[00:00.000 --> 00:18.800]  Ну что? Всем привет, товарищи. Сегодня будет жесть. Заранее предупреждаю. Я второй год подряд думаю
[00:18.800 --> 00:24.440]  наконец-то на вот именно эту лекцию, принести там какую-нибудь мантию, такой вот капюшон,
[00:24.440 --> 00:30.880]  свечи расставить здесь, потому что ближе к концу мы будем настоящим колдовством заниматься.
[00:30.880 --> 00:43.360]  Но в целом, что? Тут сложное разделение, не готов ответить на этот вопрос, давай после пары. В целом
[00:43.360 --> 00:47.800]  наша цель сегодня это отрефлексировать над своим поведением, а еще над структурами,
[00:47.800 --> 00:55.360]  янамами и прочими штуками. Ну и первая вообще такая самая простая шняга, которую можно сделать.
[00:55.360 --> 01:01.440]  Ну да, никого не смущает, что мы рефлексии собрались заниматься, хотя ее нет в C++. Сейчас речь
[01:01.440 --> 01:07.200]  не о пропузелах, которые есть, о том, что давайте добавим нормальную рефлексию, о том, что уже
[01:07.200 --> 01:16.160]  сегодня вы можете взять, добавить в свои продакшн и очень разгневать этим всех. Потому что это
[01:16.160 --> 01:27.960]  write only code, как ты выразился. Понять, что происходит невозможно. Отличная идея. Ну окей, в общем,
[01:27.960 --> 01:33.720]  на вашей совести использовать это не использовать, добавлять, не добавлять, мое дело только рассказать.
[01:33.720 --> 01:42.680]  Первая такая темка, это имена просто отрефлексировать. Что мы хотим? Есть там структура,
[01:42.680 --> 01:50.920]  янам, функция что-то там в коде написанная, и мы хотим в constexpr получить строку, в которой написано
[01:50.920 --> 02:02.280]  имя этой сущности. То есть тип, функция, поле, элемент янама, сам янам, ну это тоже тип. Ну в принципе,
[02:02.280 --> 02:12.040]  все научимся сегодня. Есть несколько подходов, все из них плохие, так и дальше будет.
[02:12.040 --> 02:20.560]  Конечно же, можно при процессорзвязать, всегда можно. Ну что предлагается? Взять какой-то define
[02:20.560 --> 02:26.400]  сделать, вместо того, чтобы писать просто класс, писать через define класс, там как-то подсовывать
[02:26.400 --> 02:34.720]  имя, через решетку его получать. Решетку знаете, да? Она токен какой-то, который пришел как аргумент
[02:34.720 --> 02:41.960]  в функциональный макрос, превращает в строку, строковый литерал именно. То есть вот прям вот в
[02:41.960 --> 02:57.600]  compile-time получили ровно то, что хотели. Но это скучно. Почему? Ну что, да, можно по-другому это как-то
[02:57.600 --> 03:06.320]  подкостылять. Ну там написано вариации, тут масса разных. Можно свободную функцию, можно переменную
[03:06.320 --> 03:12.240]  извести. Столько всего придумало человечество в этом плане, но хорошо все равно никогда не выходит.
[03:12.240 --> 03:26.720]  Хорошо вышло у жуликов. Жулиничать можно так. Да, нас тут game development. Здесь вы видите код не
[03:26.720 --> 03:36.560]  совсем на C++. В этом залог как бы успеха. Это вот Uclass, это вроде как и макрос, и когда у вас там
[03:36.560 --> 03:43.760]  какая-нибудь IDE вам отображает код ваш, этот макрос определен и превращается в ничего, но на
[03:43.760 --> 03:51.480]  самом деле, когда вы билдите ваш проект с вот такими вот штуками, запускается некоторый
[03:51.480 --> 03:59.520]  препроцессор кода. И этот препроцессор с помощью какого-нибудь кланга, как библиотеки парсит весь
[03:59.520 --> 04:06.120]  ваш код, находит все классы помеченные вот такой штукой и генерирует для них какой-то код,
[04:06.120 --> 04:19.120]  в котором, например, может быть написано имя в том числе. Да, и генерируется код в некоторый
[04:19.120 --> 04:26.680]  файлик дод generated.h. Ну, соответственно, предполагаем, что это вот все в файлике myobject лежит.
[04:26.680 --> 04:32.520]  Вы его инклюдите руками, и у вас там какие-то макросы появляются уже настоящие, которые
[04:32.520 --> 04:40.960]  разворачиваются в, например, имя этого класса. Ну, это реальный пример, если что, из вот Unreal
[04:40.960 --> 04:49.840]  Engine, там ссылочка есть, она не уехала, не уехала. Это работает не только в Unreal Engine, очень много
[04:49.840 --> 04:55.280]  таких разных фреймворков для написания всяких приложений, игр и так далее, где такие техники
[04:55.280 --> 05:00.920]  используются, пишут свой препроцессор, и все довольны. В принципе, это, наверное, даже самый
[05:00.920 --> 05:08.000]  лучший подход. Если вам все-таки нужна рефлексия в C++ в современном мире, делайте вот так. Оно надежное,
[05:08.000 --> 05:13.080]  работает, легко поддерживаемое, легко читаемое. Да, порог вхождения увеличивает, потому что,
[05:13.080 --> 05:19.280]  если вы неподготовленный разум, придете писать код на Unreal Engine с знанием плюсов, то вот это вот
[05:19.280 --> 05:24.880]  заставит вас задуматься, что происходит, что за generated, что тут какие-то непонятные макросы.
[05:24.880 --> 05:37.560]  Ну, не сильно сложно, поэтому можно терпеть. Код ген, да. Он сам вообще запускается,
[05:37.560 --> 05:42.000]  но и мы можем сами. Ну, там очень сложный пайпланет того, как билдится игра на Unreal Engine.
[05:42.000 --> 05:47.240]  Но первым делом там действительно запускается код ген, и он генерирует вот этот файл. В нем там
[05:47.240 --> 05:53.480]  куча всего пообъявлена. Например, macros generatedBuddy. Вот вы этот файл include'ите и generatedBuddy
[05:53.480 --> 05:59.800]  вписываете, и вы довольны. Вам сюда вкидывают всякие методы типа getName или getClassName.
[05:59.800 --> 06:14.760]  Ну, как бы мы расширили язык C++ своими собственными костылями, потому что комитет никак не может
[06:14.760 --> 06:25.440]  договориться, как это в язык строить. Ну да, в принципе это обычное дело. Какой-то сеньор в Epic
[06:25.440 --> 06:30.720]  Games сидит, мейнтейнет тулзу на C-шарпе написанную. Как он решил, оно работает, так оно и работает.
[06:30.720 --> 06:37.840]  Ну, то есть вообще этот предпроцессор я могу просто как-то не писав код на Unreal Engine,
[06:37.840 --> 06:43.200]  я могу свой проект забрать как процессор. Их предпроцессор от Unreal Engine? Не знаю,
[06:43.200 --> 06:50.160]  можешь попробовать, но скорее всего там из-за какого-нибудь legacy он достаточно плотно в костылен.
[06:50.160 --> 06:57.240]  Но это пишется достаточно легко, я даже думаю какую-нибудь задачу такую штуку дать. То есть у нас
[06:57.240 --> 07:03.200]  тоже есть свой предпроцессор в нашей компании, прекрасно работает, всякую рефлексию он не
[07:03.200 --> 07:12.240]  генерирует, он там для других целей. В общем делается много где, давайте пойдем дальше. Кошерный
[07:12.240 --> 07:23.040]  вариант. Кроме Аркадия, видели ли вы когда-нибудь вот такой macros pretty function? Нет. Догадайтесь,
[07:23.040 --> 07:34.600]  что он делает? Пару имен функций. Нет, macros он ничего не возвращает, macros он заменяется на что-то.
[07:34.600 --> 07:41.680]  Заменяется на пару, имя функции и указательная функция. Ну то слишком много умнейшая при процессоре
[07:41.680 --> 07:48.840]  из ACC, просто на имя функции, строковый литерал. Вот этот macros заменится на плюс-минус то, что
[07:48.840 --> 07:57.040]  написано вот здесь, но в кавычках. То есть возьмем какую-нибудь структуру foo и попробуем вот этот
[07:57.040 --> 08:11.320]  хелпер запустить. Что нам выведут? Как вы думаете? Ну что такое авто зарезолвит? Ну в целом да. То есть
[08:11.320 --> 08:16.280]  конечно правильный ответ здесь до черт его знает, это нестандартная фичар, ширине компилятора,
[08:16.280 --> 08:22.440]  оно поддерживается всеми мажорными компиляторами и даже минорными скорее всего, но как бы никто
[08:22.440 --> 08:27.560]  вам не гарантирует ничего про то, как это по факту работает, но по факту почти на всех компиляторах
[08:27.560 --> 08:38.360]  оно работает вот так. То есть вам обязательно напишут, что там за t получилось. Вот, да я прав-то
[08:38.360 --> 08:44.400]  сказал зачем-то, не прав-то речь, про t. Да, вот оно действительно написало, что t это foo. Ну что,
[08:44.400 --> 08:54.880]  поняли как получать имена всего вообще на свете? Ну подсказка еще. Нужно вам имя класса. Запускайте
[08:54.880 --> 09:05.400]  такой хелпер, берете под строку от равно до закрывающей квадратной скобки победа. Нужно вам
[09:05.400 --> 09:12.720]  название элемента янама, ну хорошо, название элемента янама это как бы не тип, сюда его передать
[09:12.720 --> 09:19.040]  нельзя, ну какие проблемы, на авто b заменим и все будет работать. А это может в Compile Time работать?
[09:19.040 --> 09:26.160]  Это и работает в Compile Time. То есть в Compile Time я могу запарсить и достать вот эту фуфу. Ну конечно,
[09:26.160 --> 09:36.760]  тебе это и будет требоваться в домашке. Ну надо, тут для краткости опущено. Ну конставала даже надо,
[09:36.760 --> 09:43.400]  потому что еще раз, вот это macros, macros он заменяется текстово на что-то, на вот эту строку он
[09:43.400 --> 09:48.920]  заменяется. Вот прям вот написав вот такую вот штуку здесь, вы как будто бы написали прямо в коде
[09:48.920 --> 09:54.880]  return, кавычка, вот такая строка, кавычка. Почему бы этой функции, которая просто ретернет строковой
[09:54.880 --> 10:01.000]  литерал, не быть конставал? Никаких проблем. То есть это действительно в Compile Time позволяет
[10:01.000 --> 10:08.680]  рефлексировать любые имена. То есть общий план такой, просто вот берем вот под строку из этого
[10:08.680 --> 10:18.320]  претифанкшена и мы победили. Но вот нюансы. Во-первых, при разных сущностях, то есть элементах
[10:18.320 --> 10:24.280]  янама, типах, еще чем-то, вы будете получать разные строки и вам по-разному нужно под строку
[10:24.280 --> 10:31.080]  убрать. То есть там за хардкодить offset не получится. И разные компиляторы в разном формате эту
[10:31.080 --> 10:47.800]  строку выводят. А что ты будешь вайнить? МСВЦ решил, что надо в треугольных скобках выводить.
[10:47.800 --> 10:55.240]  Все равно. Ну как бы, я думаю, все вы справитесь посмотреть на формат, в котором выводит конкретный
[10:55.240 --> 11:03.400]  компилятор. Тут, я не помню, клан коллега СС. Ну что-нибудь такое, да. То есть вы справитесь,
[11:03.400 --> 11:09.080]  имея десяток таких примеров, как выглядит тип при подстановке сюда, взять и общий алгоритм
[11:09.080 --> 11:15.240]  найти, который всегда работает. Просто эту работу надо будет проделать много раз. Для разных
[11:15.240 --> 11:22.840]  компиляторов, разных систем может быть даже. Ну короче, много проблем, но это делается. И мы
[11:22.840 --> 11:30.200]  получим кусочек библиотеки Magic Yanom, в которую это все уже за вас реализовано. Долго, сложно,
[11:30.200 --> 11:47.800]  муторно и печально. А почему не добавить этот стандарт, чтобы фиктированная была реализация?
[11:47.800 --> 11:59.720]  Нет, не просто поэтому. Аркадий, твоя версия? Давай без шуток, нужна серьезная версия.
[12:00.360 --> 12:08.120]  На самом деле, стандарту очень тяжело обратную совместимость ломать. Если в стандарт добавить
[12:08.120 --> 12:25.200]  вот такую штуку и четко специфицировать, что выводится. Да нет, даже не в этом проблема.
[12:25.200 --> 12:35.040]  И что? Какие проблемы? Два нижних подчеркивания, СТД подчеркивание, pretty function. Все, все проблемы
[12:35.040 --> 12:46.480]  решены. Тем более... Ну не с шаблоном, просто макрос. Речь идет о макрос. Стандарты хотят с
[12:46.480 --> 12:50.520]  рефлексией добавить, чтобы вот такой фигней не заниматься, рефлексия будет, все будут счастливы.
[12:50.680 --> 12:57.440]  Пока вот так. Почему макрос не стандартизировать? Потому что, возможно, он даже стандартизирован,
[12:57.440 --> 13:02.000]  но он спецификает, к чему он приводится. Почему нельзя строгий формат зафиксировать,
[13:02.000 --> 13:07.120]  к которому функции выводится? Потому что, во-первых, невозможно определиться, какой конкретно формат
[13:07.120 --> 13:13.800]  использовать. Во-вторых, не обратная совместимость, а совместимость в будущее. Это как forward
[13:13.800 --> 13:19.880]  compatibility. Когда мы новые фичи в язык будем добавлять, вот этот формат придется как-то
[13:19.880 --> 13:26.800]  эволюционировать. И там внезапно могут возникнуть какие-то неоднозначности, что типа можно вот так
[13:26.800 --> 13:31.800]  интерпретировать, а можно всяко из-за появления новых фичей. Ну и придется старые менять. И вот
[13:31.800 --> 13:39.840]  этого хотят всеми силами избежать. Ну типа по тем же причинам, что там мы смотрели копию, алгоритм,
[13:39.840 --> 13:46.160]  из RNG, когда про неблоиды говорили. Вот по тем же причинам, что старый алгоритм нельзя поменять,
[13:46.160 --> 13:50.680]  нельзя будет поменять спецификацию того, что выводит про эти функции, потому что код уже написан.
[13:50.680 --> 13:55.160]  И те же самые проблемы с рефлексией. Не будет возможности там эту рефлексию как-то менять,
[13:55.160 --> 14:03.760]  если что-то в языке поменяется. И из-за этого большие вопросы и проблемы. То есть, внося изменения
[14:03.760 --> 14:08.560]  сегодня, мы должны понимать, что через 10 лет нам нужна будет с ними обратная совместимость.
[14:08.560 --> 14:12.520]  Если мы неаккуратно что-то такое добавим, могут быть проблемы. Но по факту, мне кажется,
[14:12.520 --> 14:19.440]  никто просто не пытался принести бумагу, которая предлагает стандартизацию вот этого. Может быть,
[14:19.440 --> 14:24.960]  если вы ее принесете и хорошо обоснуете, почему вот проблемы, которые я описал, не будет, то ваше
[14:24.960 --> 14:37.000]  предложение примут и все будет круто. Ну тоже начнутся споры, что этот зоопарк целый будет, все
[14:37.000 --> 14:42.880]  офигеют, как это мой учитель, ну короче, ты не победишь бюрократию, комитет стандартизации.
[14:42.880 --> 14:48.760]  И тем более, когда вот-вот будет готова рефлексия, согласно некоторым мнениям, еще чуть-чуть надо
[14:48.760 --> 14:56.600]  подождать, зачем нам втаскивать такую фигню. Все, мы достаточно. Рефлексию планируют 26 запихнуть.
[14:56.600 --> 15:03.920]  Очень хотят. И шансы пока есть. Там выделили минимальный набор вещей, очень четко обоснованных,
[15:03.920 --> 15:09.040]  почему они сделаны так. И даже с ними уже мы таких дров можем наломать. Правда,
[15:09.040 --> 15:15.120]  мне половину курса выкинуть надо будет. И посвятить его рефлексии новой, если ее таки втащат. Ну ладно,
[15:15.120 --> 15:24.960]  давайте дальше ехать. Кажется, все, да? Библиотека, в которой все это уже за вас написано. Теперь про
[15:24.960 --> 15:30.880]  янамы. То есть, янамы у всего научились, конечно, выводить, но у янамов есть еще некоторое количество
[15:30.880 --> 15:38.320]  информации. Название самого янама и название элементов янама хочется. Это мы уже умеем. А вот
[15:38.320 --> 15:45.680]  количество элементов и получать как-то элемент по номеру или элемент янама по строке этого мы не умеем.
[15:45.680 --> 15:54.120]  То есть, что я подразумеваю под номером. У вас написано в самом янаме список его полей. И они
[15:54.120 --> 16:02.200]  в каком-то порядке. Но значения у них могут быть абсолютно разные. Да, это вы узнаете. И хочется и
[16:02.200 --> 16:09.560]  номер в значение перегонять и обратно, и в строку, и обратно, и чтобы вот это все просто мапилось
[16:09.560 --> 16:17.240]  друг в друга как угодно. Ну, давайте изобретать. Первое изобретение это, конечно же, препроцессорные
[16:17.240 --> 16:26.120]  преступления. Это вполне работает. Тоже у многих там в проде крутятся такие приколы. Но тут беда в том,
[16:26.120 --> 16:31.240]  что людей не заставить вот так весь код писать. Поэтому начинается, что на кодовую базу типа
[16:31.240 --> 16:38.160]  гугловской пять раз переизобретен такой макрос по-разному, и там пять раз по-разному где-то
[16:38.160 --> 16:43.920]  использован, где-то не использован. Ну, в общем, можно, но не нужно.
[16:43.920 --> 16:49.320]  Мне кажется, тут нужно не забыть упомянуть, как парстить этот эллипсис.
[16:49.320 --> 16:58.280]  Как вот это вот использовать? Ну, кто знает, как вот этот вот эллипсис превратить в список
[16:58.280 --> 17:14.040]  еномерантов? ВАААРКС. Так, если мы ВААРКС напишем, то он нам через запятую все,
[17:14.040 --> 17:25.800]  что сюда вписано, напишет. Что еще надо? А, если ты... Да, ты абсолютно прав, что я тут лукавлю и
[17:25.800 --> 17:30.880]  опускаю кучу деталей, потому что нам вообще на этот список через запятую написанных каких-то строк
[17:30.880 --> 17:43.760]  нужно навесить, замапить какую-то функцию, которая превратит их в строки. Ну, можно. Это делается,
[17:43.760 --> 17:49.280]  как я сейчас рассказывать. Не буду, будет отдельная лекция про макросы, там подобные идеи будут
[17:49.280 --> 17:54.800]  рассказаны. Можно проще сделать, можно это все просто как-то сконкатенировать и запихнуть в
[17:54.800 --> 18:02.480]  строковой литерал и не париться. Ну, короче, делается. Давайте дальше. Unreal Engine, как всегда,
[18:02.480 --> 18:09.400]  не подводит. У них простая, понятная система. Вот за это их бесконечное уважение им. Потому что вы
[18:09.400 --> 18:22.320]  опять какой-то ю и нам пишете, но это не будем обсуждать, что такое. В плане. Это чтобы у тебя
[18:22.320 --> 18:28.800]  вот эту вот штуку можно было в блюпринтах использовать. Ну, ладно. Вот такие они добавили
[18:28.800 --> 18:34.320]  сюда макросы, которые, конечно же, при компиляции флесового кода разворачиваются в ничего, но там
[18:34.320 --> 18:39.280]  когда вот помните, я говорил, файл include, который что-то там генерирует, вот там где-то будет какая-то
[18:39.280 --> 18:47.480]  функция toString, которая вот эти вот имена как-то все выдаст вам. Зачем отдельно display name какой-то,
[18:47.480 --> 18:53.400]  если можно просто вот это вот имя вытащить? Ну, вот тут про блюпринты как раз. У них там есть
[18:53.400 --> 19:00.280]  редактор, который из кубиков позволяет код писать. Вы работали с таким когда-нибудь в школе? Кубики
[19:00.280 --> 19:07.080]  такие соединяешь и типа код. Алгоритмы всякие. Нет? Ну, ладно. Короче, давайте просто считать,
[19:07.080 --> 19:11.200]  что это какой-то туллинг, какие-то инструменты с какими-то интерфейсами пользовательскими,
[19:11.200 --> 19:16.560]  и вот там необходимо показывать ваши янамы. Причем показывать не другим программистам,
[19:16.560 --> 19:24.840]  а художникам и дизайнерам. Им хочется для ваших, ну, когда они должны выбрать из какого-то набора
[19:24.840 --> 19:28.960]  вариантов какой-то конкретный вариант, это же у вас код и янам, вот им хочется нормальные имена
[19:28.960 --> 19:34.400]  иметь, и вот если вы имеете суперпроцессор, вы даже такие фокусы можете утворять. Очень приятно.
[19:34.400 --> 19:46.280]  Ну, это все неинтересно. А, ну, еще одно жульничество. Можем просто соглашение принять, что у нас
[19:46.280 --> 19:55.480]  всегда каунт будет в конце янама, и если янам подряд элементы у него значения имеют, то мы можем
[19:55.480 --> 20:01.880]  всегда найти их количество, а если они подряд, то и как бы и номера, и в общем проблема решена.
[20:01.880 --> 20:07.000]  То есть, ну, большое количество кейсов вот даже так можно покрыть, но опять же,
[20:07.000 --> 20:12.320]  такому соглашению никто не будет в большой кодовой базе следовать, будет забываться,
[20:12.320 --> 20:22.520]  переизобретаться, ну и беда. А теперь давайте, как бы, хорошее решение. Ну, хаки, конечно,
[20:22.520 --> 20:30.040]  но оно универсальное и не использует никаких припроцессоров. Так, есть helper, есть янам.
[20:30.040 --> 20:40.160]  Вот мы вывели фуа, да, и, ну, как я уже говорил выше, можно авто поставить сюда и будет нам
[20:40.160 --> 20:47.840]  выводиться, что там вот это t это фуа. Ага, теперь вопрос, а вот если мы при статике кастим 10 к фу,
[20:47.840 --> 20:54.520]  это не является элементом янама, строго говоря, да, здесь элементы 0, 1, 2, а мы при статике касте или
[20:54.520 --> 21:06.800]  10 и пытаемся вывести, что будет? Ну, если бы вы писали компилятор, что бы вы здесь вывели? Ну, именно так.
[21:06.800 --> 21:17.120]  Ну что, поняли, как понять, сколько в янаме элементов, какие у них номера и так далее?
[21:17.120 --> 21:28.880]  Если мы вместо 10 и 1 напишем, то нам выведут b.
[21:28.880 --> 21:42.440]  Вот оба варианта правильные, да, мы просто будем перебирать, можно бинпоискам и до какого-то момента,
[21:42.440 --> 21:51.680]  ну, да, оговорка, янамы бывают sparse, когда здесь не подряд идут значения, а там вообще рандомные
[21:52.680 --> 22:02.720]  В таком случае никакой бинпоиск не сработает. Ну, в целом, да, ну давайте линейный поиск, будем подряд идти от чего-то до чего-то и искать, что тут есть.
[22:02.720 --> 22:15.040]  Вопрос, от чего до чего? От 0 до f max. В смысле от 0 до f max. Сколько это времени займет по факту?
[22:15.040 --> 22:27.600]  Умная жесть. Нет, ну по факту это займет там несколько секунд вроде как, да, ну секунду, две, три может быть.
[22:27.600 --> 22:34.080]  А тем более, что плюсы в Compile Time это интерпретируются, а не компилируются, так что там еще нужно на 10.
[22:34.080 --> 22:40.880]  Короче, это будет занимать крайне и крайне долго. Ну, нормального ответа здесь нету.
[22:40.880 --> 22:50.240]  Я предлагаю минус 500 до плюс 500 и, наверное, хватит. Ну, для всех адекватных случаев должно.
[22:50.240 --> 23:05.040]  Если кому-то не хватает, то предлагается руками указать лимиты, а если кто-то сделал настолько sparse и янам, что там вообще минус миллион, плюс миллион, то вообще не надо с такими людьми общаться.
[23:05.680 --> 23:12.080]  Еще одна функция, HelperBase и функция Helper, можно будет указать перегрузки для данной.
[23:12.080 --> 23:14.080]  Что, перегрузки?
[23:14.080 --> 23:19.120]  Не перегрузки, можно вынести клаш, чтобы делать спецификации для данных типов.
[23:19.120 --> 23:33.200]  Да, можно сделать trade. Внимание, у нас была тема trade, и вот про что она была, про то, чтобы выносить решение о типах куда-нибудь вне текущего контекста.
[23:33.200 --> 23:39.760]  Вот нам в текущем контексте нужно понять, от чего до чего бегать или вообще какие значения проверять.
[23:39.760 --> 23:49.360]  Ну, давайте по дефолту что-то адекватное будем делать. Если кому-то дефолта не хватает, через trade попросим их самих указать для их и нам, сколько и где им надо бегать.
[23:49.360 --> 23:54.800]  Битфилд, битвей ставится, если где-то там что-то.
[23:54.800 --> 23:58.800]  Ну, что-нибудь придумать. Я, если честно, не думал в эту сторону.
[23:58.800 --> 24:01.760]  Указать рандомный генератор чисел.
[24:02.400 --> 24:06.400]  Отличная идея. Нет, короче, можно это все добить.
[24:06.400 --> 24:31.200]  То есть наш план такой, вернее ваш план на домашнюю, пройтись от нуля до 500 или 100-500, проверять, что вот этот вот helper выдает нормальное что-то, а не просто прикасченное число для ишки прикасченных к фу, и в принципе все узнали, и порядок, и количество.
[24:31.440 --> 24:42.240]  Наверное еще будет момент, что у нас в контексте контакт-сверхпульса ограничены числа операций.
[24:42.240 --> 24:47.120]  Ну, поэтому там подогнано так, чтобы у вас все влезло, если вы напишите хорошее решение.
[24:47.120 --> 25:00.640]  Внимание! В этой задаче, ну, в задаче по мотивам вот этой вот темы очень легко упереться в всякие лимиты, и в TL, и в лимиты рекурсии в compile-time, чтобы этого не происходило.
[25:00.640 --> 25:15.520]  Поэтому надо писать максимально аккуратный, простой код, ну, то есть в моем решении рекурсии вообще нет, то есть вот мы до сих пор многие всякие шаблонные вычисления делали рекурсии, но, оказывается, можно не только рекурсии.
[25:15.520 --> 25:17.520]  Ну, вот сейчас...
[25:17.520 --> 25:19.520]  Fold expression.
[25:20.400 --> 25:22.400]  И да, все.
[25:22.400 --> 25:33.440]  Ну, короче, в конце чуть-чуть попишем код, я вам покажу трюк, по-моему, я уже показывал его мимолетом, но вдруг вы забыли, вот он тут пригодится, чтобы не упереться в лимиты рекурсии.
[25:33.440 --> 25:39.600]  Ну, и итоговый код, если его хорошо написать, он простой, понятный и быстрый, там буквально 100 строчек.
[25:39.600 --> 25:45.280]  Вот, так что если вы начали что-то суперсложное оградить, всегда задавайтесь вопросом.
[25:46.080 --> 25:54.640]  Что-то пошло не так, наверное, может, где-то я не додумал или перепридумал, вот, но это вообще по жизни хороший совет.
[25:54.640 --> 26:02.640]  Вот, про compile time циклы будет в конце, да, наверное, я обычно тут прерывался на это, но не хочу сейчас прерываться.
[26:02.640 --> 26:09.360]  Сейчас, а с куку у нас времени, мы вроде бодро идем, но надо следить.
[26:09.360 --> 26:11.360]  40 минут прошло.
[26:12.080 --> 26:17.200]  Так. Писать сейчас. Ладно, давайте сейчас напишем.
[26:20.400 --> 26:23.760]  Ну, потому что техника простая, и лучше ее прямо сейчас показать.
[26:26.000 --> 26:34.080]  Да, да, да, да, да, просто сейчас, спойлеры, спойлеры, спойлеры, вот так, все, ничего не видели.
[26:35.040 --> 26:41.040]  А, ну и правильно, ну и хорошо, а...
[26:41.040 --> 26:45.040]  Нет, потому что не так с контрастом.
[26:45.040 --> 26:49.040]  Да, да, да, ничего видно не должно быть, все плохо, сейчас.
[26:55.040 --> 27:04.000]  Опа, опа, смотрите, как хорошо и видно все стало, но тут у меня какая-то фигня написана уже.
[27:04.960 --> 27:06.960]  Ну, это неправильно написано, потому что там так четко.
[27:06.960 --> 27:08.960]  Ну, в целом, я хочу сделать так.
[27:12.960 --> 27:18.960]  Сколько там элементов? 5, да, ведь? Да, 5.
[27:18.960 --> 27:22.960]  Хочу так написать, но не могу. Почему?
[27:23.920 --> 27:35.920]  Так, давайте придумывать что-то более простое и понятное, чем...
[27:36.880 --> 27:42.880]  Это же понятно, как во многих языках, применяя язык, проходит не в языке, а в стольных гигераторах.
[27:44.880 --> 27:46.880]  Есть STD Apply.
[27:48.880 --> 27:50.880]  STD Apply даст вам индекс?
[27:50.880 --> 27:52.880]  Да.
[27:56.880 --> 28:00.880]  Можно, давайте напишем свой STD Apply лучше, чем использовать который...
[28:00.880 --> 28:02.880]  Ну да, это все правда.
[28:06.880 --> 28:10.880]  Ну вот, два человека знают, поэтому давайте, наверное, просто писать.
[28:14.880 --> 28:22.880]  Ну, первая мысль, давайте сделаем лямбду, у которой есть шаблонным аргументом вот это самое i.
[28:23.840 --> 28:37.840]  И как бы теперь мы хотим эту лямбду запустить много раз для каждого i в такой штуке, как STD Index Sequence.
[28:38.800 --> 28:40.800]  Ну и...
[28:44.800 --> 28:46.800]  Давайте как раз вот это вот я скопипасчу.
[28:48.800 --> 28:52.800]  То есть про Index Sequence все знают или надо рассказать чуть-чуть?
[28:54.800 --> 28:58.800]  Ну это такой волшебный класс. Почему у меня кланкдэ не работает?
[28:58.800 --> 29:00.800]  Что такое?
[29:01.760 --> 29:03.760]  Не получается, да?
[29:06.760 --> 29:08.760]  Получилось.
[29:09.760 --> 29:13.760]  Это по сути то же самое, что Integer Sequence, а Integer Sequence это тупейшая штука.
[29:13.760 --> 29:19.760]  Вот у нее есть шаблонный тип T и пак значений типа T.
[29:21.760 --> 29:23.760]  И все.
[29:23.760 --> 29:25.760]  Ну и еще size.
[29:25.760 --> 29:27.760]  Ну да, можно size.
[29:28.720 --> 29:30.720]  Ну и еще size.
[29:30.720 --> 29:32.720]  Ну да, можно size получить, это количество элементов.
[29:32.720 --> 29:37.720]  То есть это на самом деле compile time, последовательность чисел.
[29:38.720 --> 29:40.720]  Ну не только чисел, но чисел.
[29:40.720 --> 29:42.720]  Type tuple, по сути.
[29:42.720 --> 29:44.720]  Ну наш type tuple.
[29:44.720 --> 29:49.720]  Ну как бы да, но type tuple хранит в себе типы, а вот эта штука хранит в себе числа.
[29:49.720 --> 29:55.720]  Идейно оно используется, чтобы какие-то последовательности индексов и прочего-прочего хранить.
[29:56.680 --> 29:59.680]  Эта штука вам очень поможет в домашке про инамы.
[30:07.680 --> 30:09.680]  Да, я не тот шаблон написал.
[30:09.680 --> 30:11.680]  Вот make index sequence есть.
[30:11.680 --> 30:15.680]  То есть я показал index sequence, это просто Integer Sequence на size t.
[30:15.680 --> 30:17.680]  Потому что у нас индекс это size t.
[30:17.680 --> 30:19.680]  А есть шаблон make index sequence.
[30:20.640 --> 30:25.640]  Которое создаст нам, ну то есть сейчас вот тут tuple size это 5.
[30:25.640 --> 30:31.640]  И вот этот тип make index sequence, он будет, давайте даже напишем.
[30:35.640 --> 30:43.640]  Вот эта шняга должна быть same as index sequence.
[30:44.600 --> 30:50.600]  index sequence 0, 1, 2, 3, 4 и все.
[30:50.600 --> 30:52.600]  Потому что у нас 5 элементов.
[30:52.600 --> 30:54.600]  Не make, просто index sequence.
[30:54.600 --> 30:56.600]  Работает.
[30:56.600 --> 30:58.600]  То есть вот это число это 5.
[30:58.600 --> 31:04.600]  И шаблон make index sequence генерирует нам index sequence, в котором написаны числа от 0 до 4.
[31:04.600 --> 31:06.600]  Ну то есть до 5 не включая.
[31:07.560 --> 31:13.560]  Теперь мы хотим как бы взять и замапить вот эту лямду по шаблонному параметру внезапно.
[31:13.560 --> 31:15.560]  На вот эту последовательность.
[31:17.560 --> 31:19.560]  А как это сделать?
[31:20.560 --> 31:22.560]  Идеи предложения.
[31:23.520 --> 31:25.520]  Сейчас.
[31:30.520 --> 31:34.520]  Ну для начала мы наверное хотим.
[31:38.520 --> 31:40.520]  Какой брейк нет.
[31:41.520 --> 31:44.520]  Я не пробовал и даже не слышал, что так можно.
[31:50.520 --> 31:51.520]  А ну.
[31:53.520 --> 31:55.520]  Брейк можно, хитро можно.
[31:55.520 --> 31:57.520]  Нет никакого брейка не нужно.
[32:07.520 --> 32:09.520]  Вот это хорошая идея.
[32:09.520 --> 32:11.520]  Взять и распаковать пак.
[32:11.520 --> 32:15.520]  Потому что как мы помним, когда у нас в шаблоне есть пак аргументов.
[32:15.520 --> 32:17.520]  Как вот здесь.
[32:17.520 --> 32:20.520]  Мы не можем его никак наружу шаблона вытащить.
[32:21.480 --> 32:24.480]  Это не является какой-то первоклассной сущностью в языке.
[32:24.480 --> 32:28.480]  Единственный способ достать вот этот вот пак и дальше с ним как-то работать.
[32:28.480 --> 32:31.480]  Это использовать другой шаблон.
[32:31.480 --> 32:34.480]  Какие-нибудь частичные специализации, вот это все.
[32:34.480 --> 32:37.480]  То есть когда мы там function писали, мы то же самое делали.
[32:37.480 --> 32:39.480]  Распаковывали шняги через.
[32:45.480 --> 32:49.480]  Нет, давай проще.
[32:50.440 --> 32:52.440]  Ты хочешь свой оператор запятая написать сейчас, да?
[32:56.440 --> 32:58.440]  Сейчас все будет.
[33:00.440 --> 33:02.440]  Внимание на экран.
[33:02.440 --> 33:06.440]  Чтобы применить fold expression нужно сначала иметь пак как пак.
[33:06.440 --> 33:09.440]  Потому что если мы вот просто такую вот штуку написали.
[33:09.440 --> 33:11.440]  Там index sequence.
[33:11.440 --> 33:13.440]  Это какой-то тип, а не пак.
[33:13.440 --> 33:15.440]  Мы с ним ничего сделать дальше не можем.
[33:15.440 --> 33:17.440]  Поэтому, смешнейший трюк.
[33:17.440 --> 33:19.440]  Я запихиваю вот эту лямду.
[33:19.440 --> 33:21.440]  Где мы пытаемся получить...
[33:25.440 --> 33:29.440]  Где мы хотим и запихиваем в другую лямду.
[33:29.440 --> 33:31.440]  Которая принимает пак.
[33:31.440 --> 33:36.440]  Сразу запускаю эту лямду от make index sequence.
[33:36.440 --> 33:41.440]  А здесь через вывод типа аргумента.
[33:41.440 --> 33:43.440]  Ну ketad.
[33:43.440 --> 33:45.440]  Нет.
[33:45.440 --> 33:47.440]  Type argument deduction.
[33:49.440 --> 33:51.440]  Вывод типа по аргументам.
[33:51.440 --> 33:55.440]  Я здесь напишу как аргумент index sequence.
[33:55.440 --> 33:57.440]  В котором вписан вот этот пак.
[33:57.440 --> 34:01.440]  И мне type deduction увидит.
[34:01.440 --> 34:03.440]  О, передали вот такой тип.
[34:05.440 --> 34:09.440]  Он, мы убедились, выглядит как index sequence от 0.1.2.3.4.
[34:09.440 --> 34:13.440]  Соответственно в этот пак у меня попадет 0.1.2.3.4.
[34:13.440 --> 34:17.440]  Да, кажется надо так писать, чтобы у меня сейчас скомпилировалось вообще что-то.
[34:17.440 --> 34:19.440]  Отлично.
[34:19.440 --> 34:21.440]  Теперь у нас есть пак, и тут уже много раз сказали.
[34:21.440 --> 34:23.440]  А давайте делать fold expression.
[34:23.440 --> 34:27.440]  Есть тут люди, которые не знают про fold expression.
[34:27.440 --> 34:29.440]  Ага, супер.
[34:29.440 --> 34:31.440]  Fold expression это очень смешная вещь.
[34:31.440 --> 34:33.440]  Вот есть у нас пак целых чисел.
[34:33.440 --> 34:39.440]  Внезапно можно написать вот так C++.
[34:43.440 --> 34:47.440]  Не важно.
[34:47.440 --> 34:51.440]  Какая будет сумма чисел от 0 до 4?
[34:51.440 --> 34:53.440]  12? 10?
[34:55.440 --> 34:59.440]  Ну, у меня всегда было плохо с рифметикой.
[34:59.440 --> 35:03.440]  Внимание.
[35:03.440 --> 35:07.440]  Ну да, это инженерный подход.
[35:07.440 --> 35:09.440]  Внимание.
[35:09.440 --> 35:11.440]  Произошла математика.
[35:11.440 --> 35:13.440]  Вот это была как бы последовательность.
[35:13.440 --> 35:15.440]  Я написал типа последовательность, плюс и так далее.
[35:15.440 --> 35:19.440]  И оно сложило все, что было в последовательности.
[35:19.440 --> 35:23.440]  И так можно делать с любым оператором.
[35:23.440 --> 35:25.440]  И любым паком.
[35:25.440 --> 35:29.440]  То есть пак не обязательно должен состоять из чисел.
[35:29.440 --> 35:31.440]  Оператор должен быть бинарный.
[35:31.440 --> 35:35.440]  С минусом не знаю, плюс умножить работает.
[35:35.440 --> 35:39.440]  Сдвиг влево, сдвиг вправо, по-моему, тоже работает.
[35:39.440 --> 35:41.440]  оператор запятая
[35:41.640 --> 35:43.640]  внезапно
[35:43.920 --> 35:47.880]  по моему да наверное и минус тоже скорее всего все работает
[35:50.800 --> 35:53.600]  оператор присваивания работает чтобы он вообще была
[36:00.520 --> 36:03.480]  да тут еще про ассоциативность может быть проблему
[36:04.080 --> 36:12.160]  потому что ну где скобки расставлять у нас некоммунативная операция там да звук влево например вот так вы сделаете у вас будет
[36:13.840 --> 36:15.840]  ассоциативность кажется вот так расставлена
[36:17.400 --> 36:19.400]  поправьте меня потому что я наизусть не помню
[36:23.440 --> 36:25.440]  вот так будет расставлена да
[36:26.320 --> 36:28.320]  понимаете в чем разница да
[36:28.440 --> 36:30.440]  можно же по-другому написать
[36:30.600 --> 36:32.600]  можно написать
[36:32.840 --> 36:34.840]  0 плюс 1 плюс 2
[36:37.280 --> 36:39.520]  плюс 3 еще скобки и
[36:40.760 --> 36:46.160]  вообще говоря если плюс это у нас не нормальный арифметический плюс а какая-то непонятная штука
[36:46.480 --> 36:54.080]  нам может быть некоммунативно не ассоциативно и нам важно в каком порядке скобки расставлять то что сейчас здесь написано расставят в первом порядке
[36:54.680 --> 36:57.360]  но никто не заставляет писать так можно написать наоборот
[36:58.360 --> 37:02.600]  3 точа плюс пак и скобки будут наоборот расставлены
[37:06.400 --> 37:07.760]  да
[37:07.760 --> 37:10.880]  к тому что вот сюда внутрь можно вписать на самом деле что угодно
[37:11.560 --> 37:18.200]  можно написать вот так и понять что все это время я вам говорил что смотрите у меня работает когда на самом деле нифига у меня не работает потому что
[37:18.440 --> 37:20.680]  там еще выше ошибки компиляции
[37:24.560 --> 37:26.560]  что почему
[37:27.360 --> 37:31.120]  где красным подчеркнуто
[37:33.920 --> 37:38.600]  почему проходит этот ассерт а потому что он в какой-то лямбде непонятно не описывается
[37:40.440 --> 37:42.440]  сейчас
[37:42.560 --> 37:48.280]  вот вот здесь я забыл фигурные скобки там уже объект собрались сюда передать чтобы оно по объекту распаковала и о
[37:48.720 --> 37:52.160]  вот теперь без двойки с десяткой о работает
[37:52.600 --> 37:54.600]  умножаем каждый элемент на два
[37:55.000 --> 38:02.400]  работает и на самом деле пак у вас может быть может состоять из типов и вы можете складывать например сайзов и типов
[38:03.680 --> 38:09.040]  или создавать новые экземпляры объектов их складывать это очень гибкая система то есть
[38:09.560 --> 38:12.040]  в общем случае это называется fold expressions
[38:15.840 --> 38:19.640]  fold expressions на cpp-reference достаточно подробно написано во всех деталях
[38:20.120 --> 38:25.920]  но в принципе его читать в большинстве случаев и не надо просто интуитивно понятно у вас есть пак и у вас есть бинарный оператор
[38:26.480 --> 38:28.480]  можете между всеми элементами
[38:29.120 --> 38:31.120]  выражения какого-то
[38:31.880 --> 38:35.920]  в котором участвует название пака взять и расставить этот бинарный оператор
[38:36.680 --> 38:38.680]  то есть если вы уже привыкли
[38:39.080 --> 38:41.880]  распаковывать паки как аргументы для чего-то дальше
[38:43.240 --> 38:45.240]  например там
[38:45.240 --> 38:50.960]  other template из три точа да мы как бы распаковали пак через запятую
[38:51.360 --> 38:55.560]  то если вы к этому привыкли и вас не смущают всякие трюки типа
[38:56.760 --> 38:59.800]  foo std forward
[39:01.400 --> 39:03.400]  тес тес
[39:03.960 --> 39:08.640]  три точа то и вот это не должно смущать потому что здесь же тоже какое-то произвольное
[39:09.280 --> 39:16.920]  выражение написано целых два пака упомянуто внимание и написано три точки оно как бы распаковывается через запятую и передает эти аргументы
[39:17.880 --> 39:24.360]  тут смысл такой же любое выражение написали написали бинарный оператор и три точки и оно распаковывается
[39:26.560 --> 39:30.720]  да тут выражение 2 умножить на элемент из из
[39:33.040 --> 39:35.760]  распаковывается по паку то есть
[39:36.160 --> 39:38.460]  в итоге вот я сказал что будет
[39:39.440 --> 39:46.760]  вот так будет вот так будет вот так будет вот так и вот так то есть буквально распаковка я
[39:47.200 --> 39:54.080]  поменял выражение с просто из на два умножить на из и теперь у меня ну действительно два умножить и элементы будут
[39:55.200 --> 39:57.200]  с этим примером должно быть прям понятно
[39:58.200 --> 40:00.200]  зачем
[40:02.920 --> 40:08.920]  все надо в скобке окружать да это внимание fold expression и всегда выглядит как
[40:10.880 --> 40:12.240]  три точки
[40:12.240 --> 40:14.240]  бинарный оператор
[40:14.560 --> 40:18.960]  блямба ну доллар может быть чем угодно здесь да плюс минус умножить и
[40:19.880 --> 40:24.720]  какое-то выражение экспор и выражение должно зависеть от пака пак
[40:25.720 --> 40:27.720]  вот общий вид еще
[40:30.720 --> 40:32.720]  что
[40:35.240 --> 40:37.660]  с форвардом нет с форвардом это не
[40:38.680 --> 40:40.680]  fold expression
[40:40.800 --> 40:42.800]  это важно
[40:43.800 --> 40:45.800]  ну когда вы пишете
[40:46.240 --> 40:53.480]  где-то вы могли видеть разве слайси в спане там не было мест где нужно зафорвардить какой-то пак или в
[40:53.760 --> 40:56.040]  фанкшен мы по моему должны были видеть ну-ка
[41:01.320 --> 41:03.320]  4 да
[41:05.720 --> 41:13.000]  просто мне кажется мы это уже с вами видели и у вас не возникало а вот вот вот мы такой код с вами написали
[41:14.840 --> 41:19.000]  это не fold expression это просто говорит компилятору я хочу
[41:19.840 --> 41:21.840]  передать этой функции аргументы
[41:22.680 --> 41:24.680]  которые написаны в этом в этих паках
[41:25.880 --> 41:33.040]  то есть ну как бы есть оператор запятая это вообще отдельная бодяга пока не думайте про него а есть вот этот синтаксис который еще до fold expression
[41:33.040 --> 41:34.120]  был
[41:34.120 --> 41:36.120]  просто распаковка пака
[41:37.360 --> 41:41.640]  то есть вот это превратится в вызов там функции фу или инициализации вот этой
[41:42.320 --> 41:44.320]  переменной фу вызов ее конструктора
[41:45.040 --> 41:46.280]  от
[41:46.280 --> 41:48.600]  аргументов которые лежат вот в этом паке args
[41:49.240 --> 41:52.600]  ну вернее обработанных через вот эти вот вот это expression
[41:55.600 --> 41:59.120]  никак ну распаковка unfolding наверное
[42:04.880 --> 42:09.680]  да да да ну то есть вот это вот это не fold expression это вы просто как бы распаковали пак
[42:10.120 --> 42:16.880]  это было еще со времен царя гороха то есть одиннадцатых плюсов и это ну главное как используются паки да
[42:17.240 --> 42:23.160]  когда у нас есть пак мы его должны там либо передать в какой-то другой шаблон и для этого мы тоже три точки пишем да
[42:23.720 --> 42:31.800]  мы просто так пак не можем передать нужно обязательно три точки а ну вот еще пример да тоже три точки написали и пак как бы через запятую
[42:32.760 --> 42:34.760]  расписался
[42:34.840 --> 42:38.800]  не через оператор запятую просто через запятую как выражение
[42:39.680 --> 42:43.080]  то есть ну это все одного рода вещи
[42:43.800 --> 42:45.600]  распаковки разная да
[42:45.640 --> 42:49.600]  я почему-то считал что с этим вы уже должны были сталкиваться и не раз
[42:50.680 --> 42:53.560]  окей да ну в общем это старая этого
[42:54.560 --> 42:56.560]  это всегда было
[42:56.640 --> 43:00.360]  теперь fold expression они из 17 плюсов появились
[43:00.560 --> 43:06.040]  они именно что не просто через запятую пишут и передают как аргументы в другой шаблон или функцию
[43:06.360 --> 43:09.280]  они именно что оператор применяют плюс например
[43:09.920 --> 43:11.920]  да
[43:27.360 --> 43:30.760]  рекурсии можно добиться желаемого нами результата
[43:33.720 --> 43:39.040]  конечно тот что я сейчас расскажу потому что рекурсия это отн инстанциации разных шаблонов
[43:39.440 --> 43:45.600]  а как мы знаем инстанциация шаблона это ну то в чем измеряется собственно перв компайл тайм штук
[43:48.160 --> 43:51.840]  а это пока никак не работает я так и не рассказал главные фишки fold expression
[43:52.800 --> 43:54.800]  да
[44:07.520 --> 44:12.480]  а да ты права давай чтобы она соответствовала напишем вот так ну
[44:15.360 --> 44:17.360]  из умножить на из
[44:18.760 --> 44:20.760]  давайте сумма квадратов от 0 до 4
[44:22.240 --> 44:24.240]  н
[44:25.160 --> 44:27.600]  на н плюс 1 на н плюс 2 на 6
[44:36.960 --> 44:42.880]  ну действительно работает квадрата то есть во что это на самом деле распаковывается теперь каждый раз будет здесь написано
[44:43.320 --> 44:45.600]  соответствующий номер умножить на самого себя
[44:45.600 --> 44:52.520]  да все паки должны быть одного размера иначе будет проблема
[45:03.840 --> 45:09.480]  отличная идея периативная ну в общем как нам fold expression помогут
[45:10.360 --> 45:15.320]  я про оператор запятую что-то говорю есть такой что делает оператор запятая
[45:16.440 --> 45:18.440]  вызывает правое и затем вызывает левое
[45:19.440 --> 45:21.440]  не наоборот
[45:21.800 --> 45:24.280]  вычисляет левое потом вычисляет правое
[45:28.800 --> 45:35.440]  оператор запятая кома оператор
[45:35.440 --> 45:37.440]  ну
[45:42.640 --> 45:48.440]  когда вы его перегрузите он этого не делает но дефолтный говорит что сначала вычисляется левый оператор
[45:49.640 --> 45:52.640]  есть такой магический оператор запятая вы можете например написать
[45:53.440 --> 45:58.400]  0 запятая 1 что это делает вычисляет 0 потом вычисляет 1 и
[45:59.080 --> 46:01.280]  возвращает по моему правое да
[46:01.440 --> 46:03.440]  последнее вычисленное
[46:04.320 --> 46:08.240]  последнее вычисленное то есть значение вот этого вот выражения давайте стать
[46:08.240 --> 46:14.040]  кассирт напишем потому что все эти вещи настолько легко забываются что просто страшно да действительно правая
[46:23.920 --> 46:28.840]  да если ты что-то перегрузишь то там что-то не гарантирует давайте про перегрузку не думать это уже
[46:29.000 --> 46:34.360]  адванс штука я и сегодня не объясню я скажу просто что мы будем через оператор запятая
[46:41.160 --> 46:49.880]  да да does not contain any expanded pack параметр оп оп
[46:58.920 --> 47:02.400]  и тогда у нас должно прерваться как раз на литературе
[47:03.200 --> 47:05.200]  нет фронтайме прерваться да
[47:06.200 --> 47:09.000]  это не поможет тебе когда ты компел тайме цикл делаешь
[47:20.640 --> 47:25.440]  но вот это вот ответ да но то как сделать цикл в компел тайме
[47:25.440 --> 47:32.280]  можно вот этот и столько еще переименовать в просто и чтобы это как будто индекс был и мы в шоколаде
[47:36.280 --> 47:38.280]  понимаете что происходит
[47:40.160 --> 47:45.560]  парсить да читаемости мы не думать да да тут вот подсказка есть
[47:47.880 --> 47:49.480]  мы
[47:49.480 --> 47:55.400]  сделали выражение в этом выражении написано лямбда которая сразу запускается и внутри этой лямбда
[47:55.800 --> 47:56.840]  мы
[47:56.840 --> 47:59.480]  используем пак как будто это одно число
[48:01.200 --> 48:03.200]  вот это все выражение некоторое
[48:04.440 --> 48:12.680]  причем это выражение с паком внутри неразвернутым поэтому само по себе это выражение не скомпилируется нужно распаковать
[48:13.800 --> 48:19.760]  распаковку мы делаем посредством fold expression причем fold expression на операторе запятая
[48:20.680 --> 48:22.680]  то есть у нас через запятую
[48:22.680 --> 48:24.680]  повторится вот этот expression
[48:24.920 --> 48:26.920]  с разными индексами
[48:28.040 --> 48:30.040]  черт
[48:30.200 --> 48:36.120]  через запятую будет написано это лямбда с нулем потом это лямбда с единицей это лямбда с двойкой и так далее и
[48:37.160 --> 48:43.720]  оператор запятая нам гарантирует что сначала то что до запятой написано вычислиться потом то что после запятой
[48:44.920 --> 48:49.040]  таким образом в общем и целом мы просто пройдемся по паку в нужном порядке и
[48:50.000 --> 48:51.680]  и
[48:51.680 --> 48:56.920]  вставим в программу вот такие строчки кода по сути с разными значениями и
[48:58.240 --> 49:00.240]  такой цикл в компайл тайме
[49:05.400 --> 49:09.120]  в рон тайме это работает так будто ты руками раскопи пастил вот эту строчку
[49:09.840 --> 49:14.360]  то есть вот эту строчку взяли раскопи пастиля с индексами от 0 до 4
[49:15.120 --> 49:20.900]  в компайл тайме это работает очень быстро потому что тут одна инстанциация шаблона одна
[49:28.000 --> 49:31.880]  вывод вывод шаблонных аргументов по
[49:34.480 --> 49:42.520]  тому с каким аргументом запущена функция вывод шаблонных параметров по тому аргументу с которым запущена функция мы запустили с
[49:43.240 --> 49:47.920]  инстанцем вот этого класса index sequence в типе которого закодирована
[49:48.800 --> 49:53.480]  последовательность от 0 до 4 а дальше мы с помощью вот этого вот выведения шаблонных параметров
[49:54.400 --> 49:59.000]  вывели вот этот пак в котором тоже выведется что написано от 0 до 4 а
[50:01.160 --> 50:03.160]  потом мы этот пак
[50:03.720 --> 50:06.200]  зафолдили с оператором запятая и
[50:07.320 --> 50:09.920]  некоторым выражением которое просто лямбду запускает
[50:10.480 --> 50:16.480]  то есть вот этот хак с лямбдой которая сразу запускается он нужен чисто чтобы сюда любую строчку смочь написать
[50:31.160 --> 50:37.280]  он раскопи пастчивает эту лямбду это выражение подставляя в него вместо
[50:37.440 --> 50:41.520]  вот этого значка разные индексы
[50:42.600 --> 50:44.600]  fold expression вот это делает
[50:45.680 --> 50:48.680]  первый шаг fold expression берет вот это вот
[50:49.600 --> 50:51.600]  все выражение и
[50:52.320 --> 50:54.320]  превращает его в следующий вид
[50:55.280 --> 50:57.280]  заменяем на 0 и
[50:57.840 --> 51:00.760]  копипастим раз два три четыре
[51:00.760 --> 51:06.560]  нумеруем раз два три четыре
[51:07.240 --> 51:09.240]  вот все что делает fold expression
[51:09.480 --> 51:11.720]  преобразует то что написано вот здесь
[51:13.240 --> 51:16.320]  вот вот вот это вот вот в это вот
[51:18.280 --> 51:20.280]  понятие шаг да
[51:21.120 --> 51:23.120]  спитой в конце не должно быть да
[51:23.200 --> 51:28.280]  теперь дальше компилятор просто по обычным правилам начинает вычислять это выражение
[51:29.200 --> 51:31.200]  каким образом ну это
[51:32.320 --> 51:39.000]  какие-то вызовы лямбд которые написаны через запятую но соответственно он увидит ну надо сначала вычислить это
[51:40.200 --> 51:46.360]  вычисляет результат как бы void но он его выкидывает потом вычисляет это потом вычисляет это ну и все
[51:47.000 --> 51:49.000]  просто оператор запитает так работает
[51:49.640 --> 51:51.640]  будь здоров
[51:53.120 --> 51:56.320]  ну да fold expression как бы копипаст это стшки
[51:57.160 --> 51:58.760]  как и все в шаблонах
[51:58.760 --> 52:03.640]  это правильная интуиция на то как работают шаблоны вы когда подставляете в шаблон какой-то аргумент
[52:04.000 --> 52:09.560]  вы копипастите стшку шаблона и заменяете все вхождения этого аргумента на то что подставили
[52:11.760 --> 52:17.280]  развертки паков работают точно также берем стшку раскопи пастчиваем что-то заменяем
[52:19.280 --> 52:21.040]  нет
[52:21.040 --> 52:23.680]  ну это по крайней мере быстрее чем
[52:24.160 --> 52:26.760]  то есть это не порождает сущности языка
[52:27.880 --> 52:34.720]  вот главный поинт потому что когда ты инстанцируешь класс какой-нибудь ты порождаешь сущность языка и
[52:35.280 --> 52:40.640]  компилятор ее должен сохранить запомнить и дальше за ней следить потому что вдруг еще кто-то захочет к ней доступ получить
[52:41.120 --> 52:47.160]  вдруг она на резолюцию имен как-то повлияет да это гораздо больше импакт чем копипаста какого-то
[52:47.640 --> 52:51.280]  кода внутри функции какой-то стшки которая вот просто кусочек кода
[52:52.280 --> 52:57.560]  вот такая мотивировка но по факту это работает быстрее я когда-то когда-то давно замерял
[53:08.640 --> 53:11.240]  нет давай не будем возвращаться это уже все умеете делать
[53:21.800 --> 53:23.800]  что ну ты
[53:26.920 --> 53:31.680]  да ты идешь рекурсии инстанцируя классы или бы функции
[53:36.200 --> 53:38.200]  нет
[53:38.200 --> 53:43.880]  да ты ты просто уже к этому привык к этому еще не привык и то и другое полная хрень с точки зрения читаемости
[53:44.400 --> 53:46.800]  невозможно читать никакому стажеру жену никому
[53:47.640 --> 53:49.640]  это
[54:04.800 --> 54:06.800]  сейчас что-то предлагаешь сделать
[54:10.960 --> 54:12.960]  а вот это
[54:17.800 --> 54:19.800]  выражение
[54:20.160 --> 54:22.160]  вот если мы в шаблонный параметр
[54:23.800 --> 54:25.800]  куда
[54:27.200 --> 54:33.920]  ладно я перестал понимать что ты хочешь поэтому давай пойдем дальше как сделать это простым понятным читаем в какой-то мере
[54:34.600 --> 54:36.600]  давайте первую строчку
[54:36.760 --> 54:38.760]  зафигарим в define
[54:47.800 --> 54:52.600]  это раз и вот этот тут остаточек кода
[54:55.520 --> 54:59.040]  то есть в принципе все кроме вот этой строчки которая в цаус что-то выводит
[55:01.920 --> 55:06.720]  как я назвал вот так ну это все зафигарим в for template end
[55:16.800 --> 55:18.800]  а
[55:25.360 --> 55:29.120]  сейчас посмотрим внимательно что мы сделали ничего сложного на самом деле
[55:33.320 --> 55:35.320]  вот так
[55:37.960 --> 55:39.960]  так вот так вот так вот так
[55:40.280 --> 55:42.280]  ну только что был какой-то код
[55:42.840 --> 55:46.200]  дословно что я сделал все кроме вот этой вот строчки
[55:46.800 --> 55:49.560]  все что выше выдрал в macros for template
[55:50.160 --> 55:54.480]  все что ниже этой строчки выдрал в macros and for template
[55:56.520 --> 56:02.240]  в этих там for template сделал аргумент у первого и это ну
[56:02.960 --> 56:04.960]  индекс как в цикле и
[56:05.760 --> 56:08.200]  а у последнего ну количество
[56:08.360 --> 56:10.360]  а
[56:11.240 --> 56:12.760]  что вы думаете об этом
[56:12.760 --> 56:20.400]  ну если вы владеете макросной магией достаточно хорошо вы можете сделать чтобы вот здесь оба аргумента были если вам так хочется но я не буду
[56:21.920 --> 56:27.760]  то есть ну уже уже понятно более-менее что происходит как-то в целом можно еще обернуть в
[56:29.000 --> 56:32.120]  прекрасные фигурные скобки у вас вообще практически цикл
[56:33.680 --> 56:35.680]  ничего стирать не надо пусть так будет
[56:38.200 --> 56:39.840]  да
[56:39.840 --> 56:40.920]  ну
[56:40.920 --> 56:47.360]  это работает и это более-менее можно понять что делает поэтому меня такое в принципе устраивает и
[56:48.920 --> 56:56.400]  ну в домашней вам во всяком случае придется что-то подобное использовать потому что на сколько я помню по лимитам не влезает рекурсия
[57:00.560 --> 57:02.560]  да
[57:08.320 --> 57:10.320]  а
[57:20.320 --> 57:22.320]  хорошая идея
[57:25.320 --> 57:28.360]  давай за пять минут и попробуй написать
[57:31.680 --> 57:33.680]  нет она не может быть констивал
[57:34.640 --> 57:36.640]  она может быть только void
[57:37.600 --> 57:42.240]  какой-то аплай мы должны в шаблоне указать
[57:44.960 --> 57:46.960]  некоторые каунт
[57:47.480 --> 57:49.480]  мы должны
[57:49.960 --> 57:51.880]  принять
[57:51.880 --> 57:53.880]  колбэк
[57:57.200 --> 57:59.200]  зачем вот это было нужно
[57:59.280 --> 58:01.280]  но затем чтобы ты мог пройтись по теплу
[58:02.080 --> 58:03.680]  компайл тайме
[58:03.680 --> 58:08.000]  в домашке это тебе понадобится да и в принципе по жизни неплохо к уметь делать
[58:09.480 --> 58:12.280]  да да ты как бы в компайл тайме проходишься
[58:12.640 --> 58:17.880]  не вран тайме а в компайл тайме заранее раскопи пастчиваешь столько раз сколько нужно вот такую строчку
[58:18.920 --> 58:25.320]  это вполне полезный навык ну вот тут предложили прокачать давайте прокачаем
[58:26.960 --> 58:28.960]  в принципе мы будем делать то же самое
[58:29.960 --> 58:32.960]  возьмем две вот этих штуки
[58:37.720 --> 58:39.720]  сделаем вот так вот так вот так
[58:42.160 --> 58:44.160]  каунт так
[58:45.120 --> 58:50.240]  почему нас нас обижают а понятно почему и мы сделаем у
[58:51.040 --> 58:53.040]  колбэка точка
[58:53.040 --> 58:54.400]  template
[58:54.400 --> 58:56.400]  оператор круглые скобки
[58:57.280 --> 58:59.280]  с параметром и
[59:02.360 --> 59:04.360]  не смущает вас это выражение
[59:08.160 --> 59:11.680]  мы хотим выбрать вызвать оператор круглые скобки колбэка
[59:12.560 --> 59:20.160]  явно но шаблонный указав явно и а так как и вот эта вот штука это шаблонная функция и вот эта вот штука это
[59:20.160 --> 59:26.200]  некоторое шаблонное что-то на зависимый тип зависимая в зависимое выражение
[59:27.600 --> 59:34.240]  компилятор компилятор если мы вот здесь ключевое слово template не напишем он подумает что мы захотели сравнить вот это выражение
[59:35.000 --> 59:37.000]  вот это выражение
[59:37.000 --> 59:40.760]  полученный буль потом сравнить вот это ну короче вы поняли да
[59:42.080 --> 59:44.080]  традиционно
[59:44.680 --> 59:48.920]  традиционно когда такое происходит мы вписываем какое-то дурацкое слово куда-то
[59:49.480 --> 59:51.480]  ну
[59:52.480 --> 01:00:00.160]  кто не синий ки темплей ну не синий ки не синий ки ну и вы скот просто сдался уже от нас не может терпеть это
[01:00:01.680 --> 01:00:03.680]  давайте
[01:00:05.160 --> 01:00:07.160]  да
[01:00:13.400 --> 01:00:15.400]  так мы без аргументов вызываем
[01:00:16.680 --> 01:00:18.680]  как что как
[01:00:18.920 --> 01:00:21.720]  нам главное указать шаблонный аргумент вот этот вот
[01:00:23.280 --> 01:00:25.280]  как через инвок
[01:00:33.560 --> 01:00:37.840]  ну как ты в инвоке укажешь какой шаблонный аргумент явно указать при вызове
[01:00:49.680 --> 01:00:51.680]  ну короче не работает
[01:01:01.160 --> 01:01:05.880]  да указатель на функцию не сможем сюда и незадуманно указатель на функции смотри сюда
[01:01:06.640 --> 01:01:09.040]  задумано передавать шаблонные лямбда
[01:01:10.720 --> 01:01:12.720]  сейчас надо использование написать
[01:01:15.800 --> 01:01:18.320]  вообще почему я сам этого не придумал очень странно
[01:01:19.840 --> 01:01:22.160]  а давайте тоже скопи пастим
[01:01:27.440 --> 01:01:29.440]  какой передать
[01:01:30.200 --> 01:01:34.640]  сейчас вот это вот просто надо подвинуть вот сюда подвинем куда-нибудь
[01:01:37.600 --> 01:01:39.600]  да
[01:01:39.720 --> 01:01:43.640]  тоже работа без макросов кстати это это гениально
[01:01:48.920 --> 01:01:50.920]  все заинлайнится
[01:01:53.280 --> 01:01:56.960]  сейчас это у нас что-то не то запустилось
[01:02:00.080 --> 01:02:02.200]  что мы компилим вообще что запускаем
[01:02:09.840 --> 01:02:11.840]  билдмейн
[01:02:13.320 --> 01:02:15.320]  билдмейн
[01:02:15.440 --> 01:02:17.440]  а
[01:02:17.960 --> 01:02:23.480]  ой нет это не смотрите туда все скомпилировалось да только что нам вывелось а
[01:02:26.240 --> 01:02:32.920]  тюпл а да я же вывожу тюпл гет и в тюпле написано что 0 42 420
[01:02:33.640 --> 01:02:37.280]  а хай ну вот и тот и тот подход и с макросами и с
[01:02:42.080 --> 01:02:44.760]  все правильно нам вывелось я что-то туплю просто
[01:02:45.320 --> 01:02:48.960]  и здесь и здесь сработала и вывела нам то что в тюпле находится
[01:02:51.120 --> 01:02:53.120]  компайл тайм циклы
[01:02:54.040 --> 01:02:57.600]  конечно же есть пропузл стандарт сделать template for
[01:02:58.320 --> 01:03:01.840]  который будет делать это очень просто и понятно как вот вот так вот
[01:03:03.840 --> 01:03:05.840]  стэкспора
[01:03:09.080 --> 01:03:15.280]  хотелось бы чтобы просто вот так было и не приходилось себе пудрить мозги к сожалению до сих пор не могут
[01:03:15.320 --> 01:03:19.480]  ни о чем договориться поэтому пока так пишем все давайте на этой
[01:03:22.120 --> 01:03:29.760]  конечно контекстное использование ключевых слов это наше все потому что новые ключевые слова добавлять то вы что аксистить нельзя
[01:03:29.880 --> 01:03:31.880]  я
[01:03:44.640 --> 01:03:50.960]  ну да ну вы шутите там предлагали какие-то типа
[01:03:54.000 --> 01:03:56.000]  такие штуки да
[01:03:57.160 --> 01:03:59.160]  типа universal template argument
[01:04:00.520 --> 01:04:04.560]  ну по моему тоже шутку было но да все давайте на этом
[01:04:05.080 --> 01:04:06.920]  паузу сделаем и
[01:04:06.920 --> 01:04:09.760]  перерыв у нас до 31 минуты
[01:04:10.840 --> 01:04:12.080]  покушать
[01:04:12.080 --> 01:04:14.080]  что-нибудь попить
[01:04:14.640 --> 01:04:16.400]  итак
[01:04:16.400 --> 01:04:20.200]  рефлексия под типов кого-то из вас могут сразу возникнуть вопросы к тому что
[01:04:22.240 --> 01:04:25.600]  да но plane old data у этого нет строгого определения
[01:04:26.320 --> 01:04:34.080]  в стандарте есть там три или копия был что-то там что-то вот мы не будем заморачиваться потому что все равно не на одну не на один
[01:04:34.200 --> 01:04:40.120]  стандартный концепт то что мы сейчас будем изобретать не маппиться мы так интуитивно ну это типа структурки
[01:04:40.320 --> 01:04:43.120]  где там есть поля и все типа и больше ничего нет
[01:04:44.480 --> 01:04:50.240]  давайте уточним немножко на самом деле это не юнион не пользовательские нет пользовательских конструкторов
[01:04:50.720 --> 01:04:55.240]  диструкторов никаких виртуальных методов копирования каких-нибудь операторов присваивания
[01:04:56.280 --> 01:05:03.120]  конечно же нет наследования все поля публичные не имеет значения по умолчанию и либо скалярные либо тоже под типы
[01:05:04.240 --> 01:05:06.240]  плюс-минус
[01:05:08.480 --> 01:05:10.480]  да они нам не помешают
[01:05:14.360 --> 01:05:16.840]  как все короче структурки как все
[01:05:20.560 --> 01:05:22.560]  блин методы в структурах это такая типа
[01:05:23.640 --> 01:05:27.200]  ничего полезного ничего вредного ну есть и есть
[01:05:28.360 --> 01:05:30.360]  окей что мы хотим
[01:05:31.400 --> 01:05:33.800]  мы хотим все в принципе уметь понимать
[01:05:34.560 --> 01:05:36.560]  да вот примерчики
[01:05:36.640 --> 01:05:42.640]  ну понятно просто структурки и все мы хотим понимать количество полей типа полей и
[01:05:43.880 --> 01:05:46.840]  внимание самое сложное это уметь получать ссылку на
[01:05:46.840 --> 01:05:53.720]  поле по номеру поля причем в компайл тайме типа
[01:05:56.920 --> 01:05:58.920]  ну в компайл тайме
[01:06:00.040 --> 01:06:05.560]  гет а запятая два и вам возвращают ссылку на флот
[01:06:08.960 --> 01:06:12.880]  нет просто ссылку на флот вы пишите гет и в треугольных скобках а
[01:06:13.880 --> 01:06:16.480]  запятая два номер
[01:06:17.000 --> 01:06:19.000]  возвращает ссылку на флот
[01:06:22.680 --> 01:06:25.080]  нигде никаких указателей на меморер классов нет
[01:06:27.560 --> 01:06:30.480]  да я фигню говорю гет а
[01:06:31.920 --> 01:06:36.640]  два и в круглых скобках какой-то конкретный инстинкт с этой структурки и
[01:06:37.760 --> 01:06:39.960]  потом вам возвращают обычные ссылку на
[01:06:40.040 --> 01:06:42.840]  флот ссылку флот амперсант то есть по
[01:06:43.680 --> 01:06:45.200]  инстанцию и
[01:06:45.200 --> 01:06:52.440]  номер у поля получить ссылку на это поле где тип ссылки но соответствует типу поля очевидно чтобы это была нормальная ссылка на это поле
[01:06:53.240 --> 01:06:56.000]  не хотим указывать сами тип вообще ничего не хотим указывать
[01:06:57.080 --> 01:06:59.960]  рефлексия по номеру же можно типа определить
[01:07:00.760 --> 01:07:02.760]  наверное
[01:07:02.920 --> 01:07:06.800]  ну теоретически да практически сейчас будем изворачивать
[01:07:06.800 --> 01:07:08.800]  именно мы уже умеем
[01:07:09.800 --> 01:07:11.800]  ну то есть
[01:07:11.800 --> 01:07:20.320]  имена конкретных полей мы умеем получать по-моему да тут надо догадаться догадаетесь как получить имя поля
[01:07:22.800 --> 01:07:24.800]  через ошибки
[01:07:24.800 --> 01:07:26.800]  переграфы на
[01:07:27.400 --> 01:07:29.400]  просто вот в этот
[01:07:31.200 --> 01:07:36.920]  будет только им структура нужно передать что-то что относится к конкретному полю
[01:07:39.400 --> 01:07:43.440]  да поинтер ту мембр указательна член выпиливает
[01:07:44.200 --> 01:07:46.640]  поинтер ту мембр указательна член выпиливает
[01:07:48.160 --> 01:07:50.160]  поинтер ту мембр
[01:07:50.160 --> 01:07:52.160]  указательному полю
[01:07:53.080 --> 01:07:59.160]  да поинтер ту мембр указательна член вы передаете его в хелпер вот тот спрете фанкшн и
[01:07:59.520 --> 01:08:03.680]  ну это указатель на член класса вам скажут на какой член он указывает
[01:08:09.160 --> 01:08:11.520]  по номеру через вот это как бы ну
[01:08:14.600 --> 01:08:20.040]  если ты уже знаешь какой конкретно поле хочешь то ты можешь взять указатель на него как на мембр класс
[01:08:21.160 --> 01:08:27.400]  и запихать в хелпер сприти фанкшн который в самом начале был это тебе ну строку даст
[01:08:28.840 --> 01:08:32.320]  по номеру вот вот это все требуется чтобы по номеру потом
[01:08:35.720 --> 01:08:38.840]  и тип и имя поля тоже даст
[01:08:39.840 --> 01:08:44.320]  по номеру что угодно по номеру это золото играть того что будет дальше
[01:08:44.720 --> 01:08:49.920]  пока мы по номеру ничего не умеем но я утверждаю что как только что одно научимся дальше все будем уметь
[01:08:51.080 --> 01:08:54.360]  то есть вот ну просто конкретного поля имя мы можем
[01:08:55.200 --> 01:09:01.040]  превратить в строку зачем правда не очень понятно но вдруг у вас уже есть список а ну да собственно
[01:09:02.120 --> 01:09:06.840]  если ссылку сможем то есть ссылку на мембр или указатель на мембр сможем вот у вас есть
[01:09:07.080 --> 01:09:13.960]  список указателей на мембр и ну закидайте их в хелпер и вот у вас будет список строк имен разных полей по индексу почему угодно
[01:09:20.240 --> 01:09:28.160]  да во-первых указатель на мембр можно передавать как не типовой шаблонный аргумент во-вторых вам его распечатают во всей подробности
[01:09:29.040 --> 01:09:35.680]  можем это посмотреть если у вас сомнения быстро быстро камеру не поворачивай это будет супер быстрое отвлечение без
[01:09:36.720 --> 01:09:38.720]  без всего
[01:09:39.120 --> 01:09:41.120]  что мы делаем
[01:09:42.960 --> 01:09:46.200]  автове авто хелпер
[01:09:46.200 --> 01:09:48.200]  а
[01:09:49.920 --> 01:09:51.920]  третий фанкшн
[01:09:54.280 --> 01:09:56.480]  мне тут есть а он уже есть так
[01:10:03.280 --> 01:10:05.280]  здравствуй
[01:10:05.600 --> 01:10:12.080]  хелпер от там какая-то структура была есть какая-то фу-фу-фу двадвое точа
[01:10:17.040 --> 01:10:19.040]  запускаем
[01:10:25.040 --> 01:10:31.760]  ну вывели то что казалось бы мы и ожидали фу двадвое точа а ну отсюда вы можете вытащить вот это вот а как строку
[01:10:32.840 --> 01:10:38.800]  вопрос только теперь научиться список вот этих вот сущностей находить до список всех указателей на все поля
[01:10:39.880 --> 01:10:42.680]  вот этого мы не умеем и сейчас как раз этим будем заниматься
[01:10:47.200 --> 01:10:49.440]  возможно ли если у нас есть просто
[01:10:50.480 --> 01:10:52.480]  ссылка то есть как это
[01:10:54.360 --> 01:10:57.320]  ссылка на член класса
[01:10:59.160 --> 01:11:01.160]  не вот таки он передать а просто круто
[01:11:02.680 --> 01:11:05.040]  он определит по ней что это член класса
[01:11:06.040 --> 01:11:10.680]  я не понимаю вот я написал кинт альберсант икс равно и
[01:11:11.680 --> 01:11:18.680]  нет не работает типа то есть вот это вот особая конструкция которая позволяет создавать поинтер тумэмбер
[01:11:21.680 --> 01:11:27.680]  да мы же подробно разжевывали что такое поинтер тумэмбер можешь пересмотреть этот момент и
[01:11:28.520 --> 01:11:35.480]  поиграться самому ты меня слушая ничего не запомнишь это точно всегда так работает тебе нужно самому поиграться с этим и
[01:11:35.920 --> 01:11:42.800]  потом уже что-то осядет ну или пересмотреть ту лекцию где мы писали function там про это как раз говорили
[01:11:43.680 --> 01:11:45.680]  окей давайте пытаться
[01:11:46.280 --> 01:11:48.280]  начнем с количества полей
[01:11:48.320 --> 01:11:50.320]  есть структура и
[01:11:50.440 --> 01:11:52.600]  вот мы создали ее экземпляр
[01:11:54.000 --> 01:11:56.000]  пока все понятно а
[01:11:56.200 --> 01:11:58.200]  вот так теперь создали экземпляр
[01:11:59.400 --> 01:12:01.400]  но и вот так и
[01:12:01.400 --> 01:12:05.880]  и на каком-то моменте нас ожидает облом да
[01:12:09.160 --> 01:12:15.760]  понятно как найти количество полей опять бен поиск туда-сюда ну или перебор
[01:12:23.400 --> 01:12:28.480]  фигурные скобочки а ты попробуй это закодить фигурными скобочками у тебя к сожалению ничего не выйдет
[01:12:28.800 --> 01:12:33.440]  все немножко хитрее но то есть идея да подбираем максимальный набор
[01:12:33.840 --> 01:12:41.760]  размер пака когда у нас компилируется вот такое выражение это и будет количество полей можно бен поиском можно линейным поиском
[01:12:42.720 --> 01:12:45.480]  а да типа аргументов нам неизвестная поэтому
[01:12:46.160 --> 01:12:49.720]  предлагают как бы скобочки но это тоже не сработает потому что
[01:12:50.280 --> 01:12:53.400]  скобочки это такая специальная костыльная конструкция в языке а
[01:12:53.840 --> 01:12:57.520]  вам там это все функции какие-то надо будет завернуть ну и общем сломается
[01:12:58.720 --> 01:13:00.720]  а
[01:13:01.400 --> 01:13:05.200]  максимальный сайзов мы же если перебрыгнули получим
[01:13:09.200 --> 01:13:12.520]  да то есть requires expression и которые тебе позволяют
[01:13:13.440 --> 01:13:17.520]  позволяют проверять будет сие или не будет это база основа
[01:13:19.880 --> 01:13:21.360]  так
[01:13:21.360 --> 01:13:23.880]  что передавать будем вместо фигурных скобочек
[01:13:24.600 --> 01:13:27.840]  ну вот фигурные скобочки вы за сами написать можете а
[01:13:28.360 --> 01:13:32.520]  заставить шаблоны вам писать нужное количество фигурных скобочек кажется не получится
[01:13:47.160 --> 01:13:50.640]  то есть фолды фолд будет по выражению какому
[01:13:51.280 --> 01:13:53.280]  запятая скобочки
[01:13:54.240 --> 01:13:59.600]  все это уже будет ошибка потому что ты уже делаешь не агрегатную инициализацию фигурными скобочками а
[01:14:00.000 --> 01:14:04.960]  создаешь пак потому что ты через оператор запятая пропускаешь считается
[01:14:11.160 --> 01:14:16.040]  запятая фигурные скобочки скобка закрывается три точки это одно выражение
[01:14:16.880 --> 01:14:20.800]  запятая фигурная скобка фигурные скобочки полностью
[01:14:24.360 --> 01:14:27.200]  это не будет работать у тебя нету выражения
[01:14:32.960 --> 01:14:34.960]  окей
[01:14:35.480 --> 01:14:37.480]  а
[01:14:41.200 --> 01:14:44.160]  давай там мы собрались инициализировать а что ты пишешь а
[01:14:45.560 --> 01:14:52.960]  да и считаем что у нас есть пак из в нашем контексте который там 0 1 2 и так далее да что мы пишем
[01:14:56.520 --> 01:14:58.520]  дальше
[01:14:58.920 --> 01:15:00.920]  из фигурной скобочки
[01:15:01.440 --> 01:15:03.440]  запятая фигурные скобочки
[01:15:03.440 --> 01:15:07.440]  в ракмин на следующий символ переходим в стрелку вправо до литочек
[01:15:09.880 --> 01:15:11.880]  ну это оператор запятая
[01:15:15.000 --> 01:15:17.320]  нет это не будет фолд экспрешен для оператора запятая
[01:15:17.960 --> 01:15:19.960]  андрей помолчи пожалуйста
[01:15:20.160 --> 01:15:27.800]  это оператор запятая все равно да окей оператор запятая это уже некоторая функция по сути в семантике языка а
[01:15:28.280 --> 01:15:36.400]  фигурные скобочки работают как агрегатно инициализация который можно инициализировать любой тип только если ты их прямо в том контексте где ты хочешь и на слизировать и написал
[01:15:37.960 --> 01:15:45.720]  в ином контексте фигурные скобочки вот эти работают как список инициализации стд initialized list то есть вот здесь у
[01:15:46.180 --> 01:15:51.680]  тебя возвращаемое значение вот этого выражения из фигурная скобка запятая фигурная скобка
[01:15:51.680 --> 01:15:55.680]  только оператор, его возвращаемый тип будет std-initializer-list.
[01:15:55.680 --> 01:15:59.680]  А от std-initializer-lista не любой тип инициализируется.
[01:16:01.680 --> 01:16:03.680]  Вообще никакая вроде.
[01:16:03.680 --> 01:16:06.680]  Это brace-initializer скорее всего будет,
[01:16:06.680 --> 01:16:09.680]  для которого не удастся вывести тип, который инициализируется.
[01:16:09.680 --> 01:16:12.680]  Да, скорее всего вообще выдадут ошибку, потому что
[01:16:12.680 --> 01:16:17.680]  тут типа надо вывести тип, и мы не смогли, и ну вот, да.
[01:16:17.680 --> 01:16:19.680]  Это даже не initializer-list.
[01:16:19.680 --> 01:16:21.680]  Короче, ничего не работает.
[01:16:21.680 --> 01:16:23.680]  К сожалению, к сожалению так.
[01:16:23.680 --> 01:16:27.680]  То есть вот такие вещи, как brace-initializer-list,
[01:16:27.680 --> 01:16:29.680]  то есть инициализация через фигурные скобочки,
[01:16:29.680 --> 01:16:31.680]  она в языке захардкожена,
[01:16:31.680 --> 01:16:34.680]  и передавать ее в какие-то функции нельзя.
[01:16:34.680 --> 01:16:37.680]  Это не first class object опять в языке,
[01:16:37.680 --> 01:16:40.680]  как и паки.
[01:16:40.680 --> 01:16:43.680]  Параметры паки тоже какие-то непонятные, костыльные,
[01:16:43.680 --> 01:16:47.680]  и не являются объектами языка, с которыми можно работать нормально.
[01:16:47.680 --> 01:16:50.680]  Но выкрутиться можно.
[01:16:50.680 --> 01:16:52.680]  Нам всего-то нужен тип,
[01:16:52.680 --> 01:16:55.680]  который можно прикастить к любому другому типу.
[01:16:55.680 --> 01:16:57.680]  Согласны?
[01:16:57.680 --> 01:16:59.680]  Ну так напишем.
[01:16:59.680 --> 01:17:02.680]  Вот тип, который можно прикастить к любому другому типу.
[01:17:04.680 --> 01:17:06.680]  Да, это юбик констрактор.
[01:17:06.680 --> 01:17:09.680]  Юбик от слова ubiquitous.
[01:17:09.680 --> 01:17:12.680]  Ubiquitous.
[01:17:12.680 --> 01:17:15.680]  Если кто-то умеет хорошо произносить на английском слово ubiquitous,
[01:17:15.680 --> 01:17:17.680]  пожалуйста, подайте голос.
[01:17:17.680 --> 01:17:19.680]  У меня не получается.
[01:17:19.680 --> 01:17:22.680]  Короче, юбик.
[01:17:22.680 --> 01:17:25.680]  Ну и все, на этом технология заканчивается.
[01:17:25.680 --> 01:17:28.680]  Ну догадайтесь, зачем здесь вот это вот?
[01:17:28.680 --> 01:17:31.680]  Зачем какой-то есть шаблонный?
[01:17:36.680 --> 01:17:38.680]  Ну пак, чтобы можно было вернуться.
[01:17:38.680 --> 01:17:40.680]  Да, да.
[01:17:40.680 --> 01:17:43.680]  То есть пишем вот такой простой, понятный код.
[01:17:43.680 --> 01:17:47.680]  Если вы за 30 секунд не можете понять, что здесь написано, вы отчислены.
[01:17:53.680 --> 01:17:56.680]  Итак, это некоторый шаблон функции.
[01:17:56.680 --> 01:17:58.680]  Констэкспро функции.
[01:17:58.680 --> 01:18:01.680]  Должна быть констэвал, но ушла одна.
[01:18:01.680 --> 01:18:03.680]  CountFieldsImpl.
[01:18:03.680 --> 01:18:07.680]  Она принимает индекс sequence с паком ишек.
[01:18:07.680 --> 01:18:10.680]  Ну, догадайтесь, почему.
[01:18:10.680 --> 01:18:13.680]  Мы только что таким же занимались в коде.
[01:18:13.680 --> 01:18:18.680]  Мы собрались использовать вывод аргументов шаблонных,
[01:18:18.680 --> 01:18:22.680]  то есть вывод вот этого вот из аргументов функции.
[01:18:22.680 --> 01:18:24.680]  Точно такая же техника.
[01:18:24.680 --> 01:18:28.680]  Вот этому индекс секунсу мы там какой-то makeIndexSequence от пяти вкинем,
[01:18:28.680 --> 01:18:32.680]  и он там развернется, и вот будет у нас пак от нуля до четырех.
[01:18:32.680 --> 01:18:34.680]  Окей.
[01:18:34.680 --> 01:18:36.680]  Есть какой-то шаблон T, но он там...
[01:18:36.680 --> 01:18:38.680]  Шаблонный аргумент T заранее задан.
[01:18:38.680 --> 01:18:41.680]  Такая же структура, которая нас интересует.
[01:18:41.680 --> 01:18:43.680]  Есть некий constraint.
[01:18:43.680 --> 01:18:45.680]  ConstraintConstructableFrom.
[01:18:45.680 --> 01:18:50.680]  Говорят, что T должен быть конструируем от ub-конструктор,
[01:18:50.680 --> 01:18:54.680]  где впихнут пак и, и написано три точки.
[01:18:56.680 --> 01:19:02.680]  То есть вот это вот выражение распакуется столько раз, сколько у нас чисел в этом паке,
[01:19:02.680 --> 01:19:12.680]  и Require, по сути, нас завалит ровно в тот момент, когда стало слишком много чисел в этом паке,
[01:19:12.680 --> 01:19:17.680]  и уже перестала работать вот эта технология, что T пытаемся конструировать от ub-ков.
[01:19:17.680 --> 01:19:19.680]  Ага.
[01:19:19.680 --> 01:19:21.680]  Сейчас, сейчас.
[01:19:21.680 --> 01:19:23.680]  В какой момент не понял?
[01:19:23.680 --> 01:19:27.680]  Мы конструируем, то есть у нас получается набор ub-конструкторов.
[01:19:27.680 --> 01:19:28.680]  Да.
[01:19:28.680 --> 01:19:30.680]  Дальше что?
[01:19:30.680 --> 01:19:33.680]  Дальше мы проверяем, что?
[01:19:33.680 --> 01:19:38.680]  Is ConstructableFrom T и вот этот пак ub-ков.
[01:19:38.680 --> 01:19:41.680]  Что T конструируется от ub-конструктора?
[01:19:41.680 --> 01:19:42.680]  Да.
[01:19:42.680 --> 01:19:43.680]  Пака.
[01:19:43.680 --> 01:19:45.680]  Вот этот пак развернется.
[01:19:45.680 --> 01:19:52.680]  И тут мы будем проверять, что T конструируется от ub-конструктор 0, ub-конструктор 1, ub-конструктор 2
[01:19:52.680 --> 01:19:55.680]  и так далее до количества чисел в этом паке.
[01:19:55.680 --> 01:19:57.680]  На самом деле не совсем, да?
[01:19:57.680 --> 01:19:58.680]  Ну совсем.
[01:19:58.680 --> 01:20:00.680]  Все там 0, 0 и еще раз 0.
[01:20:00.680 --> 01:20:02.680]  Это так.
[01:20:02.680 --> 01:20:05.680]  А, ну я сюда нули, я до сюда пока не зашел.
[01:20:05.680 --> 01:20:06.680]  Окей.
[01:20:06.680 --> 01:20:10.680]  Ну вот верно подметили, что строчкой ниже в этот пак запихиваются все нули.
[01:20:10.680 --> 01:20:12.680]  То есть тут просто будет N нулей.
[01:20:12.680 --> 01:20:18.680]  Значит у нас здесь будет N раз перечислен ub-конструктор от нуля.
[01:20:18.680 --> 01:20:23.680]  Ну и мы проверяем вот от N таких ub-конструкторов, которые я напоминаю кастятся к любому типу,
[01:20:23.680 --> 01:20:28.680]  ну ли от N штук таких ub-конструкторов сконструировать наш T, который структурка.
[01:20:28.680 --> 01:20:36.680]  Если можно, то мы пока не нашли предел верхний, после которого мы фейлимся.
[01:20:36.680 --> 01:20:42.680]  Ну и в момент, когда нашли и уже дальше идти нельзя, они конструируются.
[01:20:42.680 --> 01:20:44.680]  Ну мы другую перегрузку сейчас сделаем.
[01:20:44.680 --> 01:20:50.680]  Но вот в этой перегрузке мы как бы еще не нашли максимальное количество ub-ков,
[01:20:50.680 --> 01:20:52.680]  которые можно запихать в структуру.
[01:20:52.680 --> 01:20:58.680]  Мы сейчас не по номеру поле ищем, а мы ищем size.
[01:20:58.680 --> 01:21:03.680]  Мы ищем количество полей. Вот. Вот эта технология.
[01:21:03.680 --> 01:21:06.680]  Хотим автоматизировать вот это вот.
[01:21:06.680 --> 01:21:11.680]  Идея тупая. Все, кто отлетели, вернитесь, пожалуйста, раз уж мы повторяем еще раз.
[01:21:11.680 --> 01:21:16.680]  Мы собрались закодить вот в той функции последовательные попытки.
[01:21:16.680 --> 01:21:21.680]  Сделали так. Работает. Окей, запомнили. Ноль.
[01:21:21.680 --> 01:21:26.680]  Сделали так. С одним аргументом сработало. Запомнили. Один.
[01:21:26.680 --> 01:21:31.680]  Сделали так. Запомнили два. Попробовали с тремя, уже не получилось.
[01:21:31.680 --> 01:21:36.680]  Все, значит нужно вернуть два. Количество полей в структуре два.
[01:21:36.680 --> 01:21:42.680]  Вот эта вот рекурсивная функция, использующая ub-ки, которые кастятся к любому типу.
[01:21:42.680 --> 01:21:46.680]  То есть, любое поле можно инициализировать от ub-ка.
[01:21:46.680 --> 01:21:49.680]  Потому что оно кастится.
[01:21:49.680 --> 01:21:56.680]  Вот ровно здесь, в этой рекурсии, это как рекурсия, оно само себя запускает.
[01:21:56.680 --> 01:22:00.680]  Ровно в момент requires мы проверяем, получилось ли.
[01:22:02.680 --> 01:22:07.680]  То есть, смотрим. Предположим, у нас сейчас первая итерация.
[01:22:07.680 --> 01:22:11.680]  То есть, здесь пак из одного нуля. Мы посмотрим, конструируется t.
[01:22:11.680 --> 01:22:17.680]  Конструируется ли t из одного ubic-констрактора от нуля.
[01:22:23.680 --> 01:22:27.680]  Ну, типа того, но сейчас будет загвоздка. То есть, вот эту строчку проверяем, по сути.
[01:22:27.680 --> 01:22:30.680]  Только вместо единицы здесь будет ubic-констрактор ноль.
[01:22:30.680 --> 01:22:35.680]  Вот этот ubic-констрактор, если мы скастим t, чем он контурируется в поле?
[01:22:35.680 --> 01:22:38.680]  Да ничем. Потому что здесь нет реализации.
[01:22:38.680 --> 01:22:41.680]  Да, это нормально, что здесь нет, она и не должна быть.
[01:22:41.680 --> 01:22:45.680]  Да. Мы же не собрались в рон тайме звать.
[01:22:45.680 --> 01:22:49.680]  В рон тайме установим ошибку, а в комплантане сейчас мы перейдем.
[01:22:49.680 --> 01:22:50.680]  Да.
[01:22:52.680 --> 01:22:58.680]  А дальше идет рекурсия. То есть, если у нас уже соединить с паком размера 1 получилось, надо дальше идти.
[01:22:58.680 --> 01:23:08.680]  Ну, идем. Запускаем сами себя от t и индекс sequence от ноль и оставшихся is, которые тоже нули.
[01:23:08.680 --> 01:23:10.680]  Ну, короче, дописали еще 1 ноль.
[01:23:13.680 --> 01:23:14.680]  Что не так?
[01:23:14.680 --> 01:23:15.680]  Не я.
[01:23:15.680 --> 01:23:16.680]  Ну, вот, допустим.
[01:23:16.680 --> 01:23:22.680]  А constructable from? Он в сигурдной скобочке, можно считать, а вы чекутое в сигурдной скобочке, да?
[01:23:22.680 --> 01:23:24.680]  Constructable from? Ну, считаем, что да.
[01:23:24.680 --> 01:23:29.680]  Добавилась база рекурсии. То есть, здесь мы просто рекурсивно идем вперед, вперед, вперед.
[01:23:29.680 --> 01:23:32.680]  И в какой момент мы остановимся, в принципе, да?
[01:23:32.680 --> 01:23:36.680]  Когда вот этот requires провалится, мы больше вот эту перегрузку запустить не сможем.
[01:23:36.680 --> 01:23:45.680]  То есть, вот когда requires провалился, мы нашли то количество аргументов, то количество юбиков, при котором не получается сконструировать.
[01:23:45.680 --> 01:23:47.680]  В этот момент запустится другая перегрузка.
[01:23:47.680 --> 01:24:01.680]  Но так как мы нашли количество аргументов, при котором мы фейлимся, если мы посмотрим сюда, то полей два, а фейлимся мы при трех юбиках, то надо единичку вычесть и вернуть результат.
[01:24:01.680 --> 01:24:03.680]  И мы нашли количество полей.
[01:24:03.680 --> 01:24:08.680]  В общем случае для любой плюс-минус нормальной пацанской структуры.
[01:24:08.680 --> 01:24:10.680]  А если у нас была пустая структура?
[01:24:10.680 --> 01:24:13.680]  Это абсолютно правильное замечание.
[01:24:13.680 --> 01:24:22.680]  Да, ну тут рекомендация обернуть вот так вот и чтобы index sequence вот этот вот дефолтный там автоматом, да?
[01:24:22.680 --> 01:24:29.680]  То есть, это был импл, тут index sequence нужен, а тут красивая обертка без всего, чтобы вот было пацанской структуры.
[01:24:29.680 --> 01:24:31.680]  И вот так вот используем.
[01:24:31.680 --> 01:24:33.680]  Вот, пустая структурка.
[01:24:33.680 --> 01:24:34.680]  Что выведется?
[01:24:34.680 --> 01:24:37.680]  Это как раз загвоздка с constructable from.
[01:24:48.680 --> 01:24:49.680]  Почему минус один?
[01:24:49.680 --> 01:24:50.680]  Нет.
[01:24:50.680 --> 01:24:52.680]  Ну, это как раз так.
[01:24:53.680 --> 01:24:57.680]  Почему минус один?
[01:24:57.680 --> 01:24:58.680]  Почему минус один?
[01:24:58.680 --> 01:24:59.680]  Нет.
[01:25:04.680 --> 01:25:05.680]  От нуля...
[01:25:05.680 --> 01:25:08.680]  Так, окей, скомпилируются ли просто А-фигурные скобки?
[01:25:08.680 --> 01:25:09.680]  Да.
[01:25:09.680 --> 01:25:10.680]  Да, очевидно.
[01:25:10.680 --> 01:25:12.680]  Скомпилируется ли А от одного юбика?
[01:25:12.680 --> 01:25:13.680]  Нет.
[01:25:13.680 --> 01:25:15.680]  Вычитаем один, получаем опять.
[01:25:16.680 --> 01:25:19.680]  С чего ты решил, что это не скомпилируется?
[01:25:19.680 --> 01:25:21.680]  Какие у А есть конструкторы?
[01:25:21.680 --> 01:25:23.680]  Да, там изображен копик конструктора.
[01:25:23.680 --> 01:25:26.680]  Да, копик конструктора есть у А.
[01:25:26.680 --> 01:25:28.680]  Не забываем про это, да?
[01:25:28.680 --> 01:25:30.680]  То есть, сейчас, на самом деле, у нас есть баг как раз.
[01:25:30.680 --> 01:25:32.680]  Вот были ли вопросы к тому constructable from?
[01:25:32.680 --> 01:25:33.680]  Подходит вообще?
[01:25:33.680 --> 01:25:35.680]  Он точно фигурные скобки будет делать?
[01:25:35.680 --> 01:25:38.680]  Нет, он делает что-то более хитрое и сложное.
[01:25:40.680 --> 01:25:42.680]  Он просто диковал по столе...
[01:25:42.680 --> 01:25:44.680]  Ну, что-то такое, да.
[01:25:44.680 --> 01:25:48.680]  Короче, выведется нам здесь единица из-за копия конструктора.
[01:25:51.680 --> 01:25:52.680]  Ну, вот так вот.
[01:25:52.680 --> 01:25:57.680]  Нет, мы можем философски порассуждать, что структура является собственным полем.
[01:25:58.680 --> 01:25:59.680]  А можем...
[01:26:01.680 --> 01:26:07.680]  В смысле, если у нас нет полей, то сама структура является собственным полем?
[01:26:07.680 --> 01:26:09.680]  Нет, это баг.
[01:26:09.680 --> 01:26:11.680]  У нее ноль полей, надо вывести ноль.
[01:26:11.680 --> 01:26:14.680]  А мы выводим... вот такой код выводит один.
[01:26:15.680 --> 01:26:16.680]  А нужно вывести ноль.
[01:26:16.680 --> 01:26:17.680]  Полей нету, их ноль.
[01:26:17.680 --> 01:26:19.680]  Мы рефлексии занимаемся.
[01:26:19.680 --> 01:26:22.680]  Мы не говорим про то, сколько байтов она занимает.
[01:26:22.680 --> 01:26:24.680]  Кстати, это можно починить.
[01:26:24.680 --> 01:26:25.680]  Сайзов?
[01:26:25.680 --> 01:26:27.680]  Нет, сайзов будет длинный.
[01:26:27.680 --> 01:26:31.680]  Поэтому же сравнить сайзов с наследом, у нас сейчас 100 долларов.
[01:26:32.680 --> 01:26:39.680]  Эрик Нибблер в твиттере буквально вчера предлагал сравнивать типы посредством запихивания их обоих в одну структурку,
[01:26:39.680 --> 01:26:43.680]  как полей, обоих помеченных как No Unique Address.
[01:26:43.680 --> 01:26:48.680]  И если типы одинаковые, то они не схлопнутся.
[01:26:48.680 --> 01:26:50.680]  Если типы разные, то они схлопнутся.
[01:26:50.680 --> 01:26:52.680]  Во, не надо так.
[01:26:52.680 --> 01:26:54.680]  Тут фикс гораздо более простой.
[01:26:54.680 --> 01:26:57.680]  Вместо ConstructibleFrom, который копиконструктор умеет запускать,
[01:26:57.680 --> 01:27:01.680]  сделать свой Aggregate ConstructibleFrom с фигурными скобками.
[01:27:01.680 --> 01:27:04.680]  Вот здесь уже копиконструктора не будет запущено почему-то.
[01:27:04.680 --> 01:27:06.680]  Не знаю почему.
[01:27:06.680 --> 01:27:08.680]  Не будет.
[01:27:08.680 --> 01:27:10.680]  Это фикс.
[01:27:10.680 --> 01:27:12.680]  Он работает.
[01:27:12.680 --> 01:27:14.680]  Проверено, что он работает.
[01:27:14.680 --> 01:27:18.680]  Если мы посчитаем правила агрегатной инцелизации, то там...
[01:27:18.680 --> 01:27:22.680]  Это точно будет пролифицировано как агрегатная инцелизация,
[01:27:22.680 --> 01:27:24.680]  она не вызывает копирование.
[01:27:24.680 --> 01:27:26.680]  То есть там просто копирование не вызывается.
[01:27:26.680 --> 01:27:28.680]  Потому что такие правила в языке.
[01:27:28.680 --> 01:27:30.680]  Магия.
[01:27:30.680 --> 01:27:32.680]  Оно работает, поверьте.
[01:27:36.680 --> 01:27:38.680]  Почему оно ломалось, понятно?
[01:27:38.680 --> 01:27:40.680]  Копиконструктор.
[01:27:40.680 --> 01:27:42.680]  Кто виноват?
[01:27:42.680 --> 01:27:44.680]  ConstructibleFrom.
[01:27:44.680 --> 01:27:46.680]  Оно для одного юбика говорит, что да,
[01:27:46.680 --> 01:27:48.680]  потому что ConstructibleFrom вызвал копиконструктор.
[01:27:48.680 --> 01:27:50.680]  Решение.
[01:27:50.680 --> 01:27:54.680]  Вместо ConstructibleFrom руками написать requires и вот эту вот штуку.
[01:27:54.680 --> 01:27:56.680]  А тут кофе-конструктор не сработает?
[01:27:56.680 --> 01:27:58.680]  Да.
[01:27:58.680 --> 01:28:00.680]  Не знаю.
[01:28:00.680 --> 01:28:02.680]  А что это варксы?
[01:28:02.680 --> 01:28:04.680]  Варксы юбики на самом деле приходят.
[01:28:06.680 --> 01:28:08.680]  А они тут не вызывают конструктор?
[01:28:08.680 --> 01:28:10.680]  Мы агрегатную инцелизацию
[01:28:10.680 --> 01:28:12.680]  через фигурные скобочки делаем.
[01:28:14.680 --> 01:28:16.680]  Дефолтные сконструированные...
[01:28:16.680 --> 01:28:18.680]  То есть мы используем более какой концепт
[01:28:18.680 --> 01:28:20.680]  вместо ConstructibleFrom?
[01:28:20.680 --> 01:28:22.680]  Да.
[01:28:22.680 --> 01:28:24.680]  Выискаем, что он конструкт,
[01:28:24.680 --> 01:28:26.680]  что тот делает что-то более умное.
[01:28:26.680 --> 01:28:28.680]  Он проверяет, можно ли сконструировать
[01:28:28.680 --> 01:28:30.680]  как-нибудь.
[01:28:30.680 --> 01:28:32.680]  А тут только агрегатно сконструировать.
[01:28:32.680 --> 01:28:34.680]  Это более узкий концепт.
[01:28:34.680 --> 01:28:36.680]  Почему предыдущий ход на любой структуре?
[01:28:36.680 --> 01:28:38.680]  Почему ломаться?
[01:28:44.680 --> 01:28:46.680]  Он просто всегда
[01:28:46.680 --> 01:28:48.680]  для пустых структур...
[01:28:48.680 --> 01:28:50.680]  Он не умеет выдавать ответы
[01:28:50.680 --> 01:28:52.680]  меньше единицы.
[01:28:52.680 --> 01:28:54.680]  Вот этот код не умеет выдавать ответы
[01:28:54.680 --> 01:28:56.680]  меньше единицы.
[01:28:56.680 --> 01:28:58.680]  Всегда хотя бы единицу
[01:28:58.680 --> 01:29:00.680]  выдаст, в том числе для пустых структур.
[01:29:00.680 --> 01:29:02.680]  Нам это не нравится, заменяем на агрегатную
[01:29:02.680 --> 01:29:04.680]  инициализацию.
[01:29:04.680 --> 01:29:06.680]  Копи-конструктор довольны,
[01:29:06.680 --> 01:29:08.680]  идем дальше.
[01:29:08.680 --> 01:29:10.680]  Вот финальный код, он работает
[01:29:10.680 --> 01:29:12.680]  довольно все счастливо.
[01:29:12.680 --> 01:29:14.680]  Окей,
[01:29:14.680 --> 01:29:16.680]  справка историческая про то,
[01:29:16.680 --> 01:29:18.680]  как раньше мучались люди.
[01:29:18.680 --> 01:29:20.680]  Не помню почему,
[01:29:20.680 --> 01:29:22.680]  почему-то короче.
[01:29:24.680 --> 01:29:26.680]  Есть техника взять
[01:29:26.680 --> 01:29:28.680]  и оценить количество полей сверху
[01:29:28.680 --> 01:29:30.680]  как размер структуры.
[01:29:30.680 --> 01:29:32.680]  У нас каждое поле хотя бы один байт,
[01:29:32.680 --> 01:29:34.680]  и можно идти наоборот сверху вниз.
[01:29:36.680 --> 01:29:38.680]  По-моему мучились, потому что
[01:29:38.680 --> 01:29:40.680]  агрегатная инициализация
[01:29:40.680 --> 01:29:42.680]  как-то не так работала, и там что-то
[01:29:42.680 --> 01:29:44.680]  с этим связано. Не важно.
[01:29:46.680 --> 01:29:48.680]  Да, уменьшаем, то есть идем
[01:29:48.680 --> 01:29:50.680]  сверху вниз, и через финай
[01:29:50.680 --> 01:29:52.680]  там типа
[01:29:52.680 --> 01:29:54.680]  возможность конструирования как-то смотрим.
[01:29:54.680 --> 01:29:56.680]  Ну, не знаю.
[01:29:56.680 --> 01:29:58.680]  Это все когда-то было, сейчас уже
[01:29:58.680 --> 01:30:00.680]  нет. Если у вас на работе нет
[01:30:00.680 --> 01:30:02.680]  Т++14, то
[01:30:02.680 --> 01:30:04.680]  переквалифицируйтесь в растеры,
[01:30:04.680 --> 01:30:06.680]  как можно скорее.
[01:30:08.680 --> 01:30:10.680]  Нет, сейчас.
[01:30:10.680 --> 01:30:12.680]  А, это как раз в C++14 так было, что ли?
[01:30:12.680 --> 01:30:14.680]  А в 17 поправили.
[01:30:14.680 --> 01:30:16.680]  Ну ладно.
[01:30:16.680 --> 01:30:18.680]  Агрегатная инициализация в каждом стандарте фиксили,
[01:30:18.680 --> 01:30:20.680]  по-своему, из разных приколов.
[01:30:20.680 --> 01:30:22.680]  Ну ладно.
[01:30:22.680 --> 01:30:24.680]  Это не сильно большая сложность, блин.
[01:30:24.680 --> 01:30:26.680]  Ну то есть с no unique address будет работать
[01:30:26.680 --> 01:30:28.680]  никак. То есть вот из-за вот этого
[01:30:28.680 --> 01:30:30.680]  снивания сверх как сайзов,
[01:30:30.680 --> 01:30:32.680]  no unique address все поломает.
[01:30:32.680 --> 01:30:34.680]  Ну,
[01:30:34.680 --> 01:30:36.680]  что-то в 17
[01:30:36.680 --> 01:30:38.680]  плюсах с агрегатной инициализацией
[01:30:38.680 --> 01:30:40.680]  поменяли. Не помню,
[01:30:40.680 --> 01:30:42.680]  не знаю. Давай ехать дальше.
[01:30:42.680 --> 01:30:44.680]  Ну просто имейте в виду, что
[01:30:44.680 --> 01:30:46.680]  многое, что здесь рассказывается, оно там
[01:30:46.680 --> 01:30:48.680]  зависит от стандарта, и я на всякий случай
[01:30:48.680 --> 01:30:50.680]  все-таки вставляю слайды, с какого до какого
[01:30:50.680 --> 01:30:52.680]  это работает.
[01:30:52.680 --> 01:30:54.680]  Вот, замечание.
[01:30:54.680 --> 01:30:56.680]  Вот здесь не работает.
[01:30:56.680 --> 01:30:58.680]  То есть no unique address говорит, что
[01:30:58.680 --> 01:31:00.680]  давайте под это поле не выделять ни
[01:31:00.680 --> 01:31:02.680]  одного байта, и вот
[01:31:02.680 --> 01:31:04.680]  будет беда.
[01:31:04.680 --> 01:31:06.680]  Да.
[01:31:06.680 --> 01:31:08.680]  Как?
[01:31:10.680 --> 01:31:12.680]  Бинпоиск.
[01:31:12.680 --> 01:31:14.680]  Если вам понадобится в домашке,
[01:31:14.680 --> 01:31:16.680]  надеюсь, вы сами справитесь.
[01:31:16.680 --> 01:31:18.680]  Но no unique address по-моему что-то ломает с бинпоиском.
[01:31:18.680 --> 01:31:20.680]  Но не уверен.
[01:31:20.680 --> 01:31:22.680]  А, сейчас, это
[01:31:22.680 --> 01:31:24.680]  вот к этому.
[01:31:24.680 --> 01:31:26.680]  Вот это можно соптимизировать до
[01:31:26.680 --> 01:31:28.680]  log n,
[01:31:28.680 --> 01:31:30.680]  потому что вы знаете уже левую-правую
[01:31:30.680 --> 01:31:32.680]  границу, начинайте бинпоиск делать, если
[01:31:32.680 --> 01:31:34.680]  no unique address нет, все хорошо.
[01:31:34.680 --> 01:31:36.680]  Но, как сделать бинпоиск,
[01:31:36.680 --> 01:31:38.680]  если вы даже верхней границы не знаете,
[01:31:38.680 --> 01:31:40.680]  но уверены, что монотонна функция?
[01:31:42.680 --> 01:31:44.680]  Да.
[01:31:44.680 --> 01:31:46.680]  Прыгайте вверх, умножая на 2,
[01:31:46.680 --> 01:31:48.680]  тут в какой-то момент перестал
[01:31:48.680 --> 01:31:50.680]  работать, опа, вот это и предыдущая,
[01:31:50.680 --> 01:31:52.680]  между ними уже обычный бинпоиск.
[01:31:52.680 --> 01:31:54.680]  Ну, просто смотри,
[01:31:54.680 --> 01:31:56.680]  если ты будешь вот так вот расти вверх,
[01:31:56.680 --> 01:31:58.680]  умножая на 2,
[01:31:58.680 --> 01:32:00.680]  а потом между границами бинпоиска,
[01:32:00.680 --> 01:32:02.680]  то это будет работать с no unique address
[01:32:02.680 --> 01:32:04.680]  и проблем не будет.
[01:32:04.680 --> 01:32:06.680]  Зачем
[01:32:06.680 --> 01:32:08.680]  усложнять жизнь людям,
[01:32:08.680 --> 01:32:10.680]  если можно ее не усложнять,
[01:32:10.680 --> 01:32:12.680]  это как бы девиз разработчиков
[01:32:12.680 --> 01:32:14.680]  библиотека должен быть.
[01:32:14.680 --> 01:32:16.680]  Мы здесь страдаем,
[01:32:16.680 --> 01:32:18.680]  а чтобы вы там
[01:32:18.680 --> 01:32:20.680]  жили в свете.
[01:32:20.680 --> 01:32:22.680]  Все, давайте,
[01:32:22.680 --> 01:32:24.680]  надо следить за временем,
[01:32:24.680 --> 01:32:26.680]  очень мало времени,
[01:32:26.680 --> 01:32:28.680]  перерыв уже был,
[01:32:28.680 --> 01:32:30.680]  остался час, надеюсь за этот час
[01:32:30.680 --> 01:32:32.680]  мы сейчас успеем самое убойное,
[01:32:32.680 --> 01:32:34.680]  типы полей.
[01:32:34.680 --> 01:32:36.680]  Сейчас будет хорошо.
[01:32:36.680 --> 01:32:38.680]  Итак, 2014 год,
[01:32:38.680 --> 01:32:40.680]  первое решение,
[01:32:40.680 --> 01:32:42.680]  как узнать список
[01:32:42.680 --> 01:32:44.680]  типов полей?
[01:32:44.680 --> 01:32:46.680]  В идеале, что мы хотим?
[01:32:46.680 --> 01:32:48.680]  Ну буквально список типов получить.
[01:32:48.680 --> 01:32:50.680]  Есть поля у вашей структуры,
[01:32:50.680 --> 01:32:52.680]  у нас есть списки типов,
[01:32:52.680 --> 01:32:54.680]  хотим список типов в порядке
[01:32:54.680 --> 01:32:56.680]  объявления полей,
[01:32:56.680 --> 01:32:58.680]  типов этих полей.
[01:32:58.680 --> 01:33:00.680]  Ну,
[01:33:00.680 --> 01:33:02.680]  вот мы сконструировали
[01:33:02.680 --> 01:33:04.680]  нашу штуку от nubic конструкторов,
[01:33:04.680 --> 01:33:06.680]  количество полей уже знаем,
[01:33:06.680 --> 01:33:08.680]  запомнили, больше не спрашиваем,
[01:33:08.680 --> 01:33:10.680]  количество полей известно.
[01:33:10.680 --> 01:33:12.680]  Запихнем, пусть это n,
[01:33:12.680 --> 01:33:14.680]  запихнем nubic конструкторов
[01:33:14.680 --> 01:33:16.680]  в нашу структуру,
[01:33:16.680 --> 01:33:18.680]  в инициализацию.
[01:33:18.680 --> 01:33:20.680]  Внутри этого оператора
[01:33:20.680 --> 01:33:22.680]  мы будем знать тип,
[01:33:22.680 --> 01:33:24.680]  правда?
[01:33:24.680 --> 01:33:26.680]  Да, можно
[01:33:26.680 --> 01:33:28.680]  что-то написать сюда.
[01:33:28.680 --> 01:33:30.680]  Но вот беда,
[01:33:30.680 --> 01:33:32.680]  вытащить наружу этот тип
[01:33:32.680 --> 01:33:34.680]  мы вообще не понимаем как,
[01:33:34.680 --> 01:33:36.680]  потому что где мы здесь по стеку вызовов?
[01:33:36.680 --> 01:33:38.680]  Находимся внутри
[01:33:38.680 --> 01:33:40.680]  конструктора нашей структуры,
[01:33:40.680 --> 01:33:42.680]  а потом
[01:33:42.680 --> 01:33:44.680]  внутри как бы оператора
[01:33:44.680 --> 01:33:46.680]  каста, вот этого.
[01:33:46.680 --> 01:33:48.680]  И через этот конструктор структуры вытащить
[01:33:48.680 --> 01:33:50.680]  наружу какую-то информацию,
[01:33:50.680 --> 01:33:52.680]  но мы не можем.
[01:33:52.680 --> 01:33:54.680]  Тайп дедакшн будет работать в классах?
[01:33:54.680 --> 01:33:56.680]  В классах?
[01:33:56.680 --> 01:33:58.680]  Тайп дедакшн? Да.
[01:33:58.680 --> 01:34:00.680]  Да.
[01:34:00.680 --> 01:34:02.680]  А мы тоже откуда не вытащим?
[01:34:02.680 --> 01:34:04.680]  Ну, не вытащим,
[01:34:04.680 --> 01:34:06.680]  все равно да.
[01:34:06.680 --> 01:34:08.680]  Если вы задумаетесь,
[01:34:08.680 --> 01:34:10.680]  вытащить нельзя.
[01:34:10.680 --> 01:34:12.680]  Именно тип, именно в компайл тайме.
[01:34:12.680 --> 01:34:14.680]  Ну,
[01:34:16.680 --> 01:34:18.680]  как бы это
[01:34:18.680 --> 01:34:20.680]  не останавливает очень многих людей.
[01:34:22.680 --> 01:34:24.680]  Встречались ли вы когда-нибудь
[01:34:24.680 --> 01:34:26.680]  с системами ID-шников типов?
[01:34:28.680 --> 01:34:30.680]  Тайп ID?
[01:34:30.680 --> 01:34:32.680]  Тайп ID, да, есть такое в стандарте,
[01:34:32.680 --> 01:34:34.680]  но оно вам выдает не ID-шник типы,
[01:34:34.680 --> 01:34:36.680]  а какую-то информацию о типе.
[01:34:36.680 --> 01:34:38.680]  Вообще говоря, можно
[01:34:38.680 --> 01:34:40.680]  забабахать систему,
[01:34:40.680 --> 01:34:42.680]  которая произвольные типы
[01:34:42.680 --> 01:34:44.680]  перегоняет в
[01:34:44.680 --> 01:34:46.680]  индексы какие-то.
[01:34:46.680 --> 01:34:48.680]  В Unreal Engine, кстати, она есть.
[01:34:50.680 --> 01:34:52.680]  Шаблон просто Randall Jackson.
[01:34:52.680 --> 01:34:54.680]  Чего? Randall Jackson?
[01:34:54.680 --> 01:34:56.680]  Не-не-не.
[01:34:56.680 --> 01:34:58.680]  Ну...
[01:34:58.680 --> 01:35:00.680]  Тихо, тихо,
[01:35:00.680 --> 01:35:02.680]  замолчи, тихо.
[01:35:02.680 --> 01:35:04.680]  Не говори.
[01:35:04.680 --> 01:35:06.680]  Тайп ID
[01:35:06.680 --> 01:35:08.680]  это внутри
[01:35:09.680 --> 01:35:11.680]  Ну да, еще...
[01:35:11.680 --> 01:35:13.680]  Короче, какой-то ID-шник
[01:35:13.680 --> 01:35:15.680]  присвоить каждому типу в вашем коде.
[01:35:15.680 --> 01:35:17.680]  Это делать
[01:35:17.680 --> 01:35:19.680]  с многими разными интересными
[01:35:19.680 --> 01:35:21.680]  способами, там всякие
[01:35:21.680 --> 01:35:23.680]  костыли, можно просто для всех встроенных
[01:35:23.680 --> 01:35:25.680]  типов ID-шники заранее расписать.
[01:35:27.680 --> 01:35:29.680]  И в принципе это работает.
[01:35:29.680 --> 01:35:31.680]  Вообще в общем случае эта проблема
[01:35:31.680 --> 01:35:33.680]  не решается.
[01:35:33.680 --> 01:35:35.680]  Да, а есть смешная
[01:35:35.680 --> 01:35:37.680]  техника, что генерировать функции
[01:35:37.680 --> 01:35:39.680]  на каждый тип
[01:35:39.680 --> 01:35:41.680]  и их адреса записывать как ID-шники.
[01:35:41.680 --> 01:35:43.680]  Это вполне может
[01:35:43.680 --> 01:35:45.680]  сработать.
[01:35:45.680 --> 01:35:47.680]  Видели ли мы такое?
[01:35:47.680 --> 01:35:49.680]  По-моему, видели.
[01:35:49.680 --> 01:35:51.680]  Мы, может быть, так сравнивали при
[01:35:51.680 --> 01:35:53.680]  обезвечивании типов, мы сравнивали функции.
[01:35:53.680 --> 01:35:55.680]  Да.
[01:35:55.680 --> 01:35:57.680]  Во-во-во. Вот ровно то же самое.
[01:35:57.680 --> 01:35:59.680]  Можно взять указатель на функцию, прикастить
[01:35:59.680 --> 01:36:01.680]  звездочку, звездочку превратить
[01:36:01.680 --> 01:36:03.680]  в input.rt, и вот у вас будет ID-шник
[01:36:03.680 --> 01:36:05.680]  типа. До какой
[01:36:05.680 --> 01:36:07.680]  степени это работает, как только у вас есть
[01:36:07.680 --> 01:36:09.680]  shared libraries.
[01:36:09.680 --> 01:36:11.680]  Вы про shared библиотеки знаете
[01:36:11.680 --> 01:36:13.680]  что-нибудь, наверное.
[01:36:13.680 --> 01:36:15.680]  С ними это уже не работает.
[01:36:15.680 --> 01:36:17.680]  Тут разные люди, разные хаки
[01:36:17.680 --> 01:36:19.680]  придумывали, но там всегда проблемы,
[01:36:19.680 --> 01:36:21.680]  что если вы даже базовые типы
[01:36:21.680 --> 01:36:23.680]  захардкодите, с пользовательскими
[01:36:23.680 --> 01:36:25.680]  типами, янамами, указателями,
[01:36:25.680 --> 01:36:27.680]  проблемы, их можно
[01:36:27.680 --> 01:36:29.680]  закостылять, еще там CV-квалификаторы
[01:36:29.680 --> 01:36:31.680]  не забываем.
[01:36:31.680 --> 01:36:33.680]  Люди придумали гениальную вещь,
[01:36:33.680 --> 01:36:35.680]  это вот из какого-то доклада, не помню
[01:36:35.680 --> 01:36:37.680]  какого в репозитории ссылка есть.
[01:36:37.680 --> 01:36:39.680]  Предлагают
[01:36:39.680 --> 01:36:41.680]  там хранить
[01:36:41.680 --> 01:36:43.680]  в первой или там в последних
[01:36:43.680 --> 01:36:45.680]  с каких-то битах
[01:36:45.680 --> 01:36:47.680]  номер
[01:36:47.680 --> 01:36:49.680]  встроенного типа.
[01:36:49.680 --> 01:36:51.680]  Там прямо для unsigned
[01:36:51.680 --> 01:36:53.680]  char свой номер захардкодили,
[01:36:53.680 --> 01:36:55.680]  для intа свой номер захардкодили,
[01:36:55.680 --> 01:36:57.680]  для shrta тоже захардкодили.
[01:36:57.680 --> 01:36:59.680]  Храним эти номера в нижних с каких-то битах.
[01:36:59.680 --> 01:37:01.680]  А верхних битах
[01:37:01.680 --> 01:37:03.680]  берем по три бита
[01:37:03.680 --> 01:37:05.680]  и начинаем в них хранить CV-квалификаторы
[01:37:05.680 --> 01:37:07.680]  и является ли указателем.
[01:37:07.680 --> 01:37:09.680]  Гениально, да?
[01:37:09.680 --> 01:37:11.680]  А по-моему unsigned
[01:37:11.680 --> 01:37:13.680]  тоже они предлагают так хранить.
[01:37:15.680 --> 01:37:17.680]  Да, но
[01:37:17.680 --> 01:37:19.680]  у тебя тут целых раз, два, три,
[01:37:19.680 --> 01:37:21.680]  ну короче много, больше не понадобится.
[01:37:31.680 --> 01:37:33.680]  В ГЦЦ еще как визит
[01:37:33.680 --> 01:37:35.680]  реализован.
[01:37:35.680 --> 01:37:37.680]  До 11 работает.
[01:37:37.680 --> 01:37:39.680]  А дальше?
[01:37:39.680 --> 01:37:41.680]  Ну все, зачем тебе больше?
[01:37:41.680 --> 01:37:43.680]  Зачем вам визитить
[01:37:43.680 --> 01:37:45.680]  Зачем вам визитить
[01:37:45.680 --> 01:37:47.680]  варианты, в которых больше 11 элементов?
[01:37:47.680 --> 01:37:49.680]  Ну реально.
[01:37:49.680 --> 01:37:51.680]  Зачем вам теплы, в которых
[01:37:51.680 --> 01:37:53.680]  больше, чем там 16 элементов?
[01:37:53.680 --> 01:37:55.680]  Не бывает так.
[01:37:55.680 --> 01:37:57.680]  Ну вот, такие хаки
[01:37:57.680 --> 01:37:59.680]  придумали люди, презентовали.
[01:37:59.680 --> 01:38:01.680]  Можете это пересерчить, если интересно,
[01:38:01.680 --> 01:38:03.680]  но я лютый хейтер вот этой
[01:38:03.680 --> 01:38:05.680]  штуки, потому что пытался с этим
[01:38:05.680 --> 01:38:07.680]  работать и как-то делать, и ничего не получается.
[01:38:07.680 --> 01:38:09.680]  Всегда какие-то костыли,
[01:38:09.680 --> 01:38:11.680]  крайние случаи вылезают,
[01:38:11.680 --> 01:38:13.680]  рекомендуют янамо в
[01:38:13.680 --> 01:38:15.680]  андерлайинг-тайпы превращать, но отличная
[01:38:15.680 --> 01:38:17.680]  рефлексия, мы забыли, какой тип янамо был.
[01:38:17.680 --> 01:38:19.680]  Абсолютно не помогает.
[01:38:19.680 --> 01:38:21.680]  А идишники для типов это
[01:38:21.680 --> 01:38:23.680]  беда.
[01:38:23.680 --> 01:38:25.680]  Есть другой подход,
[01:38:25.680 --> 01:38:27.680]  реактивный.
[01:38:27.680 --> 01:38:29.680]  Ну я не ожидаю,
[01:38:29.680 --> 01:38:31.680]  что вы знаете, в каком смысле здесь это слово
[01:38:31.680 --> 01:38:33.680]  употреблено, это же из GUI,
[01:38:33.680 --> 01:38:35.680]  а GUI, как правило, никто не занимается,
[01:38:35.680 --> 01:38:37.680]  потому что это лютая дичь.
[01:38:37.680 --> 01:38:39.680]  Занимается кто-нибудь GUI здесь?
[01:38:39.680 --> 01:38:41.680]  Реактивная.
[01:38:41.680 --> 01:38:43.680]  Напомним ли ты про Асю?
[01:38:43.680 --> 01:38:45.680]  А, не, ну ладно, в таком
[01:38:45.680 --> 01:38:47.680]  смысле тоже.
[01:38:47.680 --> 01:38:49.680]  Короче, реактивная GUI.
[01:38:49.680 --> 01:38:51.680]  По-моему из GUI все-таки пошла, нет.
[01:38:51.680 --> 01:38:53.680]  Ну ладно.
[01:38:53.680 --> 01:38:55.680]  Реактивная GUI,
[01:38:55.680 --> 01:38:57.680]  никто ничему не говорит.
[01:38:57.680 --> 01:38:59.680]  Ну и ладно.
[01:38:59.680 --> 01:39:01.680]  Давайте просто посмотрим.
[01:39:01.680 --> 01:39:03.680]  Тип знаем.
[01:39:03.680 --> 01:39:05.680]  Можем сюда в какой-то вызов функции вписать,
[01:39:05.680 --> 01:39:07.680]  и у этой функции будет этот тип.
[01:39:07.680 --> 01:39:09.680]  И она что-то сделать с ним сможет,
[01:39:09.680 --> 01:39:11.680]  что ей нужно.
[01:39:11.680 --> 01:39:13.680]  Ну если нам нужно просто вывести там
[01:39:13.680 --> 01:39:15.680]  какое-нибудь имя типа,
[01:39:15.680 --> 01:39:17.680]  прекрасно сможем в циаут вывести
[01:39:17.680 --> 01:39:19.680]  внутри этой функции.
[01:39:19.680 --> 01:39:21.680]  Просто indirection добавили.
[01:39:21.680 --> 01:39:23.680]  Callback, да.
[01:39:23.680 --> 01:39:25.680]  И в целом всякие подходы
[01:39:25.680 --> 01:39:27.680]  с callback-ами и реагированием
[01:39:27.680 --> 01:39:29.680]  на что-то, он как раз называется
[01:39:29.680 --> 01:39:31.680]  реактивным программированием.
[01:39:31.680 --> 01:39:33.680]  Можете об этом почитать, я рекомендую.
[01:39:33.680 --> 01:39:35.680]  Оно весьма интересно и забавно,
[01:39:35.680 --> 01:39:37.680]  но на практике что-то как-то у меня
[01:39:37.680 --> 01:39:39.680]  все не срастается, чтобы нормально оно
[01:39:39.680 --> 01:39:41.680]  архитектурно
[01:39:41.680 --> 01:39:43.680]  подошло. Ну ладно.
[01:39:43.680 --> 01:39:45.680]  Ну вот вопрос
[01:39:45.680 --> 01:39:47.680]  только, как все это протащить?
[01:39:47.680 --> 01:39:49.680]  Мы же в юбике, а он
[01:39:49.680 --> 01:39:51.680]  в конструкторе каком-то.
[01:39:51.680 --> 01:39:53.680]  Да, как теперь?
[01:39:53.680 --> 01:39:55.680]  Шаблонные параметры юбика.
[01:39:55.680 --> 01:39:57.680]  Ну как бы да, нужно добавить шаблонные параметры
[01:39:57.680 --> 01:39:59.680]  юбика и накапливать в них список
[01:39:59.680 --> 01:40:01.680]  вот этих вот имен,
[01:40:01.680 --> 01:40:03.680]  список этих типов,
[01:40:03.680 --> 01:40:05.680]  типов членов.
[01:40:05.680 --> 01:40:07.680]  И надо
[01:40:07.680 --> 01:40:09.680]  делать рекурсию.
[01:40:09.680 --> 01:40:11.680]  Мы будем в вот этой функции смешной
[01:40:11.680 --> 01:40:13.680]  запускать tmp
[01:40:13.680 --> 01:40:15.680]  от там нескольких юбиков,
[01:40:15.680 --> 01:40:17.680]  а внутри юбика
[01:40:17.680 --> 01:40:19.680]  запускать обратно функцию.
[01:40:19.680 --> 01:40:21.680]  И
[01:40:21.680 --> 01:40:23.680]  так делать
[01:40:23.680 --> 01:40:25.680]  по количеству этих
[01:40:27.680 --> 01:40:29.680]  полей. Мы его уже знаем.
[01:40:29.680 --> 01:40:31.680]  Заранее там
[01:40:31.680 --> 01:40:33.680]  думаем, договариваемся, что вот так вот
[01:40:33.680 --> 01:40:35.680]  проходим, накапливая, накапливая эти
[01:40:35.680 --> 01:40:37.680]  типы, все больше и больше
[01:40:37.680 --> 01:40:39.680]  стек наращивая,
[01:40:39.680 --> 01:40:41.680]  собирая все типы
[01:40:41.680 --> 01:40:43.680]  полей, и в самом последнем
[01:40:43.680 --> 01:40:45.680]  уровне мы можем взять
[01:40:45.680 --> 01:40:47.680]  и бахнуть callback.
[01:40:47.680 --> 01:40:49.680]  Ну, его нужно будет
[01:40:49.680 --> 01:40:51.680]  протащить, да.
[01:40:51.680 --> 01:40:53.680]  То есть
[01:40:53.680 --> 01:40:55.680]  внезапно здесь мы
[01:40:55.680 --> 01:40:57.680]  если там вернемся,
[01:40:57.680 --> 01:40:59.680]  то попадем обратно
[01:40:59.680 --> 01:41:01.680]  в юбик, да. Представляете
[01:41:01.680 --> 01:41:03.680]  в голове вот этот стек огромный.
[01:41:03.680 --> 01:41:05.680]  Мы вошли сюда,
[01:41:05.680 --> 01:41:07.680]  потом вошли
[01:41:07.680 --> 01:41:09.680]  в юбик, потом из юбика сюда,
[01:41:09.680 --> 01:41:11.680]  туда-сюда, туда-сюда, так по количеству
[01:41:11.680 --> 01:41:13.680]  полей раз
[01:41:13.680 --> 01:41:15.680]  и накопили вот это вот все,
[01:41:15.680 --> 01:41:17.680]  и вот как бы
[01:41:17.680 --> 01:41:19.680]  ну, наружу точно никакой возможности
[01:41:19.680 --> 01:41:21.680]  что-то вернуть решительно нет.
[01:41:21.680 --> 01:41:23.680]  Но мы можем запустить callback,
[01:41:23.680 --> 01:41:25.680]  точно так же, как мы, кстати, только что делали.
[01:41:25.680 --> 01:41:27.680]  Вот этот синтаксис смешной,
[01:41:27.680 --> 01:41:29.680]  template-оператор,
[01:41:29.680 --> 01:41:31.680]  types.
[01:41:31.680 --> 01:41:33.680]  Окей,
[01:41:33.680 --> 01:41:35.680]  вот эта идея понятна, правда?
[01:41:35.680 --> 01:41:37.680]  Она тупая, бесполезная,
[01:41:37.680 --> 01:41:39.680]  сложно понять, что
[01:41:39.680 --> 01:41:41.680]  написано, но она работает, потому что мы
[01:41:41.680 --> 01:41:43.680]  теперь можем
[01:41:43.680 --> 01:41:45.680]  взять и вызвать вот этот вот forage field
[01:41:45.680 --> 01:41:47.680]  mystract с лямбдой,
[01:41:47.680 --> 01:41:49.680]  который принимает пак типов,
[01:41:49.680 --> 01:41:51.680]  и нам в этот пак типов
[01:41:51.680 --> 01:41:53.680]  собственно засунут все
[01:41:53.680 --> 01:41:55.680]  типы, которые были у мемберов,
[01:41:55.680 --> 01:41:57.680]  у полей.
[01:41:57.680 --> 01:41:59.680]  И это будет работать. Окей?
[01:42:01.680 --> 01:42:03.680]  Все.
[01:42:03.680 --> 01:42:05.680]  С этим, кажется,
[01:42:05.680 --> 01:42:07.680]  разобрались,
[01:42:07.680 --> 01:42:09.680]  я надеюсь.
[01:42:09.680 --> 01:42:11.680]  Ну, тут какие-то плюсы,
[01:42:11.680 --> 01:42:13.680]  минусы есть.
[01:42:13.680 --> 01:42:15.680]  То, что она через callback и
[01:42:15.680 --> 01:42:17.680]  линейный количественный инстанциации,
[01:42:17.680 --> 01:42:19.680]  это, конечно, супер плохо.
[01:42:19.680 --> 01:42:21.680]  Где я соврал?
[01:42:23.680 --> 01:42:25.680]  Я только что соврал.
[01:42:25.680 --> 01:42:27.680]  Смотрим сюда.
[01:42:27.680 --> 01:42:29.680]  Ты так думаешь?
[01:42:29.680 --> 01:42:31.680]  Ну, это близко
[01:42:31.680 --> 01:42:33.680]  к правде.
[01:42:33.680 --> 01:42:35.680]  В самом деле экспоненциальное тут написано.
[01:42:35.680 --> 01:42:37.680]  Вообще-то.
[01:42:37.680 --> 01:42:39.680]  Ну,
[01:42:39.680 --> 01:42:41.680]  потому что мы сейчас ветвимся каждый раз.
[01:42:41.680 --> 01:42:43.680]  Мы начинаем с одного юбика,
[01:42:43.680 --> 01:42:45.680]  запускаем
[01:42:45.680 --> 01:42:47.680]  один раз forage in-depth.
[01:42:47.680 --> 01:42:49.680]  А он запускает уже двух юбиков.
[01:42:49.680 --> 01:42:51.680]  А дальше каждый из этих двух юбиков
[01:42:51.680 --> 01:42:53.680]  запускает трех.
[01:42:53.680 --> 01:42:55.680]  И их суммарно шесть.
[01:42:55.680 --> 01:42:57.680]  Дальше каждый из этих вот шести
[01:42:57.680 --> 01:42:59.680]  запускает для четырех.
[01:42:59.680 --> 01:43:01.680]  Итого их там
[01:43:01.680 --> 01:43:03.680]  четыре на шесть.
[01:43:03.680 --> 01:43:05.680]  Ну, вы поняли, да?
[01:43:05.680 --> 01:43:07.680]  Экспоненциальное количество инстанциации,
[01:43:07.680 --> 01:43:09.680]  вот так не надо это писать.
[01:43:09.680 --> 01:43:11.680]  Не поняли?
[01:43:11.680 --> 01:43:13.680]  Кажется, оно даже сверхэкспоненциальное,
[01:43:13.680 --> 01:43:15.680]  потому что по описанию выкрутили факториал.
[01:43:15.680 --> 01:43:17.680]  Ну, неважно.
[01:43:17.680 --> 01:43:19.680]  Ну, факториал и факториал.
[01:43:19.680 --> 01:43:21.680]  Для меня факториал от экспонента не отличается.
[01:43:21.680 --> 01:43:23.680]  Ну, поняли, да?
[01:43:23.680 --> 01:43:25.680]  Почему это происходит?
[01:43:25.680 --> 01:43:27.680]  Так делать не надо, надо где-то обрубить
[01:43:27.680 --> 01:43:29.680]  вот эту рекурсию.
[01:43:29.680 --> 01:43:31.680]  Ну, то есть где-то здесь какой-то ИИФ написать
[01:43:31.680 --> 01:43:33.680]  и выйти наружу.
[01:43:33.680 --> 01:43:35.680]  Даже если вы выйдете наружу, у вас кажется
[01:43:35.680 --> 01:43:37.680]  все равно квадратично будет, или что-то такое.
[01:43:37.680 --> 01:43:39.680]  И там, ну, беда.
[01:43:39.680 --> 01:43:41.680]  Ничего не выйдет,
[01:43:41.680 --> 01:43:43.680]  чтобы сделать это нормальным.
[01:43:43.680 --> 01:43:45.680]  Но зато это работает со всеми типами
[01:43:45.680 --> 01:43:47.680]  и вроде никаких супер лютых
[01:43:47.680 --> 01:43:49.680]  хаков нету, которые ограничивают
[01:43:49.680 --> 01:43:51.680]  нас как-то.
[01:43:51.680 --> 01:43:53.680]  Вот, а теперь давайте
[01:43:53.680 --> 01:43:55.680]  все сосредоточимся.
[01:43:55.680 --> 01:43:57.680]  Давайте откроем окошко немного.
[01:43:57.680 --> 01:43:59.680]  Воздух нам понадобится.
[01:43:59.680 --> 01:44:01.680]  Кульминационный
[01:44:01.680 --> 01:44:03.680]  момент курса просто.
[01:44:03.680 --> 01:44:05.680]  Апогей, как сказал Арсений
[01:44:05.680 --> 01:44:07.680]  Станиславович.
[01:44:09.680 --> 01:44:11.680]  Так.
[01:44:13.680 --> 01:44:15.680]  Сосредоточились.
[01:44:15.680 --> 01:44:17.680]  Поехали.
[01:44:17.680 --> 01:44:19.680]  Сразу
[01:44:19.680 --> 01:44:21.680]  говорю, что макросов здесь нигде
[01:44:21.680 --> 01:44:23.680]  не используется и не будут
[01:44:23.680 --> 01:44:25.680]  использоваться.
[01:44:25.680 --> 01:44:27.680]  Код.
[01:44:27.680 --> 01:44:29.680]  Всегда ли он верен?
[01:44:29.680 --> 01:44:31.680]  Вот эта статика с сёртом
[01:44:31.680 --> 01:44:33.680]  всегда
[01:44:33.680 --> 01:44:35.680]  не сработает, но в плане, что
[01:44:35.680 --> 01:44:37.680]  окей, всё будет.
[01:44:43.680 --> 01:44:45.680]  Ну, так, подумайте.
[01:44:45.680 --> 01:44:47.680]  Если вы догадались, то лучше
[01:44:47.680 --> 01:44:49.680]  всё-таки молчите, чтобы остальные
[01:44:49.680 --> 01:44:51.680]  тоже как-то напряглись.
[01:44:51.680 --> 01:44:53.680]  Ну, что-то
[01:44:53.680 --> 01:44:55.680]  возможно.
[01:44:55.680 --> 01:44:57.680]  Если подумать
[01:44:57.680 --> 01:44:59.680]  просто про нормальный язык C++,
[01:44:59.680 --> 01:45:01.680]  то вообще-то constexpr это значит
[01:45:01.680 --> 01:45:03.680]  имутабельно.
[01:45:03.680 --> 01:45:05.680]  Любая constexpr функция, она как бы чистая
[01:45:05.680 --> 01:45:07.680]  вообще-то. Как у вас constexpr
[01:45:07.680 --> 01:45:09.680]  функция может
[01:45:09.680 --> 01:45:11.680]  возвращать
[01:45:11.680 --> 01:45:13.680]  что-то разное, там даже разных
[01:45:13.680 --> 01:45:15.680]  типов или
[01:45:15.680 --> 01:45:17.680]  ну, это же бред.
[01:45:17.680 --> 01:45:19.680]  Или вот так вот даже, да?
[01:45:19.680 --> 01:45:21.680]  Просто constexpr функции, они же
[01:45:21.680 --> 01:45:23.680]  обязаны, ну, во-первых,
[01:45:23.680 --> 01:45:25.680]  типы у них, ну, возвращаемый тип у
[01:45:25.680 --> 01:45:27.680]  функции есть, ну, всё, как он может меняться.
[01:45:27.680 --> 01:45:29.680]  Во-вторых, значения constexpr функции,
[01:45:29.680 --> 01:45:31.680]  они всегда чистые.
[01:45:31.680 --> 01:45:33.680]  У вас нету никакого рандома в compile time.
[01:45:33.680 --> 01:45:35.680]  У вас нету никакого global
[01:45:35.680 --> 01:45:37.680]  стоита, который вы могли бы менять
[01:45:37.680 --> 01:45:39.680]  и там перещелкивать что-то. Ну, не должно быть.
[01:45:39.680 --> 01:45:41.680]  Просто математическая функция,
[01:45:41.680 --> 01:45:43.680]  дали ноль, всегда на вход одно и то же должно получить.
[01:45:43.680 --> 01:45:45.680]  Ну, вот так-то
[01:45:45.680 --> 01:45:47.680]  уж вообще должно работать.
[01:45:47.680 --> 01:45:49.680]  Просто какую-то переменную объявили.
[01:45:49.680 --> 01:45:51.680]  Вот такого типа и вот такого. Ну, смотришь
[01:45:51.680 --> 01:45:53.680]  на код. Ну, две переменных одного типа.
[01:45:53.680 --> 01:45:55.680]  Вот, ну, должны быть одного.
[01:45:55.680 --> 01:45:57.680]  Но, оказывается, нет.
[01:45:57.680 --> 01:45:59.680]  Да,
[01:45:59.680 --> 01:46:01.680]  в современных компиляторах
[01:46:01.680 --> 01:46:03.680]  уже не очень актуально.
[01:46:03.680 --> 01:46:05.680]  Ну, и действительно сказано было
[01:46:05.680 --> 01:46:07.680]  лямды. Лямды.
[01:46:07.680 --> 01:46:09.680]  Вот
[01:46:09.680 --> 01:46:11.680]  some type и do something.
[01:46:11.680 --> 01:46:13.680]  Раньше были они. Вот их реализация.
[01:46:15.680 --> 01:46:17.680]  Не типовой шаблонный
[01:46:17.680 --> 01:46:19.680]  параметр, который
[01:46:19.680 --> 01:46:21.680]  инициализирован по умолчанию
[01:46:21.680 --> 01:46:23.680]  лямдой.
[01:46:23.680 --> 01:46:25.680]  Каким смешным свойством
[01:46:25.680 --> 01:46:27.680]  обладают лямды?
[01:46:27.680 --> 01:46:29.680]  Каждое объявление новый тип.
[01:46:29.680 --> 01:46:31.680]  Это верно. А каким
[01:46:31.680 --> 01:46:33.680]  смешным свойством обладают значения по умолчанию?
[01:46:33.680 --> 01:46:35.680]  Что для функций,
[01:46:35.680 --> 01:46:37.680]  что для шаблонов?
[01:46:37.680 --> 01:46:39.680]  Они каждый раз
[01:46:39.680 --> 01:46:41.680]  вычисляются в том месте,
[01:46:41.680 --> 01:46:43.680]  где вы попытались
[01:46:43.680 --> 01:46:45.680]  использовать шаблон или функцию,
[01:46:45.680 --> 01:46:47.680]  не упомянув этот аргумент.
[01:46:47.680 --> 01:46:49.680]  Для функции это тоже верно.
[01:46:49.680 --> 01:46:51.680]  Если вы какое-то выражение написали
[01:46:51.680 --> 01:46:53.680]  в дефолтный аргумент функции,
[01:46:53.680 --> 01:46:55.680]  то у вас это выражение каждый раз
[01:46:55.680 --> 01:46:57.680]  заново будет вычисляться в
[01:46:57.680 --> 01:46:59.680]  точке вызова функции.
[01:47:05.680 --> 01:47:07.680]  Нет. Насколько я знаю, по стандарту
[01:47:07.680 --> 01:47:09.680]  такого быть не может.
[01:47:11.680 --> 01:47:13.680]  Да. Компилятор обязан.
[01:47:13.680 --> 01:47:15.680]  Каждый раз,
[01:47:15.680 --> 01:47:17.680]  когда вы инстанцируете вот этот шаблон
[01:47:17.680 --> 01:47:19.680]  или вот этот,
[01:47:19.680 --> 01:47:21.680]  заново вычислять выражение, написанное здесь,
[01:47:21.680 --> 01:47:23.680]  в контексте
[01:47:23.680 --> 01:47:25.680]  точки инстанциации.
[01:47:25.680 --> 01:47:27.680]  А почему так сделано?
[01:47:27.680 --> 01:47:29.680]  А лямбда каждый раз новая.
[01:47:29.680 --> 01:47:31.680]  А чтобы какой-нибудь сурс локейшн сюда можно было вписать?
[01:47:31.680 --> 01:47:33.680]  А, то есть здесь сделано...
[01:47:33.680 --> 01:47:35.680]  По-моему, можно или нет?
[01:47:35.680 --> 01:47:37.680]  Не получилось.
[01:47:37.680 --> 01:47:39.680]  Ну ладно.
[01:47:39.680 --> 01:47:41.680]  Для функции это точно сделано
[01:47:41.680 --> 01:47:43.680]  с этой целью.
[01:47:43.680 --> 01:47:45.680]  В функциях можно в дефолтный аргумент вписать сурс локейшн,
[01:47:45.680 --> 01:47:47.680]  и это будет работать так,
[01:47:47.680 --> 01:47:49.680]  как вам кажется.
[01:47:49.680 --> 01:47:51.680]  Ну, кто не понимает, о чем я, неважно.
[01:47:51.680 --> 01:47:53.680]  Две главные мысли.
[01:47:53.680 --> 01:47:55.680]  Во-первых, дефолтные аргументы подставляются в точке,
[01:47:55.680 --> 01:47:57.680]  где вы написали код.
[01:47:57.680 --> 01:47:59.680]  А вторая, это что лямбды каждый раз они
[01:47:59.680 --> 01:48:01.680]  разные типы имеют.
[01:48:01.680 --> 01:48:03.680]  Ну и вот этот вот сам-тайп,
[01:48:03.680 --> 01:48:05.680]  вот этот сам-тайп,
[01:48:05.680 --> 01:48:07.680]  это каждый раз будут разные
[01:48:07.680 --> 01:48:09.680]  специализации шаблона сам-тайп,
[01:48:09.680 --> 01:48:11.680]  потому что лямбды разные.
[01:48:11.680 --> 01:48:13.680]  Вот на этой строчке одна лямба будет сгенерирована,
[01:48:13.680 --> 01:48:15.680]  и здесь тоже самое,
[01:48:15.680 --> 01:48:17.680]  на этой строчке одна лямба,
[01:48:17.680 --> 01:48:19.680]  на этой другая лямба.
[01:48:19.680 --> 01:48:21.680]  Ну и вот, ну да, тут тоже самое.
[01:48:21.680 --> 01:48:23.680]  Вот эта лямба берется и там
[01:48:23.680 --> 01:48:25.680]  возвращается.
[01:48:25.680 --> 01:48:27.680]  Ну, лямбды сравнивать нельзя,
[01:48:27.680 --> 01:48:29.680]  ну, как указатель на функции можно,
[01:48:29.680 --> 01:48:31.680]  поэтому...
[01:48:31.680 --> 01:48:33.680]  Да,
[01:48:33.680 --> 01:48:35.680]  до двадцатых плюсов
[01:48:35.680 --> 01:48:37.680]  нельзя было впихивать лямбды
[01:48:37.680 --> 01:48:39.680]  как не типовые шаблонные аргументы.
[01:48:39.680 --> 01:48:41.680]  В двадцатых плюсах очень сильно
[01:48:41.680 --> 01:48:43.680]  были требования к не типовым
[01:48:43.680 --> 01:48:45.680]  шаблонным аргументам. Раньше это могли быть
[01:48:45.680 --> 01:48:47.680]  только типы инты. Все.
[01:48:47.680 --> 01:48:49.680]  Теперь там и структуры,
[01:48:49.680 --> 01:48:51.680]  в домашней у вас уже были структуры, да,
[01:48:51.680 --> 01:48:53.680]  и флоты, и лямбды,
[01:48:53.680 --> 01:48:55.680]  и чётко всё можно.
[01:48:55.680 --> 01:48:57.680]  И это, конечно, здорово.
[01:48:57.680 --> 01:48:59.680]  Но что это нам
[01:48:59.680 --> 01:49:01.680]  позволит натворить?
[01:49:01.680 --> 01:49:03.680]  Так, опять вспоминаю,
[01:49:03.680 --> 01:49:05.680]  мы здесь знаем тип.
[01:49:05.680 --> 01:49:07.680]  Нам его нужно как-то вытащить.
[01:49:07.680 --> 01:49:09.680]  Давайте брать и вытаскивать.
[01:49:09.680 --> 01:49:11.680]  Сейчас познакомимся с...
[01:49:11.680 --> 01:49:13.680]  Лучшие вещи в этом мире.
[01:49:13.680 --> 01:49:15.680]  Можно сказать
[01:49:15.680 --> 01:49:17.680]  и лучшие вещи в этом мире,
[01:49:17.680 --> 01:49:19.680]  а можно сказать, так сказать,
[01:49:19.680 --> 01:49:21.680]  официальным именем по бумагам.
[01:49:21.680 --> 01:49:23.680]  Это дефект...
[01:49:23.680 --> 01:49:25.680]  Дефект репорта?
[01:49:25.680 --> 01:49:27.680]  Как по-русски репорт.
[01:49:27.680 --> 01:49:29.680]  Сообщение о дефекте,
[01:49:29.680 --> 01:49:31.680]  отчёт о дефекте, номер 2118,
[01:49:31.680 --> 01:49:33.680]  стейтфул мета...
[01:49:33.680 --> 01:49:35.680]  Смещённые формулировки
[01:49:35.680 --> 01:49:37.680]  текста,
[01:49:37.680 --> 01:49:39.680]  с самого описания языка
[01:49:39.680 --> 01:49:41.680]  в стандарте.
[01:49:41.680 --> 01:49:43.680]  Вот он правильно сказал,
[01:49:43.680 --> 01:49:45.680]  но слишком нудно уже.
[01:49:45.680 --> 01:49:47.680]  Даже то, что я сказал, уже слишком нудно.
[01:49:47.680 --> 01:49:49.680]  Короче, это баг в стандарте языка.
[01:49:49.680 --> 01:49:51.680]  Вы знаете, в законодательстве
[01:49:51.680 --> 01:49:53.680]  у нас РФ есть куча текста
[01:49:53.680 --> 01:49:55.680]  со сложными формулировками.
[01:49:55.680 --> 01:49:57.680]  Иногда так получается,
[01:49:57.680 --> 01:49:59.680]  что эти формулировки можно
[01:49:59.680 --> 01:50:01.680]  интерпретировать по-разному.
[01:50:01.680 --> 01:50:03.680]  В этот момент созываются люди
[01:50:03.680 --> 01:50:05.680]  ответственные за это,
[01:50:05.680 --> 01:50:07.680]  чтобы передать формулировку,
[01:50:07.680 --> 01:50:09.680]  чтобы точнее передать то,
[01:50:09.680 --> 01:50:11.680]  что мы хотели передать.
[01:50:11.680 --> 01:50:13.680]  В комитете стандартизации C++
[01:50:13.680 --> 01:50:15.680]  происходит то же самое.
[01:50:15.680 --> 01:50:17.680]  Есть некоторая неоднозначность,
[01:50:17.680 --> 01:50:19.680]  вернее, откровенный баг
[01:50:19.680 --> 01:50:21.680]  в бюрократической формулировке стандарта.
[01:50:21.680 --> 01:50:23.680]  Давайте на него смотреть.
[01:50:25.680 --> 01:50:27.680]  Очень внимательно смотрим.
[01:50:27.680 --> 01:50:29.680]  Это шаблон структуры.
[01:50:29.680 --> 01:50:31.680]  Он принимает
[01:50:31.680 --> 01:50:33.680]  шаблонный аргумент
[01:50:33.680 --> 01:50:35.680]  «инт».
[01:50:35.680 --> 01:50:37.680]  А внутри этого шаблона
[01:50:37.680 --> 01:50:39.680]  структуры есть
[01:50:39.680 --> 01:50:41.680]  декларация функции
[01:50:41.680 --> 01:50:43.680]  френда.
[01:50:43.680 --> 01:50:45.680]  Именно декларация.
[01:50:45.680 --> 01:50:47.680]  Объявлена функция лобхол,
[01:50:47.680 --> 01:50:49.680]  но не определена.
[01:50:49.680 --> 01:50:51.680]  И она не шаблонная,
[01:50:51.680 --> 01:50:53.680]  но в своих аргументах
[01:50:53.680 --> 01:50:55.680]  упоминает
[01:50:55.680 --> 01:50:57.680]  шаблонный аргумент этой структуры.
[01:50:57.680 --> 01:50:59.680]  То есть это всё
[01:50:59.680 --> 01:51:01.680]  зависимая штука,
[01:51:01.680 --> 01:51:03.680]  а вот просто штука зависимая от n.
[01:51:03.680 --> 01:51:05.680]  Если задуматься,
[01:51:05.680 --> 01:51:07.680]  что будет происходить,
[01:51:07.680 --> 01:51:09.680]  когда мы будем инстанциации
[01:51:09.680 --> 01:51:11.680]  тег от n создавать,
[01:51:11.680 --> 01:51:13.680]  инстанцировать тег от n.
[01:51:13.680 --> 01:51:15.680]  Что будет происходить?
[01:51:15.680 --> 01:51:17.680]  Для каждого n
[01:51:17.680 --> 01:51:19.680]  эта функция лобхол будет своя.
[01:51:19.680 --> 01:51:21.680]  И все они будут
[01:51:21.680 --> 01:51:23.680]  перегрузками друг друга, грубо говоря.
[01:51:25.680 --> 01:51:27.680]  Это пока только декларация.
[01:51:27.680 --> 01:51:29.680]  Если мы
[01:51:29.680 --> 01:51:31.680]  попытаемся вызвать её,
[01:51:31.680 --> 01:51:33.680]  технически такие штуки
[01:51:33.680 --> 01:51:35.680]  через как-то ADL находятся,
[01:51:35.680 --> 01:51:37.680]  но у нас будет ошибка компиляции,
[01:51:37.680 --> 01:51:39.680]  потому что определения пока нет.
[01:51:39.680 --> 01:51:41.680]  Действительно, откуда ему взяться?
[01:51:43.680 --> 01:51:45.680]  Давайте сделаем шаблон
[01:51:45.680 --> 01:51:47.680]  другой структуры,
[01:51:47.680 --> 01:51:49.680]  абсолютно никак не связанной с тег n,
[01:51:49.680 --> 01:51:51.680]  принимающей
[01:51:51.680 --> 01:51:53.680]  опять же int n и
[01:51:53.680 --> 01:51:55.680]  class t,
[01:51:55.680 --> 01:51:57.680]  шаблонные аргументы.
[01:51:57.680 --> 01:51:59.680]  Эта структура внутри себя
[01:51:59.680 --> 01:52:01.680]  будет на этот раз
[01:52:01.680 --> 01:52:03.680]  определять функцию
[01:52:03.680 --> 01:52:05.680]  лобхол
[01:52:05.680 --> 01:52:07.680]  с ровно такой сигнатурой,
[01:52:07.680 --> 01:52:09.680]  какая была здесь.
[01:52:09.680 --> 01:52:11.680]  И возвращать из этой функции
[01:52:11.680 --> 01:52:13.680]  тэск конструированная.
[01:52:13.680 --> 01:52:15.680]  Внимание, вопрос.
[01:52:15.680 --> 01:52:17.680]  Что произойдет теперь,
[01:52:17.680 --> 01:52:19.680]  если мы пытаемся вызвать лобхол
[01:52:19.680 --> 01:52:21.680]  от тега от 0?
[01:52:23.680 --> 01:52:25.680]  Все равно проблема, да.
[01:52:25.680 --> 01:52:27.680]  А потому что мы ни разу не инстанцировали
[01:52:27.680 --> 01:52:29.680]  вот этот шаблон.
[01:52:29.680 --> 01:52:31.680]  Но вот это вот определение
[01:52:31.680 --> 01:52:33.680]  функции лобхол, оно же зависит
[01:52:33.680 --> 01:52:35.680]  от шаблонных параметров.
[01:52:35.680 --> 01:52:37.680]  Поэтому пока шаблон не инстанцировали,
[01:52:37.680 --> 01:52:39.680]  никаких определений
[01:52:39.680 --> 01:52:41.680]  и функций нет.
[01:52:45.680 --> 01:52:47.680]  Теперь что будет?
[01:52:47.680 --> 01:52:49.680]  Что будет происходить?
[01:52:51.680 --> 01:52:53.680]  Мы инстанцировали лобхол
[01:52:53.680 --> 01:52:55.680]  от 0 int.
[01:52:57.680 --> 01:52:59.680]  Но оно скомпилируется?
[01:52:59.680 --> 01:53:01.680]  Да оно просто возьмет, скомпилируется
[01:53:01.680 --> 01:53:03.680]  и более того, возвращаемый тип
[01:53:03.680 --> 01:53:05.680]  лобхола какой будет?
[01:53:05.680 --> 01:53:07.680]  Int.
[01:53:07.680 --> 01:53:09.680]  Понимаете, то есть
[01:53:09.680 --> 01:53:11.680]  вот так написали одну строчку.
[01:53:11.680 --> 01:53:13.680]  Error.
[01:53:13.680 --> 01:53:15.680]  А если перед этим дописали вторую строчку,
[01:53:15.680 --> 01:53:17.680]  то уже не Error.
[01:53:23.680 --> 01:53:25.680]  Ну да.
[01:53:25.680 --> 01:53:27.680]  Давайте в Requires это завернем хотя бы.
[01:53:27.680 --> 01:53:29.680]  Requires вот эта штука
[01:53:29.680 --> 01:53:31.680]  до того, как мы написали
[01:53:31.680 --> 01:53:33.680]  лобхол unused
[01:53:33.680 --> 01:53:35.680]  выдаст вам типа false.
[01:53:35.680 --> 01:53:37.680]  Requires после выдаст true.
[01:53:37.680 --> 01:53:39.680]  И более того, декл-тайп от него
[01:53:39.680 --> 01:53:41.680]  выдаст вам int.
[01:53:47.680 --> 01:53:49.680]  Двойное определение одной и той же
[01:53:49.680 --> 01:53:51.680]  функции.
[01:53:53.680 --> 01:53:55.680]  Давай ты с хитрыми догадками
[01:53:55.680 --> 01:53:57.680]  как это продвигать в будущее светлое
[01:53:57.680 --> 01:53:59.680]  попозже.
[01:54:01.680 --> 01:54:03.680]  Да!
[01:54:03.680 --> 01:54:05.680]  Вы понимаете, вот что глобально произошло?
[01:54:05.680 --> 01:54:07.680]  Мы сделали слот
[01:54:07.680 --> 01:54:09.680]  внутри компилятора.
[01:54:09.680 --> 01:54:11.680]  Этот слот изначально пустой.
[01:54:11.680 --> 01:54:13.680]  Мы можем написать
[01:54:13.680 --> 01:54:15.680]  строчку и в момент компиляции
[01:54:15.680 --> 01:54:17.680]  этой строчки
[01:54:17.680 --> 01:54:19.680]  компилятор запишет в этот
[01:54:19.680 --> 01:54:21.680]  слот int.
[01:54:23.680 --> 01:54:25.680]  А также
[01:54:27.680 --> 01:54:29.680]  мы можем
[01:54:29.680 --> 01:54:31.680]  читать этот слот.
[01:54:31.680 --> 01:54:33.680]  Как такой слот
[01:54:33.680 --> 01:54:35.680]  для инвентаря в Майнкрафте.
[01:54:35.680 --> 01:54:37.680]  Можем прочитать вот так и получить,
[01:54:37.680 --> 01:54:39.680]  что там лежит int.
[01:54:39.680 --> 01:54:41.680]  Но еще можем через Requires проверить
[01:54:41.680 --> 01:54:43.680]  и нам скажут, что там ничего не лежит.
[01:54:43.680 --> 01:54:45.680]  Если мы до вот этой
[01:54:45.680 --> 01:54:47.680]  строчки попытаемся это сделать.
[01:54:47.680 --> 01:54:49.680]  Внимание!
[01:54:49.680 --> 01:54:51.680]  Эти строчки могут быть разнесены на любое
[01:54:51.680 --> 01:54:53.680]  расстояние и написаны в любом
[01:54:53.680 --> 01:54:55.680]  месте в коде.
[01:54:55.680 --> 01:54:57.680]  Единственный вопрос это в каком порядке их
[01:54:57.680 --> 01:54:59.680]  скомпилирует компилятор.
[01:54:59.680 --> 01:55:01.680]  Почему
[01:55:01.680 --> 01:55:03.680]  мы можем читать этот слот?
[01:55:03.680 --> 01:55:05.680]  Потому что как только мы инстанцировали
[01:55:05.680 --> 01:55:07.680]  вот этот класс Loop.Hole
[01:55:07.680 --> 01:55:09.680]  у нас появилось определение
[01:55:09.680 --> 01:55:11.680]  функции Loop.Hole.
[01:55:11.680 --> 01:55:13.680]  И это определение
[01:55:13.680 --> 01:55:15.680]  говорит, что вот этот авто
[01:55:15.680 --> 01:55:17.680]  тип
[01:55:17.680 --> 01:55:19.680]  вообще Т должен был быть.
[01:55:19.680 --> 01:55:21.680]  Причем в зависимости от того
[01:55:21.680 --> 01:55:23.680]  с каким T мы вот здесь инстанцируем
[01:55:23.680 --> 01:55:25.680]  класс Loop.Hole
[01:55:25.680 --> 01:55:27.680]  будет разный результат.
[01:55:27.680 --> 01:55:29.680]  А если мы напишем Loop.Hole
[01:55:29.680 --> 01:55:31.680]  1.int?
[01:55:31.680 --> 01:55:33.680]  Это заполнит другой слот.
[01:55:33.680 --> 01:55:35.680]  Каждый int это свой отдельный слот.
[01:55:39.680 --> 01:55:41.680]  Вот этот int, который здесь
[01:55:41.680 --> 01:55:43.680]  и здесь, это номер слота.
[01:55:45.680 --> 01:55:47.680]  Может присвоить только один раз?
[01:55:47.680 --> 01:55:49.680]  Один раз присвоить и все.
[01:55:53.680 --> 01:55:55.680]  Вот это вот номер слота.
[01:55:55.680 --> 01:55:57.680]  Слот 0 и слот 1 это
[01:55:57.680 --> 01:55:59.680]  два разных слота.
[01:55:59.680 --> 01:56:01.680]  Ты можешь прочитать слот 0, а можешь прочитать
[01:56:01.680 --> 01:56:03.680]  слот 1. Они независимо существуют.
[01:56:03.680 --> 01:56:05.680]  Мы не просто один слот
[01:56:05.680 --> 01:56:07.680]  сделали, мы научились делать сколько угодно
[01:56:07.680 --> 01:56:09.680]  много слотов в компиляторе,
[01:56:09.680 --> 01:56:11.680]  в которые можно в любой момент времени
[01:56:11.680 --> 01:56:13.680]  записать тип, а можно в любой момент
[01:56:13.680 --> 01:56:15.680]  времени прочитать.
[01:56:17.680 --> 01:56:19.680]  Да, один раз в write-only
[01:56:19.680 --> 01:56:21.680]  в write-once
[01:56:21.680 --> 01:56:23.680]  такой read-only-memory
[01:56:23.680 --> 01:56:25.680]  которую один раз записали
[01:56:25.680 --> 01:56:27.680]  и дальше только читают.
[01:56:27.680 --> 01:56:29.680]  Да, это не проблема, потому что
[01:56:29.680 --> 01:56:31.680]  слотов-то у нас сколько?
[01:56:31.680 --> 01:56:33.680]  Это счетное число.
[01:56:33.680 --> 01:56:35.680]  Сколько int существует?
[01:56:35.680 --> 01:56:37.680]  Можно еще сюда параметров
[01:56:37.680 --> 01:56:39.680]  допихать, 2 int, например.
[01:56:39.680 --> 01:56:41.680]  А лучше наверное
[01:56:41.680 --> 01:56:43.680]  сделать все-таки type
[01:56:43.680 --> 01:56:45.680]  параметр и накладывать
[01:56:45.680 --> 01:56:47.680]  вообще сколько угодно.
[01:56:47.680 --> 01:56:49.680]  То есть
[01:56:49.680 --> 01:56:51.680]  сколько угодно bit
[01:56:51.680 --> 01:56:53.680]  информации, которые можно только один раз
[01:56:53.680 --> 01:56:55.680]  записать. Этого в принципе достаточно уже,
[01:56:55.680 --> 01:56:57.680]  чтобы что угодно примерно хранить.
[01:56:57.680 --> 01:56:59.680]  Как мы это будем использовать?
[01:56:59.680 --> 01:57:01.680]  Да, тут
[01:57:01.680 --> 01:57:03.680]  важное подчеркивание.
[01:57:03.680 --> 01:57:05.680]  А, ну собственно, как Андрей предложил,
[01:57:05.680 --> 01:57:07.680]  давайте ко всей этой конструкции
[01:57:07.680 --> 01:57:09.680]  добавим class.
[01:57:09.680 --> 01:57:11.680]  То есть такой же tag и loophole.
[01:57:11.680 --> 01:57:13.680]  Только loophole set
[01:57:13.680 --> 01:57:15.680]  тут уже переименовался.
[01:57:15.680 --> 01:57:17.680]  Добавим
[01:57:17.680 --> 01:57:19.680]  шаблонный аргумент class.
[01:57:19.680 --> 01:57:21.680]  Зачем?
[01:57:21.680 --> 01:57:23.680]  Что будет классом, что будет int?
[01:57:29.680 --> 01:57:31.680]  Номер поля.
[01:57:31.680 --> 01:57:33.680]  Да, type структуры, номер
[01:57:33.680 --> 01:57:35.680]  поля. Внутри
[01:57:35.680 --> 01:57:37.680]  loophole
[01:57:37.680 --> 01:57:39.680]  ubica.
[01:57:39.680 --> 01:57:41.680]  Мы сделаем loophole set,
[01:57:41.680 --> 01:57:43.680]  type структуры, номер
[01:57:43.680 --> 01:57:45.680]  поля
[01:57:45.680 --> 01:57:47.680]  и type поля.
[01:57:49.680 --> 01:57:51.680]  Ну да.
[01:57:51.680 --> 01:57:53.680]  А в
[01:57:53.680 --> 01:57:55.680]  отдельной структурке loophole
[01:57:55.680 --> 01:57:57.680]  get мы просто возьмем и посмотрим
[01:57:57.680 --> 01:57:59.680]  декл-тайп loophole
[01:57:59.680 --> 01:58:01.680]  и вот мы получили
[01:58:01.680 --> 01:58:03.680]  type поля.
[01:58:03.680 --> 01:58:05.680]  Где угодно.
[01:58:05.680 --> 01:58:07.680]  Вообще в любом месте.
[01:58:07.680 --> 01:58:09.680]  Главное
[01:58:09.680 --> 01:58:11.680]  инстанцировать один раз
[01:58:11.680 --> 01:58:13.680]  все эти loophole ubica.
[01:58:17.680 --> 01:58:19.680]  Requires?
[01:58:19.680 --> 01:58:21.680]  Ты спрашиваешь,
[01:58:21.680 --> 01:58:23.680]  можно ли вот это вот loophole tag
[01:58:23.680 --> 01:58:25.680]  в requires написать?
[01:58:29.680 --> 01:58:31.680]  Будет, наверное.
[01:58:31.680 --> 01:58:33.680]  Надо поэкспериментировать. Тут...
[01:58:37.680 --> 01:58:39.680]  Окей, смотрите. Вот так точно работает.
[01:58:39.680 --> 01:58:41.680]  Любые чуть-чуть отступания
[01:58:41.680 --> 01:58:43.680]  влево-вправо могут не работать,
[01:58:43.680 --> 01:58:45.680]  потому что это, блин...
[01:58:45.680 --> 01:58:47.680]  Что это по факту такое?
[01:58:47.680 --> 01:58:49.680]  Это недосмотр
[01:58:49.680 --> 01:58:51.680]  в бюрократической формулировке
[01:58:51.680 --> 01:58:53.680]  слов стандарта
[01:58:53.680 --> 01:58:55.680]  C++. Никто тупо не подумал,
[01:58:55.680 --> 01:58:57.680]  что такое вообще можно написать,
[01:58:57.680 --> 01:58:59.680]  используя инструменты,
[01:58:59.680 --> 01:59:01.680]  которые дает стандарт.
[01:59:01.680 --> 01:59:03.680]  То есть есть там undefined behavior в стандарте
[01:59:03.680 --> 01:59:05.680]  написано. Вот поведение неопределенное.
[01:59:05.680 --> 01:59:07.680]  Есть unspecified behavior
[01:59:07.680 --> 01:59:09.680]  написано. Типа каждый компилятор
[01:59:09.680 --> 01:59:11.680]  и платформы имеют право делать что угодно.
[01:59:11.680 --> 01:59:13.680]  А есть вот такие
[01:59:13.680 --> 01:59:15.680]  кейсы, когда в самом стандарте
[01:59:15.680 --> 01:59:17.680]  вообще ничего не написано про то,
[01:59:17.680 --> 01:59:19.680]  что должно происходить
[01:59:19.680 --> 01:59:21.680]  в этой ситуации.
[01:59:29.680 --> 01:59:31.680]  Короче...
[01:59:35.680 --> 01:59:37.680]  Но нам нужно следить, что у нас
[01:59:37.680 --> 01:59:39.680]  индекс для каждой нужной...
[01:59:39.680 --> 01:59:41.680]  Почему? Нет, ты просто...
[01:59:41.680 --> 01:59:43.680]  Ты знаешь количество полей?
[01:59:43.680 --> 01:59:45.680]  Ты знаешь, в каком порядке ты юбики пихаешь в конструктор?
[01:59:45.680 --> 01:59:47.680]  Да.
[01:59:47.680 --> 01:59:49.680]  Я обязан в том же порядке про инстанцию.
[01:59:49.680 --> 01:59:51.680]  Да это неважно, слоты независимые.
[01:59:51.680 --> 01:59:53.680]  Ну да, я про это и говорю,
[01:59:53.680 --> 01:59:55.680]  что нам нужно поэкспериментировать.
[01:59:55.680 --> 01:59:57.680]  У нас тег зависит от T и номера.
[01:59:57.680 --> 01:59:59.680]  Мы можем почитать вот эту запись,
[01:59:59.680 --> 02:00:01.680]  и в этом тут действует синхронизация.
[02:00:01.680 --> 02:00:03.680]  Окей. Давайте напишем
[02:00:03.680 --> 02:00:05.680]  обертку, которая сначала запускает
[02:00:05.680 --> 02:00:07.680]  конструктор T
[02:00:07.680 --> 02:00:09.680]  от этих юбиков,
[02:00:09.680 --> 02:00:11.680]  потом делает вот эти геты и возвращает
[02:00:11.680 --> 02:00:13.680]  вам type list.
[02:00:15.680 --> 02:00:17.680]  Всё.
[02:00:17.680 --> 02:00:19.680]  Просто вот это вот пользователи давайте наружу.
[02:00:19.680 --> 02:00:21.680]  Чего?
[02:00:29.680 --> 02:00:31.680]  Ну типа число, структура и номер поля.
[02:00:31.680 --> 02:00:33.680]  Я говорю, вот этот тег
[02:00:33.680 --> 02:00:35.680]  нужно смотреть на него как на слот.
[02:00:35.680 --> 02:00:37.680]  Слот в компиляторе, в который можно
[02:00:37.680 --> 02:00:39.680]  записать тип. Вот это вот авто
[02:00:39.680 --> 02:00:41.680]  на самом деле является нашим слотом.
[02:00:43.680 --> 02:00:45.680]  Ну и слоты параметризованы типом
[02:00:45.680 --> 02:00:47.680]  и номером. Для каждого
[02:00:47.680 --> 02:00:49.680]  типа и для каждого номера свой слот.
[02:00:49.680 --> 02:00:51.680]  Есть метафункция,
[02:00:51.680 --> 02:00:53.680]  метапроцедура даже,
[02:00:53.680 --> 02:00:55.680]  а не функция, которая делает
[02:00:55.680 --> 02:00:57.680]  set. Ей нужно
[02:00:57.680 --> 02:00:59.680]  дать на вход тип и номер,
[02:00:59.680 --> 02:01:01.680]  в какой слот и что
[02:01:01.680 --> 02:01:03.680]  установить. Вот и всё.
[02:01:15.680 --> 02:01:17.680]  Можно застрелиться, пытаясь понять,
[02:01:17.680 --> 02:01:19.680]  что на этот счёт думает стандарт.
[02:01:19.680 --> 02:01:21.680]  Я вам крайне рекомендую
[02:01:21.680 --> 02:01:23.680]  становиться как-то
[02:01:23.680 --> 02:01:25.680]  бюрократами.
[02:01:25.680 --> 02:01:27.680]  Слишком сложно.
[02:01:29.680 --> 02:01:31.680]  Работает во всех компиляторах,
[02:01:31.680 --> 02:01:33.680]  кроме MSWC.
[02:01:33.680 --> 02:01:35.680]  Насколько я понимаю,
[02:01:35.680 --> 02:01:37.680]  это вроде гарантированно
[02:01:37.680 --> 02:01:39.680]  должно работать. Если не работает,
[02:01:39.680 --> 02:01:41.680]  это баг компилятор.
[02:01:41.680 --> 02:01:43.680]  Очень сложно. В Clang и GCC точно
[02:01:43.680 --> 02:01:45.680]  работает. В MSWC, скорее всего,
[02:01:45.680 --> 02:01:47.680]  со свежих-свежих версий тоже
[02:01:47.680 --> 02:01:49.680]  работает, потому что они там активно
[02:01:49.680 --> 02:01:51.680]  фиксили какие-то баги,
[02:01:51.680 --> 02:01:53.680]  относящиеся к расхождению в имплементации
[02:01:53.680 --> 02:01:55.680]  шаблонов между GCC Clang
[02:01:55.680 --> 02:01:57.680]  и MSWC.
[02:01:57.680 --> 02:01:59.680]  Но нафиг вам MSWC использовать,
[02:01:59.680 --> 02:02:01.680]  когда Clang под Windows умеют компилировать.
[02:02:01.680 --> 02:02:03.680]  Ну, камон.
[02:02:03.680 --> 02:02:05.680]  Почему мы сюда пикаем
[02:02:05.680 --> 02:02:07.680]  T?
[02:02:07.680 --> 02:02:09.680]  Было бы странно,
[02:02:09.680 --> 02:02:11.680]  если для каждой структуры
[02:02:11.680 --> 02:02:13.680]  ты использовал одни и те же слоты.
[02:02:13.680 --> 02:02:15.680]  А для одной структуры
[02:02:15.680 --> 02:02:17.680]  использовал, всё, слоты записаны.
[02:02:17.680 --> 02:02:19.680]  Для следующей структуры
[02:02:19.680 --> 02:02:21.680]  ты просто не сможешь запись сделать,
[02:02:21.680 --> 02:02:23.680]  у тебя ошибка будет.
[02:02:23.680 --> 02:02:25.680]  Мы при конструировании объекта вызываем
[02:02:25.680 --> 02:02:27.680]  сет.
[02:02:27.680 --> 02:02:29.680]  Мы всё ещё конструируем объект
[02:02:29.680 --> 02:02:31.680]  от N штук лупхол
[02:02:31.680 --> 02:02:33.680]  юбиков.
[02:02:33.680 --> 02:02:35.680]  В этот момент
[02:02:35.680 --> 02:02:37.680]  каждый из лупхол юбиков прикастится
[02:02:37.680 --> 02:02:39.680]  к нужному типу аргумента.
[02:02:39.680 --> 02:02:41.680]  В третий аргумент
[02:02:41.680 --> 02:02:43.680]  так влетит поле,
[02:02:43.680 --> 02:02:45.680]  и это будет
[02:02:45.680 --> 02:02:47.680]  номер, мы запишем его,
[02:02:47.680 --> 02:02:49.680]  а в T у нас что будет?
[02:02:49.680 --> 02:02:51.680]  T это структура.
[02:02:51.680 --> 02:02:53.680]  Структура,
[02:02:53.680 --> 02:02:55.680]  у которой мы пытаемся понять типы полей.
[02:02:55.680 --> 02:02:57.680]  И это номер поля
[02:02:57.680 --> 02:02:59.680]  или номер юбика,
[02:02:59.680 --> 02:03:01.680]  который мы пихнули в Т-фигурные скобки.
[02:03:01.680 --> 02:03:03.680]  Type это то,
[02:03:03.680 --> 02:03:05.680]  к чему юбик смог прикаститься.
[02:03:05.680 --> 02:03:07.680]  Он смог прикаститься
[02:03:07.680 --> 02:03:09.680]  к такому типу, значит это тип аргумента.
[02:03:13.680 --> 02:03:15.680]  Мы устанавливаем в слот T и
[02:03:15.680 --> 02:03:17.680]  значение Type.
[02:03:19.680 --> 02:03:21.680]  А здесь мы читаем из слота
[02:03:21.680 --> 02:03:23.680]  T, N,
[02:03:23.680 --> 02:03:25.680]  какой там тип записан.
[02:03:27.680 --> 02:03:29.680]  Магия.
[02:03:29.680 --> 02:03:31.680]  Ну вот,
[02:03:31.680 --> 02:03:33.680]  вот полный импл, чтобы
[02:03:33.680 --> 02:03:35.680]  никого вообще не смущало ничего.
[02:03:35.680 --> 02:03:37.680]  Мы прямо руками пишем
[02:03:37.680 --> 02:03:39.680]  «бери делай»,
[02:03:39.680 --> 02:03:41.680]  по количеству
[02:03:41.680 --> 02:03:43.680]  нужному, и на выход
[02:03:43.680 --> 02:03:45.680]  возвращаем тюпл, например.
[02:03:45.680 --> 02:03:47.680]  Можно через TypeTupel или TypeList
[02:03:47.680 --> 02:03:49.680]  какой-нибудь, как хотите.
[02:03:51.680 --> 02:03:53.680]  Окей.
[02:03:53.680 --> 02:03:55.680]  Никого нет сомнений, что это работает.
[02:03:55.680 --> 02:03:57.680]  Ну и не должно быть, потому что я вас очень
[02:03:57.680 --> 02:03:59.680]  экспрессивно убеждаю в том, что это работает.
[02:03:59.680 --> 02:04:01.680]  Да.
[02:04:03.680 --> 02:04:05.680]  Вот мнение
[02:04:05.680 --> 02:04:07.680]  дедов по этому поводу,
[02:04:07.680 --> 02:04:09.680]  что это дефект,
[02:04:09.680 --> 02:04:11.680]  это надо и
[02:04:11.680 --> 02:04:13.680]  исправлять, где-то
[02:04:13.680 --> 02:04:15.680]  с 2015 года известно,
[02:04:15.680 --> 02:04:17.680]  и вот я сказал, что это колдунство,
[02:04:17.680 --> 02:04:19.680]  это официальная терминология.
[02:04:19.680 --> 02:04:21.680]  Не шутки.
[02:04:23.680 --> 02:04:25.680]  Ну, в общем, понятно.
[02:04:25.680 --> 02:04:27.680]  Люди не понимают, как это работает,
[02:04:27.680 --> 02:04:29.680]  поэтому хотят избавиться, чтобы им
[02:04:29.680 --> 02:04:31.680]  стыдно не было, когда они это видят в кодбазе.
[02:04:31.680 --> 02:04:33.680]  Ну да. Нет, это
[02:04:33.680 --> 02:04:35.680]  непонятно, должно ли это на всех
[02:04:35.680 --> 02:04:37.680]  компиляторах одинаково работать. Вдруг там какие-то
[02:04:37.680 --> 02:04:39.680]  тонкие отличия? Ещё, ну, когда вы с этим
[02:04:39.680 --> 02:04:41.680]  просто будете играться, если захотите,
[02:04:41.680 --> 02:04:43.680]  будет домашка на рефлексиве
[02:04:43.680 --> 02:04:45.680]  структур, но вот это всё
[02:04:45.680 --> 02:04:47.680]  писать в ней – это опциональное.
[02:04:47.680 --> 02:04:49.680]  Потому что сейчас будет ещё один способ, который
[02:04:49.680 --> 02:04:51.680]  простой и понятный, но
[02:04:51.680 --> 02:04:53.680]  неприятный.
[02:04:55.680 --> 02:04:57.680]  Ну да.
[02:04:59.680 --> 02:05:01.680]  Ну, Arcane Arts хотят запретить.
[02:05:03.680 --> 02:05:05.680]  Ну, если запретят,
[02:05:05.680 --> 02:05:07.680]  вот тогда пусть и приходят, а пока
[02:05:07.680 --> 02:05:09.680]  что танцуем.
[02:05:09.680 --> 02:05:11.680]  Всем рекомендую хоть раз попробовать с этим поиграться,
[02:05:11.680 --> 02:05:13.680]  это просто убойная штука.
[02:05:13.680 --> 02:05:15.680]  Ну,
[02:05:15.680 --> 02:05:17.680]  в принципе, плюс у этого огромный.
[02:05:17.680 --> 02:05:19.680]  Это просто работает.
[02:05:19.680 --> 02:05:21.680]  Со всеми типами, со всеми структурами.
[02:05:21.680 --> 02:05:23.680]  Никаких ограничений нет.
[02:05:23.680 --> 02:05:25.680]  Но это могут пофиксить, что как бы
[02:05:25.680 --> 02:05:27.680]  минус, но
[02:05:27.680 --> 02:05:29.680]  скорее всего не пофиксить. Всё нормально.
[02:05:29.680 --> 02:05:31.680]  Всё. Последнее
[02:05:31.680 --> 02:05:33.680]  решение, последний
[02:05:33.680 --> 02:05:35.680]  способ.
[02:05:35.680 --> 02:05:37.680]  Четвёртое, которое почти хорошее,
[02:05:37.680 --> 02:05:39.680]  но...
[02:05:39.680 --> 02:05:41.680]  Ну, сейчас увидите.
[02:05:41.680 --> 02:05:43.680]  Знаком ли вам такой синтаксис?
[02:05:45.680 --> 02:05:47.680]  Знаком, да?
[02:05:47.680 --> 02:05:49.680]  Да, это да.
[02:05:49.680 --> 02:05:51.680]  Декомпозируем структуру на её поля.
[02:05:57.680 --> 02:05:59.680]  Ну, мы знаем число полей.
[02:05:59.680 --> 02:06:01.680]  Число полей мы знаем.
[02:06:01.680 --> 02:06:03.680]  Нам только нужно написать structure binding,
[02:06:03.680 --> 02:06:05.680]  в котором вот здесь будет
[02:06:05.680 --> 02:06:07.680]  столько, через
[02:06:07.680 --> 02:06:09.680]  запятую букв написано, сколько у нас полей.
[02:06:09.680 --> 02:06:11.680]  Ну, и тогда
[02:06:11.680 --> 02:06:13.680]  если их число
[02:06:13.680 --> 02:06:15.680]  равно числу полей, то каждое
[02:06:15.680 --> 02:06:17.680]  вот это вот выражение
[02:06:17.680 --> 02:06:19.680]  будет как бы ссылаться
[02:06:19.680 --> 02:06:21.680]  на или быть алиасом
[02:06:21.680 --> 02:06:23.680]  для конкретного поля.
[02:06:23.680 --> 02:06:25.680]  Важное замечание,
[02:06:25.680 --> 02:06:27.680]  смешное. Не знаю, сталкивались ли вы с этим
[02:06:27.680 --> 02:06:29.680]  когда-нибудь. Вот эти вот
[02:06:29.680 --> 02:06:31.680]  выражения a, b, c,
[02:06:31.680 --> 02:06:33.680]  они не являются переменными.
[02:06:33.680 --> 02:06:35.680]  Здесь одна переменная, и у неё нет названия.
[02:06:35.680 --> 02:06:37.680]  То есть это
[02:06:37.680 --> 02:06:39.680]  просто некоторые, как ярлыки, которые
[02:06:39.680 --> 02:06:41.680]  как бы если вы их пишете, то это
[02:06:41.680 --> 02:06:43.680]  то же самое, что написать value точкой
[02:06:43.680 --> 02:06:45.680]  какой-то поля.
[02:06:45.680 --> 02:06:47.680]  Поэтому, в частности, если вы возвращаете
[02:06:47.680 --> 02:06:49.680]  из функции вот это a,
[02:06:49.680 --> 02:06:51.680]  у вас не сработает named return
[02:06:51.680 --> 02:06:53.680]  value optimization.
[02:06:53.680 --> 02:06:55.680]  Сталкиваюсь с таким?
[02:06:55.680 --> 02:06:57.680]  Нет?
[02:06:57.680 --> 02:06:59.680]  Ладно, пусть на записи останется, кто-нибудь
[02:06:59.680 --> 02:07:01.680]  когда-нибудь обдумает это.
[02:07:03.680 --> 02:07:05.680]  Просто вместо
[02:07:05.680 --> 02:07:07.680]  вместо выражения a в каждой
[02:07:07.680 --> 02:07:09.680]  точке использования как бы подставляется
[02:07:09.680 --> 02:07:11.680]  value точка поля.
[02:07:11.680 --> 02:07:13.680]  Это не ссылка.
[02:07:13.680 --> 02:07:15.680]  Ссылка здесь одна, она ссылается на value
[02:07:15.680 --> 02:07:17.680]  и у неё нет имени.
[02:07:17.680 --> 02:07:19.680]  Адрес a?
[02:07:19.680 --> 02:07:21.680]  Можно, ты получишь адрес
[02:07:21.680 --> 02:07:23.680]  того, что вот здесь лежит.
[02:07:25.680 --> 02:07:27.680]  То есть получишь адрес внутри value.
[02:07:27.680 --> 02:07:29.680]  И потому что здесь ссылка.
[02:07:29.680 --> 02:07:31.680]  Почему так сделано было?
[02:07:31.680 --> 02:07:33.680]  Какие-то были причины на то, чтобы
[02:07:33.680 --> 02:07:35.680]  это было не объявлением переменной,
[02:07:35.680 --> 02:07:37.680]  а какая-то странная сущность,
[02:07:37.680 --> 02:07:39.680]  которая выражение как бы алиас,
[02:07:39.680 --> 02:07:41.680]  но как бы не переменная.
[02:07:41.680 --> 02:07:43.680]  Имейте это в виду.
[02:07:43.680 --> 02:07:45.680]  Ещё в лямбды нельзя захватывать
[02:07:45.680 --> 02:07:47.680]  вот эти вот ABC.
[02:07:47.680 --> 02:07:49.680]  Если это делать
[02:07:49.680 --> 02:07:51.680]  стипа лайком,
[02:07:51.680 --> 02:07:53.680]  то их можно, конечно.
[02:07:53.680 --> 02:07:55.680]  План наш какой.
[02:07:55.680 --> 02:07:57.680]  Вот мы получили эти ABC, давайте
[02:07:57.680 --> 02:07:59.680]  их типы просто возьмём и вернём.
[02:07:59.680 --> 02:08:01.680]  Вопрос только.
[02:08:03.680 --> 02:08:05.680]  Телефон надо в кармане держать.
[02:08:05.680 --> 02:08:07.680]  На чеку.
[02:08:07.680 --> 02:08:09.680]  Всё.
[02:08:09.680 --> 02:08:11.680]  Декл-тайп взяли,
[02:08:11.680 --> 02:08:13.680]  вернули, всё круто.
[02:08:13.680 --> 02:08:15.680]  Вопрос, как подобрать количество
[02:08:15.680 --> 02:08:17.680]  вот этих вот буковок?
[02:08:17.680 --> 02:08:19.680]  Никак.
[02:08:19.680 --> 02:08:21.680]  Вообще никак.
[02:08:21.680 --> 02:08:23.680]  Просто вот берёте, пишите так.
[02:08:23.680 --> 02:08:25.680]  Руками.
[02:08:25.680 --> 02:08:27.680]  Чё?
[02:08:27.680 --> 02:08:29.680]  Как?
[02:08:29.680 --> 02:08:31.680]  Букво.
[02:08:31.680 --> 02:08:33.680]  А0.
[02:08:33.680 --> 02:08:35.680]  А1. А2.
[02:08:35.680 --> 02:08:37.680]  Ну всё.
[02:08:37.680 --> 02:08:39.680]  Мы возвращаемся к тому
[02:08:39.680 --> 02:08:41.680]  решение фиксить лейнумом,
[02:08:41.680 --> 02:08:43.680]  где мы пишем макросы
[02:08:43.680 --> 02:08:45.680]  на столько...
[02:08:45.680 --> 02:08:47.680]  Да, да. Вы можете сделать по-разному.
[02:08:47.680 --> 02:08:49.680]  Можете раскопипастить сами,
[02:08:49.680 --> 02:08:51.680]  можете скрипт на питоне написать,
[02:08:51.680 --> 02:08:53.680]  который вам там 50 раз это повторит
[02:08:53.680 --> 02:08:55.680]  и в принципе сойдёт.
[02:08:55.680 --> 02:08:57.680]  Где бы вы видели структуру,
[02:08:57.680 --> 02:08:59.680]  в которой больше там 50 полей?
[02:08:59.680 --> 02:09:01.680]  Я видел структуру.
[02:09:03.680 --> 02:09:05.680]  Ну, запустишь скрипт на питоне
[02:09:05.680 --> 02:09:07.680]  наподобие.
[02:09:07.680 --> 02:09:09.680]  Ну, мы конфиги в текстовых файлах
[02:09:09.680 --> 02:09:11.680]  храним они в структурах,
[02:09:11.680 --> 02:09:13.680]  поэтому...
[02:09:13.680 --> 02:09:15.680]  Короче, вот, прекрасно.
[02:09:15.680 --> 02:09:17.680]  Можно сделать макрос, с помощью которого это генерить,
[02:09:17.680 --> 02:09:19.680]  но это отдельное искусство,
[02:09:19.680 --> 02:09:21.680]  вы можете только сами с этим разобраться,
[02:09:21.680 --> 02:09:23.680]  попробовать, сейчас я это рассказывать не буду.
[02:09:23.680 --> 02:09:25.680]  Да, про тай...
[02:09:25.680 --> 02:09:27.680]  Знаете, что это такое?
[02:09:27.680 --> 02:09:29.680]  Да.
[02:09:29.680 --> 02:09:31.680]  Короче, в тюпл оно связывает.
[02:09:31.680 --> 02:09:33.680]  Тут возвращается авто,
[02:09:33.680 --> 02:09:35.680]  но это авто превратится в тюпл
[02:09:35.680 --> 02:09:37.680]  из ссылок на вот эти вот штуки.
[02:09:37.680 --> 02:09:39.680]  Правда ведь? Ссылок.
[02:09:39.680 --> 02:09:41.680]  Да.
[02:09:45.680 --> 02:09:47.680]  Да, потому что и в constexpr
[02:09:47.680 --> 02:09:49.680]  вырезает ветку false,
[02:09:49.680 --> 02:09:51.680]  когда вот здесь написано true.
[02:09:51.680 --> 02:09:53.680]  Нет, тут все нормально будет,
[02:09:53.680 --> 02:09:55.680]  это гарантировано.
[02:09:55.680 --> 02:09:57.680]  Ну,
[02:09:57.680 --> 02:09:59.680]  неважно.
[02:09:59.680 --> 02:10:01.680]  Можно еще
[02:10:01.680 --> 02:10:03.680]  через перегрузки,
[02:10:03.680 --> 02:10:05.680]  чтобы не делать fov.
[02:10:05.680 --> 02:10:07.680]  Ну, то есть там просто
[02:10:07.680 --> 02:10:09.680]  перегрузки, где внутри
[02:10:09.680 --> 02:10:11.680]  тега...
[02:10:11.680 --> 02:10:13.680]  Теги мы уже видели, правда?
[02:10:13.680 --> 02:10:15.680]  Диспатчинг по тегам.
[02:10:15.680 --> 02:10:17.680]  Ретерн что?
[02:10:17.680 --> 02:10:19.680]  Нет, мы хотим тюпл
[02:10:19.680 --> 02:10:21.680]  из всех полей.
[02:10:21.680 --> 02:10:23.680]  Мы будем знать тогда их типы,
[02:10:23.680 --> 02:10:25.680]  и более того, это будет тюпл
[02:10:25.680 --> 02:10:27.680]  ссылок на поля.
[02:10:27.680 --> 02:10:29.680]  А тогда мы будем знать еще и как бы
[02:10:29.680 --> 02:10:31.680]  ссылки на них.
[02:10:31.680 --> 02:10:33.680]  Ну, и мы в принципе полностью победили.
[02:10:33.680 --> 02:10:35.680]  Вот.
[02:10:35.680 --> 02:10:37.680]  Ну, и делаем, делаем так
[02:10:37.680 --> 02:10:39.680]  62 раза.
[02:10:39.680 --> 02:10:41.680]  Потому что, как известно
[02:10:41.680 --> 02:10:43.680]  из опыта,
[02:10:43.680 --> 02:10:45.680]  в тюпле есть
[02:10:45.680 --> 02:10:47.680]  больше 64
[02:10:47.680 --> 02:10:49.680]  тюплы не бывают.
[02:10:49.680 --> 02:10:51.680]  Как известно из опыта GCC,
[02:10:51.680 --> 02:10:53.680]  варианта больше 11
[02:10:53.680 --> 02:10:55.680]  альтернатив не бывают.
[02:10:55.680 --> 02:10:57.680]  В скале не бывает тюплов больше 32
[02:10:57.680 --> 02:10:59.680]  элементов. Ну, и там еще по списку...
[02:10:59.680 --> 02:11:01.680]  Короче, все так делают.
[02:11:01.680 --> 02:11:03.680]  И...
[02:11:03.680 --> 02:11:05.680]  Ваш любимый язык, каким бы он вам
[02:11:05.680 --> 02:11:07.680]  хорошим не казался, он тоже где-то глубоко
[02:11:07.680 --> 02:11:09.680]  внутри имеет вот такой захардкоженный лимит
[02:11:09.680 --> 02:11:11.680]  на размер тюпла, варианта или еще чего-то.
[02:11:11.680 --> 02:11:13.680]  Ну, 100%.
[02:11:13.680 --> 02:11:15.680]  А у C-sharp долгое время максимальный размер
[02:11:15.680 --> 02:11:17.680]  тюпла был
[02:11:17.680 --> 02:11:19.680]  7.
[02:11:19.680 --> 02:11:21.680]  Просто 7.
[02:11:23.680 --> 02:11:25.680]  Ну, бывает нужно. В этом случае
[02:11:25.680 --> 02:11:27.680]  они предлагают
[02:11:27.680 --> 02:11:29.680]  восьмым аргументом
[02:11:29.680 --> 02:11:31.680]  в тюпл засунуть другой тюпл.
[02:11:31.680 --> 02:11:33.680]  У него можно точка rest написать
[02:11:33.680 --> 02:11:35.680]  и там опять дальше точка first,
[02:11:35.680 --> 02:11:37.680]  точка second, точка и так далее.
[02:11:37.680 --> 02:11:39.680]  Вот так.
[02:11:39.680 --> 02:11:41.680]  Прекрасно.
[02:11:43.680 --> 02:11:45.680]  ...
[02:11:45.680 --> 02:11:47.680]  А почему
[02:11:47.680 --> 02:11:49.680]  мы обязаны все
[02:11:49.680 --> 02:11:51.680]  пассить? Мы не можем
[02:11:51.680 --> 02:11:53.680]  как-нибудь шаблонный параметр?
[02:11:53.680 --> 02:11:55.680]  Я говорю, невозможно
[02:11:55.680 --> 02:11:57.680]  вот эту вот штуку заставить,
[02:11:57.680 --> 02:11:59.680]  в зависимости от чего-то шаблонного,
[02:11:59.680 --> 02:12:01.680]  генерировать код,
[02:12:01.680 --> 02:12:03.680]  где разное количество этих
[02:12:03.680 --> 02:12:05.680]  ашек-бэшек написано.
[02:12:05.680 --> 02:12:07.680]  Есть пропозл, который говорит, давайте
[02:12:07.680 --> 02:12:09.680]  сделаем, чтобы можно было сказать,
[02:12:09.680 --> 02:12:11.680]  я хочу здесь написать
[02:12:11.680 --> 02:12:13.680]  только а, а дальше три точки, и чтобы а
[02:12:13.680 --> 02:12:15.680]  это был пак.
[02:12:15.680 --> 02:12:17.680]  Пак нужного размера, и чтобы я его мог
[02:12:17.680 --> 02:12:19.680]  дальше использовать где-то. Пропозл есть.
[02:12:19.680 --> 02:12:21.680]  Вмерджит его хорошо,
[02:12:21.680 --> 02:12:23.680]  если через 10 лет, потому что там слишком много
[02:12:23.680 --> 02:12:25.680]  проблем возникает, в том числе
[02:12:25.680 --> 02:12:27.680]  в компиляторах. Потому что компиляторы
[02:12:27.680 --> 02:12:29.680]  вот вообще не готовы к тому, чтобы
[02:12:29.680 --> 02:12:31.680]  были паки
[02:12:31.680 --> 02:12:33.680]  вне шаблонного контекста. А там вот именно такая
[02:12:33.680 --> 02:12:35.680]  идея. Короче, сейчас никак
[02:12:35.680 --> 02:12:37.680]  нельзя. Только раскопипастить
[02:12:37.680 --> 02:12:39.680]  за хардкоженное количество раз
[02:12:39.680 --> 02:12:41.680]  или макросами
[02:12:41.680 --> 02:12:43.680]  нагенерить.
[02:12:47.680 --> 02:12:49.680]  Вот. Это
[02:12:49.680 --> 02:12:51.680]  работает, в принципе, для всего.
[02:12:51.680 --> 02:12:53.680]  На удивление.
[02:12:53.680 --> 02:12:55.680]  Вообще для всего.
[02:12:55.680 --> 02:12:57.680]  Даже не совсем под типы, вы всякие строки
[02:12:57.680 --> 02:12:59.680]  векторам можете пихать, и всякие
[02:12:59.680 --> 02:13:01.680]  UID-шники. Вот есть библиотека
[02:13:01.680 --> 02:13:03.680]  Boost по ФР.
[02:13:03.680 --> 02:13:05.680]  Вот там это реализовано.
[02:13:05.680 --> 02:13:07.680]  И там вот прям зарадоскопипастчина этот код
[02:13:07.680 --> 02:13:09.680]  прекрасный. И все довольны,
[02:13:09.680 --> 02:13:11.680]  и многие этим пользуются.
[02:13:11.680 --> 02:13:13.680]  Вот.
[02:13:13.680 --> 02:13:15.680]  То есть единственная
[02:13:15.680 --> 02:13:17.680]  проблема, это что
[02:13:17.680 --> 02:13:19.680]  вот у нас такой девиз, что вот этого
[02:13:19.680 --> 02:13:21.680]  хватит для любых задач. А потом кто-нибудь придет
[02:13:21.680 --> 02:13:23.680]  на Капгенят и уже не хватит.
[02:13:23.680 --> 02:13:25.680]  И вот будет беда.
[02:13:25.680 --> 02:13:27.680]  Ну, если в стандарте чуть-чуть подкрутит,
[02:13:27.680 --> 02:13:29.680]  поменяю, то уже будет совсем круто,
[02:13:29.680 --> 02:13:31.680]  и можно будет там вот эти лупхоллы
[02:13:31.680 --> 02:13:33.680]  забить-забыть
[02:13:33.680 --> 02:13:35.680]  и жить радостно. Но пока страдаем.
[02:13:35.680 --> 02:13:37.680]  Да, ссылки
[02:13:37.680 --> 02:13:39.680]  бесплатно получаем. Заметили?
[02:13:39.680 --> 02:13:41.680]  Помните, у нас там еще была задача?
[02:13:41.680 --> 02:13:43.680]  Получить ссылку на поле по номеру.
[02:13:43.680 --> 02:13:45.680]  Тай
[02:13:45.680 --> 02:13:47.680]  создает
[02:13:47.680 --> 02:13:49.680]  из
[02:13:49.680 --> 02:13:51.680]  через запятую перечисленных
[02:13:51.680 --> 02:13:53.680]  аргументов
[02:13:53.680 --> 02:13:55.680]  тюпл ссылок.
[02:13:55.680 --> 02:13:57.680]  То есть сейчас
[02:13:57.680 --> 02:13:59.680]  вот на этой строчке a
[02:13:59.680 --> 02:14:01.680]  а и b не ссылки.
[02:14:01.680 --> 02:14:03.680]  А тут вернутся ссылки.
[02:14:03.680 --> 02:14:05.680]  А и b
[02:14:05.680 --> 02:14:07.680]  это будут, вот здесь это будет
[02:14:07.680 --> 02:14:09.680]  выражение
[02:14:09.680 --> 02:14:11.680]  вот у
[02:14:11.680 --> 02:14:13.680]  как бы, давай представим,
[02:14:13.680 --> 02:14:15.680]  что у этой переменной, которая здесь
[02:14:15.680 --> 02:14:17.680]  одна, есть имя х.
[02:14:17.680 --> 02:14:19.680]  И вот здесь будет написано
[02:14:19.680 --> 02:14:21.680]  х точка названия
[02:14:21.680 --> 02:14:23.680]  первого поля.
[02:14:23.680 --> 02:14:25.680]  Там а. Тоже нет.
[02:14:25.680 --> 02:14:27.680]  А конфликт.
[02:14:27.680 --> 02:14:29.680]  У. Первое поле у него будет у.
[02:14:29.680 --> 02:14:31.680]  То есть здесь будет написано х точка у.
[02:14:31.680 --> 02:14:33.680]  Х это ссылка.
[02:14:33.680 --> 02:14:35.680]  Значит х точка у это тоже
[02:14:35.680 --> 02:14:37.680]  как бы l-value ссылка.
[02:14:37.680 --> 02:14:39.680]  Да?
[02:14:39.680 --> 02:14:41.680]  Нет.
[02:14:41.680 --> 02:14:43.680]  Это будет указатель
[02:14:43.680 --> 02:14:45.680]  на конкретный флот или там конкретный
[02:14:45.680 --> 02:14:47.680]  int.
[02:14:47.680 --> 02:14:49.680]  Это будет
[02:14:49.680 --> 02:14:51.680]  что?
[02:14:51.680 --> 02:14:53.680]  Ну
[02:14:53.680 --> 02:14:55.680]  блин, по-другому.
[02:14:55.680 --> 02:14:57.680]  Ну точно такими же техниками.
[02:14:57.680 --> 02:14:59.680]  Все одновременно не получится. Нужно
[02:14:59.680 --> 02:15:01.680]  чуть-чуть кода пописать.
[02:15:01.680 --> 02:15:03.680]  Ну тут
[02:15:03.680 --> 02:15:05.680]  как узнать?
[02:15:05.680 --> 02:15:07.680]  Не знаю, слушай. Вот именно в этой технике
[02:15:07.680 --> 02:15:09.680]  я что-то не припомню.
[02:15:09.680 --> 02:15:11.680]  Придумайте.
[02:15:11.680 --> 02:15:13.680]  В домашнике это впрочем и не требуется,
[02:15:13.680 --> 02:15:15.680]  но если хочется, то сами
[02:15:15.680 --> 02:15:17.680]  я думаю, что-нибудь придумайте.
[02:15:17.680 --> 02:15:19.680]  В конце концов, мое любимое решение с лупхолом,
[02:15:19.680 --> 02:15:21.680]  а там все и так понятно
[02:15:21.680 --> 02:15:23.680]  или непонятно.
[02:15:23.680 --> 02:15:25.680]  Там может быть суть типа
[02:15:25.680 --> 02:15:27.680]  хранить вот этот указатель
[02:15:27.680 --> 02:15:29.680]  на мембр, нет?
[02:15:29.680 --> 02:15:31.680]  Или нет?
[02:15:31.680 --> 02:15:33.680]  Сейчас.
[02:15:33.680 --> 02:15:35.680]  Слушай, ну вообще с указателем на мембр
[02:15:35.680 --> 02:15:37.680]  что-то не работает, кажется.
[02:15:37.680 --> 02:15:39.680]  Вообще никак.
[02:15:41.680 --> 02:15:43.680]  По ходу нельзя, кстати.
[02:15:43.680 --> 02:15:45.680]  Ничего мы можем сохранить с лупхолем?
[02:15:45.680 --> 02:15:47.680]  Нет, а
[02:15:47.680 --> 02:15:49.680]  в смысле, ты в лупхоле, у тебя
[02:15:49.680 --> 02:15:51.680]  сохранить ты его
[02:15:51.680 --> 02:15:53.680]  можешь. Откуда ты его вот здесь
[02:15:53.680 --> 02:15:55.680]  достанешь?
[02:15:55.680 --> 02:15:57.680]  Тебя же присвоят к какому-то мембру
[02:15:57.680 --> 02:15:59.680]  только после того, как ты из этой функции вернешься.
[02:15:59.680 --> 02:16:01.680]  Поэтому
[02:16:01.680 --> 02:16:03.680]  слушай, наверное, все-таки нельзя.
[02:16:03.680 --> 02:16:05.680]  Я вам так с горяча соврал, что можно,
[02:16:05.680 --> 02:16:07.680]  все можно.
[02:16:07.680 --> 02:16:09.680]  А на самом деле не зря, наверное,
[02:16:09.680 --> 02:16:11.680]  ни в домашней, ни в презенташней не упомянуты
[02:16:11.680 --> 02:16:13.680]  указатели на мембр.
[02:16:13.680 --> 02:16:15.680]  А что? Что не так?
[02:16:15.680 --> 02:16:17.680]  Достать в compile-time
[02:16:17.680 --> 02:16:19.680]  список указателей
[02:16:19.680 --> 02:16:21.680]  на мембр.
[02:16:21.680 --> 02:16:23.680]  Там же требуется fully qualified name.
[02:16:23.680 --> 02:16:25.680]  Вот кажется, что да.
[02:16:25.680 --> 02:16:27.680]  Там по дефолту
[02:16:27.680 --> 02:16:29.680]  единственный способ достать
[02:16:29.680 --> 02:16:31.680]  это написать их имя.
[02:16:31.680 --> 02:16:33.680]  Без рефлексии, короче, нельзя,
[02:16:33.680 --> 02:16:35.680]  которая нормальная, языковая.
[02:16:35.680 --> 02:16:37.680]  Все, окей. Давайте самое
[02:16:37.680 --> 02:16:39.680]  последнее. Как ссылку
[02:16:39.680 --> 02:16:41.680]  на поле по индексу достать, если вы выбрали
[02:16:41.680 --> 02:16:43.680]  все-таки другой какой-то путь?
[02:16:43.680 --> 02:16:45.680]  Ну, вот тут хороших
[02:16:45.680 --> 02:16:47.680]  ответов нет. Вот если вы вот так
[02:16:47.680 --> 02:16:49.680]  вот пишете через
[02:16:49.680 --> 02:16:51.680]  вот эту тост, все окей.
[02:16:51.680 --> 02:16:53.680]  И он делает tuple-ссылок.
[02:16:53.680 --> 02:16:55.680]  Еще классно.
[02:16:55.680 --> 02:16:57.680]  В иной ситуации придется
[02:16:57.680 --> 02:16:59.680]  костылять и молиться
[02:16:59.680 --> 02:17:01.680]  на undefined-behavior.
[02:17:03.680 --> 02:17:05.680]  Мы будем костылять
[02:17:05.680 --> 02:17:07.680]  через косты,
[02:17:07.680 --> 02:17:09.680]  reinterpret-косты, к тюплам.
[02:17:09.680 --> 02:17:11.680]  Берем наш instant-структуру
[02:17:11.680 --> 02:17:13.680]  reinterpret-casting к
[02:17:13.680 --> 02:17:15.680]  тюплу.
[02:17:15.680 --> 02:17:17.680]  И
[02:17:17.680 --> 02:17:19.680]  мы можем сделать get-e.
[02:17:19.680 --> 02:17:21.680]  Прекрасно.
[02:17:21.680 --> 02:17:23.680]  Ну, вот мы там
[02:17:23.680 --> 02:17:25.680]  вот у нас get.
[02:17:25.680 --> 02:17:27.680]  Получили количество полей.
[02:17:27.680 --> 02:17:29.680]  И получили tuple, в котором
[02:17:29.680 --> 02:17:31.680]  написаны подряд типы полей.
[02:17:33.680 --> 02:17:35.680]  Ну, а теперь reinterpret-casting
[02:17:35.680 --> 02:17:37.680]  к этому тюплу наша
[02:17:37.680 --> 02:17:39.680]  экземпляр t и get-e.
[02:17:39.680 --> 02:17:41.680]  И как бы технически
[02:17:41.680 --> 02:17:43.680]  это работает.
[02:17:43.680 --> 02:17:45.680]  Но еще более технически. Это лубе.
[02:17:45.680 --> 02:17:47.680]  И как бы компилятор может очень
[02:17:47.680 --> 02:17:49.680]  ну, беситься на нас.
[02:17:49.680 --> 02:17:51.680]  Можно где-нибудь понавесить
[02:17:51.680 --> 02:17:53.680]  volatile и, скорее всего, он перестанет беситься.
[02:17:53.680 --> 02:17:55.680]  И все будет работать по факту.
[02:17:55.680 --> 02:17:57.680]  Ну, все
[02:17:57.680 --> 02:17:59.680]  как-то странно. У вас нету объекта типа
[02:17:59.680 --> 02:18:01.680]  tuple. Какого черта вы конструируете объект
[02:18:01.680 --> 02:18:03.680]  типа tuple там, где его нету?
[02:18:03.680 --> 02:18:05.680]  Ну, или пытаетесь получить доступ к объекту
[02:18:05.680 --> 02:18:07.680]  типа tuple, когда
[02:18:07.680 --> 02:18:09.680]  его там нету? Да, tuple здесь
[02:18:09.680 --> 02:18:11.680]  STD tuple обычно имеется в виду. Не там
[02:18:11.680 --> 02:18:13.680]  метапрошный.
[02:18:13.680 --> 02:18:15.680]  Ну,
[02:18:15.680 --> 02:18:17.680]  не надо так делать.
[02:18:17.680 --> 02:18:19.680]  Да, еще
[02:18:19.680 --> 02:18:21.680]  действительно
[02:18:21.680 --> 02:18:23.680]  с лейаутами может быть
[02:18:23.680 --> 02:18:25.680]  проблема, потому что никто не гарантирует, что
[02:18:25.680 --> 02:18:27.680]  лейяут у структур он такой же, как
[02:18:27.680 --> 02:18:29.680]  у tuple. Стандарт, по-моему,
[02:18:29.680 --> 02:18:31.680]  лейяут у tuple вообще никак нет.
[02:18:31.680 --> 02:18:33.680]  Не констраинят. Поэтому
[02:18:33.680 --> 02:18:35.680]  надо сделать свой
[02:18:35.680 --> 02:18:37.680]  как бы tuple или
[02:18:37.680 --> 02:18:39.680]  еще. Ну, да. В принципе, свой
[02:18:39.680 --> 02:18:41.680]  tuple во всяком случае надо сделать. Свой
[02:18:41.680 --> 02:18:43.680]  tuple, у которого гарантированный лейяут будет
[02:18:43.680 --> 02:18:45.680]  такой же, как у структур. То есть, стандарт,
[02:18:45.680 --> 02:18:47.680]  лейяут, type.
[02:18:47.680 --> 02:18:49.680]  А дальше
[02:18:49.680 --> 02:18:51.680]  можно попытаться следующие хаки
[02:18:51.680 --> 02:18:53.680]  сделать. Как бы
[02:18:53.680 --> 02:18:55.680]  взяли мы наш этот tuple прекрасный
[02:18:57.680 --> 02:18:59.680]  и взяли
[02:19:01.680 --> 02:19:03.680]  сейчас, что это у нас такое?
[02:19:03.680 --> 02:19:05.680]  Да, это тип вот этого
[02:19:05.680 --> 02:19:07.680]  поля,
[02:19:07.680 --> 02:19:09.680]  которое нас интересует.
[02:19:09.680 --> 02:19:11.680]  И дальше мы
[02:19:11.680 --> 02:19:13.680]  reinterpret cast к указателям
[02:19:13.680 --> 02:19:15.680]  на байтике, указатель на начало
[02:19:15.680 --> 02:19:17.680]  tupla
[02:19:17.680 --> 02:19:19.680]  и указатель
[02:19:19.680 --> 02:19:21.680]  на...
[02:19:21.680 --> 02:19:23.680]  Ну, это конечно же
[02:19:23.680 --> 02:19:25.680]  не совсем тут правда.
[02:19:25.680 --> 02:19:27.680]  Вот этот tpl, это должен быть
[02:19:27.680 --> 02:19:29.680]  скорее
[02:19:29.680 --> 02:19:31.680]  decal val какой-то. То есть, пока
[02:19:31.680 --> 02:19:33.680]  или свой tuple новый создать.
[02:19:33.680 --> 02:19:35.680]  То есть,
[02:19:35.680 --> 02:19:37.680]  почему я об этом говорю? Вот здесь
[02:19:37.680 --> 02:19:39.680]  технически мы возьмем ссылку
[02:19:39.680 --> 02:19:41.680]  на невалидный объект
[02:19:41.680 --> 02:19:43.680]  и это уже будет tube. Но если tpl
[02:19:43.680 --> 02:19:45.680]  это просто какой-то экземпляр, вообще любой
[02:19:45.680 --> 02:19:47.680]  экземпляр, вот этого типа
[02:19:47.680 --> 02:19:49.680]  tuple, то все окей.
[02:19:49.680 --> 02:19:51.680]  И вот у нас указатель на начало
[02:19:51.680 --> 02:19:53.680]  tupla и на то место, где
[02:19:53.680 --> 02:19:55.680]  начинается нас
[02:19:55.680 --> 02:19:57.680]  интересующее поле.
[02:19:57.680 --> 02:19:59.680]  Давайте их вычтем,
[02:19:59.680 --> 02:20:01.680]  получим offset относительно начала
[02:20:01.680 --> 02:20:03.680]  структуры нашего поля.
[02:20:03.680 --> 02:20:05.680]  И тогда
[02:20:05.680 --> 02:20:07.680]  мы возьмем указатель
[02:20:07.680 --> 02:20:09.680]  уже на структуру
[02:20:09.680 --> 02:20:11.680]  нашу,
[02:20:11.680 --> 02:20:13.680]  прикастим к байтам,
[02:20:13.680 --> 02:20:15.680]  подвинем на offset и это как бы будет указатель
[02:20:15.680 --> 02:20:17.680]  в то место, где на самом деле в памяти
[02:20:17.680 --> 02:20:19.680]  лежит вот этот самый объект.
[02:20:19.680 --> 02:20:21.680]  И тогда мы сможем
[02:20:21.680 --> 02:20:23.680]  сделать reinterpret cast
[02:20:23.680 --> 02:20:25.680]  и вроде как ub избежали, но вроде как
[02:20:25.680 --> 02:20:27.680]  и нет. Не
[02:20:27.680 --> 02:20:29.680]  факт, что это ub.
[02:20:29.680 --> 02:20:31.680]  Кажется, тут
[02:20:31.680 --> 02:20:33.680]  еще вауны просто довести. Возможно,
[02:20:33.680 --> 02:20:35.680]  да, это одно из тех мест,
[02:20:35.680 --> 02:20:37.680]  где нужно навесить лаундер и вроде как
[02:20:37.680 --> 02:20:39.680]  все хорошо. По факту,
[02:20:39.680 --> 02:20:41.680]  даже если вы так оставите,
[02:20:41.680 --> 02:20:43.680]  все будет нормально. Но для
[02:20:43.680 --> 02:20:45.680]  пущей уверенности можно навесить
[02:20:45.680 --> 02:20:47.680]  сюда лаундер, потому что компилятор может
[02:20:47.680 --> 02:20:49.680]  быть не уверен, что там
[02:20:49.680 --> 02:20:51.680]  действительно объект, который вас интересует,
[02:20:51.680 --> 02:20:53.680]  лежит под этим указателем на байтике
[02:20:53.680 --> 02:20:55.680]  и что-то не так сомптимизировать.
[02:20:55.680 --> 02:20:57.680]  Но в целом вот такой способ
[02:20:57.680 --> 02:20:59.680]  есть.
[02:20:59.680 --> 02:21:01.680]  Если вы хотите познать плюсы во всем
[02:21:01.680 --> 02:21:03.680]  их величии, вычитайте, пожалуйста,
[02:21:03.680 --> 02:21:05.680]  из стандарта является ли это вот ub.
[02:21:05.680 --> 02:21:07.680]  На любой лекции у нас
[02:21:07.680 --> 02:21:09.680]  есть домашнее задание.
[02:21:09.680 --> 02:21:11.680]  Перепроверить по стандарту слова лектора.
[02:21:11.680 --> 02:21:13.680]  Потому что нельзя доверять
[02:21:13.680 --> 02:21:15.680]  мне. Все.
[02:21:15.680 --> 02:21:17.680]  На этом
[02:21:17.680 --> 02:21:19.680]  все по
[02:21:19.680 --> 02:21:21.680]  рассказам.
[02:21:21.680 --> 02:21:23.680]  Сколько у нас времени?
[02:21:23.680 --> 02:21:25.680]  У нас осталось 10 минут.
[02:21:25.680 --> 02:21:27.680]  Мы можем...
[02:21:27.680 --> 02:21:29.680]  Нет, мы не успеем
[02:21:29.680 --> 02:21:31.680]  написать с нуля.
[02:21:31.680 --> 02:21:33.680]  Может, успеем.
[02:21:33.680 --> 02:21:35.680]  Давайте в скоростном режиме
[02:21:35.680 --> 02:21:37.680]  напишем счетчик в констэкспре.
[02:21:37.680 --> 02:21:39.680]  Сейчас очень
[02:21:39.680 --> 02:21:41.680]  быстро нужно будет.
[02:21:41.680 --> 02:21:43.680]  Я могу продиктовать.
[02:21:43.680 --> 02:21:45.680]  Не надо диктовать.
[02:21:45.680 --> 02:21:47.680]  Мне мой код из репозитория.
[02:21:47.680 --> 02:21:49.680]  Аркадий.
[02:21:49.680 --> 02:21:51.680]  В смысле? Там у тебя код из репозитория есть?
[02:21:51.680 --> 02:21:53.680]  Репозитория это есть.
[02:21:53.680 --> 02:21:55.680]  Вот это все нафиг выкидываем.
[02:21:55.680 --> 02:21:57.680]  Вот это все нафиг выкидываем.
[02:21:57.680 --> 02:21:59.680]  Это все игрушки.
[02:22:01.680 --> 02:22:03.680]  Нет, перебрал.
[02:22:05.680 --> 02:22:07.680]  Вот это.
[02:22:07.680 --> 02:22:09.680]  Да.
[02:22:09.680 --> 02:22:11.680]  Давайте делать
[02:22:11.680 --> 02:22:13.680]  смешной метод counter.
[02:22:13.680 --> 02:22:15.680]  Он возвращается с st.
[02:22:15.680 --> 02:22:17.680]  Функцию.
[02:22:17.680 --> 02:22:19.680]  Не метод, функцию.
[02:22:19.680 --> 02:22:21.680]  Констэвал функцию.
[02:22:21.680 --> 02:22:23.680]  Конечно,
[02:22:23.680 --> 02:22:25.680]  должна быть шаблонной.
[02:22:27.680 --> 02:22:29.680]  Но пока не понятно какой.
[02:22:29.680 --> 02:22:31.680]  Главное, что я хочу от этой функции,
[02:22:31.680 --> 02:22:33.680]  чтобы она была констэвал,
[02:22:33.680 --> 02:22:35.680]  но при каждом запуске
[02:22:35.680 --> 02:22:37.680]  возвращала значение на единицу больше.
[02:22:37.680 --> 02:22:39.680]  При каждом констанцировании?
[02:22:39.680 --> 02:22:41.680]  Нет.
[02:22:41.680 --> 02:22:43.680]  При каждом
[02:22:43.680 --> 02:22:45.680]  написании вот такой строчки кода.
[02:22:45.680 --> 02:22:47.680]  Сейчас так не получится,
[02:22:47.680 --> 02:22:49.680]  может быть мы, допустим, шаблон
[02:22:49.680 --> 02:22:51.680]  кого-нибудь методика вызываем,
[02:22:51.680 --> 02:22:53.680]  она будет каждый раз
[02:22:53.680 --> 02:22:55.680]  констанцироваться мной.
[02:22:55.680 --> 02:22:57.680]  Что будет?
[02:22:57.680 --> 02:22:59.680]  Нет, во-первых,
[02:22:59.680 --> 02:23:01.680]  ну ты в правильную сторону мыслишь,
[02:23:01.680 --> 02:23:03.680]  но я не очень понимаю, что ты говоришь.
[02:23:03.680 --> 02:23:05.680]  При каждой констанцировании
[02:23:05.680 --> 02:23:07.680]  каунтора должен
[02:23:07.680 --> 02:23:09.680]  появляться вот это следующее число.
[02:23:09.680 --> 02:23:11.680]  Да, ну как бы да.
[02:23:11.680 --> 02:23:13.680]  Технически,
[02:23:13.680 --> 02:23:15.680]  наблюдаемое поведение,
[02:23:15.680 --> 02:23:17.680]  которое я хочу, чтобы вот здесь, вот у всех трех
[02:23:17.680 --> 02:23:19.680]  массивов был разный размер.
[02:23:19.680 --> 02:23:21.680]  Вот и все. По дефолту,
[02:23:21.680 --> 02:23:23.680]  вот вы вот здесь написали вызов каунтора,
[02:23:23.680 --> 02:23:25.680]  вот здесь и вот здесь.
[02:23:25.680 --> 02:23:27.680]  По дефолту, это все вызов одного
[02:23:27.680 --> 02:23:29.680]  и того же, оно инстанцируется один раз,
[02:23:29.680 --> 02:23:31.680]  и один раз зафиксирует
[02:23:31.680 --> 02:23:33.680]  то, что будет возвращать.
[02:23:33.680 --> 02:23:35.680]  Обязательно нужно
[02:23:35.680 --> 02:23:37.680]  иметь лямбду вот здесь вот,
[02:23:37.680 --> 02:23:39.680]  чтобы подаветь как бы
[02:23:39.680 --> 02:23:41.680]  каширование специализации.
[02:23:41.680 --> 02:23:43.680]  И заставить эту штуку каждый
[02:23:43.680 --> 02:23:45.680]  раз новую специализацию
[02:23:45.680 --> 02:23:47.680]  нам инстанцировать.
[02:23:47.680 --> 02:23:49.680]  А дальше вопрос,
[02:23:49.680 --> 02:23:51.680]  а что мы в этой новой, свежей
[02:23:51.680 --> 02:23:53.680]  специализации будем делать?
[02:24:15.680 --> 02:24:17.680]  Ну короче,
[02:24:17.680 --> 02:24:19.680]  идея. Вот у нас есть слоты.
[02:24:19.680 --> 02:24:21.680]  Занумированные числами.
[02:24:21.680 --> 02:24:23.680]  Да?
[02:24:23.680 --> 02:24:25.680]  Давайте просто будем идти слева направо
[02:24:25.680 --> 02:24:27.680]  и смотреть, пока слот занят, увеличиваем
[02:24:27.680 --> 02:24:29.680]  счетчик. Как только нашли свободный слот,
[02:24:29.680 --> 02:24:31.680]  О, это наше значение. И его
[02:24:31.680 --> 02:24:33.680]  тоже сетним.
[02:24:33.680 --> 02:24:35.680]  А мы чекаем через requires?
[02:24:35.680 --> 02:24:37.680]  Да.
[02:24:37.680 --> 02:24:39.680]  А on instance?
[02:24:39.680 --> 02:24:41.680]  Что? Нет, мы пишем
[02:24:41.680 --> 02:24:43.680]  requires loophole.
[02:24:43.680 --> 02:24:45.680]  Ну как проверить?
[02:24:49.680 --> 02:24:51.680]  Вот.
[02:24:51.680 --> 02:24:53.680]  Вот этот requires
[02:24:53.680 --> 02:24:55.680]  проверяет
[02:24:57.680 --> 02:24:59.680]  да,
[02:24:59.680 --> 02:25:01.680]  проверяет
[02:25:01.680 --> 02:25:03.680]  для какой-то определенной n
[02:25:03.680 --> 02:25:05.680]  есть ли у нас уже текущее значение
[02:25:05.680 --> 02:25:07.680]  какое-то.
[02:25:07.680 --> 02:25:09.680]  Ну...
[02:25:11.680 --> 02:25:13.680]  Да, где
[02:25:13.680 --> 02:25:15.680]  точка с запятой?
[02:25:15.680 --> 02:25:17.680]  Ну проблема в чем? Ну нам надо от нуля идти
[02:25:17.680 --> 02:25:19.680]  и вверх.
[02:25:19.680 --> 02:25:21.680]  Ну сейчас можно было бы
[02:25:21.680 --> 02:25:23.680]  пэвэпендриваться как-то и без рекурсии
[02:25:23.680 --> 02:25:25.680]  это сделать. Я предлагаю не надо.
[02:25:25.680 --> 02:25:27.680]  Я предлагаю
[02:25:27.680 --> 02:25:29.680]  просто еще один дефолтный аргумент добавить
[02:25:29.680 --> 02:25:31.680]  cst n.
[02:25:31.680 --> 02:25:33.680]  Мы будем с этим n работать
[02:25:33.680 --> 02:25:35.680]  и смотреть.
[02:25:41.680 --> 02:25:43.680]  Потому что
[02:25:43.680 --> 02:25:45.680]  в десятый раз напоминаю,
[02:25:45.680 --> 02:25:47.680]  что к сожалению, как только мы начали
[02:25:47.680 --> 02:25:49.680]  использовать
[02:25:49.680 --> 02:25:51.680]  аргументы constival или
[02:25:51.680 --> 02:25:53.680]  constexpr функций, мы уже
[02:25:53.680 --> 02:25:55.680]  откладываемся на поздний этап компиляции.
[02:25:55.680 --> 02:25:57.680]  Вот есть этап компиляции,
[02:25:57.680 --> 02:25:59.680]  где инстанцируются шаблоны, есть этап компиляции,
[02:25:59.680 --> 02:26:01.680]  где делаются constexpr вычисления.
[02:26:01.680 --> 02:26:03.680]  И вот они как бы связаны,
[02:26:03.680 --> 02:26:05.680]  но как бы разные, поэтому мы
[02:26:05.680 --> 02:26:07.680]  не можем сделать вот так.
[02:26:07.680 --> 02:26:09.680]  В общем, на самом деле там
[02:26:09.680 --> 02:26:11.680]  вот Дуборд писал, что это бай дизайн так.
[02:26:11.680 --> 02:26:13.680]  Да, это так и задумано, что
[02:26:13.680 --> 02:26:15.680]  когда у тебя вычисляется эта функция,
[02:26:15.680 --> 02:26:17.680]  разные ее вычисления
[02:26:17.680 --> 02:26:19.680]  не должны приводить к инстанциации
[02:26:19.680 --> 02:26:21.680]  новых шаблонов, поэтому нельзя
[02:26:21.680 --> 02:26:23.680]  запихать в шаблонный аргумент,
[02:26:23.680 --> 02:26:25.680]  аргумент это и constival функция.
[02:26:25.680 --> 02:26:27.680]  Специально так сделали.
[02:26:27.680 --> 02:26:29.680]  Но
[02:26:29.680 --> 02:26:31.680]  мы сейчас по сути такого же самого эффекта и добьемся.
[02:26:31.680 --> 02:26:33.680]  На каждом запуске будет
[02:26:33.680 --> 02:26:35.680]  разная инстанциация генерироваться, и все
[02:26:35.680 --> 02:26:37.680]  нормально будет. То есть они конечно
[02:26:37.680 --> 02:26:39.680]  пытаются воевать с нами, но это бесполезно.
[02:26:39.680 --> 02:26:41.680]  Комьюнити C++
[02:26:41.680 --> 02:26:43.680]  такого придумывает.
[02:26:43.680 --> 02:26:45.680]  Окей, ну
[02:26:45.680 --> 02:26:47.680]  давайте. Проверили, что на текущем
[02:26:47.680 --> 02:26:49.680]  n-ке компилируется
[02:26:49.680 --> 02:26:51.680]  loophole n, то есть сет
[02:26:51.680 --> 02:26:53.680]  произошел. Да?
[02:26:53.680 --> 02:26:55.680]  Если сет произошел,
[02:26:55.680 --> 02:26:57.680]  то мы пока не нашли свободный слот,
[02:26:57.680 --> 02:26:59.680]  и надо идти дальше. Что пишем?
[02:27:03.680 --> 02:27:05.680]  Вот так вот.
[02:27:09.680 --> 02:27:11.680]  Зачем ту же лямду?
[02:27:11.680 --> 02:27:13.680]  Хотим новую.
[02:27:19.680 --> 02:27:21.680]  Смотрите, слоты
[02:27:21.680 --> 02:27:23.680]  сейчас
[02:27:23.680 --> 02:27:25.680]  пробелы будут обозначать пустые
[02:27:25.680 --> 02:27:27.680]  слоты, да?
[02:27:27.680 --> 02:27:29.680]  Ладно, не будут.
[02:27:29.680 --> 02:27:31.680]  Если он занят,
[02:27:31.680 --> 02:27:33.680]  если он занят,
[02:27:33.680 --> 02:27:35.680]  то мы вызываем n-1. Если не занят, пишем.
[02:27:37.680 --> 02:27:39.680]  Вот это нулевой слот.
[02:27:39.680 --> 02:27:41.680]  На первом запуске мы что увидим?
[02:27:41.680 --> 02:27:43.680]  Нулевой слот свободен.
[02:27:43.680 --> 02:27:45.680]  А что значит нулевой слот свободен?
[02:27:45.680 --> 02:27:47.680]  Сета пока не произошло, да?
[02:27:49.680 --> 02:27:51.680]  Вот это проверяет, что
[02:27:51.680 --> 02:27:53.680]  loophole компилируется,
[02:27:53.680 --> 02:27:55.680]  то есть что он занят.
[02:27:55.680 --> 02:27:57.680]  Иначе мы пойдем в ветку else.
[02:27:57.680 --> 02:27:59.680]  Давайте поменяем.
[02:27:59.680 --> 02:28:01.680]  Поменяем местами.
[02:28:01.680 --> 02:28:03.680]  Вот так вот.
[02:28:03.680 --> 02:28:05.680]  Здесь надо set сделать, да?
[02:28:05.680 --> 02:28:07.680]  Как мы делаем?
[02:28:07.680 --> 02:28:09.680]  loophole
[02:28:09.680 --> 02:28:11.680]  n
[02:28:13.680 --> 02:28:15.680]  Вот так вот.
[02:28:15.680 --> 02:28:17.680]  Вот он наш loophole,
[02:28:17.680 --> 02:28:19.680]  и вот мы просто смотрим.
[02:28:19.680 --> 02:28:21.680]  Был set, не было, идем дальше.
[02:28:21.680 --> 02:28:23.680]  Прекрасно.
[02:28:23.680 --> 02:28:25.680]  Ну, даже коротко получилось.
[02:28:29.680 --> 02:28:31.680]  Что значит нашу?
[02:28:31.680 --> 02:28:33.680]  Как ты ее используешь?
[02:28:33.680 --> 02:28:35.680]  Ну зачем ты ее используешь?
[02:28:41.680 --> 02:28:43.680]  Ну ладно, я не знаю.
[02:28:43.680 --> 02:28:45.680]  Честно, я сейчас не
[02:28:45.680 --> 02:28:47.680]  в настолько пиковом состоянии,
[02:28:47.680 --> 02:28:49.680]  чтобы понять в голове, что произойдет.
[02:28:49.680 --> 02:28:51.680]  Кажется, это на самом деле умная идея.
[02:28:51.680 --> 02:28:53.680]  То есть внимание.
[02:28:53.680 --> 02:28:55.680]  У нас нету ошибок компиляции.
[02:28:55.680 --> 02:28:57.680]  И так нету ошибок компиляции.
[02:28:57.680 --> 02:28:59.680]  И так нету ошибок.
[02:28:59.680 --> 02:29:01.680]  Да-да-да.
[02:29:01.680 --> 02:29:03.680]  Наверное, это хорошая идея.
[02:29:03.680 --> 02:29:05.680]  Размеры массивов.
[02:29:05.680 --> 02:29:07.680]  С одинаковым.
[02:29:07.680 --> 02:29:09.680]  Этим разное.
[02:29:09.680 --> 02:29:11.680]  Но вот и весь каунтер.
[02:29:11.680 --> 02:29:13.680]  Одна функция, фактически.
[02:29:15.680 --> 02:29:17.680]  Вот эти инициации, они происходят
[02:29:17.680 --> 02:29:19.680]  на второй стане.
[02:29:23.680 --> 02:29:25.680]  Какие?
[02:29:25.680 --> 02:29:27.680]  Loophole N
[02:29:29.680 --> 02:29:31.680]  Loophole N
[02:29:31.680 --> 02:29:33.680]  оно, да,
[02:29:33.680 --> 02:29:35.680]  оно инстанцирует
[02:29:35.680 --> 02:29:37.680]  вот этот шаблон
[02:29:37.680 --> 02:29:39.680]  только если мы
[02:29:39.680 --> 02:29:41.680]  в if пошли.
[02:29:41.680 --> 02:29:43.680]  Тут как бы то, про что я говорил,
[02:29:43.680 --> 02:29:45.680]  почему нельзя аргументы
[02:29:45.680 --> 02:29:47.680]  в конставал или констэкспор функции
[02:29:47.680 --> 02:29:49.680]  использовать в шаблонах, это
[02:29:49.680 --> 02:29:51.680]  странный вопрос.
[02:29:51.680 --> 02:29:53.680]  Вообще это можно сделать в компиляторах,
[02:29:53.680 --> 02:29:55.680]  чтобы это работало. Но почему-то не хотят
[02:29:55.680 --> 02:29:57.680]  делать, потому что это совсем мозг взорвет людям.
[02:29:57.680 --> 02:29:59.680]  Мы считаем, что у нас
[02:29:59.680 --> 02:30:01.680]  констэкспор, конставал функции работают как
[02:30:01.680 --> 02:30:03.680]  обычные функции.
[02:30:03.680 --> 02:30:05.680]  Точно так. У обычных функций вы не можете
[02:30:05.680 --> 02:30:07.680]  аргументы их пихать в аргументы шаблона?
[02:30:07.680 --> 02:30:09.680]  Не можете. И здесь точно такую же
[02:30:09.680 --> 02:30:11.680]  семантику сохранили.
[02:30:11.680 --> 02:30:13.680]  Чтобы не взрывать людям мозги.
[02:30:13.680 --> 02:30:15.680]  У нас будет такая проблема,
[02:30:15.680 --> 02:30:17.680]  что если мы разрешим
[02:30:17.680 --> 02:30:19.680]  считать аргументы
[02:30:19.680 --> 02:30:21.680]  конставал функций
[02:30:21.680 --> 02:30:23.680]  константными выражениями,
[02:30:23.680 --> 02:30:25.680]  то у нас может быть такая проблема,
[02:30:25.680 --> 02:30:27.680]  что у нас возвращаемый тип этой функции
[02:30:27.680 --> 02:30:29.680]  зависит от значения аргумента.
[02:30:29.680 --> 02:30:31.680]  Да, может.
[02:30:31.680 --> 02:30:33.680]  Это немножко страшно.
[02:30:33.680 --> 02:30:35.680]  Это зависимые типы.
[02:30:35.680 --> 02:30:37.680]  И мы их не хотим.
[02:30:37.680 --> 02:30:39.680]  Потому что мы мазохисты
[02:30:39.680 --> 02:30:41.680]  и не хотим ничего хорошего.
[02:30:41.680 --> 02:30:43.680]  Мы хотим страдать.
[02:30:43.680 --> 02:30:45.680]  То есть у нас инстанциация
[02:30:45.680 --> 02:30:47.680]  происходит, когда ИВ выполняется?
[02:30:47.680 --> 02:30:49.680]  Да, инстанциация loophole-end
[02:30:49.680 --> 02:30:51.680]  происходит только тогда, когда мы
[02:30:51.680 --> 02:30:53.680]  в этот ИВ вошли. Почему-то это работает так.
[02:30:53.680 --> 02:30:55.680]  Почему?
[02:30:55.680 --> 02:30:57.680]  А что не так?
[02:30:57.680 --> 02:30:59.680]  Ну, вообще, ИВ констэкспор, он так и задуман.
[02:30:59.680 --> 02:31:01.680]  У тебя полностью выкидывается ветка,
[02:31:01.680 --> 02:31:03.680]  которая не сработала. Она даже не компилируется,
[02:31:03.680 --> 02:31:05.680]  шаблоны не инстанцируются. То есть по дефолту...
[02:31:05.680 --> 02:31:07.680]  Столько стимуэйтит-энтити.
[02:31:07.680 --> 02:31:09.680]  Окей.
[02:31:09.680 --> 02:31:11.680]  Это замечание, о котором я не в курсе.
[02:31:11.680 --> 02:31:13.680]  Если ты уберешь стимуэйт,
[02:31:13.680 --> 02:31:15.680]  это констэкспор функции, то, кажется, ИВ констэкспор будет инстанцировать тебе ветки.
[02:31:15.680 --> 02:31:17.680]  Да.
[02:31:19.680 --> 02:31:21.680]  Он не должен заранее знать, сколько там
[02:31:21.680 --> 02:31:23.680]  вот все эти...
[02:31:23.680 --> 02:31:25.680]  Нет. Нет, нет.
[02:31:25.680 --> 02:31:27.680]  Смотри.
[02:31:27.680 --> 02:31:29.680]  ИВ констэкспор выполняется не в момент
[02:31:29.680 --> 02:31:31.680]  исполнения функции, вообще говоря,
[02:31:31.680 --> 02:31:33.680]  а в момент
[02:31:33.680 --> 02:31:35.680]  инстанциации шаблона функции.
[02:31:35.680 --> 02:31:37.680]  То есть вот этот шаблон каунтора,
[02:31:37.680 --> 02:31:39.680]  в момент, когда он инстанцируется,
[02:31:39.680 --> 02:31:41.680]  выполняется ИВ констэкспор и выбирает,
[02:31:41.680 --> 02:31:43.680]  что оставить в этой функции.
[02:31:43.680 --> 02:31:45.680]  Либо эту ветку, либо эту ветку.
[02:31:45.680 --> 02:31:47.680]  Вот так вот.
[02:31:51.680 --> 02:31:53.680]  Вот.
[02:31:53.680 --> 02:31:55.680]  И дальше уже ту ветку,
[02:31:55.680 --> 02:31:57.680]  которую мы оставили, мы пойдем тоже
[02:31:57.680 --> 02:31:59.680]  компилировать, и в этот момент инстанцируем
[02:31:59.680 --> 02:32:01.680]  лупхол.
[02:32:03.680 --> 02:32:05.680]  Ну а здесь просто пойдем дальше
[02:32:05.680 --> 02:32:07.680]  по рекурсии и будем инстанцировать уже
[02:32:07.680 --> 02:32:09.680]  другой каунтор.
[02:32:09.680 --> 02:32:11.680]  Ну и как-то так.
[02:32:11.680 --> 02:32:13.680]  А в рантайме, в рантайме, это
[02:32:13.680 --> 02:32:15.680]  в кавычках в рантайме.
[02:32:15.680 --> 02:32:17.680]  То есть после того, как шаблон уже весь
[02:32:17.680 --> 02:32:19.680]  полностью инстанцировался,
[02:32:19.680 --> 02:32:21.680]  эта специализация у нас
[02:32:21.680 --> 02:32:23.680]  уже есть, запуск ее,
[02:32:23.680 --> 02:32:25.680]  несмотря на то, что это конставал штука,
[02:32:25.680 --> 02:32:27.680]  как бы в рантайме запуск,
[02:32:27.680 --> 02:32:29.680]  он будет просто состоять из того, чтобы
[02:32:29.680 --> 02:32:31.680]  насквозь пролететь, сквозь
[02:32:31.680 --> 02:32:33.680]  три слоя запуска каунтора
[02:32:33.680 --> 02:32:35.680]  и в итоге
[02:32:35.680 --> 02:32:37.680]  влететь в return n.
[02:32:37.680 --> 02:32:39.680]  И все. То есть там больше никакого кода
[02:32:39.680 --> 02:32:41.680]  не будет.
[02:32:41.680 --> 02:32:43.680]  И в констекспро вырезаются в момент
[02:32:43.680 --> 02:32:45.680]  инстанциации шаблонов.
[02:32:53.680 --> 02:32:55.680]  Ну вот что-то в этом есть
[02:32:55.680 --> 02:32:57.680]  извращенное, а если вы вспомните,
[02:32:57.680 --> 02:32:59.680]  что вся эта штука в принципе вычисляется
[02:32:59.680 --> 02:33:01.680]  в момент, когда мы собрались
[02:33:01.680 --> 02:33:03.680]  инстанцировать шаблоны cd array,
[02:33:03.680 --> 02:33:05.680]  чтобы понять для него второй не типовой
[02:33:05.680 --> 02:33:07.680]  аргумент, то вот уже как-то мозг начинает
[02:33:07.680 --> 02:33:09.680]  кипеть немножко.
[02:33:09.680 --> 02:33:11.680]  Ладно.
[02:33:11.680 --> 02:33:13.680]  На этом мы закончим.
[02:33:13.680 --> 02:33:15.680]  В заключение могу лишь
[02:33:15.680 --> 02:33:17.680]  сказать, что с помощью этого можно сделать
[02:33:17.680 --> 02:33:19.680]  некоторое подобие боров чекера.
[02:33:19.680 --> 02:33:21.680]  Размечая регионы,
[02:33:21.680 --> 02:33:23.680]  где там переменные жива или мертва
[02:33:23.680 --> 02:33:25.680]  через холл сета и геза.
[02:33:25.680 --> 02:33:27.680]  То есть...
[02:33:27.680 --> 02:33:29.680]  Мапу типов тоже
[02:33:29.680 --> 02:33:31.680]  кучу можно сделать.
[02:33:31.680 --> 02:33:33.680]  Попробуйте, вы офигеете
[02:33:33.680 --> 02:33:35.680]  от того, какая жизнь интересная.
[02:33:35.680 --> 02:33:37.680]  Всё. На этом совсем-совсем
[02:33:37.680 --> 02:33:39.680]  всё. Всем спасибо.
[02:33:39.680 --> 02:33:41.680]  Все свободны.
