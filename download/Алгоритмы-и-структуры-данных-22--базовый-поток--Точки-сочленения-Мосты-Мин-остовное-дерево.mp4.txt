[00:00.000 --> 00:08.840]  В прошлой неделе мы должны были с вами поговорить про мосты точки сочинения, что это такое, как
[00:08.840 --> 00:13.480]  вообще с этим работать и что происходит. На семинарах, я подозреваю, что практически вы
[00:13.480 --> 00:24.160]  пописали что-нибудь, поделали, правда? Было что-то? У всех? А кто не ходит на семинары? Хорошо,
[00:24.160 --> 00:32.800]  давайте там другой вопрос. В общем-то, что такое точка сочинения, кто из вас помнит?
[00:32.800 --> 00:42.280]  Если убрать, то будет несколько компонент связанности. Да, то есть точка сочинения в
[00:42.280 --> 00:47.880]  неориентированном графе g это будет вершина удаления, которая ведет к увеличению компонент
[00:47.880 --> 00:55.880]  связанности. Это может быть их несколько точек сочинения, но изолированная точка, например,
[00:55.880 --> 01:00.200]  никогда не приводит к нарушению связанности, поэтому изолированные точки никогда не будут
[01:00.200 --> 01:12.240]  точками сочинения. Вот здесь на этом графе какая точка? 1, 3 и все, отлично. Да, вот, то есть мы
[01:12.240 --> 01:17.360]  удаляем эту вершину, все ребра из нее, которые рядом с ней, тоже удаляются, поэтому у нас
[01:17.360 --> 01:25.200]  получается вот такой вот механизм. Как вообще понять, что нам делать с точками сочинения? Ну,
[01:25.200 --> 01:30.480]  предположим, что мы запустим какой-нибудь алгоритм DFS, вот, какой-то стартовой вершины,
[01:30.480 --> 01:35.360]  и мы говорим, что это стартовая вершина, она будет точкой сочинения тогда и только тогда,
[01:35.360 --> 01:42.640]  когда у нее будет несколько сыновей, один или более, а в дереве обхода, почему?
[01:42.640 --> 01:52.280]  Ой, два или более, соря, два или более. Нет, смотрите, я запускаю DFS, вот у меня есть граф,
[01:52.280 --> 02:00.640]  я запускаю в какой-то конкретной точке DFS, вот, и у этой конкретной точки несколько сыновей получается,
[02:00.640 --> 02:10.520]  вот в дереве обхода мы, да, то есть смотрите, вот у меня раз, тут какой-то график, два, три,
[02:10.520 --> 02:16.640]  вот так у меня граф, вот это стартовая вершина, с которой я запустил, вот это у меня получившееся
[02:16.640 --> 02:25.200]  дерево моего обхода DFS, а если я его удаляю, тогда она является точкой сочинения, почему? Ну,
[02:25.200 --> 02:30.960]  а в одну сторону достаточно все просто, если бы у меня был всего лишь один сын или вообще их не было,
[02:30.960 --> 02:35.440]  тогда в этом случае как бы у меня компонента бы не нарушилась, она как была одна, так и осталась,
[02:35.440 --> 02:42.240]  вот, ну сколько их было, столько осталось там внутри, если мы говорим с вами про несколько,
[02:42.240 --> 02:53.080]  тогда они связаны у нас через, связаны через эту вершину, да, вот, ну как бы здесь все очень логично,
[02:53.080 --> 02:58.880]  очень легко и очень понятно, то есть нам, если вот говорить чисто формально, то у нас есть лемма о
[02:58.880 --> 03:05.560]  белых путях, мы DFS заходим только в белые вершины, значит у нас из белой вершины в белую любую другую
[03:05.560 --> 03:10.600]  есть путь, и этот путь точно проходит через R, потому что иначе бы оно лежало в одном и том же,
[03:10.600 --> 03:17.200]  ну под одним и тем же сыном, вот, значит этот путь проходит вот так или там вот так к соседнему,
[03:17.200 --> 03:23.400]  поэтому здесь у нас как бы получается такой вот момент, что у нас это является точкой сочинения,
[03:23.400 --> 03:32.800]  как бы оно в две стороны будет работать, вот, а предположим, что у нас не стартовая вершина уже,
[03:32.800 --> 03:38.400]  стартовая вершина была R и мы рассмотрим какую-то другую вершину, в каком случае мы можем сказать,
[03:38.400 --> 03:42.680]  что это является точкой сочинения, но это является точкой сочинения только тогда,
[03:42.680 --> 03:50.400]  когда у нас существует какой-то сын УВ, если, ну и из этого У нельзя попасть в какого-то предка В,
[03:50.400 --> 03:54.560]  что подразумевается здесь, ну смотрите, вот у меня есть какая-то стартовая вершина,
[03:54.560 --> 04:04.480]  вот там вот как-то идет, у меня есть вершина У, есть вершина В, наоборот, наоборот сделаю,
[04:04.480 --> 04:16.880]  вот, а что означает из У нельзя попасть в предка В, двигаясь только вот по рюбрам дерева,
[04:16.880 --> 04:25.000]  то есть у меня нету чего-то такого, правильно, а из-за этого вот если у меня был здесь какой-то
[04:25.000 --> 04:30.960]  путь, я не могу попасть ни к одному предку, который был выше, то что будет при удалении данной вершины,
[04:30.960 --> 04:36.600]  ну чисто интуитивно, они разделятся между собой, то есть я не смогу из-за этой вершины подняться
[04:36.600 --> 04:41.000]  куда-то выше, никаким образом, то есть у меня не будет никакого пути для того, чтобы подняться
[04:41.000 --> 04:47.200]  вот сильно высоко, из-за этого при удалении данной вершины у меня вот эти останутся обособлены и вот
[04:47.200 --> 04:52.520]  эти останутся обособлены, то есть у меня увеличится количество компонент связанности,
[04:52.520 --> 05:00.200]  правильно, вот, но здесь мы говорим с вами, что мы двигаемся только по рёбрам и максимум одному
[05:00.200 --> 05:06.960]  обратному ребру, вот, но как бы здесь ровно в этом логика и состоит, то есть у нас есть
[05:06.960 --> 05:12.920]  некоторая вершина, у неё есть некоторый сын, вот, и мы от него смотрим, можно попасть как-нибудь наверх,
[05:12.920 --> 05:17.840]  через вниз и обратно или нет, то есть вот мы можем куда-нибудь вот отсюда попробовать пойти,
[05:17.840 --> 05:23.840]  если нет, то у нас беда, мы ничего не можем сделать, значит у нас получается больше компонент связанности,
[05:23.840 --> 05:32.200]  понятно, что я говорю или есть какие-то вопросы к этому всему,
[05:32.200 --> 05:42.040]  видимо, всё понятно, но теперь смотрите, у нас есть раз, есть два, у нас есть вот эти две теоремы,
[05:42.040 --> 05:48.320]  останется их вместе соединить и тогда мы получим с вами алгоритм поиска точек сочленения,
[05:48.320 --> 05:53.800]  нам нужно будет запускать алгоритм DFS из какой-то любой произвольной вершины,
[05:53.800 --> 06:02.240]  дальше мы смотрим на саму эту вершину, если у нас в самой этой вершины есть хотя бы две соседние
[06:02.240 --> 06:07.960]  белые вершины, то тогда R это точка сочленения, правильно, ну, то есть мы смотрим просто на
[06:07.960 --> 06:14.640]  соседние, вот, а после этого мы смотрим на какую-то вершину U, ну, то есть мы проходимся по всем
[06:14.640 --> 06:21.080]  вершинам и смотрим, у детей есть вариант подняться как-то наверх или нет, то есть выше
[06:21.080 --> 06:26.080]  нашей вершины, если есть, то всё хорошо, это не является точкой сочленения, если нет,
[06:26.080 --> 06:37.320]  то тогда это является точкой сочленения, вот, да, да, по первому пункту DFS запускаем из произвольной
[06:37.320 --> 06:49.680]  вершины, по второму есть две белые соседние вершины от нашей вершины R, то есть это означает,
[06:49.680 --> 07:02.040]  что у нас есть вот такое, да, мы должны вот это вот всё закрасить, вернуться и заново посмотреть,
[07:02.040 --> 07:22.400]  вот, понятно, хорошо, по третьему пункту есть вопросик, его достаточно, то есть смотрите,
[07:22.400 --> 07:27.320]  подразумевается следующее, вот у нас есть некоторая вершина V, у нас есть некоторая вершина U,
[07:27.320 --> 07:35.200]  они связаны между собой, U является сыном V, вот они связаны здесь, и дальше вот здесь вот там
[07:35.200 --> 07:42.760]  что-то находится, какая-то там, какое-то дерево, нам нужно понимать, если есть хотя бы одно ребро,
[07:42.760 --> 07:50.480]  которое находится сверху, тогда в этом случае мы уже можем идти выше, вот, а почему говорят про
[07:50.480 --> 07:55.320]  хотя бы одно ребро, потому что проверять будет легче, значит бесконечно может быть, для одного
[07:55.320 --> 07:59.840]  ребра это достаточно, потому что, ну представьте, у меня раз ребро, два ребро, три ребро, четыре,
[07:59.840 --> 08:07.400]  и потом отсюда, это очень долго проверять, одно обратное ребро понятно как проверить, быстро, вот,
[08:07.400 --> 08:24.080]  вопросы? Нет вопросов, хорошо, вот, теперь вопрос, как нам быстро понять, что из ребенка U нельзя
[08:24.080 --> 08:45.000]  попасть в какого-нибудь предка? Нет, а сколько будет работать этот метод? Приятное, вот, будем
[08:45.000 --> 08:51.080]  работать бесконечно долго, хорошо, смотрите, в действительности, как бы, мы будем вводить
[08:51.360 --> 08:59.560]  некоторое время, грубо говоря, время входа, время выхода из вершин, и вот время входа в вершину
[08:59.560 --> 09:04.880]  оно будет позволять нам как раз-таки понимать, когда мы вошли в данную вершину, и куда мы можем
[09:04.880 --> 09:12.480]  прийти дальше, то есть у нас будет некоторые такой тайм-ап, тайм-ин, вот, и этого будет достаточно,
[09:12.480 --> 09:17.920]  вот некоторые меры глубины вниз у нас будет тайм-ин, то есть во сколько мы вошли, а когда мы будем
[09:17.920 --> 09:24.640]  смотреть насколько мы можем подняться, мы просто смотрим насколько высоко мы можем пойти по этому
[09:24.640 --> 09:33.720]  времени. Вот и все. То есть у нас будет таймин и таймап. Что такое таймин? А таймин это время,
[09:33.720 --> 09:41.360]  когда мы заходим в данную вершину и мы можем остаться чисто в ней. А таймин бэк это как раз
[09:41.360 --> 09:48.760]  таки подняться по обратному ребру в какой-то бэк. Вот и таймап сам по себе это вот спуститься по
[09:48.760 --> 09:54.920]  дереву куда-то и после этого подняться оттуда. Почему мы можем говорить о том, что мы можем
[09:54.920 --> 10:03.880]  посчитать таймап вот в этой вершине, например? У нас же DFS какой? Какая функция это? Рекурсивная,
[10:03.880 --> 10:09.720]  то есть если мы посчитаем у детей, мы узнаем и у этого, правильно? Вот, а потому что мы будем
[10:10.200 --> 10:13.600]  раскручиваться назад, поэтому здесь, когда мы будем поднимать насколько мы можем подняться,
[10:13.600 --> 10:18.320]  мы здесь поймем тоже насколько мы можем подняться. Поэтому у нас есть как раз таки три варианта
[10:18.320 --> 10:25.920]  что максимальное время насколько мы можем подняться, то есть, насколько высоко мы можем зайти,
[10:25.920 --> 10:33.160]  это время когда мы зашли просто в эту вершину. То есть мы остаемся в ней listening у нас
[10:33.160 --> 10:39.880]  можем из нее подняться куда-нибудь вверх то есть из вот этой вершины у предположим
[10:39.880 --> 10:46.920]  что у нас есть некоторое такое вот ребро и вот мы по нему можем подняться и последнее
[10:46.920 --> 10:51.920]  это вот таймап это как раз таки вот из детей сложить и понять насколько они максимум могут
[10:51.920 --> 11:00.120]  подниматься здесь написано минимум ну что время это минимум почему потому что время входа у нас
[11:00.120 --> 11:11.680]  чем ниже тем больше наша глубина понятно что я сказал отлично значит семинар у вас прошел не
[11:11.680 --> 11:21.640]  зря это чудесно вот поэтому здесь в действительности как бы какие какие критерии для точек
[11:21.640 --> 11:29.120]  сочинения но первое для корня обхода считаем что это точка сочинения если у него больше одного
[11:29.120 --> 11:37.040]  ребенка получается то есть вот сколько мы белых вершин вот так вот походили везде ну а для проверки
[11:37.040 --> 11:44.080]  того что у нас является точка сочинения некоторая вершина в это означает что в этой вершине в из
[11:44.080 --> 11:53.640]  ее ребенка нельзя подняться выше вот то есть время входа в данную вершину оно будет меньше
[11:53.640 --> 11:59.320]  либо равно чем таймап от других это означает как раз таки этот момент что мы не можем никуда
[11:59.320 --> 12:07.400]  подняться то есть таймы на то вот та самая мера глубины есть вершина в вершина у если у меня таймап
[12:07.400 --> 12:13.720]  из этой вершины то есть насколько я максимум могу подняться он не доходит до вершины в н не
[12:13.720 --> 12:20.480]  знаю тут 5 тут 6 например вот но он максимум 6 приходит потому что не знаю там какой-нибудь ребенок
[12:20.480 --> 12:29.360]  усмотрит еще вот если у него максимальное время это 6 то у нас как бы беда в этом случае мы говорим
[12:29.360 --> 12:41.640]  что вершины в будет у нас делать будет той самой точкой сочинения мы ходим по всем вершинам и смотрим
[12:41.640 --> 13:05.520]  у них нет почему а если как понять что у нас ребенок есть вот на этом вот чудо графики ну
[13:05.520 --> 13:10.560]  смотрите в действительности как бы а 4 подходит под первые критерии правда
[13:10.560 --> 13:21.640]  да мы насмотрим на каждую вершину смотрите вот на данном на данном графе который здесь есть
[13:21.640 --> 13:35.240]  у шестерки есть один сын правильно и у него таймап какой нулевой правильно а время входа
[13:35.240 --> 13:43.840]  вершину 6 2 ну то есть вот написано 2 0 2 этого сколько мы вошли 0 это насколько мы можем поднять вот
[13:43.840 --> 13:58.960]  ну таймап 0 поэтому это время входа в корень время входа в корень 0 ну давайте хорошо давайте
[13:58.960 --> 14:28.640]  хорошо давай 4 что у нас там 0 5 6 1 3 2 вот так есть и вот так есть
[14:28.960 --> 14:40.920]  это дерево обхода а как у нас здесь идет таймын давайте сначала начнем с него к примеру таймын
[14:40.920 --> 14:46.960]  что делает он заходит сначала в наш корень ну этого дерева откуда мы начали всегда будет корень
[14:46.960 --> 14:56.160]  как раз таки дальше мы заходили в пятерку дальше мы заходили в шестерку потом единичку вот после
[14:56.160 --> 15:07.920]  этого мы оттуда ушли получили что мы зашли в 0 у нас здесь будет 4 потом здесь было 5 10 6 это
[15:07.920 --> 15:17.560]  время входа правильно осталось понять время куда мы максимум можем подниматься ну как бы из
[15:17.560 --> 15:21.880]  нулевой вершины куда я могу максимум подняться но остаться в себе потому что выше не бывает на
[15:21.880 --> 15:27.560]  самом деле поэтому у нас здесь будет ноль ноль из пятерки могу ли я куда-то выше подняться
[15:27.560 --> 15:36.360]  нет поэтому я могу остаться только на месте то есть я могу у нас какой есть вариант я могу
[15:36.360 --> 15:43.480]  либо остаться в этой вершине либо по обратному ребру подняться либо спуститься в детей и
[15:43.480 --> 15:53.160]  подняться по ним три вот этих варианта да я у меня здесь единственный вариант остаться на месте
[15:53.160 --> 15:57.640]  подняться наверх я никак не могу потому что это дерево у меня здесь все ориентировано уже
[15:57.640 --> 16:07.080]  лично теперь смотрите когда я раскручивал вот этот стэк вызову грубо говоря рекурсии то в этом
[16:07.080 --> 16:14.840]  случае здесь на самом деле идет снизу вверх единицу я могу подняться в ноль же могу поэтому
[16:14.840 --> 16:29.640]  здесь таймап 0 я его посчитаю раньше чем я зайду в шестерку это возможно так не вот так вот а дальше
[16:29.640 --> 16:35.600]  я захожу в шестерку то есть возвращаюсь из единицы сюда и смотрю ага первый вариант я остаюсь на
[16:35.600 --> 16:43.600]  месте в этом случае таймап 2 могу ли я подняться из шестерки куда-нибудь нет могу ли я через детей
[16:43.600 --> 16:54.320]  подняться куда-нибудь да поэтому я выбираю минимум из двойки и нолика получается 0 сюда смотрим
[16:54.320 --> 17:02.240]  давайте опять мы смотрим из детей из тройки таймап куда колька я могу остаться на месте это
[17:02.240 --> 17:12.760]  будет 5 я могу подняться вверх это будет 0 и все из детей у него нет детей правильно поэтому
[17:12.760 --> 17:20.320]  меня между пятеркой нулем самым минимально ну и с шестерки ой ну из второй вершины который за что
[17:20.320 --> 17:27.760]  зашел шестой из нее я могу остаться на месте это 6 подняться наверх я не могу у меня нет никакого
[17:27.760 --> 17:34.840]  обратного ребра в этой вершине детей тоже нет поэтому остается только один вариант остаться на
[17:34.840 --> 17:45.400]  месте правильно поэтому это будет 6 пересмотрю сюда а первый вариант остается на месте 4 второй
[17:45.400 --> 17:52.680]  вариант а подняться наверх могу ли я отсюда нет у меня ничего нет поэтому это отметаем и
[17:52.880 --> 18:01.360]  и третий вариант подняться из детей левой я поднимусь к нулевой управок шестерки вот
[18:01.360 --> 18:14.680]  я выбираю 4 0 6 что из этого лучше 0 вот так расставляется таймапы ну вот чисто если
[18:14.680 --> 18:22.040]  нарисовать отлично теперь смотрите а у нас это расставлено и какое условие на точки сочленения
[18:22.440 --> 18:31.360]  я смотрю сначала на корень и такой у меня есть сколько детей здесь 3 больше чем 1
[18:31.360 --> 18:40.160]  больше чем 1 а это означает что это является точка сочленения то есть вершины 4 это точка
[18:40.160 --> 18:49.360]  сочленения вот теперь смотрю на все остальные вершины у пятерки детей нет ну как двои ладно
[18:49.640 --> 18:56.400]  она не является точкой в шестерке у нее есть ребенок но у этого ребенка таймап выше чем тайм
[18:56.400 --> 19:06.480]  ин здесь правильно значит она может подниматься к предку значит если таймап в этой вершинке
[19:06.480 --> 19:14.020]  больше чем тут вот значит я могу поднимать точнее тайм-ин в этой вершинке меньше чем
[19:14.020 --> 19:18.080]  больше, чем таймап в этой вершинке, то есть я могу из этой вершины подняться
[19:18.080 --> 19:24.460]  выше, чем вот это. Тут два, а тут я поднимаюсь на ноль. Значит, если я удалю, ничего не
[19:24.460 --> 19:31.580]  произойдет. Ну, то есть удалю эту вершину, меня связано сохраняется. Правильно?
[19:31.580 --> 19:38.260]  Хорошо, идем сюда. Ну, тройки, двойки, понятно, ничего не происходит, у них детей нет.
[19:38.260 --> 19:46.940]  Смотрю на нолик. У меня время вход 4. Смотрю на левого ребенка. Если я удалил бы эту
[19:46.940 --> 19:51.020]  нулевую вершину, то вот этот левый ребенок бы остался все так же связанным. Правильно?
[19:51.020 --> 19:58.780]  Потому что тут ноль. А вот в то же время, если я посмотрю на правого ребенка, то у меня здесь
[19:58.780 --> 20:06.780]  6. Он подняться никуда не может. Ни к чему лучше он подняться не может. Согласны? А это означает,
[20:06.780 --> 20:13.020]  что если я удалю эту вершину, то у меня связанность нарушится. Поэтому здесь это
[20:13.020 --> 20:21.300]  является точкой исчленения. То есть я посмотрю на всех детей. Стал понятнее на примере?
[20:21.300 --> 20:30.740]  Нет, у нас нет ориентированных графов. У нас не ориентированный граф – это дерево обхода.
[20:30.740 --> 20:43.540]  Это получившееся дерево. Смотрите, как мы можем подниматься. Мы считаем,
[20:43.540 --> 20:49.980]  что у нас есть некоторая вершина, и у нее есть дети. Что подразумевается под
[20:49.980 --> 20:56.660]  одному обратному ребру? То есть мы доходим до какой-то здесь вершины, и от нее поднимаемся вверх,
[20:56.660 --> 21:10.460]  и считаем, что она максимальная. Смотрите, вершины У мы идем куда-нибудь к детям,
[21:10.460 --> 21:16.860]  приходим к ним в какую-то точку. Тут может быть другой ребенок, который поднимается вот сюда.
[21:16.860 --> 21:26.140]  Какой из них для меня более выгодный с точки зрения рассмотрения У? Вот этот.
[21:26.140 --> 21:37.260]  Не тайм-ин, тайм-ап. Я мог сначала вот в эту сторону пойти, здесь все обследовать,
[21:37.260 --> 21:44.260]  потом сюда. Здесь тайм-ин будет меньше. Для меня выгоднее тот, который пойдет выше.
[21:44.260 --> 21:50.620]  И под этим подразумевается, что у меня есть хотя бы одно обратное ребро. То есть я поднимаюсь
[21:50.620 --> 22:08.140]  по одному конкретному ребру. Вот оно. Чтобы найти его ребро? Чтобы найти тайм-ап. Смотрите,
[22:08.140 --> 22:15.980]  давайте еще раз. Как у нас работает ДФС? Согласны, что я сначала обработаю все эти вершины? Я буду
[22:15.980 --> 22:22.900]  по слоям обходить по сути. Согласны? То есть я рекурсивно сначала сюда зашел, потом уже поднялся,
[22:22.900 --> 22:30.220]  опять вниз и так далее. Вот. Я найду здесь тайм-ап, здесь тайм-ап, здесь тайм-ап, здесь тайм-ап.
[22:30.220 --> 22:38.300]  Вот у детей УУ, вот здесь вот которые будут находиться, вот на этом верхнем уроке, грубо говоря,
[22:38.300 --> 22:44.100]  у них свой тайм-ап есть, который они могут пройти, либо спустившись до детей подняться вверх,
[22:44.100 --> 22:52.380]  либо сами пойти вверх. Правильно? Я выбираю из них чиселка, которая мне подходит. Минимальная.
[22:52.380 --> 23:12.420]  Вы писали код на семинарах? Хорошо. Там был тайм-ин и тайм-ап? Ну, время входа, время выхода, да. Вот.
[23:12.420 --> 23:19.980]  Что, как выглядит вообще весь псевдокод? Весь псевдокод, который у нас есть. Сначала мы с вами,
[23:19.980 --> 23:26.620]  ну, все так же, типа, как мы посещаем вершину, некоторую нашу вершину, а дальше мы говорим,
[23:26.620 --> 23:32.860]  что время входа в данную вершину равно тайм-апу данную вершину плюс-плюс тайм. Что под этим
[23:32.860 --> 23:38.820]  подразумевается? Ну, смотрите, это именно то самое, когда мы говорим, что мы остаемся в этой вершине.
[23:38.820 --> 23:46.260]  Мы никуда не поднимаемся, мы просто идем вверх. Окей? Вот. То есть мы говорим, что в начале тайм-ин
[23:46.260 --> 23:57.060]  и тайм-ап одинаково. Дальше я считаю количество своих детей. Вот. Ну, точнее, сколько детей у меня
[23:57.060 --> 24:06.140]  там, к примеру, есть. После этого я смотрю и иду по всем вершинам, соседним с моей вершиной У.
[24:06.140 --> 24:11.860]  Которая является, ну, точнее, вершина У это все соседи, которые у меня есть, соседи вершины В.
[24:11.860 --> 24:24.660]  У меня есть В и у нее есть несколько вершин. Вот в форум я прохожусь по всем этим У. Окей?
[24:24.660 --> 24:36.100]  Окей. Какие есть варианты? Есть варианты несколько. А в какие вершины мы можем смотреть? В черную мы
[24:36.100 --> 24:43.780]  можем смотреть? Не можем. Мы можем смотреть только в белую или в серую. Если мы смотрим в серую вершину,
[24:43.780 --> 24:58.180]  то что это означает? Ну, что мы вот так вот делаем, вот тут вершина У. Правильно? Обратное ребро у
[24:58.180 --> 25:05.340]  нас появилось. Согласны? Вот. Это первый вариант, что у нас появилось обратное ребро в данной вершине В.
[25:05.340 --> 25:12.860]  Значит, я могу попробовать подняться по нему. И я смотрю время входа вот в эту вершину и делаю
[25:12.860 --> 25:21.380]  минимум из таймапа В из таймина У. То есть, в ту вершину, в которую я поднимаюсь. Согласны?
[25:21.380 --> 25:27.820]  Ну, то есть, я вот это обратное ребро, вот оно. Вот первый И отвечает за вот это обратное ребро.
[25:27.820 --> 25:36.300]  Меня пугает. Скажите, что именно непонятно. Давайте так.
[25:36.300 --> 25:44.300]  Тайм? Ну, типа.
[25:54.300 --> 26:00.660]  Сейчас, смотрите, нам нужно найти минимум из трех чиселок. Первоначально... Давайте,
[26:00.660 --> 26:13.660]  хорошо. Я захожу ДФС в вершину В. Да? Захожу, не знаю там, время пять. Я говорю, пусть у меня
[26:13.660 --> 26:19.700]  таймап сначала равен пяти. Ну, я остаюсь просто на месте. Это первый вариант, который возможен.
[26:19.700 --> 26:26.460]  Правильно? После этого я смотрю вот с помощью того ИФА, который здесь есть, что мы нашли серую
[26:26.460 --> 26:33.300]  вершину. Если мы нашли серую вершину, то мы пришли куда-то наверх, по нашему дереву. Значит,
[26:33.300 --> 26:46.860]  это обратное ребро. Вот оно. К некоторой вершине У. У является предком В? Да. Хорошо. А теперь вопрос.
[26:46.860 --> 26:58.660]  Значит, таймин ВУ какой? Меньше. Ну, предположим, два. Теперь, смотрите, я могу остаться на месте с пятеркой,
[26:58.660 --> 27:14.860]  а могу подняться до двойки. Ну, естественно, я выберу двойку. А, в смысле, почему там минимум написан?
[27:14.860 --> 27:27.860]  В ребенка зайти невозможно. У нас серой вершины такой не будет. Такой не будет. Я понял вопрос. Все,
[27:27.860 --> 27:36.660]  теперь я понял вопрос. Можно. Вот. А дальше, что мы смотрим? Мы смотрим на все белые наши вершинки.
[27:36.660 --> 27:43.420]  Ну, то есть, вот этот случай разобрал. Теперь, если я смотрю на белые, то они являются нашими
[27:43.420 --> 27:54.300]  предками. Ой, потомками. Извиняюсь. Теперь все вершины вот в этом эфе, где их равно там white,
[27:54.300 --> 28:19.100]  это вот это. Можно написать. У предка всегда таймин меньше. Мы не можем пойти в ребенка. Мы уже
[28:19.100 --> 28:28.140]  прошли эту вершину. Она серая. Серая вершина не может быть ребенком в нашем графе. Из серой вершины
[28:28.140 --> 28:40.020]  в белую мы пришли, а потом из этой же вершины вернулись обратно. Знаем. Она не может быть
[28:40.020 --> 28:47.140]  серая. Смотрите, если бы это было ребенком с точки зрения дерева обхода, тогда в этом случае вот это
[28:47.140 --> 28:54.140]  было бы белым. А мы пришли в серую. В серую вершину нельзя прийти, когда это ребенок.
[28:54.140 --> 29:03.700]  Серая вершина в таких графах означает вот это. Потому что мы сначала отсюда пришли, потом сюда,
[29:03.700 --> 29:20.140]  потом сюда, и вот вернулись в серую. В двух разных предках, конечно. Все правильно. Можно и так. Я бы
[29:20.140 --> 29:27.460]  просто ждал, когда у вас будет косяк в этом, а в контесте, если бы был. Минимум, да, действительно
[29:27.460 --> 29:42.460]  необходим будет. Это правильное замечание. Теперь стало понятнее. Чудно. Хорошо. Ну, смотрите,
[29:42.460 --> 29:47.900]  мы можем уже прийти в вершину У, которая 2, можем прийти в вершину У, в которой будет время входа 3.
[29:47.900 --> 30:08.340]  Минимум из них нужно взять. Я хочу подниматься выше и выше. Нет, почему? Я ж таймап складываю
[30:08.340 --> 30:21.660]  минимум. Да, у нас в таймапе всегда складываются таймын, таймын, таймын, таймын. Окей, хорошо.
[30:21.660 --> 30:31.140]  Поехали дальше. Если мы приходим в белый вершинкин, то что в этом случае происходит? Вот они
[30:31.140 --> 30:49.540]  детьми стали, правильно? Это куда мы можем прийти, да? Да. А У это откуда мы можем прийти из В?
[30:49.540 --> 31:09.980]  С минимумом. Хорошо. Поехали дальше. Пришли в белые вершины. Будем считать количество детей. Зачем?
[31:20.540 --> 31:33.940]  Для корня мы будем считать. Для корня. У нас же с корнем какой вопрос? Сколько у него детей? Вот и все. То есть
[31:33.940 --> 31:40.140]  если мы пришли в белую вершину, то у нас плюс один ребенок. Если их будет хотя бы два, то в этом
[31:40.140 --> 31:46.700]  случае будет беда. Но будет точка сочленения. Согласны? Вот. Я только для этого считаю детей.
[31:46.700 --> 31:58.500]  Дальше я прихожу в белую вершину и что я делаю? Я запускаю DFS дальше. Ага. Запускаю DFS. Что в этом
[31:58.500 --> 32:04.380]  случае происходит? Происходит следующее, что я все обратные ребра просматриваю опять. Правильно? У
[32:04.380 --> 32:12.940]  детей. У. Согласны? Все обратные ребра опять будут рассмотрены, потому что он будет рассматривать это
[32:12.940 --> 32:20.820]  ифы в серых. Окей. Если мы все просмотрели, то в этом случае, когда я вернусь к вершине У, что у меня
[32:20.820 --> 32:38.300]  будет? Согласны, что в вершине У у меня будет нужный мне почти таймап? Или нет? У является сыном В. Вот. То
[32:38.300 --> 32:48.420]  есть мы обработали всех детей и сделали там необходимый нам таймап. Согласны? Вот. Хорошо. Мы
[32:48.420 --> 32:56.860]  посчитали. Для У. То есть мы запустили DFS для У и вот этот DFS все посчитал там. То есть он отошел от
[32:56.860 --> 33:02.860]  детей, потом зашел от детей-детей и так далее. Потом вернулся обратно. Рекурсивно мы посчитали
[33:02.860 --> 33:11.140]  этот таймап. Чудненько. И тогда в этом случае, что я могу сказать? Давайте я посмотрю, а может быть из
[33:11.140 --> 33:20.780]  моих детей я вообще вот пришел здесь в нулевую вершину. Согласны? И вот, к примеру, У. Было там 6,
[33:20.780 --> 33:31.100]  ноль. То есть он мог еще выше пойти. Тогда в этом случае я сверяю, какой у меня здесь таймап, а
[33:31.100 --> 33:39.220]  какой здесь. То есть вот в этом случае я как раз разбираю случаи, когда через детей поднялся вверх.
[33:39.220 --> 34:06.460]  Поэтому тут 2 заменится на ноль. Понятно? По сути свои все. Да. Все. G, U и false. False означает,
[34:06.460 --> 34:19.700]  что это не корень. Так. Это будет самый первый. Самый первый вызов, который вы сделаете там,
[34:19.700 --> 34:34.540]  это будет DFS. Visit. От графа G в вершине там, не знаю, ноль. И это корень. У вас только одно будет
[34:34.540 --> 34:47.020]  вызов корня. Самое первое, которое вы вызовете сами. Что? Потому что каждый ребенок не является
[34:47.020 --> 35:00.700]  корнем. У вас здесь корнем одна вершина. Да. Подождите еще раз. Когда я запускаюсь от любой вершины,
[35:00.700 --> 35:07.500]  она становится корнем, а все остальное является деревом DFS. И не является корнем.
[35:07.500 --> 35:35.900]  Так. Почему это точка слиния? Вот. У корня по определению не может быть обратных
[35:35.900 --> 35:46.740]  ребер. Поэтому корень рассматривается отдельно. У корня в принципе нет обратных ребер. Ему
[35:46.740 --> 35:52.180]  некуда выше идти. Он самый первый. Вот. Все остальное может, естественно, выше идти. Поэтому,
[35:52.180 --> 36:04.940]  как бы, если 3 есть сына, это не означает, что это точка слиния. Нет. Еще вопросы. Понятен ли
[36:04.940 --> 36:25.980]  код написан здесь? Почему? Правильно.
[36:34.940 --> 36:47.780]  Ну, смотрите. Еще раз. Вот то, что здесь написано, это является таким полу-псевдокодом раз. Во-вторых,
[36:47.780 --> 36:54.140]  а то, что здесь написано, вы можете использовать каким образом? Вам с точки зрения ООП не нужно
[36:54.140 --> 36:59.180]  вот типа DFS Visit прям запускать, потому что название очень странное будет. Вам нужно поиск,
[36:59.180 --> 37:04.620]  вам нужно вернуть вектор вообще по-хорошему. Правильно. Фактически вам нужно просто вот эту
[37:04.620 --> 37:12.380]  часть выкинуть отдельно. И все. Вот. Которая внутри сама запустит DFS от нулевой вершины,
[37:12.380 --> 37:20.140]  все такое. Конечно. Это написана сама сутьевая часть. Как вы сделаете, это другой вопросик.
[37:21.140 --> 37:41.500]  Еще есть вопросы. Все понятно? Хорошо. Мосты. Что такое мост? Да. Ну, то есть точка слиния – это
[37:41.500 --> 37:47.420]  просто убрать точку, а вершину какой-то мосты – это убрать ребро. И тогда у вас увеличиваются
[37:47.420 --> 37:53.580]  компоненты связанности. Критерий моста какой? Критерий моста примерно следующий. Пусть мы
[37:53.580 --> 38:02.260]  запустили все также DFS. Ребро какое-то является мостом, если у нас вот это вот ребро ВУ и В-родитель
[38:02.260 --> 38:08.180]  У в дереве обхода, и из У нельзя подняться выше. Ну, то есть подразумевается примерно то же самое,
[38:08.180 --> 38:17.460]  что здесь ток не с точками, ток не с вершинами. То есть подразумевается следующее, что у нас
[38:21.300 --> 38:30.980]  ребро оно не будет мостом в случае, если мы можем подняться просто выше. Из нашего
[38:30.980 --> 38:40.420]  ребенка. То есть есть вот такое какое-нибудь обратное ребро. Вот. Ну, то есть ребро именно двигаясь
[38:40.420 --> 38:47.380]  по детям еще можно, и можно вот по детям обратно еще двигаться. Если вдруг мы можем подняться выше,
[38:47.380 --> 38:52.780]  то в этом случае это будет мостом. То есть если так нельзя делать, то это будет мостом. Если так можно,
[38:52.780 --> 38:58.340]  то это не мост. Ну, как бы аналогично тому же, что у нас было, просто главный вопрос, что мы,
[38:58.340 --> 39:03.260]  удаляя вот эту связанность, мы можем все так же прийти как-то в вершину В. Ну, как мы можем это
[39:03.260 --> 39:12.300]  сделать? Ну, ровно так же, типа подняться, да попасть мне. Вот. Это является вот некоторым критерием моста.
[39:12.300 --> 39:19.580]  Хорошо, к мостам. Ну, как бы здесь чуть более формально написано с точки зрения того, как доказать,
[39:19.580 --> 39:24.900]  что это критерий моста. Вот. Относительно того, что если мы не можем подниматься по обратным
[39:24.900 --> 39:30.340]  ребрам, то и в дереве у нас нет обратного вот этого пути. Значит, у нас есть единственный путь
[39:30.340 --> 39:35.220]  через это ребро. А если это путь единственный, который соединяет В.И.У., то в этом случае у нас
[39:35.220 --> 39:42.300]  при разъединении этого ребра, то есть при удалении, мы с вами получим две, две компоненты связанности уже,
[39:42.300 --> 39:50.580]  а не одну. Ну, логика здесь такая же, как бы здесь не очень сложная. Какая разница здесь в
[39:50.580 --> 39:58.500]  точки зрения оточек сочленения? Ну, смотрите. Первое, это отсутствие корня, что нам не важно здесь корень
[39:58.500 --> 40:03.860]  или не корень, потому что, ну, нет, тут корня, нам не важно, у нас ребра только. Вот. И второе, что нам
[40:03.860 --> 40:13.500]  нужно заменить таймин меньше или равно на меньше. Всё. Весь алгоритм готов. Если вы написали хоть
[40:13.500 --> 40:21.100]  что-то, то это уже работает. Вот. Поэтому это выглядит вот так. Ну, то есть мы не проверяем, мы не считаем
[40:21.100 --> 40:26.500]  здесь количество детей, мы убираем условия на корень и, в принципе, всё. И меняем вот этот вот
[40:26.500 --> 40:35.540]  меньше или равно на меньше. Вот. Так что, да, если вдруг у вас есть задача на то или на другое,
[40:35.540 --> 40:46.020]  то решив одну, вы решите, по сути, вторую. На точки сочленения чуть-чуть побольше кода из-за вещей,
[40:46.020 --> 40:53.460]  которые вы вызываете. Есть ли тут вопросы? Вот. Ну, я думаю, время работы понятно, что время
[40:53.460 --> 41:01.420]  работы это всего DFS, поэтому так. А что важно здесь понимать? Какие вопросы здесь могут быть?
[41:01.420 --> 41:15.140]  Смотрите, неориентированный граф вы всё-таки храните как две ребра. Сюда и сюда. Да? Вот. Важно
[41:15.140 --> 41:20.300]  понимать, что мы не должны смотреть вот в такой же концепции. Мы не можем вернуться по этому ребро
[41:20.300 --> 41:29.500]  обратно, когда вы будете запускать DFS. Поэтому здесь очень аккуратно обсчитывайте всё это. Если
[41:29.620 --> 41:36.540]  вдруг у вас вот это вот есть, а у вас вообще есть мультиграф, то там вообще начинается беда. Нужно
[41:36.540 --> 41:42.940]  понять, как это делать. Это отдельно. На самом деле там с кратными ребрами нужно просто проверять,
[41:42.940 --> 41:50.500]  есть ли кратное ребро или нет. Если да, то всё хорошо. Если нет, то мы работаем как обычно. Всё. Вот.
[41:50.500 --> 41:55.580]  Ну, существует теорема Робинсон. Это последнее, что я должен был бы рассказать вам на прошлой лекции.
[41:55.580 --> 42:02.780]  Поэтому всё хорошо. Звучит оно так, что неориентированный связанный граф можно сильно
[42:02.780 --> 42:09.180]  ориентировать, то есть задать какую-то ориентацию ребер таким вот образом, что у нас граф будет
[42:09.180 --> 42:17.020]  сильно связанным, только лишь в связанном графе, где нет мостов. То есть, если у вас есть какой-то
[42:17.020 --> 42:24.020]  неориентированный граф, вы можете сделать какую-то ориентацию, определенную такую, что у вас граф
[42:24.020 --> 42:29.540]  будет ориентирован сильно связан и у вас не должно быть для этого мостов. Если вдруг они есть,
[42:29.540 --> 42:40.820]  тогда вы не можете сделать такой ориентации. Прикольная теорема. Наверное. Вот. Ну, а как она
[42:40.820 --> 42:46.820]  доказывается? Ну, в одну сторону. То есть, когда мы можем сильно ориентировать наш граф, мы говорим,
[42:46.820 --> 42:54.820]  что пусть не так, пусть у нас есть какой-то мост. Ориентируем сильно наш весь граф. Предположим,
[42:54.820 --> 42:59.860]  что у нас есть это ребро, которое является мостом. Если я его удалю, то в этом случае у нас компонент
[42:59.860 --> 43:07.700]  сильно связанности увеличится. А что означает сильная связанность? Что мы можем и в одну
[43:07.700 --> 43:14.260]  сторону идти, и в другую сторону идти. То есть, у нас была вершина, то есть, было ребро какое-нибудь
[43:14.260 --> 43:22.500]  в У. Вот я его сильно ориентировал сюда. Когда я сильно ориентировал, это означает, что из вершины В
[43:22.500 --> 43:30.780]  я могу попасть в У, из вершины У я могу попасть в В. Но если это было мостом, то я удалю, и у меня
[43:30.780 --> 43:38.540]  никакого обратного пути нет. Значит, я не мог сильно ориентировать этот граф. Вот, поэтому здесь у нас
[43:38.540 --> 43:46.980]  как бы противоречие. Чудесно. Теперь, смотрите, в обратную сторону. Давайте мы, у нас нет мостов,
[43:46.980 --> 43:53.820]  у нас связанный граф, там нет мостов, все чудесно. Как мы можем предложить эту ориентацию? Ну, давайте
[43:53.820 --> 44:00.060]  ориентироваем все ребра согласно обходу в ДФС. Из любой вершины можно подняться из нее самой
[44:00.060 --> 44:09.660]  куда-нибудь выше. Все отлично, я могу ходить по предкам. Вот, это является теоремой Робинсона.
[44:09.660 --> 44:22.740]  Ну, смотрите, подразумевается, что у вас есть вот такой неориентированный граф, у вас там есть вот
[44:22.740 --> 44:26.780]  такое неориентированное ребро. Когда вы ориентируете его, вы либо в одну сторону
[44:26.780 --> 44:43.780]  смотреть, либо в другую. Вот, там другого варианта нет. Да. Смотри, мы поднимаемся из любой вершины
[44:43.780 --> 44:50.860]  выше нее самой, потом еще раз из нее выше любой какой ты хочешь, потом еще и еще, и мы доходим до
[44:50.860 --> 45:03.300]  корня, до которого, у которого нет возможности подняться еще выше. Вот. Хорошо, ладно. Хорошо.
[45:03.300 --> 45:15.500]  Из корня нельзя. Вот. Есть ли еще вопросы? Все понятно? Теперь вы сможете ответить про мосты
[45:16.460 --> 45:24.780]  если вас ночью разбудит. Расскажите. Грустно. Ну ладно.
[45:24.780 --> 45:42.700]  Ладно. Хорошо, принято. Смотрите, есть вторая тема, а я какой предлагаю механизм. Предлагаю,
[45:42.700 --> 45:49.340]  мы сейчас будем говорить про нее. У нас, благо, есть время. Вот. Возможно, мы чуточку задержимся.
[45:49.340 --> 45:55.260]  Если у нас останется алгоритм один, то я его перенесу на следующую лекцию. Хорошо? Это будет
[45:55.260 --> 46:05.540]  алгоритм Барувки. Вот. С ним чуть-чуть попозже. Ну, я надеюсь, что зависит от того, как вы будете
[46:05.540 --> 46:15.460]  слушать. Вот. Ну, посмотрим. Хотя бы один алгоритм мы с вами сегодня разберем. Вот. И с ним мы с
[46:15.460 --> 46:25.980]  вами поработаем. Кто из вас что-нибудь слышал про минимальные остовные деревья? А? Все у вас уже
[46:25.980 --> 46:46.500]  было на семинарах? На ЛКТГ? Подождите. У вас было это на ЛКТГ? Было? Что такое остовное дерево?
[46:46.500 --> 47:02.260]  Ну, хорошо. Окей. А вы на ЛКТГ алгоритмы какие-то проходите еще? Или просто типа приколы, приколы
[47:02.260 --> 47:10.020]  деревьев, назовем это так? Приколы графов? Все, принято. Ладно, хорошо. Давайте поговорим,
[47:10.020 --> 47:14.660]  что такое остовные деревья. Тогда кратко скажу. Если у нас есть какой-то неориентированный граф,
[47:14.660 --> 47:23.980]  и у нас есть... и вот остовным деревом, грубо говоря, называется такой подграф,
[47:23.980 --> 47:29.860]  который содержит все вершины из нашего изначального графа, и оно вот все связано
[47:29.860 --> 47:39.180]  будет между собой. Должно быть. Вот. То есть вот этот граф остается все таким же... то есть такая
[47:39.180 --> 47:43.180]  транспортная сеть, грубо говоря, где вы можете откуда угодно, докуда угодно все также добраться,
[47:44.140 --> 47:49.660]  учитывая, что у вас граф неориентированный. Но если вдруг нет, то в этом случае вы уже не можете
[47:49.660 --> 47:58.660]  этого сделать. Вот. Что такое минимальное остовное дерево? Вот смотрите, это остовный подграф,
[47:58.660 --> 48:06.020]  все еще, который у вас есть, но он должен иметь наименьший вес, суммарный, учитывая,
[48:06.020 --> 48:11.140]  что у нас каждое ребро имел какой-то вес. То есть вот вы хотите сделать такую минимальную
[48:11.140 --> 48:16.340]  связанность вот всего, что у вас есть, для того чтобы, ну не знаю, дороги меньше вклась, там еще
[48:16.340 --> 48:23.140]  что-нибудь. Как хотите можете это делать. Вот. Здесь нарисован граф, и вот зелененьким выделен
[48:23.140 --> 48:29.100]  минимальный остовный граф. Просто остовный граф не минимальный, а минимальный выглядит чуть-чуть
[48:29.100 --> 48:37.860]  по-другому. Вот. А что еще нам понадобится? МСТ это как раз-таки минимальное остовное дерево. Вот.
[48:37.860 --> 48:51.460]  Нам понадобится определение безопасного ребра. Что такое безопасное ребро? Ребро ВУ называется
[48:51.460 --> 48:57.860]  безопасным, если при его добавлении в наш граф же штрих, который вот мы используем как остовное
[48:57.860 --> 49:05.260]  дерево, он остается под графом некоторого, возможно другого минимального остовного дерева графа.
[49:05.260 --> 49:14.700]  То есть безопасное ребро это то, которое мы добавили, вот ничего не произошло. Вот. И оно
[49:14.700 --> 49:22.140]  все также осталось миностовым. То есть мы вот выбрали вот определенные вершинки. И все. Вот.
[49:22.140 --> 49:32.380]  А что такое минимальный остов? Ну смотрите, мы просто возьмем, какой план здесь капкан? То есть мы
[49:32.380 --> 49:37.180]  можем добавлять вот эти вот безопасные ребра и тогда у нас все будет хорошо. У нас все также
[49:37.180 --> 49:42.460]  минимально сохраняется и так далее. Подразумевается, все поняли, что такое безопасное ребро? Хорошо.
[49:42.460 --> 49:51.780]  Понял. Тогда смотрите. У нас есть некоторый граф. Мы предположим, что у нас вот пока что у нас есть
[49:51.780 --> 49:58.140]  только вот это ребро. Что такое? И предположим, что у меня есть еще вот такое, вот такое ребро,
[49:58.140 --> 50:04.740]  вот такое, вот такое какое-нибудь ребро. Что такое безопасное ребро? Безопасным ребром называется
[50:04.740 --> 50:09.820]  какое-нибудь ребро, которое будет нас связывать новые какие-нибудь ребра между собой. Ну новые
[50:09.820 --> 50:15.180]  вершины точнее. И оно будет все также под графом минимального остовного дерева. То есть вот это
[50:15.180 --> 50:22.100]  является под графом миностового. Я беру, добавляю новое и вот эти уже три вершины тоже являются под
[50:22.100 --> 50:33.620]  графом миностового. Минимальное остовное дерево. Понятно? Потом это такое. Вот это ребро,
[50:33.620 --> 50:38.660]  если я добавлю, оно уже не будет под графом миностового. Согласны? Он только увеличит стоимость.
[50:38.660 --> 50:51.900]  Нет, все разные. Ну я просто предполагаю. Хотите, напишу веса. Три, два, десять.
[50:51.900 --> 51:20.380]  Какое-то ребро не возьмет. Вот это не войдет, например. Ну смотрите, я предполагаю, что войдет. Вот
[51:20.420 --> 51:23.940]  когда я его начертил, я предполагал, что он войдет. Я написал вам такие чиселки, что оно войдет.
[51:23.940 --> 51:31.740]  Сейчас я написал вам такие чиселки, которые войдут. Я потому что, ну как бы с пустого начинать не самое
[51:31.740 --> 51:46.500]  прикольное. Под граф связанным, вот в смысле вот этот кусок. Хороший вопрос. А как ты думаешь? Нет.
[51:46.500 --> 51:58.180]  Смотрите, давайте еще раз вернем к безопасным ребрам. Что это такое? Вот у нас есть некоторый
[51:58.180 --> 52:09.980]  ж-штрих. Он является под графом некоторого ж. Ну то есть вот ж-штрих, а что это само по себе? Ну вот у
[52:09.980 --> 52:18.260]  нас есть какой-то под граф минимального основного дерева. Вот безопасным ребром будет называться то,
[52:18.260 --> 52:27.020]  что если мы добавим в этот ж-штрих это ребро, то он все также останется под графом некоторого
[52:27.020 --> 52:39.820]  минимального основного дерева. Да. Конечно. Ну представь, я возьму и сделаю все одинаковые
[52:40.300 --> 52:54.260]  веса. Я могу связывать их хоть как. То есть я могу, ну предположим, что все единичка. Я могу связать вот
[52:54.260 --> 53:04.380]  так. Правильно? Я могу связать вот так. Я могу связать вот так. Вот. Мне же никто не говорит,
[53:04.380 --> 53:15.700]  что у нас уникальные какие-то значения есть. Принято? Принято. Окей. Добавим еще пару определений.
[53:15.700 --> 53:27.820]  Добавим еще пару определений. Первое. Что такое разрез графа? Ну разрез графа это просто разрезать
[53:27.820 --> 53:32.980]  граф на два непересекающихся множество вершин. Там слева одни вершины, справа другие вершины.
[53:32.980 --> 53:41.300]  Ага. Что такое ребро пересекает некоторый разрез? Ну вот смотрите, вот это разрез,
[53:41.300 --> 53:53.380]  это разрез S и U. Все правильно. Вот. S и U это кусочки моего разреза. Согласны? Ну то есть они не
[53:53.380 --> 54:04.500]  пересекаются. Окей? Окей. А что такое ребро пересекает мой разрез? Ну то есть оно связывает одну
[54:04.500 --> 54:12.620]  вершину из одного множества в вершину другого множества. Окей? Ну вот. Вот это вот является
[54:12.620 --> 54:24.980]  пересечением моего разреза. Пока просто из определений. Правда? Хорошо. Тогда что такое лемма
[54:24.980 --> 54:32.780]  о безопасном ребре? Смотрите. Пусть G штрих это подграф некоторого минимального основного дерева T,
[54:32.780 --> 54:43.300]  графа G. А S и U является разрезом моего графа. Вот это вот подграф как раз таки. А такой,
[54:43.300 --> 54:47.780]  что же штрих не пересекает этот разрез? Ну вот согласны, что он лежит полностью внутри этого
[54:47.780 --> 54:54.460]  разреза? Просто там вот внутри как-то есть и есть. Отлично. Тогда ребро минимального веса среди
[54:54.460 --> 55:04.980]  пересекающих разрез, вот это 6 или 7, является безопасным то, у которого будет вес меньше. То
[55:04.980 --> 55:10.020]  есть если я из этого разреза возьму и добавлю вот это ребро 6, тогда у меня минус 100 получится.
[55:10.020 --> 55:23.820]  Если я добавлю 7, минус 100 не получится. Мы сейчас говорим о безопасном ребре. Мы подходим к одному
[55:23.820 --> 55:32.460]  алгоритму, который это будет использовать. Другой алгоритм использовать не будет. Нет. Мы пока
[55:32.460 --> 55:38.620]  работаем с первым. Первый будет использовать безопасные ребра, которые будут связывать здесь. И мы
[55:38.620 --> 55:45.540]  говорим, что безопасное ребро будет то, которое вот в этом есть. Безопасных ребер может быть
[55:45.540 --> 55:56.700]  несколько. Я утверждаю, что среди вот этих ребер, которые пересекают данный разрез, есть
[55:56.700 --> 56:03.180]  безопасное ребро. И это безопасное ребро, оно имеет минимальный вес. Может быть тут внутри есть
[56:03.180 --> 56:23.660]  еще одно ребро. Окей? Окей. Как доказать? Ну, по сути своей почти что да. Если у нас есть несколько
[56:23.660 --> 56:29.660]  вот этих вот ребер, мы предположим, что есть это минимальное ребро, которое есть. Рассмотрим путь
[56:29.660 --> 56:39.940]  какой-то вершины, вот из этих минимальных, из В в У, в нашем дереве. Вот. Он пересечет разрез
[56:39.940 --> 56:46.460]  по некоторому ребру, пусть Е штрих. Ну, то есть пусть не так, пусть это небезопасное ребро. Вот.
[56:46.460 --> 56:54.860]  Пусть оно пересечет по некоторому Е штрих. Окей. Вот. А если мы заменим Е на Е штрих,
[56:54.860 --> 57:03.500]  в случае, если у меня вес Е штрих меньше, тогда в этом случае связанность любая сохраняется. Вот.
[57:03.500 --> 57:09.660]  Ну, как бы все в принципе звучит хорошо. Но само по себе это будет означать что? Это будет
[57:09.660 --> 57:14.900]  означать следующее, что у нас есть одно ребро, есть другое ребро, которое соединяет две вот этих
[57:14.900 --> 57:22.460]  вот половинки между собой. Вот. И в то же время путь вот отсюда, грубо говоря, сюда и вот отсюда,
[57:22.780 --> 57:29.740]  а он переходит по этим ребрам. Поэтому их вес должен быть одинаковый. Если вдруг он окажется выше,
[57:29.740 --> 57:35.380]  то в этом случае у нас проблемы. А если мы выбрали ребро Е, вот какое-то ребро Е,
[57:35.380 --> 57:40.780]  мы уже выбрали вот эту шестерку, грубо говоря, то добавлять ребро, которое стоит больше,
[57:40.780 --> 57:50.940]  бессмысленно. Вот. Потому что оно лежит в миностове. Понятно? Вот. Так что ситуация вот примерно
[57:50.940 --> 57:56.500]  следующая. То есть, если вдруг у вас несколько одинаковых ребер при разрезе, то выбирайте любое.
[57:56.500 --> 58:03.300]  Одно или другое будет являться миностовом. Миностов не единственный. Вот. Это является
[58:03.300 --> 58:10.660]  леммой о безопасном ребре и используется в алгоритме Прима. Как работает алгоритм Прима?
[58:10.660 --> 58:27.220]  Смотрите, что мы делаем. Мы делаем следующее. Пусть у меня есть некоторый граф. Вот. Пусть у меня
[58:27.220 --> 58:44.580]  здесь есть какие-нибудь ребра. Скажите какие-нибудь веса. Пять. Шесть. Два. Девять. Три. Хорошо. Вот
[58:44.580 --> 58:58.580]  такой вот у меня граф есть. Хотите еще вершину добавлю? Хорошо. Какие-нибудь счет-числа? 57?
[58:58.580 --> 59:13.500]  Ты любишь свою школу или что? Пусть будет так. Окей. Смотрите, что здесь делается? Ну, то есть,
[59:13.500 --> 59:22.980]  у всех вершин номера там 0, 1, 2, 3, 4. Чудесно. В начале я говорю, пусть у меня в первом,
[59:22.980 --> 59:34.580]  первое это вот этот разрез S вот здесь, второе это вот здесь. Это U. Вот у меня есть. Я смотрю на
[59:34.580 --> 59:40.100]  минимальные ребра, пересекающие данный разрез. Ну, то есть, согласны, что вершина 0 является под
[59:40.100 --> 59:48.380]  графами на 100. Она одна. Пустая. Вот. Значит, что по лемме о безопасном ребре я могу выбрать
[59:48.380 --> 59:56.900]  минимальное ребро, оно будет лежать в миностове. Согласны? У меня здесь 6, 2, 5. Два. То есть,
[59:56.900 --> 01:00:05.580]  я провожу вот это вот ребро. Неудобно сейчас будет. Ну ладно. Теперь получается моим разрезом S
[01:00:05.580 --> 01:00:16.900]  будет вот это. А 2, 1, 4 это разрез U. Теперь я смотрю, какие вот здесь у меня есть ребра.
[01:00:16.900 --> 01:00:30.940]  Так. Смотрю на эти ребры и смотрю, ага, какое здесь у меня минимальное ребро? Здесь 5, здесь 9,
[01:00:30.940 --> 01:00:40.300]  здесь 3, здесь 57. А нет, здесь еще ничего нет. Это входит. А здесь 179, здесь 6. Ну какое
[01:00:40.300 --> 01:00:59.900]  минимальное? 3. Я вот это делаю. Отлично. Хотя бы так. Чудесно. У меня осталось вот теперь S
[01:00:59.900 --> 01:01:07.980]  входит, вот эти верхние ребра, эти верхние вершины, а в U входит вот эти два, две оставшиеся. У меня
[01:01:07.980 --> 01:01:21.860]  остается 57, 179, 6. Ну 6. Ну и после этого остается здесь, здесь минимальное 57 и 179. Ну 57 выбираю.
[01:01:21.860 --> 01:01:39.780]  И вот так у меня получается мой ми на 100. Понятно? Это тебе не нравится явно. Да, да, да.
[01:01:44.900 --> 01:01:45.500]  Всего.
[01:01:51.860 --> 01:02:00.100]  Что еще раз? Ну смотрите, вот Лема о безопасном ребре говорит, что в этом случае выбирай любое.
[01:02:00.100 --> 01:02:16.820]  Вот. Просто. Звучит просто. Почему? Кто тебе такое сказал? Смотрите, как я могу выбирать минимум?
[01:02:16.820 --> 01:02:35.580]  Не самое приятное. Еще. Еще. А? И что мне это даст?
[01:02:35.580 --> 01:02:46.700]  Чего? Почему бин поиск? Ты же из нулевого ребра можешь, из нулевого в первое, во второе,
[01:02:46.700 --> 01:02:51.900]  в третье, из второго там, в пятое, третье, второе, первое там попасть. Ребра-то разные.
[01:02:51.900 --> 01:03:04.060]  Как я минимум могу искать? Какие есть вещи? Могу просто проходить и искать минимум? Могу? Могу.
[01:03:04.060 --> 01:03:24.860]  А какую еще структуру вы помните, которая минимум хранит в себе и быстро находит?
[01:03:24.860 --> 01:03:37.100]  Фибоначe ву кучe принято. Просто, пирамида тоже принято. Если очень хочется,
[01:03:37.100 --> 01:03:42.140]  можно писать фибоначe ву кучe. В действительности, да, чаще всего вы будете использовать,
[01:03:42.140 --> 01:03:48.420]  это просто пирамиду. Но фибоначe ву кучe тоже можно это делать. А если вы будете
[01:03:48.420 --> 01:03:52.180]  использовать просто пирамиду, то в этом случае у вас время работы будет за Елу-Кве.
[01:03:52.180 --> 01:03:57.220]  если будете использовать ферманачевую кучу, то это будет E плюс V лук V, но есть
[01:03:57.220 --> 01:04:02.540]  интересный нюанс, у нее константа бешенная, вам это будет бесполезно, поэтому
[01:04:02.540 --> 01:04:17.140]  вы будете использовать просто пирамиду. Да, да, да, приорити Q называется, но да, да, да,
[01:04:17.140 --> 01:04:23.620]  по сути это да. То есть, когда вы делаете в приме, что вы делаете? Вы храните просто
[01:04:23.620 --> 01:04:29.700]  некоторый дист, это минимальный вес ребра, ведущий в ту или иную вершину, в данном
[01:04:29.700 --> 01:04:37.540]  разрезе, грубо говоря. Вы говорите, что у вас есть дист, и дист что делает? Он просто хранит
[01:04:37.540 --> 01:04:44.220]  число. Прев это предыдущее минимальное ребро, которое было. И хип, он будет хранить все наши
[01:04:44.220 --> 01:04:50.220]  ребра, то есть все вершины, и вот по сути по ним смотреть, что у нас там есть. То есть дист показывает
[01:04:50.220 --> 01:04:55.460]  у нас как раз какое ребро мы закладываем сюда. То есть, в самом начале, когда у меня пустота,
[01:04:55.460 --> 01:05:01.780]  некоторая пустота, то вершину нулевой я могу попасть бесплатно, а для всех остальных пока
[01:05:01.780 --> 01:05:08.140]  дотянуться не могу, потому что я еще не добавил ее в разрез S, то есть с пустой вначале. Понятно? Вот,
[01:05:08.140 --> 01:05:15.820]  и я храню в своей пирамиде, то есть у меня приоритетом выступает тот самый дист. Окей? Вот,
[01:05:15.820 --> 01:05:23.300]  и я кладу вот типа вот все свои вершинки. В начале я инсерчу типа все, что можно, у меня получается
[01:05:23.300 --> 01:05:30.260]  типа 0, 0, и дальше бесконечность 1, бесконечность 2, бесконечность 3 и так далее. Мне прикольно,
[01:05:30.260 --> 01:05:39.820]  неинтересно. Вот. Что дальше я делаю? Пока у меня хиппани будет пустан, я с вами вытаскиваю минимум,
[01:05:39.820 --> 01:05:44.860]  который там находится, и говорю, что это минимальное, расстояние до него минимально, значит,
[01:05:44.860 --> 01:05:51.540]  в этом случае оно является безопасным ребром. Значит, я могу его использовать, согласны? Вот,
[01:05:51.540 --> 01:05:59.020]  отлично. Я его достаю, кладу себе в корзиночку, говорю, что вот это вот то, что мне нужно.
[01:05:59.020 --> 01:06:06.740]  И смотрю, если у меня предыдущее неравно было, ну оно существует вообще предыдущее, куда я пришел,
[01:06:06.740 --> 01:06:13.300]  то есть начало вот этого минимального ребра, тогда в этом случае я его кладу к себе куда-нибудь. Если
[01:06:13.300 --> 01:06:20.700]  нет, то не кладу. Все просто. Потому что это нулевая вершина, у нее начала все-таки нет. Мы туда просто
[01:06:20.700 --> 01:06:28.540]  зашли. Вот с ноги. Все остальные вершины мы все-таки приходим по ребрам. Вот. А дальше что я делаю?
[01:06:28.540 --> 01:06:34.020]  А дальше я смотрю на всех соседей, то есть вот эту нулевую вершину добавил, смотрю на всех соседей,
[01:06:34.020 --> 01:06:43.740]  все которые есть, и обновляю дисты согласно тем ребрам, которые здесь есть. Ага. И как только я
[01:06:43.740 --> 01:06:51.260]  обновляю дисты, я кладу это опять в свою пирамиду. И говорю, что предыдущий для 2 кинолик, предыдущий
[01:06:51.260 --> 01:06:58.780]  для 3 кинолик, предыдущий для единички кинолик. То есть откуда я пришел в эту вершину. Вот. Кладу
[01:06:58.780 --> 01:07:06.340]  это в пирамиду, обновляю этот дист. Ну и вот здесь вот есть хип Decrease K. Decrease K подразумевает,
[01:07:06.340 --> 01:07:13.500]  что мы уменьшаем наш, ну наше число в этой пирамиде. Фактически, то есть либо я буду искать,
[01:07:13.500 --> 01:07:20.940]  либо я могу просто складывать все в пирамиду. Вот. И в этом случае там и буду поднимать. То есть
[01:07:20.940 --> 01:07:26.500]  всего сколько будет элементов мне там. Е. Согласны? Ну сколько, сколько ребер, столько,
[01:07:26.500 --> 01:07:32.060]  я дистов туда и положу. И могу просто смотреть, дошел я до этой вершины или нет. То есть есть
[01:07:32.060 --> 01:07:49.260]  она у меня или нет. Понятно? Как это работает? Сейчас мне бы его распарсить правильно. Я тебя
[01:07:49.260 --> 01:08:16.300]  перерисую. Ноль. Сейчас. Тут у нас пять. Тут у нас шесть и один. Три, два, девять. Три.
[01:08:19.260 --> 01:08:29.220]  Пятьдесят семь. Семь с девять. Все верно я нарисовал. Давайте смотреть на нашу пирамидку.
[01:08:29.220 --> 01:08:42.980]  Вот Decrease K по факту он уменьшает нашу расстояние, ну он уменьшает наш ключ. А это означает,
[01:08:42.980 --> 01:08:46.060]  что пирамида поднимается. Ну то есть этот элемент поднимается. То есть севтап просто
[01:08:46.060 --> 01:08:51.260]  вызывается от этого элемента. Что у нас происходит в самом начале? В самом начале у меня хранится
[01:08:51.260 --> 01:09:00.620]  ноль-ноль и все остальное у меня хранится как бесконечность один, бесконечность два,
[01:09:00.620 --> 01:09:13.660]  ну и так далее. Окей? Это пирамида, которая у меня в самом начале. А? Ноль, один, два. Нет,
[01:09:13.660 --> 01:09:20.700]  это номера вершин. Расстояние до этих вершин в самом начале оно бесконечное. То есть я нахожусь,
[01:09:20.700 --> 01:09:28.540]  вот представьте, что у меня разрез S пустой, а все остальное U. Первое это расстояние,
[01:09:28.540 --> 01:09:37.860]  второе это вершинка. Дальше у меня что там? Два, бесконечность, три, еще есть четыре.
[01:09:37.860 --> 01:09:50.860]  Согласны? Пирамида в начале так выглядит. Что потом происходит с этой пирамидой? Я вытаскиваю
[01:09:50.860 --> 01:09:59.900]  вот этот нулевой элемент. Вытаскиваю отсюда. Его больше нет. Интересно, что у нас происходит
[01:09:59.900 --> 01:10:07.820]  дальше? Я начинаю обновлять все дисты, которые у меня есть. Вот по всем, кто у меня является
[01:10:07.820 --> 01:10:15.780]  соседом нуля. Ага. Кто у меня является соседом нуля? Вот здесь я два не написал. В один это 6,
[01:10:15.780 --> 01:10:26.260]  здесь это 5, здесь это 2. Правильно? Согласны? Как у меня теперь будет выглядеть пирамида? Когда
[01:10:26.260 --> 01:10:31.740]  я делаю дикриски, я делаю сфитапы. Но после этого она будет корректной. Согласны? Пирамиду мы
[01:10:31.740 --> 01:10:39.940]  восстанавливаем по корректности. Поэтому это будет выглядеть как 2-3, то есть вершина 3. Потом у нас
[01:10:39.940 --> 01:11:01.900]  есть что там? Пять? Да. Где? Ошибка. Три, четыре. Вот так. Ну да. Вот вы построили пирамиду,
[01:11:01.900 --> 01:11:16.500]  но вот этом. Вот построили. Вот чего мы делаем дальше. У нас есть 2-3, у нас есть что там? 5-2,
[01:11:16.500 --> 01:11:30.700]  у нас есть 6-1, и у нас есть еще там бесконечность 4. Согласны? Я ноль достал,
[01:11:30.780 --> 01:11:40.660]  я сделал экстракт. Правильно? У меня получилась такая пирамида. Понятно, откуда она появилась?
[01:11:40.660 --> 01:11:57.020]  Сейчас расскажу. Расстояние в пирамиде делают в следующем образе. Я добавил вот это в S,
[01:11:57.060 --> 01:12:06.540]  и теперь я смотрю всех его соседей и обновляю дисты. Ну вот сколько у меня расстояние по вот этим
[01:12:06.540 --> 01:12:19.740]  вот ребрам. То есть смотрите, я при добавлении новой вершины что могу сделать? Если я добавляю новую
[01:12:19.740 --> 01:12:27.300]  вершину в S, и вот у меня разрез вот здесь вот меняется. Согласны, что если у меня были какие-то
[01:12:27.300 --> 01:12:33.580]  ребра до этого, я их так и не трону. Какое там было число? Там так и осталось. Правильно? И у меня
[01:12:33.580 --> 01:12:43.460]  изменятся только те ребра, которые здесь есть. Правильно? Дист, что показывает? Он расстояние
[01:12:43.460 --> 01:12:50.860]  от S до U в различных вариантах показывает. То есть какие ребра вот эти вот пересекаются?
[01:12:50.860 --> 01:13:20.460]  Вопрос задай. Есть 00? Смотри, я достаю этот 00.
[01:13:20.460 --> 01:13:30.740]  Это относится к вершине 0. Правильно? Отлично. Относится к вершине 0. То есть в моем S появилась
[01:13:30.740 --> 01:13:44.020]  0. В разрезе S появился 0. Конечно, потому что безопасно. Я же сортирую почему? По ребрам.
[01:13:44.020 --> 01:13:51.540]  Это самый первый вариант, самый нулевой. Когда вот я только пришел, у меня только одна вершинка.
[01:13:51.540 --> 01:14:06.220]  Понятно? Хорошо. Теперь у меня вот такой вот разрез S и U. Такой дист. Дист показывает мне,
[01:14:06.220 --> 01:14:22.740]  как я из S попадаю в U. Вот. Я добавил одну лишь вершину. Согласен? В S. Отлично. По каким
[01:14:22.740 --> 01:14:29.500]  ребрам я могу попасть в U? По пятерке, по двойке, по шестерке. Правильно? Тогда по ним я попаду
[01:14:29.500 --> 01:14:42.420]  вершину 2, 3 и 1. Правильно? Вот. Поэтому теперь я обновляю у двойки, единички и тройки вот эти
[01:14:42.420 --> 01:14:57.540]  расстояния. Как это сделать в коде? Ну смотри, я могу обратиться к какому-то элементу своей хипы.
[01:14:57.540 --> 01:15:07.220]  Вот. А вообще существует такая вещь, как декризки. В приоритете Q вы можете обратиться к конкретному
[01:15:07.220 --> 01:15:12.980]  элементу и сделать там декриз к ключа. Вот здесь ключ значение. Вот вы можете декризы делать сами
[01:15:12.980 --> 01:15:21.620]  по себе. Но. Но. Здесь важное но. В действительности вы будете делать, почти наверно, просто строить
[01:15:21.620 --> 01:15:28.700]  огромную хипу, которая будет E элементов. И просто ее перебирать. Это на самом деле никак не
[01:15:28.700 --> 01:15:35.300]  влияет симпатически. То есть, грубо говоря, вы получите не вот это, а я буду добавлять новые туда
[01:15:35.300 --> 01:15:41.860]  вершины. Но в хипу же можно добавлять элементы. Согласен? Тогда в этом случае у меня появится
[01:15:41.860 --> 01:16:03.380]  здесь два три пять два шесть один бесконечность ну там скорее всего бесконечность три да бесконечность
[01:16:03.380 --> 01:16:15.540]  четыре бесконечность два. Добавил или нет? Пара просто. Согласен? Ноль-ноль удалили. Да. Это точно.
[01:16:15.540 --> 01:16:21.300]  А? Согласен.
[01:16:31.300 --> 01:16:39.100]  Скорее вот так оно сделает. Ну суть такая же. Правильно? Как будет выглядеть пирамидка? Ну,
[01:16:39.100 --> 01:16:43.780]  около того. Давайте она правильно хотя бы сформирована. Я просто сейчас иначе добавлять
[01:16:43.780 --> 01:16:51.020]  элемент конец поднимать и так далее. Это будет долго. Получил такую корректную пирамию. Дальше я
[01:16:51.020 --> 01:17:00.820]  смотрю опять на топ. Это какой элемент? Три? Правильно? Вот. А тогда в этом случае я провожу
[01:17:00.820 --> 01:17:13.420]  свое ребро. Вот это. Которое мы проводили. И удаляю тройку отсюда. И обновляю все дисты.
[01:17:13.420 --> 01:17:22.060]  Каким образом? Ну как я могу из тройки попасть вот сюда? Согласен? То есть вот эти ребра вот одно
[01:17:22.060 --> 01:17:30.220]  ребро вот это, одно ребро вот это еще. Потому что из нуля, ну смотри, я провел одно ребро.
[01:17:30.220 --> 01:17:40.020]  Согласен ли ты, что вот все остальные ребра и 6 и 5 остались на месте? Ничего не изменилось. Ну вот.
[01:17:40.020 --> 01:18:01.860]  Давай. Десятка. Десятка. Теперь смотри, что у меня будет хипех хранится. Что очень размашисто
[01:18:01.860 --> 01:18:10.420]  пишу сегодня. Давайте прим сегодня. А дальше, значит мне нужно от вас будет время, когда вы
[01:18:10.420 --> 01:18:21.020]  хотите послушать про другие. Смотрите. У меня вот такая пирамида и я добавляю новые. Новые
[01:18:21.020 --> 01:18:34.620]  элементы какие? У меня 10-2 и что там? И 179-4, правильно? Здесь у меня 5-2, 6-1 и там еще будет 10-2. Значит
[01:18:34.620 --> 01:18:44.540]  у меня на топе моей пирамиды будет 5-2. Согласен? У меня какие элементы могут быть? Смотри,
[01:18:44.540 --> 01:19:00.100]  предыдущие вот эти все. Плюс я должен добавить сюда 10-2 и плюс добавить еще 179-4. Согласен? Вот я
[01:19:00.100 --> 01:19:14.820]  смотрю на все эти элементы. Что у меня сверху будет? А? 5-2. 5-2. После этого идут уже другие
[01:19:14.820 --> 01:19:33.700]  элементы. Кто у нас там меньше? Ну тут 6-1, 10-2. Согласен? Вот. И там вот все еще. Ну, короче,
[01:19:33.700 --> 01:19:39.980]  я нарисую опять корректную пирамиду само по себе. Вот. Но, возможно, без некоторых нюансов.
[01:19:39.980 --> 01:19:54.100]  Получается, что у нас там 179-4, бесконечность 1, бесконечность 3, бесконечность 2,
[01:19:54.100 --> 01:20:06.220]  ну и бесконечность 4. Ничего не забыл? На самом деле, ни зачем. Но если вы будете
[01:20:06.220 --> 01:20:13.060]  использовать Decrease Key, то полезно. Чтобы было у чего убирать. То есть как-то менять.
[01:20:13.060 --> 01:20:29.100]  А? Decrease Key умеет изменять ключ. Я просто пошел оттуда, вам не понравилось вот так. Я такой,
[01:20:29.100 --> 01:20:33.420]  ну ладно, я буду добавлять тогда элементы. Тогда в этом случае не нужны бесконечности. Это правда.
[01:20:33.420 --> 01:20:55.500]  Да. Да. Так вот. Что отсюда дальше пойдет? 5-2. Согласен? Поэтому здесь появится вот это ребро.
[01:20:55.620 --> 01:21:07.740]  Ну и аналогично дальше. Что важно здесь только понимать. Когда я начинаю вот таким вот образом
[01:21:07.740 --> 01:21:13.980]  строить пирамиду, то у меня элементы могут повторяться. И надо просто проверять,
[01:21:13.980 --> 01:21:21.740]  что я эти элементы не брал уже. Если я брал, тогда бессмысленно их трогать. Поэтому вот это 10-2
[01:21:21.740 --> 01:21:33.740]  никогда и больше не исполнится. Понятно? Зачем? Вы же можете вот преф, вот у вас преф показывает,
[01:21:33.740 --> 01:21:40.380]  пришли вы туда в эту вершину или нет. Можете просто хранить типа, не знаю, визит. Были там в этой вершине
[01:21:40.380 --> 01:21:51.700]  или нет. Понятно? Потому что тогда вы добавите какое-то лишнее ребро. То есть если я 10-2,
[01:21:51.740 --> 01:21:57.580]  добавлю, у меня получится вот это ребро. Зачем оно мне в миностове? Нет, то что оно будет в пирамиде валяться
[01:21:57.580 --> 01:22:03.940]  ничем. Просто у вас пирамида чуть больше будет. Так у меня пирамида за логарифм от N, за логарифм
[01:22:03.940 --> 01:22:11.580]  от V. Правильно? А там будет за логарифм от E. Ну E всегда пропорционально максимум на V квадрат.
[01:22:11.580 --> 01:22:19.740]  Но это два логарифма E. Ну то есть с точки зрения симптотики это ничего не изменит. Понятно? Вот.
[01:22:19.740 --> 01:22:24.740]  Ну и представьте, что я каждое ребро прохожу и добавляю новые сюда вершинки. Я сколько раз
[01:22:24.740 --> 01:22:33.540]  делаю экстракт? E раз. Сколько у меня пирамид всего? Лог E. Получается E лог E, но можно сократить
[01:22:33.540 --> 01:22:42.340]  до E лог V. Потому что E не бывает больше V квадрат. Понятно? Откуда получилась симптотика такая?
[01:22:42.340 --> 01:22:49.900]  Ну с фибоначевой пирамидой, ну, аналогично происходит. Вот просто аналогично, просто это
[01:22:49.900 --> 01:22:59.180]  фибоначева пирамида. Поэтому там E плюс V лог V. Понятно про приму? Вот. Что важно понимать? Важно
[01:22:59.180 --> 01:23:07.060]  понимать, что можно искать минимум просто, ну как бы наивно. Если мы ищем с вами наивно,
[01:23:07.060 --> 01:23:14.580]  тогда в этом случае мы с вами получаем что? А если мы ищем наивно, тогда мы проходимся просто
[01:23:14.580 --> 01:23:20.500]  по всем дистам и смотрим типа минимальный оттуда элемент. Дистов сколько? V, согласны? И я это
[01:23:20.500 --> 01:23:26.460]  повторяю сколько раз? V раз. Ну я потому что V вершин максимум добавлю своими на 100. Согласны?
[01:23:26.460 --> 01:23:32.740]  Обновлять дисты я суммарно сколько раз буду? E раз, потому что я по всем ребрам пройдусь. Согласны?
[01:23:32.740 --> 01:23:46.380]  Согласны, надеюсь. Нет, не совсем. Не всегда. Ну да, по сути своей, да, хорошо, то есть E
[01:23:46.380 --> 01:23:51.780]  пропорционально либо V, либо V квадрат. Да, так можно, но тут будет E плюс V, так E плюс V квадрат,
[01:23:51.780 --> 01:23:58.500]  так правильнее писать в этом плане. Так вот, очень важно, смотрите, заметьте, здесь когда мы делаем
[01:23:58.500 --> 01:24:09.180]  просто вот прямо за E плюс V квадрат, бывают ли случаи, когда это работает быстрее? Вот придумайте
[01:24:09.180 --> 01:24:25.980]  случаи, когда реализация с массивом лучше. До сколько работает алгоритм с хиппой? E лог V, а здесь
[01:24:25.980 --> 01:24:45.860]  E плюс V квадрат. В каком случае массив лучше? Я про асимптотику.
[01:24:45.860 --> 01:25:03.060]  Когда у нас E пропорционально V квадрату? Когда у нас E, почти полный граф, ну грубо говоря,
[01:25:03.060 --> 01:25:09.100]  пропорциональный там V квадрат, в этом случае сложность, приму, за сколько? Вот с массивом.
[01:25:09.100 --> 01:25:21.340]  За V квадрат, правильно? За V квадрат. А в этом случае за сколько? За V квадрат лог V. Да. Поэтому
[01:25:21.340 --> 01:25:28.180]  запомните, не всегда то, что сложнее, лучше. И если вдруг вы увидите почти полный граф, то в этом
[01:25:28.180 --> 01:25:36.140]  случае искать минимум лучше просто в открытую, просто с помощью дистов, по всему дисту проходится
[01:25:36.140 --> 01:25:48.500]  каждый раз и все. Понятно? Ну и там обновлять дисты гораздо проще и понятнее. Ок? Чему E лог V? Смотрите,
[01:25:48.500 --> 01:26:02.380]  сколько раз будет работать вот этот фор VU и соседи V? Ну нет, оно будет работать, сколько у
[01:26:02.380 --> 01:26:09.780]  нас соседей, правильно? Ну то есть вот этот фор пройдется по всем соседям V. То есть это все
[01:26:09.780 --> 01:26:18.220]  ребра, которые у меня есть из V. Согласен? Согласен. В VU я пройдусь почему? По всем ли
[01:26:18.220 --> 01:26:24.340]  вершинам я пройдусь? А теперь смотри, я прошелся по всем вершинам, а внутри я прохожусь по всем
[01:26:24.340 --> 01:26:34.060]  ребрам из этих вершин. Сколько это всего ребер? Это все ребра моего графа. Правильно? Получается так.
[01:26:34.060 --> 01:26:45.420]  Получается это E. Я это делаю E раз. А минимум нахожу с помощью экстракта. Экстракт сколько раз делается?
[01:26:45.420 --> 01:27:02.900]  Экстракт делается тоже E раз, учитывая, что вы хиппу не меняете, к примеру. Вот. Либо делается
[01:27:02.900 --> 01:27:11.820]  V раз, и тогда лог V, ну либо лог E. Ну лог V и лог E это одно и то же для вас будет асимпатически. То есть,
[01:27:11.820 --> 01:27:17.980]  смотрите, именно поэтому это работает E луквы. Хорошего вам всем вечера.
