[00:00.000 --> 00:13.440]  Всем доброго дня! Мы с вами продолжаем наши измышления. Мы с вами, так или иначе, уже прошли
[00:13.440 --> 00:19.840]  основной курс, основной блок, связанный с компиляцией, и теперь мы пошли по дополнительным темам. То есть,
[00:19.840 --> 00:27.200]  у нас сегодня тема первая. Она больше свойственна именно ООП-языкам, всяким высоковоровным языкам. То
[00:27.200 --> 00:34.560]  есть, мы начнем говорить про garbage collectors. Потом у нас, наверное, еще будет где-то лекции 2-3. На них
[00:34.560 --> 00:40.000]  мы скорее всего рассмотрим функциональный язык и рассмотрим вид промежуточного представления для
[00:40.000 --> 00:45.600]  функциональных языков. А в конце мы еще посмотрим про объектно-ориентированную программирование,
[00:45.600 --> 00:51.040]  то есть как оно реализовывается. Но сегодня, на самом деле, тоже тема, которая отчасти посвящена
[00:51.040 --> 00:56.320]  объектно-ориентированному программированию, поэтому будет интересно ее посмотреть. Значит, наша цель
[00:56.320 --> 01:00.760]  будет сегодня разобраться, во-первых, как работают garbage collectors, какие существуют алгоритмы сборки
[01:00.760 --> 01:06.560]  мусора, а после этого мы узнаем, как реализованы garbage collectors в других языках программирования.
[01:06.560 --> 01:14.720]  Значит, это тоже немножко почитал. Пока ехал сюда, да, я ехал на дороге, почитал, как работают garbage collectors в ГО.
[01:26.320 --> 01:34.320]  Ну да, вот предыстория, к чему мы вообще все клоним. Если мы вспоминаем, как у нас раньше были
[01:34.320 --> 01:39.640]  реализованы все объекты, мы говорили, значит, нам нужно алоцировать объект, нам нужно создать
[01:39.640 --> 01:47.240]  экземпляр класса, мы создаем либо структуру и запихиваем ее поля на стэк, либо мы говорили,
[01:47.240 --> 01:52.840]  не паримся, делаем молок и жизнь наша прекрасна. Вот есть только проблема в следующем, что когда мы
[01:52.840 --> 01:59.240]  делаем молок, нам нужно потом очищать эту память, чтобы у нас память не текла с ростом числа процесса.
[01:59.240 --> 02:03.760]  Вот, ты даже не опоздал.
[02:03.760 --> 02:21.600]  Да, чтобы вы все понимали, что те, кто смотрит запись в ютубе, у нас тут просто под капотом
[02:21.600 --> 02:28.880]  день открытых дверей происходит, или день карьеры, и там тоже интересные люди приходят и рассказывают
[02:28.880 --> 02:34.720]  всякую такую вещь. Вот, значит, нам нужно, память нам не нужна все время, нам нужно разобраться,
[02:34.720 --> 02:44.760]  каким образом можно использовать оптимизированную память. Ну, значит, и здесь возникает способ
[02:44.760 --> 02:50.080]  первый. Первый механизм — это механизм сборки мусора. Это форма автоматического управления памятью
[02:50.080 --> 02:56.720]  и процесс, который занимается как раз освобождением алоцированной памяти, называется горбач-коллектор.
[02:56.720 --> 03:05.160]  Давайте подумаем, какой самый простой вид горбач-коллектора можно при желании реализовать.
[03:05.160 --> 03:10.120]  Ладно, это хорошо, это нормальный вариант.
[03:10.120 --> 03:23.320]  Ну, в принципе, да, можно считать ссылки на объекты. Дальше, когда количество ссылок на объект
[03:23.320 --> 03:32.440]  становится равным нулю, не очищай. Вот, значит, давайте объявим требования, которые нам нужны.
[03:32.440 --> 03:39.080]  Значит, конечно же, тут хочется сказать, что на самом деле в языках программирования они должны
[03:39.160 --> 03:47.320]  выполнится, но спешу вас сразу обрадовать, далеко не всегда это так. И даже мы выдвигаемся к первому
[03:47.320 --> 03:52.600]  требованию, скорость работы, mildly overhead, то есть горбач-коллектор не должен требовать много ресурсов.
[03:52.600 --> 04:04.960]  Я, кстати, проводил эксперименты. Знаете, сколько времени работает горбач-коллектор в языке R?
[04:04.960 --> 04:16.640]  100 миллисекунд. А программа меньше. Ну, то есть там стабильно просто где-то порядка 100 миллисекунд
[04:16.640 --> 04:27.480]  работает горбач-коллектор. Вот, дальше, значит, мы хотели бы сделать так, чтобы у нас было мало
[04:27.480 --> 04:31.600]  количества прерваний на сборку мусора. Что такое горбач-коллектор? Это прям алгоритм,
[04:31.600 --> 04:36.880]  который запускается на стадии контекста исполнения. То есть нам нужно прямо исследовать
[04:36.880 --> 04:42.160]  весь наш код и выяснить, когда мы можем прерваться. Поэтому здесь как раз очень важно сделать так,
[04:42.160 --> 04:49.160]  чтобы больше времени мы все-таки занимались выполнением кода, а не чистки мусор. Значит,
[04:49.160 --> 04:59.160]  дальше третье требование, которое они идут все по мере убывания. Важное требование это локальность
[04:59.160 --> 05:03.360]  данных. То есть те данные, которые расположены семантически близко друг к другу, должны бы по
[05:03.360 --> 05:09.240]  хорошему помещаться в одну кашлению. То есть нам нужно делать так, чтобы те участки памяти,
[05:09.240 --> 05:13.920]  которые в пуско-копном времени находились далеко, но потом стали находиться близко в памяти,
[05:13.920 --> 05:19.480]  каким-то образом перемещались свои указатели. То есть горбач-коллектор, смотрите, важно,
[05:19.480 --> 05:25.240]  что горбач-коллектор это не только про очистку мусора, но еще и про управление памятью. То есть,
[05:25.240 --> 05:31.960]  в принципе, горбач-коллектор может при желании перемещать объекты в память. Это,
[05:31.960 --> 05:38.480]  что касается предпределяемых требований. Давайте подумаем следующее. Первый модель,
[05:38.480 --> 05:44.560]  который мы должны рассмотреть, это модель набора корневых вершин. То есть это вершины,
[05:44.560 --> 05:50.160]  к которым есть доступ в самый простой способ с точки зрения кода. Давайте подумаем,
[05:50.160 --> 05:57.440]  что у нас обычно является корневой вершиной. Стэк и глобальные переменные. Тут больше ничего
[05:57.440 --> 06:04.240]  особо нет. То есть у нас есть объекты, которые алоцированы на стэке. То есть здесь это указатель
[06:04.240 --> 06:08.720]  именно. И есть статические переменные. Стические переменные те, которые являются глобальными.
[06:08.720 --> 06:19.560]  Кстати, статические переменные класса, они тоже глобальные. То есть эти объекты нам как раз нужны.
[06:19.560 --> 06:25.880]  И дальше нам нужно высчислить набор достижимых вершин. То есть это набор корневых вершин,
[06:25.880 --> 06:30.840]  плюс тех вершин, которые достижимы по своим ссылкам. То есть если мы используем Java,
[06:30.840 --> 06:38.880]  то в Java это оператор точка. Если это R, то это либо доллар, либо собачка в зависимости от.
[06:38.880 --> 06:45.440]  Да, ну мы привыкли все к тому, что у нас это точка. То есть оператор точка, если мы представляем,
[06:45.440 --> 06:51.720]  что все методы у нас являются публичными, то все объекты у нас являются публичными,
[06:51.720 --> 06:59.360]  то по ним можно дойти до точки. Вот. Значит память выделяется у нас зачастую именно на куче. То есть
[06:59.360 --> 07:06.960]  что у нас должно происходить? По-хорошему. Первое, это у нас аллокатор. Тобственно объект,
[07:06.960 --> 07:13.040]  который пункция, которая выполняет алоцирование объекта, должно находить новое место для запрашиваемого
[07:13.040 --> 07:19.040]  участка памяти. Второе, сборщик мусора находит место, не используемое под объектами, перемещает
[07:19.040 --> 07:26.600]  участки. И третье, перемещает это объекты в кучу. Почему? Тут важный вопрос заключается в том,
[07:26.600 --> 07:30.680]  почему нам объекты нужно перемещать на кучу. Почему мы не можем использовать большое количество
[07:30.680 --> 07:41.480]  молоков. Молоки это дорогая операция. А есть еще один замечательный язык. На J начинается,
[07:41.480 --> 07:49.960]  на A заканчивается. Да, она именно. В ней вы при запуске программы указываете размер кучи.
[07:49.960 --> 07:58.960]  Ну вот прямо она мертва. То есть как бы вы делаете по факту один молок своей жизни и дальше с этими
[07:58.960 --> 08:03.720]  объектами на куче каким-то образом. То есть либо через виртуальную память, либо потом,
[08:03.720 --> 08:10.880]  когда вам эти объекты нужны, они уже идут в реальную память. Вот. То есть вот такая у нас модель.
[08:10.880 --> 08:18.320]  И здесь нам нужно сделать следующую вещь. Обычно первый подход, который заключается в том,
[08:18.320 --> 08:25.040]  что давайте создадим список. Он обычно называется free list. Это каждый элемент указывает на старт
[08:25.040 --> 08:29.600]  следующего свободного участка памяти. То есть у нас есть какой-то большой участок памяти,
[08:29.600 --> 08:35.560]  который мы выделили одним молоком. А дальше у нас происходит по факту, когда мы алоцируем
[08:35.560 --> 08:48.000]  какой-то объект на куче, то у нас происходит следующее. Мы берем, нам вот этот участок памяти
[08:48.000 --> 08:51.640]  должен указывать на вот этот объект. Если вот эта память чистая, эта память чистая,
[08:51.640 --> 09:01.880]  эта память грязная. Какое количество элементов по при листе изначально? Один. То есть у нас
[09:01.880 --> 09:09.280]  весь участок памяти есть. Более того, знаете, есть такая интересная задача. Людям по факту
[09:09.280 --> 09:17.120]  на одной из всероссийских олимпиад по информатике нужно было написать по факту
[09:17.120 --> 09:24.320]  гармош коллектор. Точнее форму управления памяти. Смотрите какая задача. Сейчас я вам покажу ее.
[09:24.320 --> 09:30.600]  Как называется? Всероссийская олимпиада по информатике, да? Нет, всероссийская.
[09:30.600 --> 09:37.640]  Если я не ошибаюсь, это 2005 год.
[09:43.760 --> 09:45.080]  Это командный чемпионат.
[10:00.800 --> 10:10.200]  Я не помню, сейчас посмотрим. О, господи, это RAR-архив. А тут по задачам ничего нету, да? Так, если у меня 7-Zip.
[10:10.200 --> 10:26.960]  А я надскачиваю, да?
[10:26.960 --> 10:39.440]  Ладно, сейчас подождите, сейчас 7-Zip скачаю.
[10:56.960 --> 11:08.840]  Как? Вот так, да? Слушайте, я его даже искал.
[11:08.840 --> 11:22.600]  А, кажется, понял. Так, Sported Formats. Кстати, не пакуйте свои объекты RAR-архивами. Как скачать его?
[11:22.600 --> 11:41.640]  Он через магазин ставится.
[11:53.480 --> 11:56.560]  Врел? Сейчас посмотрим.
[11:56.560 --> 12:06.600]  Да, ставится. Только из другого места его ставят.
[12:06.600 --> 12:20.920]  Что-то ставит. Ну, соберет.
[12:20.920 --> 12:32.680]  Ладно, сейчас подождите, дайте, найду все-таки по информатике.
[12:32.680 --> 12:40.560]  А, задание. О, на Informatics точно должно быть.
[12:40.560 --> 12:55.600]  Все-российские. О, Все-российская Олимпиадная школьника.
[12:55.600 --> 13:20.640]  А что-то тут одна задача, что ли? А, нет, вон они. Нет, не здесь.
[13:25.600 --> 13:49.280]  Да, я вижу. Сейчас, давайте найду ее. А, возможно, она в окружном этапе была, кстати.
[13:49.280 --> 14:05.560]  Нашел. Да, но она на самом деле, ну, в каком-то этом. В общем, она была на какой-то Олимпиаде,
[14:05.560 --> 14:22.720]  по-моему, должна все-российской. То есть, тут надо именно. Да, то есть, вот она, генерация. Надо
[14:22.720 --> 14:33.280]  посмотреть. О, ну, хотя бы зипник. А, это, это, это, 2005 год, апрель 2005, то есть, нам нужен
[14:35.720 --> 14:45.200]  это, значит, окружной этап. Ну, ладно, короче, вот она, задача. Так, Николай, конечно, молодец,
[14:45.200 --> 15:01.480]  вере не закрыл. Эти поручили написать менеджер памяти. Значит, с нее есть последствия,
[15:02.360 --> 15:08.280]  задача менеджера освобождать это все. Запрос освобождения, выделение памяти, это по факту мы
[15:08.280 --> 15:17.520]  работаем с Молоком с вами. Вот, и дальше он должен выделить такой блок. При этом, смотрите,
[15:17.520 --> 15:27.400]  перед самой первой ячейкой памяти не должно располагаться другой свободной ячейки. Ну да,
[15:27.400 --> 15:33.960]  ну просто это вот типа, что в школе такие тоже мотивы людям давали на Олимпиаде. Вот,
[15:33.960 --> 15:40.160]  а дальше запрос на освобождение памяти. Значит, да, тут надо хранить порядковый запрос.
[15:57.400 --> 16:12.920]  Не-не-не, тут именно, они именно в правильном порядке. То есть, тут сказано, что, типа,
[16:12.920 --> 16:21.040]  нужно алоцировать самый первый участок памяти, который доступен. Да, самый первый доступный такого объема.
[16:21.040 --> 16:30.840]  Да, это алгоритм детерминированный, но, в общем, он немного нетривиальный. Ого, еперный,
[16:30.840 --> 16:43.960]  а что с ним, что с экраном-то случилось? Матрица полетела, что ли? Ну да, да, да. А причем,
[16:43.960 --> 16:49.960]  замечу, что 8 точек должна быть м блогем где-то, где м это количество запросов.
[17:13.960 --> 17:28.560]  Ну да. Ну да, на куче можно написать это все.
[17:28.560 --> 17:56.960]  Да. Ну да, в принципе, так. Видите, даже людей на Олимпиаде, на Всероссийской,
[17:56.960 --> 18:03.560]  да, мы тут, раз мы говорим про Горбач-коллектор, вспомним, что была задача в Всероссийской Олимпиаде
[18:03.560 --> 18:08.240]  школьников по информатике, которые по факту заставляли реализовать Горбач-коллектор.
[18:08.240 --> 18:17.080]  Но понятно, что здесь именно мы говорим про управление памятью, то есть, мы не смотрим на наш
[18:17.080 --> 18:24.240]  исходный код. Вот, то есть, нам по факту вот такой вот писочек нужно хранить, первый фри-лист. Вот,
[18:24.240 --> 18:30.880]  и изначально длина этого фри-листа равняется единице. Вот, у нас есть один участок памяти. Так,
[18:30.880 --> 18:37.680]  и дальше у нас с вами есть обычно два вида сборщиков мусора. Первый, это тот,
[18:37.680 --> 18:43.360]  который учитывает количество ссылок на объекте, и второй, это тот, который просто отслеживает все
[18:43.360 --> 18:50.480]  имеющие ссылки на объект. Давайте рассмотрим каждый из них. Итак, подсчет количества вхождения.
[18:50.720 --> 18:55.120]  Представим себе, что нам нужно считать всегда количество ссылок, которые
[18:55.120 --> 19:03.080]  всылают в некоторую обыск памяти. Итак, смотрите, теперь, если мы рассмотрим переменную i,
[19:03.080 --> 19:10.080]  то она выделяет новый объект типа integer, ссылку на объект типа in.
[19:21.080 --> 19:22.080]  Угу.
[19:26.080 --> 19:27.080]  Угу.
[19:38.080 --> 19:39.080]  Ну.
[19:46.080 --> 19:47.080]  Угу.
[19:50.480 --> 19:55.480]  Окей, может быть, посмотрим. Итак, смотрите, количество ссылок на участок памяти,
[19:55.480 --> 20:01.680]  на который сейчас указывает i, стало равно единичке. Дальше, значит, когда мы делаем g равно k,
[20:01.680 --> 20:06.120]  у нас происходит, на самом деле, следующая вещь. Если мы особенно присваиваем int,
[20:06.120 --> 20:11.240]  то количество ссылок на объект, скрывающийся за g, стало на один меньше, потому что мы,
[20:11.240 --> 20:16.400]  если у нас переменная g, за переменная g скрывалось какое-то значение, то по факту мы убрали это
[20:16.400 --> 20:21.160]  значение. А если мы посмотрим на объект k, то количество ссылок на один стало больше.
[20:21.160 --> 20:28.360]  Это переменная стала и переменной g. Дальше, смотрите, алгоритм такой, как только количество ссылок
[20:28.360 --> 20:34.160]  на определенный объект стал, равняется нулю, участок добавляется в прилист, после чего количество
[20:34.160 --> 20:43.320]  ссылок на элементы объекта должно уменьшиться на единичку. Так, где здесь подвох в этом алгоритме?
[20:47.400 --> 20:58.800]  Кольцевая зависимость? Да, конечно же. Давайте посмотрим, как делать вычитание,
[20:58.800 --> 21:06.400]  типа вычисление количества объектов. Мы можем делать либо при помощи if инструкции, то есть
[21:06.400 --> 21:11.400]  напрямую это делать, либо делать это по требованию. То есть, как только память заново потребуется,
[21:11.400 --> 21:19.160]  программа прерывается на большие перерывы, и просто считают те ссылки, которые у нас есть. То есть,
[21:19.160 --> 21:23.840]  мы не в рантайме делаем, а прерываем нашу программу для того, чтобы выполнить какой-то код.
[21:23.840 --> 21:35.640]  Значит, в чем плюс и минус этого алгоритма? Алгоритм простой, но у нас есть минус. Первое
[21:35.640 --> 21:40.920]  это добавление операции числа ссылок в вычислении. Это порядка десяти инструкций на один такт.
[21:40.920 --> 22:03.720]  Надо считать их дополнительно параллельно. Ну да. Инструкция if инструкция,
[22:03.840 --> 22:12.720]  сколько операций у нас? Ну, если у нас if это jump, а сколько мы jump оценивали?
[22:12.720 --> 22:17.240]  Какое количество тактов мы оценивали от jump?
[22:17.240 --> 22:38.120]  Ну да, да, да.
[22:38.120 --> 22:58.600]  Да. Класс.
[23:08.120 --> 23:27.320]  Да, это неприятно, согласен. Вот, ну есть циклы в нашей программе. Давайте посмотрим,
[23:27.320 --> 23:36.200]  например. А, вот они, десять инструкций. То есть, можно уменьшить, если использовать
[23:36.200 --> 24:02.280]  анализ потока данных. Давайте разберем этот код. Да, атомик декремент. Да, да, да.
[24:02.280 --> 24:09.400]  Ну и атомик декремент получается, да? Ну, в принципе, да. То есть, их можно пережать.
[24:09.400 --> 24:17.840]  Главное, просто знать, как это скомпилировать потом в нашу программу. И знать, какие инструкции
[24:17.840 --> 24:25.320]  особенно нужны для этого. Ну ладно, да, это действительно так. Ну, есть вот такая классический
[24:25.320 --> 24:32.040]  пример. У нас есть класс вершины, у которого внутри содержится вершина. Указательная вершина.
[24:32.040 --> 24:37.480]  Ну и дальше мы делаем следующее. Объявляем три объекта, а дальше делаем ссылку на определенный
[24:37.480 --> 24:47.760]  объект. Да, то есть, у нас проблема этого кода, что a.x.x.x и a.x.x остаются незамеченными. То есть,
[24:47.760 --> 25:01.040]  у нас изначально что было в нашем коде? У нас изначально тряпка. Тряпка вся пересохла.
[25:17.760 --> 25:22.520]  Итак, вот у нас объект a.
[25:34.520 --> 25:45.600]  Получается, количество ссылок здесь равняется единице. На вот этот объект у нас 2 ссылки.
[25:45.600 --> 25:55.200]  Собственно, сам объект и a.x.x. Давайте нарисуем просто граф из зависимости. Вот, а дальше что мы делаем?
[25:58.560 --> 26:02.320]  С вами. Мы говорим, что a.x.x это a.x.
[26:02.320 --> 26:07.880]  Мы потом удаляем вот этот объект.
[26:11.880 --> 26:20.080]  И количество ссылок на a у нас удалится, а a.x.x у нас нигде не будет. То есть, у нас остается вот
[26:20.080 --> 26:27.120]  этот вот участок памяти, где у нас есть a.x и a.x.x. И он подсчетом числа ссылок не удалится.
[27:02.320 --> 27:32.320]  У нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть азиатский объект, а у нас есть аз
[27:32.320 --> 27:34.320]  а
[28:02.320 --> 28:27.820]  ну что разобрались или короче
[28:27.820 --> 28:46.060]  ну-ка давайте даже напишем его на маке нет ну это мой компьютер но могу на линукс подключиться
[28:46.060 --> 29:08.700]  так никакой компьютер включить так и так что мы пишем
[29:08.700 --> 29:26.460]  заинклодировали
[29:26.460 --> 29:27.460]  лик
[29:27.460 --> 29:52.020]  вектор
[29:52.020 --> 30:10.980]  где где так что конструкторе передаем
[30:40.980 --> 30:55.220]  так хорошо давайте посмотрим так ой
[30:55.220 --> 31:11.460]  в санитайс адрес
[31:11.460 --> 31:34.660]  какого стандарта не работает
[33:04.660 --> 33:22.260]  так давайте-ка что с 17 стандарта да вроде ага не или мне с другим компилятором
[33:22.260 --> 33:42.420]  сейчас попробуем нет компилировался ну блин конечно у меня
[34:42.420 --> 34:56.020]  но вот у меня я не знаю у меня какой стандарт он не семнадцатый молчанию да интересный
[34:56.020 --> 35:11.060]  пример конечно вот как легко получить горбач коллектор кстати интересно отловит ли
[35:41.060 --> 35:57.980]  да кстати это забавно но вола гринд прямо не может сказать что это за тип утечки
[35:57.980 --> 36:18.580]  не он сказал что 24 байта действительно утекло дебак символа конечно вот
[36:57.980 --> 37:26.060]  а нет да я просто неправильно параметры придал да да да но как этого кире ну да
[37:26.060 --> 37:30.620]  в операторе нью кстати утечка произошла в операторе нью от лонга
[37:30.620 --> 37:57.220]  да в общем интересный пример но видно что циклические зависимости они такие
[37:57.220 --> 38:26.460]  да их не трогать ну да ну да да кстати тем кто смотрит лекцию нужно же сказать что
[38:26.460 --> 38:55.420]  такое боро чекер ну да вот ну то есть это тоже полезная вещь и в принципе даже кстати по
[38:55.420 --> 39:00.700]  моему боро боро чекера очень просто внедрить любой язык программирования только нужно
[39:00.700 --> 39:05.740]  программистов все команды переписать будет все операторы нью и все операторы длит
[39:05.740 --> 39:29.140]  это мы тут уже заговорились немножко давайте двигаться дальше так ну в общем поняли что
[39:29.140 --> 39:35.940]  опера метода подсчета цикл цикл ссылок не работает поэтому есть некоторые trace-based методы вот
[39:35.940 --> 39:43.020]  да и здесь выделяют обычно два алгоритма основных первый алгоритм называется mark and sweep он больше
[39:43.020 --> 39:49.420]  offline алгоритм а есть алгоритм mark compact как марк шип тоже можно делать подлайн варианте есть
[39:49.420 --> 39:58.540]  вариант марк компакт то есть это алгоритм меток и компактификация а флайна онлайн это означает
[39:58.540 --> 40:06.020]  что а флайна полностью прерываем да делаем делаем стоп за ворлд и дальше все останавливаем вот
[40:06.020 --> 40:11.660]  все-таки марк консвит можно сделать так чтобы стоп за ворлд там был в редких случаях
[40:11.660 --> 40:23.940]  ну да вот значит как сделается марк консвит суть в том что мы по идее должны запустить
[40:23.940 --> 40:29.540]  дфс от всех корневых вершин и помечать все участки памяти которые мы достигаем значит
[40:29.540 --> 40:33.840]  в алгоритме свип дальше мы до каждого алоцированного участка в кип делаем
[40:33.840 --> 40:40.780]  следующее если вершина при этом у нас является помеченной то мы ее эту вершину пропускаем
[40:40.780 --> 40:48.700]  дальше иначе мы должны добавить эту вершину во фрелист а да
[40:54.940 --> 40:57.580]  ну но прессом не до
[41:03.580 --> 41:13.940]  да да да вот то есть у нас получается вот такой вот алгоритм понятно что это кажется что
[41:13.940 --> 41:18.740]  алгоритм простой но в нем есть некоторые дела в деталях собственно что этот алгоритм работает
[41:18.740 --> 41:27.980]  медленно вот он пример кстати в общем у нас есть вершины пеку иар и они у них есть ссылки на
[41:27.980 --> 41:35.820]  объект то есть второй второй элемент это ссылка на объекты и третий объект это ссылка на другие
[41:35.820 --> 41:44.940]  переменные то есть у нас получается что у нас после алгоритма пометок у нас будут помечены
[41:44.940 --> 41:50.020]  все вершины кроме вот этих двух то есть у нас есть циклическая зависимость вот между семеркой
[41:50.020 --> 41:56.340]  и девяткой собственно дальше мы делаем следующее мы берем один из элементов тут очень важно что
[41:56.340 --> 42:02.340]  можно взять один из элементов и добавить его в фрелист то есть остальные поскольку у нас с вами
[42:02.340 --> 42:07.900]  как раз линк от листа мы можем подцепить этого корня линк от листа то есть вот тут вот как раз
[42:07.900 --> 42:14.660]  вот эта девятка она перемещается на вот эту семерку тем самым нам достаточно очень легко
[42:14.660 --> 42:19.140]  разматывать цикла то есть нам нужно не все добавлять список а именно используя списки
[42:19.140 --> 42:26.060]  так значит теперь давайте обсудим сложность этого алгоритма пусть у нас выделено аж слов и
[42:26.060 --> 42:34.540]  есть р достижимых слов куча тогда стоимость garbage collection у нас будет какая значит у нас
[42:34.540 --> 42:40.060]  получается есть у отр плюс аж потому что нам нужно найти все достижимые вершины плюс
[42:40.060 --> 42:46.380]  перебрать все слова то есть в нашем графе получается вершины это слово так
[42:49.700 --> 42:54.780]  ну а получается здесь у нас тоже считается качественности жимых слов но то есть по факту
[42:54.780 --> 43:00.260]  мы можем сказать что асимптотика такая же как асимптотика dfs просто и надо посчитать вот
[43:00.260 --> 43:05.620]  при этом количество вспложденных элементов у нас аж минуса то есть в принципе мы на асимптотику
[43:05.620 --> 43:10.540]  тратим на один элемент вот такое количество операции то есть это у нас цена 1 на ар плюс
[43:10.540 --> 43:17.540]  ц2 на аж поделить наш минус р ну не знаю много или мало но в принципе если у нас остается какое-то
[43:17.540 --> 43:23.140]  количество объектов висеть в памяти то это хорошо значит знаете когда полезно использовать
[43:23.140 --> 43:29.620]  garbage collector и когда его не используют и кого за это по рукам надо бить
[43:29.620 --> 43:53.620]  да ну обычно не используют всякие млщики питоновские которые ну вот ну давайте мы за
[43:53.620 --> 44:04.060]  пулям модели а это понятно не просто делаю все чтобы создают объекты закидывает закидывает
[44:04.060 --> 44:16.900]  закидывает а потом бац и что-то памяти это памяти не хватает да кстати это стратегия поведения
[44:16.900 --> 44:35.780]  такая есть для бенчмарков это да ну да да да то есть есть такая проблема то есть вот
[44:35.780 --> 44:41.500]  она нас амортизована сложится алгоритма то есть если мы очищаем прямо очень много слов ну
[44:41.500 --> 44:47.500]  не понятно что еще можно учитывать количество байт которые мы очищаем это будет было бы честно
[44:47.500 --> 44:55.060]  вот то мы можем получить стоимость очищения одного байт информации вот значит и тут как раз
[44:55.060 --> 45:02.660]  можно сделать некоторую связь алгоритма то есть если у нас аэр приблизительно равняется аж на то
[45:02.660 --> 45:09.180]  есть у нас получается очищается малое количество объектов то сложность алгоритма очень большая если
[45:09.180 --> 45:16.380]  аж намного больше чем с аж намного больше чем ар то тогда алгоритм работает константное время
[45:16.380 --> 45:21.940]  работы и хотелось бы иметь именно такой алгоритм а есть еще компромиссный вариант когда р поделить
[45:21.940 --> 45:29.660]  на аж больше одной второй то есть у нас получается количество освобождаемых объектов будет бой хотя
[45:29.660 --> 45:38.340]  бы половина от общего числа объект сейчас дайте прикину то есть получается р больше чем половина аж
[45:38.340 --> 45:46.740]  да то есть как бы суть в том что мы не можем освободить больше чем половину объектов вот тогда
[45:46.740 --> 45:55.980]  логично увеличить размер кучи ждет еще один молок там перенести памяти использовать новый объект так
[45:55.980 --> 46:03.140]  это понятно некоторые еврестики такие что чтобы у нас каждый горбач коллектор долго не вызывался
[46:03.140 --> 46:08.220]  мы его вызываем только в те моменты когда у нас количество алоцированных объектов будет
[46:08.220 --> 46:13.460]  больше чем меньше чем половина от общего количества объектов которые были алоцированы то есть нам
[46:13.460 --> 46:21.300]  нужно выждать именно такие моменты так ну собственно каким образом это все можно оптимизировать
[46:21.300 --> 46:30.140]  первый способ это писать dfs не рекурсивный да использовать его явно на стеке вот для того
[46:30.140 --> 46:36.540]  чтобы хранить объекты значит если последний элемент стека это указательный текущий
[46:36.540 --> 46:42.380]  момент это уменьшает тоже размер количества так на одни чки вот и собственно можно использовать
[46:42.380 --> 46:47.060]  несколько фри листов для записи с разным количеством слов ну то есть готовить именно
[46:47.060 --> 46:55.780]  структуры которые вот оптимизированы под этот формат так плюс и минусы значит плюс очищает
[46:55.780 --> 47:00.740]  всю память плюс управляемая сложность работы то есть в принципе можем задать количество
[47:00.740 --> 47:07.020]  итерации минус это фрагментированность выделенной памяти про пропуски в данных у нас возникает более
[47:07.020 --> 47:13.220]  того есть еще один минус у нас чтобы за ворлд происходит то есть нам нужно остановить весь
[47:13.220 --> 47:24.980]  контекст исполнения и получить наш результат так про маркин свип понятно ага здесь это картинка
[47:24.980 --> 47:33.260]  с флешбеками когда последний последний раз делали фрагментацию фрагментация памяти
[47:33.260 --> 47:39.860]  ну да
[47:39.860 --> 47:51.980]  да ну я знаете как это он вкульную картинку вставил раньше реально где фрагментация диска это
[47:51.980 --> 47:59.140]  была очень важный момент времени очень важная операция который сильная когда мела ресурсы вот
[47:59.140 --> 48:06.580]  то есть как вы видно ввестим из диска тут 33 гигабайта если это до внешние нулевые года вот то
[48:06.580 --> 48:13.820]  есть нам нужно будет компактифицировать эти объекты и здесь нужно сделать так чтобы объекты
[48:13.820 --> 48:20.540]  которые у нас находятся в куче у нас перемещались вы последний участок памяти это он чтобы
[48:20.540 --> 48:28.100]  освобождать множество объектов на кучу вот значит и здесь как раз есть несколько модификаций
[48:28.100 --> 48:36.460]  первый называется алгоритм марка компактини значит у нас должен быть следующий указать первое
[48:36.460 --> 48:41.260]  что у нас должен быть это следующий указатель на свободный участок памяти после этого нам
[48:41.260 --> 48:48.660]  нужно сделать ограничение на используемый участок памяти и значит это именно для структур и
[48:48.660 --> 48:55.100]  должен быть объект скан это указатель на области памяти для которой необходимо провести
[48:55.100 --> 49:01.020]  сканирование всех его полей то есть этот алгоритм специально позволяет анализировать все структуры
[49:01.020 --> 49:07.460]  и поля этой структуры тут можно сказать как как для структуры использовать компактификацию корректным
[49:07.460 --> 49:07.940]  образом
[49:07.940 --> 49:16.980]  у нас структура структура структура структура вектора
[49:16.980 --> 49:31.900]  ну да нам просто нужно правильно вычислять афсета на кучу чтобы у нас объекты собирались вместе но
[49:31.900 --> 49:38.060]  это тоже может делать на уровне dfs то есть сделать как наш любимый визитер который
[49:38.060 --> 49:47.380]  будет вычислять сдвиги наших элемент относительно старта хорошо значит тут есть как раз механизм того
[49:47.380 --> 49:54.020]  как это все считается значит в пункте форвард собственно нам нужно понимать просто следующего
[49:54.020 --> 49:58.700]  участок памяти куда нам надо пылить то есть мы здесь находимся во внутренней структуре то
[49:58.700 --> 50:04.460]  было бы неплохо понять как мы выходим из этой структуры к какому объекту мы используем тут
[50:04.460 --> 50:11.660]  можно на паузу поставить принципе разобрать этот алгоритм так вот он пример кстати то есть
[50:11.660 --> 50:19.740]  у нас с вами есть перед нашим алгоритмом как раз корневые вершины п q ир вот и дальше мы
[50:19.740 --> 50:27.060]  начинаем перемещать наш объект то есть у нас получается п это 15 объект дальше у нас идет
[50:27.060 --> 50:35.260]  37 объект да и дальше мы указываем собственно элементы скан то есть которого у нас есть вот и
[50:35.260 --> 50:43.460]  как раз сканируем одну запись то есть нашу структуру и понимаем что нам нужен объекте по 15 37 ну и
[50:43.460 --> 50:50.460]  дальше они уже будут сканироваться то есть у нас 15 элемент дальше указывается на 12 элемент вот и
[50:50.460 --> 51:00.780]  мы его перемещаем в памяти вот подряд то есть потихонечку мы как раз разматываем этот
[51:00.780 --> 51:05.420]  клубок для того чтобы у нас все элементы стали последними друг за другом есть многоуровневая
[51:05.420 --> 51:11.020]  мизация понятно потому что то есть здесь есть подход типа мы копаем сверху вниз мы можем или
[51:11.020 --> 51:16.220]  мы копаем бок здесь алгоритм компании в бок но потому что скорее всего если у нас структура есть
[51:16.220 --> 51:21.420]  нам хотелось бы обращаться ко всем полям последовательно а не конкретным элемент
[51:21.420 --> 51:28.780]  хорошо какие достоинства и недостатки у этого алгоритма нет фрагментированности данных но
[51:28.780 --> 51:34.340]  проблема в том что нужно алоцировать два раза больше памяти для перемещения вот и локальный
[51:34.340 --> 51:39.500]  данных все-таки может нарушаться то есть как бы у нас получается одна структура находится не в
[51:39.500 --> 51:44.460]  одном месте а по факту указателя на объекты в одной структуре в одном месте потом если мы
[51:44.460 --> 51:51.140]  хотим обратиться к дальнейшим элементам нам нужно прыгать вниз так понятен мар компакт
[51:54.860 --> 51:58.380]  еще раз значит идея такая что вот у нас есть древовидная структура
[52:09.860 --> 52:13.260]  это какой алгоритм мар компакт или мар компакт чине
[52:14.460 --> 52:27.940]  вот это первое это алгоритм мар компакт то есть у нас есть структура у нас есть объекта
[52:27.940 --> 52:38.220]  здесь дырка здесь дырка потому что мы делаем мы делаем мы обходим наши вершины в порядке
[52:38.220 --> 52:45.140]  и вычисляем объем памяти который нам нужен здесь у нас получается этот объект будет перемещаться
[52:45.140 --> 52:51.020]  сюда значит он скинет у нас афсет допустим что он занимает 16 машинных слов следующий
[52:51.020 --> 52:56.540]  элемент который у нас заходим в дфс должен находиться на сдвиге относительно 16 машинных слов
[52:56.540 --> 53:04.220]  образно говоря вот этот элемент который был дальше у нас имеет 18 машинных слов да то есть
[53:04.220 --> 53:10.300]  и дальше у нас здесь 16 элемент после этого у нас идет афсет на 34 и мы потихонечку перемещаем
[53:10.300 --> 53:23.220]  наш объект на структуре но если в нашем поле но если у нас есть структура возможно мы хотим
[53:23.220 --> 53:31.220]  отложить выполнение наших операций то есть мы сначала хотим пройти корни а потом только спускаться
[53:31.220 --> 53:43.860]  вниз да потому что скорее всего изначально мы будем а точка x делать а потом из x мы будем
[53:43.860 --> 53:48.140]  обращаться уже другим элементом но уже когда-то позже то есть у нас первый уровень будет вот такой
[53:48.140 --> 53:56.540]  второй уровень будет вот такой вот поэтому эти элементы должны быть сначала потом эти элементы
[53:56.540 --> 54:01.300]  должны спускаться ниже то есть в принципе при другой инструкции генерируется кстати есть такое
[54:01.300 --> 54:11.020]  правило в в проектировании и написание кода закон диметра слышали да что а должен знать
[54:11.020 --> 54:22.100]  обе если а знает обе без знают оце то они должны знать оце вот так как раз алгоритм мар компакт
[54:22.100 --> 54:27.340]  подбуждает если у вас в языке реализован мар компакт вот именно вот способом чинить он
[54:27.340 --> 54:32.900]  побуждает вас как раз не писать по закону диметра то есть это даже будет влиять на то как подпишется
[54:32.900 --> 54:46.140]  в языке программирования он будет работать просто медленнее так стало понятно что вот значит вторая
[54:46.140 --> 54:55.140]  алгоритм значит марк свик компакт ну собственно здесь говорится следующее если мы хотим чтобы
[54:55.140 --> 55:00.020]  все объекты у нас помещают в кашлении то на стадии сканирования мы вместо dfs будем запускать
[55:00.020 --> 55:07.460]  bfs вот здесь нужно именно максимально считать глубину dfs дат чтобы у нас все помещалось к
[55:07.460 --> 55:13.100]  ошлению понятно что про размер кашлений мы явно не знаем и нам процессор ничего об этом не скажет но
[55:13.100 --> 55:18.500]  все равно было бы неплохо понимать на каком уровне мы можем спускаться вот
[55:24.300 --> 55:25.860]  вот пойти
[55:35.060 --> 55:35.580]  ну да
[55:35.580 --> 55:43.420]  но но новой
[55:47.060 --> 55:51.420]  но
[55:51.420 --> 56:14.500]  ну да конечно же ну то есть но то есть первое что разработчики
[56:14.500 --> 56:22.500]  армовского процессора сделали они придумали режим амуляции блин ну а ну и
[56:22.500 --> 56:29.580]  на ну а иначе как бы миграцию проводить старых всех приложений на новое да да
[56:29.580 --> 56:44.500]  конечно не но всегда новая инструкция когда появляется нужно быть аккуратным и
[56:44.500 --> 56:53.740]  делать бэкпорта на предыдущей версии вот это вот так значит здесь еще одна
[56:53.740 --> 56:57.620]  оценка значит если мы про маркет сверх компакт появляется то нам нужно будет
[56:57.620 --> 57:02.620]  копировать наши участки в словах то есть у нас вот суммарная сложность копирование будет
[57:02.620 --> 57:10.500]  с 3 на r поделить на аж пополам минус а аж пополам это размер нашей кучи вот ну и собственно
[57:10.500 --> 57:16.420]  приблизительно освобождается половина памяти поэтому мы получаем ц 3 но собственно мы выяснили
[57:16.420 --> 57:22.340]  насколько это операция копирования операция копирование у нас занимает 10 и 10 такт мы
[57:22.340 --> 57:30.180]  кажется про это говорили предъявить вот хорошо так это объединение трех лагерет значит
[57:30.180 --> 57:38.300]  теперь значит какая этипизация горбач коллекторов существует по времени остановки первая это стоп
[57:38.300 --> 57:43.180]  зэ ворлд то есть мы запускаем полностью весь горбач коллектор на все алоцированная память
[57:43.180 --> 57:50.180]  и в куче а есть по стоп пауз то есть мы запускаем на только часть объектов куч мы вызываем не
[57:50.180 --> 57:54.500]  полностью горбач коллектора вызываем только горбач коллектор и на определенном количестве
[57:54.500 --> 58:02.500]  элементов вот значит и есть следующие вида поколений собственно мы смотрели какие алгоритмы
[58:02.500 --> 58:08.100]  есть горбач коллекторов теперь давайте поймем как от стопа от стопа зэ ворлд перейти к стоп
[58:08.100 --> 58:14.420]  зэ пауз значит и для этого как раз возникают новые истории называется general channel горбач
[58:14.420 --> 58:18.580]  коллектор то есть они являются поколенческим языки именно горбач коллектор встроены в языках
[58:18.580 --> 58:25.820]  программирования значит все объекты в памяти тогда у нас можно поделить по такому признаку
[58:25.820 --> 58:33.140]  какое количество цитактов горбач коллектора пережил наш объект на самый молодые объект у
[58:33.140 --> 58:37.780]  нас попадает в элемент g0 потому что они не пережили множество ноль потому что они пережили
[58:37.780 --> 58:43.100]  ни одного горбач коллектора следующий объект у нас переживает одну чистку она они попадает
[58:43.100 --> 58:48.780]  в G2, в G1, потом в G2. Ну а дальше, на самом деле, мы прекрасно
[58:48.780 --> 58:51.940]  понимаем, скорее всего, что если объект пережил два,
[58:51.940 --> 58:55.980]  две стадии очистки гармошка-электра, то сколько он ещё переживёт?
[58:55.980 --> 59:05.980]  Много. То есть обычно здесь счёт идёт 0, 1, много. Классно,
[59:05.980 --> 59:20.980]  почему заменить? Классно, и как они в мусор собираются?
[59:20.980 --> 59:25.740]  То есть понятно, мы делаем многопоточность, но делаем
[59:25.740 --> 59:55.740]  сетон медленнее. Красава. Ну да. Ну да. Угооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооо
[59:55.740 --> 59:59.740]  Там причем две стадии... два способа генерации есть.
[59:59.740 --> 01:00:02.740]  Один эхху господи я читал его.
[01:00:02.740 --> 01:00:08.740]  Ding я за другой в РайтБарьер.
[01:00:08.740 --> 01:00:11.740]  Т.е. с них два барьера используются.
[01:00:11.740 --> 01:00:34.740]  Классно!
[01:00:34.740 --> 01:00:37.740]  Да, да, да.
[01:00:37.740 --> 01:00:39.740]  Да.
[01:00:39.740 --> 01:00:48.740]  В общем, цель запускать мусор у нас сначала на G0, чуть реже на G1 и еще реже на G2.
[01:00:48.740 --> 01:00:53.740]  Вот. И запоминание. Чтобы очистка не тракивала большое количество времени, значит мы
[01:00:53.740 --> 01:01:00.740]  необходимо запоминать объекты, которые начинают ссылаться на объекты из G0.
[01:01:00.740 --> 01:01:03.740]  Да, то есть старые объекты на новые.
[01:01:03.740 --> 01:01:09.740]  Потому что, скорее всего, они с высокой степени, вероятно, переедут в новую фазу.
[01:01:09.740 --> 01:01:14.740]  Ну список запоминаний тут очень много разных способов использовать.
[01:01:14.740 --> 01:01:20.740]  Один из интересных способов это использование грязного бита. То есть мы обновляем область старой duty bit.
[01:01:20.740 --> 01:01:26.740]  Устанавливаем bit, что в страницу была произведена запись.
[01:01:26.740 --> 01:01:28.740]  Угу.
[01:01:29.740 --> 01:01:31.740]  А?
[01:01:35.740 --> 01:01:37.740]  Да.
[01:01:39.740 --> 01:01:42.740]  Спросите, почему не используют?
[01:01:45.740 --> 01:01:47.740]  А, ну да.
[01:01:47.740 --> 01:01:50.740]  Вот, значит, еще как...
[01:01:51.740 --> 01:01:58.740]  Вот. И есть еще другие сборщики мусора. Первый из них это incremental, а второй это concurrent.
[01:01:58.740 --> 01:02:02.740]  То есть с incremental он работает по требованию.
[01:02:02.740 --> 01:02:07.740]  То есть вообще во всех современных языках программирования есть именно сборщик мусора по требованию.
[01:02:07.740 --> 01:02:11.740]  То есть есть модуль gc, который можно подключить и вызвать.
[01:02:12.740 --> 01:02:14.740]  Вот.
[01:02:14.740 --> 01:02:17.740]  Знание gc, это право отдельно.
[01:02:17.740 --> 01:02:23.740]  А, да, вначале я хотел поэкспериментировать, потому что на гc еще обшифровывается клоунбайвер.
[01:02:27.740 --> 01:02:29.740]  Четыре спроста.
[01:02:36.740 --> 01:02:38.740]  Ну, короче...
[01:02:41.740 --> 01:02:43.740]  Нормально.
[01:02:45.740 --> 01:02:49.740]  А там в гc garbage collector с большой буквой, надеюсь, написано.
[01:02:53.740 --> 01:02:57.740]  Не надо сокращать название переменных, вот и что скажу.
[01:03:03.740 --> 01:03:06.740]  Нормально. Сразу с чистка.
[01:03:06.740 --> 01:03:09.740]  Ладно, значит, про concurrent gc.
[01:03:09.740 --> 01:03:12.740]  Что мы говорим? У нас есть две действующие роли.
[01:03:12.740 --> 01:03:18.740]  Первый это сборщик, который собирает мусор, а параллельно с ним работает мутатор,
[01:03:18.740 --> 01:03:21.740]  который пытается менять граф доступности данных.
[01:03:21.740 --> 01:03:25.740]  То есть у нас по факту получается mark and sweep может в одном месте работать,
[01:03:25.740 --> 01:03:29.740]  мутатор переносит объект параллельно каким-то образом.
[01:03:29.740 --> 01:03:32.740]  Так, ну, наверное, здесь мы остановимся,
[01:03:32.740 --> 01:03:39.740]  потому что здесь на самом деле дальше еще будет алгоритм stop the pause для garbage collectors.
[01:03:40.740 --> 01:03:42.740]  А у нас пара закончилась.
[01:03:42.740 --> 01:03:46.740]  Все, я вроде больше никуда не уезжаю в ближайшее время.
[01:03:46.740 --> 01:03:50.740]  Так что таких форс-мажоров уже не будет.
[01:03:51.740 --> 01:03:53.740]  В общем, мы начали рассматривать garbage collectors.
[01:03:53.740 --> 01:03:55.740]  На самом деле почти мы их уже досмотрели.
[01:03:55.740 --> 01:04:01.740]  Нам осталось, по-моему, где-то 5-6 слайдов.
[01:04:01.740 --> 01:04:03.740]  Вот, тогда мы их досмотрим в следующий раз,
[01:04:03.740 --> 01:04:07.740]  и тогда перейдем к функциональным языкам программирования.
[01:04:09.740 --> 01:04:11.740]  Так, давайте вопросы.
[01:04:16.740 --> 01:04:19.740]  Окей, тогда если нет вопросов, то до встречи.
[01:04:19.740 --> 01:04:21.740]  Что могу сказать?
