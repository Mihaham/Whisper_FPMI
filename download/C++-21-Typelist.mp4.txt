[00:00.000 --> 00:11.000]  Сегодня мы будем писать мета контейнер.
[00:11.000 --> 00:14.000]  Вот.
[00:14.000 --> 00:20.000]  Какой это пункт? 16.5?
[00:20.000 --> 00:24.000]  Ну, давайте все-таки собраться.
[00:25.000 --> 00:37.000]  Typelist, meta-container and value-based metaprogramming.
[00:37.000 --> 00:41.000]  Значит, сейчас я объясню, что такое value-based metaprogramming,
[00:41.000 --> 00:45.000]  но сначала я объясню, что такое Typelist, meta-container.
[00:45.000 --> 00:48.000]  Ну, на самом деле, ничего, по сути, сложного сейчас нет,
[00:48.000 --> 00:53.000]  потому что я сейчас буду говорить первые минут 15.
[00:53.000 --> 01:01.000]  В принципе, и так понятно, что я сейчас буду писать.
[01:01.000 --> 01:07.000]  Мы хотим написать примерно следующее.
[01:07.000 --> 01:14.000]  Typelist. Я буду эти структуры уже с маленькой буквы писать теперь.
[01:14.000 --> 01:17.000]  Вот.
[01:17.000 --> 01:25.000]  Что такое Typelist? Это meta-container.
[01:25.000 --> 01:27.000]  Что такое meta-container?
[01:27.000 --> 01:30.000]  Ну, это хранилище типов.
[01:30.000 --> 01:34.000]  Вот он хранит последовательность типов.
[01:34.000 --> 01:39.000]  Вот. И я хочу написать такие метафункции,
[01:39.000 --> 01:46.000]  которые будут по этому meta-container возвращать что-то другое.
[01:46.000 --> 01:55.000]  Ну, например, самое банальное, что я могу сделать, это push-front, pop-front.
[01:55.000 --> 01:58.000]  Ну, или просто front.
[01:58.000 --> 02:02.000]  Вот давайте я напишу template, type-name.
[02:02.000 --> 02:06.000]  Давайте сначала напишем функцию, которая возвращает первый элемент.
[02:06.000 --> 02:19.000]  Type-name t, type-name многоточие ts, struct front.
[02:19.000 --> 02:30.000]  Ну, просто front у нас будет без тела, front от чего palo звать нельзя.
[02:30.000 --> 02:42.000]  А вот front от типа, вот такая специализация будет, type-name t, type-name многоточие ts,
[02:42.000 --> 02:50.000]  front от type-list от t, запятая t и s многоточие.
[02:50.000 --> 02:54.000]  Что это такое будет?
[02:54.000 --> 02:57.000]  Это будет type-identity.
[02:57.000 --> 03:08.000]  Давайте я напишу using std type-identity, потому что мне будет часто нужно.
[03:08.000 --> 03:11.000]  Using std type-identity.
[03:11.000 --> 03:19.000]  Ну, я подключу type-trades.
[03:19.000 --> 03:26.000]  Type-identity от t.
[03:26.000 --> 03:28.000]  Вот, дальше.
[03:28.000 --> 03:32.000]  Ну, давайте сделаем push-front и pop-front, например.
[03:32.000 --> 03:35.000]  Как будет выглядеть push-front?
[03:35.000 --> 03:44.000]  Ну, опять, наверное, опять-таки я скажу, что push-front от чего palo звать нельзя.
[03:44.000 --> 03:46.000]  Да и push и pop-front.
[03:46.000 --> 03:48.000]  Ну, вот сначала pop-front напишем.
[03:48.000 --> 03:50.000]  Pop-front от чего palo звать нельзя.
[03:50.000 --> 03:53.000]  Pop-front от type-list.
[03:53.000 --> 03:55.000]  Вызывать можно.
[03:55.000 --> 03:57.000]  Что это будет такое?
[03:57.000 --> 04:02.000]  Это будет type-list.
[04:02.000 --> 04:08.000]  Тс, многоточие.
[04:08.000 --> 04:12.000]  Сейчас.
[04:12.000 --> 04:16.000]  Если мы напишем двоеточие, наверное, будет неправильно.
[04:16.000 --> 04:22.000]  Мне надо, чтобы pop-front от него был...
[04:22.000 --> 04:24.000]  Type-list, ts.
[04:24.000 --> 04:26.000]  Нет, все правильно.
[04:26.000 --> 04:30.000]  Pop-front-identity от type-list.
[04:30.000 --> 04:34.000]  От тс, многоточие.
[04:34.000 --> 04:36.000]  Просто у меня же будет еще pop-front-t.
[04:36.000 --> 04:40.000]  Вот я здесь написал front-t.
[04:40.000 --> 04:49.000]  Pop-front – это будет меташтука, которая представляет из себя структуру, в которой объявлен type,
[04:49.000 --> 04:55.000]  которая называется type-list.
[04:55.000 --> 05:01.000]  А pop-front-t – это будет сам type-list.
[05:01.000 --> 05:04.000]  Я о чем же вы тогда сразу не пишем?
[05:04.000 --> 05:07.000]  Твоечное дерево поиска вместо списка.
[05:07.000 --> 05:09.000]  Ну а о чем компиляция?
[05:09.000 --> 05:11.000]  Компиляция долгая.
[05:11.000 --> 05:14.000]  Не бедите.
[05:14.000 --> 05:20.000]  Ну, мы на самом деле сейчас что-то подобное...
[05:20.000 --> 05:21.000]  Попытаемся здесь...
[05:21.000 --> 05:24.000]  Ну нет, двоечетнадцать деревьев.
[05:24.000 --> 05:27.000]  Нет, что? Веритель, нет.
[05:27.000 --> 05:34.000]  Front-t – это будет type-name.
[05:34.000 --> 05:41.000]  А front – вот type-list.
[05:41.000 --> 05:43.000]  От т, запятая.
[05:43.000 --> 05:45.000]  Тс, многоточие.
[05:45.000 --> 05:48.000]  Дветочие, дветочие, type.
[05:48.000 --> 05:58.000]  Да, и pop-front-t тоже самое.
[05:58.000 --> 06:00.000]  А что такое pop-front-t?
[06:00.000 --> 06:08.000]  Это pop-front, type-list, т, тс, дветочие, дветочие, type.
[06:08.000 --> 06:12.000]  Вот, ну можно сразу написать какие-нибудь простые тестики.
[06:12.000 --> 06:17.000]  Например, можно написать static-assert.
[06:17.000 --> 06:23.000]  Я еще напишу здесь, что я использую стд-is-same.
[06:23.000 --> 06:26.000]  Is-same-where.
[06:26.000 --> 06:35.000]  Вот, ну можно написать static-assert, что is-same-where.
[06:35.000 --> 06:37.000]  Type-list.
[06:37.000 --> 06:55.000]  Сейчас, pop-front-t под type-list, int-double-char.
[06:55.000 --> 07:04.000]  И просто type-list, double-char.
[07:04.000 --> 07:06.000]  Что?
[07:06.000 --> 07:19.000]  Сейчас, я проверяю, is-same-where, pop-front-t, раз-два, раз-два, type-list, double-char, не лишнее.
[07:19.000 --> 07:21.000]  Все нормально.
[07:21.000 --> 07:26.000]  Pop-front-t, вот у меня голова скобка открылась, две голоскобки открылась, две закрылась.
[07:26.000 --> 07:28.000]  Is-same-where.
[07:28.000 --> 07:32.000]  Еще type-list вот такой, и вторая голова скобка закрылась.
[07:32.000 --> 07:35.000]  Давайте какой-нибудь.
[07:35.000 --> 07:38.000]  Я вот сейчас такой вопрос. А почему мы не делаем?
[07:38.000 --> 07:40.000]  Да.
[07:40.000 --> 07:43.000]  Только не спрашивай, зачем это надо.
[07:43.000 --> 07:45.000]  Почему мы не делаем?
[07:46.000 --> 07:50.000]  Садака вексель свое десятый умеет.
[07:50.000 --> 07:52.000]  А почему мы тут сделали? Мы ничего не сделали.
[07:52.000 --> 07:55.000]  Ну я только type-list использовал.
[07:55.000 --> 07:59.000]  Почему мы не делаем front именно методом type-list?
[07:59.000 --> 08:00.000]  А как?
[08:00.000 --> 08:11.000]  Ну то есть мы делаем его using, ну не using, но типа функцией, у которой нету имплементации, а в качестве результата будем использовать стандарь результатов.
[08:11.000 --> 08:15.000]  Или там декол-type, чего-нибудь.
[08:17.000 --> 08:20.000]  Ну, методом type-list.
[08:20.000 --> 08:27.000]  Ну потому что тут писать, я не знаю, type-list 2.2.pop-front, но это хоть сколько-то лет меньше, чем pop-front type-list.
[08:27.000 --> 08:28.000]  Ну да.
[08:28.000 --> 08:30.000]  Это привычнее.
[08:31.000 --> 08:45.000]  На самом деле ты мыслишь в правильную сторону, в том смысле, что мы сейчас вот это все понапишем, а потом ясно, что это все плохо и мы сделаем по-другому.
[08:46.000 --> 08:59.000]  Вот то, что я сейчас написал, это как раз такое самое наивное метапрограммирование, которое было до появления constexpr.
[08:59.000 --> 09:05.000]  Вот я сейчас еще несколько функций напишу, а потом мы их переделаем более красивые.
[09:05.000 --> 09:06.000]  Вот.
[09:06.000 --> 09:12.000]  Сейчас я пока показываю, как это бы выглядело до того, как мы constexpr узнали.
[09:12.000 --> 09:17.000]  После того, как мы узнали constexpr, на самом деле это все проще можно сделать, сейчас мы как раз это сделаем.
[09:17.000 --> 09:22.000]  Но для начала я покажу вот такой вот довольно лидовский способ.
[09:22.000 --> 09:25.000]  А так вот, type-list.
[09:26.000 --> 09:29.000]  Ну, конечно, тут не все так легко.
[09:29.000 --> 09:32.000]  Да, я забыл тело.
[09:36.000 --> 09:38.000]  Здесь забыл тело.
[09:43.000 --> 09:44.000]  Вот.
[09:44.000 --> 09:46.000]  StaticAssociationFailed.
[09:46.000 --> 09:47.000]  Почему?
[09:53.000 --> 09:56.000]  Да, вот еще DebuggingTemplates.
[09:56.000 --> 09:57.000]  Это ужасно.
[09:57.000 --> 10:02.000]  Здесь самые плютов, брейп-пойнты на уровне компиляции.
[10:07.000 --> 10:08.000]  Сейчас, секунду.
[10:08.000 --> 10:09.000]  Кто еще не выпустил дебайдер?
[10:09.000 --> 10:12.000]  Буквально нечего делать, просто...
[10:14.000 --> 10:15.000]  Так, сейчас.
[10:15.000 --> 10:16.000]  Я где-то что-то...
[10:16.000 --> 10:18.000]  Читаем код очень мимо.
[10:19.000 --> 10:20.000]  Давайте прочитаем код очень мимо.
[10:20.000 --> 10:23.000]  Поперерасии на строчки разные, просто чтобы не запутаться.
[10:23.000 --> 10:27.000]  У тебя сейчас фигурных треугольных скобочек, как будто я делал.
[10:27.000 --> 10:28.000]  Не-не.
[10:28.000 --> 10:30.000]  Да-да, с треугольными скобочками все нормально.
[10:30.000 --> 10:36.000]  Значит, у меня есть темплейт, специализация темплейта Popfront.
[10:36.000 --> 10:37.000]  Те?
[10:40.000 --> 10:41.000]  А что нужно делать?
[10:45.000 --> 10:46.000]  Да, я умею...
[10:46.000 --> 10:47.000]  Да, вот так надо писать.
[10:47.000 --> 10:48.000]  Темплейт.
[10:49.000 --> 10:50.000]  TypeName.
[10:50.000 --> 10:51.000]  Те.
[10:51.000 --> 10:52.000]  Popfront.
[10:52.000 --> 10:53.000]  Сейчас.
[10:53.000 --> 10:57.000]  Мне нужно сделать, чтобы Popfront...
[10:57.000 --> 10:59.000]  Popfront принимает в себя...
[11:00.000 --> 11:01.000]  Сейчас.
[11:01.000 --> 11:03.000]  Для этого Popfront нужно просто лист принимать.
[11:03.000 --> 11:04.000]  А-а-а...
[11:06.000 --> 11:09.000]  Да, если я написал Popfront...
[11:10.000 --> 11:12.000]  Что, пишем концерт с TypeList?
[11:15.000 --> 11:16.000]  Неприятно.
[11:16.000 --> 11:18.000]  Здесь у вас Popfront от Те.
[11:18.000 --> 11:19.000]  Вы должны читать.
[11:20.000 --> 11:21.000]  А, да, господи.
[11:21.000 --> 11:23.000]  Не надо TypeList писать.
[11:23.000 --> 11:24.000]  Все, все нормально.
[11:25.000 --> 11:26.000]  Да, вот так.
[11:28.000 --> 11:29.000]  О, отличный, да.
[11:30.000 --> 11:31.000]  Вот.
[11:31.000 --> 11:32.000]  Ну, хорошо.
[11:32.000 --> 11:33.000]  Popfront.
[11:33.000 --> 11:35.000]  Ну, можно сделать еще Pushfront.
[11:35.000 --> 11:36.000]  Это уже...
[11:36.000 --> 11:37.000]  Неинтересно.
[11:38.000 --> 11:39.000]  Скучно.
[11:40.000 --> 11:43.000]  Да, упражнения для читать.
[11:43.000 --> 11:44.000]  Да.
[11:44.000 --> 11:45.000]  Упражнения для...
[11:48.000 --> 11:49.000]  Неленивого слушателя.
[11:50.000 --> 11:51.000]  А-а-а...
[11:51.000 --> 11:53.000]  Что насчет Pushback и Popback?
[11:53.000 --> 11:54.000]  Ну, Pushback можно сделать.
[11:56.000 --> 11:57.000]  Как сделать Pushback?
[12:00.000 --> 12:01.000]  Нужно просто принимать...
[12:01.000 --> 12:02.000]  Ну, сейчас.
[12:02.000 --> 12:03.000]  Что у нас тут проблемы?
[12:03.000 --> 12:04.000]  Делать Pop...
[12:04.000 --> 12:05.000]  Давайте я напишу Pushback.
[12:10.000 --> 12:11.000]  И тут специализация будет.
[12:11.000 --> 12:12.000]  Pushback.
[12:12.000 --> 12:15.000]  Popfront может перейти сейчас и куксе и бежать на конца.
[12:16.000 --> 12:17.000]  От TypeList.
[12:17.000 --> 12:18.000]  TS.
[12:18.000 --> 12:19.000]  Popfront.
[12:19.000 --> 12:20.000]  И бежать на конца.
[12:22.000 --> 12:23.000]  От TypeList.
[12:23.000 --> 12:24.000]  TS многоточие.
[12:24.000 --> 12:25.000]  TypeT.
[12:26.000 --> 12:27.000]  Popback.
[12:28.000 --> 12:29.000]  А, ну да.
[12:30.000 --> 12:31.000]  От TypeList.
[12:31.000 --> 12:32.000]  TS.
[12:32.000 --> 12:33.000]  Это был бы...
[12:33.000 --> 12:34.000]  Это был бы Popback.
[12:35.000 --> 12:37.000]  А Pushback будет выглядеть так.
[12:37.000 --> 12:38.000]  Это TypeIdentity.
[12:38.000 --> 12:39.000]  От TypeList.
[12:39.000 --> 12:40.000]  TS.
[12:40.000 --> 12:41.000]  TypeT.
[12:41.000 --> 12:42.000]  Что-что-что сейчас произошло?
[12:43.000 --> 12:44.000]  Мы фронт опять удалили.
[12:45.000 --> 12:46.000]  Как удалили?
[12:46.000 --> 12:47.000]  А, это...
[12:47.000 --> 12:48.000]  Это Push.
[12:48.000 --> 12:49.000]  Все хорошо.
[12:49.000 --> 12:50.000]  Да.
[12:50.000 --> 12:51.000]  Теперь я могу сказать...
[12:51.000 --> 12:52.000]  Popback плохой.
[12:52.000 --> 12:53.000]  Да?
[12:53.000 --> 12:54.000]  Popback.
[12:54.000 --> 12:55.000]  Вот с Popback будет проблема.
[12:55.000 --> 12:56.000]  Да.
[12:56.000 --> 13:01.000]  Вот я могу теперь, например, проверить, что StaticAssert Pushback...
[13:01.000 --> 13:06.000]  Так, мне нужно еще PopfrontT тоже скопировать, сделать PushbackT.
[13:12.000 --> 13:13.000]  Ой.
[13:13.000 --> 13:14.000]  PushbackT.
[13:14.000 --> 13:16.000]  Это Pushback.
[13:17.000 --> 13:18.000]  T.
[13:18.000 --> 13:19.000]  Type.
[13:20.000 --> 13:21.000]  Вот.
[13:21.000 --> 13:23.000]  И я проверяю, что PushbackT...
[13:31.000 --> 13:34.000]  Pushback у меня специализирует только для TypeList.
[13:35.000 --> 13:38.000]  А для остальных, если я вызову Pushback, то это пациент.
[13:38.000 --> 13:39.000]  А, PushbackT.
[13:39.000 --> 13:40.000]  А, PushbackT.
[13:41.000 --> 13:42.000]  PushbackT.
[13:43.000 --> 13:45.000]  А куда мы Type передаем?
[13:45.000 --> 13:46.000]  А, да, кстати.
[13:46.000 --> 13:47.000]  Отличный вопрос.
[13:47.000 --> 13:48.000]  Тогда мне нужно Pushback.
[13:49.000 --> 13:50.000]  Действительно, мне нужен...
[13:50.000 --> 13:52.000]  Первый, мне нужен вот такой параметр.
[13:55.000 --> 13:56.000]  Нет, слева.
[13:56.000 --> 13:57.000]  Вот знаете почему?
[13:58.000 --> 14:02.000]  Потому что я смогу писать тогда Pushback...
[14:04.000 --> 14:06.000]  В PushbackT тоже надо добавить.
[14:06.000 --> 14:07.000]  А, нет.
[14:07.000 --> 14:08.000]  Ну да.
[14:08.000 --> 14:09.000]  Не важно.
[14:09.000 --> 14:10.000]  Можно с этой стороны.
[14:15.000 --> 14:18.000]  Ну, бежим тогда TypeNameT, TypeNameU.
[14:18.000 --> 14:19.000]  Вот.
[14:19.000 --> 14:20.000]  А здесь TypeNameU.
[14:24.000 --> 14:26.000]  Может TypeNameList, пожалуйста.
[14:26.000 --> 14:28.000]  Или там кто-то из них Лист.
[14:28.000 --> 14:31.000]  Хотя бы, если уж не концепт, то хотя бы...
[14:31.000 --> 14:32.000]  Нормальный.
[14:33.000 --> 14:35.000]  Давайте все судьбу.
[14:36.000 --> 14:37.000]  Вот.
[14:37.000 --> 14:39.000]  Значит, проверим, что Pushback...
[14:39.000 --> 14:41.000]  Вот в такой TypeList.
[14:41.000 --> 14:42.000]  Типа Ч.
[14:42.000 --> 14:46.000]  Это будет TypeList от int Double запятая Ч.
[14:50.000 --> 14:51.000]  Проверим?
[14:51.000 --> 14:52.000]  По-моему.
[14:52.000 --> 14:53.000]  Получилось.
[14:55.000 --> 14:56.000]  Подожди, а что...
[14:56.000 --> 14:57.000]  А что получилось?
[14:57.000 --> 14:58.000]  А.
[14:58.000 --> 14:59.000]  Я Pushback-нул.
[14:59.000 --> 15:01.000]  В Int Double запятая Ч.
[15:01.000 --> 15:02.000]  Получилось Int Double запятая Ч.
[15:02.000 --> 15:04.000]  Я сказал, что запустите, а не надо запускать.
[15:07.000 --> 15:09.000]  Это что-то из-за кадра, я не знаю.
[15:09.000 --> 15:10.000]  Все, нигде.
[15:10.000 --> 15:12.000]  Я ничего скажу, а у тебя их нет.
[15:14.000 --> 15:16.000]  Вектор TypeID.
[15:16.000 --> 15:18.000]  Чем мы будем этим заниматься?
[15:18.000 --> 15:21.000]  Ну, там же есть TypeID или Typeof, что-то прикольное.
[15:21.000 --> 15:24.000]  TypeID это runtime-вещь.
[15:24.000 --> 15:26.000]  А мы хотим compile-time-container.
[15:26.000 --> 15:28.000]  А может быть, в обычном статике TypeID?
[15:28.000 --> 15:33.000]  Ну, а если не за TypeID, у констекспорта...
[15:33.000 --> 15:34.000]  Как?
[15:34.000 --> 15:36.000]  Констекспорт TypeID?
[15:36.000 --> 15:37.000]  Э...
[15:37.000 --> 15:39.000]  Кстати, не знаю.
[15:39.000 --> 15:41.000]  По-моему...
[15:41.000 --> 15:42.000]  Что происходит?
[15:42.000 --> 15:43.000]  Я ничего не вижу.
[15:43.000 --> 15:45.000]  Ты не про что не про то, что...
[15:45.000 --> 15:47.000]  Все, вот здесь сейчас написано pushback.
[15:47.000 --> 15:49.000]  Вот у нас есть struct pushback.
[15:49.000 --> 15:50.000]  Да.
[15:50.000 --> 15:52.000]  Он принимает один аргумент.
[15:52.000 --> 15:53.000]  Два аргумента.
[15:53.000 --> 15:55.000]  И еще куча аргументов TypeList.
[15:55.000 --> 15:57.000]  А мы ему передали list и te.
[15:57.000 --> 15:59.000]  Нет, нет, нет.
[15:59.000 --> 16:02.000]  Этот pushback, он от двух шаблонных параметров.
[16:02.000 --> 16:04.000]  Первый из которых TypeList, а второй te.
[16:04.000 --> 16:06.000]  О-о-о!
[16:06.000 --> 16:09.000]  А от любого другого, на больше много параметров,
[16:09.000 --> 16:11.000]  его вызывать нельзя и будет te.
[16:12.000 --> 16:14.000]  Э, молодец.
[16:17.000 --> 16:18.000]  Это еще не так.
[16:18.000 --> 16:20.000]  Скоро станет.
[16:20.000 --> 16:21.000]  Окей.
[16:21.000 --> 16:23.000]  Понимаете ли вы, почему такими способами
[16:23.000 --> 16:25.000]  получится резать pullback?
[16:25.000 --> 16:27.000]  Ну, получится, но не получится.
[16:27.000 --> 16:28.000]  Не получится.
[16:28.000 --> 16:29.000]  Прям вообще не получится.
[16:29.000 --> 16:30.000]  Мы не сможем, да, сейчас.
[16:30.000 --> 16:32.000]  Ну, в смысле, вот так в лоб не сможем.
[16:32.000 --> 16:33.000]  Да.
[16:33.000 --> 16:36.000]  Мы только за квадрат сможем popback сделать.
[16:36.000 --> 16:40.000]  А почему popback от TypeList и te?
[16:40.000 --> 16:43.000]  Потому что, чтобы нам сделать popback,
[16:43.000 --> 16:45.000]  нам здесь надо написать TypeList,
[16:45.000 --> 16:47.000]  te многоточие, te запятая te.
[16:47.000 --> 16:48.000]  А так нельзя.
[16:48.000 --> 16:51.000]  Нельзя специализировать от te.
[16:51.000 --> 16:54.000]  Написать typeName многоточие te,
[16:54.000 --> 16:56.000]  te запятая typeName te, можно.
[16:56.000 --> 17:00.000]  А вот написать в специализации
[17:00.000 --> 17:01.000]  Type многоточие te.
[17:01.000 --> 17:02.000]  Нет, так тоже нельзя.
[17:02.000 --> 17:04.000]  Что, type после многоточия разве можно?
[17:04.000 --> 17:06.000]  Нет, в объявлении шаблона можно,
[17:06.000 --> 17:07.000]  а вот в структуре...
[17:07.000 --> 17:08.000]  Что это будет иначе?
[17:08.000 --> 17:09.000]  Ничего.
[17:09.000 --> 17:10.000]  Нет, так можно.
[17:10.000 --> 17:11.000]  Мы это даже однажды делали.
[17:11.000 --> 17:13.000]  У нас, по-моему, один раз этот вопрос уже возникал.
[17:13.000 --> 17:15.000]  Как мы за шаблон попасть?
[17:15.000 --> 17:17.000]  В смысле, он просто увидит,
[17:17.000 --> 17:19.000]  что ты вызываешь так многих аргументов,
[17:19.000 --> 17:21.000]  откусит последнее, а первый сделать пакетом.
[17:21.000 --> 17:23.000]  Короче, так он умеет, а вот так нет.
[17:23.000 --> 17:24.000]  Но это неважно.
[17:24.000 --> 17:26.000]  В любом случае мы не сможем.
[17:26.000 --> 17:27.000]  Ну, а...
[17:33.000 --> 17:35.000]  Это только в экспрешенах,
[17:35.000 --> 17:37.000]  а у нас тут нет ни одного экспрешена пока.
[17:39.000 --> 17:40.000]  Вот.
[17:42.000 --> 17:45.000]  Как нам сделать что?
[17:45.000 --> 17:46.000]  Ну, например,
[17:48.000 --> 17:49.000]  add
[17:49.000 --> 17:50.000]  или...
[17:51.000 --> 17:53.000]  Ну, давайте сделаем обращение по имбексу.
[17:53.000 --> 17:55.000]  Давайте в квадратной скобочке.
[17:55.000 --> 17:57.000]  Квадратной скобочке мы не сможем сделать.
[17:57.000 --> 17:59.000]  Давайте сделаем обращение по имбексу.
[17:59.000 --> 18:01.000]  Можно назвать нашу структуру просто
[18:01.000 --> 18:03.000]  Square Veteran Braces
[18:03.000 --> 18:05.000]  Square Braces
[18:07.000 --> 18:09.000]  Square Braces T
[18:13.000 --> 18:15.000]  Вот хорошо.
[18:19.000 --> 18:21.000]  Значит, Teamgrade.
[18:21.000 --> 18:23.000]  Какая была ваша методика?
[18:29.000 --> 18:31.000]  Ну, мне надо
[18:31.000 --> 18:33.000]  сделать...
[18:35.000 --> 18:37.000]  Он должен быть фиксированным?
[18:37.000 --> 18:38.000]  Да.
[18:38.000 --> 18:40.000]  Add, она должна принимать число
[18:40.000 --> 18:42.000]  и Type List.
[18:42.000 --> 18:44.000]  Да, спускаться вниз, пока у нас...
[18:44.000 --> 18:46.000]  Вот.
[18:46.000 --> 18:48.000]  А, поэтому, мы...
[18:52.000 --> 18:54.000]  Ой, size T.
[18:57.000 --> 18:59.000]  Я здесь не буду даже, потому что я
[18:59.000 --> 19:01.000]  это без тела оставлю.
[19:05.000 --> 19:06.000]  Вот.
[19:06.000 --> 19:08.000]  И специализация для нужных мне типов.
[19:11.000 --> 19:13.000]  А надо голову отсоединить отдельно?
[19:15.000 --> 19:17.000]  Как же это прекрасно заниматься?
[19:18.000 --> 19:20.000]  Add,
[19:20.000 --> 19:22.000]  где первый шаблонный аргумент
[19:22.000 --> 19:24.000]  это...
[19:24.000 --> 19:26.000]  Вообще, я бы, конечно,
[19:26.000 --> 19:28.000]  сделал add
[19:30.000 --> 19:32.000]  чтобы index был первым
[19:32.000 --> 19:34.000]  шаблонным аргументом.
[19:34.000 --> 19:36.000]  А этот,
[19:36.000 --> 19:38.000]  второй.
[19:40.000 --> 19:42.000]  Index запитает Type List
[19:44.000 --> 19:46.000]  в тис многоточие.
[19:47.000 --> 19:49.000]  Да, нужно
[19:49.000 --> 19:51.000]  в другом порядке.
[19:51.000 --> 19:53.000]  Ну, чтобы я писал add по индексу
[19:53.000 --> 19:55.000]  как бы от Type List.
[19:55.000 --> 19:57.000]  Ну,
[19:57.000 --> 19:59.000]  может быть...
[19:59.000 --> 20:01.000]  Не знаю.
[20:01.000 --> 20:03.000]  Я очень плохо выживу pushback
[20:03.000 --> 20:05.000]  от листа.
[20:05.000 --> 20:07.000]  Может, все-таки лучше от листа.
[20:07.000 --> 20:09.000]  Сейчас мы...
[20:09.000 --> 20:11.000]  Сейчас я напишу add, и потом мы все
[20:11.000 --> 20:13.000]  сделаем по-любому, я думаю.
[20:13.000 --> 20:15.000]  Значит, как сделать add?
[20:17.000 --> 20:19.000]  Я...
[20:19.000 --> 20:21.000]  Голову, видимо, придется
[20:21.000 --> 20:23.000]  откусить, да.
[20:23.000 --> 20:25.000]  Голову, видимо, придется откусить, да.
[20:25.000 --> 20:27.000]  Голову надо откусить,
[20:27.000 --> 20:29.000]  но я пишу index и add.
[20:29.000 --> 20:31.000]  Если нет, она не называется
[20:31.000 --> 20:33.000]  index-1.
[20:33.000 --> 20:35.000]  Стоп.
[20:35.000 --> 20:37.000]  Если не называется для индекса,
[20:37.000 --> 20:39.000]  ну и все.
[20:39.000 --> 20:41.000]  Значит,
[20:41.000 --> 20:43.000]  у нас будет
[20:43.000 --> 20:45.000]  type-name-head, получается.
[20:45.000 --> 20:47.000]  Type-name
[20:47.000 --> 20:49.000]  многоточие tail.
[20:53.000 --> 20:55.000]  Я правильно понимаю,
[20:55.000 --> 20:57.000]  что мы уже официально уверены,
[20:57.000 --> 20:59.000]  что все животные это только голова
[20:59.000 --> 21:01.000]  и хвост.
[21:03.000 --> 21:05.000]  И что мы делаем-то?
[21:05.000 --> 21:07.000]  Ну, дальше надо проверить то,
[21:07.000 --> 21:09.000]  что index 0?
[21:09.000 --> 21:11.000]  Index 0 точно, потому что иначе мы в специализации.
[21:11.000 --> 21:13.000]  Значит, нужно просто type identity.
[21:13.000 --> 21:15.000]  Но нам надо сказать, что мы
[21:15.000 --> 21:17.000]  type-identity, почему плохо?
[21:17.000 --> 21:19.000]  Нехрена, буквально.
[21:19.000 --> 21:21.000]  От add,
[21:21.000 --> 21:23.000]  от type-list
[21:23.000 --> 21:25.000]  tail
[21:25.000 --> 21:27.000]  index-1.
[21:27.000 --> 21:29.000]  Типа...
[21:29.000 --> 21:31.000]  Мне не нравится, мне вообще не нравится.
[21:31.000 --> 21:33.000]  Не, ну, мне тоже пока не нравится,
[21:33.000 --> 21:35.000]  и поэтому мы сейчас все переделаем.
[21:35.000 --> 21:37.000]  Просто будет приключение количества наследников.
[21:37.000 --> 21:39.000]  Да, да, да.
[21:39.000 --> 21:41.000]  Это не очень хорошо.
[21:41.000 --> 21:43.000]  Мы делали это в тупую, без инструментов,
[21:43.000 --> 21:45.000]  сколько там появилось type-identity,
[21:45.000 --> 21:47.000]  мы делали это лучше.
[21:47.000 --> 21:49.000]  Типа, мы просто объявляли
[21:49.000 --> 21:51.000]  внутри...
[21:51.000 --> 21:53.000]  Сейчас можно здесь внутри объявить,
[21:53.000 --> 21:55.000]  type-name что-то там,
[21:55.000 --> 21:57.000]  using что-то там
[21:57.000 --> 21:59.000]  равно type-name.
[21:59.000 --> 22:01.000]  Ну, мы и так сделаем, если так тебе больше нравится.
[22:01.000 --> 22:03.000]  Я не понял, причем мы здесь.
[22:03.000 --> 22:05.000]  Потому что мы наследоваться...
[22:05.000 --> 22:07.000]  Мы наследоваться не будем миллиарды раз.
[22:07.000 --> 22:09.000]  Типа, type-list не хочет identity,
[22:09.000 --> 22:11.000]  он хочет 2 раза больше.
[22:11.000 --> 22:13.000]  Так, и нам нужна специализация
[22:13.000 --> 22:15.000]  для нуля, да?
[22:15.000 --> 22:17.000]  А вы или надо написать?
[22:17.000 --> 22:19.000]  Это штука вы или?
[22:19.000 --> 22:21.000]  Еще раз мы type-name.
[22:23.000 --> 22:25.000]  Using type равно
[22:25.000 --> 22:27.000]  add
[22:27.000 --> 22:29.000]  type
[22:29.000 --> 22:31.000]  и еще type-name.
[22:33.000 --> 22:35.000]  Так, а теперь
[22:35.000 --> 22:37.000]  для нуля все то же самое.
[22:39.000 --> 22:41.000]  Зачем я это сделал выше, не знаю,
[22:41.000 --> 22:43.000]  но не важно.
[22:47.000 --> 22:49.000]  Так,
[22:49.000 --> 22:51.000]  add
[22:51.000 --> 22:53.000]  от вот этого и нуля
[22:53.000 --> 22:55.000]  using type равно
[22:55.000 --> 22:57.000]  add.
[22:57.000 --> 22:59.000]  Да?
[22:59.000 --> 23:01.000]  Ну, и template type-name
[23:01.000 --> 23:03.000]  что?
[23:03.000 --> 23:05.000]  Type-name T, type-name
[23:05.000 --> 23:07.000]  type-name
[23:07.000 --> 23:09.000]  не type-name, а size-T.
[23:09.000 --> 23:11.000]  Type-name T,
[23:11.000 --> 23:13.000]  size-T
[23:13.000 --> 23:15.000]  index
[23:17.000 --> 23:19.000]  using type
[23:21.000 --> 23:23.000]  add
[23:23.000 --> 23:25.000]  type-name
[23:29.000 --> 23:31.000]  type-name
[23:31.000 --> 23:33.000]  add
[23:33.000 --> 23:35.000]  от T as index
[23:35.000 --> 23:37.000]  и от index
[23:37.000 --> 23:39.000]  вначале.
[23:39.000 --> 23:41.000]  А, вы меня переделали чего?
[23:41.000 --> 23:43.000]  Точки запятые.
[23:43.000 --> 23:45.000]  Точки запятые не хватает, да, спасибо, а то мы сейчас
[23:45.000 --> 23:47.000]  не бажали этого.
[23:51.000 --> 23:53.000]  А, вот, видите, нельзя.
[23:53.000 --> 23:55.000]  Что?
[23:55.000 --> 23:57.000]  Все-таки нельзя.
[23:57.000 --> 23:59.000]  Сначала size-T надо?
[23:59.000 --> 24:01.000]  Да, забавно.
[24:01.000 --> 24:03.000]  Да, забавно.
[24:03.000 --> 24:05.000]  Я спросил,
[24:05.000 --> 24:07.000]  мне сказали, что все окей.
[24:07.000 --> 24:09.000]  Ну, как минимум
[24:09.000 --> 24:11.000]  можно два пакета
[24:11.000 --> 24:13.000]  в разных делах.
[24:13.000 --> 24:15.000]  Как он их разделит?
[24:15.000 --> 24:17.000]  А?
[24:17.000 --> 24:19.000]  Зачем он отдельно size-T и type-name
[24:19.000 --> 24:21.000]  на той, чего мы тут постоим?
[24:21.000 --> 24:23.000]  Потому что мне надо, чтобы это все
[24:23.000 --> 24:25.000]  было специализация метабол.
[24:25.000 --> 24:27.000]  У нас еще хет есть.
[24:27.000 --> 24:29.000]  Вот, теперь
[24:29.000 --> 24:31.000]  меня эти не являют специализациями.
[24:31.000 --> 24:33.000]  Мне нужно, чтобы
[24:33.000 --> 24:35.000]  сначала был индекс, потом какая-то хрень.
[24:35.000 --> 24:37.000]  Ну, и ноль, аналогично, сверху.
[24:37.000 --> 24:39.000]  И ноль тоже здесь.
[24:39.000 --> 24:41.000]  Ну, обещал шаблон
[24:41.000 --> 24:43.000]  менять с индекс.
[24:43.000 --> 24:45.000]  Да-да-да.
[24:45.000 --> 24:47.000]  Он не закопил.
[24:47.000 --> 24:49.000]  А?
[24:49.000 --> 24:51.000]  А, потому что здесь индекс
[24:51.000 --> 24:53.000]  вначале.
[24:53.000 --> 24:55.000]  Ну, ладно.
[24:55.000 --> 24:57.000]  Я как чувствовал.
[24:57.000 --> 24:59.000]  Ну, потому что
[24:59.000 --> 25:01.000]  не на прессе аналогия тоже.
[25:01.000 --> 25:03.000]  А вот там шаблон
[25:03.000 --> 25:05.000]  меняет тоже.
[25:11.000 --> 25:13.000]  Ну, все.
[25:13.000 --> 25:15.000]  Так, давайте стать аксер, хоть напишем.
[25:15.000 --> 25:17.000]  О, жестко, видимо, сами стать аксер.
[25:17.000 --> 25:19.000]  Да, что-то верим.
[25:19.000 --> 25:21.000]  Я сам признаться
[25:21.000 --> 25:23.000]  не буду.
[25:23.000 --> 25:25.000]  Из C&W, что, например,
[25:25.000 --> 25:27.000]  вот такого type
[25:27.000 --> 25:29.000]  сначала индекс, потом
[25:29.000 --> 25:31.000]  type-list.
[25:31.000 --> 25:33.000]  Int, double,
[25:33.000 --> 25:35.000]  char,
[25:37.000 --> 25:39.000]  zpt, double.
[25:41.000 --> 25:43.000]  Что по
[25:43.000 --> 25:45.000]  индексу 1 в type-list
[25:45.000 --> 25:47.000]  int, double, char лежит double. Мы сейчас проверим.
[25:49.000 --> 25:51.000]  Я уже знаю, что лежит
[25:51.000 --> 25:53.000]  по индексу 1
[25:53.000 --> 25:55.000]  на type-list.
[25:55.000 --> 25:57.000]  А, потому что
[25:57.000 --> 25:59.000]  это я сделал все-таки наоборот.
[25:59.000 --> 26:01.000]  Сначала type-list, потом type-list.
[26:01.000 --> 26:03.000]  Ну да, чтобы красиво было.
[26:03.000 --> 26:05.000]  Здесь я наоборот.
[26:05.000 --> 26:07.000]  Может, не надо это же запутывать?
[26:07.000 --> 26:09.000]  А ты же не будешь пользоваться.
[26:09.000 --> 26:11.000]  Не обязательно.
[26:11.000 --> 26:13.000]  Это просто примеры.
[26:13.000 --> 26:15.000]  Я больше не буду ничего реализовывать.
[26:17.000 --> 26:19.000]  Потому что иначе мы не успеем.
[26:19.000 --> 26:21.000]  Но самое главное.
[26:21.000 --> 26:23.000]  Вот.
[26:23.000 --> 26:25.000]  Это было
[26:25.000 --> 26:27.000]  очень такое
[26:27.000 --> 26:29.000]  type-list в старом стиле.
[26:29.000 --> 26:31.000]  Потому что здесь
[26:31.000 --> 26:33.000]  мы делали все чисто на типах.
[26:33.000 --> 26:35.000]  Вот мы и здесь
[26:35.000 --> 26:37.000]  все довольно
[26:37.000 --> 26:39.000]  плохо. Все довольно
[26:39.000 --> 26:41.000]  грустно. Потому что, например,
[26:41.000 --> 26:43.000]  даже add,
[26:43.000 --> 26:45.000]  даже обращение по индексу
[26:45.000 --> 26:47.000]  требует
[26:47.000 --> 26:49.000]  работать за сколько?
[26:49.000 --> 26:51.000]  Ну вот за квадрат, да.
[26:51.000 --> 26:53.000]  Но если считать, что
[26:53.000 --> 26:55.000]  создание каждого типа...
[26:55.000 --> 26:57.000]  Компилятору приходится инстанцировать
[26:57.000 --> 26:59.000]  n типов, каждый из которых
[26:59.000 --> 27:01.000]  длины от n.
[27:01.000 --> 27:03.000]  Ну что, ему надо...
[27:03.000 --> 27:05.000]  Он сначала инстанцирует type-list
[27:05.000 --> 27:07.000]  от t1,
[27:07.000 --> 27:09.000]  и так далее tn. Потом type-list от t2,
[27:09.000 --> 27:11.000]  и так далее tn. И так
[27:11.000 --> 27:13.000]  до type-lista вот в последнем.
[27:13.000 --> 27:15.000]  Это очень эффективно, мало того,
[27:15.000 --> 27:17.000]  что компилятору приходится
[27:17.000 --> 27:19.000]  инстанцировать кучу типов,
[27:19.000 --> 27:21.000]  еще и рекурсивно.
[27:21.000 --> 27:23.000]  Ну и в целом
[27:23.000 --> 27:25.000]  эта работа очень медленно.
[27:25.000 --> 27:27.000]  Вот такая организация
[27:27.000 --> 27:29.000]  type-lista нас не будет устраивать.
[27:29.000 --> 27:31.000]  И мы сейчас делаем
[27:31.000 --> 27:33.000]  по-другому.
[27:33.000 --> 27:35.000]  И мы будем заниматься, как называемым,
[27:35.000 --> 27:37.000]  value-based метапрограммированием.
[27:37.000 --> 27:39.000]  Вот value-based метапрограммирование
[27:39.000 --> 27:41.000]  это то, что стало возможным с приходом
[27:41.000 --> 27:43.000]  constexpr.
[27:43.000 --> 27:45.000]  Что стало возможным с приходом constexpr?
[27:45.000 --> 27:47.000]  А с приходом constexpr
[27:47.000 --> 27:49.000]  мы будем писать
[27:49.000 --> 27:51.000]  просто настоящие функции,
[27:51.000 --> 27:53.000]  которые будут нам возвращать
[27:53.000 --> 27:55.000]  настоящие значения.
[27:55.000 --> 27:57.000]  И все это будет в compile-type.
[27:57.000 --> 27:59.000]  А потом мы будем писать
[27:59.000 --> 28:01.000]  один раз декл-type и все?
[28:01.000 --> 28:03.000]  Ну да,
[28:03.000 --> 28:05.000]  мы можем декл-type писать,
[28:05.000 --> 28:07.000]  но на самом деле нам даже
[28:07.000 --> 28:09.000]  это не
[28:09.000 --> 28:11.000]  пригодится сегодня.
[28:11.000 --> 28:13.000]  Кстати, сейчас, а зачем нам constexpr,
[28:13.000 --> 28:15.000]  если мы можем просто...
[28:15.000 --> 28:17.000]  Чтобы, кстати, кассерт делать.
[28:17.000 --> 28:19.000]  Смотрите, что я хочу.
[28:19.000 --> 28:21.000]  Я хочу...
[28:21.000 --> 28:23.000]  Я к тому, что мы можем просто написать
[28:23.000 --> 28:25.000]  функции и писать декл-type.
[28:29.000 --> 28:31.000]  Ну мы можем,
[28:31.000 --> 28:33.000]  но я не так собираюсь делать.
[28:33.000 --> 28:35.000]  Value-based
[28:35.000 --> 28:37.000]  type-list.
[28:37.000 --> 28:39.000]  Смотрите.
[28:39.000 --> 28:41.000]  Я начну с того же самого.
[28:41.000 --> 28:43.000]  Напишу
[28:43.000 --> 28:45.000]  template.
[28:45.000 --> 28:47.000]  Нет, я так не буду делать.
[28:47.000 --> 28:49.000]  Я просто скажу
[28:49.000 --> 28:51.000]  cp-type-list
[28:51.000 --> 28:53.000]  value-based-type-list.
[28:57.000 --> 28:59.000]  И открою value-based-type-list
[28:59.000 --> 29:01.000]  и удалю все.
[29:01.000 --> 29:03.000]  Вот начинается по месту.
[29:03.000 --> 29:05.000]  Вот.
[29:09.000 --> 29:11.000]  Я
[29:11.000 --> 29:13.000]  сделаю вот что.
[29:13.000 --> 29:15.000]  Сначала я напишу
[29:15.000 --> 29:17.000]  операторы сравнения.
[29:23.000 --> 29:25.000]  Я буду считать
[29:25.000 --> 29:27.000]  два type-lists равными,
[29:27.000 --> 29:29.000]  тогда и только тогда, когда я
[29:29.000 --> 29:31.000]  буду писать декл-type.
[29:31.000 --> 29:33.000]  Это из same.
[29:33.000 --> 29:35.000]  Ну да.
[29:35.000 --> 29:37.000]  Чтобы мне не делать из same,
[29:37.000 --> 29:39.000]  я хочу, чтобы функция просто была.
[29:39.000 --> 29:41.000]  Я буду говорить
[29:41.000 --> 29:43.000]  const-export
[29:43.000 --> 29:45.000]  обязательно.
[29:45.000 --> 29:47.000]  Можете, пожалуйста,
[29:47.000 --> 29:49.000]  вкратце наумить, что это за бред
[29:49.000 --> 29:51.000]  с тремя торгующими?
[29:51.000 --> 29:53.000]  Два
[29:53.000 --> 29:55.000]  пакета параметров.
[29:55.000 --> 29:57.000]  Пакет, смотри.
[29:57.000 --> 29:59.000]  Как их передать?
[29:59.000 --> 30:01.000]  Я принимаю параметры.
[30:01.000 --> 30:03.000]  У меня будет type-list
[30:03.000 --> 30:05.000]  js многоточие,
[30:05.000 --> 30:07.000]  type-list us многоточие.
[30:09.000 --> 30:11.000]  Я ничего не понял.
[30:11.000 --> 30:13.000]  Вот я хочу его
[30:13.000 --> 30:15.000]  откуда-то вызвать.
[30:15.000 --> 30:17.000]  Если вызвать от двух type-lists.
[30:17.000 --> 30:19.000]  Нет, ты можешь вызывать
[30:19.000 --> 30:21.000]  его только от двух type-lists.
[30:21.000 --> 30:23.000]  Когда ты вызываешь от двух type-lists,
[30:23.000 --> 30:25.000]  он понимает
[30:25.000 --> 30:27.000]  от каких пакетов были type-lists.
[30:27.000 --> 30:29.000]  И эти пакеты представляют параметр шаблона.
[30:31.000 --> 30:33.000]  Здесь-то у него однозначно все.
[30:35.000 --> 30:37.000]  Вот. Тут будет false.
[30:39.000 --> 30:41.000]  А будет еще специализация.
[30:43.000 --> 30:45.000]  Перегрузка?
[30:45.000 --> 30:47.000]  Да, давай, перегрузка.
[30:47.000 --> 30:49.000]  Перегрузка вот такая.
[30:49.000 --> 30:51.000]  Если типа одинаковая...
[30:51.000 --> 30:53.000]  В чем разница специализация шаблона функции перегрузки?
[30:53.000 --> 30:55.000]  Специализация
[30:55.000 --> 30:57.000]  Шаблона функции
[30:57.000 --> 30:59.000]  это то, что начинается с темплея
[30:59.000 --> 31:01.000]  и простые угловые скобочки.
[31:01.000 --> 31:03.000]  Вот это будет true.
[31:03.000 --> 31:05.000]  Так, в стандарте написано.
[31:05.000 --> 31:07.000]  Так и есть. Я сказал, как есть.
[31:11.000 --> 31:13.000]  Еще у меня будет оператор неравном.
[31:15.000 --> 31:17.000]  Который будет наоборот.
[31:17.000 --> 31:19.000]  Здесь будет true, а здесь false.
[31:19.000 --> 31:21.000]  А нельзя return
[31:21.000 --> 31:23.000]  противоположность и оператор вовно?
[31:25.000 --> 31:27.000]  Ну, можно, но
[31:27.000 --> 31:29.000]  я уже написал так.
[31:29.000 --> 31:31.000]  Тут мне придется имена давать.
[31:31.000 --> 31:33.000]  Заметьте, я параметры принимаю безымянные.
[31:33.000 --> 31:35.000]  Я никогда не собираюсь их изменить.
[31:37.000 --> 31:39.000]  Кстати, это можно было еще как только ты
[31:39.000 --> 31:41.000]  его смартфлекс поделать, потому что
[31:41.000 --> 31:43.000]  один return это ничего.
[31:43.000 --> 31:45.000]  Да, это можно было
[31:45.000 --> 31:47.000]  начинать себе плюс 11 делать уже.
[31:47.000 --> 31:49.000]  В принципе, ну нет, не все,
[31:49.000 --> 31:51.000]  что мы тут пишем себе плюс 11.
[31:51.000 --> 31:53.000]  Что?
[31:59.000 --> 32:01.000]  Так, окей.
[32:01.000 --> 32:03.000]  Давайте напишем push.
[32:07.000 --> 32:09.000]  Даже я написал памятку.
[32:09.000 --> 32:11.000]  Чего-то по порядке надо написать.
[32:11.000 --> 32:13.000]  Popfront сначала напишем.
[32:15.000 --> 32:17.000]  В каком формате?
[32:17.000 --> 32:19.000]  Я хочу, чтобы у меня была функция popfront.
[32:19.000 --> 32:21.000]  Чтобы я мог стать
[32:21.000 --> 32:23.000]  кассертом.
[32:23.000 --> 32:25.000]  Вот так делать.
[32:25.000 --> 32:27.000]  Popfront
[32:27.000 --> 32:29.000]  от
[32:29.000 --> 32:31.000]  TypeList
[32:31.000 --> 32:33.000]  с параметрами
[32:33.000 --> 32:35.000]  int double check.
[32:37.000 --> 32:39.000]  Сейчас увидим, что он хочет написать.
[32:39.000 --> 32:41.000]  Круглые скобочки?
[32:41.000 --> 32:43.000]  Круглые скобочки, наверное.
[32:43.000 --> 32:45.000]  Ты хочешь метод
[32:45.000 --> 32:47.000]  TypeList, который возвращает другой
[32:47.000 --> 32:49.000]  TypeList?
[32:53.000 --> 32:55.000]  Я еще не понимаю, что сейчас может
[32:55.000 --> 32:57.000]  стать кассертом стоять в линзете.
[32:59.000 --> 33:01.000]  У нас сейчас popfront это функция.
[33:01.000 --> 33:03.000]  Чтобы она не вернула,
[33:03.000 --> 33:05.000]  она не может вернуть TypeList.
[33:05.000 --> 33:07.000]  Она возвращает что-то типа TypeList.
[33:07.000 --> 33:09.000]  Объект.
[33:09.000 --> 33:11.000]  Смотри,
[33:11.000 --> 33:13.000]  вот у меня popfront
[33:13.000 --> 33:15.000]  от TypeList
[33:17.000 --> 33:19.000]  и
[33:19.000 --> 33:21.000]  там
[33:21.000 --> 33:23.000]  сконструируется объект
[33:23.000 --> 33:25.000]  по умолчанию
[33:25.000 --> 33:27.000]  и вызываются еще конструкторы всех
[33:27.000 --> 33:29.000]  внутренних...
[33:29.000 --> 33:31.000]  Он пустой.
[33:31.000 --> 33:33.000]  У нас структура пустая.
[33:33.000 --> 33:35.000]  Возвращаемый тип такой.
[33:35.000 --> 33:37.000]  Он уже знает, какой.
[33:37.000 --> 33:39.000]  Он его возвращает объект по умолчанию
[33:39.000 --> 33:41.000]  такого типа.
[33:41.000 --> 33:43.000]  То есть по дефолту мы можем
[33:43.000 --> 33:45.000]  в нешевеленном месте, но в любом типе.
[33:45.000 --> 33:47.000]  Это не нешалайзер-лист.
[33:47.000 --> 33:49.000]  Это скорее...
[33:51.000 --> 33:53.000]  И что это?
[33:53.000 --> 33:55.000]  Я не понимаю, что это.
[33:57.000 --> 33:59.000]  Этот дождь-то будет
[33:59.000 --> 34:01.000]  передаваться в конструктор.
[34:01.000 --> 34:03.000]  То есть я здесь мог бы написать фигурные
[34:03.000 --> 34:05.000]  скобочки?
[34:05.000 --> 34:07.000]  Можно бы написать std string и
[34:07.000 --> 34:09.000]  фигурные скобочки в 5.
[34:09.000 --> 34:11.000]  И тебе бы вернулся стринг
[34:11.000 --> 34:13.000]  из 5...
[34:13.000 --> 34:15.000]  Если бы я написал
[34:15.000 --> 34:17.000]  возвращается std string
[34:17.000 --> 34:19.000]  и return фигурные скобочки 5.
[34:19.000 --> 34:21.000]  Я не уверен, что для return специально сделали
[34:21.000 --> 34:23.000]  отдельную конструкцию.
[34:23.000 --> 34:25.000]  Я не уверен, что формально является
[34:25.000 --> 34:27.000]  этот нешалайзер-лист.
[34:27.000 --> 34:29.000]  Нет, это не нешалайзер-лист.
[34:29.000 --> 34:31.000]  Это copy initialization. Мы же можем написать
[34:31.000 --> 34:33.000]  вектор равно и фигурные скобочки с
[34:33.000 --> 34:35.000]  что-нибудь.
[34:35.000 --> 34:37.000]  А вот это будет тайп-лист.
[34:37.000 --> 34:39.000]  А вот это будет тайп-лист.
[34:39.000 --> 34:41.000]  А вот это будет тайп-лист.
[34:41.000 --> 34:43.000]  Ну да.
[34:43.000 --> 34:45.000]  Да, это наверное все-таки нешалайзер-лист.
[34:45.000 --> 34:47.000]  Правда.
[34:47.000 --> 34:49.000]  Это...
[34:49.000 --> 34:51.000]  ...через год у вас будет.
[34:51.000 --> 34:53.000]  Что?
[34:53.000 --> 34:55.000]  Что будет через год?
[34:55.000 --> 34:57.000]  Co-return.
[34:57.000 --> 34:59.000]  Кознак, подчеркни, return.
[34:59.000 --> 35:01.000]  А это Co-return?
[35:01.000 --> 35:03.000]  Это Co-return, да.
[35:03.000 --> 35:05.000]  В этом я буду сказать мнение.
[35:07.000 --> 35:09.000]  Окей, все, поп-фронт написали.
[35:09.000 --> 35:11.000]  Давайте напишем push-фронт.
[35:15.000 --> 35:17.000]  Как написать push-фронт?
[35:19.000 --> 35:21.000]  TypeName многоточие.
[35:21.000 --> 35:23.000]  На самом деле опять typeName.
[35:23.000 --> 35:25.000]  TypeName.ts
[35:25.000 --> 35:27.000]  Type-лист на этот раз будет вот такой.
[35:29.000 --> 35:31.000]  Push-фронт
[35:33.000 --> 35:35.000]  от вот такого
[35:35.000 --> 35:37.000]  тайп-листа.
[35:37.000 --> 35:39.000]  И не писать return пустые скобочки.
[35:41.000 --> 35:43.000]  Ну и мы можем проверить, что
[35:43.000 --> 35:45.000]  push-фронт
[35:45.000 --> 35:47.000]  от
[35:49.000 --> 35:51.000]  вот такого тайп-листа
[35:51.000 --> 35:53.000]  это вот такой тайп-лист.
[35:55.000 --> 35:57.000]  И не писать return, это все еще не правильно?
[35:59.000 --> 36:01.000]  В смысле?
[36:01.000 --> 36:03.000]  Где?
[36:03.000 --> 36:05.000]  В функцию без тела ты хочешь?
[36:05.000 --> 36:07.000]  Ну с пустым.
[36:07.000 --> 36:09.000]  В смысле тогда это вот вызываемый.
[36:09.000 --> 36:11.000]  Ну а он не догадается, что по умолчанию?
[36:11.000 --> 36:13.000]  Нет, я не догадаюсь.
[36:13.000 --> 36:15.000]  Ну в смысле это очень...
[36:15.000 --> 36:17.000]  Маленькое количество кейсов,
[36:17.000 --> 36:19.000]  где ты поставишь в функцию
[36:19.000 --> 36:21.000]  значение умолчания.
[36:21.000 --> 36:23.000]  Типа как в мейне.
[36:23.000 --> 36:25.000]  Это только в мейне так работает,
[36:25.000 --> 36:27.000]  в остальных функциях нет.
[36:27.000 --> 36:29.000]  Окей.
[36:29.000 --> 36:31.000]  Ну можно
[36:31.000 --> 36:33.000]  написать push-back, но
[36:33.000 --> 36:35.000]  не интересно.
[36:35.000 --> 36:37.000]  Pop-back, вот с поп-back опять проблема.
[36:39.000 --> 36:41.000]  Та же самая, что и раньше была.
[36:41.000 --> 36:43.000]  Написать pop-back
[36:43.000 --> 36:45.000]  не очень понятно как,
[36:45.000 --> 36:47.000]  потому что
[36:47.000 --> 36:49.000]  я не могу сделать...
[36:51.000 --> 36:53.000]  А, нет, стоп.
[36:53.000 --> 36:55.000]  Может быть я не могу.
[36:55.000 --> 36:57.000]  Ну давайте подумаем, смогу ли я написать
[36:57.000 --> 36:59.000]  pop-back.
[36:59.000 --> 37:01.000]  Что, это все, я скомпинировал.
[37:01.000 --> 37:03.000]  Где имп?
[37:07.000 --> 37:09.000]  Так, подожди.
[37:09.000 --> 37:11.000]  А вот это, кстати, странно.
[37:11.000 --> 37:13.000]  А потому что я
[37:13.000 --> 37:15.000]  не тот файл все это время компилирую,
[37:15.000 --> 37:17.000]  может быть...
[37:19.000 --> 37:21.000]  Какие хорошие тесты.
[37:21.000 --> 37:23.000]  Да, да, да.
[37:23.000 --> 37:25.000]  А, это вы, конечно.
[37:27.000 --> 37:29.000]  Это вы хорошо заметили.
[37:29.000 --> 37:31.000]  В какой-то момент я мог
[37:31.000 --> 37:33.000]  позайти слишком далеко.
[37:33.000 --> 37:35.000]  Это все компилируется.
[37:35.000 --> 37:37.000]  Да, все компилируется.
[37:37.000 --> 37:39.000]  Идем дальше.
[37:39.000 --> 37:41.000]  Хорошо.
[37:41.000 --> 37:43.000]  Окей, ну как сделать
[37:43.000 --> 37:45.000]  push-back?
[37:45.000 --> 37:47.000]  Опять нам надо сделать
[37:47.000 --> 37:49.000]  take-name-t, take-name-ts,
[37:49.000 --> 37:51.000]  take-list, take-list,
[37:51.000 --> 37:53.000]  take-list, take-list,
[37:53.000 --> 37:55.000]  take-list, take-list,
[37:55.000 --> 37:57.000]  take-list, take-list,
[37:57.000 --> 37:59.000]  take-list, take-list,
[37:59.000 --> 38:01.000]  take-list,
[38:01.000 --> 38:03.000]  push-back,
[38:03.000 --> 38:05.000]  take-list, take-list,
[38:05.000 --> 38:07.000]  take-list,
[38:07.000 --> 38:09.000]  take-list,
[38:09.000 --> 38:11.000]  and that's it.
[38:11.000 --> 38:13.000]  So, push-back, how to identify it.
[38:13.000 --> 38:15.000]  Нас же ничего лучше
[38:15.000 --> 38:25.840]  не сталоよ,
[38:25.840 --> 38:40.840]  Ну, конкретно с pushback, pushfront мы не выиграли, хотя мы все равно выиграли, потому что компилятору легче делать из-за функций, чем и сейв и вот это все.
[38:40.840 --> 38:45.840]  Ну сейчас на полмаге выиграли, а точка это непонятно, как у нас будет лучше.
[38:45.840 --> 38:46.840]  Чего?
[38:46.840 --> 38:49.840]  Как у нас будет лучше точка это.
[38:49.840 --> 38:54.840]  А вот сейчас я хочу до этого успеть дойти.
[38:54.840 --> 39:03.840]  Ну pushback вроде понятно, typelist ts запятая t, pushback от вот такого.
[39:03.840 --> 39:08.840]  А вот нам нужно в шаблонных параметрах сначала t, а потом ts?
[39:08.840 --> 39:16.840]  Я сначала t, потом ts и проверю, что pushback от вот этого, это будет вот такой typelist.
[39:16.840 --> 39:18.840]  Давайте проверю.
[39:18.840 --> 39:20.840]  Pushfront, pushfront.
[39:20.840 --> 39:21.840]  Pushback.
[39:21.840 --> 39:22.840]  Pushback.
[39:27.840 --> 39:28.840]  Работает.
[39:28.840 --> 39:36.840]  Ну вот с pushback-ом так просто кажется не выйдет, потому что, потому что, почему?
[39:36.840 --> 39:44.840]  Ну вот нам нужно вернуть вот такой typelist, а принять надо вот такой typelist.
[39:44.840 --> 39:49.840]  И кажется, что такой вот типов сейчас не сработает.
[39:51.840 --> 39:53.840]  Ну может уже по-приветному.
[39:57.840 --> 40:00.840]  Давайте проверим еще раз.
[40:00.840 --> 40:06.840]  Кажется, что такой типов не сработает, но может быть я и не прав.
[40:06.840 --> 40:07.840]  Давайте проверим.
[40:07.840 --> 40:09.840]  Значит pushback.
[40:10.840 --> 40:11.840]  Почему у нас?
[40:11.840 --> 40:12.840]  Нам надо первым править.
[40:12.840 --> 40:15.840]  Да, мне не нужен шаблонный параметр t и все.
[40:15.840 --> 40:17.840]  И он не поймет, как его отпустить от конца.
[40:17.840 --> 40:18.840]  Вот в этом проблема.
[40:18.840 --> 40:19.840]  Давайте попробуем.
[40:21.840 --> 40:22.840]  Ну.
[40:24.840 --> 40:26.840]  Ну я думаю, что он не поймет.
[40:26.840 --> 40:28.840]  Это должно быть int double char.
[40:28.840 --> 40:30.840]  Должно стать просто double char.
[40:30.840 --> 40:31.840]  Ой.
[40:39.840 --> 40:40.840]  Вот.
[40:40.840 --> 40:46.840]  Ну, к сожалению, не получается вывести шаблонный параметр t.
[40:46.840 --> 40:49.840]  А почему мы не можем дать шаблонный параметр t?
[40:49.840 --> 40:51.840]  Мы не знаем, что это мы можем сделать.
[40:51.840 --> 40:53.840]  Да, мы очень счастливы.
[40:53.840 --> 40:54.840]  Вот если мы оставим.
[40:54.840 --> 40:58.840]  Ну это странное, типа странный pullback какой-то.
[40:58.840 --> 41:01.840]  Мы просим дать его в конце какой-то конкретный.
[41:03.840 --> 41:04.840]  А если другой попросим?
[41:05.840 --> 41:06.840]  Интересно.
[41:06.840 --> 41:07.840]  CE, конечно.
[41:07.840 --> 41:09.840]  У нас в данной случае хотя бы уже есть L-функция.
[41:09.840 --> 41:13.840]  Ну в общем, pullback пока подвопросим.
[41:15.840 --> 41:17.840]  То есть все-таки можно все прям хорошо?
[41:17.840 --> 41:18.840]  Ну можно будет.
[41:18.840 --> 41:19.840]  Когда-нибудь.
[41:19.840 --> 41:20.840]  Но не всегда.
[41:21.840 --> 41:22.840]  Нет.
[41:23.840 --> 41:26.840]  Когда мы много чего другого реализуем, то это вы потом реализуете.
[41:27.840 --> 41:29.840]  Это будет у нас последней задачей.
[41:29.840 --> 41:30.840]  Да, да, да, да.
[41:31.840 --> 41:33.840]  Но это будет самое простое, что там.
[41:33.840 --> 41:35.840]  А там еще интересно.
[41:35.840 --> 41:36.840]  Сорт.
[41:36.840 --> 41:37.840]  Сорт.
[41:37.840 --> 41:38.840]  Сорт.
[41:39.840 --> 41:43.840]  Я хочу сегодня показать вам сорт на тайп-листе.
[41:43.840 --> 41:44.840]  Вот.
[41:45.840 --> 41:46.840]  Я надеюсь, что можно.
[41:46.840 --> 41:48.840]  Ну чуть-чуть, чуть-чуть, чтобы начали опять в 17-20.
[41:49.840 --> 41:50.840]  Мне кажется, у меня есть моральная права.
[41:50.840 --> 41:52.840]  Мне, кстати, не по моей вине, да.
[41:53.840 --> 41:54.840]  Ну да ладно.
[41:54.840 --> 41:55.840]  Так, давайте напишем.
[41:56.840 --> 41:58.840]  Давайте что-нибудь более интересное напишем.
[41:58.840 --> 42:00.840]  Давайте напишем функцию.
[42:02.840 --> 42:06.840]  Contains, которая проверяет, есть ли в листе такой элемент.
[42:07.840 --> 42:09.840]  Содержит ли лист такой элемент.
[42:09.840 --> 42:10.840]  Ну цена тейтс.
[42:13.840 --> 42:15.840]  Темплей, тайп-лей, многоточие.
[42:16.840 --> 42:17.840]  Тейс.
[42:17.840 --> 42:19.840]  Ну, тайп-нейм-тей, тайп-нейм-тейс.
[42:23.840 --> 42:24.840]  Вот.
[42:25.840 --> 42:26.840]  Значит.
[42:26.840 --> 42:27.840]  Конст-экспорт.
[42:27.840 --> 42:28.840]  Конст-экспорт.
[42:29.840 --> 42:30.840]  Спасибо.
[42:31.840 --> 42:32.840]  Контейтс.
[42:32.840 --> 42:33.840]  Контейтс.
[42:34.840 --> 42:35.840]  Что дальше?
[42:36.840 --> 42:37.840]  Тайп-лист.
[42:37.840 --> 42:38.840]  Тайп-лист.
[42:40.840 --> 42:41.840]  Тейс, многоточие.
[42:43.840 --> 42:44.840]  А ты не нужно принимать.
[42:44.840 --> 42:46.840]  Ты шаблонным аргументом будешь.
[42:47.840 --> 42:48.840]  Вот.
[42:48.840 --> 42:49.840]  Что нам сделать?
[42:49.840 --> 42:50.840]  Давайте подумаем.
[42:50.840 --> 42:51.840]  Как выглядит контейтс?
[42:51.840 --> 42:54.840]  Ну, нам нужно вернуть, типа, что-то, ну, либо, если...
[42:55.840 --> 42:56.840]  Сейчас.
[42:56.840 --> 42:59.840]  Слушайте, а давайте напишем цифру, которая будет проходить на тайп-нейм-тей.
[42:59.840 --> 43:00.840]  Нет.
[43:00.840 --> 43:03.840]  Надо бы из тейтс выделить первый, что ли, так удобно, что-то.
[43:04.840 --> 43:06.840]  Ну, тогда, правда, будет, ну, такая самая тупая.
[43:06.840 --> 43:09.840]  Вот, вот сейчас мы уже начнем выигрывать очень сильно,
[43:09.840 --> 43:14.840]  потому что, если бы мы писали это на шаблонных мета функциях,
[43:14.840 --> 43:18.840]  то нам пришлось бы делать рекурсию шаблону.
[43:18.840 --> 43:20.840]  То есть, понятно, что я могу сейчас обкусить первый тип
[43:21.840 --> 43:24.840]  и вызвать контейнс от всего оставшегося, ну, и,
[43:24.840 --> 43:29.840]  подсмотреть, совпадает ли тип сейчас первым, иначе вызвать от оставшегося и так далее.
[43:29.840 --> 43:30.840]  Я вам запрещаю.
[43:30.840 --> 43:34.840]  Я хочу написать, чтобы это за линию работало,
[43:34.840 --> 43:38.840]  ну, потому что в такой виде это будет за квадрат работать.
[43:38.840 --> 43:40.840]  Как сделать, чтобы это за линию работало?
[43:44.840 --> 43:51.840]  Мы уже умели проверять, есть ли тейтс среди данного кричка.
[43:51.840 --> 43:58.840]  В смысле, можем fold expression типа, мы хотим проверить что?
[43:58.840 --> 43:59.840]  Да.
[43:59.840 --> 44:03.840]  Вот, я передаю его, а принимаю тайп-лист.
[44:03.840 --> 44:04.840]  И что я делаю теперь?
[44:04.840 --> 44:09.840]  Ну, то же самое я делаю, только вместо этого я говорю
[44:11.840 --> 44:16.840]  f от t, s, y.y.y.
[44:21.840 --> 44:22.840]  Так.
[44:23.840 --> 44:25.840]  Find it, можно что-то название применить?
[44:25.840 --> 44:26.840]  Find it, да.
[44:26.840 --> 44:32.840]  Вот это, кстати, только начиная с C++, в C++17 это не было бы скомпилироваться,
[44:32.840 --> 44:38.840]  потому что find, std find не было в std export, но до C++2.
[44:38.840 --> 44:40.840]  Ну, std find мы сами можем сделать.
[44:40.840 --> 44:41.840]  Да, ну, std find можно фориком.
[44:41.840 --> 44:43.840]  Мы с тобой еще не подходили.
[44:43.840 --> 44:44.840]  Ну, я не знаю.
[44:44.840 --> 44:45.840]  Ну, я не знаю.
[44:45.840 --> 44:46.840]  Ну, я не знаю.
[44:46.840 --> 44:47.840]  Ну, я не знаю.
[44:47.840 --> 44:48.840]  Ну, я не знаю.
[44:48.840 --> 44:49.840]  Ну, я не знаю.
[44:49.840 --> 44:50.840]  Ну, я не знаю.
[44:50.840 --> 44:51.840]  Ну, я не знаю.
[44:52.840 --> 44:53.840]  Ну, я…
[44:58.840 --> 45:03.660]  Я абсолютно горел было,습니다, чтобы я просто в Challenger за Ostsol Kids
[45:03.660 --> 45:08.920]  Especially when we got testing, when we presented the first game conscious
[45:08.920 --> 45:13.460]  We had people talking aboutィwork, we have people talking about it.
[45:13.460 --> 45:14.480]  It's fun, isn't it?
[45:14.480 --> 45:15.480]  Yep.
[45:15.480 --> 45:16.480]  Yeah.
[45:16.480 --> 45:17.480]  Okay.
[45:17.480 --> 45:18.480]  So, now we read the description.
[45:18.480 --> 45:19.480]  We Scotland.
[45:19.480 --> 45:25.480]  Ну, кстати, может быть, и можно.
[45:25.480 --> 45:29.480]  По-моему, Максимов шутил.
[45:29.480 --> 45:33.480]  Нет, вообще, начиная с 2020 авто можно писать.
[45:33.480 --> 45:37.480]  Шутка удалась.
[45:37.480 --> 45:43.480]  Но здесь это не сработает, потому что это же не тип.
[45:43.480 --> 45:55.480]  Если у вас был бы не типовой шаблонный параметр, то можно было бы написать авто, и вы бы могли тогда создать шаблон.
[45:55.480 --> 46:01.480]  Но здесь не сработает авто, потому что он будет ожидать не типовой шаблонный параметр.
[46:01.480 --> 46:03.480]  А передал я ему... ну, короче, не сработает.
[46:03.480 --> 46:05.480]  А авто-авто что-нибудь?
[46:05.480 --> 46:07.480]  Нет.
[46:07.480 --> 46:11.480]  Ты слишком рано родился для этого.
[46:11.480 --> 46:13.480]  Как же это?
[46:13.480 --> 46:15.480]  Видно, что я живу.
[46:15.480 --> 46:17.480]  Это уже поздно.
[46:17.480 --> 46:25.480]  Друзья мои, нам надо успеть реализовать get и reverse.
[46:25.480 --> 46:27.480]  И потом я вам покажу сортировку.
[46:27.480 --> 46:29.480]  Сортировку я не буду реализовывать сам, я ее покажу готовую.
[46:29.480 --> 46:31.480]  Блин.
[46:31.480 --> 46:33.480]  Давайте реализуем get.
[46:33.480 --> 46:39.480]  Значит, я хочу, чтобы у меня была функция get, чтобы она работала за линию, а не за квадрат.
[46:39.480 --> 46:41.480]  Функция get.
[46:41.480 --> 46:43.480]  В смысле, неважно.
[46:43.480 --> 46:45.480]  Просто что это то же самое.
[46:45.480 --> 46:47.480]  В оригинале, откуда я это брал.
[46:47.480 --> 46:49.480]  Где get?
[46:49.480 --> 46:51.480]  Значит, хорошо.
[46:51.480 --> 46:53.480]  Функция get.
[46:57.480 --> 46:59.480]  Get, понятно.
[46:59.480 --> 47:01.480]  Просто что это одно и то же, что мы делали, что за квадрат.
[47:01.480 --> 47:05.480]  Ну, по индексу я возвращаю, что там лежит.
[47:05.480 --> 47:07.480]  Мне кажется, get более правильное название.
[47:07.480 --> 47:11.480]  Так, значит копим мне шаблонные параметры.
[47:11.480 --> 47:13.480]  У меня будет шаблонный параметр число.
[47:13.480 --> 47:15.480]  Вот тут, кстати, можно и авто написать.
[47:17.480 --> 47:19.480]  Даня, что ты сделал?
[47:19.480 --> 47:21.480]  Замечательно.
[47:21.480 --> 47:23.480]  Concepts for...
[47:23.480 --> 47:25.480]  авто.
[47:25.480 --> 47:29.480]  Вот здесь авто, потому что мы не знаем, какой тип будет.
[47:29.480 --> 47:31.480]  A.
[47:31.480 --> 47:33.480]  A.
[47:33.480 --> 47:35.480]  A.
[47:35.480 --> 47:37.480]  A.
[47:37.480 --> 47:39.480]  A.
[47:39.480 --> 47:41.480]  A.
[47:41.480 --> 47:43.480]  A.
[47:43.480 --> 47:45.480]  А это так.
[47:45.480 --> 47:47.480]  Это здесь я все-таки S.A.S.P. напишу, потому что...
[47:47.480 --> 47:49.480]  Это не приниматель.
[47:49.480 --> 47:51.480]  Это аргумент S.A.S.P., а не как template.
[47:51.480 --> 47:53.480]  Это аргумент S.A.S.P., а не как template.
[47:53.480 --> 47:57.480]  Кажется, это уменьшит поличься template.
[47:58.480 --> 48:00.480]  Так.
[48:00.480 --> 48:02.480]  Что?
[48:02.480 --> 48:04.480]  Что не приниматель?
[48:04.480 --> 48:07.480]  Почему бы это не принимал аргумент S.A.S.P., а не параметр template?
[48:09.480 --> 48:11.480]  Ну...
[48:13.480 --> 48:15.480]  Мне кажется, это как-то...
[48:15.480 --> 48:17.480]  Стоп.
[48:17.480 --> 48:19.480]  Еще раз.
[48:19.480 --> 48:23.480]  У тебя будет одна и та же функция, как бы префиксирована TS, которая...
[48:23.480 --> 48:25.480]  и она будет понимать разные индексы как аргументы.
[48:25.480 --> 48:27.480]  И будет возвращать разные типы.
[48:27.480 --> 48:29.480]  Одна и та же.
[48:29.480 --> 48:31.480]  Это не может быть, такому не может быть.
[48:33.480 --> 48:35.480]  Сейчас.
[48:35.480 --> 48:37.480]  А почему не такое может быть?
[48:37.480 --> 48:39.480]  Еще раз.
[48:39.480 --> 48:41.480]  У нас будет функция S.A.S.P., которая принимает индекс, вот type list.
[48:41.480 --> 48:43.480]  У нее аргументы, шаблоны.
[48:43.480 --> 48:45.480]  Вот эти аргументы type lista.
[48:45.480 --> 48:47.480]  То есть при фиксируемом type list'е и разных индексах она будет решать один и тот же тип.
[48:47.480 --> 48:49.480]  А это невозможно.
[48:49.480 --> 48:51.480]  Она будет очень счастливой.
[48:51.480 --> 48:53.480]  Разной.
[48:53.480 --> 48:55.480]  И они все разные, а по факту будет еще один.
[48:55.480 --> 48:57.480]  Ну пока и мне так кажется.
[48:57.480 --> 48:59.480]  Я перестал понимать.
[49:01.480 --> 49:03.480]  Она должна решать.
[49:05.480 --> 49:07.480]  Вот сейчас видите, авто работает как.
[49:07.480 --> 49:09.480]  Авто смотрит, что мы на самом деле вернули.
[49:09.480 --> 49:11.480]  И вместо того, что мы на самом деле вернули,
[49:11.480 --> 49:13.480]  создает новую шаблонную функцию.
[49:13.480 --> 49:15.480]  Да, индекс как аргумент, у нас будет
[49:15.480 --> 49:17.480]  куча вариантов того, что мы вернули.
[49:17.480 --> 49:19.480]  В теле одной и та же функции.
[49:19.480 --> 49:21.480]  Это бред.
[49:21.480 --> 49:23.480]  В принципе, можно ли было написать
[49:23.480 --> 49:25.480]  следующую конструкцию.
[49:25.480 --> 49:27.480]  Просто
[49:27.480 --> 49:29.480]  авто add.
[49:29.480 --> 49:31.480]  Просто авто функция.
[49:31.480 --> 49:33.480]  Если что-то
[49:33.480 --> 49:35.480]  ретерн штуку одного типа, иначе
[49:35.480 --> 49:37.480]  ретерн штуку другого типа.
[49:37.480 --> 49:39.480]  Это же бред.
[49:39.480 --> 49:41.480]  Так нельзя.
[49:41.480 --> 49:43.480]  Возвращаем и тип.
[49:43.480 --> 49:45.480]  Но да, кажется, это правда.
[49:45.480 --> 49:47.480]  В данном случае,
[49:47.480 --> 49:49.480]  данного индекса и данного
[49:49.480 --> 49:51.480]  номера типов, тип всегда должен быть один и тот же.
[49:51.480 --> 49:53.480]  Он и будет один и тот же.
[49:53.480 --> 49:55.480]  И здесь все будет одно и то же?
[49:55.480 --> 49:57.480]  Нет, потому что если у тебя индекс
[49:57.480 --> 49:59.480]  не перестанет быть шаблонным параметром,
[49:59.480 --> 50:01.480]  то непонятно, какой будет возвращение тип.
[50:03.480 --> 50:05.480]  У тебя разные возвращения типы.
[50:05.480 --> 50:07.480]  Ну все, поэтому так и делаем.
[50:07.480 --> 50:09.480]  А как?
[50:15.480 --> 50:17.480]  Я, к сожалению,
[50:17.480 --> 50:19.480]  я себе
[50:19.480 --> 50:21.480]  заготовил шпаргал, потому что я
[50:21.480 --> 50:23.480]  не смогу это быстро произвести.
[50:23.480 --> 50:25.480]  Поэтому воспроизведу наизусть.
[50:25.480 --> 50:27.480]  Воспроизведу быстро, но не наизусть.
[50:27.480 --> 50:29.480]  Если бы у нас было больше времени,
[50:29.480 --> 50:31.480]  я бы, возможно,
[50:31.480 --> 50:33.480]  по...
[50:33.480 --> 50:35.480]  Значит, я сейчас
[50:35.480 --> 50:37.480]  напишу сначала функцию addInfo.
[50:39.480 --> 50:41.480]  Сразу понятно.
[50:41.480 --> 50:43.480]  Тайп-нейм. Не тайп-нейм, а ССТ.
[50:43.480 --> 50:45.480]  Ну, addHelper могу назвать.
[50:47.480 --> 50:49.480]  Тайп-нейм ТС.
[50:51.480 --> 50:53.480]  Значит, функция.
[50:53.480 --> 50:55.480]  FunctionExport.
[51:01.480 --> 51:03.480]  Это не функция,
[51:03.480 --> 51:05.480]  это структура.
[51:05.480 --> 51:07.480]  addHelper.
[51:07.480 --> 51:09.480]  Вот.
[51:09.480 --> 51:11.480]  Ну и у него будет специализация
[51:11.480 --> 51:13.480]  для...
[51:15.480 --> 51:17.480]  Кажется, мы вернулись
[51:17.480 --> 51:19.480]  к СТОКу.
[51:19.480 --> 51:21.480]  Нет, я споймел, почему нет.
[51:21.480 --> 51:23.480]  Тут мне потребуется
[51:23.480 --> 51:25.480]  одна замечательная вещь
[51:25.480 --> 51:27.480]  в стандартной библиотеке,
[51:27.480 --> 51:29.480]  которая называется
[51:29.480 --> 51:31.480]  STD Index Sequence.
[51:31.480 --> 51:33.480]  Сейчас я расскажу, что это такое.
[51:33.480 --> 51:35.480]  Ам...
[51:39.480 --> 51:41.480]  Это все неправильно.
[51:41.480 --> 51:43.480]  Сделал.
[51:45.480 --> 51:47.480]  Мне нужно переменное количество индексов.
[51:47.480 --> 51:49.480]  И вот здесь будет опять
[51:49.480 --> 51:51.480]  переменное количество индексов.
[51:51.480 --> 51:53.480]  А типов не будет вообще.
[51:53.480 --> 51:55.480]  Затянули типы.
[51:55.480 --> 51:57.480]  Значит, getIndex...
[51:57.480 --> 51:59.480]  getAddHelper.
[51:59.480 --> 52:01.480]  Что такое type?
[52:01.480 --> 52:03.480]  Integer Sequence.
[52:03.480 --> 52:05.480]  Вот этих индексов.
[52:05.480 --> 52:07.480]  Он старался остаться с нами.
[52:09.480 --> 52:11.480]  Вот. Давайте
[52:13.480 --> 52:15.480]  сначала обсудим, что такое
[52:15.480 --> 52:17.480]  Index Sequence.
[52:17.480 --> 52:19.480]  Это довольно полезная штука.
[52:23.480 --> 52:25.480]  Да. Примерно так.
[52:25.480 --> 52:27.480]  Значит, в стандартной
[52:27.480 --> 52:29.480]  библиотеке
[52:29.480 --> 52:31.480]  есть такой тип Integer Sequence.
[52:31.480 --> 52:33.480]  Это, по сути, compile-time
[52:33.480 --> 52:35.480]  последующих чисел.
[52:35.480 --> 52:37.480]  Но у нее есть специализация для
[52:37.480 --> 52:39.480]  случаев, когда T это с
[52:39.480 --> 52:41.480]  ST, она называется Index Sequence.
[52:45.480 --> 52:47.480]  Вот. Ее
[52:47.480 --> 52:49.480]  прелесть в том, что
[52:49.480 --> 52:51.480]  она реализована
[52:51.480 --> 52:53.480]  внутри компилятора так,
[52:53.480 --> 52:55.480]  что создание Index Sequence
[52:55.480 --> 52:57.480]  от N, это не
[52:57.480 --> 52:59.480]  квадратичная библиотека,
[52:59.480 --> 53:01.480]  это линейная по времени.
[53:01.480 --> 53:03.480]  Качество эссоциальных шаблонов
[53:03.480 --> 53:05.480]  прикурсивных? Да. Он не инстанцирует
[53:05.480 --> 53:07.480]  N разных шаблонов
[53:07.480 --> 53:09.480]  от 1 до N, чтобы создать
[53:09.480 --> 53:11.480]  Index Sequence размера N.
[53:11.480 --> 53:13.480]  То есть мы истинно...
[53:13.480 --> 53:15.480]  Мы опять стерили, да?
[53:15.480 --> 53:17.480]  Мы, по сути, свели...
[53:17.480 --> 53:19.480]  У нас была задача, мы могли
[53:19.480 --> 53:21.480]  написать сейчас гензо квадрат, если бы
[53:21.480 --> 53:23.480]  сами реализовали
[53:23.480 --> 53:25.480]  вот что-то такое. Ну, что-то в таком
[53:25.480 --> 53:27.480]  виде, потому что нам пришлось бы вот
[53:27.480 --> 53:29.480]  рекурсию делать шаблонными инстанцированиями
[53:29.480 --> 53:31.480]  от 1 до N. Но мы сейчас
[53:31.480 --> 53:33.480]  воспользуемся вот таким вот замечательным
[53:33.480 --> 53:35.480]  типом
[53:35.480 --> 53:37.480]  Index Sequence.
[53:39.480 --> 53:41.480]  Причем тут есть
[53:43.480 --> 53:45.480]  Make Index Sequence, которая
[53:45.480 --> 53:47.480]  от N, она создает Index Sequence
[53:49.480 --> 53:51.480]  0,1,2 и так далее, плюс 1,
[53:51.480 --> 53:53.480]  а есть Index Sequence 4.
[53:53.480 --> 53:55.480]  Это штука, которая создает Index Sequence
[53:55.480 --> 53:57.480]  для пакета типов.
[53:59.480 --> 54:01.480]  Ее можно реализовать...
[54:01.480 --> 54:03.480]  Все это можно самому реализовать, но оно квадратичное будет.
[54:03.480 --> 54:05.480]  А вот в стандарте, в компиляторе
[54:05.480 --> 54:07.480]  вот так реализовано, что
[54:07.480 --> 54:09.480]  встроено в компиляторе, поэтому работает за...
[54:09.480 --> 54:11.480]  за линию.
[54:13.480 --> 54:15.480]  Так, сейчас я напишу такое заклинание.
[54:15.480 --> 54:17.480]  Еще одно.
[54:17.480 --> 54:19.480]  Template, type name
[54:19.480 --> 54:21.480]  there.
[54:21.480 --> 54:23.480]  Так, что тебе не нравится?
[54:23.480 --> 54:25.480]  Что-то неправильно сделал.
[54:25.480 --> 54:27.480]  Ладно, мы считаем, что
[54:27.480 --> 54:29.480]  понравится.
[54:29.480 --> 54:31.480]  Static Const Export
[54:33.480 --> 54:35.480]  T,
[54:35.480 --> 54:37.480]  Darmit
[54:37.480 --> 54:39.480]  от Interval Type.
[54:43.480 --> 54:45.480]  Indices.
[54:47.480 --> 54:49.480]  Запятая
[54:51.480 --> 54:53.480]  без комментариев.
[54:55.480 --> 54:57.480]  Просто ладно.
[54:57.480 --> 54:59.480]  Ладно, я понимаю, что это без комментариев.
[54:59.480 --> 55:01.480]  Это что такое?
[55:03.480 --> 55:05.480]  Да, значит...
[55:05.480 --> 55:07.480]  Закрыл.
[55:07.480 --> 55:09.480]  Вот, мне нужно поставить многоточие.
[55:09.480 --> 55:11.480]  Запятая T звездочка, запятая многоточие,
[55:11.480 --> 55:13.480]  скобочка закрылась.
[55:13.480 --> 55:15.480]  Все, все, все очевидно.
[55:15.480 --> 55:17.480]  Я должен вам показать,
[55:17.480 --> 55:19.480]  потому что до этого нельзя догадаться.
[55:19.480 --> 55:21.480]  Вот, а теперь
[55:21.480 --> 55:23.480]  как будет работать
[55:23.480 --> 55:25.480]  Get.
[55:25.480 --> 55:27.480]  О, господи.
[55:27.480 --> 55:29.480]  Нет.
[55:29.480 --> 55:31.480]  А как тут еще два многоточия?
[55:31.480 --> 55:33.480]  Сейчас я напишу, как работает M.
[55:33.480 --> 55:35.480]  У нас же любая функция вторая многоточия,
[55:35.480 --> 55:37.480]  c-style.
[55:37.480 --> 55:39.480]  Да, да, да, да.
[55:39.480 --> 55:41.480]  Да, да, да, да, да.
[55:45.480 --> 55:47.480]  Type identity.
[55:47.480 --> 55:49.480]  Плюсы?
[55:49.480 --> 55:51.480]  Базахист.
[55:51.480 --> 55:53.480]  Нет, на плюсы.
[55:53.480 --> 55:55.480]  Нет, именно плюсы.
[55:55.480 --> 55:57.480]  Нет, нет.
[55:57.480 --> 55:59.480]  Так вот.
[55:59.480 --> 56:01.480]  Да, мазахист скорее.
[56:01.480 --> 56:03.480]  Я могу что-то писать.
[56:05.480 --> 56:07.480]  Значит, я Type identity сделаю
[56:07.480 --> 56:09.480]  с параметрами
[56:09.480 --> 56:11.480]  add helper
[56:11.480 --> 56:13.480]  код std
[56:13.480 --> 56:15.480]  make
[56:15.480 --> 56:17.480]  index
[56:17.480 --> 56:19.480]  sequence
[56:21.480 --> 56:23.480]  от
[56:23.480 --> 56:25.480]  index
[56:27.480 --> 56:29.480]  и
[56:29.480 --> 56:31.480]  выточить, выточить даме
[56:31.480 --> 56:33.480]  от
[56:33.480 --> 56:35.480]  вот
[56:35.480 --> 56:37.480]  вот такого
[56:39.480 --> 56:41.480]  значит
[56:41.480 --> 56:43.480]  ts
[56:43.480 --> 56:45.480]  null ptr
[56:47.480 --> 56:49.480]  и
[56:49.480 --> 56:51.480]  сейчас.
[56:51.480 --> 56:53.480]  Закрытая
[56:53.480 --> 56:55.480]  многоточие, скобочка закрылась.
[56:55.480 --> 56:57.480]  Все.
[56:57.480 --> 56:59.480]  Кажется так.
[56:59.480 --> 57:01.480]  А
[57:01.480 --> 57:03.480]  здесь
[57:03.480 --> 57:05.480]  точка за битой.
[57:05.480 --> 57:07.480]  Ну, я могу сказать type.
[57:07.480 --> 57:09.480]  Ну, это, конечно, прикол.
[57:09.480 --> 57:11.480]  Я не согласен.
[57:13.480 --> 57:15.480]  Давайте
[57:15.480 --> 57:17.480]  поймем, что здесь написано.
[57:17.480 --> 57:19.480]  Нет.
[57:19.480 --> 57:21.480]  Нет, не понятно.
[57:21.480 --> 57:23.480]  Мне кажется,
[57:23.480 --> 57:25.480]  мы воспользовались
[57:25.480 --> 57:27.480]  тем, что
[57:27.480 --> 57:29.480]  это
[57:29.480 --> 57:31.480]  что-то сделал, а когда не
[57:31.480 --> 57:33.480]  сделал, то не сделал.
[57:33.480 --> 57:35.480]  Вызвать надо, да?
[57:35.480 --> 57:37.480]  Декл-тайп закрыть.
[57:37.480 --> 57:39.480]  Декл-тайп у меня закрылся.
[57:39.480 --> 57:41.480]  А, да-да-да.
[57:41.480 --> 57:43.480]  Вот здесь надо.
[57:43.480 --> 57:45.480]  Да.
[57:45.480 --> 57:47.480]  Почему мы возвращаем,
[57:47.480 --> 57:49.480]  значит...
[57:51.480 --> 57:53.480]  Нет, все нормально.
[57:53.480 --> 57:55.480]  Смотрите.
[57:55.480 --> 57:57.480]  Что такое
[57:57.480 --> 57:59.480]  кред-хелпер? Вот тут есть
[57:59.480 --> 58:01.480]  он, во-первых, отыдных sequence,
[58:01.480 --> 58:03.480]  и тут есть такая функция
[58:03.480 --> 58:05.480]  констетского, у которой это функция.
[58:05.480 --> 58:07.480]  Вот это объявление функции, обычной функции,
[58:07.480 --> 58:09.480]  у которой нет тела, потому что мы ее вызывать никогда не будем,
[58:09.480 --> 58:11.480]  а возвращает она T.
[58:11.480 --> 58:13.480]  А что она принимает?
[58:13.480 --> 58:15.480]  Вот. Она принимает почти все.
[58:15.480 --> 58:17.480]  Это, ну, типа
[58:17.480 --> 58:19.480]  Стивна?
[58:19.480 --> 58:21.480]  Void звездочка.
[58:21.480 --> 58:23.480]  Вот это выражение с
[58:23.480 --> 58:25.480]  опять.
[58:25.480 --> 58:27.480]  Вот. Его тип
[58:27.480 --> 58:29.480]  это Void звездочка.
[58:29.480 --> 58:31.480]  И
[58:31.480 --> 58:33.480]  здесь таких Void звездочек будет в количестве,
[58:33.480 --> 58:35.480]  сколько было индексов.
[58:35.480 --> 58:37.480]  Смотрите,
[58:37.480 --> 58:39.480]  это функция, у которой
[58:39.480 --> 58:41.480]  сигнатура следующая.
[58:41.480 --> 58:43.480]  Она принимает несколько раз
[58:43.480 --> 58:45.480]  Void звездочку
[58:45.480 --> 58:47.480]  в таком количестве, сколько индексов было
[58:47.480 --> 58:49.480]  в пакете параметров.
[58:49.480 --> 58:51.480]  Вот это распаковка пакета.
[58:53.480 --> 58:55.480]  Дальше T звездочка.
[58:55.480 --> 58:57.480]  А дальше T звездочка, и дальше
[58:57.480 --> 58:59.480]  что угодно.
[58:59.480 --> 59:01.480]  И вернет она T.
[59:01.480 --> 59:03.480]  Поэтому, как мы ей воспользуемся,
[59:03.480 --> 59:05.480]  мы спросим, а какой тип
[59:05.480 --> 59:07.480]  вернуться бы, если бы мы
[59:07.480 --> 59:09.480]  у AdHelper с параметром
[59:09.480 --> 59:11.480]  MakeIndexSequence
[59:11.480 --> 59:13.480]  от нашего индекса
[59:13.480 --> 59:15.480]  вызвали данные
[59:15.480 --> 59:17.480]  от всех наших типов,
[59:17.480 --> 59:19.480]  от указателей на все на все наше
[59:19.480 --> 59:21.480]  добро по одному.
[59:21.480 --> 59:23.480]  За счет того,
[59:23.480 --> 59:25.480]  что их ровно столько,
[59:25.480 --> 59:27.480]  за счет того, что у нас индекс
[59:27.480 --> 59:29.480]  именно такой,
[59:29.480 --> 59:31.480]  то именно на таком месте будет T звездочка
[59:31.480 --> 59:33.480]  и именно такой возвращение тип будет
[59:33.480 --> 59:35.480]  у этой функции Dummy.
[59:35.480 --> 59:37.480]  Я ничего не понял.
[59:37.480 --> 59:39.480]  Нет, вообще ничего не понял.
[59:41.480 --> 59:43.480]  Еще раз, функция Dummy
[59:43.480 --> 59:45.480]  Ну смотри, функция Dummy, ну давай.
[59:45.480 --> 59:47.480]  Dummy,
[59:47.480 --> 59:49.480]  у которой квадриллятор
[59:49.480 --> 59:51.480]  сам определит тип T,
[59:51.480 --> 59:53.480]  потому что мы его никуда не передаем никогда.
[59:53.480 --> 59:55.480]  Которая принимает
[59:55.480 --> 59:57.480]  зачем-то
[59:57.480 --> 59:59.480]  сколько-то будет звездочек.
[59:59.480 --> 01:00:01.480]  Зачем на них декладать?
[01:00:01.480 --> 01:00:03.480]  Первый аргумент
[01:00:03.480 --> 01:00:05.480]  декладать, чтобы мы могли
[01:00:05.480 --> 01:00:07.480]  сделать
[01:00:07.480 --> 01:00:09.480]  распаковку по количеству.
[01:00:09.480 --> 01:00:11.480]  Что такое
[01:00:11.480 --> 01:00:13.480]  распаковка по количеству?
[01:00:13.480 --> 01:00:15.480]  Зачем она вообще
[01:00:15.480 --> 01:00:17.480]  индексес, если она просто
[01:00:17.480 --> 01:00:19.480]  делает сколько-то подряд?
[01:00:19.480 --> 01:00:21.480]  Это просто нам надо
[01:00:21.480 --> 01:00:23.480]  сделать сколько-то подряд будет звездочек,
[01:00:23.480 --> 01:00:25.480]  чтобы на нужном месте была
[01:00:25.480 --> 01:00:27.480]  та звездочка.
[01:00:27.480 --> 01:00:29.480]  Нужное место, это место с нужным индексом.
[01:00:29.480 --> 01:00:31.480]  Потому что нам нужно, чтобы возвращение
[01:00:31.480 --> 01:00:33.480]  тип этой функции был T, где T
[01:00:33.480 --> 01:00:35.480]  это вот то, что на нужном месте.
[01:00:37.480 --> 01:00:39.480]  И он типа обгадает сам
[01:00:39.480 --> 01:00:41.480]  Откуда возьмутся индексы?
[01:00:41.480 --> 01:00:43.480]  Индексы возьмутся
[01:00:43.480 --> 01:00:45.480]  из того, что сколько индекс-секвенсов.
[01:00:45.480 --> 01:00:47.480]  Индекс-секвенс создает
[01:00:47.480 --> 01:00:49.480]  последовательность из индекс
[01:00:49.480 --> 01:00:51.480]  элементов.
[01:00:51.480 --> 01:00:53.480]  Элемент на позиции I, перед ним стоит
[01:00:53.480 --> 01:00:55.480]  и элемент.
[01:00:55.480 --> 01:00:57.480]  Хорошо.
[01:00:57.480 --> 01:00:59.480]  Мы
[01:00:59.480 --> 01:01:01.480]  создали последовательность
[01:01:01.480 --> 01:01:03.480]  чисел за линию
[01:01:03.480 --> 01:01:05.480]  длины индекс.
[01:01:05.480 --> 01:01:07.480]  Как это будет выглядеть
[01:01:07.480 --> 01:01:09.480]  у этого helper?
[01:01:09.480 --> 01:01:11.480]  Он первый
[01:01:11.480 --> 01:01:13.480]  индекс будет
[01:01:13.480 --> 01:01:15.480]  с любой звездочкой.
[01:01:15.480 --> 01:01:17.480]  А следующий будет
[01:01:17.480 --> 01:01:19.480]  с той звездочкой, где T шаблонный.
[01:01:19.480 --> 01:01:21.480]  И он должен подобрать T, чтобы правильно
[01:01:21.480 --> 01:01:23.480]  принять соответствующий аргумент
[01:01:23.480 --> 01:01:25.480]  из TS.
[01:01:25.480 --> 01:01:27.480]  Как раз тип
[01:01:27.480 --> 01:01:29.480]  с номером индекс.
[01:01:29.480 --> 01:01:31.480]  И он T правильно тогда поделит.
[01:01:31.480 --> 01:01:33.480]  И вернет его нам.
[01:01:33.480 --> 01:01:35.480]  Значит, ну давайте я статик
[01:01:35.480 --> 01:01:37.480]  еще кто-нибудь допишу, сейчас мы проверим,
[01:01:37.480 --> 01:01:39.480]  правильно ли все происходит.
[01:01:39.480 --> 01:01:41.480]  Если я один дабл чарк,
[01:01:41.480 --> 01:01:43.480]  что на втором месте?
[01:01:43.480 --> 01:01:45.480]  Эд с параметром два
[01:01:45.480 --> 01:01:47.480]  с шаблоном параметром два.
[01:01:47.480 --> 01:01:49.480]  Что на втором месте?
[01:01:49.480 --> 01:01:51.480]  Я хочу, чтобы там
[01:01:51.480 --> 01:01:53.480]  было TypeIdentity.
[01:01:53.480 --> 01:01:55.480]  Так, а
[01:01:55.480 --> 01:01:57.480]  у меня нету сравнений для TypeIdentity.
[01:01:57.480 --> 01:01:59.480]  Очень плохо.
[01:01:59.480 --> 01:02:01.480]  Ммм, ну можно взять
[01:02:01.480 --> 01:02:03.480]  кип-депагрете и достать его оттуда
[01:02:03.480 --> 01:02:05.480]  и поставить объект.
[01:02:05.480 --> 01:02:07.480]  Ну да.
[01:02:07.480 --> 01:02:09.480]  Ну а какой параметр?
[01:02:09.480 --> 01:02:11.480]  Везде звездочный.
[01:02:11.480 --> 01:02:13.480]  Ну можно же...
[01:02:13.480 --> 01:02:15.480]  Ну давайте
[01:02:15.480 --> 01:02:17.480]  через DoubleType сделаем.
[01:02:17.480 --> 01:02:19.480]  Мне по-хорошему надо было бы еще
[01:02:19.480 --> 01:02:21.480]  сделать
[01:02:21.480 --> 01:02:23.480]  оператора сравнений для типов,
[01:02:23.480 --> 01:02:25.480]  но уже никак.
[01:02:25.480 --> 01:02:27.480]  Почему мы возвращаем TypeIdentity?
[01:02:27.480 --> 01:02:29.480]  А что?
[01:02:29.480 --> 01:02:31.480]  Раньше мы возвращали...
[01:02:31.480 --> 01:02:33.480]  Потому что объект TypeIdentity
[01:02:33.480 --> 01:02:35.480]  вообще говоря мы не можем создать.
[01:02:35.480 --> 01:02:37.480]  Мы создаем либо TypeList, либо TypeIdentity,
[01:02:37.480 --> 01:02:39.480]  и мы работаем.
[01:02:39.480 --> 01:02:41.480]  А раньше мы создавали...
[01:02:41.480 --> 01:02:43.480]  Да, мы создавали объектив, да, хорошо.
[01:02:43.480 --> 01:02:45.480]  Но только TypeList мы до этого возвращали.
[01:02:47.480 --> 01:02:49.480]  Ну и SameWay от DoubleType
[01:02:49.480 --> 01:02:51.480]  от вот этой штуки.
[01:02:51.480 --> 01:02:53.480]  Да, и SameWay от DoubleType от вот этой штуки.
[01:02:55.480 --> 01:02:57.480]  И запятая Ч.
[01:02:57.480 --> 01:02:59.480]  Да.
[01:03:01.480 --> 01:03:03.480]  Сейчас, наверное, еще не скомпилируется.
[01:03:03.480 --> 01:03:05.480]  Да, не скомпилировалось,
[01:03:05.480 --> 01:03:07.480]  потому что я не подключил
[01:03:07.480 --> 01:03:09.480]  IndexSequence.
[01:03:09.480 --> 01:03:11.480]  IndexSequence у меня в utility.
[01:03:31.480 --> 01:03:33.480]  TypeValue mismatched,
[01:03:33.480 --> 01:03:35.480]  сейчас...
[01:03:37.480 --> 01:03:39.480]  А, SDB IndexSequence
[01:03:39.480 --> 01:03:41.480]  он...
[01:03:41.480 --> 01:03:43.480]  А он вначале принимает такое...
[01:03:43.480 --> 01:03:45.480]  А потом принимает
[01:03:45.480 --> 01:03:47.480]  число.
[01:03:47.480 --> 01:03:49.480]  SizeT и...
[01:03:49.480 --> 01:03:51.480]  Нет, MakeIndexSequence.
[01:03:51.480 --> 01:03:53.480]  Так, сейчас, давайте разберемся.
[01:03:53.480 --> 01:03:55.480]  В 61-й строке
[01:03:55.480 --> 01:03:57.480]  у меня
[01:03:57.480 --> 01:03:59.480]  Expected the concept of type
[01:03:59.480 --> 01:04:01.480]  on the side.
[01:04:01.480 --> 01:04:03.480]  But it's on MakingIndexSequence.
[01:04:11.480 --> 01:04:13.480]  Я специализирую...
[01:04:13.480 --> 01:04:15.480]  А...
[01:04:17.480 --> 01:04:19.480]  А, ну да, мне нужно...
[01:04:19.480 --> 01:04:21.480]  Мне нужно вот здесь
[01:04:23.480 --> 01:04:25.480]  TypeNameT
[01:04:25.480 --> 01:04:27.480]  писать.
[01:04:27.480 --> 01:04:29.480]  Кажется.
[01:04:29.480 --> 01:04:31.480]  Да?
[01:04:31.480 --> 01:04:33.480]  Да.
[01:04:33.480 --> 01:04:35.480]  Потому что
[01:04:35.480 --> 01:04:37.480]  я специализирую шаблон AdHelper
[01:04:37.480 --> 01:04:39.480]  для типа IndexSequence.
[01:04:39.480 --> 01:04:41.480]  А до этого говорилось, что этот шаблон отчислил,
[01:04:41.480 --> 01:04:43.480]  а не от типа.
[01:04:43.480 --> 01:04:45.480]  Поэтому вот у него специализация не подошла
[01:04:45.480 --> 01:04:47.480]  под общую версию.
[01:04:47.480 --> 01:04:49.480]  OK, AdHelper, IndexSequence
[01:04:49.480 --> 01:04:51.480]  от этих индексов.
[01:04:51.480 --> 01:04:53.480]  Ну и на каком месте у меня это звездочка оказывается?
[01:04:53.480 --> 01:04:55.480]  У меня получается
[01:04:55.480 --> 01:04:57.480]  сколько? У меня получается
[01:04:59.480 --> 01:05:01.480]  Ну, я вызвался от двойки, да?
[01:05:01.480 --> 01:05:03.480]  Я сказал, на месте 2.
[01:05:03.480 --> 01:05:05.480]  То есть у меня индексов должно быть
[01:05:05.480 --> 01:05:07.480]  у меня 0, 1, 2 получатся, эти индексы.
[01:05:07.480 --> 01:05:09.480]  То есть мне надо здесь, кажется,
[01:05:09.480 --> 01:05:11.480]  вот здесь
[01:05:11.480 --> 01:05:13.480]  делать, где-то
[01:05:13.480 --> 01:05:15.480]  надо минус 1 делать.
[01:05:15.480 --> 01:05:17.480]  Вот здесь минус 1 надо делать, кажется.
[01:05:19.480 --> 01:05:21.480]  Должна создаться последовательность
[01:05:21.480 --> 01:05:23.480]  из индекса элемента.
[01:05:23.480 --> 01:05:25.480]  Хотя на этапе у вас все нормально.
[01:05:25.480 --> 01:05:27.480]  Это вроде все нормально.
[01:05:27.480 --> 01:05:29.480]  Не надо ничего делать.
[01:05:29.480 --> 01:05:31.480]  У вас же от 0 еще 10 минут.
[01:05:31.480 --> 01:05:33.480]  Поэтому будет элемент, а то есть и минус.
[01:05:37.480 --> 01:05:39.480]  Нет, все как делалось.
[01:05:39.480 --> 01:05:41.480]  И Same Weight не сработало.
[01:05:41.480 --> 01:05:43.480]  Не давало нужной реализации.
[01:05:43.480 --> 01:05:45.480]  Тип не тот, а какой тип?
[01:05:45.480 --> 01:05:47.480]  Вот сейчас ты, Чарль.
[01:05:47.480 --> 01:05:49.480]  Секундочку, а у вас
[01:05:49.480 --> 01:05:51.480]  декл-тайк-то возвращается
[01:05:51.480 --> 01:05:53.480]  или сравниваетесь с Чарльом.
[01:05:53.480 --> 01:05:55.480]  Ну понятно, что мне нужно
[01:05:55.480 --> 01:05:57.480]  сделать декл-тайк.
[01:05:57.480 --> 01:05:59.480]  Это у всего твой .b.type.
[01:05:59.480 --> 01:06:01.480]  Нет, это не надо,
[01:06:01.480 --> 01:06:03.480]  потому что декл-тайк
[01:06:03.480 --> 01:06:05.480]  все работает.
[01:06:05.480 --> 01:06:07.480]  Понятно.
[01:06:09.480 --> 01:06:11.480]  К сожалению,
[01:06:11.480 --> 01:06:13.480]  не успел я вам показать
[01:06:13.480 --> 01:06:15.480]  реверс.
[01:06:17.480 --> 01:06:19.480]  Ну я еще не понял.
[01:06:19.480 --> 01:06:21.480]  Важно, это задание было нельзя догадаться,
[01:06:21.480 --> 01:06:23.480]  потому что реверс
[01:06:23.480 --> 01:06:25.480]  типа чапывает.
[01:06:25.480 --> 01:06:27.480]  Реверс можно сделать
[01:06:27.480 --> 01:06:29.480]  с помощью add.
[01:06:29.480 --> 01:06:31.480]  За линию.
[01:06:31.480 --> 01:06:33.480]  За линию, да.
[01:06:37.480 --> 01:06:39.480]  Ну вам просто надо
[01:06:39.480 --> 01:06:41.480]  там
[01:06:41.480 --> 01:06:43.480]  нет, я
[01:06:43.480 --> 01:06:45.480]  сходу не могу сказать, что надо.
[01:06:45.480 --> 01:06:47.480]  Но, короче, я
[01:06:47.480 --> 01:06:49.480]  сходу не могу сказать, что надо.
[01:06:49.480 --> 01:06:51.480]  Ну, в смысле, чтобы не инстанцировать рекурсивно,
[01:06:51.480 --> 01:06:53.480]  чтобы тебе не приходилось создавать
[01:06:53.480 --> 01:06:55.480]  n типов, у каждого из которых
[01:06:55.480 --> 01:06:57.480]  n шаблонных параметров.
[01:06:59.480 --> 01:07:01.480]  Сортировка.
[01:07:01.480 --> 01:07:03.480]  Там же придется n раз выливать add.
[01:07:03.480 --> 01:07:05.480]  Нет, вот это
[01:07:05.480 --> 01:07:07.480]  смысл, что не надо.
[01:07:07.480 --> 01:07:09.480]  Если ты вызовешь n раз add, то ты обосрался.
[01:07:09.480 --> 01:07:11.480]  Я люблю защитить add в реверс.
[01:07:11.480 --> 01:07:13.480]  Мне все очень нравится, что у нас лист, который в операции
[01:07:13.480 --> 01:07:15.480]  за УАД на минимум.
[01:07:15.480 --> 01:07:17.480]  В бетончик же быстрее.
[01:07:19.480 --> 01:07:21.480]  В бетончик же можно класть
[01:07:21.480 --> 01:07:23.480]  объекты типа тип листы.
[01:07:23.480 --> 01:07:25.480]  Значит,
[01:07:25.480 --> 01:07:27.480]  я напоследок покажу вам
[01:07:27.480 --> 01:07:29.480]  шедевральную совершенно вещь,
[01:07:29.480 --> 01:07:31.480]  в моем взгляду.
[01:07:31.480 --> 01:07:33.480]  А как он ранды берет?
[01:07:33.480 --> 01:07:35.480]  Ты должен висорть.
[01:07:35.480 --> 01:07:37.480]  Комментарии это замечательно.
[01:07:37.480 --> 01:07:39.480]  Значит, это быстрая сортировка
[01:07:39.480 --> 01:07:41.480]  для метод
[01:07:41.480 --> 01:07:43.480]  контейнера.
[01:07:43.480 --> 01:07:45.480]  Ну вот, статик ассерт.
[01:07:45.480 --> 01:07:47.480]  Ну вот тут
[01:07:47.480 --> 01:07:49.480]  значит...
[01:07:49.480 --> 01:07:51.480]  Тут где-то написано...
[01:07:51.480 --> 01:07:53.480]  Как он решил, какие типы меньше, а какие
[01:07:53.480 --> 01:07:55.480]  более?
[01:07:55.480 --> 01:07:57.480]  Вот как он решил.
[01:07:57.480 --> 01:07:59.480]  Смотрите, у меня для начала тест.
[01:07:59.480 --> 01:08:01.480]  Давайте я объявлю структуру их маленькая,
[01:08:01.480 --> 01:08:03.480]  она параметра небольшая.
[01:08:03.480 --> 01:08:05.480]  Вот.
[01:08:05.480 --> 01:08:07.480]  И для нее определю
[01:08:07.480 --> 01:08:09.480]  мне эту функцию less, которая будет
[01:08:09.480 --> 01:08:11.480]  принимать две маленьких их,
[01:08:11.480 --> 01:08:13.480]  у кого из них меньше, у кого индекс меньше.
[01:08:15.480 --> 01:08:17.480]  Вот. Ну очень просто.
[01:08:17.480 --> 01:08:19.480]  Вот берем теперь статик ассерт,
[01:08:19.480 --> 01:08:21.480]  что сортировка
[01:08:21.480 --> 01:08:23.480]  вот такого вот
[01:08:23.480 --> 01:08:25.480]  списка,
[01:08:25.480 --> 01:08:27.480]  это будет type list,
[01:08:27.480 --> 01:08:29.480]  только сортировка, наверное, должна все-таки принимать type list,
[01:08:29.480 --> 01:08:31.480]  а она принимает
[01:08:31.480 --> 01:08:33.480]  последовательность типов, ну,
[01:08:33.480 --> 01:08:35.480]  ничего страшного.
[01:08:35.480 --> 01:08:37.480]  Сортировка
[01:08:37.480 --> 01:08:39.480]  использует его
[01:08:39.480 --> 01:08:41.480]  как...
[01:08:41.480 --> 01:08:43.480]  Ну, для тех типов, для которых мы вызвали,
[01:08:43.480 --> 01:08:45.480]  он определяет.
[01:08:45.480 --> 01:08:47.480]  Короче, мы не можем вызвать ни для чего проект, как вот для этих типов.
[01:08:47.480 --> 01:08:49.480]  Да потому, что нельзя сортировать
[01:08:49.480 --> 01:08:51.480]  производить.
[01:08:51.480 --> 01:08:53.480]  Вау.
[01:08:53.480 --> 01:08:55.480]  Вот.
[01:08:55.480 --> 01:08:57.480]  А, смотрите,
[01:08:57.480 --> 01:08:59.480]  ну давайте быстренько пробежимся,
[01:08:59.480 --> 01:09:01.480]  что здесь происходит.
[01:09:01.480 --> 01:09:03.480]  Вот есть
[01:09:03.480 --> 01:09:05.480]  сайзор.
[01:09:05.480 --> 01:09:07.480]  Ну, во-первых, да, есть type list, уже нам известный,
[01:09:07.480 --> 01:09:09.480]  есть структура less,
[01:09:09.480 --> 01:09:11.480]  в которой мы специализируемся.
[01:09:11.480 --> 01:09:13.480]  Значит, есть partition,
[01:09:13.480 --> 01:09:15.480]  потом поговорим, что это такое.
[01:09:15.480 --> 01:09:17.480]  Значит, есть конкатинация двух type lists,
[01:09:17.480 --> 01:09:19.480]  оператор плюс.
[01:09:19.480 --> 01:09:21.480]  Который возвращает type list,
[01:09:21.480 --> 01:09:23.480]  вот здесь используется type list,
[01:09:23.480 --> 01:09:25.480]  который возвращает type list
[01:09:25.480 --> 01:09:27.480]  от двух
[01:09:27.480 --> 01:09:29.480]  склеенных пакетов.
[01:09:29.480 --> 01:09:31.480]  Почему она
[01:09:31.480 --> 01:09:33.480]  мы все время
[01:09:33.480 --> 01:09:35.480]  сядем через return
[01:09:35.480 --> 01:09:37.480]  Если мы будем ее вызывать,
[01:09:37.480 --> 01:09:39.480]  то она что,
[01:09:39.480 --> 01:09:41.480]  должна иметь тело на смене?
[01:09:41.480 --> 01:09:43.480]  Мы будем
[01:09:43.480 --> 01:09:45.480]  декл-тайп.
[01:09:45.480 --> 01:09:47.480]  Мы будем только декл-тайп.
[01:09:49.480 --> 01:09:51.480]  Да, мы декл-тайп
[01:09:51.480 --> 01:09:53.480]  вот это всего
[01:09:53.480 --> 01:09:55.480]  визал.
[01:09:55.480 --> 01:09:57.480]  А,
[01:09:57.480 --> 01:09:59.480]  значит,
[01:09:59.480 --> 01:10:01.480]  quick sort.
[01:10:01.480 --> 01:10:03.480]  Ну, quick sort это
[01:10:05.480 --> 01:10:07.480]  note type list некоторых типов.
[01:10:07.480 --> 01:10:09.480]  Да, хорошо.
[01:10:09.480 --> 01:10:11.480]  Статик авто.
[01:10:11.480 --> 01:10:13.480]  Что это с выращением вообще?
[01:10:13.480 --> 01:10:15.480]  Это объявление функции.
[01:10:15.480 --> 01:10:17.480]  Статическая функция,
[01:10:17.480 --> 01:10:19.480]  в которой возвращается авто и иконы.
[01:10:19.480 --> 01:10:21.480]  Которая, да.
[01:10:21.480 --> 01:10:23.480]  А, он структ написал, вот он плохой человек.
[01:10:23.480 --> 01:10:25.480]  Вот, а тут
[01:10:25.480 --> 01:10:27.480]  quick sort специализируется
[01:10:27.480 --> 01:10:29.480]  для случая, когда
[01:10:29.480 --> 01:10:31.480]  еще есть пиво.
[01:10:31.480 --> 01:10:33.480]  Кстати,
[01:10:33.480 --> 01:10:35.480]  в каком мире
[01:10:35.480 --> 01:10:37.480]  эта специализация?
[01:10:37.480 --> 01:10:39.480]  Кстати, непонятно, почему сейчас.
[01:10:39.480 --> 01:10:41.480]  Почему
[01:10:41.480 --> 01:10:43.480]  у него это не вызвало ошибку.
[01:10:43.480 --> 01:10:45.480]  Если,
[01:10:45.480 --> 01:10:47.480]  казалось бы, до этого quick sort был только от типов.
[01:10:47.480 --> 01:10:49.480]  А, тип, все нормально.
[01:10:49.480 --> 01:10:51.480]  Pivot это тоже тип.
[01:10:51.480 --> 01:10:53.480]  Значит, теперь
[01:10:53.480 --> 01:10:55.480]  у нас есть pivot.
[01:10:55.480 --> 01:10:57.480]  Ну, правильно, потому что pivot это же элемент
[01:10:57.480 --> 01:10:59.480]  листа.
[01:10:59.480 --> 01:11:01.480]  Не, это плохо.
[01:11:01.480 --> 01:11:03.480]  Ну, хорошо.
[01:11:05.480 --> 01:11:07.480]  Какой-то элемент массив называется pivot.
[01:11:07.480 --> 01:11:09.480]  Вот, теперь смотрите,
[01:11:09.480 --> 01:11:11.480]  что происходит. Result.
[01:11:11.480 --> 01:11:13.480]  Вот, если мы делаем quick sort
[01:11:13.480 --> 01:11:15.480]  с данным пиводом от такого номера типов,
[01:11:15.480 --> 01:11:17.480]  то мы возвращаем result
[01:11:17.480 --> 01:11:19.480]  вот
[01:11:19.480 --> 01:11:21.480]  такой вещи.
[01:11:21.480 --> 01:11:23.480]  Тут fold expression написан,
[01:11:23.480 --> 01:11:25.480]  мы делаем partition под pivot
[01:11:25.480 --> 01:11:27.480]  и дальше
[01:11:27.480 --> 01:11:29.480]  через fold expression
[01:11:29.480 --> 01:11:31.480]  делаем присваивание
[01:11:31.480 --> 01:11:33.480]  до подиады последнего типа
[01:11:33.480 --> 01:11:35.480]  и всего этого join.
[01:11:41.480 --> 01:11:43.480]  Что такое partition?
[01:11:43.480 --> 01:11:45.480]  Что такое точка join?
[01:11:45.480 --> 01:11:47.480]  Давай сначала помечу про partition.
[01:11:47.480 --> 01:11:49.480]  Partition
[01:11:49.480 --> 01:11:51.480]  это такой
[01:11:51.480 --> 01:11:53.480]  опять же, такая метафункция
[01:11:53.480 --> 01:11:55.480]  или структура.
[01:11:55.480 --> 01:11:57.480]  У нее параметр есть pivot
[01:11:57.480 --> 01:11:59.480]  и есть
[01:11:59.480 --> 01:12:01.480]  левый пакет типов,
[01:12:01.480 --> 01:12:03.480]  правый пакет типов.
[01:12:03.480 --> 01:12:05.480]  Она принимает
[01:12:07.480 --> 01:12:09.480]  значит, два type листа
[01:12:09.480 --> 01:12:11.480]  и у нее есть
[01:12:11.480 --> 01:12:13.480]  оператор равно.
[01:12:13.480 --> 01:12:15.480]  Ага.
[01:12:19.480 --> 01:12:21.480]  Ну, вот здесь partition
[01:12:21.480 --> 01:12:23.480]  от pivot
[01:12:23.480 --> 01:12:25.480]  это да, это partition,
[01:12:25.480 --> 01:12:27.480]  которая приняла два пустых листа.
[01:12:27.480 --> 01:12:29.480]  И это все распаковалось,
[01:12:29.480 --> 01:12:31.480]  дальше происходит оператор присваивания
[01:12:31.480 --> 01:12:33.480]  от partition pivot
[01:12:33.480 --> 01:12:35.480]  два пустых листа, partition
[01:12:35.480 --> 01:12:37.480]  pivot
[01:12:37.480 --> 01:12:39.480]  и
[01:12:39.480 --> 01:12:41.480]  значит, первый тип
[01:12:41.480 --> 01:12:43.480]  из списка типов.
[01:12:43.480 --> 01:12:45.480]  Вот. Сконструированный
[01:12:45.480 --> 01:12:47.480]  по умолчанию.
[01:12:49.480 --> 01:12:51.480]  Что будет такое
[01:12:51.480 --> 01:12:53.480]  и сам представлять
[01:12:53.480 --> 01:12:55.480]  значит, это
[01:12:55.480 --> 01:12:57.480]  присваивание. Мы берем
[01:12:57.480 --> 01:12:59.480]  partition, у которого
[01:12:59.480 --> 01:13:01.480]  есть
[01:13:01.480 --> 01:13:03.480]  у которого нет никаких типов
[01:13:03.480 --> 01:13:05.480]  правых пивота и есть какой-то еще тип правых пивота.
[01:13:05.480 --> 01:13:07.480]  Да, здесь
[01:13:07.480 --> 01:13:09.480]  с типу 20 пишем requires.
[01:13:09.480 --> 01:13:11.480]  Вот. Если
[01:13:11.480 --> 01:13:13.480]  у нас тип
[01:13:13.480 --> 01:13:15.480]  u оказался меньше, чем
[01:13:15.480 --> 01:13:17.480]  pivot, то мы попадаем
[01:13:17.480 --> 01:13:19.480]  в эту версию и возвращаем
[01:13:19.480 --> 01:13:21.480]  partition с pivot,
[01:13:21.480 --> 01:13:23.480]  в которую в левой тейп-листе написано u,
[01:13:23.480 --> 01:13:25.480]  а в правой тейп-листе ничего не написано.
[01:13:25.480 --> 01:13:27.480]  Нет, потому что
[01:13:27.480 --> 01:13:29.480]  оператор одного смысла надо подрубаться
[01:13:29.480 --> 01:13:31.480]  с левой направо или с правой?
[01:13:31.480 --> 01:13:33.480]  С левой направо, потому что это fold expression.
[01:13:33.480 --> 01:13:35.480]  Fold expression
[01:13:35.480 --> 01:13:37.480]  А, тоже с лобочек оставлен.
[01:13:37.480 --> 01:13:39.480]  Да, он делает ассоциированный с левой направо.
[01:13:39.480 --> 01:13:41.480]  Вот.
[01:13:41.480 --> 01:13:43.480]  Значит, здесь
[01:13:43.480 --> 01:13:45.480]  мы в зависимости
[01:13:45.480 --> 01:13:47.480]  от того, меньше или больше
[01:13:47.480 --> 01:13:49.480]  этот тип, чем
[01:13:49.480 --> 01:13:51.480]  пивот, либо к левому
[01:13:51.480 --> 01:13:53.480]  тейп-листу дописываем,
[01:13:53.480 --> 01:13:55.480]  либо к правому листу дописываем.
[01:13:55.480 --> 01:13:57.480]  Но здесь мы просто
[01:13:57.480 --> 01:13:59.480]  все допишем к левому тейп-листу, кажется,
[01:13:59.480 --> 01:14:01.480]  при первом проходе.
[01:14:05.480 --> 01:14:07.480]  Да, потому что, что такое join?
[01:14:07.480 --> 01:14:09.480]  Join – это мы сортируем
[01:14:09.480 --> 01:14:11.480]  левый,
[01:14:11.480 --> 01:14:13.480]  а делаем
[01:14:13.480 --> 01:14:15.480]  тейп-лист из одного лишь пивота и сортируем
[01:14:15.480 --> 01:14:17.480]  правый и конкурсируем.
[01:14:17.480 --> 01:14:19.480]  Приколепно.
[01:14:19.480 --> 01:14:21.480]  А почему оператор равно?
[01:14:21.480 --> 01:14:23.480]  Он же как-то, ну, не себя даже
[01:14:23.480 --> 01:14:25.480]  возвращает, что-то странное.
[01:14:25.480 --> 01:14:27.480]  Я не знаю, почему здесь оператором равно.
[01:14:27.480 --> 01:14:29.480]  Ну, типа, надо оператором,
[01:14:29.480 --> 01:14:31.480]  потому что оператор и только оператор
[01:14:31.480 --> 01:14:33.480]  можно через три точки описать.
[01:14:33.480 --> 01:14:35.480]  Да.
[01:14:35.480 --> 01:14:37.480]  Равно – это, типа, знаешь,
[01:14:37.480 --> 01:14:39.480]  как насторонняя стрелочка,
[01:14:39.480 --> 01:14:41.480]  связанная листом.
[01:14:43.480 --> 01:14:45.480]  Я не верю, что это работает займок.
[01:14:47.480 --> 01:14:49.480]  Ну, как себе сказать.
[01:14:49.480 --> 01:14:51.480]  Ну, запусти на тысячи.
[01:14:51.480 --> 01:14:53.480]  Мы же не умеем выбраться.
[01:14:53.480 --> 01:14:55.480]  Мне кажется, работает за квадрату,
[01:14:55.480 --> 01:14:57.480]  честно говоря.
[01:14:57.480 --> 01:14:59.480]  Давайте быстренько на питочке нанерим
[01:14:59.480 --> 01:15:01.480]  большую массив, запекаем текст
[01:15:03.480 --> 01:15:05.480]  и дальше запустим тайм.
[01:15:07.480 --> 01:15:09.480]  Нужно еще помнить, что
[01:15:09.480 --> 01:15:11.480]  типа асинтотика еще должен быть
[01:15:11.480 --> 01:15:13.480]  на большой констант.
[01:15:13.480 --> 01:15:15.480]  Ну, запустим.
[01:15:15.480 --> 01:15:17.480]  Так надо исследовать это.
[01:15:17.480 --> 01:15:19.480]  График функции.
[01:15:23.480 --> 01:15:25.480]  Я сомневаюсь, что этот квит
[01:15:25.480 --> 01:15:27.480]  и сорт ни хрена не будет.
[01:15:27.480 --> 01:15:29.480]  Ну, он быстрее, чем тот,
[01:15:29.480 --> 01:15:31.480]  что стыдно.
[01:15:31.480 --> 01:15:33.480]  Быстрее, чем отсутствие.
[01:15:33.480 --> 01:15:35.480]  Да.
[01:15:35.480 --> 01:15:37.480]  Сейчас, как он выбирает,
[01:15:37.480 --> 01:15:39.480]  как он пивот второй раз выбирает?
[01:15:39.480 --> 01:15:41.480]  Пивот всегда первый элемент.
[01:15:41.480 --> 01:15:43.480]  Пивот всегда первый элемент.
[01:15:43.480 --> 01:15:45.480]  Это же кримич.
[01:15:45.480 --> 01:15:47.480]  Пивот всегда первый элемент.
[01:15:47.480 --> 01:15:49.480]  Пивот всегда первый элемент.
[01:15:49.480 --> 01:15:51.480]  Окей.
[01:15:51.480 --> 01:15:53.480]  Тогда упорядоченный в обратном порядке лист
[01:15:53.480 --> 01:15:55.480]  будет работать.
[01:15:55.480 --> 01:15:57.480]  Да, это жестко.
[01:16:01.480 --> 01:16:03.480]  Ну, мы здесь знаем,
[01:16:03.480 --> 01:16:05.480]  как написать гет.
[01:16:05.480 --> 01:16:07.480]  Да, самописный гет
[01:16:07.480 --> 01:16:09.480]  с самописным рандом лучше работает.
[01:16:09.480 --> 01:16:11.480]  Что такое рандом?
[01:16:11.480 --> 01:16:13.480]  Космекспер-ранд в чем проблема?
[01:16:13.480 --> 01:16:15.480]  В чем проблема?
[01:16:15.480 --> 01:16:17.480]  В чем проблема?
[01:16:17.480 --> 01:16:19.480]  В чем проблема?
[01:16:19.480 --> 01:16:21.480]  Сейчас...
[01:16:21.480 --> 01:16:23.480]  Не, ну, че, идеи наканунеет генератор,
[01:16:23.480 --> 01:16:25.480]  или как он называется.
[01:16:25.480 --> 01:16:27.480]  Просто берешь остатки какого-то большого
[01:16:27.480 --> 01:16:29.480]  простого модуля и...
[01:16:29.480 --> 01:16:31.480]  И каждый запуск он будет генерить.
[01:16:31.480 --> 01:16:33.480]  Смоси, записывай за файл, а потом запускаться.
[01:16:33.480 --> 01:16:35.480]  Космекспер-ранд
[01:16:35.480 --> 01:16:37.480]  это консектуально полная хрень.
[01:16:37.480 --> 01:16:39.480]  Так что если вы скопируете
[01:16:39.480 --> 01:16:41.480]  тот же файл пару раз, то будут разные типы.
[01:16:45.480 --> 01:16:47.480]  Ооо!
[01:16:49.480 --> 01:16:51.480]  Ладно, на этом весело
[01:16:51.480 --> 01:16:53.480]  я предлагаю закончить.
