[00:00.000 --> 00:12.880]  Всем доброго дня, давайте продолжать. В общем у нас получается с пятницы наступит такое интересное
[00:12.880 --> 00:19.040]  название занятия под названием колоквиум, которое нужно будет сдать. Значит по организационным
[00:19.040 --> 00:26.600]  моментам у некоторых групп получается большую часть людей мы сможем принять именно на
[00:26.600 --> 00:33.920]  семинарских занятиях. Некоторые допустим кто желает могут приходить на колоквиум в понедельник.
[00:33.920 --> 00:39.200]  Сразу скажу, что для моих групп это преимущественно будет сдача во время семинарского занятия.
[00:39.200 --> 00:50.240]  В понедельник будут времена такие, мы начнем в 4 часа вечера аудиторию уточним и там до
[00:50.240 --> 00:57.740]  собственного победного можно приходить. Каждый семинарист плюс-минус организует какое-то
[00:57.740 --> 01:04.520]  количество людей, которые могут сдавать в понедельник. Мы возвращаемся к последней теме,
[01:04.520 --> 01:09.640]  которую нам нужно разобрать перед колоквиумом, а именно теориям парика. Давайте напомним,
[01:09.640 --> 01:15.680]  про что вообще мы с вами говорили. Мы с вами построили в прошлый раз такое понятие как образ
[01:15.680 --> 01:33.920]  парика. Если у нас есть алфавит, вида а1, педали аккаты, мы с вами сказали, что мы
[01:33.920 --> 01:43.560]  строим отображение из сигма со звездой натуральные числа в катой степени. Здесь ноль принадлежит
[01:43.560 --> 01:55.840]  множеству натуральных чисел, которое сдается следующим образом. Неужели у нас какая-то тревога?
[01:55.840 --> 02:08.680]  Это количество буква а1, количество буква а2, количество буква аккаты. Мы с вами сказали,
[02:08.680 --> 02:26.440]  что у нас с вами есть линейное множество. Если х, это у нас линейная оболочка некоторых,
[02:26.440 --> 02:44.560]  пусть у НТ, где у ИТ принадлежит натуральным числом в катой степени. Сразу скажу, что здесь
[02:44.560 --> 03:01.520]  конечное множество. Нет, стоп, секунду, я написал фигню. Р линейный давайте назовем, если Р у нас
[03:01.520 --> 03:16.280]  представима. Вот так мы с вами определяли, где линейная оболочка у, это собственно все линейные
[03:16.280 --> 03:25.360]  комбинации, которые у нас могут быть. Давайте, я бы сказал, что вот так, это отдельная. Мы с вами
[03:25.360 --> 03:35.320]  задавали. Вот так вот. Вот, значит, при этом линейная оболочка. Что это такое? Давайте я напомню.
[03:35.320 --> 03:59.200]  Альфа и Т у ИТ, где альфа и Т принадлежат натуральным числом, натуральным с нулем. А у ИТ это у нас
[03:59.200 --> 04:12.040]  с вами Н в катой степени. Вот, так, сейчас, секунду, у НТ. Вот так вот. То есть мы берем вектора,
[04:12.040 --> 04:18.720]  картежи у нас, которые получаются из количества букв, и их складываем. Значит, сумма двух множеств,
[04:18.720 --> 04:23.800]  это у нас мы берем элемент из этого множества, берем элемент из этого множества и их складываем.
[04:23.800 --> 04:40.560]  И дальше мы сказали, что R полулинейно, если R представимо в виде конечного объединения линейных множеств.
[04:40.560 --> 04:52.240]  Вот, и мы с вами определили понятие линейного прообраза и полулинейного прообраза. Соответственно,
[04:52.240 --> 04:58.960]  это те языки, образ парика, которых линейн, и полулинейн, соответственно. И мы с вами в
[04:58.960 --> 05:12.120]  прошлый раз формулировали две теоремы, наш цель которой еще один доказать. Первая теорема,
[05:12.120 --> 05:26.680]  которая мы с вами будем доказывать для любого. Это простой факт достаточно. Для любого полулинейного.
[05:26.680 --> 05:45.440]  Что там написано? Ну, давайте обозначим размер фавитом. Существует R регулярный,
[05:45.440 --> 06:00.920]  такой что, собственно, все от R равно X. Образ парика, это штуки, это регулярный язык. Это
[06:00.920 --> 06:06.920]  полулинейное множество. Ну, давайте подумаем, как мы можем с вами работать с полулинейным множеством?
[06:06.920 --> 06:20.120]  Какой у нас есть аппарат для этого? Какой? Что мы ввели для полулинейного множества?
[06:20.120 --> 06:31.720]  Смотрите, это объединение линейных множеств. Ну, собственно, давайте начнем с этого доказательства.
[06:31.720 --> 06:47.400]  Итак, если у нас X полулинейно, тогда X раскладывается в объединение, где X и T это линейное.
[06:47.400 --> 07:10.840]  Найдем. Давайте напишу так. Регулярное выражение либо регулярный язык. Такое,
[07:10.840 --> 07:31.240]  что Psi от R и T равно X и T. Тогда вопрос. Psi от чего будет равно X нашему? Ну, конечно.
[07:31.240 --> 07:49.080]  А это язык какой будет? Объединение регулярных какое? Регулярное. Хорошо. Давайте искать
[07:49.080 --> 08:06.280]  такой регулярный язык. Значит, рассмотрим произвольное XGT. Оно линейное. Тогда что мы можем
[08:06.280 --> 08:10.360]  сказать про этот XGT? В каком виде мы его можем представить? Мы можем его представить в виде A
[08:10.360 --> 08:19.960]  плюс линейная оболочка некоторого множества B, где при этом множество B у нас конечное.
[08:19.960 --> 08:33.160]  Ну, давайте придумывать регулярку. Итак, поскольку у нас B конечное,
[08:33.160 --> 08:49.000]  это значит B состоит из каких-то множеств B1 и тогда BLT, где B и T у нас принадлежит N в степени
[08:49.000 --> 09:09.440]  нашего алфавита. Ну и A получается у нас такое же. Сейчас будут индексы.
[09:19.000 --> 09:36.920]  Произвольное. Теперь смотрите. Давайте поймем, что же на самом деле B и T такое. А B и T это на самом
[09:36.920 --> 09:58.200]  деле B и T1, B и T2. Это же кортеж. B модуль сигма. Ну, где B и T не отрицательные.
[09:58.200 --> 10:21.240]  А здесь индекс M. Не обязательно одинаковое количество. А мы берем два множества и их
[10:21.240 --> 10:24.920]  объединяем. То есть мы берем произвольные элементы отсюда, произвольные элементы отсюда,
[10:24.920 --> 10:38.760]  складываем их, получаем результат. Итак, давайте явно предоставим слово. Так, мы алфавит обозначили
[10:38.760 --> 10:47.560]  как-нибудь? Ой, у нас маппинг определений. Так, что сделаем? У нас буковки А там, это буковки
[10:47.560 --> 11:08.600]  алфавита. Давайте здесь C обозначим эту штуку. Итак, давайте напишем явно слово, образ которого
[11:08.600 --> 11:21.880]  будет равным B и тому. Ну да, смотрите, нам нужно слово, в котором вот столько букв А1, столько букв
[11:21.880 --> 11:31.800]  А2, столько букв, получается А последнее количество. Да? Собственно, пишем это слово. А1 в степени B и 1,
[11:31.800 --> 11:44.960]  А2 в степени B и 2 и так далее, А и получается, что там, о господи, так, а модуль сигма, модуль
[11:44.960 --> 11:55.800]  сигма равная B и T. Ага, ну в нем получается столько букв А1, столько букв А2, столько букв получается
[11:55.800 --> 12:06.200]  А3 и так далее. Так, хорошо. Так, а теперь давайте подумаем,
[12:06.200 --> 12:22.280]  Пси, от чего будет у нас сумма АИТ и БИТ? Давайте это как-нибудь обозначим. Пусть это у нас W,
[12:22.280 --> 12:36.960]  пусть это будет у БИТ. Как тогда задать вот такой образ? Коэффициент произвольный? У нас линияная оболочка?
[12:36.960 --> 12:51.080]  Да, то есть смотрите, нам нужно вот эту вот всю вещь повторить АИТ раз, произвольная. А что значит
[12:51.080 --> 12:57.640]  произвольное количество раз не меньше нуля? Повторите произвольное слово. Звести звездочку? То есть у
[12:57.640 --> 13:06.440]  нас получается, что это Пси. Вот, господи, сейчас мы будем колдовать. Стоит вести определение, например,
[13:07.440 --> 13:10.880]  стоит А, вот, и БИТ. Да.
[13:10.880 --> 13:39.800]  Во. А? Не, не строго больше нуля. Не, мы вводили не меньше нуля.
[13:39.800 --> 13:49.000]  Мы искали нутральное с нулем. Так, образ этой штуки мы написали с вами. Так,
[13:49.000 --> 14:03.840]  теперь нам нужно написать образ вот этой штуки. Ну, давайте опять же аналогично
[14:03.840 --> 14:16.600]  введем. Значит, слова У, Ц, И, Т такие, что Пси от У, Ц, И, Т равно циитому. В принципе,
[14:16.600 --> 14:30.840]  делается ровно тем, что нам подсчетом, да? Почему? Где Б? Где, где, где Б?
[14:33.840 --> 14:43.920]  А, да, конечно же. Да, да, да, да. Все, спасибо. Да, я в индексах запутался. Так,
[14:43.920 --> 15:02.880]  значит, теперь смотрите, как задать множество ц? Да. Если что, это сложение регулярных выражений.
[15:02.880 --> 15:21.080]  С. Ага, и тогда у нас ответ какой получается? Как слово в итоговое выглядит? Как наш
[15:21.080 --> 15:38.280]  итоговое регулярное выражение будет? Да. Циит это кортеж. У циит это слово, образ парика,
[15:38.280 --> 15:46.440]  которого это кортеж циит. Ну, то есть она строится так. У нас циит и кортеж. Мы считаем
[15:46.440 --> 16:01.160]  каждый раз количество букв и говорим... Где, где, где? Нет, это маленькие. Да, это кортеж.
[16:01.160 --> 16:24.600]  Умножить на... Господи, я надеюсь, я не обсчитался. Ц, плюс линейная оболочка Б. То есть сначала
[16:24.680 --> 16:32.480]  берем произвольное слово здесь, потом берем произвольное слово здесь, отсюда. Получается
[16:32.480 --> 16:42.480]  количество букв, которые здесь и здесь складываются, поэтому здесь получается сумма. Вроде сошлось.
[16:42.480 --> 17:01.200]  Вот, ну то есть это чистая вычислительная задача. Ну да, мы нашли экзиты, а дальше нам нужно
[17:01.200 --> 17:05.520]  их объединить всех. Вот эти вот, для каждого экзита нам вот эти штуки нужно объединить.
[17:05.520 --> 17:21.840]  Ну, собственно, это доказательство. Давайте проверим. Ну, здесь немножко по-другому сделали.
[17:21.840 --> 17:29.080]  Здесь взяли сумму, взяли со звездочкой. Мне кажется, это не особо отличается. Примеры,
[17:29.160 --> 17:38.640]  собственно, а примеров не видно, потому что свет горит, да? Ну видно, линейная оболочка 1,
[17:38.640 --> 17:45.080]  2, плюс линейная оболочка 2, 1. Это, собственно, мы берем АБ квадрат и А квадрат Б и делаем над
[17:45.080 --> 17:55.520]  этим всем звездом. Здесь такой же пример, а здесь вот такой вот пример, собственно. Ничего здесь
[17:55.520 --> 18:08.840]  сложного особо нет. Так, с этим пунктом разобрались? Так, еще раз.
[18:08.840 --> 18:24.560]  Нет, ну тут же мы считаем количество букв только, поэтому неважно. То есть, в принципе, тут как
[18:24.560 --> 18:30.080]  раз слова коммунитируют в смысле образа. То есть, неважно, как одно слово написать,
[18:30.080 --> 18:35.600]  одно слева, другое справа или наоборот. Так, а теперь сложная часть этого картобалета,
[18:35.600 --> 18:39.760]  состоящая в том, что нам надо доказать следующую вещь. Теперь мы парик будем доказывать,
[18:39.760 --> 18:52.320]  что если ЛКС язык, то на самом деле это прообраз некоторого полуминейного множества. И вот здесь
[18:52.320 --> 19:01.520]  нам понадобится еще одна лемма о разрастании. Третья уже. Так,
[19:01.520 --> 19:24.160]  значит ЛКС язык, следовательно, полуминейное множество.
[19:31.960 --> 19:39.800]  Ну что, давайте докажем этот факт. Но честно, тут доказательство такое крайне не тривиальное,
[19:39.800 --> 19:47.480]  и поскольку в прошлые года эта лекция была последней, а на ней мы рисовали очень много
[19:47.480 --> 19:53.360]  елочек, то будем считать, что мы отвечаем не знаю чего. То есть, это была новогодняя лекция,
[19:53.360 --> 20:00.920]  но сейчас, к сожалению, это не новогодняя лекция. Вот, это в принципе мы с вами говорили. Так,
[20:00.920 --> 20:22.480]  давайте лему о разрастании докажем. Обобщение. Давайте рассмотрим, что у нас ЛКС язык.
[20:22.480 --> 20:36.160]  Тогда существует П, такое, что для любого слова, лежащего в этом языке, длина которого хотя бы П.
[20:36.160 --> 20:47.360]  Существует разбиение. Так, сейчас забыл. Любого К. Забыл вставить больше нуля. Существует такое П,
[20:47.360 --> 20:54.560]  что для любого слова языка, длина которого хотя бы больше П, существует разбиение.
[20:54.560 --> 21:16.720]  Х, У1, УКТ, У, ВКТ, В1, З. Такое, что, значит, получается длина вот этого штуки, вот этого
[21:16.720 --> 21:35.600]  разрастания не больше, чем П. Значит, для любого Г, получается длина УГТ, ВГТ, длина разрастания больше нуля.
[21:35.600 --> 21:49.880]  Такое, что у нас есть дерево вывода. Я не пишу что-то, для любых индексов мы можем разрастать это
[21:49.880 --> 22:00.520]  как угодно, потому что по факту это будет разрастание. Вы не против, если я картинкой
[22:00.520 --> 22:11.200]  нарисую вот эту штуку. Смотрите. Так, что у нас?
[22:30.520 --> 22:53.360]  Что это такое? Елка. Вопрос, как разрастать? Для контекста свободных языков. Ну, почти можем.
[22:53.360 --> 23:00.720]  Нет, тут для любого К. Мы доказали для К равную единицу, на самом деле, этот факт.
[23:00.720 --> 23:15.920]  Не очень хорошо, нет, не хотим. Не, ну индукцию. Давайте вспоминать, как мы доказывали оригинальную
[23:15.920 --> 23:30.720]  лему разрастания для контекста свободных языков. Да, причем брали грамматику в нормальной
[23:30.720 --> 23:37.120]  форме Хомского, брали достаточно большую глубину дерева таким образом, чтобы у нас какое-то
[23:37.120 --> 23:43.040]  правило выводилось ровно два раза. Идея тут ровно такая же. Единственное, что надо П правильно задать.
[23:43.040 --> 24:06.400]  Итак, опять же, давайте возьмем грамматику в нормальной форме Хомского и возьмем П равное
[24:06.400 --> 24:20.880]  два в степени Н на К. Ну, факт из этого следовать будет, что мы можем сколько угодно что-то повторять.
[24:20.880 --> 24:32.160]  Ну, мы можем везде, где у нас есть не терминал, подвешивать либо У2, У2, либо УК, ВК, либо произвольные
[24:32.160 --> 24:40.440]  из них. То есть берем подвешиваем. То есть у нас получается просто индексов здесь много быть. То есть
[24:40.440 --> 24:45.520]  мы можем просто в любой момент либо разрастить У1 в какое-то количество раз, либо У2 в какое-то
[24:45.520 --> 24:53.200]  количество раз, У2, В2, либо У3 и так далее. В чем произвольном порядке. Вот, как раз для этого нам
[24:53.200 --> 25:00.160]  нужно было с вами использовать вот такие вот интересные фишки. Так, ну смотрите, у нас длина
[25:00.160 --> 25:14.280]  слова хотя бы ДВ значит длина. Следовательно, у нас высота дерева вывода. Что у нас получается,
[25:14.280 --> 25:25.120]  Господи. Мы с вами в какой-то момент вывели оценку из того, что у нас дерево бинарное.
[25:25.120 --> 25:40.440]  НК плюс 1. А что это значит, что у нас высота нашего дерева хотя бы количество не терминалов плюс 1?
[25:40.440 --> 25:58.160]  Да еще помноженное на К. Да, причем хотя бы К плюс 1 раз. Вот. И получаем, что у нас есть не
[25:58.160 --> 26:26.800]  терминал А, который повторяется хотя бы К плюс 1 раз. На слайде? Да, на самом деле единиц не хватает,
[26:26.800 --> 26:33.800]  но там логарифм на двоечке, а длина слова ДВ это НК, поэтому там НК плюс 1 получается. Да,
[26:33.800 --> 26:41.680]  надо слайд поправить. Ну и вот, ну и давайте возьмем это слово. Берем самый нижний К плюс 1 вхождение,
[26:41.680 --> 26:49.840]  как мы это делали в прошлый раз. Получаем такое дерево. Ну это пример. То есть если мы с вами
[26:49.840 --> 27:02.440]  посмотрим на картинку, рассмотрим самое глубокое вхождение. Кто может напомнить,
[27:02.440 --> 27:14.480]  почему мы смотрим самое глубокое вхождение? Ну для того, чтобы ограничить длину вот этого вывода.
[27:14.480 --> 27:24.040]  Да, ну мы с вами говорили, что если у нас в обычном случае эта длина вывода не очень большая,
[27:24.040 --> 27:28.600]  то можно прямо оценку сверху на количество не терминалов, которые на высоту этого вывода
[27:28.600 --> 27:33.320]  получить. И получаем, что у нас это все сверху будет ограничено.
[27:44.480 --> 28:04.480]  Сверху ограничивается. Там что-то логарифм. Как раз логарифм. Сейчас. 2 в степени логарифм,
[28:04.480 --> 28:14.320]  там было Н на К. Ну а собственно это число П. Вот. А почему у нас УКТ и ВКТ не пустые?
[28:14.320 --> 28:19.320]  Кто мне может напомнить? УИТ и ВИТ, почему не пустые?
[28:19.320 --> 28:43.520]  В смысле как раз встречается? Да, мы берем отсечение по К буквам А. Которое, точнее самое
[28:43.520 --> 28:54.920]  глубокое отсечение по К плюс одной буквы А. И стартуем именно отсюда. В чем вопрос? Может быть,
[28:54.920 --> 29:02.000]  я не понял. Мы берем самое глубокое отсечение по деревьям и поднимаемся вверх? Нет, у нас есть ветвь,
[29:02.000 --> 29:10.080]  в которой есть хотя бы К плюс одна буква А. Какой-то не терминал. Мы берем из всех ветвей такой не
[29:10.080 --> 29:19.800]  терминал, у которого К плюс первая буква встречается как можно глубже. Но чтобы остальных буква просто
[29:19.800 --> 29:25.480]  не было. И других не терминалов не было. Потому что если бы они были бы, мы бы спустились еще ниже
[29:25.480 --> 29:33.560]  и сжали бы наше дерево. Вот. И получается сверху ограничение на высоту этого дерева вывода. Высота
[29:34.320 --> 29:41.120]  будет не больше, чем количество терминалов на К. Из этого, как мы в прошлый раз доказывали,
[29:41.120 --> 29:49.360]  обычно лему о разрастании, у нас появляется оценка сверху на П. Вопрос, почему у житое выжитое не пустое?
[29:49.360 --> 30:04.920]  Да, потому что мы находимся в нормальной форме хомского. Я отсылаю всех желающих доказательств
[30:04.920 --> 30:19.640]  2 лему о разрастании. Пл2 это если что пампинг лемма 2. Ну вот, вроде доказали этот факт. Есть
[30:19.640 --> 30:30.760]  вопросы по доказательству этого утверждения? Это высота дерева. То есть у нас длина дерева вывода
[30:30.760 --> 30:44.280]  не больше, чем двойка в степени высота этого дерева. Ой, да, все согласен. Давайте перепишем это все.
[30:44.280 --> 31:11.040]  Там, по-моему, плюс-минус 1, по-моему, вот так это было. Вот, это П. Вот, то есть получается,
[31:11.160 --> 31:17.000]  у житое выжитое больше нуля. Ну, собственно, поэтому у нас есть такое дерево вывода, и мы им будем пользоваться.
[31:17.000 --> 31:31.120]  Понятно ли доказательство? Так, вот это дерево мы не стираем, потому что мы сейчас им будем пользоваться.
[31:31.120 --> 31:40.080]  Вспоминаем, раньше мы лему о разрастании использовали только в отрицательной коннотации.
[31:40.400 --> 31:46.640]  Говорили, что пусть оно не выполнено, тогда, собственно, что-то делаем. А здесь мы его будем
[31:46.640 --> 31:53.160]  использовать в положительной коннотации. Итак, давайте вернемся к доказательству нашего факта.
[31:53.160 --> 32:07.760]  Давайте рассмотрим Л. У нас КС язык. Единственное, сейчас надо вспомнить, чему взять К. Так,
[32:07.760 --> 32:20.920]  сейчас, секунду. Во, замечательно. Давайте лему о разрастании немножко попозже. Берем Ж.
[32:20.920 --> 32:48.760]  В НФ Омского. И давайте введем следующий язык. Элема G это множество всех слов w таких,
[32:48.760 --> 33:13.560]  что только по нетерминалам из m. m это произвольное подношение терминалов в
[33:13.560 --> 33:31.760]  то есть мы будем использовать только не терминалы м да при этом понятно что с будет лежать то есть
[33:31.760 --> 33:37.640]  если м не содержит стартовое состояние то если м не содержит стартовый терминал то ничего вывести
[33:37.640 --> 33:44.600]  мы не можем потому что его просто нет давайте формулируем некоторые понятия первое что мы
[33:44.600 --> 33:50.880]  можем сказать про элема дж как соотносится элема дж
[34:02.880 --> 34:07.920]  раз а чему равняется объединение всех элентах
[34:14.600 --> 34:23.960]  вот и еще важно что забыл сказать давайте сделаем так что элема дж всегда содержит не
[34:23.960 --> 34:32.760]  терминалы м то есть вот этот пример показывает что если у нас множество м не терминалов содержит
[34:32.760 --> 34:40.080]  с а б и мы из с повторяемся вывести а а а с а в м а а то а не будет лежать в элема дж потому
[34:40.080 --> 35:04.000]  что там нет не терминала б дайте выточенную причем все не терминалы используются вот и мы
[35:04.000 --> 35:10.880]  будем доказывать следующее что элем а дж это линейный прообраз
[35:34.000 --> 35:44.400]  тогда
[35:44.400 --> 35:57.520]  объединение по всем не терминалом а дж это будет у нас полу линейный прообраз
[35:57.520 --> 36:12.160]  собственно что мы хотим доказать а теперь давайте посмотрим на вот это замечательное
[36:12.160 --> 36:19.200]  дерево так понятно почему если мы докажем что а дж это линейный прообраз то то и весь язык у
[36:19.200 --> 36:27.720]  нас является полу линейным прообразом я там полу линейным написал все отлично так смотрите
[36:27.720 --> 36:35.560]  а теперь замечательная фишка давайте рассмотрим как количество не терминалов и п излема
[36:35.560 --> 37:05.400]  разрастания так а на всякий пожарный ну можно модулем
[37:05.400 --> 37:12.160]  попробовать взять этого должно хватить вот и давайте теперь посмотрим на следующие вещи пусть
[37:12.160 --> 37:26.840]  у нас x сейчас в общем идея такая вот у нас видите елка большая длинное слово слово длины хотя бы
[37:26.920 --> 37:35.240]  давайте мы разрежем эту елку на несколько частей первая елка будет состоять это знаете фундамент
[37:35.240 --> 37:40.760]  такой елки маленький прототип елки ну видели там сборную конструкцию какой-нибудь это елка у
[37:40.760 --> 37:48.040]  которой не очень высокая которая вот слово длины не больше чем п и всякие эти аддоны к ней а вот
[37:48.040 --> 37:54.920]  в качестве аддонов мы будем использовать вот эти вот аддоны вот вот это у нас каркаса это у
[37:54.920 --> 38:01.000]  нас аддона и докажем что наш язык это на самом деле ничто иное как вот этот каркас плюс
[38:01.000 --> 38:08.120]  линейная оболочка наших аддонов вот собственно это мы и будем доказывать давайте теперь чуть
[38:08.120 --> 38:20.920]  формальнее в общем давайте x это у нас будет все от w для всех слов образ длина не больше чем
[38:20.920 --> 38:32.680]  п собственно y будет такое что длина не больше чем п и у нас вывод как раз вот эта
[38:32.680 --> 38:56.680]  куска только по не терминалы мз так давайте перепишу все от л
[38:56.680 --> 39:07.360]  только по не терминалам мз
[39:07.360 --> 39:20.320]  контрольный вопрос почему все эти множество конечным почему x конечный y конечным
[39:20.320 --> 39:39.520]  тоже слов конечно конечно же вот и будем по ночь после перерыва доказывают два утверждения
[39:39.520 --> 39:48.360]  по обе стороны что на самом деле все от л ма дже равняется x плюс линейная оболочка y
[39:48.360 --> 40:03.160]  одно доказать одна сторона будет конструктивной другая красивая с точки зрения теории
[40:03.160 --> 40:08.760]  да да да
[40:18.760 --> 40:27.760]  фишка состоит в следующем напоминаю значит давайте кантилет с континю плис смотрите у нас
[40:28.760 --> 40:35.200]  значит деревья вывода этого слова будут все не терминал из множества м и здесь будут
[40:35.200 --> 40:42.840]  все не терминал из множества м а этом давайте рассмотрим пусть у нас есть какое-то число
[40:42.840 --> 40:51.640]  т кортеж принадлежащий x плюс линейная оболочка y это значит что наш кортеж
[40:51.720 --> 41:00.560]  выглядит как следующее у нас есть какой-то и все это плюс сумма альфа и ты и ты так ведь
[41:00.560 --> 41:11.560]  логичный так теперь смотрите а давайте поймем что это значит что вот эта штука лежит фикс
[41:11.560 --> 41:25.160]  следовательно существует такое выжитое что эта длина выжитого не больше чем длины
[41:25.160 --> 41:38.120]  п и это выжитое лежит в л м дже так ведь все логично а теперь строим картинку значит дереве
[41:38.120 --> 41:46.560]  слова вывода вот этого вышитого есть все не терминалы из м пока что картинку нарисовали
[41:46.560 --> 41:55.560]  теперь смотрите что означает что игреки ты лежит в игреке это следует что из этого
[41:55.560 --> 42:06.080]  следует что существует такая пара пара уитая витая и существует такой б и ты лежащий кстати
[42:06.080 --> 42:16.080]  множестве м и только из них такое что у нас есть дерево вывода б и ты выводу и ты бы и ты
[42:16.080 --> 42:27.040]  вы и ты слишком много индексов и что мы можем сказать про эти индексы б и ты если они в этом
[42:27.040 --> 42:46.640]  дереве вывода из s слово wg т если тут у нас не терминал бы один в этом дереве вывода есть а почему
[42:46.640 --> 43:03.560]  смотрите бои ты лежит в м дубль выжитое лежит в л м дже а что значит условия лежит в л м дже
[43:03.560 --> 43:10.080]  значит все не терминалы из м у нас используется а это значит что в этом дереве есть точно где-то
[43:10.080 --> 43:26.360]  не терминал бы один так ведь давайте найдем но найдем б2 найдем б3 найдем б м т значит и теперь
[43:26.360 --> 43:32.520]  прикол почему это называется почему это называлось елочной лекции потому что по факту каждый из этих
[43:32.520 --> 43:42.640]  аддонов мы теперь спокойно можем подвесить к какому-то из этих кусков если нам надо
[43:42.640 --> 43:54.560]  разрастить б1 из у1 б1 в 1 то мы к тому месту где у нас есть б1 подвешиваем у1 б1 в 1 при этом у
[43:54.560 --> 44:05.000]  нас же слово будет вот это дополненно лежать в л м дже если мы подвесим к б1 вот сюда вот этот
[44:05.000 --> 44:13.000]  кусок дерева вывода ну конечно он будет висеть потому что у нас все не терминалы из м есть вот ну
[44:13.000 --> 44:30.400]  и поэтому значит берем следующую конструкцию подвешиваем альфа катая раз так давайте альфа
[44:31.400 --> 44:49.620]  вот полученное слово будет лежать в л м дже но потом а подвешим ну ровно находим не терминал
[44:49.620 --> 44:57.320]  б1 и нам надо разрастить наше слово целиком но чтобы найти точнее слово про образ которого
[44:57.320 --> 45:04.160]  является нашим множеством вот это вот вот это вот слово это слово образ которого это
[45:04.160 --> 45:10.520]  элемент множество x нам надо подвесить добавить сюда единичку к игреку какой-то игреки ты взять
[45:10.520 --> 45:19.280]  мы берем допустим игрек один находим не терминал б1 он точно есть берем за него подвешиваем поскольку
[45:19.280 --> 45:25.120]  у нас неважно в каком порядке стоят буквы для того чтобы получить образ парика то берем можем
[45:25.120 --> 45:30.280]  подвешивать любое место то есть берем и встречаем тогда у нас получается что psi
[45:30.280 --> 45:42.400]  грубо говоря там дубль выжитая и давайте я не знаю как написать какой буквы какой буквы хаус
[45:42.400 --> 45:56.760]  обозначим можно культурно можно не культурно да какое-нибудь слово
[46:12.400 --> 46:29.320]  давайте вот так обозначим это оператор хаус что мы в любое место в какое-то место вставили
[46:29.320 --> 46:38.000]  слово у 1 в 1 я не знаю просто как обозначить это значит слово у нас есть слово выжитая но где-то
[46:38.000 --> 46:42.840]  в промежутке в этом слове выжитом мы еще вставляем слово у 1 а где-то вставляем
[46:42.840 --> 46:53.400]  условия 1 непонятно в какое место на презентации это просто картинка короче которая все поясняет
[46:53.400 --> 47:02.400]  да вот но поскольку неважно куда нам это вставлять это все равно все от выжитого плюс все от у 1 в 1
[47:02.400 --> 47:10.640]  вот это у нас игрок один а это у нас экзитове то есть неважно куда мы ставим словом все равно
[47:10.640 --> 47:16.960]  образ парика будет его вот таким вот экзитой и у 1 игрок один а поскольку у нас есть это не
[47:16.960 --> 47:22.120]  терминал мы можем его подвесить куда угодно и мы получаем слово вот это вот слово будет лежать
[47:22.120 --> 47:30.160]  в элемент же потому что вот это слово содержатся не терминалы изн и только их а это тоже в выводе
[47:30.160 --> 47:40.240]  этого слова мы используют только не терминалы из м так и таким образом мы можем подвесить
[47:40.240 --> 47:51.120]  каждое слово альфа и т.б. и т.п. определенное количество раз и получить получается произвольное
[47:51.120 --> 47:54.240]  множество отсюда оно будет лежать в элемент же
[48:00.160 --> 48:06.200]  во
[48:06.200 --> 48:17.960]  картинку показать красивую в общем для тех кто это собственно это вывод построим про образ для
[48:17.960 --> 48:29.480]  х вот то есть нашли б1 подвесили к нему нашли б2 подвесили к нему нашли б3 подвесили к нему
[48:29.480 --> 48:44.920]  и так далее что в одну сторону кажется доказали да что вот это вещь выложена вот эту вещь
[48:44.920 --> 48:52.360]  теперь в обратную сторону нам у нас есть какое-то дерево вывода нам его надо распилить
[48:52.360 --> 49:01.000]  ну представьте себе искусственную елку вам надо взять искусственную елку собрать значит причем
[49:01.000 --> 49:09.040]  поскольку значит ситуация плохая это кризис все дела нам нужно сделать так что если допустим
[49:09.040 --> 49:17.240]  елок нам не хватает да мы могли каждый из кусок поставить как отдельную елку чтобы она не
[49:17.240 --> 49:22.840]  отличалась от оригинальных елок собственно давайте это делать значит
[49:22.840 --> 49:28.120]  заметьте эту картинку не стираю
[49:28.120 --> 49:42.040]  господи тяжелые реалии так давайте обратную сторону докажем что
[49:42.040 --> 49:58.680]  господи вот так вот ну что индукция по длине слова
[49:58.680 --> 50:15.560]  где вы лежит в эле моджа база как вы думаете какая база у нас будет
[50:15.560 --> 50:31.280]  ну тут можно общую базу сделать для нас раз длина слова не больше чем п
[50:31.280 --> 50:48.640]  тогда что мы можем сказать ну да потому что у нас x определялся как образ всех слов длина не
[50:48.640 --> 51:08.520]  больше чем п переход у нас длина слова больше чем п это значит что мы можем с вами сделать
[51:08.520 --> 51:31.920]  мы можем применить лему о разрастании 3 и так применяем лему разрастание 3 что мы получаем
[51:31.920 --> 51:42.120]  тут нужно некоторый счет опять же возьмем самое глубокое дерево в общем всю конструкцию
[51:42.120 --> 51:52.200]  которая у нас была немножечко перерисуем ее и так что у нас будет с вами здесь у нас
[51:52.200 --> 52:01.280]  будет дальше у нас будет а x z сейчас единственное дайте мне посмотреть обозначение чтобы они из
[52:01.280 --> 52:11.160]  презентации соглашались во обозначим наши слова мы кажется ко взяли количество правил
[52:11.160 --> 52:37.920]  грамматики да значит тут а 0 так что дальше на ката так какая то у нас количество не
[52:37.920 --> 52:57.840]  терминалов если что и тут у нас получается что внизу y да цель нашего всего этой ситуации тут
[52:57.840 --> 53:04.040]  у нас будет а в степени количественные терминалов минус 1 найти кусок который мы можем с вами отрезать
[53:04.040 --> 53:13.840]  что необходимо для этого куска который мы с вами хотим отрезать мы хотим чтобы длина этого
[53:13.840 --> 53:23.840]  куска была не больше чем п ну нашего под дерево при этом в нем точно содержались бы все не терминалы
[53:23.840 --> 53:43.360]  из м да а смотрите я кстати тут оговорился кажется мне хорошо вопрос задали значит здесь могут
[53:43.360 --> 53:49.000]  быть не все не терминалы из м вот я кажется давайте уточнение то есть тут могут быть произвольные
[53:49.000 --> 53:54.520]  не обязательно все но здесь должны быть все не терминалы из м то есть нам надо отрезать кусок
[53:54.520 --> 54:04.080]  такой чтобы при убирании него количество не терминалов разных в этом деле вывода оставалось
[54:04.080 --> 54:18.480]  ровно таким же а теперь давайте считать рубрика комбинаторика и принцип дирекле
[54:18.480 --> 54:28.160]  потом формально ведем вот смотрите давайте подумаем вот вот здесь вот у нас сколько не
[54:28.160 --> 54:37.160]  терминалов разных может быть
[54:37.160 --> 55:02.120]  количество не терминалов всего но утверждение такое что когда смотрим на это дерево вывода
[55:02.120 --> 55:09.440]  в нем в принципе могли встречаться все не терминала да но без буквы а сколько не
[55:09.440 --> 55:31.000]  терминалов в этом деле вывода без отжитого там может сказать сколько тут не терминалов
[55:31.000 --> 55:41.160]  без отжитого без ашек они на один меньше может быть и хуже да смотрите мы брали
[55:41.160 --> 55:46.680]  вся мое глубокое вхождение из м минус одного термина не терминал это значит что вот по цепи
[55:46.680 --> 55:57.880]  вывода у нас не терминала а на самом деле не было вот давайте как раз это сейчас вот все
[55:57.880 --> 56:08.440]  не терминала выводя вот и тогда смотрите что получается а утверждение следующее что
[56:08.440 --> 56:21.320]  вот здесь вот их не больше чем а минус 1 здесь сколько не терминалов
[56:21.320 --> 56:40.160]  вот здесь ну хотя бы но ну хотя бы 0 но то есть получается смотрите вот здесь у нас не больше
[56:40.160 --> 56:49.960]  чем n минус 1 здесь у нас точно хотя бы 0 а теперь смотрите что у нас получается если мы обозначаем
[56:49.960 --> 57:08.800]  м и т кроме а
[57:08.800 --> 57:23.320]  мы поняли с вами что м 0 не больше чем количество не терминалов минус 1 но при
[57:23.320 --> 57:44.960]  этом это больше равно чем нам один м n вопрос сколько у нас здесь чисел
[57:44.960 --> 57:54.480]  в этой последовательности сколько элементов в этой последовательности
[57:54.480 --> 58:00.920]  количество не терминалов
[58:00.920 --> 58:12.440]  да выводе из ажитого то есть грубо говоря м2 это количество не терминалов которые идут вот
[58:12.520 --> 58:25.240]  этом дереве в котором выкинули все буквы а сколько у нас их сколько чисел у нас от
[58:25.240 --> 58:36.520]  нуля до количества не терминалов количество терминалов плюс один количество значений сколько
[58:42.440 --> 58:53.360]  так это значит что
[58:53.360 --> 58:59.960]  в принципе дирекле
[58:59.960 --> 59:20.280]  а что значит что у нас количество не терминалов вы в выводе не поменялось то есть смотрите у
[59:20.280 --> 59:27.680]  нас какая картинка у нас картинка следующий что у нас есть а т дальше выводим а т плюс
[59:28.080 --> 59:34.600]  и количество не терминалов которые есть в этом выводе совпадается количеством не терминалов
[59:34.600 --> 59:49.720]  которые есть в этом выводе это значит что если мы выпилим вот эту вот часть то мы не выкинем
[59:49.720 --> 01:00:10.120]  никакого не терминала давить да собственно вот эту штуку нам надо выкинуть тогда а т т
[01:00:10.120 --> 01:00:36.480]  а получается так там все хорошо не меняет количество не терминалов
[01:00:41.120 --> 01:00:50.040]  но мы берем такие ребята значит у вас вот это вот елочка которая вот здесь
[01:00:50.040 --> 01:00:53.680]  была она была хорошая мы просто берем утаскиваем ее с собой
[01:00:53.680 --> 01:01:00.680]  давайте давайте финализируем
[01:01:10.120 --> 01:01:23.160]  как написать бы
[01:01:23.160 --> 01:01:31.040]  x у 1
[01:01:41.120 --> 01:01:58.120]  я просто выписываю в 1 z вот это вот слово будет лежать в эле модже
[01:01:58.120 --> 01:02:07.280]  да мы это с вами доказали как раз выкинув эту часть тут нет т плюс один и получается
[01:02:07.280 --> 01:02:21.160]  слово у получается фи си у т плюс один ф плюс один принадлежит игреку выполняем адапционный переход
[01:02:37.280 --> 01:02:47.180]  на этом доказательство те рем заканчивается потому что мы доказали что каждый образ или а дж это
[01:02:47.180 --> 01:02:59.560]  линейное множество да еще раз этот шаг значит мы ищем такой момент в котором в подглубине
[01:03:00.340 --> 01:03:08.380]  не меняется общее кроме этого не кроме а а шки это значит вот вот в этом вот под куски вывода
[01:03:08.380 --> 01:03:14.180]  вот которые вот вот нас здесь раскрывается если мы его выкинем то количество терминалов не
[01:03:14.180 --> 01:03:19.940]  поменяется разных которые используются в этом по дереве это значит что если мы вот эту штуку
[01:03:19.940 --> 01:03:26.400]  при фигачем к этой то если в ней были во всем дереве выводов были не терминала из м причем
[01:03:26.400 --> 01:03:34.400]  все, то и без вот этой штуки останутся все эти терминалы из m, и все будут использованы.
[01:03:34.400 --> 01:03:40.400]  Значит, вот эту вот штуку мы относим к y, а вся остальная штука остается в lmg.
[01:03:40.400 --> 01:03:46.400]  Мы слово уменьшили, поскольку у нас длина, ужитое, выжитое, вот этое, вот этое больше нуля.
[01:03:46.400 --> 01:03:49.400]  Уменьшаем длину слова и делаем индукционный переход.
[01:03:57.400 --> 01:04:01.400]  Хорошо. Понятно доказать теоремы?
[01:04:02.400 --> 01:04:05.400]  Вот, в колоксе оно, по-моему, разбито на три вопроса.
[01:04:07.400 --> 01:04:12.400]  Так, давайте следствие, быстро докажем следствие.
[01:04:13.400 --> 01:04:15.400]  Такое?
[01:04:18.400 --> 01:04:21.400]  А, следствие? Ну он золотый днис доказывается.
[01:04:22.400 --> 01:04:25.400]  Ну, чуть-чуть.
[01:04:26.400 --> 01:04:31.400]  Не, можно это при помощи лемма о разрастании доказывать, конечно, потому что, на самом деле,
[01:04:31.400 --> 01:04:35.400]  теорема парик освоится к тому, что мы просто используем лемму о разрастании, по факту.
[01:04:36.400 --> 01:04:38.400]  Следствие, любое однобуквенное язык.
[01:04:44.400 --> 01:04:46.400]  KVS язык регулярно.
[01:04:52.400 --> 01:04:54.400]  Однобуквенный.
[01:05:00.400 --> 01:05:02.400]  Альфавита за одной буквой состоит.
[01:05:07.400 --> 01:05:09.400]  Почему?
[01:05:12.400 --> 01:05:16.400]  Ну, потому что есть регулярка над тем, что алфавита для вещей.
[01:05:17.400 --> 01:05:20.400]  Ну, да, смотрите.
[01:05:22.400 --> 01:05:27.400]  Значит, что такое язык над однобуквенным алфавитом?
[01:05:30.400 --> 01:05:33.400]  Мы понимаем с вами, что...
[01:05:34.400 --> 01:05:38.400]  Господи, давайте я напишу следующее, это будет страшно.
[01:05:47.400 --> 01:05:51.400]  Все помните, что это такое?
[01:05:53.400 --> 01:05:55.400]  Что это за знак?
[01:05:56.400 --> 01:05:58.400]  Не, не изоморфизм.
[01:05:59.400 --> 01:06:07.400]  Равномочность. То есть у нас есть биекция между сигмой со звездом и натуральными числами.
[01:06:07.400 --> 01:06:09.400]  Ну, потому что любое слово...
[01:06:17.400 --> 01:06:19.400]  Не, не, не.
[01:06:20.400 --> 01:06:23.400]  Изоморфизм, по-моему, вот так обозначается.
[01:06:26.400 --> 01:06:31.400]  Да, в общем, разномочно, потому что любое слово имеет вид авкатой.
[01:06:32.400 --> 01:06:33.400]  Да?
[01:06:34.400 --> 01:06:39.400]  Ладно, пусть будет N, если мы с нулем считаем. У нас все равно все с нулем.
[01:06:41.400 --> 01:06:45.400]  Хорошо, а теперь смотрите, примейте ремпарика.
[01:06:46.400 --> 01:06:48.400]  Угу.
[01:07:03.400 --> 01:07:05.400]  Ну, значит, что такое? Псиатель.
[01:07:06.400 --> 01:07:08.400]  Это X.
[01:07:10.400 --> 01:07:11.400]  Там.
[01:07:16.400 --> 01:07:17.400]  Линейные, да?
[01:07:17.400 --> 01:07:22.400]  Ну, давайте рассмотрим одно из них. Если каждый из них будет регулярным, то и все объединение будет регулярным.
[01:07:22.400 --> 01:07:24.400]  Ну, а что такое X и T?
[01:07:25.400 --> 01:07:30.400]  Это некоторое С плюс линейная оболочка В.
[01:07:32.400 --> 01:07:33.400]  Да?
[01:07:33.400 --> 01:07:36.400]  Ну, где С и В конечное множество.
[01:07:36.400 --> 01:07:40.400]  Ну, а дальше, тут уже можно как угодно говорить.
[01:07:41.400 --> 01:07:50.400]  Поскольку у нас с вами натуральные числа и эти изоморфины, то тут можно делать все, что угодно.
[01:07:50.400 --> 01:07:54.400]  То есть, на самом деле, здесь у нас какой-то С1 и так далее, СМ.
[01:07:56.400 --> 01:08:00.400]  Ну, а дальше, тут уже можно как угодно говорить.
[01:08:00.400 --> 01:08:02.400]  Ну, а дальше, тут уже можно как угодно говорить.
[01:08:02.400 --> 01:08:05.400]  То есть, на самом деле, здесь у нас какой-то С1 и так далее, СМ.
[01:08:07.400 --> 01:08:12.400]  А здесь у нас получается В1, кто ли, ВМТ.
[01:08:12.400 --> 01:08:26.400]  Ну, собственно, вот эти ребята задаются как А в степени В1 получается А в степени ВМТ со звездой.
[01:08:30.400 --> 01:08:31.400]  Вот так.
[01:08:35.400 --> 01:08:38.400]  Вот, а эти задаются А в степени С и В.
[01:08:40.400 --> 01:08:45.400]  Ну, собственно, помните, как мы доказывали первый факт, что прообраз, существует регулярный прообраз?
[01:08:45.400 --> 01:08:50.400]  Просто здесь из этого будет именно вывод, что это именно регулярный прообраз. Обязательно такой.
[01:08:55.400 --> 01:08:56.400]  Нет, не обязательно.
[01:09:00.400 --> 01:09:01.400]  Вот так вот.
[01:09:02.400 --> 01:09:05.400]  Ну, то есть, это красивый вывод.
[01:09:08.400 --> 01:09:12.400]  Из того, что просто образ парика по факту является Ч.
[01:09:13.400 --> 01:09:18.400]  Биекция между множеством натуральных чисел и Сигмы со звездой.
[01:09:21.400 --> 01:09:23.400]  Так, ну что, понятно доказательство этого факта?
[01:09:24.400 --> 01:09:25.400]  Хорошо.
[01:09:26.400 --> 01:09:33.400]  А давайте тогда я сейчас немножечко-немножечко начну говорить про то, про что будет наша следующая часть курса.
[01:09:34.400 --> 01:09:39.400]  Да, все, выдохнули. Мы закончили с категорическими грамматиками в их классическом проявлении.
[01:09:40.400 --> 01:09:43.400]  И сейчас начинается самая интересная часть нашего курса.
[01:09:45.400 --> 01:09:48.400]  Вы помните, какой алгоритм мы с вами уже парсинга проходили?
[01:09:50.400 --> 01:09:53.400]  И почему он нам не понравился?
[01:09:56.400 --> 01:09:59.400]  Кока-янгеракасами мы проходили алгоритм с вами.
[01:10:00.400 --> 01:10:01.400]  В чем его проблема была?
[01:10:02.400 --> 01:10:03.400]  Он вообще долгий, куб.
[01:10:04.400 --> 01:10:07.400]  И вообще он просто берет и делает динамическое программирование.
[01:10:08.400 --> 01:10:09.400]  Это крайне интересно.
[01:10:10.400 --> 01:10:11.400]  И на практике вообще неприменимо.
[01:10:12.400 --> 01:10:19.400]  Поэтому целью нашей вот этой части, посвященной именно парсингу, будет построить такое семейство алгоритмов,
[01:10:19.400 --> 01:10:24.400]  которое, во-первых, как-то учитывало, что мы находимся в каком-то дереве вывода.
[01:10:25.400 --> 01:10:26.400]  Что у нас есть дерево вывода.
[01:10:27.400 --> 01:10:31.400]  А во-вторых, учиться именно парсить входной текст достаточно эффективным образом.
[01:10:32.400 --> 01:10:39.400]  На самом деле первый прообраз нашей теоремы, нашего парсинга, мы уже с вами проходили.
[01:10:40.400 --> 01:10:46.400]  Посмотрите внимательно то, как мы можем из кс-грамматики построить mp-автомат.
[01:10:46.400 --> 01:10:52.400]  Вот если внимательно посмотреть и немножко развернуть конструкцию, которая получится, мы с вами получим парсер.
[01:10:54.400 --> 01:10:56.400]  Кажется, на семинарию своей группы я это делал.
[01:10:57.400 --> 01:11:00.400]  Но, собственно, потом сейчас тоже мы можем это сделать.
[01:11:01.400 --> 01:11:03.400]  Виталий про это тоже, наверное, скажет.
[01:11:04.400 --> 01:11:06.400]  Итак, давайте рассмотрим.
[01:11:07.400 --> 01:11:08.400]  Значит, у нас есть парсер.
[01:11:09.400 --> 01:11:11.400]  Он работает с грамматикой нормальной формы Хомского.
[01:11:12.400 --> 01:11:14.400]  Но можем ли мы сделать парсер для произвольной грамматики?
[01:11:15.400 --> 01:11:17.400]  Вот такой у нас вопрос!
[01:11:24.400 --> 01:11:28.400]  Произвольная кодекс-свободной грамматика!
[01:11:32.400 --> 01:11:36.400]  Для кодекса-обедной формы Хомского мы можем парсер построить?
[01:11:37.400 --> 01:11:38.400]  Мы его уже строили.
[01:11:38.400 --> 01:11:39.600]  Мы его уже строили.
[01:11:39.600 --> 01:11:41.600]  Можно ли мы его построить для произвольной грамматики?
[01:11:41.600 --> 01:11:43.600]  Давайте рассмотрим такую грамматику.
[01:11:45.600 --> 01:11:48.200]  S-v-u-e-t-s-b, c-s-v-u-e-t-s-o-m.
[01:11:48.200 --> 01:11:49.200]  Что это за грамматика?
[01:11:49.200 --> 01:11:50.600]  Какой язык она задает?
[01:12:00.200 --> 01:12:02.400]  Аббревиатуру из трех буквок.
[01:12:03.400 --> 01:12:05.600]  P-s-p — это правильность кубочной последовательности.
[01:12:06.600 --> 01:12:08.600]  Давайте разберем какое-нибудь слово.
[01:12:10.600 --> 01:12:12.600]  Построим дерево разбора.
[01:12:13.600 --> 01:12:15.600]  Дерево разбора такое.
[01:12:17.600 --> 01:12:20.600]  И вот давайте попробуем это дерево разбора пройти в глубину.
[01:12:23.600 --> 01:12:25.600]  Там нормально видно на слайде?
[01:12:26.600 --> 01:12:29.600]  И давайте сделаем две пометки.
[01:12:30.600 --> 01:12:35.600]  Первая пометка — это то, откуда мы пришли,
[01:12:35.600 --> 01:12:38.600]  и вторая — то, где мы сейчас находимся.
[01:12:38.600 --> 01:12:42.600]  По факту, что нам необходимо для того, чтобы реализовать поиск глубину?
[01:12:44.600 --> 01:12:47.600]  Давайте, господа программисты математики.
[01:12:51.600 --> 01:12:54.600]  На каких особенностях у нас реализован поиск глубину?
[01:12:54.600 --> 01:12:55.600]  Дерево.
[01:12:55.600 --> 01:12:57.600]  Что мы находимся в стеке.
[01:12:58.600 --> 01:13:03.600]  Что если мы находимся в каком-то месте, в обходе DFS,
[01:13:03.600 --> 01:13:08.600]  то, в принципе, выйдя из функции, мы вернемся к родителю
[01:13:08.600 --> 01:13:10.600]  и мы находимся в текущей позиции.
[01:13:10.600 --> 01:13:15.600]  То есть на самом деле это нам позволяет реализовывать это на стеке.
[01:13:15.600 --> 01:13:18.600]  И, в принципе, если мы понимаем, куда нам выпрыгнуть,
[01:13:18.600 --> 01:13:21.600]  в аккосе, я не знаю, был такой термин Calling Conventions.
[01:13:23.600 --> 01:13:26.600]  То есть если мы правильно с вами зададим Calling Conventions,
[01:13:27.600 --> 01:13:29.600]  то, в принципе, нам важно знать только просто,
[01:13:29.600 --> 01:13:33.600]  где мы сейчас находимся и куда нам обратно возвращаться.
[01:13:36.600 --> 01:13:40.600]  И давайте на этой основе попытаемся построить парсер.
[01:13:42.600 --> 01:13:44.600]  Итак, давайте обходить дерево.
[01:13:44.600 --> 01:13:45.600]  Парсер.
[01:13:47.600 --> 01:13:49.600]  Итак, давайте обходить дерево разбора.
[01:13:49.600 --> 01:13:50.600]  Смотрите, точка.
[01:13:50.600 --> 01:13:52.600]  Видите, черная точка появилась.
[01:13:54.600 --> 01:13:57.600]  Давайте попытаемся гипотетически обойти это дерево разбора.
[01:13:57.600 --> 01:14:01.600]  Возможно, будет парсеров очень много, много разных способов.
[01:14:02.600 --> 01:14:04.600]  Куда мы пойдем сейчас с вами?
[01:14:06.600 --> 01:14:07.600]  Перед буквой А.
[01:14:07.600 --> 01:14:08.600]  Мы прыгаем вниз.
[01:14:08.600 --> 01:14:12.600]  При этом, когда мы идем в DFS, мы не забываем, откуда мы прыгали.
[01:14:14.600 --> 01:14:15.600]  Что мы сделаем?
[01:14:19.600 --> 01:14:21.600]  А правила разобрать не надо?
[01:14:27.600 --> 01:14:28.600]  У нас слово ААББ.
[01:14:28.600 --> 01:14:30.600]  Нам бы его надо разобрать.
[01:14:31.600 --> 01:14:32.600]  Давайте подумаем.
[01:14:32.600 --> 01:14:35.600]  Если бы у нас в этой штуке первая буква была ББ,
[01:14:35.600 --> 01:14:37.600]  мы бы что сказали, скорее всего?
[01:14:37.600 --> 01:14:41.600]  Ну, сказали до свидания, потому что первая буква у нас не совпадает.
[01:14:42.600 --> 01:14:43.600]  А теперь смотрите.
[01:14:43.600 --> 01:14:47.600]  У нас первая буква А в нашем слове.
[01:14:47.600 --> 01:14:51.600]  И как раз вот та шапка, которую мы насадили, хорошо нам подходит.
[01:14:52.600 --> 01:14:54.600]  Поэтому давайте просто прочитаем букву А
[01:14:54.600 --> 01:14:56.600]  и сдвинем нашу точку за букву А.
[01:14:58.600 --> 01:14:59.600]  Да, Вить?
[01:15:01.600 --> 01:15:02.600]  Ну вот.
[01:15:02.600 --> 01:15:04.600]  Просто это мы гипотетически обойти.
[01:15:05.600 --> 01:15:06.600]  Ну вот.
[01:15:06.600 --> 01:15:10.600]  Просто это мы гипотетически будем делать для всех подобных конструкций.
[01:15:11.600 --> 01:15:13.600]  Так, встретили не терминал.
[01:15:14.600 --> 01:15:15.600]  Что делаем?
[01:15:22.600 --> 01:15:24.600]  Да, при этом построить дерево вывода.
[01:15:27.600 --> 01:15:31.600]  Ну вот, нам надо понять, как строить это дерево вывода.
[01:15:31.600 --> 01:15:34.600]  Я как раз разбираю гипотетическое дерево вывода,
[01:15:34.600 --> 01:15:37.600]  которое мы якобы уже знаем, и хочу промотать инструкцию.
[01:15:38.600 --> 01:15:40.600]  Как мы обошли это дерево вывода.
[01:15:41.600 --> 01:15:44.600]  Только просто история такая, что мы сейчас правила грамматики
[01:15:44.600 --> 01:15:47.600]  превратим некоторые конструкции, которые мы можем с вами соединять.
[01:15:50.600 --> 01:15:53.600]  Ну вот, смотрите, если мы встретились с препятствием,
[01:15:53.600 --> 01:15:56.600]  что мы стараемся сделать с этим препятствием?
[01:15:57.600 --> 01:15:58.600]  Убирать его?
[01:15:58.600 --> 01:16:02.600]  Ну, значит, все действия алгоритмов, про которые будет говорить Виталий,
[01:16:02.600 --> 01:16:04.600]  будут прямо проходить его.
[01:16:06.600 --> 01:16:09.600]  А если мы не можем пройти на пролом, то мы что делаем?
[01:16:10.600 --> 01:16:12.600]  Обходим его, да. Именно спускаемся вниз.
[01:16:12.600 --> 01:16:17.600]  И смотрите, для того чтобы получить Calling Conventions,
[01:16:17.600 --> 01:16:20.600]  мы берем и спускаемся вниз и точку тянем за собой.
[01:16:21.600 --> 01:16:24.600]  Да, то есть куда мы должны вернуться обратно?
[01:16:26.600 --> 01:16:28.600]  Какое английское слово вы говорите?
[01:16:29.600 --> 01:16:30.600]  Какое?
[01:16:32.600 --> 01:16:34.600]  Calling Conventions.
[01:16:35.600 --> 01:16:36.600]  То есть когда мы...
[01:16:37.600 --> 01:16:40.600]  Да, термин для тех, у кого нет окост.
[01:16:40.600 --> 01:16:43.600]  На самом деле, когда мы вызываем какую-то функцию,
[01:16:43.600 --> 01:16:45.600]  мы на самом деле что-то в регистрах должны хранить.
[01:16:45.600 --> 01:16:48.600]  И для того чтобы вернуться из функции,
[01:16:48.600 --> 01:16:50.600]  нам необходимо понять, в каком месте мы находимся,
[01:16:50.600 --> 01:16:53.600]  в какой стэк у нас содержится и где у нас указатель,
[01:16:53.600 --> 01:16:55.600]  где мы вообще находимся.
[01:16:55.600 --> 01:16:58.600]  Поэтому специально говорится, что в определенных регистрах
[01:16:58.600 --> 01:17:01.600]  мы сохраняем информацию, которая необходима для того,
[01:17:01.600 --> 01:17:03.600]  чтобы мы могли вернуться из этой функции.
[01:17:05.600 --> 01:17:07.600]  Вот, это называется Calling Conventions.
[01:17:07.600 --> 01:17:10.600]  Механизм, соглашение при вызове функций.
[01:17:15.600 --> 01:17:17.600]  Да, да.
[01:17:18.600 --> 01:17:22.600]  Причем точки эти мы потом трансформируем в позиции,
[01:17:22.600 --> 01:17:25.600]  где мы находимся в слове, то есть в какой букве мы находимся.
[01:17:26.600 --> 01:17:29.600]  Вот, смотрите, дальше мы... Следующая буква А, окей.
[01:17:30.600 --> 01:17:32.600]  Дальше мы спускаемся вниз.
[01:17:33.600 --> 01:17:35.600]  Поскольку слово пустое, то мы находимся здесь.
[01:17:36.600 --> 01:17:37.600]  Так, теперь что делаем?
[01:17:38.600 --> 01:17:40.600]  Мы дошли до конца правила,
[01:17:40.600 --> 01:17:42.600]  и мы находимся в каком-то не терминале.
[01:17:43.600 --> 01:17:44.600]  Это значит что?
[01:17:45.600 --> 01:17:46.600]  Мы разобрались.
[01:17:46.600 --> 01:17:48.600]  Значит мы эту точку можем обойти.
[01:17:48.600 --> 01:17:51.600]  То есть если у нас получается черная точка,
[01:17:51.600 --> 01:17:53.600]  и черная точка находится в конце правила,
[01:17:54.600 --> 01:17:57.600]  а верхняя точка стоит передний терминал, мы ее можем обойти.
[01:17:58.600 --> 01:17:59.600]  То есть мы можем замкнуть наши препятствия.
[01:18:00.600 --> 01:18:04.600]  При этом, поскольку у нас есть Calling Conventions для вот этой вот точки,
[01:18:05.600 --> 01:18:08.600]  то когда мы вернемся здесь, мы поймем, что точку надо вернуть сюда.
[01:18:09.600 --> 01:18:11.600]  Для этого нам нужен указатель на родителя.
[01:18:12.600 --> 01:18:15.600]  То есть смотрим указатель на родителя здесь, он был здесь,
[01:18:16.600 --> 01:18:17.600]  и перемещаем эту штуку.
[01:18:17.600 --> 01:18:19.600]  Ну и повторяем такую процедуру.
[01:18:20.600 --> 01:18:23.600]  Потом опять возвращаемся вверх, проходим вот это сюда,
[01:18:24.600 --> 01:18:26.600]  переходим сюда, спускаемся вниз, проходим сюда,
[01:18:27.600 --> 01:18:28.600]  обходим слово целиком.
[01:18:30.600 --> 01:18:31.600]  Обход в глубину.
[01:18:34.600 --> 01:18:35.600]  Только вопрос в том,
[01:18:36.600 --> 01:18:39.600]  а если у нас ни одно дерево вывода, что делать?
[01:18:42.600 --> 01:18:45.600]  Ну вот, оказывается, на самом деле все эти дыры,
[01:18:45.600 --> 01:18:49.600]  ну вот, оказывается, на самом деле все эти точки можно закодировать позициями.
[01:18:51.600 --> 01:18:54.600]  Дерево входим в глубину, по позициям точек можно обойти дерево разбора,
[01:18:55.600 --> 01:18:56.600]  точки кодируют правила вывода.
[01:18:57.600 --> 01:18:58.600]  И идея следующая.
[01:18:59.600 --> 01:19:04.600]  Давайте мы с вами для каждого правила ведем такое понятие, ситуации,
[01:19:05.600 --> 01:19:06.600]  мы его еще в следующий раз определим.
[01:19:07.600 --> 01:19:09.600]  Допустим, мы разобрали какую-то часть правила альфа,
[01:19:10.600 --> 01:19:12.600]  и нам осталось разобрать часть правила, связанную с бетой.
[01:19:12.600 --> 01:19:14.600]  И мы находимся в текущей позиции точку,
[01:19:15.600 --> 01:19:18.600]  и говорим, что вот это вот правило,
[01:19:19.600 --> 01:19:21.600]  это ситуация, а, стрелочка, альфа, точка, бета,
[01:19:22.600 --> 01:19:24.600]  запятая и принадлежит некоторому мнению множеству джи-тэ.
[01:19:25.600 --> 01:19:26.600]  Что такое и жи по факту?
[01:19:27.600 --> 01:19:30.600]  Позиция вот этой круглой точки, полой точки,
[01:19:31.600 --> 01:19:32.600]  это и позиция родителя,
[01:19:33.600 --> 01:19:35.600]  сколько мы символов разобрали в родителе,
[01:19:36.600 --> 01:19:37.600]  а жи это наша текущая позиция.
[01:19:37.600 --> 01:19:40.600]  Ну альфа и бета, это левая часть правой части правила
[01:19:41.600 --> 01:19:42.600]  и правая часть правой части правила.
[01:19:43.600 --> 01:19:44.600]  Вот пример.
[01:19:46.600 --> 01:19:47.600]  Вот, сейчас давай.
[01:19:48.600 --> 01:19:49.600]  Вот пример.
[01:19:50.600 --> 01:19:51.600]  Давайте разберем его.
[01:19:52.600 --> 01:19:53.600]  Значит, как задать это правило?
[01:19:54.600 --> 01:19:55.600]  У нас есть с,
[01:19:56.600 --> 01:19:58.600]  мы разобрали уже кусок ас,
[01:19:59.600 --> 01:20:01.600]  и у нас осталось разобрать кусок бэта.
[01:20:02.600 --> 01:20:03.600]  Вот, вот, вот.
[01:20:03.600 --> 01:20:05.600]  Нас разобрали кусок ас
[01:20:06.600 --> 01:20:08.600]  и у нас осталось разобрать кусок бэс.
[01:20:09.600 --> 01:20:11.600]  При этом здесь мы разобрали одно слово,
[01:20:12.600 --> 01:20:14.600]  а здесь мы разобрали уже одну букву,
[01:20:15.600 --> 01:20:17.600]  а здесь мы разобрали две буквы.
[01:20:19.600 --> 01:20:21.600]  Поэтому эта ситуация кодируется таким образом,
[01:20:22.600 --> 01:20:23.600]  что из с мы вывели...
[01:20:24.600 --> 01:20:25.600]  находим ситуацию с, стрелочка ас,
[01:20:26.600 --> 01:20:28.600]  точка, вот эта жирная точка, ela здесь, б-с.
[01:20:29.600 --> 01:20:32.600]  При этом здесь мы разобрали одно слово,
[01:20:33.600 --> 01:20:39.600]  А вот здесь у нас нижнее правило говорит, что мы уже разобрали два символа слова.
[01:20:40.600 --> 01:20:44.600]  Вот такой математический термин мы можем с вами зашить.
[01:20:44.600 --> 01:20:49.600]  И теперь утверждение следующее, что на самом деле нам не важно,
[01:20:49.600 --> 01:20:52.600]  где мы находимся в дереве вывода.
[01:20:52.600 --> 01:20:56.600]  Какой родитель, какой контекст. Нам достаточно вот эти вот позиции.
[01:20:57.600 --> 01:20:59.600]  Только их.
[01:21:00.600 --> 01:21:01.600]  А?
[01:21:02.600 --> 01:21:05.600]  Ситуация состоит из правила грамматики.
[01:21:05.600 --> 01:21:06.600]  Раз.
[01:21:07.600 --> 01:21:09.600]  Левой части до точки.
[01:21:09.600 --> 01:21:12.600]  Точка стоит в произвольном месте правила.
[01:21:12.600 --> 01:21:14.600]  Правая часть после точки.
[01:21:14.600 --> 01:21:16.600]  Ситуация в родителе.
[01:21:16.600 --> 01:21:20.600]  Позиция, сколько букв мы прочитали после родителя.
[01:21:20.600 --> 01:21:23.600]  И сколько на текущий момент мы прочитали букв.
[01:21:24.600 --> 01:21:29.600]  Значит две буквы мы прочитали. Вот они. Буква А и буква А.
[01:21:32.600 --> 01:21:35.600]  И это сколько букв мы прочитали до вот этого момента.
[01:21:37.600 --> 01:21:38.600]  А?
[01:21:40.600 --> 01:21:42.600]  Да, да, да.
[01:21:43.600 --> 01:21:49.600]  Просто почему это называется D2? Потому что это удобно будет хранить в виде множеств.
[01:21:49.600 --> 01:21:51.600]  А на сколько угодил квадрат?
[01:21:52.600 --> 01:21:57.600]  А алгоритм будет работать за куба длины слова, но с сильно меньшей асимпточкой, чем алгоритм Эрли.
[01:21:57.600 --> 01:22:00.600]  Ой, чем алгоритм Кока-Янгера Касами.
[01:22:00.600 --> 01:22:03.600]  И в случае однозначной грамматики он будет работать за квадрат.
[01:22:04.600 --> 01:22:06.600]  С меньше константов.
[01:22:06.600 --> 01:22:07.600]  Да, да, да.
[01:22:07.600 --> 01:22:10.600]  Либо куб сильно меньше константов, либо квадрат.
[01:22:12.600 --> 01:22:14.600]  Ну и в общем смотрите.
[01:22:14.600 --> 01:22:17.600]  Последний момент, как это можно перешифровывать.
[01:22:18.600 --> 01:22:23.600]  Оказывается, что чтение буквы можно просто изменить здесь G на G плюс один.
[01:22:25.600 --> 01:22:28.600]  Здесь мы можем спуститься грамотно, переделать это правило.
[01:22:29.600 --> 01:22:30.600]  И complete.
[01:22:31.600 --> 01:22:35.600]  Мы тоже, используя вот эти позиции, можем с вами перепрошить эту штуку.
[01:22:36.600 --> 01:22:37.600]  Используя просто вот эти множества.
[01:22:38.600 --> 01:22:40.600]  Но это мы с вами разберем уже в следующий раз.
[01:22:42.600 --> 01:22:45.600]  И докажем некоторые факты, посвященные этой ситуации.
[01:22:45.600 --> 01:22:46.600]  Что такое ситуация.
[01:22:47.600 --> 01:22:49.600]  И будем доказывать некоторую динамику.
