[00:00.000 --> 00:09.440]  Сегодня последняя лекция первого модуля, который посвящен всяким железякам.
[00:09.440 --> 00:19.040]  Мы раньше рассматривали такое понятие, как вычислительный процессор. Что это такое? Это
[00:19.040 --> 00:27.280]  какие-то блоки, которые могут выполнять разные операции над регистрами, как-то взаимодействовать
[00:27.280 --> 00:33.640]  с памятью. Причем чтение загрузка у процессора быстрее всего осуществляется именно с кэш памятью.
[00:33.640 --> 00:40.200]  Но на самом деле иметь просто какой-то набор вычислительных блоков, набор регистров без
[00:40.200 --> 00:47.620]  возможности как-то связаться с внешним миром, чтобы можно было выявлять результаты выполнения
[00:47.620 --> 00:54.160]  работы, это как-то не очень осмысленно. И хотя большинство современных систем делаются в формате
[00:54.160 --> 01:01.960]  системы на кристалле, когда у вас есть одна большая микросхема, на которой можно запихать и несколько
[01:01.960 --> 01:10.080]  ядер обычного процессора, несколько ядер графического сопроцессора, какую-то периферию,
[01:10.080 --> 01:15.240]  но чаще всего такие системы на кристалле используются в мобильных устройствах,
[01:15.240 --> 01:21.800]  телефоны, планшеты, но в какой-то степени это относится в том числе и к современным
[01:21.800 --> 01:29.600]  обычным десктопным процессорам, внутри которых запихали какую-то часть периферии, например,
[01:29.600 --> 01:37.280]  контроллер управления памятью, но на самом деле так было не всегда и у большинства современных
[01:37.280 --> 01:44.680]  компьютеров на самом деле архитектура она очень похожа идеологически и с программной точки зрения
[01:44.680 --> 01:57.000]  на очень старинные компьютеры еще до эпохи x86, а именно со времен 8-битных процессоров. Что
[01:57.000 --> 02:04.600]  такое процессор? Это просто некоторая микросхема, которая позволяет общаться с внешним миром,
[02:04.600 --> 02:14.400]  используя какие-то сигналы через шину данных. Что такое шина? Шина это какая-то последовательность
[02:14.400 --> 02:21.840]  рядом идущих проводников. Обычно размер шины, то есть количество проводников, связанных между
[02:21.840 --> 02:28.200]  собой идеологически, определяется разрядностью процессора, то есть если процессор у нас 8-битный,
[02:28.200 --> 02:35.520]  у него 8-битные регистры, то как правило шина данных у него будет тоже 8-битная, то есть за один
[02:35.520 --> 02:46.960]  такт он позволяет с внешним миром передавать только 8-бит. Кроме шины данных, на которые как раз
[02:46.960 --> 02:55.800]  передаются сами данные, есть еще шина адреса. Обычно она не всегда совпадает, по разрядности с
[02:55.800 --> 03:04.280]  шиной данных может быть больше. Вот шина адреса она предназначена для того, чтобы выбирать либо
[03:04.280 --> 03:12.240]  различные устройства, либо внутри устройств разные ячейки памяти, если например это оперативная
[03:12.240 --> 03:19.120]  память, либо что-то с буферизацией. Точно так же, как и шина данных, шина адреса состоит из
[03:19.120 --> 03:25.760]  множества проводников, но если у вас 16 контактов на шине адреса, то вы можете адресовать максимум
[03:25.760 --> 03:37.240]  2 в 16 байт, но это получается 64 килобайта. Кроме того, обычно на всех системах есть контакт под
[03:37.240 --> 03:43.240]  названием clock, что это такое? У нас все устройства должны работать с некоторой фиксированной
[03:43.240 --> 03:50.840]  частотой, чтобы как-то синхронизироваться между собой. В старых системах частота была порядка
[03:50.840 --> 03:58.440]  нескольких мегагерц, в современных системах, хотя процессоры работают на частотах уже в
[03:58.440 --> 04:07.840]  несколько гигагерц, сами системные шины все-таки они работают на частотах сотен мегагерц, поскольку
[04:07.840 --> 04:16.800]  не все устройства очень быстро. И если у вас есть несколько устройств, пусть даже однотипных,
[04:16.800 --> 04:22.360]  например, много разных микросхем памяти, чем больше микросхем памяти вы стоите, тем больше у вас
[04:22.360 --> 04:28.840]  оперативной памяти доступна, то нужно иметь возможность выбирать каждую микросхему по
[04:28.840 --> 04:36.960]  отдельности. В старых системах для этого использовался дешифратор, это микросхема, которая принимает на
[04:36.960 --> 04:50.240]  вход некоторые 4 бита для того, чтобы выбрать в десятичной записи какую-то
[04:50.240 --> 04:55.760]  конкретную микросхему и включить ее для взаимодействия. Все остальные микросхемы, которые
[04:55.760 --> 05:03.360]  подключены к общим шинам адреса и данных, они оставались без взаимодействия. В современных
[05:03.360 --> 05:09.600]  системах что-то подобное реализуется в микросхемах памяти, то есть когда вы втыкаете какую-то планку,
[05:09.600 --> 05:16.000]  вообще что из себя представляет планка памяти? Это одна микросхема с контроллером, обычно по центре
[05:16.000 --> 05:23.800]  планки располагается, и куча одинаковых микросхем, которые навешаны на одни и те же контакты. И кроме
[05:23.800 --> 05:32.160]  того, у систем могут быть артагональные адресные пространства как для обращения в память,
[05:32.160 --> 05:39.240]  так и для взаимодействия с межней периферией, так называемые порты ввода-вывода. В старых
[05:39.240 --> 05:45.160]  системах они обычно переключались отдельным контактом, то есть режим работы был, когда вы
[05:45.160 --> 05:52.240]  на адресной шине выставляли либо адрес памяти, либо адрес какой-то периферийной микросхемы. Почему я вам
[05:52.240 --> 05:58.760]  рассказываю всю эту историю? Потому что с программы точки зрения многое из этого до сих пор актуально,
[05:58.760 --> 06:08.800]  хотя физическая реализация у нас совершенно другая. Что такое порты ввода-вывода? Это некоторые
[06:08.800 --> 06:15.960]  устройства, которые адресуются точно так же, как память. На самом деле порты ввода-вывода бывают
[06:15.960 --> 06:22.520]  двух видов. Некоторым из них соответствует какое-то отображаемое в реальное адресное пространство,
[06:22.520 --> 06:30.640]  то есть у вас может быть оперативная память, в которой вы обращаетесь, и в каких-то соседних
[06:30.640 --> 06:39.720]  физических адресах может располагаться данный не в памяти оперативной, а, например,
[06:39.720 --> 06:48.440]  видеопамять. Так реализован, например, протокол VGA, то есть некоторый минимальный интерфейс на
[06:48.440 --> 06:55.920]  всех PC-компьютерах до запуска их сервера, который позволяет отображать консольный текст либо
[06:55.920 --> 07:05.640]  простую графику через фреймбуфер. Портмэпт это как раз противоположность, это ортогональное
[07:05.640 --> 07:12.000]  адресное пространство, через которое можно взаимодействовать только специальными командами
[07:12.000 --> 07:20.560]  процессора для Intel IN и OUT. Одновременно процессор не может адресовать и память, и
[07:20.560 --> 07:28.480]  порты ввода-вывода. То есть процессор должен, если вы хотите что-то вывести, например, через обычный
[07:28.480 --> 07:36.360]  портмэпт порты ввода-вывода, например, это взаимодействие с жестким диском, то процессор должен
[07:36.360 --> 07:44.960]  прочитать что-то в регистр из памяти, затем с помощью команды OUT записать это в порт
[07:44.960 --> 07:53.920]  вывода, при этом временно память отключить. Как можно посмотреть, какие порты у вас вообще в
[07:53.920 --> 08:03.040]  принципе есть. Есть файлы системы PROCFS, для того чтобы там что-то смотреть, нужно
[08:03.040 --> 08:13.600]  иметь права рута, просто так вам ничего не покажут. В PROCFS у вас есть
[08:13.600 --> 08:26.720]  такие файлики как IO ports, в которые содержится информация про порты ввода-вывода, к которым
[08:26.720 --> 08:32.240]  можно обращаться с помощью команд IN и OUT. Естественно, для этого вы должны находиться в
[08:32.240 --> 08:37.520]  привилегированном режиме работы процессора. Каким устройством можно обращаться через такие порты?
[08:37.520 --> 08:47.240]  Это могут быть разные таймеры, клавиатура, устройство для прямого доступа в память, демо,
[08:47.240 --> 08:56.680]  контроллер ATO дисков, он же SATA, ну и разные устройства для конфигурации, управления. На самом
[08:56.680 --> 09:01.800]  деле у меня не совсем честная система, поэтому список устройств он достаточно странный, не
[09:01.800 --> 09:07.320]  совсем честный, потому что это виртуалка Parallels. На реальном физическом устройстве у вас могут
[09:07.320 --> 09:15.160]  быть совершенно другие устройства. Адреса ввода-вывода для портов, с которыми можно
[09:15.160 --> 09:22.200]  взаимодействовать с помощью специальных команд процессора, они 16-битные, но на самом деле очень
[09:22.200 --> 09:29.560]  много их и не нужно, поскольку вот и вывод в какие-то порты, он осуществляется последовательным
[09:29.560 --> 09:39.040]  образом. Другой способ взаимодействия с портами, это некоторые отдельные устройства, которые можно
[09:39.040 --> 09:47.240]  посмотреть в PROC.IO.MEM, это те устройства, взаимодействие с которыми осуществляется просто самыми
[09:47.240 --> 09:53.560]  обычными инструкциями MOV, то есть с записью в память, но с записью в память по определенному адресу.
[09:53.560 --> 10:03.640]  Здесь можно взаимодействовать с таблицей прерываний, можно взаимодействовать с видеопамятью режима
[10:03.640 --> 10:11.000]  VGA, который на самом деле не очень много, это не вся видеопамять, что еще интересного, но в основном
[10:11.000 --> 10:21.800]  то, с чем можно взаимодействовать для конфигурации устройств, плюс еще контроллер SATA и контроллеры
[10:21.800 --> 10:35.640]  USB. Кроме портов водовывода, каждое устройство имеет связь с процессором под названием
[10:35.640 --> 10:44.280]  аппаратное прерывание, то есть кроме диапазона адресов портов водовывода, либо отображений на
[10:44.280 --> 10:55.000]  память, диапазона вывода и вывода, у каждого устройства есть некоторые прерывания, для чего они
[10:55.000 --> 11:03.120]  нужны. У процессора есть один контакт под названием интеракт, как только на этот контакт подается
[11:03.120 --> 11:09.480]  положительный сигнал, логическая единичка, то процессор немедленно приостанавливает свою работу,
[11:09.480 --> 11:19.880]  и дальше он должен выполнить какой-то обработчик прерывания. Что именно за обработчик, это зависит от
[11:19.880 --> 11:29.080]  того, какое устройство нам послало сигнал на прерывание. Сами обработчики обычно реализуются
[11:29.080 --> 11:33.720]  ядром операционной системы, а если у вас ядро операционной системы пока еще не загружено,
[11:33.720 --> 11:41.800]  то у вас есть базовая подсистема водовывода, он же биос, некоторая флеш-память, которая содержит
[11:41.800 --> 11:48.640]  минимальный набор функциональности для того, чтобы компьютер мог включиться и загрузиться и вообще
[11:48.640 --> 11:55.320]  что-то делать. После того, как процессор обработает прерывание, он может дальше продолжить свое
[11:55.320 --> 12:05.240]  выполнение. Как классические прерывания были устроены? Если рассмотреть процессоры 80-х,
[12:05.240 --> 12:11.600]  начала 90-х годов, то обычно прерывания реализовывались одной либо двумя микросхемами,
[12:11.600 --> 12:21.160]  которые включены в каскад. У каждого прерывания был свой номер от 0 до 15. Чем меньше номер
[12:21.160 --> 12:26.520]  прерывания, тем более высокий приоритет. То есть у нас одновременно несколько устройств могут
[12:26.520 --> 12:35.360]  подать сигнал о том, что возникло некоторое событие, и в этом случае больший приоритет имеет тот,
[12:35.360 --> 12:42.360]  у которого номер прерывания меньше. В совсем старых системах прерывания, конфигурируясь вручную
[12:42.360 --> 12:47.680]  с помощью джамперов, то есть что у нас происходит, когда какое-то устройство может взаимодействовать.
[12:47.680 --> 12:54.440]  Оно подает сигнал на прерывание. Дальше контроллер прерывания подает сигнал на прерывание процессору.
[12:54.440 --> 13:02.120]  Процессор опрашивает через шину данных этот контроллер, а что именно за устройство потребовало
[13:02.120 --> 13:08.640]  внимание, и в зависимости от того, какой номер ему выдал контроллер прерываний, дальше процессор
[13:08.640 --> 13:19.840]  выполняет какую-то функцию из области ядра. В современных системах никакой двухкаскадной
[13:19.840 --> 13:26.760]  системы нет. Прерываниями занимается отдельная микросхема, это программируемый контроллер
[13:26.760 --> 13:34.600]  прерываний. Что он делает? Он предназначен для того, чтобы получать прерывания от различных
[13:34.600 --> 13:41.280]  устройств, и в отличие от более старых систем, где для каждого устройства был зафиксирован
[13:41.280 --> 13:48.720]  жестко аппаратным образом порядковый номер прерываний и его приоритет, здесь прерывания
[13:48.720 --> 13:56.680]  складываются в очередь, и контроллер прерываний имеет таблицу с приоритетами, которая задается
[13:56.680 --> 14:04.760]  программно, на стадии загрузки компьютера, на стадии инициализации ядра, и дальше последовательно
[14:04.760 --> 14:13.040]  обрабатываются уже прерывания, и устройство будет легко переконфигурировано. Где можно посмотреть
[14:13.040 --> 14:21.000]  информацию о том, каким устройствам, какие прерывания связаны, вообще у каких есть прерывания.
[14:21.160 --> 14:31.560]  Рядом валяется файлик под названием interrupts в PROCFS. Здесь мы видим аппаратный таймер, устройство
[14:31.560 --> 14:41.200]  управления питанием, SATA-контроллер, звуковая плата, два контроллера для USB, точнее три контроллера
[14:41.200 --> 14:51.520]  для USB, и legacy контроллер прерываний, который обозначен как Intel 8042, это как раз по названию
[14:51.520 --> 14:56.640]  исходных старинных микросхем для того, чтобы можно было подключать какие-нибудь старые устройства,
[14:56.640 --> 15:01.840]  но опять же это может быть виртуальное устройство и физически к старому контроллеру прерываний
[15:01.840 --> 15:09.400]  ничего не подключено. Кроме того, есть некоторые специальные сигналы под названием не маскируемые
[15:09.400 --> 15:14.280]  прерывания. То есть аппаратные прерывания процессор может временно приостанавливать,
[15:14.280 --> 15:21.640]  например, когда выполняет какую-то операцию критичную по времени, какой-то код критичный по
[15:21.640 --> 15:28.760]  времени, он может временно остановить выполнение прерываний. И есть отдельный канал, отдельный
[15:28.760 --> 15:33.280]  контакт на процессоре, так называемый не маскируемое прерывание, которое в принципе никак нельзя
[15:33.280 --> 15:38.920]  перехватить или запретить. Но не маскированные прерывания обычно используются в промышленных
[15:38.920 --> 15:49.560]  компьютерах, например, для каких-нибудь аварийных кнопок. Как вообще процессор может взаимодействовать
[15:49.560 --> 15:56.920]  с каким-то устройством? Например, устройство по названию жесткий диск. Он может передавать
[15:56.920 --> 16:07.200]  данные, читая это сначала из памяти в регистры и потом записывая через команды in и out уже
[16:07.200 --> 16:14.680]  непосредственно в порты ввода-вывода. Чем такой подход плох? Он очень медленный, поскольку здесь
[16:14.680 --> 16:24.480]  требуется читать последовательно каждое машинное слово, все это прогонять через регистры, и процессор
[16:24.480 --> 16:30.200]  во время взаимодействия с каким-то внешним устройством через обычные порты ввода-вывода не
[16:30.200 --> 16:38.320]  может заниматься чем-то более полезным. Ну и альтернативой к такому подходу является прямой
[16:38.320 --> 16:48.200]  доступ в памяти, когда поддерживаемому прямой доступ памяти устройству либо контроллеру указывается
[16:48.200 --> 16:55.720]  некоторое место оперативной физической памяти, с которой он может взаимодействовать. То есть
[16:55.720 --> 17:03.880]  ядро перед взаимодействием аллоцирует несколько страниц памяти, дальше указывает устройству,
[17:03.880 --> 17:11.080]  что тебе разрешено писать либо читать сюда-отсюда. Все, дальше устройство уже непосредственно
[17:11.080 --> 17:19.280]  напрямую взаимодействует с памятью через один из каналов DMA, и как процессор узнает о том,
[17:19.280 --> 17:28.200]  что операция была уже выполнена. Устройство посылает информацию о том, что он закончил
[17:28.200 --> 17:35.360]  взаимодействие контроллеру DMA, дальше контроллер DMA сам по себе генерирует прерывания. Эти
[17:35.360 --> 17:41.360]  прерывания обычно имеют самый высокий приоритет, и процессор, обрабатывая прерывания от контроллера DMA,
[17:41.360 --> 17:50.080]  понимает, что какое-то устройство с определенным номером канала DMA завершило взаимодействие и
[17:50.080 --> 17:57.440]  значит, можно либо записать в память следующий кусок данных, например, если вы используете
[17:57.440 --> 18:04.960]  периферийные устройства для записи, либо наоборот понимает, что данные были прочитаны и уже
[18:04.960 --> 18:12.760]  находятся в памяти, с ними как-то можно работать. На самом деле взаимодействие с жесткими дисками
[18:12.760 --> 18:22.440]  через обычный неэффективный ввод-вывод, он был распространен достаточно давно и во многих
[18:22.440 --> 18:28.200]  операционных системах, включая MS-DOS, до сих пор используется именно этот способ взаимодействия.
[18:28.200 --> 18:35.200]  То есть, если вы используете компьютер без операционной системы, либо решите написать свою
[18:35.200 --> 18:40.600]  операционную систему с нуля, то самый простой способ взаимодействия, который описан во многих
[18:40.600 --> 18:49.880]  тьютериалах, это как раз взаимодействие через команды IN и OUT, очень медленный доступ. Более того,
[18:49.880 --> 18:57.560]  есть курс по разработке и внутреннему устройству операционных систем. Классический курс
[18:57.560 --> 19:04.000]  «Разработка операционных систем» от университета MIT и специально для этого учебного курса была
[19:04.000 --> 19:12.040]  разработана простая система UNIX-подобная XV6, до которой бедные американские дети учатся писать
[19:12.040 --> 19:20.080]  свои операционные системы. В этой операционной системе приводятся примеры только для того,
[19:20.080 --> 19:30.760]  как взаимодействие с диском через порты ввода-вывода неэффективно. Немного рекламы. Один из магистрантов
[19:30.760 --> 19:36.760]  нашей кафедры написал свою операционную систему, похожую на XV6, с теми же самыми целями,
[19:36.760 --> 19:45.280]  для образовательных целей. Если вы доживёте до следующего семестра, точнее до третьего курса,
[19:45.280 --> 19:50.560]  весельного семестра, тогда у вас будет возможность взять курс по выбору по разработке операционных
[19:50.560 --> 19:59.200]  систем, как раз на примере системе под названием HelloOS, где реализован доступ к диску с использованием
[19:59.200 --> 20:13.120]  DMA. Кроме портов ввода-вывода, есть доступ к оперативной памяти. Хотя в старых системах обычно
[20:13.120 --> 20:18.920]  отдельно использовался адрес отдельно шиноданных, в какой-то момент, когда микросхем памяти стало
[20:18.920 --> 20:26.760]  очень много, это оказалось неудобным, просто потому что много проводников. Более того,
[20:26.760 --> 20:33.120]  память вы можете наращивать, для этого используется отдельный интерфейс под названием DDR, то есть вы
[20:33.120 --> 20:42.360]  покупаете планки памяти, которые можете вставлять в некоторый унифицированный разъём. Что это за шина
[20:42.360 --> 20:53.760]  такая? Это шина, которая позволяет параллельно передавать 64 бита информации за один сигнал,
[20:53.760 --> 21:03.600]  но что такое один сигнал? Если в классической передаче данных у вас на один такт взаимодействия
[21:03.600 --> 21:10.840]  передаётся только один бит, то double data rate по названию означает, что вы передаёте за один
[21:10.840 --> 21:21.600]  тик целых два бита. За счёт чего это осуществляется? На самом деле, переключение между логическим нулём и
[21:22.080 --> 21:29.360]  единицей, то есть между нулевым напряжением и верхним порогом, например, 3 вольта, оно происходит
[21:29.360 --> 21:37.120]  неоднократно. Сначала есть быстрое нарастание, а потом быстрый спад. Так вот, можно фиксировать не
[21:37.120 --> 21:42.880]  только сам факт того, что у вас сигнал стал положителем, то есть появилось напряжение на
[21:42.880 --> 21:48.080]  каком-то пене, а отслеживать то, что напряжение увеличивается, то есть нарастающий фронт,
[21:48.080 --> 21:54.320]  либо, наоборот, напряжение спада. Поэтому за один такт можно передавать сразу два бита, и этот
[21:54.320 --> 21:59.680]  способ часто используется во многих шинных передачи данных, в том числе при взаимодействии с
[21:59.680 --> 22:09.920]  памятью. И сколько можно передавать данных за одну секунду, используя обычную шину памяти. Но здесь
[22:09.920 --> 22:19.680]  у разных планок памяти есть отдельные характеристики. Во-первых, на какой частоте
[22:19.680 --> 22:27.360]  максимальные эти планки памяти могут работать. Обычно они больше одного гигагерца, если посмотрите
[22:27.360 --> 22:34.280]  на современные планки, в том числе не самые дорогие. При этом за один тиг вы можете передавать два
[22:34.280 --> 22:45.760]  бита данных, и разрядность большинства современных планок памяти это 64 бита. То есть, если у вас
[22:45.760 --> 22:58.080]  частота полтора гигагерца, то вы можете передавать на один канал в секунду три миллиарда бит,
[22:58.080 --> 23:06.440]  или достигать суммарной скорости примерно 24 гигабайта в секунду. Но у планок памяти есть
[23:06.440 --> 23:16.120]  некоторые лаги по доступу, потому что данные между контроллером памяти, которые обычно внутри
[23:16.120 --> 23:23.200]  процессора, и самим самим планками памяти, передаются последовательно большими кусками. В виде
[23:23.200 --> 23:29.800]  набора команд, когда выбирается какой-то большой блок в оперативной памяти, и дальше выполняется
[23:29.800 --> 23:38.080]  операция чтения или записи последовательно нескольких непрерывных кусков. И обычно есть еще
[23:38.080 --> 23:45.280]  отдельный параметр, это таймингс. Чем он меньше, тем лучше. Он обычно определяет количество тиков,
[23:45.280 --> 23:54.840]  требуемых на начальный доступ к памяти, на выбор ячейки в строке и в столбце, которые требуются для
[23:54.840 --> 24:00.440]  взаимодействия. То есть, взаимодействие с оперативной памятью, оно хоть и достаточно быстрое по
[24:00.440 --> 24:09.440]  количеству передаваемых данных в секунду, но оно не самое быстрое для случайной выборки,
[24:09.840 --> 24:17.280]  для произвольного доступа. Этот недостаток обычно компенсируется наличием в процессоре кэшей из
[24:17.280 --> 24:24.640]  статической памяти, обычно данные загружаются одним большим блоком в кэш-память, а дальше процессор
[24:24.640 --> 24:35.800]  непосредственно работает уже с быстрой кэш-памятью. Кроме оперативной памяти, другая параллельная
[24:35.800 --> 24:44.440]  шина, раньше часто используемая в компьютерах, сейчас уже сильно реже, это PCI и одна из ее
[24:44.440 --> 24:55.200]  разновидностей под названием AGP. В этих шинах использовалась 32 либо 64-битная в последние
[24:55.200 --> 25:05.400]  годы. Шина, которой была смещена, шина адреса, шина данных, там просто чередовались данные, то есть
[25:05.400 --> 25:13.400]  сначала выборка адреса, потом шина данных. Разгонялась эта шина до 533 мегабайт в секунду. Почему
[25:13.400 --> 25:20.680]  шина PCI до сих пор актуальна? Потому что с программной точки зрения шина PCI express, она мало чем
[25:20.680 --> 25:28.200]  отличается от PCI и от AGP. При этом у вас могли быть на системной плате несколько разъемов, которые
[25:28.200 --> 25:35.360]  находятся рядом, и они все были припаяны к одной и той же шине, то есть на одних контактах было
[25:35.360 --> 25:44.360]  сразу несколько разъемов. И устройства могли взаимодействовать как между собой, так и с
[25:44.360 --> 25:51.720]  центральным процессором. Для того, чтобы не было никаких конфликтов, всегда должно быть устройство
[25:51.720 --> 26:00.080]  под названием орбитр шины. Обычно эта роль выполнялась чипсетом на системной плате. И для того, чтобы
[26:00.080 --> 26:07.760]  уменьшить нагрузку на шину, для видеокарт был разработан специальный порт AGP, который на самом
[26:07.760 --> 26:13.080]  деле является тем же самым PCI, но только с отдельным выделенным каналом для ускорбка процессора и
[26:13.080 --> 26:24.520]  памяти. Вот что доступ к памяти, что шины PCI и AGP являются параллельными шинами, то есть они
[26:24.520 --> 26:33.040]  позволяют за один такт передавать сразу несколько бит информации. С одной стороны, это очень такое
[26:33.040 --> 26:38.880]  разумное решение, то есть у вас есть несколько контактов, и чем контактов больше, тем больше
[26:38.880 --> 26:44.720]  данных вы можете в секунду передавать. Но в то же время есть и обычные физические недостатки,
[26:44.720 --> 26:51.600]  связанные с тем, что у вас проводников много. Во-первых, они оказывают влияние друг на друга,
[26:51.600 --> 26:58.800]  то есть слишком много проводников на большое расстояние, если делать, то они будут создавать
[26:58.800 --> 27:09.440]  помехи, и данные будут портиться, их придется заново отправлять. Другая проблема связана с тем,
[27:09.440 --> 27:15.000]  что параллельные интерфейсы нужно очень аккуратно разводить на системных платах,
[27:15.000 --> 27:20.520]  и учитывая их ограниченную площадь, это не всегда бывает возможным. Что будет,
[27:20.520 --> 27:26.800]  если шину, которая работает на высокой частоте, развести не очень аккуратно,
[27:26.800 --> 27:32.640]  то есть делать все проводники не рядом идущими друг с другом, а раскидать так,
[27:32.640 --> 27:40.800]  как получилось развести. У вас может быть так, что некоторый старший бит имеет очень небольшое
[27:40.800 --> 27:46.400]  расстояние между энкросхемами, а какой-нибудь младший бит, наоборот, может иметь очень длинные
[27:46.400 --> 27:52.400]  расстояния. И здесь уже на высоких частотах будут проявляться такие эффекты, как скорость,
[27:52.400 --> 28:00.120]  скорость распространения сигнала. Какая у нас самая большая скорость возможная в мире? Скорость
[28:00.120 --> 28:04.480]  света. Но скорость света это идеальная недостижимая скорость. На самом деле,
[28:04.480 --> 28:13.720]  скорость распространения токов проводника, она не сильно больше половины от скорости
[28:13.720 --> 28:21.600]  света, и когда речь идет про частоты в сотни мегагерц, здесь плюс-минус несколько сантиметров
[28:21.600 --> 28:32.800]  уже могут существенно сказываться, поскольку если у вас данные приходят не так, как у вас с разной
[28:32.800 --> 28:40.920]  скоростью, то у вас может быть один тик по частоте синхронизации, по каналу синхронизации. В это
[28:40.920 --> 28:49.160]  время вы прочитаете один бит, который был отправлен раньше, и какой-то бит, который относился
[28:49.160 --> 28:56.640]  вообще к предыдущему байту, был отправлен раньше, но он еще не дошел. Поэтому параллельные шины,
[28:56.640 --> 29:06.080]  они не были распространены, точнее сейчас они не очень распространены, там где у вас есть какие-то
[29:06.080 --> 29:11.800]  гибкие провода, то есть если вы вскроете системный блок, то маловероятно вы найдете какие-нибудь широкие
[29:11.800 --> 29:18.000]  шины, хотя в старых компьютерах конца 90-х годов такое встречалось, но тогда частоты были сильно
[29:18.000 --> 29:28.560]  меньше. Сейчас происходит постепенный отказ от использования параллельных шин в пользу
[29:28.560 --> 29:34.200]  последовательных. По названию тут уже понятно, что параллельная шина, когда вы параллельно
[29:34.200 --> 29:39.640]  передаете сразу несколько бит, и чем шире шина, то есть чем больше бита одновременно вы передаете,
[29:39.640 --> 29:46.280]  тем больше данных, с большей скоростью вы можете передавать. Последовательные интерфейсы как раз
[29:46.280 --> 29:53.840]  наоборот передают не так много данных, но зато делают это с очень большой частотой. Что здесь обычно
[29:53.840 --> 30:01.680]  требуется для реализации кодоконтроллера шины? Обязательно требуется буферизация, то есть если вы
[30:01.680 --> 30:10.560]  хотите передать один байт информации, используя только один проводник, то вам нужно за восемь
[30:10.560 --> 30:17.000]  тактов отправить эти восемь байт, а принимающая сторона, прежде чем прочитать этот байт, должна
[30:17.000 --> 30:24.680]  все эти биты сложить в какой-то буфер и дальше уже передать по параллельной шине к какому-то
[30:24.680 --> 30:33.640]  устройству, с которым она работает. И вот современная реализация шины PCI, которая называется PCI express,
[30:33.640 --> 30:41.640]  которая использует ту же самую логическую организацию, то есть это тоже интерфейс, как PCI,
[30:41.640 --> 30:48.120]  который использует передачу сообщений между разными устройствами, но принципиальное отличие
[30:48.120 --> 30:55.120]  от классической PCI в том, что он сделан как последовательная шина, но работающая с высокой
[30:55.120 --> 31:01.960]  частотой. Причем в зависимости от того, насколько требовательное ваше устройство к скорости
[31:01.960 --> 31:09.720]  передачи данных, оно может использовать не все, только часть из каналов передачи данных. Каждый канал
[31:09.720 --> 31:16.240]  передачи данных это четыре контакта, два контакта в одну сторону и два контакта в другую. Почему два
[31:16.240 --> 31:26.520]  контакта? Потому что при последовательной передаче данных для избежания возможных, воздействия
[31:26.520 --> 31:33.560]  каких-то возможных помех, используется подход под названием дифференциальная пара. В чем идея
[31:33.560 --> 31:40.320]  дифференциальной пары переводников? Допустим, вам нужно передать данные даже на какое-то
[31:40.320 --> 31:49.080]  большое расстояние, и где-то посередине к вам прилетает какая-то помеха. Для того, чтобы эту
[31:49.080 --> 31:54.520]  помеху устранить, есть простая идея, которая заключается в том, что вы передаете один и тот же
[31:54.520 --> 32:02.160]  сигнал по двум независимым каналам связи, но по второму проводнику вы передаете его инвертированно,
[32:02.160 --> 32:07.840]  и эти проводники идут рядом. Если прилетает помеха, то она затрагивает обычно сразу два
[32:07.840 --> 32:13.960]  проводника, и помеха набывает в сторону либо повышения напряжения, либо понижения, и она
[32:13.960 --> 32:20.160]  одновременно воздействует как на прямой сигнал, так на инвертированный. Приемник, соответственно,
[32:20.160 --> 32:31.400]  берет сумму с отрицанием этих двух сигналов, и в том случае, если вы и на положительный проводник,
[32:31.400 --> 32:37.000]  и на отрицательный, получили одну и ту же помеху, то изменения будут одинаковые, и они просто
[32:37.000 --> 32:42.320]  компенсируют друг друга уже на стадии суммы. Вот это называется дифференциальная пара, и за счет
[32:42.320 --> 32:49.880]  использования дифференциальной пары удается очень существенно поднять тактовые частоты на
[32:49.880 --> 32:57.080]  проводниках, в том числе на достаточно большие расстояния. Например, HDMI-провод, USB-провода,
[32:57.080 --> 33:03.080]  они все работают на очень высоких частотах, и тем не менее, несмотря на то, что это обычный провод
[33:03.080 --> 33:08.880]  с прорезиненной оплеткой, ну хорошо, там есть еще экранирование, но не самый тяжелый провод,
[33:08.880 --> 33:17.480]  достаточно гибкий, данные передаются без помех. Так вот, внутри PCI-Express у вас может быть несколько
[33:17.480 --> 33:24.400]  таких вот пар, да еще и в каждую сторону, то есть x1 это 4 проводника, x2 это, соответственно, в два
[33:24.400 --> 33:35.200]  раза больше. Видеокарты обычно используют самые тяжелые варианты PCI-Express, какие-нибудь простые
[33:35.200 --> 33:42.480]  устройства типа звуковых карт, ну и даже SATA-контроллер, если он у вас внешний, то все
[33:42.480 --> 33:50.520]  равно больше, чем x4, обычно редко используют. Ну и еще одним отличием шины PCI-Express от обычной
[33:50.520 --> 33:57.080]  шины PCI-Express является то, что здесь используется топология звезда, а не последовательное навешивание
[33:57.080 --> 34:04.720]  нескольких устройств на одни и те же шины, то есть есть некоторый центральный свитч, который связан
[34:04.720 --> 34:11.360]  уже с процессором, и дальше к этому свитчу подключаются разные PCI-устройства. Ну и в некоторых
[34:11.360 --> 34:17.120]  процессорах может быть реализация контроллера PCI-Express, то есть как раз этого самого центрального
[34:17.120 --> 34:25.200]  свитча. И большинство устройств, которые у вас расправлены на материнской плате, особенно тяжелых
[34:25.200 --> 34:34.080]  устройств, ну с точки зрения передачи данных, это как правило PCI-устройства, и посмотреть их полный
[34:34.080 --> 34:42.160]  список можно с помощью команды lspci. Что есть у каждого устройства? У него есть некоторый порядковый
[34:42.160 --> 34:51.080]  номер, ну и PCI-устройство при подключении сообщает некую информацию о себе, которую можно выяснить,
[34:51.080 --> 35:02.000]  в том числе через команду lspci. Типовые PCI-устройства, ну кроме разных мостов на старые интерфейсы PCI
[35:02.000 --> 35:12.920]  и ESA, это SATA-контроллер, мультимедиа-контроллер, VGA-контроллер, это видеокарта, ну виртуалки,
[35:12.920 --> 35:18.880]  напоминается, как что-то виртиво GPU, у вас может быть либо Intel, либо Nvidia, либо еще что-нибудь,
[35:19.160 --> 35:26.240]  ну и USB-контроллеры. Все это достаточно быстрые устройства, с ними необходимо очень быстро
[35:26.240 --> 35:33.680]  обмениваться данными. Да, ну и все PCI-устройства поддерживают механизм прямого доступа к памяти,
[35:33.680 --> 35:39.960]  то есть взаимодействие с устройствами PCI-экспресс не производится с помощью команд in-out,
[35:39.960 --> 35:53.400]  все происходит достаточно быстро. Так, ну и кроме высокоскоростных шин PCI-экспресс бывают
[35:53.400 --> 36:00.680]  низкоскоростные шины. Самая простая из них называется I2C. Что это за шина такая? Это шина,
[36:00.680 --> 36:07.560]  которая использует помимо питания всего лишь два провода. Один провод предназначен для передачи
[36:07.560 --> 36:16.560]  тактового, информации тактового генератора, то есть там примерно с одинаковой частотой идут сигналы
[36:16.560 --> 36:23.640]  положительные либо нулевые. И второй канал, это канал для передачи данных, собственно,
[36:23.640 --> 36:31.100]  по которому передаются биты, относящиеся к сообщениям. И по времени сигнал тактовый и сигнал,
[36:31.100 --> 36:38.940]  который передается по проводу данных, они должны совпадать. Если в момент положительного сигнала
[36:38.940 --> 36:45.020]  на тактовом проводе у нас нулик на данных, то это значит логический ноль, если единичка,
[36:45.020 --> 36:50.540]  то логическая единичка. Переключение между ними это по сигналу с тактового генератора. В чем
[36:50.540 --> 36:55.460]  особенность шины I2C? Она предназначена для того, чтобы работать на небольших тактовых частотах,
[36:55.460 --> 37:02.180]  но здесь не требуется какой-то точной синхронизации разных устройств. Поскольку синхронизация,
[37:02.180 --> 37:07.660]  она производится уже самой шиной, и устройства могут в принципе даже работать с разной скоростью.
[37:07.660 --> 37:18.140]  В этом случае выбирается просто скорость, с которой могут работать все устройства. На одну шину
[37:18.140 --> 37:24.220]  I2C может быть навешано достаточно много устройств, и взаимодействие осуществляется с помощью
[37:24.220 --> 37:32.660]  сообщений, и у каждого устройства есть 7-битный в редких случаях расширенный 10-битный идентификатор,
[37:32.660 --> 37:40.780]  которым можно обращаться. Что у нас реализуется через устройство I2C? В виртуальной машине я
[37:40.780 --> 37:55.420]  не могу ничего вам показать, потому что устройств I2C в виртуалке просто нет. Если вы запустите
[37:55.420 --> 38:02.980]  утилиту I2C Detect на ноутбуке, то вы, например, можете, я имею в виду не в виртуалке, а на настоящем ноутбуке,
[38:02.980 --> 38:10.900]  то сможете, например, увидеть устройства, такие как регулятор громкости, регулятор яркости экрана,
[38:10.900 --> 38:15.820]  то есть те устройства, которые не требуют большой объем передачи данных, но при этом требуют
[38:15.820 --> 38:24.540]  максимальной простоты для подключения. На телефонах эта шина может использоваться для подключения GPS,
[38:24.540 --> 38:33.660]  гироскопа, компаса, всяких датчиков освещения, опять же, всей периферии, которая не слишком
[38:33.660 --> 38:52.980]  требовательна к скорости. Ну и я отдельно открыл вкладку с Raspberry Pi. Я все время влагонюсь под
[38:52.980 --> 38:57.180]  рутом, потому что взаимодействие с устройствами, в том числе получение достоверной информации,
[38:57.180 --> 39:05.660]  оно недоступно часто обычному пользователю. Вот у Raspberry Pi есть встроенный I2C контроллер.
[39:05.660 --> 39:15.420]  Что такое плата Raspberry Pi, представляете? Там есть еще гребенка из сорока контактов. Вот два контакта
[39:15.420 --> 39:22.780]  из них, это как раз шина I2C, на которой вы можете навешивать всякое внешнее оборудование. В обычных
[39:22.780 --> 39:27.260]  десктопных либо сервенных системах эта шина может использоваться, например, для контроля за
[39:27.260 --> 39:32.500]  скоростью вращения вентиляторов, ну и температурой процессора, то есть всякие устройства для
[39:32.500 --> 39:40.660]  мониторинга. И некоторой разновидностью шины I2C, немного упрощенной, является интерфейс под
[39:40.660 --> 39:50.220]  названием SPI, который требует уже для взаимодействия минимум три провода. Если у вас только два устройства,
[39:50.220 --> 39:59.180]  либо больше четырех проводов, если у вас несколько устройств, вот на шине I2C вы все навешиваете
[39:59.180 --> 40:05.780]  всего лишь на два провода, и по ID отдельные устройства понимают, к кому из них обращается
[40:05.780 --> 40:14.780]  хост-контроллер. В случае с SPI у вас может быть взаимодействие только между двумя устройствами,
[40:14.780 --> 40:23.500]  и кроме того вы можете передавать данные в две стороны. Кроме шины для передачи тактовой информации,
[40:23.500 --> 40:30.220]  есть шина для передачи данных от мастера к подчиненному, мастер слейф, терминология,
[40:30.220 --> 40:39.860]  которая скоро будет запрещена, но пока еще нет. Ну и в обратную сторону, это два независимых канала
[40:39.860 --> 40:47.580]  для передачи данных. И плюс отдельный канал под названием Chip Select, либо Source Select,
[40:47.580 --> 40:53.660]  Sink Select, который предназначен уже для выбора отдельного устройства, если вы навешали несколько
[40:53.660 --> 40:59.940]  микросхем, например, подключили к одному микроконтроллеру. Вот шина SPI обычно используется в микроконтроллерах,
[40:59.940 --> 41:06.500]  потому что ее реализация еще более простая, чем I2C, здесь не требуется поддерживать какие-то
[41:06.500 --> 41:13.980]  идентификаторы. Обычно по SPI цепляются, например, контроллер жидко-кристаллических экранов,
[41:13.980 --> 41:22.980]  какие-нибудь датчики температуры, датчики управления двигателями, там скорость вращения,
[41:22.980 --> 41:29.620]  ну и так далее. То есть если вы чего-то клепаете на Arduino, то наверняка с этой шиной сталкивается.
[41:29.620 --> 41:35.020]  И кроме того, помните, когда я вам показывал гравитапу, которая светилась разными огоньками,
[41:35.020 --> 41:42.380]  я же ее предварительно как-то прошивал, то есть программу с компьютера закидывал на микроконтроллер,
[41:42.380 --> 41:50.420]  и вот взаимодействие было опять же по шине SPI. То есть для контроллеров на базе AVR,
[41:50.420 --> 41:58.180]  там если вы зажимаете при включенном состоянии контакт Reset, то некоторые контакты превращаются
[41:58.180 --> 42:06.180]  в SPI, и вы можете через них заливать туда разные прошивки. Так, ну и более универсальным,
[42:06.180 --> 42:15.660]  некоторым промышленным стандартом низкоскоростных шин для передачи данных последовательных,
[42:15.660 --> 42:21.620]  является интерфейс UART. Причем UART это именно логический интерфейс, а не физический,
[42:21.620 --> 42:32.780]  который описывает, как можно передавать данные. Он передает данные последовательно, причем в
[42:32.780 --> 42:39.540]  разных форматах вы можете, например, помимо самих данных передавать еще битчетности, и кроме того
[42:39.540 --> 42:46.660]  устройства, в отличие от шины SPI или шины I2C, обязаны сами поддерживать некоторую частоту
[42:46.660 --> 42:59.700]  по договоренности. Здесь частоты бывают от 300 бит в секунду. Есть такой термин по
[42:59.700 --> 43:08.380]  названиям BOD, это дословный перевод с английского BOD, количество бит полезной информации в секунду,
[43:08.380 --> 43:15.060]  то есть количество бит, за исключением стартовых, стоповых и контрольного, и характерные скорости
[43:15.060 --> 43:22.420]  работы. Это от 300 бит в секунду в самых простых случаях, до того, что использовалось в последних
[43:22.420 --> 43:30.700]  модемах, перед тем как... Да, штуковина, которая втыкается в телефонную линию, пищит противно, да.
[43:30.700 --> 43:39.860]  Кто помнит, из тех, кто застал модем, кто помнит, с какой скоростью они работали?
[43:39.860 --> 43:47.460]  56 тысяч, это был максимум достижимый на наших качественных телефонных линиях. На самом деле,
[43:47.460 --> 43:53.660]  у меня, например, 56 тысяч никогда не удалось выжимать, обычно там 48 тысяч в секунду. Вообще,
[43:53.660 --> 44:01.660]  протокол позволяет до, с помню, 112 тысяч BOD вытягивать. То есть, данные, в принципе,
[44:01.660 --> 44:08.740]  можно передавать относительно быстро, но не так быстро, как это можно делать по USB. В чем
[44:08.740 --> 44:15.660]  прелесть протокола UART? В том, что он стандартизован, есть куча инструментов для работы с этим
[44:15.660 --> 44:22.260]  протоколом. Если у вас есть последовательный порт, как в современных компьютерах, в которых нет
[44:22.260 --> 44:28.940]  COM-порта, можно обеспечить себе подключение через последовательный UART-порт. Есть куча всяких
[44:28.940 --> 44:37.380]  устройств переходников с USB на UART, причем бывают как переходники на 5-вольтовую логику, которая
[44:37.380 --> 44:43.540]  используется для подключения Arduino, взаимодействия с Raspberry Pi, так и классические интерфейсы,
[44:43.540 --> 44:53.460]  которые работают на напряжении до 15-ти вольт, обычные RS-232, как в старых компьютерах. И очень
[44:53.460 --> 45:03.980]  много промышленного оборудования оснащено как раз интерфейсом RS-232 или B432, которым вы можете
[45:03.980 --> 45:13.260]  подключить через переходник обычный USB, ну и дальше взаимодействовать как с обычным символьным файлом.
[45:13.260 --> 45:22.940]  Вот устройство DFTTI чего-нибудь, TTI S, TTI USB, это как раз все те устройства, которые связаны
[45:22.940 --> 45:28.140]  с отдельными каналами, которыми вы подключаете эти устройства. Можете передавать туда обычную
[45:28.140 --> 45:37.260]  символную информацию. Ну и завершаем наш сегодняшний рассказ и вообще весь блок про железяки
[45:37.260 --> 45:46.900]  современными протоколами передачи данных. Это последовательная шина USB, название USB это
[45:46.900 --> 45:53.780]  Universal Serial Bus, универсальная шина, которая может подключать все что угодно. Есть куча разных
[45:53.780 --> 46:01.100]  разновидностей разъемов, но вот если мы не затрагиваем USB SuperSpeed, то есть USB третьего
[46:01.100 --> 46:10.380]  стандарта, то классическая шина это четыре контакта, два из которых это питание, земля и 5 вольт и одна
[46:10.380 --> 46:18.420]  дифференциальная пара. По такой шине можно передавать данные до 400 мегабайт в секунду, то есть
[46:18.420 --> 46:27.140]  достаточно приличная скорость. Причем канал передачи данных здесь полудубликсный, то есть вы
[46:27.140 --> 46:32.740]  одновременно можете либо читать данные, либо передавать, либо чередовать. Вот D+, D- в этих
[46:32.740 --> 46:40.780]  контактах означает, что это просто разные куски одной и той же дифференциальной пары. Ну и что у
[46:40.780 --> 46:48.780]  нас есть из USB устройств на произвольно взятом компьютере. Вообще у каждого USB устройства есть
[46:48.780 --> 46:57.060]  уникальный vendor ID и device ID. Как их получить? Их надо купить. Просто так вы, конечно, можете
[46:57.060 --> 47:04.180]  их использовать, но это будет что-то около кустарное. У каждого устройства есть некоторый стандартный
[47:04.180 --> 47:10.460]  класс, он определяется одним байтом. Для чего нужно задавать класс устройства? На случай, если
[47:10.460 --> 47:16.340]  у вас нет какого-то стандартного, нет какого-то специфичного драйвера устройства, в терминологии
[47:16.340 --> 47:23.580]  Linux это называется модуль ядра, но ваше устройство ведет себя по какому-то стандартному протоколу
[47:23.580 --> 47:29.580]  взаимодействия. Например, клавиатура, флешка. Вы же под каждую клавиатуру, каждую флешку не
[47:29.580 --> 47:34.260]  устанавливаете отдельный драйвер, просто втыкаете и оно просто работает. Потому что есть некоторый
[47:34.260 --> 47:38.620]  унифицированный класс устройств, вот он как раз определяется одним байтиком device class. И
[47:39.260 --> 47:46.500]  кроме того, каждое устройство может иметь свой индикальный идентификатор, который стоит из 4 байт,
[47:46.500 --> 47:52.260]  это vendor ID plus device ID, которые продаются USB консорциумом, то есть для того, чтобы назначить
[47:52.260 --> 48:04.420]  себе легальный vendor ID, его нужно купить. Ну и посмотреть это все можно в выводе команд ls usb.
[48:04.420 --> 48:11.940]  Вот по умолчанию, да опять же у меня виртуалки там не очень наглядно. Есть несколько устройств,
[48:11.940 --> 48:22.740]  вот числа, первое означает как раз vendor ID, второе device ID, кроме как виртуальной мыши параллель,
[48:22.740 --> 48:28.300]  у меня ничего нет. А для чего нужны уникальные идентификаторы USB устройств? Для того,
[48:28.300 --> 48:33.980]  что воткнув любое USB устройство в компьютер, можно было понять, а с чем вы работаете и
[48:33.980 --> 48:44.660]  вручную это не настраивать. То есть, когда втыкаете какой-нибудь USB устройство, то ядро ищет у себя в
[48:44.660 --> 48:53.100]  таблице по известному vendor ID и device ID, а что это за устройство, если оно находится, то загружается
[48:53.100 --> 48:59.460]  соответствующий модуль и используется взаимодействие с помощью определенного драйвера. Если не находится,
[48:59.460 --> 49:11.460]  то смотрится уже класс устройства. Вот USB с опцией Minus T отображает чуть более подробно информацию о том,
[49:11.460 --> 49:18.860]  что это за устройство и какие драйверы они используют, к нему для ядра, а также к какому классу они относятся,
[49:18.860 --> 49:31.300]  используется некоторый generic class. Ну и современная вариация протокола USB, которая USB третьего
[49:31.300 --> 49:39.940]  стандарта, подразумевает, что USB 3 это те разъемы, которые синего цвета. В чем их особенность?
[49:39.940 --> 49:45.900]  Там на самом деле не четыре контакта, а девять. То есть, вы можете воткнуть обычный четырехконтактный
[49:45.900 --> 49:54.460]  разъем и получить обычный USB порт. Если вы такаете девятиконтактный разъем в порт USB третьей версии,
[49:54.460 --> 50:00.180]  то вы еще получаете две дополнительные дифференциальные пары. Причем, каждый этих
[50:00.180 --> 50:04.780]  дифференциальных пар работает только в одну сторону. Одна для передачи данных, другая для приема.
[50:04.780 --> 50:11.500]  И дальше, какие возможные варианты? Вы можете использовать эти дополнительные дифференциальные
[50:11.500 --> 50:19.460]  пары просто для ускорения скорости передачи данных по USB. Еще есть такой разъем как USB Type-C.
[50:19.460 --> 50:26.820]  В чем его особенность? Вы его можете втыкать в разные стороны. За счет чего это достигается?
[50:26.820 --> 50:35.540]  Тут симметрично есть два контактика под названием CC1 и CC2. Это configuration сигналы,
[50:35.540 --> 50:42.500]  которые определяют, какой стороной вы воткнули этот разъем. Дальше все остальные контакты,
[50:42.500 --> 50:51.740]  они примерно симметричные и не сильно влияют, как вы воткнете. Кроме того, помимо одного основного
[50:51.740 --> 51:02.780]  порта низкоскоростного шины контактов D+, D-, тут есть еще двух дополнительных 2A3 и
[51:02.780 --> 51:10.820]  A10 и A11, это как раз две дополнительные дифф-пары. Есть еще дополнительная линия,
[51:10.820 --> 51:18.620]  под названием Sideband, которая может использоваться для альтернативного подключения, для альтернативного
[51:18.620 --> 51:24.620]  использования того же самого разъема с какими-то дополнительными портами. Кроме того, если вам не
[51:24.620 --> 51:31.700]  нужны высокоскоростные дифф-пары, то они тоже могут использоваться для дополнительных протокол.
[51:31.700 --> 51:40.260]  Какие возможные сценарии использования разъема Type-C? Во-первых, я могу взять и воткнуть блок
[51:40.260 --> 51:50.180]  питания в обычный Type-C. Этот блок питания выдает 20 вольт и 65 ватт, то есть там не только напряжение
[51:50.180 --> 51:57.500]  в 4 раза выше, но и больше ток, который он выдает. За счет чего это достигается? За счет того,
[51:57.500 --> 52:05.500]  что дополнительные дифф-пары используются просто как контакты для дополнительной подачи тока.
[52:05.500 --> 52:13.100]  Это один из сценарий в использовании. Другой сценарий использования это использование разъема Type-C,
[52:13.100 --> 52:20.860]  чтобы он мог помимо USB передавать видео-данные по протоколу DisplayPort либо HDMI. Ну вот,
[52:20.860 --> 52:25.260]  собственно, то, что вы увидите, втыкается в обычный, точнее не совсем обычный Type-C.
[52:25.260 --> 52:33.700]  Простой переходник. Дальше с этого переходника видео идет на трансляцию и на проектор. Вот здесь
[52:33.700 --> 52:38.220]  есть некоторые маленькие замечания, что не в каждой Type-C вы можете воткнуть переходник
[52:38.220 --> 52:46.820]  на HDMI. Почему? Потому что здесь подразумевается, что один разъем может использовать как USB-контроллер,
[52:46.820 --> 52:55.340]  так и видеокарта. Если у вас просто в ноутбуке или вы купили отдельный какой-то переходник с USB
[52:55.340 --> 53:02.060]  на Type-C, то у вас будет обычная реализация USB. Это в оси не будет подразумевать, что вы можете
[53:02.060 --> 53:07.340]  использовать какие-то контакты для передачи HDMI данных. Ну и в телефонах, кроме того, есть еще
[53:07.340 --> 53:15.500]  возможность воткнуть в Type-C обычные аналоговые наушники и микрофон. За счет чего это достигается?
[53:15.500 --> 53:25.340]  За счет того, что стандартные USB-каналы, которые D+, D- используются просто под вывод звука.
[53:25.340 --> 53:40.780]  Одна из шин sideband используется для подключения микрофона. Ну и поэтому в Type-C можно воткнуть
[53:40.780 --> 53:44.220]  какую-нибудь гарнитурку, и она тоже будет работать без всякой цифровой схемы.
[53:44.220 --> 53:53.620]  Так, ну на этом про железяки все. Вы видите здесь заяца. Это означает, что лекция закончилась,
[53:53.620 --> 54:00.220]  а еще заяц повесился. И значит, что больше вы его уже не увидите. И первый модуль у нас закончился.
[54:00.220 --> 54:06.660]  В связи с этим некоторые организационные объявления. Во-первых, я в общем чате под
[54:06.660 --> 54:12.860]  названием важное объявление закинул разболовку. Она может вам показаться несколько жесткой,
[54:12.860 --> 54:18.500]  но жесткой для тех, кто претендует на оценку от L10, потому что это максимально возможный балл.
[54:18.500 --> 54:24.020]  Ну опять же максимально возможный балл можно достичь, даже если сдать не все на максимум.
[54:24.020 --> 54:33.660]  Оценки 8 и 9, они вполне достижены. Это первый момент. Второй момент. У вас ожидается контрольная
[54:33.660 --> 54:39.140]  по теоретическому материалу. Как подготовится контрольная по теоретическому материалу?
[54:39.140 --> 54:46.100]  Посмотреть все лекции, будет рассказываться материал, то есть в контроле будет спрашиваться знание
[54:46.100 --> 54:51.300]  материала из лекций, плюс немножко соображалки. Немножко соображалки знают, что вы хотя бы
[54:51.300 --> 54:59.220]  что-то посчитать на бумажке тоже сможете. Речислительные задачи тоже будут. И самое интересное,
[54:59.220 --> 55:07.380]  мы живем с вами в очень странное время, когда мы заранее не знаем, где мы будем через неделю
[55:07.380 --> 55:13.460]  находиться. Либо в этой аудитории вы будете писать контрольные бумажки, либо может случиться так,
[55:13.460 --> 55:21.700]  что нас просто закроют, и в этом случае придется контрольным все равно писать, но только делать это
[55:21.700 --> 55:25.860]  в онлайн формате. Так что заранее, к сожалению, сейчас пока не могу это предсказать, в каком формате
[55:25.860 --> 55:31.820]  будет. То есть я надеюсь все-таки, что нас через неделю пока еще не закроют, а вот зато нас
[55:31.820 --> 55:39.100]  гарантированно закроют с 30-го числа. Что это означает? Означает, что учиться все равно вы будете,
[55:39.100 --> 55:47.820]  но просто будет дополнительное время для дистанционных сдач домашек, но материала не будет.
[55:47.820 --> 55:54.420]  То есть второй модуль мы начинаем после того, как закончится мини-карантин, вроде обещают
[55:54.420 --> 56:03.100]  7 ноября, что все закончится. Пока никого официального приказа не было, но если царь батюшск сказал,
[56:03.100 --> 56:15.220]  кто же ему будет противоречить? Наверное, никто не решится. Ладно, есть ли у вас вопросы по
[56:15.220 --> 56:25.420]  содержанию всего модуля, например? Вопросы перед контрольной? В прошлом году с контрольными было
[56:25.420 --> 56:32.860]  проще, они писали раз в семестр. Может, конечно, это не проще было для них, потому что больше
[56:32.860 --> 56:38.500]  стрессовой ситуации за каждое семестр. Скорее спросите, как это было в позапрошлом году и в
[56:39.460 --> 56:52.060]  когда контрольная была два раза в семестр. Ничего, нормально писали. У вас будет дополнительное время
[56:52.060 --> 57:06.220]  до сдать все это, в то время, пока у нас такие странные недоконикуи. До контроля не обязательно,
[57:06.220 --> 57:11.260]  то есть итоги все равно будут подводиться позже. То есть контрольная и решение контеста,
[57:11.260 --> 57:22.140]  это две независимые части одной оценки. Ну ладно, если вопросов нет, тогда вы можете быть свободны.
