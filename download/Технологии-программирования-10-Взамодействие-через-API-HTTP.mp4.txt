[00:00.000 --> 00:10.880]  Всем доброго дня, мы с вами продолжаем изучать наш курс, и сегодня у нас вторая часть ипопеи
[00:10.880 --> 00:16.160]  «Просите вы взаимодействие». Сегодня мы с вами пойдем на уровень чуть выше, да, и наконец-таки
[00:16.160 --> 00:23.120]  рассмотрим, как работают разные HTTP-серверы и вообще, как устроены большие системы между собой,
[00:23.120 --> 00:30.280]  как они между собой взаимосвязаны. Я не знаю, честно, у кого-то из вас уже был курс по питону,
[00:30.280 --> 00:41.200]  у кого-то он сейчас идет. Уговорите. Да, хорошо. Рассматривали ли вы там Flask или нет?
[00:41.200 --> 01:00.640]  Видимо нет. Flask. Библиотека такая. Окей, ну ладно, если что, тогда я просто сегодня тоже покажу это
[01:00.640 --> 01:06.520]  все дело, чтобы у вас было некоторое знакомство, потому что сегодня мы будем говорить как раз в том
[01:07.200 --> 01:13.160]  числе и про Application Programming Interface. Итак, давайте вот мы с вами остановимся, вспомним,
[01:13.160 --> 01:17.880]  что у нас было в прошлый раз. В прошлый раз мы с вами сказали, что у нас есть сетевой стэк,
[01:17.880 --> 01:25.560]  у нас есть какие-то примеры взаимодействия по всему стэку. Более того, мы с вами понимаем в
[01:25.560 --> 01:31.920]  случае того, что если мы находимся в одной сети, то в принципе мы с вами можем подключиться к
[01:31.920 --> 01:38.600]  одному компьютеру в той же самой сети. То есть это все происходит на уровне IP протокола. Дальше
[01:38.600 --> 01:43.320]  мы можем настроить протокол на транспортном уровне. Это у нас либо TCP, либо UDP. Мы с вами
[01:43.320 --> 01:51.760]  смотрели Wireshark. И дальше нам нужно идти в... Мы начали рассматривать прикладной уровень,
[01:51.760 --> 01:57.920]  и кажется мы с вами в прошлый раз разобрали то, что когда мы с вами должны отправлять запросы по
[01:57.920 --> 02:03.160]  HTTP, то нам нужно отправлять заголовок под названием host. Я, кажется, показывал пример,
[02:03.160 --> 02:09.400]  что подменив заголовок host мы с вами можем из одного сервера по одному и тому же IP адресу
[02:09.400 --> 02:16.920]  достучаться до разных приложений. И теперь давайте поговорим про то, каким образом процессы
[02:16.920 --> 02:23.080]  могут между собой взаимодействовать. У нас есть два процесса. Мы с вами так или иначе поняли,
[02:23.080 --> 02:28.680]  что они между собой могут общаться через сокеты. То есть это если у нас есть сетевые взаимодействия,
[02:28.680 --> 02:33.080]  мы ставим сокет по одной стороны, сокет с другой стороны, и они начинают друг друга связываться.
[02:33.080 --> 02:39.440]  Только маршрут, который проходит между этими сокетами, он достаточно длинный. То есть он может
[02:39.440 --> 02:44.720]  проходить в принципе в другую точку земли. Но на самом деле мы можем попробовать взаимодействовать
[02:44.720 --> 02:51.400]  с процессами немножко по-другому. И давайте как раз попробуем рассмотреть эти способы.
[02:51.400 --> 02:58.920]  Первый способ взаимодействия через файл. У нас есть какой-то процесс A, у нас с вами есть процесс B,
[02:58.920 --> 03:05.800]  и каким образом они могут попробовать взаимодействовать между собой через файл. Объект A допустим.
[03:05.800 --> 03:18.360]  Сейчас буду рисовать. К сожалению у меня немного рука повреждена, поэтому возможно буду стирать
[03:18.360 --> 03:27.360]  все немедленно. Давайте я буду стирать все-таки левой рукой. Итак смотрите, у нас есть с вами
[03:27.360 --> 03:42.440]  процесс A и есть процесс B. Нам нужно чтобы процесс A передавал какую-то информацию процессу B через
[03:42.440 --> 03:51.200]  файл. Значит каким образом это можно организовать? На самом деле можно сделать какую-то папку. Папку,
[03:51.200 --> 03:56.200]  которая называется взаимосвязь между сервисами. Ну и дальше смотреть на содержимое этой папки.
[03:56.200 --> 04:03.360]  Каким образом можно смотреть на содержимое папки? Мы просто смотрим, грубо говоря, создаем файлы типа
[04:03.360 --> 04:12.480]  slash 0, slash 1, slash 2, slash 3 и допустим способ общения между процессами. Откуда-куда этот
[04:12.480 --> 04:17.760]  процесс взаимодействия идет. То есть, грубо говоря, наш процесс начинает обмениваться сообщениями.
[04:17.760 --> 04:24.280]  То есть здесь мы говорим, что в нулевое сообщение A отправляет B, потом первое сообщение B отправляет A,
[04:24.280 --> 04:31.880]  ну и так далее. Собственно как каждый из процессов потом может понять, что ему пришло сообщение?
[04:31.880 --> 04:44.560]  У кого есть мысли? Да, ну посмотрите на последний ID, который прилетел и сказать, что это за, что это за
[04:44.560 --> 04:50.000]  процесс. Но правда здесь нет механизма нотификации определенного процесса, но в принципе это можно
[04:50.000 --> 04:56.320]  позволить средствами операционной системы. То есть Unix-like операционные системы имеют как раз механизм,
[04:56.320 --> 05:01.840]  который позволит получить процесс от сеть на файл. Как вы думаете, в чем недостатки этого подхода?
[05:01.840 --> 05:12.220]  У него есть на самом деле один большой недостаток, что, во-первых, у нас только два процесса могут
[05:12.220 --> 05:16.960]  взаимодействовать между собой и если какой-то процесс A запустился допустим не один раз, а два
[05:16.960 --> 05:23.100]  раза, то все пойдет по одному месту. Потому что мы не можем обрабатывать это все в параллельном
[05:23.100 --> 05:29.540]  режиме. Вот, и если мы говорим про распределенные в хранилище, то есть про хранение более чем одного
[05:29.540 --> 05:37.780]  узла, на самом деле такая концепция поддерживается. Вот, и вот современные экосистемы, которые
[05:37.780 --> 05:42.020]  обеспечивают как раз координацию между большим количеством узлов, работают приблизительно под
[05:42.020 --> 05:49.260]  протоколом. Значит, я сейчас грузить этим не буду. Давайте я примеры просто скажу, кто по такому
[05:49.260 --> 05:55.300]  протоколу работает. По такому протоколу, во-первых, работает ZooKeeper, который осуществляет координацию
[05:55.300 --> 06:03.260]  между узлами в кластерах, которые обеспечивают хранение больших объемов данных. А вторая экосистема,
[06:03.260 --> 06:09.300]  а второй инструмент тоже достаточно популярный, это инструмент ETCD. Значит, он необходим для
[06:09.300 --> 06:14.300]  аркистрации контейнеризированными ресурсами. То есть вы на семинарах уже начали проходить
[06:14.300 --> 06:19.260]  докер, поэтому, наверное, вы понимаете, что контейнеризированные приложения зачастую те,
[06:19.260 --> 06:25.220]  которые запускаются в докер-контейнерах или в аналогичных им контейнерах. Вот, то есть они как
[06:25.220 --> 06:32.140]  раз общаются таким образом, только чуть более умным для того, чтобы обеспечить распределение более
[06:32.140 --> 06:39.420]  чем одного процесса. Значит, это первый способ. Он такой самый простой, но при этом у него есть
[06:39.420 --> 06:44.420]  недостатки, но, в принципе, его можно допилить, если мы будем использовать примитивы сихронизации.
[06:44.420 --> 06:50.180]  Значит, второй способ через API. Что такое API? Это Application Programming Interface. То есть мы с
[06:50.180 --> 06:56.260]  вами по факту должны придумать какой-то интерфейс, который позволит отправлять запросы по определенному
[06:56.260 --> 07:04.140]  адресу. И как раз один из примеров использования API это как раз поверх протокола HTTP. Они зачастую
[07:04.140 --> 07:09.300]  используются, но не только поверх протокола HTTP. Про это мы будем чуть дальше говорить. Значит,
[07:09.300 --> 07:15.780]  какие плюсы и минусы? Плюсы есть, возможно, взаимодействие по сети. Минусы все-таки нужно
[07:15.780 --> 07:22.420]  будет разрешать проблемы сихронизации тоже. Третий способ это у нас есть два процесса,
[07:22.420 --> 07:28.780]  и они общаются между собой через некоторую базу данных. То есть на самом деле база данных тоже
[07:28.780 --> 07:38.220]  между собой представляет сервер. Этот сервер достаточно большой по вместимости. И при
[07:38.220 --> 07:47.860]  помощи к нему обращаются при помощи специального языка. Обычно этот язык называется structured query
[07:47.860 --> 07:57.260]  language, он же SQL. И как раз когда мы обращаемся с вами при помощи SQL, мы можем отправлять некоторые
[07:57.260 --> 08:04.140]  запросы для того, чтобы получать какие-то результаты. Значит, опять же, тут нужно сказать,
[08:04.140 --> 08:11.300]  что SQL базы данных могут быть разного уровня. Это может быть файловая база данных. Допустим,
[08:11.300 --> 08:20.580]  к примеру, файловая база данных относится с SQLite. Потому что мы с вами загружаем информацию из
[08:20.580 --> 08:28.660]  файла. Есть серверные поставки, такие как MySQL, PostgreSQL, Oracle и так далее. И тогда как раз в чем
[08:28.660 --> 08:35.060]  есть проблема всех этих баз данных, то что их надо правильно настраивать. Если вы их неправильно
[08:35.060 --> 08:42.060]  настроите, то могут быть всякие разные проблемы. Если мы говорим про большие приложения, в этом
[08:42.060 --> 08:47.180]  есть определенная проблема. Возможно вы видели, что Ahcheck в некоторых моментах очень долго грузят.
[08:47.180 --> 08:52.820]  Не Ahcheck, по крайней мере GitLab. Он может действительно долго грузить. Это связано с тем,
[08:52.820 --> 09:01.740]  что баз данных не справляются с обработкой запросов. Вообще, по идее, про баз данных должен быть
[09:01.740 --> 09:12.460]  отдельный курс. Я не знаю, у кого когда он будет. В целом, это тоже важно понимать, что это способ
[09:12.460 --> 09:18.100]  взаимодействия процессов. Но фишка в том, что все вот эти вот способы взаимодействия пока что
[09:18.100 --> 09:23.140]  являются синхронными. Про это чуть позже расскажу, что нам нужно дождаться результатов наших запросов.
[09:23.140 --> 09:29.540]  То есть мы отправили, допустим, запрос на обновление данных. Нам нужно дождаться то, что наши запросы
[09:29.540 --> 09:33.540]  действительно исполнятся. То есть мы не можем делать дальнейших действий до тех пор, пока мы с
[09:33.540 --> 09:42.060]  вами не получим результат. И это все будет очень сильно тормозить. Наверное, вы видели,
[09:42.060 --> 09:47.940]  когда вы загружаете что-то на сайте, у вас бывает такое, что я гружу страницу, я гружу страницу,
[09:47.940 --> 09:53.900]  я гружу страницу. А на самом деле под капотом у вас происходит какой-то запрос, связанный с базой данных.
[09:53.900 --> 10:02.500]  Тоже могу пример показать, если он интересен. И последний способ, это на самом деле то,
[10:02.500 --> 10:09.740]  как устроены все нормальные системы данных, высоконагруженные системы. Все взаимодействия
[10:09.740 --> 10:15.460]  происходят зачастую через очередь сообщений. Значит, смотрите, тут нужно сразу сказать,
[10:15.460 --> 10:22.820]  что это не классическая структура данных вида очередь. Она имеет похожую суть, но немножко с
[10:22.820 --> 10:29.140]  некоторыми разными возможностями. То есть у нас по факту что может сделать? У нас процессор A может
[10:29.140 --> 10:34.980]  положить какое-то сообщение в очередь. Значит, что такое сообщение? Это какой-то запрос на выполнение
[10:34.980 --> 10:41.380]  каких-то запросов с какими-то данными. Дальше что у нас происходит? У нас есть какой-то, он
[10:41.380 --> 10:48.900]  отправляет его куда-то, непонятно куда. А дальше, значит, есть процессы, которые могут обработать
[10:48.900 --> 10:55.860]  этот запрос. То есть представьте себе, образно говоря, кейс, вы отправляете запрос через
[10:55.860 --> 11:07.620]  госуслуги какой-нибудь. У вас сразу выполняется? Ну или через какую-то другую систему? Или вы
[11:07.620 --> 11:15.980]  делаете заказ какой-нибудь в интернет-магазине? Что с ним происходит? Вам просто отправляется письмо,
[11:15.980 --> 11:23.380]  что ваш заказ был получен в системе. А дальше у вас в фоновом режиме начинают эти заказы
[11:23.380 --> 11:29.340]  обрабатывать. То есть, грубо говоря, первая обработка идет в фоновом режиме, и вся большая
[11:29.340 --> 11:39.260]  часть обработки как раз уходит в фоновый режим. Давайте, опять же, далеко не отходя, пример системы
[11:39.260 --> 11:44.420]  по отправке домашних заданий рассмотрим. Вы когда отправляете посылку, что с ней происходит? У вас
[11:44.420 --> 11:52.420]  браузер висит или нет? Нет, браузер не висит, все отправляется, все происходит в фоне. После того,
[11:52.420 --> 11:57.380]  как задача обработалась, вам может прийти либо уведомление на почту, либо еще куда-нибудь.
[11:57.380 --> 12:03.460]  То есть, либо на сам сайт. То есть, вы не видите того, что происходит под капотом. И тем самым вы
[12:03.460 --> 12:10.180]  отвязываете как раз ваше приложение от контекста исполнения. То есть, это все находится в отдельно
[12:10.180 --> 12:15.340]  фоновом режиме. И на самом деле, когда вы заходите в любую большую экосистему, будь-таки Янекс,
[12:15.340 --> 12:20.020]  Гугл, Лазон и так далее, на самом деле там огромное количество очередей под капотом. То есть,
[12:20.060 --> 12:26.220]  у нас есть какое-то приложение, какой-то процесс, который на самом деле может слушать какой-то
[12:26.220 --> 12:30.420]  запрос и перенаправлять его в другое место. То есть, представьте, у нас есть пользователь,
[12:30.420 --> 12:37.260]  который что-то запросил, допустим, музыку Вконтакте. Соответственно, ему идет запрос,
[12:37.260 --> 12:42.100]  он отправляет запрос, я хочу послушать музыку. Этот запрос отправляется в отдельную очередь,
[12:42.100 --> 12:47.860]  дальше пользователи снова обрабатывают, достают этот запрос из очереди на загрузку трека,
[12:47.860 --> 12:55.940]  допустим. После этого, собственно, в каком-то режиме у вас начинает просушиваться трек,
[12:55.940 --> 12:59.220]  но сообщение, на самом деле, из одной очереди перекочевывает в другое, для того,
[12:59.220 --> 13:05.020]  чтобы вам плейлист построили в будущее. То есть, у вас же не сразу плейлист музыки отрисовывается,
[13:05.020 --> 13:10.780]  типа какие треки будут дальше. Они могут отрисоваться чуть позже и прийти чуть позже.
[13:10.780 --> 13:15.860]  Вот, тем самым как раз взаимодействие всех процессов через очередь, это на самом деле
[13:15.860 --> 13:19.940]  самый универсальный способ, каким образом можно отвязать контекст исполнения. Чем еще
[13:19.940 --> 13:24.500]  удобна очередь? Она хранит все сообщения, и если, допустим, у вас произошла какая-то ошибка,
[13:24.500 --> 13:31.460]  то, в принципе, все эти сообщения можно будет обработать снова. А не так, что,
[13:31.460 --> 13:39.780]  ой, извините, ваш запрос выполнил неуспешно, пожалуйста, повторите его позднее. Обычно могут
[13:39.780 --> 13:45.860]  написать, что, типа, вот, ваша заявка вот такая вот, и вообще, смотрите, в чем это удобство. У вас
[13:45.860 --> 13:52.980]  было такое, что когда-то сайт не работает, какой-нибудь. Обычно, если сайт правильно
[13:52.980 --> 14:02.540]  настроен, то у него бывает... Ваншопсайта произошли неполадки, вот ID-шник вашего запроса. Вы можете
[14:02.540 --> 14:08.260]  обратиться к ним в службу техподдержки, они пойдут, посмотрят в очередь, в брокер,
[14:08.260 --> 14:14.020]  который обслуживает это все дело, и скажут вам, типа, ну вот, у нас такой запрос, мы его обработали
[14:14.020 --> 14:19.060]  успешно, либо вот возникла такая ошибка, мы его перезапустили. То есть, этот запрос все равно
[14:19.060 --> 14:26.980]  сохраняется. Именно с теми параметрами, которые происходят. То есть, вот способы взаимодействия,
[14:26.980 --> 14:30.660]  первые три способы взаимодействия между процессами, это прямые способы взаимодействия,
[14:30.660 --> 14:36.900]  а четвертый способ не прямой. Значит, давайте скажу так, что мы с вами посмотрим, наверное,
[14:37.300 --> 14:42.300]  сегодня наша цель акцентироваться именно второй способ. Вот, если у вас, допустим, будут вопросы по
[14:42.300 --> 14:47.140]  третьему способу, тоже можем их разобрать, но обычно это делается в курсе по базам данных,
[14:47.140 --> 14:54.820]  ну а четвертый это уже чуть более далекая история. Но хотя принципы, на которых они работают,
[14:54.820 --> 15:03.660]  мы тоже посмотрим. Так, хорошо, давайте вопрос по этой части. Понятно?
[15:06.900 --> 15:23.260]  Ну обычно очереди умеет обрабатывать до миллионов запросов в секунду. Ой, ну до миллионов в минуту,
[15:23.260 --> 15:33.380]  да. Вы на самом деле, давайте попробуем следующий эксперимент. Мне он нравится. Я сейчас прямо в прямом
[15:33.380 --> 15:49.220]  режиме. Сколько у нас? 11.01 по часам, да? Где у нас чат? Так, я сейчас запутаюсь. А, нашел.
[16:03.380 --> 16:29.460]  Так. Все, я сделал эксперимент. Значит, я не знаю, получится он или нет, но скорее
[16:29.460 --> 16:35.500]  все получится. Значит, я сейчас в чате обсуждения материалов лекции отправил отложенные сообщения
[16:35.500 --> 16:45.020]  на 10 минут вперед. Посмотрим, во сколько придет оно. Ну вот, вот она и задержка до минуты. То есть,
[16:45.020 --> 16:49.540]  пока у нас очередь обрабатывает сообщения, у нас появляются задержки, но в целом они не критичны.
[16:49.540 --> 16:58.220]  Вот. Обычно, кстати, давайте подумаем, в какие моменты времени можно увидеть большую задержку?
[16:58.220 --> 17:22.260]  Ну с утра, во-первых. Более того, в ровные часы. То есть в 9.00, в 10.00, в 11.00, в 12.00, в 13.00. Понятно, по какой причине?
[17:22.460 --> 17:30.660]  Все просто хотят отправить сообщение, чтобы в 9.00 утра оно пришло. Вот. То есть, вот такой механизм.
[17:30.660 --> 17:35.260]  Сейчас посмотрим. Кстати, возможно оно в ту же минуту придет. Вот. Вот так вот работают очереди
[17:35.260 --> 17:39.500]  сообщений. То есть, они пытаются разослать необходимым пользователям необходимую информацию.
[17:39.500 --> 17:49.860]  Вот. То есть, отложенная отправка, она тоже реализована через очередь. Так. Так, еще вопросы?
[17:49.860 --> 18:00.260]  Хорошо. Давайте двигаться дальше. Значит, перейдем мы с вами к Application Programming Interface.
[18:00.260 --> 18:05.460]  Что такое Application Programming Interface? Это договор, в котором говорится, какие команды принимают
[18:05.460 --> 18:10.500]  некоторые сервис и в каком формате передаются данные. На самом деле, когда вы делали задание
[18:10.500 --> 18:15.700]  по тестированию, вы уже познакомились с одним Application Programming Interface. Это был Application
[18:15.700 --> 18:33.380]  Programming Interface с сайта AccuWeather. Давайте попробую даже зайти в него. Вот оно. Вот оно, API.
[18:33.380 --> 18:40.700]  Да. Значит, у меня разлагинились, но в целом мы с вами видим, что в нем есть. Значит, это пример
[18:40.700 --> 18:46.980]  классического API. И вот здесь как раз мы можем с вами увидеть запросы. Значит, здесь сразу скажу,
[18:46.980 --> 18:53.700]  что API использует протокол REST, Representational State Transfer. Про него чуть позже. И у него есть
[18:53.700 --> 19:00.460]  определенная спецификация. То есть, у него есть метод. Это как раз HTTP-метод Get. У него есть
[19:00.460 --> 19:08.180]  название нашего метода. То есть, у нас с вами есть метод URL, по которому мы отправляем. Дальше у
[19:08.180 --> 19:15.420]  него есть типа под папочка. Дальше внутри нее есть, допустим, версия API. Название того сервиса,
[19:15.420 --> 19:25.860]  в которое мы с вами идем. А там ничего не видно, да? Черт. Так. Наступает технология настройки
[19:25.860 --> 19:41.180]  проектора. Все. Магия. Да, я смотрю, что ничего не видно. Значит, смотрите. Вот это адрес,
[19:41.180 --> 19:47.740]  доменное имя по сервису. Дальше это название большого сервиса. Дальше это версия. Версия API
[19:47.740 --> 19:52.740]  ее можно переключать, допустим. Если у нас будет новая версия API, это будет V2, V3, V4 и так далее.
[19:52.740 --> 19:59.460]  Дальше у нас с вами есть информация о том, что это у нас admin.rs. И дальше,
[19:59.460 --> 20:03.060]  вот видите, country-код. В фигурных скобочках те, кто знаком с Python,
[20:03.060 --> 20:10.900]  возможно, понимают, что это за аннотация. Это аннотация для F-литералов, либо аннотация для
[20:10.900 --> 20:18.260]  метода формат. То есть, вы дальше в эту строку можете подставить переменную country-код. Какое-то
[20:18.260 --> 20:24.340]  значение country-код. Вот. И давайте посмотрим, кстати, запрос на country-лист. Вот. Вот он,
[20:24.340 --> 20:28.660]  запрос. И нам вот здесь отдают формочку. То есть, сюда мы можем ставить ключ API,
[20:28.660 --> 20:35.380]  он нужен для авторизации, и указать язык, в котором мы должны вернуть наш запрос. Ну и после этого
[20:35.380 --> 20:41.060]  мы выполняем какой-то запрос и получаем ответ. Вот. Собственно, то же самое у нас происходит и в
[20:41.060 --> 20:49.180]  браузере. Значит, как это все можно достучаться? Этого всего можно достучаться при помощи браузера,
[20:49.180 --> 20:55.000]  который отправляет все сообщения в виде HTTP через протокол HTTP. То есть, это hypertext-transfer
[20:55.000 --> 21:02.540]  протокол. Значит, и здесь как раз у нас есть информация о запросе слева. А второй, это тот
[21:02.540 --> 21:08.900]  payload, который мы с вами отправляем. Это называется телозапрос. То есть, некоторые виды запросов,
[21:08.900 --> 21:13.180]  методы запросов позволяют нам отправлять тело запроса, некоторые методы не позволяют отправлять
[21:13.180 --> 21:20.500]  тело запроса. Давайте рассмотрим, какие методы бывают. Да, сначала давайте начнем с того, что должно
[21:20.500 --> 21:27.300]  быть в HTTP запросе. Значит, первое, что в нем должно быть, это метод, адрес и версия протокола. Сейчас
[21:27.300 --> 21:32.940]  наиболее современная версия протокола это HTTP2. Дальше мы должны отправить заголовки и тело
[21:32.940 --> 21:40.220]  запроса. И давайте как раз посмотрим, какие методы у нас бывают. На самом деле, есть четыре
[21:40.220 --> 21:46.180]  основных метода, и есть еще некоторые дополнительные методы, которые можно специфицировать. Есть метод
[21:46.180 --> 21:53.740]  get, который позволяет нам получить какую-то информацию. Второй вид запроса, это запрос вида пост. То есть,
[21:53.740 --> 22:00.740]  мы можем с вами отправить пост запрос. Обычный запрос пост, это на отправку новых данных. То есть,
[22:00.740 --> 22:05.140]  вы хотите взаимодействовать с сайтом, вы должны внести какие-то новые данные. Это
[22:05.140 --> 22:10.180]  делается обычно через пост запрос. Значит, третий запрос, это пут запрос. Представьте себе,
[22:10.180 --> 22:17.780]  что у вас было какое-то уже поле, там собака-кошка, и вы, допустим, хотите этой собаке сделать
[22:17.780 --> 22:25.820]  кличку, задать какую-то кличку. Тогда вы берете вот этот полностью объект вашего пса или вашего
[22:25.820 --> 22:32.260]  кота и полностью отправляете все результаты. То есть, вы именно отправляете всю информацию и
[22:32.260 --> 22:36.940]  ее обновляете. Если вам нужно обновлять не всю информацию, то для этого обычно используют метод
[22:36.940 --> 22:47.260]  patch. То есть, добавить какие-то атрибуты. Как вы думаете, для чего предназначен запрос метод
[22:47.860 --> 22:56.660]  удалить объект? Да, удалить объект. То есть, это нотация на удаление объекта из баз. То есть,
[22:56.660 --> 23:04.660]  помимо того, что вы можете задать URL, вы можете задать разные методы на эти URL. И заголовок
[23:04.660 --> 23:11.340]  вида options является специфичным. В нем можно получить определенный объект. То есть, закаширован
[23:11.340 --> 23:16.420]  у вас объект в базе или не закаширован. То есть, нужно ли вам возвращать страницу сайта или не
[23:16.420 --> 23:22.060]  надо. Вот. И саунд обычно идет через HTTP запрос. Значит, если мы сейчас с вами пойдем на то же
[23:22.060 --> 23:30.300]  самый наш сайт, давайте я сделаю вкладочку инспект. И, кстати, отключу кеширование. Так,
[23:30.300 --> 23:42.420]  сейчас посмотрю. Да, я включу кеширование. Вот, видите, у нас есть вот запрос вида options. То есть,
[23:42.420 --> 23:51.740]  вот он запрос вида options. Вот. И говорит это. Собственно, в нем определяются, какие мы с вами
[23:51.740 --> 23:59.900]  заголовки можем отправлять. То есть, это информация о сервере, который мы с вами запрашиваем. То есть,
[23:59.900 --> 24:07.100]  ее можно использовать для разных целей. Вот. Значит, в этом запросе, что у нас обычно есть в HTTP
[24:07.100 --> 24:12.820]  запросе? У нас в HTTP запросе есть следующая вещь. Значит, мы с вами, первое, что делаем,
[24:12.820 --> 24:20.660]  это отправляем URL. Вот, видите. Вот здесь. Дальше метод у нас называется options. А, это мы даже
[24:20.660 --> 24:27.940]  специально отправляем запрос. Дальше мы у этого... Дальше что у нас происходит? У нас отправляют
[24:27.940 --> 24:32.060]  заголовки запросов. То есть, мы их там можем отправлять в следующий момент. Значит, что мы здесь
[24:32.060 --> 24:36.220]  можем сказать? Мы говорим, что мы можем принимать файлы определенного формата. Это называется
[24:36.220 --> 24:43.220]  meme-type. То есть, мы говорим, что мы готовы принимать файлы определенного, разного формата. После этого
[24:43.220 --> 24:49.500]  у нас есть информация о кодировании. То есть, на самом деле, странички в интернете приходят не в
[24:49.500 --> 25:00.180]  чистом виде, а в пережатом виде. Как вы думаете, зачем это сделано? Да, они весят меньше. То есть,
[25:00.180 --> 25:06.100]  вы можете сделать гзип про определенную HTML страницу и увидеть, что он эффективно
[25:06.100 --> 25:11.660]  пережимается. Значит, дальше здесь еще один заголовок, интересный браузером, отправляется.
[25:11.660 --> 25:19.980]  Accept language. Здесь, допустим, у меня accept language NUS стоит. Это по факту приоритет того,
[25:19.980 --> 25:28.980]  с каким языком мы с вами работаем. То есть, у меня видно язык системы английский, и поэтому у меня
[25:28.980 --> 25:35.340]  браузер отправляет английский язык. Да, правда, это нужно обрабатывать сайту. То есть, сайт должен
[25:35.340 --> 25:40.420]  разобрать этот заголовок и, в принципе, выдать мне англоязычную версию. Но этого не происходит.
[25:40.420 --> 25:51.060]  Вот, дальше, значит, здесь у нас отправляется еще вкладочка origin и refer. Зачем это нужно? Это
[25:51.060 --> 25:57.220]  нужно для защиты сайтов. То есть, чтобы у вас запросы, которые идут, шли не только с сайта этот,
[25:57.220 --> 26:07.020]  грубо говоря, с определенных сайтов. Чтобы запросы других сайтов не проходили. И, по-моему,
[26:07.020 --> 26:13.980]  вчера на семинаре группы показывал, что будет, что если я в командной строке правильно запущу
[26:14.820 --> 26:22.340]  этого Ахчека, будет очень весело. То есть, я смогу по факту вот этот вот веб-интерфейс подключиться
[26:22.340 --> 26:30.500]  к нему и использовать его как реальный сайт. Вот, то есть, здесь указывается Ахчек.ру и на сайте,
[26:30.500 --> 26:37.340]  тоже, собственно, на самом сервере, на котором мы получаем информацию, там в списке разрешенных
[26:37.340 --> 26:43.500]  адресов стоит Ахчек.ру. Этот адрес не подменяется через браузер. Точнее, его можно подменить,
[26:43.500 --> 26:48.380]  но не таким простым способом. Значит, и дальше вот важное, что у нас отправляется, у нас
[26:48.380 --> 26:55.540]  отправляется вот такое поле под названием user-agent. К чему оно соотносится? Она на самом деле показывает,
[26:55.540 --> 27:01.780]  первое, что она показывает версию операционной системы. Какая у вас операционная система? Дальше,
[27:01.780 --> 27:10.740]  у вас показывается движок, который поддерживается. И дальше указывается версия браузера. То есть,
[27:10.780 --> 27:17.260]  вы не поверите, у всех у нас по-разному эта версия браузера будет отображаться. То есть,
[27:17.260 --> 27:24.980]  вы тоже можете пойти и посмотреть, поисследовать. Вот, и на самом деле, как вы думаете, каким образом
[27:24.980 --> 27:36.500]  этот можно user-agent использовать? Запрос. Ну, давайте сделаем очень простую вещь.
[27:36.500 --> 27:51.180]  Да, видите? Как оно поняло это? Оно разобрало заголовок, которые мы отправили.
[27:51.180 --> 28:04.820]  Сейчас, давайте посмотрим, кстати. Да-да-да, давайте посмотрим, что он парсит.
[28:04.820 --> 28:21.220]  Вот тут запрос. Якуки пропалил все свои. Платформа МакОС.
[28:21.220 --> 28:36.580]  Ну, тут надо посмотреть. Возможно, где-то еще дальше в следующих запросах идет.
[28:36.580 --> 28:51.620]  Тут надо посмотреть еще по запросам. Возможно, где-то тут еще идет какой-то из запросов,
[28:51.620 --> 28:56.220]  который умеет опрашивать операционную систему. То есть, браузер на самом деле умеет опрашивать
[28:56.220 --> 29:03.620]  через JavaScript. У него есть некоторый ограниченный доступ к операционной системе. Вот, и видно,
[29:03.700 --> 29:08.980]  что у нас как раз запросы идут, а они идут у нас в синхронном режиме. Вот, и хочу подчеркнуть,
[29:08.980 --> 29:15.140]  что у нас с вами гет-запрос отправляется по умолчанию. Вот, сейчас посмотрим, что в нем еще
[29:15.140 --> 29:23.500]  находится. Вот, то есть, если мы говорим с вами про отправку запроса при вводе адреса, то мы
[29:23.500 --> 29:29.900]  всегда отправляем с вами гет-запрос. Неважно, каким образом мы его отправляем. Давайте подумаем,
[29:29.900 --> 29:37.500]  каким образом мы можем отправить не гет-запрос, а какой-то другой. Допустим, запрос на обновление
[29:37.500 --> 29:50.500]  данных, на еще какие-то... на обновление данных и так далее. Нет, вот мы работаем как клиент в браузере.
[29:50.500 --> 29:59.700]  Ну, во-первых, если у нас есть HTTP-клиент на фронтенте, то понятно, что мы можем явно
[29:59.700 --> 30:05.420]  указать, что нам нужно отправить запрос определенного типа. Да, конечно же, можно
[30:05.420 --> 30:14.060]  использовать формы для отправки не гет-запроса. Если мы посмотрим внимательно, как отправить
[30:14.060 --> 30:18.420]  поззапрос, мы можем отправить форму, можем отправить запрос из клиента браузера и запрос
[30:18.740 --> 30:28.020]  приложения. Давайте как раз я сейчас открою вот эту кнопочку. Вот она у нас кнопка. Так,
[30:28.020 --> 30:45.900]  где у нас форма? Вот она, форма. Сейчас я вот эту штуку закрою. Да, да, да. Вот она форма, то есть
[30:45.900 --> 30:53.220]  вот он объект формы. По умолчанию, по-моему, у формы метод пост. Ну, сейчас давайте попробуем
[30:53.220 --> 31:00.420]  еще что-нибудь найти. Button Submit, то есть понажайте кнопки Enter, мы с вами отправим запрос. Но на
[31:00.420 --> 31:06.740]  самом деле здесь никакое действие не привязано, потому что это фронтент. Потому что на активацию
[31:06.740 --> 31:11.780]  этой кнопки нажат... там выполняется некоторый джава скрипт код. По умолчанию, значит вы можете
[31:11.780 --> 31:21.460]  у этого всего дела... Давайте посмотрим, может быть, вот эту кнопку. Так, это картинка.
[31:21.460 --> 31:31.340]  Ага, это тоже получается у нас с формы. Ну, видите, в современных браузерах уже кое-что по-другому
[31:31.340 --> 31:39.460]  работает. Так, сейчас найду форму какую-нибудь. Где можно найти форму? На какой-нибудь стареньком сайте.
[31:39.460 --> 31:57.860]  Здесь есть? Нет, здесь нету. Может здесь? Давайте. Сейчас. Нет, это просто форма.
[31:57.860 --> 32:11.420]  В общем, давайте покажу сейчас тогда HTML-форум. Значит, это как раз сайт для разработчиков. Вот.
[32:11.420 --> 32:20.340]  И вот что мы здесь видим. Видите, форум. Дальше, значит, что такое PolyAction? PolyAction это URL,
[32:20.340 --> 32:25.140]  по которому мы отправим запрос. Типа здесь, если мы напишем slash-login, то мы будем отправлять
[32:25.140 --> 32:32.140]  запрос на наш страницу. Наш доменный адрес slash-login. Значит, а вот здесь вот мы можем указать метод.
[32:32.140 --> 32:37.820]  Видите, метод get или метод post. То есть здесь можно указать любой метод, который поддерживается.
[32:37.820 --> 32:54.700]  Вот. Ну, естественно, здесь мы, допустим, pavel asobakakml.com. Вот. И, видите, нам говорится,
[32:54.700 --> 32:59.580]  что на самом деле он пытался отправить пост-запрос, но у него ничего не произошло.
[32:59.580 --> 33:11.380]  Сейчас давайте я открою прямо средство, средство отладки. Я открою вкладку Network.
[33:11.380 --> 33:25.500]  Вот. Собственно, у нас тут. Отправилось ли что-то интересное? Нет, у нас тут ничего
[33:25.500 --> 33:34.220]  неинтересного не отправилось. То есть это просто HTML-формочка. Давайте попробуем еще раз пост-запрос
[33:34.220 --> 33:49.620]  отправить. Возможно, что он поймет, что нужно его отправлять. Не-не-не, он внутри редактора
[33:49.620 --> 33:54.900]  отправляет. Ну, то есть он пытается, по крайней мере, отправить какой-то, какой-то запрос,
[33:54.900 --> 34:01.260]  не именно классический get-запрос. То есть таким образом мы при нажатии формы можем переопределить
[34:01.260 --> 34:07.940]  название нашего сайта. Ну, название нашего приложения. Вот. Либо у нас есть какие-то
[34:07.940 --> 34:12.700]  клиентские приложения, которые мы можем, при помощи которых мы можем отправлять наш запрос.
[34:12.700 --> 34:19.500]  Так. Давайте проверим рубрику эксперимент. Во сколько у нас сообщение пришло? 10 минут.
[34:19.500 --> 34:29.460]  Ну, видимо, нам повезло. То есть у нас не было никакой задержки. Вот. Хорошо. Значит, давайте
[34:29.460 --> 34:35.420]  посмотрим какие вообще... Так, давайте сначала остановимся по вопросу. Понятно ли вот про
[34:35.420 --> 34:48.860]  методы, которые бывают в HTTP? Каким образом их можно отправить? Библиотеки для отправки запросов.
[34:48.860 --> 34:56.460]  То есть что у нас с вами есть? У нас с вами есть несколько command-line интерфейсов и есть несколько
[34:56.460 --> 35:02.540]  более крутых клиентских приложений. Значит, давайте начнем с самого такого, кажется, простого,
[35:02.540 --> 35:10.780]  но при этом не менее важного. Это сайт под названием, инструмент под названием CURL. Он же CURL. Он на самом
[35:10.780 --> 35:17.060]  деле позволяет отправлять большое количество запросов в информацию по сети. Вот. Значит,
[35:17.060 --> 35:30.020]  как оно работает? Оно работает следующим образом. Давайте я, наверное, включу вот так. Вот. То есть,
[35:30.020 --> 35:34.340]  видите, у него есть большое количество именно методов. То есть он позволяет нам отправить...
[35:34.340 --> 35:45.500]  "-d", это у нас пост-запрос, "-x", позволяет нам определить метод. Тут нету поле "-x"? Нету. Но
[35:45.700 --> 35:53.100]  можно загрузить какой-нибудь файл. И есть поле "-f", это наше название формочки. Давайте я сейчас тоже
[35:53.100 --> 36:11.260]  в качестве, наверное, примера сделаю следующую вещь. Так. Значит, что мне нужно будет?
[36:11.260 --> 36:25.900]  Блин.
[36:35.740 --> 36:36.260]  Да, блин.
[36:41.260 --> 36:46.700]  Ладно, давайте с генериумом.
[36:46.700 --> 37:11.180]  А? Ладно. Так, смотрите, я создал пользователя testuser123. И сейчас
[37:11.180 --> 37:21.860]  мы попробуем через него авторизоваться. Значит, давайте посмотрим, собственно,
[37:21.860 --> 37:32.220]  каким образом происходит авторизация на сайте. Значит, testuser123. Так, мне нужна вкладка Network.
[37:32.220 --> 37:43.660]  Значит, какие мы с вами запросы отправили? Так, нам нужен с вами, во-первых, пост-запрос. То есть,
[37:43.660 --> 37:51.260]  мы с вами... Во. То есть, на самом деле, запрос, который у нас идет, мы запрашиваем с вами именно
[37:51.260 --> 37:56.900]  токен. Да, то есть, вот он. Вот я отправил по иллодам пароль. На самом деле, из-за того,
[37:56.900 --> 38:02.140]  что мы общаемся по протоколу HTTP, мы как раз его и можем получить. То есть, что нам нужно отправиться?
[38:02.540 --> 38:15.740]  Нам нужно с вами отправить пост-запрос на вот этот вот адрес. Дальше указать... Вот, смотрите,
[38:15.740 --> 38:28.540]  следующая вещь. Указать, что мы с вами отправляем application.json. То есть, application,
[38:28.540 --> 38:36.420]  то, что это а-ля приложения, а json, то, что у нас формат данных такой. Так, минус х. Значит,
[38:36.420 --> 38:44.820]  тут придется нам прямо немножечко прямо переписать запрос, чтобы понял наш браузер. Минус
[38:44.820 --> 38:55.340]  х реферер. Вот этот запрос. И все, кажется. А, и телозапрос. Сейчас мы давайте отправим,
[38:55.340 --> 39:02.900]  и я сделаю запрос минус в. Итак, смотрите, у нас произошло поле, и что нам сказали? Нам
[39:02.900 --> 39:16.580]  нужно поле логин и пароль. Ну, давайте мы его отправим. Логин. Пейлот. А, юзернейн нам нужен, да.
[39:16.580 --> 39:46.300]  Господи, какой он страшный. А? Нам выдали токен для авторизации. Вот. То есть, сейчас мы с вами
[39:46.300 --> 39:53.380]  сможем при помощи этой штуки пойти и сделать другой запрос. То есть, вот у нас есть запрос,
[39:53.380 --> 40:06.700]  юзеринфо. Давайте сначала попробуем его отправить вот так. И видите, у нас нет никаких токенов для
[40:06.700 --> 40:13.340]  авторизации. Собственно, давайте посмотрим, где у нас передается токен авторизации. Вот,
[40:13.340 --> 40:22.380]  видите, есть запрос как раз под названием authorization. И здесь используется один из
[40:22.380 --> 40:35.020]  протоколов JVT, JSON Web Token. Мы его вставляем вот сюда и получаем информацию о сайте. Все. Ну,
[40:35.020 --> 40:39.540]  то есть, вот таким образом у нас происходит авторизация. То есть, на самом деле, у вас просто,
[40:39.540 --> 40:48.980]  когда вы заходите на сайт, у вас хранится этот токен. Где он хранится? Он хранится в месте под
[40:48.980 --> 40:58.620]  названием, где оно? Application. Вот. Local storage. То есть, есть CCS storage и есть local storage,
[40:58.620 --> 41:05.140]  в которые мы зашиваем токен авторизации. То есть, теперь вы понимаете, каким образом
[41:05.340 --> 41:10.420]  приблизительно работает сохранение информации, о том, что вы сохраняете авторизацию. То есть,
[41:10.420 --> 41:15.380]  в local storage можно сохранять определенную информацию. Но это делается как раз на стороне клиента.
[41:15.380 --> 41:23.260]  Вот. Это если вам command-line-интерфейс, почему я его показал? Потому что зачастую, когда вы
[41:23.260 --> 41:28.980]  будете отдавать какое-то приложение в какое-то другое место, то есть, передавать его в production,
[41:28.980 --> 41:34.500]  либо еще такое. Вам нужно будет зачастую отправлять именно curl-запрос. Опять же,
[41:34.500 --> 41:43.500]  есть более продвинутый интерфейс. Он называется Swagger. Вы можете открывать в любом сайте Swagger.
[41:43.500 --> 41:47.460]  Единственное, вы его здесь не откроете, здесь нужно про вас супер-пользователя на чек иметь.
[41:47.460 --> 42:05.780]  Ну, в целом, здесь есть... Ну, я их почищу. Вот. Собственно, вот они поля, которые есть. То есть,
[42:05.780 --> 42:10.940]  вот они запросы. То есть, здесь у нас видно, что есть get-запрос, есть post-запрос. При этом,
[42:10.940 --> 42:16.900]  здесь еще есть поле имена отправки. То есть, образно говоря, я хочу получить какой-то список
[42:16.900 --> 42:25.620]  курсов, я его могу получить. Вот. И при этом мне... Чем тут удобно? Мне, видите, здесь прямо отправляет
[42:25.620 --> 42:37.100]  curl-запрос для авторизации. Вот. То есть, в принципе, API работает именно таким образом. Значит,
[42:37.100 --> 42:43.020]  если говорить про другие библиотеки, то есть библиотека, именно пакет Postman,
[42:43.020 --> 42:51.100]  на что она обычно используется для тестирования API. Сейчас, вот он. Вот он выглядит вот таким
[42:51.100 --> 42:56.660]  образом. То есть, здесь тоже можно отправлять запросы, указывая заголовки, собственно,
[42:56.660 --> 43:04.740]  проводить какие-то тесты по API. Вот. И есть некоторые библиотеки, значит, другие. Если вы хотите
[43:04.740 --> 43:10.500]  именно JavaScript отправлять, то современная версия библиотеки fetch, то сейчас не надо писать... Раньше
[43:10.500 --> 43:16.780]  был старый метод через XML HTTP request. Вот. Сейчас есть новая библиотека. Значит, и если мы говорим
[43:16.780 --> 43:23.860]  через библиотеки про Python, C++ и Java, то, наверное, вы уже с ними знакомы по библиотеке, по заданию
[43:23.860 --> 43:29.740]  тестирования. Потому что там как раз при помощи этих библиотеки отправляли запросы. Знакомые
[43:29.740 --> 43:38.420]  названия? Ну, это популярно. В библиотеке понятно, что есть не только они. Так, с отравкой запросов
[43:38.420 --> 43:54.020]  разобрались? Как оно происходит? Давайте вопрос. Да, хорошо. Значит, вот пример курсу запроса. CURL
[43:54.020 --> 43:59.540]  запрос. Мы с вами уже его тоже посмотрели. Вот. И теперь нам нужно каким-то образом получать
[43:59.540 --> 44:06.420]  результат. Каким образом получается результат? Это так называемый код и возврат. Значит, они делятся
[44:06.820 --> 44:14.740]  на... У них есть пять уровней деления. Есть ошибки. Извините, я говорю, что ошибки. Есть коды возврата
[44:14.740 --> 44:22.980]  сотые, двусотые, трехсотые, четырехсотые и пятисотые. Значит, в чем заключаются все эти статусы
[44:22.980 --> 44:29.740]  и возвратов? Соты – это служебные статусы. То есть, когда вам нужно держать какой-то заголов,
[44:29.740 --> 44:36.900]  допустим, вы отправляете файл, вам отвечает сотым кодом. Сотый – это continuous,
[44:36.900 --> 44:43.540]  то первое еще какое-то. То есть, не помню. Двусотые означают, что у нас с вами все выполнилось
[44:43.540 --> 44:52.260]  корректно. Значит, двусотый код – это OK. И есть еще код 201, который иногда используют для,
[44:52.260 --> 44:58.380]  если вы что-то отправляете в пост-запросе. То есть, на обновление информации. Это 201 – это
[44:58.380 --> 45:06.180]  обычно created. Дальше идут трехсотые коды. И они тоже различаются между собой. Самые популярные коды –
[45:06.180 --> 45:17.100]  это 301, 302 и 304. За что отвечает код 301? 301 означает, что у вас ресурс постоянно перемещен. То есть,
[45:17.100 --> 45:23.740]  вам присылают заголовок, которым говорится, куда ваш запрос переезжает. Давайте как раз я сейчас
[45:23.900 --> 45:29.740]  покажу. Мы, кажется, это в прошлый раз смотрели. То есть, видите, я делал запрос по HTTP, и мне,
[45:29.740 --> 45:37.900]  видите, возвратился 301, но ему вот permanently. И дальше это соглашение пересылается из заголовок
[45:37.900 --> 45:43.620]  location, куда именно нам надо переадресоваться. То есть, здесь идет переадресация с HTTP на HTTPS.
[45:43.620 --> 45:51.100]  Есть код возврата ошибки, у кода возврата 302. Это означает, что ресурс временно перемещен.
[45:51.100 --> 45:56.100]  Обычно его используют в том случае, когда вы, допустим, залогинились на страницу,
[45:56.100 --> 46:01.900]  вам нужно перейти на другую страницу. То есть, вы выполнили пост-запрос на получение информации,
[46:01.900 --> 46:11.740]  вы дальше переходите на другую страницу. Есть еще код 304. И, на самом деле, если ваш сайт
[46:11.740 --> 46:19.700]  поддерживает код возврат 304, значит, ваш сайт, в принципе, нормально работает. Смотрите. Сейчас.
[46:21.100 --> 46:29.740]  Вот. Сейчас тыкаю на кнопки. А, давайте авторизуюсь.
[46:29.740 --> 46:54.780]  Это 301. Тут, видимо, мне нужно прогрузить все страницы.
[46:54.780 --> 47:05.100]  Ну, видите, он хитрый у меня товарищ. Он именно делает немножко другую вещь. Он
[47:05.100 --> 47:11.340]  отправляет мне код 304. Да, он мне отправляет код 200 и при этом говорит, что у меня информация
[47:11.340 --> 47:21.060]  закоширована на диске. Давайте еще раз попробуем. К сожалению, он мне почему-то не хочет 304 возвращать.
[47:21.060 --> 47:30.140]  Он мне именно дает его сотый. Но, по идее, вот здесь вот можно получить код возврата 304. То есть,
[47:30.140 --> 47:35.380]  это означает, что у вас ресурс не изменился с дата последнего запроса. Это тоже регламентируется
[47:35.380 --> 47:42.140]  заголовками. Вот. То есть, у нас есть 301, 302 и 304 кода возврата. То есть, их можно частенько
[47:42.140 --> 47:50.380]  увидеть. Следующие запросы, это 400-е запросы. Это ошибка на стороне клиента. Какие коды
[47:50.380 --> 47:57.380]  возвратов здесь есть? Первый код возврата это запрос 400. Что он означает? Он означает то,
[47:57.380 --> 48:03.940]  что вы неправильно сделали запрос по API. Вам говорят, что скорее всего вам выдают спецификацию
[48:03.940 --> 48:11.380]  еще, почему ваш запрос по API был выполнен неверно. Кстати, давайте попробуем еще раз. Курл минус.
[48:11.380 --> 48:19.380]  Как-то мы делали какой запрос? Вот это, да? Видите, нам вернулся запрос 400. Ответ 400. То есть,
[48:19.380 --> 48:31.460]  мы сделали неверный запрос по API и нам вернулся ответ. Дальше есть запрос вот такой вот. Http 401.
[48:31.460 --> 48:37.020]  Собственно, мы не авторизовались на сервисе. То есть, у нас доступа нет, потому что мы не
[48:37.020 --> 48:43.580]  авторизованы. Следующий код возврата это 403. Это значит, что у вас доступ к ресурсу запрещен.
[48:43.580 --> 48:56.660]  Следующий после этого 404. Это означает что? Not found. После этого идет запрос 405. Код возврата
[48:56.660 --> 49:06.060]  405. Давайте я его покажу на быстром примере. Сейчас мы быстро напишем приложение.
[49:13.580 --> 49:34.580]  Мы пишем route и давайте я укажу пост. Мы объявляем с вами заголовки и здесь я делаю следующее.
[49:34.580 --> 49:36.420]  Делаю обработчик.
[49:36.420 --> 49:46.500]  Дальше нам нужно
[49:46.500 --> 49:52.620]  мы пишем вот такую штуку.
[49:52.620 --> 49:59.180]  Нам допустим 6789.
[49:59.180 --> 50:07.620]  Сейчас исправим.
[50:07.620 --> 50:14.780]  Как называлось приложение у нас?
[50:14.780 --> 50:22.220]  Открываем вкладку.
[50:22.220 --> 50:29.740]  Ладно, поставлю system-wide.
[50:29.740 --> 50:33.420]  Не поставлю.
[50:33.420 --> 50:40.060]  Придется создавать окружение.
[50:40.060 --> 50:57.660]  Ну да, но я все равно привык это делать окружение.
[50:57.660 --> 51:08.060]  Итак, у нас запущено приложение на 6789 и сейчас мы сделаем следующее.
[51:08.060 --> 51:24.220]  Я отправлю http://localhost 6789 и видите какой мне статус возвращается. 405 метод not allowed. Это
[51:24.220 --> 51:31.140]  означает что у вас есть такой заголовок, у вас есть такой route, но он принимает только пост запроса.
[51:31.140 --> 51:37.780]  То есть это вам говорится о том что вы нужны отправить пост запрос.
[51:37.780 --> 51:42.420]  Вот видите здесь у нас остановится OK.
[51:42.420 --> 51:48.500]  Так, окей, понятно 405 что делает?
[51:48.500 --> 51:53.780]  Какие еще есть?
[51:53.780 --> 51:59.700]  Значит я просто интересные рассказываю, если вы не поверите вот такой код.
[51:59.700 --> 52:13.620]  Можно прочитать что типа я чайник, я не могу обработать запрос.
[52:13.620 --> 52:22.500]  Зачем он делается? Он делается на самом деле для следующих вещей.
[52:22.500 --> 52:28.820]  Представьте себе что у вас есть некоторые запросы на которые мы должны отвечать быстро и запрос на
[52:28.820 --> 52:34.260]  которые мы должны отвечать медленно и в том случае если допустим мы не можем ответить на запрос быстро.
[52:34.260 --> 52:39.940]  Кстати вот такой код возврата используется внутри систем, допустим в гитлабе он используется, тогда ваш
[52:39.940 --> 52:45.940]  запрос из быстрого переходит в медленный и уже медленная обработка этого запроса происходит.
[52:45.940 --> 52:55.060]  Вот оно используется в такой спецификации. И последние коды которые здесь есть это ошибки
[52:55.060 --> 53:02.820]  500. В чем они заключаются? Они заключаются в том что это ошибки уже на стороне сервера, не на
[53:02.820 --> 53:11.500]  стороне клиента. Самый страшный сон разработчика это когда идет большое количество 500 ошибок.
[53:11.500 --> 53:17.540]  Понятно по каким причинам. Это означает что у вас сервер начал падать, причем вы в большом количестве
[53:17.540 --> 53:24.540]  запросов. Теперь смотрите в чем их отличие. Есть ошибка чисто 500, которая отдает вам любой
[53:24.540 --> 53:46.100]  сервер. Смотрите значит мы делаем следующее. Что напишу? Так давайте вот так. Ошибка есть у нас?
[53:46.100 --> 54:00.020]  Вот видите? 500 ошибка. То есть у нас ошибка на стороне сервера, у нас сервер не может обработать
[54:00.020 --> 54:06.940]  наш запрос. Отлично. Ну тогда что нам нужно сделать? Нам нужно каким-то образом понять,
[54:06.940 --> 54:14.900]  что ошибки бывают помимо 500. Значит какие ошибки бывают? Бывают ошибки вида 502 и 503. Возможно вы
[54:14.900 --> 54:21.700]  кстати видели. 502 это означает что bad gateway. Что это означает? Это означает вот мы с вами в
[54:21.700 --> 54:26.220]  прошлый раз смотрели веб-сервер. Веб-сервер пытается перенаправить запрос на наш сервер,
[54:26.220 --> 54:32.940]  а там нашего сервера не оказывается. Ну а нам говорят bad gateway типа что никто не может ответить
[54:32.940 --> 54:41.380]  на запрос. А есть запрос 504 gateway timeout. То есть вы можете на уровне веб-сервера отследить и
[54:41.380 --> 54:46.660]  поставить timeout на выполнение запроса. То есть если вам другой сервер, который должен отвечать
[54:46.660 --> 54:55.060]  на запрос не отвечает, он говорит ой извините, я не могу ответить, сервис висит. Так что теперь
[54:55.060 --> 55:05.780]  вы понимаете, что когда сервер висит, вам страничка высвечивается типа 504. Ну и больше вроде таких
[55:05.780 --> 55:10.900]  известных кодов нету, я перечислю самую популярную. То есть которая встречается с 95% случаев.
[55:10.900 --> 55:19.820]  Так, по кодам вы знаете понятно? Хорошо, давайте дальше. Значит на самом деле теперь мы говорим с
[55:19.820 --> 55:27.900]  вами про API. Самым популярным способом использования API является representation state transfer. На самом деле мы
[55:27.900 --> 55:32.500]  с вами его уже видели. То есть мы пока рассматривали протокол HTTP, теперь мы переходим более высокому
[55:32.500 --> 55:39.660]  уровню. Значит в нем нету состояния, значит все работает поверх протокола HTTP. Есть протокол,
[55:39.660 --> 55:45.420]  способ взаимодействия, которые не работают поверх HTTP, но здесь именно мы закладываемся на
[55:45.420 --> 55:56.780]  сам HTTP. И пути это структуру каталогов. Значит давайте пример я сразу открою. Значит editor.io,
[55:56.780 --> 56:07.700]  здесь есть хороший пример. Прямо всего API. Swagger pad store. И вот давайте посмотрим, как у нас организован
[56:07.700 --> 56:16.940]  грамотный API. Значит все что касается животных, мы видим с вами, оно находится по маршруту slashpad.
[56:16.940 --> 56:24.460]  Собственно нам нужно создать животное, мы делаем пост запрос на slashpad. Нам нужно обновить текущее
[56:24.460 --> 56:31.420]  животное. Мы делаем питомца нашего, мы делаем пут запрос на slashpad. Если нам нужно найти допустим
[56:31.420 --> 56:38.580]  какого-то определенного животного по определенному ID-шнику, мы берем slashpad slashpad ID. То есть вот мы
[56:38.580 --> 56:48.060]  можем даже отправить запрос, давайте отправим. Вот. То есть вот у нас возвращается на животное.
[56:48.060 --> 56:55.500]  Понятно, что она возвращается в виде формата JSON, но это нам не мешает. Вот. Дальше, если мы хотим
[56:55.500 --> 57:03.780]  допустим найти по каким-то тегам, то мы здесь можем передать это все в заголовке запроса. Допустим
[57:03.780 --> 57:15.300]  мы находим животных по тегу элемент. Собственно оно передается в заголовке нашего запроса. Вот.
[57:15.300 --> 57:21.140]  Собственно, ну и остальные тут тоже есть у информации. То есть чем глубже объект, тем сильнее мы в него
[57:21.140 --> 57:27.780]  закапываемся. То есть получается у нас узнать об информации определенным животным slashpad slash ID, но
[57:27.780 --> 57:31.500]  допустим, если нам для конкретного животного нужно загрузить картинку, у нас получается slashpad
[57:31.500 --> 57:37.940]  slashpad ID slash upload image. То есть мы сразу делаем иерархическую структуру нашего директории.
[57:37.940 --> 57:48.020]  Вот. Про store то же самое, про user то же самое. То есть если нам нужно зайти user-login, user-logout. Ну и
[57:48.020 --> 57:53.500]  собственно здесь мы можем с вами назначить переадресацию страниц. То есть как эти запросы
[57:53.500 --> 57:58.780]  обозначаются. Да. Собственно у нас есть в любом в любом приложении, веб-приложении у нас с вами
[57:58.780 --> 58:06.420]  есть раутеры, которые позволяют перенаправить наш запрос. То есть допустим, если мы сейчас делаем
[58:06.420 --> 58:23.620]  app-route slash users, допустим, то мы можем сделать dev-get-users return, допустим, Петя, Вася,
[58:23.620 --> 58:36.700]  Коля, Маша. А понятно, что здесь под капотом еще должен лежать запрос базу данных. Так,
[58:36.700 --> 58:46.700]  так, from flask import jsonify. Нам нужно будет запрос делать. Итак, мы делаем запрос, получаем наш
[58:46.700 --> 58:58.820]  результат. Так, сейчас мы это делаем вверх. Ну и давайте отправим наш курл. Курл 8.9 slash users. То есть
[58:58.820 --> 59:05.460]  у нас теперь получается, послышу, отдается ошибка. А если мы не делаем slash, то видите, нам возвращает
[59:05.460 --> 59:11.620]  этот список. То есть мы по факту с вами навесили обработчик на какое-то событие. И наш веб-сервер,
[59:11.620 --> 59:17.180]  нет, не веб-сервер, наш сервер отвечает этим результатом. То есть на каждый URL вы можете,
[59:17.180 --> 59:25.180]  допустим, навесить какое-то ограничение. То есть если мы говорим здесь, то можно сделать вот так.
[59:25.180 --> 59:34.500]  Так, делаем tning. Опять же, я думаю, это детально будут рассматривать на каком-нибудь курсе по
[59:34.500 --> 59:43.780]  разработке. Мы можем, допустим, сделать вот так slash user slash ID. И здесь обычно методы языка позволяют как
[59:43.780 --> 01:00:00.860]  раз найти. Давайте мы перенесем. Создаем наш животных. Ой, это у нас не животные, это у нас люди.
[01:00:00.860 --> 01:00:15.260]  users ID. Собственно, перезапускаем наш сервер и называем наш метод. Опять же,
[01:00:15.260 --> 01:00:22.860]  редиректы тут тоже работают. Вот у нас users, а дальше, допустим, мы передаем slash user slash ID.
[01:00:22.860 --> 01:00:38.900]  Все, я понял. Разные языки по-разному работают.
[01:00:38.900 --> 01:00:59.380]  Вот так вот. Вот, видите? То есть нам вернулся уже конкретный пользователь. Он подставил поле ID
[01:00:59.380 --> 01:01:05.540]  вот сюда. То есть по факту это у нас декоратор, pattern, то есть он делает какую-то дополнительную
[01:01:05.540 --> 01:01:14.540]  функциональность и в итоге нам в методы нашего запроса доставляет конкретное поле ID. Вот мы
[01:01:14.540 --> 01:01:28.940]  написали с вами простой API. Совсем простенький, но рабочий. Так, хорошо, это понятно? Так, отлично.
[01:01:28.940 --> 01:01:38.380]  Давайте двигаться дальше. Значит, каким образом работает сервер? Собственно, давайте еще раз
[01:01:38.380 --> 01:01:43.500]  поговорим. Мы создаем рабочих на определенный путь. То есть делаем путь в методы, которые мы делаем.
[01:01:43.500 --> 01:01:49.580]  Обрабатываем заголовки и тело запроса и отправляем в статус код тело ответа и заголовки. То есть,
[01:01:49.580 --> 01:01:53.900]  в принципе, заголовки можно тоже возвращать в виде запроса. То есть это можно делать в том,
[01:01:53.900 --> 01:02:02.220]  что в флазке. Значит, пример библиотека, который позволяет писать в приложении. Просто сервер это
[01:02:02.220 --> 01:02:10.060]  oat++, это user ver. Там еще есть драгон. Сейчас появился. Драгон, кстати, самый быстрый по менчмаркам.
[01:02:10.060 --> 01:02:16.100]  В Python можно написать флазк. Это будет синхронный фреймворк. Fast API это. А синхронный фреймворк,
[01:02:16.100 --> 01:02:20.700]  который набирает популярности Django, это такой комбайнер. Такой достаточно большой комбайнер.
[01:02:20.700 --> 01:02:29.780]  И в Java, если мы говорим, то синхронный фреймворк это Spring и ассинхронный это ACO. Он не приходит
[01:02:29.780 --> 01:02:34.580]  ему замену, они решают немного разные задачи. Просто список фреймворков, которые можно смотреть
[01:02:34.580 --> 01:02:41.700]  для обработки веб-серверов. Так, ну, собственно, данные у нас должны храниться в базе данных,
[01:02:41.700 --> 01:02:48.060]  естественно. И мы как раз дошли с вами до трехзвенной архитектуры. То есть мы с вами тоже в прошлый раз
[01:02:48.060 --> 01:02:52.660]  рассмотрели. То есть у нас с вами есть веб-сервер, который разруливает наши запросы со стороны
[01:02:52.660 --> 01:02:57.620]  клиентов. У нас есть с вами application-сервер. То есть это вот как раз то, что я сейчас показывал на
[01:02:57.620 --> 01:03:03.940]  флазке. Это называется application-сервер. И к нему можно привязать базу данных при помощи любых
[01:03:03.940 --> 01:03:08.740]  коннекторов. Вот. Как происходит нагрузка? Значит, это вот такой вот интересный пример,
[01:03:08.740 --> 01:03:15.900]  что на самом деле, если мы говорим про Python, то обычно ставятся отдельные прокси. То есть как это
[01:03:15.900 --> 01:03:22.500]  все работает? У нас клиент отправляет запрос. Дальше у нас веб-сервер перенаправляет запрос
[01:03:22.500 --> 01:03:29.220]  на приложение, которое запущено либо локально, либо еще где-то. И здесь есть еще одна вещь,
[01:03:29.220 --> 01:03:36.500]  вот, которую очень важно не забывать. Это control-demon. То есть зачем он важен? Мы вот сейчас с вами
[01:03:36.500 --> 01:03:42.100]  запустили приложение в командной строке. А теперь представьте, что произойдет, если мы с вами закроем
[01:03:42.100 --> 01:03:52.260]  эту вкладку в консоли? Что у нас с вами произойдет? Процесс завершится, сервер перестанет отвечать.
[01:03:52.260 --> 01:03:59.060]  Поэтому его нужно поставить в каком-то фоновом режиме. Вот. Как раз процесс управления фоновыми
[01:03:59.060 --> 01:04:06.900]  режимами как раз осуществляется такими демонами. Значит, если мы говорим про Ubuntu-like-систему,
[01:04:06.900 --> 01:04:14.660]  там используется system-demon, можно поставить себе supervisor. Вот. И дальше у нас возможный перед
[01:04:14.660 --> 01:04:19.260]  нашим приложением, возможно, еще один сервер стоит. То есть в принципе у нас возможно перенаправление
[01:04:19.260 --> 01:04:26.780]  сервера. После этого нам возвращается уже ответ клиента по обратному пути. То есть здесь может
[01:04:26.780 --> 01:04:32.820]  быть большая цепочка вызовов. Вот. И это высоконагрузка систем. То есть не ставьте, пожалуйста,
[01:04:32.820 --> 01:04:40.700]  обычный сервер s-is. То есть это просто локальное решение. То есть если те же самые приложения
[01:04:40.700 --> 01:04:45.300]  на фласке разворачивают, то нужно будет еще ставить отдельный HTTP-сервер, который позволит
[01:04:45.300 --> 01:04:52.460]  запускать запросы более чем в одном потоке. Так. Хорошо. Теперь вопрос я хочу задать про Питон.
[01:04:52.460 --> 01:05:06.700]  Кто знает, что такое Jill? Да ладно. Никто не знает аббревиатуру Jill?
[01:05:06.700 --> 01:05:30.540]  Jill. Так. Мне, видимо, надо пообщаться с преподавателем по Питону, потому что по идее это нужно знать.
[01:05:30.700 --> 01:05:45.620]  Как это расшифровывается? Это расшифровывается как global interpreter log. То есть несмотря на то,
[01:05:45.620 --> 01:05:51.340]  что если вы хотите запустить приложение в Python, работать в параллельном режиме,
[01:05:51.340 --> 01:05:57.780]  то по факту у вас параллельного режима не получится. Это как раз ограничение Питона.
[01:05:57.780 --> 01:06:03.700]  Вот. Поэтому как раз фласк работает на самом деле в последовательном режиме,
[01:06:03.700 --> 01:06:10.820]  а G-Unicorn как раз позволяет распараллеливать вот эту всю машинерию. Ну, конечно, я удивлен.
[01:06:10.820 --> 01:06:21.260]  Так. Давайте я остановлюсь. Понятно ли вот эта картинка? То есть что у нас есть веб-сервер,
[01:06:21.260 --> 01:06:24.740]  дальше за ним стоит, возможно, какой-то контролирующий демон для того,
[01:06:24.740 --> 01:06:33.340]  чтобы серверы не упали. Если что, он перезапустит эти серверы. То есть его цель, цель этого
[01:06:33.340 --> 01:06:38.820]  супервизора как раз осуществлять контроль за ресурсами. Так. Теперь давайте поговорим
[01:06:38.820 --> 01:06:44.100]  про способы взаимодействия между сервисами. Они бывают синхронными и асинхронными. Значит,
[01:06:44.100 --> 01:06:53.660]  каким образом происходят синхронные взаимодействия? Клиент ожидает сразу ответа от сервиса. Обработка идет
[01:06:53.660 --> 01:07:01.780]  сразу же. То есть у вас представьте себе. Давайте я вам покажу пример асинхронного запроса. Так.
[01:07:01.780 --> 01:07:17.140]  У нас с вами... Где тут network, да? Так. Делаем пресет. Видите, крутится вкладочка. Еще раз.
[01:07:17.140 --> 01:07:26.460]  Видите, то есть мы скачиваем страницу. Мы ждем, пока у нас страница загрузится. То есть у нас в
[01:07:26.460 --> 01:07:31.900]  приложении ждет этого ресурса. Вот. И это как раз называется синхронный взаимодействие. То есть
[01:07:31.900 --> 01:07:36.460]  когда у вас вкладка в браузере крутится, именно сама на загрузку, тогда у вас идет... То есть вам
[01:07:36.460 --> 01:07:41.100]  нужно дождаться ответа от этой страницы. Обработка результатов идет сразу же. И при
[01:07:41.100 --> 01:07:50.100]  этом идет критичное время ожидания. 504. То есть у нас появляется способ получить статус квадрата
[01:07:50.100 --> 01:07:55.460]  504. И обычно, смотрите, все запросы, которые мы открываем страницу в браузере обычно идут
[01:07:55.460 --> 01:08:01.620]  синхронными. Только после этого запросы идут в асинхронном режиме. После этого веб работает
[01:08:01.620 --> 01:08:07.900]  весь в асинхронном режиме. То есть что такое асинхронный режим? Вот, наверное, это вам будет
[01:08:07.900 --> 01:08:13.500]  сейчас вы познакомитесь с этим впервые. То есть, наверное, еще никто не видел ни разу асинхронного
[01:08:13.500 --> 01:08:19.060]  взаимодействия. Только сам, если не копал. Асинхронное. Клиент отправляет запросы и не ждет ответа.
[01:08:19.060 --> 01:08:27.340]  Запрос может обрабатываться позже. При этом у нас появляются большие возможности по балансировке
[01:08:27.340 --> 01:08:32.940]  ресурсов. То есть мы можем отправить одновременно несколько запросов. И один запрос могут получить
[01:08:32.940 --> 01:08:39.420]  разные сервисы. То есть у нас появляется способ распределить нашу нагрузку. Вот. Теперь картинка.
[01:08:39.420 --> 01:08:50.860]  Что это за диаграмма? Кто мне может напомнить? Нет, это низкие из диаграммы. Это одна из диаграмм
[01:08:50.860 --> 01:09:16.500]  взаимодействия. Какая именно? По-английски на S, по-русски на P. Нет. Не-не-не. По следовательности. По
[01:09:16.500 --> 01:09:24.580]  следовательности. То есть у нас сверху вниз идет линия жизни. И у нас с вами идут запросы. Вот так
[01:09:24.580 --> 01:09:31.060]  выглядят синхронные сервисы. То есть у нас товарищ B пошел и отправил запрос на наш веб-сервис. Дальше
[01:09:31.060 --> 01:09:38.460]  этот запрос идет в базу данных. Получает результат. И несмотря на то, что сервис B отвечает
[01:09:38.460 --> 01:09:44.500]  пользой заменить сервису B, человек A сидит и тупит. То есть представьте себе, у нас запрос идет
[01:09:44.500 --> 01:09:54.540]  5 секунд. Человек A только будет ждать не 5 секунд, а 10 секунд. Два раза больше. Проблема. Каким
[01:09:54.540 --> 01:09:59.540]  образом это можно решить? Если у нас сервис позволяет обрабатывать запрос A синхронно, то можно
[01:09:59.540 --> 01:10:07.820]  сделать вот так. То есть видите, у нас получается пользователь A отправляет. Вот этот запрос является
[01:10:07.820 --> 01:10:16.500]  синхронным. Дальше у нас идет запрос на веб-сервис. Мы получаем данные. И дальше нам эти данные вернутся
[01:10:16.500 --> 01:10:22.580]  не сразу, а через какой-то момент времени. То есть видите, у нас запрос баз данных пропадает. Что-то
[01:10:22.580 --> 01:10:28.540]  здесь магическое происходит. Дальше нам возвращаются данные. Дальше нам возвращается ответ. И здесь там
[01:10:28.540 --> 01:10:34.780]  тоже возвращается ответ. Вопрос. Я хочу который вам задать. Скажите мне, пожалуйста, вот у вас,
[01:10:34.780 --> 01:10:39.700]  когда вы вызываете функцию любую в любом языке программирования, какой она является? Синхронной
[01:10:39.700 --> 01:10:47.540]  или асинхронной? Любая функция в любом языке программирования является синхронной. Вопрос.
[01:10:47.540 --> 01:10:57.780]  Каким образом сделать функцию асинхронной? Ага, это если язык программирования поддерживает
[01:10:57.780 --> 01:11:03.980]  такое. А если язык программирования такое не поддерживает? Нам нужна какая-то абстракция,
[01:11:03.980 --> 01:11:09.300]  которая позволит запустить нашу функцию в отдельном окружении и отвязать ее с основного
[01:11:09.300 --> 01:11:14.700]  использования. Как это работает? Для этого есть как раз понятие поток или нить. Лучше сказать
[01:11:14.700 --> 01:11:21.860]  дред. Подробнее будет рассматриваться на курсе операционных систем. Но суть в следующем. У нас
[01:11:21.860 --> 01:11:28.060]  с вами есть код. Это у нас какой-то процесс. Значит у нас есть код, у нас есть данные, есть на файл. И
[01:11:28.060 --> 01:11:34.100]  дальше у нас для каждого потока выделяется набор своих регистров и стэк. То есть у нас все
[01:11:34.100 --> 01:11:39.860]  переменные изначально алоцируются на стэке. Когда мы делаем отдельный поток, то у нас все
[01:11:39.860 --> 01:11:45.940]  сохраняется. При этом у переменных выделяется свой собственный набор регистров и свой собственный
[01:11:45.940 --> 01:11:52.140]  стэк. Регистры это как раз то, что у нас находится на процессоре. Таким образом, как запускать
[01:11:52.140 --> 01:11:58.180]  ассихронную функцию? Мы должны с вами создать новый поток, запустить в нем какую-то функцию и
[01:11:58.180 --> 01:12:07.780]  отвязать этот поток от исполнения. Так, хорошо. Давайте подумаем, а как результат тогда получить?
[01:12:07.780 --> 01:12:10.020]  Вот здесь стрелочка идет в обратную сторону.
[01:12:26.020 --> 01:12:33.420]  Хороший результат. Есть такой объект, он называется фьюч, который позволяет вернуть результат. Но это уже не тривиальный механизм.
[01:12:38.420 --> 01:12:43.340]  То есть объект типа фьюч, что такое объект типа фьюч? Давайте немного расскажу. Вы вызываете функцию,
[01:12:43.340 --> 01:12:49.500]  вам выдается вот типа тикет. Типа проверить готовы результаты или нет. После того, как вы проверите
[01:12:49.500 --> 01:12:54.620]  этот результат, у вас получается ответ, готов или нет. Но на самом деле делают немного по-другому.
[01:12:54.620 --> 01:13:02.580]  Вы по факту аргументы функции, которые вызываете, вы передаете еще одну функцию,
[01:13:02.580 --> 01:13:09.820]  которую нужно будет вызывать в случае того, когда у вас закончился запрос. Эта функция называется
[01:13:09.820 --> 01:13:18.860]  callback. И у меня есть пример к вам. Все на плюсах понимают здесь, ну или на ООПшных языках
[01:13:18.860 --> 01:13:47.220]  программирования. Хорошо. Так, со шхом. У меня есть вот такой код. Его видно, да?
[01:13:47.220 --> 01:13:55.620]  Главное, что функции было видно. Смотрите, каким образом обычно выделяются новые потоки.
[01:13:55.620 --> 01:14:03.460]  В C++ есть абстракция std thread. Ее не было очень долгое время, но сейчас она появилась. Единственное,
[01:14:03.460 --> 01:14:08.660]  что вам нужно будет слинковать с реализацией потоков ваш механизм. Итак, смотрите,
[01:14:08.660 --> 01:14:13.140]  значит объявляется поток, он сразу же запустится. В принципе, можно его не индициализировать. И
[01:14:13.140 --> 01:14:18.980]  первое, что всегда принимает любой поток, поток выполняется в отдельной функции. То есть мы должны
[01:14:18.980 --> 01:14:26.580]  передать сигнатуру нашей функции. Дальше у нас здесь возникает runner thread. Дальше мы передаем
[01:14:26.580 --> 01:14:32.020]  аргументы нашей функции. То есть мы получается будем вызывать функцию runner thread в отдельной
[01:14:32.020 --> 01:14:40.460]  потоке с аргументами 100. И смотрите вот эту сигнатуру. Мы будем принимать на вход функцию,
[01:14:40.460 --> 01:14:49.980]  которая принимает на вход int и возвращает void. И эта функция обычно привязана еще к
[01:14:49.980 --> 01:14:55.980]  отдельному потоку исполнения. То есть у нее должно быть какое-то хранение. И дальше мы
[01:14:55.980 --> 01:15:00.420]  делаем следующее. Мы можем, допустим, сделать вот такое поведение, что если у нас значение
[01:15:00.420 --> 01:15:06.820]  x больше нуля, то мы делаем callback на 200, иначе мы делаем callback на 400. Вызываем функцию callback с
[01:15:06.820 --> 01:15:21.100]  параметром 400. Так, вас не пугает вот такой вот код? Это лямбда функция. То есть это функция,
[01:15:21.100 --> 01:15:27.820]  которая не имеет аргументов, которая не имеет названия. Значит здесь у нас это область захвата,
[01:15:27.820 --> 01:15:33.740]  но нам здесь она не важна. Мы принимаем функцию, которая принимает на вход статус код. Здесь мы
[01:15:33.740 --> 01:15:44.500]  выполняем slip на 100 мс и получаем request complete. Дальше мы делаем следующее. Создаем
[01:15:44.500 --> 01:15:50.300]  второй поток, который принимает в результат запроса минус 200 на вход, а в качестве результата
[01:15:50.300 --> 01:15:57.620]  получает статус код, который засыпает на 50 мс и возвращает определенный результат. Потом наш
[01:15:58.620 --> 01:16:05.940]  основной поток засыпает на 200 мс, то есть у нас в программе будет 3 потока. И дальше мы объединяем
[01:16:05.940 --> 01:16:10.340]  эти потоки, то есть мы возвращаем их в общий контекст исполнения. То есть дожидаемся выполнения
[01:16:10.340 --> 01:16:17.460]  всех поток. Можно не дожидаться, можно их отвязать. Так, вопрос. Как вы думаете, что выведет этот код?
[01:16:17.460 --> 01:16:25.620]  В каком порядке? Вот это очень важно. Да, это все будет запущено сейчас параллельно.
[01:16:25.620 --> 01:16:36.740]  Кто первый закончит? Какая функция? Давайте я строки выделю. Да, сначала поток 2 обработают,
[01:16:36.740 --> 01:16:43.180]  потому что он будет спать 50 мс. Потом обработает поток 1, потому что он спит в 100 мс. А потом
[01:16:43.180 --> 01:16:51.740]  обработают результат все остальные потоки. Так, хорошо. Давайте скомпилируем это все дело.
[01:16:51.740 --> 01:17:06.460]  Нам нужен будет LP thread. Библиотеку по thread нам надо будет прилинковать. Ну давайте проверим.
[01:17:13.580 --> 01:17:22.460]  Что? Похоже? Давайте проверять. Значит сначала у нас выявилось 400. Откуда у нас могло вывести
[01:17:22.460 --> 01:17:30.900]  с 400? Вот здесь он выводит статус код. То есть у нас говорилось, что если у нас аргумент функции
[01:17:30.900 --> 01:17:38.180]  меньше нуля, то у нас вызывается callback с аргументом 400. Да, потом у нас что происходит? Дальше вызывается
[01:17:38.180 --> 01:17:45.300]  вот эта функция request has completed и у нее статус код 200. И только после этого вызывается наш request
[01:17:45.300 --> 01:17:58.620]  completed. Кстати, надо его переместить вот сюда. Да, то же самое. А третьим выполняется наш поток,
[01:17:58.620 --> 01:18:09.980]  он засыпает через 200 мс. Вот. Ну и в таком режиме браузеры работают. То есть вы видите,
[01:18:09.980 --> 01:18:18.420]  вы наверное могли обратить внимание на вот эти вот плашки. Вот эти. Давайте еще раз. Вот видите,
[01:18:18.420 --> 01:18:26.980]  что несколько запросов идут параллельно в этой линии жизни. Раз параллельно, два параллельно и
[01:18:26.980 --> 01:18:34.500]  три параллельно. То есть в принципе запросы как раз идут через функцию callback. Так, понятно ли,
[01:18:34.500 --> 01:18:41.900]  что такое callback? Это функция, которая возвращает результат, которую вызываем после выполнения
[01:18:41.900 --> 01:18:51.060]  определенной функции. Так, и здесь у нас возникает следующая неприятная вещь. Есть один антипатор,
[01:18:51.060 --> 01:19:08.820]  который связан конкретно с callback. Называется callback hell. То есть слева это код, который написан
[01:19:08.820 --> 01:19:15.900]  при помощи callback. То есть получается есть функция findUserByName. Потом нам передается на
[01:19:15.900 --> 01:19:22.980]  аргумент функция callback, которую мы с вами вызываем. А дальше внутри нее функция getUserProfile.
[01:19:22.980 --> 01:19:29.100]  Если у нас ошибка, мы делаем callback с ошибкой. Внутри нее вызываем функцию getUserGetAccount.
[01:19:29.100 --> 01:19:43.420]  Мы вызываем callback. Неприятный код, да? Как его решать? С права видно более приятная
[01:19:43.740 --> 01:19:49.900]  реализация этой функции. Она использует механизм async-await. Но как работает под
[01:19:49.900 --> 01:19:56.460]  капотом механизм async-await? Тоже интересно разобрать. И, значит, если мы сталкиваемся
[01:19:56.460 --> 01:20:03.620]  с вами с такими вещами, это значит, что пора нам рассмотреть? С какой-то проблемой.
[01:20:03.620 --> 01:20:16.700]  Да, правильно. Нам надо рассмотреть паттерн, который умеет решать эту проблему. Это будет
[01:20:16.700 --> 01:20:22.620]  поведенческий паттерн. Он называется цепочка ответственности. И он работает следующим образом.
[01:20:22.620 --> 01:20:28.260]  Вот это все поведенческие паттерны, которые у нас есть. Вы, наверное, на семинарах уже
[01:20:28.260 --> 01:20:35.180]  начали часть из них рассматривать. Мы с вами рассмотрели на семинарах стейт, и в следующий
[01:20:35.180 --> 01:20:40.980]  раз мы рассмотрим с вами обсервер, как реализация очереди сообщения. Остальные потихонечку будут
[01:20:40.980 --> 01:20:47.220]  рассматриваться на семинарах. Итак, что такое цепочка ответственности? Нам нужно запускать
[01:20:47.220 --> 01:20:52.420]  некоторые процессы по цепочке событий. Возможно, это нужно делать каким-то сложным образом. Пример.
[01:20:52.420 --> 01:20:59.100]  Сложный процесс авторизации. Возможно, что для того, чтобы вам авторизоваться в сложной
[01:20:59.100 --> 01:21:05.260]  экосистеме, вам нужно по цепочке авторизоваться во всех сервисах. Раньше, по крайней мере, года два
[01:21:05.260 --> 01:21:10.820]  назад, чтобы вам авторизоваться в Gmail, вы параллельно авторизовывались во всех сервисах
[01:21:10.820 --> 01:21:18.140]  Google. В том числе и в страницах Redirectа был YouTube. Сразу прошиваем всю экосистему. Либо
[01:21:18.140 --> 01:21:22.900]  пайплайн сборки кода. Мы будем с вами говорить про сиай на семинарах, и там тоже это все будет.
[01:21:22.900 --> 01:21:30.860]  Итак, цель паттерна chain of responsibility сделать так, чтобы колбекки нам были не страшны,
[01:21:30.860 --> 01:21:39.900]  чтобы передавать выполнение через делегатов. Примером в данном случае является либо Async
[01:21:39.900 --> 01:21:45.060]  Await. Async Await это более продвинутая реализация. Но есть механизм Promise, который позволяет вам
[01:21:45.060 --> 01:21:51.380]  построить цепочку Command-Prize в разрешении текущей. То есть у вас получается, вы выполняете функцию,
[01:21:51.380 --> 01:21:57.780]  после этого вызываете функцию Xen, выполняете следующую функцию, и получается вот такой паровоз.
[01:21:57.780 --> 01:22:08.580]  Как это реализуется? Это на самом деле очень сильно вам поможет напомнить паттерн-декоратор,
[01:22:08.580 --> 01:22:14.780]  который мы с вами рассматривали. У нас с вами есть обработчик событий, и есть базовый обработчик
[01:22:14.780 --> 01:22:21.980]  событий, у которого есть ссылка на следующий по цепочке. Когда мы с вами обрабатываем
[01:22:21.980 --> 01:22:29.740]  наш запрос, мы говорим, что если у нас следующий обработчик не опустой, то мы передаем его по
[01:22:29.740 --> 01:22:34.940]  цепочке. Значит, если у нас есть конкретный хендлер, то мы можем обработать наш запрос,
[01:22:34.940 --> 01:22:40.060]  тут функция CanHandleRequest, мы его обрабатываем. А дальше мы передаем наш запрос по цепочке.
[01:22:40.060 --> 01:22:45.620]  То есть сначала наш запрос, потом идет запрос на следующий. Ну и в итоге смотрите,
[01:22:45.620 --> 01:22:51.620]  почему это паттерн не декоратор? Потому что декоратор это у нас структурный паттерн,
[01:22:51.620 --> 01:22:58.020]  где мы объекты оборачиваем друг в друга, именно в матрешку. А здесь мы налаживаем цепочку. То есть
[01:22:58.020 --> 01:23:04.580]  у нас здесь получается, после h1 мы ставим следующим h2, а после h2 в следующем ставим h3. Можем
[01:23:04.580 --> 01:23:11.140]  сделать наоборот, то есть h1, h3, h2. То есть это именно поведенческий паттерн. Потом мы обрабатываем
[01:23:11.140 --> 01:23:22.540]  наш запрос через h1, и после этого у нас идет обработка на h2 и на h3. Давайте я остановлюсь на
[01:23:22.540 --> 01:23:39.220]  диаграмме. Скажите, понятна ли диаграмма? Давайте код посмотрим, и в следующий раз мы его запустим.
[01:23:39.220 --> 01:24:01.140]  Итак, вот он код. Да, тут синтаксис такой немножко неприятный, я думаю, будет самым
[01:24:01.140 --> 01:24:08.020]  понятно. То есть мы с вами создаем хендлер, обработчик базовый, и дальше на этот хендлер
[01:24:08.020 --> 01:24:17.540]  обычно ставится функция обработки. И дальше, смотрите, у нас получается паровозик. То есть у нас
[01:24:17.540 --> 01:24:24.060]  на хендлер ставится следующий обработчик, division 0, хендлер делим мы на ноль или нет. После этого мы
[01:24:24.060 --> 01:24:31.540]  ставим хендлер обработки файлов, тут логирование будет идет, и после этого мы еще ставим еще один
[01:24:31.540 --> 01:24:39.940]  хендлер. И в итоге один запустит другой, запустит другой, запустит третий. И здесь как раз идет два
[01:24:39.940 --> 01:24:48.940]  обработка. То есть они пройдут по цепочке. Мы запустим этот пример с вами в будущем и добьем,
[01:24:48.940 --> 01:24:58.700]  наверное, еще один паттерн. Да, тут еще остался один полпаттерн. То есть это что касается такого
[01:24:58.700 --> 01:25:05.980]  базового вводного блока по сетевому заявлению. Вообще есть отдельный курс по сетям. Через раз,
[01:25:05.980 --> 01:25:12.980]  наверное, мы с вами, я еще подумаю, про что мы будем говорить. Мы будем говорить про антипаттерна,
[01:25:12.980 --> 01:25:21.140]  либо мы рассмотрим виды языков программирования. Мне кажется, полезнее будет именно посмотреть,
[01:25:21.220 --> 01:25:29.220]  как работают разные языки программирования. Какие парадигмы существуют. Вот, давайте,
[01:25:29.220 --> 01:25:31.700]  на этом, наверное, все. Если есть вопросы, задавайте.
