[00:00.000 --> 00:15.400]  у меня первый долг это штурвагнер я там не доказал давайте восстановим утверждение пусть
[00:15.400 --> 00:30.680]  а это активная вершина тогда есть вот такого разреза не больше чем стоимость
[00:30.680 --> 00:40.160]  разреза если пересечь с аи и пересечь с аи также было в прошлый раз проверьте
[00:40.160 --> 00:44.240]  пожалуйста что я пока нигде не обманываю насчет жизни такое там мы его
[00:44.240 --> 00:51.080]  оставляем доказательства также индукция и база у нас остаётся если там какой-нибудь
[00:51.080 --> 00:58.520]  ожито это первая активная то для нем уже все доказали индукция база уже доказана
[01:02.960 --> 01:12.560]  так теперь переход пусть есть две последовательные активные вершины ауя в
[01:12.560 --> 01:27.920]  две последовательно активные вершины так я нарисую нарисую вот такую картинку совсем чуть-чуть
[01:27.920 --> 01:34.840]  отличаешься от того что было значит тут я нарисовал вот это вот маленькая облачка это
[01:34.840 --> 01:43.520]  с пересечь с ау большой это с пересечь с ав то же самое здесь это т пересечь с ау это
[01:43.520 --> 01:52.600]  т пересечь с ав отличие от предыдущего только в том что тут ау а не у-1 вот ну и значит чем
[01:52.600 --> 01:59.440]  отличаются что происходит при переходе от ау к ав через все промежуточные значит ну у меня
[01:59.440 --> 02:05.080]  добавилось вот здесь где-то ав а поскольку ав это активно и до нее активных не было то все
[02:05.080 --> 02:10.680]  предыдущие вплоть до ау-то лежали вот этой вот противоположной долей где-то есть ав а все
[02:10.680 --> 02:19.000]  предыдущие до нее лежат в другой доле значит здесь у меня есть все с ау-1 до ав-1 ну где-то
[02:19.000 --> 02:29.360]  вот здесь еще будет ау лежать потому что ау было активное значит все следующие не активные то
[02:29.360 --> 02:34.600]  есть все следующие были в одной той же доле что и ау а потом только ав помещается в другую скажем
[02:34.600 --> 02:45.840]  если эти все в т то те то ав т пришла в с вот ну и тогда мы можем написать следующее что увеличена
[02:45.840 --> 03:06.560]  вот такого разреза она равна величине разреза ав и ау-1 плюс ав и ну все оставшие то есть отсюда
[03:06.560 --> 03:18.320]  но не отсюда тоже у нас было это точно также оцениваем сначала пол по выбору ау в нашем
[03:18.320 --> 03:26.360]  алгоритме мы знаем что это не больше чем ц ау ау-1 потому что ау когда выбиралась на нашем шаге
[03:26.360 --> 03:31.760]  алгоритма для него вот эта штука максимально возможно значит это больше но чем это по
[03:31.760 --> 03:38.440]  предположению индукции это не больше чем с пересечь с ау и пересечь с ау
[03:38.440 --> 03:46.680]  значит это мы делали в тот раз и остается с этой штук разобраться вот но я утверждаю что вот
[03:46.680 --> 03:53.560]  эта вещь она меньше либо равна чем разность вот таких у двух разрезов
[04:07.080 --> 04:13.960]  значит почему это так да я я в общем-то рассматриваю как раз ровно вот эти вот два
[04:13.960 --> 04:21.280]  разреза с пересечь с ау и пересечь с ау это первый разрез и второй с пересечь с ау и пересечь с ау вот
[04:21.280 --> 04:25.800]  почему при переходе вот скажем вот этого меньшего разреза к большему то есть когда я добавляю
[04:25.800 --> 04:31.080]  новые вершинки начиная с у плюс 1 вплоть до в этой почему у меня разрез увеличивается хотя бы
[04:31.080 --> 04:38.920]  настолько но потому что видно что все вот эти вот ребра их раньше здесь не было а теперь они
[04:38.920 --> 04:45.120]  здесь появились поэтому величина увеличилась хотя бы на сумму весов всех этих ребер потому что
[04:45.120 --> 04:50.080]  что что-то такое раньше было с пересечь с ау и пересечь с ау это ну вот все вот это вот эти два
[04:50.080 --> 04:55.400]  маленьких кружочка а теперь чтобы перейти отсюда сюда я добавляю здесь одну вершину а в а здесь
[04:55.400 --> 04:59.800]  вот эти все вершины с у плюс 1 вплоть в минус 1 поэтому как минимум все вот эти ребра точно добавятся
[04:59.800 --> 05:04.040]  но еще там какие-то тоже добавятся не знаю вот такие какие не добавятся вот вот такой ребра добавится
[05:04.040 --> 05:09.080]  но это все они все не отрицательная да у них у всех капаси не отрицательная поэтому это точно
[05:09.080 --> 05:15.760]  нижняя оценка на разность наших разрезов а дальше вот эти сократились и осталось то что нужно
[05:15.760 --> 05:31.520]  ну закращается вот и получили переход индукции тоже сделали
[05:31.520 --> 05:41.040]  вопросы короче мы в прошлый раз все хорошо сделали кроме вот того что тут надо было
[05:41.040 --> 05:45.960]  рассматривать именно разрез ау не ау минус один как в прошлый раз я рисовал а именно ау и тогда
[05:45.960 --> 06:10.920]  здесь все все сойдет хорошо тогда мы переходим сегодня к деревьям сколько успеем столько
[06:10.920 --> 06:20.800]  успеем деревья у нас много раз уже не явно встречались там я говорил что-нибудь типа дерево
[06:20.800 --> 06:28.840]  обхода dfs и так далее и так далее вот давайте определим пусть же это неориентированный граф
[06:28.840 --> 06:38.840]  если вы связаны есть и не содержит циклов то это дерево
[06:59.840 --> 07:05.600]  то есть замечание такие что если у нас есть дерево то во-первых мы знаем как соотносится
[07:05.600 --> 07:22.520]  число ребер число вершин если же это дерево то мощность множества ребер на один меньше мощности
[07:22.520 --> 07:33.840]  множество вершин ну там я надеюсь что у вас там был какой-нибудь курс а-ля комминаторики вот где
[07:33.840 --> 07:38.200]  вы такое движение должны были доказывать но давайте я на пальцах поясню что вот есть у нас
[07:38.200 --> 07:43.800]  н-вершин давайте я скажу что вот это вот н почему это верно есть н-вершин и какой-то граф на них
[07:43.800 --> 07:48.920]  связанный при этом без циклов давайте значит сначала нарисуем все эти н-вершин на плоскости
[07:48.920 --> 07:54.840]  будем по одному добавлять ребра в граф что-нибудь одно провели, другое, третье, четвертое и так далее
[07:54.840 --> 08:00.800]  и поскольку мы ни разу не образуем цикла то есть вот так вот такого не бывает то на самом деле мы
[08:00.800 --> 08:05.480]  обязательно каждый раз тягиваем компоненты связанности да я провожу ребро между разными
[08:05.480 --> 08:09.240]  компонентами связанности объединяю их ну и тем самым уменьшаю число компонент соответственно 1
[08:09.240 --> 08:13.760]  ну и поскольку у меня изначально было n компонент а в конце одна компонента значит число раз
[08:13.760 --> 08:21.880]  который я это сделал ровно на минус 1 значит мы знаем всегда что 1 меньше чем вершин ну и второе
[08:21.880 --> 08:32.600]  замечание что если же это дерево то между любой парой вершин есть ровно один путь ровно один
[08:32.600 --> 08:45.840]  простой путь давайте так и для любых ув существует единственный простой путь между у и в
[08:45.840 --> 09:02.680]  но это например можно пояснить так что если есть какие-то два пути между у и в
[09:02.680 --> 09:09.840]  какой-нибудь такой какой-нибудь такой то оно по сути не обрадует цикл да более формально
[09:09.840 --> 09:14.440]  чтобы понять как здесь выглядит цикл нужно взять скажем симметрическую разность множеств
[09:14.520 --> 09:19.920]  ребер которые входят в первый путь и во второй то есть у вас один путь есть второй group если
[09:19.920 --> 09:23.520]  вы возьмете ех симметрически разность то получите множество которая обязательно является объединения
[09:23.520 --> 09:28.560]  объединений нескольких циклов причем тамmail что будет не пусто потому что это различные пути
[09:28.560 --> 09:33.680]  да ну то есть мы предположим что есть два различных взяли их симметрическую разность вот это
[09:33.680 --> 09:39.740]  гарантированно будет объединив нескольких путей сори циклов объединив нескольких циклов вот и в них
[09:39.740 --> 09:42.740]  ДФ есть ребра, значит хотя бы один цикл в исходном графе был.
[09:56.740 --> 10:00.740]  Как всегда до этого мы деревья рассматривали просто как часть какой-то алгоритмы,
[10:00.740 --> 10:03.740]  типа вот если мы пустим ДФС на графе какому-нибудь ориентированному,
[10:03.740 --> 10:07.740]  то он по сути создает дерево обхода ДФС, вот есть какой-то куринь,
[10:07.740 --> 10:11.740]  как-то там он все обойдет, это будет дерево.
[10:11.740 --> 10:16.740]  Ну здесь будет подвешенное дерево, ориентированное в каком порядке мы все ребра проходили сверху вниз.
[10:18.740 --> 10:23.740]  Ну вот теперь можно на сами деревья непосредственно посмотреть, как отдельный класс графов.
[10:24.740 --> 10:33.740]  Вот вообще деревья это очень простые графы, и на них многие задачи, которые являются трудными в общем случае,
[10:33.740 --> 10:35.740]  они решаются гораздо проще.
[10:35.740 --> 10:41.740]  Ну например помним, что есть несколько задач, которые мы решать нормально на графах не умеем,
[10:41.740 --> 10:42.740]  только за всякие экспоненты.
[10:42.740 --> 10:44.740]  Например там поиск максимальной клики.
[10:44.740 --> 10:49.740]  Вот скажите пожалуйста, если у вас есть дерево, то какая может быть в нем максимальная клика?
[10:50.740 --> 10:53.740]  Конечно да, не больше чем два, потому что если есть три, то есть цикл.
[10:55.740 --> 11:00.740]  Вопрос про независимо на что чуть сложнее, но его тоже может нашить какой-нибудь динамикой по дереву.
[11:00.740 --> 11:09.740]  Давайте запишем, что клика на дереве в дереве содержит не больше двух вершин.
[11:09.740 --> 11:16.740]  Независимо на что чуть похитрее, но можно решать с помощью динамического программирования например.
[11:19.740 --> 11:26.740]  Следующим образом, ну вот смотрите, давайте мы подвесим все дерево за какую-то вершинку, назначим какую-то вершинку корнем.
[11:30.740 --> 11:34.740]  И ведем следующую динамическую величину.
[11:34.740 --> 11:39.740]  Во-первых, вот представьте, что я как-то решил задачу для поддерева.
[11:39.740 --> 11:43.740]  То есть я например знаю в этом поддереве как выиграть максимально независимо множество.
[11:43.740 --> 11:50.740]  Тогда что мне нужно от него знать, чтобы перейти наверх, чтобы объединить ответ отсюда с ответом из другого поддерева.
[11:50.740 --> 11:54.740]  По сути нам нужно только знать взята вот этот вот корневая вершина или нет.
[11:54.740 --> 11:57.740]  Потому что если взята, то есть ограничение, что нельзя брать вот это,
[11:57.740 --> 12:01.740]  то я могу взять максимальное такое независимое, а если не взята, то соответственно я могу в остальных местах делать что угодно.
[12:01.740 --> 12:07.740]  То есть если эта вершина не присутствует в независимом множестве, то я могу здесь взять максимальное такое независимое.
[12:07.740 --> 12:10.740]  И дальше объединить с чем угодно, потому что на это ребро нет ограничений.
[12:10.740 --> 12:13.740]  Иначе она взята и значит нельзя брать вот это.
[12:13.740 --> 12:16.740]  Поэтому я введу две DP.
[12:16.740 --> 12:30.740]  DP0 от V это скажем размер максимального независимого множества под дереве V.
[12:34.740 --> 12:36.740]  Если саму V брать нельзя.
[12:36.740 --> 12:45.740]  Брать в независимом множестве нельзя.
[12:45.740 --> 12:49.740]  А DP1 тогда наоборот я ее насильно должен взять.
[12:49.740 --> 12:55.740]  DP1 от V нужно взять.
[12:55.740 --> 13:06.740]  Ну и тогда, например, если у меня для какой-то вершины, точнее для всех детей какой-то вершины посчитаны вот эти DP,
[13:06.740 --> 13:08.740]  то как посчитать DP для самой вершины?
[13:08.740 --> 13:14.740]  Вот есть какая-то U, есть у нее куча детей, там V1 и так далее, VK.
[13:14.740 --> 13:18.740]  Как найти скажем DP0 от U?
[13:18.740 --> 13:23.740]  DP0 значит я не могу взять U, но в под деревьях я могу делать что угодно.
[13:24.740 --> 13:27.740]  При этом независимо друг от друга.
[13:27.740 --> 13:29.740]  Это несвязанные между собой графы.
[13:29.740 --> 13:32.740]  Я знаю, что эту вершинку я не беру, потому что здесь я написал нолик.
[13:32.740 --> 13:35.740]  Значит мне нужно просто здесь делать что угодно, набрать какое угодно независимое множество.
[13:35.740 --> 13:37.740]  Здесь какое угодно и так далее.
[13:37.740 --> 13:45.740]  Поэтому это будет просто сумма по всем детям от первого докатыва максимум из DP0 DP1.
[13:45.740 --> 13:53.740]  Это случая, если я U не беру.
[13:53.740 --> 13:59.740]  Если я U беру, то значит мне нельзя брать вот эти вот корневые вершинки детей,
[13:59.740 --> 14:03.740]  а кроме этого можно делать что угодно.
[14:03.740 --> 14:08.740]  Если U взято, то вот эти нельзя брать, а все остальные можно брать, причем независимо в под деревьях.
[14:08.740 --> 14:16.740]  Поэтому DP1 от U это единица плюс сумма по всем детям DP0 VAT.
[14:16.740 --> 14:20.740]  Потому что само VAT брать нельзя, а в под деревьях можно делать что угодно.
[14:20.740 --> 14:22.740]  Точнее любое независимо можно брать.
[14:22.740 --> 14:26.740]  И если меня интересует максимальная во всем вот этом под деревьях вершинки U,
[14:26.740 --> 14:31.740]  то значит мне нужно максимально в каждом из них взять с помощью DP.
[14:31.740 --> 14:33.740]  Вот такая динамика под деревья.
[14:33.740 --> 14:36.740]  Под деревом мы просто идем снизу вверх, насчитываем ее.
[14:36.740 --> 14:42.740]  И в конце DP0 от R или DP1 от R это есть ответ.
[14:44.740 --> 14:52.740]  Ответ максимум из DP0 от R, DP1 от R.
[14:52.740 --> 14:58.740]  То есть получается линейный алгоритм нахождения максимального независимого множества.
[14:58.740 --> 15:02.740]  И так многие задачи решаются на деревьях быстрее, чем в общем случае.
[15:18.740 --> 15:24.740]  Вот еще один из таких интересных примеров, что можно на деревьях решать быстрее, чем в общем случае,
[15:24.740 --> 15:30.740]  это проверка деревьев на изоморфизм, значит изоморфность графов.
[15:32.740 --> 15:33.740]  Определение.
[15:34.740 --> 15:38.740]  Пусть есть два графа, но же один, же два.
[15:38.740 --> 15:53.740]  Если есть функция из множества вершин первого графа в множество вершин второго графа,
[15:53.740 --> 15:58.740]  то первая графа такая что?
[15:58.740 --> 16:00.740]  Если она такова что?
[16:00.740 --> 16:02.740]  Во-первых, это биекция.
[16:06.740 --> 16:15.740]  Во-вторых, каждую пару вершин, которые соединили ребром в исходном графе, она переводит в пару вершин, которые соединили ребром во втором графе.
[16:15.740 --> 16:19.740]  И наоборот, если две вершины были не соединились здесь, то они будут не соединились здесь.
[16:20.740 --> 16:26.740]  Для любой пары УВ являешься ребром первого графа.
[16:26.740 --> 16:30.740]  Пара Фиату и Фиат В это ребро второго графа.
[16:34.740 --> 16:40.740]  И наоборот, для любой пары не являешься ребром первого графа.
[16:44.740 --> 16:48.740]  Пара образов не является ребром второго графа.
[16:48.740 --> 16:51.740]  То есть, ребра в ребра, не ребра в не ребра.
[16:52.740 --> 16:59.740]  А тогда, если все это верно, то Фиизоморфизм графов же один, же два.
[17:03.740 --> 17:07.740]  Физоморфизм графов же один, же два.
[17:18.740 --> 17:35.740]  Так, с точки зрения рисуночка, это значит, что просто графы одинаковые, только как-то перенумерованы по-разному.
[17:36.740 --> 17:39.740]  Что-нибудь такое я нарисую.
[17:39.740 --> 17:41.740]  Вот такой граф.
[17:44.740 --> 17:46.740]  Ну и вот такой граф.
[17:47.740 --> 17:49.740]  Это же один, же два.
[17:49.740 --> 17:51.740]  И тут произвольно номирать вершины.
[17:51.740 --> 17:53.740]  1, 2, 3, 4, 5.
[17:53.740 --> 17:55.740]  1, 2, 3, 4, 5.
[17:55.740 --> 18:01.740]  Они изоморфны, а можно вот эту двойку привести в эту единицу, эту четверку в эту двойку, ну и так далее.
[18:01.740 --> 18:04.740]  Видно, что графы как бы одинаковые структуры, их можно правильно перенумеровать.
[18:05.740 --> 18:12.740]  И, собственно, из определения, видно, что они одинаковы, просто отличаются перенумерацией вершин.
[18:12.740 --> 18:16.740]  Что я могу так перенумерать вершины первого графа, чтобы получить вершины второго графа,
[18:16.740 --> 18:22.740]  при этом сохранятся все свойства, то есть все ребра перебивают в ребра, а отсутствие ребра придет в отсутствие ребра.
[18:25.740 --> 18:29.740]  И в общем случае, если у вас есть произвольные два графа какие-то, то есть понятно, да,
[18:29.740 --> 18:33.740]  вот если у вас есть какие-то произвольные два графа, то вам надо проверить они изоморфны или нет,
[18:33.740 --> 18:36.740]  как бы это одна и та же картинка или разная, или в них есть какое-то отличие.
[18:36.740 --> 18:39.740]  Можно делать всякие простые проверки.
[18:39.740 --> 18:43.740]  Ну конечно, там можно проверить, что у них одинаковый число вершин.
[18:44.740 --> 18:47.740]  Можно перег 코�ись одинаковой число ребер.
[18:50.740 --> 18:52.740]  Не знаю, можно проверить еще что-нибудь, да.
[18:52.740 --> 18:55.740]  Вы можете проверить какие-то характеристики, проверить что они одинаковые,
[18:55.740 --> 18:58.740]  это как бы необходимые условия на том, что они изоморфны, но недостаточно.
[18:58.740 --> 19:01.340]  вы можете там еще что-нибудь проверить, хоть не знаю,
[19:01.340 --> 19:05.100]  посчитать максимальное просчитание в боеграфах, если не заморфины, то соответственно
[19:05.100 --> 19:12.180]  максимальное просчитание тоже должно быть одинаковое. Но не в обратную сторону. Вот. И в общем
[19:12.180 --> 19:19.140]  случае, опять, пока никому не известно, как это делать заполином. Пока вот эта задача не решается
[19:19.140 --> 19:31.500]  заполином. Значит, проверка произвольных графов на изоморфизм, на изоморфность,
[19:31.500 --> 19:49.340]  на изоморфность, пока не решается заполином. Я не пишу, что она, наверное, трудная, потому что
[19:49.340 --> 19:54.500]  про нее этого не известно. То есть это в каком-то смысле задача проще, чем вот эти вот всякие
[19:54.500 --> 19:59.940]  макс клика, максимально здесь все множество и так далее, но пока еще сложнее, чем все полиномиальные.
[19:59.940 --> 20:04.860]  То есть это какая-то промежуточная задача, которую пока не заполином решать не умеют, не умеют доказать,
[20:04.860 --> 20:10.980]  что она достаточно сложная, чтобы решить какой-нибудь трясат или макс клику. То есть она такая совсем
[20:10.980 --> 20:20.540]  подвешенная, с ней вообще ничего не понятно. То есть она вроде как и не сложная, и при этом не простая,
[20:20.540 --> 20:25.860]  что заполином пока никто не умеет решать. Ну а на деревьях это можно сделать довольно быстро.
[20:25.860 --> 20:38.180]  Мы сейчас сделаем ZenLogin. Проверка деревьев на изоморфизм. Проверка деревьев на изоморфность.
[20:38.180 --> 20:59.740]  Так, ну что мы сделаем? Во-первых, давайте мы научимся работать с ориентированными деревьями,
[20:59.740 --> 21:08.060]  ну то есть с подвешенными какими-то. Пусть деревья подвешенные. Пусть деревья подвешенные.
[21:08.060 --> 21:19.460]  То есть есть какие-то выделенные корни, у них там R1, R2, и вот как-то так и не выглядит. Давайте я прям
[21:19.460 --> 21:27.180]  стрелочкой даже нарисую, чтобы понять направление обхода всего дерева. Вот, и надо понять,
[21:27.180 --> 21:31.580]  одно это дерево или нет. Можно ли перенумеровать вершинки, чтобы все было хорошо. Ну понятно,
[21:31.580 --> 21:35.740]  что корень должен перейти в корень, дети корни должны перейти в детей корня, но непонятно в
[21:35.740 --> 21:41.060]  каком порядке. Например, если вот здесь вот есть два ребенка, которые локально выглядят как одинаково,
[21:41.060 --> 21:45.700]  вот этих двух вершин исходящей степень 2, и вот этих двух вершин исходящей степень 2,
[21:45.700 --> 21:49.980]  тогда непонятно, как вот эти две вершины отобразить вот на эти две. Их надо оставить так же или свопнуть.
[21:49.980 --> 21:55.140]  Это можем только узнать, если мы найдем где-то различия между ними где-то ниже. Вот скажем,
[21:55.140 --> 21:59.740]  вот здесь вот я там найду такую штуку, которая есть только здесь. Значит, вот эту вершинку,
[21:59.740 --> 22:04.820]  а, надо отобразить в эту вершинку h'. Соответственно, эту надо отобразить вот в эту. И никак иначе.
[22:04.820 --> 22:09.940]  Чтобы понять, кого можно куда отобразить, нужно куда-то ниже идти и что-то там такое более
[22:09.940 --> 22:14.900]  хитрое делать. Нельзя просто сказать, что там смотрим на исходящую степень, и вершины одной
[22:14.900 --> 22:32.020]  степени друг в другом отраздействуем. Надо действовать хитрее. Мы сделаем следующее. Мы
[22:32.020 --> 22:40.660]  каждой вершине поставим соответственно какое-то число такое, что вот есть какая-то вершина,
[22:40.660 --> 22:45.940]  есть ее под дерево. Я этому под дерево ставлю соответственно какое-то число. Давайте напишу это
[22:45.940 --> 23:02.740]  cv. Это класс эквивалентности под дерево вершины v. Класс эквивалентности под дерево v. Ну и мы
[23:02.740 --> 23:06.500]  хотим, чтобы изоморфные деревья были в одном классе, а не изоморфные в разных.
[23:06.500 --> 23:15.860]  Хотим, изоморфные, изоморфные под деревья
[23:15.860 --> 23:28.340]  имеют один тоже класс эквивалентности. Один класс неизоморфный, соответственно,
[23:28.940 --> 23:46.540]  как-то нужно дать номер каждому дереву, чтобы одинаковые под дерево имели один тот же номер,
[23:46.540 --> 23:53.940]  а разные под деревья имели разные номера. Ну начнем снизу дерева от листиков. Если вершина это
[23:54.820 --> 23:58.940]  лист, да если у нас есть много листьев, то понятно, что под деревьями листьев они все
[23:58.940 --> 24:03.700]  одинаковые, потому что это просто под дереве за одной вершиной, таким образом, всегда когда мы
[24:03.700 --> 24:09.540]  видим лист, мы всем вот этим под деревьями из-под одной вершины, да, под дерево листа должны
[24:09.540 --> 24:19.280]  дать соответствup européя один тот же класс, что вот это класс, который описывает ber
[24:19.280 --> 24:23.280]  Вот так это и есть, а это, скажем, класс № 0.
[24:23.280 --> 24:27.280]  Если в поддереве одна вершина, то это класс № 0.
[24:27.280 --> 24:29.280]  Это мы сделаем для листьев.
[24:29.280 --> 24:34.280]  А дальше у нас будет следующее действие.
[24:34.280 --> 24:38.280]  Для произвольной вершины В пусть мы знаем классы всех ее детей.
[24:38.280 --> 24:45.280]  То есть у меня есть много детей, я знаю класс вот этого чувака, класс вот этого чувака, класс вот этого и класс вот этого.
[24:45.280 --> 24:53.280]  Тогда понятное дело, что класс В однозначно задается мультимножеством номеров класса всех его детей.
[24:53.280 --> 24:58.280]  Потому что, во-первых, я знаю размер этого множества, то я знаю количество детей у В.
[24:58.280 --> 25:02.280]  Во-вторых, если я знаю какие именно здесь классы, то я могу их как угодно перемешать.
[25:02.280 --> 25:04.280]  Я могу переставлять детей как угодно.
[25:04.280 --> 25:07.280]  Получится одно и то же поддерево с точностью изоморфизма.
[25:07.280 --> 25:12.280]  Ну и, значит, если я знаю само мультимножество, какие здесь классы, то я целиком знаю, как выглядит дерево.
[25:12.280 --> 25:17.280]  Я знаю, что у меня есть четыре ребенка, здесь там класс номер один, класс номер два, класс номер три, класс номер четыре.
[25:17.280 --> 25:23.280]  Я знаю, как выглядит это дерево, то есть однозначно знаю весь этот класс, однозначно знаю все это по дереву и так далее.
[25:23.280 --> 25:30.280]  То есть, по сути, чтобы задать класс эквивалентности одной вершинки, мне нужно знать класс вот этих вот всех его детей.
[25:30.280 --> 25:36.280]  Поэтому давайте мы напишем...
[25:36.280 --> 25:41.280]  Ну, давайте я пример сначала допишу этот.
[25:41.280 --> 25:47.280]  Что если, например, я вот, ну, например, да, я решу, что все эти вершинки имеют класс ноль,
[25:47.280 --> 25:54.280]  то тогда я для вершинки В сначала эти четыре нуля как бы складываю вектор и говорю, что это описание класса вершины В.
[25:54.280 --> 26:00.280]  То есть вершина В, это такая вершина, что у нее список детей образует вот такой набор классов.
[26:00.280 --> 26:04.280]  И буду говорить, что это соответствует классу номер один.
[26:04.280 --> 26:12.280]  То есть теперь у меня число один соответствует вот такому вот дереву В, ну, точнее, вершинки, у которой ровно четыре ребенка каждая из которых является листом.
[26:12.280 --> 26:14.280]  Ну, например, вот так мы задумировали.
[26:14.280 --> 26:21.280]  Дальше, если у меня есть там какая-то другая вершина У, у которой есть сын В и там еще что-то,
[26:21.280 --> 26:27.280]  то опять я знаю, что это класс номер один, знаю какие это классы, складываю все эти числа в вектор
[26:27.280 --> 26:33.280]  и говорю, что, собственно, содержимое этого вектора и задаю однозначно мне класс, класс эквивалентности для текущей вершины.
[26:33.280 --> 26:43.280]  Только чтобы у меня было все в порядке с, в порядком, я сказал, что это как бы по сути мультимножество, потому что я могу как угодно свопать детей,
[26:43.280 --> 26:49.280]  то мне нужно на самом деле здесь делать, ну, например, сортировку по возрастанию всех вот этих классов,
[26:49.280 --> 26:58.280]  потому что если мы применим 1.0.0, то давайте я напишу 0.0.1, чтобы, ну, в общем, я буду хранить это все в виде вектора,
[26:58.280 --> 27:06.280]  чтобы все однозначно хорошо, ну, как бы, чтобы вот это вот было по сути равно там 0.1.0 и было равно 1.0.0.
[27:06.280 --> 27:13.280]  Да, потому что неважно, какой именно из этих детей имеет класс номер один, потому что я их все равно всегда могу как бы перенумеровать,
[27:13.280 --> 27:21.280]  так что все вот эти три вектора надо отрождествовать. Ну, для этого я просто строю такой вектор 1.0.0, сортирую в порядке возрастания и получаю новый вектор,
[27:21.280 --> 27:26.280]  который у меня еще нигде не встречался, говорю, что это класс номер два. Вот, ну и так далее.
[27:26.280 --> 27:35.280]  Просто иду по дереву снизу вверх, записываю номера классов детей в вектор, сортирую, и это новый тип класса.
[27:35.280 --> 27:47.280]  Вот, ну и в конце там понятно, что надо будет просто посмотреть на класс R1, класс R2, если не одинаковый, то это изоморфный деревьев, если не одинаковый, то неизоморфный.
[27:47.280 --> 27:50.280]  Вот, ну давайте код напишем.
[27:50.280 --> 28:00.280]  Значит, во-первых, мне нужен будет мап из векторов int, чтобы по вот этому вектору определять какой-то номер класса.
[28:00.280 --> 28:08.280]  Давайте так назову его номер. Ну, по вектору как бы детей понять какой-то номер класса.
[28:08.280 --> 28:16.280]  Дальше нужен вектор int c, да, вот тот самый номер класса для каждой вершины.
[28:16.280 --> 28:22.280]  Ну, видимо, еще нужна переменная penta, давайте я назову.
[28:22.280 --> 28:26.280]  Сколько классов мы нашли?
[28:26.280 --> 28:30.280]  Ну, вот, вот, вот.
[28:31.280 --> 28:34.280]  Penta, давайте я назову.
[28:34.280 --> 28:39.280]  Сколько классов мы нашли?
[28:39.280 --> 28:44.280]  Тогда наш алгоритм, который по сути просто обходит дерево, может работать так.
[28:44.280 --> 28:46.280]  Вот он стоит в вершинке v.
[28:46.280 --> 28:49.280]  Дальше.
[28:49.280 --> 28:51.280]  А, ну да.
[28:51.280 --> 28:57.280]  Заводит список классов эквалентности детей.
[28:57.280 --> 29:01.280]  Давайте я его назову a, потому что мне лень писать больше букв.
[29:01.280 --> 29:05.280]  Дальше, проходимся по всем детям.
[29:05.280 --> 29:09.280]  Давайте я пишу так u, это сын v.
[29:09.280 --> 29:13.280]  Значит, сначала запуститься рекурсивно от этого самого сына.
[29:13.280 --> 29:16.280]  Дальше, по завершении этой рекурсии, по завершении dfs atu.
[29:16.280 --> 29:22.280]  Я считаю, что у меня c atu уже посчитано, то есть после этого c atu известно.
[29:23.280 --> 29:26.280]  И я это c atu просто pushback в массив a.
[29:26.280 --> 29:31.280]  То есть я нашел номер класса эквалентности ребенка, этот класс запихал в вектор a,
[29:31.280 --> 29:33.280]  ну и так делаю для каждого ребенка.
[29:33.280 --> 29:45.280]  То есть a pushback, pushback, класс, вершинки номера u.
[29:45.280 --> 29:46.280]  Сделали.
[29:46.280 --> 29:49.280]  Дальше, сочетировка вектора a.
[29:57.280 --> 30:03.280]  Ну и все, теперь вот этот вот сам вектор a является описанием класса эквалентности вершины v.
[30:03.280 --> 30:08.280]  И мне нужно посмотреть, если a уже присутствует в мапе num,
[30:08.280 --> 30:12.280]  то тогда надо просто написать, что c от v это num от a.
[30:12.280 --> 30:17.280]  Если не присутствует, то нужно его сначала вставить, сказать, что это новый класс эквалентности,
[30:17.280 --> 30:22.280]  и для вершинки c от v тоже поставить тому, чему было равно knt.
[30:23.280 --> 30:25.280]  Давайте я дальше словами напишу.
[30:25.280 --> 30:34.280]  Если a принадлежит num, то есть если у меня уже в этой мапе есть соответствие такому вектору чему-то,
[30:34.280 --> 30:39.280]  то мне нужно сделать c от v равно просто num от a.
[30:40.280 --> 30:47.280]  Потому что уже когда-то раньше в дереве я нашел такую вершину, как бы класс, который относится к векторам a.
[30:47.280 --> 30:51.280]  Я знаю, к какому номеру это соответствует, что это за номер класса эквалентности.
[30:51.280 --> 30:54.280]  Ну вот я, собственно, его просто переназначаю для вершинки v.
[30:54.280 --> 31:01.280]  Иначе, я напишу так, c от v равно knt.
[31:01.280 --> 31:07.280]  То есть я завожу новый класс эквалентности с номером knt, говорю, что вершинка v имеет такой класс.
[31:08.280 --> 31:13.280]  И, видимо, num от a равно knt++.
[31:17.280 --> 31:24.280]  То есть я в мою мапу вставляю этот вектор с номером knt, при этом knt еще увеличу ничку.
[31:24.280 --> 31:34.280]  Хорошо.
[31:34.280 --> 31:38.280]  Да, сколько у нас закрыть?
[31:38.280 --> 31:45.280]  Ну все, вес алгоритм. То есть если нам нужно теперь два каких-то дерева проверить на изоморфность,
[31:45.280 --> 31:52.280]  то я запускаю dfs от первого корня, dfs от второго корня, на одной и той же памяти, как бы вот этот вот c.
[31:52.280 --> 31:57.280]  И тогда нужно просто проверить, что в конце c от r1 равно c от r2.
[31:57.280 --> 32:00.280]  Если равны, то изоморфны, если не равны, то не изоморфны.
[32:00.280 --> 32:05.280]  Вот это, собственно, следует просто из нашего алгоритма, что...
[32:05.280 --> 32:11.280]  Как это пояснить?
[32:11.280 --> 32:17.280]  Ну, вот, собственно, мы там рисовали, что у нас выполняется вот это вот свойство,
[32:17.280 --> 32:20.280]  что изоморфенные деревья это один класс, а они изоморфенные-то разные классы.
[32:20.280 --> 32:26.280]  Собственно, мы так построили алгоритм, что это выполняется, что, как бы, если у меня известен список классов детей,
[32:26.280 --> 32:30.280]  да, и если они одинаковые эти списки, то, значит, у меня получается изоморфные по деревья,
[32:30.280 --> 32:33.280]  если разные списки, то не изоморфные по деревьям. Ну, собственно, собственно и все.
[32:33.280 --> 32:37.280]  Поэтому r1, r2 нужно просто будет проверить, правда ли, что c от r1 равно c от r2,
[32:37.280 --> 32:44.280]  если да, то изоморфны, если нет, то не изоморфны.
[32:44.280 --> 32:57.280]  Так, теперь асимптотика алгоритма, асимптотика будет на самом деле n log n,
[32:57.280 --> 33:05.280]  где n – это число вершин в... Ну, пусть в каждом дереве поровну вершин, иначе нет смысла проверять незаморфность,
[33:05.280 --> 33:11.280]  по n в каждом дереве, где n – число вершин в обоих деревьях.
[33:22.280 --> 33:28.280]  Почему это работает за n log n? Ну, во-первых, понятно, что что-то такое должно быть, потому что у меня сортировка векторов,
[33:28.280 --> 33:38.280]  у меня n раз будет сортировка. Суммарно, размер всех вот этих ашек – это от n, потому что каждая вершина,
[33:38.280 --> 33:44.280]  точнее, видимо, ну да, даже не больше, чем n, потому что каждая вершина побывает в а только один раз,
[33:44.280 --> 33:49.280]  в а для своего родителя, поэтому суммарно размер всех вот этих векторов – это линейное что-то,
[33:49.280 --> 33:55.280]  да, ну и я вызываю сортировку нескольких массивов в суммарной линии длины. Это работает за n log n.
[33:55.280 --> 34:03.280]  Остается разобраться с мапой, да, почему это работает быстро, то есть я как бы обращаюсь к мапе по индексу равному вектору.
[34:05.280 --> 34:14.280]  Ну, надо вспомнить, что если у нас есть мап, и он хранит векторы, то за сколько вообще происходит любая операция?
[34:14.280 --> 34:21.280]  За сколько я, скажем, проверяю вхождение или там достаю значение по номеру?
[34:21.280 --> 34:32.280]  Давайте напишем, что время запроса, время обработки запроса
[34:32.280 --> 34:57.280]  мап, есть длина а умножить на логарифм размера. Ну, так log n и напишем, видимо.
[34:57.280 --> 35:03.280]  Ну, потому что, смотрите, вот понятно, что логарифм, он как бы, то есть если бы у меня вот здесь был не вектор,
[35:03.280 --> 35:10.280]  а какие-нибудь инты, то понятно, что да, ну, все в мапе работает за log n, потому что у меня всего в мапе будет максимум n элементов,
[35:10.280 --> 35:16.280]  значит, все запросы работают за логарифм, да, и поиск, и вставка, и извлечение значения работают за логарифм.
[35:16.280 --> 35:23.280]  Но теперь, поскольку у меня ключи – это не числа, а векторы, у меня еще какое-то время тратится на сравнение элементов.
[35:23.280 --> 35:28.280]  Ну, вот представьте, у нас есть какое-нибудь дерево, не знаю, там, АВ или красно-черный, или какое-нибудь.
[35:28.280 --> 35:34.280]  В корне лежит какой-то вектор, и вам нужно понять, куда идти. Вот есть какой-то корень, и вам пришел какой-то вектор А.
[35:34.280 --> 35:38.280]  Вам надо сравнить, кто из них больше, и пойти либо влево, либо вправо, ну, либо понять, что они одинаковы.
[35:38.280 --> 35:43.280]  Эта проверка выполняется вот за такое время, но не большим за такое, потому что есть два вектора.
[35:43.280 --> 35:48.280]  Как проверить, кто из них больше, кто меньше? Ну, вы просто так идете слева направо, охотите первое различие, да,
[35:48.280 --> 35:52.280]  если тут больше, то спускаете вправо, если тут больше, то спускаете влево.
[35:52.280 --> 35:57.280]  Это работает не большим длина вот этого массива, ну, и не большим длина вот этого.
[35:57.280 --> 36:02.280]  Давайте я выберу одну из этих оценок.
[36:02.280 --> 36:07.280]  То есть все сравнения работают максимум за длину А, где А – это текущий мой вектор.
[36:07.280 --> 36:10.280]  И таких сравнений будет логарифмическое количество.
[36:10.280 --> 36:21.280]  Значит, суммарно время работы есть сумма, большая сумма по всем нашим массивам А, аналог М.
[36:21.280 --> 36:25.280]  Ну, а сумму А мы уже оценили, мы сказали, что это от М.
[36:25.280 --> 36:32.280]  Потому что суммарно каждая вершина попадет в свой вектор А максимум один раз.
[36:32.280 --> 36:38.280]  Каждая вершина У попадет в вектор только один раз от того, когда В – это ее родитель.
[36:38.280 --> 36:41.280]  Тогда У является сыном В, и оно попадет в вектор А.
[36:41.280 --> 36:45.280]  Значит, это все линейное количество, ну и вот получили N log N.
[36:45.280 --> 36:49.280]  То есть у меня вот эта штука работает суммарно за N log N.
[36:49.280 --> 36:53.280]  И все операции с Мапой тоже работают суммарно за N log N, вот мы здесь это показали.
[36:53.280 --> 36:57.280]  Все остальное линейное. Ужбеки там всякие и так далее.
[36:57.280 --> 36:59.280]  Согласны?
[37:01.280 --> 37:03.280]  Вот, ну отлично.
[37:03.280 --> 37:07.280]  Вот так мы научились проверять корневые деревья на изоморхность.
[37:09.280 --> 37:12.280]  Дальше нужно сделать то же самое с некорневыми деревьями,
[37:12.280 --> 37:17.280]  то есть когда у нас нет вот этого вот однозначно заданной вершинки R1, R2.
[37:17.280 --> 37:21.280]  То есть здесь там как бы было просто, что мы знали, что R1 точно в R2 должно перейти,
[37:21.280 --> 37:25.280]  потому что это единственная вершина, в которой никто не входит.
[37:25.280 --> 37:28.280]  И это тоже единственная вершина, в которой нет входящих ребер.
[37:28.280 --> 37:30.280]  Они должны друг к другу перейти.
[37:30.280 --> 37:32.280]  А если это не так?
[37:32.280 --> 37:37.280]  Если у нас нет выделенных корней, то нужно их как-то сначала найти.
[37:37.280 --> 37:41.280]  Вот вопрос у меня к вам, знаете ли вы какие-нибудь такие вершины в дереве,
[37:41.280 --> 37:44.280]  которые почти однозначно определяются?
[37:44.280 --> 37:47.280]  Есть какая-нибудь такая характеристика, типа вершинная,
[37:47.280 --> 37:51.280]  что вот в любом дереве ровно одна такая-то вершина.
[37:51.280 --> 37:55.280]  Тогда если вот такая вершина ровно одна, то я могу за нее подвесить,
[37:55.280 --> 37:58.280]  и тут подвесить, и они должны быть одинаковыми.
[37:58.280 --> 38:02.280]  Да, можно и то, и то. Вы говорите про центроид, вы говорите про центроид.
[38:02.280 --> 38:04.280]  Можно взять и то, и то.
[38:08.280 --> 38:13.280]  Так, давайте, наверное, я про центроид, потому что с центром чуть дольше все доказывать,
[38:13.280 --> 38:15.280]  как там его искать и так далее.
[38:15.280 --> 38:20.280]  Второй этап – это проверка вершины.
[38:20.280 --> 38:23.280]  Значит определенные…
[38:25.280 --> 38:27.280]  …вершина называется центроидом.
[38:27.280 --> 38:29.280]  Вершина V называется центроидом дерева.
[38:29.280 --> 38:32.280]  E Jacobsiteço – это 2018哦не.
[38:32.280 --> 38:48.820]  Опять же ver.
[38:50.280 --> 39:03.280]  Если после ее удаления все компоненты связанности, оставшиеся, имеют размер максимум n пополам, то есть она такая, что ее удаление как бы разбивает граф на компоненты хотя бы два раза меньшего размера, чем исходный граф был.
[39:05.280 --> 39:07.280]  Пусть g дерево,
[39:10.280 --> 39:11.280]  n от числа вершин.
[39:16.280 --> 39:18.280]  Вершина v называется центроидом.
[39:20.280 --> 39:42.280]  А после ее удаления все компоненты имеют размер максимум n пополам.
[39:51.280 --> 39:53.280]  Какой-нибудь пример.
[40:00.280 --> 40:02.280]  Так, вот такое страшное дерево.
[40:02.280 --> 40:04.280]  Раз, два, три, четыре, пять, шесть, семь, восемь.
[40:05.280 --> 40:06.280]  Вершин.
[40:06.280 --> 40:08.280]  Ну и кажется, вот это вот центроид будет.
[40:08.280 --> 40:14.280]  Да, потому что после удаления этой вершинки у меня будет компоненты связанности размера три, размера один и размера три.
[40:14.280 --> 40:18.280]  Каждая из чисел не превосходит в четверки, значит это будет действительно центроид.
[40:18.280 --> 40:23.280]  И, видимо, других нету, потому что если, скажем, удалить вот эту, то будет 5 вершин.
[40:23.280 --> 40:24.280]  Вот здесь это слишком много.
[40:24.280 --> 40:28.280]  Но здесь то же самое нельзя удалить, потому что здесь будет 5, это будет много.
[40:28.280 --> 40:29.280]  Короче, здесь один центроид.
[40:31.280 --> 40:32.280]  Утверждение.
[40:34.280 --> 40:38.280]  В любом дереве центроид либо единствен, либо их ровно два, при этом они соединяются ребром.
[40:42.280 --> 40:43.280]  В любом дереве.
[40:43.280 --> 40:48.280]  В любом дереве либо центроид ровно один,
[40:51.280 --> 40:52.280]  центроид ровно один,
[40:54.280 --> 40:57.280]  либо их два, они соединяются ребром.
[41:13.280 --> 41:17.280]  Так, сначала давайте предъявим алгоритм поиска какого-нибудь центроида.
[41:18.280 --> 41:23.280]  Чтобы доказать, что их не больше, чем два, давайте докажем, что он хотя бы один.
[41:24.280 --> 41:25.280]  Алгоритм поиска центроида.
[41:29.280 --> 41:34.280]  Поиска произвольного центроида.
[41:35.280 --> 41:36.280]  Алгоритм следующий.
[41:36.280 --> 41:39.280]  Давайте мы подвесим наше дерево за произвольную вершинку,
[41:40.280 --> 41:41.280]  за произвольный корень R.
[41:42.280 --> 41:44.280]  И у каждого по дереву посчитаем размер.
[41:47.280 --> 41:49.280]  Для каждого по дереву посчитаем sub3 от V,
[41:50.280 --> 41:51.280]  sub3 от D,
[41:52.280 --> 41:53.280]  sub3 от V,
[41:54.280 --> 41:55.280]  sub3 от D,
[41:56.280 --> 41:57.280]  sub3 от D,
[41:58.280 --> 41:59.280]  sub3 от D,
[42:00.280 --> 42:01.280]  sub3 от D,
[42:02.280 --> 42:03.280]  sub3 от D,
[42:04.280 --> 42:12.400]  в это размер под дерево с корнем в размер под дерево
[42:12.400 --> 42:19.080]  в и тогда смотрите как можно искать центроид но мы знаем
[42:19.080 --> 42:23.400]  что саптриот r это n потому что под дереве корня есть
[42:23.400 --> 42:28.680]  все вершины как тогда выглядит центроид это такая вершина
[42:28.680 --> 42:30.560]  вот если мы ее удалим что останется останутся ее
[42:31.560 --> 42:32.840]  и останется нам дерева бы preguntила whole rates
[42:36.260 --> 42:42.360]  мне нужно чтобы здесь был небось чем пополам здесь здесь и вот здесь
[42:42.360 --> 42:54.500]  но то что в над дереве небось чем n пополам это тоже самое что в под дереве хотя бы m пополам
[42:54.500 --> 42:59.500]  То, что сверху не больше ни пополам, равносильно тому, что снизу хотя бы, наоборот, н пополам.
[42:59.500 --> 43:09.500]  Н минус н пополам, это н пополам. То есть мне нужно найти такую вершину С, что у нее САП3 это хотя бы н пополам, а у всех детей не больше ни пополам.
[43:09.500 --> 43:30.500]  Давайте это напишем. Ищем вершину С, такую, что САП3 вот С, САП3 вот С, больше с обравнованием пополам, а у всех детей, наоборот, меньше с обравнованием пополам.
[43:31.500 --> 43:41.500]  У всех детей С, наоборот, САП3 меньше с обравнованием пополам.
[43:41.500 --> 43:55.500]  Вот, ну, это, собственно, критерии того, что нас центроет, что после удаления во всех ее, ну, как бы, по деревьях снизу будет не больше н пополам вершин, а также сверху тоже не больше н пополам, потому что у нас снизу хотя бы н пополам.
[43:55.500 --> 44:08.500]  Тогда алгоритм будет такой. Давайте мы встанем в корень и будем идти вниз в ту вершину, пока она существует, в которой САП3 хотя бы н пополам.
[44:08.500 --> 44:13.500]  Вот мы встанем в R, видим, ага, у этой вершинки САП3 хотя бы н пополам. Ну, просто сюда перейдем.
[44:13.500 --> 44:19.500]  Потому что это условие точно выполняется. Давайте просто тогда будем искать, ну, самую глубокую вершину с таким свойством.
[44:19.500 --> 44:25.500]  Стоим здесь, видим, ага, вот опять есть вершина с САП3 хотя бы н пополам, перешли сюда, а здесь уже ни одного такого нету.
[44:25.500 --> 44:29.500]  То есть у вершинки В, скажем, все дети имеют размер меньше, чем н пополам.
[44:29.500 --> 44:35.500]  Тогда в этот центроет, потому что для него выполняется вот это, а для всех детей выполняется вот это.
[44:35.500 --> 44:47.500]  Алгоритм очень простой. Насчитали САП3, размеры под деревьев, а дальше просто идем от корня сверху вниз и спускаемся в произвольную вершину с САП3 хотя бы н пополам.
[44:47.500 --> 44:57.500]  Последний раз, когда мы это смогли сделать, это и есть наш центроет, потому что ниже все имеют размер меньше, мы пополам, значит спускаться ниже нельзя, и это есть тот самый центроет.
[45:03.500 --> 45:11.500]  Так, ну вот такой алгоритм, он конечно работает, конечно завершается, потому что мы не можем спускаться бесконечно долго, потому что для листиков точно вот это уже неверно.
[45:12.500 --> 45:23.500]  Вот это неверно для листиков, если там н хотя бы 3 видимо, если н хотя бы 3, то для листиков это неверно, значит наш алгоритм точно завершится на каком-то этапе.
[45:23.500 --> 45:28.500]  То есть он будет так идти-идти-идти, когда-то он завершится, и это собственно и будет наш центроет.
[45:28.500 --> 45:30.500]  Поэтому центроет всегда есть.
[45:42.500 --> 45:47.500]  Почему их не больше, чем два? Значит он всегда есть, он либо ровно один, либо их хотя бы два.
[45:47.500 --> 45:50.500]  Вот что делать, если их два? Ну давайте нарисуем какую-нибудь картинку.
[45:51.500 --> 45:54.500]  Предположим, что есть два центроида, которые не соединены ребром.
[45:57.500 --> 46:04.500]  Пусть есть два центроида, не соединенные ребром.
[46:04.500 --> 46:06.500]  Тогда давайте нарисуем путь между ними.
[46:07.500 --> 46:12.500]  Есть первый центроид, есть второй центроид, при этом на пути есть хоть что-то.
[46:12.500 --> 46:14.500]  Есть хотя бы одна промежуточная вершинка.
[46:15.500 --> 46:20.500]  Есть второй центроид, при этом на пути есть хоть что-то, есть хотя бы одна промежуточная вершинка.
[46:30.500 --> 46:32.500]  Ну тогда смотрите.
[46:36.500 --> 46:38.500]  Сейчас, секунду.
[46:44.500 --> 46:46.500]  Что-что?
[47:02.500 --> 47:06.500]  Да, да, я понял. Сейчас давайте попробуем сделать.
[47:07.500 --> 47:09.500]  Да, это хорошая идея, действительно.
[47:09.500 --> 47:13.500]  Давайте возьмем любую промежуточную пути и назначим ее корнем.
[47:13.500 --> 47:20.500]  Тогда смотрите, с одной стороны, поскольку после удаления C1 все распадается на компоненты максимума N пополам,
[47:20.500 --> 47:23.500]  то давайте нарисую, что остается после удаления C1.
[47:24.500 --> 47:28.500]  Есть какие-то компоненты вот такие, и есть соответственно все вот это вот.
[47:29.500 --> 47:35.500]  В частности, это имеет размер не больше N пополам, поэтому это все имеет размер хотя бы N пополам.
[47:35.500 --> 47:42.500]  Значит, если я подвешу за R, то sub3 вот C1 больше равно, чем N пополам.
[47:44.500 --> 47:49.500]  Потому что кроме нее есть вот это вот размер меньше равно, чем N пополам, поэтому вот это хотя бы N пополам.
[47:50.500 --> 47:53.500]  То же самое с C2. У него есть здесь какие-то деревья.
[47:54.500 --> 48:02.500]  После удаления C2 они все имеют размер максимума N пополам, но также вот это вот все, все что как бы левее вот этого C2,
[48:02.500 --> 48:04.500]  тоже имеет размер максимума N пополам.
[48:04.500 --> 48:10.500]  Значит, sub3 вот C2 имеет размер хотя бы N пополам.
[48:11.500 --> 48:16.500]  Ну и тогда у меня есть получается вот это вот хотя бы N пополам, вот это хотя бы N пополам,
[48:16.500 --> 48:20.500]  еще есть хотя бы один корень, поэтому в дереве больше N вершин противоречия.
[48:35.500 --> 48:40.500]  Ну все, мы получили, что центроидов максимум два и мы соответственно можем их легко находить,
[48:40.500 --> 48:46.500]  можно найти легко один ну и дальше там не знаю, можно проверить у всех соседей ну там дальше как угодно.
[48:46.500 --> 48:50.500]  Можно там либо этот алгоритм модифицировать так, чтобы находил оба центроида, а не только один.
[48:51.500 --> 48:55.500]  Ну потому что по сути у меня здесь критерий на центроиды, надо просто проверить для каждого шны выполняет это или нет,
[48:55.500 --> 48:59.500]  либо мы там находим один центроид какой-то, дальше перебираем всех его соседей
[48:59.500 --> 49:02.740]  всех его соседей, проверяем выполняется ли это свойство для соседей первого центроида.
[49:02.740 --> 49:04.740]  Тем самым найдем все центроиды.
[49:04.740 --> 49:06.740]  Так вот.
[49:12.740 --> 49:16.740]  Теперь, если мы умеем искать центроиды, если мы знаем, что их мало,
[49:16.740 --> 49:20.740]  то мы понимаем, что центроид одного дерева должен обязательно перейти в центроид другого,
[49:20.740 --> 49:22.740]  если мы ищем изоморфизм.
[49:22.740 --> 49:28.740]  Если мы ищем изоморфизм, то, ну там, понятное дело, просто перенумерация вершин,
[49:28.980 --> 49:30.980]  phrases must go to the centered one,
[49:31.980 --> 49:34.980]  let's just look at which center of the second tree this center of the first tree will go.
[49:46.980 --> 49:48.980]  there must give two confirmed centers,
[49:48.980 --> 49:50.980]  in this case, say C1 and C2.
[49:51.280 --> 49:54.060]  Let's look at islo- iso- on the iso- on the isomorphism difference
[49:54.060 --> 49:56.060]  between this center-new one and this center-new one C1.
[49:56.060 --> 50:03.260]  можно просто подвесить первое дерево за c, второе за c1, и проверить, что они изоморфаны как корневые деревья.
[50:03.260 --> 50:10.460]  Потому что если я фиксировал, что вот это переходит в это, то это то же самое, что если я их поднял в корень,
[50:10.460 --> 50:20.700]  подвесил, и тем самым фиксировал, что c переходит в c1. А все остальное у меня есть уже алгоритм проверки корневых
[50:20.700 --> 50:27.020]  деревьев на изоморфанность. Если не получилось, то значит пробуем c преобразовать в c2. То есть то же самое,
[50:27.020 --> 50:34.780]  подвесим первое дерево за c, второе за c2. Проверяем изоморфаны они или нет, как корневые деревья.
[50:34.780 --> 50:41.940]  Если хотя бы один раз получилось, значит деревья изоморфаны, и мы даже знаем, какой центрой куда отображается.
[50:41.940 --> 50:47.620]  Если ни разу не получилось, значит мы не смогли этот центрой никуда преобразовать, никуда отобразить,
[50:47.620 --> 50:53.300]  поэтому деревья не изоморфаны. То здесь получается поиск центроидов,
[50:53.300 --> 51:04.700]  поиск центроидов, плюс не больше чем два, не больше две проверки на изоморфанность ориентированных деревьев,
[51:04.700 --> 51:12.620]  не больше двух проверок на изоморфанность корневых деревьев.
[51:18.620 --> 51:22.620]  Ну это все по-прежнему NLGN.
[51:31.180 --> 51:42.180]  Вот такая прелесть. Получается, что в случае деревьев мы можем вот работать как с корневыми, так и с некорневыми,
[51:42.180 --> 51:47.060]  из-за, например, того, что вот центроидов всегда не очень много. Да, значит альтернативно можно вместо
[51:47.060 --> 51:52.060]  центроида брать так называемый центр, это середина диаметра. Диаметр, как вы сказали, самый длинный путь.
[51:52.060 --> 52:00.060]  Точнее, это среди всех возможных хорошейших расстояний самое длинное. То есть мы по всем парам вершинам считаем
[52:00.060 --> 52:07.060]  хорошейшее расстояние, находим среди всех пар максимальное такое, это будет диаметр. Самое большое минимальное расстояние, это диаметр.
[52:07.060 --> 52:11.060]  Дальше на этом диаметре там однозначно определяется центр, как середина диаметра.
[52:11.060 --> 52:24.060]  Ну если, если здесь там четное число ребер, то центр это просто середина. Если их там нечетное число ребер, то у нас есть два центра,
[52:24.060 --> 52:29.060]  собственно так же, как было с центроидами. Потому что центры тоже либо один, либо их два.
[52:29.060 --> 52:34.060]  И тогда то же самое, надо просто попробовать отобразить центр первого дерева в центр второго дерева,
[52:34.060 --> 52:42.060]  и проверить, что они заморщены как корневые деревья. Тут же самое, что нам важно лишь, что есть какая-то такая характеристика вершинная,
[52:42.060 --> 52:51.060]  что есть какая-то такая вершина в дереве, что их немного, один или две их, одна или две, и они, ну понятно дело, сохраняются после заморфизма.
[52:51.060 --> 52:58.060]  Потому что деревья как бы отличаются просто перенумерацией вершин, значит там свойство для вершин должно сохраняться, потому что оно не зависит от нумерации.
[52:58.060 --> 53:02.060]  Значит центр приходит в центр, центроид в центр, и так далее.
[53:02.060 --> 53:31.060]  Окей, так теперь поговорим про LCA, Lowest Common Ancestor.
[53:31.060 --> 53:36.060]  Ну и меньше общепредок.
[53:36.060 --> 53:53.060]  Тут опять картинка на изоморфном дереве, на корневом дереве. Дерево корневое, за что-то подвешенное.
[53:53.060 --> 54:05.060]  И есть какие-то две вершинки в нем У и В. Тогда LCA это их общепредок наименьше в том смысле, что он наиболее низко расположен.
[54:05.060 --> 54:10.060]  Вот если мы так подвесили, то он находится ниже всех остальных общих предков.
[54:10.060 --> 54:18.060]  То есть это такая вершина, которая является их общим предком, то есть от которой можно дойти до У и до В по ребрам сверху вниз.
[54:18.060 --> 54:23.060]  При этом среди всех таких она самая низкая.
[54:23.060 --> 54:33.060]  Ну собственно тут как бы название Self-Descriptive, что это общепредок, при этом наименьше в том смысле, что он как бы на максимальной глубине, ниже всех остальных находится.
[54:33.060 --> 54:42.060]  Зачем это нужно? Ну, например, за тем, что если у меня все-таки, я в общем так могу понимать, как выглядит путь между У и В.
[54:42.060 --> 54:54.060]  Вот если я подвешу запрозвольную вершинку R, и я научусь находить LCA двух вершин У и В, то я знаю, если дерево было неориентированным, я знаю, как выглядит путь от У до В.
[54:54.060 --> 55:05.060]  Нужно сначала от У дойти до LCA, потом от LCA до В. Путь обязательно устроен ровно так, потому что как-то же он устроен, и на этом пути обязательно присутствует вершина,
[55:05.060 --> 55:14.060]  то есть на этом пути можно выбрать вершину минимальной глубины, то есть расположены ближе всего к корню. Это будет собственно LCA, потому что идти вот так вот мы не будем, это уже будет путь непростой.
[55:14.060 --> 55:23.060]  То есть мы можем подняться до LCA, пойти куда-то наверх, и потом обратно спускаться вниз. Но это бред, да, потому что тогда путь будет непростой.
[55:23.060 --> 55:28.060]  Самый короткий путь, и собственно единственный простой путь, это подняться от У до LCA, и потом от LCA вниз.
[55:33.060 --> 55:35.060]  Ну как можно LCA находить?
[55:35.060 --> 55:51.060]  Так, давайте попробуем успеть два способа.
[55:51.060 --> 55:59.060]  Первый способ находения LCA. Первый – это двоечные подъемы.
[56:07.060 --> 56:17.060]  Во-первых, нужна будет такая митра процедура, которая вроде как была даже когда-то в контесте. По дереву проверить, что одна вершина – это предок другой.
[56:17.060 --> 56:31.060]  Пишется она очень просто. Проверка того, что одна вершина X является предком вершины Y. У них нужно сравнить T in и T out просто.
[56:31.060 --> 56:39.060]  Значит, мы должны были, чтобы X был предком Y, нужно чтобы мы вошли в X раньше, чем в Y, а вышли позже.
[56:49.060 --> 56:57.060]  Ну мы что-то делали такое, когда про DFS просто говорили, да, потому что когда мы обходим дерево DFS, мы у каждой вершинки там можем посчитать время входа, время выхода T in, T out.
[56:57.060 --> 57:07.060]  Мы знаем, что для любых двух вершин T in, T out они либо вложены как отрезки, либо не пересекаются.
[57:07.060 --> 57:17.060]  Любые два отрезка они либо вложены, либо не пересекаются. Так любой DFS работает, что если он зашел в вершину, потом какой-то другой дошел,
[57:17.060 --> 57:23.060]  то нам нужно сначала ее целиком войти, выйти из нее, и только потом можем дойти обратно и выйти из нее.
[57:23.060 --> 57:27.060]  Если мы вошли в одну, то мы сначала должны из нее выйти, потом выйти из исходной.
[57:27.060 --> 57:35.060]  А если мы вышли из первой, то есть не может быть такого, что я зашел в одну, вышел в второй и вышел в той самой одной.
[57:35.060 --> 57:38.060]  Они не могут пересекаться, могут быть только вложены.
[57:38.060 --> 57:44.060]  Значит, чтобы это проверить, надо просто проверить, что вот такая картинка, это вот Z с такими двумя нераненствами.
[57:45.060 --> 57:54.060]  Теперь с помощью этой процедуры и, собственно, двоичных подъемов мы найдем LCA.
[57:58.060 --> 58:00.060]  Что такое двоичные подъемы?
[58:01.060 --> 58:07.060]  Так, давайте назову их лифтс.
[58:09.060 --> 58:18.060]  Лифт для числа K и вершинки V это предок V поколений двафкатой.
[58:23.060 --> 58:29.060]  То есть где я окажусь, если из вершины V двафкатой раз поднимусь в родителя?
[58:30.060 --> 58:35.060]  Предок в первом поколении это родитель, предок во втором это дедушка, ну и так далее.
[58:35.060 --> 58:38.060]  Где я окажусь, если двафкатой раз возьму родителю?
[58:38.060 --> 58:40.060]  Считается очень просто.
[58:41.060 --> 58:50.060]  Лифтс нулевой V это просто parent от V, потому что это предок в поколении двафнулевой, то есть один.
[58:51.060 --> 59:07.060]  А дальше, если я знаю лифтс какой-то KT от V, пусть это будет U, то я знаю лифтс K плюс первое от V.
[59:09.060 --> 59:11.060]  Это нужно применить вот это вот самое к U.
[59:11.060 --> 59:25.060]  Лифтс KT U, потому что чтобы прыгнуть на двафкатой плюс один вверх, достаточно один раз прыгнуть на двафкатой, а потом еще раз на двафкатой.
[59:25.060 --> 59:34.060]  Картинка такая, что вот есть V, я сначала на двафкатой вверх прыгнул, попал в U, потом еще на двафкатой попал в предка на расстоянии двафкатой плюс один.
[59:34.060 --> 59:48.060]  Давайте договоримся, что если там нет предка с таким нормом, то есть если мы не можем прыгать так высоко, то скажем, где-то здесь находится корень, то мы считаем, что в корне у меня стоит петля,
[59:48.060 --> 59:52.060]  и я бесконечно в этом подкорне могу в корень подниматься сколько угодно раз.
[59:52.060 --> 59:56.060]  То есть тут не минус один, скажем, а именно указатель в корень.
[59:56.060 --> 01:00:01.060]  То есть если мы пытаемся пойти выше, то тут будет просто корень вместо несуществующей вершины.
[01:00:02.060 --> 01:00:06.060]  Вот тогда вот так очень просто насчитываются эти бинарные подъемы.
[01:00:10.060 --> 01:00:14.060]  Ну потому что понятно, что K не имеет смысла брать сильно больше, чем логарифм N.
[01:00:14.060 --> 01:00:21.060]  Если я вот здесь вместо K возьму лог N и буду искать предков по колене 2 в степени там больше, чем лог N, то это всегда будет просто корень, это бесполезно.
[01:00:21.060 --> 01:00:27.060]  Я пытаюсь подняться на что-то больше, чем глубина дерева заведомо, значит это будет всегда корень, это не интересно.
[01:00:27.060 --> 01:00:34.060]  Значит K достаточно брать типа там до логарифма, ну давайте напишу там лог N плюс 2, на всякий случай, чтобы с запасом было.
[01:00:34.060 --> 01:00:38.060]  Ну и W, все остальные вершины, в смысле просто все вершины.
[01:00:40.060 --> 01:00:50.060]  Теперь как искать LCA, если мы знаем вот эти две процедурки, то есть если у нас есть подъемы 2-ичные и есть процедура проверки на прерывочность.
[01:00:51.060 --> 01:00:55.060]  Ну я пишу так, есть две вершины У и В.
[01:01:01.060 --> 01:01:07.060]  Во-первых, если У это предок В, то У это ответ.
[01:01:12.060 --> 01:01:16.060]  Если одна вершина предок другой, то собственно это и есть тот самый их наименьший общий предок.
[01:01:16.060 --> 01:01:22.060]  Потому что выше прыгать бесполезно, а ниже нельзя, потому что тогда мы перестанем уйметь в качестве потомка.
[01:01:22.060 --> 01:01:24.060]  То есть картинка будет такая.
[01:01:26.060 --> 01:01:32.060]  Иначе я сделаю следующее, то есть теперь У это не предок В, и картинка какая-то такая.
[01:01:32.060 --> 01:01:34.060]  Ну я вот так вот нарисую.
[01:01:35.060 --> 01:01:43.060]  Я сейчас найду вот эту вот вершину, предпоследнюю на пути от У дольца, и потом возьму от нее один раз parent, это будет ответ.
[01:01:47.060 --> 01:01:51.060]  К от К max до нуля.
[01:01:55.060 --> 01:01:59.060]  Если, значит смотрите, я стою у и пытаюсь прыгнуть на 2 вкатый.
[01:01:59.060 --> 01:02:03.060]  Если я при этом не попадаю в предка В, то я делаю такой прыжок.
[01:02:03.060 --> 01:02:05.060]  Если попадаю, то я не делаю такой прыжок.
[01:02:05.060 --> 01:02:12.060]  То есть если этот прыжок оставляет меня вот на этом вот пути как бы, не выводит меня в предке В, тогда я делаю такой прыжок.
[01:02:12.060 --> 01:02:14.060]  Иначе не делаю.
[01:02:14.060 --> 01:02:29.060]  Если неверно, что консестра лифтс Кт Ут запятая В, тогда У равно лифтс Ку.
[01:02:33.060 --> 01:02:37.060]  Вот ну и в конце все просто return лифтс 0 от У.
[01:02:45.060 --> 01:02:49.060]  Да, давайте вот эту картинку побольше нарисую.
[01:02:49.060 --> 01:02:52.060]  Вот есть У где есть там В.
[01:02:52.060 --> 01:02:58.060]  Я хочу как бы подниматься вот по этому пути так, чтобы вот в Ильца не попасть.
[01:02:58.060 --> 01:03:05.060]  То есть вот это Ильца, есть там еще какие-то более высокие вершины, я хочу закончиться вот здесь, в шине Ильца со стороны У.
[01:03:05.060 --> 01:03:09.060]  Вот здесь хочу закончиться, тогда ответ это как раз родитель этой самой вершинки.
[01:03:10.060 --> 01:03:15.060]  Я вот так поднимаюсь ушкой вверх, пока вот тут не окажусь, тогда ответ это лифтс 0 У.
[01:03:15.060 --> 01:03:18.060]  Ну почему я окажусь действительно вот здесь?
[01:03:18.060 --> 01:03:21.060]  Ну за счет этой проверки неверно, что консестра.
[01:03:21.060 --> 01:03:25.060]  Я точно никогда не поднимусь вот сюда, выше того, где мне нужно.
[01:03:25.060 --> 01:03:27.060]  То есть я всегда нахожусь не выше, чем вот здесь.
[01:03:27.060 --> 01:03:31.060]  Ну и с другой стороны, я просто по сути, то есть мне нужно подняться от У на какую-то высоту.
[01:03:31.060 --> 01:03:36.060]  Я иду просто по всем степням двойки, от максимальной к минимальной.
[01:03:36.060 --> 01:03:40.060]  И каждую степень двойки, которая здесь встречается, я ее прыгаю.
[01:03:40.060 --> 01:03:44.060]  То есть по сути, я просто взял вот это число, равное расстоянию, которое мне нужно попрыгать,
[01:03:44.060 --> 01:03:51.060]  разложил вдовечную систему числения и от старших биток к матшам откусывал.
[01:03:51.060 --> 01:03:57.060]  Не знаю, если тут было там 10, то я сначала сделал прыжок на 8, потом на 2, я оказался вот здесь.
[01:03:57.060 --> 01:04:02.060]  Какая бы здесь ни была глубина изначально, я гарантированно по степням двойки просто пройдусь,
[01:04:02.060 --> 01:04:07.060]  и я окажусь в последней вершине, которая не является предком В.
[01:04:07.060 --> 01:04:11.060]  Потом надо будет взять просто предка, и это будет ответ.
[01:04:11.060 --> 01:04:16.060]  Вот. Это работает за логарифм.
[01:04:16.060 --> 01:04:22.060]  Потому что есть один цикл, где К пробегает логарифмом значений.
[01:04:22.060 --> 01:04:29.060]  Итого мы получили предпочет за НЛГН, вот он, и ответ на запросы за ЛГН.
[01:04:32.060 --> 01:04:35.060]  Ну, в принципе, не так нормально.
[01:04:41.060 --> 01:04:50.060]  Теперь второй метод будет чуть быстрее.
[01:04:50.060 --> 01:04:58.060]  Значит, это спортстейбл на эйлеровом обходе.
[01:05:03.060 --> 01:05:07.060]  С примера начну.
[01:05:16.060 --> 01:05:19.060]  Вот пусть есть такое дерево пронумерованное.
[01:05:19.060 --> 01:05:22.060]  Как выглядит эйлеров обход? Что такое эйлеров обход?
[01:05:22.060 --> 01:05:28.060]  Это, по сути, просто порядок посещения всех вершин в процессе ДФС.
[01:05:28.060 --> 01:05:32.060]  Вот я встал отначально в двойку, как-то там все вот так вот обошел,
[01:05:32.060 --> 01:05:35.060]  и каждый раз, когда я наступаю в вершинку, я ее печатаю.
[01:05:35.060 --> 01:05:36.060]  Что здесь будет?
[01:05:36.060 --> 01:05:41.060]  Значит, сначала я встал в корень, потом спустился в один, потом в шесть,
[01:05:41.060 --> 01:05:45.060]  потом в шести поднялся в один, в четыре, в один, в два,
[01:05:45.060 --> 01:05:47.060]  ну и дальше, собственно, вот здесь просто продолжаем.
[01:05:47.060 --> 01:05:56.060]  Тройка, семь пять семь, восемь семь, три два, три два.
[01:05:56.060 --> 01:06:00.060]  Короче, это вот прям, как если бы вы рукой обводили это дерево,
[01:06:00.060 --> 01:06:03.060]  в каком порядке вы все вершины вот так вот обведете?
[01:06:04.060 --> 01:06:07.060]  Сколько раз, собственно, вы около вершинки проводите,
[01:06:07.060 --> 01:06:10.060]  столько раз вы ее и выписываете. Это эйлеров обход.
[01:06:16.060 --> 01:06:18.060]  Значит, кодом это делается тоже очень просто.
[01:06:18.060 --> 01:06:21.060]  Вам нужно просто в ДФС, и каждый раз, когда вы спускаетесь в ребенка,
[01:06:21.060 --> 01:06:25.060]  печатать от самого ребенка, и, наоборот, когда из ребенка возвращаетесь в вершину,
[01:06:25.060 --> 01:06:27.060]  нужно печатать то, куда вы вернулись.
[01:06:27.060 --> 01:06:32.060]  Короче, каждый проход ребра нужно отразить печатанием до текущей вершины.
[01:06:33.060 --> 01:06:35.060]  Прошли по ребру, напечатали то, где вы находитесь,
[01:06:35.060 --> 01:06:39.060]  поднялись в рекурсии из вершины в предка,
[01:06:39.060 --> 01:06:42.060]  опять напечатали предка, потому что вы наступили в новую вершину.
[01:06:42.060 --> 01:06:44.060]  Вот так работает эйлеров обход.
[01:06:45.060 --> 01:06:52.060]  Ну а дальше замечание следующее, что давайте, наверное, мы уже не будем доказывать,
[01:06:52.060 --> 01:06:54.060]  потому что времени не очень много остается.
[01:06:54.060 --> 01:06:57.060]  Тут оно простые все утверждения.
[01:06:57.060 --> 01:06:59.060]  Значит, утверждение.
[01:07:03.060 --> 01:07:08.060]  Вершина с минимальной глубиной
[01:07:12.060 --> 01:07:14.060]  на отрезке
[01:07:16.060 --> 01:07:21.060]  между первыми вхождениями у и в
[01:07:22.060 --> 01:07:32.060]  это есть их лца.
[01:07:39.060 --> 01:07:41.060]  То есть, если нам нужно эти лца каких-то двух вершин,
[01:07:41.060 --> 01:07:43.060]  например, вот четверки, семерки,
[01:07:43.060 --> 01:07:45.060]  четверки, семерки,
[01:07:45.060 --> 01:07:48.060]  то я смотрю на их первые вхождения в этот наш эйлеров обход,
[01:07:48.060 --> 01:07:50.060]  вот четыре, вот семь.
[01:07:50.060 --> 01:07:53.060]  И на этом отрезке нахожу вершину минимальной глубины.
[01:07:53.060 --> 01:07:55.060]  Это будет двойка.
[01:07:57.060 --> 01:07:59.060]  Это их лца.
[01:07:59.060 --> 01:08:03.060]  Между четверкой и семеркой самый низкий предок это двойка, корень дерева.
[01:08:03.060 --> 01:08:07.060]  Если, например, взять там 5 и 8,
[01:08:07.060 --> 01:08:10.060]  вот первые вхождения пятерки, вот первые вхождения восьмерки,
[01:08:10.060 --> 01:08:14.060]  на этом отрезке минимальная глубина достигается вершины семь, это их лца.
[01:08:15.060 --> 01:08:17.060]  Интуитивно это понятно.
[01:08:17.060 --> 01:08:19.060]  Есть у вас две вершины у и в,
[01:08:19.060 --> 01:08:21.060]  а у вас обход эйлеров.
[01:08:21.060 --> 01:08:23.060]  Чтобы попасть из у в,
[01:08:23.060 --> 01:08:26.060]  что должно произойти, чтобы попасть отсюда-сюда?
[01:08:26.060 --> 01:08:29.060]  Вы сначала должны все это по дереву обойти,
[01:08:29.060 --> 01:08:32.060]  потом как-то подниматься, ходить, ходить, ходить,
[01:08:32.060 --> 01:08:34.060]  и рано или поздно прийти в в.
[01:08:34.060 --> 01:08:37.060]  Для этого вам нужно по сути весь путь от у до в пройти,
[01:08:37.060 --> 01:08:39.060]  значит, вам нужно побывать у лца.
[01:08:39.060 --> 01:08:41.060]  А в более высоких предках вы не побываете,
[01:08:41.060 --> 01:08:45.060]  потому что вы в них побываете только когда все это по дереву обойдет.
[01:08:45.060 --> 01:08:47.060]  Ну так, на пальцах.
[01:08:47.060 --> 01:08:51.060]  Действительно просто минимальная глубина на отрезки между вхождениями у и в,
[01:08:51.060 --> 01:08:54.060]  это есть лца этих самых вершин.
[01:08:54.060 --> 01:08:56.060]  Тут я написал первыми, на самом деле неважно,
[01:08:56.060 --> 01:08:58.060]  какими можно там любыми двумя вхождениями рассмотреть,
[01:08:58.060 --> 01:09:01.060]  потому что все равно, если у вас есть два вхождения у и в,
[01:09:01.060 --> 01:09:04.060]  то чтобы между ними как бы, чтобы из у попасть в в,
[01:09:04.060 --> 01:09:06.060]  вам нужно пройти весь этот путь.
[01:09:06.060 --> 01:09:10.060]  Вы же как-то проходите его, соответственно все вершины печатаете,
[01:09:10.060 --> 01:09:12.060]  обязательно на отрезки между этими вхождениями.
[01:09:14.060 --> 01:09:17.060]  Значит, по сути нам нужно просто взять
[01:09:17.060 --> 01:09:20.060]  и на отрезке вот этого массива найти минимум.
[01:09:21.060 --> 01:09:23.060]  Ну вот мы умеем это делать до вот единицы.
[01:09:25.060 --> 01:09:28.060]  То есть, ну, точнее как бы не на этом массиве, конечно,
[01:09:28.060 --> 01:09:31.060]  это массив вершин, скорее нужно создать пары,
[01:09:31.060 --> 01:09:33.060]  глубина, запятая вершина.
[01:09:33.060 --> 01:09:35.060]  И на этом массиве считать уже минимум.
[01:09:36.060 --> 01:09:39.060]  Тогда, ну, сейчас напишем короче.
[01:09:40.060 --> 01:09:46.060]  Значит, вот мы получили какой-то эллеров-обход, да, вот он.
[01:09:46.060 --> 01:09:49.060]  И дальше я, если у меня был набор вершин,
[01:09:49.060 --> 01:09:55.060]  то я пишу глубина вершины, глубина вершины и сама вершина.
[01:09:55.060 --> 01:09:57.060]  То есть я вот этот массив преобразую в массив пар.
[01:09:57.060 --> 01:10:00.060]  Дальше, ну, соответственно, пары сравниваю, как обычно,
[01:10:00.060 --> 01:10:02.060]  сначала по первому аргументу, потом по второму.
[01:10:02.060 --> 01:10:04.060]  И если мне нужно найти минимум на отрезке,
[01:10:04.060 --> 01:10:06.060]  точнее вершины минимальной глубины на отрезке,
[01:10:06.060 --> 01:10:09.060]  то я просто нахожу на отрезке минимум с помощью Sparse Table.
[01:10:09.060 --> 01:10:12.060]  Минимум у меня как раз минимизирует первые элементы пары,
[01:10:12.060 --> 01:10:14.060]  то есть мы находим вершины минимальной глубины,
[01:10:14.060 --> 01:10:16.060]  ну и соответственно не только ее, но и,
[01:10:16.060 --> 01:10:18.060]  не только глубину, но и саму вершину.
[01:10:19.060 --> 01:10:21.060]  Значит, строим Sparse Table.
[01:10:22.060 --> 01:10:24.060]  Sparse Table на массиве пар.
[01:10:28.060 --> 01:10:29.060]  Вот.
[01:10:29.060 --> 01:10:31.060]  Строится он, ну, предпочет за n log n.
[01:10:32.060 --> 01:10:33.060]  Вот.
[01:10:33.060 --> 01:10:35.060]  Строится он, ну, предпочет за n log n.
[01:10:35.060 --> 01:10:37.060]  Опять же.
[01:10:40.060 --> 01:10:42.060]  Предпочет за n log n.
[01:10:43.060 --> 01:10:45.060]  Зато запрос за единицу.
[01:10:47.060 --> 01:10:49.060]  Потому что запрос Sparse Table работает за вот единицу.
[01:10:56.060 --> 01:10:58.060]  Тут, кажется, все.
[01:11:01.060 --> 01:11:03.060]  Мне надо, конечно, вспомнить, как работает Sparse Table,
[01:11:03.060 --> 01:11:06.060]  что вот у меня есть какой-то массив статически не изменяющийся,
[01:11:06.060 --> 01:11:08.060]  здесь важно, что он как бы не меняется.
[01:11:08.060 --> 01:11:11.060]  Вот я как выписал его, структура дерева у меня никогда не меняется,
[01:11:11.060 --> 01:11:13.060]  поэтому этот массив всегда вот такой.
[01:11:13.060 --> 01:11:15.060]  Вот как он там был, так он, такой никогда не изменяется.
[01:11:15.060 --> 01:11:18.060]  Ну а дальше надо вспомнить, как работает Sparse Table,
[01:11:18.060 --> 01:11:21.060]  и что он на самом деле за единицу на каждый запрос встречает.
[01:11:21.060 --> 01:11:24.060]  Так, ну и, видимо, последнее, что успеем разобрать.
[01:11:25.060 --> 01:11:27.060]  Это тоже решение задачи Убальца.
[01:11:27.060 --> 01:11:31.060]  Это алгоритм парах Култона и Бендера.
[01:11:35.060 --> 01:11:36.060]  Вот.
[01:11:36.060 --> 01:11:37.060]  Вот.
[01:11:37.060 --> 01:11:38.060]  Вот.
[01:11:38.060 --> 01:11:39.060]  Вот.
[01:11:39.060 --> 01:11:40.060]  Вот.
[01:11:40.060 --> 01:11:41.060]  Вот.
[01:11:41.060 --> 01:11:42.060]  Вот.
[01:11:42.060 --> 01:11:43.060]  Вот.
[01:11:43.060 --> 01:11:44.060]  Вот.
[01:11:44.060 --> 01:11:45.060]  Вот.
[01:11:45.060 --> 01:11:46.060]  Вот.
[01:11:46.060 --> 01:11:47.060]  Вот.
[01:11:47.060 --> 01:11:48.060]  Вот.
[01:11:48.060 --> 01:11:55.060]  Парах Култона и Бендера.
[01:11:58.060 --> 01:12:02.060]  Это прям вообще максимально наилучший, возможно, алгоритм,
[01:12:02.060 --> 01:12:06.060]  потому что у нас будет предпочет за ООН и ответный запрос за единицу.
[01:12:07.060 --> 01:12:09.060]  Ну понятно, что быстрее, чем ООН, нельзя предпочитать,
[01:12:09.060 --> 01:12:12.060]  потому что нужно дерево хотя бы прочитать, вот,
[01:12:12.060 --> 01:12:14.060]  ну и отвечать на запрос быстрее, чем за единицу тоже нельзя,
[01:12:15.060 --> 01:12:17.060]  потому что надо хотя бы вывести ответ.
[01:12:17.060 --> 01:12:21.260]  Поэтому это вот прям оптимум и шикарно.
[01:12:21.260 --> 01:12:24.020]  Как это работает?
[01:12:24.020 --> 01:12:26.380]  Ну смотрите, мы по-прежнему строим Эйлеров обход.
[01:12:26.380 --> 01:12:30.180]  Да.
[01:12:30.180 --> 01:12:37.900]  И замечаем, что в нем соседние вершины имеют глубины и
[01:12:37.900 --> 01:12:42.540]  отличаются ровно на один.
[01:12:42.540 --> 01:12:53.140]  Глубины соседей отличаются ровно на единицу, потому
[01:12:53.140 --> 01:12:55.580]  что это вершины соединённых ребров, значит у них глубины
[01:12:55.580 --> 01:12:56.580]  на один отличаются.
[01:12:56.580 --> 01:12:58.700]  Плюс или минус один.
[01:12:58.700 --> 01:13:07.700]  Так, давайте я скажу, пусть n это длина этого обхода,
[01:13:07.820 --> 01:13:09.540]  пусть n это длина обхода.
[01:13:09.540 --> 01:13:16.940]  Ну понятно, что если n маленькое число вершин, то n это примерно
[01:13:16.940 --> 01:13:21.500]  2n.
[01:13:21.500 --> 01:13:23.700]  Потому что каждый ребро мы проходим два раза сверху
[01:13:23.700 --> 01:13:29.180]  внизу и снизу вверх, поэтому число печатаний будет в
[01:13:29.180 --> 01:13:31.740]  два раза больше чем число ребер примерно.
[01:13:31.740 --> 01:13:35.940]  Поэтому n примерно 2n.
[01:13:35.940 --> 01:13:38.340]  Так вот, как у меня теперь выглядит задача.
[01:13:38.340 --> 01:13:41.980]  Есть вот такой массив длины n из вот тех вот пар, глубина
[01:13:41.980 --> 01:13:42.980]  запятая вершина.
[01:13:42.980 --> 01:13:46.340]  И при этом глубины соседей отличаются на плюс-минус
[01:13:46.340 --> 01:13:47.340]  один.
[01:13:47.340 --> 01:13:52.260]  Тогда мы сделаем следующее, значит мы разобьём наш массив
[01:13:52.260 --> 01:14:01.500]  на блоке длины k, где k это 1 вторая двоичная логарифма
[01:14:01.500 --> 01:14:11.500]  n большой, 1 вторая лог 2n.
[01:14:11.500 --> 01:14:14.300]  Чем хорошо это число?
[01:14:14.300 --> 01:14:16.140]  Ну давайте скажем определение.
[01:14:16.140 --> 01:14:23.140]  То есть вот я разбил на такие блоки длины k, определение,
[01:14:23.140 --> 01:14:26.660]  значит блок длины k называется нормализованным, если в
[01:14:26.700 --> 01:14:32.860]  нём первое число равно нулю.
[01:14:32.860 --> 01:14:40.040]  Блок длины k нормализованный, если первое число в нём
[01:14:40.040 --> 01:14:41.040]  равно нулю.
[01:14:41.040 --> 01:14:51.840]  То есть если здесь первый элемент пара это нуль.
[01:14:51.840 --> 01:15:06.280]  Значит нормализованные блоки, они в каком-то смысле
[01:15:06.280 --> 01:15:08.520]  описывают вообще все возможные блоки, потому что любой блок
[01:15:08.520 --> 01:15:14.240]  это вам нужно знать, какой элемент первый вот здесь,
[01:15:14.240 --> 01:15:15.240]  не знаю, там х.
[01:15:15.240 --> 01:15:18.840]  А также вам нужно знать список изменений плюс-минус
[01:15:18.840 --> 01:15:19.840]  1.
[01:15:19.840 --> 01:15:22.240]  То есть если вы знаете первый элемент и знаете там разность
[01:15:22.240 --> 01:15:25.640]  между первыми двумя, скажем здесь плюс 1, дальше минус
[01:15:25.640 --> 01:15:28.520]  1, минус не знаю, то есть вы знаете как отличается
[01:15:28.520 --> 01:15:31.000]  каждый следующий от предыдущего, это либо плюс 1 либо минус
[01:15:31.000 --> 01:15:32.000]  1.
[01:15:32.000 --> 01:15:37.000]  И тогда если вы знаете ещё, если вы знаете ещё и первый
[01:15:37.000 --> 01:15:39.500]  элемент, то вы знаете целиком весь блок, то есть вам нужно
[01:15:39.500 --> 01:15:43.200]  знать только следующий х, первый элемент, и последовательность
[01:15:43.200 --> 01:15:45.720]  плюс-минус единичек, как меняется следующий элемент
[01:15:45.720 --> 01:15:46.720]  по сравнению с предыдущим.
[01:15:46.720 --> 01:15:49.600]  Ну х понятно одно число, а вот эта последовательность
[01:15:49.600 --> 01:15:51.560]  это по сути просто какой-то нормализованный блок.
[01:15:51.560 --> 01:15:53.880]  Что если я х вычислю из всех элементов, то у меня получится
[01:15:53.880 --> 01:15:57.600]  та же самая последовательность из плюс-минус 1, и она будет
[01:15:57.600 --> 01:15:59.280]  равна какому-то нормализованному блоку.
[01:16:00.280 --> 01:16:07.560]  Значит так вот, любой блок, после вычитания первого
[01:16:07.560 --> 01:16:21.280]  элемента из всех его элементов, становится нормализованным.
[01:16:29.280 --> 01:16:44.780]  Но зато нормализованных блоков, их всего два в степеника
[01:16:44.780 --> 01:16:55.080]  минус 1, всего существует два в степеника минус 1 нормализованных
[01:16:55.080 --> 01:16:56.080]  блоков.
[01:16:57.080 --> 01:17:00.760]  Потому что мы знаем длину к, мы знаем, что первое число
[01:17:00.760 --> 01:17:03.640]  это 0, а каждое следующее отличается от предыдущего
[01:17:03.640 --> 01:17:06.000]  либо на плюс 1, либо на минус 1.
[01:17:06.000 --> 01:17:08.560]  Поэтому, как я уже сказал, любой блок такой нормализованной
[01:17:08.560 --> 01:17:11.820]  задается последовательностью из вот такого количества
[01:17:11.820 --> 01:17:12.820]  плюс-минус единиц.
[01:17:12.820 --> 01:17:14.320]  Значит блоков всего вот столько.
[01:17:14.320 --> 01:17:19.680]  Это с точки зрения симптотики корень н большое.
[01:17:19.680 --> 01:17:23.480]  Но если мы двойку возведем в степень ту самую половину
[01:17:23.480 --> 01:17:26.680]  алгоритма, то у нас останется n в степени половинка, то
[01:17:26.680 --> 01:17:29.680]  есть корень изо.
[01:17:29.680 --> 01:17:33.960]  Окей, разных нормализованных блоков мало, а каждый нормальный
[01:17:33.960 --> 01:17:36.760]  блок задается как бы номером нормализованного блока
[01:17:36.760 --> 01:17:39.600]  и вот этим своим первым элементом х, который я
[01:17:39.600 --> 01:17:41.400]  выщел из всех элементов, чтобы получить нормализованный
[01:17:41.400 --> 01:17:44.400]  блок.
[01:17:44.400 --> 01:17:45.880]  Тогда алгоритм будет следующий.
[01:17:45.880 --> 01:17:52.400]  Значит сначала мы для каждого возможного вообще существующего
[01:17:52.400 --> 01:17:56.360]  в природе нормализованного блока, коих вот столько,
[01:17:56.360 --> 01:17:58.520]  посчитаем минимумы на всех подотресках.
[01:17:58.520 --> 01:18:03.080]  Вот есть у меня такой нормализованный блок длины k, я для всех его
[01:18:03.080 --> 01:18:05.440]  подотресков найду минимум на этом отрезке.
[01:18:05.440 --> 01:18:09.040]  Ну это делается очень просто, ну не знаю там, тупым перебором.
[01:18:09.040 --> 01:18:12.000]  У меня всего k квадрат подотресков в нем, давайте я заведу там
[01:18:12.000 --> 01:18:14.240]  огромный массив, который будет все это хранить.
[01:18:14.240 --> 01:18:18.160]  У меня будет массив размера корень изо небольшое на
[01:18:18.160 --> 01:18:20.960]  k квадрат, то есть на лог n квадрат, на лог квадрат
[01:18:20.960 --> 01:18:21.960]  n.
[01:18:21.960 --> 01:18:25.960]  Да, мне нужно знать номер нормализованного блока,
[01:18:25.960 --> 01:18:28.880]  как вот эта последовательность, плюс-минус один, надо знать
[01:18:28.880 --> 01:18:31.600]  начало отрезка и конец отрезка lr.
[01:18:31.600 --> 01:18:34.680]  Всего их будет вот столько, считается за такое же время.
[01:18:34.680 --> 01:18:38.520]  Если мы заведем такого размера и для каждого l будем
[01:18:38.520 --> 01:18:43.040]  просто хранить список, для каждого r минимум, то для
[01:18:43.040 --> 01:18:45.520]  фиксированного l я могу насчитать список минимумов
[01:18:45.560 --> 01:18:48.480]  вот здесь, вот за линейное время от длины оставшего
[01:18:48.480 --> 01:18:49.480]  массива.
[01:18:49.480 --> 01:18:53.360]  И соответственно весь этот массив я могу заполнить
[01:18:53.360 --> 01:18:54.360]  за его размер.
[01:18:54.360 --> 01:19:00.000]  То есть это время, давайте напишем, что от корни z
[01:19:00.000 --> 01:19:14.520]  на лог квадрат, можем найти минимумы на всех подотресках
[01:19:14.520 --> 01:19:16.520]  всех существующих нормализованных блоков.
[01:19:16.520 --> 01:19:29.800]  В смысле, вообще всех нормализованных блоков.
[01:19:29.800 --> 01:19:40.720]  Ну и тогда дальше, чтобы ответить на запрос исходной
[01:19:40.720 --> 01:19:45.060]  массив, вот есть у меня исходный массив, разбитый
[01:19:45.060 --> 01:19:47.420]  как-то на блоке длины к.
[01:19:47.420 --> 01:19:49.420]  Как найти минимум на отрезке?
[01:19:49.920 --> 01:19:51.420]  Вот на каком-то таком отрезке.
[01:19:51.420 --> 01:19:54.480]  Мне нужно найти минимум вот здесь, ну это я могу
[01:19:54.480 --> 01:19:57.280]  сделать, потому что это какой-то подотрезок нормализованного
[01:19:57.280 --> 01:19:59.020]  блока, для которого я знаю ответ.
[01:19:59.020 --> 01:20:02.280]  Мне нужно найти минимум вот здесь, ну это тоже знаю
[01:20:02.280 --> 01:20:04.160]  потому, что это подотрезок нормализованного блока,
[01:20:04.160 --> 01:20:07.760]  и найти минимум вот здесь, а это несколько подҐдиующих
[01:20:07.760 --> 01:20:12.720]  блоков, на которых я построю спарстейбл. То есть первое, что мне нужно, это вот
[01:20:12.720 --> 01:20:17.520]  это вот, давайте я пронумеру, что это будет пункт А. Минимумы на всех под отрезках
[01:20:17.520 --> 01:20:23.000]  всех нормализованных блоков. Пункт Б это спарстейбл
[01:20:24.320 --> 01:20:32.000]  на всех блоках исходного массива. На всех n поделить на k блоках
[01:20:32.000 --> 01:20:34.680]  исходного массива.
[01:20:37.800 --> 01:20:47.280]  Ну, где вместо блока мы записываем минимум в этом блоке. Где вместо блока
[01:20:48.160 --> 01:20:53.720]  записываем минимум в этом блоке.
[01:20:58.280 --> 01:21:02.400]  И тогда действительно, чтобы найти минимум на отрезке, мне нужно найти минимум на
[01:21:02.960 --> 01:21:07.780]  куске нормализованного блока. Ну, то есть обычного блока. Но я знаю, как он
[01:21:07.780 --> 01:21:10.900]  отличается от нормализованного. Он отличается в вычитании вот этого первого
[01:21:10.900 --> 01:21:15.580]  элемента, с прибавлениями х ко всему формализованному posible. То есть я
[01:21:15.580 --> 01:21:20.700]  беру номер этого блока, смотрю вот этой табличке, которой я предпочитал, минимум
[01:21:20.700 --> 01:21:24.560]  на этом отрезке, добавляю к нему х. Это будет, собственно, на этом отрезке. То
[01:21:24.560 --> 01:21:28.440]  же самое здесь. Я знаю, какой номер у этого нормализован clicked блока. и он
[01:21:28.440 --> 01:21:33.120]  отличаться от него на y, первый элемент y. Я смотрю в этой большой таблице, чему равен
[01:21:33.120 --> 01:21:39.320]  минимум на этом отрезке, проверяю y, получаю минимум здесь. Ну и наконец вот тут вот нужно
[01:21:39.320 --> 01:21:45.720]  просто обратиться к sparse table для последовательности из нескольких подряд идущих блоков.
[01:21:45.720 --> 01:21:53.520]  На отрезке блоков нужно найти минимум, это делается с sparse table. Причем sparse table строится
[01:21:53.520 --> 01:22:02.280]  за вот такое время. nk логарифм n делить на k. Если мы вместо k поставим половину логарифма,
[01:22:02.280 --> 01:22:10.080]  то получим o от n. Давайте я логарифм отношения напишу как разность логарифмов.
[01:22:10.080 --> 01:22:27.080]  k это логан по порядку. Тут написано o от n минус еще что-то. Главное слагаем будет o от n.
[01:22:27.080 --> 01:22:37.240]  Ну все, sparse table это строится за линию, минимум на отрезке извлекается за единицу. И на этих
[01:22:37.480 --> 01:22:42.720]  маленьких кусочках тоже минимум извлекается за единицу, потому что это обращение к уже подсчитанному,
[01:22:42.720 --> 01:22:50.040]  к уже подсчитанной табличке вот такого размера. Все, получается что ответный запрос за единицу.
[01:22:50.040 --> 01:23:03.440]  Вопросы. Окей, тогда действительно получили предпочет за o от n, потому что вот здесь вот будет
[01:23:03.440 --> 01:23:07.280]  o от n здесь будет вот это, но это понятное дело меньше чем o от n, здесь будет корень на что-то
[01:23:07.280 --> 01:23:15.400]  несущественное. Это будет меньше чем o от n. Запрос за единицу. Все это есть алгоритм Фарах Колтона и Бендера.
[01:23:15.400 --> 01:23:18.080]  Ну тогда спасибо, до встречи на экзамене.
