[00:00.000 --> 00:08.040]  Начнем. Напомню, о чем мы говорили в прошлый раз, какую
[00:08.040 --> 00:10.600]  проблему пытались решить. В прошлый раз мы с вами говорили
[00:10.600 --> 00:14.040]  про шаблоны с переменом числом аргументов, то есть
[00:14.040 --> 00:17.540]  это шаблонные функции примерно такого вида. Пишем
[00:17.540 --> 00:22.680]  pamplet, дальше class, ну или на самом деле тут, я не упомянул,
[00:22.680 --> 00:26.840]  но я думаю, как и для обычных шаблонов понятно, что вместо
[00:26.840 --> 00:30.080]  слова класс можно писать слово typeName, дальше многоточие,
[00:30.080 --> 00:33.520]  ну и дальше называем как-то сущность, которая у нас
[00:33.520 --> 00:37.200]  именует пакет параметров типов, то есть, собственно,
[00:37.200 --> 00:41.320]  все типы, которые будут выведены при передаче аргумента
[00:41.320 --> 00:44.440]  в функцию, они будут находиться здесь. Ну и дальше, собственно,
[00:44.440 --> 00:48.440]  мы пишем обычную шаблонную функцию, вот, не знаю, она
[00:48.440 --> 00:52.160]  может принимать какой-нибудь int x, допустим, но потом, как
[00:52.160 --> 01:01.000]  правило, в конце идет пакет параметров аргументов
[01:01.000 --> 01:03.520]  функции, который тоже может принимать произвольное
[01:03.520 --> 01:06.720]  количество параметров, которые вычисляются на этапе компиляции,
[01:06.720 --> 01:08.840]  то есть на этапе компиляции подставляются все конкретные
[01:08.840 --> 01:13.920]  типы и сюда подставляются конкретные значения. Ну и,
[01:13.920 --> 01:15.520]  собственно, мы с вами поговорили про несколько способов
[01:15.520 --> 01:19.160]  работы с такими шаблонными функциями, то есть первый
[01:19.240 --> 01:23.200]  способ, собственно, просто передача пакета в дальнейшую
[01:23.200 --> 01:25.800]  функцию, то есть, если у вас есть какая-то уже функция,
[01:25.800 --> 01:27.440]  которая может принимать произвольное количество
[01:27.440 --> 01:29.640]  параметров, то я, соответственно, могу распаковать пакет,
[01:29.640 --> 01:32.920]  например, внутри этой функции, могу передать какую-нибудь
[01:32.920 --> 01:38.200]  функцию g, аркс, многоточие, и тогда все эти параметры,
[01:38.200 --> 01:41.880]  они передадутся в функцию g. Ну, могу на них навесить
[01:41.880 --> 01:43.880]  какую-нибудь функцию, ну, не знаю, например, допустим,
[01:43.880 --> 01:46.160]  я знаю, что все вот эти аргументы являются указателями,
[01:46.160 --> 01:50.480]  я просто могу написать звездочка аркс, многоточие,
[01:50.480 --> 01:52.400]  и тогда каждый аргумент будет передан в функцию g
[01:52.400 --> 01:55.440]  предварительно, ну, предварительно перед тем, как передать
[01:55.440 --> 01:58.320]  функцию g, эти параметры будут разыменованы, точнее,
[01:58.320 --> 02:02.520]  эти аргументы будут разыменованы. Дальше, второй способ,
[02:02.520 --> 02:04.160]  который мы с вами рассмотрели, это метод откусывания,
[02:04.160 --> 02:06.360]  да, ну, или метод рекурсии, то есть метод заключается
[02:06.360 --> 02:08.760]  в том, что мы на самом деле передаем функцию не целый
[02:08.760 --> 02:12.520]  пакет параметров, да, какой-то вот шаблонный, шаблонный
[02:12.520 --> 02:15.080]  отдельный параметр head, условно его назовем, вот, ну,
[02:15.080 --> 02:17.160]  и дальше все остальное, да, ну, и дальше сводим задачу,
[02:17.160 --> 02:21.560]  сводим нашу задачу к какой-то работе над аргументом head
[02:21.560 --> 02:23.480]  и в дальнейшем передаем в ту же самую функцию,
[02:23.480 --> 02:26.360]  в дальнейшем, ну, соответственно, хвост, да, ну, и главное тут
[02:26.360 --> 02:28.280]  не забыть прописать конец рекурсии, да, то есть написать,
[02:28.280 --> 02:32.120]  как должна вести себя функция f, когда ей передают один
[02:32.120 --> 02:33.920]  аргумент или как должна вести себя функция f, когда ей
[02:33.920 --> 02:36.760]  передают ноль аргументов, вот. Ну, и наконец, третий
[02:36.760 --> 02:40.520]  способ, это fold expression, собственно, это выражение
[02:40.520 --> 02:49.000]  такого вида, args, операция, многоточие, ну, или многоточие,
[02:49.000 --> 02:53.080]  операция, args, ну, и тоже аналогичное синтаксе с инициализацией,
[02:53.080 --> 02:55.560]  да, то есть это какое-то начальное значение, то я могу написать
[02:55.560 --> 03:03.480]  init op многоточие op args, вот, ну, и аналогично могу написать
[03:03.560 --> 03:15.160]  многоточие args op многоточие op init, вот. Ну, соответственно,
[03:15.160 --> 03:17.960]  таким способом я могу, то есть если мне нужно применить
[03:17.960 --> 03:20.280]  операцию как всем аргументам пакета, я могу применить
[03:20.280 --> 03:23.480]  ее точно таким же образом, вот, ну, и естественно, каждому
[03:23.480 --> 03:25.400]  аргументу можно предварительно применить какую-то функцию,
[03:25.400 --> 03:27.960]  да, или какую-то операцию, вот, эти примеры мы с вами
[03:27.960 --> 03:32.120]  рассматривали. А вот, что хотелось бы еще дополнить
[03:32.440 --> 03:35.400]  к предыдущему разговору, ну, после лекции возникали
[03:35.400 --> 03:37.960]  всякие вопросы, ну, и с этим хотелось бы упомянуть
[03:37.960 --> 03:42.440]  еще один момент, который связан вот с чем, как еще
[03:42.440 --> 03:45.880]  можно применять пакеты параметров. Пакеты параметров
[03:45.880 --> 03:47.480]  на самом деле еще можно распаковывать во всякие
[03:47.480 --> 03:50.200]  сущности, которые, скажем так, которые являются
[03:50.200 --> 03:52.760]  инициализаторами для вещей, которые доступны на этапе
[03:52.760 --> 03:54.920]  компиляции. Ну, например, да, то есть мы с вами знаем,
[03:54.920 --> 03:59.880]  что чтобы завести массив int a, я могу написать что-то
[03:59.880 --> 04:04.280]  подобие такого, x, y, z, ну и так далее. Да, то есть,
[04:04.280 --> 04:06.120]  как бы, если вот количество элементов, которые я тут
[04:06.120 --> 04:08.360]  указываю, оно известный этап компиляции, то, соответственно,
[04:08.360 --> 04:11.160]  я этими штуками могу проинциализировать массив. Да,
[04:11.160 --> 04:13.160]  но то же самое касается стд array, то есть мы можем
[04:13.160 --> 04:19.320]  написать, допустим, std array, вот, ну, указать там количество
[04:19.320 --> 04:22.120]  элементов, допустим, 10 int, ну и, соответственно, дальше
[04:22.120 --> 04:25.320]  фигурный скобка, так, неправильно, вот, треугольный
[04:25.320 --> 04:28.200]  скобка здесь, дальше a, ну и фигурный скобка указать
[04:28.360 --> 04:31.400]  элементы, которыми я должен заполнить мой массив. Вот,
[04:31.400 --> 04:33.800]  с шаблонными параметрами, точнее, с шаблонными пакетами
[04:33.800 --> 04:36.200]  это работает точно так же, то есть я могу, например,
[04:36.200 --> 04:41.320]  написать так int a квадратные скобки, ну или там могу
[04:41.320 --> 04:49.080]  в квадратном скобке написать size of многоточие от args, вот,
[04:49.080 --> 04:51.400]  ну и дальше фигурный скобок указать распакованный
[04:51.400 --> 04:54.840]  пакет параметров args многоточие закрывающей фигурная скобка,
[04:54.840 --> 04:56.680]  вот. Это приведет к тому, что, ну, собственно, будет
[04:56.680 --> 05:00.600]  записан args 0, args 1, args 2 и так далее, ну и соответствующие
[05:00.600 --> 05:04.680]  элементы массива будут заполнены элементами args, вот.
[05:04.680 --> 05:06.920]  В частности, таким способом можно, например, реализовать,
[05:06.920 --> 05:11.080]  вот, кстати, да, вот после лекции подходили с вопросом,
[05:11.080 --> 05:14.040]  то есть можно ли таким же образом реализовать шаблонную
[05:14.040 --> 05:16.520]  функцию minimum, да, которая принимает произвольное
[05:16.520 --> 05:19.560]  количество параметров, вот, ну и, соответственно,
[05:19.560 --> 05:21.960]  можно таким образом вычислить, ну, ответственно, можно,
[05:21.960 --> 05:25.400]  да, то есть можно воспользоваться методом откусывания, вот,
[05:25.480 --> 05:27.160]  то есть откусывать по одному аргументу, да, ну, соответственно,
[05:27.160 --> 05:29.480]  взять минимум из вот этого аргумента и всего остального,
[05:29.480 --> 05:32.440]  вот. Можно поступить, ну, а можно поступить вот так,
[05:32.440 --> 05:36.120]  да, то есть взять и распаковать все в массив, ну, тут, правда,
[05:36.120 --> 05:38.680]  есть, в общем, есть несколько проблем, давайте, вот, допустим,
[05:38.680 --> 05:49.400]  я пишу std array a, ну, и заполняю его элементами args, вот.
[05:49.400 --> 05:53.240]  Ну, а дальше, собственно, в обычном цикле, ну, просто,
[05:53.480 --> 05:57.320]  в цикле ищу, ищу минимум в самом массиве, вот. В чем тут
[05:57.320 --> 05:59.960]  потенциальные проблемы? Потенциальные проблемы здесь
[05:59.960 --> 06:03.960]  заключаются в том, что, ну, во-первых, array, да, он, в общем,
[06:03.960 --> 06:07.720]  array, как и vector, как и остальные, как и остальные типы, они умеют
[06:07.720 --> 06:10.200]  догадываться о том, какие параметры у них должны быть
[06:10.200 --> 06:13.480]  в качестве шаблонов, ну, вот, да, вот, в общем, параметр
[06:13.480 --> 06:15.800]  типа, который в нем хранится, параметр количества
[06:15.800 --> 06:17.320]  элементов, который в нем хранится, в общем, они могут
[06:17.320 --> 06:20.200]  вводить это исходя из инициализации, вот, про это
[06:20.200 --> 06:22.760]  мы поговорим на одном из следующих занятий, вот.
[06:22.840 --> 06:25.400]  Поэтому тут важно понимать, что вот эта штука сработает
[06:25.400 --> 06:27.880]  только в случае, если вы, только в случае, если все
[06:27.880 --> 06:29.720]  вот эти аргументы имеют один и тот же тип, да, то есть
[06:29.720 --> 06:32.040]  если вы тут передали, допустим, все int или там все
[06:32.040 --> 06:34.040]  даблы, все флоты, то, соответственно, array выведется
[06:34.040 --> 06:36.840]  как массив int или массив флотов, и все будет окей, вот.
[06:36.840 --> 06:38.760]  Если тут будут находиться элементы разных типов, то
[06:38.760 --> 06:41.640]  тогда, соответственно, вам, ну, в общем, компилятор скажет,
[06:41.640 --> 06:44.920]  что, что ничего не работает. Ну, в общем, на самом деле,
[06:44.920 --> 06:46.520]  все работает так же, как и с обычным минимумом, да, то
[06:46.520 --> 06:48.600]  есть, не знаю, вы обращали внимание или нет, но если
[06:48.600 --> 06:54.760]  вы напишите просто std min от 1, допустим, и 0.0, то вот
[06:54.760 --> 06:57.080]  эта штука не скомпилируется, почему? Потому что min ожидает
[06:57.080 --> 06:59.240]  два аргумента одного и того же типа, вот. Если вы
[06:59.240 --> 07:01.240]  min'у передадите два аргумента разных типов, то просто
[07:01.240 --> 07:03.000]  он откажется компилировать, он скажет, типа, приведите
[07:03.000 --> 07:05.400]  один из аргументов, ну, к тому типу, который вам
[07:05.400 --> 07:08.200]  нужно, вот. И здесь будет то же самое, то есть, если
[07:08.200 --> 07:10.680]  у вас в варксах будет, допустим, int, int, int, а потом
[07:10.680 --> 07:12.680]  double, вот, соответственно, он скажет, что, ну, я не
[07:12.680 --> 07:14.840]  знаю, какого типа нужно array создать, поэтому минимум
[07:15.640 --> 07:22.040]  вызван просто-напросто не будет такой. Вот. А да, ну и
[07:22.040 --> 07:24.040]  вторая проблема. Вторая проблема заключается в том, что,
[07:24.040 --> 07:26.040]  к сожалению, тут, ну, понятное дело, что когда я создаю
[07:26.040 --> 07:28.040]  массив, мне все вот эти аргументы функций придется
[07:28.040 --> 07:30.040]  копировать массив, вот. То есть, тут еще будет
[07:30.040 --> 07:32.840]  дополнительное лишнее копирование, которое бы, на
[07:32.840 --> 07:35.240]  самом деле, хотелось бы избежать, но, к сожалению, вот
[07:35.240 --> 07:37.640]  создание массива будет требовать, ну, собственно, создание
[07:37.640 --> 07:40.840]  уникальных копий вот элементов, и поэтому это
[07:40.840 --> 07:44.440]  решение может быть, скажем, не самое эффективное.
[07:44.840 --> 07:49.640]  Вот. Да-да, вот мы сами хотим написать функцию
[07:49.640 --> 07:51.640]  min, которая вычисляет минимум, ну, давайте, там
[07:51.640 --> 07:53.640]  какую-нибудь, ну, давайте напишем авто.
[07:53.640 --> 07:55.640]  В общем, шаблон тоже.
[07:57.640 --> 07:59.640]  Template.
[07:59.640 --> 08:01.640]  Класс, мы готовы.
[08:01.640 --> 08:03.640]  Arcs.
[08:03.640 --> 08:05.640]  Вот, я хочу написать функцию minimum, которая вычисляет
[08:05.640 --> 08:07.640]  минимум из всех аргументов. Вот. Ну, то есть, какие
[08:07.640 --> 08:09.640]  есть альтернативы? То есть, первое, я могу воспользоваться
[08:09.640 --> 08:11.640]  вот методом откусывания, да, то есть, методом рекурсии.
[08:11.640 --> 08:13.640]  Ну, то есть, я могу тут завести дополнительный
[08:13.640 --> 08:15.640]  параметр head. Вот. Ну, и сказать, что
[08:15.640 --> 08:17.640]  минимум из одного аргумента и всех
[08:17.640 --> 08:19.640]  остальных, это минимум из всех остальных
[08:19.640 --> 08:21.640]  и
[08:21.640 --> 08:23.640]  того самого первого аргумента. Да.
[08:23.640 --> 08:25.640]  Вот. Соответственно, если я не хочу этого делать,
[08:25.640 --> 08:27.640]  я могу воспользоваться таким трюком. Я могу создать
[08:27.640 --> 08:29.640]  массив. То есть, я из этих аргументов
[08:29.640 --> 08:31.640]  могу создать массив. Вот. Ну, при этом, не указывая
[08:31.640 --> 08:33.640]  шаблоны параметра, намекая компилятору о том,
[08:33.640 --> 08:35.640]  что, ну, как бы догадайся сам,
[08:35.640 --> 08:37.640]  догадайся, сколько тут элементов находится, какого они
[08:37.640 --> 08:39.640]  типа. Вот. Ну, и дальше, собственно, в цикле пройтись
[08:39.640 --> 08:41.640]  по массивчику и, собственно, классическим способом
[08:41.640 --> 08:43.640]  найти, классическим способом найти
[08:43.640 --> 08:45.640]  минимум в массиве. Вот.
[08:49.640 --> 08:51.640]  Нет, вот тут компилятор
[08:51.640 --> 08:53.640]  откажется это делать, потому что он скажет,
[08:53.640 --> 08:55.640]  что, ну, вот тут вы ничего не написали,
[08:55.640 --> 08:57.640]  поэтому, как бы вы сказали, ну, догадайся сам, кого
[08:57.640 --> 08:59.640]  типа массив. А так как тут встречается int
[08:59.640 --> 09:01.640]  и double, компилятор скажет, ну, я не знаю, что вы хотите, вы хотите
[09:01.640 --> 09:03.640]  int или вы хотите double. Вот. Поэтому
[09:03.640 --> 09:05.640]  ограничение данного подхода заключается в том,
[09:05.640 --> 09:07.640]  что тут необходимо, чтобы все аргументы были одного
[09:07.640 --> 09:09.640]  и того же типа. Вот.
[09:10.640 --> 09:12.640]  Окей?
[09:12.640 --> 09:14.640]  Хорошо.
[09:14.640 --> 09:16.640]  Так. Ну, и давайте вернемся к тому,
[09:16.640 --> 09:18.640]  какую проблему мы все-таки решали.
[09:18.640 --> 09:20.640]  То есть, ну, у нас
[09:20.640 --> 09:22.640]  необходимость в этих шаблонных функциях
[09:22.640 --> 09:24.640]  возникла не на пустом месте. Вообще говоря,
[09:24.640 --> 09:26.640]  мы с вами обсуждали вектор,
[09:26.640 --> 09:28.640]  а именно метод emplaceback.
[09:28.640 --> 09:30.640]  То есть, напомню, что
[09:30.640 --> 09:32.640]  у вектора есть метод,
[09:32.640 --> 09:34.640]  ну, вот я создал вектор,
[09:36.640 --> 09:38.640]  который хранит какой-то
[09:38.640 --> 09:40.640]  элементы какого-то типа
[09:40.640 --> 09:42.640]  a. Вот.
[09:42.640 --> 09:44.640]  И я хочу воспользоваться методом
[09:44.640 --> 09:46.640]  emplaceback.
[09:46.640 --> 09:48.640]  Вот.
[09:48.640 --> 09:50.640]  Emplaceback x,
[09:50.640 --> 09:52.640]  y, z. Значит,
[09:52.640 --> 09:54.640]  напомню, что делает emplaceback. Emplaceback
[09:54.640 --> 09:56.640]  по сути является эквивалентом вот такому коду
[09:56.640 --> 09:58.640]  v.
[09:58.640 --> 10:00.640]  уж
[10:00.640 --> 10:02.640]  back от a
[10:04.640 --> 10:06.640]  x, y, z. Но гораздо лучше, чем
[10:06.640 --> 10:08.640]  вот такой способ по
[10:08.640 --> 10:10.640]  нескольким вещам. Ну, первое, мне тут не приходится
[10:10.640 --> 10:12.640]  в apro chip sacrifice,
[10:12.640 --> 10:14.640]  а потом я его передаю в pushback.
[10:14.640 --> 10:16.640]  Тут же я передаю параметры
[10:16.640 --> 10:18.640]  конструктора. В отличие от pushback принимает
[10:18.640 --> 10:22.640]  сам объект, который я хочу
[10:22.640 --> 10:24.640]  ставить, а emplaceback принимает параметры конструктора,
[10:24.640 --> 10:26.640]  с которыми нужно создать нужные мне объекты a.
[10:26.640 --> 10:28.640]  Тут проблема заключается в том, что я создаю временный объект,
[10:28.640 --> 10:30.640]  а потом его передаю в pushback.
[10:30.640 --> 10:32.640]  И дальше pushback решает скопировать этот элемент
[10:32.640 --> 10:34.640]  или переместить этот элемент.
[10:34.640 --> 10:38.800]  параметры конструктора и сразу же создает элемент в нужном мне месте. То есть, я избегаю
[10:38.800 --> 10:44.200]  создания вот этой самой лишней копии. Понятно, да? Вот. И какая у нас проблема возникла? У нас возникла
[10:44.200 --> 10:47.760]  проблема с тем, что, вообще говоря, непонятно, как написать вот этот самый emplaceback. Потому что
[10:47.760 --> 10:52.840]  emplaceback, он принимает параметры конструктора, но вообще говоря, у одного и того же класса
[10:52.840 --> 10:56.920]  может быть несколько конструкторов, потом, во-вторых, мы не понимаем, так как vector это
[10:56.920 --> 11:02.200]  шаблонный контейнер, то он может хранить себе элементы, вообще говоря, произвольного типа. То есть,
[11:02.520 --> 11:05.560]  мы храним произвольный тип, во-вторых, у этого произвольный тип может быть сколько угодно
[11:05.560 --> 11:10.200]  конструкторов, и поэтому мы не знаем, что должен принимать emplaceback. Ну, собственно,
[11:10.200 --> 11:13.880]  тут возникает необходимость написать шаблонный emplaceback, который может принимать вообще все,
[11:13.880 --> 11:22.000]  что угодно. Понятно, да? Вот. Окей. Вроде как мы эту проблему победили с помощью шаблона с
[11:22.000 --> 11:27.920]  переменным числом аргументов. Но вот, смотрите, какая может быть незадача. Смотрите, какая может
[11:27.920 --> 11:41.000]  быть проблема. Давайте я тут заменю x, y, z на значение, ну, допустим, 0, 1, 2. Вот. И, допустим,
[11:41.000 --> 11:51.600]  у меня есть класс A, и в классе A написан такой конструктор, int ссылка x, int ссылка y, int ссылка z.
[11:51.600 --> 12:00.400]  Вот. Ну, то есть, конструктор A принимает, действительно, он принимает 3 int,
[12:00.400 --> 12:09.040]  но все 3 int он принимает по ссылке. Вопрос. Могу ли я создать A с помощью параметров 0, 1, 2?
[12:09.040 --> 12:22.960]  Да или нет? Почему? Да, потому что 0, 1, 2 это что? Ну, в терминологии это R-value, да? Но это,
[12:22.960 --> 12:27.640]  по сути, временные значения. Временные значения я не могу связывать с R-value ссылками. Понятно,
[12:27.640 --> 12:31.640]  да? А теперь давайте посмотрим вот сюда. Я написал в emplaceback 0, 1, 2. Как вы думаете,
[12:31.640 --> 12:37.360]  скомпилируется этот код или нет? И вот этот код скомпилируется, да, почему? Потому что,
[12:37.360 --> 12:41.880]  ну, emplaceback мы предполагаем, он реализован как? Он реализован как шаблон с переменным числом
[12:41.880 --> 12:47.920]  аргументов. То есть, я вот эти 0, 1, 2 передаю в переменный args. А потом с помощью этих args
[12:47.920 --> 12:53.720]  создаю нужный мне элемент. Так как вот это args это переменная, то с помощью переменных я
[12:53.720 --> 12:59.840]  могу создать A. Окей? Ну, кажется, это проблема. Почему? Ну, то есть, тут две проблемы. Первая
[12:59.840 --> 13:03.160]  проблема заключается в том, что вообще говоря, A нельзя создавать с помощью 0, 1, 2, а тут как бы
[13:03.160 --> 13:08.480]  у меня получилось создать элемент A с помощью параметров 0, 1, 2, с помощью R-value. Это первая
[13:08.480 --> 13:12.040]  проблема. А вторая проблема заключается в следующем. Ну, смотрите, если A принимает параметры по ссылке,
[13:12.040 --> 13:15.840]  ну, наверное, это зачем-то им нужно. Наверное, где-то внутри себя сохранит либо указатель,
[13:15.840 --> 13:21.280]  либо ссылку на эти значения, да? А что получится, если вот этот A сохранит ссылку на вот эти вот
[13:21.280 --> 13:28.680]  значения переменных? Ну, после того, как вызов emplaceback завершится, вот эта перемена уничтожится,
[13:28.680 --> 13:35.400]  и A будет хранить себе ссылки или указатели на уже мертвые переменные. Понятно? Беда. То есть,
[13:35.400 --> 13:41.280]  вообще говоря, хотелось бы запретить вот такое. И вот об этом мы сегодня поговорим. То есть,
[13:41.280 --> 13:46.800]  мы хотим запретить иногда передавать параметры. Ну, короче говоря, мы хотим, чтобы emplaceback
[13:46.800 --> 13:51.160]  научился как-то отличать. То есть, могу я передать туда R-value или не могу передать туда R-value.
[13:51.160 --> 13:56.880]  Вот. В общем, глобальный план такой. Значит, упрощенный пример. Давайте посмотрим на слайде.
[13:56.880 --> 14:02.640]  Значит, задача такая. Смотрите, давайте отвлечемся от этой проблемы. То есть, если эта проблема была
[14:02.640 --> 14:07.400]  непонятна, ну, жаль, но давайте посмотрим тогда на примере более простой задачи. Смотрите,
[14:07.400 --> 14:14.160]  я хочу сделать следующее. Я хочу написать функцию runningTime, которая принимает на вход два параметра.
[14:14.160 --> 14:19.560]  Она принимает функцию от одного аргумента. То есть, функция runningTime принимает другую
[14:19.620 --> 14:23.420]  функцию, которую она может быть вызна с одним аргументом. И принимает с другим параметром тот
[14:23.420 --> 14:27.400]  самый аргумент, с которого мне должна вызнать первую функцию. И просто, напросто… Она items
[14:27.400 --> 14:32.060]  вызывает функцию от этого аргумента и высчисляет, сколько времени эта функция запускалась. Но по
[14:32.060 --> 14:35.680]  сути, такая метафункция, которая просто принимает другую функцию аргумента и вычисляет, сколько
[14:35.680 --> 14:42.960]  времени работает эта функция на данном аргументе. Понятно? Ну, короче говоря, если я запускаю
[14:42.960 --> 14:55.900]  рантайм от fx, то она просто-напросто вычисляет время работы f от x,
[14:55.900 --> 15:03.960]  окей? Вот. Ну то есть она вычисляет f от x и заодно вычисляет время, за которое
[15:03.960 --> 15:06.580]  функция отработала. Ну и соответственно в качестве возвращаемой, ну и собственно
[15:06.580 --> 15:09.440]  возвращает она то самое время, за которое отработала эта
[15:09.440 --> 15:12.360]  функция. Ну собственно тут просто стандартный подход с измерением времени
[15:12.360 --> 15:19.520]  с помощью библиотеки time, stdc log, он просто-напросто возвращает текущее
[15:19.520 --> 15:23.760]  время в каких-то единицах измерения. Ну и соответственно я сохраняю время
[15:23.760 --> 15:28.200]  старта, ну и собственно в ретёрне я вычисляю время окончания, вычитаю из
[15:28.200 --> 15:31.560]  него время старта, ну и делю на то, сколько вот этих вот условных единиц
[15:31.560 --> 15:34.360]  прошло, ну точнее сколько вот этих условных единиц содержится в одной секунде.
[15:34.360 --> 15:39.280]  Окей? Вот. То есть stdc log минус star возвращает мне количество времени в каких-то
[15:39.280 --> 15:43.720]  условных единицах. Вот. И я собственно это время делю на количество этих самых
[15:43.720 --> 15:46.440]  условных единиц в секунде и получаю время в секундах, сколько мне заняло
[15:46.440 --> 15:50.360]  вызов этой самой функции func. Вот. В чём проблема? Ну казалось бы очень
[15:50.360 --> 15:54.800]  простая задача, и реализация этой функции вроде как изображена на слайде.
[15:54.800 --> 16:02.280]  Да, то есть, так, вы не против, если я... так нормально? Вот.
[16:02.280 --> 16:06.880]  Ну, собственно, всё довольно просто. То есть я запускаю функцию running time, измеряю
[16:06.880 --> 16:11.680]  время начала работы функции, запускаю функцию от аргумента и возвращаю, собственно,
[16:11.680 --> 16:16.240]  то, сколько времени прошло. Вот. Ну, соответственно, вызываю function от пяти,
[16:16.240 --> 16:20.400]  или вызываю running time от function от пяти, всё работает, ну, точно так же. Да, ну просто
[16:20.400 --> 16:24.000]  running time дополнительно ещё возвращает время, которое было потрачено на вызов
[16:24.000 --> 16:27.360]  функции function. Как вы думаете, в чём тут может быть проблема? В чём проблема в
[16:27.360 --> 16:38.160]  такой реализации функции running time? Сейчас, где мы передаём ссылку? Ну, смотрите, вот
[16:38.160 --> 16:42.880]  я... у меня вот running time принимает функцию... function в первом аргументе, принимает
[16:42.880 --> 16:46.880]  пятёрку в втором аргументе, я в функцию передаю, ну, собственно, арк. То есть, ну,
[16:46.880 --> 16:50.920]  собственно, тут, кажется, проблем никаких нет. Я вызываю function от пяти, и это
[16:50.920 --> 16:55.360]  абсолютно эквариенты, как если бы я вызвал running time function от пяти. Вот. Какая
[16:55.360 --> 17:05.200]  потенциальная проблема может быть? Ну, да, понятно, что тут было бы неплохо навесить там
[17:05.200 --> 17:08.880]  шаблон с переменом в чём-то аргумент, давайте пока просто посчитать, что running time имеет
[17:08.880 --> 17:14.000]  работу только с функцией одного аргумента. Вот. Пока давайте с такой функцией разберёмся. Вот.
[17:14.000 --> 17:24.400]  С какой функцией... с какой функцией ей вот эта штука не сработает? Да. Давайте посмотрим на
[17:24.400 --> 17:27.920]  следующий слайд. Смотрите, а что если у меня функция function, время, которое я хочу измерить,
[17:27.920 --> 17:32.640]  принимает аргумент по ссылке? Ну, давайте посмотрим, что произойдёт. Вот я создаю
[17:32.640 --> 17:36.480]  переменную int x равную нулю, вызываю function от x. Ну, никому не удивляет, что после этого x
[17:36.480 --> 17:39.920]  стал равен единице. Ну, давайте, да, вот, функция function, она принимает значение и увеличивает
[17:39.920 --> 17:45.240]  внутри себя значение на единицу. Да? Plus-plus value. Вот. Теперь я вызываю функцию function от x.
[17:45.240 --> 17:48.800]  x изначально равен нулю. Ну, собственно, никому не удивляет, когда после вызова function от x
[17:48.800 --> 17:53.240]  у меня x стал равен единице. Да? Нормально. А теперь сразу после этого я вызываю running time
[17:53.240 --> 18:00.920]  function от x и вижу, что x остался равным единице. Вопрос почему? Ведь running time function от x
[18:00.920 --> 18:04.200]  должен работать точно так же, как и вызов функции function от x, но просто
[18:04.200 --> 18:08.440]  дополнительно считает время. Почему x не изменился? Хотя я вызывал вроде функцию function
[18:08.440 --> 18:20.440]  внутри running time. Да, смотрите, что произошло. У меня функция running time, давайте, тут,
[18:20.440 --> 18:27.640]  обратите внимание, у меня функция running time принимает аргумент по значению u. Да? То есть,
[18:27.640 --> 18:33.120]  что произошло, когда я передал в running time аргумент x? Аргумент x скопировался в этот аргумент,
[18:33.120 --> 18:40.280]  да, и функция function работала с этой локальной копией. То есть, функция function увеличила
[18:40.280 --> 18:49.120]  локальную копию, а внешний x от этого никак не поменялся. Понятно? Вот. Это проблема. Как проблему
[18:49.120 --> 18:57.520]  будем решать? Ну, предлагаю такое решение. Давайте просто, например, в running time принимать
[18:57.520 --> 19:04.880]  аргумент по ссылке. Теперь кажется, что все нормально. У меня int x равны нулю, я вызываю
[19:04.880 --> 19:09.440]  function от x, x стал равным единице. Вызываю running time function от x, а получается x равны двойке. То
[19:09.440 --> 19:14.280]  есть, x передался по ссылке, и, собственно, внутри running time у меня этот самый аргумент, так как он
[19:14.280 --> 19:24.840]  был принят по ссылке, он же изменился. Вот. Смотрите, у меня есть функция function,
[19:24.840 --> 19:39.800]  которая принимает значение по ссылке. Давайте v. И делает plus-plus-v. Вот. У меня есть функция running
[19:39.800 --> 19:49.800]  time, которая принимает какую-то произвольную функцию и принимает аргумент по ссылке.
[19:49.880 --> 20:03.320]  Не по ссылке, а просто аргумент. Вот. И внутри этой функции running time я вызываю f от arg. Теперь
[20:03.320 --> 20:19.200]  что я делаю? Я вызываю running time от function от x, где x, допустим, равен изначально нулю. Вот.
[20:19.200 --> 20:24.960]  Что бы я хотел? Я бы хотел, чтобы вызов running time от function от x работал точно так же, как если бы
[20:24.960 --> 20:30.160]  я вызвал просто function от x. Понятно? Вопрос. Что произойдет, если я просто вызову function от x?
[20:30.160 --> 20:38.680]  Ну, x увеличится на единицу. Что на самом деле происходит? Я вызываю running time от function и от x.
[20:38.680 --> 20:43.760]  Так, running time принимает функцию по значению и аргумент тоже по значению. То есть, на самом деле,
[20:43.760 --> 20:52.480]  вот эта штука будет копией x. Вот. И что произойдет здесь тогда? Я вызываю function от вот этой копии и
[20:52.480 --> 20:58.880]  увеличится копия вот это. А вот этот x никак не изменится. Хотя я бы хотел, чтобы при этом вызове x
[20:58.880 --> 21:08.520]  тоже бы изменился. Ага. Вот. Как решить вот проблему? Я предлагаю так. Чтобы это решить, давайте просто
[21:08.520 --> 21:23.360]  добавлю ссылку. В чем теперь проблема? Вот, да. Вернемся к исходной функции function,
[21:23.360 --> 21:30.120]  которая принимает просто int. Я функцию function могу вызвать от 5. Я могу написать function от 5.
[21:30.120 --> 21:37.320]  Все сработает нормально. Если я позову running time от function от 5, все сломается. Почему? Потому
[21:37.400 --> 21:47.720]  что аргумент arg принимается по ссылке. А пятерку прикастовать к lvalue из ссылки я не могу. Да? То
[21:47.720 --> 21:53.800]  есть, возникает проблема? Смотрите, чего бы я хотел? Я бы хотел, чтобы функция running time работала и в случае,
[21:53.800 --> 21:59.280]  когда у меня функция function принимает lvalue, и в случае, когда функция function принимает rvalue. Но если я,
[21:59.280 --> 22:06.080]  соответственно, принимаю аргумент без ссылки, то у меня нарушается работа функции, которая принимает
[22:06.080 --> 22:10.160]  аргумент по ссылке. Если я принимаю аргумент по ссылке, то у меня ломается вот такая вот штука.
[22:10.160 --> 22:18.680]  Понятно? В общем, running time — это очень-очень универсальная функция, то есть не получается
[22:18.680 --> 22:26.000]  написать очень универсальную функцию running time. Проблема ясна? Самое главное — знать
[22:26.000 --> 22:37.280]  проблему. Это первый ключ к ее решению. Нормально? Хорошо. Вот сейчас, да. То есть, смотрите,
[22:37.280 --> 22:42.480]  если я пишу arg.impercent, то я не могу передавать туда константы просто. Если я напишу arg.impercent,
[22:42.480 --> 22:46.600]  то я не могу передавать, точнее, я не могу использовать функции function, которые принимают
[22:46.600 --> 22:52.400]  ссылку. Потому что они будут работать не с той ссылкой, которую я передал, а с локальной копией.
[22:52.400 --> 23:05.280]  Собственно, проблема находится в этом аргументе. Проблема в том, что этот аргумент, к сожалению,
[23:05.280 --> 23:10.520]  пока не умеет адаптироваться под передаваемые в него значения. То есть, если я в него передал lvalue,
[23:10.520 --> 23:17.280]  то из чего хотелось бы? Хотелось бы, если бы я передал lvalue, то arg был бы ссылкой на lvalue.
[23:17.280 --> 23:22.240]  А если бы я передал в этот аргумент lvalue, я бы хотел, чтобы этот аргумент был, как минимум,
[23:22.240 --> 23:34.080]  lvalue-ссылкой, а как максимум — просто-напросто переменной. На самом деле, чисто так вот,
[23:34.080 --> 23:39.520]  технически, проблему можно обойти, если писать перегрузку для функции runningTime. То есть, можно
[23:39.520 --> 23:42.880]  писать одну функцию runningTime, которая принимает аргумент по ссылке, вторую функцию runningTime,
[23:42.880 --> 23:46.640]  которая принимает аргумент по lvalue-ссылке. Ну и тогда вроде как одна будет работать,
[23:46.640 --> 23:50.640]  когда я передаю lvalue, вторая будет работать, если я передаю rvalue.
[23:50.640 --> 23:52.640]  Но проблема тут в том, что, во-первых, тут есть дублирование кода,
[23:52.640 --> 23:55.640]  то есть приходится написать практически две идентичные функции running time,
[23:55.640 --> 23:57.640]  это во-первых. А во-вторых, давайте вернемся, собственно, к замечанию,
[23:57.640 --> 23:59.640]  которое было сказано несколько минут назад.
[23:59.640 --> 24:01.640]  А что если я хочу написать функцию running time,
[24:01.640 --> 24:04.640]  которая принимает не один аргумент, а много аргументов?
[24:04.640 --> 24:06.640]  Ну что тогда? Мне тогда придется написать
[24:06.640 --> 24:11.640]  всевозможные комбинации rvalue и lvalue ссылок, согласны?
[24:11.640 --> 24:13.640]  То есть первый аргумент принимает lvalue,
[24:13.640 --> 24:14.640]  первый аргумент принимает rvalue,
[24:14.640 --> 24:15.640]  второй аргумент принимает lvalue,
[24:15.640 --> 24:17.640]  второй аргумент принимает rvalue и так далее, и так далее…
[24:17.640 --> 24:19.640]  То есть если у меня функции будет принимать 5 параметров,
[24:19.640 --> 24:21.640]  соответственно, у меня там два в пятой степени вариантов,
[24:21.640 --> 24:24.640]  то есть 32 вариантов функции мне нужно будет написать.
[24:24.640 --> 24:26.640]  Понятно?
[24:28.640 --> 24:30.640]  Попрос, как избежать от дублирования кода,
[24:30.640 --> 24:32.640]  можно не написать универсальную функцию,
[24:32.640 --> 24:34.640]  которая могла принимать все что угодно
[24:34.640 --> 24:36.640]  и использовала нужный тип ссылки.
[24:36.640 --> 24:38.640]  То есть если я в аргумент передал lvalue,
[24:38.640 --> 24:41.640]  то этот аргумент стал бы lvalue ссылкой.
[24:41.640 --> 24:43.640]  Если я в этот аргумент передал rvalue,
[24:43.640 --> 24:48.280]  стал бы RVL ссылкой. Хотелось бы написать такую универсальную функцию. Ну и такую универсальную
[24:48.280 --> 24:52.400]  функцию можно написать с помощью так называемых универсальных ссылок.
[24:52.400 --> 24:58.760]  Давайте познакомимся с понятием универсальная ссылка. Прежде чем начнем, небольшое
[24:58.760 --> 25:04.440]  замечание про сворачивание ссылок. Это просто такое правило изнк C++, которое говорит в
[25:04.440 --> 25:08.680]  следующем, что если в какой-то момент у вас в программе возникает следующая ситуация,
[25:08.680 --> 25:14.080]  ну вот представьте себе, что у вас есть какой-то тип, у которого уже есть ссылка. И вы на этот
[25:14.080 --> 25:19.280]  тип со ссылкой навешиваете еще раз ссылку. Ну как такое может возникнуть? Ну давайте посмотрим на
[25:19.280 --> 25:25.080]  вот функцию f. Вот у меня есть функция f, у нее первый аргумент это t амперсант, второй
[25:25.080 --> 25:28.760]  аргумент t два амперсанда. Ну и представьте себе, что вы вызывает функцию f и указал явно в
[25:28.760 --> 25:32.680]  треугольных скобках, что мне в качестве t нужно подставить int амперсант. И вроде как возникает
[25:32.680 --> 25:38.000]  ситуация, что у меня есть int амперсант, на который я снова должен навесить амперсант. Так вот такая
[25:38.000 --> 25:42.020]  ситуация с комплятором интерпретируется не как ошибка, а интерпретируется следующим образом.
[25:42.020 --> 25:46.260]  Значит, если вы на 1 амперсант навешиваете другой амперсант, то это тоже самое как просто
[25:46.260 --> 25:53.360] 합стотип с 1. Амперсант, вот если вы на амперсант навешиваете 2 амперсанда, то это то же самое,
[25:53.360 --> 25:58.900]  что 1 амперсант. Если вы наоборот, на 2 амперсант, навешиваете 1 амперсант, то то же самое,
[25:58.900 --> 26:02.440]  что 1 амперсант. И только если вы на 2 амперсанты навешиваете 2 амперсант,
[26:02.440 --> 26:09.640]  то остается два амперсанта. Окей? Вот. Ну то есть правило запомнить очень просто, просто
[26:09.640 --> 26:17.960]  берется минимальное из-за количества амперсанта. Вот. Окей? Нормально? Хорошо. Теперь давайте
[26:17.960 --> 26:23.200]  поговорим про универсальные ссылки. Что такое универсальная ссылка? Значит, утверждение следующее.
[26:23.200 --> 26:29.200]  Значит, универсальная ссылка — это ссылка одного из следующих двух видов, и только их. Вот. Если
[26:29.200 --> 26:34.040]  вы видите функцию function таблоном параметром t, и в качестве аргумента он принимает t
[26:34.040 --> 26:39.840]  двойной амперсант, то t двойной амперсант — это универсальная ссылка. Или если вы
[26:39.840 --> 26:43.960]  создаете переменную с помощью авто и на авто навешиваете два амперсанды, то это универсальная
[26:43.960 --> 26:52.000]  ссылка. Все. Других универсальных ссылок не существует. Вот. Это только эти два способа
[26:52.000 --> 26:56.400]  создают универсальные ссылки. Если вы начинаете на всю эту штуку навешивать const, например,
[26:56.840 --> 27:00.760]  ten двойной амперсант или const after двойной амперсант, это уже не универсальная ссылка.
[27:00.760 --> 27:08.360]  Если вы пишете т200% — это не универсальная ссылка. Универсальная ссылка — это
[27:08.360 --> 27:15.000]  только шаблонный параметр, двойной амперсант или авто двойной амперсант. Все. Либо то, либо то.
[27:15.300 --> 27:19.080]  More DNM — это универсальная ссылка. Больше ничего не является универсальной ссылкой.
[27:19.320 --> 27:22.240]  Волter ListTri silenceDown Универсальная ссылка имеет Twitter Vallс chin,
[27:22.240 --> 27:25.240]  то есть универсальная ссылка похожа на универсальную ссылку, но при этом
[27:25.240 --> 27:30.240]  универсальная ссылка похожа на RLV ссылку, но при этом RLV ссылка не является.
[27:30.240 --> 27:36.240]  Давайте еще примеры. Вот, например, функция function, которая принимает
[27:36.240 --> 27:39.240]  const, которая двойной персант. Как я уже сказал, это не универсальная ссылка.
[27:39.240 --> 27:43.240]  const и двойной персант — это константная RLV ссылка.
[27:43.240 --> 27:46.240]  Точнее, RLV ссылка на константу. Дальше.
[27:46.240 --> 27:47.240]  Дальше.
[27:47.240 --> 27:50.240]  Code after двойной персант — это тоже не универсальная ссылка.
[27:50.240 --> 27:54.240]  Это правая ссылка на константное значение.
[27:54.240 --> 28:01.240]  Дальше. Допустим, у меня есть класс stack с шаблонным параметром t.
[28:01.240 --> 28:05.240]  Вот здесь мне написана функция push, t, двойной персант, value.
[28:05.240 --> 28:09.240]  Вот тут t, двойной персант — это не универсальная ссылка. Почему?
[28:09.240 --> 28:13.240]  Потому что шаблонный параметр t — это не шаблонный параметр функции push.
[28:13.240 --> 28:16.240]  Шаблонный параметр t — это шаблонный параметр класса stack.
[28:16.240 --> 28:22.240]  То есть универсальная ссылка — это только та ссылка, которая относится к параметру самой функции.
[28:22.240 --> 28:27.240]  Вот тут параметр t, это не параметр функции. Это параметр класса stack.
[28:28.240 --> 28:32.240]  А вот если я внутри класса stack написал свою шаблонную функцию push,
[28:32.240 --> 28:35.240]  то у двойной персант — это универсальная ссылка.
[28:35.240 --> 28:38.240]  Почему? Потому что u — это шаблонный параметр самой функции,
[28:38.240 --> 28:40.240]  и она описана как U%
[28:40.240 --> 28:42.240]  понятно?
[28:42.240 --> 28:44.240]  вот, хорошо
[28:44.240 --> 28:46.240]  теперь
[28:46.240 --> 28:48.240]  что такое универсальные ссылки, как они работают?
[28:48.240 --> 28:50.240]  универсальные ссылки работают
[28:50.240 --> 28:52.240]  по следующим правилам
[28:52.240 --> 28:54.240]  надеюсь, вы помните, что когда мы с вами обсуждали в прошлом семестре
[28:54.240 --> 28:58.240]  шаблонные функции
[28:58.240 --> 29:00.240]  мы с вами говорили про то, как
[29:00.240 --> 29:02.240]  выводится шаблонный параметр
[29:02.240 --> 29:04.240]  мы с вами говорили про то, как выводится шаблонный параметр, если мы передаем
[29:04.240 --> 29:06.240]  аргумент по значению
[29:06.240 --> 29:08.240]  мы с вами говорили про то, как выводится шаблонный параметр, если мы передаем аргумент по значению
[29:08.240 --> 29:10.240]  вот, и наконец
[29:10.240 --> 29:12.240]  третий способ вывода
[29:12.240 --> 29:14.240]  шаблонных параметров
[29:14.240 --> 29:16.240]  это вывод шаблонного параметра
[29:16.240 --> 29:18.240]  в случае, когда передается аргумент
[29:18.240 --> 29:20.240]  по универсальной ссылке
[29:20.240 --> 29:22.240]  универсальных ссылок есть особый механизм вывода
[29:22.240 --> 29:24.240]  шаблонного аргумента
[29:24.240 --> 29:26.240]  смотрите, какие правила
[29:26.240 --> 29:28.240]  вот, допустим, есть функция function, которая принимает универсальную ссылку
[29:28.240 --> 29:30.240]  то есть T, двойной U%
[29:30.240 --> 29:32.240]  как будет
[29:32.240 --> 29:34.240]  выводиться тип T?
[29:34.240 --> 29:36.240]  я буду передавать какой-то аргумент функцию function
[29:36.240 --> 29:38.240]  первое
[29:38.240 --> 29:40.240]  const и volatile квалификаторы не отбрасываются
[29:40.240 --> 29:42.240]  то есть, если у аргумента, который я передал функцию function
[29:42.240 --> 29:44.240]  есть
[29:44.240 --> 29:46.240]  на него навешан какой-то
[29:46.240 --> 29:48.240]  модификатор const или модификатор volatile
[29:48.240 --> 29:50.240]  то эти квалификаторы отбрасываться
[29:50.240 --> 29:52.240]  не будут
[29:52.240 --> 29:54.240]  то есть, const не теряется
[29:54.240 --> 29:56.240]  volatile не теряется
[29:56.240 --> 29:58.240]  дальше, второе правило
[29:58.240 --> 30:00.240]  если я передаю
[30:00.240 --> 30:02.240]  в качестве аргумента
[30:02.240 --> 30:04.240]  Lvalue значение
[30:04.240 --> 30:06.240]  то тип T выводится как ссылочный
[30:08.240 --> 30:10.240]  то есть, если я написал
[30:10.240 --> 30:12.240]  function
[30:12.240 --> 30:14.240]  от, допустим, x
[30:14.240 --> 30:16.240]  перемена это всегда Lvalue
[30:16.240 --> 30:18.240]  и перемена x
[30:18.240 --> 30:20.240]  у меня
[30:20.240 --> 30:22.240]  это const int x
[30:22.240 --> 30:24.240]  равно 0
[30:24.240 --> 30:26.240]  тогда тип T будет выведен как
[30:26.240 --> 30:28.240]  const int %
[30:28.240 --> 30:30.240]  почему const int?
[30:30.240 --> 30:32.240]  потому что по первому правилу
[30:32.240 --> 30:34.240]  константность не отбрасывается
[30:34.240 --> 30:36.240]  почему %?
[30:36.240 --> 30:38.240]  потому что x это Lvalue
[30:38.240 --> 30:40.240]  а если передается Lvalue, то тип T выводится как ссылочный
[30:40.240 --> 30:42.240]  с одним %
[30:42.240 --> 30:44.240]  понятно?
[30:44.240 --> 30:46.240]  дальше
[30:46.240 --> 30:48.240]  ну и, наконец, третье правило
[30:48.240 --> 30:50.240]  если передается не Lvalue, а Rvalue
[30:50.240 --> 30:52.240]  ну, допустим, function от
[30:52.240 --> 30:54.240]  0
[30:54.240 --> 30:56.240]  тип T выводится как не ссылочный
[30:56.240 --> 30:58.240]  то есть, просто как
[30:58.240 --> 31:00.240]  тип int
[31:00.240 --> 31:02.240]  окей?
[31:02.240 --> 31:04.240]  то есть, универсальная ссылка умеет
[31:04.240 --> 31:06.240]  понимать, что вы в нее
[31:06.240 --> 31:08.240]  передали
[31:08.240 --> 31:10.240]  Lvalue или Rvalue
[31:10.240 --> 31:12.240]  то есть, если вы в нее передали Lvalue
[31:12.240 --> 31:14.240]  то тип T выведется как ссылочный
[31:14.240 --> 31:16.240]  если вы в нее передали Rvalue, то тип T выведется как не ссылочный
[31:16.240 --> 31:18.240]  вот
[31:18.240 --> 31:20.240]  понятно?
[31:20.240 --> 31:22.240]  вот
[31:22.240 --> 31:24.240]  а теперь давайте
[31:24.240 --> 31:26.240]  обсудим вот такой момент
[31:26.240 --> 31:28.240]  у меня есть функция function
[31:28.240 --> 31:30.240]  она принимает
[31:30.240 --> 31:32.240]  универсальную ссылку
[31:32.240 --> 31:34.240]  arg
[31:34.240 --> 31:36.240]  посмотрите, я сказал, что в первом случае у меня T будет имитив
[31:36.240 --> 31:38.240]  constant %
[31:38.240 --> 31:40.240]  в втором случае тип T выведется как int
[31:40.240 --> 31:42.240]  вопрос
[31:42.240 --> 31:44.240]  почему в первом случае будет
[31:44.240 --> 31:46.240]  тип переменной arg?
[31:46.240 --> 31:48.240]  смотрите
[31:48.240 --> 31:50.240]  давайте мысленно подставим
[31:50.240 --> 31:52.240]  тип T это constant %
[31:52.240 --> 31:54.240]  мысленно подставим вместо тип D constant %
[31:54.240 --> 31:56.240]  я получил constant %
[31:56.240 --> 31:58.240]  на который навесил еще 2 %
[31:58.240 --> 32:00.240]  что в итоге получится?
[32:00.240 --> 32:02.240]  вон правило
[32:02.240 --> 32:04.240]  у меня тип T выводится как ссылочный
[32:04.240 --> 32:06.240]  я на него навесил еще две ссылки
[32:06.240 --> 32:08.240]  получил в итоге одну ссылку
[32:08.240 --> 32:10.240]  тип аргумента будет на самом деле
[32:10.240 --> 32:12.240]  const int %
[32:12.240 --> 32:14.240]  окей
[32:14.240 --> 32:16.240]  какой будет тип аргумента?
[32:20.240 --> 32:22.240]  тип T выводится как int
[32:22.240 --> 32:24.240]  вместо T я сюда подставляю int
[32:24.240 --> 32:26.240]  что получается?
[32:26.240 --> 32:28.240]  int двойной %
[32:28.240 --> 32:30.240]  да?
[32:30.240 --> 32:32.240]  то есть arg будет иметь тип int
[32:32.240 --> 32:34.240]  двойной %
[32:34.240 --> 32:36.240]  вот
[32:36.240 --> 32:38.240]  то есть в зависимости от того, что я передал функцию function
[32:38.240 --> 32:40.240]  у меня тип аргумента
[32:40.240 --> 32:42.240]  тип аргумента вот этого внутри функции
[32:42.240 --> 32:44.240]  он будет иметь тип
[32:44.240 --> 32:46.240]  обычной ссылки, если я передал Lvalue
[32:46.240 --> 32:48.240]  либо хотя бы Rvalue
[32:48.240 --> 32:50.240]  понятно?
[32:50.240 --> 32:52.240]  посмотрите в чем смысл универсальной ссылки
[32:52.240 --> 32:54.240]  давайте на чистом интуитивном уровне поговорим
[32:56.240 --> 32:58.240]  что означает универсальная ссылка
[32:58.240 --> 33:00.240]  универсальная ссылка означает
[33:00.240 --> 33:02.240]  что аргумент этой функции шаблонной
[33:02.240 --> 33:02.840]  в любом случае будет reactors 저
[33:02.840 --> 33:04.840]  в любом случае будет являться ссылкой
[33:04.840 --> 33:06.280]  универсальная ссылка означает, что
[33:06.280 --> 33:08.280]  arg будет ссылкой
[33:08.280 --> 33:10.280]  и весь вопрос заключается в том,
[33:10.280 --> 33:14.660]  либо l-value с ссылкой, либо r-value с ссылкой. В каком случае ll-value
[33:14.660 --> 33:17.860]  будет, если я передал l-value в такой случае.
[33:17.860 --> 33:20.700]  В каком случае argumentArc станет r-value ссылкой.
[33:20.700 --> 33:24.840]  wyb ideia в том случае, что я туда
[33:24.840 --> 33:29.080]  передал r-value значения. То есть в этом смысл универсальных
[33:29.080 --> 33:31.680]  ссылок. Раньше под видео я писал
[33:31.680 --> 33:36.420]  Justinia Perca и feedback kal理на Литви eyebrows.
[33:36.420 --> 33:39.300]  Если я писал int 2 amp then я eram
[33:39.300 --> 33:41.860]  то я знал, что я сюда могу передать только R-value.
[33:41.860 --> 33:43.860]  Если я пишу T, двойной амперсант,
[33:43.860 --> 33:46.660]  то я знаю, что я сюда могу передать как L-value, так и R-value,
[33:46.660 --> 33:47.860]  при этом тип выйдется корректно.
[33:47.860 --> 33:50.340]  То есть тут будет или L-value ссылка, или R-value ссылка.
[33:50.340 --> 33:52.340]  Давайте поупражняемся,
[33:52.340 --> 33:53.780]  посмотрим на примеры.
[33:53.780 --> 33:57.140]  У меня есть та самая функция function, которая принимает универсальную ссылку.
[33:57.140 --> 34:00.580]  Есть целый набор переменных, есть переменная x,
[34:00.580 --> 34:02.900]  есть константная переменная cx,
[34:02.900 --> 34:06.340]  есть переменная rx, которая является R-value ссылкой на 0,
[34:06.340 --> 34:10.340]  есть переменная cx, которая является константной правой ссылкой на 0.
[34:10.340 --> 34:14.340]  Давайте пообсуждаем,
[34:14.340 --> 34:16.340]  и тут будут значения.
[34:16.340 --> 34:18.340]  Вот я вызываю function от x.
[34:18.340 --> 34:20.340]  Тут два вопроса для каждой функции.
[34:20.340 --> 34:22.340]  Какой тип будет выведен для T?
[34:22.340 --> 34:26.340]  И какой тип будет у аргумента ARC?
[34:28.340 --> 34:30.340]  Я передаю function от x. Какой тип будет у T?
[34:30.340 --> 34:32.340]  Int или int&?
[34:32.340 --> 34:34.340]  Int&, да, почему?
[34:34.340 --> 34:36.340]  Потому что смотрим на предыдущий слайд,
[34:36.340 --> 34:38.340]  при передаче L-value в качестве аргумента тип T
[34:38.340 --> 34:40.340]  выводится как L-value ссылка.
[34:40.340 --> 34:42.340]  Все, смотри, тип T это int&,
[34:42.340 --> 34:44.340]  давайте мысленно вот сюда,
[34:44.340 --> 34:46.340]  вместо T подставим int&.
[34:46.340 --> 34:48.340]  Что в итоге получится?
[34:48.340 --> 34:50.340]  Какой тип?
[34:50.340 --> 34:52.340]  Int&, да.
[34:52.340 --> 34:54.340]  Так, теперь cx.
[34:54.340 --> 34:56.340]  Да, ну это мы разбирали вон там,
[34:56.340 --> 34:58.340]  то есть если у меня передается константа,
[34:58.340 --> 35:00.340]  то тип T выводится просто как констант.
[35:00.340 --> 35:02.340]  То есть константность не теряется,
[35:02.340 --> 35:04.340]  и при этом, так как cx это L-value,
[35:04.340 --> 35:06.340]  то выводится constant&.
[35:06.340 --> 35:08.340]  А тип аргумента какой будет?
[35:08.340 --> 35:10.340]  Тоже constant&, да,
[35:10.340 --> 35:12.340]  потому что если я на 1& навешу 2&,
[35:12.340 --> 35:14.340]  получу 1&.
[35:14.340 --> 35:16.340]  Так, теперь передаю туда rx.
[35:16.340 --> 35:18.340]  Что будет?
[35:18.340 --> 35:20.340]  Так, ну, хорошо,
[35:20.340 --> 35:22.340]  т.е. это будет 0.
[35:22.340 --> 35:24.340]  Так, ну, хорошо,
[35:24.340 --> 35:26.340]  то, что int, все согласны,
[35:26.340 --> 35:28.340]  теперь что там по ссылкам?
[35:28.340 --> 35:30.340]  Почему 2?
[35:36.340 --> 35:38.340]  Ну, смотрите, действительно,
[35:38.340 --> 35:40.340]  rx имеет тип int2%,
[35:40.340 --> 35:42.340]  но нас же интересует,
[35:42.340 --> 35:44.340]  какое значение передается.
[35:44.340 --> 35:46.340]  Вот rx сам по себе,
[35:46.340 --> 35:48.340]  это что такое?
[35:48.340 --> 35:50.340]  Это L-value или R-value?
[35:50.340 --> 35:52.340]  L-value,
[35:52.340 --> 35:54.340]  блин, смотрите, какое у нас самое главное
[35:54.340 --> 35:56.340]  правило было?
[35:56.340 --> 35:58.340]  Помните, когда мы с вами говорили про,
[35:58.340 --> 36:00.340]  вы только начинали говорить про
[36:00.340 --> 36:02.340]  move-семантику, мы с вами разбирались,
[36:02.340 --> 36:04.340]  что такое L-value, что такое R-value?
[36:04.340 --> 36:06.340]  Какое было самое главное правило
[36:06.340 --> 36:08.340]  для L-value?
[36:08.340 --> 36:10.340]  Переменная это всегда L-value.
[36:10.340 --> 36:12.340]  У этого правила нет никаких исключений.
[36:12.340 --> 36:14.340]  Какая бы переменная перед вами не была,
[36:14.340 --> 36:16.340]  там, constant&, R-value ссылка,
[36:16.340 --> 36:18.340]  не R-value ссылка и так далее,
[36:18.340 --> 36:20.340]  это всегда L-value.
[36:20.340 --> 36:22.340]  Почему? Потому что переменная по определению
[36:22.340 --> 36:24.340]  это имена на область памяти.
[36:24.340 --> 36:26.340]  Если это область памяти, то это уже location-value,
[36:26.340 --> 36:28.340]  то есть L-value.
[36:28.340 --> 36:30.340]  Когда я передаю сюда rx,
[36:30.340 --> 36:32.340]  несмотря на то, что он имеет тип
[36:32.340 --> 36:34.340]  r-value ссылки, у rx есть конкретное место в памяти.
[36:34.340 --> 36:36.340]  Поэтому это L-value.
[36:36.340 --> 36:38.340]  Понятно?
[36:38.340 --> 36:40.340]  Поэтому функция в качестве параметра t
[36:40.340 --> 36:42.340]  выведет int&1,
[36:42.340 --> 36:44.340]  и хоть и будет
[36:44.340 --> 36:46.340]  иметь аргумент arg.
[36:46.340 --> 36:48.340]  Int&, да.
[36:48.340 --> 36:50.340]  То есть, на самом деле, арг
[36:50.340 --> 36:52.340]  будет являться ссылкой на rx.
[36:52.340 --> 36:54.340]  Арг будет ссылаться на ту же область памяти,
[36:54.340 --> 36:56.340]  что и rx.
[36:56.340 --> 36:58.340]  Теперь CRX.
[37:00.340 --> 37:02.340]  Константность не отбрасывается,
[37:02.340 --> 37:04.340]  поэтому const int&, а амперсант или 2 амперсанда?
[37:04.340 --> 37:06.340]  1 амперсант, да.
[37:06.340 --> 37:08.340]  CRX это переменная, переменная всегда L-value,
[37:08.340 --> 37:10.340]  поэтому вводится 1 амперсант.
[37:10.340 --> 37:12.340]  И, наконец, тип тоже const int&,
[37:12.340 --> 37:14.340]  давайте не буду писать.
[37:16.340 --> 37:18.340]  Сейчас мы переходим к примеру,
[37:18.340 --> 37:20.340]  следующий пример, они не совпадают.
[37:20.340 --> 37:22.340]  Фанкция от 0, какой тип выведется?
[37:22.340 --> 37:24.340]  Когда я переводю функцию от 0,
[37:24.340 --> 37:26.340]  выводится тип просто int.
[37:26.340 --> 37:28.340]  Да.
[37:28.340 --> 37:30.340]  Да.
[37:38.340 --> 37:40.340]  Да.
[37:40.340 --> 37:42.340]  Да-да-да.
[37:42.340 --> 37:44.340]  То есть,
[37:44.340 --> 37:46.340]  чем станет t,
[37:46.340 --> 37:48.340]  L-value ссылка или r-value ссылка,
[37:48.340 --> 37:50.340]  зависит от значения, которые я передаю,
[37:50.340 --> 37:52.340]  а не от типа аргументов, которые я передаю.
[37:56.340 --> 37:58.340]  Нет,
[37:58.340 --> 38:00.340]  потому что, смотрите,
[38:00.340 --> 38:02.340]  Rx сам по себе
[38:02.340 --> 38:04.340]  ссылается на r-value,
[38:04.340 --> 38:06.340]  но Rx сама по себе переменная,
[38:06.340 --> 38:08.340]  поэтому у нее есть короткое место памяти,
[38:08.340 --> 38:10.340]  я на нее могу спокойно ссылаться.
[38:10.340 --> 38:12.340]  Ну, спокойно,
[38:12.340 --> 38:14.340]  мы с вами это обсуждали
[38:14.340 --> 38:16.340]  на занятии по
[38:16.340 --> 38:18.340]  симматикой перемещения.
[38:18.340 --> 38:20.340]  Смотрите, что происходит, когда я пишу вот так вот,
[38:20.340 --> 38:22.340]  Rx равно 0.
[38:22.340 --> 38:24.340]  Вот это синтез,
[38:24.340 --> 38:26.340]  который позволяет создавать
[38:26.340 --> 38:28.340]  переменные,
[38:28.340 --> 38:30.340]  которые могут быть связаны только
[38:30.340 --> 38:32.340]  с временными значениями.
[38:32.340 --> 38:34.340]  Как это работает?
[38:34.340 --> 38:36.340]  Под капотом это работает примерно так.
[38:36.340 --> 38:38.340]  На самом деле, создается какая-то область памяти,
[38:38.340 --> 38:40.340]  в которую сохраняется значение 0,
[38:40.340 --> 38:42.340]  и которая называется Rx.
[38:42.340 --> 38:44.340]  То есть, R-value ссылка
[38:44.340 --> 38:46.340]  на самом деле создает
[38:46.340 --> 38:48.340]  участок памяти, в котором хранится это значение,
[38:48.340 --> 38:50.340]  и на самом деле,
[38:50.340 --> 38:52.340]  я могу менять, я могу написать Rx равно единице,
[38:52.340 --> 38:54.340]  тогда в этом месте памяти напишется единица.
[38:54.340 --> 38:56.340]  R-value ссылка создает
[38:56.340 --> 38:58.340]  для временных объектов
[38:58.340 --> 39:00.340]  не временное убежище, так скажем.
[39:02.340 --> 39:04.340]  Поэтому на Rx можно ссылаться
[39:04.340 --> 39:06.340]  так же, как и на обычный перемен int,
[39:06.340 --> 39:08.340]  потому что под Rx всегда скрывается конкретная область памяти,
[39:08.340 --> 39:10.340]  в которой хранится конкретное значение.
[39:20.340 --> 39:22.340]  А вот когда мы используем Rx,
[39:22.340 --> 39:24.340]  сам по себе Rx является L-value.
[39:24.340 --> 39:26.340]  То есть, L-value или R-value
[39:26.340 --> 39:28.340]  у нас нет никаких проблем.
[39:28.340 --> 39:30.340]  То есть, когда вы создали Rx,
[39:30.340 --> 39:32.340]  то все спокойно, вы же можете написать,
[39:32.340 --> 39:34.340]  Rx равно единице, Rx равно двойке,
[39:34.340 --> 39:36.340]  вы можете взять адрес Rx.
[39:40.340 --> 39:42.340]  Сам тип Rx это int,
[39:42.340 --> 39:44.340]  двойной персант, да.
[39:46.340 --> 39:48.340]  А когда мы используем Rx,
[39:48.340 --> 39:50.340]  то Rx является L-value.
[39:50.340 --> 39:52.340]  То есть, L-value или R-value это категория выражения,
[39:52.340 --> 39:54.340]  это категория вычисления,
[39:54.340 --> 39:56.340]  а не тип.
[40:02.340 --> 40:04.340]  У перемена Rx тип int,
[40:04.340 --> 40:06.340]  двойной персант.
[40:06.340 --> 40:08.340]  У Rx, как у выражения,
[40:08.340 --> 40:10.340]  тип int
[40:10.340 --> 40:12.340]  и категория значения L-value.
[40:18.340 --> 40:20.340]  Если внутри функции function
[40:20.340 --> 40:22.340]  мы напишем int,
[40:22.340 --> 40:24.340]  двойной персант,
[40:24.340 --> 40:26.340]  допустим R,
[40:26.340 --> 40:28.340]  равно arg,
[40:28.340 --> 40:30.340]  то это не скомпилируется.
[40:30.340 --> 40:32.340]  Почему? Потому что arg это L-value.
[40:32.340 --> 40:34.340]  Арк это переменная,
[40:34.340 --> 40:36.340]  а переменная всегда L-value.
[40:36.340 --> 40:38.340]  Ну, мне нормально.
[41:00.340 --> 41:02.340]  Когда вы создаете R-value ссылку,
[41:02.340 --> 41:04.340]  вы говорите,
[41:04.340 --> 41:06.340]  что я создаю переменную типа int,
[41:06.340 --> 41:08.340]  но ее пронициализировать
[41:08.340 --> 41:10.340]  я могу только R-value значения.
[41:10.340 --> 41:12.340]  Все.
[41:14.340 --> 41:16.340]  То есть, по сути, R-value ссылка
[41:16.340 --> 41:18.340]  это обычная переменная,
[41:18.340 --> 41:20.340]  но которую пронициализировать я могу только с помощью R-value.
[41:20.340 --> 41:22.340]  Все.
[41:22.340 --> 41:24.340]  А так как Rx это обычная переменная,
[41:24.340 --> 41:26.340]  просто своим отдельным приколом
[41:26.340 --> 41:28.340]  все остальные фишки переменных остаются
[41:28.340 --> 41:30.340]  такими же.
[41:34.340 --> 41:36.340]  Сейчас какая строчка?
[41:36.340 --> 41:38.340]  Эти строчка.
[41:38.340 --> 41:40.340]  Ну, смотрите, Rx это переменная,
[41:40.340 --> 41:42.340]  переменная это L-value,
[41:42.340 --> 41:44.340]  поэтому тип T выводится как int,
[41:44.340 --> 41:46.340]  амперсант.
[41:46.340 --> 41:48.340]  Потом я вместо типа T
[41:48.340 --> 41:50.340]  поставляю int, амперсант.
[41:50.340 --> 41:52.340]  У меня получается int, амперсант,
[41:52.340 --> 41:54.340]  на который я навесил еще 2 амперсанда.
[41:54.340 --> 41:56.340]  Вот по правилам сворачивания ссылок
[41:56.340 --> 41:58.340]  получается обычная ссылка.
[42:04.340 --> 42:06.340]  Если это универсальная ссылка,
[42:06.340 --> 42:08.340]  то в качестве T никогда не выведется
[42:08.340 --> 42:10.340]  int, двойной амперсант.
[42:10.340 --> 42:12.340]  Двойной амперсант в итоге получится.
[42:12.340 --> 42:14.340]  Давайте следующий пример.
[42:14.340 --> 42:16.340]  Если вы хотите, чтобы переменная
[42:16.340 --> 42:18.340]  передалась как R-value,
[42:18.340 --> 42:20.340]  вы должны писать stdmove.
[42:20.340 --> 42:22.340]  Если вы делаете stdmove,
[42:22.340 --> 42:24.340]  то тогда
[42:24.340 --> 42:26.340]  вы должны писать
[42:26.340 --> 42:28.340]  stdmove.
[42:28.340 --> 42:30.340]  Если вы делаете stdmove,
[42:30.340 --> 42:32.340]  то тогда
[42:32.340 --> 42:34.340]  компилятору ничего не останется,
[42:34.340 --> 42:36.340]  универсальной ссылке ничего не останется,
[42:36.340 --> 42:38.340]  предполагать, что вы
[42:38.340 --> 42:40.340]  передали туда R-value.
[42:40.340 --> 42:42.340]  Давайте добьем примеры
[42:42.340 --> 42:44.340]  и пойдем на перерыв.
[42:44.340 --> 42:46.340]  Фанкшн от нуля.
[42:46.340 --> 42:48.340]  Что выведется в качестве T?
[42:48.340 --> 42:50.340]  int, да, почему?
[42:50.340 --> 42:52.340]  Потому что 0 это R-value,
[42:52.340 --> 42:54.340]  когда передается R-value,
[42:54.340 --> 42:56.340]  то тип выводится как тип без ссылки.
[42:56.340 --> 42:58.340]  А тип аргумента какой будет?
[42:58.340 --> 43:00.340]  Вот int, 2 амперсанда.
[43:00.340 --> 43:02.340]  То есть тип T
[43:02.340 --> 43:04.340]  это int,
[43:04.340 --> 43:06.340]  но когда я вместо типа T подставляю int,
[43:06.340 --> 43:08.340]  у меня арг будет иметь тип int, 2 амперсанда.
[43:08.340 --> 43:10.340]  Вот краткие двойная ссылка.
[43:16.340 --> 43:18.340]  На int амперсанда навесили
[43:18.340 --> 43:20.340]  2 амперсанда. По правилу,
[43:20.340 --> 43:22.340]  если я на амперсант навешиваю 2 амперсанда,
[43:22.340 --> 43:24.340]  получаю 1 амперсант.
[43:24.340 --> 43:26.340]  А там я просто на int
[43:26.340 --> 43:28.340]  без амперсанда навесил 2 амперсанда.
[43:28.340 --> 43:30.340]  Если я на что-то без амперсанда навешиваю 2 амперсанда,
[43:30.340 --> 43:32.340]  получится, естественно, 2 амперсанда.
[43:32.340 --> 43:34.340]  Так, дальше.
[43:34.340 --> 43:36.340]  Вот, кстати, вот пример.
[43:36.340 --> 43:38.340]  Я перевел функцию function stdmove.x.
[43:38.340 --> 43:40.340]  Что будет?
[43:42.340 --> 43:44.340]  Так, почему?
[43:50.340 --> 43:52.340]  Смотрите, stdmove.x это что?
[43:52.340 --> 43:54.340]  Это L-value или R-value?
[43:54.340 --> 43:56.340]  R-value. Какое у нас правило?
[43:56.340 --> 43:58.340]  Если придается R-value,
[43:58.340 --> 44:00.340]  то тип T выводится как несылочный.
[44:00.340 --> 44:02.340]  То есть просто int, да.
[44:04.340 --> 44:06.340]  Так. Ну и аргумент arg
[44:06.340 --> 44:08.340]  будет иметь тип?
[44:08.340 --> 44:10.340]  Да, int 2 амперсанда.
[44:10.340 --> 44:12.340]  Так, stdmove от cx.
[44:14.340 --> 44:16.340]  Так, да, будет const int.
[44:18.340 --> 44:20.340]  Так, и тип?
[44:20.340 --> 44:22.340]  Да, const int 2 амперсанда.
[44:22.340 --> 44:24.340]  Так, теперь тут.
[44:24.340 --> 44:26.340]  Ну я подозреваю function, но в треугольном folds указываю int амперсант.
[44:28.340 --> 44:30.340]  От x. prisons будет равен тип T.
[44:30.340 --> 44:32.340]  Да, тип T будет равен
[44:32.340 --> 44:34.340]  int амперсанда, потому что, ну, я явно указал,
[44:34.340 --> 44:36.340]  что я хочу в качестве type A использовать int амперсант.
[44:36.340 --> 44:38.340]  Так, Sweep arg будет
[44:38.340 --> 44:40.340]  int амперсант, да.
[44:40.340 --> 44:42.340]  Так, теперь. тут я в качестве type T указываю
[44:42.340 --> 44:44.340]  int 2 амперсант. Что будет в качестве type T?
[44:44.340 --> 44:46.340]  Да, int 2 амперсант.
[44:46.340 --> 44:48.340]  Потому что я тут явно сказал, я хочу в качестве type T
[44:48.340 --> 44:50.340]  использовать int 2 амперсант.
[44:50.340 --> 44:52.340]  Вот, а arg будет иметь какой аргумент?
[44:52.340 --> 44:55.340]  да int двойной персант, потому что если она двойной персант,
[44:55.340 --> 44:57.340]  навешивает двойной персант, получается двойной персант.
[44:57.340 --> 44:59.340]  Вот, наконец, тут последние строчки.
[44:59.340 --> 45:01.340]  Тип T это int,
[45:01.340 --> 45:03.340]  а тип аргумента это
[45:03.340 --> 45:05.340]  да int двойной персант.
[45:05.340 --> 45:07.340]  Ну вот.
[45:07.340 --> 45:09.340]  По сути, мы
[45:09.340 --> 45:11.340]  после того, как вели универсальные ссылки,
[45:11.340 --> 45:13.340]  мы, по сути, решили проблему, которую ставили
[45:13.340 --> 45:15.340]  практически решили проблему,
[45:15.340 --> 45:17.340]  которую ставили изначально.
[45:17.340 --> 45:19.340]  То есть решение проблемы заключается в следующем.
[45:19.340 --> 45:21.340]  Давайте напишем функцию runningTime.
[45:21.340 --> 45:23.340]  Но в качестве
[45:23.340 --> 45:25.340]  второго аргумента будем принимать
[45:25.340 --> 45:27.340]  не ссылку или не будем принимать
[45:27.340 --> 45:29.340]  аргумент по значению, а будем принимать его по универсальной ссылке.
[45:29.340 --> 45:31.340]  Теперь почему
[45:31.340 --> 45:33.340]  это будет более-менее
[45:33.340 --> 45:35.340]  работать? Потому что если у меня будет
[45:35.340 --> 45:37.340]  функция function,
[45:37.340 --> 45:39.340]  я могу вызывать функцию function от нуля,
[45:39.340 --> 45:41.340]  и когда я буду вызывать
[45:41.340 --> 45:43.340]  функцию runningTime
[45:43.340 --> 45:45.340]  от функции от нуля, ноль будет
[45:45.340 --> 45:47.340]  передаваться в аргумент arg и будет передаваться
[45:47.340 --> 45:49.340]  по правой ссылке.
[45:49.340 --> 45:51.340]  Арг будет являться
[45:51.340 --> 45:53.340]  rvalue ссылкой на ноль.
[45:53.340 --> 45:55.340]  Когда я буду вызывать функцию function от int
[45:55.340 --> 45:57.340]  &value, просто одного &,
[45:57.340 --> 45:59.340]  то когда я буду передавать в runningTime
[45:59.340 --> 46:01.340]  function от x, x будет передаваться по lvalue ссылке.
[46:01.340 --> 46:03.340]  В зависимости от того, что я передал,
[46:03.340 --> 46:05.340]  то есть 0 rvalue или x lvalue,
[46:05.340 --> 46:07.340]  у меня аргумент arg будет
[46:07.340 --> 46:09.340]  являться либо lvalue ссылкой, либо rvalue ссылкой.
[46:11.340 --> 46:13.340]  То есть аргумент arg может мне
[46:13.340 --> 46:15.340]  сообщать о том, что
[46:15.340 --> 46:17.340]  на самом деле было передано
[46:17.340 --> 46:19.340]  функцию.
[46:21.340 --> 46:23.340]  Ну хорошо, аргумент arg понимает,
[46:23.340 --> 46:25.340]  что в него передали,
[46:25.340 --> 46:27.340]  lvalue или rvalue.
[46:27.340 --> 46:29.340]  Но
[46:29.340 --> 46:31.340]  все еще остается
[46:31.340 --> 46:33.340]  некоторая проблема.
[46:33.340 --> 46:35.340]  А именно проблема вот с чем.
[46:35.340 --> 46:37.340]  Давайте снова посмотрим на то,
[46:37.340 --> 46:39.340]  как реализована функция runningTime.
[46:39.340 --> 46:41.340]  Вот есть функция runningTime, она принимает
[46:41.340 --> 46:43.340]  функцию func по значению,
[46:43.340 --> 46:45.340]  она принимает аргумент arg по универсальной
[46:45.340 --> 46:47.340]  ссылке.
[46:47.340 --> 46:49.340]  У меня есть функция function l,
[46:49.340 --> 46:51.340]  которая принимает
[46:51.340 --> 46:53.340]  аргумент по lvalue ссылке.
[46:53.340 --> 46:55.340]  Я вызываю function l от x,
[46:55.340 --> 46:57.340]  все работает.
[46:57.340 --> 46:59.340]  Я вызываю runningTime от function от x,
[46:59.340 --> 47:01.340]  все работает.
[47:01.340 --> 47:03.340]  Я вызываю function l от 0,
[47:03.340 --> 47:05.340]  происходит ошибка импиляции,
[47:05.340 --> 47:07.340]  но это нормально.
[47:07.340 --> 47:09.340]  У меня function l принимает аргумент по ссылке,
[47:09.340 --> 47:11.340]  я передаю в нее 0, 0 это не lvalue,
[47:11.340 --> 47:13.340]  поэтому передать ее нельзя.
[47:13.340 --> 47:15.340]  Если у меня function l 0,
[47:15.340 --> 47:17.340]  у меня все работает.
[47:17.340 --> 47:19.340]  Вопрос почему?
[47:19.340 --> 47:21.340]  Я бы хотел, чтобы runningTime
[47:21.340 --> 47:23.340]  работал тогда и только тогда,
[47:23.340 --> 47:25.340]  когда работает обычный вызов function l
[47:25.340 --> 47:27.340]  от соответствующего аргумента.
[47:27.340 --> 47:29.340]  Вопрос, почему function l от 0
[47:29.340 --> 47:31.340]  не работает, а runningTime function l
[47:31.340 --> 47:33.340]  от 0 работает?
[47:33.340 --> 47:35.340]  Смотрите, в чем проблема.
[47:35.340 --> 47:37.340]  Что это тут передает function?
[47:37.340 --> 47:39.340]  Вот тут function я передаю rvalue,
[47:39.340 --> 47:41.340]  то есть 0, согласны?
[47:41.340 --> 47:43.340]  А что тут на самом деле
[47:43.340 --> 47:45.340]  я передаю в функцию function l?
[47:47.340 --> 47:49.340]  Я передаю арг.
[47:49.340 --> 47:51.340]  А что такое арг?
[47:53.340 --> 47:55.340]  Арг от перемена, а перемена это что?
[47:55.340 --> 47:57.340]  lvalue. То есть на самом деле,
[47:57.340 --> 47:59.340]  когда я использую вот этот runningTime,
[47:59.340 --> 48:01.340]  у меня в function l передается lvalue.
[48:01.340 --> 48:03.340]  Понятно? Понятна проблема.
[48:03.340 --> 48:05.340]  Когда я передаю
[48:05.340 --> 48:07.340]  function l
[48:07.340 --> 48:09.340]  от 0
[48:09.340 --> 48:11.340]  напрямую,
[48:11.340 --> 48:13.340]  это не работает.
[48:13.340 --> 48:15.340]  Но когда я function l передаю, грубо говоря,
[48:15.340 --> 48:17.340]  пишу вот так, int
[48:17.340 --> 48:19.340]  двойной имперсант
[48:19.340 --> 48:21.340]  arg
[48:21.340 --> 48:23.340]  равно 0, а потом
[48:23.340 --> 48:25.340]  пишу function
[48:25.340 --> 48:27.340]  l
[48:27.340 --> 48:29.340]  от arg,
[48:29.340 --> 48:31.340]  это работает. Почему?
[48:31.340 --> 48:33.340]  Потому что я создал переменную, а перемена
[48:33.340 --> 48:35.340]  это всегда lvalue.
[48:35.340 --> 48:37.340]  То есть, казалось бы,
[48:37.340 --> 48:39.340]  я старался, я подтел,
[48:39.340 --> 48:41.340]  я вводил универсальные ссылки, объяснял,
[48:41.340 --> 48:43.340]  как они работают, а переменная arg взяла
[48:43.340 --> 48:45.340]  и сказала, ну хорошо, я там буду
[48:45.340 --> 48:47.340]  либо правой ссылкой, либо левой ссылкой,
[48:47.340 --> 48:49.340]  но при этом я сама по себе arg, я всегда lvalue.
[48:49.340 --> 48:51.340]  Ну как бы
[48:51.340 --> 48:53.340]  старание на смарку. Почему?
[48:53.340 --> 48:55.340]  Потому что вот эта вот строчка func от arg
[48:55.340 --> 48:57.340]  в нее всегда будет передаваться lvalue.
[48:57.340 --> 48:59.340]  Проблема.
[49:01.340 --> 49:03.340]  Ну еще одна проблема,
[49:03.340 --> 49:05.340]  представь себе, что у меня есть функция function r,
[49:05.340 --> 49:07.340]  которая принимает int
[49:07.340 --> 49:09.340]  по rvalue ссылке.
[49:09.340 --> 49:11.340]  Она принимает int двойной имперсант,
[49:11.340 --> 49:13.340]  то есть рvalue ссылке, то есть она может принимать
[49:13.340 --> 49:15.340]  только временное значение. Если я вызываю function r
[49:15.340 --> 49:17.340]  от x, то возникает ce.
[49:17.340 --> 49:19.340]  Если я вызываю running time от function r от x,
[49:19.340 --> 49:21.340]  то возникает тоже ce. Почему? Потому что я function r
[49:21.340 --> 49:23.340]  передаю на самом деле arg, а arg
[49:23.340 --> 49:25.340]  это lvalue. Все нормально. Но при этом
[49:25.340 --> 49:27.340]  я могу вызвать function r от 0,
[49:27.340 --> 49:29.340]  а function r от 0 вызвать не могу,
[49:29.340 --> 49:31.340]  я могу вызвать function r от 0,
[49:31.340 --> 49:33.340]  а вызвать running time function r от 0 не могу. Почему?
[49:33.340 --> 49:35.340]  Потому что 0 при передаче функции
[49:35.340 --> 49:37.340]  running time внезапно превратится в аргумент arg,
[49:37.340 --> 49:39.340]  а arg это lvalue, и спокойно я передаю
[49:39.340 --> 49:41.340]  его в функцию function, что приводит
[49:41.340 --> 49:43.340]  к ошибке компиляции.
[49:43.340 --> 49:45.340]  Беда.
[49:45.340 --> 49:47.340]  То есть проблема спустилась
[49:47.340 --> 49:49.340]  на уровень дальше. Смотрите.
[49:49.340 --> 49:51.340]  Чему я научился с помощью универсальных ссылок?
[49:51.340 --> 49:53.340]  С помощью универсальных ссылок я научился
[49:53.340 --> 49:55.340]  определять, что
[49:55.340 --> 49:57.340]  передо мной.
[49:57.340 --> 49:59.340]  lvalue
[49:59.340 --> 50:01.340]  или lvalue.
[50:03.340 --> 50:05.340]  Но возникла следующая проблема.
[50:05.340 --> 50:07.340]  Какой в этом смысл, что я научился
[50:07.340 --> 50:09.340]  это определять? Если все в итоге,
[50:09.340 --> 50:11.340]  все равно сохранится
[50:11.340 --> 50:13.340]  в переменную,
[50:13.340 --> 50:15.340]  которая как всегда lvalue.
[50:19.340 --> 50:21.340]  Чего бы мне хотелось?
[50:23.340 --> 50:25.340]  Понятно, что тут объяснение проблемы.
[50:25.340 --> 50:27.340]  А чего бы на самом деле мне хотелось?
[50:27.340 --> 50:29.340]  Мне бы хотелось сделать следующее.
[50:29.340 --> 50:31.340]  Мне бы хотелось сделать так, что
[50:31.340 --> 50:33.340]  если у меня t это int аперсант,
[50:33.340 --> 50:35.340]  то я бы хотел функцию f
[50:37.340 --> 50:39.340]  передавать arg.
[50:41.340 --> 50:43.340]  А если у меня t выводится как int,
[50:43.340 --> 50:45.340]  то есть если я изначально передавал rvalue,
[50:45.340 --> 50:47.340]  то я бы хотел, чтобы аргумент arg
[50:47.340 --> 50:49.340]  и дальше передавался как rvalue.
[50:49.340 --> 50:51.340]  А как этого достичь? Как мне arg передать
[50:51.340 --> 50:53.340]  в другую функцию, как будто бы это было
[50:53.340 --> 50:55.340]  rvalue?
[50:55.340 --> 50:57.340]  В этом случае
[50:57.340 --> 50:59.340]  я бы хотел, чтобы передавался функцию f
[51:01.340 --> 51:03.340]  stdmove от arg.
[51:09.340 --> 51:11.340]  В зависимости от того, что они
[51:11.340 --> 51:13.340]  передали функцию running time
[51:13.340 --> 51:15.340]  либо lvalue, либо rvalue,
[51:15.340 --> 51:17.340]  я бы хотел передавать либо
[51:17.340 --> 51:19.340]  arg, либо
[51:19.340 --> 51:21.340]  stdmove от arg. Понятно?
[51:21.340 --> 51:23.340]  Грубо говоря, я бы хотел
[51:23.340 --> 51:25.340]  сделать условный stdmove.
[51:25.340 --> 51:27.340]  То есть если мне изначально передали lvalue,
[51:27.340 --> 51:29.340]  то я бы хотел не делать stmove. Если
[51:29.340 --> 51:31.340]  мне изначально передали rvalue, то я бы хотел потом
[51:31.340 --> 51:33.340]  в arg применить stmove. Понятно?
[51:33.340 --> 51:35.340]  То есть я бы хотел, в зависимости от условия, выполнить
[51:35.340 --> 51:37.340]  № sdmove и № sdmove.
[51:39.340 --> 51:41.340]  То есть вот чего хочется.
[51:41.340 --> 51:43.340]  Если в перемену arg
[51:43.340 --> 51:44.300]  передали lvalue,
[51:44.300 --> 51:46.300]  то вызывается fng от arg. Если в arg
[51:46.300 --> 51:47.340]  передали rvalue,
[51:47.340 --> 51:49.340]  то вызывается不行 от stdmove от arg.
[51:49.340 --> 51:51.340]  То есть, грубо говоря,
[51:51.340 --> 51:56.300]  хотелось бы написать что-то вот такое, да, если там varg передали lvalue, то вызываю
[51:56.300 --> 52:04.180]  func от arg, иначе вызываю func stdmove от arg. Вот. Возникает вопрос, на который, на самом деле, я уже
[52:04.180 --> 52:09.340]  дал ответ, но давайте для повторения спрошу. А как можно понять, что на самом деле
[52:09.340 --> 52:20.340]  передавали varg? lvalue или rvalue? Да, вот это можно определить по типу T. Понятно?
[52:20.340 --> 52:26.380]  Если у меня тип T это ссылка, то значит мне изначально в arg передавали
[52:26.380 --> 52:32.500]  lvalue. Если у меня T выводится без ссылки, значит меня в аргумент передавали rvalue.
[52:32.500 --> 52:36.060]  Понятно? То есть на самом деле вот этот код можно переписать, ну опять же этот
[52:36.060 --> 52:42.300]  псевдокод, да, можно переписать вот так. Если arg это lvalue ссылка, то значит вызываю
[52:42.300 --> 52:49.700]  func от arg. Если arg это не lvalue ссылка, то значит вызываю func stdmove от arg. Согласны?
[52:50.940 --> 53:01.940]  Окей. Ну и, собственно, вот то, что нам нужно, называется stdforward. Вот. То есть два
[53:01.940 --> 53:08.540]  столпа, на которых держится стемантика прямой передачи. Это универсальная ссылка
[53:08.540 --> 53:13.900]  и stdforward. Значит, что такое stdforward? Вот функция stdforward это буквально то, что
[53:13.900 --> 53:21.900]  нам нужно. stdforward это условный stdmove. Давайте даже пропишу отдельно. То есть stdforward
[53:21.900 --> 53:26.020]  это функция, которая либо делает stdmove, либо не делает stdmove в зависимости от
[53:26.020 --> 53:29.460]  какого-то условия. Но конкретное условие такое. Если я в stdforward передал
[53:29.460 --> 53:34.020]  обычную ссылку, то stdmove не делается. Если я в stdforward передал тип без ссылки,
[53:34.020 --> 53:40.260]  то stdmove делается. Вот. stdforward, то есть stdforward работает так. Я в него в
[53:40.380 --> 53:47.220]  треугольной скобке передаю аргумент. Точнее, в треугольной скобке передаю тип, с которым
[53:47.220 --> 53:52.580]  был передан аргумент, и в круглоскобке передаю сам аргумент. Вот. И дальше stdforward смотрит,
[53:52.580 --> 53:56.780]  если аргумент содержит ссылку, то он просто-напросто возвращает арк. Если тип не содержит
[53:56.780 --> 54:04.500]  амперсант, если тип не содержит один амперсант, то он возвращает stdmove от арка. Вот. То есть
[54:04.500 --> 54:08.780]  Решение заключается просто в следующем, вот в этой строчке.
[54:08.780 --> 54:16.380]  Я вызываю функцию fun.cd.forward от arg с большой буквы в круглоскопках
[54:16.380 --> 54:18.380]  arg с маленькой буквы, и все работает так, как надо.
[54:18.380 --> 54:23.740]  То есть, смотрите, решение состоит из двух частей.
[54:23.740 --> 54:27.060]  Первая часть – это прием по универсальной ссылке,
[54:27.060 --> 54:29.340]  для чего мне нужно принимать по универсальной ссылке,
[54:29.340 --> 54:32.300]  потому что я хочу уметь отличать lvalue от rvalue.
[54:32.700 --> 54:36.220]  Если передали lvalue, то у меня принимается аргумент по lvalue-ссылке,
[54:36.220 --> 54:39.220]  если я передаю rvalue, то у меня аргумент принимается по rvalue-ссылке.
[54:39.220 --> 54:42.220]  Дальше внутри функции возникает другая проблема.
[54:42.220 --> 54:45.220]  Допустим, arg – это lvalue-ссылка или rvalue-ссылка.
[54:45.220 --> 54:48.020]  Вне зависимости от этого, arg по себе является lvalue.
[54:48.020 --> 54:50.220]  Теперь мне нужно как-то суметь,
[54:50.220 --> 54:55.380]  arg передать в другую функцию с учетом того, какой изначально был тип
[54:55.380 --> 54:57.860]  передаваемого аргумента – lvalue или rvalue.
[54:57.860 --> 54:59.860]  Мне нужно сделать условность demove.
[54:59.860 --> 55:01.860]  Изначально условность demove – это stforward.
[55:01.860 --> 55:04.380]  Я говорю stforward, arg с большой буквы.
[55:04.380 --> 55:07.380]  По этим треугольным скобкам stforward понимает,
[55:07.380 --> 55:11.380]  что перед ним находится lvalue-ссылка или обычное,
[55:11.380 --> 55:14.380]  что изначально было передано lvalue или rvalue.
[55:14.380 --> 55:16.380]  Дальше в круглый скоб передаю arg.
[55:16.380 --> 55:19.380]  В этом случае stforward просто либо делает stmove, либо не делает stmove,
[55:19.380 --> 55:22.380]  в зависимости от того, что ему передали в треугольной скобке.
[55:22.380 --> 55:24.380]  Понятно?
[55:24.900 --> 55:26.900]  Окей?
[55:30.900 --> 55:31.900]  Ну вот.
[55:31.900 --> 55:34.900]  Теперь все прекрасно работает.
[55:34.900 --> 55:38.900]  У меня есть теперь две функции functionL и functionR.
[55:38.900 --> 55:41.900]  functionL может принимать аргумент только по lvalue-ссылке,
[55:41.900 --> 55:44.900]  а functionR может принимать аргумент только по rvalue-ссылке.
[55:44.900 --> 55:47.900]  Я вызываю functionL от x – это работает.
[55:47.900 --> 55:50.900]  И когда вызываю runningTime от functionL от x – все тоже работает.
[55:50.900 --> 55:53.900]  Почему? Потому что функция runningTime
[55:53.900 --> 55:56.900]  принимает аргумент по lvalue-ссылке,
[55:56.900 --> 56:00.900]  и дальше stforward тоже передает его функцию по lvalue-ссылке.
[56:00.900 --> 56:03.900]  Когда я вызываю functionL от 0 – у меня ошибка в компиляции.
[56:03.900 --> 56:06.900]  Почему? Потому что я не могу в int.ampersand передать 0.
[56:06.900 --> 56:10.900]  Когда я вызываю runningTime от functionL от 0 – тоже возникает ошибка в компиляции.
[56:10.900 --> 56:13.900]  Почему? Потому что когда я вызываю функцию func от stforward от arg,
[56:13.900 --> 56:16.900]  у меня stforward что делает? stforward делает move,
[56:16.900 --> 56:20.900]  потому что он видит, что изначально был 0, значит изначально был rvalue.
[56:20.900 --> 56:23.900]  Но stforward говорит, что я буду передавать функцию function,
[56:23.900 --> 56:26.900]  вот этот аргумент arg, с помощью stmove.
[56:26.900 --> 56:29.900]  Но функция func увидит, что в нее передали stmove, а stmove – это rvalue.
[56:29.900 --> 56:32.900]  И, соответственно, functionL скажет, что, ну, погодите, я не могу принимать rvalue,
[56:32.900 --> 56:35.900]  потому что я принимаю только int.ampersand.
[56:35.900 --> 56:38.900]  Поэтому возникнет ошибка в компиляции.
[56:38.900 --> 56:41.900]  Ну и последний блок, functionR от x будет CE.
[56:41.900 --> 56:44.900]  RunningTime от functionR от x будет тоже CE. Почему?
[56:44.900 --> 56:47.900]  Потому что во второй строчке функции runningTime у меня будет stforward.
[56:47.900 --> 56:50.900]  stforward не будет вызывать stmove,
[56:50.900 --> 56:53.900]  а functionR может принимать только rvalue значения.
[56:53.900 --> 56:56.900]  Ну а в последней строчке все сработает, потому что functionR от 0 все понятно,
[56:56.900 --> 56:59.900]  то есть там int.ampersand, и в runningTime functionR от 0 тоже все будет окей.
[56:59.900 --> 57:02.900]  Почему? Потому что stforward просто применен к аргу stmove,
[57:02.900 --> 57:05.900]  и тогда функция functionR примет stmove от arg,
[57:05.900 --> 57:08.900]  что будет являться rvalue значения.
[57:08.900 --> 57:11.900]  Окей?
[57:11.900 --> 57:14.900]  Понятно?
[57:14.900 --> 57:17.900]  То есть в целом картинка вот такая.
[57:24.900 --> 57:27.900]  Вот. Если я передаю сюда, ну, допустим, x,
[57:27.900 --> 57:30.900]  сюда я передаю 0, ну, путь такой.
[57:30.900 --> 57:33.900]  Когда я передаю x, у меня t выводится как int.ampersand,
[57:33.900 --> 57:36.900]  и все это в итоге, ну, давайте, тут вот...
[57:40.900 --> 57:43.900]  Вот. Когда мне x попадает в функцию,
[57:43.900 --> 57:46.900]  то тип t выводится как int.ampersand,
[57:46.900 --> 57:49.900]  и arg будет являться ссылкой на вот это самое x.
[57:49.900 --> 57:52.900]  Вот. Просто когда я делаю stforward...
[57:56.900 --> 57:59.900]  Вот. У меня функция f как будто бы вызывает просто f от arg.
[57:59.900 --> 58:02.900]  Ну, а так как arg это ссылка на x, то как будто бы я вызываю напрямую f от x.
[58:02.900 --> 58:05.900]  Вот. Если я сюда передаю 0,
[58:05.900 --> 58:08.900]  то тип t выводится как int, arg будет являться правой ссылкой на 0.
[58:08.900 --> 58:11.900]  Ну, при этом arg сам по себе это lvalue.
[58:11.900 --> 58:14.900]  Когда я применяю stforward, stforward видит, что t это int,
[58:14.900 --> 58:17.900]  и поэтому он в функции f передает f от stmove от arg.
[58:17.900 --> 58:20.900]  Вот. Поэтому когда я передаю 0, у меня вызывается stmove от arg.
[58:20.900 --> 58:23.900]  Когда я передаю x, у меня вызывается просто f от arg.
[58:23.900 --> 58:26.900]  Окей? Да.
[58:30.900 --> 58:33.900]  Ну, stforward устроено довольно сложно.
[58:33.900 --> 58:36.900]  Заметьте, что мы с вами не говорили про ток и реализован stmove, на самом деле.
[58:36.900 --> 58:39.900]  Вот. И про ток реализован stforward.
[58:39.900 --> 58:42.900]  То есть, про это мы поговорим ближе к концу семестра,
[58:42.900 --> 58:45.900]  когда будем подробнее говорить про шаблоны.
[58:45.900 --> 58:48.900]  Вот. Пока просто примите на веру, что stmove работает как надо,
[58:48.900 --> 58:51.900]  и stforward тоже работает как надо. Окей?
[58:56.900 --> 58:59.900]  Так, есть ли вопросы?
[58:59.900 --> 59:02.900]  Да, еще раз хочу, да, еще обращу внимание вот на этот комментарий.
[59:02.900 --> 59:05.900]  Заметьте, что в отличие stmove,
[59:05.900 --> 59:08.900]  stforward обязательно принимает треугольные скобки,
[59:08.900 --> 59:11.900]  ну, arg, принимает тип.
[59:11.900 --> 59:14.900]  Вот. То есть, когда мы с вами вызывали stmove,
[59:14.900 --> 59:17.900]  мы с вами просто писали stmove от x.
[59:17.900 --> 59:20.900]  Когда мы с вами пишем stforward,
[59:20.900 --> 59:23.900]  нам издать нужно передать в него аргумент,
[59:23.900 --> 59:26.900]  ну, вот этот вот самый тип,
[59:26.900 --> 59:29.900]  с которым был создан x.
[59:29.900 --> 59:32.900]  Почему? Потому что stmove, на самом деле,
[59:32.900 --> 59:35.900]  неважно, какой был изначально тип у x.
[59:35.900 --> 59:38.900]  В детстве какого изначального типа у x был,
[59:38.900 --> 59:41.900]  он просто-напросто приводит его к RLU ссылки, и все.
[59:41.900 --> 59:44.900]  А stforward, ему важно, чем был изначально x,
[59:44.900 --> 59:47.900]  то есть вот этот вот arg. Ему важно, чем он был изначально.
[59:47.900 --> 59:50.900]  Он был изначально int and percent, и он изначально был просто int.
[59:50.900 --> 59:53.900]  И в зависимости от этого, в зависимости от того, какой тип тут указан,
[59:53.900 --> 59:56.900]  он либо будет делать stmove, либо не будет делать stmove. Окей?
[59:56.900 --> 59:59.900]  То есть stforward обязан...
[59:59.900 --> 01:00:02.900]  То есть мы обязаны писать stforward с треугольными скобками.
[01:00:02.900 --> 01:00:05.900]  Ну, на самом деле, если вы напишете без треугольных скобок,
[01:00:05.900 --> 01:00:08.900]  а нет, там проблема в том, что скомпилируется, ну ладно.
[01:00:08.900 --> 01:00:11.900]  Обязательно передавайте с треугольными скобками.
[01:00:11.900 --> 01:00:14.900]  Так, есть ли вопросы?
[01:00:16.900 --> 01:00:19.900]  Хорошо.
[01:00:19.900 --> 01:00:22.900]  Ну и, собственно, давайте теперь
[01:00:22.900 --> 01:00:27.900]  объединим знания с сегодняшнего занятия и прошлого.
[01:00:27.900 --> 01:00:30.900]  Собственно,
[01:00:30.900 --> 01:00:33.900]  ну вот, вначале уже нам сказали, что, ну точнее,
[01:00:33.900 --> 01:00:36.900]  дали рекомендацию, что, ну вообще говоря, было бы неплохо
[01:00:36.900 --> 01:00:39.900]  написать функцию running time, которая может принимать произвольное количество аргументов,
[01:00:39.900 --> 01:00:42.900]  потому что, ну, вообще говоря, интересно узнавать время работы не только функции
[01:00:42.900 --> 01:00:45.900]  от одного аргумента, но и функции от нуля аргументов, от двух аргументов,
[01:00:45.900 --> 01:00:48.900]  от трех, ну и так далее. Как сделать это решение более универсальным?
[01:00:48.900 --> 01:00:51.900]  Ну, собственно, использовать шаблоны
[01:00:51.900 --> 01:00:54.900]  с переменом числом аргументов.
[01:00:54.900 --> 01:00:57.900]  Пропишем тут.
[01:00:57.900 --> 01:01:00.900]  Template.
[01:01:00.900 --> 01:01:03.900]  Класс.
[01:01:03.900 --> 01:01:06.900]  Ну, собственно, шаблонный тип для функции.
[01:01:06.900 --> 01:01:09.900]  Ну и дальше класс многоточие
[01:01:09.900 --> 01:01:12.900]  args.
[01:01:12.900 --> 01:01:15.900]  Ну дальше там
[01:01:15.900 --> 01:01:18.900]  функция возвращает double.
[01:01:18.900 --> 01:01:21.900]  Run time от
[01:01:21.900 --> 01:01:24.900]  f, f и дальше принимаем
[01:01:24.900 --> 01:01:27.900]  произвольное количество аргументов, и при этом произвольное количество аргументов
[01:01:27.900 --> 01:01:30.900]  по универсальной ссылке. Обратите внимание.
[01:01:30.900 --> 01:01:33.900]  args, двойной амперсант, многоточие,
[01:01:33.900 --> 01:01:36.900]  args.
[01:01:39.900 --> 01:01:42.900]  Вот. Ага.
[01:01:42.900 --> 01:01:45.900]  То есть я принимаю какое угодно количество шаблонных параметров
[01:01:45.900 --> 01:01:48.900]  по универсальной ссылке. Ага.
[01:01:48.900 --> 01:01:51.900]  Что я делаю дальше? Ну дальше я вычисляю
[01:01:51.900 --> 01:01:54.900]  время начала работы функции.
[01:01:57.900 --> 01:02:00.900]  std clock. Вот. И дальше вызываю
[01:02:00.900 --> 01:02:03.900]  функцию f от аргументов. Но чтобы передать аргументы
[01:02:03.900 --> 01:02:06.900]  функции f, что мне нужно сделать? Что мне нужно применить к каждому аргументу?
[01:02:06.900 --> 01:02:09.900]  К каждому аргументу мне нужно применить
[01:02:09.900 --> 01:02:12.900]  условный std move, согласны? То есть std forward.
[01:02:12.900 --> 01:02:15.900]  То есть я пишу f
[01:02:15.900 --> 01:02:18.900]  от std forward
[01:02:18.900 --> 01:02:21.900]  от
[01:02:21.900 --> 01:02:24.900]  параметра args,
[01:02:24.900 --> 01:02:27.900]  круглые скобки args,
[01:02:27.900 --> 01:02:30.900]  и многоточие.
[01:02:30.900 --> 01:02:33.900]  Ну по-моему, это распаковка пакета args.
[01:02:33.900 --> 01:02:36.900]  Я применил к args какую-то функцию, и после нее
[01:02:36.900 --> 01:02:39.900]  написал многоточие. Нормально?
[01:02:39.900 --> 01:02:42.900]  Вот. Ну и дальше, собственно, return.
[01:02:42.900 --> 01:02:45.900]  Ну и return, блабла, то, что там написано.
[01:02:45.900 --> 01:02:48.900]  Вот.
[01:02:48.900 --> 01:02:51.900]  Понятно?
[01:02:53.900 --> 01:02:56.900]  Ну вот. Ну я просто-напросто заменил предыдущее решение
[01:02:56.900 --> 01:02:59.900]  с одним аргументом на решение с произвольным количеством
[01:02:59.900 --> 01:03:02.900]  аргументов. То есть ну, что тут изменилось? Заменилось то, что я принимаю
[01:03:02.900 --> 01:03:05.900]  теперь args двойным персом многоточия, ну что говорит
[01:03:05.900 --> 01:03:08.900]  том, что у меня несколько, что я принимаю много аргументов
[01:03:08.900 --> 01:03:11.900]  произвольное количество. Вот. Ну и наконец я forward принимаю
[01:03:11.900 --> 01:03:14.900]  к одному аргументу, а к несколько аргументу, то есть
[01:03:14.900 --> 01:03:17.900]  применяю sd forward к args, ну и дальше распаковывает
[01:03:17.900 --> 01:03:20.900]  пакет для передачи функции.
[01:03:20.900 --> 01:03:23.900]  Нормально?
[01:03:23.900 --> 01:03:26.900]  Вот.
[01:03:26.900 --> 01:03:29.900]  Так. Ну и давайте рассмотрим примеры,
[01:03:29.900 --> 01:03:32.900]  давайте просмотрим примеры применения вот этих самых
[01:03:32.900 --> 01:03:35.900]  универсальных ссылок. Ну первый пример применения это
[01:03:35.900 --> 01:03:38.900]  собственно имплейсбэк, то есть теперь понятно, как использовать имплейсбэк.
[01:03:38.900 --> 01:03:41.900]  А теперь я что делаю? Я принимаю все эти аргументы, естественно,
[01:03:41.900 --> 01:03:44.900]  по универсальной ссылке. Ну а дальше, собственно, передаю их в соответствующий
[01:03:44.900 --> 01:03:47.900]  конструктор с помощью sd forward. Вот.
[01:03:47.900 --> 01:03:50.900]  И еще примеры. Ну смотрите,
[01:03:50.900 --> 01:03:53.900]  так, ну наверняка вы приступали уже к решению
[01:03:53.900 --> 01:03:56.900]  задач по умным указателям, вот. И там в качестве
[01:03:56.900 --> 01:03:59.900]  дополнительного задания указано там реализовать
[01:03:59.900 --> 01:04:02.900]  функции makeunique и makeshared. Вот.
[01:04:02.900 --> 01:04:05.900]  Собственно, смотрите, makeunique и makeshared, по сути, те же самые
[01:04:05.900 --> 01:04:08.900]  функции, что имплейсбэк. Ну что делать, например, makeunique?
[01:04:08.900 --> 01:04:11.900]  makeunique принимает в треугольных скобках
[01:04:11.900 --> 01:04:14.900]  тип указателя, который я должен создать, вот.
[01:04:14.900 --> 01:04:17.900]  А в круглой скобке принимает параметры конструктора, с которым этот объект
[01:04:17.900 --> 01:04:20.900]  нужно создать. Да? Вот.
[01:04:20.900 --> 01:04:23.900]  Ну и, собственно, давайте реализуем функцию
[01:04:23.900 --> 01:04:26.900]  makeunique. То есть как она устроена?
[01:04:26.900 --> 01:04:29.900]  Она принимает,
[01:04:29.900 --> 01:04:32.900]  ну первым аргументом в треугольных скобках она обязательно
[01:04:32.900 --> 01:04:35.900]  принимает тип указателя, который нужно создать,
[01:04:35.900 --> 01:04:38.900]  вот. А дальше она принимает параметры конструктора.
[01:04:38.900 --> 01:04:41.900]  Вот. Что она возвращает? Она возвращает unique.ptr.
[01:04:44.900 --> 01:04:47.900]  Unique.ptr, который указывает на аргументе ptr.
[01:04:47.900 --> 01:04:50.900]  И функция называется
[01:04:50.900 --> 01:04:53.900]  makeunique.ptr.
[01:04:54.900 --> 01:04:59.900]  И функция называется
[01:04:59.900 --> 01:05:02.900]  makeunique. Вот. И эта функция принимает
[01:05:02.900 --> 01:05:05.900]  произвольное количество параметров. Ну при этом, конечно, я заранее не знаю.
[01:05:05.900 --> 01:05:08.900]  То есть, естественно, я не знаю, да. А вот конструктор,
[01:05:08.900 --> 01:05:11.900]  конструктор типа t. Он принимает они аргументы по ссылке,
[01:05:11.900 --> 01:05:14.900]  он принимает аргументы по RVLU ссылке. То есть этого я ничего не знаю.
[01:05:14.900 --> 01:05:17.900]  Вот. Так я ничего этого не знаю, я простоris принимаю аргументы
[01:05:17.900 --> 01:05:20.900]  по универсальной ссылке. Вот. И универсальная ссылка
[01:05:20.900 --> 01:05:24.520]  разберется, каким аргументам нужно давать амперсан,
[01:05:24.520 --> 01:05:26.720]  каким аргументам не нужно давать амперсан.
[01:05:26.720 --> 01:05:28.360]  Ну и, собственно, решение просто запущается в том,
[01:05:28.360 --> 01:05:40.760]  чтобы написать return, unique ptr от t, ну и, собственно,
[01:05:40.760 --> 01:05:46.480]  ставлю туда выделенную память, new t, ну давайте тут напишу,
[01:05:46.480 --> 01:06:13.040]  new t, forward, new t от, и передаю туда все аргументы, и передаю туда все
[01:06:13.040 --> 01:06:15.660]  аргументы arcs, но при этом все аргументы передаю, ну,
[01:06:15.660 --> 01:06:19.400]  с помощью stmov, либо, ну, короче, с помощью условного stmov, да, то есть
[01:06:19.400 --> 01:06:22.040]  в каждом аргументе должен либо применить stmov, либо, либо не применить
[01:06:22.040 --> 01:06:42.080]  stmov. Делается с помощью std forward, std forward от arcs, arcs многоточили, вот, и так, вот, понятно?
[01:06:42.080 --> 01:06:46.760]  То есть, вот, я принял аргументы, я не знаю, какие аргументы там должны приниматься,
[01:06:46.760 --> 01:06:50.320]  по ссылке, не по ссылке, в общем, универсальная ссылка сама разберется, а дальше все эти
[01:06:50.320 --> 01:06:58.000]  аргументы я передаю в конструктор new, да, я пишу new t и говорю, что вот этот объект t
[01:06:58.000 --> 01:07:01.600]  нужно создать с помощью вот этих вот аргументов, вот, но при этом каждый аргумент я передаю
[01:07:01.600 --> 01:07:07.000]  либо с помощью stmov, либо с помощью, ну, либо просто с помощью обычной передачи, да, по ссылке, вот,
[01:07:07.000 --> 01:07:10.640]  то есть std forward сам решает, какой аргумент нужно, какому аргументу нужно применить stmov,
[01:07:10.640 --> 01:07:21.960]  какому аргументу не нужно применять, окей? Вот, это, так, презентация поехала, ну ладно, в общем,
[01:07:21.960 --> 01:07:25.720]  это первый пример. Вот, второй пример, это, собственно, то, что мы с вами проговорили,
[01:07:25.720 --> 01:07:30.800]  это emplaceback, да, emplaceback тоже принимает аргументы по универсальной ссылке и дальше,
[01:07:30.800 --> 01:07:37.880]  ну, каким-то образом создает объект в нужном месте в памяти, вот. Ну или, например, у стека,
[01:07:38.140 --> 01:07:42.340]  точнее у списка, у 2-вязаного списка, у 1-вязаного списка, bricks++, есть template,
[01:07:42.340 --> 01:07:48.040]  да, который просто позволяет создать элемент в нужном месте, ну, просто позволяет создать
[01:07:48.040 --> 01:07:52.240]  элемент, ну, с помощью параметров конструктора, вот. Например, у стека, да, у стека можно
[01:07:52.240 --> 01:07:57.420]  сделать template, который принимает параметры конструктора carrots, вот, создает новый узел,
[01:07:57.420 --> 01:08:05.380]  код semua, вот, принимает голову, хет, и создает там объект типа t, ну, объект, создает объект типа t
[01:08:05.380 --> 01:08:07.180]  с помощью параметров конструктора args.
[01:08:07.180 --> 01:08:11.680]  Но при этом предварительно каждый аргумент args оборачивается в std forward,
[01:08:11.680 --> 01:08:15.180]  чтобы либо передавать его с помощью std move, либо передавать его просто по обычной ссылке.
[01:08:19.180 --> 01:08:20.180]  Окей?
[01:08:21.680 --> 01:08:22.680]  Нормально?
[01:08:24.180 --> 01:08:25.480]  Так, ну давайте задам вопрос.
[01:08:25.480 --> 01:08:27.980]  Понятно ли, вот допустим, вот смотрите, вот есть мой кюник,
[01:08:27.980 --> 01:08:30.980]  понятно ли, почему мы тут принимаем аргументы по универсальной ссылке
[01:08:30.980 --> 01:08:33.180]  и почему мы передаем их с помощью std forward?
[01:08:33.980 --> 01:08:38.480]  Вот почему, все ли понимают на текущий момент, почему нужна вот эта вот связка?
[01:08:39.480 --> 01:08:40.980]  Или есть какие-то вопросы?
[01:08:42.480 --> 01:08:43.480]  Да, давайте.
[01:08:43.980 --> 01:08:44.980]  Так.
[01:08:46.480 --> 01:08:48.480]  Хорошо, давайте пример.
[01:08:56.980 --> 01:08:59.480]  Давайте напишем класс.
[01:09:00.280 --> 01:09:07.280]  Пусть у меня есть класс A, и у него поля, и у него есть два поля.
[01:09:07.280 --> 01:09:11.280]  Int % x и просто int y.
[01:09:16.280 --> 01:09:18.280]  И в публичной части у него есть такой конструктор.
[01:09:20.780 --> 01:09:25.780]  Int % a, int b.
[01:09:26.080 --> 01:09:29.080]  Так, ну, ссылка x инициализируется ссылкой a,
[01:09:31.080 --> 01:09:34.080]  а значение y инициализируется значением b.
[01:09:38.080 --> 01:09:40.080]  Ну и там еще какие-то методы, неважно.
[01:09:41.080 --> 01:09:42.080]  Пока понятно.
[01:09:43.080 --> 01:09:48.080]  Все, у меня есть какой-то класс A, у которого в конструкторе есть два параметра.
[01:09:48.080 --> 01:09:53.080]  Первый параметр принимается по обычной ссылке, второй параметр принимается по параметрам.
[01:09:53.380 --> 01:09:57.380]  Первый параметр принимается по обычной ссылке, второй параметр принимается по значению.
[01:09:57.380 --> 01:09:58.380]  Окей?
[01:09:59.380 --> 01:10:01.380]  Теперь, что я делаю?
[01:10:02.380 --> 01:10:03.380]  Теперь я вызываю...
[01:10:04.380 --> 01:10:05.380]  Теперь я хочу создать...
[01:10:10.380 --> 01:10:12.380]  Теперь я хочу создать умный указатель.
[01:10:13.380 --> 01:10:14.380]  Я пишу.
[01:10:17.380 --> 01:10:21.380]  ptr равно make.
[01:10:23.380 --> 01:10:25.380]  Unique, вот a.
[01:10:26.380 --> 01:10:28.380]  Ну и, допустим, я туда передаю...
[01:10:29.380 --> 01:10:31.380]  Давайте, тут, допустим, есть int a,
[01:10:32.380 --> 01:10:36.380]  равное 0 и int b, равное 1.
[01:10:36.380 --> 01:10:40.380]  Вот, я туда передаю ab.
[01:10:42.380 --> 01:10:44.380]  Понятно, чего я хочу достичь?
[01:10:46.380 --> 01:10:50.380]  Я хочу создать, грубо говоря, да, то есть, грубо говоря, что я хочу?
[01:10:50.680 --> 01:10:58.680]  Я хочу создать new a от ab, да, ну при этом завернуть это в умный указатель.
[01:11:01.680 --> 01:11:05.680]  make.unique создает умный указатель на объект a, unique.ptr.
[01:11:05.980 --> 01:11:07.980]  Мы пишем просто аналог функции...
[01:11:10.980 --> 01:11:12.980]  Есть функция cd make.unique.
[01:11:15.980 --> 01:11:19.980]  Мы сейчас обсуждаем, как она устроена, на примере своей собственной реализации.
[01:11:21.980 --> 01:11:22.980]  Окей?
[01:11:23.980 --> 01:11:25.980]  Ох, ну тут, грубо говоря, грубо говоря, что делает make.unique?
[01:11:25.980 --> 01:11:29.980]  Грубо говоря, make.unique просто устроит умный указатель.
[01:11:30.280 --> 01:11:36.280]  То есть, в конструктор a я передаю переменную a и передаю переменную b.
[01:11:37.280 --> 01:11:43.280]  Но при этом, при этом сам объект a сохранит ссылку на a и сохранит просто значение b.
[01:11:45.280 --> 01:11:46.280]  В чем проблема?
[01:11:47.280 --> 01:11:49.280]  Представьте себе, что я написал make.unique.ptr.
[01:11:50.280 --> 01:11:52.280]  Я написал make.unique.ptr.
[01:11:53.280 --> 01:11:55.280]  Я написал make.unique.ptr.
[01:11:55.580 --> 01:11:56.580]  В чем проблема?
[01:11:57.580 --> 01:12:01.580]  Представьте себе, что я написал make.unique.ptr без вот этого всего.
[01:12:08.580 --> 01:12:14.580]  Просто args многоточие, и тут просто args многоточие.
[01:12:16.580 --> 01:12:17.580]  Что сломается?
[01:12:17.580 --> 01:12:21.580]  Вот я тут все аргументы принял по значению, и тут просто передаю все аргументы по значению.
[01:12:21.580 --> 01:12:22.580]  Что сломается?
[01:12:25.580 --> 01:12:26.580]  Чего я хотел?
[01:12:26.580 --> 01:12:34.580]  Я бы хотел, чтобы x, ссылка x, ссылалась на переменную a.
[01:12:34.580 --> 01:12:35.580]  Согласны?
[01:12:36.580 --> 01:12:41.580]  То есть, когда я пишу new a в кругу скобки ab, у меня вот этот первый параметр уходит вот сюда,
[01:12:41.580 --> 01:12:43.580]  то есть сохранится на его ссылке.
[01:12:43.580 --> 01:12:47.580]  И дальше ссылка на x ссылается на то же самое, на что ссылается вот это a.
[01:12:47.580 --> 01:12:49.580]  А вот это a и то же самое, что и вот это a. Согласны?
[01:12:49.880 --> 01:12:50.880]  Так.
[01:12:50.880 --> 01:12:54.880]  А что произошло, когда я передал аргументы a и b в функцию make.unique?
[01:12:56.880 --> 01:12:59.880]  Вот эта передача почему? По ссылке, по значению.
[01:13:02.880 --> 01:13:04.880]  Да, эта передача просто по значению.
[01:13:05.880 --> 01:13:07.880]  Тут стоит args многоточие, args.
[01:13:07.880 --> 01:13:13.880]  То есть, я просто взял и вот эти a и b скопировал вот сюда.
[01:13:14.180 --> 01:13:15.180]  Так.
[01:13:16.180 --> 01:13:20.180]  И когда я написал ut от args, на что создалась ссылка вот эта x?
[01:13:24.180 --> 01:13:26.180]  Вот эта x теперь ссылается в локальную копию.
[01:13:26.180 --> 01:13:28.180]  Понятно?
[01:13:28.180 --> 01:13:32.180]  То есть, после выполнения вот этого кода, у меня вот этот объект, который будет создан,
[01:13:32.180 --> 01:13:34.180]  он будет ссылаться в локальную копию.
[01:13:34.180 --> 01:13:37.180]  После того, как функция make.unique завершится, все, функция make.unique завершилась,
[01:13:37.180 --> 01:13:40.180]  локальные копии уничтожились, на что теперь ссылается x?
[01:13:40.480 --> 01:13:42.480]  Ни на что. Теперь висячий указатель.
[01:13:42.480 --> 01:13:44.480]  Он ссылается на память, которая уже удалена.
[01:13:44.480 --> 01:13:46.480]  Понятно?
[01:13:46.480 --> 01:13:50.480]  То есть, с помощью такой реализации у меня не получилось достичь того,
[01:13:50.480 --> 01:13:54.480]  чтобы a напрямую передалось непосредственно в конструктор a.
[01:13:54.480 --> 01:13:56.480]  Окей?
[01:13:56.480 --> 01:13:57.480]  Почему?
[01:13:57.480 --> 01:14:01.480]  Потому что тут я все принимал по значению u.
[01:14:01.480 --> 01:14:03.480]  Да?
[01:14:03.480 --> 01:14:05.480]  Теперь.
[01:14:06.480 --> 01:14:08.480]  Теперь давайте добавим универсальную ссылку.
[01:14:08.780 --> 01:14:10.780]  Вот для чего нужна универсальная ссылка?
[01:14:10.780 --> 01:14:12.780]  Ну, на самом деле тут...
[01:14:12.780 --> 01:14:15.780]  Давайте тут еще int, двойной персант y добавим.
[01:14:15.780 --> 01:14:19.780]  Вот. Тут вместо b напишем 0.
[01:14:22.780 --> 01:14:24.780]  Вот.
[01:14:27.780 --> 01:14:29.780]  Ну, давайте двойной персант.
[01:14:30.080 --> 01:14:32.080]  Сдамов от b.
[01:14:32.080 --> 01:14:34.080]  Ну, ладно, так плохо.
[01:14:34.080 --> 01:14:36.080]  Нет, все хорошо, все нормально.
[01:14:36.080 --> 01:14:38.080]  Это сработает.
[01:14:38.080 --> 01:14:39.080]  Вот.
[01:14:39.080 --> 01:14:43.080]  Теперь смотрите, что произойдет, если я добавлю просто один аперсант.
[01:14:43.080 --> 01:14:47.080]  Если я добавлю один аперсант, то я не смогу туда передать 0.
[01:14:47.080 --> 01:14:49.080]  Да?
[01:14:49.080 --> 01:14:50.080]  Поэтому что мне нужно делать?
[01:14:50.080 --> 01:14:52.080]  Мне нужно передавать универсальные ссылки.
[01:14:52.080 --> 01:14:53.080]  Почему?
[01:14:53.080 --> 01:14:55.080]  Потому что универсальная ссылка мне гарантирует,
[01:14:55.080 --> 01:14:57.080]  что каждый аргумент, который я добавил,
[01:14:57.220 --> 01:14:59.220]  это 소фт будет передавать по обычной ссылке.
[01:14:59.220 --> 01:15:01.220]  Влюс это будет передать по RVEL.
[01:15:01.220 --> 01:15:03.220]  Понятно?
[01:15:04.340 --> 01:15:06.700]  추 동안
[01:15:06.700 --> 01:15:08.660]  то здесь
[01:15:08.820 --> 01:15:11.860]  все вот тут требует универсальный ссылку,
[01:15:11.860 --> 01:15:13.860]  чтобы каждый аргумент был передан либо по ссылке, либо универсальный ссылки.
[01:15:13.920 --> 01:15:16.980]  Если угодно просто надо,
[01:15:16.980 --> 01:15:19.980]  чтобы вы не производить лишних копирований.
[01:15:19.980 --> 01:15:21.980]  Вот. Для чего мы передаем по ссылке?
[01:15:21.980 --> 01:15:23.980]  Чтобы избирать лишних копирований.
[01:15:23.980 --> 01:15:25.980]  Влу тоже я передаю, чтобы избирать лишних копирований.
[01:15:25.980 --> 01:15:27.980]  Что произойдет, если я тут просто на австе передам args?
[01:15:27.980 --> 01:15:29.980]  Если я просто передам args,
[01:15:31.980 --> 01:15:33.980]  тогда из-за этого параметра конструктора,
[01:15:33.980 --> 01:15:35.980]  из-за этого параметра конструктора, у меня вот эта
[01:15:35.980 --> 01:15:37.980]  строчка не скомпилируется. Почему? Потому что
[01:15:37.980 --> 01:15:39.980]  args — это переменные.
[01:15:39.980 --> 01:15:41.980]  А так как args — это переменные, то они
[01:15:41.980 --> 01:15:43.980]  не умеют связываться с RVL-ю ссылками.
[01:15:43.980 --> 01:15:45.980]  Согласны?
[01:15:45.980 --> 01:15:47.980]  Ну чего на самом деле мне нужно? Мне нужно
[01:15:47.980 --> 01:15:49.980]  на самом деле к вот этому второму аргументу
[01:15:51.980 --> 01:15:53.980]  применить stdmove.
[01:15:55.980 --> 01:15:57.980]  Если я во второй аргумент передам stdmove
[01:15:57.980 --> 01:15:59.980]  от arg, то все будет нормально.
[01:16:03.980 --> 01:16:05.980]  А как мне понять, нужно ли применять stdmove или нет?
[01:16:05.980 --> 01:16:07.980]  Смотрите, к первому аргументу
[01:16:09.980 --> 01:16:11.980]  stdmove применять не нужно.
[01:16:11.980 --> 01:16:13.980]  А к второму аргументу нужно применять stdmove.
[01:16:13.980 --> 01:16:15.980]  Как отличить одно от другого?
[01:16:15.980 --> 01:16:17.980]  Ну собственно,
[01:16:17.980 --> 01:16:19.980]  вот этот отличик краски делает функцию stdforward.
[01:16:19.980 --> 01:16:21.980]  stdforward смотрит, что
[01:16:21.980 --> 01:16:23.980]  изначально мы
[01:16:23.980 --> 01:16:25.980]  передали lvalue ссылку.
[01:16:25.980 --> 01:16:27.980]  Но раз мы передали lvalue ссылку, значит не нужно
[01:16:27.980 --> 01:16:29.980]  делать stdmove. Если мы изначально передали rvalue,
[01:16:29.980 --> 01:16:31.980]  то соответственно нужно сделать stdmove,
[01:16:31.980 --> 01:16:33.980]  чтобы дальше тоже пошла
[01:16:33.980 --> 01:16:35.980]  rvalue ссылка. Понятно?
[01:16:37.980 --> 01:16:39.980]  Еще раз. Универсальная ссылка гарантирует,
[01:16:39.980 --> 01:16:41.980]  что lvalue передастся по lvalue ссылке,
[01:16:41.980 --> 01:16:43.980]  rvalue передастся по rvalue ссылке.
[01:16:43.980 --> 01:16:45.980]  stdforward гарантирует, что если я изначально
[01:16:45.980 --> 01:16:47.980]  передавал lvalue, то он в эту же функцию
[01:16:47.980 --> 01:16:49.980]  передастся с помощью lvalue.
[01:16:49.980 --> 01:16:51.980]  Если изначально в аргумент
[01:16:51.980 --> 01:16:53.980]  был передан lvalue, то он будет передаваться дальше
[01:16:53.980 --> 01:16:55.980]  с помощью stdmove. То есть сохранится категория значения.
[01:16:55.980 --> 01:16:57.980]  Понятно?
[01:16:59.980 --> 01:17:01.980]  Почему называется forward?
[01:17:01.980 --> 01:17:03.980]  Почему функция называется stdforward?
[01:17:03.980 --> 01:17:05.980]  stdforward у нас слово
[01:17:05.980 --> 01:17:07.980]  тематика прямой передачи.
[01:17:07.980 --> 01:17:09.980]  Тематика передачи вперед.
[01:17:09.980 --> 01:17:11.980]  То есть как будто бы я вот эти аргументы
[01:17:11.980 --> 01:17:13.980]  a0 передаю не с помощью
[01:17:13.980 --> 01:17:15.980]  функции makeunique, а передаю
[01:17:15.980 --> 01:17:17.980]  сразу напрямую вот сюда.
[01:17:17.980 --> 01:17:19.980]  Не меняя их категории значения. Понятно?
[01:17:19.980 --> 01:17:21.980]  Ну, хорошо, тогда на сегодня все.
[01:17:21.980 --> 01:17:23.980]  На семинарах поработать еще.
[01:17:23.980 --> 01:17:25.980]  До встречи на следующей неделе.
