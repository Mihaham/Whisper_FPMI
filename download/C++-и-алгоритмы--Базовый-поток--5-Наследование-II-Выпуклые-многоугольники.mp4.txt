[00:00.000 --> 00:12.240]  Сегодня продолжаем говорить про наследование. Давайте вспомним, на чем мы остановились в прошлый раз.
[00:12.240 --> 00:19.960]  В прошлый раз мы говорили про то, что ссылки указателей на базовый класс на самом деле могут
[00:19.960 --> 00:27.640]  ссылаться и на объекты производного класса. У меня есть некоторый класс A, есть класс B,
[00:27.640 --> 00:32.200]  который публично унаследован от A. Это означает, что внешний код имеет право знать о том,
[00:32.200 --> 00:38.320]  что B каким-то образом связан с A, точнее унаследован от A. Поэтому где-то во внешнем коде,
[00:38.320 --> 00:41.960]  неважно, в мейне или в какой-то другой функции я могу сделать следующую вещь. Я могу создать
[00:41.960 --> 00:47.800]  объект типа B и создать ссылку на A, но при этом сделать так, чтобы она указывала на объект B.
[00:47.800 --> 00:53.520]  Вот тут вот создаю объект B, создаю Bptr, который на самом деле является указателем на A, но при этом
[00:53.520 --> 01:04.840]  он хранит в себе адрес объекта B. Мы говорили про то, что если у меня и в классе A, и в классе B
[01:04.840 --> 01:10.320]  есть одна и та же функция F, давайте говорить о том, что они имеют одинаковую сигнатуру, то если я
[01:10.320 --> 01:14.680]  через этот указатель буду вызывать функцию F, то у меня будет вызываться метод, который расположен в
[01:14.680 --> 01:21.120]  классе A. Почему? Потому что статический тип объекта Bptr, точнее указатель Bptr, это указатель на A.
[01:21.120 --> 01:24.800]  Соответственно, компилятор видит, что это указатель на A, поэтому он предполагает, что
[01:24.800 --> 01:31.520]  наверное надо вызывать именно метод F. Но при этом, наверное, хотелось бы немного другого поведения,
[01:31.520 --> 01:36.160]  хотелось бы примерно следующего. Мы бы хотели понимать, что если у нас есть какой-то указатель,
[01:36.160 --> 01:41.680]  и этот указатель может указывать как на объект базового класса, так и на объект производного
[01:41.680 --> 01:47.600]  класса, то мы хотим, чтобы по этому указателю выбиралась именно та функция, точнее выбор
[01:47.600 --> 01:50.880]  функции осуществлялась именно на основании того, какой на самом деле объект там лежит,
[01:50.880 --> 01:55.880]  а не на основании типа самого указателя. Понятна проблема? Хотелось бы, наверное,
[01:55.880 --> 02:02.800]  достичь какого-то такого поведения. И это можно сделать с помощью механизма виртуальных функций,
[02:02.800 --> 02:09.800]  ну или виртуальных методов. Как это работает? Давайте я просто возьму и в базовом классе перед
[02:09.800 --> 02:15.400]  именем метода напишу ключевое слово virtual. Что это означает? Что означает ключевое слово
[02:15.400 --> 02:22.840]  virtual? Ключевое слово virtual означает, что выбор класса, из которого нужно вызвать этот метод,
[02:22.840 --> 02:27.720]  он должен осуществляться непосредственно на основании типа, который лежит под указателем или
[02:27.720 --> 02:32.400]  ссылкой, но не на основании статического типа указателей или ссылки. Что у меня тут происходит?
[02:32.400 --> 02:39.760]  У меня тут есть в классе A виртуальная функция f, которая выводит на экран, что вызвана функция f
[02:39.760 --> 02:46.720]  из класса A. А в структуре B я пишу точно такую же функцию, но она при этом выводит на экран,
[02:46.720 --> 02:55.640]  что вызвана функция из B. При этом, да, тут надо подчеркнуть, что если в классе A функцию f объявил
[02:55.640 --> 02:59.240]  виртуальный, то и во всех наследниках эта же функция будет виртуальной, то есть не обязательно
[02:59.240 --> 03:04.640]  везде писать ключевое слово virtual. То есть как только функция стала виртуальной, дальше во всех
[03:04.640 --> 03:08.600]  наследниках эта функция автоматически будет виртуальной. И теперь смотрите, что происходит. Я
[03:08.600 --> 03:14.480]  создаю объект типа B, снова создаю указатель, который имеет тип A со звездой, но при этом он
[03:14.480 --> 03:19.720]  указывает на объект типа B. И дальше я через этот указатель вызываю f. И вот в этот момент происходит
[03:19.720 --> 03:24.560]  магия. В этот момент у меня вызывается функция f, которая находится не в классе A, а которая находится
[03:24.560 --> 03:30.240]  в классе B. Почему? Потому что ключевое слово virtual как раз таки об этом говорит, что выбор функции
[03:30.240 --> 03:34.400]  должен осуществляться непосредственно на основании вот того объекта, который там лежит, а не на
[03:34.400 --> 03:43.520]  основании того, какой указатель, короче, а не на основании типа указателя. Понятно? Вот. Соответственно,
[03:43.520 --> 03:48.120]  в этом назначение виртуальных функций. Виртуальные функции позволяют через указатели или ссылки,
[03:48.120 --> 03:53.000]  то есть тут важный момент, именно через указатели и ссылки позволяет вам вызывать именно ту версию
[03:53.000 --> 03:58.760]  функции, которая расположена непосредственно в самом объекте, который там лежит, а не на основании
[03:58.760 --> 04:05.360]  типа указателей или ссылки. Вот. Соответственно, этот механизм еще называется механизм позднего
[04:05.360 --> 04:10.960]  связывания. Ну, почему позднего связывания? Ну, вот дело в том, что до этого у нас все вызовы функций,
[04:10.960 --> 04:17.760]  давайте сюда вернемся. Вот здесь выбор функции, то есть непосредственно вот какая функция будет
[04:17.760 --> 04:23.960]  вызвана, это решение принималось на этапе компиляции. Вот это называется раннее связывание. То есть
[04:24.080 --> 04:29.840]  раннее связывание говорит о том, что выбор. Вот именно выбор функции, которая будет вызвана,
[04:29.840 --> 04:33.600]  осуществляется на этапе компиляции. То есть вот на этапе компиляции, здесь будет, ну в
[04:33.600 --> 04:39.700]  код Assembler будет подставлен именно вызов функции f, которая находится в a. Здесь же, когда мы используем
[04:39.700 --> 04:43.960]  виртуальные функции, используется механизм позднего связывания. Механизм позднего связывания
[04:43.960 --> 04:52.000]  работает не во время компиляции, а непосредственно во время исполнения программы. То есть позднее
[04:52.000 --> 04:54.000]  Говорить нам о том, что выбор
[04:54.000 --> 04:56.000]  непосредственной функции, которая будет вызвана
[04:56.000 --> 04:58.000]  будет осуществляться во время
[04:58.000 --> 05:00.000]  работы программ,
[05:00.000 --> 05:02.000]  а не во время компиляции.
[05:02.000 --> 05:04.000]  Кто-нибудь может привести пример из первого
[05:04.000 --> 05:06.000]  семестра, когда у нас осуществлялось
[05:06.000 --> 05:08.000]  такое позднее связывание,
[05:08.000 --> 05:10.000]  а не раннее связывание?
[05:10.000 --> 05:12.000]  У вас на самом деле был
[05:12.000 --> 05:14.000]  такой пример?
[05:14.000 --> 05:16.000]  Приведите пример,
[05:16.000 --> 05:18.000]  когда у вас функция вызывается,
[05:18.000 --> 05:20.000]  точнее выбор функции,
[05:20.000 --> 05:22.000]  которая будет вызвана происходит не на этапе компиляции,
[05:22.000 --> 05:24.000]  а во время исполнения программы.
[05:32.000 --> 05:34.000]  Но это указатель на функцию на самом деле.
[05:34.000 --> 05:36.000]  Представьте себе, что
[05:36.000 --> 05:38.000]  у вас есть
[05:38.000 --> 05:40.000]  какая-то функция f,
[05:40.000 --> 05:42.000]  есть какая-то функция g,
[05:44.000 --> 05:46.000]  и есть функция
[05:46.000 --> 05:48.000]  call,
[05:48.000 --> 05:50.000]  которая принимает указатель на функцию
[05:56.000 --> 05:58.000]  и внутри осуществляет вызов
[05:58.000 --> 06:00.000]  этой самой функции.
[06:00.000 --> 06:02.000]  Теперь я могу
[06:02.000 --> 06:04.000]  в эту функцию передавать
[06:04.000 --> 06:06.000]  либо f,
[06:06.000 --> 06:08.000]  либо g.
[06:08.000 --> 06:10.000]  Понятное дело, я могу это делать
[06:10.000 --> 06:12.000]  непосредственно
[06:12.000 --> 06:14.000]  вот так, например,
[06:14.000 --> 06:16.000]  sin
[06:18.000 --> 06:20.000]  x,
[06:20.000 --> 06:22.000]  и там, например,
[06:22.000 --> 06:24.000]  if x
[06:24.000 --> 06:26.000]  равно-равно нулю,
[06:26.000 --> 06:28.000]  я делаю call
[06:28.000 --> 06:30.000]  f else
[06:32.000 --> 06:34.000]  call g.
[06:36.000 --> 06:38.000]  То есть здесь выбор функции,
[06:38.000 --> 06:40.000]  которая будет вызвана, происходит не на этапе компиляции,
[06:40.000 --> 06:42.000]  а на этапе выполнения программы.
[06:42.000 --> 06:44.000]  Именно на этапе выполнения программы, вот здесь вместо ptr
[06:44.000 --> 06:46.000]  будет подставлена конкретная функция,
[06:46.000 --> 06:48.000]  а потом она будет вызвана.
[06:48.000 --> 06:50.000]  То есть понятное дело, что на этапе компиляции
[06:50.000 --> 06:52.000]  у компиляторов в принципе нет никакой возможности понять,
[06:52.000 --> 06:54.000]  какую функцию здесь нужно вызывать.
[06:54.000 --> 06:56.000]  Потому что указатель происходит
[06:56.000 --> 06:58.000]  во время выполнения программы,
[06:58.000 --> 07:00.000]  а не во время компиляции.
[07:00.000 --> 07:02.000]  Пример понятен?
[07:06.000 --> 07:08.000]  Да, ну и собственно
[07:08.000 --> 07:10.000]  про механизм позднего связывания поговорили,
[07:10.000 --> 07:12.000]  давайте вот тут
[07:12.000 --> 07:14.000]  еще пример разберем, значит смотрите, что тут происходит.
[07:14.000 --> 07:16.000]  Вот здесь есть ф, есть класс a, есть виртуальный метод f
[07:16.000 --> 07:18.000]  и есть обычный метод g.
[07:18.000 --> 07:20.000]  Есть структура b, в которой объявлены
[07:20.000 --> 07:22.000]  точно такие же методы f и g, но при этом
[07:22.000 --> 07:24.000]  мы помним, что f по-прежнему виртуальная,
[07:24.000 --> 07:26.000]  потому что виртуальность она наследуется.
[07:26.000 --> 07:28.000]  И теперь здесь, когда я вызываю функцию g,
[07:28.000 --> 07:30.000]  у меня вот сюда
[07:30.000 --> 07:32.000]  именно код,
[07:32.000 --> 07:34.000]  тот код, который приводит
[07:34.000 --> 07:36.000]  к вызову функции g, он подставляется непосредственно
[07:36.000 --> 07:38.000]  во время компиляции.
[07:38.000 --> 07:40.000]  А вот здесь выбор функции f конкретный,
[07:40.000 --> 07:42.000]  то есть либо из a, либо из b,
[07:42.000 --> 07:44.000]  то есть сходит во время исполнения программы,
[07:44.000 --> 07:46.000]  но не во время компиляции, окей?
[07:46.000 --> 07:48.000]  Ну и соответственно,
[07:48.000 --> 07:50.000]  вот такой вопрос, как я сказал,
[07:50.000 --> 07:52.000]  во второй строке решение откладывается,
[07:52.000 --> 07:54.000]  то есть компилятор здесь на самом деле не подставляет
[07:54.000 --> 07:56.000]  никакого кода, точнее он там пишет особый код,
[07:56.000 --> 07:58.000]  но при этом конкретную функцию туда
[07:58.000 --> 08:00.000]  не подставляет, а откладывает
[08:00.000 --> 08:02.000]  это все на момент
[08:02.000 --> 08:04.000]  рантайма, на момент выполнения
[08:04.000 --> 08:06.000]  программы. Это вот вопрос, а в чем проблема?
[08:06.000 --> 08:08.000]  Почему нельзя просто так взять и, скажем, сюда
[08:08.000 --> 08:10.000]  подставить вызов функции,
[08:10.000 --> 08:12.000]  которая находится в b?
[08:12.000 --> 08:14.000]  Кажется, компилятор вполне себе может проанализировать ваш код,
[08:14.000 --> 08:16.000]  понять, что
[08:16.000 --> 08:18.000]  указатель на a на самом деле
[08:18.000 --> 08:20.000]  ссылается на объект b, и поэтому здесь нужно
[08:20.000 --> 08:22.000]  вызвать g, который находится в b.
[08:22.000 --> 08:24.000]  В чем проблема? Зачем это нужно откладывать?
[08:24.000 --> 08:26.000]  Зачем нужно позднее связывание? Почему нельзя обойтись
[08:26.000 --> 08:28.000]  только ранним связыванием?
[08:34.000 --> 08:36.000]  В чем проблема определения
[08:36.000 --> 08:38.000]  функции f на этапе
[08:38.000 --> 08:40.000]  компиляции? Почему здесь нельзя просто так взять
[08:40.000 --> 08:42.000]  и сразу подставить b.2.f?
[08:42.000 --> 08:44.000]  Почему компилятор
[08:44.000 --> 08:46.000]  так не может сделать?
[08:48.000 --> 08:50.000]  Сложно.
[08:52.000 --> 08:54.000]  Смотрите, ответ такой.
[08:54.000 --> 08:56.000]  Дело в том, что в данном случае компилятор
[08:56.000 --> 08:58.000]  конечно может это сделать, и
[08:58.000 --> 09:00.000]  вполне вероятно он так и сделает. Здесь,
[09:00.000 --> 09:02.000]  если с достаточно
[09:02.000 --> 09:04.000]  уровнем
[09:04.000 --> 09:06.000]  оптимизации вы запускаете компиляцию,
[09:06.000 --> 09:08.000]  возможно он это как-то соптимизирует и здесь
[09:08.000 --> 09:10.000]  сразу поставит вызов функции b.
[09:10.000 --> 09:12.000]  Но в общем случае он этого сделать не может.
[09:12.000 --> 09:14.000]  И вот почему. Дело в том, что у вас
[09:14.000 --> 09:16.000]  фактически
[09:16.000 --> 09:18.000]  объект, на который будет указывать a,
[09:18.000 --> 09:20.000]  может зависеть от каких-то
[09:20.000 --> 09:22.000]  параметров, которые будут
[09:22.000 --> 09:24.000]  известны только на этапе выполнения программы.
[09:24.000 --> 09:26.000]  Я уже приводил этот пример
[09:26.000 --> 09:28.000]  с указателем на функцию.
[09:28.000 --> 09:30.000]  Смотрите, у меня есть x.
[09:30.000 --> 09:32.000]  Я x вожу с клавиатуры.
[09:32.000 --> 09:34.000]  Понятное дело, что компиляторы пока не научились
[09:34.000 --> 09:36.000]  делать действия пользователей. То есть компилятор не может предсказать,
[09:36.000 --> 09:38.000]  а что же будет на самом деле введено.
[09:38.000 --> 09:40.000]  Понятно? То есть я могу ввести 1,
[09:40.000 --> 09:42.000]  2, 3, могу ввести 0 или вообще
[09:42.000 --> 09:44.000]  что угодно. И здесь в зависимости
[09:44.000 --> 09:46.000]  от того, ввел я 0 или нет, у меня
[09:46.000 --> 09:48.000]  указатель ptr указывает либо на объект
[09:48.000 --> 09:50.000]  типа b, new b, либо на объект
[09:50.000 --> 09:52.000]  типа a, new a.
[09:52.000 --> 09:54.000]  Ну и понятное дело, что вот в данный момент,
[09:54.000 --> 09:56.000]  что когда компилятор читает ваш код, ему в принципе
[09:56.000 --> 09:58.000]  не понятно, а какую функцию f нужно вызвать.
[09:58.000 --> 10:00.000]  Которая находится в b или которая в a.
[10:00.000 --> 10:02.000]  Понятно?
[10:02.000 --> 10:04.000]  На этапе компиляции это сделать просто нельзя.
[10:04.000 --> 10:06.000]  Это не всегда возможно.
[10:06.000 --> 10:08.000]  вот пример, когда этого сделать тупо нельзя.
[10:08.000 --> 10:10.000]  Вот для этого существует механизм позднего связ Goo.
[10:10.000 --> 10:12.000]  Решение о том, какая функция
[10:12.000 --> 10:14.000]  будет вызвана, откладывается до момента
[10:14.000 --> 10:16.000]  исполнения программы.
[10:16.000 --> 10:18.000]  Вот. Ну и как здесь написано
[10:18.000 --> 10:20.000]  позднее связ10 действительно оно
[10:20.000 --> 10:22.000]  более затратно, чем раннее связ00.
[10:22.000 --> 10:24.000]  У вас возникает вопрос. Ну хорошо, а зачем
[10:24.000 --> 10:26.000]  тогда все сделать на этапе компиляции,
[10:26.000 --> 10:28.000]  тогда давайте все делать на этапе executed
[10:28.000 --> 10:30.000]  программы, во время исполнения программы
[10:30.000 --> 10:33.480]  для каждой функции определять, какая должна быть вызвана.
[10:33.480 --> 10:36.000]  Естественно, это более дорого. Понятно почему.
[10:36.000 --> 10:39.000]  Потому что на этапе компиляции компилятор сразу может поставить, что
[10:39.000 --> 10:42.000]  а вот тут находится такая-то функция, поэтому при вызове этой функции
[10:42.000 --> 10:47.000]  указатель инструкции нужно передвинуть туда.
[10:47.000 --> 10:51.000]  А если у вас есть позднее связание, то есть если у вас решение о том,
[10:51.000 --> 10:53.000]  какая функция будет вызвана, откладывается до момента исполнения программы,
[10:53.000 --> 10:56.000]  то естественно компилятору нужно сделать несколько дополнительных действий.
[10:56.000 --> 10:59.000]  В частности, понять, какой объект там на самом деле лежит,
[10:59.000 --> 11:02.000]  какую функцию нужно выбрать и только потом ее вызвать.
[11:02.000 --> 11:06.000]  То есть позднее связание обязательно влечет за собой некоторые дополнительные действия.
[11:06.000 --> 11:09.000]  Окей?
[11:09.000 --> 11:13.000]  Поэтому, в общем, с одной стороны мы получаем гибкость,
[11:13.000 --> 11:16.000]  то есть мы можем использовать указатели на базовый класс и при этом,
[11:16.000 --> 11:19.000]  в зависимости на какой объект мы на самом деле указываем,
[11:19.000 --> 11:22.000]  будет вызываться тот или иной метод, но с другой стороны мы получаем
[11:22.000 --> 11:26.000]  некоторую просадку в производительности, потому что вызывать такие функции более дорого.
[11:26.000 --> 11:29.000]  Понятно?
[11:29.000 --> 11:36.000]  Хорошо, ну и давайте попробуем как-то, не знаю, порешаем задачи на эту тему.
[11:36.000 --> 11:44.000]  Вот есть класс A, в нем есть виртуальный метод F и не виртуальный метод G.
[11:44.000 --> 11:47.000]  Дальше есть класс B, который публично унаследован от A,
[11:47.000 --> 11:53.000]  в нем есть точно такой же метод F, и в свою очередь B объявляет метод G виртуальным.
[11:53.000 --> 11:59.000]  Ну и есть структура C, которая наследуется от B и определяет функцию F,
[11:59.000 --> 12:04.000]  и определяет функцию G, но при этом, заметьте, что тип другой.
[12:04.000 --> 12:09.000]  То есть во всех функциях есть метод F, который возвращает void,
[12:09.000 --> 12:13.000]  во всех функциях есть метод G, но при этом в классе A он возвращает void,
[12:13.000 --> 12:15.000]  а в классе C он возвращает char.
[12:15.000 --> 12:18.000]  Ну и более того, виртуальный метод G объявляется только в классе B.
[12:18.000 --> 12:23.000]  Давайте посмотрим на центральную колонку и попробуем определить, где метод вызывается.
[12:23.000 --> 12:29.000]  При условии, что я объект типа A создаю с помощью объекта типа B,
[12:29.000 --> 12:34.000]  объект B создаю с помощью объекта типа C, ну и объект C создаю с помощью объекта типа C.
[12:34.000 --> 12:39.000]  Ну давайте, наверное, с C начнем, это самое простое, да, вот последние две строки.
[12:39.000 --> 12:42.000]  Что там вызывается?
[12:42.000 --> 12:45.000]  Ну, естественно, C, да, везде.
[12:45.000 --> 12:50.000]  Ну, тут нет никаких вариантов, потому что, ну как бы, C проинтересована объектом типа C,
[12:50.000 --> 12:52.000]  тут вообще никаких вопросов быть не может.
[12:52.000 --> 12:56.000]  Хорошо, давайте тогда, ну давайте тогда начнем, давайте сверху пойдем.
[12:56.000 --> 12:59.000]  Вот я вызываю A.F, какая функция вызывается?
[13:01.000 --> 13:04.000]  Так, кто считает, что в B?
[13:04.000 --> 13:07.000]  А кто считает, что A?
[13:07.000 --> 13:09.000]  Да, действительно, A.
[13:09.000 --> 13:12.000]  Может, кто-то сможет объяснить, почему A, а не B?
[13:12.000 --> 13:16.000]  Так, смотрите, F виртуальная, и A создан с помощью объекта типа B,
[13:16.000 --> 13:20.000]  но при этом вызывается A, то есть это, кажется, противоречит тому, что мы обсуждали до этого, или нет?
[13:24.000 --> 13:27.000]  Ну кто объяснит?
[13:32.000 --> 13:36.000]  Ну, вот смотрите, я утверждаю, что есть противоречи... что?
[13:36.000 --> 13:41.000]  Ну, не совсем.
[13:41.000 --> 13:46.000]  То есть конструктор, ну, точнее так, конструктор от B, конечно, вызвался,
[13:46.000 --> 13:49.000]  но при этом произошло нечто другое. Что еще произошло?
[13:49.000 --> 13:52.000]  Срезка, да. Все помните, что такое срезка?
[13:52.000 --> 13:56.000]  Вот, значит, этот пример показывает, ну, то есть этот пример демонстрирует то,
[13:56.000 --> 14:00.000]  что, на самом деле, важно отличать срезку и работу с указателями и ссылками.
[14:00.000 --> 14:04.000]  Значит, еще раз, срезка создает непосредственно тот объект, который вы попросили,
[14:04.000 --> 14:07.000]  то есть срезка создает вам объект типа A.
[14:07.000 --> 14:12.000]  То есть A, а маленькая, это переменная, которая ссылается на объект типа A.
[14:12.000 --> 14:16.000]  Да, то есть, ну, действительно, там в правой части произошло создание объекта типа B,
[14:16.000 --> 14:19.000]  но потом он просто взял и урезался до объекта типа A.
[14:19.000 --> 14:22.000]  Поэтому тут, на самом деле, виртуализация, естественно, не работает, почему?
[14:22.000 --> 14:25.000]  Потому что, ну, компилятор видит, что A это объект типа A,
[14:25.000 --> 14:29.000]  и у объекта типа A можно вызывать только методы класса A,
[14:29.000 --> 14:31.000]  поэтому тут вызывается af.
[14:31.000 --> 14:33.000]  Ну, и в центральных двух строках?
[14:36.000 --> 14:38.000]  Ну, абсолютно точно так же.
[14:38.000 --> 14:41.000]  Bf и Bf, ой, и Bg.
[14:41.000 --> 14:45.000]  Почему? Потому что тип, тип переменной B, это B.
[14:45.000 --> 14:48.000]  То есть сама B является объектом типа B.
[14:48.000 --> 14:54.000]  У объекта типа B ничего нельзя вызвать другого, кроме как, вот, собственно, методы класса B.
[14:54.000 --> 14:57.000]  А вот теперь давайте перейдем на правую, в правую колонку,
[14:57.000 --> 14:59.000]  ну, и пойдем по порядку.
[14:59.000 --> 15:02.000]  Вот у меня есть указатель, указатель на A,
[15:02.000 --> 15:05.000]  но он при этом указывает на объект типа B.
[15:07.000 --> 15:09.000]  Какие функции будут вызваны f и g?
[15:09.000 --> 15:11.000]  Которые находятся в A, в B или в C?
[15:11.000 --> 15:14.000]  Так, здесь вызовется вот так. Согласны?
[15:18.000 --> 15:20.000]  А здесь a, g, так? Или нет?
[15:28.000 --> 15:31.000]  Ну, а теперь давайте перейдем на правую колонку.
[15:31.000 --> 15:33.000]  Вот здесь у меня есть указатель на A,
[15:33.000 --> 15:36.000]  но он при этом указывает на объект типа B.
[15:38.000 --> 15:40.000]  Какие функции будут вызваны f и g?
[15:41.000 --> 15:43.000]  Говорю, давайте по порядку.
[15:43.000 --> 15:48.000]  Почему в первой строке вызовется функция, которая находится в B?
[15:53.000 --> 15:56.000]  Да, ну, во-первых, потому что f виртуальная,
[15:56.000 --> 15:58.000]  то есть по порядку, что мы делаем?
[15:58.000 --> 16:02.000]  Мы понимаем, что тип APB это указатель на A,
[16:02.000 --> 16:07.000]  поэтому мы идем сюда и смотрим на функцию f.
[16:07.000 --> 16:11.000]  И вот в этот момент мы понимаем, что функция f виртуальная.
[16:11.000 --> 16:14.000]  А раз функция f виртуальная, то что это означает?
[16:14.000 --> 16:17.000]  Это означает, что нам не достаточно знать о том,
[16:17.000 --> 16:19.000]  какой указатель на самом деле был.
[16:19.000 --> 16:22.000]  Нам важно знать, на какой объект мы указываем. Согласны?
[16:22.000 --> 16:25.000]  А объект, на который мы указываем, это объект типа B.
[16:25.000 --> 16:30.000]  Поэтому вызван на самом деле фактически будет вот этот метод,
[16:30.000 --> 16:32.000]  который находится в B.
[16:32.000 --> 16:34.000]  Окей.
[16:34.000 --> 16:37.000]  Так, ну а во второй строке почему будет вызван метод g,
[16:37.000 --> 16:39.000]  который находится в A?
[16:39.000 --> 16:41.000]  Потому что g в A не виртуальный.
[16:41.000 --> 16:43.000]  Да, потому что метод g не виртуальный.
[16:43.000 --> 16:45.000]  Все, то есть тут то же самое.
[16:45.000 --> 16:47.000]  Мы видим, что APB это указатель на A,
[16:47.000 --> 16:49.000]  мы идем сюда, видим, что это метод g,
[16:49.000 --> 16:51.000]  и он не виртуальный,
[16:51.000 --> 16:53.000]  поэтому просто-напросто берем и его вызываем.
[16:53.000 --> 16:55.000]  То есть тут нет позднего связывания.
[16:55.000 --> 16:57.000]  Так, идем дальше.
[16:57.000 --> 16:59.000]  C.
[17:03.000 --> 17:06.000]  Так, в первой строке какой метод будет вызван?
[17:06.000 --> 17:08.000]  Который в B или в C или в A?
[17:08.000 --> 17:10.000]  В A.
[17:10.000 --> 17:12.000]  Так, говорят в C.
[17:12.000 --> 17:14.000]  Ну хорошо. А во второй строке?
[17:18.000 --> 17:20.000]  В A.
[17:20.000 --> 17:22.000]  Окей, ну давайте теперь поговорим.
[17:22.000 --> 17:24.000]  Почему в первой строке вызывается метод, который находится в C?
[17:28.000 --> 17:30.000]  Да, потому что f виртуальный метод.
[17:30.000 --> 17:32.000]  Еще раз, что мы делаем?
[17:32.000 --> 17:34.000]  Еще раз, как действует компилятор?
[17:34.000 --> 17:36.000]  Компилятор просто смотрит на тип APC.
[17:36.000 --> 17:38.000]  Тип APC это указатель на A,
[17:38.000 --> 17:40.000]  поэтому мы идем сюда.
[17:40.000 --> 17:42.000]  То есть компилятор в этот момент понимает,
[17:42.000 --> 17:44.000]  что метод f виртуальный,
[17:44.000 --> 17:46.000]  поэтому нужно посмотреть на то, какой на самом деле тип там лежит.
[17:46.000 --> 17:48.000]  Там на самом деле лежит тип C.
[17:48.000 --> 17:50.000]  Потому что мы создали его с помощью конструкции new C.
[17:50.000 --> 17:52.000]  Ну а так как на самом деле
[17:52.000 --> 17:54.000]  мы указываем на объекте C,
[17:54.000 --> 17:56.000]  поэтому нужно вызывать метод f.
[17:56.000 --> 17:58.000]  А во второй строке почему вызывается g?
[17:58.000 --> 18:00.000]  Во второй строке почему вызывается g из A,
[18:00.000 --> 18:02.000]  а не из B или не из C?
[18:02.000 --> 18:04.000]  Потому что g не виртуальная.
[18:04.000 --> 18:06.000]  Да, потому что g не виртуальная.
[18:06.000 --> 18:08.000]  Но снова мы идем в класс A и видим, что g не виртуальная,
[18:08.000 --> 18:10.000]  поэтому вообще нет никаких вариантов.
[18:10.000 --> 18:12.000]  То есть вызываем только эту g.
[18:12.000 --> 18:14.000]  Ну и последние две строки.
[18:14.000 --> 18:16.000]  Какие тут методы?
[18:20.000 --> 18:22.000]  Так, есть вариант из B в C.
[18:22.000 --> 18:24.000]  Еще какие варианты есть?
[18:24.000 --> 18:26.000]  С, С.
[18:26.000 --> 18:28.000]  Есть еще варианты?
[18:34.000 --> 18:36.000]  Кто за первый вариант?
[18:36.000 --> 18:38.000]  Один.
[18:38.000 --> 18:40.000]  Кто за второй вариант?
[18:40.000 --> 18:42.000]  Побольше.
[18:42.000 --> 18:44.000]  Кто за третий вариант?
[18:44.000 --> 18:46.000]  Тоже один.
[18:46.000 --> 18:48.000]  Ну да, на самом деле
[18:48.000 --> 18:50.000]  будет вызван...
[18:50.000 --> 18:52.000]  Хотя нет, стоп.
[18:52.000 --> 18:54.000]  Нет, все правильно.
[18:54.000 --> 18:56.000]  Здесь вызвана вторая строка.
[18:58.000 --> 19:00.000]  То есть будет C, F
[19:00.000 --> 19:02.000]  и C, G.
[19:04.000 --> 19:06.000]  Сейчас, стоп.
[19:06.000 --> 19:08.000]  Нет, нет, тут неправда.
[19:08.000 --> 19:10.000]  Сейчас поговорим.
[19:10.000 --> 19:12.000]  Давайте по порядку.
[19:12.000 --> 19:14.000]  В первой строке
[19:14.000 --> 19:16.000]  почему вызывается C, думаю, понятно.
[19:16.000 --> 19:18.000]  Мы идем в B,
[19:18.000 --> 19:20.000]  то есть B по C на самом деле указывает на A, B,
[19:20.000 --> 19:22.000]  мы идем сюда, видим функцию F,
[19:22.000 --> 19:24.000]  но она на самом деле виртуальная.
[19:24.000 --> 19:26.000]  Почему?
[19:26.000 --> 19:28.000]  Потому что мы сказали, что виртуальность на самом деле наследуется.
[19:28.000 --> 19:30.000]  То есть если в базовом классе
[19:30.000 --> 19:32.000]  эта функция объявлена виртуальной,
[19:32.000 --> 19:34.000]  то и всюду далее она будет виртуальной.
[19:34.000 --> 19:36.000]  То есть как бы вот тут не явно все равно стоит слово virtual.
[19:40.000 --> 19:42.000]  Она виртуальная, поэтому на самом деле смотрим на то,
[19:42.000 --> 19:44.000]  на какой объект мы указываем.
[19:44.000 --> 19:46.000]  На самом деле мы указываем на объект типа C,
[19:46.000 --> 19:48.000]  поэтому вызывается метод F, который находится в C.
[19:48.000 --> 19:50.000]  А вот теперь смотрим сюда.
[19:50.000 --> 19:52.000]  Здесь все интереснее.
[19:54.000 --> 19:56.000]  Здесь все интереснее. Почему?
[19:56.000 --> 19:58.000]  Потому что действительно мы смотрим на функцию G
[19:58.000 --> 20:00.000]  и G виртуальная.
[20:00.000 --> 20:02.000]  Но какая функция G виртуальная?
[20:04.000 --> 20:06.000]  Которая возвращает void.
[20:06.000 --> 20:08.000]  То есть виртуальная именно функция,
[20:08.000 --> 20:10.000]  которая ничего не принимает и возвращает void.
[20:10.000 --> 20:12.000]  Функция, которая возвращает char
[20:12.000 --> 20:14.000]  и ничего не принимает,
[20:14.000 --> 20:16.000]  к этой void не имеет никакого отношения.
[20:16.000 --> 20:18.000]  Это функция, которая имеет абсолютно другой тип.
[20:18.000 --> 20:20.000]  Поэтому она не виртуальная.
[20:22.000 --> 20:24.000]  Поэтому здесь на самом деле будет вызвана функция из B.
[20:28.000 --> 20:30.000]  Кто понимает?
[20:32.000 --> 20:34.000]  В смысле, давайте алгоритм еще раз.
[20:36.000 --> 20:38.000]  Нет, вот функция char
[20:38.000 --> 20:40.000]  в данном контексте,
[20:40.000 --> 20:42.000]  в данном случае ее нельзя вызвать.
[20:44.000 --> 20:46.000]  Потому что это функция, которая находится в C.
[20:46.000 --> 20:48.000]  И она никак не связана.
[20:50.000 --> 20:52.000]  Что находится в B?
[20:52.000 --> 20:54.000]  В B у вас находится функция, которая возвращает void.
[20:54.000 --> 20:56.000]  Есть функция C,
[20:56.000 --> 20:58.000]  которая возвращает char G.
[21:00.000 --> 21:02.000]  С помощью указателя на B
[21:02.000 --> 21:04.000]  можно вызвать только функции,
[21:04.000 --> 21:06.000]  которые объявлены в классе B.
[21:10.000 --> 21:12.000]  Char G объявлено в классе C.
[21:12.000 --> 21:14.000]  Вот про эту функцию класс B в принципе ничего не знает.
[21:14.000 --> 21:16.000]  Поэтому она не может быть вызвана никак.
[21:18.000 --> 21:20.000]  Грубо говоря, вот эти функции имеют разные типы.
[21:20.000 --> 21:22.000]  Одна возвращает void,
[21:22.000 --> 21:24.000]  другая char.
[21:24.000 --> 21:26.000]  Они имеют разные типы.
[21:26.000 --> 21:28.000]  Поэтому виртуальность на них не распространяется.
[21:30.000 --> 21:32.000]  Виртуальность распространяется только на ту функцию,
[21:32.000 --> 21:34.000]  которая дословно совпадает
[21:34.000 --> 21:36.000]  с тем типом, который был объявлен виртуальным.
[21:40.000 --> 21:42.000]  Теперь был вопрос, как компилятор понимает,
[21:42.000 --> 21:44.000]  что на самом деле...
[21:44.000 --> 21:46.000]  Как компилятор это все понимает?
[21:46.000 --> 21:48.000]  Давайте еще раз с алгоритмом.
[21:48.000 --> 21:50.000]  Алгоритм такой.
[21:50.000 --> 21:52.000]  Компилятор смотрит на тип указателя.
[21:52.000 --> 21:54.000]  Тип указателя какой? Указатель на B.
[21:54.000 --> 21:56.000]  Поэтому мы должны пойти вот сюда.
[21:58.000 --> 22:00.000]  Смотрим сюда.
[22:00.000 --> 22:02.000]  Эта функция какая? Виртуальная.
[22:02.000 --> 22:04.000]  Виртуальная функция void G.
[22:04.000 --> 22:06.000]  Мы принимаем решение о том,
[22:06.000 --> 22:08.000]  какая функция будет вызвана,
[22:08.000 --> 22:10.000]  а не того, на какой объект мы указываем.
[22:10.000 --> 22:12.000]  А указываем мы на объект типа C.
[22:12.000 --> 22:14.000]  Мы идем в C и смотрим,
[22:14.000 --> 22:16.000]  есть ли там функция void G.
[22:18.000 --> 22:20.000]  Такой функции там нет.
[22:20.000 --> 22:22.000]  Точнее, она есть, но она унаследована
[22:22.000 --> 22:24.000]  от B.
[22:24.000 --> 22:26.000]  Мы ее никак не переопределяли в классе C.
[22:26.000 --> 22:28.000]  Поэтому мы вызываем именно ту функцию,
[22:28.000 --> 22:30.000]  которую она унаследовала.
[22:36.000 --> 22:38.000]  Есть вопросы?
[22:40.000 --> 22:42.000]  Вот.
[22:42.000 --> 22:44.000]  Здесь вызывается функция
[22:44.000 --> 22:46.000]  именно того типа, который указан
[22:46.000 --> 22:48.000]  непосредственно в классе B.
[22:48.000 --> 22:50.000]  А в классе B функция G имеет
[22:50.000 --> 22:52.000]  тип void и пустые круглые скобки.
[22:52.000 --> 22:54.000]  Поэтому никакая другая функция
[22:54.000 --> 22:56.000]  с другой сигнатурой вызвана быть не может.
[23:04.000 --> 23:06.000]  Ответы вроде все совпало.
[23:06.000 --> 23:08.000]  Хорошо.
[23:10.000 --> 23:12.000]  Значит,
[23:12.000 --> 23:14.000]  еще немного про виртуальность.
[23:14.000 --> 23:16.000]  Виртуальность работает
[23:16.000 --> 23:18.000]  и внутри методов класса.
[23:18.000 --> 23:20.000]  Что это означает? Это означает, что
[23:20.000 --> 23:22.000]  если у вас есть какой-то виртуальный метод,
[23:22.000 --> 23:24.000]  и вы этот виртуальный метод вызываете
[23:24.000 --> 23:26.000]  внутри другого метода,
[23:26.000 --> 23:28.000]  то все вот эти приколы
[23:28.000 --> 23:30.000]  с поздним связанием
[23:30.000 --> 23:32.000]  будут также работать.
[23:32.000 --> 23:34.000]  В частности, если у меня есть
[23:34.000 --> 23:36.000]  указатель на A,
[23:36.000 --> 23:38.000]  при этом я проницилизировал указатель на A
[23:38.000 --> 23:40.000]  и указателем на B.
[23:40.000 --> 23:42.000]  Если я вызову printName,
[23:42.000 --> 23:44.000]  несмотря на то, что printName
[23:44.000 --> 23:46.000]  не является виртуальным,
[23:46.000 --> 23:48.000]  то есть тут никаких проблем нет.
[23:48.000 --> 23:50.000]  Тут вызывается именно A
[23:50.000 --> 23:52.000]  2.2.printName.
[23:54.000 --> 23:56.000]  То есть тут происходит какое связывание?
[23:58.000 --> 24:00.000]  Раннее связывание.
[24:00.000 --> 24:02.000]  PrintName не виртуальное. Но при этом
[24:02.000 --> 24:04.000]  printName сама внутри себя
[24:04.000 --> 24:06.000]  вызывает виртуальную функцию.
[24:06.000 --> 24:08.000]  И вот здесь уже происходит позднее связывание.
[24:08.000 --> 24:10.000]  Понятно?
[24:10.000 --> 24:12.000]  То есть вот здесь внутри этой функции комплинатор
[24:12.000 --> 24:14.000]  подставляет код, который непосредственно
[24:14.000 --> 24:16.000]  не вызывает name, а делает какие-то приколы
[24:16.000 --> 24:18.000]  так, чтобы был вызван именно
[24:18.000 --> 24:20.000]  тот метод, на который указывает
[24:20.000 --> 24:22.000]  указатель.
[24:22.000 --> 24:24.000]  Но именно указатель this.
[24:24.000 --> 24:26.000]  Тут на самом деле name
[24:26.000 --> 24:28.000]  разворачивается this,
[24:28.000 --> 24:30.000]  стрелочка name.
[24:32.000 --> 24:34.000]  А указатель this на самом деле указывает
[24:34.000 --> 24:36.000]  на объект типа B.
[24:36.000 --> 24:38.000]  Понятно почему.
[24:38.000 --> 24:40.000]  Поэтому тут работает виртуальный метод.
[24:42.000 --> 24:44.000]  Пример понятен?
[24:46.000 --> 24:48.000]  В общем, мораль такая, что
[24:48.000 --> 24:50.000]  виртуальные функции работают не только во внешнем коде,
[24:50.000 --> 24:52.000]  но и внутри ваших классов тоже
[24:52.000 --> 24:54.000]  можно вызывать виртуальные методы,
[24:54.000 --> 24:56.000]  и они работают, в общем,
[24:56.000 --> 24:58.000]  как и заявлялось.
[24:58.000 --> 25:00.000]  Единственное исключение,
[25:00.000 --> 25:02.000]  виртуальные методы не работают в конструкторах
[25:02.000 --> 25:04.000]  и деструкторах. Вот если вы в конструкторе
[25:04.000 --> 25:06.000]  или деструкторе позовете виртуальный метод,
[25:06.000 --> 25:08.000]  то виртуальность будет игнорироваться.
[25:14.000 --> 25:16.000]  Из того, что я знаю, это единственное исключение,
[25:16.000 --> 25:18.000]  когда виртуальные методы не работают.
[25:18.000 --> 25:20.000]  Это конструкторы и деструкторы.
[25:20.000 --> 25:22.000]  Есть гипотезы,
[25:22.000 --> 25:24.000]  почему не работают?
[25:26.000 --> 25:28.000]  Из-за чего?
[25:32.000 --> 25:34.000]  Ну да, смотрите,
[25:34.000 --> 25:36.000]  да, действительно,
[25:36.000 --> 25:38.000]  почему в конструкторе нельзя вызывать
[25:38.000 --> 25:40.000]  виртуальные методы.
[25:40.000 --> 25:42.000]  Смотрите, вот представьте,
[25:42.000 --> 25:44.000]  что у меня есть конструктор B,
[25:44.000 --> 25:46.000]  что делает конструктор B?
[25:46.000 --> 25:48.000]  Конструктор B сначала
[25:48.000 --> 25:50.000]  вызывает конструктор A. Согласны?
[25:50.000 --> 25:52.000]  Ну, помним, да? Хорошо.
[25:52.000 --> 25:54.000]  А внутри конструктора A
[25:54.000 --> 25:56.000]  вызывается виртуальный метод F.
[25:56.000 --> 25:58.000]  Если я внутри конструктора A
[25:58.000 --> 26:00.000]  вызываю виртуальный метод F,
[26:00.000 --> 26:02.000]  который будет вызван. Который из a или который из b?
[26:02.000 --> 26:04.000]  Ну, по идее.
[26:04.000 --> 26:06.000]  По идее, если он виртуальный, то, наверное, должен быть вызван метод,
[26:06.000 --> 26:08.000]  который находится в b.
[26:08.000 --> 26:10.000]  А что может делать такого запрещенного,
[26:10.000 --> 26:12.000]  в данном контексте,
[26:12.000 --> 26:14.000]  метод f, который определен в b?
[26:14.000 --> 26:16.000]  Ну, не совсем.
[26:16.000 --> 26:18.000]  Он может использовать ту часть,
[26:18.000 --> 26:20.000]  которая еще не проницилизирована.
[26:20.000 --> 26:22.000]  Понятно проблема?
[26:22.000 --> 26:24.000]  Давайте еще раз повторю.
[26:24.000 --> 26:26.000]  Вот смотрите, у меня есть конструктор b.
[26:26.000 --> 26:28.000]  Я его вызываю.
[26:28.000 --> 26:30.000]  Причем, что происходит в конструкторе b,
[26:30.000 --> 26:32.000]  это вызов конструктора a.
[26:32.000 --> 26:34.000]  Изначально я создаю вот такую вот коробку,
[26:34.000 --> 26:36.000]  которая относится к a.
[26:36.000 --> 26:38.000]  Вот эта вот закрашенная часть, она еще не создана.
[26:38.000 --> 26:40.000]  Она еще даже не проницилизирована.
[26:40.000 --> 26:42.000]  Окей?
[26:42.000 --> 26:44.000]  И теперь смотрите, если я вдруг
[26:44.000 --> 26:46.000]  в конструкторе a вызываю виртуальный метод,
[26:46.000 --> 26:48.000]  то этот виртуальный метод чисто теоретически может
[26:48.000 --> 26:50.000]  полезть туда, куда ему еще не следует.
[26:50.000 --> 26:52.000]  Понятно?
[26:52.000 --> 26:54.000]  То есть он может полезть в ту часть, которая еще не создана.
[26:54.000 --> 26:56.000]  И это большая беда.
[26:56.000 --> 26:58.000]  Понятно?
[26:58.000 --> 27:00.000]  То же самое с деструктором.
[27:00.000 --> 27:02.000]  Что происходит в деструкторе b?
[27:02.000 --> 27:04.000]  Что сначала уничтожается?
[27:10.000 --> 27:12.000]  Сначала в деструкторе уничтожается все то,
[27:12.000 --> 27:14.000]  что относится к объекту b.
[27:14.000 --> 27:16.000]  Согласны?
[27:16.000 --> 27:18.000]  Вот.
[27:18.000 --> 27:20.000]  Ну и теперь смотрите, у меня все вот тут уничтожилось,
[27:20.000 --> 27:22.000]  и я захожу в деструктор a.
[27:22.000 --> 27:24.000]  И в деструкторе a снова вызываю виртуальный метод f.
[27:24.000 --> 27:26.000]  Ну и та же самая проблема.
[27:26.000 --> 27:28.000]  Теперь вот этот вот виртуальный метод f
[27:28.000 --> 27:30.000]  может захотеть полезть
[27:30.000 --> 27:32.000]  в уже удаленную часть.
[27:32.000 --> 27:34.000]  То есть та часть, которая уже в принципе
[27:34.000 --> 27:36.000]  компилятором была, ну не компилятором,
[27:36.000 --> 27:38.000]  а вот исполнителем была помечена как уже удаленная.
[27:38.000 --> 27:40.000]  Снова беда.
[27:40.000 --> 27:42.000]  Поэтому в конструкторах и деструкторах
[27:42.000 --> 27:44.000]  виртуальность просто-напросто не работает.
[27:44.000 --> 27:46.000]  То есть не то, что это будет undefined behavior,
[27:46.000 --> 27:48.000]  нет, просто вот не работает.
[27:48.000 --> 27:50.000]  То есть будут вызваны именно те методы,
[27:50.000 --> 27:52.000]  которые, точнее, вот тут будет вызвана
[27:52.000 --> 27:54.000]  обязательно метод a, и тут обязательно метод a,
[27:54.000 --> 27:56.000]  тут обязательно метод b,
[27:56.000 --> 27:58.000]  и обязательно метод b.
[27:58.000 --> 28:00.000]  Все.
[28:00.000 --> 28:02.000]  Окей?
[28:02.000 --> 28:04.000]  Все понятно здесь?
[28:06.000 --> 28:08.000]  Идем дальше.
[28:10.000 --> 28:12.000]  Ну, про виртуальность более-менее мы
[28:12.000 --> 28:14.000]  поговорили.
[28:14.000 --> 28:16.000]  Теперь, в общем, немного теории, вот как это все называется.
[28:16.000 --> 28:18.000]  Вот то, про что мы сейчас говорим,
[28:18.000 --> 28:20.000]  про механизмы позднего связывания,
[28:20.000 --> 28:22.000]  и тому подобное, называется динамическим
[28:22.000 --> 28:24.000]  полиморфизмом.
[28:24.000 --> 28:26.000]  Еще раз, у нас есть основные столпы,
[28:26.000 --> 28:28.000]  на которых держится объектно-ориентированное программирование,
[28:28.000 --> 28:30.000]  это абстракция, инкапсуляция, наследование
[28:30.000 --> 28:32.000]  и полиморфизм.
[28:32.000 --> 28:34.000]  Полиморфизм бывает разный.
[28:34.000 --> 28:36.000]  Давайте еще раз вспомним, что такое полиморфизм.
[28:36.000 --> 28:38.000]  Полиморфизм — это свойство системы, которая позволяет
[28:38.000 --> 28:40.000]  использовать несколько реализаций
[28:40.000 --> 28:42.000]  в рамках одного интерфейса.
[28:42.000 --> 28:44.000]  И до этого мы, на самом деле, говорили про полиморфизм
[28:44.000 --> 28:46.000]  как про вещь, которая позволяет нам
[28:46.000 --> 28:48.000]  выбрать нужную функцию в зависимости того,
[28:48.000 --> 28:50.000]  например, шаблоны.
[28:52.000 --> 28:54.000]  То есть мы можем одну и ту же функцию F использовать для нескольких типов.
[28:54.000 --> 28:56.000]  Или перегрузка — то же самое.
[28:56.000 --> 28:58.000]  То есть мы можем использовать одну и ту же операцию,
[28:58.000 --> 29:00.000]  но при этом для разных типов и даже своих собственных.
[29:00.000 --> 29:02.000]  И это всё является примерно статического полиморфизма.
[29:02.000 --> 29:04.000]  Почему статического?
[29:04.000 --> 29:06.000]  Статический полиморфизм означает,
[29:06.000 --> 29:08.000]  что мы реализацию выбираем на этапе компиляции.
[29:08.000 --> 29:10.000]  То есть понятно дело,
[29:10.000 --> 29:12.000]  что шаблоны,
[29:12.000 --> 29:14.000]  выбор перегрузки, перегрузка операции,
[29:14.000 --> 29:16.000]  всё работает на этапе компиляции.
[29:16.000 --> 29:22.220]  выбирает, какую версию той или иной функции нужно выбрать. Понятно? Динамический полиморфизм,
[29:22.220 --> 29:29.980]  вроде как тоже, осуществляет, реализует вот этот механизм полиморфизма, то есть в зависимости
[29:29.980 --> 29:33.820]  того, на какой объект мы указываем, выбирает вся или иная функция. Но при этом это все происходит
[29:33.820 --> 29:38.780]  не на этапе компиляции, как мы обсудили до этого, а во время исполнения программы. Программа
[29:38.780 --> 29:44.020]  выполняется, в процессе своей работы она исполняется, и в какой-то момент она может вызвать
[29:44.020 --> 29:51.080]  функцию f из a или может вызвать функцию f из b, в зависимости того, какое условие ей пришло. И это все
[29:51.080 --> 29:58.960]  происходит во время исполнения, а не во время компиляции. Вот. Да, ну и, собственно, основной
[29:58.960 --> 30:03.040]  механизм реализации динамического полиморфизма — это виртуальные функции. Ну, есть еще второй,
[30:03.040 --> 30:09.760]  есть еще один механизм реализации динамического полиморфизма. Кто вспомнит? Обсуждали. Ну,
[30:09.760 --> 30:14.940]  указатель на функцию. Если вы используете указатель на функцию, то это тоже как бы динамический
[30:14.940 --> 30:20.460]  полиморфизм, потому что вы можете использовать либо ту, либо иную функцию в зависимости
[30:20.460 --> 30:26.500]  каких-то условий. Да, и, собственно, наследование с применением виртуальных функций называют
[30:26.500 --> 30:30.940]  полиморфным. Вот если у вас в наследовании присутствуют виртуальные функции, то такое
[30:30.940 --> 30:36.620]  наследование называется полиморфным, не виртуальным. Значит, в C++ существует понятие
[30:36.620 --> 30:41.320]  виртуального наследования, и это вот не про это. Виртуальное наследование — это совсем про
[30:41.320 --> 30:45.720]  другое, я не знаю, успеем мы в этом году про это поговорить или нет, но в общем, виртуальное
[30:45.720 --> 30:53.280]  наследование — это вот не про это, здесь полиморфное наследование. Окей? Ну, потому
[30:53.280 --> 30:56.480]  что полиморфное наследование позволяет реализовать динамический полиморфизм. Окей?
[30:56.480 --> 31:03.880]  Ну и собственно… Для чего нам это все нужно? Мы вроде как обсудили, что, наверное, иногда это
[31:03.880 --> 31:09.880]  это бывает полезно. Ну и на самом деле динамический полиморпизм используется довольно часто во многих паттернах.
[31:09.880 --> 31:13.880]  Очень часто бывает полезно. Давайте такой игрушечный пример.
[31:13.880 --> 31:19.880]  Я утверждаю, что с помощью динамического полиморпизма мне сейчас удастся
[31:19.880 --> 31:25.880]  создать массив из объектов разных типов. Как я это сделаю?
[31:25.880 --> 31:31.880]  Давайте я заведу класс «Животное». Допустим я хочу в одном массиве хранить всех животных.
[31:31.880 --> 31:37.880]  Кошек, собак и тому подобное. Понятно дело, что тип кошки, тип собаки отличаются.
[31:37.880 --> 31:40.880]  Но при этом мне бы хотелось их всех хранить в одном массиве.
[31:40.880 --> 31:43.880]  Как бы в классическом C++, то есть до сегодняшней лекции мы этого делать не могли.
[31:43.880 --> 31:46.880]  А сейчас я утверждаю, что сможем. Смотрите, что мы делаем.
[31:46.880 --> 31:54.880]  Мы заводим класс «Животное» и заводим в нем виртуальный метод, который могут выполнять все животные.
[31:54.880 --> 31:59.880]  Например, подать голос. Заводим, соответственно, кошку и в ней переопределяем этот метод voice.
[32:00.880 --> 32:04.880]  Заводим собаку, она лает. Заводим лису, она тоже что-то делает.
[32:04.880 --> 32:08.880]  Соответственно, у нас есть такая иерархия. Есть животное.
[32:08.880 --> 32:17.880]  И все животные в нашей программе, они все унаследованы от этого базового класса.
[32:17.880 --> 32:21.880]  Ну и теперь смотрите, что я делаю. Если я хочу создать массив всех животных,
[32:21.880 --> 32:27.880]  я просто-напросто беру и создаю массив указателей на животных.
[32:29.880 --> 32:33.880]  Ну и далее я могу делать следующую вещь. То есть я могу заполнить этот массив.
[32:33.880 --> 32:40.880]  Например, for int i равно 0 и меньше 10 i, плюс-плюс i.
[32:40.880 --> 32:51.880]  Ну и в зависимости от каких-то условий сделать animal с i равно new cat,
[32:51.880 --> 32:57.880]  либо new, в зависимости от какого-то условия, new fox или new dog.
[32:58.880 --> 33:02.880]  То есть я, например, могу с клавиатуры вводить имя животного,
[33:02.880 --> 33:06.880]  и в зависимости от того, какое имя я ввел, мне добавляется в этот массив либо кошка,
[33:06.880 --> 33:08.880]  либо собака, либо кто-то еще.
[33:08.880 --> 33:11.880]  Понятное дело, что на этапе компиляции, то есть компилятор, в принципе,
[33:11.880 --> 33:15.880]  не зная заранее, какие животные у вас будут храниться в массиве, в каком порядке и так далее.
[33:15.880 --> 33:18.880]  Все это происходит непосредственно во время исполнения программы.
[33:18.880 --> 33:22.880]  И дальше вы делаете следующую вещь. Вы просто для каждого животного вызываете метод voice.
[33:22.880 --> 33:26.880]  То есть вы можете, например, вашему зоопару сказать, ну там, все подать голос.
[33:26.880 --> 33:31.880]  И сразу раз на экране будут появляться именно те звуки, которые вы задали в методе voice
[33:31.880 --> 33:34.880]  для каждого из отдельных типов. Понятно?
[33:34.880 --> 33:37.880]  То есть мы единым образом работаем с объектами разных типов,
[33:37.880 --> 33:41.880]  и при этом их все храним в одном массиве. Круто?
[33:43.880 --> 33:49.880]  Ну и на самом деле, если говорить так, в общем, чем вообще хорош C++,
[33:49.880 --> 33:54.880]  почему вообще мы изучаем C++, во многих университетах C++ изучается как базовый язык.
[33:54.880 --> 34:00.880]  Да потому что вот эта реализация, динамический полиморфизм,
[34:00.880 --> 34:02.880]  он лежит в основе очень многих языков программирования.
[34:02.880 --> 34:05.880]  Например, вы знаете язык Python.
[34:05.880 --> 34:09.880]  Например, в Python в массивах можно хранить объекты разных типов.
[34:09.880 --> 34:11.880]  За счет чего это достигается?
[34:11.880 --> 34:13.880]  Ну как раз таки за счет этого.
[34:13.880 --> 34:16.880]  Например, в одной из самых популярных реализаций Пайтона, CITON,
[34:16.880 --> 34:21.880]  который реализован на C, на C++, там как раз используется динамический полиморфизм.
[34:21.880 --> 34:28.880]  То есть предполагается, что все объекты в Python унаследованы от одного класса object, условно.
[34:28.880 --> 34:33.880]  То есть в Python есть общий базовый класс object, от которого унаследованы вообще все типы.
[34:33.880 --> 34:40.880]  И вот на самом деле, когда вы создаете массив объектов, у вас в этом массиве как раз-таки хранятся указатели нам вот эти объекты типа object.
[34:40.880 --> 34:45.880]  И за счет этого получается достичь того, что у вас в одном массиве могут храниться элементы абсолютно разных типов.
[34:45.880 --> 34:49.880]  И вот именно в основе всего этого лежит вот этот механизм.
[34:51.880 --> 34:56.880]  Ну, соответственно, в C++ тоже можно реализовать что-то подобное.
[34:56.880 --> 34:59.880]  То есть можно писать вообще свою стандартную библиотеку,
[34:59.880 --> 35:02.880]  создать базовый класс object, от которого унаследованы вообще все типы.
[35:02.880 --> 35:06.880]  То есть создать класс int, класс float и так далее, унаследовать их всех от object,
[35:06.880 --> 35:12.880]  и тогда можно будет хранить объекты разных типов в одном массиве.
[35:12.880 --> 35:18.880]  Ну и вопрос, а почему так не делают? Почему не сделать так?
[35:18.880 --> 35:25.880]  Что? Да, непроизводительно. То есть как мы сказали, механизм позднего связывания работает долго.
[35:25.880 --> 35:31.880]  Потому что на этапе компиляции мы можем что-то саптимизировать, мы можем подставить конкретные вызовы, мы можем что-то заинлайнить и так далее.
[35:31.880 --> 35:35.880]  Когда мы используем механизм позднего связывания, мы такой возможности просто-напросто теряемся.
[35:35.880 --> 35:38.880]  Потому что мы выбираем функцию непосредственно на этапе исполнения.
[35:38.880 --> 35:42.880]  То есть это какой-то дополнительный код, какие-то дополнительные затраты на выборы функции.
[35:42.880 --> 35:46.880]  Ну а во-вторых, это дополнительные затраты на вызов функции и так далее.
[35:55.880 --> 36:01.880]  Еще один важный момент, который касается виртуальных методов, ну и в принципе полимортного наследования, это виртуальный деструктор.
[36:01.880 --> 36:07.880]  Деструкторы тоже можно делать виртуальными. То есть может возникать вопрос, а для чего?
[36:07.880 --> 36:12.880]  На самом деле виртуальный деструктор это чуть ли не самое важное, а вот про что мы сегодня будем говорить.
[36:12.880 --> 36:18.880]  Проблема следующая. Вот представьте себе такую вещь. Вот у меня есть класс stack.
[36:18.880 --> 36:26.880]  И я создал класс stackMax, то есть класс stack с поддержкой максимума.
[36:26.880 --> 36:33.880]  И я его унаследовал от класса stack. Ну понятно, то есть публичная наследование говорит о том, что stackMax является stack.
[36:33.880 --> 36:39.880]  Ну и понятное дело, что их реализации похожи, поэтому я как бы, например, чтобы избежать дублирование кода делаю вот такую вещь.
[36:39.880 --> 36:45.880]  Разумно? Окей. Ну и теперь представьте себе, что я делаю следующую вещь.
[36:45.880 --> 36:51.880]  Я создаю указатель на stack, но при этом ему присваиваю объект типа stackMax.
[36:51.880 --> 36:55.880]  Ну я могу так сделать? Могу.
[36:55.880 --> 37:01.880]  Окей. Ну и теперь, так как я создавал объект с помощью new, я должен его очистить с помощью delete.
[37:01.880 --> 37:06.880]  И вот тут я вызываю delete. В чем беда? В чем проблема?
[37:09.880 --> 37:15.880]  Ага, да. Действительно. Что делает delete? Кто помнит? В первую очередь.
[37:15.880 --> 37:21.880]  Да, delete в первую очередь вызывает деструктор. А какой деструктор будет вызывать тут delete?
[37:22.880 --> 37:30.880]  Да, тут будет вызвать деструктор stack. А почему? Неужели компилятор такой тупой и будет вызывать именно вот этот деструктор?
[37:30.880 --> 37:38.880]  Ну да, правда. Компилятор тупой. Почему? Потому что компилятор на самом деле просто-напросто берет и смотрит, а какой указатель мы удаляем?
[37:38.880 --> 37:43.880]  А удаляем мы указатель на stack. Вот. Stack со звездой.
[37:43.880 --> 37:47.880]  Но так как мы удаляем указатель на stack, то и значит, что нужно вызвать деструктор stack.
[37:47.880 --> 37:53.880]  Ну и все. У нас есть часть, которая относится к stack, и есть часть, которая относится к max.
[37:53.880 --> 38:00.880]  Вот. Вот эта часть будет удалена, а вот тут, если даже были какие-то выделения памяти и тому подобное, то ничего с убеждением не будет.
[38:00.880 --> 38:04.880]  Беда? Беда.
[38:04.880 --> 38:15.880]  Вот. Да. Ну и, собственно, здесь все расписано. Да, действительно, что тип stackptr это stack-указатель, delete вызывает деструктор stack, а не stackmax.
[38:15.880 --> 38:20.880]  Поэтому stackmax будет уничтожен неправильно. Ну, то есть, просто на обстановке findBehaviour.
[38:20.880 --> 38:23.880]  Ну, а на практике это утечка памяти.
[38:23.880 --> 38:29.880]  Как решается эта проблема? Решается проблема очень просто. Нужно объявить... То есть, если вы предполагаете...
[38:29.880 --> 38:34.880]  Давайте я сразу скажу, что не надо там заводить панику и вообще все деструкторы делать виртуальными, нет.
[38:34.880 --> 38:42.880]  Если вы предполагаете, что ваш класс может являться базовым классом для каких-то других классов, то в этом классе нужно делать деструктор виртуальным.
[38:42.880 --> 38:47.880]  Чем помогает виртуальный деструктор? Ну, собственно, ровно тем же, чем помогает виртуальность для остальных методов.
[38:47.880 --> 38:58.880]  Значит, если вы объявили деструктор виртуальным, то выбор конкретного деструктора будет осуществляться непосредственно на этапе исполнения программы, а не на этапе компиляции.
[38:58.880 --> 39:04.880]  То есть, что здесь происходит? Теперь. Тип stack-ptr – это stack-указатель.
[39:04.880 --> 39:10.880]  Поэтому я иду в класс stack и смотрю, какой там деструктор. И вижу, что там деструктор виртуальный.
[39:10.880 --> 39:14.880]  Но раз деструктор виртуальный, то это значит, что мне нужно посмотреть повнимательнее.
[39:14.880 --> 39:18.880]  То есть, уже не на этапе компиляции, а на этапе исполнения программы.
[39:18.880 --> 39:22.880]  То есть, нужно посмотреть, какой на самом деле объект лежит под этим указателем.
[39:22.880 --> 39:29.880]  А под этим указателем лежит указатель на stack-max, поэтому тут на самом деле будет вызван деструктор stack-max.
[39:29.880 --> 39:33.880]  И все благодаря виртуальному деструктуру в базовом классе.
[39:38.880 --> 39:41.880]  Ну вот, пока осознайте это, и после перерывов продолжим.
[39:42.880 --> 39:51.880]  Так, продолжим. В общем, как я сказал, если у вас предполагается
[39:51.880 --> 39:58.880]  использование вашего класса как некоторого полиморфного наследника,
[39:58.880 --> 40:01.880]  то есть, если в вашем классе есть какие-то виртуальные методы,
[40:01.880 --> 40:07.880]  то необходимо также позаботиться о том, что у вас и деструктор тоже был виртуальный.
[40:07.880 --> 40:10.880]  То есть, для полиморфных классов необходимо писать виртуальный деструктор.
[40:10.880 --> 40:13.880]  Это просто, в общем, жизненно необходимо.
[40:18.880 --> 40:25.880]  Ну и теперь поговорим про некоторые ключевые слова, которые помогут упростить написание полиморфных классов.
[40:25.880 --> 40:31.880]  Ну и в принципе, уберегут от большого количества проблем.
[40:31.880 --> 40:33.880]  Это слова overwrite и final.
[40:37.880 --> 40:42.880]  Да, естественно, если вы что-то наследуете, то эти же самые функции тоже виртуальные.
[40:42.880 --> 40:47.880]  Если у вас в базовом классе виртуальная, то эта виртуальность сохраняется для всех остальных классов.
[40:58.880 --> 41:00.880]  Поговорим про слова overwrite и final.
[41:00.880 --> 41:09.880]  Проблема следующая. Мы, на самом деле, с ней уже столкнулись, когда обсуждали один из примеров.
[41:09.880 --> 41:13.880]  Помните, когда у нас была функция g, которая void, или функция g, которая char.
[41:13.880 --> 41:17.880]  Там действительно было легко запутаться в том, какая функция является виртуальной,
[41:17.880 --> 41:19.880]  какая не является виртуальной.
[41:19.880 --> 41:21.880]  Так вот, чтобы этого не было, есть специальные слова.
[41:21.880 --> 41:24.880]  Давайте подробнее про проблему.
[41:24.880 --> 41:30.880]  Мы помним, что виртуальность работает только для функции определенного типа.
[41:30.880 --> 41:35.880]  Если я сказал, что функция void fint, она виртуальная,
[41:35.880 --> 41:40.880]  то это означает, что функция void flong в производном классе виртуальной уже не будет.
[41:40.880 --> 41:43.880]  Виртуальность строго сохраняет тип.
[41:43.880 --> 41:47.880]  То же самое касается константности. Константность это тоже часть типа функции.
[41:47.880 --> 41:51.880]  Поэтому если у вас в базовом классе функция g является константной,
[41:51.880 --> 41:53.880]  а в производном классе g она не является константной,
[41:53.880 --> 41:55.880]  то вот эта функция, она с этой никак не связана.
[41:55.880 --> 41:58.880]  Сюда виртуальность не распространяется.
[41:58.880 --> 42:02.880]  И это является, естественно, источником большого количества ошибок.
[42:02.880 --> 42:09.880]  Чтобы переопределить виртуальную функцию, вам нужно в точности дословно знать
[42:09.880 --> 42:12.880]  интерфейс или тип функций, которые есть в базовом классе.
[42:12.880 --> 42:14.880]  Понятно?
[42:14.880 --> 42:18.880]  Но при этом понятное дело, что забыть написать конст очень просто.
[42:18.880 --> 42:22.880]  Ну и, соответственно, здесь показана эта проблема, что, действительно,
[42:22.880 --> 42:28.880]  если у меня есть указатель на a, который на самом деле указывает на объекте по b,
[42:28.880 --> 42:31.880]  и я вызываю здесь f от нуля, то, казалось бы, я тут предполагаю,
[42:31.880 --> 42:33.880]  что у меня будет вызвана функция f, которая находится в b,
[42:33.880 --> 42:35.880]  потому что f — это виртуальная функция.
[42:35.880 --> 42:38.880]  Но при этом нет, будет вызвана функция f, которая находится в a. Почему?
[42:38.880 --> 42:41.880]  Еще раз, потому что эта функция никак не связана с функцией f от int.
[42:41.880 --> 42:44.880]  f от int и f от long — это абсолютно разные функции.
[42:44.880 --> 42:46.880]  То же самое касается функции g.
[42:46.880 --> 42:49.880]  В базовом классе у меня функция g объявлена как константная,
[42:49.880 --> 42:52.880]  в производном классе эта функция g не константная.
[42:52.880 --> 42:55.880]  Поэтому здесь будет вызвана именно функция g, которая находится в a,
[42:55.880 --> 42:58.880]  а не которая в b. Понятно?
[42:58.880 --> 43:02.880]  И вот чтобы избежать таких проблем, то есть с точки зрения компилятора,
[43:02.880 --> 43:04.880]  естественно, это не ошибка.
[43:04.880 --> 43:07.880]  То есть, возможно, вы предполагали, что вот эти вот функции f и g,
[43:07.880 --> 43:10.880]  они переопределяют в виртуальные функции, которые находятся выше.
[43:10.880 --> 43:12.880]  Но при этом это не так.
[43:12.880 --> 43:15.880]  Но и компилятор, естественно, ругаться не будет и выдавать предупреждения не будет,
[43:15.880 --> 43:17.880]  потому что это вполне символично.
[43:17.880 --> 43:20.880]  Он просто создал новые функции, которые никак не связаны с теми.
[43:20.880 --> 43:22.880]  Все нормально.
[43:22.880 --> 43:25.880]  Но вот если вы хотите, чтобы компилятор действительно проследил,
[43:25.880 --> 43:27.880]  что вы сделали все правильно,
[43:27.880 --> 43:32.880]  это не ключевое слово, это зарезервированный идентификатор.
[43:32.880 --> 43:35.880]  То есть есть специальное слово — overwrite,
[43:35.880 --> 43:39.880]  которое будет следить за тем, чтобы вы сделали все так, как хотели.
[43:39.880 --> 43:43.880]  Вы просто после функции, которую вы предполагаете, что она виртуальная,
[43:43.880 --> 43:45.880]  если у вас есть виртуальная функция,
[43:45.880 --> 43:48.880]  и вы хотите ее в наследники переопределить,
[43:48.880 --> 43:50.880]  вы должны написать слово overwrite.
[43:50.880 --> 43:53.880]  Точнее, не должны, если вы не напишете, ошибки не будет.
[43:53.880 --> 43:56.880]  Но при этом overwrite убережет вас от возможных проблем,
[43:56.880 --> 43:58.880]  которые мы обсуждали ранее.
[43:58.880 --> 44:01.880]  То есть если вы пишете overwrite,
[44:01.880 --> 44:07.880]  но при этом ваша функция никак не связана с какой-нибудь виртуальной функцией
[44:07.880 --> 44:10.880]  выше по иерархии наследования,
[44:10.880 --> 44:13.880]  то у вас возникнет ошибка в компиляции.
[44:13.880 --> 44:16.880]  Но в частности здесь вам скажут, что вот эта вот функция,
[44:16.880 --> 44:20.880]  она помещена как overwrite, но она на самом деле ничего не overrides.
[44:20.880 --> 44:22.880]  То же самое с функцией g.
[44:22.880 --> 44:25.880]  То есть функцию g вы пометили как overwrite, но она ничего не overrides.
[44:25.880 --> 44:28.880]  Потому что она никак не связана с той виртуальной функцией,
[44:28.880 --> 44:31.880]  которая находится в базовом классе.
[44:31.880 --> 44:34.880]  Понятно? Да.
[44:34.880 --> 44:37.880]  А функция, когда у вас такое несоответствие,
[44:37.880 --> 44:41.880]  проходит на этапе компиляции это делать или после?
[44:41.880 --> 44:43.880]  Нет, это естественно...
[44:43.880 --> 44:46.880]  На этапе компиляции, да, уже разбирается с тем,
[44:46.880 --> 44:49.880]  откинуть функцию дальше или сразу...
[44:49.880 --> 44:52.880]  Нет, тут все можно сделать на этапе компиляции.
[44:52.880 --> 44:55.880]  То есть компилятор же видит, что тут есть функция flong.
[44:55.880 --> 44:58.880]  И вы пометили ее как overwrite.
[44:58.880 --> 45:01.880]  Если без overwrite, то будет как и здесь.
[45:01.880 --> 45:04.880]  Проблем никаких не будет.
[45:04.880 --> 45:07.880]  Ошибки компиляции не будет.
[45:07.880 --> 45:10.880]  Просто будут вызываться функции f и g, которые находятся в a.
[45:10.880 --> 45:13.880]  Потому что в b вы ничего не приопределили.
[45:13.880 --> 45:16.880]  То есть точке зрения компилятора вы ничего не приопределили.
[45:16.880 --> 45:19.880]  Long и int это разные типы.
[45:19.880 --> 45:22.880]  g с констом и g без конста это разные типы тоже.
[45:22.880 --> 45:26.880]  Естественно, проверка overwrite, то есть overwrite это или не overwrite,
[45:26.880 --> 45:29.880]  это на этапе компиляции происходит.
[45:29.880 --> 45:32.880]  Что делает компилятор?
[45:32.880 --> 45:35.880]  Он видит, что есть функция flong.
[45:35.880 --> 45:38.880]  И вы утверждаете, что она переопределяет функцию,
[45:38.880 --> 45:41.880]  которая находится в базовом классе.
[45:41.880 --> 45:44.880]  Но при этом он смотрит в базовый класс и видит, что такой функции там нет.
[45:44.880 --> 45:47.880]  Ну и все, ошибка компиляции.
[45:47.880 --> 45:50.880]  Такой виртуальной функции там нет.
[45:50.880 --> 45:53.880]  Ну то есть условно, если у вас тут была функция h...
[45:53.880 --> 45:56.880]  void h.
[45:56.880 --> 45:59.880]  И тут бы вы написали тоже void h,
[45:59.880 --> 46:02.880]  и при этом написали overwrite,
[46:02.880 --> 46:05.880]  то тоже была бы ошибка компиляции. Почему?
[46:05.880 --> 46:08.880]  Потому что функция h не виртуальная.
[46:08.880 --> 46:11.880]  То есть overwrite работает только для виртуальных функций.
[46:20.880 --> 46:23.880]  Соответственно, как мы сказали,
[46:23.880 --> 46:26.880]  переопределять виртуальные функции можно только дословно.
[46:26.880 --> 46:29.880]  То есть типы функций могут совпадать.
[46:29.880 --> 46:32.880]  Это не совсем правда. Точнее, это правда с точностью
[46:32.880 --> 46:35.880]  до кавариантных возвращаемых типов.
[46:35.880 --> 46:38.880]  Что такое кавариантные возвращаемые типы?
[46:38.880 --> 46:41.880]  Кавариантные возвращаемые типы это типы, которые связаны
[46:41.880 --> 46:44.880]  между собой и иерархией наследования.
[46:44.880 --> 46:47.880]  То есть условно, если у вас виртуальная функция f,
[46:47.880 --> 46:50.880]  virtual,
[46:50.880 --> 46:53.880]  скажем, указатель на a,
[46:53.880 --> 46:56.880]  а функция f, которая находится в наследнике,
[46:56.880 --> 46:59.880]  возвращает указатель на b, и при этом a является
[46:59.880 --> 47:02.880]  базовым классом для b, то все OK.
[47:02.880 --> 47:05.880]  То есть несмотря на то, что a указатель и b указатель
[47:05.880 --> 47:08.880]  это разные типы, все равно они являются совместимыми
[47:08.880 --> 47:11.880]  между собой, поэтому все OK.
[47:11.880 --> 47:14.880]  Понятно?
[47:14.880 --> 47:17.880]  Только с указателями и ссылками.
[47:17.880 --> 47:20.880]  У нас не нравится только указатель или ссылки
[47:20.880 --> 47:23.880]  на типы, которые связаны между собой и иерархией наследования.
[47:23.880 --> 47:26.880]  Для чего это может быть нужно?
[47:26.880 --> 47:29.880]  Это часто применяется для всевозможных паттернов
[47:29.880 --> 47:32.880]  проектирования или в частности для так называемых
[47:32.880 --> 47:35.880]  виртуальных конструкторов копирования.
[47:35.880 --> 47:38.880]  Например, есть метод clone, который просто клонирует
[47:38.880 --> 47:41.880]  текущий объект, возвращая указатель на него.
[47:41.880 --> 47:44.880]  У вас есть класс a, и у вас есть метод clone, который возвращает
[47:44.880 --> 47:47.880]  объект типа a, но при этом копию на объект типа a.
[47:47.880 --> 47:50.880]  И вы переопределяете этот метод
[47:50.880 --> 47:53.880]  в наследники в классе b, и при этом
[47:53.880 --> 47:56.880]  в классе наследники он возвращает указатель на b.
[47:56.880 --> 47:59.880]  И при этом clone, который находится в базовом классе,
[47:59.880 --> 48:02.880]  и clone, который находится в наследнике, они между собой связаны,
[48:02.880 --> 48:05.880]  и по-прежнему они могут override друг другу.
[48:05.880 --> 48:08.880]  Они по-прежнему являются виртуальными, и они связаны друг с другом.
[48:08.880 --> 48:11.880]  Вот ровно потому, что тип a со звездой
[48:11.880 --> 48:14.880]  и тип b со звездой являются квариантными типами.
[48:19.880 --> 48:22.880]  Да, да, да.
[48:41.880 --> 48:44.880]  В смысле, вы имеете в виду, если вот так и ставить?
[48:47.880 --> 48:50.880]  Сейчас, указатель a, так.
[48:56.880 --> 48:59.880]  Так.
[49:07.880 --> 49:10.880]  Ну, вот так.
[49:10.880 --> 49:13.880]  Нет, смотрите, опять же,
[49:13.880 --> 49:16.880]  короче, срезки тут, естественно, не происходит.
[49:16.880 --> 49:19.880]  То есть вы работаете тупо с указателями.
[49:19.880 --> 49:22.880]  То есть даже если вы сделали так,
[49:22.880 --> 49:25.880]  в данном контексте у вас, в данном случае,
[49:25.880 --> 49:28.880]  у вас будет вызван clone, который расположен в b,
[49:28.880 --> 49:31.880]  то есть вот здесь.
[49:31.880 --> 49:34.880]  То есть будет вызван clone, который расположен в b,
[49:34.880 --> 49:37.880]  то есть вот здесь.
[49:37.880 --> 49:40.880]  То есть будет вызван clone,
[49:40.880 --> 49:43.880]  возвращает вам указатель на объект типа b.
[49:43.880 --> 49:46.880]  Если вы его сохраните в указатель на a,
[49:46.880 --> 49:49.880]  то так можно делать.
[49:49.880 --> 49:52.880]  Мы, собственно, всю лекцию этому посвятили.
[49:52.880 --> 49:55.880]  Но при этом, естественно, весь b,
[49:55.880 --> 49:58.880]  потому что вы создаете весь b.
[49:58.880 --> 50:01.880]  То есть указатели ссылки
[50:01.880 --> 50:04.880]  никакой срезки не делают никогда.
[50:04.880 --> 50:07.880]  Указатели ссылки ссылаются именно
[50:07.880 --> 50:10.880]  на тот объект, который у вас есть.
[50:16.880 --> 50:19.880]  Ну, есть еще одно специальное слово, final,
[50:19.880 --> 50:22.880]  которое говорит следующее.
[50:22.880 --> 50:25.880]  Final говорит о том, что эту функцию больше
[50:25.880 --> 50:28.880]  переопределять нельзя.
[50:28.880 --> 50:31.880]  То есть вот эта функция, которая оплена здесь,
[50:31.880 --> 50:34.880]  больше изменению не подлежит в наследниках.
[50:34.880 --> 50:37.880]  Ну вот как это работает?
[50:37.880 --> 50:40.880]  Вот у вас есть виртуальная функция f,
[50:40.880 --> 50:43.880]  вы ее переопределяете в структуре b,
[50:43.880 --> 50:46.880]  и при этом говорите, что она final.
[50:46.880 --> 50:49.880]  Наследники b не имеют права эту функцию как-то переопределять.
[50:49.880 --> 50:52.880]  Но это может быть нужно, например, если вы в классе
[50:52.880 --> 50:55.880]  переопределили какое-то ее поведение,
[50:55.880 --> 50:58.880]  и дальше не хотите, чтобы оно как-то менялось.
[50:58.880 --> 51:01.880]  То есть у вас нет логики класса b.
[51:01.880 --> 51:04.880]  И теперь, если вы в структуре c,
[51:04.880 --> 51:07.880]  которая наследована от b, попытаетесь эту функцию заоверайдить,
[51:07.880 --> 51:10.880]  точнее попытаетесь ее переопределить,
[51:10.880 --> 51:13.880]  то есть создать другую функцию, то есть начинать создать функцию,
[51:13.880 --> 51:16.880]  которая тоже является void, которая ничего не принимает,
[51:16.880 --> 51:19.880]  имеет имя f, то у вас ничего не получится, будет ошибка компиляции.
[51:19.880 --> 51:22.880]  Почему? То же самое.
[51:22.880 --> 51:25.880]  Override вообще ни на что не влияет.
[51:25.880 --> 51:28.880]  Грубо говоря, предохраняет вас от ошибок.
[51:28.880 --> 51:31.880]  Неважно, писали вы override или нет, у вас все равно происходит переопределение.
[51:31.880 --> 51:34.880]  Override, грубо говоря, с точки зрения...
[51:34.880 --> 51:37.880]  Override не привносит никакой код.
[51:37.880 --> 51:40.880]  То есть, грубо говоря, компиляторы его игнорируют в той степени,
[51:40.880 --> 51:43.880]  что он лишь выдает вам предупреждение, если у вас что-то идет не так.
[51:43.880 --> 51:46.880]  В остальном override ни на что не влияет.
[51:46.880 --> 51:49.880]  По код-стайлу, да.
[51:49.880 --> 51:52.880]  Точнее так. Если вы переопределяете виртуальную функцию,
[51:52.880 --> 51:55.880]  то нужно писать override.
[51:55.880 --> 51:58.880]  Если вы не делаете этого, то не нужно.
[51:58.880 --> 52:01.880]  Компилятору, на самом деле, от этого не жарко,
[52:01.880 --> 52:04.880]  но это просто вас спасает от ошибок.
[52:04.880 --> 52:07.880]  И, соответственно, будет ошибка, что
[52:07.880 --> 52:10.880]  виртуальная функция CF переопределяет финальную функцию,
[52:10.880 --> 52:13.880]  которая вот здесь была объявлена как финальная.
[52:13.880 --> 52:16.880]  То есть final запрещает
[52:16.880 --> 52:19.880]  дальнейшее переопределение этой функции в наследниках.
[52:22.880 --> 52:25.880] RETUR華 я Quinn.
[52:26.880 --> 52:33.240]  Да. Ну, соответственно, правило
[52:33.240 --> 52:36.240]  понятное дело, что финальный можно пометить только виртуальную функцию.
[52:36.240 --> 52:39.240]  То есть нельзя просто так взять и сказать,
[52:39.240 --> 52:42.240]  что какой-то метод финальный.
[52:42.240 --> 52:45.240]  Финальный может быть только виртуальная функция
[52:45.240 --> 52:48.240]  потому что переопределяются к виртуальной функции.
[52:48.240 --> 52:51.240]  А невертуальные функции, што с ними происходит?
[52:51.240 --> 53:01.040]  Если вы все-таки хотите написать функцию, которую вообще никак нельзя не переопределить, не заместить в наследниках,
[53:01.040 --> 53:05.440]  то можно ее создать виртуальной и сразу сделать ее финальной.
[53:05.440 --> 53:09.440]  Тогда в наследниках в принципе нельзя будет создать функцию voidf.
[53:09.440 --> 53:19.440]  Потому что, во-первых, так как это функция виртуальная, то компилятор будет считать, что любая функция voidf — это переопределение.
[53:19.640 --> 53:22.640]  Ну а так как вы написали final, то переопределения запрещены.
[53:26.640 --> 53:31.640]  Да, соответственно, это имеет смысл, если хочешь запретить наследникам определять функции с тем же именем и типом.
[53:33.640 --> 53:39.640]  Ну и еще одно место, где может использоваться final. Final может использоваться на уровне с классом, точнее с объявлением класса.
[53:39.640 --> 53:44.640]  Тут все просто. Это слово просто говорит о том, что от этого класса нельзя наследоваться.
[53:44.840 --> 53:49.840]  Если вы хотите, чтобы от вашего класса нельзя было наследоваться, то вы помечаете его final.
[53:49.840 --> 53:58.840]  Для чего это может быть нужно? Например, у вас есть класс, в котором есть виртуальные функции, которые вы унаследовали от кого-то,
[53:58.840 --> 54:02.840]  но при этом виртуального деструктора в этом классе у вас не предполагается.
[54:02.840 --> 54:06.840]  Не потому что вы не хотите, чтобы от вашего класса в принципе кто-то наследовался и так далее.
[54:06.840 --> 54:09.840]  Тогда просто пишите final и тогда вы защищаете себя от ошибок.
[54:09.840 --> 54:13.840]  Если вы случайно от этого класса унаследуетесь, то будет ошибка компиляции.
[54:14.040 --> 54:16.040]  Понятно?
[54:22.040 --> 54:28.040]  Еще один пункт. Поговорим про чисто виртуальные функции и абстрактные классы.
[54:30.040 --> 54:32.040]  Вот такой.
[54:33.040 --> 54:35.040]  Почти жизни, например.
[54:35.040 --> 54:41.040]  Допустим, вы пишете какой-то свой messenger на языке C++.
[54:41.240 --> 54:47.240]  Ну и понятное дело, чтобы как-то описать логику вашей программы и так далее,
[54:47.240 --> 54:55.240]  вы вводите туда новые классы, новые сущности, описываете вашу программу в вас messenger с точки зрения каких-то других абстракций.
[54:55.240 --> 54:58.240]  Но с частности, вам нужен, например, класс сообщения.
[54:58.240 --> 55:01.240]  Если вы хотите послать какое-то сообщение, то для этого нужен класс.
[55:01.240 --> 55:05.240]  Но при этом вы понимаете, что типа в сообщении у вас может быть несколько.
[55:05.240 --> 55:08.240]  И при этом каждое сообщение ведет себя как-то иначе.
[55:08.440 --> 55:14.440]  Есть текстовые сообщения, есть сообщения в виде картинки, есть сообщения в виде видео и так далее.
[55:14.440 --> 55:16.440]  Типов сообщений может быть очень много.
[55:16.440 --> 55:26.440]  И при этом, наверное, хотелось бы иметь возможность для каждого конкретного пользователя хранить массив тех сообщений, которые у него есть.
[55:26.440 --> 55:31.440]  Как добиться того, чтобы можно было в одном массиве хранить сообщения разных типов?
[55:31.440 --> 55:35.440]  Ну, естественно, с помощью динамического полиморфизма.
[55:35.440 --> 55:37.440]  То, про что мы говорили.
[55:37.640 --> 55:39.640]  Поэтому что мы делаем?
[55:39.640 --> 55:42.640]  Мы заводим базовый класс сообщения и говорим в нем следующее.
[55:42.640 --> 55:46.640]  У него есть метод send, который просто берет и отправляет сообщение в нужный чат.
[55:46.640 --> 55:48.640]  Чат мы принимаем по указателю.
[55:48.640 --> 55:52.640]  Мы принимаем указатель на чат и в этот чат отправляем это сообщение.
[55:52.640 --> 55:54.640]  Ну ладно, в общем, нам не важно, как работает логика.
[55:54.640 --> 55:57.640]  И плюс мы предполагаем, что у каждого сообщения есть метод display,
[55:57.640 --> 56:01.640]  который просто, например, на устройстве отображает это самое сообщение.
[56:01.640 --> 56:06.640]  Понятное дело, что текстовые сообщения, сообщения видео, сообщения картинка, они отображаются по-разному.
[56:06.840 --> 56:08.840]  Ну, естественно.
[56:08.840 --> 56:12.840]  Текст это просто текст, а картинку нужно как-то декодировать.
[56:12.840 --> 56:19.840]  Поэтому мы предполагаем, что метод display должен быть переопределен в классах наследников.
[56:21.840 --> 56:25.840]  Ну то есть в классе текстовые сообщения метод display выглядит одним образом,
[56:25.840 --> 56:29.840]  в классе сообщения sticker отображение выглядит другим способом и так далее.
[56:29.840 --> 56:32.840]  И каждый класс по-своему переопределяет этот метод display.
[56:32.840 --> 56:34.840]  Логика понятна?
[56:35.040 --> 56:37.040]  Вот.
[56:37.040 --> 56:39.040]  В общем, вот такая иерархия.
[56:39.040 --> 56:41.040]  Все, логично, окей.
[56:41.040 --> 56:46.040]  Ну и теперь давайте попробуем ответить на некоторые вопросы и посвятить некоторые проблемы.
[56:46.040 --> 56:50.040]  Ну вот смотрите, у меня есть базовый класс message.
[56:54.040 --> 57:02.040]  Есть, соответственно, текстовые сообщения, есть там изображения, есть там stickers, ну и так далее.
[57:02.240 --> 57:04.240]  Вопрос.
[57:04.240 --> 57:10.240]  Имеет ли в моей программе вообще смысл создавать объекты типа message?
[57:10.240 --> 57:12.240]  message msg
[57:16.240 --> 57:18.240]  Ну, наверное, нет.
[57:18.240 --> 57:20.240]  Что означает абстрактное сообщение?
[57:20.240 --> 57:22.240]  Ну, непонятно, да?
[57:22.240 --> 57:24.240]  В общем, что такое сообщение?
[57:24.240 --> 57:26.240]  Сообщение может быть либо текстовое, либо видео, либо изображение и так далее.
[57:26.240 --> 57:29.240]  Просто сообщение какое-то абстрактное, не имеет смысла.
[57:29.240 --> 57:31.240]  То же самое как сказать, я купил мебель.
[57:31.440 --> 57:34.440]  На ней можно сидеть, за ней можно писать и так далее.
[57:34.440 --> 57:36.440]  Но ничего не понятно, да?
[57:36.440 --> 57:38.440]  То есть можно купить конкретный объект.
[57:38.440 --> 57:40.440]  Второй вопрос.
[57:40.440 --> 57:42.440]  А что должен делать метод display в message?
[57:42.440 --> 57:46.440]  Ну, смотрите, так как я написал класс message, в нем есть метод display.
[57:46.440 --> 57:49.440]  И, естественно, мне нужно его как-то реализовать.
[57:49.440 --> 57:51.440]  То есть я не могу оставлять методы без реализации.
[57:51.440 --> 57:55.440]  То есть я не могу просто написать функцию, я не могу просто объедить функцию и ее никак не определить.
[57:58.440 --> 58:00.440]  Что должен делать метод display в message?
[58:00.640 --> 58:02.640]  Ну, вообще непонятно.
[58:02.640 --> 58:04.640]  Ну, снова, как отобразить абстрактное сообщение?
[58:04.640 --> 58:06.640]  Вообще ничего непонятно.
[58:06.640 --> 58:08.640]  Третий вопрос.
[58:08.640 --> 58:10.640]  Как заставить наследников реализовывать display?
[58:10.640 --> 58:12.640]  Ну, хорошо, допустим, я придумал какой-то логичный способ
[58:12.640 --> 58:14.640]  делать отображение произвольного сообщения.
[58:14.640 --> 58:18.640]  Но при этом понятное дело, что у меня есть другие типы сообщений,
[58:18.640 --> 58:21.640]  в которых мне просто необходимо реализовать свой метод display.
[58:21.640 --> 58:23.640]  Точнее, свою реализацию display.
[58:23.640 --> 58:27.640]  И при этом мне нужно заставить их реализовать это все по-своему.
[58:27.640 --> 58:29.640]  Ну, понятно почему, да?
[58:29.840 --> 58:31.840]  То есть я, например, могу реализовать класс
[58:31.840 --> 58:33.840]  sticker message,
[58:33.840 --> 58:35.840]  и при этом забыть реализовать вот этот метод.
[58:35.840 --> 58:37.840]  Ну, просто могу про него забыть.
[58:37.840 --> 58:40.840]  Ну, при этом, если я про него забуду, то ничего страшного.
[58:40.840 --> 58:42.840]  У меня просто будет использоваться метод из базового класса.
[58:42.840 --> 58:44.840]  Ну, а это, естественно, баг.
[58:44.840 --> 58:46.840]  То есть мне, наверное, хотелось бы еще
[58:46.840 --> 58:50.840]  про метод display сказать, что этот метод обязательно для реализации.
[58:50.840 --> 58:54.840]  То есть вы все должны по-своему обязательно его как-то реализовать.
[58:54.840 --> 58:56.840]  То есть использовать базовую реализацию нельзя.
[58:56.840 --> 58:58.840]  Вот.
[58:58.840 --> 59:00.840]  Вот такие три проблемы.
[59:00.840 --> 59:02.840]  И все они решаются с помощью
[59:02.840 --> 59:04.840]  так называемых чисто виртуальных функций
[59:04.840 --> 59:06.840]  или чисто виртуальных методов.
[59:06.840 --> 59:08.840]  Значит, что такое чисто виртуальная функция
[59:08.840 --> 59:10.840]  или чисто виртуальный метод?
[59:10.840 --> 59:12.840]  Это метод, который помечается, в общем,
[59:12.840 --> 59:14.840]  в конце конструкции равно ноль.
[59:14.840 --> 59:16.840]  То есть, по-моему, да, мы обсуждали,
[59:16.840 --> 59:18.840]  там равно default, равно delete,
[59:18.840 --> 59:20.840]  и вот сейчас есть конструкция равно ноль.
[59:20.840 --> 59:22.840]  Вот если вы методу говорите,
[59:22.840 --> 59:24.840]  что он равен нулю, то это значит, что вы определяете
[59:24.840 --> 59:26.840]  чисто виртуальный метод.
[59:26.840 --> 59:28.840]  Чисто виртуальный метод это метод,
[59:28.840 --> 59:30.840]  который может не иметь реализации.
[59:34.840 --> 59:36.840]  То есть если вы хотите сказать, что у этого метода
[59:36.840 --> 59:38.840]  может не быть реализации, то вы делаете
[59:38.840 --> 59:40.840]  равно нулю.
[59:40.840 --> 59:42.840]  Вот.
[59:42.840 --> 59:44.840]  Что это влечет за собой?
[59:44.840 --> 59:46.840]  Да, ну, собственно, как я сказал,
[59:46.840 --> 59:48.840]  что чисто виртуальные функции
[59:48.840 --> 59:50.840]  можно оставлять без реализации, то есть нет никакой ошибки.
[59:50.840 --> 59:52.840]  То есть если вы
[59:52.840 --> 59:54.840]  если вы оставили какой-то метод без реализации,
[59:54.840 --> 59:56.840]  то естественно это ошибка,
[59:56.840 --> 59:58.840]  ну ошибка линковки.
[59:58.840 --> 01:00:00.840]  То есть компилятор ожидал, что у вас есть функция,
[01:00:00.840 --> 01:00:02.840]  у нее есть реализация, а вы ее не написали,
[01:00:02.840 --> 01:00:04.840]  в общем в этом случае это ошибка.
[01:00:04.840 --> 01:00:06.840]  В случае чисто виртуальных функций такой ошибки не
[01:00:06.840 --> 01:00:08.840]  возникает. То есть компилятор понимает,
[01:00:08.840 --> 01:00:10.840]  что вот вы нарочно оставили всё без реализации.
[01:00:10.840 --> 01:00:12.840]  Единственное исключение — это
[01:00:12.840 --> 01:00:14.840]  чисто виртуальные деструкторы.
[01:00:14.840 --> 01:00:16.840]  Вот чисто виртуальные деструкторы,
[01:00:16.840 --> 01:00:18.840]  во-первых, их делать не стоит, а во-вторых,
[01:00:18.840 --> 01:00:20.840]  у любого деструктора обязательно должна быть реализация.
[01:00:20.840 --> 01:00:25.840]  Деструктор всегда вызывается так или иначе.
[01:00:25.840 --> 01:00:30.840]  Второй момент. Чисто виртуальные функции могут быть реализованы только вне класса.
[01:00:30.840 --> 01:00:40.840]  То есть нельзя написать виртуал void f равно 0 и дальше написать реализацию.
[01:00:40.840 --> 01:00:45.840]  Вот так делать нельзя. То есть после равно 0 можно написать только точку запятой.
[01:00:45.840 --> 01:00:50.840]  Если вы хотите этот метод реализовать, то это нужно сделать обязательно вне класса.
[01:00:50.840 --> 01:00:53.840]  Просто такое правило.
[01:01:03.840 --> 01:01:06.840]  Сейчас будет про это.
[01:01:06.840 --> 01:01:11.840]  Я сказал, что чисто виртуальные методы позволяют вам не писать реализацию для конкретного метода.
[01:01:11.840 --> 01:01:15.840]  Это может показаться странным.
[01:01:15.840 --> 01:01:19.840]  Неужели это нужно только для того, чтобы не писать реализацию?
[01:01:19.840 --> 01:01:22.840]  Нет. Это еще позволяет создавать так называемые абстрактные классы.
[01:01:22.840 --> 01:01:28.840]  Абстрактный класс — это класс у которого есть хотя бы один чисто виртуальный метод.
[01:01:28.840 --> 01:01:34.840]  Если в вашем классе есть хотя бы один чисто виртуальный метод, этот класс называется абстрактным.
[01:01:34.840 --> 01:01:39.840]  Почему этот класс называется абстрактным?
[01:01:39.840 --> 01:01:43.280]  А потому что объекты таких типов создавать нельзя.
[01:01:43.280 --> 01:01:50.520]  Понятное дело, что если у вас есть абстрактный класс, то это означает, что в нем есть
[01:01:50.520 --> 01:01:54.560]  чисто виртуальные методы, то есть меты, у которых нет реализации. Если у вас есть методы, у pipeline нет реализации,
[01:01:54.560 --> 01:02:01.000]  то это значит, что вызывать эти методы, естественно, нельзя.
[01:02:01.000 --> 01:02:07.740]  Ну и объекты таких типов тоже создавать нельзя. Логика такая. Короче, абстрактный класс
[01:02:07.740 --> 01:02:09.420]  одним чисто виртуальным методом, и главное их
[01:02:09.420 --> 01:02:11.040]  свойство состоит в том, что объекты таких
[01:02:11.040 --> 01:02:12.800]  классов создавать нельзя. То есть нельзя
[01:02:12.800 --> 01:02:19.720]  создать iMessage, iMessage MSG. Вот тут будет
[01:02:19.720 --> 01:02:23.340]  ошибка компиляции. Ну да, вот здесь это показано.
[01:02:23.340 --> 01:02:25.860]  Но при этом, при этом можно создавать
[01:02:25.860 --> 01:02:28.340]  указатели на такие, на такие типы и
[01:02:28.340 --> 01:02:35.340]  ссылки на такие типы, окей? То есть абстрактные
[01:02:35.340 --> 01:02:36.700]  классы могут быть использованы только
[01:02:36.700 --> 01:02:38.260]  для того, чтобы создавать на них указатели
[01:02:38.260 --> 01:02:41.820]  или создавать на них ссылки. Все, сами объекты
[01:02:41.820 --> 01:02:43.340]  создавать нельзя. То есть в некотором
[01:02:43.340 --> 01:02:45.500]  смысле, вот про это по-моему было
[01:02:45.500 --> 01:02:46.840]  где-то написано, в общем, в некотором
[01:02:46.840 --> 01:02:48.700]  смысле абстрактные классы представляют
[01:02:48.700 --> 01:02:52.820]  из себя интерфейсы. Ну грубо говоря, что
[01:02:52.820 --> 01:02:59.260]  такое интерфейс? Вот по код-стайлу мы в
[01:02:59.260 --> 01:03:00.700]  начале абстрактных классов пишем всегда
[01:03:00.700 --> 01:03:03.940]  заглавную букву i. Это по код-стайлу. Ну от
[01:03:03.940 --> 01:03:07.380]  слова интерфейс. Чтобы не путать абстрактные
[01:03:07.380 --> 01:03:09.620]  классы и не абстрактные классы. В общем,
[01:03:09.620 --> 01:03:11.220]  интерфейс это следующее. То есть вы
[01:03:11.220 --> 01:03:13.940]  внутри этого класса можете написать, какие
[01:03:13.940 --> 01:03:18.260]  методы там есть у метода, какие методы есть у
[01:03:18.260 --> 01:03:20.340]  класса message. То есть, точнее, что можно делать
[01:03:20.340 --> 01:03:22.420]  сообщением. Например, сообщением можно делать
[01:03:22.420 --> 01:03:26.620]  send, сообщением можно делать display. Ну и
[01:03:26.620 --> 01:03:29.140]  допустим, display я сделал равно нулю. И он
[01:03:29.140 --> 01:03:34.980]  виртуальный, естественно. Что это
[01:03:34.980 --> 01:03:36.660]  означает? Это означает, что у любого
[01:03:36.660 --> 01:03:38.420]  объекта, который я унаследую, который я
[01:03:38.420 --> 01:03:41.380]  унаследую от message, у меня обязательно в
[01:03:41.380 --> 01:03:44.300]  нем должны появиться методы send и метод
[01:03:44.300 --> 01:03:47.340]  display. Да? И, соответственно, я через
[01:03:47.340 --> 01:03:49.340]  вот эти вот ptr могу вызывать методы
[01:03:49.340 --> 01:03:54.220]  display. Могу через этот ptr вызывать метод
[01:03:54.220 --> 01:04:06.420]  send. Ну и так далее. Что? Ну потому что, наверное,
[01:04:06.420 --> 01:04:07.620]  вы хотите, чтобы ваше сообщение можно было
[01:04:07.620 --> 01:04:13.260]  как-то отправлять. То есть вы внутри
[01:04:13.260 --> 01:04:14.980]  абстрактного класса пишете все действия,
[01:04:14.980 --> 01:04:18.740]  которые можно совершать над
[01:04:18.740 --> 01:04:20.620]  объектами, которые объединены, грубо говоря,
[01:04:20.620 --> 01:04:23.540]  понятием сообщения. Любое сообщение
[01:04:23.700 --> 01:04:25.020]  можно отправить, любое сообщение можно
[01:04:25.020 --> 01:04:26.980]  показать на экране, любое сообщение, не знаю,
[01:04:26.980 --> 01:04:29.500]  можно удалить. Ну и теперь вы можете
[01:04:29.500 --> 01:04:30.740]  создавать указатель или ссылки на
[01:04:30.740 --> 01:04:34.180]  сообщение и присваивать им конкретные
[01:04:34.180 --> 01:04:37.100]  типы сообщения. Там текстовая, картинка,
[01:04:37.100 --> 01:04:38.660]  стикер и так далее. И со всеми этими
[01:04:38.660 --> 01:04:40.580]  сообщения теперь можно делать display, send
[01:04:40.580 --> 01:04:42.260]  и тому подобное. Почему? Потому что эти
[01:04:42.260 --> 01:04:44.100]  методы объявлены в абстрактном базовом
[01:04:44.100 --> 01:04:47.100]  классе iMessage.
[01:04:54.180 --> 01:04:57.180]  Да, ну то есть...
[01:04:57.180 --> 01:05:01.340]  Нет, абстрактный класс это класс хотя бы
[01:05:01.340 --> 01:05:03.220]  одним чисто виртуальным методом. А в абстрактном
[01:05:03.220 --> 01:05:04.700]  классе может быть, например, один чисто
[01:05:04.700 --> 01:05:06.300]  виртуальный метод, а все остальные методы
[01:05:06.300 --> 01:05:09.420]  могут быть невиртуальными. Это нормально.
[01:05:09.420 --> 01:05:13.420]  Ну давайте конкретный пример.
[01:05:13.420 --> 01:05:14.820]  Почему, например, send может быть
[01:05:14.820 --> 01:05:16.220]  невиртуальным, а display виртуальным?
[01:05:16.220 --> 01:05:18.300]  Ну потому что send, допустим, логика
[01:05:18.300 --> 01:05:20.020]  программы устроена так, что отправка
[01:05:20.020 --> 01:05:21.740]  сообщения это просто, например, запись,
[01:05:22.500 --> 01:05:24.260]  запись в логе, что вот там Вася отправил
[01:05:24.260 --> 01:05:27.060]  сообщение Петь и все. То есть, естественно,
[01:05:27.060 --> 01:05:28.940]  как бы нет смысла этот send
[01:05:28.940 --> 01:05:30.380]  переопределять там для текста отдельно,
[01:05:30.380 --> 01:05:31.940]  для стикера и так далее. То есть, сообщение
[01:05:31.940 --> 01:05:33.500]  это просто одна строка там в логе и все.
[01:05:33.500 --> 01:05:37.620]  А вот display уже работает по-разному, то есть
[01:05:37.620 --> 01:05:39.100]  для текста, для картинки, для видео
[01:05:39.100 --> 01:05:41.780]  display работает по-разному. И поэтому я
[01:05:41.780 --> 01:05:43.740]  объявляю его чисто виртуальным.
[01:05:43.740 --> 01:05:45.940]  Почему объявляю виртуальным? Для того,
[01:05:45.940 --> 01:05:47.500]  чтобы наследники могли его
[01:05:47.500 --> 01:05:50.300]  переопределить. А чисто виртуальным?
[01:05:50.300 --> 01:05:52.220]  Ну потому что я хочу сделать абстрактный
[01:05:52.220 --> 01:05:53.700]  класс, объект, которого нельзя создать и
[01:05:53.700 --> 01:05:55.140]  плюс я не знаю, как мне написать
[01:05:55.140 --> 01:05:57.900]  реализацию для display в общем случае.
[01:05:57.900 --> 01:06:02.460]  Что? Затемнение можно, да, написать реализацию.
[01:06:02.460 --> 01:06:06.620]  Хороший вопрос. Например, за этим.
[01:06:06.620 --> 01:06:11.580]  Void. Давайте так напишем. Для чего
[01:06:11.580 --> 01:06:13.020]  писать реализацию чисто виртуальным
[01:06:13.020 --> 01:06:16.900]  методом? Ну, например, вот зачем.
[01:06:17.820 --> 01:06:21.780]  Display. Вот я пишу здесь реализацию.
[01:06:21.780 --> 01:06:24.980]  Ну и, допустим, представь себе, что у вас
[01:06:24.980 --> 01:06:26.660]  есть какие-то общие действия, которые
[01:06:26.660 --> 01:06:28.900]  необходимо сделать. Ну, например,
[01:06:28.900 --> 01:06:32.540]  опять же, не залогировать, а ну.
[01:06:33.740 --> 01:06:35.700]  Ну какие есть общие действия?
[01:06:35.700 --> 01:06:37.780]  Отобразить, может, дату и время отправки.
[01:06:37.780 --> 01:06:45.020]  OK? Например, display.date.time.
[01:06:45.700 --> 01:06:47.460]  Все. Вот любое сообщение должно там
[01:06:47.460 --> 01:06:50.300]  отобразить дату и время. То есть здесь
[01:06:50.300 --> 01:06:51.780]  вы пишете некоторую общую логику. И
[01:06:51.780 --> 01:06:55.700]  теперь в наследниках, вот. Ну и, например,
[01:06:55.700 --> 01:07:01.540]  в наследнике, в текст message вы пишете
[01:07:01.540 --> 01:07:06.780]  метод display и теперь вы можете написать так.
[01:07:06.780 --> 01:07:08.460]  Вы можете сказать, что сначала мы делаем
[01:07:08.460 --> 01:07:12.740]  общие действия, например, iMessage,
[01:07:12.740 --> 01:07:17.980]  двоеточие, двоеточие, display. Ну, display.
[01:07:17.980 --> 01:07:19.500]  А дальше пишете специфичные действия.
[01:07:19.500 --> 01:07:22.100]  Вот. То есть сначала вы вызываете метод из
[01:07:22.100 --> 01:07:23.780]  базового класса, а потом уже делаете те
[01:07:23.780 --> 01:07:27.340]  действия, которые вам нужны. Вот, например, вот так.
[01:07:27.340 --> 01:07:29.860]  Понятно?
[01:07:34.460 --> 01:07:37.500]  Хорошо. Да, значит, абстрактный класс,
[01:07:37.500 --> 01:07:38.780]  нельзя создавать объект абстрактного
[01:07:38.780 --> 01:07:40.260]  класса, но при этом можно создавать ссылки
[01:07:40.260 --> 01:07:42.380]  указателя на абстрактный класс. Вот.
[01:07:42.380 --> 01:07:44.700]  Значит, еще одно свойство абстрактных
[01:07:44.700 --> 01:07:48.580]  классов. Если вдруг наследник решит
[01:07:48.580 --> 01:07:50.500]  подерзить и не будет переопределять
[01:07:50.500 --> 01:07:52.460]  чисто виртуальный метод, то, в общем, в
[01:07:52.460 --> 01:07:53.900]  наказание он сам автоматически становится
[01:07:53.900 --> 01:07:56.900]  абстрактным. Ну, то есть, если у меня есть
[01:07:56.900 --> 01:08:00.980]  iMessage и stickerMessage, который решил
[01:08:00.980 --> 01:08:02.700]  не переопределять метод display, то с
[01:08:02.700 --> 01:08:04.180]  этого момента stickerMessage тоже считается
[01:08:04.180 --> 01:08:06.460]  абстрактным. То есть объекты такого типа
[01:08:06.460 --> 01:08:09.360]  создавать нельзя, окей?
[01:08:09.360 --> 01:08:11.900]  То есть наследуется как виртуальность, так и
[01:08:11.900 --> 01:08:13.920]  чистая виртуальность, вот так.
[01:08:13.920 --> 01:08:15.700]  Чтобы перестать быть чисто виртуально,
[01:08:15.700 --> 01:08:17.260]  точнее чтобы перестать быть абстрактным,
[01:08:17.260 --> 01:08:19.220]  нужно взять и переопределить
[01:08:19.220 --> 01:08:21.500]  соответствующий чисто виртуальный метод.
[01:08:21.500 --> 01:08:23.540]  И вот, собственно, в этом и заключается
[01:08:23.540 --> 01:08:25.900]  решение проблемы с тем, чтобы заставить
[01:08:25.900 --> 01:08:27.860]  обьекты производных классов
[01:08:27.860 --> 01:08:31.880]  переопределять методы. Потому что, если
[01:08:31.880 --> 01:08:33.640]  объекты производных классов это не
[01:08:33.640 --> 01:08:34.720]  сделают, то они сами становятся абстрактными.
[01:08:34.720 --> 01:08:41.720]  А им это нафиг надо, им это не надо. Понятно? Такие дела.
[01:08:41.720 --> 01:08:47.720]  Да, вызов чисто виртуальных методов в конструкторах или деструкторах приводит к undefinedBehaviour,
[01:08:47.720 --> 01:08:54.720]  но это к вопросу о том, что в конструкторах и деструкторах в принципе не стоит вызывать виртуальные методы,
[01:08:54.720 --> 01:08:58.720]  а чисто виртуальные методы тем более. Это undefinedBehaviour.
[01:08:58.720 --> 01:09:04.720]  Ну и про то, что мы говорили, абстрактные классы используются для определения интерфейсов,
[01:09:04.720 --> 01:09:06.720]  для создания семейства классов с одинаковыми свойствами методами.
[01:09:06.720 --> 01:09:08.720]  Но это, кажется, обсудили.
[01:09:08.720 --> 01:09:11.720]  То есть, если вам нужно общий интерфейс вынести в какой-то отдельный класс,
[01:09:11.720 --> 01:09:16.720]  то вы создаете абстрактный класс. И дальше все наследники обязаны будут это все реализовать.
[01:09:21.720 --> 01:09:23.720]  Есть вопросы?
[01:09:23.720 --> 01:09:27.720]  Хорошо.
[01:09:27.720 --> 01:09:31.720]  Ну и сколько у нас? 10 минут осталось, отлично.
[01:09:31.720 --> 01:09:38.720]  В общем, есть вопросы по лекции про наследование?
[01:09:38.720 --> 01:09:42.720]  Про виртуальные методы, про...
[01:09:42.720 --> 01:09:46.720]  Ну и теперь давайте 10 минут посетим тому, чтобы понять,
[01:09:46.720 --> 01:09:49.720]  а как вообще работает механизм позднего связывания?
[01:09:49.720 --> 01:09:51.720]  На этапе компиляции все понятно.
[01:09:51.720 --> 01:09:55.720]  Компилятор просто подставляет нужные ассемблерные инструкции,
[01:09:55.720 --> 01:09:58.720]  вызовы отдельно под инструкции и так далее, и все нормально.
[01:09:58.720 --> 01:10:00.720]  А вот как работает механизм позднего связывания?
[01:10:00.720 --> 01:10:04.720]  То есть как вообще, во время исполнения, понять, какую функцию нужно вызывать?
[01:10:04.720 --> 01:10:06.720]  Вот это интересный вопрос.
[01:10:06.720 --> 01:10:09.720]  Значит, работает это так.
[01:10:09.720 --> 01:10:14.720]  Смотрите, как только... Представьте, что у вас есть класс.
[01:10:14.720 --> 01:10:18.720]  Давайте структуру напишу, чтобы паблик не писать.
[01:10:19.720 --> 01:10:22.720]  И у вас есть в нем виртуальная функция A.
[01:10:25.720 --> 01:10:30.720]  Значит, как только у вас в классе появилась виртуальная функция,
[01:10:30.720 --> 01:10:35.720]  для этого класса создается так называемая таблица виртуальных функций.
[01:10:38.720 --> 01:10:43.720]  Таблица виртуальных функций.
[01:10:44.720 --> 01:10:46.720]  Ну, что это такое?
[01:10:46.720 --> 01:10:50.720]  Она, понятное дело, может быть устроена по-разному в зависимости от реализации,
[01:10:50.720 --> 01:10:52.720]  но в общем случае там можно считать так.
[01:10:52.720 --> 01:10:56.720]  Значит, таблица виртуальных функций это просто тип функции...
[01:11:01.720 --> 01:11:10.720]  Это тип функции, который отображается в некоторый адрес вашей программе.
[01:11:10.720 --> 01:11:12.720]  Где эта функция на самом деле расположена?
[01:11:12.720 --> 01:11:17.720]  Ну, давайте я тут вместо адреса буду писать просто полное имя функции.
[01:11:17.720 --> 01:11:19.720]  там a...f.
[01:11:23.720 --> 01:11:28.720]  То есть для каждой виртуальной функции заводится некоторая запись в таблице виртуальных функций для класса A.
[01:11:32.720 --> 01:11:37.720]  И давайте тут заведу еще виртуальную функцию g, для примера.
[01:11:40.720 --> 01:11:44.720]  Виртуал int g.
[01:11:44.720 --> 01:11:48.720]  Ну и здесь будет тогда int g.
[01:11:48.720 --> 01:11:54.720]  И указатель будет вести, собственно, вот на начало инструкции для A.
[01:11:54.720 --> 01:11:57.720]  Теперь я завожу структуру B.
[01:11:59.720 --> 01:12:01.720]  Ну и давайте что я сделаю?
[01:12:01.720 --> 01:12:05.720]  Я возьму и переопределю виртуальную функцию f.
[01:12:06.720 --> 01:12:10.720]  А, да, спасибо.
[01:12:10.720 --> 01:12:14.720]  B унаследуем от A.
[01:12:14.720 --> 01:12:16.720]  Что происходит?
[01:12:16.720 --> 01:12:18.720]  В B тоже есть виртуальные функции.
[01:12:18.720 --> 01:12:22.720]  Так как B унаследуется от A, а в A есть виртуальные функции, то B уже не отвертится.
[01:12:22.720 --> 01:12:24.720]  В B в любом случае есть виртуальные функции.
[01:12:24.720 --> 01:12:28.720]  Поэтому для B тоже заводится таблица виртуальных функций.
[01:12:28.720 --> 01:12:32.720]  В этой таблице тоже есть две записи.
[01:12:32.720 --> 01:12:35.720]  Давайте еще одну функцию добавим.
[01:12:35.720 --> 01:12:37.720]  Пусть будет три записи.
[01:12:37.720 --> 01:12:45.720]  Virtual void h.
[01:12:47.720 --> 01:12:50.720]  В таблице виртуальных функций для B есть три записи.
[01:12:50.720 --> 01:12:52.720]  Какие?
[01:12:52.720 --> 01:12:54.720]  Понятное дело, что это функция f.
[01:12:54.720 --> 01:12:58.720]  Потому что раз это функция виртуальная в A, то эта функция виртуальная и в B.
[01:12:58.720 --> 01:13:02.720]  Куда указывает указатель в этой таблице?
[01:13:02.720 --> 01:13:04.720]  На B.
[01:13:04.720 --> 01:13:06.720]  Почему?
[01:13:06.720 --> 01:13:08.720]  Потому что B реализует функцию f по-своему.
[01:13:08.720 --> 01:13:10.720]  И указатель, который находится здесь...
[01:13:10.720 --> 01:13:16.720]  Указатель это некоторое 32-битное или 64-битное число.
[01:13:16.720 --> 01:13:18.720]  Здесь пишу так.
[01:13:18.720 --> 01:13:20.720]  Это просто указатель, который указывает вот сюда.
[01:13:20.720 --> 01:13:22.720]  И этот указатель указывает вот сюда.
[01:13:22.720 --> 01:13:24.720]  Какие есть еще методы?
[01:13:24.720 --> 01:13:26.720]  Есть метод g.
[01:13:26.720 --> 01:13:30.720]  Так как это тоже виртуальный метод, он унаследован от A.
[01:13:30.720 --> 01:13:32.720]  Согласны?
[01:13:32.720 --> 01:13:36.720]  Куда указывает указатель в этой таблице?
[01:13:36.720 --> 01:13:38.720]  На A.
[01:13:38.720 --> 01:13:40.720]  Потому что B не переопределяет функцию g.
[01:13:40.720 --> 01:13:42.720]  То есть альтернативной реализации для g нет.
[01:13:42.720 --> 01:13:44.720]  То есть единственная реализация, которая есть для g, это A.
[01:13:44.720 --> 01:13:46.720]  Поэтому этот указатель указывает на A.
[01:13:46.720 --> 01:13:48.720]  Хорошо?
[01:13:48.720 --> 01:13:52.720]  Ну и также B заводит свою функцию h.
[01:13:52.720 --> 01:13:54.720]  H будет h,
[01:13:54.720 --> 01:13:56.720]  которая ведет, естественно, в B.
[01:13:56.720 --> 01:13:58.720]  Вот.
[01:13:58.720 --> 01:14:00.720]  Ну и так далее. Понятно, да?
[01:14:00.720 --> 01:14:02.720]  То есть если вы там что-то наследуете от C,
[01:14:02.720 --> 01:14:04.720]  то есть заводите класс C, который наследован от B,
[01:14:04.720 --> 01:14:06.720]  заводите класс D, который наследован от A,
[01:14:06.720 --> 01:14:08.720]  то для каждого такого класса
[01:14:08.720 --> 01:14:10.720]  у вас заводится своя таблица виртуальных функций.
[01:14:10.720 --> 01:14:12.720]  Все понятно.
[01:14:12.720 --> 01:14:14.720]  Теперь.
[01:14:14.720 --> 01:14:16.720]  Что происходит далее?
[01:14:16.720 --> 01:14:18.720]  Значит, допустим,
[01:14:18.720 --> 01:14:20.720]  мы пишем вот так.
[01:14:20.720 --> 01:14:22.720]  Х равно nuB.
[01:14:22.720 --> 01:14:24.720]  Дальше делаем ptr,
[01:14:24.720 --> 01:14:26.720]  стрелочка на vtf.
[01:14:28.720 --> 01:14:30.720]  Как компилятор понимает...
[01:14:30.720 --> 01:14:32.720]  Тут есть главный вопрос,
[01:14:32.720 --> 01:14:34.720]  вообще говоря.
[01:14:34.720 --> 01:14:36.720]  Как компилятор понимает,
[01:14:36.720 --> 01:14:38.720]  на какой тип указывает ptr?
[01:14:40.720 --> 01:14:42.720]  Вообще говоря, это не тривиальная задача.
[01:14:42.720 --> 01:14:44.720]  Потому что напомню, что здесь может стоять
[01:14:44.720 --> 01:14:46.720]  что-то наподобие такого.
[01:14:46.720 --> 01:14:48.720]  Х равно равно 0.
[01:14:48.720 --> 01:14:50.720]  Х равно nuB,
[01:14:50.720 --> 01:14:52.720]  иначе nuA.
[01:14:52.720 --> 01:14:54.720]  То есть вообще говоря, компилятор
[01:14:54.720 --> 01:14:56.720]  на этапе компиляции, он не понимает,
[01:14:56.720 --> 01:14:58.720]  какой там на самом деле объект лежит.
[01:14:58.720 --> 01:15:00.720]  Поэтому ему нужно как-то понять,
[01:15:00.720 --> 01:15:02.720]  что там за объект.
[01:15:02.720 --> 01:15:04.720]  Вот как компилятор понимает,
[01:15:04.720 --> 01:15:06.720]  на какой объект на самом деле указывает ptr?
[01:15:06.720 --> 01:15:08.720]  Вопрос такой,
[01:15:08.720 --> 01:15:10.720]  но на понимание.
[01:15:10.720 --> 01:15:12.720]  Точнее, я предлагаю вам решение,
[01:15:12.720 --> 01:15:14.720]  а вы его покритикуйте.
[01:15:14.720 --> 01:15:16.720]  Я говорю следующую вещь.
[01:15:16.720 --> 01:15:18.720]  Если указатель ptr указывает
[01:15:18.720 --> 01:15:20.720]  на объект типа B,
[01:15:20.720 --> 01:15:22.720]  то это означает следующее.
[01:15:22.720 --> 01:15:24.720]  Это означает, что у меня сначала лежит
[01:15:24.720 --> 01:15:26.720]  объект типа A, а потом какая-то часть,
[01:15:26.720 --> 01:15:28.720]  которая относится к B.
[01:15:28.720 --> 01:15:30.720]  В памяти так устроено.
[01:15:30.720 --> 01:15:32.720]  И компилятор просто проверяет,
[01:15:32.720 --> 01:15:34.720]  вот эти биты относятся к A,
[01:15:34.720 --> 01:15:36.720]  а вот эти биты относятся к B.
[01:15:36.720 --> 01:15:38.720]  И если это действительно так,
[01:15:38.720 --> 01:15:40.720]  то у меня объект типа B.
[01:15:40.720 --> 01:15:42.720]  Если это не так, то объект типа A.
[01:15:42.720 --> 01:15:44.720]  В чем проблема?
[01:15:46.720 --> 01:15:48.720]  Что?
[01:15:48.720 --> 01:15:50.720]  Ну нет, такого быть не может.
[01:15:50.720 --> 01:15:52.720]  Если я вызываю метод f,
[01:15:52.720 --> 01:15:54.720]  то это значит, что у меня
[01:15:54.720 --> 01:15:56.720]  конструкторы все сработали.
[01:16:04.720 --> 01:16:06.720]  Ну да, смотрите,
[01:16:06.720 --> 01:16:08.720]  что происходит в памяти?
[01:16:08.720 --> 01:16:10.720]  Что такое память, как она устроена?
[01:16:10.720 --> 01:16:12.720]  Что в ней хранится?
[01:16:12.720 --> 01:16:14.720]  Да, ну,
[01:16:14.720 --> 01:16:16.720]  ну, нолики единички.
[01:16:16.720 --> 01:16:18.720]  Единственное, что хранится в памяти,
[01:16:18.720 --> 01:16:20.720]  это нолики единички.
[01:16:20.720 --> 01:16:22.720]  Как по ноликам единичкам здесь
[01:16:22.720 --> 01:16:24.720]  понять, точнее, вот тут, например,
[01:16:24.720 --> 01:16:26.720]  есть какое-то polyintx.
[01:16:26.720 --> 01:16:28.720]  Polyintx кодируется тоже каким-то
[01:16:28.720 --> 01:16:30.720]  ноликами единичками.
[01:16:30.720 --> 01:16:32.720]  Как чисто по ноликам единичкам
[01:16:32.720 --> 01:16:34.720]  компилятору понять,
[01:16:34.720 --> 01:16:36.720]  что там лежит
[01:16:36.720 --> 01:16:38.720]  объект типа B, а не просто
[01:16:38.720 --> 01:16:40.720]  какой-то рандомный мусор?
[01:16:40.720 --> 01:16:42.720]  Ну согласитесь, что если у вас есть
[01:16:42.720 --> 01:16:44.720]  объект типа A,
[01:16:44.720 --> 01:16:46.720]  а правее него ничего нет,
[01:16:46.720 --> 01:16:48.720]  то есть тут лежит какой-то мусор.
[01:16:48.720 --> 01:16:50.720]  Но согласитесь, что этот мусор,
[01:16:50.720 --> 01:16:52.720]  он может быть так устроен, что он очень сильно похож
[01:16:52.720 --> 01:16:54.720]  на объект типа B.
[01:16:54.720 --> 01:16:56.720]  Ну и проблема.
[01:16:56.720 --> 01:16:58.720]  Поэтому такой план проваливается
[01:16:58.720 --> 01:17:00.720]  естественным образом.
[01:17:00.720 --> 01:17:02.720]  То есть даже если бы тут хранилась какая-то информация,
[01:17:02.720 --> 01:17:04.720]  вот представьте себе, что компилятор
[01:17:04.720 --> 01:17:06.720]  бы здесь хранил какую-то информацию о том,
[01:17:06.720 --> 01:17:08.720]  что начинается B.
[01:17:08.720 --> 01:17:10.720]  Не знаю, в каком-то виде он бы
[01:17:10.720 --> 01:17:12.720]  закодировал.
[01:17:12.720 --> 01:17:14.720]  Но тогда бы это тоже не работало, почему?
[01:17:14.720 --> 01:17:16.720]  Потому что если на самом деле у вас тут лежал объект типа A,
[01:17:16.720 --> 01:17:18.720]  то за объектом типа A у вас бы лежал какой-то мусор.
[01:17:18.720 --> 01:17:20.720]  А вот эти самые мусорные биты,
[01:17:20.720 --> 01:17:22.720]  они могли бы выстроиться в такую цепочку,
[01:17:22.720 --> 01:17:24.720]  которая бы давала вам B.
[01:17:24.720 --> 01:17:26.720]  Что?
[01:17:26.720 --> 01:17:28.720]  Ну это маловероятно, но такое возможно.
[01:17:28.720 --> 01:17:30.720]  Чтобы уменьшить вероятность,
[01:17:30.720 --> 01:17:32.720]  нужно было все больше и больше бибитов откусывать.
[01:17:32.720 --> 01:17:34.720]  В общем, беда.
[01:17:34.720 --> 01:17:36.720]  В общем, так делать нельзя.
[01:17:36.720 --> 01:17:38.720]  А как делается?
[01:17:38.720 --> 01:17:40.720]  Делается за счет некоторого понижения
[01:17:40.720 --> 01:17:42.720]  производительности.
[01:17:42.720 --> 01:17:44.720]  Делается так.
[01:17:44.720 --> 01:17:46.720]  Вот если вы посмотрите на
[01:17:46.720 --> 01:17:48.720]  сайзов полиморфных классов,
[01:17:48.720 --> 01:17:50.720]  то есть у классов, которые есть виртуальные функции,
[01:17:50.720 --> 01:17:52.720]  то увидите, что у всех размер
[01:17:52.720 --> 01:17:54.720]  как минимум больше на 8 байт.
[01:17:54.720 --> 01:17:56.720]  То есть скажем, если у вас
[01:17:56.720 --> 01:17:58.720]  в структуре A хранится
[01:17:58.720 --> 01:18:00.720]  поле типа long,
[01:18:00.720 --> 01:18:02.720]  ну или long-long давайте,
[01:18:02.720 --> 01:18:04.720]  int64t,
[01:18:04.720 --> 01:18:06.720]  то вообще говоря,
[01:18:06.720 --> 01:18:08.720]  окажется, что размер типа A
[01:18:08.720 --> 01:18:10.720]  должен занимать 8 байт.
[01:18:10.720 --> 01:18:12.720]  Вот если вы посмотрите на его реальные сайзов,
[01:18:12.720 --> 01:18:14.720]  то увидите 16 байт.
[01:18:14.720 --> 01:18:16.720]  Почему? Куда уходит еще дополнительные 8 байт?
[01:18:16.720 --> 01:18:18.720]  А уходят они на так называемый указатель
[01:18:18.720 --> 01:18:20.720]  на таблицу виртуальных функций.
[01:18:24.720 --> 01:18:26.720]  Указатель
[01:18:28.720 --> 01:18:30.720]  на таблицу
[01:18:30.720 --> 01:18:32.720]  виртуальных функций.
[01:18:34.720 --> 01:18:36.720]  Ну или WPTR.
[01:18:36.720 --> 01:18:38.720]  Что это такое?
[01:18:38.720 --> 01:18:40.720]  Значит смотрите, у каждого класса
[01:18:40.720 --> 01:18:42.720]  полиморфного
[01:18:42.720 --> 01:18:44.720]  есть своя таблица виртуальных функций.
[01:18:44.720 --> 01:18:46.720]  Мы про это говорили.
[01:18:46.720 --> 01:18:48.720]  Теперь.
[01:18:48.720 --> 01:18:50.720]  Вот есть объект типа A.
[01:18:50.720 --> 01:18:52.720]  Значит на самом деле в памяти
[01:18:52.720 --> 01:18:54.720]  все устроено так. Если у вас класс A
[01:18:54.720 --> 01:18:56.720]  содержит виртуальные методы,
[01:18:56.720 --> 01:18:58.720]  ну или у него есть таблица виртуальных функций,
[01:18:58.720 --> 01:19:00.720]  то это означает, что
[01:19:00.720 --> 01:19:02.720]  все поля
[01:19:02.720 --> 01:19:04.720]  объекта A хранятся здесь.
[01:19:06.720 --> 01:19:08.720]  А перед объектом типа A 8 байт
[01:19:10.720 --> 01:19:12.720]  отводится на так называемый указатель
[01:19:12.720 --> 01:19:14.720]  на таблицу виртуальных функций.
[01:19:14.720 --> 01:19:16.720]  И этот указатель как раз таки указывает на нужную таблицу.
[01:19:18.720 --> 01:19:20.720]  Понятно?
[01:19:20.720 --> 01:19:22.720]  То есть как это работает? Снова.
[01:19:22.720 --> 01:19:24.720]  Я завожу указатель на A.
[01:19:24.720 --> 01:19:26.720]  PTR. И делаю
[01:19:26.720 --> 01:19:28.720]  указатель B.
[01:19:28.720 --> 01:19:30.720]  Что у меня происходит в памяти?
[01:19:30.720 --> 01:19:32.720]  В памяти создается объект типа B.
[01:19:32.720 --> 01:19:34.720]  То есть это часть, которая относится к A,
[01:19:34.720 --> 01:19:36.720]  это часть, которая относится только к B.
[01:19:36.720 --> 01:19:38.720]  И при этом в начале дописывается
[01:19:38.720 --> 01:19:40.720]  специальный 8 байт,
[01:19:40.720 --> 01:19:42.720]  в котором хранится указатель
[01:19:42.720 --> 01:19:44.720]  на таблицу виртуальных функций для B.
[01:19:44.720 --> 01:19:46.720]  И этот указатель указывает вот сюда.
[01:19:46.720 --> 01:19:48.720]  Понятно?
[01:19:48.720 --> 01:19:50.720]  Тип указатель на таблицу виртуальных функций.
[01:19:50.720 --> 01:19:52.720]  Зависит от реализации.
[01:19:56.720 --> 01:19:58.720]  Можно.
[01:19:58.720 --> 01:20:00.720]  Короче, вот то, что я рассказываю,
[01:20:00.720 --> 01:20:02.720]  давайте так, вот то, что я рассказываю,
[01:20:02.720 --> 01:20:04.720]  этого в стандарте не описано.
[01:20:04.720 --> 01:20:06.720]  То есть как бы стандарт
[01:20:06.720 --> 01:20:08.720]  просто пишет, что вот нужно
[01:20:08.720 --> 01:20:10.720]  поддержать возможность динамического полимархизма.
[01:20:10.720 --> 01:20:12.720]  Вот то, что я сейчас рассказываю,
[01:20:12.720 --> 01:20:14.720]  это то, как реализовано
[01:20:14.720 --> 01:20:16.720]  в подавляющем большинстве компиляторов.
[01:20:16.720 --> 01:20:18.720]  И скорее всего у вас.
[01:20:18.720 --> 01:20:20.720]  То есть этот указатель вы можете достать
[01:20:20.720 --> 01:20:22.720]  и посмотреть его.
[01:20:22.720 --> 01:20:24.720]  Но вообще это не гарантируется.
[01:20:24.720 --> 01:20:26.720]  Но скорее всего именно так это и происходит.
[01:20:26.720 --> 01:20:28.720]  И теперь,
[01:20:28.720 --> 01:20:30.720]  смотрите, что происходит,
[01:20:30.720 --> 01:20:32.720]  когда я вызываю PTR стрелочка F.
[01:20:32.720 --> 01:20:34.720]  Что на самом деле происходит?
[01:20:34.720 --> 01:20:36.720]  А на самом деле происходит следующая вещь.
[01:20:36.720 --> 01:20:38.720]  Компилятор смотрит вот сюда.
[01:20:38.720 --> 01:20:40.720]  Во-первых, компилятор понимает,
[01:20:40.720 --> 01:20:42.720]  что A это полиморфный тип.
[01:20:42.720 --> 01:20:44.720]  То есть у него есть виртуальные методы.
[01:20:44.720 --> 01:20:46.720]  Что это означает?
[01:20:46.720 --> 01:20:48.720]  Это означает, что первые 8 بайт
[01:20:48.720 --> 01:20:50.720]  это указатель на таблицу виртуальных функций.
[01:20:50.720 --> 01:20:52.720]  Так, это указатель на таблицу виртуальных функций.
[01:20:52.720 --> 01:20:54.720]  Он просто берет
[01:20:54.720 --> 01:20:56.720]  и идет по этому указателю.
[01:20:56.720 --> 01:20:58.720]  Приходят вот сюда.
[01:20:58.720 --> 01:21:00.720]  Всё, по этому указателю
[01:21:00.720 --> 01:21:02.720]  он приходит в таблицу виртуальных функций.
[01:21:02.720 --> 01:21:04.720]  А уже в таблице виртуальных функций
[01:21:04.720 --> 01:21:06.720]  компилятор ищет нужную ему функцию f
[01:21:06.720 --> 01:21:08.720]  и вот здесь обращается
[01:21:08.720 --> 01:21:10.720]  по нужному адресу к нужной ему функции.
[01:21:10.720 --> 01:21:17.720]  И именно в этом заключается долгое время работы. Почему?
[01:21:17.720 --> 01:21:20.720]  Потому что ему нужно сначала разоминать этот указатель,
[01:21:20.720 --> 01:21:22.720]  пойти в таблицу, разоминать вот этот указатель,
[01:21:22.720 --> 01:21:25.720]  пойти в нужную функцию и только потом начинать ее выполнять.
[01:21:25.720 --> 01:21:29.720]  Понятно, как это устроено?
[01:21:29.720 --> 01:21:32.720]  Еще раз, для каждого класса, в котором есть виртуальный метод,
[01:21:32.720 --> 01:21:34.720]  заводится таблица виртуальных функций.
[01:21:34.720 --> 01:21:36.720]  Когда вы создаете объект такого класса,
[01:21:36.720 --> 01:21:40.720]  у вас размер каждого объекта увеличивается на 8 байт.
[01:21:40.720 --> 01:21:46.720]  Эти 8 байт нужны для того, чтобы хранить указатель на эту самую таблицу.
[01:21:46.720 --> 01:21:50.720]  И теперь компилятор, когда вы будете использовать такой синтаксис,
[01:21:50.720 --> 01:21:52.720]  с помощью ссылки или указателя,
[01:21:52.720 --> 01:21:55.720]  компилятор будет в первую очередь смотреть на этот указатель,
[01:21:55.720 --> 01:21:58.720]  и вот по этому указателю компилятор уже может понять,
[01:21:58.720 --> 01:22:00.720]  какой тип, тип A, тип B или C.
[01:22:00.720 --> 01:22:03.720]  Все, дальше он проходит по этому указателю в нужную таблицу
[01:22:03.720 --> 01:22:07.720]  и за эту таблицу вытаскивает нужную функцию.
[01:22:07.720 --> 01:22:11.720]  Вот так это работает.
[01:22:11.720 --> 01:22:15.720]  Ну все, в общем, с полиморфным наследом закончили.
[01:22:15.720 --> 01:22:19.720]  Виртуальные функции позволяют использовать полиморфное наследование.
[01:22:19.720 --> 01:22:24.720]  Необходимо помнить о необходимости использования виртуального деструктора,
[01:22:24.720 --> 01:22:26.720]  если у вас есть виртуальные методы.
[01:22:26.720 --> 01:22:30.720]  Нужно использовать override, если вы хотите переопределить виртуальные методы.
[01:22:30.720 --> 01:22:34.720]  Ну и есть чисто виртуальные функции, которые делают классы абстрактными.
[01:22:34.720 --> 01:22:38.720]  Основные тезисы лекции.
[01:23:01.720 --> 01:23:11.720]  Сегодня продолжим геометрию и поговорим продробно про выпуклые многоугольники.
[01:23:11.720 --> 01:23:18.720]  Нам будет достаточно определения выпуклого многоугольника,
[01:23:18.720 --> 01:23:26.720]  как многоугольника такого, что при продолжении произвольной стороны
[01:23:26.720 --> 01:23:31.720]  у вас все точки находятся по одну сторону от прямой.
[01:23:31.720 --> 01:23:36.720]  Это одно из определений выпуклости многоугольника.
[01:23:36.720 --> 01:23:40.720]  Ну и, естественно, первый вопрос, который тут может возникнуть,
[01:23:40.720 --> 01:23:43.720]  это, собственно, следующий.
[01:23:43.720 --> 01:23:48.720]  Ну, естественно, мы многоугольник, давайте про это скажем еще раз,
[01:23:48.720 --> 01:24:04.720]  что многоугольник будем представлять в виде упорядоченного набора вершин,
[01:24:04.720 --> 01:24:09.720]  то есть в виде упорядоченного по часовой стрелке или против часовой стрелки,
[01:24:09.720 --> 01:24:11.720]  в общем-то говоря, неважно.
[01:24:11.720 --> 01:24:15.720]  Потому что они как-то упорядочены в некотором массиве вершин.
[01:24:17.720 --> 01:24:21.720]  И, соответственно, первый вопрос, который можно поставить,
[01:24:21.720 --> 01:24:24.720]  это, смотрите, вам дан многоугольник.
[01:24:24.720 --> 01:24:27.720]  То есть многоугольник вам дан в виде некоторого массива вершин.
[01:24:27.720 --> 01:24:31.720]  Собственно, можно поставить вопрос, а является ли этот многоугольник выпуклым или нет?
[01:24:31.720 --> 01:24:35.720]  Что вам подсунули? Выпуклую штуку или нет?
[01:24:42.720 --> 01:24:45.720]  То есть тест на выпуклость.
[01:24:47.720 --> 01:24:49.720]  Что мы можем сделать?
[01:24:49.720 --> 01:24:55.720]  Ну, смотрите. Самый простой алгоритм, который, в принципе, может придумать,
[01:24:55.720 --> 01:24:58.720]  это действует чисто по определению.
[01:24:58.720 --> 01:25:05.720]  Давайте возьмем просто каждую сторону, и для каждой стороны просмотрим все точки и определим,
[01:25:05.720 --> 01:25:08.720]  находятся ли они по одному сторону от прямой или нет.
[01:25:08.720 --> 01:25:10.720]  Наивный алгоритм, кажется, понятен.
[01:25:10.720 --> 01:25:12.720]  Просто-напросто по определению все проверим.
[01:25:12.720 --> 01:25:15.720]  За сколько этот алгоритм работает?
[01:25:15.720 --> 01:25:18.720]  За квадрат, да.
[01:25:18.720 --> 01:25:26.720]  Наивный алгоритм работает за большое от n квадрат.
[01:25:26.720 --> 01:25:29.720]  Ну понятно, нам нужно перебрать каждую сторону,
[01:25:29.720 --> 01:25:34.720]  и для каждой стороны мы проходимся по всем вершинам.
[01:25:34.720 --> 01:25:36.720]  Соответственно, n квадрат.
[01:25:36.720 --> 01:25:39.720]  Давайте попробуем как-то этот алгоритм улучшить.
[01:25:39.720 --> 01:25:41.720]  Улучшать и предлагаю его следующим образом.
[01:25:41.720 --> 01:25:47.720]  Я предлагаю проверять не все вершины, а только одну.
[01:25:47.720 --> 01:25:50.720]  Ну, смотрите, вот я взял какую-то сторону.
[01:25:50.720 --> 01:25:52.720]  Вот эту.
[01:25:52.720 --> 01:25:56.720]  И давайте я просто-напросто проверю угол, который составляет,
[01:25:56.720 --> 01:26:00.720]  ну, вектор, который проходит от вершины, ну давайте, в общем случае,
[01:26:00.720 --> 01:26:12.720]  ПК, ПК плюс один, и ПК плюс один, ПК плюс два.
[01:26:12.720 --> 01:26:18.720]  Вот давайте я проверю угол между двумя последовательными векторами сторон.
[01:26:18.720 --> 01:26:20.720]  Я утверждаю следующую вещь.
[01:26:20.720 --> 01:26:24.720]  Что если у меня, ну, то есть если я прохожусь по всем сторонам,
[01:26:24.720 --> 01:26:26.720]  то есть сначала такой, такой, такой, такой,
[01:26:26.720 --> 01:26:29.720]  что если приобходит нам по часовой стрелке или про часовой стрелке,
[01:26:29.720 --> 01:26:32.720]  то у меня все углы будут либо положительные, либо отрицательные.
[01:26:32.720 --> 01:26:34.720]  Вот если знаки всех углов совпадают,
[01:26:34.720 --> 01:26:38.720]  то в этом случае у меня многоугольник выпуклый.
[01:26:39.720 --> 01:26:47.720]  Вот, значит, предложение такое.
[01:26:56.720 --> 01:26:58.720]  Последовательно
[01:26:58.720 --> 01:27:08.720]  рассмотрим пары ПК, ПК плюс один, и ПК плюс один, ПК плюс два,
[01:27:08.720 --> 01:27:18.720]  ну, пара и вектор, давайте, вектор.
[01:27:29.720 --> 01:27:33.720]  И знаки углов между ними.
[01:27:39.720 --> 01:27:48.720]  И критерий такой, значит, если знаки все больше либо равны нуля,
[01:27:48.720 --> 01:27:52.720]  ну, или меньше либо равны нуля,
[01:27:52.720 --> 01:27:59.720]  то выпуклый.
[01:28:03.720 --> 01:28:07.720]  Иначе нет.
[01:28:15.720 --> 01:28:18.720]  Ну, давайте вспомним, ну, что тут можно вспомнить.
[01:28:19.720 --> 01:28:23.720]  Знаки углов между ними.
[01:28:23.720 --> 01:28:27.720]  Каким образом мы считаем знаки углов между векторами?
[01:28:29.720 --> 01:28:32.720]  Через синус, а если?
[01:28:32.720 --> 01:28:34.720]  Через векторное произведение, да, отлично.
[01:28:34.720 --> 01:28:38.720]  То есть нам тут достаточно, на самом деле, посчитать просто векторное произведение
[01:28:38.720 --> 01:28:47.720]  ПК, ПК плюс один, и ПК плюс один, ПК плюс два.
[01:28:49.720 --> 01:28:52.720]  Вот, читаем векторное произведение, следим за знаками.
[01:28:52.720 --> 01:28:54.720]  Если в какой-нибудь момент встретились два разных знака,
[01:28:54.720 --> 01:28:58.720]  то есть все время было плюс-плюс-плюс, в какой-то момент появился минус,
[01:28:58.720 --> 01:28:59.720]  то останавливаем работу.
[01:28:59.720 --> 01:29:01.720]  И наоборот, если все время было минус-минус-минус,
[01:29:01.720 --> 01:29:05.720]  в какой-то момент встретились плюс, то тоже завершаем работу.
[01:29:08.720 --> 01:29:11.720]  Ну, пока алгоритм понятен, да?
[01:29:11.720 --> 01:29:13.720]  За сколько он работает?
[01:29:13.720 --> 01:29:15.720]  За линию.
[01:29:15.720 --> 01:29:16.720]  За линию.
[01:29:16.720 --> 01:29:18.720]  Мы просто проходимся по всем парам,
[01:29:18.720 --> 01:29:20.720]  ну не по всем, а просто по последним парам.
[01:29:20.720 --> 01:29:24.720]  Сначала вот эту пару, потом вот эту пару, потом вот эту пару и так далее.
[01:29:24.720 --> 01:29:27.720]  Ну, всего последних пар, естественно, у от n.
[01:29:27.720 --> 01:29:29.720]  Короче, их не больше n.
[01:29:29.720 --> 01:29:33.720]  Поэтому алгоритм работает у от n.
[01:29:33.720 --> 01:29:37.720]  Ну и теперь главный вопрос, а почему на самом деле это так?
[01:29:39.720 --> 01:29:41.720]  Почему это работает?
[01:29:42.720 --> 01:29:45.720]  Ну, смотрите.
[01:29:46.720 --> 01:29:47.720]  Доказательство корректности.
[01:29:47.720 --> 01:29:50.720]  Давайте попробуем доказать по индукции.
[01:29:50.720 --> 01:29:55.720]  Ну, начнем с n равного 3.
[01:29:55.720 --> 01:29:58.720]  То есть многоугольники начинаются с n равного 3.
[01:29:58.720 --> 01:29:59.720]  Ну, здесь все понятно.
[01:29:59.720 --> 01:30:01.720]  Любой треугольник выпуклый.
[01:30:01.720 --> 01:30:03.720]  Согласны, да?
[01:30:03.720 --> 01:30:05.720]  Ну, здесь...
[01:30:12.720 --> 01:30:17.720]  Любой треугольник выпуклый, ну и плюс для любого треугольника вот это свойство тоже выполняется.
[01:30:17.720 --> 01:30:19.720]  Поэтому все нормально.
[01:30:19.720 --> 01:30:21.720]  Теперь.
[01:30:23.720 --> 01:30:29.720]  Пусть верно для любого n меньше, чем...
[01:30:29.720 --> 01:30:32.720]  Любого n-штрих меньше, чем n.
[01:30:32.720 --> 01:30:34.720]  Вот.
[01:30:37.720 --> 01:30:41.720]  Рассмотрим n-угольник.
[01:30:50.720 --> 01:30:52.720]  n-угольник, у которого...
[01:30:52.720 --> 01:30:54.720]  Ну, вот эта штука выполнена.
[01:30:59.720 --> 01:31:01.720]  Вот.
[01:31:08.720 --> 01:31:09.720]  Окей?
[01:31:09.720 --> 01:31:13.720]  Ну, вот взяли произвольный многоугольник и сказали, что, ну вот, допустим,
[01:31:13.720 --> 01:31:16.720]  все время каждый угол выполняется на один и тот же поворот.
[01:31:16.720 --> 01:31:20.720]  Давайте покажем, что такой многоугольник будет являться действительно выпуклым.
[01:31:20.720 --> 01:31:22.720]  Ну, что мы сделаем?
[01:31:22.720 --> 01:31:25.720]  Давайте возьмем произвольную точку k.
[01:31:25.720 --> 01:31:27.720]  Возьмем...
[01:31:30.720 --> 01:31:34.720]  Произвольную точку pk.
[01:31:34.720 --> 01:31:37.720]  И удалим ее.
[01:31:49.720 --> 01:31:51.720]  Из n-угольника.
[01:31:51.720 --> 01:31:54.720]  Ну, то есть у меня был какой-то многоугольник.
[01:31:59.720 --> 01:32:00.720]  Вот.
[01:32:00.720 --> 01:32:02.720]  Эта точка pk.
[01:32:02.720 --> 01:32:05.720]  Вот, я от нее избавился временно.
[01:32:09.720 --> 01:32:12.720]  Все время на ее удаляю.
[01:32:14.720 --> 01:32:17.720]  Вот, что я получил?
[01:32:17.720 --> 01:32:19.720]  Я получил на самом деле...
[01:32:19.720 --> 01:32:23.720]  Я утверждаю, что я получил n-1-угольник.
[01:32:24.720 --> 01:32:28.720]  N-1-угольник.
[01:32:33.720 --> 01:32:35.720]  С выполненным звездочкой.
[01:32:35.720 --> 01:32:38.720]  То есть звездочка для такого n-1-угольника, говоришь, не выполняется.
[01:32:38.720 --> 01:32:40.720]  Вопрос, почему?
[01:32:40.720 --> 01:32:42.720]  На самом деле это не очевидно.
[01:32:42.720 --> 01:32:45.720]  То есть если для какого многоугольника это выполняется,
[01:32:45.720 --> 01:32:48.720]  то почему это будет продолжать выполняться для такого многоугольника?
[01:32:48.720 --> 01:32:51.720]  Ну, пояснение такое.
[01:32:53.720 --> 01:32:55.720]  Вот.
[01:32:58.720 --> 01:33:01.720]  Значит, это k-1.
[01:33:01.720 --> 01:33:03.720]  pk.
[01:33:03.720 --> 01:33:05.720]  Тут еще.
[01:33:07.720 --> 01:33:09.720]  k-2.
[01:33:09.720 --> 01:33:11.720]  k-1.
[01:33:11.720 --> 01:33:15.720]  И вот на самом деле хочется понять...
[01:33:15.720 --> 01:33:17.720]  Вот эту точку я удалил.
[01:33:17.720 --> 01:33:21.720]  И хочется понять, действительно ли угол.
[01:33:21.720 --> 01:33:24.720]  Давайте я буду предполагать, что у меня все время происходит...
[01:33:24.720 --> 01:33:29.720]  Точнее, поворот происходит в положительном направлении.
[01:33:31.720 --> 01:33:33.720]  Давайте я буду предлагать, что у меня все время происходит в положительном направлении.
[01:33:33.720 --> 01:33:37.720]  Давайте я докажу, что для pk-1 и pk-1 поворот относительно такой прямой
[01:33:37.720 --> 01:33:40.720]  тоже происходит в положительном направлении.
[01:33:40.720 --> 01:33:44.720]  Допустим, это не так.
[01:33:44.720 --> 01:33:46.720]  Как это может получиться?
[01:33:46.720 --> 01:33:49.720]  Как могло получиться так, что у меня вот этот поворот
[01:33:49.720 --> 01:33:54.720]  Пк плюс один осуществляется в наоборот отрицательном направлении.
[01:33:54.720 --> 01:33:57.720]  Это значит, что у меня картинка выглядит на самом деле не так,
[01:33:57.720 --> 01:34:00.720]  а каким-то таким образом.
[01:34:00.720 --> 01:34:07.720]  Тут Пк, и вот тут где-то Пк плюс один.
[01:34:07.720 --> 01:34:14.720]  Справедливо?
[01:34:14.720 --> 01:34:23.720]  А что это в свою очередь означает?
[01:34:23.720 --> 01:34:27.720]  Да.
[01:34:27.720 --> 01:34:31.720]  В свою очередь означает, что тогда у меня от этой прямой
[01:34:31.720 --> 01:34:36.720]  есть две точки, которые находятся по ее разные стороны.
[01:34:36.720 --> 01:34:44.720]  Для некоторой тройки здесь не выполняется условие звездочка.
[01:34:44.720 --> 01:34:49.720]  Поэтому такого быть не может.
[01:34:49.720 --> 01:34:51.720]  Окей.
[01:34:51.720 --> 01:34:53.720]  Все.
[01:34:53.720 --> 01:34:56.720]  Тогда тут получили Пк минус один и Пк плюс один.
[01:34:56.720 --> 01:35:00.720]  Ну и на самом деле утверждаю, что мы все доказали.
[01:35:00.720 --> 01:35:06.720]  Действительно, рассмотрим вот такой n минус один угольник.
[01:35:06.720 --> 01:35:08.720]  Для него выполняется звездочка.
[01:35:08.720 --> 01:35:11.720]  Также по предположению индукции для него выполняется условие...
[01:35:11.720 --> 01:35:13.720]  Ну, короче, для него все выполняется.
[01:35:13.720 --> 01:35:16.720]  Вот для такого n минус один угольника у меня выполняется звездочка,
[01:35:16.720 --> 01:35:18.720]  а соответственно он является выпуклым.
[01:35:18.720 --> 01:35:20.720]  Согласны?
[01:35:20.720 --> 01:35:24.720]  Ну и давайте рассмотрим здесь все поподробнее.
[01:35:24.720 --> 01:35:27.720]  Теперь как мне доказать, что вот если у меня есть выпуклый многоугольник,
[01:35:27.720 --> 01:35:31.720]  как мне доказать, что если я добавлю вот такую точку Пк,
[01:35:31.720 --> 01:35:41.720]  как мне показать, что у меня действительно многоугольник будет по-прежнему выпуклый?
[01:35:41.720 --> 01:35:43.720]  Ну, на самом деле достаточно просто.
[01:35:43.720 --> 01:35:51.720]  Достаточно просто понять следующую вещь.
[01:35:51.720 --> 01:36:01.720]  Смотрите, что мне известно про расположение точки Пк?
[01:36:01.720 --> 01:36:09.720]  Точка Пк точно находится по левую сторону от вот такого вектора.
[01:36:09.720 --> 01:36:11.720]  То есть точка Пх находится здесь.
[01:36:11.720 --> 01:36:17.720]  Аналогично мне известно, что точка Пк находится по левую сторону от вот такого отрезка.
[01:36:17.720 --> 01:36:19.720]  Ну, по звездочке.
[01:36:19.720 --> 01:36:23.720]  Соответственно Пк находится где-то вот в этой области.
[01:36:23.720 --> 01:36:28.720]  Плюс, мне что еще дополнительно известно, может ли точка Пк находиться где-то здесь?
[01:36:28.720 --> 01:36:31.720]  Нет, не может. Почему? Потому что у меня повороты везде одинакового знака.
[01:36:31.720 --> 01:36:37.720]  Если у меня точка Пк была где-то здесь, то поворот здесь бы осуществлялся в отрицательном направлении.
[01:36:37.720 --> 01:36:39.720]  Что противоречит звездочке?
[01:36:39.720 --> 01:36:41.720]  Соответственно ничего не остается, кроме как Пк быть здесь.
[01:36:41.720 --> 01:36:49.720]  Ну, а мы знаем, что любая точка, которая находится здесь, создает мне выпуклый многоугольник.
[01:36:53.720 --> 01:36:55.720]  Ну, это понятно.
[01:36:55.720 --> 01:36:59.720]  То есть все, мы показали, что без точки Пк у меня многоугольник выпуклый,
[01:36:59.720 --> 01:37:02.720]  а с точкой Пк... ну, а точка Пк мне ничего не портит.
[01:37:02.720 --> 01:37:06.720]  Точка Пк тоже делает выпуклый многоугольник.
[01:37:07.720 --> 01:37:11.720]  Ну, вот, собственно, и все.
[01:37:14.720 --> 01:37:16.720]  Понятно?
[01:37:21.720 --> 01:37:23.720]  Вот такая история.
[01:37:26.720 --> 01:37:30.720]  Окей, мы научились проверять многоугольник на выпуклость.
[01:37:30.720 --> 01:37:32.720]  Теперь давайте перейдем...
[01:37:33.720 --> 01:37:37.720]  Ну, даже не перейдем, давайте вернемся к прошлой лекции.
[01:37:37.720 --> 01:37:39.720]  Мы закончим на прошлой лекции, и на чем?
[01:37:39.720 --> 01:37:42.720]  Помните, что мы обсуждали в последний раз?
[01:37:42.720 --> 01:37:46.720]  Да, принадлежит ли точка внутренности многоугольника или нет?
[01:37:46.720 --> 01:37:48.720]  Вот я утверждаю, что если у меня многоугольник выпуклый...
[01:37:48.720 --> 01:37:51.720]  Да, и какой алгоритм у нас был за какое время?
[01:37:53.720 --> 01:37:56.720]  Или мы не обсудили, за сколько он работает?
[01:37:56.720 --> 01:37:58.720]  Ну, хорошо, если не обсудили, за сколько работал наш алгоритм,
[01:37:58.720 --> 01:38:00.720]  который мы обсудили в прошлый раз.
[01:38:00.720 --> 01:38:02.720]  Ну, интуитивно.
[01:38:02.720 --> 01:38:06.720]  Ну, за линию, да, давайте я напомню, что мы делали.
[01:38:06.720 --> 01:38:10.720]  Мы брали точку и просто проводили либо горизонтальную,
[01:38:10.720 --> 01:38:13.720]  либо под каким-то углом, ну, в общем, проводили какую-то прямую.
[01:38:13.720 --> 01:38:16.720]  Ну, в зависимости от метода, который вам больше понравился.
[01:38:16.720 --> 01:38:18.720]  В общем, так или иначе мы проводим какую-то прямую,
[01:38:18.720 --> 01:38:20.720]  и даже считаем количество пересечений.
[01:38:20.720 --> 01:38:22.720]  Да?
[01:38:22.720 --> 01:38:24.720]  А как мы считаем количество пересечений?
[01:38:24.720 --> 01:38:26.720]  Ну, мы просто проходим все последовательно
[01:38:26.720 --> 01:38:28.720]  по каждому отрезку многоугольника
[01:38:28.720 --> 01:38:30.720]  и смотрим, пересекается он случом или нет.
[01:38:30.720 --> 01:38:32.720]  Проверка, пересекается ли отрезок случом или нет,
[01:38:32.720 --> 01:38:34.720]  мы умеем выполнять за единицу.
[01:38:34.720 --> 01:38:36.720]  Соответственно, общая работа, линия.
[01:38:36.720 --> 01:38:38.720]  То есть за линию мы умеем проверять,
[01:38:38.720 --> 01:38:40.720]  находится ли точка внутри многоугольника или нет.
[01:38:40.720 --> 01:38:42.720]  Вот.
[01:38:42.720 --> 01:38:46.720]  Так вот, я утверждаю, что если у меня многоугольник выпуклый,
[01:38:46.720 --> 01:38:48.720]  то мы можем проверять,
[01:38:48.720 --> 01:38:52.720]  а вот я утверждаю, что если у меня многоугольник выпуклый,
[01:38:52.720 --> 01:38:54.720]  то эту задачу можно решить гораздо быстрее.
[01:38:54.720 --> 01:38:56.720]  Второй пункт.
[01:39:10.720 --> 01:39:12.720]  Принадлежность точки
[01:39:12.720 --> 01:39:28.720]  внутренности выпуклого многоугольника.
[01:39:32.720 --> 01:39:34.720]  Как мы это будем делать?
[01:39:34.720 --> 01:39:36.720]  Ну, смотрите, допустим, неизвестно,
[01:39:36.720 --> 01:39:38.720]  что многоугольник выпуклый.
[01:39:42.720 --> 01:39:46.720]  Мне известно, что многоугольник выпуклый.
[01:39:46.720 --> 01:39:52.720]  Давайте возьму произвольную сторону,
[01:39:52.720 --> 01:39:56.720]  ну, даже вектор, наверное, с стороны p0 и p1.
[01:39:56.720 --> 01:40:00.720]  И задам вам следующий вопрос.
[01:40:00.720 --> 01:40:10.720]  Что можно сказать про вектора p0, p1, p0, p2, p0, p3 и так далее?
[01:40:10.720 --> 01:40:12.720]  p0, pn-1.
[01:40:12.720 --> 01:40:16.720]  Ну, вот про эти вектора.
[01:40:24.720 --> 01:40:28.720]  p0, p1, p0, p2, p0, p3, p0, p4, p0, p5.
[01:40:34.720 --> 01:40:36.720]  Вот, случай выпуклого многоугольника.
[01:40:36.720 --> 01:40:38.720]  Ну, понятно, что мы будем делать.
[01:40:38.720 --> 01:40:40.720]  Ну, понятно, они не пересекаются.
[01:40:40.720 --> 01:40:42.720]  Что еще? Ну, самое главное.
[01:40:44.720 --> 01:40:46.720]  Да, что? Еще раз.
[01:40:46.720 --> 01:40:48.720]  Ну, в одну сторону.
[01:40:48.720 --> 01:40:50.720]  Вот именно в таком порядке,
[01:40:50.720 --> 01:40:52.720]  если их перечисляют, то что происходит?
[01:40:52.720 --> 01:40:56.720]  Заметьте, что они идут по возрастанию угла.
[01:40:56.720 --> 01:40:58.720]  По возрастанию угла относительно p0, p1.
[01:40:58.720 --> 01:41:00.720]  То есть тут угол p0, p1 вставляет 0,
[01:41:00.720 --> 01:41:02.720]  ну, самим собой.
[01:41:02.720 --> 01:41:04.720]  Дальше угол p больше, больше, больше и так далее.
[01:41:08.720 --> 01:41:10.720]  То есть здесь все идет по возрастанию.
[01:41:10.720 --> 01:41:12.720]  Ахи, вы знаете алгоритмы,
[01:41:12.720 --> 01:41:14.720]  которые работают быстрее,
[01:41:14.720 --> 01:41:16.720]  если у вас что-то есть по возрастанию?
[01:41:16.720 --> 01:41:18.720]  Бинпоиск. Отлично.
[01:41:18.720 --> 01:41:20.720]  Отлично.
[01:41:24.720 --> 01:41:26.720]  Ну, давайте, у меня есть какая-то точка
[01:41:26.720 --> 01:41:28.720]  штрих.
[01:41:28.720 --> 01:41:30.720]  Я хочу проверить, лежит ли она внутри
[01:41:30.720 --> 01:41:32.720]  многоугольника или нет.
[01:41:32.720 --> 01:41:34.720]  Ну, давайте придумаем какой-то алгоритм.
[01:41:34.720 --> 01:41:36.720]  Что мы будем делать?
[01:41:38.720 --> 01:41:40.720]  Видимо, каким-то бинпоиском
[01:41:40.720 --> 01:41:42.720]  найдем положение
[01:41:42.720 --> 01:41:44.720]  по 0, по штрих.
[01:41:44.720 --> 01:41:46.720]  Ну, посмотрите, бинпоиск
[01:41:46.720 --> 01:41:48.720]  мне находит какой-то вектор.
[01:41:48.720 --> 01:41:50.720]  То есть либо вот этот вектор, либо вот этот вектор.
[01:41:50.720 --> 01:41:52.720]  Ну, есть ли разница,
[01:41:52.720 --> 01:41:54.720]  какой вектор искать?
[01:42:00.720 --> 01:42:02.720]  Ну, давайте какую-нибудь умную фразу скажем.
[01:42:02.720 --> 01:42:04.720]  Ну, смотрите, бинпоиск
[01:42:04.720 --> 01:42:06.720]  притягивается,
[01:42:06.720 --> 01:42:08.720]  ну, смотрите, бинпоиск
[01:42:08.720 --> 01:42:10.720]  предполагает, что бинпоиск
[01:42:10.720 --> 01:42:12.720]  как бы предполагает
[01:42:12.720 --> 01:42:14.720]  ответ на вопрос, есть ли такой вектор
[01:42:14.720 --> 01:42:16.720]  или нет.
[01:42:16.720 --> 01:42:18.720]  Ну, естественно, скорее всего, вот именно такого вектора
[01:42:18.720 --> 01:42:20.720]  у вас среди этого набора нет.
[01:42:20.720 --> 01:42:22.720]  Поэтому бинпоиск будет вращать всегда false.
[01:42:22.720 --> 01:42:24.720]  А что нам на самом деле нужно?
[01:42:24.720 --> 01:42:26.720]  Нам нужен не бинпоиск, а какой-то алгоритм,
[01:42:26.720 --> 01:42:28.720]  который на нем основан.
[01:42:28.720 --> 01:42:30.720]  Во, супер, upper bound или lower bound?
[01:42:30.720 --> 01:42:32.720]  Давайте найдем lower bound, например.
[01:42:32.720 --> 01:42:34.720]  Все помните такое lower bound?
[01:42:36.720 --> 01:42:38.720]  Первый шаг.
[01:42:38.720 --> 01:42:40.720]  Так, плохо видно, да?
[01:42:48.720 --> 01:42:50.720]  Lower bound.
[01:42:50.720 --> 01:42:52.720]  Ну, давайте сам полигон,
[01:42:52.720 --> 01:42:54.720]  вот это вот все я буду обозначать как
[01:42:54.720 --> 01:42:56.720]  побольшое.
[01:42:56.720 --> 01:42:58.720]  А точку, которую хочу найти,
[01:42:58.720 --> 01:43:00.720]  а вектор, которую хочу найти, по ноль, по штрих.
[01:43:00.720 --> 01:43:02.720]  То есть я хочу найти
[01:43:02.720 --> 01:43:04.720]  в многоугольнике P
[01:43:04.720 --> 01:43:06.720]  lower bound
[01:43:06.720 --> 01:43:08.720]  для вектора
[01:43:08.720 --> 01:43:10.720]  ноль по штрих.
[01:43:10.720 --> 01:43:12.720]  Ну, что такое lower bound?
[01:43:16.720 --> 01:43:18.720]  Это первый
[01:43:18.720 --> 01:43:20.720]  элемент.
[01:43:20.720 --> 01:43:22.720]  Такой что? Какой?
[01:43:26.720 --> 01:43:28.720]  Больше либо равен, да.
[01:43:28.720 --> 01:43:30.720]  Первый элемент, который больше либо равен.
[01:43:32.720 --> 01:43:34.720]  В данном случае
[01:43:34.720 --> 01:43:36.720]  какой вектор у меня является lower bound?
[01:43:38.720 --> 01:43:40.720]  Ну, по ноль по 4, да.
[01:43:44.720 --> 01:43:46.720]  Все, то есть я нашел
[01:43:46.720 --> 01:43:48.720]  вектор, который по углу,
[01:43:48.720 --> 01:43:50.720]  точнее, первый вектор по величине.
[01:43:50.720 --> 01:43:52.720]  Наименьший по величине
[01:43:52.720 --> 01:43:54.720]  вектор, который больше либо равен,
[01:43:54.720 --> 01:43:56.720]  чем нужный мне вектор.
[01:43:58.720 --> 01:44:00.720]  Понятно?
[01:44:00.720 --> 01:44:02.720]  И что я дальше делаю?
[01:44:02.720 --> 01:44:04.720]  Ну, понятное дело, что если я знаю
[01:44:04.720 --> 01:44:06.720]  такой вектор, то я знаю и
[01:44:06.720 --> 01:44:08.720]  следующую по величине,
[01:44:08.720 --> 01:44:10.720]  то есть вот такой вектор.
[01:44:10.720 --> 01:44:12.720]  То есть, грубо говоря, что?
[01:44:14.720 --> 01:44:16.720]  Ну, почти.
[01:44:16.720 --> 01:44:18.720]  То есть я знаю,
[01:44:18.720 --> 01:44:20.720]  что у меня вот этот вектор, он зажат
[01:44:20.720 --> 01:44:22.720]  между вот таким вектором
[01:44:22.720 --> 01:44:24.720]  и вот таким вектором.
[01:44:26.720 --> 01:44:28.720]  И что мне осталось проверить?
[01:44:28.720 --> 01:44:30.720]  Вот эта точка находится
[01:44:30.720 --> 01:44:32.720]  между вот таким лучом
[01:44:32.720 --> 01:44:34.720]  и между вот таким лучом.
[01:44:34.720 --> 01:44:36.720]  И что мне на самом деле остается проверить?
[01:44:36.720 --> 01:44:38.720]  Да, мне нужно на самом деле проверить,
[01:44:38.720 --> 01:44:40.720]  по какую сторону эта точка расположена
[01:44:40.720 --> 01:44:42.720]  относительно вот этого отрезка.
[01:44:42.720 --> 01:44:44.720]  Ну, или в общем случае нужно просто проверить,
[01:44:44.720 --> 01:44:46.720]  принадлежит ли эта точка вот этому треугольнику.
[01:44:46.720 --> 01:44:48.720]  Ну, понятное дело, что это все делается
[01:44:48.720 --> 01:44:50.720]  за вот единицами. Не важно, каким алгоритм
[01:44:50.720 --> 01:44:52.720]  вы используетесь.
[01:44:52.720 --> 01:44:54.720]  Да?
[01:44:54.720 --> 01:44:56.720]  Lower bound.
[01:44:56.720 --> 01:44:58.720]  Давайте, продолжаем писать.
[01:45:02.720 --> 01:45:04.720]  Находим
[01:45:06.720 --> 01:45:08.720]  p0, pk
[01:45:08.720 --> 01:45:10.720]  и p0,
[01:45:10.720 --> 01:45:12.720]  pk
[01:45:12.720 --> 01:45:14.720]  плюс один,
[01:45:16.720 --> 01:45:18.720]  между которыми
[01:45:18.720 --> 01:45:20.720]  зажат
[01:45:24.720 --> 01:45:26.720]  зажат
[01:45:26.720 --> 01:45:28.720]  вектор p0, p'.
[01:45:28.720 --> 01:45:30.720]  Классно?
[01:45:30.720 --> 01:45:32.720]  Ну, вот этот первый шаг
[01:45:32.720 --> 01:45:34.720]  он выполняется как раз таки за от логарифма.
[01:45:34.720 --> 01:45:36.720]  Потому что это по сути бинпоиск.
[01:45:36.720 --> 01:45:38.720]  Точнее алгоритм, который основан
[01:45:38.720 --> 01:45:40.720]  на бинпоиске, да?
[01:45:42.720 --> 01:45:44.720]  Log n.
[01:45:48.720 --> 01:45:50.720]  Ну, все.
[01:45:56.720 --> 01:45:58.720]  Ну и второй,
[01:45:58.720 --> 01:46:00.720]  последний пункт,
[01:46:00.720 --> 01:46:02.720]  этот алгоритм второй.
[01:46:02.720 --> 01:46:04.720]  Проверяем
[01:46:06.720 --> 01:46:08.720]  p'
[01:46:08.720 --> 01:46:10.720]  принадлежит,
[01:46:10.720 --> 01:46:12.720]  ну, давайте
[01:46:12.720 --> 01:46:14.720]  треугольнику
[01:46:14.720 --> 01:46:16.720]  p0, pk,
[01:46:16.720 --> 01:46:18.720]  pk плюс один,
[01:46:18.720 --> 01:46:20.720]  да, у меня?
[01:46:20.720 --> 01:46:22.720]  pk, да.
[01:46:22.720 --> 01:46:24.720]  pk плюс один.
[01:46:26.720 --> 01:46:28.720]  Вот, ну, можно так.
[01:46:28.720 --> 01:46:30.720]  По какую сторону
[01:46:36.720 --> 01:46:38.720]  от pk
[01:46:38.720 --> 01:46:40.720]  pk плюс один
[01:46:42.720 --> 01:46:44.720]  располагается p'.
[01:46:44.720 --> 01:46:46.720]  Все.
[01:46:54.720 --> 01:46:56.720]  Вопросы?
[01:46:56.720 --> 01:46:58.720]  Все понятно?
[01:47:00.720 --> 01:47:02.720]  Смотрите, тогда у меня такой вопрос.
[01:47:02.720 --> 01:47:04.720]  Смотрите, ну, вроде как,
[01:47:04.720 --> 01:47:06.720]  я обещал,
[01:47:06.720 --> 01:47:08.720]  что
[01:47:08.720 --> 01:47:10.720]  мы вообще никак не будем привлекать там всякую,
[01:47:10.720 --> 01:47:12.720]  там всякие приближенные
[01:47:12.720 --> 01:47:14.720]  вычисления, вычисления углов и так далее,
[01:47:14.720 --> 01:47:16.720]  а вот
[01:47:16.720 --> 01:47:18.720]  смотрите, когда я сравниваю угол,
[01:47:18.720 --> 01:47:20.720]  смотрите, когда я делаю бинпоиск,
[01:47:20.720 --> 01:47:22.720]  мне же на самом деле нужно сравнивать углы.
[01:47:22.720 --> 01:47:24.720]  Согласны?
[01:47:24.720 --> 01:47:26.720]  То есть как устроен бинпоиск? Я просто сравню, грубо говоря,
[01:47:26.720 --> 01:47:28.720]  вот эта штука больше, чем этот вектор или нет,
[01:47:28.720 --> 01:47:30.720]  но я сравниваю их по углу.
[01:47:30.720 --> 01:47:32.720]  Не возникает ли это противоречием? То есть мне же нужно сравнить углы,
[01:47:32.720 --> 01:47:34.720]  а как мне сравнить углы,
[01:47:34.720 --> 01:47:36.720]  не вычисляя их?
[01:47:36.720 --> 01:47:38.720]  Косинус не совсем.
[01:47:38.720 --> 01:47:40.720]  Косинус тут не поможет.
[01:47:40.720 --> 01:47:42.720]  Да, опять же, синус.
[01:47:46.720 --> 01:47:48.720]  Ну, точнее, величина знака, да,
[01:47:48.720 --> 01:47:50.720]  смотрите еще раз.
[01:47:54.720 --> 01:47:56.720]  Вот, есть два произвольных вектора.
[01:47:56.720 --> 01:47:58.720]  Вектор A,
[01:47:58.720 --> 01:48:00.720]  вектор B.
[01:48:00.720 --> 01:48:02.720]  Ну, вот горизонтальный вектор,
[01:48:02.720 --> 01:48:04.720]  а вектор B,
[01:48:04.720 --> 01:48:06.720]  и вот горизонтальная ось, допустим.
[01:48:06.720 --> 01:48:08.720]  И мне нужно понять, вот угол A,
[01:48:08.720 --> 01:48:10.720]  который составляется вот этой осью
[01:48:10.720 --> 01:48:12.720]  он Больше, чем вектор,
[01:48:12.720 --> 01:48:14.720]  Больше, чем угол, который составляет B с этой осью или нет?
[01:48:14.720 --> 01:48:16.720]  Как мне это понять?
[01:48:18.720 --> 01:48:20.720]  Давайте так,
[01:48:20.800 --> 01:48:22.720]  B меньше, чем A, ну давайте угол,
[01:48:22.720 --> 01:48:24.720]  который составляет B меньше, чем угол, который составляет A,
[01:48:24.720 --> 01:48:26.720]  тогда и только тогда?
[01:48:28.720 --> 01:48:30.720]  Когда поворот от Б к A совершается
[01:48:30.720 --> 01:48:32.720]  в положительном направлении,
[01:48:32.720 --> 01:48:34.720]  Согласны?
[01:48:34.720 --> 01:48:38.720]  То есть тогда и только тогда, когда...
[01:48:38.720 --> 01:48:42.720]  Давайте поменяем местами, чтобы...
[01:48:42.720 --> 01:48:44.720]  Давайте вот так.
[01:48:44.720 --> 01:48:46.720]  Ну, более привычно.
[01:48:46.720 --> 01:48:58.720]  А меньше b, тогда и только тогда, когда векторное произведение a и b больше нуля.
[01:48:58.720 --> 01:49:00.720]  Согласны?
[01:49:00.720 --> 01:49:02.720]  Всё.
[01:49:02.720 --> 01:49:14.720]  Чтобы сравнить углы, которые составляют векторы, мне достаточно просто сравнить векторные произведения.
[01:49:23.720 --> 01:49:28.720]  Поэтому тут по-прежнему, мне не нужно привлекать какие-то аркосинусы, арксинусы, аркангенцы.
[01:49:28.720 --> 01:49:32.720]  Я собираюсь по-прежнему вот в парадигме векторных и скалярных произведений.
[01:49:34.720 --> 01:49:36.720]  Всё.
[01:49:36.720 --> 01:49:38.720]  Замечательно.
[01:49:44.720 --> 01:49:46.720]  Всё, могу стирать.
[01:49:46.720 --> 01:50:06.720]  Ну и еще одна тема, которую стоит обсудить в цикле разговоров про геометрию, это выпухлые оболочки.
[01:50:16.720 --> 01:50:26.720]  Значит, выпухлые оболочки или по-английски convex hull.
[01:50:26.720 --> 01:50:44.720]  Значит, выпухлые оболочки множество точек, множество точек s, называется минимальная по включению,
[01:50:44.720 --> 01:51:04.720]  минимальная по включению выпухлое множество, содержащее s.
[01:51:04.720 --> 01:51:14.720]  Ну то есть у меня есть какое-то множество точек.
[01:51:14.720 --> 01:51:22.720]  И я строю такое выпухлое множество. Что такое выпухлое множество?
[01:51:22.720 --> 01:51:26.720]  Выпухлое множество, давайте вот, математическое определение, оно на самом деле не понадобится.
[01:51:26.720 --> 01:51:31.720]  В общем, выпухлое множество это то множество, которое вместе с любой парой точек содержит все промежуточные точки.
[01:51:31.720 --> 01:51:39.720]  То есть если вам известно, что есть точка A и есть точка B, и они оба принадлежат выпухлое множество,
[01:51:39.720 --> 01:51:45.720]  это означает, что все точки между ними тоже лежат в этом выпухлое множестве.
[01:51:45.720 --> 01:51:50.720]  Ну то есть грубо говоря, вот такая фигура, она не является выпухлой. Почему?
[01:51:50.720 --> 01:51:54.720]  Потому что вот есть пара точек, и вот эти точки посередине ему не принадлежат.
[01:51:54.720 --> 01:51:57.720]  Но при этом круг является выпухлым множеством.
[01:51:57.720 --> 01:52:02.720]  Какую бы пару точек они взяли, у вас промежуточные точки тоже лежат в этом множестве.
[01:52:02.720 --> 01:52:06.720]  Грубо говоря, я хочу построить такую оболочку всех моих точек,
[01:52:06.720 --> 01:52:10.720]  которая была бы выпухлой, минимальной, и которая бы естественно все точки содержала.
[01:52:10.720 --> 01:52:15.720]  То есть грубо говоря, это такое некоторое минимальное описание моего множества точек.
[01:52:21.720 --> 01:52:26.720]  Ну естественно, для произвольного множества точек, не знаю, для бесконечного множества точек,
[01:52:26.720 --> 01:52:30.720]  выпухлая оболочка может быть, ну вообще говоря, довольно произвольной фигурой.
[01:52:30.720 --> 01:52:34.720]  Например, если я возьму счетное множество точек, которые расположены по окружности,
[01:52:34.720 --> 01:52:38.720]  то выпухлой оболочкой такого множества точек будет окружность.
[01:52:38.720 --> 01:52:44.720]  Дело немного обстоит по-другому, если я использую конечное множество точек.
[01:52:44.720 --> 01:52:49.720]  Можете ли вы предположить, что будет являться выпухлой оболочкой конечного набора точек?
[01:52:49.720 --> 01:52:54.720]  Допустим, я беру вообще произвольные точки, но при этом их конечное число.
[01:52:54.720 --> 01:52:57.720]  7. Что будет являться выпухлой оболочкой?
[01:53:00.720 --> 01:53:04.720]  Ну в данном случае там шестиугольник, ну а в общем случае?
[01:53:05.720 --> 01:53:07.720]  Просто какой-то многоугольник, да.
[01:53:07.720 --> 01:53:11.720]  Ну это доказательство мы опустим, но если неформально, то понятное дело,
[01:53:11.720 --> 01:53:14.720]  что если мы следуем определению изматона выпуклости,
[01:53:14.720 --> 01:53:19.720]  то мы просто-напросто проводим всевозможные отрезки.
[01:53:19.720 --> 01:53:26.720]  Ну и по определению выпуклости у меня все отрезки должны быть внутри моего выпухлого множества.
[01:53:26.720 --> 01:53:30.720]  Поэтому, естественно, минимальная фигура, которая содержит все вот эти вот точки,
[01:53:30.720 --> 01:53:34.720]  все вот эти отрезки, это будет, грубо говоря, вот эта вот самая внешняя граница.
[01:53:34.720 --> 01:53:37.720]  Внешняя граница этой фигуры.
[01:53:37.720 --> 01:54:01.720]  Поэтому давайте отдельно пропишем, что выпухлая оболочка конечного множества точек является
[01:54:01.720 --> 01:54:08.720]  выпухлый многоугольник,
[01:54:08.720 --> 01:54:22.720]  вершина которого, давайте, конечного множества S,
[01:54:22.720 --> 01:54:28.720]  вершина которого принадлежит S.
[01:54:28.720 --> 01:54:35.720]  Вот, то есть что мне нужно сделать, в чем стоит задача?
[01:54:35.720 --> 01:54:37.720]  Ну сейчас у нас.
[01:54:37.720 --> 01:54:41.720]  Нам будет дано какой-то произвольный набор точек конечный,
[01:54:41.720 --> 01:54:44.720]  и нам нужно из этого конечного набора точек выделить такие точки,
[01:54:44.720 --> 01:54:47.720]  которые будут являться вершинами нашего выпухлого многоугольника.
[01:54:47.720 --> 01:54:49.720]  Ну короче говоря, нам дан произвольный набор множества точек,
[01:54:49.720 --> 01:54:55.720]  и нам нужно из него вытащить такой многоугольник, который бы являлся их выпухлой оболочкой.
[01:54:55.720 --> 01:55:01.720]  Вот такая вот цель на оставшуюся часть лекции.
[01:55:01.720 --> 01:55:15.720]  Ну и давайте начнем, наверное, с алгоритма Джарвиса.
[01:55:31.720 --> 01:55:39.720]  Забыл.
[01:55:53.720 --> 01:55:57.720]  Так, алгоритм Джарвиса.
[01:55:57.720 --> 01:56:01.720]  Ну еще иногда его называют алгоритм упаковки подарка.
[01:56:09.720 --> 01:56:11.720]  И вот почему.
[01:56:11.720 --> 01:56:21.720]  Давайте рассмотрим произвольное множество точек.
[01:56:21.720 --> 01:56:24.720]  Ну и давайте с такой чисто житейской точки зрения подумаем,
[01:56:24.720 --> 01:56:28.720]  как бы нам построить для такого множества точек выпухлую оболочку.
[01:56:28.720 --> 01:56:31.720]  Ну давайте возьмем какую-нибудь точку, которая гарантирована,
[01:56:31.720 --> 01:56:33.720]  которая точно войдет в нашу выпухлую оболочку.
[01:56:33.720 --> 01:56:35.720]  Это какая точка?
[01:56:35.720 --> 01:56:38.720]  Ну либо самая левая, либо самая верхняя, самая правая, самая нижняя, не важно.
[01:56:38.720 --> 01:56:40.720]  Давайте возьмем самую нижнюю точку.
[01:56:40.720 --> 01:56:46.720]  Понятное дело, что самая нижняя точка обязательно должна быть выпухлой оболочки.
[01:56:46.720 --> 01:56:48.720]  Ну и дальше я сделаю следующую вещь.
[01:56:48.720 --> 01:56:52.720]  Давайте я возьму бесконечную такую ленту,
[01:56:52.720 --> 01:56:58.720]  и буду этой лентой оборачивать мои точки, как будто заворачиваю подарок.
[01:56:58.720 --> 01:57:03.720]  Ну либо можно сказать, что тут прибиты какие-то гвоздики в стене.
[01:57:03.720 --> 01:57:08.720]  Я взял веревку и начал потихоньку оборачивать все вот эти вот гвоздики.
[01:57:08.720 --> 01:57:18.720]  Я беру и поворачиваю в положительном направлении, то есть против чего стрелки, вот этот самый луч.
[01:57:18.720 --> 01:57:20.720]  Что я в итоге получу?
[01:57:20.720 --> 01:57:22.720]  В какой момент у меня луч упрется во что-то?
[01:57:25.720 --> 01:57:27.720]  Ну вот в этот момент.
[01:57:30.720 --> 01:57:32.720]  Что это за момент такой? Что это за точка?
[01:57:34.720 --> 01:57:36.720]  С математической точки зрения.
[01:57:42.720 --> 01:57:44.720]  Да, с минимальным углом относительно горизонтали.
[01:57:46.720 --> 01:57:48.720]  Я беру вершину с минимальным углом.
[01:57:51.720 --> 01:57:55.720]  Ну и собственно давайте я возьму эту точку в мое выпуклое множество.
[01:57:55.720 --> 01:57:58.720]  При этом заметьте, что по построению у меня все окей.
[01:57:58.720 --> 01:58:03.720]  То есть я на самом деле утверждаю, тут корректность мы не будем строго доказывать, но вообще по построению тут все окей.
[01:58:03.720 --> 01:58:10.720]  Почему? Потому что если я взял вот такой луч, то у меня гарантированно правее него ничего нет.
[01:58:10.720 --> 01:58:12.720]  Все остальные точки остались только левее.
[01:58:12.720 --> 01:58:14.720]  Поэтому выпуклость у меня сохраняется.
[01:58:14.720 --> 01:58:15.720]  То же самое здесь.
[01:58:15.720 --> 01:58:16.720]  То же самое здесь.
[01:58:16.720 --> 01:58:23.720]  Ну теперь я беру вот эту точку и относительно этой точки начинаю продолжать заворачивать, в общем, заворачивать упаковку.
[01:58:23.720 --> 01:58:25.720]  Что у меня произойдет дальше?
[01:58:25.720 --> 01:58:31.720]  Ну дальше я встречу вот эту точку с наименьшим углом относительно вот этой прямой.
[01:58:31.720 --> 01:58:33.720]  Точнее вот этой луча, согласны?
[01:58:33.720 --> 01:58:35.720]  Ну и так далее.
[01:58:35.720 --> 01:58:40.720]  Встретил вот эту точку, дальше продолжаю заворачивать упаковку.
[01:58:40.720 --> 01:58:46.720]  и в какой-то момент встречу точку с наименьшим углом относительно вот этой прямой.
[01:58:46.720 --> 01:58:49.720]  И так далее. Продолжаю заворачивать, встречаю вот эту точку.
[01:58:49.720 --> 01:58:55.720]  Продолжаю заворачивать эту точку, ну и в какой-то момент приду в изначально.
[01:58:55.720 --> 01:58:59.720]  Это идея алгоритма. То есть, естественно, это не алгоритм, да?
[01:58:59.720 --> 01:59:06.720]  Это идея. Так, давайте перейдем к формальному описанию того, что мы на самом деле сделали.
[01:59:07.720 --> 01:59:09.720]  И за сколько это все работает?
[01:59:17.720 --> 01:59:20.720]  Первым шагом мы выбираем...
[01:59:26.720 --> 01:59:28.720]  Как я обозначил?
[01:59:30.720 --> 01:59:32.720]  Мы выбираем по штрих.
[01:59:36.720 --> 01:59:44.720]  С наименьшей координатой y.
[01:59:44.720 --> 01:59:48.720]  Ну опять же, почему это так? Потому что точка с наименьшей координатой y,
[01:59:48.720 --> 01:59:53.720]  с наименьшей координатой x, неважно, в любом случае эта точка войдет в выпуклую оболочку.
[01:59:53.720 --> 01:59:57.720]  Потому что мы не имеем права ее не взять. Иначе она ничем не будет захвачена.
[01:59:57.720 --> 02:00:03.720]  Короче, если таких точек несколько, то, давайте так, если таких несколько,
[02:00:03.720 --> 02:00:15.720]  например, они расположены одной прямой, таких несколько, то среди них
[02:00:15.720 --> 02:00:27.720]  с наименьшей координатой x.
[02:00:27.720 --> 02:00:31.720]  В общем, если таких точек несколько, если все расположенные на минимальном y,
[02:00:31.720 --> 02:00:35.720]  на одной прямой, то убираем точку с наименьшей координатой x.
[02:00:35.720 --> 02:00:39.720]  То есть самую левую, самую левую нижнюю точку.
[02:00:39.720 --> 02:00:45.720]  Дальше. Второй пункт делаем следующим образом.
[02:00:45.720 --> 02:01:05.720]  Пи, выбираем так, что
[02:01:05.720 --> 02:01:31.720]  пи-2, пи-1 угол, пи-1пи, является
[02:01:31.720 --> 02:01:48.720]  минимальным среди всех, среди всех п, принадлежащих многоугольнику.
[02:01:48.720 --> 02:01:54.720]  Ну, короче говоря, вот у вас есть, да, кстати, надо видимо отдельно сказать,
[02:01:54.720 --> 02:01:57.720]  что есть точка п0, мы ее выбрали как минимальную.
[02:01:57.720 --> 02:02:00.720]  Дальше мы выбираем точку п1, как минимальную,
[02:02:00.720 --> 02:02:03.720]  ну, которая составляет минимальный угол с горизонталью.
[02:02:03.720 --> 02:02:05.720]  Давайте это отдельно там пропишем.
[02:02:05.720 --> 02:02:23.720]  Какой-нибудь пункт, один штрих, п1, образует минимальный угол с горизонталью.
[02:02:23.720 --> 02:02:25.720]  Вот. То есть теперь, когда у меня есть две точки,
[02:02:25.720 --> 02:02:29.720]  я выбираю следующую точку п2 так, чтобы вот этот вот угол
[02:02:29.720 --> 02:02:34.720]  между вот этим вектором, то есть, который образован двумя последними точками,
[02:02:34.720 --> 02:02:37.720]  и вот этот вектор, чтобы он был минимальным.
[02:02:37.720 --> 02:02:42.720]  То есть, ну, понятное дело, что у меня есть много кандидатов, да,
[02:02:42.720 --> 02:02:45.720]  но среди них я выбираю такой, который образует минимальный угол.
[02:02:45.720 --> 02:02:50.720]  Да. Может так получиться, что таких несколько.
[02:02:50.720 --> 02:02:53.720]  Ну, то есть, вот представьте, что тут тоже есть несколько точек,
[02:02:53.720 --> 02:02:55.720]  которые расположены на одной прямой.
[02:02:55.720 --> 02:02:58.720]  Тогда какую точку мне среди них нужно выбрать?
[02:02:58.720 --> 02:02:59.720]  Самую дальнюю?
[02:02:59.720 --> 02:03:02.720]  Самую дальнюю, да.
[02:03:02.720 --> 02:03:21.720]  Ну, снова. Если таких несколько, то самая дальняя.
[02:03:21.720 --> 02:03:34.720]  Вот. Ну и повторяем. Повторяем пункт два.
[02:03:34.720 --> 02:03:40.720]  До каких пор? Ну, пока не вернемся в изначальную точку.
[02:03:40.720 --> 02:03:50.720]  Пока Pi не равно по ноль. Ну или, что у меня тут, по штриху было, да?
[02:03:50.720 --> 02:03:59.720]  По ноль тогда обозначу.
[02:03:59.720 --> 02:04:04.720]  Окей? Что?
[02:04:04.720 --> 02:04:09.720]  А вот не совсем. Ну, в худшем случае, действительно, он работает за n квадрат.
[02:04:09.720 --> 02:04:25.720]  Ну, давайте, действительно, давайте обсудим, за сколько он работает.
[02:04:25.720 --> 02:04:30.720]  Ну, давайте по порядку, значит, по каждому пункту.
[02:04:30.720 --> 02:04:36.720]  Ну вот, пункты один и один штрих суммарно работают за сколько?
[02:04:36.720 --> 02:04:38.720]  Ну, не более, чем за линию, согласны?
[02:04:38.720 --> 02:04:41.720]  Ну, нужно просто пройтись по всем точкам и найти там минимальную по y,
[02:04:41.720 --> 02:04:46.720]  ну, и потом еще дополнительно пройтись по всем точкам и найти точку с минимальным углом относительно горизонтали.
[02:04:46.720 --> 02:04:50.720]  То есть тут как бы линия, два прохода всего, да?
[02:04:50.720 --> 02:04:56.720]  Окей. Теперь суммарно сколько работает пункты два и три?
[02:04:56.720 --> 02:05:05.720]  Ну, давайте так. Сколько всего итераций пункта два мне потребуется?
[02:05:05.720 --> 02:05:13.720]  Да, сколько точек выпулой оболочки?
[02:05:13.720 --> 02:05:28.720]  Всего итераций h. h это количество точек выпулой оболочки.
[02:05:28.720 --> 02:05:31.720]  Ну, то есть, ну, в данном случае сколько всего точек?
[02:05:31.720 --> 02:05:38.720]  Раз, два, три, четыре, пять, шесть. Ну, то есть примерно шесть итераций.
[02:05:38.720 --> 02:05:51.720]  Так, и на каждой итерации я трачу сколько времени?
[02:05:51.720 --> 02:05:58.720]  Сколько мне нужно времени, чтобы среди всех точек найти точку, которая образует минимальный угол?
[02:05:58.720 --> 02:06:03.720]  Ну, n, да. То есть я просто беру и за линейное время нахожу минимально от n.
[02:06:03.720 --> 02:06:12.720]  Ну, то есть суммарная сложность, о большое, от n, h.
[02:06:12.720 --> 02:06:13.720]  Можно вопрос?
[02:06:13.720 --> 02:06:14.720]  Да.
[02:06:14.720 --> 02:06:17.720]  А если мы, допустим, можем вот сейчас вот точек по эти находимся,
[02:06:17.720 --> 02:06:19.720]  нам уже не надо пойти и по ноль проверять.
[02:06:19.720 --> 02:06:23.720]  Не можно ли нам перейти и по ноль проверять?
[02:06:23.720 --> 02:06:27.720]  Можно. Ну, как бы, в этом случае у вас будет оценка n-h.
[02:06:27.720 --> 02:06:35.720]  Н-h на h. Ну, не сильно, вы ничего не выиграете от этого.
[02:06:35.720 --> 02:06:39.720]  Ну, действительно, можно те точки, которые уже добавили в облочку, их можно не рассматривать.
[02:06:39.720 --> 02:06:46.720]  Но это не сильно повлияет.
[02:06:46.720 --> 02:06:51.720]  И здесь сразу мы видим следующую вещь, что у вас как бы время работы зависит от ответа.
[02:06:51.720 --> 02:06:53.720]  Ну, это на самом деле не очень хорошо, потому что вообще говорят,
[02:06:53.720 --> 02:07:10.760]  вот в этом случае
[02:07:11.720 --> 02:07:15.720]  такие алгоритмы не считаются полиномиальными.
[02:07:15.720 --> 02:07:17.720]  Потому что, как бы, пол escaped stopped from a display algorithm.
[02:07:17.720 --> 02:07:22.720]  Но, nachusson-semit contractor околонал это было все Venezuela,
[02:07:22.720 --> 02:07:27.720]  В этом случае, ваше алгоритм работает за n квадрат.
[02:07:27.720 --> 02:07:28.720]  Ну, какой это случай?
[02:07:28.720 --> 02:07:33.720]  Ну, вот если у вас внезапно все точки выстроились по окружности, например.
[02:07:33.720 --> 02:07:41.720]  В этом случае у вас все точки войдут в вашу выпуклую оболочку.
[02:07:41.720 --> 02:07:43.720]  Понятно эта оценка, откуда берется?
[02:07:43.720 --> 02:07:45.720]  Чем она хороша, чем она плоха?
[02:07:45.720 --> 02:07:50.720]  В общем, алгоритм Джарвиса работает нормально, если вы действительно заранее знаете,
[02:07:50.720 --> 02:07:53.720]  допустим, из свойств ваших точек, из свойств вашей задачи.
[02:07:53.720 --> 02:07:56.720]  Если вы точно знаете, что у вас количество точек выпуклой оболочки будет немного.
[02:07:56.720 --> 02:07:59.720]  Например, вы знаете, что у вас точки в основном сконцентрированы в центре,
[02:07:59.720 --> 02:08:01.720]  а снаружи очень мало точек.
[02:08:01.720 --> 02:08:03.720]  В этом случае нормально.
[02:08:03.720 --> 02:08:07.720]  Но в худшем случае у вас алгоритм по-прежнему будет работать за n квадрат,
[02:08:07.720 --> 02:08:10.720]  что не очень приятно.
[02:08:10.720 --> 02:08:17.720]  Так, будем писать псевдокод или на слово поверим?
[02:08:17.720 --> 02:08:22.720]  Все, отлично, супер. Мы на одной волне, замечательно.
[02:08:22.720 --> 02:08:26.720]  Давайте тогда попробуем придумать что-то более...
[02:08:26.720 --> 02:08:29.720]  В общем, алгоритм Джарвиса на самом деле очень прост.
[02:08:29.720 --> 02:08:32.720]  То есть он тут всего три пункта, и в целом все нормально.
[02:08:32.720 --> 02:08:35.720]  Да, давайте еще такой вопрос на понимание.
[02:08:35.720 --> 02:08:40.720]  Все ли понимают, что здесь снова не нужно никаких углов вычислять?
[02:08:40.720 --> 02:08:44.720]  Ну, снова минимальный угол можно посчитать просто с помощью векторного произведения.
[02:08:45.720 --> 02:08:52.720]  То есть мы берем два вектора и сравним их между собой.
[02:08:52.720 --> 02:08:54.720]  Как их сравнить между собой?
[02:08:54.720 --> 02:08:56.720]  Просто взять их векторное произведение.
[02:08:56.720 --> 02:09:03.720]  Чем больше векторное произведение, тем дальше вот этот вот отрезок находится,
[02:09:03.720 --> 02:09:07.720]  точнее так, неправильно сказал, по величине угла,
[02:09:07.720 --> 02:09:09.720]  по знаку угла между этими векторами.
[02:09:09.720 --> 02:09:13.720]  Если угол положительный, то значит этот вектор находится дальше.
[02:09:13.720 --> 02:09:15.720]  Вот этот вектор находится дальше.
[02:09:15.720 --> 02:09:19.720]  Если угол отрицательный, то значит этот вектор находится ближе.
[02:09:25.720 --> 02:09:27.720]  Ну, придется...
[02:09:27.720 --> 02:09:29.720]  Что сказать быстрее всего?
[02:09:29.720 --> 02:09:32.720]  То есть если вы видите, что у вас векторное произведение 0,
[02:09:32.720 --> 02:09:37.720]  то вы просто на самом деле смотрите на модуль координат вот этих вот штук.
[02:09:43.720 --> 02:09:45.720]  То есть у вас сравнение происходит следующим образом.
[02:09:45.720 --> 02:09:48.720]  Если векторное произведение меньше 0, то то,
[02:09:48.720 --> 02:09:50.720]  если векторное произведение больше 0, то то,
[02:09:50.720 --> 02:09:53.720]  если векторное произведение равно 0, то сравниваем еще и длины.
[02:10:01.720 --> 02:10:06.720]  Простой алгоритм Джарвиса, который в худшем случае работает за н квадрат,
[02:10:06.720 --> 02:10:09.720]  в лучшем случае, если повезет, работает за линию.
[02:10:09.720 --> 02:10:10.720]  Окей.
[02:10:10.720 --> 02:10:13.720]  Но хотелось бы чего-то более хорошего.
[02:10:13.720 --> 02:10:16.720]  И вот, прежде чем перейдем к следующему алгоритму,
[02:10:16.720 --> 02:10:22.720]  наверное стоит сделать замечание и рассказать следующую вещь.
[02:10:22.720 --> 02:10:28.720]  Вообще говоря, в общем случае, быстрее, чем занять log n,
[02:10:28.720 --> 02:10:31.720]  у вас построить выпуклую оболочку вряд ли получится.
[02:10:31.720 --> 02:10:35.720]  И вот последующая причина. Давайте замечание просто.
[02:10:40.720 --> 02:10:44.720]  Давайте так. Нижняя оценка
[02:10:52.720 --> 02:10:54.720]  на скорость
[02:11:00.720 --> 02:11:02.720]  построения выпуклой оболочки.
[02:11:02.720 --> 02:11:05.720]  Вот утверждается, что быстрее, чем за
[02:11:09.720 --> 02:11:11.720]  n log n вряд ли получится.
[02:11:11.720 --> 02:11:15.720]  Ну, что значит в общем случае, сейчас расскажу.
[02:11:15.720 --> 02:11:20.720]  У вас был в первом семе, то есть вы обсуждали нижнюю оценку на скорости сортировки?
[02:11:23.720 --> 02:11:25.720]  Да или нет?
[02:11:25.720 --> 02:11:29.720]  Все знают, что быстрее, чем за n log n сортировать в принципе в общем случае нельзя.
[02:11:29.720 --> 02:11:31.720]  Все, отлично.
[02:11:31.720 --> 02:11:33.720]  И с этим на самом деле это очень сильно связано.
[02:11:33.720 --> 02:11:34.720]  Смотрите почему.
[02:11:34.720 --> 02:11:38.720]  В общем, я утверждаю, что если вдруг мне получится построить выпуклую оболочку
[02:11:38.720 --> 02:11:41.720]  быстрее, чем за n log n, то это значит, что я смогу сортировать быстрее, чем за n log n.
[02:11:41.720 --> 02:11:43.720]  И вот такой причине.
[02:11:43.720 --> 02:11:46.720]  Вот, представьте себе, что у меня есть точки
[02:11:46.720 --> 02:11:50.720]  x0, x1, x2, ну и так далее, x1-1.
[02:11:50.720 --> 02:11:54.720]  Ну, не точки, а точнее массив значений.
[02:11:54.720 --> 02:11:56.720]  Окей?
[02:11:56.720 --> 02:11:58.720]  Теперь, что я сделаю?
[02:11:58.720 --> 02:12:03.720]  Давайте я из этих чисел, не важно, что это,
[02:12:03.720 --> 02:12:06.720]  ну, допустим числа, я сделаю следующую штуку.
[02:12:09.720 --> 02:12:12.720]  Я построю точку из точки с вот такими координатами.
[02:12:24.720 --> 02:12:28.720]  То есть точки с абсциссой x и и ординатой x и в квадрате.
[02:12:29.720 --> 02:12:31.720]  Окей?
[02:12:33.720 --> 02:12:36.720]  Ну, как будут выглядеть эти точки на плоскости?
[02:12:38.720 --> 02:12:40.720]  Вот таким образом.
[02:12:42.720 --> 02:12:44.720]  Ну, вот тут где-то у меня точки.
[02:12:44.720 --> 02:12:47.720]  И я ставлю им соответственно, ну и тут где-то ноль.
[02:12:48.720 --> 02:12:50.720]  И вот у меня точки.
[02:12:50.720 --> 02:12:54.720]  Вот, вот, тут, пусть тут.
[02:12:59.720 --> 02:13:01.720]  Согласны?
[02:13:02.720 --> 02:13:05.720]  Ну, то есть они все лежат на параболе.
[02:13:10.720 --> 02:13:13.720]  Что произойдет, если я построю выпуклой оболочку этих точек?
[02:13:15.720 --> 02:13:17.720]  Ну, понятное дело, что они все, что все эти точки
[02:13:17.720 --> 02:13:19.720]  войдут в выпуклую оболочку. Согласны?
[02:13:21.720 --> 02:13:24.720]  То есть я не могу, то есть выпуклая оболочка будет
[02:13:24.720 --> 02:13:26.720]  состоять из всех этих точек.
[02:13:26.720 --> 02:13:29.720]  То есть я построю многоугольник на этом наборе точек.
[02:13:30.720 --> 02:13:33.720]  А мы знаем, что многоугольник у него все вершины упорядочены.
[02:13:34.720 --> 02:13:37.720]  Да, ну, то есть сначала тут одна точка, потом следующая, следующая, следующая и так далее.
[02:13:37.720 --> 02:13:40.720]  То есть, по сути, если я умею, если я умею
[02:13:40.720 --> 02:13:43.720]  строить выпуклую оболочку быстрее, чем за n лог n,
[02:13:45.720 --> 02:13:48.720]  то по сути это означает, что я эти точки,
[02:13:48.720 --> 02:13:51.720]  x1, ну, xi, xj и так далее,
[02:13:51.720 --> 02:13:54.720]  получается, что все эти точки я тоже отсортировал в порядке возрастания.
[02:13:55.720 --> 02:13:58.720]  Ну, а это противоречие. Ну, нельзя сортировать быстрее, чем за n лог n.
[02:13:58.720 --> 02:14:00.720]  В общем случае.
[02:14:00.720 --> 02:14:03.720]  Ну, точнее, сортировка, которая основана только на сравнениях.
[02:14:04.720 --> 02:14:07.720]  Поэтому в этой модели вычислений, основанной только на сравнениях,
[02:14:07.720 --> 02:14:10.720]  быстрее, чем за n лог n, построить выпуклую оболочку тоже нельзя.
[02:14:11.720 --> 02:14:13.720]  Окей?
[02:14:15.720 --> 02:14:17.720]  Вот.
[02:14:17.720 --> 02:14:20.720]  Вот.
[02:14:22.720 --> 02:14:25.720]  Ну, точнее, если у меня алгоритмы по строению выпуклых оболочек
[02:14:26.720 --> 02:14:29.720]  вообще не предполагают никакой структуры в данных,
[02:14:29.720 --> 02:14:32.720]  то есть не предполагают, что у меня все точки там целы,
[02:14:32.720 --> 02:14:35.720]  не предполагают, что у меня там точки имеют какое-то определенное распределение,
[02:14:35.720 --> 02:14:38.720]  то вообще говоря быстрее, чем за n лог n, не получится.
[02:14:38.720 --> 02:14:41.720]  На самом деле, есть по строению выпуклых оболочек,
[02:14:41.720 --> 02:14:44.720]  которые работают быстрее, за линейное время и так далее,
[02:14:44.720 --> 02:14:48.880]  отчислил. Их мы затроить не будем. Давайте рассмотрим некоторый общий алгоритм,
[02:14:48.880 --> 02:14:59.520]  который достигает вот этой самой нижней границы. Вот этот алгоритм называется алгоритмом Грехома.
[02:15:14.720 --> 02:15:24.400]  Работает он следующим образом. У меня есть какой-то конечный набор точек,
[02:15:24.400 --> 02:15:47.800]  и я делаю следующую вещь. Как и в предыдущем алгоритме, я убираю точку с наименьшей
[02:15:47.800 --> 02:15:54.640]  y-координатой. Эта точка гарантированно у меня будет входить в мою выпуклую оболочку.
[02:15:54.640 --> 02:16:04.840]  А дальше я сделаю следующую интересную вещь. Я возьму и отсортирую все точки остальные по
[02:16:04.840 --> 02:16:12.440]  величине угла относительно горизонтального луча, проведенного из вот этой точки панели.
[02:16:12.440 --> 02:16:26.680]  Ну, то есть, сначала вот такая, так, так, так, так, ну и так далее. То есть 1, 2, 3, 4, 5, 6.
[02:16:26.680 --> 02:16:50.520]  То есть первый шаг. Первый шаг, ну, выбираю по ноль как аргмин по y, среди всех точек p.
[02:16:50.520 --> 02:17:13.640]  Дальше второй. Я сортирую по полярному углу относительно точки p0.
[02:17:20.520 --> 02:17:32.760]  И теперь у меня есть набор тех же самых точек, но теперь он сортирован вот по этому
[02:17:32.760 --> 02:17:51.240]  самому полярному углу. Окей? Окей, что я делаю дальше? А делаю я следующую вещь. Пусть c stack
[02:17:51.240 --> 02:18:08.440]  хранящей текущие точки в выпуклой оболочке. То есть я сведу c, некоторый stack, который будет
[02:18:08.440 --> 02:18:16.160]  хранить все точки, уже построенные в выпуклой оболочке. Окей? Ну, изначально, понятно дело,
[02:18:16.160 --> 02:18:28.160]  что c у меня состоит из точек p0 и p1. Ну, почему p0? Понятно, мы ее выбрали изначально. Почему p1?
[02:18:28.160 --> 02:18:31.440]  Потому что она обладает наименьшим полярным углом относительно горизонтали. Естественно,
[02:18:31.440 --> 02:18:39.400]  эту точку тоже надо взять. Ну, как в алгоритме Джарвиса. То есть первые две точки, как взять,
[02:18:39.400 --> 02:19:00.080]  я понимаю. А дальше происходят странные вещи. Дальше происходит следующая вещь.
[02:19:00.080 --> 02:19:27.880]  На очередном шаге рассмотрим точку pi.
[02:19:27.880 --> 02:19:44.680]  И попытаемся ее добавить. Я рассматриваю точку 2. Вот такую выпуклую оболочку я уже построил,
[02:19:44.680 --> 02:19:52.120]  и теперь пытаюсь добавить точку 2. Ну, в каком случае мне ее добавить выгодно? В каком случае
[02:19:52.120 --> 02:19:57.160]  я могу ее добавить? Ну, если она не портит мне выпуклость моего многоугольника, согласны? Ну,
[02:19:57.160 --> 02:20:00.880]  в данном случае она пока ничего не портит. То есть у меня тут по критерию выпуклости все нормально.
[02:20:00.880 --> 02:20:15.600]  То есть я заворачиваю в положительном направлении. Рассматриваю точку pi и... Что, почему? Нет, пока
[02:20:15.600 --> 02:20:21.000]  вы смотрите точки 0, 1 и 2, с ними все нормально. То есть я их рассматриваю по порядку. То есть сначала
[02:20:21.000 --> 02:20:25.560]  буду рассматривать точку 2, потом 3, потом 4, потом 5 и так далее. Вот пока я рассмотрел только точки 0,
[02:20:25.560 --> 02:20:32.480]  1 и 2. Остальные меня пока не интересуют. Здесь все нормально. То есть если она ничего не портит,
[02:20:32.480 --> 02:20:37.720]  то есть если у меня тут происходит поворот в положительном направлении, то все отлично. А что,
[02:20:37.720 --> 02:20:45.640]  если у меня происходит такая картина? Хорошо, точку 2 я добавил. На следующем шаге я пытаюсь
[02:20:45.640 --> 02:20:49.920]  добавить точку 3. То есть я очень хочу ее добавить. Ну, почему мне ее нужно добавить на этом шаге?
[02:20:49.920 --> 02:20:55.320]  Потому что вот эта точка, она гарантирована пока вот этим множеством не покрывается. Потому что
[02:20:55.320 --> 02:21:02.600]  она имеет наибольший полярный угол, наибольший среди всех этих первых четырех точек. Поэтому
[02:21:02.600 --> 02:21:09.720]  ее я на данном шаге обязан взять. Но при этом я вижу, что у меня портится выпуклость. Кто виноват в этой
[02:21:09.720 --> 02:21:18.600]  не выпуклости? Да, точка 2. И вот на этот случай есть специальный рецепт. Значит рассматриваю точку
[02:21:18.800 --> 02:21:36.680]  и если вектора i-2, i-1, i, i-1. Так, тут плохо i-2 и i-1. Давайте к. Давайте вообще с.
[02:21:36.680 --> 02:22:01.160]  Ск. Ск. Ск-1. Ну, c это точки из стека, окей? Ну вот у меня есть стек и в нем хранятся точки
[02:22:01.160 --> 02:22:16.640]  p0, p1 и так далее, pk. Ну просто какие-то точки, которые уже составляют мою выпуклооболочку. Хотел c, написал p.
[02:22:16.640 --> 02:22:25.360]  Вот, то есть я рассматриваю предыдущую точку и точку перед предыдущей. То есть я рассматриваю
[02:22:25.360 --> 02:22:33.560]  последние два элемента стека. Вот. Если угол между этими векторами, то есть если вот эти вектора
[02:22:33.560 --> 02:22:53.600]  образуют отрицательный поворот, то удаляю точку ck. Вот, это ровно то, что мы обсудили. Вот, смотрите,
[02:22:53.600 --> 02:22:58.280]  у меня была изначально точка p0 и p1. Все, я их добавил в мой стек. Они составляют выпуклооболочку.
[02:22:58.280 --> 02:23:04.160]  Ну, пока. Дальше рассматриваю точку 2. С точки 2 все хорошо. Она образует положительный поворот,
[02:23:04.160 --> 02:23:10.000]  поэтому все окей. Дальше рассматриваю точку 3 и вижу, что тут уже образуется неположительный поворот.
[02:23:10.000 --> 02:23:17.080]  То есть нарушается выпуклость. Значит, мне вот эту точку нужно удалить. Я ее удаляю и продолжаю дальше.
[02:23:17.080 --> 02:23:29.560]  Сейчас, подождите. На очередном шаге рассматриваю точку pi и если образует отрицательный поворот,
[02:23:29.560 --> 02:23:44.760]  то удаляю ck. Ну и, собственно, и так до тех пор. Пока. Ну, давайте вот это условие звездочку
[02:23:44.760 --> 02:23:50.680]  обозначим. В общем, пока вот это верно, пока у меня образуется отрицательный поворот,
[02:23:50.680 --> 02:24:04.200]  я в последовательность удаляю точку из стека. Окей? И только в самом конце добавляю точку pi.
[02:24:04.200 --> 02:24:14.520]  Ну, давайте на таком примере, ну или давайте отдельно что-ли мы нарисуем, какой-нибудь пример.
[02:24:14.520 --> 02:24:34.640]  Все видно хорошо. Ну, давайте как-то так. В общем, это первая точка, это вторая, третья,
[02:24:34.640 --> 02:24:41.400]  четвертая, пятая, шестая, седьмая и восьмая. Значит, будем рисовать стек, что в нем сейчас
[02:24:41.400 --> 02:24:49.040]  находится, и идти по порядку. То есть, изначально у меня, в моей выпуклой оболочке находятся точки
[02:24:49.040 --> 02:24:57.960]  p0 и p1. Дальше я пытаюсь добавить точку p2. С точкой p2 у меня все хорошо, согласны? Все выпукло.
[02:24:57.960 --> 02:25:06.800]  Стек добавляется с точкой p2. Дальше добавляю точку p3. А вот с p3 уже нехорошо. Вот тут появился другой
[02:25:06.800 --> 02:25:17.280]  поворот отрицательный. Поэтому я удаляю точку p2 из стека и проверяю, действительно у меня точки,
[02:25:17.280 --> 02:25:25.120]  угол между p0 и p1, и p1 и p3 образуют положительный поворот. Но тут, кажется, все нормально. Все нормально,
[02:25:25.280 --> 02:25:36.160]  добавляю точку p3. Идем дальше. p4 могу добавить? Все нормально, поворот хороший. p5 могу добавить?
[02:25:36.160 --> 02:25:44.760]  Поворот хороший. p6 могу добавить? Давайте более явно. Тоже все нормально. То есть, я спокойно
[02:25:44.760 --> 02:25:58.280]  добавляю p4, p5 и p6. Добавляю p7. Беда. Все, тут все портится. То есть, вот этот вот угол портит
[02:25:58.280 --> 02:26:11.720]  мне всю малину. Поэтому я удаляю точку p6 и рассматриваю вот такой угол. Снова все плохо, да? То есть,
[02:26:11.720 --> 02:26:23.320]  снова тут угол отрицательный. Поэтому p5 я тоже удаляю. Я рассматриваю точку p4. Давайте снова
[02:26:23.320 --> 02:26:32.080]  очевидно нарисуем, чтобы... вот так. Снова угол не совсем хороший, а точнее отрицательный. Поэтому
[02:26:32.080 --> 02:26:40.160]  и p4 я тоже удаляю из рассмотрения. Все, остается точка p3. И с точкой p3 у меня все нормально. Согласны?
[02:26:40.160 --> 02:26:49.040]  Все. Значит, цикл у меня там закончился, я добавляю точку p7. Дальше добавляю точку p8.
[02:26:49.040 --> 02:26:56.520]  С p8 все нормально. Добавляю точку p0. Все нормально. 7, p8. Ну, p0 я не добавляю, просто я замечаю,
[02:26:56.520 --> 02:27:00.680]  что я вернулся в ту же точку, откуда я начал. Все, и в итоге я понял, что у меня выбукла
[02:27:00.680 --> 02:27:12.720]  блок стоит из точек p0, p1, p3, p7, p8. Вот они. В порядке перечисления. Окей? Вот такой алгоритм.
[02:27:12.720 --> 02:27:26.440]  Пятый пункт. Повторяем пока... что повторяем? Повторяем 4. Повторяем четвертый пункт,
[02:27:26.440 --> 02:27:36.800]  пока pi не равно 0. То есть, как только я вернулся в исходную точку, я завершаю работу. Точнее не так,
[02:27:36.800 --> 02:27:50.280]  это неправильно. Повторяем до тех пор, пока не закончатся точки. Я же точки в порядке
[02:27:50.280 --> 02:27:54.440]  взрастания перечисляю. То есть, как только у меня точки закончились, это значит,
[02:27:54.440 --> 02:28:14.280]  что я все закончил. Не надо ничего проверять. Ну вот как-то так. Вопросы по алгоритму есть?
[02:28:14.280 --> 02:28:20.360]  Что непонятно? Какой шаг? Давайте еще раз повторюсь. Первые два пункта очень простые.
[02:28:20.360 --> 02:28:26.360]  Сначала выбираем минимальную точку p0. Дальше относительно этой точки горизонтали сортируем все
[02:28:26.360 --> 02:28:30.600]  точки по полярному углу. Снова сам угол вычислять не нужно. То есть, все можно сделать с помощью
[02:28:30.600 --> 02:28:35.800]  обычного векторного произведения. То есть, величину углов можно сравнить на основании
[02:28:35.800 --> 02:28:46.760]  вот векторного произведения двух векторов. Зачем? Еще раз, векторное произведение у нас,
[02:28:46.760 --> 02:29:00.920]  его проект снова из-за этого, это просто axby минус aybx. Нас же интересует только знак. Нас
[02:29:00.920 --> 02:29:04.120]  интересует синус угла между ними. То есть, между ними положительный угол и отрицательный угол.
[02:29:04.120 --> 02:29:10.280]  Все. Тут ни деления, ничего не нужно делать. То есть, единственное, что нам нужно знать...
[02:29:10.280 --> 02:29:20.360]  Так вот, смотрите. Что вас интересует? Вас интересует угол b с горизонталью. Условно,
[02:29:20.360 --> 02:29:24.040]  с горизонталью составляет больше угол или меньше угол? Вот если у вас угол, то есть,
[02:29:24.040 --> 02:29:31.120]  если у вас от a до b, от a до b угол положительный, то значит b находится дальше. Если отрицательный,
[02:29:31.120 --> 02:29:46.440]  то ближе. Вот и все. Ничего вопроса? Симптотика, супер. Давайте перейдем к симптотике. Тут все
[02:29:46.440 --> 02:29:56.920]  просто. Ну, не все просто, ладно. Почти. Первый пункт, за сколько выполняется? Ну, за линию.
[02:29:56.920 --> 02:30:09.400]  Ну, минимум найти за линию. Сортировка. Вот n, сортировка n log n. Вот. И это, собственно, самый долгий
[02:30:09.400 --> 02:30:17.280]  шаг. Второй шаг, он самый долгий. Дальше все нормально. Там c stack. Тут вообще единица. То есть,
[02:30:17.280 --> 02:30:26.680]  просто создаем stack и добавляем изначально две точки. Ну, самое сложное, наверное, здесь. В чем
[02:30:26.680 --> 02:30:33.400]  могут быть сложности вот в этих двух пунктах? Ну, смотрите, что у меня происходит. С одной стороны,
[02:30:33.400 --> 02:30:38.960]  я рассматриваю каждую точку только один раз, казалось бы. То есть, каждую точку я рассматриваю
[02:30:38.960 --> 02:30:46.360]  только один раз, поэтому o от n. Согласны? Но при этом получается так, что я постепенно из моего
[02:30:46.360 --> 02:30:51.720]  множества c какие-то точки удаляю. То есть, я некоторые точки рассматриваю по несколько раз.
[02:30:51.720 --> 02:30:58.920]  Это правда. То есть, смотрите, что у меня происходит. То есть, я точку 4 рассматривал,
[02:30:58.920 --> 02:31:08.480]  когда добавлял ее, и плюс точку 4 рассматривал, когда вот эти вот точки удалялись. Согласны? Да,
[02:31:08.480 --> 02:31:12.280]  и на этом, на самом деле, все. То есть, может показаться, что каждую точку я могу рассмотреть
[02:31:12.280 --> 02:31:16.320]  очень большое количество раз. На самом деле, нет. Каждую точку я могу рассмотреть только два раза.
[02:31:16.320 --> 02:31:31.280]  Первый раз, когда я ее добавлял в стэк. Давайте это отдельно пропишем. Каждая точка
[02:31:31.280 --> 02:31:56.520]  один раз добавляется в стэк и не более одного раза удаляется из него.
[02:32:01.280 --> 02:32:08.320]  То есть, я на каждой точке совершаю, грубо говоря, не более двух действий. Ну,
[02:32:08.320 --> 02:32:11.400]  понятное дело, что там есть еще какие-то действия, которые связаны с тем, что я вычисляю углы и так
[02:32:11.400 --> 02:32:14.720]  далее. Но так или иначе, каждое мое действие приводит к тому, что я какую-то точку добавляю,
[02:32:14.720 --> 02:32:26.440]  а какую-то точку удаляю. Согласны? Ну, все. Сколько всего добавлений точек?
[02:32:26.440 --> 02:32:42.680]  Сколько всего раз я добавляю точки в стэк? Не более чем n. А сколько всего раз я удаляю
[02:32:42.680 --> 02:32:50.640]  точки из стэка? Всего удалений. Не более чем n+. То есть, я не могу из стэка удалить больше точек,
[02:32:50.640 --> 02:33:04.040]  чем я в него добавлял. Окей, давайте напишем равно n. Согласен. Да, каждую точку в любом случае
[02:33:04.040 --> 02:33:08.760]  окажется хотя бы один раз в стэке. Да, согласен. Но самое главное, что всего удалений у меня будет
[02:33:08.760 --> 02:33:18.120]  не больше, чем n+. Соответственно, не больше, чем n раз. Понятно? То есть, суммарная сложность
[02:33:18.120 --> 02:33:25.760]  пунктов 4 и 5 от n. Ну или, можно иначе сказать, амортизированная сложность пункта A4 не
[02:33:25.760 --> 02:33:32.600]  происходит от единицы. Согласны? Ну помнишь, что такое амортизированная сложность? То есть,
[02:33:32.600 --> 02:33:37.840]  если я возьму суммарную сложность, то я просуммирую. То есть, понятно дело, что в каждый определенный
[02:33:37.840 --> 02:33:43.480]  момент у меня сложность пункта A4 может быть большой. Вот как наберется вот этими точками? То есть,
[02:33:43.480 --> 02:33:48.760]  я не могу сказать, что у меня в каждый момент пункт 4 выполняется за константное время. То есть,
[02:33:48.760 --> 02:33:52.280]  теоретически он может выполняться и бесконечно, ну не бесконечно, а очень большое количество времени.
[02:33:52.280 --> 02:34:01.720]  Ну например, вот если я так вот по спирали, ну не совсем так, но вот как-то вот так сделаю кучу
[02:34:01.720 --> 02:34:05.960]  точек и вот тут отдельную точку. Понятно дело, что когда я буду рассматривать эту точку, мне придется
[02:34:05.960 --> 02:34:13.200]  вот тут поудалять очень много всего. Но при этом суммарно, суммарно, гарантированно я не произведу
[02:34:13.200 --> 02:34:23.400]  более чем 2n действий. Все. То есть, что у меня получается? O от n, O от n log n, тут O от единицы и
[02:34:23.400 --> 02:34:30.880]  суммарно они более чем 2n, ну то есть O от n. Но естественно, вот эта штука самая долгая. Все,
[02:34:30.880 --> 02:34:36.320]  поэтому алгоритм суммарно работает за n log n и это в принципе теоретически возможно минимум,
[02:34:36.320 --> 02:34:42.320]  то есть на, ну в модели, когда мы можем использовать только арифметические действия, ну и всякие
[02:34:42.320 --> 02:35:06.200]  сравнения. Да, да. Вот. Ну видимо, видимо еще один алгоритм не успеем рассказать, ну в общем-то
[02:35:06.200 --> 02:35:10.880]  этого достаточно. Этого в задании будут только эти два алгоритма. Соответственно у вас есть
[02:35:10.880 --> 02:35:23.480]  алгоритм Джарвиса, который работает за n h и у вас есть алгоритм Грехема, который работает за n
[02:35:23.480 --> 02:35:27.760]  log n. Но опять же, нельзя сказать, что там, скажем Грехем строго лучше, чем Джарвис и Джарвис строго
[02:35:27.760 --> 02:35:32.400]  лучше, чем Грехем. Да, потому что, ну в зависимости от соотношений между h и log n, у вас могут
[02:35:32.400 --> 02:35:37.400]  получаться те или иные, в общем, те или иные артефакты, так скажем. Вот. Все зависит от
[02:35:37.400 --> 02:35:40.720]  установки сдачи, там, насколько вы понимаете, там, насколько много точек у вас, может быть,
[02:35:40.720 --> 02:35:45.520]  выпуклые оболочки или насколько, насколько мало. Ну, сегодня, видимо, все. Спасибо.
