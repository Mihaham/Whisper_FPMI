[00:00.000 --> 00:14.000]  Всем добрый день! Сегодня мы продолжаем разговор про вычисления на ограниченной памяти,
[00:14.000 --> 00:21.000]  но теперь дополнительная память будет совсем маленькой, а именно логарифмической.
[00:21.000 --> 00:25.000]  Сначала поговорим про деталинированные вычисления на логарифмической памяти,
[00:25.000 --> 00:31.000]  и потом начнём разговор про недетерминированные вычисления, которые продолжим в следующий раз.
[00:31.000 --> 00:37.000]  Возможно, в следующий раз будет точно, но ещё посмотрим.
[00:38.000 --> 00:44.000]  Давайте начну демонстрацию.
[00:51.000 --> 01:00.000]  Поговорим про вычисления на логарифмической памяти.
[01:00.000 --> 01:09.000]  Давайте я напомню, как мы считаем память.
[01:09.000 --> 01:28.000]  Подсчитывается число занятых ячеек на рабочих лентах.
[01:28.000 --> 01:44.000]  Не учитываются ячейки входа, которые, соответственно, получаются неизменяемыми.
[01:44.000 --> 02:00.000]  Ну и выхода, если он не просто да или нет, то есть если он является словом или числом.
[02:00.000 --> 02:09.000]  Если он является битом, то тогда не важно, считать его или нет, он всё равно константа.
[02:09.000 --> 02:14.000]  Вот, соответственно, вот есть класс L.
[02:14.000 --> 02:19.000]  Получается L – это dspace.
[02:19.000 --> 02:24.000]  Вот, сейчас, нет, здесь больше не нужно.
[02:24.000 --> 02:27.000]  Здесь мы просто пишем логарифм.
[02:27.000 --> 02:49.000]  Это класс языков, для которых достаточно памяти порядка Ln на детерминированной машине тюрлинга.
[02:49.000 --> 02:51.000]  Ещё есть Tnl.
[02:51.000 --> 02:57.000]  Tnl – это будет nspace от Ln.
[02:57.000 --> 03:11.000]  Соответственно, это класс языков, для которых достаточно памяти порядка Ln,
[03:11.000 --> 03:18.000]  соответственно, на недерминированной машине тюрлинга.
[03:18.000 --> 03:26.000]  Ну и, значит, поговорим.
[03:26.000 --> 03:32.000]  Сначала, первая половина лекции будет стоять от различных примеров.
[03:32.000 --> 03:37.000]  Примеры языков из L.
[03:37.000 --> 03:55.000]  Первый класс примеров будет различными задачами из просто арифметики двоичных чисел.
[03:56.000 --> 04:09.000]  Задача из арифметики двоичных чисел.
[04:09.000 --> 04:17.000]  Ну и первое из них – это просто сравнение чисел.
[04:17.000 --> 04:31.000]  Значит, здесь у нас будет язык LE, который состоит из пар XY, таких, что x меньше либо равно y.
[04:31.000 --> 04:39.000]  Ну, на самом деле, будет там меньше либо равно, да, или там больше либо равно, строго меньше.
[04:39.000 --> 04:42.000]  Будут они в двоичной записи записаны или какой-нибудь другой.
[04:42.000 --> 04:44.000]  И это всё, на самом деле, не очень важно.
[04:44.000 --> 04:46.000]  Главное, что не унарные.
[04:46.000 --> 04:58.000]  Если запись унарная, то там и так все фактически полинамиальные алгоритмы будут решаться на лог памяти.
[04:58.000 --> 05:05.000]  Потому что если у вас унарное кодирование, то вы можете сначала перейти в двоичное
[05:05.000 --> 05:10.000]  и дальше уже работать с тем, что получится.
[05:10.000 --> 05:20.000]  И, конечно, двоичное кодирование занимает логарифмическую память от самого числа.
[05:20.000 --> 05:25.000]  Поэтому там все обычные полинамиальные алгоритмы будут логарифмическими.
[05:25.000 --> 05:27.000]  Что унарной записи – это не интересно.
[05:27.000 --> 05:29.000]  Будем считать, что запись двоичная.
[05:29.000 --> 05:43.000]  Тут, на самом деле, важный вопрос состоит в том, как именно представлены числа.
[05:43.000 --> 05:52.000]  Самый простой вариант, когда достаточно константной памяти,
[05:52.000 --> 06:19.000]  это если у X и Y одинаковое число значащих битов, то есть возможные ведущие нули.
[06:19.000 --> 06:32.000]  При этом X и Y записаны на разных лентах.
[06:32.000 --> 06:53.000]  Получается, что тогда достаточно идти слева направо,
[06:53.000 --> 07:12.000]  значит, читать параллельно X и Y от старших битов к младшим,
[07:12.000 --> 07:19.000]  соответственно, сравнивать прочтенные биты,
[07:19.000 --> 07:28.000]  ну и искать первое несовпадение.
[07:28.000 --> 07:47.000]  Как только оно найдется, можно выдать ответ, что число, в котором стоит единица, больше.
[07:47.000 --> 08:01.000]  Если все совпали, то числа равны.
[08:01.000 --> 08:06.000]  Это можно сделать конечным автоматом.
[08:06.000 --> 08:12.000]  То есть мы идем слева направо от старших битов к младшим.
[08:12.000 --> 08:28.000]  Я думаю, что должно быть так.
[08:28.000 --> 08:41.000]  1b, что у них, возможно, разное число значащих битов, но тогда будем считать, что ведущих нулей нет.
[08:41.000 --> 08:46.000]  Можно считать, что они есть, там еще немножко сложнее.
[08:46.000 --> 09:05.000]  Соответственно, в записях нет ведущих единиц.
[09:05.000 --> 09:22.000]  Но, соответственно, возможно, различная длина X и Y.
[09:22.000 --> 09:30.000]  Ну тогда получается, что сначала нужно сравнить...
[09:30.000 --> 09:40.000]  А, ну и они по-прежнему на разных лентах.
[09:40.000 --> 09:45.000]  Нужно сначала сравнить длины.
[09:45.000 --> 10:04.000]  Если у одного числа длина больше, то и оно больше.
[10:04.000 --> 10:13.000]  Тоже вполне все естественно.
[10:13.000 --> 10:16.000]  Ну и, в принципе, можно просто...
[10:16.000 --> 10:29.000]  По-прежнему не нужна дополнительная память.
[10:29.000 --> 10:36.000]  Но, соответственно, нужно сделать минимум два прохода.
[10:36.000 --> 10:41.000]  Да, скорее три.
[10:41.000 --> 10:44.000]  Я пишу несколько проходов.
[10:44.000 --> 10:51.000]  Тут все зависит от того, что мы сначала стоим на старшем разряде или на младшем.
[10:51.000 --> 10:54.000]  Потому что, чтобы сравнивать длину, не важно.
[10:54.000 --> 11:00.000]  Для того, чтобы сравнивать длину, безразлично с какой стороны начинать.
[11:00.000 --> 11:11.000]  Мы просто идем параллельно по битам и смотрим, какое число быстрее закончилось.
[11:11.000 --> 11:16.000]  Если одинаково, то тогда уже нужно сравнивать по битам.
[11:16.000 --> 11:22.000]  Если мы стоим на младших разрядах, то можно сначала пройти к старшим, сравнить длину.
[11:22.000 --> 11:26.000]  Если длина одна, тогда уже начинается о старших сравнивать.
[11:26.000 --> 11:33.000]  Если мы сначала на старших разрядах, то можно сначала сравнить.
[11:33.000 --> 11:37.000]  Но тогда мы окажемся при равенстве в конце слова.
[11:37.000 --> 11:41.000]  И тогда, соответственно, нужно возвращаться обратно.
[11:41.000 --> 11:44.000]  А потом уже снова сравнивать.
[11:44.000 --> 11:47.000]  В общем, я думаю, это тоже должно быть понятно.
[11:47.000 --> 11:51.000]  И еще один В.
[11:51.000 --> 11:59.000]  Соответственно, записи на одной ленте.
[12:01.000 --> 12:07.000]  Тогда уже обязательно нужен некоторый алгорифм.
[12:07.000 --> 12:32.000]  Для сравнения соответствующих битов нужно перемещаться от записи одного слова к записи другого.
[12:32.000 --> 12:56.000]  При этом нельзя делать пометки до какого бита прочитано число.
[12:56.000 --> 13:00.000]  Если можно было делать пометки, тогда дополнительной памяти не нужно было.
[13:00.000 --> 13:03.000]  Мы тоже сделали пометку.
[13:03.000 --> 13:07.000]  Возвратились, взяли там бит, тоже сделали пометку.
[13:07.000 --> 13:12.000]  Пошли туда, сравнили, сдвинулись, сделали пометку и так далее.
[13:12.000 --> 13:15.000]  Ходили бы туда-сюда.
[13:15.000 --> 13:24.000]  Но, к сожалению, так нельзя.
[13:24.000 --> 13:38.000]  Соответственно, вместо пометок нужно подсчитывать шаги.
[13:38.000 --> 14:07.000]  Например, идем вдоль слова Х, подсчитываем шаги на второй линии.
[14:08.000 --> 14:21.000]  Мы записываем двоичные записи, поэтому там получится длина записи и порядка алгорифма.
[14:21.000 --> 14:35.000]  Длина записи будет в верхней целой части алгорифма Х.
[14:35.000 --> 14:41.000]  Ну, там плюс один, может быть, в общем, неважно.
[14:41.000 --> 14:48.000]  После этого дошли до конца слова, дальше идем вдоль слова Y.
[14:48.000 --> 14:53.000]  Соответственно, подсчитываем.
[14:53.000 --> 14:58.000]  Снова шаги.
[14:58.000 --> 15:02.000]  Ну, и снова записываем.
[15:02.000 --> 15:18.000]  Дальше идем вдоль слова Y, подсчитываем шаги, тоже записываем результат отдельно.
[15:18.000 --> 15:23.000]  Равниваем результаты.
[15:23.000 --> 15:34.000]  И это уже можно делать обычным способом, потому что на рабочей ленте с алгоритмической длиной мы можем делать пометки.
[15:34.000 --> 15:44.000]  Тут уже обычным способом делаем пометки.
[15:44.000 --> 15:50.000]  Так как там только алгоритмическая память.
[15:50.000 --> 15:53.000]  Ну и вообще рабочая память.
[15:53.000 --> 16:05.000]  Вот, соответственно, если какой-то больше, то выдаем соответствующий ответ.
[16:05.000 --> 16:15.000]  Так, если равны, то начинаем сравнивать результаты.
[16:15.000 --> 16:23.000]  Так, длина Y нам, в принципе, уже не нужна.
[16:23.000 --> 16:29.000]  Дальше, получается, идем на начало X.
[16:29.000 --> 16:33.000]  Значит, у нас запасы уже не нужны.
[16:33.000 --> 16:42.000]  Ну, и дальше идем на начало X.
[16:42.000 --> 16:46.000]  Значит, у нас запомнена длина X.
[16:46.000 --> 16:54.000]  Идем на начало X.
[16:54.000 --> 17:01.000]  Запоминаем бит на X1.
[17:01.000 --> 17:07.000]  Дальше делаем шаги.
[17:07.000 --> 17:11.000]  Бит на X1.
[17:11.000 --> 17:23.000]  Дальше делаем длину X плюс один шаг вправо.
[17:23.000 --> 17:32.000]  Сравниваем.
[17:32.000 --> 17:48.000]  Ну, значит, мы таким образом дойдем до Y1 и сравниваем его с X1.
[17:48.000 --> 17:54.000]  Ну, на самом деле тут, смотрите, надо все-таки это аккуратно делать.
[17:54.000 --> 17:58.000]  Потому что если вдруг оказалось, что там еще ведущие нули есть,
[17:58.000 --> 18:02.000]  то нужно будет и от длину сравнивать с учетом этих самых ведущих нулей.
[18:02.000 --> 18:14.000]  Так что можно либо требовать, чтобы у нас автоматически,
[18:14.000 --> 18:18.000]  если где-то начальная единица, мы сразу отвергаем, говорим, что не в том формате вход.
[18:18.000 --> 18:22.000]  Да, это мы, конечно, сможем сделать.
[18:22.000 --> 18:26.000]  Либо как-то еще отдельно говорить, как именно мы будем сравнивать.
[18:26.000 --> 18:28.000]  Тогда сначала нам...
[18:28.000 --> 18:31.000]  Тут как бы тогда будет две разные вещи.
[18:31.000 --> 18:35.000]  Отдельная вещь – это число битов от первой единицы до конца,
[18:35.000 --> 18:38.000]  а другая вещь – длина всей записи.
[18:38.000 --> 18:45.000]  И тогда, соответственно, будут немножко...
[18:45.000 --> 18:49.000]  В общем, одну вещь мы используем здесь, другую – здесь.
[18:49.000 --> 18:51.000]  Так, хорошо.
[18:51.000 --> 19:03.000]  Дальше, получается, идем теперь на длину х шагов влево.
[19:03.000 --> 19:10.000]  Значит, запоминаем бит х2.
[19:10.000 --> 19:23.000]  Соответственно, делаем теперь длину х плюс один шагов вправо.
[19:23.000 --> 19:32.000]  Значит, и сравниваем х2, запоминанное с у2.
[19:32.000 --> 19:37.000]  Ну и так далее.
[19:37.000 --> 19:49.000]  То есть каждый раз делаем х шагов влево, потом х плюс один шаг вправо.
[19:49.000 --> 19:51.000]  И делаем сравнение.
[19:51.000 --> 19:57.000]  Соответственно, если где-то какие-то сравнения различные, то понятно будет ответ.
[19:57.000 --> 20:00.000]  Если все одинаковые, то будет тоже ответ.
[20:00.000 --> 20:02.000]  Вот, хорошо.
[20:02.000 --> 20:06.000]  Соответственно, получается, есть некоторый общий вывод.
[20:06.000 --> 20:16.000]  Есть некоторый общий вывод, что если для реализации алгоритма
[20:16.000 --> 20:23.000]  достаточно иметь полиномиальное число.
[20:23.000 --> 20:26.000]  Даже нет, не полиномиальное.
[20:26.000 --> 20:33.000]  Константное число счетчиков,
[20:33.000 --> 20:48.000]  каждый из которых варьируется в пределах от 1 до полинома от n,
[20:48.000 --> 21:02.000]  то для реализации алгоритма достаточно логарифмической памяти.
[21:02.000 --> 21:09.000]  Здесь нам нужен фактически один счетчик, чтобы запомнить длину х,
[21:09.000 --> 21:12.000]  и один, чтобы считать эти шаги.
[21:12.000 --> 21:16.000]  Его же можно использовать здесь для сравнения.
[21:16.000 --> 21:20.000]  Получается, что память логарифмическая.
[21:20.000 --> 21:22.000]  Я надеюсь, что это довольно понятно.
[21:22.000 --> 21:25.000]  Это не очень сложная вещь, но я просто хочу подробно рассказать,
[21:25.000 --> 21:31.000]  чтобы было понятно, на какие технические вещи тут нужно обращать внимание.
[21:31.000 --> 21:39.000]  Несли каких-нибудь вопросов.
[21:39.000 --> 21:44.000]  Если нет, то движемся дальше.
[21:44.000 --> 21:47.000]  Дальше пункт два.
[21:47.000 --> 21:52.000]  Пункт два – это сложение чисел.
[21:52.000 --> 21:57.000]  Тут я уже не буду так подробно рассказывать.
[21:57.000 --> 22:01.000]  Тут со сложением.
[22:01.000 --> 22:04.000]  Это функция.
[22:04.000 --> 22:09.000]  Для функции по логарифмической вычислимости можно понимать две вещи эквивалентные.
[22:09.000 --> 22:14.000]  Либо у нас есть машина, у которой есть выходной поток,
[22:14.000 --> 22:23.000]  и в нем печатается сумма.
[22:23.000 --> 22:31.000]  Либо у нас уже дана сумма, и мы просто проверяем, что сумма именно такая.
[22:31.000 --> 22:34.000]  Сложение чисел.
[22:34.000 --> 23:03.000]  Тут тоже первый вариант, когда у нас на x и y слагаемые написаны на разных лентах.
[23:03.000 --> 23:11.000]  Соответственно, тогда годится обычный школьный алгоритм.
[23:11.000 --> 23:15.000]  Столбик.
[23:15.000 --> 23:32.000]  И, опять же, дополнительной памяти вообще не нужно.
[23:32.000 --> 23:37.000]  Это получается, можно сделать конечным автоматом.
[23:37.000 --> 23:40.000]  Взять и сложить.
[23:40.000 --> 23:46.000]  Понятно, вы все знаете, когда мы идем справа налево,
[23:46.000 --> 23:58.000]  запоминаем бита переноса, то есть складываем бита x и y,
[23:58.000 --> 24:04.000]  добавляем бит перенос, если он был, если получилось 0 или 1, то так и оставляем бит переноса 0,
[24:04.000 --> 24:12.000]  если 2 или 3, то 0 или 1 пишем, и еще один бит переноса, и так все вычисляется.
[24:12.000 --> 24:16.000]  Обычный алгоритм.
[24:16.000 --> 24:30.000]  Соответственно, 2b, 2b это слагаемые записаны на одной ленте.
[24:30.000 --> 24:49.000]  Тогда получается аналогично, но нужен счетчик, обозначающий текущую позицию.
[24:49.000 --> 24:52.000]  Точно так же, как здесь.
[24:52.000 --> 24:58.000]  Хорошо, я думаю, это понятно, складывать столбик все умеют.
[24:58.000 --> 25:00.000]  Теперь поговорим про умножение.
[25:00.000 --> 25:08.000]  Три умножения чисел.
[25:08.000 --> 25:13.000]  Здесь уже прямо школьный алгоритм не совсем подходит.
[25:13.000 --> 25:25.000]  Школьный алгоритм в чистом виде не вполне подходит,
[25:25.000 --> 25:39.000]  поскольку обычно подразумевает квадратную таблицу,
[25:39.000 --> 25:52.000]  соответствующими результатами умножений и потом сложения.
[25:52.000 --> 26:08.000]  Но на самом деле, если у нас x будет равно x1, и так далее, и xn.
[26:08.000 --> 26:13.000]  А давайте наоборот.
[26:13.000 --> 26:20.000]  Давайте так, от n до 0, xn, xn-1, и так далее x0.
[26:20.000 --> 26:25.000]  То есть мы нумеруем, начиная с мальших видов, начиная с 0.
[26:25.000 --> 26:38.000]  Соответственно, у равняется yn, и так далее y0.
[26:38.000 --> 26:55.000]  Ну, тогда получается, что x умноженный на y будет равен z,
[26:55.000 --> 27:04.000]  которое будет равно, значит, будет бит в два раза больше z2n, и так далее z0.
[27:04.000 --> 27:07.000]  И биты в принципе считаются так.
[27:07.000 --> 27:13.000]  Значит z0, но это равно x0 на y0.
[27:13.000 --> 27:16.000]  Это понятно.
[27:16.000 --> 27:30.000]  Значит z1 будет равно x0y1 плюс x1y0.
[27:30.000 --> 27:45.000]  З2 будет равно x0y2 плюс x1y1 плюс x2y0.
[27:45.000 --> 27:55.000]  Ну и еще, возможно, плюс перенос предыдущего этапа.
[27:55.000 --> 28:00.000]  Потому что здесь с 0 на 1 никак не могло быть переноса,
[28:00.000 --> 28:06.000]  потому что тут либо 0, либо 1, а вот здесь, в принципе, могло быть 2.
[28:06.000 --> 28:08.000]  Могло быть 2, 1 плюс 1.
[28:08.000 --> 28:12.000]  Тогда тут мы пишем 0, а единицу отправляем на перенос предыдущего этапа.
[28:12.000 --> 28:16.000]  И так, в принципе, и дальше будет.
[28:16.000 --> 28:18.000]  Понятное дело.
[28:18.000 --> 28:38.000]  Зкт будет равно x0yk, значит, плюс x1y-1, плюс и так далее.
[28:38.000 --> 28:43.000]  Плюс в конце там xкт y0.
[28:43.000 --> 28:53.000]  Ну и еще опять же плюс перенос.
[28:53.000 --> 28:55.000]  Но главное, что надо понимать про перенос,
[28:55.000 --> 28:59.000]  значит, чем перенос для умножения отличается от переноса для сложения.
[28:59.000 --> 29:05.000]  Для сложения этот перенос был всегда либо 0, либо 1.
[29:05.000 --> 29:09.000]  А здесь, поскольку мы складываем много слагаемых,
[29:09.000 --> 29:12.000]  при этом система у нас по-прежнему двоичная,
[29:12.000 --> 29:16.000]  то этот перенос может быть длинным.
[29:16.000 --> 29:23.000]  То есть тут даже если x1 и x2, даже если x и y хранятся на разных лентах,
[29:23.000 --> 29:27.000]  и нам не нужна логографическая память для того, чтобы запоминать,
[29:27.000 --> 29:32.000]  куда мы там смотрим на x и куда на y,
[29:32.000 --> 29:40.000]  то все равно нам нужна логографическая память для хранения переноса.
[29:40.000 --> 29:43.000]  То есть тут получается и так далее.
[29:43.000 --> 29:53.000]  И для хранения переноса может быть нужна логографическая память.
[30:10.000 --> 30:18.000]  Получается, что мы делаем.
[30:18.000 --> 30:26.000]  Понятное дело, что если у нас с двух лент на одну нужно,
[30:26.000 --> 30:30.000]  то нам нужны счетчики, чтобы запоминать, куда идти в одном условии и в другом условии.
[30:30.000 --> 30:34.000]  Пусть у нас даже x и y на разных лентах.
[30:34.000 --> 30:37.000]  Тогда что мы делаем?
[30:37.000 --> 30:43.000]  Один указатель выводим вот сюда, другой сюда,
[30:43.000 --> 30:46.000]  и потом один по взрослению, другой по убыванию.
[30:46.000 --> 30:52.000]  Если у нас и там, и там единицы, то мы увеличиваем этот счетчик на единицу.
[30:52.000 --> 30:57.000]  Потом еще добавляем перенос с предыдущего шага.
[30:57.000 --> 31:00.000]  Получается какое-то число логографическое.
[31:00.000 --> 31:04.000]  Последний бит мы записываем в ответ ZKT,
[31:04.000 --> 31:08.000]  а все кроме последнего бита, то есть целую часть от половины,
[31:08.000 --> 31:12.000]  мы отправляем как перенос на следующий шаг.
[31:23.000 --> 31:27.000]  Ну ладно, я думаю, это тоже должно быть довольно понятно.
[31:27.000 --> 31:33.000]  В результате, кроме этого текущего переноса и, возможно, указателей для одной ленты,
[31:33.000 --> 31:37.000]  нам ничего не нужно хранить, получается логографическая память.
[31:38.000 --> 31:40.000]  Так, хорошо.
[31:40.000 --> 31:48.000]  Теперь проверим четвертую часть.
[31:48.000 --> 32:07.000]  Четвертая часть, проверим проверка правильности скобочной последовательности.
[32:11.000 --> 32:15.000]  Значит, проверка правильности скобочной последовательности.
[32:18.000 --> 32:26.000]  Я думаю, что вы все помните, что это такое.
[32:26.000 --> 32:33.000]  У нас имеется баланс.
[32:33.000 --> 32:40.000]  Одно из определений такое,
[32:40.000 --> 32:59.000]  что в каждом префиксе открывающих скобок не меньше, чем закрывающих,
[32:59.000 --> 33:09.000]  а во всей последовательности поровну.
[33:09.000 --> 33:29.000]  Вот тогда мы можем просто завести счетчик для подсчета баланса.
[33:29.000 --> 33:47.000]  Соответственно, при открывающей скобке увеличивать его на 1, значит при закрывающей уменьшать.
[33:47.000 --> 34:08.000]  Если оказалось, что он равен 0 и должен быть уменьшен, то, соответственно, отвергнуть вход.
[34:08.000 --> 34:31.000]  Если слово закончилось, то проверить, что он равен 0.
[34:31.000 --> 34:39.000]  Если равен, то принять, если не правен, то отвергнуть.
[34:39.000 --> 34:46.000]  Понятно, что никакой момент баланс не может быть больше, чем длина.
[34:46.000 --> 35:15.000]  Поскольку баланс всегда не больше длины, то, соответственно, получаем, что достаточно логарифма битов.
[35:15.000 --> 35:23.000]  Так, хорошо. Надеюсь, это тоже более-менее понятно.
[35:23.000 --> 35:29.000]  Другой вариант. Я оставлю номер 4, 4 штрих.
[35:29.000 --> 35:47.000]  Это проверка правильности последовательности из нескольких типов скобок.
[35:47.000 --> 36:03.000]  Тут недостаточно проверять баланс по каждому типу скобок.
[36:03.000 --> 36:17.000]  Например, может быть, вот такая вот скобка, потом скобка круглая закрывается и скобка квадратная закрывается.
[36:17.000 --> 36:35.000]  Тут, соответственно, все балансы верны.
[36:35.000 --> 37:01.000]  Последовательность неправильная.
[37:01.000 --> 37:05.000]  Ну, соответственно, тут получается критерий, который нужно проверять.
[37:05.000 --> 37:31.000]  Такой критерий, что условие на баланс соблюдается внутри каждой пары
[37:31.000 --> 37:41.000]  соответствующих скобок.
[37:41.000 --> 37:51.000]  Да, здесь, например, круглая закрывается, круглая закрывается, вот между ними баланс не соблюден.
[37:51.000 --> 38:15.000]  Ну и тогда алгоритм будет такой, что мы стартуем от открывающей скобки,
[38:15.000 --> 38:39.000]  заводим счетчик символов и счетчик баланса по скобкам данного типа.
[38:39.000 --> 38:57.000]  И, соответственно, доходим до момента, когда счетчик баланса обнулился.
[38:57.000 --> 39:15.000]  Вот, соответственно, если слово кончилось раньше, то отвергаем.
[39:15.000 --> 39:39.000]  Ну и дальше, соответственно, анализируем участок между этими двумя скобками.
[39:39.000 --> 39:51.000]  С точки зрения баланса. Ну и тут вроде бы даже можно не разделять, а просто подсчитать баланс.
[39:51.000 --> 40:13.000]  Достаточно подсчитать баланс по всем типам скобок.
[40:13.000 --> 40:17.000]  В смысле не различать их?
[40:17.000 --> 40:21.000]  Ну, мне кажется, да, должно быть достаточно.
[40:21.000 --> 40:27.000]  Ну, в принципе, надо подумать, это будет верный критерий или нет, но, по-моему, верный.
[40:27.000 --> 40:31.000]  Если даже вдруг не верный, то можно и по каждой отдельности.
[40:31.000 --> 40:39.000]  Но, по-моему, даже если внутри по всем типам все будет нормально, но при этом это не разбирается,
[40:39.000 --> 40:45.000]  то по предположению индукции там для какой-то другой пары скобок внутри них будет не все верно.
[40:45.000 --> 40:51.000]  Так что вроде бы это должно быть правильно.
[40:51.000 --> 40:59.000]  Вот такая дополнительная оптимизация. Можно, конечно, перебирать разные.
[40:59.000 --> 41:05.000]  Да, в принципе, тут еще можно поговорить о входе записан.
[41:05.000 --> 41:17.000]  Потому что если у нас константное число видов скобок, то, конечно, можно просто как слово написать.
[41:17.000 --> 41:23.000]  Но если еще и число скобок может быть растущие, зависящие от длины,
[41:23.000 --> 41:29.000]  то тогда нужно описывать типа скобка открывающая, и у нее там индекс какой-нибудь.
[41:29.000 --> 41:33.000]  Индекс в мире какого она типа.
[41:33.000 --> 41:37.000]  Но неважно. Эти индексы как раз тоже логографической длины,
[41:37.000 --> 41:44.000]  так что можно их там сравнивать друг с другом как угодно и так далее. Записывать, приписывать и так далее.
[41:44.000 --> 41:50.000]  Ну, соответственно, как мы анализируем, можно считать, что мы идем обратно справа налево.
[41:50.000 --> 41:54.000]  Каждый раз баланс туда-сюда изменяем.
[41:54.000 --> 42:06.000]  И, соответственно, вот этот счетчик символов наоборот уменьшаем на единицу на каждом ходе.
[42:24.000 --> 42:38.000]  Соответственно, когда этот счетчик символов обнулился при проходе обратно, то счетчик баланс новый тоже должен обнулиться.
[42:38.000 --> 42:44.000]  Так, ну ладно.
[42:44.000 --> 42:49.000]  Так, ну ладно. Я думаю, что онлайн-лекции перерыв не обязательно делать.
[42:49.000 --> 42:52.000]  У меня еще есть одна историка, которую хочу рассказать.
[42:52.000 --> 42:58.000]  Про логографическую память детерминирована, дальше про нл уже начнем разговор.
[42:58.000 --> 43:03.000]  Она немножко более сложная, чем все предыдущие.
[43:03.000 --> 43:16.000]  Пятое это проверка того, является ли граф деревом.
[43:16.000 --> 43:26.000]  Тут, конечно, могут быть какие-то разговоры про то, как именно граф кодируется.
[43:26.000 --> 43:38.000]  Да, ну по граммеру он неориентированный, является неориентированный граф деревом.
[43:38.000 --> 43:44.000]  Он может кодироваться как список ребер, как матрица смежности.
[43:44.000 --> 43:50.000]  Так или иначе, мы считаем, что у нас есть процедура, как от вершины перейти к соседней.
[43:50.000 --> 43:55.000]  Может быть, к соседней с таким-то номером и так далее.
[43:55.000 --> 44:01.000]  Вот, проверка того, является ли неориентированный граф деревом.
[44:01.000 --> 44:07.000]  Смотрите, какое определение. Дерево.
[44:07.000 --> 44:19.000]  Дерево – это связный граф без циклов.
[44:19.000 --> 44:23.000]  Вот, но можем ли мы проверять связность?
[44:23.000 --> 44:40.000]  Значит, можем ли мы проверять связность и отсутствие циклов по отдельности?
[44:40.000 --> 44:55.000]  На самом деле можем, но это довольно сложная теорема.
[44:55.000 --> 45:05.000]  Такая теорема Рейнгольда 2005 года.
[45:05.000 --> 45:13.000]  Основная вещь, которую мы изучаем в этом курсе, относится к 70-м годам, к 80-м.
[45:13.000 --> 45:19.000]  А это уже существенно более свежий результат.
[45:19.000 --> 45:23.000]  Хотя для вас, может быть, уже не такой свежий.
[45:23.000 --> 45:35.000]  Теорема Рейнгольда 2005 года использует технику экспандеров.
[45:35.000 --> 45:41.000]  И там довольно много технических разных подробностей.
[45:41.000 --> 45:52.000]  На моем спецкурсе про псевдослучайности и дарандомизации пару недель назад мы как раз доказали эту теорему.
[45:52.000 --> 45:57.000]  Но тоже без всех технических подробностей.
[45:57.000 --> 46:05.000]  И до этого мы три занятия необходимой вещи из теории экспандеров изучали.
[46:05.000 --> 46:10.000]  Такой серьезный результат, на пальцах не объяснить.
[46:10.000 --> 46:28.000]  И то, и другое вместе можно проверить относительно, по крайней мере, элементарные методы.
[46:28.000 --> 46:36.000]  Тут я вам покажу пример.
[46:36.000 --> 46:46.000]  Вот здесь будет один граф с циклом.
[46:46.000 --> 46:50.000]  Такой цикл.
[46:50.000 --> 46:59.000]  И у него какие-то есть ответвления.
[46:59.000 --> 47:01.000]  Вот так.
[47:01.000 --> 47:04.000]  Это граф с циклом.
[47:04.000 --> 47:09.000]  Еще есть дерево.
[47:09.000 --> 47:25.000]  Какое-то такое дерево.
[47:25.000 --> 47:29.000]  Ну, неважно. Я не очень большое рисую.
[47:29.000 --> 47:41.000]  Вот этот цикл, то, что я написал, у нас унициклический граф.
[47:41.000 --> 47:44.000]  И один граф дерева.
[47:44.000 --> 47:50.000]  Теперь мы возьмем и начнем эти графы обходить.
[47:50.000 --> 47:53.000]  И обходить по правилам левой руки.
[47:53.000 --> 47:55.000]  То есть каждый раз будем поворачивать налево.
[47:55.000 --> 48:01.000]  Я пока неформально говорю, что левой руки на картинке видно.
[48:01.000 --> 48:05.000]  Это в общем виде не очень понятно.
[48:05.000 --> 48:09.000]  Давайте я тут какую-нибудь стрелочку поставлю.
[48:09.000 --> 48:14.000]  В начале направление обхода.
[48:14.000 --> 48:18.000]  Вот так мы начинаем обходить.
[48:18.000 --> 48:26.000]  Обходим так потихоньку.
[48:26.000 --> 48:35.000]  Обходим.
[48:35.000 --> 48:53.000]  Вот так вот обходим потихоньку.
[48:53.000 --> 49:05.000]  Так он в конце.
[49:05.000 --> 49:13.000]  Давайте аккуратно сделаем.
[49:13.000 --> 49:31.000]  Так вот обходим.
[49:31.000 --> 49:34.000]  Все, обошли.
[49:34.000 --> 49:43.000]  А тут тоже обходим.
[49:43.000 --> 50:04.000]  Тоже каждый раз поворачиваем налево.
[50:04.000 --> 50:06.000]  Вот, ну уже видно.
[50:06.000 --> 50:24.000]  Можете представить, чем закончится.
[50:24.000 --> 50:38.000]  Можно увидеть одно кардинальное отличие.
[50:38.000 --> 50:41.000]  Слева то, что у нас справа.
[50:41.000 --> 50:44.000]  Справа мы каждое ребро прошли два раза.
[50:44.000 --> 50:47.000]  Один раз в одну сторону.
[50:47.000 --> 50:50.000]  Вот так вот.
[50:50.000 --> 50:57.000]  Один раз в другую сторону.
[50:57.000 --> 51:07.000]  Слева некоторые ребра, ребра которые в цикле, мы прошли только один раз.
[51:07.000 --> 51:09.000]  Отсюда что получается?
[51:09.000 --> 51:19.000]  Отсюда получается, что справа у нас число шагов в два раза больше, чем число ребер.
[51:19.000 --> 51:24.000]  Потому что мы каждое ребро прошли один раз в одну сторону, два раза в другую сторону.
[51:24.000 --> 51:30.000]  Слева у нас число шагов меньше, чем удвоенное число ребер.
[51:30.000 --> 51:44.000]  Ну вот это как раз ключевая идея.
[51:44.000 --> 51:49.000]  Есть вообще эквалентное определение дерева.
[51:49.000 --> 52:12.000]  Эквалентное определение дерева, что это граф, связанный граф на N-вершинах, у которого N-1 ребро.
[52:12.000 --> 52:40.000]  И как раз подсчитать число ребер, нужно завести счётчик и с ним работать.
[52:40.000 --> 52:43.000]  Но связанность остаётся.
[52:43.000 --> 53:04.000]  Вместо связанности будем проверять, что обход определённого вида
[53:04.000 --> 53:25.000]  делает 2n-2 шага, прежде чем вернуться на исходное ребро.
[53:25.000 --> 53:28.000]  Вернуться, то есть пройти вторично.
[53:28.000 --> 53:38.000]  Эти картинки существенно опираются на планарность.
[53:38.000 --> 53:57.000]  В примерах обход проводился по правилу левой руки, но без планарности непонятно, откуда его взять.
[53:57.000 --> 54:07.000]  Поэтому вместо этого мы будем считать так.
[54:07.000 --> 54:36.000]  Значит, заменим такое правило, что если после ребра Ij идём по ребру jk
[54:36.000 --> 55:03.000]  где k – это вершина с минимальным номером, которая больше i, в которой есть ребро.
[55:03.000 --> 55:10.000]  При этом тут имеется в виду порядок по циклу.
[55:10.000 --> 55:38.000]  То есть k минимальное в ряду i плюс 1, i плюс 2 и так далее, n потом 1, 1 и так далее.
[55:38.000 --> 55:45.000]  В честь самой i тоже может быть, если там никаких других вершин нет.
[55:45.000 --> 56:13.000]  В частности, если j – висячая вершина, то после ij будет jj.
[56:13.000 --> 56:31.000]  То есть мы пройдём туда и обратно. То же самое, что мы и здесь, и здесь много раз видели.
[56:31.000 --> 56:43.000]  Проблема с этим определением такая, что оно не всегда даст такой обход, как мы хотим.
[56:43.000 --> 56:49.000]  Особенно если нет планарности.
[56:49.000 --> 56:57.000]  Давайте я покажу пример. Тут уже пример будет с номерами.
[57:19.000 --> 57:35.000]  Тут будет так.
[57:35.000 --> 57:49.000]  1, 2, 3, 4, 5 и 6.
[57:49.000 --> 57:54.000]  Вот в этом графике есть вершин, и будет сейчас 5 ребер.
[57:54.000 --> 58:00.000]  Но дерева он не будет за счёт того, что есть изолированная вершина.
[58:00.000 --> 58:03.000]  5 и 6 изолированной вершины.
[58:03.000 --> 58:15.000]  Тут будет вот такой вот ромбик.
[58:15.000 --> 58:19.000]  Теперь смотрите, что будет получаться.
[58:19.000 --> 58:38.000]  Например, мы начали с единицы и пошли в двойку.
[58:38.000 --> 58:44.000]  Дальше из двойки. Мы в двойку пришли из единицы.
[58:44.000 --> 58:48.000]  Дальше будем идти в тройку.
[58:48.000 --> 58:57.000]  Тройка минимальная, которая соединена.
[58:57.000 --> 59:11.000]  Дальше пришли в тройку из двойки, идём в четвёрку.
[59:11.000 --> 59:21.000]  Четвёрку пришли из тройки, но должны уйти в двойку.
[59:21.000 --> 59:40.000]  Дальше в двойку пришли из четвёрки, следующий по циклу единицы.
[59:40.000 --> 59:54.000]  Уходим в единицу.
[59:54.000 --> 01:00:05.000]  Теперь пришли из двойки, уходим в тройку.
[01:00:05.000 --> 01:00:15.000]  Теперь в тройку пришли из единицы, следующая двойка.
[01:00:15.000 --> 01:00:22.000]  Пришли из тройки, следующая четвёрка, уходим сюда.
[01:00:22.000 --> 01:00:29.000]  Пришли из двойки, следующая тройка, уходим сюда.
[01:00:29.000 --> 01:00:34.000]  Наконец, пришли из четвёрки, следующий по циклу единицы.
[01:00:34.000 --> 01:00:39.000]  Соответственно из тройки уходим вот сюда.
[01:00:39.000 --> 01:00:42.000]  После этого продолжается цикл.
[01:00:42.000 --> 01:00:47.000]  Видно, что здесь мы вдоль каждого ребра прошли два раза.
[01:00:47.000 --> 01:00:52.000]  Одни раз в одну, другой раз в другую сторону.
[01:00:59.000 --> 01:01:09.000]  Хорошо.
[01:01:09.000 --> 01:01:26.000]  В чём тут отличие?
[01:01:26.000 --> 01:01:31.000]  Дело в том, что в любом случае в таком обходе
[01:01:31.000 --> 01:01:41.000]  каждое ребро не может встретиться больше двух раз до зацикливания.
[01:01:41.000 --> 01:01:43.000]  То есть оно может встретиться один раз в одну сторону,
[01:01:43.000 --> 01:01:45.000]  другой раз в другую сторону.
[01:01:45.000 --> 01:01:48.000]  Меньше не может.
[01:01:48.000 --> 01:01:54.000]  Вот, поэтому...
[01:01:54.000 --> 01:01:59.000]  Ещё третья вещь.
[01:01:59.000 --> 01:02:14.000]  В примере слева граф не является деревом.
[01:02:14.000 --> 01:02:25.000]  Однако обход делает два и минус два шага,
[01:02:25.000 --> 01:02:44.000]  прежде чем зациклиться.
[01:02:44.000 --> 01:02:53.000]  Вот.
[01:02:53.000 --> 01:02:56.000]  Но есть ещё особенность, которая...
[01:02:56.000 --> 01:03:00.000]  Тут есть эта изолированная вершина.
[01:03:00.000 --> 01:03:08.000]  Однако в нём есть изолированная вершина.
[01:03:08.000 --> 01:03:12.000]  Соответственно, итоговый критерий такой.
[01:03:12.000 --> 01:03:27.000]  Граф является деревом, если...
[01:03:27.000 --> 01:03:30.000]  Так, первое.
[01:03:30.000 --> 01:03:41.000]  Первое, в нём n вершин и n-1 ребро.
[01:03:41.000 --> 01:03:43.000]  Второе.
[01:03:43.000 --> 01:03:53.000]  Обход по указанному правилу...
[01:03:53.000 --> 01:04:02.000]  Обход по указанному правилу возвращается на исходное ребро
[01:04:02.000 --> 01:04:09.000]  после 2n минус двух шагов.
[01:04:09.000 --> 01:04:13.000]  И третье.
[01:04:13.000 --> 01:04:31.000]  В нём нет изолированных вершин.
[01:04:31.000 --> 01:04:49.000]  Соответственно, все эти условия проверяются на логарифмической памяти.
[01:04:49.000 --> 01:04:53.000]  Так, почему?
[01:04:53.000 --> 01:04:55.000]  Ну понятно.
[01:04:55.000 --> 01:05:02.000]  Рёбра, так или иначе, должно быть, возможно легко посчитать.
[01:05:02.000 --> 01:05:08.000]  Соответственно, обход тоже понятно как делать.
[01:05:08.000 --> 01:05:15.000]  Во-первых, мы запоминаем исходное ребро.
[01:05:15.000 --> 01:05:18.000]  Вот 1-2, например.
[01:05:18.000 --> 01:05:20.000]  Мы запоминаем исходное ребро.
[01:05:20.000 --> 01:05:22.000]  До этого нам нужно два логарифма.
[01:05:22.000 --> 01:05:26.000]  Потом каждый раз мы помним предыдущую вершину, текущую вершину.
[01:05:26.000 --> 01:05:32.000]  И, соответственно, ещё перебираем все остальные, начиная со следующей.
[01:05:32.000 --> 01:05:34.000]  Ну, со следующей после вот этой.
[01:05:34.000 --> 01:05:39.000]  В общем, в таком порядке перебираем остальные и проверяем, какое из них есть ребро.
[01:05:39.000 --> 01:05:43.000]  Ну, там типа ещё нужно три логарифма.
[01:05:43.000 --> 01:05:50.000]  То есть мы помним i, помним g, и ещё нужно для перебора, соответственно, вот этих вот.
[01:05:50.000 --> 01:05:56.000]  Как только мы видим ребро, сразу переключаем.
[01:05:56.000 --> 01:06:00.000]  И так вот, там какая-то константа на логарифм нужна.
[01:06:00.000 --> 01:06:04.000]  Ну, изолированные вершины тоже легко проверить.
[01:06:14.000 --> 01:06:16.000]  Изолированные вершины тоже легко проверить.
[01:06:16.000 --> 01:06:18.000]  Просто перебираем все вершины.
[01:06:18.000 --> 01:06:20.000]  Это нужен логарифм.
[01:06:20.000 --> 01:06:23.000]  Перебираем все возможные соседи.
[01:06:23.000 --> 01:06:25.000]  Ещё логарифм.
[01:06:25.000 --> 01:06:30.000]  И, соответственно, если все проверили, а ребра нет, значит она изолированная.
[01:06:30.000 --> 01:06:33.000]  И тогда нужно отвернуть.
[01:06:33.000 --> 01:06:35.000]  Ну, и что нужно ещё сказать?
[01:06:35.000 --> 01:06:39.000]  Нужно ещё сказать, почему критерия выполняется.
[01:06:39.000 --> 01:06:59.000]  И, соответственно, если граф не является деревом, но имеет n-1 ребро.
[01:07:01.000 --> 01:07:06.000]  Значит, но имеет n-1 ребро.
[01:07:09.000 --> 01:07:14.000]  То он не связан.
[01:07:18.000 --> 01:07:23.000]  Если граф не является деревом, но имеет n-1 ребро, то он не связан.
[01:07:24.000 --> 01:07:25.000]  Вот.
[01:07:25.000 --> 01:07:34.000]  Значит, если при этом в нём нет изолированных вершин,
[01:07:37.000 --> 01:07:51.000]  то в каждой связанной компоненте строго меньше n-1 ребра.
[01:07:53.000 --> 01:08:18.000]  Ну, а обход до зацикливания проходит по каждому ребру не более двух раз.
[01:08:23.000 --> 01:08:41.000]  Как в связанной компоненте может быть строго меньше n-1 ребра?
[01:08:41.000 --> 01:08:48.000]  Ну, если вообще во всём графе n-1, а в компоненте...
[01:08:48.000 --> 01:08:53.000]  Ну, как бы вот здесь связанная компонентя столько же ребр, сколько во всём графе.
[01:08:53.000 --> 01:08:56.000]  Из-за изолированных вершин.
[01:08:56.000 --> 01:09:05.000]  Если в компоненте меньше n-1 ребра, то это несвязанная компонента.
[01:09:05.000 --> 01:09:11.000]  Нет, n-1 – это от всего графа.
[01:09:11.000 --> 01:09:17.000]  N – это число числов во всём графе, а связанный компонент – это отдельный кусок.
[01:09:17.000 --> 01:09:18.000]  Вот.
[01:09:18.000 --> 01:09:21.000]  Обход до зацикливания проходит по каждому ребру не более двух раз.
[01:09:21.000 --> 01:09:34.000]  Соответственно, общее число шагов будет меньше, чем 2n-2.
[01:09:34.000 --> 01:09:40.000]  То есть получается, что если первое и третье выполнено, то тогда второе не выполнено.
[01:09:40.000 --> 01:09:55.000]  То есть если граф не дерево и выполнено условие 1 и 3, то не выполнено условие 2.
[01:09:55.000 --> 01:10:02.000]  То есть все сразу выполнены быть не могут.
[01:10:02.000 --> 01:10:05.000]  Вот.
[01:10:05.000 --> 01:10:24.000]  Ну и дальше нужно ещё доказать, что если граф является деревом, то все три условия выполняются.
[01:10:24.000 --> 01:10:33.000]  Ну да, кстати, тут ещё нужно сказать, что n больше одного.
[01:10:33.000 --> 01:10:42.000]  Если n больше одного, если n равно единице, то это всё тривиально.
[01:10:42.000 --> 01:10:45.000]  Если граф реализируется, то все три условия выполняются.
[01:10:45.000 --> 01:10:55.000]  Так, ну соответственно, первое мы знаем из дискретного анализа, третье тоже очевидно.
[01:10:55.000 --> 01:10:58.000]  Первое и третье.
[01:10:58.000 --> 01:11:00.000]  Ну, давайте я пишу так.
[01:11:00.000 --> 01:11:06.000]  Первое известно, третье очевидно.
[01:11:06.000 --> 01:11:07.000]  Вот.
[01:11:07.000 --> 01:11:12.000]  А второе нужно доказать.
[01:11:12.000 --> 01:11:15.000]  Да, значит, условие 2.
[01:11:15.000 --> 01:11:25.000]  2 доказывается по индукции.
[01:11:25.000 --> 01:11:29.000]  Ну, можно примерно сделать так.
[01:11:29.000 --> 01:11:34.000]  Можно, например, начать с висячей вершины.
[01:11:34.000 --> 01:11:45.000]  Начнём с висячей вершины.
[01:11:45.000 --> 01:11:52.000]  Это тоже хорошо известный факт, что в любом дереве есть висячая вершина.
[01:11:52.000 --> 01:12:03.000]  Ну а дальше из другого конца, из соединённой с ней вершины, может выходить некоторое количество поддерев.
[01:12:03.000 --> 01:12:26.000]  Да, значит, тут есть какое-то, так, нет.
[01:12:26.000 --> 01:12:32.000]  Значит, тут есть какое-то, так сказать, дерево.
[01:12:32.000 --> 01:12:37.000]  Первое, да, значит, какое-то.
[01:12:37.000 --> 01:12:40.000]  Дерево второе.
[01:12:40.000 --> 01:12:43.000]  И какое-то дерево третье, например.
[01:12:43.000 --> 01:12:47.000]  Ну и в принципе, конечно, более может быть больше.
[01:12:47.000 --> 01:12:55.000]  Вот, а смотрите, да, как бы вот, например, они нумируются.
[01:12:55.000 --> 01:13:00.000]  Да, тут есть какой-то циклический порядок.
[01:13:00.000 --> 01:13:15.000]  Давайте я таким цветом обозначу циклический порядок.
[01:13:15.000 --> 01:13:21.000]  Ну, в смысле, это порядок номеров вот этих вот вершин, которые вот с этой связаны.
[01:13:21.000 --> 01:13:23.000]  Значит, вот эта вот висячая.
[01:13:23.000 --> 01:13:27.000]  Значит, дальше там вот эта вот, вот эта вот, вот эта вот, так далее.
[01:13:27.000 --> 01:13:35.000]  Так, но дальше смотрите, получается, что вот к этой вершине смежной, да, значит,
[01:13:35.000 --> 01:13:54.000]  к смежной с ней, с ней свисячей, к смежной с ней присоединено несколько деревьев.
[01:13:54.000 --> 01:14:00.000]  Значит, в каждом из них.
[01:14:00.000 --> 01:14:17.000]  Ну, соответственно, да, значит, в которых, значит, в которых эта смежная является висячей.
[01:14:17.000 --> 01:14:30.000]  Значит, в каждом из них, по предположению индукции, по предположению индукции,
[01:14:30.000 --> 01:14:48.000]  обход пройдет по каждому ребру дважды, прежде чем вернется в исходную.
[01:14:48.000 --> 01:15:04.000]  Ну, а соответственно, вернувшись, вернувшись, да, значит, по нашему правилу, перейдет в следующее дерево.
[01:15:04.000 --> 01:15:28.000]  И, соответственно, только обойдя все деревья, путь вернется в самую первую вершину.
[01:15:28.000 --> 01:15:37.000]  Ну вот, то есть мы идем сюда, следующий панель, наверное, вот это, поэтому он идет сюда и начинает обход вот этого дерева,
[01:15:37.000 --> 01:15:45.000]  возвращается сюда, потом, по правилу, приходит вот в эту вершину, соответственно, дальше обходит вот это вот под дерево,
[01:15:45.000 --> 01:15:54.000]  возвращается сюда, идет сюда, обходит вот это вот под дерево, возвращается, только потом идет обратно сюда.
[01:15:54.000 --> 01:16:06.000]  Ну вот, с какого ребра начинать, это, в принципе, не важно, но, в принципе, можно на логарифмической памяти и висячей вершины тоже искать.
[01:16:06.000 --> 01:16:17.000]  Вот. Ну что, понятны конструкции, есть какие-нибудь вопросы?
[01:16:17.000 --> 01:16:31.000]  Да, отлично. Так, ну ладно, значит, у меня остается 5 минут, так что я только кратко анонсирую, что будет в следующий раз.
[01:16:31.000 --> 01:16:40.000]  Значит, по всей видимости, в следующий раз будет очным, но еще сейчас дождемся официального объявления именно от Fistech.
[01:16:40.000 --> 01:16:53.000]  Вот. Значит, NL. NL означает недetermинированная логарифмическая память.
[01:16:53.000 --> 01:17:04.000]  Да, то есть получается, что есть разные возможные варианты следующего хода.
[01:17:04.000 --> 01:17:15.000]  И если какой-то путь будет в принимающую вершину, то у нас лежит наш вход в языке.
[01:17:15.000 --> 01:17:23.000]  Значит, если нет ни одного, то, соответственно, машина в целом отвергает вход.
[01:17:23.000 --> 01:17:33.000]  Так, значит, ну и там есть классическая задача. Это путь уже в ориентированном графе.
[01:17:33.000 --> 01:17:43.000]  Значит, путь в ориентированном графе. Ну и идея такая, что вот у нас есть... почему это лежит в NL?
[01:17:43.000 --> 01:17:50.000]  Потому что, смотрите, если есть вообще какой-то путь, то есть путь, с которым длина не больше, чем число вершины в графе.
[01:17:50.000 --> 01:17:58.000]  А тогда мы можем запустить цикл следующего вида. Значит, у нас есть текущая вершина и предыдущая.
[01:17:58.000 --> 01:18:08.000]  Или даже есть просто текущая вершина. Текущая вершина, мы перебираем все возможные варианты следующей вершины.
[01:18:09.000 --> 01:18:15.000]  Ну, можно даже сказать так. Мы перебираем вообще все вершины.
[01:18:15.000 --> 01:18:26.000]  То есть из текущей мы перебираем все вершины. Если в вершину, которую мы сейчас рассматриваем, есть ребро из текущей,
[01:18:26.000 --> 01:18:32.000]  что значит перебираем? Недетерминированно. То есть берем недетерминированную какую-то еще вершину.
[01:18:32.000 --> 01:18:44.000]  Если в какую-то еще вершину есть ребро из текущей, то мы, соответственно, по этому ребру переходим, и у нас новое рассмотренное будет текущей.
[01:18:44.000 --> 01:18:56.000]  Если у нас вершины нету вообще, то мы, например, сразу говорим нет.
[01:18:57.000 --> 01:19:08.000]  Тогда если какой-то путь есть, то будет вариант, что мы каждый раз берем вершину доли этого пути и в итоге приходим, куда нам нужно.
[01:19:08.000 --> 01:19:17.000]  Вот это базовая задача из NL. Дальше у нас будет две больших теоремы.
[01:19:17.000 --> 01:19:25.000]  Мне бы хотелось очень успеть их обе в следующий раз пройти. Может быть, какие-то вещи я буду пропускать, оставлять на семинара.
[01:19:25.000 --> 01:19:39.000]  Одна теорема о том, что NL равняется ко NL. То есть доказывать отсутствие пути можно тоже. На логографической памяти недетерминированно.
[01:19:39.000 --> 01:19:49.000]  Вторая теорема, что эта задача о пути будет полной в этом классе NL.
[01:19:49.000 --> 01:19:55.000]  Это почти очевидно, если вспомнить все наши разговоры про конфигурационный граф.
[01:19:55.000 --> 01:20:05.000]  Потому что в конфигурационном графе как раз и был разговор о том, есть путь от начальной вершины до принимающей или нет такого пути.
[01:20:05.000 --> 01:20:17.000]  Вот такой анонс. Тогда получается до следующего раза. Если больше нет вопросов, то спасибо за внимание.
