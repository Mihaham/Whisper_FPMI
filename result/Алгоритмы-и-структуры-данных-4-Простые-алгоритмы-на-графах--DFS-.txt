Добрый вечер, давайте начинать. Мы закончили более-менее с динамикой, переходим к графам,
до конца семестра у нас будут графы. Мы их многократно уже на самом деле затрагивали,
в этом семестре и в прошлом. Давайте немножко формализую, что мы хотим. Ориентированный граф
это следующее. Формально это просто пара из двух множеств В и Е, где В это произвольное
конечное множество, а Е это какое-то подмножество из декартового квадрата В на В. Дальше,
если я буду элементы множества В называть вершинами, рисовать их точечками, а элементы
множества Е представлять как какие-то стрелки из первого элемента пары во второй, то можно,
например, нарисовать какой-нибудь вот такой вот граф. Граф на четырех вершинах, давайте скажем,
на пяти ребрах. Ну и вот если есть какая-то ориентированная стрелочка из одной вершины
в другую, значит такая пара, скажем, пара три-четыре, лежит в множестве ребер. Формально для такого
графа Е это просто все вот эти пары, которые соответствуют стрелочкам. Значит один-два первая
пара, один-четыре, четыре-два, два-три, три-четыре. Вот это ориентированный граф, когда у всех ребер
есть ориентация, то есть каждый ребро это на самом деле стрелочка из одной в другую. И формально это
значит, что у нас пары упорядоченные. Откуда-куда ведет ребро. Росовое определение это неориентированный
граф. Это то же самое, когда ребра у вас соответственно неориентированная. С точки зрения пары,
это значит, что пара у вас не упорядоченная. Как обычно неориентированный граф это пара В.Е,
где В по-прежнему это конечное множество, а Е, я так напишу, под множество CСВ по 2. Где ССВ по 2
это всевозможное двуэлементное под множество множество В. То есть я из вот этого множества
могу выбрать любые два элемента, взять двуэлементное под множество, и любое такое
двуэлементное под множество может выступать ребром нашего графа. Ну и соответственно, если я
Если я здесь, в этом графе, затру все стрелочки, то получу другой уже неориентированный граф.
Вот и формально множество ребер здесь.
Ну, поскольку у меня ребра теперь неориентированные,
каждый ребро, на самом деле, тогда неупорядоченная пара.
И здесь у меня E – это уже множество из таких пар.
Значит, 1, 2, 1, 4.
Ну, то же самое, только уже я пишу не пары, а двуэлементное множество.
Ну, это же не число, а множество.
Если вы до этого определяли C из множества по 2, то, наверное, так и определяли.
Я вот так определяю.
C из множества по k – это всевозможные коэлементные подношения в этом множестве.
Ну, я думаю, все с этим знакомы.
Значит, определение пути, цикла и так далее я давать не буду.
Они все очень интуитивные.
Да, путь – это когда можно просто вот так вот по стрелочкам пройти
и попасть из одной вершины в другую.
Там тут то же самое.
Цикла – это когда вы начали в одной вершине и закончились в ней же.
То есть это такой путь, чтобы заканчивать там же, где начали.
Вот.
Ну, что-то такое.
Значит, сегодня самый простой алгоритм у нас будет DFS.
Давайте сразу его напишем.
Значит, алгоритм DFS расшифровывается как поиск в глубину или depth first search.
Значит, он работает следующим образом.
Ну, интуитивно он просто – это рекурсивный алгоритм,
который при запуске из какой-то определенной вершины
рассматривает все возможные исходящие из нее ребра
и пытается пойти вдоль тех ребр, которые ведут его в новое, еще не посещенное вершина.
То есть алгоритм DFS просто хочет обойти весь граф,
ну и там не знаю, что-нибудь в них записать,
понять, какие вершинки он посетил, какие не посетил.
И DFS просто берет и смотрит на список всех исходящих ребр
из данной вершины, где он находится,
выбирает из них то, которое ведет в первую, не посещенную вершину
и рекурсивно запускается от вот этой вот вершинки, куда он может перейти.
Дальше что-то там здесь обходит,
рекурсия отсюда завершается, поднимается наверх
и берется следующее вершина, ну как бы следующий сосед,
точнее следующее ребро, которое ведет в новую, не посещенную вершину.
И так далее, пока просто есть не посещенные соседи,
мы в них переходим.
Вот, ну давайте это напишем,
с какой-то степенью точности.
Во-первых, я буду считать, что граф у меня будет храниться,
скажем, в векторе векторов.
Ну я вот так вот напишу.
В том понимании, что для каждой вершины V
у меня будет список всех ее соседей.
То есть у меня для каждой вершинки V
будет в векторе G с индексом V хранится список всех ее соседей,
то есть всех тех товарищей, куда можно попасть за один шаг из V.
Это просто список всех соседей.
То есть то, куда есть ребра из вершинки V.
Что еще?
Ну вроде все.
Значит, я как-нибудь веду вспомогательные массивы.
Давайте тоже пусть у меня будет массив parent,
у меня будет массив color,
массив ta-in, массив ta-out.
Вот это будут какие-то массивы,
которые индексированы номерами вершин.
Да, я буду считать еще, что у меня вершины,
это просто целый число от нуля до минус одного
для удобства.
Ну чтобы у них были простые номера,
чтобы можно было обращаться, скажем, parent тот V,
это родители вершины V.
Сейчас я объясню, что это все такое.
Вот, значит, алгоритм будет работать следующим образом.
Давайте сначала покрасим все вершины в белый цвет.
И в момент, когда мы заходим в вершинку,
будем красить ее в серый.
Серый значит, что она сейчас в обработке.
И мы будем красить ее в серый.
И мы будем красить ее в серый.
И мы будем красить ее в серый.
А когда заходим в вершинку,ela,
будем красить ее в серый.
Серый значит, что она в обработке.
Мы сейчас пытаемся из нее что-то найти.
Мы пытаемся из нее рассмотреть все ребра.
Когда заходим, мы красим ее в серый.
И в конце, когда мы уже все обошли,
когда рекурсия из вершинки V завершилась,
мы обошли все, что потенциально можно было.
Мы говорим, что окей, мы эту вершинку закрываем
и красим ее в черный.
Белый, значит, мы еще к ней вообще не прикасались,
находится в процессе обработки. Мы на нее смотрим и перебираем ребра из нее.
Черные, когда мы ее полностью обработали, и больше вообще туда не смотрим. Когда мы
обошли все, что из нее достижимо. Ну, примерно так. Вот. TNT out это моменты
времени входа и выхода в вершину. Давайте запишу, что это моменты времени. Нам понадобится
это чуть позже. Я их сразу сейчас веду. Моменты времени входа и выхода в вершину.
Ну, у нас алгоритм какой-то такой итеративный. Он пришел в одну вершину, пришел в другую, в третью,
в четвертую и так далее. В какой-то момент он больше из вершины никуда пойти не может.
Говоришь, что окей, я из нее выхожу. То есть у меня формально рекурсия просто в данной
вершине завершается, потому что больше идти некуда. Рекурсия завершается, мы говорим,
из вершины выходим. Красим ее в черный цвет и поднимаемся по стеку рекурсии наверх. Дальше мы
отмечаем, когда мы зашли в вершину, когда мы вышли из вершины. Когда рекурсия, соответственно,
попала в V, когда она из нее вышла. Ну и давайте это напишем. Давайте какой-нибудь DFS,
который принимает вершину V, работает примерно так. Во-первых, мы вошли в вершину. Когда мы в нее
входим, мне нужно поменять у нее цвет. Во-первых, мы говорим, что мы в нее вошли и сразу цвет
становится серым. Давайте так и напишу. Давайте по-английски напишу, не по-русски. Мы говорим,
что у нее цвет серый. Дальше мы говорим, что мы в нее зашли и время входа в нее это вот какой-то
текущее время. Вот пусть таймер это текущий таймер времени. Ну и я его сразу увеличу,
чтобы следующие события происходили в следующие моменты времени. Я напишу вот так вот. Таймер
плюс-плюс. Значит, якобы таймер положил сюда и сам таймер увеличил на единичку. Следующие события
уже происходят в следующие моменты времени. Я время увеличил. Я зашел в вершину, нажал счетчик,
время увеличилось. Так, все. Теперь я просто перебираю всех соседей. То есть все возможные
вершины, куда можно перейти из данной. Это просто все возможные элементы списка ГОТВ. И теперь я
от них запускаюсь рекурсивно, но только в случае, если они белые. Только в случае, если я их еще
вообще не видел, если это новые вершинки, то я от них буду запускаться. Потому что если я в них
уже был, если они уже серые или черные, то нет смысла еще раз идти туда же. У меня и так там DFS
уже либо и так работает сейчас, либо уже вообще отработал. Поэтому запускаться еще раз с DFS от
серых или черных вершин я не буду. Я запускаюсь только от белых. Поэтому я пишу, что если color2
не white, то я ее просто скипаю, делаю continue. Вот, а иначе запускаюсь рекурсивно. Ну давайте,
давайте я так, давайте еще вот здесь допишу, что parent от tu равно v и перейду рекурсивно в вершинку
tu. Parent будет для каждой вершины говорить из какой вершины я в нее пришел. То есть если я вот сейчас
иду вдоль ребра из v в tu, то я для вершинки tu записал, что ее parent является v. Ну просто
родительская вершина в этом обходе. Все, то есть я буквально просто обхожу все, что можно по всем
белым, по всем белым вершинкам. Это я обошел всех сосей и теперь у меня это все завершилось. Надо
выйти из рекурса и поместь, что вершина, вершина пройдена. Значит для этого мне нужно у нее проставить
черный цвет и сказать, что я из нее вышел в данный момент времени. Поэтому я пишу просто color
от v это black и видимо tu от v равно тоже timer++. То есть вот в тот момент времени, когда я сюда пришел,
я кладу в tu от v этот таймер и увеличу его, потому что все остальные события происходят в следующий
момент времени. Вот вроде весь DFS. Вот такой простой код, ну который в каком-то смысле жадно
просто идет туда, куда можно. Идет туда, куда есть смысл. Понятно, нет смысла идти туда,
где мы уже были, вот. А там, где мы не были, просто давайте туда пойдем вот такой рекурсией. Видит
первую попавшуюся вершину, идет туда. Вот, значит оказывается, что здесь ну удобно сформулировать
следующую лему, называется лема о белых путях, которая что-то говорит о работе DFS.
Давайте я сейчас скажу, что я живу в случае ориентированного графа. Пока что у меня все
ребра ориентированные и все вот здесь вот тоже происходит в ориентированном мире. Поэтому я здесь
напишу, что граф уже ориентированный. Про неориентированный мы как-нибудь попозже поговорим.
Лема такая. Вот давайте рассмотрим момент времени tu от v. Моменты входа и выхода из вершинки v. Вот
что происходит за то время, пока мы как бы обрабатываем вершину v. То есть за время от входа в
нее до выхода из нее. Кого мы посетим? Что вообще изменится в график, там какие вершинки поместятся
посещенными, у каких поменяются цвета и так далее. Я утверждаю, что за этот промежуток времени произведет
ровно следующее. Для любой вершинки v за время от tu от v, то есть от входа v до tu от v алгоритм
посетит все вершины, достиженные по белым путям из v и больше никого не посетит. И только их.
Вот, то есть если к моменту времени входа v, к моменту времени входа здесь был какой-то
полностью белый путь, то есть путь по исключительно белым вершинкам, вот если здесь все были белые на
этом пути, то тогда к моменту времени выхода из v все эти вершинки посетятся, то есть от них
вот всех запустится dfs, они все перекрасятся в черный и никаких других вершин в черный не перекрасится.
То есть вот если здесь был белый путь, давайте я их dubly v-шками обозначу, white, если не все
были белые, то они становятся черными. Вот, и никаких других вершин я не посещу, никаких
других вершин за вот это вот время, за промежуток времени вот это вот, я никаких других вершин не
увижу. Давайте попробуем доказать. Ну, смотрите, с одной стороны понятно, что ничего другого
за это время я точно не увижу, потому что что происходит в момент времени с этого поэта?
Вот я был в вершинке v, вот я в нее когда-то впервые зашел, потом я что-то делаю и рано или поздно я
запускаю, точнее завершаю рекурсивный запуск dfs от v, но понятно, что за это время я только спускался
по каким-то ребрам, да и запускал dfs рекурсивно только от тех вершин, в которые вело ребро,
поэтому максимум, что я мог посетить, это какие-то вот такие вот пути ведущие из v, вот что-то такое я
мог делать, но понятно, что никакие другие вершины недостижимые из v по путям я достичь не мог,
так dfs работает, он идет только по ребрам, как бы да, по ребрам вот из текущей вершины. Ну и с другой
стороны, если вдруг что-то было достижимое и оно было, скажем там, серое или черное, то в них я
тоже не зайду, потому что dfs не заходит в небелые вершины, он запускается только от белых вершин.
Поэтому вот эта вот часть про и только их, она более-менее очевидна, ничего другого мы посетить не
можем. Давайте запишем это, что других вершин посетить не могли. Вот, теперь почему посетим все,
что нужно? Ну, давайте подумаем. Значит, во-первых, давайте поймем вообще, что представляют у себя
серые вершины в какой-либо момент времени. То есть белые, черные есть серые. Вот что такое серые? Вот
если я алгоритм в какой-то момент остановлю, заморожу картинку, посмотрю какие вершины являются
серыми, то на самом деле легко понять, что они образуют сплошной путь и они все лежат на стеке
рекурсии. Вот если вот эти товарищи все серые, то они как раз образуют путь и они все лежат
в стеке рекурсии. Образуют путь и лежат на стеке рекурсии. Ну почему? Потому что вот когда-то
ДФС там запустился от какой-то вершины, от стартовой вершины он запустился, пометил ее серой,
потом куда-то спустился, покрасил ее серой опять-таки. Если он дальше куда-то спускается и пометил что-то
серое, то значит он опять спустился по ребру. Ну и так далее. А если внезапно он пытается из вершины
пойти там, то есть если он что-то обошел и пытается пойти дальше, скажем, вот он эту ветку обошел и
потом переходит в какую-то новую вершинку. Значит, к моменту перехода все эти уже будут черные,
потому что я когда завершаю рекурсивный вызов, я перекрашиваю серой в черную. Поэтому у меня всегда
на стеке рекурсии будут как раз вот последовательность серых вершин на пути. Понятно
же это? Ну вот, значит получается, что с серыми все более-менее понятно. Это какой-то стек
рекурсии, пусть вот это вот В. Ну тогда понятно, что при моменте входа в нее,
у меня граф просто вот такой, больше ничего нет. Ну точнее стек рекурсии вот такой. То есть это
последняя рассмотренная вершина, она лежит на стеке рекурсии. К моменту времени выхода из нее
стек тоже будет такой, потому что мне нужно ее будет из стека удалить, стек будет пустой. Значит,
никаких других серых вершин к моменту времени выхода не появится. Мораль такая, что от, ну точнее
не так, да? К моменту Та от В новых серых не появляется. Новых серых не появляется.
Потому что это стек, да, я из вот этого состояния вернулся к нему же, потому что я зашел, когда
захожу в В у меня было такое состояние стека, когда выхожу тоже должно было быть такое, чтобы я В
удалил. Поэтому других серых не появилось. Могли появиться, значит, только черные. Вот. Хорошо.
Значит, что теперь я хочу? Я хочу доказать утверждение вот этого, да, что алгоритм пустит все
вершины, достижимые по белым путям. Давайте доказывать. Вот есть В. Давайте пойдем от противного,
пусть нашелся какой-то путь по белым вершинам, на котором не все вершины покрасились в черный.
Ладно, сейчас пойду от противного. Пусть есть какой-то путь, который в момент времени входа в В был
полностью белый, то есть все вот эти вот товарищи были белые. И пусть к моменту времени выхода из В
он не весь черный, то есть я его не весь посетил. Понятно, серыми они стать не могли, потому что
стек-рекурс у меня сохранился, они не могут быть серые в момент времени выхода, но кто-то из них
может быть черным, а кто-то может остаться белым. Так вот, давайте тогда посмотрим самую глубокую,
оставшуюся белой. Пусть это будет какая-нибудь У. Пусть У, самая глубокая на этом пути, самая
глубокая, оставшаяся белой. Ну, для нее тогда что-то точно пошло не так, потому что если У была
белой и осталась белой, то родители ее, вот это вот да, Parent Tattoo, как раз предыдущий вершин на этом
пути, она точно превратилась в черную. Ну, потому что мы взяли как раз, наоборот, извините, самую
наименее глубокую я имел ввиду, то есть самую высокую, извините. На этом пути у меня к моменту
времени выхода из В вот эта, скажем, стала черной, эта стала черной, эта стала черной, а эта осталась
белой. Но тогда для этой вершины явно что-то пошло не так, потому что вершина перекрасилась из белого
в черный, но у нее осталось ребро, ведущее в белую вершину, то есть она как была белой, так и осталась
белой. Ну, противоречие, потому что DFS, если из вершины видит ребро в белую, он обязательно сначала
в него перейдет и только потом может перекрасить эту вершину в черный. Противоречие.
Значит, еще раз быстренько, вот если у меня был белый путь и какая-то вершина не перекрасилась
в черный, давайте возьмем самую высокую, такую не перекрасилась в черный. Вот эти все перекрасились
в черную, а эта осталась белой. Но тогда для вот этой вершины что-то пошло не так. Ну, как бы
алгоритм DFS так не мог работать, что он перекрасил одну вершину из белой в черную, а вершину в
которой есть ребро оставил белой, потому что в момент рассмотрения вот этой вершинки он обязательно
должен был просмотреть это ребро и, значит, запуститься рекурсивно отсюда. Противоречие.
Тут утверждение как бы для какого-то тривиального алгоритма, но оно нам будет несколько раз нужно,
поэтому я его в общей строгости доказываю. Отсюда следует две вещи. Из этой леммы следует два
факта. Во-первых, простой факт, который так был более-менее очевиден, это следующее, что если мы
изначально покрасим весь граф в белый цвет, все вершины в белый цвет и запустимся DFS от какой-то
старта вершинки S, то тогда к моменту завершения DFS мы обойдем в точности все, что было достижимо
в принципе. Если изначально все вершины белые, то после, давайте так, то DFS от S пометит черными
все достижимые из S вершины. Ну понятно, просто лемма в белых путях, потому что все, что достижимо,
оно достижимо по белым путям, значит будет объединено DFS и будет перекрашено в черный.
Ну и второе следствие, чуть более уже интересное, это проверка графа на
оцикличность и поиск цикла. Следствие второе. Ну опять, я считаю, что все вершины у меня изначально
покрашены в белый цвет. Вот, значит тогда я утверждаю, что DFS от S находит ребров серую вершину,
если и только если в исходном графе есть цикл достижимый из S.
То есть какая-то вот такая картинка, вот если есть цикл, то мы его обязательно найдем. Вот,
значит есть ребро, находит ребро в серую вершинку, но вот здесь, смотрите, мы перебираем все ребра графа,
вот если в этот момент времени я вижу ребро из VF2 и 2 при этом серое, то есть вот здесь вот,
ну по факту, когда я просто перебираю все ребра, если я вижу ребро в серую вершинку,
то есть если вот здесь добавлю условия, если color of 2 равно gray, тогда я нашел цикл.
Вот если в этот момент времени color of 2 серый, тогда найден цикл. Вот, ну почему? Почему? Смотрите,
слева-направо более-менее просто. Почему, если DFS от S нашел ребро в серую вершину,
то обязательно есть цикл? Скажите, пожалуйста. Ну да, потому что у меня серые вершины образуются
так рекурсии и при этом путь. На все серые вершины обязательно путь. Если я из текущей вершины V
внезапно увидел ребро в серую, значит я обязательно нашел ребро в какую-то из вершины этого пути,
значит я замкнул цикл. Если я увидел ребро, то я точно нашел цикл. Ну теперь надо обратно показать,
что если цикл есть, то обязательно найду его таким образом. Да, ну поэтому я говорю,
что цикл достижимый из S. Так, обратно. Пусть есть цикл достижимый из S, давайте его нарисуем.
Вот такой вот он есть. Я хочу показать, что я в каком-то смысле его найду. То есть что я
найду какое-то ребро в серую вершину хоть когда-то. Ну, смотрите, давайте вот в этом цикле,
который в нашем графе присутствует, давайте возьмем вершину с минимальным TEIN. Я так буду
несколько раз делать за сегодня. Среди интересующих меня вершин давайте найдем вершину с минимальным
TEIN. Пусть, скажем, U это вершина цикла с минимальным значением TEIN от U. Где-то вот она здесь есть.
Ну потому что, вообще говоря, непонятно, какую именно из вершин цикла я найду в первую очередь.
Потому что, да, у меня есть какой-то цикл, но совершенно необязательно, что DFS ровно вот по этому
пути пойдет и в таком порядке их посетит. Он, например, мог пойти как-то вот так. Я же не говорю,
что нет других ребер. Они вполне себе могут быть. DFS, поскольку я здесь никак не специфицирую,
как именно я, в каком порядке я обхожу ребра, может обходить их совершенно произвольно,
ну и поэтому он мог дойти до этого цикла как-то по-другому. Например, вот так. Поэтому просто из
всех возможных вершин цикла я возьму самую первую, ту, которую я впервые увижу. Ну а дальше давайте
рассмотрим вот этот момент времени TEIN на ТУ. В этот момент времени, поскольку U это первая
вершина на цикле, все остальные еще белые. Все остальные еще не посещены, я их еще не видел,
у них больше момент времени входа. Поэтому они все еще белые, вот эти все белые. А когда я сюда
захожу, я ее перекрашиваю в серый. Ну а дальше просто левый в белых путях. У меня есть вот такой вот белый
путь. Я сказал, что все эти вершинки белые. Поэтому, в частности, к моменту времени выхода из U я вот
эти все вершины успею обойти. Я от них от всех запущу рекурсивный DFS. В частности, DFS рано или
поздно запустится вот от этой вершинки V, которая предшествовала U на цикле. То есть я от них от всех
в каком-то порядке, я не обязательно говорю, что в таком, но в каком-то порядке я запускаю DFS,
так или иначе я запущу DFS от V. Ну, значит, я увижу ребро в серую вершинку. Потому что до того, как я
вышел из U, я обязательно запустил DFS от всех этих чуваков, возможно, в каком-то произвольном порядке,
неважно. Главное, что я запустил DFS от этой вершинки, вот предыдущей вершины на цикле. И поэтому этот DFS
увидит ребро в серую вершинку. Значит, цикл будет найден. Пусть V это предыдущая вершина на цикле,
тогда по лейме DFS от V запустится раньше, чем завершится запуск DFS от U.
Давайте напишу так, запустится раньше, чем U перекрасится в черный.
Ну, это как раз значит, что мы нашли ребро в серую вершинку.
Так, окей.
Хорошо.
Тогда едем дальше.
Следующее, что я хочу сделать, это построить топологическую сортировку ациклического графа.
Ну, во-первых, обозначение в каком-то смысле. Я буду писать DAC, чтобы сказать
ориентированный ациклический граф. Ну, это так расшифровывается, directed acyclic graph на ориентированный
ациклический граф. Ориентированный ациклический, то есть без циклов, граф.
Ну, давайте скажем, представим, что мы сделали эту проверку, не нашли ребер в серую вершинку,
то есть у меня в графе нету циклов. Вот, тогда для таких графов определяется так называемая
топологическая сортировка. Топологическая сортировка, ну, вот такого графа.
То есть неформально просто скажу, это такая перестановка вершин, что все ребра идут только
слева-направо из вершин с меньшими номерами, вершин с большими номерами. То есть я могу так
изобразить вершины на кардинатной прямой, что все ребра ведут только слева-направо.
Перестановка вершин. Такая, что все ребра ведут слева-направо.
Вот, значит, ну, вообще это очень удобное представление графа, если он, конечно, циклический,
потому что, ну, вот на самом деле, когда мы говорим что-то про какие-либо динамики,
да, и пишем формулу пересчета для динамики, если построить граф вот этих вот переходов,
где вершинами выступает как раз состояние динамики, ну, скажем, там элементы массива,
а стрелочкой обозначают зависимость. То есть как мы, из каких значений мы пересчитываем
новые значения динамики. Тогда вот там как раз получается это все адекватно решать только в
случае, если граф зависимости в DP-шке у вас как раз циклический, что у вас там есть какие-то
вершины, которые определяются сами по себе, а дальше все остальные пересчитываются через то,
что вы уже посчитали. Ну, как раз в этом смысле, да, что если вы знаете, скажем,
ответ для вот этой вершинки, то для всех остальных вы ответ считаете как ответ там,
ну, завище от всех. Короче, если скажем, для этой вершинки, чтобы посчитать DP-шку,
вам нужно рассмотреть все ведущие вот сюда вот ребра, то есть те состояния, от которых это зависит.
Ну и дальше ответ как-то склеить из того, что вы здесь получили. Вот. Ну, а если вы сделали топ
сорт этого графа, то по факту вы просто знаете, что вот если слева направо идти,
то у вас каждая новая вершина будет как раз зависеть только от предыдущих, то есть в нее ведут ребра
только из предыдущих, поэтому DP-шка очень просто насчитывается, если так слева направо расположить.
Вот. Ну, не знаю, простое утверждение, давайте даже замечание это скажу, что топ сорт существует
только для дагов. Топологическая сортировка существует только для дагов, только для
ациклических графов. Ну, потому что если граф не ациклический, в нем есть цикл, то вы его никак
напрямую не расположите при условии, что в серебре ток слева направо. Если ребро идет слева направо
и есть цикл, то вам надо рано или поздно вернуться как бы справа налево, иначе цикл вы не нарисуете.
Вот. Ну и давайте построим алгоритм, предъявим алгоритм нахождения топ сорта.
Алгоритм нахождения топ сорта.
Работает он следующим образом. Сначала, как всегда, я крашу все вершины в белый цвет,
говорю, что все вершины еще чистые и не посещенные. А дальше я запускаюсь DFS,
запускаю цикл, скажем, по всем вершинам и вызываю DFS от тех вершин, которые пока что белые. Давайте
как-то так это напишу. Я перебираю все S там от 0 до N. 0 до N-1. Если она белая, то я запускаю DFS.
Если color от S пока что белый, тогда запускаю DFS. Вот. Ну и как меня уже спрашивали, граф не
обязательно связанный, поэтому, возможно, вам придется несколько раз в этом цикле от
нескольких разных S запускать DFS, потому что там могут быть какие-то просто не связанные между
собой компоненты, или, например, может быть, что-нибудь вот такое, и вы не угадали, DFS сначала
запустили отсюда, потом отсюда, потом отсюда. Ну и тогда каждый будет независимый новый запуск
из вот этого вот, ну, из внешнего цикла. Короче, этот DFS может вызваться несколько раз. А дальше
я утверждаю, что если вы просто возьмете и напишете все вершины в порядке убывания Таута,
вы получите топ-сорт. Топ-сорт – это сортировка всех вершин в порядке убывания Таут.
Я здесь могу говорить про Таут, потому что у меня DFS от всех вершин так или иначе запустились,
у каждой вершины определен правильный Таут в момент времени выхода из нее. И вот теперь,
если я посортирую по этому значению, по Таутам в порядке убывания, то у меня будет
я утверждаю корректный топ-сорт. Ну, давайте сначала скажу про время работы. Вот я тут говорю
«сортировка». На самом деле легко заметить, что все Тауты у меня очень маленькие числа. В данной
реализации максимум 2n, потому что таймер у меня увеличивается два раза на каждую вершину. Поэтому
значения Таута всегда маленькие, и сортировку можно сделать не за n-логен, а просто за линейное
время, сортировкой подсчетом, скажем. Сортировка подсчетом давайте здесь уточню, чтобы лишних
логарифмов не возникало. Сортировка подсчетом. Ну и все это суммарно будет работать за линейное время,
потому что сортировка вот этот шаг работает за линейное время. Дальше надо проанализировать,
как работает DFS. Ну понятно, мы просто запускаем DFS в худшем случае от всех вершин. Если посмотреть
на этот код внимательно, то тоже понятно, что в каждую вершину мы зайдем максимум один раз,
потому что мы заходим только в те, которые белые, и каждое ребро мы тоже просмотрим максимум один
раз, ну точнее ровно один раз, потому что мы ребро просматриваем только если мы находимся в данной
вершине сейчас. Поэтому симпатика будет линейная от числа вершин плюс число ребер, то есть от n
плюс m. Ну вот, теперь доказательства корректности. Почему то, что я делаю, такая странная
перестановка вершин является на самом деле топ-сортом. Ну для этого достаточно доказать
следующий факт, что если внезапно у вас есть в графе какое-то ребро у v, то tout для u будет больше
чем tout от v, потому что как раз это и означает, что если tout от u больше чем tout от v, то значит u в
нашей сортировке идет раньше чем v. Достаточно доказать, что если у v это ребро, то вышли из u мы
позже чем из v. Это как раз и будет означать, что вот этой нашей сортировке в обратном порядке
по tout, u будет раньше. Давайте докажем. Для этого я хочу рассмотреть два случая опять, в какую из них я
зашел раньше. Давайте сравним у них t in и разберем два случая. Первый случай, скажем, когда t in от u
меньше чем t in от v, то есть я зашел в u раньше чем v. Я зашел сначала сюда, потом в v. Почему тогда верно
вот такое неравенство на tout? Ну да, по факту это опять лемма о белых путях, потому что к моменту
времени входа в u это еще белое, к моменту времени входа в v еще белое, значит к моменту времени
выхода из u я из v тоже уже выйду. Значит я сначала вышел отсюда, только потом вышел отсюда. Значит
нужно неравенство на tout сохраниться. Опять по лемме о белых путях. ДФС от v запустится раньше
чем у станет черной. Значит я из v выйду раньше чем из u. Теперь в обратную сторону пусть t in от u
наоборот больше чем t in от v. То есть наоборот ситуация симметричная. Я сначала каким-то образом попал
в v, а u к моменту времени входа в v еще белое. Что тогда сделать? Почему верно вот это неравенство?
Ну да, можно сказать, что смотрите, у нас же граф на самом деле ациклический, значит не существует
пути из v в u. Таких пути не существует в принципе, потому что иначе был бы цикл. А значит, ну мы это
тоже формулировали, мы знаем, что из v достижимы только те, будут покрашены в черной к моменту
времени выхода, только те, которые достижимы по ребрам, по белым путям. Поскольку u недостижима
по путям, значит u не будет покрашена в черной, и к моменту времени выхода из v u вообще будет
еще даже не затронута. В этом случае, поскольку нет пути из v в u, то к моменту времени выхода из v,
то есть к моменту t out от v, u все еще будет белый. Ну а раз к моменту времени выхода отсюда
она еще будет белой, то еще только после этого мы в нее зайдем, еще после выйдем.
Значит, мне нравится, что по давным выполняются. Ну давайте тогда перерыв небольшой, продолжим потом.
Дальше мне нужно будет следующее определение. Пусть, как обычно, g это у меня ориентированный
граф. Я ввожу в следующее отношение на вершинах. Я пишу u tilde v и говорю, что u и v сильно связаны,
сильно связаны, если между ними существуют пути в обе стороны. То есть, если существует путь из
u в v и существует путь из v в u. Мне нужно требовать пути в обе стороны. Если бы я жил в неориентированном
случае, то здесь по факту просто написано определение связанности, достижимости двух вершин друг
из друга, но поскольку у меня уже ребра ориентированы, я не могу сказать, что путь от u до v является путем
от v до u, просто в обратном порядке пройдя. Поэтому мне нужно требовать, ну чтобы это было адекватное
определение, мне нужно требовать наличия пути в обе стороны. Дальше я утверждаю, что это отношение
является отношением эквивалентности. Тильда является отношением эквивалентности. Это значит,
что по этому отношению все вершины графа разбиваются на некоторые непересекающиеся куски,
на какие-то подмножества. Такие, что внутри подмножества, они все попарны друг другом,
сильно связаны. То есть, если я рассмотрю две вершины внутри одного вот такого множества,
то будут пути в обе стороны. А если я рассмотрю вершины из разных множеств, то есть из разных
классов эквивалентности, то по крайней мере в одну из двух сторон пути не будет. Скажем,
вот такого пути нет. Доказательства. Ну значит, просто по определению, чтобы доказать,
что отношение является отношением эквалентности, нужно доказать три вещи. Во-первых,
надо доказать рефлексивность. Да, это очевидно. Ну понятно, что у сильно связана сама с собой,
потому что путь из У это стоит на месте, и путь из в обратную сторону тоже стоит на месте,
ничего не делать. Значит, дальше симметричность тоже очевидна. Если У и В сильно связаны,
то В и У тоже сильно связаны, потому что у меня определение симметричное относительно перестановки
У и В. Ну и третья, значит, транзитивность. Если, скажем, У и В сильно связаны, а также В и В
сильно связаны, то почему У и В сильно связаны. Ну просто по картинке, раз есть путь из У В,
давайте его нарисуем, есть путь из В до В В. Значит, если просто их склеит, то получится один больший
путь из у В В и обратно, поскольку В и В сильно связаны, то есть вот такой вот путь, поскольку
в В и У сильно связаны все идет такой путь. Дальше, если их склеит, то получится как раз путь в
обратную сторону. Ну все, значит, реально все вершины распадаются на такие классы
эквивалентности. И вот задача – найти эти самые классы эквивалентности. Надо выделить
классы эквивалентности по этому отношению, которые также называются компонентами сильной
связности. Вот это вот все. Это компоненты сильной связности. Вот их надо выделить,
надо разбить граф на компоненты сильной связности.
Сейчас эту задачу решает алгоритм Касараю. Алгоритм Касараю
выделение компонент сильной связности. Выделение компонент сильной связности. КСС для краткости.
Он устроен следующим образом. Во-первых, я проделаю то же самое, что делал для поиска
топологической сортировки ациклического графа. Я также сначала все вершины покрашу в белый,
потом фориком запущусь ДФСом от всех белых вершин и в конце построю перестановку в порядке
убывания т-аутов. Давайте этот первый шаг также напишу. Аналогично поиску топ-сорт,
поиска топологической сортировки, так аналогично поиску топологической сортировки, получим
перестановку вершин в порядке убывания т-аутов.
Вот, а второй шаг следующий. Давайте я скажу, что давайте я вот здесь еще раз
все вершины опять покрашу в белый. Вновь красим все вершины в белый, красим все в белый.
И дальше я буду идти по вот этой перестановке, которую я получил, и запускаться ДФСом по обратным
ребрам. В порядке перестановки запускаю, я вот этого назначу, давайте ДФС реверснутая от В, где ДФС
реверснутая это как бы ДФС по обратным ребрам. То есть вот если в исходном графе у меня все
ребра имели какую-то ориентацию, были стрелочки какие-то, то ДФС реверснутый ходит наоборот по
обратным стрелкам. То есть если у меня была стрелка из У в, то он наоборот пойдет по стрелке В в стрелка
У. То есть он разворачивает все стрелки как бы и ходит уже по ним в новом графе. Я получил
какую-то перестановку, дальше я просто иду по этой перестановке в том порядке, в котором там
элементы написаны, и если вершина еще белая, то я запускаю ДФС по обратным ребрам из нее.
И я утверждаю, что то, что обойдет очередной запуск этого ДФС, это будет очередная КСС. То есть
вот когда я запускаю ДФС по обратным ребрам от вершины В, все что он посетит, обходя вот так вот
по обратным ребрам в этом графе, все что он посетит, это будет в точности его КСС. Очередная КСС.
Потом он посмотрит на следующую вершинку в перестановке, какую-нибудь У, опять по обратным
ребрам обойдет всю ее компоненту сильной связности, ну и так далее. Все вершинки пройдет. Для каждой,
если она еще белая, то есть если я еще ее ни в какую компоненту сильной связанности не отнес, то я
запускаю от нее ДФС по обратным ребрам, и он обходит всю компоненту связанности. Тем самым как раз
весь граф подразбивает на вот такие вот облачка, которые являются компонентом сильной связанности.
В первом пункте я делаю то же самое, что делал только что для поиска топ-сорта. Значит, а именно,
я крашу все в белый, потом в цикле по всем вершинам запускаю ДФС от всех вершин, ну если они
белые. И дальше сорчу все вершины в порядке убывания ТАУТ. Тот же самый топ-сорт, я не говорю,
что это топ-сорт, потому что граф может быть с циклами. Код точно такой же, да. Нет, уже может
быть граф с циклами, более того, КСС разумно находить только в случае, если граф с циклами.
Вот я говорю, аналогично поиску топ-сорта. Я не говорю, что я получаю топ-сорт, но я пишу тот же
самый код. Я крашу все в белый, потом по всем вершинам запускаю ДФС, теперь у меня все вершины
имеют какой-то свой ТАУТ. Вот давайте их посортируем в порядке убывания ТАУТ, так же, как было в топ-сорте.
Теперь я получу какую-то перестановку вершин. Я не говорю, что это топ-сорт, но эта перестановка
такая же, как строюсь в алгоритме топ-сорта. И дальше я с ней работаю вот таким вот образом.
Вот, утверждаю, что не можем, это надо доказывать, сейчас будем делать. Вот утверждается, что очередной
каждый такой запуск обойдет в точности ровно одну компонентную силу населения, ничего больше,
ничего лишнего не обойдет. Так, перед тем, как перейти к доказательству корректности, давайте
про детали всякие поговорим, несущественные. Ну, во-первых, как реализовать ДФС реверснутый,
как сделать ДФС по обратным ребрам. Ну, кажется, самое простое, это просто завести явным образом
обратный граф, где каждое ребро поменяло свою ориентацию. Если было ребро УВ, то теперь есть
ребро ВУ. И дальше этот ДФС по обратным ребрам ведет себя, как обычный ДФС, но уже в новом графе.
Когда я поменял ориентацию всех ребер, обратные стали обычными прямыми, я просто запускаю обычный
ДФС вот в этом уже новом графе, в реверснутом. Поэтому эта штука, это просто ДФС, ну, на новом
графе по факту. Обычный ДФС. И асимпточку надо еще сказать. Здесь пока что тривиальная линия,
ну, потому что здесь тривиальные проходы. Это как топсорт работает за N+, мы уже говорили,
это линия. Дальше опять ДФС по всем вершинам. Мы знаем, что суммарное время работы всех ДФС
это линия опять. Потому что каждый вершина будет просмотрена максимум один раз, точнее ДФС
в нее зашел максимум один раз. И каждый ребро просмотрен тоже один раз, потому что он просмотрен
только из одного из двух концов. Поэтому время работы здесь будет линейное. Ну вот, теперь
давайте доказывать корректность. Мне нужно доказать, что то, что я делаю, действительно находят мне все
КСС. Ну, смотрите, во-первых, понятно, что если я запустил в какое-то время ДФС от вершинки В,
то по крайней мере всю ее КСС я точно обойду. Потому что она вся, понятное дело, достижима по
ребрам из В, потому что есть пути из всех вершин В. Значит, я по обратным ребрам ее всю обойду. Вопрос
только, не обойду ли я чего-нибудь лишнего. То есть я точно обойду всю свою компоненту, потому
что она достижима по ребрам. Почему не обойду лишнего? Вот это надо только понять. Надо показать,
что ДФС по обратным ребрам от вершины В не обходит лишнего.
Вот. Ну, для этого давайте такое утверждение докажем. Пусть у нас есть две компоненты
соссетительной связности, между которыми есть ребро. Пусть есть хотя бы одно ребро из С1 в С2.
Значит, тогда верно следующее.
То есть вот есть у меня одна компонент С1 и другая С2. Пусть между ними есть какое-то
ребро. Возможно, их может быть несколько, потому что, скажем, может идти ребро отсюда сюда, отсюда
сюда, отсюда сюда и так далее. Неважно. Вот. Если есть хотя бы одно, тогда я утверждаю, что максимальный
ТА по всем вершинкам отсюда больше, чем максимальный ТА по всем вершинкам здесь. То есть, грубо говоря,
момент времени выхода отсюда больше момента времени выхода отсюда. Зачем это нам нужно? Ну вот
ровно для того, чтобы показать, что мы ничего лишнего не находим. Потому что в этом случае,
если я докажу, что при наличии ребра вот этот, что ТА вот отсюда больше, чем ТА вот отсюда,
это будет означать, что как раз вот эта вот вершина, где достигается от максимуму, вот этот В,
где достигается максимум ТАута, να в пересновке будет раньше, чем все что вот это вот. Потому что
у нее ТАут больше, чем все вот эти вот. Значит, ДФС-реверснутый сначала запустится от В и только
потом от каких-то вершин вот этой компоненты, потому что у неё ТАут чем у всех остальных. Значит,
сначала ДФС-реверснутый запустится от нее, обойдет все, что достижено по обратным ребрам. Это как раз
вот эта компонента связанности. А потом в будущем запустится от какой-то вершины из этой компоненты.
Он обойдет всю С2, но в С1 уже не пойдет, потому что там уже были.
На все эти вершины уже отнесены какой-то КСС.
Поэтому мы по этому ребру не пойдем, то есть хотя и есть вот это обратное ребро,
но мы по нему не идем, потому что они все и так уже назначены в какой-то КСС.
Окей?
Ну что, давайте доказывать.
Так, кстати вопрос, а может ли быть вот в такой картинке,
если у меня есть ребро из С1 в С2, может ли быть обратный ребро из С2 в С1?
Не может, да, потому что иначе, если бы оно было, это бы все скрылось в одну КСС,
потому что есть пути как бы и отсюда-сюда, и отсюда-сюда, они все были бы в одной КСС.
Поэтому точно таких обратных ребер нет.
Ну теперь давайте вот это вот доказывать.
Я мальчик ленивый, сделаю то же самое.
Давайте посмотрим из всех вот этих вот вершин вершину с минимальным тейном.
Среди всех вершин С1 и С2 выберем вершину с минимальным тейном.
Выберем вершину с минимальным значением тейном.
Ну опять два случая.
Откуда она, из С1 или из С2?
Пусть она в С1.
Вот, то есть Тин от Х меньше, чем Тин от всех остальных вот этих вершин.
Ну тогда вроде понятно, к моменту времени входа в Х
все остальные вершины обеих компонентов еще белые,
и более того, из Х есть пути в них вовсе,
потому что внутри компоненты сильной связанности есть все пути.
Более того, из Х можно добраться досюда,
а потом с помощью ребра досюда и посетить всю С2.
Поэтому из Х достижимо и С1 и С2 целиком.
Поэтому к моменту времени выхода из Х
все вот это вот уже будет помещено черным.
Потому что из Х все это достижимо,
значит к моменту времени выхода из Х, опять по леме о белых путях,
все вот это перекрасится в черный,
значит Та от Х будет больше, чем все остальное.
То есть по леме о белых путях,
к моменту времени выхода из Х,
то есть к моменту Та от Х,
С2 и С1 целиком перекрасятся в черный цвет.
Ну это как раз и означает,
что Та от Х больше,
чем максимально возможное значение Та по всем вершинам С2.
То есть я сначала из них из всех вышел,
только потом из Х.
То есть, если я из них вышел из С2,
то есть я сначала из них из всех вышел,
только потом из Х.
Нормально?
Так, ну теперь противоположный случай,
когда она наоборот в С2.
Пусть она в С2.
То есть вершина с минимальным Тином,
она находится во второй компоненте,
сильно связанная с С2.
Вот, ну тогда я утверждаю,
что к моменту времени выхода из нее,
С2 вся перекрасится в черный,
а С1 останется белый.
То есть к моменту Та от Х,
вся С2 перекрасится в черный,
а С1 останется белый.
Да, ну потому что мы уже поняли,
что не просто даже нет ребер из С2 в С1,
а даже нет путей из С2 в С1.
Потому что если бы был какой-то путь из С2 в С1,
то они бы все замкнулись в один большой цикл
и была бы одна общая КСС.
Значит, полямия белых путях,
к моменту времени выхода из Х,
я в С1 вообще даже не зайду,
потому что оно недостижимо просто.
Поэтому сначала обойдется вся С2,
вся она поместится в черный,
и только потом когда-то в будущем посетится С1.
То есть Та у Т вот отсюда больше,
чем Та вот отсюда.
Тогда...
Ну может даже так написать,
для любого В из С1,
для любого У из С2,
Та у В больше, чем Та у.
Потому что сначала вся С2,
а потом только после этого вся С1.
Вот, вроде доказали.
Корректность доказали,
то есть мы реально,
мы в хорошем порядке обходим все эти КССки,
что мы никогда не пытаемся
по обратному ребру перейти
из одной компоненты в другую.
Мы именно их сначала вот эту обойдем,
потом вот эту, потом эту и так далее.
То есть мы ничего лишнего никогда не обходим.
Ну, например, давайте картинка какая-то.
Например, вот если такой граф, скажем,
на пяти вершинах.
На пяти вершинах.
Ну, здесь понятно, здесь каждая вершина
это отдельное КСС,
потому что нет циклов.
Ну и тогда утверждается,
что мы обязательно сначала вот перед тем,
как вот эту вот вершинку обработать
и сказать, что она сама по себе КСС,
мы обязаны будем обойти вот это и вот это.
Ну понятно, у них просто будет больше Та,
чем у нее, в любом случае.
То есть сначала, скажем, обойдем это, это,
потом это, потом вот эти две.
Так, вопросы, может, какие-то?
Ну, хорошо.
Еще раз?
Не, ну как красим?
Они где-то там внутри,
вот они где-то внутри ДФСа,
но я знаю, что вот если я рассматриваю момент времени, скажем,
от Тин до ТАУТ Х,
то у меня новых серых не появляется,
у меня только какие-то белые перекрасились в черные,
поэтому здесь как бы серые нигде
не появляются, они где-то внутри, внутри ДФСа
появляются,
но вот как бы к моменту времени
ТАУТ от Х,
они уже не просто серыми, они уже и черными стали,
поэтому новых серых здесь нигде не появляются.
Так, значит, мне нужно будет
еще такое наблюдение,
давайте следствие напишу, что ли.
Значит, пусть
для каждой вершинки
у меня заводится некое значение
ID от В,
это номер КСС,
содержащий
вершину В.
В том порядке, в котором
его находят
алгоритм Косараю.
В порядке из
алгоритма Косараю.
Ну то есть он же в каком-то порядке
эти компоненты находит,
он сначала нашел одну, потом другую, потом третью и так далее.
Вот давайте ID-шники им всем поставим.
Когда я обхожу очередную КСС,
я говорю, что это там, это нулевая компонента,
здесь везде будут нолики и ID-шники,
это первая, здесь все единичные и так далее.
То есть в каждой вершинке можно записать номер ее КСС,
в какую компоненту я ее отнес.
Вот.
Значит тогда,
если у меня есть какое-то ребро,
скажем, АВ,
тогда у меня есть неравенство
на ID-шники между ними.
Именно, видимо, что ID от А
меньше равно ID от В.
Вот.
Ну вроде более-менее тривиально.
Значит давайте разберем два случая,
в одной они компоненте или нет.
Значит, если
А и В в одной КСС,
то, ну понятно дело, ID-шники просто равны.
Да, мы доказали, что Косараю корректно работает
и все.
А если,
если у меня есть неравенство,
если у меня есть неравенство,
мы доказали, что Косараю корректно работает
и все вершины разбивают правильным образом
на компоненте сильно связанности,
значит если они в одной КСС, то у них будет одинаковый номер.
Если в разных,
то они обязательно вот в какой-то
такой вот картинке лежат.
Поскольку у меня есть ребро из А в В,
и они в разных КСС, то вот это вот А, вот это вот В.
На этой картинке они лежат в разных КСС,
между которыми есть ребро,
и вот именно А и В концы этого ребра.
Иначе,
у меня картинка ровно вот такая.
Тогда я хочу доказать, что ID от А
строго меньше, чем ID от В.
Ну, вроде понятно.
Мы доказывали, что если у меня есть ребро
между компонентами,
то сначала обойдется вот это, потом вот это.
Да, значит есть ребро.
То есть,
из С1 в С2,
следовательно,
DFS, вот этот вот реверснутый,
сначала обойдется С1, потом С2.
Значит, ID-шники
соотносят так, как нам нужно.
Значит, ID от А будет даже строго
меньше, чем ID от В.
Правда же?
Хорошо.
Тогда, зачем мне это нужно?
Для следующей задачи.
Задача называется
два-сад.
Задача такая.
Представьте себе, что у вас есть
пропозициональная формула в виде
два KNF.
Например, какая-то вот такая.
Х или не Y,
и
Z и Y,
и там, скажем, A или
не X. Ну, короче, вот что-то такое.
То есть, конъюнкция
скобок. В каждой скобке
дизъюнкция литералов
переменных или их отрицаний.
Соответственно, формула в два KNF.
Давайте научимся
проверять ее на выполнимость.
То есть, что такое два-сад?
Два от, собственно, два KNF,
сад от solo satisfiability, выполнимость формулы.
Давайте узнаем, выполнима она или нет.
То есть, существует ли хоть какой-то набор,
на котором она единичная.
Соответственно, вопрос.
Существует ли
набор значений переменных,
на котором она единичная?
Давайте сделаем следующее.
Давайте мы все вот эти
дизъюнкции, которые все должны
одновременно выполняться,
поскольку у меня идет конъюнкция скобок,
мне нужно, чтобы все дизъюнкции
выполнялись одновременно.
Чтобы все скобки одновременно выполнились.
Давайте каждую скобку заменим
на две эквивалентные импликации.
То есть, а именно
вот такую дизъюнкцию
можно эквивалентным образом
переписать, как вот такую импликацию.
переписать как вот такую импликацию. Или как вот такую импликацию. Это всё
эквивалентная запись. Потому что если мне нужно, чтобы хотя бы одно из них было
истина, то значит, если не первое, то второе, если не второе, то первое. А дальше давайте
эти импликации воспринимать как стрелки в графе, как ребра в графе. То есть буквально
давайте заведем граф, вершинами которого будет выступать все переменные отрицания.
Сейчас я заведу граф. Вершины все p и не p, то есть все переменные отрицания
переменных. Ну а ребра вот такие, как нам диктуют вот эти вот импликации. То есть я
каждую скобку расписываю как вот такие две эквивалентные импликации и провожу буквально
вот такие ребра, как оно говорит. Из не a в b, из не b в a. На ребра как диктуют импликации.
Так, мотлок же у всех был, да? Никого не пугает с левой импликации.
Вот, построил граф. Ну а дальше теорема. Я утверждаю, что phi выполнимо,
то есть у нее существует набор, на котором она единична, если и только если для каждой
переменной p. p и не p находятся в разных компонентах сильной связности.
Формула выполнима, если и только если для каждой переменной, а на ее отрицание находится в
разных кусках, в разных компонентах сильной связности. Доказались. Давайте слева направо
от противного. Пусть и выполнимо, но при этом для какой-то переменной она и ее отрицание лежат
в одной компоненте сильной связности. То есть i. p равно i. p. Ну что это значит? Значит,
они лежат в каком-то таком общем облачке, а что есть пути обе стороны? Ну, есть вот такой
какой-то путь по ребрам и есть обратный путь по ребрам. По импликациям на самом деле. Вот,
ну тогда это значит, что phi точно выполнимо быть не может, потому что p никакое значение принять не
может. Потому что, например, если по единичке, представьте, p равно 1, тогда все, что достижено
из p по стрелкам, тоже должно быть истинным на самом деле, потому что у нас есть правило,
что для истинности импликации из нички может следовать только единичка, из истинной следует
только истина. Поэтому если здесь 1, то все вот эти товарищи тоже 1. То есть если это истинно,
то все вот эти по дороге тоже истины. Значит, не по истинно, что не может быть одновременно с
тем, что по истинно. Ну и обратно, если не по истинно, то вдоль этого пути все должны быть истинны,
то есть p должно быть истинно противоречием. Просто p не может принять никакое значение.
Согласны? Вот, это простую сторону. Теперь обратно. Теперь обратно. Утверждается,
что если такого выраженного случая не произошло, если мы не нашли явного противоречия, то что здесь
написано? Здесь написано, что по факту p и p должны принять одинаковые значения, потому что отсюда
следует это, отсюда следует это. Они все должны принять равное значение. Такого быть не может,
потому что p и p обязательно дополняют друг друга. Вот утверждается, что если такого выраженного
случая не получилось, то никаких других противоречий нету, и можно подобрать правильный набор значений
переменных, который бы нашу формулу заединищил. Давайте его построим. Значит, построим явным
образом выполняющий набор. Построим выполняющий набор. А именно, для каждой переменной p, поскольку
она и ее отрицания лежат в разных компонентах сильно связанности, то здесь написано какое-то
неравенство, меньше или больше. Давайте тогда скажем, что истинен тот литерал, который и лежит в
большей компоненте сильно связанности. А именно, для любой p сделаю следующее. Если id p больше,
чем id не p, то я говорю, что p равно единице, а иначе ноль. Иначе, если, наоборот, в обратную
сторону id не p больше, то, наоборот, p равно нулю. Я считаю, что истинен тот литерал, который лежит в
большей компоненте сильно связанности, с большим номером в смысле. Вот здесь id p больше, поэтому
p единичка. И здесь id не p больше, поэтому вот это истинно, то есть p равно нулю. Вот давайте так
фиксируем значение всех переменных. Давайте так фиксируем значение всех переменных.
Теперь докажем, что этот набор значений действительно выполняющий. Докажем, что
это набор выполняющий. Ну вот противно. Пусть не так, пусть мы фиксировали значение всех
переменных, и фи почему-то ноль. Ну раз фи ноль, значит какая-то конкретная скобка нулевая.
А фи это конъюнкция скобок. Если конъюнкция нулевая, значит какая-то конкретная скобка равна нулю.
Значит, тогда существует конкретная скобка х или у, которая равна нулю при вот том вот конкретном
наборе значений. Возможно, там х идет с отрицанием, у с отрицанием неважно. Я считаю, что это как бы
литерал. То есть х сам по себе может быть сам отрицанием. Возможно, здесь написано не х,
или здесь написано не у. Это неважно. Здесь дюнкция нулевая. Это значит, что обе переменные нулевые.
Точнее оба литерала нулевые. х и у равны нулю. Давайте вспоминать, когда мы переменной могли
поставить нулевое значение. Только если у нее ID-шник и ее отрицание больше, чем ID от нее самой.
Это правило, по которому мы выставляем значение переменных. Если оно ноль, значит у нее у отрицания
и ID-шник больше. Ну и то же самое для у. Но, более того, кроме этого, я еще могу заметить следующее,
что в графе у меня обязательно есть два ребра. Есть ребро из не х в у и из не у в х.
И осталось применить вот этот факт, что при наличии ребра в графе у меня таким
образом соотносятся одишники. Давайте все это склеим. Смотрите, давайте начнем с ID не х,
вот этой штуки. За счет того, что существует ребро в у, ID от не х будет меньше либо равно,
чем ID от у. Это вот это вот следствие. Дальше, ID от у строго меньше, чем ID от не у. Вот тут
это написано. Дальше, из не у есть ребро в х, поэтому опять-таки последствию это значение не больше,
чем ID от х, потому что есть вот такой ребро. Но при этом ID от х меньше, чем ID от не х.
Значит мы получили что число меньше, чем оно само, противоречие. Вот, то есть тот набор
значений, который мы определили, реально выполняет все скобки одновременно. Потому что если какую-то не
выполняет, то мы можем легко прийти к противоречию с помощью вот этого факта. Все. Поэтому для того,
чтобы решить эту задачу, для того чтобы найти у фи какой-нибудь выполняющий набор, мне достаточно
построить граф, выделить в нем кс ски и всем переменным присвоить какое-то значение в зависимости
того, у кого ID компоненты больше. Работает опять-таки за линейное время. Если у меня сколько-то
переменных и сколько-то скобок, то у меня граф на удвоенном количестве переменных идет,
потому что для каждой переменной две вершины, она и отрицание. И для каждой скобки,
для каждой скобки коих с, у меня будет суммарно 2 умножить на с ребер, потому что каждая скобка
дает мне две стрелки на два ребра. То есть время работы получается линейным от к плюс с,
где к число переменных, с число скобок. Как-то так. Все, спасибо.
