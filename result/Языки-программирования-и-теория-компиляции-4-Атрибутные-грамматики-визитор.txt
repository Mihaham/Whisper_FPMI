Всем доброго дня! Мы с вами продолжаем наш курс после некоторого перерыва. У нас снова будет
еще один перерыв на следующей неделе. Мне кажется, как раз за это время перерыва могло появиться
большое количество вопросов по выполнению домашних заданий, и мы их сегодня будем как раз,
наверное, разбирать на семинаре. Сразу скажу, что это первый блок, в котором тема лекций и
тема семинаров будут кардинально различаться. Потому что на лекциях мы с вами будем рассматривать
семантический анализ, а на практике мы с вами будем рассматривать уже конвертацию VR для того,
чтобы в базовом интерпретаторе, который по факту мы пишем, мы могли сразу весь код
сконвертировать в VR. Напомню еще раз, где мы с вами находимся. Мы с вами находимся на
стадии elaboration, то есть у нас уже с вами есть дерево в разборах, но пока что это просто дерево
выводов в какой-то грамматике. То есть пока что оно не обладает никакой семантической сущностью.
Наша цель будет сегодня как раз это добавить. Давайте это краткое напоминание с прошлого
раза. Что нам нужно знать о токене? Вот когда мы распарсили его. Тип, значение, если это функция,
то какое количество аргументов она принимает, сигнатуру. И в дальнейшем было бы неплохо понимать,
что если это переменная, куда мы ее кладем? На стэк или в кучу? Ну это совсем уже...
Нет, там уже есть поинтеры в расте.
Да, если мы говорим про garbage collector, то нам нужно было понимать, как долго мы можем хранить
значение нашей переменной. Для этого нужно как раз область видимости определить. Ну и последняя
вещь, это кто ответственный за локацию объектов и за удаление объектов? Либо нормальные аллокаторы
можно использовать, которые удаляются в конце использования, как раз pattern-ray. Опять же еще
раз напомню стадии симматического анализа. Мы будем их проходить. Первая стадия симматического
анализа — это создание таблицы символов. И сегодня мы с вами разберем два подхода к созданию
таблицы символов. Вторая — это проверка типов. Третья — это подготовка фреймов для вызова функции,
потому что конвертировать в VR мы будем на самом деле по фреймово. То есть у нас есть тело функции,
мы будем конвертировать именно тело функции. И дальше мы рассмотрим с вами трансляцию Intermediate
Representation. Это язык, который напоминает что-то промежуточное между ассемблером и классическим
исходным кодом, в который можно писать разные инструкции. Воле того, он выполняет эти инструкции
линейно, и там в нем будут некоторые свойства, которые позволят его прямо интерпретировать по ходу.
Вот. И теперь нам нужно сделать следующее. Неплохо было бы сделать так, чтобы для каждого
не терминала мы могли бы создать некоторую осмысленную сущность. При этом для каждой
сущности необходимо определить некоторый набор атрибутов, которые ему привязаны. То есть
каждому не терминалу не терминалу нам нужно отнести некоторые... Ну смотрите, тут про атрибуты нужно
быть аккуратным. Это может быть некоторый класс, это может быть некоторое, так сказать,
там набор переменных, которые с ним связаны. Да, потому что это важно. Давайте как раз рассмотрим
пример, связанный с парсингом числа. Вот, если у нас есть какое-то число... Так, а мел у нас есть?
Или с наступлением весна? Вот, тут тоже есть. Что у нас есть? У нас... А, тут плохо,
чтобы в Zoom не будет показываться доска. Ну да ладно. Да, есть что в записи. А может,
у меня есть этот пример? Давайте гляну. Да, есть у меня этот слайд. Давайте я его покажу как раз.
То есть, смотрите, представьте себе, что у нас есть грамматика для разбора чисел. То есть,
это у нас достаточно какое-то простое число. Значит, как мы можем с вами зашифровать число
произвольное в записи? Это у нас либо знак, и дальше у нас есть какая-то последовательность бит,
которая нам нужна. И, значит, что мы должны сделать? Мы должны при встрече нашего числа при парсинге
этого правила сделать следующее. Указать, грубо говоря, список бит, которые у нас есть. Тут у нас
есть как раз операция для аппенда бита. И видно, что в данном контексте, если у нас с вами есть
лист 0, лист 1 и бит. Кстати, вам видно или мне кажется, тут какая-то засветка идет дичайшая?
Да, да, да. Мне вот кажется, что он тоже как... Я, конечно, понимаю. Так, можем ли мы это как-то поправить?
Это максимум, на что я способен.
А? Введем порядок в ручном режиме. Когда они закрывали же, шторы в ручном режиме. Вроде должно
быть лучше видно. Вот, то есть у нас, смотрите, что есть. У нас есть какой-то элемент лист 0,
да, и дальше мы парсим. Опять же, это объект-лист, но тут видите 1. Это означает, что когда мы парсим
некоторую атрибутную грамматику, мы с вами на самом деле можем обратиться к этой переменной. То есть
мы говорим лист 0, это лист 1 и бит. И дальше мы делаем некоторые операции при встрече, при выводе
этого правила. Опять же, нужно здесь сказать, что атрибутные правила будут хорошо работать в
случае восходящих парсеров, как только мы разбираем правила какое-то. Да, то есть мы поднимаемся по
дереву, вывода вверх. А в случае, если у нас парсер идет сверху вниз, когда мы должны выводить это
правило? Еще раз, смотрите, когда мы парсим снизу вверх, да, когда мы можем произвести вычисления
в большем количестве случаев. Наверное, когда мы распарсили это правило, мы сделали вывод этого
правила, написали код. Да, то есть у нас, грубо говоря, если у нас есть алгоритм перенос сверткам,
то после свертки мы сразу можем применять это, выводить последствия действия, которые мы должны с
вами делать. А, то есть генерирует какой-то дополнительный код и его выполнять. А в случае,
если у нас парсер идет сверху вниз, то мы должны закрыть это правило снизу, то есть мы как бы,
да, да, да, нам нужно распарсить все под дерево, только потом подняться вверх. Вот, и вот она атрибутная
грамматика. Но давайте подумаем, в чем плохо работает атрибутная грамматика на лету, то есть сразу
выводить какое-то правило. Особенно в восходящих парсерах. А? Что-что? Ну да, то есть у нас может
быть какой-то условный результат, в зависимости от того, куда мы с вами пойдем. Да, то есть те же
самые IFs работать не будут нормально. Как бы, вы должны сначала распарсить первую часть выражения,
а после этого парсить только последнюю. Да, и получается, смотрите, интересная операция. Та же самая
инструкция do while. Как бы, с ней могут быть проблемы, потому что, не, с do while, наверное, даже
проблем не будет. Вы сначала как минимум один раз должны будете выполнить последний пациент с действием,
который ждет после do, потом проверять условия. Да, то есть вам нужно будет аккуратно заходить
во все под деревья, которые у вас были, и на выводе грамматики как раз применять эти правила не очень
хорошо. То есть нам нужна какая-то отложенная структура атрибутов, к которой мы после этого можем
обратиться и выполнить какие-то действия. Понятна ли мысль про отложенную структуру атрибутов,
что на лету мы можем парсить только какие-то простейшие конструкции. Хорошо, значит атрибутная
грамматика для числа числа. Так, собственно, знак мы можем определить это bool значение негатив,
число это int, некоторое value. Список бит это может быть там набор типа позиция и значение бита для
того, чтобы допустим не хранить все значения напрямую. И тут как раз если мы говорим про числа,
то такая интересная особенность про формат хранения чисел. Какие форматы хранения чисел вы знаете?
Как обычно хранятся числа int? Не-не, ну давайте это с теми понятным. Имеется в виду big
and then little and then. Да, и у нас сразу хранится 32 бита для int. Вот, но есть интересная структура,
интересная библиотека. Нет, есть библиотека для серилизации, десерилизации, protobuf называется.
Вы, который формат хранения чисел совсем другой, то есть они записываются в бинарном формате,
вот, и там число имеет переменное количество byte int. То есть int может кодироваться переменным
числом byte от 1 до 4. Смотрите, там интересная запись, число вьется на 4 актета.
Да, да, я согласен, что если мы говорим про компиляторы, нам это неважно. Допустим,
если мы пишем какой-нибудь парсер для серилизации, десерилизации и каких-то данных,
но нам тоже нужно парсить грамматику, которую она задает, и тоже давать какие-то атрибуты.
Так вот, в protobuf интересная возможность, интересная особенность. Вы храните 4 байта,
и первый бит этого байта означает на самом деле следующее. Будет ли у вас активирован следующий
байт? То есть если у вас первый бит 0 в записи, то вот эти записи вам не нужны.
Вот, то есть в зависимости от этого, а? Вот, но там правда идет интересное кодирование. 0 превращается
в 0. Дальше минус 1 превращается в 1. Я не помню порядок. Единичка превращается в 2 и так далее.
То есть это называется зигзак кодирования. То есть если вы хотите прочитать значение 2,
то оно будет кодироваться в единицу. Если единица, то в минус единицы. Да, то есть вы пишете байты,
вот они. И идем до определенного контекста. Ничего он не напоминает. Тут, собственно, вот эта
абстракция. Это называется зигзак кодирования, но мы с вами прекрасно понимаем, ну, зигзак,
типа получается. Вот такое кодирование. Но на самом деле, поскольку вы уже не просто программисты,
а, собственно, проходите там курс по мотону и про всякие по всякой дискретной математике, то что
это напоминает? Вот эта конструкция. А? Нумерация целых чисел. То есть мы так показываем, что множество
целых чисел равномощно множество натуральных чисел. Вот. И это в пользу для эффективного кодирования информации.
Ну, это я рассказал про кодирование интов, на самом деле. А, нет, ну там просто еще строки используют
в этом формате. Я просто не весь формат рассказываю, потому что это не сильно нам нужно. То есть смотрите,
как бы есть атрибуто, которое мы можем считать на лету, и здесь, в принципе, формат парсинга данных
такой, что по первому биту мы сразу понимаем, какие у нас идут числа. Вот. Но, собственно, дерево разбора
будет вот такое вот. И грав, в зависимости для разбора числа, будет вот такое. Блин, мне точно надо
тебе переделать презентацию. Суть в том, что если у нас есть дерево разбора, то как бы нам все равно
придется заходить, как бы парсить сначала первое значение, подниматься по нему. Да, то есть видите,
тут такой рекурсивный обход идет. То есть мы получаем значения снизу, а как бы парсить мы должны
их сверху. Вот. То есть нам нужно взаимодействие так как вверх, так и вниз. Даже для такого простого
примера. Для того, чтобы вычислять грав зависимости. Вот. Но, на самом деле, мы с вами уже поняли,
что грав зависимости не всегда можно построить на лету. Хотелось бы какую-то другую абстракцию
иметь. Вот как раз про эфе. Собственно, допустим, мы когда доходим, у нас, допустим, представьте,
уже разобрано statement1 и statement2, то нам не понятно, что именно выбрать. То есть как бы нам
приходится использовать и то и другое условие. Да, понятно, что в этом примере мы сначала можем
попробовать распарсить condition, а потом собрать правила. Но все равно, если мы поменяем порядок
операции, то напрямую мы это делать уже не сможем. Ну и, собственно, дальше есть следующие методы
обработки атрибутных грамматик. Их выделяют обычно три. Первый метод динамический. То есть
обрабатываем вершину, как только под дерево уже обработано. Вот все узлы под дерево уже обработаны.
Мы с вами как раз должны хранить очередь вершин, в которые у нас зависимость, и мы должны хранить
ципологическую тратировку графа. Ну в какой-то степени для того, чтобы строить граф зависимости.
Это сложно. Следующая вещь — это до победного, а-ля, знаете, эвристический подход. Мы пытаемся
разобрать правила. Как только у нас правило какое-то не разбирается, мы ждем, пока какие-то другие правила
у нас разберутся. И последний подход — это подход, основанных на правилах грамматики. То есть на каждое
правило генерируется некоторый код, который его разбирает. Главное, что код этих атрибутов должен
работать нормально. И как мы с вами понимаем уже на самом деле, как и FlexBizone позволяет генерировать
код определенный, так и Ante-Ler на самом деле позволяет даже четко задавать атрибуты для грамматика.
Как это делается? Когда у нас есть некоторые правила, мы пишем фигурные скобки после обработки
какого-то правила для того, чтобы поставить какое-то свойство в наш контекст. Это вот такая вот интересная
вещь, связанная с контекстом, и на самом деле она зачастую используется на практике. Опять же,
контекст — это хорошо, но чем может быть плохо использование вот классических атрибутов? То есть,
грубо говоря, мы построили грамматику, задали атрибуты, всё типа работает. Что нам придется
делать, если нам придется сильно изменять структуру нашей грамматики? Да, заново всё строить,
заново определять все атрибуты, которые у нас имеются. То есть, у нас нет никакой эфемерной
структуры, мы как бы явно привязываемся к виду грамматики нашей. Это не очень хорошо,
поэтому вот атрибутных грамматик обычно выделяют некоторые частные случаи атрибутной грамматики,
и оно называется абстрактно-синтактическое дерево разбора. То есть, мы говорим, что каждому
не терминалу мы задаем некоторый атрибут, который отвечает за хранение этого не терминала,
за хранение сематической структуры, хранение этого не терминала. Сейчас давайте посмотрю буквально
по слайдам. Тут у меня про интерпретатор написано, давайте всё-таки расскажу, что такое абстрактно-
синтактическое дерево. Вот представьте себе, что у нас было какое-то правило. Давайте опять,
а на какой доске лучше писать? Любой? Нет, вам какой? На левый, на правый? Давайте, давайте
смотрим формулу ВВП. Итак. Бедный стул. Итак, что мы с вами делаем? У нас есть,
представьте себе, конструкция. СТМТ. Так. Экспор выводит, значит, что экспор звёздочка звёздочка,
экспор. Минус экспор. Ну и что-нибудь ещё нам. Нам это токен. Понятно, что экспор это у нас
должен быть объект одного и того же класса. Потому что это у нас некоторая сущность отвечает за
выражение. Причём выражение может быть числом, а может быть минус экспор, то есть унарный минус,
негативная экспрессия. Получается негатив экспрессия. И вот это что у нас? Что это за оператор?
Возведение в степени. Умножить-умножить. Вот. Тогда смотрите, что мы можем сделать в этом месте?
Мы на самом деле в этом месте можем трансформировать всю нашу структуру в следующие объекты. У нас с вами
будет expression, который будет представлять собой некоторый абстрактный класс, возможно интерфейс.
А в наследниках этого класса у нас будет три наследника. Первый это нам экспор,
второе это не гейт экспорт, а третье это кто? Кого я забыл? PowerExport.
Какие методы у них могут быть? Здесь опять же мы можем сказать с вами, что у expression будет
некоторое значение вида посчитать, функция, метод. Мы вызываем метод calc и пытаемся посчитать выражение.
Но реализация метода calc, она у каждого метода будет другой, разной. Да, потому что здесь у нас
calc вернет просто число, которое хранится. Здесь calc вызовет calc от выражения, которое лежит под
капотом, а здесь calc у нас вычислит возведение в степень для двух выражений. То есть оно вызовет
у каждого из них функцию calc и в конце вызовет еще один calc. Да, то есть у нас прямо видно
древовидную структуру. Мы с вами за счет исследований и полиморфизма по факту можем работать с этим
объектом как с единым целым. И это те, кто проходил курс по технологиям программирования, здесь кажется
такой всего один коллега. Какой это паттерн? Да, обработка дерева. То есть вычисление значения
дерева в зависимости от детей. Нет, это пока еще не визитер. Нет, мы к визитеру хотим перейти,
это пока паттерн-композит, который хранит дерево как один объект. То есть он хранит сложный
объект как единое целое. Вот в чем суть. Ну да. Ну в чем особенность паттерна-композит?
Особенность паттерна-композит состоит в том, что это всего лишь структурный паттерн. То есть для того,
чтобы с ним работать, в поведении будет очень неприятно, как обвязывать. То есть нам, как бы
представьте себе, вот у нас есть два стейтмата и для каждого из стейтматов нужно будет вызывать
метод calc. То есть стейтматы экспро и дальше вы должны будете проверять тип значений, которые у вас есть.
Хотелось бы отвязаться от этой типа и иметь какую-то общую структуру объектов.
Тут, кстати, говорится про интерпретатор. Что делать, если мы хотим справляться с циклами?
Первое это анролить и пытаться использовать только константы или те значения, для которых мы уже
знаем какую-то величину. Либо пытаться проходить несколько раз по циклической конструкции,
попытаться все-таки проставить корневый узел, относительно которого мы с вами дальше можем
размотаться. Понятно, что это неприятно и хотелось бы это обложить как можно на дальний момент времени.
Не, обработка циклов имеется в виду не в дереве в зависимости, а в коде в нашем. Мы же хотим циклические
инструкции писать. Ну а как интерпретировать? Ну вот да. Ну да, то есть нам каждый раз нужно
вычислять условия, посмотреть доступны ли это переменные или нет. Ну да, мы пока наивный
интерпретатор пишем, поэтому с этим проблем у нас никаких не будет. Хорошо. Так, это разобрались.
Мы видим с вами, что с этой структурой объектов работает достаточно сложно, потому что statement
потом он будет вызывать expression. Вам нужно просто помнить сигнатуру всех методов, которые у вас
хранятся в абстрактном синтетическом дереве. Причем смотрите, чем особенность в абстрактном
синтетическом дереве. Он заключается в следующем, что по факту как ни странно, вот оператор умножить
умножить здесь нам уже не нужен. Вот этот вот. Потому что он будет храниться по факту в информации об
узле этого дерева. Это power expression, это означает, что оператор звездочка-звездочка находится там.
Вот, то есть как бы говорится. И более того, не факт, что у нас каждое правило будет соотносить
один к одному. То есть, возможно, какие-то у нас могут быть интересные вещи. Допустим, смотрите.
Statematys. Допустим, это у нас Statematys на Statematys. То есть, что такое STMTS? Это у нас statement.
То есть, statement это что? Либо это пустой элемент, либо statement и набор других statement. Тогда
какой код мы должны сгенерировать? Нет. То есть, смотрите, здесь не будет как раз для этого
STMTS создаваться новый объект абстрактного синтетического дерева. Не на каждое правило у нас
будет создаваться объект новый. Какая инструкция будет генерироваться на вот эту вот вещь?
Не, на самом деле у нас будет хранить некоторый список стейтментов. Это да. Ну как оптимизирующие?
Если бы он был оптимизирующий, он, возможно, бы там еще что-то сделал.
Ну интересно. Буду знать. На самом деле, что произойдет? Значит, за STMTS будет создана
отдельный на самом деле объект, типа список стейтментов. Это будет некоторая сигнатура,
так сказать, в которой мы будем хранить что-то. И когда мы это вызываем, то мы в список стейтментов
будем добавлять просто еще один стейтмент. Да, то есть у нас типа сначала 3, 4, 5 и так далее. То есть,
все, что так или иначе подразумевает под собой итерацию к линии, какое-то повторение,
скорее всего, будет обработаться некоторыми списками под капотом. Но мы здесь понимаем,
что с этим будет работать достаточно сложно. И если мы будем рассматривать чистый подход,
классический, связанный с деревьями, то нам непонятно, где у нас находится скоп у переменных.
То есть, представьте нам атрибуты, писать для каждой переменной, писать атрибут,
в каком скопе он находится. Это долбаться можно. Дальше создать хранилища переменных в отдельном
месте тоже было бы неплохо. Да, мы его и так или иначе будем создавать. Но все же, значит,
инициировать дерево разбора, ну, за нас это уже сделали, значит, в этом проблеме нет. Вот,
и дальше у нас есть такая вещь, как нелокальность получения метаданных дерева. То есть, как бы нам
объект, который нужен в дереве, находится где-то в другом месте, совсем в другом месте. И последняя
вещь, кстати, крайне неприятная, и тут любители функционального языка могут сказать, что вы
делаете, вы ломаете нам функциональную парадигму от слова совсем. То есть, как бы у нас абстрактная
синтоксическое дерево, ну или даже атрибутная грамматика, и мы не понимаем, как обрабатывать это
в функциональном стиле. Вот, в пигене это делается, как сказал Гера. Да? Ну да, там как раз из-за
счет звездочки делается. Ну, умный, значит. Ну, это да. Ну да, тут я хочу сказать, что на самом деле
существует другой подход в функциональной парадигме программирования. Вот, и, возможно, мы его
с вами посмотрим. То есть, там даже ИАР, промежуточное представление, будет выглядеть по-другому относительно
классического ООП, ну классической императивной парадигмы. Не, ну для функциональных языков не
хотелось бы, чтобы ИАР был императивный. Не, ну смотрите, где это может быть полезно, когда у вас есть
какая-то функция, которая должна работать до определенного момента времени. То есть, если она не
сработает по определенному моменту времени, все, система глохнет. Ну, real-time OS. У них, скорее всего, вполне
возможно понадобится как раз функциональная парадигма. Ну, тут надо опять же...
Все это хорошо, если бы в базе данных планирование, вычисление веса для плана, было бы хорошо работало.
Но в базных данных это тоже не так. То есть, план выполнения запроса есть, он даже считает
сложность выполнения этого запроса, но потом... Ну вот, да. Поэтому такая вот вещь. Поэтому,
значит, как обрабатывают деревья, и здесь возникает паттерн под названием visitor. В чем его суть
состоит? У нас с вами строятся две структуры. Значит, первое, у нас с вами есть базовые элементы. По
факту, в нашем случае это будут элементы абстрактного синтоксического дерева. Вот, и на них строится
вызов структуры, подструктура объектов. То есть, опять же, все элементы, они будут иметь конкретного
наследника. Что есть у наследников? У наследников есть метод visitAccept, который позволяет
реализовать себе какой-то элемент объект. То есть, он принимает объект типа visitor и по факту
запускает рекурсивный механизм. При этом у нас с вами появляется еще один объект под названием
visitor, у которого есть метод visit от конкретного элемента. То есть, он умеет... Смотрите, я хочу
подчеркнуть внимательно ваше внимание, что visit он вызывается не от элемента, а от конкретного
элемента. Почему это важно? Потому что здесь будет на самом деле работать механизм двойной
диспетчеризации. То есть, как все это будет обрабатываться? У нас с вами будет какой-то
visitor. Мы с вами на самом деле будем все запускать от элемента. То есть, представьте себе, мы находимся
в корне, и мы говорим про следующую концепцию. Вместо того, чтобы посетитель обошел, допустим, дом,
мы делаем следующее. Мы говорим обратную вещь. Пусть дом впустит от себя визитера,
посетителя. То есть, первая реализация, которая у вас будет, это... Так, может быть, какой-нибудь код
напишем? Какой код написать? Не, я сейчас это... Я сейчас какой-нибудь текст-эдитер открою.
Ладно, ладно, сейчас подождите, тогда я вижу Studio Code, вырублю.
Не, не, не. Так, ладно, давайте new files, ну, какой-нибудь. Да, у меня просто тут какие-то
примеры, типа... Так, давайте open folder. Чего у нас с интернетом беда? А? Да я понимаю, что...
Я знаю, так. Так, конечно, есть. Мне питона достаточно будет. Ну да, на питоне парадик...
Ладно, давайте, короче, откроем текст в редактор, как бы...
Сделаем проще. Так, давайте тогда... На каком языке напишем? Господи, ну, ладно. Ладно, давайте тогда...
Да, давайте, значит, сначала напишем... О, проснулся, блин. Ну, все, adios. Давайте мы с вами даже
напишем class main cpp, сначала file. И я просто опишу, собственно, последность действий,
которые у нас есть. Допустим, мы с вами делаем какой-нибудь home. У нас будет с вами какой-то дом,
у нас с вами будут к нему комнаты. Ага. Нет, периметр, визитер...
Ну, для этого композита достаточно. Давайте, ладно, давайте как раз мы с классическим
примером... home. Вы смотрите, мы создаем home. Да, кстати, home равно new. Да.
Вот так вот сделаем. Так, давайте я здесь... Я напишу все в одном файле, простите меня. Значит,
class element, собственно, он будет абстрактным. Давайте мы его так и обозначим. У него будет
virtual void, void accept. Он будет принимать объект вида visitor. Соответственно, нам нужен этот
class visitor сначала объявить, точнее, определить. Соответственно, у нас будет сначала class visitor.
Нет, это объявление. Вот так вот, да, получается. Так, ладно, теперь смотрите, значит,
у нас будет class home, public element. Значит, в нем будет у нас void accept. Так, что там?
Это ассигнатура. Ну, собственно, здесь может быть разная вещь в зависимости от нашего элемента,
допустим. То есть мы можем хранить какую-нибудь структуру, да, образно говоря.
Да, и базовая реализация, на самом деле, нам нужно вызвать у этого visitor method-visit. Вот тебя.
Внутрь visitor мы закладываем. То есть, если у нас теперь будет какой-то class visitor...
Ну да, по факту, видите, accept нужно только для того, чтобы правильный экземпляр класса
все переадресовать. Да, именно так. Значит, смотрите. А, я точку запятой забываю оставить.
Значит, class visitor. Какие у него будут методы? А, блин, я всегда забываю, что эти методы публичными
должны быть. Нет. Так, все, публичный. Значит, public. У него будет visit следующий, void visit,
собственно. И тут мы определяем уже как раз от конкретного дома void visit, допустим, room.
Значит, нам нужно еще classroom объявить. А мы его forward declare-нули. А, точно, точно,
точно. Сейчас, собственно, да, согласен. Так, да.
Да, да, конечно же. Я просто пишу в этом одном файле. По факту нам нужно делать forward declaration
всех объектов, которые здесь есть. Да, да, да, конечно же. Конечно же мы понимаем,
что нам нужен как раз кодогенератор здесь для того, чтобы не городить большое количество
элементов. Так, значит, void accept visitor overwrite. О, господи, какой openCL? У нас курс не про это.
А, да. Visit add this. Вот. Собственно, а теперь это, смотрите, значит, что мы можем сделать?
Так, смотрите. Я, конечно, понимаю, что тут интересно. Так, у нас теперь появляется
клад fillInVisitor. Собственно, у него теперь появляются два метода. Да, кстати, мы... Кто? Да.
Ну, во-первых, да, во-вторых, мы можем его переиспользовать потом. Да, они вообще ничего не должны знать.
Нет, методы добавлять это плохо. Опять же, если мы говорим про тот же самый swole, то у нас есть openClosePrinciple,
который говорит, что неплохо... плохо будет добавлять методы, лучше наследоваться и переопределять убедение.
Так, значит, смотрите, давайте мы напишем нашего, наконец-таки, homeVisitor, studentVisitor. Так, смотрите, overwrite.
Представьте себе, что, образно говоря, student, он заходит в какое-то место. Да? Нет, он не должен прийти по комнатам.
Так, ладно, давайте, короче, мы сделаем немножко другой кейс. Назовем наш класс не этот.
Нет, все нормально. Да. Блин. Это да, это я согласен. Старенький я уже. Вот, вот так.
Так, смотрите, а что означает, что у нас studentVisitor?
Смотрите, значит, давайте у student я пока что сделаю следующую вещь.
Собственно, у dormitory будет храниться какой-нибудь std-вектор. От чего? Chrome.
Вот так вот. То есть, получается, у нас вот так должно быть. А, нет, у нас же forward declaration, нам ничего не надо это делать.
Вот, то есть, видите, у нас есть список комнат. Так.
Где? Room. Это Room.
Собственно, смотрите, получается, у нас в доме есть общежитие. В нашей квартире есть общежитие.
Ту-ту, блин, в нашем общежитии есть комнаты. Заговариваюсь.
Вот. И дальше у нас с вами есть studentVisitor. Да?
Ну, кажется, по-хорошему, надо вообще, говорим, делать не вектор комнаты, а вектор элементов.
Потому что комнаты, наверное, будут работать у вектора типов.
Да, ну, понятно, что мы поверх комнаты можем свое дерево наследование тоже потом сделать.
Ну, по-хорошему говоря, да, вектор элементов.
Ну, по крайней мере, если мы потом универили studentVisitor...
Да.
...вот там у нас будет кодевой асколь класс.
Согласен. Да, согласен.
Вот, смотрите, то есть у нас получается вектор элемент rooms.
А дальше, смотрите, studentVisitor. Что у него будет в атрибутах?
У него, наверное, будет в атрибутах какой-нибудь, так, introom.
То есть в какой комнате он живет?
Нужно будет объявить сейчас какой-нибудь explicitInstructor.
Explicit получается studentVisitor at introom.
Вот так вот.
Да, то есть у нас получается с вами studentVisitor, и он умеет комнату.
Ну, и, соответственно, тогда что нам нужно сделать?
Опять же, тут нам нужно будет dormitory rooms.
At, получается, что?
At нашу комнату.
Accept.
What's this?
Так.
Rooms at.
Не room, а room.
То есть он умеет заходить только в текущую...
заходить только в свою комнату.
Ну и давайте мы с вами
в комнату напишем какой-нибудь std-out.
Hooray from room.
Как называется комната у нас?
У нас что в комнате есть?
А у нас ничего нет.
Давайте назовем ее.
Description.
Вот, то есть мы создаем описание комнаты.
Так.
Которое мы можем даже с вами потом сделать.
А, в комнате может быть интернет.
Это я согласен, что в комнате может быть интернет.
Но, как бы, это не может быть.
Так.
Explicit.
Господи.
Room.
Вызываем конструктор копирования.
Так.
Вот, у нас комната есть.
Так, вот, у нас комната есть.
Давайте наконец-таки мы ClassMain напишем.
Так, а что...
А, я у стрима подключу.
Так, вот смотрите, значит...
Вот что у нас происходит.
Значит, у нас есть HelloFromRoom.
Значит, у нас есть HelloFromRoom.
Собственно, теперь мы можем с вами сделать следующее.
Элемент.
Это у нас теперь dormitory.
А, вот это?
Да, без проблем.
Вот, смотрите, то есть у нас dormitory.
Дальше у нас dormitory...
Не, подождите.
Нам же нужно комнату вне сделать.
Да, у нас vector.
Так, dormitory.
Что у нас?
А, смотрите, нам домокастить нужно будет.
Да.
Да, здесь, к сожалению, нам нужно будет это...
Вызвать вот так.
А, все.
Rooms, да, понятно, что мы как бы в конструкторе класса dormitory
должны были передать элемент класса ClassMain.
Что тут?
Давайте...
А?
Да.
Да.
Room 1.
А, description 1.
NewRoom 2.
NewRoom 3.
NewRoom 3.
Так, давайте их по номерам сделаем.
То есть вот у нас, собственно, вот они комнаты у нас.
Блин, это же а-ля джейсон, да.
Значит, и теперь смотрите, что мы должны?
Создать нашего StudentVisitor.
Visitor.
Верно, StudentVisitor равно NewStudentVisitor.
Вот, давайте от первой комнаты.
Чего ты ругаешься?
Inaccessible.
О, господи.
Public.
Вот мы его оставляем.
Все.
Ну и что, давайте посмотрим, как это работает.
Значит, у нас с вами теперь dormitory.
Должна принять нашего визитора.
Все, давайте теперь запустим.
Все.
Через атлантчик запускать?
Понятно, что можно сразу запустить.
О, господи.
Так, сейчас, секунду.
У меня еще дебаггер неправильно стоит.
Да, можно, на самом деле, сразу запустить.
Опа, так.
Что он говорит?
Two Errors.
Что он говорит?
Ох, е-мое.
Понятно.
Так, ладно.
Там с VS Code что-то.
Да-да-да.
О, господи.
Так, а что он?
Не забудьте функцию Main.
Нет, я не забыл функцию Main.
А, выкат передний был правильный.
Все.
Во, е.
О, господи.
Все.
Во, е.
Кажется, получилось.
То есть у нас студент зашел только в свою комнату.
Вот, то есть он...
Да, вот, смотрите.
Теперь вот второй студент.
Он заходит во вторую комнату.
Вот он.
Two Errors.
Во, все.
Теперь зашел в вторую комнату.
А теперь мы сделаем другого визитера.
Я вам расскажу секретную тайну.
До какого-то года это работало.
Я скопировал.
Во.
То есть мы с вами создали титчер визитера, который теперь ходит по всем комнатам.
С обходом.
С каким-нибудь.
Его можно как угодно назвать.
Вот, и собственно...
Типа того.
Типа того.
Это только на фистихе работает.
Так.
Dormitory.
Да, кстати, я сразу скажу, что лучше вызывать именно от конкретного элемента Accept,
а не визит от чего-то.
Потому что мы с вами, допустим, когда построим синтоксическое дерево,
на уровне языка промежуточного представления нам придется заходить не во всю программу целиком,
а в каждый из фреймов по отдельности.
Ну да.
Так, teacher-vizitor.
Вот, мы с вами запускаем teacher-vizitor.
Надеюсь, компинируется это все.
Вот.
И вот, что делает teacher.
Он зашел во все комнаты.
В ответственно, если нам нужен какой-нибудь дополнительный еще визитер,
то мы его купим.
Вот.
И вот.
И вот.
И вот.
В ответственно, если нам нужен какой-нибудь дополнительный еще визитер,
то мы его просто добавляем.
Единственный недостаток этого подхода заключается в том,
что если внезапно у вас происходит какой-то капитальный ремонт в общежитии,
и у вас внезапно в общежитие добавляется какая-нибудь игровая комната,
то что нужно будет переделывать?
Надо переделать все визитеры.
Да, нужно будет в визитерах добавить.
У квадрона визитер...
...постоянно...
...переделывали всех визитеров.
Да.
Вот.
И на самом деле есть еще одна вещь, которую я хочу сказать.
Про это, наверное, мы с вами будем уже говорить на семинарах.
Что визитер можно сделать тимплейтным пластом
с помощью некоторого колхака.
Но это лучше не делать.
Это можно делать, но делается это неприятно,
потому что нам все равно нужно будет возвращать некоторые элементы из дочернего узла.
Да.
Но это делать через костыли.
...помогает приезжать игроками...
...висели иконские иконские элементы...
...и они не двигаются.
Да, а в предотвлении...
...когда едет новая шаблона, у тебя цикл включится до последнего шаблона.
...выбрали иконский цикл...
...выбрали иконский цикл...
...выбрали иконский цикл...
Так, что?
...выбрали иконский цикл...
...выбрали иконский цикл...
...выбрали иконский цикл...
Так, ну я думаю, что это мы пройдем дальше.
Давайте я спрошу, понятен ли суть паттерна визитер?
Хорошо.
Итак, смотрите.
И здесь мы начинаем наконец-таки...
У нас теперь есть некоторая сущность, которая нам позволяет
обходить абстрактное синтоксическое дерево разбора.
Да?
Подчеркну. То есть дальше, на самом деле, мы будем с вами
работать с такими понятиями, как...
...таблицы символов, нам нужно будет хранить
систему выводов типов и так далее.
И для каждой из этих вещей как раз нам нужно будет делать
свои собственные визитеры, объекты типа визитера.
Первое, что мы с вами можем сделать поверх этого визитера,
это, допустим, само абстрактное синтоксическое дерево распечатать.
А, собственно, суть второго задания, которое у нас есть.
А теперь нам нужны таблицы символов.
Эта структура данных, которая позволяет отслеживать
набор атрибута по имени токена.
Давайте поймем, что нам нужно от таблицы символов.
Ну, да, каким-то образом держать скопы.
Что такое скопы? Это область видимости.
То есть у нас есть переменные, допустим, А, и в внутреннем скопе
мы еще раз объявили переменную А.
Это мы должны с вами поддерживать.
Да, пока что, если мы храним это в общем месте,
то это будет не очень...
...выгодно.
Ну, да.
То есть, смотрите, здесь как раз надо будет уметь,
значит, во-первых, строить эту таблицу.
Опять же, сразу скажу, что таблица символов не воспринимает
ее чисто как таблицу.
Вот это вот такое есть важное отличие.
Смотрите, здесь есть два подхода к построению.
Один подход – это дерево таблиц.
А второй подход – это дерево таблиц.
А второй подход, который есть, это на самом деле
хешмап от стеков.
Стеков.
Как только мы заходим в какой-то скоп,
мы по факту этот новый скоп умулируем тем,
что мы будем на стек добавлять определенные элементы.
В самом деле это стек,
который будет еще в этом скопе,
а стек, который будет еще в этом хешмапе,
значит, от строки в дюкте.
Да, давайте как раз
тоже это все рассмотрим.
Давайте я сразу в код тогда
прыгну. Вот, смотрите, вот она функция,
допустим, у нас.
Вот у нас, смотрите, есть класс на джаве,
блин, мне надо переделать.
Да.
И у нас есть функция тестов n от переменной b.
Значит, что у нас с вами
здесь должно быть? У нас с вами, собственно,
есть несколько скопов. Первый скоп – это
глобальный скоп, в котором
у нас доступны списки всех классов.
Дальше у нас внутри скопов, связанных с классом,
какой скоп следующий будет?
Функции и методов нашего класса.
Ой, методов и полей нашего
класса. Дальше мы с вами,
когда заходим еще в один скоп, то что у нас
с вами получается? У нас с вами появляются
значения переменных. Во-первых, b переменная,
и во-вторых, у нас дальше идут еще
именованные, то есть у нас могут быть именованные
скопы, которые обозначаются явными методами,
а есть у нас занумерованные скопы. Что такое
занумерованные скопы? Это мы включаем какие-то
блокчные инструкции, дальше мы их с вами можем
набирать. У нас внутри одной функции может большое быть количество
EFOP или каких-то больших и больших структур. То есть мы с вами
должны уметь с ними работать для того, чтобы
переменную b. Значит, что нам нужно отслеживать
в скопе? Чтобы мы в текущем скопе не объявили
ту же самую переменную,
это раз. Во-вторых, если мы используем
какую-то переменную, то она у нас вообще
где-то объявлена была.
И здесь мы как раз можем написать подобный код.
Давайте я его тоже сейчас
быстро накидаю. Здесь
scopes.cpp.
Смотрите. Допустим, у нас есть int x
равно нулю, x1.
Дальше у нас есть функция main. x равно двойке.
If x больше пятерки,
int y равно
тройке. Там int x равно
четверть.
Else
int x равно пятерке.
Вот давайте так. x равно пятерке,
y равно тройке.
Этот код
скомпилируется.
Если я не допустил никаких синтоксических ошибок.
Я надеюсь, что я не допустил.
А я его не допустил, да?
Но в чем проблема этого кода?
Проблема в коде
с точки зрения компилятора.
Да, куча шейдувингов
переменных.
И смотрите, как мы это можем хранить.
На самом деле мы можем
создать некоторую структуру,
в которой будем хранить наши переменные.
Это си получится.
Поэтому в си на самом деле переменные
объявляются вначале функция.
Ну 89 стандарта.
В 99 уже можно в любом месте объявлять.
Да.
Вот.
Вот.
Вот.
Да.
Ну, можем на паскале писать.
А?
Или на фортране.
Давайте расскажу ту структуру,
которую мы зачастую будем пользоваться.
Чтобы было уже для практики.
Мы заводим специальный стэк.
Определенных символов.
В которых мы будем хранить некоторые значения.
Фиксированные значения.
И дополнительно мы с вами будем обходить
это все дело в общем.
Смотрите, какие у нас скопы будут здесь.
У нас будет скоп глобальный,
в котором будет переменная х,
равная нулю.
Дальше у нас будет скоп под названием main.
Внутри которого...
Что у нас будет с вами?
Какие переменные у нас объявляются
в скопе внутри функции main?
А?
Никакие, да.
А дальше мы объявляем два скопа.
Значит скоп решетка 0.
Вот.
А в скопе решетка 1
у нас будет объявляться переменная какая?
У.
Вот такая вот вещь.
И соответственно нам нужно в этой структуре
в каждый момент времени
понимать следующее, что если мы обращаемся
к переменной х, то к какой из переменных х
мы с вами обращаемся.
Для этого... А?
А что такое последнее?
Да, та, которая выше на стэке.
Поэтому, чтобы это сэмулировать,
мы с вами будем создавать общий массив
hashMap из элементов.
Это на самом деле
обход для интерпретатора и для построения
любой структуры.
У нас появляются три объекта в видах main.xy.
И дальше мы делаем следующее.
У нас будет общий стэк,
который объявляет. У нас первое объявление
идет переменная х.
Давайте я буду звездочка 1,
звездочка 2,
звездочка 3, звездочка 4, звездочка 5.
Я их буду писать.
Когда у нас появляется х равно 1,
мы кладем сюда звездочку 1.
И этот х тоже звездочка 1.
Дальше у нас встречается функция main.
Это будет решетка звездочка 2.
А дальше мы делаем хитрое.
Мы пишем, что вот у нас main.
Он ссылается на звездочку 2.
И в этом времени мы делаем следующее.
У нас открывается новый скоп
при анализе нашего кода.
Поэтому давайте мы добавим специальный символ,
открывающийся в кнопке,
который по факту будет храниться на стэке
чисто для того, чтобы отсигнализироваться,
когда нам нужно отсоединить этот скоп.
Дальше у нас скоп-решетка 0 идет.
Вот смотрите, мы дошли до сюда
и парсим программу.
И тогда каким образом получить значение переменной х?
Нам нужно посмотреть на вершину стэка
соответствующей данной переменной.
Вот так, допустим.
Пока мы про функции.
Ну смотрите, мы можем для каждого фрейма
по отдельности тоже соотносить эти объекты.
То есть мы запрыгиваем...
Эта структура является в смысле динамической структурой.
То есть когда мы обходим код этих объектов,
мы их можем хранить в отдельной сущности
и их использовать.
Я согласен, что здесь не будет общей древовидной структуры,
потому что у нас тут объекты тоже будут выкидываться
из этой структуры.
Так, смотрите, дальше у нас идет решетка 0,
мы добавляем элемент.
После этого у нас встречается переменная х
с решеткой 3
и переменная у с решеткой 4.
А потом у нас происходит следующее.
Закрыть скоп.
Каким образом мы с вами закрываем скоп?
Есть у кого и мысли?
Да, снимаем все, что идет с токена скопка
и снимаем эти объекты.
Опять же, если мы говорим про объекты каких-то классов,
то, грубо говоря, когда мы будем транслировать
в промежуточное представление,
нам нужно будет вызвать деструкторы этих классов.
То есть все, что у нас есть,
вы деструкторы конкретных классов.
Опять же, на уровне кодегена что у нас происходит.
Опять же, когда мы генерируем код для определенного фрейма,
то мы можем зайти именно в конкретный скоп конкретного фрейма
и это все проанализировать.
Естественно, здесь мы говорим, что наша структура
является динамической,
она не будет являться статической.
И если у нас структура является вот такой,
то в принципе этого хватает.
И на самом деле, на практике, скажу честно,
что вот такая вот самая простенькая структура,
ее вполне хватает для того, чтобы полностью проанализировать наш код.
Вторая вещь, которая здесь есть,
которую мы можем использовать,
это использовать немного другой подход,
который у нас имеется,
то есть у нас получается,
есть глобальный скоп, в нем будет функция ScopeExample,
и дальше мы делаем следующее.
Вот у нас появляется класс определенный под названием ScopeExample,
а потом внутри скопа GlobalExample
у нас появляется TestFN.
Соответственно, нам иногда полезно хранить полные модификаторы,
которые у нас есть,
то есть для того, чтобы мы глобальному модификатору с вами могли обратиться,
у нас появляется TestFN.
Дальше, внутри этого у нас в Scope,
под названием ScopeExampleTestFN,
появляется переменная B,
и у нас появляется как раз у метода,
собственно, в самой таблице всего,
у нас появляется intB и returnInt.
И вот в такой структуре, если вам нужно обращаться
к какому-то объекту,
мы с вами вполне можем получить,
когда мы к нему обращаемся.
Если вам нужно хранить, допустим, что-то за пределами этого скопа.
То есть у этого X будет полный модификатор,
Main$0,
решетка 0, X.
Все, да. А главное,
после этого код не перестраивать,
потому что иначе индексация вся полетит.
Мы пока здесь не говорим про оптимизацию,
поэтому, в принципе, здесь нам...
Нет, это будет плохо.
Ну, это да.
Главное только понимать для каждой переменной,
какой именно переменной мы обращаемся.
А, да.
Ну, в целом, да.
А это как раз потом и происходит,
когда мы переходим в VR,
когда говорим, что у нас аналог SSA,
стандартный аналог,
когда по факту каждый виртуальный регистр
будет назначаться с новому значению.
Любой.
То есть там есть инты, флоты.
Там прям четкий тип.
Если есть инт, то там инт есть 32,
есть инт 64, есть инт 17, 33 и так далее.
Если мы...
Да, инт-1, это бул.
Там есть структура, там есть массивы,
там есть структура.
Да, про LV мы говорим.
Вот, собственно, а здесь мы как раз получаем
полный идентификатор имени,
про который мы с вами говорили.
Значит, тут, в принципе,
это как раз пример презентации нашей.
Собственно, что мы с вами успели посмотреть?
Мы с вами сегодня посмотрели таблицу символов,
как строить в первом варианте.
Значит, пока что это именно, так сказать,
свежая история, которая нам полезна.
На семинарах мы сегодня с вами будем говорить
про именно ER и посмотрим как раз
визитор, как можно строить.
Мы пишем простой пример нашего кода на ER,
то есть на языке ER.
Посмотрим, как он пишется, код ER,
а дальше попытаемся его встроить в конкретный визитор.
Вот это план на наш сегодняшний семинар.
Так, давайте вопросу.
Ну и тут как раз у нас логично получится,
что когда мы код напишем на ER, у вас будет как раз время
порядка двух недель, чтобы освоиться вопрос, поздавать и так далее.
Все тогда, спасибо.
