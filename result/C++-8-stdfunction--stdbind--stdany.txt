мы в прошлый раз закончили вот на таком примере значит у нас продолжается тема лямбду функций
и последний раз я вам рассказывал про списки захвата в лямбдах вот тут мы рассматривали
пример что если я в классе нахожусь то поля класса они мне капчер был то есть я не могу
написать а в квадратных скобочках вот если я здесь пишу а в квадратных скобочках то это будет
ошибка компиляции нет никакого а который можно было бы захватить возможно кстати это я не
показывал давайте я напомню так г плюс плюс ага да г плюс плюс 11 у меня все замечательно
г плюс плюс 11 лямбда captures вот я не могу захватить а потому что non variable ну потому
что это нелокальная переменная она не подлежит захвату да да но я могу вот так написать понимаете
почему потому что это как если бы я ну я скажу заведи внутри себя в лямбде внутреннее поле а
которая будет про инициализировано текущим актор я вижу локально вот так нормально то есть
это да вот здесь я уже честно захватил по копии все нормально и теперь когда объект
умрет у меня не не сломается ничего я мог бы написать вот так и тогда бы опять была та же
самая проблема ну это я захватил по ссылке как бы на инт назвав ее а то что я видел как
а вот это я своей лямбде создал ссылку на инт ну как поле в объекте которая ссылается на текущие
но опять если объект умрет ссылка будет неволидной вот ладно еще один пример который я здесь
покажу прежде чем дальше пойти это статические переменные вот представьте что у меня есть
статическая переменная static int я даже не знаю как назвать а равно 3 чтобы не сконфликтовать
именами другими и вот я пытаюсь значит вот эту вот лямбду но только я тоже не назвать по-другому
аж например вот я хочу сказать давай-ка я вот такую лямбду заведу вот получится у меня или нет ну нет
потому что статические тоже не захватываемые ну нет захватываемая да я ошибся значит так
можно писать но интересно если я скажу c++ так равно warning ну ладно вот если я так напишу
что будет но вот кажется что оно должно работать несмотря на то что я не захватил потому что а
а это статическая переменная а стало быть она не должна присутствовать списках захвата и вот
странно насколько я понял это должно было быть ошибкой но почему-то это не являлась ошибкой
ну ладно давайте так попробуем да так работает естественно статическая переменная то мне не
надо писать в захват потому что она статическая она не локально но она локальная статическая но
она не локальная в том смысле что ее время жизни не ограничивается этой функцией вот короче
для статических переменных все работает не так как можно было бы подумать и кстати вот
допустим я здесь увеличил бы а я бы сказал здесь вот так
и выведем сейчас аж от чего от 5 вот что будет во-первых могу ли я увеличивать а а ведь казалось
бы ну я не написал мютабл я не сказал что лямбда мютабл а как а значит казалось бы я не
должен уметь захват но я же не захватила а да чего-чего не на аргумент она то что мы захватили а
а мы не захватили она нам и так доступно то есть это будет работать и это реально изменит нашу а
будет 9 ну там дальше еще что-то выявилось но первым числом выявилось 9 вот
не понял вопрос что значит структуру с таким же смыслом
да сейчас на самом деле я как раз хочу перейти к пункту следующему и я сегодня вам покажу вот
сейчас как лямбда работает изнутри то есть на самом деле вот то что мы сейчас все делаем это какие-то
такие это мы так исследуем слона там потрогали за хвост потрогали за хобот как это бывает в известной
фритче но на самом деле все эти вопросы сразу становятся очевидными если просто понять что на
самом деле делает компилятор когда видеть лямбда вот сейчас мы на это посмотрим ну вот последний
момент вот мы здесь написали а в квадратных скобках вот почему ворнинг то есть это не ошибка
компиляции мы его как будто бы захватили но на самом деле нет мы вот я не знаю почему это не
ошибка компиляции это странно что это не эррор ну минус эррор это был бы эррор то есть мы написали
статическую переменную как будто мы ее захватываем но на самом деле мы ее не мы не создали ее копию она
все еще статическая и мы все еще обращаемся к ней как будто она из мейна и меняем ее если
инкриментируем вот такие дела ну можно еще поэкспериментировать что было бы я ссылку
написал например ну то же самое ну без разницы все равно я бы обращался к ней самой таким способом
короче опасно это статические переменные в лямбде в общем да когда вы что-нибудь в лямбду захватываете
надо очень аккуратными быть надо вообще думать если вы из лямбды используете какие-то вещи кроме
как аргументы лямбды то надо все время все время быть внимательным все время думать это вы захватили
по ссылке или по значению они закончится ли время жизни этой штуки раньше чем вы ее используете и
так далее вот ну ладно так вот сейчас будет самое интересное это пункт 10 3 лямбды как объекты
ой не 10 3 13 3 closures as objects напоминаю что такое closure это слово переводим замыкание
замыканием называется вот тот тип который получается из лямбды ну это просто такой термин
с функционального программирования closure замыкание почему так называется ну не знаю
исторически так называется можно в википедии кстати найти я нашел статью википедии на русском
языке замыкание в скобочках программирования ну да есть это не c++ специфичное название просто
вот такие объекты называется замыканиями вот там в каких-то функциональных языках они очень
часто встречаются так вот я вам покажу сейчас такой замечательный сайт который называется cpp
insights точка его вот и он ну кажется что тут я могу соврать возможно это как-то связано
с год болтам в общем есть сайт год болт который вы наверное знаете который вам позволяет
смотреть какой какой ассемблер ваш код превращается вот но люди пошли дальше и
создали сайт cpp insights который позволяет вам посмотреть во что превращается ваш код на плюсах
до того как он превращается в ассемблер то есть компилятор компилируя ваш код на самом деле
его некоторым образом преобразует а уже потом генерирует ассемблер и вот ну например вот
здесь в качестве учебного при в качестве ознакомительного примера вот такой вот
пример приведен можно жать на кнопочку получить результат вот можно увидеть что на самом деле
с точки зрения компилятора то что здесь написано range based for вот этот вот разворачивая во первых
conchard r10 разворачивается вот в такое тут 10 нуле еще стоит а во вторых range based for
разворачивается вот такое очень удобно приятно можно смотреть как компиля ну здесь можно смотреть
например как компилятор расшифровывает range based for как компилятор там некоторые
шаблоны инстанцирует ну и вот пожалуй одно из самого полезного что здесь можно увидеть во что
компилятор лямбуда превращает давайте я просто покажу вам вот я напишу авто f равно ну стандартно
ничего не захватываю int x int y а return x меньше y и скажу там std seout f от 1 2 ну include o stream надо
написать вот сейчас я нажимаю на кнопочку play и чудесным образом я сейчас увижу
чего почему я еще пока не нажал вот смотрите что произошло ну тут довольно мелко вот так можно то
есть смотрите что на самом деле для компилятора означает лямбда вот мы сейчас копнем вглубь и
поймем что такое лямбда на самом деле на самом деле да чего да на самом деле компилятор видя лямбду
создает локальный класс с каким-то техническим внутренним названием это вот это название конечно
же никем не гарантируется это компилятор сам он придумывает какое-нибудь название для этого класса
так чтобы оно не пересекалось ни с каким из ваших существующих в общем по какому-то
внутреннему там принципу придумают лямбда 8 11 я так полагаю что 8 это номер строки 11 номер
номер столбца в котором он встретил а в которой самое главное что есть это inline был оператор
круглые скобочки конст который возвращает x меньше игр а почему конст ну потому что
обычно компаратор ожидает ну когда вы в мэп передаете лямбду например в компаратор то он
ожидает ну у мэпа компаратор например ждает что оператор круглые скобочки конст да и у
сортировок ну короче логично что круглые скобочки должен быть конст с точки зрения лямбда да конст
текстур закомментированный видимо это видимо начиная с какого-то стандарта это должно быть
конст экспорт но пока нет я не знаю почему так написано дальше дальше смотрите что еще есть у
этой лямбды у этой лямбды есть такой замечательный метод ну во-первых вот такой using using red
type 8 11 это вот это что это такое это указательная функция то есть на самом деле лямбда еще неявно
конвертируема в да function pointer то есть какой какие требования стандарта кладывает на вот этот
вот тип closure во-первых должен быть константный оператор круглые скобочки от ваших типов которые
возвращает то что вам надо во-вторых а должна быть неявная конверсия и вот это именно она это
оператор приведения неявного к типу вот этому то есть лямбда не явно конвертируема в function
pointer объект этой лямбды и возвращает он чтобы вы думали вот эту штуку а это некоторая статическая
функция которая по сути просто создает человековые объекты вызывает мне оператор круглые скобочки то
есть ну во что должен сконвертировать компилятор эту лямбду если я попросил конверсию к оператору
господи к function pointer он должен вернуть как pointer на какую-то сишную функцию от двух параметров
на какую но она просто статически еще тут объявлена отдельно на ряду совсем тем что
да да да это статическая функция от двух аргументов вот и она таким образом я могу
function pointer значит сконвертировать ну вызвать лямбду как function pointer ну вот он значит написал
вот это все и сразу же дальше я объявил объект такого класса по умолчанию а дальше просто я
сказал ну стд си аут точка оператор такой-то f точка оператор такой-то от вот этого вот что на
самом деле происходит когда я делаю вот так вот а теперь главный вопрос после которого вам у
вас должно что-то проясниться в голове вот смотрите давайте опять вот этот пример рассмотрю
да у меня есть что у меня есть ну в общем такая штука и я значит сравниваю по расстоянию до
середины что на самом деле ну я захвачу вот это вот да господи что на самом деле будет с объектом
что что появится справа если я так вот сделаю вот это мит которая я захватил это что это поле
класса конечно то есть на самом деле когда я что-то в класс захватываю что появляется у этого
класса да у него появляется просто приватное поле а также появляется конструктор от этой
штуки захваченной по ссылке который инициализирует это поле значением копируя его
но а по ссылке здесь будет интомперсант они и и это должно теперь вам вот теперь вам должно
стать понятно почему я не могу написать плюс плюс мит здесь да потому что круглые скобочки
так он а мид это поле когда я захватил по значению на самом деле у меня в классе появилось поле
просто в классе лям в классе closure но поскольку круглые скобочки должны быть константными я не
могу поля менять а мид это моё поле сейчас вопрос почему не констант логично оператор круглые
скобочки константные зачем ему быть констант кто требует этого чего что от этого станет
понятнее у нас есть требование что круглые скобочки должны быть константными круглые скобочки
должны не менять объект но поля этого объекта они ну обычные поля да почему почему я не могу
менять поля и скобочек да потому что поля констант потому что круглые скобочки константный если
я пишу здесь мьютобыл то это просто приводит к тому что
что круглые скобочки перестают быть константными
да, кстати, интересно, можно было бы mutable написать здесь
ну, нет, ну, ну это странно, да
ну вот перестают быть константными круглые скобочки
вот, а если я по ссылке захватываю
и не пишу mutable
что происходит?
как это работает?
я говорю плюс плюс мид
у меня теперь поле это интом персант
вот это конст не запрещает менять мне вот этот мид
потому что технически это указатель наверное
да, значит это может вас шокировать
если у вас восприятие ссылок
значит как не отличимых от исходного объекта вещей
но на самом деле мы это обсуждали в первом семестре
что если у вас ссылка является полем
то константость метода не влияет на возможность вашу менять вот это поле
да, то есть я могу менять мид тем самым меняя то что под ссылкой
но как бы с точки зрения компилятора поле я не поменял
вот
поэтому если я захватываю по ссылке то я могу менять
а если я захватываю по значению то я не могу менять если только mutable не напишу
вот так это работает
вот это объясняет почему все так устроено
а дальше
хорошо
ну давайте вернемся к
ну я же говорил мы можем
мы можем написать авто ну std sconst мы можем написать
просто это поле будет константное да?
тогда у меня будет
compilation failed
потому что
нет потому что no member named sconst
господи а где оно в утилите может быть
да
да теперь это константная ссылка
да я вам в прошлый раз неправильно сказал я вам в прошлый раз вот так сказал
надо писать meet равно std sconst meet
но это это все равно было бы meet это было бы значением
а вот так я могу константную ссылку написать
вот
ну хорошо
хорошо что?
кто?
ну да похоже уже не костуется
сейчас
для
если в лямбде есть захват то да к function pointer она уже не костуется потому что
ну потому что непонятно как потому что нужно
неявным первым параметром принять вис туда и там поля какие-то использовать уже не понятно как это делается
что оно не костуется к function pointer в таком случае
да
вот
я думаю что идея не сработает потому что конст же отбрасывается при выводе типа
он же что делает он выводит тип снова вот здесь
но если у тебя конст значения
ну если я пишу вот так
равно std sconst то это как если бы я написал авто
x проинцелизировав его этой штукой
но
конста отбросится если у тебя там просто значение
вот если у тебя там была ссылка то конст не отбросится а если было значение то конст отбрасывается потому что это бессмысленно
бессмысленно навешивать конст на объект
на не ссылку
ну мало ли просто был бы интересный способ оставить
вот ну то есть все равно int
вот ладно
да здесь можно мувать как вы помните
там вроде можно вообще все что угодно писать
да можно любой expression писать
ну вот если я кстати так напишу что будет
будет ошибка компиляции сейчас
потому что я пытаюсь
проинцелизировать non constant value reference
посредством rvl
да все отлично все вы вы вы усвоили да хорошо
могу написать это forward здесь
ну ладно в общем вы все поняли
да здесь вот так я написать не могу
так не разрешено
только либо 0 амперсантов либо 1 амперсант 2 амперсантов ну не разрешено так делать
вот да просто такой синтаксис не добавили
ладно хорошо
давайте дальше так вот у меня есть значит такой такой объект f
и теперь я говорю
вот так говорю
нормально все
возьму создам f2 копирование msf
все нормально
должен сделать конструктор копирования а что не явно не до определиться
почему нет я здесь целое число поставил
все нормально
без проблем
ну у такого типа не явный конструктор копирования все нормально я создал копию этого объекта
хорошо
вот так могу ли я написать
такого же типа как f сделай мне f2
да будет ли конструктор по умолчанию хороший вопрос
ну смотрите если читать буквально то что тут написано тут сгенерирован конструктор от int амперсант
и
как мы помним а мы же помним правда если у нас есть хоть один
кастомный конструктор то дефолтный конструктор компилятором не генерируется
поэтому сейчас будет ce
так написать нельзя
нету дефолтного конструктора но
начиная си плюс плюс двадцать можно
то есть я частично
си плюс плюс двадцать добавили в стандарт требования что компилятор обязан сгенерировать еще и дефолтный конструктор
а нет вру
он обязан возгенерировать только если нету
этих capture да если если есть capture все равно не будет вот если у меня нету capture то нормально
что компилятор обязан сгенерировать дефолтный конструктор если нету захвата
а что изменилось
что компилятор обязан сгенерировать дефолтный конструктор если нету захвата а если есть
давайте уберем захват и посмотрим
вот если я так напишу
то
господи
подождите
си плюс плюс двадцать нормально
вот а си плюс плюс семнадцать
кажется это не работало еще
по какой-то причине да это еще не работало
а
ну вот по кочану
а чего так сейчас что
no matching конструктор
ну в общем до си плюс плюс двадцать
несмотря на то что казалось бы по логике вещей конструктор должен генерироваться он не генерировался
ну вот нельзя было так создавать лямбда по умолчанию а начиная си плюс плюс двадцать можно
но только если нет захвата если есть захват то
ну понятно потому что непонятно чем мид проницилизировать чем его проницилизировать нулем что ли ну типа это как ну не очень понятно как-то странно
сейчас зачем нам две лямбда функции одного типа
ээээ
ну тут скорее вопрос не зачем нам две лямбда функции одного типа нам то может быть много зачем ну как типа ну у тебя может быть
у них поля разные ну как они могут иметь
ну это стейтфул лямбда это же стейтфул объекты у них у каждого есть свое поле у каждой есть какие-то данные
если у тебя есть функция в которой хранятся какие-то данные она когда вычисляется что-то с этими данными делает вообще говоря
у тебя может быть много таких этих функторов которые каждый в своем состоянии находится
как раз как раз если у тебя есть как раз если есть захват то осмысленно иметь ну легко придумать сценарий в котором может быть осмысленно иметь много
лямбда функции одинакового типа потому что они с состоянием они стейтфул у них есть у каждой какое-то поле
которая что-то хранит и говорит о состоянии текущей лямбда функции сейчас
разве ты еще не сказал что если у них есть захват тогда тут нельзя сделать
нельзя по умолчанию создавать но так можно я могу копию создать
вот
кстати начиная си плюс плюс двадцать я могу даже так написать
типа он умеет с мелькалявными кастовать?
нет
не не не я не могу написать вот так и в два равно f это мы выясняли в прошлый раз так сейчас
вот если я так напишу это будет ce потому что у этих лямб это разные типы вообще-то
это ну даже даже если здесь было бы еще раз вот если здесь было бы одинаково если бы код был абсолютно идентичный
это бы все равно не работало потому что разные классы да ну и что что код одинаковый компилятор два разных класса сгенерирует
но начиная си плюс плюс двадцать я могу вот так написать
ну это си плюс 17 сейчас я двадцатый выберу
в си плюс плюс 17 нельзя было писать лямбду в аннуэлэйтинг контексте мы это обсуждали в прошлый раз
а еще не было конструктора по умолчанию а вот си плюс плюс двадцать так можно
и это кстати приводит к интересному следствию вместо того чтобы в мэп вот вам нужно мэп завести
вам можно не создавать объекты писать декл тайпа вам можно сразу написать декл тайп вот здесь и лямбду
ну то есть вот здесь вот вам же не нужно
ну вы можете просто вот так написать и все и это лямбда будет использоваться как компаратор в мэпе
вам нужно тип указать компаратора но он сам сможет создать объект этого компаратора там внутри себя
вот
ладно дальше можно ли присваивать
вот я сказал декл тайп от f f2 равно f
теперь хочу присвоить f равно f2 можно ли присваивать
хотелось почему нет
ну да если нет захвата то можно но есть захват поэтому нельзя
ну потому что сейчас он не умеет кастовать
потому что да потому что опять есть не дефолтный конструктор копирования
и значит копия signet-оператор implicitly-deleted ну это логично считается что
у нас есть не дефолтный конструктор и для таких лямбд мы типа
ну компилятор считает что мы не должны генерировать
а
signet-оператор но если бы не было захвата опять
то это должно нормально работать
вот если без захвата то пожалуйста присваивайте
вот
ну и что еще
а
а вот кстати еще пример хороший
представьте что у меня такая вещь
std-unique-ptr на int
u от new int от 5
и я тут говорю
u равно std ну понятно что так я не смогу написать
всем понятно что так я не смогу написать будет ce
кому понятно почему вот это ce
unique-ptr нельзя копировать
но я могу написать вот так
я могу в лямбду move-нуть
ну у меня может быть какая-то штука
которая в лямбду у меня может быть объект который move-only объект
и я могу его захватить в лямбду посредством move-а
тогда я могу
ну я могу в этой лямбде его использовать
я могу сказать x-звездочка u например
y-звездочка u
но
но
что будет если я вот так попытаюсь написать
а тут опять будет ce
потому что эта лямбда уже некопируемая
потому что в ней есть поле unique-ptr
no member unique-ptr
include memory
вот такая лямбда уже некопируемая потому что
в ней есть поле
unique-ptr
copy-constructor of
вот это is implicit deleted because вот такое
поле has deleted copy-constructor очень информативно
вот
но
вот так я могу сделать
ну должен быть по крайней мере
move-ать лямбду мне по идее никто не мешает
вот пожалуйста move-ать лямбду можно
такую то есть я забрал из той лямбды
ее поля и
соответственно если теперь я вызову f
вот если я сейчас запущу код
то что будет
мы упадем в рантайме конечно же
какое ce откуда ce
я move-нул из
и что
move-нутый объект валиден
я move-нул поле теперь по unique-ptr
лежит null-ptr но он корректен
обращение к move-нутому объекту это не ошибка
компиляции
и даже не runtime-error
обращаться к move-нутому объекту корректно
но просто move-нутый unique-ptr
нельзя разыминовывать
он null-ptr
поэтому если я сейчас это запущу
то я упаду из-за того что обращаюсь к move-нутому unique-ptr
который там в полях остался
ну разыминовываю
а под ним null-ptr
есть ли здесь утечка памяти
в этом коде
ну нет конечно
разумеется нет потому что unique-ptr
освобождается сам когда все
когда уничтожается
когда f2 уничтожается
ну f2 вызовет сейчас корректно
когда f2 уничтожается
кстати запустить то здесь можно хоть
похоже нельзя
ладно да здесь нельзя запускать код
ну очень жаль
ну в принципе мне от cpp-insights
больше ничего и не надо сегодня
я думаю
вот
давайте я создам файл
closures cpp
и сюда скопи пащу
и посмотрим что будет реально
вот все скомпилировалось
здесь ноль
почему ноль
ну потому что действительно двойка
ближе к пяти чем один
если я здесь делаю один
если я здесь вызову вот это f
то я сейчас упаду
потому что разыминовал null-ptr
вот
короче лямбды это
не могу сказать что это сложно
но это требует аккуратности
когда вы их используете
а так
тип вот этого поля
ну он автоматически выводит
как если бы я
написал авто у равно sdm-u
ну это то есть уник-ptr будет
если бы я так написал
он бы выводил как если бы
я сказал авто амперсанту у равно sdm-u в ату
то есть это было бы ce
потому что
lvl-reference инициализируется lvl
кстати
что если вот так написать
а давайте подумаем что будет
ты там зря отвлекся
очень интересный пример
вот так
Денис Васюк значит
ты зря это пример
мне кажется тебя должен порадовать
вы знаете у нас каждый год
каждый год
вот
к концу года остается немного человек
которые активно следят за происходящими
со мной разговаривают
и обязательно вот каждый год есть
человек который очень эмоционально
реагирует на все происходящее
вот в прошлом году
был один такой человек
вот в этом году видимо эта роль
достается тебе мне очень надо чтобы
ты ходил на оставшиеся лекции
потому что
мне нужны чьи-то восторженные
комментарии от того что нам предстоит
лекции иначе будут скучными
мне нужна какая-то
аудитория которая бы
ну по идее ничего не произойдет
ну в смысле все будет нормально
хотелось бы чтобы мы умерли в этот момент
по ЗАЕ
ну типа так
ты ему кажется мы урем
нет типа кастэлвэльюсюки
затем кастэлконстэлвэльюсюки
как это вообще будет происходить
ну что такое эсконст
тут надо подумать о том что такое эсконст
так сейчас я
открою
да да да я
специально отрубился чтобы
чтобы не палить поисковую строку браузера
да а то там
всякие вещи
будут на видео записаны
у меня кстати интернет опять не работает
что за дела
да ладно на записи мы
остановили на минутку
потом продолжили
сейчас придется себе
раздавать интернет конечно
ну вот
работал перестал
а может это просто cpp референс лежит
вот это неловкая ситуация будет если это так
а нет
нет
подождите у меня лежит cpp референс кажется
а то есть проблема не в интернете
то есть мы не можем открыть cpp референс
ну вот
а то есть проблема не в интернете
то есть мы не можем открыть cpp референс
класс
а так
хорошо тогда мы попробуем по-другому
черт
все лекция закончена
не не не не
сейчас мы сейчас мы сделаем хитрее
сейчас я вас научу лайфхаком
давайте попробуем вот так
у меня он подал признаки жизни
и где-то по пути закончилась
да давайте вот так сделаем
я думаю что
да если вы не знаете
очень рекомендую всем
всем
айтишникам просто в порядке
обязательно нужно знать эту вещь
а прекрасно
got 301 response от crawl-time
замечательно
давайте попробуем какой-нибудь другой день
тоже мы не можем
хорошо а вот здесь что было
может быть здесь мы можем
класс
замечательно
короче мы не можем открыть cpp референс
очень жаль
ну
да вообще если cpp референс не работает
то конечно печально
потому что
ладно у нас есть у нас есть аналоги
у нас есть cpp референс дома
смотрите у нас же есть сайт c++.com
кто c++.com
вот
давайте
мм
воспользуемся им
да
вот
давайте
мм
воспользуемся им
да
правда
правда
почему-то
правда
правда правда
правда
к сожалению
он не такой удобный
ару
кто не знал что есть сайт cpp
dps-reference.ru
так
может быть cpp референс ru работает
так ладно короче не хочу этим заниматься
не работает так не работает
в общем
в общем это
кажется
должно компилироваться
правда делать какую-то ерунду
ну то есть что я сейчас сделал
я как бы сделал
константную ссылку на
rvlu
ссылку
ура
ааа
кстати
вот на cpp референс написано что
вариант с туманперсандами он просто
а ну тогда это все объясняет
то есть он просто
да поэтому я хотел сказать тебе референс
значит там просто закостылено что если мы rvlu ссылки вызываемся то
падай
ну потому что не надо так делать
ну я в принципе согласен да
ладно
вообще это должно работать теоретически
ааа
в целом все вроде что я хотел рассказать про
closures s-objects
нет
сейчас кстати
а в чем проблема вот этого вот
константную ссылку
на временный объект
почему бы не разрешить
rvlu ссылку кастовать
в константную lp
ну что в этом плохом
я не знаю у меня нет ответа
почему они это запретили я не знаю
ну вот запретили
ну понятно что если я просто
статик касс бы написал то это бы сработало
так
да еще один маленький вопросик
последний
смотрите
вот вы теперь понимаете что если я напишу
sizeof
мне надо что-нибудь вернуть как было
вот я могу здесь написать
например sizeof
ну я могу например спросить
sizeof от
f
вы понимаете что это значит
вы понимаете теперь
должны сколько это будет
размер u
да вам просто выяснится размер u
то есть
каков размер объекта лямбды
это кстати непраздный вопрос
когда вы лямбду куда-нибудь передаете
в качестве параметра
в функцию
вам нужно понимать а размер самого объекта лямбды
он какой вот лямбду
если куда-то передаете лучше по значению или по ссылке
передать
вот и кстати говоря
к вопросу еще о том зачем может быть нужно копировать лямбды
да если вы лямбду саму как объект куда-то хотите
передать в другую функцию
по значению или по ссылке
вам как действовать
вот
если лямбда ничего не захватывает то ее sizeof это просто 1
если я допустим в лямбду захватил 1 int
то ее размер был бы 4
а если я захватил ссылку на int
то ее размер был бы 8
то есть захвачу int по значению будет размер 4
захвачу int по ссылке будет размер 8
ну и понятно что размер лямбды он как
ну опять как сумма
ну то есть просто размер объекта
вот сейчас размер лямбды будет
таков каков размер Unique PTR
а кстати каков размер Unique PTR
8 ну 0 это второе
да размер Unique PTR 8 почему 8
сначала страшно стало
да Unique PTR в себе хранит всего лишь 1 pointer и все
а как же дилитер
дилитер у нас
а он сооптимизирован через MTBase Optimization
поэтому размер Unique PTR это всего лишь размер 1 pointer
все
вот дальше
давайте теперь поговорим вот о какой штуке
еще один пункт
раньше это не выделял отдельным пунктом
но сейчас выделю в связи с тем что в c++20 появилось кое-что более интересное
generic lambdas
generic lambdas
лямбды могут быть
generic
generic
что такое generic
java какой-то попахивает
обобщенные лямбды это что
ну я могу в лямбду принять авто
я могу сказать авто f равно
авто x
авто y
return x меньше y
f от 1 2 опять сказать
ну извините что я все время вывожу
используя этот пример ну просто он самый простой и на нем все можно продемонстрировать вот
все ну в общем-то тут и говорить то почти не о чем было бы если бы не
вопрос а как это работает вот у кого сейчас
вызывает вопросики эта конструкция
если у вас сейчас
вот нет у вас сейчас ощущения типа а как
какая магия как это работает какой тип uef вообще что это такое
как это вообще может работать у вас нет такого вопроса в голове
я не верю что мы когда вызываем то сдавляем
это что это шаблон
если делается локальный шаблонный класс
это что с тигом uef
не в смысле просто шаблонный круглый
да
на самом деле f это не шаблон
оператор круглой скобки в ней шаблон то есть сама по себе f это не сама по себе f не шаблонного типа
поэтому объект f
он
никакими трудными проблемами не обладает
переференцов жил
давайте попробуем
по моему он еще у меня работал недавно
пару часов назад
а
ну на пинг отвечает
ай ладно у меня не установлен
а
да короче это просто шаблонный оператор круглой скобки
просто шаблонный оператор так я извимо должен уметь так копировать же правда
давайте я попробую это сюда скопи пастить
нет так не работает копирование извимо к сожалению
x клип у меня тоже не установлен
ну в общем ладно вы мне поверите что это просто шаблонный оператор круглой скобки
а
конечно же я могу вот так написать например
тогда будет шаблонный оператор круглой скобки который принимает ссылки тогда это уже не скомпилируется
понятно почему
потому что опять таки
так не то
я не то я не то компилирую
это не компилируется потому что я передаю rvalue по lvalue ссылки
но если я здесь напишу
const auto ampersand то это компилируется
если я здесь напишу вот так
то это тоже компилируется
вот
кстати вопрос вот этот оператор круглой скобки у него будет сколько шаблонных параметров
два
два конечно t и u то есть вот это разные типы вообще говоря
я
вот эта функция
это будет не та же самая функция что функция двух интов
вот
если я сделаю f от 1 2 потом f от 1 2 0 будет это будут разные функции
а
что можно делать например
используя такую штуку
можно например
в лямбды захватывает другие лямбды давайте я вам сейчас покажу пример один который мне
довольно таки понравился вот смотрите вот у меня есть функция f
которая
ничего не принимает
и просто делает
печатает high я ее назову print high
я могу сделать функтор ну то есть функцию над функцией
которая
что я себя буду представлять
да то есть смотрите я могу сделать функцию над функцию от функции которая
принимает функцию
и возвращает другую функцию
и
и
и
и
и
и
и
ну то есть
нет сейчас do twice от f это
да это просто два раза вызвать f
вот но я могу
сделать
штуку которая
возвращает мне
функцию
это что это что питон
смотрите я
сейчас написал функцию
которая принимает функцию и возвращает функцию
а
и теперь могу сказать
нормально то есть я взял
ну да тут какая-то ерунда
вот давайте я попробую вызвать print high high
print high high это значит
callable
вызываемый объект
а ну да
а ну да
вот давайте проверим что это работает
может очень забыл нет все работает и действительно получается high high
вот почему по rvlu ссылке
ну
можно было бы и по значению в принципе это тоже бы работало
но rvlu ссылка она более универсальная
потому что не любая функция копируется
не любой объект копируется а тут вот
вот
такие дела
а если там авто два амперсанта мы передаем
какую-то
ссылку
какую ссылку
ну авто два амперсанта это универсальная ссылка работает по правилам вывода универсальных ссылок
вот
я кстати мог бы здесь и вот так написать наверное это бы тоже сработало
так вы поняли все этот пример
чего
можно авто ну в данном случае да потому что print high она ничего не
что еще раз
ну все тоже будет нормально здесь не важно как принять хоть с одним амперсантом хоть с двумя
в смысле захвата вот здесь вот захватится ли копия или захватится ссылка это кстати интересный вопрос
я думаю что копия
я думаю что копия захватится потому что все равно вы как если бы авто
ну передаете в конструктор
без амперсантов передаете
ну в нашем примере это не важно потому что будет работать в любом случае
можно кстати посмотреть на c++ insight да на cpp insights
ну давайте вы это сами сделайте потому что уже мы долго сидим на этом не очень стоит вот
ладно это generic лямбны понятно что генерируется шаблонный оператор круглой скобки
также понятно что generic лямбны уже к function pointer не кастится потому что тоже непонятно к какому кастить
что какой тип у function pointer должен быть непонятно
вот
как template type-name-t type-name-u оператор
как template type-name-t type-name-u оператор
что ты
ну вот
кажется нет кажется так не должен не будет работать
слушайте не знаю может он и генерирует такой оператор
сейчас то есть нам надо будет тогда просто по идее
а может кстати генерирует и правда
ну тогда нам нужно явно ему будет передать шаблонные параметры кстати говоря
давайте попробуем ладно я вот отсюда извимо я не умею как это делать
ну вот
давайте попробуем ладно я вот отсюда извимо я не умею копировать но отсюда я должен суметь копировать
сейчас давайте я попробую давайте посмотрим что cppinsight мне скажет
так ну вот это лямбда которая print high она неинтересная
дальше лямбда которая do twice лямбда 11 21 вот у нее есть параметр шаблонный оператор круглой скобки отсылки на
на объект внутри которого есть еще один локальный класс в котором есть оператор круглой скобки без параметров
и уже нет полей
кстати нет полей в нем заметьте что интересно
он решил что они ему не нужны просто
да вот это интересно почему он возможно потому что он не читает f локальной переменной там
а так нельзя а так можно но полей он все равно не сделал
сейчас покажу
вот так вот
ну как будто бы является но почему-то он решил как поле ее не добавлять к себе
ну так ducking
Илья, а правда ли, что f для внутренней лянды просто не является локальной переменной, поэтому не хватило?
Ну как будто бы является, но почему-то он решил как поле ее не добавлять к себе.
Ну я думаю, что компилятор имеет право делать преобразование кода, сохраняя эквивалентность так, чтобы там все наблюдаемое поведение не менялось.
Не, ну кстати, это же плохо по идее. Мы же можем эти лянды вообще разделить друг от друга, и вот эта ссылка, она может там просрочиться или что-то такое.
Ну, то есть по-хорошему он должен сохранять их значение.
Давайте вот так попробуем написать. Может он действительно не считает ее локальной переменной и поэтому не захватил.
Да, вот теперь захватил.
Да, возможно у него такие же правила сработали, как и были с классом, что если эта штука является параметром функции, в которой мы сейчас находимся, то он ее тоже не считает локальной переменной и не захватывает.
Что еще раз сработало, какие правила?
Ну, потому что это как будто бы не локальная переменная, а параметр функции, в которой мы сейчас находимся.
Это странно, потому что мне кажется, что она должна считаться локальной переменной, но почему-то он ее решил.
А попробуем вместо F, Q, C.
Давайте я не буду больше ничего пробовать. Мы пойдем дальше, потому что так можно очень долго на этом сидеть целый час и пробовать разные варианты.
Ну, в общем...
Мы добились того, чего хотели, это работает, а вот эти все сценарии, когда он что захватил, когда нет, это не очевидно, скажем так, и нужно себя перепроверять лишний раз.
Вот видите, мы в очередной раз столкнулись с тем, что не очевидно, он захватил или не захватил.
Да, открылся CP Reference. Отлично просто открылся. Смотрите, как прекрасно он открылся.
Можно еще раз обновить страницу, может он сейчас нормально прогрузится?
За я ответ сделал.
Да качо.
А, ну все, да.
В лямбде еще можно захватывать переменное количество аргументов, если он в шаблоне, начиная с C++20, по-моему.
Но это я не буду вам показывать, это уже на CP Reference сами увидите.
Ну вот, еще чего?
Переменное количество аргументов.
Ну вот, еще чего?
Переменное количество аргументов.
Если мы в шаблонном методе, то можно здесь написать вот так, args.
Если бы мы были в шаблонном методе, где args это пакет, то можно было бы распаковать пакет вот так.
И можно было бы написать вот так.
args равно std forward от args, от args.
Ну вот.
Ну вот.
Начиная с C++20, лямбды могут быть шаблонными.
То есть у нас могли быть до этого обобщенные лямбды, вот этот джинель к лямбды, которые принимают авто.
Но начиная с C++20, лямбды могут быть шаблонными.
То есть у нас могли быть обобщенные лямбды, вот этот джинель к лямбды, которые принимают авто.
Но начиная с C++20, лямбды могут быть шаблонными.
Принимают авто.
Но начиная с C++20, мы можем просто явно назвать, какой t.
И тогда мы можем в возвращаемом типе использовать что-то связанное с t.
Ну например, я могу сказать std remove reference t от t.
Вот.
Вот.
Ну, если бы мы с вами были в настоящем C++20, и если бы мы знали чуть побольше, то я бы сказал, для чего это может быть нужно.
Это может быть нужно для того, чтобы requirements написать на t, ну, концепты использовать.
Можно бы здесь потребовать, например, что t должно быть из Invocable.
Но пока мы этого не умеем, поэтому пока я просто вот такой игрушечный пример покажу.
Вот. Давайте проверим, что это работает.
Да, что?
Могли бы через tackle-type получить тип, написав tackle-type в маленькой?
Но если бы у нас было написано авто вместо явного шаблона, мы могли бы через tackle-type получить тип?
Могли бы, да.
Ну, там, конечно, были бы проблемы с этими ссылочками там всякие там.
Ну, надо было помнить, что он там иногда отбрасывает персанды, иногда не отбрасывает, вот эта вся история.
Но вообще, да, могли бы.
Ну, то есть, функционально ничего нового не добавилось.
Ну, просто синтаксис появился более удобный.
Обращаться к t.
Так-то мы могли бы и сказать, что tackle-type от чего-то.
Можно ли явно указывать шаблонные параметры каким-то образом?
Когда лямду вызываешь?
Да. Но если там написать, повторять, явно, оператор, круглые скобочки и еще.
Ну, как функции?
Вот, кстати, этого не знаю.
Думаю, что нельзя, но не буду пробовать.
Ну, нет, если ты оператор круглые скобочки вызываешь, то там, наверно, может.
Ну типа, написать f.операции.
В errado.
Наверное, так можно, но просто f с круглыми скобочками, с угловыми скобочками так должно быть нельзя, потому что это не f шаблонный же, а оператор круглые скобочки в нем.
Но я не уверен, это это все появилось совсем недавно, сейчас 20, может они такой возможности не добавили, добавили только, только эту.
Вот, ну ладно. Все, про генерик лямбда я вроде все сказал, что хотел.
Напоследок, нам сейчас надо, мы сейчас изучим один прекрасный класс, очень полезный и важный, как с точки зрения теории, так и с точки зрения практики.
Вот мы дофига посмотрели разных возможностей функционального программирования, на самом деле Федя вам рассказал про рейнджи, это тоже относится к теме функционального программирования, потому что по сути вы,
ну по сути рейнджи это тоже в каком-то смысле, ну вот эти вот функторы, когда палкой там конвейер создаете и разных операций что делать, а потом его разом выполняете.
Вот, есть один замечательный класс, который тоже появился в C++11 впервые, и он позволяет вам хранить любой вызываемый объект.
Ну давайте это будет пункт 13.5, правда я обещал, что пункт про рейнджи будет 13.5, ну давайте это будет 13.6.
Фанкшн, STD-фанкшн.
Так, где у нас лежит STD-фанкшн, я опять забыл, то ли в утилите, то ли в функционал, будем надеяться, что в функционал.
Значит смотрите, что позволяет делать мне класс STD-фанкшн.
Ну во-первых, это шаблонный класс, у которого шаблонный параметр должен быть функциональным типом.
Я могу вот так сказать.
Значит STD-фанкшн, это такой тип, шаблонный, его шаблонным параметром является тип функции, функциональный тип.
Да, функциональный тип вот так записывается, смотрите, у нас бывает тип указатель на функцию, это вот так записывается, у нас бывает тип ссылка на функцию, это вот так записывается.
А это, это просто функция.
Функция формально это тоже некоторый тип, да, функция работает типом.
Да не думаю.
Нет, у многих все еще вызывает недоумение, что это за тип такой, потому что объявить переменную такого типа я не могу.
Но формально все еще это такой тип, и он должен быть шаблонным параметром.
Ты же можешь объявить такую типу?
Переменную такого типа, нет.
В глобальном скопе называется она функция?
Нет, это не будет переменной.
Это не будет переменной считаться.
Это примерно оно и есть.
А так, SD-фанкшн.
Вот, этот функшн можно теперь вызывать, у него есть оператор круглой скобочки, как ни странно.
Что еще есть у SD-фанкшна?
А cpp-референс, о, таки наконец прогрузился cpp-референс.
Да, ну вот, собственно, на cpp-референс перечислены возможные синтаксисы лямпт.
И возможные варианты, что может быть в списках захвата.
В общем, я эту страничку предлагаю вам самим посмотреть, вот что может быть в списках захвата лямпт.
Но я уже не буду сейчас к этому возвращаться.
Давайте я попробую открыть страничку про SD-фанкшн.
Ну, в целом, как бы ничего пока удивительного.
Ну, объект и объект.
Проинициализировали его лямбдой.
Но прикол в том, что этот тип SD-фанкшн может в рантайме подменять функцию, которая под ним лежит.
Я могу, например, сказать...
Ну, я не знаю.
Я могу взять, например, и такую функцию объявить.
Increment XA.
И сказать, теперь f это будет increment.
Типа не по ссылке?
Да дело не в ссылке.
То, что функции не явно конвертируются в указатели на функции, это мы и раньше знали.
Проблема в том, чудо этой истории в том, что вообще-то под f лежал объект лямбды.
Closure.
А потом я взял и такой сказал, окей, теперь храни обычный указательностичный фунсток, окей.
А потом я ему скажу, а теперь у меня есть еще такой класс.
Ну, структура.
Ну, не compare, а структура, не знаю, decrement.
И в ней будет int, оператор, круглые скобочки, от int.
Const, который берет и возвращает минус-минус X.
И я такой говорю, хорошо, а теперь ты храни, пожалуйста, decrement.
И снова спрошу, чему равно f от 2.
Ну, можно и не const, да.
Пожалуйста.
То есть, у меня сначала функции была лямбда.
Потом обычная осишная функция.
Потом некоторые функциональные объекты в старом стиле.
И все это...
И все это я спокойно могу присваивать функции.
А могу вообще функции изначально...
Функции изначально...
Объявить как пустую.
Ну, я могу сказать, например, так.
auto ff равно std move от f.
Я забрал функцию, которая хранила f.
И сейчас я попробую вывести f от 2 и, скорее всего, упаду.
Ну да.
Это exception.
Bad function call.
То есть, функция хранит некоторую функцию в себе.
Но я ее могу забрать у нее.
И теперь она пустая.
Это было бы то же самое, как если бы я std function объявил вот так.
То есть, я могу сказать, std function f без параметра.
Ну, ничем не проинциализировав изначально.
Она хранит как бы пустую...
nullptr она хранит в каком-то смысле.
А дальше она просто в себе подкладывает то лямбду,
то function pointer, то стандартный, то компаратор в старом...
Ну, функциональный объект в старом стиле.
И это все она в рантайме может подменять один тип на другой.
Так еще прикол в том, что если мы ее вызываем, когда ничего нет,
там не exception полетает, а не...
Да-да-да.
Но она, когда мы ее вызываем...
Ну, у него есть оператор круглой скобочки у этого объекта.
И он видит, если мы от пустого вызываемся, то кидает exception.
Ну, он видит себя, я пустой или нет.
Вот, себе переференс прогрузился.
Смотрите, что у нас есть.
Ну, у нас есть конструкторы, деструкторы.
Swap, assign, оператор bool.
Что такое оператор bool?
Ну, это как раз cast проверка пустая функция или нет.
То есть, можно написать iff, то есть, если там что-то лежит.
Вот.
Давайте посмотрим на конструкторы.
Вот, да.
Ну, тут написано, что это general purpose polymorphic function wrapper.
Каждые объекты function могут хранить, копировать и вызывать
любой copy constructable callable target.
А это функции обычные, сишные, лямдовыражения, байндовыражения
или другие функции.
А также указатели на члены и указатели на методы.
В этом списке вам должно быть понятно все, кроме того, что такое bind expression.
Про bind expression мы сейчас отдельно поговорим.
Вот какие есть, значит,
конструкторы.
А сейчас будет табличка, значит, смех в зале.
Посмотрите внимательно на вот эти вот версии конструктора.
Аллокатор они принимают.
Но здесь...
Ну, как можно догадаться, функция фантастики, фантастика
фантастики, фантастика фантастики, фантастика фантастики,
как можно догадаться, функцион объекту оно лоцирует кое-что в динамической памяти,
потому что ему, чтобы сохранить этот объект функции, ему нужно его где-то,
примерно так же, как и sharedPTR, его нужно сохранить в динамической памяти выделив.
Но тут есть смешной момент.
Это было удалено все плюс 17.
Значит, анекдот вот какой.
А СТЛ, не СТЛ, а комитет, конечно же, по инерции,
решил, что, ребята, раз мы храним что-то в динамической памяти, давайте добавлять аллокатор.
Но, к моменту C++17, все поняли, что аллокаторы всех так задолбали,
что они решили, и компиляторы все еще не смогли поддержать функцион с кастомным аллокатором нормально.
То есть, sharedPTR с кастомным аллокатором они еще поддержали и сказали, ладно.
Но когда они еще и Function, которые в C++17 появились, добавили с кастомным аллокатором,
разработчики компиляторов сказали, да вы задолбали, мы не будем это поддерживать.
То есть, там до, вплоть до вот C++17 компиляторы все еще не научились поддерживать кастомный аллокатор Function.
Тогда комитет сказал, ладно, сдаемся, не поддерживайте кастомный аллокатор Function.
Мы не хотим этим.
Чтобы отказаться от этой идеи.
Что-что?
Чтобы отказаться от этой дебильной идеи.
Значит, комитет решил отказаться от аллокаторов как части типа,
и Function не стала его поддерживать.
На самом деле, я вам открою секрет,
в C++17, и об этом нам предстоит вскоре поговорить,
вероятно сегодня мы не успеем, но в следующий раз,
появились так называемые полиморфик аллокаторы.
На самом деле тот факт, что аллокаторы являются части типа контейнеров,
всех изрядно задолбал уже к моменту C++11 и C++14,
и все уже понимали, что это была какая-то ошибка довольно старая,
от которой бы пора избавить язык,
но по инерции все навешивали вот эти костыли,
скопт аллокатор адаптер и прочая вот эта вот дрянь,
которую все очень задолбались поддерживать.
Но начиная с C++17, вы, возможно, замечали,
появился новый вид контейнеров, у которых аллокатор это не часть типа,
а который динамически может подменяться.
Это же в реализации совсем мясо.
Да нет, и это как раз, как ни странно, в реализации не так уж сложно,
как поддерживать все эти пропагейт он контейнер, копия ассайнмент,
и тому подобное, скопт аллокатор адаптер и прочее.
Вот, и вот видите, здесь у Анну, ну да, здесь мы уже потратили.
В общем, мы на самом деле с вами плавненько подходим к следующей теме крупной,
которая у нас займет несколько пар,
и на которую у вас будет и задача sharedPTR, и следующая задача,
но она будет там пересекаться с разными темами,
это тема стирания типов.
А именно, у нас с вами вот уже в нескольких местах возникла одна и та же проблема.
Мы хотим уметь динамически подменять тип хранимого объекта.
Мы хотим уметь в sharedPTR динамически подменять тип дилитера и типа аллокатора.
Мы хотим в Function уметь динамически подменять тип хранимого объекта.
Мы хотим в контейнерах сделать так, чтобы аллокатор не был частью типа,
и тоже в контейнерах хотим уметь динамически подменять аллокатор,
что научились делать с Fibonacci 17.
Ну и еще кое-где мы это хотим научиться делать, и мы увидим, где это еще помогает.
И это будет наша следующая тема, и вот сегодня наша цель это успеть обсудить,
как это сделано в sharedPTR.
И после этого вы сможете начать писать sharedPTR.
Класс Function на самом деле мы с вами тоже реализуем.
Мы с вами обсудим, как он устроен изнутри.
И это очень хорошая такая содержательная задача – реализовать Function.
И вообще это могло бы быть целой отдельной задачей, домашней,
но в силу нехватки времени, потому что у вас и так много задач, это не будет домашней задачей.
Но на самом деле реализовать Function полноценно, чтобы оно работало как надо и все делать умело,
это прям полноценная задача. Мы ее реализуем в упрощенном варианте,
но вы увидите, насколько там много, насколько глубока кроличья нора, так сказать.
Как из sharedPTR, сколько проблем скрывает за собой реализация STD Function.
Тем не менее, прежде чем к этому переходить, я вам покажу еще несколько фокусов с STD Function.
Во-первых, STD Function умеет хранить указатели на члены, как уже было сказано.
То есть, указатели на методы, например, она умеет хранить.
А, например, у меня может быть метод…
Не знаю, тест, я не силен в придумывании названий.
У меня может быть метод…
Который тоже принимает int.
Давайте у меня будет поле какое-нибудь типа int.
Метод add, который принимает y и возвращает x плюс y.
Это метод класса Test.
STD Function умеет хранить любой callable.
Любой callable, любую callable сущность.
Что такое callable здесь написано?
Тут написано, значит, много интересного.
Мы вскоре разберемся в том, что тут написано.
Но указатель на метод тоже callable.
Как вызывать указатель на метод?
Ну вот у меня есть тест t, и я могу сказать, что t, давайте вспомним,
точка звездочка add, вот 5, например.
Только надо в скобке взять это, потому что круглый скобок приоритет выше, чем у точки со звездочкой.
В параграфе 3.10, если мне не изменяет память.
Не, это мы и делали.
Ну это и есть он, это метод просто.
Указатель на метод.
Ну давайте проверим, что я вас не обманываю.
Давайте я вот это все удалю.
Блин, зря я это удалил, надо, наверное, было это закомментировать.
А, ой, извините, я чушь написал, действительно.
Это не указатель на метод, это я написал чушь.
Мне нужен указатель на метод.
Сначала мне нужен указатель на метод.
Да, это бред, написан.
Сейчас, конечно, это не сработает, давайте проверим.
Да, это вообще не было declared in the scope.
Извините, я написал чушь.
Давайте я объявлю указатель на метод.
Как он объявляется?
Тест 2.2. звездочка.
Только это в скобочках, а перед этим возвращаемый тип.
Значит int test 2.2. звездочка at int.
И вот здесь имя.
padd, например.
Равно amp test 2.2.add.
Вот, теперь это указатель на метод.
И теперь, имея объект t, я могу по указателю на метод вызвать метод.
Нормально?
Вот теперь должно быть нормально.
Все работает и выводит ничего.
Почему?
Потому что я не вывел все аут, давайте выведу.
Должно вывести 7, кажется, да?
Так вот, такую штуку я тоже могу присвоить к функциону.
То есть я могу завести function, в который положить эту штуковину.
Вот этот вот указатель на метод.
std function.
Но вот вопрос.
А как мне function-то, значит...
Кажется, первым параметром, который у меня есть, это стд function.
Дикол-тайп.
Кажется, первым параметром надо передать какой-нибудь...
Ну, вообще, у меня в SimpleFuse 17, кажется, есть
class-template-argument-deduction.
Может, мне это поможет?
Давайте я попробую просто сказать, что std function f равно padd.
И пусть он сам отгадает шаблонные параметры.
Может, он сможет?
Мы не можем просто дикол-тайп?
К сожалению, нет, он не смог.
Потому что...
Но он объяснил, почему.
У него много, в общем, было трудностей.
В общем, он не смог отгадать шаблонные параметры таким способом.
К сожалению, не вышло.
Придется указывать их явно.
Что же делать?
Ну, можно попробовать, да, сказать, дикол-тайп.
От padd.
Тоже не получилось.
Мы же до этого присваивали не указатель на функцию, а функцию.
Да.
Мне нужно здесь, чтобы был...
Вот здесь был тип функции.
Ладно, давайте я вам скажу, какой тип должен быть у этой
штуки.
На самом деле, у этой функции тип должен быть int,
ссылка на тест
и второй параметр int.
Так, есть.
Ну, он не явно первым аргументом берет ссылку
на себя, на объект.
Вот такой функции можно присвоить
указатель на метод.
А можем ли мы таким образом вызвать метод?
Да, можем, если у меня объект
есть.
Чтобы мне вызвать указатель на метод, мне нужно
иметь объект t,
а также передать ему что-то вторым параметром.
Вот я могу дикол-тайп,
а я могу дикол-тайп,
а я могу дикол-тайп,
а также передать ему что-то вторым параметром.
Вот я могу точно так же сказать, да, что...
Думаю, не сработает.
Ну, давай проверим.
Ну, я не пробовал, ну давай проверим.
Нет.
Да.
Нет, к сожалению, как раз
из-за этого нам потребуется
как раз из-за этого нам потребуется
вот это вот, все, что тут
написано.
Потому что указатель
на метод и другой синтаксис вызова.
Короче, нет, так не работает.
Как он внутри понимает это указатель на метод
или...
А вот, а вот,
а я вам говорил, что real night function это хорошая задача.
Да, и что?
У него левым аргументом объекта
правым аргументом pointerToMember
должен быть.
Вот, но еще интереснее,
что на самом деле можно так делать
не только pointerToMember, но и pointerTo...
не pointerToMethod, а pointerTo...
указатель на поля, короче,
так можно вызывать, вызывать
указатель на поля.
Смотрите, я могу сказать
std function
std function
std function
от int
тест
от int
от тест
и все
ff равно, ну, мне нужно
указатель на поле, int
тест
тест, уже без скобочек
2.2. звездочка
px равно
amp test
2.2.x
И вот, если я сейчас ничего не путаю,
кажется, что мне получится
вот так сделать.
Давайте проверим.
Да, все работает.
И я таким образом могу
у объекта
вызывать поле, как бы.
По ссылке на объект
возвращает его поле.
Да.
По сути, это функция getter такой.
Зачем это может быть надо?
Ну, например,
вот у вас есть
структура или у вас есть тупл.
А вы хотите отсортировать
этот тупл по какому-то
из полей. Тогда вы можете
просто передать в
в качестве
Не отсортировать тупл. У вас есть
вектор из туплов, ну, или вектор
пар. А вы хотите отсортировать
его по какому-нибудь полю.
Вот.
И
тогда вы могли бы, ну, я правда не уверен,
что это работать будет
с std-сортом.
В смысле, стд-сорту передать
о панке сейчас?
Кстати, нам же Федя
показывал такой прикол, что там...
Ну да, да, это значит, это такая
проекция. Вы как бы берете и...
Ладно, я сейчас затрудняюсь пример привести.
Давайте я его потом в следующий раз приведу, когда мы будем
Invoke делать. Когда мы будем Function реализовывать,
короче, мы в следующий раз будем Function реализовывать.
И там
я этот пример приведу.
Вы узнаете, зачем нужна функция std-invoke.
Вот. Пока просто
мы знаем, что можно так делать.
Кстати,
вопросик. Если я здесь
пишу,
все нормально будет?
Нет. Почему?
Это такой вопрос на
глубокое понимание очередное.
Смотрите, у меня константный метод.
А вы не константный тип
в... Да.
А я пытаюсь
штуку, которая
на самом деле константная
по отношению к объекту,
отдать туда, где ожидается штука,
которая на самом деле не константная
по отношению к объекту. То есть я пытаюсь сказать,
а
f, ну,
вот моя функция, она имеет
право менять тестом...
Ну вот, менять свой первый
аргумент. Я не
могу
ей присвоить штуку,
которая не может менять свой первый аргумент.
Именно в эту сторону, а не
обратную. Вот если бы у меня здесь
было так,
вот если бы у меня здесь было так,
то это нормально.
Вот, смотрите.
Так, сейчас. Нет, подождите, здесь это...
Я забыл написать конст
вот здесь еще.
Так, сейчас.
Тут что ли конст мне надо написать? Нет, это как
странно.
Да.
О, теперь работает.
Сейчас, да, давайте вот здесь
сотрем.
Да, наверное, я все-таки перепутал.
Не в ту сторону нельзя, в другую сторону нельзя.
Да, в эту сторону можно.
Сказал, что
важно не перепутать и перепутал.
Бывает. Как прям с курткой в прошлый раз.
есть константную функцию.
Да, да, эта функция может
менять, да.
Ну, конечно, конечно.
Моя функция
гипотетически может менять первый аргумент.
А я и даю функцию, которая не может менять первый аргумент,
ну окей.
Но в обратную сторону нельзя,
если бы моя функция должна
не уметь менять первый аргумент.
А я и даю функцию, которая
умеет менять первый аргумент. Я нарушаю
константность.
вот если я здесь теперь сотру конст тоset это будет тоет все сломает вот
здесь вот будет ошибка потому что она первым аргументом не яна принимает
тестом establish а я пытаюсь отдать туда где требуется конст тестом важна первым
аргументом вот вот именно сейчас все правильно вот именно в эту сторону
нельзя я пытаюсь функции которая не меняет
первый аргумент подсунуть функцию, которая меняет
первый аргумент.
Моя функция не должна уметь менять первый аргумент,
а я и подсовываю.
Я обещал в сигнатуре этой функции, что она не меняет
первый аргумент.
А я и подсовываю функцию, которая меняет первый аргумент,
вот так не должно работать.
Вот.
Окей, это, что касается stfunction.
И последнее самое.
что в этой теме я вам расскажу это bind штука под названием std bind cpp-reference давай работай
значит пункт давайте в этом же файле скажу пункт 13.7 будет
назваться std bind смотрите что насколько велик и могучий язык c++ что мне позволяет делать
язык c++ он мне позволяет делать карирование кто значит такое карирование да да о ты знаешь
такое карирование значит функциональном программировании есть наряду с термином
замыкания что такой термин карирование каринг по-моему пишется так но я не уверен
лучше не буду писать это по английски можно на wikipedia открыть статью класс
нет нет карри это фамилия не от слова нести карри а от фамилии ученого который занимался
там логикой логикой и всякими подобными вещами лямбда исчисления в части кажется занималась
комбинаторной логикой занимался короче если у меня есть функция ну давайте опять напишу авто
моя любимая авто
f равно
назову ее less вот на этот раз я придумаю нормальное название назову less функция
которая сравнивает два аргумент кто из них меньше но я могу а захотеть сделать из этой
функции другую функцию функция будет от одного аргумента которая проверяет правда ли что ее
аргумент меньше чем 5 я хочу взять эту функцию и зафиксировать в ней один аргумент ну конечно
же я могу это сделать тоже через лямбда то есть я могу ну наподобие того что я делал тогда я
могу сказать типа ну да я могу типа вот так сделать и сказать return опять лямбда
которая принимает сейчас less than 5 это что такое это функция которая принимает один аргумент
а и эта штука мне возвращать должна мы же вызываем а да все я не должен еще одну лямбу мне
просто нужно сказать проверить что x что less от x и 5 вот так я могу сделать нет да все все нормально
да да да я сказал что less than 5 это функция которая возвращает less от x и 5 получилась
функция не маргман но на самом деле такая штука есть но у меня есть функция стандартной
функция стандартной библиотеки которая позволяет мне это делать она называется ст байнд я могу
сказать следующее это удалю стд байнд less дальше очень странно знак подчеркивания 1 5 ну не
знак подчеркивания 2 на самом деле здесь надо добавить стд placeholders смотрите это такая штука
что как ст байнд это вещь которая берет функцию а дальше она принимает переменное количество
аргументов из которых нужно ну вот стд placeholders знак подчеркивания 2 это некоторые специальные
объект которые исключительно функции стд байт понимаемый она говорит ей что на второе по
счету место нужно подставить то что я следующим тебе передал пятерку это хороший вопрос да
вот давайте я вам открою страничку на cpp референс про байнд только я надеюсь ну она пока грузится
почему нельзя просто в нормальном порядке вот тихо тихо что значит в нормальном порядке
передавать чтобы она понимала на какое место подставить вот это я скорее всего что-то забыл
возможно я перепутал порядок сначала надо писать 5 а потом ст placeholders
а
я
Я все еще не понимаю, в какой функции...
А, да, вот наконец-то нам открылось...
В каком цели выполняет неподчерканное банно?
Показать вместо какого аргумента функции подставить то, что вы дали в байке?
В смысле, что вместо второго аргумента функции подставить?
А нельзя просто в таком порядке их написать, чтобы на втором месте среди аргумента...
А ты хочешь снимать эти аргументы?
А ты хочешь сделать затычку для пропуска аргумента?
В смысле? Я не понимаю почему.
Мы хотим пропускать аргументы, но тебе за что?
В первом оставить пустыню?
В смысле, первое оставить пустыню?
В прямом.
Это у тебя новая функция получается?
Я не понимаю, что значит первое оставить пустыню?
Тебе нужно сделать новую функцию, которая первым аргументом передаст дальше ту функцию, которая в этом случае,
а на второй аргумент будет подставлять вот эту.
Эм...
Что у тебя там твоего lesson 5 это...
Так же прописать явно принимаемые параметры и явно прописать, чтобы там...
Типа mx?
Или что-то иное.
Ну да, lesson 5 для mx.
Ну типа это было в 1.8 в часе.
Это как-то ты не забрал меня встать.
Ну блин, просто это кажется было бы в 100 раз короче.
И меньше потенциальных параметров.
Почему-то у меня не работает.
Просто это дичь какая-то.
Сейчас, я пытаюсь понять, что я не так сделал.
Просто так вы делаете на шаблонах, а так это были бы отдельные симптические конструкции.
Так это было бы супер спресс.
Что-то я не то сделал, но не понимаю что.
К сожалению.
Вась, просто логика сперса.
Давайте сделаем отдельный стиль поисковая, приводим в основном вот к этому.
И это логично.
Может они с нуля нумируют аргументы просто?
Ага, интересно.
С единицей говоришь можно?
Ага, с единицей получается.
Окей.
А видимо там нужно связанный отрезок.
А, видимо я не могу указать второй, не указав первый.
Вот в чем дело, да, хорошо.
По смыслу это что значит?
Что типа, куда фихать соответствующие аргументы, которые в полночьем не функционируют?
В смысле, мы не можем все равно пропустить аргументы?
Если мы не можем пропустить аргументы, мы не можем пропустить аргументы?
В смысле, мы не можем все равно пропустить аргументы?
Если мы не можем пропустить аргументы, зачем вообще весь этот синтаксис?
Можем, можем, я забыл как.
О, это Хаскл Харри.
Тут сами до человека.
Говорите, я логик.
Да, что-то у меня не получается второй аргумент подставить вместо первого.
Экспентальным путем было обнаружено, что вам всего 29 поисков дали.
Да, ну в общем, ну в общем, да, я могу подставить.
Вот смотрите, ну еще раз, что я написал.
Я сказал, создай мне из функции less новую функцию, которая на первое место подставляет пятерку.
А второй аргумент как бы пробрасывает как надо.
Господи, я все перепутал, все не так.
Плейсхолдер, да, плейсхолдер это как раз что пропустить надо.
Опять это что подставить на второе место, вот как это работает.
Вот, вот как это работает.
Если я напишу вот так, это плейсхолдер.
Да, это я, извините, опять, в который раз это работает.
Да, теперь я создал функцию как бы с двумя аргументами, эквивалентно исходной.
Вот, я мог бы сказать, вот так.
Правда, все равно непонятно, почему так не работает.
Попробуем после этого плейсхолдер один поставить, чисто по приколу.
Нет, плейсхолдер вместо двойки у плейсхолдера один.
И запустим, и скомпилируем.
Я угадал.
Да, все, мы методом проб и ошибок поняли как работают плейсхолдеры, да.
Да, только один работает.
Да.
Да.
Плейсхолдеры, короче, я нумирую плейсхолдеры с единицы, независимо от того, в каком порядке я что перечисляю.
Сейчас у меня получилась функция, которая проверяет больше, чем пять, да.
То есть тот аргумент, который я передаю в less than five, он как бы подставляется на место вот этой штуки.
То есть, если я перечисляю плейсхолдеры с единицей, то у меня получается, что я перечисляю плейсхолдеры,
то этот аргумент, который я передаю в less than five, он как бы подставляется на место вот этой штуки.
И в итоге получается функция, правда ли, что пять меньше моей штуки, которую я передал сюда.
А, ну понятно, зачем это сделано.
Мы же хотим, чтобы у нас плейсхолдеры могли использоваться несколько раз с одним номером.
Типа один параметр в несколько и так далее.
Да, да, да, это правда.
Вот, я могу здесь, да, например, если у меня есть функция х умножить на у,
я могу сделать функцию square, которая просто берет один и тот же плейсхолдер в два раза.
Вот.
Я могу также сделать функцию, которая меняет местами аргументы.
То есть, я могу, например, сказать, авто...
Автогрейтор равно std bind less std placeholders.
Два.
Два std placeholders один.
Во.
И, ну то есть, я меняю местами аргументы.
То, что мне в выражении передают первым, я отдам вторым.
А то, что мне передали вторым, я отдам первым.
Опять Мексика.
Вот, это std bind.
Вот.
Какой тип имеет вот это выражение?
std bind.
Ну, вообще, грейтер.
И у него какой тип?
Отличный вопрос, правда?
Грейтер.
На самом деле, я уже видел вот в этих ошибках компиляции, какой тип у него.
Ну вот, std bind main lambda intent.
Короче, это еще одна какая-то внутренняя штуковина.
То есть это еще, наеду с лямбдами, bind объекты.
Это такие штуковины, которые тоже генерируются компилятором из bind expressions.
И на самом деле, их тип он тоже внутри где-то в STL определенно.
Ну, вот это std bind.
Это некоторый внутренний тип, который в STL где-то написан.
Но вас он не должен интересовать.
Вот на себе перейфе сказано, что тип возвращаемого значения unspecified.
Это компилятор решает, какой у него конкретно тип.
Но на самом деле, bind в отличие от лямбды можно реализовать самим.
То есть можно написать реализацию байнда.
И реализация байнда вместе с реализацией function, это была бы очень хорошая содержательно-интересная задача.
Вот.
У вас, наверное, сейчас должно вызывать некоторую отрыв и страх, как можно реализовать bind самим.
Ну, bind можно реализовать.
Можно нагуглить, кстати, как bind реализован.
Там есть пост на хабрид.
Ну, нужно будет много шаблонной магии для этого.
Ещё интересная штука, что плейсхоберы, учитывая, что они даже в STL ограниченные, то чуть проще становится жить.
Вот.
Ну, в общем, да.
Реализовывать bind мы, наверное, не будем, и заданий у вас не будет реализовать bind, потому что некогда нам.
Function мы реализуем, но bind не будем.
Но для интересующихся там, я не знаю, это может быть какой-нибудь...
Не знаю.
В качестве вопроса на отл-10 на экзамене можно там...
Реализовать bind.
Да, типа идею реализации bind рассказать.
Что bind из себя, как он идейно вообще, что он делает, то есть что должен он хранить, что вообще этот объект из себя представляет, что это такое.
Можно, кстати, спросить опять-таки на CPP Insights.
Ну, на CPP Insights мы, скорее всего, не увидим, ничего интересного, потому что это просто внутренний тип, который в STL где-то определён, что такое bind.
Ну, какой-то внутренний тип, который там на шаблонах написан.
Вот.
Но Function умеет хранить и bind объекты тоже.
Вот у вас здесь написано, что...
Ну, короче, результаты bind-expression они тоже являются callable.
Ну, логично.
Да, то есть Function может лежать как указательный метод, так указательный член, так и, значит, bind-expression, bind-объект.
Вообще вопрос, почему bind не всегда возвращает лямбль?
Ну, bind возвращает некоторый специальный тип,
который сделан...
Ты же bind можешь байнить не только лямбды, ты же bind можешь делать не только из лямбды.
Ну, bind – это специальная структура.
Почему мы хотим вообще различные типы возвращать как результат bind?
Потому что bind написан кодом.
Bind – это штука, которая реализована прям.
Bind – это шаблонная некоторая вещь.
Там шаблонный класс стрёмный,
который с помощью шаблонной магии вычисления вот этих вот позиций подставляет на нужные места
и возвращает объект себя этого шаблонного класса.
Потому что bind просто реализован в стандартной библиотеке как класс.
Ну, bind, тип байнда реализован как класс.
Ладно, мы вроде справились, да.
А правда ли, что до появления ASTO никаких лямбдов или лямбдов не могло быть?
Я не знаю, могло ли быть, но они появились одновременно.
Я имею в виду, что нельзя было бы объявить тип назвать крепким.
Ну, кажется, что да, нельзя было.
А там же такой тип был.
Кажется, что нельзя было.
Но в случае с bind декл-тайп...
Да, давайте перерыв.
Всё, мы закончили тему 13.
Вот, значит, мы начинаем новую тему.
Как я уже сказал, она будет называться стирание типов.
Значит, тема 14.
Называется type erasure.
Стирание типов.
И в этой главе мы окончательно превратим плюсы в питон.
Как я уже сказал, мы с вами уже несколько раз столкнулись с ситуацией,
что нам хотелось бы динамически подменять тип хранимого объекта.
О, мне нужно зарядку подключить.
Динамически подменять тип хранимого объекта.
Например...
Например, когда мы с вами говорили про shared PTR,
мы поняли, что мы бы хотели, чтобы он...
Чтобы Allocator и Deleter не были частью его типа.
Но мы пока не умели это делать.
Потом мы вспоминали, что мы хотим, чтобы Allocator и Deleter не были частью его типа.
Но мы пока не умели это делать.
Потом мы встретились с STD Function и поняли, что в самом деле она из той же серии.
Это тоже тип, который может динамически подменять, хранить под собой разные вещи.
И на самом деле мы в контейнерах тоже бы хотели, начиная с C++17,
у нас есть проблема, что мы не хотим иметь Allocator частью типа контейнер.
Это проблема, которую Комитет осознал довольно давно, но решение придумал не так давно.
Мы начнем с очень простого.
Мы сразу решим все эти проблемы разом.
Я сейчас в пункте 14.1 познакомлю вас с одним замечательным классом,
название которого я вам уже заспойлерил названием этого файла.
Мы познакомимся с замечательным классом,
на примере которого сразу увидим, как можно устроить динамическую типизацию в плюсах.
Тип этот будет называться std-any.
Он есть в стандартной библиотеке в заголочном файле any.
Смотрите, как это чудесно работает.
Я беру и говорю std-any a равно 5.
А потом говорю a равно 3.14.
А потом говорю a равно abcdf.
А потом говорю a равно std-vector int 1,2.
И все прекрасно работает.
Пока мы не компилируем.
Но нет, все работает, даже если это скомпилировать.
Ну, вектор у меня не подключен.
Сейчас подключим, господи, проблем-то.
А вот тут есть логичный вопрос.
Мы по производительности и случайно к питону такими фильмками не приближаемся?
А вот на этот вопрос мы сейчас ответим.
Мы сейчас с вами реализуем эдик просто в этом пункте, и вы все поймем.
Итак, господа, этот тип, правда начиная с c++17 только появился,
но на самом деле для его реализации не нужно ничего знать сверх того, что вы уже знаете.
Вообще, на самом деле при ваших текущих знаниях это можно рассматривать как задачу на подумать.
Как реализовать такое поведение?
Нет, ну, естественно, можно реализовать такое поведение,
что просто template-оператор присваивания игнорирует то, что ему дали.
Это, конечно, можно, но нет, мы не такое поведение хотим.
Мы хотим, чтобы они можно было доставать то, что в нем хранится.
Ну, например... А, кстати, а как прочитать то, что в Any лежит?
Вот это отличный вопрос.
Там какой-нибудь Get и указать...
Get с типом, правильно.
Подождите.
Подождите, подождите, значит, std...
Вот, чтобы прочитать из Any то, что в нем сейчас лежит,
есть замечательная функция, которая называется std AnyCast.
И я говорю, к какому типу.
Вот, я здесь говорю std AnyCast к Double,
тут я говорю std AnyCast к чему, кстати?
Хонс Чар, наверное, звездочки.
Я, кстати, не уверен, может быть и к String.
Ну, сейчас проверим.
А тут к Intu.
Ну, не суть там.
Если конча звездочка не сработает, напишем String.
Вот.
Да, все работает прекрасно.
Что, если я не отгадаю тип?
Например, вот здесь я напишу
опять AnyCast к конча звездочки, хотя на самом деле там уже вектор лежит.
Ну, ты проиграл.
А что будет?
Ну, нет.
Убе это как-то слишком жестко.
Все-таки нет.
Но будет exception.
Логично.
Bad AnyCast.
Специальный тип exception.
Как он понял, что...
А вот он должен...
Там...
Ну, он должен понимать, какой тип в нем лежит, конечно.
Зачем?
Ну, например, для того, чтобы мы могли
спрашивать его, что в нем сейчас лежит.
А зачем тогда...
Понимать, что в нем лежит, надо и для более прагматичных целей.
Например...
Если он понимает, что в нем лежит, зачем мы ему шаблонный параметр для AnyCast придаем вообще?
Зачем нам вообще AnyCast?
Почему...
Почему тогда этот костюм используем?
Давай...
Вот над каким вопросом задумываемся сейчас.
Допустим, в нем лежит вектор.
И потом я говорю, а равно...
Вот я делаю это.
А я сейчас вопрос напишу.
А как вектор-то уничтожается?
Кто-нибудь вызывает деструктор вектора и в какой момент?
И как он понимает, что надо вызвать деструктор вектора сейчас?
Когда у него типы не совпадают.
А как он понимает, что нужно вызвать деструктор вектора?
Вот именно.
Он должен знать, какой у него тип.
Как минимум для того, чтобы корректно уничтожать то, что в нем раньше лежало.
А зачем тогда мы для AnyCast даем ему тип?
А как бы ты представлял себе это без указания типа?
Ну просто видишь ли, если бы ты не говорил о том, что у него тип...
Ну просто видишь ли, если бы ты не говорил AnyCast, то ты бы...
Что? У тебя было бы A, у A тип Any.
Я не мог бы в SDC Out, например, отдать Any.
Ну это что? Это должно компилироваться или нет, если пишу SDC Out A?
A это Any. Там может быть что угодно.
Ну вообще говоря, не все может выводиться в C Out.
Просто в некоторых ситуациях мне нужно посмотреть на Any как на что-то конкретное.
Чтобы C Out, например, знал, что в него сейчас выводят.
Нельзя сделать тип Any Value, который будет наследником какой-нибудь общей фигни.
Что-что-что? Any Value?
Шарлонный тип Any Value, который типа T.
И он наследуется в какой-нибудь общей фигни.
Мы у себя храним указатель на общую фигню.
Ты сейчас мне расскажешь, как Any реализовать или что?
Ну да.
Спасибо. Молодец.
Ты придумал как резотение.
Классно.
Ну да, ты только что решил задачу реализации.
Там только надо Vertical написать, где надо.
Да, да, так и надо.
Все, можешь идти писать shared PTR.
Тебе это и нужно там сделать.
Только там Deletor и Allocator нужно одновременно разными поддерживать.
Давайте поговорим о том, как реализовать Any.
Действительно, ну а кто, кроме господина Андрусова, да, Андрусов?
Андрусов, да, извиняюсь, понял, что сделать надо.
Как же нам добиться такого поведения, используя известные нам средства языка?
То есть на самом деле я вам сейчас никакой лайфхак не расскажу,
ну в смысле я не расскажу вам сейчас ничего нового,
в смысле каких-то языковых средств, которых мы раньше не проходили.
Надо просто с умом использовать то, что мы уже знаем.
Ну, казалось бы, да, это какой-нибудь указатель на void.
И чего?
Вот если мы будем хранить void звездочку, то как мы будем понимать какой это тип, чтобы его корректно уничтожать?
А вот это уже другой вопрос.
Да, в этом главная сложность.
Сохранить указатель на функцию деструктора.
Да, можно, конечно, сохранить указатель на объект, а также указатель на...
Указатель на метод деструктора.
А также указатель на соответствующие его методы, которые надо вызывать в случае,
когда, например, мы присваиваем один другому, когда мы уничтожаем, когда мы копируем и так далее.
Тяжеловесно.
Нет, это как раз более эффективная реализация была бы.
Но мы сейчас напишем более простую, но менее эффективную реализацию.
Вот именно так, как я сейчас сказал, фанкшн реализована.
Вот именно так.
Потом.
Вот будем реализовывать фанкшн, увидишь.
Пока мы простую реализацию обсуждаем.
Мы, по сути, что вы предлагаете сделать?
Давайте хранить void звездочку, а также хранить поинтеры на методы соответствующие, которые надо вызывать, когда что-то происходит с объектом.
Так я говорю, а зачем это делать, если у нас уже в языке есть механизм, делающий то же самое за нас?
Знаете, как он называется?
Таблица виртуальных функций.
Ведь, по сути, то, что вы сейчас предложили, это давайте напишем свою таблицу виртуальных функций просто для этого объекта.
Но ведь, по сути, у нас уже есть механизм в языке, который нам это и делает.
Он хранит typeinfo, а также указательный на то, что делать с объектом, если с ним деструктор вызвался, что-нибудь еще сделалось, что-нибудь еще сделалось и так далее.
Ну, конечно же, логично, что если мы хотим runtime типизацию, нам нужен runtime полиморфизм, то нам нужно использовать virtual.
Вот вы так много внифпопад говорили, давайте сделаем что-нибудь виртуальным, отнаследуемся виртуально, что-нибудь еще сделаем.
И это было совсем не нужно, в итераторах это все не нужно, потому что там все в шаблонах, там все делается в compile-time.
Вот сейчас настал момент, когда нам нужны виртуальные функции, наконец-то, по-настоящему.
Мы просто сделаем сейчас динамический полиморфизм, мы просто сделаем, что компилятор за нас будет помнить, какой тип там лежит и вызывать ему правильные методы.
А как мы этого добьемся?
А у нас будет следующая...
У нас будет виртуальный деструктор.
Хитрость, конечно, у нас будет виртуальный деструктор.
У нас будет следующая интересная структура, давайте я назову base, в которой будет виртуальный деструктор.
Ну, я даже не знаю чисто виртуально, но давайте я напишу равно default.
Зачем мне виртуальный деструктор?
Ну, для того, чтобы этот тип полиморфным стал.
А теперь смотрите, что я говорю.
Говорите play type name t, struct derived, это наследник base.
Вот.
Что на самом деле происходит?
Что я храню?
А я храню указательно base.
Что происходит, когда я создаю any?
Ну, у меня очевидно должен быть шаблонный конструктор.
Any от t.
Давайте назвать p obj.
И что я делаю?
Чем я инициализирую p obj?
Я говорю p obj это new.
Сейчас, если вы внимательно слушаете лекции, у вас должно быть в глубине неприятное ощущение.
Как же это не new, а как же allocator?
Но нет, мы уже забили на allocator к этому моменту.
То есть мы пишем any, в any тоже нестандартный allocator не поддерживается.
Комитет решил, что нет, это overkill поддерживает allocator.
Тем более мы скоро придумаем allocator, который динамически подменяемый.
Ну так вот.
Использование слишком чрезмерное переусложнение.
New derived с шаблонным параметром t от obj.
А что делает диструктор any?
И о чудо!
Это же корректная работа.
Правда у нас derived еще должен уметь создаваться.
А derived от чего должен уметь создаваться?
От const t obj и что в нем должно быть?
А в нем просто этот объект и будет лежать.
И о чудо!
Вот и все, вот и все работает.
Вот и вся почти реализация.
Я наоборот утверждал, что это работает менее эффективно.
Я наоборот утверждал, что это работает менее эффективно.
Сейчас мы это обсудим, давайте сначала все поймут, что это работает как надо.
Еще правда нам надо оператор присваивания и конструктор копирования, но сейчас мы напишем.
Это называется idioma type erasure.
На самом деле type erasure называется как раз вот это.
Там спорный вопрос, что именно сейчас принято называть type erasure, но вот это классическая type erasure.
Это способ хранить в объекте вещи переменного типа и динамически подменять их.
Почему это корректно работает? Как работает delete p obj?
За счет виртуального деструктора он понимает, что ему реально нужно сделать в деструкторе.
В частности он понимает, что ему надо уничтожить вот это.
Здесь t является полем, но он его тоже корректно уничтожит, потому что деструктор виртуальный, а виртуальный деструктор он корректно отрабатывает на наследниках.
Я уже унаследовался от Base, а у Base виртуальный деструктор.
Это уже значит, что у меня тоже деструктор виртуальный, а значит все будет корректно отрабатывать.
Если бы я здесь не написал вот этого, то все бы конечно не работало.
Работа компилировалась бы, но были бы утечки памяти постоянно.
Ну мы хотим еще оператора присваивания.
Давайте напишем конструктор копирования для начала, вот это интересно.
А еще разве мы не хотим конструктор по умолчанию, который не создает указатель?
Ну как, чтобы я мог сказать std any, я могу сказать auto b равно a, вот я могу так написать?
Как это не могу? Должен уметь.
Нет, со std я могу, это же std any.
Стандартный any конечно можно копировать.
Вот, когда-то это тоже была задачей на отл, но теперь это стало задачей на хор,
потому что язык развивается, как известно.
Так, на самом деле это тоже интересный вопрос.
Как написать конструктор копирования?
Мне нужно написать any от const any % other, давайте скажу.
И что сделать надо?
Конструктор не бывает виртуальными.
Значит, вопрос, что написать? Вот это задача на подумать.
Да, вот мне нужно скопировать any, чтобы все так же получилось.
Откуда я знаю, какой t там был?
Все, тихо молчи, ты понял, давайте еще кто-нибудь поймет.
Он догадался, еще кто-нибудь догадайтесь.
Ну ладно, ну да, надо сделать просто еще одну виртуальную функцию вот здесь.
Давайте я назову ее getCopy.
Ну она будет pure virtual, пускай.
Вот, а здесь она будет реализована, как она будет реализована?
Ну она будет, ну я могу сказать авто, ну нет, мне надо сказать все-таки.
B и звездочка, getCopy, override.
Мы же можем написать rewrite в звездочку.
Где? Здесь? Не, мне нужна функция с такой же сигнатурой, иначе override не сработает, напоминаю.
Ну я делаю override, это значит мне нужно полностью соответствовать.
Вот, и что эта функция будет возвращать? Да просто она будет возвращать, return.
Ну return u derived t от obj.
Да, можно и не писать здесь t.
Соответственно, что должна делать? Должен конструктор копирования, но он должен просто делать pobj,
инициализировать его other, getCopy, да и все.
Нет, other.pobj.getCopy, other.pobj.getCopy, да.
Давайте напишем boop-конструктор.
Ну видимо мы тоже должны делать такой.
А, указатель.
А что намешается брать просто указатель? Да, move-конструктор вообще тривиальный, можно сказать.
pobj просто other.pobj, other.pobj равно nullptr.
Ну можно написать оператор присваивания еще, но не будем.
Вот, такие дела.
std any.
Давайте посмотрим на cpp-reference.
Может быть там еще есть что-нибудь интересное, о чем стоит.
std any, any это конструктор.
Что это похоже на node-based node?
Да что вы говорите, наследование они вообще...
Похоже.
Да, еще похоже на mother и son тоже.
Знаете, была такая чувство.
Крайне с медведем, да.
Ну, к сожалению, cpp-reference нас не радует сегодня.
Ну что, господа, самое время понять, как же устроен shared-ptr на самом деле.
Да, в shared-ptr используются виртуальные функции.
Если вы откроете код настоящего shared-ptr, вы увидите там слово virtual.
Потому что там используется именно эта идиома type-array.
У меня уже было, вот здесь вот, был черновичок shared-ptr.
Напоминаю.
Значит, да, у меня будет пункт 14.2.
Называться shared-ptr with custom deleter and allocator.
Давайте для начала придумаем, как сделать custom deleter shared-ptr.
Все-таки в том примере с base-derived там можно у переопределяемого метода было делать указательный derived, а не на base.
Да.
И override написать, и он бы не ругался.
Это вроде просто захархожено, что так можно делать.
Давай попробую.
Ну ладно.
Значит, можно и так.
Я здесь тип не точно назвал.
Я, наверное, могу просто сказать авто и не париться.
Все.
Надежно.
Так.
Так вот.
Что же с shared-ptr?
Вы помните, какая проблема-то была?
У shared-ptr может быть custom deleter.
И allocator.
Не, но как сказать.
Вы все-таки не хотите, чтобы можно было любой любой объект туда класть?
Надо, чтобы там все-таки лежал allocator какой-то.
Давайте, вам это писать.
Я сейчас не буду реализовывать shared-ptr за вас.
Я только попробую сказать обтекаемо, как его нужно делать, чтобы все работало в нем.
А как вообще, что хранить в shared-ptr?
Мы поняли, что в shared-ptr, вы помните вообще, что в shared-ptr нам хранить приходилось?
У нас, во-первых, был ptr и count.
Но потом мы поняли, что нам нужно на самом деле shared-count и weak-count отдельно.
А потом мы поняли, что у нас вообще еще control-block должен быть иногда.
Иногда нет.
Так вот, есть следующее предложение.
Давайте сделаем структуру base-control-block.
Смотрите.
Я заведу такую структуру.
Base-control-block, в которой будет нечто общее для всех control-block.
А это что?
Это shared-count и weak-count.
А также там будет виртуальная вот эта штука.
Там еще будут всякие штуки для копирования нужные.
А дальше мне нужно два разных control-block.
Один на случай, если осознан через make-shared, а другой на случай, если осознан не через make-shared.
Помните, в чем разница, если осознан через make-shared и не через make-shared?
Если осознан через make-shared, у меня на самом деле две...
Господи, да какой же ты.
Давайте я попробую shared-ptr открыть.
Конструктор shared-ptr я попробую открыть.
Мне нужно посмотреть какие конструкторы у shared-ptr.
Есть две разных ситуации. Я могу создавать shared-ptr напрямую, а могу создавать через make-shared.
Если я создаю через...
Эни прогрузился, я надеюсь сейчас shared-ptr прогрузится.
Если я создаю shared-ptr напрямую, то у меня что может быть?
У меня может быть кастомный deletor, кастомный allocator.
Ну и, собственно, мне надо хранить сам pointer на объект.
Мне надо хранить объект allocator, объект deletor и pointer на сам объект, на t.
Если я создаюсь через make-shared, что у меня может быть?
У меня все еще может быть кастомный allocator, но кастомного deletor у меня уже не может быть.
Кастомный deletor может быть только если я создаюсь напрямую, а не через make-shared.
Потому что если я создаюсь через make-shared, то make-shared за меня создает объект.
Что такое make-shared?
Это за меня выдели память и создай объект.
И тогда deletor считается, что должен...
Кастомный deletor нужен на случай, если в момент удаления вам нужно не delete сделать, а что-то другое.
Но make-shared сам за вас делает new.
Ну тогда у вас не должно быть свободы вместо delete сделать что-то другое.
Если вы создаетесь через make-shared, то есть просите за вас его вызвать new,
то вы тем самым подразумеваете, что вместо, что в момент удаления надо будет сделать delete.
Сейчас, но ведь вот когда мы делали, допустим, delete с локатором, у нас же был...
У нас просили сделать...
Просили выделить память, но не для t, а для base-node.
Нет, это уже другая проблема.
Это rebind локаторов.
Ребайнт локаторов вы тоже сделаете сами.
Ну вот а в чем проблема здесь?
Точно так же для rebind локатора на...
Подожди, я сейчас вообще про другую проблему говорю.
Я говорю про проблему того, что deleter может быть кастомный, а может не быть.
Deleter и allocator это разные сущности.
Понимаете, у тебя может быть одновременно и deleter, и allocator отдельно переданы.
Почему у make-shared у нас нет deleter?
Еще раз объясняю.
Что такое deleter вообще?
Это что за штуковина?
Deleter это функция, это функциональный объект, который с оператором круглые скобочки,
который будет вызван над вашим pointer вместо delete-pointer.
Вы можете хотеть, чтобы sharedptr, когда отпускал ваш объект, когда уничтожал его,
не освобождал память, а что-то другое делал.
Например, закрывал файл, если ваш объект был файлом.
Или разрывал соединение по сети, если ваш объект был сетью.
Или разлучивал mutex, если вы знаете, что это такое.
Если ваш объект был mutex-ом.
Не delete делать нужно в конце, когда вы закончили поле с объектом, а что-то иное.
Deleter это функция, которая выполняется вместо delete над вашим объектом,
когда последний sharedptr на него умирает.
Это понятно, но почему при make-shared нельзя?
Потому что make-shared за вас делает new.
А значит, при удалении надо сделать именно delete, а не что-то другое.
Илья, вот такой вопрос.
Почему эту функцию, эту функциональную нельзя поместить в destructor?
Кого?
Ну, вот то, что мы хотим делать.
Destructor кого?
Destructor кого?
Объекта, на которые указывают наш птр.
Оно не дало видение правого места destructor.
Нет, ну вот допустим, у меня есть sharedptr, который указывает на объект файла.
Почему я в destructor не могу прописать?
Если у тебя хранится указатель на него.
Я же буду вызывать destructor, когда кончились ссылки.
Ну, наверное, можешь.
Ну, тогда тебе в deletre вообще ничего не надо будет делать.
Ну, вот да.
В этом и вопрос. Откуда появилась идея делать deletre?
Просто мне казалось, что специально ровно для этого мы придумали destructor.
Нет, ребята.
Сейчас я подумаю.
Какой-нибудь другой сценарий.
Типа, если у меня соединение по сети, то destructor этого соединения просто делает там разъединение.
Если у меня файл, то destructor этого файла.
Тут, наверное, видишь какой момент.
У тебя эта штука, на которую ты держишь указатель, она может не быть объектом даже.
Но если ты работаешь с каким-нибудь сичным интерфейсом, у тебя указатель на файл, это даже не объект.
Это указатель на какую-нибудь структуру, которая ничего не умеет сама по себе.
Как и socket сетевой.
Он хранит себе какие-то числа, и ничего больше не умеет.
И все, что ты с ним делаешь, в функциональном стиле, ты над ним выполняешь некоторые операции.
И вот в таком сценарии, если у тебя указатель хранит какую-нибудь штуку, которая не в объектно-ориентированном стиле написана, а просто которая...
Сичный pointer на что-то.
Ну, в общем-то, да, если у тебя штука была бы...
SharedPattern хранит сичный pointer.
Это штука, над которой в конце надо, может быть, что-то сделать.
С этим pointer нужно вызвать над ним какую-нибудь функцию.
А сам он не умеет.
Например, сичный файл, дескриптор сичного файла, как он там называется, он не умеет для себя ничего делать.
Да-да-да-да.
Ну, например, такое.
То же самое с сетевыми штуками, если у тебя есть сетевой socket какой-нибудь.
Он точно так же устроен, он ничего не умеет.
Т.е. пилитер, по сути, это такой кастрид для случаев, когда у нас не объект, а дескриптор все-таки нужен.
Ну, типа того, да.
Похоже на то.
Что там?
Кстати, любые сущности, связанные с низкоуровневым программированием, процесс, операционная система.
Такая же фигня.
Т.е. в конце надо будет, может быть, нужно что-нибудь сделать, дождаться, пока он завершится, например.
Но он же в своем деструкторе этого не делает.
Или trap, например, тот же самый.
Он в своем деструкторе ничего не дожидается, он просто грохается.
А вам, может быть, надо, прежде чем он закончится, что-то с ним сделать.
Например, дождаться окончания.
Ну, короче, деструктор объекта и дилитер, это, может быть, разная операция, да.
И, возвращаясь к предыдущей теме, если мы делаемся через make-share, значит, мы не должны нестандартный дилитер использовать.
Следующий вопрос.
Если у нас есть нестандартный дилитер, на кой черт нам еще и нестандартный локатор может быть нужен?
Ну, потому что выделять кого?
Нет.
Если у нас нестандартный дилитер, это значит, что мы создаемся через конструктор напрямую, а не через make-share.
А это значит, что когда мы создаем share-ptr, объект уже создан.
Для чего мы тогда локатор еще передаем нестандартный?
Чтобы контрольный блок выделялся на нестандартном локаторе.
Вот этот вот конструктор, вот он самый непонятный, вот этот вот.
Зачем нам нужен одновременно и дилитер нестандартный, и локатор нестандартный?
А для того, чтобы когда объект закончил жить, мы над ним сделали кастомную функцию, например, там файл закрыли.
Но в то же время контрольные блоки мы выделяли не через new, а через что-то другое.
И освобождали бы контрольные блоки счетчиками через что-то другое.
То есть в данном случае локатор нужен для выделения контрольных блоков, а сам объект уже создан.
И когда он уничтожается, мы не дилит делаем, а вот эту функцию дилитер.
Но локатор кастомный.
Короче, у нас есть два принципиально разных сценария.
Один сценарий мы создали через мейкшерет, другой сценарий мы создали напрямую через конструктор.
И в первом из этих сценариев нам надо хранить только локатор.
Во втором из этих сценариев нам надо хранить и дилитер и локатор.
Я напишу template typeNameT, typeNameU давайте скажу.
struct controlBlockMakeshared
Не призываю вас так ее называть, может вы придумаете название получше.
Да, и это наследник BaseControlBlock, разумеется.
То есть я делаю Type и Rager, но с умом.
Мой ControlBlock он таков, что в нем будет сейчас храниться дилитер и локатор.
Ой нет, через мейкшерет только локатор.
Вот в ControlBlock, который для мейкшерет, только локатор хранится.
Откуда локатор возьмется?
Из шаблона.
А где? Что? Написай.
Ну вот здесь шаблон.
А локатор это будет шаблоны параметра этой структуры, а не самого SharedPTR, для чего мы и старались.
Ну а лок, наверное, равно для локатора?
Нет, давайте вот такими словами бросаться тут не будем.
Короче, а лок.
Это внутренний класс вообще, SharedPTR, это внутренняя структура SharedPTR, мы пока ничего по дефолту не знаем, что хотим.
Вот. Мы будем...
Вот, а лок здесь хранится. А еще что должно храниться?
Ну, наверное, сам Пойнтер, да. Пойнтер на U.
Только заметьте, уже на U, а не на T. Тип-то, вообще говоря, может быть и другим.
Я напоминаю, что у нас все еще может...
Ну, T и U, они могут быть и то, что один наследник другого.
Один может быть мамой, другой папой, а указывают они на сына на самом деле оба.
То есть, типы T и U, это не обязательно один и тот же тип, и даже не обязательно T наследник U или наоборот.
У вас может быть SharedPTR на сына.
Ну, вы можете создать изначально SharedPTR на сына.
Потом его сказать, SharedPTR на маму равно ему, SharedPTR на папу равно ему, а SharedPTR на сына грохнуть.
И у вас будет SharedPTR на маму, SharedPTR на папу.
Оба они указывают на сына и share вот этот вот control-блок.
Хотя у них у обоих тип в SharedPTR не тот, который на самом деле лежит под указателем.
Но все еще это должно работать корректно, при условии, что там у вас виртуальные методы в этом сыне.
Короче, ради поддержки виртуальности.
Ради поддержки наследования, чтобы SharedPTR мог указывать не на...
Наследование у нас диструкция другая, с виртуальностью нормально.
А SharedPTR на T хранит у тебя указатель на U.
И он знает, что хранит указатель на U, и за счет TypeRanger он правильный диструктор вызовет.
Даже если там не было.
Он вызовет диструктор для типа U.
Ну, в смысле, за счет TypeRanger мы, когда будем уничтожать объект, мы вызовем диструктор вот этого control-блока MakeShared.
Но этот control-блок MakeShared он сделает правильную вещь за нас.
Он сделает delete PTR, а PTR это U.
И удалит правильно.
Вот, короче, если у нас вот такая ситуация, то мы храним вот это.
Только ли это или еще что-то?
Нет, не только это мы храним.
Вы вообще помните, ради чего мы MakeShared-то придумали изначально?
Чтобы они рядом лежали, сам объект и счетчики.
Когда мы через MakeShared создаем объект, то мы храним это.
И счетчики, когда мы через MakeShared создаемся, мы объект сами создаем.
Мы сам объект где-то хранить должны.
На самом деле в control-блоке MakeShared мы сам объект храним.
Control-блок у нас вначале для чего был?
Для того чтобы объект хранить.
Вместе со счетчиками.
То есть на самом деле мы храним объект здесь, а не PTR.
Вот.
Так.
Хорошо.
Ну, вроде пока так.
Если у нас control-блок не MakeShared.
Давайте я назову control-блок direct.
Почему мы на локатор выделяем память?
Что?
Почему мы на локатор выделяем память?
Где? Мы пока ничего не выделяем.
Ну, мы по идее действительно новый единик адрес поменяли.
Чего, чего, чего?
Ну, единик адрес, что такое, да?
А, ты про это? Ну да, это вы сами сделаете.
Почему мы на локатор выделяем память?
Да.
Вообще, да.
17 это все через ГБО сделано, как обычно.
То есть эти control-блоки, они еще наследники локаторов и дилитеров соответствующих.
Там все умно.
Если вы начнете STL читать, там все вообще классно написано.
Там еще есть оптимизации на случай, там если, то все.
Ну, короче, да.
Вот.
Если же у нас control-блок direct, то мы храним дилитер.
А локатор и объект.
Указательный объект.
Вот.
В полях самого shared PTR мы храним указатель на control-блок.
На base control-блок, разумеется.
Под который может лежать как один, так и другой control-блок, смотря, что там было сделано.
Да.
Вот.
А еще в полях shared PTR мы будем хранить указатель на T.
Знаете зачем?
А чтобы быстрее доступ к объекту получать.
В shared PTR мы будем хранить не только, в shared PTR мы будем хранить два поинтера.
Один это поинтер на блок, а второй это поинтер на сам T.
Зачем мы в shared PTR в полях храним поинтер на сам T еще раз?
Да чтобы быстро через shared PTR можно было T получать.
Потому что если мы будем так делать, то нам постоянно надо будет два разыминования делать, чтобы до T достучаться.
Shared PTR в себе хранит сам, как поле, тот PTR, за который он ответственен.
Он его пробрасывает из control-блока, хранит, чтобы не делать лишнюю индирекцию, что называется.
То есть мы жертвуем памяти, чтобы повлиять.
Ну да, да, мы в shared PTR хотим, чтобы PTR, наш самый главный, был близко доступен.
Ну какие у нас остались вопросы?
Что еще осталось не обсужденным?
Ну в принципе-то все, я вот такую заготовку написал, с ней уже можно shared PTR идти писать.
Control-блок direct, он вообще используется?
Control-блок direct, это когда мы создали shared PTR через прямой вызов конструктора.
Я все еще не понял, когда мы его используем?
Что значит когда используем?
В смысле, зачем нам этот стракт вообще нужен?
Для type erasure?
Хорошо, я создал shared PTR через прямой вызов конструктора.
Где мне хранить счетчики для начала?
Ты предлагаешь их в полях хранить? Прям в shared PTR?
Ну окей, в control-блоке.
Отлично, в control-блоке.
У меня есть базовый control-блок, вот такой shared count и weak count.
Ты предлагаешь какого типа control-блок хранить в таком shared PTR?
Я говорю, что у меня есть подвид control-блока, вот такой.
В котором есть два счетчика, а также deleter-аллокатор и мой у.
Настоящий.
Ну еще мне надо хранить deleter-аллокатор где-то,
потому что они могут быть кастомными, когда меня создавали напрямую через конструктор.
Кто все понимает до сих пор?
Обожаю, да, да, да.
Зачем нам здесь хранить указатель на u в control-блоке еще?
Может быть и не нужно.
Может быть и без него будет работать, кстати.
Но могут быть проблемы, я боюсь, что будут проблемы с наследованием, если здесь не хранить.
Даже если мы его храним, мы же все равно потом используем test-озвездочку.
Ну что?
Нет, control-блок должен хранить указатель на объект, как он его воспринимает, где начало.
Да, например, смотрите, если у меня множественное наследование, там есть мама, папа, дружная семья, несколько мам, несколько бабушек.
Вот этот control-блок будет хранить u в том смысле, как его настоящий объект.
А Shered-PTR-то хранит указатель на t.
Он воспринимает объект, как экземпляр того t, от которого сам Shered-PTR.
Наоборот, не уверен.
Наоборот, не уверен.
наоборот не уверен так я не знаю как получится да это очень правильный вопрос да это еще
один момент который мы недообсудили я спросил тут все ли хорошо вот это пожалуй последняя
вещь которую надо обсудить да это совершенно ведь подожди нет а локатор нет а локатор
а локатор в мейк шерот выделяет только блок объект уже создан объект создается не
через локатор но точнее точнее он создается может и через локатор но только а локатор не
используется для удаления само объекта локатор когда мы через мейк шерот создаемся а локатор
используется только для создания блока вот да кого мы храним а локатор конечно мы должны хранить
у нас есть функция allocate shared вот давайте о отлично смотрите давайте в качестве завершающего
упражнения напишем функцию allocate shared есть функция мейк шерот которая
type name t type name многоточий arcs которая возвращает shared ptr от t мейк шерот я напомню
что она делает она принимает значит arcs двойной имперсант многоточий arcs и она на самом-то деле
просто выражается через allocate shared мейк шерот это просто allocate shared со стандартным
локатором и вся магия заключена в allocate shared на самом деле эта функция просто делать return
shared ptr ой return нет она делал allocate shared от std а локатор а локатор от чего ну а ты давайте
скажем и std forward от arcs как это я объект я вызываю функцию я передаю объект в нее и на самом
деле самое-то главное интересный вопрос что делает а локатор ну что делает allocate
shared type name t type name alloc type name многоточие arcs shared ptr от allocate shared вот это очень
интересный вопрос но я сейчас не реализую эту функцию целиком потому что ну я проговорю как ее
реализовать ну я типа скажу словами но не напишу вам это предстоит самим написать мне надо здесь
вот этим а локатором выделить штуковину в которой будет одновременно лежать и счетчики и объект
потом мне нужно поместить на нужный адрес мой объект и запомнить а локатор мне дали на t а
локатор мне дали для того чтобы я им выделил память я должен этим локатором выделить память
под свой контрол блок а потом положить на нужный адрес из в этом вон друге свой объект то есть
я должен сказать то есть я сейчас должен да я сейчас должен сделать rebind этого локатора на тип
до блог какой да я сейчас должен сделать rebind а локатора на тип контрол блок мэйк шерет
с таким типом и таким аллок как мне дали вот дальше я на том локаторе который получился делаю
allocate 1 я не буду это писать потому что сами напишите это это часть задачи я сейчас rebind
же локатор на то чтобы он создавал мне контрол блок говорю на этом локаторе allocate 1 штуку потом
на этом же локаторе ну на самом деле кажется даже не на локаторе просто через new потому что
мне локатор не нужен для создания объекта я просто могу placement new положить по нужному
адресу внутри контрол блока уже я знаю где он уже наш объект из тех аргументов которые мне дали
я не уверен что локатор так делает возможно кстати это изменилось начиная с си плюс плюс какого-то
да но да но я говорил что когда мы делаем через мэйк шерет allocate шерет локатор нужен только
для блока они для объекта я не помню это менялась от стандарта к стандарту я не помню по моему до
си плюс 17 не использовался локатор для того чтобы констракт вызывать дело здесь потом начал
использоваться уточните на себе переэфференциал locate шерет использует прям констракт или
placement new чтобы сконструировать по моему это изменилось си плюс 17 то есть раньше он использовал
потом стал использоваться локатор короче мы делаем либо констракт либо placement new по
нужному адресу этим локаторам а потом сам этот локатор ну точнее вот этот объект локатора
который нам далее вместе со всем тем чем надо кладем вот этот блок ну и там же его и сохраняем
то есть вот этот лок который нам далее мы в тот самый блок и кладем как поле нам надо заполнить
этот блок всеми этими штуками и там счетчик вот и там счетчики правильно проставить последний
вопрос последний вопрос а что делать когда мне нужно уничтожить объект но еще не уничтожать
блок помните если у меня на объект существует закончились указывать шерет птр но еще остались
то мне надо деструктор у вызвать вот здесь но контролл блок еще должен оставаться в памяти и
контролл блок впоследствии мне надо будет освободить локатором но у меня тайп и рейджер вот этот
контракт вот деструктор этого контролл блока должен вызваться в самый последний момент когда
я уже уничтожаю контролл блок у меня должен уничтожаться объекту локатора в частности то есть
когда будет умирать послед kimse вик птр должен вызваться диструктор вpr блок мейк � Suit но
при этом диструктор у должен быть вызван до этого а в момент когда будет умирать контролл
блок мэйк шерет деструктора уже не должен вызываться он раньше был вызван что же делать
что вот именно проблема в том что когда я буду в самом конце когда будет умирать вик птр буду
уничтожать контрол блок мэйк шерет вызовутся деструкторы всех полей неизбежны как подошли
виртуальный диструктор он вызовет диструктор и этого аллок этого у но диструктору уже должен
был быть мной вызван когда умирал шерет птр а когда мэйк птр диструктору нельзя вызывать уже
то есть когда будет умирать контрол блок мэйк шерет мне надо вот это поле избежать его вызову
диструктора каким-то чудом как же мне этого это сделать кого мунуть на самом деле короче на
самом деле мне здесь придется это у хранить не как у а как массив чаров потому что мне вручную
нужно решать когда его диструктурирует но можно как илайн storage да то есть я здесь напишу чар
элайны ну там чар значит илайн с илайн с у чар сайз офу обж вот вот для чего да потому что
когда будет умирать последний век птр иначе он диструктурирует тату а он уже был уничтожен
дважды выдастся диструктурируй потому что это массив чаров я рассказал все что планировал
сегодня на этой торжественной счастливой ноте я вам выдаю четвертую задачу шерет птр
сейчас пара закончилась но если хотите можно задать вопросы да и кстати можно поздавать еще
