Ну что, мы начинаем нашу лекцию, наконец, в таком карантинном
режиме.
Надеюсь, что в следующий раз у нас последнее занятие
в таком виде будет, ну а пока живем так, как можем.
Сегодня, в прошлый раз мы говорили про то, как строить
масштабируемые системы, мы до этого долго говорили
о строительстве заустойчивой системы, в прошлый раз мы
поговорили о строительстве масштабируемой системы,
как в них искать узкие места и с помощью каких-то
трюков, не знаю, идей, можно их преодолевать, а сегодня
мы поговорим про несколько другую задачу, точнее про
ту же самую задачу, но немного в другой момент времени.
Вот, предположим, мы не то чтобы прямо сейчас пишем
распределенную систему, а мы только задумали ее написать,
мы примерно понимаем, что она должна делать, разумеется,
мы там, не знаю, решили построить кивурию хранилища или
файловую систему, или сервис блокировок, или что угодно.
Мы, наверное, собрали требования, какого поведения мы от
него ожидаем?
Ну, например, мы ожидаем, что наша система должна
быть ренеризуемой, наша система должна масштабироваться
определенным образом, наша система должна переживать
отказ вот такого-то числа узлов, такого-то числа датацентров,
такого-то числа регионов, потеря такого-то числа регионов.
Отлично!
А теперь нужно сделать все остальное.
То есть, нужно придумать дизайн, нужно как-то его
провалидировать, и нужно написать корректную реализацию.
Вот сегодня нас будет интересовать не вопрос, не знаю, отказа
устойчивости определенных алгоритмов или масштабируемости
определенного дизайна, а вот, в принципе, как, имея
некоторую задумку, получить корректную систему, корректный
код.
То есть, реализацию, которая в конечном итоге будет
соответствовать заранее поставленным требованиям.
Будет очень неприятно, если мы будем писать большую
систему, будем писать ее не один год большими силами,
то, кажется, что она реализуемость не способна нам обеспечить
и по каким-то фундаментальным причинам, которые были...
То есть, ошибка была допущена где-то в самом начале дизайна.
Так вот, давайте подумаем, как же не получить такую
неприятность.
То есть, у нас есть некоторая задача большая, сделать
файловую систему, сделать кивалию хранилища, сделать
базу данных.
И вот мы приступаем к дизайну.
Как нам...
Ну, это как-то очень сложно.
Сначала мы вообще просто хотим дизайн как-то придумать.
Вот, допустим, мы придумали, выбрали какие-то алгоритмы,
выбрали компоненты, декомпозировали нашу систему на какие-то
отдельные подсистемы, сформулировали гарантии для них, подумали,
через какие протоколы внутри эти гарантии будут достигаться,
подумали про взаимосвязь этих компонентов.
Ну, и готовы писать.
Ну, или не готовы, или, точнее, что значит мы придумали?
Вот мало же просто придумать.
Ну вот, идеи рождаются в чьей-то голове, но нужно
же из головы эти идеи вынести для того, чтобы эти идеи
можно было бы обсудить с другими людьми, ну и вообще
провалидировать, насколько они разумны.
Вот так рождается понятие дизайн документа.
У нас есть какая-то сложная задумка, она в нашу голову
не помещается, но ее сложно в таком виде презентовать,
поэтому мы пишем дизайн док.
Ну вот давайте я покажу примеры.
Вот дизайн док как rowHDB, надеюсь, мне сейчас видно.
А они публичные?
Дизайн док и публичные?
Ну зависит, если ты пишешь Google Spanner внутри Google, то конечно
же они не публичные, но если у тебя open source база данных,
то ты хочешь сделать процесс разработки и верификации
дизайна прозрачным для людей, ты хочешь, чтобы люди
верили, что твоя система работает корректно, поэтому
конечно ты публикуешь дизайн документа и весь процесс
разработки ведешь открыто.
Ну вот дизайн документ как rowHDB и не думаю, что прям
по нему шла разработка.
А я давно уже должен все показывать и ничего не
показываю, к сожалению, да?
Ну вот, я долго показывал экран с тектоником, потому
что вот пример файловая система, которая большая,
сложная, нужно как-то ее задизайнить.
Мы в прошлый раз говорили, что вот там есть такие компоненты
Metastore, Chunkstore, пленская библиотека, так вот, мы хотим каким-то
образом дизайн презентовать, но мы можем, конечно, картинку
нарисовать, но одной картинки мало, скорее всего, мы хотим
снабдить эту картинку какими-то подробностями.
Ну и для этого мы пишем дизайн док, и вот я сейчас
показываю вам дизайн док как rowHDB, который был написан
когда-то еще давно-давно и с тех пор стала скорее
документация архитектурная про систему, есть более
полная версия, но вот это то, что было примерно
в начале.
Ну и мы уже в прошлый раз, по-моему, его смотрели,
тут есть слой SQL, слой кивалиохранилища, отдельные узлы, которые
хранят реплики диапазонов, и эти реплики реплицируются
с помощью протокола консенсора.
Ну в общем, мы пишем такой документ и описываем в нем
разные компоненты или разные слои архитектуры, вот здесь
есть слой непосредственно репликации данных и распределения
данных, а есть слой распределенных транзакций, и вот как все
транзакции работают, тут подробно достаточно описано.
Вот описана модель согласованности, которую мы предоставляем
для транзакций, это строгая сериализуемость или в контексте
отдельного ключа или нерезуемость, ну про транзакции мы будем
говорить в следующий раз, пока это не очень важно,
что именно это означает.
Главное, что вот такие секции есть, ну и какие-то технические
детали, как именно данные представлены в киеварюхранилище,
как там хранятся метаданные, как балансируется нагрузка.
В общем, все такие детали мы описали для чего, для
того чтобы, во-первых, в конце концов, по этому дизайн-доку
можно было бы писать код и сверяться с ним, а во-вторых,
чтобы провести дизайн-ребью.
Вот подобно тому, как вы там, не знаю, пишете какой-то
багфикс или какую-то маленькую фичу в какую-то маленькую
библиотеку и выкатываете полреквест и его ревьюют
более опытные разработчики, скажем, вот точно так же
происходит и с дизайн-ребью.
Смысл тот же самый, только мы проверяем не какую-то
конкретность не пид-кода, а мы пытаемся валидировать
дизайн.
Вот собирается комитет из опытных разработчиков
и они обсуждают, насколько такой дизайн соответствует
заявленным требованиям, насколько он эффективен,
можно ли сделать иначе, можно ли сделать лучше,
где есть слабые места, где есть узкие места при масштабировании.
Эта стадия необходима для любой большой системы,
потому что, мы уже говорили, системы распределенные
устроены довольно сложно и писать их долго.
Пишутся они несколько лет, поэтому, и конечно же
мы пишем систему для того, чтобы потом от нее кто-то
существенно зависит в нашей инфраструктуре.
То есть мы пишем огромную файловую систему, чтобы
хранить в ней все данные нашей компании.
Вот будет неприятно, если мы подадим несколько лет,
а потом поймем, что мы провалились на стадии дизайна.
Так что стадия дизайн-ребью критически важна.
Вот давайте я покажу вам дизайн-дог более актуальный.
Это дизайн-дог транзакций и экзектифанс-семантики в Кавке.
Кавка у нас будет в другом курсе.
Это система, которая реализует персистентную очередь сообщения,
то есть позволяет продюсерам и консюмерам обмениваться
большими потоками данных.
И в какой-то момент в этой системе потребовались
транзакции.
То есть мы хотим автомарно отправлять сообщения сразу
в несколько экологических потоков, не связанных между
собой.
Ну или, что примерно то же самое, экзектифанс-семантика,
но сейчас про это говорить подробно невозможно.
Ну, суть в том, что вот был написан дизайн-дог очень
большой.
Вот тут 67 страниц.
Точнее даже не то, чтобы один дизайн-дог, а как бы
итерации дизайн-документа, который вот… дизайн-документ
развивался с течением времени, ну вот примерно там, не знаю,
год или полтора.
Вот.
И в случае с этой системой дизайн-ребью было публичным.
Ну, то есть люди со всего интернета могли прийти,
читать этот глугодог и там комментировать, и остались
какие-то, не знаю, замечания, идеи.
Вот этот процесс длился достаточно длительное время,
и потом в конце концов дизайн зафиксировали и пошли
его писать.
Вообще, процесс должен быть хорошо знакомым вам,
в смысле вот дизайн-ребью, потому что, скажем, любой
язык программирования развивается по тем же самым
законам.
Вот, не знаю, вы Google хотите добавить в Go-дженерики,
и вы пишете дизайн-документ.
И вот с дженериками в Го, кажется, была точно такая же
ситуация.
Дизайн-документ написали, а потом его публично обсуждали.
Ну, или в языке Rust в позапрошлом году добавляли AsyncAwait.
Ну, что-то похожее на коротина C++.
И там тоже были разные стадии дизайн-документы и публичное
обсуждение.
Ну, вот для этого...
Почему это Swift?
Неправильные ссылки.
Непорядок.
Вот.
Для таких обсуждений у Rust есть просто свои собственные
форумы, где можно обсуждать те или иные пропозалы.
Ну, совершенно стандартная история, знакомая вам для
языков программирования, вот то же самое происходит
в распределённых системах.
Ну, в разработке любых крупных проектов.
Распределённых систем особенно, потому что...
Ну, в чём сложность распределённых систем?
В том, что они пишутся долго, и в том, что в них много
недетерминизма, много конкарнсия.
И вот такие вещи одному человеку в голове уж тем
более сложно очень превалидировать.
Нужно, чтобы на его дизайн посмотрели другие люди.
Ну вот, такая задача.
Проводим мы дизайн-ревью.
Там показываем вот такие документы, обсуждаем такие
документы, смотрим на вот такие вот картинки и принимаем
решение.
Всё, идём писать систему.
Вот в таком подходе есть некоторая уязвимость.
Понятно ли она?
Ну, наверное, мы не можем предугадать сразу какие-то
небольшие детали реализации, которые вообще могут в принципе
как-то повлиять на...
Ну, смотри, какие-то небольшие детали реализации могут
повлиять, но скорее, я бы сказал, что не могут.
Они могут повлиять, в смысле, какого масштаба детали
ты...
Про какого масштаба детали ты говоришь?
Вот скажем, мы долго обсуждаем, что если мы вот положили
в основу системы консенсус, то мы сможем добиться
реализуемости.
А если мы хотим добиться реализуемости, то нам в
обратную сторону необходимо иметь консенсус.
И вот если мы задумали, что у нас система что-то там
упорядочивает, но при этом внутри консенсус не использует,
ну, например, мы решили написать GFS, вот так это
написано в статье, то, конечно же, мы ни на что рассчитывать
не можем.
Но я бы не сказал, что вот такую деталь трудно не заметить.
Как бы очень трудно понять, что GFS, очень не трудно понять,
что GFS необходима для бродкаст на уровне перезапись,
на уровне перезапись отдельных чанков.
То есть, скорее, наш курс как раз про это, про то, что
какие-то важные свойства распределенных систем,
они зависят от каких-то больших задач, которые сложно
просмотреть.
Ну, конечно, можно сказать, что мы обсуждаем здесь
не такой, как бы не то чтобы прямо высокоуровневый
дизайн, мы можем обсуждать реализацию какого-то отдельного
компонента, и там такие проблемы уже могут быть.
Но на уровне дизайн-ревью нас, наверное, не интересует,
ну, не знаю, используем ли мы где-то в коде там, не
знаю, вектор или дек, что будет лучше работать у нас.
Конечно, нам такие частности не важны.
Проблема, о которой я хочу сказать такая, вот картинки
и такой дизайн-документ, такой вот текст на английском
языке, он хорош, пока люди его понимают одинаково.
Но такое происходит не всегда.
Вот я вам показывал на лекции про Singular Greek Access, статью
по Access Made Simple, и там вот, и показывал вопрос на Stackoverflow,
где какой-то человек обнаружил, что там есть какая-то неоднозначность,
какая это неоднозначность, и интерпретировав какое-то
предложение на английском языке неправильно, можно
получить некорректный алгоритм.
Ну, наверное, если вы понимаете, что происходит, вы интерпретируете
его правильно, и обо всем вы сами догадаетесь, но
мы бы хотели такие неоднозначности устранить.
Вот естественный язык нам в этом не помогает, потому
что естественный язык по устроению неоднозначно,
мы не можем эту неоднозначность из него исключить.
Ну, можно поступить альтернативным способом, если мы хотим
объяснить людям дизайн так, чтобы они ни в чем не
сомневались, мы можем написать код.
Ну, в конце концов, вы говорите, например, соседу,
как работает merge sort, делим массив пополам, сортируем
левую часть, сортируем правую, потом сливаем.
Ну, вроде бы все понятно, но если вы увидите код,
вам будет гораздо проще разобраться, что именно
происходит, и как именно все работает, как именно
сливается.
Или мы говорим в коэксорте, делим массив каким-то
ведущим элементом на две части, тут же великая множество
вариаций, как это можно сделать, ну и большое количество
возможностей ошибиться в этой процедуре.
Так что, как говорил Linux, покажите мне код, вот гораздо
приятнее посмотреть на код, но в распределенной системе
мы не можем сразу написать код, конечно же, это займет
несколько лет, но не знаю, мы могли бы написать для
каких-то ключевых компонентов, ну какую-то маленькую, референсную,
упрощенную, неэффективную реализацию.
Ну, такой proof of concept, что вот в принципе такое можно
было бы сделать.
Ну, это, конечно, немалые усилия, и мы получаем
проблемы другого рода.
Вот текст на английском языке, на любом естественном
языке неоднозначен, код программы очень однозначен,
но в нем появляется очень много деталей, которые нерелевантны
дизайну.
Ну, вот если мы пишем какой-нибудь, если мы используем какой-то
контейнер в коде, то вот мы смотрим на этот код и
думаем, а этот контейнер здесь важен или он просто
выбран спонтанно, потому что нужно было что-то написать.
Вот.
Ну, не знаю, нам нужно думать про локации памяти, нам
нужно думать про… ну, в общем, появляются какие-то
инженерные детали, как именно вы на языке эту реализацию
напишете, ну, потому что язык заставляет вас использовать
довольно низкий уровень абстракции относительно
вашего дизайна, и вы делаете больше, чем нужно.
Так что и язык программирования, и дизайн Doki несовершенны.
Ну, как, вернее, если вас смущает, что в вашей референсной
реализации упрощенной будет много каких-то инженерных
подробностей, неважных для вашей системы, например,
вы выбрали там, не знаю, карутины вместо файберов
или колбеки вместо файберов или акторы, что-нибудь такое.
Это же для дизайна, скорее всего, неважно, ну, может
быть, тоже важно, но, допустим, на данном уровне абстракции
не важно, а вам нужно какой-то код написать.
Поэтому, ну, что вы можете делать?
Вы можете написать комментарии к этому коду, что, ну, вот,
не обращайте на это внимания, вот, главное, что, вот, в
общем, понятно, что комментарии полезны в коде, но, как бы,
на стадии дизайна, где все очень подвижно и все часто
меняется, комментарии запросто могут с кодом разойтись.
Ну, и комментарии вообще, в принципе, так себе в форме
документации.
Далеко не идеально для задач дизайна.
Ну, вот, у нас есть дизайн-док на языке, не знаю, человеческом
каком-то, и есть программа на языке программирования.
И вот и то, и другое в качестве описания дизайна не совсем
нам подходит.
Нужно что-то более строгое, чем естественный язык,
и все же не такое подробное, не такое детальное, как код
на языке программирования.
Ну, как вы, не знаю, изучаете алгоритмы?
Наверное, вам показывают какой-то псевдокод, на доске
его пишут, например.
Вряд ли вы в алгоритм изучаете прямо сразу на C++, по реализации
на C++.
Вот.
Ну, псевдокод тоже инструмент далекий от идеала, потому
что вы, наверное, заметили в своей жизни уже, что сколько
книг по алгоритмам, столько вариантов псевдокода существует.
Каждый автор изобретает свой.
И получается, что вам заодно нужно будет объяснить вместе
с своим дизайном этот псевдокод, как он устроен.
Псевдокод неформален, вот в чем беда.
Хочется в этом месте иметь какой-то большую степень
формализма, большую степень строгости.
Ну вот, вы представьте, вы строите дом и приходите
к строителям и говорите, мне нужна крыша, мне нужна
два этажа, мне нужна веранда рядом.
Это примерно дизайн-документ, какие компоненты в системе
есть.
Наверное, вы что-то про них напишете, но по такому
дизайн-документу сложно написать код, сложно построить
дом.
Вот Лэмпард говорит об этом же, что дом невозможно
построить без чертежей, вот так же для распределенной
системы любого большого проекта вам тоже нужен такой
своеобразный чертеж.
И этот чертеж – это формальная спецификация.
То есть это некоторый формальный вариант псевдокода, формальная
система, где у вас есть строгий синтаксис и строгая
семантика.
И вот если вы придумаете себе такую систему для
спецификации вашего дизайна, то ее невозможно будет
понять неоднозначно, просто потому что мы говорим про
какие-то математические объекты математическим
языком.
То есть такая спецификация могла бы служить нам в
идеальной документации системы.
Но давайте я покажу вам, у меня сегодня очень много
ссылок открыто, я боюсь у них всех потеряться.
Вот мы смотрели с вами алгоритм RAFT не так давно, я вам показывал
вот страница с его спецификацией, вот написано, что какие
бывают узлы в RAFT, какие сообщения по сети летают
и как каждый узел на эти сообщения реагирует.
Может быть, эту реализацию можно понять неоднозначно.
На этот случай у RAFT есть референсная реализация
на C++.
Вот иллюстрация тезиса про то, что код может быть
слишком подробным.
Вот мы говорим handle append-endress, смотрим на обработчик сообщения
append-endress и тут какие-то детали про protobuf и какие-то
блокировки.
Вот в спецификации RAFT ничего нет про блокировки,
это детали реализации постороннего протокола репликации,
а в реализации они есть, потому что в реализации
нужно решать, как выразить конкарнси на уровне языка
программирования.
Так что вот эта страница, возможно, не слишком формальна.
Этот код, возможно, чересчур детализирован деталями
конкарнси в языке C++.
И ровно поэтому авторы алгоритма RAFT написали вместе
и с тем, и с другим еще и спецификацию на языке
TLA+, про которую мы сегодня будем говорить.
Вот эта спецификация, она, конечно, больше, чем страница
кода, тут вот 500 строчек, но с другой стороны, она
гораздо меньше, чем реализация на C++, и в отличие от страницы
с спецификацией в статье, эта спецификация абсолютно
строгая.
Сейчас, я вроде бы транслирую экран.
То, что вы показываете, это и есть спецификация?
Да.
Но это же не похоже, смотри, это похоже на псевдокод.
Какие-то очень странные символы.
Очень странные символы, но мы разберемся, что они
значат.
Во-первых, они не странные, это вообще конъюнкция.
Ты, наверное, такое в своей жизни уже видел.
Это что-то такое декларативное очень, и что приятно, вот
эта спецификация, ее сложная, если ты знаешь язык TLA+, если
ты знаешь, что такое логика, то ты можешь прочесть спецификацию
так же, как и я.
Ты не сможешь ее прочесть иначе.
Вот сегодня мы поговорим, как можно писать такие
спецификации, и вообще, как придумать такой вот
язык для спецификаций.
Мы будем говорить не о формальной спецификации
вообще, а о спецификации на конкретном языке, который
придумал Лесли Лэмпард.
Это язык TLA+.
Почему именно он?
Потому что это самый востребованный индустрией инструмент.
Вот давайте я покажу вам статью, которую написали
в Amazon, в дареком уже 2014 году, про то, что это статья,
которую писали инженеры облака Amazon, и, конечно, они
пишут нагруженные конкурентные распределенные системы.
И вот они говорят, мы используем дизайн-ревью, мы используем
код-ревью, мы используем статический анализ кода,
мы используем стресс-тесты, мы используем fault injection.
Но все равно этого не хватает по разным причинам.
Мы пишем сложные конкурентные и отказоустойчивые системы.
И, конечно же, люди, которые валидируют дизайн тех
или иных компонентов, там протоколы репликации,
они не могут в голове перебрать все возможные исполнения.
Вот, а fault injection, он тоже не обеспечивает полное
покрытие всех возможных сценариев.
Поэтому мы хотим решить две задачи, на самом деле,
на месте инженеров Amazon.
Во-первых, мы хотим иметь язык для спецификации для
того, чтобы просто документировать наш дизайн максимально
строго.
Вот, об этом они писали и в своей недавней статье,
уже 20-го, кажется, года, миллионы маленьких баз данных
про...
В общем, неважно даже сейчас, что это за система, которую
они здесь пишут.
Важно, что они используют CLI plus по двум причинам.
Во-первых, спецификация на CLI plus – это просто хорошая
форма документации распределенных протоколов, а во-вторых,
если вы смогли описать свой дизайн на некотором
формальном языке, то, ну, его, если это язык формальный,
то его может читать уже не только человек, а еще и
компьютер.
И для такой спецификации можно написать model checker,
то есть программу, которая по этой спецификации, в
которой описана система и описаны ее свойства, может
механически проверить, что система удовлетворяет
этим свойствам.
Но это не совсем доказательство, скорее, это полный перебор,
то есть мы можем перебрать все возможные достижимые
состояния системы и проверить, что свойства исполняются
во всех состояниях или на всех возможных траекториях
поведениях.
Вот, но, тем не менее, это второй важный бонус, который
мы, используя формальную спецификацию, получаем.
Мы можем использовать model checker, и для CLI plus, конечно
же, model checker есть, он называется TLC.
Никто не знает, что значит TLC, расшифровка этого сокращения
утрачена.
Но, тем не менее, вот этот model checker, что он позволил
сделать в Амазоне еще в 2013-14 году.
Вот пример систем, который инженеры специфицировали
и валидировали, верифицировали с помощью model checker для
CLI plus.
Самые разные компоненты, самые разные системы, от
каких-то логов и структур данных до протоколов, репликаций
и каких-то сетевых патоколов.
И вот, пожалуйста, размер спецификации, который был
получен, ну и везде он несоизмерим, конечно, с объемом кода,
который нужно было в том или ином компоненте написать.
И при этом эти спецификации и model checker помогли найти
какие-то баги, ну или убедиться, наоборот, что их нет, и мы
дальше можем использовать эту страшную логовую структуру
данных.
Вот, наша задача сегодня разобраться с этими инструментами,
поговорить про то, что уже придумал Лесли Лэмбард
и как можно с помощью такого инструмента описывать
и протоколы репликации, и какие-то, и более крупный
дизайн.
Вообще, Лесли Лэмбард придумал это все давным-давно, и
его не интересовала задача верификации, ему нужен был
способ просто строго излагать свои алгоритмы, и он придумывал
язык для себя.
Ну и уже позже для него написали model checker и стали
использовать в индустрии для верификации какого-то
промышленного дизайна.
Ну и, конечно, да, Amazon это не единственный пример компании,
которая использует формальные методы при разработке своих
систем.
Сейчас, после этой статьи, спецификации стали более-менее
общим местом, и, скажем, если мы посмотрим на какую-то
современную базу данных, TitaniumDB, то у них есть репозитории,
где они формально описали, ну, там RAFT и какие-то его
вариации, и протокол распределенных транзакций.
Вот можем пойти в этот репозиторий и посмотреть на какую-то
спецификацию размера, ну, такого среднего размера,
400 строчек.
Вот, как РОЧДБ, который я упоминал в самом начале,
для него тоже есть спецификация.
Ну вот, можно открыть, сейчас найду, их пост про транзакции,
про дизайн транзакции в их инженерном блоге.
И там они ссылаются на свою реализацию, свою спецификацию
этого протокола.
Вот это такой приятный довес к этому дизайн-документу
и вот к секции про транзакции.
Конечно, никто вас не заставляет спецификацию расшифровывать
с нуля, не понимая, что у них происходит.
Скорее вы читаете спецификацию, после того вы прочтете
документ на естественном языке и уже более-менее будете
понимать, из каких компонентов, деталей состоит система
или алгоритм какой-то.
Но для того, чтобы добиться строгого формального
понимания, вам все-таки нужно читать его спецификацию
на языке тела и плюс.
Итак, давайте теперь говорить про то, как этот язык устроен,
как устроена спецификация, что это вообще такое.
И мы перемещаемся на доску.
Итак, мы хотим каким-то образом специфицировать нашу
систему строго.
Что вообще это значит?
Ну, я бы сказал, что мы хотим написать для нее такой
строгий стресс-тест.
Вот у нас есть некоторый алгоритм, например, алгоритм
консенсус, там есть узлы, которые договариваются
в общем значении.
Так вот, мы не будем описывать сам алгоритм в вакууме,
мы строго опишем тест, в котором есть, скажем, три
узла, и они обмениваются сообщениями и с помощью
протокола Paxos договариваются об общем выборе.
То есть у нас есть некоторый такой мир, некоторая система
и набор свойств.
Вот эта спецификация.
Давайте теперь думать, как эта спецификация должна
быть устроена.
То есть как мы опишем строго, на каком формальном языке
мы опишем систему нашу и на каком формальном языке
мы опишем свойства этой системы.
Вспомним лекции про невозможность консенсус и про теорему
FLP.
Там мы говорили про произвольный алгоритм консенсуса
и показывали, что у него обязательно есть лайфлог.
Для того, чтобы говорить про произвольный алгоритм,
мы этот алгоритм заменили в уме на граф конфигурации.
Мы сказали, что у нас есть направленный граф,
где каждая вершина конфигурация это
снимок текущего состояния всего исполнения.
Это состояние сети, то есть те сообщения, которые были
отправлены узлами, но еще не получены адресатами
и находятся в проводах, плюс состояние каждого узла.
Вплоть до того, что мы фиксируем их регистры,
состояние памяти, состояние жесткого диска,
всю эту информацию.
Все это вместе составляет конфигурацию.
Между конфигурациями были атомарные переходы.
Если в этой конфигурации в сети
было сообщение М, адресованное узлу П,
то мы могли это сообщение доставить
и получить новое состояние мира, где изменилось
состояние узла, которое сообщение получил,
и, возможно, изменилось состояние сети, потому что
начало сеть новое сообщение.
Все возможные исполнения мы представили в виде графа.
Каждая траектория в этом графе – это какое-то конкретное исполнение.
И это конкретное исполнение в те времена ФЛП
выбирала отверсия, который стремился алгоритм
загнать в лайфлог.
В спецификации сама система описывается примерно таким же образом.
Как именно это представить в языке,
в смысле как мы именно описываем этот граф,
мы отложим этот вопрос на будущее.
А пока поговорим про свойства.
Я напомню, что нас не интересуют все возможные свойства,
которые только можно вообразить.
Свойства относительно алгоритма, вернее, этого графа,
который по этому алгоритму порождается
для какой-то фиксированного числа узлов,
который в консенсусе участвует.
Свойства нас интересуют как правило двух типов.
Свойства safety и свойства liveness.
Первый класс свойств о том, что не происходит ничего плохого,
и liveness свойств о том, что eventually происходит что-то хорошее.
Эти свойства – это утверждение про нашу…
На всякий случай я поясню еще раз.
То есть эта система не имеется в виду, что распределенная система база данных,
а имеется в виду такой мир, в котором есть участники,
которые реализуют некий протокол.
Это может быть буквально распределенная система с клиентами,
или это могут быть узлы, которые решают задачу консенсуса.
И вот эту систему, этот мир я изображаю в виде графа конфигурации
с какими-то атомарными переходами, видимо, по доставке сообщений.
А дальше мы про эту систему строим какие-то утверждения.
Мы говорим, что с ней не происходит никогда ничего плохого,
или что с ней происходит нечто хорошее рано или поздно.
Вот эти утверждения вроде бы в общем про систему,
но можно сказать чуть локальнее.
Вот safety свойства – это, например, что…
Представим себе, что у нас система – это мьютекс по разделению памяти
и несколько потоков.
И мы хотим убедиться, что мьютекс гарантирует взаимные исключения.
Например, safety свойства – это взаимные исключения.
Вот взаимные исключения в терминах этого графа – это утверждение про что?
Ну, про весь граф разом или про…
Про какую структуру в этом графе?
Вот если мы говорим про мьютекс и потоки, то каждая конфигурация фиксирует
некоторую точку у исполнения, то есть инструкцион-поинтер каждого потока
и состояние разделяемой памяти, в том числе там какие-то ячейки внутри этого мьютекса.
Вот утверждение взаимного исключения.
Свойства взаимного исключения.
Во-первых, это свойство safety, мы, наверное, понимаем все.
Это утверждение, что ни в какой момент времени не бывает такого,
что два потока одновременно находятся в критической секции.
Это утверждение про весь граф или про что?
Итак, вопрос мой понятен был.
У нас есть система, например, это потоки, которые пытаются взять блокировку,
и мы рисуем граф всех возможных состояний в таком исполнении,
где у нас есть четыре потока и один мьютекс.
Мы говорим, что для такой системы мы формулируем свойства взаимного исключения.
То есть не может быть такого, что два потока находятся одновременно в критической секции.
Вот это свойство взаимного исключения.
Это утверждение про весь граф в целом, про отдельные его пути, про что.
Это утверждение про каждую конфигурацию, про каждый узел этого графа.
А если мы говорим про свойства свободы от взаимной блокировки,
то есть если у нас мьютекс свободен и его пытаются захватить несколько потоков,
то одному из них это удастся.
Deadlock freedom.
Это ваивное свойство про то, что eventually что-то произойдет.
Вот это утверждение про что?
Ну, явно уже не про отдельную вершину, не про отдельную конфигурацию.
Может, про то, что из каждой вершины есть переход какой-то следующий?
Не понятно, как это связано.
Переход есть, ты ходишь по бесконечному пути, и в нем ничего хорошего не происходит.
Где же этот deadlock freedom? Это deadlock.
Возможно отсутствие циклов, но...
Что значит отсутствие циклов?
Непонятно, что значит отсутствие циклов.
Если у тебя есть мьютекс и четыре потока,
мьютекс на одной ячейке памяти с флажками 0,1 и 2, если вы помните, можно было такое написать,
то в этом графе просто конечное число вершин.
Исполнения могут бесконечно долгими быть, если мы напишем
несколько потоков, которые будут в цикле wild true захватывать мьютекс и отпускать его.
Но цикла там, конечно, будут, потому что состояние мьютекса в состоянии системы повторяется.
Вы не понимаете мой вопрос.
Свойство взаимного исключения — это утверждение про каждую вершину графа.
А свойство прогресса для мьютекса — это утверждение про весь граф разом,
утверждение про отдельную вершину и про что.
Нет, это утверждение про каждую траекторию в этом графе, про каждый путь.
Для каждого пути в этом графе должно выполняться следующее,
что в какой-то момент какой-то поток в этом пути, в этой траектории мьютекс захватывает.
В том-то и дело, что safety свойства — это утверждение про каждую вершину графа.
Live in свойства — это утверждение про каждый путь в графе.
И вот только такие свойства нас интересуют.
Мы, скажем, не говорим про алгоритм консенсуса, что в графе конфигурации существует путь,
в котором кто-то что-то выбирает.
Вот такого рода свойства нам бесполезны, что существует путь.
Нам интересно говорить про каждую вершину, про каждую точку в исполнении
и про каждый путь в этом графе.
У нас в графе могут быть циклы?
Что?
У нас в графе могут быть циклы?
Конечно, могут быть циклы. Я же только что привел пример с мьютексами и потоками,
где циклы точно будут.
Просто потому, что число состояния системы ограничено сверху.
У тебя ячейка мьютекса принимает значение 0,1 и 0,2,
и instruction pointer потоков тоже чем-то ограничен каким-то набором значений,
потому что программа просто конечной длины.
Никаких там счетчиков у тебя нет.
Вот и все.
Нет, циклы здесь не важны.
Циклы – это тоже некоторая траектория.
Траектория может быть бесконечная.
Это абсолютно легально.
Вот.
Когда мы говорим про TLA, то мы думаем про граф конфигурации и про свойства,
и теперь нужно каким-то образом эти свойства записать строго.
Нужно как-то граф записать в виде формальной системы с помощью формального языка
и свойства записать.
Вот давайте начнем со свойств, потому что это будет нам попроще сделать.
В теле плюс конфигурации называются состояниями.
Каждое состояние описывается набором переменных.
Каждое состояние описывается набором переменных.
Просто мы говорим, что есть некоторый набор переменных,
и каждое назначение значений для этого набора переменных
описывает некоторое состояние системы.
У нас есть переменный, и мы назначаем им значение.
И вот для каждого состояния мы должны иметь возможность что-то про него утверждать.
Нам пока не важно, что именно это за переменные, какой у них смысл.
Мы сейчас говорим про то, как построить сам язык для таких утверждений.
Ну а как мы обычно формулируем утверждения строго?
Какой у нас для этого инструмент есть?
Еще раз, мы сейчас говорим про язык.
Как мы формулируем строго утверждения?
Не знаю, в математике как мы строго формулируем утверждения?
Еще раз возьмем, мы используем логику.
Возможно, формально логично.
Да, ну вот мы к этому и идем.
У нас свойство это некоторые утверждения, некоторые логики.
Нужно только подходящую логику выбрать.
Явно логика высказывания достаточно бедна для наших целей.
Мы там ничего содержательно сказать не можем.
Но есть более богатые, более выразительные системы.
Ну вот представьте перед вами задача, скажем, формализовать математику.
Вам надоело говорить это очевидно, и вы хотите что-то строго записать.
Что вы для этого делаете?
Вы используете...
Мы сейчас не говорим про какую-то...
Про логику вообще из каких деталей она состоит.
Мы говорим про...
Про какой-то конкретный язык.
Вот я предлагаю вспомнить вам логику первого порядка.
Знакомое явление?
В ней вы можете...
Что у вас там есть?
У любой логики есть синтаксис и семантика.
Вы можете строить, во-первых, формулы.
Конечно, у вас есть обычные логические связки.
Но что у вас еще появляется?
У вас появляются некоторые функциональные символы и предикатные символы.
И вы можете писать еще и квантор существования, и всеобщности.
Правда, не по предикатам, но по элементам некоторого домена, который вы заранее зафиксировали.
И вы дальше умеете эти формулы интерпретировать,
потому что вы понимаете, каким математическим объектом соответствуют ваши переменные и функции, как они себя ведут.
Вы же это все знаете, правда?
Вот.
Да.
Отлично. Тогда можно...
Можно привести пример.
Какого-то утверждения, который можно в логике первого порядка сформулировать про состояние системы.
Вот давайте посмотрим на свойства взаимного исключения.
Вот видно вам на экране?
Да.
Что тут говорится? Что для любых...
Ну, тут некоторая такая математическая аскиграфика, но в принципе можно догадаться, что происходит.
Тут написано, для любых процессов P1 и P2 из некоторого множества, если P1 не равен P2, вот эта вот решетка означает не равен,
то из этого следует, что неверно, что программ-каунтер P1 находится в критической секции,
и одновременно с этим программ-каунтер P2 тоже находится в критической секции.
Ну вот, пожалуйста, утверждения в логике первого порядка.
Вот сам язык позволяет нам такие утверждения формулировать.
Это утверждения про какое-то состояние мира. У нас есть переменные.
Видимо, есть переменная программ-каунтер, которая описывает точку... точку исполнения,
в которой находится каждый из поток, в каждый из процессов, как они здесь называются.
И вот мы строим некоторые утверждения про эти переменные. Утверждения выглядят вот таким вот образом.
То есть вот такой вот логике нам достаточно, чтобы сформулировать свойства взаимного исключения.
Но нам этого недостаточно, чтобы сформулировать свойства лавенеса, свойства прогресса.
Потому что логика первого порядка позволяет нам что-то говорить про конкретное состояние системы.
Давайте вернемся на доску.
Вот мы можем сказать что-то про конкретный кружочек здесь.
Но мы же хотим говорить не просто про отдельные моменты исполнения,
мы хотим говорить про всю траекторию.
Про то, что прямо сейчас, может быть, Ньютексом не владеет никто, но в будущем кто-то завладеет.
И вот в наших утверждениях появляется измерение времени.
Вот здесь одной логики первого порядка недостаточно,
потому что нам нужно это как-то измерение, темпоральное, вводить.
Для таких задач существуют другие логики, называются модальными логиками.
И конкретно здесь нас будет интересовать темпоральная логика.
Смотрите, в логике первого порядка мы интерпретировали формулы
на, можно сказать, состояниях нашего мира.
Мы брали значения переменных, подставляли их по некоторым правилам,
и вычесывали, узнавали формулы выполнения и в Bloomberg'е以前
Ward Trainת дivers김ắнила anni во tellement тысячи к來了та,
можно сказать, что в состояниях нашего мира. Мы брали значения переменных,
подставляли их по некоторым правилам и вычисляли, узнавали, формула выполняется
или не выполняется в этом состоянии. В темпоральной логике мы формулируем
утверждение и интерпретируем формулы не относительно отдельных состояний, а целых
траектории в этом графе. То есть для нас мы оперируем такими объектами.
Траектория — это начальное состояние, следующее состояние, следующее состояние и так далее.
И формулу, которую мы будем строить, мы будем интерпретировать на таких
траекториях. Я бы называть их трейсами, можно называть их, лэмпорт называет их
поведениями. Как мы строим темпоральные формулы? Во-первых, мы можем что-то
строить утверждение, как и раньше, относительно переменных. Но к этим
правилам, к существующему синтаксису, у нас добавляются новые
темпоральные операторы. Темпоральных операторов главных три. Вот если phi — это
некоторая формула, скажем, утверждения про состояние, то можно написать box phi,
это означает всегда. Diamond phi означает eventually. И кружочек phi — это означает next.
Как это всё нужно понимать? Вот давайте начнём с некоторой базы. Пусть phi — это
утверждение про отдельное состояние. Скажем, phi — это утверждение, что в данном
состоянии мы можем вот эту формулу проинтерпретировать на конкретном
состоянии, проверить, верно ли, что в этом состоянии потоки не нарушают
взаимное исключение. Вот когда мы говорим box phi, то есть добавляем такой вот
квадратный темпоральный оператор, то мы говорим, что phi выполняется в каждой
точке, в каждой конфигурации из траектории. Это инвариант. То есть если у нас есть
цепочка из состояний, то в каждом состоянии выполнена phi. Что означает
eventually? Странный вопрос, наверное. Понятно, что означает. Эта формула
интерпретируется так. Прямо сейчас phi может быть не выполнена, но где-то в
будущем, на каком-то шаге, в какой-то конфигурации цкатой phi всё-таки
не должно выполнится.
С next ещё проще.
Сейчас про это поговорим. Ну, мы вообще-то... Давай прямо сейчас про это поговорим.
Вот что такое не always phi? Не всегда phi. Значит, что где-то не phi. Что? Значит, что есть где-то...
Это то же самое, что и eventually не phi. Ну вот, так что можно заметить, что
отрицание, оно, темпоральный оператор, поворачивает. Можно подумать, что такое не
кружок phi. Кружок тоже поворачивается, но не меняется пред. Хорошо.
Ну, это такой простой случай, когда phi это формула утверждения про некоторое
конкретное состояние. Формула про состояние. А что, если phi это самостоятельная
темпоральная формула? То есть в phi тоже могут входить темпоральные операторы. Вот
мы скажем так, более строго теперь. У нас будет такая база. Мы скажем, что вот пусть у
нас phi это утверждение про состояние. Мы скажем, что траектория sigma выполняет
формулу phi про состояние, утверждение про состояние, если
стартовая конфигурация этой траектории выполняет формулу phi. Ну, пока такой
бессмысленное определение. Все-таки у нас темпоральная логика, там утверждение
про траектории, поэтому мы интерпретируем формулу всегда на траектории.
Но вот если формула про конкретное состояние, про одно состояние, у нее нет
темпоральных операторов, то она интерпретируется так. Мы просто берем
начальную конфигурацию в траектории и интерпретируем формулу на ней. Вот, а
теперь, если мы видим формулу box phi, то траектория sigma выполняет формулу box phi
тогда, когда что?
Не для любого цитов, потому что phi у нас сейчас уже любая, в том числе,
темпоральная формула.
Для любого k
вот ведем такое вспомогательное определение суффикс.
Траектории.
Мы скажем, что траектория sigma выполняет формулу always phi, когда любой суффикс
этой траектории выполняет формулу phi. Вот это все матчется с такой картинкой.
Если у нас phi это утверждение про конкретное состояние, а не про
траекторию, то вот эта запись, что суффикс исполняет phi, это более-менее
означает, что цикатый выполняет phi. Ну, то есть, что просто phi выполнено в каждой
конфигурации. Вот, а что такое формально теперь, что значит, что sigma выполняет
diamond phi?
Это называть еще box, я говорю, так, кажется, не записал, а eventually diamond, потому что
символы такие.
Ну, скажите мне, что здесь написано?
Ну, существует некоторый суффикс траектории,
который выполняет phi. Вот.
Ну, нам нужно, мы говорим про формальная система, нам нужно немного формализма, вот,
а теперь про интуицию. Вот, я сейчас напишу две формулы, и мы пытаемся понять,
что они значат. Первая формула. Давайте от чего-то избавимся.
Какой-то вопрос?
Цикаты – это конфигурация, то есть конфигурация графа. В смысле, это узлы графа,
а в смысле общей задачи – это снимок состояния всей системы, то есть в случае
потоков – это состояние разделения памяти и стэк каждого потока и его регистры,
или в случае распределенной системы, узлов, которые решают консенсус – это
состояние сети плюс состояние каждого узла.
Да.
Так потому что в темпоральной логике мы, смотри, это просто по построению,
в темпоральной логике мы оперируем не конфигурациями, а траекториями.
И мы интерпретируем любую формулу в темпоральной логике не на конфигурации,
а на траектории. Поэтому мы всегда говорим про траектории, но у нас есть
некоторая база. У нас есть такие выраженные формулы темпоральные,
где темпоральных операторов вообще нет. Вот мы интерпретируем их таким образом,
сводим их к интерпретации на первом состоянии, на первой конфигурации.
А так вообще мы говорим про суффиксы.
Собственно, я же поэтому сначала написал так, где φ была не темпоральной формулой
в утверждении про состояние, а потом написал более общее определение.
У нас смысл базы по темпоральности формулы.
Вот если формула φ не темпоральная, там нет темпоральных операторов,
то мы интерпретируем ее на траектории так. Мы берем первую конфигурацию
в этой траектории и интерпретируем φ на ней. Это вот некоторый искусственный шаг,
но просто чтобы дальше от него идти. А здесь уже все довольно разумно.
Мы говорим, что σ выполняет eventual φ, то есть некоторая траектория выполняет
eventual φ, если на некотором суффиксе исполняется просто φ.
И если φ оказывается в формуле, где темпоральных операторов нет,
то это означает, что σ выполняет eventual φ, когда существует
некоторая конфигурация ЦК, которая выполняет φ.
Вот просто склеиваем это и это.
Получилось ответить на твой вопрос?
Относительно.
Спрашивай, потому что ответ да или нет, получилось или не получилось.
То есть это вполне эквивалентно тому, что у нас для какой-то конфигурации
это выполнено, потому что у нас футбаза и дальше суффикс.
Смотри, вот я пишу такое свойство, always всегда взаимное исключение.
Вот взаимное исключение я уже показывал, это формула,
которую можно было проинтерпретировать на состоянии системы,
на программ-каунтрах, потоках и узнать, выполняется взаимное исключение или нет.
Я пишу always. Это означает вот просто по этому определению,
что для любого суффикса вот эта формула уже должна на суффиксе выполняться.
Эта формула не темпоральная, там не было темпоральных операторов.
Поэтому я беру просто суффикс любой и проверяю, что любой суффикс
должен выполнять вот эту формулу взаимного исключения.
А это в свою очередь означает для не темпоральной формулы,
что ЦКТ должно выполнять формулу взаимного исключения.
И всё это для любого ЦКТ, для любого ОК.
На всякий случай ничего сложного не происходит.
Если мы чего-то не понимаем, то значит мы запутались в определениях просто.
Мы всего лишь перенесли утверждение какого-то мгновенного состояния мира
на цепочки состоянии. Вот и всё.
Ладно, давайте, чтобы понять, что убедиться, что мы действительно понимаем,
я задам вопрос, который я планировал.
Две уже не очень тривиальные формулы. Что означают они?
Box diamond fee, always eventually fee и eventually always fee.
Первое это просто always?
Первое это не просто always, конечно.
Потому что, ну вот, начнём вы раскрывать.
Always eventually fee. Это означает, что для любого суффикса
выполняется eventually fee.
Но это не означает, что...
Первое значит то, что у нас fee будет выполняться сколько угодно много раз?
Вот, это значит, что fee выполняется бесконечно много раз на траектории.
Вот какой бы суффикс мы ни взяли, всё равно в будущем fee будет выполнена.
Но при этом fee не обязана выполняться, не знаю, всегда,
потому что она может выполняться, не знаю, на каждую вторую конфигурацию
всё равно формула будет выполнена на такой траектории.
Что это означает для нас, для людей, которые занимаются concurrency?
Неважно, в распределённых системах или в многопоточных.
Это означает свойство fairness.
То есть вы пишете планировщик операционной системы,
и вы обязаны запускать поток бесконечно много раз, пока он готов исполняться.
Вы не можете его задерживать на бесконечное время.
Это fairness. А вот это свойство что означает?
Начиная с какого-то момента, когда будет выполняться.
Вот это уже разговор про распределённые системы.
Есть такое понятие eventual consistency.
Оно про то, что реплики вообще-то могут расходиться,
но если их оставить в покое, то они друг с другом договорятся
и придут к одному и тому же состоянию.
Навсегда.
Мы умеем теперь строить формулы темпоральной логики.
Это хорошо.
А теперь нам нужно саму систему описать.
Граф, который порождает траектории, на которых мы интерпретируем свойства.
Напомню, что спецификация – это система плюс свойства.
Свойства мы описывать умеем.
Мы умеем строить сложные утверждения относительно…
Во-первых, мы берём граф системы
и говорим, что каждое состояние в этом графе описывается наборами переменных.
И дальше мы, во-первых, строим язык,
в котором можно формулировать сложные утверждения строго
относительно состояния, то есть относительно набора переменных.
Это логика первого порядка.
А дальше мы этот язык расширяем темпоральными операторами
для того, чтобы строить утверждения относительно путей.
Да, вот то, что мы построили, называется LTL – линейная темпоральная логика.
Это не единственная темпоральная логика, есть другие.
Но вот Лэмпорту нравится она.
И ещё Лэмпорту не нравится оператор NEXT.
Вот в TLA+, Temporal Logic of Actions, там тоже слово «темпоральное»,
есть Box и Diamond, два темпоральных оператора, но нет кружочка NEXT.
Почему его нет?
В темпоральной логике вообще-то он есть, а у Лэмпорта его нет.
Лэмпорт его выбрасывает, он говорит, что не нужно писать свойства,
в которых есть кружочки.
Но это же просто свойства на префексе первом, на суффексе первом.
Мы же не определили, что это такое в общем случае.
Давай определим.
Сигма выполняет кружочек Фи тогда, когда Сигма плюс один выполняет Фи.
Вот ничего неожиданного.
Мы же не различаем NEXT и Eventually.
Что?
Мы не умеем различать NEXT и Eventually, по-моему.
Смотрите, зачем мы вообще пишем спецификации для того, чтобы проверять, скажем,
safety. Мы описали спецификацию ПАКСОСа, и у нас есть Model Shaker,
который может по этой спецификации сгенерировать этот граф
и проверить, что свойства выполняются.
Safety свойства ПАКСОСа — это свойства, которые мы доказывали в асинхронной системе.
Мы вообще работаем в мире, где нет никакой синхронности,
поэтому непонятно, что значит NEXT в нашем графе.
Мы не можем требовать, чтобы следующим шагом было доставлено какое-то сообщение
или случилось какое-то событие.
Мы нигде не можем в своих ожиданиях от мира
оперировать, а следующим ходом произойдет вот это.
У нас есть либо concurrency, и нас могут переключить на другой поток,
либо у нас есть асинхронность сети, и следующее может быть доставлено любое сообщение.
Поэтому Lamport говорит, что в условиях асинхронности нам оператор NEXT не нужен,
потому что мы не рассчитываем на время.
Логика темпоральная, но асинхронность мы не рассчитываем нигде.
Кроме того, вы можете просто спецификацию детализировать в любой момент.
То есть вы там написали какую-то подсистему, а потом добавили в нее состояние
просто потому, что больше деталей его спецификации теперь.
И раньше то, что занимало один шаг, занимает теперь 10 шагов.
То есть вы можете спеку детализировать спецификацию вашей системы,
и тогда у вас свойства, которые использовали бы оператор NEXT, поломались бы.
Вот Lamport против этого.
Так ты же формулируешь здесь какие-то ожидания свои.
Вот у тебя не должно быть ожиданий, что вот о следующем что-то случится,
следующим шагом что-то случится.
Хорошо, тогда мы движемся к...
Мы исчерпали время, конечно, все.
Нужно перейти к примерам, но вот последняя теоретическая часть
про то, как описать сам граф, саму систему.
Есть идеи?
Вот у нас есть язык логики для того, чтобы описывать свои legitimacy
Есть идеи. Вот у нас есть язык логики для того, чтобы
описывать свойства. Но будет плохо, если нам придется
сейчас изобрести новый язык для того, чтобы описывать
графы конфигурации. Лэмпард переиспользует то, что вот
написано в правой части, говорит, что описание системы
это тоже свойство такого вида. Он говорит, что описание
графа – это некоторое свойство, которое выделяет все допустимые
цепочки в этом графе. Это цепочки, в которых в начальной
конфигурации выполняется предикат init, свойство init,
и для каждой пары соседней конфигурации выполняется
предикат next. Next – это предикат на парах состояний, на прошлом
и будущем. И вот если для любой пары соседних конфигураций
в траектории выполняется next, и для первой конфигурации
выполняется init, то это означает, что траектория валидна.
Так что граф конфигурации описывается вот такой
темпоральной формулой, а свойства системы описываются
вот какими-то такими темпоральными формулами.
Еще раз, init что задает? Смотри, это темпоральная формула.
Это как фи и пси, грубо говоря. Эта формула, поскольку
без темпоральных операторов, она интерпретируется на
начальной конфигурации, а next – это такой предикат,
это уже расширение линейной темпоральной логики, это
предикат на паре соседних конфигураций, и он должен
выполняться для каждой пары. И если эта формула справедлива
на траектории, то эта траектория принадлежит этому графу,
и вот так мы графы описываем. То есть next – это какая-то
формула, которая описывает переходы между вершинами?
Да, она говорит, что next выполняется на соседних
состояниях. Это означает, что в графе существует
переход из состояния s в состояние штрих. Ну, например,
здесь было сообщение какое-то в сети, а здесь какой-то
узел его получил. И вот предикат это проверяет, и значит,
если предикат выполнется, значит, такой переход возможен.
Вот то, что получилось, и называется все вместе
TLA+, Temporal Logic of Actions. Вот этот предикат next называется
action. И Лэмпард замечает, что вся эта конструкция,
точнее такой способ описать граф – это такой дискретный
аналог дифференциальных уравнений. Мы, по сути, описываем
всевозможные изменения в состоянии системы. Что
такое плюс, я, честно говоря, не помню, уже не знаю. Ну
вот так Лэмпард предлагает нам специфицировать весь
наш код. А дальше мы должны посмотреть на какие-то
спецификации и понять, что же все это значит, в конце
концов. Потому что пока, наверное, ничего не понятно.
Давайте сделаем это после перерыва. Через 10 минут.
Ну что, продолжаем. Мы не в силах уже заниматься
совсем абстрактным. Нужно посмотреть на примеры.
Вот я надеюсь, что вы сейчас видите первую спецификацию
на TLA, которую я хочу вам показать. Это спецификация
алгоритма Ивклида. Вообще-то задумка TLA в том, чтобы специфицировать
конкурентные системы, распределенные системы или многоплоточные
системы. Вот алгоритм Ивклида полностью не соответствует
этим церям, но это самый простой пример, самый маленький
хлоу ворлд, который только можно придумать. Вот смотрите,
здесь есть переменные X и Y. И изначально они равны
значениям N и M. Вот каким образом M и N. Вот как мы это
описали с помощью предиката ИНИТ. Вот, пожалуйста, утверждение
про состояние мира. Про две переменные. X равен M, Y равен
N. Формула логики первого порядка. И вот предикат
NEXT, который выделяет допустимые переходы. Вот в этом предикате
есть штрихованные и нештрихованные переменные. Штрихованные
переменные — это переменные, отвечающие следующему
состоянию, не штрихованные к текущему состоянию. И если
этот предикат, этот action, как называется в тело, выполняется,
то значит, переход допустим. Какие возможны переходы?
Либо если X меньше Y, то допустим переход, где X не меняется,
а из Y вычитается X. Или наоборот. Если Y в старом состоянии
был меньше X, то допускается переход, где новый X равен
старому, из которого вычли Y. И вот описание системы.
Вот описание графа конфигурации. В начальной конфигурации
должен быть выполнен предикат ИНИТ и для каждого перехода
должен быть выполнен next. Но вот это крайне неинтересный
граф. Почему? Потому что это просто такой бамбук, цепочка
узлов. Никаких витринений нет, никакого недетерминизма
нет, ничего интересного. Но тем не менее, мы по крайней
мере видим, как устроен язык. Вот мы видим, что в нем отступы
влияют. То есть вместо того, чтобы писать скобочки,
мы пишем отступы. Вот вместо and и or мы пишем вот такой
связки графики с юнкцией конъюнкцией. Но в принципе
можно расшировать, что примерно происходит. Это чем-то
отдаленно напоминает всех. Ну и это сравнение, оно
здесь не просто так, потому что... Давайте я вам покажу
какой-нибудь пример сейчас. Да, видите, это не какой-то
супер моргинальный инструмент. Вот GitHub умеет подсвечивать
тела и плюс. Секунду, терпение. Это не про... Ну, смотрите,
LaTeX писал лэмпорт, тела и плюс придумал лэмпорт, еще бы
это спецификация, не умели транслироваться бы в тех.
Вот, пожалуйста, статья про там... Я рассказывал вам
на лекции про паксос-мейдлайв, про гибкие кворумы, про то,
что кворумы на фазу препэра на accept могут быть разные,
и можно брать где-то больше, где-то меньше для разных
целей. Ну и вот спецификация этого алгоритма, спецификация
алгоритма паксоса, и она скомпилирована в читаемый
PDF. Тут уже у вас конъюнкции и дизюнкции совершенно
обычные. Что еще про эту спецификацию можно сказать?
Что удивляет в ней даже не это, а то, что чекер тела
и плюс может интерпретировать вот такие вот штуки. Какое
мы здесь свойства проверяем? Мы проверяем safety-свойства,
predicate, который говорит, что если x равен y, то x равен
наибольшему общему делителю nm. Вот, а наибольший общий
делитель, про него, конечно, модел чекера ничего не
знает, поэтому мы его определяем. Мы вводим отношение делимости,
мы определяем множество делителей, мы учим, пишем
функцию, которая находит максимум, и определяем наибольший
общий делитель как максимум из пересечения множества
делителей по yq. Так что вот здесь описание системы
перед вами, вот набор переменных и формула, которая выделяет
допустимые траектории. И вот инвариант, то есть утверждение
про конкретное состояние. Вот, ну это такой скучный
пример, но зато его можно запустить, в смысле, можно
запустить модел чекер, задав какие-то значения nm, ну
и получить, что мы нашли три разных состояния, видимо,
три шага. Алгоритм вклюда сделал, дошел до 6 и остановился.
Ну это неинтересный пример, потому что граф тут довольно
выраженный просто. Вот, посмотрим, например, сложнее. Вот,
этот пример понятен только старикам, типа у меня, потому
что они смотрели в детстве боевик Крепкий орешек 3.
В этом фильме был Брюс Вирес, и ему звонил террорист
и говорил, что если он сейчас не решит довольно странный
пазл, то Црис взорвет бомбу, кажется, дело было так. Пазл
был такой. Был фонтан и две канистры размером 3.5 галлонов,
и нужно было набрать большую канистру 4. Вот. Ну такой пазл,
его нужно найти решение. Понятно, что граф конфигурации
для этого пазла, можно, вот посмотрим, как этот граф
строится с помощью тела и плюс. Мы вводим две переменные,
сколько сейчас воды в большой канистре, сколько в маленькой,
и значения описывают вот состояние, которое мы достигли.
У нас есть начальное состояние, где канистры пустые. Мы можем
совершать некоторые действия. Мы можем заполнить маленькую
канистру водой. Этот экшен называется Fill Small Jug, и он выглядит
так. В штрихованные переменные с маленькой канистрой наполняется
тройкой, а большая остается без изменений. Мы можем заполнить
большую канистру, штрихованные переменные положить здесь
5, а в штрихованные переменные на маленькой канистре сохранить
просто значение. И мы можем опустошить маленькую, опустошить
точно так же, и мы можем переливать из... у нас какой-то вопрос в чате. Штрихи, да, это
специальный синтаксис, который позволяет нам писать экшены, а именно вот предикат
next на парах соседних состояний. У нас переменных объявлено здесь две, big и small,
а в экшенах мы можем писать переменные big и big-штрих. Вот штрих — это значит следующее
состояние. Вот и правила переливания. Вот предикат на паре состояний, который допускает
переливания. В большой канистре становится минимум из большой плюс маленькой и емкости
большой канистры, в маленькой, соответственно, маленькая уменьшается на дельту, на которую
изменилась большая. Вот на всякий случай тут не нужно думать про порядок вычислений,
потому что порядка вычислений здесь нет. Это вообще неимперативный код, это логическая
формула. Вот она берет четыре значения и проверяет, что для них выполнены какие-то соотношения. Да,
разумеется, Model Checker, который будет интерпретировать эту спецификацию, он будет смотреть на это как на
какие-то присваивания, но вообще мы пишем логическую формулу. У нас здесь равно — это равно, это не
присваивание. Окей, мы определили маленькие экшены, отдельные экшены для таких элементарных
операций, а теперь можем описать весь граф. Вот для этого мы next определяем как дизьюнкцию всех этих
отдельных шагов. При каждом переходе мы можем либо опустошить маленькую канистру, либо опустошить
большую канистру, либо наполнить маленькую, либо наполнить большую, либо перелить из одной в
другую. Вот и за счет этой вариативности у нас граф становится уже менее тривиальным, из каждой
конфигурации у него есть, видимо, 6 дуг. А теперь вопрос. Вот мы описали таким вот образом граф
конфигурации для нашего пазла. А теперь мы хотим каким-то образом с помощью model checker,
который умеет варидировать safety-level-свойства, то есть свойства, описанные в виде темпоральных
формул, мы хотим узнать, есть ли решение у пазла. Вот узнать, существует ли решение, то есть существует
ли в графе какая-то конфигурация, для которой выполняется, что b равно 4. Вот вроде бы
темпоральная логика этого делать не позволяет. Мы строим утверждение относительно каждого пути
или каждого состояния. А тут у нас вопрос, существует ли состояние, в котором выполнено
некоторые условия. Вот поможет ли нам здесь model checker, который умеет проверять свойства
на выполнимость. Eventually, b равно 4 означает, что, что бы ты ни делал, ты в будущем обязательно
достигнешь четырех. А ты заполняешь маленькую канистру, потом выливаешь ее, заполняешь,
выливаешь, заполняешь, выливаешь, делаешь так бесконечно. Это некоторая траектория в графе,
а свойства, они же должны выполняться для любой траектории. В этом смысл.
Когда мы говорим save to aliveness, свойства спустя прогресс, она означает, что на каждой
траектории в графе у тебя происходит нечто хорошее. Вот на такой траектории ничего хорошего не
произойдет и не должно. Мы говорим следующее, мы пишем инвариант, что big не равно 4. А теперь мы
запускаем model checker и проверяем, что этот вариант выполняется. То есть верно ли, что в каждом
состоянии у нас содержимое большой канистры не равно 4. Вот запускаем model checker. Он находит
84 состояния, 16 разных, чтобы это пока не значило. И инвариант нарушается. Тем самым мы узнаем,
что в графе все-таки существует. То есть этот вариант несправедлив, и в графе, значит,
существует состояние, где содержимое большой канистры все-таки равно 4. Ну а поскольку model
checker TLA+, перебирает граф не абы как, а поиском в ширину, то это означает, что он находит не просто
траекторию, на которой вариант нарушается, а он находит кратчайшую траекторию, на которую этот
вариант нарушается. И вот мы можем здесь, в этом окошке, траекторию прочесть. Мы начинаем с двух
нулей, потом тут даже написано, как называется, action, который мы взяли. Мы заполняем большую
канистру, получаем там 5, потом мы переливаем из большой канистры в маленькую, получаем в большую
2, в маленькой 3, потом мы опустошаем маленькую канистру, там становится 0, потом мы переливаем
из маленькой в большую, там становится 2, потом мы заполняем большую, там становится 5, и потом
мы переливаем из большой в маленькую, пока не заполнится маленькая, и таким образом в большой
остается 4. Вот утверждается, что решение короче не существует просто потому, что model checker обходит
граф поиском ширину. Эта спецификация все еще не имеет никакого отношения к конкарнции прямого
и к определенным системам, но по крайней мере ирустрирует, как можно описать какой-то
не совсем тривиальный граф уже. Ну что ж, а теперь мы морально готовы к тому, чтобы посмотреть на
спецификацию алгоритма Paxos. Вот она местами выглядит довольно страшно, ну вот например, посмотрите на этот
экшен. Ну это дело техники. Итак, смотрим на спецификацию, точнее даже так, смотрим на
спецификацию и понимаем, что, даже по предыдущим примерам, что тело и плюс это очень низкоуровневый
язык. Там есть переменные, там есть множество, там есть отображение, там есть списки, но там нет узлов,
там нет сети, там нет никаких высокоуровневых абстракций, про которые мы думаем, когда говорим
про определенные системы. Это сделано намеренно, потому что такой уровень абстракции нас бы
в себе фиксировал, а Lampard хочет, чтобы мы могли специфицировать систему в самом разном масштабе
с любым уровнем детализации, и через множество, и через списки, через отображение по замыслу Lampard
можно выразить всё. В том числе можно выразить алгоритм Paxos, узлы, которые общаются по сети.
Давайте подумаем, как это можно сделать. Тут, по-моему, ответ уже перед вами, можно было бы его
просто прочесть. Как нам моделировать узлы и сеть алгоритма Paxos? У нас есть узлы, аксепторы, и у каждого
аксептора есть состояние. Каждый аксептор помнит максимальный ballot number, который он получал,
и каждый аксептор помнит отданный голос. Вот эти три переменные — это, на самом деле, три отображения.
Отображение из множества аксепторов. Максимальный ballot number — это отображение из аксепторов
в максимальные ballot numbers. Эти две переменные — это отображение для каждого аксептора из
отображения в значение или в ballot number, за который он проголосовал,
proposal number, за который этот аксептор проголосовал. Вот три такие переменные описывают состояние
всех аксепторов. Ещё одна переменная описывает просто сеть. Вот мы не пытаемся моделировать
здесь провода какие-то, там, коммутаторы, стойки, децентрия. Сеть — это просто множество отправленных
сообщений. И у нас есть специальный action next, специальный action send,
который позволяет отправить в сеть сообщения. Этот action говорит, что штрихованный messages
должен быть равен messages на предыдущем шаге в объединении с таким синглотоном из множества
из сообщения. Вот так моделируется сеть. Как моделируется исполнение? Как обычно,
смотрим на предикат next. В этом предикате есть два конъюнкта. Что может в аксете происходить?
Может происходить отправка сообщения prepare на первой фазе, может происходить отправка в
обратную сторону промеса, accept и accepted. Четыре возможных события. И вот здесь есть две ветки.
Первая ветка — это действие пропаузера. Какой-то пропаузер начинает первую фазу паксуса,
посылает prepare. Вот здесь нотация лэмпрад из оригинальной статьи «Паксус имеет симпл»,
1a — это prepare, 1b — это promise, 2a — это accept, 2b — это ответ acceptа, то, что он проголосовал за
значение, за пропаузу. И вот смотрите, что мы пишем. Или существует ballot number из множества всех
ballot number такой, что или было отправлено сообщение prepare, или существует некоторое значение такое,
что был отправлен accept из пары b в. То есть лэмпрад здесь даже не моделирует пропаузеров.
Просто в системе появляются prepare и появляются accept. Вот как будто бы из воздуха возникают.
Вот из воздуха возник prepare с ballot number b. Что такое action phase 1a? Как он устроен? Он устроен
очень просто. Он говорит, что в штрихованной сети появляется такое сообщение типа 1a с ballot
number b, а все остальные переменные остаются неизменными. Вот это как будто бы какой-то пропаузер
отправил какому-то accept сообщение. Вернее, он отправил его даже не какому-то конкретному accept,
потому что здесь получателя вообще нет. Это просто prepare с некоторым ballot number.
Кто же его получает? Ну, вообще-то его может получить любой acceptor. При переходе из
предшествующего состояния в следующее, мы можем выбрать одного из acceptors, из множества acceptors,
которые мы задаем в model checker, и для него может случиться переход phase 1b. А phase 1b устроен
таким образом. В сети есть сообщение m. Такое, что его тип 1a, то есть это prepare, ballot number в
нем больше, чем максимальный ballot number, который видел данный acceptor. Это не массивы, это отображение.
Вот, ballot number штрих для этого acceptor меняется на значение из сообщения, и в сети появляется
сообщение типа 1b, то есть promise от acceptor a с ballot number, который нам отправили. И переменная
поля m-ball и m-wall – это proposal, за который данный acceptor к этому времени проголосовал.
То есть вот такой вот переход. Вот здесь видите, сообщение отправляется кому-то одному. Здесь
сообщение отправляется сразу всем. И будучи отправленным, оно из сети никогда не исчезает.
Поэтому это такая широковещательная рассылка. Вы сделали broadcast сразу всем, и каждый acceptor
любой acceptor a может это сообщение получить. Что? Подожди, но это реакция отдельного acceptor. Тут
никаких кормов и не должно быть. Acceptor получил сообщение prepare, посмотрел на свои переменные и
ответил. Повтори, пожалуйста, вопрос. Очень тихо было слышно. Это такой очень странный уродливый
синтаксис. Lamport тоже кажется уродливым, но всем он кажется уродливым. Это означает, что переменное
отображение штрихованное равно исходному за исключением одной точки a, где оно меняется на
такое значение. Ну вот, это такая вот большая конъюнкция. Какие условия должны сложиться,
чтобы нам acceptor отправил promise? В сети должен быть prepare, его ballot number этого acceptor должен
быть меньше, чем ballot number в сообщении. Ну и тогда в обратную сторону появится promise.
То есть опять же, тут нет никакой последовательности шагов. Это вот как бы разум случается и все,
это такой атомарный переход. Каждый action это атомарный переход. Ну вот, мы посмотрели
фейс 1a, фейс 1b, а теперь фейс 2a. То есть возможен переход для некоторого b и для некоторого v.
Этот переход означает, что для данного ballot number и данного значения v в сеть, видимо,
был отправлен accept. А почему он был отправлен? Ну вообще-то это сложно уже. Тут можно такие детали
прочесть. Вот фейс 2a. Этот action говорит, что в штрихованном мире есть accept, а в нештрихованном
его еще не было. Ну вот, в нештрихованном мире в сети не существовало сообщения 2a с ballot
number b. В штрихованной сети оно появилось и, видимо, должно быть какое-то условие,
которое к этому привело. Видимо, собрался quorum. То есть существует элемент q множество quorumов.
Такой, что... Тут хорошо знакомые любители функционального программирования конструкции
LED. Если вы пишете на c++ всю жизнь, то, наверное, вам это трудно читать. Ну в общем, мы здесь
определяем множество всех ballot numbers, которые мы получили от accept'ров. То есть вот мы перебираем
все сообщения, множество messages такие, что это сообщение promise, оно входит в этот quorum
выделенный и ballot number там b. Вот, и из них собираем... Сейчас, я сам запутался.
Это множество всех сообщений, которые мы получили в рамках этого quorum, а это все сообщения с непустыми
голосами. Ну дальше мы определили два таких объекта, и через них мы уже строим некоторую формулу.
То есть мы выделили некоторую сложную подформулу, дали ей имя, связали ее с именем. Вот, и теперь мы
можем эту подформулу использовать в качестве имени для того, чтобы сказать, что какой-то
пропозер предлагает значение v с ballot number b, потому что, ну, либо все ответы были пустыми, а b было,
а v, видимо, было его выбором, его собственным значением. Либо же существует такое сообщение в quorum'е
promise, такое, что значение в этом сообщении это v, и при этом в этом сообщении ballot number больше,
чем все другие, не меньше, чем ballot number всех других сообщений с quorum. Ну вот, вроде прочитали.
Вот это целиком декларативное описание, тут никаких вычислений, никакого порядка нет. Мы просто
пишем большую формулу. Вообще, вся эта спецификация — это одна большая формула next, по сути-то. Вот если мы
начнем ее подставлять, то получится такая гигантская, непонятная, но она и так не очень-то понятная, но
получится абсолютно гигантская формула, и вот эта формула описывает все возможные исполнения алгоритма
сингуют degree of access. Примерно понятная идея, как эта спецификация описана?
Что? Так вот же, мы только что прочли. Смотри, вот этот... Вот мы задаем просто множество quorum'ов,
когда мы запускаем... Смотри, model checker, вот здесь у нас есть переменные и есть некоторые константы. Вот
value — это множество всех значений, acceptor — это множество acceptor'ов, quorum1, quorum2 — это quorumы
для первой и для второй фазы. И когда мы запускаем model checker, мы задаем, что у нас три acceptor,
что у нас два значения, что у нас, раз три acceptor, то вот такая система quorum'ов, любые
всевозможные двойки. Вот, а ballot number'ов у нас вообще четыре. Вот два возможных значения,
четыре acceptor'а, три acceptor'а, четыре ballot number'а. Тут как таковых пропаузеров нет. Вот этих циклов
с литрами нет. У вас просто из воздуха появляются сначала prepare, а потом появляются accept. И
acceptor должны на них реагировать. Чего мы от такого графа хотим? Мы хотим выполнения safety
свойства. А safety свойства записывается вот буквально так, как мы формулировали теорему.
Для любого значения v или для любого ballot number'a v. Если был выбран пропаузл bv, что значит
выбран? Что существует quorum второй фазы такой, что любой acceptor из этого quorum'а отправил в сеть
сообщение 2b с этим значением и этим ballot number'ом. Вот просто определение понятия выбора в консенсусе
в алгоритме Paxos. Это вот formula agreed. Вот если мы умеем читать, мы понимаем, что такое значение
выбрано. Мы уже не можем... Вот здесь максимально строгое изложение. Еще раз помните, говорил вам,
что значение выбрано не означает, что оно лежит на большинстве... Даже пропаузл лежит на большинстве
acceptor'ов. А то, что большинство acceptor'ов ответили. Вот здесь ровно это и записано. Нашелся quorum
такое, что каждый acceptor из этого quorum'а отправил в сеть сообщение 2b. А safety свойства описывается так.
Для любого v из множества значений и b из множества ballot number'ов, если пропаузл был выбран,
то для любого другого значения v2 или любого другого v2 больше v из того, что в сети появилось
сообщение accept b2 v2, следует, что v равно v2. То есть для любого пропаузла с большим ballot number'ом
значение в accept должно совпадать. Опять же, это ровно формировка теории. Вот мы теперь это можем
записать при желании скомпилировать в PDF и проверить. И вот запустив на таком наборе с такими
параметрами muddle-checker мы узнаем, что у нас в мультипаксосе получилось то ли 6 миллионов
состояний, то ли 700 тысяч состояний в зависимости от того, как считать. Почему 700 тысяч меньше, чем 6
миллионов? Ну, в смысле, почему два разных счетчика состояний? Потому что некоторые
состояний различать не стоит. Скажем, вы отправили сообщение... Дело не в том, что у вас два
состояний, ромбиком вы пришли к одному и тому же состоянию, потому что у вас два события
коммутировали. А дело в том, что некоторые состояний будут симметричны в том смысле, что из одного
можно получить другое, просто перенумерував аксепторы или перенумерував значения. Вот понятно,
что различать такие случаи не стоит, и muddle-checker их не различает, и ровно поэтому, когда мы задаем
ему параметры, мы говорим, что вот 1а2а3 это просто некоторые идентификаторы аксепторов, и можно их
перенумеровывать. Они ничем друг от друга не отличаются, они все одинаковы. Со значениями то
же самое. Вот это позволяет перебор сокращать. Вот так вот можно задать Paxos. Не то чтобы это
очень-очень удобно читалось, потому что тут бы много таких... Не поворачивайся сказать слово
инженерных оптимизаций. У нас новый вопрос в чате. Найдет ли TLC LifeLog? TLC найдет LifeLog,
и я чуть позже про него покажу. Чуть позже я его покажу в другом контексте. Ну, LifeLog это
что-то паральное свойство, значит его можно проверять. Я хотел про оптимизации поговорить.
Смотрите, тут много оптимизаций. Когда мы отправляем сообщение в сеть, мы отправляем его сразу всем.
Когда мы отправляем сообщение в сеть, мы его после этого никогда из сети не извлекаем. То есть когда
мы получаем сообщение, мы пишем, что существует m, множество messages такое и так далее. Что? Ну да,
мы таким образом упрощаем жизнь Model Checker. Вот вопрос, а как такая спека учитывает сбои узлов?
Учитывает она как-то их или нет? Рестарта точно не учитывает здесь, а вот
сбой, исполнение в котором узел умер, это исполнение в котором узел просто не двигается,
но не совершает ходов. А поскольку Model Checker перебирает все возможные траектории, в том числе
в сети, в котором какой-то узел не ходит, то это в общем-то равносильно. То есть тут не нужно каким-то
образом моделировать partition или моделировать сбои узлов. Вот partition это просто некоторые
исполнения, где долгое время какие-то сообщения не долетают до каких-то узлов. Model Checker переберет
все возможные исполнения, в том числе и такие. Поэтому необходимости как-то явно описывать такие
partition в спецификации нет. А зачем мы зафиксировали Bell от одного до четырех? Ну а как мы будем? Ну а
иначе Model Checker что перебирать? Чтобы ограничить число состояния в нашем графе, чтобы оно было
конечным, чтобы Model Checker завершался. Ну кажется другая модель получилась. В чем здесь хитрость?
Непонятно. Здесь нету хитрости. Мы просто хотим дождаться, чтобы проверка завершится. Мы можем
написать 100, но тогда понимаешь, что любой параметр, все эти параметры вместе комбинаторно
перемножаются и получается экспоненциальное число состояния в нашем мире. Даже для таких маленьких
параметров мы получили 6, где было? 6 миллионов состояний. У нас всего лишь 3 acceptora, 4 было
от number, 2 значения. Вот, разумеется, мы не можем брать большие числа. Если мы хотим какие-то
свойства проверить eventually, то может при больших числах что-то испортиться или нет? Я думаю,
что не может. Если ты сдавал курс весной, то ты знаешь, что количество потоков или количество
узлов мало на что влияет. Влияет конкурентность. Вот это ломает алгоритмы, но конкурентность Model
Checker как раз перебирает полностью. То есть он перебирает все возможные состояния, которые
достижимы в исполнении алгоритма. Но бы ценой того, что он перебирает какие-то конечные графы
для небольших значений параметров, для небольших значений свободных переменных.
Но мы, поскольку мы верим, что баги конкурентно не так устроены, а мы, кажется, верим, но потому
что контрпремеров просто не существует. Мы верим, что даже с такими параметрами, если мы не найдем
ошибок, то мы будем склонны считать, что алгоритм корректен. Разумеется, ты можешь эти значения
увеличивать, брать больше acceptors, больше bullet numbers. Но как алгоритм пакса зависит от большого
количества bullet numbers. Что может случиться с bullet number 7 и не может случиться с тремя?
Тут проблема не в значениях, а в конкуренции. В каком порядке долетают сообщения? Вот мы верим,
что для небольшого количества acceptors, небольшого количества bullet numbers будет достаточно для того,
чтобы быть уверенными, что алгоритм корректен. Что еще у нас в этой спейке привлекает? Ну не
привлекает, а скорее вызывает вопросы. Возможно, нам не нравится, что она написана как будто ее
фусцировали намеренно. Мы сейчас посмотрим другую спеку, и там все будет лучше. Это скорее отношение
представьте себе, как люди пишут из академии и как пишут инженеры. Пишут по-разному. Вот так же и
лэмпард. Он пишет логическую формулу, но даже логическую формулу можно написать в продакшн качества.
Вот это логическая формула математика, а сейчас я найду логическую формулу инженера. Вот логическая
формула инженера. Тут комментарии больше, чем формул, и все обозначения, которые вводятся,
они еще длинные и читаемые. Вот спека получается, конечно, больше, какие-то тысячи строк. Это
протокол изоляции транзакций, который у нас будет через неделю или через две. Так вот, эта спека
написана инженером облака Amazon, и она оставляет совершенно другое впечатление. Можете догадаться.
Так что это здесь не свойство TLA, это свойство лэмпарда. А вот свойство TLA, оно вот здесь вот. Видите,
здесь есть такой специальный предикат TypeOC. Дело в том, что TLA динамически типизирован,
язык, у которого нет статических типов. Почему? Потому что если у вас язык с статическими типами,
то он вас в векторном смысле ограничивает. Вот представьте, как бы вы на C++ написали бы множество
сообщений, где сообщение будет разных типов. Вы бы смогли это написать с помощью каких-нибудь
вариантов, но вы бы, безусловно, страдали в своем коде. А лэмпард просто множество
messenger кладет совершенно гитрогенные объекты в этом сэнде и совершенно не беспокоится. Ну,
при написании не беспокоится. Когда он спеку написал, он хочет убедиться, что она типизируется
нормально. И он это проверяет в рантайме. Каким образом он просто в каждом... Он запускает проверку
инварианта TypeOC. Вот если вы написали большую спеку, то начнете здесь с проверки инварианта
Safety, SafeValue здесь называется, а с проверки инварианта TypeOC, что вот эта формула выполняется в
каждом отдельном состоянии, которое был у чехер посетит. Если выполняется, то, наверное, ваша спека
делает что-то разумное. Вы ей можете верить. Что еще можно было бы про эту спеку сказать? Не знаю.
Если у вас вопросы остаются, то задавайте. Если нет, то я дальше пойду. Я хотел про RAFT
поговорить. Вот здесь уже спецификация большая, и мне кажется, что она написана достаточно читаема,
в отличие от Paxos, и по ней ориентироваться при некоторой сноровке даже проще, чем по вот этому
описанию из статьи. Вот смотрите, с чего мы начинаем чтение спецификации. Скорее всего,
множество переменных может быть, но скорее всего с оператора Next, с actionNext. Что вообще в системе
происходит? И вот здесь actionNext иллюстрирует нам все возможные события, все возможные переходы,
которые в RAFT рассматриваются. Рестарт узла, тайм-аут реакшн таймера, где мы считаем, что лидер,
видимо, уже мертв, где мы посылаем request vote с просьбой проголосовать за нас, мы становимся лидером,
мы получаем запрос от клиента, мы двигаем commit-индекс вперед, мы получаем команду
репликации от немы. Тут существует EG, то есть ИТ-сервер отправил житому сообщение request
vote с просьбой проголосовать за себя в каком-то терме. В общем, это все, что может с миром
происходить, с миром RAFT. Ну и почему такая спека может быть полезна? Вот смотрим, например,
на actionRestart. Какая нам от него польза? Нам как разработчика. Вот в RSM, который мы пишем,
есть состояние персистентное, есть волатильное. То есть мы должны что-то хранить в памяти,
что-то мы можем хранить в памяти, а что-то мы обязаны хранить на диске. И вот по этому action
можно понять, какое состояние волатильное, какое персистентное. Вот в RAFT здесь написано,
какое-какое. Но вот эту же информацию можно получить из спеки, читая этот action. Вот current
терм не меняется при рестарте. VotedFor, отданный голос не меняется при рестарте. Log не меняется
при рестарте. Это означает, что это персистентное состояние. Смотрим статью, и вот действительно
эти три переменные должны храниться надежно на диске. Вот, а при этом текущий стейт узла может
потеряться. Какие-то собранные при голосовании голоса могут потеряться. Знание про то, как мы
матчимся с другой репликой по логу тоже может потеряться. Все это не страшно. Или, например,
мы пытаемся понять, что делает реплика, когда у нее истекает reaction timer. Вот, можно здесь
это пытаться найти, ну вот, например. Какие-то действия описаны. Вот спецификации их можно найти в
action timeout. Вот сервер И, у него истек timeout, и он считает, что лидер текущего терма отказал.
Тогда он становится кандидатом, он увеличивает терм на единицу, он сбрасывает голос. То есть
он пока ни за кого не проголосовал. Ну и дальше он может отправить request vote, потому что он
кандидат, и жид и ему еще не ответил. Вот тогда в сеть можно положить вот такое сообщение. И здесь
мы видим, что мы именно посылаем при голосовании. Мы посылаем свой терм, мы посылаем терм последней
записи влоги, мы посылаем длину лога. Ну вот, в общем, такие сообщения. Вот это более сложный
экшен, где реплика реагирует на доставленные сообщения. Ну, кстати, это уже сил нет, да и
время у нас лучше на другое потратить. В общем, спеку RAF-то можно использовать просто как
документацию алгоритма. Более подробную, чем вот это словесное писание, и гораздо менее подробную,
менее детализированную, чем код на C++, который у нас где-то был здесь. Тут, конечно, можно...
Вот все эти спецификации, они же именно про дизайн и про корректность алгоритма. Или их,
в теории, можно как-то соединить с реализацией, проверить, что мы этот алгоритм реализовали правильно.
Я как раз к этому хотел перейти, потому что мы можем с помощью формальных методов,
с помощью спецификации на тело E+, написать понятную формальную документацию и потом
проверифицировать с помощью Model Checker. Но мы верифицируем дизайн, а в конечном итоге мы бы
хотели верифицировать реализацию. Мы хотели бы быть уверены не только в дизайне, но и в коде,
который мы написали тоже. Я сейчас к этому перейду, буквально пара слов про RAF-то. Вот эта спека,
ее уже сложно проверить, так как можно проверить спеку Paxos. Почему? Потому что хотя бы из-за
этого экшена вот здесь прирастает current term. Поэтому если мы начнем такую спеку прогонять
через Model Checker, то в ней будет бесконечно много состояний, потому что термы будут расти. И будет
цепочка, где просто каждая реплика тайм-аутится на каждом шаге. Значит ли это, что эта
спецификация годится только для документации, не годится для проверки. Но мы можем запустить ее
в Model Checker и ограничить глубину или просто ждать. И чем больше мы прождем, тем больше мы будем
уверены, что алгоритм корректи. Просто потому что он так вот волнами исследует граф конфигурации.
Вот, это уже такая более инженерная документация, в смысле написана более
человечная, в отличие вот от вот этого фарша символов. Ну и да, я говорил вам, что можно делать
это совсем хорошо, если у вас много свободного времени и вы знаете хороший код промышленного
качества. Можете писать промышленного качества логические формулы еще. Но это все логические
формулы и замечательно все, что... Да, договорю, раз уж начал. Тут критерии качества промышленные,
они применимы к логическим формулам и в других смыслах. Вот вы пишете, во-первых,
комментарии в коде, во-вторых, вы тесты кода пишете еще. То есть вы проверяете, что ваша
спецификация, в смысле ваш код вообще работает, что он делает что-то разумное.
Вот к спецификации тоже можно писать unit-тесты. Вот тут есть какие-то дикие... Сейчас мы найти это.
Может быть, в этой спецификации нет.
Черт возьми, нет только хорошего примера. Но можно для самой спецификации писать маленькие
unit-тесты, то есть некоторые сложные предикаты, и потом с помощью Model Checker вылидировать,
что они действительно выполняются, то есть проверяешь, что строили линеризуемое. Вот такой
предикат можно написать, он будет устроен суперсложно, но все равно можно убедиться,
что он корректен, просто запустив его на некоторых конкретных историях. В общем,
все практики, которые применяются, многие практики, которые применяются в промышленном
программировании, их можно перенести на программирование логических формов.
Но, наконец, мы все еще не уверены, что наша реализация будет корректна. Даже если мы придумали
дизайн, даже если мы его строго изложили в виде спецификации, даже если мы верифицировали
спецификацию с помощью Model Checker, все равно остается шанс, что мы напортачили в реализации.
Вот нам же хочется в итоге получить работающий код, который поверх работающего дизайна,
вот работающий дизайн у нас есть, а в коде мы ошиблись. Почему мы в коде ошиблись? Где мы вообще могли
ошибиться? Ну, просто невнимательно. Ну, скорее всего, дополнительная сложность, которую ты
получаешь, программируя распределенные системы, это конкурентность. Вот в спейке Паксоса у тебя
все однопоточное. В смысле, странное заявление. В спейке Паксоса у тебя цепочки, где изотоварных
шагов. В рафте у тебя здесь тоже переходы атомарные. Вот кто-то отправил... у кого-то
истек тайм-аут, кто-то отправил реквест в аут. А в коде у тебя все конкурентно. И вот в коде у тебя
появляются какие-то блокировки, какие-то локи-анлоки. Здесь это довольно сложно устроено,
но мы это еще в будущем увидим. И можно ошибиться в конкарнсе. Во-первых, как можно провалидировать,
что вы конкарнсе пишете правильно. Ваши примитивы и синхронизации, которые вы используете,
тоже корректны. В этом написали какие-то страшные мьютексы или экзекутеры страшные,
какие-то лог-фри очереди, что-то подобное. Вот для этого, оказывается, тоже можно использовать
CLA+. Это все еще не про код, но про другой аспект реализации. Не про дизайн верхней уровней,
а про примитивы конкурентности, которые мы используем. Конкарнсе тоже можно специфицировать
и верифицировать с помощью CLA+. Но если, скажем, конкарнсе в распределенной системе можно выразить
с помощью дизъюнкции и с помощью кванторосуществования, это тот инструмент, с помощью которого вы
конкуренции, с помощью которого вы конкуренции описываете в распределенной системе в CLA+,
то вот такой низкоуровневый способ для конкурентности на уровне потоков вам уже не подходит. С потоками
все-таки у вас есть планировщик, как единственный источник интерминизма и конкарнсе, и у вас есть
какие-то атомарные шаги в потоках, и потоки перемешиваются друг с другом. Вот на CLA+,
какого-то адекватного способа выразить это нет, вы сойдете с ума, если будете описывать отдельные
маленькие шаги, отдельные инструкции, таким образом. Но для решения этой проблемы существует
промежуточный язык, который называется плюскаль, потому что плюскаль, как паскаль, только, в общем,
немного по-другому. И в нем уже есть понятие потоков, есть понятие процедур функций,
есть понятие макросов для атомарных операций, и вот есть метки. И можно описать какой-то... Вот это,
кстати, ваша домашка про LifeLog, первая домашка из весеннего курса. Здесь написан алгоритм
взаимоисключения, в котором есть LifeLog, и для него написаны свойства safety и свойства liveness.
И этот код написан уже в таком императивном стиле. Вот мы сначала выполняем фидж-эт, если мы
получили что-то больше 0, то мы уменьшаем его, а потом пробуем заново, снова делаем фидж-эт,
если получить больше 0, пробуем заново. Если помните, у нас такая игрушечная задачка была. Вот такой
код можно верифицировать с помощью того же самого ModelChecker, если предварительно транслировать его
в TLA+. И это можно сделать механически. Каким образом? Тут долго рассказывать, я общий принцип поясню.
Вот у нас здесь есть метки, это такие атомарные шаги. Между этими атомарными шагами, то есть вы
можете сделать один шаг, потом переключиться на другой поток, на другой процесс. Вы можете взять
этот высокоуровневый код и транслировать его в низкоуровневый логический Assembler. Он не
предназначен для чтения, так же как Assembler, не предназначен для чтения людьми, но его уже может
валидировать ModelChecker TLA. Трансляция устроена довольно забавно. Я бы сказал, что это буквально
компирация в Assembler, потому что... Вот представим, что у вас есть... Ну, во-первых, как устроен
атомарный шаг? Вы пишите l1 fetch add. Для каждой метки генерируется служебный action. Он говорит,
что programCounter сейчас равен l1, programCounter, штрихованный после этого action, равен l2.
Вот. А переменная count, она на единицу увеличилась. То есть мы можем вот такие вот простые атомарные
шаги... Да, и значение pref оказалось в старое значение count. Вот мы в теле плюс выразили
операцию fetch add, которую написал сам пользователь, впрочем. Вот. Что происходит, когда мы зовем
какую-то функцию? Ну или давайте себе вот... Сейчас другой пример. Call Tricky Unlock, где мы делаем
fetch add. В Unlock для него тоже будет служебный action, и в нем мы проверяем, что programCounter был
равен Unlock, programCounter, штрихованный, становится равен чему? Первой метке процедуры, которую мы вызвали,
o1. Но при этом мы должны для будущего возврата из этой функции в стэк вызовов положить,
а куда мы, собственно, должны вернуться. Мы обновляем наш стэк вызовов, добавляем в него
новый стэковый frame, где мы говорим, что возвращаемся в процедуру Tricky Unlock в метку lock,
когда мы отсюда выйдем из процедуры Tricky Unlock вот по этому return. А теперь смотрим на o2.
Здесь мы находимся в метке o2, и мы должны перейти в метку, которую мы извлекаем из головы стэка,
а потом мы попаем сам стэк. Ну не потом, в смысле вот как бы все вместе. Короче, вот у нас тут
служебные переменные programCounter, это просто instruction pointer, у нас здесь callstack моделируется.
Ну короче, мы вот буквально компилируем вот этот псевдокод в логический assembler с такими же
собственными структурами данных, которые у вас в процессоре выполняются. А дальше мы можем
запустить проверку safety свойства и liveness свойств. И safety свойства, она у нас выполняется,
liveness свойства нарушаются, разумеется, потому что есть lifelog. И тут его невозможно, конечно,
читать, но tli plus его находят, его можно декодировать отсюда. Я думаю, что вы как бы сами найдете его
быстрее, сами его искали быстрее. Разве что можно показать, как именно свойства формулируются,
свойства liveness. Вот logany и logall. Что из них что? Давайте читать, потому что я сам не помню.
Logany. Существует процесс такой, что если programCounter этого процесса не равен критической секции,
то загадочные символы programCounter равны критической секции. logall для любого p из множества процессов,
если programCounter p не равен, то магические символы programCounter равны. Вот смотрите,
у нас есть две гарантии прогресса, сильные и слабые. Сильные про то, что каждый поток,
получится критическую секцию, слабые, что какой это поток?
Ну, точнее так, слабая гарантия прогресса, она про то, что mutex бесконечно часто захватывают.
mutex бесконечно часто... если у вас число потоков конечное, то утверждение, что mutex бесконечно
часто захватывают, эквивалентно тому, что какой-то поток бесконечно часто захватывает mutex. Вот,
и ровно это формулируется в свойствах logany. Вот tilde-стрелочка означает следующее. Давайте
попробую здесь написать. Лучше, конечно, на доске. tilde-стрелочка — это когда у вас
phi tilde-стрелочка psi. Это означает, кажется, это сокращение для такого.
Всегда верно, что если phi, то event чьё ли psi. То есть существует процесс такой, что если прямо
сейчас он не в критической секции, то в будущем он обязательно будет в критической секции. Но это
справедливо для любого суффикса. Вот, это свойство можно запустить, проверить, и Model Checker найдёт
страшное, плохо читаемое исполнение. Где-то оно... я его свернул. Что делать? Вот, смотрите, тут есть
некоторая фундаментальная беда такого подхода. С одной стороны, всё довольно астроумно, то есть
мы пишем такой псевдокод, потом мы нажимаем кнопочку в IDE «транслировать его». Но сейчас я не
транслирую, потому что я ошибку написал. Здесь, синтоксическую. Если мы её сотрём и нажмём на
кнопку, то компилятор этой IDE сгенирует код, такой логический, и его провалидирует относительно
свойств, и найдёт ошибку. Но беда в том, что Model Checker работает уже не с этим понятным кодом,
где есть функция, где есть атомарные шаги, а вот с этим вот, с этим фаршем Assembler. И bit.race,
который сейчас тоже в виде такого вот фарша. Нужно её декодировать, то есть в этом состоянии
program counter 1 равен L2, program counter 2 равен log, и нужно идти сюда и смотреть, где же потоки находились.
Не очень удобно. Кроме того, есть другая проблема. А что, если мы неверно ошиблись с метками? Вдруг мы
подметку поместили сразу две операции над разными ячейками памяти. Вот таких операций
атомарных в процессоре нет, а у нас они есть. И мы получили исполнение, более узкий набор
исполнений, и мы не все случаи перебрали. Но это непреодолимые препятствия, и преодолеются они
совершенно другим образом. Весной я вам рассказывал про планировщик Go, как он устроен,
и, может быть, говорил, что другие языки этот дизайн переиспользуют, в том числе планировщик
для фреймворка Tokyo в Rust. И вот есть статья, как они писали свой быстрый планировщик. Тут,
в общем-то, пересказ идей планировщика Go. Ничего интересного до момента, когда появляется Loom.
Вот они написали код, и теперь его нужно проверить. Вот для того, чтобы проверить написанный код,
где есть всякие лог-фри и вейт-фри очереди, разработчики написали собственный фреймворк,
где они заставляют писать код на своих собственных атомиках и мютоксах на Rust. Но
за этими атомиками и мютоксами прячется Model Checker. И Model Checker перебирает уже не...
Model Checker работает не с каким-то псевдокодом, не с какими-то спецификациями,
он работает уже непосредственно с кодом на Rust, ну или с кодом на C++, это уже неважно.
Вот он перебирает исполнение этого кода. И в какой-то степени мы вот на вопрос отвечаем,
как убедиться, что в коде ошибок нет. Ну можно через Model Checker прогонять сам код. Ну разумеется,
не всякий код, потому что код обычно сложно устроен, и через Model Checker можно прогнать
только какие-то небольшие сниппеты. Ну то есть можно протестировать там маленький, ну,
трэдпул. Можно протестировать какой-нибудь там спинлок или очередь. Но нельзя протестировать
настоящую реализацию RAF, которая работает поверх там каких-то трэдов, файберов, фьюч, потому что
состояния там будет уже безумно много. Их много было даже в спецификации, а в коде настоящем их
будет еще больше, потому что у нас просто больше подробностей. Что делать в этом случае? Вот у нас
есть RAF, то он написан на C++. Вот у нас даже есть уже RAF, и он написан на C++. Где он был? Вот он.
И мы хотим убедиться, что он корректный. Ну правда, вот мы собираемся по этому коду изучать RAF,
а вдруг ему баги есть. Будет неприятно. Как так? Ну вот у нас уже написан код, понимаешь, что это
сложно взять и... Во-первых, нужно будет переписать весь код, что довольно сложно. Ну и где-то он с этим
фреймворком не сойдется, допустим. Ну да, ответ очевидный. Мы не можем в таком масштабе использовать
уже перебор. Мы не можем делать model checker. Нам нужно использовать fault injection. Было бы здорово,
если бы мы fault injection держали в уме, когда мы писали этот код. Но есть уже какие-то системы,
которые написаны без учета fault injection, а тестировать их нужно. Убедиться, что... Ну да,
мы верим, что эти системы построены на корректном дизайне, но в системах просто бывают баги,
связанные с конкурентостью, связанные, там не знаю, с чем-то. Автор не выспался. Нужно убедиться,
что в самой реализации багов нет. Fault injection внутри системы мы строить уже не можем, потому что
вот код написан, это очень сложно было бы сделать. Ну вот для таких задач существует решение. Его
придумал замечательный человек, которого зовут Кал Кингсбери. Вот, я не знаю, у меня где-то...
Есть ли где-то его доклад? Ну давайте посмотрим. Минутку буквально. Он очень забавный.
Секунду.
Ну вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот,
Но у нас не DevFire.
Ю Kwang-Chi, не делайте眾드�fer, manage.6i for the fire.
menosenedORY, ищите результаты accomplishment.
называется Jepson. Вот репозиторий на GitHub. Этот фреймворк фолтинжекшена, где фолтинжекшен,
кстати, он тестировал у Kevin, потрясающе, где он запускает в виртуальных машинах узлы системы и,
там, не знаю, через IP tables ломает между ними маршрутизацию, двигает системные часы в
контейнерах, не знаю, перезагружает что-то, ломает что-то. То есть он буквально ломает физический
мир на уровне операционной системы, в которой узлы выполняются. То есть нам не нужно менять код
нашей системы, мы можем снаружи все это так вот ломать. И он занимается этим более-менее
профессионально. Ему заказывают исследование корректности разработчиков этой системы,
он исследовал, кажется, буквально все, что есть. Монгодиби тут много раз упоминается,
вот он продолжает, ее продолжают писать, он продолжает ее ломать, ищут там какие-то баги.
Вот. Что он искал в последний раз? Кажется, какие-то баги с транзакциями связаны. Ну,
вот, рисовал какие-то безумно странные картинки про причинность. Вот это можно делать, не залезая
внутрь системы, просто зная, что, там, не знаю, она реализует атомарное key-value с операции CAS,
или она реализует key-value с транзакциями. Вот мы пишем стресс-тест, где мы проверяем некоторые
варианты, что, не знаю, мы делаем n-анкрементов и получаем значение n, в итоге, в ящике памяти. И
запускаем этот стресс-тест вместе с тем, нагружая систему какими-то проблемами в виде рестартов
узлов, двигаем часы и, там, не знаю, ломаем сеть между узлами, строим какие-то партишины. Вот таким
образом можно тестировать код, который написан без учета, без учета возможной верификации
возможного fault injection внутри. Но если вы чуть аккуратнее, то вы можете писать код и учитывать это,
то есть просто закладывать на стадии дизайн. Вот вы, у вас есть дизайн-ребью, вы к нему написали
спецификацию системы. Вы, давайте откроем, сейчас я найду картинку, статью про это. Вот, это статья,
напомню, «Амазона», про «Эксвежую систему», это статья 20-го или 21-го даже года, помню, 20-го все-же.
Вот, они пишут, что они используют формальные методы для того, чтобы провалидировать дизайн. Ну,
во-первых, они используют их для того, чтобы задокументировать свой дизайн, а во-вторых,
чтобы проверить какие-то safety liveness свойства с помощью model checker TLC. Но вместе с этим они
весь свой код пишут в фрейворке, который абстрагирует все детали физического мира.
Вот, и дальше умеют запускать этот код в режиме симуляции детерминированной для того, чтобы
убедиться, что сам код не нарушает свойства уже. И это тот же самый fault injection, что и в Jepsen,
то есть вы могли бы снаружи также ломать сеть или также ломать часы. Но когда вы это все
промоделировали внутри, то, во-первых, такие тесты работают, ну, не знаю, на какое количество
порядков быстрее. Видимо, какая-то колоссальная разница там должна быть в миллион раз быстрее. А
кроме того, вы можете просто более сложные сценарии проворачивать. То есть вы можете написать поломку
вашего кода в симуляторе совершенно, ну, не знаю, любые партишины в сети в симуляторе сделать
гораздо легче, чем в реальном мире. Любой дрейф часов, короче говоря, все, что вы можете представить
себе, все сбои, которые вы можете вообразить, и гораздо проще моделировать кодом в симуляторе,
чем пытаться делать их снаружи. И проще, и быстрее, и можно сделать это гораздо разнообразнее. Вот эта
идея, мне кажется, это не они придумали, потому что такой подход используют в Apple в системе,
которая называется FoundationDB. Вот опять, не важно, что это за система, важно, что в 2013 году про нее
был замечательный доклад, про то, что это, кажется, первые люди, которые в мире, которые решили
сделать так, решили абстрагировать весь недотерминизм, который в системе есть, весь внешний мир,
сеть, часы, диск, время, и написать весь код поверх симулятора. Это позволяет, во-первых,
делать fault injection, гораздо внедрять сбои вообще в любые места вашей программы, и, во-вторых,
добавляет, что важно, дотерминизм, воспроизводимость. Вы можете, если у вас проблемы,
воспроизвести исполнение и добавить отладки. Короче, вы понимаете, что это значит. И вот точно
так же они начали с того, что написали собственную библиотеку Concurrency, потому что она им нужна была
для дотерминизма, для того, чтобы они контролировали, что там нигде нет хэшмэпов, нигде нет потоков,
которые не дотерминированно планируются. Ну и фреймворк у них, у них тоже открытый код,
можно посмотреть на их фреймворк, он называется Flow. Там у них такие акторы с фьючами, но акторы,
они здесь, это такое расширение компилиатора, но я бы сказал, что сейчас это более-менее
эквивалентно к рутинам. В смысле цель у них точно такие же, то есть скомпилировать код в
какую-то стейт-машину. Вот они это сделали, они получили дотерминизм на уровне Concurrency и дальше
они пишут весь свой промышленный код с помощью этого фреймворка и с помощью симулятора. Ну и
также у них симуляция задается одним числом и на выход дают одно число и другое число. Если там,
не знаю, сиды одинаковые, а дайджесты получились разные, то, видимо, там, не знаю, код дотерминирован,
доверять ему нельзя. Вот и так можно написать большую промышленную систему. Вот оно.
Конечно, этот подход тоже несовершенен, потому что вы, кажется, понимаете, чем симуляция
отличается от реального исполнения тем, что, например, в симуляции в шаге потока, в шаге файбера не
идет время. Вот у них такая же проблема, у них есть доклад, где они описывают все эти трудности. У них
тоже время не идет, потому что непонятно, как можно было бы двигать часы, когда файбер исполняется,
если мы хотим делать дотерминированно все. Но в целом никто вас не заставляет использовать один
подход. Разумно использовать все. То есть вы по возможности закладываете, вы проектируете вашу
систему, пишете дизайн документ в виде спецификации на TLA, вы используете Model Checker для того,
чтобы провалидировать какие-то аспекты, вы используете эту спецификацию как форму документации для
вашего дизайна, а дальше вы пишете код. Ну я не сказал разумеется, с чего нужно начинать. С того,
чтобы выбрать правильный язык и уже к нему добавлять все эти инструменты fault injection и внешний
и внутренний. И с языком тут тоже очень интересно, в смысле это отдельная сторона вопроса и отдельный
современный тренд. Как, куда современные языки двигаются. Вот разумеется, вы пишете систему,
не на питоне, не потому что питон медленный, а потому что питон динамически типизированный.
Если вы когда-нибудь писали, видели проект на питоне большой, видели тесты, то вы знаете,
что в этих тестах проверяется, что верно ли, что мы там отправили функцию в строчку и получили
назад тоже строчку. То есть мы просто проверяем типы, которые в языке типа C++ были бы зафиксированы
на уровне сигнатуры функции и проверил компилятор при компиляции. То есть нам необходимо статическая
система типов, но вот вариативность здесь огромная на самом деле. И о чем я сейчас сформулирую,
достаточно емко, о чем я хочу сказать. Типы в языках программирования, они не про то, что там,
не знаю, нельзя умножать строчку на число, но в некоторых языках можно, не будем сейчас о них,
строчку на строчку умножать не стоит, наверное, всегда, ни при каких обстоятельствах. Так вот,
система типов не про это, не про то, чтобы запретить такие безумные ошибки. Вообще,
есть такая мета интуиция очень сложная, про то, что описание типов в языке в некотором смысле
эквивалентно формулировке теориям, а тело функции — это ее доказательство. Вот если эту идею развить,
она очень содержательна, то можно понять, что система типов, она про какие-то статические
свойства программы. Вот если у вас есть программа на C++ и вы запускаете ее, наверное, вы уверены,
что вы там две строчки не перемножаете внутри. Но может быть, у вас есть там висящие указатели.
Ну, что вы делаете для этого? Вы для этого заводите адрес-санитайзер, и он проверяет,
что у вас память не течет в конкретном исполнении. Но это проверка в рантайме, точно так же,
как Питон проверяет, что вы не умножаете две строчки в рантайме. Просто проверка другого рода.
Эту задачу можно решить по-другому же. То есть можно взять язык со сборкой мусора и решить
проблемы на уровне рантайма. То есть вам ГО не позволяет получить висящую ссылку,
потому что в ГО вообще нет понятия сториджа, там стэка или куча, где расположить объект,
решается сам компилятор. Ну а дальше рантайм обеспечивает, что пока ссылки на объект есть,
этот объект освобожден не будет. Ну или, скажем, рантайм ГО вам обеспечивает,
что вы более-менее не можете переполнить стэк, потому что он растет у грутина. Но это вот такие
гарантии на уровне рантайма, которые обеспечиваются, а можно достигать гарантии на уровне системы типов.
То есть можно просто построить язык, в котором в системе типов будет заложено, что вы не можете
получить висящую ссылку. Вот, например, вот Rust, он эту проблему решает. Каким образом сейчас...
Это была заготовлена ссылка. Вот пример кода на C++ и на Rust. Здесь мы берем вектор,
кладем вектор в два значения, берем указатель на первый элемент, потом делаем pushback,
потом разыминовываем указатель. Ну и получаем в общем случае use of the free,
потому что этот pushback мог привести к перелокации буфера, и в итоге наш поинтер инвалидировался.
Вот эта программа, в которой есть use of the free, вы можете его обнаружить, запустив ее под
адрес санитайзера, а можете не обнаружить use of the free, потому что в исполнении он не случится,
а где-нибудь продакшн не случится. Вот, а можно эту же проблему решить на уровне системы типов,
то есть просто запретить программы, в которых такая утечка в принципе возможна. Делать это
косвенно в Rust, но в общем довольно просто. Нужно сделать single writer multiple readers, то есть
либо вам разрешается иметь только одну мутабельную ссылку на данные. Вот у вас здесь есть мутабельный
вектор и мутабельная ссылка на его элемент, и вы дальше мутируете вектор через одну ссылку,
а потом читаете элемент через другую ссылку. И вот вы свойства потеряли, но корректность
потеряли. Что делает этот раз? Он говорит, что не может быть в программе одновременно с мутабельной
ссылкой другая мутабельная, или вообще любой рейхеринг, через который можно читать. Если
есть мутабельная ссылка, то значит других ссылок нет. Вот такой простой вариант, его можно проверять
на уровне системы типов, на уровне комператора, и таким образом отслеживать не то что ошибку в
каком-то конкретном исполнении, а апроксимировать ошибки, которые возникают хотя бы в одном исполнении.
Собственно, система типов про это, про то, чтобы апроксимировать все возможные исполнения
программы. Если хотя бы в каком-то исполнении что-то может пойти не так, то значит, неважно,
реализуется оно или не реализуется. Система типов языка может это запретить. Это, в общем,
иллюстрация какой-то системы типов. Можно строить разные системы типов. Например, есть язык Java,
и там все это референсы. Есть value-типы, но, в общем, одни референсы вокруг. И вы понимаете,
что существует в Java такая проблема, которая называется ошибка на миллиард долларов. Кажется,
про то, что за каждым референсом может лежать null. И вообще-то, когда вы вызываете через референс
менять какой-то объект, тут нужно узнать, убедиться сначала, что этот референс не пустой,
что он на что-то указывает. То есть, как с и плюс-плюс, вы получаете pointer и не знаете,
а вдруг он на null-пойнтер ссылается сейчас. Поэтому в языке Kotlin есть понятие null-safety
или null-ability, его еще называют, про то, что вы не можете, если вы не уверены, если в ссылке может
быть null или не null, если null может быть в ссылке, то вы не можете обратиться через нее к объекту,
пока вы не убедитесь, что там не null. Тут где-то был простой пример. Ну вот, у вас есть ссылка,
и вы можете обратиться к полю длина, только если вы проверили на не null сначала. Это вроде бы
простые соображения, но тут дело в том, что сам компилиатор, сама система типов заставляет вас
это делать. Вы не можете не проверить, иначе ваша программа не скомпилируется. Вот идею можно
расширять. Есть null-safety в Kotlin, есть lifetime и разделяемое-неразделяемое владение в Rust.
Есть другая проблема. Скажем, вы пишете сокеты, и если вы знаете API-сокетов, то вы знаете,
что чтобы получить работающий сокет, нужно сначала его построить, сказать на нем bind,
сказать listen, сказать accept. Вот такой пайплайн пройти из четырех операций. А что делать,
если вы в программе написали listen, но не написали перед этим bind? Еще один класс ошибок,
которые вы можете совершить. Система типов может вам помочь и с такими ошибками. Это
называют state-safety. То есть вы можете как-то на уровне системы типов закодировать, что методы
объекта можно вызывать только в каком-то порядке. И если вы вызываете их не в таком, то компилиатор
тоже может сослаться на это как на ошибку. То есть можно было бы сказать, что можно же просто таких
ошибок не делать. Можно, конечно, всегда делать все правильно, не получать инвалидированные
итераторы, вызывать методы в правильном порядке, не обращаться по null-pointer никогда. Конечно,
можно с помощью дисциплины человеческой, но какие-то проблемы можно переложить на компилиатор.
И вообще тут возможности совершенно фантастические могут быть. Есть понятие зависимых типов,
когда вы можете добиться следующего. Вы можете иметь не просто тип матрицы, скажем, или вектор,
а вы можете иметь тип матрицы размером n на m. И вы можете написать функцию, которая умножает
только матрицы, у которых размеры согласованы. При этом не то, чтобы эта матрица как бы на стадии
компилиации написана, что она размера 3 на 5. Нет. Вы читаете там из файла какое-то значение,
при этом вы можете создать дальше матрицу, и при этом они все равно перемножаются правильно.
Или вы не можете обратиться к нулевому элементу пустого вектора. Вот такие ошибки тоже можно было
в runtime отслеживать, а можно построить настолько сложную систему типов, которые и их будет находить.
Вот скажем, есть вариация Husker, которая это позволяет делать, в которой вы не можете
выбрать функцию head на списке от пустого списка. Список должен быть не пустым, иначе это будет
ошибка компилиации. Это не то же самое, что constexpr и C++, на всякий случай.
constexpr он про то, что он известен на этапе компилиации. Длина списка может быть неизвестна на
этапе компилиации, а проверка все равно работает. В этом и суть. А проверка в runtime работает? Нет,
еще раз. Проверка работает на стадии компилиации, разумеется. Так мы же не знаем размер. Так задача
сложная. Это самое сложное, что в языках программирования бывают зависимые типы.
Это тема другого курса. Написать компилятор, который поддерживает зависимые типы, это очень сложная
задача, потому что задача проверки в такой системе типов вычислительна крайне сложная.
Тут очень много трейдовов, очень много сложностей. Конечно, звучит очень невероятно,
но задача-то непростая. C++ этого не будет никогда, потому что по миллиону разных причин.
Это делают не просто так в функциональных языках, в первую очередь. Можете еще раз повторить объяснение,
почему constexpr не подходит? Потому что ты читаешь список из файла или по сети и получаешь.
Почему тут constexpr? constexpr — это то, что есть в программе на стадии компиляции. Я взял в
программе вектор, сделал в него один pushback, сделал второй pushback и сделал третий pushback,
а потом я сравниваю. Я взял два вектора, в одном сделал три pushback, в другой четыре pushback,
а потом пытаюсь скалярно их перемножить. Вот такая программа, она вот ясно делает… что?
— В языках, о которых вы говорите, с такими типами, тип известен на этапе компиляции или нет?
— Ну в смысле? Ты пишешь, не знаю, грубо говоря, список, но просто не ограничивай у себя constexpr,
и все. Ты сделал три pushback, ты сделал четыре pushback, ты пытаешься скалярно перемножить,
и, конечно, функция, которая скалярно перемножает два вектора, выдаст тебя компиляции, потому что,
ну просто по тексту программы можно было бы понять, что нет, это работать не будет.
При этом на этапе компиляции сами вектора неизвестно еще.
— Какие-то статические анализаторы кода, которые могут…
— Ну какие статические анализаторы? Понимаешь, что компилятор — это есть статический анализатор
кода, он этим и занимается. Просто задача очень сложная.
— Ну то есть, условно говоря, он проверяет то, что там где-то был if, то что n равно равно m,
и только после этого разрешает вызов. То есть он в каком-то смысле проверяет, что там где-то
был как вкотлени, типа if n равно равно m, только потом разрешит этот вызов функции перемножения.
— Да, но для этого нужно и мог это понять, что вот какое n и какое m, всегда ли оно сходится или может
не сходится. Но это очень сложная задача. Поэтому ее решать-то в промышленных языках вроде бы и не
пытаются. Вот есть для хаскера какая-то вариация, там что-то сделали. Но это прям супер-супер сложная.
Вот мы, наверное, на такое рассчитывать не можем, но вот мы можем использовать… Ну вот no safety и то
как бы делали сколько лет. Это сложная задача, потому что она требует как бы и синтезис определенным
образом задизайнить, чтобы он под это все подходил. Тут есть нюансы, про которые можно поговорить,
но это как бы еще раз, это отдельный курс. Сейчас мы просто… Я просто обозначаю, что корректность,
она обеспечивается, конечно, не только проверками в runtime, не только как бы формальной спецификации
на стадии дизайна и не только там fault injection при исполнении, но еще просто выбором языка и
развитием языков программирования. Все это тоже помогает. То есть задача решается с самых разных сторон.
Вообще говоря, система типов в языках программирования — это супер-сложная область,
супер-большая. Ее развивает много лет уже, и там как бы замысел-то один в системе типов — как
делать больше статистических проверок, не исполняя программы? Как проверять более-более сложные
свойства программ? Вот то, что ты не можешь перемножать строчки — это довольно простое
свойство. А вот то, что ты там не получаешь всяких ссылок, или что ты не можешь получить data race,
или то, что ты не можешь обратиться к полю через null-ссылку, или про то, что ты не можешь вызвать
bind после listen — это уже менее тривиальные свойства, и для них нужны специальные системы типов,
и вот это огромная научная область. Итого, мы пишем спецификацию, мы выбираем подходящий язык,
мы на нем пишем программу, где какие-то отдельные маленькие юниты мы можем, не знаю, тестировать,
верифицировать помощью model-чейкера, типа лог-фри очереди, но на уровне кода мы используем
fault injection, возможно, если мы можем использовать fault injection, который мы внедряем в свой проект
сразу, и мы используем fault injection снаружи в виде фреймворка Jepsen, который позволяет нам статически
убедиться, не модифицируя код, что система ведет себя снаружи в соответствии с поставленными,
с гарантиями, которые сформулировали в самом начале. Наконец, вот последнее, что я скажу,
и на этом закончу, потому что устал. Можно идти еще дальше и использовать,
но то, что таким словом называется, то есть вы берете свою систему большую, вы там потестировали
ее Jepsen, день-два, погоняли какие-то маленькие тесты, а дальше вы разворачиваете у себя, не знаю,
тестовый кластер и просто запускаете на ней демона специального, который ходит, периодически там,
не знаю, перезагружает машины, что-то портит, и вот это происходит так в фоне. Не так, чтобы система
стала полностью недоступна, но вот просто увеличивает число разнообразных событий,
которые с ней происходят, и вот в таком режиме кластер живет, с ним работают люди, и вот вы уже
через людей пытаетесь понять, есть ли какие-то баги, репортит они вам их или нет, потому что
любые тесты, синтетические или спецификации, вы проверяете то, что вы сами ожидаете от системы,
и скорее всего, просто так устроено человеческое мышление, что он проверяет то, что он знает,
что работает, а то, что он не знает, что у него работает, он обычно не проверяет, вот поэтому
дальше приходят люди, они тестируют вашу систему своими настоящими задачами и узнают, что в ней
все-таки баги есть. Ну и пройдя через все вот эти круги ада, мы в конце концов можем быть уверены,
что наша система, наверное, работает, написано корректно. Все, у меня на сегодня все.
