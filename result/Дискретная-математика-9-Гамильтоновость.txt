Ну давайте снова алгоритм Flurin, повторим, я тогда про
него ничего толком доказать не успел.
Значит дано илеров, илеров связанный граф, ну илеров граф.
Значит, старт, стартуем из любой горшины, из любой горшины,
и из любой вершины, и двигаемся по любому ребром, по любому ребром.
Там мостов нет в начале, все степени вершин чётные, в самом начале степени
вершин всех вершин чётные, мостов там быть не может. Можете проверить, что если степень
всех вершин чётный, то конечно там нет мостов. Это первый шаг, говорю, повторяю,
первый шаг. Тут никаких засад быть не может в начале, потому что мы ещё не нарушили структуру
графа, он ещё хороший. Значит, пройденные ребра удаляем, но вот тут вот уже могут быть
проблемы. Мы начинаем резать ребра, и вот тут уже начинаются всякие беды в этом месте. Значит,
шагу. Значит, из вершины, в которые мы пришли, мы можем выйти, потому что степень вершины
чётная, мы удалили ребро, но степень чётная, значит, есть ещё одно ребро, по которому можно
выйти. Для выхода, для выхода выбираем ребро, не являющийся мостом,
если же такого ребра нет, то двигаемся по мосту. Если такого ребра нет,
то двигаемся по мосту, опять же пройденные ребра удаляются.
Ну, критерии остановки нет ребер. Нет ребер, по которым можем выйти.
По которым можно выйти из вершины. Нет ребер, по которым, то есть, локально всё проверяется,
то есть, в окрестности конкретной точки, в которой мы оказываемся, можно выйти из вершины. Ну,
собственно, всё. Давайте докажем, что вот был вопрос, почему там не может быть два моста. Как
раз сейчас мы про это поговорим. Я просто тогда даже не начал доказывать корректности, в
доказательстве в самом деле более-менее эти вещи прояснены. Значит, смотрите, утверждение.
Алгоритм Fleury построит Эллеров цикл. Давайте докажем.
Ну, предположим, давайте первое утверждение. Алгоритм Fleury построит просто цикл, как минимум.
Он берет ребра и соединяет ребра в цикл, он же по ним ходит, пройденные удаляет, чтобы как раз
второй раз по одному и тому же ребру не пройти. Он строит цикл, потому что он двигается по ребрам,
которые собираются в цикл. Алгоритм Fleury построит цикл просто пока что. Как вы думаете,
почему-то он обязательно именно цикл построит. Он построит цикл по той причине,
что он не может закончить никакой другой вершине. Во всех промежуточных вершинах, отличных от
стартовой, есть ребро, из которого можно выйти, потому что степень четная. Единственная вершина,
в которой он дальше пройти уже не сможет, это вершина нечетной степени, которая есть стартовая.
То есть вершина, которая проходит по серединке, там остаются степени вершин всечетные. И поэтому,
даже если он может не элировать цикл, цикл точно построит, потому что он не закончит до тех пор,
пока не вернется в начало. В любом случае у него будет куда идти, пока мы не вернемся в начало.
Алгоритм не может закончить. Закончить работу в не стартовой вершине.
Так как все степени всех вершин четные и все вершины, кроме стартовой, остаются
с четной степенью и все вершины, остаются с четной степенью.
В процессе работы алгоритма. Ну что ж, он построит цикл.
Ну, вторая часть утверждения. Собственно, он построит эйлеров цикл. Давайте. Алгоритм
флеури. Не знаю, как правильно, если честно, построит эйлеров цикл. Ну, хорошо. Вот мы запустил алгоритм,
он закончил и, предположим, остались ребра. Понимаете, в чем дело? Вот вы описывали ту ситуацию,
когда у нас вот что-нибудь такое. Почему такая ситуация в промежуточных шагах работы возникнуть
не может? Ну, дело вот в чем. В том, что если он пройдет по вот этому мосту, то он здесь останется,
но он должен цикл построить, то есть он должен как-то вернуться в начало. Если начало не в этой
компоненте связанности, то противоречит получается. Мы же выяснили, что он обязан вернуться в ту
вершину, с которой начинал. Опять же, если же стартовая вершина здесь, то у нас получается что?
Если стартовая вершина в этой компоненте связанности, то получается, что мы прошли,
образовали мост, до этого его не было. То есть как-то мы там прошли, вошли вот в эту компоненту
связанности, стартовали, вошли в эту компоненту связанности, здесь порушили, а потом мы хотим
опять назад. Почему так не может быть? Получается, мы вот эту компоненту связанности вообще не
обрабатывали. Выходит так, да? Но граф Эйлеров, давайте подумаем, может такое произойти в Эйлеровом графе?
Ну как бы, смотрите, если единственное, понимаете, получается, что вот здесь мы не работали, это ребра
мы не трогали. Это оригинальный граф, это ребра оригинального графа без всякого удаления ребр.
Получается, что у нас единство, вот есть компоненты связанности здесь, есть компоненты
связанности здесь, и между ними единственный мост. Но такого в Эйлеровом графе быть не может.
Да, конечно, в алгоритмах Лери нужно сначала проверить, что граф Эйлеров, потом ему давать
собственно строить. Так вот эта штука, вот такая штука была в изначальном графе, потому что,
ну, иначе. Ну, значит, получается, если мы стартовали здесь, значит, мы как-то вот сюда вышли,
потом здесь, что-то походили и хотим обратно вернуться. Ну, значит, мы вот тут ничего не трогали.
Ну, а если мы тут что-то трогали, то тогда вот, вот эта часть, смотрите. Пусть в конце алгоритма,
давайте, в конце алгоритма, работы алгоритма, останется, остались ребра. То есть он вернулся
в старт, в начало, но ребра остались. Остались ребра. Рассмотрим любую компоненту связанности,
которая в самом конце, после окончания работы осталась. Как? Рассмотрим любую компоненту связанности.
Раз ребра остались, значит, есть компонента связанности, неодновершенная, неизолированная вершина.
Рассмотрим любую компоненту связанности,
состоящую из двух вершин, состоящую из больше либо равно, чем двух вершин,
которые осталось после работы алгоритма.
Вот. Что у нас тогда получается? Вот давайте представим в себе картинку. Вот здесь К есть,
что тут происходит вообще наверху. Я помню, что в школе, когда мы занимались там на каких-то
этажах, ниже выше был спортзал и там все время прыгали, но здесь вроде спортзал совершенно в
другом месте. Так, смотрите, вот эта компонент связанности, неодновершенная, и давайте найдем
последний момент, когда мы в ней были, но вот следующий шаг, мы уже из нее вышли. Ну, то есть,
вот последний шаг, в который мы еще пребывали внутри этой самой компонент связанности. Рассмотрим.
Шаг М. Последний шаг. Алгоритм. При котором мы были в К. Мы были в К. Все, точка.
Последний шаг. То есть, следующий шаг уже не в К. Ну, что ж тогда получается? Получается, что вот мы
куда-то дальше, вот сюда пошли. То есть, прошли по ребру, а это был мост. Получается, мы не прошли
компоненту связанности, у нас и была возможность пройти не по мосту, но мы пошли по мосту. Это мост.
Противоречие. Поняли? Вот. То есть, вот такая же картинка, ну, посередине, когда может возникнуть,
когда у нас вот здесь что-нибудь такое было, да, то есть, у нас не мост был изначально, тогда мы сюда
вошли, что-то тут поделали, потом вернулись, но здесь что-то осталось, но вот по тому, что мы доказали,
так не может быть. Здесь ничего не останется, если мы тут сюда зайдем и начнем тут действовать.
Поэтому, если мы туда не заходили, то противоречие, потому что граф Эйлеровым,
такой граф Эйлеровым быть не может, если же мы туда заходили, то не должно быть, не должно
ничего остаться, в смысле ребер там вообще, вот. Поэтому тоже так не бывает. Но вот в итоге построится
Эйлеров цикл. Вот. Ну, не знаю, насколько этот компьютерный алгоритм, потому что, видите,
на каждом шаге нужно проверять две вещи. Что мост? Мост — это глобальная проверка, проверка того,
что изначально граф был, ну, по крайней мере, в какой-то, кроме изолированных вершин, связан,
а после удаления перестанет быть связанным. Вот эта проверка я не могу себе понять. Но,
насколько я понимаю, там есть алгоритмы, я знаю даже некоторые алгоритмы, которые это делают.
Расстояние между вершинами в графе считают, но это все-таки какие-то довольно, не то чтобы
очень быстро. То есть, это довольно быстро делается, но если каждый раз это делать,
мне кажется, все-таки довольно тяжеловесным получится. Так. Ну, что ж. Все, что хотел
проигрывать, рассказал. Теперь давайте начнем с гамильтоновости. Ну.
Смотрите. Вы же знаете, да, откуда возникла эта задачка про гамильтоновость. Что иногда называют
задачками коми-вояжора. А кто такие коми-вояжоры? Это люди, которые ходили по домам и втюхивали
людям всякую дрянь. Вот. Ну, всякий шерпотреб, который не очень качественный был. И поэтому
у них была прямая заинтересованность не вернуться в тот город, с которым они уже были. Вот. Там люди их
не любили и помнили. Вот. И поэтому вот они думали, можно ли как-то вот так пройти к побольше городов,
но чтобы никуда в два раза не попадать. Вот. Ну, вот так. Значит, определение. Кравжи гамильтонов,
если в нем есть цикл, который проходит по всем вершинам ровно один раз.
Ну, это, знаете, приложение, так сказать, 18 века. А вот приложение современное, конечно,
более к созданию микросхем скорее. Там есть заинтересованность. Смотрите, вот, при нанесении
этих элементов на микросхему. Есть автомат, у него есть головка, которая наносит эти самые
элементы. Она должна двигаться по какому-то, по какой-то траектории, по линии наносить.
Соответственно, в чем интерес? Главное, чтобы она пока побыстрее прошла, никуда не возвращаясь,
чтобы быстрее работала по микросхеме, при этом чтоб вернулась в исходную точку для нанесения таких
же элементов на следующую микросхему. То есть тоже, по идее, есть масса точек на этой плате,
которую нужно сделать и нужно обойти эти точки так, чтобы не возвращаться никуда два раза.
Желательно. Причем по циклу. Значит, задача сложная. В Эйлер-вости, видите, есть алгоритмы,
есть легкие критерии проверки того, что граф Эйлеров, гамильтоновость, задача сложная, алгоритмов.
Проверки гамильтоновости, судя по всему, нет. Но все четко доказано, что связано с задачей,
пресловутой задачей p равно np. И в зависимости от того, верно это гипотеза или не верна,
алгоритм есть или нет, поскольку мы не верим, что она верна, то скорее всего алгоритма нет.
Ну, вот как-то так. Потому что мы не хотим, чтобы наши криптоалгоритмы легко взламывались,
если p равно np, то они взламывают легко. Как раз таки большинство современных криптоалгоритмов,
которые существуют на настоящий момент, то есть не все. Мы ученые понимали, что твердость и не
взламываясь наших шифров зависит от этой дурацкой гипотезы, про которую никто ничего не знает.
И поэтому придумали шифры, которые не зависят от этой гипотезы, но все же более простые шифры
основаны на ней. Поэтому нам не хочется, чтобы шифры основные легко взламывались,
и поэтому p, наверное, не равно np, а поэтому и гамильтонового из алгоритма нет. Это то,
что изучает в курсах сложность вычислений. Поэтому, ребят, обратите внимание, то, что я сейчас буду
рассказывать, это не критерии гамильтоновости, таких не существует, что на самом деле довольно
странно. Можно же, наверное, придумать какой-нибудь очень сложно проверяемый на практике, вообще не
проверяемый на практике критерий, который критерием был при этом. Но не знаю, я не встречал именно
критериев гамильтоновости. Вот признаки есть. Не гамильтоновости есть много признаков, то есть если
граф вот что-нибудь такое содержит, то совершенно точно уже не гамильтонов, например, признаки. По
обратную сторону опять не работает. Признак гамильтоновости есть, если граф что-то есть,
то он совершенно точно гамильтонов. Вот признаки не гамильтоновости я вот на семинары оставил,
скорее там в семинарских листочках они есть, а признаки гамильтоновости мы сейчас с вами
рассмотрим некоторые. Первый признак Дирака. Вот этот конкретно признак Оры называется. То следствие,
которое я из него выведу, частный случай фактически признак Оры называется признаком Дирака.
Вот. Значит, если в графе же военные, для любых двух вершин,
двух вершин, ув, несоединенных ребром, степень У плюс степень В, больше либо равна чем Н,
суммарно. То есть вот такая данность есть. Для любых двух несоединенных ребров вершин,
суммарно степень больше либо равна чем Н. Так Н это количество вершин, да. Вот. Н это количество
вершин. То граф гамильтонов. Работает только в одну сторону, ребят. Но почему, предупреждаю,
потому что каждый раз находятся студенты, которые применяют его в обратную сторону. Не признак
вот этот вот. Вот это условие не выполнено, значит он не гамильтонов. Конечно, нет. Ну, конечно,
нет. Есть графы гамильтонов, для которых это условие не выполнено. Безусловно. То есть что
этот признак графжа гамильтонов? Есть очень классические гамильтоновы графы, называют
простые циклы на вершинах. В них этот признак не выполнен совершенно точно. То есть что этот
признак говорит? Эти циклы содержат очень мало ребер, но при этом они гамильтонов. И нельзя
сказать, что любой там граф на вершинах с ребрами гамильтонов. Конечно, нет. Тоже неверно. Вот.
То есть там, вот смотрите, что вот этот признак Оры, признак Дирока, который позже будет, они все
говорят следующее неформально. Если в графе очень много ребер, то он гамильтонов заведомо. Но если в
нём мало ребер, он может быть как гамильтоновым, так и не гамильтоновым. Это индивидуальная ситуация,
как говорится. И вот тут нужны какие-то алгоритмы, но их нету. Вот, к сожалению.
А здесь, на самом деле, фактически то, что здесь описывается, называется плотный граф. Но очень
много ребер. Почти максимально возможное количество ребер. Само собой, полный граф на
н-вершинах. Конечно, гамильтонов. В чём вопрос, как говорится. Если одно ребро из полного графа
на н-вершинах, то у нас останется гамильтоновым. Но вот до какого момента можно удалять, как говорят,
чтобы он всё же гарантированно остался гамильтоновым? Примерно про это признак Оры. Дальше, вот если
правильно удалять, то он всё равно останется гамильтоновым. Если неправильно удалять, то нет.
Но вот как-то так. То есть там уже разница. То есть самый интересный случай про гамильтоновость — это
никогда очень много ребер. Там совершенно понятно. Он точно гамильтонов. Всё, вопросов нет.
Там возникает другой вопрос числоприкладной. Как этот цикл найти? Мы знаем, предположим,
из каких-то источников, что он гамильтонов. А как найти этот цикл гамильтонов? Казается,
тоже нет алгоритма нормального. Есть какие-то более сложные, чем полиномиальные. Нормального
тоже нет. Это тоже трудная задача, оказывается. В заведомо известном гамильтоновом графе найти
цикл гамильтонов. Смотрите, что у нас получается. Давайте докажем. В данном
случае у нас граф содержит совершенно очень много ребер. Безумно много на самом деле. Что это за
безобразие? Суммарная степень больше либо равная, чем эта. Сколько у него ребер. Ну пусть и Женя
гамильтонов. Пусть существует Ж, удовлетворяющий условиям задачи, условиям теоремы,
которые не являются гамильтоновым. Вот. Смотрите. Вот кто может доказать,
что из условия сразу автоматически следует, что граф связан. Понимаете, да? Не связанный граф
гамильтоновым быть точно не может. Почему из вот этого? В этом условии не написано,
что он связан. Но вот на самом деле из этого условия уже следует, что он связан. Но там настолько
много ребер, что он не связанным быть не может, если это неформально. Вот как это доказать?
Как? Ну да, но как доказать, что он не связан все-таки? Ну не обязательно. Подумайте,
даже если вершина на ребер, может не связанный граф и сделать. Да, все правильно. Все правильно,
все правильно. Если есть две компоненты связанности, хотя бы две компоненты связанности,
возьмем две вершинки из разных компонентов связанности. Их суммарная степень какая? Ну,
максимум, наверное, n-1, да? Ну какая? Количество вершин в этой компоненте связанности – –1,
плюс количество вершин в этой компоненте связанности – еще раз – –1. То есть это n-2 даже
самая большая суммарная степень у них может оказаться, правильно? А у нас больше
ребровное, они же точно не соединены ребром. Ну то есть вот из этого условия автоматически следует.
Если же они соединены, то вот что. То УВ и суммарной степенью плюс суммарной степенью В никак не больше,
чем n-2, поэтому противоречие. То есть вот такого рода условия сразу дает нам связанность
автоматическую, так сказать. Вот. Хорошо. Уже связан. Давайте найдем, в нем нет цикла
Гамильтонова, да? Уже нет Гамильтонова цикла, но давайте найдем в нем Гамильтонову цепь.
Понимаете, да? Что такое Гамильтонова цепь? Это цепь, которая, простая цепь,
которая проходит по одному разу все вершины у цепи, не цикла. Давайте, собственно, построим
такое. Может быть, мы немножко его модифицируем, сразу говорю, но давайте отыщем там, сделаем так,
чтобы в нем была Гамильтонова цепь. Вот. Возможно, модифицируя же, возможно, изменяя же,
сделаем так, чтобы уже содержалась Гамильтонова цепь.
Ну давайте, как это сделать? Смотрите. Вот рассмотрим самую длинную цепь,
которая уже у нас имеется, простую цепь. Рассмотрим самую длинную простую цепь уже.
Самую длинную простую цепь уже. Ну вот, какая-нибудь.
Смотрите, давайте добавим ребер уже так, чтобы А, он, ну смотрите, вот это условие
при добавлении ребер само собой сохранится. Так? Но есть беда. Нам же нужно оставить граф
негамильтоновым, то есть мы предположили, что негамильтонов при добавлении ребра мы должны
гарантировать, что он остался негамильтоновым. Но если мы добавили, знаете, как один преподаватель,
с которым я работал, говорил, ну тогда в этот граф можно все ребра докинуть, он сразу автоматически
станет гамильтоновым, и всё, больше ничего с ним делать не надо. То есть мы же противоречить-то не
получим тогда, да? То есть если мы докинем сразу все ребра, которые в нём нет, он станет полным и
сразу окажется гамильтоновым. То есть нужно умным образом добавлять ребра таким образом,
чтобы цепь вот эта самая длинная удлинялась, но при этом гамильтонов цикл не появлялся. Как это
сделать? Ну как удлинить цепь? Логично найти вершину, которая, смотрите, ребра из А1, А2,
так далее АК, из А1, из АК как минимум, только внутри цепи идут, правда? Ну иначе цепь можно
было продлить. То есть из А1, из АК ребра идут только внутри цепи, если они есть, кроме вот этих
оресоновых А1, А2, АК-1, АК, может быть ещё какие-то ребра, то ли тогда они внутри вершин цепи должны
быть, так? Вот, значит рассмотрим любую вершину, которая вне цепи, она с АК, например, ребром уже не
соединена. Давайте эту ребру сюда дорисуем. А почему гамильтонов цикл при этом не появится?
Ну оно и не соединено с А1, всё правильно, да, но ещё, а почему цикл-то не появится,
гамильтонов цикл не появится? Ну, смотрите, предположим, что у нас цикл появился. Вот добавили
это ребро, а вдруг цикл появился. Ну что это значит? Это значит, что этот цикл совершенно
точно данное ребро содержит, да? А значит удалив это ребро, мы сделаем гамильтонов цикл,
гамильтонову цепь, а по нашему предположению это самая длинная цепь, она не гамильтонова. Вот,
поэтому противоречие. То есть в чём беда? Если при добавлении ребра появляется гамильтонов цикл,
значит этот цикл никак по этому ребру не пройти не может. Вот как раз это то ребро, которое нужно,
чтобы он появился. Значит удалив это ребро, мы разобьём этот гамильтонов цикл на гамильтонову
цепь, а значит вот это не самая длинная цепь у нас в графе. То есть рассмотрим любое АК плюс
первое вне цепи, соединим с окатом его ребром, гамильтонов цикл не появится, потому что иначе
этот цикл не самая длинная. Если дальше, возможно, можно это продлить. Ну то есть вот АК плюс первое
добавили, может быть дальше можно пойти, чтобы не повторялись вершины и так далее. Доходим до
того момента, пока опять заступорились, дальше некуда идти. Ну всегда сможем докинуть и таким
образом продлить до гамильтоновой цепи, в этом идее. Всё правильно. То есть если гамильтоновой цепи нет,
то мы вот так вот докидывая ребра по одному, внимание, по одному, получаем гамильтонову цепь
в конечном счете. Поняли, да, ребят? Она длинная К, К меньше чем N. Тогда добавим, рассмотрим любое,
любую вершину АК плюс один вне цепи и добавим ребром,
ребром АК плюс один. Ну в таком случае у нас гамильтонов цикл не появится.
Вот. Ну что ж, продолжаем. Ну теперь давайте, собственно, свела задача к чему, что в графе G
есть гамильтоновая цепь, но нет гамильтонового цикла и условие задачи выполнено для этого графа.
Так, смотрите, что у нас будет тогда. Уже есть гамильтоновая цепь,
нет гамильтонового цикла и G удовлетворяет условиям теоремы.
Смотрите, вот что у нас получается. Вот это давайте я изображу. Вот гамильтоновая цепь наша. Значит,
смотрите, каких ребер совершенно точно не может быть, если мы имеем в виду, что есть и нет
гамильтонового цикла. Вот этого ребра быть не может никак, да? Не ребро. Давайте просто посмотрим,
поскольку здесь серебра графа, обратите внимание, здесь серебра граф по одной, то все ребра из-за 1,
ну смотрите, у нас же условие вон какое, суммарная степень гигантская, то есть вот этими двумя ребрами
из-за 1 и AN, соответственно, ну никак не обойтись. Тут есть куча ещё ребер, которые тоже внутри этой
цепи как-то распределены, да? Вот. И у этих вершин, которые не соединены ребрами, но тут вот
непонятно про них что, но тоже куча соседей, потому что у них суммарная степень очень большая. Так,
ребят? Давайте смотреть. Вот предположим, что у нас из-за 1, например, во 3 есть ребро.
Тогда я утверждаю, что вот такого ребра быть тоже точно не может. Почему? Тогда есть гамильтонов
цикл. Увидите его? Вот он, вот он и вот он. Все, гамильтонов цикл есть. Если первое АИТ ребро,
где И от 3 до N-1, то АНАИ-1 не ребро, так как иначе формируется гамильтонов цикл.
Ну вот на этом, собственно, противоречие мы и построим. Давайте подумаем. Вот отсюда
ДК-1 ребер исходит. Внутрь всё, всё внутри цепи. Каждое ребро накладывает, ну не каждое,
а кроме вот этого, вот этого А1А2, накладывает ограничение. Да, ребят? Давайте посмотрим,
какая суммарная степень может быть А1А1. Но она никак не может быть больше, чем... Давайте
смотреть. Вот эти два ребра есть совершенно точно. Теперь среди вот этих, если есть вот это ребро,
так? Из А1, например, в А3, в А4, то нет. В предыдущие из АН, так? Слава быть. У нас...
Сколько у нас запретов получается? Получается, у нас...
Да, на каждое ребро из А1, кроме одного вот этого, и получается запрет. Всё правильно. То есть у нас
получается... Ну давайте, придется выражать... Ну понятно, да. Сейчас как раз я более формально
это напишу. Вот столько ребер появляется, а вот эти все ребра накладывают запреты, да? Соответственно...
Вот как-то так. Стоп, что-то я переборщил. Нет, стоп, конечно. Вот этих мы говорим про
ребра от А3 до АН-3. Соответственно, здесь АН-3. До АН-2. Я тут все время путаюсь. Помогите мне,
пожалуйста. Так, сколько здесь... Так. То есть И равно Н-5. От 0 до Н-5, тут Н-4. Даже. То есть из
Н-4 вершин от А3 до АН-2. Обратите внимание. Вот столько запретных для ребра из АН. Правильно?
Ну, потому что в АН-1-то ребра есть точно? Значит, вопрос про АН-2 и вот эти вот другие. До А2. В А1
точно нет. Ну вот. Можно даже чуть поправить. До А2. Здесь Н-4, тут Н-3. Соответственно,
вот эти стуки сократятся, получается Н-1. Ну, короче говоря, суммарная степень АН и А1 никак
не может быть больше, чем Н-1 из вот этих запретов. Ну, а противоречие с условием. Все.
С условием теории. Ну, собственно, все, которое доказывает, что вот это признак гарантирует,
что Грав Гамильтонов. Так. Ну, смотрите. Вот эти два ребра точно есть. Теперь вопросы. Вот эти
вершины идут. Вот есть ли ребра вот в эти вершины? Из АН вот в эти вершины, соответственно. Из АН.
То есть, смотрите. Если, смотрите, рассмотрим ребра из А1, которые отличны от вот этого вот.
Их ДЕК А1-1 штук. Каждое такое ребро накладывает запрет на ребро из АН-2. Правильно? Эти ребра
из АН-2 могут быть вот в эти вершины. Их Н-3 штуки. От нуля до Н-4. Да, вот этих вершин. Среди них
нельзя проводить вот во столько вершин. Но, стало быть, максимум вот во столько-минус столько
вершин можно провести. Ну, потому что вот здесь Н-3 вершины. Ну, а я тут от С-3 насчитал. Я считал С-3.
На самом деле, в А2-3 за АН тоже может быть ребро. Ну, да. А если граф не связан, там гамильтоновой цепи
точно нет. Ну и вообще, в принципе, граф не связан, и гамильтоновым быть не может. То есть, сам признак
получается неверен. Если вот это условие не гарантирует связанности графа, то это неверный признак.
Ну, можно подумать. Да-да-да. А, кстати, да, контрпример-то простой. Одна вершина плюс клика,
наверное, с одной вершины. Что-нибудь такое. Точно не гамильтонов граф. Вот. Так. Какой еще признак
гамильтоновости сегодня изучим? Вот так. Сколько у нас времени? Мы в 12.10, да, заканчиваем? Хорошо.
Более слов... А, ну, следствие. Следствие. Признак дирока называется.
Если в графе...
Ж, который ВЕ. Для любой вершины. Степень В. Больше либо рано,
чем от пополам. Где от количества вершин? То граф гамильтонов. Вот так. Следствие признака
Ора. Потому что если степень каждой индивидуальной вершины больше либо ровно, чем от пополам, то
суммарная степень вершин, которые не соединены ребром, точно больше либо ровно, чем Н. Поэтому это
более сильный признак, чем признак дирока. Признак дирока тем более. Говорит, ну, он очень-очень
плотный граф, но вообще ужас плотный. Тут хотя бы половина ребер от полного графа, тогда он
совершенно точно гамильтонов. Ну вот, да. Так. Само собой, если там хотя бы половина ребер от
полного графа, конечно он будет гамильтонов. Куда он денется? Вот. Интереснее, как мы понимаем,
интереснее в случае более разреженных графов. Вот. А про них ничего эти теоремы не говорят. Так.
Есть более тонкий признак Эрдыша Хватова, который я хочу вам рассказать. А для этого
нужно несколько определений дать. Определение. Ну что такое кликовое число графа, знаете, нет?
Так. Я вам это говорил, да? Клика – это полный подграф. Кликовое число – это размер самой большой
клики в графе. Тоже гадская вещь. НП – сложная задача, как ни странно. Я не знаю, почему так
много НП-сложных задач. То есть вот кликовое число нахождения, вот граф задан. Придумать
компьютерный алгоритм – быстрый, который найдет кликовое число. Ну и желательно вычислить эту
самую большую клику. Вот нет таких быстрых алгоритмов. Вот. Оказывается. Поэтому там в каких-нибудь в
веб-графах, в которых там миллиарды вершин, помните, я вам описывал их, там трудно ищутся клики,
но у нас нет быстрого алгоритма, который ищет это все. Вот. И характеристики с трудом вычисляются.
В разе что локально, то есть когда мы ограничим на какой-нибудь миллион, скажем, вершин, может
там что-нибудь там и отыщется. А вот на весь граф не получается, что алгоритмы не могут быстро
обработать такой массив данных. Вот. Но это вот как раз вопросы big data. Почему нам нужны эти
быстрые алгоритмы? У нас огромное количество данных, нам нужно их быстро обрабатывать,
а у нас нет быстрых алгоритмов, чтобы это сделать. Вот. Так. Значит. Смотрите. Ну кликовое число
тогда не определяю. Что такое вершинная связанность? Набор. Набор вершин. Так. Еще раз.
Минимальное число вершин. Минимальное число вершин. Которые можно удалить из графа G,
из связанного графа G. Так, чтобы он потерял связанность.
Называется вершиной связанности графа G. Вершиной связанности графа G.
Обозначение вот такое. Так. Господи. Что же я не могу нарисовать? Вот. Капа G. А вот. А если вы
помните, число независимости, например, обозначается альфа, да? Так. Ну давайте. Теперь
признак карточки хватало. Да? Вопрос какой-то? Ну вопрос. Хорошо. А вот какая вершина связанная,
скажем, у дерева? Да. Тогда один. Потому что, да, достаточно одну вершинку удалить, чтобы оно
потеряло связанность. Все правильно. Вершина. Ну два получается. Ну пустой граф связан, да.
Пустой граф связан. Поэтому два. Клика это полный под граф. То есть граф, под граф,
в котором между любыми двумя вершинами есть ребро. Проведено ребро. Вот. В данном случае нам
нужнее не кликовое число, а число независимости. То есть под множество вершин, в котором между
любыми двумя вершинами как раз наоборот нет ребра. Вот теория. Вот не уверен, что мы успеем ее доказать
сегодня, но начнем. Признак картоша хватало. Вот здесь, вроде бы, это оба венгерские имени,
но вроде бы Райгородский, это с этим хватало, он общался, он знает, как его фамилия произносить.
Вот. Да. Ну Эрдыш, я как говорил, он в 90-е годы умер. Например, ну мне не было шанс,
но там Райгородский мог пообщаться. Не знаю, вроде он не общался с ним. Лично с Эрдышем. Вот. Да.
Так. Просто знаете, как это пишется по-венгерски? И вот вопрос, что вот это, что эти две точки
означают, это все-таки не «о» и не «е», а какая-то там... Ну вот, в общем, я могу произнести эту букву,
но в русском языке такого звука нет, поэтому... Да. Это «э», вот. Соответственно, поэтому
транслитерируют по-разному. Вот. Ну, на самом деле, это нормальное дело, ребят. Это в английский вам
повезло, там нет букв, там нет звуков, которых нет в русском языке. Вообще-то в языках разный набор
звуков. Вы должны знать. Я, например, киргизский учил, там еще три звука, кроме обычных, кроме тех,
которые в русском имеются. Это обычный, при этом этот набор звуков характерен для всех тюркских
языков. Там вот эти звуки все есть. Там адыгейский, я посмотрел, это ужасный совершенно язык, там
56 согласных. Вот. Это вот как раз ниндоевропейские языки автохтонные. Там жуткий набор звуков. Так.
Так. Ну что ж. Пусть графежем. Верно, вот такое. Так-так-так. Число независимости у нас нет,
наоборот. Вершинная связанность будет... Так, стоп, стоп, я путаюсь, я путаюсь. Да, вот так. Число
независимости меньше, чем вершинная связанность. Вот. Тогда же... Да, в графеже на трех и более
вершинах. Это важно. А тогда же гамильтонов. Конечно, неверно, для двух или меньше там проще
вся ситуация. И не нужно никакие такие признаки. То есть, если число независимости меньше,
либо равно вершины связанности, то граф гамильтонов. Признак Эрдыша Хватова. Значит, смотрите.
Начало доказательств такое. Нужно выяснить, что же сначала они... Вот если оно удовлетворяет
условия, то точно не дерево. Но деревни гамильтонова. Это уже понятно, да? Там циклов нет.
Поэтому и цикл гамильтонова точно не будет. Вот. Давайте выясним, что вот если это условие у нас
есть, даже в связанном графе, конечно. Ну, как бы, да. Но тут определяется, вот эта капа определяется
только для связанного. То есть, как бы, если оно есть, то предполагается, что граф связан. Но
все-таки нужно отметить. Вот. Смотрите. Вот почему это же... Почему же, если удовлетворяет условия,
то не дерево? Как минимум двоечки, да. Как минимум двоечки. Почему? Капа равно, если же дерево.
Листы образуют независимое подмножество. Листы. А в дереве может быть три или больше листов.
Ну, тут же три более вершин. Да. В любом дереве есть хотя бы два листа. Поэтому число независимости,
листы образуют сами по себе независимое подмножество. Поэтому число независимости от дерева больше
либо ровно чем два. Правильно, Риман? Вот. А вершинная связанность дерева, хотя равна единице, почему?
Да, возьмем вершинку, которая листом не является. Что тогда? Тогда параграф распадется на компонент
связанности. Почему? Ну, в принципе, да, можно так, можно так, можно так. То
капа от g равно единичке, альфа от g больше либо равно чем 2. И условие не выполнено. И условие теоремы не выполнено.
Для g не выполнено. Ну, то есть, если условие у нас имеет место быть, то же заведомо не дерево.
Начнём с циклу. Рассмотрим самый длинный цикл уже.
Значит, ну вот, смотрите.
Какой-то обозначим вот c.
Пусть, вот этот самый цикл g, пусть, c есть, нет, не n, нет, вру-вру-вру, k, мы не знаем сколько тут вершин, c это a1, a2, ну, то есть, обходим этот цикл по вершинам, a1, a2, в каком-нибудь направлении, в любом.
Нам не важно в каком. Вот такой цикл, обойдём его.
Так, смотрите, пусть же не Гамильтонов, он даже можно не предполагать, а хотя нет, нужно предположить. Пусть, ну, шока, но это самый длинный цикл.
Если k равно n, то всё доказано.
Если k строго меньше, чем n, вот с этого предположения мы должны противоречиво вести. Пусть k строго меньше, чем n.
То есть, самый длинный цикл, который у нас есть в графе, меньше, чем n.
Ну, простой цикл имеется в виду, да?
Тогда, смотрите, при удалении вот этих ребер этого самого цикла, граф распадётся на какие-то компоненты связности, ну, кроме вот этих вершин цикла, так?
Ну, может распадаться, может не распадаться, просто вот обозначим ту компоненту связности, если распадётся, то возьмём какую-нибудь компоненту связности, не одна вершина, которая осталась после того, как мы удалили.
Если она одна, ну, её саму и возьмём, поняли, да?
Так, значит, после удаления, после удаления ребер с, рассмотрим любую компоненту связности, которая образовалась.
Рассмотрим любую образовавшуюся компоненту связности, образовавшуюся компоненту связности.
Дубль В, который вовне, Дубль В, состоящий из более чем одной вершины, вот так.
Больше одной, ну, не одна вершина.
Так, если такой не будет, графуни циклический тогда получается, правда?
Вернее, даже не ребер, а вершин цикла С.
Вершин.
Ну, давайте, хорошо, просто компонент связности Дубль В, на самом деле мы не будем пользоваться тем, что там больше, чем одна вершина, нам это на самом деле не так, чтобы нужно, вот.
Ну вот, хорошо, вот теперь давайте перерисуем.
И вот здесь у нас компонент связности Дубль В. Обозначим.
Н-Дубль В это у нас neighbors, от neighbors соседи Дубль В, то есть это те вершины, те вершины В из множества вершин графа В без компонента Дубль В.
Такие, что существует У из, существует У просто, такое, что УВ из, ну, ребром соединен.
А, существует У из Дубль В, конечно же, ну то есть соседи Дубль В вне Дубль В. Н-Дубль В обозначим это дело.
Понятно, ребята?
Соседи, соседи вот это его компоненты связности, которые, ну, это те вершины, с которыми Дубль В соединено вне себя.
Их, а?
Есть. А это же граф связный.
Понятно, что у нас это, ну, если бы не было ребер вовне Дубль В, то...
Так мы же удалили для этого вот это вот вершины.
Чтобы получить компонент связности, нужно удалить эти вершины.
Теперь мы рассмотрим весь граф сразу. А он связан. То есть, вовне Дубль В точно ребра идут. Вопрос, куда идут ребра вовне.
Первое утверждение. Лемма 1.
Н-Дубль В под множество С.
То есть, ребра идут в цикл.
Очевидно, почему?
Это же компоненты связанности, она в другие штуки идти точно не может.
Ну да. Доказательства.
Ну, пусть есть В, пусть есть вершины Дубль В из НВ, не принадлежащие от цикла.
Что тогда?
Тогда у нас вот такая картинка.
Ну, тогда вот эта Дубль В маленькая плюс Дубль В большая, они вместе тоже образуют компоненты связанности.
Но это не компоненты связанности, оно не максимально. Правильно?
Следовательно, Дубль В большой объединить с Дубль В маленькая тоже связано.
И Дубль В не компоненты связанности.
Так как она не максимальная.
Ну, собственно, все.
Отсюда соседи Дубль В из Вне могут быть только внутри цикла.
То есть, из Дубль В идут ребра только вот куда-нибудь сюда.
И поэтому при удалении вот этого всего вершины цикла Дубль В получается одной отдельной компонентой связанности.
Понимаете, да?
Так, хорошо.
Что теперь следующего утверждения, утверждение ЛЕМА-2?
Если для любого И от 1 до k-1
Если АИТ принадлежит НВВ, то есть, оно соединено ребром с этой компонентной связанностью,
то следующее за ней уже нет.
То следующее не соединено ребром с Дубль В.
Почему?
Ну, да.
Правда, нужно, наверное, для АКАТОВА написать.
Тогда, правда, непонятно, а И плюс 1 чему равно, имеется в виду А1 тогда.
Вот.
То есть, следующая подцикла.
Поняли, ребят?
Вот.
Доказательства.
Ну, если так, если есть две соседние подциклы вершины, которые соединены ребром с НВВ,
то мы можем удлинить этот самый цикл, а мы предположили, что он самый длинный.
Смотрите как.
Мы удлиняем этот цикл.
Вот так, вот так.
Вот здесь некая перемычка между ними должна быть,
потому что Дубль В компонента связанности.
Потом вот так.
И возвращаемся.
Цикл длинее стал.
Там добавилось хотя-то к АМИМУ два ребра в цикле.
Добавилось.
Противоречие.
Если АИТ и АИ плюс 1 принадлежат Дубль В,
то можем удлинить цикл С.
Можем найти цикл длинее С.
Так.
Как это, значит, описать?
А1 до АИТ.
Дальше.
В... не знаю.
ЦИТ, ЦИ плюс 1.
ЦИ плюс 1.
Обратно ВАИТ плюс 1.
И ВАИ 1.
Противоречие.
Противоречие.
Пока понятно?
Да.
Ну, то есть, у нас вышло что?
Что вершинки соседей Дубль В,
они через раз идут.
Как минимум через раз.
Ну, как максимум через раз.
В цикле.
ЦИТ – это вот эта вершинка, с которой АИТ соединено.
Блин, звонок.
Почти закончили, честно, ребят.
Тут еще одна лемма осталась, и, в принципе, все.
Но в этой лемме я могу запутаться,
потому что там цикл довольно заковыристый строится.
Что делать?
Я не думал, что мы так далеко в этом доказательности,
честно говоря, продвинемся.
Я думал, мы вот примерно до этого места дойдем и закончим уже.
А там уже можно потом лемму будет рассказывать.
Ну, это все.
