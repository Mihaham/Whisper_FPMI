Так переходим к еще одной структуре. Судерева я оставил только на семинар,
потому что они с автоматом очень похожи. Давайте попробуем в этот раз только с автоматом работать.
Так, поднимите, пожалуйста, руки у кого сейчас есть курс формальных языков.
Хорошо, спасибо. Ну, как я понимаю, он теперь не обязательный, поэтому я все равно должен
буду вести всякие определения, но постараюсь по минимуму и больше на картинках.
Значит, что такое вообще автомат? Мы будем говорить про детерминированный конечный автомат.
По факту это просто граф с ребрами, со стрелочками, и на стрелочках написаны какие-то буквы.
Что-нибудь вот такое, например. На каждом ребре будет написана какая-то буква,
и какие-то вершины будут помешаны терминальными. Я буду вот такой вот
штриховкой обозначать терминальные вершины. Формально, автомат – это граф ориентированный,
где на ребрах написаны буквы. Причем, чтобы он был детерминированный, не может быть такого,
что из вершины ведет два ребра с одинаковой меткой. То есть не бывает, так же, как у нас было в
боре. Например, не бывает такого, что из вершины выходят два ребра с одинаковой меткой. Такое нам
запрещено. Детерминированный в том плане, что если мы стоим в вершине, мне нужно прочитать букву,
то я знаю, куда идти. Например, если приходит А, то я иду сюда, если приходит Б, то я иду сюда. А если
приходит С, то мне идти некуда. Я сразу завершаюсь и говорю «все, вы меня просите прочитать слово,
которого в автомате нет». Я сразу завершаюсь и говорю «дальше не иду». Если вот здесь меня просит
прочитать С, я дальше не иду. Ну и, соответственно, пути ведущие из стартовой вершины. Вот есть
какая-то стартовая вершина, тоже отдельно выделенная в автомате. Значит, пути ведущие из
стартовой вершины в какую-либо терминальную соответствуют принимаемым словам. Например,
можно прочитать АС попасть сюда, можно прочитать ББ попасть сюда, можно прочитать БА попасть сюда.
Все эти слова, которые я могу прочитать на пути от старта до терминальной вершины,
это принимаемые слова. На этом конкретном примере это будет АС, ББ и БА. Тот автомат,
который мы будем строить, если цикл достижим из старта и из него достижим из терминальной,
то да. Я еще нарисую картинку, но автомат, который мы будем строить в этот раз, он будет
ациклический, поэтому на циклами не надо будет думать даже, что происходит с циклами. Но если
они какие-то есть, в принципе, определение пока не противоречит. А может быть, например, что-то
вот такое. Представьте себе. Вот, ну, какой-нибудь х. Да, например, вот это вот терминальное. Ну,
еще что-нибудь, давайте вот это терминальное. Тогда, например, до этой вершинки можно дойти так.
На вот этот вот старт можно, например, просчитать А, Б, Ц, Х. Можно просчитать А, Б, Ц, А. А можно
прокрутиться по всему этому циклу и опять пройти по Ху. То есть, что тогда будет? Будет А, Б, Ц, А, Б,
Б, Ц, Х. Вот все это принимаемые слова. Ну, их там, соответственно, будет даже бесконечно много,
потому что раз есть цикл, то мы можем по нему сколько угодно раз пропетлять, да, и потом дойти
до сюда, до терминальной. Вот, это все принимаемые. То есть, принимаемые слова — это в точной сети,
которые соответствуют какому-то пути от старта до терминальной вершины. Это все принимаемые
слова. Соответственно, отвергаемые — это все остальные. Отвергаемые слова. Все остальные. Это
те, либо которые я вообще даже не могу просчитать в автомате, как, например, здесь А, Б, А. Я могу
просчитать А, могу просчитать Б, но отсюда А я не вижу, я сразу здесь сломаюсь, говорю, все,
дальше читать не могу, я слово отвергаю. То есть, если я из вершины пытаюсь просчитать букву,
которой нет, по которой нет перехода, я говорю, что все слово отвергается. Ну, либо это слово,
дошедшее просто до нетерминальной вершины, например, А, Б, Ц. Давайте примеры, значит, А, Б, А, А,
Б, Ц. Они будут отвергаться. А, Б, А, потому что мы даже не можем его прочитать, А, Б, Ц просчитать
можем, но заканчиваемся в нетерминальной вершине, значит, слово не непринимаемое, то есть отвергаемое.
Окей? Концепция очень простая. Так, ну, вроде определил. Значит, да, повторяю, это неформальное
определение. Вот на картинке нам такого хватит. Дальше. Значит, я скажу следующее, что если А — это
автомат, то, ну, через L от А я буду обозначать множество всех принимаемых слов. Всех принимаемых
им слов. Будем мы решать обратную задачу, мы, наоборот, хотим по языку построить автомат,
потому что, ну, вот если автомат задан, то понятно, какие слова он принимает, какие не принимает.
Будем решать обратную задачу, мы будем строить по языку какой-то автомат такой, что его язык
совпадает в точности с L. Вот. Язык, уточню для тех, кому это непривычно, язык — это просто множество слов.
А язык — это просто множество слов. Множество всех слов, которые наш автомат должен принимать. Так,
хорошо. Значит, определение. Пустель — произвольный язык. Тогда через, ну, просто давайте, значит, такое
обозначение RL от X — это все такие Y, что X конкретонация Y принадлежит L. И это я буду называть правым
контекстом X относительно L. Правый контекст X относительно L. То есть, вот есть какое-то слово X,
тогда в его правом контексте лежат все его дополнения до какого-то слова из L.
Да, да, да. Тогда что будет? Ой. А, я понял, я понял вас, да. Да, это правда. У нас, конечно, все конечное,
мы же алгоритмисты, у нас вообще все всегда конечное. Вот. Значит, это все возможные способы,
как можно слово дополнить, чем можно слово дополнить справа, чтобы это слово лежало в языке L. Называется
правый контекст. Значит, пример. Когда вы у себя в среде разработки что-нибудь там печатаете,
какую-нибудь функцию, пытаетесь вызвать, например, встроенную или ту, которую вы уже напечатали,
вы обычно несколько первых букв печатаете, и потом вам вылазит такое окошко, где написано,
как можно продолжить, да, как бы, ну, чем можно завершить до того, что уже есть. Вот представьте,
что L — это, как бы, пространство всех имен, которые есть в программе, и именно, что среда
разработки вам подсказывает, как можно дополнить до слова из языка. Вот, вот ровно оно. Да, это все
доступные команды. Вы уже что-то ввели, вопрос, как можно дозакончиться до какого-то слова из языка.
Вот. Значит, это называется правый контекст, да, как бы, как можно справа дополнить до элемента из L.
Значит, дальше пустель язык. Значит, тогда вводим отношение эквивалентности, говорим, что x L
эквивалентно y, ну, либо тильдочка с нижними nxml, либо я скоро буду просто писать без L,
а вот так буду просто писать. Ну, пока давайте так обозначим. Значит, если у них одинаковые правые
контексты. Два слова эквивалентны, если они одинаковы с точки зрения дополнений справа. Понятно,
что это отношение эквивалентности, потому что оно порождено отношением эквивалентности, да,
ну, по факту он просто задается равенством. Это очевидно отношение эквивалентности. Вот.
Значит, ну, есть такая теорема Махилла Нероуда. Ну, давайте я ее в урезанной версии напишу. Значит,
я скажу так, что минимальный автомат, принимающий L, принимающий L, имеет ровно столько состояний,
столько вершин, ровно столько вершин, сколько классов эквивалентности относительно вот этого l,
вот классов эквивалентности по этому отношению. Значит, сколько есть классов эквивалентности
по введенному только что отношению тильда.
Так, это знакомо?
Тем, у кого были... Ага, вы и до этого еще не дошли.
А что же там делать, интересно, ну ладно.
Скоро будет у вас такая телем, значит.
У кого есть формалки.
То есть, вот это отношение,
оно в каком-то смысле задает в точности вершины автомата.
Минимальные, здесь я имею в виду, минимальные поочисла вершин.
Поочисла вершин.
Вот. То есть, на самом деле,
минимальность числа вершин достигается ровно в том случае,
когда у вас состояниями автомата, вот этими вот вершинами,
выступают в точности класса эквалентности по вот этой вот тильде.
Вот, это теорема Махилни Роуд.
Доказывается, на самом деле, очень просто.
Но мы не будем ее доказывать.
Нам это не надо.
Но мы из нее понимаем следующее.
Следствие, что если мы хотим строить какой-то минимальный автомат для какого-то языка,
то нам вот, как я уже сказал, нужно в качестве вершин
рассматривать классы эквалентности по отношению тильда.
В качестве вершин
в минимальном автомате
выступают
классы эквалентности.
Вступают классы эквалентности. То есть, вершина,
это будет на самом деле классы эквалентности.
Ну, соответствовать будет классы эквалентности, да.
Конечно, конечно, да. То есть, у нас есть язык.
Мы хотим в точности по нему построить автомат, который принимает слова из L и только их.
Все остальные отвергают.
Так. Ну, давайте в простую сторону это докажем.
Почему это верно?
Ну, типа доказательства не знаю.
Да, вот давайте, например, посмотрим на два слова, которые эквалентны друг другу.
Пусть X эквалентна Y.
Есть ли им какой-то смысл быть в разных вершинах?
То есть, может ли быть такое, что из старта при прочтении X я попадаю в одну вершину,
а при прочтении Y попадаю в другую вершину?
Есть ли какой-то смысл им быть различными?
Вот я утверждаю, что нет, потому что, раз они эквивалентны с точки зрения вот этой тильды,
значит, все их продолжения до слова из L,
то есть, все возможные их пути до терминальной вершины одинаковые.
То есть, если отсюда есть какой-то путь до терминала, значит,
и здесь есть точно такой же длины, из таких же символов состоящих,
потому что у них одинаковые правые контексты.
То есть, их поведение вперед, при продолжении, оно одинаковое.
Поэтому я могу просто смело склеить эти две вершины.
Ну и вот эти все возможные ветвления склеить тоже в...
Ну просто склеить и сделать, чтобы не было повторений.
То есть, я могу вершины склеить, если они эквивалентны. Понятно?
Потому что как раз продолжения, вот эти все возможные пути,
дополняющие до слова из L, то есть до терминальной вершины,
они у них одинаковые, поэтому можно вершины склеить всегда.
Потому что с точки зрения остатка графа, с точки зрения достижимости, они будут эквивалентны.
Значит, их можно склеить.
Вот.
Но это мы доказали, видимо, что...
Что?
Что вершин не больше, чем классы эквивалентности, правильно?
Потому что эквивалентные слова можно склеить,
значит, вершин не больше, чем классы эквивалентности.
Ну и легко показать, что если слова не эквивалентны,
то они не могут быть в одной вершине.
Не может быть такого, что у вас х, давайте там, у, не эквивалентно у.
Тогда не может быть такое, что вы, прочитав...
Продон.
У не эквивалентно в.
Не может быть такое, что, прочитав из старта у и в, вы пришли в одну вершину.
Потому что раз они не эквивалентны,
ну значит, они должны как-то различаться.
Значит, из у должен быть какой-то путь до терминала,
которого нет в.
Но раз вы их склеили, вы не можете их уже отличить друг от друга.
Они для вас одинаковые.
С точки зрения правого контекста,
с точки зрения продолжения до терминалов, они одинаковые.
Поэтому не могут различаться.
Ну значит, вроде мы доказали, что
одинаковые слова, то есть, эквивалентные слова,
можно склеить вершинки, а разные склеить нельзя.
Ну, поэтому, как бы, число класса эквивалентности в точности число вершин.
Да.
Да, есть каких слов?
Есть слов, ну...
Ну, есть слов языка только, но в плане...
Нет, вообще...
Сейчас.
Ну, вообще говоря, вот в этой общей теории вообще, вообще,
из всех слов сигма звездочки.
То есть, есть какой-то объемлющий алфавит.
Сигма.
Да, мы рассматриваем, как бы, ну вот, х и у,
и у, это все были элементы сигма звездочки.
Да.
Да, какое-то слово просто.
Какой-то набор символов.
Это в общем случае, да.
Ну, для префиксов слов из языка вы имеете ввиду.
Это хорошее замечание, мы сейчас ровно к этому перейдем.
Скажу так, что в общей теории,
это, ну как бы,
не уточняется.
То есть, мы для всех вообще слов рассматриваем.
Да.
Возможно, скажем, если х не является префиксом никакого слова,
возможно, у него пустой правый контекст.
Да, р или от х равно пустого множества.
Такие слова тоже есть.
Как бы, в общем случае, да.
И именно эта теорема, она работает именно в случае,
когда у вас есть такой кла...
Ну, как бы, разрешены такие классы.
Поэтому, в общем случае, х и у могут быть даже не префиксом никакого слова.
У них могут быть пустые правые контексты.
Но вот мы сейчас перейдем к рассмотрению
только хороших слов, которые продолжаются хоть как-то.
Это пока было в общем случае.
Так.
Не-не-не.
Вот она как раз работает, если вообще все рассматривать.
А мы один класс уберем, у нас станет меньше.
Ну, потому что вот здесь, вот в этой теореме,
на самом деле подразумевается, что у вас автомат полный.
Ну, я не хочу это проговаривать, чтобы никого не путать,
если кто-то не поймет просто.
А?
Да.
Да.
Давайте скепнем, пожалуйста.
Вот.
Значит, смотрите, с этого момента, давайте,
раз мы вот про это как раз вы почувствовали,
что здесь что-то не так, давайте я сразу скажу,
что пусть L у нас будет множество всех суффиксов
какой-то фиксированной строки.
Множество всех суффиксов строки S.
И я буду хотеть строить автомат,
принимающий в точности только суффиксы S.
Вот есть какая-то строка, я по ней построил L,
как множество всех суффиксов.
И хочу строить автомат, распознающий только суффикс L.
Вот.
И здесь я сразу говорю, давайте отныне
не будем рассматривать
строки,
не являющиеся под строками S.
Потому что, если X это не под строка S,
то ее невозможно добить до суффикса S справа,
нельзя к ней ничего приписать, чтобы получить суффикс,
и значит, у нее пустой правый контекст.
Если X это не под строка S,
на самом деле это верно, если и только если у нее пустой правый контекст.
То есть ее никак нельзя добить до суффикса,
ровно в том случае, когда она не под строка.
Вот.
Поэтому давайте мы такие строки выкинем.
Это вот как раз те случаи, когда я пытаюсь читать что-то в автомате,
и в какой-то момент пытаюсь читать несуществующий символ.
Вот как было на картинке, я прочитал, прочитал,
потом из вершины пытаюсь читать что-то, чего нет.
Это как раз соответствует тому, что мы не под строка.
То есть я пытаюсь прочитать символ,
ну, такой, что вот такой по строке нет просто у меня в строке.
S.
Вообще говоря, вот как раз в этой общей теореме
для таких товарищей нужна была бы отдельная вершинка,
куда бы я переходил, как только понимал, что
что у меня плохое слово, мне нужно перейти в слово с пустым классом эквалентности.
Но, поскольку я их дропаю, то есть я избавляюсь от этого класса и у меня станет на одну вершинку поменьше.
Да.
А у нас, если строчка не дает пустой, то у меня там контекст, пустой или пустой?
Как минимум пустое слово там есть?
Да.
Да, давайте пример.
Если я напишу строчку abc ab, чему равен правый контекст строки ab?
Во-первых, епсилон, во-вторых, cab.
То есть, раз она суфикс, то епсилон всегда подходит.
Да, можно приписать пустое слово, то есть ничего не приписываешь, чтобы получить суфикс.
Либо можно написать вот это.
Ну, в случае, если эта строка еще где-то входит, мы получаем еще какое-то другое дополнение до конца.
Вот.
Ну, а, например, если бы мы взяли что-нибудь типа, там, не знаю, cb, мы бы взяли пустое множество.
Вот.
И такие слова мы не хотим рассматривать, но это в точности не под строка.
Мы такие не рассматриваем.
Не рассматриваем, так как это не под строка.
Вот.
Значит, тогда как будет выглядеть наш автомат?
Как выглядит это, собственно, и будет суфиксный автомат, да?
Суфиксный автомат строки s.
То есть, минимальный автомат, принимающий в точности все ее суффиксы.
Принимающий в точности суффиксы s.
Принимающий в точности суффиксы s.
Да, в точности.
Да, суффиксы и только их.
Вот.
Ну, с вершинами мы уже разобрались.
Мы поняли, что в минимальном автомате вершины это в точности класса эквивалентности.
Поэтому вершины соответствуют однозначно классам эквивалентности.
Значит, если я научусь находить классы эквивалентности,
я, по крайней мере, знаю, сколько вершин в моем автомате.
Теперь, что происходит с ребрами?
Нас с переходами.
Так.
Ну, надо разбираться.
Давайте я пока оставлю это под вопросом.
Пока мне нужно какие-то свойства автомата вообще понять,
как устроен класс эквивалентности и так далее.
Давайте пока это оставим.
Потом к этому вернемся.
Так, пара простых утверждений.
Не буду нумеровать.
Значит, утверждения.
Пусть для двух строк у и в их правые контексты внезапно совпали.
Тогда скажите, пожалуйста, что можно сказать про соотношение у и в.
Ну, я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Что можно сказать про соотношение у и в?
Ну, эквивалентность понятна.
Это не утверждение.
Это определение тогда.
Что можно еще про них сказать с точки зрения?
Ну, вот все.
Теперь L это набор суффиксов.
Строки S.
Что можно сказать, как они соотносятся?
А более точно?
Одно под строка другого.
А более точно?
Суффикс другого.
Тогда либо у это суффикс v, либо v это суффиксу.
Доказательство.
Очень простое.
Поскольку мы рассматриваем только под слова S, только
под строки S, я сказал, вот отныне я не рассматриваю
ни под строки.
Я рассматриваю только какие-то под строки.
Причем я знаю, что у и в это под строки S, у них одинаковые
правые контексты.
Полезно понимать, полезно думать о правом контексте
в терминах вхождений.
Потому что, по факту, что такое элементы правого
контекста?
Вот r от u это что такое?
Это все такие дополнения до суффикса.
В этом плане r задает в точности множество вхождений,
позиции всех вхождений вот этого слова.
Потому что, что такое дополнение до суффикса?
Значит, вот где-то есть u, и если я вот это вот допишу
до конца, то у меня получил суффикс.
Дальше, если есть какой-то другой элемент правого контекста,
то вот у меня было u, я еще что-то дописал, получил
суффикс.
То есть r в точности описывает на самом деле множество вхождений.
Окей, причем они равны.
Что это значит?
Значит, есть какое-то слово, вот есть какой-то конкретный
элемент, давай скажем, w, лежащий одновременно в r от
u и в r от v.
Что это такое?
Значит, вот есть какой-то суффикс w, такой, что перед
ним в нашей строке встречается u.
Да, ну это в точности определение того, что w лежит в правом
контексте u.
Значит, у меня вот такая картинка, что s выглядит так,
она заканчивается на uw.
С другой стороны, то же самое w лежит в r от v.
Значит, вот опять же, здесь же заканчивается очередное
вхождение v.
Поэтому v либо какое-то вот такое, либо какое-то вот такое.
Поэтому очевидно одно суффикс другого.
Согласны?
Хорошо.
Суждение следующее.
Пусть c какой-то классик эволюционности.
Тогда существует такое u, такая строка u, что c это в точности
u и несколько ее самых длинных суффиксов.
То есть, если я рассматриваю классик эволюционности и
изучаю все слова, которые в нем лежат.
Вот, например, классик эволюционности – это слова, у которых
одинаковый правый контекст.
Я рассматриваю слова с каким-то фиксированным правым
контекстом, они образуют некие классики эволюционности.
Так вот, я утверждаю, что его структура такая.
Есть какая-то самая длинная в этом классе строка u,
а потом несколько ее суффиксов в порядке убывания
времени на один.
То есть, второй по максимальности, дальше третий по максимальности,
четвертый, ну и так далее, вплоть до какого-то.
И на этом класс заканчивается.
Вот это вот c.
То есть, что есть такая самая длинная в этом классе строка,
что все остальные получаются отбрасыванием от нее
самого левого символа.
Ну, вплоть до какого-то момента.
Я тоже, что любой c выглядит ровно так.
Ну, почему это так?
Во-первых, легко заметить, что в одном классе не может
быть двух строк равной длины.
Ну, значит, не может быть двух строк равной длины.
Ну, потому что мы доказали, что если у двух строк
одинаковый класс эквивалентности, да, вот предыдущее утверждение,
если у двух строк одинаковый класс, то одно суффикс другого.
Ну, значит, они не могут иметь одинаковую длину.
Один точно короче, чем другой.
Значит, длины всех строк различны.
Хорошо, давай тогда определим у как самую длинную.
Значит, пусть у самая длинная строка в c.
Ну, а давайте скажем, что v самая короткая.
Во-первых, очевидно, что v и все остальные строки, лежащие в этом классе,
они конечно суффиксы u.
По предыдущему утверждению, что если две строки эквивалентны,
то одна суффикс другого.
Раз это самая длинная, то все суффиксы u.
То есть все строки, лежащие в c, точно суффиксы u.
Ну, значит, у всех у всех строк, лежащих в u,
все у всех строк, лежащих в c, точно суффиксы u.
в С, точные суффиксы У. Вот. Ну, значит, вот это В тоже в частности, конечно. И теперь единственное,
что мне осталось доказать, это что именно вот здесь вот все суффиксы непрерывно идут. То есть,
если есть В, самое короткое, то между ними получается все суффиксы длины от У до В. То есть,
именно вот, ну, не бывает такого, что есть какие-то пропуски. Скажем, не знаю, здесь длина 10, 9, 8, 7, 6, 5,
не может быть такого, что какая-то из них пропущена. Не может не быть какого-то суффикс.
Надо достаточно показать, что все суффиксы, ну, что все суффиксы длины хотя бы такой,
лежат в этом же классе. Все суффиксы У длины хотя бы такой, как УВ, лежат в С.
Тем самым мы утверждение полностью докажем. Ну, это несложно. Пусть ВВ какой-то вот этот
промежуточный суффикс. Ну, не так, да? То есть, пусть ВВ это какая-то строка, какой-то суффикс У,
длины хотя бы В. Давайте докажем, что он в этом классе лежит. Пусть ВВ это суффикс У, причем его
длина хотя бы такая, как УВ. Давайте докажем, что он лежит в этом классе. Вот, то есть, картинка такая,
есть какая-то длинная У, есть более короткий его суффикс ВВ и есть самый короткий суффикс В.
Тогда давайте заметим следующее. Давайте заметим, что РЛ от В содержит в себе РЛ от В и содержит в себе
РАТУ. Почему? Ну, потому что, повторю, правый контекст в каком-то смысле задает множество всех
вхождений строки. Понятное дело, что у В вхождений только больше, чем у В и еще больше, чем у У. Да, ну,
или там более формально. Почему правый контекст В содержит целиком правый контекст ВВ? Потому что,
если внезапно где-то в моей длинной строке С я увидел В в правом контексте, в котором лежит
какой-то Х, то, очевидно, вот здесь же я получил В и Х. То есть, если Х лежала в правом контексте В,
то оно же лежит в правом контексте В. Ну, очевидно, да? То есть, если я укорачиваю строчку,
ну, перехожу к суффиксу строки, то правый контекст может только вырасти, потому что все,
что было раньше, оно остается в правом контексте. Значит, верна такая цепочка вложений, но поскольку
мы знаем, что R от В равно R от У, а они же в одном классе, значит, у них одинаковые контексты,
значит, здесь они тоже все одинаковые, значит, В тоже в классе. Согласны? Чудно. Так, ну тогда я
могу записать, что такое рёбра в нашем автомате. Значит, рёбра у меня выглядит следующим образом.
Ну, давайте я буду писать, откуда, куда и какая метка на этом ребре. Значит, рёбра – это все такие
тройки С1, С2, Д, где С1, С2 – это классы, а Д – это символ. Значит, давайте напишу, что это классы. Это
какой-то символ алфавита. Если существует у из С1 такое, что у Д лежит в С2. Вот. Очень естественное
определение, потому что, смотрите, что такое ребро из… Вот как бы у меня есть один класс,
одна вершинка. И с другой класс, вторая вершинка. Я провожу ребро Д между ними. Если вот здесь
есть какое-то слово у, продолжающиеся буквой Д вот сюда. Ну, весьма естественно, да? Потому что
что такое у из С1? Это значит, что я мог из стартовой вершинки, прочитав у, попасть в С1. А вот,
прочитывая у, я попадаю в С1. И мне что нужно? Я хочу теперь у2 прочитать с помощью С2. То есть,
прочитав у2, попасть в С2. Но я просто провожу такое ребро, попадаю в точность в С2. Вот. Значит,
почему это верно? На самом деле, здесь нужно просто понять следующее, что если я провожу такое
ребро из С1 в С2, то оно верно не только для вот этого у, да? Не только это у я могу продолжить
буквой Д. Но и все другие пути, приходящие в С1, также можно было бы продлить буквой Д. Потому
что, ну то есть, я здесь беру только для некоторого у. Надо доказать, что как бы я сюда не пришел,
я могу приписать буквой Д, и окажусь в том же классе. Да. Из всех строк, да. Не, еще раз,
С1, С2 это классы. Классы это вершины. Да, да, да. Вот, вот же, вот же. Вершины это класс
эквивалентности. Вот. Соответственно, это класс. Ну, вершины, отвечающие там нескольким, вот. На
самом деле, вот таким вот строчкам. Да, мы знаем, как устроен класс. Это вот это вот. Тут несколько
слов. Что это значит? Значит, что из старта до сюда есть много путей, которые на самом деле задают
с точностью вот эти вот строки. Какая-то самая длинная и несколько ее самых, несколько ее самых
длинных суффиксов. И вот я утверждаю, что если к одной из них можно написать Д, то и к ним ко всем
тоже можно написать Д. Вот. Ну, это вроде просто. Значит, смотрите, что значит, что существует у С1 такое,
что у Д лежит в С2. Я хочу написать следующее, что если вот это вот верно, то пусть В это произвольная
строка С1, я хочу показать, что ВД тоже лежит в С2. Ну, то есть, если верно для какой-то строки С1,
то это верно для всех, что приписывание буквы оставляет, ну, переводит меня в класс С2. То есть,
я мог бы здесь написать квантер для любого месту существования. Так.
Давайте докажем, что у них одинаковые правые контексты. Давайте докажем, что вот этих двух строк
одинаковые правые контексты. Значит, они лежат в одном классе. Давайте рассмотрим какой-то конкретный
х из Р от УД. Значит, докажем, что этот же х лежит в Р от ВД. А если мы докажем, то мы по факту,
ну, как бы, докажем одно вложение, второе будет аналогично. Картинка. Была длинная строка С. Здесь
где-то было УДХ. Но при этом мы с вами знаем, что У и В лежат в одном классе С. С1. Значит,
в частности, вот здесь же заканчивается какое-то вхождение В. Ну, то есть, я знаю, что, то есть,
как можно вот это написать? Можно было бы это переписать так, что ДХ лежит в Р от У. То есть,
У можно продолжить до суффикса строкой ДХ. Ну, и поскольку они в одном классе лежат,
значит, это же самое ДХ лежит в правом контексте строки В. Вот. Но это формально. На картинке
можно нарисовать так, что если вот здесь У заканчивается, заканчивает какое-то свое вхождение,
то значит, здесь же заканчивает какое-то свое вхождение В. Будь оно более короткое или
более длинное, это неважно. Значит, ВД можно дополнить Х. Что хотели, получили. Вот. Мы тем самым
доказали, что правый контекст УД вложен в правом контекст ВД. Ну и обратно верно, потому что мы
никого в предположении на У и В не накладывали. То есть, получается, что вот такое определение
ребер, которые я ввожу, то есть, как они выглядят в автомате, оно действительно соответствует тому
пониманию, что как бы я не дошел от старта до С1, я при помощи буквы Д попадаю в класс С2. Вот мы
доказали, что как бы я не попал в С1, приписывание Д приводит меня в один тот же класс С2. Вот. Вопрос
есть? Да. Вот это? Так. Про утверждение классикой валентности. Да. Не, смотрите, то У и это У, могут
быть разные У. То утверждение было следующее, что если есть какой-то классикой валентности,
то существует такое У, что ведь классикой валентности это У и несколько самых длинных
суффиксов. Вы про это? Несколько это один У или даже новый У. Только сама У может быть? Может быть,
да. Но возможно какие-то еще. Несколько, значит, ну как бы она и возможно кто-то еще. Да. Но главное,
что там непрерывный отрезок идет. Непрерывный отрезок длинный. Хорошо. Значит, ну все, мы на самом
деле тогда поняли, как, если что, выглядит наш автомат. То есть, мы знаем, как устроены вершинки,
как устроены ребра. Да, и вот если там, если нам все это известно, мы можем его построить.
Ну давайте пример попробуем. Давайте попробуем построить автомат для строки вот этой вот,
которую я уже рисовал. А, Б, Ц, А, Б. Пусть это будет С. Ой, будет непросто. Ну давайте попробуем.
Значит, смотрите, давайте напишем. Я буду рисовать множество строк и правый контекст это для каждой
из этих строк. Давайте начнем с суффикса Б. Давайте начнем с пустой строки, точнее. Пустая строка,
понятно, будет соответствовать корню нашего автомата, да, стартовой вершинки. И ее правый
контекст это все суффиксы. То есть, это пустой суффикс Б, А, Б, Ц, А, Б. Ну и так далее. Короче,
все суффиксы. И понятно, что она такая одна, нет никакой другой строки, у которой правый контекст
содержал бы вообще все суффиксы строки С. Едем дальше. Вот давайте рассмотрим суффикс Б. Какой у
него правый контекст? Во-первых, вот одно вхождение Б, значит, можно с помощью эпсилона добить до суффикса.
Либо вот оно, Б, можно с помощью Ц, А, Б добить до суффикса. Здесь же можно заметить, что, например,
у строки А, Б ровно такой же правый контекст. Вот оно, А, Б, ее можно дополнить эпсилоном до суффикса.
Либо вот оно, А, Б, можно дополнить Ц, А, Б до суффикса. Поскольку у них одинаковые правые контексты,
значит, они лежат в одном классе. И кажется, больше таких строк нет. Значит, следующая строка будет Ц,
А, Б. У нее правый контекст просто эпсилон. Вот единственное вхождение Ц, А, Б в строчку добить до суффикса
можно, только ничего не приписав. То же самое происходит вот с этими всеми более длинными строчками,
Б, Ц, А, Б и А, Б, Ц, А, Б. У них у всех одинаковый правый контекст, значит, все они в одном классе
эквивалентности. Согласны? Так, еду дальше. Какие у меня еще остались подстрочки? Ну, давайте А посмотрим.
Какой у нее правый контекст? Б и Б, Ц, А, Б. Видимо, она здесь сама по себе. Других строк с таким классом я не вижу,
с таким правым контекстом, точнее, я не вижу. Дальше рассмотрим Ц, А. У Ц, А правый контекст только Б,
потому что единственное вхождение Ц, А, вот оно добить до суффикса можно только прочитав Б. И то же самое
будет у всех этих более длинных строк заканчиваться в этой Ашке, то есть Б, Ц, А и А, Б, Ц, А. Как видим,
все они заканчиваются только вот здесь, вот в этой позиции Б, Ц, А, А, Б, Ц, А, Ц. Вот они все только здесь
заканчиваются. Их правый контекст состоит только из Б. Правый контекст у них одинаковый, они все
дойдут в одном множестве, в одном классе эквивалентности. Так, хорошо, мы разобрали все суффиксы, все заканчиваются
вот здесь. Теперь есть строка Ц, и видимо все более длинные заканчиваются здесь. Ц, Б, Ц и А, Б, Ц. У них у всех правый
контекст это только строка А, Б. На ко всем строчкам можно написать только А, Б, чтобы получить суффикс.
Больше ничего нельзя. Так, Б, А, Б у меня уже написано, А написано. Все, кажется, все перебрал. Проверяйте.
Вот, значит это множество вершин моего автомата. Теперь, ну я провожу ребра вот по тому правилу.
Вот у меня есть Эпсилон, например, сюда будет ребро по букве Б. Да, потому что я могу взять Эпсилон,
написать Б и получить вот это вот Б. Дальше отсюда я могу куда перейти, например. Ну или давайте вот
отсюда, я еще могу перейти вот сюда написав А. Я беру Эпсилон, приписываю А, получаю вот это слово А.
И могу отсюда перейти вот сюда, приписав букву С. Я беру Эпсилон, дописываю С, получаю вот это вот С.
Хорошо, теперь ребра отсюда. Можно написать ребро отсюда-сюда по букве Б. У меня было А,
я дописываю Б, получаю А-Б. Можно ли еще что-то дописать к А? Видимо нет, потому что после А
всегда идет Б, да, как как видим. Значит ничего другого после А дописать нельзя. Дальше, какие
ребра отсюда идут? Например, вот сюда есть ребро по букве С, потому что можно было взять Б,
дописать С, получить Б-С. Либо, как видим, взять А-Б, написать С, получить А-Б-С. То есть,
какую бы строчку я отсюда не взял, дописав С, я обязательно оказываюсь в этом классе. Опять же,
никакую другую букву нельзя дописать, потому что после Б всегда идет либо С, либо ничего.
Поэтому отсюда больше ребр нету. Так, ну давайте я дальше уже без комментариев что-нибудь доведу.
Отсюда после СА есть только Б, такое вот ребро. Отсюда никуда нельзя, потому что это все уже
суффиксы, да, правее некуда. Ну и из вот этого С можно только в СА попасть. Вот сюда вот есть
такое ребро по букве А. Конец. Вот. Значит, ну да, не очень красиво, но тем не менее вот как-то так
автомат строится, на самом деле. Хороший вопрос. Давайте отметим. Давайте, скажите мне вообще,
пожалуйста, какие вершины, какие классы должны быть терминальными? Да, те, которые содержат суффиксы.
Ну здесь это только вот это, вот это и вот это. Потому что у меня суффиксы какие есть? Эпсилон,
есть Б, есть АБ есть ЦАБ, есть Б ЦАБ, есть АБ ЦАБ. Все сейчас. Ровно они являются терминальными,
потому что терминальные то что? Значит мы дошли от старта до терминали мы должны прояснить только
суффикс. Потому что автомат принимать только суффиксы. Как раз вот ровно вершины содержащие
суффиксы только суффиксы. Это как раз будут терминальные терминальные вершины. Вот, хорошо.
все значит наша цель теперь как-то научиться строить такой автомат побыстрее потому что это
конечно мучительно ну когда ничего не прочитали еще можно все читать вот так значит теперь
давайте введем некоторые обозначения начну во первых через x в квадратных скобках относительно
строки s я обозначаю класс эквивалентности куда входит x класс эквивалентности x ну вроде как
обычно да есть у нас есть отношение эквивалентности мы по ним факторизуем то квадратные скобки это
класс эквивалентности элемента дальше если c это класс то longest от c это самая длинная строка
в этом классе мы помним что каждый класс устроен как это какая-то строка и ее суффиксы в порядке
убывание на 1 да убывают убывают длины на 1 вот пусть longest это та самая длинная из них обозначение
просто значит и также скажу лену ц это длина этого longest так и кажется последний линка ц мне
еще будет нужно это следующее смотрите вот давайте нарисую ц это какая-то самая длинная строка
то есть longest от ц затем ее суффикс без первого символа потом опять без второго символа без третьего
и так далее ну вплоть до какой-то строки вот они все лежат в классе ц вопрос а что будет если я
откушу от вот этой самой короткой строки в этом классе опять первый символ ну по предположению раз
это была самая короткая значит я попаду в какой-то другой класс ц-штрих так вот пусть это будет
линка ц это такой класс ц-штрих который содержит самый длинный суффикс longest не не лежащий в
классе ц который содержит самый длинный суффикс строки longest от ц не лежащий при этом в ц
ну определение более громоздко чем картинка вот у меня есть все строки лежащие в ц что будет
если откушу первый символ от самой короткой строки я попадаю в другой класс и это и будет
линк от ц а значит это будет суффиксная ссылка суффиксная ссылка класса ц
так утверждение критерий longest я утверждаю следующее что есть очень простой критерий проверки того
что строка является longest в своем классе значит 40 у давайте я напишу прямо так максимально
формально равна longest в своем классе если только если если только если верно хотя бы одно из
двух условий либо у это префикс с либо существует два таких разных символа а и б что а у и б у это
под строки с значит longest это в точности следующие строки префиксы или же строки
продлевающиеся налево разными буквами хотя бы двумя разными буквами еще раз строка является
longest в своем классе если только если верно одно из двух либо у это префикс с либо существует
две разные буквы из алфавита такие что ау и б у это обе под строки с то есть ушку можно продлить
влево двумя разными буквами то есть есть вхождение скажем ау есть вхождение б у нашу строку с
так доказательства давайте например слева направо тут на самом деле почти одинаковое
рассуждение то есть слева направо пусть у это longest в своем классе то есть вот есть некий класс в
ней у самая длинная строка остальные получаются все на длины там поменьше это вот класс эквивалентности
для с на самом деле надо было в обратную сторону ну ладно я хочу тогда сказать что у либо префикс
можно продолжить двумя разными способами налево пусть не так пусть для у неверно не то не то то что
есть у не префикс и не существует двух различных продолжений влево пусть у не префикс и не
существует и б таких что блаблабла вот что здесь написано пусть это неверно что это тогда значит
На самом деле это означает, что любое вхождение U
предваряется слева одной и той же буквой.
То есть, где бы я U в моей большой строке S не увидел,
слева от нее одна и та же C всегда.
Все вхождения U слева одинаково предваряются буквой C.
Ну, потому что, поскольку U не префиг,
значит, я могу всегда говорить про предваряющую букву,
то есть всегда есть буква слева.
И раз нет двух раз листьев, значит, они все одинаковые.
То есть, все вхождения U предваряются слева одинаковой буквой C.
Но, извините, тогда U не могла бы быть лонгистом в своем классе,
потому что U строк U и C U одинаково множество вхождений.
А раз я сказал, что любое вхождение U предваряется C,
значит, у U и C U одинаково множество вхождений.
Значит, у них одинаковые правые контексты,
значит, они должны быть в одном классе.
Противоречие.
Что? Да, конечно.
Так, значит, любое...
Значит, да, значит,
любое вхождение U в S предваряется одинаковой буквой C.
Значит,
значит, у них одинаковые правые контексты.
U и C U.
Ну, как бы, множество вхождений у них одинаковое,
множество окончаний вхождений у них одинаковое,
да, везде, где есть U, есть и C U.
Значит, они просто заканчиваются в одном и том же множестве индексов.
Поэтому у них одинаковые правые контексты,
значит, U не может быть лонгистом в своем классе.
U
не лонгист в своем классе. Противоречие.
Да?
Так, обратно.
Почему, если верно, вот это вот,
то U обязательно лонгист.
Ну, пусть не лонгист.
Что это значит?
Значит, что если я рассмотрю ее класс,
то U
лежит в том же классе, что и какая-то более длинная строка
с суффиксом которой она является.
У
лежит в том же классе, что и какая-то более длинная строка
с суффиксом которой она является.
Давайте, ну, то есть, как бы вот,
картинка будет такая,
ну, и какая-то,
и вот здесь, на каком-то шаге U, то есть,
U не самая длинная в своем классе.
Тогда, смотрите, вот, если я в качестве C
рассмотрю вот эту букву,
ну, вот, в точности тот символ, который получается
перед отбрасыванием, да, перед получением U,
тогда U U и C U одинаково множество вхождений,
то есть, они в одном классе лежат.
Лежит в одном классе C.
Значит, U не префикс,
потому что всегда левее от U можно написать C.
И не существует двух различных продолжений U влево,
потому что U входит только там, где входит C U.
Противоречие.
Значит, пусть U это не лонгест,
тогда
U и C U
лежат в одном классе C.
Да, ну, вот еще раз, U это вот,
вот она сама U.
C это тот символ, который находится, ну,
перед, перед ней, в строке на один повыше,
самый левый символ, который я отбрасываю,
чтобы получить U.
Вот.
Тогда они в одном классе,
значит, любое вхождение U, опять-таки,
предваряется символом C.
Значит, любое вхождение U
предваряется символом C.
Значит, не может быть такого, что U префикс
и не может быть такого, что U
предваряется слева двумя разными символами.
Ну, потому что любое вхождение U,
где бы оно ни располагалось,
слева автоматически влечет C.
Значит, U не префикс, потому что слева
должно быть что-то.
И нет двух разных продолжений влево.
Нет A и B, есть только C.
Конец.
Да.
Вы доказали, что в том классе
есть не только строка,
а и все остальные.
Для любого класса,
какой бы я цени рассмотрел,
это строка, ну, как бы,
самая длинная строка в классе
и несколько ее самых длинных суффиксов.
Какой бы класс я не рассмотрел.
Это для любого класса верно.
Так.
Вопросы какие-то?
Хорошо.
Значит, смотрите,
как это было нужно.
Давайте я скажу следующее.
Давайте мы начнем,
попробуем строить алгоритм.
Как строить суффиксный автомат
по строке S.
Ну, такая попытка делать алгоритм.
Во-первых,
я его буду, наш автомат,
строить инкрементально.
То есть я иду по строке слева направо,
дописываю символ
и хочу перестроить автомат.
То есть, вот я имел какой-то S,
я дописываю справок S,
новый символ C,
и хочу перестроить автомат.
Ну, перестраиваем автомат.
Побуквенно.
Вот написал букву, перестроил автомат,
написал букву, перестроил автомат.
Вот. И второе, я пока что
не буду следить за терминальностью.
Да, на протяжении всего алгоритма
я терминальности проставлять не буду,
вообще не буду над ними задумываться.
Только в самом конце, когда весь автомат
для все строки построю,
только тогда я проставлю все терминальности.
Пока про это вообще не думаю.
И вам не советую.
И, смотрите, что я могу сделать.
Я могу сделать,
я могу сделать,
я могу сделать,
и смотрите,
что мы будем делать? Мы на самом деле
будем делать вот этот переход,
рассматривая множество лонгестов
всех классов эквивалентности.
То есть, я буду
смотреть на то, как меняются
все лонгесты, то есть какие строки там
появляются, становятся лонгестами,
какие строки перестают быть лонгестами
при дописывание одной новой буквы.
То есть, при переходе к новой строке,
как меняются все лонгесты.
То есть, как меняются,
множество лонгест при дописывании c, при переходе от s к sc. Вопрос первый,
могла ли какая-то строка перестать быть лонгестом, то есть она была лонгестом,
потом внезапно перестала. Нет, потому что критерий. Если строка была лонгестом относительно
старой строки s, то есть для нее было верно что-то из этого, то значит обязательно она остается
лонгестом в sc. Потому что префикс остался префиксом, предварение влево осталось
предварением влево. Мы только справа что-то дописали, никакие вхождения не сломались.
Значит первое замечание, что лонгесты не пропадают. Ну и вообще почему нам
достаточно смотреть на лонгесты? Потому что если я знаю набор лонгестов, то я на самом деле знаю
все классы эквивалентности. Потому что лонгест задает классы эквивалентности, это какая-то строка
пусть будет лонгестом в своем классе. Вот это u, лонгест в своем классе. Тогда что такое ее класс?
Это все ее суффиксы, которые не лонгесты. То есть я вот отбрасываю по одному символу и дожидаюсь,
когда я получу очередной лонгест. Значит тогда это старый класс, это уже новый класс начинается.
Поэтому мне реально достаточно смотреть только за лонгестами. Лонгесты однозначно определяют
всю структуру классов. Если я знаю какие строки являются лонгестами, значит я знаю разбиение вот
этих суффиксов по классам эквивалентности. Что вот эти вот в одном классе, внутри с u, а когда
я отбрасываю первый символ, попадаю в новый лонгест, это уже новый класс. Причем один является
суффиксом другого. Еще раз, я взял какой-то лонгест u, отбрасываю первый символ. Это все не лонгесты,
не лонгесты, не лонгесты, внезапно попал в лонгесты. Еще раз, я знаю все лонгесты, я отбрасывал
первый символ, и когда ты попал в новый лонгест, тогда это обязательно новый класс. А вы что говорите?
Еще раз. Потому что они не лонгесты. А если они лежали в каком-то другом классе, то это должен
быть лонгестом в своем классе. То есть лонгест в своем классе задает как раз отсечение между вот этой
строкой и ее более длинной версией. Если здесь есть какое-то сечение, то есть если эти строки в
разных классах, то это должна быть... А, вы про то, что не может быть такого, что вот... Все, все, все,
я понял, я понял. Да, сейчас один момент. Да, сейчас секу. Тогда это было бы лонгестом как раз.
Потому что то, что вы сказали, продолжается разными буквами. То есть здесь есть какой-то x, что вот эта
строка, к этой строке можно слева дописать x. А если есть какое-то другое, то есть вот другое,
другое продолжение ее налево, так что это уходит в другой класс, то как раз здесь был бы другой
символ y. Значит это должно было быть лонгестом, потому что есть два продолжения. Ага. Вот,
значит действительно таких сечений вот посреди не может. Именно что вот они, они, мы просто отбрасываем
первый символ, дожидаемся, когда будет следующий лонгест. Так, теперь давай следить только за
лонгестами. Мы поняли, что они как бы нам порождают в точности все классы эквивалентности. Достаточно
следить только за лонгестами.
Ну, вопрос первый. Скажите, пожалуйста, при переходе от СКС, какая строка точно станет новым
лонгестом? Еще раз? Вся. Да, вся СС точно становится новым лонгестом. Значит опять при переходе
СКС, СС точно становится новым лонгестом. Ну, просто потому что для нее тривиально выполнен критерий
лонгест. Она является префиксом на всей строке. И при этом раньше ее нигде не было. Это самая длинная
строка, которая сейчас есть. Ее раньше в С не было, значит она раньше в автомате не присутствовала.
Только сейчас СС стала префиксом, то есть стала лонгестом. Поэтому как минимум одна строка СС точно
становится лонгестом всегда. Не зависимо ни от чего. Это точно новый класс эквивалентности, которого
раньше не было. Вот. На самом деле иногда появляется еще класс эквалентности. Но давай сначала поймем,
что за класс у вот этого СС. Кто здесь лежит? Какие здесь лежат слова? Какие здесь есть слова?
Сначала давайте определим, а чему вообще равен правый контекст вот этой строки СС относительно
вот этой нашей новой строки СС. Да, только Эпсилон. Надо дополнить строчку до суффикса
само себя, можно только приписав пустое слово. Значит здесь лежат в точности все такие слова,
у которых правый контекст это только Эпсилон. Ну класс эквивалентности это те, у которых
правый контекст только Эпсилон. Это можно характеризовать так. Это в точности все суффиксы СС.
Которые не входят в С, как под строки.
Потому что у них у всех правый контекст это Эпсилон. То есть вот есть длинная строка СС.
Вот последний символ будет С. Что за такие строки, у которых правый контекст только Эпсилон?
Ну во-первых понятно, что это обязательно суффиксы. Потому что если это не суффикс, то можно что-то
дописать недревеленно до суффикса. Значит это только такие суффиксы, у которых больше никаких
вхождений нету. Потому что каждый элемент правого контекста это по факту обозначение
какого-то вхождения строки в слово, в большую строчку. То есть больше нигде вот эти вот все
суффиксы, лежащие в одном классе эквалинации СС, больше они нигде вхождений не имеют.
Но это вот в сущности то, что я написал. Это все такие суффиксы, вот от такого до там какого-то
самого короткого из них, которые только что получили вхождение, то есть вот здесь вот заканчивается,
но раньше нигде не были. То есть которые не являются под строчками С. То есть они сейчас
получили вхождение, вот здесь они заканчиваются так, что можно написать Эпсилон. То есть вот здесь
заканчиваются. И больше в правом контексте ничего нет. Значит раньше их не было. Это вот такие строки,
которые я в первый раз увидел. Супер. Дальше давайте введем обозначение. Пусть С0 это самый длинный
суффикс СС, который входил в С как под строка. То есть у меня несколько самых длинных суффиксов
в строке СС не входили в С, как под строки. То есть вот эти вот самые длинные, они лежали в одном классе
таком же как СС. А вот давайте рассмотрим самый длинный, который входил. Но это соответственно
получается вот это вот. Это самый длинный суффикс, который раньше входил в С. То есть он будет ровно
длины на один меньше, чем самый короткий из вот этого класса. Согласны? Вот. То есть я вот
рассматриваю все не имевшие вхождения в С раньше, а они все не имели. А вот следующие, длины еще на один
поменьше, будет самым длинным имевшим вхождение. Вот. Значит я так обозначил. Ну и можно заметить
сразу, что линк от СС будет у меня гарантированно С0. Ну собственно по картинке, потому что вот есть
большой СС. Дальше я несколько первых символов могу отбросить, так что это все еще будут не под
строки С, то есть вот в том же самом классе находиться. А потом я отбрасываю очередной символ и попадаю
в строчку, которая уже имела раньше вхождение. То есть у меня вот был самый длинный суффикс,
я отбрасываю по одному символу, они не имеют вхождения в С, потом отбросил один символ и
получил вхождение в С. Это строка С0 и это в точности самый длинный суффикс СС, который
лежит в другом классе. Чего? Ну потому что линк у меня на классах определен. Линк от класса это
класс, формально. Ну по смыслу, да, можно опустить скобки, имеется в виду, что именно что суффсылка
для класса этой строки это вот этот вот класс. Окей? Так, хорошо. Теперь давайте попробуем понять,
могут ли быть еще какие-то другие лонгесты. Вот я уверен, что в общем случае может. Давайте
скажем следующее. Пусть Т это какой-то новый лонгест. Отличный от всего это СС. Отличный
от СС. То есть я понял, что СС обязательно новый лонгест. Вопрос, а могут ли другие еще появиться?
Ну вот пусть какой-то появился. Пусть Т это еще какой-то новый лонгест, который раньше не был,
а теперь он стал лонгестом. То есть он раньше не был лонгестом, а теперь стал. Когда такое могло
произойти? Вспоминаем критерий лонгест. Критерий лонгест. Строка Т может быть лонгестом в СС.
Если верно одно из двух, либо Т это префикс СС, значит это может быть только в случае, если Т это
префикс СС. Либо существуют две разные буквы А и Б, такие что АТ и БТ это под сроки СС.
Я просто написал критерий. Но смотрите, вот этого быть не может. Потому что если Т было префиксом СС,
то оно было бы и префиксом С. Значит оно и раньше было бы лонгестом. А я предполагаю, что это новый
лонгест. То есть раньше не был лонгестом, а теперь стал лонгестом. Поэтому этого быть не
может. Ну, формально, если бы Т было префиксом СС, то это либо префикс С, либо вся СС. То есть как
выглядит префикс? Это либо вся строка, либо что-то, что является префиксом С. Ну, все СС. Я уже
сказал, что Т отлично от СС, значит Т это префикс С, значит он раньше должен был быть лонгестом.
Поэтому этот случай я отвергаю. Получается, что теперь верно вот это, что Т продолжается влево
двумя разными символами. А раньше этого не было. То есть раньше, в момент, когда у меня был
построен автомат для С, раньше Т всегда предварялось только одним символом. Т предварялось
влево только одинаковым символом С. Т всегда предварялось одним и тем же символом.
Ну, то есть раньше оно не было лонгестом. Значит, вот это все было неверно. Значит,
оно продлевалось влево всегда одинаково. Всегда перед Т было какое-то А. А теперь внезапно появилось
еще вхождение В. То есть перед Т можно теперь еще и В написать. Давайте нарисуем картинку тогда.
Вот вся моя строка СС. Раньше все вхождения Т продлевались влево только А. То есть вот было
какое-то там АТ. Вот здесь там было какое-то АТ. Ну, и там еще где-то вот здесь могло быть АТ. Они
могли пересекаться вполне. А теперь внезапно появились два разных символа. Такие, что они
предваряют Т. Ну, тогда понятно, что это вот здесь опять-таки. То есть мы получили, по факту,
мы получили новое вхождение строки БТ. Это могло произойти только в суффиксе, потому что новые
вхождения, они вот обязательно только что закончились. Я дописал один новый символ. Строки,
получившие вхождение, обязательно являются суффиксами. То есть картинка такая. Какие-то были
раньше вхождения АТ, и теперь только что появилось вхождение БТ. Еще раз? Ну, не обязательно.
Пример вам какой-то вы хотите, чтобы я нарисовал или что? Давайте попробуем.
Сейчас, секунду, подождите, пожалуйста. АТС, АТС. А теперь представьте вот так вот. То есть у меня
была вот такая строка. Как видим, вот здесь, а, извините, давайте тогда побольше нарисую. Вот так.
Как видим, раньше, вот если я в качестве Т возьму вот это вот, оно раньше всегда продлевалось только
Ашкой. Никаких других вхождений ДЦ не имеет. Но если я внезапно дописываю здесь С, то опа,
появляется новое вхождение, предваряемое другой буквой. Оно не обязательно за одного символа стоит.
Но что из этого можно заключить? Чему равно Т? В частности. В частности. Но какому? Вот С0 я утверждаю.
Потому что что такое Т? Давайте посмотрим. Да, мы правильно поняли, что это суффикс С. Т
обязательно суффикс С. Но это не абы какой суффикс. А такой суффикс, что его расширение влево на одну
букву раньше не встречалось в С. Потому что, ну вот как я сказал, БТ раньше нигде не встречалось.
Значит, Т это самый длинный суффикс С, который является под строкой С. То есть это С0. Потому что
перед ним идет такая буква, что раньше такая комбинация БТ нигде не встречалась. Значит,
Т это С0 в точности. Самый длинный суффикс С, встречавшийся в С. Итого, что мы поняли? Мы поняли,
что если какой-то новый лонгест и появился, вот этот Т, если он и появился, то он обязательно равен С0.
Все, никаких других лонгестов не бывает. Один лонгест, это всегда С. Он обязательно
появляется. И, возможно, еще в качестве нового лонгеста появляется С0. Больше ничего нет. Потому
что мы доказали, что, то есть мы рассмотрели произвольный новый лонгест, мы доказали,
что он равен в точности С0. То есть если он есть, то он только С0. Вывод. Всегда появляется новый
лонгест СС и, возможно, С0. То есть всегда максимум плюс две вершинки, плюс два класса. Согласны? Да.
Потому что я предположил, пусть Т какой-то новый лонгест. Бла-бла-бла значит Т равно С0. Еще раз,
давайте это рассудение проведем. Значит пусть Т какой-то новый лонгест отличный от СС. Так,
сейчас. Наверное, надо повторить. Еще раз. Смотрите, вот я в этот момент понял, что вот этот Т,
который новый лонгест, то еще раз пусть Т какой-то новый лонгест. Один из тех новых,
которые появились. Я доказываю, что раньше он всегда предварялся одним и тем же А. Теперь
внезапно научился предваряться Б. Значит, в частности, в частности, Т это такой суффикс СС,
что его более длинные суффиксы, ну то есть если рассмотреть любой другой суффикс большей длины,
он уже в С не встречался. Ну потому что если перед Т идет Б и БТ раньше не было, то какой бы
более длинный суффикс я не рассмотрел, он раньше в С не входил. Поэтому в качестве Т может выступать
только самый длинный ранее встречавшийся. Потому что любой другой более длинный, чем Т, уже
встречался. Продон, наоборот, не встречался. То есть еще раз. Т это такой суффикс, что если его хотя бы
на один символ продлить, то это уже не встречалось. Значит, Т может быть только самым длинным
встречавшимся, потому что если возьму какой-то более короткий встречавшийся, то его продолжение
влево тоже будет встречаться. И это противоречит вот этой картинке. Потому что продолжение Т влево на
один не встречалось. Значит, Т только С0. Ну все, давайте закончим продолжение в следующий раз.
