Всем привет, мы начинаем. Начинаем мы наконец-то семинар, который я давно хотел, и все, что-то мы затягивали.
Мы будем, значит, кодить, и будет это происходить через волшебную магию Live Share в S-коде.
Ну да, все будем вместе редачить одни и те же файлы.
Так, Invitational Link Copy to Clickboard. Значит, появилась ссылка на Live Share.
Просьба по ней пройти и убедиться, что у вас что-нибудь работает.
О, дискуссию можно начинать. Космические технологии.
Так, ну дождемся пока, хоть один человек появится, и мы убедимся, что все работает.
Запись идет. ФПС поставил мало, цепу не грузится, ноут не греется. Вроде это успех.
Так, ну что, хоть у кого-нибудь получилось?
Ну, может в браузере, может нет. Я с той стороны не видел, как оно работает.
Да, и какие-то имена вбивайте, потому что гест анонимус меня как-то смущает.
Там же можно имя вбить, правда?
Нет?
Есть позволение, что нужно залогинить самый Microsoft Account.
У вас нет Microsoft Account?
Вы не пользуетесь WinDoy?
Мне просто нужно человек пять хотя бы, чтобы работали.
Ну да, вот там оно некоторое время тупить может.
Давайте тогда на такой вопрос смешно ответим, и вообще вводное, чем мы тут собрались заниматься сейчас.
Надеюсь, вы меня слушаете, хотя бы в полухо, смотря в экраны.
Мы хотим работать со списками типов. Что такое список?
Ну, чисто на математическом языке. Последовательность, конечная.
Ну, противопоставляется множеству. Последовательность, она вот фиксированная.
И в каком смысле мы хотим список типов?
Мы хотим какой-то другой тип, который внутри себя кодирует список других типов.
Зачем?
Есть идеи, зачем это может быть нужно?
Ну, как в Расте?
Ну, я, к сожалению, вот в Расте не знаю, что там, как обстоят дела со списками типов.
Кажется, никак. Последний раз, когда я проверял.
Был пропозал добавить тюплы, и там такие сразу, о, давайте тюплы еще и с типами будут работать, и ну, чего-то нет.
Что, никак не будут списки типов использоваться?
Как задать?
А, никак. Есть способы.
Ну, хорошо. Вот C++11. Какое жуткое изменение в шаблонах было, от которого все офигели?
А? Нет, с феней было всегда.
В рядике?
В рядике, да. В рядике это в каком-то смысле список типов, да?
Можем передать шаблон не один тип, а сколько угодно. 0, 1, 2.
А чем они неудобны?
Ну, посередине как-то обращаться к какому-нибудь катому не очень удобно.
Ну, это решаемая проблема.
Ну, в принципе все более-менее.
Ну, все решаемое. Ладно. Нет, короче, проблема главная, на которую я сетую, это то, что нельзя несколько в рядиков передать один шаблон.
Да?
Помните, я говорил, что мы собрались обобщать абстракт факторе?
Давайте даже картинку откроем.
Такая-то не та...
Произойдет ли что-то плохое, если я сейчас открою мой Google Drive?
Кажется, там не было ничего такого.
Да, тут только учеба. Прекрасно. Никакой дискредитирующей информации.
Лекция какая мне нужна?
Кто помнит, какая это была лекция?
Первая, наверное.
Да.
Ты-ты-ты-ты-ты-ты.
Где же она? Она одна из первых была. Вот. Вот-вот-вот.
Вот абстракт факторе. Я в какой-то момент сказал, что мы собрались ее обобщать.
Потому что тут, мол, ну код, полный boilerplate.
Вся эта иерархия нужна просто потому, что нужна, а интеллектуального кода ни в одной функции нету.
Там просто во всех вот этих вот create product A, create product B написано return new concrete product A.
Вот это вот код мы не хотим руками писать, эти функции мы не хотим руками писать, эти классы мы не хотим руками писать.
Ничего не хотим руками писать.
Хотим сгенерировать всю вот эту вот штуку, просто указав...
Ну, взяв какой-то шаблон и что-то в него подставив.
А что мы будем в шаблон подставлять?
Вот какие здесь вещи определяют вот всю эту иерархию?
Интерфейс фабрики.
Интерфейс фабрики? Ну а интерфейс фабрики чем определяется?
Ну тут просто create product A, create product B.
Это значит, что весь интерфейс, все, что в нем содержится, это вот просто список типов на самом деле.
Что крейтим?
Список типов, product A, product B. Это интерфейсы, кстати, да?
Вот один список типов нам надо задать, чтобы всю вот эту штуку сгенерировать.
А дальше есть конкретные фабрики.
Ну, догадайтесь, чем они задаются.
Вот конкретная фабрика 1, конкретная фабрика 2. Чем первая задается?
Тоже списком типов.
Конкрет product A, concrete product B. Ну, с единичкой.
Второй список типов получили.
И для второй concrete factory тоже список.
То есть если это не голосом проговаривать, а в коде написать, то у нас abstract factory задается...
Что?
Давайте осептим всех.
Вот видите, кто-то из вас у меня автоматом заосептился, видимо, потому что я уже раньше осептил.
Я тоже почему-то пустил.
Сейчас ты говоришь, что несколько вариантов как раз нельзя в тупле упаковать и внутри уже расплывать.
Ты в правильную сторону мыслишь, но пока...
Да, ты в абсолютно правильную сторону мыслишь, но пока идейно.
Для тех, кто может...
Как-то не понял из моих рассуждений.
Вот есть один список типов.
Product A, product B, product C. Это интерфейсы, которые мы хотим в нашей факторе.
Любая конкретная фабрика задается...
Product A1, product B1, product C1.
Это другой список типов.
Но как бы от этого списка типов мы все равно не избавляемся.
Чтобы конкретную фабрику соорудить, нам нужно и список интерфейсов знать, и список продуктов, которые удовлетворяют этому интерфейсу.
Два списка типов.
Соответственно, если мы хотим вот эти вот конкретные фабрики, вот эти вот классы Concrete Factory 1, Concrete Factory 2 каким-то образом генерировать с помощью шаблонов,
то нам нужно сначала научиться несколько разных как-то ворядек паков передавать в один класс.
Ну, я думаю, вы должны понимать, что...
Что я пишу?
Вот так вот мы делать не умеем, потому что непонятно, где разделитель поставить.
Я думаю, ничего не стоило в языке C++ ввести вот такую замечательную фишку, которая есть в некоторых других языках,
где умеют точкой с запятой разделять такие паки, но у нас такого нет.
Если честно, я не помню, где так можно разделять сейчас.
Короче, вот тут есть такой язык, да, скрипт, опять пропаганда пошла.
Вот там можно параметры функций разделять с запятыми и точками за запято, и там у этого вполне логичный смысл есть.
Мол, через запятую ты несколько аргументов с одним и тем же типом перечисляешь, а с точкой с запятой новый тип.
Ну, это мелочи.
Так, вот это надо убрать, вот это надо убрать.
Тут кто-то что-то пишет.
Ну, давайте вот на это все забьем.
Мы пришли к выводу, надо сделать какой-то тип, который содержит в себе несколько других типов.
Как это сделать?
Ну да, предлагается использовать STD tuple, но без значений, как тип, в котором просто указаны типы.
Но я предлагаю даже так не делать, а сделал для этого свой тип.
Давайте даже type tuple его назовем.
И все, вот наш тип.
Это такой tuple из типов.
Как его предполагается использовать?
Предполагается в какой-то другой шаблон, например, concrete factory maker какой-то.
Передать первый type tuple.
Может тут же тогда назначим factory factory?
Нет.
Не, не, не, надо полагать сущности.
Вот так.
Ну, factory это речь идет о конкретном шаблоне, вот этом вот.
Maker creator это всегда такой тип, когда не хочешь заморачиваться, этот шаблон или нет.
Хорошо, можно просто concrete factory назвать и все.
Можно generator.
Идея понятна.
Мы просто вот такими двумя tuplami можем передать два разных списка в один и тот же тип.
А зачем это?
Кто-то откопировал, может быть это был я.
А как с этим работать потом?
Может быть не очень понятно.
Потому что мы написали tt2.
Какую-то такую штуку.
Подожди, скорированием.
Вот мы такой шаблон написали, передали туда два списка типов.
А как из них достать?
Собственно, эти самые списки изначальные как-то использовать?
Можно по индексу получать.
А можно как-то очень тупо, если мы просто хотим получить вот такой же pack.
Прям параметр pack или заребай?
Прям параметр pack получить.
Кто меня там так активно...
Можно сделать последний, кого-то всех.
Нет, видимо вопрос непонятный я задаю.
Вот здесь хочется, идейно, сделать tt1 и распаковать и что-то с ними сделать.
Вот мы сейчас так не можем, потому что это какой-то класс непонятный.
Ну, можно...
Сейчас это класс у нас, да?
Но тогда это же по сути не будет rebind.
Что такое rebind?
Ну, нам нужно вытащить шаблон, наверное, и можно написать.
Мы здесь буквально выпусто оставим и закроем этот класс.
А затем написать конкретно специализацию от тюкла с какими-то паками.
Специализацию? Какую?
Ну, напиши специализацию, в которой будут паки.
Закончился класс.
Теперь мы пишем replay.
Никто не понимает, о чем речь, что происходит, или все понимают, и всем очевидно.
Я прослушал просто начало довода, поэтому не смотрю.
Так, ну, начало было какое?
Мы хотим генерировать Concrete Factory вот такие.
Чтобы их задать, нам нужно, во-первых, список интерфейсов,
во-вторых, список конкретных продуктов, которым мы будем дергать new.
Здесь написано, new дергаем.
Нужно два списка.
Два вариадика в одном шаблоне быть не может.
Поэтому мы сказали, заведем вот такой вспомогательный класс TypeTuple,
который ничего не делает, и будем через него передавать два разных списка.
Мы сначала список запаковали в тип TypeTuple.
А, вот, а то мы речь, что да, в шаблон мы не можем два вариадика передать.
Но...
Что ты забыл?
Сейчас, мне кажется, его просто бесит, что я вот тут некорректный код написал.
Вот, теперь его ничего не бесит.
Видите, это компилируется.
Вот в том, что будет сегодня, и том, что будет в домашней грядущей,
корректность кода, она вот проверяется на этапе компиляции полностью.
То есть сегодня мы вообще не будем собирать коды, запускать его,
мы будем чисто по красным подчеркиваниям понимать, что у нас где неправильно.
А как оно скомпилировалось?
Видите, вот так не работает.
Говорят, template parameter pack must be less template parameter.
То есть один и в конце.
Нельзя.
А вот так почему-то можно.
Но это к вопросу, а что такое вообще явная специализация?
Мы, по сути, делаем pattern matching.
Мы говорим, если вот этот шаблон, шаблон тут один, да?
Вот это все разные просто специализации одного шаблона.
Если этот шаблон инстанцировали с типами,
с какими-то специализациями type tuple,
а конкретно со специализациями, у которых написан вот такой pack внутри,
то вот использую вот такое вот тело класса
для нашей специализации Concrete Factor Regenerator.
И в итоге в рамках вот этого кода мы уже спокойно можем
паки test1 или test2 распаковывать.
Прикол, да?
Нет, действие компилятора, он видит.
Вот такую штуку видит.
Давайте ее сюда подвинем.
Сюда подвинем.
Прекрати прыгать.
И сюда, наверное, надо написать int float,
а сюда bool char, чтобы у нас компилировалось.
Ура.
Действие компилятора.
Он видит, что шаблон Concrete Factor Regenerator инстанцирует
с вот такими двумя шаблонными аргументами
и смотрит, какую явную специализацию надо использовать.
Ну, вот это, формально говоря, тоже явная специализация,
но она не единственная.
Он посмотрит еще на эту.
Ну, выбирается здесь и как с перегрузкой функции самая конкретная.
Ну, выбирается здесь и как с перегрузкой функции самая конкретная.
А, я кого-то following.
Как мне stop following?
Нет.
Так, unfollow.
Ну, из вот этих двух специализаций выберется самая конкретная.
Вот это просто говорит, я принимаю любые вообще классы, мне все равно.
А вот это говорит, я принимаю только классы,
типы, являющиеся инстанциацией шаблона TypeTuple.
Специализации, точнее сказать.
Ну, мы передали специализации TypeTuple, да.
Значит, выберется эта специализация.
Ну, и при этом сказано, что когда вот такие типы передали,
пусть то, что внутри этого типа TypeTuple было,
у нас теперь хранится в таком паке,
а то, что в этом было, хранится в таком паке.
Вот этот int float пара попадет, ой, в этот пак тэс-1,
а boll char попадет в пак тэс-2.
Но мы не можем явно вызвать вот эту штуку,
вот конкретную, нижнюю,
чтобы он не выводился в самок,
а явно типа, что он не знает, где же двигатель, да?
А ты, в принципе, не можешь явные специализации сказать,
используй вот эту.
Ну, ты же можешь в векторе там пакать int, чтобы открыть пак.
Ну, смотри, у тебя есть вектор bool, да?
Можешь ли ты сказать компилятору,
я хочу не вектор bool, которая специализация,
а хочу обычный вектор.
Ну, ты же знаешь, да, что вектор bool-ов, он там биты пакует.
Можешь ли ты компилятора попросить,
используй не вот эту явную специализацию для bool-а,
где биты пакуют, а используй главную специализацию?
Вообще не можешь.
В C++ всегда автоматом определяется,
какую из явных специализаций шаблона использовать
при подстановке шаблонных аргументов.
А может быть, у меня есть вот, я сделаю штуку,
какой ошибку он мне интересный дает?
Ошибку, вот там он красную подчеркивает,
меня просто не подчеркивает.
А у вас, когда вы смотрите, нету ошибок, да?
Ну, я не вижу всех.
Странно.
Ну, у всех по-разному.
Ну, что за ошибка?
Слишком много шаблонных аргументов.
Почему?
Идем смотрим в этот шаблон.
Сколько шаблонных аргументов он принимает?
Два.
Все.
А ты четыре передал.
А да.
Type tuple, да, это шаблон,
который принимает сколько угодно
шаблонных параметров.
То есть, здесь можно передать хоть десять.
Void, void, void.
Сейчас, как еще раз мы передаем
два type tuple?
Просто два класса принимаем, любых.
А потом мы говорим, что если эти классы
были конкретно type tuple с вот такими паками внутри,
то кто-то что-то навставлял,
то использовать вот этот вот код,
который здесь написан.
Вот это тело класса.
Просто вот мачинг, которые там двое,
наши, которые два, извините, точные,
какие-то всевозможные туманы,
как он так матчит?
Сейчас.
Как происходит мачинг?
Что-то я сломал, да?
Или кто сломал?
Тест 1, тест, а, тест 2.
Что можно сюда писать?
На самом деле это произвольный
паттерн мачинг, грубо говоря.
Вот я только что поменял чуть-чуть код,
и он начал ругаться.
На что он ругается?
Contains a template parameter
that cannot be deduced.
То есть, посмотри внимательно
на этот код, все посмотрите.
Может ли компилятор как-то понять
из вот этого вот такого паттерна,
что должно содержаться в паке тест 2?
Не может никак, он здесь не упомянут.
Поэтому это ошибка.
А вот если он однозначно может,
сопоставив то, что мы конкретно
в шаблон подставили,
с вот таким паттерном понять,
что каждая из вот здесь написанного
должно чем являться,
то как бы все нормально.
Гайды, да, гайды не про это.
Гайды про...
Гайды про конструкторы.
По шаблонным аргументам конструктора
понять шаблонные аргументы класса.
А здесь мы вообще конструкторы
звать не будем, пока что.
Все в compile-time.
А вот мы можем второй гайде
вытащить как первый?
Вместо tie2.ts2 просто тс2.x?
Использовать один как...
Да, так мы действительно можем.
Внезапно.
Только теперь вот так надо
такой паттерн использовать.
Заметили, что произошло?
Да, да, да.
Вот здесь теперь надо убрать type2.pl
и просто через запятую перечислять их.
То есть вот этот механизм
частичных специализаций явных
вы, наверное,
в задачах не его использовали,
а полные специализации, да?
То есть у вас вот здесь ничего не было,
а здесь вы просто конкретное значение указывали.
Забавно второй раз type2.pl убирать.
Мы можем уже type2.pl это доставить,
он просто как один,
подставится здесь.
Да, он подставится как одно значение
в этом паке параметров.
Тут начинается тема с
дактайпингом, кстати.
Так писать я считаю плохо,
потому что пользователю не очевидно,
что первый, оказывается, type2.pl должен быть,
а второй не type2.pl.
То есть пользователь спокойно может вот так написать,
это будет работать неправильно.
Да?
А почему если не писать type2.pl,
вы могли передать ему час?
А мы поменяли сверху,
как шаблон выглядит.
Мы сказали, что второй аргумент
теперь не какой-то type2.pl должен быть,
а просто
просто варядик какой-то,
пак каких-то типов.
То есть смешивать паки
и type2.pl я не советую, запутаетесь.
Либо передаете все через
тюплы, а внутри уже распаковываете,
как с этим работаете.
Либо все через один варядик.
Ну, вот это такая идея,
зачем все это может быть нужно и зачем
используются. Как сгенерировать этот
класс с ConcreteFactory мы пока не знаем,
конечно же.
Но сама, вот как сама
цель научиться работать со
списками типов, я думаю,
я достаточно обосновал,
что сейчас мы будем учиться делать
всякие классные операции
со списками типов.
Но не с такими.
Потому что вот я говорю списки типов,
а список типов это type list, а здесь почему-то
назвал type2.pl.
Чего?
Почему без методов?
Да нет.
Не поэтому.
Вообще методов никаких мы не будем
использовать. Шаблонное вот это вот
программирование на уровне типов, оно
всегда выглядит как функциональное
программирование. У вас есть данные типы,
все. Никакого ООП
на уровне шаблонов
на самом деле нет.
Давайте к спискам типов.
Придумайте мне, пожалуйста,
еще один список,
еще один способ
задать список типов.
Голова и остаток.
Вот. Голова и остаток.
Кто-нибудь еще понял,
что Аркадий сказал?
Давайте кто-нибудь попробует вот здесь написать
что-нибудь.
Слушай, а ты изначально
не заклюлся? Нет.
Все работает.
Но падает, да?
Нет, просто что-то вернулось.
Странно.
Что-то такое.
Там ты его...
Нет,
нет, не с
строиточиями.
Все правильно было написано
сейчас.
Вспомните Матлог.
Как вы из множеств делали
списки на Матлоге?
Ну,
примерно.
Ну ладно,
это могло от Лектора отличаться.
Идея в следующем.
И давайте вот это вот название
я поменяю. Я поменяю его на такое смешное
слово cons, потому что в функциональном
программировании это так принято называть.
Потому что одно вообще-то.
А, ты на fsharp'е пишешь?
Нет, я на скале пишу.
Нет, одно должно быть.
Ну, cons будет.
Какая идея? Мы будем задавать список типов
вот так.
Да,
это главная проблема этого слова.
Надо отучить свою память
пальцами букву T вставлять.
Ну, как-то так мы будем это делать.
Но тут начинается какая-то неприятность.
Сможем порезаться
будем резаться.
Ну,
смотри,
фундаментально, если ты используешь
врядики, то тебе не нужны
никакие вот такие приколы.
Врядики уже сами по себе
полноценные списки типов, и с ними можно
работать как угодно, можно голову отщеплять,
можно там еще что-то делать классное.
Это отдельная тема.
И она достаточно простая, на самом деле.
Я предлагаю вам
самим потренироваться, если вы хотите
с тем, что я буду type теплами называть,
работать. Ну, то есть в дамашке тоже немножко
будет про type теплы, но совсем чуть-чуть.
Но вот с этими type теплами можно, очевидно,
операции всякие делать.
Можно отрезать голову от вот этого вот
type тепла, где голова это первый элемент,
вот этот инт,
а все остальное, остаток
это хвост. То есть можно сделать операцию
отрезания головы.
Можно сделать операцию получения по индексу
типа в этом списке.
Очень сильно зависит
от того, как вы это сделаете.
Перформанс в компайлтайме
это отдельная тема.
Можно,
но это делается
built-in magic функциями,
которые, впрочем,
не могут быть
в компайле.
Но которые, впрочем,
ну, короче, есть
tuple get такая фигня в стандартной
библиотеке, типа std get
там ноль от тепла.
Вот она внутри
конечно же никакими шаблонами
не реализована, она реализована просто
через встроенную в компилятор волшебную функцию,
которая волшебством достает
нужный элемент. Но если вы сделаете
вот так и реализуете
протокол тепла для вашего type тепла,
то там все будет работать за вот единицы
и можно вот так делать.
Но мне интересно не это.
Мне интересно...
Окей, ладно, тогда надо использовать
не свой шаблон type tuple, а std.
tuple и вот там уже интринзики работают.
Все.
Ну, короче, можно сделать это быстро,
но медленно.
Можно так. Способ, конечно,
миллион.
Попробовать все мы
тупо не успеем, не на семинарах,
не в домашках.
Вот.
Вот, к этому
и вопрос, что
первым делом, когда вот этот
конс видят, ну, в чем идея
его? Мы храним в первом
шаблонном аргументе голову,
то есть первый элемент списка,
а во втором шаблонном аргументе
храним остальной список.
Но остальной список это другой конс.
Ой.
Ну, очень быстро
замечаешь, что если только так
действовать, то вот здесь какая-то фигня
оказывается. Понятно ли вам,
что вот так будет дико неудобно со всем этим работать?
Что
последний элемент как бы может быть
ну, второй шаблонный аргумент
у конса может быть другим консом, а может
быть конкретным типом.
И уже не понятно,
как это отличать от, скажем,
от списка списков.
То есть двумерный массив
типов мы тоже, наверное, хотим уметь делать.
Начинается куча проблем. От этого
берется здесь элемент нил.
Соответственно,
если все это подытожить,
что мы говорим? Что мы вводим
такой, грубо говоря, концепт
список типов.
Список типов
это либо
нил
это значит пустой список.
Либо
либо
это какая-то инстанциация
конса.
Теперь вопрос.
Я здесь хочу написать что?
Что, мол,
тт
давайте так.
Опять говорю неправильное слово.
Какая-то специализация
конс.
Вот, да. Умейте ли вы
определять,
является ли структура специализации
какого-то
шаблона
в принципе как угодно?
Как-то да.
Мы это написали уже, по сути.
Вот через это
как раз можно.
Тут можно просто в паблике написать using type
иначе using value true.
Можно еще вот так.
False type.
Вот здесь там
true type.
И примерно мы поняли,
как проверять, является ли там что-то.
Конечно,
оно должно быть, да.
Идея понятна.
Надеюсь, вы такое просто уже писали,
когда-то игрались с этим.
А сейчас я вам покажу более
смешной юморной способ,
до которого допереть
самому, наверное, достаточно сложно.
То есть я его не сам, конечно же, придумал,
а высмотрел.
Сейчас
бы воспроизвести
и ничего не перепутать.
Requires у нас будет
такой.
Да.
Вот так.
Вот так.
Вот так.
Вот так.
И вот так.
Как вам?
Понимаете, что
написано?
В смысле, все, красно мне...
Ну,
это шаблонная лямбда,
и она снимает
на одну.
Ну, она
паттерн.
У нее паттерн в аргументе
консов A и B.
Поэтому
она либо дидюсит A
и B, если
ТТ это конс,
либо дается
E, что
ТТ не конс.
Поняли объяснение?
Так, а может, B
тоже тайп-лист, нет?
Нет, B может быть
либо тайп-лист, либо нил.
Нет, нет.
B может быть либо конс, либо нил.
Но это абсолютная правда,
что B должно быть тайп-листом.
Но так мы не умеем
языке C++.
Ну, то есть, можно
из хичлицы написать
штуку, которая при проверке этого концепта
будет рекурсивно спускаться
по всем консам и проверять, что они
везде корректные.
Да, да.
Нет, что? Стоп.
B должно быть
либо конс, либо нил.
То есть, можно написать
хитрую процедуру
в Compel Time, которая будет спускаться по этим
типам. Метапрограммирование
там все волшебство
сделает и проверит, что везде конс
и нилы.
Наверное, у этого есть причина,
почему так не делается.
Просто причина, наверное,
в том, что
а что
есть список бесконечных?
Ну, это раз.
А два,
что если рекурсию у вас
в общем случае не завершится.
То есть, не хочется
иметь при проверке концептов
произвольную рекурсию.
Наверное, поэтому...
Окраничение на рекурсию есть.
В общем, мораль.
Можно здесь из хищрица все это
вынести в отдельный шаблон класса,
и там рекурсивно идти
и проверять, что все нормально.
Я предлагаю так не делать.
Просто остановиться на этом. Мы проверили
верхний уровень, он конс, нил,
а дальше мы просто
на самом деле будем работать с вот этими списками,
в какой-то момент до какого-то
места их развернем и все равно
проверим, что там все нормально.
Да?
Зачем вы конс подумали? Я забыл.
Конс? Ну, на самом деле
не зачем. Это все развлекуха.
То есть, в современном C++
просто берите, используйте
врядики, у вас все будет хорошо.
Но когда-то их не было, до 11-х плюсов.
И до них тоже как-то
хотелось со списками типов работать.
А как ты описываешь,
что да?
Просто проверять концепты никто
не просит. Не проверяю
все. Концепты нам
нужны только для удобства.
Да, то, что здесь что-то проходит,
это, конечно, грустно, но
давайте не будем перегружать компилятор
с лишними проверками,
потому что если мы на каждой инстанциации шаблон
работающего со списком типов будем
проходить весь список типов и проверять, что он весь
корректный, будет немножко
больно.
Да, зачем все это нужно?
Это все придумал Александр Эску в книжке своей,
которую я там не один раз уже о ней упоминал.
И придумал ровно для
вот этого вот
всего. Он хотел генерировать
вот такие вот сложные шаблоны.
Для этого нужны были списки типов.
Врядиков
не было. Он
хорошо учил матлог в УЗе
и просто реализовал
такой матложный список или
функпрожный список.
Ну, подозреваю, что это не
функциональные программисты придумали, а все-таки
логики в какой-то момент.
Во времена тюринга, например.
Вот просто вот так делать.
Да, во всяких
языках вроде Хаскеля ровно так
и задается всегда любые списки.
Некоторое преимущество у такого подхода
есть.
Но вы его увидите в домашке.
Кто уже себе все проспылирил,
тот сам себе злобный Буратино.
Еще про Хаскель пару слов скажу.
Перед тем, как мы
перейдем к тому, чтобы писать разные
операции работы над вот такими списками типов.
Тяжело
форматировать код.
Или что-то хотел сказать?
Нет, я хотел сказать, что
тяжело код удалять.
Что значит удалять?
Последний элемент? Откусить?
Ну да, тяжело.
Что поделать?
Поэтому я говорю, что вот это лист такой.
Он как бы форвард-лист на самом деле,
но сейчас больше такая терминология
функпрожная идет.
Там это листами просто называют.
Поэтому вот это тюпл.
Потому что в тюпле на самом деле рандом аксесс есть, если очень постараться.
Завод единицы по индексу
вообще никак здесь не получится.
Да, завод единицы по индексу
вообще никак здесь не получится.
Я не верю, что в тюпле есть
аксесс, если не иметь
в игре имплементацию следовательного.
Ну если не иметь, то наверное нет.
Почти, наверное. Не уверен.
Наверное, все-таки какие-то хитрые способы есть.
Я не помню.
Но каждый год придумываю
новые хитрые способы извращаться в языке
C++. Я не удивлюсь, если что-то
вы уже придумали.
Или я просто не нашел.
Но если кто-то найдет, обязательно нам расскажите.
А мы про именно листы будем.
Так вот, что я хотел сказать. Про форматирование.
Сейчас у вас будут трехэтажные шаблоны.
Вот такие.
Уже был комментарий, что
как от треугольной скобки не обколоться.
Очень просто.
Новый код стайл.
Для вас новый. Почему у нас 4 пробела?
Что это такое?
Должно быть 2.
А клан формат?
Нет.
Я не буду запускать клан формат сегодня.
Сейчас увидишь, почему.
А где кнопочка...
Еще надо.
Еще, да?
О, вот теперь видно.
4.
Детект.
Вернули обратно.
Вот так кажется было, да?
Нормально видно?
Код стайл.
Новый для вас. Очень смешной.
Кому-то сейчас понравится, кто-то будет плеваться.
Теперь это лесенка, да?
В смысле?
Это невероятно удобно, если вы занимаетесь
функциональным программированием.
Любые списки чего угодно
работают так.
Какое-то название или
префикс на первой строчке.
На следующей строчке открывающая скобка.
И после нее через пробел
элемент списка.
Потом запятая через пробел элемент списка.
Ну и так далее.
Да.
Это принципиально, что она переносится.
Потому что, да, оно у тебя так выровнено
будет.
Эта колонка,
вся пунктуация.
Более того, это мега удобно
в плане копирования.
Если там просто какой-нибудь
вот такую какую-нибудь фигню сделать.
Вот так делать, да?
Вы предлагаете?
Ну я решил,
что мне два була на самом деле
в этом списке нужно в конце.
Откопировал, у меня не компилируется.
Нужно вернуться обратно,
поставить запятую.
Нет, неудобно.
Я делаю вот так.
Теперь могу спокойно копировать
хоть последний элемент.
Ладно, любой кроме первого.
Кто строчки переносит?
Или это я сам тройной клип?
Наверное, это я сам.
Ну, короче, такой стиль есть.
Он в Haskellе широко используется.
Сегодня я его буду тоже использовать.
Мне кажется, это удобнее,
когда мы пишем функциональный код.
Так, на этом
такая вводная часть
закончена.
Давайте удалим
все, что происходит.
Все лишнее.
А лишнее здесь...
Все.
О, тут кто-то
играется с какими-то матчами.
Кто-то писал
и прокомментируйте.
Что ты хотел сказать этим?
Я не хотел ничего сказать.
Ну ладно.
Я удалю это?
Окей, вот это удалим.
Вот это, наверное, все оставим.
Это, наверное,
в репозиторий попадет,
а может, не попадет.
Я не решил, хочу ли это все заливать.
Окей, мы идем в соседний файл.
Здесь есть какая-то кнопочка,
чтобы у вас всех пресумонить.
Нету, да?
У меня должна быть кнопочка,
чтобы всех пресумонить в конкретное место.
Ну ладно, не получилось.
О, я вас всех
сфокусировал на мне. Прекрасно.
Можете отфокусироваться.
Главное, чтобы вы попали в нужный файл.
Смешной файл.
Здесь есть куча заглушек
разных и смешных операций.
Давайте по ним пробежимся.
И везде, где вы видите туду,
нужно что-то вписать.
Поэтому, если вас эта операция
заинтересовала, вы стирайте туду
и начинайте пыхтеть.
Не гадлистите, пожалуйста.
Мы здесь собрались что-то хорошее накодить.
Ну, первая операция.
Делаем список типов из параметра pack.
Она нам нужна, чтобы поудобнее списки типов
создавать, потому что вот так
ручками писать cons, cons, cons, nil
мы не хотим.
Но поиграться с ними хотим.
Поэтому нужно уметь паки конвертировать
в cons, cons, cons, cons
и nil в конце.
Предупреждение заранее. Не засоряйте
глобальный namespace, пожалуйста.
Если вы вспомогательные какие-то шаблоны будете делать,
namespace detail
и в него все.
Append. Ну, понятно, что Append делает.
Дописывает в конец новый тип.
И тут, конечно же, тесты уже
накиданы с какого-то
прошлого года. Если вам их не хватает, вы можете
еще их накидать.
Ну и то, о чем я говорил.
Решили вы
под задачу, как только вот эта вот
красная строчка пропала.
Так, Append, Append.
Конкатонация.
Ну, тоже понятно,
что такое, да?
Ничего магического.
Headtail. Взять первые элементы,
взять все кроме первого.
Найти длину.
Почему плюс? А, наверное,
в прошлом году ставили плюс и там, где занято.
Пока не занято.
Думаю, тоже вопросов нет.
Reverse. Ну и разреверсить.
Вот map более интересная.
Вот вы знаете про операцию Map.
Да.
MapReduce.
Такое модное.
Это все из FuncProgi пошло.
И MapReduce.
И, заметите, что мы используем в качестве функции.
Другой шаблон.
Это метафункция.
Она на вход принимает какой-то класс.
А, ну я не понял,
что ты там писал. На выход дают
другой класс. Нужно пройтись
по всему списку типов и каждый тип
в нем заменить на f
от этого типа.
Ну и тут есть тест
с функцией, метафункцией AddStar.
Что, мол,
int void bool добавить звездочку
должна быть int звездочку, void звездочку, bool звездочка.
Сколько там еще?
Interspers. Вот это кажется одной из самых сложных.
Если кто-то прям хочет вот запотеть,
возьмите эту штуку.
Что она делала?
А, между каждыми элементами
вставляет новый.
Ну по тестам можно понять, на самом деле, что происходит.
boolpack int void bool
решили интерсперс на char.
Получилось int char,
void char, bool char.
Нет, в конце char нет.
Ну короче, как в питоне
Interspers, знаете?
Там можно список
строк сделать ему что-то типа
Interspers и потом join.
И вот вы делаете список строк
Interspers запятая
и потом join. И у вас получается
список с запятыми строка.
Ну вот такая логика тут.
Какие у нас ограничения для реализации?
Важно ли
type-to-plu, type-to-plu?
Я хочу, чтобы вы
не уходили к type-to-plu.
Ну то есть как бы реализация
должна быть в духе вот этих списков типов.
Везде надо ходить рекурсивно.
Первые элементы.
Ну не сильно сложно, но так.
Надо поднапрячься.
И последний n тоже так.
Итак.
Сейчас все, кто подключен,
дружно решается, какую функцию он
хочет реализовывать, и садится.
Ты отжал
pack-to-list. Прекрасно.
А еще я отжал
на mscreen tl. Пожалуйста,
прошу, не пишите больше
афиги.
Да нет,
на mspace detail как раз мусора надо
накидывать.
Ну конфликты может быть.
Так.
Что ж вы так смотрите печально?
Вам надо решиться на мужественный
подвиг. Вызваться.
Что? Да, вы пишите, не я пишу.
А нужно писать, кто
забрал или нет?
Месяка хватит.
Да без разницы.
Я думаю тоже без разницы.
Да.
Оценок за это конечно же никаких
не будет, но это возможность потренироваться
под неймнадзором перед домашкой.
Домашка, как вы можете догадаться,
будет ровно про это. Реализовать кучу
разных операций.
Но с таким спайси
нил, нил и конс
прибиты,
зафиксированы ли названия?
Сейчас да.
Конс и нил они зафиксированы и прибиты.
Мы в итоге с консами
работаем в стане традиции получается.
То же самое может быть
писать и на этим вариадике.
Да, но есть
некоторое преимущество. Я говорю в домашке
вы увидите, что классного можно натворить,
если пользоваться не вариадиками.
Если кто-то писал на хаскеле,
то он может догадаться, чем
хаскеловский лист отличается
фундаментально, например,
векторов в плюсах.
А что, бесконечная?
Да. Ленивость?
Да.
Больше ничего не говорю, сами подумайте об этом,
в домашке разберетесь до конца.
Вообще суть всего этого
в том, чтобы прочувствовать, как
писать разные метафункции
хитрые операции
в шаблонах над типами.
Потому что тут очень много
всего придется вам заиспользовать.
Частичные специализации,
всякие полные,
вся цирковая штука.
Почему append никто не взял?
Append один из самых простых.
Кто хочет append?
Класс-лист. Что за класс-лист?
Есть концепты type-лист,
которые мы можем здесь дописать
где-то вместо этого,
а можем не дописывать.
Так.
Все написано.
Нужно доброволец найти длину,
это простенько.
Доброволец найти длину,
не ты, Аркадий.
Ну, совсем просто.
Возьмите.
Так tail
тоже тебе слишком просто
будет. Ты tail не берешь.
Нет, я не знаю пока,
как написать tail.
Ну ладно, давай тогда.
Tail, кажется, никто не взял.
А зачем мы вообще писали
всех этих класс?
Вот эти вот густое тело.
А, можно без тела.
На самом деле.
Да.
Ну, то есть давайте сейчас у конца
и Нилы уберем тело,
если вас оно смущает,
и это будет тогда incomplete type.
Ну, так и задумано.
Мы их не хотим
создавать экземпляры этого класса.
Это чисто служебный класс.
Сейчас здесь где-то есть типа last.
Я прочитал tail
и подумал, что это last,
а не tail.
Last?
Наверное, last end.
Сейчас, а как в Haskell last называется?
Да там last end в конце есть,
я его возьму.
А, ну можно так.
А если у Вадика желание
наоборот сделать, чтобы у нас
из концев лист получился?
Хороший желание или плохой?
Сейчас, из листа в тюпл?
Нет, из концев,
из последовательства концев в тюпл.
Вот вложенные концы
мы называем листом.
В ряде с тюплами одно и то же.
Если хочешь, напиши
конверсию из
из листа в тюпл, но
короче, это будет медленно,
если ты будешь реализовывать вот эти вот алгоритмы,
сначала переходя к
паку, а потом обратно.
Сейчас, а если
писать last end,
насколько это
не правильно?
Сначала считать size.
Что значит
сначала считать size?
Сначала какой размер листа,
а потом уже из этого
исходим.
Давай подумаем.
Кажется, в форвард листе
нельзя играть.
Потому что в форвард листе, пока мы не пройдем
до конца, не знаем, где мы закончим.
Ну да, тут аналогии с обычным кодом
они работают прекрасно.
Мы можем пройти
в форвард листе до конца
в перекурсии, например,
а потом, спускаясь вверх, накапливать
элементы. Можем?
Можем. Здесь тоже что-то такое
возможно получится.
То есть не два прохода,
а спуститься и подняться.
В итоге каждый свой
namespace detail делает или
да, сделайте
свой namespace detail
какой угодно.
Короче, главное, глобальный namespace
не засоряйте и избегайте конфликтов имен.
Есть ли еще кто-то?
Typelist у вас
уже зафиксировано.
Typelist это концепт, да.
Он зафиксирован.
Если ты насполирил
себя как в домашке, он зафиксирован.
Тут по-другому, да, так и задумано.
Окей, это хорошо.
В домашке концепт typelist другой.
Кто сидит, скучает?
Возьмите еще что-нибудь.
Лучше бы сейчас Typelist заняться.
А я ничего говорить не буду. У нас
семинар.
У меня тоже
useI
в будущем он появится.
Просто получается не протестировать
то, что он будет написать.
Тут и так не особо протестируешь за количество ошибок
компиляции, но как только
начнет какое-то
количество реализованных корректно функций
накапливаться, все будет круто.
Так.
Так, это Pactlist
ты сделал, Аркадий?
сделал давай тест напишем поехал разметка да ребята пакту лист у нас
рабочий утверждается что так что можете его использовать и не сами выписывать
ну в смысле для тестов для тестов его использовать да реализация
должно быть без него чтобы оно быстро работало тесты можно с ним
ну вы работайте я пойду за водичкой
ее именно и приветствую мы сейчас просто ходим рекурсивно по этим спискам и
пытаемся что-то найти
а вот это я не назвал
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
Сейчас, давайте по одному.
Короче, я ловлю странное ошибку.
Планетарь, эваливация, локальность, констакт.
Планетарь, эваливация, локальность, констакт.
Планетарь, эваливация, локальность, констакт.
Возможно, ты наткнулся на independent base name lookup.
Нет?
Помнишь? Рассказывал об этом.
Что если у тебя дергаешь что-то из родительского класса...
Это все в одном классе.
Это все в одном?
Да, у меня нет последований.
Я просто в родительский хуй нес. Ну ладно.
И, то есть...
Divide, Extend.
Ну это просто обокруглять в делении.
Когда такие ошибки, надо начинать модифицировать.
Вот это выражение вынести в отдельную constexpr переменную.
Прям в этом блоке делаешь constexpr фуров, но это выражение уже подставляешь.
И вот как-то так декомпозируй на кусочки и смотри, работает или не работает.
Да.
Concatenate.
Давайте посмотрим Concatenate.
После...
Так.
Ну, идейно. Что вы сделали?
Ну, дошли до конца списка.
Ну, вот.
Так надо.
Да, вот тут...
Некто Никита пытается сделать частичные специализации.
Using так не работает. Это вы.
Никита, ты.
Вы вдвоем, Никита.
Понял.
А вот так не работает. Нельзя сделать forward declaration для using, к сожалению.
Поэтому я и сказал про namespace, потому что вам какие-то структурки вспомогательные могут понадобиться.
Так, а какая ошибка у тебя была? В каком месте?
На какую строчку мне посмотреть?
134.
А вот почему нельзя forward эти music делать?
А, так вот. Вот так.
Ну, это мега тупо. Меня тоже это бесит.
Местами это мне ломает жизнь очень сильно, но вот так вот.
И причем достаточно легко придумать замену.
Ну, какой-нибудь type name foo, если бы работало, было бы здорово.
Как forward declaration.
Но не работает. Я думаю, за проблем Abbey.
Так.
Ну, ctrl c сделай, перезагрузись.
А first and detail.
Это оно?
Нет.
Сейчас. Length. Что в length пошло не так?
Нормально.
Хитрее будете делать.
Хитрее.
Списки типов.
Знаешь операцию group by?
Ну, вот это бонус на уровень этого dz.
Сейчас забавишься.
Ну, obs скрашился. Наверное, оно и к лучшему.
На камере.
Ну, на камере тут достаточно хорошо все видно должно быть, по идее.
Вот.
Ну, я просто не знаю, как с этим воевать.
Оно умирает, крашится, у меня ноут перегревается.
Возможно, пора новый ноут покупать.
Так, ну, length там вообще правильно выглядел.
То, что он не работал, это, возможно, баг чего-то выше.
Что?
TL?
Окей, оно все работает.
Вот.
Вот.
Здравствуй.
Здравствуй.
Аркадий, ты решил просто все написать за всех, да?
Нет, просто какой-то человек у меня украл у нас TL.
И я хочу написать, записать, чтобы вот этого деймспейса и таблистировать.
Окей.
Ну, такое могло произойти.
Так, кто-то у нас неправильно использует слово typelist.
Typelist это концепт.
Cons.
Cons, пара, элемент, хвост, это cons.
Или что вы хотите?
Type tuple.
Такие же первокуры шумные, боже мой.
Реверс делаете, да?
Кто?
N? Что?
Вау.
Но это умно, да.
Но это медленно.
Так, Никита Петя.
Мне кажется, вы что-то тут творите такое очень хитрое.
Зачем?
Не надо так.
Perf в compile-time измеряется в количестве инстанциаций.
Всегда, когда мы пишем что-то вот такое, наша задача это минимизировать количество инстанциаций шаблонов.
То, что вы делаете, это будет очень больно.
Ну, то есть чем проще и меньше действий вы делаете, как правило, тем быстрее оно работает.
OK, но логично, хотя бы unpack на фису правильный, но типа это должно работать?
Unpack. То есть вы перегоняете...
А зато type tuple и sponsor?
Ну, нет.
Вот это фигня какая-то.
Почему сделали type tuple из какого-то left и шаблон unpack вашего?
Ну, короче, у вас таким образом не получится сделать превращение type-листа в type tuple,
чтобы превратить type-лист в type tuple, вам нужно в шаблонных аргументах вашего хелпера, вот здесь, накопить пак итоговый,
а потом разом весь его запихнуть в type tuple.
Если вы поняли, это OK.
Но это не имеет отношения к реализации апенда.
В апенде нужно просто дойти до конца и заменить...
Заменить.
Ну, как конкатенейт люди уже справились, можно точно так же как там, по сути.
Ну, добивайте.
Пока апенд превратится в конкатенейт, tl, cons...
Блин, конкатенейт он ниже.
Ладно.
Сейчас с левой тип, с правой конца.
Сейчас разом в конце левой тип, правой...
Да, слева тип, справа другой список.
Ну, вот, да, вот эта конвертация в ту сторону, это то, что немножко расширяет сознание в плане использования шаблонов,
накапливания результата в шаблонных аргументов какого-то хелпера.
Такой трюк необычный немного.
А что мы делаем?
К тебе смельчак, который возьмет эндерспёрс?
Ты берёшь его, да?
А я пилю.
Я пилю.
А ты пилю.
А я пилю.
И ты пилю.
А я пилю.
А я пилю.
А я пилю.
А я пилю.
А я пилю.
А я пилю.
Ты берёшь его, да?
Ага, всё.
А вот плюсик вижу, всё, я не заметил.
Реализация, я всё-таки считаю, что...
Ну что ты делаешь? Ты идёшь...
Сколько выкинуть надо, да?
Ну это нормально, в принципе.
По-моему, я также в итоге написал. Это самое простое, что можно написать.
Насчёт оптимального, надо, конечно, подумать.
С головы такая просто это не выдумать.
Ну как можно, типа, имитировать?
Именно...
Вот как бы, типа, граф идём, открытие, закрытие, вершина.
Вот как бы, закрытие, имитирование.
Вышли из скоб.
В шаблонных аргументах что-то надо делать.
Смотри, мне хочется, в идеале как сделать?
Сделать репушку, чтобы мы выходим до конца, а затем выходим один раз.
Это кажется последствием уже.
Нет, выходить мы всё равно все... ну и входим-выходим одинаковое количество раз.
Прошли до конца, потом выходим.
И вот пока мы проходим внутрь, мы должны каким-то образом понять,
а на каждом из этих шагов должны ли мы наружу возвращать
результат просто, как он есть, или прицепить ещё свой элемент.
То есть каждая нода рекурсии делает решение.
То, что ей дали следующего шага, вернуть как есть или прицепить свой результат.
Вот это решение научиться принимать нужно, пока мы спускались вниз, мне кажется.
Сейчас я попробую. У меня есть какая-то голове мысли возникла.
Сейчас может получится делать.
Track 1
Я не знаю, что тут делать.
Хочется сказать, что нет.
что нет, но тут как всегда есть маленькое но, но наизусть
я не помню в чём там деталь и проблема.
А нет, вот куда посмотреть какая строчка.
Так, и что тебе пишут?
Так вроде она работает, просто там это кто-то нашалил сверху, сломал.
Ну я вот сейчас смотрю, тут ничего вроде нету.
160.
Аппенд никто не стал писать.
Ну это мы пробуем так, если мы выбрали любой список, один список на капель для другой размерации.
У вас ничего не работает, да, там смептонг.
Ну тут люди пишут что-то, поэтому это всё.
Пробовали выйти и зайти обратно?
Какой у тебя ник?
Нет, может просто призрак остался.
Да, но только пишет анонимус, на самом деле ники можно ставить.
Да, это для меня новости.
Кто type name не дописал?
Кто мап писал, он готов или не готов?
Тут кажется какие-то форут-декларации нужно накладывать, что-то вот такое, чтобы оно не жаловалось на жизнь.
Ну вообще мап должен быть проще, мне кажется.
Вот то, что три разных шаблона, уже это так не должно быть, там одного должно хватить.
А, вижу. Ну всё равно, по-моему одним шаблоном можно обойтись. То есть проще должно быть немножко всё.
Одним шаблоном со специализацией в смысле, да.
Что-то по всему файлу пропадают запятые точки с запятыми. Что происходит? Кто ворует?
Аркадий, почему ты забросил last temple fast?
Я не забросил, это интернет упал, я его пришёл.
Не видишь, но он растёт.
Видишь имплементацию, она есть.
Нет, я написал какую-то логику уже, но я верю, что она работает. У меня осталась специализация для крывых звучей.
Кто пишет маму?
Кажется люди за вами, вот там.
Так, в 373 мы пытаемся первой N.
А, ты наткнулся на случай, когда ты сделал специализацию, когда нулевой размер, число н, число ноль, и отдельную специализацию, где нил.
Сейчас, нет. 379 и 391, говоришь, ambiguous.
Да, тут тоже может быть ambiguous, когда у тебя и ноль, и конс одновременно.
Кстати, это тоже такая мораль небольшая, что такое возникает, а надо писать третью тогда.
У меня она возникала с пустым обычно, когда вот не конс, а нил.
Так, что вы в этом тейке сделали такого, товарищи?
Ты один делал или вы там вместе?
Да, что ты там натворил?
Ага, развернуты.
И тебе потом обратно разворачивать нужно.
Кажется мне, что можно без этого разворота.
Ну вот сразу ты идешь внутрь, вниз.
Берешь и говоришь, что я это конс от текущего элемента и рекурсивный вызов от хвоста.
Понял?
На каждой трассе рекурсии ты говоришь, что твой тип это вот конс от текущего типа и рекурсивного вызова.
А дальше рекурсивный вызов в какой-то момент решит, а дальше идти не надо.
Все, мы набрали сколько надо.
И вернет нил.
Не придется реверс делать.
Что вы видите?
Что вы видите?
А вот и другое.
Теперь положите.
Кто-то у нас где-то халпы.
У нас халпы где-то там.
Вот у нас халпы.
Я не особо понимаю.
Стоит ли сейчас пытаться впихнуть кусочек теории?
Ну давай ты мне покажешь, а я перепишу.
О да, сейчас тебе путешествие будет.
Вот отсюда начинается.
Только один счетчик, да?
Да.
Тин счетчик.
Хэк тэйл, тэк тэк.
У, мама, кондиционал тэ.
Ну это конечно так.
Ну в принципе это примерно то, что я хотел, да.
Ну тут сейчас будет да.
Тут просто с насыщением.
Иначе видимо...
Что ты такое делаешь вообще тогда?
А, эта штука плюс... да, да, да, факт.
Какое-то программирование.
Сейчас надо искать, да?
Все, да?
Больше специализации нет?
Вот еще.
О, нет.
Конец.
На самом деле не конец, да?
Потому что еще если тебя ноль передали.
Если ноль передали, то...
Если ноль передали, то...
Нет, она отработает, если ноль передали.
Можно оптимайз, конечно, сделать.
Но если так помыслить.
Ну сейчас давай мы напишем ниловскую специализацию.
Тут еще size 0.
А, она дойдет.
И это last end, да?
Вот сюда size еще можно написать.
Size 0.
Это last end был, правда?
Last end.
Last end, да, для last ends n.
Окей, да, да.
Можно только оптимизировать, но это так фигня.
Окей, смотри...
Прикол.
Conditional te можно заменить.
Заменить на следующий прикол.
А, специализацию на bool сделать?
Сейчас, но...
Интересно, интересно.
Вот такой какой-то прикол.
Сейчас, нет.
Но тут, конечно, достаточно сложно это будет с тем, как ты написал.
Отсюда выдрать tail only head.
Я не знаю, мне не хочется об этом думать.
Я бы оставил...
Можно да, можно так.
Но тут можно поиграться.
И вот через этот люк тоже может красивее выйти.
В целом, кажется, она работает.
Сейчас.
Если заменить.
Давай тогда вот здесь нужно в last end.
Ну тут умеет просто на fast.
Там тест нежуестка.
Что это подчеркнуто?
No name type name.
А, стоп, там еще не все.
Тут странное что-то.
Тут надо вставить.
Сюда write.
Почему-то нет.
Почему ты сюда write и не ввешай?
Не-не-не.
Смотри, meagones.
Type.
Type.
3.
Мне кажется, она идет в дефолтную имплементацию.
conditional.t
Ты понял, что произошло, да?
А, скобки потерялись.
Работает, ура.
Ну все, получилось.
Жаль, конечно, что wi-fi карта не позволила.
Так, у кого еще что-то не сработало или не срослось?
Рома, мы случайно развивали монст в обратном направлении.
Можешь ампак-тошку смотреть?
Кого посмотреть?
Ампак-тошку, вверху самом.
Это Никита.
Мы как-то сделали правильно,
только у нас ампак он еще реверсит при этом.
Неприятная особенность, да?
Мы ее осознали давно.
А зачем вы вот так вот делаете?
Странно.
В чем странность?
Принимайте.
Зачем отдельно выделять обработку последнего элемента,
когда база рекурсии может с нулем работать?
Может.
Так, а сама рекурсия как выглядит?
ConsLeftRight распаковываем
и запускаем ампак от...
А что такое helper?
Просто закопить.
Не понимаю.
Ну и кажется, кстати, кассет проходит.
Ну, проходит и проходит.
Взять кассет с перевернутым.
Зачем...
Просто смотрите, вы говорите,
что сигнатура у этого шаблона, она какая?
Cons и...
О, все окей.
А...
С таким helper можно было
в качестве него type tuple
просто использовать.
Но я имел в виду что?
Прям вот так сделать.
Прям вот здесь pack передавать.
А вот left-right это не очень хорошо называть.
Head-tail фиксированная терминология,
которая там
во всей литературе примерно используется.
Tail.
А здесь просто передаем head
и тот же самый и.
Я бы это вот так назвал.
То есть мы аккумулируем какие-то типы.
В случае, когда ампак
такой вот такой,
то есть мы аккумулируем
какие-то типы.
В случае, когда ампак такой вот такой,
мы аккумулируем
nil, int...
Да, все нормально, нет.
Все нормально.
Мы аккумулируем типы в обычный pack.
Только они нааккумулировались,
возвращаем type tuple.
Проще? Проще.
Да, вот это все
я удаляю, оно уже не нужно.
Какой-то legacy.
И это кажется тоже.
Окей.
Я не могу прочитать,
что у вас здесь написано.
Ну окей,
но я прям рекомендую
попробовать дать ему шанс.
Трехэтажные шаблоны
требуют особого какого-то
подхода к жизни.
Так, и
int
double float.
Чтобы развернуть,
просто местами
дописываем
в конец
будет
float double int.
Почему это сработало?
Так,
мап заброшен
или у вас какой-то прогресс есть?
Возможно, вы на кого-то
в полу нажали и вас из-за этого
дергало.
Просто дергало.
Давайте мы просто
уже к концу...
Вы не обидитесь, если я просто расскажу,
как мап написать?
Мы можем сейчас свою организацию
попробовать снимать?
Да.
Ну если она большая,
то это точно что-то не так.
Что там...
Мап?
Мап это две специализации, все.
Применяет
метафункцию каждому элементу списка.
К нилу он не применяется.
Ну к нилу будет
тоже нил.
Ну да.
Но к пустому множеству
применить функцию, это
будет все еще пустое множество
по элементное применение функции.
А по элементным?
Да.
Ну,
я думаю,
что это все еще
будет пустое множество
по элементам.
Надеюсь.
Мы не работаем.
Сейчас.
Как закомпетить?
Так, это вы вставили, да?
Имплементация.
Так, ну,
что вы пытаетесь делать?
Пытаемся сделать...
получается
бабло от
функции.
Как бы да.
У вас два случая есть.
Либо список дали пустой, либо не пустой.
То, что у вас три
специализации, это странно.
Я говорю, что так не надо.
Ой, куда делось? Что произошло?
Нет, у вас
Мап импл есть главная специализация.
Вот частичная специализация номер 1,
частичная специализация номер 2.
Я говорю, что главную
просто надо убрать. Ой.
А вот так, просто
без всего оставить.
Вот тут typeName надо приписывать, да?
Плюсы странный язык.
Когда вы пишете шаблон два двуи точия
названия чего-то,
он думает, что это переменная или функция,
а то, что вы подразумеваете type,
вот надо явно было прописать.
Ошибка к импиляции только в этом месте
тут была.
Так, ну и два случая.
Либо в tail
есть cons от head и tail.
Тогда мы применяем
f к head, кладем в cons,
а tail запускаемся рекурсивно.
Либо у нас был нил.
Тогда и результат нил.
Должно
работать.
Почему не работает?
Потому что вы...
Короче, это очень смешно.
Что не хватает в этой строчке?
Type.
Все, теперь все работает.
То есть вы на самом деле справились, но вот это
легко забыть, type name и
type дописать и да.
Бывало у меня такое, что
я часто дебажил это и только потом
понял, что я дурак.
Так, ну что, кажется у нас вообще
все получилось сделать в целом.
Хоть как-то.
Так, ну что?
Давайте
поднимите руки, если вы все еще
редачите что-то по спискам типов.
Вот два человека точно
готовы еще
копаться с онпаком.
Все остальные, кажется, уже нет.
Что-то написали, если
хотели, если не хотели, то
ну очень жаль.
Да.
Length of tail.
Type of specialized
non-type template argument
depends on the template
параметр.
О,
потому что он так не умеет.
Он не может как бы
распарсить вот этот вот
процесс вычисления этого значения.
Вообще, конечно, мог бы он это понимать,
но кажется, так просто не умеет.
Нет, он вам
говорит что, что
он будет пытаться
ну вообще, что такое синтаксе значит?
Это в выведе, что первая
штука была tail, а второй
аргумент был равен длине
этого tail, но он
начинает пытаться этот tail выводить
оттуда тоже и как-то это сопоставлять,
и, кажется, сломается в этот момент.
Ну, то есть так нельзя, короче.
Да.
Специализироваться по номеру,
который длина списка,
это плохо.
Ребят, давайте общую мысль
скажу по поводу perf.
Вы же любите perf, вы на плюсах
пишете. Вот perf в compile
time он тоже важен.
В чем измеряется в compile time
perf? Ну вот в
run time в тактах процессора,
а в compile time, когда мы вот таким
занимаемся, на самом деле в
инстанциациях.
И вот все, что вы реализовали,
чем меньше инстанциация оно делает,
шаблонов разных, тем лучше.
Если вы там на каждой
если вы в своей рекурсии
на каждом уровне запускаете
шаблон length, то что будет?
Будет от
n квадрат инстанциаций.
Так tail у тебя разный на каждой
суффикс.
Но чтобы понять, какую специализацию
выбрать, надо и размер посчитать, правда?
Чтобы посчитать
размер этого списка, сколько нужно
операций? Линия.
Для следующего элемента сколько? Линия.
Хорошо, пойдем с конца.
Спасет ли ваше каширование?
Не знаю.
Давайте не думать, что есть каширование,
а просто пытаться писать
код с как можно меньше инстанциацией.
Кажется,
это просто такое, да, ладно,
ваша правда, здесь не будет квадрата,
здесь будет непонятно что,
возможно и линия.
Может и нет.
Ладно,
это все не важно, общая мысль понятна,
меньше инстанциаций лучше,
не надо делать там квадрат инстанциаций,
лучше линию, лучше еще
меньше, но меньше не получается
обычно.
Смотри, тут
про читаемости речи уже
не идет.
Никто сюда смотреть не должен.
Да, write only
code.
В моей
компании, я думаю, есть
максимум пара-тройка человек,
которые в таком готовы
разбираться, заниматься и смотреть,
что это такое.
Мне кажется, где угодно
будет максимум 1-2-3 человека,
которые таким заниматься любят.
Это не правильный вопрос,
но какие техники
компайл-тайм-учления
где можно выделить
компайл-тайм-учлений?
Ну компайл-тайм-учлений
на самом деле много где есть,
как бы...
Ну,
что?
Не знаю,
не знаю.
Перезагрузилась, все заработало.
В репетитории есть куча
ссылок, и в частности
они здесь, чтобы показать вам,
где это вообще может быть нужно.
Сейчас, где
ссылка?
Например, вот, LibUnifex,
замечательная библиотека, которая
в итоге была принята
в это,
ну в стандарт почти, скоро
будет принята.
Type-лист,
ой, Type-листы.
И пошло-поехало.
Ну, то есть,
просто в какой-то момент, делая сложные
библиотеки, внезапно оказывается,
что вот это вот нужно где-то, и начинается
цирк совсем вот этим вот.
Ну, тут не так много
операций, конечно, всегда стараются
минимизировать вот такой беспредел,
но оно бывает.
Стрим?
Ну,
это какой-то стрим
каких-то объектов, мы не знаем каких,
но можем что-то делать. Не знаю.
Ну, там просто все очень
шаблонное, а чтобы убрать шаблоны,
нужен TypeRager, который у нас будет в один
из следующих разов, поэтому пока
отложим.
Помимо Unifex,
кажется, в Function 2 что-то тоже было
близкое на списке типов,
только оно так не называется.
Ну, в целом, вот просто какую-то библиотеку
открыл, и здесь все обмазано каким-то
лютыми шаблонами, и
кажется, была
метапрога, прям метапрога,
что вычисление в Compile Time.
Ну,
ну,
ну,
ну,
Кажется,
вот это, примерно,
оно. Какие-то Function
Trades пошли.
View,
Invoker. Ну,
вот похоже, что это оно.
Так, в общем, любые сложные
библиотеки большие, где есть шаблоны,
если порыться, там ты найдешь
вычисление в Compile Time в том или ином
видео. Тут есть некоторое количество ссылок.
Кстати, не хватает ссылок. Надо в презентации на сегодня есть ссылка. Так,
давайте считать, что мы все закончили на сегодня с написанием кода. Как вам? И
чуть послушаем сказочек. Голова болит от кода? Давайте откроем окна и
проветрим. Голова перестанет болеть. Я отвечаю, что отдыхательный. А перерыв сделать надо.
Перерыв сделать надо. Давайте в 20 минут продолжим кусок, который успеем, я расскажу.
