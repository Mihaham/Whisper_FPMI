Вот, мы сегодня поговорим про теоремы Гёделя о неполноте.
Ну давайте я прям так напишу, теоремы Гёделя о неполноте.
Попробуем их как-нибудь доказать в какой-нибудь строгости.
Ну, история такая, в 1900 году математик Гильберт поставил 23 задачи,
которые на тот момент считал самыми интересными в математике,
которые на тот момент еще и не были решены.
Вот, с надеждой на то, что постепенно люди эти задачи научатся решать,
ну или как-то докажут, что они неразрешимы.
Вот, в 1930-м Гёдель одну из этих задач решил в тех терминах, что задач решить невозможно.
То есть, грубо говоря, Гильберт поставил задачу о том, что, ну вот,
аксиматика пиана, вот эта вот стандартная модель с плюсиком умножением индукции
и всякими там свойствами сложения умножения, вот, противоречива ли это аксиматика или нет.
То есть, можно ли вывести из нее противоречие или нет.
Вот и оказалось, что ответить на этот вопрос, ну скажем так, средствами самой рифметики невозможно.
Вот, и это, собственно, и есть результат Гёделя, что ответить утвердительно на вопрос
о том, противоречива или не противоречива эта вот арифметика пиана, ну, грубо говоря, невозможно.
По крайней мере, средствами самой рифметики.
Вот, ну давайте, это было в 1930-м году.
Давайте я скажу, что первая термина Гёделя о неполноте.
Ну, в первой постановке я ее сравниваю следующим образом.
Значит, любая достаточно мощная теория,
либо достаточно мощная, значит, в ней достаточно много, что можно уметь делать.
Там, не знаю, складывать, умножать, и достаточно сильные правила вывода,
типа там есть какая-нибудь индукция, есть модус понус, вместе все с чем-нибудь, ну и так далее.
То есть, достаточно много аспектов реальной математики затрагивать.
Так вот, любая такая теория, она либо неадекватна,
то есть, в ней можно вывести какое-то ложное утверждение.
Да, ну давайте так и напишу, можно вывести ложь.
Вот, либо неполна.
То есть, по крайней мере, какую-то истину нельзя вывести.
Полнота в обычном понимании теории, да?
Полнота это значит что?
Для любого утверждения либо утверждение, либо его отрицание выводимы.
Полнота значит, грубо говоря, что can't,
можно хотя бы про одно из двух доказать выводимость.
То есть, любое утверждение, либо само по себе доказуемо выводимо,
с отрицанием выводим, то есть выводится не phi. Вот, ну и тогда, соответственно, вот наша
арифметика пиана, она как бы, ну либо из нее выводится что-то, что мы не хотим, либо что-то не
выводится. Вот, ну давайте еще напишу теорема штрих. Это альтернативная формулировка, то же
самой теоремы. Напишу так, значит, если теория не противоречива, то в ней существуют утверждения,
которые не доказуемы и не опровержимы. Существуют утверждения, которые не доказуемы и не опровержимы.
Давайте так кратенько напишу, что не выводится phi и не выводится отрицание phi. То есть про какое-то
утверждение мы не можем сказать ни того, ни другого. Не выводимость phi, не выводимость
отрицания phi не имеет места. Ни то, ни то неверно. Вот, ну это как бы альтернативная формировка,
то же самые штуки. Когда-то удобно в таких темных, а что когда-то в таких. Так, ну и наконец вторая
теорема, которая, собственно, напрямую отвечает на вопрос Гильберта. Вторая теорема Гёделя.
Она говорит следующее, что, опять-таки, если теория не противоречива, то в ней
не доказуемы утверждения, формулирующие не противоречивость этой самой теории. То есть вот
мы рассматриваем какую-то теорию, и пусть мы в этой теории смогли написать утверждение,
ну то есть формулу, замкнутую формулу какую-то, которая сущностно означает, что теория не
противоречива. Так вот утверждается, что такая формула тогда не выводима. Так вот, если теория не
противоречива, то в ней не выводима формула, означающая ее непротиворечивость.
Вот, ну и, собственно, вот это прямой ответ на вопрос Гильберта, что, если у нас есть теория,
утверждение о том, что она не противоречива, можно как-то записать в терминах обычного вывода,
значит, что не существует последовательности выводов какой-то формулы ФИ и одновременно с этим
выводом какой-то формулы не ФИ. Противоречие, значит, выводится одновременно ФИ и не ФИ. Если
вот это записать как-то в терминах самой теории, самой арифметики, где мы живем, то доказать в
смысле вывести эту формулу невозможно. И как раз таким образом на вопрос Гильберта мы отвечаем,
что невозможно доказать, потому что формула о непротиворечивости не выводима. Ну вот,
как-то так. Да, хорошо. Вот, смотрите, вот эти штуки довольно какие-то абстрактные. Вот это еще
более-менее понятно, что средствами самой арифметики невозможно доказать, что она не
противоречива. Это вот это более-менее. Вот здесь довольно абстрактные утверждения про то,
что там что-то не выводится, грубо говоря. То есть какая-то истина не выводится, либо же
какое-то утверждение не доказуемо и не опровержимо. Но существуют на самом деле конкретные какие-то
примеры, конкретные примеры теорем, которые вообще говоря верны, но вот в аксиматике пиано не выводится.
Надо как-нибудь пример нарисуем. Пример так называемый теорема Гудстейна. Значит, это такая
теорема, которая вообще говоря истина, ну в смысле верна как математическое утверждение,
но при этом не выводима вот в аксиматике пиано. И это как раз иллюстрация того, что вот какую-то
истину нельзя вывести. То есть эта теорема утверждает, что в принципе она такая есть,
какая-то истина, довольно абстрактная. А здесь конкретный пример задачи, про которую можно
доказать, что в пиано она не выводится. То есть она сама по себе верна, но используя вот эти
элементарные средства арифметики, индукция, мудус понансы и правила вывода из логики в смысле
защитения предикатов и высказываний, она не выводится. Ну, теорема. Давайте рассмотрим сначала
последовательность Гудстейна. Она определяется следующим образом. Ну, для какого-то числа m.
Для числа m. Сначала мы m расписываем в двоичной системе числения. Давайте сразу на примере.
Ну 100 давайте возьмем. Это 64, плюс 32, плюс 4, плюс 2, вроде бы. Нет, плюс 4 просто. Правда? Дальше это
расписываю как степени двойки. Получается 2 в шестой, плюс 2 в пятой, плюс 2 в квадрате.
Вот. Дальше я хочу сделать то же самое вот с этими показателями экспоненты, до тех пор,
пока у меня не будут все числа в этой вот записи двойки и меньше. То есть я хочу добиться того,
чтобы все числа здесь написанные были не больше, чем два. Ну, соответственно, я сейчас шестерку
разложил в двоичной системе числения. Пятерку, ну и двойку. Что такое 6? Понятно. 4 плюс 2,
то есть 2 в квадрате, плюс 2 в первой. 2 в пятой, это 2 в квадрате, плюс 2 в нулевой. Вот. Ну и вот
здесь я напишу не 2 в квадрате, а 2 в степени, 2 в степени 1. То есть я хочу, чтобы показатели все
были, самые верхние показатели были меньше, чем основания степени. Вот. Ну и здесь я еще сверху
подставлю единичкой, чтобы было не 2, а 2 в степени 1. Это вроде не важно, но на всякий случай.
То есть я дораскладываю вот эту сумму до тех пор, пока все показатели не будут меньше, чем 2. Вот.
Что я делаю дальше? На первом шаге я всюду заменяю 2 на 3 и вычитаю 1. Давайте скажем,
что второй элемент последовательности, значит это следующий. Это замена всех 2 на 3 и в конце
надо сделать минус 1. То есть у меня m переходит в, ну вот здесь давайте я всюду вместо 2 напишу
3. То есть 3 в степени 3 в степени 3 в степени 1, плюс 3 в степени 1. Дальше здесь 3 в степени 3 в
степени 3 в степени 1, плюс 3 в степени 0, плюс 3 в степени 3 в степени 1 и минус 1. Вот. Ну чисто
механически двойка поменял на тройке, в конце вычел единичку. Это какое число? m штрих. Вот. Ну там
можно все это раскрыть и посчитать конкретные его значения. Дальше я делаю с m штрих примерно
тоже самое, только уже в системе осуществления с основанием 3. То есть я ее раскладываю по
степеням тройки. Вот. Разложил, потом сделал то же самое, только с четверкой. То есть все тройки
пройдет в четверке и вычел единичку. И так далее. Потом у меня получится новое число,
я разложу ее в четверичной системе осуществления. Опять все четверки заменил на пятерку и вычел
единичку. Ну и так далее. Понятно более-менее, что произошло. Вот. И так я делаю, делаю много-много
раз. Там 4 поменял на 5, 5 на 6, 6 на 7 и так далее. Так вот теорема утверждает, что какой бы вы
m изначально не взяли, эта последовательность рано или поздно занулиться. То есть будет все время 0,
0, 0, 0, 0, 0. Теорема, последовательность, кажется это называется финитно, то есть равна нулю с
какого-то момента. Вот. Ну тут как бы противоречие такое, да, ну не противоречие, а проблема,
что с одной стороны, когда вы увеличиваете показатель, точнее основание степени, то у вас
одноственное число растет, вы уменьшаете единичку и, возможно, эта единичка может так хорошо съесть
какую-то степень, что они потом будут, ну короче, ну короче там какой-то слагаем пропадет, да,
вот когда вы ищете единичку, и тогда там вот эти слагаемые будут медленнее расти, единичка их
рано или поздно всех съест. Ну как-то так. Вот. Ну и вот оказывается, что эта штука, она вот как раз
в аксиматике пиано недоказуема, недоказуема в аксиматике пиано, но вообще говоря верна, да, но истинна.
Вот значит, более точно она доказуема в аксиматике второго порядка, это когда мы можем ставить кванторы
не только по переменам, да, потому что сейчас вот во всем, и в вычислении предикатов, и в аксиматике
пиано, мы говорим, что у нас кванторы только по переменам, да, там существует п, для любого z и так
далее. Вот. А представьте себе, что мы еще можем ставить, скажем, кванторы по множествам или там по
функциям. Вот если разрешить себе такое делать, ну и там соответственно добавить, расширить
в сигнатуру правильным образом, чтобы множество можно было вообще определять, то эту штуку можно будет вывести.
Ну вот. Так, что еще хотел сказать. Наверное, для затравки все. Хорошо. Ну давайте, значит,
попробуем доказать теорему руками. С какой-то степенью подробности, доказать первой теоремы Гёделя.
Значит, смотрите, наверное пару недель назад вы что-то говорили про бета-функцию и про
кодирование смалина. Были такие слова. Вот. Ну, значит, пафос, во-первых, в том, что мы можем
кодировать конечные последовательности чисел числами, ну или там парами чисел, неважно, да,
то есть грубо говоря, сколь угодно длинную, но конечную последовательность можно закодировать там
маленьким числом объектов, двумя числами целыми, вот, натуральными. И плюс мы умеем кодировать числа
как строки, как битовые строки. Вот. Ну тогда давайте я скажу нагло, что можно написать вот в
арифметике пиано, можно написать следующую формулу, которая означала бы следующее. Значит,
subs от слова substitute x, y, z. Значит, формула, проверяющая, что x это номер формулы,
полученной при подстановке z в y. Вот. То есть я еще хочу научиться кодировать формулы числами,
да, то есть вот как бы здесь у меня x, y, z это какие-то числа, z я воспринимаю как аргумент формулы y,
при этом y у меня ассоциировано, ну y это число, но я ее ассоцирую с какой-то формулой, да, то есть я
ввожу какое-то там хорошее кодирование всех формул так, чтобы было однозначно, взаимно,
как бы легко декодируемое соответствие между числами и формулами, да, то есть мне нужно
какое-то соответствие между числами и формулами. Вот. Но представьте, что такое кодирование какое-то
есть, что у нас есть какая-то простая процедура перекодировки числа в формулу и наоборот. Значит,
тогда я беру формулу y, ну точнее число y, строю соответствующую формулу этому y и, ну я считаю
здесь, что y это формула одного аргумента с одним параметром. Вот я подставляю туда параметр z,
получается какая-то формула y от z. И дальше я вот это вот опять воспринимаю как формулу и говорю,
что x это ее номер. Ну и соответственно substitute проверяю, что x реально это номер формулы y от z.
Вот. Ну надо, наверное, пару слов сказать про то, как кодировать формулу числами, но, наверное,
не очень подробно. Значит, смотрите, у нас, вообще говоря, синтоксически довольно мало букв в нашем
алфавите, к которым мы записываем формулу. Да, у нас есть кванторы, у нас есть там всякие сложения,
умножения, у нас есть скобочки, у нас есть нолик, возможность единица, символ последователя,
равенство, логические связки. Может что-нибудь еще, ну короче, какой-то константный алфавит
служебных символов. Да. Ну нету, неважно, ну можно сказать, что нету. Не холодно и не жарко от этого.
Вот. Можно ввести, скажем так. Вот. А дальше у меня есть переменные. В переменах у меня
счетное количество, потому что формула может быть сколь угодно длинной, и мне может потребоваться
использование сколь угодно большого количества переменных. Вот. Поэтому я для унификации,
давайте буду считать, что у меня все переменные пронумерованы, и скажу, что у меня переменные это
всегда x0, x1, x2 и так далее. То есть в каждой формуле можно поставить только такие-то переменные,
которые занумерованы. Там не a, b, c, p, q и так далее, а вот x каким-то номером. Вот. Ну,
давайте сначала формулу научимся строкой кодировать, а потом строки мы уже умеем числами кодировать.
Ну вот как, например, такую штуку закодировать нулями единицами? Ну, в смысле, битовой строкой.
Не знаю, давайте напишу. Для любого y существует x такой, что, давайте не так,
сразу веду номера переменных. Для любого x0 существует x1, ну, например, такое, что x1 равно
s от x0. Ну, какое-то такое неинтересное утверждение, но все же. То есть как можно
было бы его закодировать нулями единицами, чтобы потом можно было однозначно декодировать?
Давайте подумаем.
Ну, давайте так, спрошу. Значит, я хочу действовать по тупому. Я хочу просто каждому символу из этой
формулы поставить соответствие какую-то бинарную строчку и дальше потом их разделить,
какими-то разделителями. Что сначала идет код первого символа, потом пробел в каком-то смысле,
потом код второго символа, пробел, код третьего символа и так далее. Вот вопрос,
как мне можно закодировать символы и пробелы так, чтобы я понимал, где символы, где пробел?
Давайте с этого начнем.
Ну, что-то такое я и сделаю. Да, вопрос, что за запрещенное сочетание?
Ага. Да, я понял. То есть, сейчас-сейчас. То есть, я говорю, 1.1 использовать нельзя,
а дальше любое описание разбивается на блоке. И вот когда вы встречаете 1.1, это пробел, да, типа.
Вот, а это уже описание. Да, ну давайте так. Я что-то другое в голове имел. Ну, давайте,
это неважно на самом деле, можно и так. Значит, смотрите, давайте скажем, что пробел, то есть
промежуток между символами, имеет код 1.1. Вот. А дальше все остальные символы нашего алфавита
закодированы какими-то строками, четные длины, и мы воспринимаем блоки по два символа,
как какие-то неделимые штуки, например, 0.0, 0.1 и 1.0. Такие неделимые блоки можем использовать.
Вот. Ну, тогда, например, можно все вот эти штуки закодировать какими-то вот такими вот блоками,
например, это, не знаю, там, 0.0.0.0.0.0. Здесь там несколько таких блоков, один такой блок,
ну и так далее. То есть, мы можем закодировать все вот эти вот служебные символы последовательностью
таких вот блоков. Вот. Ну, еще надо с переменами что-нибудь придумать. Ну, например, можно сказать так,
что переменная, это когда начинается с блока 1.0, а дальше, если я буду воспоминать вот это как 0,
а это как 1, то дальше идет просто бинарная запись индекса переменной. Бинарная запись индекса.
Вот в этом понимании, что 0 меняю на 0.0, а 1 на 0.1. Вот. Ну и здесь, соответственно,
давайте я тоже здесь скажу, что здесь нигде 1.0 не используется. То есть, чтобы 1.0 означало
начало переменной, мне нужно, чтобы здесь 1.0 нигде не использовалось. То есть, я здесь для
кодирования вот этих чуваков использую только вот эти вот два блока в любых комбинациях. А если
хочу ввести перемену, то я сначала ставлю идентификатор, что это идет номер переменной,
и затем просто пишу ее номер, раскладываю в двуечную систему члене ее индекс, считаю,
что нолики это 0.0, а 1 это 0.1 и записываю вот эти вот блоки, записываю индекс. Так. Что-то понятно?
Ну вот. Какое-то есть кодирование. Ну и все, а дальше мы строки же умеем в числа переводить.
Значит, формулы в числа тоже научились переводить. Но обратное переводение какое-то такое же.
Вот. Хорошо. Надо еще сказать, что вот это вот substitution тоже работает, что можно подставить
в формулу некое число и посчитать номер новой функции x. Ну понятно, что это такое. У меня есть
какая-то формула y. Точнее, число y. Я сначала начинаю это число воспринимать как формулу,
нахожу в ней все вхождения вот этого параметра z, и всюду вместо нее подставляю z,
а потом заново пересчитываю номер этой формулы x. Ну понятно, что это как бы алгоритмически можно
сделать. Ну так, сейчас давайте подумаем немножечко.
Это все детали на самом деле. Смотрите, мне будет достаточно, давайте так скажу, мне будет
достаточно жить в мире, что я сюда подставляю только правильные коды формул от одной переменной.
Вот. Я априори считаю, что это формула одной переменной, это число, которое подставляет в эту
формулу, а это код, результирующий формулу. Я хочу, чтобы substitution работал правильно на вот
таких вот штуках. Вот. Ну все, у меня есть формула, я ее декодирую, то есть число декодирую в формулу,
подставляю z и заново кодирую обратно. Утверждается, что все это можно осуществить средствами
арифметики. Потому что я умею работать со строками из-за кодирования Смалина. У меня есть строки
из миллионидничек, но там надо что-то подставить куда-то, проверить, что вот это вот здесь равно,
что вот это вот здесь вот здесь вот встречается, что в остальных местах строка такая же,
какая была раньше, ну и заново все это закодировать. Ну вот отсюда вроде как должно быть понятно,
что вот эта штука реально выражается средствами арифметики. Так, хорошо. Вот,
значит, это первая формула, которая нам нужна. Ну и вторая, давайте я ее назову provable от x.
Значит, это формула, тоже какая-то формула в арифметике, которая проверяет, что... Нет,
нет, не, пардон, сори, поторопился. Поторопился. С proof начну. Proof p, x. Значит, формула, проверяющая,
что p, это вывод x. Я хочу проверить, что p это вывод x. Ну вывод это что такое? Вывод всегда,
это просто последовательность формул. На формула первая форма, вторая, третья, четвертая и так
далее. Это вывод x, если x где-то здесь встречается. Вот. Ну, во-первых, как закодировать вывод? То есть,
вообще говоря, вывод это конечная последовательность формул, там, phi 0, phi 1 и так далее, phi,
какой-нибудь mt. Конечная последовательность формул. Но я конечную последовательность
кодирую с Тюмею. Это вот бета-функция Гедделя. Это конечная последовательность формул. Я ее кодирую
бета-функцией Гедделя. Вот. Ну а дальше надо проверить корректность вывода. То есть,
что каждая конкретная штука, каждая конкретная формула, либо аксиома, либо полученность
предыдущих по правилам modus ponens. Ну и плюс надо еще проверить, что x где-то здесь встречается. Ну,
это все какие-то тривиальные проверки. Надо проверить, что x равно кому-то из них. И, значит,
мне нужно, чтобы каждая формула была либо аксиома, либо полученно по правилам вывода. Но опять,
это какие-то синтетические проверки. Как проверить, что какая-то формула, это какая-то аксиома. Ну,
просто надо разобрать ее по кванторам, по переменным и понять правду, что тут написано,
вот ровно какая-то аксиома. Ну, не знаю, там, аксиома равенства какая-нибудь, рефлексивность
равенства же есть, наверное. Вот. Есть такая аксиома или нет? Ну, короче, неважно, я беру какую-то
аксиому, есть такая или нет, неважно, какую-то из аксиом беру, как проверить, что конкретная форма
имеет вот такой вид. Ну, понятно, вначале должна быть всеобщность, потом название первой переменой,
потом всеобщность названия второй, ну и дальше какая-то просто логическая связка, что вот так-то
должны соотноситься все символы в строке. Ну вот. Ну и с modus ponens тоже самое. Короче,
проще говоря, эта штука тоже выражается некой формулой внутри арифметики. Ну и, наконец,
я ввожу формулу доказуемости, это просто существует доказательство.
Ну, это, соответственно, формула, проверяющая выводимость x. Ну, выводимость, это просто по
определению, значит, существует вывод. Вот как раз вот существует какая-то по сравнению формула,
которая выводит x. Так, ну супер. Что дальше? Ну, вообще, она для чисел по умолчанию.
Да, да, да, да, да, да, да, все верно, все верно. Так, ну вот, и теперь, наконец, я рассмотрю такую формулу.
Вот. Значит, в качестве аргументов я буду подставлять формулу одной переменной, ну,
точнее, номера формул, которые зависят от одного параметра. Формула g от формулы y проверяет
следующее, что xyy это значит, что я в формулу подставляю ее номер, теперь я это обозвал
просто x. То есть, по сути, вот эта вот конструкция означает, что x это y от y. Как раз substitution так
работает. Я в формулу подставляю вот эту третью штуку. Ну и она при этом не доказуема.
Вот. И дальше я просто подставляю сюда ее свой номер и рассматриваю утверждение g от g.
То есть g это формула одной переменной с одним параметром, я подставляю в нее
саму себя. Вот такая эта замкнутая формула. Какая-то замкнутая формула. Давайте попробуем
проанализировать ее на истинность. Истинна она или нет. Ну, два варианта. Пусть она истинна. g от g истинна.
Это что значит? Вот я здесь вместо y подставляю g. Как раз x это g от g. Значит, тогда, если x это
g от g, то есть вот это вот все верно, по предположению g от g истинна, поэтому вот это вот все верно,
значит x не доказуема. Не доказуема, то есть неуводима. Понятно? Вот. Это значит неполнота
в нашей теории. То есть если штука истинна, то она неуводима. Есть какая-то истинная формула
неуводимая. Значит, неполнота. Вот. Ну, в противоположном случае, если g от g ложна,
что значит g от g ложна? Значит, если я подставлю в качестве x вот здесь вот как раз правильное
значение g от g, то для нее будет вот это вот неверно, то есть она будет provable. Да, если вот это
вот все движение с квантором неверно, ложно, значит, в частности для вот этого x, а вот это
вот будет неверно, значит, наоборот, верна выводимость, верна выводимость, provable от x.
Значит, выводимо-ложное утверждение, а это есть как раз g. Вот эта вот штука, это есть g от g.
То есть получается, что выводимо-ложное утверждение, давай так и напишу, что g от g выводимо,
вот это значит неадекватность. То есть у нас получилось вывести что-то что-то ложное,
что на самом деле неверно. Так, ну вот такое доказательство. Да, то есть по факту здесь,
смотрите, здесь по факту под капотом скрыто много всяких строковых операций над формулами,
что в формуле подстановки, что в формуле выводимости, собственно provable. А дальше
просто стандартный диагональный аргумент. Я рассматриваю какую-то формулу, подставляю
её саму в себя в качестве аргумента. Вот и получается, что эта штука не может быть ни
истинной, не ложной. Ну то есть как бы, если она истинна, то одно, если ложна, то другое.
Ну хорошо. Это по факту первая терема Гёделя была. Вот, можно тут же доказать её вот альтернативную
версию, которая называла теорема штрих. Да, то есть тут я доказал, что теорема либо неполна,
либо неадекватна. В теореме штрих я утверждал, что если теория не противоречива, тогда существуют
утверждения, которые нельзя, которые неуводимы и не опровержимы. Так, ну доказать давайте,
то же самое сделаем. Давайте посмотрим ту же самую ЖАДЖЕ и зададимся другим вопросом,
не истинна ли она, а выводима ли она. То есть то же самое, только вопрос выводима ли она. Но опять
это либо верно, либо неверно. Давайте скажем, что выводима. То есть пусть ЖАДЖЕ выводима в нашей
вот оксиматике пиана. Так, ну раз она выводима, значит вот существует такой х, равный ЖАДЖЕ,
такой что х не выводима. То есть если она выводима, то она не выводима. Противорячая, да?
ЖАДЖЕ, ЖАДЖЕ, ЖАДЖЕ. Так, сейчас я немножко позарепаю. Значит, если она выводима, да,
еще раз, если вот эта вот ЖАДЖЕ выводима, то есть вот здесь при постановке Y равная Ж,
если эта штука выводима, да, то, ну да, там какое-то правило Бернайса, воспользуемся.
Да, и как раз должен быть вот такой х, оно не выводимо. Окей, значит, что делать,
если она не выводима? О, наоборот, наоборот, наоборот. Сорри. Ну давайте, мне нужно доказать,
что ни она не выводима, ни ее отрицание не выводима. Значит, пусть отрицание ЖАДЖЕ выводима, вот так.
Да, то есть я утверждаю, что вот ФИ равное ЖАДЖЕ как раз и будет той нужной мне формуля,
равно. Да, то есть тут вопрос скорее не такой, выводима ли она, а выводима ли ФИ или отрицание
ФИ. Вот, ну как бы ЖАДЖЕ мы поняли, что выводима быть не может. Теперь давайте предположим,
что отрицание ЖАДЖЕ выводима. Тоже покажем, что такое быть не может. Пусть отрицание ЖАДЖЕ
выводима. Что тогда? Да, значит, что такое отрицание этой формулы? Это значит, что,
ну по сути, это значит, что для любого х либо он не равен, либо доказуем. Да, то есть частности
для такого х равного ЖАДЖЕ неверно не выводится. Сейчас, момент. А, тогда противоречие будет. Да,
значит, смотрите, вот здесь, вот отсюда следует, что вот в той формуле, если опять-таки взять х
равное ЖАДЖЕ, то получится, что она выводима. Да, но раз она выводима, то у нас получилась
противоречивая теория. Да, то есть мы предположили, что отрицание формулы и сама формула выводима
одновременно, а значит, наша теория противоречива. Все. Ну вот, значит, мы доказали, что вот эта
конкретная формула, мы ее ручками построили, вот эта конкретная формула сама по себе не выводима,
и неопровержима, то есть ее отрицание тоже не выводима. Ну вот. Так, все, формальная теория,
мы можем считать доказанная. Давайте попытаемся понять смысл вот этой формулы, что тут написано.
Я отвержаю, что вот эту формулу в коробочке, я ее вот так вот напишу. Давайте вот так вот напишу.
Вот это вот, по сути, это есть желчо. Я рассматриваю вот это утверждение,
что это утверждение говорит само про себя, вот я само вот это вот утверждение,
эта рамочка, она не доказуема, то есть не выводима. вот почему это g adje. Ну, по сути,
g adje как раз вот это и значит, что такое g adje. Это вот здесь вот х равно как раз g adje,
и оно не доказуемо то есть утверждение само про себя говорит, что оно само по себе не
недоказуемо, то есть неуводимо. Это вот как раз ровно вот это и значит, что утверждение само про
себя стоит и кричит «я недоказуемо». Вот. И мы показали, что это утверждение реально
недоказуемо. Ни оно, ни его отрицание недоказуемо. Вот. Прикольно, вроде. Так. Что-то еще хотел сказать тут.
Давайте, наверное, перерыв небольшой сделаем, потом продолжим. Так. Мы доказали первые теоремы Гёделя в
двух альтернативных постановках. Давайте вторую тоже быстренько докажем. Тоже так, на пальцах более
менее. Например, вторая была теорема про то, что утверждение о непротиворечивости неуводимо.
Давайте так это, так и сформулирую. Утверждение о непротиворечивости самой теории, самой теории
неуводимо. Вот. Так. Ну, во-первых, давайте вспомним, что такое непротиворечивость,
не противоречивость это значит, что нельзя вывести одновременно формулу ее отрицания. Вот.
Наверное, вы должны помнить, что если вдруг теория противоречива, то есть я смог из нее вывести и фи,
и нифи одновременно, то вообще из нее все что угодно уводимо. По крайней мере, любое противоречие
уводимо. То есть если она противоречива, то можно вывести всякое утверждение вместе с его отрицанием.
Давайте, например, для определенности считать, что вот это утверждение о непротиворечивости,
оно фрамилируется так. Не существует доказательства для утверждения того,
что 0 равно s от нуля. Ну, можно было просто написать not provable, да, наверное. Ну, или что-то
же самое, да. Просто not provable. Вот. Тут фигурные скобки я рисую в том смысле, что у меня же ведь
эта формула, а я формулы подставляю числа, ну, вот как бы вот это кодирование. Я взял номер этой
формулы, кодирование формулы. Ну, это какое-то очевидно неверное утверждение. Вот, в частности,
мне нужно доказать, что его нельзя вывести. Вот это утверждение, собственно, и означает
непротиворечивость. Потому что если вот это ложное утверждение не выводимо, то все остальные тоже.
И значит нельзя вывести одновременно фи и нефи. Так. То есть мы смогли сформулировать утверждение
о непротиворечивости в рамках самой теории. Давайте предположим, что оно выводимо.
Значит, предположим, что формула С выводимо. Да, давайте прям так и напишу. Выводимо С.
Значит, с другой стороны, у нас есть терема штрих, которая говорила, что если теория сама по себе
не противоречива, то есть если вот то С верно, если теория не противоречива, то какая-то конкретная
формула фи не выводится ни сама, ни ее отрицание не выводится. То есть я знаю следующее. Мы знаем,
терема штрих нам говорит следующее, что из истинности С следует факт невыводимости,
ну вот той самой фи в частности. Невыводимость фи и невыводимость отрицания фи тоже. Да, это я
просто как бы ослабил терему штрих. Я сказал, что фи невыводимо. Причем фи это вот, собственно,
ровно вот эта вот формула. Формула, говорящая про себя, что она невыводима. Ну вот здесь вот
хочется сказать примерно следующее. Смотрите, у нас выводимо С, и мы знаем, что верно вот это,
но отсюда как бы по моду споненсу следует, что невыводимо фи. Да, то есть здесь у нас есть вот
это, у нас есть посылка импликации, то у нас есть заключение. Здесь, строго говоря, нужно повозиться,
потому что мне нужна не просто истинность этого утверждения, но скорее выводимость этого утверждения.
Чтобы применять моду споненс, мне нужно, чтобы это тоже было выводимо. Но утверждаю, что это
можно сделать. Вот если здесь проанализировать доказательства, то на самом деле стука это
просто вывод в аксиоматике. То есть на самом деле вот здесь вот это не просто истина, это еще и
выводимо истина. На самом деле тут можно написать штопор, то есть это штука выводима. Ну и все,
а дальше по моду споненсу мы высекаем посылку, понимаем, что невыводимо фи. Так, а сейчас,
надо ли это вообще или нет? Ну да, надо. Не выводимо фи, но, извините, фи сама про себя говорит,
что я недоказуемый, то есть я невыводимо. Сейчас, вот так точнее. Сорри, я поторопился. Еще раз,
у нас есть штопор С, у нас есть штопор от теоремы штрих, что выводимо вот такая импликация. По моду
споненсу выводимо утверждение о том, что фи невыводимо. Вот так. То есть заключение
импликации. То есть у нас получается, что утверждение о том, что фи невыводимо, выводимо.
Но это противоречие с фи. То есть фи сама про себя говорит, что она невыводимо, но мы, получается,
поняли, что... Сейчас. Сложно. Самой же надо сюда подставить. Ну да. По факту мы доказали в
рамках теории, что фи невыводимо, но фи про себя утверждает, что она как раз недоказуема.
Ну не совсем. Сейчас. Скорее, фи говорит, что невыводимо фи. Скорее вот это вот фи.
Да? Что невыводимо само вот это утверждение. Скорее вот это вот фи. Вот. Ну и все. Получается
какое-то противоречие, что с одной стороны мы вывели фи. Да, вот просто мы вывели фи с одной
стороны. С другой стороны мы знаем, что он невыводимо. Противоречие. С другой стороны.
Значит, по теориями штрих, фи невыводимо. Противоречие. Так, ну вроде как-то так. Вот,
хорошо. Хорошо. Сейчас мы доказали? Ну, давайте тогда, у нас остается немножко времени, 15 минут.
На прошлой лекции вы по факту, смотрите, по факту я сейчас передоказал обе теоремы. И первых,
и вторые теоремы Геодора о неполноте. На самом деле, на прошлой лекции вы тоже это доказали
немножко другим способом. Вы через теория Мутарского и через строгость вложения в
арифметической иерархии. Значит, у вас было такое в прошлый раз, в теории Мутарского,
на всякий случай, быстренько формулирую, что множество арифметических истин не арифметично.
Вот, и для этого вы использовали арифметическую иерархию, то есть вы рассматривали такие вот
классы и доказали, что они все друг друга, то есть при движении слева направо у вас будет
строгое вложение. То есть это строго вложено сюда, строго вложено сюда, ну и так далее. То есть при
движении слева направо по этой цепочке у вас получается строго вложение сигов, в частности,
и пишет тоже. Было такое? Не помните. Ну сейчас я прям точно верифицирую это. Да. Да, хорошо. То есть
на самом деле эта теория из прошлого раза, она базируется на том, что по факту на строгости
вложений всех вот этих штук. Значит, на самом деле нам остается доказать, что сигмакатая строго
вложена в сигмака плюс первая для каждого к, для всех к. Давайте попробуем это сделать быстренько.
Значит, как я это буду делать? Значит, я покажу, что в каждом из классов, скажем,
сигмак и пика есть так называемое универсальное множество. Вот. Ну что такое универсальное
множество, скажем, w в классе сигмака? Во-первых, нужно, чтобы само это множество лежало в сигмаке.
Во-вторых, я буду воспринимать w как множество пар. Давайте там скажу, да, множество пар nх. Таких,
что какое-то условие верно. Само по себе это множество пар лежит в сигмаке. И во-вторых,
среди всех его сечений встречаются все возможные множества сигмака. Значит, скажу так, что для
любого w, лежащего в сигмаке, где w под множество натуральных чисел, существует такое конкретное n,
что w – это все такие х, что nх лежит в w. То есть, иными словами, это проекция w на первую
координату при n равна вот эта конкретная n. Проекция w на n. Вот. Универсальное множество в
классе – это множество пар, чисел, лежащие, во-первых, само по себе в сигмаке. Во-вторых,
среди всех возможных его сечений по первому аргументу, то есть среди всех возможных проекций
на первый аргумент при фиксации первого аргумента за n, среди всех возможных вот таких вот сечений
встречаются любые множества из сигмака. Ну, любые, как бы, те, которые являются под множество n,
то есть, которые не пары, а просто множество элементов. Вот все такие множества встречаются
как сечение w. Вот. Ну и, значит, теорема... Давайте лемма. Как-то пафосно слишком для теоремы.
Значит, лемма утверждает, что в обоих классах существует универсальное множество. Там для
любого k. В сигмаке и в пике существует универсальное множество. Вот. Ну и, во-вторых,
лемма 1, лемма 2. Универсальное множество в одном не льет и в другом. Скажем, универсальное множество
для сигмака не льет в пика. Вот. Значит, что отсюда следует? Есть какое-то множество лежащее в
сигмаке, но при этом не лежащее в пика. Это, по крайней мере, значит, что на каждом уровне
сигма и p отличны, что вот эти вот все штуки отличны друг от друга. Потому что есть универсальное
здесь, не лежащее здесь. Вот. И так далее. Ну да, да, да. Еще раз. Вот я знаю, что есть какое-то
множество тут, не лежащее тут. Наоборот, есть какой-то элемент тут, не лежащий здесь.
Но при этом мы знаем вложение вот такое. Нам знаем такое вложение, поэтому, в частности,
универсальное множество для p3 лежит в сигма 4, но не лежит в сигма 3. Получается, у меня вот эта
цепочка тоже строго вложена. Да, спасибо. Вот. Хорошо. Ну давайте докажем что-нибудь отсюда.
Давайте второй начнем, если ассенсия время первой тоже докажем.
Значит, здесь вроде должно быть просто. Вот пусть есть какое-то универсальное множество для сигмака,
давайте его как-нибудь назову. Пусть t это универсальное множество для сигмака. То есть это
какое-то множество пар. Там n запятая x таких, что выполняется какой-то сигмакапредикат.
Давайте рассмотрим диагональ. Пусть d это такие x, что пара xx лежит в t. Вот. Значит,
еще раз. Я взял универсальное для сигмака. Во-первых, давайте для рассуждения противного,
я предполагаю, что t еще лежит в пика. И дальше рассматриваю диагональ этого множества. То есть
все пары x, все x такие, что xx лежит в t. Ну тогда с одной стороны эта штука лежит в пика. Само
всего это множество d. Ну почему? Если t лежит в пика, то его по факту вот такая диагональ
тоже лежит в пика. Ну, совсем просто можно сказать, что d, m сводится к t. Причем с
сводимость тривиальным надо просто по x поставить пару x в tx. Так как раз понятно,
что x в d, если только если пара xx лежит в t. Вот такая m сводимость. Ну то есть понятно,
как это вычислимая тотальная функция. Мы свели одно к другому. Если это в пика, то это тоже в пика.
Одно из свойств арифметической иерархии, что если вы внутри класса свели, ну как бы,
m свели один из и к другому, и вот это лежит в пика, то это тоже лежит в пика. Вот. Хорошо.
Ну теперь надо дополнение рассмотреть. Тогда дополнение к d. Это что такое? Ну понятно,
такие x, что наоборот пара xx не лежит в t. Но с другой стороны понятно, что это в сигмак лежит,
потому что дополнение множества из пика. Что такое пика? Пика это значит, что множество задается
разрешимым предикатом, на который наверху для любого существует, для любого существует.
Потом здесь я рисую отрицание, то есть ставлю отрицание перед цепочкой кванторов,
проношу, получаю как раз утверждение типа сигма. Существует для любого, существует для любого.
То есть все кванторы поменялись на противоположные. Вот. Значит это лежит в сигмак. Ну и теперь я
утверждаю, что d с чертой, то есть с одной стороны d с чертой это какое-то множество из сигмака,
с другой стороны я утверждаю, что d' не является никаким сечением t, несмотря на то, что t универсально.
Ну потому что опять-таки обычный диагональный метод. Но d' не является сечением t. Потому что
если бы являлось, скажем, пусть d' это все такие x, что t, n, 0, x. От противного
иду пусть это какое-то сечение для какого-то конкретного n, 0. Ну и тогда надо видимо спросить
себя, лежит ли n, 0 в d с чертой. Вот и прийти к противоречию в любом случае.
Вот. Такая идея.
Ну и давайте лему 1 попробуем быстренькой тогда. Доказать? Ну давайте начнем с сигма 1.
Да, так и есть, так и есть. У меня остается вот эта предпосылка, что k хотя бы 1.
Вот. Значит, какое можно выбрать универсальное множество в сигма 1? Ну сигма 1, давайте напомню,
это что такое? Это такие множества, для которых вопрос принадлежности к А равносилен тому,
что... Вот это вот верно. Где r какой-то разрешимый предикад. Разрешимый предикад,
да. Вычислимый. Вот. То есть по факту это в точности перечислимые множества. То есть как раз
здесь лежат такие множества, для которых существует... Ну по факту это проекция, опять-таки.
А это проекция вот этой r на первую координату. Вот. Ну в другом понимании, ну неважно, короче. Вот.
Короче, сигма 1 перечислимая. Ну какое универсальное перечислимое множество можно взять? А? Ну да,
да, да, да. Можно просто взять, значит, язык nx, что n-ная машина останавливается на входе x.
Останавливается на входе x. Вот. То есть с одной стороны это множество перечислимо,
потому что можно запускать машину на входах и посмотреть, остановиться. Ну то есть как бы дожидаться
момента, когда она остановится. Если остановилась, то выводите nx. Вот. С другой стороны, каждое сечение,
да, каждое сечение, это область определения какой-то вычислимой функции. И мы как раз знаем,
что перечислимое то же самое, что область определения вычислимых функций. Получается, что эта
штука универсальная в сигма 1. Вот. Ну и теперь давайте на сигма 2 посмотрим. Дальше все будет
аналогично. Сигма 2. Какое здесь универсальное? Ну, во-первых, давайте посмотрим, что такое а лежит
в сигма 2. Да, я понимаю, что там лежат такие x, для которых верна вот такая вот цепочка кванторов,
наоборот. Так, sorry, с P2, с P2 неудобнее будет рассуждать. Значит, x в a, если и только если,
для любого y существует z такое, что rx, yx, z. Да, это определение P2. То есть опять-таки r это
какой-то разрешимый предикат. x в a, если и только если, вот такая цепочка кванторов выполняется.
Вот. Ну а дальше, смотрите, я вот это вот могу обозвать, то есть у меня на самом деле вот здесь
написано, при фиксированном x множество тех y, на которых вот это верно, это какое-то перечислимое
множество. Множество тех y, для которых существует z такое, что rx, yx, z, это перечислимое. Ну просто
вот по определению. Вот существует z такое, что. А значит, эта штука может быть получена как
сечение универсального σ1 множества. Давайте я его напишу. Здесь мне будет удобно говорить,
что у меня есть универсальное перечислимое множество троек n, x, y. Вот. Ну в том же
самом смысле, что само это множество троек лежит в σ1 и среди сечений по каждому конкретному n,
множество пара x, y, z задает все возможные перечислимые множество пар. Вот. Ну и тогда вот эта
вот штука, это что такое? Это какое-то сечение вот того множества u при некотором конкретном n.
Да, я там давайте так напишу, сечение. Сейчас. Нет, не буду сечением писать. Просто, да, это все такие y,
что верен предикат u, n, x, y. Для кого-то конкретного n. Давайте я ноль напишу. Вот. То есть еще раз,
вот эта вот штука, это какой-то σ1 предикат. σ1 предикат я могу заменить на сечение универсального
множества. Вот я это здесь и сделал. То есть как раз это сечение при фиксированном x,
при фиксированном n, 0. Вот. Ну а дальше, чтобы проверить, что x лежит ва, мне нужно проверить,
что вот для этого конкретного n, 0 верно, что для любого y, y лежит в этом множестве. Так,
надо взять предикат. Давайте я его напишу. Вот. Значит дальше, я формально вожу вот такой
предикат. p от n, x равно для любого y верно вот это вот u от n, x. u от n, x, y. Я формально вот так вот
ввел. Дальше понятно, что x, y, если только если для некоторого n, 0, p от n, 0, x. То есть как раз
для некоторого n, 0, для любого y верно вот это вот. Потому что вот тут вот это написано. Как
раз мне нужно, чтобы для любого y выполнялось вот это вот условие. Для некоторого n, 0. Ну и все,
получается, что как раз вот это вот u, это будет мое универсальное p2 множество. Да, значит,
с одной стороны. Сейчас, одну секунду. Нет, нет, это p, p, p, p. Да, все. Теперь, значит,
я рассматриваю множество. Давайте скажем w. Это такие пары n, x, что верно, p от n, x. Вот.
Тогда это есть как раз универсальное p2 множество. Универсальное для p2. Потому что,
с одной стороны, в качестве его сечения есть всевозможные p2 функции, p2 множество. Потому что
для любого p2 множества существует конкретное сечение такое что. Ну вот понятно. Как раз все
возможные его сечения это всевозможные p2 множество. С другой стороны, почему оно само по себе p2?
Ну потому что такое p. Это значит для любого y от n, x, y, где вот эта штука по факту это
σ1 предикат. То есть для любого атом существует. Поэтому само по себе оно тоже лежит в p2.
Вот. Ну и все. И получается, что мы построили универсальное для p2. Легко доказать,
что дополнение будет универсальным для σ2. Ну и вообще всегда σ от p отличается взятием
дополнения. Тогда дополнение вот к этому w будет универсальным в σ2. Ну и так далее. Можно
рассматривать там, скажем, σ3. Там будет на один квантор больше. Но опять-таки последний квантор
сжирается и превращается в σ1 утверждение. И мы вот это вот преобразуем, вот это вот все,
преобразуем с помощью универсального множества в какую-то проекцию. И, грубо говоря, вот этот
квантор вытаскиваем наружу. Потому что вот это вот превращается в, точнее, в сечение по какому-то
ноль. Вот. И эта ноль у меня будет как аргумент функции внешней. Вот. И тем самым как раз получится,
что для каждого там σ или π будет универсальная своя. Вот. Ну тогда я первую-вторую лему доказали.
И значит вот теория Мутарского, соответственно, которая базировалась, как бы, одно из доказательств,
который базируется на строгости вложения всех этих классов, тоже доказали, считайте.
Ну вот тогда все. Спасибо.
