Нет, ну да, ладно, честно скажу. Сейчас, конечно, оставшись в лекции, мы будем рассматривать вещи гораздо более простые, чем какие-то там это преобразования фурье.
Тоже, в общем-то, вещь не сложная, но...
Нет, начнём мы не с неё, хотя, да, динамику мы пообсуждаем.
Но там просто тут тоже будьте аккуратны. Начнём мы, конечно, с вещей, которые вы без сомнения знаете, то есть, скорее так, может так сказать, повторение, и так это сведение в общую кучу получится.
Угадай, чего.
Нет.
Ну вот, но скажем так, скажем так, крутые вещи, причём такого продвинутого уровня там тоже есть, поэтому не засыпайте.
Но начнём мы всё-таки ещё с пару вещей. Начнём мы с одной вещи, которая, на самом деле, стоило бы рассказывать, конечно, два-три раза назад.
Это вещь про disjoint sparse table.
Вот.
Что-то мы её не рассмотрели.
Вот.
Ну, суть просто следующая.
Что вот мы с вами, то есть у нас вот была задача, есть статический массив, и мы хотим въём на подотресках делать какую-то операцию.
Но возникает маленькая, но если это сумма, то мы умеем это делать частичными суммами, да.
Но у нас, если это минимум, то умеем делать sparse table.
Но, к сожалению, с минимумом нам пришлось жёстко воспользоваться тем, что функция, во-первых, идёт патентно, а во-вторых, коммутативно.
А вот, например, если, как всегда, про функцию мы знаем, то только то, что она ассоциативна.
Ну, там, предложение каких-нибудь матриц необязательно невыражённых там и так далее.
То есть тогда у нас эта идепатентность уже не прокатит.
Вот на наше счастье оказывается, оказывается, что всё-таки можно уметь считать её на подотреске с предподсчётом за n log n
и за o от единицы потом ответа на запрос.
Ну то есть идея, ну как бы структура обычно так и известна под названием disjoint sparse table.
Вот она, sparse table.
Ну, просто понятно, суть будет заключаться в том, что если раньше мы находили два отрезка длины 2 в степени n,
где эти отрезки покрывали и нам плевать на перекрытие, потому что идепатентность и коммутативность,
то в данном случае нам бы желательно эти отрезки находить как-нибудь по-другому.
Вот, понимаете, да?
Вот, так что вот такая вот идея. Что же делать?
Значит как же нам это сделать?
Значит смотрите, мы будем делать следующее.
Во-первых, то есть у нас будет что-то похожее, такое похожее на встречное дерево Фенрика.
А именно, мы, значит, посчитаем, так сказать, t1, значит, да.
Вот, в идее хотелось бы так. То есть мы хотим для каждого числа х посчитать вот такой массив.
Смотрите.
То есть, а именно, то есть, помним, у каждого х, вот, помним, если у нас х записать в двоичной системе счисления,
1, 0, 0, там 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, да.
Ну ладно, лучше 0, 0, вот так.
Да, пожалуй, пусть так будет.
То замечаем, что, мы помним, что у нас есть такая штука, как f от x.
Что такое f от x? Напомню, что это то же самое, что х, просто мы обнулили самый последний единичный бит.
А все остальное прям копия.
Вот, прям копия, копия, копия, копия, копия, копия, копия, копия.
Вот.
Так вот, у меня возникает хитрая идея.
Я хочу для каждого х и для каждого числа х', которое лежит на полуинтервале от f от x до x,
хранить вот этот вот it от x3 до x.
Вот, ну вот так это можно написать.
Вот.
Ну it, то есть вот мы теперь говорим, что мы на подотреске хотим брать операцию it, как всегда.
Это f от x? Ну вот от x до x? Это я?
Нет, еще круче. Внимание.
Я хочу для каждого числа между f от x и x, я хочу уметь вычислять, уметь вычислять it чисел от x3 до x.
То есть фактически это типа полуинтервалы.
То есть я хочу ее уметь считать прямо в явном виде хранить от x1 до x, от x-x2 до x, от x-x3 до x.
От x и так далее от f от x до x.
Понятно, да?
Да, нет, наверное все нормально.
Вот.
Ну в принципе для каждого х завести такой вектор в общем-то несложно, правда?
Но брать его можно за o длины этих векторов, согласны? Суммарной длины.
Ну если мы конечно поверим, что операция it ассоциативная.
Впрочем, есть подозрение, что если it не ассоциативно, то как это все насчитывать, это еще вообще очень большой вопрос.
Вот.
Хорошо.
Правда теперь возникает вопрос, а как вы думаете, какова суммарная длина всех этих векторов?
Ну да.
Почему?
Потому что можно вместо x и y картиночки все будет понятно.
Какие картиночки?
Ну, смотри, давай возьмем весь массив, поделим его пополам.
Так.
И от центра мы насчитаем нашу функцию влево и вправо.
А вправо мы пока ничего не насчитываем.
А нам не нравится.
Ну это потом, мы пока про это говорим.
Так, давай это не передергивай сразу.
Мы считаем только влево, да?
Да, мы считаем только влево.
Ну хорошо, мы считаем только влево.
Так.
А по сути, что произойдет дальше?
Мы на всех вот таких отрезках считаем функцию влево, здесь тоже влево, вот до сюда.
Вот здесь вроде ничего не посчитаем, я не помню.
Ну, что-то посчитаем, более мелкие отрезки мы посчитаем.
А вот это зачем?
Ну, более мелкие вот эти вот, вот это вот.
Да.
Там же тоже будут эти там, есть тут 4 нолика, тут все будет.
Да, окей, да.
А дальше мы посчитаем вот на, вот здесь стрелочка тоже до конца.
Да.
Потом вот здесь мы посчитаем, нет, вот здесь мы посчитаем.
Ну и где-то...
Вот сюда, вот здесь посчитаем вот сюда.
Ага.
Вот здесь посчитаем вот сюда.
И вот здесь посчитаем вот сюда.
Ну и так далее.
Ну да.
Что произошло, на самом деле, еще раз.
Да, погоди.
Мы просто не смотрели, где вот эти f лежат.
Вместо того, чтобы думать о функциях влево чисел.
Так, то понятно.
Так, ладно, всем понятно, что произошло?
Ну мало ли.
Нет, ну мало ли, может я тут рассказываю эту штуку,
которую на самом деле все уже давно знают.
Все-таки это не многомерная ff тоже все-таки, да.
Но смотрите, давайте сейчас я попробую нарисовать то же самое,
но на реальных примерах битчиков.
Вот.
Значит, смотрите, как у нас устроено это все.
Вот давайте я нарисую, как всегда, 16 чисел.
Вот в двоичном представлении я их даже нарисую.
Понадобится.
Я знаю.
Так, 0 1 0 0, 0 1 0 1, значит 0 1 1 0, 0 1 1 1, значит 1 0 0 0,
1 0 0 1, 1 0 1 0, 1 0 1 1, 1 1 0 0, 1 1 0 1, 1 1 0, 1 1 1,
О, четко.
Вот.
Так.
Как это называется?
Так.
Вот.
Так.
Ну а теперь давайте считать.
Значит, где же мы от каких иксов что насчитываем?
Ну, действительно, начнем со следующего.
Вот начнем с серединки.
Так, ну, ну да.
Ну, хотя, если у нас x до n включительно,
то на самом деле мы начинаем с того,
что вот для этого вот 1 0 0 1 мы насчитываем аж на целый,
то есть эти прям все суффиксы вот аж на вот такие.
Видите, да?
Ну, потому что x мы перебираем от 1 до n.
Как всегда.
Как в Фенвике мы это делали.
Та переча, та переча.
Значит, дальше.
Теперь рассмотрим числа, у которой заканчиваются на 3 нолика.
Вот.
Ну, как бы да, их у нас тут целое одно, новое, да,
и мы для него вот такую штуку насчитываем.
А здесь таких чисел нет.
Ну, здесь есть число с 4 ноликами, но для него мы уже насчитали.
Видите, да?
Теперь давайте рассмотрим числа с ровно двумя ноликами.
Их у нас два вот как раз в середине.
Вот даже вот так надо скорее посчитать.
Вот так отделить.
То есть их у нас вот у нас тут два отрезка, их у нас ровно два.
То есть вот туточки.
И вот туточки.
Вот.
Вот.
То есть наглядник.
А теперь рассмотрим числа с нолик, у которых нолик один.
Секунду.
Скопочка.
Что?
Скопочку вот такую.
Она задевает 0.1.0.0.
То есть она пишет сейчас.
Сейчас где она?
Скопочке ставить лучше, наверное...
По-моему, как-то все нормально, да.
Скопочка стоит под числом, потому что оно-то само не включительно.
Скопочка самая левая изнарисована.
Скопочка стоит под числом 0.1.0.0.
Да.
Его не включительно, но все предыдущие 4 насчитаны.
Да.
И это ваше.
Вот я так нарисую.
Теперь берем.
Теперь на всех этих отрезках там есть по числу, у которых 1 нолик.
Да, вот он.
Да.
Вот.
Что тут еще делим.
Вот получается еще под отрезок.
То есть видите оно вот.
То есть как бы ровно половину получается по крови.
Вот так получается.
Ага.
Ага.
И ага.
Вот так вот.
Вот.
Ну, на самом деле еще заметим, что вот эти числа нам придется...
То есть когда уже 0 ноликов, это нам придется тоже вот как-то вот так вот хранить, видимо.
Вот.
То есть там вот так.
Там вот так тоже.
Ну, как всегда, видите.
То есть просто половиночку рисуем.
Все очень просто.
Вот.
Замечаем, что суммарный размер такой таблицы у нас сколько получается.
Ну да.
То есть в переводе говоря n лог n.
Это же n пополам лог n, если быть точнее.
Вот.
Потому что логарифум уровней на каждом получается ровно n пополам значений.
На 7 степень двойки, конечно.
Вот.
Ну.
Но, конечно же, нам потребуется не только функция f, но и не менее любимая нами функция g.
Ну, потому что они все равно...
Мы с Тамарой ходим парой.
Мы с Тамарой f и g.
Вот.
Значит, теперь у нас идея такая.
Теперь я хочу для каждого x уметь считать сумму не только от f от x до x, но и от x до g от x.
А точнее, как всегда, то есть это x.
Значит, для любого x' значит, насчитать сумму от...
На этот раз...
Ну ладно, давайте так.
Вот, если совсем быть точнее.
Вот, хочется насчитывать сумму от x до x'.
Вот.
Ну, то есть фактически те же самые полуинтервалы, только в другую сторону.
Вот.
А теперь давайте вспомним, а что такое g?
Ну, g это немножко наоборот.
То есть, смотрите, если можно сказать, что, допустим, число...
Смотрите.
Вот так.
Можно ли так сказать?
А, ведь, смотрите, можно еще одна интерпретация функции f и g.
Заметим, что пусть у нас у x-а сколько-то последних нулей.
Там 4 штуки.
Так вот, заметим, что f от x это ближайшее снизу число, у которого не меньше, чем 4 нуля.
А g от x это будет ближайшее сверху число, у которого не меньше, чем 4 нуля.
То есть, заметим, что это, кстати, совпадает с нашим предыдущим...
Ну вот, с нашим предыдущим определением.
Вот.
Сейчас, если на ближайший взгляд там единичку...
Да, да, да.
То есть, видите, да, тут, конечно, хитрее.
Тут понятно, тут прям надо тут единичку прибавить, поэтому тут 1, 0, 0, 0, 0.
И вот тут 0, 0, 0, 0.
Да.
Видите, да?
Ну, по большому счету, на самом деле, занимаемся мы следующим.
То есть, если вот рассматривать, что означают эти полуинтервалы, то у нас есть...
То, смотрите, то в случае функции g мы просто говорим, что я эти нолики хочу уметь заполнять чем угодно
и до этого момента включительно считать сумму.
Если говорите, включительно, правда?
Вот.
Ну а здесь, наоборот, на самом деле, если брать от этого включительно, то надо из x-а вычесть единичку,
сказать, что у меня в конце есть блок единичек, и я этот блок единичек могу заменять на что угодно
и до этого момента считать сумму.
Вот.
Но можно заметить, что в данном случае тогда...
То есть, это тоже будет n пополам log n.
Более того, на самом деле сейчас мы опять получим тут прям полные деревоотресков.
Ну, для нуля, конечно, мы так делать не будем, но смотрите тут как.
Какие тут отрезки в эту сторону?
Я их попробую вот так вот нарисовать.
Нет.
Да, жалко, что у меня нет цветного мела.
Но теперь смотрите.
То есть, опять же, рассмотрим число с тремя нулями.
И до ближайшего числа с тремя нулями тут, очевидно, симметрично этот полуинтервал и загоняем.
Тут он как бы вот тут заканчивался, тут он идет.
Оп.
Мы начинали не включительно x, а включительно j отец.
Видимо зря.
Нет, понимаете.
Ну, тут такой момент, смотрите.
Что на самом деле как бы сумму-то я считаю до x' не включительно.
Поэтому я мог бы это сформулировать так.
А, все, да, конечно. Да-да-да.
Да, то есть я могу еще по-другому сказать.
Я могу сказать, что давайте я x' буду выбирать на полуинтервале, но вот тут тогда буду брать сумму на подотрески.
Так что по количеству, в общем-то, суть одна.
Сейчас, а там вот такие круглые?
Нет, нет, это-то остается.
Вы выбирали x' на вот таком центральном пуске, а считали потом от x' включительно до x' не включительно.
Да.
То есть, вы видите, вот так.
Ну да. То есть, видите, да.
То есть, видите, это так удобно.
То есть, когда мы идем вправо, мы x' включаем.
А когда идем влево, то x' не включаем.
Поэтому получается, что вот когда у нас тут вот с тремя нулями, получается, что мы ушли влево и вправо, и размах крыла получился одинаковый.
Ну, собственно, так оно все...
Ну, собственно, в самых интересных для нас точках так и будет.
Потому что когда мы возьмем вот число с двумя нулями в конце, то тоже будет на самом деле вот такая ситуация.
Вот такая.
И вот здесь тоже вот такая.
Ты сейчас двигаешь эту скобочку прямо, но на самом деле она остается влево.
Да, да, да.
Но это и так просто же.
То есть, у нас здесь трески не должны быть другого цвета.
Да.
Ну, как вы помните, да, вообще-то мы подобное дерево уже даже рисовали, чтобы увидеть, что, оказывается, мы не так далеко ушли от дерева отрезка во встречном дереве Фенрика, как окажется.
То есть, по большому счету, мы ровно на те же отрезках храним там суммы.
Просто они хранятся в других местах и перебираются другим образом.
Ну, в общем-то, от самих по себе таких отрезков мы никуда не ушли.
То есть, вот такая красота там.
Какая-то вот так.
Что-то тут не то.
Ну ладно.
Так.
А, видимо...
А, видимо, я тут с самого начала вот этот забыл нарисовать.
Это был типа красный, а вот эти вот уже...
Вот.
Так что вот такая красота.
Ну, теперь, at least in principle, как говорится.
То есть, теперь наша цель какая?
Вот если нас очень слезно попросили найти на подотреске от L включительно до...
Вот L включительно, а до R не включительно полуинтервал, да?
То нам теперь надо просто разбить этот полуинтервал на два полуинтервала, которые у нас тут встречаются.
Вот.
А, давайте...
А, я придумал.
Знаете, что надо делать?
Надо тут стрелочки нарисовать.
Да, именно.
Во.
Во.
То есть, значение, на самом деле, не только на больших интервалах рассчитано.
Если был голод, мы, в основном, считали значение от 4-го интервала.
Да.
А здесь мы выловили, типа, отом памяти.
Да.
А здесь мы насчитали каждую точку.
Ну да.
То есть, это как бы да, больше смахивает на там полный протокол мерш сорта скорее, да.
Ну так, по структуре памяти.
Чем надеюсь?
Ну, тут среднее такое.
Ну, с другой стороны, да.
То есть, как бы понятно, что полный протокол мерш сорта и делая с ним там что-нибудь,
это, конечно, не новость в уголовной хронике.
То есть, как бы да.
Каждый из слов вспомнит дело Дольского в Одессе или Дюрье в Мемпелье.
Так.
Вот.
Вот.
Значит, теперь.
Что нам это дает?
Но тогда заметим, что если LR устроены так, что L находится там, допустим, в левой половине массива,
а R в правой, может быть, даже на границе,
то я утверждаю, что тогда мы найдем ответ в завод единицы.
Вот.
То есть, просто, если где угодно слева, потому что ответ тут,
то есть, допустим, L где-нибудь вот тут, а тут R где-нибудь вот тут,
то тогда мы просто берем вот эту середину.
Так сказать, становимся, как у нас утром сегодня была дуэль.
Ну, вот она.
То есть, товарищ, один уходит влево, в сторону F, другой в сторону G.
Оба также свою сумму находят.
Собственно, они их объединяют и радуются.
Вот.
Но что делать, если LR оказались в одной половине, ну, скажем, в правой?
Ну, в общем-то, то же самое.
То же самое.
Тоже можно найти прям два полуинтервала,
собственно, которые пощитны, которые в совокупности составляют наш полуинтервал.
Ну, понятно, здесь полуинтервал, тут граница вот такая, ну и так далее.
В общем, к чему это нас приводит?
То есть, получается, по крайней мере, свести задачу к поиску двух полуинтервалов,
на которых мы уже все насчитали, это мы уже поняли.
Единственное, да, единственное, конечно, что пока мы это делаем,
конечно, буквально чуть-чуть залог очень сильно.
Поэтому нам теперь жутко интересно.
Вот даны LR, а как найти, ну, хотя бы на каком уровне нам вообще работать?
Ну, если мы найдем на каком уровне.
Ну, то есть так, то есть, по сути, что нам надо?
То есть, по сути, вот что нам надо?
Нам надо идти на каком уровне работать и на какой конкретно дуэль расходиться, правда?
Ну, с другой стороны, что это нас приводит?
Ну, давай постепенно.
И с картинки мы видим следующее, что нам, на самом деле, у нас есть числа LR.
И нам надо найти число с максимальным количеством нулей между ними,
которое там, то есть, с максимальным числом нулей в конце, которое лежит в этом полуинтервале, правда?
Вот. Ну, ладно, тут, конечно, оговорочка, может быть, небольшая оговорочка,
что тут, допустим, там L может быть равно нулю.
Ну, думается, что если мы там посчитаем ответ не только для суффиксов,
но и для префиксов заранее, ничего страшного не будет, правда?
Вот. Поэтому без особого ограничения обществе можно считать, что L больше нуля.
Топереча.
Ну, тогда, получается, я утверждаю, что нам надо просто найти число с максимальным числом нулей в конце
между L включительно и R не включительно.
Как же это сделать?
Ну, давайте внимательно посмотрим.
Раз от L включительно, до R не включительно, значит, L больше R.
Значит, давайте думать, вот у нас как устроены L и R.
Они устроены, значит, они до какого-то момента, они радостно одинаковые, одинаковые, одинаковые, единаковые,
одинаковые, одинаковые, одинаковые, одинаковые, одинаковые, одинаковые, одинаковые
Давайте подальше. Призошла неожиданность, l оказалось равно 0, r оказалось равно 1.
Видите, да? Вот так.
А дальше что-то происходит.
Что могло произойти?
Тут дальше находится какое-то число и тут какое-то число, правда?
Давайте я r чуть пониже нарисую.
Тут что-то и тут что-то, да?
Тогда смотрите, какой тонкий момент.
Я могу рассмотреть такое специальное число x между ними, которое равно...
Вот смотрите, до этого момента они совпадают.
Здесь будет 1, а справа будет 0, 0, 0, 0, 0, 0 до упора.
Почему я их нарисовал именно так?
Потому что, как легко убедиться, l меньше x, меньше уровр x, согласны?
Но чем этот x приятен?
Этот x, обратите внимание, он приятен тем, что у нас посчитаны...
Легко по определению видеть, что более того, что l приятны тем, что l больше либо равно, чем f от x, обратите внимание.
Потому что f от x это то же самое, как l, только если бы тут были полностью нули.
А l тут могут быть нули, могут быть и нет, поэтому я тут больше либо равно пишу.
Но с другой стороны про x...
Но с другой стороны я могу теперь сказать, что r теперь заведомо строго меньше, чем g от x, согласны?
Ну что это значит?
Это значит, что...
У меня тут ведро.
Это значит, что тогда суммы на подотресках l от x в эту сторону и от x до r в эту сторону, да, возможно пустой, но неважно, у меня посчитаны.
Вот они у меня посчитаны, конкретно вот для этого x.
И все, что мне остается, это теперь просто за o от единицы каким-то образом из l и r этот x выкопать.
А теперь внимательно посмотрите на картинку и скажите мне, как же мне по l и r за o от единицы, ну ладно, может быть с каким-то предподсчетом, выкопать этот x?
От l до r.
От l или от r.
От f, от f.
Да, но надо заметить, то есть действительно, если мы возьмем l к 40 r, то мы замечаем, что до вот этого подран заставы тут будут 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и 0 и...
впервые в этом месте будет единица, а тут черт знает что, но нам это не важно,
потому что теперь, чтобы сделать x, я должен просто все справа от этой единицы
занулить, но у нас по большому счету теперь, то есть действительно, то есть все, что мне
нужно, это сказать, что у меня l, то есть сказать так,
так что мне нужно вот просто взять вот эту, то есть найти, фактически все,
что мне нужно, это найти в каком разряде это произошло, а в lxor r это самый старший
разряд, поэтому все, что мне нужно, по идее, это для всех чисел от 0 до 2 в
степени n-1, ну может быть там до 2 в степени n, насчитать, где находится
самый старший единичный разряд, но мы это можем без труда сделать, ну там за
линию там пробежаться, или там может быть еще там крейнбитовая магия, которая
правда, это не за от единицы будет делать, но все равно, ну то есть там что-то, вот,
ну не знаю, насколько мне известно, built-in popcount, он считает количество
единичных бит, но не за от единицы, а за от реального количества единичных бит,
ну ускоряет этот, прям зовут единицы, ну может быть, а ну окей, если есть, то есть,
но правда у меня, ну вот философский вопрос, то это уже да, но не важно,
математически не важно, практически, как бы, все зависит от того, будете вы тратить
время на то, чтобы это писать или не будете, знаете, вот на контесте, как бы, знаете,
тоже принципиальный вопрос, можете ли вы реализовать так, чтобы бинпоиск свести
к ловербаунду, или будете писать бинпоиск сами, математически без разницы, а на
контесте, как бы, вопрос, это будете ли вы писать еще 10 минут, причем с риском
допустить ошибку или не будете, ой, но это отдельная песня, конечно, вот, так вот,
ну хорошо, ладно, допустим, мы этот, там, сделали предподсчет, этот бит нашли,
но тогда возникает такой, действительно, внимание вопрос, как же мне тогда найти сам
х, я же изначально только или х знаю, х я не знаю, но я знаю этот бит, да, но теперь я вот знаю
этот бит, но если я, я могу тогда возвести 2 в степень этого бита, ну в смысле, там,
один хрест-хрест этот бит, тоже, слава богу, за вот единицы можно сделать предподсчетом, вот,
но и теперь у меня, теперь, теперь тогда, чтобы получить х, я должен просто сказать r
and вот эта вот степень гойки, вот, ну правда, это, правда, это приведет, получится у меня, правда,
но та же самая степень гойки, то есть, за нулятся не только вот эти, вот эти штуки, но и вот это все за нулиться,
чего, да, поэтому с and тут, ну, and хочется, потому что, потому что хочется какие-то биты за нулить,
а так же, да, просто мы, да, мы же имеем право это, это все тупо сдвинуть на это количество бита,
потом сдвинуть обратно, да, типа одно и то же, но как бы там уже нули, то есть фокус такой, знаете, да,
то есть, знаете, берем, берем там часы и галстук у случайного посетителя, там кладем ящик,
там задвигаем, выдвигаем его, там нет, вот, ну, знаете, там потом вы там достаете пистолет,
стреляете в воздух, там сверху прилетает ящик с криками безобразия, буду жаловаться в ВЦСПС,
там, значит, появляется директор, там, учреждение, называют там все в шоке, там, вообще, там, ну вот,
ну и потом, потом только в конце уже за кулисами к вам подходит, ой, а что с галстуком-то делать,
а, что он вам тычит, вот тут галстук, вот часы, все, они так залезают себе в карман, а, ну да, вот, так,
ну, смотрели этот фильм, естественно, да, ой, зря, как классика быстро устаревает, вот посмотрите,
как Навальную ночь, не пошелеете, правда, да, то есть, я понимаю, да, 56-й год, но правда, знаете,
тут единственное, только желательно это смотреть до конца, потому что я понимаю, что сначала вам
может показаться скучно, но, давайте, я вас убираю, это временно, так вот, ну, соответственно,
вот этот фокус мы, значит, туда-сюда задвинули, значит, получилось, вот, ну, собственно, и все,
что, так, что вопрос возьми, нет вопроса, не в векторах, а все в массиве, нет, на самом деле,
нет, на самом деле, вполне можно, просто, вот, не случайно я их нарисовал именно так, потому что на
самом деле все вот эти значения можно банально написать в соответствующем, потому что, смотрите,
каждый полуинтервал, да, он задается х-трихом, правда, но, смотрите, на каждом уровне у меня каждый х-трих
встречается ровно один раз, либо в отрезке налево, в полуинтервале налево, либо в полуинтервале
направо, правда, особенно, ну, особенно, знаете, если мы, да, если мы тут все-таки воспользуемся вот этой интерпретацией,
тогда для каждого х-триха у нас тогда на каждом уровне ровно одно значение, поэтому тогда это можно писать
все не в векторах, а просто завести реально двумерный массив, то есть, там, количество уровней на, и для каждого х-триха
прям вот это аккуратно насчитывать, то есть, в результате по факту, то есть, там, ответ у вас, там, то есть, ответ
у вас будет действительно что-то типа, значит, значение таблички в точке L умножить на значение в точке R-1,
вот, R-1, то есть, единственное только вопрос будет, вот это все, это вам нужно только понять, на каком уровне вы находитесь,
то есть, по факту, по LxorR и вот этому старшему биту вы просто понимаете, на каком уровне вы живете, и все, и просто на этом уровне,
просто берете, типа, вот это значение, вот это значение, там, смерзили, возрадовались, так что, вот такая вот.
Какие-то беды будут?
Почему? Какие беды будут?
У нас же иногда, что будет, если R, вот, на эдикативе, например, будет 1, 0, 0, 0?
А, ну да, действительно, сейчас.
Может, все и хорошо, но и не нормально?
Пу-пу-пу-пу.
Ну, на самом деле, да, нет.
На самом деле, это говорит о том, что, на самом деле, просто вот эта часть, она может оказаться выверженной, на самом деле.
У нас нет значения, где она вывержена.
Да, такого значения у нас нет, да, поэтому, к сожалению, вам придется, возможно, написать, что если х у вас случайно оказался равен r,
то тогда вы не делаете latter, it,Let, это, а просто возвращаете ответ, как ответ вот это.
Вот. Ну, знаете, это уже по мелочи.
Просто если этой мелочи хочется писать не так, а рекурсивно, рекурсивно это долго.
Ну, да. Ну, долго. Влагорифа. Чаще всего вам хватит.
Чаще всего нам этого хватит.
Ну да. Ну да, потому что, нет, все зависит от того, как бы, чего у вас больше, запросов или элементов.
Потому что, как бы, смотрите, потому что, например, предплата, то есть, действительно, давайте думать.
То есть, всегда надо так проводить анализ.
Что предположим, что у вас массив на n элементов и q запросов.
Да?
Тогда, если вы делаете вот это, там, любой, любой версия спортстейпла,
тогда у вас получается n log n предподсчета плюс q.
Есть еще одна панкость.
Давай считать, что у нас операция работает не за ввод линьицы, а за некоторая оотка.
Ну, на самом деле, с точки зрения того, что выбирать, суть одна.
Потому что, как бы, и там, и там, фактически, я, вот эти вот операции, они оценивают в том числе,
и сколько операций мне, сколько распыть мне надо вывести.
Поэтому от того, что я, что тут, что в дереве отрезков, я тупо накадом нажаю.
Так вот.
Значит, тут n log n плюс q.
А если, это вот s t, если.
А если я делаю D.O.
Черт, тоже Sergen3, ничего себе.
Вот.
То тогда, смотрите, дерево отрезков я могу построить для заданного массива за o от n.
Вот.
Но только после этого тогда мне придется тут q log n разстрадать.
То есть, заметим, что вообще говоря, если q оказалось меньше, чем n log n, то дерево отрезков начинает выигрывать.
Правда, другое дело, что если q меньше, ой, и запросы статические, то вообще можно задуматься о тем, чтобы привести сжатие координат.
И тогда там вообще потом после этого развлекаться за q log q.
Но это уже другая песня.
Вот.
А так, но так, в принципе, вот.
То есть, если q, то есть, кто меньше?
Если q меньше, чем n, то D.O. начинает выигрывать.
Если q, если q больше, то, но, то, конечно же, sports table выигрывает.
Если q примерно одинаковое, то там уже надо константу реально верить.
Потому что в общем-то у sports table даже нельзя сказать, что там константа вообще называется прям мегамла.
Ну вот, поэтому тут балансик.
Ну да, да.
Ну вот, да.
То есть, как сказать, уже чемпионат по дополнительным показателям уже начинается.
Вот это вот.
Так что вот такая вот красота у нас получилась.
Но тем не менее структура красивая.
Собственно, структура милая.
Так что здорово.
Так, ну все.
Так, есть ли тут какие-то вопросы?
Нет.
Ну хорошо.
Ладно, тогда пойдем кое-куда еще.
Ладно, давайте это.
Это безобразие мы уберем.
Вот.
Ну а теперь мы все-таки перейдем к маленькому приятному методу четырех русских.
Да.
Ну.
Нет.
В таком виде нет.
Ну я боюсь, когда как он начнет изменяться, так я боюсь, там как бы все логарифмы повылезают сразу.
Нет, в принципе, отдельный вопрос.
Да, можно ли сделать так, чтобы изменение было за логарифом, а нахождение там суммы на подотресках в точь, за лот единицы?
Про это же нет.
Почему?
А кость как-то, вроде бы, перейдет в статус.
Нет, нельзя.
Ну да.
Изменяется, что вы вроде, то ли N точек, то ли N точек?
Нет, вопрос даже.
Ну конкретно тут да, потому что тут придется много чего менять, потому что если у вас там был большой полуинтервал, на нем в середине точка поменял, значит тут все надо пересчитывать.
Если вы умеете это, то есть если это, скажем, какая-нибудь сумма на подотреске, или там SparkStable это на минимум, а числа только уменьшаются, то тогда, конечно, вы тут за логарифом все пересчитать можете.
А как у тебя запросы?
Так же.
А, черт.
Ну...
Ну ладно, там можно...
Нет, ну там, я не знаю, если на каждом полуинтервале хранить стэк...
А, черт, тогда это в запросах, поиск по стэку.
Ну да, вряд ли.
Нет, ну если честно, знаете, то есть есть аргумент за то, что, скорее всего, это нельзя в принципе подобные вещи делать.
Аргумент следующий. Давайте мы будем искать минимум на отрезке, и при этом, кстати, на отрезке у нас сидят те самые камешки, которые мы только сравнивать умеем.
Тогда у меня почему-то... тогда вот возникает как-то жуткое подозрение, что... ну, конечно, что если мы будем менять какие-то элементы, то запрос-то так как бы дешевле, чем за логарифом, и ответ не получим.
Ну вот, потому что ответы у нас... ну вот, потому что ответ у нас... там вариантов ответа много.
Ну то есть нет, аргумент, конечно, сомнительный, потому что мало ли какой предподсчет мы там сделали.
Потому что теоретически, если мы бы сделали предподсчет, скажем, на полную таблицу, прям вообще на квадратическую таблицу, то мы бы могли за 1 ответы давать.
Поэтому там сомнительно. То есть даже там, если у нас предподсчет уже там за какой-нибудь логариф, то, может быть, и можно как-то.
Вот. Ну ладно, давайте тогда перейдем к методу четырех русских.
Значит, теперь мы все-таки вернемся к задаче на минимум, потому что основная у нас цель... основная у нас цель.
Это такая, дан статический массив, и мы хотим искать минимум на отрезке за от 1.
Ага, за от Кирмана. И в оффлайне запросы, да?
Ну не важно, ну вот.
Нет, мы круче. Мы хотим не только минимум на отрезке за от единицы, да.
То есть да, минимум на отрезке за от единицы умеет Спарстейбл, это да.
Но Спарстейбл требует предподсчета за илоген.
А мы сделаем себе круче, мы хотим предподсчет за отн.
То есть мы хотим прям идеальный алгоритм.
Нет, это называется алгоритм Фарах Колтон Бендера.
Да, Фарах Колтон Бендер, две фамилии.
Ну, Фарах Колтон и Бендер. Двойная фамилия.
Нет, это не русские. Дело в том, что в основе этого алгоритма лежит метод четырех русских.
Нет, там реально четыре русских. Динец, Кронрат, Фараджа, Фарлазаров.
Да, Ефим, да. Ой, да, там хит сезона.
Потому что какие-то алгоритмы с одной стороны Железного Занаса, потом с другой стороны Динец.
Потом начинаются две теоремы Корзанова еще.
Ну, Корзанов точно русский.
Нет, убавили то, что хит сезона, а потом в итоге какие-то чемпионские алгоритмы начинают предлагать такой...
American scientist, American.
Эндрю Векчислав Голдберг.
Эндрю Векчислав Голдберг. American scientist.
Да, в Бикипедии реально так написано.
Хотя, я не знаю. Судя по комментариям Стамкевича, судя по всему, ему довелось с ним пообщаться и на русском языке, в принципе.
Так, ну, собственно, с творчеством этих всех замечательных личностей мы обязательно познакомимся не позже, чем в начале третьего семестра.
Хотя, такими темпами, может, и во втором уже доживем, я не знаю.
Ну, а, собственно, к чему и нет, на самом деле.
Так вот, ладно, если конкретно минимум, мы хотим сделать предподсчет за отн и за единицу.
Ну, как это делать?
Ну, и сейчас я, конечно, сделаю такую более длинную операцию.
Ну, хотя, возможно, там кто-то и знает, что есть более короткая, но, на самом деле, тут, конечно, длинная цепочка.
Дело в том, что такая задача статика РМК.
Давай, или даже вот написать оффлайн.
Нет, главное не оффлайн.
Да, все-таки статика РМК.
Дело в том, что она сводится к задаче статик LCA.
Вот, да, мы не знаем, что такое граф.
Но, все-таки, здесь мы предположим, что вы все-таки знаете.
Значит, смотрите.
Ну, что такое задача LCA?
Дано подвешенное дерево.
Вот.
Дано нам подвешенное дерево.
Там для каждой вершины, скажем, известен его предок, например.
Ну, понятно, там можно потолок и так далее.
И вот нам с вами очень-очень-очень-очень хочется искать LCA.
Что такое LCA?
Это наименьший общий предок.
То есть, для вот этой вершины этой я хочу найти самый глубокого их общего предка.
В данном случае это будет вот он.
Понимаете, да?
Ну, сталкивались, я думаю, скорее всего, с таким объектом.
Вы его там умеете тоже сводить с помощью там, к тому же спортстейблу.
Или там двоичные подъемы еще есть.
Вот. То есть, для самой задачи LCA может они не нужны.
Но если вы там хотите искать, скажем, минимум на пути за логарифом,
то на самом деле двоичные подъемы вас могут очень выручить.
Как говорится, без этих ваших там...
Как вы их там называете?
Это heavy light decomposition.
Ну вот, тем более, что они за лог квадрат.
Вот.
Итак, смотрите.
Так вот, значит, план дальше.
Так вот, мы сведем...
Построим просто дерево и будем сводить задачу к LCA.
Задачу LCA в свою очередь.
Мы тоже сведем к задаче RMQ.
Ну да.
Да-да-да.
Этот факт мы отправляем в какой-то золотой зал славы.
Просто и садим его рядом с утверждением о том, что mergesort работает за OATM.
А потом просто важно дорисовываем тут три важных символа.
Плюс-минус один.
Дело в том, что я буду сводить не ко всем массивам,
а к массивам, у которых любые два соседних элемента отличаются на единичку.
И вот уже на эту задачу мы будем натравливать метод четырехрусских.
Ну вот там эти вот.
Вот такой план.
Ну спрашивайте, как же это сделать?
Ну вот.
А вы видите, достаточно просто.
Да, мы с вами не знаем, что такое LCA, но что такое декартовое дерево, мы знаем?
Проходили.
Так вот.
Давайте объявим эту штуку приоритетами
и построим на этих приоритетах декартовое дерево по неявному ключу.
Прям вот чтобы только вот этот неявный ключ должен быть вот такой.
Вы же помните, мы же умеем по заданным приоритетам
и отсортированным ключам строить дерево за лигию, правда?
Умеем?
Что, не обсуждали?
Ну давайте обсудим, хорошо.
Значит, смотрите.
Итак, задача.
Так, ну во-первых, давайте сразу обсудим,
значит, почему то, что мы сейчас построим, это то, что нам надо.
Потому что рассмотрим вершинку с минимальным приоритетом.
Давайте объявим ее корнем.
То, что справа будет находиться в правом по дереве, то, что слева в левом.
Тогда заметим, что для всех подотресков, в которые она попадает,
значит, минимум будет именно она, но и LCA будет именно она, правда?
Поэтому, то есть, если ответ это она, то вот, значит, тут все в порядке.
Значит, дальше строим рекурсивно.
Рекурсивно, значит, берем вот на этих подотресках тоже минимум.
И опять же, то есть, строим тут вот опять, то есть, вот повешаем так,
и тут получается то, что слева, тут уже только пятерка осталась, да?
И тут, соответственно, тоже какое-то под дерево.
Теперь заметим, что если у вас в этом подотреске минимум это,
то есть, он лежит вот слева отсюда и захватывает эту вершину,
то минимум она и LCA будет тоже она.
Понимаете, да?
Если мы построили такое дерево.
Да, если мы вот построили такое дерево.
Да, я сейчас объясняю, что если мы сейчас реально построим такое дикартовое дерево
с такими приоритетами, то как бы будет то, что надо.
То есть, на нем мы будем строить потом LCA.
Вот строили когда-нибудь LCA на дикартовом дереве?
Так что вот.
Так, ну ладно, понятно ли, что, короче, надо дикартовое дерево построить,
и сведение сделано.
Ну вот теперь тогда, раз уж действительно так, кстати, произошло,
давайте еще раз, давайте попробуем его построить.
Строить мы его будем следующим образом.
Так.
О, слушайте, а тут, кстати, да, ну вот, кстати, неплохой пример получился.
Значит, будем строить слева-направо.
Значит, ну начнем с пятачка.
Дальше мы видим единичку.
Дальше мы видим единичку.
Ну, единичка меньше пяти, тут пока все понятно.
Дальше.
Следующая вершина по приоритету больше, чем вот эта.
Поэтому ее спокойно можно тут справа подвесить.
Ну, каждую вершину мы должны где-то справа подвесить, да?
Вот в идеале эту вершину тоже бы хотели прям за вот единица подвесить сюда.
Но мы и не можем этого сделать, потому что у нее приоритет меньше.
Так, тогда мы отправляемся к ее родителю
и понимаем, что у этого родителя приоритет еще меньше.
Поэтому это нам дает возможность подвесить двоечку просто прямо к нему,
а к этой двоечке слева подвесить вот это тут все.
Ну, тут пока одна вершина, но соответственно.
Видите, да?
Теперь видим троечку.
Мы видим, что мы сразу ее справа можем подвесить, потому что приоритет больше, чем то, что тут было справа.
Поэтому прям вешаем сначала троечку, а потом и восьмерочку.
А теперь нам пришла четверочка.
Смотрите, сюда мы ее подвесить пока не можем, потому что четверочка тут меньше.
Вот.
А сюда можем.
Ну, так давайте так и сделаем.
Сюда четверочка, сюда восьмерочку.
Такой более интересный случай.
Такой самый показательный.
Единичку сюда мы подвесить не можем.
И сюда подвесить не можем.
Я даже, даже можно это все затирать.
И сюда подвесить не можем.
А сюда, ну, так и быть пусть можем.
Тогда смотрите, мы вешаем единицу вот сюда,
а слева от нее вешаем вот все вот это под дерево.
Да, пожалуй, вот это не надо стирать.
Три, четыре.
А, пардон.
Да, да, да, да, пардон, пардон, пардон.
Конечно.
Вот.
То есть прям вот взяли и под дерево подвесили.
То есть смотрите, что у нас происходит.
На каждом шаге у нас есть дерево,
которое, с нашей точки зрения, устроено вот таким образом.
То есть вот такая цепочка,
правый путь, на котором висят какие-то левые деревья.
Да, левые в хорошем смысле этого слова.
Вот.
Но нас в первую очередь правый путь интересует.
Значит, как мы тогда это работаем?
Тогда мы идем, внимание, это важно, снизу вверх
и находим вот этот наш приоритет,
между какими двумя его можно вот так вот вставить.
Находим и, соответственно, вставляем.
То есть тут прям левое, объявляем, что все вот это, это его левое под деревом.
Чем приятен это?
Ну, конечно же, может так случиться, что у него приоритет меньше всех,
но тогда, значит, мы объявляем эту вершину новым корнем.
И все вот это, все слева к нему вешаем.
К чему это нас приводит?
Приводит нас к тому, что, да, мы построили такое дикартовое дерево,
но заметим, что этот алгоритм работает за от n.
Почему он работает за от n?
Да просто потому, что если мы прошлись тут вверх за от, допустим, 4,
то у нас вот этот правый путь уменьшился на 3 и прибавился на 1.
Ну, можно вообще себе этого воображать, знаете, что,
то есть как бы если вы не хотите для вершины хранить родителей,
то вы можете просто эти вершины хранить в стеке.
И если вам вы справа вершину подвесить не можете,
значит вы эту вершину из стека удаляете.
И дальше тогда уже стандартная логика в духе,
что каждая вершина может быть удалена из стека не более чем один раз,
а всего вы туда добавляете n вершин.
То есть следовательно, суммарно этот алгоритм работает за от n.
Вот, понятна технология?
Да.
Такая вот. То есть вот таким вот образом мы свели статик рамку к статику лца
и еще из-за от нас научились строить дикартовое дерево.
Так, тут еще вопрос есть?
А мы не дошли еще.
Это общий план всего этого фара Холтон Бендера.
Вот.
Потому что на самом деле все, что мы пока сделали, это сделали вот это сведение.
То есть вот это сведение, ну и просто решение статика лца,
то есть это просто приятно, что если у вас есть подвешенное дерево,
вы можете сделать за от n предподсчет и потом за от единицы лца искать.
То есть это само по себе интересная задача уже.
Но как же нам теперь вот у произвольного лца,
да, уже у произвольного дерева искать лца, то есть сводить к рамку?
Ну, как говорят это?
Как это говорили? Делаем, как всегда.
Как говорят в войску? Делаем, как всегда, в войско хора.
Мы сдаемся, в утилении, это пластинка.
Так.
А идея такая.
Запустим еще один алгоритм, который мы не знаем.
Но я поверю, что вы сталкивались с такой аббревиатурой, как DFS.
Да, возможно даже на вступительной работе.
Вот.
Ну, идея такая.
Запускаем DFS и выписываем все вершины, которые видим.
Во-первых, мы выписываем сам корень.
Вот, смотрите, давайте я вершину тут буковками помечу.
Там a, b, c, d, e, f, g, там допустим h, i, j, k, l, m, n, o, p, q, r.
S, t, u, там u, v, w, x, y, z.
Да ладно.
Ну ладно.
Фи.
Так, а это что за бухло вообще?
Так.
Нет, мы уже теперь сахарку сводим.
Это вообще произвольная идея.
Абсолютно произвольная, да, но мы ее тоже умеем.
Ладно, пусть это будет альфа.
Ну вот, маленький алфавит этот.
Где?
Вот это?
А-а.
Ой, ладно.
Умлаут так умлаут.
Так.
Так вот, значит, смотрите, выписываем вершины.
Но, во-первых, сначала мы выписываем вершину a,
а после этого начинаем выписывать все вершины, которые видим.
Причем когда идем по ребру вниз и когда идем по ребру вверх.
Получается примерно следующее безобразие.
Значит k, значит потом j, потом p, потом идем назад j.
Значит тут l, j, phi, j, l, j, phi, j.
Значит возвращаемся тут k, m, k.
Возвращаемся в a.
Идем дальше тут, что там, e, h, там альфа.
Там e, h, альфа, там тут c, альфа, r, альфа, q, альфа, да.
Вот это все.
С альфа, r, альфа, q, альфа.
Куда-то там возвращаемся, но я думаю...
Куда мы там возвращаемся?
Там h, но я думаю, ладно, дальше, я думаю, дописывать нет смысла,
а я думаю, вы так поняли уже.
Как искать lца на этом все?
Так вот, дело в том, что мы выписываем не только сами вершины,
но мысленно мы еще выписываем их глубины.
Ну да, ну вот как-то так.
Вот обратите внимание, вот кстати и выплыл массивчик,
у которого любые два соседних отличаются ровно на единичку.
Выплыл, вот выплыл родимый.
So, what's next?
А next будет такой.
Значит смотрите.
Если мы хотим найти lца между вершиной p и вершиной n, допустим.
Я просто найду первое вхождение каждой из этих вершин в наш массив.
Ну я их могу заранее предподсчитать, правда?
Я возьму их под отрезок.
Я на этом под отрезке найду вершину с минимальной высотой.
Отверждение.
Это она.
Это lца.
Вот. Почему так?
Ну доказательство очень простое.
Потому что рассмотрим у двух вершин lца.
То есть заметьте, вот у меня есть вершина, допустим, x, вершина y,
и есть вот эта вот lца от x и y, которую мы обозначим как z.
Тогда смотрите.
Тогда у нас в этом массиве мы тут шли, шли, шли, шли, шли, шли,
и пришли в вершину z, наконец.
Она у нас впервые произошла, да?
Заметьте, что у нас будет происходить.
Мы сначала пойдем в какое-то ее поддерево, потом вернемся в z.
Потом еще походим по поддереву, вернемся в z.
Еще подходим в z, и на это прям спотиним навсегда.
Вот что произойдет, если у z 3 поддерева.
Ну, если 4, то тут будет 4 отрезка, ну вы поняли, в принципе, да?
Но теперь идея такая.
Ну вот, что самое важное для нас, это то, что все вхождения x и y,
как вершин, находящиеся в поддереве z, будут где-то здесь.
В чем более того, скорее всего, x и y, ну мы сейчас не можем для простоты
рассматривать случаи, когда x является предком y, да?
Ну вот, но если x и y не являются друг другом предка,
то значит x лежит в одном поддереве, а y в другом.
Ну там вот y где-нибудь вот здесь, а x допустим здесь, да?
Но тогда смотрите какая ситуация.
Заметим, что на этом отрезке все глубины не меньше, чем глубина z,
но так как x лежат в разных поддеревях, то между ними z будет обязательно.
То есть, следовательно, этот минимум будет равен именно глубине z,
а такой глубиной в этом месте обладает токана.
Да, я не знаю, это выдали вам минимум вот конкретно этот или конкретно этот,
но вершина тут будет все равно одна и та же.
То есть вот таким образом получается, на этом массиве нам надо просто находить
минимум на отрезке, но правда с оговоркой, что как бы этот минимум
вам надо не сам минимум находить, а где он находится.
То есть вот таким вот образом мы свели задачу к статик РМО.
Вот, понятно?
Таким образом, вот эту штуку мы тоже...
Да, именно важно, что плюс-минус один.
Ну вот, мы подошли к самому интересному.
Вот, так и хочется сказать теперь.
А теперь, дамы и господа, вот, собственно, самое интересное.
Жалко, они с нами нету.
Вот, поэтому, товарищи, значит, смотрите.
Можно.
Господа друг другу на вы общаются.
Так что тут максимум, товарищи.
Как это? А по-хорошему, по сону.
Хотя, действительно, да.
Как это можно? Теперь, господа, самый очаровательный алгоритм,
который встречался в жизни.
Или по сону смотреть прикол.
Ладно, значит, в любой терминологии, значит, суть алгоритма остается неизменной,
как есть суть метода.
Итак, значит, у нас есть мистический массив.
Вот, его можно изобразить вот таким вот веселым графиком.
Вот.
Ну вот.
А теперь, значит, смотрите.
Оставная фишка методы четырехрусских звучит так.
Зафиксируем k, которое выберем позже.
То есть у нас есть какая-то, ну, так сказать, константа.
Но она, правда, будет зависеть от n.
Но у нас и массив. У нас задан массив размера n.
Выберем какое-нибудь число k. Зафиксируем его.
И разделим отрезки, да, разделим массив на подотрески размера k.
Вот.
О, ладно, даже.
Ладно, давайте так это объединим это с корневухой и назовем эту длину отрезка.
Это k-бубен.
Что?
Бубен.
Почему?
Откуда корневуха?
Нет, тут не корневуха, а бубен.
Но там тоже, знаете, разделяют на блоки размера, который потом подгоняется, да?
Ну вот, поэтому часто оно бывает называется бубен, бывает называется блок.
Но чаще вот бубен, потому что там шаман бубен технологии, вот это вот все.
Так вот.
Итак, разделяем отрезки массив на отрезки размера бубен.
Бубен.
Всего отрезков, как вы уже догадались, n поделить на бубен.
Да, вы когда-нибудь делили n на бубен?
Вот, ну и так далее.
Так вот, в чем у меня идея?
Ну, во-первых, заметим, смотрите, каждый отрезок, каждый отрезок у меня,
он, смотрите, он является собой конец какого-то бубнового блока,
несколько полных блоков, идущих подряд, и начало какого-то блока.
Тогда смотрите, какая у нас идея возникает.
Мы же можем, во-первых, заметим, что на каждом блоке мы можем насчитать ответы на префиксах
и на суффиксах, правда?
Суммарно за отн получится, потому что в каждом блоке эти действия отбубны, правда?
Ну, это все равно отн, правда?
Топереча.
А теперь заметим следующее, что попутно мы как раз в каждом блоке минимум насчитали, правда?
Насчитали?
А давайте на этих минимумах построим спортстейбл.
Вот.
Построим спортстейбл, и тогда с помощью таких технологий мы уже на все такие подотрески
сумеем ответить за от единицы.
Потому что есть ответ на суффиксе, есть ответ на префиксе, есть ответ спортстейбле.
Понимаете, да?
Вот, собственно, и все.
Значит, еще раз смотрите.
На каждом блоке мы считаем минимумы на префиксах, минимумы на суффиксах.
Суммарно за отн мы это делаем, потому что в каждом блоке мы это делаем за отбубен.
С другой стороны, у нас на каждом блоке нашелся минимум.
И я на этих вот минимумах хочу посчитать ответ на префикс.
И я на этих вот минимумах хочу построить спортстейбл.
Если я на нем построю, тогда каждый отрезок, он представляет из себя суффикс, несколько подряд идущих блоков и префикс.
Минимум на суффиксе я беру за от единицы из этого блока, минимум на префиксе из этого блока,
а минимум из минимумов блоков в подотреске я беру из этого спортстейбла.
Получается, вот единица.
Ну, теперь думаем, какой у нас предподсчет?
Сколько времени мы потратили на предподсчет?
Отн там, ну, 2n+,
ну, вот, да, n делить на бубен, там, допустим, лог, n делить на бубен.
Ну, замечаем, что если бубен там где-нибудь логн, то, в принципе, это уже превращается отn, правда?
А вообще, чем больше, тем лучше, правда?
Да, давайте вообще бубен равно n.
Ну, да.
Но внимание на, да.
Так, вот, внимание, вопрос.
Да, где ошибка?
А, если она в одном бубене будет участвовать, как традиция?
Да, но, к сожалению, да, это не работает по одной маленькой причине.
К сожалению, нам могут подсует вот такие отрезки.
И такая технология в таком случае, ну, ее полномочия тут, короче, все.
Вот.
Ну, что же делать?
А вот, да, вот тут начинается просто ядро этой технологии.
Смотрите, тут прям самая магия.
Заметим, что вот сколько у нас вообще, вот, рассмотрим вот эти вот отрезки длины бубен.
А теперь давайте подумаем.
А сколько вообще различных отрезков, в принципе, там может оказаться, учитывая, что у нас РНК плюс-минус один?
Ну, не совсем. Правильно ответ бесконечно много.
Потому что тут могут быть отрезки 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 2, 1, 2, 1, 1, 2, 2, 3, 2, 3, 2, 3 и так далее.
Но заметим, что с точки зрения поиска минимума, да, нас интересуют только их условно-частичные разности, правда?
Ну вот.
Это отрезки, которые реально могут оказаться блоками.
Они могут оказаться блоками.
Да, формально говоря, такой вот, и так до бесконечности.
Но заметим, что нам, в общем-то, если мы вычтем мысленно хотя бы из этих блоков, из всего блока одинаковое число, то позиция минимума не поменяется, правда?
То есть, ну вот. То есть, в общем-то, мне достаточно знать только вот эти вот попарно-соседние разности, правда?
Ну, эти частичные разности.
То есть, ну вот, и они будут представлять из себя только числа там 1, 1, минус 1, там и все. Понимаете, да?
А вот их уже всего лишь 2 в степени Бубен, даже минус 1, но я не буду описать.
То есть, в точке зрения до вот этих сдвигов у нас эти штуки всего 2, их 2 в степени Бубен. Видите, да?
Да.
Порядка 2 в степени Бубен.
Sol, zy, k, v, e, n, y, z.
Вот. Значит, что предлагается делать?
Ну, Бубен должен быть, наверное, не очень большой константой.
Поэтому мы тут сделаем просто вот главный финт ушами этой технологии.
А давайте все такие объекты переберем.
Вот все 2 в степени Бубен.
И для каждого из них на каждом подотреске прям тупо найдем минимум.
Да, прям вот так нагло.
То есть, тогда мы после этого предпочитаем для каждого блока, какой он в самом начале, да?
И после этого тогда вот в этой вот огромной мерзкой таблице тогда сможем в зоо от единицы для таких мелочей находить ответ.
То есть, вот в этом и смысл, да?
Технологии вот метода разделяй и властвуй.
То есть, разделяем все на какие-то такие мелкие, мелкие подотрески.
То есть, большие мы там как-то считаем с помощью вот больших структур, а мелкие мы прям тут перебираем полностью в тупую.
То есть, вот такая вот у нас технология.
Так, вот.
Понятно, да?
Тогда давайте посмотрим.
Вот мы все подотрески Бубнового отрезка мы за сколько посчитаем?
Тогда давайте посмотрим. Вот мы все подотрески бубнового отрезка мы за сколько посчитаем?
А в квадрате-то зачем? Откуда? У тебя всего отрезков два в степени бубен.
Так, и сколько этих левых правых границ? Да, бубен в квадрате, но да, причем можно даже не мелочи сказать, что так, отрезков у меня бубен в квадрате, для каждого из них я ищу минимум за линию, поэтому бубен в квадрате, на самом деле да, да, можно при очень большом желании оптимизировать до квадрата, если хотите, или там построить там какой-нибудь спортстейбл за там бубен лог бубен,
но на самом деле вообще нет резоза заборачиваться, сейчас увидите почему.
Итак, значит этот предподсчет торжественно добавляется вот сюда, значит два в степени бубен в кубе, вот теперь давайте думать, чему у нас должен оказаться равен бубен, чтобы это было хорошо?
Ну вот, на самом деле да, можно пытаться проявить как действительно тут догадываться, но можно просто спалить ответ.
Сам лог n конечно не поможет, потому что тут будет n на какую-то градость в кубе, но мы просто объявим.
Давайте пусть у нас бубен, да, обычно бубен это корень или корень из n лог n, но у нас он будет лог n, внимание, именно пополам, это важно, потому что если я подставлю сюда лог n пополам,
тогда получается 2n, плюс значит 2n поделить на лог 2-ичный n, умножить на логарифм 2-ичный n поделить на, да в общем-то уже не особо важно что, потому что это уже точно не более чем у отn, правда?
А что у нас здесь? Здесь получается 2 в степени лог 2n пополам на лог в кубе n, ну поделить на 8, но это уже не принципиально, но что такое 2 в степени лог 2n пополам?
Да, он родимый, это тупо корень из n, но корень из n умноженный на логарифм в любой степени, это отn, вот, ну и собственно все, то есть получается, что суммарно это все отn.
Да, конечно, неожиданно, это конечно не к таким алгоритмам за отn мы привыкли, конечно, но да, как говорится, это все безобразие тоже вот за отn работает, вот, так что вот такая вот технология метода 4х русских, то есть зафиксировать бубен, который выберем позже,
вот, потом и там разбить все на отрезки, там какие-то отрезки или кусочки размера бубен, и для каждого этого кусочка, для каждого возможного вообще кусочка все посчитаем, в общем, заметим, что у нас, обратите внимание, кусочков у нас что-то типа n поделить на бубен,
а два нота, мы посчитали так, что у нас скорее всего два в степени бубен даже меньше, чем n поделить на бубен, поэтому по факту у нас тут, то есть скорее всего кусочков, которые мы посчитали, там обсчитали даже меньше, чем вообще кусочков, которые нам предложили тут, собственно, ровно за счет чего мы в общем-то и выигрываем, вот, то есть вот такая вот технология.
Ну что, есть ли тут какие-то вопросы?
Знаешь ли ты версию по алгоритму, которую реально можно написать, которая будет быстро работать, я его знаю.
Вот, вот я сейчас все вспоминаю, ну что значит реально можно написать?
В смысле, что она не требует три стрелочек для себя, не требует...
Не требует четыре тысячи нарян в памяти?
Ну, сформулируем так. Не, ну скажем так, что-то подобное все равно придется писать, может быть даже в более усложненной версии.
В более усложненной версии.
Да? Ой, ну я боюсь, там в этом отрезке в каждом бубне сейчас тебе придется чуть более сложные вещи считать.
У нас была лекция, собственно...
Я помню.
И на нее встрял Егор Небочев и такой, ребята, забудьте все это, а сейчас я вот такую расскажу.
Так.
Идея в чем? Можно пройтись по всему массиву, как вы со стеком, а стек запечатать просто в битовой маске.
Да, так.
Эта битовая маска может быть размером, скажем, N. В смысле, лог N по длине.
Так, и что?
И теперь, если у нас длинный запрос, миллион, то все то же самое.
А если у нас короткий запрос, то нам нужно просто взять некоторую битву маску, обрубить ее с конца и взять первую ноль.
Ну да, да, да, правильно, да. У меня такой же алгоритм, да.
Он гораздо приятнее.
Ну, кому-кому? Ну как сказать? Что приятнее? Делать что-то там стеком какие-то там что-то непонятное хранить или тут?
И сначала свести, построить до гордого дерева, потом перевести в высокий, потом построить на эту руку.
Нет, смотри.
Смотри, никакой Егор Горбачев на самом деле тут не обвалил, на самом деле, это доказательство.
То есть вот эта значимость, это алгоритма.
По одной простой причине.
Потому что решили мы не только стать ЭКРМКУ, но и вот это.
Да, правда, да.
Другой вопрос. Другой вопрос.
Можете свести стать ЭКРМКУ плюс-минус один и его так же решать, как ты сказал, конечно.
Вот. Ну окей.
Да, теперь сейчас я вот расскажу так.
А, или все эту лекцию слушали, повторяться нет смысла, нет?
Нет? Чего?
Два человека, я тебя забыл.
Два человека, да? Точно два?
Нет, просто честно скажу, у меня просто аналогичная ситуация в прошлом поколении была.
То есть мне этот алгоритм, собственно, ваши и предшественники рассказали.
Вот, я не знаю, видимо к ним, то есть да, другой Егор.
А, или Егор Горбачев слушал лекцию вместе с ними, а потом пришел, обрадовал.
Я не знаю.
Но просто да, крутой алгоритм в любом случае.
Да.
Христо Боже.
Значит, смотрите, теперь как делать все то же самое, но без сведения к каким-то там непонятным улца и ДФС.
Ну да, ДФС это сложный алгоритм, на самом деле.
Нет, на самом деле зря смеетесь.
На самом деле, вот знаете, если так покопаться в истории, то как это ни странно вообще такая...
То есть тут надо, конечно, смотреть, то есть первое появление что-то подобного ДФС относится едва ли не к веку 19-му даже.
Вот.
Но на самом деле первая статья, вот такую статью, которую я реально видел по ДФС, его свойством, это была статья 75-го года.
Автор Роберт Энне Тарьян.
Но в этой статье, правда, рассказывались такие мощные вещи, как поиск точек сочленения и компонент сильной связности.
Причем не двумя ДФС, а одним.
Естественно.
Это два принципиально разных алгоритма.
Да.
Вот.
Так что тут...
Ну вот.
Ну там просто...
То есть у него другой алгоритм был.
Так вот, это я просто к чему.
Просто дело в том, что практически все алгоритмы поиска корчайших путей, ну, по крайней мере, в основных версиях к тому моменту уже были.
Ну скажем, алгоритм Dexter датируется 59-м годом.
Например.
Ну там всякие там...
Ну, Флойд и Форд Белман, по-моему, тоже в этом районе.
Ну там Простовные Деревья вообще молчу, потому что Примхроскал это 50-е годы, Барувка 20-е годы вообще.
Вот.
То есть как это называется?
Зачем был...
Что?
Чего?
Ну...
Ну не совсем так.
Нет.
На самом деле они могут быть более очевидны, чем ДФС.
Почему?
Ну, потому что на самом деле, то есть все алгоритмы практически, вот поиска корчайших путей, они берут свое начало.
Они основаны на БФС на самом деле.
А точнее, на волновом алгоритме.
Ну вот.
А идея которого...
Ну, о чем она говорит?
Ну, берем стартовую вершину.
0, да?
Так.
У всех ее соседей, понятно, расстояние 1.
У соседей-соседей расстояние 2.
Ну и так далее, да?
То есть все остальное это как бы...
Можно волны прям по векторам перебирать аккуратненько, да?
Вот.
Ну, можно там эту очередь забабахать и получится вот такой там всеми нами любимый БФС.
Ну и так далее.
Вот.
То есть ну а все остальные алгоритмы, то есть там дальше там начинаем...
Давайте, если тут веса от 1 до k, потом k начинаем увеличивать.
Там потом у нас получается там k очередей.
Мы некоторые начинаем пропускать.
Так, в общем-то, алгоритм ДХ3 появляется.
То есть на самом деле это такой БФС с бесконечным числом очередей, на самом деле.
Ну, в свое время мы обе подробно об этом поговорим.
Я так это...
Пока для затравочки.
На самом деле вот ДХ3 просто вот отсюда берется.
Или там Форд Белман, например.
Это тупо давайте найдем расстояние методом динамического программирования, на самом деле.
То есть вот это тупо ДП-шку прям в классическом стиле пишем.
ДП от ВЖ.
Минимальный вес пути, который идет до В, состоит ровный Ж-рюмер.
Ну или меньше либо равно, чем Ж.
Там разные модификации есть.
То есть в общем-то...
То есть в общем-то, достаточно стандартные подходы.
То есть с этой точки зрения ДФС как концепция сама по себе не такая тривиальная, на самом деле.
Вот.
Ну вот.
Поэтому тут вот...
Поэтому, возможно, мы на самом деле там у нас получится так, что мы будем это знать.
Там это ДФС с потенциалами, но не будем знать ДФС.
Ну как сказать? Именно обход как алгоритм...
Ну не скажу, хотя скорее с ДФСом.
Ну хотя понятно, что само общее математическое знание при существовании левого цикла, оно относится к веку 18-му скорее.
Потому что связано еще, собственно, с именем Леонарда Эльера, собственно.
Вот.
Ну собственно, там Кюниксбергские мосты, вот эти все там все дела.
Вот.
Ну вот. То есть вот это все.
Так. Так вот.
Значит, пока мы тут говорили, я тут почти все стер.
И теперь у нас следующая технология.
Смотрите.
Вот.
Значит, смотрите.
Значит опять делим, ну значит, массив на этот раз абсолютно произвольный.
Там 5, 1, 4, 2, 3, 8, там 57, 1 и так далее.
Делим его опять на отрезки по бубен.
Да, на всякий случай сейчас мы не будем предсказывать бубен.
Вот. Сами себе подгоним.
А теперь, значит, внимательно думаем вот о чем.
То есть теперь, к сожалению, у нас...
Может и поменялся.
Ну.
Может поменялся, может нет.
Ну, как бы.
Чего?
Не-не-не.
Это число 57.
Да.
Вот.
И пришла к нам 57.
И сказал.
Но смотрите.
Но на этот раз, к сожалению, даже с точностью разжатия координат у нас этих отрезков ну сколько?
Ну да.
Но если в тупую сжимать координаты типа там, то получится что-то типа там, я не знаю, бубен факториал.
Вот.
Но с другой стороны, тут какие проблемы могут быть?
Ну вот.
Ну проблемы могут быть, что, конечно, там...
Ну вот.
Для каждого...
Ну вот.
Ну то есть, конечно, можно попытаться для каждого там работать что-нибудь типа там за бубен факториал, конечно, умножить на бубен факториал.
Например, там в кубе.
Ну или там, да?
Но правда, с другой стороны, теперь для каждого подотреска надо понять, какого типа блоку он принадлежит, правда?
Да.
А можно ли это сделать за его от бубен?
Не понятно.
Вот.
Поэтому там уже сомнительно.
В общем, не в зависимости от того, насколько мелкий будет бубен.
Но.
Но.
С другой стороны, с точки зрения именно поиска минимума, нам, в общем-то, это не то, чтобы сильно критично.
Потому что на самом деле...
Вот.
То есть, на самом деле...
Бубен можно искать...
Значит, минимум можно искать следующим образом.
Значит, смотрите.
Давайте я...
Попытаюсь...
Вот рассмотрим отрезок.
И мне жутко интересно, вот если я буду идти справа налево и рассматривать вот такие отрезки.
Мне жутко интересно, какие элементы будут минимумами?
Вот, понимаете, да?
Сначала самый элемент.
Ну, понятно.
Сначала самый первый элемент.
Потом, начиная с какого-то момента, там будут больше-больше-больше, потом бах-бах, произошел следующее, да?
Да.
Вот.
Значит, тоже идем-идем-идем, идем-идем.
Значит, тут тоже что-то поныряли, поныряли, тут вот следующее, и так далее.
То есть, в принципе, уже можно понять.
Если мы говорим об отрезках, которые являются суффиксами этого блока, то значит, если там блок начинается где-то здесь, то ответ вот он.
Если и вот он где-то здесь, то вот он.
Если где-то здесь, то вот он, и так далее, правда?
То есть, более того, можно это было бы даже сказать так.
Давайте в масочке сохраним, какие элементы у нас тут появились как очередные минимумы, а какие нет.
То есть, прям вот так и напишем в данном случае.
1, 0, 0, там 1, 0, 0, там 1.
И вот если тут еще этот появился тоже 1, масочка необязательно периодична, да?
Тогда смотрите, если у нас есть масочка блока...
Чего, какие циферки?
Да, пожалуй.
Ну, вот тут какая-нибудь там...
Ну, допустим, тут.
Так вот, у нас получилась такая масочка того, что может быть.
Тогда если мы хотим найти минимум среди, скажем, первых пяти элементов, то мы по этой масочке можем понять, где он находится.
То есть, надо просто найти, где, начиная с этой позиции, находится ближайшая единичка.
А такие вещи мы можем предподсчитать, просто перебрав все масочки за два в степени Бубен.
Для каждой масочки перебрав Бубен позиции.
И для каждой позиции...
Что ты еще?
Ну вот.
И для каждой позиции там, ну, можно там даже в тупую зоо от Бубена считать единичку.
Да, можно и не в тупую, но не важно.
Вот, понимаете, да?
То есть, в принципе, да, мы уже поняли, что это, в общем-то, не страшно будет, правда?
Потому что, напоминаю, у нас эта старая технология, работа вот с этими вот большими отрезками та же.
То есть, минимум на префиксе, минимум на суффиксе, spark-stable, радость.
То есть, если у нас Бубен не будет превосходить о от логн, то, в общем-то, тогда с большими отрезками мы справляемся уверенно.
Понимаете, да?
И при подсчет для них тоже делаем суммарно за о от н.
Помним, да?
Так что главное, то есть, главное с мелкими.
Правда, желательно, чтобы у меня было не меньше.
Было омега от логарифма n Бубен желательно еще.
Потому что, если там он будет меньше, то тогда там spark-stable будет все-таки дольше работать где-то.
Значит, поехали.
Что у нас дальше будет?
Ну, а теперь фишка такая.
Ну, хорошо, для суффикса мы, конечно, это все нашли.
Но для суффикса неинтересно.
Мы для суффикса и так могли предпочитать минимум, да?
Мы же, помните, мы же хотим где-то вот внутри как-то искать минимум, правда?
Но теперь идея такая.
А давайте теперь пробежимся по этой штуке.
И будем идти так.
Идем слева направо.
И мы хотим в каждый момент времени в каком-нибудь стейке хранить только те элементы,
которые, если мы дошли до этой позиции, которые могут быть минимум на каком-то суффиксе.
Точнее, подотрески заканчиваются в этой позиции.
Значит, как это будет работать?
Смотрите.
Сначала мы идем слева направо.
Вот видим ноль, добавляем ноль в стек.
Видите, да?
Потом видим один, добавляем его в стек.
Потом видим четыре, добавляем в стек.
Потом семь.
А теперь вот видим три.
Теперь заметим, что если у нас отрезок заканчивается где-то здесь, то или позже,
то четверка и семерка больше никогда минимум не будут железны, правда?
Поэтому мы эту семерку и четверку из стека выпиливаем.
И вот получается, добавляем их в стек три.
Поэтому теперь дальше пишем одиннадцать.
Потом тут же его удаляем и пишем девять.
Потом удаляем и пишем пять.
То есть вот такую операцию со стеками мы можем провернуть.
И, собственно, ничего удивительного в ней нет.
И мы, очевидно, проделали ее за от.
Видите, да?
Правда, она пока абстрактная, абстрактная массив в вакууме.
Главное, мы это туда не списали.
Вот.
Прошлись и как бы забыли.
Да, пока просто прошлись, да.
Абстрактный проход со стеком в вакууме.
Значит, зачем мы это сделали?
А сделали мы это вот зачем?
Ведь дело в том, что когда мы идем вот так слева направо,
мы можем прям хранить масочку из всех элементов, которые сейчас в этом стеке лежат, правда?
То есть она там сначала это будет масочка один, потом там масочка один, потом масочка 1111, потом масочка 1111, потом масочка 11001.
Видите, да?
Потом масочка 1001, потом масочка вот 01, потом масочка 001.
Но заметим, что это в каждый момент времени у нас получается ровно та самая масочка, которую мы хотели.
Помните?
То есть та самая.
То есть когда мы дошли до этого элемента, то тут единичками горят только те элементы, которые могут быть минимуме в зависимости от левой границы.
Вот, легко убедиться, правда?
Но тогда идея такая.
Но тогда идея такая.
Тогда проходим с этим спеком и эти масочки себе сохраняем.
То есть для каждого элемента сохраняем свою масочку.
И тогда получается, что когда у вас будет вот такой мелкий отрезок, вот вы знаете, что для этого элемента у вас есть вот масочка на вот это вот все.
Там 100 там какой-нибудь.
Условно там какой-нибудь 10011101.
Смотрите, где этот отрезок тут начинается.
И находите ближайшую единичку.
Ну вот, находите просто ближайшую единичку.
То есть единственное, что теперь надо предподсчитать помимо самих этих масочек, это для каждой масочки и для каждой позиции в масочке найдите ближайшую единичку.
Мы это уже сделали.
Все.
То есть теперь получается, что с этим предподсчетом мы тогда за о от единицы на мелкие отвечаем.
И тогда у нас общий предподсчет 2 в степени бубен.
На бубен даже квадрата не куб.
Ну при том, что там остальной предподсчет делается за о от н.
Плюс, ну как всегда, н поделить на бубен.
Ну можно не хранить, потому что заметим, что в этих масочках они уже есть.
Совершенно верно, можно не хранить.
Сейчас, а вот когда мы поделились, мы поделились по каждому блоку отдельно?
Мы не пройти по всему массиву со стеком.
Главное в каждом моменте запечатлеть эту маску.
Ну да.
Нет, фишка тут в том, что на самом деле эту маску можно хранить даже на очереди.
Ну потому что, смотрите, если вы хотите слева...
Я знаю, как выгореть, но по ней проходиться.
Почему, не знаю.
Не, в смысле, а зачем?
Если ты хочешь, у тебя есть, так скажем, к элементов, и у тебя масочка размера к.
Если ты хочешь отпилить последний элемент, ты просто вот этот бит выпиливаешь и все.
Ну вот, выпилить этот последний бит, ты можешь сделать единицы, если ты знаешь размер очереди, а ты ее знаешь.
Поэтому по большому счету, да,
по большому счету, на самом деле, вы можете пробежаться очередью для каждого отрезка размера Бубен, не только для этого,
буквально для каждого, на самом деле, себе такую масочку посчитать.
Ну более этого, на самом деле, а что касается вот этой очереди, то на этой технологии на самом деле еще основан алгоритм, еще один метод, как искать поддерживать минимум в очереди.
Ну то есть у нас, как всегда, задача, у нас есть очередь, мы можем туда добавлять элементы, удалять элементы и сообщать, а кто у нас сейчас в очереди минимум.
Спрашивается, как это делать.
Ну вот, ну конечно, масочку на все элементы мы не похороним, хотя, в принципе, если мы ее будем хранить не в одном числе, а у нас тоже будет параллельный массивчик, да,
и там скажем, для каждого элемента мы можем в явном виде хранить, где у нас ближайшая единичка, правда?
Видите, да?
То тогда у нас будет получаться следующее, что в каждый момент времени у нас есть очередь, есть вот такая масочка, вот.
И мы говорим, что если мы что-то добавляем элемент, то значит, возможно, нам придется, ну да, правда, тут с ноликами проблемы, их не удастся перенаправить, вот.
Но идея будет в том, что значит мы вот эти элементы, помните, у нас же стэк был, да?
Мы их как бы из стэка удаляем, условно, ну вот, а этот элемент добавляем, понимаете, да?
Вот, ну тут, конечно, да, ладно, набрал я тут, конечно, с масочкой, но суть будет следующим.
Мы вот храним вот этот стэк, но при этом, когда удаляем элемент слева, мы говорим, что если этот элемент сейчас лежит в стэке, значит мы его снизу стэка удалим.
Да, как удалить элемент снизу стэка, ну давайте представим, что это очередь, понимаете?
Так, меня слышно вообще? А то что-то у меня там опять конкурент с улицы пришел.
Ну вот, причем заметим, что вот, например, вот в этой ситуации, если вот эти два элемента будут удалены, то у нас в стэке лежат сейчас вот троечка и двоечка, да?
Нет, троечка не лежит.
А, троечка уже не лежит?
Да.
Но, ладно, давайте так, отмотаем назад, да, троечка и пятерочка вот эти вот лежат, да, тогда у меня троечка и пятерочка лежат.
И тогда, смотрите, то есть, ну, с стэком мы делаем какие-то операции, но, значит, когда удаляется элемент, мы говорим, так, это та ли это троечка.
Как говорится, не та, ну, значит, просто удаляем на минимум в очереди, это не влияет.
То есть, пока мы вообще не дойдем до этого минимума, то тут можно удалять и не заморачиваться.
удалять и не заморачиваться. А когда дойдет, ну значит мы просто с этой стороны стека тоже удаляем.
Ну как сказать, в данном случае нам удобно понять, что это просто стек, у которого мы умеем...
Скажите так, это стек, который подтапливает.
Да, по факту это очередь, но знаете, как-то все-таки...
Очередь у нас все-таки обычно вот такая, а у нас все-таки...
Я считаю, что играть можно с конца, так что это все-таки дек.
Ну, окей, ладно.
Ну ладно, ну да. Ну понятно, что по факту, но все-таки список, дек, там все что угодно.
Там понятно в любом случае как-то реализовать, но...
Может быть чистить битву и магию?
Нет, ну битвой и магии нельзя, если размер очереди бывает большой.
Ну нет, я сейчас просто рассказал, что на самом деле это можно и в принципе такое минимум в очереди поддерживать.
Нет, просто знаете, я помню, там год назад вот была такая Олимпиада для восьмых классов,
тоже там баловая какая, там последние задачи, там, по-моему, нужно было модифицировать именно этот алгоритм.
Там просто жесткое уминание за УАТН было.
Ну там, причем, был прикол, что там, типа, совсем же там, типа, для Энда миллиона дает 98 баллов,
а еще два балла в офлайн-проверке, это если Энда десяти в седьмой.
Все там написали, дерево отрезков там все понаписали, вы знаете, у всех 98 баллов.
А на самом деле там была вот линейка, но там что-то жуткое было, там, по-моему, и вот это надо было использовать,
и эти все вот технологии, помните, как мы эти вектора там расширяли, сужали, там вот это все безобразие было.
Там вот какая-то хорошая задача.
Не, а что такое? Ну, как бы, простая амортизация, там никаких фибоначевых куч там не требовалось.
Дерево Песк изыграли в момент их рождения.
Да?
Ну, может быть. Хотя, конечно, вопрос, как их изыграли.
Не, ну да, как твоего рождения.
Так, а у тебя вот рождение, надо полагать, 2000 какой? Третий, получается, угадал.
Вы становились пять по отдатию на питение Дерево Песка?
Нет. Да нет, там по другим принципам.
Не, ну там, знаете, я мог там посчитать в духе, что там, я не знаю,
посчитать, насколько вы должны быть младше моего брата.
Ну, потому что сколько лет назад он там учился, там поступил на химфар.
Да, правда, это сложнее, потому что там он как бы в прошлом, вообще-то в этом году его закончил, но не важно.
Так что вот получается такая вот технология.
Еще тут бонуса можно действительно на очереди минимум искать.
Ну, а заодно, на самом деле, тут можно на этом массиве тогда, это, конечно, чуть сложнее,
но зато сразу дает вам возможность писать метод четырех русских и ни о какой ЛЦАшке не вспоминать.
Так что получилась вот такая технология.
Так, ну что, есть ли тут какие-то вопросы?
Так, ну, формально говоря, получается, на этом можно и закончить.
Ну, там просто какая логика?
Просто, по идее, где-то в этом месте должен произойти 15-минутный, там, 10-минутный перерыв.
А у вас через 15 минут, я так понял, регулирует.
Нет, ее отменили.
А, отменили?
Да, потому что там, видимо, Регерошка понял, что он кому-то поставил во время пары и такой, ну ладно.
Да, вот действительно.
Всегда любил Андрея Михайловича, на самом деле, за, собственно, адекватную простоту, на самом деле.
Так, ну хорошо.
Хорошо, хотя...
Ну да.
Нет, ну тут по-разному.
Понимаете, тут просто проблема такая, что в этом месте как-то надо начинать
просто принципиально новую тему.
Там то ли к ДП переходить, то ли к чем-то еще.
А можно вопрос?
А?
Какая именно часть из этого, это метод четырех русских?
Потому что мы вроде, в целом, говорили про алкоголь, но пора полного...
Нет, часть методов четырех русских, это та, которая с бубном.
Может, на Вене написано, что там что-то пора мататься, там что-то...
Ну потому что, слушайте, потому что этим методом не только она решается.
Смотрите.
Потому что там предлагается следующее.
Значит, там предлагается такая неожиданная задача.
Даны две матрицы.
n на n.
Из ноликов и единичек.
Ну бла-бла-бла, короче.
Я хочу их перемножить.
Причем очень хочу сделать это быстрее, чем ЗМК.
Как мне это сделать?
И тут у нас снова приходят четырех русских, четыре русских и говорят.
Приходят наши четырех русские и говорят.
Ладно, зафиксируем k, который выберем позже, в смысле, бубен.
Разделим в первой матрице каждую вот эту штуку на отрезке длины бубен.
А в этой матрице на столбцы длины бубен.
На вот такой штучке.
Тут строки, там столбцы.
Ну потому что что такое произведение?
Это что-то типа строка на столбе скалярно.
Поэтому вместо того, чтобы делать это за o от n,
при правильном предподсчете мы можем легко это сделать за n поделить на бубен.
Думаю, вы уже загадались как.
Итак, ну давайте теперь считать, какой же нам бубен нужен и с какой симптом у нас это получится.
Ну ладно, произведение, скалярное произведение всех вот этих масочек вы сделаете за 2 в степени 2 бубен.
Ну если в тупую, то на бубен.
А если, ну правда там советуют перемножать не просто матрики, а сказать, что они битые, и типа умножение это типа взятие n, да?
Поэтому тут на самом деле это тоже битовая масочка.
В этом случае могли бы вообще, может быть, за o от единицы обойтись, но тем не менее давайте уж в тупую тогда.
2 в степени 2 бубен на бубен.
И собственно само перемножение матрицы теперь будет работать за сколько?
За n в квадрате умножить на n поделить на бубен.
Ну понятно, что при такой, ну вот давайте теперь подгоняем бубен.
Как теперь?
Сколько?
Ну да.
Ну в принципе да.
А можно так, я все-таки расскажу общую технологию, как тут аккуратно думать.
Ну потому что заметим, что если у нас тут от параметра зависит две части, причем одна из них растет, а другая убывает,
то если мы хотим оптимальную асимптотику, то нам нужно конечно найти вот этот момент, правда?
Потому что асимптотика суммы это то же самое, что асимптотика максимума, правда?
Ну соответственно тогда получается надо, чтобы вот эти штуки были примерно равны.
Ну давайте домножим на бубен, получится, что 2 в степени 3 бубна умножить на бубен.
А, ой-ой-ой, слава богу, да.
А то я ж думал, о боже, сейчас у меня бубен натрешить делиться будет, что ли.
Ну почему бы нет?
И вот получается n.
Ну и теперь соответственно надо подогнать максимально близкий бубен так, чтобы и тут подошло.
Но точно мы это решить не можем, но нам точно и не нужно, нам нужно асимптотически, правда?
И тут мы заметим следующее, что если мы возьмем, допустим, какой-нибудь бубен лог,
то есть если возьму лог 2n, то эта штука получится заведомо меньше, то есть n2 на что-то там, правда?
То есть лог 2n должно быть меньше, чем бубен.
Но с другой стороны заметим, если мы возьмем, ну скажем, полтора логарифма,
то тогда здесь уже получится n в кубе на что-то там.
То есть получается бубен получается тоже, получается θ от логарифма, какой-то надо брать.
Ну в общем-то тут не особо принципиально, возможно просто давайте логарифом n возьмем и все.
То есть с точки зрения этого слагаем его с сути 1, и тогда получится асимптотика.
Асимптотика, ну не то чтобы она нас в прошлом году обрадует, но по крайней мере как пример технологии подходит.
Вот, пожалуйста.
Ну быстрее, чем за куб, правда?
Ну в конце концов это, кто из нас никогда не пихал там это при n равно 1000, я не знаю, n куб поделить на 32?
Еще никто?
Да, кто не пихал?
Да, кто не пихал?
Нет, или мало кто из этих технологий?
Кто из нас никогда не кидался по улице мелом?
Я не кидался, Вася не кидался.
Вот это вот вся технология.
А где можно настолько ускорить, что n в кубе можно и не пихать после n в кубе?
Да, но ограничения это всегда можно увеличить.
Там 2000, 3000, потом там все от константы зависит.
Там же есть же места, где этому наступает период.
Я уже рассказываю эту веселую историю, как я на кубе порчусь, у меня там не запихалась корневая.
В чем главное?
При официальном решении за n лог квадрат, там n были такое, что лог квадрат вроде и корень примерно одно и то же.
Ну действительно там, ну давай, ну вот.
Ну там плюс-минус.
Ну, например, если n это, например, там, я не знаю, 400 тысяч, да?
То тогда, смотрите, логарифм это тогда 400 тысяч, это что?
Ну где-то там 18-19, да?
Там, то есть в квадрате, то есть квадрат получается что-то типа 350.
А что такое, ну вот.
Ну вот, нот, а корень из 400 тысяч, это что такое?
Ну там 500 где-то получается.
Ну ладно, больше там, 607 нот.
Ну ладно, больше 600-700.
Ну то есть как бы понятно, что плюс-минус вот это там зависит.
Ну вот, но оказалось, что это прям критично, что даже несмотря на то, что у меня решение было доказать на закоренение из-за корень логм, там как это иногда случается,
но как бы тем не менее оказалось, что при ТЛе 4 секунды мой корень работает за 12 идите лесом.
То есть я там уминал обеими ногами, но, ну я, конечно, там не самый крутой уминатель в истории, конечно, но вот.
У меня задача работать в квадрат, работать быстрее, чем автор, тем более.
Ну да, бывает такое.
Ну, на самом деле это еще от тестов зависит.
Знаете, бывает такое, что я как-то в одном разборе видел замечательную формулировку от авторов тестов.
То есть там такое, там автор Наталья Бондаренко, по-моему, это писала.
Писала так замечательно.
Это решение оказалось неожиданностью для нас, и мы не заготовили против него тестов.
Вот, то есть это замечательная формулировка, конечно, такая.
Ну, ну что такое умеет делать?
Мало ли.
Знаете, как это обидно, когда человек сказал, что он не умеет делать тестов, а потом его тесты ваши прогрессы получают в А57.
Ну понятно, да.
Нет, ну тут как бы чемпионат, кто умеет пихать неправильные решения, а против не умеющих делать тестов.
Вот, так что да.
Так что вот на самом деле, то есть если говорите в Википедии, там написано это.
То есть на самом деле самое смешное, что подобная технология работает даже в задаче о поиске наибольшей общей подпоследовательности.
Вот на самом деле.
Там даже налог квадрат удастся поделить.
Или не удастся.
Нет, ну вот дай бог памяти, вот, видимо, в следующий раз мы до этого и дойдем.
Нет.
Или да.
Ну в общем, да, там тоже есть, то есть как это, поэтому технология применима не только тут, вот еще разные места.
То есть даже в атоме к себе, по-моему, она может чуть-чуть возникнуть.
Ой, ну для того, чтобы дойти до атома к себе, нам придется еще там пару алгоритмов изучать.
Так что боюсь, это в следующих алгоритмах.
Да, в следующих алгоритмах.
Да, в следующих лекциях это ждите новинок.
Так что ладно.
Так, еще какие-нибудь вопросы есть?
Пользуюсь в случае.
Нет?
Вот.
Ну ладно.
Так, тогда знаете, что мы сделаем?
Ну, новых тем я запускать не хочу, а мы все-таки на полчаса задержались.
Ну, ну, ну, ну, ну, ну.
Ну, ну, ну, ну.
Ну, ну, ну.
А мы все-таки на полчаса задержались.
Вот.
Поэтому знаете, давайте тогда скажем, что на этом все на сегодня.
