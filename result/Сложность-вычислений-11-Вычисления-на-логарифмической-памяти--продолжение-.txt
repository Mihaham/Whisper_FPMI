Добрый день. В прошлый раз мы довольно подробно изучили
детерминированные числения на логермической памяти,
а сегодня будем изучать недетерминированные числения.
Давайте я начну демонстрировать экран.
Есть класс NL, который есть nspace.
Это класс языков, которые распознаются на недетерминированной машине
на соответственно логермической памяти.
Мы с Теремысовича знаем, что NL вложено в thespace
от logarithms N в квадрате.
А это вложено в класс, который называется poly-L.
Также есть открытая проблема.
Это равны ли L и NL?
Поскольку мы проходили, на пилонарном уровне никаких вопросов нет,
на пилонарном уровне pspace равняется npspace,
то можно считать эту логермическую проблему
аналогом проблемы раунст p и np для логермической памяти.
Это аналог проблемы p равно np для логермической памяти.
Изучается она также похожими методами.
Именно в классе NL изучаются полные задачи
относительно логермической сводимости.
А сводится к B логермически.
Если существует функция F,
вычислимая на логермической памяти такая что,
а дальше как всегда, такая что x лежит в A,
тогда и только тогда, когда F от x лежит в B.
Что означает логермическая память?
Мы это обсуждали.
Тут есть два определения.
Давайте это в отдельном окне напишу.
Два определения функции вычислимости
на логермической памяти.
Первая.
Есть машина с отдельной лентой
только для записи битов ответа один за другим.
Учисляющая F.
Я напишу с неизменяемым входом.
И отдельной лентой только для записи битов ответа.
Машина учисляет F.
И, соответственно, она использует
порядка логерифма битов на рабочих лентах.
Второе есть определение, что языки
такие, пара x и такие, что длина F от x меньше,
тем и.
Давайте лучше напишу больше либо равно.
Это неважно, так как это более естественно.
И таких, что i-t, b-t, F от x равен единице,
лежат в L.
Почему эти определения эквивалентны?
Эквивалентность определений.
Почему из второго следует первое?
Получается вот почему.
Мы запускаем цикл по i.
От единицы до бесконечности.
Соответственно, сначала проверяем,
что длина F от x больше либо равно i.
Если это неверно, то заканчиваем работу.
Затем, если верно, то проверяем,
что i-t бит равен единице.
Если это верно, то печатаем единицу.
Иначе ноль.
И переходим к следующему i.
Соответственно, ясно, что каждый раз на каждом вычислении
используем одну и ту же лабирхимическую память.
Ну и еще дополнительно нужна память для хранения i.
Ну и один, два, три, четыре, пять.
Так, ну и один-два, значит, из первого-второго делается
так.
Да, здесь запускаем вычисления f от x, но, соответственно,
не храним биты выхода, а только считаем их.
Соответственно, если оказалось, что слово закончилось до
того, как вывели и битов, то отвечаем нет на оба вопроса.
Потому что тут итого бита выхода вообще нету, но
в частности он не равен единице.
Вот, соответственно, если вывели итый бит, то отвечаем
да на первый вопрос и, соответственно, в зависимости от бита, как
бы и этот бит на второй.
Значит, вот такая вот процедура должна быть
Так, теперь, значит, что делаем дальше?
Ну, дальше возникает понятие nl-трудности и nl-полноты.
Значит, nl-трудность это значит, что для любого a из nl
верно, что a сводится к b, а b-nl-трудный.
Если b и сам лежит в nl, то b называется nl-полным.
Так, хорошо.
Ну, соответственно, дальше возникают стандартные соображения.
Например, если какой-то там nl-полный язык лежит в l, то l равно nl, ну и так далее.
То есть тут, в общем, все такого общего плана соображения, они такие же, как и для NP и предпонимаемой сводимости.
Вот здесь сначала написать, что если a сводится к b и b в l, то a в l.
Ну и так далее. В общем, это разного рода стандартные соображения, более-менее как обычно.
Так, ну теперь давайте посмотрим на примеры.
Примеры языков из nl.
Ну, например, path или dpath в ориентированном графе.
Path – это множество троек из графа и двух вершин его, таких, что в ориентированной графе G есть ориентированный путь.
Из s в t.
Вот почему это, почему это лежит в nl.
Потому что может быть такая, например, процедура, значит, недетерминированный алгоритм поиска пути.
Значит, алгоритм такой. Значит, тут опять же цикл для i. Вот единица до n.
Ну, до n я начал вершину.
Значит, выбрать произвольную вершину.
Сейчас, извините.
Так.
Значит, выбрать произвольную вершину.
Если из текущей вершины есть ребро в выбранную,
то, соответственно, перейдем выбранную.
Вот. Ну, соответственно, если, ну, точнее так, начнем, назначим s текущей вершиной.
Значит, и дальше сделаем вот n раз.
Продолжим писать. Значит, выберем произвольную вершину.
Если из текущей вершины есть ребро выбранную, то перейдем выбранную.
Ну, и в результате, значит, если текущая совпала с t, то вернем 1.
Вернем, да. Вот.
Соответственно, дальше, соответственно, если, значит, если после n шагов t ни разу не встретилась,
то, соответственно, вернем нет.
Вот. Значит, почему это требует логарифмической памяти?
Ну, потому что нам фактически нужно хранить текущую вершину, да, значит, и индекс для перебора вот этого i.
А дальше, да, то есть для номера этапа.
Ну, а дальше нам еще нужна логарифмическая память, чтобы написать произвольные вершины.
Вот. И тогда мы, соответственно, проверяем, что вот это ребро есть.
А, и тогда переходим, соответственно, старую текущую стираем, да, значит, выбранную, переносим на ее место.
Вот. Тогда, если путь есть, значит, если путь есть, тогда есть путь без повторной вершин.
Он длинный небольшой n. Ну, там даже и минус 1, не важно.
Вот. И тогда будет реализация выбора, который по нему пройдет и придет в t.
Соответственно, если пути нет, то как бы он не ходил.
И даже неважно, что делать, если нет ребра выбранную, да, можно оставаться на месте, можно сразу отвечать нет.
Это неважно, в любом случае будет правильно.
Так.
Хорошо.
Значит, теперь...
Такие еще есть примеры. Ну, например, есть язык сильно связанности.
Значит, s is connected.
Это множество таких графов g.
Что g – это сильно связанный, ориентированный граф.
Вот. Тогда здесь, в общем, нужно проверить наличие пути из каждой вершины в каждую другую.
Ну, соответственно, это делается многократным применением предыдущего алгоритма.
Вот. Ну, добавляется еще там пара счетчиков.
Тут даже может делать один счетчик, проверять, что для каждой есть путь вы плюс один.
Да, из n в первую.
Значит, уже такого линейного цикла будет достаточно.
Так, хорошо.
Значит, теперь...
Вот язык path на самом деле будет nl полный.
Вот теорема.
Язык path является nl полным.
Ну, идея доказательства – это аналогично в полноте succinct path в ap-space.
Значит, тут нужно рассмотреть конфигурационный граф машины m на входе x.
Ну и, соответственно, с использованием логарифмической памяти.
Идея доказательства.
Ну и, соответственно, в нем есть путь.
Значит, в этом графе есть путь, изначальная вершина в принимающую.
Тогда и только тогда.
Когда, соответственно, x...
Ну, когда m от x равно единице.
Ну, то есть когда x у нас там лежит в нашем языке a.
Так, давайте начнем с того, что у нас пусть a лежит в nl.
И, соответственно, a распознается нетерминированной машиной тюринга m.
Значит, нужно рассмотреть конфигурационный граф этой машины на входе x с использованием логарифмической памяти.
Ну вот, мы еще предполагаем, что есть одна выделенная принимающая вершина, в которую идут дополнительные ребра.
Каждая обычная принимающая вершина.
Ну и нужно только объяснить, нужно только обосновать, почему сводимость логарифмическая.
Значит, это делается следующим образом.
Ну, тут фактически x известен.
Во-первых, конфигурационный граф имеет полимерный размер.
Потому что логарифмическая память.
На логарифмической памяти полимерное число возможных записей.
Ну и, соответственно, дальше еще умножается на число положения головки, на входе длины n и так далее.
Значит, поэтому граф имеет полимерный размер.
Поэтому, в принципе, это может быть логарифмическая сводимость.
Ну и, соответственно, проверить, есть ли ребро.
Значит, довольно легко.
Ну, то есть можно на логарифмической памяти.
Вот это второе определение.
То есть у нас тут есть описание графа.
Есть какая-то стандартная номерация вершин в графе.
И дальше фактически граф кодируется матрицей смежности.
Нам нужно понять, есть ли ребро между данными конфигурациями.
Ну, то есть тут нужно смотреть, какого вообще размера матрица смежности.
И есть ли ребро.
Какого размера – это легко понять.
Есть ли ребро – тоже довольно-таки легко понять.
У нас полимерное число вершин.
Запись вершины – это логарифмическое число битов.
Поэтому можно коды вершин целиком анализировать.
Ну и, соответственно, хранить описание конфигурации прямо в памяти.
Ну и, соответственно, получится, что нужно проверить, что там почти все символы одинаковые,
кроме места, где стоит головка, и провинтового места.
Изменения соответствуют программам машины тюнинга.
На общем, более-менее стандартная вещь.
Поэтому мы это сможем сделать.
Давайте я еще одну свободимость покажу.
Т.е. язык Strongly Connected – тоже NL-полный.
Тут нужно показать, что PATH логарифмически сводится к Strongly Connected.
Вот каким образом.
Я, наверное, лучше нарисую.
Вот у нас есть какой-то граф.
В нём есть две выделенных вершины.
Вершина S.
Вершина T.
Вот есть ли путь.
Значит, нужно как-то этот граф дополнить, чтобы сильная связность дополнился.
Но это делается так.
Добавляются еще две вершины.
Добавляем еще две вершины.
Добавляем еще две вершины.
Добавляем еще две вершины.
Добавляем еще две вершины.
Надо сделать так, чтобы из этой новой вершины было ребро только сюда, а из T было бы ребро только сюда.
Поэтому если из этой вершины можно пройти вот в эту, то обязательно должен быть путь где-то здесь.
Но нужно сделать так, чтобы все остальные были.
Мы сделаем так, что наоборот из всех вершин есть ребро вот сюда.
И наоборот, отсюда есть ребра куда угодно.
А что же получается?
Получается, что если я как-нибудь обозначу на там S' и T'.
Извините, я случайно нажал.
Получается, что путь из S' и T' обязательно должен начинаться вот с этого ребра.
И обязательно должен заканчиваться вот этим ребром.
Если путь из S' и T' есть, тогда с S' есть путь такой.
А для любой другой пары вершин есть путь такой.
Из произвольной вершины сначала в S', и в том числе и в T'.
Сначала из произвольной вершины в S', потом в S', потом через T', потом в T' и потом из T' в произвольную вершину.
Получается, что я запишу.
Получаем вершины S', T' и ребра.
Рёбра S' в S', из S' в X.
Тут X не равно S.
Кроме того, из T' и из T' в Y.
Тут со S' в Y не равно T.
Тогда есть пути из X в S'.
Кстати, наверное, ничего плохого не будет.
Давайте без этой оговорки.
Для всех сделаем, так проще будет.
Тогда есть пути вида X в S', в S', в T', в Y.
Это если есть путь из S' в T'.
Если из S' в T' есть путь, то его можно дополнить до пути из любого X, любого Y.
Если нет пути из S' в исходном графе, то он и не появится.
Мы добавили из S' в S', но дальше из S' мы можем только обратно в S вернуться и больше никуда.
Поэтому всё равно придётся идти только в этом графе.
И даже если мы в какой-то момент свернём в S', то всё равно мы можем вернуться только в S.
Поэтому мы рассмотрим последний момент, когда мы S посещали.
И после этого должен быть уже путь из S в T внутри старого графа,
потому что S' может договорились, что не может это быть использовано.
А T' тоже не может быть, но до этого нужно T посетить.
Поэтому если будет путь из S в T' в таком расширном графе, то он будет и в исходном графе.
Ну и, конечно, такая S-водимость логарифмическая,
потому что мы тут совсем простую вещь делаем.
То есть добавляем две вершины, какие-то вот такие ребра очень регулярные.
Поэтому это всё, естественно, можно делать на логарифмической памяти.
Так, хорошо. Может, какие-нибудь вопросы есть?
Ладно, двигаемся дальше.
Потому что, как и в NP, кроме определения через нетоминированные машины,
есть ещё сертификатное определение.
Сертификатное определение NL.
Считаново будет таким, что имеется машина с дополнительной...
Что дело в том, что если вы обычное определение будете использовать,
то есть если взять определение NP и заменить полинамиальную вычислимость V на логарифмическую,
то всё равно получится NP.
Поэтому определение будет другим, более ограниченным.
Основная идея, значит, нужно ограничить возможности чтения сертификата.
Соответственно, имеется машина с дополнительной входной лентой,
которую можно читать только слева направо.
Соответственно, её содержимое назовём сертификатом.
Её содержимое назовём сертификатом.
Ну и определение, соответственно, теперь как обычно.
Значит, х лежит ва, тогда и только тогда, когда существует S такое, что V от XS равно единице.
И, соответственно, S читается только слева направо.
Но при этом оно читается непринудительно.
То есть мы можем начать с чтения, какие-то вычления провести, потом дальше читать и так далее.
Так.
Надо доказать, почему доказательства эквивалентности определений.
Так, значит, через нетермируемую машину тюринга влечёт сертификатная.
Здесь в сертификат будем записывать, какую из допустимых команд нетермируемой машины тюринга нужно выполнить.
Ну и дальше, соответственно, дальше её выполнять.
Ну и это дальше.
Эта самая V работает как универсальная машина.
Ну а, соответственно, если из сертификатного выводить то, которое через машины,
то получается, что мы каждый раз вместо чтения нового бита сертификата пытаемся его недетерминированно угадать.
Вот.
Да, ну, например, значит, пример, что для задачи PF сертификатом будет сам путь.
Значит, для сильной связности сертификатом будет набор путей для каждой пары вершин.
Так.
И теперь мы подошли к очень интересному моменту.
То есть, если помните, то в случае с NP, кроме вопроса о том, равны ли P и NP, был ещё вопрос о том, равны ли NP и CoNP.
В ней есть некоторые основания полагать, что они неравны.
Ну и интуиция там, например, такая, что когда у нас CoNP, нам как бы нужно доказывать отсутствие сертификата.
Как это делать, совершенно не ясно.
Вот, казалось бы, такая интуиция должна и для логотипической памяти работать, а вот однако же не работает.
Значит, здесь возникает теорема иммермана селепчения.
Теорема иммермана селепчения говорит, что NL равняется CoNL.
Вот.
И как раз через сертификатное определение мы сейчас будем её доказывать.
Надеюсь, за сегодня успеем.
Так, значит, идея.
Нам достаточно доказать,
что дополнение к PATH.
Значит, дополнение к PATH, то есть это множество троек GST,
граф и две вершины, таких, что в графе G вершина S недостижима из T.
Ой, наоборот давайте.
Конечно, не важно, но это для единобрания вершины T недостижима из S.
Надо сказать, что дополнение к PATH лежит в NL.
Значит, тогда если у нас A лежит в CoNL,
то A с чертой лежит в NL.
Тогда, соответственно,
А с чертой сводится к PATH.
Ну и тогда A сводится к PATH с чертой.
И, соответственно, если PATH с чертой лежит в NL,
то и A лежит в NL.
Значит, тогда получается CoNL вложено в NL.
Ну и, соответственно, симметрично получаем, что NL вложено в CoNL.
Вот.
Так, значит, как мы это будем доказывать?
Нужно научиться предъявлять сертификат отсутствия пути из S в T.
Вот, соответственно, пусть мы откуда-то знаем количество вершин, которые достижимы из S.
Так, тогда недостижимость T.
Читая недостижимость T, можно получить так.
Значит, недостижимость T можно получить так.
Так, давайте вот это количество обозначим.
Количество с, значит, вершин, которые достижимы из S.
Значит, можно предъявить C вершин достижимых из S, среди которых нет T.
Вот.
Тогда, соответственно, раз T не входит в множество достижимых, значит, оно недостижимо.
Так, значит, при этом просто так предъявлять нельзя.
Нужно доказывать достижимость.
Ну и, соответственно, предъявлять вместе с путями из S в T.
Также нужно проверять, что достижимые вершины не повторяются в этом списке.
Значит, для этого они предъявляются в порядке увеличения номеров.
Получается, что тогда можно проверять коэффициентность на логарифимической памяти.
Значит, как это делается?
Ну, смотрите, вот у нас есть вершина, потом путь из S до нее.
Значит, давайте как-нибудь я это схематично покажу.
Значит, как выглядит сертификат.
Значит, тут будет сначала некоторая вершина V1, значит, потом путь из S до V1.
Значит, потом совместная вершина V2, которая больше V1.
Значит, потом путь из S до V2.
Ну и так далее.
А как мы это читаем?
Мы читаем V1, дальше проверяем этот путь.
Значит, допомнили V1, проверяем этот путь, смотрим, что тут V1 встречается в конце.
Дальше читаем V2, проверяем, что V2 больше, чем V1.
После этого забываем V1 и проверяем теперь путь из S до V2.
Дальше нам будет V3, проверяем, что V3 больше, чем V2, проверяем путь и так далее.
И еще у нас есть счетчик, счетчик числа проверенных вершин.
Значит, соответственно, когда этот счетчик достигнет C, то мы останавливаемся.
А еще каждый раз мы очередную вершину сравним с T.
Значит, нужно проверять, что новая вершина не равна T.
Соответственно, мы это все проверим, если действительно все сошлось.
Значит, порядок правильный, пути правильные, вершина T не встречается.
И, соответственно, количество достигло C, то это означает, что мы нашли C различных вершин,
которые все достижимы из S. А раз их всего, значит, T не достижим.
Ну, это, соответственно, что здесь осталось.
Так, давайте я так условно здесь нарисую, что это сертификатная лента вот так вот разделена на кусочки.
Так, значит, соответственно, что здесь получается нужно.
Значит, нужно учиться определять число достижимых вершин.
Ну, предположим, значит, C и T. C и T это число вершин достижимых за не больше, чем и шагов.
И тогда идея такая.
Значит, C будет равно Cn, ну и даже Cn-1.
Вот, это достижимых из S, давайте тоже опишем, достижимых из S.
Вот, а C0, неизвестно, в чем равно, значит, C0 равно 1.
Конечно, нужно по индукции, значит, по индукции записать доказательства для, соответственно, там, C1, C2 и т.д.
Ну и соответственно, для Cn запустить предыдущую проверку.
Так, ну и как мы это будем делать?
Значит, пусть известно C и T.
Тогда для любой конкретной вершины можно доказать либо достижимость, либо недостижимость за и плюс один шаг.
Ну, смотря что будет верно.
Если достижимость верна, то, соответственно, будем доказывать достижимость.
Если не верно, будем доказывать недостижимость.
Вот, значит, достижимость.
Ну, просто можно предъявить, можно предъявить путь, точно так же, как мы уже делали.
Значит, недостижимость, нужно предъявить C и T, вершин достижимых за не больше чем и шагов.
И проверить, что из них не ведет ребра в данную.
То есть если у нас уже есть такое число вершин, то что значит, что у нас вершины достижимы и плюс один шаг?
Это означает, что в нее идет ребро из какой-то вершин, которые достижимы за и шагов.
А эта вершина должна быть в списке всех вершин, достижимых не более чем за и шагов.
Но если мы все перечислили, и ни заодно не ведет ребра в данную, то значит, это уже точно,
значит, наша точно за и плюс один шаг недостижима.
Ну и, соответственно, теперь можно сертифицировать C и плюс первое при известном C и T.
Если просто для каждой вершины предъявлять сертификат либо достижимости,
либо недостижимости, ну и, соответственно, и подсчитывать достижимые вершины.
Ну и, соответственно, и подсчитывать достижимые вершины.
В целом, я попробую написать, как будет, как один блок будет выглядеть.
Тут к какому-то моменту доказательства C и T, доказательств того, что C и T равно тому-то.
Так, соответственно, дальше будет доказательство достижимости или недостижимости.
Достижимости или недостижимости, там V1, дальше, соответственно, такое же там для V2, ну и так далее.
И получается, что все это вместе, все это вместе получается будет доказательством, доказательство C и плюс один.
Да, именно мы идем по вот этим доказательствам и, соответственно, подсчитываем, какие у нас достижимости.
Соответственно, теперь вот это все вместе будет как бы началом на следующем этапе, дальше будет доказательство C и плюс два и так далее.
Ну а в самом конце, когда мы дошли до ценного, мы еще дописываем вот эту штуку.
Ну вот, в результате нам в каждый момент нужно хранить не очень много.
От всего предыдущего нам нужно оставить только размер C и T, то есть будет логариф.
Теперь что нам здесь нужно? Ну, счетчик для переменных, V1, V2 и так далее.
Еще один счетчик. Одно доказательство. Либо это у нас путь, ну где там нужно еще три счетчика.
Либо это у нас вот такое доказательство, но оно немножко больше.
У нас есть счетчик для вот этих вершин, счетчики для достижимости, ну и еще там какой-то вспоминательный переменный, чтобы проверять, что нет ребра.
Вот, значит в результате получается, что можно на логичной памяти проверять, что пути нет.
Отсюда получается несколько других языков, которые лежат в NL, благодаря тому, что NL равно QNL.
Так, ну, например, двудольность.
Значит, bipartite, то есть множество G таких, что G – это двудольный граф.
Потому что есть теорема, что G удолен тогда и только тогда, когда в G нет ничетного цикла, нет ничетных циклов.
Ну а, да, то есть проверка того, что есть путь, нечетные длины или циклы, она точно так же делается, как и все в NL, как и проверка пути.
Вот, соответственно, вот это вот нет, это как раз будет QNL, ну а поскольку NL равно QNL, значит это лежит в NL.
Ну а, то есть нет ничетных циклов, это QNL-свойство, значит NL-свойство.
Вот, значит, двудольность лежит в NL, ну и, на самом деле, два SAT.
Два SAT – это множество таких phi, значит, phi – это выполнимое 2 KNF.
Вот, но про это подробно обсуждать сейчас нет времени, да, значит, идея такая.
Значит, идея такая, что мы строим по KNF-граф, значит, это вроде обсуждалось на семинарах или даже на лекциях, кажется, на семинарах.
Значит, по disjunct-у, значит, х или у, значит, строим два ребра.
Значит, строим два ребра из ни х в у и из ни у в х.
Вот, ну и тогда утверждение, утверждение, что, значит, граф, ну, то есть 2 KNF выполнимо, 2 KNF выполнимо.
Значит, тогда я только тогда в этом графе, значит, в этом графе нет цикла, который содержит одновременно P и не P для некоторой переменной.
Вот, ну и опять же, да, вот это отсутствие цикла, значит, отсутствие такого цикла – это ко-NL-свойства, а значит, и NL, поскольку NL равно ко-NL.
Вот, ну и также эти, да, значит, также эти, значит, эти языки являются NL-полными.
Вот, ну, например, например, для двудольного, для двудольности.
А, нет, сейчас, подождите, я неправильно сказал, то, by-partit, если неориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный, то, если не ориентированный,
то, если не ориентированный, то, если не ориентированный, то, если не ориентировальный, то, если не ориентировальный, то, если не ориентированный, то� это если не ориентированный путь лежит у sunshine, потому что там же неориентированный путь нам надо проверять.
Так.
надо переформулировать. А давайте вот что, просто вот так, напишем дек.
Дек, да, значит, недвудольный, да,
арграф гез циклов, да, так, тогда вот это вот надо убрать, да, и просто, да, что нет циклов,
значит, нет циклов это какое нл-свойство, да, значит, е нл-свойство,
вот, ну и тогда, собственно, для, соответственно, для дека,
значит, для дек, ну, в принципе, можно просто исходный, да, значит,
граф, который строится по машине, циклов не имеет, вот, и, соответственно, добавим,
значит, добавим ребро из принимающей вершины в начальную, тогда, соответственно, в таком
графе, в таком графе нет циклов, значит, тогда и только тогда, когда, соответственно,
ну, машина, ну, то есть, когда принимающие состояние недостижимо, принимающее состояние
недостижимо, вот, ну, это как раз будет кое нл, то есть, в графе нет циклов, тогда и только тогда,
когда там исходная житва а из кое нл, ну, вот, значит, соответственно, кое нл мы сюда свели,
да, раз нл равно кое нл, то он будет и нл полно, вот, так, ну ладно, значит, надо заканчивать,
спасибо за внимание.
