Начало, ну да, это будет пункт 14.6, кажется, нашей программы, да, потому что 45 это была реализация
function. Значит, std вариант и его реализация. Сейчас будет весело. Ну, это повеселее, чем function
Зачем он нужен-то? Сейчас, подожди, сейчас мы посмотрим, как его используют.
У нас был union до этого. Вот, и мы поняли, что union позволяет хранить несколько объектов на одном
и том же участке памяти, вероятно, меняя один на другой. Вот, ну, вариант это более умный union,
по сути. Ну, то есть, это такой тип, который позволяет вам хранить одно из перечисленного,
и при этом он безопасен в том смысле, что вы, вы либо правильно обратитесь к нему,
либо уж у вас исключение выйдет. Конечно, если ты, мы в прошлый раз видели, что у нас был union
с int, мы начали ему строку присваивать, и было secul. Значит, вариант появился только c++17,
и там, ну, нет, в принципе, не было больших препятствий, чтобы он появился раньше. Мы
прямо будем использовать некоторые фишки c++17 в его реализации. Ну, вот, ну, давайте,
для примера я что-нибудь заведу, int, запятая double, запятая std string. Вот, вот я завел вариант.
Так, сейчас я сразу же буду это пытаться компилировать.
Не, не, не, мы стараемся переходить на c++20. Вот, ну да, конструктор по умолчанию сработал,
это значит, что он принципизировал первый, скорее всего. Но я могу написать вот так,
потому что я не помню наизусть, что он делает, я же вас тоже не заставляю помнить, как конструкторе
что делает. Вот, ну, я могу пронициализировать его любым типом из перечисленных. Вот,
могу пронициализировать его пятеркой, тогда в нем будет храниться им. В том числе,
можно пронициализировать его abc и потом что-нибудь еще, и оно само сотрется. Да, да. Вот, ну,
давайте, я попробую обратиться к тому, что в нем лежит. Вот, я могу сказать, чтобы обратиться
к варианту, есть функция get, std get. Ну, как с tuple? Есть get по типу и get по индексу. Нет,
разные функции, одна для tuple, другая для варианта. Но для варианта, как мы делаем? Я говорю,
get int от v. Ну, давайте, я попрошу вывести, что будет. Мне сейчас выведут 5. Вот, но если я
попробую сделать get не от int, а от, скажем, чего-нибудь другого, от double, например. Сейчас
будет exception, потому что там не double на самом деле. Вот, exception, badVariant, access. WrongIndexForVariant.
Ну, ладно, я могу положить туда что-нибудь другое, например, строку.
Чудесным образом вариант поймет, что ему подходят, ну вот, что из трех возможных вариантов,
что он мог бы проницилизировать, самый подходящий это проницилизировать строку. По сути, здесь
применяются те же правила, которые при разрешении перегрузки применяются. А у него,
он сейчас звездочка справа, а надо выбрать, что это такое, int, double или std string. Ну вот,
он выберет std string, так что теперь там будет std string. Разумеется, я могу после этого сказать там,
не знаю, что-нибудь еще, там 3.0, и он выберет значит double. Вот давайте я, кстати, нет, если я так
напишу, то это будет непонятно. Сейчас, как бы мне сделать? Давайте я скажу, что у меня не double,
а float, но я сейчас классический пример хочу с неоднозначностью. То есть, если вот я ему скажу,
у него там тип float, а я ему попробую double прислоить. Вот. Вероятно, он сейчас скажет,
что неоднозначность очень всё понятно, конечно, да. Ну, это ce или это? Ce, конечно, да. Ну,
возможно, ce-lang что-нибудь более приятное скажет. Vibe overloaded. Да, ну, значит, не получается.
Да, ну, в общем, не смог он. Видимо, по какой-то другой причине, но так или иначе не смог.
Вот. Ну, вот если я ему бы сказал здесь double, а попробовал присвоить float,
то сейчас-то он, наверное, смог, я надеюсь. Да, вот так вот. Ну, там, на самом деле, просто у него
налевешено шаблонных всяких enable fov и прочего, что-то включает, если там не может,
но по сути, это работает при разрешении перегрузки. Вот сейчас он double содержит.
Есть ещё такая функция holds alternative. Сейчас, как это мы не говорим,
я немного вперёд забежал и сделаю стд вариант. Давайте посмотрим на preference.
Значит, вот такая функция holds alternative. Она просто позволяет вам проверить, правда ли,
вариант содержит то, что вы думаете. Верно ли, что он держит что-то похожее на double? Нет,
верно ли, он держит либо int, либо double, либо string. Одно из трёх. Это буль, который вперёд, правда,
потому что он double держит? Да, да, да. Почему alternative? Ну, потому что... Ну, стд holds звучало бы, как будто не очевидно, что это именно варианты можно применить.
Ну, и вот такая, что он назвает. Какой из альтернатив сейчас имеет место? Альтернативы три, но сейчас будет один,
то есть это пронициализировалось double. Он решил, что это double. Если бы я так сделал, то, разумеется, был бы false, потому что в нём лежала бы строка.
Ну, и я могу легко, значит, забрать у него строку. Кстати, я могу вот что сделать. Я могу сказать std get, но я тебе скажу,
автор s равно std get от std string от std move от v. Как мы любим. Вот, что произойдёт? Ну, он заберёт у него строку, просто move нет из варианта строку,
в варианте останется пустая строка, а у нас будет настоящая строка. То есть это будет std get. Да, get он перегружен для lvalue, lvalue как полагается.
То есть, если мы вызываемся от lvalue ссылки на вариант, он возвращает нам, ну, возвращает нам немножко странный тип варианта,
не важно, что это такое, но для нас важно, что он, по сути, возвращает нам ссылку на t и lvalue ссылку. Значит, мы её скопируем, если будем так инициализировать.
А вот если мы от lvalue варианта вызвались, то он вернёт нам lvalue ссылку. Соответственно, мы сейчас соберём у него строку, и можно проверить, что...
Ну, давайте я проверю std seout s.length и ещё проверю std get, std string. Вот, v.length.
А, правда ли, что мы можем выяснить? А в temp test это нормальный ловень? Нет, потому что lvalue есть ссылка. В смысле, если std loop есть, вот просто at temp test, то это даёт нам ссылку на его string.
Да, если бы мы его сделали, а потом поменяли бы string на что-то другое, всё сломалось бы. Боюсь, что нет, потому что мы получили std вариант альтернатив.
Скорее всего, вариант альтернатив хранит именно тип просто.
Хранит, то он хранит, только... 100. А, вариант альтернатив t. Да-да-да, всё нормально, всё нормально было бы, всё нормально.
Вариант альтернатив t – это type name, вариант альтернатив type, а type там прописан так, как надо, очевидно. То есть это должно нормально работать.
Давайте проверим, что всё правильно, как я и думал. Вот, 5, 0, 5, 0. А, ну да, то есть я забрал у него 5, 0, это и раньше было, я забрал у него строку.
Вот, теперь моя строка имеет длину 5, а та строка, которая в варианте лежит, имеет длину 0, потому что из неё будет.
Вот. Ну, в общем-то... Можно ли хранить ссылку на объект, который там лежит? Можно, она сломается, когда ты поменяешь тип, видимо.
Ну да. Логично. И вернётся в нормальный стандарт. Что если я в качестве альтернатива хранил вариант, у которого удалён move-оператор? Это будет...
Не, ничего, если ты... В смысле, RG. Ну, если я пытаюсь его move-нуть, он же не сможет понять, что это ошибка компиляции.
Ещё раз. Не сможет понять.
Если у меня одним из вариантов структура, у которой запрещен move-ующий оператор. А я написал вот такую строчку.
Да. Он просто пойдёт... Он должен отстанцировать шаблон, и в момент отстанцирования увидит, что нету оператора. Конечно же, это будет C, а не RG.
Потому что он уже знает, что я к стрингу пытаюсь отставать.
Да, потому что вот здесь ты делаешь к стрингу от V.
А почему это будет C? Если же нет move-а конструктора, то конструктор копирования будет.
Если написать равно нелит, то он скажет, что нет.
Да, хорошо.
Если написать равно нелит, то это будет C. Ну да, понятно, если у вас нет move-а, но есть копия, а про move ничего нет, то это копирование.
Нет, понятно, что это всё C. Такие вещи – это всегда ошибки компиляции. Такие вещи не бывают в runtime. Ошибками не победают.
Повторить какие вещи.
Какие вещи?
Ну...
Что мы обсуждаем?
Непонятно.
Когда нету какого-то методового типа? Когда какой-то метод удалён?
Он же формально удалён не у V, а у...
У объекта. Это не важно. Не может вообще...
В какой бы ситуации вы ни находились, чтобы вы не писали на плюсах, если у какого-то типа отсутствует какой-то метод, то это может привести либо к CE, либо...
Ни к чему не привести. Не может отсутствия метода привести к RE.
Отсутствие неличи методов – это compile-time понятие. В runtime-е не бывает такого, что что-то пошло не так, за то, что метода нет.
Окей.
Ну разве только это если pure-virtual-function-call, который лучше не вспоминать.
Вот. Вы помните, что как pure-virtual-call?
Помню, что как pure-virtual-call, как его позвать не помню.
Ну ладно, не важно.
Ну там типа прикол в том, что ты можешь описать определение этой индивидуальной функции и потом...
Ну не важно. В общем, так. Ещё одна вещь, которую можно делать с вариантом... Да, ну...
То есть, чё самое интересное про вариант? Он каким-то чудом, когда мы его инициализируем, он выбирает, какой из типов сейчас мы создали.
Когда мы делаем ему присваивание, он удаляет правильно тот тип, который в нём сейчас лежит и...
Конструирует.
Конструирует новый, опять правильно выбирает каким-то образом...
А если там...
Какой тип мы сейчас у него создали?
Если мы присваиваем такой, что он сейчас, он же не будет конструировать заново, он именно скопирует.
Да, он присвоит, да.
Удаляет.
Сделает правильно всё.
В смысле, он не будет уничтожать?
Да, он... Ну как и есть.
Он...
Всё сделает, как будто там лежит реально строка просто.
Да, как будто он просто тоже тип.
А вот...
Бла-бла-бла-бла-бла...
Да, если...
Ну, тут ещё есть случаи, когда у него ничего не лежит.
Value is by exception.
Это если вы пытались в него что-то сконструировать, а оно бросилось в включение и получилось, что в варианте ничего.
Тогда он называется Value is by exception.
Вот. Ну вот если...
Бла-бла-бла... Короче, если правый...
У правого такая же интернатива, как и у левого, то присваивает просто значение.
А если выбраться в исключение, то он не становится value-less, а просто...
Value зависит от...
Ну, в общем, сложно.
Давайте ещё одну интересную...
Понятно, что когда он уничтожается, всё в конце правильно очищается.
Ещё можно делать get по индексу, а не только по типу.
Ну, как гостиупло, в принципе, get.
Get по индексу.
Size t.
А...
Значит, как это работает?
Ну, просто вы говорите, я хочу взять и по альтернативу нумеровать с нуля.
Аналогично, если вы не отгадали, то будет исключение вам.
Вот. И что ещё есть интересного, это функция visit.
Вот сейчас я сделаю, конечно, интересное дело.
Смотрите, вот давайте я так поступлю.
Вот давайте я заведу вектор вариантов.
Давайте я скажу, что вот этот вариант, на самом деле, это у меня такой тип.
Вариант t.
Это вот такая вещь.
А почему, кстати, get holds the iterative?
Почему это всё внешние функции?
Я чего-то не понимаю.
Почему это не методы?
Ну да, ну это типа очень странно.
Почему не в.get, а из td.get, а из td.get?
Не могу сходу ответить.
Наверное...
Синтексичнее тоже вполне возможно будет делать.
Я думаю, что есть какая-то причина, но вот сейчас я её не могу назвать.
Мне кажется, что там какие-то проблемы в реализации этого звала.
Можно погуглить, а может быть, мы это позже поймём.
Может быть, там была какая-то проблема, но я сейчас не могу моментально ответить.
А может и нет, может, почему-то решили, что так лучше.
Да.
Сдвизит.
Сдвизит.
Так вот, смотрите, давайте я возьму sd-вектор из вариантов.
Придётся мне назвать его vec от 5.
И скажу, что vec0 это 4, vec1 это abc, vec2 это 3.0, vec3 это...
Вообще, зачем я так делаю? Я же могу сказать вот так, я могу сказать, что это vec
и пронициализировать следующим образом.
3, abc, 5.0, abcde и ещё что-нибудь.
Минус один.
Что-то уже интересно.
Упадёт.
Может, double?
Нет вектора.
А, ну написано, потому что иначе пришлось бы писать x.template в мембрге.
Ну да, да, да, да.
Логично, логично.
Да, это правда.
А почему пришло это?
Да у нас шаблоны нет.
Потому что нет, это шаблоны.
У него было бы можно знать, если оператор меньше, против этой штуки.
Класс.
Да, да.
А в чём у нас CE там было?
Никакого CE, просто вектор забыл заявить.
Всё нормально, он создал вот такой вектор из вариантов.
Смотрите, как классно.
У нас вектор из пяти вариантов, и в каждом варианте разные типы.
Теперь я хочу сделать следующее.
Я хочу вывести все эти варианты.
То есть я хочу сейчас написать такой цикл и сказать,
для каждого элемента варианта вывести его сяут.
Просто вывести.
Не поможет.
Во-первых, так совсем не...
А во-вторых, будет это вариант.
Всё нормально.
Но цялость у него не определён?
Или определён?
У варианта нет, конечно.
Мне можно сказать get от...
Но надо понять от чего каждый раз.
А, ну вот, собственно, и visit, да?
Значит, visit это такая штука, которая позволяет вам взять
и для данного варианта выполнить одним функцию.
Ну вот, а...
Смотрите, давайте я напишу for.
Ух, ну, напишу for констафта в векторе.
Я сделаю следующее.
std visit.
std visit.
Значит, вариант.
А дальше функцию, которую я хочу применить.
Ну, как я это сделаю?
Да.
Я просто напишу обобщенную лямину.
И что она будет делать?
Она будет делать std seout x.
Что?
Ну...
Мы же ничего не сделали.
Как ничего не сделали?
Я просто вывел все элементы варианта.
А что?
Ну типа...
Мы же ничего дополнительного не сделали.
Мы опять сказали авто, и теперь это работает.
Один раз не войти, а второй раз сказать авто-авто.
Так а как тебе вы...
Тебе хочется для всех элементов варианта сделать одно и то же действие?
Ну, у всех оно разное.
Я про то, что авто...
Не очевидно, почему авто разгадывает.
Да, стоп.
Как авто вариантом лежит.
Так, потому что visit так устроен.
Ну, функция visit, она принимает...
Визит.
Он принимает первым аргумент варианта,
а вторым аргументом функцию,
которая...
Шаблон функции.
Да, которая должна уметь обрабатывать все типы, которые в варианте.
Давайте...
Невидно шаблонные, не перегруженные?
Нет, можно перегруженные.
Давайте посмотрим на visit.
То есть главное, чтобы она была на все типы?
А я перепутал только порядок.
Значит, сначала функция, потом вариант.
Я не знаю.
Вот смотрите.
Есть первым параметром визитера,
вторым параметром...
А еще переменная число вариантов.
То есть, на самом деле, я мог написать CD-визит без цикла.
Вот это все и элементы вектора подряд.
Ну, вы не знаете, сколько элементов вектора?
V0 запятая, V1 запятая, V...
А, нет, нет, нет.
Интеллектуально.
Вот.
Что она делает?
Она просто берет вот этот визитер,
применяет ко всем элементам варианта.
То есть, я беру stdinvoke,
ну, потому что это же может быть и указатель на член.
За что?
Да, берет этот визитер
и берет stdget от из.
А что такое из?
Сейчас, может быть...
Кажется, не один указатель.
Не знаю.
Ну, если есть из, значит будет...
Из.
Это stdforward, вариант basis, vax, index.
Реально.
Ну, every type is variant basis.
Это, значит...
Да.
Кстати, основной вариант только тесно.
Честный тип должен создаваться, да?
Что такое чистый тип?
В смысле, можно ли отсылок?
Нет, ну можно не туда что-нибудь положить.
Указатель, конечно, можно.
Вот с константами и сосылками будут приколы.
Но константу тоже можно.
Вот ссылку уже проблематично.
Ну, в плане 20 часов можно или просто нереально?
Не могу сходу сказать.
Может быть, что нереально.
Ну, вот тут есть примеры.
Ну, давайте я...
Давайте, во-первых, проверим, что это работает.
Более плохо.
Действительно все...
Да.
Как это работает?
Непонятно.
Еще раз вопрос.
Эта шаблонная функция должна уметь принимать все аргументы...
Все оперативные варианты, да.
Ну да.
Вот там есть более странные примеры еще.
Там не лежит.
Давайте посмотрим действительно вот эти примеры.
Тут есть поинтереснее.
Во-первых, ну вот этот вот...
Вот это примитивный пример, который мы только...
СТД визит, вот по сути то, что я сейчас сделал.
У меня есть вектор из разных штук.
И я каждый из них вывел просто.
Я мог бы, например, сделать так.
Взял и удвоил их все.
Да, ну то есть, смотрите, я такое говорю.
Вот давайте я скажу...
Ух!
СТД вектор.
Ну давайте я скажу авто...
Я не знаю, авто.
Век два равно век.
И теперь век два.
Век два.
Век два.
Век два.
Век два.
Плохо.
СТД векто.
Вариант Т.
А почему?
Век два.
А как я?
Мне надо положить в него.
Век два.
Сейчас сделаем плейсбек.
Что?
А вот что.
СТД визит.
СТД визит.
Вот.
Такой вещи.
Авто двойной персант Х.
Стрелочка.
Вариант Т.
Фигурная скобочка открылась.
Ретерн.
Х плюс Х.
Запятая.
В.
О.
Авто двойной персанты это же универсальная ссылка.
Универсальная ссылка, да.
Смотрите, что я сделал.
В.
Из первого вектора.
Посетил соответствующий вариант.
С такой функцией.
Которая принимает абы что.
А возвращает снова вариант.
Пронициализированный.
Удвоенным значением.
Который лежал в старом варианте.
Теперь я могу вот этот цикл.
Взять и скопировать.
Только теперь уже буду идти
Поверх два.
И давайте проверим, что просто все
Применится
Удваивание.
Я новую строку выведу.
Давайте посмотрим.
Действительно.
Получилось.
Вот.
Никто еще никогда так не радовался,
что у него получилось сложить два объекта.
Зачем мы принимаем
так универсальные ссылки?
Почему не конст?
Чтобы можно было теоретически туда
подставить временки варианта.
Ну да, типа...
Конст аута имперсан принимает
все что угодно, а аута...
Сейчас, это все нормально?
Вдруг он его убьет?
Нет, нет, он не убьет.
Ну, смотри.
Да, ну, если...
Да, поскольку я здесь
V передаю, а не std move от V,
то у меня все равно
копируется все.
Вот если бы я std move от V передавал,
то он бы ему отдал бы этот X
move'ом.
И что он тогда делал с X plus X?
В смысле? В чем проблема?
X plus X понятно, что делал.
Просто вариант бы потерял.
Ну давайте я продемонстрирую
std move.
Что происходит?
Можно?
Сейчас, ну, visit просто
в функцию свою
забирает
аргумент по R-value ссылке.
Ну, то есть, move'ет его из варианта.
То есть, вариант опять пустой остается.
В плане, если я посылаю,
видал, что никому не случилось.
По R-value ссылке.
По R-value ссылке.
Ну, случается, что X plus X
что это будет?
В плане... Вызывается...
от каждого...
от соответствующей штуки,
которая в варианте лежит.
С правильным типом.
Она от R-value ссылки.
Если в момент
передачи
в этот визитор,
ты заберешь
у варианта этот X.
Почему?
Вы думаете, что это инициализация параметров?
Это X от V просто происходит.
Ну, все, X...
А от того, что в V лежит,
с правильным подставленным.
А у X-value ссылку не принимаете?
Конечно, поэтому она и не универсальна.
Я знаю, она не принимает X-value выражение
и вместо auto-амперсанда
будет стоять поста.
Ну...
Числи тип без ссылок.
Ну...
Ну что?
Ну тип выведется как
тип без амперсанда, да, а у X-value
тип с двумя амперсандами.
Ну...
Вывод типов работает, да.
То есть он замувает
непосредственно то, что лежит.
Да, то, что лежит.
Ну давайте, я не знаю, давайте...
Вот сейчас еще раз
проверим, что...
Зачем ему, если
агумент функции, это всего лишь ссылка?
Нелогично.
В смысле?
Мы хотим, чтобы объект забрался.
Так, давай это сделать.
Давай еще раз.
Вот то, что auto-амперсанда X.
Это R-value ссылка.
Ну...
Забирает объект.
Она может его забрать.
Она заберет его, когда ты что-то будешь использовать с ней.
То есть она заберет, если мы
создадим что-то от него.
Она бы забрала что-нибудь,
если бы там было написано after X просто.
Вроде бы
сейчас X
сейчас vector 1 не будет пустым.
Вот в этом, видимо, утверждение.
Я не уверен, я не буду переразить язык.
Так.
Но он будет из пустых строк, по идее.
Нет, мы, кстати, мы же у него ничего не забрали.
Из пустых чисел строк.
Почему?
Именно в данном примере.
Из-за того, что вы сделали X плюс X.
А, господи, у меня здесь V
const auto, а не просто auto.
Да, это жестко.
А вот теперь должно сработать.
А, почему не сработало?
Ну, const объекты, если мувнут, то ничего не будет.
А, потому что здесь должно быть
auto member sender. Вот, наверное, почему.
Так. Почему?
Нет, да, это уже неправда.
Это не должно ни на что повлиять.
Так кажется, что он не забирает ничего.
А зачем ему сейчас забирать?
А в какой момент он, чтобы забрать, должен быть
выдвинут конструктор копирования или оператор
мувающий оператор.
Он не выяснил ни разу.
Появляется тим, для которого мы можем сделать такую перегрузку,
которая забирает все данные.
Все.
Но сама по себе эта рисунка ничего не трогает.
Она просто тим.
Вот, если бы мы возвращали
рейтсер на CDMove от X
внутрь ляма, то CDMove мы забрали.
Да, мы забрали, потому что
CDMove принимает по ссылке,
значит, нужно было бы...
...
...
Можно вне этого места...
Да!
Да, я понял.
Да, я был неправ, значит.
Вот, надо, если нужно, писать.
Ну, давайте вот так и сделаем.
Забрали.
Вот сейчас все правильно.
Вот сейчас все так.
Забрал пять, оставил пять.
Все было прав, я был неправ.
Ну, теперь понятно, что произошло?
Господи, я понимаю, вы понимаете,
я так разговариваю.
Мы едем, мы едем, мы едем.
Сейчас, а почему, если мы там напишем const auto,
то не будет работать?
Потому что, если ты зваешь move, это const объекта,
я вас регулировал с каким-то чудом.
Нет, просто если ты move,
вызываешь const объекта, он не будет работать.
Это нет перегрузки
mov для const объекта.
Это-то ладно, а почему
вообще auto два амперсанта
компилируется в плане...
Почему, как он принимает по универсальной ссылке
без const константную штуку?
Что-что-что?
Рекол в том, что два амперсанта ему конфликт
на const reply.
Так, подожди, auto двумя амперсант,
auto const туда подставляется.
Конечно.
const не отбрасывается при выводе, типа.
Рекол еще там.
Тут, скажи, не в том, что ссылки,
а в будущем const reply они отдельно работают.
Да-да-да-да.
С const здесь не получится,
потому что этот move, он дает
const value ссылку, вот этот stdmove
от v дает мне const value ссылку,
и это не дает
возможности, ну, то есть здесь я получаю
const там...
const что?
const какой-то
тип два амперсанта, но move
не может работать как move,
когда он его возвращает.
Так, ну ладно,
короче, кто понял,
тот молодец.
Вот сейчас
внутри этого
visit, auto два амперсанта
и x,
x будет иметь тип
string или string два амперсанта?
String два амперсанта, конечно.
Тут либо кланк сошел в сумму,
либо мы чего-то не понимаем, в общем,
если бы возвращать x плюс x, у нас ничего не работало, да?
В смысле, не работало?
Ну, он бы не муялся, а если
return x, не stdmove от x, а просто x,
он бы не обмувывается, почему?
Кланк не понимает
мусьманчику. Нет.
Если здесь убрать, stdmove от x,
return.
Давайте посмотрим.
Ну потому что возвращаемый тип, это просто
принимаемый тип.
Можно просто его это...
Ну, давайте подумаем.
Возвращаемый тип, это просто вариант.
То есть он создает вариант от x.
А x это ребелью.
А x это лвл, да.
А на g-press плюс 11 у меня
stdmove. Я не знаю, что это значит.
Секунду, в плане x...
А 11 вообще есть?
Чего вот x это лвл?
Вас интересно видеть?
x это не лвл.
Вот здесь...
Х это лвл.
В плане выражения, да.
Да, он должен вернуть вариант
t, созданный от x.
Где x это лвл, давайте запустим.
Интересно.
А, стоп, это силенг. Я сейчас с силенгом
это подъехал. Силенгом, да.
Нет, не мувает.
Кланк не мувает. А у меня мувает.
У тебя кланк? У меня кланк.
Сейчас, может я чуть не правильно
писал? Может у тебя
Силенг 12.
У меня 13.
Давай...
Интересно.
Так, давайте г плюс плюсом еще проверим.
Там минус 11, ну или просто.
Да, ой, не то.
Тоже не мувает.
Сейчас я буду код сравнить.
Ну короче, я буду считать, что
все правильно и пойду дальше.
Видимо, мне повезло.
Не буду думать тогда.
Ну давайте, давайте.
А вот есть ли?
Вот внутри его функции есть разница?
Что нам дали?
Стринг? А, нет, есть, конечно,
разница.
Сейчас, секунду, а он
смувал только...
Последней строчкой, что он там
у нас стоит? Внизу еще в коль написано
века просто. Век 2.
И века, и 2, и еще века, да?
Она просто...
То есть, вот внутри тебя этой функции
мы могли написать
х равно 17.
Если бы это была функция
чисто только для стреков,
то мы могли написать х равно 17,
и это поменяло бы В.
Нет.
Что?!
Нет, сейчас, ну ты же по ссылке принял х,
ну да.
Я же фактически вот здесь принял
х, это ссылка, я получил
ссылку на то самое, что в варианте лежит.
Ну, давайте я скажу,
например, х...
Сейчас, нет, я все, я теперь стал понимать.
Потому что я все понимаю.
Я ничего не понимаю, почему это авто,
это... Давайте я вот здесь вот скажу,
например, х плюс равно х.
Ну, такая...
Да.
Ну, еще раз, х плюс равно х.
Это, вроде, для всех типов подходит.
Не подумай, персонаж.
Не подумай, персонаж, не подумай.
Да, неважно, можно
не вплетать сюда мупсимантику, пожалуйста.
Можно не вплетать сюда мупсимантику,
пожалуйста. Я хочу понять
варианта не мупсимантики.
Нет.
Мы вон там уже
задались вопросом,
представим мупсимантику, я ничего не понял.
Я же не возвращаюсь наружу,
не мупуя его.
Я не собираюсь забирать, я просто меняю
самым быстрым, как я получил вариант,
по какой ссылке.
Таким образом, у меня
х это
2k, а не вариант.
Потому что видит, ну, видит это дело,
он передает
лямбда функцию. Все, у меня удвоились
все, вроде, все удвоилось.
В первом век я во втором все пустил.
А, и это антайм-штук вообще, хорошо. Так, господа
хорошие, давайте
пойдем дальше, и
мы, это все, это все замечательно,
но наша цель сегодня
это реализовать еще.
Ну, не видит,
видит мы сегодня не реализуем.
Завтра, может, реализуем.
А вот основную идею
варианта, хочется
понять реализацию ее.
То есть, мы хотим,
ну, вообще, интересные
примеры, вот с видитом еще есть,
вот, например,
короче, сами посмотрите на них, они
очень великолепные, но
сейчас не будет.
Вот, давайте попробуем
реализовать вариант.
Вот.
Я для
этого, наверное, закомментирую все вот.
То есть, нормально нам что надо сделать?
Нам просто надо юниор сделать так, чтобы
обращались в угол.
У вас тут был пробок.
Значит, вот это
я закомментирую.
Так.
Так.
Сейчас я буду реализовывать
вариант.
И я,
ну, давайте, действительно,
вот, что-нибудь.
Нет, нет,
пока без оптимизации.
Просто вот, что мы хотим,
что мы хотим, чтобы было.
Какой вариант?
Он написан с кучей оптимизацией,
только не очень понятно, что здесь имеется
в виду под small object optimization действительно,
потому что все хранится на стейке,
видит так, а не на куче.
Значит, вот у меня будет
type name types, их много.
Мне нужно первыми эти выделять.
Сейчас подумаем, сейчас может
и понадобится.
Давайте посмотрим.
Что будет внутри?
Storage на или...
Ну, что-то такое.
Ну, есть
два варианта. Можно
массив чаров,
как мы любим.
А можно...
А какой у него размер будет?
И как мы будем
понимать, кто там лежит?
Ну, это...
Это не очень приятно.
В общем, можно сделать
чисто на storage,
чисто на storage
без union.
Но мне больше нравится с union.
Мне кажется, так оно
как-то элегантнее смотрится.
Но если вы хотите
реализовывать через
массив чаров,
пожалуйста, можете так реализовывать.
Здесь бы все работало.
Но в STL
реализовано через union.
Вот этой...
Вот у меня открыт
ST вариант, собственно, variadic union.
Так что я вас не обманываю.
Ну, вот это то, что мы сейчас напишем.
А что такое variadic union?
Самый способ
union запихнуть все types.
Type name
head. Вот тут уже мне потребуется
head и tail.
Tail.
Union.
Variadic union.
Правильно?
Нет, там tab несколько.
Что? Variatic.
Variadic.
Что в нем будет лежать?
Ну, в нем будет head
и еще что?
И еще union.
От всего остального.
Ваня, это сразу вопрос.
Мы же тут
тупо создадим кучу типов.
Ну.
Идея в том, что у тебя все лежало
на дридаш-пакете.
Вот оно и лежит на дридаш-пакете.
Это шаблонный union.
Шаблонный union, конечно.
Разрыв, разрыв.
Конечно, шаблонный union.
В прошлый раз я даже про него говорил.
Вкратце. Да, но мне нужен
это... Чего не хватает?
Зачем мы его внутренним типом делать?
Зачем мы его внутренним типом делать?
Чтоб не мешался во внешнюю
мирию или...
Ну да. Вопрос.
Почему это будет так работать?
Типа union внутри union?
Ну да. На одной и той же памяти
лежит либо первый тип,
либо union из остальных типов.
Но union из остальных типов, соответственно...
Так.
А чего не хватает-то, очевидно, еще?
Здесь.
Сейчас CE будет такой.
Если это так, попробуй стабилизировать.
Ну хотел бы, наверное, объект.
Да, мы все отцепилируем, чтобы не подставить.
Нет, не хватает базы.
В смысле, это база хранили.
Но нужно специализовывать вовно.
Union пустой.
После, наверное. Да.
Темплей.
Давайте от одного, давайте от одного.
Одного менее приятно.
Разве? Созвать пустой union?
Темплей.
Ну, может, type name T.
Давайте так, union.
Так, нет.
Какая-то неудача мне не нравится,
потому что она отличается.
Сейчас, мне нужен темплей.
Type name T.
От одного.
Да, конечно.
Ну, давайте сделаем union от одного типа, ладно.
Кстати, у нас все скопилируется,
потому что надо сначала его инстанцировать.
Ну, понятно, да. Он инстанцировал меня в мейне.
Ага.
My вариант.
Ну, локатор, потому что динамическая память не выделяется.
Нет, может, конечно, было бы прикрутить локатор,
чтобы констракт и дестрой делался правильно.
Но мы не будем.
А у standard variant есть локатор или что?
Нет, конечно, нет.
Это вообще не нормально было.
У standard variant есть quanti-chart,
который реализовал свой standard variant
и лучше, чем standard variant, на 20% еще поддерживает локатор.
Мы же в чеченой специализации должны писать
variadic-union и треугольные скобочки.
Ага.
Нет, от пустого же, наверное.
А вот от пустого ты пустой union создаешь?
Нет, давайте...
Чего пустой union?
А если пустой union есть?
Почему нет?
Да, пустой union просто.
Сейчас я немножечко переживаю
насчет синтеза.
Ну, так, у меня чего?
Ну, и мне нужно в поля чуть положить.
В поля варианта, собственно, я кладу что?
Variadic union.
Variadic union.
От моих типов.
Правильно, что мы пока что умеем, значит...
Только дышать.
Нет, мы умеем делать
SD-variant ничего.
Ну, понятно, что
под вариантом оно еще не понравилось.
Кажется, пустой нельзя.
Wrong number of tablet arguments.
Ну, да, это вероятно.
Одного получается?
Ну, плохо имплементация языков пасты.
Кажется.
Почему пасты?
Нужно будет что-то сделать вот здесь
и что-то сделать в этом месте.
Ну, да.
Нужно будет что-то сделать вот здесь
и что-то сделать вот здесь.
Нужно с хедом делать то же самое, что здесь, с последним элементом.
Если мы что-то
будем делать.
Хотя...
Да, ему не нравится, что я внутри класса
определяю специализацию. Ну, давайте вынесем из класса.
А что?
А я... В смысле, если один сделать,
то все нормально, все работает.
А почему ты говорил, что один
неприятно?
А если делать копии пасты?
Кажется. Я пока не уверен,
что мы там вообще писать собираемся.
Типа, можно ли обратиться к хеду,
если у тебя
или это, либо в реакцию?
Вроде можно.
Так, а я хочу... Недовольный человек.
Верно.
А, блин.
Что ж такое?
Недовольные скобочки
не нужны.
Может быть, тоже такие
негеточие?
Пустой дайдней?
Ну, а почему бы нет? Негеточие повторится хоть.
Оно, типа, будет менее приоритетным,
поэтому сработает.
Тут уже бред.
Двойная.
Ладно.
Можете...
Жестко подберегись к тебе.
О, Конст-Каст.
Ну, весело.
Конст-Каст воет звездочки?
От Конст воет звездочки.
Мой воздух никому нельзя трогать.
Не, кстати, Каст и Конст-Каст воет звездочки.
Никто не смеет трогать
мой воздух.
В смысле пустоту?
Я даже почтил бы, да.
А, вообще, не надо никаким
головы скобочек, просто вот так.
Легко.
А, ну да.
Логично.
Вот это более частный случай,
чем это.
Первое более частный случай, чем второе.
Поэтому, на самом деле, наоборот
должно... они в обратном порядке
должны идти.
В порядке влияет.
Во! Это общая версия,
а эта версия,
может, кстати, порядок не влияет,
но я лучше напишу на всякий случай,
что вот так точно заработает.
Это более общая версия,
это более частная версия, понимаете?
Поэтому
в случае, когда есть хотя бы один шаблонный
аргумент, он будет
выбирать.
Что?
Он больше не будет
выбирать.
Я запрещаю вам выбирать.
Иронка?
Мне нужно написать
здесь, что это специализация.
О, ну теперь-то наконец-то
заработает, я еще надеюсь.
Справить.
Так, окей, ладно.
Значит, это Юнион. Мы его храним в полях.
Один вопросик.
Если у меня есть
вариантик Юнион,
и я такой, точка хет,
и он такой, нет его,
я общий вариант.
Нормально, что у нас бывает хет,
а бывает не хет?
Так мы будем специализировать
какие-то методы только для 2 Юниона,
и все.
Сейчас.
Если у тебя так случится, что ты
к пустому Юниона обращаешь,
то это будет CE, действительно.
Но это же в Compile Time все будет разрешаться.
То есть ты никогда к пустому Юнион не будешь хет просить.
Если мы проинстанцируемся хоть
со скольки-нибудь типами,
ты уже можешь хет написать,
потому что это будет та версия,
которая проверяется.
В N запрещается
создавать себе от 0 типов.
Правильно делает.
Так, давайте
что-нибудь еще
реализуем, например,
ГЭТ.
Как реализовать ГЭТ?
ГЭТ это самое простое.
Как реализовать ГЭТ?
По интексу, надеюсь.
По интексу, да.
Ну можно по интексу, по типу.
Без разницы.
Надо просто эпоксильно посмотреть,
пока у нас не спалет CE.
Значит, template sizeTn
и
ну давайте, ладно, напишу sizeTindex.
Мы его тоже делаем внешней функцией.
И typeName, ну это и есть внешний, да.
typeNameT это то,
что вернется нам,
и typeNameноготочие types
это типы, которые варианты.
Т, амперсант, ГЭТ.
Ну тут нужно
4 версии.
Т, амперсант, конст, амперсант,
Т2, амперсант, конст, Т2, амперсант.
Это просто независимо
свойства конст
и свойства
2 амперсанта сочетаются.
Нет, ну я тебе писал уже
сюда LL и что там такое.
Нет, свойства, просто
формально все свойства конст
и все свойства
LL и ссылки меняются одновременно.
Вот и все.
Значит, мы что принимаем?
Мы принимаем...
Ну да.
Ну да,
ну она просто...
Типа она просто в губу идет и что?
Нет, у меня можно взять
поле.
Не, Маня,
ты переводишь поле, она все равно просто будет...
Так, вот я
говорю, вот я взял Get
и хочу вернуть
T по индексу, индекс.
Че мне надо здесь
написать?
А почему остальные
даем к шаблонной кон...
они его выведут сами?
Ну конечно.
Ну вариант же от каких-то типов.
Не, я про T, это что?
Это то, что мы вернем, да.
То, что мы вернем, компилятор
сейчас выведет, потому что я же напишу
компилятор, что-то.
Вот индекс нам придется
передавать, а T он
увидит.
Тоже выведет, конечно.
Но я же о конкретном варианте
буду звать.
Как мы будем
понимать?
Вот и вопрос, как мы сейчас будем понимать?
Вот что нам нужно здесь написать?
Нам нужна специализация для первого совпадающего...
А, нет, это не то.
На самом деле нам
надо просто хранить в варианте...
А какой индекс у нас?
В смысле?
Не понял. В смысле?
В варианте
буду помнить число, какая из
альтернатив сейчас... Сейчас жива.
А для гета нам не нужно?
Что? Зачем нам это для гета?
Нам это не нужно.
А, для гета?
А очень просто, я сейчас просто
поспроверю, правда ли мой...
Я сейчас напишу, если
индекс,
но это должна быть функция друг.
Понятно.
Я в чем проблема
не хранить эту штуку вообще?
Ну а как?
Если сделаешь без нее, молодец.
Если мы сравним нулю, ну,
нуля почитаться туда, да?
Нам нужно проверить, что мы
правильно идем. Как ты поймешь, что ты
дошел до нужного типа?
Не-не-не.
Если у тебя нету в варианте
поля, который говорит, какой у тебя сейчас
индекс. Мы сейчас по индекс
уходим, по сайсте. Это мы поймем.
Мы поймем, что мы дошли, но мы не поймем
правды или что сейчас вариант...
Так в этом и вопрос, да.
Нужно, короче, исключение выкинуть, если мы...
Если мы дошли...
Мы же не должны делать
get убейку. Мы должны ему кинуть
exception, если он не обгадал
номер.
Иначе мы ничего не выиграем.
Нет.
Если сейчас активный тип,
не тот, которого он попросил.
Поэтому нам надо проверить,
правда ли... Так, значит, что я сейчас написал?
Friends здесь надо сказать.
А если
v.index
не равно
вот этот индекс,
причем я не могу тут написать и в
деспорте, потому что
index это runtime вещь,
index маленькая,
то, значит, throw
std, bet,
variant,
access.
Вот.
А, иначе, что сделать?
Return, что?
Get, index-1.
Ну...
Ну,
здесь надо бы
в самом...
Вот тут
я не хочу здесь рекурсию организовывать,
потому что рекурсию надо организовать вот здесь.
В самом
union-е давайте
напишем функцию, которая делает...
Во-первых, нам понадобится функция get,
ну а потом нам еще понадобится функция put,
как мы вскоре выяснили.
Давайте напишем функцию get в union-е.
Metamget, который
как раз
ну вот
у этого union-а просит
соответствующий тип, то есть
это будет
шаблонная функция
опять,
template, type name,
size t,
index,
type name,
t,
t,
versant,
get,
on,
ничего,
без параметров.
И что она будет делать?
Ну, если
if constexpr index 0,
возвращаем hat.
Да, if constexpr,
уже здесь можно constexpr,
if constexpr index
равно 0,
то
return hat,
а иначе
тут вот я должен else писать,
потому что у меня есть constexpr.
tail.get
return
tail.get
и вот тут мне
надо писать template,
потому что
это зависимое имя,
иначе они будут неоднозначны,
с оператором меньше.
template.get,
index,
minus 1,
нахрена?
куда передаём?
в get
потому что он должен понимать,
что возвращается, иначе не сможем написать
возвращаемый тип.
Ну, template я не передаю
в качестве параметра, я просто
t он восстанавливает.
Да, и он восстанавливает.
Чем повреждут t & %?
А где?
Вместо t & %?
Да.
Кажется, что да.
Кажется, что так должно работать.
Расход поменьше.
Да, действительно.
Одновременно их.
Это нормально?
Кажется, должно работать.
У нас сейчас шаблонный тип,
у которого есть шаблонный union,
у которого шаблонный метод.
Ну, авто анкерсант
так же как и t,
анкерсант это нормально.
Вот, хорошо, теперь мы можем...
А, теперь у нас...
А если мы попросили get
от больше, чем
pro было?
Что здесь должно произойти?
No such index.
А как мы это поймём?
Стоп, а почему pro вообще?
А, потому что мы не можем...
Что?
У нас нет функции get, которая берёт
индекс переменной.
Нет, индекс только
compound time может быть.
Тогда можно не pro, а просто ce, всё нормально.
Ну, значит, что-то не дойдёт.
Если может ce, то можно...
Он же сам сюда не придёт.
Мы хотим ce, ce это лучше, чем re.
Чё мы должны...
Мы пустом union не говорим.
Делить.
Афа...
Чего-чего-чего?
Я вообще не показал, зачем...
Ну, по ощущениям как...
В варианте grand они не после
такой числики созданы.
В варианте grand.
Вариант ради чего?
Мы пока вообще не говорили о чём.
То есть кажется, что он
создан для более хитрых вещей,
и нам всё открыто.
Он создан для того,
чтобы ты мог хранить
одно из нескольких,
чтобы у тебя не автоматически
бы оно освобождалось, подчищалось правильно,
когда ты меняешь одно на другое.
Чтобы у тебя не было ub,
когда ты прислаиваешь.
Была строка, а стала int.
Илья, пусть у меня
вариант
от четырёх аргументов.
Я передал ему пять
число. Вот что он сейчас
пытается сделать.
Он такой... Констекс продали,
проверили, что не то, перешли,
опачки, нету гет.
Да, но вот мы придём сюда...
Если он не писать,
то он туда придёт и такой
гет нету, CE.
Мы же этого хотим.
Ну, я думаю, что мы всё-таки хотим
не совсем этого, мы хотим, наверное,
чтобы он сказал что-то более умное, чем...
Нужно вызвать CE с комментарием.
Я хочу RE явно.
Например, кстати,
кассёр сейчас напишем.
Да, сойдёт.
И дальше такая вот чисто пас.
Нет, нет, нет.
Саня, а почему тебе никто не написал
паксер, который будет
вот эти ошибки, которые загоняешь и смотришь?
Что это вообще значит?
Перевод спрессованный.
Такое есть.
А почему нас это предоучили?
Чтоб ты учился
говорить с компилятором на ты.
Я не хочу!
Так вот, удаляем, давайте.
Стартуем.
Саня, а можно напомнить, пожалуйста,
ещё зачем нам
этот гарантий клюня, который...
Зачем дарить? Вы же хотели
оставить? Вы хотели
оставить всё?
Тут непонятно,
когда что такое будет
автоамперсант.
А он и так был непонятным.
Красивый комментарий.
О, секунду, а почему void?
Почему нельзя оттать на EPR?
Просто статик сёрта.
Ошибка к пиляции
будет в момент, когда мы попытаемся
его вернуть, разве нет, до того,
как мы дойдём до статика сёрта.
Ошибка к пиляции будет в момент,
когда мы напишем return
раньше, чем мы дойдём до статика сёрта.
Потому что мы там пишем return tail.
Так стоит get.
Он просто не инстанцирует
этот get. Если он дойдёт
до инстанцирования этого get,
то он сделает все get.
Но если ему не придётся
инстанцировать, то все get не нужно быть.
Сейчас он всё равно ничего не скомплирует,
потому что у нас много ещё проблем.
Можно просто закомментировать весь main
пока что, чтобы не мешало.
А зачем нам писать более общий
вариант кину на свёклу?
Чтобы специализация была ниже,
чем объявление.
Это же специализация.
Они достаточно крутые, шаблонные
метрогамисты, чтобы понять,
в каком порядке он будет падать.
Давай просто int возвращай и всё.
Ну, это как-то уж совсем.
Лучше a хорошо.
А void-impercent же корректная запись?
Я не написал void-impercent.
Нет, он попытается, он выведет,
что ему вернули void, и такой
void-impercent get.
Да, это некорректно.
Вот есть void?
Нет, лучше у меня есть void-impercent.
Чёрт с ним.
Не знаю, что угодно здесь будет.
Туду.
Давайте
согласен, что-нибудь более
серьёзное реализуем.
Вот, например, как...
А, вот здесь return что надо написать?
О, get.
Ну, return storage.get.
Вот index вот этот.
Ну и, собственно, всё.
Правда?
Говорит, нас интересовало позже,
чем тот, что...
Вот.
Значит, мы...
Ну, в общем-то, вот, да.
Мы здесь тоже вроде можем
t убрать.
По кайфу.
Просто автоинтерсант?
Ну, наверное, тоже можем, по правду.
Так.
Так, хорошо.
Ну, как
делать get по типу,
а не по индексу?
Ещё лучше.
Это return v.storage.get.
Да, v.storage.get.
Как делать
get по типу теперь?
Давайте будем хранить.
Понятное дело.
Что за вопрос?
Точно автоинтерсант?
То есть мы в этом хейдинге
как-нибудь опять...
Хотя нет.
Не, мы хотим ссылку
именно на то, что там лежит.
Именно объект. Этот автоинтерсант будет
ровно тем типом, который ты дал
варианту в начале.
Чтоб ты ему не дал в начале, он его и вернёт.
По крайней мере.
Да, как делать
get по типу?
Вот задача предыдущая.
Напишем пояс по типу индекса,
а потом вернём по индексу.
По типу индекса.
Да, нам надо просто сделать get
по такой...
Ну, нам нужна вспомогательная...
Нам нужна такая метафункция.
get index by type.
от
где?
types
2.2.value
Можно в стиле STL
написать get index by type v.
от
v
а
как это будет работать, если у нас
индекс будет...
Давайте
напишем метафункцию
get index by type.
get index by type
это будет
структура
значит
template, type name
type name
types
структура
get index by type
static const
size t
индекс равно
value
равно чему?
Тут надо
опять с head и с tail
Нет, это общая.
Ну, общую, значит, я выше напишу.
Что, да?
Значит, основная какая?
Если t это head,
то, значит, это 0.
А иначе это
get index by type от
t tail
плюс 1, правильно?
А нужно написать const export
size t?
Ну, не обязательно,
поскольку мы еще не проходили,
я не пишу. Но оно и так будет работать без него.
Кого?
Статик const export?
Ну, еще
писать const export, но оно
и так будет работать.
Почти без разницы.
Статик const всегда const export?
Ну, да.
Потому что это одинаково будет.
Вот.
В,
t, head.
Вопросик, так сказать.
Знак вопроса.
А почему не const export?
Знак вопроса и так const export?
Ну, как? Это все в compile time.
Статик const size t,
его в compile time надо проницилизировать.
Значит, он будет вот это все вычитать в compile time.
Мы так проверку на простоту пытаемся
вычислить.
Conditional оно
для типов.
Условия тип, другой тип.
А тут число должно быть.
Тогда что?
Тогда ноль. А иначе что?
Yet index by type
от
tail
value
плюс один.
Чего не хватает?
Не хватает
для обычно конца рекурсии
template type name t
и type name arcs, к сожалению,
придется, потому что type name многоточие
arcs
type name многоточие
types
struct
Иначе это не будет специализацией.
Можно слово types не писать?
Да.
А
что я здесь напишу?
Если у меня
оказалось, что я дошел
до сюда, то что мне надо написать?
Ничего.
Кажется...
Не, ну какой-то value здесь должно быть.
Можно какой-то
минус один.
Ну, стандартная реализация
она просто...
Ну, тут я
верну просто ноль,
и там
в итоге у меня получится n.
Ну, то есть получится
index, которого нет.
Это логично.
Я как бы
возвращаю n
в по сути.
Возвращаю index после последнего.
А почему статикасер?
Статикасер где написать?
Рано статикасер?
Рано статикасер?
Нет.
Если мы попросили...
Если напишешь
статикасер в теле этого класса,
то я боюсь, что он сработает
без инстанцилирования даже.
В смысле?
Можно писать статикасер в ней методов?
Нет, обязательно. Здесь я как раз не вижу
повода на CE.
Мы попросили тип, которого
среди данного списка типов нет.
И мы на этапе компиляции
понимаем, что это так произошло.
Мы вернем n.
Я возвращаю номер, который больше,
чем размер списка типов.
Ошибка и так будет на этапе компиляции потом.
Она просто не здесь вызовется, а там, где попросят...
GetIndexByType
по сути тебе говорит, он находит
или возвращает n.
Да.
Было бы странно, если бы метафункция приводила
к ошибке компиляции.
Она либо находит и говорит index, либо говорит нет его.
Не падает, а говорит, что его нет.
Смысл вернуть n в том,
что ты как бы возвращаешь
ответ, что нет его.
Вот.
А здесь надо написать t,
запятая head,
запятая tail на доточке.
Кажется вот так, иначе это не будет
по связавшему, правда?
Вот. И что дальше?
Нужно еще
GetIndexByType
определить.
Ну да.
GetTypeName
что угодно.
Static...
не статик...
const...
джузинг?
constexpr, sizeT
constexpr значит константа времени компиляции.
sizeT
get
index
by type
v
равно
get index
by type port types
многоточие value.
Вот.
Ну и теперь просто, если мы хотим
сделать get по типу,
ну вот все у нас написано.
А, это get по индексу и по типу?
Да, это get по индексу и get по типу.
Get по типу, мы селили get по индексу.
GetIndexByType?
Вот.
Теперь самое интересное.
Ну мы написали get.
Но это не интересно тоже.
Понятно, как написать hold за интернете.
Типа, что get возвращает...
Get не кинул.
Фактически.
Ну нет, через исключение...
Это медленно, но можно их
переписать.
Ну просто ту же самую рекурсию.
Только, ну что, я просто
разматываю, проверяю,
что...
Ну, мне, наверное,
надо будет сделать наоборот еще
GetIndexByIndex.
То есть, мне говорят...
Сейчас, почему нет взять что-то...
Меня спрашивают, правда ли hold за
интернете в такой-то тип?
Я понимаю, какой индекс у этого типа.
Через ту же метафункцию getIndexByType.
И разматываю рекурсию, пока...
Зачем разматывать? Можно проверить, что
в этой точке индексовый индекс.
Даже проще.
И просто проверяю, что индекс
в моем варианте, это вот тот самый
getIndexByType. Все.
Это не интересно.
Самое интересное. Конструкторы.
Как
создаваться в всей этой моде?
Мы пока написали классные вспыхательные функции,
но мы не написали самого главного.
Как конструк... У вас
следующая пара во сколько начинается? Уже начинается?
У кого-то она вообще есть?
Да, у всех есть.
Ну, вообще-то 16.55
по расписанию DNS.
Ого.
А можно вопрос?
У меня лично...
Это статик ассорт в IDQ не...
Ну, там, пустой.
Он падает автоматически.
Все равно падает.
Что с этим делать?
Вот думали пока.
Вот он и мне упал, поэтому я его
закомментировал.
Типа NABL?
Не, а проблема ли у нас
не в случае?
Не особо.
Я вообще, ребята, простой, вижу статик
ассорт.
Ну...
Почему он его инстанцирует?
А он не имеет права?
А почему должен?
Нет, статик ассорт фолс он просто может
проинстанцировать... Я думаю, что надо просто
делать статик ассорт, зависимый от индекса.
Тогда он не сможет его проинстанцировать,
пока индекс не будет подставлен.
Вот. Но просто статик ассорт фолс
компилятор сразу видит.
Я просто простой.
Просто когда ты пишешь статик ассорт,
фолс это, вероятно, означает, что ты хочешь,
чтобы было в ЦЕ гарантировано.
Вот.
Вероятно.
Да.
Очень жалко, что конструкторы
не отсубили.
Давайте пока хотя бы идею,
а как реализовать конструкторы?
Мне надо, чтобы у него...
Поддержать муфтемантику.
Да подожди ты с муфтемантикой со своей
она не моя.
Везде теперь будущего спиннажера.
У нас другая уже, другие проблемы, новые.
Нам нужно, чтобы вариант
умел конструироваться
от всех типов,
которые
перечислены в этом
types. Не только.
И не только, причем от них, да.
И не только их наследников.
Надо, чтобы
вариант умел
выбирать. Вот его
конструили от какого-то типа, а он такой
а какой из вот этих вот типов
лучше всего подходит?
И его вот нужно
И если какие-то подходят от
одинаковых хорошо, то еще и выкинутся.
А если какие-то подходят от одинаковых хорошо, то ЦЕ должно быть.
Мы от флопа
даббл конструировать умеем.
Спокойно.
И он передал, что вот мы такие
расширения здесь надо как-то
воспользоваться стандаками.
Хотелось бы чем-нибудь STD
Сделай, пожалуйста.
Надо все так, чтобы это было
разрешение на перегрузку
разных конструктов.
Может быть, я не знаю,
определить внутри варианта
конструктора,
чтобы все конструк...
Сейчас.
Понятно, что уже шаблонный
конструктор от чего угодно.
Да. Внутри.
Попутаться, типа, сконструировать надо все
и в таком счетчик вести,
типа, удалось или нет, у нас чрезвычайно
очень дико. Нет, ну не так надо.
Что происходит?
Вариант Helper
Вариант конструктор Helper
А, я видел где-то это по поводу сочетания.
Это что?
Это базоварианта.
База. Это база, ребята.
Смотрите.
Я сейчас скажу,
что мой вариант
это
приватный
приватный наследник.
Наверное, все-таки назовут не вариант
base, а вариант
choice.
Вариант Alternative.
Ну хорошо, вариант Alternative.
Вариант Alternative
Вариант Alternative.
И до этого просто
нереально догадаться. От чего?
От следующего.
Что это что?
Мне здесь надо
написать вот что.
Types
многоточие
многоточие
У меня будет наследников
родителей столько, сколько
типов в пакете.
Как это партится?
У меня остается
вот это многоточие, оно
привязывается к вот этому и распаковывается
тут, а вот это многоточие
считает мне через запятую наследников.
Ну то есть у нас будет вариант Alternative
с каждым типом.
Types одинаковые.
И каждому из этих вариантов Alternative
я создам конструктор
от соответствующего Types.
А потом здесь пишу using
все эти конструкторы.
template, все эти конструкторы.
Нет!
Нет!
Нет!
Сейчас, а как эти конструкторы будут работать?
Как эти конструкторы, что они будут
построировать?
Type name
Types, using
вариант
Alternative
Вот эти два типа
и вот TS
там точка они
затекаются.
Нет, Types многоточие
2.2.
вариант
Alternative
и все.
Что, кучку так?
Так нет, это неправильный синтакс
Type name T просто, разве нет?
Нет, для каждого это должно быть.
Для каждого
наш родитель, а наши родители это вариант
Alternative типы.
Но они проинциализированы чем-то, что?
Сейчас.
Мы хотим использовать все их вот так.
Мы хотим
все их конструкторы использовать.
Я че это?
Не знаю, либо
как они могут это консервировать?
Так, кажется, что
мне вообще не нужно здесь было писать
темплей, а нужно было написать вот так.
Нет.
Yes.
Yes.
Так, вопрос.
Как эти конструкторы
к нашему сториджу имеют отношение?
Они же
вообще не могут наш сторидж
конструировать.
Сейчас смогут.
Смотрите.
Это же конструкторы вариант Alternative.
Это приватные штуки.
СФТП, по сути.
Heuristic Recurrent Template Pattern. Кто помнит, что это такое?
Я наследуюсь
от некой штуки,
которая на самом деле
знает, что она сама
по себе никогда не существует.
И этот вариант
Alternative знаешь, что на самом деле
он всегда вариант.
Он
будет
знать, что
на самом деле
у него
есть сын,
которого зовут вариант.
Только мне
предварительно нужно объявить
вариант, потому что иначе
он. Нет, понятно.
Вот.
Вот этот вот будет
его сыном.
И
что будет
делать
эта сволочь? Она будет
создаваться уметь от
соответствующего Т?
И что будет делать
она?
Она будет брать, делать
статикаст себя.
Дирайв.
И туда в сторидж писать
в нею типа Т.
А почему
он только должен?
Статикаст наследнику.
Да, если ты наследник.
А почему
мы больше принимаем только 100%
value?
Ну, это потому, что остальное потом сами
допишется. Ещё нужно с мулом правильно.
Так нет, мы разве не должны
любой конструктур каждого из типов
наших внутренних? Или только сами типы?
Нет-нет-нет. Вариант Alternative
соответствующий типу Т.
Для всех Т.
У меня будет столько конструкторов,
сколько вариантов.
Нет-нет-нет. Почему, например, если у нас есть сложный тип,
который умеет конструироваться, ну, у него конструктор,
принимать 5 аргументов, почему мы не можем написать...
Ну, он implicit нас конструирует.
Если у него explicit конструктор,
то тебе всё равно будет explicit конструировать.
Окей, всё нормально.
Нет-нет-нет. Если у тебя...
Ты не можешь конструировать
вариант от
Этого же другое, это in-place надо тогда делать.
Ты можешь вариант прислать
объект одного из типов,
которым ты послал конструкцию.
Так вот, я скажу Static Cast
к Дирай в Тайперсанду, к Дирай в Зёрдочке.
Всё, ладно, надо заканчивать.
Реинтерпрет.
От Vis. Нет, Static.
Мне не нужен реинтерпрет, потому что я
кастуюсь к своему сыну.
Это безопасно.
Может быть с тем же...
Да, есть.
Реинтерпрет может
действовать неправильно.
Да, потому что у нас же множество расследования.
Это нормально?
Ну, у нас не пустые, поэтому...
Почему-то наш неправильно действует.
Ну, здесь не может...
Зачем писать реинтерпрет, если и Static
сделает то же самое?
Реинтерпрет это
тяжёлое оружие.
Зачем Static сделать то же самое
и правильно, гарантированно, даже если
не так с реинтерпретом?
Static as derived Vis.
Стрелочка что? Storage.
В смысле?
Static настолько же безопасный,
насколько реинтерпрет.
Да какая разница?
Нет, не настолько же безопасный.
Static проверяет, он
делает правильные сдвиги, если вдруг они
будут нужны и так далее.
Хороший тон пользу Static, когда им нужно именно Static
в этом идее.
Static, например,
сделает правильный сдвиг, если надо.
Static, например, проверит
приватность, если ты её случайно
нарушил.
Так вот.
Ну, так вот, точка storage.
А, кстати, а как можно
делать Static as, если он private наследник?
Он сам разве знает,
что от него наследуется?
Static as знает ли, что это
наследование? Правильно, он не знает.
Вариант alternative не знает,
что вариант является
наследником варианта alternative.
Поэтому вариант должен сделать другом
вариант alternative.
Это правильно.
Сейчас вариант alternative, сейчас компилятор
заугается, скажет, что
Static as не может кастовать,
потому что вариант alternative
не...
Потому что вариант,
это приватный наследник варианта alternative,
и никто, включая самого вариант
alternative, не должен знать о том, что вариант
его наследник.
Но мы сейчас
в варианте напишем, что вариант alternative
это друг, и вариант alternative будет знать,
что вариант его наследника Static as будет работать.
Вот, а что надо
сделать? Static as дыря вис
storage что?
Там будет template put at value.
Да, да, да, да.
Нам нужен метод
в storage ещё сделать put, я как говорил.
Нам нужно сделать метод put
template
от t
value.
Ну а метод put надо реализовать.
Там налогет, видимо.
Ну да, то же самое, что и с get,
там только put.
Ну всё на сегодня, ладно, давайте уже.
