добрый день давайте начнем сегодня сегодня мы с вами начнем такой условный заключительный
третий модуль ну вообще завершающий модуль нашу с вами разговор про язык c++ и в нем мы так
ну можно сказать обзорно посмотрим на те возможности которые не были рассмотрены
которые не были рассмотрены в курсе ранее ну каким-то причинам ну в первую очередь в первую
очередь мы ссориторимся на каких-то нововведениях последних стандартов языка c++ да это c++ 20
23 ну и также подробно рассмотрим такую такой аспект программирования на c++ на самом не только
c++ как метапрограммирование да то есть программирование скажем так программирование
запрограммирование того как программы должны быть запрограммиров в общем давайте потихоньку
потихоньку разбираться значит первое про что хотелось бы поговорить в рамках вот этих наших
самых вот этого нашего самого вот этого нашего с вами цикла лекции посвященного нововведением
стандарта c++ метапрограммирование мы поговорим про вычисление на этапе компиляции давайте как
обычно начнем спробischen начнем с проблемы что вообще мы хотим решить то с чего мы
мы не можем сделать на текущем уровне развития.
Смотрите, мы с вами знаем, что в некоторых местах VZKC++
нам необходимо подставлять так называемые
compile-time константы.
Что это означает? Это означает, что в некоторых местах программы
должны вставить такие значения, которые должны быть известны
уже на этапе компиляции. Одним из самых известных таких примеров
являются C-style массивы, являются обычные C-шные массивы.
Вот пример. У меня C-шный массив,
который называется C-style,
и, соответственно, если я хочу
указать его размер
в квадратных скобках,
то известно, что этим самым размером
может являться только нечто, что является
константой известной на этапе компиляции.
Согласно стандарту языка программирования C++,
то обычные массивы, которые создаются на стеке,
или там глобально, в общем, обычные такие вот C-шные массивы,
они обязаны в квадратной скобке принимать нечто,
что известно, что вычислимо на этапе компиляции.
То есть, если мы подаем что-то, что известно на этапе runtime,
например, вводим с клавиатуры число n, подаем его туда,
то вообще говоря, стандарт языка программирования C++ такое не позволяет.
В чем проблема?
Ну, смотри, действительно, в этом примере я могу
подать значение n, который известный на этапе компиляции,
то есть, во-первых, константа n является константой,
во-вторых, ее значение известной на этапе компиляции все OK.
Кроме того, второй пример, который сейчас встречается,
это, собственно, передача параметров шаблонов.
Мы знаем, что шаблоны тоже могут принимать параметры
в виде числовых значений, ну и, естественно, параметры шаблонов
тоже должны быть известны на этапе компиляции. Почему?
Потому что шаблоны, это на самом деле не код, который уже существует,
в процессе компиляции программ. Ну, соответственно, чтобы ему сгенерировать код,
естественно, ему нужно знать все значения в сети,
по которым в него подставлены. Соответственно, все то, что мы передаем
внутрь треугольных скобок, тоже, естественно, должно удовлетворять требованию
вычислимости на этапе компиляции. Ну и тут, так как n является
константой времени компиляции, n умножить на n плюс 32, тоже вычислимый на этапе компиляции,
все OK, все супер.
Вот. Соответственно,
на прошлом слайде было представлено
был представлен такой термин, как константное выражение. Давайте его
подробнее обсудим. Константное выражение – это просто выражение, которое может быть вычислено
на этапе компиляции. Вот. Соответственно, ну, понятное дело,
что n умножить на n в данном контексте плюс 32 является
константным выражением, потому что оно может быть вычислено
на этапе компиляции. Давайте посмотрим на следующую
проблему. Представьте себе следующую ситуацию. OK.
Я понимаю, что в качестве значений,
которые я могу передавать в качестве размера массива,
я должен указывать какое-то константное выражение или какую-то
константу, которая известна на этапе компиляции. Ну, смотрите,
если размер массива представим в виде n в квадрате плюс 32,
то кажется, что с этим никаких проблем нет. Если n – это штука,
которая известна на этапе компиляции, то я просто пишу n умножить на n плюс 32
и, соответственно, подаю на вход
мои программы. А что если
что если
нечто, которое я хочу записать внутри квадрата скобок,
тоже зависит от некой константы, известной на этапе
компиляции, для констинт
n равно сотне,
но при этом не представимо вот в таком простом виде, как
n умножить на n плюс 32. То есть представьте, что я хочу, например, вычислить
n в третьей степени.
Допустим, я хочу, чтобы размер
массива был равен n-ке в третьей степени.
При этом n-ка – это некоторая константа, которую я хочу…
Я не хочу для нее заводить какую-то магическую константу,
всегда писать 100, поэтому я тут завожу переменную n,
записываю значение 100, и если мне вдруг нужно вместо n
брать значение 1000, скажем 50, то я могу просто нам
сменять это значение. Я хочу, чтобы это же изменение касалось
и того, что вычисляется в квадратных скобках.
Понятное дело, что n в третьей степени…
Если это константы известной на этапе компиляции, то n в третьей степени
вообще, говорят, наверное, тоже должно быть известной на этапе компиляции.
Согласны? Согласны?
В чем проблема? Проблема в том, что n известный
на этапе компиляции, но если я в квадратной скобке
подставлю функцию… Мне немного аргумента перепутаны,
ну ладно. Если я в аргументы функции…
Если я в аргументы, простите, квадратных скобок
передаю некоторую функцию, то вообще говоря, функция
rx10++ – это сущность этапа исполнения программы.
Когда мы вызываем функцию, мы с вами говорим про то,
что функция вызывается во время исполнения программы,
а не во время компиляции. Поэтому если я попытаюсь сделать
так, то несмотря на то, что у меня n является
константы, которые известны на этапе компиляции,
компилятор начнет ругаться. Он скажет, что, погодите,
тут я в качестве аргумента квадратных скобок
передаю результат вычисления функции,
а функция вычисляется в рантайме. Функция не вычисляется
на этапе компиляции. Соответственно, получается так,
что, к сожалению, у меня не получится
в квадратной скобке передать результат
вызвав некоторые функции от константного выражения.
Проблем понятен? То есть, хотелось бы
иметь некий способ вычислять значение
каких-то функций на этапе компиляции. Если бы я смог
вычислять значение функции на этапе компиляции,
то, передав функцию константы времени компиляции,
при этом функция тоже может вычисляться
на этапе компиляции, то тогда�� я получу
возможность делать выч Eigenavigicide на этапе компиляции
значение, которое тоже будут известны в этапе компиляции.
Пока мы этого делать не можем, почему?
Потому что те функции, с которыми мы с вами знакомились в течение курса,
они обладают этим свойством, что они всегда вычисляются только во время исполнения программы.
Поэтому компилятор их вычислять во время компиляции не будет.
Окей, соответственно, главный вопрос, как все-таки заставить компилятор
что-то вычислять на этапе компиляции?
То есть, если у меня есть некоторая функция, которую я хочу вычислять на этапе компиляции,
то как мне заставить компилятор это сделать?
Ну и, на самом деле, у этого вопроса есть довольно-таки простой ответ,
но прежде чем мы к нему перейдем, давайте немного пострадаем
и пройдемся, так скажем, по историческим этапам развития C++,
как развивалась история вычислений на этапе компиляции в языке C++.
И в итоге придем к тому, к чему пришел стандарт в C++ 17 и C++ 20.
На чем основаны классические compile-time вычисления?
Ну, смотрите, для того, чтобы заставить компилятор что-то вычислять на этапе компиляции,
нам нужно, вообще говоря, понять, что может сделать компилятор на этапе компиляции.
Ну, смотрите, первое, про что мы с вами сказали в самом начале сегодняшнего занятия,
так это то, что компилятор на этапе компиляции в первую очередь подставляет все шаблонные параметры.
Если я создам некоторый класс C и в него передам какую-то константу времени компиляции,
то эта константа, соответственно, в саму структуру или в сам класс,
давайте напишем template int n, класс C,
то вот этот вот шаблонный параметр n подставится во все нужные места класса еще на этапе компиляции.
То есть, грубо говоря, если у меня внутри есть какой-то метод voidf,
и тут есть создание перемены int x равно n, то вместо вот этого значения, вместо вот этой перемены n,
подставится ровно то значение, которое я передаю при инстанцировании шаблона,
то это значение 100, оно как раз-таки будет подставлено вот сюда на этапе компиляции.
То есть, что делает компилятор во время компиляции?
Это подставляет шаблонные параметры в те места программы, которые необходимы.
Это первое. Второе. Что еще делает компилятор?
Компилятор, естественно, на этапе компиляции пытается задать значение некоторым константам,
которые могут быть вычтены на этапе компиляции. Давайте посмотрим на конкретный пример.
Смотрите, если я создам некоторую структуру, которая называется integral constant,
я создаю структуру integral constant, которая будет параметризована
некоторым типом integer и некоторым значением.
Собственно, значение я могу передать тоже в шаблонный параметр.
Назову структуру integral constant и дальше заведу статическую константную переменную integer k value равно value.
Что тут произойдет? Смотрите, integral constant это шаблонная структура.
При установке параметра в шаблонную структуру что произойдет?
У меня, во-первых, вместо типа integer подставится какой-то конкретный тип.
Допустим int. Вот здесь, в этой строчке я в качестве параметра integral constant
передаю int и 100. Что это будет означать?
Это будет означать, что вместо этого типа integer автоматически будет подставлен int еще на этапе компиляции.
А во-вторых, вместо этого значения 100, который передается в качестве второго шаблонного параметра,
вот сюда подставится значение 100.
И в итоге что у меня получится? У меня получится int-овая константа,
которая изначально провентилизирует значение 100.
При этом, так как она константа, то эта константа тоже будет известна на этапе компиляции.
Понятно?
Поэтому вот эту константную статическую переменную я вполне себе спокойно смогу использовать
внутри квадратных скобок, которые требуют константа времени компиляции,
ну и также внутри STD array, которые тоже требуют константа времени компиляции.
То есть первое, что мы знаем, первое, какой факт не выберем,
так это то, что компилятор подставляет все шаблонные параметры.
И, соответственно, если какая-то переменная является константной,
то, соответственно, по возможности он старается тоже вычислить ее на этапе компиляции.
Окей.
Вот то, что я написал здесь, то есть то, что я написал вот эту самую структуру integral constant,
это на самом деле полноценный аналог аналогичной структуры из стандартной библиотеки.
То есть если мы возьмем заголовочный файл type traits,
то там мы найдем вот эту самую структуру std integral constant.
Ну и, соответственно, вот эта самая std integral constant устроена ровно так же, как я описал здесь.
То есть в ней есть статическое константное поле value,
которое просто-напросто хранит вот это самое значение.
Так, ну тут повис не мой вопрос.
Ну, соответственно, зачем нам такая структура?
То есть как бы зачем нам использовать какую-то побочную структуру,
если мы можем просто-напросто подставлять константу?
То есть зачем нам в качестве промежуточного этапа использовать какую-то структуру,
которая внутри себя хранит статическое поле value?
А вот для чего, смотрите, давайте я поступлю следующим образом.
Давайте я попробую организовать вычисление некоторой функции на этапе компиляции.
Ну, например, давайте я попробую организовать вычисление функции возведения в квадрат.
Что я для этого сделаю?
Я напишу структуру square и унаследую ее публичным образом, естественно, от std integral constant от int и n умножить на n.
Вот, и дальше, если мне в каком-то месте программа, ну, например, вот здесь,
то есть при создании массива int, если мне при создании массива,
если у меня при создании массива возникнет необходимость вычислить какую-то функцию от константа известный этап компиляции,
я могу поступить следующим образом.
Я могу инстанцировать структуру square параметром, ну, допустим, n.
Да, ну, n вот этот вот самый параметр, вот эта самая константа.
И взять у нее значение статического поля value.
Почему я уверен, что вот это значение обязательно будет вычислено на этапе компиляции?
По следующей причине, смотрите, во-первых, я точно знаю, что так как, ну, давайте тут вместо n 100 напишем.
Во-первых, я точно знаю, что все шаблонные параметры подставляются на этапе компиляции, согласны?
Вот, то есть я беру сотку, подставляю вот сюда. Соответственно, шаблонный класс square инстанцируется с помощью параметра n равный 100.
Дальше, чтобы инстанцировать square, ему нужно инстанцировать класс integral constant.
Инстанцируется класс integral constant со значениями int и n умножить на n.
Вот. Но вот это значение n умножить на n, так как n подставляется на этапе компиляции, и плюс, смотрите, что самое главное,
чтобы компилятору понять, от чего будет наследоваться класс square, ему нужно будет обязательно вычислить вот это значение и сюда подставить.
Понятно? То есть у компилятора возникает необходимость в инстанцировании square.
А при инстанцировании square у компилятора возникает необходимость в инстанцировании integral constant от вот этого значения.
И поэтому, так как компилятор понимает, ну окей, n это константы известной этапы компиляции, вот это тоже известный этап компиляции,
n умножить на n я могу вычислить на этапе компиляции, точнее, мне необходимо вычислить это на этапе компиляции,
чтобы можно было инстанцировать integral constant, и он ровно этим и займется.
То есть он вычислит n умножить на n на этапе компиляции, подставит в integral constant,
а в integral constant существует статическое поле value, которое будет равно как раз к этому самым бернному значению.
Понятно? То есть каким образом мы смогли компилятор заставить выполнить вычисление?
Мы его заставили тем, что при передаче шаблонных параметров компилятор обязан их вычислить на этапе компиляции,
если это возможно. Понятное дело, что это возможно, так как n это шаблонный параметр, который представляется на этапе компиляции,
поэтому у него такая возможность есть.
Используя механизм подстановки шаблонных параметров, мы с вами смогли заставить компилятор делать полезную работу.
Давайте посмотрим на другие примеры. Давайте посмотрим на примеры каких-нибудь более смыслных функций.
Смотрите, возведение в квадрат кажется очень скучно. Почему?
Потому что, вообще говоря, я тут вполне себе мог и раньше написать n умножить на n.
То есть в вычислении n в квадрате на этапе компиляции это не очень интересно,
потому что если я тут напишу n умножить на n, то компилятор это бы все равно вычислил, даже не требуя этой самой структуры.
Давайте посмотрим на какой-нибудь более смыслный пример. Ну и более смыслный пример, например, вычисление факториала.
Вряд ли я сюда смогу написать какой-нибудь факториал от n.
Понятное дело, что, во-первых, функции факториала встроенные в c++ нет,
во-вторых, даже если я напишу какую-то стороннюю функцию, то, как я уже сказал, функции вычисляются на этапе исполнения программы,
поэтому на этапе компиляции компилятор вычислять эту функцию не будет.
Давайте попробуем как-нибудь компилятор заставить вычислить факториал на этапе сборки программы.
Предложение будет следующее. Как это будет устроено?
Спойлер написан на экране. Давайте его проведем тоже на доске, чтобы проследить за логикой.
Смотрите, чтобы заставить что-то вычислять на этапе компиляции, необходимо это все обернуть в шаблонный параметр.
Давайте я так и поступлю. Давайте напишу шаблонную структуру факториал,
который будет параметризован как раз таки значением, от которого нужно вычислить факториал.
Что мне дальше нужно сделать? Мне дальше нужно каким-то образом компилятор заставить делать вычисление.
Чтобы сделать вычисление, ему нужно эту n превратить во что-то, что будет поставлено в какой-то другой шаблонный параметр,
в какой-то другой структуру. Смотрите, что мы знаем про факториал?
Мы знаем, что факториал от n умножен на факториал от n-1.
Давайте я факториал унаследую от факториала от n умножить на факториал от n-1.
Давайте на одной доске напишу вот тут. Мы наследуем от факториала от n умножить на факториал от n-1,
то есть смотрите, что я говорю? Я говорю, что факториал от n унаследовано от структуры...
Я говорю, что факториал от n это целочисленная константа, которая внутри себя хранит значение n умножить на факториал от значения факториала n-1.
Понятно? То есть что происходит? Снова, n это значение, которое должно быть известным в этапе компиляции.
Действительно, я его подставляю вот сюда, допустим, факториал. Подставляю его вот так.
Факториал от n... value. Вот, то есть n-ку я подставляю на этапе компиляции.
Соответственно, подставляется n-ка и при инстанцировании факториала компилятор понимает, что так как мне нужно инстанцировать факториал,
то мне нужно и инстанцировать базовый класс. Компилятор начинает инстанцировать базовый класс и, соответственно,
понимает, что ему нужно... Для того, чтобы понять, что это вообще за класс, чтобы его инстанцировать,
необходимо вычислить вот это значение. Соответственно, компилятор приступает к учтению это значение.
То есть он рекурсивно начинает вычислять факториал от n-1, берет оттуда значение, это значение умножает на n,
соответственно, вот в integer const в статическом polyvalue будет записано значение факториала от n. Понятно?
В чем проблема? Да.
Как он может понять, что в стриале есть polyvalue, если он уже увидел, что он наследует и его иностранство?
Он не хочет еще параметры расследования, и он сразу определяется, что у него есть polyvalue.
Как он поймет, что у него есть polyvalue? Очень просто.
Во-первых, чтобы понять, что у него есть polyvalue, ему сначала нужно вот этот шаблон инстанцировать.
Он его сначала инстанцирует. Понятно, что при постановке конкретного n ему конкретно n известен.
После того, как он инстанцирует этот класс, естественно, станут известны ему все поля, которые там есть.
Так как любой факториал в итоге является наследником integer constant, а в integer constant есть статическое polyvalue,
то и факториал n-1 тоже есть статическое polyvalue.
Все видят проблему типичной рекурсивной реализации факториала.
То есть мы написали рекурсивное определение факториала, и вообще говорят, тут у нас нигде нет конца рекурсии.
Согласны? То есть я буду вычислять факториал от 100, потом рекурсивно буду вычислять факториал от 99, факториал от 98, факториал от единицы, факториал от нуля,
и дальше пойдет вычисление факториала от минус единицы, минус двойки и так далее.
То есть тут не хватает конца рекурсии. Вопрос вам.
А как мы реализуем конец рекурсии? Как мы в терминах наследования или в терминах структуры скажем,
что дальше структуры инстанцировать не надо, на этом стоит остановиться, тут мы уже знаем ответ.
Какой механизм нам позволит это сделать?
Так, введем еще одну структуру. Какую?
Так, ну смотрите, вот тут, смотрите, у меня факториал, вызывает всегда факториал.
То есть тут вроде как нигде не фигурируется эта самая другая структура.
Вот, супер, да, специализация уже близко к правде, то есть только не частичная специализация,
тут нам поможет полная специализация. Вот, почему? Ну смотрите, тут мы что можем сказать?
Напомню про идею специализации. Что такое специализация шаблона?
Специализация шаблона позволяет вам сказать, что при некоторых конкретных параметрах,
шаблон нужно инстанцировать чуть иначе. То есть я говорю, что в общем случае факториал устроен вот так,
но в частности, как пишется полная специализация?
Полная специализация пишется с пустыми треугольными скобками, дальше я снова прописываю ту самую
структуру шаблонную, факториал, но при этом дополнительно прописываю эту структуру шаблонную.
Дополнительно прописываю треугольные скобки и в треугольных скобках указываю, для какого параметра
факториал должен вести себя иначе. В случае факториала речь идет про ноль, то есть факториал от нуля,
база рекурсии тут факториал от нуля равен единице, поэтому я говорю, что я специализирую факториал от нуля
и наследую его от std integral constant от int и от единицы.
Вот и смотрите, что происходит. Ну давайте, допустим, посмотрим, как будет происходить вычисление
на этапе компиляции факториала от тройки. Что будет происходить? Когда я попросил факториал от тройки
2.2.value, вот, происходит следующее. Компилятор видит, что ему нужно понять, что это такой за класс
или что это такая структура факториала тройки. Когда он начинает инстанцировать факториал от тройки,
то есть он смотрит на это определение, а факториал от тройки это наследник класса integer constant от n умножить
на факториал от 3-1, то есть двойки. То есть чтобы инстанцировать класс факториал,
ему нужно инстанцировать класс факториала двойки. Окей.
Компилятор идет дальше и начинает инстанцировать класс факториала двойки.
Когда компилятор инстанцирует факториал от двойки, он видит, что факториал от двойки унаследован от integer constant,
а чтобы инстанцировать integer constant, ему нужно инстанцировать, то есть ему нужно понять, что значение написано
И нужно инстанцировать факториал от единицы.
Инстанцируется факториал от единицы.
Дальше инстанцируется, потому что сам принцип有人
инстанцирует факториал от нуля.
Факториал от нуля. Но когда я инстанцирую факториал от нуля,
я уже смотру не сюда, а вот сюда, потому что тут факториал от нуля у меня вы체가 полностью
специализирован. То есть, я говорю что, для факториала от нуля мне нужно действовать как-то иначе.
Соответственно, компилятор приходит сюда, видит, что факториал от 0 это
наследник класса integral constant со значением единица, ну и на этом все, как бы
рекурсия закончилась. У меня создается факториал от 0 со значением value
равным единице. Дальше я возвращаюсь в определение факториала от единицы, да,
факториал от единицы у меня вычисляется как факториал от 0 умножить на n, то есть тут
получится единица. Факториал от двойки будет вычисляться, то есть будет вычисляться как
двойка умножить на факториал от единицы, то есть двойка, ну и конец факториала тройки
2.2.value, он будет инстанцирован как тройка, умноженная на факториал от двойки.
Мы про него говорили пару слайдов назад, вот integral constant это класс, в котором есть
всего лишь одно статическое поле, статическое константное поле, которое
хранит себе вот этот вот самый параметр, который мы передали в треугольной скобке.
То есть это его, то есть единое значение integral constant это хранить себе, хранить
себе статическую константу, которую мы передали. Так, есть ли еще вопросы?
Окей, давайте рассмотрим, да, естественно, просто необходимо добавить специализацию шаблона.
Так, ну что дальше? Смотрите, вот как пользоваться, а как пользоваться этим
вычислением на этапе интелляции, который мы задали? Ну смотрите, чтобы воспользоваться
этим значением нам необходимо сделать следующее. Ну так мы понимаем, что значение вот этого
самого факториала от n в структуре факториал хранится в статическом поле value, да, мне
необходимо написать факториал от n, даже 2.2.value. Вообще говоря, кажется, что это довольно
фигуромостко, да, то есть, ну, понятное дело, что если я хочу узнать какое-то значение, да, то я бы
хотел это сделать быстро, да, там, ну, как-то, не знаю, написать поменьше символов и так далее.
Вот, как можно упростить, как можно упростить данный пример? Значит, упростить данный пример можно
с помощью шаблонов переменных. Смотрите, давайте я заведу шаблонную переменную, то есть, после того,
как я написал все это, давайте я напишу шаблонную переменную, шаблонную переменную, которая будет
хранить себе значение факториала. Напомню, как пишется шаблонная переменная. Ну, шаблонная переменная,
к любой другой шаблон начинается с преамбулы template, допустим int n, вот. Ну и дальше я задаю
значение, дальше я задаю саму, дальше я задаю саму переменную. Ну, давайте напишу переменную const
int факториал. Напомню, что по тайлу у нас константы начинаются, ну, глобальные константы начинаются
с префикса k факториал, и скажу, что она будет равна статическому полю факториалу от n
2.2.value, вот. То есть, вот, я завел шаблонную переменную факториал, которая в зависимости от параметра n,
которая в зависимости от параметра n, точнее, я завел целый набор, да, целый набор переменных, вот,
каждый из которых параметризовано типом, точнее, числом n, ну, и в зависимости от n у меня
всегда подставляется либо факториал 100 вл, да, факториал 99 вл и так далее. Поэтому после того, как я
ввел значение, после того, как я ввел вот эту шаблонную переменную, я могу и пользоваться вот
таким образом. k факториал от n, вот. То есть, так эта шаблонная переменная, да, то она уже внутри себя
хранит значение, вот, которое вычислено по тому правилу, и, соответственно, код стал значительно
проще и значительно читаемее. Окей? Нормально? Хорошо. Давайте посмотрим еще, например, вычисления
на этапе компиляции, ну, и еще один классический пример, да, сразу после факториала. Это пример,
ну, то есть, естественно, после факториала, как правило, идет вычисление чисел Фибоначчи.
Давайте попробуем организовать вычисление чисел Фибоначчи на этапе, на этапе компиляции. Вот,
давайте тоже напишем, вот, потом прокомментируем. Ну, соответственно, вычисление чисел Фибоначчи
устроено так же, да, мы должны завести шаблонную структуру Фибоначчи, которая должна быть
наследована от класса, в котором будет, в котором, ну, в поле которого, да, будет храниться, ну,
значение Фибоначчи от n. Ну, естественно, таким, естественно, таким классом у нас будет std
integer constant, integral, integral constant от int, и, ну, и туда мы должны передать значение, которое будет
храниться. Ну, как вычислять число Фибоначчи? Число Фибоначчи уничтожен следующим образом.
Мы должны взять значение числа Фибоначчи от n-1, 2.2.value, вот, и прибавить к нему значение числа
Фибоначчи от n-2, ну, и взять оттуда статическую переменную value. Вот, совершаем определение класса.
Вот, ну, естественно, как и раньше, как и раньше, нам нужно прописать признак конца рекурсии,
да, потому что если мы будем усилять Фибоначчи от n, у нас рекурсина будет
усиляться в Фибоначчи от n-1, n-2, ну, и так далее. Давайте пропишем, давайте пропишем конец рекурсии.
Ну, также делаем с помощью шаблонной специализации.
Фибоначчи от единицы, да, и Фибоначчи от единицы это integral constant от единицы.
Ну, аналогично прописываем Фибоначчи от нуля. Давайте не буду прописывать. Вот.
Ну, и опять же абсолютно аналогично вот тут, как во второй строчке, да, я могу прописать шаблонную
переменную k-Fibonacci, и вот сюда вместо k-factorial подставлять k-Fibonacci, у меня Фибоначчи будет
вычисляться вот согласно тому правилу. То есть, когда я буду инстанцировать Фибоначчи, допустим,
от 10. Вот. Компилятор, чтобы инстанцировать Фибоначчи от 10, ему нужно будет проинстанцировать
класс SD integral constant, а чтобы проинстанцировать класс SD integral constant, ему нужно будет узнать,
что за значение я передал сюда. Чтобы узнать, что значение я передал сюда, ему нужно будет
проинстанцировать Фибоначчи от n-1, Фибоначчи от n-2, ну, и так далее. В итоге все, в итоге все,
в итоге вычисление пройдет успешно. Вот. И в поле, и в статическом поле value будет храниться нужное
значение. Вопрос. Как вы думаете, есть ли какие-то проблемы вот в этой реализации? Да. Вот, смотрите,
да. Ну, я надеюсь, вы помните, что когда мы вычисляем Фибоначчи, когда мы вычисляем число Фибоначчи
рекурсивно, у нас возникает следующая проблема. Давайте посмотрим на то, как вычисляется Фибоначчи
от, не знаю, 5. Да, когда вычисляется Фибоначчи от 5, он вызывает Фибоначчи от 4 и Фибоначчи
от 3. Фибоначчи от 4 вызывает Фибоначчи от 3, Фибоначчи от 2, тут вызывает Фибоначчи от 2,
Фибоначчи от единицы. Вот. Ну, так или иначе, мы видим, что вот это вот дерево, да, вычисляется
целиком здесь же. Вот. Вот это дерево вычисляется целиком здесь же. То есть, грубо говоря, у меня
одни и те же вычисления повторяются кучу-кучу раз. Да. Ну, я надеюсь, вы помните, что вычисление
фибоначи с помощью рекурсивного алгоритма, оно растет экспоненциально, то есть это
ω большое от, по-моему, полтора в степени n. То есть на самом деле вычислять фибоначи с
помощью рекурса неэффективно. И вроде как замечание ценное, действительно
валидное, но на самом деле я утверждаю, что когда мы говорим про шаблоны,
вот такой штуки не происходит. Понимаете ли вы почему? Понимаете ли вы
почему вот такое вычтение фибоначи будет занимать линейное время, а не
экспоненциальное? Да, смотрите, в чем прикол. Смотрите, как мы боимся с этой
проблемой в случае рекурсии. В случае рекурсии мы используем технику
минимализации. Мы вычислили код значения фибоначи, мы просто
его запоминаем, и потом в следующий раз, ну, допустим, вот тут мы вычислили фибоначи от 3,
и потом в следующий раз, когда нам понадобится вычислить фибоначи от 3, мы уже не вычисляем его
заново. Мы используем уже готовые значения из какого-то массива. А теперь, смотрите,
я утверждаю, что когда мы используем шаблоны, вот эта вот самая
мимоизация с запоминанием предыдущих вычтенных значений, она происходит
автоматически с помощью компилятора. Почему? Да потому что, если мы вспомним,
как компилятор инстанцирует шаблоны, то увидим следующую вещь.
Ну, смотрите, вот, допустим, я использую какую-то шаблонную функцию f от единицы.
Это шаблонная функция, которая принимает на вход int. Соответственно, когда компилятор видит, что я вызываю
функцию f от int, он инстанцирует функцию f от int. А что происходит, когда он встречает
снова функцию f, которая вызывает от int? Инстанцирует ли он ее заново? Нет,
инстанцирование шаблона для каждого набора параметров происходит ровно один раз.
То есть, когда компилятор первый раз встретил функцию f, которая вызывает от int,
он подставляет шаблонный параметр int и генерирует из этого шаблона готовую
функцию и записывает ее в исполняемый файл. Дальше, когда в следующий раз он видит
функцию f, которая вызывается от int, он же не будет повторно инстанцировать одну и ту же функцию.
Зачем инстанцировать одну и ту же функцию несколько раз? И здесь то же самое.
Когда компилятор видит инстанцирование класса Fibonacci от пяти впервые,
естественно, этот класс инстанцирует, он сохраняет ее у себя в памяти.
А когда он видит следующий раз Fibonacci от пяти, ну, компилятор естественно понимает,
что вот этот класс я уже раньше инстанцировал, этот класс уже есть,
поэтому заново инстанцировать я его не буду, я просто возьму оттуда готовое значение.
Поэтому на самом деле вот этот алгоритм, точнее вот это вот вычтение, занимает OATN.
Причем OATN не во время исполнения программы, а во время компиляции.
Вот. И это, кстати, важный момент. Важно отметить, что вычисление вот этого значения,
факториала от N или Fibonacci от N, будет тратить время только на этапе компиляции.
То есть у вас будет долгая, то есть у вас компиляция, возможно, будет долгая,
но вот во время исполнения программы, когда программа будет работать,
тут уже будет готовое значение. То есть компилятор посчитает это значение на этапе компиляции
и подставит уже сюда конкретный результат. Ну, допустим, 6. Понятно?
То есть после того, как компилятор вычислит все значения, все value,
все шаблоны переменной, этап компиляции, он уже во время исполнения
будет просто использовать их значения. И вычислять на этапе исполнения программы он не будет.
Это понятно? Вот. Да.
Ну, скорее всего, скорее всего, нет. Ну, то есть если компилятор увидит, что, как бы,
после установки всех значений код, значит, код, ну, смотрите, во-первых, тут есть два момента.
Первый момент, вот эти все структуры, они не содержат никакого исполняемого кода,
то есть они не содержат ни методов, скажем, ни функций, ни конструкторов и так далее.
Вот. Поэтому, соответственно, хранить ему, по сути, нечего. Вот. Поэтому после
установки всех шаблонных параметров, после всех значений, то есть, как бы,
компилятор просто-напросто возьмет и в ассемблерный код тупо вставит значение 6,
или тупо вставит значение 24. Вот. И после выполнения всего этого компилятора увидит,
что в самом ассемблерном коде у него нет никаких вычислений связанных с этим структуром,
поэтому он, скорее всего, их просто-напросто уберет. Вот. Поэтому на, по этому размеру бинарного файла,
ну, опять же, там, скорее всего, в режиме оптимизации, скорее всего, там ничего
сохранено не будет. В режиме дебага, возможно, он это сохранит. Так. Несколько замечаний,
несколько замечаний по следам того, что мне задали, какие вопросы мне задали в перерыве,
еще раз повторюсь, что вот это вот значение n, которое используется для вычислений факториала,
фибоначи, и так далее, е, оно обязано быть известно, оно обязано быть известно на этап
компиляции. Вот. То есть, ну, два момента. Первый момент такой. Вот эта штука, вот сам факториал,
там, не знаю, факториал от тысячи, да, факториал от миллиона, он будет вычисляться на этап
компиляции. То есть, в рантайме, то есть, пока, то есть, во время работы программы вы потратите
все, вообще говоря, ничего. Вот. Тут может возникнуть следующая идея. Ага, давайте хакнем,
давайте хакнем контест. Вот. И сделаем следующее. Давайте просто просто напишем, напишем факториал
или напишем фибонач, который вычисляется на этапе компиляции. Вот. А когда, ну, собственно,
программа будет запускаться, я туда подставлю там нужное значение, и, соответственно, получу
значение за вот единицы. А вот шиш, так не выйдет. Почему? Потому что, еще раз повторю, что вот
это вот значение n, оно должно быть известно на этапе компиляции. Естественно, параметры вашей
программы передаются на этапе исполнения. Вот. Поэтому воспользоваться этим на этапе исполнения
у вас не получится. То есть, как бы, вот это чисто концепция и этап компиляции. То есть, ну, единственное,
что вы можете сделать, это на этапе компиляции заранее там почитать там факториалы там, ну,
допустим, от нуля до сталь, там от нуля до тысячи, да, и потом, то есть, сохранить это все в массиве,
и потом, во время исполнения программы, там, когда вы подаёте на вход какое-то там значение, да, вы
можете обратиться к этому массиву, да, из этого массива вычислить какое-то, вычислить какое-то значение.
Вот. Это первое замечание. Второе замечание заключается в следующем. Смотрите, несмотря на то,
что вот вычисление факториал, вычление произвольного факториала или вычисления
произвольного числа fibonacci на этапе исполнения программы теперь не стоит ничего. То есть, если
вам нужно прям вот fibonacci steal on 1000, да, то во время исполнения программы, программа не сделает
вообще ничего, она просто возьмет уже готовое значение, которое было посчитано и темпы компиляции.
Вам можно считать, что fibonacci steal on n или factorial on n на этапе исполнения будет вычисляться за
единицу. Но в чем подвох? Подвох в том, что вот это время на вычислении
нужного факториала или нужного фибоначи, вы потратите на этапе компиляции, и поэтому не
удивляйтесь, когда в третьем контесте вы увидите, что ограничение
по времени на вычлении каких-то там функций будет занимать очень
маленьким, но я сразу предупреждаю, что у нас будут ограничения по времени на
время компиляции. То есть если ваша программа компилируется достаточно
долго, то скорее всего вы реализовали какой-то неэффективный алгоритм, и соответственно
таким образом тайм-ремит у вас будет на время компиляции, а не на время
исполнения программы. Вот. Есть ли еще вопросы?
Окей. Так, ну здесь мы продолжаем, значит продолжаем, продолжаем примеры, начнут
вот пример быстрого возведения в степень. Напоминаю, что чтобы быстро
возвести число в степень, допустим, х в степени n, чтобы это не делать за
линейное время, мы поступаем как? Если n делится на два, то мы берем, то мы
вычисляем x в степени n пополам и возводим в квадрат. Вот. Если n
в остатке, если n является сочетным числом, то мы берем x и умножаем на x,
ну тоже получается степень n пополам в квадрате. Вот. То есть таким образом
вычисление степени происходит за логичмическое время, и ровно это же самое
алгоритм можно реализовать с помощью вычислений на этапе компиляции.
То есть что мы делаем? Мы пишем так называемую метафункцию возведения в
степень по, вот, перенимаем на вход x, перенимаем на вход значение n, то есть если n
если n делится на два, то мы вычисляем по x на x на n делить пополам, и иначе
вычисляем x умножить на степень x умножить на x, n-1 делить на 2. В общем, все то
же самое, что и раньше, просто тут возникает ветвление. Вот. Тут есть
небольшая проблема, но про которую поговорим чуть позже. Вот.
Окей. Значит, смотрите, вот все то, о чем я говорил до этого, вот вычисление
Fibonacci в таком стиле, вычисление факториала в таком стиле, вычисление там
степени, это все, скажем так, старый стиль C++. Вот. В общем, это то, как разработчикам
необходимо, было необходимо выкручиваться в ситуации, когда C++
не предоставлял никаких инструментов для того, чтобы делать корректные
вычисления на этапе компиляции. Вот. На самом деле современный C++ в этом
смысле стал более лоялен и оброс достаточно большим количеством инструментов
для того, чтобы можно было организовать хорошие и правдоподобные, ну не
правдоподобные, да, хорошие и приятные вычисления на этапе компиляции. Давайте
про них поговорим. Значит, первое, про что мы поговорим, так это constexport
функция. Что такое constexport функция? Значит, constexport функция — это функция,
у которой в начале, да, перед описанием типа, ну или там перед возвращаемым
значением написано ключевое слово constexport. Что это означает? constexport
функция — это такая функция, которая может быть, может быть вычислена на этапе
компиляции. Смотрите, вот до этого, когда мы с вами писали функции там на языке
C++, вот эти функции, они все обязаны были вычисляться на этапе
исполнения программы. То есть на этапе компиляции компилятор вообще, говорят,
строго-настрого отказывался что-либо, что-либо вычислять, вычислять какие-либо
функции. Так вот, в C++11 появились constexport функции, которые могут быть вычислены
на этапе компиляции. То есть я как бы говорю компилятору о том, что вот эта
функция, да, она может быть вычислена на этапе компиляции, потому что она использует
только те операции, которые допустимы на этапе компиляции. Вот. В частности,
если мне вдруг хочется реализовивать функцию факториала, ну
которую я в теории там захочу вычислить на этапе компиляции, я могу просто-напросто
перед функцией факториала написать constexport, вот.
Ну и, соответственно,의 cooler, ну и, соответственно, к чему это приведет. Это приведет к
тому, что если я функцию факториала буду передавать constexport значения, то
есть, простите, если я функцию, если я факториала буду передавать значения, которые
известны на этапе компиляции, например, факториал 5, как в данном примере,, то он
все будет работать корректно. Почему? Потому что компиляторamer, ага, факториал
и это принимает conscient, известную на этапе компиляции, в данном случае 5,
factorial объявлен как consistent экспорт, то есть у функции может быть
в metros Алексеев Main meanwhile архитектура
ну и компилятор запустит эту функцию, ну то есть он как бы Representative
компилирует эту функцию, потом на этапе компиляции её запустит
и соответственно вычлит вот attention factorial
вычлитDavid paintings factorial от 5
то есть опять же, после того как вычлите эту функцию на этапе компиляции
вы поставите туда уже готовое значение
и на этапе исполнения программы вы потратите ровно ничего
но при этом, опять же стоит понимать, что на этапе компиляции вы потратите какое-то...
вы потратите какое-то время
ОК?
То есть вот все то же самое можно сделать просто с помощью constexpr функции и при этом писать обычные функции, как мы с вами привыкли.
Давайте поговорим про некоторые свойства constexpr функций.
Что они представляют, что можно писать в constexpr функции, что нельзя писать в constexpr функциях и так далее.
Во-первых, любая constexpr функция автоматически является inline.
Почему? Потому что если функция может быть вычислена на таблике компиляции, то, естественно, эта функция обязана появляться в той же самой единице трансляции или в том же самом файле, что мы сейчас компилируем.
Кроме того, из первого пункта следует, что constexpr функции я могу спокойно помещать в заголовочные файлы, да, это не будет приводить к нарушению правил одного определения.
Помните, что слово inline используется для того, чтобы можно было нарушить правила одного определения.
Дальше, до C++20, а constexpr функции не могли быть виртуальными, сейчас виртуальными они и быть могут, то есть сейчас вы можете объявить виртуальную функцию constexpr.
До C++20, то есть если вы используете стандарт, раньше C++20, то в constexpr функциях нельзя использовать try catch, потому что считалось, что если функция должна быть вычислена на таблике компиляции, то, естественно, и исключения она генерировать не должна.
До C++20 она не могла использовать ассемблерные вставки, теперь она может использовать ассемблерные вставки.
До C++20 она не могла использовать операции динамической памятью.
Вот это вообще, наверное, самое хрешесносное.
В общем, смотрите, когда мы выделяем динамическую память, выделение динамической памяти – это концепция времени исполнения.
То есть мы с вами говорили о том, что если во время исполнения программы памяти не хватает, то я выделяю эту самую динамическую память во время исполнения и во время исполнения ее очищаю.
И поэтому кажется, что понятие constexpr, то есть вычисление на этапе компиляции и динамическое выделение памяти не совместимы друг с другом.
На самом деле это по-прежнему так.
Просто C++20 разрешили использовать операции new внутри constexpr функций, но с дополнительными ограничениями.
Первое ограничение – это то, что я выделяю new int 10.
Вот это значение тоже должно быть в известном этапе компиляции.
А во-вторых, я обязан для этого выделения памяти вызвать delete.
Если я для этого выделения памяти не вызову delete, при этом компилятор это проверит.
То есть компилятор проверит, что я для этого new вызову delete.
Если этого не произойдет, то компилятор поругается, скажет, что я не могу вызывать constexpr функцию в случае, если для этого new не вызвано delete.
Кстати, таким образом теперь можно проверять верное решение, не допускаете ли вы усечь памяти на этапе компиляции.
Опять же, это такой вредный совет, но все-таки так можно сделать.
Если вы можете пометить функцию, которая выделяет динамическую память, как constexpr,
если вы ее не сможете вызвать на этапе компиляции, то компилятор поругается,
то вы увидите, что он поругается того, что вы для какого-то new не вызвали delete.
Дальше, DOSY плюс 23, constexpr функции не могли содержать Go2, DOSY плюс 23, они могли определять только нестатические литеральные переменные,
про то, что такое литеральные переменные, поговорим на следующем слайде.
Ну и самое главное, я уже сказал, что если вы в constexpr функции начинаете плюс 20 выделять динамическую память, при этом ее не освобождаете,
то компилятор откажется эту constexpr функцию запускать, ну запускать на этапе компиляции.
И дополнительно, если компилятор во время исполнения кода, во время компиляции увидит, что ваш код использует undefinedBehaviour,
то он кинет вам ошибку компиляции. То есть, на самом деле, теперь как бы в дополнение к этому можно проверять ваш код,
вашу функцию на то, содержат они undefinedBehaviour или нет. Ну как это делается, вы пишете функцию, помечаете constexpr,
и дальше подаете на вход константы времени компиляции, точнее, пытаетесь запустить эту функцию на этапе компиляции.
Если компилятор откажется запустить эту функцию на этапе компиляции, значит не содержится undefinedBehaviour.
При этом он сдаст соответствующие сообщения об ошибке. Ну либо он скажет, что вы для new не вызвали delete и так далее.
Понятно? Теперь давайте поговорим про то, что такое... давайте сюда немного перейдем.
Давайте поговорим про то, что такое литеральный тип. То есть, почему в C++, по-моему, до C++23 в constexpr функциях можно было использовать только литеральные типы.
Литеральный тип — это, по сути, тип, который состоит только из примитивных типов, там int, bool, double и так далее,
либо состоит из структур, которые, в свою очередь, тоже состоят из литеральных типов.
То есть, литеральный тип — это либо примитивные типы, либо какая-то структура или union, которая состоит из литеральных типов.
То есть, если у вас есть структура, давайте вот пример. То есть, если у вас есть структура A,
которая содержит внутри себя int, double и есть структура S,
которая внутри себя содержит поле A и поле bool, f, то структура A и структура S являются литеральными типами.
Потому что структура A является структурой от литеральных типов, а структура S тоже является структурой от литеральных типов,
а A является литеральным типом, потому что состоит из литеральных типов.
Да, да, но при этом, литеральный тип не может иметь конструкторов, кроме конструкторов копирования на перемещение,
деструкторов и так далее.
А пока еще примеры constexpr функции.
Соответственно, вычление Fibonacci теперь можно организовать тоже на этапе компиляции, просто добавив слово constexpr к функции Fibonacci.
Вычление степени тоже можно производить с помощью constexpr функции, при этом в constexpr функциях допустима рекурсия.
То есть я могу организовать рекурсивное вычление, возведение в степень.
И, соответственно, начинаясь смотреть, в чем проблема. При вычлении Fibonacci, что мне тут приходится делать?
При вычлении числа Fibonacci мне приходится как-то изворачиваться, хранить предыдущие значения, предпредыдущие значения и так далее.
Теперь при вычлении числа Fibonacci, начиная с плюс 20, я могу, как я уже сказал, я могу делать выделение с помощью new.
То есть я могу условно реализовать функцию Fibonacci так.
То есть завести какой-то динамический массив из n плюс одного элемента и заполнять его последовательно значениями i и i плюс 1.
Fibonacci от 0 это 0, Fibonacci от 1 это 1, Fibonacci от i это Fibonacci от i минус 1, плюс Fibonacci от i минус 2.
После этого я делаю delete, и программа работает корректно.
Выделение динамической памяти на этапе компиляции допустима.
В принципе, принципиальная разница будет, во-первых, то, что эта функция помещена как constexpr, не означает, что эту функцию мы обязаны запускать только на этапе компиляции.
constexpr функция, она может быть вычислена на этапе компиляции.
Но в то же время эту функцию можно вычислить на этапе исполнения программы.
Ну а раз мы эту функцию можем вычислять на этапе исполнения программы, то естественно мы заранее значение n можем не знать.
Ну а раз мы заранее значение n не знаем, то мы используем только динамический массив.
Да, кстати, начиная с Fibonacci плюс 20, в качестве вот этого самого типа можно использовать и vector.
То есть если в классе объявлены constexpr конструкторы, constexpr деструкторы и так далее, то сами типы тоже могут быть созданы внутри constexpr функции.
То есть vector на самом деле тоже можно использовать, начиная с Fibonacci плюс 20.
Окей?
Хорошо.
Так, следующий момент. Смотрите, я уже этот пункт проговорил, давайте еще раз рассмотрим следующую проблему.
Посмотрите, из того, что я функцию пометил как constexpr, следует ли что, что компилятор может вызвать эту функцию на этапе компиляции.
Если у компилятора есть выбор вызвать функцию на этапе компиляции или не вызвать на этапе компиляции, то корее всего компилятор сделает выбор в пользу того, чтобы не вызвать ее на этапе компиляции.
То есть компилятор довольно такие ленивая штука. Если у него есть возможность не делать что-то на этапе компиляции, то он этого делать не будет.
в частности. В частности, вот посмотрим, например, вот у меня есть систему массив,
в который я передаю результат вызова функции по от 3,5.
Погасил.
Да, смотрите, вот у меня есть систему массив, которая передаёт результат вызова функции по от 3,5.
Смотрите, вот тут у компилятора нет выбора, то есть тут компилятор обязан вызвать эту
функцию на этапе компиляции, чтобы просто нам понять, какого размера будет массив. Но если
я вызову, допустим, cout по у 5,3, то смотрите, несмотря на то, что вроде как все константы
известны на этапе компиляции, то есть и 5,3 не известны на этапе компиляции, компилятор
скорее всего будет вызвать эту функцию на этапе исполнения программы, а не на этапе
компиляции. Ну кроме того, понятное дело, как я уже сказал, констант-эксперт функции, они могут
быть вызваны на этапе компиляции, но они также могут быть использованы и во время рантайма,
то есть, например, если я в поу передаю просто случайное число, то это случайное число будет
вычислено на этапе исполнения программы и будет передано функцию, и функция будет вычислена на
этапе исполнения. Возникает следующий вопрос. Как написать функцию, то есть можно ли написать
какую-нибудь функцию, которая гарантированно будет вычислена на этапе компиляции? То есть можно
написать такую функцию, которая имеет смысл, которую имеет смысл вызывать только на этапе
компиляции? То есть я хочу, чтобы, во-первых, функцию компилятор всегда вызывал на этапе
компиляции, если у меня есть такая возможность, а во-вторых, чтобы просто не было возможности
вызывать конкретную функцию на этапе исполнения программы. И такая возможность есть. Точнее,
она появилась, начиная с E++20, и появилось снова ключевое слово, которое называется consteval.
Что такое consteval? consteval это функция, которая вычисляется только на этапе компиляции.
Соответственно, если я передаю в систему массив pow3.5, то pow3.5 будет вычислено на этапе компиляции.
Если я пишу cout pow.5.3, то эта функция pow.5.3 тоже будет вычислена на этапе компиляции.
Туда, на то место, где прописана cout, вот на то место подставится конкретное значение.
5 в степени 3. Но если я пытаюсь вызвать функцию pow.5.3 на этапе исполнения программы, то есть если
я в функцию pow.5.3 передам аргументы, которые не являются константными временем компиляции,
то, соответственно, возникнет ошибка в компиляции, потому что компилятор скажет, что в consteval
функцию можно передавать только const expression, то есть может передавать только выражение,
которое вычили мы на этапе компиляции. Понятно отличие consteval от constexpr?
constexpr может быть вычислено как на этапе компиляции, так и на этапе исполнения программы. При этом,
если есть выбор у компилятора, то он, скорее всего, выберет вычление ее на этапе исполнения,
а consteval вычисляется всегда только на этапе компиляции.
К чему еще может быть применено ключевое слово constexpr?
Ключевое слово constexpr может быть применено к переменным. Что это будет означать?
constexpr переменная — это, во-первых, константная переменная, то есть constexpr в этом смысле
работает аналогично ключевому слову const, но помимо того, что constexpr переменная является
константной, constexpr переменная обязана быть проинциализирована константой времени компиляции.
Пример.
Смотрите, я вполне себе могу написать что-то наподобие такого. int x
int x и потом создать const int x умножить на x. Смотрите, эта константная переменная — это
переменная константа, но при этом она проинциализирована значением,
которой неизвестны этапы компиляции. Согласны? Так вот, если бы я тут написал вместо const
expr, то это не скомпилировалось бы. Почему? Потому что constexpr,
но помимо того, что делает саму переменную константной, constexpr еще гарантирует,
что значение этой переменной будет известно на этапе компиляции. Но раз x неизвестна на этапе
компиляции, то и значение переменной square от x тоже не может быть известно на этапе компиляции.
Понятно? Вот, то есть constexpr, то есть таким образом можно использовать константная
переменная для того, чтобы гарантировать, что, то есть если вы хотите действительно сказать,
что значение данной переменной известно на этапе компиляции, вы можете помнить ее как
constexpr, ну и таким образом const станет более читаемым, и во-вторых, таким образом вы сами
себя будете проверять, то есть компилятор будет проверять, что действительно значение переменной
известно только на этапе компиляции, а не на этапе исполнения программы.
Вот. Соответственно, constexpr-переменные обладают следующими свойствами. Во-первых,
переменная должна быть литерального типа, ну мы про это сказали, вот. Она должна быть,
она обязана быть принципизирована константным выражением, вот сказали. И во-вторых,
constexpr-переменные являются, и во-вторых, constexpr-переменные являются сами по себе
константными. Ну, это я тоже упомянул. Теперь, смотрите, какая еще возникла проблема. Вот у нас
есть возможность писать const-переменные, есть возможность писать constexpr-переменные.
Вот. По сути, ну что можно сказать? Можно сказать, что constexpr-переменная, она является, ну такой
вот, часть constexpr-переменных, да, почему? Потому что constexpr-переменные, помимо того, что, так,
неправильно, да, наверное, ну так стоит. Ну, короче говоря, constexpr-переменная, помимо того,
что является еще и константной переменной, да, constexpr-переменная еще гарантирует, что она
обязана быть принципизирована константным выражением, вот. А что, если я хочу сказать следующее,
что если я хочу сказать, что переменная сама по себе не является константной, да, то есть переменная
может менять свое значение, но при этом принципизирована, она должна быть некоторым
константным выражением. То есть значение данной переменной, начальное значение данной переменной,
должно быть известно еще на этапе компиляции, вот, но при этом в последствии, да, в последствии,
в результате выполнения программы переменная может свое значение менять. Вот. Как можно,
как можно такое, как можно такое провернуть? Ну, смотрите, во-первых, для чего это может быть
нужно? Значит, пример показан на экране. Смотрите, вот у меня есть функция pull, когда объявлена
констэкспорт. Ну, по понятным причинам, да, то есть я хочу, чтобы возведение в степень, ну, работало
и на этапе исполнения, и на этапе компиляции, вот, но при этом я хочу дать дополнительную
возможность компилятору запускать эту функцию на этапе, на этапе компиляции, вот. Но если я напишу
вот такой код, там auto x равно поу 3 5, то несмотря на то, что компилятор может вычислить степень,
3 в степени 5 на этапе компиляции, скорее всего он этим заниматься не будет, то есть, ну, как минимум
вот это вот поведение, да, то есть, как минимум, вычисление на этапе компиляции не гарантируется. А что, если я хочу,
ну, что если я хочу сделать так, чтобы, ну, что если я хочу, чтобы у меня на этапе исполнения
программы не тратилось время на вычтение, на вычтение этой самой степени, что если я хочу, чтобы
значение переменной x начальное было уже заранее вычислено на заранее известный этапе компиляции. Вот,
чтобы этого достичь, да, чтобы вынудить компилятор, вот, в данном контексте вычислить значение функции pull,
можно поступить следующим образом. Можно воспользоваться ключевым словом constantit,
которое тоже появилось все плюс 20. Что такое constantit переменная? А constantit переменная,
ну, это как раз таки ровно та самая переменная, которая нам была нужна в предыдущем, в предыдущем
примере. А constantit переменная гарантирует, гарантирует, что значение данной переменной, начальное
значение данной переменной, будет известно на этапе компиляции, вот. Но при этом сама переменная
не является константой, вот. То есть, можно считать, можно считать, что constant export переменная,
constant export переменная, это есть const plus constantit, вот. То есть, constant export переменная,
она, во-первых, нельзя менять во время исполнения программ, во-вторых, ее значение должно быть
известно на этапе компиляции, вот. При этом, просто const переменная, она не обязана иметь значение,
которое известно на этапе компиляции, а constantit переменная, она, она может, в принципе, в теории
менять свое значение в процессе работы программы, вот. И поэтому, если мы рассмотрим данный пример,
то что у нас тут есть? У нас тут есть constant export функция pull, которая может быть вычислена на этапе
компиляции, и плюс вот этот самый вызов функции pull происходит при инициализации constantit переменной
х. Но раз constantit переменная х, она, обязана быть вычислена, то есть ее значение обязательно
быть вычислено на этапе компиляции, то к эмпилятору ничего не остается, кроме как вычислить значение
3 степени 5 на этапе компиляции, вот. Понятно? Есть ли вопросы? Смотрите, чтобы, то есть, там, на самом
деле, довольно сложные, в общем, сложные взаимоотношения с constant export, в общем, с constant export типами, давайте
вернемся. Вот, смотрите, вот dos и plus, dos и plus 23, в качестве, ну, в качестве, в качестве переменных,
которые могут встречаться в constant export функциях, могли встречаться только, могли встречаться только
литеральные типы. Почему Behr не считался литеральным типом? Потому что, ну, во-первых, у него есть
нетривиальные конструкторы, у него есть нетривиальные конструкторы копирования, конструкторы
перемещения, плюс он внутри себя, естественно, там, в своих конструкторах вызывал new, ну, а dos и
plus 20, соответственно, new в constant export контексте вызывать нельзя было, вот. Соответственно,
начиная с plus 20 в constant export контексте, можно вызывать теперь практически все что угодно, там всякие
try, catch блоки, new, delete и так далее, и плюс, соответственно, я, если я помечу, если я какие-то
конструкторы и диструктор помечу как constant export, то, соответственно, таким образом, я для типа скажу, что,
ну, данный конструктор можно вызывать на этапе компиляции, вот. Ну, соответственно, таким образом в
векторе появилось это все, то есть, во-первых, появилась поддержка выделения памяти на этапе
компиляции, плюс появилась поддержка constant export конструкторов, диструкторов, вот. Ну, и, соответственно,
начиная с plus 23, можно создавать с вектора и на этапе компиляции, вот. Есть еще вопрос, да.
Ну, потому что, ну, смотрите, если вы, проблема вот в чем, если вы объявите статическую
переменную, давайте, вообще, кажется, эта проблема довольно-таки очевидная, ну, давайте.
Смотрите, вот у вас есть функция f, вот. И представьте себе, что в ней есть статическая
переменная, static int x там равно чему-то, вот. В чем проблема статических переменных? Ну, проблема
статических переменных заключается в том, что, ну, статические переменные, они, смотрите, статические
переменные инициализируются всегда только один раз при первом вызове функции f, вот. При этом,
что считается первым вызовом функции f? Первым вызовом функции f считается, ну, как
тот момент, когда у меня программа там начинает свое исполнение, дальше у меня программа
исполняется, исполнилась, исполняется и в какой-то момент я там, и в какой-то
момент, соответственно, вызываю функцию f. Вот, как только я в первую вызвал функцию f,
у меня создается вот эта статическая переменная и дальше она начинает жить. Вот. В чем тут проблема?
Представьте, что я теперь функцию f могу вызывать в
конструктор-контексте, то возникает проблема, а что считать первым вызовом
функции f? То есть считать ли вызов функции f на этап компиляции первым ее вызван или нет?
То есть, смотрите, если у меня функция f вызвана вот здесь, то считается это или нет?
С одной стороны, считается, потому что вроде как функция была вызвана, а с другой
стороны, не считается, потому что предыдущий код, предыдущий legacy код,
он мог опираться на то, что функция f вычисляется только на этапе
исполнения, поэтому статическая перемена
вызывается только на этапе исполнения. Вот, это первая проблема, а вторая проблема
заключается в следующем. Представьте себе такую картину, а что если у меня тут стоит
какой-то указатель static int звёдочка x, и я тут пишу new int.
Что делать в этом случае? То есть, ну представьте, что я, допустим, разрешил
писать new, но при этом статическую перемену
записал какой-то указатель на какую-то другую переменную.
В чём тут проблема? Проблема состоит в том, что если я вычисляю функцию на этапе
компиляции, то мне нужен вот этот вот указатель, да, каким-то образом с этапом
компиляции потом в последствии перенести на этап исполнения. Но как бы на этапе
компиляции, на этапе исполнения будут совершенно разные значения. Вот, поэтому, в общем,
со статическими переменами большое количество проблем, поэтому до какого-то
момента они были запрещены. Вот, кстати, я не знаю, как они там решили эти
проблемы с плюс 23, надо это отдельно посмотреть. Вот, но в целом проблемы с ними есть,
поэтому, видимо, так долго их не водили. Ещё проблемы, ой, ещё вопросы или
проблемы? Хорошо, давайте, давайте посмотрим, что у нас ещё осталось,
константинит перемен, а, ну, в общем-то, всё, да. Собственно, мораль. Какая мораль?
Человечество проделало очень большой путь от вот этого к вот этому. Вот, поэтому,
в общем, что важно понимать? Важно понимать, вообще говоря, процесс инстанцирования
шаблонов, да, то есть важно понимать, что процесс инстанцирования шаблонов
происходит на этапе компиляции, поэтому при постановке шаблонов параметров у него,
то есть компилятор нет никаких вариантов, и он обязан вычислять те свои параметры на этапе
компиляции. Если у него такой возможности нет, то, соответственно, возникает ошибка
компиляции. Вот, ну и, наконец, современные стандарты C++ привнесли много всего нового,
чтобы можно было бы работать с вычислением на этапе компиляции. Вот, но, на самом деле,
с этим есть много разных проблем, которые постепенно решаются. Вот, постепенно рамки того,
что можно делать на этапе компиляции, что можно вычислять на этапе компиляции,
на этапе исполнения программы, они увеличиваются. Вот. Есть ли вопросы?
Ну, окей, тогда на сегодня все. До встречи в следующей неделе.
