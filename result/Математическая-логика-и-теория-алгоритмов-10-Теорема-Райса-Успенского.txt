Сегодня у нас будет последняя лекция чисто по теории вычислимости. Дальше мы будем переходить к связи между вычислимостью и арифметикой.
Мы сегодня изучим две теоремы. Одна теорема Райса Успенского о неразрешимости функциональных свойств программ.
А вторая теорема Клиния о неподвижной точке. Одно из известных следствий из нее это то, что для любого языка программирования есть Куайм.
То есть программа, которая печатает свой собственный текст.
Начнем с одного важного определения, которое не явно мы раньше использовали, но сегодня будем использовать явно.
Это определение называется главная универсальная вычислительная функция.
По сравнению с тем, что уже было, первое слово новое, главное.
Соответственно, это функция У из пар натуральных чисел, ну или обратите из пар строк на натуральные числа в строке, которая обладает тремя свойствами.
Первое свойство это вычислимость. Это означает, что У вычислимо как функция двух аргументов.
То есть есть программа, которая получает два аргумента и всегда возвращает значение, если функция определена и не останавливается, если функция не определена.
Второе свойство, что оно универсальное, это оно как раньше, давайте я повторю для полноты.
Для любой вычислимой Ф, 4 из натуральных чисел натуральные числа, существует такая программа, что для любого Х, 4Ф от Х равняется У от ПХ.
Вот это свойство еще называют тюринг полнота языка программирования.
Такую функцию можно понимать как язык программирования, где первый аргумент это программа, а второй аргумент это аргумент этой программы.
А сама У это такой компилятор, который получает программу, получает входные данные и запускает эту программу на входных данных.
Ну и соответственно, либо получается какой-то ответ, либо она не останавливается.
Но мы не узнаем, что она не останавливается.
Еще есть третье свойство, которое я на самом деле использовал неделю назад, когда мы обсуждали, что всякие свойства, типа всю доопределенности будут не перечислимые, не коперечислимые.
Значит, там мы это использовали.
Ну а общее определение того, что такое главная универсальна вычлемая функция, такое.
Для любой В из Н на Н в Н, то есть неформально говоря, для любого другого языка программирования, который даже не обязательно универсальный,
а просто какой-то язык, который получает текст программы, получает входные данные и получает какой-то ответ.
Боже мать.
Определенный, может неопределенный.
Для любого такого языка программирования существует перекодирование.
Значит, существует тотальная вычислимая функция.
Значит, С из Н в Н такая, что для любого П и для любого Х мы получаем, что В от ПХ это У от С от ПХ.
То есть есть как бы такой транслятор, переводчик, который программы для В переделывает, программы для У.
Причем этот транслятор сам является вычислимой процедурой.
Ну вот для обычных языков программирования, которые достаточно структурированные, ну все вот так вот и будет.
И вообще довольно сложно придумать функцию, которая была бы универсальной, но не главная.
Значит, неуниверсальность очень легко придумать.
Да, просто случайную функцию более-менее возьмете вычислимой, она скорее всего универсальна не будет.
Но придумать так, что она была универсальна, но третий свойств был не выполнен, довольно сложно.
Потому что обычные языки программирования имеют какую-то структуру.
Есть структура одного языка, а структура другого можно как-то регулярно переводить.
Ну и в принципе реальные компиляторы более-менее это и делают.
Они переделывают язык, текст программы на каком-то высокоуровнем языке, уже выполнимый файл, который стоит из команд для процессора.
То есть это компиляторы настоящие, они скорее как раз как это функция сделают из одного языка, другой перекодируют.
Но тем не менее, всякими изощрёнными методами можно придумать и не главные языки, и мы это сегодня сделаем.
Так, хорошо.
Значит, теперь смотрите, я нарисую такую диаграмму.
Значит, вот это будут перечислимые языки.
Значит, перечислимые языки, вот это вот, ну или множество.
Да, языки это термин уже такой из теории формальных языков.
Ну ладно, раз я написал, давайте как пояснение напишу множество.
Просто когда множество слов, а не множество чисел, то его часто называют языком.
Вот поэтому я так и написал.
Значит, здесь будут копии перечислимые языки.
То есть дополнение к перечислимым.
Вот, значит, с пересечения будут разрешимые языки.
Значит, про это говорит теорема Поста.
Да, мы в какой-то момент доказывали, что множество разрешимо тогда и только тогда, когда оно и перечислимо, и ко перечислимо.
Ну, значит, в прошлый раз было некоторое количество примеров.
Значит, например, проблема остановки будет вот здесь.
Перечислимо, но неразрешимо.
Значит, бывает копии перечислимые, но неразрешимые.
Я сейчас не помню, какой был пример в прошлый раз.
Но, например, вот ИД, это я имею в виду empty domain.
Значит, empty domain – это множество нигде неопределенных программ.
Значит, множество нигде неопределенных программ.
Ну, ко перечислимо, потому что где-то определенные программы будут перечислимыми по куче разных причин.
Например, можно по очереди запускать на все большем числе входов, на все большее и большее число шагов и смотреть, остановится ли хоть где-то.
Если хоть где-то, хоть какое-то число шагов остановится, то мы говорим, что да, эта программа где-то останавливается, и это будет перечисление как дополнение к ЕД.
Ну, а вот, например, множество всюду определенных программ или множество программ конечной области определения,
ну, дайте я про все прокомментирую, аж проблемы остановки.
Ну, обычно, это множество пар из программы и входа. Такие, что эта программа останавливается на этом входе.
Но можно рассмотреть, например, проблему остановки на конкретном входе. То есть верно ли, что данная программа останавливается на пустом слове, например.
Вот, тогда уже здесь, как и во всех остальных, это будет именно множество программ, а не множество чего-то более хитрого.
Так, значит, Т это множество всюду определенных программ, всюду определенных программ, значит, ЕД, ФД это множество программ с конечной области определения.
Соответственно, смотрите, это все получается разной свойствой программ, и ни одно из них не попало в пересечение, в разрешимые языки.
Ну, вот теорема Райс Успенска говорит, что это неспроста.
Теорема Райса Успенского.
Но коротко она говорит, что есть какой-то
вопрос, что я могу делать.
Успенского, но коротко она говорит, что любое нетривиальное
функциональное свойство программ, свойство программ
неразрешимо.
Сейчас мы подробнее всё, тут очень много на самом
деле оговорок.
Так, значит краткая формулировка, значит полная формулировка.
Что такое нетривиальная штука и функциональное
свойство?
Функционально это означает, что зависит от того, что
эта программа делает, а не от того, как она выглядит.
Например, свойство программы иметь чётную длину – это
неразрешимые свойства, а свойство программы содержать
конкретный символ – тоже разрешимые свойства.
Но свойства вычислять данную функцию уже будут неразрешимыми.
Или все вот те перечисленные.
Соответственно, есть какое-то множество вычислимых функций.
А это множество вычислимых функций.
Значит такое, что оно не пусто, его дополнение тоже
не пусто.
Это означает нетривиальность.
Такое, что А не пусто, и дополнение КА тоже не пусто.
Значит вот это и означает нетривиальность.
Далее, второй пункт, который в этой формулировке вообще
под ковром.
Второе предположение, что есть именно главные универсальные
вычислимые функции.
Пусть У – это главные универсальные вычислимые функции.
Что же такое функциональность?
Функциональность может сказать следующее, что две программы
вычисляющие одну и ту же функцию, либо обе обладают
этим свойством одновременно, либо обе не обладают.
Соответственно рассматривается множество программ, таких
что, если мы вот так фиксируем первый аргумент равный этой
программе и второй аргумент варьируем, то есть эта точка
означает, что мы эту запись понимаем как функцию от
второго аргумента при фиксированном первом.
Это получается, конечно, вычислимая функция, и соответственно
она может лежать ва или не лежать.
Соответственно, мы берем множество тех, при которых
эта функция лежит ва, и говорим, что тогда она неразрешима.
Вот это и есть арема Райса Успенского.
Получается, что функциональность означает, что те программы
для одной функции либо берем все вместе, либо не берем
все вместе.
Значит, функциональность свойства программ означает,
что те программы для одной и той же функции либо одновременно
обладают свойствами, либо одновременно не обладают.
Но здесь так и получается либо одновременно.
Ну что, я надеюсь, теперь понятна и полная формулировка.
Если остались какие-то вопросы, то задавайте, сейчас
будем доказывать в общем виде.
То есть было некоторое число частных случаев для всех
перечисленных.
Для всех перечисленных здесь мы доказывали.
Я помню, у нас было не определенные функции, а функции, которые
константны на области определения.
Да, такой у нас был пример этой самой функции, которая
перечислила, но не разрешима.
Не функция, а множество.
Нет, это в этом теориям и заключается.
Сейчас будем доказывать.
Так, давайте, и тут как-то многое, это самое, я это
выделю.
Значит, как раз вот это вот, да, это утверждение теоремы.
Так, ну, значит, доказательства.
Ну, вот рассмотрим, рассмотрим нигде не определенную функцию.
Да, это не если вполне конкретная функция, обозначен ее греческой
буквой z, такая очень используемая в математике, да, там есть
эта функция Риммана, z распределения и так далее.
Вот, если не умеете писать, то поучитесь.
Да, это на самом деле легко, такая петелька, да, я потом
вот так вот.
Вот, значит, z от x, значит, z от x это нигде не определенная
функция.
Значит, нигде не определенная функция, конечно, вычислима.
Тривиальная программа стоит на месте, ничего не делать.
Тогда она никогда не остановится и как раз вычислит нигде
не определенную функцию.
Вот, значит, раз она вычислима, то она либо обладает свойством
вот этим аккорасивом, либо не обладает.
Ну, без ограничений общности можно считать, что обладает.
Без ограничений общности z лежит ва.
Вот, но значит, также анетривиально это означает, что есть какие-то
функции, которые в этом не обладают.
А с чертой не пусто.
Из этого следует, что существует x, который лежит, ну, который
не лежит ва.
Ну, и x конечно уже где-то будет определена.
Так, значит, теперь рассмотрим какое-то перечислимо-неразрешимое
множество k.
Так, и теперь рассмотрим вот такую функцию v.
Так, v от qx.
Значит, v от qx будет выглядеть так.
Значит, это будет вот это вот x.
Если q у нас лежит в k, и z от x, если q не лежит в k.
И это вычислимая функция, вычислимая функция двух
аргументов.
Значит, почему она вычислимая?
Ну, например, можно сказать так, то мы перечисляем просто
множество k и ждем, пока там появится число q.
И как только появилось, запускаем программу x от
x.
Все, на этом программа закончилась.
Но не закончился анализ программы.
Теперь можно сказать так, что если q лежит в k, то действительно
мы рано или поздно до него дойдем, и в этот момент
начнем вычисление x от x и вычислим то, что нужно.
Но если q не лежит в k, то мы никогда не дойдем до
этого q, и все время будем ждать бесконечно долго.
Но при этом вычислим именно то, что нужно, потому что
нам тогда и нужно не остановиться.
Поэтому это вычислимая функция.
Когда я говорю, что x лежит в a, имеется в виду, что я беру
именно вычислимую функцию не из a.
А это вообще свойство вычислимых функций, это, можно сказать,
разбиение множества вычислимых функций на два подмножества.
Так что x будет по определению вычислим, а что вот к этой
штуке можно применить это свойство.
У нас получается, что существует s, так что у него отклик был
долгим.
Так, а что он перегрелся, что ли?
Так, так я был долго писать.
Ладно, хорошо, что есть получается, ну то, что там написано.
Дальше для любого q получается, для любого q и для любого x,
значит, соответственно, v от qx.
Так, сейчас, если так будет, я не смогу энтузку использовать.
Сейчас дорисую, v от qx, значит, равняется u от s от q и x.
Так, ну ладно, сейчас посмотрим, если что, придется только на этой доске писать.
Так, хорошо, значит, это именно для этого v, но тогда что же мы получаем?
Значит, мы получаем, что если q лежит в k, то мы получаем, что v от q, вот я точку буду писать
вместо аргументов, чтобы подчеркнуть, что я считаю аргументом.
v от q и аргументы это будет q от аргумента.
Значит, из этого следует, что u от s от q и аргумента это тоже будет q от этого аргумента.
Вот, а из этого следует, что, так, давайте считать так, что вот a красиво это множество функций,
а еще есть a простое. Значит, a простое это множество таких p, в общем, как раз то,
которое там было написано. Значит, множество таких p, что u от p и второго аргумента лежит в a красивом.
Вот, в общем, из этого следует, что у нас что? Значит, q у нас не лежит в a красивом, значит,
s от q не лежит в a простому. Ну и симметрично получается, что если q не лежит в k, то тогда
получается, что v от q и второго аргумента это z, то есть получается, что u от s от q и второго
аргумента это z нигде не определенное. Вот, а тогда получается, что s от q у нас лежит в a простом.
Да, то есть функция вот эта, вот как функция z лежит в a красивом,
значит, программа, которая вычисляет относительно u, лежит в a простом. Вот, соответственно,
итог. Значит, итог, получаем, что q лежит в k множестве k тогда и только тогда, когда s от q лежит в a. При этом,
s у нас из определения главной универсальной вычислимой функции, s будет сюда определенная
универсальной вычислимая. А у нас было определение в прошлый раз, что когда такое бывает, это означает,
что k у нас m свелось к множеству a. Но поскольку мы же взяли k не просто так, а неразрешимым,
то а получается тоже неразрешимым. Вот. А, да, вы правы, вы правы. Да, давайте перечеркнем. Тогда
здесь сказка с чертой получилась, но для разрешимости это неважно. Да, спасибо за поправку. Надо было
в самом начале взять, что z не лежит в a, тогда здесь бы не нужно подчеркивать. Но, в общем,
все неважно. Это все неважно. Получается, что если k у нас взято неразрешимым, значит, если k
неразрешимым, то а с чертой тоже неразрешимым. Но и а неразрешимым. Вот. Причем сказать,
что это про перечислимость нельзя, потому что вот у нас там было безгорячение общности. Да,
то есть так-то у нас, скажем, k у нас не коперечислимо, и поэтому а с чертой тоже не
коперечислимо. Да, то есть а не перечислимо получилось. Но поскольку там было безгорячение
общности, то в другом случае получилось бы не коперечислимо, и, соответственно,
надежно ничего сказать про перечислимость а нельзя. А про разрешимость можно. Значит, а точно
неразрешимо. Вот. Ну что, какие-нибудь вопросы? Так, давайте посмотрим, это починилось доска или
она. Ничего, похоже, не починилось. Вообще не откликается. Да. Ну, потому что у нас здесь,
по предположению, что здесь вот, так, а вон три страницы добавил. Так, невидимо,
я тут не смогу писать, тут все зависло. Ну, так, ладно. Короче, что у нас там было? У нас там
было, что ксия не лежит ва. Значит, вот это у нас не лежит ва красивом. Вот. Но если функция не лежит ва
красивом, то программа для нее не лежит ва прямом. Вот. Тут снова что ли память забилась? Так, ладно.
Эту доску я больше-то не буду использовать сегодня. Вот. Ну, а здесь, соответственно, вот этот
z будет лежать у нас ва. Так. Ну, ладно. Значит, в частности, смотрите, что у нас получилось. Значит,
следствие из теоремы. Значит, следствие из теоремы Райса Успенского будет таким. Значит,
множество программ, которые вычисляют одну конкретную функцию. Да, то есть смотрите, значит,
если f из n в n вычислимо, значит, а u это главная универсальная вычислимая функция, то тогда
нож таких p, что для любого x, у от px равняется f от x, значит, это получается неразрешимо. Вот. И в том
числе оно бесконечно. Значит, оно неразрешимо и в том числе бесконечно. В том числе бесконечно. То есть,
как бы любую программу можно написать бесконечным числом способов. Ну, то есть, любое задание,
любое программистское задание можно выполнить бесконечным числом способов. Так, ну это вы,
возможно, и так понимаете. Значит, на любом нормальном языке программирования, значит,
можно оставлять комментарии, какие угодно, с какой угодно большой длины и любого содержания.
Так, хорошо. Но это следствие позволяет построить неглавную функцию. Вот. Значит, построим неглавную
функцию. Значит, неглавную вирсально учитимую функцию, значит, которой вот это наше z от x,
значит, негде неопределенная функция имеет ровно один номер. Так, тут что-то открылось, да. Так,
по крайней мере, хорошо бы восстановить. Так, ладно, я с этим потом разберусь. Значит,
как это будет устроено? Ну, значит, смотрите, у нас есть множество ЕД, которое множество негде
неоплённых программ. Да, то есть сначала у нас есть какая-то обычная, обычная универсальная
функция, да, из вирсально-машин-тюринга. Так, давайте я снова. Значит, пусть у, это
главная универсальная учитимая функция. Значит, соответственно, ЕД это множество таких П,
что для любого х у от Пх не определено. Значит, дальше, соответственно, есть, ну, получается,
ЕД с чертой, но это наоборот. Значит, множество П таких, что существует х, то у от Пх определён.
Вот, и этот ЕД с чертой перечислим, а с чертой перечислимо. Ну вот, перечислять будем,
начиная соединиться. Значит, П1, П2, П3 и так далее. Так, а теперь, смотрите, рассмотрела такую
функцию. В от И и х. Значит, это будет не определено, если И равно нулю, и это будет у от П и Т х,
если и больше нуля. Вот, утверждается, что эта функция как раз универсальна, но не главное.
Вот, это В, это универсально учитимая функция, но не главное. Так, значит, чего она вычислима,
во-первых? Ну, вычислима, потому что вот это перечисление, да, то есть, конечно, мы можем
сравнить ЕС нулём, конечно, можем зациклиться, если Е равно нулю, а если Е больше нуля, то мы
начинаем вот это перечисление, ждём, пока ИТ программа встретится, её подставляем вот в эту
функцию, и это получается такая, как бы большая композиция вычислимых функций. Так, она вычислима,
дальше, почему она универсальна? Ну, универсальна, потому что, если функция нигде не определена,
то тогда вот для неё есть И, равная нулю, а если функция где-то определена, то она встречается вот
в этом перечислении, и, соответственно, под некоторым номером И она встретится, да, и будет
здесь. Вот, поэтому она универсальная. А почему она не главная? А не главная, потому что, как раз
нигде не определённо, имеет ровно один номер ноль. Не главное, потому что Z от X имеет один номер ноль.
Вот. Нет, значит, смотрите, из V в U мы можем перекодировать, но наоборот мы не можем. Да, то есть,
смотрите, почему мы не можем, почему так получается, что она не главная, почему мы не
можем перекодировать из обычного языка вот в этот, потому что нам нужно понять по программе
для обычного языка, будет она где-то определена или не будет. И если она нигде не определена,
нам нужно вернуть обязательно И, равная нулю. Вот. А если, соответственно, определена, то что-то
неравная нулю. Ну и получается, тогда бы мы для исходной задачи могли, для исходной универсальной
функции, это нумерация называется, для исходной нумерации мы могли бы решить задачу о нигде
неопределённости, что если перекодировка вот в эту функцию даёт ноль, то значит нигде не
определена. Если больше, значит где-то определена. Вот. А раз мы это решить не можем, значит и
перекодировок такой нет и поэтому она не главная. Вот. Но такая конструкция есть, на эту тему есть
очень сложная теорема. Я как-то один раз пытался в ней разобраться, но это в принципе можно,
там не нужно там два месяца что-то учить, но там довольно хитрое рассуждение, так что
её только сформулирую. Называется теорема Фридберга. Значит теорема Фридберга
заключается в следующем, что есть функция, есть универсальная функция, у которой у любой
вычислимый есть ровно один номер. То есть получается существует такая В, то для любой
F вычислимый существует единственная такая программа P, что для любого x равняется f от x.
То есть это такая однозначная номерация вычислимых функций.
Есть такая шутка, что в такой номерации очень просто было бы проверять задачи
по программированию, что просто для любой функции есть ровно одна программа, которая вычисляет,
и соответственно, если вы именно эту программу сдали, то значит зачет, если будет другую,
то не зачет. Но конечно в реальности ее нельзя применять, ну как бы ничего хорошего в этой
номерации нет, кроме красивой математики. Да, на практике, конечно, это очень затруднило бы такое
написание программы. Так, хорошо, ну что, киньте вопросы. Так, я думал сейчас небольшой
перерыв сделаю, потому что сейчас немножко другая тема начнется. Ну, дайте на 5 минут.
Вторая тема это, значит, куайны и теоремы клиния. Значит, куайны это программы, которые печатают
собственный текст. Программы, которые печатают собственный текст. Вот, значит, если писать инструкцию
на естественном языке, то можно писать следующее. Значит, напечатать дважды. Я вторую копию в
кавычке. Ну и дальше тоже самое. Напечатать дважды.
Взяв вторую копию в кавычке. А если вы эту инструкцию исполните, то ровно такое тексте
должен получиться. Ну, вот, аналогичные конструкции бывают и на разных других языках
программирования. Ну, значит, утверждается следующее, что если у вас язык программирования
производит главную универсальную учлимую функцию, то там такое можно сделать. Значит, теорема
такая. Теорема о куайнах. То если у – это главная универсальная учлимая функция,
значит, то тогда, ну, можно, например, так написать. Значит, существует п, такое что любого х,
значит, у от pх равняется п. То есть это получается функция дается константой. И это не
просто константа, а это константа равная номеру этой функции. Вот так. Значит, это теорема
о существовании куайнов. Так, да, тогда я тебе это напишу. Значит, теорема о существовании куайнов.
Значит, куайна – это тоже фамилия одного логика, но вот она стала нарисательным выражением.
Так, значит, вот эта теорема о существовании куайнов следует из более сильной теоремы к линии о
неподвижной точке. Теорема к линии о неподвижной точке. Так, значит, пусть у нас есть какое-то
преобразование. Ну и как у нас тут всюду? Пусть у нас есть главная универсальная учлимая функция.
Значит, пусть есть главная универсальная учлимая функция и есть какое-то преобразование h из n в n.
Значит, это всюду определенная учлимая функция. Можно сказать, что это h – это
преобразование программ. Значит, h – это преобразование программ.
Значит, тогда неформально теорема говорит следующее, что есть такая программа,
которая до преобразования делает то же самое, что после преобразования.
Значит, есть программа, которая до преобразования делает то же
то и после преобразования. Ну а формально получается следующее. Существует такое,
что для любого x у от px равняется у от h от px. Значит, вот на любом x до преобразования
то же самое, что после преобразования. Вот это есть неподвижная точка. Неподвижная точка
преобразования. Обычно неподвижная точка – это прям, что h от x равно x. Но здесь, конечно,
такого может не быть. Но если мы смотрим на то, что программа делает, а не на то,
как она выглядит, то неподвижная точка будет. Так, значит, хорошо. Как из вот этой теоремы
к линии получить теорему о сочетании Куайна? Ну смотрите, мы, конечно, используем, что у нас
функция. Как теоремы к линии вывести теорему о существовании маленькой буквы. Так, ну смотрите,
рассмотрим такую функцию v от px равняется p. Это, конечно, будет вычислимая функция двух
аргументов. Из этого следует, что поскольку u – это главная универсальная вычислимая функция,
то из этого следует, что существует s такое, что у любого x, v от px равняется u от s от px.
И теперь вот эту вот функцию s, которая получается из определения главной универсального
вычислимой функции, вот эту функцию s мы воспределим как функцию h из условий теоремы к линии.
Значит, по теоремы к линии существует p, так же для любого x, u от px равняется u от s от px.
Ну а дальше мы дописываем здесь, что это равняется v от px и это равняется p.
Соответственно, итог получается как раз какой нужен. Существует p для любого x,
значит, u от px равняется p.
Значит, неформально можно сказать так, что мы рассматриваем такое преобразование программ,
что из программы P делаем программу напечатать текст P,
соответственно есть программа, которая до преобразования делает то же самое,
что после преобразования, но после преобразования она напечатает текст P,
значит, до преобразования она тоже напечатает текст P, то есть до преобразования она напечатает
свой собственный текст, а это нам и нужно было.
вот так ну что понятно ладно тогда будем доказывать теорему к линиям
так ну на самом деле я не претендую на то чтобы объяснить там глубокую сущность
его я сейчас ну сейчас будет некоторый такой кролик из шляпы да то есть я буду
какие-то странные действия делать об итоге терема докажется вот значит
почему так получается но в книжке речи один шиня там есть какой-то глубокое
объяснение что нужно смотреть там на то что преобразование бывает какие там
классы квалентности что он делает там и так далее вот но это так просто трудно
двух словах сказать да то есть сейчас я расскажу них такой формальное
рассуждение да где как бы все переходы я надеюсь что будет понятно но общая идея
может ускользнуть и это нормально так хорошо так ну начнем с того что сделаем
следующее значит вот такую вот транную функцию рассмотрим v от px это будет у от
у от пп и икс вы смотрите что получается получается что программу п запускаем на
своем собственном тексте дали там машину п запускаем в своем собственном номере и
то что получилось тоже приспособляем как программу и уже ее запускаем на входе
икс вот если у от пп не определено то тогда и такая штука тоже нигде не
определена получается вот если у от пп какой результат дало то мы его теперь
запускаем на икс да это наш программ в от п икс значит конечно вы от по икс
будет вычислимой функции по крайней мере на вы от п икс будет вычислимой функции
значит к ней можно применить условия главности так значит это вычислимая функция
значит этого следует существует с значит такое что для любого значит существует
с такое что для любого икс получаем что в от п икс равняется у от с от п икс значит
это у нас поскольку главное значит поскольку у это главная висальима члены функция так
значит теперь смотрите мы пока вообще про условия ничего не сказали у нас условия была
функция но не у нас есть у условия да как главный но еще есть функция аж собственно
само преобразование вот этот функция что же сюда подъемная вычислимая вот дальше мы
делаем следующее дальше рассмотрим насчет т от икс т от икс которая будет равняться аж от
икс от икс вот это у нас ну по крайней мере вычислимая функция даже сюда определенно но
важно значит важно что просто вычислимая функция так
сейчас успеем и доказать немножко обсудить значит рассмотрим т от икс до аж от с от икс
вычислимая функция дальше дальше мы пользуемся просто универсальностью да вот это сейчас здесь
мы пользуемся главностью главной универсальностью а дальше просто универсальностью да значит
поскольку у это просто универсальничная функция то существует ку значит существует ку такое что
для любого икс значит т от икс равняется у от ку икс
так хорошо ну теперь тоже можно сказать что утверждается значит утверждается что
и с от ку это неподвижная точка значит утверждение то и с от ку это неподвижная точка
так я сейчас перелесну на следующий экран так понятно ли пока все ну совершенно непонятно
зачем все нужно да но сейчас как бы да сейчас вот кролик вылезет из шляпы и все что здесь написано
этом экране да значит понадобится вычислимки которые покажут что это действительно неподвижная
точка сейчас это буду переключаться до сюда между экранами так но будем доказывать что это
неподвижная точка рассмотрим у от и с от ку икс так ну что мы здесь можем применить
ну вот это очень похожая да только весь п вместо ку но значит и здесь будет соответственно ку
вместо п то есть это будет равняться значит в от ку икс если всю добру каждому равенству
значит это получается из определения с так функция это будет верно так значит что
дальше первый раз есть в в от ку икс данную можно теперь вот это вот определение вы применить
значит тут будет у от у от ку ку икс так значит это определение в
так значит дальше мы вот сюда вниз пойдем у нас там у от ку ку но это вот
вот если их равно ку то у от ку ку будет равняться ты от ку и это определение ку на самом деле
то есть это будет равняться на счет у от п от ку на счет икс
значит это получается из определения ку
так дальше что мы теперь используем на определение t наверное да значит
t у нас вот нет вот это вот это h от s от икс и вроде сейчас уже все получится да то есть
последний переход получаем что значит у от h от s от ку икс значит это получается из определения t
значит смотрите мы здесь икс вообще никак не использовали да то есть икс был любой значит
это верно для любого икс и это он то что нам нужно значит мы получаем что для любого икс значит у
от с от ку икс равняется у от аж от с от ку икс это и значит что я садку это неподвижная точка
ну вот то есть рем доказано да причем она конструктивно доказано да что не просто
не просто мы утверждаем что она есть мы прямо предъявляем да я в нас показываем откуда ее найти
так ну что какие-нибудь вопросы
так у меня еще небольшое время остается значит я хотел бы чуть-чуть поговорить о вот таких ну не
совсем таких игрушечных применениях да потому что куайна это вообще все такое развлечение да
есть такой это мега куайн где взято там 50 разных языков программирования вот и грубо говоря там
написано программа на s и которая пишет программу там на джабе да потом программа на джабе пишет
программу напитония до програм Elizabethhta не пишет там программу на просте и так далее вот а
последняя программа пишет еще самую первую программу на то есть это еще так эзоцикленно
вот есть такой пример еще там как-то это еще и графически выстроено что ведь красивая
и в картинку получается, на крайней мере, исходная
программа.
Но вообще, это всё пила, но это какие-то игрушечные
применения.
А если что-то более серьёзное?
Давайте я расскажу, это не то, что прям теорема,
ну хотя это можно сравнивать как теорема, но это скорее
философское понимание.
Наблюдение, давайте я так напишу, это можно сформировать
как теорему, но теоремка эта будет скучноватая.
А наблюдение само по себе полезное.
Наблюдение, что за счёт теоремы к линии можно писать
рекурсивные программы.
Можно писать рекурсивные программы.
На любом языке программирование, которое соответствует
главной универсальному члену и функции.
На любом языке программирования, соответствующем главной
универсальному члену и функции.
Неважно, есть ли прям синтактические средства для рекурсия,
но всё равно по факту их писать можно.
Значит, почему это так?
Давайте рассмотрим какую-нибудь рекурсию.
Например, для факториала, рекурсивная формула, что
что факториал N, значит, это будет 1, если N равно 0.
И факториал от N минус 1 умножить на N, значит, если N больше 0.
Стандартное рекурсивное учление факториала.
Смотрите, почему это правило что-то определяет.
Тут получается, что мы функцию определяем через саму себя.
То есть, можно сказать, что факториал – это решение
этого уравнения.
Значит, можно сказать, что это уравнение на неизвестную
функцию факт.
И вопрос, почему у этого уравнения есть решение.
Если говорить о теории множеств, то теория мы доказывали
от рассвидетельной рекурсии, что любое такое правило
однозначно дает какую-то функцию во вполне упорядоченном
множестве.
А натуральный чисто, конечно, является вполне упорядоченным,
но в каком-то другом, например, в целых числах уже не любое
даже в принципе это определение, конечно, что задаст.
Не, это, наверное, задаст за счет этой единицы, это
задаст, но если произвольную такую написать.
А, нет, сейчас, ничего не задаст, потому что, смотрите,
если там должно быть что-то факториал нуля, что вообще
для отрицательных вообще не понятно, что делать.
В общем, да, ладно, короче говоря, если у вас не вполне
упорядоченное множество, то к рекурсии нужно аккуратно
подходить, и она может ничего не дать, может дать все
угодно.
И, соответственно, ничего не получится.
Ну, хорошо, но даже пусть у нас с теорией множеств
есть тярема, почему, собственно, программа есть, которая
ее вычислит.
Чего вычислимая функция получится?
Вот.
Ну, вот почему.
Значит, смотрите, рассмотрим программу, такую не программу,
да, функцию двух аргументов.
Значит, v от p и n.
Значит, это будет равняться как раз единице, если n равно
е.
Ну, значит, еn умножить на, я нет, сейчас, извините,
здесь я не могу писать v, ну, наверное, надо написать.
Так, ладно, сейчас, дайте попробую правильно написать,
значит, тут, если n больше 0.
Так, хорошо, значит, тогда что получается?
Да, наверное, правильно, да, потому что тут я как бы
не вращаю какую-то программу в ту, которая не на вот
это воспринимает как правильную, ее применять к n-1, умножать
на n, да, но теперь это тут уже не обязательно u.
Вот.
Но как раз тярема к линии говорит, что вот это v можно
и на u тоже заменить.
Значит, почему?
Смотрите.
Значит, если u это главная уникальная вычисленная
функция, то тогда существует сюда определенная s, значит,
такая, что для любого p, для любого n, значит, v вот
u от p и n равняется u от s от p и n.
Так, значит, дальше.
По тяреме к линии теперь, по тяреме к линии у нас существует
п, такое, что для любого n, u от p и n, значит, равняется
u от s от p и n.
Тут как раз очень удобно, да, что и в условиях тяремы
к линии, и в определении главной универсальной
вычисленной функции у нас функция вычисленной
всегда определенная.
Да, то есть вот эту s я осределяю как функцию h из условий
тяремы к линии.
Вот.
После этого получаем следующее.
Значит, получаем, что при этом p и любом n, значит,
получаем следующее, то u от p и n равняется u от s от
p, так, от s от p и n, это у нас равняется v от p и n, а это
равняется как раз единице, если n равно 0, значит, и n
умножить на u от p и n минус 1, если n больше 0.
Вот.
И теперь, если посмотреть на начало и на конец, то
получается, что именно программа p удовлетворяет рекурсивному
правилу.
Но вот и получается, что есть программа, и так на
самом деле не только для этого, а для любого правила,
то есть отсюда уже недалеко до общей тяремы, что для
вычислимого рекурсивного правила, надо там только,
вот, чтобы это прям точно с теми получилось, нужно
аккуратно сказать про условия завершения.
Да, что нужно, ну, например, да, например, можно сказать,
что значение в каждой точке зависит только от меньших,
значений в меньших точках, тогда в 0 автоматически
нужно взять конкретное значение задать, потому
что меньших у него нету.
Вот.
Значит, соответственно, для любого рекурсивного
правила существует программа, которая этому правилу соответствует.
Ну вот.
Вот такое применение.
Ну что, есть какие-нибудь вопросы?
Ну тогда на сегодня все.
Спасибо за внимание, будем приходить к арифметике.
