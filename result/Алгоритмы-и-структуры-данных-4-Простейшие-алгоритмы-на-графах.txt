Так, добрый день, второе, да, так, ну что, мы переходим
к графам, у нас до конца семестра будет граф, так
что brace yourself, что называется, а очень кратко, что такое
граф, граф у нас будет неориентированный и ориентированный, что такое ориентированный
граф, это пара VE, VV это какое-то конечное множество, а E вложено
в V на V, соответственно картинка, мы будем элементы V изображать
точечками, а элементы E изображать стрелочками из
одной вершины в другую, то есть если у нас есть как
бы что такое E под множество V на V, значит это набор пар,
каждая пара упорядочена, у нее есть первый элемент
второй, первый это то откуда ведет, стрелочка второй
это куда, например если есть три вершинки и вот такие
вот ребра, мы можем сказать, что у нас есть ребра один-два,
один-три и два-три, вот, дальше неориентированный граф
ну, начало такое же, вот, а E теперь это у нас под множество,
чего бы вы думали, CSV подва, где CSV подва это все неупорядоченные
под множество из двух элементов, потому что когда у нас граф
неориентированный, у нас соответственно, мы хотим
чтобы в E лежали неупорядоченные пары, то есть по факту множество
двуэлементное, но CSV подва это как раз все двуэлементные
под множество, тот же граф, если я нарисую уже без стрелочек,
у нас ребра будут один-два, два-три и один-три, их как
бы оптимальные всего рисовать именно в фигурных скобках,
потому что это неупорядоченная пара, и мы всегда можем менять местами,
а круглые скобки, вообще говоря, да, правильнее было бы оставлять
для ориентированных ребер, вот, я не всегда буду придерживаться
такой оптимальной нотации, часто я буду просто обозначать
в ребро, независимо от того он ориентированный или
нет, но правильнее было бы всегда делать оставить
этоimalу для ориентированных ребер, а вот это estrutки
ориентированных.
Но это в идеальном мире, мы часто будем просто вот
так вот обозначать и то, и то, аosition ohm, и ориентированные
и ориентированно, и неориентированно.
Так, ну, значит, я не буду давать нам всякое определение
путей, циклов и так далее, нам будет хватать интуитивного
понимания, благо, это можно очень легко формализовать.
Ну, тогда, когда мы будем про это говорить, мы и так
будем понимать, о чем речь, поэтому всякие остальные
определения я не пишу.
Называется DFS, расшифровывается depth first search или поиск в
глубину.
Значит, ну, что он делает, да, классическая постановка
такая, вы стоите в лабиринте, вы граф воспринимаете как
лабиринт, вы находитесь в какой-то точке, в одной
из вершин, и вам нужно, ну, там, например, обойти
все или дойти до какой-то конкретной вершины.
И вы не очень хотите думать, вы просто берете и переходите
по кому-то доступному ребру.
Значит, мы реализуем его, я сейчас напишу наиболее
полную реализацию, которая сохраняет наибольшее количество
информации, которая нам потенциально понадобится.
Значит, во-первых, как я храню граф.
Сегодня у меня будет только ориентированные графы,
и я их буду хранить в виде вектора-вектора.
Значит, у меня для каждой вершины будет список ее
соседей.
Значит, давайте я вот здесь вот напишу, что g вот v, это
ну, давайте прям формально, все такие u, что v, u это ребро.
То есть для каждой вершинки v у меня есть список всех
ее соседей, то есть то, куда я могу добраться за один
шаг.
Вот есть v, вот есть все ребра из нее исходящие, и они все
лежат в списке g вот v, в векторе точнее, в векторе g вот v, все
ее соседи за один шаг.
Вот, ну а дальше всякая вспомогательная информация.
Значит, давайте я заведу vector int parent, это как бы предыдущая
вершина на пути, vector int t int out, значит, это время
входа, время выхода из вершины, мы пока будем блуждать по
лабиринту, каждый раз, когда мы заходим в вершину, мы
говорим, что мы туда пришли в очередной момент времени,
то есть у нас есть какой-то таймер, который увеличивается
постоянно, когда мы заходим в вершину, мы туда записываем,
когда мы пришли, когда выходим, тоже записываем, когда мы
из нее вышли.
Так, color мне еще нужно, видимо, все.
Да, color.
Давайте я строку эту назову, да, конечно, можно это гораздо
более компактно хранить, но давайте у меня будут строки
vector string, color, значит, я по ходу работы нашего алгоритма
буду вершины красить в три цвета, белые, серые, черные.
Давайте сразу напишу, что это будет значить, белые
значит, что мы в вершине еще не были, серые значит,
что уже побывали, но еще как бы не до конца ее просмотрели,
то есть в каком-то смысле она в обработке, а черные
значит, что мы ее полностью обработали, больше туда
заходить не будем, потому что мы уже все оттуда изучили.
Значит, white это еще не просмотренные,
ну и поэтому изначально все вершины белые,
gray это те вершины, которые в обработке, то есть мы их
уже увидели, мы в них уже зашли, но еще они полностью
обработали, то есть не закрыли, не можем сказать, что мы
их полностью обработали, и так у меня склероз, черные
забыл как называется, черные это те, которые полностью
обработали, полностью обработали.
Вот, значит, как работает DFS.
Он принимает вершину, где мы начинаем наш путь, и
делает следующее.
Первым делом, когда заходит вершина, он, во-первых, помечает
ее серой, потому что она изначально была белая, мы
как бы вот только что в нее вступили, должны пометить,
что мы как бы сейчас ее обрабатываем, она в обработке.
Мы говорим, что у нее цвет серый.
Color of V is equal to gray.
Также мы помечаем, что мы в нее только что вошли.
T in V равно, но я напишу timer++, в том смысле, что есть какая-то
глобальная переменная timer, изначально равная, например,
нулю.
Вот.
Ну и тогда, соответственно, мы зашли, положили сюда
таймер и таймер увеличили.
А то есть сказали, что вершину зашли вот в очередной момент
времени.
Дальше.
Что мы делаем, собственно, с вершиной?
Мы из нее начинаем перебирать все возможные достижимые
ребра.
Ну, просто все возможные исходящие ребра.
Вот V.
Вот мы пытаемся по всем вот этим ребрам пройти.
Если мы видим ребро в какую-то интересную вершину, а именно
в белую вершину, то мы, получается, нашли какой-то новый путь,
новый маршрут, по которому мы еще не следовали.
Вершина белая.
Мы в ней еще как бы не бывали, она не просмотрена.
Поэтому давайте просто из нее запустимся рекурсивно.
Вот просто возьмем и насильно спустимся туда.
Если мы раньше стояли в V, а нашли какую-то новую вершинку
ту, например, которая была белая, я забываю про V, ну
не то что забываю, а из V перехожу в ту и теперь начинаю
делать то же самое из ту.
Вот.
Вот такой.
Сейчас, одну секунду.
Я перебираю все элементы вектора желтвы.
Через двоеточие перебираю все элементы вектора желтвы.
Если свет вершины ту не белый, то я просто ее скипаю.
Потому что если она не белая, значит она либо уже в обработке
и так, то есть мы там уже как бы побывали, не надо
еще раз запускаться.
Либо она вообще черная и значит мы ее полностью
обошли и повторно делать то же самое вообще нет никакого
смысла.
Поэтому, если color2 не равно white, то continue.
Так.
Дальше.
Значит, иначе.
Иначе, я просто рекурсивно хочу вызваться, но еще давайте
на всякий случай я запомню, что parent от ту равно V.
То есть я хочу сказать, что предыдущая вершина
на пути до ту, это V, то есть непосредственно перед тем,
как попасть в ту, я посетил V, и собственно прошел вот
это вот.
Чтобы попасть в ту, я прошел, приберу V2, записал, что
предыдущая вершинка это V, ну и соответственно
Vfs от ту.
Вот цикл закончился, и в конце, когда мы все ребра
перебрали, то есть смотрите, вот этот цикл полностью
завершился, мы перебрали все исходящие ребра, и теперь
мы должны завершить вызов рекурсии, пометить вершину
использованной, полностью обработанной, то есть, во-первых,
мы ей цвет меняем на черный.
Во-вторых, мы говорим, что мы из нее выходим, то
есть tout задаем, время выхода задаем, какое-то фиксированное,
опять-таки таймер плюс-плюс, потому что у меня сквозное
время всего.
Вот.
Ну и все, завершить рекурсивный вызов, вот очень простой
алгоритм.
Да, вот на этом примере, если мы стояли вот здесь
вот, то есть если мы сначала как-то попали в V, потом прошли
по ту, то мы сначала обойдем целиком все, что достижено
из ту, как бы, потом вызов рекурсивный закончится,
мы пометим ту черный, вернемся в V, то есть у меня завершился
рекурсивный вызов, я вернулся на уровень рекурсии наверх,
у меня стал обрабатываться опять V, я здесь дошел все
вот эти вот ребра, что-то там еще обошел, потом завершился
вызов из V, опять поднялись наверх, ну и так далее, пока
у нас вся рекурсия не… короче, пока stack рекурсии
не очистится.
Так, вот такой алгоритм, пока, просто без измысления
того, что он делает, понятно ли, в смысле, без измысления
того, как бы, на что он направлен, на что он там посещает и
так далее, что проверяет, понятно ли реализация.
Так, ну хорошо, вот, вроде ничего не забыл.
Значит, Лемма, о том, как он работает, называется
Лемма о белых путях.
Я вот ожидаю следующее, смотрите, вот давайте рассмотрим
момент времени, вот этот, когда мы только-только зашли
в вершину, пометили ее серой, и соответственно, проставили
в ней момент входа, время входа, значит, дальше прокрутили
какое-то время, пока все вот это прошло, когда произойдет
вот это, то есть рассмотрим два момента времени, начало
входа в вершину и, соответственно, конец выхода из вершины.
Вот я вот ожидаю, что за это время, между этими два
момента времени, между этими два момента, между входом
и выходом из вершины конкретной, мы посетим те и только те
вершины, которые достижены по белым путям.
Для любого, за время между ТИ на ТВ и ТАУТ от В, DFS обойдет
и пометит черными те и только те вершины, которые были
в этот момент времени достижимы по белым путям, те и только
те вершины, которые были достижимы из В в момент времени
входа по полностью белым путям. Вот есть какая-то
вершинка В, мы в нее зашли, сразу покрасили в серый,
а теперь, значит, мой вопрос, а что будет к моменту времени,
когда этот ДФС от В закончится, когда я обойду, ДФС от В закончится,
я все ребра там переберу. Вот я утверждаю, что все,
что посетим, все, что мы посетим, это в точности
такие пути, точнее вершины на путях, что здесь все вершинки
были белые изначально. Вот если там они все были
белые, то я их все обязательно посещу к моменту времени
выхода из В, и более того, я их уже перекрашу в черный,
то есть не просто посещу, но и целиком закончу обработку.
Такое нехитрое утверждение. Доказательства.
Так, ну почему мы не посетим ничего лишнего? Почему мы
можем посетить только то, что достижимо по белым
путям? Ну потому что, что такое достижимо, да, это
то, куда я как бы перейду в процессе обхода. Перехожу
я только в белые вершины каждый раз, поэтому ничего
кроме белых вершин, ничего кроме тех вершин, которые
были изначально белыми, я посетить не смогу. Поэтому
могу посетить только то, что белое. Могу посетить
только белые вершины по белым путям. Следовательно,
на лишнего ничего не обойду. Лишнего не обойду. Вот.
Значит, почему я верну в обратную сторону, что все,
что достижимо по белым путям, обойдется? Давайте
рассмотрим произвольный белый путь. Почему к моменту
времени выхода отсюда я все это обойду? Так, ну для
этого надо сначала понять, как у нас устроен стэк
рекурсии. Значит, что у нас лежит в стэке рекурсии?
В стэке рекурсии, я утверждаю, всегда лежит некоторый путь
по серым вершинам. Путь из серых вершин. Значит,
это более или менее очевидно, потому что как он формируется?
Мы запускаемся откуда-то там из начала, из некого
корня, сразу покрасили его в серый. Дальше, когда у
нас раздувается стэк рекурсия, когда я из текущей вершины
перехожу куда-то дальше, в вершину, которая была
до этого белой. То есть вот я нашел очередное ребро
в белую вершину, перекрасил ее в серый, грей, и запустился
от нее рекурсивно. То есть у меня было ребро из этой
серой в эту серую. Дальше, запускаюсь отсюда. Опять
перебираю все ребра, нахожу ребро в белую, если нашел,
то запускаюсь отсюда, перекрашиваю сразу в серую. Ну и так далее.
Поэтому в любой момент времени стэк это всегда путь по
серым. Ну и когда я откатываюсь, когда запускается рекурсивный
запуск от какой-то вершины, у меня просто наш путь немножко
обрывается, последнее ребро удаляется, последняя
вершина с ним удаляется. Поэтому в стэке всегда путь
из серых вершин. И значит, давайте рассмотрим, что
происходит в момент времени ты над В. То есть я начал
в Р, шел по серым вершинам, дошел до В, и В только что
поместилось в качестве очередной серой вершины
в наш стэк рекурсии. То есть я дошел до сюда, стэк
у меня теперь вот такой, стэк рекурсии. И дальше
я начинаю что-то обходить. Тогда в момент времени
ты аут от В, это когда я вот здесь что-то еще пообходил
и стэк вернулся к тому состоянию, когда вот, как
если бы В еще не было добавлен. То есть я В опять удаляю
из стэка рекурсии, это как условие выхода отсюда.
Я ее удаляю, делаю черной, она уходит из стэка рекурсии,
как бы мы закончили ее обработку. Поэтому смотрите,
к моменту времени выхода серое это то же самое, что
было изначально. То есть что было серым в начале,
с момента времени ты и на ТВ, оно же собственно
и есть серое к моменту времени ты аут от В. Потому что это
просто вот весь этот путь. Поэтому ничего кроме белого
и черного я здесь получить не могу. У меня серые все
только вот эти. Все что было серым остается серым. Значит,
отсюда вот эти вот вершины, которые достижимы по белым
путям, они теперь точно не серые. Значит, вершины
достижимые по белым путям точно не серые. Значит, надо
только разобраться с белыми и черными. То есть серые
отдельно, они вот здесь, с ними все нормально. Вопрос
почему тогда они все покрасятся в черные? Почему? То есть
мы понимаем, что они не могут покраситься в серые, потому
что они не могут попасть в стек рекурсии выше чем
В. Значит, они все либо белые, либо черные. Вот почему
не все в черные окрасть, а почему не все обработаются.
Так, интересно. Давайте предпологаем, что это неверно,
и что найдется какая-то вершина, которая раньше была
достижена по белому пути, но после выхода из В она
будет не обработана, то есть будет белой. Если она
черная, то уже все хорошо, мы доказали, что надо. Вопрос
почему она может быть белой? Может она быть белой? То
есть вот раньше был какой-то путь по белым, и к моменту
времени выхода отсюда это по-прежнему белое. Ну хорошо,
давайте рассмотрим этот путь. Вот какой-то путь из
белых, которые изначально были белые, пусть это белое
в конце. Давайте на этом пути посмотрим самую низкую
И� пусть вот эта перекрасилась черной, эта перекрасилась
черная, а эта осталась белой. То есть из всех вершин
на белом пути рассмотрим самую высокую оставшуюся
белую. Эти все перекрасились, мы знаем, что они обязательно
перекрасились в черный, потому-что серый мы знаем,
мы их уже обработали, это стекр рекурсия. Все их
в черный, а эта осталась в белый. Но вот извините,
как вот эта могла в черный перекраситься, если это
по-прежнему белое? Потому что в черный мы вершину
можем перекрасить только в случае, когда мы из нее
все ребра просмотрели и все ходы в белые вершины
совершили. А здесь, смотрите, у меня было ребро отсюда
в белую, и она осталась белой, то есть я как бы туда
не зашел, ДФС туда не заходил, но при этом эта вершина почему-то
черная. Ну, понятно, что бред, у нас алгоритм не так
работает. Значит, такого не бывает, и все, весь путь
должен быть обязательно черный. Значит, давайте
зафиксируем как-нибудь. Пусть какая-то ум осталась
белой, осталась белой. Тогда рассмотрим самую высокую
вершину на пути из ВДУ. Ее родитель перекрасился
черный, значит, это ребро должно было быть просмотрено
противоречием. Ее родитель черный. Черный, значит,
белый. Такое техническое утверждение, казалось бы,
зачем мы его доказываем. Ну, раз уж мы хотим хоть
какой-то формализм придать, то, наверное, стоит. Вот,
зато отсюда сразу следует следующие два простых факта.
Значит, факт первый, следствие. Если мы изначально все вершины
окрасим в белый, и из мейна запускаем DFS от S, какой-то
произвольной вершины, то к моменту завершения
мы обойдем в точности все, что достижено из С, потому
что если изначально все белое, то достижимость по
белым вершинам, это то же, что просто достижимость,
потому что у нас все вершины белые изначально. Значит,
к моменту завершения DFS мы обойдем просто все, что
достижено. Если все вершины изначально белые в тех
то давайте напишу так. Внешне давайте напишу я запуске
DFS буду разрядить на внешне и внутреннее. Внешне это
те, которые запускаются, грубо говоря, из мейна,
из собственного тела программы, а внутренне это то, когда
DFS сам себя запускает. Вот внутренне это как бы рекурсивные
запуски DFS самого себя, а внешне когда вот там другая
процедура его использует. Мы в качестве мейна его
использует. Внешний запуск DFS обойдет в точности все
DFS. Потому что достижимость и достижимость по белым
это одно и то же, а лемма белых путях говорит, что все,
что достижим по белому путям мы обойдем. Так, это был
следствие 1, следствие 2. DFS позволяет проверять граф на
отключенность или, наоборот, на наличие цикла. Значит,
как найти цикл? Я утверждаю следующее, что в графе
существует цикл, достижимый из S. Цикл – это замкнутый
маршрут по ребрам, то есть я иду-иду по ребрам, их
ваза 6 туда откуда начал. Цикл, достижимый из S, значит,
что я встал в S, прошел по ребрам и потом вошел в цикл
каким-то образом. Сначала как бы предпериод, потом
период по циклу. Так вот, такой цикл существует, если
и только если в какой-то момент времени мы видим
ребро в серую вершину. Если, если после внешнего
запуска DFS от S, когда-то находит ребро в серую вершину.
Не просто если, а если и только если. Давайте равносильность
тут напишем. Если и только если, мы когда-либо видим
ребро в серую вершину. Давайте напомню, как у нас работает
мы идем по стеку рекурсии, красим вершины в серый. В
момент времени, когда мы целиком рассмотрели все
ребра, идти дальше некуда, мы вершину из стеки рекурсии
удаляем и поднимаемся к предыдущей вершине в стеке
рекурсии. Так вот, если я когда-то вижу ребро из
текущей в какую-то более раннюю серую, а серый у меня
это только более ранний, да, поэтому только куда-то
выше по стеку рекурсии, если я нахожу такое ребро,
то у меня есть цикл. И наоборот, любой цикл, ну не любой
цикл я нахожу, а по крайней мере один такой цикл я найду.
Значит, ну доказательства. То есть тут на самом деле
два утверждения, что если цикл есть, то я его найду,
и что если я нашел ребро в серую, то это цикл. Давайте
справа налево. Так раз если я нашел ребро в серую, то
это цикл. Ну это тривиально. Что такое ребро в серую?
Еще раз вспоминаем, что стек рекурсии это все серые
вершины. Серые. Поэтому ребро в серую это как раз ребро
в одного из предков. То есть был вот такой путь по серым.
Серая, серая, серая, серая. И я из текущей нашел ребро
в серую. Ну поэтому вот он вам цикл, понятное дело.
Да, если был путь, и я нашел ребро в какую-то одну из
предыдущих, то очевидно есть цикл.
Теперь обратно. Почему я гарантированно найду хотя
бы один из циклов таким образом? То есть почему если
в графе есть цикл, то я найду его таким алгоритмом, то
есть что обязательно будет ребро в серую. Давайте посмотрим.
Пусть есть некий цикл конкретный. Вот есть S, есть достижимый
из S некий цикл. Почему я обязательно его обнаружу?
Ну на самом деле это неверно. Я скорее обнаружу. Я просто
обнаружил один из циклов. На самом деле задача нахождения
всех циклов, наверное, трудная. Я не ставлю себе такой задачи.
Я просто как бы найду хоть какой-то цикл. Так вот почему
если есть один цикл, то я найду хотя бы какой-то.
Ну вот смотрите, давайте я в этом цикле найду вершину
с минимальным т.ин. Вот если есть цикл, какой-то замкнутый
маршрут, давайте я в этом цикле найду вершину с минимальным
т.ин. А поскольку у меня из S достижим весь этот цикл,
то значит все эти вершины рано или поздно, я в них
рано или поздно приду, поэтому я могу выбрать вершину с
минимальным т.ин. Так вот пусть U это вершина из цикла
с минимальным значением т.ин. Вот она U. Да, ну потому
что на самом деле я не знаю как именно я от S добрался
до этого цикла. Я мог как-нибудь вот так добраться. Мог как-нибудь
вот так вот и потом другой цикл какой-то найти. Короче
все кого знают. Вот пусть U это самое первое вот вхождение
которое наш DFS нашел. То есть я к моменту времени
входа в U еще больше ни в каких других вершинах этого
цикла не бывал. Но тогда смотрите, когда я зашел сюда,
я сразу крашу ее серый, а остальные вершины цикла
по-прежнему белые, потому что U это вершина с минимальным
т.ин. Значит к моменту времени входа в нее еще никакие другие
цикла не были даже просмотрены, не были увидены. Значит к моменту
времени выхода отсюда я все эти вершины полей на белых
путях, я все эти вершины обработаю покрашив черный.
Но давайте в частности посмотрим на вот эту вершину как бы
предыдущую на цикле. Я ее обработаю, я закончил обработку
до того как я закончил обработку вершины U. Значит к моменту
времени когда я нахожусь здесь, у меня вершина U по-прежнему
серая, значит я найду ребро в серую вершину победа. Так
вот, в этот момент времени давайте запишем в этот момент
U серая, а остальные вершины цикла белые.
Пусть V это предыдущая вершина на цикле, предыдущая перед U,
предыдущая перед U вершина на цикле,
значит мы до нее дойдем до того как завершим обход U, потому
что V достижим по белым пути. Значит в момент времени
обработки V мы увидим ребро в серую вершину U. При обработке
V мы увидим ребро в серую вершину U. Победа. Нормально?
Чудесно.
Если бы у нас была задача просто такая, проверить
существует ли в графе цикл достижимый из S, я запускаю
DFS от S, внешне DFS от S, он что там обходит, и если надо
еще DFS подправить, то если я вижу ребро в серую, то
говорим, что вот-вот он цикл. Более того, если бы мне
нужно было именно вывести последовательность вершин
на этом цикле, то есть что это за цикл, не просто сказать
есть он или нет, а сказать вершины лежащие на этом
цикле, то мне можно было бы просто по pair'ам пропрыгать
до вершинки U, и это был бы как раз тот самый цикл,
который мы ищем, потому что если мы здесь нашли
ребро вот сюда, то parent у меня как раз все ребра из
stack'а рекурсии. Вот это вот parent от текущей вершины,
это parent от parent и так далее, то есть я могу прыгать по
parent, пока не дойду до этой вершинки, которая ведет
по стрелке, и тогда это и будет как раз цикл, который
мы искали. Все, вот такой мощный инструмент.
Дальше, значит, что мы хотим сделать? Ну, давайте пусть
будет определение. DAG, от английского directed acyclic graph,
это собственно ориентированный циклический граф, ориентированный
граф без циклов, напишу так, граф без циклов. Я буду
часто говорить просто DAG, потому что мне лень говорить
фразу граф без циклов, да, DAG проще, acyclic, ну, как бы
acyclic. Вот, и для DAG'ов есть такое удобное понятие как
топологическая сортировка. Это перестановка вершин,
что любое ребро ведет только из вершины с меньшим номером
вершин с большим номером. Такая перестановка вершин,
что любое ребро ведет, ну, я напишу, слева направо.
То есть, из вершины с меньшим номером, вершины с большим
большим номером. То есть я могу вот так вот изобразить
мои вершины на прямой, что все ребра ведут как бы вот
так вот, слева направо. Нет ребер, нет ребер в обратную
сторону. Вот. Ну, простое утверждение
терреалгоритм, что топсор существует только у дагов,
топсорт существует только если граф является дагом
и топсорт можно найти за линейное время.
Топологическая сортировка существует только если
граф является дагом. И находится за линейное время.
Значит, топ-сорт существует и находится линейное время.
Вот, ну, смотрите, значит, здесь линейное время – это
всегда линейное время от размера графа.
Размер графа – это у меня n плюс m, где n – это число
вершин, то есть мощность в множество v, а m – это число
ребер.
Я буду всегда, скорее всего, использовать такие
обозначения.
n вершины и m ребер у меня в графе.
Ну, поэтому линия у меня мерится суммарно от размера
графа, от n плюс m.
Вот.
Ну, доказательства.
Значит, слева направо.
Почему, если топ-сорт есть, то граф циклический?
Ну, я симпеню, у меня все ребра слева направо, а цикл
он как бы есть.
Если он идет слева направо, то ему надо когда-то вернуться
в начало, значит, ему надо, чтобы ребро его справа
налево.
Очевидно, даже не знаю, что это написать.
Просто если все ребра слева направо, то цикл мы никак
не получим.
Мы всегда только увеличиваем номер, мы не можем вернуться
туда, откуда начали.
Теперь в обратную сторону.
Мне нужно показать, как найти топ-сорт дага за линейное
время.
Предъявим алгоритм.
Предъявим алгоритм.
Поиска топ-сорт на даге за линейное время.
Так, алгоритм следующий.
Алгоритм следующий.
Мы перебираем все вершины графа и запускаем внешний
DFS для всех белых вершин.
Если color от s равно white, то запускаем DFS от s.
Потому что мы знаем, что DFS от s обойдет только то,
что достижено из s, но, возможно, не весь граф, то есть какой-то
кусок графа.
А я хочу весь граф обойти, поэтому я сначала прохожусь
по всем вершинам, да, во внешнем цикле.
Если вижу, что вершина не посещена, я из нее запускаю
DFS.
Он там что-то обойдет.
Вот.
И в конце топологичная сортировка – это сортировка
вершин в порядке убывания tout.
Но у нас DFS работает, он при входе, при выходе выставляет
конкретное tntout.
Это какие-то числа.
Причем, более того, это небольшие числа, не больше
чем 2n примерно, да, потому что таймер у нас увеличивается
при входе и увеличивается при выходе.
Всего в ходах и выходах линейное количество, поэтому
числа не очень большие.
Но если уж надо, сортировку в порядке убывания можно
сделать за линейное время, сортировкой подсчетом,
потому что все значения небольшие, поэтому можно
посортить за линию.
Поэтому сортировка – это не очень страшная вещь.
Но на самом деле можно и похитрее, можно заметить,
что можно просто каждый раз, когда мы вышли из вершины,
у нее минимальный tout, мы можем запихнуть в конец
нашего списка.
Ну и тогда, соответственно, справа налево восстановить
эту перестановку, и тоже будет за линию, даже без
всякой сортировки.
Ну то есть тут нет проблем с тем, как это посортировать,
это уже вопрос реализации.
То есть получается вот этот конкретный шаг.
Если у нас весь алгоритм отработал за быстро, то
сама сортировка работает за линию.
Так или иначе, можем все вершины порядочить за
длинное время.
Ну а алгоритм DFS, очевидно, работает за m+, потому что
мы никакую вершину больше одного раза не войдем.
Вход в вершину означает ее покраска с белой на серую,
выход с серой на черную.
Поэтому вход в вершину максимум один раз, и каждый
ребро просмотрится тоже максимум один раз.
Потому что, если я сюда зашел один раз, то, соответственно,
каждое конкретное ребро просмотрится только один раз.
Значит, у меня каждая вершина просмотрится максимум
один раз, и каждое ребро максимум один раз, поэтому
время суммарно на n+.
Время таковой корректности мы докажем после перерыва.
Смотрите, я предъявил алгоритм, сейчас хочу доказать
его корректность.
То есть мы чего-то делаем.
Я утверждаю, что если у меня на входе был DAG, то такая
перестановка вершины является, на самом деле, типологической
сортировкой.
Ну почему?
Надо просто доказать отсутствие ребер справа налево.
То есть я управлял вершины в порядке бывания таута,
хочу доказать, что если есть какое-то ребро, то
он обязательно слева направо, доказать свою корректность.
Мне достаточно показать, что если какое-то ребро
было в исходном графе, то эта вершина напечатается
в нашей сортировке раньше, то есть у нее больше таут.
Если есть ребро, то это должно быть раньше, то есть у нее
должно быть больше таут.
Достаточно доказать, что таут от Ум больше, чем
таут от В.
Чтобы это доказать, давайте переберем, какая из двух
вершин У и В была посещена первой, то есть у кого из
них меньше Таин.
Случай первый, Таин от У меньше Таин от В, то есть
когда я зашел в У, В белая, В еще не обработана, я в ней
еще не был, вообще ни разу не видел.
Значит, тогда вот У к моменту времени входа серая, то
есть я сюда зашел, а В белая, ну значит, поскольку В достижимо
по белому пути, вот, собственно, он один, да, просто по ребру
в белую вершину, значит, до выхода из У я выйду из
В, то есть я ее целиком обработаю, перекрашу в черный, значит,
выйду отсюда раньше, чем отсюда, поэтому получаю
требования неравенственно таута.
Значит, по, опять-таки, лени о белых путях, к моменту
времени Таут от У, В будет целиком обработана, значит,
она будет, из нее вышли еще раньше, чем этот момент
времени выхода из У, к моменту Таут от У, В уже целиком
обработана, то есть выход из нее состоял еще раньше,
к моменту Таут от У.
Второй случай, наоборот, с другой стороны неравенственно,
давайте здесь.
Наоборот, сначала мы зашли в В, то есть сначала я попал
сюда, покрасил В серый, а У еще белая, к моменту
времени входа в В, У еще белая, У еще белая, ну окей, давайте
предположим, что это неверно, сейчас или нет, не надо
даже, ну да, давайте предположим, что это неверно, пусть не
так, то есть не нравится верно в обратную сторону,
наоборот, Таут от У меньше, чем Таут от В, что это значит?
Это значит, что вершина У обработана целиком до
того, как обработана вершина В целиком, то есть смотрите,
как у нас тогда история событий была, мы сначала
увидели В, покрасили ее в серый, потом что-то поделали,
вышли из У, то есть мы ее целиком обработали, и только
после этого вышли из В, значит, в частности, я с помощью
стека рекурсии дошел из В до У, потому что чтобы
обработать у меня опять-таки по леймам белых путях, обработаются
к моменту времени выхода Таут от В, те и только те
вершины, которые были достижены по белым путям, поэтому
раз я успел закончить обработку У до обработки В, значит,
я ее посетил по какому-то белому пути, обработал,
вышел, и только после этого вышел из В, да, лейма белых
путях, говоришь, что как раз, если это верно, то есть если
я У успел обработать до выхода из В, значит, она была достижена
по белому пути. Это противоречит тому, что у нас графа циклический,
да, потому что если В достижимый, наоборот, У достижимый из
В по белому пути, значит, есть цикл противоречия.
Конец. Значит, давайте это запишем, пусть не так Таут
от У меньше, чем Таут от В, тогда У обработается раньше
чем У обработается В, значит, опять-таки по леймам белых
путях, а У достижимый из В по белому пути, противоречие
с ацикличностью. Ну все, показали. Значит, в любом случае
верное неравенство, поэтому я сначала напечатаю У, потом
напечатаю В, значит, у меня реально все ребра будут
идти слева направо. Прекрасно. Значит, мы топ-сорт построили
Зачем это может быть вообще нужно? Ну, на дагах очень
просто считать всякие динамики. А, и вообще, если у Вас, ну,
скажем так, граф зависимости в переходах динамики вообще
должен быть всегда дагом, потому что мы когда там
говорим, что какое-то значение ДП, динамики зависит от
каких-то других, если нарисовать стрелку зависимости, то
у меня, по сути, не должно быть циклов, потому что
у меня всегда получается циклическая зависимость,
и мы не можем определить значение. А так у нас в
каком-то смысле вся динамика, это ее формула пересчета
и так граф образует. То есть, что из чего пересчитывается?
Вот если стрелку рисовать как зависимость, зависимость
пересчета, то у меня получается как раз даг. Ну и, собственно,
как раз мы представляем то, как у нас всякая динамика
может насчитываться. Например, на даге нас могут попросить
число путей, найти число путей в даге. Вот это очень легко
делается. Да, ну давайте я нарисую общую картинку.
Давайте ДП вот в, это количество путей, начинающихся в, тогда
если я нахожусь где-то в и пытаюсь продолжить путь,
то я могу либо сразу закончиться и получить путь из одной
вершины, либо перейти в любого из сыновей и взять
ДП. Если ДП от В это количество путей, начинающихся в, тогда
ДП в это, это 1 плюс сумма по всем исходящим ребрам
ДПУТ. То есть я либо сразу заканчиваюсь, либо куда-то
перехожу, и тогда мне подойдет в качестве завершения любой
путь начинающихся в У. И все они будут различны, потому
что у них вторые вершины различны. Ну поэтому я все
путей перебираю. Вот. И как раз-таки если я все ребра
смогу порядочить слева-направо, то есть если у меня есть перестановка
вершин, такая, что все ребра ведут ровно вот так вот,
то я могу мою динамику насчитывать динамикой
справа-налево. То есть я знаю, что здесь ДП равно единицы,
здесь ДП получится равно двойки, потому что можно
либо стоять здесь, либо прыгнуть сюда. Здесь ДП,
ну короче в общем, у меня все более правые вершины,
для всех более правых вершин ДП уже посчитано, поэтому
я в сумме все слагаемые знаю. Надо просто сложить все,
что нужно и получить ДП вот здесь. И так я иду справа-налево,
все более правое уже почитано, поэтому я могу сложить нужные
слагаемые и положить сюда то самое ДП. Вот как раз
такой удобный способ упорядочения вершин, чтобы всякие
такие штуки можно было справа-налево считать.
Так. Хорошо. Хорошо. Что-то был случай графов без циклов.
Теперь давайте отказываемся от этого предположения
и будем изучать произвольный граф, возможно, с циклами.
Определение. Значит, пусть G это граф ориентированный,
пусть G ориентированный граф. Я буду говорить, что вершины
У и В сильно связаны, если есть путь из У в В. Нет,
есть путь в обе стороны. Будем говорить, что вершины
У и В сильно связаны. Сегодня буду обозначать тильдочки
как отношение к эквивалентности. Значит, они сильно связаны,
если из У существует путь В и из В существует путь
В. Из У есть путь В и из В есть путь В. Короче, в обе
стороны есть путь в одну и в другую, и туда и обратно.
Я вот это утверждение, что вот это вот отношение,
которое я только что ввел, получается у меня отношение
на парах вершин. Бинарное отношение, я утверждаю, что
оно является отношением эквивалентности. Отношение
тильда, отношение к эквивалентности. Так, у кого не было матлога?
Или, точнее, так, кто не знает, что такое отношение к
эквивалентности? Так, хорошо. Не всегда так, не всегда
все знают. На всякий случай проговорю. Отношение к
эквивалентности значит, что у меня все вершины разбиваются
на некие классы, что внутри класса все вершины попарно
эквивалентны друг другу. То есть, что внутри класса
есть пути в обе стороны между вершинами, а между
классами хотя бы одного из двух путей нету. То есть,
что либо нету такого пути, либо нету другого пути.
Доказательства. Отношение к эквивалентности по определению
это совокупность трех условий. Рефлексивность. То есть,
что каждая вершина сама себе эквивалентна. Ну,
понятно, что каждая вершина сама себе сильно связана,
потому что можно стоять на месте. Это путь из У в У
и из У в У. Как бы это глупо не звучало. Дальше называется
симметричность. Ну, симметричность тоже тривиально. Потому что
если У и В сильно связаны, то В и У сильно связаны. Ну,
потому что у меня это определение от перестановки условий остается
тем же самым. Здесь тоже очевидно. Ну и третья транзитивность.
Почему, если У и В сильно связаны, В и В сильно связаны, то У и,
вstudy-выс сильно связаны. Ну, понятно,
у меня есть вот такие два пути, есть такие два пути,
если их скр Down, то получится путь отсюда сюда и отсюда.
Я могу сначала пройти от У до В до В В. Это будет путь
в одну сторону, и могу пройти от В до В до USB это будет путь в другую
сторону. Поэтому, У и В сильно связаны. А это как раз
интранзитивности, то есть, что если u сильно связана с v, v сильно связана с w,
то u сильно связана с w. Доказательство картинка.
Нет, нет. Но на самом деле, если есть какой-то путь, то есть обязательно простой путь.
Тут возможно есть повторения, но их всегда можно высечь, потому что
достижимость не меняется от того, что вы можете повторять вершины, вы можете вот эту циклическую
петлю обрубить, и тогда у вас путь укоротится, но это не влияет ни на что. То есть тут я, на самом
деле, мог в определении зашить простоту пути, но это не влияет на определение. Все остается таким же
самым. Так. Это хороший вопрос про простоту, но это будет чуть более актуально, когда мы будем
говорить про мосты и точку слинения, когда мы будем говорить про двусвязанность в неориентированном
графе, вот там уже за простотой придется следить чуть более пристально, потому что там это по
интереснее условие. А тут не надо еще. Так. Ну и вот еще, значит, определение. Надеюсь, мы
классы эквивалентности после факторизации по этому отношению называются компонентами
сильно связанности. То есть вот я сказал, что это отношение эквивалентности, значит, все вершины
разбиваются на такие группы, на такие классы, внутри которых все вершины попарно сильно связаны,
а между классами не сильно связаны попарно, и так вот эти вот группы называются компонентами
сильно связанности. Значит, ну формально классы эквивалентности по отношению тильда это называются
компонентами сильно связанности. Вот я буду опять-таки для краткости говорить КСС,
компоненты сильно связанности, КСС. Вот. Следующая наша задача это по графу найти его разбиение на
КСС, найти его разбиение на компонент сильно связанности. Ну и выделить все КСС. Алгоритм,
который ее решает, это так называемый алгоритм Косараю. Выделение КСС. Значит, алгоритм очень
простой. Шаг первый идентичен тому, что мы делаем в топ-сорте. Мы проходим по всем вершинам в порядке
от 0 до минус одного и запускаем внешний ДФС обычный из всех белых вершин, а дальше сортируем
вершины порядка бывания таута. Давайте напишу так же как в топ-сорте, как в топ-сорте ДФС плюс
сортировка побывания таут. Вот. Шаг второй. У меня теперь есть некоторый порядок вершин. В случае
ациклического графа это топ-сорт. В случае не ациклического графа, ну просто какой-то порядок.
Мы пока про такой порядок ничего не доказывали. Это какая-то присуновка вершин. Так вот давайте
в этом порядке пройдемся по вершинам. В порядке, который диктуется нам вот этой сортировкой и будем
запускать из вершины ДФС по обратным ребрам. То есть не по ребру вниз, которая там у него было прямое
ребро, а по обратному ребру. Сейчас формализую. Но неформально. Значит, запускаем ДФС. Напишу так
ДФСР в скобочках ДФС по обратным ребрам для вершин в этом порядке. И все, что я обошел в результате
одного внешнего запуска ДФСР, то есть ДФСР по обратным ребрам, это будет очередная КСС.
Все, что обошли в результате одного запуска, это очередная компонента сильной связанности.
Значит, формально, что такое ДФСР. Смотрите, обычный граф, он как-то задан у нас. У нас есть там
какие-то ребра УВ, Х, Ю и так далее. Обратный граф, Ж с верхним униксом Р, это когда я меняю
ориентацию всех ребр. То есть ребро УВ превращается в ребро ВУ, ребро ХИ превращается в ребро УВХ. Ну и
так далее. Я просто беру и меняю стрелочку у всех ребр. Соответственно, если у меня был ЖВ представлен
как вектор векторов, для каждой вершины у меня был записан, куда можно из нее попасть. То есть для
УВ было записано В, для Х, Ю и так далее. То теперь я могу построить такой же вектор векторов,
только для обратного графа, где для каждой вершины храни, наоборот, как бы откуда в нее можно было
бы попасть. То есть В можно было попасть из У. И значит, теперь я как бы ее инвертирую, говорю, что
можно из В попасть в У. Меняю направление стрелки, ну и по сути как бы переставляю начало и конец у всех
ребр. Поэтому такое проявление очень простое. Надо просто поменять стрелочку, надо просто поменять,
где начало, где конец. Вот. И я запускаю вот этот самый ДФС в новом графе Ж с верхним униксом Р,
обратный Ж. И все, что я смог достичь за очередной вершинки по этим ребрам, это вот очередная КСС.
Примерно так это будет выглядеть. Смотрите, вот у меня был граф Ж. Как это будет работать, да? Вот,
ну, например, его, если я сожму КСС, картинка будет примерно вот такая. Что-нибудь такое я нарисую. То
есть у меня кружочки это КСС, то есть там все по парам достижены как-нибудь вот так вот,
во все стороны. Здесь тоже КСС какой-нибудь, здесь КСС. Вот. А эти в КСС клеить нельзя,
значит здесь вообще между ними, например, нет ребер. Есть ребра отсюда-сюда, есть ребра отсюда-сюда,
но нет ребер обратно. Вот, например, такая картинка. Тогда как работает ДФС по обратным ребрам? Вот,
если я его запущу от какой-нибудь вершины внутри этой компоненты, я обойду целиком только эту
компоненту. Ну, потому что у меня ДФС только по обратным ребрам идет, он это ребро не просмотрит,
но поскольку здесь все вершины достижены по парам в обе стороны, то я по обратным ребрам обойду
целиком всю эту компоненту. Я запускаюсь отсюда, все достижено из нее и наоборот из нее, ну, она из
всех достижено, поэтому по обратным ребрам я целиком эту всю компоненту обойду. Тоже самое,
здесь, если запускаюсь ДФС по обратным ребрам отсюда, я обойду целиком только эту компоненту,
а сюда не перейду, и последний шаг, у меня будет как раз обход вот этой вот у этой вот штуки.
там в частности будут просмотрены эти ребра, но поскольку их концы уже
просмотрены, и им уже назначены компоненты сильно связанности, то я в них не
поднимаюсь, я только обхожу эту компоненту и говорю, что это очередная
ксс. Понятно? То есть еще раз, мы сейчас все докажем, что это
корректно работает, идея такая, что каждый вот этот вот dfsr, если я его
запускаю в очередной вершинке, он обойдет только свою ксс, только то, что
надо. Весь класс эквивалентности и больше ничего. То есть какая проблема
могла бы быть, если бы вдруг у меня был вот такой граф, и я запускаюсь первым
делом вот отсюда, dfsr по обратным ребраммам, из этой вершинки. Я, скажем, взял, обошел всю эту
ксс, правильно сделал, но еще внезапно взял, обнаружил это ребро и поднялся сюда,
и сказал, что эти все лежат там же, где и вот это. То есть я их все положил скорее в
одну ксс. Вот нам надо будет отследить, что я такого не делаю, что если я
запускаюсь в вершинке какой-то компоненты, то все вот эти вот уже
обработаны. Я не склею две разные ксски.
Так.
Так, ну значит опять, вот я определил какой-то алгоритм. Время работы, наверное, понятно,
что оно линейное, потому что первое это то же самое, что в топ-сорте. Это понятно, что от n
плюс m, потому что по факту это просто dfs какой-то. Второй шаг, то это то же
самое, только dfs по обратному графу. Опять, никакого ребра, никакой вершины я не
обойду больше, чем один раз, поэтому этот шаг тоже работает за линию, и со
симптомикой здесь все шикарно. Быстрее, чем линия работать нельзя. Вот, значит,
доказательство корректности опять. Доказательство корректности.
Значит, первое замечание такое, что каждый внешний запуск dfs по обратным
ребрам обходит одну или несколько ксс целиком. Каждый внешний запуск dfs по
обратным ребрам обходит одну или несколько ксс целиком, ну, потому что если
вершина, это первая белая, взятая вершина из компонентов сильно связанности, то
есть все остальные тоже белые внутри нее, и я запускаю dfs по обратным ребрам, так
момент времени выхода, то есть к моменту завершения этого dfs, я точно обойду
всю эту ксс, ну, потому что они были белые изначально, они были достижены
по обратным ребрам, потому что это ксс, в ксс достижены все, и в одну сторону, и
в другую, и по прямым, и по обратным. Значит, к моменту времени выхода из этой
компоненты я точно ее все обойду. Ну, и то самое вот с всеми остальными. Возможно,
я мог как-то вот так вот прыгнуть, нехорошо взять, кроме этой компоненты,
обойти что-нибудь еще. Ну, тогда если я обошел, то я тоже целиком обошел, потому что
если я внезапно наступил сюда, то здесь опять-таки все белые, ну, то есть по
предложении индукции, да, я, если раньше только несколько компонентов откусил, то
эта компонента целиком белая, я сюда пришел, здесь все белое, поэтому к моменту
времени выхода опять по леймам о белых путях, о белых путях я все обойду. Поэтому я
обхожу точно свою компоненту сильно связанности и, возможно, несколько еще
целых компонентов связанности, сильно связанности. Вот надо доказать, что кроме
себя мы ничего не обойдем.
Что не обойдем лишних КСС.
Значит, ну, кто такие лишние?
Лишние могут быть только те, которые вот как раз достижимы по вот такому
обратному ребру. То есть плохая ситуация только такая, когда я взял и запустился
ДФС от какой-то вершины В, обошел всю эту КСС и нашел ребро ведущее в эту КСС
из другой КСС, при этом она еще не, как бы она еще целиком не обедена, она целиком
белая еще, ну, как бы, давайте напишу, не обедена. Вот это плохая ситуация,
потому что тогда я обойду сразу две и скажу, что не обедена.
Вот это плохая ситуация, потому что тогда я обойду сразу две и скажу, что не одно
и то же, а мне так делать нельзя. Вот, ну, смотрите, если это происходит, то у меня
что получается? Поскольку у меня эта вершина, точнее, из этой вершины я запустил внешний
ДФС раньше, чем мог бы запустить отсюда, то это значит, что у этой вершины ТАУТ
больше, чем вот здесь, у всех этих вершин. Да, потому что иначе, если бы у этой
вершины ТАУТ был бы меньше, чем, скажем, вот этой, то поскольку я запускаю ДФС
Р в порядке убывания ТАУТа, то я тогда бы сначала запустил ДФС Р отсюда, обошел бы
всю эту КСС и только после этого обошел бы вот эту КСС. Поэтому такая проблема
может быть только в случае, когда ТАУТ от В больше, чем ТАУТ от всех вершин этой
компоненты. Ну, давайте С1 я напишу, ТАУТ С1. Ну, вот доказываю, что такого не
бывает. Ну, давайте напишем утверждение. Пусть С1, С2, две компоненты сильно
связанности, причем есть, по крайней мере, одно ребро из С1 в С2. Есть. Ну, их на
самом деле может быть несколько, вполне возможно такое. У нас же это не точки, а
именно, что много точек. У нас может быть много ребер. Так вот, причем, есть хотя бы
одно ребро из С1 в С2. Тогда вот, утверждаю я, максимальное значение ТАУТа
по всем УСС1 больше, чем максимальное значение ТАУТа по всем УСС2. Если мы это
докажем, то автоматически покажем, что такого не бывает.
Так, доказательства. Опять давайте рассмотрим два случая. А именно, давайте посмотрим
на минимальный ТОИН. То есть опять, у нас на самом деле все рассуждения, вот эти
доказываются так. Рассмотрим на ту вершину, куда попали первые. То есть, из всех вот
этих вершин С1, С2 мы рассмотрим вершину с минимальным ТОИН. Где она была? Здесь
или здесь? Рассмотрим два случая. Первый случай. Минимальное значение ТОИНа по
Х, по всем ХСС1 меньше, чем минимальное значение ТОИНа по всем УСС2. То есть,
напоминаю, вот эти ТОИН, ТАУТы, это то, что у меня после первого шага получилось. То есть,
я запускал обычный ДФС по прямым ребрам, обычный, без вот этого обращения пока что,
обычный ДФС по прямым ребрам. И там просадил все ТОИН, ТАУТы. Так вот, в этом плане ТОИН,
ТАУТ, ТОИНы соотносятся так. То есть, я сначала пришел сюда, потом сюда. Ну, вроде понятно,
что если это верно, значит, давайте рассмотрим, пусть вот эта вот штука равна ТОИН от Х. То есть,
вот здесь вот самая первая посещаемая вершина, это Х. То есть, к моменту времени входа в Х, это все
еще белое. Вот эти все вершинки белые и эти все белые. Ну, тогда понятно, что к моменту времени выхода
из Х все это покрасится в черный. И значит, это все тоже покрасится в черный. Значит, ТАУТ от Х
больше, чем ТАУТ от всех отсюда. Если Х это первая просмотренная вершина, тогда опять-таки
полемим в белых путях. К моменту времени ТАУТ от Х и С1 и С2 будут целиком просмотрены, значит,
у них ТАУТ меньше, чем ТАУТ от Х. Так, С2 будет целиком обработано. Значит, все вот эти вот ТАУТы,
максимальное значение ТАУТ от В, то В из С2 меньше, чем ТАУТ от Х. Победа. То есть, что все ТАУТы
отсюда произошли раньше, чем ТАУТ от Х. Значит, максимальный ТАУТ отсюда меньше, чем максимальный
ТАУТ отсюда. Это то, что мы хотели. Кейс номер два. Они нас в другую сторону. Минимум, например,
достигается вот здесь. Давайте напишем. Пусть вот это равно 3 над Y. То есть, из всех этих
вершин обеих компонентов я сначала увидел какую-то вершину второй компоненты. Почему-то впервые
первая просмотренная вершина была вот эта. Первая, точнее, увиденная вершина была вот эта Y. Это могло произойти
по тысячи разных причин. Например, потому что эта вершина имеет наименьший номер, и из нее запустился
внешний DFS впервые. Либо, может быть, мы как-нибудь дошли до этой компоненты из какой-то другой
компоненты. То есть, сначала вот это там обошли, потом пришли сюда. И тогда это увидено раньше, чем все
остальные. То есть, это вполне спокойно может быть. Так вот. Но нам это не важно. Значит, пусть это верно.
Сейчас, на секунду. А, ну да. В общем, я утверждаю, что к моменту времени, то есть, как обычно,
к моменту времени T out от Y, я обойду только то, что достижено по белым. А это точно не C1.
Потому что если бы из Y было достижено C1 по белым вершинам, то у меня бы они все склеились в одну большую
КСС, потому что есть путь отсюда-сюда. Значит, такого не может быть. Значит, к моменту времени выхода из Y,
это будет черным, а это останется белым. Значит, T out и отсюда подавно больше, чем все T out отсюда.
Ну, давайте заметим, что не может быть белого пути из Y в C2, так как иначе у меня был бы путь в обе стороны
между C1 и C2. Иначе есть путь в обе стороны, а значит, есть сильно связанные перерывы.
Иначе между C1 и C2 есть путь в обе стороны, противоречие. Мы считаем, что это разные компоненты,
и есть путь только из C1 и C2. Значит, опять-таки, по нашей любимой технично-леме, к моменту времени выхода
из Y мы обойдем только то, что было достижено по белым путям из Y, а значит, C1 вообще не обойдем,
даже не увидим. По-леме, к моменту T out от Y мы даже не увидим C1.
Значит, у них T out еще больше. Мы их не видели, обошли целиком C2, потому что к моменту времени выхода отсюда
мы обойдем целиком C2, опять-таки по-леме. То есть, все отсюда вышли, а сюда еще даже не вошли.
То есть, у них еще больше T in и еще больше T out. Доказали.
Значит, здесь даже получается неравенство такое, что любой T out отсюда больше любого T out отсюда.
Могу даже вот так написать. Для любого VSC2, для любого USC1, T out от V меньше T out от U.
Значит, частности доказали то, что нужно.
Ну и все получается, что наш алгоритм действительно вот такой дичь никогда не делает.
То есть, он никогда не пытается перейти в другую CSS из текущей. Он всегда именно в том порядке сверху вниз их обрабатывает.
Если бы как-то так можно было представить наш граф, например, если я к CSS представлю такими кружочками
и проведу ребра между CSS, если они там есть, вот такой граф, например, то мой алгоритм примерно вот так работает.
Он сначала вот это откусит как CSS, вот это откусит, потом вот это откусит, потом вот это, потом вот это.
То есть, он не будет идти снизу вверх, скорее наоборот сверху вниз будет идти.
Вот, вопрос есть?
Так, хорошо.
Замечание давайте здесь еще сделаем.
Нам понадобится либо сегодня, либо через раз.
Давайте мы для каждой компоненты, точнее для каждой высшины запомним номер.
Номер компонента сильной связи, где она лежит.
Пусть, так у меня кончились буквы, ну пусть будет ID.
ID от V это номер ксс вершины V в алгоритме Косараю.
Ну то есть давайте мы в коде сделаем еще следующее.
Каждый раз, когда мы находим очередную ксс, для всех ее вершин проставляем ID-шник.
То есть говорим, что они все лежат там ID от V равно номеру компоненты.
Проставили им всем одинаковый ID-шник.
А потом увеличили текущий номер компонента, чтобы все следующие вершины лежали в других компонентах сильной связности.
То есть вот это у меня обратный DFS, DFSR.
Все, что посещает, помечает как бы в текущей компоненте.
А потом увеличивают номер компонента на один, чтобы все остальные лежали уже в следующей, после следующей и так далее.
То есть на этой картинке у меня скажем, вот это будет 0-й ID-шник, 1-й, 2-й, 3-й, 4-й.
То есть все вершины отсюда имеют 0-й ID, все отсюда 1-й и так далее.
Так вот, тогда я утверждаю, что если AB это ребрографа, то ID от A меньше равного ID от B.
Почему? Действительно, если они лежат в одной KSS, то есть если они сильно связаны, то, понятно, у них должно быть одинаковый ID.
И поскольку мы доказали корректность алгоритма Косара, у них будут просто одинаковые ID-шники.
То ID-А равно ID-B.
Значит, иначе мы что знаем? Мы знаем, что они в разных KSS, но при этом есть ребро из A в B.
Поэтому картинка вот такая.
Есть ребро из A в B, при этом A в KSS №C1, а B в KSS №C2.
Ну и тогда мы знаем, что Косарайо сначала посмотрит на эту KSS и ее целиком обойдет.
Скажет, что у нее какой-то конкретный ID-шник.
И только после этого, когда-то в будущем, он обойдет эту KSS и всем вершинам этой KSS назначит свой новый ID-шник.
Потому что иначе, если бы мы сначала обошли вот это, то есть если бы мы начали с этого, то мы бы тогда обошли целиком ID-C1 и ID-C2 и сказали бы, что они лежат в одной KSS.
А мы так не делаем, потому что мы доказали корректность.
А мы доказали корректность, значит мы не можем начать отсюда.
Мы не можем сказать, что эта компонента идет раньше, чем вот эта.
Реально, C1 была найдена раньше, поэтому у него просто меньше ID-шник.
KSS №C1 обходится раньше,
следовательно, у нее меньше ID.
Значит ID A строго меньше, чем ID B.
Вот такой интересный факт.
Вот это нам понадобится, когда мы двасад будем решать, но давайте я уже за две минуты не успею, давайте закончим сейчас.
И в следующий раз мы вот это утверждение еще раз запишем и будем использовать.
Все, спасибо всем.
