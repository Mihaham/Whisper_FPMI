всем доброго дня мы с вами продолжаем курс курс называется у нас технологии настройки
проекторов вот потому что мы тут пытались настроить проектор в итоге вроде привели его
в исходное состояние но даже это нам сильно не помогло потому что мне придется видимо некоторое
время потратить на то чтобы потом этот проектор выключать вот значит сегодня у нас последняя
лекция перед контрольной и значит уже есть пробный вариант контрольной контрольной будет
находиться напомню в одной из трех аудиторий да потому что сейчас вы все прекрасно вмещаетесь
в одно аудиторию но на контрольной вы точно в одного аудитории не вместитесь по понятным причинам
вот распределение людей по контрольным будет чуть позже и сегодня мы с вами начать будем говорить
закать закончим тему тестирования дополнительно значить я принес тех книги которые я планировал
принести их можно взять посмотреть вот ну а сегодня мы продолжим говорить про методики
тестирования и дополнить по говорим еще про патор значит напомню на чем мы с вами в прошлый
раз остановились к сожалению на проекторе не очень сильно видно поэтому я буду некоторые вещи
переписывать значит мы с вами начали говорить по мутационное тестирование это методика
которая позволяет производить над исходным кодом некоторые мутации.
У нас есть с вами функция, которая является public a plus b,
и она возвращает a plus b.
Вот такая у нас функция.
Каким образом мы ее можем мутировать? Мы ее можем мутировать одним из трех способов.
Первый способ – это написать то же самое, только написать a plus b и return.
Такая конструкция, допустим, корректна в питоне,
когда вы можете вернуть произвольный динамический тип из функции.
То есть вы можете вернуть return.
Второй вариант – это вот эту же функцию поменять на protected,
то есть изменить ее модификатор области видимости.
И третий вариант – это у нас с вами функция будет такая.
У нас будет функция a minus b.
И наша цель будет придумать как можно больше таких тестов, чтобы она сломала эти варианты.
Если у нас ни один из вариантов не ломается при прохождении наших всех тестов,
это означает, что у нас тесты достаточно слабые. Почему?
Потому что мы предоставили с вами некорректный код, и у нас эта проверка не проходит.
Как вы думаете, какого мутанта будет сложнее всего победить?
Который возвращает на объект, который делает protected или который делает a minus b?
Который делает protected.
Да, конечно, который делает protected.
Потому что вдруг этот метод оказывается не публичным, а приватным.
Ой, не публичным, а protected, и мы его вызываем в наследники какого-то класса.
В принципе, мы его сможем вызвать, но из нее вызвать не можем.
Особенно представьте себе, что эта функция с модификатором видимости, она...
Да, кстати, код неверный.
Эта функция с модификатором видимости где-то вызывается еще дополнительно.
Так, сейчас я буквально одну момента сделаю, чтобы мне не мешала вкладочка.
Так, значит, в чем заключается цель мутационного тестирования?
Цель тестирования, во-первых, это найти слабо протестированные участки,
которые проходят мутанты, то есть у нас некоторые мутанты остаются.
Дальше понятно, что слабые тесты, просто как сам факт тестов, они пропускают мутантов.
И мы понимаем с вами какие ошибки в целом могут внести в программу.
Самый главный кейс, который бывает, вы берете знак меньше, меняете на знак меньше или равно.
Но это сложно тестируемый мутант. Почему?
Потому что вам как раз нужно явно указать граничные значения.
Логично?
Для того, чтобы как раз проверить переход через границу.
Или еще какой-нибудь слабый мутант у нас меньше на меньше или равно,
а потом L вставится на условия равенства.
То есть у нас получается unreachable код, код, который мы не можем достигнуть.
Вот. То есть вот в этом цели как раз мутационного тестирования.
То есть как он замеряется mutation coverage, мы замеряем количество.
Получается у нас формула такая.
Единичка минус количество мутаций, которые сбежали, на общее количество мутаций.
То есть если у нас количество мутаций и не сбежавших равняется нулю, то у нас coverage 100%.
Логично?
Так. Вот такая вот интересная методика.
Так. Она понятна?
Только, как вы думаете, удобно ее проводить или нет?
Нет. Совсем ее неудобно и к ней прибегают уже в тех случаях, когда нужно вызвать случайные претурбации.
Вот. Это что касается mutation testing.
Значит еще раз мы с вами поговорим про статическое тестирование.
Суть в том, что в статическом тестировании мы с вами не запускаем код, но изучаем структуру дерева нашего проекта.
Собственно здесь есть некоторые примеры, которые мы можем привести.
Первый пример это код review.
Второй пример это статические анализаторы кода. Они же еще называются линтерами.
Про них мы с вами уже говорили.
И есть инструменты замера качества кода. Одним из таких классических инструментов является Sonor Cube.
Его можно использовать тоже в своих задачах. Мы про него детально говорить не будем, но в целом оно показывает примеры.
В чем суть код review? Он выявляет антипаторные.
Что мы здесь видим?
Этот антипатор называется Hadouken code style.
Или иначе callback hell.
Это именно Hadouken code style.
У нас функция, внутри нее проверка условий, внутри нее еще одна проверка условий, еще одна и еще одна.
В итоге что у нас получается? У нас получается достаточно большой уровень вложенности кода.
И с таким кодом разбираться, конечно, сложно.
Как обычно такое решается? У кого-нибудь есть мысли?
Ретернами.
Во-первых, ретернами, а во-вторых, инвертированием условий.
То есть, если вы заходите внутрь условия, здесь говорится, если условие выполнено, мы прыгаем внутрь.
А надо сделать так, что если у вас не выполнено условие, то вы выходите из этой функции.
Да, то есть, инвертирование условий позволяет нам решать нашу задачу.
Да, тут сразу скажу, что еще бывает один антипатор, но это callback hell.
То есть, когда мы вызываем функцию асинхронно, что это означает?
Это означает, что вы не дожидаетесь результатов исполнения, но вам нужно каким-то образом будет просигнализировать, что эта функция выполнена.
Тогда вы передаете в качестве результата еще одну функцию.
И вы получаете как раз тот результат.
Если у нас время останется, я вам покажу, собственно, как работают асинхронные функции.
Так, вот у нас статический анализатор кода.
Значит, мы его, наверное, все так или иначе видели.
Откройте любую среду разработки, и вы увидите вот такой интересный код.
То, что у вас там, допустим, объект возвращает не то, что надо.
Или там подсветит, что у вас строка слишком длинная.
Это тоже явно можно увидеть в любых инструментах.
То есть, любая интегрированная среда разработки, она же IDE, вам покажет.
Либо любой текстовый редактор с подключенным набором плагинов.
Это код, кстати, на языке Objective-C.
То есть, у нас он очень интересный, так сказать.
Значит, линтеры какие бывают?
Их на самом деле бывает очень много.
Еще раз, в C++ зачастую используется Selang Format или Selang Tidy.
Собственно, Selang Format форматирует ваш код, Selang Tidy проверяет ваш код.
Дальше, в Python есть очень большое количество линтеров.
Это Flake 8, PyLint.
Это именно анализаторы кода.
Если мы говорим про MyPy, то это анализатор кода, который проверяет типы.
То есть, type annotations, которые есть в Python.
И в Java зачастую используют либо CheckStyle,
либо, по-моему, еще одна библиотека Humcrest называется.
Но я точно тут могу ошибиться.
CheckStyle зачастую используется.
Так, теперь давайте поговорим про метрики качества кода, которые у нас есть.
Их на самом деле большое количество.
Их реально можно перечислять в этот основные.
То есть, количество строчек кода, lines of code.
То есть, мы говорим про качество кода.
Вот представьте себе, что у вас есть один файл, в котором 10 тысяч строк кода.
Как вы думаете, такой код читать просто или нет?
Максимально просто.
Максимально просто, потому что все в одном файле, да?
Но на самом деле никакой структуры явно не видно за этим.
Если у вас уже проверили первые итерации проектов, вам на это должны были намекнуть.
Если вы пишете много классов в одном файле, вы что-то делаете не так.
То есть, это нужно максимально разносить по разным классам.
Ладно, давайте подумаем, почему метрика lines of code per file не очень хорошая.
В чем у нее есть изъян?
Именно строчек кода.
Можно написать одну строчку и 99 строк комментариев к этому коду.
Ну и в принципе такой код будет вполне читаемый, потому что у нас есть какие-то комментарии, которые дают важную сущность.
Более того, комментарии зачастую используют для того, чтобы генерировать документацию к нашему проекту.
Из таких интересных библиотек, которые позволяют генерировать документацию, в C++...
Кстати, надо будет поговорить про документирование кода.
В C++ зачастую используют инструмент Doxygen для генерации документации, а в Python зачастую используют пакет под названием Sphinx.
Ну либо сервисы a la Read the Docs.
То есть они позволяют вам оформить документацию в явном виде.
А если мы говорим про Java, собственно там есть специальная опция в Systems Work.
Вопрос, если здесь кто-то из 311 группы...
Да, про Mavin говорили?
Ну вот, у Mavin есть опция NV Onside, которая генерирует документацию.
Для проекта.
Вот, то есть это вот такая вещь.
Поэтому с документацией очень важно, поэтому есть другая метрика, называется source lines of code.
То есть количество строчек кода, которые содержат определенные стейтменты.
И как раз statement coverage, мы говорим, что statement coverage у нас равняется...
Ну обычно, если мы говорим именно, что каждый statement у нас в одной строке,
у нас получается, что это coverage равняется количеству statement coverage
к количеству source lines of code.
Да, не к количеству локов.
Да, потому что понятно, что если вот так вот мы сделаем, то мы никогда coverage не добьемся.
Да, именно количество source lines of code.
Ну да, важный строк кода.
Дальше.
Значит, метрики качества, которые можно отследить рефлексивным образом.
То есть, грубо говоря, отследить их в прошлом.
Значит, это количество строк на код.
Да, то есть вы просто идете ретроспективно по всем комитам, которые у вас имеются,
и отслеживаете все изменения, которые у вас произошли в коде.
Их даже можно отследить по названию комитов.
Вы берете и указываете изменения, которые у вас есть.
Ретроспективно.
Ретроспективно это означает, что мы смотрим на историю.
То есть мы понимаем, что в какой-то момент времени мы внесли баг,
мы в названии комитов указали fix и смотрим, какие строки у нас были изменены.
Кстати, для этого есть специальная команда.
Давайте я покажу ее.
Откроем какой-нибудь проект, допустим.
Откроем проект Linux Mint.
Вот, есть, кстати, графическая оболочка для этого всего.
Давайте это все увеличить, чтобы было видно.
И дальше смотрите, идем в произвольный файл.
Ридми, допустим.
И смотрите, здесь есть складка под названием blame.
Собственно, по каждой строке кода она показывает, кто внес изменения в эту конкретную строку кода.
То есть вы можете в принципе отмотаться по истории изменений для этих действий.
То есть назад, назад, назад.
И, собственно, посчитать комиты, которые у вас имеют статус fix.
То есть это именно ретроспективная метрика.
Следующая метрика, которая является очень важной, это цикломатическая сложность программы.
Сейчас про нее поговорим.
И более того, помните первые лекции, когда у нас были cohesion и coupling?
На самом деле cohesion и coupling это математические термины, их можно четко сформулировать.
Я этого делать не буду и на контроль на этого не буду.
Прямо сказать, что вот у нас cohesion такой, то у него качество не очень хорошее.
Так, окей.
Это что касается метрики качества.
Сейчас мы поговорим про цикломатическую сложность.
Да, метрик очень много.
Соответственно, чем больше метрик, тем лучше.
Ну, опять же до определенного момента.
Потому что некоторые метрики могут гаррелировать между собой.
То есть они будут вести себя ровно одинаково.
Так, двигаемся дальше.
Хорошо.
Значит, цикломатическая сложность.
Формула для цикломатической сложности.
Значит, у вас у всех были графы?
Все знают, что такое граф?
Ровно говоря, цикломатическая сложность нашей функции или нашей программы
замеряется по формуле.
E-V плюс удвоенное количество компонент связности.
То есть что мы делаем?
Мы код нашей программы представляем в виде графа.
Неориентированного на самом деле графа.
Рисуем все условия веток перехода.
И замеряем вот эту величину.
Давайте представим, что у нас есть линия.
Скажите, пожалуйста, чему равняется цикломатическая сложность линии?
Линия это у нас что?
Это дерево.
Ну, в дереве что мы знаем? Чему равняется E?
В-1.
То есть для вот этой штуки мы получаем, что M равно E-E-1 плюс 2.
Получаем 1.
Сложность вот такой штуки 1.
Теперь представьте себе, что у нас в ходе есть 1 if.
Да, да, согласен.
Ага, теперь представим себе, что у нас есть цикл.
Нет, 1.
Что такое компонента связанности?
Это класс эквалидности по тому, как мы можем достичь объекта.
Если мы от любой вершины можем дойти до любой другой.
То есть граф у нас связанный, значит компонент связанности у нас 1.
Здесь у нас сколько?
Цикломатическая сложность. Давайте посчитаем.
Раз, два, три, четыре, пять, шесть.
В равняется шести, E равняется раз, два, три, четыре, пять.
Господи.
Раз, два, три, четыре, пять, шесть.
M равняется двойке.
То есть мы с вами видим, что каждая нелинейность по факту,
каждое условие добавляет количество цикломатической сложности единицы.
На примере, который на слайде.
Здесь на самом деле что-то типа Дувайла.
Давайте я тоже это перерисую.
Здесь как раз все возвращается извне.
Вот такой у нас граф.
Что у нас в нем есть?
Раз, два, три, четыре, пять, шесть, семь, восемь.
B равняется восьми.
А E равняется раз, два, три, четыре, пять, шесть, семь, восемь.
B в десять.
Да, кажется, по-моему, тут баг сейчас формуле будет.
Да, четыре.
Так. Раз, два, раз, два.
Да, тут баг формуле M равняется четырем.
Надо будет поправить.
Опять же, просто есть некоторые замеры.
Есть обычно две версии цикломатической сложности,
когда у нас есть возврат начала и когда у нас нет возврат начала.
Но давайте считать, что здесь у нас общая формула.
И цикломатическая сложность равняется четыре.
Сразу скажу, что автором вот этой метрики является МакКейп.
И как раз вы можете пойти и вбить как раз Кейп цикломатик комплексити.
А вот она, кстати, книга.
Вот это оригинальная статья.
Вы когда-нибудь читали научные статьи?
Давайте посмотрим на это.
Познакомлю.
Значит, статья комплексити межер.
Обращу внимание на год.
1976.
Вот она.
Уже к этому году задумывались о качестве кода.
И здесь вводится как раз вот эта формула.
И, смотрите, давайте рассмотрим некоторые примеры.
Сейчас будут примеры разности цикломатической сложности.
Опять же, тут есть некоторые разные нотации о том,
как это заменить.
Я хочу здесь показать пример того, как эта сложность растет.
Вот это код сложности 2.
Тут, скорее всего, печатка.
Вот эти штуки сложности 1.
У следующего кода сложность 2.
У вот этого кода уже сложность 5.
Сложность 6.
8.
9.
10.
10.
11.
Мы поняли.
Это незначное число мы не достигли никогда.
Нет.
Мы поняли.
Нет.
Скорее нужно сказать так же.
Если вы достигаете двузначенного числа, значит у вас есть проблемы в коде.
И как раз, если внимательно почитать эту статью,
то евреистически как раз выяснилось, что если у вас цикломатическая сложность больше, чем 10,
то вам надо переписывать ваш код.
Но потому что тут, смотрите, явно даже видно, что, грубо говоря,
на десяти вершинах, на цикломатической сложности 10,
если как-то граф можно сделать планарным, то есть его можно нарисовать на плоскости,
то когда цикломатическая сложность у вас 11,
ну это уже все.
Как говорится, сложно такой граф сделать планарным,
то есть чтобы нарисовать на плоскости без пересечений.
Вот.
История развития этого всего на самом деле пошла еще в далеком прошлом,
когда сказали, что не надо использовать конструкции вида Go2.
Кто-нибудь хоть раз в жизни использовал Go2?
Ну да, единственное, если вы используете их в Assembler либо в Asyah.
Да, Go2 это просто инструкция вида Jump.
Она просто есть в Assembler, как факт.
А вот если мы говорим про сишный код,
то в Go2 инструкцию можно использовать только как инструкцию Finally.
То есть если вы посмотрите, как работают исключения,
то там есть вот такое свойство.
Там try, catch и finally.
Что делает finally?
По факту, она вне зависимости от того,
закончили ли вы здесь в trial и поймали исключение,
вы очищаете те ресурсы, которые у вас имеются.
Вот такая вот вещь.
Это сложность очень важная.
И здесь как раз...
Тут уже говорит статья, я ее перешлю.
Вот, пожалуйста, посмотрите.
Примеры.
Даже невооруженным глазом видно, что слева код достаточно простой,
а справа код сложный.
А теперь представьте, что вы с этим кодом еще и работаете в виде кода.
А, то есть у вас, грубо говоря, здесь у нас картинка двумерная,
а в коде у нас картинка одномерная.
Будет неприятно использовать вот такой код.
Так, хорошо, давайте про цикломатическую сложность вопрос.
Вы видели, наверное, в варианте пробном, что есть такая задача.
Условные, да, или конструкция-фор.
То есть если у нас есть фор, какое-нибудь,
то как он у нас будет выглядеть?
И мы выполняем некоторые действия.
То есть если у нас есть фор,
то как он у нас будет выглядеть?
И мы выполняем некоторые действия.
Где тряпка? А, во.
То есть как эта конструкция у нас будет выглядеть?
Ну, первое, что у нас есть.
Мы ставим i равное нулю.
Дальше мы делаем условие i меньше 10.
Если у нас i меньше 10, то мы двигаемся и выполняем action.
И возвращаемся в наш цикл.
Иначе выходим из цикла.
То есть, да, у нас тут получается, просто явно цикл появляется.
Поэтому, так или иначе, она называется цикломатической сложностью.
То есть вот раз.
А во-вторых, мы можем посмотреть на количество циклов в нашем графе
и получить конкретные выводы.
О том, какое количество нелинейности у нас с вами в коде возникает.
То есть у такого кода, если мы с вами больше ничего добавлять не будем,
то у нас цикломатическая сложность будет 2.
Так, это понятно?
На контроль не сможете решить?
Ладно, давайте тогда...
Если что, задавайте вопрос.
Так, теперь мы переходим еще к одной методике.
То есть, то, что у нас было, это было тестирование белого ящика.
Сейчас мы с вами говорим про тестирование черного ящика.
То есть, что такое черный ящик?
Мы с вами не видим код.
У нас мы имеем только некоторый вход и некоторый выход.
И по входу мы пытаемся получить определенный выход.
То есть, мы можем подать вход и проверить только выхода.
Значит, какие методики здесь есть?
У нас с вами есть метод классов эквалентности.
Это типичные методы.
Метод граничных значений.
Метод, основанный на моделях.
Я бы сказал, на предметной области.
То есть, образно говоря, вы знаете область, в которой вы работаете.
И знаете, каким образом должны выписываться результаты.
И последняя методика, которую часто используется, это парное тестирование.
Значит, классы эквалентности.
Здесь, на самом деле, все достаточно просто.
Нам нужно по...
Мы с вами бьем наш код.
Бьем наши значения на определенные классы эквалентности.
По именно ответам.
И пытаемся продемонстрировать из условий задач все тесты,
которые попадают, как минимум, по одному объекту в каждой из классов эквалентности,
которым мы определяем по условиям задачи.
Вот это важно.
Давайте тоже, чтобы было понимание, возьмем какой-нибудь пример.
Пример достаточно простой.
Представим себе, что у нас в зависимости от квартала...
От квартала, точнее.
Выплачивается, ну, разное количество, разная сумма взносов.
Значит, здесь у нас выплачивается 5 рублей.
Здесь у нас выплачивается 7.
Здесь у нас выплачивается 10.
А здесь выплачивается 8.
В квартале, извините, важен именно месяц поступления платежа.
То есть нам нужно в каждый из месяцев нашего квартала платить определенную сумму.
Здесь у нас 5, здесь у нас 7, здесь у нас 10, здесь у нас 8.
Нам нужно предъявить по одному из примеров для каждого класса эквалентности.
Значит, какие примеры мы можем предъявить?
Мы можем сказать, что в месяце 2 у нас ответ 5.
То есть в качестве входных тестов мы предъявляем месяц 2.
Дальше мы предъявляем тест для пятого месяца, это май, получаем ответ 7.
Для восьмого месяца, это у нас август, получаем ответ 10.
И одиннадцатый тест.
Одиннадцатый тест.
То есть мы взяли по одному объекту из каждого класса эквалентности и получили ответ.
Понятно, что здесь можно добавлять дополнительные тесты, образно говоря.
Если нам говорят, что если мы, допустим, укажем месяц неудовлетворяющим условиям,
то мы должны получить ошибку.
Ну, собственно говоря, мы получаем ответ 8.
Если мы укажем месяц неудовлетворяющим условиям, то мы должны получить ошибку.
Ну, собственно, здесь зависит от того, как именно условия определяются.
Если мы говорим, что у нас четких требований нет, мы можем взять месяц номер 15.
И это по факту будет класс эквалентности, связанный с тем, что мы не попадаем в наш диапазон.
То есть на объект вида 15 мы должны кидать exception.
Вот такой пример.
То есть метод тестирования методом класса эквалентности говорит нам о том,
что нам нужно привести по примеру тестов из каждого класса эквалентности.
Вот. Желательно брать объекты внутри класса эквалентности, одни на их границе.
Так, давайте вопрос по этой методике.
Вы говорите там сложно-простого.
Да, это реально просто.
Хорошо, тогда следующий тест, и он интереснее, он отличается тем, каким образом проводить варианты.
Метод граничных значений.
Нам нужно для каждого теста предъявить некоторые граничные значения.
То есть по одному тесту из каждой из сторон.
Тут очень важно понять, очень важный момент заключается в том,
какой вид тестирования нас просят.
Потому что у метода граничных значений обычно есть два варианта.
Первый вариант это two-way, двусторонний.
И второй это free-way, трёсторонний.
Что означает?
Если мы с вами рассмотрим какой-то флот-диапазон
и говорим следующее, что вот здесь вот, допустим, при варианте не больше чем 50 ответ х,
а при варианте больше чем 50 ответ у,
то нам нужно будет провести, в два-way тестирования нам нужно будет сказать два теста только.
То есть нам нужно будет сказать вариант 50, входных варианты 50 и 50 плюс эпсилом.
То есть двух границ.
А если мы говорим free-way тестирования, то нам нужно будет не только взять точку внутри нашего объекта
и вне нашего объекта, но и ещё объект, который является по факту объектом уже внутри нашего множества.
То есть у нас 50 минус эпсилом будет 50 и 50 плюс эпсилом.
То есть у нас будет три варианта тестов.
То есть мы должны, грубо говоря, давайте я выражусь так.
В two-way мы можем взять только граничную точку и точку вне множества,
а во free-way мы ещё должны взять точку внутри нашего множества.
Просто бывают различные варианты этого кейса.
Обычно это касается именно флотов.
Сентами здесь будет такая вещь, что у нас в two-way будут варианты 50 и 51,
а в free-way у нас будут варианты 50 и 51.
Собственно, когда мы будем говорить про контрольную, мы будем уточнять,
какой из вариантов граничных значений мы можем использовать.
Нужно будет сделать.
Как вы думаете, что именно логичнее проверять, two-way тестирование или free-way тестирование?
Да, логичнее всегда проверять free-way тестирование, потому что у нас знак меньше,
всегда может легко превратиться в знак меньше или равно.
Любой тест это нужно по-хорошему выявлять.
Так, это метод граничных значений.
Понятен ли он? Хорошо.
Следующие парные тестирования.
Составляем тесты, чтобы все пары признаков были протестированы.
Кейс очень стандартный.
Мы с вами уже смотрели тестирование наших мобильных приложений
и представим себе, что надо протестировать наш сайт на следующих вариантах.
Представим себе, что у нас есть с вами, я не знаю,
три варианта телефонов.
Первый это айфон.
Второй это, я не знаю,
операционную систему берем,
андроид.
Третий это, не знаю,
пусть Windows Phone будет.
Который у нас будет, я не знаю,
айфон.
Андроид.
Третий это, не знаю,
пусть Windows Phone будет.
Которого, кстати, уже нет, но пусть он живет.
Дальше. У нас с вами есть три вида браузеров.
Образно говоря.
Chrome,
Firefox и Opera.
И есть, давайте скажем, три расширения экрана.
То есть у нас есть горизонтальная, есть вертикальная и есть fullscreen.
И нам нужно проверить, как работает наше приложение на вот этих комбинациях.
Сколько всего вариантов будет?
27.
Как вы думаете, 27 вариантов тестировать, особенно вручную, это приятно?
Это очень много.
Поэтому основная методика заключается в том,
почему бы нам не протестировать все возможные пары комбинаций.
То есть не все возможные тройки, а именно все возможные пары.
То есть образно говоря, нам нужно получить тест,
в котором есть пара iPhone Chrome.
Нам нужно получить тест, в котором есть пара Android
на вертикальном лэскейпе.
И предоставить такой минимальный набор тестов.
Да, их будет два раза меньше.
Тут мы займемся немного комбинаторикой.
Ну и особенно представьте себе, когда у нас вариантов 4 будет.
То есть у нас группа будет не 3, а группа будет 4.
То есть у нас получается количество вариантов будет порядка квадрата.
От количества действий, а не четвертой степени.
То есть добавляем четвертую размерность, мы получаем 81,
а так у нас будет порядка 9-10 тестов.
Ну что, давайте составлять варианты.
Значит, давайте iPhone, Android в Windows Phone.
И дальше мы их перечислим.
То есть как минимум нам нужно будет перечислить тройки вариантов.
Windows Phone.
И дальше перечисляем тройки браузеров таким образом,
чтобы они не пересекались.
Ну понятно, что здесь мы можем сделать циклический звик.
C, F, O.
Так, O, C, F.
Дальше что у нас получается?
O, C, F.
То есть у нас получается вот такие тройки вариантов.
А теперь нам нужно протестировать пару.
Допустим Android Horizontal.
Точнее iPhone Horizontal.
Смотрите, здесь мы покрываем сразу пару iPhone Horizontal.
Следующим тестом мы хотим покрыть iPhone Vertical.
iPhone Vertical.
А третьим вариантом у нас закрывается iPhone FFF.
Это кто у нас?
Fullscreen.
Fullscreen, да.
Так, то есть мы перебрали с вами варианты.
Дальше значит iPhone Android.
Ой, Android получается Horizontal.
Сейчас я подумаю.
Можно ли их прямо так же перечислить?
Кажется, их можно прямо так же перечислить.
Так, тем образом смотрите.
Horizontal у нас перекрывает все варианты телефонов, все варианты браузеров.
Vertical перекрывает тоже здесь.
И Fullscreen, кажется, у нас тоже все перекрывает.
То есть если сейчас какую пару комбинаций мы не возьмем из трех групп,
они у нас все будут покрыты этими тестами.
То есть это сильно сокращает количество тестов.
Смотрите, у нас было тестов 27 штук, теперь стало их 9.
Но при этом скорее всего утверждение такое, что парное тестирование сможет там 90% случаев точно выявить.
Наверное, это будет намного проще.
То есть сказать, грубо говоря, поставьте себе...
Один человек берет iPhone, второй человек берет Android, третий человек берет Windows Phone
и проверяет те варианты, которые у нас здесь есть.
Понятно, что вариации могут отличаться.
Так, этот вариант понятен?
Эта методика.
Хорошо.
Пример мы с вами уже разобрали, пример был на доске.
Теперь decision table testing.
Особенность здесь заключается в том, что вы берете, читаете требования
и понимаете, образно говоря, что если вы потратили 5 рублей,
то у вас скидка 0%.
Если у вас, грубо говоря...
То есть читаете какой-нибудь пресс-лист и читаете условия, которые у вас есть по варианту.
Просто с кисточком перечисляете их и просто выписываете их в таблицу.
Образно говоря, что если вы, грубо говоря, потратили 1000 рублей,
дальше совершили выкуп по 50% деятельности, это 11 столбец,
то вам дается скидка 10% на 15 вещей.
Вопрос, как эту таблицу превратить в теста?
Таблица это и есть входные варианты для тестов.
То есть вы просто выписываете все требования в виде таблицы,
а дальше переводите их в тест.
Все, поменяли слово, получили тест.
То есть иногда полезно выписать все варианты в виде таблички,
чтобы они у вас были видны как тест.
Так, это что касается decision table testing.
Вот такие у нас методики тестирования черного ящика базовые существуют.
Их вполне достаточно для базовых реализаций.
Так, это понятно?
Хорошо.
Теперь переходим к тестированию gray box.
Что такое серый ящик?
Это значит, что у нас к нему нет полного доступа.
То есть у нас открыт только частичный доступ к нашему проекту.
И у нас есть частичные знания об архитектуре проекта.
Давайте приведем примеры тестирования серого ящика.
Первый пример это, как ни странно, UML.
Сейчас мы не видим с вами реализацию нашего кода,
но у нас есть реализация видеорхитектуры нашего проекта.
То есть мы можем понять, где может прорвать.
То, про что мы говорили на первых лекциях с точки зрения тестирования,
это как раз тестирование серого ящика.
Дополнительный вариант на самом деле это техподдержка.
То есть первая линия техподдержки, которая сидит,
она умеет отвечать на какие-то базовые вопросы.
Что она переадресует это все разработчикам,
которые уже разгребают отдельные вопросы.
То есть в UML мы не вдаемся в детали,
видим ошибки при этом в архитектуре.
Есть еще примеры, основанные на опыте.
Это, так сказать, experience-based testing.
То есть образно говоря, представьте себе ситуацию,
что у вас есть какая-то проблема в коде.
И не только в коде, в какой-то сфере.
Вы провели эксперимент, у нас должен получиться такой-то результат.
Вы тогда можете обратиться к человеку,
который проводит этот эксперимент не в первый раз,
а, допустим, раз в десятый.
Заплатите ему какую-то сумму, образно говоря,
для того, чтобы он провел вам экспертизу
и сказал, что вы делаете не так.
И тогда вы получаете уже итоговый результат.
То есть вы по факту здесь получите потенциальное место
Если мы говорим вообще, из какой сферы это приходит,
то если кто-то интересовался машинным обучением,
я не знаю, есть ли среди вас такие,
то есть методика как раз, называется active learning.
То есть представьте себе, что у вас есть
какой-то неизведанный мир,
и вы можете у эксперта, грубо говоря, спросить,
что это перед нами.
Для того, чтобы как можно больше раскрыть всю картину,
которую у нас имеется.
Вот это примеры тестирования серого ящика.
Кстати, важный аспект, который заключается здесь,
он состоит в том, что время эксперта ценно.
Грубо говоря, вы не можете его нанять на полную ставку,
потому что это вам будет стоить дорого, очень дорого.
Но вы можете спросить советы за иную сумму,
провести рецензию вашего продукта.
Так, это что касается примеров тестирования.
И если вопросов нет?
Есть ли здесь вопросы?
Окей, тогда мы переходим к следующей теме.
Это автоматические методики тестирования.
И здесь как раз мы посмотрим, как переходить
на более высокий уровень.
С кем-то из вас мы уже эту тему проходили
и на семинарах.
Нам нужно говорить про заглушки.
Это называется test doubles.
Что нам помогают делать заглушки?
Заглушки позволяют не проводить запрос
определенного сервиса, а получать конкретный результат.
Если у нас есть соединение по интернету,
то мы его прирубаем и возвращаем ответ.
И в данном случае у нас с вами есть
несколько примеров.
У нас есть два вида тест-даблов.
Первый называют стаб,
второй называют мог.
И они отличаются между собой.
В чем заключается став?
Он заключается в том, что когда вы вызываете
какой-то метод, вам просто возвращается какой-то результат.
Образно говоря, вы вызываете метод add
с определенными параметрами A и B,
он вам всегда вернет значение 9.
Вы вызываете метод add,
и при вызове метода add вы вернете 42.
То есть оно не влияет на результат теста.
Другой вариант тест-даблов
это MOKI.
Они проверяют дополнительно, что некоторые действия
действительно произошло,
что у вас функция add действительно была вызвана,
и она может поменять результат теста.
Образно говоря, вы делаете 2 плюс 2,
вы заменяете вызов функции add 2 плюс 2
на результат 2 плюс 2 умножить на 2.
И получаете результат.
То есть вы проверите, что вы функцию вызвали,
и при этом вы можете еще вызвать внешнюю функцию.
Допустим, проверить работу базы данных.
И есть другое различие, что MOKI
это на самом деле стаб плюс ожидание некоторых выходов.
То есть ожидание это как раз, что вы проверяете результат работы.
А кто на семинарах Google MOKI уже прошел?
Да, что-то немного.
Хорошо, там в Google MOKI, когда вы будете работать,
есть два варианта.
Первый вариант on call,
а второй вариант это expect call.
Вопрос.
Где MOKI, где Staba?
Да, MOKI это expect call,
потому что мы ожидаем, что при вызове функции
у нас произойдет какие-то проверки.
А on call мы говорим, что при вызове функции
возвращает такой-то объект.
Кстати, если вы запустите пример
без проверки,
то Google MOKI выдаст предупреждение о том,
что вы не повесили никакие проверки на MOKI объект,
на Stab объект.
Это вот такая классификация.
Если мы говорим дополнительно,
то пример, который у нас есть, их обычно различают.
Если мы говорим про объекты,
которые мы обычно умеем контролировать,
то обычно это называют Staba,
потому что мы можем подменить объекты,
допустим, указать другой вариант базы данных,
к которым мы подключаемся.
Допустим, вот как раз те, кто пишут проект
связанный с базой данных,
сначала мы говорили в первый этаж,
что вам нужно взять просто in-memory базу данных,
и вы можете использовать систему под тестирование.
А дальше вы отправляете почту.
Как проверить, что результат будет корректный?
Если вы проводите ручное тестирование,
вы пойдете посмотрите на почту,
увидите вашу почту, можете кликнуть по ссылке.
В автоматическом случае, конечно, вы не можете пойти
в почтовый браузер, потому что, более того,
вы даже автоматически сможете сэмулировать браузер.
Во-вторых, как вы пройдете к капчу автоматически?
Ну сложно.
Капчи, если были бы не такими умными,
было бы все хорошо. Но на самом деле,
я видел несколько вариантов капчи, когда показывают картинки,
и они специально заблюрины таким образом,
и не смогли их разгадать.
Ну да, как говорится,
опять же, кейсы, все пробиваемые пушки
и непробиваемые брони.
Да, резистентность к антибиотикам тоже.
Согласен. Хороший пример.
То есть, по факту, мы можем создать свой mock-объект,
который будет проверять, что мы действительно
отправили письмо.
Но письмо отправлять не будет.
Проверяет выходы.
Какие фреймворки для mock-тестирования существуют?
В Python есть unit-test-mock.
В S++ есть Google-mock.
В Java, те, кто работает по Java,
скорее всего будут использовать библиотеку Makita.
И если мы говорим про JavaScript, есть библиотека Jest.
Как раз детально, как эти тесты работают,
мы как раз будем говорить на семинарах.
Собственно, если вам не говорили про mock-тестирование,
пините ваших семинаристов.
Вот, они вам должны это рассказать.
Так,
вижемся дальше.
То есть, еще раз, моки позволяют заглушить объект.
Да, про свою группу я знаю.
Я это на следующем семинаре планирую рассказывать.
Так, вижемся дальше.
Вопрос, как это реализовать?
Как реализовать моки?
Да, почитать библиотеку,
в которой реализована Google-mock.
Или почитать библиотеку,
в которой реализованы какие-то другие функции.
И вот здесь оказывается интересная вещь,
что мы сейчас с вами рассмотрим два паттерна,
при помощи которых это можно реализовывать.
Нужен механизм подмена.
Нам нужно реализовать механизм подмена.
И здесь важно следующее.
А подменять наш объект?
Или подменять объект в каких-то случаях
и обращаться к действительному реальному объекту?
То есть, у нас по факту будет два сценария этих вариантов.
И первый паттерн, который мы с вами здесь рассмотрим,
это паттерн прокси.
Паттерн прокси является структурным паттерном.
Напоминаю, что у нас есть поведенческие паттерны,
у нас есть порождающие паттерны структурные.
А также есть доступ к объекту-заменителю
до и после вызова функций с целью получения
или ограничения некоторого функционала.
Классический пример,
который есть.
Вот представьте себе,
что вам нужно
делать следующее.
У вас есть банкомат.
У вас есть деньги.
Банкомат.
Что нужно ему для работы?
Доступ к банковской системе.
Хорошо.
Приходит человек,
хочет снять деньги.
Если есть банковская система,
он достает карточку,
отправляет запрос, получает информацию
и уходит.
Что делает он, если нет интернета?
Вариант первый,
кинуть exception.
Но на самом деле такой вариант не подходит.
Почему?
Вдруг банковская система
действительно отказала?
На самом деле здесь возникает
объект-рослойка,
в которую мы идем и спрашиваем,
есть ли у тебя доступ к интернету.
Если у тебя есть доступ к интернету,
мы общаемся к банковской системе.
Если у нас с вами доступа к интернету нет,
то по факту мы можем сказать,
что у нас в банкомате есть определенная сумма денег
и записывать ее в определенный журнал действий.
Этот пользователь снял xxx рублей
или снял 100 рублей.
Пришел Петя,
снял 100 рублей.
Пришел Коля,
снял 200 рублей.
Понятно, что количество денег ограничено
суммой в банкомате.
В банкомате большие суммы не лежат.
Тут есть еще одна вещь,
что если у нас даже денег
в банкомате нет,
это один из немногих случаев,
когда по девятовой карте можно выйти в минус.
То есть у вас не запрашивается информация
в интернете,
вы идете и снимаете определенную сумму действий.
Потом, когда у вас интернет появляется,
вы берете и накатываете все действия, которые есть.
Как раз это и делает pattern proxy.
Чтобы записать некоторые функциональность действий
перед тем, как мы отправим ее
в реальную систему.
Что можно повесить в качестве proxy?
Примеров proxy на самом деле большое количество.
И это реализация паттерна.
Давайте я побольше сделаю.
Вот так вот она выглядит.
То есть у нас, смотрите,
есть клиент.
Смотрите, у нас есть с вами клиент.
Он обращается к сервис-интерфейсу пользователя.
И он может обращаться либо к действительному объекту,
либо к сервису.
То есть у нас есть некоторая операция,
либо к объекту proxy,
который перенаправляет все запросы на реальное действие.
В этом реализована страница авторизации.
Образно говоря, если у вас есть доступ к авторизации,
то вы перенаправляетесь к реальному сервису.
Если у вас нету доступа,
вас перенаправляет в какое-то другое действие.
Авторизация пользователя.
Классический пример.
Вы берете и заходите в систему. В любую.
У вас запрашивается информация.
Если у вас доступа к этому объекту нет,
у вас идет перенаправление.
Наверное, сталкивались всегда с таким,
что у авторизованных пользователей, не авторизованных,
есть разные механизмы действий.
Или в зависимости от языка у вас происходит разная реализация.
То есть, грубо говоря, тут всегда есть
разная функциональность.
Ну и по факту, давайте подумаем,
у вас в качестве прокси объекта
будет МОК, и вы будете вызывать как раз МОК-объект.
А дальше он будет решать
следующую вещь.
То есть, вы будете считать количество вызовов
вашей функции.
И с какими аргументами он вызвался.
То есть, вы введете журнал действий.
И после этого вы можете либо передать
ответы за функции реальному объекту.
Это называется SPY.
Либо вернуть результат работы вашей функции.
То есть, тот ответ, который у вас был заложен до этого.
Вот она реализация.
Кажется, замечательный объект.
И, так или иначе, прокси у вас находятся везде.
В любой системе.
Все, перенаправление настроено
больше прокси.
Вот.
Так, какие примеры использования прокси?
Их, на самом деле, достаточно больших много.
Значит, это ленивая инициализация данных.
То есть, грубо говоря, все ленивые вычисления
по факту происходят так, что вы объявляете объект.
И когда вам действительно нужно получить результат этого объекта,
вы запускаете какую-то операцию.
То есть, есть, так сказать, лейзи.
Есть игр.
Игр, это вы сразу вычисляете результат.
Защита доступа. Мы видели с вами.
Локальный запуск сервера.
То есть, вы делаете локальный прокси объект, который общается к реальному сервису.
Дальше, логирование запросов.
То есть, вы заходите на любой сервис.
И любая активность у вас записывается в отдельный журнал.
Кэширование.
То есть, по факту вы идете и делаете доступ локально, а не к интернету.
И дополнительно можно экономить на результатах запуска тестов.
То есть, это такой паттерн, который так или иначе используется.
Более того, скорее всего, вероятно, кто-нибудь из вас сейчас прямо пользуется этим паттерном.
Что, есть такие?
Кто сейчас в соцсетях сидит?
На букву Ф или на букву И?
Нет таких?
Которые запрещены на территории Российской Федерации.
Я надеюсь, вы намек поняли.
Молодцы.
Значит, плюсы и минусы.
У нас может быть разделение сервиса и нашего клиента.
Плюс, работа при отсутствии сервиса или подключения к сервису.
То есть, когда у нас есть пример.
Дальше, мы можем делать контроль за сервисом.
И минус задержка от сервиса.
То есть, наверное, вы видели все примеры, которые я запускал.
Я запускал их на домашнем компьютере.
Который по факту Secure Shell.
Он позволяет нам авторизовываться.
И на семинарах вы про СССР поговорите детально.
Но при этом могут быть задержки.
Дичайше из-за того, что я ввожу какую-то комбинацию.
Она, собственно, доходит с запозданием.
Это минус использования прокси паттернов и прокси объектов.
Так, хорошо.
Есть ли вопросы по этому паттерну?
То есть, примеров достаточно большое количество.
И есть паттерн-антипод ему.
И, кстати, он является реализован в большом числе языков.
Ну, в той или иной степени.
Смотрите, здесь мы ограничивали доступ к определенному объекту.
То есть, у нас прокси был.
Это у нас объект и его заместитель.
Который его может подменить.
Но есть другой подход.
Давайте попробуем как раз расширить наш объект.
То есть, у нас есть объект.
И нам динамически нужно дополнить его поведение.
Я не знаю.
Возможно, что если у вас есть питон, то вы это уже прошли.
Это паттерн-декоратор.
У кого сейчас есть питоны, кто уже прошел декораторы?
Угу.
Хорошо.
Ну, вот.
Реализация паттерн-декоратора это в питоне декораторы.
А что позволяет этот паттерн сделать?
Он позволит добавить функциональность некоторым динамическим образом.
То есть, у нас, например, отправка нотификаций.
Установка тайм-аутов на определенную задачу.
То есть, у нас задача управляется не более, чем какое-то количество времени.
И сервер на Python.
Тоже, в принципе, можно это сделать.
То есть, у вас обработка запросов идет.
И представим себе кейс.
Что нам необходимо предоставить общий интерфейс для отправки нотификаций.
Сначала в Telegram, потом по почте, потом в Вконтакте.
При этом для разных групп пользователи это делают по-разному.
В итоге, значит, делается следующее.
Что у нас идет семь вариантов отправки на три варианта нотификаций.
Потому что два в кубе, минус один вариант.
Когда мы ничего не отправляем.
Каким образом решать эту задачу?
Каким образом решать эту задачу?
У кого есть мысли?
Ну да.
Нам нужно создать переходничок, который для каждого варианта будет решать, как его вызывать.
Не поверите, в России придумали замечательный вариант.
Какая есть русская народная игрушка?
Матрешка.
То есть, мы берем и обалакиваем один объект внутри другого.
Вот.
Давайте как раз посмотрим эту вещь.
И цель декоратора как раз стоит в том, чтобы динамически добавить функциональность таким образом,
чтобы не зависеть от внутренней реализации.
То есть, у нас будет обертка как в матрешке.
Давайте посмотрим реализацию этого паттерна.
Опять надо картинку увеличить.
Вот она.
То есть, смотрите, у нас есть клиент и у нас компонент есть.
У нас с вами есть конкретный компонент, который пишет наши сообщения.
Есть декоратор, который оборачивает наш объект.
И потом мы поверх этого декоратора можем добавлять какие-то функциональности.
То есть, у нас не будет это делать, наука будет продолжать.
Потому что это очень 쉬е.
какие-то функциональности. То есть у нас есть декоратор
A, который добавляет объекты, и декоратор B, который объявляет
объект. Дайте я тебе как раз пример покажу.
Ой, я не ту ссылку вбил. Итак, значит, паттерн декоратор
он на самом деле самый сложный. Без точки зрения кодовой
реализации. Как раз он будет отправлять нам эти уведомления.
Смотрите код main. Значит, у нас с вами будет нотификатор,
и он будет у нас трех разных типов. То есть у нас есть
natifier, у нас есть tg-notifier, и у нас email-notifier есть.
И я обращу внимание, смотрите, видите, natifier есть один,
дальше второй natifier принимает на вход себе natifier первого
объекта. То есть у нас получается с вами следующее, что у нас
один natifier вложен в другой. То есть у нас lock-notifier, tg-notifier,
и третий объект это email-notifier. То есть они вложены у нас друг
в друга. А дальше делается следующее. Мы email-notifier-у передаем аргумент hello-tp.
Даже видите, даже есть реализация. Видно, что natify у нас есть как раз в
декоратор natifier-е, есть email-notifier-е, есть в tg-notifier-е. То есть во всех типах
объектов у нас есть метод natify. Хорошо, давайте посмотрим, как он реализован у нас.
Мы идем в cpp-source и посмотрим нотификатор. Давайте начнем сначала с декоратора natifier.
Собственно, он делает следующее. У него у natifier-а хранится объект на другой
natifier и мы вызываем natify-месседж. Давайте посмотрим, как выглядит lock-notifier. Все
очень просто. Мы просто пишем в выходной поток наше сообщение. В email-notifier-е... Сразу говорю,
тут сейчас жесть будет. email-notifier. Ну и что тут сделается? Мы вызываем конструктор родительского
класса и отправляем письмо на почту. Через гугловскую почту мы отправляем письмо определенному
человеку. Вот так вот письма по почте отправляются. Это в c++, если что. А вот так tg-notifier у нас
выглядит. То есть мы должны отправить сообщение в какой-то чат. Мы получаем бота, токены для
авторизации и отправляем сообщение. Мы его цилизируем и дальше отправляем сообщение в определенный
чат. В итоге у нас по цепочке они вызовутся. Сначала email-notifier отправит письмо по почте,
потом он передает это все tg-notifier, а после этого lock-notifier. И как раз это в диаграмме будет видно.
Вот она диаграмма по следовательности. Вот так она будет выглядеть. То есть у нас есть клиент,
он вызывает у декоратора b method-execute, в нашем случае notify, потом декоратор b вызовет у
объекта a method-execute, и дальше декоратор a у конкретного компонента вызовет method-execute.
Матрешка получается. Как вы думаете, в чем минус этой матрешки?
Да, это раз. Если в какой-то месте у нас будет ошибка, то дальше в матрешку мы не поедем.
Да, это важно. Но в целом, смотрите, здесь появляется возможность динамически добавлять
объекта. Если мы хотим получить, допустим, сначала отправить уведомления в tg, потом в почту,
мы просто меняем порядок вызова конструкторов. Потому что наш декоратор принимает объект
определенного типа. И, кстати, при помощи декораторов, вот это важно,
реализован мог тестирование в питоне. Именно при помощи декоратора, а не при помощи проксе
объекта. Необходимо учитывать. Ну и в случае применения, когда нам нужно добавлять функциональность
на лету, не меняя код. Или еще бывает такой кейс, очень конкретный, если вам нужно для объекта сделать
наследование, а объект уже final, то есть от него нельзя наследоваться. Тогда вы можете по факту
перейти от статического наследования к динамическому наследованию этих объектов.
Вот, значит, плюс и минус этого паттерна — это большая гибкость, чем у наследования.
Можно добавлять несколько обязанностей сразу. У нас есть, если есть много мелких объектов,
то оно работает как матрешка. Ну и если у нас крайне много объектов, то сложно отслеживать,
в каком порядке они вызываются, для этого нужна трассировка. И сложность дебага последствий
операции. Ну, в целом, это тоже можно решать. Проблемы вы берете и создаете маленькие матрешки.
Значит, это что касается паттерн и декоратор. Так, и давайте поймем главное отличие прокси от
декоратора. Вот два похожих паттерна между собой. Да, именно так. То есть различие этих паттернов — чисто
логическое. То есть прокси обычно ограничивает некоторый доступ, либо отделяет доступ. А декоратор,
наоборот, расширяет эту функциональность. Так, и, наверное, сейчас я покажу еще одну интересную вещь.
Это в качестве демонстрации. Помните, у нас был пример, связанный с тем, что у нас было системное
тестирование, и мы показали некоторый пример. Помните, там, при нажатии на сайт MIP-TRUE мы можем
кликнуть по вкладке «Расписание». В общем, есть у меня такой пример. Давайте посмотрим. Вот он пример.
Значит, здесь использовался библиотека Selenium. Она у меня уже настроена. Единственное, что...
Вы у нас первый курс, да? Да, видите, я тут для пятого курса. Давайте будем считать,
что вы стали первыми курсами магистратуры. Да, сразу так, авансом. Смотрите, что здесь происходит.
Здесь библиотека на питоне. Ничего не видно, да? Пайтест, и вот здесь как раз у нас будет браузер.
То есть мы прямо позволим сделать виртуальный браузер, в котором мы инициализируем его таким
образом. И по факту мы делаем виртуальный браузер, и дальше мы его сейчас запустим. И мы можем
передавать явно команды нашему браузеру. То есть браузер Get MIP-TRUE, дальше, то есть прямо можно найти
элемент по определенной ссылке, по определенному названию, нажать на кнопку расписания. Дальше
расписание занятий, найти эту вкладку именно конкретно. Тут нужно будет сидеть с элементом.
Дальше вы находите элемент, скролитесь на него и скачиваете файл. Нажимаете на кнопку. Что, запустим?
Смотрите. То есть у нас открывается браузер,
и он здесь ничего не поломается. Открывается сайт MIP-TRUE, первое действие. Дальше кликается
на кнопку студента. Это все в автоматическом режиме. Расписание занятий, видите вкладка
расписания занятий. Он на нее кликает. Он на нее кликнул. Видите, он перемотался, скачал файл.
Все, тест закончился. Да, но расписание я не могу открыть, потому что у меня Mac.
Он не умеет Excel файлы открывать. Но в целом, вот такая демонстрация. Это реально можно
делать в автоматическом режиме. Так, наверное, на этом все. Если есть вопросы, то задавайте.
