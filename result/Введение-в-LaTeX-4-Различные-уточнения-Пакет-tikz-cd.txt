Всем привет! У нас сегодня четвертое занятие по теху, и на самом деле сегодня будет последний
раз, когда мы обсуждаем такие базовые вещи, которые касаются набора текста и чего-то вокруг его
форматирования. И после этого планируется еще два занятия посвятить тому, чтобы за один раз
разобраться со всякой векторной графикой, в частности пакетом TIX, а еще одно занятие, чтобы
разобраться с тем, как я вас презентации, вроде той, которая сейчас показывается. Это тоже бывает
очень полезно, если вы в всяких конференциях участвуете, ну или просто какие-то штуки для
отчетности делаете. Тоже полезный навык. Сегодня я буду, в частности, почищать всякие хвосты,
которые образовались за прошлые пары, чтобы потом в чистосовете заниматься с чем-то другим.
Да, содержание того, что было сегодня, но, в общем, еще увидим. Сначала всякое разное. Во-первых,
я обещал разобраться, чем разница между табьюлерами и тэббингами. Это, как мы в
прошлый раз видели, разные окружения, чтобы делать таблицы, и я тогда по старой памяти
случайно написал где-то тэббинг, и оно почему-то не заработало, и стало думать, почему. Это очень
простой тэббинг, это вообще-то устаревшая штука, лучше вообще никогда не пользоваться. Я не знаю,
почему она у меня была в главе вместо табьюлера, но, в общем, тут такая короткая сводка, почему
тэббингом лучше не пользоваться и выбирать вместо табьюлера. Во-первых, в тэббинге нет настройки
выравнивания текста, по какому из краев. Ну, как помним, окружение тэбьюла принимает первым
аргументом некую специальную строку, которая партится на буковке, идентифицирующую выравнивание
в колонках, и некоторое количество прямых слайшей, которые отвечают за количество разделителей,
ну, линии разделителей между этими колонками. Вот, тэббинга такого нет. Потом там вообще другой
тиндексис, там вместо апперсандов что-то вроде знак больше и бэкфлэш, в общем, что-то неудобное и
что-то несовместимое с другими окружениями вроде там рэя или матрицы, которые мы уже видели, тоже
неудобно. Потом в тэббингах, во-первых, поскольку нет способ делать всякие выравнивания текста,
потому что нет аргумента, который подается на вход тэббингу, значит нет способа разделять
колонки линиями друг от друга, и поэтому тоже проблема. Ну и да, кроме того, в тэббинге нет
ничего из того, что будет дальше, чего мы еще не обсуждали. Я вот решил, раз разговор зашел,
обмянуть, какие еще бывают настройки таблиц, потому что мне это периодически бывало полезно,
и это, конечно, такая вещь в себе, которую приходится, ну, наверное, каждый раз гуглить заново,
когда-то начинаешь с этим пользоваться, как-то не откладывается в памяти, но полезно понимать,
что такое вообще существует и этим как-то можно воспользоваться в своей жизни. Вот. Ну, как мы
видели, что когда мы открываем окружение тэббюлар, и мы можем подать аргумент вот такого вида,
как я написал, то, что я уже упоминал, что вот там идентификаторы и буковки, по какому краю
выравнивать, и некоторое количество слэшей, отвечающих за количество вертикальных линий
между колонками. Вместо этих буковок могут быть другие буковки, такие, как в первом пункте.
Вот такие есть варианты. Соответственно, P в честь переграф, M, видимо, в честь middle,
а B, видимо, в честь bottom. Что это за буковки? Они заводят на каждую ячейку в этой колонке специальный,
так сказать, параграф. Это некое особое окружение, которое по-хорошему форматируется. Во-первых,
в нём по умолчанию выравнивание по ширине, а не по одному из краёв. Ну и во-вторых,
внутри него работают всякие модификаторы, как в отдельном блоке. Это бывает удобно.
Ну, поскольку тут выравнивание уже не к какому-то краю, а по ширине, то хочется эту ширину указать.
И обязательный аргумент любого такого параметра — это, собственно, ширина колонки. Её придётся
подбирать руками. Ну, когда вы посмотрите, как будет лучше смотреться и примете какое-то решение,
тогда и будет хорошо. Ну, ровно той, за которую отвечает этот конкретный модификатор. Ну, как
раньше было, что вместо LRC теперь у нас новая нотация P, M или B. В какой пишем, за ту колонкой
отвечает. Ну и есть такое преимущество, если не хочется прямо все колонки вычислять точно
сюда. А вот, например, у вас есть некоторое количество колонок, которые нужно сделать там
фиксировано маленькими. Ну, допустим, колонка там номер чего-нибудь, какая-нибудь дата. Их мы более
или менее понимаем, какой они должны быть ширины, и можем это указать. А все остальные — это какой-то
там неограниченно большой текст. И чтобы с ним не париться, есть замена всей этой истории просто
большая буква X. Она говорит следующее. Все колонки, которые помещены буквой X, вот между ними вся
ширина, которая осталась, делится поровну. Ну, то есть вся ширина, которая осталась после вычета
других параметров, если они вообще присутствовали.
То есть после фигурных скобок X можно... Да. Причем, если мы, скажем, делаем фигурные скобки 3X,
значит, что мы скажем? У нас есть три колонки, и они все равны ширине, и эта ширина делится между
ними. Вот ширина всей таблицы делится между ними поровну. Ну, поскольку мы не написали больше ничего,
если у нас только 3X, и ничего не отнималось, то, собственно, у нас все и осталось. Но я думаю,
это стоит хотя бы раз посмотреть, как это выглядит в коде. Да, на этот раз я не перепутаю,
напишу begin tabular, а не begin tabbing. Тут еще всякие разные параметры, опциональные не очень. Я
уж в этом не хочу копаться, потому что я сам пользуюсь, наверное, раз в год, и, наверное,
ничего не помню. Ну вот, положим, у нас есть 3X, и есть три колонки, в которых есть какой-то текст.
Ну, привычная нотация, мы разделяем содержимые колонки амперсендами. Строка завершать не
нужно, поскольку у нас строка в таблице всего одна. Так уж сложилось. Посмотрим, что будет.
Будет падение. Интересно. Хорошо. Яподеза такая, что чтобы X заработал, нам нужно хотя бы одну
колонку с какой-то шириной указать. Попробуем так. Допустим, у нас есть какая-то колонка,
шириной там 2 сантиметра, и уже потом 2X. Все еще не нравится. Что будешь делать?
Окей, видимо, это что-то, что мне придется еще погуглить и рассказать попозже. Возможно,
после какого-то перерыва. Нет, есть уверенность, что это работает, но, возможно, по модулю еще
какого-то пакета, который я не подключил, или какой-то настройки, которые нужно указать. Но,
чтобы сейчас время не тратить, уж, думаю, ладно, можем смириться, но в качестве компенсации покажу
хотя бы как работают модификаторы Пешки. Вот, я утверждаю, у нас получится таблица
шириной не во всю страницу, а только на 6 сантиметров, которые мы ей отвели. Да, уж,
по крайней мере, это слава богу заработало. Вот с X нужно еще как-то поколдовать. Не могу
искать сходу, в чем дело, не помню. Но, во всяком случае, Пешки работают, это уже хорошо. Уже
чем-то мы научились бороться. Ну, эксперименты ради, если у нас будут все Пешки, а одна Ц, у которой
не фиксирована ширина. Что можно ожидать? Ну, что он подберет просто такую ширину, которая ему кажется
оптимальной. Например, чтобы влез весь текст, как здесь. Я в том, что не рекомендую сочетать два
подхода одновременно, но это как будто бы два разных мира. Один мир делает все через параграфы,
вот эти вот PBM, а другой — через выравнивание. И тот, который с параграфами, на самом деле,
более гибкий, мы еще увидим почему. И, на самом деле, тот эффект, который сейчас достигается,
буквочка C, его можно достичь в рамках параграфа тоже. Это потребует некой более хитрой нотации,
но это будет более расширяемо и в целом рекомендуется, если у вас будут какие-то большие,
сложные таблицы. Нотация такая. Можно каждый символ, отвечающий за колонку, еще обрамить вот
в такие вот две команды. Знак больше и аргумент, и знак меньше и аргумент. Что это за команды? Они
говорят, какой код, ну, тот код, который будет являться аргументом этих команд, какой код подставить
перед текстом каждой ячейки в этой таблице, ну, в рамках данной колонки, которую мы описываем,
естественно, после него. Ну, примерно, как это было с окружениями. Вот у нас был код,
который пресидент текст и был код, который саксидент текст. То, что строго до и строго после
вставляется и потом уже компилируется. Ну, например, такой use case нам хочется, чтобы одна из колонок
была написана вся жирным шрифтом. И при этом не хочется руками указывать в каждой ячейке этот
модификатор жирного шрифта. Мы можем указать его прямо в колонке. Естественно, поскольку это
модификатор, нам хочется написать его перед текстом. Нам потребуется вот эта вот левая из команд,
знак больше и какой это текст. Ну и этим каким-то текстом, который будет поставляться,
будет команда bf-series, которая, как мы помним, открывает модификатор жирного шрифта до конца
текущего блока. Мне кажется, можно вообще любой текст. Мы можем проверить, кстати. Во-первых,
вот я перед модификатором третьей колонки открываю мою команду больше и в ней пишу bf-series.
Ну и проверим, что какой-то текст еще можно написать. Допустим, текст капсом. Вот я утверждаю,
ну вернее, предполагаю, что нарисуется четвертое слово текст перед теми тремя,
которые уже есть. И все они к тому же будут жирными. И это верная гипотеза. Оно буквально
подставляет все, что видит. Вначале ячейки, а потом уже комплиирует то, что получится. Да,
могу. Давай. Да, это хороший план. Код тоже стоит зумить. Вот так, наверное, лучше. Ну ладно,
я попробую сделать так, чтобы не очень большим. Вот. Что мы сделали? Мы написали вот такую штуку.
Знак больше и в скобочках bf-series-txt. Он посмотрел, ага, bf-series-txt. Подставил его сюда,
в третий столбец. И написал еще один текст, сделал все жирным. Ну и более того, чтобы уж проверить,
чтобы проверить, что это работает на все ячейки данного столбца, просто протублируем эту строку,
посмотрим, что они будут две одинаковых. Да. Эффект распространяется на весь столбец. Это
бывает полезно. И в частности, так можно управлять. Ну, поскольку по умолчанию в параграфе
выравнивания только по ширине, и мы как будто бы воруем у себя функционал того,
что раньше было выравнивание там по левому-правому краю или по центру, вот можно это решать таким
способом. Можно указывать там centering или flash left или flash right, или как там это называется.
Можно посмотреть, как эти модификаторы выглядят. Вот, можно подставлять их сюда в качестве аргумента
команды больше. А, BAM, да, сейчас вернусь. BAM, эти буквы отвечают за горизонтальное
выравнивание текста. Ой, сейчас, набрал, за вертикальное. Ну смотри, допустим, у нас есть
какая-то очень длинная по тексту колонка. Тогда нам уместно говорить о том, как будет
относительно длинной колонке выровнен по вертикали текст, которого в колонках не очень много. Ну,
есть три подхода. Можно выравнивать его по верхнему краю таблицы, можно посередине всей этой строки,
а можно по нижнему краю. И вот это как раз отвечает выбор P, M или B. Ну вот, можем для
примера одной колонке предсвоить значение M в честь middle, а другой B в честь bottom. Смотри,
что будет. Проблема. Колонка, которая сентеринг, она на самом деле имеет неограниченную ширину,
и она будет вот туда перейти вообще, пока у нее хоть какая-то на это совесть имеется. Ну,
придется заменить ее тоже на P и тоже дать ей, скажем, три сантиметра ширины, фиксированное
количество. Вот. Что мы видим? Они выровнялись по-разному. Для меня, на самом деле, загадка,
почему то, что помещено буквой M, плохо разместилось по центру, назови это, конечно,
нифига не центр, а что-то непонятное. Но, возможно, дело в том, что, например, модификаторы M и B плохо
работают, будучи одновременно указанными. Мы можем попробовать сделать два модификатора B.
Жесть. Посмотрим, что будет. Ну да, это поведение не похоже на то, что мы ожидали, это правда. Как
будто бы это, наоборот, выравнивание поверху, хотя я был убежден, что это работает несколько
иначе. Ну хорошо, а если это будут два модификатора P, то что произойдет?
В общем, это заставляет задуматься. Нет, есть прям полная уверенность, что это должно работать
так, но, возможно, дело в том, что весь текст, который на самом деле в правой строке, это же все,
в общем-то, одна строка. Ну просто так сложилось, что она очень длинная и нужно много раз переносить.
Возможно, если бы мы сделали это несколькими строками, то стало бы лучше. Сейчас пока не
нужно запоминать то, что я пишу. Что я пытаюсь сделать? Я пытаюсь побить текст на строке поменьше
с помощью команды, которую вы уже видели, New Line или Line Break. Сейчас нам это не очень важно,
в чем между ними разница. Вот, мне кажется, тогда эффект должен проявиться. Ну и, например,
буква B обещанная. Окей, чтобы эксперимент был еще чище, уберем лишнее пояснение здесь.
В общем, какая мораль. Модификаторы M и B явно делают не то же самое, что модификатор P,
но при этом они почему-то делают не то, что я ожидал. Этот вопрос нужно бы решить,
но, видимо, вместе с вопросом, про то, почему не работает X, и более того, мне кажется,
это связанные вопросы, которые чем-то одним решаются, какой-то одной лишней командой. Вот
я их предлагаю на потом оставить. Сейчас не будем тратить время. Ну, повторюсь, сегодня в Афтежен
такие вещи, за которыми даже я хожу, как правило, в Google и, в общем, пользуюсь довольно редко.
Полезно понимать, что такое существует, что этим можно воспользоваться по необходимости,
но в голове это, конечно, все не удержишь. Вот я не удержал, например, почему B и M работают
не так, как я от них ожидал. Но, по крайней мере, мы посмотрели на эффекты от постановки кода до и
после конца ячейки, и это уже, в общем-то, хороший результат. Кстати, можно еще разобраться. Ну и ладно.
Да, окружение array. Я обещал вообще сказать, что это за окружение такое. Огромнее следующее. Это
буквально аналог таблиц, но для математического режима. Но поскольку tabular работает с обычным
текстом, вот хочется иметь какой-то аналог, но вот есть array. У него там очень много настроек
разных, можно посмотреть, как это делается. Ну вот базовый вискейс он такой. У нас когда-то был
вопрос, как нам нарисовать матрицу, у которой будут эти вот скобочки слева и справа ограничительные,
будут двойные вертикальные черты, как, скажем, ущербники Бекли-Мишева. Ну вот, можно так сделать.
Можно сделать array, ну буквально таблицы, это же есть матрица, одно и то же. Ну и задать в этом array
явно, что вот левая граница будет две вертикальные черты и правая тоже. Ну и допустим, это была матрица
какой-то системы уравнений, и поэтому нам захотелось отделить квадратик в левой ее части от самого
крайнего правого столбца. Соответственно, для этого тоже array нам помог. Он так работает из коробки.
Ну так же, как tabular, но при этом в математике. Вот. Это может быть полезно как раз-таки во всей
этой алгебраической истории, когда вы рисуете всякие матрицы, и причем матрица какого-то
хитрого блочного вида, в котором нужны вроде какие-то черты, какие-то вертикальные, горизонтальные,
вот. Наверное, этим стоит пользоваться. Это полезно. Повторюсь, тут есть много настроек,
ну в духе тех, что мы видели на прошлом слайде, там mb и прочее, тут какие-то другие. В общем,
вот здесь можно еще много чего писать. Но я сейчас не скажу, что именно. Это все гуглится,
и более того, этого может даже никогда в жизни не пригодиться. Поэтому предлагаю не заморачиваться.
Вот сам array, сам по себе. Вот он, да, он полезен, он нужен, его я привел. Да, еще один долг был
про кликабельные ссылки. У нас ни таковыми не были, хочется это исправить. Первая важная
оговорка. В прошлый раз я говорил про команду href, которая делает гиперсылки. Ну, команда,
которая принимает аргументами какой-то URL, который она хочет ссылаться, и текст, который будет
являться ссылкой на этот URL, и по клику на который захочется переходить на этот URL. Вот,
чтобы оно вообще работало, нужен специальный пакет hyperf. Ну, кто бы мог подумать, гиперсылки. И более
того, этот же пакет, он, собственно, и открывает нам те функции, которые нам хотелось бы, чтобы
ссылки внутри текста тоже были кликабельными. Ну вот, чтобы это произошло, нужно после подключения
пакета еще вот такую команду запустить hypersetup. Ну, то есть, буквально настроить работу гиперсилы
в ранг данного документа. Настройка такая, чисто косметическая. Во-первых, есть параметры
unicode-true и colorlink-true. Ну, unicode-true, понятно, что значит. Хочется, чтобы тот текст, который
является ссылками, он мог быть уникодным. Поскольку мы пишем на русском языке, в кодировке
бывают проблемы как некоторыми англоязычными. Вот unicode-true, это точно наш выход. В конституции
падают. Надеюсь, они больше не упадут. Да, потом параметры colorlinks. Тут две альтернативы. Либо
можно делать ссылки обравленными в такие рамочки цветные, либо их можно выделять текстом самими
себе эти ссылки. Вот, мне кажется, в литературе более принято второй вариант, ссылки, выделенные
текстом. Я сам обычно им пользуюсь и поэтому обычно представляю значение true. А дальше миллион
параметров, какого цвета нужно красить ссылки, какого вида. Я привел только 4 тех, которые вам
теоретически могут пригодиться. Ну, типа ссылка на, ну, просто команды ref, ссылка на какие-то файлы,
ссылка на какие-то библиографические вещи. Ну, при этом попозже поговорим. Ну, не в этот раз уже.
Ну и вот, собственно, ссылка на URL-ы, куда-то во внешний интернет. И вот их всем можно делать
разными цветами. Цвета, есть некоторые встроенные в техе, их там можно погуглить, там штук 10,
всякие там red, yellow, green, blue. Вот эти вот обычные английские слова. Но есть, на самом деле, много
способов настройки. Во-первых, можно задавать, скажем, набор из двух цветов и числовой параметр
между ними в восклицательных знаках. Он отражает, в каком соотношении нужно одно к другому взять.
Скажем, вот здесь это означает, что я беру 70 процентов черного и 30 процентов синего. Ну,
в церемониях RGB просто берутся те числа, которые кодируют черный, ну, то есть 255 по всем, по всем
каналам. Берется то, что кодирует синий, то есть 255 по синим, и остальные все по нулям. Ну и вот
считается их среднее взвешенное с такими вот коэффициентами 0.7 и 0.3. И получается какой-то
цвет типа темно-синий. Он выглядит довольно симпатично. Ну и, опять же, можно все подбирать,
чтобы это было хорошо именно для вас. Можно вообще руками указывать RGB-шный код, цвета,
который вам нравится. Но там уже не в int, а в числах от нуля до одного, ну, степени яркости
каждого канала. Чтобы это работало, потребуется пакет xcolor, ну, просто, как всегда, use package
xcolor и дальше в пишете все, что вам нравится. Команда define color, которой нужно подать на вход
название вашего цвета, которым дальше будет пользоваться. А дальше один из способов задать
цвет. Ну вот я привожу способ задать цвет непосредственно через RGB, ну, потому что это довольно
удобно и довольно человекочитаемо. И вот с этого момента у вас есть ваше забронированное слово,
там darkblue, которое можно подставлять в такие же окружения, и оно будет работать.
Не, он буквально пишется hyperf, как я написал. Слушай, может быть, если у тебя, скажем,
setup mektech, то, может быть, ну, VSCode с mektech. Ну, смотри, просто, ну, я выгружал довольно много
гайдов, штук пять, а там они по-разному работают, ну, типа, кому что понравится. Ну, в общем,
я подозреваю, что просто у тебя он в рамках базового пакета теха, который скачивается по
умолчанию, вот его там не было, и нужно будет отдельно докачать. И это делается как? Проходишь
в консоль mektech, в раздел packages, ищешь там, нужно, и скачиваешь. Ну, сейчас нам дальше это не очень
пригодится в рамках сегодняшнего занятия, поэтому успеешь починить, ничего страшного. Но пакет
точно такой, я проверял. Вот буквально соседняя вкладочка, вот у меня тут есть, вот hyperf,
она вот так вот работает. Вот, про это поговорили, это уточнили. Да, еще был маленький должок,
как сделать велическое значение счетчиков. Ну, вот вдруг нам захочется, чтобы наши секции были не
раз-два-три, а там abvgd. Это можно сделать. Для этого, ну, вот как мы видели, есть команды там,
роуман, какие еще были, аребик, лейтен, или нет, было не лейтен, а альф. В общем, всякие команды,
которые принимают на вход название счетчика, выдают некую интерпретацию этого счетчика с
точки зрения того, какая была команда. Будет что там римская цифра, или там арабская цифра,
или вообще латинская буква, которая под нужным номером. Вот с таким пакетом, с русским байбелем,
ну, то есть байбел, который еще и с параметром russian, приезжает команда asbook, ну, вот видимо,
как альф в счастье алфавита, вот asbook в счастье асбуки. И команда asbook, она по названию счетчика
выдаёт его кириллическое значение. Ну, то есть ту букву кириллического алфавита, ну, то есть нашего
русского, под каким номером, вернее, под тем номером, какое значение этого счетчика. Ну,
вот такой маленький пример кода, как это будет выглядеть. Мы создаем счетчик, который называется
кир в счастье кириллице, представим ему значение 5, и говорим, вот выдай мне asbook от счетчика кир.
Ну, то есть он выдаст нам пятую букву алфавита, и это букву D. Что характерно, есть команды с буквы
заглавной и с буквы строчной, ну, разница как раз в том, что выходные буквы будут либо заглавными,
либо строчными. Мы такой же видели эффект, скажем, с романом, альфом, всякими такими вещами.
Ну, просто как-то разговор зашел, вот я решил, что почему бы не упомянуть. Ну,
смотри, иногда в некоторых текстах тебе может захотеться сделать
нумерованный список, в котором нумерация будет буквами алфавита. Это же типично,
так бывает, вполне себе. И тогда ты делаешь, соответственно, begin enumerate, и вот как я показывал
в прошлый раз специальным аргументом, какую команду модификатор применить ко всем значениям
счетчика, и там в качестве команды модификатора будет выступать команда asbook. И вот с тех пор
тебя enumerate, ну, текущий enumerate, будет нумеровать не числами, а русскими буквами. Ну, это же,
скажем, противоестественно, когда у тебя в тексте на русском языке есть нумерованный список,
который нумеруют латинскими буквами. Как-то это неудобно. Но вот если хочешь с этим побороться,
то вот это делается примерно вот так. Ага, был еще такой вопрос. Вот я загнулся про окружение split,
и что-то у меня вообще не заработало, мы не поняли со всеми остальными. Решение такое. Сплит,
на самом деле, это окружение, которое работает внутри другой математики. Ну, то есть как окружение
aligned, как окружение cases, которое само по себе математику не открывает, не закрывает, ожидает
ее извне. Ну и такое применение есть. Вот мы открыли честное окружение математическое equation,
где математика началась, и внутри нее можно делать окружение split. Сплит очень похож на aligned,
он, на самом деле, я тут даже, я пытался почитать, в чем существенная разница между split и aligned,
и существенной разницы я не нашел в рамках тех cases, которые нам потребуются, ну, вам для вашей
дальнейшей работы в ближайшие годы, я думаю, вы раньше не заметите. Но, во всяком случае,
вот есть окружение split, что оно делает? Оно берет все строки, которые ей поданы,
и подаются они также через двойной backslash, ну, как вот в окружении всяком табличном,
и так же, как в aligned, тут есть параметр ampersand, который позволяет их выравнивать,
ну, выравнивать по одной вертикальной прямой. Все символы, помеченные этим ampersand,
работают так же, как aligned. Вот он берет все эти строки и говорит, что теперь это один объект,
который нужно нумеровать как один объект. В частности, если этот объект оказался в окружении
equation, который нумируется, то пронумируется оно посередине, ну, потому что это один объект,
и вот его оно хорошо выровняло. Вот был такой вопрос, я точно помню, и вот мы начались его решать.
Это, наверное, может быть полезно, но я, честно говоря, просто сам особо не пользуюсь нумерованными
формулами, как-то мне это не очень нравится. Чисто дело вкуса. Да, то, что мы… филандом. Вот,
возможно, даже и нет. Вот это настолько похожее окружение. Возможно, что-то из этого было устаревшее,
приехало еще из старого теха, ну, еще не из латеха, не знаю, не могу утверждать. Ну, в общем,
все кейсы, которые у нас, скорее всего, с aligned сорвутся более-менее так же. Ну, вот главная
мораль какая? У нас есть какое-то внешнее окружение из математики, которое нумируется,
например, equation. И если мы хотим, чтобы объекты внутри нумеровали как-то хорошо, скажем, у нас
есть много строк, мы хотим нумеровать все вместе, как единый блок, то мы заворачиваем их в какое-то
еще окружение, скажем, split или aligned. Хотя, кстати, я, кажется, читал, что split не поддерживает
никакой текст в математике до и после себя, как будто бы это штука, которая должна быть в вакууме
сама по себе. Ну, давай проверим. Прям скопирую этот код и попробую, скажем, написать, ну,
вот не просто его, а сказать, что же система уравнений. И раз система, то вот хочется,
чтобы тут была слева фигурная скобка. Ну, а справа, допустим, точка. Ну, уже видели,
кажется, в прошлый раз такие эффекты, что так бывает. Ну, смотри, он отработал, но пожаловался.
Вот, пожалуйста, split не использую, использовал вместо этого aligned. Ну, как бы так мягко пожаловался,
и поэтому все равно сделал то, что мы ожидали. В общем, да, странная вещь. Для меня загадка,
почему эти окружения существуют одновременно. Возможно, они приехали от разных поставщиков.
Например, aligned приехал от amsmath, и это скорее всего правда, потому что все окружения,
которые про вравнивание, они оттуда. А split откуда-то еще. Ну, бок его знает.
Не, ну, это чисто в кассовщину. То есть, не знаю почему. Мне больше нравится нумеровать
теоремы целиком. Вот, вот эти вот лейблы делать, вот, к окружениям, которые теоремы, и ссылаться
уже на них. Не запишу, но, ну, в общем, тут вопрос. Можно по разным подходам придумать. Я бы сделал
как. Я бы все промежуточные важные результаты выделил в отдельные леммы. И вот на лемму уже
ссылался. Но это все вообще дело вкуса, ни на что не влияет. Как хотите, так и делайте. Мы научились,
что вот так оно работает. Окей. И последнее, конечно, что было обещано, это вот есть окружение
фигур и тейбл. Вот мы как-то говорили, что есть способы вставлять в тех всякие там картинки,
там таблицы, и что сами по себе эти объекты, они довольно, ну, плохо устроены в том плане,
что их в тех не умеют грамотно размещать в тексте. Он его размещает прямо посреди строки,
и если при этом это была огромная картинка, то он строку, получается, расширит, а следующее
начнет только вот далеко после. Это будет не симпатично. И поэтому приходится такие объекты
заворачивать какие-то еще окружения, вроде окружения Center или там окружения Flash Left,
Flash Right. Вот более общий подход к этому — это окружение фигуры тейбл. Это специальное окружение,
которое для того и нужны, чтобы в себе инкапсулировать всякие картинки и таблицы,
т.е. фигур для картинок, тейбл для таблиц. Синдексис буквально такой. Есть окружение фигур,
какой-то параметр, сейчас поговорим, что это значит. А дальше все, как мы привыкли. Include
Graphics, который вставляет какую-то картинку в данное место. Ну и вот мы еще прибили к этому label.
Ну, мы в прошлый раз видели, что label — это буквально штучка, позволяющая потом ссылаться на этот
с помощью ссылок, пометить какое-то место в коде. А caption — это такая команда специфичная для
фигуры тейбл. Она специальным образом готовит подпись для данной картинки. Сейчас мы на примере
в коде увидим, что это значит. В общем, это все собирается в новый объект, который называется
фигурой. И вот фигура — это уже хороший объект, его теха умеет грамотно размещать в тексте. И то,
как он это размещает, определяется вот этим вот параметром, который вообще-то необязательный
аргумент. Но, честно говоря, даже не уверен, что без него это сработает. Вот такой синдоксис,
квадратные скобки. Эти аргументы принимают разные значения. Вот такие. Я списочек привел.
Просто страшная аж. Она говорит, ну вот примерно как у нас была история с linebreak и pagebreak. Она
дает лотеху рекомендации. Размести примерно здесь. Но если тебе по форматированию не очень будет
нравиться, то ты можешь подвигать, чтобы у тебя было хорошо. В общем, такая либеральная команда.
Есть варианты T и B. Топ и bottom. Оно говорит следующее. Размести данный объект, будь то картинка
или таблица, строго вверху текущей страницы или внизу текущей страницы. Но если вы читали
какие-то статьи, вы видели, что там часто так делают, постоянно используются. Еще есть странный
вариант буквы P. Видимо, есть слово page. Оно говорит, сделай отдельную страницу для всех таких
объектов. Ну, допустим, у вас их много. Много таблиц. Какая-то стадия по машинному обучению.
Какие-то метрики считаете. И вот все таблицы будут на одной отдельной странице. И поскольку мы эти
таблицы научились и подписывать, и нумеровать, то в принципе нам не страшно, что они находятся,
скажем, далеко от того места, где, собственно, про них говорится. Потому что если мы на них
ссылаться, то мы на них сошлемся, и проблемы не будет. У нас, слава богу, электронный документ,
который может ходить туда-сюда. У нас на отдельной странице будет таблица, которая в одном окружении,
или может разной. То есть если мы делаем разное окружение и в них выделим P, то они все будут на
одной странице или на трех страницах. Это хороший вопрос. Я часто скажу, я ни разу не пользовался
вариантом с P. Можем просто протестить, сработает ли.
Может быть реально удобно, потому что, допустим, я делаю праг, и таблицы чаще всего удобны,
они были отдельно где-то реально. Ну, это хорошая мысль. Ну, давай попробуем, действительно.
Ну, так, только не фигура тейбл, потому что картинки у меня заготовлены при себе нет.
Это правда. Это можно перегрузить, сделав аж восклицательный знак искать. Вот прямо здесь
поставь знак восклицания, как будто ты очень, не знаю, яростно говоришь «Теху, пожалуйста,
именно сюда». Но есть более, как это, более хорошо работающий из коробки вариант. Это
заглавная аж. Ну, вместо страшной аж просто. Она говорит «Вот прям тут размести, пожалуйста,
вот прям в текущем месте». Вот. Но да, мы говорили про вариант с пейдж, и во-первых,
нам нужно сначала сделать, собственно, этот пейдж, а во-вторых, делать хоть какую-то таблицу,
чтобы она была про что говорить. То есть набегим tabular, end tabular, ну, и какое-то там неважно,
A и B. Ну, и теперь хочется, видимо, размножить эту таблицу, сделать их несколько, да, и посмотреть,
что будет при вот таком вот варианте. Ну, только у нас теперь это будут разные фигуры. Ну,
и можно еще подписи делать разными, чтобы мы, точнее, их отличили друг от друга. Смотри,
он собрал их все на одну страницу. Это, конечно, маленькие таблички, поэтому тут не очень наглядно,
но да, он сделал специальную страницу, которая хранит именно такие вот объекты, как table и
figure. И там они по порядку идут. Там первая, вторая, третья. Причем он даже знает русское слово
«таблица», написал его руками. Видимо, оно приезжает с пакетом Babel Russian. Вот. Ну, а дальше наши
подписи кавтомные, которые уже мы руками подписывали. Ну, а нумерация, разумеется,
такая какая, ну, у всех таблиц общая нумерация. Мы про это говорили в прошлый раз. Вот. Есть счетчик
table, который за это отвечает. И, наверное, можно им даже манипулировать. Если, скажем, здесь сделаю
set counter table, ну, не знаю, 10, то, наверное, следующая таблица будет 11 по счету. Да,
действительно, она будет 11. В общем, остальные правила, которые касаются счетчиков, прочего,
они как какие были, таки и остались. Ну, просто новый объект, теперь это таблица. Ну, и да, еще
одно преимущество такого подхода, заворачивать всякие таблицы и картинки в таблицы и фигуры,
следующее. Мы видели специальные команды list of figures, list of tables. Ну, как table of contents,
есть команда, которая генерирует содержание и перерисовывает там все секции, и на какой странице
их можно найти. Есть такие же команды, которые генерят список всех табличек, которые есть в
статье или там всех картинок, и, опять же, со страницами, на которых можно найти. Это очень
удобно, этим можно пользоваться. Собственно, в этом была мотивация по них вообще рассказать,
вот, ради этих команд. Ну, и да, еще вариант, если мы хотим сделать какую-то не очень большую
табличку или не очень большую картинку, которая, скажем, занимает место только там в углу страницы,
а дальше обтекается текстом. Вот как такое настроить? Для этого table уже не годится,
потому что он умеет размещать только его дипа на всю ширину страницы, а нам хочется иначе. Для
этого есть специальное окружение wrapFigure и wrapTable, ну, то есть, заворачиваемые объекты,
так сказать, фигуры и таблицы. У них два обязательных аргумента. Вот у figure был один
аргумент, причем он почему-то необязательный, почему-то в квадратных скобках, хотя, на самом
деле, он, без него, наверное, даже не сработает. Но вот у wrapTable аргументов два вместо этого,
и не оба в скобках фигурных. Собственно, какой ширины должна быть данная штучка? Ну, поскольку
теперь мы хотим, чтобы она была посреди текста, она должна обтекаться, значит, у них какая-то
конкретная ширина, которую мы хотим указать, там, два сантиметра. А также параметр, собственно,
по какой стороне мы его выравниваем, по левой или по правой? Вот. Ну и что получится на выходе?
Объект, который прям в данном месте попадает на страницу, выравнивается по этому левому или
правому краю и грамотно обтекается текстом по всем правилам, какие все есть. Обычно выглядит
симпатично. Да, но чтобы это работало, нужно подключить еще пакет wrapFig. Ну, как всегда, usePackage
и далее название. Нумерация у тех таблиц, которые получены из table и тех таблиц, которые
получены из wrapTable, она общая. Это все один объект. Да, всякие долги я почистил, теперь хочется
поговорить про чуть-чуть более продвинутые вещи на тему того, что мы уже обсуждали. Вот мы говорили
про счетчики, говорили про теоремы, и вот я немножко заикался, как устроена номерация теорем,
и как ее можно управлять. Вот тут я разные способы основу привожу. А первых, да, как мы, я не
верен. Наверное, такое я уже показывал. Мы можем при объявлении теоремы после двух аргументов,
которые обязательные, а именно, собственно, название категории теорем, как мы будем дальше к нему в
тексте отсылаться, и его русскоязычное название, которое будет писаться при генерации документа,
есть необязательный аргумент. Вот теперь мы уже можем это по-честному сказать. Это имя счетчика,
в честь которого нумируется данный объект. Ну, то есть, если счетчик section инкремитируется на 1,
он сбрасывает счетчик вот этот вот теоремы обратно до единицы, до своего первого значения.
То есть, теорема в втором секции будет 2.1? Да, все так. Правильно. 2.1 звучит, если это не был
слышно на микрофон. Значит, в первой секции будут теоремы вида 1.1, 1.2 и так далее. Как только секция
обновилась и стала равной значением 2, то есть, ее счетчик инкремитировался, теорема, счетчик
с теоремы сбросился, и теперь они нумируются снова с единицы 2.1, 2.2 и так далее. И также можно
сделать нумерацию, скажем, следствий в честь теорем. То есть, с каждой новой теоремой счетчик
следствия будет обнуляться. И при этом после теоремы 1.2 будут следствия 1.2.1, 1.2.2 и так далее.
Ну, естественно, после каждой теоремы префикс будет свой.
То есть, оно понимает, когда теорема – это кодовое слово, когда это счетчик?
Да. Ну, потому что у нее просто разные контексты. На название счетчика поступают в качестве
аргумента только в такого вида параметры или в команда вида там setCounter, newCounter,
всякие такие. А когда мы делаем begin-end, то есть, окружение какое-то, открываем-закрываем,
то, понятно, я делаю это не иначе как окружение, не счетчик.
То есть, идти по перегрузке? Ну, наверное, можно так сказать.
Я уж на самом деле сам не вполне шарю как-то прям со стенки, как устроено, но, наверное,
наверное, как-то так. То есть, понятно, что это какой-то синтезактический анализ.
Он просто, скорее всего, смотрит на то, какое было предыдущее слово,
ну, вернее, смотрит, как бы, на структуру дерева разбора, если уж там более хитро говорить.
Но вот, я думаю, это слово, оно является определяющим. В данном случае он видит,
что мы делаем newserum, и, знаешь, он не ожидает того, что мы напишем какое-то,
ну, в этом аргументе напишем что-то, что будет не счетчиком.
Ну и вот такой вот пример. Предлагаю вчитаться, что происходит. Есть секция первая, потому что
их просто не было до этого в тексте. И дальше мы пишем две теоремы, пишем какое-то доказательство,
пишем какое-то следствие и определение. Вот какая будет нумерация? Предлагаю фиксировать.
Думаем, у нас есть первая секция, есть иоремы, которые нумируются за секциями. Значит, у нас
будет теорема 1.1, 1.2. Правильно? Да. Далее есть окружение доказательства, которое вообще не
нумируется, оно просто доказательство без номера, без всего. Ну и тут тоже не
будет номера. Далее есть короллари, следствие, которое нумируется в честь теоремы. Поскольку
прямо перед ней значение счётика теоремы равно 2, а теорема нумируется в честь секции,
значение счетчика секции равно 1, то значит это будет следствие 1.2.1. То есть он подтянул значение
черчика в секции и теорема, и их в качестве перегрессов
вказал.
Ну и да, дальше у нас теорема определения, но поскольку
это окружение с звездочкой, оно вообще не нумерованное,
то есть тут вообще не будет номера, думать про него
не нужно.
Ну и да, оно выглядит ровно так, как я сказал.
Две теоремы под разными номерами, и следствие
у которого префикс номера — это номер и теорема,
который предшествует.
Вот.
Немножко другой синтаксис.
То был официальный аргумент после обязательных, вот
вот здесь.
Если мы укажем этот официальный аргумент между обязательными,
вот такой синтаксис, это будет значит следующее.
Это значит, что мы теперь счетчиком для теорем категории
proposition будет не свой счетчик proposition, а тот счетчик,
который мы укажем здесь.
То есть мы зададим свой счетчик какой-то, ну new counter,
это значит мы инициализируем счетчик, который называется
my count, и говорим, что именно этот счетчик будут использовать
как теоремы категории proposition, так и теоремы категории
lemma.
То есть у них будет общая номерация.
Значит, смотрим на примере.
Есть некая солянка из propositions и lemma, и они все используют
один счетчик my count, который на момент инициализации
равен, конечно, нулю.
Мы это обсуждали.
Значит, первое утверждение proposition, как всегда, инкриментирует
счетчик на 1, которому оно пользуется счетчиком
my count.
И значит, наверное, это будет утверждение 1.
Дальше идет lemma, поскольку у них счетчик тот же, она
снова инкриментирует, значит, получится lemma 2.
Далее снова proposition, будет утверждение 3.
А дальше мы говорим step counter my count, то есть мы насильно
инкриментируем счетчик еще на 1.
Когда следующая lemma, она будет под каким номером?
Ну было раз, два, три, а потом мы его еще инкриментировали
насильно.
Ну значит, пятый.
Действительно так.
Проверим, что действительно так.
Да, ура.
Вот тот самый счетчик качует из утверждения в утверждение
и увеличивается так, как мы ему сказали.
Ну вот, это похоже на какой-то странный случай, и непонятно,
где его использовать.
Тот вискист, который у меня в голове, что вот иногда
утверждение lemma это что-то очень родственное, их можно
нумеровать подряд.
В целом, да.
Поэтому в принципе в такой ситуации, наверное, можно
использовать.
Если вдруг пишете какой-то конспект и лектор, которого
вы слушаете смешивает утверждение lemma, то вот это ваш выход.
Вот.
Ну и да, тут есть тоже комментарий, который я уже говорил,
что счетчиками, которые отвечают за те олемы, можно
манипулировать так же, как обычными счетчиками, там
делают step counters, делают step counters.
Если вам это вдруг почему-то необходимо.
Да, теперь чуть-чуть про кастомные символы.
У нас про это был разговор в прошлый раз, как делать
символ делимости, всякие такие вещи.
Ну вот есть такой инструментарий, в тех, которые называются
бокс.
Есть куча разных боксов.
Бокс — это буквально контейнер, ну, так переводится.
И есть разные боксы, которые умеют применять разные
модификаторы к тексту, которые внутри.
У них еще какие-то есть свои там свойства версточного
характера, которых я сейчас не хочу говорить, которых
я сам не очень знаю.
Но вот нам как юзерам интересно, что умеют эти боксы делать
с текстом.
Есть просто пара бокс, который просто заворачивает
текст в контейнер фиксированной ширины.
Значит, весь текст будет по ширине, может быть, не
такой, как вся страница, а какой мы укажем.
Есть framebox, он просто заворачивает то, что внутри в рамочку.
Есть colorbox, он подкрашивает, по-моему, фон подкрашивает,
но, может быть, и сам текст.
Надо проверить.
Я сам никогда не пользовался конкретно colorbox, не могу сказать.
Но это точно работает.
Racebox берет содержимое, которое мы подали, и поднимает,
слово race, либо опускает его на значение lift.
Ну то есть, lift это будет какое-то число указанное
в единицких измерениях, которые к тебе отвечают на
всякие размерности, ну то есть там или point, или x, или
m, или сантиметры, все, что мы обсуждали на первых
занятий.
И вот он поднимает его или опускает на такую величину.
Почему может опускать?
Потому что значение может быть отрицательным.
Скажем, racebox минус 5 сантиметров текст, он возьмет конкретный
текст, который в скобочках, и опустит его на 5 сантиметров.
При этом…
Да-да?
Как он может его поднять в плане, если сверху текст,
мы пишем racebox…
Прямо насильно.
То есть оно перерекается.
Да, это не повлияет ни на что вне этой коробки.
Он просто возьмет текущий текст и вот прям вот визуально
его поднимет еще на 5 сантиметров.
Клинж.
Ну, казалось бы, клинж, но есть кейси, о которых это
может быть полезно.
Например, у нас есть какие-то кастомные символы, нам нужно
по какой-то причине какие-то два объекта друг на другом
положить, например.
Ну, какой-то нужен такой сложный композитный символ.
Я такого примера не приведу, но предлагаю поверить, что
они есть, и вдруг они вам когда-нибудь тоже встретятся.
Да, есть…
Блин, я забыл перепечатать.
Короче, это не racebox, это rotatebox.
Rotatebox, ну, значит, бокс, который вращает.
У него в качестве обязательного аргумента количество градусов,
на который он повернет текст, ну, кажется, противчасовой.
Ну, это можно проверить, противчасовой или почасовой.
Ну, как-то детерминирован, там явно прописано.
Ну, есть scalebox, который масштабирует содержимое.
Вот scalebox мне прямо прикажетался, мне вот, например, чисто
идеологически не нравится, как в техе написаны буквы
хи заглавные.
Вот, предлагаю посмотреть.
Кстати, я не помню, работают ли хи вне математики, но
предлагаю попробовать.
Может быть, сработает.
Не, не сработало.
Ну, это же математика.
Мне не жалко.
Что опять?
Сейчас почему?
Может, мне какие-то AMS чего-нибудь не подключено?
Вроде подключено.
Почему же тогда нет?
Ну, хорошо.
И что-то интересно, а если эпсилон?
Эпсилон ты знаешь.
Чего-то ты не знаешь то о хи.
А, я понял.
Заглавное хи — это буквально латинское х.
Поэтому он, собственно, ничего и не делает.
А, сейчас у меня опять падает студия.
Вроде перестали падать.
Да.
Ну, вот, особенность буквы хи в том, что некоторые,
скажем, лекторы на физтехе рисуют ее даже заглавную
не как просто х, а как что-то симпатичное, ну, там как-то
вот загогулиными.
И вот в обычном техе хи только строчная, которая так
умеет.
Вот, предлагаю посмотреть.
Ну, то есть, буква симпатичная, но сейчас мы скажем, делаем
хи для сравнения ABC, но вот она почему-то опущена
вниз.
А вот мы хотим, чтобы теперь это было наше заглавное
хи.
Вот, переопределим мы вот таким вот образом.
Вернее так, даже не переопределим, а просто определим, потому
что команды хи заглавной их в техе вообще нет, потому
что он думает, что заглавное хи — это просто х.
Вот, предлагаю определить заглавную хи.
Ну, как мы это сделаем?
Мы сделаем нюком.
Во-первых, уже известное сочетание.
Сделаем команду хи.
И, собственно, что нам нужно?
Видимо, нужно этот хи, во-первых, отмасштабировать за счет
скейлбокса, а во-вторых, поднять вверх строки за счет
рейсбокса.
Предлагаю так и сделать.
Вверх скейлбокс.
Ну, допустим, 1.1.
Не очень сильно ее увеличим.
И, да, посмотрим, что будет.
Так, видимо, здесь потребуется, скажем, вот так вот сделать.
Как всегда, проблемы.
Ладно, предлагаю тогда пока что забыть о том, что хи
в математике, и вот эти доллары оставить здесь.
Не понял.
Как будто бы он не знает скейлбокса.
Ну, как такое может быть?
Сейчас, из чистого интереса, а если я просто делаю, ну,
какой это скейлбокс?
Может так казаться, что он тоже приезжает с каким-то
пакетом, а я, может, забыл, с каким.
У них, конечно, неудобно.
Да, он не знает, что такое скейлбокс.
И я тебе позволю погуглить, откуда он приходит, с какого
пакета.
Просто, чтобы время не тратить.
Примерно перевести хочется.
Ну, то есть, не мог же написать что-то совсем неправильное.
Скорее всего, не мог.
Да, действительно, он приезжает с пакетом графикс.
Его нужно подключить, чтобы это заработало.
Ну, хорошо, делаем use package, graphics, и пробуем еще раз.
Окей, оно смогло обнасумировать букву А.
Хорошо.
А теперь попробуем, что будет, если мы сделаем, собственно,
нашу хи.
Ну окей, буквы хи стало, кажется, больше.
Но она все еще опущена вниз с строки, и это хочется
исправить.
Ну, вспоминаем, что у нас есть инструмент racebox.
Он поднимает весь текст на какую-то величину, какую
мы укажем.
К сожалению, придется подгонять, какая именно величина.
Ну, как будто это что-то типа половинка буквы X, ну,
то есть половинка строчной буквы.
Поэтому я предлагаю написать 05X.
Ну, как будто угадал.
Все, ура, мы сделали свою кастомную заклавную букву
хи, которой раньше техи не было, и теперь можем ей
пользоваться.
А что это за гвозда, конечно, насчет математики, что
вообще-то эта буква хотите еще в математике применять,
а мы тоже доллары использовали внутри.
Но, оказывается, оно, в общем, оно это схавало.
Видимо, я так это для себя объяснил.
Вообще-то, скейлбокс, он создает такое маленькое
окружение внутри себя, такой вот параграф.
И все, что внутри него находится, оно, собственно, только то,
что внутри влияет.
И оно даже не знает, что снаружи математика, не
математика, ему это неважно, потому что он в вакууме
существует.
Ну, на то и ты бокс, контейнер.
В общем, мы с этим справились.
И второй такой полезный пример была речь о том, как сделать
значок делимости.
Три точки друг на другом.
Я позволю себе украсть код, который я нашел на Stack Overflow.
Ну уж не будем набирать, просто зачитаю, что тут
написано.
H-боксы и V-боксы – это тоже какие-то боксы, причем древние
боксы, приехавшие еще из Теха, которые просто
заворачивают текст в горизонтальную коробку, в данном случае
в вертикальную коробку.
Сейчас это все не очень важно.
Важно следующее, что, во-первых, у нас три H-бокса подряд, значит,
мы насильно размещаем три коробки друг на другом,
каждый с новой строки.
Ну потому что это горизонтальные коробки, они вот так вот устроены.
Но при этом каждая новая строка, мы говорим, будет
довольно маленькой.
Мы задаем параметры baseline-skip довольно маленьким, чтобы
эти новые строки, они были прям меньше одной буквы
x.
Тут сейчас много еще непонятного, я даже не призываю все это
распарности понять, я призываю понять философию, что вот
есть боксы, они позволяют текст внутри себя как-то
им манипулировать, чуть хитрее, чем мы раньше умели.
И вот мы вот тут манипулируем так.
Мы заворачиваем в боксы точечки, ставим точечки друг
на другом и вот еще заворачиваем все это в команду mustrel.
Если помните, мы во второй раз обсуждали, что вот есть
mustbin, который весь текст, который внутри нее превращает
в математическую бинарную операцию и примет соответствующие
правила выставления пробелов там до и после аргументов.
Вот mustrel это почти то же самое.
Ну просто правила расстановки пробелов между бинарными
операциями и аргументами и между relation, отношениями
и аргументами, оно немножечко разное.
Ну и вот уж для чистоты, поскольку все-таки это отношение,
мы именно по-моему mustrel, а не mustbin.
Ну и на выходе мы что имеем?
Оно взяло три точечки, их нарисовало друг на другом
и получилось, в общем-то, симпатично.
Уж всяко симпатичнее, чем команды видос, да?
Ну если вам этиологически очень не нравится что-то
очень много непонятного кода, который даже я украл
и я бы сам его не написал скорее всего, потому что
ну это какие-то странные параметры, их тоже раз
в жизни задаешь, но можем попробовать иначе.
Какой подход естественный намечается?
Мы же знаем про команду видос, вертикальные точечки.
Вот допустим.
Не-не, вертикальные точечки, они уже вертикальные.
Ой, сейчас, кто-то написал видос.
Чем плохо?
Во-первых, это не отношение, поэтому пробелы плохо стоят.
Во-вторых, они какие-то большие, они торчат куда-то вверх.
Наверное нам поможет скейлбокс.
Можем попробовать.
Предлагаю сделать new command, который будет называться
div by, divisible by, а внутри скейлбокс, ну наверное 0.9, нет, 0.8,
вот с таким коэффициентом давайте попробуем, а внутри
что ну вот видос.
Напомню, что то, что в боксе, да, правильно, напомню еще
раз то, что в боксе оно не видит математики снаружи,
поэтому нам придется доллар внутри тоже поставить.
Оттейс, да, мафрел, чтобы правильные пробелы были
ко всему прочему.
Если сейчас все это заработать в первый раз, то будет конечно
очень приятно.
Ну а вдруг, о, заработало, смотрите, получилось.
Мы сделали почти то же самое, но при этом кодом, который
мы понимаем.
Да, мне кажется, это довольно приятно.
Ну и понятно, что можно там подбирать значение масштабирования
там, может быть 0.8.5, какое-то самое оптимальное, чтобы
это было прям очень симпатично.
И ну вот, мы изобрели символ и можем теперь им пользоваться.
Вот такая история.
Для этого боксы и нужны.
Ага.
Что-то вот перемудренное какое-то.
Ну, я его украл с отца Коверфлоу, ну то есть там сидят такие
адепты теха, которые, во-первых, на нем писали, когда мы еще
там только-только родились, скорее всего, и там было
очень много разного старого синдекса, за который сейчас,
ну может быть работает, поддерживается, но никем
не используется.
Ну в частности, аж боксы, это, да, штуки прямо из старого
теха, например.
Ну, как бы, это решение, которое у кого-то сработало,
почему бы не воспользоваться.
У меня про это сегодня еще будет, что, в принципе, старые
решения, они, ну, типа, ничем не плохи.
Если мы хотим просто их применить раз в жизни, а
не выучить понять, почему они работают, дальше пользоваться
именно ими.
А вот просто решить конкретную проблему.
Конкретная проблему у нас нет трехточечек.
Возьмем триточки вот таким вот образом.
Ну, можно и такое взять, и работает, и слава богу.
Мы хотя бы поняли, что хотя бы примерно написано.
Примерно тут тоже какие-то боксы как-то друг с другом
размещаются, какое-то соотношение метрическое
между ними останавливается, ну, и как-то оно работает.
Ну да, это, конечно, громоздкое решение.
Уж по крайней мере, когда мы научились делать свое,
мы, наверное, будем пользоваться им, как-то это в душе приятнее.
Ну и тем более все понятно.
Да, про декомпозицию на файлы.
Тут будет совсем просто.
Как я уже упоминал, большие проекты, все их, ну, их
трудно поддерживать в одном файле, в самом ожидаемом,
в стадии композировать, и потом подключать уже по
кусочкам какой-то большой документ, который в Main.Tech,
собственно, который потом будет собираться, и результат
сборки которого и будет нашей работой.
Вот.
Ну, как это делается?
Мы пишем разные коды в разных файликах, как-то их называем,
а потом подключаем их в Main.Tech с помощью команды input.
Команда input буквально берет тот код, который написан
в соответствующем аргументе, в следующем файле, и подставляет
этот код на стадии компиляции, и собирает его все вместе
уже как будто это единый файл.
Вот.
Можно тут писать в конце точка тех, название файлов
можно не писать, но он догадается.
Ну, просто потому что мы input'ом бы не стали подключать
ничего кроме файлов в точке тех, и как-то, в общем, сообразит,
даже если мы это не укажем.
Есть у него альтернатива include, но небольшая табличка,
в чем разница между ними есть.
Да, можно подключать файлы с помощью input, можно с помощью
include.
Разница следующая.
Во-первых, input подставляет просто текст.
Include окружает себя некоторым информатированием.
Он начинает с новой строки, с новой страницы, с красной
строки и всякие такие вещи.
Если мы делаем какие-то логически очень друг от друга независимые
вещи, скажем, в каждом файле у нас какая-то большая
голова книги, и мы хотим эти главы друг от друга
более-менее независимым початать, то тогда, в принципе,
можно через input это делать.
Почему бы нет?
Потом.
Input'ы могут быть вложенными.
У нас, допустим, гигантский проект, в котором файлы
вложены, файлы вложены, файлы вложены, вот тогда
тоже input это наш выход, а include не наш.
Кроме того, если мы хотим в какой-то причине комплировать
не все, ну скажем, мы на стадии отладки находимся
и проверяем конкретные главы, напечатанные хорошо.
Мы можем для includ'а задавать специальную команду include-only,
указывать преамбулу и далее какое-то количество
имен, и тогда он будет делать что-то нетривиальное при
команде include-filename, только если filename это одно из этих
имен, которые мы указали, а иначе он просто ничего
не будет делать.
Ну то есть это удобно тем, что мы написали одну строчку
и вот вся отладка, а в случае с input'ом придется ходить
и комментировать намеренно каждую строку, которая
что-то input'ит, еще может что-то просмотрим, пусть нехорошо
тогда.
Ну в общем-то такие, минорные различия, на стадии продакшена
конечно это не влияет, ну когда почитать готовый
текст.
На стадии продакшена, разница основная в том, что input он
просто подставляет текст, а include его заворачивает
в новые страницы и вот как-то обоставляет от всего остального.
Да, еще одно уточнение, что весь этот поиск файлов
он идет из корневой директории, в которой лежит main, то есть
он когда собирает main, он переходит в директорию,
которая находится и уже оттуда начинает искать.
Возможно можно как-то этим управлять и указать в переменную,
ну что-то вроде переменный path, ну для теха какой-то
своей, не знаю, есть ли такая, наверняка есть, указать
им какие-то еще пути, по которым ему нужно искать
файлы, но мне кажется это какие-то заморочки и один
теховый проект лучше хранить как-то в одном месте и думаю,
что от этого вам сильно неудобнее не станет.
Да, это буквально такой файл с помогательной, которая
именно чтобы подставиться в основной, там уже нет
ни преамбулы, ни begin document, ни end document, там только голый
код.
Да, сам по себе он не скомплируется, это хорошее замечание,
действительно так.
На самом деле, если мы посмотрим на преамбулу, ну вот у нас
же были уже там Playground и у них были преамбулы, а наш
тоже вообще не скомплируется, просто потому что у нее
вообще нет begin document, end document, но при этом оно как-то работает,
потому что мы его подставили, команда input, она просто
подставила код преамбулы и пошла комплировать дальше,
где уже document есть, вот.
Вот, если помните, input, собственно, и был тем спойлером, который
я еще на первом занятии, кажется, озвучил, что вот
можно так преамбулы подключать, но вот можно не только
преамбулы, а можно вообще что угодно, и вообще это
хороший тон, где композировать проекты, скажем, на главы
или там на лекции, ну, зависит от того, чего пишете, так
и вам удобнее, и читателям, и тем, кто поддерживает
ваш код, если кто его поддерживает.
Да, еще есть способ подключать под рефники, вот прямо уже
скомплированные под рефники или вообще под рефники
другой природы, ну просто какие-то у вас были, вы
хотите их в тех вставить.
Есть команда input pdf, прижатая с пакетом pdf pages, там есть
разные настройки, можно в разном порядке их указывать,
вот тут я привел пример, что можно, скажем, вставить
меня в страничку первую, третью, и все из интервалов
с пятой по шестую, ну как бы это тут не очень интересно,
потому что это подряд пятая и шестая, но можно было
бы, скажем, 5-7, там было бы 3 страницы, и он их, соответственно,
страничками подряд вставит в то место, где мы это попросили
сделать, вот.
Если бы мы хотели, чтобы это было именно как векторная
картинка вставлена, мы бы сделали input graphics, input pdf,
он буквально вставляет прям страницы в наш документ,
вот прям после нашей страницы текущей вставляет новой
pdf страницы, вот.
Это бывает полезно, если вы, скажем, готовите что-то
для печати на буклетах, скажем, у которых там типа
три разворота, да, вот такие сверточные, и их, ну вообще-то
текст удобно генерить просто подряд сверху вниз, весь
в каком-то документике теховом, да, текст удобно генерить
прямо подряд в одном документике, но при этом, когда вы будете
готовить его на печати, вам потребуются эти блоки
текста как-то переставить, потому что, как мы понимаем,
на печати, особенно странного буклета, там, с цельными
разворотами, страницы будут в каком-то другом порядке
идти, чтобы это было правильно на печати, и вот тогда нам
поможет pdf pages, потому что там есть некие настройки,
которые такой заточены, но я, конечно, в этой подробности
не вдаюсь, потому что не уверен, что это многим
потребуется в жизни.
Ну, мне когда-то приказалось, поэтому решил включить.
И вот такой небольшой спойлер к тому, что мы будем
заниматься в следующий раз, заниматься будет
компьютерной графикой, ну там, всякие векторные
рисуночки, там, графики функций, какая-то геометрия,
вот такая демо-версия его, это пакет tixcd, вот, все
графикой заведут пакет tix, а вот tixcd, это его расширение
все обрисовать так называемые компутативные диаграммы.
Сейчас не очень важно, что это значит, но можно воспринимать
это так.
Это способ рисовать схемы, в которых у вас есть только
объекты и стрелочки, которые их соединяют.
Ну скажем, какие-то графы, какие-то там автоматы, может
быть, вот какие-то такие штуки, если хочется рисовать,
tixcd вам может помочь.
Буквально всего один пример приведу, ну во-первых,
что вы делаете, вы подключаете пакет, как всегда, usePackage tixcd,
а useCase будет такой, есть окружение tixcd, вы его
открываете, закрываете.
Ну какой-то параметр, тут всякие настройки стиля
можно производить.
Ну вот тут я сделаю rowSeparator равно huge, то есть я говорю,
что пожалуйста мне между строками сделай большое
расстояние.
Буквально это оно значит.
А дальше такое, дальше синтаксис прямо как в таблицах.
У нас есть, ну, наша диаграмма делит все пространство
на какие-то строки и на какие-то колонки.
И тут даже не нужно заранее задавать их количество,
чтобы оно было согласовано бы в течение всего текста.
Тут у меня будет, если мы посчитаем три колонки и
две строки.
То есть я в рамках вот одной строки, у меня есть некий
текст, амперсант разделяющий две колонки, ну какая-то
пустая колонка, снова амперсант, и третья колонка.
То же самое здесь.
Какая-то пустая колонка, амперсант, как это не пустая
колонка, снова амперсант, еще какая-то пустая колонка.
Ну то есть по три колонки, и на первой строки, и на
второй.
Это какой-то обычный математический текст, который, ну, просто как вставлится, мы пишем.
А вот есть особая команда arrow, которая специфична именно для ticcd.
Она буквально рисует стрелочку в заданном направлении, подписанную заданной буквкой или заданным текстом.
Что такое заданное направление? Тут я rr. Стрелочка ведущая на две ячейки вправо, ну, то есть right-right.
Тут у меня есть стрелочка ведущая dr, ведущая на одну ячейку вниз, на одну ячейку вправо.
Напоминаю, что у нас все побито на три ячейки по горизонтали, две по вертикали.
Всего шесть ячейк. Я просто управляю, откуда, куда, какая стрелочка будет вести.
Ну, и там дальше подписывается какая-то будет буковкой phi, какая-то будет буковкой pi, какая-то будет буковкой psi, del это down-left.
А еще есть необязательный аргументом как-то модифицирующего начертания.
Есть, например, dash-right arrow означает, что наша стрелочка будет необычной, а пунктирной.
Ну, типа dash-arrow, пунктирная стрелочка.
А swap означает, что оно обычно подписывается, скажем, сверху.
Текст общается сверху стрелочки относительно той ориентации, которая у стрелочки.
Если она перевернута, значит текст будет снизу стрелочки.
А вот наоборот. Вот это вообще команда swap.
Ну, сейчас я не призываю это сразу вникнуть, но тут, в общем, все довольно просто.
С этим можно разобраться буквально за вечер, если вам это потребуется.
Ну вот как это нам это отрисует? Получилась такая симпатичная картинка, которая отрисовала нужные стрелочки.
Да, у нас, видите, шесть ячеек. Раз, два, три, четыре, пять, шесть.
Просто три из них пустые. Ну, они и были в коде пустые.
А те, которые не пустые, там наш текст, который мы писали.
И вот грамотные ведущие стрелочки, которые там right-right два раза.
Да, там down-right тоже грамотно отрисованная стрелочка.
И какие-то подписи, которые мы указали.
Давай.
Тут было бы, конечно, хорошо, чтобы это было все на одном слайде.
Но, к сожалению, не умещалось.
Не, все окей.
В общем, такой вот простой пакет.
С помощью него можно рисовать, повторюсь, всякие графчики.
Всякие автоматы, если вы какие-то там формальными языками занимаетесь.
И для этого вам не нужно изобретать велосипеды и пользоваться большим пакетом TIX.
Можно пользоваться TIX-CD.
Этот TIX-CD сразу в математике надо.
Да, все верно.
Я его уже внутри формулы включаю.
Это хорошее замечание.
Да, ну и всякие напуственные слова.
Поскольку у нас следующие занятия будут уже специфичные.
Будем говорить именно про векторную графику, про презентации, про библиографии.
В общем, такие вещи, которые уже касаются не прям набора какого-то текста в техе.
Ну, для любых задач.
Какие-то специфичные.
То вот для общих задач я какие-то напустные слова скажу.
Во-первых, есть еще куча пакетов.
Мы далеко не все посмотрели.
Вам будет приказано что-то по жизни разное.
Скорее всего, если вы какую-то задачу не можете решить,
придете в Google, типа LaTeX, HowTo, что-то там.
Вам будет даться какой-то ответ в интернете.
Скорее всего, там будут еще какие-то новые пакеты,
которым придется пользоваться.
Вот есть, скажем, вот такие, которые стоит хотя бы упомянуть.
Есть мультикол, чтобы писать текст несколько колонок.
Ну, я не знаю, как это делать.
Я не знаю.
Вот такие, которые стоит хотя бы упомянуть.
Есть мультикол, чтобы писать текст несколько колонок.
Ну, то есть, не во всю эту ширину страницы,
а вот в полширины и до конца страницы.
Потом снова в полширину и до конца страницы.
Ну, так бывает полезно.
Есть пакет TokLoft, который подходит к левому настроению содержания.
Я про него, наверное, еще расскажу.
Ну, там, через раз может быть.
Есть listings.
Это пакет, чтобы отрисовывать грамотно всякий код.
Плюсовый, питонячий, чтобы это выглядело красиво.
А не голым текстом LaTeX,
а, типа, там, чтобы синексы посвечивало всякие такие вещи.
Приятно.
Есть algorithm2e.
И еще целая пачка пакетов, которые
подойдут рисовать алгоритмы всяким псевдокодом.
Ну, типа, оно умеет всякие форы, элсы и зены
рисовать с символами.
Ну, вот, им часто пользуются всякие там математики,
которые пишут что-то про алгоритмы.
Вот, таким вещами.
Ну, а, есть Repfig.
Но, да, это слайд с прошлого года.
Я в прошлом году вообще про него не рассказывал,
сейчас вспоминал, поэтому это уже вам и неинтересно.
Потому что я уже показал, как им пользоваться.
Ну, да, такое тоже есть.
Что там еще я говорил?
Ну, и да, я говорю, что
стоит гуглить.
LaTeX очень долго существует.
И на ваши вопросы наверняка уже есть ответы.
А то еще и много ответов.
И среди них могут быть, конечно, какие-то упорты.
Мы, скажем, видели сегодня упорты и вариант
нарисовать три точки друг на другом.
При том, что мы придумали свой, который намного проще.
Но тот тоже сработал.
И, в общем-то, слава богу.
Не надо бояться.
Если вы понимаете не весь код, который копируете,
это ничего страшного.
Для тех, к сожалению, это ничего страшного.
Но главное, чтобы это у вас сработало.
Думаю, что на этом стоит закончить.
Ура.
Всякий анонс в следующий раз я сделал.
Спасибо за внимание.
