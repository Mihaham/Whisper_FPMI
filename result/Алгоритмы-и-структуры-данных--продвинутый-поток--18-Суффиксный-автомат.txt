Теперь можно перейти к структуре данных из всей суффиксной приады.
Мы, конечно, не сегодня будем говорить про дерево тандемных повторов,
потому что это не суффиксная структура.
Ну а красивая она или нет, это уже другая вопрос.
Итак, как говорится, поиск под структур в заданной строке в онлайне способ номер три.
Способ номер три на этот раз будет такой.
Ну естественно, так как у вас есть формалки, то вам не надо объяснять, что такое автомат в принципе.
Чем отличается детерминированный автомат от недетерминированного?
Отлично.
Ну вот, тогда можно сразу сформулировать, что такое вообще суффиксный автомат для строки.
Тогда бы просто замгновенно пишем, что определение суффиксный автомат.
Или его еще называют down, вот s.
Ну или там с индексом s.
Ну короче, расшифровывается это как you're directed at cyclic внезапно word graph.
Пока не в оригинальной статье, почему-то автор его вот таким вот образом называл.
Так вот, это минимальный детерминированный конечный автомат, принимающий,
ну давайте уж не будем тут уже мелочиться, надо экономить на словах все суффиксы строки s и только их.
Можно тогда сформулировать принимающий язык всех суффиксов строки s.
Можно и так, да.
А можно и так.
Да, действительно, мы будем говорить языка туда.
То есть в общем-то вот идея, ну в чем собственно идея?
Ну придумать просто какой-нибудь автомат, который принимает все суффиксы строки s.
В общем-то не сильно сложно.
Может чего?
Детерминированный.
Ну ладно.
Ну как придумать просто какой-нибудь автомат детерминированный, который принимает суффиксы?
Тупо построить борь.
Да мало кто знает, но борь это тоже детерминированный конечный автомат.
Правда я бы не самый оптимальный.
Почему?
Да просто потому, что если этот борь нарисовать, например,
ну там, то есть ну обычно там вот, ну там суффиксный борь у нас вот как-то вот так вот будет выглядеть.
Может вот так, вот так, вот так вот еще.
Ну а сразу оптимизация.
А давайте-ка вот эти все листы объединим, скажем, в одну вершину.
Вот. Уже стало вершинней.
Оп.
И соответственно вот.
Вот какая-то такая красота, да?
Вот.
Ну а там, скорее всего, еще и вот эти первые символы-то можно пообъединять и так далее все.
Ну вот.
Ну вообще говоря, а что такое минимальный детерминированный конечный автомат вообще?
Что это такое вообще?
Ну по сути у него каждая вершина — это классиколитность слов.
Классиколитность?
Да, где эквалидность задается как то, что если дописать какое-то слово,
оно либо ли обои будет лежать в языке, либо не будет.
Так. Какой-то классиколитность.
А почему он за это? Так это разве будет не в любом?
В смысле?
Ну минимально, минимально, ну еще и бэдэк крайненько такая.
Его вершина, по сути, это классиколитность.
Какие-то вершины эквивалентные.
Ну да. А что означает эквивалентная?
Ну вот, не знаю, например, слова В — эквивалентные.
Если для любого слова W, ВВ и УВ либо одновременно в языке, либо одновременно не в языке.
Ну да. Ну да, хотелось бы как-бы исполковать человеческий язык.
Ну хотя, ладно, человеческость тут, конечно, понятие относительное.
Ну да, действительно.
То есть основная ключевая идея минимальностью заключается в том,
что для каждой вершины можно определить ее язык.
То есть, по сути, по каким словам из этой вершины можно дойти детерминальных вершин?
И можно действительно заметить, что если оказывается у двух вершин языки тупо совпадают,
то что тогда можно сделать?
Тогда можно просто эти две вершины обедить в одну и никто не пострадает.
То есть, по большому счету, необходимым условием минимальности является то,
что в минимальном детерминированном конечном автомате языки всех вершин попарно различны.
Правда, отсюда же можно аккуратно сделать вывод, что в минимальном автомате,
в общем, минимальный автомат в общем-то заточен сюда из амортизма единственный.
Ну, по весьма банальной причине, потому что, в общем-то, необходимые языки банально порождаются.
Ну то есть, действительно, можно даже попробовать построить автомат для какой-нибудь строки.
Ну вот, например, для какой?
Чтоб, ну так, чтобы интересно было.
А вот давайте я его для абабасы построю.
О, интересно, получится то, что я хочу.
Вот как построить суффиксный автомат в принципе?
Чтобы сразу минимальный.
Ну, во-первых, начнем с того, что у него должна быть стартовая вершина,
у которой будет язык.
Язык.
Ну или там, не знаю, как он называется.
Вот так, не знаю, может он там человек автоматов, язык вершины как-то по-другому называется.
Ну, по каким словам можно из вершины дойти на терминальный?
Как это называется?
Вот было множество вершин, которые недостижимы.
Нет, это другое.
Это как-то обозначалось, не помню какого термина специально.
Ну ладно, будем называть это язык вершины.
Какой язык в этой вершине?
Ну так и пишем.
Эпсилон, А, СА, АЦА, БАЦА, АВАЦА, БАБАЦА и АБАБАЦА.
АБАБАЦА это не глагол, да.
Вот.
Вот, ну что можно сказать?
Эпсилон показывает, что вершина терминальная.
И мы видим, что из этой вершины обязательно должны быть переходы по буквам А, Б и С, а других переходов быть не должно.
Так, ну давайте нарисуем.
Куда должен быть переход по букве А?
По букве А должен быть переход в состояние, из которого по терминальным вершинам можно зайти в какие слова?
Ну, во все слова, которые тут начинались в буквы А, только без этой первой буквы А.
Получается вот, из А получаем Эпсилон, из А получаем СА, тут получаем БАЦА и тут получаем БАБАЦА.
Так, неплохо.
Ну ладно, будем работать BFS.
Значит, еще тут должен быть переход по Б.
Оп.
Оп.
Так, так, так, так, так.
Значит, это у нас БАЦА.
БАЦА и БАБАЦА.
Значит, тут, соответственно, получается язык этого состояния АЦА и БАЦА получается.
Вот.
И буква С, которая нас отправляет, собственно, в язык, состоящий из слова А.
Обе эти вершины не терминальные, потому что в их языках нет Эпсилона, а вот тут и есть, поэтому тут терминальный.
Так.
Так, идем дальше.
Так, теперь смотрите.
Как-то тут сразу все начинает едва ли не схлопываться.
Потому что, смотрите, если мы пойдем отсюда по букве С, то мы перейдем в состояние, у которого язык это слово А.
Оно же есть.
Да, такой язык у нас есть.
Вот он.
Так, что еще?
А если перейти по...
Буква С.
Да, да.
А еще есть переход по букве Б, которая ведет нас вот в это состояние.
Опа.
Так, не понял.
Так, что я где забыл?
Ничего.
Прошли первые буквы.
А, да, все нормально, я ничего не забыл.
Просто тут еще два состояния остались, с ними все в порядке.
Так.
Ну, БФС так БФС.
Так, ну отсюда у нас есть переход.
Какой?
Ну, здесь так.
Если рисовать планарный граф, то получится так.
Можно здесь нарисовать переход по букве С.
Нет.
Ну, точнее так.
Тут пока вообще один переход есть по букве А.
И тут получается какой язык?
Ца и Бац.
Так.
Ну, здесь замечаем, что по букве С мы переходим автоматически сюда.
А по букве Б вот тут уже становится интереснее.
Тут, оказывается, язык Аца.
Не оттуда.
А, не оттуда.
Ну ладно, уйдите отсюда.
Ага.
Так, ладно.
Значит, смотри.
Б.
Значит, тут у нас переход.
Значит, Аца.
Ну и здесь, в общем-то, тут уже интриги никакой нет.
Да, что-то как-то неудачную строку.
Неудачная строка получилась, как видно.
А, в конце.
Я считаю, что вы можете...
Ну, да.
А и Ц.
Так.
А, ну и кое-что мы забыли.
Опа, еще одну терминальную вершину.
С языком Эпсилон.
Вот.
И сказать, что на этом все с вами были подписаны.
Вот.
Да.
Ну да, получилось что-то не самое удачное.
Не самое удачное в том плане...
Чего? Чего не так?
Ну да, на самом деле, да, я заметил, что мы тут, конечно, немножко вот так вот...
Ну что вы вы narисовали.
На самом деле, если правильно нарисовать, можно заметить, что это как бы...
Состояние, это просто мы проходимся по строке АББАЦА.
И еще какие-то там переходы между собой добавляем, на самом деле.
Вот, обратите внимание.
Ну, могут быть и альтернативные версии.
То есть, это явно не всегда так.
Потому что, на самом деле, может быть, какая-нибудь строка на скидку АББББ.
Ну давайте попробуем сразу. Ну, во-первых, понятно, что в состоянии вот переходы
вот эти АББББББББББББББББББББББББББББББББББББББББББ БББ БББ ББ ББ Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б Б
Бэб
Так, ну поехали.
Если мы делаем переход по букве А, то тут как бы этот процесс, язык явно схлопывается.
Получается ББББ.
Тут получается ББББ.
Ну есть еще переход по букве B, и вот тут он как бы чуть-чуть поумнее становится.
Что он делает? Так, какой язык я тут должен нарисовать?
да но именно до 5 не до 6 обротеть внимание
ну да здесь уже да в общем язык конечно намекает ничего больше не будет так 4 3 2
1 и внезапно боль вот такая неожиданная красота
б-б-б-б и эпсилом ровный за который у меня тут терминал ну тут уже б-б-б-б-б-эпсилом
соответственно б-б-б-эпсилом б-эпсилом и все да видите может быть даже подозрительно
показаться кажется что тут как бы две абсолютно одинаковые цепочки но нам
принципиально но как бы в суффиксном автомате нам принципиально что эти вершины
терминальный а эти нет и это единственная разница то есть в принципе можно заметить
что если бы у нас цель была построить автомат который принимает все под строте
они все суффиксы то тогда на самом деле то тогда на самом деле действительно мы
могли бы тогда эти цепочки тут так жественно объединить ничего не было
если обратить внимание то есть суффиксный автомат это минимальный автомат принимающий
именно суффиксы а не под строту вот так что вот такая вот неожиданная красота
но он не минимальный тут есть где-то одинаковые классы
ну точнее так автомат является минимальный мы термируем автомат является минимальным тогда
и только тогда когда во первых через любую вершину проходит путь от стартовой вершины
какой-то
и тогда собственно автомат получается не Fail.
Ну и наша механизм показывает что если вы правильно строить только те вершины
который мы вынуждены строить mio получается действительно минимальный автомат да
Да, согласен. Это просто скучно и вообще.
Да.
Можно просто, тут нельзя было
пойти при грубе один раз,
а потом пойти наверх,
без стрелочек нарисовать.
Куда наверх?
В верхние языки
там для просто бэшн.
Ну как сказать?
Ну нельзя было.
Ну как-то есть язык B-B-B-B, а есть язык H такой.
Это разная вещь.
Ну нельзя из левой нижней вершины
нарисовать шесть стрелок
в верхней вершине.
Шесть стрелок?
Да.
По какой букве?
Да, они будут тренированы.
А, ну в эпсилон, да, так-то можно было.
Поэтому мы и правильно.
Мы говорим про детерминированный автомат.
Ну потому что искать подстройки
в строке с помощью не детерминированного автомата
это DFS какой-то запускает.
Это нам не выше.
Вот. Значит, поехали.
Ну вот это мы поговорили
что это такое на уровне автомата.
А теперь поговорим
что это такое.
Попробуем поговорить на уровне строки.
Вот.
Но на самом деле
Вот.
Но на самом деле вот это вот красненькое
ну по-разному.
Для состояния это называется язык
а для подстроки
назовем правой контекст.
То есть на самом деле можно ввести такое
независимое определение.
Значит, пусть
у нас допустим
пусть у нас допустим
P под строка S.
Тогда
правым контекстом
и будем называть его там
R с индексом S от P
то есть под строки P
ну там
под строки P относительно S
он называется, да.
P относительно строки S.
Назовем
множество таких строк W
что PW
суффикс S.
Ну да.
Отсюда в данной ситуации
политологи рекомендуют.
Так.
Ну заметим, что почему я рисую
правый контекст и вот эти вот языки
состояний
одним и тем же цветом.
Ну, ровно потому, что
ну действительно.
То есть по большому счету
если P под строка S
то по ней вы в автомате должны пройти
ну не факт, что там в терминальную вершину
конечно, но должны пройти
и при этом попасть в вершину, у которой язык этой
вершины должен в точности
совпадать с тем, что мы называем правым контекстом.
Вот. Это что такое с точки зрения
автомата.
А с точки зрения
строки S это выглядит
следующим образом. То есть есть
под строка P. У нее есть несколько
вхождений.
Допустим, вот они.
Допустим, это вот под строка P
входит здесь, входит здесь.
А еще совершенно случайно здесь
вхождения могут пересекаться.
И тогда
ее правым контекстом
являются вот
такие
суффиксы.
Вот.
Вот.
Теперь мы говорили что-то
про классы эквивалентности, да?
Вот давайте
снова посмотрим, что такое
классы эквивалентности относительно именно здесь.
То есть, ну понятно, в
суффиксах в автомате понятно, мы говорили, что
строки эквивалентные, если мы по ним можем
пройти и прийти в один и тот же состояние,
правда?
Значит, теперь мы
что мы теперь тут скажем?
Так, тоже давайте
определение.
Скажем мы.
То есть, это называется
подстроен от P и Q.
P и Q
эквивалентны, будем
говорить, относительно строки
S,
если
их правые контексты
относительно строки S
совпадают.
Вот.
Вот.
Хорошо так?
Хорошо так?
Вот.
Вот действительно.
То есть, получается, видите, эквивалентность
можно выразить просто чисто в строковых
церквах, понимаете, да?
Вот понятно, что вот в автомате
и тут это одно и то же.
Но, когда мы смотрим
на это сюда,
то, ну вот, то есть, здесь
просто если нарисовать банально
что это такое, да?
Вот что это такое вообще у P и Q
одинаковый правый контекст?
Это означает, что
все вхождения строк
P и Q заканчиваются
в одних и тех же
позициях.
Логично, да?
Да.
Вот.
А отсюда, просто уже
в этой картинке
возникает первое утверждение.
Пусть
допустим вот
ну давайте пусть с отсылкой на картинку
допустим, да?
Пусть P эквивалентно Q
и соответственно
P длиннее Q.
Вот.
Тогда утверждаю
я.
Ну тогда я утверждаю, что Q
это суффикс
значит, во-первых, я утверждаю
Q это суффикс.
Во-первых, Q это
суффикс P.
Ну а просто из картинки очевидно,
правда?
Ну и во-вторых,
заметим еще следующее.
Все
суффиксы P
более, ну вот,
более длинные, чем Q.
Эквивалентный
P.
Ну просто логично, да?
Что если P их все
не утверждает,
то это
просто
логично, да?
Что если все вхождения P и Q
заканчиваются в этих позициях,
то, наверное, если я возьму какой-нибудь
более длинный суффикс,
то заметим, что
все его вхождения
находятся, ну во-первых,
так как он суффикс P,
то они здесь находятся,
а с другой стороны, так как
каждое из них еще и вхождение Q,
то получается, в других местах оно не находится.
То есть вообще заметим, да?
Если вы возьмете какую-нибудь под строку P
и будете отпиливать у нее по одному символу,
то некоторое время у вас вхождения будут те же,
а потом, например, те же вхождения
останутся, но появится еще
одну, ну или там несколько, да?
Ну два там, и так далее.
Когда вот так расширяется, то есть как бы множество
экстенсивно расширяется, то есть старые
окончания не исчезают, новые появляются.
Это вот полезно себе просто такую
картинку в голове иметь.
Вот.
Ну такое мистическое свойство
дает нам возможность ввести
понятие, там, ввести понятие
класс эквивалентности.
То есть так и записать. То есть определение.
Да?
То есть класс, ну вот,
то есть вот это вот P
с индексом S,
это класс эквивалентности.
Настепе
под, соответственно,
S.
Да, вот обратите внимание, я тут
индекс пишу, потому что класс эквивалентности
он разный.
Да, обратите внимание, ну вот,
ну конечно в ядном виде хренить этот класс эквивалентности
мы не будем, но такое понятие
введем.
Понятно, да?
То есть он описывает все
подстройки S, у которых
конечной позиции
Ну да, конечной позиции
те же, что и у P.
Да.
Вот.
Более того,
мы еще можем ввести,
давайте в том же определении
еще введем такое понятие,
как longest.
Вот так класс эквивалентности.
Это будет длиннейшее.
Шея строка
этого класса.
Да, как вы уже убедились,
она определяется однозначно.
Понимаете, да?
Вот.
И нам еще пригодится понятие
len.
Ну это просто
длина
longest, максимальная длина.
То есть не путать, да?
То есть разница будет в том, что
из этих трех понятий мы реально
в вершинах будем хранить len.
Ну понятно, в сами строки мы хранить
не будем, а вот их длину запросто.
Ну в общем-то, если мы суфистный автомат
откуда-то выкопаем, то в общем-то
по len потом восстановить
то есть в общем-то, если вы уже суфистный
автомат выкопали, то в общем-то и len,
а потом еще и восстанавливает longest,
в общем-то не сложно, правда?
Ну потому что, например, можно
для каждого состояния, например,
можно найти, скажем,
какую-нибудь самую короткую
строчку, которая через это состояние
проходит.
Как найти?
Нет, даже не самую короткую строчку,
а самый короткий суфикс.
Как найти? Да очень просто.
С помощью динамики для каждой вершины
можно найти корочайший путь истартовый.
Ну как?
Да, динамика называется BFS.
Но граф ициклический,
да, мистический факт.
Очевидно, что суфиксный автомат
обязан быть ициклическим графом, согласны?
Ну просто потому что у нас конечный язык.
Вот.
Вверх конечный язык, вот этот автомат
минимальный, потому что теоретически не минимальный
суфиксный автомат может быть циклическим,
но просто этот цикл может быть.
А во вторых еще можно
динамикой для каждой вершины написать
найти корочайший путь до терминальной,
правда?
И тогда комбинируете две строчки,
то есть эти два пути, получаем какой-то
суфикс, и вершина должна находиться
на какой-то позиции, соответственно получаем
какой под строке он соответствует.
В общем, можно найти корочайший путь отстартовый,
а можно найти длиннейший.
Ну потому что у нас наибраточная динамика,
но граф ициклический,
поэтому можно все.
Ну по факту этого не будет,
потому что реально мы при построении
будем поддерживать лент
и жестко им пользоваться.
Так что вот такие понятия.
Логист, конечно, механик не будет, класс эквалиптости
будем иметь в виду.
Вот, как же мы это будем делать?
Но для того, чтобы действительно
строить какой-то автомат,
ну как бы да, нам как бы надо строить,
и вообще попутно еще подумать, а зачем нам его строить?
Потому что вдруг выяснится,
что размер этого минимального автомата
это, там, я не знаю, квадрат.
Вот нельзя для условно обоцам
бы построить ничего принципиально лучше,
нежели борт.
Может же быть такое?
Ну, по камере, пока не очень.
Но для того, чтобы это стало понятно,
давайте подумаем вот о чем.
Давайте внимательно посмотрим
на этих логистов.
Кто они?
Какие подстроки являются
логистами своих класса эквалиптости?
Ну, это префиксы
для начала.
Сейчас.
Класса эквалиптости и все остальные
это суффиксы логистов.
Правильно.
У нас интересует такой, да,
но это для любой строки верни.
Ну, у любой строки, как бы да,
есть несколько ю-суффиксов эквалетные,
а еще есть кто-то, кто вернили.
Кто-то, кто вернили.
Ну, давайте, значит, смотрите.
Сейчас подумаем вот о чем.
Рассмотрим строчку.
И подумаем. Давайте так.
Какая строка, что означает,
что строка не является
логистом?
Вот такая строка P,
допустим, не является
логистом в своем классе эквалиптости.
Значит, слева от всех
храждений одинаковый символ? Да.
То есть, в принципе, это означает, что существует хотя бы на один символ
более длинная строка,
суффиксом, который является P, который эквалиптост.
То есть, который заканчивается на тени тут же.
Это означает,
что
перед всеми
храждениями
перед храждениями P, на самом деле,
находится один и тот же символ.
То есть, можно сформулировать так, что строка
не является логистом.
Ну, как минимум, если, во-первых,
то есть, для этого нужно,
чтобы, во-первых, P не была суффиксом,
то префиксом, обратите внимание, да?
А во-вторых, перед всеми
храждениями P были абсолютно отдельные символы.
Видите, да?
Это необходимо.
Но это и достаточно,
обратите внимание, правда?
Поэтому сейчас я эту лему,
то есть, на самом деле, лему можно
сформулировали не в ранг теория,
но это прям ключевая лемма,
на самом деле,
нот, которая нам даст все.
Она говорит нам следующее.
То есть, я ее сформулирую так.
Пусть у нас P под строка S.
Пусть P под строка S.
Так? Да.
Тогда что?
Тогда, смотрите,
P равно
является лонгестом,
ладно, синим потом допишу,
лонгестом в своем классике валентности.
Тогда и только тогда,
когда выполнено хотя бы одно,
то есть, следующее букву утверждений.
Второе утверждение
будет, значит,
P префикс S.
И второе,
в алфавите
существуют такие две
буковки.
Ну и что, давайте я на всякий случай
для педантов напишу,
что A не равно B.
Такие что?
A, P
и B, P
под строки S.
Ну, конечно,
правда.
Ну вот,
как бы, да,
казалось бы,
видите, мы ничего
мегаумного не заметили,
да, но чуть-чуть переформулировали
и уже выглядит
солидно.
О,
вот.
И тогда получается следующее.
Значит, теперь давайте подумаем вот о чем.
Значит, ну вот, если говорить про вот A, P
и B, P под строки S,
ну, то есть, вообще, вот, когда у нас
возникают подстроки и продолжение влево,
на самом деле, это может вызвать ассоциации
с построением суффиксного дерева,
только не для самой строки,
а для развертки.
То есть, тогда, по большому счету,
если мы строим суффиксное дерево для развертки
на строке S, то обратите внимание, что
тогда вот это утверждение означает,
что под строка P приходит вершина
с развилкой, правда?
Ну, у нас не все вершины,
ну вот.
Но, заметим, что
в суффиксном автомате это тоже
имеет отражение.
Вот, нам пришло время ввести
такое мистическое понятие, как
суффиксная ссылка.
Да, и снова с нами понятие
суффиксная ссылка.
Но на этот раз,
но сейчас это понятие будет вообще
никак не связанно ни с какими украинами
и там прочими карасиками.
Значит, определим.
Значит, пусть
у нас,
пусть у нас действительно
действительно P
под строка S.
П, не пустая
под строка S.
Не пустая под строка
S.
Тогда мы вводим понятие
суффиксная ссылка.
Суфф
от P
всегда.
Что же это такое?
Так вот.
Ну, даже суффиксную ссылку
будем вводить даже не от P,
а от класса
эквивалентности.
Ну, тут тоже,
тут суффикс можно писать,
S можно не писать,
он аналогично писать.
Значит, что это такое?
Ну, то есть ссылка класса
эквивалентности.
Это тоже класс эквивалентности.
Q
с индексом S.
Такой, что
Q
Q
Q, короче,
ну вот, суффикс,
можно не писать даже, что собственный,
суффикс P.
Значит, Q не эквивалентен
P
по S. И длина
Q максимально возможна.
Не эквивалентен.
Не эквивалентен.
Суфф
это класс эквивалентности.
Нет, ну да.
Ну или в переводе говорят,
что суффиксная ссылка
с точки зрения автомата, она ведет
из вершины в вершину.
Везде могу черные нарисовать.
Вот.
Значит, как-то,
чтобы понять, как выглядят суффиксные
ссылки, давайте, вот у нас есть
два примера автоматов, а вот давайте
посмотрим, вот каждая вершина соответствует
классу эквивалентности, да?
Вот давайте попробуем эти классы эквивалентности
изобразить. Вот, например,
у этой вершины, какой класс эквивалентности?
Да, совершенно верно.
Да, кстати, отсюда
такое есть приятное
мистическое устройство во всех строчках.
Класс эквивалентности ε равен
множеству из ε.
Ну, действительно, логично,
потому что, вот, кстати, да,
как-то чему равен правый контекст
ε?
Эпсилон?
Вот, там же, наверное, написано.
А шерть такое?
А в общем случае?
Все суффиксы.
Да, то есть, заметим, что
правым контекстом
эпсилона, нет, классом эквивалентности
эпсилон является эпсилон, а правым контекстом
эпсилоны является все суффиксы
от кустово до самой спрессы.
Оба раза ключи.
Вот, значит, идем дальше.
Так, ну, теперь
попробуем V-faces тоже.
Все мы сделали, вот, черный эпсилон
для вершины.
Это класс эквалентности
этой вершины.
То есть, мы помним, что...
То есть, слово.
Ну, да, то есть, я по большому счету...
Да, эпсилон это не в смысле пустой...
Да, пустое множество, оно вот так
в смысле. А эпсилон
пустое слово. Множество из пустого
слова и пустое множество, это разные вещи.
Так, топелька.
Ну, давайте
попробуем. То есть, заметим, с точки зрения автомата
класс эквалентности вершины, это
по каким строчкам мы в нее можем прийти,
по большому счету, правда?
Поэтому вот здесь у нас класс эквалентности, это
A. Здесь, вот
по этой вершине мы можем прийти отсюда,
можем прийти отсюда. Получается
молодое. B и AB.
Ну да. B и AB.
Так.
Так.
По этой вершине мы можем прийти только отсюда,
поэтому получается B, A
и A, B, A.
Так, что дальше?
Так, вот здесь становится
интереснее. Сюда можно прийти
по строкам BAB
и ABAB.
Сюда, соответственно,
BAB
и ABBA. И ABBA
нас ведут.
Теперь вот сюда объединяем.
Что у нас появляется?
Объединяем вот это и это,
и приписываем C. Получается
BATS, ABATS,
что еще там получается?
BABATS
и ABABATS.
Еще C было.
А просто C откуда?
И старый.
И старый?
Еще стрелочка.
Ой, а у нас еще...
А, ну да,
потому что мы еще забыли ATS
отсюда
и, собственно, C.
То есть, видите, да,
в классе квалицитета, наоборот, он под конец разгоняется.
Да, вот получается
C, A, C.
Ну и здесь, соответственно, уже
тесно перечисляем
все суффиксы, начиная
с третьего.
C, A, ATSA,
BATS, ABATS,
BABATS
и ABABATS.
Вот.
Там еще C, A.
C, A.
Прямо сразу
скучная стройка.
Вот здесь как-то повеселее.
А, ну здесь, в общем-то, да,
и писать удобнее.
Потому что, смотрите, здесь F,
здесь A, AB,
ABATS,
ABABB.
Ну здесь просто подстрок у этой строки мало.
Видите, состояние внука, зато подстрок
мало. ABABB.
И здесь вот идем сюда, получается
F, B,
B, B.
B, B, B.
В машине хватает.
B, B, B.
B, B, B, B.
И что еще? А, ну и тут всего
две строчки, да.
A, B, B, B, B.
B и B, B, B.
B, B, B.
Вот.
Да, видите, тут подстрочек много,
но они как-то удачно
скомпоновались.
Подстрочек мало, и там просто едва лиги
по одной максимуму распихались
по всем состояниям.
Вот.
Так что вот, интересное зрение.
Так, чему я это все вообще?
Так, мы начали с того, что мы определили
суффиксный ссылок. Вот давайте
попробуем порисовать.
А куда у нас, например, ведут
здесь суффиксные ссылки?
Вот, например, вот из этого состояния.
Куда у нас ведет суффиксная ссылка?
Вот из этого.
Вот берем абабацу и находим максимальный
ее суффикс, который не в этом классике валютности.
Но, очевидно, это суффикс A.
Поэтому
где у нас классик валютности с A?
Он, соответственно, вот здесь.
Так.
А куда суффиксная ссылка ведет отсюда?
Вот.
Тут тоже A есть.
Да, тут C, конечно.
Поэтому
так.
А отсюда
куда?
Да вот сюда.
Тут все так.
Тут что?
А
Б
А
А
Б
А
Б
И
А
Б
А
А
А
А
А ну и отсюда. Ну здесь у нас сопротивление бесполезное. Так, вот такая красота получается.
Так, а тут у нас это как будет выглядеть.
Ну тут проще когда-то. Все в старт выглядело.
Ну давайте выберем любую письму. Пойдем по А из стартовой.
Так, отсюда куда?
Отсюда идет в Б, то есть это будет вниз-влево.
Ну да.
Отсюда в Б-Б.
О, смотрите, да, тут такая красота получается.
Вот так, вот так. Ой, отсюда куда?
Отсюда в 5 Б, вот наизданных.
Да-да. А из этих Б куда идет?
Обратно от другого.
Ага, ну да, здесь вообще красота.
Какие обратные рёбра, вспомнили потом.
Так что вот можно хранить еще такой сутик, такие сутиксные сынки.
Ну, очевидно, что эти суфиксные сынки образуют, по большому счету, подвешенное дерево.
Причем не просто подвешенное дерево, а подвешенное дерево с корнем в стартовой вершине. Правда?
Да, просто потому что в рафоциклический и у каждой вершины есть куда вести суфиксные сынки, кроме стартовой.
Например, по этому. Этого уже достаточно, чтобы сказать, что это дерево.
Нет, дерево на суфиксных сынках нет.
Ну да. Сам автомат, конечно, деревом не является.
Но суфиксные сынки образуют подвешенное дерево с корнем стартовой вершины.
Это все, что я утверждаю.
Или в это не верится?
Нет, не очевидно.
Не очевидно?
Ну, утверждение такое. Заметим, что у нас есть у каждой вершины класс эквивалентности.
И суфиксная ссылка всегда ведет в класс эквивалентности со строго меньшей длиной лонгеста. Правда?
Да.
Значит, граф из суфиксных сынок, он ациклический.
Логично.
Из каждой вершины есть ребро, кроме стартовой.
Ну, следовательно, отсюда получается, что если вы будете идти из любой вершины, то просто рано или поздно дойдете до стартовой вершины.
Хорошо.
Больше нет.
Так что получается, здесь тоже можно говорить о дереве суфиксных сынов.
Причем у этого дерева есть маленькие приятные свойства.
Вот давайте посмотрим, что нам вот эта лемма говорит.
Эта лемма говорит о следующем.
Она говорит, что жила была вершина, допустим.
И теперь может быть какая-то вопрос.
Да, у нее может быть куда-то там суфиксные ссылки ведет, может это стартовая вершина.
А теперь внимание, вопрос.
А сколько у нее детей?
По суфиксам всегда.
Вот допустим, что это вот у нас класс эквивалентности P, причем тут P равно логисту этого класса эквивалентности.
Вот это вот типо P, да?
Тогда мы знаем вот что.
У нее два варианта.
Либо P это префикс S.
Либо у этого, это P это префикс С.
Либо у этого, это P можно продолжить влево двумя разными способами.
Хотя бы двумя.
Но заметим, что если эти два способа есть, то на самом деле из этих способов в P обязательно ведет суфиксная ссылка.
Обратите внимание.
Ну что, рассмотрим класс эквивалентности вот этого вот AP, да?
Так как P логисту, то P этому AP не эквивалентен.
Значит из этого класса эквивалентности суфиксная ссылка не эквивалентна.
То есть смотрите, то есть можно, видите, с другой стороны смотреть на самом деле на это.
То есть можно смотреть, что если мы расширяем подстроки влево, то как бы каждая суфиксная ссылка ведущая в P это как бы продолжение по какой-нибудь букве.
Понимаете, да?
То есть собственно это приводит нас к маленькой приятной вещи.
Вот.
То есть собственно это приводит нас к маленькой приятной вещи.
Что у очень, что у почти всех, ну что у большого количества вершин есть хотя бы два ребёнка.
Ну утверждение можно сформировать так.
Утверждение.
Утверждение.
То есть количество вершин с менее, не более чем одним ребёнком в дереве суфиксных ссылок,
в дереве суф, не превосходят, не превосходят чего?
Включать количество префиксов.
А сколько у нас префиксов?
Хотя бы N-1.
На S-1.
Ну да, можно сказать S-1.
Но я даже уточню.
Надо сказать S.
Я бы даже, ну вот.
Я бы даже так.
Не превосходит S, модуля S, если S не равно просто a в степени N.
Ну а в степени модуля в смысле.
Ну потому что заметим, что если у строки хотя бы два символа, то в корень ведёт как минимум две ссылочки.
Ну потому что заметим.
Сколько детей у стартовой вершины?
Ответ.
Ровно столько, сколько различных символов встречается в строке.
Логично, да?
Вот, поэтому если у нас S не равно a, то у стартовой вершины хотя бы два ребёнка есть.
Поэтому детей не более чем S.
Ну вот и, ну и соответственно, ну здесь уже не интересно, равно модуля S плюс один иначе.
Ну, кстати, на эту тему.
А давайте себе вообразим, как выглядит суффиксный автомат для строки A.
Как он выглядит?
Ну просто последовательность, типа a шага, а свинца на 1 назад.
Ну да, в полном соответствии с, действительно, названием.
Вот как-то так.
Вот как-то так.
Если у нас строка A.
И соответственно все вершины терминальны.
Терминал, терминал.
Ну и тупой вопрос суффиксной ссылки, как выглядит.
Назад через 1 шаг.
Прямо цепочкой.
Да, но это вот конкретно отдельный случай.
Но как это ни странно, через суффиксные ссылки мы пришли к важной мистической теории.
Если у нас строка равна a, то количество состояний в ней равно модуле S плюс один.
Ну теперь внимание, вопрос.
Если у вас есть дерево, в котором количество вершин с одним или менее вебетком не превосходит в модуле S.
А сколько в нем может быть вершин всего?
Наверное.
Логика очень простая. Как выглядит дерево?
У нас дерево в некоторых вершинах развитвляется.
Вот у нас есть корень, допустим он развитвился, у нас есть 2 вершины.
В каждой из них цепочка идет, идет, идет и тоже развитвляется.
Разветвляется, потом развитвляется и так далее.
То есть в итоге у нас каждая развилка увеличивает количество веточек хотя бы на одну.
А если там развилка тройная, то на две. Если четверная, то на три и так далее.
и так далее. Но в самом конце у нас на этих цепочечек должно быть n, получается, не более
чем n. Следовательно, развилок было не более чем n-1. То есть могло быть вот такое доказательство,
хотя, наверное, на дискогне вы сдавали что-то более строго индукционное. Не сдавали? А, ну ладно,
видимо, подразумевается, что это задачка на оценку 1.
Это можно просмотреть? Почему, доказали? Нет, мы его доказали. Почему? Потому что, откуда мы это взяли? Потому что
там доказательство такое. Рассмотрим вершину, рассмотрим ее логнист. Да? Да. Так, если у нее не двое детей,
значит P является ее префиксом S. Не двое, а в смысле один? Один или менее. И да. Это может быть только в том
случае, если P-префикс С. Ну да. Кстати, эти утверждения, думаю, не противоречат. Может быть и то, и то
одновременно. Вполне себе. Вот тем не менее. А, за примером даже далеко ходить не надо. А, ну вот, пожалуйста,
вот у вас был префикс А, видите, да? То есть А с одной стороны префикс, а с другой стороны двое детей у него есть.
Вот. Вот. Поэтому утверждения, ну, по префиксу у нас всего не более чем С, а мы еще и докрутили, что вообще
С плюс один, но, как бы, если хотя бы два символа есть, то тогда пустая класса квалифтости пустой строки имеет
хотя бы двух детей. Поэтому выкидываем. Поэтому следствие, мистическое следствие, я его только
напишу. Значит, если модуль С, если плена строки больше либо равно двух, больше либо равно, то размер,
только количество вершин дауг от С не превосходит два С минусы.
Неплохо.
Да, что-то как-то, да, знаете, что-то как-то тихой сапой даже получилось. То есть, знаете, тривиально, то есть типа простое
наблюдение, простое наблюдение, простое понятие, простое наблюдение. Опа! Автомат линейный.
Почему мы утверждаем еще раз, что нас равно С плюс один иначе?
Потому что иначе это строка С вот эта а-а-а-а-а-а и автомат выглядит вот так.
А, если С не равно, да, да, да, все нормально.
Да, именно не равно. То есть вот мы внезапно доказали, что количества вершин в автомате оказывается мало.
Два С минус один. В качестве сейчас еще одного такого, знаете, прикольного упражнения на понимание
вообще автомата, мы сейчас выведем еще. Мы выведем еще такое интересное утверждение,
так что из этого можно стереть. Господи, все так жалко стереть, если честно.
Впрочем, это и неважно. Ну ладно, сейчас будет на самом деле мелочевочка по этому плану.
Определение суффиксного автомата, наверное, мы уже выучили. Вот автомат хочется оставить.
Просто есть еще мистическое утверждение. Если С, модуль С больше либо равно два, то размер
даугат С прям равен два модуля С минус один, тогда и только тогда, когда С равно лежит в каком-то множестве.
Вот загадка. А что же это за мистические строчки, для которых периодически?
На высоких видах А, Б, Б, Б, Б, Б, Б. Чемой? Это откуда? Ну вот у нас, например... У вас на формалах был суффиксный автомат?
У нас было задача, докажите, что количество вершин в таком дереве не больше, чем два С минус один.
Мы это доказали очень странно. Вспользует суффиксный автомат, но странно.
Ну, по сути, когда это раньше выполняется, нам нужно, чтобы все вершины с не более чем одним ребенком были уже листьями, да?
Ну, да. То есть, чтобы не было вершин с ровно одним ребенком. Да, ну, во-первых, да. Во-первых, они... Ну, на самом деле, да.
Ну, и еще, чтобы все, чтобы детей было ровно, чтобы таких вершин было ровно С. То есть, чтобы все непустые префиксы были как раз...
Так, ну давайте рассмотрим. Ну, во-первых, так. Ну да. Есть такое, да.
Более своими классными вариантов. Ну, желательно, да. Что-то получается, да, чтобы... Смотрите. То есть, надо, то есть, желательно, да.
Ну, во-первых... Ну, давайте начнем с простого. Во-первых, нужно, чтобы развилок было ровно С-1. Заметим, что если у нас есть хотя бы одна тройная развилка, то развилок не более чем С-2, правда?
Тогда это означает, что, например, корень, корень явно является развилкой не более чем на 2. Ну, на самом деле, да. Поэтому сразу можно рассмотреть в случае. Давайте так.
То есть, теперь вопрос... То есть, из этого следует, что различных символов у нас в строке может быть не более чем 2. Логично, да? Не более чем 2.
Ну, если там всего один различный символ, то модуль С плюс один нас не интересует. Ну, потому что... Когда модуль С плюс один равен два модуль С минус один?
Ну, да. То есть, поэтому нам придется добавить сюда строку вида, там, допустим, АА.
Но, если брать, я думал вообще не написать, что модуля С больше чем два, чтобы было красивее. Ну, и так и быть, вот, слушайте. Я двойки рассматриваю, так и быть.
И теперь, если у нас символов больше чем один, то их должно быть ровно два. Ну, хотя бы два. Ну, а теперь следующее свойство.
То есть, у нас, точнее, должно быть ровно два символа, и при этом должно быть, что все префиксы, все состояния соответствующих префиксам, они являются листьями.
А что означает, что префикс является листом?
Это не период?
Нет, что ли?
Почему? Откуда у вас тут понятие период вообще период?
Значит, если из префикса...
Ой.
Что ни к одному префику слева нельзя добавить ничего.
Для каждого префикса, суфиксная ссылка ведет вопсилами.
То есть, обратите внимание, да.
Нет, правда, нет.
Нет. Это не то же самое.
Значит, суфиксная ссылка...
Значит, у него не меняются такие ссылки.
Да, а что значит, что в вершину не ведет суфиксную ссылку?
Значит, что нельзя продлить слева.
Да, то есть ни один префикс, ни к одному префиксу нельзя добавить слева символ, так, чтоб получился еще одна кастрада, правильно?
чтобы получилось по строка s. Понятно, о чем я говорю?
Нет.
Ну, давайте думать.
Смотрите, что такое суффиксная ссылка, ведущая в вершину p, где p это лонгест.
То есть, у нас ведет вершина вот отсюда, это означает, что к p можно прерисовать какой-то символ a и получить вот это состояние, правда?
Точнее, строку, лежащую в этом состоянии, да?
То есть, каждая суффиксная ссылка соответствует продолжению лонгеста на один символ влево, так, чтобы строка осталась под строкой, правда?
Так, чтобы это стало выкраской?
Нет, так, чтобы под строка осталась под строкой. Вот p была под строкой, да?
Да.
Так вот, вот эта суффиксная ссылка, так сказать, по символу a, означает, что ap это тоже под строка строки s.
Вот. Если две ведут, значит, как бы, таких продолжений два. Ну, если три, то три, четыре, четыре и так далее. Логично, да?
А что означает, что он больно?
Влево, ничего нельзя выписать.
Да. То есть, получается, строка не просто, но тогда что это означает?
Это означает, что под строка префикс, причем у нее единственное вхождение, это, собственно, в префиксе, правда?
А теперь, смотрите.
И это должно выполняться у всех суффиксов.
В том числе и у суффикса длины 1.
Вот, предположим, что этот суффикс имеет символ a без ограничения в обществе, да?
Тогда получается, что это под строка a больше нигде не встречается.
То есть, если она встречалась где-то, то тут суффиксная ссылка у этого префикса бы откровенно была.
Получается, ее нигде нет.
То есть, получается, что это за мистическая строка?
Получается, ее нигде нет.
То есть, получается, что это за мистическая строка?
У которой всего два различных символа, причем первый символ больше нигде не встречается.
A...
Вот.
То есть, соответственно, получается A...
И AB в степени получается K.
где a и b лежат в алфавите, а не равно b, естественно, и, соответственно, k – натуральное число.
Ну, натуральное, понятно, в русском смысле.
Что значит в русском смысле?
В русском смысле – да, потому что там, в какой-нибудь Европе, 0 – это натуральное число.
Да, вот такой сын.
И на формалке.
На формалке с Матлоги 0 тоже натуральное число.
Ну, значит, да. Значит, Матлоги исповедуют другую школу.
Ну, окей, ладно.
Ну, поэтому вот тут и говоримся.
Хотя тут уже, да, я, ладно, ладно, обычно я тут перестраховываюсь и тогда пишу z+.
Всё.
А ещё bb?
А, а – это символ, я понял.
Да, оно же bb.
Ну, понятно, что если кто-то пишет b, а разницы не будет.
Или там xzzzzzz.
А ещё я могу написать.
Вот.
Слушайте, красота.
Красота получается у нас такая.
Но, на самом деле, линейность этим даже не ограничивается.
Ну, что хорошо.
Состояние у нас линейное количество.
В общем, заметим, от размера алфавита, кстати, состоит количество состояний.
Вот такое ограничение не зависит никак.
Ну, что с ребрами?
Сколько же может быть ребр?
Ну, автомат.
Субъективный ссылок?
Не-не-не, ну, субъективный ссылок, понятно, не более, чем 2s-2.
Обычно?
Обычно, скажи так.
Ну, нам тоже же интересно, что, как бы, матчики, что у нас какую-то память жрут.
И спрашивают, сколько памяти они сожрут.
Там граф планарный, почему-то.
Значит, их не более, чем либо минус 6.
Ну.
Один был, да, конечно, два графа.
Неделька.
Я бы упоминал.
Кто упоминал?
Здесь, ну, вот, мы вот так строили.
Ну.
Здесь мы его, я бы сказал, мы рассмотрели три примера, и везде он получился планарным.
Да.
Ну, как бы, возможно, это случайное совпадение.
Но если тут про 3 и минус 6, я бы сказал, скажу, нет, у нас не будет такой.
Оценки мы докажем, что бывает получше.
То есть он не планарный?
Нет.
Хорошо.
Так что нет, да.
Так что не надо пользоваться планарным, да.
Не будет.
Планарность или планарный граф?
Хотя, да, это фильм, да.
Да, это фильм всегда.
Поэтому, да, очень важно.
Когда вы будете делать тесты на задачу с решением суффиксного автомата,
обязательно вставляйте тесты, где суффиксный автомат не планарен.
А то мало ли кто придумает решение,
в котором будет пользоваться тем, что суффиксный автомат планарен.
Нет, это же надо еще задачу такую придумать, чтобы так можно было.
Что бы желать ошибки неискусственные, типа, возьмите суффиксный автомат,
там, я не знаю, и сделайте что-нибудь там на нем, как на графе.
Так.
Ну, давайте думать.
Реально, а сколько тут ребер вообще?
Вот.
Ну, значит, это мы будем сделать так.
Значит, чтобы понять, сколько у нас ребер будет,
мы будем говорить так.
Смотрите.
Запустим DFS.
Только смотрите, у нас не стартовые вершины,
а из, так сказать, финишной.
Ну, заметим, что у нас в автомате всегда будет
ровно одна вершина, из которой ребер не торчит.
Ну, класс эквалидности и, соответственно, всей строки.
Он так и называется.
Да.
А теперь смотрите.
Ну, заметим, что до этой вершины можно найти из всех вершин.
Ну, доказательств очень простые.
Из каждой вершины давайте будем в тупую уйти до тех пор,
пока не упрёмся в тупик.
А это единственный тупик.
Ну, потому что, если бы было два тупика, то, наверное,
либо один из этих тупиков не терминальный, мы бы его вытянули просто,
либо эти два терминальных, казались бы, все терминальные тупики – это эквивалидные вершины.
Да.
Вот.
Вот, видите, то есть типичная математика.
То есть, видите, ничего сложного, но умные фразы уже появляются.
Можно как всегда.
Так вот.
Поэтому можно запустить, так сказать, ДФС по обратным ребрам.
Вот.
Ну, примерно так это будет выглядеть.
Вот.
Вот тут где-то стартовая вершина вот эта будет.
Вот.
Ну, заметим, что в это дерево ДФС по обратным ребрам войдёт.
Сколько ребра?
Не более чем два модулес минус два.
Логично, да?
Ну, если вершин всего не более чем два с минус один, то, наверное, и в дереве ребра не более чем два с минус два, правда?
Вот.
Так вот.
Но в автомате, естественно, есть и другие ребра, которые в этот ДФС не вошли.
Вот.
Но заметим теперь следующее.
Рассмотрим, что происходит.
Вот.
Но заметим теперь следующее.
Рассмотрим каждое такое ребро.
Вот, допустим.
Так вот.
Каждому ребру, ну, заметим, что до каждой вершины можно дойти из стартовой вершины, правда?
Поэтому идея такая.
Вот, допустим, мы тут как-нибудь можем дойти.
Вот так, вот так, вот так.
Вот так, вот так, вот так.
Я так обалдусь.
Не обязательно по оттоку черным ребрам.
Эти тоже можно использовать, пожалуйста.
Вот.
Так вот.
Я поверю, что каждому такому ребру можно поставить в соответствие вот такого рода путь.
Смотрите.
Значит, путь, он будет состоять, он как угодно доходит до этой вершины, проходит по этому ребру.
А дальше, обратите внимание, идет...
Строго по этому дереву ДФСа.
Я запутался.
Мы пустили ДФС из финишной.
Ну, смотрите.
Теперь я каждому ребру, не вошедшему дереву ДФС, сопоставляю путь, который из эпсилона, ну, из стартовой вершины в тубик, который проходит через это ребро.
Причем после этого ребра он ведет строго по дереву ДФС.
Доет, но как угодно.
Да.
Да, хорошо.
Тогда заметим следующее.
Что мы различным черным ребром поставили в соответствие различные пути, правда?
Ну, потому что каждый путь задается по каждому пути.
Можно посмотреть, по какому ребру мы его построили.
Это последнее черное ребро на пути, правда?
Да.
А еще можно заметить, что чем, что такое строка соответствующей этому пути?
Это относится к словам, в которых одинаковый суффис.
Чего?
Что строка этому нужен?
А, строка пути.
Ладно.
Что же это за строка такая?
Окачивается некоторый...
Ну, мы хотим сказать, что у каждого решина, наверное, указывается параметр степь.
Поэтому...
Пусть черное ребро входит в решину У.
Тогда...
Пусть каждый классик ролевый степь входит куда?
Ну, у нас в последствии черное ребро, ребро в котором мы построили, разрезует то, что мы...
Нашли новый классик уремности подобный.
Чего?
Почему?
У черного ребра могут входить и в одну и ту же вершину.
Я спрашиваю не что такое ребро, а чем является строка, которая у нас тут.
Вот что это за строка?
Что такое строка, по которой мы прошли стартовые вершины в тупе?
Что про нее можно сказать?
Совершенно верно.
Причем, можно даже более сильно сказать это суффикс строки С, эквивалентный самой строки С.
Но это нам сейчас пока даже не надо.
Хотя вот можем учесть, что это суффикс строки С, который больше нигде, кроме как в конце строки С, не встречается.
Но это же неважно.
А важно другое.
А сколько у нас таких суффиксов?
Их не более чем модуль С.
Потому что не пустой суффикс строки С.
Их не более чем модуль С.
Правда?
Не пустой суффикс строки С.
Их не более чем модуль С.
Но при этом заметим, что один из таких суффиксов, по одному из таких суффиксов, уже ДФС дошел до стартовых вершин.
Поэтому получается, что отсюда следует, что получается вот этих черных ребр не более чем модуль С-1.
То есть поэтому возникает сразу естественное утверждение, что действительно если модуль С больше либо равно 2, то размер, так сказать, количество вершин, то есть количество ребр не превосходит 3 модуль С-3.
Причем...
А мы тут сделали очень грубую оценку, да?
Ну почему?
Просто различные суффиксы не более чем С.
Каждый такой путь черная вершина.
Ну давайте вот...
А давайте думать просто.
Давайте думать, насколько центр эта груба.
Причем давайте говорить, что модуль Е да угод С равно 3 модуль С-3 тогда и только тогда, когда С лежит.
И вот теперь давайте думать.
А что это за мистическая строка должна быть?
Ну во-первых начнем с того, что в ней прям жестко должно быть 2С-1 вершин.
Правда?
Должно быть?
Что? Откуда? Ну нет.
Это же просто строка С какая-то.
А, причем я понял.
Ну просто смотрите, то есть помните у нас синий ребр ровно количество вершин минус 1 и еще не более чем модуль С-1 черный ребр, да?
Да.
Тогда чтобы 3С-3 достигалось надо чтобы синий ребр был 2С-2.
Ну тогда и вершин должно быть 2С-1.
Тогда получается у нас...
Ну вот тогда у нас получается что...
Что у нас получается?
Это же самое, что С это либо А, либо...
Ну то есть С...
То есть необходимое условие, что С лежит где-то в этом росте.
Ну давайте проверять АА нам подходит? Сколько ребр в автомате АА?
Хорошо.
Это два.
Ну два, вот просто. Автомата А, вот на самом деле вот эти два ребра не счастливые.
Поэтому АА нам не подходит.
Сколько у нас ребр будет в АВ степени К?
Ну в принципе вот пример уже был, да?
То есть заметим, что здесь у нас...
Сколько у нас ребра?
Ну да, то есть здесь ребр будет получается 2К-1.
А в каких случаях тогда это...
3 модуль С минус 3.
Ведь что такое С?
Это равно...
Ну вот 3К, короче, можно писать.
Потому что модуль С это К плюс 1, правда?
Понимаете, да?
Модуль С К плюс 1.
Да, да, согласен.
Ну да.
Но это эквивалент на тому, что К равно 1.
К плюс 1 равно 3К, правда?
Да.
То есть получается 3С-3 достигается только в одном случае.
Когда С равно АВ.
То есть да, мораль 3С-3 это неточная оценка.
Ну точнее так вот.
Пример, конечно, есть.
Но видите, он как бы не распространяется.
То есть следствие такое.
Если модуль С больше либо равно 3,
то модуль Е даунг от С
меньше либо равен даже 3 модуль С минус 4.
Вот.
Причем...
А вот давайте теперь вот прежде чем пойдем на перерыв подумаем.
Е даунг от С равно 3 модуль С минус 4.
Тогда и только так.
А когда С равно...
Вот теперь давайте реально подумаем.
А что это должна быть за строка?
Вот 3С-3 у нас не получилось.
Заметим, что...
Ну заметим, что сколько вершин в этом автомате может быть?
Ну хотя бы 2С-2.
Да, хотя бы 2С-2.
Ну потому что если 2 там...
Нет, почему?
Сейчас.
Ну да, хотя получается да.
Или этого уже все?
Нет, ну как всякие.
Ну вершин действительно хотя бы 2С-2.
Потому что если вершин 2С-3, например, да,
то синих ребер у нас получается 2С-4.
И добавляем черных коих не более чем С-1,
получается 3С-5 мало, правильно?
То есть вершин должно быть хотя бы 2С-2.
Но при С-3 вершин 2С-1 быть не может,
мы поняли, что этого не хватает.
Отлично.
Значит, вершин должно быть 2С-2.
Так, ну давайте думать.
Вершин 2С-2.
Но при этом, если...
Вот, если вершин 2С-2, то мы замечаем, что...
Вот, вершин 2С-2 и получается, что...
что черный ребер должен быть ровно С-1.
Видите, да?
Что это означает?
Ну, что их должно...
Ну вот.
Раз их С-1, это означает, обратите внимание,
что все, что как бы получается,
то есть на самом деле все не пустые суффиксы на самом деле проходят сюда.
Потому что сюда приходит аж С-суффиксов.
То есть вот этот синий и еще С-1 черный, правда?
А теперь смотрите, а что это за мистическая такая ситуация,
когда у вас все суффиксы эквивалентны самой строке С?
Что это за мистическая ситуация?
Что это за мистическая ситуация?
Получается, что последние символы строки вообще больше не встречаются.
Да.
Действительно.
То есть если мы хотим, чтобы суффиксы с последнего символа тоже были эквивалентны на этой строке,
то получается, мы вынуждены заключить, что он больше нигде не встречается.
Потому что, иначе у него было бы больше, чем оно вхождение.
Подключается к третьей С.
Так, неплохо.
То есть смотрите, то есть у нас есть...
То есть имеется в виду какая-то строка, у которой вот есть последний символ,
назовем его С,
и он больше нигде не встречается.
Так, это необходимо и достаточно, чтобы заявлять, что в черных рыбах С-1, да?
Так, а теперь давайте думать, что же должна быть строчка?
То есть какие у нас должны быть послабления?
Такие, чтобы у строчки, получается, количество состояний было 2С-1 или 2С-2.
При этом, обратите внимание, последний символ не повторялся.
Но, видимо, если мы берем последний символ, то получится строчка как раз из первого труждения,
из самого верхнего, что у него будет 2 на 1-1.
Почему?
Потому что добавление последнего символа добавляет только одно новое состояние картины.
Почему?
Ну, как-то да, но и что? Что значит добавление?
Ну, значит, что еще взять строку без последнего символа, то у него будет на одном состоянии меньше.
Ну, да.
Ну, там такое. Не факт, на самом деле.
Хотя нет, факт.
Там, знаете, надо тогда доказывать, что для строки без последнего символа автомат там действительно не поменяется.
Хочется пока это же их делать.
Нет, вот мы выяснили, да, смотрите, что у нас за строки, у которых состояние 2С-1?
Мы выяснили, что это только такие строки, и больше они никакие нам не подходят.
А теперь давайте вспомним, откуда мы так мыслили?
Ну, мы мыслили, что у нас префиксы, во-первых.
Что там для того, чтобы было 2С-1, надо чтобы, получается, надо чтобы префиксы все вели в листья, то есть никакой префикс нигде не встречался, правда?
Было дело?
Вот. И отсюда мы вывели, что это должно быть вот А на БВБ.
А, ну еще нам надо было, чтобы там...
Ну, еще там выяснилось, что вот А, А, А, А нам все не подходят, поэтому получается корень тоже развилкой, нам надо было, чтобы там было движение.
А, ну можно так сказать, если у нас всего два разных символа в строке, то это будет, типа, АС и Ми будет очень малая ребра.
А вот давайте, кстати, подумаем, да, вот сколько символов может быть?
Ну, как минимум, один символ, ну, этот символ больше не повторяется.
Но если там кроме нее только один символ, то есть вот если вот ААААС, то давайте подумаем, сколько состояния, сколько ребр будет в ААААС?
Модуля с плюс один, кажется.
Ну да, то есть если у вас строка А в степени КС, то там как это будет выглядеть?
Ну, во-первых, вся вот эта цепочка, да, ААААА, да, и тут вот С еще, да, вот такая вот АААА, АААА, вот.
И при этом еще верно, что из всех вершин еще есть переход по символу С.
Ну и сколько тут получается?
Регерд 2К.
Получается, да, тут...
Кажется.
Сейчас. Нет, почему? Значит, АС у нас К.
2К плюс один.
С под С значит К плюс один, плюс, и сколько у нас еще переходов по С?
Их получается, ну сколько там получается? Тоже К плюс один.
Нет, реально, смотрите.
Вот этих вот вершин.
А, потому что вот это вот не считается, да.
А этих К.
Получается, что 2К плюс один.
Так, 2К плюс один versus...
Ну то есть, да, 2К плюс один, это что такое?
2С плюс один.
Два модуля С.
Минус один.
Чего?
Да.
Ну плюс С это К плюс один.
То есть, мы получили еще какие-то строчки, у которых количество составит...
А, количество геобер.
Ну, а это равно 3С минус 4, когда С равно 3.
Ну да.
Отлично.
Ну да, то есть это равно 3С минус 4, когда С равно 3.
То есть, получается, что если мы рассматриваем АС, то получается, значит...
Получается АС, соответственно.
Но если мы хотим большей длины, то у нас проблема.
Ну теперь, смотрите.
Тогда получается, что у нас...
Строчки, если хотим длины 3, там длины больше 3, то получается, что нам должны быть 3 различных символов, правда?
То есть, в коре тройная развилка.
А это уже значит, что все остальные префиксы больше не встречаются.
Значит, на первых символах только один.
Значит, префиксы больше жестко не встречаются.
Так что мы вынуждены заключить, что тут...
Значит, дальше будет АВ в степени КС.
Значит, соответственно, АВ и СА.
Значит, А не равно В, не равно С, не равно А.
И, соответственно, то это К.
Да, красота.
Осталось только придумать задачу, в которой можно скатиться.
В смысле, что в автомате в решении более чем 3 Ка плюс 7.
В контресе плюс 7, то решение тупое.
А в противном случае рассмотрим следующий.
А для АВ в КТЦ у нас сколько будет ВВ?
А, ой, действительно.
Это же получается, что мы написали необходимую, что ли?
Ну ладно.
В качестве упражнения остается проверить, что эту подходит.
Так.
Почему в качестве упражнения?
В качестве упражнения?
Потому что, я думаю, да.
Пришло время, наверное, перелетчику строить.
Или не хотите?
Да, давайте сейчас.
Да, давайте.
Нет, ну я думаю, да.
Прежде чем совершить последний матч-бросок
и, собственно, это теперь за линию еще и построить.
Но вопрос вот тут.
Про черные ребра.
Поэтому мы их висели ДФС, нашли дерево ДФС.
Дэйвилл говорил, что количество черных ребр не более чем С-1.
Да.
Ну потому что, по сути, каждому из них соответствует...
Какой-то суффикс.
Суффикс.
Ну какой-то непустой суффикс.
Даже из класса эквалентности вот этого.
А почему еще раз?
Потому что мы ему ставим в соответствии такой суффикс.
А как?
Ну, если рассматриваем путь,
рассматриваем путь из стартовой вершины в ту вершину через это ребро.
Причем путь строим таким образом, чтобы после этого ребра путь шел строго под дерево ДФС.
Это гарантирует нам, что для разных черных ребров пути будут различны.
Да, мы его так считаем, да.
Так, ну мы вот, в общем-то, изучили.
Соответственно, даже достаточно устройства автомата.
Теперь остается сделать еще пару шагов и получить еще алгоритм,
как строить, действительно, этот автомат за линию.
Вот.
А попутно, может быть, еще что-нибудь про него понять.
Ну, если там останется время.
Значит, смотри.
Строить автомат, мы, как это ни странно, будем абсолютно тем же способом,
ну, пока я не говорил, идейно, как и суффиксное дерево.
В каком плане?
Тем же способом.
У нас снова будет какая-то пустая строка, в которой мы будем дописывать символы по одному
и модифицировать автомат.
Понятная идея, да?
Вот.
Поэтому основное, что для нас будет интересовать, это следующее.
Вот, предположим, мы к строке S приписываем символ C.
Как поменяются автоматы?
Как они поменяются?
Ну, во-первых,
ну, начнем с простого утверждения.
Если x равно longest относительно x относительно строки S,
то, очевидно,
относительно S, он тоже будет longest, по вон той уже имеемой модели, правда?
Ну, или что то же самое.
Если какая-то строка под строка S стала longest,
то в процессе добавления новых символов она останется longest,
на всякий случай.
То есть, если мы будем дописывать символы по одному и модифицировать автомат,
то в процессе добавления новых символов она останется longestов навсегда.
Логично, да?
Вот, по сути, что это утверждение значит.
Давайте я еще вот так вот сотру.
Ну, действительно.
Ну, просто вот из этого утверждения очевидно, что, да, то есть,
строка является longest тогда, это тогда, когда выполнено оба еще утверждения.
Видно, что если хотя бы одно из этих утверждений стало выполнено,
то оно теперь выполнено навсегда, правда?
Разве что, разница будет в том, что эти продолжения может количество увеличиваться,
но меньше двух уже не станет.
Поэтому нам теперь даже интересно кое-что больше.
Вот даже более такое культовое утверждение сейчас будет.
Пусть
x
Значит, давайте так.
Значит, x
равно longest в ССС
тогда, только тогда,
когда выполнено одно из следующих утверждений.
Ну, первое очевидно.
x
longest от x
в ССС
Ну, а теперь подумаем.
А какие мистические подстроки?
А что же это вообще теперь, давайте подумаем.
Вот здесь мы должны перечислить мистические подстроки
у строки ССС, которые
ну вот, которые не являются longest-ами в строке ССС.
Что это за строки?
Это швейк ССС.
Почему?
Ну, если они не содержат последней силы, то они играются в строке ССС.
Эээ, и что?
Сейчас.
Вот тут надо куда?
Ну, они либо субексы, да, и ССС.
А если они не являются, то их как бы, их
набор обхождения не поменялся на концовках последней.
А если они стали longest-ами, значит,
ну, типа, субекс
элемент на один больше его классик валяности перестал быть его классик валяности.
То есть, у него
ну, это просто невозможно.
Ну, это просто невозможно.
Ну, да, вот сейчас мы докрутим.
Давайте начнем вот с чего.
Начнем с того, что под строка Х, вот это, она может быть под строкой С,
а может не быть.
А давайте подумаем.
А что это за строки такие, которые являются под строками СС, но не являются под строками СС?
Субексы ССС.
Все?
Да, ну, они должны быть суфиксами ССС,
но они должны быть суфиксами ССС.
Да, ну, они должны быть суфиксами ССС, но это не все суфиксы.
А на самом деле это класс эквивалентности СС.
В автомате по СС, правильно?
Это в точности те строки,
у которых в рождении ровно одно.
Вот.
Но, очевидно, из них логистом является кто?
Ну, да. Поэтому мы здесь и пишем.
ХСС. Х равно ССС.
А вот теперь начинаем думать.
Теперь, значит, нам нужно найти такую строку Х,
которая является под строкой С.
Но при этом, обратите внимание,
в СС она логистом не была,
а в СС, опа, неожиданно стала.
Внимание, вопрос.
Что это?
Что же это такая мстика?
То есть жила-была вот какая-то подстрока мистическая,
и у нее было вхождение.
То есть, видите, даже, может быть, несколько вхождений было.
Давайте поменьше вхождение буду рисовать.
Причем обратите внимание,
до, то есть, ну, обратите внимание,
логистом она не была.
Она не была.
Она не была.
Она не была.
То есть, обратите внимание,
логистом она не была.
То есть, претиксом строки С она не является.
Правда?
Претиксом не является,
и перед всеми ее вхождениями стоит один и тот же символ Х.
Да, и в конце тут везде ССС.
Но тут, неожиданно выясняется,
неожиданно выясняется, что вот здесь, конкретно здесь,
стоит другой символ.
То есть, получается, если я назову эту строку, допустим, С0,
то получается интересный факт.
С0 является, это такой суффикс СС, который является под строкой С.
Но при этом, при этом самый, чуть больший суффикс строки СС
под строкой строки С уже не является.
Поэтому внезапно мы здесь пишем, Х равно С0.
Где С0?
Это максимально, но это длиннейший суффикс СС,
СС, являющийся под строкой С.
Вот такое интересное утверждение.
Вот.
Кстати, это утверждение является еще одним доказательством того,
что количество состояний в суффиксном автомате не превосходит 2С-1.
Потому что количество лонгестов с добавлением одного символа
увеличивается на не более чем два, обратите внимание.
Неплохо, правда?
Видите?
Вот.
Можно еще раз утверждение доказать, что я не логист.
Или хотя бы случай, когда мы разыграем.
Значит, поехали.
Так, ну давайте смотреть.
Итак, давайте, кто может быть лонгестом в СС?
Ну, во-первых, если эта строка не является даже под строкой СС,
то мы выяснили, что все эти строки это суффикс СС
и несколько чуть более коротких суффиксов, которые не встречаются в СС.
И они все в одном классе приводительности СС лежат, правда?
Ну, то есть...
Ну, то и да.
Нет.
Утверждение.
Сейчас будет очень тупое утверждение, но будет очень умно звучать.
Все подстроки строки СС, не являющиеся подстроками строки С,
лежат в одном классе эквивалентности относительно СС.
Да.
Он является, ну, СС.
Да, это в классе эквивалентности строки СС.
И он состоит из строки СС и нескольких еще чуть более коротких суффиксов,
которые не встречаются в СС подстройке.
Да, вот.
Отлично.
И это какой случай?
Второй.
Хорошо.
Теперь мы рассматриваем случаи, когда Х это под строка С.
Тогда у нас два варианта.
Либо она уже была лонгестом.
Либо это такая мистическая строка Х,
которая в С лонгестом не была, а в С неожиданно стала.
И тут мы рассуждаем, что это строка.
Ну, начнем с того, что это суффикс.
Ну, очевидно, что значит, что она не была лонгестом?
Это значит, что в С не была префиксом,
и перед всеми ее вхождениями стоял один и тот же символик.
Как тогда может быть, что с добавлением С она неожиданно стала лонгестом?
Ну, префиксом строки С она от этого не стала.
Следовательно, у нее должно появиться второй символ перед ней.
Значит, получается, С0 было в конце, и перед ним стоит символ отличный от X.
Тогда получается, что это С0 суффикс СС, который входит в С как под строка.
Причем, если я добавлю к нему этот символ перед ним,
то этот суффикс уже как под строка в С не входит.
Да, и это третий случай?
И это в точности третий случай.
Но там нет дополнительного условия.
Какого?
Что если добавить, ну, что если добавить Y, то он не входит в С.
Но нет, он Y может сам по себе как символ входить в С.
Но суффикс еще и с Y не входит в С.
Это не обязательно, потому что заметим, что эта строка,
вот эта строка, длиннейшая суффикс, являющаяся под строкой С,
она по-любому является лонгестом СС.
Независимо от того, входит ли игрок С0 как под строка или нет.
А, хотя нет, игрок С0 по-любому не входит.
Потому что С0 – это длиннейший суффикс СС, являющийся под строкой С.
То есть это по определению означает, что игрок С0 по-любому не входит.
Да, могло быть так, что тут уже игроков тут нет,
но тут какие-то Z и X тут уже могли быть,
но это означает, что просто первый и третий случай сошлись вместе.
И более того, кстати, что приятно, в строке СС на самом деле,
в строке СС на самом деле, обратите внимание,
то есть будет уже видно так, у нас будет состояние вот этого,
обязательно СС, и из него обязательно будет вести суффиксная ссылка в состояние С0.
Прямо вот обязательно.
А теперь давайте вот что думаем.
А теперь надо подумать, какие состояния будем создавать.
Ну, заметим, что состояние фактически эквиваленты логистам, правда?
Каждому логисту по состоянию, каждому состоянию по логисту, правда?
Состояние график, класс эквалентности, он за логистом.
Ну да, ну как бы каждому состоянию в графе соответствует логист.
Поэтому можно сделать вывод следующий, что у нас, когда мы заменяем С на СС, что может произойти?
Ну, во-первых, все старые логисты сохраняются, и все состояния между ними мы сохраним.
Но при этом добавится, во-первых, состояние на СС,
и, в-третьих, что самое главное, обязательно мы должны проследить, что логистом должно стать вот эта штука.
Что это значит?
Ну тут два варианта, либо она уже была логистом, и тогда нового состояния здесь не появится,
либо она логистом не была, и тогда...
А что дальше?
А тогда вот что. Это означает, что у нас в строке С было мистическое состояние,
у которого был класс эквалентности в лице нескольких строчек,
и одной из них была строка неожиданно С0.
Еще в не логистом, обратите внимание, да?
А теперь, бах-бах, ничего не поменялось.
Все подстроки строки С сохранили свои статусы, то есть логист остался логистом, не логист остался не логистом,
окромя С0.
С0 неожиданно не был логистом, теперь объявился.
Ну что это означает?
Это означает, то есть в этом случае мы вынуждены заключить, что у нас теперь есть две,
из этой одной вершины у нас получилось две вершины.
Одна отвечает за вот эти более длинные строчки, две, а вот эта отвечает за С0 и все остальное.
Что же отчего это нас приводит?
Остается только один маленький вопрос.
Как же нам будет отличать один случай от другого?
Ну мы сейчас пока временно забьем на вопрос о том, откуда мы будем выкапывать ребра.
Ну давайте предположим, что как бы нам главное построить правильные вершины,
а ребра и допустим суффиксные ссылки нам будут присылать с небес по факсу.
Ну как всегда, пока с небес по факсу, потом небеса и факс мы как всегда,
сначала изобретем факс, потом изобретем небеса.
Или наоборот порядок 35.
Так вот.
Ну давайте подумаем вот о чем.
А как вообще понять, хотя бы теоретически?
Предположим, внимание, сразу скажу, уровень алгоритма такой.
Так, ну думаю вот эти базовые определения можно будет стирать, да?
Ну вот эти я, вот эти я, пожалуй, не буду стирать, но я думаю там совсем...
Тем более, там на языке правых контекстов мы, наверное, уже и говорите и будем.
Как говорится, они уже сделают свое дело и могут ухудить.
Ой.
Ого.
Да, что-то вот эта губка как-то лучше работает.
Да?
Это следы не оставляет.
Да?
Да?
Это оставляет маркер.
Ага.
Ну надо это стирать до самого края.
Да-да-да.
Да, то есть это подмести еще.
А как же это сделать?
Ну как же это сделать?
Ну как же это сделать?
Ну как же это сделать?
Да-да-да.
Да, то есть это подмести еще.
Да-да-да.
Ну давай сюда.
Ну ничего.
Да нет, нормально.
Ну вот нормально.
Как говорится, да.
У вас как бы да.
Ну как бы да.
Ну да, любишь мыть полы любикудные.
Да я теперь нужно ее поставить сверху, чтобы не было...
Да-да.
Ну, все это, конечно, можно, да.
Ну давайте.
Идеально.
Ой, красота.
Так вот.
Значит, ну давайте начнем вот с чего.
Значит, как же мы будем сродиться с автоматом?
Вот даже.
Ну, как всегда, начнем реализацию с того, значит, состояния.
Стракт.
Как мы назовем состояние?
Ноги.
Ну естественно.
Ну не в стейджи, действительно, да.
Ну.
Ну естественно, да.
Так.
Ну, что тут у нас есть?
Так.
Ну, во-первых, у нас есть какие-нибудь ребра.
Давайте, как всегда, в мапочке.
Так.
Как здесь переходы называются?
Убекская.
Ладно.
Go.
Угу.
Так.
Значит, это было ноде.
Что нам еще потребуется?
Так.
Но нам еще не помешает такая техническая переменная лента самая.
И суф.
Ну, она же линка.
Она же вообще.
Все.
Ну, вы уже догадываетесь, да, что суфт на автомат.
Ну, конечно, будем в конечках.
То есть где-то так ноде.
Ну, соответственно, лодис.
Ну.
Ну.
Ну.
Ну, соответственно, лодис.
А, ну ладно.
Где-то там потом когда-нибудь.
Значит, еще надо.
Важно обратить внимание.
Нам еще потребуется хранить булифлаг, типа, не является этой вершиной терминальной.
Да.
Важная оговорка.
Когда я говорил, что мы будем строить по автомату С, автомату СС модифицировать, мы будем устроить прям предельно честно, но по модулю того, что мы не будем достраивать терминальные вершины.
Ну, потому что заметим, да, что там терминальные вершины иногда-то будут меняться очень сильно.
То есть там просто там n выключаться, n включаться.
Ну, на самом деле, мы заметим, что в самом-самом-самом конце, на самом деле, если мы уже насчитали лену и суффиксные ссылки, то насчитать терминальные вершины, если надо. Очень просто.
Как это сделать?
Вот, кстати, давайте так.
Такое воспоминание того, что такое суффиксная ссылка.
Вот дан автомат, все, лены построены, суффы построены, гоу построены, осталось только понять, кто терминальная вершина.
Ну просто от всей строки по суффиксным ссылкам.
Ну да. Ну, на самом деле, этого даже не нужно, потому что, забегая вперед, скажу, что мы в каждый момент времени будем сохранить вот это вот состояние, соответствующие полной строке.
Да.
Совершенно верно.
То есть, действительно, то есть, на самом деле, там в конце надо просто взять это состояние s и, собственно, из него по суффиксным ссылкам до корня пробежаться.
Ну, корень в смысле стартовая вершина.
Это в смысле старта, да, а это в смысле.
Вот.
То есть, ну действительно, заметим, что тут это соответствует всей строке s и нескольким и суффиксам.
Суффиксная ссылка соответствует некоторым следующим, тут еще следующим, ну и так далее.
Это я просто нарисовал, что, как бы, если мы пойдем, возьмем эту стоковую вершину и пройдем из нее по всем суффиксам, то мы пройдем в точности по всем вершинам, которые должны быть терминальными.
Или что то же самое, в точности по всем вершинам, классами эквивалентности которых являются суффиксы строки s.
Стокова это...
Из которой нет ребра.
То есть, последняя.
Да. Она же класс эквивалентности самой строки s.
Содержащей саму строку s.
Да, и мы хотим от нее пойти...
Да, по суффиксам.
Хотим по суффиксам, просто по суффиксным ссылкам.
А, по суффиксным ссылкам.
И говорим, что все, которые...
Все, которые загорите, они терминальны?
Да, а все остальные идут.
Почему они терминальны?
Ну, потому что заметим, что, ну, вершина играет терминальна тогда, когда ее класс эквивалентности состоит из суффиксов.
Правда?
Ну, напоминаю, автоматный строй, который принимает суффиксы только из игр, да.
Следует, на каждое состояние оно, как бы у него класс эквивалентности, либо только из суффиксов, либо только из не суффиксов.
Да.
Не понял.
Так, начнем.
Так, у нас язык, состоящий из суффиксов, сказать, есть только язык.
Да, все это.
Значит, терминальная вершина должна состоять...
Класс эквалентности терминальной вершины должен состоять только из суффиксов.
Ну, то есть не может быть так, что мы в вершину можем прийти и по суффиксу, и по не суффиксу.
Да, хорошо. Ну, некоторых суффиксов.
Терминальная вершина?
Да, не обязательно всех.
Да, некоторые.
Либо это класс эквалентности, состоит только из суффиксов, не обязательно всех, но только из суффиксов,
либо он состоит только из строк, которые суффиксами не являются.
Тоже не всех.
Ну, и тоже некоторые.
И она тогда будет терминальна? Тогда она будет не терминальна.
Ну тогда она не терминальна. Да.
То есть следовательно нам надо найти все вершины, в классе эквалютности которых лежат суффиксы.
Значит поехали. Самый длинный суффикс, суффикс это строка S.
Вот ее там. Это стоковая вершина.
В нее приходят в эквалютности строка S и несколько там чуть покороче суффиксов.
И вот есть первый суффикс. Он у нас кстати S0 называется.
Кстати это S0. Поприветствуем.
Обратите внимание. И он.
Ну вот это первый суффикс, который вот здесь не лежит.
Там лежат все до какого-то момента.
И этот момент называется S0. И он лежит в другом месте.
Заметим, что этот момент описан в определении суффиксной ссылки.
Переходим в суффиксную ссылку и говорим что эта вершина тоже терминальная.
В ней лежат этот суффикс и еще несколько суффиксов предыдущих подряд.
До какого-то момента. Этот момент описан в суффиксной ссылке уже из нее.
В общем, почему других не будет терминальных?
А потому что мы все суффиксы аккуратненько перебрали.
Ну как бы, если объединить классы эквалютности этих вершин будут в точности все суффиксы.
Потому что, напоминаю, в каждой вершине классы эквалютности состоит из одной строки и идущих подряд по длинам суффиксов.
Причем без дыр.
То есть у нас есть строка, строка без одного символа, строка без двух символов, строка без трех и так далее.
Дыр не было.
То есть каждый класс эквалютности выдаётся в этой ступе?
Да.
Да, к сожалению, это было в четвертом утверждении.
Она же не цепится.
Ну, в смысле, первая длинная и последняя?
Ну да.
Понял?
У нас же говорили, что если у нас есть две строки в одной вершине, то они не просто одна из них суффиксов, а все суффиксы промежуточных длин тоже там есть.
Поэтому как бы тут все суффиксы аккуратненько перечислены.
Да, согласен.
Вот, ура!
Да, мы не знаем их, мы знаем только, ну правда, мы знаем длины лонгестов.
Понятно, да?
Вот.
Вот, поэтому, ну это я к чему.
Это я сказал, что в самом-самом конце, если нам очень надо, в 99% случаев, кстати, помечать в конце терминальность вершины нам не надо.
Ну там хватает обычно.
Вот.
Значит, что тогда получается?
То есть мы там в конце терминальней вершины пометим, это для нас не проблема.
Вот.
Но теперь давайте выясним вот что.
Давайте же выясним.
Является, значит, как найти S0?
Как найти, куда входит S0?
Вот как найти эту максимальную подстрочку?
То есть максимальный суффикс строки С, который входит в S как подстрока?
Как его найти?
Если у нас есть автомат строки S, напоминаем.
Суффикс на слухе, хочу, чтобы это поделилось.
Мы от текущей максимальной строки смотрим, можно ли пройти по символу С.
Ну да.
То есть смотрите, что означает максимальный суффикс строки СС, который встречается в S как подстрока?
Это максимальный суффикс строки S, из которого можно прыгнуть по символу С.
То есть это означает, то есть на картинке это будет выглядеть так.
Значит, смотрите.
Так, значит, как это распил?
Ну ладно, как это будет распил выглядеть?
Сейчас я туда, и мы увидим вот что.
Значит так, жила-было состояние S.
Ну, эта строка является префиксом, она вообще никуда, то есть эта вершина никуда не денется.
Ну, как вы уже поняли, старые вершины вообще никуда не денутся.
Так вот, значит, поехали.
То есть ищем первой, первой, первой, первой.
То есть первой вершины на суффиксном пути.
Из которой можно перейти по символу С.
Так, бывает, кстати, один крайний случай, когда вы так дошли до стартовой вершины, и так ни одного либора по символу С не нашли.
Может такое быть.
Первый раз с вами встречались.
Мне даже не обязательно.
Нет, там даже не обязательно.
Ну, теоретически такое может быть.
Ну, практически, если тогда, ну вот.
Ну, если тогда, ну вот.
Ну, а теперь давайте, ну вот.
Ну, если такое.
Ну да, на самом деле, ну вот.
Нет, на самом деле, нет.
Нет, такое может быть только в том случае, в том и том и том случае, когда символ С новый для строки С.
Потому что если вы даже стартовые вершины не можете перейти по символу С, значит, в строке С такого символа не было, правда?
Логично, да?
Помните, да, что у нас из стартовой вершины точить количество ребра по одному либу на каждый символ, встречающийся в строке С, правда?
Поэтому да, то есть если символ С новый, то значит, вы так по суффиксным ссылкам заскачете до стартовой, так этого перехода не найдете.
Но в этом случае все становится тривиально, тогда в этом случае С0, очевидно, равен просто Эпсилому, правда?
То есть никакой новой вершины создавать не надо будет.
То есть в этом случае вы там создадите просто новую вершину С и в общем-то все.
Ну, с точки зрения вершин, напоминаю, не ребер.
Понимаете, да?
Топереча.
Топереча.
А теперь предположим, что вы шли и шли по суффиксным ссылкам, и вот основной случай.
Когда С вы нашли, тогда заметим, что эта вершина является классом эквивалента.
Эквивалентности С0.
Но ключевой вопрос теперь какой?
Является ли это С0 лонгистым в эйсе?
Да или нет?
Теперь внимание вопрос.
А вот как нам теперь понять?
Потому что важно это отличить, потому что если она является лонгистым, то ничего интересного.
А если она не является лонгистым, ну тогда нам придется пострадать.
То есть тогда нам придется как-то распределить этот класс эквивалентности на две.
Нам надо посмотреть на л, этих двух вершинок.
Заметьте, вот если это вершина П, а это вершина Q.
Внимание, вопрос. Чему равна длина С0 в этих терминах?
ЛНП плюс один.
Да, совершенно верно.
Вот модуль С0 равно ЛНП плюс один.
Еще мы знаем, что длина С0 меньше либо равна ЛНК, естественно.
Это мы уже точно знаем.
И теперь нам остается только проверить.
Откуда мы знаем, что ЛНК в пластиковой сной?
Ну мы знаем, потому что С0 – это длина какой-то строки в этом классе эквалентности, а ЛНК – это длина максимальной строки в этом классе эквалентности.
Поэтому, что же у нас получается?
Ну поэтому теперь все, что нам остается, это проверить.
Это неравенство является равенством или строгим неравенством? Прям проверить.
То есть прям честно.
А теперь думать, что тогда происходит?
Ну тогда просто проверяем.
То есть если ЛНК равно ЛНП плюс один, то тогда что происходит?
Тогда мы просто создаем новую СЦ.
О, мне идея.
Ну не пришло ли время нам использовать новый маркер?
Вот.
Вот.
Ну чтоб просто помечать у нас.
Маленький.
Это серийный маркер.
Ладно, давайте кто скажет, это манджиэнта, это бирюзовый маркер.
Ладно, потом да.
А потом более продвинутые на самом деле.
На самом деле это и начнут эти бинарные копиковые.
Еще можно так, да.
Вот.
Вот.
Есть ноль тоже маленькая.
Я жалко сразу не сообразил, но ладно.
Вот.
Значит, смотрите.
Итак, я, собственно, к чему я это сделал?
Я это все.
Я это все потому, что я хочу вот.
Ну, малиновым мне хочется просто создавать вот типа новые датчики.
Вот у меня есть этот С0.
Да?
Значит, ну давайте рассматривать.
Вот есть у меня этот С0.
Ну начнем с того, что ЛН здесь.
Ну понятно, равен ЛН здесь плюс один.
Ну или что, тоже самая длина этой строки.
В общем, мне интересно.
Ну, мы пока про переходы не говорим, но теперь нам интересно.
Так, вот давайте.
Мне казалось, что вот тут равенство.
Тогда мы поняли, что новые вершины ставить не надо.
И тогда мы выясняем, что все, что нам остается, это найти пока.
А куда у нас суффиксная ссылка отсюда отправится?
Все?
Ну да.
Ну и соответственно и останется.
Останется только просто вот у этой свежеприготовленной вершины отправить суффиксную ссылку сюда и больше не тут.
Автомат готов.
Ну ладно, еще ребра надо.
Срочно будем я сейчас отбираться.
Ну а теперь давайте более интересный случай.
А что делать, если неожиданно выяснилось, что здесь строго больше?
Ну, я думаю, что здесь будет больше.
А что делать, если неожиданно выяснилось, что здесь строго больше?
Что здесь строго больше?
Что делать?
Ну все, давайте выяснить.
Тогда мы обнаружим следующее.
Тогда мы обнаружим, что нам придется сказать, что ладно, эта вершина, у нее там был свой лонгест, этому лонгесту она и останется соответствует.
Мы сказали, если у нас была лонгестом, то мы суффиксную ссылку...
То мы суффиксную ссылку из ССС просто в эту курю отправляем.
А сейчас, значит, придется создать новую вершину для ареста.
То есть, что произошло, напоминаю?
Произошло то, что у нас был класс эквивалентности у этой строки, да?
И он разбился на два.
Почему он разбился на два?
Он разбился на два по одной причине.
Начиная с С0, вот эти строки стали суффиксами строки СС, а эти...
А эти не являются суффиксами строки СС.
Понятно, да?
Почему?
Ну, потому так получилось.
Слушай, напоминаю.
Потому что С0 это максимальный суффикс строки СС, который есть в строке С как подстрока.
Почему выше у меня суффиксы?
А, все, да, ясно.
Потому что это две строки.
А эти суффиксы и все, кто дальше, тоже будут суффиксами.
То есть, обратите внимание, на самом деле, ровно поэтому класс разваливается.
Потому что, как бы, чем они отличаются с точки зрения...
То есть, с точки зрения правых контекстов, на самом деле, правые контекста отличаются тем, что к этим строчкам добавился эпсилом.
Ну, в смысле, последняя.
А у этих ничего не поменялось.
Ну, не поменялось в смысле, вот, где вот они заканчиваются.
То есть, понятно, там все строки увеличились на СМОС, естественно, в правом контексте, да?
Но конкретно здесь еще появился дополнительный эпсил.
Поэтому это мы отправим в кул, а этой вершине мы составим понятие клон.
Мы ее назовем клон.
Понятно, да?
Вот.
И суффиксные ссылки теперь направятся там.
Вот.
Вот.
Вот.
Вот.
И суффиксные ссылки теперь направятся так.
То есть, смотрите, вот у кул была какая-то суффиксная ссылка, да?
Вот она вела в какую-то мистическую вершину.
Там, видите?
Тоже вот.
Еще тоже.
Вот это, да?
Тогда заметим, что так как этот клас разбавился, то теперь, значит, мы из клона эту суффиксную ссылку направляем сюда.
А из кул суффиксная ссылка направляется в клона.
Ну, по определению, правда?
Да.
И, конечно же, из этой вершины, так или иначе, суффиксная ссылка отправляется в клон.
Вот такая красота.
То есть, вот получается, таким вот образом мы можем хитро разбираться
на тему того, действительно, какие новые вершины у нас появятся.
Можем даже их в явном виде почислять.
Ну, мы на слайдинге себе оставим вопрос, почему это работает за лигию.
Слушай, за лигию будем оценивать уже, когда сейчас подумаем.
Подумаем, а как же нам все-таки восстанавливать веру?
Прежде чем мы снимаем это, понятно ли, как строить все, кроме игры?
Нет, а что мы только что научились сделать?
Мы научились понимать, какие новые вершины у нас появятся.
И какие будут у них суффиксные ссылки.
Ну, то есть, появится дополнительный оборот, да, но, возможно, еще клон или нет?
Да, возможно, клон. Причем мы научились даже понимать, появится он или нет.
И все.
Да.
Еще мы научились пересчитывать у новых вершин суффиксные ссылки.
Еще иногда вот у одной вершины, в одном случае, видите, перенаправлять старую.
Да.
А еще я предпочитаю, что мы научились у этих новых вершин вычислять лены.
И вот еще, конечно, мы научились делать с клонами.
Ну, создаем новую вершину, называем ее по каким-то пока непонятным причинам клон.
Вот.
И говорим, что она соответствует теперь S0.
То есть, как бы у нас класс эквалентности вершины Q развивался на два.
Вот в клоне будет то, что S0 ниже, а то, что выше, останется в Q.
Вот.
Вот и все.
И после этого мы говорим, что суффиксные ссылки перенаправляются так.
Из клона суффиксные ссылки ведет туда, куда она вела из вершины Q.
Из Q суффиксная ссылка теперь ведет в клона, и из S0, естественно, она тоже ведет в клона.
Все это, если говорить на уровне алберта.
Ну, конечно, будет интересно понимать, почему это так.
Вот почему это так.
Так, понятно, почему это так.
Ну, потому что теперь основание как раз небольшой суффикс.
Да, поэтому из S0 суффиксная ссылка ведет в него, это да.
Из Q в него ведет теперь ссылка, потому что, ну, потому что класс эквалентности разбился на два.
И очевидно, в этом случае из верхнего класса эквалентности ссылка теперь ведет в нижний.
Ну, а из нижнего, получается, суффиксная ссылка ведет туда, куда она из, собственно, этого производившегося класса раньше вела.
В общем, да, если вы хорошо понимаете, как устроены классы эквалентности, то это все очень простые утверждения.
То есть это дело привычки, в общем.
В чем разница между Q и Qn?
Сейчас.
Они создают разные классы эквалентности.
Они создают разные классы эквалентности.
Ведь S0 теперь у клона, а сверху там не S0, сверху...
Ну, сверху какие-то строки, которые раньше до появления CWLX были эквалентны S0, а теперь перестали.
Отличия...
Кстати, да, чем они отличаются?
Вот забегая вперед на все ноли, отличаются они следующим.
То есть, заметим, что в их классе, то есть, их правые контекста отличаются только одним.
В правом контексте нижнего класса есть эксилон, потому что это является суффиксами С.
А те, кто выше S0, они суффиксами не являются.
Вот.
Но так как у нас, кроме этого суффикса, у них хождение заканчивалось в одних и тех же позициях,
то тогда получается, что...
Получается, что, действительно, то есть, правый контекст этого, это как правый контекст этого, только плюс эксилон.
Вот, кстати, почему мы понимаем, что n называют вершину клон?
Потому что отсюда следует очевидная вещь, что мы тогда переходы, которые ведут из вершины клон, тупо копируем из вершины Q.
Я тупо берем и копирую.
Почему у них совпадают правые контесты?
Ну, потому что у них позиции окончания, эти вхождения этих строк совпадают.
Ну, до появления, смотри, до появления символа С они совпадали прям идентичные, да?
Но при появлении символа С у этой строти и у ее потомков появился ровно одно вхождение в самом конце.
Да, ясно.
То есть, получается, отличие этой вершины от этой только одно.
По сути, эта вершина будет терминальной, а эта нет. Все.
В общем-то, а переходы у них одни и те же.
Понимаете, да?
Переходы, которые ведут из.
То есть, они ведут вот, потому что другие классы эквализуют.
Ну, там надо может поразбирать случаи, потому что может быть там, оказалось, что эта вершина Q тоже на этом пути в принципе лежит.
Может быть, такое, да?
Там она лежит и там, может быть, из нее надо сделать новый переход.
Ну, теперь, кстати, об этом.
Какие новые переходы надо делать вообще?
Ну, из класса эквализации S в С в классе эквализации С в С в С.
Да, да. Ну, давайте думать.
Так, ну, во-первых, давайте подумаем.
Значит, какие новые переходы?
Ну, во-первых, алгоритм будет устроен так.
Что, во-первых, заметим, что из всех вот этих вот товарищей нужно сделать переход по символу С.
Да, то есть, напоминаю.
Напоминаю, из этих всех вершин перехода по символу С не было.
Ну, здесь из этой вершины вообще переходов не было.
А тут вот.
Вот я так.
Ну, во-первых, находить переходы сразу можно.
Прям, вы скачете по суффиксным ссылкам, прямо нет перехода.
Ладно, добавляете в новую вершину и, собственно, радуете.
Действительно, такие переходы должны быть, потому что, действительно, мы перебираем суффиксы строки С.
И мы знаем, что если к ним приписать С, то должны получиться суффиксы строки СС, причем которые нигде, кроме как в конце СС, не встречаются.
Поэтому переходы по символу С из них должны отправиться сюда.
Понимаете, да?
И вот мы нашли первую вершину, у которой переход по символу С есть.
Так.
Говорим мы. Ой-ой-ой. Ой-ой-ой. Ой-ой-ой.
Так, заметим, что начиная с этого момента, переходы по символу С, в общем-то, перенаправлять сюда не надо.
Потому что там уже начнутся строки, которые, помимо, вроде как в конце СС, встречаются где-то еще.
Понимаете, да?
Вот.
Так легко.
Так легко.
Ну, теперь, значит, с чего начнем?
Значит, начнем с простого случая.
Так, ну давайте, самый простой случай у нас, это когда мы прям вот, давайте, прям шли-шли-шли-шли, вот давайте, для разминочки, и прям вот до стартовой вершины и дошли.
И обнаружили, что ни одного перехода по символу С у нас, вот самый простой случай.
Что тогда делать?
Ну, естественно, из них мы перекидываем переход по символу С.
Ну, теперь возникает естественный вопрос.
А нужно ли добавлять какие-то еще переходы?
Или, может быть, какие-то переходы надо удалить или поменять?
Ну, это означает, что С встречаются впервые?
Да.
Ну да.
И, значит, с чего начнем?
Ну, это означает, что С встречаются впервые?
Да.
Ну да.
Из этого автоматически означает, что да, что переходы по символу С должны быть в точности из стратеи С и юсуфиксов и вести сюда, больше вариантов нет.
Отлично.
А что можно сказать по другим переходам?
Хорошо, да, у нас там не было переходов по символу С, но ведь там были переходы по разным другим нуклам, может быть, там надо как-то поменять?
Вот да, мы помнили, что вершины не меняются, а переходы.
Ну, понятно, что да, но пока не считаются никакие переходы, кроме вот этих переходов по С.
А почему это?
А почему это? Понятно.
Ну, у нас каждой вершины соответствует набор слов, да, по которым можно у него поискать.
Да, классы квалифиций.
И он классы квалифиций этих подстроек, и он не изменился.
Ну да.
Ну вот добавился новый классы квалифиций для СС.
Ну да.
Так что символ не С, оно как бы вело из одного классы квалифиций в другой, так оно и будет вести.
Да и в принципе верно, действительно.
Давайте вспомним, что вообще означает, что ребро ведет из класса, по любому символу, не важно там какому, игр.
Вот что означает, что ребро ведет из класса эквалентности в класс эквалентности по символу игр?
Что это означает?
Это означает следующее, что тут есть какой-то класс эквалентности из каких-то строчек.
И ребро ведет в класс эквалентности, где есть все вот эти же строчки, только с приписанным к нему символом игр.
Ну может быть, ну на самом деле, если уж полностью рисовать как тут устроено, то на самом деле может быть там еще какие-то продвинутые строчки есть.
То есть если рассмотреть какие вообще символы ведут, то есть ребра ведут в вершину, то вообще можно обнаружить интересный факт.
Да, то есть можно обнаружить.
Давайте, чтобы это обнаружить, я еще маркер возьму.
Да, что тут вот, можно взять подлиннее, вот так вот.
Так вот, допустим, такие две строчки.
Тут у нас будет чуть-чуть еще там пара строчек.
Ладно, даже три строчки.
Вот это сюда, это сюда, это сюда.
Вот.
И если из них, ну вот, и получится следующее.
И из них всех будут вести их вот так вот.
И тогда класс эквалентности получится в точности быть.
Там игрок, видите, вот два плюс вот эти вот три, да.
Вот.
Еще вот эти три.
Да, тут подлинном, конечно, не очень сходится, но вот так вот.
И более того, там еще.
Ну естественно, кстати, все эти как бы товарищи связаны с суффиксными ссылками, кстати, что приятно.
Вот.
Оп.
Оп-оп.
То есть мы тут идем, идем, тут везде переходы по игроку есть, да, все переходы.
Кстати, интересный факт отсюда следует, что в каждую вершину все ребра, все ребра, кто входит в вершину, они по одному и тому же символу, обратите внимание.
Еще такое интересное.
Да, конечно.
Ну просто потому, что все, все классы эквалентности заканчиваются на один и тот же символ.
Так что, да.
Ну и тут, естественно, может произойти, когда наконец-то произошло, когда тут ребро идет куда-то еще, это означает, что это вот суффиксная ссылка, потому что наконец-то вот этот класс эквалентности закончился.
То есть видите, мы взяли такие последовательные классы эквалентности, такие по суффиксным ссылкам, приписали к ним игрок, обнаружили, что строчки объединились в большой класс эквалентности.
То есть вот так это выглядит.
Понятно, да?
Да, в целом.
Вот. То есть это означает, да, видите, что означает, что ребро идет отсюда-сюда.
Значит, если мы к этому классу эквалентности припишем игрок, то это станет частью вот этого класса эквалентности.
Но заметим, что вот в этом особенно случае классы эквалентности, ну кроме вот этого, не поменялись от слова вообще.
Следовательно, и ребра между ними, вот между ними, которые были, неважно, кстати, по символу C или не по символу C, не поменялись от слова вообще.
Понятно, да?
Поэтому становится верно автоматически следующее.
То есть даже не просто этот случай, а вот давайте следующий у нас по сложности случай говорит нам о том, что вот допустим мы тут все-таки нашли этот вот S0.
Вот это я убираю.
Вот. И говорю, вот неожиданно вот этот вот S0 нашелся, но неожиданно выяснилось, что это вершина Q.
И здесь оказалось, что, допустим, S0 равно лонгестот S0 от своего плана.
Лонгестот, допустим.
Тогда мы замечаем следующее, что классы эквалентности, опять же, не поменялись, правда?
То есть поменялись они только в том плане, что довалился вот этот S, но все ребра, которые должны вести в него, мы и провели, а ребра грядущих из него быть не должно.
Поэтому получается, что тоже вообще ничего менять не надо, правда?
Понимаете?
То есть ну и по ядой, как всегда, нарисовали суффиксную ссылку и возрадовались.
И чуть-чуть-чуть-чуть более сложным оказывается случай с флоном.
Потому что если оказалось, что S0 не равен, то мы также снаобъявляем, что у нас классы эквалентности Q, вот этот вот, С, С, С, С.
Неожиданно, скулков нет, разбился на B.
Ну тогда что это значит?
С точки зрения ребр, которые ведут из этих классов эквалентности, мы замечаем, что на самом деле ребра, ведущие из этих классов эквалентности, из этого и из этого, они идентичны, правда?
Логично, да?
Да, ну, кстати, единственная только оговорка, что могло так случиться, что мы для вершины Q, пока тут шли, уже создали этот новый переход по символу С.
Вот.
Ну там надо либо доказать, что этого не произошло, либо...
Не важно.
Вот.
Поэтому дальше происходит следующее.
Обратите внимание, что тогда получается, что переходы мы прям копируем, прям вот, прям копипаста.
А что касается переходов в клон, то замечаем, что на самом деле, раз класс эквалентности разбился на 2, значит просто часть переходов, которые вели в эту вершину, они получается просто теперь должны вести в клон.
Причем, как они устроены?
Вот мы знаем, что у нас был набор переходов, ведущие в нашу вершину Q, да?
И теперь мы знаем следующее, что класс эквалентности разбился на 2.
То есть мы знаем, что в принципе все вершины, из которых ведут ребра по этому символу, они вот устроены так.
И мы видим, что, для этого, мы знаем, что все вершины, из которых ведут ребра по этому символу, они вот устроены так.
И мы видим, что, если как бы имелись в виду строчки длинные с 0 или меньше, то тогда теперь ребра должны быть перенаправлены в клон.
А те, кто были длин больше, то они как в Q или так и остались.
Ну, тогда получается, то есть получается, раз мы тут создали клона, то получается, что самая длинная строчка, которую надо перенаправить, она вот здесь и есть, лент П плюс 1, она же и столь, правда?
вот здесь и есть лент П плюс один, а она же столь, правда? То есть получается вот конкретно ее надо
перенаправить. И все последующие. Да, и все последующие, которые ввели в Q. То есть получается вот так.
То есть дальше получается мы делаем, то есть получается алгоритм строим так. Мы идем дальше
по суффиксным ссылкам до тех пор, пока тут ведут переходы по символу С. Ну вот, и перенаправляем
их в клон. Тут по символу С. Именно в Q. И все эти ребра перенаправляем. А по остальным буквам
получается больше ничего не поменял.
Ну это все. От клона до С. От клона до С. А вот давайте подумаем. Ведь, естественно, надо еще подумать,
что могли бы какие-нибудь экзотические случаи, типа из клона в С, может быть из клона в Q какое-нибудь
ребро появилось, мало ли из Q в клон. Ну из Q в клон они появились по очевидным причинам,
потому что в клоне класса квалетности длин меньше, чем Q, правда? Но теоретически, наверное,
могло быть так, что из клона тоже должно появиться не только старое ребро в СQ, надо скопировать,
но еще и нарисовать ребро в СЦ. Но давайте подумаем, а что это такое вообще? Что это означает? То есть из
клона надо привести ребро по, видимо, символу С. Почему? Ну давайте подумаем, происходит это в каком-то
случае. Ну заметим следующее, что если у нас была строка С и стал символ С, и если мы из нее должны
нарисовать ребро по символу С, то что это значит? Как минимум это означает, что С0 не просто суффикс С,
но он еще и суффикс строки С. Ну все и не все. Нет, на самом деле такое может быть, если тут ССССС,
тут какая-нибудь буква А и какая-нибудь градость. А тут вот ССССС больше не встречается. Так что такое,
в принципе, возможно. Но есть один маленький нюанс. Тогда в этом случае заметим, что... Смотрите,
раз СССССС это суффикс, тогда я утверждаю следующее. Вот тогда мы думаем, если вот это вот клон,
вот это вот СССС стало новым лонгистом. Но это означает, что действительно СССС встречалось
здесь. Может быть еще где-то там как минимум СССС встречалось. Ну короче говоря, просто заметим,
что вот это вот ССС, оно на самом деле, то есть сама по себе вот эта строка СССС, которая
соответствовала строке даже, получается, Q, она являлась суффиксом строки С. То есть она
встретилась на этом пути. А раз она встретилась на этом пути, это означает, что мы пока тут ходили,
создали из нее переход по силу С, и получается он скопировался. Понимаете, да? То есть поэтому
получается, что алгоритм хитрый. Оказывается, когда мы копировали переход, мы как бы новый
переход скопировали. Но правда для этого, чтобы совсем довести это до аккуратности,
надо теперь показать, что на самом деле тут как бы либо этот переход всегда будет,
ли этот переход всегда не будет. Ну мы сказали, что действительно, если переход неожиданно из
С0, по символу S сюда нужен. То есть из этой лиршины переход в СС нужен тогда и
только тогда, когда действительно С0 состоит только из символа С., то есть как мы только locally
Ну, конечно, потому что вы сказали, что из этой штуки должен быть переход по символу c сюда, тогда и только тогда, когда s0 это суффикс s, правда?
Это происходит, но тогда у нас с0 это и суффикс sc, и суффикс s.
Значит, получается, что s0 просто состоит из строк sc и всё.
Это я понял.
Но я утверждаю, что это произойдёт тогда и только тогда, когда вершина q тоже лежит на этом суффиксном пути где-то выше.
Ну вот, раз мы верим даже в тогда и только тогда, тогда получается, что либо тогда sq был создан, этот переход, и он будет скопирован, либо он не создан, и тогда его и здесь создавать не надо.
Всё. Вот такая магия.
В результате это превращает last, то есть даёт нам весьма простой ход.
Вот мы заводим строку s.
То есть что мы храним? Мы храним string s и ещё вот эту вершину last.
Ну last это мы будем хранить, ну вот типа классы квалентности строки s, ну последнюю вершину, stop.
В результате, ну там понятно, инициализация будет привиальная.
Ну во-первых, мы создадим, понятно, одну вершину.
И в этой вершине будет, понятно, пустой мапчик.
Тут можно так писать?
Тут вроде можно, а то мне предради, что тут ноди писать обязательно.
Ну мало ли, не скомпилиться.
Нет, понятно, что вы, наверное, в состоянии, видите, ну вот, нулевую стартовую вершину будет, естественно, ноль.
Суфиксная ссылка будет равна минус один.
Так, ну, и это безобразие мы в полсу.
Вот, нодис понятно, s понятно, s равно it, it, ну и last равно нулю.
Вот, пока все просто.
Ну, знаете, я подозреваю, что если я пишу код, а вы можете с ремаксом смиряться, не получится ли то же самое.
Потому что, в отличие от, видимо, суфиксного массива, тут, видимо, сложно написать код как-то не так.
Итак, добавляем новый символ, господа.
Добавляем новый символ.
Ну, давайте его малиновыми называть.
Чак Ч.
Чак С.
Что мы там будем делать?
Ну, во-первых.
Ну, во-первых, давайте создадим вершину mlast.
Вот, мы будем называть эту вершину mlast.
Вот, и так и напишем int nlast равно, ну, очевидно чему, nodis.size.
Вот.
И так, создаем.
Значит, в nodis соответственно делаем pushback.
Нет, не так делаем pushback.
Ну, сейчас, малиновых делаем pushback.
Ну, если не получается, то мы будем делать pushback.
Ну сейчас мариновую сделаем.
Нет, здесь мы не настолько, давайте уж честно.
Я олдскульщик, я так вижу.
Так, ну поехали. Переходов не будет.
Лен равно чему?
Ну, в генестрии я все-таки не еду.
Ага.
Так, ой, а знаете что, давайте-ка я тут где-нибудь припишу.
Сразу, для удобства. S.pushback от C.
А еще можно сказать, что это Лен от Last писал?
Ну давайте.
Я тут. Легче уже S.lens написать.
Так, сувиксная ссылка я пока не знаю куда, поэтому пишу минус один.
Ну и это безобразие тоже.
Вот я создал новую вершинку.
Это я создал вот mlast.
Это вот правая верхняя?
Это что?
Это правая верхняя?
Да, это вот я создал вот эту вершину.
Теперь я сделаю следующее.
int p равно last.
Ну ладно сейчас.
While, вот я аккуратно говорю, не can go из вершины P по символу C.
Ну давайте я через while это напишу.
Там часто через folie, там где Max может через folie пишет.
Я вот так напишу.
Ну дальше что я делаю?
Я создаю переход по символу C.
Там пишем что-то.
nodis от P.go от C равно mlast.
Ну и здесь конечно P равно.
Ну допустим nodis от P.su.
Ну правда сразу обнаружим, что сразу в этом while мы даже заподозрили, что уже что-то не ладно.
Потому что могла возникнуть такая ситуация, когда мы просто вылетим в трубу, правда?
Поэтому надо по-хорошему писать while P больше либо равно нуля, and end не can go.
Ну можно было конечно в can go еще прописать, что нельзя ходить по символу C из вершины P, которая не существует.
Но это сложновато мне кажется.
Лучше уж тогда так, написать подозрение can go в валидную вершину.
Я технический работник, мне дали вершину, я проверил. Если мне дали хрен знает что, я взлыл.
Это безопаснее.
На самом деле если ваши сотрудники воют от того, что вы дали не совсем корректную работу, то это на самом деле более безопасно, чем когда они умеют за вас что-то думать.
Потому что чем больше ваши сотрудники додумывают за вас независимо от вас, тем больше вероятность, что они сделают то, что вы не ожидаете.
Это называется miscommunication.
На жаргонном языке орков.
Так что лучше вот как бы.
Чего там лицо плюсов?
Принцип плюсов.
Принцип программирования в целом на самом деле.
То есть как бы хотите надежного программирования, то есть надо писать так, чтобы каждая функция была максимально понятна, что она делает желательно из названий без неожиданных специфик.
Это как хороший программист посмотрит на лево, посмотрит на право при переходе дороги, настроен без сна.
Не, не, не.
Ну как сказать, хороший программист настроит так, чтобы действительно все, кому надо переходить дорогу, смотрели только на право.
Хотя...
Ну то есть это называется скорее перестраховка, так?
Нет, нет, это у меня ассоциация, это у меня другое немножко вызывает ассоциацию про таблицы.
Вот вы не столкнулись, так, вы еще не столкнулись с Нишкой 99 советов для программистов?
Нет? Все еще не столкнулись? Я просто должен был уже цитировать вам, наверное, как-то за полгода работы.
Просто там один из советов говорят так, что там сейчас, как там было устроено.
Сейчас не скажу, как известно, но многие считают, что компиляция программы, там действительно что-то там устроено так,
что значит там это, что там что-то, значит программа, значит, считывается, переводится, там все файлы переводятся в объектные,
дальше происходит какая-то магия, и там создается ХЗ.
Магия это линковка.
Потому что там все, потому что названием начинаются соответствовать какие-то реализации в других местах.
Ну вот, и все считают, что линковка какая-то магия, не надо в ней играть.
Так вот, ребята, это не так.
Linker это предельно тупая программа, которая вот смотрит на звание, смотрит какие функции есть,
устанавливает между этими списками, заносит их в свою таблицу, все.
Так что не надо, ну там вот какой-то такой совет был.
Вот. Что, Мишель нам тоже это не цитировал?
Какое безобрение.
Ну ладно.
Ну вот.
Ну вот, то есть какая-то вот такая ассоциация возникла.
Так вот.
Поэтому давайте теперь аккуратненько проверим этот случай.
Если выяснилось, что мы, вот сразу случай номер ноль,
если П вылетел куда подальше, то мы делаем очень простую вещь.
Простая вещь заключается в том, что тогда мы вообще ничего не создаем,
все что нам остается это сказать, то есть ну как бы все нужные переходы уже создали получается,
и да, это сказать только одно.
А куда введет суффиксная ссылка из эссе?
То есть нодис от вот этого nlast.sub.
Куда она должна вести?
Ноль.
Ну да.
Где у нас корень?
В нуле, очевидно.
Ну а где?
Согласно ниту.
Ну да. Ну и теперь пишем last равно nlast.
Вот в этом месте nlast становится нормальной синей вершиной.
И мы выбрасываемся.
Вот.
Ну теперь поеду.
Ну а теперь, пожалуй, я даже кое-куда перейду.
Так, давайте я вот сюда кое-куда перейду и буду писать.
Да, то есть типа n продолжается.
И только n.
Так и так.
Ну а теперь пишем int q равно.
Чему равно?
Ну, ну я-то честно пишу.
Вот.
Ну вот, значит, смотрите.
Ну и теперь соответственно у нас как всегда два вопроса.
В первый случай давайте простой способ.
Если оказалось, что nodis от p.len плюс 1 равно равно nodis от q.len.
Что мы тогда делаем?
Нужно заликовать из s, c в q.
Ну да.
То есть опять пишем nodis от last.suf равно.
Чему он там равно?
Ну да.
Ну да.
Suf равно на этот раз q.
Ну откровенно говоря q.
Ну а дальше как всегда last равно last не забыть.
И выпустится.
Ну это тогда потом придется.
Ну смотрите.
Нет, знаете, правильнее делать так, вот почему.
Потому что, ну, совсем идеально с точки зрения промышленного программирования, да.
Если это все происходит, если вот это все хранится в классе, а это все в привате.
Это все в классе.
Ну я не знаю, я сейчас немножко по алипиадам напишу.
А мы алипиады все...
Ну да.
Отлично.
Ну вот.
Отлично.
Ну тогда внутри этой структуры, тогда вот этот last находится внутри этой структуры.
Вообще по-хорошему, а метод add внешний.
То есть в принципе, да.
То есть как бы пользователь вообще не должен знать, что у вас там какой-то last есть.
То есть это как бы его личное дело.
То есть вы ему там предоставляете какой-то интерфейс ходьбы по автомату.
Если вы очень жадный, то вы даже не сообщаете существование вот этих полей в принципе.
Потому что он сказал автомат.
Определение.
Словарное определение слова детермирует на конечный автомат.
Он никаких суффикс персылать не подразумевает.
Так, а то, что я их там храню, это мое личное дело.
Вот.
Ну можете так заявить на алипиадах?
Вы вряд ли себе такое заявлять будете, конечно.
Ну ладно.
В алипиадах вы, конечно, это мое имя.
За словом приват ругаться не будете, я подозреваю.
Или будете?
Все будете?
Ну хотя бы по ситуации.
На самом деле, если писать какой-нибудь большой код, то он может лучше приватом и поругаться.
Себе же как бы безопасность будет.
Или, по крайней мере, каждый раз, когда вы вместо что-то выносите в паблик, вы хоть себе там это подробно расписываете.
Почему вы так делаете?
Вообще, конечно, на алипиадах обычно этим, конечно, пренебрегают для скорости.
Вот это один из тех моментов, когда и понятно, где надо просто загнать в тестер-лапшу и забыть о ней навсегда.
Или там надо написать код, который будет.
Вот который будут читать там через много-много лет.
В том числе и вы, как всегда.
Так, ладно.
Значит, теперь самое интересное начинается.
Нам пришло время создать клона.
И получается маленькая приятная вещь.
Итак, поехали.
int клон равно, ну естественно, ну понятно, чему.
Вот именно поэтому вам могло показаться.
А почему нельзя сказать, что там каждый nlast равно там last плюс один или что-нибудь еще в этом роде.
А вот ровно из-за этого.
И теперь мы, а сейчас мы четыре.
В полном соответствии с названием мы заявим nodis.pushback nodis.com.
Вот такой вот из себя красота.
Так, ну правда мы его скопировали, но скопировали мы от этого только переходы.
Могли скопировать, могли сразу pushback-нуть правильно.
Ну типа.
Нет, ну мы не, ну нет, сначала мы ее pushback'ем, а потом будем уже у нее менять.
Ну можно сразу.
Нет, сразу нельзя, потому что nodis.cold поменяться не должна.
В смысле?
Ну nodis.cold должна обойтись в меня, не поменяйте, только в суффиксной ссылке.
Нет, в смысле мы можем в nodis.cold сразу pushback'ать правильный нод.
Не копировать nodis.cold, копировать только go, а остальные их оставлять сразу.
А, ну допустим конечно.
Ну просто в этом случае что получится?
Ну вот если так по чесноку делать, то ну поехали, что тут будет.
nodis.cold.go.
Да?
nodis.cold.go.
Так, ну хорошо, да, Лен допустим надо.
nodis.cold.p.ln.plus1 и что-то еще.
Вот, p давайте так оставим.
И что Лену вот, так, что там дальше, суффиксную ссылку у нас мы откуда берем?
nodis.cold.sul. Прям честно копируем.
А, ну и конечно форс потом в конце.
Так, ой.
А, а еще тут должны быть фигурные столбки, да?
А еще тут надо emplaceback писать, да, да, да.
Если писать emplaceback, то не будет сколько не нужно как раз, вот было правильно.
А, черт.
Вот называется, я не привык писать emplaceback, да.
А один раз я загнался дальше просто поменяв pushback на emplaceback и ничего больше.
Несет.
Ну хорошо, ладно, пусть так будет.
Ну вот.
Ну не знаю, вот у меня поэтому и было.
Можно так написать, а можно написать emplaceback, pushback nodis.cold, а потом написать nodis.cold.ln, но вот это.
По-моему у символов было бы меньше.
Зато одна строчка.
Ну да, для желающих одну строчку.
Ну напиши эту вторую строчку сюда.
Да.
Ах да, это плохо, да.
Так, ну хорошо.
Давайте вкуп меняем suf на нашу плану.
О, так, вот теперь, так, погодите, погодите.
Сейчас все будет.
Так, значит теперь поехали.
Значит, во-первых, давайте сразу поменяем suf к смыслу.
Ну, кстати, что уж так, что уж только вкуп-то сразу.
Nodis.cold.suf мы поменяем не только там, а еще и можно сразу в emlast отправиться.
И он везде будет равен этому клону.
Тут мы напишем klona, тут мы напишем emlast, тут мы напишем suf.
А теперь самое интересное.
Хорошо, суфки-суфки перенаправили.
Теперь самое интересное.
Вот это перенаправление.
Ну да.
Значит, как все, и пишем опять.
While аккуратно, пожалуйста, p больше либо равно нуля.
endend nodis.go.c, ну там go.c всегда существует, поэтому можно не проверять.
Почему всегда существует?
Ну, если из какой-то класса эквалент есть переход по символу c, то по всем меньшим его сувексом точным переход это символу c есть.
А из p он есть, потому что он у нас по определению p.
И так вот, пока он есть и равен q, ну он всегда есть, но пока он равен q, то мы заявляем, что он теперь, что это вот go от этого равно теперь клону.
Ну и в конце напишу, да, ну давайте тут молимо напишу, go.c равно теперь клон.
Ну вот.
И вот это вот пластическая фруктика.
p равно nodis.p.
Красота.
Благодарь.
Ну, на этом вроде как все.
Last равно last.
Ой-ой-ой.
И можно еще и retour написать.
Ну теперь уж точно.
Вот. Чем приятен сувексовый автомат, что это все.
Ладно, то есть все, что вам теперь осталось тут дописать, это функцию can go.
Ну понятно, тут просто удвините строчку и написайте это nodis.p.count.c, да?
Ну вы же так проверяете, если переход, правда?
Нет, есть более быстрый способ, формально.
Какой?
nodis.v.go.find.c не равно nodis.v.go.end.
Это быстрее, чем count.
Count вызывает эту штуку, вроде бы.
Да?
Особенно это у вас, например, в мультимапе, ну понятно.
А, ну в общем так лучше после этого.
Ну хорошо, пожалуйста.
Ладно, ну ладно, поверим.
Но не так принципально, конечно.
Если nodis.p.go.find.c не равно nodis.p.go.end.
find.c, естественно.
О, теперь прям вообще все написали.
Ну ладно, там include и using place, то есть со стд вы как-нибудь напишите.
Или даже это using case, стд vector, стд map, там вот это все.
Так, что осталось?
Ну, функцию проверки.
Какая функция проверки?
Ну, у нас мы построили софтомат, который метод основается.
А?
Какая функция?
Не, ну функция проверки элементарно уж как-нибудь пишется.
Нет, по этой логике у нас еще осталось, это, как бы, потом поласту, это построить еще терминальные вершины.
А, да.
Но всякие эти подобные мелочи, как бы, это уже зависит от решения.
Я говорю, по моему ощущению почти никогда, например, строить терминальные вершины в явном виде никому не надо.
Просто потому что половина вещей, которые вам на самом деле надо, они на самом деле иногда из этого вот лена и выкровыкиваются.
Вот знаете, сразу первая базовая задача на суфекстофтомат такая.
Ну, практически там вам какую-то мистику описывают, какую-то черную магию, а по сути она говорит так.
Найдите, пожалуйста, размеры всех классов эквивалентности, отсортируйте их по возрастанию, вы видите последователь кисел.
Вот, кстати, внимание, вопрос. Как найти числа, которые являются размерами классов эквивалентности?
Классов эквалентности суфекса?
Классов эквалентности, нет, пси вообще под строк.
А лены?
Может быть, если нет, то там пси, которые меньше него, то...
Нет, не до конца.
Не до конца.
А там, против, про пушить начало?
Нет.
Ой, пушить.
Нет, первое тупое решение простое.
Напишем динамику, для каждой вершины посчитаем, с какими способами в нее можно прийти.
Все.
Можно задачи наполнить?
Ну, задача.
Ну, давайте так.
Две строки называются эквалентными, если у них совпадают правые контексты.
Ну, там написано по-другому, но суть такая.
Пожалуйста, найдите, у каждого из классов эквалентности, найдите их размеры.
И все эти размеры отсортируйте и напечатайте на экран.
Ясно.
Ну, мы уже знаем для каждой же вершинки самую длинную?
Да, длину самую длинную, да.
А, надо же, можно еще найти длину самую короткой, наверное.
Ну да, можно найти длину самого длинного суфекса, который в ней не лежит.
Да, и, собственно, по сути...
Да, по сути...
Поэтому размер класса эквалентности это, как бы, лен от v минус лен от супа v.
Да.
Вот.
Если вы напишете какую-нибудь динамику, то есть, если вы напишете еще динамику,
где для каждой вершины найдете, скажем, самый короткий путь до стока,
или самый длинный путь до стока,
то, возможно, вы для этих вершин еще и можете сами эти вершины, сами эти ломбисы находить.
Да.
Ну, как подстроить.
Вот.
То есть там всякое такое можно делать, там разные вещи можно делать.
Вот.
Так что, ну, это, то есть, это все уже техника, это уже зависит от того, там, что надо делать.
Так что самое интересное сейчас вообще такое, за какую симптомику это вообще работает?
Надо бы сказать, что за линию.
За линию на алгоритм от развернутой.
На алгоритм от развернутой.
Ну, понятно.
А с нас только доказать почему это работает за линию.
Да.
Ну да.
Скажите, сколько это работает?
Давайте посмотрим, что у нас вообще может не быстро работать.
Угу.
Ну, уходить по этим.
Ну, ухожение по существенным словам у нас вообще.
Ну, это, это вот эти вот вайлы.
Это единственное вообще шоу, у нас тут вообще как-то нелинейная работа.
Да, у нас два причина.
Давайте смотреть.
Давайте их пометим.
Мы их пометим.
Так, вот это мы пометим коричневым, вот этот вайл мы пометим коричневым цветом.
А вот этот вайл мы пометим голубым цветом.
Значит, идея у меня такая.
Я буду мысленно, вот мысленно, в явном виде я делать не буду, но теоретически я могу делать так.
Я буду мысленно поддерживать, во-первых, суффиксную ссылку из ласта.
Вот, кстати, обратите внимание, да, это ласт.
Вот.
А голубой указателем я буду на суффиксную ссылку от суффиксной ссылки.
От ласта.
Отлично.
А теперь смотрите.
Первый вайл занимается тем, что оба эти указателя двигаются до вершины П.
Вот, двигаются, двигаются, двигаются, и вот, наконец, коричневый указатель указывает на П, голубой указатель, соответственно, сюда.
После этого этот указатель такжестно переходит, ну там, в худшем случае, наклон, а в лучшем случае, наклон.
Ну, давайте сейчас рассмотрим, в случае, когда наклон.
Видите, да?
А теперь как бы нам теперь найти суффиксную ссылку клона?
Так вот, на самом деле более продвинутая версия алгоритма могла бы выглядеть так.
Этот голубой указатель продолжает вот так вот скакать, скакать, скакать до тех пор, пока у него ребра указывают в К, да?
Тогда он, значит, проходит сюда, а теперь заметим, что из этой вершины, ну если он там в аут не вылетел, да,
то тогда мы обнаружим, что здесь переход по символу С есть, и он не просто есть, а на самом деле вот эта бывшая суффиксная ссылка,
которой в этом случае нету, она вела ровно сюда.
Понимаете, да?
Поэтому голубой указатель сюда переходит, то есть, заметим, что оценить время работы можно как О от количества,
суммарного количества скачков этих указателей, согласны?
Ну там плюс еще какие-нибудь M10, которые вы там забывали, в общем, ну вот.
Ну а теперь заметим, что каждый указатель скачет несколько раз, ноль или более раз скачет по суффиксным ссылкам,
а потом, возможно, проходит по символу С.
Тогда, если у этого указателя смотреть такую штуку, как лен, вершины, в которые он указывает, да,
то каждый скачок этот лен уменьшает, а каждый переход по символу С, обратите внимание,
он тут так устроен, что лен увеличивается ровно на 1, обратите внимание.
Понимаете, да? Вот тут вот так четко устроено.
То есть, конечно, неверно, то есть, как мы уже выяснили, не всегда верно, что если вы перейдете по ебру,
то лен у вас увеличится именно на 1, он может увеличиться и на больше.
Ну, потому что, видите, вот по этих вершинах, например, вот из этих вершин тут этот лен больше, чем вот этот лен плюс один, правда?
Чем дальше, чем сильнее больше.
Но конкретно здесь это не так, он увеличивается ровно на 1.
Это потому, что мы прошли до последней такой, ну да.
Ну либо, ладно, есть еще один случай, когда там оба эти указателя там вылетели и потом пришли в ноль.
Но это тоже не очень интересно, понимаете, да?
То есть там лишние вот единицы действия, когда вы вылетели за пределы нуля,
быстро это поняли, вернулись в ноль, сказали stop.
Но отсюда, в общем-то, думаю, линейность алгоритма становится очевидной.
Другой способ доказательства может быть заключаться в том, что,
то есть заключается в том, что давайте в качестве потенциала рассмотрим длину суфферского пути из ласта.
Ну там заметим, что длина суфферского пути, то есть мы работаем за от вот этих вот вершин
и заметим, что вместо этой части пути тут остается две вершины, да.
А после этого заметим, что тут идет какой-то путь, тут идет какой-то путь,
и тут количество вершин не более чем количество вершин, тут плюс один.
Что можно сказать?
По суфферским путям?
Ну да, если это по суфферским путям дальше идти, да.
Точно, да.
Ну да, если это по суффиксным путям дальше идти, да.
То есть поэтому вы как бы работали за O от L, и потенциал ваш стал уменьшился на L и увеличился на 2.
Ладно, на 3 может быть.
Ну тут не очевиден факт, почему для двух нет никаких вершин.
А вот поэтому, видите, потому что, смотрите, вот у вас есть суффиксный путь, да?
И вот вы из этих всех вершин пытаетесь пройти по символу C.
И как бы эти вершины, как бы нексты, идущие подряд вершины, слопываются в одну.
Худший случай, когда они прям вот так параллельно идут.
И тогда эта длина плюс один, потому что там еще в конце все есть.
Вот.
Да, но тут уже как конкретно это доказывает, в общем выбирайте сами, тут вам как намекнет.
Не знаю, я предпочитаю указатели, потому что этот метод у нас уже есть, давайте им пользоваться.
Сейчас ты еще раз вноси, длина суффиксного пути из власт.
Утверждение, длина суффиксного пути N last не более чем длина из суффиксного пути last.
Минус вот это вот расстояние до этой вершины.
Плюс 3.
Ну до этой вершины, это в смысле, до куда мы там дошли.
То есть до первой вершины, из которой есть переход по C.
Нет.
Нет-нет-нет-нет, смотрите, вот мы как ходим.
Сначала мы идем пока нет перехода по символу C, а потом дальше идем пока есть переход в ту же самую вершину.
То есть тогда, если вот количество этих вершин равно там Z, то тогда длина суффиксного пути N last это не более чем длина суффиксного пути от last.
Минус Z, то есть минус вот это вот.
Плюс 2.
Вот ну за счет вот этих вершин.
Ну самих N last и clone.
И плюс может быть 1 вон там.
То есть плюс 3, короче, в сумме получается.
А 1, в смысле, если мы дошли до корня?
Да.
То есть если, если тут прям, когда мы тут шли до корня, то есть каждый, каждый вершины переход по символу C был прям в честную, в новую вершину.
Тогда там как бы параллель, параллель, параллель, параллель, параллель, параллель, из эпсела на параллель сюда, и отсюда суффиксная суффигина в этот же эпсел.
Вот.
То есть можно было так доказывать.
Ну вот с этими указателями, просто метод вот этих вот двух указателей, по-моему, у нас уже в дереве будем другую.
Ну вот то есть вот видите.
То есть как-то опять эта классика, да.
То есть как бы фокус можно показывать с горящими, с горящими мечами или с топорами, там называется.
Но технология фокуса одна и та же.
Экшн лов.
