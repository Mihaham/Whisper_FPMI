Родительский контроль.
Так, я не знаю, давайте опять, да, приношу извинения
за то, что мы задержались.
Создать, сохранить.
Так, не знаю, экран видно или нет.
Нормально.
Проверим.
Не, проектор видно, нормально, что написано.
Не, ну мы, конечно, опять можем потушить свет, и тогда
ютуб не увидит меня, но мне-то как-то без разницы.
Так, опять рубрика эта.
Нет, не угадали.
А почему, интересно, схема так работает, электрическая.
О, нормально.
Мне кажется, чуть-чуть темнее сделали, но при этом презентация
стала виднее.
Так, давайте начнем мы с вами, у нас сегодня будет
новая тема, которая продлится, не поверите, аж три недели.
Почему продлится три недели, потому что следующая среда
выходной.
Тема называется тестирование, тема достаточно важная
с учетом даже того, что у нас с вами было на первом
задании, то есть вам так или иначе самостоятельно
уже необходимо тестировать тот код, который написали
просто по той причине, что система не выдает никаких
вердиктов.
То есть надо запаковать файлы в архив, нужно их распаковать.
Значит, это наша сегодняшняя тема, теперь две организационных
вещи, которые я хотел сказать.
Дедлайн по первому заданию перенесем на два дня, с
пятого на седьмое марта.
Значит, мы выкатим еще до конца недели, постараемся
выкатить.
Значит, второе задание, оно будет посвящено системам
сборки проектов.
Раз, и второе задание мы выкатим, это будет первая часть
проекта.
Сейчас мы одобряем всякие шаблоны проектов и, в принципе,
можно будет их начать делать.
Второе организационное объявление у нас будет контрольное
все-таки промежуточное.
Она будет предварительно пока на 5 апреля поставлена.
Значит, что касается тем этих контрольных, это будут
все темы, которые мы пройдем до того момента, плюс будут
некоторые задачи на решение именно.
То есть это немножко про тестирование, больше не
про сегодняшнюю лекцию, а именно про следующую лекцию.
Будут темы, посвященные тому, что надо будет нарисовать
какую-то UML-диаграмму, и будет еще возможно что-то
по паттернам, которые мы с вами сейчас проходим
на семинарах.
Значит, и еще мы определились с цепороговыми баллами.
Значит, у нас будет 5 технических заданий, каждый из них
будет стоить по 8 баллов, то есть те 10 баллов, которые
вы получаете в задании, трансформируются в 8 баллов
в итоговой оценке.
Немножко сложная формула, но я думаю, мы ее приведем
к общему знаменателю.
Так, что я еще забыл сказать.
По-моему, я все сказал по организационным вещам.
Возможно, что если я что-то забыл, спросите меня, может
быть.
Контрольных будет две.
Первая пятого и вторая ближе к концу семестра.
Ну, давайте, может быть, попробуем сделать, но поскольку
это первый раз контрольная, может быть, не быть, но
какие-то примеры тестовых задач мы пришлем.
Вот так.
А прикол в том, что формат контроля меняется в этом
году.
Да.
А, все, вспомнил, и еще раз, значит, мы тоже чуть-чуть
усложнили систему сдачи курса, значит, сразу скажу,
что если какой-то из порогов не проходит, то это перездача.
Возможно, кроме контрольных.
Почему кроме контрольных, как вы думаете?
Да, может быть, такое, что не повезло.
Ну, и мы в этом году снизили пороги на контрольных, а
вот те задания, которые вы делаете в рамках семестра,
пожалуйста, делайте.
Ага, значит, пороги 15 баллов на тех заданиях, 10 баллов
на проекты, 5 баллов на контрольные.
Вот.
То есть, еще раз.
То есть, надо по заданиям набрать 15 из 40, 10 из 40 на
проект и 5 из 20 – это коррель.
Вот.
В сумме сколько получается?
30.
30 из 100.
То есть, если вы сдаете все эти пороги, вы автоматно
получаете зачет.
Да.
Вот.
Да.
Значит, смотрите, сегодняшняя тема – это тема тестирования,
но мы сегодня поговорим не только про тестирование,
но и поговорим немножечко про качество ПО.
Давайте вспомним, что у нас было в прошлый раз.
Методология разработки.
Есть разные методологии разработки, и мы с вами
как раз детально с ними разобрались.
Значит, сегодняшняя тема – это, по-моему, первая такая
достаточно техническая тема, но сегодня мы начнем
именно эту тему с точки зрения именно теоретического
обоснования.
Зачем это необходимо?
Посмотрим, что такое пирамидотестирование.
А в следующий раз, уже после выходных, мы с вами будем
говорить про какие-то тонкие технические вещи, связанные
именно с тестированием.
Как замерять то, что наш продукт хорошо протестирован.
Прежде чем мы с вами начнем, мы с вами поиграем в небольшую
игру.
Представьте себе, что у нас есть некоторая функция,
которая принимает на вход некоторый набор чисел,
а на выход выдает, являются ли эти числа сторонами
треугольника.
Наша задача состоит в том, чтобы придумать как можно
больше выходных данных, на которых можно проверить
результат работы функции.
Ну, поехали.
От минус 100 до 100.
Ну, хорошо.
Сколько тестов получится?
От минус 100 до 100?
Ну да, 8 миллионов.
Ну, значит, смотрите, мы сразу сталкиваемся с проблемой
того, что называется комбинаторным взрывом.
Что количество вариантов у нас растет в достаточно
большой прогрессии.
И вообще, по-хорошему говоря, вот такой именно сетап
тестов лучше не использовать, потому что иначе мы придем
к избыточному тестированию.
Да, ну, давайте пример.
Нам нужен некоторый сетап примеров написать.
Нет, конкретно.
Нам нужен именно конкретный тест.
Почему?
Чтобы наш результат мог воспроизводиться.
1, 2, 1.
Хорошо.
Какой ответ на эту задачу?
Хорошо.
Какой?
Да, 1, 1, 1, 1.
Это интересный тест.
Что на него мы должны выдавать?
Значит, смотрите, в зависимости от того, как мы реализуем
это все, по-хорошему, он должен выдавать ошибку.
То есть, давайте я напишу, что exception выдает.
Значит, раз говорю, товарищам тоже некоторая техническая
вещь, которая заточена под разные языки программирования.
Разные стили.
Значит, во всяких языках типа C подобных, у нас нет
такого понятия как exception.
Тогда используется следующая вещь.
Код возврата ошибки.
Оно еще обычно называется ерно.
На курсе по косу вы будете сталкиваться с этим.
Либо делается следующая вещь.
Когда у нас вызывает какая-то функция, которая должна
возвращать ошибку, пишут, обычно это будет
что-то подобное. Ер запитает result.
То есть, тем самым мы говорим, что мы возвращаем результат,
но ты, пожалуйста, проверь, что у тебя находится в ошибках.
А в высокоуровнях языках больше принято кидать exception
в таких сценариях и его ловить.
Давайте еще примеры.
Так, минус два, ноль.
Ну, три. Какой ответ?
Ну, давайте, да.
Ну, ответ, конечно же, нет, потому что
сторона треугольника должна быть неотрицательна.
Ладно, зависит от сценария.
Да, что одно из чисел является отрицательным.
Согласен.
Ага.
Да.
Да, восемь. Да, можно.
Да, это если есть тест даблов, да.
Угу.
Угу.
Угу.
Да, кстати, кто-то сказал, нужно еще и все перестановки проверить.
Почему надо перестановки проверить?
Да, у нас может быть, в принципе, код такой,
что if a plus b больше c return true.
Все.
Ну, да.
Ну, ноль семьдесят один. Хорошо.
Да. Угу.
Так.
Вообще, по-хорошему, нужен тест, который выдает true?
Ну, да, можно.
Это граничный кейс, я согласен.
Давайте корректный тест какой-нибудь.
Угу.
Да.
Я не понимаю, почему у нас есть
Да.
Я не понимаю, почему ручка работает как ластик.
Так.
Что предлагает бесконечный минус один, бесконечный минус один, бесконечный минус один.
Давайте я так напишу.
Так.
Смотрите, на самом деле, сейчас мы опираемся на то,
по факту, как вызывается эта функция.
Да.
Давайте подумаем гипотетически,
на каком языке мы с вами будем писать эту функцию.
Да.
Ну, на C.
Смотрите, если мы пишем это все на C++,
то, скорее всего, у нас вот этой ошибки может не быть,
потому что мы передаем три числа a, b, c, d, a, b, c,
и у нас просто ошибка компиляции возникнет на этом тесте.
Ну, смотрите.
А давайте предположим, что у нас будет функция вот такая вот.
Вот такая у нас функция с вами будет.
Что делать будем?
Давай.
Да, типа.
Значит, анекдот.
Два тестировщика заходят в бар и заказывают
одну кружку пива, две кружки пива, три кружки пива,
полторы кружки пива, 0,585 кружек пива,
минус 500 кружек пива, кварте кружек пива.
А?
Ага.
Вот.
Ну, давайте еще один тест.
И что на нем должно выдаться?
Ну, да.
Ну, моя цель показать приблизительно, как эти тесты выглядят.
Так.
Ну, на самом деле, если еще взять все перестановки,
то какое количество сценариев у нас есть?
Кстати, у нас еще, кажется, нету одного сценария.
Ну, хорошо.
Если мы в питоне работаем, то у нас не будет переполнений.
Давайте другой еще тест.
А?
Да.
Ну, да.
Давайте его тоже сюда куда-нибудь запишу.
Да, еперный.
А еще один кейс.
Не-не-не.
Ну, два от четыре, как бы три между ними.
Да.
Чего выдает?
По-хорошему фолс можно выдавать.
И еще один кейс.
Да...
Ладно, да, согласен.
Да.
И еще нужен случай со всеми нулями.
Почему?
Ну, да.
То есть, возможно, есть такая проверка,
и кто-то, возможно, математик, может сказать,
что равносторонний треугольник, у которого сторона стремится к нулю,
является правильным треугольником.
Поэтому треугольник со сторонами 0,0,0 может существовать.
Но мы же не знаем, кто пишет код.
Может быть, его пишет Убермегаматематика,
которая считает, что треугольник со всеми нулями — это треугольник.
Вот, в общем, такие тесты есть.
И, как видно, сценариев может быть огромное количество.
Значит, я не знаю, сколько у нас сценариев.
Давайте посчитаем. Раз, два, три, четыре,
пять, семь, восемь, девять, десять, одиннадцать.
Перестановки все двенадцать.
Возможно, что еще есть какие-то варианты.
Но, по факту, из книжки, из которой я взял этот пример,
в нем было четырнадцать тестовых вариантов,
четырнадцать вариантов тестов.
А?
Ну, да.
На самом деле, вот еще тест с равенством есть.
Вот тут вот значений.
Да, там типа два, три, пять треугольник мы опустили.
Ну, вот.
Ну, да, ладно, согласен.
Надо посмотреть, честно, результаты.
Ну, в общем, двенадцать с четырнадцать — это очень даже хорошо.
Почему? Потому что, если проводить этот тест в среднем по больнице,
среди команды разработки, то они покрывают только половину случаев.
То есть не более семи вариантов выделяют.
Мы с вами покрыли четырнадцать вариантов.
Вот. И вот как раз вот этой книжке можно прочитать этот тест.
Значит, книжка называется MyAirsoft,
Глент-Портмайер, Art of Software Testing.
Это четвертое издание.
Оно вышло, по-моему, в 2004 году.
Как вы думаете, в каком году первое издание вышло?
Еще раньше.
Ну, в 79-м, по-моему, если не ошибаюсь.
Значит, классическая книжка.
Она у меня из дома, она где-то двести страниц занимает.
Она очень тонкая, но там есть особенности современного тестирования.
Там именно такая хорошая теоретическая книжка по основам тестирования.
Значит, вторая книжка.
Это такая более практическая книжка.
Она заточена по то, чтобы сначала писать тест, а потом писать код.
Эта методология называется Test Driven Development.
Мы с вами, наверное, попробуем поговорить про нее на следующей лекции.
Возможно, кто-то и на семинарах ее посмотрят.
Просто это интересно получается.
Идея такая, что мы сначала пишем тест, а потом пишем код.
И это хорошая вещь.
Если вы, допустим, хотите стать внезапно веб-разработчиком,
то на самом деле можно писать код вот таким вот способом.
На Python здесь используется как раз фреймворк Django для написания сайта.
И третья книжка.
Это еще одна книжка по TDD, но она уже немножко про другую методологию.
Давайте в прошлый раз мы с вами говорили про экстремальное программирование.
Где мы предполагали, что сидит либо два человека за компьютером,
либо один человек сидит за компьютером, а другой человек – это заказчик, который мы командуем.
В данном случае еще могут подкидываться тестировщики.
Значит, сразу скажу, что мы сегодня будем смотреть на тестирование немножко с другой стороны.
Мы больше сегодня будем говорить про автоматическое тестирование.
То есть тестирование, которое запускается посредством кода.
Но есть еще и ручное тестирование, и оно даже превалирует.
Это тот случай, когда мы с вами не пишем код,
а мы просто, возможно, визуально отсматриваем результаты
или что-то вбиваем в какой-нибудь веб-браузер.
Пример теста. Мы хотим проверить, пишет ли ручка.
Наводим на доску, начинаем писать.
Ручка не пишет, исполняется эластик. Тест провален.
Ну да, тогда нам надо выяснить причину, кто проваливает тест.
Ручка или карандаш.
И тогда мы должны закопаться глубже и, возможно, написать отдельный подтест для ручки и отдельный подтест для карандаша.
Для того, чтобы выяснить, у кого проблема.
Итак, давайте я расскажу, что на самом деле, что касается тестирования,
есть международный стандарт тестирования.
Он называется ASTQB.
И вообще, если тут есть интернет, по-моему, здесь можно зайти на ссылку
и посмотреть, в общем, какие здесь уровни есть.
Значит, смотрите. Всего в этом стандарте тестирования разделяются три подсоставных части.
Это ядровая часть тестирования.
Справа это тестирование, которое заточено под именно определенных специалистов.
То есть, если здесь внимательно посмотреть, не видно, да?
Я просто не знаю, как это визуально выглядит.
Ну и с чем можно презентацию открыть?
Значит, смотрите, какие составные части есть здесь.
Это приемочное тестирование.
Это, по-моему, скриншот с 17-го или 19-го года.
Сейчас все, что написано in development, оно уже разработано.
Дальше есть тестирование мобильных приложений.
Есть тестирование используемости юзабилити тестинг.
Дальше, на более продвинутом уровне, можно даже тестировать безопасность.
А там еще есть еще один уровень.
Это по факту инженер, который автоматизирует тесты.
То, что мы с вами подразумеваем под профессией тестировщика,
которые именно связаны с разработкой, то это как раз вот про этот уровень.
Значит, с другой стороны, мы можем с вами пойти в гибкие методологии разработки
и понять, как тестировать продукт в рамках как раз гибких методологий.
Почему это важно? Давайте подумаем.
Почему тестирование в гибкой методологии может отличаться от тестирования в классической разработке?
В других методологиях?
Да, нам нужно реально очень часто общаться с разработчиком.
И есть юанцы, которые связаны именно с тем, что оба у нас выкатилась новая фишка,
и нам быстро надо ее протестировать.
И каким образом протестировать?
Количество изменений, которое у нас появляется в один день, оно очень огромное.
Ну или можно пойти в управление тестами.
И тогда у нас появляются менеджер тестов, управление тестами, анализ тестов, тест аналитик.
И дальше, на более высоком уровне, это управление процессом тестирования.
И это уже по факту глава команды QA.
QA расшифровывается как quality assurance. Уверенность в качестве.
Так, давайте вопрос по этой картинке.
Мы с вами сегодня посмотрим, начнем смотреть нижний самый уровень.
Это Certify Tester.
И если вы зайдете на сайт и скачаете Syllabus этой программы,
если вы мне напомните в чате, я вам скину Syllabus.
Это, короче, документ такой на 100 страниц PDF-ка, в котором есть вот это все.
И вот мы с вами, кажется, что мы пришли на курс технологии программирования.
Да, мы должны писать код.
И мы говорим, что давайте мы с вами будем именно технически заряженными, уметь писать, автоматизировать все вещи.
Но оказывается, чтобы сдать на этот уровень, не обязательно уметь писать код.
Вот, это надо понимать.
Поэтому сегодня мы смотрим на тестирование немножко с другой стороны,
по сравнению с разработкой ПО.
Так, есть вопросы по слайду?
Движемся дальше.
Значит, смотрите, дальше в каждом из уровней этого стандарта есть подсоставные части.
И вот из каких составных частей состоит Foundation Level, про который мы с вами говорим.
Начнем рассматриваться тема, как основы тестирования.
Что же такое тестирование?
А второе, это тестирование, как оно проходит через цикл разработки.
И здесь важная составная часть, какие типы тестов бывают и какие уровни тестирования бывают.
А Software Development Life Cycle Models, то есть методология разработки, мы с вами рассмотрели в прошлый раз.
Поэтому мы с вами про них говорить не будем.
Дальше, следующая составная часть, это статическое тестирование.
Это очень важно.
И на самом деле, забегая немножко наперед, ваш код проходит статическое тестирование.
Когда вы сдаете технические задания.
В какой момент оно проходит?
Статическое тестирование – это тестирование, которое не запускает код.
Код StyleChecker к ним тоже относится.
И процесс Review – это процесс статического тестирования кода.
Не, наоборот.
Это то, что проверяет человек.
То есть смотрит код, говорит, стабуляция не та.
Вот это вот все.
Там типа куча переменных на одной строке.
Пайп на 500 символов и так далее.
И дальше есть код Stack.
И дальше есть некоторые методики тестирования.
Так называемый метод черного ящика, метод белого ящика и метод, основанный на опыте.
Может быть кому-нибудь интересно, кто-нибудь здесь учится на управленцев?
Нет, нет.
Но возможно, что если кто учится на управленцев, тому будет полезно как раз изучить основы управления тестами.
Ну и дальше есть набор инструментов, которые поддерживают инфраструктуру тестирования.
То есть каким образом их нужно использовать.
Вот такая вот у нас с вами категоризация.
Мы с вами посмотрим первые четыре пункта точно из этой все части.
И заодно еще на лекциях посмотрим некоторые методики, а на семинарах попробуем их в автоматическом режиме применения.
Это, наверное, одна из первых лекций, которая прямо будет в темах семинара.
Так, ну смотрите, давайте...
Так, извините.
Вопросы.
Поехали дальше?
Да, вопрос.
В чем заключается задача тестирования?
Значит, задача тестирования необходима для того, чтобы оценить артефакты тестирования.
Что такое артефакты?
Артефакты это по факту выходной продукт того или иного действия.
Значит, у нас здесь могут быть разные вещи.
У нас может быть код.
То есть мы пытаемся оценить код.
Более того, у нас с вами может быть дизайн.
Это дизайн графический там какой-то странички.
Либо дизайн с точки зрения архитектуры.
Дальше мы можем оценивать те требования, которые нам предоставил заказчик.
То есть есть функциональные требования, то, что система должна делать с точки зрения функции.
То есть при нажатии на кнопку у нас должна вываливаться вот такая вот плашка.
Или совершаться заказ.
Да, но при этом бывают не функциональные требования.
Допустим, к ним относятся требования о локализации продукта.
Да, локализация это перевод на другой язык.
То есть если вы, допустим, на нашем сайте попробуете нажать в правом верхнем углу язык выбрать,
то вы увидите, что интерфейс переключится на английский язык.
Правда, не во всех местах тестов на локализацию на сайте не написаны.
Да, но на самом деле есть две плашки условия на русском и условия на английском.
Я просто взял их, скопировал и не парился.
По факту мне надо сесть в какой-нибудь момент времени и перевести задание на английский язык.
Вот, а user story это, давайте так скажу, это термин больше из скрама.
Просто эта лекция делалась после скрама.
Это задача, которую мы решаем на текущий момент.
Которая вносит некоторое новое value в наш продукт.
Допустим, создать такую-то кнопку, реализовать такой-то функционал, внедрить то-то.
А, то есть это какой-то новый функционал и по факту мы при помощи него можем оценить, сделана задача или нет.
Более того, мы верифицируем то, что требования некоторые выполнены.
Значит, смотрите, тонкий момент.
Что такое верификация?
Верификация.
Верификация – это процесс, который показывает, что наш продукт работает грамотно.
Не то, что он делает необходимые вещи, а то, что он делает грамотно.
Давайте пример поясню анекдотом.
Значит, барышня с некоторым цветом волос начинает печатать текст.
Говорят, я печатаю со скоростью 600 знаков в минуту.
Я спрашиваю, как так?
Говорят, ну я просто сижу, печатаю.
И что, отличие получается?
Ну да, получается, только непонятно, что написано.
Вот.
Вот это процесс валидации.
То есть процесс валидации того, что барышня пишет 600 знаков в минуту.
Нет, это валидация.
Барышня, ты же можешь написать текст со скоростью 600 знаков в минуту?
Валидация – это мы проверяем, что мы делаем вроде бы нормальные вещи.
А верификация – это то, что мы написали не фигню, а написали нормальный текст.
Не-не-не, это две просто разных ветви.
И по факту, давайте тоже вперед забегу.
На статическом тестировании мы верифицируем наш продукт, наш код или так далее.
А на стадии валидации мы проверяем, что когда мы его запускаем, он работает.
Ну, вроде так это.
Что-то тест проходит.
Типа, как говорится, пивком покатит.
А, тонкий процесс.
На этом нужно замечать.
Ну, мы еще поговорим про верификацию.
Ну, следующая история про задачи тестирования – это избегание дефектов.
То есть нам нужно избежать того, что мы в каком-то месте посадим баг.
Ну, если вдруг мы не нашли дефекты, то нам что надо сделать?
А?
Ну, да.
То есть если мы не предотвратили, нам надо быстро иметь из Кати.
То есть нам передал код команды разработки, и нам нужно найти эти збой и эти дефекты.
Вот.
Значит...
А?
Ну, исправить потом, конечно же.
Да, ну, естественно, это передается все команде разработки, и команда разработки это фиксит.
А?
Тонкий момент.
Чем отличается збоя дефекта?
Збоя дефекта.
Дефект – это та вещь, которая еще может пока каким-то косвенным стороной влиять на то, что у нас процесс какой-то происходит.
Возможно, правильный.
Вы же знаете, наверное, что в каком-то месте можно допустить две ошибки, и кажется, что все будет работать нормально.
Знакомо, да.
Это два дефекта по факту.
А збоя – это когда мы наткнулись на это место, и у нас все падает.
Понятно разница?
То есть дефект – это то, что потенциально может дать збоя, а збоя – это, по факту, уже произошедшее мероприятие.
Вот.
Значит, еще одна вещь – это больше такая отчетная деятельность.
То есть нам нужно предоставить информацию основателям, ну, либо заказчикам об уровне тестирования и уверенности в работе нашей системы.
То есть мы говорим, мы провели набор тестов, и, пожалуйста, 99% времени, типа, наша система будет стоять стабильно.
Из-за этого мы можем делать какие-то выводы.
Вот. Ну и последнее, что нам необходимо точно делать.
Помните, мы в прошлый раз говорили, что нам важно говорить про сертификацию.
Помните, я показывал сертификацию ответствия, там, типа, когда мы говорили, какие требования бывают, факторы к ПО.
Вот в данном случае нам нужно еще во время тестов убедиться, что мы соответствуем необходимым стандартному качеству ПО.
А они есть, их реально много.
Так, вот, вот это у нас задача тестирования. Давайте вопрос по ним.
Да.
Хорошо, движемся дальше тогда.
Значит, смотрите, следующий момент, который нам необходимо пояснить, есть профессия тестировщик, есть профессия КУА-инженер.
Наверное, слышали или читали где-нибудь, что есть люди бесятся, когда их называют тестировщиками, хотя они хотят называться КУА-инженерами,
quality assurance-инженерами по контролю в степени уверенности.
Значит, смотрите, и здесь получается такая разница.
Значит, в чем цель тестирования по факту?
Цель тестирования по факту. Это нахождение и решение появившихся сбоев и дефектов.
И при этом тестировщики больше заточены на исходном коде и архитектурном дизайне.
Ну, собственно, кто этим занимается? Этим занимаются как раз тест-инженеры и разработчики.
Чего у вас там? Все нормально? Все. Ага.
Вот. И видно, когда это происходит. Это тестирование происходит на стадии тестирования и параллельно со стадией разработки.
Значит, дальше есть некоторая другая более расширенная вещь, так quality control.
Мы проверяем, что наш продукт соответствует требованиям перед тем, как его внедрят в реальную жизнь.
Вот. И здесь фокус идет уже на оценке всего продукта так-такового.
И вот как раз здесь и появляется та самая необходимая верификация нашего продукта.
Да, мы проверяем, что продукт делает грамотно.
Потому что вы могли, в принципе, сделать все, что надо, а потом оказывается, что вы сделали совсем не то, что хотели.
То есть вы... Ну, опять же, наш эфемерный пример с фиксиками. Возможно, кому-то надоели.
Мы сделали крутую онлайн-платформу, а потом смотрим на эту платформу и получаем, что у нас вместо фиксиков, я не знаю, кто.
Такие... А?
Ну, либо вирусы, либо человечки из этого... из Саус-Парка или, хуже того, Хэппи Три Фрэнс.
Ну, соответственно, мы нарушаем просто стандарт качества, и мы проиграли.
Просто потому что мы хотели фиксики онлайн.
Насколько сделать? Там 6 плюс или 0 плюс?
По-моему, ну, типа ограничений по возрасту. А получается хардкорный 18 плюс, если не 21 плюс.
А?
Да-да-да-да.
Вот. Значит, и есть еще одна статья. Это Quality Assurance.
Значит, мы устанавливаем уже грамотный процесс с точки зрения стандартов качества.
Вот. И здесь мы уже фокусируемся не на продукте, не на дизайне, а на большем.
На том процессе, который у нас с вами проходит в выкоманде.
Вот. И цель этого всего.
Если, как говорится, если у нас порядок, то вероятность того, что у нас где-то произойдет сбой, намного меньше.
И здесь уже принимают участие также из заказчика.
И этот процесс происходит повсеместно, то есть во все время развития нашего продукта.
Вот. Поэтому Куа, это намного больше, чем тестирование.
Вот. Хотя, возможно, что мы сегодня будем говорить про тестирование из точки зрения того, что у нас будет в QA.
Но надо отслеживать точно.
Вот. И, скорее всего, мы сегодня затрагиваем на стадии Quality Control и тестирование.
Вот. Пожалуйста, отличайте этих людей и не называйте, пожалуйста, тестировщиков-тестировщиков.
Они могут обижаться на это.
Они любят называть себя QA-инженерами.
Так. По этому слайду вопросы.
Окей.
Развет вопросов.
Значит, мы посмотрим немножко про стандарты качества.
Какие они есть? Сейчас это просто ознакомительный слайд.
В следующих лекциях мы в деталях поговорим.
Значит, что такое стандарт качества?
Значит, есть два стандарта ISO.
Первый более старый – это 9.1.2.6.
Более новый – это 25.0.10.
Стандарт оценки качества софта.
Нас интересует в данном случае поддерживаемость.
То есть, эта способность продукта сохраняет свою способность в поддержке.
Ну, грубо говоря, пример.
Чтобы вы понимали, представьте себе, вы написали код на алгосах.
Не в обиду алгосах.
Когда вы последний код, первый контест по алгосам сдали свой?
Ну, во время обучения.
Ну, что-то мощное.
У вас что, вот такая контест по алгосам долгая?
Понятно.
Ладно, все равно четыре месяца прошло.
Так, декабрин, варь, февраль.
А, три месяца.
Три месяца прошло сегодня, первый день весны.
Попробуйте открыть этот код.
И понять, что в нем происходит.
Вот как раз…
Ладно, до понятия.
Сможете ли вы модифицировать для своих новых целей?
Из-за сколько?
А?
Нет, нет, нет.
Вот как раз использовать как черный ящик нарушает свойство поддерживаемости.
Потому что, если, допустим, нам баги чинить в этой штуке, мы это просто не сможем сделать.
А?
Нет, не факт.
Нет, ну а вдруг тесты не покрыли всевозможные баги?
Вы верите тестам?
Я нет.
Ну вот.
Значит, тут есть шесть составных частей, нас интересует сегодня поддерживаемость.
Значит, есть стадии, связанные с эффективностью и пользованием.
Видите, тут всякие интересные вещи.
Типа usability.
Там есть такая подкладочка.
Learnability и understandability.
Learnability – это способность к обучению к тому интерфейсу, который мы осваиваем.
Это, знаете, вот всякие туториалы есть.
Вы заходите в первый раз на сайт, или в первый раз в игру, и внедряются в туториалы.
Вот.
То есть вы про свой сталернабилити.
А destability вы открываете, и вам все понятно, что тут происходит.
Значит, есть еще функциональность.
Есть надежность.
И портируемость.
Портируемость – это значит, что адаптивность нашего продукта для того, чтобы перенести его, допустим, с PlayStation на Xbox.
Так вот, что касается поддерживаемости.
Она состоит из вот таких вот составных частей.
То есть поддерживаемость составляет в себе модифицированность, анализируемость кода и тестируемость кода.
И дальше, если спускаться на более низкий уровень, есть устойчивость к ошибкам.
А complexity, сложность кода, зависит от его возможности тестировать.
Давайте попробуем какие-то выводы сделать из этой картинки.
Тут надо логическую связь простроить.
У вас как раз был матлок предыдущей парой.
Давайте еще раз включим.
Причем матлок, потому что нам надо понять.
Смотрите, если у нас мы…
Смотрите, вопрос в том, что если у нас код сложный, как вы думаете, тестируем мы он или нет?
Можно ли его протестировать?
Иногда бывает такое, что у нас функции 50 аргументов.
Как написать тест для функций с 50 аргументами?
Во-первых, эти 50 аргументов надо подготовить.
Это хорошо, если они енты.
А если это какие-то еще сложные структуры, нам эти структуры надо подготовить, запаковать,
еще проверить, как эти стадии идут внутри нашего кода, как они ввятся и так далее.
Это реально сложный процесс.
Поэтому если код сложный, то протестировать его сложно.
А если код сложно тестировать, вывод какой?
Мы потратим огромное количество времени на поддержку.
Просто невозможно, возможно экспоненциальное время.
Поэтому вывод из этой картинки, да, кстати, снизу, это метрики качества кода,
которые можно использовать для того, чтобы отвлечь ту или иную составную часть.
Лог – это lines of code, если что.
А про остальные надо смотреть.
Значит, вывод, чтобы код был поддерживаемым, он должен быть тестированным.
То есть наша цель, если мы хотим с вами уметь поддерживать код, правильно писать тестовую базу.
Так, сейчас у нас...
Ага, я понял.
Что, делаем перерыв?
Да, хорошо, давайте сделаем перерыв.
Дальше мы поговорим про принципы тестирования, и, наверное, сегодня на пирамиде тестирование закончено.
Итак, мы с вами продолжаем, и сейчас мы будем говорить с вами по принципам тестирования.
Их всего семь штук.
Значит, два этих принципа очень похожи, но в них есть небольшая разница, поэтому мы их тоже разберем.
Значит, принцип первый. Тестирование показывает наличие дефектов, а не их отсутствие.
То есть, смотрите, вывод такой, который может сказать следующим, что если у нас есть тесты,
то вероятность того, что мы найдем тот или иной дефект, подрастает.
То есть, в обратную сторону не работает.
Что если у нас с вами...
Да, то не факт, что мы его найдем тестово.
Да, вероятность уменьшается, конечно, что мы не найдем этот дефект, но все-таки он и есть.
Вот.
Второй тезис. Избыточное тестирование невозможно.
Значит, чтобы вы поняли, я приведу один пример.
Представьте себе, что у нас есть код с ветвлением.
Сколько вариантов нам добавляет ветвление?
Два. Два варианта. Либо в одну сторону идем, либо во вторую сторону идем.
А теперь представьте, что если у нас идет в коде десять ветвлений подряд.
Одно, потом второе ветвление, потом третье, четвертое и так далее.
Сколько у нас вариантов получается?
Два в десятый.
Два в десятый.
Да, то есть у нас количество тестов в худшем варианте на каждое ветвление увеличивается в два раза.
Которое необходимо для того, чтобы рассмотреть все тестовые сценарии.
А?
Ага.
И в итоге, для того, чтобы проверить все тестовые сценарии, мы можем просто сидеть и каждую секунду проводить какой-то тест.
Все равно до конца жизни времени не хватит.
Да, просто количество вариантов, которые у нас есть, оно будет крайне большим.
Поэтому избыточное тестирование невозможно.
И поэтому все время на тестирование тратить не очень хорошо.
Поэтому есть следующий, третий принцип тестирования.
Ранее начало тестирования экономит время, деньги и даже нервы.
Значит, давайте я как раз, наверное, на слайде изображу график, который можно увидеть.
Значит, это будет три картинки.
График в зависимости количества сожженных нервных клеток от времени разработки.
Так.
Давайте подумаем, как выглядит график, в котором тестов нету.
Ага, конечно.
Экспоненциально.
Есть? Так, есть маркеры разных цветов?
Нету?
Где?
А, меню вижу.
А, ёберный.
Юзабилити не очень.
Так, значит, давайте я даже скажу, что оно...
Я же выбрал цвет.
Я и не понял.
Так.
Юзабилити такое юзабилити.
Вот.
А потому что у нас комминаторный взрыв происходит.
Чем больше вариантов, тем хуже.
Чем сложнее тестировать код.
Если у нас на каждое условие, а мы внедряем по одному условию в минуту,
усложняется увеличивать количество вариантов в два раза,
то вопрос, какая у нас функция?
Время?
Время разработки нашего проекта.
То есть сначала мы начинаем писать код int main, образно говоря.
Все, нервов нисколько.
Количество нервов, которые мы тратим для того, чтобы это протестировать, увеличивается.
А потом у нас ходу кин-код стайл какой-нибудь.
И вы такие, сиди, ёберный балет.
А как же это протестировать?
Ну, там проблема в том, что это все делается через callback hell,
и callback debugging еще сложнее.
Вот, значит, смотрите, теперь представим себе второй кейс.
Я надеюсь, что я с ручкой справлюсь.
Желтенький.
Так, давайте оранжевенький кейс.
Значит, мы начали тестироваться чуть-чуть позже.
Вот где-то вот здесь мы начали писать тесты.
И тогда количество тестов у нас...
Это идет какая-то экспоненциальная функция, но она...
Вот, значит, если мы сразу сделали нормально,
то количество неров уже, возможно, будет расти линейным образом.
На контрольной вы увидите этот эффект в рамках
не готовились к контрольной,
готовились к контрольной чуть-чуть,
готовились к контрольной хорошо.
Вот, значит, вот такое у нас грайк получается.
Опять же, он может быть неточным.
Смотрите, этот график неточный.
Давайте его поправлю немножечко.
График, скорее всего, такой.
Вот такой вот.
Как вы думаете, почему всплеск неровов возник?
Нет, вы...
Нет, вы с этим столкнетесь.
Когда вы начнете писать первые тесты, вы поймете,
что, блин, это тут происходит?
Какой-то сложный фреймбор для тестирования.
Как его там записать?
Как его подключить в зависимости?
Как эту вещь, черт возьми, собирать?
Как эту вещь запускать?
То есть вот этот первый скачок – это просто людей приучить к тестированию.
Вот, это сложно.
Не всегда получается, но надо.
Это помогает.
Да, ну и в оранжевом тоже будет небольшой всплеск.
Да, в красном сначала классно, а потом будет плохо.
Вот, значит, еще один сценарий, который важно разобрать.
Еще один график, который показывает...
Каким образом ресурсы на разработку должны связываться с ресурсами на тестирование?
А скорее всего...
Вот, давайте подумаем, если мы попытаемся затушить красный график,
каким образом мы захотим его тушить?
Ну, нанять команду тестировщиков.
И тогда, смотрите, у нас затраты на тестирование будут сильно превышать затраты на разработку.
Логично.
А если мы с вами больше денег тратим на разработку, нежели чем на тестирование,
то с чем у нас проблема возникает?
Мы будем развивать наш продукт или нет?
А?
Ладно, с багом. Мы просто будем тратить время на то, чтобы фиксить баги
и никак не приступать к развитию нашего проекта в дальнейшем.
Поэтому, по факту, если мы говорим, что это время на разработку...
Нет, то затраты на тестирование обычно не должны превышать затраты на разработку.
Это такое афемерное правило.
Что они должны идти параллельно?
И как раз при помощи этого синего графика, при помощи вот таких затрат,
в принципе, вот такое плюс-минус получается.
Понятен тезис?
Понятен тезис?
Ну понятно, но наш проект же тоже растет, он начинает получать ресурсы,
инвесторы подключаются и так далее,
поэтому мы считаем, что если мы грамотно управляем нашим продуктом тем,
чем мы занимаемся, то и ресурсов у нас будут на это больше.
Мы сможем нанимать больше людей и, соответственно, тратить больше денег.
Плюс мы возможно, за счет того, что у нас есть раннее тестирование,
мы возможно мигрируем со старой версии 1 на новую версию 2
чуть меньшим ресурсом, чем нам нужны.
Просто мы сэкономим время на оптимизацию той или иной версии.
Правило про это.
80% дефектов содержатся в 20% кода.
То есть, скорее всего, та ядреная технология, которая у нас есть,
кор, поскольку от нее зачастую все зависят,
вот эта у нас кор компонента,
а эта, допустим, какая-то другая компонента, которая зависит от нее,
и от нее зависит все компоненты,
и скорее всего, вероятнее всего, что у нас бак находится в ядре,
в нашей системе, в каком-то ядреном компоненте.
Было ли бы в каком-то месте накапливаются баги?
Ну, кор это, возможно, низкоуровневая библиотека какая-то.
Грубо говоря, идея такая.
Если тараканы скопились в одном месте,
то, скорее всего, тараканы будут искапливаться в этом месте.
Такой же вещь.
То есть, это классическое правило Парета.
Следующий интересный кейс.
А парадокс пестицидон.
Он говорит о том, что старые тесты не помогают находить новые дефекты.
Да, то есть, тестовая база должна развиваться параллельно с кодовой базой.
Да, то есть, тестовая база должна развиваться параллельно с кодовой базой.
Да, это называется регрессионное тестирование.
Вот. Идея такая, что...
Ну, представьте себе, вы травите тараканов.
Я не знаю, вообще есть таракан или нет сейчас.
Ну, слава богу.
Ну вот, они могут быть.
Представьте, вы травите их одним средством.
Вроде они уходят.
Ну, это, конечно, не так.
Вроде они уходят.
Потом начинаете травить тем же средством, когда они приходят второй раз,
а они резистентны к этому тесту.
Вот.
И возникает проблема.
Та же самая проблема с тем, почему нельзя часто пить антибиотики.
Ровно поэтому.
Потому что вирус становится резистентным к этому антибиотику.
Понятен тезис.
Шестой тезис.
Тестирование зависит от контекста.
Оно сильно зависит от методологии разработки и от сфер разработки.
То есть подмобильные девайсы тестируются все по-разному.
Вопрос.
Как вы думаете, кому жить на свете легче?
Тестировщикам Android или тестировщикам iOS?
Да.
Почему?
Давайте варианты.
Почему iOS, почему Android?
А?
Для миллион разных версий Android, миллион разных марок и так далее.
А?
Ну да.
Вот, оно есть все, достаточно просто.
Я говорю, что у меня на практике был кейс, когда мы нейросетку под телефон запускали.
У нас в итоге 10 отдельных Android устройств.
На одном видеокарте нормально работает, на втором работает ненормально.
На третьем оно жрет дофига памяти.
На четвертом оно вообще не жрет памяти.
При этом выполняет за 100-500 секунд обработку.
В общем, реально какой-то зоопарк моделей возникает.
Ну и front-end тестируется, наверное, не те же самые методы, на что и backend.
То есть сильно все зависит.
И последняя вещь, это тезис, который очень сильно похож на первый тезис.
Но суть в чем?
Отсутствие ошибок – это ошибочное суждение.
То есть, что значит, что если у вас нет ошибок,
то у вас все замечательно.
На самом деле это не так.
Возможно, вы просто не до конца искали.
Вот.
Это 7 принципов, на которых основывается тестирование.
Давайте вопроса.
По ним?
Да, конечно, будет.
А содержание будет такое.
Есть код.
Да, написать к нему тест, чтобы покрылось как можно больше процентов кода.
Нет, там багов в коде нет.
Там нужно именно удостовериться, что этот код тестируется нормально.
Нет, кстати, там был баг.
Там был баг в задании, который пришлось фиксить.
Это забавный кейс.
Короче, был написан проект удалить папки в проекте.
И там была опция удалить папку текущую.
В итоге вы запускаете этот код, и он удаляет папку с проекта.
Пришлось exception закидывать туда.
Что типа, are you sure, товарищ?
Удалять проект из текущей директории.
Вот.
В общем, давайте поговорим теперь, если про принципы хорошо, давайте поговорим про психологию.
Давайте подумаем, почему тестировщики и разработчики должны быть разными людьми.
Мысление разное. В чем оно заключается?
Они не копают по-другому. Смотрите, разработчики это больше творческие люди.
Разработчики творческие люди, они хотят создавать новый код, создавать новые продукты, и так далее.
А тестировщики зачастую...
Ну, если говорить на терминах физтеха, то да, они факеры.
На самом деле, они критики.
То есть, их цель, чтобы продукт был качественный, из-за этого они достаточно серьезно придираются к тому, что написано.
Вот.
Ну, пример, я не знаю, по-моему, сейчас в 11 классе уже пишут все сочинения, да?
А проблема в том, вспомните свое ощущение, когда вы написали свое первое сочинение.
Какое у вас было ощущение?
О, я родил это.
А?
Ага, да, и так сойдет.
И так сойдет.
Это вспоминаем с 39-го государства, который...
И так сойдет.
Вот.
А тестировщики, они, наоборот, говорят учителю, типа, исправь, пожалуйста.
Поэтому, на самом деле, смотрите, важно в стадии тестирования, чтобы люди не критиковали друг друга.
Важно не переходить на личности, важно содействовать в нейтральном ключе.
Вы обсуждаете код, а не людей.
И обсуждаете тоже код, а не людей.
Вот.
Ну, это такой важный намек.
Так что, когда вы будете работать, не обижайтесь, пожалуйста, на тестировщиков.
Они делают благое дело.
Вот.
Кстати, возможно, кто-то из вас пойдет в КУА инженеры.
Вполне возможно.
Кто-то из вас пойдет в разработчики.
Такое тоже вполне возможно.
Так, понятно про психологию.
А?
Про психологию тестирования.
Так, есть КУА инженеры, они ведут себя в разном ключе.
Угу.
Движемся дальше.
Значит, смотрите, дальше следующий кейс.
Больше теоретически.
Нам больше важно именно про пирамиду тестирования поговорить.
А детали, если что, можно прочесть будет на слайдах, на презентациях.
Что в чем каждый уровень заключается.
Мы с вами поговорим крайне на таком низком уровне.
Какие уровни тестирования бывают?
Значит, разные системы говорят, что уровней тестирования может быть огромное количество.
Кто-то перечисляет одну пирамиду, кто-то дает вторую пирамиду, кто-то дает третью, четвертую, так далее.
Ну, в общем, каноническая, если говорить по формату СКБ, такая пирамида,
что на самом нижнем уровне у нас находится юни-тестирование,
на среднем уровне у нас находится интеграционное тестирование,
далее дальше запускаются системные тестирования,
и на верхнем уровне запускается приемочное тестирование.
Оно же Acceptance Testing.
И вот, чтобы вы понимали, я приведу некоторую математическую абстракцию.
У вас же с математикой нормально?
Смотрите.
Представим себе, что мы с вами тестируем граф.
Какой-то математический объект.
Грубо говоря, вершина этого графа — это класс.
Тогда у нас на самом деле мы можем сказать, что unit-тестирование...
Так, нам надо вернуть на черный цвет.
Да еперны балета.
Первое, вершина графа — это unit-тестирование.
То есть мы тестируем вершину определенного графа.
По факту мы тестируем с вами класс, модуль или компонент.
Проверяем, что наш класс работает так, как нужно.
Второй кейс — это интеграционное тестирование.
Что в графе у нас помимо вершин есть?
Ребра.
И в интеграционном тестировании мы тестируем не вершину...
Да еперны.
А тестируем ребро.
Ну вот считать, что у нас ребро порванное, значит у нас тест не пройдет.
Просто доска постаралась.
То есть мы с вами берем два компонента, либо некоторый набор компонент,
и проверяем взаимодействие между ними.
Представьте, Вася отправляет Пете тысячу рублей по протоколу.
Вася снимается тысячу рублей, потом обрыв связи, Петя тысячу рублей не приходит.
Что делать?
А все, тютик.
Как говорится, застали вы это или нет, была песенка такая.
Сел на пятенок, должен был косарь отдать.
Русское народное творчество.
Следующий более высокий уровень — это системное тестирование.
И как вы думаете, что мы здесь тестируем?
Четко КСС.
Я бы сказал, ну можно так сказать, если мы тестируем компоненту сильно связанности,
либо еще что-то, это окей, тогда будет еще системное интеграционное тестирование,
которое тестирует связи между этими сильно связанными компонентами.
Но в целом, в каноническом определении, это граф.
Вопрос, а что может быть выше?
