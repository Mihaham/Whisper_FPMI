Лекция 4. Основы DML, агрегатные функции, сложенные запросы. Закончим наконец сегодня с DML,
с вами развяжемся до конца и начнем основу проектирования баз данных. Немножко повторим,
с чего закончили прошлую лекцию. Это этап выполнения запроса Select. У нас, как я уже
говорил, запросы Select, хоть в принципе запросы SQL у нас максимально приближены к естественному
языку, но с другой стороны они, тем не менее, не такие простые, как хотелось бы быть, как хотелось
бы нам как пользователям, и их порядок выполнения, вот запросов именно Select, запросов к базе данных
на выдачу каких-то конкретных данных из базы, он порядок выполнения, он такой немножко
инвертированный, ну перепутанный скорее, даже не инвертированный. Как вы помните, у нас все
начинается не с собственного утверждения Select, а с from и join. Потом идет where, group by, having,
select только на этапе после соединения, фильтрация таблиц работает, потом уже,
ну не фильтрация, а логическая какой-то выборки по условию. Потом идет сортировка и, соответственно,
ограничение выдачи через лимит и offset. Картинку тоже эту вы видели на слайде предыдущем,
предыдущей лекции, но опять же в детактических материалах, в детактических, прошу прощения,
целях повторю еще раз, ее, ну честно признаюсь, картинка, она взята из общего доступа, довольно
очень такая наглядная, с другой стороны, удобно показывающая, что происходит. Опять же, прошу
обратить на этап выполнения group by и having. Как вы видите, левые столбцы, левые столбцы
результирующей таблицы, которые получаются на этом этапе, они слиплись, соединились совместно в
две группы. То, что, собственно, у нас происходит на этапе group by, значения, эквивалентные значения
в различных строках, они по какому-то заданному нами атрибуту соединяются в некое такое одно,
что ли, метазначение, такая мета-ячейка скорее даже появляется, значение у нас
остается то же самое, и вот наглядно это хорошо видно. Здесь также я приведу вам SQL запрос для
создания тестовой таблицы, которая у нас в этой лекции будет продолжать фигурировать и которая
появилась еще в прошлой лекции. Там ничего сложного, просто чтобы, если кто-то захочет запустить
код у себя на машине и как-то поиграться, уличить лектора в недобросовестности формулирования
наглядных материалов. Так, хорошо, давайте посмотрим быстренько на агрегатные функции,
агрегатные или агрегирующие, то есть это функции, в принципе, работающие похожим образом,
как выражение groupBy, но единственно, если groupBy у нас просто склеивает ячейки по какому-то
атрибуту в одну ячейку, оставляя значение исходное, но одинаковое для всех склеиваемых,
соединяемых ячейек, то агрегатные функции делают иначе, они по какому-то атрибуту выполняют некое
действие, заложенное, собственно, в их определение. На слайде написано это буквально немножко
иным языком, в общем-то, это цитата из документации, агрегатная функция сводит множество входных
значений к одному выходному, а также у нас определенные особенности по обработке налозначений,
вот большинство агрегатных функций, они налозначение игнорируют. Ну, в принципе, это
мы тоже с вами оговаривали в прошлый раз, даже, по-моему, в позапрошлый раз, для
при рассмотрении троичной логики, но вот повторяем, чтобы не забыть. Основные функции, перечисленные,
ну, как основные, наиболее часто употребимые, что ли, такие вот функции на уровне каких-то
азов, которые нужно точно знать и представлять себе, они на слайде перечислены. Опять же, в
документации по ссылкам из прошлой лекции можете посмотреть там, ну, или просто сами, в принципе,
найти, это довольно несложно, на сайте Postgres Pro. Можете посмотреть таблички с полным переченем
агрегатных функций, их ощутимо больше, но мы с вами ознакомимся вот только с такими,
более, наверное, простыми и понятными, но в принципе их, повторюсь, сильно больше, там есть отдельные
классы статистических агрегатных функций, то есть все это можно использовать, чтобы писать какие-то
очень интересные запросы, получать какие-то очень интересные результаты с аналитической уже
составляющей, а не просто вычислить количество срок в таблице или общую сумму. Краткое описание
приведено на слайде. Давайте вслух я быстренько расскажу, что и как. Каунт со звездочкой, ну,
вы уже, очевидно, с этим сталкивались не раз. Вы считаете просто количество входных строк,
то бишь, строк в таблице. Результат, опять же, вот обратите внимание, в каждой функции указан
результат. И вот в функциях после каунта в скобках приведены аргументы, это не значит,
что там какие-то конкретные аргументы или их должен быть список, а имеется в виду, что просто
в каунт мы можем прописать звездочку, специальный указатель, да, а в сам max, min, average мы должны
написать как минимум ими столбца, если функции еще дополнительно каких-то значений аргументов не
принимают. За дополнительными аргументами я вас отсылаю, опять же, к документации. Там есть
определенные ситуации, где могут потребоваться, но по умолчанию, в принципе, нам сейчас вполне
хватит того, что есть. Опять же, обратите внимание в описание, вычисляет сумму всех входных значений,
отличных от null для всех функций, кроме каунта. Каунт, по умолчанию, у нас выдаст все строки,
которые, по умолчанию, имеется в виду с аргументом специальным звездочкой, выдаст все строки в
таблице, даже если одна из строк будет заполнена одними null. Вот примеры использования. Select
count звездочка, считаем количество рядов, прошу прощения, количество строк, конечно же, ну,
получаем 10, да, в общем-то, все довольно просто. Если мы посмотрим, теперь в агрегатная функция
суммирования сам просуммируем все жалования, все жалования, которые платится каждому сотруднику,
получаем, так, 500, 560 тысяч рублей, ну, получается это месячное очевидное жалование на, там,
какой-то, какую-то совокупность подразделений фирмы, вот такой фонд оплаты труда. Можем посчитать
в данном случае, найти, вернее, даже дату найма, и обратите внимание, у нас Maxmin принимает не только
числовые значения, числовые типы данных, но и, в данном случае, тип данных здесь дает, ну, как бы,
понятно, что, в принципе, он где-то внутренне трансформируется в число, в какой-то, там,
какой-либо из систем, в зависимости от системы счисления, в зависимости от СУБД, и, ну,
по сути дела, да, это вот в данном случае у нас Max все равно работает как такая численная функция
для дейт, просто вот это вот косметическое представление дейта для пользователя, в первую
очередь, хотя, да, для каких-то операций тоже дейт имеет свою специфику, как тип данных,
но, тем не менее, просто к чему все это? К тому, что Max может принимать не только
нативно числовые типы, может принимать еще и иные варианты типов данных подробнее, да,
смотрите в спецификацию, ну, или просто можете попробовать на каких-то простеньких запросах.
То же самое с MIN, соответственно, Max Date of Employment выдает нам дату наимов самого последнего,
самого нового сотрудника, самого нового коллеги, MIN Date of Employment выдает дату наима самого
первого сотрудника в подразделении некоем, ну, здесь совокупность подразделений, поэтому можно
сказать, практически в фирме, да, если бы у нас вот фирма состояла из четырех подразделений и
десяти человек. Average, ну, понятно, считает среднее значение, поскольку, как вы помните,
сам у нас посчитала среднюю, вернее, общую сумму жалования, общий фонд оплаты труда как 560 тысяч,
160 тысяч мы поделили на 10, получили 56 тысяч рублей, и, опять же, да, здесь у нас выходной тип
числовое значение Numeric, и здесь количество налей там, на самом деле, даже не влезло в картинку,
там какое-то, что-то около десятка, если не ошибаюсь, мы можем это, конечно, привести к
какому-то иному типу, чтобы получился покрасивее результат. Ну, напрямую получается у нас такой
тип данных, надо иметь, наверное, это в виду для каких-то, да, вот, опять же, это тип с повышенной
точностью, это не просто float, это именно тип, который позволяет избежать ошибок при проекции,
связанных с проекцией, дистичной системы счисления на двоичную, и там повышенная,
соответственно, да, повторюсь, точность обеспечивается при вычислениях. Хорошо,
Select Group By агрегатные функции. Когда в запросе присутствует предложение Group By или какая-либо
агрегатная функция, выражения в списке Select, по общему правилу, не могут обращаться к
негруппируемым столбцам, так как иначе в негруппируемом столбце нужно было бы вернуть
более одного возможного значения. Агрегатные функции, если они используются, вычисляются по всем
строкам, составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы.
Теперь, может быть, постараюсь более простыми словами. Опять, как мы с вами говорили, на пальцах
у нас Group By слепляет строки, соединяет их, а вернее, даже не строки, а конкретные значения по
атрибутам. Там понятно, что мы можем в Group By запихнуть много перечислений столбцов, но для
простоты возьмем один столбец. Получается, что если мы Group By используем, компонуем по какому-то
атрибуту одинаковые значения в группе, буквально, повторюсь, просто склеим одинаковые значения в
одну ячейку, то мы, если будем обращаться к иным атрибутам, которые у нас не склеились, которые у
нас все еще представляются в виде отдельных записей, отдельных строк таблицы, если мы к ним
будем обращаться, у нас просто запрос не будет иметь какого-то содержательного смысла. Мы не
сможем специфицировать для не склеенных ячеек, какую мы хотим ячеек получить в ответ. В общем-то,
довольно, наверное, мне кажется, просто, если над этим немножко подумать, поразмышлять, как мы
можем к множественному значению получить конкретный ответ, если мы пытаемся взять из неопределенного
множества значений, то есть, грубо говоря, не знаю, как мы можем, ну, такой, может быть,
немножко пример, уходящий в сторону, как мы можем выбрать конкретно элементарную частицу,
если они ничем не отличаются. Какую-то мы можем выбрать, но она будет торжественна любой другой,
мы как бы специфицировать ее не можем в принципе, силы физических ограничений. Вот примерно здесь
то же самое происходит, но ограничения логические, по крайней мере. Понятно, что каждая строка,
каждый там элемент, они на диске записаны определенным образом, каждый элемент кортежа
в любом отношении определенным образом записан, имеет свой конкретный адрес, но логически у нас
они становятся не конкретны для запроса. Так, и соответственно, мы к таким столбцам обращаться
не можем, а по грубой, по сгруппированным столбцам можем использовать агрегатные функции. Давайте
посмотрим. Давайте посмотрим пример у нас, пример использования агрегатной функции и
группирования. Мы здесь хотим получить, ну, сгруппируем по департаментам, так, мы хотим, да, мы хотим,
хотим из нашей таблицы с данными по нашим сотрудникам, сгруппируем эти данные по департаментам
и смотрим, какое среднее жалование у нас для каждого департамента получается. Опять же,
обратите внимание, кто, может быть, еще там на семинарах не знаком, вот мы можем привести число,
наше результирующее, результат вычисления среднего значения к какому-то более, что ли,
пристойному виду, скажем так. В данном случае мы используем функцию round, округление мы можем
задать на количество знаков после запятой, мы могли бы сделать приведение типа для нашего значения,
могли бы его привести, например, к типу integer, причем это тоже было бы в данном случае округлением,
а не отбрасыванием, как, ну, не знаю, C++, такой банальный пример приведу. Будет тоже округлением
использования приведения типа, ну, можно использовать округление, опять же, как вариант,
а явное такое. И пример отработки груба и average опять же на слайде, ну, наверное, пояснять,
мне кажется, здесь, в принципе, ничего не надо, ну как, давайте, давайте все-таки, окей, давайте
чуть подробнее, вот мы склеиваем первую строку, пятую и девятую вместе, у нас получается 50,
значение в столбце salary, мы причем salary не можем, мы причем к salary при этом не смогли бы
обратиться, не используя агрегатную функцию, у нас был, наша СОБД выдала бы нам ошибку, чтобы
обратиться к salary, мы используем, ну, чтобы сделать запрос логически осмысленным, каким-то
содержательным, мы используем агрегатную функцию на столбце salary, на атрибуте, и получаем,
соответственно, тоже склеенное такое результирующее агрегатное значение для
нашей группы в атрибуте department. Хорошо, давайте посмотрим на подзапросы, в принципе, мы уже
изучили, прошли все, что нужно знать о селект-запросе, как таковому подзапросу, такой же селект-запрос,
возженный внутрь другого селект-запроса, вот так вот, грубо говоря, отделяется он скобками,
внутри скобок пишется обычно селект-запрос. Подзапросы бывают нескольких видов, скалярные и
нескалярные, можно их, вернее, скажем так, есть даже как минимум два основания деления для подзапросов,
первое это скалярные и нескалярные, и второе это коррелирующие и некоррелирующие, и что это такое,
вот скалярный подзапрос, так, прошу прощения, да, скалярный подзапрос у нас выдает, мы уже об этом
с вами говорили, скалярный подзапрос, ну и в принципе даже запрос может быть тоже скалярным,
он выдаёт у нас одно единственное значение, одну, по сути дела, ячейку в таблице, нескалярный
подзапрос выдаёт множество значений, как правило, когда говорят о нескалярных запросах, их, во-первых,
так не называют, во-вторых, просто говорят запросы, во-вторых, подразумевается, что если запрос не
скалярный, то он, как правило, выдаёт не просто строку, одну, но строку из нескольких атрибутов,
а именно несколько строк. И даже более того, конкретно для того, чтобы использовать некоторые
предикаты со скалярными подзапросами, с нескалярными, прошу прощения, речь конкретно для них явно
идёт о том, что выдаётся значение нескольких строк в одном столбце. Подзапросы не коррелирующие
и коррелирующие, что это значит? То есть у нас подзапрос может быть связан с внешним запросом тем,
что он ссылается внутри себя на данные внешней таблицы. Как это происходит, сейчас мы с вами
посмотрим. Давайте ещё немножко скажем о том, что важно иметь в виду при связанном коррелированном
или коррелирующем подзапросе. Важно понимать, что такой запрос выполняется для каждой строки,
обрабатываемой во внешнем запросе. На практике оптимизация может быть определённой внутри
СОБД, её средствами, но в теории, грубо говоря, по стандарту нужно иметь в виду, что у нас,
по сути дела, получается как вложенный цикл за счёт связанного подзапроса. Ну, соответственно,
что это значит? Это значит, как минимум, в теории, что время потенциально может приобретать
квадратичное отклонение от нормы. Мы можем увеличить запрос, квадратично более ресурсоёмким
его сделать. Можно использовать подзапросами определённые предикаты. Вот они на слайде
приведены. Exists in, not in, any, some и all. Any, some сразу говорит, что это в принципе синонимичные
конструкции. Можно any, можно сам использовать. Понятно, вот последние два, последние две части
вот этой классификации. Это, в общем-то, аналоги логических кванторов. Существование,
всеобщенность. Exists, хотя, казалось бы, похож на тоже, на квантор, но немножко иначе работает.
In, not in. Вот, наверное, самое простое. То есть, когда у нас есть какой-то подзапрос,
выдаёт он список значений, и мы просто проверяем на то, входит ли наше значение из внешнего
запроса, из какой-то внешней таблицы, из таблицы во внешнем запросе, в тот список значений,
который нам выдал подзапрос в итоге. Что ещё можно, наверное, сказать и важно для вас понимать.
Некоторые вот детали, в принципе, это цитаты из документации, поэтому можете не то, что до слайда
заучивать, можно это, в принципе, найти и в собой документация по постгрессу, но вот такие реперные
может быть точки. На слайдах они будут, ознакомьтесь с ними, пожалуйста, имейте их в виду. Что здесь
важного? Выполнив запрос Exists, у нас система проверяет, возвращает ли он строки в результате.
Если он возвращает минимум одну строку, результат Exists будет true, если не возвращает ни одной, false.
Запрос может выполняться не полностью, и как и остальные подзапросы, кстати говоря, это важный
момент, потому что, соответственно, у нас, если вы рассчитываете на пробегание, условно, каким-то
курсором по всем данным, которые у нас под запрос должны были бы попасть, то этого может не быть.
Здесь аналогия такая, наверное, напрашивается с работой этих логических операторов. Когда мы там
OR или AND используем для некого ускорения, когда мы знаем, что у нас может быть вычислено только
в OR одно значение, если оно будет истинно, то этого будет достаточно, чтобы вычислить значение всего
выражения. Примерно здесь то же самое. Если у нас одна строка хотя бы возвращена, то уже будет true.
Поэтому, грубо говоря, в принципе это может быть оптимизировано внутри так, что у нас Exists
будет возвращать просто одну строку и все. Грубо говоря, повторюсь, это не значит, что Exists
всегда отрабатывает только по одной строке. При использовании предиката еще Exists нас не
интересует значение, возвращаемое, как правило, не интересует. И 10 исключений, опять же. Можно указать
после Select произвольные значения вплоть до Select false или Select null. И запрос все равно отработает,
потому что как таковой Select не будет по сути что ли отрабатываться. Почти никогда не будет
отрабатываться, но есть исключения, повторюсь. In, not in здесь, в принципе, все тоже, наверное,
довольно просто. Может быть даже интуитивно просто проверка на вхождение значения во множество
значений. При этом множество значений у нас возвращается под запросом. И вот у нас, смотрите,
ограничение здесь уже есть явное, что в правой стороне этого выражения в скобках задается
запрос, который должен возвращать ровно один столбец. Но именно столбец и в принципе здесь
может быть скалярное выражение, да, но если это не скалярное выражение, не скалярный результат,
то один столбец, но множество строк будет в столбце. И возможность возвратить одну строку с
несколькими атрибутами не допускается. Вычисленное значение левого выражения сравнивается со
значениями во всех строках, возвращенных под запросом. Результатом своего выражения in будет
true, если строка с таким значением находится и false в противном случае. Not in работает зеркально,
но наоборот, или зеркально наоборот, но здесь true будет, если находятся только несовпадающие
строки. То есть если хотя бы одна строка совпала, то результатом уже будет false для not in. Также
для null определенные особенности, но об этом мы тоже с вами в принципе говорили и затрагивали
эту тему для проечной логики, когда разбирали как действуют операторы. И запрос может выполняться
не полностью. Опять же. Да, any sum. Повторюсь, это синонимичные конструкции. Опять же, похоже это
на кванторы всеобщенности. Вернее, существование в данном случае, на квантор существования,
конечно же, также у нас ровно один столбец должен возвращать под запрос, и вычисленное значение
левого выражения сравнивается со значением в каждой строке результата под запрос, с помощью заданного
оператора. То есть у нас еще выражение any sum и под запрос, а между ними еще и дополнительно какой-то
оператор. Например, какой-то логический оператор, который у нас true или false будет выдавать. Сейчас
посмотрим уже на примерах. Пока немножко скучный, может быть, и уж точно сухой из теории, но,
по крайней мере, чтобы у вас было это на слуху, я думаю, что нужно это проговорить. Опять же,
синтаксис выражения оператора all и под запрос. То же самое, что с any sum,
та же синтаксическая конструкция. Тоже допустим оператор между, ну, даже обязательный оператор
между выражением и предикатом all под запрос возвращает ровно один столбец. Из интересного,
наверное, конструкция not in равнозначно такой вот записи, когда не равно all. И тоже, опять же,
запрос может выполняться не полностью. Хотя, да, казалось бы, all, но исходя из внутреннего устройства
в данном случае Postgres, поскольку это именно разъяснение документации Postgres,
получается, что нужно быть с этим аккуратным. Это не значит, что у нас будет какой-то логически
некорректный результат. Это значит, что у нас нужно аккуратно обращаться с под запросом внутри,
который будет ссылаться на какие-то генераторы последовательности, например. И вот с такими
вещами более продвинутыми там могут быть определенные проблемы за счет того,
что вычисления происходят в момент выполнения, и одни правила накладываются на другие, скажем,
вот так вот, общего. И поэтому просто не рекомендуется закладываться на стопроцентное
вычисление отложенных каких-то функций, которые могут фигурировать под запросе.
Ну, это более сложные вещи, мы их касаться в принципе на курсе не будем, но вот просто имейте
в виду, что такое может быть. Так, Select под запрос скалярный как-то вообще выглядит,
что происходит. Результат скалярного произведения под запрос единственное значение,
и вот будет представлена единственная запись. Здесь, конечно, это все искусственно,
это простые примеры, и они за счет этого... Примеры на простом материале не за счет этого,
конечно, искусственно выглядят, но зато, я надеюсь, более, может быть, наглядно будет за счет
простоты обращения к единственной таблице. Вот под запрос у нас внутренний Select мы здесь
однозначно установили по атрибуту имя, то у нас имя должно быть Ольга Кузнецова. У нас только
одна запись такая в нашем отношении, поэтому у нас под запрос будет скалярным. Скалярным он
становится, потому что мы выбираем только один атрибут с employee ID, и дальше уже по
эквивалентности находим жалование Ольги Кузнецовой за работную плату. Конечно,
можно было сделать проще, можно было бы просто employee ID, или можно было не employee ID поставить,
а поставить name Ольги Кузнецовой. Ну вот, повторюсь, это намеренный искусственный запрос для
большей наглядности, какой-то дидактичности, что здесь, по сути дела, нам главное понять,
что вот вычисляется единственная ячейка, единственное значение. Под запрос не скалярный,
предикат IN, результат не скалярного под запроса множество значений, и у нас вот здесь прям
наверчено-наверчено мы рассчитываем среднюю заработную плату для тех сотрудников, у которых
средний возраст, вернее, у которых возраст выше среднего по условной нашей компании.
Вычисляем, опять же, я не призываю вас писать так, да, это просто для наглядности, вычисляем
средний возраст, после этого вычисляем множество значений, которые у нас будут
больше среднего возраста. Вот у нас показано всё это поэтапно, на слайде справа. Вычисляем
средний возраст, это самый глубокий селект, потом селект второго уровня, ну следующего,
до следующего уровня вычисляет у нас множество значений, которые больше 35 лет,
и дальше мы уже просто высчитываем средние жалования для этой группы сотрудников.
Здесь вот у нас опять же синтаксис приведения типов, обратите внимание, и на самом деле,
если бы у нас было не приведено, тип бы не был приведен к целочисленному значению,
у нас здесь была бы шестерка в периоде. И повторюсь, у нас приведение отрабатывает,
по сути дела, в данном случае как округление, а не как отбрасывание чисел после разделителя,
да, после запятой нашей. Exist, выбираем всех сотрудников, работающих в департаменте IT. Вот
таким вот образом замысловатым мы это делаем. Что здесь, на что важно обратить, у нас запрос
не скалярный, в чем это выражается. Вот у нас ссылки на внешнюю таблицу из конструкции WHERE,
T1.Department равно IT. Вот T1 мы качество псевдонима использовали при объявлении таблицы,
при указании таблицы в конструкции FROM, и T2 мы псевдоним используем для той же самой таблицы,
но для того, чтобы явно нам делать пересыливание, явно ссылаться на таблицу хоть одну и ту же,
но тем не менее, поскольку у нас, по сути дела, будет прохождение по одной таблице дважды,
сначала мы проходимся во внутреннем цикле по ней, а потом еще и во внешнем цикле. Мы,
соответственно, в разные переменные, грубо говоря, загоняем нашу таблицу. У нас во внутреннем
подзапросе для каждой строки из внешнего запроса будет отрабатываться вот это условие
логическое. И что здесь важно понимать? Важно, наверное, вот что. Если мы, вот здесь обратите,
у WHERE у нас T1-департамент, из внешней таблицы департамент должен быть IT, и из внутренней
таблицы департамент должен быть IT. Если мы уберем значение для внешней таблицы,
вот скажем, казалось бы, зачем нам именно совпадение для того, чтобы найти всех сотрудников IT-департамента,
давайте просто во внутреннем запросе сделаем SELECT, найдем все департаменты, где у нас будет IT,
и замечательно. И, наверное, вот так у нас как-то отработает. Нет, ребят, не отработает,
потому что Exist у нас возвращает true, ну, более высотачение, true или false для выражения под
запроса. Поэтому здесь у нас, да, у нас здесь будет действительно только там три наших строки,
первая, пятая и девятая в подзапросе, и Exist выдаст у нас true, потому что внутри под запрос
нашлись строчки. Но поскольку у нас нет никакого ограничения внутри под запроса, у нас все,
у нас вот это вот WHERE-условие будет всегда истинно для всех строк из таблицы new employees,
поэтому у нас все сотрудники попадут в результирующий запрос, хотя мы, вроде бы,
казалось, какое-то условие даже поставили. Нам нужно именно условие, что внутри под запроса
для каждой строки из внешнего запроса будет отрабатывать логическая проверка. Если этого
не будет, вот, повторюсь, будет такой результат. Что мы теперь делаем? Теперь мы пробуем
нисколерный запрос с квантором существования. Что мы хотим? Мы, по сути, в данном случае
исключаем работников с минимальным жалованием. Как это работает? Мы в подзапросе нашем Any,
мы выводим все жалования по столбе с заработной платой по всем сотрудникам, и мы смотрим для
каждого сотрудника, для каждого сотрудника его заработную плату, и указываем, что она должна
быть больше любой другой зарплаты из нашего подзапроса. Поскольку у нас минимальная плата
это 50 тысяч рублей для целого ряда сотрудников, то получается, что те сотрудники, которые ее
получают, они не попадают в наш запрос, потому что у них вот это условие не отрабатывает. Их 50
тысяч рублей заработной платы не является больше ни одной строки, ни одного результата,
ни одной другой заработной платы из вот этого столбца. Поэтому у нас Any не отрабатывает для них,
отрабатывает для 60 тысяч рублей, потому что есть строки, которые меньше 60, это вот 7, 8, 9, 10,
отрабатывает, очевидно, для 70 тысяч рублей. Потому что для 70 тысяч рублей, да, это все остальные,
у нас только два значения 70, это 3 и 5. Все остальные строки со 2 по 10, кроме 3 и 5, они меньше 70,
они тоже соответственно валидируют нам вот это вот условие. Так, выберем работников с максимальной
зарплатой. То есть здесь мы до этого откидывали с минимальным жалованием, а теперь давайте попробуем
выбрать с максимальной зарплатой. Но вот кажется, кажется, что, наверное, мы могли бы использовать
квантор всеобщенности, использовать All. Что бы у нас получилось? У нас бы получилось,
что буквально, да, вот как это можно прочитать, что для всех, для всех тех результатов, для всех
тех объемов заработной платы, размеров заработной платы, где заработная плата конкретного сотрудника
больше любой другой заработной платы в таблице, да. Но так вот, косноязычно по-русски это звучит,
к сожалению. Казалось бы, вроде бы, должен получиться нормальный результат, но нет,
не получится, потому что на самом деле у нас условие вот это некорректно сформулировано,
потому что заработная плата в 70 тысяч рублей не больше всех остальных заработных плат. То есть
она больше 50, больше 60, но вот те же 70 тысяч, они у нас попадут в подзапрос, будут в промежуточной
результирующей таблице, где будет все вот эти 10 значений. И на этапе сравнения 70 тысяч рублей
с 70 тысячами рублями у нас оператор больше не выдаст нам значение истины. А если мы поставим
больше или равно, то у нас все получится, потому что как раз по равенству у нас будет истинное
значение при сравнении 70 с 70. Почему 50 при этом не попадет в результат, потому что у нас 50,
конечно, равно 50, но у нас 50 не больше иных значений, не больше 60, не больше 70.
Ну вот так. Вот на этом у нас, в принципе, все с подзапросами в общем виде, с агрегатными
функциями. Вопрос в чате. Да, ребят, скалярды очень, смотрите, все довольно тривиально.
Вот давайте здесь посмотрим подскалярдный запрос. То есть у нас скалярдный запрос это
буквально одна ячейка. Если у нас на выходе одна ячейка, не одна ячейка там в каждом столбце,
а именно одна ячейка в одном столбце, то это скалярдный запрос. Ну подзапрос, если говорить в контексте
темы подзапросов. Вот скалярдный результат, вот скалярдный результат, вот это уже не скалярдный
результат. Для чего это нужно? Для того, чтобы нам по классификации раскидывать, как у нас
функционируют те или иные предикаты, которые мы можем использовать, те или иные конструкции.
Ну если со скалярдным подзапросом здесь, наверное, нет какой-то явной сейчас подоплеки. Ну там,
правда, есть у вас есть точно в семинарах табличка, в каких местах можно какие подзапросы использовать.
Вот для этого классификация эффективна. А с точки зрения скалярдной и не скалярной,
а с точки зрения того, что мы прямо сейчас здесь видим, запросы коррелирующие и некоррелирующие,
здесь эта классификация имеет смысл для того, чтобы нам понимать, как у нас будет, по крайней
мере, по стандарту отрабатывать SQL-запрос. По стандарту связный подзапрос, то есть ссылающийся
на внешнюю, на таблицу из внешнего запроса, будет отрабатывать как вложенный цикл. Соответственно,
что у нас происходит со временем выполнения? Оно возводится в квадрат. Вот цель классификации
такова. Цель классификации скалярды и не скалярды, повторюсь, где можно использовать,
где нельзя. У вас в семинарах есть прям большая красивая табличка. Ну давайте,
наверное, я ее вставлю в лекциях, слайд просто добавлю, чтобы у вас тоже было для слайдов под
рукой, все в одном месте. Но, в принципе, кажется, что это, наверное, как-то, знаете,
так даже может быть полуинтуитивно. Просто попробуйте, потренируйтесь на различных
подзапросах, в принципе, вариантов тренировок множества. Опять же отсылаю у вас тестовые базы
данных на сайте PostgresPro, в их разделе «Обучение». На целый гигабайт базы данных можно поиграться,
посмотреть, как что будет отрабатывать и построить какие-нибудь интересные, посмотреть на какие-то
интересные поднагодные данные в виде выдачи планировщика. Макс и Мин, в последних двух
примерах это вы имеете в виду All и Any, видимо. Или вы имеете в виду, ну да, получается,
All и Any. Да, в принципе, можно. Единственное, смотрите, вот здесь, когда мы хотим найти
работников с максимальной зарплатой, мы можем сказать просто salary больше и равно какой-то
вот max и там вычислить максимальное значение. Опять же, там будет max, максимальное значение
внутри телек запроса, внутри подзапроса. Мы можем использовать, да, безусловно. И мы получим,
в принципе, такой же результат. Вот здесь, вот здесь нам нужно будет переделывать запрос,
чтобы исключить работников с минимальным жалованием. Хотя нет, вы знаете, да, здесь тоже, в принципе,
можно. Ну, повторюсь, в данном случае, наверное, вот такая избыточность SQL прям видна очень ярко,
потому что намеренно упрощенный пример, чтобы было вот так на пальцах понятно, что происходит.
В действительности, конечно, это не всегда верно. Просто у нас здесь числовые, по сути дела,
сравнения. Больше-меньше. Ну, в принципе, больше-меньше и будет, да, с числами. Но, в общем случае,
это будет все-таки не всегда equivalent. Так, хорошо. В общем, мы с вами разделались наконец-то
в Data Manipulation Language с общими его азами и основами. Дальше посмотрим с вами сейчас на основу
проектирования баз данных, сколько успеем. Продолжим эту тему уже, видимо, на следующем занятии.
Ну, да, не растягиваю удовольствие. Собственно, давайте с вами продолжим. Что такое проектирование
баз данных? Это процесс создания детализированной модели данных, базы данных, а также необходимой
ограничении целостности. Про модели данных мы с вами, в принципе, говорили раньше. Так, вопрос в
чате ищем. О, слушайте, но это зависит. Вопрос, как можно сооптимизировать запрос, чтобы высчитывать
каждый раз новый подзапрос. Это зависит от конкретного запроса. Вот так вот, в общем случае,
я бы не стал давать какой-то рекомендации. Я бы вам единственно порекомендовал попробовать
посмотреть, что происходит через планировщик, посмотреть вот методами EXPLAIN. Ну, мы будем об
этом еще говорить с вами чуть попозже. Можете прямо сейчас попробовать просто документацию
почитать. Там несложно, в большом счете. Посмотреть, что происходит внутри при ваших запросах,
в конкретных реальных запросах происходит ли реально итерация по вложенному циклу. Потому что
может быть конкретно в вашей ситуации, если это конкретный пример, а не абстрактный вопрос,
там не будет вычисляться по стандарту, как положено, каждая строка из внешнего запроса,
сравниваться с каждой строкой внутреннего. Повторюсь, вообще, я бы не стал просто отвечать,
потому что не факт, что ответ вообще можно такой общий какой-то дать. На то мы говорим с вами о
том, что это прям выделяется отдельно связанные подзапросы, потому что вот они вот такие. Это
стандарт, это вот так и есть. От них невозможно избавиться всегда. Если подзапрос не зависит от
строки, то в общем случае он не будет, опять же, он не будет внутри себя... Смотрите, давайте вернемся
с вами. Вот здесь у нас есть зависимость. Почему есть зависимость? Потому что вот здесь мы ссылаемся
на нашу таблицу из внешнего запроса. Поэтому у нас здесь будет не скаллярный, но связанный под
запрос с предикатом Exist. И здесь у нас будет каждая строка внешней таблицы. Внешне, да,
это такой, может быть, жирганизм, извините меня, таблица из внешнего запроса. Каждая строка таблицы
из внешнего запроса будет сравниваться с каждой строкой таблицы, которая у нас получилась вот в
этом вложенном селект-запросе. Здесь у нас, когда мы убрали ссылку, у нас просто получился вложенный,
не скаллярный и не связанный, по сути дела, подзапрос. Вот здесь пример неверного запроса,
неверного в контексте определения, не скаллярный, связанный, Exist. Здесь получился у нас Exist,
не скаллярный, но не связанный. Здесь у нас просто селект вычислится на этапе соответствующем,
в соответствующем порядке. И начнется с вложенного селект-вычисления, то есть from new in place,
where t2 department равно IT. Просто вот это вычислится и дальше пойдет вверх по восходящему стеку.
Ну, по стеку вверх, по восходящему стеку. По стеку вверх просто пойдет и все. А вот здесь не
получится по стеку вверх, здесь будет именно вложение. Поэтому еще раз проговорю, у нас вложенный
цикл получается только когда у нас связанная запроска, когда у нас есть явная ссылка из
внутреннего запроса на данные из внешнего запроса. Под внутренним запросом, да, понимается под
запрос, соответственно, то, что в скобках написано там селект, что-то там. Хорошо,
проектирование баз данных. Давайте быстренько с вами по каким-то наверхам пробежимся,
потому что уже немножко не успеваем, к сожалению. Что мы делаем, по сути своей,
простыми словами, мы пытаемся сделать... Нет, опять же, вот SQL с точки зрения функционирования
должен каждый раз высчитывать. Конкретно СУБД занесет ваш запрос в кэш, опять же, условно,
если он частотно повторяющийся, занесет его в кэш и с кэша достанет, посмотрит,
как она это делала, определит вот эти вот все пути, построит дерево запроса, деревья запроса,
определит наиболее оптимальные, наиболее оптимальные в данном конкретном случае,
исходя из загрузки узлов и так далее и того подобное, и только потом вычислить запрос,
и в общем виде, и в общем случае на практике, общий случай на практике, да, у вас не будет
постоянной квадратичной, да, квадратичного возрастания времени постоянного? Нет. Все,
к счастью, не так. Это достигается, конечно, тоже не прямыми такими методами, а скорее такими,
которые называются эвристические, что ли, до некоторой степени. Ну, за счет, по большому счету,
того, что, да, там какие-то данные просто будут храниться в памяти оперативной либо на диске,
и СОБД просто к ним обратится, поэтому чистая SQL будет читать заново, постоянно. Конкретная СОБД
имеет средство оптимизации, она ими активно пользуется, и за счет этого позволит избежать
заново пересчета. Опять же, Exist, для примера, да, повторюсь, он у вас отработает, в принципе,
если хотя бы какие-то строки попали в подзапрос, для каких-то строк он выдаст вам значение true,
если у вас хоть какие-то строки вы оказались в подзапросе. Ну, это уже да, если у вас нет
ссылки, это немножко не то, это получается несвязанный подзапрос. Скажу, наверное, уже в четвертый
или в пятый раз, если связанный подзапрос SQL по стандарту будет отрабатывать его внутренний
подзапрос каждый раз для каждой строки внешней таблицы внешнего запроса, СОБД может иметь
средства оптимизации, которые позволят сэкономить время и ресурсы. Но это надо смотреть конкретно
уже на статистику вашей базы данных, на то, как отрабатывает планировщик, какой план запрос
фонд строит. Хорошо, проектирование. Наконец-то, мы при проектировании пытаемся наши данные
организовать сообразно требованиям реалиционной модели. Ну, коль скоро бы в парадигме реалиционной
базы данных проектируем. Если мы взяли Neo4j, то, конечно, там мы можем чертить красивые графы.
По сути дела, то, что мы чертим, проектируем при работе с реалиционной моделью, тоже на самом
деле является графом. По большому счету у нас просто в вершинах нашего графа оказываются таблички,
а связи между ними, дуги графа, оказываются функциональными зависимостими, обеспечиваемыми за
счет ограничений первичного и внешнего ключей. У проектирования есть определенные задачи и надо,
наверное, самое главное понимать вот что. База данных наша, она не про хранение, не про
использование наименьшего количества, наименьшего объема жесткого диска. Это совсем не про то. База
данных про оптимальное хранение и работу с данными, про оптимальное манипулирование ими. В этом
смысле, сколько реально на диске места занимает ваша база данных, вопрос вообще вторичный,
и ваше база данных должна быть логически последовательна и подчиняться определенным
правилам. Последовательно спроектированно подчиняться определенным правилам не для того,
чтобы занимать, повторюсь, меньше места, для того чтобы при добавлении редактирования удалений
данных у вас не возникали аномалии определенные, о которых мы с вами сейчас поговорим. У проектирования
выделяют определенные шаги, ну, это такая, знаете, прям теория теория, здесь нет каких-то отражений
в конструкции СУБД, в том, как она функционирует, но принято выделять, вот, по существу можно это выделить
вот на такие этапы разложить, да, определение предметной области, определение взаимосвязи между различными
элементами данных, наложение логической структуры на основе определенных соотношений, создание
с проектированной БД с учетом особенностей используемой СУБД. А выделяют три этапа, концептуальное
проектирование, логическое проектирование, физическое проектирование, концептуальное самое
верхнеуровневое, ну, самое абстрактное, самое верхнеуровневое с точки зрения реализации на
конкретном программном обеспечении. Концептуальное это когда мы берем лист бумаги и начинаем, так
сказать, на нем, ну, уже не лист бумаги, конечно же, да, там, графические редакторы соответствующие
и начинаем в них красивые там фигуры чертить, между ними проводить линии с специфическими маркерами,
показывающими характер взаимоотношений. На логическом этапе мы добавляем уже ограничения какие-то,
да, привязанные к нашей реализационной модели моменты, ограничения вот о которых мы с вами
говорили, на типы данных, на какие-то значения, физическое проектирование тоже непосредственно
написание SQL-команда, SQL-программ, которые будут вашей СУБД выполняться и уже внутри нее будут
созданы корректные представления вашей модели данных. Первый шаг в определение данных,
ну, такая история, в общем-то, да, не имеющая каких-то формализмов, просто история о том,
что на практике необходимо какие-то вещи, какие-то вот данные, которые подчас могут даже сейчас,
да, даже сейчас на некоторых предприятиях, каких-то фирмах, ну, небольших, конечно, скорее,
храниться просто в Excel-овских таблицах, их нужно вообще понять, что это за данные, их как-то вот,
может быть, очистить предварительно, может быть, там определить вообще, насколько эти данные
сообразным образом хранятся и вникнуть в собственную предметную область, ну, хотя бы немножко,
хотя бы выделив основные сущности, основные абстракции, погрузиться в предметную область,
чтобы понимать, насколько, как эти данные надо разделять для оптимального хранения и последующих
операций с ними. Давайте мы попробуем с вами на примере посмотреть вообще, да, как можно описать
вот некую предметную область. Вот, ну, допустим, магазин Пятерочка, вот, можно выделить какие-то
сущности, типа каталога товаров, каталога складов, характеристики наполнения склада, планы поставок
и так далее. Для банка, например, Теньков, это сущности будут клиент, карты клиента, транзакции по
картам и так далее. Ну, для МФТИ тоже, да, можно какие-то сущности выделять, пофантазировать,
ну, это буквально, да, в какой-то степени, наверное, фантазия все-таки. Работа воображения,
по крайней мере, но все-таки, да, логический анализ имеет место быть. Вот студент, группа, преподаватель,
расписание пары экзаменов, это все как отдельные сущности можно себе выделить для начала и
попробовать построить уже какую-то концептуальную модель, используя более строгие, что ли, методы
и инструменты. Что мы делаем, что мы используем для того, чтобы спроектировать базу данных,
когда мы уже хоть как-то вот допоняли, что происходит с нашей предметной областью,
с чем нам предстоит заниматься, мы пытаемся с помощью ER-модели Entity Relationship Model
построить модель данных, описывающую основные взаимосвязи и впоследствии ее уточнить
необходимым образом. Нам нужны в модели две категории, это, собственно, сущности и между
сущности и между ними связи. Сущности – это наши будут вершины графа, связи – это его дуги,
и ER-модель выглядит, собственно, так, как показано на рисунке. Тариф, пластиковая карта,
операция – модель для платежной системы какой-то, для банка может быть. Понятно, она привитивная,
это исключительно в дидактических целях, реальная модель будет сложнее, будет иметь определенный
набор технических отношений, то есть необходимые для функционирования базы данных для того, чтобы
отслеживать какие-то изменения и так далее. На стадии концептуального проектирования это еще
и не нужно, технические какие-то данные, отношения для технических данных, но тем не менее,
это вообще-то примитив-примитив. Определение взаимосвязи. Нам необходимо, опять же, в нашей
модели каким-то образом показывать не просто дуги графа между вершинами, а нужно показывать,
что они еще имеют какую-то между собой… они между собой различаются. Для этого используется
так называемая аннотация воронья лапка. На слайде приведены примеры использования этой
аннотации. У нас в принципе связей между сущностями может быть несколько, но они,
наверное, довольно простые, на мой взгляд. Во всяком случае, после того, как вы проект свой курсовой
сделаете, я думаю, что для вас тоже это будет в целом понятная история. То есть, может быть,
один ко многим и многие ко многим и один к одному. Здесь у нас… это вот такие, наверное, основные
варианты связи, поскольку у нас все-таки ограничение первичного-вторичного ключей работает,
поэтому ноль или один, ноль или много – это более редкая история. Но вариантов здесь чуть больше,
больше выразительности, более выразительные средства предоставляет нотация. То есть, есть связь
многие – один ко многим, один и только один, один или ноль. В общем, вы это все видите на экране,
выглядит это вот так, стандартным образом. Концептуальная модель – ресторан, например,
можно ее обозначить следующим образом. Вот мы выделили несколько сущностей, между ними
графически обозначили некоторое количество связей, и, используя нашу нотацию, вороней лапки,
эти связи не версифицировали. На что здесь можно обратить внимание? Ну вот, например,
что значит заказ и блюдо? То есть у нас у одного заказа, вот эта дуга, что означает? Что у одного
заказа в одном заказе может быть одно или несколько блюд, а одно блюдо, оно может, как в несколько
заказов входить, так и ни в один заказ не входить. Ну что это значит ни в один заказ не входить?
То есть у нас, в принципе, есть какой-то перечень блюд, и не обязательно, что они соединены
с каждым заказом. Ну как бы понятно, у нас просто номенклатуры в меню есть, а заказ еще не сделан
на это блюдо. Или новое блюдо добавлено в меню, а заказов по нему еще нет. Так же, в принципе,
каждую связь здесь можно также объяснить. Ну давайте, наверно, может быть, один к одному
заказ и оплата счета. То есть у нас в одном заказе допускается только один счет, и один счет может
быть только в одном заказе. Ну здесь довольно понятно, наверное, хотя современные средства
предоставляют... Средства обеспечения деятельности предприятия общественного питания
предоставляют возможность разбивать счета и оплачивать несколько счетов в одном заказе.
