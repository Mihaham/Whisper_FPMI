Возвращаемся к кэшам, очень простая схема, мы сохраняем
в памяти результаты вычислений для того, чтобы не вычислять
еще раз.
Мы уже пришли к вам, с вами к тому, что у нас не просто
ключ значения, а ключ, а там какое-то махровое, какой-то
массивчик или хэшик, и там куча различных флагов,
еще что-то, еще что-то, и в том числе значений.
В эти флаги мы складываем информацию о том, а вдруг
мы сейчас что-то пересчитываем, а вдруг мы там что-то еще,
дата до какого числа это значение актуальное, ну
то есть куча различной информации служебной, да, то есть
это уже не просто, это массивчик, массивчик или хэшик, вы
же знаете все эти примитивные, да, массив, хэш, окей, проблема,
с которой мы ушли в прошлый раз, эти значения в кэше
оказались вдруг взаимозависимы, ну то есть, например, хэш,
ключ кэш, главная страница может включать в себя несколько
других кэшей, а те могут включать в себя еще несколько
кэшей, а те могут включать в себя еще несколько кэшей,
то есть зависит, да, то есть вот главная страница,
здесь у нас там, не знаю, логотип, там, не знаю, последние
новости, погода, новости спорта, да, и вот это вот
один кэш, вот этот другой кэш, это третий кэш, третий
кусочек кэша, да, а главная страница это вот тоже запись
в кэше, а вот этот спорт, например, он зависит там,
не знаю, от списка последних новостей в спорте и так
далее, и вот у нас, новости спорта..
и мы должны сбросить вот это, вот это, вот это и
так далее, то есть мы должны сбросить целый куст данных,
когда пришла одна маленькая, блин, новость спорта.
Вопрос, к которому вы ушли на наши затянувшиеся выходные,
это сделать? Как вот эту взаимосвязь отследить? Где ее хранить? Как нам запомнить о том, что при
приходе новой новости спорта мы должны сбросить какое-то количество кэшей?
Ну то есть ты представляешь, это означает, что когда ты будешь кэшировать главную страницу,
программисту нужно знать обо всем, что у него там внутри под ним лежит.
Вот она пока еще нигде не просматривается. А давай я тебе усложню задачу. Не просто спорты
новости, а программист новостного раздела принимает решение, что мы теперь к новости
подвязываем спортсмена. То есть меняется какой-то кусочек вот здесь, внизу, вот здесь, об этом не знаю.
Ну то есть хранить некое дерево зависимости. Окей, первый вариант. Мы храним дерево зависимости,
то есть каким-то образом это нужно придумать, как мы вот это все деревце отсюда сюда сюда,
оно будет там не знаю, оно будет сложным. Мы храним. И если происходит какое-то изменение,
мы поэтому дерево должны пройти и все сбросить. Все, что может измениться.
Ну в смысле мы по ней идем и сбрасываем вот это или как?
Вы не сможете так, я понимаю про что вы говорите, но тогда это дерево у вас не просто хранит
информацию о связях, она еще и хранит информацию о сути этой связи. Это я просто вам так сказал,
это последняя новость, а может будет какая угодна связь когда это может означать что вот
эта штучка включена в эту штучку, а вот этот связь может означать что если вот эта штучка
приходит, то вся вот эта штучка становится не важной. А вот это может означать что
если вот это вот это изменяется то здесь нужно добавить там не знаю синий цвет ну то есть как
без связь может быть какая угодно сложности нужно попроще как весь путь до корня да и все ничего
да все верно то есть как бы в варианте с деревом вы берете и выкидываете весь путь до корня есть
другой способ есть другие идеи чем плохо вариант потому что мы не знаем как конкретно вот это
вот это изменение вот этих данных повлияло на все остальные киши что нужно с ними сделать мы не
знаем но мы знаем что не зависит поэтому просто на всякий случай всех до корня выкидываем и
и рассчитываем на то что дальше наш программа сама разберется сама все перчатки в принципе
правильно рассчитываю чем плох вариант
да но мы эту проблему не решим если не будем залезать внутрь понимать смысл вот
это вот конкретно связи а мы не очень хотим но это правильно то есть как бы решение то есть
вы всегда будете когда вы будете разрабатывать решение всегда будете балансировать на грани
простоты и как бы и эффективности да и не факт что самое эффективное решение лучше потому что
самое эффективное решение вот в данном случае это разработать некий механизм где бы вы могли
там не знаю мета язык где вы могли бы кодировать что вот что конкретно как конкретно вот это вот
этот вот элемент киша влияет на этот элемент киша и как бы выполнять как бы осмысленная да вот
сбрасывать эту связь да то есть не просто все сбросить а именно как-то пересчитывать да насколько
времени вы на это потратите и как это будет работать сколько-то будет ошибок которые напишут
программисты которому поставить задачу это вы выпускники и у вас все хорошо вы крутые
ребятки а они-то я не знаю черти где учились но понаехали и как бы фигачить с ошибками кривый коз
конечно буду пересчитывать сюда это простое решение но не само
давайте чем плох вариант вас само наличие вот такого дерева не не смущает вот это вот
хрень которая через два года работы станет какой-то совершенно огромной сложной тяжело
поддерживаемой конструкции вот будет там я не знаю 5 уровней там я не знаю тысячи сущностей как
ее вообще банально редактировать как ее в памяти держать как ее вообще то есть как бы это должен
быть хорошо это означает что его в таком случае если каждое решение знает только про родителя
означает что при старте вашей программы как это фигня должна собраться кто-то должен все это
обойти ну или как или ты при каждом и где само дерево не сохранится каждый знает своего родителя
ну окей хорошо да или гонить проще согласен да ну ладно я хорошо все равно да то есть да то есть
при каких-то изменениях да то есть в чем чем плохая чем плохая эта история при каких-то
изменениях не ну дерево дерево
хорошая кстати история да это будет не дерево это будет у нас это будет не дерево это будет сеточка
поясни
это 100 процентов не дерево совершенно верно вот эта штука может влиять вот сюда вот сюда вот
сюда и приходит приходится к разным этим просто сеть сетка ну блин граф это может быть как угодно
главное чтобы не было стык и зависимости и мы не сломались на этом хорошо вам не
кажется что это все равно будет сложно поддерживать
потому что нам нужно кешировать не только главную страницу например страницу спорта и
страницу конкретной новости спорта для главной страницы используются кусочки из внутренних да
из других страниц короче есть такой вот способ да окей он немножко стрёмный потому что мы вот
можно действительно поймать здесь какие-нибудь кривые конструкции в виде какой-нибудь цикла
а может быть здесь есть какой-нибудь элемент который только для главной используется понимаешь
мы не знаем этого всего вот это сложно поддерживать и вполне возможно что когда-нибудь то есть смотрите
да то есть он знает своего родителя вот я вспомнил чем здесь проблема хорошо а теперь я беру и
переписываю вот эту страницу главную меняю ловят у меня структуру меняю и теперь я должен
просканировать весь блин мой код надо запустить истер который пойдет вниз да найдет мне подсветит
все те места где это потенциально использовав кто меня потенциально сбрасывает и переписать
давай
ребят это все да красиво но слишком сложно для киша
нет я про таймстэм поэтому уже и так храним чтобы понимать где что у нас живо что не живо я
говорю про то что у нас эти изменения могут идти не только вверх но и вниз я могу переписать
главную страницу сделать ее принципиально другой и теперь я должен просканировать весь мой код
который сбрасывает главную страницу и пересмотреть на каждый вот этих этих связей
заново а она сейчас по прежнему актуальной или нет и поддержка киша становится довольно сложной
историей есть более элегантное решение назовите мне его все с деревом забыли вы поняли все плюсы
все минус очень просто на поверхности но пока когда сайт начинает расти начинается с
проблемы и сложностей другое решение так развивай мысль
сама фраза подписываются на меня пугает понимаешь то есть давай по-другому
забудь не нет то есть как бы мы построить сервис по обслуживанию киша слишком сложно
проще посмотрите налог здесь мы пытаемся с вами в этом дереве мы пытаемся сохранить связи с
низу вверх а что если попробовать наоборот проще без шины проще и так мы пытаемся сбросить при
изменении листочка мы пытаемся сбросить все потенциальные элементы дерева которые от него зависит
так
услышали давай еще раз
смотрите а поменялась структура это нас как главную страницу не волнует потому что
главная страница знает только про свою структуру у нас структура главная страница она проверяет
себя мои элементы не протухли если мой элемент протух ты его грубо говоря вызываю и говорю тупо
проверь себя а он уже знает сам про себя все и так далее и так он спустит до всех протухших
элементов при показе при показе точно также как и да то есть это вот этот история она нас
составляет то есть мы при изменении элемента вот здесь внизу мы сбрасываем все киши предлагаем
противопал как бы другая логика есть то есть смотрите по ключу хранится
тоже сам массивчик в этом массивчике кроме значения есть список так называемый это то что вы
сейчас назвали это называется системы тегирования кишей то есть есть хэш который описывает что
вот этот конкретный ключ зависит от ключа 2 ключа там и не знаю 15 и там не знаю еще ключа 24 при
этом когда вот это значение вычислялась ключ 2 имел таймстэп такой-то ну то есть время да такой-то
ключ 15 имел таймстэп не знаю какой-то ключ 24 имел таймстэп такой то есть это некий слепок
что было какие были значения у вот этих вот составных частей да то есть насколько какие они
были когда они были вычислены какая была версия актуальность здесь можно и таймстэп писать
можно списать версию версия 1 версия 2 версия 3 да и тут просто значение версии его просто
и теперь проверка нас усложняется мы поднимаем по ключу вот эту вот конструкцию после этого мы
смотрим ключ 2 идем в тот же самый кэш и смотрим какой текущий текущий таймстэп у ключа 2 если
он такой же значит с этим ключом все в порядке время нет таймстэпе находится время вычисления
время актуальность
давайте ответим на этот вопрос должны ли мы нет подожди она по таймеру это в нормальном
режиме а как нам понять что она не стухла
если кто-то под ключом вот смотри вот у нас вот этот у нас просто ключ на вот
это вот у нас там и ключ 2 если кто-то вот здесь обновился нам мы по идее должны пойти вниз
да это если уже обновился а если что-то
под ключом 2 обновилась у нас была проблема не со временем работы да у нас была проблема
с поддержимостью этой штуки короче логика верна да то есть формально мы должны пойти вниз то
есть если мы хотим прямо абсолютно честно мы должны дойти вниз до конца люди с этим мухлюют
немножечко да как мухлюют но то есть мы поняли да как как эти вниз но смысл не как эти вниз а
логику поняли да то есть грубо говоря у каждого составного элемента проверяется когда он был
вычислен если у нас в кэше лежит информация о том что тех пор этот конкретный ключ обновился
это значит что вот это тоже уже не актуально и это тоже нужно пересчитать поняли это поняли да
придется
он куда-то включается тоже наверное ну вдруг не сюда но какой-то другой
страничку включается естественно иначе это не иначе она тогда не нужно вообще да то есть
он где-то тоже используется на какой-то страничке он тоже используется и когда-то он тоже обновится
мы не все дерево мы обходим все дерево который от нас зависит да короче совершенно правильная
прозвучала фраза зависит от того какие у нас требования если нам нужно показывать абсолютно
актуальную информацию нам нужно обходить все дерево
не подожди подожди не совсем так
смотрите
у нас ссылки на валидность невалидность у нас не ссылки на куски данных грубо говоря то есть
то что вот этот ключ зависит от ключа 2 15 и 24 не значит что вот это значение является суммой
значений 2 15 и 24 понимаете
это вовсе не не гарантирован то есть грубо говоря у нас главная страница зависит от времени
поступления последней новости зависит зависит страница спорта зависит от времени поступления
последней новости зависит но это не значит что вся страница спорта включена в главную
страницу нет да то есть нас это это некий просто как бы сигнал то есть как только столкнулись
тем что что-то невалидно цепочки просто пересчитываем вот это значение все оно там уже
в процессе пересчета где-то там что-то обновится и все эти ключи пойду да но вернее как мы когда
будем пересчитать вот это значение мы запишем новые значение новые темпы для ключей и все
следующий раз мы просто не сломаемся то есть вот эта штука это у нас она исключительно сигнал
о том что что-то протухло почему скорее всего очень часто вряд ли кэш будет часто перечислить
он не имеет смысла если он будет часто пересчитывать вот поэтому поэтому
используются небольшие хаки сейчас вам расскажу да то есть
да когда формируете вот эту главную страницу вы когда формируете вот этот ключ вы садитесь
думаете от чего он зависит и вы можете просто ввести некие пективные значения которые например
реально нигде не используется но для вас являются плагом например время последней новости вот ты
знаешь то у тебя главная страница зависит от того где что есть последнее но ты не знаешь где
конкретно она появится спорте погоде или то не знаю в политике или еще где-то то есть
ты вот как бы конкретное дерево но не не туда с конкретной конкретной цепочку ты не знаешь то
есть не важно тебе просто если появилась новость она изменилась то это Notice,
что главная страница изменится.
То есть мы провели броу же в 12 минут.
Да.
Погнали цепить есть.
Если надо будет какой-то подключить
софтпорт, то мы бы правильно
разобрали броу же.
Да, грубо говоря.
Даже не так.
Ты сюда провел.
Ты ввел некое значение.
Вот это у нас раздел.
Это последняя новость в разделе, грубо говоря.
Ты просто
вводишь отдельную сущность.
Последняя новость.
Да.
И проводишь ее вот так вообще.
Нет, ты прям
вводишь это вот прям, я поэтому и говорю,
ты вводишь эту фиктивную сущность.
И когда ты теперь сохраняешь новость,
ты меняешь
какой-то из вот этих вот значений.
И вот это.
Тогда новую новость сохраняешь.
Да.
Просто эта фиктивная сущность
сдается там, я не знаю,
время последней новости.
Нет.
Потому что если ты сейчас
я понимаю, что ты хочешь сделать.
Ты хочешь связать вот так вот сюда.
Это будет как бы канонически правильно
с точки зрения и так далее.
Но это хрен будет работать, потому что в этом случае
ты все равно будешь из главной страницы
проходить все под уровни,
а не только свойства.
А мы хотим именно вот этого
сбежать. Мы хотим уйти от конструкции,
когда мы должны будем вот здесь
идти в ключ 2 и проверять его валидность.
А потом идти
все его под ключи и проверять их
валидность, да и так далее.
Мы хотим от этой штуки уйти.
И в явном виде прописать в главную страницу
все, от чего она может быть зависима.
Да.
В месте сохранения,
в месте, где у тебя сохраняется статья.
Так, а
что ты так помнишь,
с того, что я тебе чинил,
ты видела или нет?
Нет.
Это как заказ кожаного?
Это как заказ кожаного, да.
Ну подожди, понимаешь,
то есть как бы эти новые данные тебе
где-то нужны. Да, то есть чисто теоретически
возможно, то есть это такая же
штука, вид сбоку.
Что вот это вот наша конструкция.
То есть чисто теоретически, вот сейчас
на главной странице, главная страница построена
таким образом, что ей
нужен вот этот вот фиктивный блок.
Время последнего, время последней
новости.
Через год пришли новые
программисты, главную страницу переписали.
Им вот этот блок уже не нужен.
Но ребятки, которые
пилят редакторский интерфейс,
возможно об этом никогда и не узнают.
И продолжают поддерживать этот фиктивный блок.
Да, такая же жопа.
Вид сбоку.
То есть в этом случае,
в варианте подъема вверх по дереву
мы
как бы нам это сложно поддерживать,
потому что при изменении
этой сущности мы должны пойти вниз.
И здесь по большому счету точно так же.
При изменении
этой сущности
мы должны
те фиктивные блоки, которые используются,
все фиктивные ключи,
мы должны каким-то образом
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
выборке мы должны доходить до дна каждый раз либо вот такие вот хаки в виде того что блин
водится какие-то эффективные сущности которые используются только для сброса кишах по большому
счету последняя новость но вот такая вот сущность или погода погода там не знаю температура изменилась
температура то есть то есть такая же конструкция будет у нас будет температура в москве санкт-петербурге
я не знаю в яреване еще где-то еще где-то еще где и в нормальном варианте у нас меняется например
погода только в москве у нас меняется вот это вот и сбрасывается потихонечку и главная
страница сбрасывается только в случае если мы в москве если пользователи в москве но мы
можем придумать какую-то другую конструкцию мы можем придумать ими не знаю погода последняя
которая будет бросиваться некие ключи которые сбрасываться каждый раз когда изменилась хоть
какая-то погода хоть где-нибудь и писать его сюда нет просто вот вот просто берется пересчитывать
значение еще раз то что у тебя вот этот вот ключ зависит от вот отсюда отсюда и отсюда не
означает что у тебя вот это значение физически состоит из вот этого вот этого и вот это это не
не обязательно все равно не обязательно как бы то есть нет да вполне возможно что где-то у
тебя внутри вычислений твоего кода эти значения будут использоваться это сигнал о том что вот эти
данные вот эти данные зависит от вот этих все как-то зависит ты не знаешь как если ты
сейчас будешь еще и про это думать ну блин совсем закопать как ты используешь их не обязательно
нет и вот это начинаешь вот это начинаешь пересчитывать ну вот давай вернемся к спорту
вот смотри появилась последняя новость последний появилась последняя новость спорта последняя
новость спорта используется в ключе 2 это главная страница раздела спорт и есть ключ это главная
страница сайт еще у тебя появилась последняя новость в спорте да это эффективная сущность
поменялась потому что последняя новость поменя色 так и вот и вот у тебя есть ключ 2 это
главная страница спорта и ключ это главная страница и те и это стране и эта страничка и
и эта страничка зависит от того, что у тебя новость
в спорте.
Но это не значит, что у тебя главная страница включает
в себя спорт.
Тебе не нужно спорт пересчитывать.
Ты его пересчитаешь тогда, когда будешь валидировать
ключ два.
В валидации ключа два тоже будет написана вот эта
ссылка на эту фиктивную сущность.
Главную страницу ты пересчитаешь.
Зачем?
Не факт, что ты, то, что ты человек пришел на главную
страницу, это не значит, что он тут же пойдет на
страницу спорта или кто-то вообще спорт смотрит.
Спорта нет, зачем?
Да, зависит от того, как конкретно вы построите этот
самый пересчет.
То есть, смотри, если, вот допустим, вот у тебя главная
страница.
Допустим, она у тебя состоит из вот таких вот, вот это
последние новости из спорта, вот это последние новости
из политики.
В спорте появилась новая новость.
Соответственно, протухла вот эта страница.
Протухла страница спорта.
А страница спорта выглядит как последние новости о
футболе, последние новости, не знаю, о баскетболе.
И вот эта страница.
Появилась новая новость о спорте, протухли две вот
эти странички.
Их обе надо пересчитать по большому счету.
Но сейчас у нас пользователь пришел сюда, и мы вот занимаемся
выводом вот этой страницы.
Мы начинаем пересчитывать.
Дальше мы понимаем, что где-то у нас фиктивный
ключ, который называется, не знаю, ТЛАСС, вот он протух,
все, помер.
А, соответственно, вот это все невалидно, нам нужно
пересчитать.
Начинаем пересчитывать.
Поехали.
Вот дальше, как построено наше вычисление.
Если оно построено грамотно, то по большому счету будет
вызван какой-то метод, который...
