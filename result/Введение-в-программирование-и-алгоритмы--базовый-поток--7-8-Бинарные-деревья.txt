Мы начинаем разбираться с вами с деревьями.
Деревья. Тогда вводим следующее определение. Первое определение, которое нам понадобится,
это что такое граф? Граф. Это просто пара из V и E. Где V? Где V это конечное множество,
мы рассматриваем на конечный граф. Конечное множество, которое называется вершинами,
которое называется множеством вершин. А E? Что такое E, скажите?
Упорядочное множество ребер. Упорядочное множество ребер. Но по факту это некоторое бинарное отношение
между вершинами,
которое называется множество ребер. Мы будем полагать этот граф именно в таком плане,
что у нас просто есть какие-то вершины и у нас есть какие-то ребра. Самое обычное представление
графа, я думаю, вам понятное, просто нарисовать что-то такое и для вас будет вот это граф.
Вот это есть множество ребер, я их напишу как маленькие элементы E, а это множество вершин.
Но так как мы будем говорить именно о деревьях сегодня и алгоритмах графа,
хотя действительно у вас там будет чуть позже, то мы должны понять вообще что такое дерево.
Следующее определение. Дерево это связный ациклический.
Смотрите, если у меня нет в графе каких-то циклов, то мы считаем, что это дерево. Вы можете
видеть в разных источниках немножко по-разному, что это не ориентированный или ориентированный
граф. Мы на этом не зацикливаемся, мы все же будем считать, что это будет ориентированный граф,
но так как, например, если вы будете учить по кормону, там сказано, что это не ориентированный граф,
то я точного вот именно этого момента не буду вам говорить. Но что касается дерева. Дерево выглядит
вот примерно следующим образом. Это просто ациклический какой-то граф. Вот это дерево и все.
То есть воспринимаете дерево просто как висячую такую штуку, в которой что-то есть. Однако
деревья бывают на самом деле разные. И вот именно здесь и кроется такая вот штука,
которая связана именно с определением. Не у всех деревьев есть корень. Я думаю,
часть из вас понимает, что такое корень. Мы сейчас этим разберемся по факту,
что это так называемое корневое дерево. Давайте продолжим определение.
Корневое, корневое дерево. И определение нам сейчас просто очень много пригодится.
Главное, чтобы мы были в одной плоскости обсуждения. Корневое дерево это дерево,
в котором, сейчас будет самый гениальный мув с точки зрения определения, выделена одна вершина,
вершина,
называемая корнем.
Это в случае неориентированных графов. В случае ориентированных графов корень,
это не просто какая-то выделенная вершина, а корень это та вершина, у которой нет родителей.
Но так как мы еще не дали определение родителей и детей, мы сейчас тоже это напишем и напишем,
что для нас будет являться корень. Я обещаю, не будет сильно много определений, но они все нам
понадобятся просто. Следующее определение. Узел дерева. Давайте сразу поясню, что на английском
это нода. На всякий случай, чтобы если вы писали, вы не писали дек кучи разных способов,
но все неправильные. Давайте сразу будем английские слова еще учить этому всему. Узел это вершина,
вершина, дереве, корнем. Следующее определение, которое нам тоже понадобится. Мы сейчас все их
разберем на примере. То есть мы сначала все это запишем и увидим. Любой узел,
мы будем, любой узел, у на единственном пути, пути от r, это корень, у нас root, слово root,
до x, до x в дереве t, называется, называется предка, предка,
предка икса. Смотрите, что такое предок икса? Предок икса, это просто любой узел,
который находился чуть выше, если смотреть там от корня. То есть представьте, у нас есть к иксу
какой-то путь от корня, и мы по этому пути находим все вершинки, которые выше лежали нашу икса. Это
и будет наш предок. Определение, которое нам говорит о том, что такое, это по-английски предок
написано. Окей, определение следующее. Если y- предок x, то x потомок y,
вот здесь главное понимать, что такое потомок. Потомок все, что лежит ниже.
Окей, еще одно определение, сейчас мы скоро перейдем на примерчики. Определение следующее,
по деревам с корнем, с корнем в узле x, называется дерево, дерево,
порожденное, порожденное, порожденное потомками x.
Вот, это то, что нам понадобится. Еще понадобится несколько определений, связанных с тем, что такое
родитель, кто такой ребенок, степень вершины, глубина и так далее нашего там дерева и каких-нибудь
таких вот вещей. Давайте с вами это напишем и после этого как раз перейдем ко всему остальному.
Есть ли какие-то вопросы пока по этим определениям? Вроде все понятно? Да? Нет?
Как будет потомок на x? Потомок?
Отдесендует.
Правильно, сейчас напишу. Потомок. Здесь вот я сверху напишу.
Просто правильно их пишите хотя бы у себя в структурках данных, потому что иначе это будет грустно.
Просто сам. Сын.
Сын это другое, сейчас я объясню в чем разница. Предок и сын, потомок и сын, это разные вещи.
Это может быть дочь.
Это может быть внук скорее.
Так, ребят, окей. Смотрите, давайте с вами определим что такое вообще родитель и что такое сын.
Можете на секунду на предыдущий слайд перелеснуть? Да, конечно.
Вот последнее.
Под деревом с корнем возле x называется дерево, порожденное потомками x.
Давайте тогда перейдем дальше.
Окей, смотрите, если и при x, это последнее, ребро, ребро на пути, на пути из R корня.
Дерево в узел x, а то y, родитель, я надеюсь родитель вы знаете как по-английски это по-армянски, по отношению.
По отношению к x, а x это у нас ребенок, по отношению к y.
Вот, то есть смотрите, ну или дочерний узел здесь, когда как можно говорить, но в том суть, что мы будем называть родителем и ребенком только те вершины, которые рядом.
То есть нельзя говорить, что там, ну мы сейчас на примере поймем, в чем разница потомка и ребенка.
То есть ребенок является потомком, но потомок не является ребенком. Вот в чем все будет принципиально у нас разница.
Окей, и давайте все последнее определение, я понимаю, что их много, их все нужно запомнить, но я думаю они интуитивно все понятны на самом деле.
Вот, первое, количество дочерних узлов, количество дочерних узлов, дочерних узлов, узлов узла x, называется степенью.
Следующее определение, следующее определение длина простого пути.
А из корня r в узел x называется, называется глубиной узла x.
Если вдруг я где-то не очень, вы не понимаете, что я написал, говорите, вот, я вроде бы все все проговариваю.
Вот, и последнее определение, которое нам еще понадобится, высота, высота дерева, высота в дереве равна количеству, количество ребер.
Ребер в самом, самом длинном, простом, простой путь, бывает непростой.
Смотрите, если мы рассматриваем, грубо говоря, неориентированный граф, непростой путь, вот если вы по одному ребру вверх не ссури, мы ходим, вот добавили это, оно не сильно влияет на что-то, но путь увеличился.
Мы говорим, что степень, это количество сыновей или это вообще степень вершины, сколько ребер из нее выходит?
Степенью узла, степенью узла называется количество его дочерних узлов.
Ну, дочерних, то есть, исходящих из него.
Ну, то есть, это не степень вершины.
Это не степень вершины, все верно.
Степень узла это немного другое.
Вот, а так, в самом длинном, простом пути, я еще не дописал, ай-ай, сейчас, сейчас нет одной штуки.
В самом длинном, простом пути находящимся, нисходящим, да, все правильно, нисходящим, ну, то есть, проложенным.
Нисходящим от узла к листу.
Вот, узла, узла к листу.
Вот, это почти что последнее определение, которое нам нужно будет, вообще, в принципе, сегодня.
То есть, смотрите, мы должны познакомиться как раз-таки с самими деревьями, вообще, как они выглядят, что это происходит.
Давайте с вами нарисуем просто денег.
Что такое?
Хорошо, я сейчас не услышал вопрос, но относительно листа, лист, что еще раз?
Вы написали от корня к листу.
Ой, от корня к листу, от корня к листу, сори, давайте исправлю.
От корня.
Вот.
Прошу прощения.
Давайте с вами нарисуем просто обычное дерево.
Сейчас мы разберемся, что такое лист и так далее, просто иначе, если мы введем абсолютно все понятия, все будет очень громоздко в этом плане.
Лучше просто такие вот основные вещи понимать.
Представьте следующее, вот у меня граф.
Для меня я буду рисовать ориентированные деревья, ориентированные, почему?
Потому что так понятно, что является корнем.
Вот и все.
Предположим следующее, вот у меня есть вот такое вот дерево.
Пусть будет так, здесь будет вот так, здесь будет вот так,
здесь просто так,
вот так,
вот так,
вот по нему мы сейчас все как раз-таки поймем, что здесь происходит.
Вот, ну давайте обычно, ну деревья просто так, нам не интересны, просто какие-то рандомные вершинки и так далее.
Обычно в узлах хранится так называемый ключ.
Это означает, что там хранится какое-то значение, которое нам будет необходимо, и мы строим как-то дерево по нему.
Вот, мы сегодня построим два таких дерева, видим, что это будет.
Вот, ну предположим тут как-то рандомно, мы расставим числа 3, 10, не знаю, там 4, пусть будет тоже 10,
2, 8, там 12, не знаю, 1, 2, придут 6 и 9.
Вот, смотрите, что называется здесь корнем.
Корнем мы по факту будем называть вершину, у которой нет родителей.
У нее нет родителей.
Вот это корень.
Листы – это те вершины, у которых нет детей.
Вот то, что я сейчас выделяю, давайте оранженки будем выделять, просто вот это, вот это, вот это,
это, это и вот это.
Это все листы.
А на записание такое определение?
Главное, чтобы вы понимали это.
Что такое листы корень для вас?
Вот.
Листы – это те узлы, у которых нет детей.
Вот, смотрите, для вершины с номером, давайте пусть будет не 9, 10, 10, а тут примерно будет там, не знаю, 11,
чтобы могли их различать просто легко.
11.
Вот.
Смотрите, для вершины, например, с номером, ну, в которой лежит вот наш ключ 2.
8 для 2, давайте я прям так и запишу.
Для 2.
У нас две двойки.
Хорошо, тогда для 9.
Да.
Для 9.
8 является, является потомком, ой, предком, предком,
но не родителем.
Вот.
А вот 2.
А 2.
А 2.
Это у нас уже и родитель.
И родитель.
И предка.
Аналогично можно сказать, что для 7 девятка является предка, ой, потомком,
девятка является потомком для 7, но не является ее ребенком.
Для семерки, для семерки скажите мне, что является ребенком?
Какие вершины есть дети данной штуки?
3-11-4.
3-11-4, да, только у вас прям эхо из-за того, что вы рядышком, ну так ладно.
3-11-4, да, то есть смотрите, только то, что находится рядышком и то, что ниже.
Вот это будут, будут дети.
Именно это необходимо различать.
Помимо этого, смотрите, высота дерева, высота дерева, вот моего, вот оно.
Высота моего дерева здесь.
Высота.
У меня 4.
Почему?
Потому что самый длинный путь, раз, два, три, ну давайте вот так, раз, два, три, четыре.
Количество ребер у меня такое, если дерево состоит лишь из одного корня, его высота ноль.
Ребер нет.
А теперь, что касается именно глубины.
Глубина, давайте возьму здесь, к примеру, бордовый такой.
Глубина, вот на этом уровне, где у меня есть семерка, это ноль.
От корня до корня ребер лежит тоже ноль.
Вот на этом уровне, где у меня стоит 3-4-11, глубина один.
Глубина.
Глубина.
Глубина.
На вот этом уровне.
У меня это два.
На вот этом уровне.
У меня глубина три.
Здесь четыре.
Вот в чем вся корня.
Смотрите, по факту самая большая глубина есть высота, которая есть в дереве.
Это логично.
Вот, поэтому деревья очень часто изображаются именно в таком вот виде,
чтобы вершины на одной глубине находились на одном уровне.
Это удобно с точки зрения прокладывания путей и так далее.
Есть ли вопросы к этому сейчас?
Наверное, вопрос по пониманию определения.
Допустим, если у нас есть еще одна вершина,
которая у нее нет родителей,
то тогда у нас дерево только не было.
А где такую вершину взять?
Просто взять, добавить и, например, к четверке привести,
то тогда такое дерево перестанет быть корневым.
Сейчас.
Что делать?
Убрать вот здесь?
Нет, добавить на нулевом уровне вершину,
например, 12, и привести к 4 стрелочку,
то тогда такое дерево перестанет быть корневым.
Вот так, да?
Да.
Да, такое дерево перестанет быть корневым, да.
Спасибо.
Корень мы считаем один.
Угу.
Так.
Еще вопросы?
Только один сын может быть, ой, только два сына может быть, да.
У меня здесь три есть у семерки.
А, да, логично.
Количество сыновей никак не зависит от дерева.
То есть, если это случайное дерево какое-то,
просто именно дерево,
то у него может быть хоть сколько сыновей?
Может быть ноль, может быть эн, может быть два эн, и так далее.
Вот.
Родитель только один, правильно?
Родитель один, да.
Мы считаем, что да.
Вот только что этот вопрос задали,
и вы сказали, что будет два корня.
Прикол в том, что мы от новой вершины направляли к четверку.
Да, да, от новой вершины.
А, понятно.
Вот, ну, родитель, мы будем считать...
Если еще одно, то это не является корня.
То есть, от четверки.
Что еще раз?
Если мы не от новой к четверку, а от четвертой в новую проведем,
это ведь все окей?
От четверки мы возьмем и здесь делаем вот так?
Да, да, да, я просто подумал, может быть...
Если так, то у него появится новый сын.
Да, понял.
Ну, типа, у него будет уже три сына, нет, один.
Ой, не два.
Еще вопросы?
Получается, степень каждого зла — это степень вершины минус один.
Потому что у нас как бы входящее ребро на ней не учитывается.
Смотрите, а степень вообще в ориентированном графе —
это не просто количество ребр.
Ну, вот если брать там дискоетовую математику,
степень в ориентированном графе там может считаться по-разному.
Чаще всего их разделяет уходящая степень и не выходящая степень.
По факту, по факту, здесь выходящая степень является степенью зла.
Понятно?
Окей, понятно.
Если бы это был неориентированный граф, то да.
Еще вопросы?
Отсутствует.
Отлично.
Тогда давайте с вами разберемся, а жду такое бинарное дерево.
Бинарное дерево.
Последнее определение относительно самого дерева.
Бинарное дерево мы зададим вообще рекурсивно.
Что такое бинарное дерево?
Бинарное дерево.
Ой, давайте синьки буду писать.
Какую бы я этого делала.
Бинарное дерево.
По-английски binary tree.
Вот.
Бинарное дерево t представляет собой.
Представляет
собой
конечное
множество
множество
узлов,
которые
здесь возможно один из двух вариантов.
Первый вариант.
Либо не содержит узлов,
либо не содержит узлов,
либо
состоит
состоит
из трех
не пересекающихся
не пересекающихся
не пересекающихся множество.
Первое это корневой узел.
Корневой
узел.
Второе.
Бинарное
дерево
называющееся
левым
под деревом.
Вот.
И последнее это бинарное дерево
называющееся
правым
под деревом.
Вот.
Важный вопрос.
Как может быть конечное множество узлов,
которые не содержат узлов?
Еще раз.
Бинарное дерево
это
конечное множество узлов,
которое
первое либо не содержит узлов,
либо состоит из трех не пересекающихся множества.
Ну типа пустое множество, это конечное множество узлов,
а
Ну, типа пустое множество – это конечное множество, Миша.
А, вы про это. Хорошо.
Ну да.
Я думаю, просто это два одинаковых эквивалентных определения просто.
Нет.
Что под этим всем подразумевается?
Оно задается так, смотрите.
Бинарное дерево – это по факту вы можете воспринимать чаще всего следующим образом,
что просто у каждого из узлов есть не более чем два ребенка.
Вот это будет для нас бинарное какое-то дерево.
А так нельзя было определить просто?
Есть проблема, которую я хотел бы, чтобы вы поняли.
А в чем проблема? Почему нельзя определить просто так?
Не более двух детей.
Ну, видимо, с неориентированными какие-то проблемы будут.
Может быть.
Могут циклы образоваться, которых нельзя.
Циклы могут образоваться, действительно.
То есть здесь много всего, чего может образоваться, если мы будем задавать просто как панаитию.
Здесь лучше всего рекурсивно так задать.
Давайте, смотрите.
Это у меня бинарное дерево.
Оно состоит из корня и двух под деревьев, которые являются тоже бинарными деревьями.
Почему?
Потому что у меня здесь есть, вот здесь в левом под деревья есть корень.
И у него есть то ли левое, то ли правое под дерево.
А непонятно какое это под дерево.
Здесь важно еще понимать – это левый сын или правый сын?
В бинарных деревьях это важно.
И вот когда я рисую таким вот образом, я не могу сказать, что это бинарное дерево.
Для меня еще и важен порядок.
Слева находится или справа.
Всегда помните об этом, что для того, чтобы у нас что-то здесь работало,
нам необходимо задумываться о том, что это левый сын или правый сын.
Потому что сама себе структура данных так устроена.
Понятно?
То есть, смотрите, здесь есть проблема.
Что непонятно – левый или правый.
Мы должны четко определять, какое это из сценарий.
Есть ли вопросы к этому?
Сами бинарные деревья.
Понятно.
Окей.
Тогда давайте сейчас кое-что еще запишем, потом у нас будет небольшой перерыв.
Делайте такой большой подзаголовок.
Это большая тема.
Бинарное.
Дерево.
Поиска.
Что такое бинарное дерево?
Поиск.
Что такое бинарное дерево?
Поиск.
У него следующее определение есть.
Бинарное дерево.
Поиска.
Не поверите, но это бинарное дерево.
Дерево.
Удовлетворяющее.
Следующему.
Своиство.
Если
Х
Узел
Бинарного дерева.
Поиска.
Бинарного дерева. Поиска.
Поиска.
С ключом К.
Хотя давайте с ключом.
С ключом К.
Еще раз, что такое ключ?
Ключ – это значение, которое содержит в себе узел.
Значение,
которое содержит
в себе узел.
То,
все
узлы
влево
под деревья
должны иметь ключи.
Должны
иметь ключи
меньше К.
А вправо
если мы говорим о том, что
эти ключи будут
как-то
уникальны, то есть они не будут повторяться,
то вправо мы будем говорить о том, что
больше К.
Но, естественно, есть такая возможность,
что будет что-то повторяться.
Пять и пять, к примеру.
То в этом случае вы должны решить,
это будет влево или вправо под деревью.
Здесь уже, как вы хотите,
больше К.
Вот.
Это важное
свойство бинарных
деревьев поиска,
которое нам
и понадобится, которое мы будем
больше всего использовать.
И перед перерывом
давайте сделаем следующее.
Как будет выглядеть вообще структура
узла
у этого
дерева поиска?
Давайте черную напишу.
Структура, которую мы будем с вами
использовать, структура,
ноды
будет очень похожа
на
разный список.
Единственное, что
у этой ноды
я пишу больше псевдокода,
поэтому здесь будет без кобыч,
у меня будет какое-то значение
ключа.
Это не обязательно int, поэтому я пишу здесь
любой рандомный тип.
Мелу или Чару вам нужно, или Флот,
или Бул, и так далее.
Вот. Он должен указывать
на левую,
на левого сына.
Он должен указывать
на правого сына,
на правого ребенка.
И
он по-хорошему...
Левого.
Так.
Для некоторых операций
необходимо...
Что еще раз?
Еще раз я пишу псевдокод.
Ребята.
Вы будете писать звездочки.
Я здесь поясню указатель.
Да.
Сына.
Сына.
Если кому-то не нравится, что это
сына, на дочь. Хорошо.
Ну или на ребенка.
Как вам больше
хочется. Вот.
Right.
Указатель на правого — это указатель
на родителя.
Указатель
на родителя.
Вот.
Это то, что касается вообще
того, как выглядит
узел у нас
в бинарном дереве поиска.
Ну и давайте я сейчас
нарисую одно дерево поиска.
И вы уйдете на перерыв,
думая о том, что является
это деревом поиска или нет.
Бинарным деревом поиска.
Так.
Пусть будет так.
Пусть будет здесь там
один.
Шесть.
Четыре.
Семь.
Десять.
Четырнадцать.
Двенадцать.
Пусть будет тут тринадцать.
Это влево сейчас.
Влево.
Тринадцать.
Вот.
Все. Давайте у нас перерыв.
Тогда в шестнадцать тридцать пять
мы продолжаем.
Что такое бинарное дерево поиска?
Я с вами вспомню.
Еще раз.
Бинарное дерево поиска.
Бинарное дерево поиска
удовлетворяет следующему свойству.
Если х – узел
бинарного дерева поиска
с ключом k,
то все узлы в левом под дереве
меньше,
имеют ключи меньше,
чем в нашем
дереве поиска.
В правом больше.
То есть, смотрите.
Я должен смотреть на каждый из
корней,
так сказать, под деревья.
Первый корень. Все
в левом под дереве,
то есть все в левом под дереве,
это вот в этом дереве,
должны быть меньше.
Удовлетворяет
все здесь
элементы меньше, чем восемь.
В правом по дереве
у меня все элементы
больше, чем восемь.
Отлично. Для корни это работает.
Необходимо проверить для всех остальных.
Для десяти,
к примеру, у него правое
под дерево – это 14,13.
Правое под дерево, значит,
в правом под дереве должно быть все больше.
14,13 больше 10. Все правильно.
А 13 является левым
под деревом, а 14.
Если это левое под дерево,
то там у нас как раз элемент
меньше 13, меньше 14.
Теперь смотрим на левое под дерево.
Можно вопрос.
Как для одного дерева,
как для одной
ветки потомков
определяется левое или правое?
Вот 13. Почему это левое, а не правое?
Потому что стрелочка левее направлена.
Я так изобразил, что оно слева.
В своей структуре
вы будете
указывать, что у вас есть
левый сын и правый сын.
Если 13 является левым
ребенком,
то в этом случае вы пишете,
что указатель left равен
на 13, на эту вершину,
а указатель right равен
now.
Понятно?
Вот.
Поэтому здесь
на самом деле все корректно.
Если левое под дерево также разобрать,
как и правое, то мы получим, что здесь
все корректно.
Это является действительно бинарным
деревом поиска.
Можно тогда вопрос по определению?
Да.
Мы ставили три условия, что три
непересекающегося множества.
Корневой узел, бинарное дерево слева,
бинарное дерево справа.
Может быть только бинарное дерево слева
или только бинарное дерево справа?
Потому что бинарным деревом
там помнишь условия, написано
пустое множество.
Спасибо.
Нет вопросов.
Хорошо.
Бинарное дерево поиска
достаточно полезная штука.
Когда под дерево единственное,
сложно сказать левое оно или правое.
Это правда сложно,
но я здесь специально
рисовал влево и вправо стрелочки
для того, чтобы можно было определить
то это или нет.
Сразу скажу, что в контрольной
скорее всего, я напомню вам,
что вас еще ожидает в конце семестра
контрольная по алгоритмам,
возможны такие вопросы,
а является ли это бинарным деревом поиска,
к примеру, или укажите
бинарные деревья поиска.
Может быть все что угодно.
Главное, чтобы помнить, что бинарное означает
два,
два потомка
и так далее.
Хорошо.
Смотрите, действия,
которые мы можем вообще совершать
со своим деревом.
И первое, что нам необходимо на самом деле,
это обход дерева.
Повторите, пожалуйста,
свойство бинарного дерева поиска.
В бинарном дереве поиска
для любого узла
в левом его по дереве
стоят все
узлы, у которых
ключ меньше,
чем у моего узла,
с которого я смотрю. То есть, если это корень
8, к примеру, я смотрю, то в левом его
по дереве все элементы меньше
имеют ключ,
а в правом все больше.
Вот.
Если у вас вдруг есть равные элементы,
они могут на самом деле здесь повторяться
в зависимости от вашей реализации
вашего бинарного дерева.
Вот. Вы можете отправить его либо вправо,
либо влево. Хорошо?
Окей.
Давайте дальше.
А равные элементы могут быть одновременно
из права и слева? То есть, например, у нас
родитель 5, и мы слева и справа отправим
пятерки.
Это не совсем корректно может быть.
Вот. Потому что
если вы определяете как это бинарное дерево,
лучше убрать не до сказаний, сколько раз
слева элементы все меньше, справа
не меньше.
Вот. Понятно?
Хорошо.
Окей.
Давайте с вами говорить об обходе
дерева. Обход
бинарного
дерева
поиска.
Первый обход,
который мы с вами затронем,
это будет
симметрический
симметрический.
Центрированный.
Его также называют
центрированный.
Но
обход
обход.
Это следующий обход,
обход дерева,
обход
узлов,
узлов
в отсортированном
порядке.
Обход узлов в отсортированном порядке.
Вот. Что это означает?
Давайте с вами вернемся к этому
дереву. И вот здесь вот будем как раз
таки все писать. Давайте я его еще раз нарисую.
Только маленьким.
Такой зеленый.
Восемь.
Там у меня было здесь три.
Здесь было один.
Здесь было шесть.
Здесь
четыре. Здесь
семь.
Здесь у меня был правый из
десяти.
Потом был правый из четырнадцати.
И левый сын.
Это четырнадцать.
Давайте я перепишу, чтобы точно видно было.
Четырнадцать.
И здесь у меня был тринадцать.
Как необходимо обойти
дерево для того, чтобы
был порядок
возраста в отсортированном
порядке?
И пройтись вот таким
образом.
Вот так, вот так,
вот так, вот так.
После чего
мы идем вот сюда,
сюда, сюда.
Сюда сначала.
Потом сюда. И вот здесь закончим.
Смотрите, вот здесь
когда у меня есть выемка,
мне считает четырнадцать.
И вот здесь у меня не считает шесть.
Это не считается.
Чего у меня проходит?
Показывайте вершины, какие
трубы.
Нам необходимо,
чтобы наш алгоритм
обхода вывел
следующую последовательность.
Давайте сейчас. Один,
три, четыре,
шесть, семь,
восемь, десять,
тринадцать и четырнадцать.
В отсортированном
порядке.
И это можно сделать.
Это не очень сложно с помощью рекурсии.
Вот.
Что такое
вот этот вот симметрический
подход? Смотрите.
Нам необходимо обойти сначала левый.
После этого, если нет
никаких левых, то вернуться
к родителю.
И дальше пойти вправое под дерево.
Опять найти здесь
левый кусочек.
Если левых под деревьев нет больше,
и мы все там обошли,
мы возвращаемся к нашему родителю.
И идем вправо.
Если у правого нет ни левого, ни правого,
то мы возвращаемся к родителю, идем наверх-наверх,
пока у нас не появится еще раз правое дерево.
То есть, смотрите, мы идем как будто бы слева
направо.
Понятно?
По-хорошему,
если бы мы, ну, у меня было бы тут
чуть побольше расстояния, я бы мог
вот это вот все,
грубо говоря, спустить вот так вот
на координатную плоскость, если бы
правильно рисовал,
что все правое под дерево лежит правее.
И у меня они бы спустились
ровно на свои места. То есть у меня было бы
1, 3, 4, 6, 7,
8, 9, 10, 13, 14.
То есть, представьте, я
все это спустил, если вот
красиво так нарисовать,
спустил это все на
свою какую-то координатную
прямую, и я
получил как раз эти
значения.
Как это делается?
Ну, это делается достаточно просто.
Давайте напишем
с вами функцию.
InOrder
Волк, например.
Обход.
InOrder, обход.
Куда
я передаю какой-то там ключик?
Потому что я буду делать рекурсивно.
Если вам нужно обойти весь граф,
то вы передаете туда
корень.
Вот.
x это не тип нода.
Что я говорю, что если у меня
если у меня x
не равен
now,
то есть он как бы нода,
но указатель на ноду.
Звездочка, если хотите.
То в этом случае
на всякий случай в плюсах
указатели сравниваются
лучше с nowptr.
Если это
now, то в этом случае
вы делаете
InOrder
Волк
от
xLeft
после чего
печатаете
xKey
а после чего запускаете
InOrder
Волк
от xRate
И тогда вы сможете
все напечатать.
Для того чтобы понять, а как это вообще работает,
давайте с вами напишем стек рекурсии
и тогда вам станет ясно.
На самом деле вы почти все
задали задания.
Мы почти все должны были задать задания.
Уже первая.
Там у вас была задачка с Ханойским башнем.
Вот тут похожий принцип на это.
То есть если у меня есть
какой-то стек рекурсий,
первоначально я вызываю
от своего корня.
Тогда у меня первый стек рекурсий
грубо говоря
8 печатать когда-то.
Я просто буду обозначать,
здесь не писать саму функцию, но это стек рекурсий.
Вот.
Дальше я иду в левый под деревья,
потому что первоначально я вызываю рекурсию,
а не печатаю что-то.
Тогда выше восьмерки у меня будет тройка.
Тройка тоже у меня ничего не сделает,
потому что когда она войдет в рекурсию,
у меня есть левт еще.
Он не на лву.
Тогда он смотрит на единицу.
Единица.
У нее нет ни левого под дерево,
ни правого под дерево.
Он просто печатает в XK.
То есть я напечатал здесь
единичку.
И убираю это из стека.
Так, желтый плов.
Давайте оранжевый.
Так лучше.
И я убираю это из стека рекурсии.
Возвращаюсь к тройке.
У тройки есть еще...
Я печатаю тройку, потому что у него
деревьев больше нет.
Поэтому я здесь печатаю три.
Но из стека рекурсии она пока
еще не выходит.
Потому что у меня есть еще правое под дерево,
которое должен прогуляться вот здесь.
Значит у меня в этот стек
рекурсии сверху добавляется
четыре.
Ой, шесть сначала.
У шестерки есть левое под дерево.
Сначала четыре.
У четыре нет уже левого под дерево.
Ни правого под дерево на самом деле
ничего нет, поэтому я просто печатаю
четыре.
И возвращаюсь к шестерке.
После этого у шестерки,
так как левых под деревьев левой рекурсии
никакой не было, я печатаю
х, то есть шесть.
И дальше я захожу
в семерку.
То есть у меня в стеке рекурсии появляется
вот эта вот семерка.
После чего я печатаю...
У семерки ничего нет, я печатаю семь.
Убираю ее из своего стека
рекурсии.
Возвращаюсь к шестерке.
У шестерки мы тоже уже все обошли, значит
мы убираем её из стека рекурсии.
У тройки мы тоже уже все обошли.
Возвращаем стек рекурсии.
Если мы прошли все левое
под дерево, то в этом случае
мы печатаем здесь восемь.
И дальше идем в правое под дерево.
Но правое под дерево
аналогично рассматривается. У вас
10 13 и 14 есть ли вопрос именно к этой к этому обходу как он работает
треть пожалуйста говорили что указатель лучше сравнивать с нал птр да да да спасибо
был такой ну ли вы указатели все плюс плюс в одиннадцатых ну стали нал птр ну можно с нулем
можно сразу то есть так вы хотите и еще раз просто для удобства ну где у нас
все в дакоиде реализовано удаление элемента вот как мы убирали а зачем мы удаляем
у нас здесь нет никакого удаления мы обходим дерево мы еще до удаления дошли
удаление где реализовываться но почти таким же алгоритмом там с точностью до переставки
двухстрок по идее долей не ну да нет удаление с бинарного дерева поиска не так работает а еще
раз повторить алгоритм смысле очистку дерево то есть полнодаление дерева ну если вы хотите
по полности удалить его туда так можно почти что так но только нужно переставить будет что-то
да ну здесь нет проблем но на самом деле если начислить туда так давайте еще раз как выглядит
этот алгоритм до всего остального мы с вами дойдем как очистить память я думаю вы справитесь
вот еще раз как работает этот алгоритм первоначально мы идем в самое левое под дерево самым
левым согласно нашему принципу вообще бинарного дерева поиска самым левым находится самый минимальный
элемент поэтому мы должны его сначала вывести после этого мы возвращаемся к родителю этого
минимального элемента и просмат и печатаем его идем в правое под деревом правом под деревья
опять могут находиться левые правые под деревья мы по ним пойдем мы сначала выводим все левое потом
выводим сам элемент потом все правое вот суть алгоритма в этом вот и все вот
да смотрите еще раз я пишу здесь псевдокода вот я вы можете использовать так как хотите но я
пишу здесь просто псевдокод для понимания того чтобы вы понимали как устроен алгоритм
я не пишу здесь прям на конкретных плюсах вот окей давайте с вами продолжим дальше есть ли
еще вопросы к этому обходу видимо нету окей тогда давайте с вами перейдем к следующему
следующий обход который нас ждет это второй обход он прямой по это прямой порядок прямой
порядок есть мне опять придется нарисовать свое это дерево чтобы на нем все сделать
прямой порядок это выводится корень а после чего левая левая левая под дерево
после правая
прошу прощения вот давайте здесь напишем с вами как выглядит прямой
порядок давайте сначала нарисуем вообще как выглядит это сначала еще раз это дерево повторим
давайте пусть будет так у нас было здесь 8 здесь у меня было 3 здесь у меня был 1 здесь 6
6 после чего здесь было 4 7 здесь 10 здесь 14 здесь 13 вот вот и нам необходимо
вывести это вот таком порядке который здесь написано для того чтобы это сделать нам
достаточно также написать просто псевдокод и вы сейчас поймете почему это порядок называется прям
прикордер
там это кса также одно мы говорим что если у меня икс не ноль то в этом случае мы печатаем
сначала икс икс кей после чего мы делаем при ордер прикордер волк начала от левого по дерево то
есть от икс точка левт после чего мы делаем прикордер волк от правого по дереву то есть
смотрите мне нужно чтобы я смог вывести сначала вызывать скорень потом левая под
то есть у меня вывести 8 3 потом левая по дереву 1 потом я возвращаюсь правая здесь
корень 6 потом левая 4 потом 7 потом я иду вправое по дереву там 10 14 13 здесь аналогично работаем
со стеком вызова функции единственное что у нас принц самого начала то есть здесь мы как бы
начинаем но этот порядок выглядит следующим образом на сами на самом дереве я иду с корня и
обхожу свое дерево просто следующим образом вот так вот так вот так 4 потом 7 потом возвращаюсь
сюда 10 14 13 на самом деле был бы правое по дереву я бы сделал вот так вот и заканчивается но
здесь то есть смотрите мы обходим начиная самого корня и абсолютно все вершинки за собой тянем то
есть мы обходим обходим вот и все вот это прямой порядок вызову с этим есть вопросы
получается что если мы проходим если используем симметрический порядок и обход дерева то мы
обязательно нужно дать самую левую чтобы пройти весь граф а для ну и корень туда передаем и везде
корень передаем нет если для симметрического то там же он ведь окончится на том что в смысле
если мы передать такой сильный вызов он найдет самый левый лист и начнет с него да здесь у нас
так построено грид что мы передаем корень сначала в самый левый уйдем а только потом перейдем
во все остальное если вы хотите вывести именно так туда корень
вот это что касается прямого порядка и как вы думаете если есть прямой порядок то есть
какой порядок обратный обратный правильно обратный порядок как вы думаете давайте тут
думаете просто обратный порядок обратный обратный порядок
обратный порядок сначала левая и правая под дерево левая потом правая под деревья
а потом корень после корень если опять нарисую это же дерево 8 3 1 6
4 7 здесь у меня будет 10 14 13
13 вот то есть в каком порядке он мне должен взять и вывести этот массив данных которые у
меня есть вот в этом дереве он мне должен вывести следующим видео сначала левая правая только потом
корень то есть 1 4 7 потом корень этого 6 потом 3 после мы идем вправое под деревом и по
нему ходим здесь 13 14 10 и 8 вот так выглядит обратный порядок вызова то есть мы грубо
говоря сначала идем по листам потом возвращаемся к родителям вот если вы хотите увидеть как здесь
это выглядит на рисуночке то это будет выглядит вот так 1 4 7 потом только 6 потом 3 после чего
мы идем вот сюда и переходим сначала в 13 потом 14 10 8 и на 8 заканчиваем вот
прямой обратный порядок то есть условно симметричный понятно в порядке возрастания
бывания по ходить хотите забавный случай забавный случай следующим я как-то ну вот уже давно давно
получается проходил собесовый яндекс я думаю на кафедру яндекса кто-то из вас все-таки почта
и думает об этом и меня разработчик спросил следующий чуть-чуть отключом с простой темы
спросил следующий представь у меня есть такой огромный огромный граф типа связи в принципе и
мне нужно понять а если в этом огромном графе маленький под граф как это сделать быстро а быстро
это можно сделать с помощью этих обходов если вывести в прямом и обратном порядке и то и то
дерево и посмотреть вообще существует ли такие последовательности то мы получим с вами что если
такое вообще а под граф грубо говоря в этом графе большом поэтому суть на самом деле обратные
порядки прямые порядки достаточно полезные штуки мы так можем понять структуру самого самого
бинарного дерева вот и все то есть если вам будет дан к примеру какая-то последовательности вам
нужно построить по ней типа обратную обратный порядок то вот пожалуйста вы можете как-то
из этого массива данных получить а какое у вас вообще было дерево поиска это не очень вот
получается можно по обратному порядку однозначно установить дерево выходить не по не по обратному
по нескольким вещам можно вот но по обратному порядку мы сможем восстановить какие элементы
являются крайними то есть замыкающими ли как можно сказать листьями вот но здесь тоже не
совсем корректно то есть мы можем точно сказать что такой курить вот это мы точно можно сказать
вот замык последний а вот а дальше здесь же будут вопросы типа того как это именно
выглядит вот и все но то есть на самом деле можно сказать что вот этот вот кусок он разделен то
есть то что больше восьми лежит в правом по дереве меньше восьми в левом по дереве то есть вот сын
и вот на самом деле у этого дерева у восьмерки лично десятки мы тоже начинаем отделять вот
это все лежит в правом по дереве 4 является его сыном у тройки вот так вот является все правом
по дереву все что четырех до шести а единичка левым по деревам значит вот этот сын и вот это
самим все можно восстановить еще между 4 и 7 надо поставить ну у шестерки да у шестерки типа вот
четыре от левая по дереве правая здесь просто необходимо очень много так типа грубо говоря ходить
и смотреть когда заканчивается элементы меньше больше необходимо его только реализовать пост ордера
от какого-то икса мы пишем следующее если у меня икс не равен но то в этом случае я
делаю просто пост ордер пост ордер если мы бы писали обычных код они все в доклад нам надо
было бы рассмотреть если и правый и левый волк ордер не равно нулём то есть указатель на правый
зачем у тебя вот здесь и становка рекурсии ты просто пишешь икс неравен на нау пдр ты
передаешь нау он тебя не выполнит рекурсию просто еще а все понял пост ордер волк икс
и там принц икс точку киев глик что у тебя за чудесная вот так
ахан включай камеру были нелеков да да да
окей это то что касается вообще вот обходов за сколько работают обходы давайте на одном
примере на инордер волк который у меня был вот симметрический проход мы по нему и скажем
вообще за сколько у нас что работает окей ну все остальные будут делаться примерно
аналогично пусть у меня корень икс вот с н узлами н узлами обход будет занимать это от это это
будет им порта в самом деле все остальные тоже смотрите снизу мы можем ограничить следующим
образом мы с вами знаем что он пройдется как минимум по вершину поэтому время работы как
минимум это маленькое омега большое от то есть снизу мы взяли и ограничен он должен пройтись
по всем вот если у меня только лишь при же упрощение если лишь у меня только там нулевой какой-то
элемент то есть нам вот то в этом случае там будет какой-то церковь в выполнении с меня ничего
там будет абсолютно с рекурсии будет какой-то константное время если я возьму и у меня будет
ноль элементов на бути на упр это будет одно сравнение ну пусть одно время какой-то цель занимает
вот если у меня n больше нуля то я говорю следующее у меня левая по дереву и правая по дереву пусть
кауслов кауслов влевом по дереве и тогда в правом по дереве так как у меня в иксе
н узлов то влевом правом по дереве у меня будет n минус ка минус один правом по дереве
минус ка потому что влевом минус один потому что еще корень есть сам по себе правом по дереве
ok тогда мы с вами говорим что если у меня т от n есть то оно будет меньше либо равно
чем некоторые т от к ну время работы левого по дерево плюс время работы n минус ка минус
один наш рекурсивный алгоритм для правого по дерево и плюс какая-то константа д какая-то
константа д где у меня это время выполнения без рекурсии то есть время выполнения моей
функции без рекурсии время выполнения давайте сейчас пояснение сделаем д время выполнения то
есть это приент и фут этот сравнить так далее время выполнения без вызова рекурсии
вот меньше ли она не просто равно ну потому что я д так специально подберу мне нужно ограничить
сверху смотрите если я говорю что я ограничил снизу свое т от n то мне нужно доказать что
т от n это у большое от n правильно и тогда я могу сказать что это это правильно правильно тогда
мне нужно взять ограничение сверху какой-то поэтому мы ограничили вот таким вот образом
т это что логично вот окей у меня есть время выполнения без рекурсии тогда покажем что
т от n меньше либо равно чем c плюс d на n плюс там цепь по индукции индукции базы индукции
следующие база n равная нулю т от нуля меньше либо равно чем ц и плюс д умножить на ноль
плюс ц равная ц ну да логично мы так и говорили чудесно теперь для н больше либо больших нуля
мы говорим что т от н меньше либо равно чем т от к плюс т от n минус к минус 1 плюс д правильно
мы с вами уже объяснили почему к и n минус к минус 1 они меньше n меньше n поэтому это меньше
либо равно для них работает предположение индукции вот это вот предположение которое у меня было то
есть у меня будет меньше чем ц плюс д на к плюс ц и снова пропадает опять сейчас не слышу сейчас
сейчас это нормально хорошо хорошо а окей для т от к мы вот написали для n минус к плюс ц плюс
д n минус к минус 1 плюс ц и плюс ко всему этому д еще плюс да вот это да который был чудесно
смотрите ц плюс д на к и ц плюс д вот здесь вот минус к они сокращаются друг с другом правильно
получается ц плюс д на n это у меня равно равно ц плюс д умножить на n и у меня остается следующее
плюс ц плюс ц плюс д это оставил ц плюс д минус 1 минус ц плюс д ну вот минус 1 здесь был получается
вот это сокращается вот с этим с этим это равно ц плюс д на n плюс ц моё предположение индукции
верну таким образом и сверху ограничили его ц плюс д на n плюс ц то есть мы говорим следовательно
т от н равно о большой от н ну тогда т от н равно о большой от н и т от н равно о нега большой от
значит т от н равно это большой от н то есть она работает за линейное время ясно как это доказано
даже еще раз это мы все доказали верхнее самоутверждение да время работы in order
т от н равно это вот то есть мы показали что на гранично сверху
n ограничено снизу n и тогда оно ограничено в принципе вот и все вот такое вот доказательство есть
и к этому вопрос можно предыдущий слайд приключить там я успел написать кое-что с приордером ну да
еще вот это то что касается вообще а как обходить это дерево но у нас ожидает еще ой-ой блин
пощаде мы сегодня не успеем пирамида ну ладно посмотрим успеем не успеем тут уже как пойдет вот
если что на следующую лекцию оставим пока все понятно с бинарными деревьями они не сложные просто
можно думать с ними еще так что выводится почему зачем мы и для чего вот
окей все давайте с вами продолжим то ты успел хорошо
теперь вообще работа с бинарными деревьями поиска работа с бинарными
деревьями
поиска
скажите что из этих деревьев мы хотим вообще с вами получать кто мне скажет так уметь
что из них удобно получать в лечении ментов деревьев что еще раз проверять наличие
элементов деревьев можно проверять наличие элемента то есть можно сделать поиск элемента
и первая такая по теме это поиск элементов
давайте я опять нарисую наше любимое дерево и мы по нему сделаем поиск 8 3
то очень похоже на сам бинарный поиск который вы знаете вы его прошли еще на
семинарах дополнительно всякий случай 6 до 4 здесь у нас 7 здесь 10 здесь 14
здесь 13 вот у нас с вами есть такое дерево как мы будем искать например здесь четверку вот
я хочу найти 4 вот где находится этот элемент я смотрю на корень корень у меня больше 4 тогда
я должен пойти в левую сторону так у меня 4 меньше 8 потому что у меня все элементы которые
меньше находятся левее а все элементы больше правее вот я иду влево 4 8 я сравниваю теперь
здесь корнем 4 больше 8 больше 3 поэтому я иду вправо а теперь мне нужно пойти влево почему
потому что 4 меньше 6 и вот я нашел эту четверку вот и все вот единственное что если мы не
будем находить какой-то конкретный ключ то мы будем возвращать с вами на лп т ну ну то есть
здесь давайте напишем этот алгоритм выглядит очень просто он тоже рекурсивный здесь очень
много рекурсии достаточно удобно ею использовать мы передаем ну откуда мы ищем и сам ключ к вот и
мы говорим что если у меня икс равен но икс равен но но то есть я не нахожу ничего или
или как равен икс точка к я нашел этот ключ то в этом случае я возвращаю икс то есть сам элемент
сам узел который мы нашли вот иначе что я делаю если у меня ка меньше чем икс точка к
то в этом случае скажи пожалуйста даша в какую решить никого в какую сторону мы идем если у
меня ка меньше чем икс к если скома и меньше чем узел то мы идем вправо вроде не находится все
элементы меньше меньше находится слева лево но у меня ка меньше чем икс к лево то есть мы идем
влево и поэтому здесь мы вызываем ритор возвращаем поиск от икс точка левт и моего ключа к
вот иначе возвращаем поиск от икс точка райд и к ну иначе мы идем вправо но нам не
нужен else получается почему если вдруг а если ка больше икс к а мы а если просто
ритор будет какой а ну ладно я так вот ставил да кстати после риторного вставить а если вы
хотите можете писать здесь типа икс равно икс левт икс равно икс райд и вот здесь вот вызывать
риторный сёрч от икс и к ну или там может еще по третью слове выхода из слове либо
мы пришли в нулевую вершину то есть вот представьте ну нет у меня здесь пятерки
предположим был бы он бы пришел к четыре а четыре мне нужно было бы пойти вправо но тут на
вот то есть у него у 4 икс райд нал правильно это нал если у меня нал то такого не существует
я возвращаю нулевой указатель либо же надо будет потом проверить там не знаю другую вершину
дешево поиска но на той бинарное дерево другое не может быть пятерка может встать лишь только
вот сюда после четверки к примеру если бы я сказал пятерку но ее нет поэтому я верну нал
либо я верну икс которого будет икс к понятно так еще вопросы есть это сергей а если вот он
войдет вот сюда вот в икс равно нал и зеркер нет икс а он ноль просто вернет да он вернет нал
по тр нулевой указатель а то есть мы указатель окей еще я понял еще раз икс это указатель
а тип серч это указатель на ноду тип серч в плане что он вернет да он указатель на ноду вернет
еще вопроса вот окей я думаю вы понимаете что вот этот вот поиск работает за о
от аж где аж это высота дерева
почему за столько он работает а все очень просто смотрите каждый раз мы спускаемся на
уровень ниже то есть наша глубина увеличивается правильно каждую итерацию рекурсии если каждую
итерацию рекурсии мы увеличиваем глубину глубина максимальная это высота нашего дерева все мы
получили это ограничение ясно вот вопросы есть к этому если он заретернет икс а не
все отмена я все понял еще вопросы есть какие-нибудь чтобы не было такого
но видимо мы правда сегодня будем с бинарными деревья с деревьями да разберемся тогда тогда
давайте так сейчас перерыв 10 минут до 17 40 вот после этого продолжим хорошо а какая у нас
должна была быть типа сорт которая да вот ну расскажем и на следующей лекции очень страшно
а получается нам после выполнения алгоритма нужно дополнительно проверять что у нас
серч вернул либо нутер либо необходимую ноду да да конечно так почти все серчи работают все
они возвращают либо нулевой тратор либо там куда-то непонятно либо что-нибудь еще ну вы можете
потом посмотреть когда пройдете стельба примете примерно так и дубов так окей давайте тогда с
вами продолжать с поиском элемента мы с вами разобрались что он возвращает тоже разобрались
то есть мы поняли вообще как это вообще все выглядит и так далее давайте теперь тогда разберемся
с вами а что нас еще ждет с этим деревом поиска смотрите есть еще две вещи которые мы
должны с вами разобрать что вообще хранится деревья поиска первое это поиск минимум
поиск
мини мума скажите где лежит самый минимальный элемент в бинарном дереве поиска софия да мы
левый лист самый левый лист то есть нам нужно просто в самый левый край уйти и там будет самый
минимальный элемент это круто тогда давайте с вами сделаем функции минимум
который будет принимать также но дуэйкс но указательная ту ноду и говорить что если у меня
икс левт равно равно но плохо пишу прошу прощения равно но то в этом случае я беру и возвращаю
ритор икс если это не так тогда я беру и возвращаю ритор минимум от икс точка власть
окей он обязан быть по настоящему самым левым он должен быть на последний а если он будет на
последнем уровне но будет не самым левым то есть в бинарном дереве поиска ну то есть если у нас
есть допустим ну приведи мне пример дерева где такое возможно ну допустим 8 потом идут 3
ну и 4 допустим и от 4 идет 2 такое может быть а как такое возможно
или так как 2 меньше чем 3 такого не может быть меньше чем 8 там должно быть ну больше
а понял все правое под дерево больше 8 вот такого быть не может это не бинарное дерево поиска
не бинарное дерево поиска всегда в самом левом а где находится максимум то есть поиск максимум
самым правым поэтому поиск максимума максимум
это следующее что если у меня икс точка райт
в этом случае ритурн икс в противном случае ритурн максимум
икс точка вот это те операции которые мы можем делать просто с бинарным деревом поиска но вопрос
остается еще следующий но я думаю вы понимаете что и то и то работает в среднем за о от аж
ну то есть просто направо идти просто налево идти о о от аж чудесно теперь вопрос к вам
следующий ну как бы да все хорошо в этом плане у нас есть эта штука но у нас есть проблема еще
следующая мы не можем вставлять элементы и удалять это были давайте сейчас разбираться
со вставкой и удалением элементы из нашего узла вот и первое с чем мы разберемся это у нас будет
вставка элемента смотрите если мы вставляем элемент какой-то он должен быть где вставлен
так вы считаете он может заменить какую-то но до которой у нас уже есть
нет почему ну потому что мы не знаем какие элементы слева и справа от нее и поэтому нам
придется все эти элементы перепроявлять и посмотреть можем ли мы туда ставить наш новый
смотрите действительно самом деле здесь вся суть в том что мы вставляем элемент по факту
как новый лист какой-то куда нам необходимо вот это делается достаточно просто и выглядит
следующим образом вот у нас есть сейчас напишем сначала вот здесь поступим так а после чего
разберем это на пример вот у меня есть insert в дерево там т какого-то элемента z вот пусть
узет так как z у меня какая-то новая но да у него есть какой-то кей там равно не знаю в предположим
а вот z точка там райт равно z точка левт ровно но правильно вот то есть у него все его элементы
налевые что делать с парентом я думаю вы тоже догадываетесь он тоже нал необходимого
будет добавить строчку как его подкрепить правильно это не очень сложно вот что я
делаю у меня будет два указателя первые указательная будет и грековинал а икс равен корню
моего дерева корню моего дерева я делаю следующее пока икс неравен ау
делаю следующее игрек равно икс если у меня z кей меньше чем икс кей то в этом случае я
говорю о том что у меня икс равно икс левт я ищу место куда мне ставить з если у него
ключ меньше и то я иду в левое по дереву если ключ больше иначе говорю что икс равно икс
правая по дереву и говорю что а ну хотя ладно давайте напишем что здесь z там
перрент перрент его равен игреку то откуда мы пришли то есть смотрите икс по факту икс о игрек
игрек это та вершина с которой мы пришли то есть это вот это вот финальная вершина от которой мы
будем как раз к ней подтягивать наше з после чего мы делаем что если у меня был игрек равен ал
что это будет означать скажи мне олег пожалуйста чурик как ты считаешь
вот если у меня игрек остался нули вы после этого ваилу то что происходит
включи микрофон только пожалуйста алик включи микрофон да давай как раз у нас и как остался
нули вы по нас икс с самого начала оказался равен нулю так это значит то что у нас пустой
дерево пустой да то есть это пустое дерево нас с вами тогда у нас получается что корнем этого
нового дерева когда мы вставляем у меня должен оказаться z все иначе ну sorry у меня здесь не
хватает места я продолжу здесь иначе else else и если у меня z кей меньше чем игрек то в этом
случае у меня игрек левый равен z то есть если z кей меньше чем игрек то это в левую часть
а иначе иначе вопросы как мы можем сравнить число и указатель и игреки хорошо да спасибо
греки так лучше
хорошо и теперь иначе мы говорим что игрек райт равен z вот
у нас как бы по стандарту если два числа равны то он идет в правый век
вопрос еще есть то есть смотрите еще раз что мы делаем давайте
предположим пусть у меня есть какое-то дерево как это вообще выглядит давайте
сейчас придумаем какой-нибудь другое дерево которое у нас есть не знаю 12 здесь у меня там
не знаю 3 здесь у меня там в левом значит 1 здесь у меня там 4 здесь у меня там 13 у
него здесь есть под дерево 12 здесь у меня там 16 я хочу вставить а элемент 11 элемент 11 я хочу
сюда вот доставить я его должен ставить ой 12 извините 12 13 давайте здесь делаем 10 так чтобы
нас не было одинаково просто 10 я хочу ставить 11 мне его нужно подцепить вот к этому я в начале
своим иксом прохожусь и дохожу сначала направо потому что 11 больше 10 потом налево потому что
11 меньше 13 здесь 12 говорю что у меня икс стал равен нал вот здесь вот но игрек остался 12 то
есть мы игрек сохраняем в этом плане вот у меня остался игрек равный 12 и к нему необходимо
что-то подцепить и вот я подцепляю этот элемент 11 вот так он становится в моем деле вот это то
что касается вставки возможен следующий момент что у вас будет не совсем дерево такая цепочка
вот из-за таких вот инсерта как это будет выглядеть это будет выглядеть примерно следующий представьте
мы вставили сначала единицу потом мы вставили двойку потом мы вставили тройку потом четыре и
так далее то есть в этом случае моё дерево это по факту такая цепочка грубо говоря если вы
хотите понимать что это как это выглядит ну это такой вот список линей и все вот и здесь высота
дерева равна всем ну количество элементов поэтому здесь будет грубо говоря инсерт нам необходимо же
дойти до самого края и сёрт всегда работает за от аж но вот в этом случае аж равно
потому что мы будем все время вставлять там дальше дальше дальше дальше дальше наши
элементы так далее вот то есть возможен случай бинарных деревьев поиска в наивных бинарных
деревьев поиска мы просмотрим с вами еще потом другие когда у нас будет такая вот длинная длинная
цепочка ясно вот можно предыдущий слайд пожалуйста можно конечно есть ли еще вопросы к вставке элемента
вопрос а вот вы в вайле написали условия и пока икс не нулевой указатель да но это
как будто мы дошли до 100 да так если мы хотим ставить элемент за мне он же не обязательно будет
листом почему он всегда будет листом он всегда вставляется к листу а почему а почему он
обязательно лист как ты думаешь может ли быть он не лист смотри ну дерево бинарное там 7 давай
предложи мне дерево в который я не могу вставить мне листов хорошо от меня дерево 7 слева 6 правого 8
потом из 6 идет 8 четверка я например хочу ставить а просто вправо пойдем то пятерку
вот сюда буду вставлять на у меня будет ну как бы полу лист такой я не знаю смотрите только не
сюда же а если у меня вот вместо восьмерки будет десятка я хочу ставить восьмерку десятка
я хочу ставить восьмерку я дойду до 10 сюда ставлю 8 она все я понял то есть еще раз эти
элементы которые мы вставляем они всегда будут листами это правда можно еще раз пояснить при
пятерку про пятерку но она вот сюда вставится ой не сюда она ставится справа 4 вот сюда вставится
пятерку спасибо и илликсандрич а вот мы структуре которая общая информация о дереве храним получается
адрес корня и что еще глубину там можете хранить что вам нужно если вам нужен сайс постоянно сайс
если он нужен постоянно глубина то глубину но только надпись как глубину типа при всех вот
этих вот модернизациях консерта и так далее правильно считать но по факту там главный
у любого дерева самое главное что еще раз глубину наверное удобно в ноге хранить смотрите
глубина относится к узлу высота относится к дереву не путайте эти понятия глубина это там
где находится сейчас наши наш узел это мы количество ребер от корня до этого элемента до этого узла
вот это глубина высота дерева это максимальный вот этот вот сколько у нас максимум этих
ребер может быть вот глубина смотрите глубина здесь для восьмерки это два глубина именно для
восьмерки для десятки у меня глубина один а вот высота всего дерева высота вот этого всего
дерева криво нарисовал высота всего дерева 3 и возможен такой случай говорю при вставке вот
тем образом который мы делаем вставляем возможен такой случай что мы будем постоянно идти в правое
дерево к примеру там 1 2 3 4 и так далее тогда в этом случае у нас глубина будет равна n
глубина высота извиняюсь я уже сам начинаю заговорить высота n
а вот глубина каждого элемента вот корня 0 2 единичка тройки 2 4 3 поймите вот эту
всю разницу между глубиной высотой дерева высота дерева к дереву глубина к узлу все
еще вопросы есть какие-нибудь вставки чему в левом примере высота будет 3 высота будет 3 вот
у меня самый длинный путь который есть сколько здесь у меня а первый а все понятно 2 3 3 ребра
правым высота будет не n минус 1 что еще раз правым высота не n минус 1 n я имею в виду
количество элементов н минус 1 же будет а да ладно правда да спасибо
а так там вопрос в чате как ставить элемент который равен одному из листов он будет
левым или правым смотрите еще раз с равными элементами в зависимости от того как вы делаете
свою структуру если описывать элементы как мы делали здесь то все элементы равны будут
идти вправо но бинарное дерево поиска она создана для того чтобы искать элементы но
дерево поиска вот поэтому там не вставляется просто так элементы одинаковые только если
какая-то прям сильная надобность в этом есть вот и все еще вопросы есть какие-нибудь
хорошо и тогда у нас последний пункт с бинарными деревьями поиска это удаление элемента запишите
себе пожалуйста удаление удаление элемента узла нам необходимо удалить какой-то элемент по
какому-то ключу примеру с черчем вы нашли это ну вот своим файлом который у вас был вы нашли
какой-то элемент теперь нам нужно его взять удалить здесь может быть несколько вещей когда нам
нужно что-то удалить несколько вариантов которые нам надо будет рассмотреть смотрите давайте я
вернусь к тому дереву который мы все это время писали вот так у нас там было 8 сейчас
дерево 8 из него исходила тройка стройки сюда единичка из шестерки ой здесь шестерка здесь
у меня был элемент 4 здесь 7 здесь у меня элементы ну чуть-чуть криво вышло ну ладно
давайте 10 здесь у меня был правый сын это 14 и сюда 13 смотрите важные моменты для удаления
первые случаи когда мы удаляем это вершина является этот узел является листом предположим
мы хотим удалить 13 что в этом случае мы должны делать давайте первый случай
удаление листа
места
вот и инородская как вы как ты думаешь вот если мне нужно удалить лист что мне нужно сделать
найти его но я его нашел вот 13 вот его выделил даже просто удалить и сделать указатель нулем
у его родители у его родители нужно сделать просто указатель нулем то есть при удалении листа
мы удаляем но до удаляем но то и после этого у родителя у родителя у родителя
делаем указатель указатель
на налп т на т хорошо второе с листом более-менее просто то здесь не сложно что будет если мы
будем удалять лист мы просто его берем удаляем говорим что у родителей больше нет сына ну как же
так но вот так уж получилось что все у нас теперь элемент здесь элемент здесь вот такой теперь
давайте с вами рассмотрим второй случай второй случай удаления это когда давайте здесь сатру
это и второй случай выглядит следующим образом представьте следующее что у этой вершины у этого
узла который мы хотим удалить есть только лишь один сын один ребенок который может быть либо
левым либо правым это без разницы вот либо левым либо правым либо левым либо правым ребенком и
тогда необходимо будет удалить этого эту вершинку этот узел и перед подвесить все остальные которые
были за ним то есть смотрите если я хочу удалить 14 что я должен сделать я должен сделать следующее
убрать вершину 14 и переподвесить 13 следующим образом вот то есть просто если это был правый
сын для кого-то именно тот узел то правый сын стал тем кем был то есть правым сыном теперь
стала вершина стал узел 13 если было бы то есть два ребенка у 14 мы же не можем сделать два
правых элемента момент до этого случая дойдем это еще один случай то есть тут три случая рассматривается
то есть когда у нас всего всего
один ребенок
просто переподвешиваю просто
переехавшим
то есть здесь достаточно тоже просто мы удаляем эту вершину для родителя этой вершины мы говорим
что теперь у тебя твой сын это другой вот и все твой ребенок любой он может быть и правым и
левым здесь без разницы на самом деле потому что он был всего один значит он такая останется так
как для 10 если 14 было правым правым сыном то все что связано с правым под деревом у него все
больше поэтому здесь мы никак баланс не нарушим когда мы будем удалять его теперь остается самый
такой сложный момент связанный с тем а что делать когда у узла есть два ребенка в этом
случае давайте я его сейчас выделю как-нибудь вот предположим мы хотим удалить 3 что должно встать
на место трех как вы думаете вот давайте я спрошу спрошу льва лев миловарцев вот скажи мне
пожалуйста как ты думаешь что должно встать на место трех если удаляй три возможно должно встать
но единичка мейби единичка а если бы у единички здесь справа было бы вот так давайте чуть-чуть
но смысл в том что да последний правый лист сам в общем в левом по дереве самый правый
листок мне кажется в левом по дереве самый правый лист почему но он не нарушит все
ценности бинарный бинарного дерева и все все наоборот он стоит правый лист и
к крайнему левому листу правого листа добавить вторую ветку ага смотрите а точно ли надо брать
левое дерево или правое поддель здесь есть не важно по сути то мы можем просто сказать ну
вспомнить как у нас происходил обход всех элементов что эти два элемента то есть
само правый элемент из левого по дереву и самый левый исправа по дереву являются оба
сахиги не в обходе от тому моменту который мы удаляем да то есть смотрите вспомните
действительно если вспомнить обход то для того чтобы у нас ничего не нарушилось мне
необходимо здесь вот если я выпишу это в порядке в порядке отсортированном 1 2 3 4 там 6 7 8 ну и так
далее то если я удаляю здесь тройку то на место тройки может встать спокойно либо два либо
четыре мы можем взять либо самый правый лист у левого по дерева либо самый левый лист у
правого по дереву здесь без разницы вот то есть мы просто находим здесь
следующий элемент за удаляемым я буду находить именно справа по
дереву находим следующий элемент за удаляемым и удаляем его и вставляем его на это место
то есть здесь я хочу ставить четверку на это место понятно вот то есть удаление есть вот три
таких случая смотрите для удаления я напишу себе функцию функцию которая называется трансплант
а вот
куда я передам свою дерево у и в у и в это некоторые узлы и я хочу заменить одно под дерево другим
под деревом вот то есть здесь у меня как бы ну я хочу просто заменить у на в вот и все что я
делаю я делаю следующее что если у меня родитель уп и его нету то в этом случае я говорю что это
корень поэтому я здесь просто возьму и переподвешу и скажу что а т рут равновая
вот и начин и начин если у меня у равно у п левт то есть оно является левым сыном то в этом
случае я говорю что у п левт у меня равен в вот и начин если это не так то он является правым
сыном и тогда я говорю что у в райт равно но я просто взял и заменил здесь ну я вставил на
место ув вот и все и последнее что мне нужно сказать что если у меня в не равно
на упр то родитель в равен родителю все у меня есть вот такая вот функция я просто на место у
вставляю в что такое в узел у тоже узел вместо узла у я сделаю узел в что
если пишете на плюсах то еще надо удалить здесь у дилей ту написать а просто есть функции транспорт
где мы нет теперь давайте с вами напишем код для удаления это будет наверное последний
вернуть тогда спрашивайте вопрос если у вас есть зачем последние условия и вы не равняетесь
но потому что если вы равняетесь на ну то есть нулевая вершина мы просто присобачили тогда
у нее нет родителей то есть она не начал не указывать сама вершина по себе бесполезно у
нее нет родителей да а что нам мешает вот нас есть самый какой-то правый элемент левой ветки да или
сам самый левый значение его есть перезаписать это значение только это значение тот элемент
который мы уходим хотим удалить а потом удалить нижний так нет это пока не удаление это просто
просто мы в в запихали по факту то что ты сказала мы сделаем но только надо понять
какой что это именно тот случай поймите что нас в одной функции рейс должно быть
все три случая рассмотрено понятно да все вы записали это
надеюсь туда окей тогда давайте с вами продолжать а теперь сама функция рейс рейс
я уже знаю какую я именно удаляю ну то есть за это сама уже но до этого дерева если вам
нужно сначала найти а только потом удалить то вы сначала пишите сёрч то есть поиск свой ну или
файн назовите и потом вы только ее удаляется вот рейс мы сделаем следующим образом если у меня
зед левая часть зед левт равно нау то в этом случае я что делаю у него нет левого сына тогда
мне нужно что взять заменить просто саму зед на вершину которая является его правым ребенком то
есть т трансплант от т зет и на его место на место сет я пишу за трайд просто правую вершину
если у него нет левого ребенка иначе если у зед
смотрите в зет левт равно нау в ходе также и лист лист тут это тоже сделано
потому что у него нет левого ребенка правильно правильно то есть я вставил если что сюда нал
зет райт у меня нал именно поэтому у него родителей нету нау именно поэтому в трансплант было написано
тот и вот если у зет есть правый ребенок ой точнее нету правого ребенка то в этом случае я делаю
трансплант т зет и зет левт левой то есть если нет правого ребенка тогда я левую просто
подвешиваю туда еще раз а вот теперь нам необходимо сделать следующее иначе иначе мы с вами говорим
о том что нам необходимо взять и найти наш минимум у этого правого по дереву то есть смотрите
мы берем самый левый самый левый лист нашего правого по дереву поэтому здесь достаточно сказать
что иначе я делаю так игре кровно минимум вот вот чего вот
если у нас есть два ребенка от зет то есть корнем того под дерево правого является
и в нем я пытаюсь найти минимум я нахожу этот минимум и говорю что если у меня у
игреков родитель не равен z то есть он где-то дальше чем за это вообще сильно то я делаю
трансплант трансплант своего дерева игрек и игрек райт я сначала его должен переподцепить
почему потому что у самого левого листа может быть правый ребенок у самого левого вот это вот
то есть смотрите минимум это не совсем лист если у меня есть вот такое вот дерево вот такое
к примеру то минимум вот это число давайте еще раз вот здесь пусть будет 5 4 2 а здесь 3
минимум это вот это тогда я перецепляю его право ребенка правый ребенок после чего я
делаю я делаю этот трансплант я говорю что у меня игрек райт равно зет райт
когда я уже переподцепил все и игрек райт
п равно игрек
вот и мне осталось еще сделать немножко действий здесь а что если оно игрек z является родителем то
смотрите у меня здесь немножко больше действий я сначала переподцепляю у игрека правое под дерево
я его переподцепил после этого беру и говорю что у меня это запихивается еще в z правый ребенка
з дальше я пишу здесь трансплант от чего как вы думаете ты z и игрек теперь на место z я уже
записываю игрек вот и дальше мне нужно написать здесь еще две строчки к сожалению не могу здесь
то есть смотрите этот трансплант он после ифа то есть этот в этот иф не входит и вот здесь вот
еще две строки две строки следующие игрек левт у меня равен зет левт и игрек левт
райт равен игрек все есть ли вопросы почему так что происходит и как так вышло давайте еще
раз по строчкам что такое игрек можно еще раз игрек это минимальный элемент самым правым под
деревьем самый минимальный элемент правом под деревьем который мы можем безопасно вставить
наше дерево вот он например или если мы смотрели мы смотрели на вот это дерево здесь для тройки то
вот эта четверка это как раз этот минимум мы самое левое пошли на эти самые левой такой кусочек
есть ли вопросы можешь тоже с графом это визуализирует вот последний else еще раз это
с графом просто так ну да ну то есть смотрите давайте хорошо с последним графом вы имеете
в виду а я понял последний else именно да да да тяжел давайте еще раз это порисуем вот у
меня есть тройка вот у меня есть четверка правильно у четверки parent это 6 да
вот что я делаю я вместо четверки я же ее переподвешиваю я делаю трансплант y и y правого
y правого меня на поэтому я просто по факту эту вершину отцепляю ничего с ней не делаю то есть
если здесь смотреть то я просто сейчас момент то я просто удаляю вот эту связь по-хорошему то есть
у меня осталось это четверка где-то здесь теперь нал находится и говорю что у игрека вот у этого
игрека правый равен z правому то есть вот этот кусочек и у правого сына z родителем теперь
является игре то есть я беру и переподвешиваю это так что у меня теперь четверка вот где-то
здесь она пока морфин существует она вот так вот делает после этого я делаю замену z и y я их
меняю местами то есть я беру и теперь у меня восьмерка переподвешенные сюда смотрит единичку
так вот и у игрека я переподвешиваю левой то есть единичку подделываю и говорю что у
левого теперь родитель это четверочка все стало понятнее или нет так еще вопросы то есть я правильно
понял что мы просто самый маленький лист правой ветви переставляем самый маленький элемент правой
ветви вставляем а вопрос а почему мы не можем просто левую ветвь подвесить к минимуму правой
ветви и просто правого ветвь ну собственно поставить место удаленного еще раз можно почему
мы не в нашем случае а я кажется понял шестерку мы не можем просто взять теперь подвесить да
потому что 4 непонятно куда встанет они у нас в этом случае наверное мы можем прийти подвесить
ветвь 1 2 к четверке слева а шестерку подвесить к 8 это сильно больше действий это не ну здесь
в конкретном случае можем но только это увеличит количество действий типа неистово а что в общем
случае делать ну то же то есть мы просто берем получается с этого подвешиваем к минимуму от
а я понял о чем-то правильно 1 2 4 а вот потом всю эту конструкцию вместо тройки да смотри то
что ты пытаешься сделать называется ты пытаешься перед переделать это все во второй случай когда
у верши нету ни левого ни правого сына если ты переподвесишь да ты получишь просто 2 случай
удаления при подвесить можно попробовать только случайно может тоже сильно запутаться можно
потому сначала минимум потом туда запихать потом все еще переделать
понятно и она может немножко нарушить саму конструкцию твоего дерева вот и все ты просто
таким образом берешь и кремляешь свое дерево еще больше а если ты его выпрямляем то все долго
высота увеличивается ну да высоту мы просто типа искусственно зачем-то увеличить так вот
глянуть конечно можно повторить про что такое трансплент трансплент он просто меняет он на
место вот здесь вот у меня написано z это за трайд он на место z записывает за трайд и
переподвешивает все вот еще вот что такое t это дерево это дерево у которого есть как минимум
корень все давайте еще раз типа по строчкам рейса ну типа просто что происходит первые
первые две строчки вот это вот типа за плев трансплент и трансплент рассматривают
случаи когда у узла z нет левого или правого дочернего узла нет у него ребенка если у него
нет ребенка то есть это может быть и лист это может быть и без одного ребенка и так далее вы
просто должны взять и переподвесить трансплент просто берет и переподвешивает вот что касается
строчек 512 ну вот типа вот этих вот минимумы и гриппэ и гриппз это так далее смотрите мы
первоначально смотрим является ли игрек нашим является ли игрек ребенком z то есть у игрек
пэ ну перрент игрек это з если это не так то нам необходимо взять и все еще переподвешивать
если же это будет так то нам необходимо всего один раз взять и переместить туда элемент так
как мы удаляем по факту два элемента если у игрека грубо говоря если мы вместо z подставляем
игрек он является сыном игре сыном за и он является самым левым заметьте самым
всех возможным то мы просто должны его поставить на его место а вот если он не является сыном
находится где-то далеко то нам необходимо взять и переподвесить еще больше то есть
пэ это пэрн да это пэрн все правильно
еще вопросы есть
смотрите по факту рэс работает за у от аж потому что трансплент работает за у от единицы вот все
работает просто за у от единицы но переподвешивание то есть нам необходимо ну здесь абсолютно все
вот эти у штуки вот трансплент трансплент вот здесь вот сравнение трансплент и здесь какие-то
переподвешивания это все за от единички единственное что дает нам здесь сложности алгоритма это вот
поиск вот этого минимума поэтому в этом случае мы говорим о том что рэс работает за о от аж
ясно
вот есть ли еще какие-нибудь вопросы к бинарным деревьям поиска мы с вами хотя бы закончили
что радует чтобы поиск минимум не работал за от нужно периодически просто перемешивать
наши дерево не совсем нужна будет сбалансирована с дерева об этом поговорим через лекцию хорошо
мы поговорим про сбалансированные деревья что это вообще такое да там нужно будет балансировать их
вот и все бывает смысл менять корень дерева чтобы у нас у нас
по одному вопросу сначала антонио был у нас есть смысл иногда но менять корень
смотрите для того чтобы у нас асимптотика улучшалась то есть аж улучшалась используется
сбалансированные деревья поиска это отдельная штука там не просто корень меняется там правильно
все подвешивается и там корень действительно может немножко так все время вилять вот если
будет рандомно просто корень менять не сильно выигрыш во время какой еще вопрос у нас в контесте
вы только бинарные деревья в этом контесте да будут только бинарные деревья обычно не
сбалансированные следующие сбалансированные они всегда будут всегда будут бинарные правда вот
единственное в предыдущем контесте что у нас там в предыдущем контесте были задач
которые по факту тоже это надо полный перебор было делать и там было уже не бинарные мирные
ферзии да мирные ферзии там по факту надо было и аннарные деревья строить рекурсивный
обычная рекурсия там рекурсия которая все писали в задании спойлер типа мистово много
строчек кода решается каждая задача не больше 40 строчек нам нужно было понять
какая делается рекурсия перекрестной или обычной как это считается
не нужна была там не нужны были там деревья но не нужны если вы усложнили себе так жизнь
хорошо вопрос 40 строчек даже электронные часы но нет электронные часы надзейфать было
да я имею в виду обязательные задачи обязательные задачи кроме всяких реализации тэка дэк
и так далее там надо было просто подумать то там просто чисто вот смотрите у вас в контесте будет
который воскресенье мы пришел в 10 утра у вас там будет еще задачи на хипсорп про пирамиды
пирамиды мы с вами рассмотрим на следующем занятии
