Лекция номер 10. И мы с вами приступаем к, у нас будет несколько тем, первая рекурсия.
Так что такое вообще рекурсивный какой-то объект? Вообще встречались ли вы с рекурсией
в жизни? Наверняка вас вы слышали или видели какие-то примеры рекурсии. Давайте в жизни,
что-нибудь из жизни. Ну, жизнь физтеха, понятно, сразу с факториала, окей. Давайте тогда что-нибудь
простое, например, попроще факториала. Рекурсивное определение натурального числа. Ноль, ну,
мы программисты, и у нас на нас большое влияние, как вы знаете, американская поэтому и математика,
их стандарты. Ноль, это у нас там и остатки отрицательные и так далее. Ноль, это натуральное
число. Если число, значит, как дальше мне можно определить рекурсивно на следующее натуральное число?
Ну, например, и мы с вами можем много разных примеров проводить, но вы правильно сказали,
факториал, один из таких классических примеров, у нас есть некая формула рекуррентная, где мы
факториал определяем через факториал же. Но рекурсивно называется функция, которая вызывает
саму себя. Вот вы, допустим, как обычно я спрашиваю для того, чтобы вы думали, вы, допустим, находится на
экзамене, и у вас, как всегда, неудачный экзоминатор, который задает подлые вопросы с подковыркой. Он,
то есть, знает, что, может, вопрос некорректен или еще что-то и смотрит на вашу реакцию. Вот,
например, вы, вас как зовут, молодой человек? Егор. Гор просто. Хорошо, Гор. Вы сидите на экзамене и
вам говорят, вот я напишу сейчас функцию. Экзоминатор говорит, я сейчас напишу функцию. Он еще не написал,
но вот напишет. Это какая-то, знаешь, ставка вслепую. Значит, он пишет, он скажет, я сейчас напишу
функцию. И, посмотрев на эту функцию, вы, Гор, сможете сказать, рекурсивная эта функция или нет? Что вы
должны ответить экзоминатору? Да, сможете ли вы с уверенностью, да, 100% сказать, рекурсивная эта
функция или нет, если он вам напишет сейчас функцию и покажет ее? Совершенно правильно. Вот вы бы
сдали, потому что мы не всегда видим с вами рекурсию просто по одной функции. Бывает самый простой способ,
прямая рекурсия, когда функция вызывает сама себя. Я где-то видел, причем чуть ли не в детском
учебнике, определение, мне очень понравилось, но, видимо, учебник не очень хорошо редактировался,
где детям рассказывали про рекурсию, рассказывали, но это червяк, который ест сам себя. Это, конечно,
наверное, червяки едят сам себя, они не специалист биологии, но, наверное, детскую психику такое
определение повреждает. Поэтому даже мы с вами не будем об этом думать. То есть это прямая рекурсия.
Косвенная рекурсия — это когда, например, функция A вызывает функцию B, а функция B вызывает функцию A.
И просто посмотрев на функцию A, мы не можем сказать, вот эту функцию B, которая вызовется,
она вызовет ее или нет. И рекурсивные функции на самом деле надо знать, когда использовать,
потому что рекурсия иногда это очень удобно и очень полезно, и вы не можете очень кратко и просто
написать какие-то вещи. Мы будем часто, например, их использовать, когда программируем деревья,
когда программируем разные алгоритмы на графах, например, DFS. И там действительно без рекурсии можно
это было бы писать, но вам бы пришлось затрачивать слишком большие дополнительные усилия. А есть
примеры, когда рекурсию не надо использовать. И, например, на собеседованиях там в Яндекс и в другие
крутые компании часто спрашивают даже вопрос с подковыркой, а напиши такую программу рекурсивно,
и ты понимаешь, что. И вот тут сейчас мы давайте сначала посмотрим на самый первый пример с
факториалом. Факториал обычно во всех учебниках действительно классический, такая штука,
на которой показывается пример рекурсии. Ну давайте, чтобы не выделяться из серой массы
тех, кто программирует на C++ первую рекурсивную программу, тоже напишем факториал. Пусть у нас
будет некий int. Ну можно long. Сейчас давайте, наверное, даже все-таки напишем, в зависимости от, понятно,
где-то это будет совпадать. Ну так красивее хоть будет long. Давайте напишем. Пусть у меня будет
какая-то функция факт, которая возвращает long, принимает long and, собственно, факториал,
который мы хотим посчитать. Каким образом она это будет у нас с вами делать? Если у нас n или 0
или 1, то плохой стиль возвращаем 1. А иначе, во всех остальных случаях, когда мы не вернулись,
значит, мы просто вернем следующее выражение. n умножить на факториал n-1. Это корректная функция.
Она считает факториал и вызывает, собственно, саму себя. Вот у нас здесь явно есть прямая
рекурсия. Вы видите, что у нас из функций вызывается функция. Тут самый червяк. Можно же было,
можно было бы написать все это одной строчкой. Да, можно написать, например, вторую версию этой
программы, воспользовавшись нашими знаниями. И давайте так и сделаем. Без if это напишем,
а просто сразу сделаем return. Заменим просто наш условный оператор тернарной операции,
который у нас c++ есть. Если n больше 1, тогда мы вернем значение выражения n умножить на факториал
n-1, а иначе мы с вами вернем просто единичку, что является значением факториала при n меньшем
либо равном 1. Теперь, как вообще это чудо работает? Прежде всего, надо понять, что когда
происходит первый вызов функций. Допустим, в main где-нибудь мы вызываем этот факториал от 5. У нас
есть stack и все вызовы этих функций, те данные, которые хранятся в этих функциях, они хранятся
на stack. Мы это уже с вами много раз смотрели. Вот у нас идет вызов функции факт с параметром 5.
Что такое n? Это некий параметр, который передается по значению. Это локальная
переменная. То же самое, что если бы мы внутри функции объявили int n, то есть мы с вами получаем
первый вызов f от 5. Фактически у нас на stack сейчас объявляется локальная некая переменная n,
значение которой равно 5. Кроме того, что у нас объявляется переменная, помните я рассказывал,
что для того, чтобы вызывать функцию, еще хранится служебная информация, потому что никаких секретов не
происходит. Вызов функции это просто переход на какую-то строчку кода. У процессора есть некие
команды, например там call или jump, в зависимости от ассемблера языка. Тем не менее, неважно. Важно,
что он просто безусловно переходит, как вот то слово, которое мы не называем с вами, и потом
возвращается. Чтобы ему вернуться, ему надо помнить, куда вернуться, то есть хранится некий
адрес возврата. То есть у нас есть некий адрес возврата, который неявно записывается тоже в stack,
плюс некий контекст процессора, регистры, которые были на этот момент, чтобы когда мы вернулись,
да, все было как вот так. Вот я отвернулся к доске, вы тут все взяли, я повернулся назад,
все положили как было, никто ничего не заметил. Я могу продолжать лекцию, как и было. Также и
программа, она должна вернуться в точку, откуда вызвали функцию, и ничего не должно измениться,
ничего не должно сбиться от того, что там кто-то что-то поработал, ей затер. Вот это хранится,
и теперь идет у нас с вами здесь if, если это не выполняется, выполняется эта строчка, идет вызов,
что мы возвращаем значение 5, мы должны вернуть, чтобы функция закончилась, она должна свою последнюю
строчку отработать, вот она ее отрабатывает, она считает значение выражения 5 умножить на
факториал от 4, и в этот момент она еще не закончилась, потому что она должна вызвать функцию
факториал от 4 для того, чтобы закончить свою работу, и факториал от 4 у нас выполняется,
вызывается, и в стеке ниже теперь для нее все. Сначала локальная переменная n равно 4,
теперь вот этот адрес, теперь вот эти служебные еще дополнительные информации, то есть обратите
внимание, как у нас стек растет при вызове рекурсивном, и здесь тоже самое, 4 умножить на
факториал от 3, идет вызов факториал от 3, этот ждет закончания вычления выражения, чтобы закончиться,
выражение у нас как бы не вычислилось здесь тоже, поэтому для того чтобы вычислить выражение
вызываем это, и вот у нас каждый новый вызов, это фактически вся вот эта служебная информация,
плюс локальные переменные в памяти n равно 3, и мы хотим с вами 3 умножить на факториал от 2,
факториал от 2, то же самое n равно 2, некая информация 2 умножить на факториал от 1,
и вот здесь наконец произойдет чудо, вызовется функция факториал от 1,
в которой будет у меня n равно 1, будет еще служебная информация, вот эта строчка сработает,
и мы закончим вот эту функцию по этой строчке, вот это место, и оно вернется нам единичка,
вот это место, где заканчивается рекурсия очень важно, потому что если у вас нет места,
которая заканчивает рекурсию, то она у вас будет бесконечной, но писать бесконечные программы
не надо большого ума иметь, можно цикл написать бесконечным, можно рекурсию бесконечную,
здесь просто проблема, что она не только не закончится, она рано или поздно переполнит стэк,
потому что у вас есть стэк, и глубина рекурсии, на нашей терминологии глубина, это как раз сколько
вызовов мы максимально делаем, то есть у вас какая максимальная глубина рекурсии,
но вот от какого параметра можете вызвать максимум, по условию вот столько вы можете
этих вызовов получить, и надо посмотреть, влезают ли они у вас в стэк, потому что кроме самих
локальных перемен, у вас есть служебная информация, но тем не менее, если вызовов много,
эти мегабайты там 1, 2, 4 у вас забьются, и это легко почитать, кроме того, если не дай бог вы
какой-нибудь массив объявляете внутри функции рекурсивной, но она забьется намного быстрее,
если большие там структуры, которые локальные будут объявляться, поэтому переполнить стэк
большого ума не надо, у вас будет стэк оверфлоу, это такое есть выражение культовое, даже есть
некие сайты типа стэк оверфлоу, поэтому, может вы слышали, есть такой форум стэк оверфлоу,
поэтому это как раз про переполнение стэка, например, рекурсии, ну и здесь мы возвращаем эту
единичку, единичка заканчивает вычисление функции, потому что ей вернули значение,
получается двоечка, двойка является результатом вычисления функции, функция сворачивается,
возвращается сюда значение 2, то есть эта из стэка у нас уже удалилась, здесь у нас 6,
мы возвращаем 6 и как помираем, потому что мы вернули и функция закончилась, все,
стэк в данном случае указатель подвинул вверх и эта память будет затерта, физически там никто
с отбойным молотком не приходит и не перетирает эти ячейки, их просто затрут, когда они в следующий
раз понадобятся, 4 там на 6, 24 мы с вами получили, тоже закончили, здесь там 120 мы получили и
вернули эти 120 в основную программу, вот мы так 120 получили, когда мы в одну сторону развернулись,
в другую свернулись, хорошо, теперь давайте вот тот самый подлый пример, когда на собеседонах
спрашивают, а этот пример является классическим примером в любой книге вообще, если вы, значит,
загуглите, посмотрите или даже я помню статью какую-то читал на хабре, где было написано писать
вот это рекурсивно, это хуже чем топить щенков там в речке, когда у нас, я считаю, что как бы это
ужасно, кто так пишет и вот если кто-то так напишет вообще и мы увидим, это вот знаете,
считается просто вот не знаю, очень плохой стиль, вот очень плохой, как будто вы там матом ругаетесь,
когда пишете, это вот на уровне вот этих четырех букв, которые нам нельзя произносить, и так это числа
фибоначи, и так все вы знаете числа фибоначи, у вас есть нулевой, первый элемент, допустим,
они равные единице, каждый последующий элемент определяется по формуле, как два предыдущих,
числа фибоначи тоже быстро растут, наверняка те, кто в школе занимались олимпиадной математикой,
знает явную формулу для очистки фибоначи, степенную, через золотое сечение, может быть,
это не наша как бы в любом случае программа, это школьные такие штуки, но если вам интересно,
можете википедию прочитать про числа фибоначи и их историю, почему они в природе имеют большое
значение, что наше тело подчиняется во многом, в том числе этим законам, там пропорции там,
я не помню, от груди до ступни и от головы там до ступни, это вот там золотое сечение, вот и рука
там у нас по такому принципу, и вообще мы с вами ходячие числа фибоначи, но сейчас на программирование
мы просто хотим с вами написать рекурсивную программу, ведь это же так очевидно, посмотрите,
это же напрашивается рекурсия, и мы просто, ну давайте напишем, вот у нас функция некая,
она принимает у нас значение вот этого числа и то же самое вот по такому же образцу,
что нам изобретать, вот если n меньше либо равно 1, давайте вернем 1, а иначе сделаем вот этот
вызов, что f значит ретурн, и здесь просто явно напишем вот эту формулу, f от n минус 1,
плюс f от n минус 2, то есть взяли, написали, очень легко, красиво, и вот ты в Яндексе
собеседуешься, написал, и тебе говорят, все, не прошел, почему? Вот давайте посмотрим, почему
факториалом еще можно, хотя тоже ничего умного не было писать, факториал рекурсии, когда там
нужен просто цикл и переменная, и памяти там будет требоваться меньше, и операции будет меньше
на копирование дополнительной информации, потому что, я надеюсь, вы уже способны к 10 лекции написать
факториал без рекурсия просто циклом, правда ведь? Накапливая как бы счетчик, правда? Вот,
но хотя бы этот еще пример, он хорошо понятен, и мы его именно как учебный пример используем,
хотя смысла писать здесь рекурсию на факториале не было, а здесь не то, что смысла писать нет,
это просто убивает все, почему? Ну, давайте посмотрим, допустим, вызвал числа Fibonacci от 5,
запустил эту функцию f с параметром 5, что получается? У меня здесь это не срабатывает,
и у меня идет вызов 4, и он пока не закончился, потому что до этого второе слагаемое не
посчитается, пока первое не посчитается, правда? 4 у меня это 3, соответственно, 3 у меня это 2,
2-1 здесь я закончил, значит, после этого у меня здесь второе будет слагаемое, и снова 2,
теперь у меня будет снова 3, и вот это все под дерево, сейчас мне придется, так, простите,
да, здесь я перестарался, это все под дерево, 3 у меня будет небольшое вот это поддеревание,
так, стоп, да, с счета я запутался, небольшое вот это под дерево у нас будет с вами дублироваться,
вот у нас 2, здесь 2, теперь 5 это 4 плюс 3, соответственно, вот это 3, это вот это под дерево,
сейчас мне придется его заново с вами переписать, 2 и 1 это 1 и 0, ну вроде как не так страшно,
но допустим, у меня был бы вызов от 6, тогда что у меня происходит? 6 это 5 плюс 4, и тогда вот
это все штука после того, как посчиталось, здесь начнем сочетаться заново, то есть 4 это 3 и 2,
3 это 2 и 1, 2 это 1 и 0, 2 это 1 и 0, и если бы это было, например, 7, то это было бы 6,
и 5, а 5 это уже вот это все, и вы видите, что стек-то здесь как раз не переполнится,
у нас нет проблемы со стеком, его глубина небольшая, вот глубина стека, у нас проблема будет другая,
здесь у вас не глубина, а ширина, что значит ширина, время выполнения, потому что вы одно и
то же значение считаете много раз, пересчитываете его, и фактически, если посмотреть на сложность
алгоритма, она экспоненциальная, вы учили сложности, и знаете, что экспоненциальная сложность
тому большую, потому что при увеличении, это легко доказать, при увеличении n на 1,
у меня сложность растет в два раза, потому что у меня сразу две ветки, и здесь вы будете там
считать 4 часа или там сколько-то часов, значение равное 30, именно из-за сложности,
потому что у вас линейная, обычная программа посчитала бы это циклом, просто берете две
переменные, сдвигаете и складываете, вам не нужно ничего, а здесь вы сделаете вместо линейной
сложности, вместо o от n, n переносите в степень, ну и все, и вы убиваете себя, и это ужасно,
потому что это вы не понимаете тогда базовых принципов алгоритмов, что такое сложность, и вам
кажется, что вообще эффективность не нужна, если вы так пишете, то что будет с вами дальше, как вы
будете программировать, будете там, не знаю, эстер и лен писать в каждый фор, внутрь по пять раз,
в выражениях эстер и лен, плюс эстер и лен, плюс два эстер и лена, еще давайте одним эстер и леном это
все загоним, вот, и после этого у вас вот примерно таких программистов боятся и в нормальной it компании не
берут, но если вас вдруг попросят написать рекурсивные фибоначи, бывает таки, я знаю подло интервью и
видел я разные вопросы, много наших пусняков работает по всех it компаниях мира, и они рассказывают,
человек там спрашивают, когда там в гугле они проходят собеседование, когда ты пишешь и какой-то
индус тебя собеседует, ну как правило там очень много просто индусов, которые тоже крутые
программисты как русские, он тебе дает код, он дает тебе задачу, смотрит как ты кодишь, причем не что-то там
супер сложное, да, там может быть бин поиск, еще какие-то вещи, сортировочка, и в том числе могут
попросить написать фибоначи рекурсивно, это задание с ловушкой, они надеются, что вы это понимаете,
напишете по-другому, можно написать рекурсивно с помощью дополнительного параметра за нормальную
сложность линейную, но это будет такая задачка на подумать для тех, кому интересно, а теперь
последнее, что я хочу сказать про рекурсию, как вы думаете, если задачи, вообще можно ли обойтись
без рекурсии, или вот бывает момент, когда без рекурсии вообще никак, вот вы в футболочке МФТИ,
скажите, да, в черный, а что нам дает, давайте попробуем докопаться до принципа вообще,
что нам дает рекурсия, что она такого делает, делает ли она что-то, что мы с вами не можем сделать
сами, ведь если мы перейдем на уровень ниже, а мы с вами программисты C++ уже довольно программируем
на низком уровне, да, мы понятны, что это спецукороний язык, но, тем не менее, это не питоны,
не какой-нибудь скриптовой ноукод, тем не менее, мы что делаем в рекурсии, что дает рекурсия
такого нашей программе, первое это цикл, почему, потому что она повторяет какие-то действия,
это можно повторение реализовать циклом, но это не только цикл, что она еще добавляет,
вот если посмотреть на вот то, что выписывал в стеке про factorial, что она добавила к этому циклу вызовов,
да, ответите, да, на каждый вызов была переменная, это что, если все эти переменные объединить,
это массив, то есть фактически рекурсия это стек плюс массив какой-то, то есть этот стек
можно просто самим промоделировать, взять массив, туда все это нужный момент записывать,
и поэтому все можно решить, конечно же, без рекурсии, потому что она не дает ничего нового,
она просто автоматически делает массив, который на стеке создается во время этих вызовов,
если мы, слепок, это не все понимают, но это кстати очень классно, если вы это сразу поймете,
для вас рекурсия не будет какой-то такой загадкой, то есть слепок, если мы в стеке возьмем в текущий
момент времени, это тот массив, который она автоматически создала, ну там может быть
разный массив, не обязательно однотипный, у вас могут быть разные переменные,
то есть там несколько массивов или массив-структур, а второй это цикл, который она вам организовывает,
поэтому массив плюс цикл вам решает проблему, и тот же DFS мы можем написать как рекурсивно,
так и не рекурсивно, то есть поэтому просто рекурсивно это будет проще за счет того,
что часть работы за вас сделает компилятор, в частности автоматически в нужный момент
организует вам хранение данных. Это все про рекурсию, и мы с вами сделаем небольшой
прерыв 5 минуток, и после этого перейдем к новой нашей теме перечисления. Мы переходим
к новым таким пользовательским типам данных, которые нам позволяют конструировать более
сложные объекты. Синтаксис перечисления следующие, ену, перечисления еще были и в C,
C++ просто немножечко их усовершенствовал, но они у нас были очень давно, имя типа и список
целочисленных констант. Писок целочисленных констант. Иногда нам требуется с вами работать
с константами, когда их некоторое ограниченное количество, например, мы хотим с вами возначить
север, юг, запад, восток, дни, недели, еще что-то, и хотим это сделать константами. Чтобы подчеркнуть,
что эти константы принадлежат какой-то одной сущности к одному типу данных, мы можем эти
константы сделать типом перечисления, объявить их в нем. Тогда компилятор поможет вам контролировать
типы, чтобы вы там не ошиблись, и кроме севера, запада, юга и востока использовали еще что-то
несуществующего часть света, пятое измерение. Поэтому в этом случае вам компилятор опять же
будет в помощь. Ну давайте на примере это покажем и объявим перечисления дни недели. То есть я хочу
сделать константы, которые будут у меня обозначать дни недели, и объявлю перечисления, которые будут
иметь ими типа days of week, дни недели. А сами константы будут иметь значения, которые мы с вами
сейчас напишем, и имена этих констант будет днями недели. Потому что мы с вами как бы должны
привыкнуть, что в программировании все на американский манер. У них дни недели тоже начинаются
в воскресенье, потому что все языки у нас создавались. Большое влияние культурное США есть
в программировании, вот так скажем. Вот, я честно не слышал, что вы сказали, но давайте к перечислению.
Какие значения получат эти константы? На самом деле по умолчанию все понятно
нумируется с нуля. Это будет 0, это 1, 2, 3, 4, 5, 6. То есть от нуля до 6 у вас получат значение дни
недели. Таким мы не явно это сделали, мы это могли бы сделать явно. В следующем примере напишу,
как это будет. Но здесь, когда вы не даете никакие значения константам, они всегда целочисленные,
в перечислении у вас всегда только целочисленные константы, это их имена, и по умолчанию дается
с нуля и следующая на единицу больше. Примерно как наше рекурсивное определение только что было для
натуральных чисел. Опять же влияние США, что они с нуля. Значит int main. Теперь, когда у нас есть вот
этот тип, можно объявлять переменные этого типа. Мы взяли с вами, сконструировали новый тип,
новый тип данных, days of week. На прошлой лекции мы уже с вами делали новые типы с помощью TypeDev.
Помните, для того чтобы простить себе жизнь, и существующие какие-то типы присваивали им
новые имя. Так и здесь мы создали новый тип, тип называется days of week, и можно создать переменные
этого типа D1, D2. Что хорошего, теперь компилятор будет контролировать, что D1 и D2 это переменные,
которые можно присвоить только вот из этого набора, и не даст вам присвоить ничего другого.
То есть, если я хочу что-то присвоить D1, то я должен написать имя какой-то константы,
которые здесь есть. Я даже не могу написать там равно пяти, он не даст компилировать. D2.
Пусть у меня будет это понедельник, а это четверг. Вот я объявил. Теперь я могу делать некие
арифметические операции между ними. Например, я могу ввести переменную int, которая посчитает
difference между ними, разницу, и вычесть одно из другого. Вот в этом случае при, там мы можем
применять те же операции, которые допустимы к целочисленным переменным, и здесь произойдет
неявное преобразование в int в этот момент. То есть из int в перечлении нельзя, из перечления в int
можно. Результат будет 3. То есть значение этой константы, оно у вас подставится, у вас была
эта единичка, это была четверка, 4-1, 3, и в этой переменной будет 3. Можем сравнивать,
например, написать, если первый день меньше второго дня. То же самое, у вас будет сравниваться их
целочисленные значения. Ну и дальше там что-то. То есть можно такие вещи писать, там cout,
какое-нибудь сообщение. Перечисления имеют недостатки. В частности, если вы попробуете
вывести его на экран, то есть напечатаете d1, то вы не получите красивое мандой на экране. Вы
получите значение этой константы. То есть опять же будет неявное преобразование в int. Это очевидно
почему. Это лишь имя, это имя константы. У нас некие имена в скомпилированном коде не хранятся. Ведь
когда мы пишем программу, мы называем переменные. Можем назвать переменную i, можно написать
горшок, а можно написать какое-нибудь очень длинное, длинное, длинное слово или несколько слов. Например,
одно слово несколько раз, которое вот сейчас прозвучало, 20 раз через знак подчеркивания. И вы
тем самым думаете, что компилятор будет каждую эту переменную хранить в памяти на ее имя. Зачем
она ему нужна? Он, собственно, для этого компилирует, чтобы ваш бред привести в обычный машинный код.
Там просто будет адрес того, где это хранится. Никаких имен там не будет. Там будут адреса и
обращения к этим адресам. Поэтому понятно, что здесь имена это для вас, чтобы вы лучше читали код.
Ему не нужны никакие имена, ему нужны цифры, адреса и так далее. Поэтому именно так оно и
рабосмещение, оно именно так и работает. Поэтому он знает, где это хранится, и знает, чему оно равно.
Так, а вот эта проверка, которая здесь, почему вы можете спросить, вот здесь же он знает,
потому что это на этапе компилианции узнает. Когда он скомпилировал все, а вашей программе забыли,
есть машинный код, который ничего не знал, как его создали, и он уже выполняется. Вот, собственно,
задача компилятора. С вашего языка она… Да. Ну, это проблема, потому что у нас нет явного
преобразования, вы не можете ввести. Вы можете только задать. И вот сейчас еще важный момент,
как их задавать нестандартно. Смотрите, сейчас я сделаю перечисление, которого не будет имя типа,
мы можем также сделать, но в нем будут только некие константы. Все, мы закончили вообще эту
штуку, все закрыли и забыли, и сделали какую-то константу, например, и начали прямо присваивать
значения. Это можно делать, можете сами присваивать значения. Какой-то момент вам надоело
присваивать значения, тогда следующее значение будет плюс один от предыдущего. Можно даже
выражение здесь писать, например, ten plus forty, fifty равно ten plus forty. Я могу даже дальше пойти,
чем в этом примере. Можно заново начать, можно сделать там три, и после этого, если вы не напишете,
будет четыре по умолчанию, то есть он будет приводить единичку к последней, но это так никто
не делает, потому что хорошо бы вам по возрастанию их писать, чтобы потом код было удобно читать.
Если вам совсем интересно, даже можно делать одинаковые константы, то есть разные имена на одно
значение. Такое может понадобиться, может, у вас там есть синонимы для пятерки, вы хотите,
чтобы так и так можно было. То есть это тоже будет работать. Какие еще вообще есть разумные
примеры перечисления? Ну, например, перечисления, можно сделать переключатель. У вас выключено это
нолик, включено это один, и ну это как бы логично, но просто чтобы 0,1 написать, вы можете более красивые
константы себе ввести, и компилятор будет контролировать, что у вас именно они используются в нужном
типе данных. Например, еще может быть какое-нибудь там перечисление, относящееся обязательно к одной
сущности должно быть, например, по времени. Вы знаете, что в стране, которую я упомянул, есть такая
система времени, связанная с меридианом и mpm, и вот такое перечисление. Не только 24-часовая,
но и 12-часовая там система принята. Нет, я написал с большой буквы, просто, наверное, плохо видно,
простите. С большой буквы да, потому что это уже другое. Так, ну а перечисления, вообще чем
перечисления, если еще посмотреть, отличаются тента? Вообще, зачем они нам нужны, почему нельзя
просто интом все делать? Во-первых, да, у них есть некая общая сущность, во-вторых, их немного,
вот, например, я не знаю, север-юг, запад-восток. Вот у вас четыре каких-то объекта, из них можно
сделать хорошо перечисления, потому что их ограниченное количество, они имеют какой-то смысл,
их понятно как назвать, и нужно контролировать. Когда же объектов у вас много, например, не знаю,
какие-то игроки выиграют игру, их пронумеровали до 456, и тогда, конечно, не надо делать такое
перечисление, потому что, ну, вам, во-первых, у них нет имен, вот есть такая игра, был недавно
сериал, там у игроков не было имена, вы не можете сделать перечисления, если их сделали, если у вас
объекты не имеют имен, это явный пример, когда перечисления неприменимы, потому что здесь у вас
север-запад, восток-юг, можно написать там south, да, north и так далее, west-east, а здесь у вас,
если только номера, вы не можете сделать перечисления, это первое, когда вы не можете
делать перечисления, второе, даже если вы узнаете имена персонажей в этом сериале, все 456,
то вы все равно не можете их сделать перечисления, потому что это очень странное будет перечисление
с таким количеством значений, поэтому вы должны использовать всегда в программировании принцип
разумности, у вас не должно быть кода, который невозможно легко прочитать, читать 456 констант
очень неудобно, вот, поэтому ограничивайтесь там, не знаю, 12-15, но это, наверное, совсем максимум,
которые можно для перечисления брать, а лучше вот такие простые примеры, которые у нас были там
дни недели и так далее. При перечислении всё, и переходим к нашей следующей теме, структуры.
Структуры появились в языке C, но C++ их сильно преобразил, тем не менее, начнём с базовой идеи,
зачем структуры появились у нас в языке C. У нас были массивы, массив хранит информацию о
нескольких объектах, о нескольких каких-то свойствах объекта, но массив имеет главное
свойство, какое, что все элементы должны быть одного типа, вот если мы захотим, например,
представить элемент «студент», у вас есть параметры разного типа, вот, например, я не знаю, вот вы,
в красной футболке, да, вот вы, да, вот вы, вы студент, у вас есть имя, как вас зовут? Артём,
это какой тип данных, Артём, ваше имя? Чар-звёздочка, что за чар, у вас имя за одну букву, что ли?
Чар-звёздочка, значит, давайте какой-нибудь интовский, вот ваш рост, 175, хорошо, стипендия,
это, наверное, long-double, я думаю, что поместилось, это фистех, поэтому здесь самые большие стипендии,
вот, то есть мы видим, что у Артёма, как минимум, мы уже нашли чар-звёздочку, уже инт, уже даббл,
если поискать в закромах, то можно, наверное, все типы придумать, да, сколько там зубов у Артёма,
я не знаю, и так далее, чтобы описать сущность «студент», и в этом случае массив для Артёма не
подойдёт, потому что имя это, например, чар-звёздочка, а размер во стипендии это long-double,
и нам, что ты загрустил, Артём, вспомнил про стипендию, ничего страшного, у тебя будет повышенное,
сдашь на все пятёрки первую сессию, я уверен, вот, хорошо, Артём, сравним после сессии, будет ли у
тебя средний балл 5 или выше? Вот, значит, я думаю, что, соответственно, структуры появились как раз для
хранения информации разного типа в одном таком объекте, где у нас есть некая физическая сущность,
мы хотим описать её свойства, например, не знаю, вот телевизор у него, есть там длина диагонали,
есть цвет, есть цена, есть ещё страна выпуска, и всё это данные разного типа, а я не хочу хранить это
в разных переменах, хочу в одной переменной телевизор, для этого и придумали структуры,
они изначально все такими и родились, и объявляются структуры, следующим образом мы пишем стракт,
после этого имя типа, фигурная скобка, и объявляются поля структуры, каждое поле имеет какой-то тип,
вот как я на примере про Артёма или телевизор рассказывал, тип элемент 1, и это у нас какой-то
тип 2, это вот второе поле, да, какое-то имя переменной, элемент 2 и так далее, может быть у нас много
разных типов, несколько элементов могут иметь один и тот же тип, закрывается фигурная скобочка,
здесь необычная, дальше у нас, может быть вы не привыкли ещё, есть возможность описать этого,
мы завели тип и сразу создать переменные этого типа, то есть я могу здесь написать список
описателей, у меня это называется формально, он не обязателен, поэтому он квадрат на скобках,
и здесь у нас могут быть переменные, указатели или массивы, переменные, указатели или массивы,
и точка запятой ставится, и вот это вынос мозга, особенно там, потому что мы иногда не можем
не писать список описателей, опустить его, и тогда будет тот случай, когда после фигурной скобки
ставится точка запятой, она обязательно, если вы не поставили, потому что вот строчка у вас начинается,
и надо закончить, и у вас не скомпилируется, вот эту точку запятой не забываем никогда ставить,
давайте напишем структуру студент, про которую я рассказывал,
пусть у меня будет некий массив piu,
из 30 букв, я думаю, нам хватит, если нет, расширим, например, у вас может быть какой-то
int, номер, там, не знаю, ну, там, рост, там, hate, то, что мы говорили, и стипендия, да, у нас,
double, давайте, ладно, спустимся с небес на землю, double хватит, я думаю, вот, double,
там, salary, зарплата, да, и все, мы закрыли с вами структуру, и теперь я могу создать сразу,
просто объекты, которые я упомянул, то есть, я могу сделать, например, массив, там, вот наша fpmi,
нет, не fpmi, у нас есть базовый поток fpmi, f-p-m-i, базовый, видите, bmf, в общем, вот это,
и сразу создать сколько нас, там, 120 человек, вот я создаю сразу 120 Артемов, 120 таких структур
мы создали, куда мы сможем записывать про каждого данные, можно при указатель,
pointer на нашего студента, вот, собственно, пример этого синтаксиса, который был,
мы могли с вами не писать, не список описать или опустить его, вы успели это переписать,
я могу здесь стереть, да, Артем, вы руку подняли, ладно, мы могли здесь не писать,
а поставить точку запятой, тогда бы я просто объявил тип, а, да, я, конечно, тупо сделал,
я сказал, вы успели, вы сказали, нет, а я стер, и, простите, я просто хотел, я боюсь, чтобы все успеть,
я поэтому спросить должен, да, мнение спросил, мнение профсоюзного комитета студента пустяно,
поэтому, вот, значит, поэтому отчисляем, значит, мы можем не писать здесь никакие описатели,
то есть не делать никакие переменные, никакие массивы, никакие указатели, а у нас теперь есть
новый тип, мы можем просто объявлять ниже в любом месте переменные этого типа, то есть,
как обычно, ind, например, пишем ind, какая-то переменная, так и здесь я могу написать,
вот это наша bfpmi, тот же самый массив от 120, например, сделать и указатель, то есть,
не обязательно объявлять там сразу, вы можете объявить это потом, потому что тип у вас уже есть,
вот этот тип student, здесь у вас тот же самый тип student, мало того, можно это стереть? Хорошо,
вы уже научены, да, поэтому, когда в следующий раз спросите, вы всё равно, зачем говорить,
да, нет, всё равно я сотру, я справлюсь, можно здесь сразу, например, объявить ещё один пример
какого-то студента и задать ему начальное значение, например, Артём, так его и назвали,
с большой буквы, вот, и Артём равен, и в фигурных скобках, так как мы обычно инициализировали,
например, массивы, мы сейчас проинциализируем Артёма, разные поля через запятую, значит,
его фио, там Иванов, его фамилия, допустим, его рост 1,775 и его стипендия, сейчас мы напишем,
55 678 рублей 91 копейка, вот, значит, Артём, наверное, межнар у нас, поэтому у него повышенная стипендия, так,
а мысли без точки вообще, да, сейчас мы будем, теперь как проинциализировать массивы структур,
давайте запишем маленький подпункт, инициализация массивов структур,
пусть у меня есть некая структура, которая, например, содержит в себе значение комплексного числа,
в ней есть два поля типа float, real и im, я сразу же, где объявил новый тип, сейчас конструирую массив этого
типа и назову его compel, это будет двумерная матрица из комплексных чисел, размера 2 на 3,
как мне его проинциализировать, также ставлю здесь фигурную скобку, теперь по строкам и
каждый элемент структуры еще в своей фигурной скобке, поэтому здесь получается три фигурные
открывающие скобки подряд, потому что первый элемент 1 1 это вот как раз структура, каждый
элемент структуры это элемент массива, то есть это первая строка, стоящая из трех у нас столбцов,
допустим они все одинаковые, и закрываю первую строку, ставлю также запятую и
инициализирую теперь вторую строку аналогичным образом, вот я инициализирую многомерный массив,
и когда я закончил, я закрываю теперь фигурную скобку для начальной инициализации, ставлю точку
вот у нас как это получилось, теперь как получить то, как хотите, во-первых, это не важно,
хотите как напишите, я же говорю, всегда тип данных, как я хочу, если это не ключевое слово,
если я копирую одну структуру в другую, то есть если я присвоил, если я хочу скопировать одну
структуру в другую одного типа, я могу просто их присвоить, например, если у меня есть два элемента,
Артем и гор, если я хочу скопировать они одного типа student, если присваиваю Артем гору,
то просто все поля скопируются из того, от чего мы присваиваем, тому,
что мы присваиваем, то есть происходит элементное копирование при присваивании двух структур,
но они должны быть одного типа, теперь давайте запишем маленький подзаголовочек доступ к полям структур,
да, этот тип и есть тип структуры, да, итак, у нас есть операция точка с помощью этой операции,
она у нас даже была в списке фриоритетов, мы можем с вами получать доступ к поле структуры,
так называемой операции выбора, например, если у нас есть структура Артем, Артем,
прости, что сегодня все примеры на тебе, то мы можем поставить точку и,
например, обратиться его фамилии, либо, если это какой-то массив, вот, например,
у нас был компл, мы можем также через элементы массива обращаться, более интересно,
что бывает, если у нас с вами есть указатель, давайте вот здесь, помним, что у нас было недавно
написано, где, например, я объявил некую, где я объявил некую перемену, являющуюся указателем
на эту структуру, это PS. Как мне сейчас обратиться к полю фио от указателя на структуру? Стандартным,
старым, добрым C, я должен что сделать? Если это у меня указатель, я должен его разыменовать,
правильно? Как мы разыменовываем указатель? Какой амперсант? Теперь скобочка мне нужна,
поскольку там приоритеты, у нас еще сейчас сломаются, если мы ее не поставим, чтобы точка
не перетянула и взять точку, вот что было, то из этого сделали все плюс-плюс, поняли,
что это так часто нужно, сделали специальную операцию, которая называется стрелочка,
мы можем теперь написать PS, стрелочка, которая просто пишется как минус и знак больше,
и, например, доступ к полю селари и присвоили что-то там, здесь тоже Иванов, вот так мы можем с вами
получать доступ к элементам структуры по старому и по новому, и последнее, что я хотел сказать,
это структуры на самом деле в C были именно тем, что я рассказал, но без стрелочки, стрелочка это
уже C++-ная штука, которые позволяли нам работать с элементами, объединять элементы разного типа
в один тип, C++ объектно-ориентированный язык, и главная сущность здесь классы,
у вас вообще будет целый курс, который называется объектно-ориентированное программирование
в целый второй семестр, и классы это не только данные, но и некие действия над этими данными,
именно методы, и поэтому у нас есть класс, который фактически является продолжением структуры,
но в новом синтезе C++ в структуре можно все делать то же самое, там тоже можно писать методы,
фактически вы можете делать не класс, а структуру, но есть некие отличия, и эти отличия, самое главное,
которое вы должны знать, кроме там есть еще элемент с наследованием, заключается в том,
что если в классах по умолчанию все поля закрытые, а здесь все поля открытые, главное,
что мы должны понять, что здесь все поля открытые, к ним может каждый обращаться,
и извне вот я вот такое могу делать, потому что в C++, если бы такое написал, поле было бы закрытое,
я бы не смог обратиться к внутренностям, если бы я не открыл специальным образом это поле или
не сделал через специальный метод, а здесь у меня все открытое. Все, на этом наша лекция закончена,
и мы с вами увидимся через неделю.
