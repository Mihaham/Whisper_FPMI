Всем доброго дня! Мы с вами продолжаем наш интересный курс. Сегодня у нас план на лекцию такой.
Сначала мы с вами закончим предыдущую тему, а именно рассматриваем, как у нас будет работать
Gorbache Collector. А следующий блок у нас будет посвящен тому, каким образом у нас работает
функциональная парадигма. Во-первых, в императивных языках программирования, а после этого мы посмотрим,
каким образом работает чисто функциональная парадигма на примере того, как работает весь
конвейер компиляции в таком языке под названием Haskell. Давайте вспомним, на чем мы с вами в прошлый раз закончили.
Мы, кажется, с вами в прошлый раз закончили на типизации Gorbache Collector
по времени остановки. У нас есть Stop the World, когда у нас запускается Gorbache Collector на все
лоцированные памяти в куче, и есть Stop the Pause, когда у нас Gorbache Collector запускается только на
небольшой части объектов в куче. Цель как раз состоит в том, чтобы двинуться дальше и посмотреть,
какие вообще Gorbache Collector существуют. Первые из Gorbache Collector, которые у нас есть, это
поколенческие Gorbache Collector. То есть, что мы говорим? Мы говорим следующее, что у нас с вами все
объекты в памяти делятся по следующему признаку. То есть, количество стадии Gorbache Collector,
который пережил данный объект. Самый молодой объект это объект G0. После того, как объекты
у нас пережили, одну очистку Gorbache Collector у нас, это все переходит в поколение G1. Дальше у нас
дополнительно переходят еще переключения из G1 в G2. Почему темы Gorbache Collector интересны,
я сам тут сидел ночью работал и понимал, что в одном месте очень интересный факт оказался,
что я загружаю модели параметров в нейросеть. И почему-то, когда я перемещаю их в ГПУ,
память остается на цепу. И у меня просто берет и память остается на цепу. Понятно,
что такого быть не должно. Не на цепу в оперативной памяти. Важная тема и надо посмотреть,
каким образом мы это все делаем. Теперь смотрите, как мы можем реализовать stop-the-pause. Мы должны
запускать очень часто сборку мусора в поколении G0. Чуть реже мы должны запускать сборку мусора
на, так сказать, G1 и еще реже на G2. Это как раз основная концепция, которую мы хотим преследовать
для решения нашей задачи. То есть, грубо говоря, запускать на таких мастодонтов память как можно
реже. Здесь есть еще тезис. Если книги существуют 200 лет, то, скорее всего, с высокой степень
вероятности она еще проживет 200 лет. Понятно, что какие-то молодые вещи очень часто отмирают.
И мы как раз пытаемся реализовать эту концепцию. Здесь нужно посмотреть следующую вещь. Чтобы
наша очистка мусора не затрагивала именно большое количество ссылок на объекты G1 и G2. Потому что
если у нас есть объект в элементе G0, то понятно, что она будет затрагивать ссылки на G1 и G2. То есть,
если есть какой-то указатель, то нам нужно или, допустим, у нас есть объекты G1, которые начинают
ссылаться на объекты G0. Понятно, что тот же самый MarkSweep или MarkCompact запускать каждый раз на
новых объектов, которые мы присоединили, это очень неприятно. Поэтому здесь нам нужно будет
отслеживать именно эти моменты и попытаться каким-то образом найти эти объекты, которые начинают
ссылаться на объекты G1. Какие способы запоминания у нас есть? На самом деле, либо списком, либо мы
можем использовать множество, либо мы можем использовать грязный хак под названием duty bit.
Значит, в чем он заключается? Он заключается в том, что если мы пытаемся обновить область старой
памяти, то мы устанавливаем bit, что в странице была произведена запись, тем самым мы ее отвязываем
от контекции исполнения. Сразу тут нужно сказать, что те элементы, которые у нас как раз в этом
множестве попадают, в принципе, они будут являться корневыми вершинами для запуска сборщика
мусора. Потому что мы их прямо записали, а остальные объекты, возможно, уже никаким образом не
привязаны. Дополнительно мы можем, кстати, хранить корневые объекты, но в целом еще вершины для
запоминания. Почему мы с них стартуем? Как вы думаете? Желательно запускать алгоритм guardbatch
коллектора от тех вершин, которые мы привязали к вершинам из предыдущих поколений. То есть суть
в чем? У нас есть объекты, значит у нас... А, нет, это у нас объекты из g1 и g2. Мы запускаемся на них и
смотрим ссылки на объекты g0. Почему из них можно быть эффективно запускать сборщик мусора? На объекты
g0. Ну мы просто скорее всего тогда быстро пометим вершины, которые нам нужны, потому что они
ссылаются на новые объекты. И, собственно, мы сразу забетонируем эти объекты, что, пожалуйста,
типа вот у вас новый объект, он живой, поэтому желательно не стирать ссылку на этот объект.
Вот, значит, и после этого, как у нас есть Generational GC, у нас есть еще другие сборщики мусора,
и они заключаются в следующем, что у нас с вами может быть два разных, две разных разновидности
горбач-коллекторов. Первая разновидность это incremental garbage collector, который работает по
требованию, да, то есть, который запускается раз в какой-то промежуток времени, либо мы можем
явно вызвать garbage collector для реализации наших результатов. Вот. И второй это параллельный
сборщик мусора, то есть это сборщик мусора, который работает параллельно с исполняющим кодом,
и здесь у нас возникают два новых объекта очень важных. Первая роль это у нас сборщик, собственно,
который собирает мусор, а второй это mutator, то есть это тот объект, который меняет граф
в доступности данных, то есть у нас есть все перемены, у нас есть ссылки, и нам нужно помечать,
как у нас объекты взаимодействуют с этими ссылками. Вот. Собственно, давайте посмотрим, как работает
именно мутатор. Значит, для этого, как ни странно, нам нужно вспомнить принципы DFS и VFS, да, потому
что мутатор будет красить вершины. Да. Давайте вспомним, за что отвечает белый цвет. Ага, серое.
Да, да, да. Она находится в теке, мы ее еще не посетили. Есть вершина черного цвета. Да,
мы обошли все по дереву, которое было в этой вершине. Все верно. То есть в итоге у нас белая вершина
не посещена, серая эта вершина находится в обработке, черная эта вершина посещена. Основные варианты,
которые у нас есть в обходах DFS и VFS, что у нас нет в DFS, что у нас нет ребра из черной вершины в белую.
Почему? Да, если есть, то она уже не белая. Значит, серая вершина на самом деле находится в структуре данных
нашего обхода. В нашем случае это будет структура данных сборщика мусора. И какие у нас, давайте
подумаем, какие у нас подводные камни могут быть, когда мы реализуем параллельный горбач-коллектор?
Ну, параллельный с работающим кодом. Ну да, то есть первая проблема, которая у нас может быть,
это в какой-то момент времени у нас есть серебро из черной вершины в белую. То есть оно просто
появилось. Ссылка черная указывает на белый объект. Значит, здесь нужно каким-то образом обработать
эту вещь. У кого есть идея, каким образом это можно обработать? Интересный способ. Можно в онлайне
попробовать это поменять. Правда, через блокировку. Вот смотрите, если у нас есть какая-то белая вершина,
мы аллоцировали с вами какую-то переменную и говорим, что х приводит значение у, то что у нас
может произойти? У нас эта вершина внезапно может быть привязана только к текущему объекту. То есть
мы с вами создаем поинтер, отвязываем, уходим. У нас срабатывает горбач-коллектор. Он увидит,
на самом деле там будет логично, что... Кстати, какие объекты мы должны очистить будем? Какого цвета
после обхода графа горбач-коллектора? Да, все белые. Вот, а теперь посмотрите, у нас вершина черная,
значит у нее идет ребро в белое. Все, больше у нее никаких сидячих ребер нету. Эта вершина пропадает
как только она была создана. Есть некоторые лайфхаки, которые позволят это решить. Есть первая
достаточно такая примитивная идея. Да-да-да, мы говорим про новую локацию во время запуска.
Ну да, то есть первая вещь, это если мы лоцируем переменную, либо второй способ, который на самом
деле чуть-чуть менее приятный, но он заставит нам входить, можно вот эту вершину попробовать серый
цвет покрасить. Ну да, но тогда нужно будет аккуратненько обрабатывать. То есть добавить вершину
force в черную мусору. Вот, и собственно, на самом деле вы не поверите, есть три разных методики записи,
то есть когда мы делаем запись, мы на самом деле делаем такую сущность, как под названием write
barrier. И первый способ, как раз, который мы с вами обсуждаем, когда мутатор делает ссылку на белый
объект A в черном объекте B, то мы A перекрашиваем в серый цвет. То есть это реально одна из методик.
А, подождите, у нас не B перекрашивается в серый цвет, у нас A перекрашивается в серый цвет. Я
что-то затупил. Это логично, то есть у нас относительно этого объекта мы говорим, что он
лоцируется. Кстати, сразу скажу, что он именно красится не в черный цвет, а в серый цвет,
потому что на него тоже могли навешаться ссылки. Значит, второй способ, это мы перекрашиваем B,
то есть вот эта методика стиля, то есть, что вот это перекрашивается в серое. И есть два метода,
которые украшаются здесь в серое. И есть как раз следующее. Это, по-моему, то, что Гера предложил.
Да, то есть все страницы памяти, которые покрашены в черный цвет, устанавливаются в
режим. То есть мы ставим жесткий барьер, вот, и когда мы делаем запись в эту страницу, то мы делаем
PageFold. То есть мы говорим, что в этом время нельзя записать перемены. Понятно, что тогда нужно
реализовывать отложенные вычисления в нашем графе работного кода. Так, эти методики понятны?
Хорошо. Так, это когда мы ставим переменную на чтение на запись, то есть что мы делаем. А вторая
методика, это методика переменных на чтение, да. И здесь тоже, значит, мы делаем следующее, что как
только у нас мутатор получает какую-то ссылку на объект, то есть мы хотим прочитать переменную,
и внезапно этот объект стал белым, это означает, что всё равно эта перемена в какой-то момент
времени стала доступна. Поэтому её нужно добавить в список вершин на обработке, и мы её добавляем в
чёрный цвет, ой, в серый цвет. И Apple тоже придумал ещё одну методику. Значит, когда у нас мутатор
получает ссылку на объект B, содержащий в нечёрной странице вертолем памяти, то есть серый или белый,
тогда, собственно, любой тот, кто запрашивает эту переменную на чтение, будет красить каждый
указатель на чёрный цвет. То есть, типа, мы обратились к этой переменной, а значит, что
получается? Это значит, что по факту мы с этим объектом уже можем работать, а всех детей чёрных
вершин в серый. То есть мы произвели чтение и в режиме реал тайма обработали эту вершину.
То есть инжектим как раз механизм синхронизации. Это что происходит, когда мы в параллельном
гарбоч-коллекторе, или stop the pause, это работает либо в stop-pause, либо в параллельном
конкарном гарбоч-коллекторе. Так, понятно ли эта методика? То есть, в принципе, мы уже с вами с этим
можем работать. Так, ну и теперь давайте рассмотрим примеры гарбоч-коллекторов в разных языках
программирования. Сейчас питон активно меняется, вот, это важно сказать, ну да. Вот, ну на самом деле,
если мы говорим про всякие нейросети, то просто в какой-то момент намертво после всех проглонов
там просто гарбоч-коллектор вызывается. Причем там несколько гарбоч-коллекторов вызывается,
там первый гарбоч-коллектор, который вызывается, это, ну, собственно, сам ГЦ, а второй гарбоч-коллектор
это торчёвый гарбоч-коллектор, который берет и вычищает CUDA кэш. То есть там какие-то переменные,
которые нужно было закушировать, он их очищает.
То есть, у которых нет ссылок, но другие объекты.
Ну там, кстати, у разных фреймворков есть
разные вызовы горбач коллекторов.
Итак, значит, в Python у нас
GenerationUntil и второй это подсчет
числа ссылок.
Как оно работает?
Собственно, в Python у нас с вами
есть вот такой пример.
И, значит, здесь у нас как раз указывается
sys.getTrashCount, то есть, что позволяет узнать
количество ссылок на объект.
И дальше мы как раз можем запустить
getTrashOld, то есть, узнать пороги
для количества объектов, чтобы запускать
ГЦ для каждого поколения.
В принципе, по-моему, их можно
переустановить, поменять.
По умолчанию, значит, 700 на поколение G0,
10 на поколение G1 и 10 на поколение G2.
Это вот такое значение.
Возможно, кстати, оно меняется
со временем.
Давайте попробуем посмотреть.
Python 3.
Gc, Gc.
А, нет, вот.
Дальше современных версий
из Python пороги те же самые.
Это Python 3.12.
То есть, за несколько лет
у нас ничего не поменялось.
Вот, ну и в принципе здесь вот как раз
пример, что у нас создается нода.
А после этого мы указываем
с вами вершину x.
После этого считаем количество ссылок
на объект x.
Кстати, вопрос, почему количество ссылок
на объект x
равняется 2?
О, пример.
Ну да.
То есть, оно сохраняет ссылку себе,
а потом считает количество ссылок.
Так, дальше у нас x,
значит, что мы делаем?
Дальше, значит,
мы считаем x.x
эта нода.
И здесь тоже у x.a.x
создаются две ссылки.
А дальше мы делаем следующее.
Присваиваем переменной a значение x.x.
И тогда у нас ревка у нас
не будет.
И тогда у нас ревка
переменной a будет равняться 3.
Потому что как раз
кто у нас содержит ссылку на этот объект?
a и x.
Когда удаляем
x, у нас количество ссылок
на объект a равняется 1.
И у нас
по факту этот объект остается
в памяти. То есть, у нас он не скидывается
в горбач-коллектор.
Ну, в принципе,
всегда можно вызвать gc-коллектор.
Поэтому
в питоне зачастую используют как раз
оператор dell
для того, чтобы вызвать коллектор.
Нет, конечно же.
Там делается dell, да потом gc-коллектор.
Работает медленно, но
обычно в тех применениях,
когда это в питоне требуется,
когда нужно явно вызвать горбач-коллектор,
несколько десятков
миллисекунд переждать
это не проблема.
Особенно когда обработки идут секунды.
Так, это что касается питона.
А в джаве
значит
более сложный механизм.
В джаве есть несколько
типов горбач-коллекторов.
Первая это gc, вторая
это full gc.
Майнер gc работает
на только молодом поколении
и есть full gc, в котором происходит
полная сборка мусора.
В full gc
есть 4
поколения.
Первая это идон,
вторая это сурвайвер 0,
дальше у нас идет сурвайвер 1
и в конце концов
у нас возникает объект под названием
tenured. То есть это вот финальное
поколение, которое у нас есть.
И как они меняются
между собой? Соответственно они
на самом деле хитрую вещь делают.
Они говорят следующее, что есть
и объекты, которые действительно слишком долго
застоялись у нас.
Поэтому у нас будет
процедура такая, что сначала
все молодые объекты, которые
пережили горбач-коллектор, переходят
в вет
в сурвайвер 0.
Потом идон плюс сурвайвер 0
переходят в сурвайвер 1.
Потом, смотрите, интересный момент,
что идон плюс сурвайвер 1 переходят в
сурвайвер 0.
То есть мы возвращаем его
и только после некоторых переходов
как раз у нас
делается... То есть у нас, видите,
происходят... молодые объекты
перезапускаются всегда, а немолодые
объекты, они как бы
чередуются между собой.
Тем самым мы можем накапливать
наши объекты и перемещать их.
Но потом, после какого-то момента времени
мы понимаем, что есть какие-то объекты,
с которыми лучше
не сталкиваться,
какие-то глобальные объекты,
тогда мы с вами уже их перемещаем
в поколение под названием тенорт.
Так.
Понятно ли схема?
Хорошо.
Так. Это что касается
горбач-коллекторов. Мы поняли
по идее за...
не знаю...
А где он был?
А где у него реализация есть?
Не, мы это в коде
я спрашиваю, мы это в коде найдем?
Давайте посмотрим, где...
У меня все равно есть старый стандарт,
который это...
Куда мы прыгаем?
В memory, видимо?
Так, что мы гуглим?
О.
Ммм...
И где это?
Он гениально.
Memory.
А зачем мне судо?
Сейчас пропишем свои гаражки.
Так, вот он declarable.
Значит, вот он у нас.
То есть вы в ни одной реализации
его не вставили?
Да.
Стандарт сказал, вот есть функции
для сборки мусора, вы их
выполняете, но выполнять не обязательно.
Гениально.
А, я не знаю,
что отличается.
Need to remove.
А есть еще undeclare reachable.
Ну да.
Смотрите, как оно реализовывается.
Очень просто.
Вот, как бы вот.
Вот идеально.
Согласен.
Вот.
А тут не написано,
видимо, тут надо читать
в реддите.
Информация.
Вот, да.
То есть в C++
есть.
И тут надо посмотреть реализации,
в которых это все есть.
Но, видимо, тут
здраво решили убрать.
Сказали, что, типа, надо...
Ну да.
Не, ну можно свой написать,
зато...
Да, есть такой.
Так.
Согласен.
Я, кстати, читал что-то,
что
собрались правительства стран
или правительства этих
советов безопасности
каких-то стран и сказали, что
C++ небезопасен, давайте на раз
переходить.
Ну да.
Да.
Ну да.
Да.
Так.
Ага.
Так.
Не ненавидит траст?
Да.
Да.
Да.
Ну да.
Да, допустим.
Да, допустим.
О, Господи,
и как с этим работать?
Ну да.
Ну да.
А почему
берется ссылка?
Ну да.
Ну да.
Интересно, конечно.
Да.
Понятно.
Реально получается setup
это такие интерфейсы а-ля.
Так, в какой сет вставлять?
Нет, в какой хэш?
В какой сет вставлять?
Так это хэш-сет.
Да.
Ну да.
Да, полезен
переход.
Согласен.
Да, да, да, да, да.
Да, вот они.
Ну, видно.
Ждем.
Последняя версия BLD
была три недели назад.
Ну, развиваются все люди.
Вот, а мы пойдем все-таки
сегодня не...
Я предлагаю пойти не в раст.
Нет.
Нет.
А давай, у меня есть
вопрос.
У меня есть предложение
пойти немного в другую парадигму
даже.
Да, мы пойдем с вами в функциональную парадигму.
Тут, наверное, уже
любопытные слушатели
смогли увидеть, что
в вкладке в браузере у меня
большое количество
складок называется
GHC.
Но прежде чем мы с вами начнем, давайте посмотрим,
как работает функциональная парадигма
в классических языках программирования.
Вот, значит, смотрите, у меня есть пример,
на самом деле, который...
При помощи которых я показывал люди, как колбэки
работают.
Черный экран нормальный, или лучше светлый сделать?
Нормально.
Нет, просто можно сделать вот так.
Просто нормально.
Ладно, давайте так.
У него есть... Слушай, я вот
смотрю, у B3 map
есть dockers.
А, да?
B3 map?
Я, короче, его не заметил.
Ладно.
Вот это вот?
Да.
А?
B3 map.
В этом плане все.
Ура!
Все еще и сестра позвала, потому что после инсерта
мы не знаем про объекты инсерта,
и хотим получить указатель.
Ну, да-да-да.
Давайте мы как раз возьмем
пример,
который я показывал на другом курсе.
У нас
будет вот такой пример.
Я не знаю, видны или нет.
Ну, кстати, вам
везет, у вас на проекторе
немножко световая гамма хорошая.
Она у меня немножко выкрученная.
То есть то, что у вас зеленое, у меня салатовое.
Подкручу профилю.
Так, profile, background.
А?
Вот-вот-вот. Я сейчас как раз для них
это еще и настрою.
Так.
А как вот этот цвет поменять?
Сейчас.
Тупняк.
А?
Какой цвет у нас?
Ага, это selection, это selection text.
Я какой-то цвет не вижу.
Какой я цвет не вижу.
А, тут вам сложно передать.
Вот так сделаю.
Да, теперь видно.
Бывает сложно настроить профили,
но мы справились.
Смотрите, здесь функция...
В чем стоит особенность?
У нас с вами будет функция...
Смотрите, давайте разберем код.
Здесь запускаются два потока.
Первый поток вызывает
функцию runner thread
с аргументом 100
и возвращает функцию callback.
То есть у нас функция callback,
которая принимает на вход
статус код.
Следующую инструкцию.
У нас поток засыпает на определенный момент времени
и дальше у нас выполняется
запрос о том, что
request у нас completed.
И второй поток тоже
есть такой же.
И вот вопрос. Как это
трансформируется в
valueM-овский код?
Давайте
предположение.
Ну, создание передо...
Ну, как...
Надо функцию
создать в создании класса
под каждую ляму.
Да.
Так, lvmain.c
минус...
Да.
Да, значит,
смотрите, тут у нас будут литералы.
Очень много литералов.
А, это я сделал
include называется.
Ладно, проматываем.
Так, так, так.
О, господи.
Во.
Значит, что он создал?
Видите?
Он создал класс под названием
std.function
на определенную ветку.
Причем, смотрите, как интересно
он это запускает.
Да?
То есть, а, это у нас
runner.thread. То есть, мы по факту
вызываем с вами callback.
И это вот такая вот страшная
штука,
которую мы принимали в определенном
аргументе. Причем, смотрите,
а хочу обратить ваше внимание,
что когда мы указываем c++,
в код c++, то у нас
с вами работает как раз сигнатура,
да, то есть мы проверяем
типа, а здесь у нас просто уже передается
указательного звездочку.
И вот здесь как раз есть какая-то
страшная функция называется
function if и ee...
mangling.
Давайте прочитаем.
Значит, смотрите,
восьмерка это function,
а ee это у нас...
это у нас
vee, это из Void to Wind.
E-C-L-G-I. Ну, разберемся.
А теперь смотрите, что у нас
делается. У нас
делается следующая вещь.
Мы с вами,
значит, получаем наш
объект
и создаем его.
Господи.
То есть у нас с вами...
Давайте посмотрим. То есть мы
как раз создаем вот эту функцию.
Раз...
А, стоп, стоп,
стоп, стоп, стоп. Это у нас
этот. Это еще не
main. Подождите.
Вот он main.
Матечная.
Ладно, давайте посмотрим, что оно делает.
Кстати, хочу подчеркнуть, что
видите, у C++,
у этого,
скажите, у LVM
есть опция создания типов.
То есть вот этот
класс Std.ChronoDuration
это как раз структура.
Так, значит,
что мы с вами делаем? Мы принимаем
с вами аргументы и
смотрим процессы 3.
Процесс 3 и процент 0.
Значит, смотрите, что он делает?
Он нам алоцирует переменную
типа class.anon.
Вот, смотрите, то есть у нас
вызывается класс anon 0,
класс anon
другого типа.
Почему они разные?
А, ну, видимо, это у нас функции такие.
Значит, нам нужно будет их с вами найти.
После этого мы вызываем с вами
running thread функцию.
И после этого
делаем slip. О, господи.
Да, конечно, mangling это
очень веселая история.
Вот, собственно, мы дальше
выполняем join.
И возвращаем 0.
Вот они как раз у нас
вызывают
функции join.
О, а это у нас
получается, это у нас
основной контекст.
То есть это у нас thread,
function main.
Да, то есть, видите, у нас это все компилится еще
в основную функцию.
В общем, получается
страшное веселье, в котором мы
с вами должны найти
anon.
Угу.
Это у нас
наверное не надо было настолько
сложный код писать.
Давайте простой код
напишем.
А?
Так, смотрите.
Значит, мы делаем include
function.
Test the function.
Avoid at int
func.
В общем,
мы делаем
include function.
Так.
То есть мы создаем с вами переменную.
Так, точку за пятой делаем, да, func
от пяти.
Значит, давайте
проверим, как это работает.
Угу.
Ну.
Так, function.
Угу.
Ну да.
Так, ну, давайте
посмотрим, как эта функция выглядит.
А.
Угу.
Итак, смотрите. У нас снова
здесь возник объект
класса class.anon.
Объект. И дальше мы вызываем
страшную функцию,
которая называется
std void function
и так далее.
То есть у нас идет как раз
вызов нашего объекта.
И после этого у нас, кстати,
хочу подчеркнуть, что у нас
после этого идет
tool label wind,
пятую метку
и unwind label 6. То есть у нас
по факту получается два
джампа происходят.
Вот это вот у нас вызов
как раз нашей функции.
Вот. И дальше мы выходим
из результаты, вычленяем наши
значения. То есть у нас
по факту здесь
стра...
Ну, видите, то есть у нас
получается с вами создание функции.
Это создание прямо отдельных
объектов, в которые мы
дальше можем прыгать.
Вот. То есть и тут
как, кстати, еще и другие метки
есть. То есть, в принципе,
после этого мы вообще можем
перепрыгнуть в другую функцию. То есть
как бы у нас здесь сохраняется контекст
исполнения. Да? То есть мы вызываем
с вами вот эту function base,
загружаем это все в
переменных. То есть у нас по факту
класс является своим собственным объектом.
То есть вот мы
с вами как раз...
Это у нас, кстати, main,
который алоцировался.
Мы, смотрите, создаем class function.
Это dialog function.
Дальше алоцируем
указатель на
анонимный элемент, на
anonymous. Дальше, значит, мы записываем
переменную %1 в %4.
То есть вот мы принимаем
контекст исполнения функции
main. Вот. И после этого
уже вызываем нашу
функцию, function base.
То есть здесь это прямо
function
мы создаем.
А вот она, кстати,
вот эта вот функция, у нее как раз
нотация вот
вот такая вот. Кстати, где у нас
здесь printf? Давайте найдем его.
Вот она у нас
тело функции. То есть у нее
как раз манглинг случается
вот таким образом. То есть мы с вами
алоцируем объект, а дальше
уже получаем элемент из
аргумента. Значит, почему
так сделано? Потому что здесь
есть еще capturing переменных.
То есть мы можем int
y равно 5 сделать и
принять.
По-моему, вот так принимается.
То есть у нас получается уже
функция принимает и еще
один аргумент.
Кстати, подождите.
Давайте сделаем x плюс y.
Мы с вами
ищем переменную.
Вот она нам приходит.
Значит, откуда она у нас нам приходит?
То есть мы делаем процент 6 и
процент 8. То есть у нас процент 6
загружает наш элемент.
И вот смотрите, очень интересный
момент. То есть у нас
есть переменная класс anon.
Именно в этой класс
anon мы загружаем значение
нулевого элемента.
То есть получается
вот это значение, которое мы загрузили,
это на самом деле элемент структуры
нашего класса. Просто у
нас получается, здесь у нас нету явных
классов в силанге,
в львемском, но вот
видно все равно, что мы какие-то
тут переменные загрузили все-таки.
Вот.
Ну и что
мы с вами в итоге видим?
Мы с вами видим интересные
объекты.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Ну и что мы с вами в итоге видим?
Мы с вами видим интересную вещь, что в принципе
императивная парадигма
программирования нас сталкивает к тому,
что наши объекты должны быть экземплярами
классов.
То есть по факту у нас функция
это классы набором аргументов.
И по факту, когда мы с вами
вот эту вот функцию создаваем, мы создаем
с вами конструктор этого класса
и принимаем аргумент y и передаем
дальше в эту функцию
значение x.
То есть мы создаем как раз одну функцию
с одним аргументом.
Да. Собственно, класс
Anon%0 это как раз SelfObject.
Который у нас есть.
Вот. И если мы посмотрим, кстати.
Вот.
И, кстати, здесь тоже
про то, что вы говорили,
возвращается AddressOfMain.
Называется функция,
которая как раз распаковывает
объекты по указателю.
Вот, конечно, не оптимизировано, но все же.
Вот. И AccessFromMain тоже есть.
Вот. То есть мы
с вами поняли, как работают классы.
Так. Понятно ли это?
Что объект со структурой.
Вот. А теперь вопрос.
Как работают чисто функциональные
парадигмы? То есть ладно бы,
если у нас есть оперативная парадигма,
то, на самом деле, очень
просто взять и наши объекты
скомпилировать
в определенный язык.
Но что делать, если нам приходится работать
с функциональной парадигмой?
В моем случае мы можем использовать какой-то граф
вычисления, потому что
очередной шаг
это не вычисление, а довершение
внизу в блок графа вычисления.
А когда потом нам
пришлось такое, что мы
будем спрашивать, то у нас будет
все части этого графа, которые были
напрошены.
Ну да.
Ну да. На самом деле это похожая вещь.
Там просто наша цель
будет следующая. Поскольку у нас функциональные
языки программирования, они
стараются выражать все, во-первых, максимально
функционально, а во-вторых, в парадигме
линейных вычислений, то конечно же нам
нужно запускать граф вычислений и его считать.
Только на самом деле
нам нужно будет явно задать инструкции.
То есть у нас мы строим граф
вычислений, и нам нужно попытаться
в низком
уровне нашего языка попробовать
задать эти как раз низкие
граф вычислений.
Итак, сейчас мы
посмотрим с вами на чисто функциональную парадигму,
именно посмотрим, как компилиться
код на Haskell.
Давайте посмотрим.
Я взял книгу.
Значит,
гхс, Haskell-компилер.
И сейчас мы с вами как раз попробуем
написать нашу фазу.
Значит, сразу скажу,
что здесь добавляется одна
важная фаза, про которую мы с вами
не поговорили.
Но она не менее важна
во всех компиляторах.
Вот. Просто мы ее
пропустили.
Так, смотрите, с чего начинается.
Для того, чтобы написать нам
код на Haskell,
нам нужно начать со следующего.
Значит, у нас должен быть файл
с расширением Haskell. Haskell у нас
компилируется.
.hs, да.
После этого у нас возникает
следующее понятие под названием
parse.
Ну, распарсить.
Да, распарсить. Я думаю, с этим никаких проблем нет.
Но авторы Haskell'а утверждают,
что у них парсер тоже написан в чисто
функциональной парадигме.
Ну...
Ну да.
Условно есть.
Р не вообще функциональный
парадигм. Да, да, да.
В принципе, так и есть.
Регион функциональный,
пока вы это не отключите.
Ну да, то есть удобная работа.
Спарсер функциональный парадигм. Ну, в принципе, да.
У нас зашли в одну структуру,
не смогли ее распарсить,
пошли в следующую.
Рекурсивный спуск, в принципе.
Рекурсивный спуск вообще
попал, да.
Рекурс вообще функциональный парадигм.
Да, да, да.
Вторая стадия, смотрите,
здесь она называется ренейминг.
Значит...
Манглинг.
Манглинг
в прямом смысле слова.
В Haskell'е
нет такого понятия, как
таблица символов.
Они сразу
перекидывают все
на фули квалифайд на мейн-нейм.
Все переписывают.
При этом
это требует некоторое количество проходов,
но они говорят, что ну и ладно.
Типа
не сильно это беда.
С учетом того, что у нас обычно все переменные,
они как бы анонимные и привязаны в каком-то контексте.
Итак.
Дальше мы с вами происходим в следующее.
У нас с вами происходит тайпчейкер.
То есть, ну, опять же, в любом компиляторе
у нас должен быть тайпчейкинг.
Здесь он тоже некоторый
свичной реализон.
Дальше следующая стадия
называется
дешугеринг.
То есть, на самом деле
большая часть инструкций, которые
мы с вами видим в Haskell'е
это синтоксический
сахар.
То есть, на самом деле такого быть не может.
И мы с вами понимаем,
что если у нас какие-то лямбда функции есть,
то зачастую как раз
нам нужно их явно писать.
То есть, у нас есть только функции
и набор аргументов, которые она может принимать.
Значит, и здесь мы спускаемся
на первый язык, так сказать,
который
называется ER-ом языка
Haskell. Это core.
GHC-Core.
И вот здесь уже будет некоторый небольшой
набор инструкций, который у нас будет.
Дальше что мы можем сделать?
Дальше мы закидываем это все
в операцию simplify.
То есть, это упрощение дерева ER,
которое у нас было. Мы его
просматривали на одной из лекций.
И здесь как раз
есть некоторые опции,
которые мы можем с вами сделать. То есть, мы можем
переписать правила, мы можем проверить
строгость типов
и специализация
конструкторов. После этого
мы получаем с вами core-tidy,
то есть, очистку
названия наших перемен
явным образом.
А дальше
что мы можем с вами сделать?
Дальше у нас есть две развилки.
Либо мы делаем интерфейсный
объект, которым можно подключить извне,
либо можем впуститься дальше.
После этого
у нас
готовится наш язык
промежуточного представления в нормальную
форму. Называется aNormalForm.
И после этого
она трансформируется еще
в одну стадию, называется STG.
В чем ее суть?
Это вот просто уже
а-ля байт-машина.
А-ля байт-код-машина для
нашего этого.
Для кого?
Для компилятора.
И вот из нее мы уже делаем кодогенерацию.
Причем, давайте посмотрим, куда мы
именно делаем кодогенерацию.
А?
Да-да-да.
То есть либо...
Ну да, то есть в принципе оно
генерирует в одну из
стадий. То есть мы можем даже
сгенировать LVM-код.
Да.
Да, можем
сгенировать сечный код. То есть в принципе здесь есть
разные
различия.
Ну и в общем здесь вот эти
все стадии мы сейчас потихонечку и разберем.
В первую парадигму.
Так, понятно структура?
Вот, значит
что они говорят? Они говорят следующее,
что GHC
написали свои собственные инструменты.
Alex и Happy.
Которые аналог Lexa и Yak.
Давайте попробуем посмотреть.
А?
Так, где оно?
GHC
это интерфейс.
Интересно, сколько?
85% на Хаскеле написано.
Так.
Driver, GHC.
Нет, это C++.
Компилер его.
Вот он.
То есть вот они у нас в стадии.
Здесь они как раз все есть.
Так, а где тут
Lexer?
Парсер есть.
Вот у нас парсер и вот он Lexer.
Вот он язык
Lexera.
На
Lexer.x
Здесь
как раз можно увидеть
символы, которые у нас есть.
То есть variable ID и так далее.
То есть в принципе
здесь как раз можно увидеть
разные
комментарии, способы парсинга
комментариев. А дальше мы можем
делать это, вывод некоторых
символов. Вот это называется
как называли? Alex.
Теперь давайте парсер посмотрим.
Где у нас парсер?
Я же не парсер.
Неужели они его переименовали?
Это header.
В общем здесь у нас прямо генируется
код, который можно
посмотреть и пощупать.
Вот он, header.
Lex.
А, вот он, это уже
чистые символы. То есть
что мы конкретно с вами делаем
в определенном случае?
Вот, то есть это
как раз
так это рано.
То есть мы получаем этот перемен.
Дальше про ренейминг.
Это процесс переменования всех
инотификаторов в исходном коде
Хаскеля.
И теперь
тут суть в том, что
система Хаскеля
устроена так, чтобы мы могли
перейкспортировать идентифайер.
И дальше здесь указано следующее,
что если
можно большим количеством
образом переаккомпилировать наш
перезапускать наш код. Дальше здесь
описано каким образом происходит
type checking. И последнее, что здесь
приходит, это как раз
то каким образом устроен
язык core.
После этого, значит, мы генерируем
весь язык в STG.
И у нас тут есть три механизма.
И вот тут как раз
есть минимальный язык,
в котором нам нужно
с вами разобраться.
То есть
вот по факту это основной синтакс из того,
что поддерживает core. То есть у нас есть
переменные, у нас есть
data конструкторы, у нас есть литералы,
у нас с вами есть лямбда функции,
которая абстрагирует
либо тип, либо переменную.
И есть биндинги.
Здесь, наверное, сложно это читать,
потому что
тут детали есть. Поэтому я подготовил
еще одну вещь.
Так, это не то.
А, вот она. Это значит
understanding Haskell core features.
То есть как оно у нас работает.
То есть это именно
то, как работает
Haskell core. Итак, значит,
все, что есть в Haskell
это на самом деле
синтактический сахар. То есть
смотрите.
Ну, да.
Давайте.
Ну, не, ну не совсем.
Да. Все, что сложнее, чем лямбда.
Давайте прочитаем
вот этот вот код.
Значит, у нас есть какая-то функция product,
которая принимает список.
A плюс B и
C плюс D. Значит, она
использует несколько фичей. Первое
это листы тиралы.
То есть как у нас списки организовываются.
А дальше
у нас с вами есть
function application. То есть мы применяем функцию.
Итак, давайте прочитаем,
что же здесь происходит.
Что же это за функция product такая?
То есть это
то же самое, что и здесь.
Значит, здесь у нас идет
оператор application. То есть у нас есть
функция plus.
Оператор
в двоеточии
он занимает письменство
в клее в этом списке и делеген.
Да, да, да.
То есть у нас получается
мы учисляем A плюс B, после этого
используем двоеточие, потом используем
C плюс D, потом...
Да, да, да.
Ну, и этот код сложно читать.
Это был уже чистый функциональный парадигм.
То есть мы берем пустой список,
применяем оператор конкатинации,
прибавления, и дальше
мы получаем
результат.
И, собственно, здесь...
Ну, да, да, да.
То есть как же удобно это все.
И, собственно,
здесь первый шаг — это лексический анализ.
Я думаю, что
здесь мы останавливаться не будем.
Здесь важно просто,
поскольку у нас все является...
Единственный момент, что поскольку у нас
все является синтетическим фасахером,
то нам нужно будет найти в других модулях
реализация этих функций.
Надо проверить, что у нас есть
те или иные контексты.
Более того, мы должны уметь
распарсить эту структуру.
То есть вот эта структура — это у нас
Operation Application, что мы применяем операцию.
То есть нам нужно переставить наш аргумент.
Дальше мы получаем, собственно,
синтетический анализ.
У нас получается синтоксическое дерево.
После этого мы
делаем type checking,
который делает синтокс.
И дальше у нас идет
de-sugaring либо в core,
либо в stg, либо в c-.
Итак, значит,
что у нас есть в коре?
Давайте разбираться.
Значит, у нас в коре есть переменные.
У нас есть литералы.
У нас, на самом деле,
не поверите...
Дальше у нас есть лямда.
Это лямда-функция,
которая принимает аргументы.
В общем, здесь огромное
количество паттернов.
То есть вот они.
У нас есть как раз паттерначик,
который нам надо как раз это все
переобразовать.
А теперь смотрите, что у нас
в коре есть.
Вот все, что у нас есть в коре.
То есть у нас есть
variable-identity, есть lit-literal,
есть application, есть
лямда,
variable-expression, есть bind,
привязать примерно значение.
Смотрите, if-of нет,
то есть оператора verse здесь нет, есть оператор
case, который принимает
набор альтернатив.
И есть
krc.
Причем, смотрите,
здесь описаны прямо данные.
У нас получается есть let-bind-expression,
а вот она bind.
То есть каким он образом работает.
Мы привязываем
наш значение. То есть у нас с вами
по факту есть функции
приложений.
У нас есть лямды.
У нас есть лед-биндинги.
То есть они у нас остаются.
И есть у нас
coefficients.
То есть у нас давайте
чтобы вы понимали,
что такое coefficients.
Итак, читаем документацию.
Что оно
делает?
А,
это pattern-munching у нас.
То есть,
которое позволяет
копировать типа.
Вот, то есть это
именно привязка
переменная к значению.
Вот, то есть у нас есть какие-то
простые именно типа.
И давайте сейчас как раз разберем,
как работают эти
дегринги, например.
Итак, значит, если у нас есть инфиксные операторы,
то они кастуются вот таким образом.
То есть у нас идет трансформация
наших Haskell-Core в операцию
вот такую.
И значит,
здесь у нас происходит следующее,
что это базовая трансляция,
а вот здесь вот у нас
давайте посмотрим, что происходит.
Почему наш код должен быть
именно вот таким?
Типа вот вверх вот здесь.
Да.
Что это означает?
У нас, значит, получается оператор
2i,
который принимает функцию bool
и который
возвращает из bools bool.
То есть мы можем сделать полную спецификацию.
Дальше он принимает переменную
a типа bool и переменную b
типа bool. Ну, точнее не переменную,
как называется,
немутируемый объект типа bool.
Вот.
И теперь давайте посмотрим, каким образом
у нас пишется функция. То есть у нас,
когда мы говорим, что у нас есть функция,
то она у нас кастуется вот таким
образом. То есть f это лямбда функция,
slash это лямбда,
которая принимает x
в двоеточие, возвращает x в двоеточие.
Если нам нужно будет с вами
сохранить какие-то аргументы,
то это производится вот таким образом.
То есть мы берем x и y и говорим,
что это нот x или y.
То есть у нас тут как раз
биндинг аргументов.
С левой стороны направо.
Вот. Если у нас это лямбда функция,
то мы таким же
образом это корректируем.
Вот. Ну и, собственно, если мы с вами
пытаемся использовать многофункцию
в переменную, то мы должны идти
в концепцию каринга.
Напоминаю, что такое каринг. Это когда мы
берем и переносим один аргумент
в отдельную функцию. То есть у нас
когда мы подставляем определенное значение
x, то у нас получается функция,
которая идет из y и возвращает
z. То есть это вот специальный
оператор. Даже есть в функциональных
языках программирования.
То есть карри берет нашу функцию
из x и y в z
и перевращает его функцию, которая
принимает x и дальше
принимает x и возвращает функцию
из y в z. И в этом самом мы можем
вычислять наш результат последовательно.
То есть сначала
получить значение, а потом только посчитать результат
по требованию.
Дальше, значит, паттерн
bindings здесь
делается следующее, что у нас
с вами в коре
получается следующая функция. У нас, допустим,
есть a integer, b bool,
а дальше
делается привязка аргументов.
Собственно, у нас возникает
функция запятая,
которая вычленяет
по факту это оператор
проекции
чистого вида. То есть у нас есть x и y,
мы возвращаем x.
То есть, грубо говоря, альтернативный
вариант.
А потом
как бы
вы меняете
периодическую визу,
то у вас для меня тоже будет
определенное предназначение в форме.
Ну да, вот лучше.
Хорошо у вас
разначение, которое
меняет определенное предназначение.
Ну да.
Вот. Собственно,
оператор значения вот такой.
Значит, и
мы делаем именно проекцию.
Если у нас оператор
однобуквенный, то мы тоже
его преобразуем вот такой вид. То есть
говорим, что
примени наш оператор
или к аргументам a, b.
Tuple
Здесь у нас используется
несколько функций.
И
multi-argument matching.
Здесь делается
следующее. Мы говорим, что
по факту мы делаем
с вами таблицу истинности.
То есть они как раз,
когда мы устанавливаем какие-то значения,
они партятся в дерево свич-кейс.
Вот. Если нам нужно
закопаться
в кейс-экспрешена,
то тоже мы это можем
сделать.
То есть l.
Насинг оператор есть.
Дальше.
Значит
кейс
тоже есть, и в the Nels
конвертируется, кстати.
Так, вопрос
к вам.
Есть ли мысли,
почему core конвертирует вот так?
Нет, нет, нет.
Какой порядок стоит?
Нет, потому что
у них
кейс же у нас
не работает.
А кейс
не работает.
А кейс не работает.
А кейс же у нас
работает как он
если
на самом деле функция true
это функция возвращающей первые аргументы,
а функция false — это так.
Поэтому на самом деле
на самом деле
кейс — это применение
Google Arc в двух аргументах.
Ну, это да.
Скорее всего.
Не, я спрашиваю, почему false впереди true?
Ну да.
Дальше.
Оператор sequential.
Собственно,
который у нас есть, он делает следующее.
Он берет и преобразует наши
поля. То есть sequential ab,
case a of.
Любой аргумент мы получаем, возвращаем b.
Вот такая функция.
То есть она добавляет наши аргументы.
Вот.
То есть если у нас есть f и g,
это case bula,
то дальше мы его дописываем.
Дальше, значит, полиморфизум.
Что это делает?
Вот для всех a
z и x.
В общем, тоже видно конвертацию.
То есть что у нас принимается переменная
а определенного типа.
Дальше мы подставляем значение x
типа a.
И возвращаем этот x.
Собственно, здесь тоже у нас
явно представляют стипы,
если мы захотим.
Дальше у нас
есть
функция длина списка.
Собственно, как она
конвертируется.
Следующая.
То есть у нас
вызываем аргумент.
То есть что у нас есть a и xs.
Мы принимаем
аргумент a и xs и мы возвращаем
длину этого списка.
Дальше, значит, что здесь
интересного есть?
Оператор плюс.
Тут тоже ничего интересного.
Дунотация.
Это как раз, так сказать,
не функцион... Это какой?
Это у нас не функциональный стиль.
То есть можно перейти в не функциональный стиль.
А написать что-то
в императивном.
Конечно, это не рекомендуется.
Но что мы делаем?
Мы как раз это переписываем
в стиле Monad.
То есть как раз переменные привязаны...
Это один из немногих способов,
как мы переменные можем присвоить определенное значение.
То есть как бы мы говорим, что у нас функция Act.
То есть дальше
мы принимаем через этот аргумент
запись в аргумент x.
Потом следующую принимаем
аргумент Act, который
вызывает эти значения
к переменной y.
И только после этого возвращаем
x и y.
Если мы захотим с вами
вызвать вот эту функцию,
то
она вот таким страшным образом выглядит.
То есть видно, что нам приходится переписывать
наши функциональные языки.
И последнее это
Core,
не presented.
Это Cartesian и Cast.
Здесь тоже у нас получается
функции типов,
которые у нас есть.
И получается следующее,
что у нас тут делается.
ID мы объявляем A,
A или B
являются тем же самым типом.
И дальше мы говорим следующее,
что если у нас есть
переменная A определенного типа,
переменная B определенного типа,
и мы по факту говорим,
вот этот оператор %%A,
мы говорим, что если A,
присваиваем значение,
что у нас второй перемен тоже есть.
То есть видно, что здесь
есть разные способы,
как это сделать.
А вот она, кстати,
типичная
каерция,
которая у нас существует.
В принципе, вот это то, что у нас
с вами
может поддерживаться в Haskell.
Это у нас как раз был
Core механизм.
Я думаю, при желании можно будет
транслировать это все в кордере.
То есть у нас язык уже резко сокращается.
Но все равно этот стиль
пока никакой.
Можно ли сразу из него
транслировать в C?
Из вот этих вот всяких вещей.
Не очень. Поэтому нам нужен еще
один способ трансформации.
Это как раз STG.
Здесь это примеры, презентация.
Значит, смотрите, каким образом
выглядит STG.
Я тоже нашел презентацию.
Я потом думаю, можно будет прикрепить
все это дело.
Язык STG. Давайте познакомимся с ним.
Вот с этим уже можно работать.
То есть у нас с вами
есть некоторый набор
переменных x, y, f, g.
Дальше у нас есть конструкторы.
Есть литералы.
У нас целые или действительные числа.
У нас есть атомы.
То есть это аргумент.
Аргументность.
И у нас есть арность нашей функции,
которую мы с вами можем переопределить.
То есть эта арность неизвестна,
эта арность известна.
Дальше у нас выражение может быть базовым.
Это атомная переменная.
Дальше это может быть вузов функции.
Fкатая.
Получается,
арность нашей функции,
она принимает n аргументов.
По действию должно быть fкатой.
Либо мы с вами можем
вызвать примитивную функцию,
если нам нужно.
Дальше, смотрите, здесь есть оператор let,
который позволяет
выделить нам объект
в куче.
Optinye.
То есть записать.
И у нас есть как раз case.
То есть у нас есть case,
которое осуществляет набор альтернативных вариантов.
Какие у нас альтернативные
могут быть?
Либо у нас это pattern matching,
сопоставление с образцом,
либо это альтернативный по умолчанию.
То есть наша цель научиться в первую очередь
конвертировать кейсы.
Если мы научимся конвертировать кейсы,
то будет нам счастье.
И смотрите, дальше что у нас есть?
Мы вызываем функцию арности n.
То есть объект это у нас либо fun,
либо function, который мы лоцируем на куче.
Таким образом, как у нас есть.
Дальше у нас есть par, partial.
То есть частичное применение
функции к аргументам.
И есть полное применение конструктора.
То есть мы создаем с вами объект
нашей функции.
И смотрите, здесь есть специальное это.
Специальные аргументы,
которых изначально не было.
То есть мы пока что в языке корни
каким образом не говорили про отложенные вычисления.
Собственно, чтобы явно сказать,
что у нас отложенное вычисление,
есть оператор Sang.
Это специальная штука врантами,
которая делает ожидание.
Вот.
Да.
Ну и собственно, смотрите, как это выглядит
в STG.
То есть у нас явно указывается
функция с набором аргументов.
Почему? Потому что нам нужно
какие-то параметры
в стг.
То есть у нас явно указывается
функция с набором аргументов.
Почему? Потому что нам нужно каким-то образом
скастовать будет ее
и явно выселить тип.
То есть у нас есть как раз функция фолдинга,
допустим, fx, xx, g,
то мы явно указываем, что
нам надо...
Как это называется?
AsyncEvade это называется.
То есть в современных
языках программирования
есть парадигма, что у нас должна
быть результат выполнения функции,
после этого, возможно, это будет в отдельном потоке,
после этого мы получаем результат.
Вот, значит,
теперь, значит,
здесь есть некоторые ограничения.
Заключается в следующем, что
объекты у нас в куче создаются
только в led-ворожениях.
То есть больше мы нигде не создаем
афемерных объектов, и
выражение приводится к нормальной форме
только в кейс-ворожениях.
Вот, значит, смотрите,
есть вот такой вот пример, давайте поймем,
что он делает.
А?
Это вот чистый
этот...
элемент.
Это чисто функциональный язык.
Давайте поймем, что он делает.
В смысле...
Ну, некоторым математикам,
в кабачках, удобнее...
Да.
...удобнее выражать
свои идеи на
эти кейс-ворожениях.
Это раз, но, во-вторых, это стриминг объекта.
Стриминг парадигма,
она как раз позволяет
сделать важное
свойство ресайленси.
То есть у нас по факту объекты всегда
эмутируемые.
И мы по факту можем сделать один поток, потом данные
перегонять в другой поток, в третий поток,
в четвертый поток и так далее. То есть такие
штуки проще конвейерить.
Да, кстати...
Да, кстати...
Да, кстати, я видел,
я пока готовился к материалам, я видел
транслятор из
GHC в кок.
Это как раз язык верификаций.
Прямо в GitHub репозитории
какую-то нашел.
Программа, по-моему, что-то такое.
Да, по-моему,
я сейчас могу ошибаться,
Евгений Дашков ведет.
Даже курс по работе
с этим языком.
Можно найти в лектории.
Да, то есть можно походить.
То есть смотрите, что у нас получается.
У нас с вами создается
Fold Natural, S0.
Вот, и здесь как раз
мы вызываем вот эту вещь.
То есть видите,
что такое у нас кон, давайте вспомним.
Полное применение конструктора.
То есть мы вызываем конструктор нашего
объекта, и дальше
мы это... Смотрите,
давайте прочитаем. Data not
это кто у нас с вами?
Это либо 0,
либо...
Либо...
Следующий.
Not это натуральный число.
Да, not это натуральный число.
То есть это либо 0, либо следующее за ним.
Дальше что у нас говорится?
Объявляется, что 0 это 0.
1 это...
Success от 0.
Да, success not.
И дальше мы делаем следующее.
У нас Fold not делает вот такое вот
Fold natural.
Да, то есть что это у нас такое?
Это у нас функция,
которая принимает
a функцию,
потом из a делает
a, потом из него...
Принимает a, принимает функцию
из a в a, принимает not,
надаёт a. Да.
А, это типа...
Проходится с successor?
Да, то есть у нас получается
z as 0
выдаёт 0,
то есть если мы принимаем
0, а если мы принимаем
successor and,
то что мы делаем?
Применяем себя к Foldo.
Да, применяем себя к Foldo.
Вот.
То есть вот такая вот нотация.
Ну и собственно, at a это что у нас получается?
А, это прикрутить
себя для
препроцессора.
То есть у нас
at принимает два аргумента
сам себя.
А, нет, он принимает...
Да, это
ab, ab пропущено.
Это мы
с себя, да,
перекинуть с successor, с себя
на аргумент.
То есть это получается сложение.
Да.
И есть mall.
Это
сделать
от себя.
Да, от себя
в какое-то количество раз.
Так, теперь смотрите, как это работает.
Значит, вот это переписывается вот таким образом.
То есть мы создаём конструктор объектов.
И дальше
мы говорим следующее, что
мы создаём следующий объект в
sNext. Вот такой код.
Собственно. И дальше тут
наверное мы уже
посмотрим это в другой раз.
Потому что здесь уже будет
некоторое веселье и посмотрим
на стратегию вычисления.
Вот этого всего добра.
Конечно, мозг оно сильно ломает.
А?
Более того, ещё сильнее
будет ломать мозг
логические языки
программирования.
Но есть этот быстрый мем, что
шаблоны
будут...
Ну, это...
Шаблон создавал человек, который
заранчен и там
вытекает.
Нет, скорее про лог.
Про лог это логический язык
программирования.
Это не функциональный язык.
Это функциональный язык?
По поводу программирования
да, разумеется, что
программирование шаблона
на неровной местной
тексте
и получаются результаты
поставить функции, да, значительно
приятные.
Но, да, вот все другие
идеи
это, значит, по программовку
линзиной и прочих
поворачивающих.
Да.
Всё.
Ладно, на этом мы остановимся.
Следующий раз продолжим.
Наверное, какие-нибудь вопросы
поотвечаем.
