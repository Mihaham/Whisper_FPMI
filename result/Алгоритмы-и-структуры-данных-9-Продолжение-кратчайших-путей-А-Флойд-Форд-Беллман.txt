Продолжаем сегодня говорить про кратчайшие пути.
Начнем с алгоритма звездочка.
Это алгоритм, который решает задачу такую же, как Дейкстра,
а именно находит кратчайший путь от одной вершины до
другой.
Более точно, Дейкстра у нас могла находить от одной
вершины до всех, а мы будем решать задачу именно, что
от S до T находит расстояние от S до T, т.е. фиксированы
стартовая конечная вершина, нам нужно найти минимальное
расстояние.
И здесь будет работать следующая идея.
Смотрите, раньше в алгоритме Дейкстра мы действовали
примерно так.
У нас была S, мы для каждой вершины находили расстояние
до нее, в каком-то массиве DIST, для каждой вершинки
мы сохраняли текущее найденное до нее расстояние, минимальную
длину пути, которую мы уже нашли.
Там их постепенно обновляли, раскрывали вершину с минимальным
DIST, которая еще не обработана, рассматривали все рёбра
с нее, обновляли DIST вот здесь, и потом брали опять вершину
с минимальным DIST, те, которые еще не обработаны.
Логично в каком-то смысле DIST еще вклеить оценку остаточной
длины пути.
Сейчас мы рассматриваем только путь от S до текущей
вершинки, до вершинки V.
А давайте еще каким-то образом научимся учитывать оставшую
длину пути от V до T.
Вот как это будет реализовано.
Для каждой вершины V у нас будет две функции.
Функция G это вот та самая оценка на минимальное расстояние.
Ну, давайте так напишу, текущая найденная оценка
на DIST SV.
Так же как в DX, что у нас не сразу появляется правильное
расстояние как же от V, а вот когда мы до нее дойдем,
когда мы из кучи извлечем, тогда это будет правильное
расстояние.
То есть, возможно, вот эта величина, мы ее изначально
чему-то положили равной, затем она как-то убывает-убывает,
и когда мы ее достаем из кучи, это уже правильный
ответ.
Ну, например, если у меня есть вот эта S, вот эта V,
я нашел там путь длины 10, положил сюда G равно 10, ну
или в этом вот понимании, да, 10 от V равно 10.
Потом нашел путь покороче, суммарной длины 9, обновил
ее, ну и так далее.
Много-много раз обновляю этот путь.
И когда вот эта вершинка V извлечется из очереди
в алгоритме Dijkstra, мы будем считать, что то значение
Dist, которое там лежит, это и есть правильное значение.
Мы доказывали в прошлый раз, что это будет правильный
ответ.
Вот так вот, вот эта G от V, она как-то убывает, да,
но вот пусть G это текущее найденное расстояние.
Вот, и будет вторая функция H от V.
Это оценка на, наоборот, остаточную часть пути от
V до T, Dist Vt.
Понятно, что эту оценку мы не можем взять никак
исходя как бы из, из графа, да, потому что чтобы это
посчитать, нам нужно как бы ну там от V до T рассматривать
как будто бы вот этот вот, ну не знаю, остаток пути
как будто обратно до Dijkstra пускать.
Мы такого делать не будем.
У нас эта H будет браться, ну вот именно что какая-то
оценка.
Например, если мы знаем, что этот граф лежит на плоскости,
то минимальное расстояние от V до T оно явно не меньше
чем ефкрида расстояния между этими точками.
Да, то есть если мы считаем, что наш граф планарный,
в смысле плоский, да, расположен на плоскости, и там есть
какие-то ребра по которым можем ходить, то понятное
дело, что минимальная длина пути от V до T она не меньше
чем ну просто длина этого отрезка.
Поэтому в качестве H от V мы, например, будем брать просто
ефкрида расстояния между ними.
Если, повторюсь, граф у нас уложен на плоскости.
То есть это то же самое, если у нас граф там какой-то
специфический, тогда в качестве H от V можем брать нам какие-то
другие функции.
Вот чуть позже рассмотрим пример.
Окей, то есть J это то, что находится в нашем алгоритме,
а H это какая-то оценка, ну по сути это просто функция
от V до T типа расстояния ефкрида между ними, без учета структуры
графа.
Вот, и тогда мы определяем f как функцию, J и H, и по сути
алгоритм-озвездочка это просто dx на f, грубо говоря.
А звездочка это алгоритм dx на значениях f.
Ну давайте напишем код, как это выглядит.
Мне также нужна очередь, ну в смысле куча, из которой
я буду доставать значения, только теперь я буду доставать
минимальное значение f, вот что значит dx по значениям
f.
Это значит, что минимум у меня берется из кучи не
по значениям g, а по значениям f, то есть в вершинке будут
сравниваться внутри кучи по порядке возрастания
f, в корне будет минимальное значение f.
Ну так вот, давайте мы будем считать, что у меня есть
там вектор значений g, ну давайте пусть будет double,
если мы говорим, что точки на плоскости лежат, то
наверное расстояние у нас вещественное, а не целое.
Значит вектор double g, h это какая-то функция, то есть
мы не храним значение h, мы можем его вычислить,
если нам нужна для какой-то вершинки v почитать расстояние
от v до t, ну оценку на расстояние от v до t, тогда мы ее просто
там по какой-нибудь формуле считаем, то есть явно мы
ее не храним.
Ну то же самое нужен вектор double f, нужна куча, давайте
я напишу вот так, priority q, вот, есть в плюсах priority
q, но там тяжеловато будет с декоризки, там тяжело
показывать, какой элемент нужно уменьшить, ну в общем
давайте здесь считаем, что тут написана наша куча,
в которой мы можем делать все наши операции, там
insert, extract, min, декоризки по указателю, то есть вот
эта куча, которую мы реализовали.
И здесь будут лежать номера вершин, которые упорядочены
по f, да, значит куча номеров вершин, куча номеров вершин,
упорядоченных по f, по f.
Ну и дальше стандартная, стандартный кусок sd extra,
что мы сначала вставляем в нашу очередь старту вершинку,
так, пардон.
Сначала говорим, что g от s это 0, f от s, ну это соответственно
h от s, да, потому что g от s понятно 0, расстояние
из этого 0, дальше f от s это сумма g плюс h, но если
g это 0, то тогда остается просто h, h от s.
Ну и в очередь как раз ее добавляем, q insert s.
Дальше я напишу следующее wild true.
Значит извлекаем из очереди вершину с минимальным f.
Значит я напишу v равно q.extract min.
Достали и удалили из очереди вершинку с минимальным значением
f, которая там есть, и пытаемся ее раскрыть.
Дальше наша процедура, что если есть v, мы пытаемся
ее раскрыть, то есть обновляем значение g у вот этих вот,
у концов этих ребер.
Значит делаем цикл по исходящим ребрам, по всем
ребрам лежащим, так, ну тут g уже занят, давайте я
назову graph, graph от v, ну это так же как раньше, то
что было g от v, это список ребер исходящих из v.
Ну и нам нужно обновить значение функции g для
вот этого, для конца вот этих ребер.
Так, сейчас, секунду, подумаю как это написать.
Это я посчитал, какая будет длина пути, что мы сначала
доходим до v, потом добавляем это ребро, то есть добавляем
e.cost, потом если значение g, которое лежало в конце
вот эта вот e.tu, оно больше, чем x, тогда нужно его обновить и, соответственно,
сделать изменения в очереди. Что g вот e.tu равно x,
соответственно, вот здесь должны быть строчки типа там decrease key или insert.
Если вершинка e.tu есть в очереди, то нам нужно просто
сделать decrease key, потому что у нее было вот такое значение g и, соответственно,
такое значение f. Если ее не было, то нам нужно ее туда вставить. Давайте я
напишу, что f от e.tu это g от e.tu плюс h от e.tu. Не забываем, что нам
нужно добавлять вот эту вот функцию h в конце. Ну и здесь, соответственно, я
пишу, что если e.tu находится в очереди q, в смысле, в куче находится в q, то просто
надо сделать decrease key. Иначе, если там нет, надо сделать insert.
Так, ну вроде всего. Вот и вот здесь вот нужно еще вставить, что если мы из очереди
извлекаем вершинку t, до которой мы, собственно, пытались найти расстояние,
то мы сразу из этого цикла завершаемся и говорим, что мы нашли ответ. Вот здесь
вот надо вставить, что если v это t, тогда break. Вот такой алгоритм. Пока, возможно,
какая-то магия, но сейчас поясним, как это работает и когда это корректно работает.
Идея очень простая. Вместо того, чтобы насчитывать только оценку от s до v, мы
еще добавляем какую-то вот эту вспомогательную функцию h, которая называется
эвристика. Эвристика, то есть оценка на расстояние от, где оно, вот она, h, это оценка
на расстояние от этой вершинки до конца, до t. Ну и потом, собственно, просто dx по значениям
вот этого f, что это значение g, как расстояние от s до этой вершинки, плюс оценка на
расстояние от этой вершинки до конца. А дальше просто обычная dx до того момента,
пока мы не дойдем, пока мы не извлечем из очереди, из кучи, в смысле, вершину
равную t, когда вершина равна t будет иметь минимальное значение f. Вот такой алгоритм.
Значит, почему это хоть сколько-то адекватно? Определение. Функция h,
которую мы будем называть эвристикой, называется допустимой, если h от v не
превосходит настоящего расстояния от v до t. Если для любого v h от v не больше,
чем настоящая dist vt. То есть h допустима, если это оценка снизу на истинное расстояние.
Оценка снизу. Ну, здесь я неявно предполагаю еще, что h положительно. Давайте я явно здесь
пропишу. Но мы рассматриваем, в смысле не отрицательно, мы рассматриваем только
не отрицательную эвристику, потому что, ну, логический смысл, что это как бы оценка длины
пути от v до конца, и было бы странно, если бы длина vt была отрицательной. Мы пока живем в
парадигме, что отрицательных ребер нет, соответственно, путь не может иметь отрицательную длину.
Вот это допустимая эвристика. Дальше. Эвристика h называется монотонной. Эвристика h называется
монотонной. Если для каждого ребра выполняется неравенство треугольника. Значит, если для
любого ребра uv выполнена неравенство треугольника следующего вида, что h от u не больше, чем h от v,
плюс e точка кост. Очень логичное предположение, если h это у нас оценка на расстояние от текущей
до конца, то уж наверное оценка длины пути отсюда до конца h от u не превосходит оценки
отсюда до конца h от v, плюс длина этого ребра. Понятно, что от u можно добраться до t, использовав это
ребро, а потом дойдя от v до t. Это условие того, что наша h адекватна, что она по крайней мере
учитывает все вот эти ребра и удовлетворяет неравенство треугольника.
Очень простое замечание, что монотонный является допустимой. Замечание, монотонная
евристика является допустимой. Доказывается очень просто, я не буду это формально прописывать,
значит понятно, что надо еще потребовать, здесь нужно еще дополнительно требовать,
потому что иначе это будет неверно. Извините, монотонный это когда выполняется треугольник для
всех ребер, а также h это 0, вот так. Эти два условия нам нужны. h это вершина до которой
аши дает расстояние, конечная вершина, что вот у меня есть s и t, мы хотим для каждой вершинки v
оценить вот эту длину пути, длина пути из v в t. Не могу пока, у нас будет зависеть
эта симплуатика от того какая у нас аш, поэтому пока что пока что не скажу, итак.
Почему? Нет вроде все, ну смотрите логика какая, что если мы пытаемся оценить длину пути от u до t,
то мы в частности можем пройти это ребро потом от v до t, но возможно как-то можно более оптимально.
Итак, вернусь к факту, почему монотонная допустимая. Ну h от t это 0, значит в вершинке t у меня
значение функции 0, дальше рассматриваем скажем все ребра ведущие в t, тогда мы понимаем, что значение
h вот в этих вершинках не больше чем длина этого ребра, но поэтому в частности значение h в них не
больше расстояния до t. То есть, грубо говоря, если я рассмотрю все кратчайшие пути, то значение
функции h здесь из монотонности будет не больше чем длина этого пути. Ну и так далее, что если я
рассмотрю произвольный кратчайший путь, то значение h здесь не большим суммой этих ребер,
а она равна как раз таки кратчайшему расстоянию, просто расстоянию от вершинка t. Поэтому монотонная
всегда допустима. Вот, и следующая теорема, которую мы не полностью докажем, утверждает следующее,
что, во-первых, если h это монотонная евристика, вот как раз переходим к асимптотике, то а звездочка
не хуже dx и всегда находит правильный ответ, то а звездочка всегда вернет правильный ответ,
при этом каждая вершина раскроется не больше одного раза. Каждая вершина раскроется не больше одного
раза. Ну, напоминаю, раскрытие это то, что делается у меня вот в этом цикле, что перебор всех ребер и
попытка релаксации, то есть обновления g для всех концов всех исходящих ребер, это раскрытие. Ну,
а если это верно, то это не хуже чем dx, потому что dx у нас как раз таки раскрывает все вершины
по разу и, собственно, в простой реализации за m log n находит кратчайшее расстояние до t.
Значит, это делает все то же самое, и раз оно раскрывает все вершины максимум по одному разу,
то это не хуже чем dx. Второе, если h допустимая, только допустимая, но не монотонная, то оказывается,
что а звездочка тоже всегда вернет правильный ответ, но, возможно, за гораздо большее время,
в худшем случае экспедициальное, то а звездочка всегда вернет правильный ответ,
но в худшем случае за экспедициальное время. Ну, то есть время больше любого
пленома, например, за два в степени n, грубо говоря. То есть это хорошо с точки зрения
получения ответа, но непрактично с точки зрения времени работы. Я еще поговорю про все это время
работы, на самом деле в этом нет ничего страшного, что в худшем случае экспонента на самом деле
часто там гораздо меньше, чем экспонента. Это я еще скажу. Ну и последнее, если h даже
недопустимая, то как бы уже ничего нельзя утверждать, что, во-первых, а звездочка может
работать долго, во-вторых, может вернуть неправильный ответ. Но давайте напишу так,
то если h какая-то адекватная отражает как-то условия нашей задачи, то, возможно,
она отработает быстро и вернет, ну, примерно правильное приближение. То есть вот здесь мы
отказываемся от точного ответа, а ответ может быть неверным. Но так неформально это будет
хорошее приближение к ответу. То а звездочка может вернуть хорошее приближение к ответу.
Хорошее приближение к ответу. Ну а в худшем случае, конечно, ответ неверный и при этом еще
и работает уже экспоненциально долго. Но в худшем случае неверный ответ плюс экспоненциальное
время работы. Вот теперь зачем это может быть нужно? Ну смотрите, первый случай самый-самый
случай, который мы делаем, а второй случай самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-самый-с
в каком-то смысле можно ожидать, что он быстрее найдет самый короткий путь, что и, грубо говоря, вот он понимает, что там какие-то
вершины лучше других за счет оценки, ну и поэтому их будет рассматривать в первую очередь. Это так совсем неформально. Во втором, здесь
может быть такое, что если у вас эвристика хоть и допустимая, хоть и не монотонная, то все равно
иногда бывает очень быстрое время работы. То есть вот здесь, но это как повезет, то насколько вам
получится угадать с эвристикой, что если она действительно вот прям очень хорошо отражает то, как у вас выглядит ваш граф,
если вы смогли как-то формулой задать оценку на расстояние, то, возможно, эта штука то есть написана в худшем
случае, на самом деле в лучшем случае может быть тоже там очень быстро, лучше, чем DX. Ну наконец последнее, если на h
нет никаких ограничений, то, ну то же самое, что если вам повезет, что если h какая-то такая крутая, хоть и не
удовлетворяет там каким-то свойствам, но очень адекватно отражает структуру вашего графа, то, возможно, опять-таки она работает
быстро, но при этом, возможно, чуть-чуть ошибается. Ну там не знаю, на 10% ошибется. Это, в принципе, хорошее
приближение к ответу. Вот, особенно во всяких задачах типа, если у вас есть много задач, не очень больших и при
этом вам не обязательно искать там точный ответ. Ну не знаю, вы пишете какую-нибудь игру, а звездочка обычно как раз в
разработке игр используется. У вас есть игра, вам нужно там одного юнита переправить в какую-то точку. Понятно, что на пути
могут быть препятствия, другие юниты, там какие-нибудь деревья. Вот, ну вы берете просто там а звездочку и, возможно,
на хоть не кратчайшее расстояние, ну а там расстояние на 10% больше оптимального. Ну ничего страшного, в принципе, от этого
никто, никто сильно грустеть не будет. Так, значит, мы давайте докажем первую часть, остальное мы не будем доказывать.
Чтобы это сделать, утверждение такое, если h монотонное, то во звездочке последовательность f от извлекаемых вершин не строго возрастает.
Последовательность, я напишу так, f от v1, f от v2 и так далее у извлекаемых вершин не убывает. То есть, есть неравенство, что вот это меньше
чем вот это, меньше чем вот это и так далее. Извлекаемые вершины это те, которые я достаю из кучи. Что сначала будет s, потом я ее достал из кучи, раскрыл, посчитал как-то f для всех остальных, потом это будет вершина с минимальным f лежащая в куче и так далее и так далее.
Так вот, утверждается, что последовательность, когда я извлекаю эти вершинки, у меня f точно не убывает. f новая вершинка по сравнению с f старой будет только больше либо равно.
Ну, доказательство очень простое. Как это работает? Давайте рассмотрим раскрытие вершинки v. Вот мы предположим, что мы ее извлекли, соответственно, здесь было f от v, мы ее раскрываем. То есть, рассмотрим все исходящие ребра.
Тогда, что происходит вот с этой, скажем, вершинкой tu? Ну, у нее значение либо остается таким, каким было, f от tu, либо не поменялось, могло не поменяться, если нам не выгодно это ребро использовать.
Либо оно могло стать равно, ну, давайте напишем, что это g от v, плюс e-кост, плюс h от tu.
Так что мы могли заиспользовать вот этот путь, который мы нашли, от s до v, прибавить это новое ребро и затем с помощью эвристики h оценить расстояние от tu до t.
Ну, если мы с вами сможем доказать, что это большее равно f от v, то мы, на самом деле, победим.
Потому что это будет означать, что если мы какую-то вершинку раскрываем, то все остальные значения, которые есть у нас в куче, они могут быть только большее равно, чем вот этот извлеченный минимум.
То есть, если было, наоборот, с другую сторону неравенства меньше, тогда, смотрите, мы извлекли какое-то значение, значение f, обновили и положили в кучу вершину с меньшим f.
Тогда как раз противоречит, что у меня в каком-то месте убывает последовательность извлекаемых вот этих f.
Иначе, если неравенство всегда вот такое, то, соответственно, когда мы извлекли вершину, положить мы в нее могли только вершины с большим значением, с большим либо равным.
Поэтому, когда мы их будем извлекать, конечно, будет такая цепочка неравенства.
Так, ну почему это верно? Здесь нужно просто написать неравенство треугольника для функции h, которая следует из определения монотонности.
Значит, давайте напишем такое f от v, это g от v плюс h от v.
Ну и h от v я оценю по определению монотонности через h от tu plus e-coast.
Потому что что такое h от v? Это оценка на расстояние от v до конца.
Понятно, что этот путь не больше, чем стоимость этого ребра плюс расстояние от tu до конца.
Ну, собственно, доказали требуемое неравенство, что g от v плюс h от v не больше, чем g от v плюс h от tu plus e-coast.
Вот оно в точности здесь написано.
Утверждение доказано.
Вопросы?
Так, что следующее?
Ну да, собственно, тогда утверждение...
Давайте, скажем, доказать стеорема пункт 1.
Доказать стеорема пункт 1.
Что озвучка корректно работает, что она не работает.
Мы знаем, что последовательность минимумов у нас не строго возрастает.
Это в частности означает, что нет смысла вершину раскрывать больше, чем один раз.
Потому что, представьте, какой нам может быть резон раскрывать какую-то вершину дважды.
То есть мы нашли до нее какой-то путь, раскрыли, обновили вот эти вот расстояния.
А потом еще нашли до нее другой какой-то путь, и опять ее раскрываем.
То есть она опять добавилась в очередь, мы ее опять извлекли, и, соответственно, опять раскрываем.
Но понятно, что это бессмысленно, если у меня последовательность f-ок возрастает.
То есть, смотрите, мы в какой-то момент f от v было у нас какое-то, мы ее извлекли.
Потом в какой-то другой момент, более поздний, мы опять вы извлекаем.
Но это осмысленно делать, только если f от v упало.
Если оно было таким же, то нет смысла ее заново рассматривать.
Поэтому давайте напишем вершина v.
Вершина v.
Вершина v.
Вершина v.
Давайте напишем.
Вершина v может быть извлечена дважды.
Дважды.
Только если f от v уменьшается в промежутке между извлечениями.
f от v уменьшилась.
Уменьшилась.
Между извлечениями.
Ну а такого не бывает, потому что мы доказали, что последовательность f,
которую мы извлекаем, только нестрого возрастает.
А если мы извлекли v, а потом она уменьшилась, то понятно, что нам нужно будет когда-то ее обработать.
Значит, получается, что наша последовательность, ну, неверно, что она не убывает.
Это значит, что в какой-то момент мы извлекли v, оно было вот такой, а потом в другой момент мы опять извлекли v, и оно упало.
Значит, противоречие с тем утверждением.
Противоречие с утверждением.
Это значит, что каждая вершина рассматривается один раз.
Первая часть выполнена. Точнее, вторая.
Что каждая вершина рассматривается максимум один раз.
Теперь почему вернется правильный ответ?
Почему вернем правильный ответ?
Ну, смотрите, мы видим, что...
Ну, во-первых, там, простой случай.
Если t недостижимо из s, то давайте считать, что такого не бывает.
Что можно просто исходно было запустить какой-нибудь bfs, проверить, достижимо ли t из s.
Считаем, что достижимо.
Значит, тогда наш алгоритм завершится только, когда извлечет t из кучи.
Алгоритм завершается, когда он извлекает t из кучи.
Там было условие, что если текущий вершин равно t, то break.
Ну пусть тогда это не верно.
То есть мы нашли какой-то путь от s до t.
Извлекли t из кучи.
То есть мы нашли путь, соответственно, нашли f от t.
Какое-то оно было минимально в куче, мы его извлекли и закончились.
И пусть это неправильный ответ.
Ну, тогда давайте виртуально представим, что мы продолжаем наш алгоритм,
до тех пор, пока очередь не опустеет.
И если мы вдруг не получаем текущий вершин,
то тогда, соответственно, f от t от нее должна была бы упасть.
И потом, когда я эту t опять извлекаю, то получается, что последний эффект у меня убывает.
Значит, идея такая.
Ну, во-первых, давайте заметим, что f от t это просто всегда g, вот t.
Потому что h от t это у нас всегда 0.
Так как h от t это 0.
Ну, то есть мы нашли текущий вершин.
То есть мы нашли текущий вершин.
Так как h от t это 0.
Поэтому, когда мы доходим до вершинки t, для нее f и g это одно и то же.
Потому что h 0 для конечной вершинки.
Итак, пусть алгоритм нашел неоптимальный путь какой-то длины f от t.
Вот он нашел какой-то такой путь.
Извлек t из очереди, из кучи и завершился.
И пусть это не оптимум.
Тогда давайте рассмотрим настоящий оптимум.
Вот пусть вот это то, что мы нашли в алгоритме, во звездочках.
А это настоящий оптимальный путь. Самый короткий.
То есть более короткий, чем то, что мы нашли.
Тогда давайте мы виртуально представим, что мы наш алгоритм продолжим запускать.
Ну, то есть продолжим реализовывать, пока очередь не опустеет.
Ну, тогда смотрите, понятное дело, что в какой-то момент у меня обработается вот эта вершина.
После нее обработается вот эта вершина и так далее, и так далее.
То есть на самом деле, если мы как бы позволим нашему алгоритму работать бесконечно долго,
пока очередь не опустеет, он, конечно, весь вот этот путь раскроет вот в таком порядке.
Что сначала раскроет эту вершину, потом эту, потом и так далее, потом вот эту.
Здесь легко видеть, что если здесь есть неравенство на h, а g...
Ну да, g равно, собственно, сумме вот этих ребер, то они именно в таком порядке будут рассматриваться.
Именно в порядке слева-направого в какой-то момент они рассмотрятся.
Ну, значит, если мы наш алгоритм позволим работать бесконечно долго,
он когда-то пересчитает f от t как какое-то меньшее число.
Значит, опять добавит его в очередь и потом извлечет f от t с меньшим значением.
Противоречие с тем, что мы не можем такого делать.
Значит, если это так, то давайте виртуально продолжим работу алгоритма,
пока очередь не опустеет, пока q не опустеет.
Значит, тогда он этот алгоритм найдет опыт, уменьшит f от t,
ну и соответственно потом ему придется извлечь t с уменьшимся значением,
что противоречит опять-таки утверждению.
Ну, опять противоречие, f у нас не может падать.
Тут немножко неформально, тут нужно аккуратнее объяснить,
почему мы когда-то оптимальный путь все-таки рассмотрим.
Тут просто можете с вами подумать, я не буду этого требовать.
Но те, кто не умеет, они не умеют, они не умеют, они не умеют, они не умеют, они не умеют.
Ну, тут просто можете с вами подумать, я не буду этого требовать.
Ну, понятно, что s рассмотрится в первую очередь.
Затем в какой-то момент эта вершина тоже рассмотрится, причем до нее найдено крышешее расстояние,
потому что мы рассмотрели это ребро.
Дальше эта вершина тоже рассмотрится, потому что до нее, до вот это найдено крышешее расстояние,
и здесь это ребро, ну, в общем, опять по неразрешению треугольника из монотонности,
вот эта штука будет больше значима вот эта.
Эта штука, как бы, либо рассмотрится раньше, либо это рассмотрится раньше,
но тогда до нее f ровно такое, как нужно.
Поэтому этот путь мы, ну, не то что обязательно его слева направо пройдем,
то есть мы, возможно, нашли там, ну, то есть какой-то такой путь,
если он такой же длинный, то, возможно, мы рассмотрели не вот этот путь, а вот этот.
Но главное, что мы все-таки, все равно, как бы, эту информацию в этом пути передадим в t,
и тем самым f от t уменьшится.
Так, ну, вроде с корректностью все. Вопросы?
А у меня вопрос, вы предлагали сделать пул,
и чего было так просто, на что находится эта вершина?
Да, ну, это можно просто булевский флаг хранить.
Давайте для каждой вершины хранить булевский флаг, есть она в очереди или нет.
Когда мы ее извлекаем, мы этот флаг делаем, что на ней лежит,
когда добавляем, делаем, что на ней лежит.
Так, ну, значит, из этого всего следует, что асимптотика точно сверху оценивается m-луганом.
Так же, как в дэйкстре, да, что мы поняли, что это не хуже, чем дэйкстры,
а дэйкстры работают вот на куче, ровно с такой асимптотикой.
Ну, и еще раз повторюсь, да, что очень часто мы, на самом деле,
делаем флаг хранить в тексте, в тексте, в тексте, в тексте, в тексте, в тексте, в тексте, в тексте.
Ну, и еще раз повторюсь, да, что очень часто мы, на самом деле,
будем работать сильно лучше, чем вот эта самая наша асимптотика.
Например, представьте себе такую картинку.
Вот есть у вас та же самая игра, есть у вас юнит, который стоит здесь и прячется попасть сюда.
При этом у вас нет никаких ограничений на этом пути.
То есть, грубо говоря, есть вот такой путь.
Тогда что делает дэйкстра?
Ну, давайте, если граф будет как бы невзвешеный, то дэйкстра, по сути, работает как бы ф-эшт.
Сначала мы рассмотрим все вершины на расстоянии 0, потом все вершины на расстоянии 1, на расстоянии 2 и так далее.
То есть, мы будем вот такими вот расширяющимися квадратиками двигаться.
Это дэйкстра или бфс.
А звездочка...
А давайте напишу, что здесь бфс или дэйкстра.
Как будет действовать а звездочка?
Если, например, у меня метрика...
Здесь у меня, видимо, Манхэттенская, что у меня можно ходить в четырех направлениях за один шаг, за одну единицу стоимости.
Тогда, если мы введем, скажем, в качестве эвристики Манхэттенское расстояние...
То есть, сумму модулей разности по х и по у,
то тогда он просто сразу же найдет вот такой ответ и не будет даже от него отступать.
Это мы сейчас покажем.
Если h от v равно dist от v до t, то он на самом деле, по сути, просто находит сразу кратчайший путь,
без всяких ответвлений, без вот этих вот обработки лишних вершин.
Тут не совсем такая картинка будет, но по сути, по крайней мере, мы не будем рассматривать вот эти вот вершины, которые слева снизу находятся.
Их вообще наша а звездочка даже не увидит.
Это неосимпатическая оптимизация. То есть, тут нельзя гарантированно писать что-то лучшее, чем m log n.
Но очень часто, именно там на практике с точки зрения времени работы, это работает сильно лучше, чем всякие вот эти детерминированные, гарантированные алгоритмы.
Так, ну и примеры.
Того, какого h можно брать.
Примеры.
Значит, первое. Если мы скажем, что h от v это тождественный ноль, то а звездочка тождественная совпадает с dx.
А звездочка вырождается в алгоритм dx.
Ну, потому что в этом случае f это то же самое, что g.
А если dx у нас работала как куча на g, то есть каждый раз извлекали минимальное значение g, а теперь а звездочка извлекает минимальное значение f.
Но это одно и то же просто. Поэтому по этому алгоритму идет ровно то же самое.
Поэтому как минимум то, что мы написали, не хуже даже в самом тупом случае, когда эвристика у нас нулевая.
Второй случай, наоборот противоположный, идеальный.
Если нам получилось угадать такую эвристику, которая для каждой вершины выдает настоящие расстояния,
то, ну я вот так напишу тоже неформально, что а звездочка рассмотрит почти только вершины на кратчайшем пути из s в t.
Почему это верно? Смотрите.
Есть s, есть t.
Я знаю, что у нас есть обороты, которые не могут быть на кратчайшем пути.
Но мы не можем их перенести на кратчайшем пути.
Если мы не будем перенести на кратчайшем пути, то мы не сможем перенести на кратчайшем пути.
Почему это верно? Смотрите, есть s, есть t. Я знаю, что h от v это всегда vt, поэтому в частности вот здесь в самом начале, когда я считаю f от s, у меня f будет равно настоящему расстоянию от s до t.
Я напоминаю, в самом начале f от s это просто h от s. В самом начале f от s это просто h от s, потому что g0 есть путь длины 0 из s в s. Соответственно, это просто distance, dist от s до t.
То есть мы в самом начале положим в нашу кучу вершину с f равным dist. Но мы его пока не знаем, грубо говоря, или не знаем путь.
Дальше мы ее раскрываем. Смотрите, что происходит на, скажем, кратчайшем пути. На кратчайшем пути у меня g вырастает на вес этого ребра, а h, наоборот, убывает на вес этого ребра.
Поэтому f не меняется. Еще раз, если я рассматриваю ребро кратчайшего пути от s до t, то у меня g увеличится на вес этого ребра, а h уменьшится, потому что g, собственно, я прибавляю, а из h у меня distance, наоборот, уменьшился на вес этого ребра, потому что осталось идти меньше.
Значит f не изменится. Вычли и прибавили одно и то же, значит f у меня остается. Поэтому на этом пути f одно и то же всегда и не меняется.
Ну а на остальных, если это ребро не лежит на кратчайшем пути, то здесь будет строго больше значения f. Если это ребро, если эта вершина не лежит на кратчайшем пути, то значит этот путь не оптимальный от s до нее, а потом от нее до t, значит здесь f будет больше.
Если это не лежит на кратчайшем, то это больше, чем f. Ну а наш алгоритм рассматривает вершины в порядке возрастания f. То есть он сначала добавит в кучу вот это вот со значением f, потом ее удалит, добавит вот это с значением f и много вершин с значением больше, чем f.
Потом из них минимально это вот это, опять раскроют ее, добавят вот эту и опять сколько это больше, чем f, ну и так далее. Поэтому по сути он просто сразу идет к кратчайшему пути и все.
Здесь небольшая тонкость, что если тут есть какая-то еще вершина на расстоянии тоже f, то есть есть ну например там два кратчайших пути, вот есть такой путь, есть такой путь.
Тогда, ну здесь уже да, здесь чуть менее приятно он будет между ними как бы бегать, да, например он сначала рассмотрел s, потом добавил вот эти две, потом скажем вот эти две рассмотрел, добавил вот эти две, потом эти две рассмотрел, добавил вот эти две.
И у них у всех будет одно и то же значение f. Вот здесь везде будет f, потому что они все на кратчайшем пути.
Ну то есть поэтому в каком-то смысле, а звездочка как бы все кратчайшие пути найдет. Ну это так, тоже не совсем верно. Какие-то рассмотрит только частично, да, потому что вот его рассмотрел, нашел t, этот путь он заканчивать не будет.
Но главное, что вершины не лежащие ни в каком кратчайшем пути он точно рассматривать не будет. Вот это главное, что весь этот мусор, вот как здесь был, весь мусор лежащий в неправильной области он даже смотреть не будет.
Так, ну это, конечно, утопия. Если у нас есть способ вычислять расстояние от v до t, то, собственно, нам никакая звездочка не нужна. Мы можем просто сразу вывести dist st и все.
Ну вот если h как-то к нему близко, то это вот обосновывает, почему азоточка хороша.
Ну и третье, какие-то конкретные случаи, что если у меня граф расположен на плоскости, ну давайте я нарисую такую сеточку, да, вот как там у меня была.
Есть такая сетка, соответственно, вершины это узлы, и можно двигаться за один шаг вправо, вверх, вниз или влево.
Тогда, значит, это как раз, ну, минимально, сейчас, сори, значит, у меня есть вершинки в узлах, ребра, это, соответственно, вот эти вот вертикальные гридонатальные перемычки,
и какие-то из них, скажем, удалены, ну там не знаю, здесь там мост разрушен, тут нельзя ходить. Вот такой есть граф какой-то.
Мне нужно идти короче же путь отсюда до сюда. Тогда нижней оценкой на расстояние может выступать как раз-таки вот та самая Манхэттенская метрика.
Я напишу, что h от v это vx-tx плюс vy-tx, Манхэттенское расстояние.
Ну понятно, да, из нашей структуры графа понятно, что кратчайший путь отсюда до сюда не может иметь меньшую длину, чем Манхэттен.
Потому что только если в случае, когда здесь нет препятствий, мы можем добиться такого расстояния.
Если препятствий есть, то нам придется их обходить, и расстояние подлинно только вырастет.
То есть выполняется оценка снизу, а h от v всегда меньше обыночен настоящей дистанции.
Четвертое. Это когда у меня вот такая сеточка с диагоналями, значит такая же, только диагонали есть еще везде.
То есть я могу за один шаг переместиться либо вверх, либо вправо, либо вниз, либо влево, либо по одной из четырех вот этих диагоналек, тоже за одну единицу стоимости.
Тогда здесь подойдет метрика Чебушова, расстояние Чебушова.
Ну это максимум из мололей разности. Максимум из vx-tx и vy-ty.
Ну тоже понятно, если у нас такая сетка, то даже в оптимальном случае, когда все ребра присутствуют, нет никаких препятствий, нам нужно ровно столько пройти.
Потому что, если, скажем, модуль разности х это 10, а модуль разности у это 5, то мы сначала проходимся по диагональкам.
Минус 1, минус 1 делаем, и потом х добиваем единичками, чтобы до правильного значения дойти.
То есть это оценка снизу, опять монотонная ивристика, поэтому все здорово.
Ну и последнее, это просто обычное эвклидовое расстояние.
Это в случае, когда у меня, грубо говоря, здесь довольно большая степень дискретизации.
То есть вместо 8 направлений, когда я могу ходить в Чебушовской сетке, я могу ходить, грубо говоря, во все стороны.
То есть у меня нет, иными словами, очень-очень большая степень дискретизации, здесь очень много вот таких исходящих ребр.
Ну тогда это корень из суммы разности квадратов.
Тоже, если у меня нет никаких ограничений, я могу ходить в любую сторону, то это минимально возможная длина, собственно, пути, соединяющей вершинки ВИТ.
Поэтому в зависимости от того, как у вас выглядит сетка, как у вас выглядит граф, на основе, в общем, какой метрик он построен, вам будут подходить всякие разные аж.
Ну и понятно, что если граф не уложен на плоскости, то нужны какие-то еще другие подходы.
В контесте будет задача про пятнашки, вот такая задача, что есть у вас доска 4 на 4, одна свободная клетка, в остальных написаны числа от 1 до 15.
И вам нужно как-то их так двигать, то есть можно число перемещать в свободную клетку так, чтобы получить какую-то перестановку заданную, скажем, тождественную, 1, 2, 3, 4, 5 и так далее до 15.
Ну там тоже нужна какая-то евристика, один из возможных способов, нужна какая-то евристика, ну и так, чтобы азветочка на них хорошо работала.
Чем лучше вы евристику сможете подобрать, тем быстрее ваш алгоритм будет.
Так, есть вопросы по азветочке еще?
Хорошо, тогда едем дальше.
Простой алгоритм Флойда.
Задача такая, пусть в графе могут быть отрицательные ребра.
То есть ребра отрицательного веса. Напомню, что в DX у нас все веса всегда не отрицательные, иначе DX не работает.
Так вот пусть в графе могут быть отрицательные ребра, но отрицательных циклов нет.
Но нет отрицательных циклов.
То есть таких циклов, таких вот замкнутых путей, на которых сумма весов была бы меньше нуля.
Значит тогда алгоритм Флойда
Находит все попарные кратчайшие расстояния. То есть для каждой пары У и В он найдет расстояние от У до В.
Находит все попарные кратчайшие расстояния.
То есть для любой пары У и В он найдет расстояние от У до В.
И делает это он с помощью очень простой динамики.
Пусть считается у меня вершины пронумерованы от одного до N.
И заведем следующую динамику.
DP IJK
Это минимальная длина пути из И в J,
который в качестве промежуточных вершин может рассматривать только вершины с номерами не больше чем K.
Минимальное расстояние из И в J такое, что в качестве промежуточных, кроме И и кроме J,
на пути все остальные имеют номер не больше чем K.
Все промежуточные вершины
имеют номер не больше чем K.
То есть такая вот картинка есть, и есть J.
Мы пытаемся найти кратчайший путь, но используя при этом вот здесь посерединке только вершины с номерами не больше чем K.
Все вот эти вершины имеют номера не больше чем K.
Как это сделать? Как насчитать такую динамику?
Во-первых, DP IJT0 это просто вес ребра из И в J.
Потому что если K равно 0, то нам вообще нельзя использовать промежуточные вершины.
Здесь написано грешение вершины 0, но у меня нет ни одной вершины с номером 0 или меньше.
Значит, мне нельзя использовать ничего промежуточного.
Мне можно только проверить, есть ли ребро между ними, и тогда написать там вес этого ребра.
Равно кост и J.
Я считаю, что если И равно J, то кост равен нулю.
На все вершины я навешиваю неявно петли веса 0.
То есть я могу из вершинки прийти в нее же за 0 стоимости.
Если же нет ребра из И в J, то я считаю, что кост равен плюс бесконечности.
Если ребра нет, то мы искусственно его создаем и говорим, что стоимость на нем плюс бесконечность.
Потому что мы не можем сказать, что кост равен 0.
Мы думаем, что стоимость на нем плюс бесконечность.
Потому что с точки зрения расстояний отсутствие ребра или наличие ребра бесконечного веса это одно и то же.
Мы все равно им не будем пользоваться.
Поэтому в этом случае динамика будет корректно определена, что если ребра нет, то кост равен.
Вот эта dp равна плюс бесконечности.
Ребра нет, dp тоже не определено.
Минимум по пустому множеству это плюс бесконечность.
Теперь простые переходы.
Переход от k до слоя k плюс 1.
Представьте, что мне известны все dp и jk при фиксированном k для любых и j.
То есть k фиксировано, а и j произвольные я знаю.
Теперь я, соответственно, хочу найти dp и jk плюс 1.
Как выглядит кратчайший путь из И в J, который в качестве промежуточных может искусствовать.
Как выглядит кратчайший путь из И в J, который в качестве промежуточных может использовать вершины с номерами не больше, чем k плюс 1.
Здесь есть две простые опции.
Первая опция, что они не просто меньше, чем k плюс 1, но еще и все меньше, чем k.
То есть мы не используем вершину с номером k плюс 1.
Тогда нужно просто взять dp и jk.
Этот случай отвечает тому, что мы вообще не берем вершину с номером k плюс 1.
Второй случай, когда мы, наоборот, ее берем.
То есть вот есть какой-то такой путь.
Здесь где-то есть вершина с номером k плюс 1.
Тогда я утверждаю, что вот на этих кусочках нет вершин с номерами больше, чем k.
То есть если я говорю, что есть вершина с номером k плюс 1, то она максимум одна.
Соответственно, вот здесь на этих кусках все промежуточные имеют номер не больше, чем k.
Ну это почти очевидно. Нет же смысла посещать одну вершину больше, чем один раз.
То есть если мы зашли в k плюс 1, то еще где-то нет смысла ее посещать.
Ну и соответственно нам нужно взять dp и k плюс 1k
плюс dp k плюс 1j k.
Кажется, все.
То есть я либо не беру k плюс 1, либо беру.
Тогда вот здесь мне нужно просто взять значение предыдущего слоя, скатого слоя.
Вот здесь важно, что нет отрицательных циклов.
Потому что это предположение, что мы берем вершину номера k плюс 1 только один раз.
Ну максимум один раз.
Оно верно исключительно в предположении, что нет отрицательных циклов.
Потому что если бы они были, то вот этот оптимальный путь, возможно, вершину k плюс 1 содержал бы много раз.
То есть ну как можно, скажем, вот если есть у меня какой-то цикл отрицательного веса, скажем, минус 1,
есть какой-то путь вот такой вот, который имеет вес ровно минус 1,
тогда мы можем сначала дойти и до k плюс 1, потом петляй здесь сколько угодно долго,
сколько хотим, столько и петляем, потом доходим даже.
И значит distance у меня на самом деле будет сколько угодно большой по модулю отрицательный,
сколько угодно маленький, сколько угодно близко к минус бесконечности.
И поэтому, во-первых, вот это решение будет неверно, что достаточно взять k плюс 1 один раз.
Во-вторых, distance вообще будет не очень корректно определённо.
Он будет равен минус бесконечности.
Потому что мы можем дойти до k плюс 1, бесконечно долго петлять,
наматывая сколько угодно большой по модулю отрицательный вес,
и потом добегать даже с произвольным отрицательным весом.
Вот, а мы считаем, что такого нету, поэтому цикла нам не нужны.
Так, всё вот, по сути, весь алгоритм.
Работает это за n куб, потому что у меня динамика трёхмерная,
каждый аргумент от одного до n бегает, ну и пересчёт за единицу.
А симптотика кубическая.
Вот, почти всё.
Ну, здесь вот у этого подхода недостаток в том, что он ещё и кубическую память требует.
А нет, на самом деле, достаточно квадратичной тоже памяти,
потому что мы видим наш старый трюк, что мы видим,
что k плюс 1 слои динамики выражаются только через k-тый.
Поэтому, чтобы решить задачи, нам достаточно хранить два слоя динамики,
k-тый k плюс 1, через k-тый пересчитать k плюс 1,
потом на место k-того записать k плюс 1,
потом k плюс 2 пересчитывать через k плюс 1,
каждый раз хранять только два слоя.
Можно сделать всё так же, как мы делали с кубической памяти.
И каждый раз хранять только два слоя.
Можно сделать так и обойтись квадратичной памятью, но можно сделать ещё проще.
Давайте напишем следующее, что пусть g и g – это стоимость ребра из и в ж,
стоимость ребра из и в ж, тогда алгоритм Флойда можно написать так.
По всем k от 1 до n, по всем i от 1 до n, по всем g от 1 до n.
Сделать такое обновление, такую релаксацию.
g и t и g и t – это минимумы с вождем лежало,
ну и соответственно суммы весов в путей от i до k плюс от k до g.
Всё.
Даже без dp по сути нам последние измерения не нужны.
Я просто убрал последние измерения и сказал, что dp – это g.
Всё, сделал такую штуку.
В конце, то есть изначально в ж у меня лежали стоимости ребер,
а в конце в массиве g будут лежать стоимости расстояний между всеми парами вершин.
Тут нужно немножко пояснить, почему это корректно,
почему можно вот так втупую отрезать последние измерения.
Почему можно отрезать последние измерения?
Ну, давайте просто докажем, что после кат-итерации внешнего цикла
после кат-итерации внешнего цикла,
ну то есть вот того цикла пока как раз внешнего цикла,
выполнено, что g и t и g и t равно тому самому dp и t и g и t каты.
Вот оказательства индукции пока.
База k равна нулю, очевидно.
В самом начале до выполнения цикла у меня в массиве g лежат просто веса ребер,
а это и есть dp и t и g и t нулевое.
База k равна нулю.
У меня просто хранится веса ребер, и там всё хорошо, там всё верно.
dp совпадает с весами ребер, когда k равна нулю.
Ну, теперь давайте сделаем одну итерацию.
Значит, фиксируем k, рассматриваем k-тую итерацию.
Рассматриваем k-tu-ю итерацию.
Давайте нарисуем матрицу нашего, вот эту матрицу g.
Замечание первое, что в k-той строке и k-том столце значения в течение этой итерации меняться не будут.
Значит, я нарисовал матрицу g, рассматриваю k-тую строку и k-тый столбец.
Вот я утверждаю, что значения в этой строке и в этом столце меняться не будут.
Давайте сюда посмотрим.
Что такое k-той столбец и k-той строка?
Это когда i или g равно k.
Ну, давайте представим, что в этот момент i равно k.
Тогда здесь написано путь из k в g, он релаксируется тем, что там было исходно,
или же расстояние от k до k плюс расстояние от k до g.
То есть у нас есть путь из k в g,
он релаксируется тем, что там было исходно,
или же расстояние от k до k плюс расстояние от k до g.
Но это 0, а это то, что там лежало.
Поэтому если i это k, то у меня в этой строчке не делать ничего ровно, потому что эта штука 0.
То же самое, если у меня g это k, наоборот, здесь написано ik,
здесь написано опять то старое значение, тут опять ik, а здесь написано kk.
Здесь же будет вот это 0, поэтому строчке ничего не делать.
Это значит, действительно, в моей матрице, в течение ката итерации,
вот эти вот товарищи не изменяются,
ну и, соответственно, равны тому же, чему были до этой итерации.
Ну потому что понятно, что если у меня одна из конечных вершин, это k,
то в dp i g k нет смысла использовать k где-то посередине,
потому что если k это одна из конечных, то сама катовершина в промежуше не участвует,
поэтому для нее что k здесь написано, что k-i будет одно и то же.
Здесь ничего не меняется и остается корректным,
но все остальные просто пересчитываются по той формуле.
То есть для всех остальных мы смотрим, на что получается.
Вот если это i g, то мы смотрим ik и kg.
Посмотрим вот эти две клетки.
Но в них написаны правильные значения из dp,
соответственно, у меня просто все остальное содержимое в матрице
в точности пересчитается по вот этой вот формуле.
Каждое значение заменится на минимум из себя и суммы двух правильных значений dp.
Ну все, значит после всей этой итерации у меня вся матрица будет правильная.
То есть единственная проблема могла быть в этом алгоритме в том,
что единственное плохое здесь потенциально могло бы быть,
что когда я делаю все на одной точке памяти в одном и том же массиве g,
могло быть такое, что я на одной итерации сделал несколько.
То есть представьте, что я вот здесь g и g правильно посчитал,
используя катовую вершину.
А потом для какой-то другой пары из штриха и штриха их пересчитал через и g.
А само и g уже учитывает катовую вершину и якобы, соответственно,
типа две итерации за одну сделал.
Ну вот мы доказали, что такого не бывает, что вот эта строка и столбец,
строка и столбец у меня фиксированы, а все остальные через них пересчитываются,
значит мы вот ровно делаем одну переход с k-1 на катой.
Ну все, значит наша таблица, она как раз ровно то самое dp моделирует.
Вопросы?
Хорошо.
Тогда последнее простое замечание про Флойда,
это как можно восстановить ответ, как можно восстановить сам путь.
То есть сейчас мы знаем корочайшее расстояние,
расстояние между всеми парами вершин,
а вот как узнать прям последовательность вершин на этом пути?
Значит восстановление ответа,
то есть восстановление самих путей.
Не их весов, а прям самих путей, как последовательность вершин.
Здесь все тоже довольно прозрачно.
В случае, когда я обновляю значение g,
g этой житы обновляется, то есть оно было раньше чем-то, а потом уменьшилось.
Когда оно уменьшается?
Когда я нашел в качестве нового оптимального расстояния вершины,
то есть в качестве нового оптимального расстояния вершины,
то оно уменьшается.
Когда я нашел в качестве нового оптимального пути из FG некий путь, проходящий через K.
Давайте тогда сделаем следующее.
Вот когда g и t житы обновляется
через g и t ка т, плюс g ка т житы,
мы для этой пары и g запомним, что k как бы центральная вершина.
Выполним P и t житы равно k.
И соответственно, затем, когда весь алгоритм у нас закончится,
у меня для каждой пары вершин и g будет храниться в этом массиве P и g вспомогательным,
будет храниться какая-то вершина на этом пути.
Центральная вершина на этом пути, в смысле что посередине,
в смысле что она имеет максимальный номер на самом деле,
будет храниться у меня вершина с максимальным номером, которая на этом пути лежит.
Чтобы найти этот самый путь из FG,
я понимаю, что мне нужно сначала из P, потом из K.
Давайте сначала рекурсивно напечатаю путь из P, потом напечатаю K,
потом напечатаю путь из K в G.
Конец.
Тогда путь из И в Ж выглядит так, что это сначала путь из И в П и Т в Ж, потом сама эта вершина П и Т в Ж, потом путь из П и Т в Ж, конец.
Идея очень простая. Я запомнил, когда я в самый последний раз пересчитал Ж и Т и Ж, через какое К, с помощью какой вершины я добрался из И в Ж.
Если я знаю, что я добрался с помощью этой вершинки с номером П и Ж, мне нужно сначала найти вот эту часть пути рекурсивно.
То есть я пишу какую-то функцию, которая принимает две вершины и печатает путь между ними.
Тогда сначала из И до первой половинки, потом саму эту вершину, потом из этой центральной вершины до конца. Тоже рекурсивно печатаю путь.
Время не поменяется, память вырастет в два раза, потому что нужен вспомогательный массив П, поэтому точка не изменится.
Хорошо.
Вот такой флойд работает за куб, очень просто пишется. Находит все кратчащие расстояния между всеми парами вершин.
Если у вас реальная задача такая, что между всеми парами надо найти расстояние, то ничего проще, чем флойды написать.
Я не представляю, что можно, здесь четыре содержательные строчки. 4-4-4 и релаксация через минимум.
Очень простой алгоритм.
Наконец последний алгоритм с хорошейшими путями, это алгоритм Форда Белмана.
Это наконец алгоритм, который адекватно работает в самом плохом случае, когда могут быть и отрицательные ребра, и отрицательные циклы.
В самом деле во флойде тоже можно было научиться работать с отрицательными циклами, но мы не будем это обсуждать.
Давайте считать, что в графе теперь, только теперь, могут быть и отрицательные ребра, и отрицательные циклы.
То есть циклы отрицательного веса.
А задача такая.
Ну, во-первых, надо теперь определить, что такое расстояние от S до T.
Соответственно с нашим обычным определением, что это минимум по всем возможным длинным путей из S в T, оно теперь может быть минус бесконечность.
А именно вот как раз в том самом случае, когда я могу от S добраться до какого-то цикла отрицательного, по нему сколько угодно много впитлять, потом дойти до T.
В таком случае дистанц может быть сколько угодно отрицательным.
Сколько угодно большим по модулю отрицательным.
Поэтому давайте напишем следующее простое соображение, что дистанц это минус бесконечность, если и только если существует цикл С отрицательного веса.
С отрицательного веса такой, что из S достижимо C, из C достижимо S.
Стрелочки я рисую достижимость.
Из C достижимо C, из C достижимо T.
Вообще говоря, это надо доказывать, потому что у меня есть определение, что такое дистанц, как минимальная возможная длина пути.
Почему минус бесконечность для этого минимума равносильно наличию такого цикла?
Давайте как-то это поясним.
Почему только в такой ситуации может быть у нас минус бесконечность в качестве дистанца?
Давайте я скажу следующее.
Пусть кост ИG по модулю не больше, чем X для любого ребра ИG, а вершина у меня ровно N.
Пусть Дист СТ это минус бесконечность.
Я хочу доказать, что есть отрицательный цикл на пути из С в Т.
То есть еще раз, я доказываю ту кв документность, что минус бесконечной расстояния, то же самое, что есть отрицательный цикл.
То это мало.
цикл на пути из s в t. То есть еще раз, я доказываю
ту эквивалентность, что минус бесконечное расстояние,
то же самое, что есть отрезательный цикл, достижим
на пути из s в t. Справа налево очевидно, по картинке
мы просто доходим до него, петляем сколько угодно
долго, потом доходим до t. Теперь слева направо.
Почему, если distance st минус бесконечность, то обязательно
есть такая картинка, что мы доходим, потом петляем
по циклу, потом доходим до t. Так вот, пусть это
бесконечность, тогда рассмотрим, рассмотрим путь из s в t
веса меньше, чем минус xn с минимальным возможным
числом ребер, с минимальным числом ребер. Ну такой путь
понятное дело есть, потому что у меня последовательность
множества длин путей не ограничена снизу, значит есть
сколько угодно отрицательное число, сколько угодно большое
по модуле отрицательное, значит есть вес меньше, чем
минус x. Среди них я могу выбрать путь с минимальным
числом ребер, потому что натуральные числа фундированы,
то есть минимум корректно определен, это какое-то число.
Дальше. Как он выглядит? Какой такой путь? Первое
замечание, что число ребер в нем строго больше, чем n,
потому что если бы их было не больше, чем n, то его вес
никак не мог бы быть меньше, чем минус xn, потому что
каждое ребро имеет вес больше или равно, чем минус x,
значит если бы их было не больше, чем n, то суммарный
вес был бы больше или равно, чем минус xn, значит ребер
больше, чем n, значит есть какой-то цикл, мы какую-то
вершинку посещаем хотя бы два раза, есть по крайней
мере один цикл, значит есть цикл, ну потому что если
цикла нету и каждая вершина приходит в новую вершину,
то значит вершина у меня посещена аж, видимо, n плюс
1, видимо, n плюс 1 вершина получается посещена, или даже
n плюс 2, короче даже n плюс 2, потому что ребер хотя бы
n плюс 1, значит новых вершин хотя бы n плюс 1, с учетом s
и хотя бы n плюс 2, ну короче, точно если вершина посещена
хотя бы дважды, значит есть цикл. Ну и тогда смотрите,
если у этого цикла вес не отрицательный, тогда я
его могу отбросить, и мой путь в состоянии только лучше,
у него вес останется меньше, чем минус xn, а число ребера
уменьшится, значит исходный был не оптимальный, значит
единственная возможность это, что это цикл отрицательного
веса, победа, значит есть путь из s в t содержащий
какой-то отрицательный цикл. Давайте еще раз повторю,
что есть цикл, если он имеет не отрицательный вес,
то его можно отбросить, его можно отбросить, получить
лучший путь, получить лучший путь. Лучший в том смысле,
что будет выполняться и вот это условие, а вот это условие
станет еще лучше, потому что число ребер только уменьшится.
Я выбросил цикл, число ребер уменьшилось, но при этом
неравенство выполнилось, поэтому мой исходный путь был
не оптимальным с точки зрения числа ребер. Ну все, значит
действительно на таком пути есть отрицательный цикл
и мы доказали то, что хотели. Согласны? Это возможно было
даже не нужно доказывать, то есть очевидно, что как
гипотетически можно вот здесь получить внизу бесконечность,
только петлять где-то сколько угодно долго, но вот это
формализация. Так, хорошо, теперь к алгоритму наконец.
Алгоритм находит кратчайшее расстояние от s до всех.
Находит кратчайшее расстояние от s до всех. То есть не все пары
между собой как флойд, а только от s до всех. Так же,
как было в DX-ре, от s до всех. Только теперь могут быть
отрицательные циклы и отрицательные ребра.
Так, опять динамика. dp v k это минимальная стоимость пути
из s в использующей не больше чем k ребер. Минимальный вес
пути из s в использующей не больше k ребер. Такая динамика.
Как она насчитывается? Если карту нулю, то нам нельзя
использовать ребра, и здесь понятно, что лежит. Это либо
0, если v равно s, либо плюс бесконечность, если v не равно
s. Потому что если нам нельзя использовать ребра, то мы
можем только стоять на месте. Значит, нул, собственно.
dps это 0, а dp и все остальные это плюс бесконечность.
Нельзя никуда попасть. Вот, ну переход. Если я хочу
вершину v попасть за k ребер, давайте я переворачиваю
последнее ребро. Тогда выполняется следующее соотношение.
dp v kt это минимум. Ну, во-первых, надо оставить там
dp v k-1, потому что, а вдруг мне не нужно все k ребер
проходить, достаточно k-1. Значит, это случай, когда
я использую не больше, чем k-1 ребро. Теперь нужен
случай, когда я использую k ребер. Тогда нужно перебрать
последнее. То есть я перебираю все возможные ребра у v
в нашем графе. Ну и здесь остается dp u k-1
плюс кост u v.
То есть еще раз. Это случай отвечает тому, когда я беру
не больше, чем k-1 ребро. Это случай, когда беру все k ребер.
Если я беру k ребер, то давайте я переберу последнее.
Перебираю ребро u v, торчащее в v. Тогда что такое путь
использующий k ребер, при этом посещающий последнее ребро?
Значит, нам нужно сначала оптимальным образом добраться
до u за k-1 ребро, потом это ребро приклеить.
Ну, собственно, это здесь не написано, что мне нужно
добраться сначала до u за k-1 ребро, потом взять вот это
последнее ребро u v. Верно?
Вот. Ну так пересчитывается наша динамика.
Тогда я утверждаю, что если у меня нет отрицательных
циклов, то мне достаточно посчитать n-1 слой динамики,
и это будут ответы.
Если уже нет отрицательных циклов, то для любого v dp
vt n-1 равно dist sv.
Ну, это наш любимый аргумент, что если и есть какой-то
путь от s до v, то он содержит не больше n-1 ребро.
Ну, в смысле, если есть какой-то путь, то кратчайший содержит
не больше н-1 ребро, потому что иначе, если он содержит
хотя бы n ребер, то он обязательно какую-то вершину посещает
дважды, значит, входит в цикл, а циклы нам вредны,
потому что нет отрицательных.
Вот в этом предположении, если их нет, тогда циклы нам
не нужны, поэтому достаточно n-1 ребра для нахождения пути.
В этом случае получается асимптотика n на m,
потому что вот этот второй аргумент бегает у меня от 0
до n-1, n слоев в динамике.
Ну, и внутри каждого слоя я для каждой вершины рассмотрю
все входящие в нее ребра.
Это в точности m, потому что для каждой вершины я рассмотрю
все входящие, значит, я рассмотрю все ребра по одному разу.
Значит, это слоев в ДП, но это время обработки одного слоя.
Потому что на каждом слое, префиксированном в втором
аргументе, я для каждой вершины рассмотрю все входящие в нее ребра,
то есть рассмотрю просто все ребра по одному разу.
Асимптотика будет n-m.
Так, ну и здесь память тоже у меня получилась квадратичная,
n на n.
Но на самом деле тот же самый трюк работает,
что нам достаточно хранить два слоя динамики,
потому что видим, что карты перешли через k-1.
Значит, достаточно, опять, ну, просто ДП в предыдущий слой
и ДП в текущий слой сделать.
Достаточно по этому линейной памяти.
Достаточно от n памяти сделать.
С помощью двух слоев динамики.
Ну, на самом деле там можно так же, как во флойде,
вот это вот второй аргумент вообще не хранить,
и просто хранить ДП в это, и как-то их там доставать и проталкивать.
Но давайте на этом не будем.
Давайте считать, что у меня два слоя динамики,
они один через другой пересчитываются.
Вот это простой случай.
Если нету отрицательных ребер, то, понятное дело,
мы найдем всегда правильный ответ.
За n-1 итерацию нашей ДПшки.
Теперь случай интересный, когда есть отрицательные циклы.
Теперь пусть в G есть отрицательные циклы.
Тогда давайте сделаем следующую вещь.
Давайте мы сделаем на одну больше итерацию нашего алгоритма.
То есть вот до этого момента мы сделали,
мы посчитали все ДПшки до n-1 слоя.
Теперь давайте еще один лишний сделаем.
Давайте ДП н-ый слой посчитаем.
Давайте напишу, что не есть, а могут быть.
Тогда найдем ДП вн для любого v,
по тем же формулам.
То есть просто сделаем на одну итерацию больше
в нашем алгоритме динамики.
Тогда я утверждаю следующее утверждение.
На каждом отрицательном цикле
хотя бы у одной вершины значение ДП уменьшилось.
Формально, если C это цикл отрицательного веса,
отрицательного веса,
достиженный из S,
то хотя бы для какой-то его вершины
ДП вн строго меньше, чем ДП вн-1.
Понятно, что если отрицательных циклов нет,
то последняя вот эта итерация n,
она просто не будет быть в нём.
Но если у нас есть отрицательный цикл,
то если у нас есть отрицательный цикл,
то если у нас есть отрицательный цикл,
то, так говоря, последняя вот эта итерация n,
она абсолютно бесполезна,
потому что мы знаем, что все кратчайшие пути
в отсутствие отрицательных циклов
имеют длину максимум n-1 ребро.
Поэтому, если бы их не было,
то это неравенство нигде бы не достигалось.
Но я утверждаю следующее верное обратное,
что если есть отрицательный цикл,
то на каждом отрицательном цикле
хотя бы одной вершинкой ДП уменьшится.
Доказательства.
От противного.
Пусть есть какой-то отрицательный цикл.
С.
Я нарисую все его ребра.
Пусть c1, c2 и так далее, ck,
это их...
Давайте не ck, а c, какой-нибудь l.
Это их стоимости.
Пусть есть отрицательный цикл
с стоимостью ребер c и t.
Тогда сумма c и t
поит от 1 до l меньше 0.
Это условие того, что он у отрицательного веса.
Предположим, что вот это неверно.
Что ни для какого v
у меня не будет здесь неравенства.
То есть, наоборот, для любого v
из c
верное равенство на самом деле.
Здесь не может быть значка
больше,
потому что когда я считаю n-й слой
через n-1, я в частности там сохраняю
старое значение и пытаюсь его еще
релаксировать чем-то поменьше.
Поэтому здесь значка больше быть не может,
потому что для пересчета этого я всегда беру
минимум из вот этого и чего-то там еще.
Поэтому здесь может быть только равенство.
Значка больше быть не может.
Но главное, что из этого следует.
То есть,
так, мне, видимо,
еще нужно будет вершины занумировать.
Пусть это будет v1, v2, v3
и так далее vl.
Главное, что из этого следует.
Сейчас, секунду.
Так, момент, сейчас я немножко
повдупляю, значит, здесь будет, видимо,
vi
плюс один, я хочу написать, здесь будет
dp vi,
это n-1,
плюс ci, вот что я хочу написать.
Вот.
Для каждого i будет выполнено
вот такое вот неравенство.
Почему?
Потому что, смотрите, как у меня считается
dp vi плюс 1,
я рассматриваю
все входящие в нее ребра.
В частности, я рассмотрю вот это ребро из vi,
vi плюс первое, веса ci.
И поскольку я из них всех беру минимум,
то значит, в частности, эта штука меньше
и равна, чем dp vi,
vi t, n-1, то есть дойти сюда,
зайти на одно ребро, и потом приклеить
вот это последнее ребро, веса ci.
Ну, это просто из нашей динамики,
что, что я делаю,
я делаю,
я делаю, я делаю,
ну, это просто из нашей динамики,
что, чтобы посчитать эту штуку, я в частности
рассматриваю такой путь.
Хорошо. Теперь давайте я
сложу все эти неравенства по всем i.
Сложим эти неравенства
по всем i.
Ну, слева получится
перестановка всех вершин,
v2, v3, v4 и так далее, v1,
т.е. это будет просто сумма
по всем вершинам из цикла
dp, vt, n.
Здесь тоже будет сумма
по всем вершинам из цикла, v1, v2,
и так далее vlt,
т.е. сумма будет та же самая,
ну, только как бы со сдвигом, да,
порядок слагами поменяется,
dp, v, n-1.
Так, ну и остается сумма весов всех ребер.
Сумма по житце житая.
Ага, время кончилось.
Вот. Ну и все.
А вот эти штуки тогда сокращаются
и получается, что сумма весов у меня
больше на нуля, противоречие.
Ну, предположим, что цикл отрицательный.
Получилось, неравенство
с той штукой больше равна нуля,
а исходно предположим, что он отрицательный.
Так, давай тогда на этом
закончим, последнюю мысль я скажу в следующий раз.
Спасибо.
