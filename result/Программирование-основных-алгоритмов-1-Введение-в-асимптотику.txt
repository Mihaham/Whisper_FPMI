Так, ну окей, всем доброго утра. Я вас приветствую на курсе алгоритмов и структур данных.
И, как вы могли заметить, здесь много народу, хотя никто из вас не ожидал, что у вас столько будет,
потому что у нас огромная мишанина получилась в силу определенных особенностей.
Ну, что поделать? Это такие организационные моменты. А давайте приступим.
Ну окей, как меня можно звать? Так, меня зовут Кулапин Артур Евгеньевич.
Окей, ваши семинаристы уже должны были по-хорошему вам выслать ссылку на чат.
Ну, на канал курса в телеграме, там же есть ссылка на чат и все, все организационное. Если нет, то я сейчас напишу.
И сейчас мне придется подтянуть немного, потому что...
Так, по-моему, она вот такая вот, но те, кто есть, может верить. Ну, вроде бы да.
Я продолжу тогда, видимо, раз просит. Окей, это канал курса, там будет появляться вся организационная
информация. Сейчас там есть уже ведомость в ней, можно найти формулу, как у вас будет ставиться оценка за этот курс.
И там же есть ссылка на первый контест, первое домашнее задание. Он откроется после лекции.
Есть три цюка. Дедлайн через чуть меньше чем две недели. Так что, спешите решать.
Да, сразу скажу, что у нас, ну, давайте, наверное, выпишу, как у нас будет устроена система оценивания.
Она устроена следующим образом. Пусть K это доля от максимума за контеста.
Там в ведомости указана разболотка всех задач, какая, сколько, весят.
То есть берется ваш набранный бал, делится на идеального студента, так называемого, и получается число от нуля до одного.
То есть на СТ это бла-бла-бла за теорки, так называемые.
Теоретические домашние задания. Это будет набор некоторых задач, которые вам предстоит решить и зачитить либо семинаристам, либо ассистентам.
Они уже будут сами устанавливать формат, как вы будете это делать.
Тогда, ну, соответственно, это от нуля до одного, от нуля до одного.
И то мы получаем такую формулу на самом деле.
То есть семь с половиной за контест плюс два с половиной на теорки. В сумме десять. Офигелятся по правилам математики.
Да, если что, будут бонусные задачи. То есть на самом деле здесь можно больше, чем один будет получить.
Там альфа, альфа, больше на единицы. В контестах аналогично будет.
То есть можно получить больше десяти, но это вам в плюс, но я смотрю, что кто-то получит больше десяти.
Будем честными. Вот это формула.
Давайте назовем это так. За зачет.
Потому что у некоторых из вас и зачет, и экзамен в этом семестре по курсу алгоритмов.
Поэтому это только за зачет. Экзамен – это вообще отдельное мероприятие, которое с зачетом никак не связано.
Они живут в параллельных плоскостях и, соответственно, оценки друг на друга никак не влияют.
У тех, у кого будет только зачет, возможно, если нам состав семинаристов будет очень скучно в декабре,
мы проведем еще устный зачет, который будет с каким-то весом фигурировать с этой штукой.
Но это не точно. Следите за объявлениями в канале и будете все знать.
Есть ли вопросы по организации курса?
Ну, видимо, вопросов нет. То есть, всем понятно, как вы будете получать оценку.
Соответственно, да.
Окей.
Все понятно, про это все сказали.
Ну, тогда давайте пойдем вообще о том, зачем изучаем алгоритмы и структуры данных.
Может быть, есть те, кто знает ответ на этот вопрос.
Если все это уже за вас реализовано в других библиотеках.
Ну, вот вы знаете, мне вот всю неделю писали люди с первого курса, которые
не понимали, что это такое.
Ну, я не знаю.
Ну, вот вы знаете, мне вот всю неделю писали люди с первого курса, которые
попали по распиленному контесту в базу, но хотят очень в основу.
Вот, я очень хочу услышать от них ответ на этот вопрос, потому что они зачем-то хотели в основу.
Значит, они, наверное, знают, зачем нужны алгоритмы. Вот, здесь есть такие?
Ну, нет. Окей.
Ну, на самом деле алгоритмы нужны внезапно не для того, чтобы вы знали кучу алгоритмов. Вау.
Если вы умеете там, не знаю, писать какой-нибудь суффиксный автомат, то, конечно, круто.
Но то, что вы знаете, что он существует, это вам никакого преимущества не дает.
Собственно, поэтому и существуют контесты и терки для того, чтобы вы учились видеть в разных условиях,
где вам нужно применить тот или иной алгоритм. Потому что никто в будущем вам не будет ставить задачу,
не знаю, напиши бинпоиск. Ну, такого не будет, к сожалению.
Вот, там придется учиться их видеть. Ну, или понимать, что...
Или это как бы одна сторона медали. Другая сторона медали, вам нужно...
Будет понимать, что быстрее какие-то задачи просто решить нельзя.
Мир жесток, да. Не все можно решать очень быстро.
Окей. То есть наша мотивация – это научиться их видеть эти алгоритмы,
распознавать их и, быть может, применять по возможности.
Потому что, опять же, далеко не каждый захочет видеть в вашем коде какую-нибудь фибоначевую кучу,
потому что это очень сложно и неподдерживаемо.
Теперь перейдем к плану курса. Курс двухсеместровый.
У нас будет два семестра. Давайте как-нибудь разделим, наверное.
В первом семестре мы начинаем в самых основ-основ.
Это асимптотика, бинпоиск, бла-бла-бла.
Затем идем к... То есть у нас в первом семестре посвящен куча структур данных на самом деле.
То есть здесь в основном структуры данных.
Ну, такие как хэш-таблицы.
Это деревья поиска.
Ну, что еще? Ну, какие-нибудь деревья отрезков будут обязательно.
Ну, тысячи их.
Может быть, мы сюда еще успеем в сон динамическое программирование, геометрию, сортировки, кучу и так далее.
Но, скажем так, это еще открытый вопрос.
Геометрия, динамическое программирование.
А вот второй семестр будет полностью посвящен тому, как применять разные из этих штук в определенных задачах.
Ну, соответственно, здесь будут два конкретных больших блока. Это будут графы.
И вот здесь у нас будет геометрия.
Здесь будут два конкретных больших блока. Это будут графы.
А что именно из графов? Это будут всякие обходы. Обходы в ширину, обходы в глубину.
Дальше это будут кратчайшие пути.
Это некоторые известные алгоритмы DX3.
И зацепим в зависимости от того, как мы будем с вами контактировать.
И третий кусочек программы. Это будут всякие потоки.
Это первое. И второе. Это будут строки.
Это вот то, что проходит на третьем, так сказать, третьем семестре по МАИ.
В своем курсе основных алгоритмов.
Вот такой вот у нас план.
А сегодня мы начнем с самого-самого-самого-базового.
С чего только можно начать.
Это мы с вами поймем вообще, как оценивать алгоритмы, хороший или плохой.
Вот у вас есть, допустим, две программы, решающие одну и ту же задачу.
Одна из них заходит по ТЛюБ-контест, другая нет.
Вопрос, почему? Как можно понять вообще, эффективно ли программа или нет?
И в каких терминах это понимать?
Да, у нас будут сами две величины.
Характеристики, нажимаем так, за которые мы будем следить.
Это время и память.
У нас два вида ресурсов, на самом деле.
Ну, собственно, память у нас будет обычная оперативная.
Мы будем жить в прекрасном мире, на котором мы смотрим в розовых очках.
Где у нас все вмещается в оперативку.
Все прекрасно работает, все очень быстро с памятью и так далее.
К сожалению, в жизни это не так, но
чтобы изучать эту науку, надо пройти сначала то, что мы сейчас будем проходить.
А время, ну время, оно везде время.
И в каких терминах это измерять?
Не очень понятно, но программа отработала секунду.
На другом железе она может отработать за 0,5 секунды, например.
Или за 10 секунд.
Что?
Ну да, очень сложно говорить про физическое время.
И поэтому здесь были введены асимпатические классы.
Давайте будем введем определение.
Пусть f, g это функции, определенные на n.
Вот.
Тогда...
Если что, это поточная аудитория арки. Заходите.
Тогда f от n.
Если...
Ну...
Давайте подумаем.
Сначала графически пробуем изобразить, потому что у нас есть первокурсники, которые
еще с кванторами не очень владеют, скажем так.
Что мы хотим?
То есть у нас есть какой-то график g от n.
И у нас есть график g от n.
И у нас есть график g от n.
То есть у нас есть какой-то график g от n.
И мы хотим, чтобы f от n, начиная с какого-то момента,
лежало ниже, чем какая-то константа c умножить на g от n.
То есть как мы хотим, чтобы f от n как-то вот так вот себя ввела.
То есть в какой-то момент n0, они могут сравняться, но дальше f должна быть ниже, чем g.
Давайте упражнение по мотонализу, запишите это в кванторах.
Кто может сказать как-то в кванторах эту мысль?
Давайте как-нибудь так сформулируем, да?
Тут n0 натуральный.
Существует c, такое, что
для любого n больше либо равного n0,
f от n меньше, в общем, c на g от n.
Похоже на правду?
Да, мы считаем, что c больше нуля. Справедливо.
Вот собственно мы будем говорить, что f равно o от g, если вот такое вот выполнено.
Поэтому у нас как бы классы алгоритмов подразделяются на полиномиальные,
это которые o больше от полинома.
И так далее, и так далее. Давайте рассмотрим какой-нибудь пример.
Доказать, что f от n...
Ну, как-нибудь не знаю.
Вот такая вот f от n, это какой-то многочлен, n куб плюс n квадрат плюс n в степени альфы пускай,
и f от n по большой от n в степени альфы. Здесь даже двоечку поставлю. То есть нам
можно показать, что многочленок достаточно сокращать до старшей степени. Вот это вот
байду. Я верю, что вы с этим сами справитесь, потому что это несложно. Вы просто берете,
там не знаю, n равное 3, подбираете f, и подбираете n0, начиная с которого
13 степени альфа больше, чем вот эта штука. Оно обязательно такое найдется в силу монотонности.
Да, это правда. Это правда, действительно. Здесь можно написать что угодно,
но обычно сокращают до наиболее старшего. Да, конечно, потому что у вас целомножить на g от n. То есть
вы сюда можете от 3n в степени альфы написать спокойно. Но обычно их опускают, то есть берут
наиболее значимую функцию. Давайте из чего-нибудь такого, что более интересное. У вас будет множество
примеров на семинаре, которые будут у кого-то на этой неделе, у кого-то на следующей. Вот такой пример.
Давайте это сатру, наверное, уже не нужно.
Правда ли, что f равно от g?
Смотрите, что такое логарифт по основанию гамма от n? Это можно, например, так написать. Согласны?
А мы договорились, что мультипликативные константы нас не интересуют в обольшом,
поэтому всегда пишут просто лог без основания. Да, программисты настолько ленивы, что им лень писать
основания. Для простой жизни давайте напишу двоичный. Обычно нас будет интересовать двоичный
логарифм. Просто формула перехода логарифма к другому основанию. Вот вопрос, правда ли, что это
для таких f уже верно? Не правда, да? Естественно, не правда. n делить на лог растет гораздо быстрее,
чем лог. Я предлагаю вам написать рисание этого определения и, соответственно, построить нужные
вам наборы входных данных самостоятельно. Еще у нас будет несколько терминов. Это будет
омега большая и тета большая. Окей, ну я вернусь все-таки к той доске и напишу вот здесь вот
определение. f от n, омега большая g от n. Да, это вот омега большая, но я думаю физики знают,
что это буква. Вот. Если вот бла-бла-бла-бла-бла. Сейчас я на один уровень даже их помещу.
Вот. Выглядит странно, да? То есть что мы хотим? Мы хотим, чтобы у нас функция f,
всегда, какую бы мы не выбирали константу, f всегда была бы выше, чем g. То есть, на самом деле,
что мы хотим? Мы хотим, чтобы у нас было здесь не так написано. Для любой c больше нуля найдется
n0, принадлежащий n. Вот здесь вот так вот важно порядок расставить. Какую бы вы константу не
выбирали, найдется момент такой, что начиная с него f будет больше равна, чем в целом нужна эта
функция. То есть, если здесь у нас ограничение сверху роста, то здесь ограничение снизу. И обычно,
обычно, мы будем жить в прекрасном мире, где мы будем оценивать только о большие. Потому что
оценить сверху всегда проще, чем оценить снизу. Ну вот в математике есть всякие задачи на оценку
плюс пример. То есть, вам нужно там где-то оценить что-то и провести пример. То есть,
какой-то пример и показать, что лучше нельзя. То же здесь, вам нужно показать, что у вас g от n
достижимо. А показать, что лучше, чем g от n нельзя, очень сложно. Очень сложно доказывать,
когда очень сложно доказывать утверждение, вида. Правда ли, что мы не можем сделать что-то лучше,
чем? То есть, правда ли, что это оптимальное время, лучше нельзя? И существует лишь несколько алгоритм,
для которых доказаны такие асимпотики. О них мы будем говорить, скорее всего, через лекцию. Это
всякие сортировки. Там доказано, что лучше, чем n лог n нельзя, просто-напросто, при определенных
условиях. Но в целом, будем очень редко получать омега. Обычно, будем гнаться за вот этим,
то нам этого будет хватать вообще с головой. Ну, это у большой, если что.
Ну, это в краске будет рассматриваться на семинарах. Вы будете доказывать, что правда,
что неправда. То есть, как можно эти значки менять местами. Вот. Ну, есть еще третье определение.
Давайте я напишу для полноты картины. Это большая буковка тета. Вот такое, буква O, в ней буква N.
Вот это тета. Если для любых c1 больше c2 больше 0, существует n0. Такое, что для любого n,
f от n будет зажато с двух сторон. Вот. То есть, это как вообще победа. То есть, как мы получили,
что у нас f от n, начиная с некоторых моментов, ведет себя как функция g от n, асинтетически. Ну,
с точностью это константы. Вот. То есть, мы смогли зажать между двумя рамками, причем они одинаковые.
Они очень близки друг к другу. Вот теты мы будем получать еще реже, чем омеги. Потому что,
чтобы доказать тету, вам нужно получить O большое. Это мы обычно будем делать. Получить омегу большую
— это сложнее. А получить омегу равную ошке — это почти невозможно обычно. Вот. Окей. Как-то так.
Вопросы пока что? Про умалые? Смотрите, умалые нам вообще не нужно, на самом деле. Нам нужно
вот эти три штуки. Есть еще их младшие братья-близнецы, назовем это так. Это омега-малые,
о-малые и тета-малые. На них никто не пользуется. Потому что это, скажем так,
приоргатива больше математиков, чем программистов. Вот. Нас-то в математике будет либо в
матанализе умалое встречаться, либо же у тех, кто на ПМИ, на курсе Райгородского. Не знаю,
есть ли похожий курс у ПМФов. Наверное, езде будет еще умалое. Поэтому я тактично уйду от этого вопроса.
Так, сколько у нас времени? 25 минут. Да. А вы как хотите сформулировать?
И что?
Действительно.
Окей, ладно. Давайте оставим пока что это под вопросом. Да, ладно, я подумаю, точно скажу,
потому что произошел просак. Окей, тогда теперь что мы будем делать дальше? На самом деле,
дальше нас интересуют рекуррентные соотношения, их ассинтетическое поведение. Потому что
многие алгоритмы выполняются рекурсивно. Где вы разбиваете под задачу на части,
что-то с ними делаете, и там дальше что-то решаете. Одно из самых известных рекуррент – это вот такая
штука. Вот, там пример рекуррентного соотношения. Ну, кто-нибудь может узнать,
что здесь спрятано? Какой алгоритм работает вот с таком вот временным соотношением? Ну да,
это бинпоиск всем известный. Ну, для тех, кто не знает, мы сейчас будем пояснять, что такое бинпоиск.
Вот. Ну, давайте так вот. Пусть f от n – это монотонная функция. Ну, для определенности она будет строго
возрастать. Возрастающе. Тогда, ну, есть такая теорема в монотонализе, строго возрастающая.
Ну, из монотона или из наивных соображений.
Для любой c найдется n0 такое, что… И будут выполнены два требования. f от n0 больше либо равно c,
и для любого n1 меньше, чем n0, f от n1 меньше, чем c. Даже не так, давайте тоже формулируем. Для
любого n2 вот так вот. Вот. Ну, здесь для любой цеп хорошая, надо сказать,
есть область определенности функции, есть область значений, по-моему, называется. Вот область
значений функции, если вы возьмете тут константу, то тогда у вас будет выполнено такое соотношение.
Собственно, задача обычного бинпоиска – это найти вот это вот n0, найти какое-то пороговое значение.
То есть найти такое минимальное n0, начиная с которого там что-то верно. Вот обычно у нас все задачи,
которые будут звучать, найдите минимальное, не знаю, к, чтобы, бла-бла-бла, или максимальное
l, чтобы, бла-бла-бла, они все у вас будут на бинпоиск. То есть у вас будет как-то
встает такой предикат. Пусть b от n – это предикат. Ну, предикат – это такая-то типа функция,
которая разрешает либо 0, либо 1, true-false. Такой, что для любого n больше-либо равного n0, b от n
равно 1, 0. Задача – найти n0. Вот что мы хотим – найти n0. И мы хотим это сделать быстрее,
чем перебирать все возможные n из области функции f. Ну, давайте нарисуем какой-нибудь график,
чтобы было понятней чуть-чуть, что происходит. То есть, как бы, вот ваше такое пороговое поведение.
То есть, у вас как-то вот так вот функция ведет себя. Здесь n0, это n, это f, n. То есть, у вас
какая-то вот такая вот графика этого предиката, и вам нужно найти этот n0. Ну, как это можно делать?
Ну, допустим, вы знаете, что он лежит в каких-то окрестностях от a до b. Ну, что вы тогда делаете?
Вы просто алгоритм следующий. Пойска n0. Первый шаг – это m равно a плюс b пополам. Вы выбираете серединку
где-то здесь. Если у вас… Второй шаг. Если p от m еще равно единице, то если вы попали вот так вот,
значит, что у вас где-то вот в этой области находится ваше 0, и вы сокращаете задачу ровно в два раза,
то говорите, будто бы, что b равно m. Иначе a равно m. Шаг третий. Повторять 1, 2 пока.
Пока у вас такое вот соотношение выполнено. Ну, если у нас n0, это натуральное. Иначе у вас будет
все это заданное точностью. Ну, о том, если у вас здесь a, b, m – это какие-то вещественные числа,
вы будете говорить опять же на семинарах. Спойлер, у вас вещественных чисел не бывает в компьютерах.
Вот. Их невозможно сохранить полностью. Поэтому все это сведется к дискретному
случаю. Просто немного менее приятному, назовем это так. Вот. Ну, и давайте посмотрим. Просто выпишем
этот алгоритм. Давайте обозначим l – это модуль b минуса. Тогда за сколько вы найдете ответ на
отрезки длины l? Ну, вы сведете задачу к задаче вдвое меньше. Плюс выполнив o от единицы действий.
Если у вас, ну, этот предикат, этот p, считается за o от единиц, то есть за какое-то константное число
операций. Понятное дело, что в общем случае предикат будет не за единицу считаться. И тогда у вас будет
стать какое-то o от p, где p – это время подсчета этого предиката. Вот. Ну, как решать эту рекурренту?
Ну, и в целом, как решать рекурренты? У рекуррент есть несколько способов их решений. Вот первый
способ – это для тех, кто когда-то знаком с алгоритмами в свое время в школе, это мастер-теорема,
вот огромная, страшная теорема. Ну, наверное, она бы заняла у нас вот посюда бы место,
все ее формулировки, если не больше. Поэтому ее обычно никто не помнит полную формулировку и
когда надо, мне просто заглядывают. Вот. А доказательство у нее тут, наверное, ну, пару таких
быдосок огромных заняло, поэтому мы не будем этим заниматься с вами. Все-таки у нас как-то так
сжатый курс алгоритма. Относительно сжатый, конечно, но все-таки. Вот. Вот. Есть несколько методов
решения рекуррентов. Ну, и нулевой метод – это мастер-теорема такая. Подробнее все про нее
написано в книге Формана в третьем издании. Прекрасные чти, во всем на ночь советую. 50
страниц в день и будете знать алгоритмы. Правда, не те, что мы проходим. Вот. Но полезно. Так,
теперь нормальный способ. Первый человеческий – это метод подстановки. Ну, в целом, казалось бы,
это почти единственный метод. Но есть еще один, который мы с вами посмотрим чуть позже. Это анализ
дерева рекурсия. Вот. Но мы его потом посмотрим, потому что у нас сегодня не будет алгоритмов,
которым он применим. В момент подстановки мы сейчас им решим эту рекурренту. Ну, давайте решать.
Ну, мы сделаем все очень просто. Мы возьмем и метод подстановки называется… Просто
просто возьмите и подставьте это же выражение сюда же. То есть проведите одну интерацию еще.
Так. Давайте так сделаем. Вот. Это лишняя скобка. То есть вот ваша единица осталась,
а эту превратили, будто бы вы здесь вместо L сделали замену переменных L пополам.
Логично. Сделаем K шагов. Ну, то есть на каждом шаге у вас будет как-то вот так-то выглядеть.
Вот. Ну, мы будем искренне верить, что для любого гамма меньше 1, t от гамма равно 0. Вот. Это у нас
будет такое требование, чтобы у нас была какая-то база, так сказать, нашей рекурсии. Чтобы не могли
долго спускаться. Ну, тогда давайте сделаем вот такое вот. Так. t от L поделить на 2 в степени
округленный верх логариф двуечный. Конечно, есть, потому что у вас здесь K шаг. K у вас не
констант. У вас K произвольный здесь. То есть, понятное дело, что если бы это был второй шаг,
у вас от единицы схлопнулось бы от единицы. Но, в общем-то, в случае у вас число шагов,
оно не константное. Оно зависит как функция от L. Поэтому мы не можем так просто взять и забить на
него. Вот. Плюс вот. Ну, понятное дело, что вот это вот число в скобках меньше 1. Согласны?
Ну, и двуечный логариф L округленный вверх. Значит, да, в этой штуке это хотя бы L. Значит,
здесь меньше, в общем, 1. Значит, мы по вот этому вот требованию говорим, что это 0. Просто-напросто.
Вот лог L. То есть, такой вот метод подстановки. Он просто берется, и вы делаете один шаг,
и понимаете примерно, как у вас будет меняться ваше рекуррентное соотношение. Дальше делаете
еще шаг. Ну, и так далее. То есть, вы видите общий вид изменения на катом шаге, и дальше из него уже
ка устремляете. Ну, не в бесконечность, когда у вас вот эта рекуррентная часть идет в 0. Подбираете
нужное ка и побеждаете. Да. Смотрите. Ну, действительно, если…
Это верное замечание очень. Давайте скажем так. Замечание. Правда ли вот это, что N2 равно O2 в степени N?
Ну, вот. То есть, как бы, понятное дело, что оценка O большим, она в некотором плане немножко
бессмысленна. Потому что она не дает вам никакой точности. Вот. Поэтому всегда старается выбрать
под O большим функцию как можно меньше. Вот. Ну, понятное дело, что если я скажу, что… Ну вот,
вот этого штука bin-поиск называлась, если что. Потому что бинарный вы делите пополам. Вот. Если я скажу,
что bin-поиск работает за O от L, то же правда. Вот. Но, скорее всего, от вас будет ждать нет ответа.
Смотрите, мы здесь немножко договариваемся, что у нас не может быть с двух сторон O. Вот. Потому
что… Что? Так нет, это вот… Это преобразование все T от L. У вас здесь-то нет O. Ну, грубо говоря,
у вас здесь есть запись без O слева. То есть это будто бы модификация одного и того же. Формально
мы никогда не будем писать вот так вот. Потому что, во-первых, это неправда просто-напросто. Потому
что мы искренне верим, что равенство все-таки в две стороны читается. Здесь в обе стороны неверно.
Вы можете сказать вот так вот. Вложенность поставить. И вот это уже будет правдой с одной
стороны. Вот. Но мы просто так никогда не делаем. Ну, потому что так сложилось. Мы не пишем с обеих
сторон O большие. Ну и на самом деле вот O от J от N это просто класс функций множества в некотором
плане. Поэтому здесь можно смело писать знак принадлежности. И вроде бы даже с точки зрения
формальной математики это будет вернее. Мы уже все привыкли здесь писать равенство, поэтому здесь
такая вот сумятица получается. Вот. Поэтому мы дабы избежать некорректных выражений не будем писать,
что Омега большое от чего-то равно O большое от чего-то. Потому что это просто бессмыслится. Мы
запрещаем себе такие выражения. Что еще раз? Ну, это прозрение.
Ну, это смотрите. Хорошо. Я пишу подробнее. Мы хотим, чтобы L поделить на 2 степени K оказалось
строго меньше единички. Потому что тогда у нас здесь вот эта вот штука пропадет. И только тогда. Мы
договорились, что только тогда она и пропадает. Ну, что мы тогда делаем? Мы просто берем и говорим.
Тогда K. Ну, что-то 2 степени K больше, чем L. K больше равно, чем логарифт натворичный L,
а углённый вверх. То есть мы решаем такое неравенство с вами, на самом деле.
Окей. Ну, тогда, если здесь вопросов больше нет, мы пойдем дальше, наверное. Так, давайте я вам
сразу же скажу, что в определении Омега большого я вам всем наврал. Но оно было здесь написано. Там
просто был вот знак другую сторону здесь. Я написал, что здесь для любого С больше нуля найдется. Но,
конечно, это неправда. Там вот в том углу были правы. Да, там тоже будут два канфра существует.
Пожалуйста, поправьте. Окей. Почти весь этот семестр посвящен структурам данных, как мы с вами
говорили. И большая часть у нас будет как бы две стороны этих структур данных. Одна будет работать,
мы будем идти к деревьям поисками, наверное. Вот вторая половина структур данных у нас будет
связана с обработкой запросов на подотресках. То есть нас будут, как правило, интересовать такие
издачи, как сумма на подотреске в массе, там минимум на подотреске и всякие другие их, как бы так
сказать, интересные есть. Собственно, нас будет, давайте, наверное, тогда
РМК и РСК. Вот у нас будут две задачи, которые нас будут волновать весь семестр. Это РМК и РСК я сейчас
все объясню, если что. Ну подсловка у них общая, есть масси, мы хотим что-то узнавать на подотреске.
Это range не query. Ну с английским не очень, поэтому может быть query надо по-другому произносить.
Вот. Это запрос минимума на подотреске.
И второе, это РСК будет нас интересовать. Ну давайте гении дедукции.
Какое здесь будет слово написано? Да, range сам query. Бла-бла-бла. Вот. У них есть несколько постановок.
Давайте сформулируем. Есть статик. Это массив не меняется.
То есть он как его дали, такой он и остается все время. Есть вариант динамик. Это изменения разрешены.
В чем-нибудь от самых разных видов. Вот. Есть еще два термина. Это онлайн. Если что, мы все это будем потом еще повторять.
Можно, скажем так, просто запомнить. Это временную память, чтобы понимать, что происходит.
Вот. Онлайн это запросы неизвестны заранее. Есть еще одна версия. Это из обновлайн. Это бла-бла-бла. Известны.
То есть вам известно все вопросы и это прекрасно. Можете там что-то сделать. Как там подсортировать. Отыть на них все в облегченном порядке и дальше вывести их в том, в котором вас спрашивали.
Обычно мы будем жить с онлайн задачами, ну потому что мир устроен так, что все у нас онлайн. 21 век.
И сегодня мы будем с вами решать вот такую вот задачу. Онлайн стать РСК. Вот это вот точно будет интересоваться с вами сегодня.
В статическом массиве отвечать на запросы ЭЛЕР, который переводит нас вот в такую вот штуку.
То есть он дает запрос ЭЛЕР и мы должны работать с его вещью. Вот это что мы будем сегодня учиться работать с этим.
Да, ну я думаю сразу можно догадаться, что если у вас есть решение для динамик задачи, то как бы есть решение для статика. Потому что статика это одно что динамик.
Аналогично с онлайн и оффлайн, если у вас есть решение для онлайн, то понятное дело и для оффлайн оно у вас есть.
То есть как бы здесь можно и оффлайн писать, но динамик здесь нельзя, динамик он не умеет менять массивы.
Ну что здесь предлагается сделать? Здесь предлагается сделать следующее, что давайте посчитаем вот такой вот массив.
Ведем массив в префиксах сумм.
Приопитый, это будет сумма вот такого вот вложения от миллиарда.
Ну давайте в один амбецапт будем жить.
Ну в массиве 1, 2, 3, 4, 5 это будет массив 1, 3, 6, 10, 15 тогда.
Вот, ну тогда что такое сумма по i от l до r?
Это же на самом деле что такое?
Давайте я напишу полностью эту сумму.
Согласны ли вы с этим утверждением?
Ну она вроде очевидна на самом деле.
Что мы как бы взяли сумму от начала до r и вычеркнули все лишнее.
Все, что здесь попало лишний хвост мы взяли и удалили.
Ну тогда можно сказать, что это равно.
Выпишем вот так.
Согласны ли вы с этим утверждением?
Ну просто схватили эту запись прекрасно.
Ну победа.
То есть мы с вами научились.
То есть если мы один раз почитали массив пред,
то тогда мы с вами научились отвечать на вот единицы на запрос.
Согласны?
Как считать массив пред?
Ну сделаем вот так вот.
Первый пред нулевой равный нулю.
И ты равно а и ты плюс пред и минус один.
Есть такое вот соотношение есть у него.
Ну вроде логично, да?
Вот так.
Тогда пред с помощью такого интересной процедуры у вас считается за линию.
Ну за линейное время от размера h.
Почему?
Ну на самом деле понятно.
Почему?
Потому что у вас здесь.
Короче говоря, да.
Вот здесь просто проходите каждый индекс массива пред,
он имеет размер h.
Вот.
И здесь у вас единицы.
Просто сложение.
Вот.
Ну поэтому дело, что вам этот пред надо где-то хранить.
То есть надо по идее эту память выделить, да?
По-хорошему.
То есть создать отдельно массивчик,
вот так вот его заполнить.
Ну на самом деле, по-хорошему,
вам не нужно это делать,
потому что вы можете писать прямо поверх массива a.
Почему нет?
Ну типа вам на момент подсчета ita момент,
вам прежние h не нужны.
Вам нужна только a ita,
которую вы будете сейчас перезаписывать.
Вот.
Вот.
И пред, и минус первый.
Вот.
Это у вас уже посчитанную записку.
То есть у вас даже корректно будет писать поверх массива a.
Вот этот массив пред.
Вау, круто, да?
Поэтому можно даже до памяти выделить на самом деле.
Массив статический, да.
Но ваш задача звучит так.
У вас есть массив pzn элементов
и q запросов к нему.
У вас есть пзн элементов,
и q запросов к нему.
Сумма на подотреске.
То есть как устроен сам массив,
вас не очень интересует, если честно.
Вас не просят его вернуть в исходном виде.
Хотя его можно вернуть
из массива pzn, сумму обратно построить,
на самом деле, как массив разности,
и просто последовать.
Но это нам не очень интересно.
И в самом деле я к тому, что здесь можно
до памяти выделять под массив pzn.
Но понятное дело, что в контесте у вас будут задачи на это,
и там можно везде выделять до памяти,
то есть банально проще жить с этим всем.
Вот.
Но, так сказать, просто для вашего сведения,
что можно пересписывать его.
Вот.
Тогда ответный запрос
зовут единица, да?
Вот. И все-таки решение...
Мы будем обозначать разные
решения вот этих вот задачей в родской рамку
таким вот образом, что
будем говорить, что это какая-то вот такая вот пара
где вот это вот это время построения вашей
вспомогательной штуки для ответных запросов,
а вот это время ответа на запрос в мощи нее.
То есть мы за o от n построили массив
пред, а дальше
на один запрос ответили за от единицы
просто вычитанием двух значений в массиве.
Ну, разностью.
Пара
время
построения
плюс время
запроса.
Ну,
вопрос в студию
можно ли
так считать минимума под отрезки?
Ну, почему нет?
Ну, давайте кто-нибудь.
И что?
Ну, понятно, что
ну, может как-то это можно там...
Ну, да, минимум действительно не получится.
Хорошо. Какое требование, в общем, на операцию
мы можем наложить, чтобы получилось?
Можно же не только сумму
считать на отрезки, я не знаю там, ну...
Вдруг нам захочется побитого i
посчитать на отрезки?
Вдруг нам захочется чем-то?
Обратимость?
Да, мы хотели, ну,
посчитать на отрезки.
Ну, да.
Да, мы хотели обратимость,
во-первых.
Да и в главных, в общем-то.
Это первое, что мы хотим обратимость,
мы хотим иметь обратную операцию.
Ну, то есть, там, если кто-то там знаком стал
неправильно в школе,
например, у вас группа, там, это
множество, где у вас есть ассоциативная
и бинарная операция,
то, конечно, там есть обратные элементы.
Вот.
Мы как бы хотим уметь обращать элементы,
чтобы
у вас был минимум минус.
С минимумом так не получится.
У вас минимум необратим.
Ну, под обратимостью есть подразумевание следующее.
Что у вас для любых
А, Б,
решение
уравнения
минимум
под АХ равно
Б,
единственно.
Вот тогда мы считаем,
что минимум обратим,
уравнение разрешается единственным образом.
Ну, вместо минимума всегда поставьте произвольную F,
вы получите объявление обратимым.
Функции в нашем конкретном курсе.
Но это неправда.
Неправда.
Поэтому минимум не обратим.
Вот. Ну, еще что мы хотим делать?
Мы хотим иметь ассоциативность все-таки.
Ассоциативность,
как скобочки не расстреляют,
в результате не тот же.
Все-таки нам здесь стало важно,
когда мы это делаем.
Ну, и, наверное,
не знаю, какую-нибудь коммунативность,
наверное, тоже хотелось бы.
Или нет?
Вроде не обязательно.
Ну, вроде нет, действительно,
мы все считаем здесь,
короче говоря, от большего индекса в единицу,
вроде бы можно без коммунативности обойтись.
Но обычно она всегда будет присутствовать.
Придумать ассоциативную,
некоммунативную аккорацию сложно.
Но один из примеров
это умножение матрицы.
Она ассоциативна, но некоммунативна.
И внезапно не всегда обратим.
У вас уже была первая пара по линаву,
по аналитам.
Те, кто уже был в курсе,
вы знаете, что есть выраженная матрица
и с ними уравнение не всегда
в разрешении.
Ну что тогда?
У нас до конца пары.
Получается еще 15 минут.
15 минут.
Ну окей,
посмотрите, что мы разобрались, ты молодец.
Ну, окей,
какие еще операции обратимы?
Ну, операция умножить, она обратима,
пока вы не пытаетесь делить на ноль.
Поэтому нули придется отдельно
ифать.
Здесь никак не будет так.
Что еще?
Ну, ладно.
Примеры обратимых операций сам придумайте.
Ну, либо в домашних встретите.
А, ну вот, кстати,
давайте разберем такую задачу.
Вот у вас есть массив АИП.
Это фродская лир.
Хотим вернуть следующую.
Ну, знаете, что такое средне-гармоническая, да?
Ну, казалось бы, у вас вообще нигде встречи не может.
Вообще нигде.
Ну, пример такой.
Ну, все-таки вы в тучбольной физике когда-то знали,
вы вроде не знаете.
Когда-то вы уже знали, все.
Наверное.
Значит мы все, наверно.
Ну, давайте посмотрим.
Ну, вот,
ну, вот,
вот,
ну, вот,
Наверное, значит, мы сегодня, наверное, спустили бы.
Вот, и у вас там, если автомобиль едет...
Как считать среднюю скорость у автомобиля?
Если он проезжает равные промежутки пути просто разными скоростями.
V1, V2, и ты дали там V.
Раскал паса.
Вот, побито.
S, S, S, S.
V1, V2, V3, V4.
Как вы считаете среднюю скорость?
Да, V4, S.
V9, S9, V1.
На V.
На S.
Ну, давайте на это все пробить.
Если у вас там хотите выгонять что-то среднее,
вот, просто на каком-то подотреске,
ну, например, не знаю, у вас там испытание нового двигателя идет,
вот, и вы хотите узнать, какая у него там была зрения скорость на таком-то отрезке.
Вот, тогда вы можете принять этот вот запрос, быстро обрабатывать это.
Ну, не знаю, зачем-то вам это пригодилось.
Вот, это минимальная жизнеспособная легенда, какая-то задача.
Вот.
Вверху.
Что?
Возможно, я не помню.
Ну, может быть, это неважно.
Ну, давайте A.
Вот так вот.
Ну, умножить на число, это меньшее из проблем, скажем так,
которые мы можем встретить в этой задачи.
Вот.
Ну, какое здесь решение?
Ну, решение, давайте перейдем к массиву обратно.
То есть вместо A, будем писать 1 делить на A и везде.
Да?
То есть мы...
A1.
А я?
Переведем A1.
Вот.
Тогда ответом будет на запрос или...
Возьмем прегрессные суммы на вот таком вот уже массиве, возьмем, да?
Тогда мы получим знаменатель.
Эту формулу.
Ну, и вернем 1 делить на эту штуку.
Ну, умножить еще на эту коэффициент.
То есть за эту единицу тоже можно обрабатывать.
То есть, на самом деле, операции типа среднего гармонического
внезапно, вообще-то, проходят.
Хотя, оказалось бы, они немножко необратимы.
Не понятно вообще, что такое обратимость для среднего гармонического.
Понятно, но...
Что-то типа такого.
Ну, откуда можно выразить, верно?
Значит, пить, да, но...
Так не очевидно.
Можно еще раз? Почему минимум был необратим у нас?
Давайте решим уравнение.
Их все равно 4, их все равно 5, и так далее подходят.
То есть у вас решение единственное.
Поэтому вас меня не обратили.
Ну, окей.
Ну, давайте начнем, когда тема следующей векции.
А именно, у нас с вами такая будет сейчас...
Ну, в следующей векции не страшно.
Нужно будет такое отступление,
назовем это в некотором бане,
данье уважения классическим курсам по алгоритму.
Вот.
Утверждение на контейнеры.
Вот, нас будет рисовать
следующие штуки
в списке
односвязанным
и несвязанным.
Дальше нас будет рисовать
степ,
очередь
и деп.
Вот, нас будут рисовать такие вот контейнеры.
Ну, давайте, наверное, поговорим
про списки,
про это трио поговорим в следующий раз.
Ну, сколько успеем, столько успеем.
Так сказать,
больше успеем сегодня,
больше успеем в семестре.
Значит, больше будет экзамен.
И больше домашний.
Ну, вот мне институты уже пересылали сообщение
из чата в групп, что спрашивают, когда
уже домашние будут.
Вот, так что я
вчера напрягся
и все-таки доделал контест первым
и первый теоретический домашний был уже в субботу
в чате.
Да, там деплайны, там сроки выполнены
в две недели примерно на каждую неделю.
Вот, ну, возможно, у вас
не будет перерывов перед
вторым домашним заданием, потому что
потому что лучше
сейчас сделать как можно больше, чем в декабре
страдать, потому что в декабре
и так будет много предметов, которые займут ваше
место в сердечке.
Вот, например,
домашний по мотану третья
и я думаю, что тогда
контестом будет не очень нравится
дополнительный, тем более там
тема будет достаточно тяжелая,
а не вот то, что в первом контесте.
Потому что в первый контест, скорее всего, вам сядете
и за пару тройку вечеров зарешаете, потому что
он легкий.
Это так чисто, чтобы вас расслабить, вот, а потом
да.
А ограничения по времени на контесте нет?
Конечно, есть.
Это не то, чтобы вы типа сели
и у вас ровно три часа чтобы решить. Нет, такого нет.
У вас как бы есть у всех
общий финишный флажок.
Вот там, по-моему,
во вторник через две недели, 23.59.
Вот.
Мы можете начать хоть в 10.30 утра
контест откроется.
Сегодня, да. Мы можете хоть
в 10.30. Ладно, нет, это будет плохо, что на записи
останется не ходить на пары следующие. Вот.
Ходите на них, а потом вот после пар
открыть контест, вот.
И начать его решать. Хоть все две недели
обрешайтесь. Ладно, на пары ходите.
Можно на мои только ходить.
И на фюру.
Штрафы за посылки есть вообще? Нет.
А, кстати,
небольшое нововведение.
Вот, вы могли слышать от старших
курсов, что
существуют всякие архивы на
Водхабе, на Гитлабе с решениями.
Вот. Пишу вас расстроить.
Во-первых, половина, значит,
поменена с прошлого года. Вы
сказать не очень сможете. Во-вторых, поменена
легенда почти вся. Поэтому
искать будет труднее.
Третьих и самых
главных, мы наконец-то,
ну как наконец-то?
Я уже давно так делал. Вот. Наконец-то
удалось, ну, говори Степанова и
Илью Даниловича, электра в основном потоке,
что мы перейдем все
на Яндекс.Контест, решать Контест,
потому что можно настроить код стайл автоматически
при отправке.
Вот. Поэтому вы будете отсылывать
код. Вам тестирующая система будет говорить,
что вы крайне неправы и что ваш код крайне
далек от идеала, назовем это так.
Но она будет говорить, где ваши ошибки
и будет выдавать ошибку компиляции вам
вердикт. Если вы
потратите на первую задачу посылок 30,
чтобы заслать, это не страшно.
Да, еще будут включены
санитайзеры. Санитайзеры
это такая штука, которая внезапно
проверяет, как вы обращаетесь с памятью.
То есть,
если вы выделим осип и пошли за его
границы, она скажет вам, что вы
неправы и выдаст вам ошибку
исполнения.
Круто? Чего вы не улыбаетесь?
Круто. А насколько хорош
эта проверка
код стайла? Ну, она просто
идет. Ну, типа там включена одна
настройка. Делает как в Гугле.
Но она проверяет прям вплоть до
правил названия перемена.
Вплоть до того, чтобы ты в приватных полях в строек ставил нижние подчерки.
И чтобы у тебя
константы с буквы K маленькие начинают.
Ура.
Но вам семинаристы подробнее
про это расскажут.
Сегодня вечером, если у вас будет
желание, вы можете заслать
первую задачу, Леха,
и обнаружить, что
она не сдается.
Я утверждаю,
что за конечное число этой рации вы ее сдадите.
Зададите все.
Может быть, что эта рация будет большим.
Если у вас закончится предел стой-то рации,
вы напишите в чат, я до тысячи подниму.
Думаю,
тысячи вам точно хватит.
Вы недооцениваете.
Не, я, конечно, понимаю, что могу вас недооценивать.
Я тогда просто ограничу время, чтобы вы не могли
дудосить эту систему.
Раз в десять секунд хотя бы
слать.
Оставлю сток посылок, чтобы, типа,
если вы будете непрерывно слать посылки,
чтобы вы не могли исчерпать лимит.
Но вы не доводите до такого, пожалуйста.
Будут введены какие-нибудь санкции
таким людям.
Так, окей. Смотрите.
Да, еще
в ведомости вы могли...
У нас 35 минут. Я решил,
что мне лень рассказывать про то.
Буду на следующей неделе рассказывать.
Расскажу дальше про моменты еще.
Ведомости у вас, да, может стратки сворачивать.
Ведомости у вас некоторые задачи отмечены
простеньким. Это задача с ревью
для семинариста или ассистента.
Вот.
Это значит, что они будут реально проверить
ваш код и смотреть, чтобы вы,
типа, код стайлу все сделали,
но все-таки ваш код можно читать.
Сразу скажу,
что код вот такого вот вида
не пройдет проверку
код стайла. Ну, в принципе, проверку
в ревью не пройдет.
А как правильно?
Во-первых, нужно разные строки разносить.
Во-вторых, непонятно, что тут A, что тут B.
Вы должны конкретно прописывать полностью
словами. Например,
их,
даже если в условии,
они
названы в условии сокращенно,
просто чтобы
была как бы проведена связь между легендой
и входным форматом.
Только для этого их так называются.
Как же?
Потому что у вас, ну, по-моему, я не помню,
расшатан или нет, просто требования
такой косметической гугля.
Ну, потому что, как бы, когда ты читаешь так,
ты будто бы
не замечаешь запятую, продолжаешь дальше
читать одно и то же имя. А так у тебя четко
разделены все сущности.
Вот. Я
надеюсь, я вас обрадовал под конец
лекции.
Вот. Тем, кто
хотел все еще с базы
перейти в основу, я все-таки советую
подумать. У вас таких новостей?
