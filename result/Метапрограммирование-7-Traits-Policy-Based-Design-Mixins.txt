Давайте начинать продолжать, поговорим про дизайн.
Есть все вот эти вот паттерны дизайна оу пешные, про которые
мы говорим, вспоминаем постоянно, а есть чисто вот
в шаблонах, из них так как-то получилось, что вытекло
несколько тоже таких, то ли шаблонов, то ли чего-то
такого.
Короче, техника, которую все постоянно используют,
их говорят, но иногда не очень правильно терминно
используют, и путаница начинается, но в общем
что-то вроде с rtp, такие модные слова, которые в шаблонном
мире постоянно вы будете слышать.
Давайте про них говорить, примерчик сразу, мы сделали
функцию копия, вот стандарта такая есть, она копирует
из одного какого-то контейнера данные, в какой-то другой,
ну из вектора в вектор перекладывает.
Давайте представим, что у нас на платформе есть
какая-то волшебная функция bitblast, superspeedy bitblast, которая
умеет какие-то примитивные типы данных копировать
со скоростью света просто, ну и мы хотим соответственно
проверить, если у нас в контейнере на самом деле
лежат кинькинты или что-нибудь подобное, то использовать
супер быструю функцию, иначе ручками цикл, идти, копировать,
как бы выхода нет.
Ну очень быстро окажется, что там еще нужно добавлять
условия tif, там entable и float, погнали-погнали, неудобно,
как решить эту проблему, неудобство, что вот надо
просто вписывать сюда, какой концепт, ну а как расширять,
просто в другое место вписывать надо будет в одно и то же.
Хочется, чтобы не было одного места, куда нужно все вписывать,
как-то децентрализовать.
По сайзову можно поменять, да, хочется помечать типа,
но тоже это будет централизованное место.
Можно сделать концепт в духе hesmet и написать отдельное
название метода.
А, даже не так, можно просто завести класс, который говорит,
что он совместим с суперскими библиотеклассами и наследоваться
от него тем, кто...
Так, как ты будешь int наследоваться от чего-то?
Как ты будешь int наследоваться от чего-то?
Как мы будем...
Вот есть такая еще идея, да, можно внутри...
Надо о специализации спрашивать.
Вот.
Ну тупая идея, можно прямо внутри класса писать
какой-нибудь флажок.
Ну, compile-time флажок, типа struct, yes, you can beatblast me и
прям точка с запятой.
То есть с этим типом внутри класса какого-то ничего
нельзя сделать, кроме как проверить, что он там написан
или не написан.
Вот это как бы такая пометка.
Можно или нельзя.
В NT ее не пихнуть, в Bly не пихнуть.
Поэтому мы делаем вот так, как сказал Аркадий примерно.
Мы делаем трейты, так называемые.
Трейты – это такой шаблон для некоторого семейства
типов, которые описывают конкретные типы в этом семействе,
какие-то их свойства.
В данном случае мы делаем некоторые трейты для алгоритма
копия и там позволяем конкретным типам в специализациях
вписывать свойства.
Вот int пометили, что beatblastable true.
Можно еще какие-то другие типы пометить, даже которыми
вы не владеете.
То есть если бы вот этот вот flag beatblastable true-false вы
просили писать прямо внутри типа, то с int вы бы не смогли
работать.
А так можете.
Или какими-то чужими классами чай-код вам запрещено менять.
Но вы все равно их хотите beatblastить, вот так можно.
Можно так, да, ну тут по-разному можно.
Идея одна, что вот в таких трейт-объектах можно кучу
разных свойств написать, compile-type-свойств типов.
Можно какие-то связанные с ними типы, например signed
type какой-нибудь или что-нибудь такое.
Можно вот boolean или там int.
Да?
Я просто думаю, если мы, ну допустим, мы хотим завести
какой-то трейд, который у нас, который мы хотим
наставить только для типа под нашим контролем.
То есть, во-первых, не какие-то встроенные типы интопы,
а не какие-то чужие, которые нельзя трогать.
Вот не лучше ли все-таки сказать, что трейд это конце?
Сейчас будем, давай, ты вот слишком глубокие вопросы
слишком рано задаешь.
Надо такой сложный вопрос под конец раздела про трейты
задать.
Потому что сейчас про концепты мы еще чуть-чуть поговорим.
Собственно, да, использовать это так.
Заметьте, type-name здесь не написан и работает дефолт
как раз, который нам обычно не нужен, а тут ровно он и
нужен.
Что тип два двуи точа что-то это переменная.
Ну и вот, теперь можно дописывать кого можно битбластить
вообще где угодно в коде и это будет работать.
А вот еще раз мы эти копии трейд под каждый тип пишем?
Не под каждый, есть дефолтная.
Под каждый, который да, мы можем специализировать,
если хотим.
Есть какие-то разумные дефолты.
Ну, бывают, конечно, ситуации, когда по дефолту трейд
вообще не должен быть определен для вашего типа.
Например, итератор трейдс.
Итератор трейдс от какого-то рандомного типа вроде void
просто void.
Не должен быть определен, но он и не определен.
Вот, а когда разумно, в принципе, для всего дел
дефолт, то вот он можно сделать.
И еще раз, если вернемся назад, у нас вот копия трейса
бинта true от bool, true от size 3, true…
Да, руками вписываем.
Если хочется для целого другого семейства, то можно
тут еще через концепт частичную специализацию сделать.
Ну, короче, все шаблонные трюки работают.
Ну и вот, тут такая цитатка из книжки, что такое в целом
трейд, в классическом их понимании, что это некоторый
уровень индирекции, выносящий принятие решения о конкретных
типов куда-то туда, из текущего контекста.
Вот, кстати, название книжки, в репетитории ссылка есть,
ну, вернее, название, мы тут не пиратим, правда.
Ну, найдете.
Там много чего полезного.
Ну, тут еще вопросы к этому алгоритму на самом деле
остаются копия, да, но от всякого банального, которое,
я думаю, тоже понятно, как решить, да, вот первые
два пункта про последовательность контейнера и там вектор
bool off тоже через какие-то трейты того же самого итератора
оно решается.
Ну, знаете, почему вектор bool off сложнее с ним писать
алгоритмы обобщенные, да, там разыменование итератора
возвращает не конкретно bool, а какая-то оберточка дурацкая,
вот там можно немножко наесться, да, когда поставишь
bitblastable для bool true, пихнешь вектор bool off и ничего работать
не будет.
Повезет, если ошибка компиляции, если нет, то просто все
скрашится.
Вот есть чуть менее тривиальные проблемы, что first result могут
на самом деле разные типы иметь, там конвертации
всякие происходят, хотим мы этого, не хотим, хороший
вопрос, можно ли просто так bitblastить разные типы
друг в друга, ну тоже как-то надо это учесть, правда,
если мы на самом деле хотим перекопировать контейнер
int в контейнер float, сделав конверсию, а мы запустим
bitblast, то мы как бы побитого скопируем int как float и работа
ничего не будет, да, такие вещи надо учитывать.
И вот нужда в новых ифах, если у нас еще какие-то
способы есть для конкретных контейнеров или конкретных
случаев, делать алгоритм копирования быстрее, что-то
в прошлый раз было про то, как это сделать, никто
не запомнил.
Или?
И еще раз, чем это?
Мы написали if прямо в алгоритме копирования, для чего мы
его сделали?
Чтобы ускорить для каких-то конкретных специализаций
этот алгоритм, у нас всегда есть общий алгоритм, он
всегда работает, но он не всегда оптимальный, поэтому
для конкретной специализации мы говорим, нет, будем такое
использовать, что если есть еще куча разных частных
кейсов, где для конкретной специализации можно алгоритм
по-другому реализовать, он будет быстрее работать.
СВОП вспомнил, это правильное направление, что там было?
Там была такая аббревиатура ADL, так же как мы СВОП кастомизировали
для разных штук, так же и всякие копии предполагается,
но это дико неудобно и вообще надо это все обернуть в
10 слоев шаблонов, чтобы было удобно, а как это делать
мы только в конце курса будем узнавать, потому что
это убойная тема и не особо кому нужная, поэтому она
на задворке запихана, а может и вообще выкинем.
Первые две проблемы просто через этот итератор трейдс
на самом деле решаются, и для решения вот этой последней
проблемы есть пропузл, собственно эта проблема возникла очень
ярко в STD ranges, но там ее обхачили, натуральные хаки
включили, и подробнее об этом в следующих сериях,
и в STD execution тоже возникла такая же абсолютно проблема
и там уже ее так хорошо обхачивать не получалось,
пришлось хачить с удвоенной силой, удестеренной, и
все-таки получилось, но результат не блойды и точки
кастомизации.
Точки кастомизации в этом теген вуке?
Теген вуке они тоже, вот в ranges были не блойды, точки
кастомизации, а в execution запихали теген вук, и в общем
все это лютая дичь, невозможно читать, невозможно в этом
разобраться, вот возможно мы разберемся, но когда
ты свой хочешь кастомизацию сделать для этого копии,
ты хочешь свой контейнер, ты хочешь для него кастомизировать,
тебе придется разбираться в том, как оно работает,
и там подыхаешь, поэтому есть пропозл, выкинуть все
эти костыли и хаки нафиг и сделать на уровне языка
прям инструмент, чтобы можно было кастомизировать
специализации откуда угодно, аккуратным образом, без
конфликтов всяких имен, проблем с линковкой, аби и прочего-прочего,
то есть просто руками написать специализацию, это проблематично,
специализировать шаблоны из стандартной библиотеки
по умолчанию нельзя, если не оговорено иного, и там
вот какие-то проблемы есть, давайте о них пока не говорить.
Вот, идем дальше, взаимодействие с концептами вот этого всего,
ну вот там был концепт-этератор, да и в принципе тогда есть
концепт-этератор, но если мы его захотим написать,
то возможно мы что-то такое сделаем, да, понятно, что написано,
мы требуем, чтобы было бульевое поле contiguous у класса-этератора,
которое нам говорит, можно ли его просто мем-копию
взять и перекопировать или нет, ну то есть подряд
ли в памяти идут необходимые элементы, ну это чтобы был
какой-то tap name, value type, чтобы как раз по нему понять,
а не proxy ли там у нас и вот это все, ну то есть какой-то такой
концепт мы можем завести, но он будет плохой, почему?
Вот такой концепт утверждается, что очень плохой, какой-то
очень частый кейс, который в миллионе код бас просто
каждый день используется, что, указатели, да, указатели
тоже-этераторы, первая домашка должна была этого научить,
то есть здесь, конечно, если вы указатели, попытаетесь
найти какую-то переменную внутри, ничего не выйдет,
поэтому так не делают, да, и в целом всякие тривиальные
типы, указатели, а еще типы, которыми вы не владеете
и не можете их заставить соблюдать контракт, что
вот написано вот такие вот названия внутри, может
них по-другому просто, ну код стайл другой, с маленькой
буквы пишут, а у вас с большой, вот во всех таких случаях
просто так делать максимально тупо, да, за этим у нас есть
трейты, давайте на примере STD это посмотрим, в STD есть
итератор trades, ну и тут сразу видно, что итератор trades
для т-звездочки переопределен, потому что мы говорим, что
как бы указатель тоже-этератор, ну и внутри трейта для итератора
есть вот такие типы, я думаю, вы их уже успели повидать,
вы писали slice, а дальше есть концепты, целая стопка
концептов разных, ну они как бы были и раньше, только
они не были концепциями, это были именованные требования,
кто-нибудь сможет напомнить, что такое input итератор,
что он умеет, пройтись только один раз, да, пройтись только
один раз и что писать, читать, что можно, да, вот input итератор
можно читать, причем каждый раз прочитать можно только
один раз и потом заинкрементить, по-моему как-то так, ну output
итератор тоже самое симметрично, только писать и двигать
вперед, forward итератор, да, только вперед, ну bidirectional
из названия понятно, тоже самое, но еще есть назад,
так random access, да, причем за сколько?
Регулярность, что значит регулярность, что это значит, ну возможно,
я в таких вопросах не силен, если честно, где в стандарте
требуется регуляр, а где не требуется, скорее всего
требуется, да, что там output, input итератора копировать
нельзя, конечно же, да, что это значит, начиная с forward
там скорее всего всякая копируемость требуется,
да, random access за от единицы можно двигать, наверное,
элементов в любую сторону и contiguous о чем говорит?
Да, окей, все это помним, ну давайте, что?
Forward копировать это очень плохая идея, forward итератор копировать
почему?
Так, это единственный способ, что-то полезное сделать
с forward итераторами на самом деле, кажется, что, ну потому
что ты копируешь его, копию двигаешь куда-то, у тебя
остался старый, ты доволен, нет?
Ну не факт, надо, конечно, конкретные концепты смотреть,
какие сейчас поставили там, давайте один из них посмотрим,
ну вот предварительный концепт дурацкий, input or output итератор,
требуется, чтобы можно было разыминовать и что-то
референсабл получить, ну я думаю понятно, что что-то
типа ссылку вернуть вглубь не идем сегодня, и weekly incrementable,
но incrementable что значит?
Можно инкремитировать, можно инкремитировать, почему
weekly?
Только с одной стороны?
Нет.
Нет, по-моему, там в том числе, нет, да, конечно, этот
incrementable говорит про plus plus, который префиксный,
почему weekly?
Что это слово значит?
Ну типа не факт, что сдвиген, ну у нас же были две недели
назад, по-моему, всякие концепты, где было слово weekly, оно
конкретный смысл имело в стандарте.
Ну там ордер, да, что там слово weekly означало?
В week-ордере.
Иquality.
Ну вот что-то, да, что-то про семантику, сейчас вот.
Иquality preservation нету.
Ну почему на input и output итераторах не требуют equality preservation,
когда делают increment?
Ну да, они вообще одноразовые, как вы там что-то будете
одинаковые два создавать и потом их сравнивать?
Ну окей, взяли стрим, читаем с него, да, input итератором,
создали два одинаковых input итератора, прочитали
одним по incrementale, прочитали другим по incrementale, будут
ли они равны?
Нет уже.
Нет уже, потому что как бы, ну вот результаты, которые
вы прочитаете, они будут разные, вот эти вот операции
там incrementa и чтения, они не сохраняют equality, поэтому
вот тут как раз одно из тех мест, когда явно оговорено
и понятно почему equality не соблюдается, потому что
там input и input итератор, они с внешним миром взаимодействуют,
результат там может быть разный.
То есть они будут равны, но это не значит, что они
равны, что при этом они будут не равны?
Ну ты создал два input и input итератора, изначально
они равны, да?
Значит, после любой последовательности операций, дозволенных,
тоже должны остаться равны значениям.
Например, в прошлый витфли и ордеринге было тоже equality
непризвестно, когда у нас пары, мы сравниваем только
по первому элементу.
То есть все раз отличается, а первые одинаковые.
Он нас вернул, что они равны, но по факту они не равны.
Да.
Но тут вопрос был, если два итератора, которые мы
один сдвинули, второй сдвинули, ну плюс-плюс сделали,
сравним, он выдаст трубку?
Ну вообще, по-моему, никогда для input итераторов не делают
оператор равенства, поэтому, да, банально некорректен
вопрос equality preservation.
А почему викли, если там у нас нет?
Потому что если ты требуешь equality preservation, то ты автоматом
требуешь как бы неявно, чтобы equality был определен,
да?
Да.
Тут не требуется equality, чтобы был определен для них,
поэтому викли.
А тут викли просто неопределен.
Да, и это, и даже если бы вы попытались определить,
у вас бы все равно не получилось достичь equality preservation,
да?
Пример.
Создали два input итератора на поток.
Что значит equality preservation?
Любое выражение от них, вот одного вычислили,
от другого вычислили, должно одно и то же получиться
в результате.
Давайте от одного там разоминуем его по инкрементам,
потом второе разоминуем по инкрементам.
Ну понятно, что мы разные вещи прочитаем, и не будут
равные вещи, которые мы прочитали.
Да?
Ну там вот такие проблемы возникают из-за взаимодействия
с внешним миром.
Мы не знаем, что нам там выдадут, и вот эти все вопросы
equality preservation здесь бессмысленные.
Поэтому...
Окей, ладно, давайте вот это вот...
Не так важно сейчас, надо успеть все остальное.
Концепт input итератор.
Вот здесь как раз используется input-output-iterator.
Некоторое indirectly readable есть.
Но не особо важно, что это.
Окей, можно понять, что это вот что-то про то,
что разыминовываешь, и получается что-то хорошее.
Ну, не важно.
Меня больше интересует вот это вот красное,
iter-concept.
Вот это как раз про понимание того, что за итератор перед нами.
Тут требуют, чтобы был определен некоторый
iter-concept, который вообще непонятно что пока.
И чтобы он наследовал input-iterator-tag.
Итератор теги, вы помните что-нибудь?
Они друг на друга наследуют и просто обозначают,
насколько силен наш итератор.
Вот в итераторах надо явно указывать, что мы итератор.
То есть какой-то рандомный тип просто никогда не должен...
Любой тип взяли, попытались запихать в вот этот концепт.
Он никогда не пройдет этот концепт как раз из-за
предпоследнего требования.
Нужна явная пометка.
Да, я итератор, вот у меня есть тег.
Вопрос только, где эта пометка ставится
и что это за итер-концепт.
Внимание на икра.
Что?
Для legacy?
Да, ты абсолютно прав.
Потому что итер-концепт нужен зачем?
Определим итер-trades.
Итер-trades это как бы итератор-trades, но не совсем.
Если у нас специализирован итератор-trades,
то мы используем эту специализацию.
Если нет, то мы используем сам итератор.
И прямо внутри самого итератора будем искать
всякие наши типы, интересующие нас.
Тут уже начинаются такие выкрутасы.
И дальше этот итер-концепт определяется
как либо там итератор-trades, итератор-концепт,
если он есть, если его нет,
итератор-trades, итератор-category.
Если есть, а если нет, то там еще какие-то правила.
Сложные правила для поддержания legacy.
Но мораль в чем?
В концепте мы не напрямую идем в тип,
а идем через trades на самом деле.
И вам я тоже рекомендую так делать.
Конечно, зависит от ситуации.
Но в целом, если вы вводите какую-то новую абстракцию,
которая для вашего кода столь же фундаментально
как итератор для алгоритмов,
лучше бы иметь не только концепт,
но и трейты для спецификации всяких деталей.
И вот не в концепте требовать, чтобы было,
как я вот здесь написал, какой-то value-type,
чтобы через... пока.
Чтобы через трейты мы прошли,
и вот в трейте уже нашли value-type.
Вот.
Давайте еще просто примеры посмотрим,
где эти трейты бывают.
Вот такая фигня есть.
Видели ее когда-нибудь?
Вот я тоже когда составлял эти слайды,
увидел ее первый раз, но она есть.
Это трейты для всяких умных поинтеров.
Ну и для обычного поинтера тоже.
Тут, например, есть нормальная функция toAdress.
Ладно, это...
Не будем про это.
Из зумного указателя вытащить указатель.
Ну я не уверен, что это как бы,
что итераторы удовлетворяют поинтер трейтсам,
а может и удовлетворяют...
Не знаю.
Но это уже какая-то такая арканная магия, да?
Вот сколько лет вы программируете на плюсах,
про такие трейты не слышали, они, оказывается, есть.
И вот там всякие приколы типа.
Pointer2.
Ребинда.
Ну да, еще есть такие штуки.
Ну, в общем, есть такое.
Есть chart trades.
Об этом вы точно не слышали.
Слышал?
Ты что, с Unicode'ом работаешь?
На плюсах?
Нет.
Нет?
Ну зачем тебе это тогда?
Дальше почти.
Ну, я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Ну, зачем тебе это тогда?
Дальше почти.
Почти.
Почти слышал, а не почти работаешь?
Почти Unicode.
Почти Unicode.
Ну, короче, это вот одна из темных частей стандарта.
Мы не умеем Unicode, мы не умеем строки, мы ничего не умеем,
но какие-то там chart trades у нас есть,
и они там говорят всякие типы разные, интересные.
Ну, вот как понимать, вот эти три типа.
Off-type, post-type, state-type, implementation-defined.
Что это?
Зачем это?
Не используете.
Да, я так и живу в своей жизни.
В принципе, мне все хорошо.
Есть что локатер трейдсы?
То есть какие-то фундаментальные концепции, которые есть в стандарте,
для них есть трейды, чтобы понимать про них всякие разные интересные факты.
Про конкретные классы, которые удовлетворяют этим абстрактным концептам,
понимать интересные вещи, при этом не накладывая строгих ограничений
на то, как эти сами классы выглядят, чтобы у вас там указатель мог быть итератором.
Вот.
Или какая-нибудь legacy могла там быть обернута через трейды
и стать нормальным этим.
Одна только деталь.
По-моему, локатер трейдс с каких-то там плюсов нельзя специализировать теперь.
Вот.
Так что не получится ваш legacy-локатер затолкать в стандартный интерфейс.
Но...
А он разве не будет просто сам defining мета?
Там не знаю, что происходило.
Сломаться страшно.
Что-то там, короче, какие-то телодвижения в комитете есть.
Давайте не будем про это.
Итог про трейты.
Это точки кастомизации с свойстью типов.
Какие-то вот property на уровне типов.
С концептами они прекрасно дружат.
Они друг друга не заменяют.
Они просто артагональные.
Разные функции выполняют.
И еще такая мысль, что это не проповедение.
Какие-то функции определять в трейтах.
Это как бы в типах трейтах.
Это как бы не очень кошерно.
Считается, что вот чуть по-другому надо это делать.
Ну, по крайней мере, согласно книжке Modern C++ Design.
И не только ей.
Может, это в Underworld вычитал.
Короче, сейчас будет еще одна шняга, которая покажется похожей.
Но на самом деле нет.
И вот она уже про поведение.
Будет или нет?
У нас осталось пять минут.
Попытаемся чуть-чуть затронуть.
Да?
Есть такая часть, плюс как инвалидация итератора.
Да.
И референс тоже.
И разные трейнеры, они по-разному дают гарантии,
не дала будет инвалидации или не будет инвалидации.
И вот у меня вопрос.
Почему эти гарантии не засунули в трейдах?
Почему нельзя спросить...
В смысле?
Спросить, инвалидирует ли конкретный метод итератор.
Ну, например?
Когда тебе это нужно?
Что?
Ну, смотрите, трейды нужны, когда вы пишете обобщенный код.
Да?
Когда вы должны работать с любым чем-то.
Как часто ты пишешь код, обобщенный по контейнерам?
Я, если честно, никогда.
Зачем?
Какой use case этого?
Сделать мэп, но у которого есть метод возвращающий ключ максимального значения.
Хорошо.
Ты наследуешь какой-то мэп.
Ключ максимального значения, что ты там...
Ну, в смысле, end типа или...
Нет.
Ну, back, front.
Нет.
Front и back это максимальный и минимальный ключ.
А мне нужен ключ максимального значения.
Ну, а зачем тебе обобщенный контейнер?
Потому что он в нескольких местах в коде используется.
Что?
Ну нет, ты конкретный контейнер берешь, конкретный шаблон мапа.
И вот его используешь, правда?
Ты же знаешь, какие у него методы, что инвалидирует и что...
Это понятно.
Ну, все.
Поэтому просто не возникает use case, когда у вас код обобщен именно по...
По значениям.
По значениям.
По значениям.
По значениям.
Не возникает use case, когда у вас код обобщен именно по...
Не специализации шаблона контейнера,
а по самому шаблону контейнера.
Потому что нужно для каждого контента чуть-чуть проверять.
Ну да, еще непонятно, какой API...
А если мы знаем API контейнера,
мы, скорее всего, знаем контейнер.
Да, и тут просто не сложилось на уровне концептуальном.
Такого кода не бывает.
Поэтому нужды в этом нет.
Мне кажется, так.
Но если у тебя есть какие-то очень хорошие use case,
ты можешь принести предложение в комитет.
Там тебя закидают пометом.
Ну опять же, да, интерфейсы разные.
Если вы интерфейс зафиксировали, то...
Да нет.
Специально называют их по-разному, чтобы ты не мог обобщить на самом-то деле.
Почему?
Что?
Это же получается палку в колеса списать.
Нет, это правильные палки, потому что пытаться обобщить в этом месте не надо.
Используй конкретную структуру данных.
Давайте...
Что?
Я не расслышал, помню, что ты сказал,
но это важно, потому что нам надо ехать дальше сейчас буквально за 5 минут,
попытаемся прилететь.
Вот алгоритм, да.
Вот мы тут ИФ завязали.
Наверное, не надо.
Мы не любим ИФы, мы любим там какой-то полиморфизм,
как-то выносить это все.
Ну и как бы я уже сказал про точки кастомизации,
вот сейчас не через них будем,
и вообще это плохой пример для того, что будет.
Мы будем в рамках класса конкретного.
Ладно, нет, рано говорю.
Тут вообще много параметров вот у этого алгоритма.
Или абстрактного алгоритма.
Да.
Будем смотреть абстрактный алгоритм распределенной сортировки.
Какие точки кастомизации у него в принципе могут быть.
На самом деле их много, да.
Тут есть...
Ну вообще, что он делает?
Он параллельно сортирует значения.
И вот ему нужно и понять,
в каком виде они приходят,
и в каком виде на выход,
то есть какие-то контейнеры нужны,
и понять, что значит параллельно,
и мифический нужен, чтобы там как-то вот это все запустить.
Некоторые локаторы нужны,
чтобы промежуточные штуки хранить.
Нужно и компаратор тоже, в принципе,
чтобы понять, как данные сравнивать.
Вот все эти разные точки кастомизации,
они вот как бы артагональны,
и по ним нужно, даже, наверное,
не очень корректно это говорить,
точками кастомизации,
это некоторые такие параметры алгоритма,
которые вот на уровне входа нужно как-то указать.
И в случае с функциями,
тут особо как бы трюков я никаких не расскажу,
а вот если вы пишете некоторый класс
для алгоритма распределенной сортировки,
то сейчас будет смешной прикол.
Ну, перед тем, как прикол рассказать,
надо понять, что мы хотим от вот такого механизма,
чтобы задавать все эти разные параметры.
Во-первых, он должен быть полностью открытый,
то есть если мы хотим, мы должны смочь свой новый локатор написать и подставить, так?
Написать свой новый экзекьютор и запихать туда,
или свой новый контейнер.
Ну, контейнеры новые написали,
подставили туда, но мы должны соблюдать контракт,
который там учитывается.
А я не думаю, что кто-то в алгоритме распределенной сортировки
будет заранее думать,
а инвалидируются ли там итераторы у твоего классного контейнера,
который как-то там, ну, нет.
Такого просто не делают.
Да, вот эти все параметры, которые мы собрались уносить,
они обязательно должны быть артагональными,
понимаете, о чем я, да?
Не должно быть такого, что вот такие две комбинации друг с другом не работают,
а если вы используете вот это вот, то вы там обязаны вот это вот использовать.
Все эти параметры, они независимо меняются.
Любой из них можно поменять, другие оставить как были,
и все будет нормально в теории.
И мы должны избежать комбинаторного взрыва.
Ну, очевидно, мы не хотим руками все комбинации там прописывать,
как-то вот что-то...
Ну, понятно, о чем я.
Ну, и тут уже в голову приходят всякие идеи,
типа, ну, давайте как-то шаблонными аргументами
какого-то вот этого вот алгоритма это указывать
и потом как-то к ним дергаться.
Но у нас на самом деле есть общий инструмент для этого.
Называется стратегия.
Ну, когда в ОП вы хотите что-то из вот этого всего кастомизировать,
берете и делаете интерфейс,
кайф-экзекютер, который имеет нет-экзекют,
имеет интерфейс-компаратор с методом compare.
Интерфейс, там, аллокатор с методом create и там remove.
Не знаю, в джаве так делают или нет.
Но у нас не ОП.
И в целом мы хотим вот эту вот идею стратегии...
Ну, а что это?
Это, по сути, просто интерфейс с одним методом запустить.
Интерфейс, который с одной целью существует,
мы хотим закрыть то, какую именно функцию мы запускаем.
Перенесем это в compile-time в каком-то смысле.
Делать мы это будем так.
Context — это класс, который как раз отвечает за нашу распределенную сортировку
или еще что-то.
И ему нужна стратегия того, как делать сальтуху.
Ну, это может быть стратегия аллокации, стратегия еще чего-то.
Даже стратегия копирования, например.
И мы потребуем, чтобы у шаблонного аргумента, который здесь будет указан,
был метод статический — сделать сальтуху.
И в, собственно, нашем коде, где мы захотели сделать сальтуху,
мы берем ее и делаем.
Окей?
Просто взяли и сделали стратегию статической.
Пока ничего волшебного.
Ну, причем без состояния.
Да.
Здесь, так как метод статический, мы не можем никакое состояние в стратегии хранить.
Это такой просто заглушка, чтобы передать метод внутрь шаблона.
С таким же успехом здесь можно было бы передать указатель на функцию в шаблон.
Умеем так?
Надеюсь, умеем.
Вот этот синтакс, синт в скобочках звездочка.
Можно пойти дальше.
Чего?
С кем?
Я слова не могу расслышать.
Фронды.
Ну, в смысле, ну...
Ну, это просто функция какая-то.
Ну, D должно быть, да, так класс должен быть.
Ну, в общем-то, да.
Ну, это просто функция какая-то.
Ну, D должно быть, да, так класс должен быть, наверное, публичный,
видимый вот этим вот конкретным классом,
который удовлетворяет вот этому концепту сделать с Альтуху.
Ну, что произошло, по сути, мы просто взяли и сделали вместо интерфейса
для паттерна стратегия концепт.
И вместо того, чтобы передавать объект, там,
передаем теперь шаблонное, эту штуку.
Такой перенос паттерна на статические рельсы.
Ну, мы пойдем дальше.
Мы не просто статическую функцию потребуем,
а обычный метод.
И будем себя наследовать от стратегии.
Зачем?
Зачем?
Хороший вопрос.
Ну, теперь мы можем писать саммерсолд без двух двоеточек,
это прикольно.
Состояние.
Состояние можем хранить, да, например.
Можем каять циклы.
Можем CRTP накастовать.
MTBase Optimization.
Еще MTBase Optimization, да.
Но почему именно наследуемся, а не храним как поле?
Ну, на самом деле...
Ну, как поле тоже, наверное, можно.
Сейчас мы же можем и контрастать.
Ну, да.
Ну, исторически так сложилось.
Если кого-то интерфейс принимающий стратегию
и мы хотим себя...
Нет, такого мы не хотим.
Мы хотим кастомизировать поведение внутри вот этого контекста.
Вот контекст делает много всякого кода,
и у него есть какие-то вот места, где можно что-то поменять.
Поменять экзекьютор, поменять там локатор, поменять еще что-то.
И мы вот ровно эту задачу решаем.
Вот такое решение вполне ок.
Ну, и вот эта вот такая статическая стратегия,
где мы наследуемся от набора стратегий,
она называется policy в книжках.
И не только.
Ну, и есть целое такое направление.
Policy-based design.
Что это дизайн шаблонных библиотек,
который основывается на вот таких вот политиках.
Ну, почему это здорово?
Вы же любую политику можете написать и подмешать в класс,
и оно будет работать так же быстро,
как если бы автор этой библиотеки изначально там такой код вписал.
Ну, еще много всяких приколов есть.
Просто дальше ехать и смотреть примерчики классные.
Есть некоторый виджет-менеджер.
Ему нужна политика создания виджетов, наверное.
Ну, как это использовать?
Сделать две политики каких-то.
Вот одна через Нью создаёт, другая через клон чего-то.
И пихнуть OpNew Creator от виджета.
Но это не очень удобно.
Потому что мы же понимаем, что вот этот виджет-менеджер
хочет создавать виджеты.
Зачем тому, кто из вне собрался использовать виджет-менеджер,
указывать конкретно, что виджет.
А если он укажет не виджет, то что-то другое.
Может, оно не скомпилируется.
Ну, в общем, странно.
Зачем это уточнять?
Давайте просто шаблонные-шаблонные аргументы использовать.
Вот это вот более полное видение того, что такое по политике.
В книжке Александреска уже книжка, да, в ней.
Вот ровно так показывают, что такое политика.
Шаблонный-шаблонный аргумент, который как-то кастомизирует поведение,
которое вы инстанцируете сами и наследуетесь от него.
То есть вот именно такой паттерн визуально.
Это не CRTP.
Вот этот вот виджет – это у нас конкретный класс.
Он ниоткуда не приходит с небес.
Мы прямо вот знаем, что нам нужно создавать виджеты.
Поэтому мы инстанцируем политику создания для виджета.
А можем не только для виджета.
Вот несколько разных политик создания чего-то отнаследоваться
и уметь создавать все виды объектов, которые нам нужны.
Возможно, не уверен.
Но тут всегда можно сказать типа декоратор, когда речь идет о дизайне.
Везде одинаковые трюки используются.
Ввести еще один indirection.
Вот здесь мы в качестве indirection принимаем что-то в шаблонные аргументы
и наследуемся от него.
Можно концептом завестись.
Как-то хочется.
Видим голый класс.
Вернее, голый template-class-class.
Хотим шаблоны в концепты вернуть, чтобы как-то сказать пользователю,
что конкретно мы сюда ожидаем, нам подставят.
Тут можно написать так.
Будет работать.
Вот нашла коса на камень, что называется.
Вот T это шаблон.
А переменная не может быть типа просто шаблон.
Нужен конкретный тип.
Какую специализацию хотим?
Еще один type name.
Какой еще один type name?
Можно спросить явно аргументам.
Можно дурацкий подход.
Сделать некоторого свидетеля, что крейт есть, хоть какой-то.
И подставлять его.
То есть технически что мы хотим написать?
Для любого U, T от U нормальный класс.
И можно вызвать крейт.
Или для любого U, который наследуется от чего-нибудь.
Мы поднимали на одной из прошлых парт этот вопрос,
что хочется иметь квантор всеобщности не только по переменам T,
но и по типам каким-то.
Для любого U, T от U инстанцируется.
Нельзя. Нет такого.
Поэтому вот такой хак предлагается.
Проверить на одном конкретном и надеяться, что если на нем сработало,
то сработает на всех.
Еще раз не очень.
То есть вопрос фиктивный.
Мы фиктивный класс поставляем?
Да.
Тупейший хак.
Но иногда, может, и его хватит.
То есть если там во всяком...
Ну, такая простая ситуация, что там...
Сейчас когда ему не хватит?
Если это класс, закрытый от пользователей?
Ну, если класс требует какого-то интерфейса от того,
что в него подставляют.
То есть если это вот T, то есть какой-то концепт внутри.
Вот тогда это все, типа, поломается.
Ну, конечно, это же не может быть просто потому,
что у нас написан интерплейт класс-класс.
Может.
Сюда нельзя вписывать.
Не работает так.
Нельзя вписывать концепты.
Да, но если даже у класса написано, что он концепт хочет,
оно спокойно сюда подставится в качестве шаблона.
Ну и да.
Ну, короче, тут...
Чувствуете некоторые несостыковки в языке?
Как-то все так вот корявенько.
Ну, к сожалению, вот так.
Да, тут еще есть такой вопрос.
Откуда вообще прототип будет браться?
Прототип криэйтора.
Ну, что значит прототип криэйтора?
Значит, он там какой-то объект у себя имеет
и возвращает его клоны, копии каким-то образом полученные.
Ну, возможно, такое нужно там зачем-то.
Уже стилизованный виджет туда положили,
и вот он уже стилизованные копии возвращает.
Так как положить-то?
Ну, предлагаются тупые хаки.
Просто взять и сделать методы getPrototype, setPrototype в криэйторе,
и внимание, понт этой всей схемы с политиками.
Вот оно, состояние.
Мы подмешали новое состояние,
и можем его сетать и гетать снаружи.
Вот эти методы мы их просто подмешаем
внутрь того класса, который будет эту политику использовать.
И вот если мы знаем, что у нас наша конкретная специализация,
которой мы пользуемся, она вот политику криэйтора использует,
то мы можем вызвать эти методы.
Берем, вызываем.
Это в ходе того, что мы наследуемся от чего-то,
если мы хотим подмешать методы,
мы можем отнесеться, можем сделать так.
Или где-нибудь.
Да, мы подмешиваем новые методы, которые...
Можем ли мы так правильно правильно сделать?
Что сделать?
Бранчинг.
Если мы...
Что?
А тут конструктор явно написан.
Вот да.
Тут можно так, можно всяк.
Просто конструктор плохо,
потому что нам придется как бы менять конструктор
того, кто политику имплементирует,
чтобы он еще инициализировал.
Если бы мы хотели все-таки не иметь конструктора,
а иметь статические методы.
Тогда никак не получится.
У тебя стейт нужен.
Что ты копировать будешь?
Это фундаментально такой типа creator,
который имеет стейт.
Он копирует какой-то конкретный объект.
Ну да.
Такое подмешивание методов
отличается просто от наследоваться,
а тем, что родитель без CRTP тогда не сможет.
Пользуется тем, что есть в ребенке.
А тут я напомню,
вот этот вот виджет-менеджер
использует метод create.
То есть CRTP и эта штука,
они в каком-нибудь смысле противоположны.
CRTP говорит,
что мы будем наследоваться от кого-то,
от главного куска кода,
и наши методы наш родитель
сможет использовать за счет CRTP.
Ну и мы, соответственно,
методы родителя можем использовать.
А тут мы говорим наоборот.
Давайте главный кусок кода
наследуется от политик,
и мы можем использовать методы из политика,
и политики могут нам подмешать
новых методов, которые пользователям будут доступны.
Вот, это про это.
Что ты говорил?
Подумал, что, наверное,
можно просто create, getPrototype
одну функцию сделать,
и тогда элементы держат
на стейке.
Что? Нет, create это
фиксированный интерфейс,
что виджет-менеджер всегда пытается вызвать
в своей полисе метод create
без аргументов.
Crate ровно так должен быть имплементирован,
не как иначе.
То есть это что?
Как мы будем использовать это?
В смысле?
Есть виджет-менеджер, он хочет создавать виджеты.
Он всегда дергает метод create.
Все.
У своего creation полисе дергает метод create.
Мы,
тот, кто извне создал
виджет-менеджер, который использует
prototype creator, он сам обязан
сделать set.
Но он же знает, что он использует prototype
creator, да?
Он знает, что там будет метод set.
Почему метод set будет у виджет-менеджера?
Ну, просто наследование.
Он вызовет его и установит
конкретный prototype, и дальше виджет-менеджер
нормально будет функционировать.
Это, конечно, не очень круто, мы нарушаем
райи, но лучше не получилось.
А если у нас
есть default-ный аргумент?
У нас же концепт проверяет, что
если мы require, спишем и просто
вызов, да, какой-то,
то он проверяет, что это просто wall-defined,
поэтому если я напишу в create,
вот если я напишу в create,
с default-ным аргументом
будет работать просто.
И тогда я могу выменить
вот эти два метода,
которые я использую, как
способ заследить
прототип, я могу
на самом деле сделать
стейп и
оставить его.
У меня create будет
принимать опциональный аргумент
тестом звездочками.
Да, но если он
по дефолту null,
и ты в виджет менеджере уже написал
кучу кода, который зовет create без
аргумента,
цель метода create...
Бранчинг важно описать просто
в теле функции, что если мы пришли... Зачем?
Это
антитезис тому, к чему мы хотим прийти.
Ты вытягиваешь
вот эти вот артагональные
кейсы обратно в главный алгоритм
и начинаешь их там...
Короче, это путь никуда, потом у тебя еще
бранчинга будет с каждым разом, надо хранить
все артагональным и вот
single responsibility. Вот этот чувак
не должен думать о том, что там какие-то
прототипы могут использоваться.
Он же не будет думать.
Ну ты говоришь, здесь if и напишем, что if
прототип так... Нет, if и будут
в теле криейта,
который мы пишем один раз для
прототип криейтора. Так, и какой if?
Какой if? Если мы пришел null,
то он интерпретирует
этот вызов, как просто
установить прототип, который в него
положен, state статической переменной.
Если он пришел не null, то значит его нужно
выставить.
То есть ты говоришь
извне, ты хочешь
извне вызвать create этот аргумент и
типа это более читаемый код, да? Зачем?
Это код, который
позволит state брать.
Так а куда ты установишь этот прототип?
Статическую перемену.
Прекрасная идея.
А потом мы будем писать такопоточный код
или захотим два виджет менеджера или несколько
прототип криейторов и такие
все сломалось.
Короче, нет.
Не надо так, пожалуйста.
Все, давай ехать дальше, потому что это все
провокации и развод.
Вот да, если тут концепт-трюк
не работает, зато
работает более простой трюк,
что вы явно указываете, для кого вы хотите
creation policy.
Вот это хороший способ обойти вот эту
проблему. Просто вытягивайте
наружу информацию о том, что конкретно
вы хотите.
Это логично, но
первая мысль, когда с таким сталкиваешься,
по крайней мере, у меня была, я хочу квантро всеобщенности.
Он не нужен.
То есть вот здесь
я хотел квантро всеобщенности, он не нужен.
Просто сделайте еще один аргумент
у концепта, как что конкретно
вы создавать хотите. И в том контексте,
в котором вы используете этот концепт, вы, наверное,
знаете, что вы хотите создавать.
Покажите.
Короче, нет, все можем.
Все всегда утверждается, что это всегда
решение проблемы того, что вам захотелось
написать квантро всеобщенности по типам.
Не надо вытягивать эту информацию
наружу, будет нормально.
Окей.
Вот еще так можно делать.
В книжке это приводится, не знаю
зачем. То есть мы делаем шаблонные
не саму полисе,
а функцию.
Но тогда мы уже не можем стейт никакой, связанный
с типом t хранить.
Кажется, что не очень полезно,
но так тоже можно.
Все.
Все-таки все. Трюк маленький.
Можно вот такой код
написать, правда?
Что мы делаем? Мы создаем виджет
менеджер, потом сохраняем где-то
за три девять земель ссылку на него
через полисе.
Конкретно.
Потом
пытаемся удалить.
Почему это
УБ?
Где
Нью?
Ну где-то был Нью, считай Нью был.
То есть даже если
Нью был, это все равно УБ, правда?
То есть мы сделали Нью
и my-widget-менеджер, а удалили
по указателю на прототайп-креатор.
Почему УБ?
Да, тип другой,
а что нужно сделать?
Нет, если мы
либо виртуальный
деструктор, либо
приватный. То есть вопрос, что
мы хотим? Мы хотим, чтобы такой код
корректно работал, и так можно было сделать.
Тогда нужен виртуальный деструктор.
Здесь мы не хотим, чтобы такой код работал.
Нафиг нам это надо? Почему
вообще кто-то запоминает
этот
widget-менеджер по указателю
на его полисе? Вообще такого не должно
быть.
Наследование сделать приватным мы не можем,
но такое тоже
иногда прокатывает. Делать приватное
наследование, чтобы даже вот эта строчка не скомпилировалась.
То есть нельзя было
присвоить по указателю. Но мы так
не можем, потому что нам get-прототайп,
set-прототайп нужны, чтобы они публично
вылетели наружу.
Окей, давайте
просто сделаем деструктор приватным.
Protect-от, точнее.
Всё. Теперь вот это
не компилируется, и мы предотвратили
ошибку. Ну и не
добавили никаких виртуальных вызовов дурацких,
которые здесь не нужны. Вообще
не нужны.
Если у вас в главе есть правило
«используешь наследование, делай виртуальный
деструктор», поменяйте
это правило, пожалуйста, на «используешь
наследование, делай либо
приватный, либо виртуальный деструктор».
Такое очень общее правило,
мне кажется, оно покрывает
все кейсы.
Мне кажется, ничего сложного,
правда?
Что я тут хотел сказать?
Ну да, можно какие-то
конкретные методы же ещё делать.
То есть, вот я говорил, там артагональность
не зависит от деталей имплементации.
Можно. Можно в виджет-менеджере
сделать конкретный кейс для
конкретной
полиси.
Почему можно?
Потому что шавлоны лениво инстанцируются.
Если вы не используете этот метод,
то он вам компиляцию не сломает.
То есть, ну вот такое
как бы окей. Опциональная
такая штука. Если полиси позволяет
менять прототип, то эта функция тоже
можете использовать, всё будет работать.
Здесь должен быть план «покодить».
Кодение на следующий раз переносится,
конечно. А примеры,
где это используется?
Полиси-бейст дизайн.
Вот кто-нибудь вот это вот на
олимпиадках использовал?
Это ГЦЦ-шная
библиотека,
стандартная библиотека плюсов от ГЦЦ,
от ГНУ, да? У неё есть вот такая
вот include-ext-pbds.
Полиси-бейст data structures.
Вот если вас
интересовало, что значит полиси-бейст,
вот ровно это.
Это есть, а ещё там
Rb-дерево. Красно-чёрное
дерево, которое там можно как-то кастомизировать,
свои собственные ноды туда вставлять,
новые какие-то эти
ребра добавлять дополнительные.
Вот кто умело этим пользовался, мог
там рвать олимпиадки при помощи
уже имеющегося красно-чёрного
дерева, в которое встроил ещё пару каких-нибудь
хитрых обратных ребер, и там всё заработало
и взлетело. Но я так не умел,
к сожалению.
Преоритет Q там тоже вроде есть.
Да там много чего есть.
Вот, аллокаторы в стандартной библиотеке,
это вы не поверите. Это тоже политики.
У всех контейнеров.
Потому что мы наследуемся от аллокатора, как правило,
чтобы
empty-based optimizations
работал.
Ну,
не совсем. Мы принимаем не шаблон
аллокатора, а конкретный аллокатор, поэтому это
не совсем тот паттерн, который в книжке
описывается. Но
тем не менее. Вот здесь прямо честно,
ровно то, что в книжке описано, ровно то они и сделали.
Вот есть библиотеки,
две штуки. Там я это тоже
нашёл. Но я уже забыл, что это за библиотеки,
что они делают. Ладно, вру не забыл,
но сами почитайте, если хотите.
Последние
мы уже совсем задерживаемся, да.
Последние три слайда буквально.
Такой кейс смешной. Я сейчас буду просто
как из Пушкили. Есть полигон,
есть точки. Мы в полигоне храним
вектор точек. Мы захотели
как-то расширять эту дурацкую программу,
какие-то вот там хитрости делать.
Например, точки помечать лейблами
какими-то. Или делать точки там
в пятимерном пространстве.
Конечно, мы вот так не расширим ничего,
надо сделать шаблон.
Конечно надо.
Полигон в пятимерном пространстве.
Ну окей, приметризовали
шаблоном, и
теперь можно подменять на какую-то точку,
и вот если мы там захотим лейбла добавить,
то мы наследуемся точки
и добавим там
стринг лейбл. Звучит
отлично.
Можно по-другому?
Можно, пожалуйста, еще назад.
Еще назад. Шаблонный
полигон, точка.
Пешек.
Почему мы не можем
н-коррелинат хранить?
У нас же точки, которые должны это заново создавать,
если у нас трехмерная, четырехмерная,
что они, ну просто
какой-то полигон, ну коллекция
точек, я не знаю, ну вот
точки хранимые.
Да,
то есть это могут быть там не просто точки,
а какие-то точки в гильбертовом пространстве
хранимые как-то ла-ла-ла-ла.
Ну просто обобщили, вот тупейшее
обобщение. С чем собрались использовать?
Вот, например, с таким.
Вот лейбл point, оно там расширяет point
и добавляет
но чтобы соблюдить интерфейс, который
полигон использует, нам нужен конструктор
двух аргументов. И вот тут все
сломалось, потому что если мы хотим добавить
несколько разных лейблов, или еще
что-нибудь такое хитрое, и много
разного функционала нового к точке прикрепить,
да, что это там, например, точка
на карте, у которой
там есть иконка специальная, есть
пометка, есть подсказка, есть там
привязка к какому-то квисту, потому что
это на самом деле не просто полигон, а там
путь, который вам нужно по квисту пройти,
идя в Скайриме, куда-то в горы.
Ну,
искусственный немножко пример, но
предлагаемое решение вот такое.
Отнаследовать точку
от параметра пака.
Чем-то напоминает политики.
Называется
теперь миксыны.
Ну, почему-то вот так.
То есть, миксыны — это главное
про то, что тут целый пак, и вы можете их сколько
угодно вписывать. С
политиками это тоже можно скрестить, да?
То есть, миксыны — это именно про то,
что у вас пак чего-то, чего вы наследуетесь.
Политика — это вот то, что говорили.
И теперь мы можем
подмешивать. Слово «миксын» — что значит
«подмешать». Можете подмешать лейбл
прямо внутрь точки,
пихнув его вот сюда.
И как бы у каждой точки будет состояние лейбл.
Да, вот у нас, собственно,
point от лейбла.
Да,
подмешиваем поля, подмешиваем методы, причем
сколько угодно.
Че?
Для дефолтных что?
Ну, тут как бы да,
как такие структуры данных
с миксинами инициализировать,
ну, через конструктор у вас ничего не выйдет.
Че?
Через какой-нибудь билдер что-нибудь можно изобрести,
наверное, да. Да даже с конструктором,
если постараться, можно изобрести, ну,
просто принимать сюда пак миксинов и, типа,
руками давайте, ребята, указывайте.
Ну, может быть там неудобно.
Ну, в общем вот,
можно сделать их шаблонами, будут миксины политики
и еще ЦРТП закастывать
и вот вообще классно будет.
А что стало лучше?
Не знаю.
Уже слишком поздно, чтобы было что-то лучше,
но вот так можно.
Есть смешной трюк через все это.
Внимание!
Функция использует миксины.
Вот сейчас очень смешной трюк.
Я думаю, эта забивка совсем последняя будет.
Функция использует миксины.
Бейс.
Вот она тут фу какое-то делает, да.
Потом кто-то наследует этот дирайвт
тоже там с миксинами
и тоже делает фу.
Шедуинг происходит, да.
Теперь внимание.
Вот эти вот шаблоны
видите? Один из них
ничего не имеет, а другой говорит, что
а фу-то вообще-то виртуальная функция.
И теперь мы
вот этот дирайвт-шаблон
можем инстанцировать от node-virtual, а можем от virtual.
И вот в этом классе A
фу это не виртуальный вызов,
а в классе B он виртуальный.
Поздравляю, мы научились
с помощью шаблонных аргументов включать
или выключать виртуальность верархии.
Так можно.
В одном есть виртуальная функция?
Да, вот это вот
дирайвт наследует бейс.
Ещё тут всё миксинами обмазано.
И у дирайвта и бейса есть фу
функция.
Вот они печатают, там разное.
Бейс и дирайвт.
Ну, они не виртуальные.
Тут не написано, что они виртуальные.
Но мы можем подмешать миксин,
который
прилетит через вот-вот
через дирайвт прилетит, к бейзу прилетит
и бейс от него наследуется.
И в этом миксине написано, что
фута вообще-то была виртуальной всё это время.
И тогда и это станет виртуальной.
И это станет виртуальной.
И всё, у вас виртуальная иерархия.
Что?
Не знаю.
Зачем здесь бейс? Почему нельзя?
Ну, чтобы продемонстрировать,
что если мы прикастим к бейзу,
вот А или там Б, то и вызовем
футу будут разные результаты.
Ну да.
Да.
Да.
Когда ты кастуешь
вот такие вещи,
ты уже должен быть джедаем.
Ты не можешь ошибиться.
Должен контролировать каждую букву в своем коде.
Ну, в общем, тут компилятор тебе не помощник,
если вот таким занимаешься.
И вот библиотека, про которую я говорил.
Там это есть.
Там реально используют миксины и реально отключают или включают виртуальность.
Если интересно, почитайте.
А у меня на этом всё.
Все свободны.
