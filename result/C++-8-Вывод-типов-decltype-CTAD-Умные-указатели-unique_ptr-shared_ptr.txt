Мы сейчас закончим тему вывода типов и перейдем к следующей теме, по которой у вас будет третья задача.
Давайте вспомним, на чем мы остановились. Мы остановились на обсуждении того,
что такое декл-тайп. В принципе, мы почти все обсудили про декл-тайп, что я хотел, кроме одной такой
интересной детали. Вот смотрите, давайте разберем такой пример. Вот представьте, я хочу написать
функцию, которая берет какой-то элемент контейнера, которая, скажем так, является оберткой над
квадратными скобочками в контейнере. То есть, ну скажем, она логирует что-то и возвращает,
ну ссылку на этот элемент скажем. Вот, контейнер, контейнер, там и sizeT-индекс. То есть, как я хочу
пользоваться этой функцией? Я хочу говорить, например, std vector int v там от 10 и сказать
v.getByIndex, не знаю, 5 присвоить 1. Ну вот так я хочу делать. То есть, это такая обертка над
квадратными скобочками, не знаю, std out blah blah blah. И, значит, вот return контейнер с квадратными
скобочками индекс. Это пример не я придумал, это пример придумал Скотт Меерс. Ну, вероятно,
может, и не он сам лично его придумал. В его книжке есть про эффективность современной C++. Вопрос.
Мы умеем, мы вообще умеем так сделать. В смысле, что мы умеем добавить функции к классу, хоть как-нибудь,
хоть не шаблонные, какие угодно. Ой, господи, я ерунду написал, конечно. GetByIndex v5. Это я написал чушь
какую-то, да. Да-да-да. Вот. А вопрос, какой должен быть возвращаемый тип? Пример из книжки просто,
вот. Я сейчас просто хочу вам кое-какую фичу показать, но вот прежде чем я ее покажу,
вот давайте ответим на вопрос. Мотивирующий пример. Каким должен быть возвращаемый тип у этой
штуки? Ну, тот же, что у квадратных скобочек. То есть желательно можно... Тупой вариант это контейнер
2.2.type что-то там. Ну, референс type, да. Умный вариант. Да, умный вариант. Вот, я хочу донести мысль. Да,
decal type, вот контейнер, значит, индекс, да. Но я хочу донести мысль, что здесь ни авто нельзя написать,
ни автоамперсант нельзя написать. Почему нельзя написать авто? Потому что надо бросить ссылку и
тогда никого присваивать не получится. Например, даже для интов-то не будет работать для вектора интов.
Почему нельзя написать автоамперсант? Потому что... Почему нельзя написать, кстати, автоамперсант?
Пусть он вернул int, а мы ссылку добавим на что. В смысле, пусть он вернул позначение. А почему он
мог вернуть позначение? Ну, контейнеры иногда возвращают там int, например, просто в квадратной
скобочке. В квадратной скобочке в контейнере. А, нет, не бывает, не бывает. Справедливо. Бывает вектор буль. Ну, да, понятно, но просто не понятно, я не понимаю, да, нет, нет. Все, ну, типа, если это вектор буль, то это не сработает. Ну, потому что у нас, короче, иногда бывает возвращение по ссылке, иногда по значению в квадратной
скобочке. Иногда устроено так, что возвращает ссылку, иногда, наш любимый контрпример, вектор буль, они возвращают значение, которому присваивание меняет контейнер. Ну, мы хотим, чтобы он сохранял ссылочность. То есть, чтобы ссылка... Чтобы, короче, возвращаемый тип был ссылкой, если и этот был ссылкой, и не был ссылкой в противном случае. Я мог бы, конечно, писать декл-тайп от контейнера квадратной скобочки индекс. Это было бы правильно, формально, но очень плохо с точки зрения код-стайла, потому что
мне пришлось бы повторять мое выражение дважды, и если бы я его чуть поменял, то потом возвращаемый тип у меня мог бы не совпасть, и все плохо. Вот, поэтому в C++14, уже не в 11, а в 14 появилась такая странная языковая конструкция под названием декл-тайп от авто.
Хоть на это время большого мозга. Да, вы ее можете видеть иногда в некоторых методах стандартной библиотеки, возвращаемый тип такой. Ну, ладно, не знаю, не уверен, что прямо вы ее можете увидеть на CBP-референс, но, короче, скажем так, кое-где в реализации кое-каких классов в некоторых методах вам она может понадобиться.
То есть, вам нужно самостоятельно вывести тип возвращаемого значения, но при этом вывести его по правилам декл-тайпа, а не по правилам авто. То есть, в частности, не отбрасывать ссылку, если она была.
То есть, не декл-тайп от выражения, которое вам придется крипастить, если оно там длинное, это плохой код-стайл, а декл-тайп от сам догадайся чего, ну понятно от чего, от вот этого выражения.
Ну, значит, это такой способ сказать, выведи тип сам, но по правилам декл-тайп, то есть, в точности повтори тип возвращаемого значения, если он был ссылочным, не отбрасывай ссылку, вот.
Ну, и если он был с двумя амперсандами, то, значит, будет два амперсанды, ну и так далее. Вот такая вот странная конструкция, ну вот, иногда пригождается.
А какая у нас проблема была из-за того, что мы бит референс по ссылке возвращали?
Потому что, если ты присвоишь бит референс, сейчас, ну давай подумаем, вот у тебя создался бит референс, ты вернул ссылку на бит референс, а бит референс, а, ну понятно какая, у тебя временный бит референс же, у тебя битая ссылка просто кажется.
Отлично.
Потому что, ты, когда обратился по индексу, у тебя создался R-value бит референс, это будет CE даже, я бы сказал, потому что это же R-value, а ты возвращаешь автамперсанд, это будет CE, вот, ну и всё, это не скомпилируется для VectorBuy, а так нормально будет работать.
Ну вот, такие дела.
А вот эта штука по UAC++14, то есть, по UAC не возможно написать декл-тайп от авто, или что?
Ну просто не было такой конструкции, ну декл-тайп, ну это же новоязыковая фича, декл-тайп от типа пишется авто, это что такое? Ну вот такая вот, придумали такой синтезис декл-тайп от авто у UAC++14.
То есть, это как бы считается как единая конструкция, да?
Ну да, это не подчиняется тем же правилам, что декл-тайп отдельно и авто отдельно, это так не работает, ну понятно, что это новоязыковая фича.
Ну ладно, давайте последний пункт отойти, ну или привет последний, давайте теперь поговорим вот ещё про что.
Это стало актуально только с C++17, но раз уж у нас тема TypeDeduction, то мне кажется, что уместно прямо здесь поговорить вот про это.
Класс TemplateArgumentDeduction, ну сокращённо это обозначается ct.ad, про это есть прям длинная статья на ct.preference,
эта штука, которая появилась с C++17, и наверное под неё даже имеет смысл создать отдельный файл, давайте так и сделаем.
Что такое класс TemplateArgumentDeduction? Ну смотрите, у нас в принципе, ну вы уже можете догадаться, что это такое,
я думаю некоторые из вас и так знают, что это такое.
Вектор от авто?
Да не вектор от авто, просто вектор, а компилятор сам догадается от чего.
Ну то есть, вот у вас есть, скажем, у вас есть отличный механизм вывода типов.
Вы уже умеете выводить типы возвращаемых значений функций, типы параметров функций, когда они шаблонные,
типы переменных, когда инициализируете переменные, и вы можете даже выводить автоматические типы шаблонных параметров функций,
то есть когда вы вызываете f от чего-то, а f шаблонная, вы же не пишете явно шаблонный аргумент, они сами выводятся.
Но в C++17 люди подумали, а зачем нам писать явно шаблонные аргументы класса, если можно то же самое сделать,
можно же шаблонные аргументы класса тоже выводить автоматически, если это получается сделать однозначно.
Но когда это получается сделать однозначно, ну например, вот когда вы объявляете какую-нибудь пару,
вот уж точно, когда вы объявляете пару, я не знаю, 1.0, запятая abc, ну тут, конечно, без abc, вот 1.0, запятая 1.
Вот понятно, что однозначно ясно, из каких аргументов пара состоит.
Сейчас, правда, я немножечко не уверен, что это скомпилируется.
Так, ну давайте сначала попробуем без слага C++17, это не скомпилироваться, это не должно скомпилироваться, да.
Missing template arguments before p, это понятно, а вот если минус abc++17, то это компилируется, да, все нормально.
Начиная с C++17, значит, комплятор умеет, если у него однозначно получается догадаться из параметров конструктора,
какие шаблоны аргумента к классу надо подставить, то он это подставляет.
То есть вам, в частности, вам не надо, когда вы объявляете пару, говорить пара из чего.
Вы еще, не дай бог, ошибетесь и не точно скажете из чего, а тут он сам догадается из чего она.
Ну вот, давайте попробуем с вектором так сделать.
Кстати, почему пара добавилась, заинклудилась, если меня только его стрим подключит, интересно, ну ладно.
Вот давайте я сделаю вектор.
А вектор так можно инициализировать?
Конечно, конечно можно, уже давным-давно, уже 10 лет как, с C++11?
Ладно.
Ну с 11-го года initializer list это называется.
Это обычная работа, когда у вас, типа, переменные конкретные там определенные.
Сейчас, я в нем почему-то для пары работаю, почему-то для вектора пока не понимаю.
Ну ладно, работает, работает.
Нет-нет-нет, у вас есть тип std и initializer list.
Я про это не говорил, что ли, в первом семестре, может быть и забыл сказать.
Что-то про него говорили.
У вас есть такой тип std и initializer list, который появился с C++11.
И он привел к тому, что вы можете в фигурных скобочках перечислять длинные списки,
в частности вы можете вектор вот так инициализировать.
То есть initializer list это такой встроенный тип,
который, ну он непонятно как реализован,
его как-то компилятор реализует, его самим не реализовать.
Но он, когда вы конструируете контейнер от чего-то в фигурных скобочках,
через запятую,
он в первую очередь проверяет, нельзя ли это подставить как initializer list,
конструктор от initializer lista.
И если можно, если у вас в списке все перемены одного и того же типа,
то он просто выберет конструктор лучше от initializer list и сумеет,
ну и поймет, что это вот оно, вы просто элементы вектора хотите этим пронициализировать.
Ну вот это работает начиная с целью 11.
Правда ли, что пара тоже инициализируется от initializer list?
Нет, пара инициализируется не от initializer lista сейчас,
пара инициализируется агрегатной инициализацией, разные вещи.
А, ну...
Меня именно это спутало, просто обычно я пишу,
в равно initializer list, то есть равно фигурной скобочке,
так можно, я офигел, но без проблем.
А, вот так ты имеешь ввиду?
Не-не-не, так оно...
А, тебя смутило именно то, что ты, то, что я равно не написал?
Ну да, ну так тоже можно, ну да.
Ну так вот, теперь я хочу убрать int.
Да, давайте проверим, что я вас не обманул.
v.size, сейчас должно быть 5.
В принципе, если не 5, то...
Ой, я себе 17 скомпилировал.
А, да, теперь...
Ну ладно, это мы закомментируем.
Ну да, 5, все нормально.
Вот, а теперь я уберу int.
Черт возьми.
Я уберу int и посмотрим, как это работает, себе 17.
Вот, не работает.
Но если я добавлю c+, 17, работает и размер 500.
Вот, такие дела.
А можно...
Насчет пары, применимость.
Ну то есть, мы получается балансируем между тем, чтобы не ошибиться,
и тем, что код менее читабельный.
Точно ли, Анатолий, стоит, что мы не ошибемся в двух чиселках?
Ну, в целом, вопрос достаточно справедливый.
И надо сказать, что там в комитете кое о чем пожалели c+, 20,
когда поняли, что они натворили,
с этими initializer-листами и выводом шаблонных параметров.
В общем, приколов достаточно много возникает в связи с этим,
но я не буду их все перечислять, потому что я многие из них не помню,
но про некоторые из них написано в книжке Мейерса,
про некоторые из них там я сам слушал на лекциях от некоторых там,
значит, членов комитета.
Ну вот, если вкратце, то у этого много неожиданных побочных эффектов.
В большинстве случаев это работает как ожидается,
ну, например, в таких случаях,
но в некоторых это работает странно.
Ну, например, давайте вот такой вопрос зададим,
что если я решу создать вектор,
вот, смотрите, у меня есть вектор от пяти интов,
вот я его создал,
но я же могу создать вектор, вообще, у меня есть такой конструктор,
от...
А, да, еще нужно важный момент сказать,
в C++11 вообще такая мода пошла,
фигурные скобки вообще предпочтительно использовать перед круглыми,
то есть, когда вы инициализируете что-то,
когда вы пишете там, объявляете объект класса,
то фигурные скобки предпочтительнее, чем круглые.
Почему? Потому что круглые лишают вас возможности
попасть в конструктор и нишалайзер листа,
а фигурные, типа, они, если найдется нишалайзер лист от таких параметров,
то, значит, вы попадете в него,
а если не найдется, то он просто аналог круглых сделает.
Ну, в частности, я могу написать vv от пяти запятая там шести,
ну, тут, ну, хорошо, тут я, конечно, непонятно, что сказал,
но вот я могу так сделать,
это будет означать, что я создал вектор из пяти интов,
каждый из которых равен шести.
Нет, я не уверен, что это равно,
я уже не уверен, что это равно,
это не то, наверное, это все-таки вектор из двух интов.
Нет, все правильно, это вектор из пяти интов, кажется, который равен шести.
Вы не тот сайс выявили.
А, да, тогда я все-таки думал, что это вектор из двух интов.
Ну да.
Потому что конструктор и нишалайзер листа предпочтительнее,
вот если бы я так написал, то это было бы по-другому.
Так о чем мораль в итоге не очень понятна?
Пока морали нет, сейчас будет, подождите.
Ну вот,
сейчас будет мораль, почему
иногда это приводит к странным последствиям.
Вот смотрите, я стираю
шаблонный параметр,
и меняю скобочки на фигурный.
Вот раньше у меня была возможность сделать вот так.
Ну, я могу создать вектор
от двух итераторов.
Ну, я могу создать вектор от диапазона, правда?
То есть это будет что?
А теперь вы сделаете вектор из двух итераторов?
Вот если бы я так написал,
то это был бы вектор размера 5 из 5 интов,
он просто скопировал диапазон.
Но если я сейчас сотру
параметр шаблонный,
ну, все еще нормально,
потому что он однозначно понял,
что если я создал соц. итераторов, то он понял.
Ну, короче, если я буду использовать круглые скобочки,
то это еще нормально.
А если я буду, как мне завещали там,
с 11 использовать фигурные скобочки по максимуму,
то это приведет к тому,
что у меня будет вектор из двух элементов.
И что это будет за элемент?
Это будет вектор не из интов,
а из итераторов на вектор от интов.
Второй вектор, он не от инт, а от std-вектор-инт-итератор.
А почему тогда фигурных скобочей удобнее круглых,
если они такой дичьей сделают?
Вот, и начиная с C++20,
в комитете передумали и сказали нет,
все-таки используйте круглые предпочтительнее, чем фигурные.
Ну, то есть, я уже не помню всю хронологию истории,
но помню, что, в общем,
я уже забыл причины,
но про это в книжке MERS написано,
вот, эффективность элемента C++ нам тоже пропагандирует фигурные скобочки.
Вот, но в C++20 все переосмыслили и сказали нет,
все-таки эти круглые, потому что с фигурными вот такая дичь иногда происходит,
и там еще несколько примеров дичи есть, но я их тоже забыл.
Короче, надо быть аккуратными.
Вот, поведение иногда бывает необычным.
Вот, но о чем я хотел рассказать?
Я хотел рассказать еще о user-defined deduction rules.
Смотрите, C++17 в связи с этим
позволяет вам для своих классов определить
правила вывода типов, кастомные, по своему желанию.
Ну, то есть, представьте, что у меня был бы
какой-нибудь мой вектор.
Ну, с моим вектором, конечно, тут не очень хорошо, но
что-нибудь бытовое вам привести пример, чтобы было покороче.
А не буду приводить пример, просто открою страницу референс, и там пример привезем.
В общем, вы можете определить для своих классов свои собственные правила вывода.
Значит, вот эта страница про class template argument deduction,
вы видите ее размер,
она достаточно внушительная по объему, и тут в C++20 еще ничего появилось, добавилось.
Вот, то есть, вот как работает этот вывод типов для шаблонов классов,
и вот, что добавилось в эти правила, значит, в C++20.
Вот, но вот как выглядит кастомное правило для user-defined deduction guides.
Смотрите, вот у меня есть контейнер,
ну, вот, собственно, тот самый пример, у меня есть контейнер от T,
и его можно конструировать, значит, от T, а еще можно конструить от пара итераторов.
Ну, контейнер от T, а конструировать его можно от пары итераторов.
Тогда я беру и говорю, давайте-ка я добавлю свой собственный deduction guide.
Я говорю, что если для некоторого шаблона классов, например,
дедакшн гайд, я говорю, что если для некоторого шаблонного типа итер,
мой контейнер конструирует от пары таких вещей,
то это должно, вот такой вот синтез, стрелочка,
интерпретироваться, как если бы контейнер конструировались шаблонным параметром вот таким.
Ну, то есть, я просто явно прописываю дедакшн гайд для шаблона.
То есть мы по сути этой конструкции явно указываем возвращаемый тип для такой функции.
Для конструктора, например, да?
Ну, нет, конструкторы остаются как были конструкторами.
Вы можете, для произвольного T, это отдельно от класса пишется,
я говорю, для произвольного типа итер, если мой контейнер конструируется от двух вещей такого типа,
то это понимается как контейнер вот с таким шаблонным параметром.
Потому что автоматический компилятор бы выявил непонятно, какой шаблонный параметр,
а я явно ему сказал, какой, надо вывести, если его от такого сконструировали.
Ну и вот, компилятор будет следовать этому правилу переопределить стрелочку,
может, в смысле, переопределить стрелочку.
Это не оператор-стрелочка, это синтаксис такой, просто кастом дедакшн гайд.
Нет никакого оператора, тут нет никакого выражения,
это просто такая дополнительная, дополнительная синтаксическая конструкция,
введенная в язык, кастомный гайд, как выводить типы.
Вот, ну, ну в общем, это всё.
Тут много ещё интересных примеров, кому хочется разобраться, почитайте,
но мне кажется, что я не буду дальше на этом задерживаться, в общем.
Проблема, они себе создали массу, и нам тоже, ну, и веселье тоже.
Ещё какие там...
Ну, в общем, это всё.
Проблема, они себе создали массу, и нам тоже, ну, и веселье тоже.
Ещё какие там, какие там правила вывода работают, в каком случае,
мы с этим ещё когда-нибудь огребём тоже, наверное.
Вот.
Ну и последнее, о чём я хотел рассказать в этом пункте, в этой главе, точнее,
в этой теме, это...
Ну, давайте я назову это пунктом 11.4.
Так, сейчас, минуточку.
Господи, я забыл, как это называется по-английски.
А-а-а!
Вот это...
Вот это прикол.
А-а-а!
Вот это...
Вот это прикол.
Сейчас.
А-а-а!
Господи!
Да, вот как это называется.
Называется structured binding.
Так, хорошо, давайте...
покажу.
Ну, давайте сначала пример просто покажу, простой.
Значит, structured binding.
Binding.
Структурд байдинг.
Байндинг.
Тоже начинается и плюс 17 они появились.
А кто знает, что это такое?
Что такое structured bindings?
Перевода на русский я вообще не знаю, но вот...
Я и по-английски забываю, как это называется.
Никто не знает?
Может, в одну строчку много присваиваний сделать можно?
Ну, типа...
Ну, нет, ну...
Мне даже интересно, кто-нибудь из вас пользовался таким когда-нибудь или нет.
Ну, хорошо, сейчас вам покажу.
Вот у меня есть мэп.
Вот я хочу обойти мэп.
Вот как совсем модно по современному написать для каждого элемента мэпы.
Ну, мы понимаем, что можно написать вот так, да.
И что-то сделать.
Но C++17 позволяет нам написать еще круче.
Можно написать вот так.
А, ну да, есть такое.
Разве что не все компиляторы это поддерживают вроде до сих пор.
Да ладно, а какой не поддерживает?
Это уж очень давно есть, чтоб не поддерживали.
Вот, ну...
Я точно знаю, что в EJUDGE так нельзя писать.
Я не знаю, каким там компиляторам пользоваться, надумаю я C++17.
Что странно, казалось бы, должно уже поддерживаться.
Ну, в общем, да, вот это так работает.
Это называется structured bindings.
Вот.
Ну, опять же, есть целая длинная статья про то, как это работает.
Про то, как, для каких типов это, значит, определено.
Ну вот, вы можете это делать для массива, во-первых.
То есть вы можете таким образом инициализировать.
Если у вас есть массив из нескольких элементов, то вы можете сказать авто.
И вот такая штука, и каждый из них будет, соответственно, равен, соответственно, массиву.
Дальше вы можете байнить tuple-like type.
Что такое tuple-like type?
Это тип, ну, к нему пара тоже относится.
А, нет, наверное, к нему пара не относится, виноват.
Пара относится к третьему случаю.
Это когда у вас просто aggregate type.
То есть когда у вас просто поля это...
Ну, короче, когда у вас просто агрегат, как пара, то получается, что вы просто...
Каждые перемены, соответственно, инициализируются соответствующим полем с этого класса.
Вот.
Ну а tuple-like type – это тип, который ведет себя как tuple, штука tuple, но это как пара только из нескольких элементов.
Значит, чтобы это работало, у вас должно быть, чтобы std tuple-size от вашего типа был корректным выражением.
И чтобы еще tuple-element, такая метафункция от вашего, значит, по индексу E от вашего типа,
type был определен.
Вот если это так, и если у вас ваш тип таков, что он это поддерживает, то, значит, это будет работать.
Ну, в частности, это будет работать для std tuple.
std tuple – это просто кортеж из нескольких элементов.
Это, по сути, такое обобщение пары.
Ну, вот как раз у вас есть такой коррект.
std tuple – это просто кортеж из нескольких элементов.
Это, по сути, такое обобщение пары.
Ну вот как раз это та задача, которая у вас не будет.
Но я думаю, что мы с вами на какой-нибудь паре обсудим реализацию std tuple,
просто потому что у нас теперь будет на это время,
и реализовывать вам самим это, наверное, будет не надо, но мы поговорим о том, как он реализован.
Там некоторая шаблонная магия происходит.
Можно на код обратно на секундочку?
Куда? А, окей, сейчас.
Я правильно понимаю, что авто здесь имеет не совсем тот же самый смысл, что обычно?
Или это реально какой-то тип данных теперь?
Ну как? Здесь авто ни во что не разворачивается.
Я могу здесь не написать авто?
Просто вот что-то сделать так, чтобы не избежать слова авто?
По-моему, нет, но я не знаю способа.
Хорошо.
Ну, здесь важно написал ли я просто авто или конста автоамперсант, или просто автоамперсант.
То есть понятно, что смысл вот от того, что я написал,
авто, автоамперсант или конста автоамперсант, смысл будет разным.
Я по-прежнему либо получу копию, либо ссылку, либо константную ссылку на каждые из вещей.
Да, это непонятно, как это сработает, в смысле, что это значит.
Обычно, если дальше идет элемент, то есть, ну там, буквально P по M, где P это там пара,
то понятно, что такое константная ссылка на константную ссылку.
Ну, на каждый из элементов, ну как, я фактически объявил константную ссылку на первое поле,
константную ссылку на второе поле и так далее.
Хорошо.
Вот.
Ну, там, конечно, есть наверняка дофига тонкостей, которые я не знаю, они все перечислены на той странице,
которую я показал, но, так скажем, в базовом случае,
это вот так работает, я думаю, что здесь не надо подробнее на это восстанавливаться.
А можно вопрос?
А вот если бы мы написали константный автоэмперсант P, 2.M,
ну, то есть, P было бы парой.
Да.
А у нас не происходило бы копирований?
Не происходило бы, да.
А почему?
Ну, я думаю, потому что у нас не было бы копирований.
Ну, я думаю, потому что у нас не было бы копирований.
Не происходило бы копирований?
Не происходило бы, да.
А почему?
Ну, как почему?
Ну, как я сделал константную ссылку на пару, а откуда копирование должно было произойти?
Ну, а как эта пара конструировалась бы?
Она никак бы не конструировалась.
Я ссылку объявил на пару, а не копил пары.
Ну, в мэпе же нет пар.
Как это нет? Есть?
Ну...
Вообще, что такое конс автоэмперсант, что-то, 2.container.
Это сокращенная запись для for.
auto it равно m.cbegin, it не равно m.cend, plus, plus it.
auto p равно звёдочка it.
Ну, конс автоэмперсант p равно звёдочка it.
Под итератором, разыменованным, лежит пара, на неё ссылка и получается.
Понятно.
Это я.
А я?
Это двоеточие, которым я тоже много раз использовался.
Например, если я сейчас возьму свой лист и напишу двоеточие.
Это же сработает, потому что у меня определённые итераторы.
Да, это должно сработать, если у тебя определены методы begin и end
с правильными там условиями, которые где-то перечислены.
Да, ну, можно по этому поводу тоже запариться и открыть...
вот эту страничку на этот раз открыть.
В принципе, тоже к теме типов относится.
Ну, вот здесь формально объяснено, во что расшифровывается range-based-for.
Здесь объяснено, что такое begin-export-end-export.
Вот, begin-export-end.
Ну, в зависимости от того, что за тип, значит, begin-export – это...
Ну, я мельком объяснил, что такое begin-export-end-export.
Ну, я мельком увидел в форе using, где-то в самом низу примеров.
Using LMT равна decal type...
Это кажется C++23. Это ещё мы такого не дошли. Подождите.
Это слишком высокий уровень. Подождите, пока мы такого не дошли.
Ну, в общем, да, если ваш класс поддерживает соответствующий функционал, то оно развернётся правильно.
Всё. Ну, тут можно много ещё всяких фишечек обсуждать, на самом деле.
Например, в C++20 появились так называемые...
Господи, я тоже забыл, как они называются.
Ну, в общем, вы можете теперь начинать C++20.
C++20 при...
Сейчас. Извините меня. Да, вот. Designed initializers.
Я не знаю, как это даже правильно прочитать по-английски.
Designed.
Designed.
Вот вы можете начинать C++20, инициализировать объект свой, явно указывая, какие поля вы инициализируете.
Ну, вот про это написано здесь.
То есть я могу не просто агрегатную инициализацию использовать, а designed initializers.
Я не могу говорить, что это поле равно такому, это поле равно такому.
Это немножечко питон-стайл.
Мы вот давно мечтали об этом.
А почему вы такую, если честно, ключу так подновели?
Думаю, потому что у них было много более важных проблем до этого.
Какие конструкторы будут вызваны?
Никакие. Это будет агрегат. Ну как это? Это...
В смысле, это агрегатная инициализация.
Она работает, если у вас нету конструкторов.
Каждое поле инициализируется по отдельности.
Не, ну мы же можем ее вызвать, и когда есть конструктор?
Не думаю. Думаю, что нет.
Вот, агрегат – это такой тип, что это либо массив, либо класс, в котором нету, в частности, user-deployed constructors.
Вот, ну это все синтактические детали.
Я думаю, что хватит про это говорить.
На самом деле, понятно, что...
никакого принципиально нового функционала они не вносят,
но это просто такой синтактический сахар, это называется.
Или разные детали того, как сделали, чтобы было удобнее писать.
Вот, но концептуально тут особо глубокого ничего нет.
Просто очень много проблем.
Ну, в общем-то, я думаю, что это будет очень интересно.
Детали того, как сделали, чтобы было удобнее писать.
Вот, но концептуально тут особо глубокого ничего нет.
Просто очень много правил, которые пришлось вести в язык в связи с этим,
как теперь, что, какая синтактическая запись обозначает.
Вот, но я думаю, на этом можно тему завершить.
Вот, теперь мы формально умеем пользоваться автодекл-тайпом.
Это нам пригодится неоднократно.
Но еще можем теперь явно не объявлять, не упоминать шамлонный аргумент класса.
Ну, иногда я буду теперь тоже пользоваться и structured-binding-ами,
и designed-binding-ами, и shalizer-ами.
То есть, просто, чтобы вы не спрашивали, что это такое.
В своих примерах буду пользоваться, возможно.
Все.
Давайте перейдем к следующей теме.
Следующая тема гораздо более содержательная,
и она у нас тоже займет там, ну, больше одной пары.
Она займет у нас, я думаю.
И мы к ней еще потом будем возвращаться,
и по ней же у вас будет третье задание, называется «Умные указатели».
Наша задача понять, как работают умные указатели,
как они реализованы.
И, конечно, главным образом, как реализован shared-PTR, что он делает.
Что такое умные указатели, я надеюсь, вы уже помните.
И, конечно, это будет очень интересно.
И, конечно, я думаю, что это будет очень интересно.
Реализован shared-PTR, что он делает.
Что такое умные указатели, я надеюсь, вы уже помните.
Мы с ними впервые встречались, когда...
Что ж такое?
Когда обсуждали исключения.
Значит, какая у нас проблема была.
Кстати, у меня, возможно, даже сохранился этот файл.
Какая была проблема? Вот давайте посмотрим, вспомним.
У меня есть...
У меня была какая-то функция.
Ну вот она, f.
И я в ней выделяю какой-то ресурс,
а потом выхожу из функции и, возможно, выхожу нештатно.
То есть у меня...
Я могу нормальным образом из нее выйти,
а могу выйти из-за того, что исключение выбросилось.
И у меня появляется проблема, что если я выйду из исключения,
мне придется вручную дописывать deletePTR в нужное место,
а то утечка памяти будет.
Да и на самом деле, даже если бы у меня не было проблемы исключений...
Господи.
Ну то есть с исключениями это уж прям совсем плохо.
Но даже без исключений, честно говоря,
всякий раз следить за тем, что я написал delete ровно столько раз,
сколько написал new и нигде не забыл.
И если вдруг у меня просто в нескольких местах return,
то я тоже не должен забывать написать delete, прежде чем сделать return.
Сделал не только в исключениях.
Дело просто в том, что если я выхожу из функции разными путями потенциально,
у меня может быть в нескольких местах return написано,
то мне получается надо в каждом месте не забыть delete сделать.
Но это совсем плохо.
Это очень неудобно и, так сказать, error prone это называется,
способствует ошибкам в точкам памяти.
Умный указатель это просто в базовой версии.
Это класс, который конструируется от какого-то ресурса,
ну вот типичный самый такой, наверное, распространенный
базой примера-то от указателя, и в деструкторе просто делает delete ptr.
За счет того, что деструктор локального объекта в любом случае вызывается,
когда мы выходим из функции, delete ptr будет сделано в любом случае.
Вот.
Ну и когда мы это впервые обсуждали, мы говорили о том,
что с этим умным указателем очевидная проблема,
непонятно, например, как его копировать.
Такой указатель там по значению передать в другую функцию –
это уже проблема, потому что чтоб из себя предследовать,
копирование такого указателя.
Это сразу нужно как-то усложнять его конструкцию,
нужно либо считать, сколько еще копий существует от этого указателя,
что они указывают на то же самое, либо указатель нельзя копировать.
А если его нельзя копировать, то тогда его, например, в контейнеры нельзя класть.
Ну так было до C++11.
Ну а вот теперь, когда мы с вами знаем,
му в семантику, то мы можем эту проблему решить легко.
И первое, с чего мы начнем разговор про умные указатели,
это будет, конечно же, unique ptr.
Значит, пункт 12.1 будет называться unique ptr.
Мы не понимаем, как копировать его, как этот умный указатель копировать.
Если мы хотим его копировать, сразу возникает проблема,
надо где-то счетчик вести, сколько еще умных указателей указывают на то же самое.
Но, если мы, например, не понимаем, как это сфотографировать,
то мы можем как-то указать на то же самое.
указано то же самое. Но если мы не хотим копировать умный указатель, мы можем разрешить его перемещать.
У нас же move теперь есть. Когда у нас есть move семантика, не обязательно чтобы типы умели
копироваться, достаточно чтобы они умели перемещаться, с ними в принципе можно будет нормально
работать. Потому что тип, который нельзя ни копировать, ни переместить, это довольно сложный
в работе тип, его никуда не передашь нормально, его в контейнер не положишь, в вектор например. А тип,
который можно перемещать нормально, и вот Unique PTR это как раз классический прям, канонический
пример типа, который move-ать можно, копировать нельзя. Что он на себя представляет? Он на себя
представляет минималистичный совершенно смартпойнтер, который делает вот ровно то,
что заявлено, значит у него есть шаблонный параметр Unique, шаблонный параметр T, он себя хранит,
давайте ладно, я назову его так, как он на самом деле называется, хотя нет, не буду, а то сейчас
опять будет какой-то аргумент до плен влука, по чём-нибудь сломается. Ну вот у меня есть сырой
сишный указатель в полях, а публично у меня есть конструктор от этого указателя, и я просто заполняю
указатель, а диструктор просто делает delete этого PTR. Вот, и что важно, Unique PTR не позволяет
себя копировать. Понятно почему копирование это проблема, потому что тогда два указателя будут
указать на одно и то же, и когда будут удаляться они, ну получается двойное удаление. Ну вот чтобы
такого не было, мы явно запрещаем конструктор копирования и явно запрещаем
копирующий оператор присваивания, но зато мы разрешаем муловающий конструктор. Мы говорим,
что вот такой конструктор, он просто будет, значит, забирать PTR у того PTR, а тот PTR делать
NullPTR. Ну это будет NullXR. Delete NullPTR ни к чему не приводит. Кстати, да, это еще важный,
а нет, Free даже от NullPTR ни к чему не приводит. Вот, ну и теперь я уже могу смело писать для краткости
авто. Значит, я говорю, что PTR, ну мне надо сделать delete сначала моего PTR, потом сделать PTR равно OtherPTR,
OtherPTR равно NullPTR и return this. Ну тут, наверное, опять можно было копить, ой, двойной персент,
ну тут, наверное, можно было опять копии and swap какой-нибудь сделать, ну в общем, все понятно. Вот,
по сути все. Я тем самым реализовал Unique PTR. Вот это по сути почти вся реализация Unique PTR. Почему
почти вся? Ну потому что там еще есть пара полезных методов, такие как Get, это получить
сижный pointer, прям сырой. Еще есть метод reset, сбросить, то есть сделать NullPTR,
тогда удалится то, что лежит под Unique PTR. Но в принципе все. Если вам нужен минималистичный,
с минимумом нынешних расходов Unique PTR, SmartPtr, то вот Unique PTR это ваш выбор. Он появился в
стандартной библиотеке C++11, и он является, еще раз повторю, прям каноническим примером класс,
который move-ить можно, копировать нельзя. Можно ли создать вектор из Unique PTR-ов и pushback-ить
у него, и там этот вектор куда-то передавать потом? Можно, конечно. Только нужно отдавать ему move
от этого сразу. Ну да, положить вектор Unique PTR по значению, то есть если у меня есть Unique PTR-U,
ну давайте вот я сейчас продемонстрирую что-нибудь. std-vector std Unique PTR Attent
v. Вот. Ну и давайте скажу std Unique PTR up равно newint от 5. Я уже не пишу шаблонный параметр,
потому что он должен сам вывести для Unique PTR здесь. Назначу, что он должен понять,
какой Unique PTR от чего. Ну теперь, если я скажу v.pushback up, это будет, конечно же,
ошибка компиляции, потому что... почему? Давайте вопрос в зал.
Нельзя скопировать. Всем понятно? Ну да, нельзя. Нужно по rvlu ссылки отдавать. Это как называется?
Да, у меня все это было не подключено. Сейчас я подключу. Значит, Unique Pointer у нас находится в
memory, а Vector у нас находится в Vector. А зачем тебе Unique PTR подключать? А, потому что ты
я ошибся. Он не справился с выводом шаблонного аргумента. Возможно, потому что нужно было вот так
сделать. Нет, он все равно не справился. Ну что ж поделать, придется я вам написать int.
А нельзя написать Unique PTR up просто от 5? Тогда это объяснить. Нет, нельзя. От указателя нужно.
Нужно конструировать Unique PTR от ресурса. Вот это, кстати, очень важный момент. Вот это очень важный
вопрос, который вы сейчас задали. Это очень типичная ошибка. Вот уверен, что на экзамене многие
люди наложают в этом, когда будут про Unique PTR писать что-нибудь или рассказывать. Нельзя
создавать SmartPointer от T, где T сам объект. SmartPointer создается от C-шного Пойнтера.
SmartPointer New за вас не сделает. Он только Delete за вас сделает. Но New вы сами должны делать,
если хотите создать SmartPointer самостоятельно. Другой вопрос, что есть функция MakeUnique,
которая за вас New сделает, но про нее мы чуть позже поговорим. Но конструктор SmartPointer,
он принимает уже выделенный ресурс. Он за вас ресурс не выделяет. Задача SmartPointer — только
освободить за вас ресурс, не выделить его за вас, только освободить за вас. Поэтому в Unique PTR надо
передавать именно уже указатель. Илья, короче, сделай всем то, что хотел. Ты создал вектор SD
Unique PTR, а у тебя свой Unique PTR. Я думаю, мы хотели его проверить. Нет, я хотел именно STD Unique PTR вам
показать, как работает. Потому что я реализовал Unique PTR не полностью. Я вам показал схему,
как примерно он реализован, но, конечно, не написал туда кучу конструкторов, кучу
вспугательных функций и так далее. Но основной функционал вот так выглядит. Сейчас вектор от него
не получится сделать. Вектор от этой штуки, ну, наверное, получится. Но с точки зрения того,
что я вам хочу показать, разницы вроде не должно быть в поведении. А какую кучу конструкторов ты
пропустил, я не очень понимаю. Ну, вот все эти те, которые он не смог между которыми выбрать,
когда решал, что ему нужно за конструктор вызвать. Ну, у него есть конструктор от устаревшего
авто PTR, от другого Unique PTR, от другого типа, от Unique PTR, от Null PTR, от Пойнтера и еще дополнительного
параметра, кастомная функция удалитель. Ну, он не смог выбрать, вероятно, между, ну, я так полагаю,
он не смог выбрать между вот этим и, допустим, конструктором от Null PTR или конструктором от
другого Unique PTR, от другого типа. Ну, в общем, между какими-то двумя он не смог выбрать,
он не смог вывести типа из-за этого. Не знаю, почему именно он не смог вывести тип.
А, я понял, почему он не смог вывести тип, вероятно, он не смог вывести тип,
потому что он конструироваться умеет не только от T звездочки, а от U звездочки. Ну, то есть,
на самом деле, у него там вот такой конструктор. Это нужно, например, за тем,
что я могу создать указатель на родителя, а подсунуть ему наследника. Вот. Если у меня есть
base и derived, я могу создать Unique PTR на base, а подсунуть ему указатель на derived. Ну, то есть,
тут понятно, написано что-то типа enable if, бла-бла-бла, ну, или даже этого не написано,
просто он CE выдаст, если PTR от того не создается. Вот поэтому он не смог вывести тип, я думаю.
Вот я думаю, поэтому, потому что у него он не только от T звездочки непосредственно может
создаваться, еще от других, ну, грубо говоря, ну да, между родителем и наследником, как минимум,
он может еще создаваться. Ну вот, чтобы в это все не влезать, я хотел на STD Unique PTR показать
поведение. Ну вот, на STD Unique PTR сейчас у меня ожидаемое CE, которое я хотел продемонстрировать,
что, заметьте, кстати, в каком именно месте произошла CE. Ну, мы хотели forward передать,
не получилось. Да, вот смотрите, вы уже теперь должны понимать, что именно сломалось, то есть,
вот видите, где произошло CE, в new allocator.h, то есть, на самом деле, в STD-аллокаторе произошел CE,
а в каком месте, когда мы в векторе делали, ну, клали в вектор объект, там вызвался вот этот вот
оператор new, placement new, вот этого типа от STD forward args a args. Он успешно дошел, то есть,
он прошел через allocator trades, allocator, дошел до функции construct, все это по правильной ссылке
туда передавалось, и вот там, когда оказалось вот это new от blah-blah-blah Unique PTR, от старого Unique PTR,
он понял, что это at all value конструктор, а он удален, поэтому нельзя. Какой выход? Нужно
написать sdmove, понятно. Вот, ну можно было так и не делать, а можно было как сделать. Можно было
сказать v.pushback. Pushback что? Ну, если я напишу так, то это будет опять CE, потому что он не
поймет. А, нет, вот так, наверное, он поймет, какой тип. Нет, не понял, какой тип, почему он не понял.
Возможно, потому что Unique PTR explicit конструктор. Да, вот еще какая история, потому что у Unique PTR
вот этот конструктор explicit. Я думаю, потому что, ну, чтоб не происходило неявной конверсии в Unique PTR,
где не надо, если я не прошу Unique PTR сделать. Вот, я думаю, поэтому он сейчас не смог.
Да, это explicit конструктор. Вот, но я могу написать mplaceback.
mplaceback. И вот сейчас должно все получиться. Теперь получилось все. Потому что в случае pushback он
должен был неявно создать ссылку на код stampersound. Из вот этого это неявный вызов конструктора,
а в случае placeback там уже такого нету, там он явно создает, t из нее и 5. Ну все, вот эта
корректная программа, в ней нет ничего, нет утечек памяти. Но я могу спокойно делать вот так,
и говорить в .mplaceback.new.pt. В это время век три будут релокации там в каком-то количестве,
что-то там будет переладываться. Но все это будет корректно работать, потому что просто при
релокации он умывает старый Unique PTR. В конце все они корректно удалятся. Вот, это Unique PTR. Ну прекрасно.
Давайте вот здесь я остановлюсь и спрошу, есть ли вопросы про Unique PTR, все ли с ним понятно,
вот в рамках того, что я рассказал. Да, Unique PTR очень простой. Если вам не нужно, если вы знаете,
что у вас лишь один объект в каждом интервью, лишь один указатель будет указывать на этот объект,
у вас единоличный владелец у этого ресурса, указателя. Мы потом обсудим другие виды ресурсов,
то есть не только указателей, но пока только указатели с new и delete. То Unique PTR это минимум
латинных расходов, очень простой класс, очень базовый просто. Реализовать его это задача на
тройку просто, ну вот в таком виде, как я сейчас написал. Вот, ну хорошо. Теперь мы переходим к
обсуждению того, как устроен класс. Возможно, ну там, после вектора и мэпа какого-нибудь,
возможно, он входит в топ-3 по полезности в C++, ну после стринг еще. Вот, значит,
один из самых нужных и часто используемых реально классов и плюсах современных — это
shared PTR. Вот если вы где-нибудь придете в какую-нибудь компанию, где прод на плюсах написан,
то именно на современных, не на C, которые маскируются под плюсы. Вот если вы придете в
компанию, в которой люди говорят, что пишут на плюсах, хотя на самом деле пишут на C,
то это другое дело. Но если вы придете в компанию, где реально люди на плюсах пишут,
то вы прям вот наверняка увидите либо shared PTR в куче в коде, либо аналогов своих shared PTR.
Shared PTR — это штука, которая прям очень часто используется, очень нужна. И вы будете ей в дальнейшем
тоже, наверное, хотя нет, у нас, наверное, уже таких задач не будет, но вам предстоит его
реализовать еще самим. Это умный указатель с разделяемым владением. То есть это класс,
который менеджит ресурс и следит за тем, сколько еще объектов, сколько еще таких же указателей
на этот же ресурс указывают. Когда они все умирают, ресурс удаляется. Вот. Эта вещь
появилась в C++11 и завоевала просто мировую популярность, потому что с приходом shared PTR
вам уж почти никогда не надо… с приходом shared PTR вам никогда не надо делать delete самому,
а с приходом еще кое-чего, небольшого улучшения, вам и new никогда не надо делать самому. То есть
современные плюсы, они таковые, что в них никогда почти не надо писать new delete
самостоятельно. Вообще никогда не надо писать new delete самостоятельно, даже так скажем. Все,
что я вам говорил до этого, вы жили в мире лжи. То есть мы вас учили пользоваться операторами new
delete, там писать аллокаторы. На самом деле это все был мир лжи. В настоящих плюсах современных
new delete никто не пишет вручную. Все пользуются shared PTR. Вот. Давайте сейчас я попробую
обсудить в базовом варианте, как он устроен. Ну смотрите, значит, пункт 12.2, basic,
давайте скажу, простая версия of shared PTR. Давайте я так скажу, MVP, shared PTR MVP,
minimum valuable product. Минимальная рабочая версия, короче, shared PTR. Сейчас у нас будет.
Ну с shared PTR как с вектором. Мы сейчас его как-то худо-бедно реализуем, а потом мы поймем,
что есть проблема, о которой мы не подумали, исправим ее, потом через некоторое время поймем,
что есть еще проблемы, опять вернемся, опять исправим ее, а потом, в общем, в несколько
итераций будет shared PTR, и в конце концов вам нужно будет написать полноценный уже shared PTR
с настоящим, с решением всех проблем. То есть то, что я сейчас напишу, это будет такой очень-очень
примитивный shared PTR с кучей потенциальных недостатков. В общем, как с вектором,
как с пушбеком, мы будем к нему еще неоднократно возвращаться. Ну для начала, что мы хотим от
shared PTR? Мы хотим, чтобы мы его могли вот так вот заводить. Shared PTR от it, там, P от new int,
от PT. Вот, дальше я говорю, авто PPR равно P. Создалась копия shared PTR. Там, я не знаю,
вот у меня есть какая-то функция F, которая принимает, хочу сказать, авто, но у меня кажется,
нет C++20, поэтому придется написать. Вот, я могу его сюда передать, и тут что-то сделать.
Get, это штука, которая возвращает мне просто сырой point. Вот, я могу, значит, F вызвать от P. Могу
вызвать F от std move, от P. Вот, все это время shared PTR, ну в одном случае он копируется, в другом
случае он move-ается, но все это должно корректно обрабатываться, и лишь в самом конце, когда все
shared PTR на мой объект уничтожились, там я могу написать еще P равно std move, не знаю, PPR равно,
теперь могу сказать, std move от P. У меня сначала в P лежал такой же pointer, как в PP, я его скопировал,
отдал в эту функцию, он там с ним что-то поделался, уничтожился, локальная копия. Потом я move-нул PPR туда,
теперь в PP NALPTR лежит, а в том локальном P что-то лежит. Оно тоже уничтожилось, но у меня еще остался
жить вот этот изначальный P. Теперь я в PP присвоил его, и в P у меня теперь NALPTR, а в PPL лежит тот самый
изначальный PTR, то есть у меня в одном экземпляре теперь храницы, и только когда все это закончилось,
у меня должен вызваться деструктор моего, ну не деструктор, а delete, вот тот самый PTR,
который в самом начале я создал. То есть я в своей программе постоянно туда-сюда отдаю этот
shared PTR, копирую, перемещаю, присваиваю за меня один на другой, все что угодно делаю, и он все
время помнит так, еще кто-нибудь жив, кто указывает на него или нет, как только никто не жив, все он
удаляет. Вот, наша задача сейчас реализовать минимальную рабочую версию этого shared PTR,
ну и, видимо, на этом мы закончим сегодня. Ну давайте подумаем. Класс shared PTR, значит, как
это должно быть устроено, чтобы это работало. Что мы будем хранить в полях? Ну, очевидно,
будем хранить PTR, и вот мой конструктор shared PTR от T звездочки PTR. Ну, я опять же говорю,
что на самом деле он от U звездочки, где U это, возможно, наследник T, ну это вот те самые детали,
которых мы сейчас не будем думать, он еще explicit. Ну вот, вопрос, давайте сразу, это можно считать
упражнение такое, очень хорошее, для вот чисто упражнение по ОП. Как мне организовать это, чтобы
оно нормально копировалось? Ну, то есть понятно, что я сохраняю PTR в полях, ну и, допустим,
пока ничего не делаю. Вот самое интересное начинается, когда я хочу скопировать shared PTR.
Я говорю PTR, other PTR, и тут возникает интересный вопрос, а как мне вот, собственно, поддержать
счетчик-то? Если среди вас кто-нибудь, кто знает, как это реализовано уже, вот кто знает,
там тому не интересно. Кто не знает, я предлагаю прямо вот сесть и подумать, а что сделать надо?
Мне надо как-то уметь считать, сколько еще shared PTR, но то же самое, что и у меня.
Можете создать им звездочка общей, которая будет обновляться с каждым созданием и уничтожением
shared PTR? Да, ну ты слишком умный, так неинтересно. Значит, обычно люди, когда им задышат этот
вопрос, они проходят три стадии. Первый, давайте сначала две неверных идеи, а потом объясню
верную, но у нас сразу верная идея прозвучала. Скорее всего, многим из вас, тут у нас с нами в
основном со мной общаются всего 3-4 человека, вот остальные, если вас когда-нибудь спросит,
как реализовать shared PTR, вам может прийти в голову идея просто им хранить, помимо этой звездочки,
но это не рабочая идея, потому что она еще будет рабочей, пока у вас две всего, пока у вас единственный
shared PTR и вы копируете LDA2, но когда у вас станет их три, вам нужно обновить этот инт у всех
shared PTR, который у вас есть на то же самое, как вы третий достанете, непонятно. То есть хранить
просто инт наряду с Т не рабочая идея. Следующая идея, которая обычно приходит людям в голову,
это сделать статик инт, ну типа общее поле для всех. Это опять не рабочая идея, потому что тогда у
вас будет общий инт на все вообще shared PTR от инт, а не только на shared PTR с таким PTR. Дальше
люди обычно начинают тупить и говорят, ну давайте заведем какой-нибудь глобальную статическую мэпу,
в которую будем пихать, значит, PTR, а значением будет инт, и мы будем, короче, всякий раз обращаться
к этой мэпе, она будет статической, мы будем смотреть типа, что там это для нашего PTR,
какое там сейчас число и так далее, но это понятно. Отличный план, надежный. Да, очень надежный,
отличный план. Это, конечно, ну он даже рабочий, но слишком сложно. Конечно же, самый простой и
логичный вариант, до которого не все догадываются, это просто завести общий инт звездочку еще,
который будет у всех наших PTR одинаковый, и он будет указывать на число, которое, собственно,
означает сколько еще PTR, но то же самое. Тогда нам при создании нового shared PTR нужно этот
вкаунт инициализировать числом. Секундочку, секундочку, секундочку. Я, конечно, все понимаю,
но если мы двум разным shared PTR дадим один указатель, это нормально, что все пойдет по-плохому?
Это не нормально, это правильное замечание, а это мы никак не починим. Да, еще одно очень...
Можно делать вот в ситуации, когда мы хотим генерировать shared PTR от чистых-сырых указателей,
но при этом чтобы они, то есть не давая их знать о существовании друг друга, но при этом чтобы они
корректно работали. Тут есть что-то более умное, чем хранить глобальную маку? Значит, смотрите, вы сейчас еще
одно очень популярное заблуждение или, не знаю, что такое, мнение про shared PTR вы сказали, что типа,
а как же быть, если мы просто создаем два сырых C-шных поинтера и сконструируем два разных,
один C-шный поинтер и два разных shared PTR от него сконструируем? Что тогда будет? Возможно,
я про это уже говорил раньше, а может быть, забыл, когда мы про исключение говорим. Ну, короче, нет,
умные указатели не защищают вот этого. Это не проблема класса shared PTR, это ваша проблема,
не так, не надо так делать. Вопрос как раз в том, можно ли в таком случае делать что-то кроме
как мабух хранить? Не знаю и знать не хочу, просто не надо не писать никогда самому. Вот так звучит
ответ современный на этот вопрос. Значит, если вы вручную создадите C-шный поинтер и присвоите
двум разным shared PTR, его будет двойное удаление и, конечно, все будет плохо. Shared PTR не защищает
вот этого, они не предназначены для решения этой проблемы, а если вы так делаете, значит, вы
просто не умеете shared PTR пользоваться. Просто решение заключается в том, что не надо никогда
создавать C-шные поинтеры вручную. А как надо их создавать, это мы обсудим в следующий раз,
но для этого есть функция make shared как раз, которая маскирует вызов new так,
чтобы вам не приходилось никогда делать иметь дело с C-шным поинтером непосредственно.
На самом деле правила код стайла говорят, что современный каноничный подход к этому говорит,
что даже конструктор shared PTR явно не надо вызывать, надо просто делать через функцию make shared,
которая за вас делает new. Но вот мы немножечко забежали вперед. Ну, короче, от этой проблемы
shared PTR не защищает, и я не собираюсь эту проблему решать с помощью shared PTR. Понятно? Это важно очень,
надо понимать, что это не та проблема, от которой shared PTR спасает. Просто так не надо писать.
Вот. Ну, возможно, ну да, глобальная мапа бы решила этот вопрос, но у нас нет такой цели решить этот
вопрос. Понятно, что если бы была глобальная мапа, то мы бы от этого защитились, но мы не ставим себе
цель от этого защититься, просто мы говорим пользователям не писать так. Так, окей? Ну вот,
хорошо, теперь что я говорю? Ну, other PTR, ну, теперь я просто говорю звёздочка count,
ну, плюс-плюс звёздочка count. А, ну да, точно, count other.count и вот так. Ну, кажется, это no accept,
а вот просто эта штука не no accept. Ну, давайте для упражнения там, что делает move конструктор.
Ну, он тоже no accept будет. Секундочку, я понимаю, что мы сейчас рассчитываем на то, что new от одного
мта может дать нам исключение. Конечно. Круто. Ты этот вопрос уже задавал однажды. Да, мы... Я думал
про вектор, но ладно. Мы... Да, это сильно. В смысле? Ну, это... Я не могу назвать эту операцию no accept,
даже формально просто не могу назвать. No accept считается, когда нету вызовов не no accept
операторов. Вот просто некорректный код, если я назову это no accept. А, окей. Ну,
есть он скопилируется, но это будет просто нарушение всемыслимых контрактов. Давайте move
конструктор. Ну, что с move конструктором? Ну, всё то же самое. other.ptr count other.count,
а вот тут интересно становится. А что нам надо сделать в move конструкторе?
Ну, вроде ничего, всё. надо сказать other.ptr равно null.ptr и other.count равно типа 0. А вот нельзя же так.
Ну, точнее вот так. Но есть проблемка. Он же указывает на то, что ему можно так писать.
Чё? other.count у нас такой же как count у нас, как можно писать other.count.
А, да, так мы не должны сделать, так мы не должны делать. Сейчас. Да, правильно.
Можно остаться в other.count, мы не должны его тоже null.ptr сделать. Сейчас, подождите. other.count тоже
null.ptr надо сделать. Да, я всё перепутал. Тут как раз всё просто. Да-да-да-да-да-да. Мы создали,
ну, мы просто всё забрали у того и взяли это себе. Всё, ничего больше не произошло. Да, ничего
интересного не произошло. Вот. Да, это move конструктор. Move assignment оператор будет интереснее,
а move конструктор неинтересный. Деструктор. Вот сейчас интересно тоже будет. Чё делать
деструктор? Ну, если other.count и other.count... Ну, я бы сказал minus minus звёздочка count в любом случае,
а вот теперь я говорю, если звёздочка count... Нет, не в любом. В нём же может лежать null.ptr.
Minus minus звёздочка null.ptr это вроде плохо очень. Да, согласен. Ну... Просто если не count, то выходи.
Да, это нам нужно просто вот так сделать сначала, такой разобрать. Теперь мы его вычитаем,
и если обнаружим, что мы были последними, то чё делаем?
Удаляем и то и другое. Delete ptr, delete count. Ну, в общем-то, да, примерно так. Вот. Ну, я не буду
реализовывать копии assignment оператора move assignment оператор. Это неинтересно, это понятно.
Ну вот. Это, в принципе, базовая рабочая версия shared ptr. Ну, в ней есть много проблем.
Первая проблема... Ну, как минимум о двух мы уже упомянули. Первая проблема в том, что этот shared ptr
потенциально таков, что можно создать два разных shared ptr на один и тот же указатель, будет плохо.
То есть мы ещё хотим написать вспомогательную функцию, которая будет маскировать за нас вызовы
new на самом деле. Make shared она будет называться. Ещё проблема, что мы хотим уметь создавать
shared ptr на родителя, когда нам дали наследника. Вот. Но есть и ещё несколько проблем. Например,
такая проблема. Что если у нас будет такая структура данных, в которой несколько shared ptr,
ну, в которой... В общем, что если мы создадим закольцованный список? Если мы теперь всегда
вместо сишных pointer будем использовать shared pointer, то мы можем... У нас может произойти ситуация,
что у нас возник закольцованный список. То есть, ну, в простейшем случае, у нас там есть дерево,
в котором родитель ссылается на ребёнка, ребёнок на родителя, и они все shared ptr друг на друга.
И поэтому, когда мы отцепим всю эту штуку, они оба будут думать, что ещё кто-то на них указывает,
а на самом деле уже больше никто, они недоступны извне. И они не удалятся,
потому что ещё счётчики будут единицей. А должны бы. Понятно проблема?
Мы реально сможем это решить без особых накладок?
Никто не обещал, что не будет особых накладок. Они будут.
А я не понял проблему. Проблема. Мы всё. Мы перешли
на shared ptr полностью. Мы больше не используем сишные пойнтеры. Давай напишем какое-нибудь
двоичное дерево поиска на shared ptr, например, красно-чёрное дерево. Теперь у тебя, у каждого
родителя есть shared ptr на сынове, у каждого сына есть shared ptr на родителя. И вот ты решил
отцепить под дерево. Ты просто стёр... ну, забыл про shared ptr на родителя, на вот этого,
на корень под дерево. По-хорошему бы надо, чтобы всё под дерево удалилось тогда, потому что у тебя
внешний... ну всё, у тебя пропал поинтер на любую из его вершин извне. Но на самом деле ничего не
удалится, потому что они друг на друга ссылаются закольцовано и будут из-за этого думать, что ещё
кто-то на них ссылается. На самом деле уже есть программа доступ к ним потерян. Да, хорошо.
Это тоже проблема, которую тоже нужно уметь решать. Именно эта проблема, кстати, возникает
в сборке мусора. Когда у вас есть, например, ну, когда у вас есть язык со сборкой мусора,
например, java или csharp, то это одна из главных проблем, которая утяжеляет это. Когда у вас
автоматически система сборки мусора следит за... считает ссылки на каждый объект, если у вас
закольцованный список, все ссылаются друг на друга, а внешний указатель потерян, то это нужно
как-то обрабатывать. И вот это существенно утяжеляет процесс сборки мусора. Ну и у нас это вызовет
некоторые трудности, то есть мы на какие-то ситуации будем тоже обрабатывать. Ну и ещё мы
хотим уметь использовать, кроме как delete, ещё кастомную функцию удалитель. То есть мы хотим,
чтобы SharedPtr работал не только для NewDelete, а для произвольного ресурса, у которого своя функция
освобождения. То есть это не обязательно pointer, который delete надо делать. Может быть, что-то другое,
что в качестве удаления нужно другую функцию вызвать. Вообще не связанную с освобождением памяти,
а просто там отпускать какой-нибудь... разъединять соединения, допустим, по сети. Это всё тизер к
следующему разу, то есть у нас много на самом деле проблем, и это я не все ещё перечислил, но вот мы их
всё будем решать по очереди, и в конце концов у нас будет внимание, как работает SharedPtr достаточно
глубоко. Ну а на сегодня всё, пока.
