Смотрите, что мы изучили в прошлый раз. Мы изучили, что бывают задачи, которые перечислимые, но неразрешимые.
То есть, в целом, можно рисовать такую диаграмму Эйлера.
Есть множество перечислимое, есть множество коперечислимое, и есть пересечение и пересечение в точность разрешимой множества.
Это нам критика Теремы Поста. Терема Поста говорит, что множество разрешимо только тогда, когда и оно само перечислимо, и его дополнение тоже перечислимо, то есть оно коперечислимо.
Дальше мы изучали разные задачи. Например, проблема самоприменимости была вот здесь, проблема остановки или остановка была вот здесь.
Коперечислимое мы в явном виде не приводили, но, например, нигде неопределенная программа, то есть множество программ, которые ни на одном входе не останавливаются, будут коперечислимым.
Почему это так? А давайте прямо докажем аккуратненько.
Теорема множества таких П, что для любого Х у от Пх не определено. Вот это множество коперечислимо, но неразрешимо.
Почему оно коперечислимо? Ну, его дополнение, доказательство. Почему коперечислимо?
Ну, потому что его дополнение это множество таких П, что существует Х такое, что у от Пх определено.
А можно еще по-другому написать. Можно написать, что это равно множество таких П, что существует Х и существует Т, такие, что у от Пх останавливается за Т шагов.
Вот. Но вот эта вот часть, после кванторов, это свойство разрешимое.
Получается, что вот это разрешимое свойство тройки Пхта.
Ну и тогда получаем, что дополнение перечислимо как проект разрешимого.
Так, потому что здесь хоть и две переменных, но по ним один тот же квантор, так что можно вместо этого написать, что существует пара из Х и Т.
То есть получаем, что дополнение перечислимо. Ну а, соответственно, само множество коперечислимо.
Так, почему оно неразрешимое? Ну, неразрешимое, потому что, опять же, это на самом деле верно. В самом конце обсуждали про главную нумерацию.
Это вот что неразрешимо. Ну вот, для проблем основки это всегда верно.
А вот для нигде неопределенной это не всегда верно, что оно неразрешимо. Верно только для главной нумерации.
Ну, интуиция такая, что можно посмотреть... Так, давайте на следующую страницу.
Почему оно неразрешимое? Ну, потому что можно рассмотреть... Рассмотрим Q такую, что для любого Y у от Qy равняется у от px.
И тогда получается, что Q нигде не определена. Тогда и только тогда, когда у от px останавливается.
Ну и что же получается? Мы не можем определить, верно ли, что у от px останавливается, значит не можем определить, что Q нигде не определена.
Если бы мы про Q могли определить верно ли, что она нигде не определена, то мы смогли бы про пару px определить верно ли вот это.
То есть мы получаем, что вот это вот неразрешимо. Из этого следует, что вот это вот тоже неразрешимо.
Так, ну ничего, понятно? Но здесь используется на самом деле определение главности или опорно какой-нибудь конкретный язык программирования, что можно...
Что как бы превращение пары px вот в такое Q, это вычислимая задача. Иначе нельзя сделать такую штуку, потому что мы не сможем по px найти такое Q.
Так, ну и еще у нас, давайте я вернусь сюда. Еще у нас был пример задач, которая вообще снаружи не перечислима, не коперечислима.
Эта задача, наоборот, всюду определена. Верно ли, что программа всюду определена?
Значит, вот эта вот задача, она не перечислима и не коперечислима. Но, опять же, только вот для главных нумераций.
Так, ну у нас сейчас самое время вспомнить, что такое главная нумерация или главная универсально училимая функция.
Но я говорю о нумерации иногда, потому что можно считать, что программа или код программы или номер программы это номер функции, которую она вычисляет.
Вот, и можно считать, что, соответственно, универсально училимая функция или тампилятор, можно сказать, задает нумерацию всех вычилимых функций.
То есть номер вычилимой функции это фактически программа, которая ее вычисляет.
Так, ну вот, значит, соответственно, главная универсальная вычислимая функция.
Значит, это у, который берет два аргумента.
Но тут смотрите, я уже много раз говорил, что есть два стандартных подхода, что вычилимые функции определены на натуральных числах.
Это исторически первый подход, или что функции определены на словах из нулей единицы.
Это такой более современный подход, потому что сейчас мы привыкли, что все кодируется битами, поэтому все определяется на словах.
А в 30-х годах прошлого века компьютеров еще не было, так что люди не привыкли к универсальному кодированию,
зато уже много знали про математику, поэтому они, соответственно, любили все натуральными числами кодировать.
Вообще, на самом деле, кодирование оно же не только из компьютерной техники взялось,
но, например, еще из генетического кода, который тоже был открыт в 50-х годах, в 30-х о нем еще не знали.
Поэтому сейчас для нас как-то привычнее говорить про строки, слова и так далее.
Но, с другой стороны, можно и про числа говорить. Это, по крайней мере, короче.
Стандартный символ для натуральных чисел.
Стандартного значения это один символ, а не несколько.
Код. Главная универсальная вычислимая функция U.
Это функция, которая заплывает следующими свойствами.
Во-первых, она сама вычислима. У вычислима как функция от двух аргументов.
Во-вторых, она универсальная, что означает, что для любой вычислимой F,
которая отображает нейтральные числа и нейтральные числа,
существует такой номер P или такая программа P, что для любого x U от Px равняется F от x.
Вот это еще то, что называется полнотап от юринга для языкопрограммирования.
То есть, что можно любую задачу на этом языке решить.
И, наконец, третье свойство, которое и говорит, что это главная универсальная функция,
что фактически можно писать транслятор на нее с любого другого языкопрограммирования.
Тут для любой вычислимой функции двух аргументов
существует S.
Значит, S это всюду определенная, всюду определенная вычислимая функция.
Такая, что для любого P и для любого x V от P и x равняется U от S от P и x.
Вот, то есть, что делает S?
S фактически переводит с языка U на язык V.
То есть, S берет программу P, которая дает какую-то функцию.
То есть, вот это V от P и x равняется какому-то F от x.
И можно сказать, что P это программа для той функции на языке V.
И вот эта вот функция S из программы P делает программу S от P,
которая будет программой для той же самой функции на языке U.
Ну, вот такой транслятор получается.
Значит, в принципе, такой транслятор всегда есть, но для главной он не просто есть,
а он всегда определен и вычислен.
Ну, в смысле, он всегда всегда определен, но он еще и вычислим.
То есть, такая программа всегда есть, но не всегда его можно найти.
А вот для главной всегда можно найти.
Вот.
Хорошо, теперь что я хочу про эти функции сказать?
Так, ну, смотрите, вот если вернемся на эту диаграмму,
то здесь, ну, вот самоприменимость,
самоприменимость это не свойство функции на самом деле.
Потому что для одной и той же задачи можно написать самоприменимую программу,
а можно не самоприменимую.
Ну, например, давайте, почему так происходит, пример.
Например, пусть у меня функция ищет в программе какой-нибудь символ.
Ну, вообще в тексте.
Функция ищет в тексте символ и ищет там твердый знак.
Вот есть файл какой-нибудь кодировки стандартной, кириллической.
И она в этом файле ищет твердый знак.
И если она его нашла, то она останавливается.
А если не нашла, то, соответственно, не останавливается, зацикливается.
Ну, можно сказать, что она ищет, пока не найдет.
Если его там нет, то она всегда будет искать.
Вот такая функция.
Но теперь как ее можно реализовать?
Можно реализовать, что вот символ твердый знак и ищи его в тексте.
То есть все символы сравнивай с этим символом.
Тогда в этом тексте программа есть твердый знак,
и она на своем собственном тексте остановится.
А можно взять другую программу, которая говорит,
возьмите символ ща и возьмите следующую букву алфавита.
И потом эту следующую букву ищите.
Тогда вот в этой программе в тексте такой программы нет символа твердый знак,
хотя она делает то же самое.
Советственно, получается, что одна программа останавливается на собственном тексте,
другая делает то же самое, но на собственном тексте не останавливается.
Поэтому самоприменимость — это свойство конкретной реализации.
Но все остальное — остановка, нигде неопределенность, всю доопределенность и еще куча всего остального —
это свойство не реализации, а свойство функций, которые программа вычисляет.
Какие-то свойства реализации могут быть даже разрешимыми.
Например, что длина программы не больше 1000 символов.
Да, вот это, конечно, разрешимое свойство.
Но с другой стороны, все, наверное, понимают, что если какую-то программу можно написать,
то можно ее сколько-либо раздуть.
То есть если есть программа, реализующая функцию короче 1000 символов,
то можно написать и другую, которая будет длиннее 1000 символов.
Ну уж как минимум за счет написания комментариев.
Даже если комментариев в языке нет, то все равно можно что-то делать.
Бессмысленное, да, но зато оно занимает текст программы.
Ну вот, поэтому какие-то такие свойства могут быть даже разрешимыми.
Но вот все, что связано с функциями, пока у нас было, оно не разрешимо.
Может быть перечислимо как проблема остановки, может быть...
Может быть перечислимо как нигде неопределенность, может быть даже ни то ни другое, как сюда, определенность.
Вот, но вот сейчас я хочу про это доказать теорему, что вот здесь вот может быть только в тривиальном случае,
то есть если свойство всегда верно или никогда не верно, то оно, конечно, разрешимо.
Но если свойство либо может быть как верно, так и неверно, и при этом это свойство функции,
то мы не можем понять, обладает ли данная программа этим свойством или нет.
Так, хорошо, теперь давайте я запишу это.
Так, пусть какое-нибудь А красивое.
Значит, А красивое это множество вычислимых функций одного аргумента.
Значит, такое, что, соответственно, А не пусто и А с чертой тоже не пусто.
Вот тогда теорема Успенского райса
заключается в следующем, что множество таких программ, что программа задает,
А, сейчас, подождите, так, нет, давайте я его аккуратнее сформулирую.
Пусть У это главная универсальная вычислимая функция.
А вот такое вот.
Значит, тогда множество таких П, что у, так, вот тут есть такое обозначение с точечкой.
Значит, обозначение с точечкой означает, что то, что написано, воспринимается как функция только вот от этой точечки.
То есть, П фиксировано, а Х это аргумент.
В общем, множество таких П, что соответствующее сечение лежит в А красивом,
значит, это неразрешимое множество.
То есть, получается, что если есть программы, то есть если есть функция, обладающая хорошим свойством, есть функция, им не обладающая,
то невозможно по тексту программы сказать, вычислямая ей функция обладает эти свойства или не обладает.
Но это если это главная универсальная вычислимая функция.
Так, понятно ли утверждение теоремы?
То есть вот, опять же, если вернуться на нашу диаграмму в начало,
то теорема говорит, что вот эти свойства именно функций могут быть вот здесь, вот здесь, вот здесь, вот здесь,
но никогда не могут быть вот здесь, вот, да, только если это тривиальное свойство.
Так, ну ладно, давайте будем доказывать.
И в доказательстве нам как раз поможет нигде неопределенная функция.
Так, значит, пусть вот здесь такая буква, зета, греческая буква, ее полезно уметь писать, встречается в математике.
Значит, zeta от x это нигде неопределенная функция, нигде неопределенная функция.
И вот, значит, без ограничений общности, без ограничений общности эта функция zeta лежит в а красивом.
Что если вдруг не лежит, мы перейдем к дополнению, да, она же где-то лежит, либо в а, либо в дополнение к а.
Если в дополнение, то мы переименуем дополнение а в а, будем доказывать неразрешимость дополнения,
но а разрешимость, поскольку сохраняется при дополнении, то, значит, для исходного она тоже верно.
А, значит, без ограничений общности zeta лежит в а, и пусть тогда кси, значит, пусть кси лежит...
А, хотя сейчас, может быть, наоборот удобнее. Понятно, что это неважно, но в каком-то варианте удобнее излагать.
Да, вообще, наверное, не очень важно.
Да, вроде неважно, так тоже сработает. Пусть z лежит в а, а какая другая функция кси лежит в а с чертой.
Поскольку свойство нетривиально, то найдется функция, которая в а с чертой лежит.
Так, теперь, что мы делаем? Теперь пусть k, пусть k это перечислимое, перечислимое, неразрешимое множество.
И тогда рассмотрим вот такую функцию.
А, значит, v от nx. Это v не случайно, это мы будем подставлять как раз в определение главной функции.
Значит, v от nx равняется следующему, оно равно кси от x, если n принадлежит k, и z от x, если n не принадлежит k.
Ну, то есть, если вспомнить определение, то вот этот z от x, значит, это не определено, не определено, если n не принадлежит k.
Так, значит, вот эта функция v вычислима, v от nx вычислима.
Потому что на самом деле, можно сказать, что v от nx это будет кси от x умножить на полухарактеристическую функцию k от n.
Да, как раз если n лежит в k, тогда мы единицу умножаем на кси от x, получаем кси от x.
А если n не принадлежит k, тогда мы умножаем на неопределенность. На неопределенность не важно, что мы умножаем, получаем неопределенность.
Что нам и нужно.
Вот, значит, v от nx вычислима. Что тогда нам говорит свойство?
Значит, из свойства главной универсальной вычислимой функции мы получаем, что существует всю доопределенную вычислимая s.
Такая, что для любых nx, v от nx равняется u от s от n и x.
Что же мы получаем? Мы получаем, что если n лежит в k, то тогда для любого x u от s от nx равняется кси от x.
Значит, и тогда получается, что s от n лежит в a с чертой.
Если n не принадлежит k, то тогда получается, что для любого x u от s от nx равно z от x.
И тогда получается, что s от n лежит в a.
Почему это так? Потому что кси у нас лежит в a с чертой, а s от n получается программой, которая ее вычисляет.
Сейчас, наверное, не совсем хорошо вот так вот писать, потому что a красивое, это именно множество функций.
Сейчас это где-то надо вести обозначение.
Давайте напишу так. Здесь a прямое с чертой, здесь тоже a прямое, а где-нибудь здесь я напишу, что a прямое это множество таких p, что...
А, вот эта штука и есть. Я могу просто вот сюда написать a прямое, которое равняется вот этой штуке.
Значит, оно неразрешимо. То есть a красивое множество функций, а a прямое множество программ, которые эти функции вычисляют.
Это немножко разные объекты, поэтому я их по-разному обозначаю.
Вот, соответственно, получается вот это. Что же получается?
Ну, мы получили... Сейчас, что еще раз объяснить?
А, две строки. Вот, да.
Значит, еще раз, смотрите, кси у нас лежит в a с чертой красивым.
Но вот это вот равенство получается, что s от n сдает программу, которая вычисляет кси, то есть вычисляет функцию из a красивого с чертой.
Значит, самой s от n лежит в a прямом с чертой.
Ну и симметрично вот здесь. Значит, z у нас лежит в a, s от n вычисляет программу, которая лежит в a.
Поэтому, соответственно, s от n лежит в a прямом.
Что же мы получили?
Ну, мы получили, на самом деле, мосводимость.
Потому что если тут перейти к дополнению, будет в другую сторону.
Ну, не к дополнению, а к отрицанию.
Значит, к отрицанию получается то же самое, что сверху, но в другую сторону.
То есть в итоге мы получили, что n лежит в k тогда и только тогда, когда s от n лежит в a с чертой.
Но тогда получается, что если s от чертой разрешима, то есть k у нас сводится к s чертой.
Но поскольку k неразрешима, то я с чертой неразрешима.
Ну вот, собственно, все доказали. Нам это и нужно было.
Ну, то есть, да, все-таки надо было там исправить.
Наоборот, тогда бы здесь а получился неразрешимо, но, по сути, это неважно.
Так, ну что, какие-нибудь вопросы?
Ну вот, как исходная диаграмма показывала, могут быть три варианта.
На самом деле, это еще и больше, как мы в следующей лекции узнаем.
В общем, может быть перечислим, может быть ко перечислимо, а может быть ни то, ни другое.
Ну вот, в этом ни том, ни другом, на самом деле, есть больше разных вариантов.
Вот. Так, ну а сейчас вроде и звонок должен быть.
Если вопросов нету, то можно сейчас сделать перерыв.
А потом будет другая великая теорема неподвижной точки.
Так, ну что ж, давайте продолжим.
Может быть, какие-нибудь вопросы появились?
Так, ну ладно.
Значит, тогда я хочу показать пример, как можно построить неглавную универсальную вычислимую функцию.
Как мы будем использовать эту теорему?
Что мы построим такую функцию, для которой эта теорема неверна.
Но при этом эта функция будет универсально вычислимой.
И, значит, она будет неглавной.
Значит, пример построения неглавной универсально вычислимой функции.
Значит, план такой.
Значит, построим функцию, которая будет универсально вычислимой.
Но для некоторой, но некоторое нетривиальное свойство, а будет разрешимым.
Ну а для главного оно должно было быть неразрешимым, значит, это неглавное.
Так.
Значит, рассмотрим множество какой-нибудь...
Ну, неважно, как эти идеи его назовем.
Значит, d, как раз мы с ним уже встречались вначале, это множество где-то определенных функций.
То есть это множество таких p, таких, что существует x, что u от px определено.
То есть это множество где-то останавливающихся программ.
Значит, при этом вот эта u, которая здесь, это обычная универсальная машина тюринга, то есть она-то главная.
Но мы на базе ее сделаем другую неглавную.
Так.
Значит, смотрите, вот это может перечислимо.
Значит, это перечислимое множество.
Но раз оно перечислимо, то вот пусть какая-то функция его перечисляет.
То есть вот это d, значит, d это там d0, d1, d2 и так далее.
Вот как-то мы его перечислили.
Теперь рассмотрим такую функцию.
Рассмотрим вот такую функцию v, v от nx,
которая будет не определено.
Не определено, если n равно 0.
Вот. E равняется u от d с индексом n-1 и x, если n больше 0.
Вот. Тогда что же получается?
D вот здесь. Множество где-то останавливающихся программ.
Множество x, что существует x, что у от x определено.
Так. Ну вот, рассмотрим вот такое вот v.
Ну, утверждаем, что v искомое.
Значит, v искомое.
Почему?
Ну, во-первых, v вычислимо.
v вычислимо как...
Да, ну и нужно...
То есть тут нужно считать, что все эти di-то это конкретные числа.
То есть это не пропусков неопределенных.
А прямо это мы перечислим множество в каком-то порядке.
Вот. Поэтому v вычислимо как композиция вычислимых функций.
То есть нам нужно сначала сравнить с нулем, что, понятное дело, мы умеем.
Потом вычислить, если больше нет, вычислить dn-1,
что какое-то перечисление можно сделать, и поставить v, которое тоже вычислимо.
Вот. Поэтому v вычислимо как композиция вычислимых функций.
Дальше. v универсальная.
Почему? Ну, потому что нигде неопределенное имеет номер 0.
Значит, z от x имеет номер 0.
Вот. А соответственно, все остальные тоже имеют какой-то номер.
Значит, все остальные имеют какой-то номер dit.
Значит, какой-то номер dit. Ну и потом встречаются под номером dit в u.
И потому встречаются под номером i плюс 1, получается.
Значит, под номером i плюс 1 в v.
Ну, вот это d. Значит, d это множество всех где-то определенных программ.
Потому что номеров всех функций, кроме нигде неопределенных.
И, соответственно, наша функция где-то определенная, имеет какой-то номер внутри d.
И тогда, если мы возьмем n как i плюс 1, то как раз та же самая функция появится на i плюс 1 строчке в таблице для v.
Так. Ну чего? Понятно?
Тогда что же получается? Значит, да, универсальность тоже есть.
Но при этом можно по номеру... То есть получается, что n больше 0 тогда и только тогда,
когда существует такой x, что v от nx определено.
Да, и то, что n больше 0, конечно, можно выяснить.
Получается, что нигде неопределенная функция имеет вообще ровно один номер.
И это, конечно, разрешимое множество.
Кстати, получается в следствии с теорией Успенского райса, что для любой функции есть бесконечно много программ.
Иначе это будет конечное множество.
Ну, для обычных языков мы это и так знаем.
Но, опять же, получается, что это следует просто из главности, не из каких-то особенностей синтаксиса.
Ну вот, значит, поэтому...
Ну вот, в общем, свойства где-то определенности разрешима.
Но, следовательно, v не главное.
Ну вот.
Понятны конструкция? Есть какие-нибудь вопросы?
Да, давайте поймём, почему определение тут не будет выполнено.
Это хороший вопрос.
Смотрите, что такое главное по определению, что если у нас есть какая-то ещё нумерация w,
то мы из этой нумерации w можем перекодировать нумерации вот здесь.
И почему мы так не можем сделать?
Потому что, смотрите, если у нас программа для w нигде не определена,
то для неё нужно...
Её нужно перекодировать в номер 0.
Вот, и никак иначе.
Но тогда получается, что там для той w надо было бы определять,
надо было бы понимать, определена exchange programme где-то или не определена.
То есть получается, чтобы корректно перекодировать вот в эту нумерацию,
нужно для той нумерации определять, является ли программа где-то определённой или не является.
Но мы только что увидели, что это невозможно для главной нумерации.
Понятно, да, какова природа.
Там действительно и для где-то определенной можно найти программу,
и для нигде неопределенной можно, но для нигде неопределенной здесь есть ровно один вариант.
И чтобы именно его сопоставить, нужно для то и откуда перекодируем
решать вот эту проблему непустой области определения.
Так, ничего, понятно.
Так, тут я хотел бы упомянуть еще одну теорему,
но, конечно, уже без доказательств, это сложная теорема.
Теорема Фридберга, существует универсальная вычлимая функция,
в которой у каждой функции одного аргумента есть ровно одна программа.
При таковенском программировании удобно проверять олимпиаду по программированию.
Нужно просто сравнивать то, что предъявили, с той единственной программой, которая подходит.
Но, конечно, это совершенно не практический язык, и довольно сложно доказывается.
Но теорема есть.
Так, ну теперь еще одна тема, которую я сегодня хочу обсудить, и еще одна теорема.
Так, знаете ли вы, что такое Куайм?
Да, совершенно верно. Ну, вообще, это фамилия тоже, математика.
Но эта фамилия стала нарисательным понятием.
Это программа, которая печатает свой текст.
Такую программу можно написать на, опять же, любом нормальном языке программирования,
а именно на любом, который задает главную универсальному члену мою функцию.
Ну и, действительно, бывает, что люди развлекаются, берут какой-нибудь язык программирования и на нем пишут.
Есть читерские языки, в которых в язык встроена программа, типа лист, напечатать текст текущей программы.
Еще может быть такой читерский подход с файловой системой, что программа на файловой системе
находит свой собственный текст и его читает и выводит.
Но бывают, конечно, и настоящие Куаймы, которые никакими особенностями среды не пользуются,
а просто сами печатают, и действительно его можно создать.
На естественном языке можно писать такую инструкцию.
Напечатать дважды,
взяв второй экземпляр в кавычке.
Ну и дальше, соответственно, еще раз то же самое.
Напечатать дважды, взяв второй экземпляр в кавычке.
Но действительно, если эту инструкцию выполнить, то она сама и получится.
Ну и более-менее стандартные Куаймы, они более-менее то же самое делают,
используя средства того языка, на котором они написаны.
Но, конечно, можно что-то другое делать.
Теорема стоит в том, что на самом деле на любом языке,
который задает главную универсальному члену функцию, такое можно написать.
Теорема, что на любом языке программирование,
программирование, значит, задающим главную универсальному члену функцию,
существует Куайм.
Вот, значит, и это на самом деле следует из более общей теоремы,
значит, а именно из теоремы к линии о неподвижной точке.
Так, ну а вообще можете при желании поупражняться на своих любимых языках программирования.
Значит, пока в чем заключается теорема?
Ну, смотрите, ничего не печатать и печатать ничего, это немножко разные вещи.
Да, то есть я сказал, что пустая программа, не, но вообще в обычный компилятор,
если вы пустой файл отправите, наверное, он ошибку выдаст.
Это, конечно, зависит там от языка и от компилятора, но скорее он все-таки выдаст ошибку.
Вот, но опять же, она должна, скорее всего, даже если он не выдаст ошибку,
скорее всего, она вообще ничего не будет делать, а она должна напечатать пустое слово.
Это не одно и то же.
Конечно, можно придумать язык, который, получив пустой файл и печатает пустую строку,
но там легкая задача получается.
Теоремы к линии о неподвижной точке.
Так, значит, пусть у, это главная универсаливоченемая функция.
Значит, а h это функция одного аргумента.
Значит, h функция одного аргумента это всюду определенная вычислимая функция.
Тогда существует p такое, что для любого x u от p и x равняется u от h от p и x.
Вот, то есть что здесь происходит?
Значит, здесь h делает какое-то преобразование программ.
Да, h берет программу p, что-то не делает, получает программу h от p.
Но теорема заключается в том, что, чтобы это преобразование не делало,
все равно найдется программа, которая не изменит свои работы после этого преобразования.
То есть тут смысл получается такой, что h это преобразование программ,
но оно, по крайней мере, вычислимое и всюду определенное, то есть во что-то преобразует.
И, соответственно, теорема, что существует программа,
которая после преобразования делает то же, что и до преобразования.
Вот, теперь как это связано с QAIN?
Ну, QAIN в тернах универсальных, значит, QAIN в тернах универсальных вычислимых функций,
ну, наверное, нужно вот так вот потребовать, что для любого x у от px равно p.
А вот это, наверное, нужно назвать QAIN.
Ну, тут вопрос, что нужно в QAIN подставлять, там пустой вход или какой угодно,
но вот здесь решили, что какое угодно.
Вот, ну и тогда, грубо говоря, нужно написать h от p, это программа print p,
значит, напечатать p.
Ну и опять же, такая программа, она для большинства языков просто напрямую есть такая функция,
напечатать что-нибудь.
Но можно ее там доказать для главной универсальной функции непосредственно, что такая есть.
Ну, тогда получается, что у от px равняется у от h от px.
Если p такова, ну, p такова, которая из теоремы, то получается, что у от px равно у от h от px и равно p.
Потому что программа print p выдает p.
Вот, поэтому QAIN существует.
Так, ну чего, понятно.
Так, ну что ж, давайте попробуем доказать эту теорему.
Значит, тут доказательство, на самом деле, не очень длинное, но оно какое-то такое немножко странное.
Там, в общем, немножко как кролика из шляпы достают, не очень понятно, почему вообще так происходят.
Ну вот, в книжке вещей Айкина Шиня там немножко побольше написано, почему такое происходит,
там это как-то погружено в какие-то общие свойства вычтемых функций.
Так, ну вот я попробую, надеюсь, что у меня получится не испортить фокус,
и, соответственно, я достану кролика из шляпы.
Значит, как часто бывает каким-то образом использовать диагональный метод.
Вот, а именно возникает такая странная идея.
Так, значит, вот доказательство, значит, доказательство теоремы.
Так, значит, идея очень странная, да, вообще непонятно откуда взявшаяся.
Но, в общем, применим программу саму к себе, и то, что получилось, воспримем как тоже некоторую программу.
Значит, применим программу саму к себе, и воспримем результат,
воспримем результат как тоже некоторую программу.
Ну, так вообще непонятно зачем, но вроде не запрещено так делать,
и иногда даже осмыслено. Вполне может быть так, что программа делает какое-то изменение в тексте программы, например,
сохраняя ее синтетическую корректность, и тогда она в своем тексте тоже может изменить что-то,
и получится тоже какая-то осмысленная программа.
Вот, значит, что это в серонах универсальных функций происходит?
Значит, я определю, значит, v от x, y.
Ну или, так, сейчас давайте, давайте лучше v от n, x.
v от n, x я определю как u, а u это как раз вот та самая, которая из условия, главное, универсальная.
Значит, u от u от n, n и x.
Ну вот, значит, вот как-то я так и сделал.
Теперь, что нам говорит свойство главности?
Так, значит, и свойство главности,
и свойство главности существует какое-то преобразование.
Значит, существует преобразование s такое, что для любого n, для любого x
v от n, x равняется u от s от n, x.
Так, ну хорошо, значит, вот есть, значит, есть вот такая вот функция.
Так, пока опять же, да, все корректно, непонятно зачем.
Ну ладно, дальше следующий странный шаг.
Значит, теперь рассмотрим,
значит, рассмотрим функцию
t от x, который есть h, ой, нет, h от s от x.
Вот, а h это как раз та функция, в которой мы неподвижную точку ищем.
Сейчас ее пока не было еще. Так, давайте я тут это напомню.
Значит, это у которой ищем неподвижную точку.
Так, значит, и вот это вот h от s от x, это будет сюда определенное.
Ой, так.
Значит, это всюду определенная, всюду определенная вычислимая функция.
Так, теперь свойства главности мы уже использовали, теперь свойства универсальности.
Значит, по свойству универсальности,
по свойству универсальности существует такое q,
что для любого x t от x равняется u от qx.
Вот, ну и теперь утверждение.
Утверждение s, s от q, это неподвижная точка.
Почему же так происходит? Ну, сейчас будет некоторая выкладка.
Сейчас вот все, что на этой доске есть, сейчас сыграет на следующей, и я буду туда-сюда перебегать.
Так, значит, s от q неподвижная точка.
Так, ну давайте посмотрим. Значит, u от s от q и x.
Так, что это такое? Ну, смотрим вот сюда вот.
Да, тут вместо nq. Значит, u от s от qx это v от qx.
Так, ну давайте запишем. У от s от qx это v от qx.
Так, очень хорошо. А что как было v от qx?
А это у нас вот здесь вот. Да, здесь вот эта вот диагональная функция.
То есть это получается, равняется u от u от qq и x.
Ну ладно. Так, значит, это тоже получилось.
Так, теперь что такое u от q и q? А смотрим вот сюда вот.
Ну, u от qx это t от x, а u от q и q это t от q.
То есть это будет u от t от q и x.
Вот, ну и наконец, что такое t от q?
Смотрим вот сюда вот. t от q это h, t от x это h от s от x,
а t от q это h от s от q.
Получаем, что это будет u от h от s от q и x.
Но вот x был произвольным, так что получается, что действительно все верно.
Так, значит, поскольку x произвольный, то теория получается доказана.
Действительно, это самое s от q делает с x то же самое, что h от s от q
тоже с тем же самым произвольным x.
Ну вот, вроде фокус получился, и вроде формально все верно,
но почему нужно делать именно так, не очень понятно.
Ну вот, опять же, величайкие нишени, это погружено в некоторый более широкий контекст.
Написано там про функции, имеющие там продолжение или не имеющее,
и что если у них там нету всю дополнительную члену продолжения,
то у них должна быть неподвижная точка, диагонально его как раз нету.
В общем, рекомендую прочесть, но сейчас более широким контекстом это не будем обсуждать.
Есть какие-нибудь вопросы. Я хотел бы еще про небольшое приложение сказать,
помимо куайнов, но если есть вопросы, то могу ответить.
Ладно, ну хорошо, давайте тогда оставишься пять минут.
Еще одно приложение.
Приложение это рекурсивное программирование.
Почему вообще рекурсия возможна, и что вообще такое рекурсия?
Ну рекурсия означает, что какая-то программа вызывает саму себя с каким-нибудь другим аргументом,
а потом, в свою очередь, еще раз вызывает саму себя с еще другим аргументом,
и так это все спускается до какого-то базового случая.
Бывает что бесконечная рекурсия, типа там, рекурсия, смотри, рекурсия,
там нет условий остановки, она ни к чему не может привести.
На чем основана вообще возможность такой штуки?
Ну обычно в языке программирования есть специальные конструкции для такого,
то есть какая-то подпрограмма, которую можно вызвать и можно вызвать саму себя.
Есть там какой-то процессор, который это все обрабатывает.
Ну а все же, мы так написали программу, почему она там скомпилируется, вообще что-то сделает.
И, например, в машине Тюринга там же нет таких конструкций.
Почему на машине Тюринга такое можно писать?
Ну оказывается, что теория МакЛини говорит, что рекурсивное программирование,
возможно, на любом языке, который соответствует главной универсальному члену и функции.
Ну в каком смысле возможно, я думаю сейчас будет понятно.
Ну, например, есть определение функции факториал рекурсивное.
Что такое функция факториал? Это единица, если n равно нулю,
и n умножить на факториал от n-1, если n больше нуля.
Почему есть функция, которая этому удовлетворяет?
Что мы вообще хотим? Что означает, что программа вычисляет факториал именно по рекурсивному определению?
Ну, давайте напишем.
Значит, программа P рекурсивно вычисляет n-факториал.
Дальше, что она должна делать?
Это означает, что u от P и n будет равняться единице, если n равно нулю,
и cесто n умножить на u от P и n-1, значит, если n больше нуля.
Значит, почему такое P есть? Ну, ровно по терминику линия.
Значит, такое P есть по терминику линии.
Как именно? Ну, смотрите, можно написать так.
Значит, v от P и n будет равно тому же самому.
И n умножить, а здесь u, n умножить на u от P и n-1, если n больше нуля.
Да, уж такое v точно можно написать.
Значит, тут никакой рекурсии нет.
Дальше по теореме, не по теореме, а по свойству главности,
значит, по свойству главности мы получаем, что существует S такое,
что для любого P, для любого n, u от S от P и n равно v от P и n.
А дальше по теореме к линии.
По теореме к линии существует такое P, что для любого n, u от P и n равно u от S от P и n.
Тут очень красивая штука.
Мы берем S из определения главной универсальной функции
и поставим это S в теорему к линии как функцию сюда определенного преобразования.
И к этой S в качестве h применяем теорему к линии.
Ну, в общем, если это все раскрутить,
значит, если все это раскрутить, если взять вот это вот равенство,
потом вот это вот равенство и потом вот это вот равенство,
то получится ровно исходная равенство, которая нам и была нужна.
То есть вывод такой, что рекурсию писать можно, и, соответственно, она точно реализуется.
Спасибо за внимание.
