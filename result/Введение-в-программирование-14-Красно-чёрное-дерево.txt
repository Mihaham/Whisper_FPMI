У нас сегодня последняя лекция, и мы разберем сегодня
красно-черное дерево.
Это еще одна возможная реализация дерева поиска.
Мы прошли с вами уже много, и вот сегодня еще одно
и последнее.
Зачем это нужно мы обсудим в конце.
Мы сравним, построим итоговую табличку, где в чатике
преподавателей.
Сравним все деревья, которые мы прошли, и поймем, чем
это лучше остальных, чем он уступает другим.
В разных случаях нужны разные деревья, поэтому
полезно иметь представление о них обо всем.
Итак, определение.
Красно-черное дерево.
Кстати, давайте я сегодняшнюю лекцию буду писать синим
маркером, потому что, раз оно красно-черное, нам
нужно будет много красного и черного.
Давайте я синий как нейтральный буду использовать для текста.
Дерево поиска называется красно-черным, если выполнять
следующие пять свойств.
Первое.
Все вершины покрашены в красный или черный цвет.
Я красный буду писать Red или Black цвет.
Соответственно дерево по-английски Red Black, Red Black 3.
Второе.
Корень черного дерева имеет черный цвет.
Третье.
У каждой вершины, сейчас не так, сейчас скажу, значит
я хочу сделать следующее.
Я хочу, чтобы у каждой вершины, в которой находился какой-то
ключ, то есть у каждой нормальной вершины, которая покрашена
в красный или черный цвет, было всегда два ребенка.
И причем либо это настоящий обычный ребенок, то есть
обычная вершина ключ, либо это вершина такой лист,
который будет как бы мы будем воспринимать как
на УПТР, как указатель на несуществующую вершинку.
И у этих вершинок, которые как бы указательны на на
УПТР мы будем считать отдельными элементами нашего дерева,
и никакие ключи не хранятся, и они покрашены в тоже чёрный цвет, и так, у каждой вершины ровно два сына,
и они могут быть чёрными нулевыми листьями, они могут быть чёрными
листьями без ключей. Давайте мы сначала это напишем, потом я приведу какой-нибудь пример красно-черного
дерева и поймём о чём идёт речь. Листьями без ключей. То есть у нас как бы будут обычные вершины,
в которых хранятся ключи, а листьями будут выступать только такие вершины специальные, в которых не
хранится ключ, она обязательно чёрная, ну и по сути вот такие, мы просто подвешиваем ко всем вершинам
такие вот листья чёрные, чтобы только внутренние вершины дерева, то есть все не листовые вершины
дерева, отвечали ключам, а листики это только вот эти вот фиктивные чёрные вершины. Четвёртое свойство,
значит, дети красной вершины, красной вершины, так красной внутренним красным цветом, дети
красной вершины,
чёрные. Ну имеется в виду вот что есть красная вершина, у неё есть два ребёнка всегда и они
оба должны быть чёрными, то есть не всё под дерево чёрное, а два непосредственных сына левый и правый.
И наконец пятое, если мы начинаем путь в любой вершины и идём вниз до листа, то на этом пути,
на любом таком пути будет поровну, будет одинаковое количество чёрных вершин, будет
поровну чёрных вершин. Для любого В на любом нисходящем пути от В до листа одно и то же
количество чёрных вершин. Вот, ну то есть, например, вот есть какая-то вершинка В,
например, она сама по себе красная, в ней хранится какой-то ключ. И вот есть там, не знаю, какие-то её
дети, здесь, например, чёрный, здесь чёрный, вот здесь, например, вот эти два листика, которые я
буду обозначать прямогольниками, то есть здесь хранится какой-то ключ, здесь какой-то ключ,
здесь ключ, а вот здесь ключей нет, то есть это чёрные листья, в которых нет ключей, и тогда,
например, вот на этом пути от вершинки В вот сюда вот, есть две чёрные вершины, первая, вот эта
вторая. Соответственно, тогда требование, что на любом таком пути от В, куда-либо вниз, куда-либо до
листьев будет ровно две черные вершины. Вот такое пятый наш требуй. Ну, какой-нибудь пример.
Пример. Значит, в корне обязательно должна быть, корень обязательно черный. Пусть, например,
там число будет 20. Дальше пусть будет что-нибудь красное. Здесь какое-нибудь число 10, а здесь черное
число 25. Здесь, например, я сделаю два вот таких черных листика. И тогда, например, смотрите,
вот если в качестве корня рассматриваете вершинку В, то есть если вы это корень,
тогда вот здесь есть путь, на котором суммарно три черные вершины. То есть В, сын и внук.
Здесь три черные вершины. Тогда, соответственно, на любом пути, не исходящем отсюда, тоже должно
быть три черные вершины. Ну, например, как может выглядеть это дерево. Извините, отсюда это откуда?
Сейчас. От корня. На правом пути вот здесь три черные. Значит, на таком пути, не исходящем
влево, тоже должно быть три черные вершины. Значит, красное. Пусть будет это красное,
тогда мне нужно еще, чтобы было хотя бы две черные. Ну, точнее, ровно две черные. Ну,
пусть я вот такую картинку нарисую. Вот такую. Так, я еще хочу что-нибудь сделать, чтобы...
Одну секунду, я придумаю что-нибудь интересное. Да, сейчас будет. Вот здесь будет черное. Вот здесь
будет один лист, такой фиктивный, в котором не хранится ключ. Дальше будет, в качестве левого сына,
будет какая-то красная вершина, и у нее два черных листа. Ну и, соответственно, числа там,
здесь можно писать что-то в стиле 18, здесь 15, здесь какой-нибудь там 8. Так что это корректное
красно-черное дерево. Например, еще раз, давайте для v проверим пятое свойство. На вот таком пути
3 черных, на таком пути 3 черных, на таком пути тоже 3 черных, здесь 3 черных, здесь 3 черных.
В общем, здесь везде получается по 3 черных. То же самое можно проверить для вот
этих вершинки в 18. Здесь на этом пути 2 черных, на этом пути 2 черных, на этом пути две черных.
для всех это выполняется дальше важно это уже свойство что нет двух красных
подряд то есть дети красная обязательно черная вот ну и все остальные свойства
тоже вроде выполняется вот вам пожалуйста корректная красно-черная дерево
пожалуйста надолго от представлять свойствами давайте спасибо вот значит такие странные
свойства вот какое-то дерево да зачем это нужно непонятно но давайте не знаю то есть кто-то
это придумал давайте поймем почему это вообще работает почему это может быть полезно нам для
реализации каких-то деревьев утверждение если в красно-черном дереве в красно-черном дереве
содержится n ключей повторюсь да что в листьях вот этих вот вершинах фиктивных которые я рисую
прямоугольниками там ключей нет это просто такие фиктивные вершины которые покрашены в черный
цвет просто чтобы нам было удобно считать черную но вот эту глубину да по чтобы нам было удобно
считать число черных чтобы всегда мы заканчивались в черной вершинке на вот этом черном листике
так вот если содержится n ключей вот как в этом случае в этом дереве у меня сколько ключей раз
два три четыре пять шесть то есть есть куча листьев но самих ключей ровно шесть так если
содержится n ключей то глубина аж не превосходит удвоенного двойственного алгоритма вот он присоединен
ну это собственно то что нам всегда нужно да мы хотим чтобы глубина нашего дерева поиска была
как можно меньше вот понятно что она там меньше чем логарифмической быть может иначе у нем просто
не может быть аналиментов вот давайте покажем что здесь максимум удвоен алгоритм
удвоен алгоритм глубина фиктивная вершина всегда чёрная и всегда листья да именно так фиктивные
вершины это вот эти вот листья которые мы подвешиваем к каждой вершинке в которых
содержится ключ ну в смысле если если у нее не хватает детей то мы подвешиваем к ней детей это
это будут фиктивные вершины, листья всегда чёрные, да.
Доказательства. Давайте докажем сначала следующее.
Докажем сначала, что если х это произвольная вершина,
произвольная вершина, а bh от х это так называемая
чёрная глубина, чёрная глубина вершины х, чёрная глубина
это количество чёрных вершин в любом нисходящем пути
начиная с х. Количество чёрных вершин в любом нисходящем
пути из х без учёта х. То есть сам х мы как бы не учитываем
в bh. В этой чёрной глубине мы считаем только более
низкие вершины, сама х не учитывается. Ну и поскольку
у меня есть свойство, что на любом таком пути будет
поровну чёрных вершин, то тогда такая чёрная глубина
правильно определена. Раз на любом пути их поровну,
то можно вести функцию bh от х как длину любого такого
пути, ну в смысле количества чёрных вершин на любом таком
пути. Так вот, если bh – это чёрная глубина, то в поддереве
х лежит по крайней мере 2 в степени bh от х минус
1 ключ. То есть если чёрная глубина какая-то, то этот
дерево достаточно большое, оно экспоненциально большое
то есть 2 в степени bh от х минус 1. Значит, доказывать
этого движения мы будем индукцией по глубине h. Заметьте, не
по чёрной глубине, а просто по глубине х. Докажем это
индукцией по h от х. Не по чёрной глубине, а просто
по глубине. Да, в поддереве, включая х. Да, само х входит
в своё поддерево, то есть в той вот 2 в степени минус
1 х тоже учитывается. А х учитывает х? Что? А х учитывает
самого себя? Ну это уже не важно, давай считать что
нет. Значит, база х равно 0, это значит что х – это
лист и это фиктивная вершина. А фиктивная вершина, там
нет ключей и это чёрная вершина. То есть фиктивная, чёрная – нет
ключей, нет ключа. Ну а что такое 2 в степени bh от х? Минус
1. Ну если х – это лист, получается такая прямоугольная
коробочка, где ничего нет, это просто чёрная эффективная
вершина, где нет ключа, тогда bh от х – это тоже 0. В bh мы
не учитываем х в плане количества чёрных на нисходящем пути,
значит это будет 0, 2 в 0 – это 1, минус 1 – это 0. Ну понятно, что в этом по дереве
ничего нет, нет ни одного ключа, а понятно, что их там хотя бы 0. Значит, база верна.
Дальше переход. Путь это верно для всех вершинок на какой-то глубине не больше, чем какая-то.
Дальше возьмём вершинку х на какой-то фиксированной глубине. Что может быть,
у неё есть два сына. И тогда что у них может быть с чёрными глубинами?
Давайте я левого сына назову у, не давайте л, правого сына назову г. Какие у них могут быть
чёрные глубины? Ну легко понять, что bh от l больше равно, чем bh от х-1, и то же самое bh от r.
Bh, если вдруг вы ещё не поняли, bh – это black height, чёрная высота.
Извините, а х – это любая вершина, и красная и чёрная может быть?
Нет ограничений на цвет. Сейчас я сбился, пишу опять чёрный, давайте синий продолжим.
Итак, если х – это произвольная вершина, у неё есть два сына. Если мы в переходе, то h от х больше 0,
то есть это не лист. У неё есть два сына, левый и правый. У левой вершинки чёрная глубина хотя бы bh от x-1,
потому что мы отрезали максимум одну вершинку. Раньше у меня был какой-то путь нисходящий
без учёта х. Теперь я ещё перестал учитывать l, но понятно, что от этого глубина могла уменьшиться максимум на единицу.
И то же самое с правым сыном, что bh от r больше равно, чем bh от x-1.
Ну и тогда по предположению индукции, поскольку l и r – это менее глубокая вершина, то есть они ниже к листьям находятся,
это означает, что в их поддеревьях здесь хотя бы 2 в степени bh от l-1 ключ, и здесь хотя бы 2 в степени bh от r-1 ключ.
Суммарно, в поддеревье x вершин сколько? Ну хотя бы 1 плюс 1 от x. Дальше 2 в степени bh от l-1, 2 в степени bh от r-1.
Ну и наконец теперь, поставляя вот эти неравенства сюда, получаю как раз то, что нужно. Значит это будет 1-1 сократилось,
2 в степени bh от x-1 плюс 2 в степени bh от x-1 минус 1. Это в точности то, что нам нужно.
Теперь мы доказали, простейшие индукции, просто снизу вверх по нашему дереву, доказали, что если у x-а фиксирована какая-то черная глубина bh от x,
то в поддеревье этой вершины хотя бы вот столько ключей, хотя бы вот столько ключей, то есть вершин с численным значением, неэффективных вершин хотя бы столько.
Так, ну теперь зачем это нам? Ну пусть теперь тогда h это высота всего дерева.
Дальше легко понять, что bh от корня, от рута больше равно, чем h пополам, так как у нас не может быть такого, что идет две подряд красные вершины.
То есть смотрите, вот есть у нас корень, мы знаем, что корень всегда черный, кстати, есть у нас корень, как устроен произвольный путь.
Он как-то спускается, считает количество черных вершин, и при этом там нет двух подряд красных, потому что у нас было свойство, что у красной вершины сыновья обязательно черные.
Значит, на этом пути понятное дело, что черных хотя бы столько, сколько красных.
Ну значит, черная глубина, она хотя бы половина от общей глубины.
Итак, черная глубина от корня хотя бы h пополам, так как у красной вершины, у красной вершины любой сын черный.
Любой сын черный. Ну значит, черных просто на этом пути хотя бы половина.
Вот отсюда сразу следует, что если у меня глубина хотя бы такая, то какое должно выполняться неравенство?
n должно быть меньше либо равно, чем 2 в степени, сейчас одну секунду.
То есть мы знаем, что в дереве всего n ключей, и при этом если высота такая, то в этом дереве как минимум 2 в степени h пополам минус 1 ключей.
Значит, n должно быть больше либо равно, чем эта нижняя оценка. Здесь будет h пополам минус 1.
Ну отсюда как раз следует наше требуемое неравенство, что n плюс 1 больше либо равно, чем 2 в степени h пополам.
То есть h пополам меньше либо равно, чем двоечный алгорифм от n плюс 1.
Ну что то же самое, это означает, что h не больше, чем двойный двоечный алгорифм от n плюс 1.
Доказали.
Вот, если используя просто черную глубину и зная, что не может быть под красной вершинки другой красной вершины, мы понимаем, что как бы на любом пути черных достаточно много.
И раз у меня дерево экспедиционно растет по черной глубине, значит и количество узлов тоже, да, общее количество ключей, но экспедиционно по глубине, значит глубина, наоборот, логарифмична в большинстве ключей.
Доказали. Ну, собственно, это нам и дает нашу любимую логарифмическую оценку на глубину.
Так же, как в ВВЛ дереве, глубина у нас будет всегда логарифмическая.
В отличие от, скажем, сплей дерева, где у нас только амортизировано, все выполняется за логарифм, здесь будет все гарантировано всегда от логарифма,
потому что глубина всегда у нас будет не больше, чем удвоенный логарифм.
Вот. Доказали.
Идем дальше. Ну, давайте скажем, что find в таком дереве выполняется, как в любом дереве поиска.
Как в любом дереве поиска.
С таким мы уже умеем работать, мы просто встаем в корень, понимаем, когда нужно опуститься влево или вправо, и, собственно, ищем х в одном из двух по деревьям.
Это работает за от глубины, то есть за от логарифма.
За от логарифма.
Вот. Значит, это просто сложнее обстоит ситуация с insert и raise.
Давайте к ним перейдем.
Как делать insertX?
InsertX.
А вот как.
Значит, мы сначала сделаем все так же, как у нас было в, скажем, наивном дереве поиска.
То есть мы сначала пытаемся найти этот х в дереве, то есть как-то спускаемся от корня в поисках этого х, и в какой-то момент доходим до вершинки,
у которой, скажем, нужно пойти влево в поисках х, но здесь стоит черный вот этот вот фиктивный лист.
То есть картинка какая-то будет такая. Мы дошли до ключа у.
Он-то может быть черным, может быть красным, это неважно.
И, например, нам в поисках х нужно спуститься влево, а слева у меня стоит фиктивный лист.
Что это означает?
И вот сюда я хочу поместить х.
Тогда я оставляю у как бы неизменным, но в качестве улевого сына я к нему подвешиваю красную вершину х.
То есть я создаю вершинку х, крашу ее в красный цвет, подвешиваю слева к этому саму у.
И к х, поскольку это теперь как бы стало листом, я к нему подвешиваю ссылки на вот эти две фиктивные вершинки.
Они будут обе черные, обе без ключей, они будут листьями.
Вообще, кстати, давайте я здесь же замечу, что на самом деле вот эти вот черные прямоугольники, которые я рисую, вот эти листья,
их не обязательно хранить прям отдельными вершинами в нашем дереве.
То есть не обязательно заводить для них всю память там.
Ну как у нас, в принципе, вершина. Это ссылка на левое сына, на правого сына, цвет, ключ и, возможно, еще ссылка на родителя.
Так вот, у таких вот фиктивных вершинок, у листьев, на самом деле можно просто завести одну вершину, которая будет отвечать как бы всем листьям.
Давайте это запишем.
Можно создать всего одну вершину.
Можно вопрос.
А мы можем хранить просто указатель на фиктивную вершину, как 0ptr?
Это не совсем удобно, потому что нам хочется, как бы нам будет иногда очень хотеться брать цвет от вот этой вот как бы фиктивной вершины.
Но брать как бы цвет и ифать отдельно, что это если 0ptr, то верни, пожалуйста, черный.
Можно так, но классически здесь именно подвешивается вот эта вот одна вершинка, и у нее просто хранится поле, что она черного цвета.
И чтобы как бы это не давало сильного проигрыша по памяти, мы на самом деле заведем одну вершину, вот эту фиктивную, и как бы ее подвесим на место всех листиков.
То есть вообще картинка будет какая-то такая.
Вот если у меня там было много вершинок с листьями какими-то вот такими, то есть если вот это вот мы хотим видеть в реале, то на самом деле мы просто заведем одну вершинку фиктивную,
и они все будут на нее ссылаться в качестве левой правой сыны.
Так, когда вставка будет неудобной, нам во всей структуре придется у всех элементов хранить указатель на нилы.
Ничего не помните, неудобного. Смотрите еще раз. У нас есть отдельная вершина, в которой написано, что она как бы фиктивная.
Что это означает? Это значит, что у нее написано, скажем, в качестве цвета, что она черная, и еще, ну там, например, у нее нет ссылки на левую правую сыну.
То есть у всех нормальных вершин есть ссылка на левую правую сыну, она указывает либо на настоящую вершину, либо на фиктивную вершину.
А у фиктивной вершины, как раз таки, мы будем считать, что ссылка на левую и на правую, это на ЛПТР.
И тогда нет никаких проблем. Вот когда я здесь хочу вставить, когда я останавливаюсь, когда я спустился в вершину, у которой нет ни левого, ни правого сына.
То есть эта вершина как раз вот та самая эффективная. И для вставки я завожу как раз здесь красную вершину Х и подвешаю к ней две новые вот эти вот черные фиктивные вершины.
Так, Максим, нет. Это мы сейчас все пофиксим. Матвей, vertex left nil, потом vertex new vertex будет ошибка.
Что такое vertex? Стрелка new vertex, я не понимаю.
Ну, то есть мы, типа, отдельно храним от вершины на реальную вершину один указатель, а от вершины на nil мы храним другой указатель, потому что nil не обладает теми же полями.
Нет, nil обладает теми же полями. Вот я сказал, что мы вот эти вот узлы, вот эти вот прямоугольнички черные храним на самом деле просто как одну вершину nil, у которой есть все поля.
У нее есть черный цвет, но у нее ссылка на левое правое сыно, это null pointer. Нет никаких проблем. То есть это адекватная вершина, просто одна на всех.
Статик момбра для всего класса. Да, можно так. То есть нам от нее нужно только то, что у нее черный цвет, да, и у нее нету ссылок на левое правое сыно. Да, можно как статик момбра.
Итак, это было просто техническое отступление, как можно реализовать вот это вот подвешивание эффективных черных вершин внизу дерева.
Итак, что мы сделали в инсерте? Давайте возвращаться сюда.
Так что было с y. Давайте считать, не умоляю общности, что мы подвешиваем x слева. То есть что это означало? Была какая-то вершина y, фиг знает какого цвета, может быть черная, может быть красная.
И слева у нее была фиктивная вершина. Левый и ее сын, это вот этот фиктивный лист.
Тогда я вне зависимости от цвета y, давайте это подчеркнем, вне зависимости от цвета y, мы подвешиваем в эту вот позицию красный x.
Ну и соответственно у x создаем две ссылки слева и справа на нулевую вершину, ну точнее на вот эту фиктивную вершину черной прямой.
Сделали так, теперь у меня что-то могло сломаться, конечно же. У меня могло, например, быть так, что если y была красная, то теперь у меня есть две красные вершины подряд.
Может быть, например, такая проблема. Мы сейчас с этим будем бороться.
Давайте пока поймем, какие вообще могли нарушиться свойства нашего дерева при подвешивании вот этой, при вставке этой черной вершины, извините, красной вершины, на место там, где изначально была, был черный.
Если y был красный, будет беда.
Да, это мы уже поняли, да, что если, ну то есть это нарушение свойств, кажется, так, у меня где-то написано номера вся, чтобы удобнее было идентифицировать, да, это будет нарушение четвертого свойства.
Может быть нарушение четвертого свойства, это если y красный.
Ну вроде только его можно нарушить.
На самом деле нет.
Еще одно свойство может нарушаться при при вставке красной вершины.
На самом деле это второе свойство.
Но оно может нарушиться только если изначально дерево было пустое, и вы вставили просто красный x, да, в качестве корня, то есть было пустое дерево, вы вставили x в качестве корня, и тогда, соответственно, корень стал красным, а должен быть черным.
Да, и теперь точно все, теперь никакие другие свойства нарушаться не могут.
Либо второй, либо четвертый.
Давайте с этим разберемся и сделаем так, чтобы свойства все восстановились и никаких проблем не было.
Вот, значит, ну понятно, что если x, давайте вернусь, значит, если x это сейчас корень, и он красный, то это просто первая вершина нашего дерева, давайте его просто перекрасим в черный цвет, тогда все восстановится.
То есть от перекраски корня из красного в черный, понятно, где никакие свойства не поменяются.
Теперь, то есть второе свойство легко как бы фиксится, нужно просто перекрасить x в черный цвет.
Давайте это тоже запишем.
То есть это легко лечится, перекрасить x в черный.
Основная проблема это, конечно, четвертое свойство, вот мы с ним разберемся.
В ходе эффективной киши можно сделать статик.
Да, это уже отсудили.
Итак, какая может быть проблема, когда у меня есть красный x, подвешенный к красному родителю.
Но смотрите, если этот родитель красный, то поскольку из схода до вставки у меня было корректное красно-черное дерево, значит это точно не корень, y не корень, потому что он красный,
значит у него есть черный родитель.
Давайте я этого родителя назову G, grandparent.
Вот есть черный родитель.
Так, давайте ребра я не буду рисовать цветными.
Ребра все-таки синие будут.
Вот, а ключи у меня красный и черный.
Тогда, значит, у меня есть, получается, вешина x, у него красный родитель и у него есть черный, опять-таки, родитель, который является дедушкой для нашей вешки x.
Тогда мы посмотрим на так называемый дядю вешины x.
То есть это второй сын вешины G.
Вот есть уже один сын, это y, и есть второй сын, который мы назовем u.
Слово ankle.
У него есть две опции, либо он черный, либо он красный.
Какого цвета дядя вешины x?
Первый случай, когда он красный.
Значит, случай один.
Когда u красный.
То есть картинка такая.
Есть красный x, есть красный y, есть красный u и есть черный grandparent.
Вот такое дерево.
Ну, соответственно, там слева, справа могут быть подвешенные всякие деревья.
Давайте я не буду рисовать.
То есть понятно, что вот здесь, давайте один раз нарисую.
Вот здесь есть какие-то всякие деревья подвешенные.
Тогда мы сделаем следующее.
Мы просто перекрасим G в красный, а u и y в черный.
Значит, вместо G я рисую красное G.
Вместо y и u я рисую черное y и u, а x оставляю красное.
Все остальное не трогаю, не меняю, не перекрашиваю.
То есть под деревья остаются такими же, как были.
Все ссылки, все связы остаются такими же, как были.
И тогда я утверждаю, что проблема решена.
Ну, во-первых, по крайней мере, здесь локально.
Действительно, мы избавились от двух подряд красных вершин.
Было x и y, теперь якобы их разнес стало здесь чередование.
Ну, а что еще нужно проверить?
Там почти все свойства тривиальные.
Понятно, что все вершины красные или черные.
Понятно, что если мы еще не дошли до корня, то с корнем нет проблем.
Понятно, что все листья у меня остались черными, потому что я листья не перекрашиваю.
Эти эффективные вершины не перекрашиваю.
Самое сложное свойство – это только что сохраняется черная глубина.
Давайте вот за ней последим.
Что вот, например, здесь, если у меня был черный g,
то получается, что на всех вот таких вот путях у меня одинаковая черная глубина.
То есть количество черных, на них нам всех одинаково.
Но теперь смотрите, если я поменял цвета у вот таких трех вершинок,
то ничего, собственно, не изменилось.
У меня, скажем, если вот здесь было суммарно x красных,
ну не x, а k, тогда здесь осталось уже k красных,
потому что я просто поменял цвета у g и у y.
Количество черных, черных.
Количество черных не изменилось.
То же самое здесь.
Я поменял местами цвета у g и у u,
количество черных на таких путях не изменилось.
Поэтому с черной глубиной тоже все будет верно.
То есть с черной глубиной все не раньше сохранятся.
Вот, значит, тогда какие остаются проблемы?
Проблемы могут быть только такие.
Либо у g еще есть родитель, и он опять красный,
тогда мне нужно, как бы, ну, по сути, запуститься рекурсирно
и подниматься наверх, пока я вот это все не исправлю.
Либо же корень.
Тогда давайте просто делаем так.
Вот смотрите, раньше у меня была какая проблема?
Раньше я был сфокусированный вот на этом вот по дереве,
и у меня было, как бы, нарушение могло быть только одно из двух видов.
Либо x – это красный корень,
либо у x есть красный родитель.
Тогда, значит, я делаю, если вот эта ситуация выполняется,
я так перекрашиваю, и теперь проблема сводится вот к такому по дереву.
То есть здесь все нормально,
и единственная проблема в нашем дереве – это либо то, что g – это красный корень,
либо уже красный родитель.
Тогда опять нужно подняться наверх и как-то перекрасить.
Тогда просто я пишу какую-то процедурку, там, не знаю, fix after insert.
Она запускается исходно от вершины x,
и если ситуация такая, то она просто перекрашивает вершины так, как сказано,
и x поднимает в дедушку.
Затем запускается рекурсирно, как бы, в дедушке, да,
и опять делает те же самые проверки.
То есть если есть красный дядя, то нужно перекрасить
и подняться от x на две вершины вверх.
И то же самое, значит, запуститься рекурсивно выше.
Давайте подпишем, что рекурсивный запуск от дедушки g.
Это в случае красного дяди мы просто что-то перекрашиваем, поднимаемся наверх.
Структуру дерева не меняет, только меняет цвета.
Второй кейс – это когда наш дядя черный.
Здесь возникают два случая, в зависимости от того,
является ли x левым или правым сыном своего отца.
Давайте сначала возьмем случай, когда x – это левый сын.
Значит, случай 2.1.
x – это левый сын y.
Что еще раз, если у красный ажек корень?
Еще раз, у нас есть процедура, которая fix after insert,
фиксим после вставки от какой-то вершины x.
Если она красная и корень, то просто ее перекрашиваем в черный.
Иначе у нее есть красный родитель, мы делаем вот такую штуку
и запускаемся рекурсивно от g.
В том случае, в котором вы говорите, мы просто поднялись сюда,
запустились рекурсивно от g, g – это красный корень,
тогда просто ее перекрашиваем в черный, и на этом заканчиваем.
Почему не ломается правило с черной глубиной?
Смотрите, что у меня могло поменяться.
Давайте просто посмотрим, на каких путях что-то изменилось.
Например, вот такой путь.
Путь из g через y вода по дереву.
Теперь он здесь такой.
Сколько на этом пути черных вершин?
Сколько было, столько осталось,
потому что одна красная перекрасилась в черный,
одна черная – в красный.
Какие еще есть пути?
Есть какой-нибудь такой путь.
Тоже самое, одна черная стала красная,
одна красная стала черной.
На всех путях просто можно явно перебрать все пути,
какие здесь есть,
и увидеть, что количество черных вершин
на любом таком нисходящем пути не изменилось.
Вот и все.
Ну и там, например, если смотреть
какой-нибудь родителя, то тоже самое.
Если взять какой-нибудь вот такой вот путь,
то на нем изменились только цвета двух вершин на противоположные.
Значит, количество не изменилось.
И так, значит, в случае, когда x это левый сын y.
Давайте наносим картинку.
Вот у меня есть g.
Нет, не так.
Есть x красный, есть y тоже красный,
и есть черный дядя.
Ну тогда понятно, кстати, что
g обязательно черный.
g обязательно черный,
потому что если y был красным в исходном дереве,
то значит его родители обязательно черные.
У нас не могло быть двух красных подряд в исходном дереве.
Тогда сделаем следующее.
Мы сделаем просто один поворот.
Вот такой вот.
Вот такой поворот.
И потом последующую перекраску.
Значит, поворот как действует.
Если здесь были подвешены какие-то деревья,
давайте их тоже как-нибудь назовем,
a, b, c, d, e.
Тогда как действует малый такой поворот.
Давайте вспоминать.
y станет корнем.
Дальше g переместится сюда,
x переместится сюда.
У останется справа,
но здесь все переподвесится.
a, b, c, d.
Обычный, просто малый поворот,
который мы уже много раз делали,
когда говорили, например,
про овл-деревь или просплейдер.
И теперь назначим цвета всем вершинкам
следующим образом.
Значит, y станет черным.
y станет черным.
x останется красным.
x станет красным.
g станет красным.
u станет черным.
То есть в таком случае
мы сделали один поворот
и такую перекраску вершин.
Давайте проверим, что все хорошо.
Готовьтесь, будет много разных случаев.
Алгоритм не из приятных,
но у него есть определенные преимущества.
Много случаев нужно развивать.
Нам придется это сделать.
Что мы сделали?
Почему все работает?
Понятно, что это осталось дерево поиска,
потому что поворот сохраняется всегда дерево поиска.
Дальше.
Что у нас происходит,
если у нас теперь две красные вершины подряд?
Раньше были две красные подряд.
Теперь такого точно не будет,
потому что, смотрите, у меня y стал черным.
И значит, даже все, что находится выше,
там нет конфликтов.
Даже если у него есть красный родитель,
то все равно здесь нет конфликта.
И выше тоже конфликта нет,
потому что раньше было правильное красно-черное дерево.
Если у меня здесь нет конфликтов,
красное с красным не граничит,
то выше подниматься не нужно.
И я уже исправил все мои дисбалансы.
У меня теперь все хорошо,
в плане, что нет двух соседних красных.
Осталось проверить все про черные глубины.
Давайте посмотрим.
Вот, например, был какой-нибудь путь.
Вот такой, да?
g, y, c.
Теперь это превращается вот в такой вот путь.
Что с ним произошло?
Здесь была одна черная, одна красная,
и какой-то путь в c.
Здесь стало то же самое.
Одна черная, одна красная, и путь в c.
Но если в c правильная черная глубина,
она не поменялась,
значит, на этой пути тоже черная глубина не поменялась.
Что еще можно взять?
Ну, какой-нибудь там не знаю.
g, y, x, b. Вот такой какой-то путь.
Y, x, b.
Что произошло?
По сути, у нас было две красные, одна черная,
а стало одна черная, одна красная,
и путь в b.
То есть черная глубина опять не поменялась.
И так аккуратно тоже...
Давайте не будем это суперподробно дальше делать.
Если просто аккуратно рассмотреть все возможные пути,
то можно легко понять,
что черные глубины не поменялись.
То есть на каждом пути количество черных ошиб не изменилось
за счет вот этих хитрых перекрашиваний.
Вот за счет хитрых перекрашиваний.
Все.
То есть мы выполнили один поворот
и перекрашивания так,
что у меня теперь все свойства опять выполняются.
То есть у меня конфликт
между x и родителем разрешился.
Дальше y теперь не красный.
Если он корень, то уже все хорошо,
выше некуда подниматься.
Но даже если он не корень, то родитель у него...
То есть то конфликта с родителем нет.
Поэтому здесь сразу наш подъем заканчивается.
То есть мы сделали один поворот, и сразу можно завершиться.
Потому что больше конфликтов нет.
Вот.
В случае второй, когда x это правый сын y,
то нужно сделать следующее.
Давайте нарисую картинку здесь.
Что у меня было?
У меня был черный g, черный дядя,
красный y и красный x.
Тогда первое, что я сделаю,
это выполню вот такое вращение.
Тогда что произойдет?
А цвета пока что не меняем.
Тогда g и y останутся на месте.
Зато здесь перекрасится x и y.
И мы свели ситуацию
к 2.1.
Потому что у меня вот эта вот картинка
совпадает вот с этой картинкой.
У меня есть
две подряд идущие красные вершины.
Одна из которых является левым сыном, другой.
У них есть общий...
Дедушка черный, и дядя тоже черный.
То есть картинка совпадает вот с этой,
только там просто x и y поменены местами.
За счет такого маленького поворота
мы как раз таки опять свели ситуацию,
когда есть два красных подряд,
свели ситуацию, что один является левым сыном,
другой.
Мы сводим случай правого сына
к случаю левого сына просто одним поворотом.
На этом разбор инсерта на самом деле закончен.
Можете повторить, почему у x могут быть
какие-то поддеревья после инсерта.
Когда я рисую под деревья,
это не обязательно какие-то ключи,
это, возможно, просто один лист.
В общем случае, это какое-то поддерево.
Это иногда просто черные вершины,
но это тоже поддерево.
Никаких проблем с этим нет.
Более того, мы же иногда,
помните первый случай,
когда дядя был красный,
тогда мы поднялись из x в g.
Мы поднялись на два раза,
и тогда есть какие-то содержательные поддеревья.
Мы же рекурсивно поднимаемся,
и их нужно тоже учить.
И таким образом, что мы сделали?
Давайте резюмируем, как работает инсерт.
Он идет снизу вверх.
Если текущая вершина корень,
то он просто перекрашивает в черный цвет,
потому что проблем нет.
Иначе, если текущая вершина красная,
если у нее черный водитель,
то можно сразу завершиться,
потому что проблем нет.
Давайте я, наверное, пропишу все-таки.
Как работает инсерт x?
То есть мы вставили красный x
на нужное место.
Дальше делаем следующее.
Если x это корень,
то перекрашиваем в красный.
Иначе, если родитель черный,
то заканчиваемся.
Если родитель черный,
то return,
потому что делать ничего не нужно,
а насice,ells Netflix,
у меня есть x,
родитель красный.
Разбираем те два случая.
У меня получается 2 красные вершины подряд.
Если дядя красный,
то мы перекрашиваем,
yourself иверх.
Иначе, если дядя черный,
то мы делаем 1 или 2 поворота.
И затем завершаемся.
Ясно.
Если дядя красный,
тогда мы делаем перекрашивание и подъем.
подъем, то есть фиксим от исходного дедушки, а если дядя черный, тогда мы делаем не больше
чем два поворота, перекрашивание и return. Вот так работает наш фикс после инсерта. Прелесть в том,
что здесь будет максимум два поворота. В итоге вся операция инсерта совершает максимум два
поворота. Совершим не больше, чем два поворота. Более-менее понятно, что это самая сложная
операция. Понятно, что перекрасить можно почти за бесплатно. Это совсем просто. Перепрессивой
одно поле у узла. Нужно просто поменять цвет. А поворот там чуть более тонкая штука. Давайте
нарисую его. Если у меня есть какие-то две вершинки x и p, я делаю поворот вокруг вот этого
вот ребра, то мне нужно поменять кучу всяких ссылок. Потому что у вот этих вот трёх поддерев
меняются родители, меняются дети x, меняются дети p, меняются указательные родители у x, у p.
Короче, много всяких ссылок переставляются. Понятно дело, что из всех этих операций поворот это самое
тяжёлое. По сравнению с переменой цвета, это самое тяжёлое. Прелесть инсерта в том, в красном-чёрном
дереве, что будет максимум два поворота. То есть в принципе таких поворотов, таких дорогих операций
будет не много всегда, будет всего две. Чему у нас при повороте у самого левого ребёнка x меняется
родитель? Ну хорошо, не у всех поменяется. Окей, что у двух из трёх получается? Нет. У одного из трёх
меняется. Окей, да, виноват. Я не прав, да, действительно. Ну окей, не у всех, да, ну у кого-то.
Получается, вот этот, вот перебодрится к п. Виноват, да, вы правы. Так, вопрос в чате, если x корень, то
почему перекрашиваем в красный? Ну потому что у нас было требование того, что корень всегда
чёрный. Есть такое требование. И просто от перекрашивания корня в чёрный цвет ничего не
сломается. Если он был красный, то его можно просто перекрасить в чёрный, и никакие свойства не
нарушатся. То есть чёрная глубина останется корректно определённой везде, не будет двух
подарков красных и так далее и так далее. Все свойства сохранены. То есть так можно всегда
сделать, это ничего не испортит, но обеспечит выполнение новой свойства.
Так, на этом сенсертом я и что-ли мы разобрались. А, блин, что-то я...
Извините, да, тоже право, конечно. Перекрашиваем в чёрный. Да, спасибо. Значит, сенсертом мы
разобрались, поняли, что здесь мало будет поворотов. То есть поворотов всегда не больше,
чем два. Хорошо, теперь переходим к рейзу. Здесь ещё больше случаев, но прелесть будет такая же,
что у нас будет мало поворотов. И это, в частности, выигрыш по сравнению с VL-деревом,
что VL-дерев может быть довольно много поворотов, когда мы делаем эти фиксы. И это преимущество
красно-чёрного по сравнению с VL-деревом. Итак, как у нас работает рейз в наивном дереве поиска?
Мы находим наш X где-то в дереве. В идеальной ситуации, когда у него, скажем, оба сына это
фиктивные листья, мы просто X как-то удаляем, и на его место записываем чёрный лист. То есть
есть есть случай, когда у него как бы ноль. То есть в этом случае мы будем говорить, что у него
ноль детей. То есть дети являются фиктивными листьями. Дальше может быть такой случай.
Может быть случай, что у нас есть X, и у него есть, скажем, только левый сын. Есть только левое
поддерево, а правое это фиктивный лист. В этом случае говорим, что у него один ребенок. Тогда в
таком случае мы тоже знаем, что делать. Надо просто, ну по крайней мере в наивном дереве поиска,
нужно просто вот это поддерево переподвесить на место X. X вынуть, переподвесить вот это дерево
сюда и соответственно здесь будет, ну и это соответственно тоже удалится, соответственно вот
это поддерево будет на месте X висеть. И наконец последний случай, это когда у X есть оба ребенка,
есть оба поддерево, и левое и правое. Тогда давайте также, как в наивном дереве поиска, например,
сделаем следующее. Давайте мы из левого поддерево возьмем максимальный элемент, скопируем его на
место X и теперь удалим максимум из этого поддерево. И поскольку это был максимальный, то у него точно
не будет правого сына, значит если у x два ребенка, два ребенка, делаем как мы это много раз делали,
находим максимум в левом подделье, в левом подделье, копируем максимум на место x и
удаляем максимум из поддерева, и тем самым мы перешли в ситуацию 0 или 1 сын, 0 или 1 ребенок,
ну потому что у max точно нет правого сына, потому что максимум такая вершина, ну точнее нету как бы
настоящего правого сына, там есть ссылка на фиктивный лист, но как бы ключей в правом по
дереве нету, там нету вершин с ключами, вот, то есть мы на самом деле свели задачу удаления,
к случаю вот этому и вот этому, когда есть 0 или когда есть один сын, в случае, когда есть два ребенка,
я показал как разбираем, находим максимальный элемент слева, копируем его на место x, и тогда
вот тот максимальный элемент, который мы скопировали, у него опять, нам его нужно удалить, у него 0 или 1
ребенок, потому что правого точно нету, вот, значит нам достаточно разобрать в случае, когда удаляется
вершина с нулем детей, то есть с двумя фиктивными листями, либо с одним ребенком, то есть один
настоящий лист, там какой-то адекватный по дереву, а второй лист это вот этот фиктивный ребенок, вот,
ну тогда я вот ожидал, что есть всего три случая, три случая, значит первый случай такой, мы удаляем
красную вершину x, у которой оба сына это фиктивные черные листи, здесь решение очень простое,
мы просто заменим этот x на фиктивный черный лист, и все, на этом рейс закончится, здесь все будет
хорошо, потому что смотрите, что мы сделали, мы как бы по сути удалили вот эту красную вершину,
удалили один фиктивный лист, да и по сути подняли один из черных листьев наверх, тогда смотрите,
у меня ничего не сломалось, у меня точно не появилось двух красных подряд, потому что мы
удалили только красную, но и вместо подвесили черную, точно не появился звук красных подряд. Дальше,
у меня не изменилась черная глубина, потому что вот на таких путях, которые проходят через x,
теперь число черных осталось таким же, как было, и вот это в частности ответ на вопрос,
зачем нам это подрешивать, да, потому что вот раньше, если здесь была, то есть если бы не было
листьев, у меня была бы скажем нулевая черная глубина, а здесь мы бы вообще, сейчас,
ладно, плохая иллюстрация, короче, если мы переподвесим черный лист вот сюда, то черная глубина
не поменяется, короче, то есть любой такой путь, он содержал вот этот один лист, ну значит,
он теперь тоже его будет содержать, то есть черная глубина не поменялась, ну и все остальные
свойства тоже выполняются, то есть корень либо не изменился, либо стал вот этим фиктивным
листиком, он остался черным, все вершины это красные или черные, что еще там было, да,
ну вроде все свойства хранили, то есть это простой случай, когда нужно добавить красную вершину,
оба сына которой это фиктивные листины, нужно просто ее заменить на фиктивные листины. Дальше
второй случай, сложный, это когда х это черная вершина с двумя черными фиктивными сыновьями,
вот здесь будет еще более подробный разбор случаев, здесь будет еще много случаев,
которые мы чуть позже разберем, много случаев. И наконец, третий случай, это когда я удаляю вершину,
я удаляю вершину, у которой один сын это черный лист, а другой сын это какой-то поддерев. Давайте
посмотрим, как может выглядеть такая ситуация. Вот есть х, есть справа у него черный лист,
тогда что может быть слева? Давайте подумаем, если слева, а слева какое-то адекватное поддерево,
хотя бы с одним ключом. Если слева есть черная вершина, черный не лист, тогда черная гудна вот
здесь была бы хотя бы двойка, потому что у меня есть вот эта вот черная вершина, и дальше внизу
обязательно мы доходим до черного листа, поэтому здесь не может быть черных вершин, нет черных
вершин. Там могут быть черными только листья, потому что, постройте, иначе вот здесь черная
гудна будет двойка, а здесь однице, противоречие с тем, что у нас, ну то есть изначально у меня
было корректное красно-черное дерево, а здесь оно некорректное, противоречие. Здесь нет черных,
поэтому единственное, что там может быть, это одна единственная красная, то есть здесь просто есть одна
красная, какая-то там Y. Вот, ну почему она одна? Потому что у красной нету, то есть у красной любые
дети черная, но если есть какой-то черный ребенок у нее, то опять противоречие, да, мы сказали,
что нету черных вершин. То есть на самом деле картинка обязательно такая, если мы живем в третьем
случае, то X черный, правый сын у него это черный фиктивный лист, левый сын это красный Y, а у Y
есть два фиктивных черных сына. Вот такой простой разбор случаев позволяет сказать, что в этом
случае обязательно X имеет глубину 2 снизу, да, правый сын пустой лист, левый сын это красный
вершина Y и дальше у него тоже вот эти два черные черные листа из него торчат. Решение здесь тоже
очень простое, то есть как и что мне нужно? Мне нужно из вот этого красно-черного дерева получить
дерево, в котором X выкинуть. Давай тогда я просто напишу на место X, Y, покрашу его в черный и скажу,
что у него есть два вот таких черных сына. Тогда я отуждаю, опять все свойства восстановятся,
ну то есть все свойства не нарушатся, потому что опять-таки не будет двух красных подряд,
потому что если их не было в дереве выше, то им нет куда взяться, потому что я на место вот этого
черного X поставил черный Y, то есть цвета как бы выше не поменялись. Дальше, что с черной глубиной?
Ну вот здесь была какая черная глубина? Здесь была черная вершина X и потом черный лист здесь,
ну здесь тоже самое, черный Y и черный лист здесь. И все вот эти пути имели
одинаково черную глубину, ну собственно так же здесь они все имеют одинаковую черную глубину.
И тот X, который мы хотели удалить, мы спокойно удалили. То есть этот случай тоже простой. Он может
выглядеть только так, только что у меня есть левый красный сын без потомков внизу, и тогда это
просто решается тем, что мы Y ставим на место X и перекрашиваем его в черный. Нет, случай два,
мы сейчас будем активно разбирать. Много случаев, смотри дальше. То есть мы сейчас показали,
что первый и третий случай мы разобрали. Осталось понять, что происходит во втором.
Ну и вот на оставшееся время, видим, мы будем разбирать этот второй случай. Так,
есть ли вопросы на текущий момент? Так, а что было на прошлом слайде? Вот это?
А, ну да, то есть сейчас. Ну как у нас, это надо проговорить или вам надо просто посмотреть?
Ну давайте кратко, то есть если у меня у X есть два поддерева, в каждом из которых есть ключи,
то есть там не только эффективные листья, то мы делаем как в обычном неявном дереве поиска,
наивном дереве поиска. Мы спускаемся в левого сына, находим там максимальную вершину просто
едя максимально вправо, вправо, вправо, пока есть вершина, нашли максимум, значит у него есть
правый сын, но это обязательно черно эффективный лист. То есть справа нет ключей, там только
эффективный лист. Тогда мы максимум копированы на место X и дальше у меня, на самом деле опять,
случай либо вот этот, либо вот этот, потому что う меня есть максимальная вершина, которую нужно
удалить, и у нее нет правого сына, то есть на месте правого сына эффективный лист, поэтому детей
либо вообще ноль, то есть оба сына эффективные листия, либо есть один ребенок только слева,
тогда соответственно вот эта вот ситуация. То есть в случае достаточно расправить когда ноль или один
нормальный сын, вот, но и они здесь все разобраны. А правое под дерево х? Вот это типа? Так а что меняется?
Вот здесь мы просто скопировали значение, у меня вот здесь вот правильное,
корректное красно-черное дерево, мне нужно просто вот здесь разобраться с удалением х,
то есть это ровно то же самое, что было в наитном дереве поиска, мы просто один элемент перетащили
повыше, дерево не сломала структуру, нам нужно просто удалить один элемент, вот этот максимум.
Что? Понятно. Так, если х красный имеет один эффективного сына, если х красный имеет одного
неэффективного сына. Да, вот мы здесь расслужуясь, что такого не бывает.
То есть вот третий случай, когда у х есть один неэффективный сын, тогда окей,
значит давайте повторим, пусть х какой-то непонятный, вот здесь пусть х какой-то
синий, есть один фективный сын, есть соответственно другое под дерево, где есть неэффективные дети,
но раз здесь черная 이번ная единица, значит здесь тоже черная т merely должна быть единица
и поскольку здесь есть обязательно черные листики, то там не может быть черных вершин, значит там
может быть только что-то красное, и это обязательно тогда одна красная вершина y, then x черный,
вот такая ровно, как здесь не рисована, да, вот здесь x не может быть красной, вот в этой
ситуации x не может быть красной, мы это доказали, вот хорошо, значит чего, мы разбираем второй случай,
разбираем второй случай, и давайте мы скажем, что сейчас у нас задачу немножко обобщим,
потому что нам нужно будет ее рекурсивно опять применять, значит задача теперь такая,
задача, было корректное красно-черное дерево, потом что с ним произошло, давайте я вернусь,
вот у меня была категория x с ключом неэффективной высшинка x, и я ее как бы хочу удалить,
понятно, что я ее просто заменю на такой черный прямоугольник, то есть по сути что произошло,
у меня было дерево с черным корнем, и раньше было дерево под дерево с черным корнем, и я его так
поменял, что у него уменьшилась черная глубина на 1, но корень остался черный, значит задача,
было корректное красно-черное дерево, была черная вершина x, так вот вместо него, вместо нее
подвесили опять-таки дерево с черным корнем, дерево с черным корнем, но черная глубина на 1 меньше,
но черная глубина на 1 уменьшилась, потому что у меня там был черный x и лист, было две вершины на
вот этом пути, теперь там осталось только одна, один черный лист, то есть по сути черная глубина
просто уменьшилась, вот, и я буду решать эту задачу, да, то есть у меня что было, у меня есть там
какое-то корректное красно-черное дерево, дальше было у него какое-то под дерево с черным корнем,
с черной глубиной, там vh, потом я как-то его так перестроил, что теперь здесь глубина стала vh-1,
вот, и это теперь все корректное красно-черное дерево,
корректно красно-черное дерево, и моя задача теперь как-то пройтись снизу вверх, пересчитать,
там сделаем какие-то повороты, чего-то перекрасить, так, чтобы теперь глобально,
тоже стало корректно красно-черное дерево, вот, такая будет задача,wię ну, хорошо, значит
я буду треугольником рисовать вот этого дерева, которое изменило свою глубину,
уменьшило свою глубину черную на единицу. Тогда какие могут быть случаи? Давайте будем считать,
считаем, что это дерево правый сын своего родителя. В случае, когда это левый сын,
он симметричен. Правый сын своего родителя. Ну, во-первых, если родителя нету, то делать
ничего не нужно. У меня было корректное красно-черное дерево с корнем в черной
вершине. Мы что-то так сделали, что-то у него изменили, что теперь черный губан уменьшился на 1,
но корень остался черным. И если это был корень, то делать ничего не нужно. У меня было просто
корректное черное дерево, я в нем что-то поменял, осталось корректное черное дерево. Если родителя нет,
то делать нечего, то есть у нас уже все хорошо. Иначе картинка какая-то такая. Вот есть тот
треугольник, который поменял свою глубину, треугольник, который поменял свою глубину,
и есть у него родитель А. Давайте синим его нарисуем. Родитель А. Тогда давайте посмотрим на цвет этой
вершинки. Посмотрим на цвет этой вершины, какой красный, красный или черный. Красный или черный.
Цвет вершинки А. И давайте сначала разберем случай, когда она была красная. Есть мой треугольник,
правый сын, красные вершины. Вот какая такая картинка. Теперь хорошо, я утверждаю, что слева
обязательно есть какая-то вершина с ключом. Почему? Потому что вот здесь исходно была какая-то
положительная, даже не просто положительная, а была черная глубина хотя бы 2. Слева тоже должна быть
черная глубина хотя бы 2, ну и значит здесь обязательно есть хотя бы одна вершина. Раз это
был исходно, красное-черное дерево, то здесь глубина черная хотя бы 2, поэтому здесь есть хотя бы
одна вершинка В. Дальше мы разберем случай по цвету этой вершинки В. Мы фиксировали,
А, нет, тут нет случаев. Скажите, пожалуйста, какого цвета должна быть вершинка В?
Синего.
Так. Чёрная, конечно, да, потому что, раз у меня исходно было корректное красно-чёрное дерево,
то у меня не может быть две красные подряд, поэтому В обязательно чёрная.
Кто ещё раз такой А? Смотрите ещё раз. Треугольник – это то под дерево,
откуда мы удалили х. То есть там было корректное красно-чёрное дерево.
Мы удалили оттуда х, соответственно, чёрное угло уменьшилось на 1.
А А – это родитель этого под деревом. Это родитель этого под деревом.
И мы сейчас разбираем случай, когда А красно.
Тогда слева обязательно чёрная вершинка В. Дальше два случая.
Дальше два случая. Есть ли у В красный сын? Есть ли у В хотя бы один красный сын?
Так, давайте случай 2.1.1. Есть.
Тогда картинка такая. Есть вот этот наш треугольник, который изменился.
Есть красная А. Есть чёрная В. И у него есть красный сын С.
Давайте считаем, что он является правым сыном вершинки В.
Тогда в этом случае я делаю следующее. Мы сделаем следующее.
Мы сделаем два поворота. Это будет первый поворот, это второй поворот.
И перекрашивание. Так что теперь картинка станет следующей.
У меня С останется красной. Но даже здесь перекрашивания получается не будет.
А А перекрасится тоже в чёрный. И будет вот такое дерево.
Наш треугольник будет теперь вот здесь. Справа.
Давайте здесь поймём, почему это будет корректно красно-чёрное дерево.
И я восстановлю все свойства. У меня всё будет хорошо.
Смотрите. Эта штука изменила свою чёрную глубину. Раньше было H, теперь H-1.
Раз раньше было H, то получается, что чёрная глубина в треугольнике А равна H.
То есть вот здесь те подделевья, которые висят, они имеют чёрную глубину.
H-1 здесь, H-1 здесь, H-1 здесь.
Чёрная глубина у них у всех получается H-1. Раз все вот эти вот пути имеют тоже число чёрных решений,
что здесь ровно H, потому что раньше было корректно.
Чёрное дерево. Значит, здесь у них вся гладина H-1.
Теперь я сделаю такие повороты и перекрашивание, что теперь картинка вот такая.
Давайте поймём, что здесь происходит со всеми глубинами чёрных.
Здесь H-1, A, B, C, D. D подвесилось сюда.
Дальше C подвесилось сюда, осталось H-1. A и B тоже подвесились к B, и у них тоже гладина H-1.
Сейчас я на чат отвечу. Что здесь с чёрной глубиной?
Ну, смотрите, просто смотрим. Если встать в вершину C, то у меня любой путь содержит ровно H чёрных вершин,
потому что он проходит через B и под дерево, либо через A и под дерево.
Поэтому у всех вершинок глубина осталась ровно H, такая, как и была.
Если раньше у меня была чёрная глубина H, теперь осталась чёрная глубина H.
По дереве тоже всё хорошо. То есть вот эти все пути, они не изменили свои чёрные глубины, поэтому здесь всё хорошо.
Дальше у меня не может возникнуть конфликта красный-красный, что не может быть двух красных вершин подряд,
потому что, раз раньше было корректное чёрное дерево, то вот здесь не было красного родителя у A.
Ну, соответственно, этот родитель переместился сюда, тут нет двух красных.
В итоге мы исправили все нарушения свойств.
Ничего не означает, нет, это просто рефакт.
В итоге случай 2.1.1 такой, если A красная, а у B есть хотя бы один красный сын,
то можно за два поворота и перекрашивания выполнить все условия, выполнить все наши требования на красный-чёрный дерево.
Значит, следующий случай. Давайте попробуем его здесь уместить.
2.1.2. Это когда нет красного сына.
Такая картинка такая. У меня есть, давайте повторим, красная A, чёрная B слева,
и вот это наша треугольничка, которая поменяла свою глубину с H на H-1 справа.
И смотрите, у B нет красного сына. То есть есть там вот эти два по дереву A и B,
оба имеют красную глубину H-1, и у них у обоих, у обоих по дереве в корне чёрные,
раз мы предположим, что нет у красного сына.
Тогда преобразование следующее. Здесь даже не будет переподвешивание, здесь будет просто перекрашивание.
Мы поменяем цвета у A и у B. Будет тогда чёрная A и красная B.
А всё остальное останется таким, как было. Здесь A, B, здесь наш треугольничек, C.
Тогда что происходит с глубинами? Раньше была чёрная глубина H, теперь стала H-1.
Ну, в смысле, это то, что произошло вот в этом по дереве C.
Что теперь здесь? Здесь у меня чёрная глубина H, потому что здесь H-1, ещё одна чёрная вершинка A,
поэтому здесь всё хорошо. Здесь тоже будет H, потому что одна чёрная и H-1.
И здесь тоже всё хорошо, потому что здесь одна чёрная A и H-1 от A-1 приходят.
Значит, чёрная глубина – это вершинки правильные. Опять-таки конфликтов красный-красный нет,
потому что, смотрите, у B нет красного сына, значит, оба вот эти вот корня, вот здесь вот, они чёрные,
соответственно, вот здесь происходит чёрный вершин. Поэтому конфликтов красный-красный нет.
Единственный конфликт, который мог бы появиться, он был бы вот здесь вот.
Но поскольку вершины красные, то конфликта нет. У нас появляется красная и чёрная,
тогда выполняются все свойства. И опять-таки мы что-то перекрасили, у нас выполняются все свойства,
и мы восстановили опять корректность красно-чёрного дерева.
Так, хорошо, это был случай 2.1, то есть, когда A это красный, а это красный.
Так, хорошо, значит, это мы сделали. Теперь нам осталось разобрать противоположную точку,
а чёрный. Здесь будет опять-таки несколько кейсов. Ничё случай 2.2, а чёрный.
Вот есть чёрный A, вот есть под дерево справа от него, который уменьшил свою чёрную глубину,
аж наш минус один. Теперь давайте разберём, какие могут быть цвета у левого сына A,
какие могут быть цвета у вершинки B. Цвет B.
Так, сейчас, одну секунду.
Да, значит, случай 2.1 получается. Да, это когда у меня B красный.
Так, ещё раз, сейчас, одну секунду.
Да, и потом будет случай, когда он чёрный. Так, всё хорошо.
Значит, пусть вот A, пусть B теперь красный у нас.
Тогда что у него происходит? Давайте перерисуем.
Вот есть A, вот есть B, вот есть под дерево аж минус один.
Можно ещё раз, что в корне под дерево аж минус один.
Это значит следующее, что вот здесь было раньше, здесь в качестве поддерево
висела корректное красно-чёрное дерево с корнем в чёрной вершине, с чёрной глубиной аж.
Потом мы как-то над ним поиздевались, так что это осталось корректное красно-чёрное дерево
с корнем в чёрной вершине, но теперь у него чёрная губина на 1 уменьшилась, вот это означает, что губина уменьшилась.
Соответственно, всё, что выше, было тоже корректно, красно-чёрное дерево,
просто теперь вместо правильного дерева справа висит дерево губины на 1 поменьше.
Соответственно, у меня могла сломаться чёрная губина.
Итак, Б красный. Теперь опять-таки два случая насчёт того, есть ли у Б красные дети.
А нет, не так. Красных детей точно нет, он виноват.
Оба ребёнка у Б, конечно же, чёрные.
Опять-таки, раз H хотя бы двойка, здесь должно быть хотя бы две чёрные вершины на пути.
У него есть обе чёрные вершины, давайте рассмотрим правого чёрного сына.
С обязательно чёрный.
И здесь два случая. Есть ли у С красный сын?
Соответственно, случай 2,2,1,1 получается, это когда есть.
Нарисуем. Значит, есть А, есть левый сын Б, у него есть правый сын С,
ну и, например, левый сын D красный.
И справа к А подвешен треугольник, который поменял свою губину.
Тогда я сделаю следующее. Я опять-таки сделаю два поворота и перекрашивание, чтобы получилось вот как-то так.
Сначала вот этот поворот, потом вот этот поворот.
Тогда будет следующее. С встанет в корень, и я покрашу в чёрный.
А станет справа, я тоже покрашу его в чёрный.
Здесь будет Б, здесь будет D.
И, соответственно, вот этот наш треугольник, он переподвесится в качестве правого сына.
Он останется в качестве правого сына УА.
Соответственно, всё, что было здесь, всякие вот эти под деревья, я их даже здесь явно не рисую.
Давайте я один раз их навесую, что вот здесь есть под дерево, вот это, вот это, вот это.
Они все, соответственно, сюда переподвешиваются в правильном порядке, так чтобы было правильное дерево поиска.
Все под деревья также подвешиваются.
Значит, теперь что происходит, почему всё починилось?
Значит, смотрите, у меня чёрная губина, вот здесь вот раньше была H плюс 1.
То есть чёрная вершинка А, и H была вот отсюда.
Соответственно, здесь тоже везде H плюс 1.
Теперь что происходит от вершинки С?
Есть чёрная С, есть чёрная А, и здесь глубина H минус 1.
Поэтому чёрная губина осталась такая, как надо, H плюс 1.
Значит, 1 плюс 1 плюс H минус 1, это H плюс 1.
Какой-нибудь путь здесь.
Значит, здесь есть две чёрные, и здесь есть тоже под дерево с глубиной чёрной H минус 1.
У них у всех глубина, конечно, H минус 1, потому что здесь была одна чёрная.
Вот, ну и так далее.
Короче, легко убедиться, что опять-таки у всех под деревьев здесь выполняется свойство про чёрную губину.
И нету двух красных подряд, и их не появится нигде сверху.
Поэтому мы на самом деле можем сразу завершиться.
То есть мы опять сделали два поворота, сделали перекрашивание и избавились от всяких нарушений и свойств.
Вот так.
Значит, противоволожный случай.
Что получается?
2, 2. Не знаю, что я их номирую, но ладно.
2, 2, 1, 2, когда у С нет красного сына.
Что мы такое видели?
Тогда нужно просто С перекрасить в...
Тогда нужно будет С просто перекрасить в красный, и всё будет хорошо.
Значит, тогда картинка такая.
Так.
Вот здесь треугольник, который поменял высоту, и у С нет красных детей.
И у С нет красных детей.
Тогда мы делаем просто один поворот вот здесь.
И будет следующее.
Будет чёрная В, справа чёрная А, и слева красная С.
Ну и синий треугольник останется вот здесь.
За счёт того, что у С нет красных детей, я её могу спокойно перекрасить в красный.
Когда не возникнет конфликтов вот с этими двумя детьми, не будет конфликтов красный-красный,
потому что там не было красных детей.
И оба вот этих под деревом начинаются с чёрной вершинки.
Поэтому здесь тоже будет чёрная вершина в корне.
Противоречий красный-красный не будет.
Ну и с чёрной губиной тоже всё хорошо, потому что раньше у меня была чёрная губина H+,
чёрная вершинка А, и раньше была H.
Здесь стало сколько?
Здесь есть чёрная В, чёрная А, и H-1.
Тоже самое, H+.
Какой-нибудь путь влево, например, что здесь было?
Раз у меня было исходно H+, то вот здесь вот было под дерево с чёрной губиной H,
и оно сюда и подвесилось, получается, здесь H+.
Соответственно, все остальные пути можно также перебрать,
убедиться, что у них чёрная губина не изменилась.
То есть какая была в исходном дереве, такая стала и теперь.
Ну и тоже можно завершиться.
Я исправил все нарушения чёрной губины, и стало всё опять хорошо.
Можно завершать наш рекурсивный подъём, который исправляет все нарушения свойств.
Осталось нам два случая.
Это когда и А, и Б чёрные.
Давайте вернёмся.
Да, мы фиксировали уже, что у нас А это чёрный.
Дальше мы предположим, что он красный.
Соответственно, случай 2.2.2 – это когда А чёрный, и Б чёрный.
А есть Б, оба чёрные.
А подвешено справа дерево, уменьшившее свою чёрную глубину.
Теперь опять тоже наш любимый вопрос.
Задаём себе, есть ли у Б красные дети?
Есть ли у Б красные дети?
Ну, соответственно, первая кесть – когда они есть.
2.2.2.1 – есть.
А есть Б, оба чёрные.
А подвешено справа дерево, уменьшившее свою чёрную глубину.
2.2.2.1 – есть.
Опять давайте его нарисуем справа.
Пусть он будет красный, красный Д.
Тогда здесь будет опять-таки два поворота и перекрашивание.
Первый поворот, второй поворот.
Это сведёт нашу ситуацию вот к следующей.
Д вылезет в корень.
Мы его покрасим в чёрный.
А у нас будут все вершинки чёрные.
И синий треугольник будет справа.
Опять-таки можно убедиться, что всё сохранится.
Все свойства, какие были, такие останутся.
Например, вот здесь исходно была глубина чёрной глубины h плюс 1.
Вот здесь она теперь какая стала?
Раз, два, плюс h минус 1, то есть в точности h плюс 1.
Такая, как нам нужно.
Дальше здесь какая глубина?
Здесь одна чёрная, вторая чёрная.
И деревья были вот здесь вот у b.
Но здесь была глубина, видимо, h минус 1,
потому что была чёрная-чёрная, значит здесь обязательно h минус 1.
Ну и здесь опять осталась чёрная-чёрная и h минус 1.
С чёрной глубиной всё хорошо.
Противоречие красная-красная соседей у нас не появилось.
Значит, мы опять всё исправили, и на этом можно завершиться.
И, наконец, самый плохой случай, последний случай 2222,
это когда нет красных детей.
То есть ситуация такая, есть у нас a, есть слева b,
есть под дерево, который изменил свою глубину,
и здесь нет красных детей у b, то есть оба сына чёрные.
Вот здесь чёрный корень и здесь чёрный корень.
Тогда мы сделаем следующее.
Мы перекрасим b в красный
и запустимся рекурсивно от a.
Рекурсивно вверх.
И вот здесь, обратите внимание, здесь самый важный случай.
Все остальные просто какие-то условия,
когда можно за 1-2 поворота и перекрашивание всё сразу исправить,
а вот здесь нужно придётся подниматься выше.
Значит, смотрите, пусть a чёрный, и b чёрный,
и у b нет красных детей, тогда оба ребёнка чёрные.
То есть вот здесь чёрные, вот здесь чёрные.
Слева и справа чёрные по дереве.
Тогда вспоминаем, у меня вот здесь было корректное под дерево
с глубиной h, стало с глубиной h-1.
Тогда что я сделал, когда я поменял цвет вершинки b на красных?
Во-первых, у меня не возникло конфликтов красный-красный,
у меня у b не было красных сыновей.
У меня теперь у b только чёрные дети,
и перекраска его в красный цвет ничего не сломает.
Но зато, смотрите, я уменьшил глубины вот этих всех чёрных путей.
То есть здесь раньше была чёрная глубина h-1,
раз раньше здесь была h-1, то здесь была раньше h-1,
а теперь стала h.
Я уменьшил за счёт перекраски одной чёрной вершины в красный цвет,
и я уменьшил чёрную глубину на единицу.
Поэтому все это теперь это корректное красно-черное дерево
с корнем в чёрной вершине,
у которой чёрная глубина уменьшилась на 1 по сравнению с исходом.
Это как раз та задача, которую мы решаем.
Раньше это выполнялось для под деревом,
здесь было какой-то корректно красно-черное дерево,
у которого уменьшилась чёрная глубина на единицу.
В случае вот в этом… я могу так перекрасить,
что теперь у меня вот это будет корректное красно-черное дерево,
из которого чёрная губна уменьшилась на 1 disproportionately с исходом.
Потому что здесь уменьчилась на 1 и здесь уменьчилась на 1 чёрная губина.
Всё, я просто поднимаюсь в А и запускаю опять разбор случаев рекурсивных,
то есть у меня опять есть функция, которая стоит в какой-то вершине,
в которой поменялась вот это наше свойство, то есть что уменьшилась губина на единичку.
Просто поднимается, там все случаи перебирает, если что поднимается вверх,
опять рекурсивно что-то делает, либо делает trying to Göwoって перекрашен.
На этом и рейс мы тоже разобрали.
Я сразу скажу, что здесь можно ничего в принципе не пугаться.
К экзамену не нужно будет учить все эти 9 случаев, которые мы разобрали.
6 тут и 3 в инсерте.
Я сделаю какую-нибудь паркалку, на которой будут написаны все эти повороты,
потому что я считаю, что не нужно держать в голове.
Нужно просто понимать, как все случаи достаточно разобрать.
Что их достаточно для решения.
Но их все заучивать, конечно, это убиться может.
Итак, давайте напоследок я формулирую, чем все наши обсужденные деревья лучше.
Где их можно применять, где они оптимальны.
Красно-черные деревья, red-black деревья.
Какие у них плюсы?
Плюсы в том, что во-первых, всегда работают от логарифма,
потому что глубина всегда ограничена логарифмом.
И плюс еще в том, что всегда не больше, чем два поворота.
Всегда не больше, чем два поворота.
Я говорил, когда мы сделали инсерт, что самое тяжелое во всех этих перебалансировках,
это, конечно, поворота, потому что поворот включает в себя много всяких присвоений указателей.
И хотелось бы, чтобы было как можно меньше.
Вы поняли, что и в инсерте, и в эрезе таких поворотов всегда максимум два.
И это выгодно отличает red-black от avail.
Значит, в red-black всего максимум два поворота.
Но давайте я напишу минус.
Глубина может быть примерно два логарифма.
Значит, по сравнению с avail деревом, у него плюс тоже, что всегда за от логарифма,
потому что глубина всегда от логарифма.
У него было что-то в стиле логарифма по основанию phi от n,
дефец золотой сечения.
Насколько я помню, грубо говоря, это что-то в стиле полтора логен.
То есть глубина у avail чуть меньше, чем у red-black.
Поэтому если вы пишете red-black, то вам нужно будет в константу раз дольше спускаться.
Примерно полтора логарифма.
Сейчас я в чат вернусь.
Минус, может быть много поворотов по сравнению с red-black.
Red-black всегда максимум два, а в avail их максимум вплоть до всей глубины.
Возможно, все дерево придется поворачивать.
То есть подниматься наверх и для каждой вершинки делать поворот.
А про все остальные деревья мы знаем их преимущество.
Сплей минус его то, что он амортизированный и может на какие-то запросы отвечать долго.
Но его плюс в том, что он частые запросы хранит близко к корню.
У декартового дерева плюс, наверное, в том, что он проще всего пишется.
Минус в том, что он вероятностный и опять-таки на какие-то вопросы может долго отвечать.
У B дерева плюс в том, что оно работает с огромным массивом данных.
А минус в том, что оно не дает выигрыша по сравнению с red-black или avail.
Похожие посложности, всякие процедуры, повороты, сплиты, мержи и так далее.
На малых массивах данных лучше писать avail или red-black.
Последнее, что скажу, это что чаще всего именно на red-black деревьях реализуется STD set и STD demo.
Это вроде как не требуется в...
Ну, короче, это не требование компилятора, но большинство реализует их именно через красно-черное дерево.
Так, вопрос.
Рейс из-за 222 не может идти вверх до корни, совершив кучу действий хоть при пнастке?
Может, может, но повторюсь, это гораздо более простое действие, чем поворот.
Даже подняться в корни, подняться в родителя и сделать перекрашивание, это проще, чем сделать много поворотов.
Он может подниматься, но, смотрите, если мы все равно спускаемся до этой вершинки,
то потом подняться обратно, в принципе, это не очень сложно.
Нужно просто пройтись в обратном порядке по тем вершинам, которые мы прошли, если нужно перекрасить.
То есть у RedBlack меньше константов?
Даже несмотря на то, что глубина немного больше, чем у AVL?
Еще раз.
Ну, не совсем.
Сейчас скажу.
У AVL меньше константов...
У RedBlack можно сказать, что меньше константов в инсерт и в рейс.
То есть он оптимальнее с точки зрения инсертов и рейзов,
а AVL оптимальнее с точки зрения файлов, скажем так.
То есть здесь хоть глубина побольше, но зато поворотов всяких меньше.
А здесь Find лучше, потому что у него глубина меньше,
а поворотов не надо ни в AVL, ни в RedBlack.
Не нужны повороты при Fight.
То есть, соответственно, опять зависит от задачи.
Если у вас более-менее фиксированная база данных,
и нередко поступает запрос изменения, то, наверное, лучше AVL.
Иначе, если она часто динамически меняется, то, наверное, лучше RedBlack,
хоть Find чуть-чуть подольше работает в константу раз.
Но зато инсерт и рейс будут эффективнее, чем AVL.
Вот, если нет вопросов, тогда всем спасибо за большое внимание.
Увидимся на экзамене. Удачи на зачете и на экзамене. Всем пока!
