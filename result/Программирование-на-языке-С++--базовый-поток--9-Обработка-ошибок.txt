Всем добрый день, давайте начнем. В прошлый раз мы с вами начали обсуждать тему обработки
ошибок в C++ и рассмотрели несколько способов, как это можно было бы сделать уже с существующими метами,
то есть теми метами, которые мы уже знаем. Давайте кратко по ним пройдемся. Первый метод это
просто добить. Мы просто-напросто говорим о том, что ошибки существуют, соответственно,
если происходит какая-то ошибка, то ничего с этим делать поделать не можно, программа просто падает.
Понятное дело, чем плохо это способ, это способ плохо тем, что если мы пишем какое-то приложение,
отдаем его конечному пользователю, то пользователю возникает какая-то ошибка,
ему нужно либо программу перезапускать, либо обращаться в соответствующий справочник,
обращаться в компанию, которая предоставила ему это приложение, и спрашивать, а что за ошибка,
как мне с ней справляться. Поэтому хотелось бы иметь некоторую возможность справляться с ошибкой
изнутри самого кода. Грубо говоря, если у меня в коде при вызове библиотечной функции возникла
ошибка, я бы хотел иметь какую-то возможность продолжить нормальную работу, например, либо
постараться воспользоваться какой-то другой функцией, либо напечатать какое-то осмысленное
сообщение на экран, что скажем, на системе не хватает памяти, сходить купить новую плашку и так далее.
Или просто справиться с проблемой, изменить входные данные, как-то еще раз их проверить и так далее.
Соответственно, какие есть для этого способы? Первый способ это использовать некоторую глобальную
переменную, в которой мы будем записывать код ошибки. Соответственно, функция отработала,
дальше в эту глобальную переменную она записывает, что вот функция завершилась кодом ошибки 0,
или с кодом ошибки 1, 2 и так далее. В чем проблема? Понятно. Для каждой функции у меня
будет свои коды ошибки, то есть для каждой функции будет своя интерпретация того, что такое код
ошибки 1, 2 и так далее. Плюс необходимо проверять эту самую глобальную переменную. И плюс если
мы пишем какую-то многопоточную программу, или программу, в которую используют несколько потоков,
несколько процессов, которые используют одну и ту же глобальную переменную, то соответственно
у нас мы теряем возможность узнать, а какая функция записала, условно, эту переменную. Вообще все
проблемы с синхронизацией, нескольких потоков и так далее у нас в этой программе будут присутствовать.
Следующий подход, который очень часто используется, по сути, де-факто является основным способом обработки ошибок в языке C.
Это, соответственно, способ, при котором мы из функции возвращаем код ошибки.
У нас есть функция, и каждая функция, которая потенциально может завершиться неуспешно,
она возвращает некоторые код ошибки, некоторые сигналы того, что программа, точнее, функция завершилась успешно или неуспешно.
Но опять же недостатками такого подхода, естественно, преимущественно, является то, что все ошибки видны сразу явно.
То есть у нас код состоит из кучи ифов, мы видим, что вот эта функция может теоретически завершиться неуспешно,
вот эта функция всегда завершается успешно и так далее.
Но недостаток, понятное дело, мы должны теперь проверять возвращаемые значения каждой функции.
Это, во-первых, фавор, во-вторых, соответственно, у нас теряется привычная нами семантика возвращаемого значения.
Все-таки мы привыкли, что если мы взываем какую-то функцию, то эта функция возвращает результат.
Странно предполагать, что какая-то математическая функция или вообще функция в широком смысле, она возвращает код ошибки.
Результат мы должны получать каким-то отдельным способом, либо с помощью ссылки, либо с помощью указателя.
Ну, соответственно, у каждого способа есть свои преимущественные досадки.
Мы к ним еще вернемся, когда обсудим то, что я запланировал на сегодня.
Но сейчас давайте поговорим про то, какой способ обработки ошибок привнес язык C++.
Ну и какой способ обработки ошибок существует во многих объектно-ориентированных языках программирования.
Я говорю про исключение.
Соответственно, давайте посмотрим на пример, который разбирали в прошлый раз.
Значит, я напомню, что мы хотим написать функцию divide, которая принимает на вход два значения и пытается разделить одно на другое.
Ну и соответственно, мы с вами понимаем, что деление допустимо только если, во многих множествах,
то деление допустимо только в случае, если y не равен нулю.
Соответственно, мы должны каким-то образом проверять, что если y равен нулю,
то мы должны каким-то образом сообщить об ошибке, что функция не может корректно завершиться.
А во всех остальных ситуациях мы сообщаем, что возвращаем верный ответ.
Соответственно, чтобы сообщить об ошибке в C++, используется специальный оператор, специальное ключевое слово throw.
Что делает throw?
throw аварийно завершает функцию, при этом считается, что функция не возвращает никакого значения, а просто завершается.
И это каскадно приводит к тому, что программа просто-напросто аварийно завершает работу.
Давайте подробно поговорим про то, как устроен throw.
Следующий пример. Представьте себе, что у меня есть функция main, которая вызывает курение, курение вызывает рак,
рак бросает исключение единицы.
Ну и соответственно, каждая функция делает какую-то работу, в частности, печатает что-то в консуле вывода.
Что у меня тут происходит?
От этой последовательности вызовов, смокинг, канцер и так далее, значит, канцер доходит до строчки throw1.
Чему приводит throw1?
throw1 приводит к тому, что все следующие операторы этой функции, если я встретил оператора throw,
то все остальные операторы, которые идут после throw, они просто-напросто не выполняются.
То есть вызов оператора throw приводит к тому, что функция завершается.
Но при этом завершение функции, естественно, приводит к тому, что все локальные перемены тоже уничтожаются,
для них вызываются деструкторы и так далее.
То есть с этим все хорошо.
Если будет вызвано оператор throw, то все локальные переменные будут корректно очищены, будут корректно удалены.
Что происходит дальше?
Дальше мы возвращаемся в функцию смокинг, который вызывал канцер.
Так как функция канцер завершилась неуспешно, то считается, что в той строчке, в которой был вызван канцер,
считается, что в этой строчке тоже вылетело исключение.
То есть смотрите, канцер сгенерировал некоторые исключение, я сгенерировал некоторую ошибку.
Соответственно, ошибка дошла до функции смокинг.
То есть считается, что если канцер завершился не успешно, значит канцер завершился с ошибкой.
И ошибка теперь вылетает отсюда.
Соответственно, это приводит к тому, что смокинг тоже аварийно завершается,
все операторы, которые находится дальше него, тоже не выполняются.
Соответственно, смокинг аварийно завершает работу.
Опять же, тоже корректно уничтожая все локальные перемения и так далее.
Дальше исключение попадает в функцию main. Трочку с вызовом. Функции smoking.
Исключение вылетает из этой функции. Ну и так как main это исключение никак не обрабатывает,
про обработку исключения чуть позже. Так как main никак ничего не делает с этой ошибкой,
то main тоже аварийно завершается, и никакие операторы дальше не будут выполнены.
Соответственно, в итоге вызова этой программы мы с вами увидим на экране сообщение об ошибке,
что программа аварийно завершилась, но завершилась с помощью вызова функции terminate.
Ну и соответственно, программа завершилась после того, как было выброшено исключение типа int.
Соответственно, мы видим такое сообщение об ошибке, и ни одного сообщения, которое написано выше,
типа cout.cancers, cout.smoking и так далее, мы не увидим. В общем чертах понятно?
То есть, вызов оператора throw, если никакие исключения, если я ошибку никак не обрабатывать,
то это приводит к тому, что программа просто каскадно завершается.
То есть, завершается функция, которая вызвала оператор throw, дальше завершается функция,
которая вызвала функцию, которая привела к ошибке, и так далее, и пока не завершится вся программа.
То есть, на таком примитивном первом уровне кажется, что все понятно.
Давайте поговорим про то, для чего нужен вот этот аргумент, которому мы указываем оператор throw.
На самом деле, тут аналогия довольно-таки простая. Можно привести аналогию с оператором return.
То есть, если оператор return возвращает значение e, которое у нас получилось в результате
корректного выполнения программы, то throw принимает аргумент, который должен быть условно,
опять же, это не совсем корректно, но типа возвращает в результате некорректного завершения программы.
То есть, если я пишу что-то наподобие throw a, то у меня создается исключение e, новое понятие.
Исключение – это некоторый объект, который по сути должен хранить себе информацию о том,
какая ошибка произошла. То есть, если произошла какая-то ошибка, то значит, что в программе
существует некоторое исключение, некоторая исключительная ситуация, вот.
И в целом, назначение вот этого самого исключения, вот этого самого объекта,
заключается в том, чтобы хранить Некоторую информацию о том из-за чего ошибка произошла,
в целом какую-то общую информацию об ошибке. То есть, в целом, если вы пишете throw a,
то это означает, что с помощью вот этого объекта a или с помощью вот этого типа а вы хотите
Соответственно, если я пишу throwA, то состается исключение A,
и при этом вот эта переменная A копируется в специальное место в программе.
Есть специальное место в программе, есть глобальная память, есть стэковая память, и так далее.
Соответственно, где-то в глобальной памяти создается объект исключения,
и вот эта вот переменная, переменная a, она копируется, она копируется в этот специальный объект
исключения, и программа, ну мы поговорим о том, как она может обращаться к этому
объекту и кем-то образом узнавать о том, что за ошибка произошла, вот. Ну естественно, если
я напишу throw sdmuffat a, то этот объект a, точнее переменная a, переместится вот в этот
объект исключения, который будет создан при вызове оператора throw, вот.
Окей? Вот, ну то есть аналогия опять же тут такая же, как и с оператором return, да, то есть
если я пишу там return a, то вообще говоря там объект может там скопироваться, да, если я
пишу return там какой-то временный объект, да, то это временный объект, он перемещается и так
далее, то есть в целом тут аналогия такая, вот. Теперь давайте поговорим про то, как
исключение обрабатывать. Ну окей, мы поняли, да, что если мы вызываем оператор throw, то все,
кирдык, программа завершается, все плохо и так далее, но кажется, что это не совсем то, что нам
нужно, да, потому что когда мы говорили про обработку ошибок, ну когда я в начале говорил
про обработку ошибок, я говорил, что вообще говоря это про то, как бы восстановить нормальную
работу программы, да, если какая-то исключительная ситуация произошла, но, допустим, я понимаю, что
вот эту функцию вызвать нельзя, ну по какой-то причине, да, допустим, сервера недоступны, да, то есть
я вызываю там функцию, да, например, я открываю какое-то соединение по СТ, допустим, ну хочу там
сделать какой-то запрос Гуглу, вот, а Гугл говорит, там не отвечает, все, вот. Дальше, соответственно, я
понимаю, что если Гугл не отвечает, то я могу там, не знаю, обратиться в Яндекс, или какие-то другие
поисковики. Вот, соответственно, я получил какое-то некорректное сообщение, какое-то некорректное
обращение, ну, соответственно, в результате я могу восстановить корректную работу программы, просто
переключившись, допустим, на другой сервер или что-то наподобие этого. Значит, давайте посмотрим,
как можно продолжить нормальное течение программы в случае, если произошла какая-то
нештатная ситуация, какая-то исключительная ситуация. Значит, для этого используется так называемый
try-catch-блок. Что делает try-catch-блок? Давайте по порядку. В блоке try мы помещаем вызовы,
ну и вообще те операторы, операторы, операции и вызовы функций, которые потенциально могут
привести к проблемам. Например, вот в этой простой программе мы с вами понимаем, что теоретически
функция деления может привести к тому, что она завершится неуспешно, она выбросит исключение. Но при
этом, если функция divide завершится неуспешно, мы не хотим аварийно завершать программу. Мы хотим
просто напечатать какое-то сообщение на экран и продолжить корректное исполнение программы.
Что для этого мы делаем? Мы для этого помещаем вызов функции divide в блок try. Значит, смотрите,
в блок try можно помещать произвольное количество функций, и все эти функции будут вызываться
трога друг за другом по порядку. В общем, все нормально. В общем, блок try это просто отдельный
вид блока исполняемого кода C++. Значит, я пишу try divide. И что это означает? Это означает,
что если в divide возникнет какое-то исключение, если в divide выскочит какая-то ошибка, то эту ошибку
можно будет поймать в последующем за try блоком catch. Соответственно, блок try просто говорит
компилятору, что вот с этим блоком будь поаккуратней. Если из него вылетит исключение,
то попытаюсь его поймать одним из последующих блоков catch. Что такое catch блок? Catch блок
позволяет вам поймать исключение какого-то конкретного типа. Ну, в частности, допустим,
я знаю, что функция divide бросает исключение типа int. Видим, что в функции divide написано throw1.
Это означает, что вот этот вот исключение, вот этот объект исключения имеет тип int. Соответственно,
я пишу, что в блоке catch я должен поймать исключение типа int и записать его в переменную r.
Окей? Вот. Я поймал, то есть, после того, как в divide возникло исключение, значит,
это исключение вылетело из divide. Но так как оно вылетело в блоке try, то блок try автоматически
начнет искать соответствующий этому исключению блок catch. И он этот блок найдет, то есть он видит,
что вот этот вот catch, который написан здесь, принимает исключение типа int, а у меня действительно
исключение типа int. Вот. Он сохраняет значение этого исключения в переменную r, ну, путем копирования.
Ну и, соответственно, после этого выполняется вот этот блок. То есть выполняется выводный
экран division error, error-код, ну и, соответственно, печатает с кода ошибки. Вот. После того,
как блок catch завершится, программа продолжит нормальную работу. И вот в этом принципиальное
отличие, наличие try-catch-блока от отсутствия. То есть, если бы тут try-catch-блок отсутствовал,
то исключение вылетело из divide и программа бы завершилась. Ну, потому что завершилась функция
main. Здесь же так у меня есть block try-catch-блок. После того, как catch-блок отработал, считается,
что программа должна продолжить работу в нормальном режиме. То есть, она продолжит работу с первого
оператора, который находится за catch-блоком. Ну, то есть, естественно, я не буду возвращаться обратно
в функцию divide и продолжать работу. То есть, если функция divide завершилась неуспешно, то ее продолжать
не имеет смысла. Продолжить работу я буду после первого отработанного блока catch. Ну, вот в данном
случае следующим оператором будет return 0. То есть, у меня после блока catch отработает return 0 и
программа нормально завершит работу. Любой блок сужает область видимости. Да, спасибо. Хороший
вопрос. Действительно стоит обратить внимание. Смотрите, то, что написано в try-блоке, то есть,
если я в try-блоке создал переменную index, то эта переменная будет видна только в этом try-catch-блоке.
Окей? Вне этого блока эта переменная видна не будет. Но, аналогично, если я в catch-блоке
тоже создам какую-то переменную, то эта переменная будет видна только вот в этом блоке. Понятно? В
других блоках ее видно не будет. Точнее, вот вне этого блока ее видно не будет. Окей? То есть,
любой блок, который ограничен фигурной скопкой, он, естественно, создает свой скоп, то есть свою область
видимости. Прошу прощения. Еще вопросы. Как только try-блок завершится, то все локальные
переменные будут уничтожены, естественно. Так, еще? Окей. Ну, соответственно, да, как я сказал...
А, ну вот, да, тут все нормально, про это я все сказал. Вот, смотрите, а что если у меня из одной
функции может вылетать сразу несколько исключений, ну, исключений нескольких типов? Ну, допустим,
представьте себе, что я ожидаю, что функция divide может бросать исключения типа int и бросать
исключения типа double. Вот, значит, вот в этом принципиально отличие блока оператора throw от
оператора return. Return всегда должен содержать объект одного и того же типа. То есть, если я
прописал, что возвращаем я значение int, то я могу возвращать только int. Ну, или то, что приводится
к int. Оператор throw, вообще говоря, если я написал throw 1, то где-то в другом месте функции я могу
написать вполне спокойно throw полтора. То есть, типа бросаемых исключений не обязано совпадать,
окей? То есть, из одной и той же функции я могу бросать несколько видов исключений. Ну, вот в частности
пример. Допустим, функция divide по какой-то причине может бросать либо исключения типа int,
либо исключения типа double. Вот, соответственно, чтобы корректно обработать ситуацию, я могу
написать несколько блоков catch. То есть, я могу написать отдельный catch-блок для int и отдельный
catch-блок для double. В этом случае, если у меня будет брошенное исключение типа int, то я попаду в
catch-блок, который соответствует int, и на экране появится int. Если у меня исключение будет типа
double, то я попаду в блок catch, который относится к double и, соответственно, выполнится оператор,
который находится внутри этого catch-блока. Опять же, если какой-то из catch-блоков отработал,
то программа корректно продолжит работу за последним catch-блоком, который был перечислен, окей? То
есть, catch может выбирать по типу исключения, который был выбран. Ну, естественно, логичный
вопрос заключается в том, что а что произойдет, если я вдруг бросил исключение, но при этом ни одного
catch-блока не соответствует? Ну, тут, я думаю, очевидно, что произойдет. В этом случае будет
считаться, что исключение не будет обработано. То есть, исключение обработано будет, в общем,
все будет работать точно так, как если бы вы вообще тройблока не написали. То есть, если бы я в своей
программе, точнее, функция devite, написал бы еще какую-нибудь строчку, не знаю, true, true имеет тип
bool, поэтому он не подходит ни под int, ни по double, и, соответственно, исключение не будет обработано.
Все нормально, смотрите, если вы написали, если вы написали true 1 или 2, то 1 и 2 это тип int, то есть
и 1 и 2 попадут в catch-блок, связанный с int. То есть, как бы тут важен тип, смотрите, тут есть тип,
и плюс есть еще переменная, давайте назад вернемся, и плюс есть еще переменная, в которую сохраняется
значение исключения. То есть, вот что 1, что 2 попадут в блок int, но при этом в переменную r будет
сохранено значение либо 1, либо 2. Нет, а, ну, в смысле, можно, ну, в смысле, вы можете написать так,
вы можете написать catch int r, вот, и допустим, по какой-то причине вы ненавидите цифру 2, вот,
ну, вы можете написать, что если r равно 2, да, то снова написать throw. Ну, типа throw, ну,
давайте напишем throw 1, ну, просто throw, вот. Короче, из китча тоже можно бросать исключение,
в этом случае, ну, тоже будет считаться, что данная функция завершится аварийно и полетит исключение
дальше. Да, как понять, из какой функции вылетело? Ну, смотрите, короткий ответ, никак?
Короче, смотрите, если у вас есть несколько функций, давайте так, у вас есть try, допустим,
функция f, функция g, вот, и, допустим, и функция f, и функция g бросают исключение типа int, вот.
Можно ли как-то понять, из какой функции вылетело исключение? Ну, по самому исключению понять
нельзя, вот, ну, то есть, как бы int, он и в Африке int, да, то есть, не важно, там, int брошен из f,
из g, то есть, как бы int останется int. Вот, можно узнать двумя способами, то есть, либо сделать так,
чтобы функция f, функция g бросала разные значения int, ну, либо, действительно, бросала pr, чтобы,
может, было понять, в какой функции, либо воспользоваться специальным, в общем, есть специальный класс,
так-так-так-так, как он называется? std traceback, что ли? В общем, есть специальный объект traceback,
который позволяет узнать, соответственно, последовательность вызовов, которая привела
к исключению, вот. Соответственно, в исключении можно сохранить вот эту информацию, и тогда вот
будет полная информация, какая последовательность вызовов функции привела к тому, что исключение было
брошено. Не помню, то есть traceback, то ли backtrace. Нужно будет посмотреть. Окей? Окей. Так, ну да,
как я уже сказал, если ни одного кетчблока не подходит, то, ну, исключение считается непойманным.
Дальше. Во, да, хороший слайд, смотрите. Вообще говоря, смотрите, вот тут у меня, давайте вот на этот
пример посмотрим, вот у меня есть тут блок trie, ну, допустим, позываю какую-то функцию f, вот, и у меня
блок trie ловит либо int, либо double, вот. И я сказал, что если я бросаю true, то true имеет type bool, да, ну,
и, соответственно, он не будет пойманным ни одним кетчблоком. Ну, тут могло возникнуть следующее
сомнение. Ну, погодите. Смотрите, мы же знаем, что в C++ существует неявное переобразование типов, да, ну,
например, bool спокойно может приводиться к int, int спокойно может приводиться к bool, double к int,
int w и так далее. Вот. Почему бы здесь не сказать, что, ну, смотрите, раз у меня тут true, bool, да, и bool
осуществляет неявное, как это называется, promotion к int, то, ну, казалось бы, bool должен выбрать int
и, соответственно, отработать этот кетчблок. Вот. Значит, важно, что важно отметить, так это то, что блок
catch выбирается не согласно правилам перегрузки. Вот правила выбора для блока кетча, ну, к счастью,
очень просты. Значит, блок catch выбирается строго по точному соответствию. Вот, если бросается тип
A, то ищется кетчблок, который соответствует строгу типа A. Вот. Если тип A может быть переобразован
к типу B, то блок, который относится к типу B, выбран не будет. Кетчблок выбирается строго по
точному соответствию. Вот, в частности, я пишу try divide, то есть пытаюсь вызвать функцию divide,
вызываю функцию divide, divide бросает int, и, соответственно, я принимаю unsigned int и char.
Несмотря на то, что int может быть переобразован как в unsigned int, так и в char, ни одним блоком он
пойман не будет. Просто потому, что кетчблок выбирается строго по точному соответствию. Окей?
Константность. Не учитывая константность. То есть, если вы ловите constant, то это то же
самое, что и int. Вот. Ну и по ссылке то же самое. Можете поймать по int ссылке,
и так далее, то же будет int. Окей? Да. Да. Да, да, это правильно. Потому что вот этот row вы
написали не внутри tryblock, вы написали внутри, короче, вы написали его вне tryblock. Да, собственно,
я говорю, что нужно завершить вот эту функцию, вот эту функцию нужно целиком завершить и передать
управление другой функции. Ну, как то, которая вызывала, ну, допустим, вот это я пишу функцию f,
вот. А функцию f вызывала функцию g. Ну, вот есть функция g, которая вызывает функцию f. Вот.
Соответственно, если функция f находится в tryblock, то вот этот tryblock будет обрабатывать уже вот это
исключение. Окей? То есть, ну, естественно, смотрите, давайте так. Вот тут сверху написан try,
и вот этот row написан вне tryblock. Поэтому, естественно, он обрабатывать его не будет,
ну все. Давай, до свидания. Типа, функцию завершаем, выходим туда. Вот. Да, да, да. То есть,
ну, точно так же, как с f. Да, то есть, если я внутри вложеного f'а напишу else, он будет
относиться только к нему. То есть, да, я могу строить иерархию try'ов. Я могу написать try,
там не знаю, потом try. Там что-то, что-то. Catch, допустим, a. Вот. И тут catch b. Вот. А вот этот
catch относится к вот этому try? А вот этот try относится к вот этому catch? То во внешне он не попадет,
да. Да, да. Вот. То есть, ну, правило просто, ну, правило простое. Вот я нахожусь тут, я смотрю
самый ближайший tryblock, это вот этот. Вот. Дальше смотрю, смогу ли я обработать ему еще эти
catch'и. Нет, не могу, поэтому исключение вот из этого блока вылетает наружу. Но что значит
наружу? Вот во внешний tryblock. Вот этот tryblock пытается обработать исключение. Смотрю вот эти
catch'и. Если это не отработали, то снова вылетаю наружу. Значит, если tryblock и нет, соответственно,
то я вылетаю вообще из функции. Ну и так далее. Так, еще вопросы? Хорошо. Так. Да, вот я сказал,
что, я сказал, что, да, можно. Если там не будет второго try, то как это будет? В смысле, если внешнего не будет,
если вот этого try не будет, то, ну, будет работать как один try. То есть, если тут исключение, то есть,
если вот это исключение не обрабатывается вот этим catch'ем блоком, то исключение просто
вылетает из функции. То есть, tryblock нужно для того, чтобы погасить, не буду произвести слово, из ГТА.
В общем, если tryblock не смог обработать исключение, то значит, что это исключение вылетает из функции
ровно так, как мы показывали на первых слайдах. Вот, да. Сейчас не совсем понимаю, ну, как бы, давайте так,
давайте такой пример. Блок try, внутри блока try я вызываю функцию f. Вот. Ну, допустим, функция, ну,
то есть, я предполагаю, что функция f может бросить исключение, пишу catch, допустим int. Вот. Допустим,
для обработки этого исключения мне нужно вызвать какую-то другую функцию. Ну, допустим, я вызываю тут g.
Но, в свою очередь, я понимаю, что функция g тоже может брать исключение. Вот. Что я могу сделать?
Я могу тут внутри catch'а тоже написать try функция g, catch какой-то тип, и так далее. Вот. Ну,
тогда вот этот try catch' блок будет относиться только к тому, что написано вот тут.
Не, не, не. То есть, просто написать catch дальше try нельзя. Вот. Только так. То есть, catch имеет
вот такой синдексис. Идут фигурные скобки, а дальше последователь операторов. Вот. В свою очередь,
это последователь операторов может быть обернут в свой блок try. Ну, короче, это прям синдекс
sketch. Без фигурных скобок написать нельзя. Да. Да, ну да, да, да. Вполне. Вот можно, ну, то есть,
можно написать try f, дальше catch int. И дальше, ну, короче, если у вас есть две функции,
которые возвращают, которые бросают в станциали один тот же тип, то, да, можно написать try f,
catch int. Там что-то. И потом снова написать try g, catch int. Ну, да, вы можете try блок
на несколько try блоков. Все нормально. Тут будет try catch отвечать за это, вот это try catch block за это.
Так, еще вопросы. Окей. Так, значит, несколько минут назад я сказал про то, что catch блок
выбирается согласно абсолютно точному соответствию. Вот. Из этого правила есть буквально пара
исключений. Значит, первое исключение, да, первое исключение из этого правила заключается в том,
что если вы ловите, то есть, если вы пытаетесь поймать void указатель, то с помощью void указателя
вы можете поймать вообще абсолютно произвольный указатель. То есть, если вы где-то выше написали,
точнее, пункт написали, там, не знаю, throw, там, адрес x, ну, где x это int, то void с отрездой
поймает этот указатель. То есть, void с отрездой ловит вообще произвольный указатель. Окей. То есть, если в
качестве исключения, в качестве типа исключения у вас летит указатель, то void с отрездой его
поймает в любом случае. Окей. Это первое исключение. Второе исключение из этого правила заключается в
наследовании. Если у вас есть класс A, от которого унаследован класс B, ну, естественно, публичным образом,
вот, то, такой пример, если вы напишете throw B, ловить будете A, то с помощью объекта типа A
вы сможете поймать B. Окей. То есть, с помощью указания, с помощью, в общем, с помощью класса родителя
можно ловить классы наследников. Почему? Потому что если B публично наследовал от A, то B является A, да.
Ну и по принципу установки Барбар Лиска везде, где можно поставить A, там же можно поставить B.
Соответственно, если catch ловит объекты типа A, то он значит, он ловит и объекты типа B. Окей. Да.
Да, и к ссылкам и указателями тоже относятся. То есть, я, например, могу поймать A по ссылке,
соответственно, эта ссылка может поймать и объект типа B. Окей. Хорошо. Так. Теперь,
про выбор блока try. Смотрите, среди того, что я сказал ранее, теперь может возникнуть следующая
ситуация. Теперь может возникнуть такая ситуация, при которой у меня одному и тому же исключению может
соответствовать сразу несколько блоков catch. Ну, например, вот я нахожусь в функции f и, значит, в try
блоке пишу throw adress x. Значит, в блоке try можно писать throw, но это будет считаться, что исключение
возникло в блоке try, и, соответственно, оно будет обработано в соответствующем блоке catch. Вот. Я пишу
try throw adress x. Ну, adress x имеет тип int со звездой, да. После него идут catch void со звездой и catch int
со звездой. То есть, с одной стороны подходит int со звездой, с другой стороны подходит void со звездой,
потому что void со звездой может поймать произвольный указатель. Какой блок catch будет выбран? Так вот,
значит, еще одно отличие блока catch от выбора перегрузки заключается в том, что блок catch выбирается
не по самому точному соответствию, если подходит несколько, а выбирается самый первый подходящий. То
есть, блоки catch проверяются последовательно друг за другом. То есть, грубо говоря, я тут бросил исключение
типа int со звездой, дальше проверяю, подходит ли блок catch void со звездой. Да, блок catch void со звездой
подходит, поэтому он будет обработан вот в этом catch-блоке. Окей? Вот, значит, второй пример. Вот у меня
есть класс B, который публичным образом наследован от класса A. Вот, я пишу функцию F, в которой
бросаю исключение B. Пишу try throw B. Вот, соответственно, есть два catch-блока, catch A, catch B. Значит, объект типа B
подходит под оба catch-блока, и под catch A, и под catch B. Почему? Потому что B точное соответствие
типов, а потому что B публичным образом наследован от A. Вот. Но при этом, так как catch-блоки расположены вот
в таком порядке, у меня всегда будет всегда будет срабатывать только первый catch-блок. То есть, второй
блок тут, по сути, бесполезен. Потому что если я брошу исключение типа A, то будет отрабатывать блок
catch A. Если я буду брошать исключение типа B, то будет отрабатывать тоже блок catch A. До catch B никогда
дело не дойдет. Окей? То есть, об этом стоит помнить. То есть, как бы catch-блок выбирается не по самому
точному соответствию, если подходит несколько, а выбирается самый первый подходящий catch-блок. Вот.
Да. Ну, соответственно, тут замечание про то, что если я, соответственно, если я ловлю исключение по
значению, вот как тут catch A, catch B, catch int, и так далее, то когда я ловлю исключение по значению,
то, значит, вот этот объект исключения, который сгенерирован компилятором, он будет копироваться
вот в данную переменную. Вот. Тут я создал переменную int. Вот. И вот это исключение, оно будет скопировано
вот в эту переменную. Чтобы избежать лишних копирований, стоит ловить исключение по... То есть, стоит
рассмотреть возможность, ловлю ли исключение по ссылке. Ну, например, я, допустим, я по какой-то причине
хочу бросить в качестве исключения вектор из миллиона элементов. Ну, типа вот кирпич на голову летит, вот
тебе вектор. Вот. Соответственно, catch может этот вектор поймать, но если я буду вектор ловить по значению,
то тогда при ловле исключения у меня вектор будет полностью скопирован. Вот. Чтобы избежать копирования
большого вектора, ну, потенциально, да, я тут могу исключение принять по константной ссылке, и тогда эта
ссылка будет ссылаться вот на тот самый объект исключения, который был ранее сгенерирован. Никакой копии
происходить не будет. Окей? Ну, это классический способ оптимизации копирования. Вот. Окей. Так, ну и,
кажется, последний пункт, который связан с синтаксисом, состоит в том, что существует особая форма catch.
Catch с многоточием. Ну, смотрите, чего это нужно. Вот, представь себе, что у меня есть какая-то функция f,
ну, которая потенциально может бросить исключения. Вот. При этом она может бросить исключения, ну,
либо разных типов, типа int, типа double, типа float, типа vector и так далее и так далее. Но при этом
обработка всех этих видов исключения, она работает абсолютно одинаково. Ну, например,
какое бы исключение не бросило f, мне всегда нужно просто напечатать сообщение на экране,
что произошла ошибка. Вот. Соответственно, к чему это приведет? Ну, это приведет к тому,
что мне нужно будет написать там catch, int, написать там cout что-то что-то, а потом написать catch,
double, вот, написать что-то что-то, ну и так далее. Ну, как бы, понятное дело, что это дублирование
кода, ну и плюс вот эти блоки catch, они вообще, говоря, никак не добавляют читаемости кода. Да,
потому что если в каждом catch блоке нужно сделать одно и то же, то ну как бы зачем писать сразу
несколько catch? Так вот, поэтому в C++ существует способ поймать вообще произвольные исключения.
Чтобы сказать, что мне не важно какое исключение я ловлю, главное, чтобы исключение было поймано,
можно написать catch многоточие. Вот. Catch многоточие ловит абсолютно произвольные исключения. То есть,
какое бы исключение не было брошено в функции f, catch многоточие его поймает и обработает.
Соответственно, точнее, выполнится то, что написано внутри блока catch. Вот. В чем преимущество?
Ну, преимущество в том, что я могу единообразно обработать вообще произвольные исключения,
не выдавая из деталей какого типа оно было брошено. Вот. Плохая новость заключается в том,
что если я написал catch многоточие, то у меня нет доступа к самому объекту исключения. Вот.
Ну, точнее, нет переменной, в которую, нет переменной, в которую я могу обратиться. Вот. Ну, на самом деле,
давайте так, на самом деле можно, вот, там, какими-то, в общем, окольными способами, там, по-моему, есть
все плюс-плюс. Опять же, стандартная функция, блин, как она, типа current exception, ну, или типа
active exception, очень можно в документации посмотреть. Но, так или иначе, вот такого простого способа
к объекту исключения с помощью объекта получить не получится. Вот. То есть, если хочется поймать
произвольные исключения, ну, или в целом, в целом, обработка исключения не зависит от его вида,
не зависит от его типа, то можно воспользоваться catch многоточием. Да. Авто, кстати, хороший вопрос,
ну, наверное, нет все-таки. Наверное, все-таки нет. Ну, потому что, нет, нет, точно нет. Потому что
авто, ну, потому что авто — это концепция этап компиляции. Ну, на этапе компиляции мы же не
знаем, что у нас может пойти не так. Вот. То есть, как бы, представьте, у вас есть функция, которая
может бросить исключение как типа int, так и типа double. Вот. Если вы написали речь, которая принимает
double, ну, тогда вы, по сути, говорите, что, ну, типа компилятор на этапе компиляции способен понять,
а какой тип исключения пойдет в этот catch. Ну, естественно, исключение — это концепция
рантайма, концепция времени исполнения, поэтому автор разрешен на этапе компиляции быть не может.
Вот. Так. Есть ли вопросы? Да.
— Да.
— Если тип не может копироваться, то, ну, стандартная история, то есть, если тип не может
быть копирован, то... а, тут у вас, нет, у вас тогда просто возник ошибка компиляции.
Потому что, компилятор, если, ну, смотрите, тут все хорошо. Ну, то есть, как бы, как бы, не будь там
ошибки в ошибке. Понимаете, если у вас есть, то есть, если у вас есть какой-то catch-блок
и вы написали вот так. Но при этом тип А не может быть скопирован,
то компилятор, ну, он это заметит. Ну, то есть, компилятор же понимает, что если отработает этот
Компилятор же понимает, что если отработать этот блок кэч, ему нужно будет вызвать копирование и так далее.
Но компилятор понимает, что если ему нужно будет вызвать копирование, то он это сделать не сможет.
Поэтому выдаст вам ошибку, что типа вы ловите по значению тип, который нельзя скопировать.
Ошибка империации просто будет.
Когда он даст?
Ну, кстати, по этому поводу надо узнать.
Скорее всего, да, скорее всего исключение будет храниться на хипе.
Ну да, скорее всего на хипе.
Хотя я в этом не уверен, может и на стеке.
Надо посмотреть, я не буду врать.
Да, обычно так и делают.
Я обычно обрабатываю какие-то специфические исключения, кэч-инт, кэч-дабл.
А потом в самом конце пишу кэч-многоточие.
Но идут правила абсолютно такое же, как и в прошлый раз.
То есть отрабатывают первый подходящий кэч.
То есть сначала проверяется кэч-инт.
Инт не подходит, подхожу кэч-дабл, не подходит.
Перехожу в кэч-многоточие, он все ловит.
И поэтому, допустим, если я напишу кэч-многоточие в самом начале,
то, естественно, во всех остальных кэчах никого смысла не будет.
Потому что кэч-многоточие все поймает, и остальные ничего не достанется.
Есть ли еще вопросы?
Ну, давайте тогда сделаем перерыв.
Где шаблоны?
Да, я понял.
Вопрос, видимо, про это.
Если у меня есть какая-то шаблонная функция,
класс T,
не знаю, там void F от T,
вот, это F вызывает какую-то функцию G.
Я пишу try,
вот, я могу написать
кэч TX.
Параметр шаблона я могу использовать в кэче,
потому что после того, как функция будет приинстанцирована,
вместо типа T подставляется конкретный тип,
тут будет стоять конкретный тип.
То есть тут проблем нет.
Давай теперь предметно поговорим про то,
зачем вам
или вообще кому-либо
может прийти в голову написать
try-catch-блок.
До этого мы рассмотрели какие-то игрушечные примеры,
когда говорили о том, что
если в функции возникло исключение,
то давайте обернем в этот самый блок try,
а в кэч-блоке просто напечатаем.
Произошла ошибка.
Спасибо, Кэп, понятно.
Для чего все-таки,
с какой практической целью можно использовать try-catch-блок?
Давайте посмотрим на следующий
очень простой пример.
Представьте, что у меня есть функция f,
и функция f внутри себя выделяет
динамическую память.
А дальше я потенциально вызываю
опасную функцию g.
Давайте я сначала
напишу функцию f
без обработки ошибок.
Представьте, что у меня тут
есть на авто
ptr равно
newint.
Здесь я вызываю функцию g,
и дальше
что-то делаю, и в конце, естественно,
не забываю делать delete.
Казалось бы, прекрасная функция.
Она вначале выделяет память,
дальше использует функцию g,
ну, допустим, туда передает ptr,
как-то работает, и в конце выделяет delete,
то есть освобождает память.
Все прекрасно, утечек не должно быть и так далее.
Но теперь мы понимаем, что у нас
в принципе в теории может возникнуть ситуация,
при которой функция g завершится неуспешно.
То есть из функции g вылетит исключение.
Это произойдет, если из функции g вылетит исключение,
но при этом мы его не обработаем.
Сработает функция f,
функция f выделяет динамическую память,
дальше начнет работать функция g,
функция g завершится неуспешно, и из нее вылетит исключение.
Но так как мы функцию f исключения не обрабатываем,
что произойдет?
Ну, переменная ptr просто-напросто исчезнет,
но delete-то, естественно, никто не вызовет,
ну, компилятор за нас delete вызывать не будет.
Это не его забота.
То есть из функции g вылетает исключение,
ну, дальше, допустим, где-то снаружи,
ну, допустим, есть функция main,
функция main,
функции main я написал try f,
тут его как-то обработал,
вот, и как ни в чем не бывало,
продолжил работу.
Что произошло?
Окей, ошибки вроде как нет,
ну, то есть main сделала все, чтобы ошибки не допустить, да?
Main сделала все, чтобы программа продолжила корректную работу.
Программа корректно продолжила работу,
но вот эту память у нее уже никто не вернет.
Она бесследно утекла.
Понятно?
Поэтому что нужно сделать?
Необходимо, ну, то есть так как мы понимаем,
что функция g потенциально опасная,
нам нужно перед тем, как, ну, нам нужно обработать эту ошибку,
и перед тем, как ошибку пробросить дальше,
да, то есть прежде чем сказать, что
пусть ошибка летит дальше,
перед этим мне нужно очистить ту память, которую я выдел до этого.
Давайте посмотрим, как нужно было бы
справиться с этой проблемой.
Вот у меня есть функция f, я выделяю динамическую память,
ptr равно new int,
дальше в блоке try вызываю функцию g.
Почему в блоке try? Потому что я понимаю, что g потенциально может привести к проблемам.
Вызываю в блоке try функцию g,
g бросает исключение,
я его принимаю в блоке catch,
делаю delete ptr,
и, соответственно,
ну, допустим, ptr равно new ptr, да, то есть говорю, что
все, после того, как исключение возникло,
этим указать им нельзя пользоваться, я его за нуляю
и иду дальше, допустим.
Вот, соответственно,
то, каким образом можно использовать блок catch.
Окей?
Вот.
Хорошо.
Другой вопрос.
Опять же, по этому коду.
Вот этот код, на самом деле, несколько странный.
Почему? Потому что, ну, смотрите,
если функция g завершилась неуспешно,
если функция g завершилась неуспешно,
то, вообще говоря, кажется, что продолжать функцию f
не имеет смысла.
На самом деле, чего бы мне хотелось?
Мне бы хотелось поймать исключение, которое летит
из функции g,
сделать там все дела по очистке, допустим,
ну, очистить это само указать ptr,
а потом сказать, что вот это исключение я поймал,
но пусть летит дальше, да?
И, на самом деле, это сделать можно
например, вот так.
Вот. То есть, более правильно,
наверное, было бы поступить вот так.
То есть, я вызываю, то есть,
try блок, я вызываю функцию g, ловлю его
в блоке catch, в блоке catch удаляю
нужный мне указатель, а дальше говорю, что
ну все, я все необходимые действия перед завершением
функции сделал, теперь исключение пусть
летит дальше. То есть, снова пишу throw a.
Вот. То есть, я как бы говорю, что давай бросим то же самое
исключение, пусть оно летит дальше.
Вот.
Понятно, что мы хотели сделать.
Вот.
Но, какие тут есть проблемы?
Проблемы тут две.
Первая проблема заключается в следующем.
Смотрите. Когда я пишу throw a,
когда я пишу throw a,
вот это вот throw a, как мы говорили,
создаст новое исключение.
Вы смотрите, у меня где-то
в этом особом месте
в памяти хранится исключение
типа a. Вот.
Когда я поймал это исключение по ссылке,
ну, я, по сути, в переменную a
давайте так, в переменную a,
сохранил ссылку на вот это самое исключение.
А дальше, когда снова пишу throw a,
что происходит? Ну, throw a обязан
создать новое исключение. И тогда он
в этом месте программы, вот в этом месте
создает объект с помощью копирования самого себя.
То есть, по сути, я выполняю там лишние действия.
То есть, создаю новый объект
путем его копирования. Вот.
А что если я бросал вектор? То есть, что если я взял
и бросил вектор большой длины? В этом случае
я бы создал еще одну копию вектора, который бы бросил дальше.
Ну, вообще говоря, согласитесь, было бы
довольно-таки разумно
не создавать новое исключение, то есть, не пересадовать новое исключение,
а бросать то самое исключение, которое
летело изначально. Да?
Ну как? Потрать от единицы времени, сказать, что вот исключение
там уже лежит, пусть оно уже летит дальше.
Вот. Это первая проблема. Вторая проблема
заключается в следующем. Смотрите, давайте мысленно,
мысленно вот здесь,
вот здесь,
подставим кетч в ноготочке.
Ну, действительно, смотрите, допустим, я говорю, что
мне не важно, что вылетело из функции g,
вот если функция g как-то аварийно завершилась,
если из нее вылетело какое-то исключение,
то в любом случае я должен удалить указатель
и перебросить исключение дальше.
Но вот в чем проблема.
Если я пишу кетч многоточия,
если я пишу кетч многоточия, то
как я уже говорил, я не могу
получить доступа к самому объекту исключения, согласны?
Вот.
А это означает, что если я хочу сбросить исключение
и попить niemand нового avocado там,
кто Aussie будет,
то я не не знаю,
что мне написать вот тут, но у меня же нет переменной,
которая хранится в исключении, и что написать вот тут, я не знаю.
То есть две проблемы,
первое, если я пишу throw Representative Qi,
если с такой конфигурации, я напишу throw A,
то будет создано копирование, точно, будет создано копия
с Bakupenkkuchy в исключении. А вторая проблема,
если бы я там написал вместо a многоточия,
я бы не смог написать throw A,
потому что у меня, по сути, нет переменной,
Понятна проблема? Что делать? Вот специально для этого случая есть специальная форма оператора throw,
который не принимает аргументов. Просто throw. запятой. Что означает оператор throw без аргументов?
Оператор throw без аргументов означает брось исключения заново. То есть как бы есть текущие
исключения, которые мы сейчас обрабатываем. И вот брось его заново. То есть throw без аргументов
имеет смысл писать только внутри кетчблока. То есть если вы находитесь внутри кетчблока,
это означает, что вы обрабатываете сейчас какое-то исключение. И если вы хотите это же исключение
пробросить дальше, то сказать, что я все сделал на этой моей полномочии, все, дальше не могу ничего
обработать, пусть это исключение летит дальше, то вы можете написать просто throw, и тогда у вас
будет брошено ровно это же самое исключение, без создания копии. Более того, даже если вы напишете
кетчблоготочие, то есть если у вас нет доступа напрямую к исходному исключению, вы можете все
равно написать throw, и тогда будет брошено ровно то же самое исключение, без создания его копии и так
далее. Понятно? Смотрите еще раз. В чем пример? Вот у меня есть функция f. Внутри функции f я
выделяю динамическую память и дальше вызываю потенциально опасную функцию g. Если функция g
завершилась неуспешно, ну вот представьте, что функция g завершилась неуспешно, и в этом случае я
не знаю, что мне дальше делать. Но в этом случае я говорю, что функция f тогда тоже должна варьерно
завершиться. Ну какие у меня есть варианты? Первый вариант, ну просто не писать throw кетчблок,
тогда если я вызову функцию g, вот как здесь, просто после исключения вылетит наружу, функция f завершится.
Но если функция f завершится досрочно, вот тут, то я не смогу вызвать delete. Поэтому, чтобы вызвать
delete перед тем, как функция f завершится, я пишу try кетчблок. То есть я пишу try g, дальше ловлю
произвольное исключение, мне плевать какое там исключение, мне главное его поймать. Я ловлю
исключение, и дальше говорю, что я очищаю память, которую я ранее выделил, а дальше говорю, ну все, пусть
исключение летит дальше. То есть я перехватываю исключение только для того, чтобы выполнить
очистку памяти в текущей функции. А дальше говорю, что ну все, как бы ошибка все еще есть, я эту ошибку кидаю дальше.
Смотрите, я могу на какой-то переменной обратиться. То есть, допустим, я написал try f, catch int. Ну то есть я могу не писать имя переменной, тогда, ну просто,
я говорю, что я ловлю исключение типа int. Но если я напишу имя переменной, допустим int r, то тогда,
я, допустим, могу написать stdout r. Ну и тогда я выведу значение вот этой самой исключения. Вот, например,
для этого, чтобы узнать, чему оно равно. То есть не только какого оно типа, но и чему равно его значение.
Так, еще вопросы? Да. Да, давайте разберем. Давайте вот на этом примере.
Значит, вопрос был такой. Вот если я поймал исключение,
и дальше написал r равно 2, и дальше снова throw. Что произойдет? Ну то есть, допустим, тут изначально летело исключение 1.
Что произойдет? Опять ничего, потому что вот этот r является копией вот этого значения. То есть вот этот r,
это отдельная переменная, которая не как-то связана с этим. Но когда вы пишете r равно 2,
вы изменили вот эту локальную переменную. Вот тут по-прежнему осталось единица, поэтому будет
лететь дальше единица. Но если вы напишете int&r, и дальше r равно 2, тогда вот эта вот ссылка
будет ссылаться на вот этот исходный объект исключения. Если напишете r равно 2, то вот это
исключение изменится, и по сути у вас дальше будет лететь исключение равное 2. То есть если вы хотите
иметь возможность их менять, исключение, которое в данный момент находится в программе, то принимаем
по ссылке. А если вы принимаете по значению, то это просто будет копия того же самого исключения
здесь.
Да, ну потому что, смотрите, потому что, ну, не знаю, допустим, вот вы просто так вот, вы пишете
программу и тут, о, напишу kind of throw. Что это означает? Как бы исключения нет, но вы навели суету,
ну, типа, все нормально, вы говорите, давайте бросим исключение, которого нет. Ну, как бы,
короче, исключения есть только вот в блоке catch, по сути. То есть когда вы находитесь в блоке catch,
вы обрабатываете какое-то исключение, и в нем оно гарантированно есть, поэтому в этом случае
вы можете написать throw. А просто так написать throw без аргументов, ну, нельзя. Да. Нет, она вызывает
функцию terminate, вот. Ну, а terminate там, я не помню, что она называет, в общем, terminate просто
завершает программу. Возможно, кстати, abort тоже вызывает. Ну, можем, но зачем? Ну, то есть,
мы в любой момент можем вызвать terminate. Вот. Ну, тут мы про другое говорим, про то, как, ну, все-таки
продолжить нормальные течения программы без аварийного ее завершения. Вот. Ну, вообще, как бы
аварийно завершить программу можно в любой момент, либо с помощью там terminate, exit, abort и так далее.
Так. Еще вопросы? Окей. Так. Вот. Значит, в контексте того, что я сказал до этого,
еще более остро встает вопрос про рай. Ну, я надеюсь, вы не забыли четыре буквы,
которые означают resource acquisition и centralization. Смотрите, вот мы с вами говорили про то,
что вот идиом рай, она позволяет нам писать более безопасный код, при этом не задумываясь на тем,
чтобы там освобождать вовремя память, освобождать вовремя мютексы и так далее и так далее. Вот.
То есть, например, если мы используем SD-вектор, то вообще говоря, мы не задумываясь на тем,
как устроены динамические массивы, то есть new-derit нам не нужны. Если мы используем unique-ptr,
то тоже new-derit нам не нужны. Вот. Значит, в контексте разговора про исключения эти классы становятся
еще более актуальными. Почему? Значит, еще раз обратим внимание вот на тот пример, который был
в течение нескольких слайдов. Смотрите, если я использую сырую память, то мне необходимо
помнить о том, что потенциально каждая функция может бросить исключение, а если функция может
бросить исключение, то, соответственно, у меня память утечет потенциально. Но если бы я вместо
сырых указателей, вместо динамической памяти использовал бы встроенные методы, типа unique-ptr
или std-вектор, то смотрите, что бы получилось. Я бы написал... Смотрите, вот что произошло бы,
если бы я тут вместо обычного указателя написал unique-ptr. Ну, допустим, auto p равно makeunique int
что-то там. Вот. Тут бы вызвал функцию g. Вот. И delete мне тут писать не нужно. Смотрите,
если я использую makeunique, то вообще говоря, мне не нужно делать никаких приколов strike edge.
Почему? Потому что если g вылетит какое-то исключение, то что произойдет? Функция g вызовет
исключение. Это исключение я тут не обрабатываю. Это означает, что функция просто завершается. А что
происходит при завершении функции? Да, при завершении функции сработают деструкторы всех
переменных. Ну а деструктора unique-ptr что сделает? Очистит динамическую память. Понятно? Вот. То есть
идея в чем? Если я использую стандартные классы, которые работают, которые управляют ресурсами,
то и заботиться об отчечении в strike edge блоке мне тоже не приходится. То есть, например, код,
который написан выше, то есть абсолютно аналогичный код будет получен, если я просто-напросто обычный
указатель, который получен с помощью new, заменю на указатель, который получен с помощью unique-ptr.
Вот. Окей? Вот. То есть, мораль? Активно используйте рай-классы типа vector, unique-ptr,
sharp-ptr, ну и так далее. Вот. Есть ли вопросы? Нет. Ну да, в общем, давайте поясню. Во многих языках
программирования, во многих языках программирования есть исключения. Есть аналоги
strike-edge блоков. И во многих языках программирования, помимо ключевых слов типа strike-edge,
есть еще блок final, который выполняется в любом случае. То есть блок final, который выполняется
в случае, если исключение произошло или исключение не произошло. Все плюсы такого блока нет.
Окей. Давайте пойдем дальше и поговорим про статическую спецификацию исключений.
Смотрите, вот. Вообще говоря, ситуация стала довольно-таки печальная. Почему? Потому что,
ну вот, до этого мы не знали исключения, но и на самом ли горе не знали. То есть как бы мы
программировали и думали, что, ну вот, как бы все функции завершаются успешно, все прекрасно,
в общем, никаких обработок исключения делать не нужно и так далее. Сейчас же я привел вас
за руку в мир полный ужасов, в котором каждая функция может сбросить исключения, в каждой
функции может пойти что-то не так. Соответственно, для каждой функции, скорее всего, нужно вызывать,
нужно делать try, очищать память, следить, вызвали мы new, если мы вызвали new,
после этого вызываем другие функции, нужно убедиться, что эти пункты не образуются
исключений и, соответственно, что мы, если вдруг исключение возникло, освободим память и так далее.
Ужас, кошмар, что делать? Вот. Как жить в мире, когда каждая функция потенциально может сбросить
исключения? Ну, давайте я немного смягчу пилилю и расскажу про статическую спецификацию исключений.
То есть как сказать, что функция, в принципе, безопасная? Вообще говоря, не все функции опасные.
Главное, в общем, правильными им пользоваться и правильно обращать внимание на те функции,
которые потенциально опасны или потенциально безопасны. Смотрите, чтобы подсказать компилятору,
ну или чтобы подсказать читающему ваш код, что функция безопасная, ну безопасная в том смысле,
что она не бросает исключений, в том, что она там все делает корректно, она никогда не завершается
неуспешно. Вот. Значит, для этих целей существует ключевое слово noexcept. Значит, к любой функции,
после ее прототипа вы можете приписать слово noexcept, и это будет означать, что, собственно,
эта функция не бросает исключений. Ну или, более того, это является обещанием для компилятора,
что эта функция исключений не бросает. Соответственно, к чему это приводит? Это не приводит к тому,
что, как бы, к сожалению, не знаю почему, но если вы в функции, которая является noexcept, будете
вызывать опасные функции или будете писать операторы throw, компилятор на это ругаться не будет.
Ну, точнее, он, наверное, скажет что-то типа warning, что типа, ну, погоди, ты же сказал,
что noexcept, но вообще там делает throw, но как бы компилирует программу не откажется. Вот. Но
что произойдет? Если вы вдруг попытаетесь нарушить свое обещание и функции, которые пометили noexcept,
бросите исключения, вот в этот момент программа просто возьмет и завершится автоматически. Вот.
То есть функция noexcept говорит следующее, что функция либо ничего не бросает, либо если бросает,
то все-таки рдыка совсем. Все, вот никак нельзя эту ситуацию разрешить. В общем,
если вы нарушили свое обещание и бросаете что-то из noexcept функции, то программа завершается без
возможности ее, как бы, нормального продолжения работы. Окей? Вот. Поэтому слою noexcept оно,
оно железное. Вот. То есть оно либо, то есть она либо не бросает ничего, либо бросает,
но от этого всем плохо. Вот. Окей? Вот. Поэтому вы можете обращать внимание на те функции,
которые помещены noexcept. Если вы видите, что функция помещена noexcept, то в принципе обрабатывать,
обрабатывать ее ошибку не имеет смысла. Почему? Потому что, ну, она либо не бросает ошибок,
либо если она бросает ошибку, то обработать эту ошибку не получится никак. Вот. Поэтому noexcept
функции — это те функции, которые не требуют никаких обработок, никаких трай-кэтчблоков. Вот. Окей? Да.
Да. Можно мы про это, кажется, мы про это поговорим, я не помню сегодня или на какой-то
лекции, но вообще давайте скажу сейчас. В общем, если у вас есть какая-то функция, вы хотите проверить,
является она noexcept или нет, то есть специальная операция noexcept? Да, кажется, у меня на слайдах это есть,
давайте поясню. Чтобы проверить, является ли функция noexcept или нет, я могу написать вот так,
noexcept от f. Noexcept от f возвращает true, если функция является noexcept и false, если функция
не помещена как noexcept. Окей? Вот. Специальная операция noexcept. Вот. То есть еще раз повторю,
noexcept — это такое, ну, не знаю, слово пацана, исключение на стеке. Вот. Окей? Да. Смотрите, то, что
функция noexcept не означает, что внутри этой функции не могут возникать ошибки. То есть, естественно,
если функция noexcept, то внутри нее могут потенциально возникать ошибки, самое главное, чтобы эти ошибки
не покидали эту функцию. То есть, вот этот код вполне себе нормальный. То есть, если я пишу функцию f,
которая является noexcept, внутри нее вызываю функцию g, и при этом потенциальные ошибки функции g гашу
сразу же внутри функции f, то все окей. Самое главное, чтобы ошибки не покидали саму функцию f. Окей? Нормально?
Вот. Дальше. А теперь, да, значит, про noexcept все есть. Значит, смотрите, у noexcept, у ключевого
слова noexcept есть три смысла. Значит, первым смыслом мы познакомились, и это спецификатор.
Спецификатор. Значит, спецификатор, который говорит том, является ли функция безопасной или нет. Вот.
Значит, второй смысл ключевого слова noexcept — это условный спецификатор. Про него на слайде.
Условный спецификатор. Смотрите, вообще говоря, в общем случае, когда вы пишете либо какую-то
функцию, либо, на самом деле, еще более часто, когда пишете какую-то шаблонную функцию, вы, на самом
деле, не всегда можете понять, действительно ли все операции, которые вы используете внутри шаблонной
функции, безопасны или нет. Ну, самый яркий пример — это, например, функция, которая выполняет
сложение. Например, если я выполняю сложение целых чисел, то, вообще говоря, исключение в этом
случае никогда происходить не будет. То есть сложение целых чисел никогда не переводит к исключительной
ситуации. А если я, допустим, складываю две строки, то уже непонятно, потому что сложение двух
строк приводит к тому, что я выделяю динамическую память, а выделение динамической памяти в теории
может привести к тому, что у меня закончится память, соответственно, исключение. Поэтому сложение двух
строк не является безопасным, то есть не является noexcept по сравнению с сложением двух целых чисел.
Вот. Поэтому в языке plus plus был введен так называемый условный спецификатор noexcept. Смотрите,
помимо того, что я могу писать слово noexcept, вот, например, voidf noexcept, я могу еще написать voidf
noexcept true. Вот noexcept true это то же самое, что просто noexcept. То есть noexcept, внутри которого
написано буллевское выражение true или false, означает, что функция либо является noexcept, либо
не является noexcept. Или, например, если я напишу voidje, это по сути то же самое, как если бы я написал
voidje noexcept false. Ну, понятное дело, что писать noexcept true или noexcept false не имеет смысла,
потому что noexcept true можно заменить на noexcept, а noexcept false можно заменить на
отсутствие noexcept. Вот. Более осмысленное следующее применение. Ну вот, представь себе, что у меня
есть шаблонная функция h, которая, ну, по какой-то причине, может теоретически бросить исключение,
если у меня size of t больше единицы, и ни в коем случае не может бросить исключение, если у меня size of t
равен единице. Вот. Ну, какая-то вот такая функция. Вот. Что я могу тогда написать? Я могу написать
noexcept и в скобках size of t больше единицы. В этом случае, если у меня шаблонная функция h будет
инстанцирована с типом t, размер которого больше единицы, у меня функция будет noexcept. Вот. Если у меня
h будет инстанцирован с помощью типа t, у которого размер равен единице, то в этом случае функция не
будет noexcept. Окей? То есть, условный спецификатор позволяет в зависимости от того или иного условия,
ну, который, естественно, проверяется на этапе компиляции, пометить функцию как noexcept либо
как не noexcept. Вот. Ну и, наконец, операция noexcept. Кстати, в том примере я ошибся, там вот тут
были правильные синксис. Операция. Ну, операция просто. Значит, операция noexcept. Да, вопрос.
Нормально. Не-не-не. Вот давайте сейчас про это поговорю и дальше приведу примеры. Смотрите,
значит, вот мы познакомились с тем, что noexcept может быть спецификатором, может быть условным
спецификатором, и еще noexcept, еще ключевое слово noexcept отвечает за операцию. Значит, операция
noexcept принимает на вход некоторое выражение, но при этом его не вычисляет, а лишь его анализирует
на предмет того, является ли оно noexcept или нет. Ну, как sizeof, например. Например, если я напишу
sizeof uint, ну, я надеюсь, все помнят, что вот эта вот строчка не приведет к тому, что у меня будет
выделено память, да. Потому что sizeof, он лишь анализирует это выражение, то есть он его не
вызывает, он анализирует это выражение и говорит не то, а какого размера будет результат вот этого
new. Ну, результатом вызова new является указатель, указатель как раз занимает 8 байт, поэтому вот
это sizeof будет равен 8. То есть sizeof, оператор, он не вычисляет это выражение, он лишь его
анализирует. Вот точно так же поступает и операция noexcept. Noexcept лишь анализирует то, что мы передали
ей в круглые скобки, не вычисляя при этом, и просто выдает мне вердикт. Вот эта штука является
noexcept или вот эта штука не является noexcept. Вот. Так. Ну, вот пример. Вот у меня есть функция f,
которая помещена как noexcept, и есть функция g, которая не помещена как noexcept. Я спрашиваю, верно ли,
что вызов функции f будет noexcept, то есть верно ли, что вызов функции f не бросает исключений. И в
качестве ответа мне вернется true. Вот. Если я спрашиваю, верно ли, что функция g не бросает
исключений, то есть верно ли, что функция g является noexcept, то есть вызов функции g является
noexcept, в этом случае будет возвращен false. Почему? Потому что функция g не помещена как noexcept.
Вот. Еще примеры. Вот я написал вектор, я создал вектор v и дальше пишу noexcept 1 делить на 0. Давайте
про это поговорим. Вот. В некоторых это вводит в шок, но noexcept 1 делить на 0 это true. Почему?
По одной очень простой причине. noexcept лишь проверяет то, может ли данное выражение
бросить исключения. Смотрите, деление int, ну так как int это примитивные типы, ну и плюс,
так как у нас есть совместимость с языком c, работает примитивными типами, никогда не
бросает исключений. То есть деление двух int никогда не приводит к тому, что будет брошено исключения.
Поэтому noexcept на вот такую вот штуку говорит true. То есть вот эта штука безопасна с точки
зрения исключения, в том смысле, что она не будет приводить к выбросу исключения. Вот. Ну при этом
значит никакого undefined behavior тоже нет, потому что, как я уже сказал, операция noexcept, как и
операция sizeof не вычисляет то, что написано в кругу скоб канала, лишь его анализирует. Анализирует,
она анализирует это выражение, видит, что тут стоит int, тут стоит int, то есть определение int на int,
исключения не возникает. Поэтому true. Окей? Нормально? Да. Да, вот если вы пишете noexcept,
ну и даже какое-то выражение, то вот это выражение, оно анализируется на этапе компиляции. То есть оно
никогда не вычисляется, noexcept что-то что-то, оно вычисляется на этапе компиляции. Вот. Так,
вопрос какие-то. Но не исключение. Он может быть ошибкой runtime error, ну типа, не знаю, короче,
это может быть ошибкой операционной системы, это может быть ошибкой процессора, по-моему floating
division и так далее, но это не исключение. Исключение — это вот то, что бросается с помощью throw. Тут нет
throw. Потому что, ну смотрите, работа с int она реализована в языке C, в языке C никаких исключений
нет. Поэтому я точно знаю, что деление int на int не приведет к выбросу исключения. Окей? Так, еще вопросы.
Нет, имя функции проверить нельзя. То есть написать, то есть если вы напишете noexcept просто f,
то это всегда будет true. Почему? Потому что, ну f — это просто имя функции. Ну имя функции,
как выражение, всегда, как бы, никогда не бросается исключение. Потому что, когда вы обращаетесь к
переменной, обращение к переменной всегда безопасно. То есть, по сути, вы тут спрашиваете, а безопасно ли
обратиться к имени f? Да, безопасно. То есть это то же самое, как если вы написали f.zapitoj. Ну просто
написать f.zapitoj можно и абсолютно безопасно. Еще вопросы. Окей. И последняя строчка. Последняя
строчка. А noexcept v.pushback 1 делить на 0. Вот это false по следующей причине. Смотрите. 1 делить на 0.
Что делает операция noexcept? Операция noexcept снова берет вот это все выражение и анализирует его,
например, на предмет того, может ли что-то произойти не так или нет. Значит, как noexcept
анализирует это выражение? Ну он просто пошагово пытается понять, а что тут будет происходить.
Значит, первым делом компилятор понимает, что тут будет происходить деление int на int. Как мы с
вами поняли, деление int на int никогда не приводит к исключению. Окей. В результате деление
int на int получается int. То есть в итоге в pushback будет передан int. Вот. Дальше анализирует, верно ли,
что вызов pushback от int является безопасным. И ответ нет. Почему? Потому что pushback теоретически
может бросить исключение. То есть точнее по следующей причине. Pushback в векторе не помещен
как noexcept. А если pushback в векторе не помещен как noexcept, значит noexcept от этого выражения будет
false. Понятно? Вот. Да. Да. Деление любого int на любой int никогда не бросает исключений.
Так. Ну и вот, собственно, пример, про который я говорил. Смотрите, представьте себе следующую
ситуацию. Вот я пишу шаблонную функцию сам. По сути, вот тут элементы метапрограммирования.
Смотрите, по сути, то есть что я тут хочу. Я хочу написать функцию сам, которая принимает два
произвольных значения и складывает их между собой. Ну, понятное дело, что если бы я не знал,
проключусь слова noexcept, я просто написал там сам const x, const y и return x plus y. Теперь, так как я
знаю, проключусь слова noexcept, я хочу пометить мою функцию либо как noexcept, либо как не noexcept.
Вот. Но при этом я понимаю, что в зависимости от того, какого типа t мне будет передан на вход,
у меня функция будет noexcept, либо не будет noexcept. Ну, собственно, пример я уже приводил.
Если функцию сам передаду два int, то сложение двух int всегда безопасно. Согласны? Вот. Если
функцию сам я передам строчки, то сложение двух строчек уже потенциально может привести к
проблемам. Потому что сложение двух строчек — это потенциальное выделение памяти, а выделение
памяти — это потенциальная ошибка, беда лог, то есть не хватает памяти. Поэтому чтобы компилятор
сам определил, является ли моя функция noexcept или нет, я пишу следующий код. Я пишу noexcept
в круглых скобках noexcept от x и plus y. Все не понимают, что это означает. Давайте разберем поэтапно.
Вот я написал t сам, давайте так, tx, ty, noexcept, x plus y. Давайте разбираться. Значит, как я уже
сказал, у ключевых слов noexcept может быть один из трех разных смыслов. Давайте разберем
каждый смысл. Давайте разберем вот этот noexcept. Каким из этих трех смыслов обладает вот этот
внешний noexcept? Да, условный спецификатор два. То есть это условный спецификатор, то есть он в зависимости
от условия, которые я подал на вход в круглые скобки, будет выставлять noexcept флаг для суммы,
либо не будет выставлять noexcept для суммы. Понятно? То есть в зависимости того, вернет ли вот
эта штука true или false, он либо добавит noexcept к функции sum, либо не добавит noexcept к sum.
Окей, теперь вот это. Какой смысл вот этого слова noexcept? Операция, да, то есть третий смысл. То есть
вот этот внутренний noexcept, он проверяет верно ли, что выражение x plus y безопасно. И вот тут
компилятор за нас проверяет, он за нас смотрит, ага, если x и y это int, то есть если вдруг я функцию
сам передал int, то он смотрит, ага, сложение двух int, сложение двух int, это безопасно, поэтому возвращает
true, и тут мне стоит noexcept true, то есть функция sum будет noexcept. Если же на вход я передал две строки,
то тогда компилятор анализирует, ага, noexcept x plus y, x plus y это две строки, сложение двух строк
не помещено как noexcept, когда вы реализовывали свою строку, вы не помечали, естественно,
оператора сложения как noexcept, операцию сложения как noexcept, поэтому он тут вернет false, и тогда у
меня тут в качестве условного спецификатора будет noexcept false, а noexcept false это отсутствие noexcept.
Все, понятно? То есть таким образом в зависимости от какого-то условия я либо выставляю
flag noexcept, либо не выставляю flag noexcept. Да. Потому что компилятор понимает, ага, смотрите,
вот тут написан прототип функции, если тут написан прототип функции, значит,
последующий с ним слово noexcept может иметь только либо первый, либо второй смысл. То есть компилятор
понимает, что noexcept, который написан после прототипа функций, может иметь один из двух смыслов. Дальше,
он видит, что этот noexcept не одинок, у него есть круглые скобки, значит, это условный
спецификатор. Ну а дальше, когда компилятор заходит в эти круглые скобки, он понимает,
что в эти круглые скобки может быть написано только выражение, но раз это выражение, то ничего кроме
операций там быть не может, потому что выражение это комбинация операций и их аргументов.
Нет, не, погодите, сейчас вы про что? Я не снимаю. Вот вы про то, что если я написал
типа auto, sum, tx, ty, дальше, ну, понятное дело, потому что там noexcept, ну там что-то что-то,
а дальше стрелочка t, да? Вы про это? Нет, тут все нормально, потому что вот этот вот это прототип
функции, точнее, тип функции, ой, ну да, в общем, вот этот прототип функции, после прототипа функции
пишется noexcept, вот, ну а дальше через стрелочку я указываю возвращаемое значение. Да, да, да. Сначала
все, что относится к прототип функции, а потом возвращаемое значение. Так, звонок, давайте посмотрим,
что у нас там осталось. А, ну по сути все, финальный пример. Ага, так, есть вопросы? Так, а не бросающий
new, ну про не бросающий мы с вами поговорили, давайте еще раз повторю, что, значит, как я уже сказал,
new потенциально может брось исключение, подолог, да, то есть, в случае, если вдруг память не хватает
по какой-то причине, то new может завершиться с ошибкой, да, то есть, new может брось исключение
подолог, вот, если вы не хотите, чтобы new бросало исключение, то есть, если вы не хотите париться с
обработкой исключения, то мы пишем new с параметром sdno throw, в этом случае эта версия new будет
возвращать nullptr, если память не удалось выделить, вот, ну, на этом в целом все, ну да, все, спасибо,
до встречи на следующей неделе.
