Лекция 9. У нас сегодня строки. Начинаем. Первая задача, которую мы будем разбирать всю лекцию,
это задача о поиске какого-либо паттерна в тексте. Чуть формальнее даны паттерн P.
Ноль индексации будем все вести. И текст. Давайте T его обозначим. Вот такая вот постановка задачи.
Это то, что нам дано. Хотим все такие И, что P равно T. Я буду использовать бетоновскую индексацию.
То есть мы хотим найти все такие индексы И, что паттерн входит в текст. Если сложно по формуле,
то картиночка. Это наш текст. Это наш паттерн. Здесь у нас будет И плюс модуль P минус 1.
Мы хотим, чтобы у нас это все было равно паттерну нашему.
И мы хотим найти все такие И. Самая наивная постановка и простая. Найти хотя бы одно такое И,
то есть есть ли вообще вхождение паттернов в текст. Если да, то хотим найти их все.
В общем-то, задача такая. У нее есть несколько решений. Я знаю четыре. У меня даже больше.
Но нас будет интересовать не все. А именно есть нулевое решение, которое записывать не буду,
называется наивным. Это взять в каждой позиции И, попытаться приложить паттерн и проверить
наивно, что они равны. То есть вы берете, перебираете И, дальше сравниваете. Правда ли,
что это подстрока равна паттерну? Итак, для каждого И очень интеллектуальное решение,
поэтому на доске его не будет. А симпточку предлагаю оценить самостоятельно.
Окей, рассмотрим такую штуку. Z функция. Если что, она приобрела такое название задолго до,
возможно, символизма у нее. Поэтому просто так оставим. Определение.
Z функция от st и t равно максимальному k. Такое, что
вот такое вот интересное определение. То есть у вас эта штука Z функция строится по строке и
по факту возвращает вам массив, где в итой точке вот такое вот значение. Картиночка. Вот ваша итая
позиция. Когда вы хотите как можно дальше направо уйти, чтобы у вас вот эти вот части были равны.
То есть это если это и плюс z ита, это просто z ита будет. Берем, что вот это вот равно вот этому вот.
Окей, ну это к максимально всех возможностях. То есть можно правее берем.
Собственно, как проверять наличие паттернов в тексте? Вам нужно, ну окей, давайте сначала научимся
считать их эффективно. Вот, а потом уже разберемся, как паттерны искать. Так, алгоритм построения.
Собственно, их два. Первый алгоритм, он тоже не появится на доске, потому что он наивный и не
оптимальный по времени, а все-таки Z функцию надо строить оптимально. Вот, поэтому сразу перейдем
к линейному алгоритму. Напишем определение. Z блок, это у нас будет, это под строка и плюс z ита,
соответственно. То есть если вы в какой-то точке посчитали и, посчитали z и, то вот эта штука
называется Z блоком. Окей. Собственно, в ходе алгоритма мы будем поддерживать Z блок. Алгоритм
поддерживает Z блок с наибольшей правой границей. То есть если у вас, ну понятно, у вас в каждой
точке и начинается какой-то Z блок, вы выбираете тот, у которого правая граница максимальна,
ну и мы будем его поддерживать все время. Его границы будут обозначаться очень просто. LR,
очень интеллектуально. Окей, тогда нужно просто рассмотреть кучу случаев, как будем переставить
Z функцию. Так, картинка, большая картинка. Давайте это L, это R, это I. И допустим, что мы посчитали
уже для всех z меньше i, z функцию уже знаем. То есть вот здесь на префиксе мы уже все знаем.
Посчитали z0, z и-1. Кстати, чему равен z0? Ну как база индукции. Ну да, можно определить,
как длину строки, например. Некоторые говорят, что здесь мы требуем не собственный префикс,
то есть чтобы он был не равен всей строке, тогда говорят, что это 0. Ну только он игнорируется
при рассмотрении далее. Просто z0, она просто ставится по факту и дальше начинается алгоритм
с единички. Вот. Ну можно z0 равный 0, надеюсь, чтобы было проще жить. Не надо, все равно
туда смотреть не будем. Окей, что мы делаем дальше? L равно R равно минус 1, то есть у нас нет ни одного
z-блока, считаем теперь. Соответственно, теперь нам остается посчитать z и-то, если мы знаем все
вот эти вот. Утверждение такое. Сейчас подгоним нужную сторону. Здесь плюс-минус 1. Так,
давайте доказывать. Для этого мы посмотрим, если у нас это LR, то вот это значит, что вот эта вот
штука равна какой-то вот этой вот штуке, так это z-блок. И что еще мы знаем? Мы знаем его длину
что-то типа R минус L плюс 1. В силу того, что они равны, у нас где-то есть аналогичная точка I. Ну,
только она будет I минус L, иметь индекс. Окей, что теперь мы знаем? Если у нас есть этот I минус L
какой-то, давайте лучше I чуть правее нарисую, чтобы картинка была поадекватней чуть-чуть.
И минус L. И у нас есть два случая. Давайте смотрим первый случай. А, еще здесь нужно видеть,
что если I лежит в отрезке LR. Вот, теперь будет правдой. Так, первый случай это то, что у нас
zI минус L меньше, чем R минус I плюс 1. Что это значит? Это значит, что у нас вот это значение z-функции
как-то вот так вот. То есть оно не доходит вот сюда вот. Вот здесь вот такое вот. То есть вот это вот
будет вот это вот будет I плюс z I минус L, вот здесь вот. А здесь вот будет I минус L плюс z I минус L.
Так как это одинаковые строки, вот эти две штуки тоже равны. Но заметим, что так как мы знаем,
что это значение z-функции, значит у нас вот эти вот равны. То есть у нас вот это вот, давайте двумя дужками
обозначу. Они равны все друг другу. Вот, ну тогда из этого следует, что z-функция в этой точке,
она хотя бы имеет вот такую вот длину. Потому что эти штуки равны. Согласны? Давайте распишем,
что именно у нас есть. У нас есть следующее, что так как R минус L плюс 1 равно
плюс 1, потому что R все-таки отрезан. Так как это верно, что из этого следует? Из этого следует,
что верно нравится вот этих вот штук двух. То есть s I минус L. I минус L плюс z I минус L плюс 1.
Вот так вот будет. В полуинтервале вот такого здесь будет обозначаться. Он у нас равен вот этой
вот штуке. Так, I плюс z I минус L плюс 1. Вот. Теперь так как у нас есть значение z-функции здесь,
из этого следует, что s z I минус L совпадает с, то есть вот эта вот часть с этой.
I минус L плюс z I минус L плюс 1.
Ну, будто бы вот так вот. Тогда у нас вот эти две части равны. То есть из этого следует.
Совпадает с вот такой вот штукой. I. I плюс z I минус L плюс 1. Ну, откуда значит,
что у нас и того, что z I t, z I минус L t. То есть z I минус у нас верно вот это вот. И при этом эта штука меньше, чем это.
Ну, возвращается тогда, что z I t больше собрать чем минимум из этих двух. Ну, логично. Потому что
минимум из этих двух-то вот это вот. А мы получили, что это больше либо равно. Более того, на самом деле,
здесь можно заметить следующее. Давайте отметим здесь это. Что у нас верно? Что раз это z-блок,
да, вот это вот, то у нас если здесь написано какая-то буква x, то вот здесь написано какая-то буква y.
Потому что иначе мы продолжили бы вправо в этой точке. Согласны? Окей. Что теперь можно заметить?
Что раз эти две строки побольше, они равны, которые одной душкой обозначены, значит здесь стоит x.
Значит, здесь и здесь символы различаются. А из этого следует, что на самом деле здесь равенство.
В этом случае. Окей, если с этим понятно, поехали ко второму случаю.
Давай теперь вот эту штуку меньше либо равна чем z I-L. И рассмотрим тогда следующую картинку.
Что это значит? Это значит, что мы выходим своим z-блоком вот сюда вот, за эту штуку.
Согласны? Но логично тогда утверждаем, что мы будто бы выходим сюда, но мы же не знаем,
что за r происходит вообще-то. Просто неизвестно. Мы туда никогда не заглядывали.
Поэтому разумно обрубить z-функцию вот этим вот значением, потому что у вас здесь равенство есть.
А что там дальше справа потом посчитать? Давайте напишем так, что тогда
i-Lt v.r-L-1 равняется чему? То есть вот эта вот часть, то есть то, что если мы обрежем,
она будет равняться вот этой вот s I-prt. Но это понятно почему. Потому что у нас есть
равенство вот этих частей. Просто z-блок выходит аж сюда. Ну все. Что z I-T больше 1 чем r минус i плюс 1.
Ну это просто разность, просто длина вот этой штуки. Ну все, доказали тогда утверждение.
Окей, утверждение доказано, тогда алгоритм очень простой. Каждый раз давайте ставить,
что z I-T, вот эта вот штука, минимум из двух. И дальше, если у нас вот это минимум, да, то есть
вот это вот здесь минимум. То есть это вот выполняется. То мы просто будем говорить сразу вот так вот.
Иначе, если верно вот это вот, то что мы будем делать? Будем говорить тогда, что z-функция в точке i равна
длине вот этой вот оставшейся части. И дальше мы будем просто наивно сравнивать вот эти вот
символы и вот эти вот символы. Вдруг можно продолжить z-блок? Ну все, алгоритм примерно такой.
Да, ну я вас обманул. Мы не все рассмотрели, а вы появились на развод. Потому что вот это не всегда
верно. Когда это может быть неверным? Когда у вас последнее значение z-функции z I-1 равно 0,
и при этом у вас крайний z-блок заканчивается в z I-1. Поэтому если i не лежит в отрезке lr,
то это возможно только в одном случае. То есть у вас был ваш l, вот ваш r, и вот ваши i. Это возможно
только когда у вас l равно r и равно i-1. То есть у вас z-блок длины 0, начинающийся в позиции i-1.
Только тогда это возможно. В этом случае мы будем поступать максимально интеллектуально и
абсолютно то же самое, просто вайлом считать, сравнивать вот эти вот символы. Все, алгоритм очень
интеллектуальный. Теперь давайте напишем псевдокодик быстренький, который объединит
все три случая в короткую конструкцию и обрадуемся жизни. Сразу напоминаю
псевдокод, поэтому здесь я могу написать ссылки, константности и прочее.
Давайте сразу напишу, что модулез, и поехали так, for.
Давайте подумаем, что если обозначить, что вот в этом случае, что у меня будет минимумом.
Какое значение получится? То есть если i у меня равно r-1, то я получу здесь 0. Возможно,
где-то набаговал на плюс-минус 1, поэтому я позволю себе переиграть всех и написать вот так.
Вдруг там случайно отрицательное выйдет. Вот так вот. Это изначальное значение zi. Теперь я буду
смотреть, что делать. Если у меня вот этот случай верен, то даже если запущу такой вайл,
который идет вперед и отстранивает, он тут же оборвется. Если я запущу здесь вайл,
то он почитает мне корректно. Если я запущу здесь вайл, то он тоже почитает мне корректно.
Значит, я просто запущу вайл. Так, давайте. А ну база там как-нибудь или типа нулю задайте.
Непринципиально как задавать, если честно, изначально. Надо, чтобы получилось не отрицательное.
Вот так еще напишем. Так, теперь вайл i плюс zi меньше, чем модуль s. Это нам нужно,
чтобы не вылететь за индексы при пересчете. Именно сайд почему? Ну давайте нули напишем.
Это мелочи жизни. Теперь мы смотрим, правда ли, что у нас верно. Вот такие вот. Если да,
то мы говорим плюс плюс zi. Ну и последнее, надо обновить lr.
Мы говорим, что r равно i и z от i. l равно i. Ну здесь типа return z. Ну все. Очень интеллектуальный
алгоритм на самом деле. Как бы расписывать его долго, понимать его еще хуже, кодом он такой
коротенький. i плюс zi символ строки на позиции plus zi равен символу на позиции zi. То есть мы проверяем,
правда ли, что вот этот вот, потом вот этот вот, потом вот этот вот. Или в этом случае это будет
вот этот, потом вот этот, потом вот этот. А давайте теперь, как искать, собственно,
вхождение паттернов текст. Вхождение паттернов текста очень просто. Вхождение ПС. Обозначим,
что у нас есть строка S, вот такая вот интересная. Решетка T. Что это значит? Это значит, что решетка
это какой-то разделитель, которого нет в алфавите. У вас строки состоят из символов. В символы
принадлежат алфавиту. Возьмите какой-нибудь уникальный символ, который не лежит в алфавите.
Но обычно говорят, что алфавит это от A до Z, решетка не лежит в алфавите от A до Z. Иначе там,
ну не знаю, можно войти себе за решетки на самом деле, но там немножко неприятнее будет жить,
поэтому проще с ней жить. Окей, так, вхождение ПФТ. С равно П-решетка T. Тогда строим
ZS. Здесь строим Z-функция. Тогда P-решетка T на позиции И. И сейчас картинка для наглядности.
Давайте здесь будет решетка стоять наша. Это будет P, это T. Вот, допустим, выбрал И. Тогда
вхождение, это то же самое, что у меня вот здесь вот эти вот штуки совпадут. Логично? Ну, максимально
логично. То есть я хочу сказать, что на позиции И, если ZИ-модуль П равен модуль П. Конец. Ну, и верну
и в обратную сторону. Потому что у вас здесь равенство, потому что если знак меньше здесь,
то ZИ-ПТ меньше, чем модуль П, то вхождение неполное, то есть входит какой-то лишь префикс.
Если же, может ли выйти знак больше, знака больше быть не может, потому что у вас здесь решетка,
которой нет в алхавите. Поэтому решетка, очевидно, в Т не входит, значит вы не можете хотя бы модуль П
плюс один выбить значение. Ну и все. Не-не-не-не, почему? На позиции И имеется в виду в тексте Т,
безотносительно этого куска. Почему нулевая? У вас берется И во всей строке. Ну да, у вас же будет
одна большая строка, поэтому берете, может эта функция берется по строке С, поэтому так. Ну вот пересчет,
и у нас модуль П будет примерно. Короче говоря, когда вы решаете задачи, вы просто напишете код,
потом такие, блин, перевели позицию, учет на один, он включается во всех индексах в ответе,
пойду-ка прибавлю один, или отниму один, и все. Примерно так решаются задачи на простроке.
Вот. Окей. Что мы с вами не сделали? Мы с вами не доказали, что это работает за линию. Да? Что нам
нужно для этого сделать? Нам нужно доказать, что этот алгоритм работает за линию. Если мы докажем,
то это победа. Ну давайте сделаем вот как. Тумарно алгоритм определяется числом вайлов, да?
Так, ну что можно здесь сказать? Что здесь хочется вкинуть? Какой-нибудь прикол типа
«каждый символ рассмотрен лишь два раза, поэтому у Тумарной линия». Попробуем подробнее с этим
разобраться. Так. И вот уже следующее, что каждый символ, давайте время работы,
каждый символ просматривается не более двух раз. Да-да-да-да-да. Не более двух раз, вроде бы.
Раз, пять, какие-то разы. Ну первое, это будто бы, когда я его прохожу в вайле, да? То есть что у
меня происходит в этом случае? То есть нам нужно посчитать суммарное число итерации вайл. Ну,
сейчас. Вайл выполняется только когда верно либо вот это, либо вот это, да? Если вот это,
то у нас просто R напрямую сдвигается явно, и это посещение указателем R будет символа. Согласны?
А второй случай, это вот этот. Тогда с ним что происходит? Да вроде то же самое. Ну будто бы,
да. То есть каждый символ повещается не более двух раз, получается. Ну будто бы да, потому что вы
выходите за R только либо в этом, либо в этом случае, а если вы находитесь внутри R, то есть вот этот
кейс у вас вайл вообще не работает. Ну и все, будто бы это доказывает время работы. Потому что
суммарно вайло всего линия. Давайте это обозначить uf3, чтобы можно было индексировать. Либо при выполнении
в кубочках 2, либо при кубочках 3. Следовательно, суммарная итерация вайл
не более, чем для длины строки. А еще у вас есть пыльная итерация вайла внешний for,
который там тоже при не запуске вайла какие-то итерации вам накидывает. Но их тоже не более,
чем длина строки, поэтому суммарно здесь не более 3 длины строки операций. Тогда время построения
z функции. Вот длина строки. Откуда у вас следует в частности, что вот этот алгоритм,
ось к обхождению всех паттернов текст, работает за линейное время от длины паттерна и текста. Ну все,
самый сложный часть разобрали. Сейчас маленький перерывчик в виде хашей, потому что нелегкие.
Динамиальное хаширование алгоритм Рабина Карпа.
Так, ну сейчас будет немного страшно. Определим хэш от 0 по m-1.
Так, сейчас самое страшное. Надо вспомнить, что именно из чего вы читаете.
Итой на х в степени m-1-i по модулеку. То есть, что я говорю? Я рассматриваю строку как многочлен.
Где у него вот есть иксы, есть вот эти пейты. Зачем мне это нужно? Это называется полинейный хэш,
ну или роллинг хэш. Или хэш Рабина Карп, как хотите называть. Верно, зачем нам это нужно?
Затем, что хэш от 0 по m-1, что это такое? Давайте распишем. Что? Q это число? Пока нет.
Пока что любое, потом я скажу, как у х выбирать. Это минус. Минус 1, минус i.
Согласно, я просто взял и расписал определение. Давайте теперь я сделаю вот как. Я хочу
PM отдельно выяснить отсюда. При индексе равном m, что у меня будет? PM. Крупнее. Пм умножить на х в нулевой.
Плюс сумма. Давайте я здесь напишу опять же так. P itx в степени m-i по модулю Q. Согласны?
Ну вроде я просто ничего интеллектуального здесь не сделал. Я вынес м-то слагаемое.
Кого? При i равном m у меня здесь 0. Х нулевой будет, поэтому он не нужен. Так,
теперь остается привести это к классному виду. Вот это кто такой? И чем он отличается от этого?
Тем, что у вас здесь есть m-1, а здесь m. Поэтому снова пишем PM и вынесу х один раз.
Ну так это же мы знаем кто такой.
Собственно, я ввел так интересный хэш, чтобы я мог считать хэш гораздо проще для следующего
символа. Чтобы добавление одного символа мне хэш сильно не портило. Я мог его явно за 1 пересчитать.
Так давайте теперь, грубо говоря, это первое утверждение будет или свойство его в некотором
плане. Теперь второе свойство доказать. А именно как считать хэш произвольной подстроки? Давайте
выводить хэш подстроки. Хочу хэш PLPR хочу. Ну давайте выпишем просто по определению. Так,
можно я не буду писать везде mod-q, и будем считать, что мы по члену Q ведутся. Просто
для экономии места. Так, P и ты. Теперь надо расписать это через страшные вещи. Давайте
распишу это вот так вот. Да, R. Согласны, что это верно? Ну я просто взял, здесь все слагаемое,
здесь вычил ненужное. Окей, так что теперь нужно сказать? Ну что вот это по формуле это просто
хэш от P0 blah blah blah PLR ты. Сейчас PLR ты будет. Не, PLR плюс 1 получится. Потому что там-то у
нас M-1-I, то есть я хочу, чтобы здесь-то у меня ходило. А, все, я туплю, sorry. Да.
Хэш от P0 PLR. И теперь мне нужно понять, на какую степень здесь домножить,
чтобы получить здесь L-1. Ну что здесь получить L-1, мне нужно взять и это превратить в домножить
на х в степени L-R. Согласны? L-I только. R-R, да.
Какая единичка? Зачем? А, ну мы хотим M-1 здесь еще, да. Вот. Подогнали, да. То есть это хэш,
давайте напишу это на следующей строке. Минус. Во, получили формулу.
Почему плюс 1? Здесь L-I минус 1. Минус 1. Я хочу по формуле подогнать по ту. А здесь R-L
плюс 1, чтобы у меня склопилось в R-. Потом я просто выношу это сюда, потому что оно от и не зависит,
и получаю просто по окрению хэш. И того, что мы с вами получили, что если я знаю хэши для всех
префиксов, то я знаю хэш любоподстроки быстро достаточно. То есть что я могу сделать? Я могу
начать, во-первых, хэши всех префиксов, причем за линию используя вот эту рекурренту, так называемую,
и сразу начать все иксы во всех степенях. Потому что эта штука, она не больше, чем для нас строки,
очевидно. Ну и все, и тогда вы можете просто брать нужные вам штуки. То есть как искать хэш под
строки? Хэш под строки ищется очень просто, вот так вот, по этой формуле. То есть научились.
Р. Это R. Но мы искали от LDR, зная все h, i, t, p, i, t за от единички.
Находим h от p, l, r. То есть мы умеем находить, мы не будем их искать сейчас, но мы умеем
их находить. Как теперь работать в алгоритме Rabinocarp, собственно? Алгоритм Rabinocarp устроен
очень просто. Давайте посчитаем хэш паттерна и потом пойдем скользящим окном считать хэш под
срок соответствующей длины. Если не равны, то вхождения точно нет. Если равны, то надо проверять
наивно, просто в тупую сравнивать. Удержается, что в среднем будет линия. Почему это так? Потому
что здесь нужно рассматривать. Ему равна вероятность того, что у вас здесь есть совпадение.
И здесь нужно сказать следующее утверждение. Точнее, как мы убираем qx? q – простое, x – случайное,
в таком вот множестве. Давайте от двойки хотя бы брать. Потому что x равны нулю бессмысленно,
x равны единице, плюс-минус тоже. А вот x равен двойке уже имеет смысл. То есть убирать
какой-то случайный за этих чисел. Что делается дальше? Дальше рассматривается вероятность того,
что h от x равно h от y, где x и y – разные сроки. И показывается, что она у вас не превосходит,
что она равна, меньше либо равна, чем 1 делить на размер вот этого множества. Потеряем без зуб,
чтобы у вас коллизия произошла, вам необходимо, чтобы у вас там последние члены совпали. Вот.
q – 1. Ну, вы равны q, не будьте врать, вы будете считать все по модулю q. Да, здесь везде по
модулю q, если что вычтения берутся. То есть берется x типа r-r-1 по модулю q. Эта штука по
модулю q. Перемножаются они по модулю q. Всем из этого вычитают этот и снова берут по модулю q.
Если все арифметика модульная, то это будет классно, если вы напишете в ревью класс модульной
арифметики, чтобы было проще жить. Заодно задавать туда простое число в compile-time проверять его,
что у вас поле и что вы умеете в нем делить. Иначе, если это непростое число, обрубать
оператор деления в нем. Ну, это так. Задачка node3 по плюсам. Если что, не шучу, это на комиссии была
задача в первом семестре у Мещерина. Там нужно было написать кольцо многощенов над полем. Ну,
над кольцом. Если это поле, то их можно делить. Ну, самоделение надо было реализовывать.
zp от x, если у вас есть keep, значит это такое. Compile-time. Так, окей. Понятно,
как алгоритма Rabinokarp работает. Вот, и выясняется, что если возьмете... короче, выясняется,
что вероятность коллизии... а, у нас были хэши, вы знаете, что такое коллизия. Коллизии
не превосходит 1 делить на q-3. Вот, это bd, если что. Вероятность. Ну,
дайте я напишу здесь нормально, тут совсем все плохо. ABD. Ну, тогда что остается взять?
Сколько подстроек мы перебираем в тексте длины паттерна? Ну, худшая оценка порядка длины текста.
Тогда при q больше, чем квадрат длины текста, вероятность хотя бы одной коллизии
не превосходит 1 делить на q. А если у вас вероятность длины коллизии не превосходит 1 делить на q,
то у вас в целом все прекрасно. Потому что можно по неравенству марково оценить
ожидание числа коллизий, и оно там будет меньше одного, короче. Вот. У вас будет меньше,
чем одна коллизия в среднем. Поэтому у вас среднее время работы выходит, что у вас очень мало
раз придется наивно проверять полностью все строки, всю длину строки, и все будет хорошо.
Поэтому в среднем тоже линия получается. Вот, окей. С этим справились, да? Да, это не сложно
доказать самому на самом деле. Ну, вы берете, расписываете, что у вас две разные строки,
и они многощенно от них равны по модулю q. Берете тогда разность по модулю q равна нулю,
ну и смотрите, когда у вас разность равна нулю, просто-напросто. Вы выносите там, получается,
у вас будет выноситься этот. Сейчас я скажу, что именно. Ну, у вас x берется одинаковый,
поэтому везде выносится x-вытый, и берется разность коэффициентов везде. Ну, и чтобы
оно там где-то обнулялось, у вас получится примерно один дель на q. Ну, один дель на мощность
этого множества. Собственно, это верно только в поле, поэтому q простое. Более того,
вам же нужно брать q достаточно большое, поэтому вы заранее фиксируете большое q,
да, простое и больше, чем квадрат длины текста. Сразу спойлер, есть такое классное число. По-моему,
оно выглядит вот так вот. Вот, по-моему, оно простое. И VDA 63-1 простое, и VDA 64-1 простое.
Нет, просто, оно просто простое. Ну, можно явно проверить, но утверждается, что простое. По-моему,
числа мерсена они называются или что-то такое. Кстати, скажу сразу, вместо x очень плохо брать
двойку, потому что существуют контратесты под двойку, очень легко строятся. Называются строки
TOE-MORSE. Это такие забавные строки, в которых у вас очень много коллизий будет, если x равен двойке.
Ну и в целом здесь важно про хэши понимать следующее, что если некий злоумышленник знает ваш х и знает
ваш q, то он очень легко построит, ну не очень легко, но построит контратест, вот так вот скажем.
То есть, есть алгоритм нормального, плюс-минус адекватного построения контратеста, если вы знаете q и x.
Поэтому, если у вас задача не заходит хэши, вы должны будете попробовать поменять просто x и q и
понять, что теперь заходит. Просто антихэш-тест у автора под эти параметры есть, а под другие нет.
И из-за того, что x и q можно выбирать достаточно многими способами, все-таки простых много
достаточно чисел, а x чуть побольше, чуть-чуть совсем. Вот, тогда пар еще чуть побольше, а тестов все-таки
поменьше. Как бы очень интеллектуальная оценка, тысячи тестов у вас не будет задача.
Нет, вы зафиксировали q. У вас q фиксирован.
Нет, вы зафиксировали q какое-то. Большое, да.
Ну, если вы зафиксировали и вы зафиксировали x, вот. Тогда у вас для двух строк вероятность
коллизии вот такая вот, для двух случайных строк. Ну да, при любом фиксируемом.
То есть многочлен тут рассматривается. Ну, на вики, по-моему, нет доказательства строгого.
Там вроде была ссылка на статью, где это оказывается нормально.
В крайнем случае там указан автор этого хэша, и там у него точно можно найти доказательство.
Так, все, третий способ. Это префикс-функция.
Про что префикс-функция у нас? Мы, так, покукарекали про время.
Ну, смотрите, я доказал, что вероятность коллизии хотя бы меньше, чем один делец на q.
Окей. Тогда, значит, у меня, грубо говоря, коллизии нет. Так что я делаю? Я просто беру свой текст,
беру паттерн и просто везде его прикладываю. Так как я считаю сначала префиксные хэши для всех,
тогда для текста я знаю хэш любого строки золоть единицы. Ну все. Коллизии при этом мало.
Обычно в задачах, когда пишут хэши, это именно немножко такой практический момент в плане
спорт-проги всякой и всяких олимпиадок и контестов. Никто не пишет здесь проверку явно за линию.
Если не заходит, все просто меняют параметры q и x, пока не зайдет. Все, примерно так. Вот.
Никто не сравнивает, да. Вам хорошему надо проверять. Ну, более чем по-хорошему,
нужно изучить просто нормальные алгоритмы и не пользоваться хэшами. Но иногда они вам пригодятся,
потому что эти хэши можно обобщать на двумерный и трехмерный случаи, в частности. Но об этом на
семинаре поговорите. Так, префикс функции. Кто это такой? Ну, матрица, фотография. Вы хотите
найти прогресс фотографии? Фотография. 3D фотография. Ну, в смысле? Ну, я не знаю. Не особо важно.
Важно то, что это можно сделать просто. Если вам интересно, зачем, то я отсылаю вас к литературе.
Я не знаю такой литературе. Так, кто такой PS от И? Префикс функции обозначается буквой P.
Максимальная K такое, что...
Вот такая вот картинка будет. Так, это картинка, теперь формула.
Вот наша строка S. Так, вот наша точка I. Тогда у нас должно быть равенство вот таких вот тук.
Вот это вот. Это K. Это I минус K плюс 1. Вот. Ещё мы хотим махтивно участвовать в эту штуку.
План у нас простой. Определить, что такое su prefix. Определяем.
Супрефикс на строке S называется под строка P. Такая, что она одновременно и префикс, и суфикс. Очень интеллектуально.
Можно переписать тогда определение. PS от И. Это длина максимального su-префикса U S.
Вот так вот можно писать. То есть можно писать либо через индекс, либо через su-префикс, это понимать.
Придётся проникнуть с картинкой.
Вот наша строка S. Всё. И допустим я знаю, что вот это вот её su-префикс. Давайте его подлиннее нарисую.
Вот это её su-префикс. То есть вот эта штука равна этой штуке.
Как устроим второй подлиннее su-префикс?
Заметьте, что если у вас эта штука равна этой штуке, то у вас что получится?
Вот у вас второй по длине su-префикс. Вот такая вот штука.
Вот так эти две штуки равны. То есть у вас равенство всех четырёх подстрок наблюдается.
Почему? Допустим это su-префикс строки, вторая положенность.
Тогда он равен вот этой штуке. Но вся эта штука равна всей этой штуке.
Поэтому эта равна этой, а эта равна вот этой.
То есть su-префиксы позиции И имеют вид.
Первый su-префикс это максимальный по вложенности. Мы определили его как префикс функция.
Согласны? Ну просто по определению. И вот первый su-префикс.
Второй su-префикс в силу того, что мы определили, что здесь и здесь равенство, он равен su-префиксу вот этой штуке.
То есть su-префикс. Второй su-префикс это максимальный по вложенности su-префикс первого префикса.
То есть это вот этого штука. То есть максимальный su-префикс вот этой вот строке.
Кто подскажет третий su-префикс?
Да, именно так. То есть они устроены вот таким вот интересным образом. Все su-префиксы.
Вот. Ну вы еще можете сказать, что вся строка это su-префикс.
Это будет правдой. Но однако мы будем рассматривать не собственные su-префиксы, то есть не равные всей строке.
Поэтому вот так вот. Собственно алгоритма очень простой построение тогда префикс-функции.
Он устроен так, что вы будете считать также для очередной и этой позиции и просто пересчитывать, когда у вас символы совпадут с следующими из одними.
Поясню сейчас, что я имею в виду. То есть допустим я посчитал для первых и позиции и хочу посчитать для и плюс первой.
Давайте вот так вот. Для первых и минус один посчитал, хочу длительный посчитать.
Случай первый. Это какой? Что я могу продолжить текущий su-префикс на единичку?
Да? Могу же так сделать?
Когда это будет верно? Тогда когда у нас вот это равно вот этой и вот этот и ты символ равен вот этому символу.
Держи и минус один, потому что мы переписали. То есть если у нас верно, что s и ты равен s вот
Вот такой вот штуки. То есть этот символ совпадает вот с этим. То есть это x, это x какой-то.
Ну тогда просто-напросто.
Плюс один. Просто уличаем на единичку.
Второй случай. Это когда-то неверно. Что тогда мы должны сделать?
Тогда как мы можем продолжить так, чтобы остаться su-префиксом? Мы просто должны перебрать все su-префиксы меньше длины.
Если мы какой-то из них смогли продолжить, то это победа.
То есть если я не смог продолжить вот этот большой, то вдруг я смогу поменьше продолжить?
Тогда я должен смотреть здесь и вот. То есть допустим здесь y, а вот здесь вот x.
Ну я тогда же могу продолжить на один просто su-префикс чуть поменьше.
Но эти другие строки мне не нужно рассматривать. Почему? Потому что они su-префиксами не являются.
А если у вас вот эти части не являются su-префиксами, то у вас и расширенные на один su-префикс не являются.
То есть поэтому это единственный кандидат, который надо перебрать.
Ну что, y, p, s от i минус 1.
S от i, s от i минус 1, плюс 1.
Не равно s и тому.
И при этом i.
Вот так вот.
Нет.
Я хочу просто перебрать все su-префиксы.
Ну давайте так я кодом пока напишу. Потом поправим чуть условия, чтобы у нас здесь нигде выход за границей не прилетал.
Потому что мы же не можем бесконечно их перебирать.
То есть мы закончим перебирать, когда у вас p, s от i минус 1 равно 0 просто.
Вот эта штука она равно 0. Вы закончите перебирать.
Кого?
Нет, вы хотите проверить, что у вас вы перебираете все su-префиксы уменьшающиеся, то есть у них вот такие вот индексы будут.
Вот это их длина.
Зачем?
Я не пишу код, я пишу просто певдокодом то, что мы перебираем их все. Код сейчас будет.
Ну действительно. Мы же хотим продолжить su-префикс только.
Ну в прямом.
Потому что я ничего не написал.
И не собираюсь дописывать.
Ну в смысле, я здесь написал просто перебор. Я не написал, что буду дальше делать.
Почему? Потому что могу.
Я сейчас напишу полный.
Я же сказал, что мы это не учитываем.
Что?
Ну да. Если у вас строка из всех ашек, то мы учитываем длинную строку минус 1.
Если у вас верно это, то вы делаете вот так вот. Иначе вы делаете это, когда у вас закончился.
Ну окей, хорошо. Здесь надо сказать, что k равно i, перебирать по k. Затем сказать, что k это значение, что перификс функции в точке i равно k плюс 1.
И вот теперь вы поймете. Но мне лень. На текущий момент.
Я напишу словами. То есть перебираемся все супрификсы. Все супрификсы.
И пытаемся их продолжить.
Вот. Теперь код.
Который вы конечно нигде не найдете.
И в нем найдете. И в нем найдете. И на ВИК-конспектах найдете. И на ИМАКСе найдете. Везде найдете.
По-моему только в Корване не найдете. Потому что в Корване строк почти нет.
Ну что? Укнута не знаю. Я знаю, что есть книга Гасфилда классная.
Вот можете книгу Гасфилда почитать. Там про строки много. Вектор int p. Наша перификс функция.
Давайте теперь говорить, что...
Теперь мы допустим знаем все, что до it построено.
Что будем делать?
Ну первый случай. На самом деле понятно, что можно просто вайлом рассмотреть все эти случаи и все.
Они вложены друг в друга.
Поэтому я здесь сижу сразу себе, что int k равно...
Ой, p, извините.
p, s.
Так, p, it.
Вроде бы так, да? Перебираем, что k равно p и минус 1 только, наверное.
Вот это текущее значение перификс функции.
И теперь мы будем просто вайлом смотреть, можем ли мы продлить наш текущий значение перификс функции.
То есть вайл k больше 0.
И...
s, it не равен.
s, k?
Я буду говорить, что k.
Теперь я смотрю, что если у меня k будет больше 0.
Так, сейчас. Здесь k-1 будет.
И теперь давайте осмотреть, что если я все-таки пришел к успеху, то есть у меня s, it оказался равен s, k.
То что тогда у меня получается?
Тогда я делаю плюс плюс k. То есть увеличиваю на единичку все-таки это значение.
Что если s, it...
Ой, мы последние, здесь нужно писать p, it...
равнул k. Ну, все, это конец.
Здесь осталось фигуными сковками закрывать.
Здесь?
k, it и k.
Если что, первая ряд свободен.
Я бы не сказал.
Ну, тогда доски хватает на два предложения.
Ну, все, мы научились... так, теперь мы научились вам строить p-функции.
Давайте поймем, за сколько эта алгоритма работает.
Ровно столько, сколько у нас страции вайла.
Верно?
Ну и сколько их?
Да.
А доказать можете?
Ну, у вас, короче, смотрите, доказать есть следующее,
что суммарное количество увеличений, вот это вот,
их не больше, чем длина строки штук.
Каждая итерация вайла только уменьшает.
Поэтому суммарно, причем уменьшает хотя бы на один.
И пока не ноль.
Поэтому суммарно, может, у вайла не более, чем две длины строки,
но с один итерацией.
Потому что каждая итерация уменьшает на один.
То есть за каждую итерацию мы увеличиваемся либо на один,
либо на ноль, либо вообще уменьшаемся.
Вот так вот.
Что k? k определяется снаружи вайла.
То есть k это текущие значения префикс-функции,
мы перебираемся у префикса просто-напросто.
А k отвечает за вот этот перебор по ним.
Так, окей, что тогда?
Время работы так обосновали.
Тогда остается последнее, это как искать подстроку в строке с помощью этой штуки.
Ну да, пишем паттернешь фоткотекст и перебираем индексы нужные.
И вот эта штука с префикс-функцией называется алгоритм-кнута Мориса Прата.
Алгоритм-кнута Мориса Прата.
Шаг первый.
s равно p пишет kt.
Шаг второй.
Строим p, s.
Смотрим на картинку.
Тогда в хождении есть позиции i.
Есть у нас равные вот такие вот штуки.
То есть здесь у нас позиции i.
И т.д.
Равен длине паттерна.
Тогда это только тогда, когда у вас есть хождение p в тв в вот таком вот индексе.
Ой, два модуля p.
Почему минус два модуля p?
Во-первых, вам нужно вычислить вот эту вот штуку.
Во-вторых, еще у вас вот эта штука вычитается один раз.
Поэтому в системе отсчета на токе текста у вас хождение вот здесь вот.
Это i минус длина паттерна и минус еще вот эта штука будет.
То есть снова за линию нашли все хождения.
А, ну у нас лекция как раз закончилась.
Ну все тогда, всем пока.
