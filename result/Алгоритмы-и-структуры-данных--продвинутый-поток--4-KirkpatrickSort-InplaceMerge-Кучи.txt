Сортировку, которую я в итоге расскажу, на самом деле написать можно.
И может быть она даже за какую-то крутую симптомику работать будет.
Нет, теоретически можно. Практически рассказывать я буду о сортировке не ради сортировки, а скорее ради модели.
Потому что нам пришло время как раз поговорить о том, о чем мы, о каком мире мы вообще живем, в какой модели мы вообще в вычислении живем.
Мы живем в такой штуке, как рам модель.
Поговорим немножко об этом.
Давайте вообразим себе.
Как, по крайней мере, с точки зрения официальной науки мы считаем, что компьютер устроит?
Мы, конечно, неформально считаем, и будем считать, что алгоритм меряется в операциях C++. Что мы там пишем на C++, так оно работает.
Ну практически.
Но более официально это работает так.
Значит есть некий ящик, в котором у нас все будет работать.
Вот. Значит есть входная лента.
Вот у нас будет такая вот входная лента.
Которой, ну как вы уже зарадуетесь, к нам будут поступать данные.
Данные поступают очень интересно, мы их только один раз можем считать.
Да, сразу оговоримся, что такое ячейка.
В каждой ячейке находится B-битное число.
Что такое B? B это мистическая константа вашей системы.
То есть условно говоря, с B-битными числами мы умеем работать за от единицы.
Ну в современном мире B чаще подавляюще в большинстве случаев рабло 64.
Ну или в ранних редакциях было 32.
Вот, значит есть входная лента, есть выходная.
То есть мы тут начинаем что-то печатать.
То же, то есть печатать мы умеем только B-битные числа.
Вот это у нас входная-выходная лента, но работает в ней некий мистический ящик.
Даже не совсем черный.
Что у нас в нем?
Он у нас состоит будет из двух частей.
В нем есть программа.
И регистры.
Они прямо на бите так и нумируются, начиная с нуля.
Причем более того часто подразумевается, что регистры нумируются аж с нуля до 2 в степени B минус 1.
То есть в принципе все индексы тоже являются B-битными числами.
Вот.
И также еще важно пока мне сказать на уровне заклинания на ближайшую минуту, что конкретно нулевый регистр он выделен.
Он называется суммат.
Вот.
Почему он так отдельно выделен?
Потому что модель у нас устроена будет таким образом, что все индексы у нас выделены.
Вот.
Почему он так отдельно выделен?
Потому что модель у нас устроена будет таким образом, что все экспетические операции будут выполняться строго через него.
То есть условно говоря мы не можем сложить там.
То есть то опять как вы уже поняли это память такая.
То есть в каждом регистре находится какое-то B-битное число.
Вот.
Но пятое седьмым вы сложить не можете.
Ну, по крайней мере напрямую.
Вы можете только скопировать пятое число в сумматор, прибавить к нему и прибавить к нему седьмое число.
Вот.
То есть вот примерно так это будет работать.
Вот.
Вот.
Вот.
Да.
Внутри регистра находится B-битная числа.
Да.
Можно лучше сразу сказать без знаков.
Вот.
Так что вот такая вот красота у нас получается.
Вот.
Ну а теперь, ну самое интересное конечно, как у нас выглядит программа.
Ну программа естественно состоит из команд.
Ну давайте смотреть.
Какие команды у нас вообще есть?
Вот.
Ну во-первых давайте подумаем.
Значит что у нас тут есть?
Так.
Ну вот.
Ну команды, как вы уже сказали, по идее есть конечно команды ADDUS.
То есть эта команда занимается тем, что берет нулевой регистр и прибавляет к нему какой-то регистр.
Но в каком виде она это делает?
Смотрите.
То есть как команде ADDUS передается на вход параллельно.
Он бывает трех типов.
Вот я нарисую так.
Равно 57, 57 и звездочка 57.
Вот.
Какого-то такого типа.
Ну естественно вместо числа 57 может появиться абсолютно любое число.
Правда, обратите внимание, важно оно как-бы фиксировать.
Ну никогда просто.
Что же это такое?
Значит ну в предлагаемых вот обозначениях.
Да, обозначения предлагаются с такими авторами как Аха, Хопкрафт, Фульман.
Вот.
Да, к сожалению, я запамятал в какой конкретной книжке это предлагалось.
Но авторы такие, да.
У этих трех авторов как бы есть подозрение, что больше, чем одна книжка.
Там в основном по построению конфилиаторов.
Вот, но тем не менее.
Значит так вот, они предлагают следующее.
Значит обозначение такое.
Значит равно 57.
Это означает, что мы прибавим к сумматру реально число 57.
Прям вот именно с того, то есть плюс равно 57.
Да, это до 57 будет означать, что мы прибавим то, что находится в 57-ом резисторе.
И наконец, и наконец вот самое интересное, просто едва ли нет, там, программа образующая.
Укажите, что будет, если мы прибавим звездочка 57?
Она предлагает то, что находится в резисторе, в котором адрес находится в резисторе 57.
Да, да, так что наверное.
То есть в переводе говоря, мы пойдем в 57-ой резистор, возьмем оттуда число, пойдем оттуда...
О, спасибо.
Пойдем оттуда в резистор номер, что там в 57-ой числе написано.
И вот это уже прибавить.
Да, это называется посленная адресация.
Если это написано.
Ноль.
Вон, как писано.
Вот, вот.
Нет, ну...
Ну в принципе да.
Можно еще раз?
Равно 57.
Что?
Равно 57 прибавляет буквально число 57.
Ну, к сумматору.
Перед первым нулевым резистором.
Да.
Более того, результат сложения, естественно, кладет в нулевой резистор.
Да, то есть с репетическими операциями вот будет всегда так.
А умножить?
Умножить?
Нет, это не умножить 57, это...
Да, скорее указатель.
Это...
Это означает, что...
Ну, скажем так.
Если вообразить себе эти резисторы как массивы, то это будет так.
R0 плюс равно R с индексом 57.
А, вот я даже так здесь напишу.
То есть смотрите, вот это здесь означает R0 плюс равно 57.
Здесь это будет R0 плюс равно R57.
Это другое.
А тут R0 плюс равно R с индексом 57.
Чего?
Память, память и регистры это одно и то же.
Ну, да, мы...
Ну, скажем так, там разные варианты.
Ну, в самой простой версии подразумевается, что регистр вот там...
Просто столько же, сколько бы битнов чисел.
Так, почему я это в руках держу вообще?
Так.
То есть...
Нет, ну как сказать...
Нет, погодите.
Нет, понимаете, ты в программе заранее не знаешь, что у тебя написано в этом регистре.
Вот.
Итак, значит, смотрите.
Ну, значит, если говорить об арифметических командах, то что еще бывает?
Ну, естественно, бывает команда вычитания, команда умножения.
Хотя тут начинаются споры, в некоторых моделях умножения нету.
Вот.
Что еще есть?
Ну, там какой-нибудь там ДИВ есть.
Ну, целочит целое деление.
Ну, мод обычно сюда не вставляют, потому что на самом деле мод прекрасно реализуется через там мульт и ДИВ.
Логично, да?
Чего?
Ну, и через суп тоже, да.
Ну, как угодно, в общем, короче говоря, добавлять не обязательно.
Вот.
Чего умножение?
Умножение через ЭД.
Через ЭД.
Ну, как сказать?
Ну, так теоретически, конечно, да.
Правда, но заметим, что в таком виде, если бы язык ограничился только этим, то на самом деле мы сделать тут можем ничего вообще.
Да, потому что мы даже сочетать данные не можем.
Да, конечно же, нам всякие считывания должны быть, но здесь вот не ошибиться.
Потому что, во-первых, есть операция...
Что мне все хочется держать, господи?
Так, какие?
Да.
Да, там все идентично.
Так, значит, какие еще операции есть?
Вот.
Ну, есть операции.
Во-первых, есть операции Рид и, соответственно, ее напарник Райт.
Они параметров не принимают.
Вот.
Потому что Рид, он говорит следующее.
А считай мне, пожалуйста, следующее быбитное число с входной ленты.
А куда?
В сумматор.
Просто записать?
Ну, типа того.
Считать первое?
Ну, вот.
Так же.
Ну, вот.
Нет, считать следующее.
Входной ленте есть указатель.
То есть он просто считает вот это число и сдвинет этот указатель.
А Райт отправит в другую сторону.
Вот.
А Райт?
А тоже из сумматора.
Вот.
На самом деле этого достаточно, потому что по факту мы сейчас увидим.
Вот так.
Что же у нас есть еще?
Вот.
Значит, смотрите.
Во-первых, Рид и Райт это мы говорили из входной-выходной ленты.
Но там как бы все считанное один раз считали и все.
А тут, что вывели, то уже навсегда.
Для того, чтобы изобрести счетчик конструкции через джамп, нужно изобрести джамп.
Для начала.
Для того, чтобы джамп было понятно куда.
Погодите, погодите.
Ну, погодите.
Сначала давайте еще хотя бы все команды говорим, потому что этого тоже мало.
Потому что есть Рид и Райт, а есть, конечно,
Райт.
Райт.
Райт.
Райт.
Точно так.
Уcrit trademark.
Уوعרא competence I.
Р suficiente.
Р AND.
Р again.
Р а hashtag.
Р..
Ну.
Отлично.
Сicker.
На самом деле cal �нар啦 на작а Us.
Т apls.
Да, или соответственно, что находится в регистре номер 57.
Вот, ну это точно такое присваивание.
Только если lot – это присваивание, достань оттуда число и положи его в сумматор,
то store – наоборот. Возьми то, что лежит в сумматоре, и сохрани туда.
Ну или по тому числу, которое там написано.
То есть в программе в этом месте написано в явном виде константа и какой-то значок.
Store равно 57. Ну, стало быть, не бывает.
Да, ну lot – это типа загрузить, то есть достать из памяти, а store – это послать туда.
Вот так.
Ну то, что написано в соответствующем регистре, ну или там конкретную константу.
То есть lot равно 57, значит напишет, что в сумматор равен 57.
Да, то есть это будет просто, ну то есть, по сути, то же самое как плюс, только тут просто присваивание.
А так прям вот один.
Да, только наоборот.
В плане store можно все три вот эти параметры?
Нет, ну не все три, да. Store равно 57 – действительно сомнительно.
Потому что как бы не будет понятно, куда это собственно записывать.
Да, ну здесь как бы, конечно, здесь ограничивается все логичностью.
Вот.
Вот, но как бы заметим, что, конечно, пока все равно что-то не хватает.
Если у нас программа будет состоять только из этого, то программа будет работать за вот единицы, правда?
Ну, потому что у нас ветвления никаких нет.
Ну, если команда стоит только вот из этих операций.
То есть нет, я не сказал, что результат программы всегда будет один и тот же.
Но я утверждаю, что работать всегда будет за вот единицы, то есть программа может представлять собой только там последовательность операций, которые она скупулезно выполнена.
Вот, поэтому нам нужны какие-то ветвления.
Вот.
Так, ну что же нам сделать?
Ну, придется начать, конечно, с операции jump.
Ну, тут придется написать равно 57.
Почему здесь равно?
Пусть уже пришло время понять, как выглядит программа.
Ну, программа, естественно, выглядит как последовательность операций, на самом деле.
Тут мы ничего нового не изобретем.
Там нулевая, первая, вторая, третья там и так далее.
То есть программа начинает выполняться просто с нуля.
И как только она там дойдет, скажем, до конца списка, тогда она и завершится.
Ну, для того, чтобы у нас были варианты, появляется...
Ну, во-первых, появляется функция jump, так для удобства.
То есть jump прям в явном виде указывает, в какой точности места программы мы идем.
Вот.
Но ветвление, конечно, сам по себе jump не дает.
Максимум, что он пока даст, в таком виде это бесконечный цикл, если мы прыгаем назад.
Прыгает в строчку программы номер 57.
К регистрам это не имеет никакого отношения на этот раз.
Но для того, чтобы это к регистрам имело хоть какое-то отношение,
то есть...
Вот.
Вот.
Мы не можем инструкцию задать из регистра.
Что такое инструкция из регистра?
Ага, пойди в 179-ую строчку программы. Нет.
Вот.
Сейчас.
А вот мы там прибавляем число, вычитаем число.
Вот откуда берется это число?
Откуда в нашей модели мы идем про это число?
А это в команде написано.
То есть в этой строчке, вот я тут пишу, там вот может быть написано, например,
addada звездочка 57 или там выше.
load, допустим, равно 179.
Ну и так далее.
То есть вот так команда и выглядит.
А все-таки 57 это номер с точки, куда мы прыгаем, или количество операции до...
Чего-чего?
57.
Нет, в jump 57 нет.
Это означает, что ты как бы шел просто по списку.
В каждое время у тебя был указатель, который говорит, какую команду ты сейчас исполняешь.
Так вот, если это команда jump 57, то указатель перепрыгивает на 57-ую строчку.
Ну, можно и так сказать.
Ну, зависит от нумерации.
Ну, обычно нумеруют с нуля, хотя можно, в принципе, нумеровать с единицы, там не принципиально.
Ну да.
Нет, как повезет, может быть, хуже.
Может оказаться, что ты прыгаешь из более низкой команды.
И в принципе это может привести к бесконечному циклу.
То есть ты там долез, такой двухсотой команды, тебе сказали jump 57.
Так, дошел 57-ой, сделал все это еще раз и тебя опять отправили назад.
Да, ну пока, конечно, без каких-либо ифов это, конечно, тоже пока бессмысленно.
Что оно либо дает бесконечный цикл, либо говорит, что пропусти вот эти несколько команд.
Но зачем это сделано, непонятно.
Непонятно.
Да, да, начинаются все там прыжки, типа там, смотрите, вот это играем, это пропускаем, это играем, это пропускаем.
Так это я тут рыбу заворачиваю, поэтому и пропускаем теперь ноты, поворачиваем.
Так это.
Так, о чем я сейчас понятно?
Нашу отсылка, да.
Ну, хорошо.
Это называется у кого ноты, у кого в голове при этом возникли слова там, интермедиа, агонезов и винокур.
Ни у кого, ну ладно.
Ой, вот зачем нужно телевизор использовать, да, надо показывать все эти вещи, ну ладно, не важно.
Так.
Ладно, значит, смотрите.
И так, чтобы у нас были какие-то, значит, в роли ифа, у нас такой практически единственный иф будет, это такой G0.
Так, в каком виде он будет работать?
Ну, пусть он будет работать на самом деле.
Вот так вот.
G0 218.
Чего?
Ну, не знаю, потому что не все же 57.
Можно 52.
Ну, я не знаю, ну, то есть у вас плохие ассоциации с числом 218.
Хорошо.
Вот.
Ну, давайте, например, вот в таком виде.
Вот.
Ну, то есть, честно скажу.
Ну, то есть, совсем конкретные детали можно и запамятовать, но сейчас как бы нам нужно понять, как это устроено в принципе, то есть как бы совсем идеально мы копать не будем.
Вот.
Вот.
Значит, G0 будет говорить так.
То есть, смотрите.
Посмотри в сумматор.
Если там ноль, то прыгни, пожалуйста.
Вот.
Ну, обычно там так.
Если там равно нулю, то прыгни, пожалуйста.
Ну, вот.
Ну, вот.
Ну, обычно там так.
Если там равно нулю, то прыгни, пожалуйста, в 52 строчку.
А если нет, ну, тогда просто проэкономируйте дальше.
Ну, такой вот ифтик.
С нулем?
А чего бы нет?
Ну, там проблем нет.
Ну, обычно нет.
Ну, как сказать?
Как сравнить два целых числа с другим?
Ну, например, можно это сделать как поделить одно на другое вот с помощью дива.
То есть, как бы утверждение натуральное число а меньше натурального числа тогда и только тогда, когда а див б равно нулю.
Скорее вопрос, как можно проверить?
Какой инструкции?
Так вообще, я говорю, это она и есть инструкция.
Что вы имеете в виду?
Она дана.
Что значит?
Это как бы вопрос, как исходя из нее все остальное устроено.
То есть, это как бы дано.
Она есть.
Что значит?
Какой-то дискоммуникация.
Откуда берется?
Что значит, как устроено?
А как устроено?
Это вас не смущает?
Такой же абсолютный вопрос.
Нет, это аксиоматик.
То есть, смотрите.
То есть, как устроено нот.
То есть, скажем так, это модель.
То есть, мы считаем, как машина тюринга там условно.
То есть, машина тюринга тоже в природе не существует в явном виде.
Ну, там ладно, кто-то там, конечно, сделал отдельную красивую ленту с красивым маркером, эластиком.
Но в реальности тоже ее нет.
Этого тоже в реальности нет.
То есть, это такая абстрактная модель, в которой мы живем.
Ну да.
Есть разные варианты.
То есть, есть вариант, например, может быть, кому-то...
То есть, там есть альтернативные модели, в которых есть аналогичная команда Gen Zero.
Очевидно то, что одна не выражается через другую и не наоборот.
Ну, вообще говоря, да.
То есть, можно там специально занять регистр, который будет там превращать...
Ну да, то есть, видимо, превращать число в ноль, если оно не ноль, и наоборот.
Превращать ноль в не ноль.
Ну, в какой-то бул, так что там плюс-минус одно и то же.
Ну, давай.
То есть, тоже там.
Поэтому я тут в скобочках пишу.
Так.
Битовая операция.
Ну, это так.
Вот.
На самом деле, хороший вопрос.
Потому что, вообще говоря, есть.
И более того, часто в моделях они в явном виде даже в базе прописываются.
Правда, смотря какие.
Потому что, если вам нужна, например, операция, сдвинуть вправо на 12 бит,
то, в общем-то, это эквалентно тому, что есть 2 бита.
Сдвинуть вправо на 12 бит, то, в общем-то, это эквалентно тому, что сделать дифф на 2 в 12.
Правда?
Вот.
Ну вот.
А если, например, сдвинуть наоборот 12, то это получается умножить на 2 в 12.
Но здесь, соответственно, нам придется прописать важную вещь.
Какую? Что мы делаем, если происходит переполнение?
Ну, мы с вами, видимо, будем говорить, что если происходит переполнение,
значит, все происходит по модулю 2 в степени B.
Как в реальном компьютере, кстати, происходит обычно.
Обычно.
Видимо, Мишель нас уже предупреждал, что стандарт C++ не гарантирует,
что при переполнении NTA там все будет именно по модулю 2 в 64.
Для безнаковых гарантирует, а для знаковых нет.
Чего?
Да, у нас безнак.
Нет, как сказать, у нас не C++.
Тут как бы аккуратно.
В джаве, например, понятия безнаковый тип нет вообще.
Да, в питоне вообще нет понятия 32-битный тип.
Да, в питоне нет вообще.
Да, ну, то есть это уже такое.
Нет, то есть конкретно другая.
Потому что если говорить о том, как там реально компьютер устроен,
то обычно у вас будет такой предмет, как окоос,
оно же архитектура компьютерной системы.
Там вы будете уже изучать, что такое гарвардская архитектура компьютера.
То есть там уже будет подробнее написано, там как он устроен конкретно,
что там как раз программа и регистр, это будут, на самом деле, перемешанные вещи.
То есть там действительно программа режет едва ли не в той же памяти,
но там, правда, в памяти регистры будут немножко разные вещи.
А что значит магические буквы АС0?
АС0?
Так вот тут уже я не скажу.
Хотя я тоже их видел, но именно на этом уровне я их понимаю.
Ну, скажем так, теоретически нужно.
То есть практически мы с вами этого заниматься не будем.
Может не в последнюю очередь, потому что я сам в этом не разбираюсь.
То есть я, в общем-то, это рассказываю только так, в какие-то общие види,
чтобы просто было представление, что вот эта штука есть.
Вот так скажем.
Да.
Какое?
Какое множество регистров?
А какое у нее отдельное название?
Так называется регистры, потому что других регистров нет, другой памяти нету вообще.
Да, просто память, да, и все.
То есть нет, это там в этих ассемблярах, да, там есть там, что есть отдельно,
там EIX, там ECX и прочая гадость, там есть что-то отдельное, есть отдельная память и так далее.
То есть знаете, вот этим и называется, что есть абстрактная модель,
а есть конкретная, сколько вешать в граммах.
Соответственно, да, это разные вещи.
В этом месте, оказывается, напоминаю, что мы здесь все-таки занимаемся скорее математикой.
Поэтому у нас там подобного рода мелочи обычно игнорируются.
Вот.
Итак.
Вот, но оказывается, то есть ну в принципе давайте все хотя бы вообразим,
хотя бы протестируем навшивость.
А может ли с помощью вот этого всего хотя бы массив считать?
Вот знаете задача, дано число N, и дальше идет N-чисел, да?
Так.
Так, ну вот давайте подумаем, а каким конкретным образом это сделать?
Потому что, как вы видите, у нас же нет операции FOR, да?
Поспрашивайте.
Нет, ну не здесь 9 и плюс 7, но как бы видимо, в окончании FOR это называется.
В окончании FOR, да.
Дальше мы копируем то, что находится в сумат, они там В1, допустим.
Да, да.
Считываем коридор, то, что оно дано в массиве.
Ну и дальше еще один сторон записываем в другой регистр, и возвращаемся...
А каким образом выясняем?
А как вы выясняем, куда записывать?
А мы же можем через звезды снять?
Можем?
Ну да.
Ну да, но здесь вот действительно заветим, что фактически...
А ну поднимите руки, кто как-нибудь программировал на языке Паскаль?
Ой, как здорово. Молодцы.
Слушайте, Паскаль еще это не умер, да.
Вот, ура.
Вот, ну неважно, нет, потому что почему я вспомню язык Паскаль?
Потому что в отличие языка Си, переменные языки Паскаль прописываются в явном виде до начала программы.
То есть вы там посредине, там условно посреди мэйна, точнее аналогов Паскали, вы не можете написать там int Вася.
Нет, вот Си-Си тоже посреди функций нельзя.
Ну окей, да, хорошо.
Вот, но просто, да, удобно просто мыслить в таких терминах и мысленно сказать, что допустим, что вот R1 у меня будет N.
Это будет N, это будет И, допустим.
Вот, а массив А, а вот это вот будет, а это будет типа массив А на N элементов.
Типа от третьего до там какого-то N-2.
Я проверил, ассо-ноль это короче мы вводим все команды, которые можно реализовать.
Ну там, сейчас, как circle перевести на русский?
Circle?
Ну схемы короче, логические схемы, константной глубины и размера многочлен.
Ну да, и по этим причинам там говорят, что иногда говорят, что умножение туда не входит по мистическим причинам.
Понятно, спасибо.
Если мы умеем это реализовывать, то мы можем этим пользоваться как команды.
Ну да.
Это очень-то логично, потому что мы хотим оказывать.
Ну да.
Да, спасибо.
Да, circuit, если что, это имеется в виду вот такое слово.
Вот.
Нет, нет.
Ну это скорее схема.
Вот.
Так.
Ну вот.
Это у нас А.
Вот так вот массив.
То есть если хочется хотя бы его считать, то мы по камере можем действительно завести переменную И и написать какую-нибудь такую подпроцедуру, которая сравнивает переменную И с переменной N.
Вот.
То есть как это будет работать?
Как сравнить переменную? То есть верно ли, что И равно N?
Или не равно? Как это сделать?
Ну очень просто.
Надо отправить переменную И в сумматор, вычесть из нее N и проверить, получился ли ноль.
Вот, да или нет?
Вот.
Ну и не забывать там прибавить ей единичку.
Вот.
Что значит под программой?
То и значит.
Ну и здесь, конечно, официального понятия под программа нет, но как бы вы там зарезервируете.
То есть для того, чтобы сравнить там, то есть сравнить И с N, то как бы у вас будет там несколько строчек, которые будут сделать какие-то технические действия.
И чтобы в конце забабахать GZERO или GENOZERO.
Ну это понятно, мы же запускаем программу из разных мест.
Не-не-не-не-не-не-не.
Ну в данном случае это означает копипасту.
Да.
Как мы закончим программу, если ноль, например?
Чего ноль?
Ну N-0 как бы.
Ну а нет, просто в этом месте вы скажем, правильно так, если оно равно нулю, значит мы просто скакнем.
Ну просто вот где-то у нас это считывание заканчивается и там начинаются какие-то следующие действия.
И вот просто jump, то есть из какого-то места jump у нас скакнет сюда.
А мы типа с запасом возьмем вот эти?
Кого?
Ну считывая, ну как с запасом.
Ну мы мысленно себе вообразим, что у нас тут идет N-элемент.
Вот.
Ну как бы мы будем заранее знать, что они будут начинаться там с третьего.
Или там если вы хотите завести несколько еще переменных, то с четвертой.
Вот примерно так.
Почему?
Ну для того, чтобы понять, что цикл закончился.
Откуда программа узнает, что надо считать именно N-чисел?
Да, именно.
То есть это как бы такая реализация цикла.
То есть мы там говорим, что если у нас там и достигла N, как мы выяснили, то значит мы там jump'ем за пределы этого всего.
А если нет, то значит мы идем тут, считываем очередную штуку, увеличиваем и на единицу.
И тут jump'емся обратно.
То есть тут будет какой-нибудь jump еще вверх.
Это вполне возможно.
Так, ну вот, например, это так можно сделать.
Там можно также сумму искать и так далее.
Вот.
Но дальше начинается шоу.
То есть на самом деле модель в принципе достаточно хороша.
Вроде даже адекватно.
Но у нее есть правда неожиданная дыхка.
Эта модель считает, что у вас есть вот практически реально 2 в 64 памяти, и вы ей прям свободно за вот единицы пользуетесь.
Ну в реальной жизни, конечно, у вас, как говорится, если вам дадут оперативу на 2 в 64, это, конечно, кайф.
Но это называется, через сколько тысячелетий вам такую оперативу дадут.
Пока не понятно.
Или кому-то давали.
Хотя это называется, да, хранится ли в мире вообще столько памяти 2 в 64 байт?
Вроде так, да.
Нет, хотя ладно, давайте прикинем.
Хорошо, гигабайт от сколько?
10 девят.
Нет, 10 девят, да, это что-то типа 2 в 30 или 2 в 32.
Хорошо.
2 в 32 гигабайт, кажется, столько в мире есть, конечно.
Нет, в общем, наверное, миллиард гигабайт.
Ну да.
Ну да, да, да.
Ну хорошо, ладно.
Столько вообще в мире памяти есть.
А если в одном добром процессоре столько памяти?
Ну, сомнитесь.
Нет, там просто памяти бывает немножко разное.
Ой, вот об этом тоже мы сегодня должны поговорить.
Точно мы про внешнюю сортировку еще не говорили.
Ладно, придется телевизор включить.
Вот.
Ну ничего страшного.
Вот.
Ну, конечно, тут такая мечта.
Но с другой стороны, нет, и тогда оказывается, на самом деле,
то есть кажется, что вроде ничего страшного, но выясняется,
что там такие достаточно экзотические вещи.
То есть вот представим себе, что у нас, оказывается,
2 в 64 памяти есть, и у нас есть задача отсортировать n чисел.
Ну, за константу не получится, конечно, да.
Но, смотрите.
Ну, вот.
Ну, возникает вопрос.
Давайте себе вообразим.
Ну, хорошо, давайте прикинем,
за сколько можно вообще сортировать n бибитных чисел?
Ну, можно кинуть пузырком за n квадрат.
Да, можно попытаться каким-то мистическим образом
нарисовать какой-нибудь мерч-сорт или хип-сорт.
Нет, хип-сорт даже может легче,
потому что тут как бы еще отдельный вопрос,
как на этом всем реализовывать, например, рекурсию.
Ну, то есть понятно, что там надо какой-то стэк завести,
там все такое, но это из цикла думать придется.
Вот.
Ну, вот.
Ну, как сказать, просто сортировка подсчетом будет работать
за n плюс 2 в степени b.
Это многовато.
Вот, если мы забабахаем, скажем,
то есть мы могли бы забабахать что-нибудь типа n умножить на b.
А у нас b это переменная, b это не константа.
Ну, вообще говоря, ну, как сказать, и да, и нет.
Вот так.
Как это называется? Ответьте вопрос, да или нет ответ.
И да, и нет.
Называется да.
Нет, знаете, на вопрос a или b можно ответить да.
Это переменная или константа? Да.
Можно, но это совсем не информативно.
Нет, это все-таки отражает истину.
Потому что b это параметр модели.
То есть в данном случае мы фиксируем b,
но и программы тут пишут, исходя из того, что у нас тут b фиксировано.
Вот, но получается при раздах b получается, может быть, немножко разные модели
и немножко разные асимптики.
То есть асимптика может зависеть от b таким образом.
Да.
Ну, например, вот могли бы.
Да, вот если сделать, ну, как бы, если сделать какой-нибудь radix sort действительно,
то в принципе, ну, зная b, то получается вот асимптика от n на b.
Вот.
Чего? Ну, не совсем.
Ну, нет, ну, действительно, заметим, что b, конечно же, не превосходит log n,
потому что n действительно должно влезть в редистор, это правда.
А то и с запасом некоторым даже.
Вот, вот это да.
Но как бы, но как бы все равно из этого следует, что nb это не хуже, чем nlog n.
Нет.
Нет.
Хотя, а, ну да.
Так, ну хорошо, ладно, уговорили, уговорили, да.
Ладно, ладно, да, согласен.
Согласен, хорошо.
Да, поэтому да, здесь действительно nb.
Ну, правда, что тут можно делать?
Можно же там начать развлекаться и вспоминать, что мы в один, в count sort,
там в этом radix sort не обязаны по одному битку только писать, да.
Мы же там можем брать несколько бит, которые там образуют число порядка n.
И у нас там что там получалось?
На самом деле, могло получиться nb поделить на log n.
Вот.
И вот что лучше, вот это или nlog n, это на самом деле уже вопрос.
Ну, в зависимости от b и конкретного n, конечно, да.
То есть вопрос, что больше, b или log квадрат?
Обычно, скорее всего, log квадрат.
Ну, не, ну да.
То есть это, конечно, n должно быть уже достаточно большим, чтобы это конкурировало.
Ну да, ну это и следа, b64, конечно.
Но ничего страшного.
Потому что мы все равно сейчас будем стремиться к асимптотике nlog b.
Вот.
Смотрите.
Но здесь мы прям в наглую начнем пользоваться, что ячейк у нас прям вот очень много.
Значит, потому что...
И чего?
Не, смотрите.
Значит, мы сделаем вот так.
Значит, нам дают на вход n чисел.
N битных чисел.
Так вот, мы их мысленно разобьем на две половины.
Типа большую и меньшую.
И дальше сделаем что-то типа подсчета.
Ну, в том плане, что значит для каждой первой половины, ну, условно каждой,
мы прям в явном виде выпишем все числа, которые с нее начинаются.
Точнее, все правые половинки.
Ну, прям можете себе вообразить что-то типа вектора векторов.
Понимаете, да?
То есть получится какой-то набор вот таких списков.
Там массивчиков точнее, да?
Вот.
Ну, идея будет в том, чтобы просто отсортировать каждый список, а потом все аккуратненько вывести.
Ну, для каждой первой половины мы прям выписали прям все список правых половин, которые соответствуют.
Да.
Ну, что-то типа вектор векторов, но не совсем.
Чего?
Ну, да.
Но, правда, есть маленькая оговорка.
Чтобы сделать такой вектор векторов, это потребуется и памяти 2 в степени b пополам,
ну, 2 в степени b пополам векторов.
И пробираться прям придется по 2 в степени b пополам векторов, а этого, наверное, не хотелось бы.
Что же делать?
Ну, это, конечно, нужно делать.
По 2 в степени b пополам векторов, а этого, наверное, не хотелось бы.
Что же делать?
Ну, сделаем мы, вот сейчас будет неожиданно, сделаем мы неожиданно наглую вещь.
Значит, ну, во-первых, ну, там это вообразить себе можно так.
Во-первых, начнем с того, что выпишем все левые половины и рекурсивные, ну ладно, у нас по-любому рекурсивная сортировка есть, да?
Так вот, давайте выпишем все левые половины и рекурсивно их отсортируем.
Вот.
И не просто отсортируем, а еще и удалим дубликаты.
Вот, хотя...
Нет, лево, почему?
Левое, ну, во-первых, среди этих чисел могут быть повторяющиеся,
а во-вторых, почему бы даже если чисто не повторяются, левым половинам не повторяться?
Ну, теперь вопрос, как его создать?
Как мы уже сказали, просто создать вектор на 2 в степени b пополам векторов мы не можем.
Это было первое приближение, мы уже ушли дальше.
Да нет, так это не отставайте, пожалуйста, это называется.
Нет, у нас нет двумерного массива никакого.
То есть мы уже ушли дальше.
Ну, теперь у нас есть какая-то вопрос.
Но на самом деле, для того, чтобы нам было удобно, на самом деле от дубликатов мы ухитримся избавиться даже раньше, чем запускать сортировку.
И сделаем мы это неожиданно наглым образом.
Ну, чтобы в рекурсии запускала, в рекурсию передавать поменьше чисел.
Повлияет.
Более того, это нам еще и не хватит, придется еще думать.
Значит, смотрите.
Значит, как будем удалять?
Но здесь, видимо, еще, как минимум, видимо, придется еще забабахать неожиданное предположение о том, что у нас все регистры по умолчанию равны нулю.
Например.
Вот. И тогда, конечно, пробираться.
И тогда избавляться от дубликатов очень просто.
То есть фактически у вас получается такой просто забабахался просто на автомате массив юзит.
Вот, понимаете, да?
Вот, и забабахался такой массив юзит.
Чего? Не слышал?
Ничего?
Да, но разница в том, что мы его как бы не создавали в явном виде.
Нет, фишка такая, что пробираться по нему не придется.
То есть, как бы, когда мы избавляемся от дубликатов, просто мы бежим по нашим Н-числам, берем левую половину и говорим, так, в массиве юзит она есть?
Не записываем. Или если ее нет, о, ее нет.
Значит, мы записываем это число и в массиве юзит помечаем.
Например. Аналогичным образом можно, в принципе, даже для каждой левой половины сохранить, а сколько у нас там правых половины.
Вот.
Так что вот такая вот неожиданная идея. Понятно, да?
Вот.
То есть, более того, далее, согласно этому списку, посчитав для каждого элемента, получается, левой половинки, сколько правых встречается, можно, в принципе, вот такие списки тоже вполне себе составить.
Правда, единственная проблема будет в том, что эти сами, эти левые половинки еще пока не отсактированы.
Понимаете, да?
Вот. Ну, правда, их можно, конечно, в этом месте уже отсактировать.
Вот.
Но тут уже порядок не принципиальный.
Ну, то есть, алгоритм после этого простой. То есть, надо будет отсактировать эти левые половинки, а также для каждой левой половинки отсактировать ее списочек.
Ну, все делаем, естественно, рекурсивно. Причем рекурсия уже будет знать, что мы уже сортируем не битные числа, а б пополам битные числа.
Понятно, да?
Понятно, да?
Поняли, как делать эти списки.
Вот.
Ну, вот. Ну, с отдельной песней, которую мы пока вынесем за скобки, как делать рекурсию.
Вот.
Да, тут, конечно, будет... Чего говорите?
Нет, тут еще отдельный вопрос. То есть, у нас же всего памяти два в степени В.
Да.
Мы используем два в степени В пополам... Ну, около два в степени В регистра, нам же еще служебные, не можем cemetery.
Ну да.
Может быть такого, что на служебной регистре места не оста��ться?
Нет. Ну там просто в рекурсии будет сначала два в степени В пополам, потом два в степени В на четыре, а потом два в степени В на восемь и т.д.
В полом panic stuffindistinct Mohammed
Вит Отс dudes
Да. Так что на служебной... Чего?
но например так то есть вот у вас был массив на 2 в степени b пополам вы знали где он находится
сразу после него будем записывать вот эти списки вот ну вот как-то можно сделать ну например так
но например так то есть ну бы мы же уже выяснили про каждый элемент собственно где он находится да
ну таки нигде он находится а сколько сколько ну а дальше ну да дальше факт то есть
да вот нет то правда не до 22 степени б 2 степени минобой пополам
да вот ну дальше по по ним можно можно сказать вы помните как мы там в каунт сорти делали да
где где эти списки заканчиваются ну или наоборот начинаются вот но там это можно параллельно
но то есть сначала насчитать эти чисел тебя потом пробежаться по списку допустим второй раз и там
скажем когда мы какую-то половинку видим первый раз значит мы там помечаем что ее список будет
заканчиваться вот там скажем вот в этом месте ну да но это можно я бы сказал что лучше пробежимся
на там третий раз и тогда уже будем записывать вот вот да ну не понял вопроса
нет то а что нам надо нам нужно там пара нам нужен массив юзит на два степени б
пополам вот то есть мы его знаем мы его используем вот допустим в смысле не понял
чем нет мы помяну господи ну то как 5 монет можно качу мы уже по моему мы уже с этого там уже
много много итерации прошло то есть там скорее всего в этом месте у нас будет одновременно и
едет и там и массив юзит и будет еще одновременно еще там по количеству там для каждой левой
половинки сколько там по количеству соответственно чтобы там еще потом еще потом бы чтобы это еще
превратилось где они находятся и так далее ну да ну давайте заведем ну заведем массив размера не
два степени бы пополам от 3 на 2 степени бы пополам где для каждой там левой половинки будем
три числа хранить там какой-нибудь юзит типа юзит 0 или 1 но который там будет периодически
зачищаться там второй там сколько сколько элементов и третье чтоб там хранилось еще там
там где где заканчиваются текущие элементы например ну как отсылка к отсылка к там
радиорсорту по эти где мы там сначала мы считали сколько в корзинах элементов потом по каждой
корзине считали где она заканчивается а потом пробегались по массиву там задом наперед и
там сдвигали указатели какие-то
сейчас нет погодите погодите не понимаю что значит рекурсивный
нет зачем
ну но если в видео вы слишком привязываетесь к активке естественно там никаких указателей
не там в таких явных видах не будет но там скажем для каждой левая духа что там для левой
половинки будет храниться там где этот массив начинается где массив заканчивается то есть
в каких конкретно регистрах то есть скажем там для этой половинки он будет там но вот но вот
это да тут да ладно тут видимо больше абстракции требуется просто вот да ну да то есть возможно
их придется еще куда-нибудь скопировать чтоб там было удобнее работать еще кстати когда когда
вы выходите из рекурсии важно будет еще все что вы использовали за нулять обратно потому что вы
потом будете запускать еще но как бы все что вы использовали можете занудить за там получается
от а прям а как занудить этот массив на два степени бы пополам этот юзид очень просто
прибираемся по тем же элементам и во все юзид и пишем 0 но так и пишем ну скажем так это да
пишем но лот равно нулю и там и и но ты и стор по этому адресу типа того но там придется ладно
под адрес придется из конкретной переменной крыши подгружать на самом деле тоже но вот соответственно
датам развлекалочка будет вот но тут на самом деле возникает самое смешное ну давайте думать за
сколько это работает на самом деле кто-то уже на самом деле нам уже сказали проблему такой
алгоритм работает за так нам хочется сказать что за n лог b но отсюда логично предположить что как
бы рекурсивные что как бы рекурсивно то есть когда у нас б битные числа мы рекурсивно запускаемся
от б пополамных чисел да там б пополам от 4 и так далее но понятно что когда б станет равно там
один или два то мы там любым подсчетом отсортируем уже числа да но хочется наверное сказать что на
каждом уровне наверно передается там собственно и отсисел да но давайте вот да а то есть по в
щеда если формально писать то получится эно ты от иен бы равно чему давайте так давайте скажем
что этих различных левых половинах допустим нет ладно х
х вот тогда это равно получается там от н плюс т от получается
каба пополам плюс т от получается к 1 нет ладно не к 1 л 1 но
это вот длина первого списка плюс т это л2 в пополам плюс и так далее плюс т от
лк в пополам вот вот получается такая рекуррента вот и хочется что-то про нее
сказать хочется доказать даже чему хочется доказать что т от нб не
превосходит c н лог б если мы пытаемся это по индукции доказать то что у нас
получается получается т от нб меньше либо равно а n плюс там ка там на лог 2
b минус 1 плюс сумма л и тх на там соответственно этот лог 2 б
чего а ну да да да да забыл вот так ну хорошо это у нас получается а и
значит плюс сколько там получается плюс цена n плюс к и в скобочках лог 2 б минус 1
так можно ли сказать что это не превосходит цен лог 2 б
ну да тут как бы проблема в том что вот это к может быть вплоть до n и тогда может быть
многовато так ну давайте так давайте по очереди так там будем мы нету так нету как
удалять дубликаты нельзя потому что их потом же все выписывать как-то ну может
да но как это поможет здесь улучшить оценку почему это да но просто особенно когда n прям
значительно меньше там как-то 2 в степени b а то как бы только на очень глубоком уровне
рекурсии начнет помогать это эквивалент вообще то есть это на самом деле идентичность тому
будет что а давайте просто если чисел у нас стало меньше чем n давайте по сортируем под то есть
там если там скажем 2 в степени b стало меньше чем n давайте подсчетом сортировать это в принципе
идентично да да это будет это как бы может быть база индукции там будет все за линию до кайф то
есть может быть там и синтетику где-то еще там на какой-нибудь там логин поделим вот разве что
но потому что мы ну как бы мы все действия которые тут делали делается за линию ну кроме рекурсивных
вызовов вот а также что нам нужно нам надо взять под сортировать все левые половины вот это мы
делаем это количество различных левых половин поэтому брали левой половины удаляли дубликаты
и по каждой левой половине еще составляли список правых вот ну потому что мы числа пополам поделили
тут пополам бит тут пополам бит вот и тут но это что у нас у нас все числа б битная то есть
мы сортируем не рандомные элементы а именно б битные числа а то и мы сводим это к рекурсивному
вызову для сортировки б пополам битных кейс вот ну тут суммируем но так как вот l1 плюс l2 и так далее
плюс lk это в точности n потому что это по сути сколько у нас всего правых половина
чисел а и нас всего ровно n какие длины но это длинный списков а суммарной длина этих списков
ну вы раз ну задачка как говорится это называется было у пети спи 57 яблок он разложил их на три
списка первом списке было лежали красные яблоки во втором желтые третьем зеленые внимание вопрос
какова суммарная длина этих трех списков другая задачка у пети было 57 яблок от каждого яблока
он отрезал половинку червивые половинки он выписал в первый список там собственно нормальные
половинки во второй а те в которых там на которые села муха на третий сколько суммарно половинок
списков то это половина к яблок лежала в трех списках но если я брошу от стихии чисел первую
половинку то колеса чисел остается таким же ну а потом я эти числа я никуда их не выкидал
разбил на блоке а чину что сумма сумма этим блоком будет и хорошо а изначально и что
и начало количество элементов просто у нас осталось таким ну потому что только первую
часть да да да у нас тоже таким же но у нас я для каждого элемента однозначно знаю объекцию
и блоков какой он идет это не длинная длина блока то длинно она же длина списка она же размер списка
а длина видимо путаница с длиной числа понятно но окей ладно вот хорошо но
действительно проблема пока остается да ну да но возникает не а не возникает вопрос ну
чё ну что это такое что про вот про вот алгоритм прямо так тупо устроен даже из-за того что у
вас там какая-то рекуррента не сходится давайте вот в каждом списке максимум искать но
а какой в элемент отчипить ставкой то есть вы как раз будете за вот это куда-то элемент
вставлять нет ну хорошо но тут возникает вопрос что что то есть вы как-то то есть вы реально
считаете что автор статьи называется реально значит сказал что там нет что-то не сходится
поэтому давайте сделаем подобного рода лайфхак так вот в этом юмор заключается
браво да он именно это и делает ладно нет он делает умнее он он он сразу находит максимальный
элемент да да то есть я все в шоке видят обожжу что реально прям вот статья прям написано давайте
из каждого списка еще да прям честно за линию достанем максимум и выкинем его и тогда и тогда
после этого да тогда здесь там все эльки получаются минус один и все автоматически сходится да причем
там рикуррент он явном виде не писал но видимо вот мы мысли он видимо вот так же как и ты да то
есть сказал чтоб суммарно в рекурсии там переходила н элемент да да но это было просто очень забавно
но вот ну в статье если быть точнее но потому что у нас раньше не сходила что у нас тут сумма
была не на n плюс к если тут изденели это то тогда убиваем получается тот получается цен логен цен
логб минус цен плюс аэн ну соответственно да там при ц больше либо равном а соответственно сходится
вот да но на самом деле нет ну как то есть это там статья там авторы статьи там вот киево первых
кирк патрик да поэтому называется кирк патрик сорт вот то есть кирк патрик рай ну как сказать
скажем так скажем так конкретно таким образом выделены выбранные модели нас память не
в данной модели никак в данной модели никак тихий тихий тихий спокойно вот в реале но там но если
я как бы приблизить это к реальности то видимо вы будете просто реализовывать кирк патрик сорт
на хэштаблицах да нет самое смешное что нет то просто вот действительно как три вот что есть
вот такое есть вот мы еще будем изучать такая братская структура в некотором смысле дерево
в одном дыбу оса на хеда а ну-ка прийти руки кто сталкивался с деревом дым дыбоса хоть в
каком-то виде ладно скажу что это такое вообще значит нам хочется реализовать на это то есть
мы идем дальше мы хотим не отсортировать эти числа а мы хотим реализовать на них сет то есть что
такое то есть какой что значит сет значит хотим реализовать структуру данных которая умеет
добавлять элемент удалять элемент понимать здесь ли сам элемент а также по элементу искать там
всякие саксы там следующий элемент там предыдущий там всякие лавербаунда пербаунда короче вот так
вот структура опять будет жестко пользоваться тем что мы храним именно б битные числа и будет
прям жестко использовать прям вот все эти регистры если не больше то есть официальная но то есть там
то есть условно идея на самом деле начинаться будет примерно также то есть во-первых мы там то
есть там будет идея такая что во-первых там по моему для то есть мы будем делить половину тоже опять
числа на левую половину и правую для каждой левой во-первых для каждой левой половины там
будет храниться прям реально рекурсивно сет правых половин прям рекурсивно а также у нас
отдельно еще будет сет самих левых половин которые не пустые ну сет ну смысле типа рекурсивно
та же структура то есть да да но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то но-то
на самом деле во многих алгоритмах начинает работать это мистическая хэштаблица то есть там черный ящик который умеет там добавлять элемент удалять элементы и говорить есть ли такой элемент и все это делать за единицу да да мы причем всем плевать да это вероятностный естественно алгоритм там но как бы всех устраивает
нет ну не знаю но я не знаю я не уверен что она будет работать прям мега быстро особенно по сравнению с там просто если вы хотя бы вот это реализуете нормально потому что вы смотрите вас в реальной жизни и ты ну максимум до 10 18 в общем то есть чем запускать вот эту рекурсию с этими птическими там анордерет мапами векторами может вам легче было на самом деле действительно сортировать не рекурсивно например там каким подсчетом или вообще хипом да нет ну понятно
что чемпионам скорее там скажем так дайте нет это отдельная песня удастся ли вам вот таким вот образом да вот таким или этим сортом убить ну хотя бы стд сорт то есть он как-то там на шаблонах это должно теоретически тормозить но время реально там ну а какие ну какие но там будет интеллектуальная задача причем давайте возьмем интернет
ассорт давайте возьмем рандом и завалим интернет ассорт ну завалим в том плане что давайте попробуем взять взять теста который будет реально застрянет ну вот если за квадрат он конечно не застрянет но как бы соответственно но впрочем шансов мало а
но работает так ну просто но смотрите раньше мы суммировали тут было к плюс или 1 плюс альдва плюс альтер и так далее да и тогда если это просто там по индукции переходить то в сумме получится вот тут цена n плюс к но потому что сумма всех элях равна n вот но а теперь предположим что мы передаем в рекурсию здесь не 1 элементов 1 минус 1 потому что мы например перед тем как запускаться рекурсивно прям за линию
честно максимум нашли и выписали отдельно тогда в рекурсию мы передаем или 1 минус 1 л 2 минус 1 и так далее лка минус 1 но да нет там было просто n плюс ка превращается в ка плюс вот это это сумма получается n минус ка и кашки убились ну да максимумы естественно суммарно по всем спискам за вот это нашли да вот так что вот такая вот
радость так что вот такое вот да может быть немножко сумбурно действительно такой вот то есть если в эту сторону копать то вот приблизительно такие такое счастье там можно найти особенно в старых статьях то есть конечно да то есть не то что мы этим будем заниматься то есть я это всегда так рассказываю просто то есть знаете я как-то как-то вот как учить левее какая учить физики про квантовую физику то есть как бы не для того чтобы все это прям идеально поняли того что просто поняли
что это вот бывает и примерно вот так вот работает давай ну потому что люди надеются ну как бы как бы и академический интерес такой что чистать ну я там чистать но нет не совсем он тоже стартирует б битные числа
вот но просто лога как вы уже сказали как вы уже поняли лучше чем б поэтому лог логан автоматически лучше чем лог б
и здесь ща сейчас ну пройдите пройдите пройдите так
не но там просто это будет очень осмысленно что фишка будет в том что мы как бы да может показаться что мы тут в рекурсии будем до лога найти на
самом деле не будем потому что чем меньше список тем как бы глубже придется в нем идти в этом плане да поэтому да
да ну вот даже лог логан лог лог логан даже лучше так что там это интеллектуальная вещь но отходить туда то что вот такое вот бывает
теоретически видимо в этом можно даже да то есть как бы да то есть конечно понятно что то есть это
конечно наука может поиграть может получить неожиданный смысл если действительно б будет неожиданно
расти там когда выкишь 64 там 128 256 или там там до конь миллион дойдет и так далее то есть тогда это может тогда это может
стать осмысленно но там то есть пока конечно да это больше как какая-то там просто и там там где-то абстрактная интеллектуальная
игра но что делать у нас экологически чистая математика существует как бы это да и енот и ею
занимаются так что вот так ну вот ну ладно дерево нам дебосом крыши скопать не будем
ну в свое время конечно должны а как же вот но я но думается что логично это делать наверное в
том месте где у нас будут собственно остальные все деревья а про деревьев у нас нет то есть максимум
что у нас будет это куча но до куч нам тоже еще сегодня надо дожить потому что нас вон и внешнюю
сортировку надо покопать и еще надо ин плейс мерш обсудить да да но да но как говорится каким образом с
помощью крыльк каким образом линейный алгоритм строится с помощью крыльки в ухе мы с вами узнаем
после перерыва все возвращаемся в нормальный мир то все как бы с нормальными алгоритмами они этим
вот безобразием и так и так задача но точная обстановка значит такая значит данные дан массив
который разделен на два отсортированных куска вот
разделенность массив на два отсортированных куска задача сделать из этих или из двух отсортированных
кусков один отсортированный кусок ну смержит 20 ровных массива может показаться что это не
сложно если только не одно но хочется использовать вот единицы дополнительной памяти то есть
переводи говоря хочется переупорядочить элементы вот этого массива так чтобы они
были отсортированы уже образовали единый отсортированный кусок но при этом помимо этого
массива использовать только там какие-то конечное число переменных условно говоря
вот так так что это это будет у нас собственно этой называется там им плейс мерч то есть
вот так называется задача вот теперь поехали как же и решать так ну не просто придется разомнуться
на чем разомнуться не тот и прикол что разные хотя если бы они были одинаковые нам бы это
сильно не помогло но значит смотрите на самом деле есть два скажем так я думаю есть две
разминочные задачи которые нам в конечном счете помогут вот давайте сначала начнем с такой дан массив
вот так нужно сделать завод единицы дополнительной памяти циклический сдвиг
да ну нет ну тут надо уточнять насколько да вот давайте допустим нам нужно сдвинуться только
на один элемент ну тогда действительно легко сохраняем его фориком там фориком все сдвигаем
на единичку записываем в конец да без проблем а теперь когда выясняется что вам нужно сдвинуться
либо то есть хочется сдвинуться не на один элемент а на целых к но в данном случае наоборот то есть
все элементы с виду так а влево как первых отправить в начало так нам нужно переписать
ну понятно ну да ну в принципе да есть да есть и такой вариант действительно то есть по
каждому элементу можно легко вычислить а куда а где он должен по идее оказаться правда но
первое нулевой элемент должен оказаться в позиции n-ка но там n-ка ты там в n-2 к там и так далее
правда и в принципе так вот мы можем только идти идти идти и тут вот если окажемся вот еще
раз здесь ну значит тут происходит какие-то зацикла и делаем так пока очередной элемент
не должен оказаться в нулевом элементе да единственное только оговорочка что конечно
скачаток от нулевого элемента мы вовсе не обязаны пройти прям по всему массиву правда ну
например если n равно там 18 а к равно 3 тогда где мы проскачем тогда как бы нулевой элемент
перейдет в 15 15 в 12 12 там в 9 9 6 6 в 3 3 в нулевой да то есть в общем случае придется посчитать
действительно гцд или нот но теперь да хорошо задача даны два числа как почти как посчитать
нот за от единицы дополнительной памяти да но первая подлянка 6 вы напишите стандарт
алгоритм рекурсивный алгоритм то вы пофылить потому что рекурсивный алгоритм это не от единицы
дополнительной памяти просто сразу если вы только не гарантируете конечно что там вызов в рекурсии
будет там вот единицы нет просто хотелось обратить на это внимание нет ну как сказать числа ну как
сказать глубина рекурсии ну зависит от да от это зависит это нас не устраивает но как мы помним на
самом деле есть алгоритм который ищет гцд с помощью вайлика это понятно о чем речь да так
что не не боимся останавливаться поэтому просто хотелось обратить внимание да что как бы рекурсии
нам бы хотелось пользоваться не но потому что три какие вот возьмем нулевой элемент и
будем от нулевой переставим на его место там следующий там на его место и так далее и
зациклимся внимание вопрос какие элементы по каким элементам мы пробежимся ну рано или поздно
нулевой вернемся но вот вот поэтому зациклимся да ойли вот в примере с кара внутри равно 18
выяснилось что мы так прошли не все элементы потому что нулевой перешел в 15 15 в 12 12 9
9 в шестой шестой третий третий нулевой то есть прошли только элементы делящиеся на три
вот то есть получается мы прошли не все элементы ну понятно что если мы стартуемся с первого
то пройдем те же самые элементы только со сдвигом остается только вопрос а сколько раз нам
надо так сделать ну вот гцд до гцд нк в буквальном смысле вот такая радость но есть такой вариант так
что в принципе да можно вычислить явном виде гцд и сделать вот такие сдвиги но правда кто-то
в начале упомянул весь принципиально другой не менее красивый способ способ называется
но то есть способ такой неожиданный а давайте-ка при вот жил был массив а давайте-ка его
переверсим да ну такая изя задача в качестве упражнений остается как переверсить массив
завод единицы дополнительной памяти так ну надея но надеюсь это никого не пугает или или пугает
или надо рассказать как это делается нет ну знаете там шутки шутками а потом вы выясняется что для
кого-то там что для кого-то скажем кусок сотни там допустим вот он в кусоке вот это вот разбить
элементы на меньше и больше 100 единиц дополнительной памяти это неведомая страшная магия поэтому
и переспрашиваю так надо обсуждать как реверс завод единиц памяти нет никому не надо все хорошо вот
так вот идея такая хорошо приверсили массив потом разбили его на вот типа последние к элементов и
разбили мысленно естественно и каждый из этих массивов пореверсили
вот я утверждаю что получилось ровно то что надо
по большому счету это как бы этот реверс то есть как бы циклический двиг можно устроить как мы
распилили массив на кае минус кае склеили их в другом порядке вот то есть еще вот такой еще красивый
вариант есть что реально реализована в алгоритме стд rotate честно говоря я не знаю ну философский вопрос
у тебя есть один цикл по которым ты идешь вперед и ты начинаешь прыгать назад
так прыгаешь прыгаешь прыгаешь и не нужно задавать какой-то массив юздов чтобы не попало
в какое-то число два раза ты гарантированно первый раз типа второй то же самое с которым ты начал
может даже ничего не запоминать можно просто делать типа ровно n прыжков и начинать сначала с
первого элемента это что значит ровно n если вы из каждого элемента будете ровно
н прыжков делать то вопреки ну можно и тогда ну в общем да ну хорошо да десять способов как
реально гцд не считать хорошо ну ну как угодно но на самом деле как бы если вот вопрос почему
писать это то этого алгоритма мне кажется может быть маленький недостаток недостаток называется
сколько по сколько перекопирования вы здесь будете делать хотя нет если вдуматься то на
самом деле нет нет ну не совсем смотрите хотя нет ну формулу можно вопрос не в этом вопрос как бы
где больше хотя заметил она хотя я утверждаю что переприсваивание как это не странно тут и тут
в любой редакции будет одинаково хотя а хотя нет тут побольше но там смотрите каждый но
смотрите каждый элемент здесь я утверждаю что копирование будет ровно 2n уж вы каждый
элемент значит куда-то себе значит скопируйте в tmp шка потом куда-то поместите до свопов да
насколько присваивание вы делаете свопах да но это называется как вы это называется как вы
делаете своп конечно и замечательно особенно учитывая что мы свопаем элементы в конкретных
массивах они там вот это вот да когда нам как когда вы фактически это как бы как бы просто
это работает из цикла что возьмем два элемента и перевесим на них этикетки но тут у нас такой
опции нет к сожалению это если числа но но и но естественно у нас речь идет о том что мы это
что тут у нас калишки как всегда калишки черный ящик ну компаратор который я говорю все это но
вот тогда это важно проговорить особенно в свете предыдущего безобразия но вот да то есть
если числа то конечно дата можно развлекаться как угодно но факт остается фактом ну если она ну
как вам сказать но я боюсь что теоретически можно придумать структуру который так и сработает
то есть векторы конечно вы так по сваппайте это да нет ну кстати что любые две все структура
может содержать больше чем от единицы памяти да ну да нет ну как сказать я ну теоретически можно
но как бы но я боюсь так практически это да это уже конкретные модели что что тут конкретно хочется
и подгонка так что лучше нет указательные конечно можно дай вот там можно стоп но правда
там проблема в том что даже в сваппани к сором там по моему три присваивания с этими к сором
идет да там так или иначе но вроде 3 но да получается три да то есть получается вот это
по присваивания в полтора раза хуже там по моему там нет там а там нет сейчас
нет погодите нет в нашем случае смотрите в пример давай пусть к равно один да просто
нет пройдите пройдите пусть к равно один я утверждаю что он присваивает не хватит вообще
потому что я ну левой записываю в тмп шку здесь делаю прям честные присваивания прям честно
не смапа даже именно присваивания и после этого вот этот элемент помещаю сюда все так что тут
получается ну как-то не трин пополам уже заведомо вот более того когда вы делаете цикл пока то
по большому счету вы делаете то же самое но мы здесь не делаем свопов
но это но это такой отдельный скайп это отдельный случай если кара вновь пополам и в этом
случае боевая ничья но это тем более но вот то есть как поэтому кажется что ну мне просто
такие аргументы на самом деле должны были убеждать стандарте плюс плюс что имеет
смысл реализовывайте хотя и стандарте не написано как-то надо реализовывать там как там
наверное гарантируется только что вот единицы дополнительной памяти еще и еще вообще по времени
за линию все а там что вы там внутри пишите типа ваше дело нет это вряд ли я думаю тут
гарантируется что не на рандомизирует нет n с элементом мы же про ротэйт говорим нет
n с элементом рандомизированный дань и наверное требует и все этих 5 фамилии они не будут
ну да так ребят ау
так смотрим дальше так господа ау ладно это был у нас ротэйт вот что тут вспомнился тут
захотелось обсудить значит это у нас был ротэйт следующий вопрос но на самом деле
попытаемся приблизиться уже к мерчу давайте нот давайте попробуем вспомнить сколько нам
реально нужно дополнительной памяти вообще могло бы могло бы дополнительной памяти возникнуть
чтобы слить эти два массива да мы с вами прошлый раз убеждали что если у нас есть допамяти
размера минимального массива то в принципе этого хватит помните как мы это делаем то есть
напоминаю мы этот элемент значит этот массив сюда копируем а потом честно вот 2 2 указателями
сюда сливаем еще то с учетом то что это указатель может выйти за эту границу и оказывается что нам
самое главное что это указатель никогда не догоняет этот как бы я если это указатель отсюда
сдвинулся что тут находится нам уже по барабану ну скажешь так максимум что сделать это его
догонит этого но это будет просто означает что вот этот массив закончился а дальше можно ничего
не делать что ну можно ну зачем можно просто копировать это это уже мертв мы уже друг мы уже
мы забыли мы давайте мы уже другую задачу решаем да осторожно да знаете я как бы знаете
дети два плюс два ровно 4 ой почитай ой посижу кайф телефоне почитаю да вылезаю из телефона
а потом после этого сублимации супер эго очень резистенто по отношению коллективно бессознательному
так что давайте как так что давайте к телефончике убирай да нет я не знаю да нет может быть конечно
да действительно на какой-нибудь банке тоже написано контент и интересная информация но
есть подозрение что она не поможет вот да а вот жидкость а вот жидкость в ней возможно
действительно да так ну хорошо значит за рить теперь значит какая у нас тут идея будет
значит первое чем мы о чем мы попытаемся заботиться это добьемся того чтобы у нас была
допамять под задача да у нас нет допамяти но нам хочется чтобы она была
да скачать дополнили до памяти используя да да да да так смотри смотри смотри так вот нет
чит на самом деле очень простой я могу вот допустим если мне дано число ка то я могу найти
ка максимальных элементов в этих двух массивах правда ну пока я описать где они находятся я точно
могу правда я просто какое-нибудь число вот я вот вот давайте просто задача даны даны два
отсортированных массива найдите в них каты максимум вот такая задача например да да сложная
но на самом деле идея очень простая давайте поставим два указателя и будем их как раз двигать
там в зависимости от того кто больше да нет обычный мёрч когда мы не просто двигаем еще и там
больше элемент куда-то записываем а здесь мы просто двигаем просто двигаем абстрактно двигаем
указатели вакууме чтоб получить каты максимум вот что это нам поможет сделать это нам поможет то
есть как бы в результате ка движение то есть у нас получится то есть вот сколько-то максимальных
здесь там ка 1 и сколько-то максимальных здесь ка 2 сумма ка понимаете да вот то есть вот это
ка максимум это мы знаем да так вот у меня идея такая а теперь давайте сделаем циклический
сделаем циклический слик таким образом так дайте как я начну делать давайте-ка я буду
сливать красный массив синим массивом но так чтоб красиво было вот так вот идея теперь такая
теперь у нас будет начало красного массива дальше идет начало синего массива
нет рекуррента 5 это по-моему про логарифа было или нет или про что-то еще нет да нет вроде и
тут а то дальше кончик первого массива кончик второго массива вот но на самом деле мы вот это
вот все объединим то есть мы скажем что у нас теперь допустим вот здесь ка каких-то
элементов причем не обязательно от сортированных да но мы можем конечно они там образуются с
два сортированных массива но нам плевать потому что смотрите щит будет заключаться в следующем
значит внимание то есть мы вопрек можем так сделать а в тех можем еще не просто сделать а
сказать что к приблизить на равно корень из и ну вот значит зачем мне ка приблизить то корень из
так вот у меня идея сумма двух массивов да она то сумма двух массива значит если так вот я
утверждаю что я теперь то есть я нашел корень изен максимум ну порядка там там где-то два корня из
н будет на самом деле так вот я утверждаю что я теперь вот эти вот элементы могу использовать как
допамять ну например вот то есть то есть ну рассмотрим да там рассмотрим допустим простой
случай рассмотрим случай когда синий массив оказал по длине оказался меньше чем корень из
и после этой операции ну вот давайте вот такой вот этот такой длинненький массивчик а этот
синенький оказался коротенький да но я для этого и для простоты да если красненький оказался
меньше то как бы мы их посвапать можем без проблем да потому что это тоже самый циклический
сдвиг по большому счету вот мы себе уже да вот так вот идея такая значит но мы знаем что надо
слить вот этот с этим и вот это еще ко максимум тогда идея такая давайте сольем вот эти два
массива только идя справа налево они слева направо и записывая вот сюда но вы мо да вы можете
сказать что да если тупо записывать то мы эти элементы потеряем навсегда но фишка будет
заключаться в том что когда нам то есть мы будем не просто записывать мы будем свапать то есть
когда нам мам скажу вот этот элемент должен быть записан сюда мы говорим ok так посвапаем вот этот
элемент с этим да да это такой буфер да но мы нашли ко максимуму прямо в самом начале но
но просто фишка они будут как-то рандомно перемещаться они вот как-то рандомно перемещаться
по массиву вот пытаемся померзли вот мы будем мерзлить вот этот массив вот мы
предположили что после этой операции которую мы сделали оказалось что синий массив маленький
то есть меньше чем к да вот внутри здесь вот то есть ну вот чего это следующий случай пока
это разминочный случай чтобы мы просто понимали о чем мы вообще делаем вот я сейчас просто даже
на примере покажу как это будет выглядеть смотрите допустим красный массив у нас 2 6 там 10 14 21
46 а синий массив у нас допустим там 3 10 15 20 и при этом зелененький массивчик у нас какой-нибудь
достаточно большой да какой но мало еще надо и 2025 хорошо хорошо да но глава точно а поехали
да как там говорят это так главное чтобы было больше 45 поэтому что там дальше должно быть так
так да 2 3 9 обязательно и конечно же 4 4 4 да вот вот значит поехали делать будем так и так два
указателя на старт поехали так так что же у нас больше 46 или 20 очевидно 46 тогда идея датчик
понятно значит 46 отправляется сюда а 44 но то это 444 отправляется сюда
так 21 или 20 21 значит 21 свапается с 239 21 пишем сюда 239 пишем сюда так 14 или 20
очевидно 20 значит 20 отправляется сюда 2007 отправляется сюда вот
так 15 или 14 так ну 15 отправляется сюда 179 отправляется сюда так 179
но по факту да ну понятно как и ну как всегда мерже на самом деле да здесь здесь и куда записывать
так что там дальше 14 или 10 очевидно 14 так 14 сюда 57 туда вот так о десятки
ну не суть важно ну давайте напереда скажем для рандомизирования скажем что сюда пойдет
2007 а сюда пойдет 10 так и теперь туточки 179 сюда 10 сюда то есть слаб соседних элементов так
что-то нас еще так ну дальше 6 и 179 отправляется сюда так тут 179 6 да пока она вот да пока еще
мы вот сюда даже 3 но значит тройка остается здесь вот от двойка значит записывается
сюда то есть 444 не знаю вот смысле как мы прыгаем не понял но я просто здесь не рисовал в явном
виде указал мы тут естественно в явном виде храним указатель до куда мы здесь дошли так что
нет зачем нет не так было мы говорили вот у нас есть текущий красный элемент текущий
синий элемент выбираем кто из них больше вот мы выбрали тройка она должна куда-то отправиться куда
мы говорим текущий указатель и говорит что а проблема да видимо просто да идея в том что да
вот этот указатель должен быть да видимо этот массив должен быть маленьким они это они правый
да ну да видимо ладно так пример показывает что в таком виде не совсем работает но если окажется
что как раз-то холиментов меньше зеленых то должно быть все нормально ну давайте попробуем
не мы выбрали неплохой массив мы не угадали с какой стороны идти нет наоборот нам как раз
повезло у нас как бы ничего не схлопнулось но но но нам могло не поем ну да ну как бы да
ну типа того да да если бы брали только из красных то мы бы как бы все съели и пошли бы
дальше да вот да что в переводе на русский означает омням да да да вот так ну хорошо
значит давайте давайте 3 6 9 12 15 так соответственно ладно что тут еще дальше так два а нет наоборот
давайте тут их три элемента тут мы пишем 2 4 6 8 10 и тут какая-то рандомная гадость
рандомная гадость это да да да 179 там 200 218 239 так ну поехали значит сваппаем 10 и 239
ну как раз даже если нет сортирован и главное что не в конце все равно муктор
оцениваться и ровно это важно понимать так дальше значит 10 теперь так 10 9 сваппаем
9 и 218 9 и 218 так что дальше 6 и 8 ну понятно да тут 8 тут 179 так тут 8 так опять два одинаковых
элемента но в тов ты будешь делать ну не важно ладно давайте давайте ну как всегда 57 отправим
сюда 57 57 отправим сюда ну а шестерку вон туда значит шестерка так и 239 так значит так 4 так
что у нас дальше 4 179 4 и 179 так дальше 3 так ну хорошо 3 239 а летающий макер 3 и 239 вот
ну и соответственно что и что-то еще ну да и 2 179 мы сваппаем кто оказался так смысле а как а как как ты
да и нет нет почему тут сошлось а очень просто потому что когда вы записываете синие потому что
у вас как бы в каждом времени есть какое-то расстояние между тем куда записывать и
собственно последним синим элементом да и между ними находит вот этот зеленый блок каждый раз
когда вы записываете синие эти два указатель просто синхронно сдвигаются а когда вы записываете
красный зеленый приближается к синему поэтому там у нас произошла ситуация когда зеленый
указатель просто догнался и нам фантастически повезло что не обогнал а если красных элементов
меньше либо равно зеленых то гарантируется не догонит поэтому да здесь оказалось принципиально
чтобы именно правой массив оказался да но смотрите что теперь сделать и так и так
предположим что тут оказался у нас меньше либо равно ка элементов и тогда мы выполнили такой мерч
но мы еще не все закончили потому что все должно быть отсортировано не все кроме этого буфера правда
только двоечку я не правильно писал вот но идея очень простая если мы знаем что у нас есть буферы
с ка элементов и ка и это ка максимумов то ну где бы этот буфер не оказался но мы как минимум
можем сделать циклический сдвиг отправить но вот и отправить эти элементы в конец правда а
второе что самое главное если все остальное отсортировано нам с пустым мы можем взять и
отсортировать эти элементы например пузырком там можем мы можем принципе и вставками неважно
главное отсортировать их за n квадрат любым нерекурсивным методом сот единицей памяти
ну пожалуйста можете сипсортом но нам это не будет но вот нет понимаете нет это будет но там
проблема даже не в этом проблема будет проблема даже скорее вот 8 точки нам же в линию надо
уложиться да поэтому если мы сделаем буфер корень из n то как бы получать что можно сортировать
за квадрат в принципе можно обнаглеть конечно и сделать буфер размера n поделить на лог n и
отсортировать хипсорта вот но на самом деле нам хватит я утверждаю что нам хватит буфера порядка
корень из n вот вот носа но то есть какие вот примерно вот таким вот образом мы этим буфером
и будем пользоваться понятно да вот понятно да вот сейчас но вот так вот значит это у нас
вот такая вот идея то есть так вот может то есть там ка максимум от для любого ка таким
образом запилить отправить в конец можно подразумевать что мы их потом когда-нибудь в конце
каким чем-нибудь отсортировать вот начнем вот это нас приводит значит позволяет сделать следующий
шаг значит следующий шаг будет такой следующий шаг будет такой значит ка значит мы сейчас в
явном виде это число ка добавим хочется найти такое число ка ну во первых давайте так даже
не ка значит мы введем число бубен но сейчас еще крыша рановато его вводить то когда у нас там
будут всякие методы там четырех русских то как бы безгубно там никак вот поэтому сразу
можно назвать его бубен чего не но клауда вали пятых обычно звучит в бэно и ну ка не совсем то
будет но я скажу так давайте так у меня будет бубен но я сразу я сразу спалю он равен коде не
не паримся вот просто бубен значит и я хочу найти вот здесь у меня будет ка но мне будет
это ка лежать на там условно от 3 там на полу интервале от бубна до двух бубнов ну да знаете
не просто не два бубен нет максимум отсылка может быть знаете это как как звали советник это там
это там за советник и царей николая второго там но такие там и любит ваще раз пути два пути там
вот это все вот ну вот чего ка максимум ка максимум нет где ка это вот какое-то число такое
не просто такое число что n минус ка делится на бубен
ну формально я хочу найти такое зачем потому что следующий шаг у меня будет очень простой я
хочу вот эти оставшиеся массивы поделить на блоки по бубен элементов да и мне будет
очень хотеться чтобы я прям че прям хорошо хорошо поделил учитываем сейчас скажу как
смотреть значит главное пока но пока я добился того чтобы у меня как бы там лишних не было хотя
соответственно значит boobin boobin boobin boobin boobin boobin boobin boobin boobin
нет нет я никакие челюсти не смотрел поэтому и поэтому нет хотя может быть я случайно слышал
мелодию которая на самом деле берется из челюстей я не знаю так первое к чему дело
да у нас есть такие блоки один из этих блоков есть вот на границу он конечно может быть не
совсем от сортированной но идея на самом деле такая ну а первым можно по сортировать но но там
как бы у нас есть другие свойства нам пока еще интересно что как бы вот эти блоки образуют
тоже от сортированной массива эти блоки адвозуют от сортированной массива но этот лишний
boobin на самом деле нам погоды не делает не типично для boobin но тем не менее вот вот то есть идея на
самом деле бы то есть идея будет простая смотрите давайте временно выкинем эту погран заставу
из массива ну выкинем смысле там перетащим ее куда-нибудь в начало да тогда и смотрите
произойдет тогда у нас останется вот эти 20 ровных массива длина как длины которых прям
честно на boobin делится тогда если мы их аккуратненько сольем сумеем слить то тогда
у нас останет тогда нас останется значит этот буфер слитые два массива и в начале boobin
элемент как мы уже убедились мы то есть мы легко можем во первых по сортировать это вот этот
boobin просто там чем угодно там пузыречка а потом слить два массива пользуясь тем что этот массив
мелкий логично но да то есть отдельная песня что потом когда реализовывать будете это значит
все это реально придется делать но вот но да да да да именно но только единственное что этот
блок вам придется тоже внутри себя по сортировать но потому что видите не по сортирован нет его
нет это что нельзя он рекурсивный так что вы придется пузырек придется гонять пузырек ну
или тоже хотя нет это да бабл сорт скорее boost бабл сорт если там такое есть я подозреваю
что скорее есть чем нет но все так что так что вот на эту погран заставу мы как мы поняли можем
начхать вот и так что что мы сухом остатки получили и так мы получили я тут сейчас подробно
значит значит красенький от сортированной массив который мы поделили на блоке размера
бубен бубен бубен вот вот значит тут поделили на бубен и еще у нас есть буфер размера к больше
либо равно бубен вот теперь задача каким-то мистическим образом это все от сорти рова тю понятно
да так вот так сейчас будет может быть едва ли не самый не тривиальный шаг от сортируем
блоки от сортируем блоки по максимальному элементу ну в смысле по последнему да
спрашивается каким образом мы это сделаем нет мы не сделаем это пузырком дело в том что каждый
сват то есть у вас будет корень из ан блоков и вы будете тогда делать от ан свапов получается
а каждый слаб делается за корень из ан поэтому очень важно что мы делаем именно ставками потому
ровно в этом месте оказывается важно что нам важен алгоритм в который делает свапов там от
количества блоков то есть у нас вот почему оказывается сортировка в стапы чемпионская
теперь да потому что оказывается что она да она делает там н квадрат сравнений там н квадрат
сравнений но всего н переприсваиваний и вот конкретно сейчас нам это ой как надо потому
что каждое присваивание мы сейчас о корень из ан делаем видите да вот и так по сортировали да
но отдельная песня давайте скажем что давайте по сортируем по максимальным элементам а что
делать если элементы максимальные элементы равны стабильно но вот но на самом деле лучше
а как как стабильно сортировать кстати
мы же можем завести отдельные массивы с индексами блоков не можем это вот корни
дополнительной памяти внезапно да нету на самом деле тут совета вот состоял тут
отдельная песня можно ли тут забава хоть хоть какую-то стабильную сортировку завод единицы
дополнительной памяти но тут обычно советуют лучше по-другому лучше при равенстве максимальных
давайте сортировать по минимальным ну хорошо ладно видимо а это не вставки ладно даби а ладно
если да если если употреблять совсем точные слова то конечно имеется в виду сортировка выбора да да
извините мой косяк да мой косяк мой косяк до ставками да имеется в виду что дата сортировка
в котором и на каждом шаге думаем куда что сейчас поставить на очередной элемент прибираемся по
всем оставшимся выбираем минимум ставим до вставками конечно работать не будет да боже упаси
да неправ неправ неправ все так но вот сейчас нет сейчас погодить погодить погодить сейчас будет
интересно значит теперь давайте думать значит у нас образуются какие-то отсортированные блоки
где-то красные где-то синие ну правда мы уже не знаем кто из них красный а кто из них си
пошла мне где хранить откуда мы какие блоки взяли вот то есть единственное конечно мы там
догадываемся что если там несколько блоков идут подряд то наверное там они образуют какой-то
отсортированный все-таки массив то есть вот как так потом как-то так ну и так далее
ну какая-то такая бяка получилось вот теперь что же теперь делать
вот но очевидно это не привелось к тому что массив отсортировать то надо проверить не
ну можно завтра провяжаться и проверить не получился массив отсортированным если да то
радость да а еще заодно сразу тут проверить не был ли он отсортирован с самого начала да вот
но к сожалению могло так случиться что нет я чего вот но вот значит смотреть какая тут
теперь идея возникает но то что же нам теперь делать что же но то что что-то можно сделать но
идея на самом деле следующая начитая начитей у нас будет следующая то что идем теперь по массиву
дальше нас вот теперь единый массив такой какой-то дам и в конце какой-то буфер который мы сейчас
будем активно пользоваться на впервые в жизни и смотрите идем слева направо идем идем идем
ungen
идем идем идем trucks нет ну идем ну смысле он вот этому массиву я вот этот массив те превратил в
едины зеленый но сorcе он по бокам но мы идем точь пока у нас сраксирован но пока у нас это
тупо идем, идем, идем, но, возможно, через некоторое количество блоков неожиданно выяснилось, что он перестал быть отсортирован.
Вот, видно, да?
Вот.
То есть, вот такая вот неожиданность выяснилось.
Вот.
Но возникает такой, но возникает такой естественный вопрос.
Так, ну хорошо, допустим, если выяснилось, что они такие, то в принципе мы, пользуясь тем, что вот этот массив мелкий, можем их слить, правда?
Ну, то и значит, то и значит. Превращаем 20 ровных массивов в один.
Да, мы пользуемся этим буфером.
А что с ним не так?
И что?
Нет, ну во-первых, когда мы тут сортировали, мы его не пользовали никак.
Нет, во-вторых...
Нет, ну, смотря, что вы имеете под второй моментом.
Потому что когда мы будем сливать, естественно, мы будем иметь в виду, что про этот массив мы временно забудем, да?
И мы интуитивно будем считать, что у нас как будто эта вот штука на самом деле идет по памяти прям сразу за этой.
Ну, в смысле, а что там? У нас там в операторе квадрата не можем перегрузить оператор квадратной скобки, например.
Который там говорит, что если и меньше этой границы, значит элемент где-то здесь, если больше, значит где-то там все.
То есть как бы это простой технический хак.
Поэтому мы можем, смотрите, мы можем за линию от этих элементов не только их слить, но еще и поставить на это место.
Что еще? То есть мы можем слить первое место до с первыми местными звуками, но наш буфер тогда переместится в уголок?
Это долго.
Если это потом стали набирать жадно, и потом если не набралось, то повторили и так далее, то конечно это долго, да?
Мы, видимо, обратно все-таки не слились через это место по элементам.
Нет, почему не слились? Нет, там будет...
Нет, ну там, нет, просто как бы после того, как вы их сольете, буфер окажется в начале.
Ну нет, почему не весь? Вы же как бы когда сливаете, вы будете записывать их вот сюда.
Но более того, нет, я вам даже больше скажу, более того, вам придется на самом деле еще эти два элемента посвапать, помните?
Да, чтоб адекватно был.
На это, да, но на это плевать, там просто идея не в этом.
То есть мы это, то есть как-нибудь мы, то есть очень короче говоря, основная суть такая.
Как-нибудь эти два массива, используя вот этот буфер и не трогая вот это вот безобразие, могут быть слиты.
Это не два соседника, а соседний с префиксом.
Чего? Ну какой это префикс и идущий за ним блок?
Так, ребят, еще раз, я перешел на более высокий уровень абстракции только что.
Видимо, вы этого не заметили.
Я утверждение, вот этот абстрактированный массив с вот этим абстрактированным массивом мы можем слить.
А, используя вот этот буфер.
Б, не трогая вот это вот то, что между ними.
И более того, сделать это так, чтобы как бы этот буфер остался на месте, возможно, с пошафленными элементами, а абстрактированный массив оказался здесь.
Вот все, что я сказал.
Отдельная песня, там надо ли там свапать местами эти два массива, там что там надо делать и так далее.
То есть я как бы пока просто сказал, мы это можем сделать за о, отскокнутый элемент.
А все-таки надо еще раз почему сказать?
Ну, потому что мы только что, ну мы перед этим вот научились сливать два массива в предположении, что левый из них по размеру меньше буфера.
Вот здесь просто сделаем так, чтобы этот массив был меньше буфера, а дальше просто как бы начинаем интуитивно воспринимать вот этот кусок плюс этот кусок как единый кусок.
Чего?
Ну, например, можно послапать эти две части, это удобно будет.
Потому что когда вы будете записывать, вы как бы когда у вас закончится здесь, вы перескочите вот сюда телепортировать.
Ну да, ну да, ну циклический двиг внутри этого массива мы сделаем за от его длины.
Вот, так что это все, как бы да, в таких случаях да, это детали реализации, как бы негоже нам на нашем уровне о таких вещах вообще задумываться надо.
Вот, но мы будем, да, куда ждеваться.
Так, что там за шум пошел?
Вот, так вот.
Так вот.
Но вот это просто, на самом деле я, ну вот, ну конечно, если бы в тупую так будем делать, то конечно несколько таких операций будут работать долго, это да.
Потому что корень ИЗН операции, каждый из которых делается за линию, ну понятно, это Н корней ИЗН, это не то, что нам надо.
Да, уже за Н корней ИЗН мы наверное как-то более простыми методами могли бы слить.
Ну я не знаю, там надо, нет, знаете, как слить два массива за Н корней ИЗН?
Да очень, да очень просто, поделить массив на блоке, отсортировать их.
Да нет, все еще, ой, все еще, хотя нет, все еще тупее, как слить два массива за Н корней ИЗН, наплевать на то, что они отсортированы и запустить хипсорт, все.
На самом-то деле, в общем-то, да.
Не, потому что так-то можно было действить, это атак.
Ассортировка с помощью эскорт этих композиций.
Делим на блоки по корень ИЗН, ссортируем каждый, потом в блоки сливаем.
Да, самое смешное, что да.
Да, поэтому хипсорт это самая крутая ссортировка.
Такая ссортировка, да.
Такие нет, мы сейчас пытаемся страдать, доказав, что мерч-сорт, на самом деле, можно сделать без рекламы.
Ну да, нет, ну из этого будет следующий мерч-сорт, но ради этого мы вот тут такие страдания себе делаем.
Да, вот.
Так, но на самом деле я утверждаю, но на самом деле можно утверждать маленькую приятную вещь.
То есть фишка, на самом деле, следующая, что я утверждаю, что после того, как мы на самом деле это все отсортировали,
вот я хочу это утверждать, у меня вот до этого момента элементы, теперь после того, как они тут станут все отсортированы,
вот все, я утверждаю, что эти элементы можно не трогать, они стоят на правильных местах.
То есть вот такая вот неожиданная заява у меня.
То есть это будет означать, что мы как бы следующие операции будем делать уже начиная не отсюда, а отсюда.
Вот, то есть как бы видите, то есть.
Мы спрашиваем и начинаем с последнего блока.
Да, но то есть то, что там появилось, потому что понятно, что этот блок стал лучше, естественно, да.
Но как бы это да, тоже блок и как бы там дальше все идет, идет, идет.
То есть тогда я утверждаю, что это суммарно будет за линию.
Сейчас давайте думать, да, хороший вопрос.
Так, тихо, тихо, тихо, тихо.
Сейчас давайте смотреть.
Так вот, да, кто-то уже видимо понял, а вот я еще не понял, да.
То есть как всегда, смотрите.
И не все понятно, поэтому давайте, да, вот самый интересный момент.
Кто сказал, что вот эти элементы уже заведомо правильные, то есть что там.
То есть ну там, или вот по сути, например, что там, там, там, там.
Кто сказал, что вот эти элементы уже заведомо правильные, то есть что там.
То есть ну там, или вот по сути, например, что вот тут станет какой-то элемент.
Кто сказал, что все вот эти элементы больше его?
Как это, вот кто такую глупость сказал?
Ну вот, то картинка называется «А вот кто».
Смотрите.
Ну, по крайней мере, на самом первом шаге это достаточно очевидно,
потому что какой вывод можно сделать из того, что у вас тут жили-были два блока,
и они не дают себе сортировку?
По-видимому это означает, что они тупо из разных блоков.
Если вот прям вот этот элемент прям вот меньше этого,
то есть подозрение, что они тупо из разных блоков.
Вот.
Вот, то есть допустим красный и синий, хотя могло быть и наоборот.
Я не знаю.
Вот, но это не обязательно минимальный синий блок.
Нет, он не минимальный, он заканчивается на элемент больше, чем вот этот.
Сейчас, ну не, сейчас, погодите.
Ну вот, сейчас.
Сейчас, нет, ну там, ну сформулировать так.
Нет, чисто теоретически возможна ситуация, когда вот в этом вот сортированные последовательности
и там и красные и синие блоки были.
То есть тут как бы какой-то префикс красного и очень удачно вставился какие-нибудь синие.
Какой-то префикс синие.
Да, какого-то да.
Ну почему несколько начальных блоков синие очень удачно куда-то вставились.
Такое могло быть.
Вот, но факт остается факт.
Но теперь смотрите, какая ситуация.
Раз у нас тут красный блок, а тут синий, да,
то мы теперь можем гарантировать,
мы теперь можем гарантировать, что все последующие элементы, все последующие элементы, они больше либо этого, либо этого.
Понимаете, да?
Но потому что тут важный момент, когда вы вот эти синие блоки сортируете, их относительный порядок остается неизменным.
Точнее, существует только один.
Ну, пойте, мы там, правда, договаривались, что мы их сортируем по правому элементу при равных правых по левому, да?
Было дело?
Нет.
Это вы и сказали стейблсорт.
Я сказал, что не знаю, как делать стейблсорт с вот единицей дополнительной памяти лично.
Лично я вот это сказал.
Да, вот мы тут страдаем для того, чтобы стейблсорт за вот единицей дополнительной памяти был, да?
По максимальному элементу, а при равных по левому?
По минимальному.
Тогда я утверждаю, что в этом случае блоки могут переставиться только в одном случае.
Если совершенно случайно у вас идет два блока из абсолютно одинаковых элементов.
Вот тогда они могут случайно переставиться.
Чего?
Да.
Вот, но вот тут и оно.
Они одинаковые, поэтому нам в общем начхать.
То есть, ну, как сказать, конечно, кто-то, возможно, будет не в восторге от того, что у вас мелко переставил местами одинаковые элементы.
Но это будет из цикла а шо делать.
Вот.
Соответственно.
Чего-чего?
Ну, в таком виде, да.
Сам на себе нот.
Не, ну, всем на себя насылаться, ну, так относительно.
Вот.
Ну, там, значит, придется делать аккуратно.
Ну да, придется.
Да, придется.
Да, придется, тут ничего не поделаешь.
Ну, смотрите, я вот, утверждение.
Синя, относительный порядок синих блоков мог поменяться только,
только для каких-то двух идущих подряд блоков, в которых все элементы равны.
Почему?
Ну, потому что они у нас и правые элементы у них равны, и левые элементы у них равны.
Поэтому с точки зрения там того, как мы их сортировали, они равны.
Вот, я утверждаю, что других никаких случаев быть не может.
Первые сколько-то.
Ну, там, то есть, если мы как бы взяли вот тут как бы отсортированные вот эти вот T-блоков,
тут как бы у нас получается там это вот T-блоков, а это T-плюс первый.
Да.
Ну да, я утверждаю, что так.
Да, последние еще могут быть не на своих местах, но эти уже точно на своих.
Ну, минимальное T из этих блоков.
Нет.
Сейчас, погоди, давай не перескакивать, мы тут начали немножко другой момент обсуждать,
поэтому не надо так скакать сразу.
Нет, мы пытаемся доказать, то есть, например, что мы делали?
Мы шли, шли, шли, допустим, искали и шли по блокам, пока они дают отсортированный массив.
Предположим, что мы нашли T от T-блоков, вначале образуют отсортированный массив.
А T-плюс первый нам малину портит.
Так вот, я говорю так, давайте сольем эти два отсортированных массива в один, используя буфер.
Я утверждаю, что после этого на первых вот этих вот T-блоках будут стоять реально те элементы,
которые в результате мержа должны стоять на этом месте.
То есть это уже правильный ответ.
Чего? Почему по три на Бубен?
Нет, дальше мы будем делать то же самое, просто начиная уже с T-плюс первого блока.
Но не обязательно, как повезет, если там следующий нам фейлит порядок, то два,
но если следующий дает адекватный порядок, значит набираем дальше.
Да, да, да.
Следующий за фейл. Мы его от следующего.
Мы это все сортируем?
А после этого говорим, что первые T-блоков, то есть то, что там образовывается,
мы больше не рассматриваем, потому что это типа уже правильные элементы.
То есть мы их больше трогать не будем.
Почему они на светах стоят?
Вот, это мы пытаемся доказать, но как бы мы прерываемся на то, чтобы понять, что происходит, видимо.
Нет, я его сформулировал ровно в тех же словах, что и сейчас.
Просто, видимо, это было 10 минут назад и, видимо, там параллельно было несколько мыслей.
Вот.
Значит, теперь возникает интеллектуальный вопрос.
А почему, собственно, вот эти T умножить на Бубен минимумов находятся среди вот этих первых элементов?
Ну, по сути, утверждение в этом, правда?
Это понятно, что я сказал, да?
Вот.
Почему это так?
А вот почему.
Ну, утверждение такое.
Ну, во-первых, смотрите, как вы сказали, вот эти блоки, да, красные, сиги, они,
ну, то есть вот эти два блока, они явно из разных массивов, разных цветов, прошли, правда?
Почему?
Вот именно для того, чтобы обоставить это утверждение, мы вообще не будем говорить о том,
что относительные порядки красных блоков и синих блоков на самом деле не поменяются.
Понимаете, да?
Понимаете, да.
Вот.
Ну, теперь думаем.
Но тогда из этого следует, что каждый следующий блок, он либо красный, либо синий, правда?
А это дает нам маленький приятный факт.
Это дает нам то, что, например, мы не можем кормить,
а мы можем, например, мы можем кормить,
факт. Это дает нам то, что все вот эти элементы заведомо больше либо равны
минимума из этого элемента и этого элемента. Понимаете, да? Вот. Ну вот новая
какая-то вопрос, что из этого следует? Ну ладно, но к чему равен минимум из
этого элемента и этого элемента? Да, он равен этому элементу, потому что мы
тупо по этой штуке сортировали. Вот. Так что я тут даже
некорректно нарисовал, скорее вот так, правильно. Но тогда замечаем следующее,
то есть мы поняли, что все вот эти элементы больше вот этого, правда? То есть все вот
эти элементы там получается заведомо больше этого. Вот. Но тогда сколько
элементов вообще может быть меньше этого? Все, кто до него. Ну все, кто до него, плюс
сколько-то еще здесь. То есть получается, получается два вертолида. Если бы
вообще бы глобально отсортировали этот массив, то получается, что а, этот элемент
останется где-то здесь. Ну он может оказаться здесь, может сдвинуться куда-то вправо. Ну вот.
И во-вторых, все элементы, меньше его, тоже находятся в этом массиве. Ну вы вот очень про,
ну вот. Но тогда, так как элемент, меньших или равных элементов, чем он у нас, не менее,
чем Т на Бубен, то отсюда мы и делаем вывод, что после слияния от сортировки даже не всего
массива, а вот только этих частей, первые Т на Бубен элементов встанут на свои места.
Понятно? Мы говорим, что все элементы справа, они больше равны минимуму. Да, но минимум.
Нет, блоки мы сортировали ровно по максимуму в блоках. При равных максимумах по минимуму.
Нет, этот максимум заведомо больше этого, ну или равен. Минимум из этих вот максимумов.
Вот. Ну вот. Так что получается, первый шаг, ну первый шаг, корректно сделали,
и эти элементы встали на место. Чем отличается второй шаг от первого? Он отличается тем,
что да, у нас тут идут как бы все еще какие-то красные, тут идут какие-то красные блоки,
там где-то красные, где-то синие. Что? Вот. То есть где-то красные, где-то какие-то синие идут,
там не знаю. Но, а в самом начале идет какой-то странный блок. Потому что он как бы вроде синий,
но вроде не совсем. Но на самом деле у этого элемента интересно следующее, что вот этот
элемент никуда не делся, он как был максимум, он на этом месте после слияния остался, правда?
Но единственная только проблема, что после слияния, конечно, стрелочка за ним могла,
конечно, немножко улучшиться. Понимаете, да? Но на самом деле суть доказательства-то от
это не поменяется. Потому что давайте этот блок, если этот максимум был синим,
то давайте без особого ограничения считать этот блок, продолжать считать этот блок синим.
Потому что утверждение-то останется, что дальнейшие синие блоки все равно дают какой-то отсортированный
массив, правда? Поэтому дальше все равно будет верное утверждение, что в тот момент,
когда у вас сортировка нарушится, значит вы наткнетесь на два соседних блока разного цвета.
И тогда абсолютно тем же образом будет работать доказательство, что просто дальше дошли до
какого-то блока, вот тут fail, значит вот эти сливаем. Ну вот потом начинает сюда идем, сливаем и так далее.
Справа лежит все, что больше это, а здесь как повезет, здесь вот в этой зоне лежит все,
что меньше либо равно этой штуке, а здесь лежат как те, кто меньше его, так и те, кто больше. То есть
такая серая пожаром зона. Да, это дом мержа. После мержа получилось, что, ну вот, ну пост, чего?
У нас есть красный и синий блок. Красный же, что все шлет после синего блока. Если этот блок и синий, то они идут после него в изначальном синим массиве, да?
Ну да, и что? Получается, все элементы справа, они будут больше либо равны, чем элементы из синиего блока,
которые будут из синиего цвета. А для красного такое же утверждение. Получается, что у нас, можно сказать, более сильное утверждение, что у нас массив с т и еще синим блоком тоже ассортирован, корректно.
Чего? Нет, справа здесь могут быть элементы, которые меньше вот конкретно этого элемента.
Из синих нет, а из красных, да. Из красных, да. Так что вот получается, и слили. Важный момент, что когда вы фиксируете т-блоков, вы работаете, конечно, на будущее с т плюс одним блоком.
Но с другой стороны, заметим, что так как элементов здесь всегда не меньше, чем в этом следующем блоке, то получается, что, можно сказать, что вы это делаете за о, там каждое такое переходы вы делаете за о от t умножить на boobie.
Поэтому суммарно получается, что это работает за линию.
Мы начинаем с нового блока и делаем такой же процесс.
Да, то есть, находим отсортированный, ищем отсортированный префикс, смотрим, где фейлится, слияем.
Почему эта линия, где она находится?
Ну, потому что, смотри, на каждом шаге ты, допустим, приписал к ответу сколько-то блоков, да.
Так вот, я утверждаю, что этот шаг ты сделал за о от количества элементов в нём блоков. Почему? Потому что работал с не более чем столько плюс boobie блоков. Всё. То есть, можно так доказывать.
Ну, например, так. А я бы просто оценил, что t умножить на boobie плюс boobie не происходит. 2t умножить на boobie ещё можно. Можно и так. Ну, в общем, как угодно мыслить, суть одна.
Да. Так что вот получается, что вот таким вот не очень хитрым образом мы уситрились всё-таки подсортировать что-то за линию. Давай.
Просто сортируем?
Ну, потому что в конце останется, что у вас есть отсортированный массив, и потом идут к максимуму в рандомном порядке.
Да, всё, что вам остается, это как-нибудь сортировать, но так как их там порядка коринг, то вы сортируете любым пузырьком.
И вот с блоков, с блоков, где у вас пересеклись?
Да, и вот эта мелочь. Но это надо сделать, да. То есть надо сначала с этой мелочью разобраться, но мелочь, как бы, во-первых, сортируется сама, а во-вторых, как мелочь, она сливается со всем остальным.
Ну, то есть ещё раз. То есть, если как бы этот алгоритм реализовывать, то с самого начала он выглядит так.
Во-первых, в самое начало вычисляем бубен. Вычисляем бубен, вычисляем к. Ну, к понятно, чему равно.
Оно равно там что-то типа бубен плюс там n% бубен, очевидно. Вот. Отлично.
Значит, мы находим к максимальных элементов и с помощью циклического сдвига запихиваем их в начало.
Тем самым сформировали буфер. Теперь, разби, теперь, значит, разби, значит, всё остальное разбили мысленно на блоке по бубен. Мы знаем, что это число делится на бубен.
При этом, значит, вот этот блок, прошедший через границу, мы также отправляем в начало массива.
То есть, там, то есть, тут типа какая-то мелочь. Тут, значит, дальше идут вот эти вот красные блоки.
И тут дальше идут какие-то вот синие блоки. И буфер.
Значит, дальше идёт следующее. С помощью вот этого буфера вы сливаете вот эти блоки. Вот как мы тут писали. То есть, мы вот этим вот шагиками.
Это привело в складу, что у вас вот есть тут какой-то массив, тут есть какой-то большой отсортированный и буфер.
Теперь. Далее что делать? Далее. Сортируем пузырёчком вот эту, вот эту. Ну, потому что это, ну, бубен сортируем пузырёчком, да?
Получается, что он у вас тут отсортировался. После этого вы с помощью буфера этот и этот массив сливаете.
Вот. В конце, значит, получается, у вас остаётся отсортированный массив и рандомно расположенные элементы, которые заведомо больше, чем всё тут.
Значит, всё, что вам остаётся, теперь пузырёчком досортировать буфер. Всё. То есть, вот так устроено уголит.
Красно-синей блоки по максимуму и приравных максимумах по минимуму. А это важно. Сортируем. Сортируем именно выбором.
Потому что нам нужно, чтобы они копировались, они корень из Н раз. Так что вот такая красота.
Примы.
Ну, в смысле примомет, у вас бы буфер закончился.
Ну, вот. То есть здесь это сделается нормально, потому что этот блок меньше буфера.
Но если вы каждый блок сливаете с сортированным предыдущим, то это НКРГИЗН будет.
Ну, как бы нет. То есть нам заморачиваться о том, что надо что-то отсекать, нужно для того, чтобы была 7 точек. Да.
А зачем он там делает эффективное действие?
Дыны губин проходящие так, мы можем их просто взять и отрезать.
И просто два дополнительных блока, дыны губины, ничего страшного.
Может никак не используешь они одинаково или нет?
Сейчас.
Так. А, вот эти-то?
Да, да.
Ну, как сказать, ладно. Нет, ну, в основном мы используем, например, неявно для асимптотики, для того, чтобы у нас тут не было того, что мы тут рассмотрели три мелких блока и один неожиданно большой.
Да, но это, то есть это даст какую-то константу.
Нет, ну там предлагали, что как бы это рассмотреть как два отдельных блока и как бы не париться.
Вот примерно так. Ну, в принципе, можно, да.
Но это уже как бы такая.
Ну, точнее так, это уже на вкусу светломастера разные это называется, да.
Ну, можно, то есть, ну, как сказать, можно так, можно эдак, в общем.
Как говорится, но основная технология фокуса остается такая же, да.
То есть как?
Нет, почему нет? Ну-ка, ну.
Ну.
Да нет, ну, как сказать, нет, если вы скажете, что Бубен есть, просто какой-то блок в конце будет, не будет, будет длины меньше Бубен, но не глобально.
Один раз, как бы это ни страшно.
Вот.
Вот это вот? Какое? Какое? Вот это или?
Вот это?
Смотрите, утверждение такое, на каждом шаге, потому что на каждом шаге вы нашли L, значит, как-то дошли тут L элементов, да.
Дальше идет блок размера L' меньше либо равно L, да.
Вы их сливаете за, сливаете, Вадим, по сути, за OatL, правда?
Ну ладно, за L плюс L', но это OatL, да.
И после этого говорите, что вы, значит, L' первых элементов, они уже точно правильные.
Все.
То есть получается, каждый шаг, он как работает за OatL' и находит L ответ, так что суммарно ли? Да.
Нет, ну понятно, что там скорее 2N и так далее, но как бы.
Ну вот, ну да.
Так, еще вопросы?
То есть мы каждый раз вот двигаем, критически этот блок налево, с очередной?
Ну, например, да. Можно и сдвинуть.
А если сдвигать только?
Что? Ну, ну я не знаю, вот, ну следовательно сложно сказать, ну ладно, из того, что мы имеем, да, придется сдвинуть.
Наверное, можно с другой стороны, и его пересмотреть.
Или, например, социировать не по правым концам, а по левым.
Ну всякое.
Ну парь.
Ну, я думаю, что это будет очень удобно.
Ну, я думаю, что это будет очень удобно.
Ну, я думаю, что это будет очень удобно.
Ну, но если честно, не без этого, да.
У меня.
Скажем так, что было, я как бы помню какие-то вот общие идеи, из которых, собственно, выдаю алгоритм.
Как бы я не гарантирую, что оригинальный алгоритм был вот ровно такой.
Почти, наверное, он не такой, да.
Но, по крайней мере, константы Бубен то точно не было, естественно, да.
Вот.
Но в оригинале, кстати, в оригинале вполне вероятно, что Буфер стоял в начале, да.
Чего?
Бубен?
Тембурин.
По-моему, я вот когда-то гуглил вопрос на Тембурин, да.
Ну да.
Вот.
Ну, я не знаю.
Ну, как сказать, понятно.
Может быть, ну может там будет, конечно, константа Блок, конечно, еще, да.
Так что вот.
Так.
То что?
Ладно.
Так.
Есть ли еще какие-то тут вопросы?
Потому что дальше как бы мы будем заниматься чем-то уже совершенно с этим несвязанным.
В смысле?
Циклическим сдвигом.
Чего?
Нет, ну в смысле нет.
Понятно, что если вот в такой интерпретации вы будете тут как-то сливать и в результате окажется, что у вас отсортированный массив будет как-то вот здесь и еще немного здесь и в начале Буфер.
Так что поэтому вам придется внутри этого еще сделать циклический сдвиг, чтобы Буфер оказался здесь.
Ну, с формулиров так.
Если вам придется это писать, то, конечно, желать как-то подумать о том, чтобы циклических сдвигов было как можно меньше.
Да, тут явно есть поле для там придумывания.
Откровенно.
Да, да, да.
Ну, а там фокус, да.
А во всем остальном как-то говорят, да, что дальше уже вы сами будете думать, там это прицеплять ли, то есть сделать ли ваши кинжалы горящими там или там.
Или там шарики какие-то лопать и так далее.
Но кидать их в мишень с помощницей, вы будете все равно одним и тем же идейным способом.
Так что последнее, что нам хочется о сортировках сказать.
Вот прям самое последнее.
Ну, то есть надо об этом помнить, что есть такая штука, как внешняя сортировка.
Ну, что это такое?
Ну, потому что редко, конечно, в олимпиадной жизни такое бывает.
Может быть, практически никогда.
Ну, отновлено.
Да, редко, конечно, в олимпиадной жизни такое бывает.
Может быть, практически никогда.
Но в реальной жизни часто бывает, что данные, которые вы хотите отсортировать, в оперативную память не влезают.
То есть в переводе к ВР, вы их не можете хранить так, чтобы прям вот получить за от единицы доступ к ним.
То есть, ну, например, в первом приближении у вас будет такое внешнее хранилище информации, там жесткий диск.
То есть, допустим, куда-то надо лазить.
Но проблема в том, что данные, конечно, придется подгружать каким-то образом частями.
И вот такой, ну, потому что в худшем случае бывает, что там, видимо, это там вместо жесткого диска вам эти данные и два линии по интернету там как-то придется перегонять.
Ну, не по интернету, или по какой-то локальной сети, потому что у вас там, допустим, какой-нибудь кластер на самом деле есть, и там данные распределенным образом на каких-то процессорах хранятся.
Вот, ну, мы начнем с жесткого диска, потому чтобы не вводить себе еще там какую-то потенциальную возможность параллельности.
Так, ну, кстати, о жестком диске.
Да, в принципе, в принципе, можно сказать, что доступ к любой ячейке памяти в жестком диске тоже делается за вот единиц.
Но в данном случае оказывается сильно принципиально, что от единицы к жесткому диску очень-очень-очень сильно жирные.
Сейчас жестких дисков нет почти.
Ну, как сказать, жестких дисков может и нет.
Но тем не менее память о них осталась.
Тем более вместо жесткого диска чаще всего вы можете воображать какие-нибудь процессоры.
И для них тоже будет верно такое важное утверждение, что произвольный доступ к одной ячейке, конечно, будет долгий, но при этом если вы хотите взять не одну ячейку, а там сколько-то прям мегабайт сразу вместе с ней, лежащих рядом,
то это вы делаете за буквально такое же время.
То есть вообразить себе такое вполне возможно.
Вот.
Получается последовательный доступ действует хорошо, но желательно, чтобы по памяти не скакать.
Вот. Ну и там, конечно, количество пластин на самом диске обычных там несколько. Ну там 6-12 по-разному.
Вот.
Ну, в принципе, в реальной жизни тоже, на самом деле, на реальной практике вам тоже часто придется, когда вы думаете об эффективности алгоритма, учитывать, что не только то, что он там работает за n log n или n квадрат,
а сколько конкретно раз вы лазите куда-нибудь в рандомную память или там делаете запросы в базу данных.
Потому что на самом деле, потому что, например, у моего брата, скажем, на реальной практике оказались действительно проблемы, что там можно делать алгоритм за o от n и делать там, допустим, n обращений к какой-нибудь базе данных.
Но это работает сильно хуже, чем если вы работаете едва ли даже не за n log n алгоритм или квадратный, но при этом делаете всего 5 обращений к базе данных.
То есть это может оказаться до жути критично об этом.
Если вот вопрос, чем реальная жизнь отличается от олимпиад, вот в том числе такие вот еще спецэффекты бывают.
Вот.
То есть вот самое разное. Поэтому вот там какой-нибудь Петр Митычев так и говорил, что как бы ну в реальной жизни там другие алгоритмы, понимаете, там они, ну не в смысле они там сложнее или легче, они просто вот другие они.
Вот вообще другие.
Так что будьте готовы.
Вот.
Итак, как же предлагается сортировать?
Ну, допустим, у нас будем делить на блоке по 100 мб данных.
Ну, почему по 100 мб? Ну, допустим, у нас там оператива там 200-300 где-то.
Вот.
Значит, что мы делаем?
Вот допустим, у нас оказалось, допустим этот массив данных, в массиве данных у нас оказалось не сильно много блоков.
Ну, например, k.
Тогда, значит, что получается?
Сортируем каждый блок по отдельности.
Говоря, ну вот.
Ну, как мы это делаем? Ну, просто загружаем, сортируем, сохраняем обратно.
То есть получается вот тогда что-то типа с той самой корневухи, то есть там делим на блоке, каждый блок сортируем, а потом сейчас мы эти блоки будем как-то сливать.
Вот.
Но как мы их будем сливать?
Ну, в самом деле, если k не сильно большое, то можно сливать k путевым слиянием.
Ну, то есть, ну, как бы вы когда-нибудь примерили метод k указателей?
Ну, это как метод двух указателей, только указателей k.
Ну, ну вот.
Ну, то есть, например, как слить k массивов? Очень просто.
Вы храните k указателей, все элементы храните, например, в сете.
Вот. Или в хипе даже лучше.
Ну, хип просто быстрее по константе работает, хоть, конечно, даст и логарифом тоже.
Вот.
Но правда, конечно, маленькая оговорочка здесь будет важная, что когда вы сливаете k путевым слиянием, может показаться, что вы как бы по одному, то есть вы там с диска достаёте пока элементов.
То есть по одному элементу.
Но, конечно же, это не так.
Но, конечно же, это не так.
То есть в реальности выгодно, действительно, раз вы себе уже разрешили хранить в оперативной памяти 100 мегабайт данных, то, наверное, логично хранить не k элементов, а чтоб хранилось 100 мегабайт, которые поделены еще на k частей.
Логично, да?
То есть просто, то есть на этот раз из каждого там этого сортированного под массива на 100 мегабайт мы достаем там по 100 мегабайт поделить на k.
И вот сливаете, когда у вас один массив заканчивается, вот тогда вы его, собственно, и там подгружаете.
Понимаете, да?
Ну, когда вот, ну да.
Ну, по сути, когда то, что вы закачали, закончилось, значит тогда вы, значит, там достаёте следующее.
Ну и, попутно, теоретически можно в этом месте, на самом деле, из ответа там первые сколько-то элементов тоже отправить в ответ.
Ну а можно не отправлять. Вот давайте внимательно смотреть.
То есть что у нас получится?
Вот, особенно если k не сильно большое.
То есть смотрим, да? То есть у нас есть k квадрат частей.
Значит, загружено не более k частей объемов, соответственно, 100 мегабайт поделить на k.
Ну и получается все эти части там в оперативную память лезут.
Ну, собственно, мы так специально и подгоняли, в общем-то, да, и получается, то есть получается вот такая радость.
Вот, а вот теперь давайте думать, сколько действий мы в итоге сделали?
А главное, каких нам это принципиально?
Тихо нам это принципиально.
Ну, во-первых, просто действие в ОЗУ.
Так, ну-ка, кто может в течение пяти секунд догадаться, как расшифровывается аббревиатура ОЗУ?
Ну да, ну да, или оперативная, да.
Ну, скорее операционная, да, оперативное запоминающее устройство, да.
Да, звучит, конечно, немножко совково, но тем не менее, да.
Вот, но с другой стороны, это все до сих пор там есть.
Да, так вот, ну действительно, в самой оперативной памяти, когда мы сортируем именно блоки, то что у нас получается?
n лог m, где m это у нас что?
Да, ну m это вот объем одного блока, да.
Потому что каждый блок размера m мы сортируем за m лог m и всего блоков n поделить на m.
Да, да, поэтому получается n лог m.
Вот, но при этом доступ к жесткому, значит, у нас, давайте смотрим.
Сколько раз мы в рандомное место диска лезем?
Ну, в рандомное место диска получается мы лезем 2k раз, ну, где k типа на считывании и k на записи, да.
Вот, ну и соответственно последовать и как бы элементов, которые мы как бы считали последовательно, получилось, ну, там типа 2n тоже там, n считали, n записали.
Вот, то есть этим обычно вот стоит следить.
То есть, видите, это хорошо, что как бы, видите, основная суть, что весь вот этот лишний логарифм, да, то есть мы все-таки пытаемся делать у себя как-то в оперативной памяти.
Ну, пока это был, конечно, несложный, там несложный этап, потому что мы там каждый блок независимо сактируем.
А теперь, а теперь получается следующее.
Вот, теперь значит раунд второй, k путевое слияние.
Так, ну понятно, что в оперативной памяти мы, естественно, это делаем n лог k, да, ну в сумме получается как ас n лог n, забирай вперед, да.
То есть как бы тут получается, тут получается m, тут равно k, которое равно как ас n поделить на m, так что получается n лог n, то есть все нормально.
Ну, собственно, меньше и не могло быть.
Вот, значит тут получается n лог k, но обратите внимание, на этот раз оказывается, что произвольных доступов к памяти уже как квадрат получается.
Ну, помните, да, мы каждый, каждый из калблоков поделили еще на k частей.
То есть как бы считывание и запись как бы подряд идут все, все то же самое, но вот, к сожалению, считывание у нас вот как квадрат пока еще многовато.
Ну, на самом деле зависит от k, зависит от k, потому что если там k равно 2, 3, 5, 10, то может это еще не так страшно.
Вот, но на самом деле вот если k, например, 500, то на самом деле может, то есть могут тут иметь место и более какие-то продвинутые технологии.
Ну, например, то есть как бы, то есть может оказаться, что имеет смысл действительно делать, то есть делать не двух вот это уровневое слияние, а как бы, то есть как бы,
то есть может оказаться, что имеет смысл действительно делать, то есть делать не двух вот это уровневое слияние, а сказать, что давайте мы сначала, ну, понятно, первая фаза без вариантов.
Мы примерно там каждый из 500 блоков мы локально отсектируем, да.
Дальше будет идти такая, давайте теперь разделим эти 500 на группки по 20, да, на группки по 20, и каждый из них там, там 20 путевым слиянием отсектируем, да.
То есть для этого нам потребуется доступов, получается, что-то типа 20 в квадрате умножить на 25, потому что у нас всего как бы 25 таких как бы метаблоков.
Понимаете, да?
Вот. Ну вот, ну и в конце вам придется еще, конечно, сделать 25 путевое какое-то слияние.
Вот.
Но там рандомных доступов получается сколько?
Ну не совсем, там, там, смотрите, там 25 массивов, на каждом из них, то есть на каждом из них как бы получается делить надо не только на 25, но еще на 20, потому что чтобы 100 между 100 мегабайт влилось.
Поэтому тут получается все-таки 25 в квадрате на 20.
Но суммарно, обратите внимание, это прям, это оказывается там раз в 10 меньше, чем 500 в квадрате.
И это может оказаться критично.
То есть настолько критично, что как бы это компенсирует тот факт, что последовательных считываний и записей получится уже не 2, а на 3.
Вот.
Но это будет все равно, то есть гораздо быстрее, то есть вот в первую очередь тут имеет смысл оптимизировать такую штуку.
Вот.
Так что вот тут, то есть на самом деле сильно глубже мы тут копать не будем, но как бы, что это момент есть и в ней есть такие спецэффекты, я должен был упомянуть.
Так, ну что, есть ли тут какие-то вопросы?
Ну, мне она неизвестна.
Не, ну то есть известно, что как бы быстрее, чем ZN-Login вы не ассектируете так или иначе.
Ну вот, ну сколько там вот удастся вам так вот.
Ну, короче, последовательный доступ, да.
Ну а нет, ну Омега, да, но, понимаете, тут как раз тот случай, когда константа имеет значение.
Ну потому что одно дело, когда вам как бы не сильно принципиально, ну то есть вы в этом олимпиадном программе, это вам не принципиально программа работает 0,5 секунд или 0,7 секунд, да.
А в реальном каком-нибудь жизни может быть принципиально вам программа работает 5 часов или 7 часов или 10 часов.
То есть ну реально принципиально, правда.
Поэтому тут приходится думать.
Вот.
Там соответственно.
Соответственно.
Вот.
Так, еще какие-то вопросы?
Нет, ну если там.
Нет, ну теоретически, наверное, ну там можно.
Другой вопрос, как бы насколько это будет эффективно, это уже надо отдельно считать.
Нет, ну как всегда, как всегда, программируй и сделай, мы можем все, что позволяет нам язык C++, в принципе.
Так что вопрос, как бы насколько это эффективно.
Так, ну что?
Еще вопросы?
А, что?
Нету?
Все?
Так, ну ладно.
Так, ладно, давайте на всякий случай пробежимся, чтобы убедиться, что я ничего не забыл.
Хотя практически все мы здесь уже обсудили.
Прямоугольник.
Но смотрите.
Здесь просто упоминается, что если говорить о структуре данных, они бывают статические.
То есть когда вы там зафиксировали уже там какую-то область памяти и все.
И эта область памяти не меняется.
То есть там какой-нибудь там прямоугольник там или какая-нибудь пара.
Ну по модулю того является ли это статическими, конечно.
Или там какой-нибудь статический массив, который вот раз он навсегда объявился и он не меняется.
По размеру.
А вот какой-нибудь вектор, например, меняется.
Потому что он сейчас может, сегодня он может занимать столько памяти, а завтра уже чуть побольше.
Ну вот, то есть он там пресайзится может.
Вот.
Ну и соответственно практически весь СТЛ в общем-то к этому типу принадлежит.
То есть там сет, мап, там стеки, там стеки, деки, очереди и прочее.
Там приоритетная радость.
Ну к которой мы в общем-то и переходим.
Так, ну, так, ну и здесь бла-бла-бла, это может все было.
Это мы обсуждали, обсуждали, обсуждали, обсуждали, обсуждали, обсуждали, в общем-то.
А, тут больше ничего нет.
Ладно, все.
Все, значит убедились, что я ничего не забыл.
Ладно, тогда, ладно, я вас тогда попрошу видимо включить свет.
Потому что отсюда мы выключаемся.
Вот.
И будем разговаривать уже.
Вы уверены?
Да.
Вот.
Вот.
Так что поэтому мы можем соответственно переходить к нашим любимым кучам.
Вот.
И будем соответственно думать.
Так.
Значит, ну давайте смотреть, что вообще можно с кучами делать.
Ну мы уже изучали действительно, что такое как минимум двоичная куча.
Вот.
То есть даже, даже первое рассмотрели, что ее можно вообще написать.
И она будет написана даже очень удобно.
Вот.
Ну вот, ну давайте вообще скажем.
А что такое куча вообще?
Как бы.
Ну-ка напомните, что такое куча?
Чего набор деревьев?
Чего-чего-чего?
Не-не-не.
Ну тут как бы.
Ну да.
Ну в первую очередь да.
Тут обычно, тут имеется куча с точки зрения интерфейса.
Ну давайте экстракт.
Ну допустим.
Прям максимум хотите?
Нет, давайте все-таки минимум.
Ну неважно, там минимум можно максимум.
Ну а также, конечно, вставить элемент.
А, ну еще.
Ладно.
Ну давайте как бы к экстракт-мину.
Обычно еще гет-пин поставляется, поэтому да.
Вот.
Ну чисто теоретически, да.
То есть основные операции такие.
Чисто теоретически можно.
Но обычно еще вставляют все-таки такие операции, как.
Просто RIS по итератору.
Вот я так красненьким напишу.
Ну что это означает?
Это означает, что предположим, что вы там.
Отправляете элемент, допустим, в кучу, да.
И вам возвращается итератор на него.
Что-то типа.
То есть гарантируется, что как бы куча не менялась,
итератор всегда будет указывать на этот элемент.
Это как бы вам нужно для того, чтобы вы могли по этому
итератору элемент удалить в любой момент до того,
как он станет минимален.
Вот, понимаете, да?
Вот.
Ну давайте еще смотреть.
Вот.
Значит.
Ну базовая куча такая.
И у нас, в общем-то, есть двойечная куча.
Наша обычная.
Которая все.
Так.
Будьте здоровы.
Так.
Вот.
И мы знаем, что все эти операции лада, кроме гетмина,
работают за логарифом.
Вот.
Это мы с вами знаем.
Вот.
Но, конечно, первое, что хочется упомянуть, это то,
что, а кто сказал, что куча обязана быть двоечной?
Ведь, в принципе, почему бы куча не быть краечной?
Вот почему бы кто сказал, что у кучи обязана быть двоечной?
Вот почему бы куча не быть краечной?
Вот почему бы кто сказал, что у каждой вершины должно быть два ребенка?
А давайте у нее будет ка детей?
Где ка?
Какой-то выбранный параметр.
Ну то.
Бывает троечная куча, там четверичная куча, там десятиричная куча.
Вы когда-нибудь писали десятиричную кучу?
Нет.
Одно дело звучит, другое дело писали ли?
То есть, как вы понимаете, слышали ли про Денту Линукса
и ставили ли вы Денту Линукса, это два разных вопроса.
Да.
Ну да.
Ну, опять отвечу.
Каечная куча, на самом деле, может быть реализована даже не сильно сложно.
Потому что можно ее тоже реализовать вполне себе в массиве,
без всяких указателей.
И тогда окажется, что, на самом деле,
если у вас есть вершина номер И, то у нее очень просто найти детей.
Как найти ее детей?
Ну, каи плюс один, каи плюс два и так далее, каи плюс ка.
Вот.
Ну а родитель будет, соответственно, и минус один делить на ка,
округленные, понятно, куда.
Вот.
Ну а, кстати, в двоичном случае это тоже прекрасно работает.
Если вы писали двоичную кучу в ноль индексации,
то, в общем-то, вы с этими формулами сталкивались.
Ну, один индексация, конечно, для двоичной кучи гораздо удобнее,
но вот в ноль индексации, если вам этот элемент прям жалко,
то как бы можно использовать.
Но давайте подумаем.
Вот в каечной куче, где ка – это как бы уже параметр,
который придется использовать в 8 точки.
Так, за какой этим точку в нем работает детмин?
Да, ну, естественно, вот единица тут неинтересна.
А за какое всем точку можно выполнить вставку?
Да, ну, это у нас подвешивание листа и сифтап.
Ну и сифтап, очевидно, здесь работает за логарифом по основанию ка.
В общем, чем больше ка получается, тем меньше эта штука, правда?
Но к огромному сожалению, с экстракт-мином да и эризом тоже это работает уже не так,
потому что экстракт-мин у нас на сколько работает?
Да.
К сожалению, тут приходится домножать на ка. Почему?
Потому что когда вы просеиваете вниз, то вам придется прибирать реально всех детей
и находить среди них минимум.
Понимаете, да?
Поэтому ка, лог, ка. Ну, там можно, конечно,
ну, можно пытаться задумываться на тему того,
а нельзя ли положить туда сет из детей,
чтобы минимум удобно доставать.
Но тогда это получится.
Ка заменится на лог ка, и тогда это все превратится в лог н.
Вот.
Так, ну и рейс, соответственно, нота.
Пока в тупом виде это тоже будет работать о от ка лог ка н.
Вот.
Вот.
Ну, в принципе, да.
Как бы самые тупые операции, конечно, такие,
но на самом деле в куче иногда бывают часто полезные немножко другие операции.
То есть еще какие-то.
Например, в первую очередь, конечно, нам не помешает операция декризки.
От итератора.
То есть это значит, мы тыкаемся в какой-то элемент, прям вот тыкаемся,
и хотим там то, что там находится, уменьшить до значения х.
Ну, как повезет.
Ну, скажем так, такая реализация возможна.
Но давайте подумаем.
Но давайте подумаем.
Но в двоичной куче более того принципиально лучше вы ничего и не придумаете.
Хотя понятно, что в реализации зачем вам выпиливать элементы из середины кучи,
если вместо этого просто вызвать севта можно один.
Конечно.
Да, у нас камешки.
Спасибо за замечание.
Ну вот.
Куда складывать?
Не-не-не.
Это означает, что я заменяю его значение на другое значение, которое меньше.
Вот.
Просто гарантируется, что х меньше того, что там по итератору хранилось.
Вот.
Так.
А в коичной куче за какое время вы можете сделать декризки?
Чего?
Да, то есть обратите внимание, да.
То есть если не выпиливать, то есть можно было бы выпилить и пихнуть,
но если сделать просто севтап, то это будет уже эффективнее.
А ведь на самом деле у нас есть замечательный уже, как минимум, алгоритм,
в котором это может оказаться критично.
Конечно же, я говорю об алгоритме dx.
Да.
Мы, конечно, не знаем, что такое равдам.
Как всегда.
А, на отборе было.
Ну, неважно.
Значит, смотрите.
Ну ладно, нам сейчас неважно даже, в чем заключается алгоритм dx.
Нам важно, что?
Что там есть?
Что там есть?
Там есть v-вершин.
То есть там у вас v-вершин e-рёбер.
И алгоритм устроен так, что вам, если dx с кучей писать, то что вам там нужно сделать?
Там вам нужно сделать, по сути, v инфектов.
Ну, хотя в других реализациях можно просто сразу на них кучу поставить.
Там v инфектов.
Что там еще делается?
Значит, v экстракт минов.
И обратите внимание, e декриз киев, по факту.
Да.
Ну, если вы никогда не кодили на паскали, вы могли об этом даже не задумываться,
потому что, скорее всего, de экстракт минов.
Вы могли об этом даже не задумываться, потому что, скорее всего, de экстракт с кучей или с этого
вы все равно делаете, по принципу, выпили элемент в сунь меньше.
Кто-то это делает из сета, кто-то делает это даже из дерева отрезков.
Мне говорили, что там, что называется, там знаменитый Елена Владимировна очень любит de экстракт с деревом отрезков.
Ну да.
Это красивый ход.
Ну, конечно, более оптимальный по константе, это, конечно, будет de экстракт с приоритетикой, конечно.
Правда, с приоритетикой будет проблема там в том, что вы не сможете сделать декризки,
вам придется просто добавлять элемент, просто меньше элемента,
а потом, когда достаете что-то из кучи, говорить, что так, это мы рассматриваем до свидания.
Чего?
Ну да, ну да.
А там не важно.
Там можно сделать юзды, а можно просто проверить, достаешь элемент.
Так, если то, что там в куче написано, не равно его актуальной величине, то до свидания.
Можно еще так.
А можно, а можно юзды, пожалуйста.
Вот.
Ну, а теперь давай, ну, а 7 точке это не меняет.
И теперь давайте думать.
Значит, вот такая штука.
Ну, работает она за, ну, получается, тогда получается с бинарным хип,
с бинарным хип даст нам de экстракт с кучей за буквально e лог в.
Чего?
Ну, v лог v плюс e лог v.
Хорошо.
Хорошо.
Вот.
Хорошо.
v плюс e на лог v.
Да, v правая.
А то e может оказаться и меньше v.
Действительно, да.
Вот было бы остовное дерево, мы бы на это забили.
А тут придется...
Было бы дерево, мы бы на e забили.
Ну да.
Нет, почему?
Нет, если бы искали остовное дерево, то как бы на e мы не могли забить все сверху.
Но понимали бы, что e не меньше, чем v-1.
Поэтому будут у нас остовные деревья.
Будет кайф.
Да.
Но это называется, когда у нас еще будут.
Скорее всего, в следующем семестре.
Вот.
Значит, это было v плюс e на лог v.
А теперь давайте смотреть.
А в коичной куче что будет?
А тут будет vk плюс e на лог kv.
И теперь возникает, на самом деле, интеллектуальный математический вопрос.
А при каком k это поменьше?
Вот тут уже, да, знаете, как бы на практике можно реально начать думать.
На самом деле, если вам подсунули v и e, то как бы в эту формулу можно подставлять k и, соответственно, искать, где ми ему.
Правда, это будет не очень точно.
Потому что, на самом деле, там конкретная k может еще от константы зависеть.
Ну, потому что в реальности надо помнить, да, что в реальности у вас это будет работать за c1vk лог kv плюс c2e лог kv.
Вот так.
Если у вас есть примерные оценки, ну, правда есть, да.
Но, правда, я боюсь, это уже отдельная практическая работа, конечно, посмотреть, какие у вас там реально константы.
Но пока давайте попробуем понять математически хотя бы.
Как найти оптимальное, то есть как тут найти действительно оптимальное k?
Но можем.
Так, ну, давайте смотреть, да.
Да, давайте. У нас есть классический метод, действительно.
Так, vk.
Ну, давайте так.
Одна возрастающая функция у нас это vk лог v поделить на лог k, на самом деле.
Ну, что такое лог kv? Это лог v делить на лог k, правда?
И ее мы складываем с e лог v, там, делить на лог k.
Так.
Ну, скажем так, вот эта функция откровенно убывает с ростом k.
А эта, ну, начинает с какого-то момента возрастать.
Ну, потому что k все-таки перевешивает лог k.
Ну, можно там посчитать производно, обнаружить, что там, по-моему, минимум где-то между 2 и 3.
Там, по-моему, 2 линии в ешечке.
Ну, если это линум, конечно.
Вот.
Вот.
Значит, лог k лог k, лог v лог v.
Тогда получается, чтобы это было примерно одинаково, получается, что оптимально должно быть k e поделить на v.
Чего?
Ну, мы сказали, ну, смотрите, значит, стандартная логика поиска оптимума.
Вы складываете две функции.
Одна из них возрастает, другая убывает.
Чтобы, ну, сумма это асимпатически то же самое, что максимум, правда?
Значит, надо сделать так, чтобы максимум был как можно меньше.
А это достигается примерно в той точке, где они примерно равны.
Поэтому мы тут их примерно уравняли и начали шлёп-шлёпать.
То есть получается, где-то k должно быть примерно e поделить на v.
Если мы это подставляем, то асимпатику у нас получается e логарифом по основанию e делить на v.
Нет, если кто-то когда-нибудь копался в каких-нибудь асимптотиках более продвинутых, чем на Олимпиадах используется алгоритмов,
то логарифом по основанию e делить на v новостью для вас быть не должен.
То есть где-то такое встречается.
Ну, в принципе, это одна из идей, откуда это вообще может влияться.
То есть более страшно, если в эту степень возводят двойку, что-нибудь возводят на самом деле.
В общем, там всякое бывает.
Но в принципе получается, что такой вот алгоритм есть.
То есть, конечно, если e поделить на v меньше двойки, то алгоритм, конечно, имеет относительную пользу, конечно.
Но, скажем, на самом деле, чем больше ребер, тем это, то хорошо.
Тут ещё момент такой, потому что мало кто знает, но есть алгоритм Dijkstra без кучи.
Нет, просто самое страшное, я иногда удивляюсь, что оказывается, что некоторые люди даже не знают,
что Dijkstra можно без кучи писать и без сета.
Потому что на самом деле там сам по себе алгоритм Dijkstra говорит,
что мы на каждом шаге находим вершину с минимальным D, фиксируем её и делаем релаксацию.
То есть, в принципе, тупая реализация говорит, давайте так и сделаем,
то вообще получится, вот если без кучи, это вообще получится за v квадрат плюс e.
И более того, заметим, что выясняется, что вот эта асимпатика может так жестко проиграть вот этой.
Потому что если e порядка v квадрат, то тут будет квадрат, тут квадрат лог v проблема.
А вот здесь на самом деле этот случай оказывается обработан.
E равно v квадрат, но как бы e поделить на v получается v, и получается это единица.
У нас получается то, что у нас v-ичная куча.
Да, ну на самом деле да. Что такое v-ичная куча?
В v-ичной куче, в которой находится не более чем v элементов,
но да, это по сути не сильно отвечает всем, что вы просто храните в чёрном ящике все элементы,
а когда просят минимум, вы честно его находите.
Да, то есть по большому счёту да.
То есть что такое массив?
Массив, наверное, элементов это такая n-ичная куча.
Ну да, но не совсем, ладно.
Нет, ладно, что такое n-ичная куча?
Это такой, смотрите, это такой абсолютно обычный массив,
просто мы минимум всегда в явном виде храним в нулевом элементе.
И всё, остальные как угодно.
Да, да, да, ну вот, то есть вот оказывается да.
Ну как минимум, каечную кучу вот так вставить можно, она может оказаться полезной.
Вот это как минимум первая идея, которую тут хочется рассмотреть.
Правда ли, что краскал сводится к приму примерно такой же манипуляции?
Краскал сводится к приму?
А краскал ты давно S&M используешь, как ты S&M берёшь?
Нет, нет, обратная функция Акермана в S&M немножко из других соображений берётся очень сильно.
Если вы про это, а так прим и краскал это вообще два разных алгоритма.
Ну то есть прим-прим это вот это вот, да, но краскал это что-то принципиально другое.
Но краскал это когда вы сортируете ребра и добавляете их там.
То есть как бы прим это один расширяющийся кусок.
Краскал это много кусочков, которые объединяются.
Поэтому да.
А борувка это...
Ну да, нет, ну логично так.
В Югославии.
Ну да.
Ну да, 20-е годы человеку надо было соединить в электрическую сеть в всю Югославию.
Или что там было.
Ну вот.
Ну вот он придумал это.
Да, в чём парадокс в том, что да, конкретно компьютеров ещё не было, алгоритм уже был.
Ну по чём формально отметим, что да, там вот...
Он хорошо параллелизируется, параллелизируется хорошо.
Ну и в теоретических алгоритмах, как мы увидим на самом деле там, собственно, шаг борувки, это будет просто очень важная вещь.
Примерно как вот, просто как куча фибоначи.
Да.
Ну ладно, до борувки мы ещё доживём.
До кучи фибоначи тоже доживём, но в следующий раз будет.
Чего коллективно?
Господи.
Осуждать кучу фибоначи?
Господи.
Нет, ну да.
Проблема то, что Никифор как бы непонятно, что сказал, поэтому как бы тут...
Как бы, поэтому осудить можно максимум, как бы, уровень понятности сказанного, но не то, что он сказал, да.
Ну да.
Ну как сказать.
Ну я не знаю, можно ещё и этот подход, кстати, сам по себе осудить, да.
А потом осудить осуждение какого-либо подхода, ну в общем.
Но с другой стороны, знаете, как в таких случаях бывает, как-то есть КВН, есть обзор, ну пока я стираю.
Ну вот есть КВН, есть обзор на КВН, в чём их там несколько, несколько есть даже математический обзор.
Ну были когда, там люди когда-то реально выпускали обзоры, в которых прям статистически обсчитывали выступления.
Там у них основной параметр это там, то есть они там вычитали коэффициент Гуликова, там уделенный коэффициент Гуликова и самый важный параметр это прям если взяли главный относительный коэффициент Гуликова.
Нет, то есть там, то есть эпично считается, ладно, я скажу, просто эпично, потому что там, там что-то, типа, уделяйте коэффициент Гуликова,
то есть по сути это как бы количество ваших зашедших шуток поделить на количество вообще шуток, которые у вас были.
Ну то есть доля зашедших шуток короче. А относительный коэффициент Гуликова, когда это вы домножаете на время,
то считается, что это сколько смешного времени у вас выступлений было по сути.
вот и они так но они вот это вычисляли там что-то еще там считали разные самые
вещи классные обзоры были но к сожалению они очень тяжело делались
но вот ну поэтому сейчас их к сожалению нету вот так вот я собственно к чему то
есть рекурсия возникла тому что после того как стало этих обзоров уже настояло
наслоилось настолько много что какой-то минут появился обзор на обзоры но там
просто один кв еще сел и так сделал обзор на там все имеющиеся обзоры
самая популярная но вот но этот он походу просто не понял поэтому там да вот но
потом даже возникла мысль они пойти ли дальше но вы и делать то как один обзор
сказали как из обзорщиков сказал так обзор на обзор обзоров на квн
ой да ну нафиг я лучше посплю пойду господи маразм уже какой-то вот на этом
рекурсия закончилась вот нет ну как сказать чаще всего так и происходит да
не ну можно там теоретически там можно показать теоретически что если сделать
рекурсию там насколько угодно глубокое то получится там какая-нибудь радость
да алгоритм там за n в степени 1 плюс и эпсилон тот же самый да да да да да вот
ладно значит ладно тем временем я уже все стер вот значит чем мы еще будем
хотите от куч на самом деле у нас появится просто помимо вот этих ну скажем так эти
операции еще будут относительно собственно относительно нужные то
есть еще ну то есть ладно чуть-чуть все появится но самое главное которое вот
для нас прям будет принципиально это знаменитая операция мэлт или что то же самое мерч
то есть суть будет такая то есть нам то есть куча дается по ссылке другая куча и надо их
объединить но чтобы как бы из двух куч появилась одна и вот с этими кучами возникает проблема потому
что за какое время мы можем слить две кучи размера не более чем n да за отн причем этот
алгоритм идентичен то есть алгоритма по сути возьми все элементы построю кучу заново нет если
бы тупо вставляли элементы то был бы н логен но как бы мы умеем просто их выписать массив и
сделать вот так слушайте не ставка личной кучи интересно это как да было было было да сев даунами
снизу и вверх да так ну что ну конечно куча ну ладно поверим наверно что тем же самым
тоже все за линию строится вот но наверное это нас не устраивает раз уж возникла идея слияния то
наверное хочется сливать побыстрее правда но сколько можно сливать ну хочется за логари
мечта мечта но мы начнем с базы сейчас вы сейчас я начну просто буквально с базы потому что на
той куче который сейчас расскажу конечно там много чего действительно базируется я конечно
говорю о биномеральной куче и так да биномеральная куча да с биномом она как-то связана да ну да
по идее она так и называется байно мел хип байно мел хип значит смотрите это будет первая для нас
куча в которой количество детей у вершины может различаться чем различаться не в смысле что там
вот есть какой-то там последний элемент у которого там листов не хватает а прям принципиально но
правда у каждой вершины хотя нет но хотя структура тем не менее будет достаточно жестко значит
смотрите устроена она нет устроена она очень просто смотрите сейчас у нас будет но для того
чтобы вести понятие биномерная куча мы ведем понятие биномеральное дерево смотрите так вот
начитайте биномерное дерево порядка 0 это одна вершина биномерное дерево порядка 1 это две вершины
биномеральное дерево порядка 2 это так сразу варианты это 4 вершины
биномерное дерево порядка 3 это 8 вершин
но принцип очень простой дерево порядка к плюс один это что такое это такое дерево порядка к
к вершине которого мы повесили еще одного ребенка на котором висит еще одно дерево тк вот так
нет ну да но сейчас скажем давайте вот поэтому принципу я сейчас создам т4 то есть я возьму
просто вот нарисую просто просто честно это 3 а на него вот и добавлю корню еще одного ребенка
на котором повешу еще одно т3 вот
вот такая вот радость но можно принципе по-другому на самом деле да можно заметить что
дерево порядка к это на но то есть можно еще сказать что дерево порядка к это такая вершинка у
которой к детей и на этих к детей навешанных деревья порядка т 0 т 1 т 2 там и так далее там
тк т к-1 можно еще вот можно заметить что еще это вот так встроено вот это называется биномерное
дерево мы в таком дереве будем хранить элементы и как вы уже догадываетесь по принципу кучи то
есть в том плане что в каждой вершине элемент будет меньше чем у детей вот но как-то так-то
будет работать вот ну то есть каждый элемент меньше своих детей и больше никаких ограничений
нет это биномерное дерево почему это еще не куча да как миним как-то очень странно что мы можем
хранить только степени двойки структура у нас жесткая то есть даже непонятно как
удалить элемент то есть как бы нельзя просто взять и там отпилить ножку у дерева так чтобы
оно не перестало от этого быть дерево вот и вот теперь пришло время определения это было
биномерное дерево но вот а биномерная куча но а биномерная куча то есть прям вот можно
прямо определение сказать биномерная куча это но ладно скажем как официально говорят значит
связный список связный список значит биномерных деревьев
порядки которых строго возрастают вот так скажем
то есть у нас в одной биномерной куче два одинаковых дерева быть не может
они упорядочены по возрастанию своих порядков то есть размеров а элементы как угодно да ну и
здесь ну конечно дополнительность но вот но то есть еще также добавлю что она обычно еще ну то
есть там при это не особо принципиально хотя вот если вы хотите get mean то вам помимо этого
связанного списка нужно еще хранить в явном виде указательное минимум но потому что где минимум
в этих в каком из этих деревьев там логарифма деревьев минимум находится непонятно но вот
обычно принято его хранить по вот вот это ка называется порядок дерева вот вот по такому
порядку они упорядочены вот ну вот то есть конечно же там пейли там с элементами это никак не
связано вот вот так устроена биномерная куча да порядок но в каждой вершине порядок известен
и это позволяет нам кое-что делать но в первую очередь это нам позволяет делать мэлт ну мэлт
начинается но начинается в принципе с того что если у нас образовалась два одинаковых по
порядку дерева то их легко превратить в одно дерево правда надо просто к одному из них повесить
другое но кого кому повесить то в зависимости от того у кого корень меньше понимаете да
правда еще отдельная песня такая дайте вот еще тоже в науке может может встретиться но да и нам
тоже поэтому упомянем смотрите ведь как вот допустим вы хотите реализовать такую кучу как
вы будете хранить детей но либо вектор либо связанный список да ну в принципе есть такой
вариант но обычно нет от вектора иногда любят как бы избавляться то есть настолько любят избавляться
что в науке есть такое понятие pointer machine pointer machine what does it mean it means that we don't like
vectors and arrays I didn't know because ну короче говоря потому что там как-то выдают памяти
только кусками по 1 но это да но вот там вот иногда любят вот давайте считаем что мы не имеем
права за 1 выделять там массив памяти ну или там чтобы по нему скакать вот тогда а мы а все что
мы имеем право это вот мы пукать то есть нужна новая память мы можем сказать нею и нам дадут
фиксированный кусок памяти вот то есть условно говоря вот хочется запретить себе массив но первый
способ конечно это вот детей хранить в связанном списке но нам пригодится более эпический способ
смотрите вот давайте я на примере так 4 сейчас нарисую вот допустим я тут рисую какие-нибудь
элементы 5 там 7 там 6 8 там 8 10 там 9 11 тут 12 ладно не будем париться 13 14 15 16 17 19
в смысле не понял что так что такое хранить детей пеномерный куча я храню кучу как связан
список деревьев нет а нет в этом смысле нет дерево это нет это там дети это тоже пеномерные
деревья просто меньшего порядка вот ну можно про нот так вот есть очень красивый стал то есть
можно конечно то есть конечно кормон там в этом месте завещает конечно хранить то есть в реальности
хранить эти элементы так то есть сослаться вот сюда взаимно причем сослаться там а диано от
детей потом действительно сделать вот так вот был связан вот можно даже кольцевой список сделать
чего и что я тебе больше скан нет две да но это и неважно особо вот вот так вот можно но альтернативный
метод вообще очень красивый на самом деле у каждой вершины всего два указателя child и next
ну то есть каждая вершина говорит у меня есть как бы как бы мои мои дети делятся на два типа
типа самый большой ребенок и все остальные почему я делю именно так а потому что они
весят все равно одинаково нет ну логично да ну как бы действительно что кто больше
весят там это ребенок 15 лет или там три ребенка по 5 лет да ну по-разному ладно тут
по сути да и смотрите нет я спрашиваю что ты работаете так смотрите значит у каждой
вершины да есть то есть вот до 4 вершины хранится так вот в нашем случае у нас порядок 4 поэтому
смотрите вот у меня этот указатель next то есть у меня тут будет целая цепочка из питочков
вот целая цепочка из питочков питочки питочки единственные в мире питочки да вот значит чуть
такое вот это на самом деле символизирует типа что у нас есть одна вершина у которой 5 детей да
что тут корень что тут значение 5 это случайное совпадение сейчас вы в этом видеть вот значит
так сколько он а нет стоп мне пяти родителей четверо детей погодите давайте нет да давайте
спокойно у меня у меня четверо детей не пятеро да нет может быть потом я встречу еще какую-нибудь
такую же вершину 4 детьми мы объединимся у нас детей станет 5 но действительно жила было два
человек у каждого 4 ребенка они объединились чтобы каким образом имелись правильно один
из них стал ребенком другого все следовательно теперь и дал у кого-то из нас у того у кого
приоритет там лучше теперь пятеро детей да да вы можете да может быть это не жизненно да но как
вот значит отрить дальше происходит следующее значит теперь это мы сейчас подальше куда-нибудь
отвезем потому что третий в реале это будет так сюда здесь у нас отправляет значит какие у меня
тут дети бы здоров так ну здесь у меня будет самый большой ребенок 12 ну самый большой по
рангу естественно самый большой нет у меня все-таки 5 все четверть детей все нормально так далее тут
тот у меня будет сколько так тут у меня шубы тут у меня будет восьмерочка да тот у меня будет
шестерочка а нет да тут семерчика давайте вот так сделаем вот шестерочка семерчик нет
нет а да да чтобы от большего к меньшему по порядку внимание да то есть вот то есть
на самом деле вот да вот красивый способ который мы возможно там будем в следующий раз и пользоваться
иногда это то что на самом деле можно там биномиальное дерево вот таким вот образом хранить
то есть видите очень удобно да как бы есть как бы получается как бы чайлт на котором висит как бы
там дерево на порядок меньше и на экс на котором тоже висит такое тоже симметричное дерево на
порядок меньше сейчас это биномиальное дерево просто я его еще не дорисовал
ну указатель такой но на как бы следующий экземпляр себя то есть как бы чтобы воспитывать
четырех детей мне как бы нужно раз четвериться только вот уровень только мой уровень четвертый
у этого уровень третьей у этого второй у этого первой а у этого нулевой и у него детей нет нет
надо три вы так на том дерево вы так не покажете потому что next это как бы специзобретение такое то
есть это такой способ из-за повесить на вершину 4 ребенка но вот у меня дети 12 там 8 6 7 и вот тут
дети вот 12 8 6 7 вот да это мы так дали сейчас нет возможно я сейчас дорисую станет все понятнее
потому что я еще как бы как назвать я только начал вот значит 12 у него есть трое детей 13
14 16 поэтому мы идем тоже по next вот так вот так вот так вот то есть next next next и тут везде
12 12 12 на нем висит что же на нем висит а висит на нем так значит ну тут у нас так значит нас тут
трое детей так эти дети какие у нас 13 14 16 да 13 14 16 это не в том порядке 16 14 13 так что у
нас висит на 16 так на 16 так да у нас что-то висит а вот в роли чего-то 17 и 18
да 16 это 16 16 так порядок какой 17 18 так но здесь у этой вершины один ребенок то есть поэтому
сюда мы рисуем 17 а сюда мы рисуем 19 и на этом все здесь пока не так но 18 у нас один поэтому
тут тоже остается как есть так теперь 14 у нас есть так ну давайте для того чтобы нарисовать
адекватно что такое 14 мы все-таки это немножко подвинем вот давайте вот так вот сделаем
ой но да придется тех двигать тоже но ладно подвинем ну или уже поймем что мы уже все поняли
так так ну а что и так все понятно так или нет ну так тут 16 тут 14 тут 13 вот тут 13 вот ладно тут
у нас значит соответственно тут 14 тот чего где так на 14 висит 15 поэтому здесь мы рисуем 14
здесь мы рисуем 15 вот очень удобно вот видите то есть получается что-то такое полного двоичного
дерева видите то есть типа от каждой вершины можем перейти либо к ребенку либо к следующему
либо к списку следующих детей удобно оказывается что просто у каждой вершины красивая структура
child next и более того на каждый из них висят получается корректные деревья меньшего уровня
это бывает удобно ну учитывая что вектор тоже же там и дает оверхед где-то раз в два то как бы
нормально но я так скажу когда общее число вершин на самом деле это два там это сколько но
если у тебя тут два степеника как бы ключей то общий число вершин здесь это два степеника плюс
один минус один почему потому что три тут получилась полной двоичное дерево и на самом
деле листы это просто выписанные все элементы но да да тут ведь и по сути я просто теперь типа
дерево отрезков на минимум получилось на самом деле то есть у нас как бы выписаны дети и дальше
на каждом уровне мы выбираем минимум и говорим что он типа идет справа ну сливаемые до это
немножко не то ну по-моему не ну по-моему сливаемый до все-таки немножко другие
идеи впрочем дойдем разберемся но в некотором смысле да но там такое увидите вот вот но
заметь вот на 12 висит вот это то есть как бы она пятерки заметим что получается вот это
вот дерево это как раз тоже третьего порядка здесь тоже получается на 8 будет висеть какое-то
там дерево нужного порядка так что тут так что позвольте мне тут не дорисовывать но это пока
пример того как дерево может хранить ну бенмяльное дерево порядка када вот так тихо тихо тихо
так но давайте думать о как бы мы их не хранили как бы до связи списка дать подумаем как сделать
мэлт но мэлт думать достаточно очевидно просто двумя указателями идем по спискам и честно
сливаем и практически это будет идентично просто сложению столбиком двоичной системе
счастливее правда ну посмотрите допустим мы сливаем кучу типа состоящую из т0 там допустим
т5 и т8 с кучей какой-нибудь там т1 т5 там так какой-нибудь там т6 и т там 19 да но это для
простоты да как-то будет работать тогда идем двумя указателями так т0 меньше чем т1 поэтому
т0 заносим в ответ сдвигаем указатель сливаем т1 и т5 так ты один месяц ли идем так т5 и
т5 опа сюрприз т5 объединяем т5 и т5 получается т6 пока еще его никуда не заносим потому что
мы видим что дальше т6 тоже есть поэтому объединяем т6 т6 получается т7 вот не то это по большому
счетову перенос на самом деле поэтому да то есть т7 нет если тут т6 было тоже например да то
ну значит одно т6 мы бы сюда вынесли а дальше это 7 бы пошло дальше вот ну а дальше там по указателям
т8 это 13 но то есть это идентично тому что вы как бы складываете числа какие вы числа складываете
т0 т5 т8 это в бинарном виде получается 1 0 0 0 0 1 0 0 1 да и допустим вы складываете т1 т5 т6
это 13 то есть 0 1 0 0 0 значит там 1 1 что там дальше 0 0 и дальше там еще какой-то безобразие 0 0 0 0 1 то есть
когда вы складываете что делаете да и пить 1 плюс 0 1 0 это 1 так 0 0 0 1 плюс 1 значит тут 0
единичка в уме да тут теперь 1 плюс 0 значит 0 пишем единичка в уме и тут 0 плюс 0 плюс 1 это
1 тут 1 и дальше 0 0 0 0 1 да то есть вот так вы складываете столбиком бинарные числа да так вот
фишка в том что просто каждое конкретное сложение то есть за каждой единичкой стоит как бы биномиальное
дерево соответствующего размера то есть если вы складываете то есть перенос это означает что
у вас с предыдущих шагов образовалось еще дополнительно дерево этого порядка то есть
если у вас их таких два то значит вы сюда ничего не кладете а эти два дерева объединяете если у вас
их образовалось 3 то есть например вы там складывали 1 0 1 там 1 0 1 1 да то что бы у вас получилось да не
так давайте вот так то тогда вы бы 1 1 0 и тут получалось 1 в уме и тут получилось бы 3 3 единички
или в данном случае три биномиальных дерева порядка 1 да тогда что что вы делаете одно из этих
дерева вы переносите сюда остальные два складываете и у вас перенос оказывается здесь и тут получается 0 тут
получается 1 тут получается 0 тут получается 1 тут получается 1 вот так то есть когда может
быть немножко каскадно получается но в принципе это с помощью двухсвязанного списка это делается
легко правда ну можно но в какой-нибудь мягкой куче нам окажется полезно не выписывать но там
просто фишка такая что там один из но там будут забирать первые эти вот теперь откуда взялась вот
это пятая рекуррента про там логарифом минимума да так вот там будет фишка в том что нам будет
очень хотеться складывать то есть уметь сливать кучи не за от логарифма там размеров а за от
логарифма минимума размеров и на самом деле заметим что реальный столбик у вас там идет только
пока не закончится одна из куч а после этого у вас идет там максимум какой-то вот это как там
каскадное объединение там финального переноса оно конечно может работать задолго но как бы в
потенциале это учтется потому что каждая такое что такая штука уменьшает количество деревьев
ну примерно так ну по факту так и будет у вас по факту будет а вот у вас будет так по факту
два указателя и один перенос вот так что да кто сказал нет это я так это я на будущее сказал
что в реальности давайте вот теперь байномиал напишу давайте то есть пока мы как бы можем
заявить что байдобил хип вот а в мэлт имеет логарифм да гетмин если его отдельно хранить
минимумы то конечно вот единицы да то есть если мы каждый раз когда делаем например мэлт мы
этот минимум еще и пересчитываем в явном виде типа того да но не заморачивайтесь пока то есть
я пока на будущее накинул нам понадобится в софт хипе как бы структура будет почти такая поэтому
я так сразу накинул вот но пока вот для понимания биндальна куча этого конечно не нужно можете
себе воображать ее векторе вот что там дальше так теперь давайте думать мэлт у нас логарифм так
декриски за сколько работает ну да если хранить для каждой вершины родителя то в принципе там
сифта делается за логарифм так так следующий номер нашей программы так а теперь это просто как
сделать вставку но да то есть на самом деле и да тут на цели в сливаемых кучах часто будет как
слить очень просто сделать кучу из одного элемента и слить с предыдущим то есть инсерт равно крейт плюс
то давайте так начнем с более простого как удалять минимум
нет мы даже не проходим у нас есть где минимум две ойли
да но как вы уже сказали что на самом деле если вы удалите корень из
какого-то дерева у вас образуется корректная биндальная куча состоящие с кодирови
поэтому по факту просто создаем из ее кучу и делаем торжественное мэлт
ну да если мы удаляем именно известный нам минимум ну а если удаляя а как удалить
произвольный элемент да да сам стандартный метод сделать декрески на минус бесконечности
удали и экстракт мин сделать но до операции друг другу сводится нет потому что одея да тут
обычно третий ну формально как если в тупую так делать то конечно он тоже логарифом но обычно
принято это считается что давайте отдельно еще поддерживаем указатель на то где реально
минимум и во всех то есть там это работает зенит за счет того что во всех инститах во всех мэлтах
мы прям в явном виде этот минимум пересчитываем вот такая вот эпическая фишка вот в принципе
вот уже неплохо да как вот такую ну очень просто нет а я вам покажу смотрите смотрите нет это
очень просто так значит тут значит допустим мы тут решили 16 уменьшить допустим до чего там
до 4 первое что мы делаем это значит ну во первых тут 4 переписываем да а теперь идем в родителей
говорим так ты 12 а я 4 я меньше что делать только вот идея очень простая да ничего то какие
проблемы значит свапаем 4 и 12 прямо от указателя да ну как структура-то одинаковая да и здесь
вешаем 4 то есть ну свап в данном случае будет заключаться в том что у меня теперь вот этот
указатель будет красненьким а вот этот зелененьким то есть просто чайл то есть чайл дн экс подсуну там
послапали нет ну мы к этому при нет мы в принципе храним конечно но но в простой реализации обычно
нет обычно там эти 12 явном виде хранятся не придется не до свой себя ну пробежался за
логарифом поменял в чем проблема да но и но мы это да но ведь я вот я вот эти четверки здесь поменял
а эти 12 менять не надо потому что как бы просто просто теперь как бы в качестве это 12 будет
висеть в качестве ребенка а тут четверка и здесь то же самое теперь можно с пятеркой была тут
шестерка кстати свапать бы ничего не надо было чего 12 ну вот эти две на вот эти 12 трогать
не надо то есть мы потрогали только вот конкретно в этом месте да да да да да числёта даже не знаю
обычно минимум реально поддерживается практически везде нет но стараются там все делать за вот
единиц пусть даже это нам какие-то амортизационные издержки дают вот ну собственно будущим на это
будем смотреть после да пока же мы видим что у нас хорошие достижения что у нас все эти кучи не
имеют никакого отношения к амортизации вот то есть можно конечно сказать что мы дитмин конечно
делаем замортизированные там немножко чем-то похожим на амортизацию да потому что по факту
мы вычисления минимум просто делаем заранее ранее но вот но но с другой стороны зачем заросли
у нас гитминов очень много этих операций очень мало то на аналогично действительно его один раз
вычислить вот но в будущем конечно нас ждет и эпическая амортизация которая позволит там
некоторые этих логарифмов позаменять на единицы да ну потому что фактически ты делаешь сифтап просто
сифтап делаешь а глубину тут все логарифмические вот это сифтап и еще возможно минимум пересчитать
но это даже за вот единицы пересчитывается вот так что в будущем то есть конечно у нас будет
амортизация то есть будет будем пытаться эти логарифмы убивать но сразу оговоримся все
конечно очевидно логарифмы не убьем потому что да иначе нас будет сортировка за линию но
почти все убить удастся если не ко мне ну есть нет ну тогда и с деревом дебулоса конечно да
который все делает за лог б но оно прям вообще все оно сильно оно будет значительно сильнее кучи
правда при этом но там есть какие-нибудь более простые структуры но там но это уже совсем другая
история вот так так ладно ну что судя по времени на сегодня все
