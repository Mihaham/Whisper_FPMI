Так, начнем лекцию. Сегодня мы начинаем новую веху в нашей базовой истории и будем говорить,
собственно, мы начинаем четвертый модуль, заключительный, в нашем курсе мы будем говорить
целиком и полностью про задачи rmq и rsq. Значит, расшифровываются как
рейндж минимум или сам кьюри, ну или запросы, запрос минимума, суммы
на отрезке. Будем разбирать эти задачи. Значит, для начала классическая базовая постановка. Задача.
Дан некоторый массив. Вот и нужно отвечать на запросы следующего вида. Значит, запрос выглядит так.
Как кьюри от l до r. Что это означает? Это означает, что надо найти
результат некоторой операции на отрезке l до r. Ну, то есть, давайте приведем пример.
Пусть мне дан массив, 7, 5, 0, 1, 2, 4, 3. Вот. 1, 2, 3, 4, 5, ну давайте шестерку еще напишем.
Значит, там такой массив и периодически к нему приходят различные запросы. Например, найти минимум на отрезке
отресов второго по четвертый элемент. Нолевой, первый, второй, третий, четвертый. То есть, мне нужно найти минимум вот на этом отрезке.
То есть, естественно, в качестве ответа должен вернуться ноль. Или запрос найти сумму на отрезке с четвертого по, ну пусть по седьмой.
5, 6, 7. Соответственно, нужно найти те сумму, что это 15. Да, ну и так далее. То есть, операции могут быть, вообще говоря, разные.
То есть, не обязательно это операция минимума, суммы. То есть, может быть, операция произведения, максимума, наименьшего общего делителя,
количество нулей. Ну и так далее. Ну, в общем, просто некоторый запрос к отрезку. Ну и соответственно, цель нашей сегодняшней будущей лекции
понять, как можно это все делать наиболее эффективно. Ну, давайте для начала, как и в любой другой задаче, рассмотрим какой-нибудь наивный подход.
Ну, то есть, понятно, что наивный подход работает за, за сколько? Ну, за линию, да. То есть, за θ от r минус l, ну или за o большое от n.
Ну, где n это, где n это размер массива? Ну, то есть, естественно, если вам приходит некий запрос, то самый банальный способ это просто пройтись и все посчитать.
Ну, естественно, такой способ вряд ли нас устраивает, особенно если у вас запросов много. Скажем, если у вас размер массива миллион, да, запросов тысяч,
то за какое-то обозримое время, то есть, там меньше секунды и так далее, вы это, естественно, не посчитаете. Ну, а запросы, естественно, будут попадаться именно такие.
С другой стороны, если вам известно, что запросов достаточно мало, то есть понятно дело, что если запросов мало,
вам известно, что 2-3 запроса в сутки или всего 2-3 запроса на всю таблицу, то, естественно,
никакие структуры данных строить не надо. Это, в принципе, нормальное решение.
Вы за линейное время обработали все запросы. Но, естественно, мы будем стремиться не к этому,
но мы будем стремиться немного к другим вещам. Давайте попробуем как-нибудь этот подход улучшить.
Как-нибудь попробуем этот подход улучшить. И первое улучшение, про которое мы поговорим,
будет, давайте, пункт номер ноль, SQRT, декомпозиция.
Кто-нибудь слышал что-нибудь про такой метод? Встречался? Нет?
Просто довольно популярный способ оптимизации каких-то запросов на отрезках
или каких-то функций для работы с массивами. Давайте разберем.
Идея в чем? Давайте здесь будет иллюстрация, здесь я буду писать, что происходит.
Первым шагом разобьем массив на подотрезке размера B.
Возьмем и как-то порежем наш большой массив на вот такие подотрезочки.
Ну последний, может быть, не достигает B, но вот как-то так.
Значит, это первый шаг. На втором шаге посчитаем результат операции
на каждом из этих подотрезков. Ну и сохраним. Сохраним в каком-то отдельном массиве.
Это означает буквально следующее. Мы считаем минимум или сумму здесь,
считаем минимум и сумму здесь и строим некоторый новый массив,
в котором все эти результаты сохраним. Размер исходного массива был N,
размер этого массива N деленное на B, округленное куда? Вверх-вниз, кажется, вверх.
Ну не важно, короче говоря, N деленное на B. Ну в общем-то и все.
Это предпочет таким образом закончен. Да, тут важно отметить, что сейчас мы будем рассматривать.
Понятно, если мы не используем наимный подход, то чтобы его не использовать,
нам необходимо сделать какой-то предпочет. То есть нам необходимо либо построить
какую-то структуру данных, либо как-то обработать наши входные данные,
чтобы можно было в дальнейшем использовать более эффективные методы.
Поэтому любой алгоритм я буду оценивать с помощью двух увеличений.
Первое это время при процессинге.
То есть это то время, которое я потрачу на то, чтобы прочитать мои входные данные
и с ними что-то сделать, каким-то образом переупорядочить, построить какую-то структуру данных,
чтобы можно было более эффективно наполнять запросы.
Ну и время, соответственно, операции запроса.
Так вот, давайте вернемся к этой структуре, то, что мы построили,
и поймем, сколько времени нам потребуется, чтобы построить достаточно примитивную, но все-таки структуру данных.
От n, да? Все согласны? Все видят, что от n.
Ну потому что что я делаю? Я, по сути, беру первый отрезок, считаю в нем сумму минимум,
или что угодно сохраняю, беру второй отрезок, считаю в нем зеленей на время и так далее.
Если я просуммирую размеры всех отрезков, то, естественно, получу n.
Поэтому время на припроцессинг, это от n.
Как выполняется запрос?
Значит, запрос выглядит следующим образом.
Давайте здесь порисуем.
Вот у меня есть большой массив, который я некоторым образом разбил на отрезке.
Приходит запрос. Найти сумму произведения, что угодно, вот на таком отрезке.
Как бы вы решили эту задачу, имея на руках вот то, что у нас есть?
Вот эти. Да, смотрите, вот эти.
Вот для всех этих элементов мы уже значение посчитали. Согласны?
То есть мы можем запрос вот на этих отрезках свести к запросу вот на этих штуках.
То есть давайте запишем.
Если под отрезки целиком лежат в запросе, то считаем ответ
в построенном массиве. Ну, под построенным массивом я имею в виду вот этот массив.
То есть у нас есть потенциально много кусков больших, для которых мы все уже посчитали.
Они находятся здесь. Поэтому свели задачу подсчета минимума или суммы на таком большом отрезке
к подсчету на вот таком маленьком отрезке. Согласны?
А что с вот этими делать? Да, ну а здесь посчитаем вручную.
Остатки. Ну давайте. Что такое остатки? Остатки это вот эти вот штуки.
Остатки посчитаем вручную. Вот.
Такая идея. Ну и за сколько это все работает?
Ну, N и B получается тут. У нас все-таки два параметра. То есть у нас есть параметры размер массива
и размеры отрезков, на которые мы делим. То есть я думаю, вы понимаете, что если мы возьмем в качестве B единицу,
то мы ничего не выиграем. Поэтому B нужно выбрать каким-то разумным.
Сейчас вспомним вам каким. Давай для произвольного B попробуем понять, за сколько мы работаем.
Ну вот первый шаг из опроса. За сколько мы посчитаем ответ вот на таких отрезках?
Ну это неправда. Ну то есть в каждом отдельном отрезке, естественно, за единицу.
Но суммарно-то их больше, чем один. N на B, да. То есть потенциально мы, в худшем случае,
мы пройдемся по всем элементам здесь. Поэтому первый шаг работает за N делить на B. Все согласны?
Большое N деленное на B. И плюс, за сколько времени мы обработаем вот эти самые остатки?
За 2B. Ну снова, у нас каждый из остатков не превосходит B,
поэтому мы отработаем за B, ну как бы на константу забьем, поэтому напишем просто плюс B. Вот такая сложность.
Смотрите, мы эту схему будем улучшать, мы эту схему улучшим в какой-то момент. Возможно в следующем семестре.
Вот так или иначе. Да, то есть вот эти штуки тоже можно оптимизировать.
Ну самый простой ответ, который здесь мог быть, это скажем, мы можем посчитать сумму на всех префиксах здесь
и сумму на всех суффиксах. Ну тоже предпочитать. Ну тут правда непонятно, как вы будете разбираться вот такими запросами.
Это мы будем улучшать, это естественно не самый хороший подход, но это просто простой подход, который работает,
с помощью которого можно заметно улучшить время запроса. Так вот, давайте попробуем вот эту штуку минимизировать.
Что? Плюс 2B, ну в терминах онотации мы на констанции забиваем. Ну что 2B, что 3B.
Ну давайте, чтобы никого не смущает. Пишу 2B. Так, давайте минимизируем эту штуку.
Ну при каком B это достигает минимума. Кто считает производные, окститесь, да, B равно корень из N.
Да, ну это легко понять почему, потому что если я возьму B равно корень из N, то первое слагаемое состояние корень из N
и второе слагаемое состояние корень из N. Если разнюю что-то больше чем корень из N, то у меня второе слагаемое вырастет.
Если я возьму что-то меньше чем корень из N, то у меня первое слагаемое вырастет. Ну понятно, да?
поэтому минимум достигается на корне из n. Ну и собственно отсюда и название
square-t-декомпозиция. То есть мы разбили наш весь отрезок под отрезки размера
корень из n и улучшили время работы от n до корня из n, ну короче говоря улучшили
запрос, но это все равно не очень хорошо. Почему? Не совсем понял. То есть приведите пример
запроса, который работает за линию. Вот этот? Так если такие запросы, то я просто
за линейное время считаю тут минимум, но размер этого кусочка у меня корень из n.
И этот запрос я обрабатываю максимум за корень из n.
Или что-то не ясно? Да. Вы смотрите время при процессинге это что? Вот вам приходит массив и
говорят, то есть вам приходит задача, вам приходит массив и вам говорят,
будет миллион запросов вида найти минимум на отрезке, найти сумму на отрезке. То есть вы
можете потратить какое-то время на то, чтобы как-то обработать ваши данные, ну чтобы потом в
последствии можно было эффективно считать. Вот пример. Если мы никак не обрабатываем массив,
а просто в тупую обрабатываем наши запросы, то мы каждый запрос обрабатываем в худшем случае
за линию. А что мы здесь делали? Мы взяли массив и не стали сразу отвечать на запросы,
а провели некоторую работу над ним, то есть свели задачу к меньшим подзадачам, корневым,
и потратили на это время teta от m. То есть это один раз на всю программу. А потом нам приходят
запросы и мы отвечаем на все остальные запросы за корень из n. То есть суммарное время, если угодно,
да, это t при процессинга плюс количество запросов, умноженное на tq от n, и это равно o от n
плюс q на корень из n. Это суммарное время работы над этой структурой данных. Вот. Ну это вот два
простых метода, которые позволяют практически бесплатно получить некоторые улучшения или как-то
решить задачу. Ну как бы что ответ за n, что ответ за корень из n, на самом деле достаточно плохо,
потому что они достаточно, то есть это достаточно быстрорастущие функции. Все-таки хотелось бы,
хотелось бы чего-то получше. Ну и давайте перейдем к более осмысленным структурам данных, которые
решают те же самые задачи. Значит, здесь необходимо поговорить про классификацию задач.
Задача rmq-rsq под пункт классификация. Задача rmq-rsq делится на несколько категорий, то есть бывают
разные, у них бывают разные постановки, и вот в зависимости от того, какая постановка вам дана,
различают следующие виды задач. Бывают задачи статик, а бывают задачи дайнэмик. Чем эти задачи
отличаются? Статик, массив не меняется. Ну то есть вот это та задача, которую мы решали сейчас. То
есть вам дана некоторый массив, он фиксирован, то есть вам гарантируется, что он никогда не
будет меняться, то есть в него не будут добавляться элементы, сами элементы тоже не будут изменяться,
и вам нужно просто отвечать на запросы, сумму, минимум и так далее. Ну а динамика, естественно,
давайте так скажем, есть запросы изменения. Ну то есть помимо запросов там найти сумму,
найти минимум, найти максимум, периодически поступают запросы, скажем, изменить этот
элемент и изменить какую-то группу элементов и так далее. Ну естественно, эта задача более
сложная, ее мы тоже будем решать. Какие еще есть бывают виды? Бывают оффлайн задача и онлайн задача.
Значит, оффлайн, все запросы известны заранее. Ну допустим, вам дана некоторый массив, и вам
сразу же сказано, что будут именно такие вот запросы. То есть будет запрос, скажем, найти сумму
с первого по третьей, с четвертого по пятой и так далее. Тут, в принципе, вам сказано, что вот
есть запросы, вам приходит на вход запрос, и вы понимаете, что все эти отрезки не пересекаются
друг с другом. Естественно, в таком случае вы можете просто все запросы считать и дальше обрабатывать
их в нужном вам порядке. Скажем, обработать все запросы, которые работают с первой половиной
массива, потом обработать запрос, который работает со второй половиной массива и так далее. Ну и онлайн задача.
Давайте так скажем. Эта задача вид запрос-ответ. То есть вам приходит запрос, вам тут же нужно выплюнуть
ответ. То есть если в оффлайн-задаче вы можете сразу считать все запросы и потом отвечать на них в
нужном вам порядке, в каком вы хотите, то в случае онлайн-постановке вам приходит запрос, вам сразу
нужно выдать ответ. Да, запрос и ответ. На лекциях мы будем рассматривать статическую постановку,
динамическую постановку и онлайн постановку. С оффлайн вы тоже поработаете, но уже самостоятельно,
на семинарах и в домашнем задании. Естественно, у нас есть две задачи, которые отличаются одной
буквой. RMQ и RSQ. Давайте я даже, наверное, перейду куда-то сюда. Все ли понимают, что операции вида
минимум и операции вида максимум, это разные операции и поэтому, скорее всего, их решать придется
каким-то разными методами. Давайте переведем пример. Давайте не пример точнее, а попробуем ответить на вопрос,
в чем отличие задач RMQ и RSQ. Давайте скажем, есть операция минимума, есть операция суммы.
Давайте попробуем найти сходство и отличия. В общем, какими свойствами обладает операция минимума?
Своица операции там, она ассоциативна, коммунативна. Ассоциативна или операция минимума?
Ассоциативна, да, то есть есть ассоциативность. Сложение, естественно, тоже ассоциативно.
Коммунативность есть. Здесь тоже есть. Ну хорошо, обе операции ассоциативны, обе операции коммунативны,
а в чем отличие-то? Почему бы не просто взять, не свести там, скажем, обе задачи к одной и той же и все?
Почему, скажем, методы, которые применимы к одной операции, могут быть неприменимы к другой операции?
Что вы про плюс, например, можете сказать? Плюс операция обратимая.
Минимум, к сожалению, нет. Ну скажем, если я вам дам уравнение вида, давайте так, х плюс 3 равно 5,
то, как минимум, к экзамену по матану вы должны будете уметь это решать, правильно? То есть теоретически это возможно.
Если я вам дам уравнение вида равно 3, то тут вам даже 6 курсов вистеха не помогут.
Поэтому минимум операции не обратимая, это печально. Но у минимума есть одно замечательное свойство,
у которого нету плюса. Ну хорошо, слово дня. Идемпотентность. Что это за свойство, кто знает?
Отлично. Идемпотентность это свойство, что если вы применяете некоторую операцию к одному и тому же элементу два раза,
то вы получите тот же самый элемент. Понятное дело, что минимум из х и икса это х. Для суммы, естественно, это неверно.
То есть х плюс х в общем случае не равно 2х. Не равно х, да. Это я вас проверял. Согласны?
Ну и давайте, собственно, зная вот эту разницу, будем строить некоторые специфичные структуры данных,
которые будут позволять решать те или иные издачи. Ну в общем-то, специфичная операция,
они как раз используют свойства либо обратимости, либо идемпотентности. То есть если вы можете построить
какую-то эффективную структуру данных для суммы, то она вряд ли заработает для минимума.
структуру данных для минимума, то она вряд ли будет эффективной для суммы.
В качестве первого примера такой структуры данных решим простую задачу.
Значит, какой пункт?
Задача статик rsq.
Просто я говорил выше. Задача звучит следующим образом.
У меня есть некоторый массив, этот массив неизменяемый,
и мне нужно отвечать на запросы, виды найти сумму на каком-то отрезке,
найти сумму на другом отрезке, ну или на самом деле найти результат
в выполнении произвольной операции, которая обладает свойствами обратимости.
Ну а там обративности, коммутативности, ассоциативности.
Ну, снова давайте кончимся.
Думаем, 6, 0, 5, 4, 3, 2.
Ну вот вам данная задача. Как будем решать?
Да, да, все гениальное просто.
Действительно, решение массив префиксных сумм.
Ну то есть заведем массив P такой, что в элементе P i там будет хранится сумма,
давайте ПК там, будет хранится сумма P i от 0 до k аитах.
Просто будем хранить суммы на всевозможных префиксах.
Ну то есть если это массив A, то из этого массива A мы сделаем массив P,
который будет иметь вид 6, дальше 11, 15, 18, 20.
Соответственно, при процессинге, естественно, работает за сколько?
За линейное время.
Все понимают, как посчитать массив префиксных сумм за линейное время.
Ну мы просто идем, значит записываем элемент сюда, дальше сюда записываем элемент.
Ну давайте формулу просто напишем.
Ну отсюда нам просто следует, что это P i-1 плюс i.
Ну естественно там крайний случай нуля надо рассмотреть,
но не будем этим заморачивать голову.
Ну и запрос.
Мне нужно найти, скажем, значение суммы вот на таком отрезке.
Со второго по четвертый.
Что я должен сделать?
То есть qi от lr выглядит следующим образом.
Я обращаюсь к элементу под номером r.
Ну давайте так распишем.
Это будет сумма по i от l до r аитых.
В свою очередь это равно сумма по i от 0 до r аитых,
минус сумма по i от 0 до l-1 аитых.
Но это в точности равно значению префиксной суммы в точке r
и значению префиксной суммы в точке l-1.
То есть P от r минус P от l-1.
Ну и время запроса.
Вот вам пример структура данных,
которая решила ту же самую задачу,
которую мы вроде поставили до этого.
Но при этом мы воспользовались всего лишь свойством обратимости
и смогли сильно улучшить наш алгоритм.
При процессе за линейное время и сразу же отвечаем на вопросы.
То есть сразу отвечаем на запросы за O от единицы.
Вот. Такие дела.
Что?
Минус.
Ну скажем, давайте заменим операцию суммы на операцию минимума.
Как бы вы нашли значение минимум? Давайте мысленно.
Можно записывать просто.
Мысленно представим, что у нас такая вещь.
То есть считаем минимум на префексе.
То есть тут 6, тут 0 и дальше везде 0.
Нужно найти минимум на отрезке от 2 до 4.
Вот. Обращаясь к вот этим элементам,
вы естественно никак не поймете, какой у вас там минимум.
Потому что вы не можете вычесть.
Ну короче, нет операции в вычитании,
нет операции обратной минимуму.
Так, ну еще пару слов про массив рефиксум.
Ну смотрите, с обратимостью разобрались.
Ассоциативность вроде тоже понятна.
С ассоциативностью, думаю, тоже все понятно.
Потому что если мы хотим посчитать значение здесь,
то мы берем значение отсюда, вычитаем отсюда и так далее.
А что коммутативность? Нужна ли тут коммутативность или нет?
Скажем, можем ли мы использовать то же самое для некоммунативной операции?
Например, у меня в ячейках массива хранятся матрицы.
Я перемножаю так матрицы.
И, собственно, здесь, когда я использую вычитание,
умножаю на обратную матрицу.
Скажем, если я хочу найти произведение матриц здесь,
то я беру произведение матриц здесь
и умножаю на обратную матрицу, полученную произведением элементов здесь.
Что? Другой ответ получится. А какой?
Нет, на самом деле все хорошо с коммутативностью.
Единственный момент заключается в том,
что то, как мы писали здесь, тут написано следующее.
То есть мы берем a0, a1, a2, и так далее, ar.
А потом берем следующую штуку, a0, и так далее, al, минус 1.
Естественно, если операция некоммунативна, то это не работает.
Согласны?
Ну просто, потому что если я беру минус 1,
то получается вот такая история, al-1, и так далее, a0-1.
Естественно, al-1 и ar, они не сократятся.
В общем, операция некоммунативна.
Если у меня операция была коммунативна,
то я мог просто al вынести к kL, al-1, kL-1, a0 к 0, и все бы сократилось.
Здесь такого нет.
Но операцию можно сделать коммунативно,
то есть от этой штуки можно добиться того,
чтобы она не требовала коммунативность,
просто-напросто поменяв местами операнды.
Скажем, если я возьму a0, и так далее, al-1,
и потом только выполню a0, и так далее, ar,
тут al, то тут все будет хорошо.
Согласны?
Я возьму вот эту штуку, свернусь вот этой штукой,
и получается только произведение от al-1 до ar.
Поэтому коммунативность тут тоже не нужна.
Единственное требование на операцию,
которую можно с помощью такой префиксной суммы обрабатывать,
это ассоциативность и обратимость.
Идем дальше.
Следующий на очереди у нас задача статика РМК.
Как будем решать?
С помощью такой структуры решить задачу с минимумом не получится.
Нельзя сказать, что если я посчитаю минимум на префексе,
посчитаю минимум на маленьком префексе,
то я смогу понять минимум на разности.
То есть такого, естественно, сделать нельзя.
Давайте попробуем что-нибудь придумать.
Придумаем что-нибудь вот в таком виде.
Значит, первый пункт, метод грубой силы,
ну или просто некоторый наивный подход.
Давайте сейчас рассмотрим некоторый наивный подход,
то есть тупой, банальный, который работает долго,
но впоследствии мы его очень сильно улучшим.
Давайте сделаем довольно странную вещь.
Давайте посчитаем минимумы на всевозможных отрезках.
Вопрос возьмем и на всевозможных отрезках посчитаем.
Ну, то есть заведем массив s, двумерный, давайте t лучше, t и s.
Это минимум на отрезке i, i плюс s минус 1.
Ну, то есть это минимум на отрезке, начинающейся в позиции i,
и имеющий размер s.
Ну, естественно, при процессинг такой штуки работает за n квадрат.
Ну, чтобы заполнить эту табличку, вам потребуется времени n квадрат.
Но за то время запроса у вас будет вот единица.
Красота?
Нравится?
Мне тоже нравится.
Давайте попробуем как-то вот эту штуку улучшить.
В общем, этот метод понятен.
Он плохой, но он работает.
Давайте попробуем как-нибудь улучшить.
В общем, я предлагаю улучшать следующую сторону.
Я утверждаю, что хранить минимум на каждом подотреске довольно дорого.
Хранить минимум, точнее, на подотреске всех длин.
На подотреске длины 1, 2, 3, 4, 5.
В общем, это слишком много, и это на самом деле избыточно.
Я утверждаю, что можно обойтись меньшим количеством отрезков.
Какие отрезки нам достаточно?
Ну, смотрите.
Вот пусть мне нужно посчитать минимум на отрезке длины s.
Минимум на отрезке длины s.
В том подходе предлагается следующее.
Ну, так как я храню минимум на всех подотресках,
на подотресках всех длин,
то я соответственно значение здесь могу посчитать за единицу.
А вот давайте представим себе следующую ситуацию.
Допустим, я не знаю минимума на отрезке длины s.
Конкретно на этом отрезке я ничего не знаю.
Могу ли я по-прежнему как-то за о от единицы посчитать значение минимуму здесь?
Если я знаю, скажем, значение минимума на подотресках меньше длины.
Например.
Из-за идемпатентности, да.
Значит, смотрите.
Если я знаю значение на подотреске s меньше, чем s,
то что я могу сделать?
Я могу развить мой отрезок на вот такой отрезок длины s.
И вот на такой отрезок длины s.
Посчитать минимум, то есть найти минимум здесь, найти минимум здесь.
И дальше я могу взять минимум от этих двух штук.
И так как у меня выполняются свойства идемпатентности,
идемпатентности,
то все будет хорошо.
Согласны? То есть то, что я два раза учту вот этот вот отрезок,
меня в принципе не волнует.
Он просто-напросто схлопнется.
Для суммы это, естественно, не работает.
Потому что если я посчитаю сумму здесь,
потом посчитаю сумму здесь,
то неверно, что сумма на всем отрезке это сумма вот этих штук.
А вот для минимума, максимума,
что там еще?
Наименьший общий делитель,
наибольший общий делитель,
наименьший общий крат,
на это все верно.
Ну и, собственно,
заключительный вопрос.
А для каких s-трих мне тогда,
вот какие s-трих мне нужно посчитать,
чтобы это всегда можно было сделать?
Здесь следующее.
Давайте в качестве s-трих
будем брать
отрезки,
длина которых
является степенью двойки.
То есть не будем считать минимум на всевозможных отрезках.
Один, два, три, четыре и так далее.
А будем считать минимум на подотресках длины один,
длины два, длины четыре, длины восемь и так далее.
И вот тогда я утверждаю, что вы любой отрезок
таким образом покроете.
Понятно как?
Ну вы просто возьмете ближайшую степень двойки снизу,
и она, естественно, покроет
два раза ваш отрезок.
Вот идея.
И, собственно, идея к структуре данных,
которая реализует эту идею, называется
sparse table
или разреженная таблица.
Разреженная
таблица.
То есть будем строить
двумерный массив вот такого вида.
Это будет равно
минимуму на отрезке
от i
до i плюс
два степеника минус один.
То есть это минимум на отрезке,
который начинается в позиции i
и имеет длину два степеника.
Окей?
Давайте начнем с запроса.
Пока забьем на то, как это можно построить,
давайте убедимся, что
давайте убедимся, что запрос
действительно можно выполнить за от единицы.
Вот смотрите, допустим, вам известно,
вам известно следующее.
Вам известно вот такая штука.
То есть вам известны минимумы на всех подотресках,
длина которых является степенью двойки.
И вам приходит запрос найти минимум на отрезке от l до r.
Вот от l до r.
Как обработать этот запрос,
имея на руках вот эту таблицу?
Что нужно взять в качестве k?
Логарифм двоичный, да, то есть
в качестве k берем
логарифм двоичный от r-l
плюс один, ну скажем, округляем вниз.
Вот.
И дальше что?
Что возвращаем?
Ага.
Минимум из t, l и k.
То есть берем минимум вот на этом отрезке.
Да?
То есть что такое t, l, k?
t, l, k это минимум на отрезке,
который начинается в позиции l
и имеет длину 2 в степени k.
Ну то есть вот на таком отрезке.
И теперь нужно взять вот этот отрезок.
А он какой размер имеет?
Точнее, какой вид?
Да, t от r-2 в степени k
от k.
Ну вот.
Согласны?
Вот.
Ну естественно, то есть вот это обращение
за 1, вот это обращение за 1,
соответственно, весь запрос
вас обрабатывает за 1.
То есть вы берете произвольное отрезок
и разбиваете его на два подотреска,
которые имеют,
ну два на два подотреска,
длина которых имеет,
которая является степенью двойки.
Тут есть тонкий момент,
который появляется вот здесь.
То есть как посчитать логарифм двоичный,
то есть как найти ближайшую
минимальную степень двойки.
Но это абсолютно на семинарах.
В общем-то, есть более-менее два подхода.
То есть первое, это вы предварительно
считаете всевозможные логарифмы,
то есть там для единиц, для двойки, для тройки,
то есть для всех предпочитываете k.
А есть другой подход,
используете встроенную функцию.
Ну, она не встроена в язык,
но является некоторым расширением
для GCC и других,
Billkin CLZ,
которая просто считает количество ведущих нулей
в числе.
Таким образом, вы можете эффективно
высчитывать логарифм от числа,
ну для целого числа.
В общем, поговорите семинаристами,
какой способ они вам предложат,
таким и пользуйтесь.
Но это уже такая техническая деталь,
мы туда не лезем.
Так, давайте сюда.
Значит, что нам остается?
Нам остается,
да я думаю, пример нам привести надо,
ну что, было понимание?
Примерно.
Давайте возьмем какой-нибудь массив снова.
5, 0, 4, 3, 6, 1,
5, 0, 4, 3, 6, 1,
ну и еще какой-нибудь,
ну пусть 7.
Вот, как будет выглядеть наша таблица?
Значит, наша таблица будет выглядеть так.
Ну, здесь мы будем писать,
k равна 0, k равна 1, k равна 2.
Этого нам будет достаточно.
Ну и здесь, соответственно,
0, 1, 2, 3, 4, 5, 6.
Вот, значит, в нулевой строке,
в нулевой строке нашей таблицы,
что будет храниться?
2 в степени 0 это 1,
ну то есть мы будем хранить там минимумы
на всех подотресках длины 1.
То есть просто исходный массив, да.
То есть просто 5, 0, 4, 3, 6, 1, 7.
То есть ну минимум на отрезках длины 1,
это просто самый исходный массив.
Теперь, как посчитать значение здесь?
Ну, давайте параллельно думать о том,
во-первых, что сюда нужно поставить,
во-вторых, как это посчитать?
Давайте сначала ответим на первый вопрос.
Что тут должно стоять?
Тут должно стоять минимум на подотреске,
в нуле,
и имеет длину 2 в степени 1, то есть 2.
То есть здесь хранится 0.
Далее. Здесь.
Значит, у нас отрезок начинается в единице,
имеет длину 2, поэтому должен 0.
Переходим дальше. Здесь 3.
Здесь 3.
Здесь 1.
Здесь 1.
Все, дальше мы выходим за границы,
но тут мы ничего не считаем.
Так, ну и дальше х равное 2,
то есть на подотресках длины 4.
Значит, берем подотрезок, который начинается в нуле,
и длины 4. Тут 0.
Дальше сдвигаемся вправо, тут тоже 0.
Сдвигаемся вправо, тут единица.
Сдвигаемся вправо, тут тоже единица.
Здесь ничего не ставим.
Ну вот, получилась такая таблица.
Вопрос, как ее построить?
Вопросов нет, да?
Все понятно.
Что мы тут сделали и так далее.
Окей, ну построение такое.
Что у нас тут? Какой индекс?
t и 0 равно просто a и t для любого i.
Это обсудили.
То есть, первое, что мы делаем,
что мы делаем,
что мы делаем,
для любого i.
Это обсудили.
То есть, первая строка таблицы,
это всегда просто-напросто исходный массив.
Вот он.
Идем дальше.
Как мне построить следующие уровни?
4k, in, 1 и так далее, ugn.
Так, давайте в другое место перейдем.
4k, in, 1 и так далее, log n.
4i, in, 0 и так далее.
До какого?
До какого?
До n-2 в степени k.
Да?
Ну, чтобы не выходить за границу,
чтобы не читать минимум там, где нам не надо.
Мы делаем следующую вещь.
t от i k равно чему?
Ну вот, мне нужно посчитать значения в ячейке t и k.
То есть, мне, грубо говоря, нужно идти минимум на отрезке от i,
до i плюс 2 в степени k минус 1.
Ну, смотрите, если я иду циклом по k,
то я считаю значения в точке k,
то я точно знаю, что у меня уже посчитаны все значения
для k минус 1, k минус 2 и так далее.
То есть, я могу просто свести задачу к меньшим.
То есть, как я здесь могу свести?
Я могу свести к поиску минимума на отрезке от i,
до i плюс 2 в степени k минус 1 минус 1.
И i плюс 2 в степени k минус 1.
И плюс 2 в степени k минус 1.
Согласны?
А это что такое?
Это отрезок, который начинается в позиции i,
имеет длину 2 в степени k минус 1.
Где у меня хранится этот результат?
до t i k минус 1.
Ну, естественно, от всего этого я беру минимум.
А вот это что за отрезок?
Смотрите, он имеет длину 2 в степени k минус 1 и начинается здесь.
То есть, я беру значение в точке i плюс 2 в степени k минус 1,
k минус 1.
Все.
То есть, вот таким вот рекуррентным способом я посчитал все значения матрицы t i k
на основании уже посчитанных значений.
То есть, заметьте, что к моменту, когда я считаю значение для
индекса k, у меня все значения для k минус 1 уже посчитаны.
Да, поэтому я спокойно могу ими пользоваться.
Вот.
Вот, собственно, весь код построения.
Это build.
И за сколько это работает?
t при процессинге от n.
За сколько отработает этот цикл?
Ну, за сколько отработает этот цикл?
Ну, этот цикл, естественно, работает за длину моей sparse таблицы.
Можем ли мы как-то ограничить ее размер сверху?
Ну, сколько у меня столбцов?
Ну, вот здесь.
Да, за n лог n.
Вот и ответ.
За n лог n.
Ну, тут тоже легко понять, иначе у меня внешний цикл работает за алгоритм,
внутренний цикл работает максимум за n.
Поэтому n лог n.
Ну, понятное дело, что у меня тут постепенно размеры внутреннего цикла уменьшаются,
но если просуммировать, то есть если честно все просуммировать,
то лучше, чем n лог n, то очень не получится.
В общем.
А симпатика здесь n лог n.
Все, значит, итог.
Какой у нас итог?
Итог.
Мы построили sparse table, разреженную таблицу,
у которой при процессинг занимает n лог n,
и на запрос он отвечает за вот единицы.
Достойно, да?
То есть с помощью такого нехитрого трюка мы начинали там с чего?
Мы начинали с того, что мы строим там квадратичную какую-то таблицу,
и в итоге спустились до таблицы, которая строится за n лог n.
У вас может возникнуть вопрос.
Можно ли лог n лог n?
Ответ можно.
Но вы еще маленькие.
Я вам этого не расскажу.
Вот, возрастейте через лекции 2.
Может быть, поговорим.
Что?
Деревоотресков решать другую задачу.
И у него симпатика чуть похуже.
Давайте, раз время есть, давайте поговорим просто про некоторые улучшения.
Которые мы уже сейчас можем сделать.
В общем, ну к чему мы в итоге стремимся?
Мы в итоге на самом деле хотим, чтобы тут стояла n.
То есть n лог n на самом деле очень неплохо.
Н лог n на самом деле здорово.
Н лог n на практике практически ничем не отличается от линий.
А симпатически, естественно, хочется чего-то лучшего.
Тем более, что у нас была там структура данных, префиксные суммы,
которые умели все делать, делать все то же самое для суммы,
ну там, за линией.
То есть, в общем, мы хотим, чтобы у нас была структура данных,
чтобы у нас было все то же самое для суммы,
ну там, за линейный препроцессинг и за от единицы.
Значит, как я уже сказал, для SPARS таблицы это тоже возможно.
Но об этом поговорим как-нибудь потом.
Сейчас давайте обсудим просто некоторые способы оптимизации,
которые можно здесь применить и получить нечто лучшее.
Нелинейное, но с лучшими асимптотиками.
А давайте вернемся к SQLT декомпозиции, внезапно.
Давайте попробуем применить тот же самый метод,
только к вот этой схеме.
Давайте назовем улучшение SPARS табел.
Что мы сделаем?
Давайте, как и в случае SQLT декомпозиции,
разобьем наш массив под массивы размера b.
b мы подберем тоже снова позже,
потому что здесь не факт, что будет тот же самый корень.
Тут b, тут b, тут b, тут b.
И снова посчитаем минимумы.
Ну, минимумы, максимумы, то есть любую операцию,
которую вы хотите.
Считаем минимумы.
И давайте сделаем следующую штуку.
Давайте вот я на вот таком массиве,
то есть этот массив имеет размер n,
этот массив имеет размер n деленное на b,
вот давайте я на этом массиве построю SPARS таблицу.
То есть раньше я строил SPARS таблицу на всем массиве,
а теперь я построю SPARS таблицу на массиве меньшей длины.
Построим SPARS таблицу на массиве меньшей длины.
Чему тогда будет равно время при процессинге?
Вы видите, у меня b пока произвольная, пока нет корня.
Да, nb на лук n деленное на b.
Вот такая симптотипа.
А время запроса?
Чему будет равно время запроса?
Ну как у меня выглядит запрос?
Допустим, мне нужно посчитать минимум вот на таком отрезке.
Да, то есть здесь я посчитаю за единицу.
То есть снова все те отрезки, которые у меня попали в середину,
я их все предпочитаю за единицу.
Ну а здесь по-прежнему я не знаю, что сделаю.
Давайте честно посчитаю.
Снова посчитаю честно.
Что у меня в итоге будет?
У меня в итоге будет у от единицы плюс, возможно, плюс b.
Ну и давайте попробуем подобрать какую-нибудь b.
Что будет, если я возьму в качестве b, в качестве b логарифм?
Если я возьму в качестве b логарифм, то tp от n у меня будет равно чему?
Значит, тут будет n деленное на логарифм, тут тоже будет n деленное на логарифм,
но на логарифм можно тут забить, поэтому тут получится n деленное на логарифм,
умноженное на логарифм n, умноженное на логарифм n.
То есть логарифм, знаменатель логарифм 4 здесь сократятся, получится просто o от n.
Ну а запрос будет за логарифм.
То есть с помощью такого же трюка, как и мы делали в случае эскорты декомпозиции,
я могу улучшить время построения с n лог n до n, но при этом чуть ухудшил время запроса.
Вот.
Хорошо, давайте попробуем что-нибудь сделать еще.
Можно ли тут еще как-то улучшить?
Вот здесь стоит логарифм.
Можно ли мы как-то здесь избавиться от логарифма?
Ну, например, давайте сделаем так.
Давайте построим SPARS таблицу не только здесь, но и на каждом внутреннем подотреске.
Окей?
Давайте попробуем.
SPARS таблицей на каждом подотреске B.
Что у нас получится?
Время построения по-прежнему будет n деленное на B, логарифм n деленное на B,
плюс я строю теперь SPARS таблицы на каждом из этих маленьких подотресках.
Да?
Сколько времени это работает?
Это будет работать n деленное на B умножить на время построения SPARS таблицы здесь.
То есть это B, лог B.
Согласны?
Никто еще не потерялся?
Понятно, что мы делаем.
То есть SPARS таблицу мы уже построили, мы сейчас просто издеваемся над ней,
пытаемся какие-то копейки выжить из нее, пока у нас есть время.
Вот.
Хорошо, значит, это n лог B.
Это относится к маленькому массиву.
Вот к маленькому массиву.
А вот эти B лог B, они относятся к вот этим массивчикам.
Так.
Ну, если все это причисать, то что у нас получится?
У нас получится n деленное на B, лог n деленное на B,
плюс вот эти B сократятся, получится просто n лог B.
N лог B.
Вот.
Но время запроса внезапно станет раундом от единицы.
Почему?
Потому что любой запрос на отрезки, у нас сводится к чему?
У нас сводится к запросу на маленькой SPARS таблице вот этой,
и к двум запросам на SPARS таблицу здесь, и SPARS таблицу здесь.
SPARS таблица делает запрос за единицу, поэтому мы улучшили запрос до единицы.
Улучшили запрос до единицы.
Но это при условии, что у нас в качестве B выступает логарифм n.
Если я сюда подставлю в качестве B логарифм n, то что у меня получится?
Здесь по-прежнему будет n-ка, как и раньше, а здесь зараза возникнет что?
n логарифм логарифма n.
О, n лог n.
Ну вот.
Это максимум, что я могу вам на сегодня предложить.
Есть классическая SPARS таблица, которая работает за n лог n,
которая может быть построена за n лог n, и запросы могут быть обработаны за единицу.
Если у вас много свободного времени, то вы можете эту же SPARS таблицу улучшить до n лог лог n,
ну и при этом оставить асимптотику запроса до единицы.
Вот.
Но опять же повторюсь, в принципе, возможно построить ее из-за линейное время.
Об этом мы как-нибудь поговорим позже.
Вот.
Короче говоря, мораль.
Для задачи статика RMQ, то есть если вам нужно посчитать минимум или любую другую
единопатентную операцию, то пользуйтесь SPARS таблицей.
Вот.
Если у вас операция обратима, то пользуйтесь массивом префиксных сумм.
Ну и, собственно, ключевой момент.
Есть замечательная схема, которая классически называется escort этих композиций,
которая позволяет всевозможный запрос, всевозможные задачи структуру данных ускорить.
И вот пример.
Либо мы ускоряем построение до n, но делаем запрос при этом из алгорифма,
либо просто ускоряем время построения до n лог n.
Вот.
Ну и в этой части остается немного времени.
Давайте к следующей задаче пока переходить не будем.
Давайте еще обсудим один момент.
Поговорим про многомерные задачи.
То есть я думаю понятно, что задачи RMQ и RSCOM уже ставятся не только на, скажем, массиве,
но и на двумерных массивах или на трехмерных массивах.
То есть как они ставятся?
В многомерный случай.
Значит, вам дана матрица, и необходимо уметь читать
уметь читать минимум, максимум или сумму на
вот таких вот под прямоугольниках.
На таких вот под прямоугольниках.
Вопрос вам, понимаете ли вы как, скажем, не знаю, префиксные суммы.
Скажем, мы решаем задачу RSQ.
Понимаете ли вы, как массив префиксных сумм можно адаптировать и для этой конкретной задачи?
Что нужно сделать?
Да, то есть что нужно сделать, чтобы посчитать...
То есть я утверждаю, что мне на самом деле достаточно уметь читать сумму вот на таких прямоугольниках.
То есть мне достаточно посчитать суммы.
То есть мне достаточно уметь быстро и эффективно вычислять суммы,
суммы на прямоугольниках, у которых левый верхний конец находится в точке 0.0.
То есть наверное на таком прямоугольнике, вот на таком прямоугольнике и так далее.
Вот допустим, я такой умею.
Ну и на самом деле массив префиксных сумм ровно это и дело.
Он вычисляет сумму на некоторых префиксах.
Здесь тоже самое, только в качестве префиксов выступают вот такие вот прямоугольнички.
Вот, допустим, мы предпочитали все значения для таких прямоугольников.
Как посчитать значение суммы вот здесь?
Очень просто, да?
Мы должны взять значение суммы здесь, вычесть суммы здесь, вычесть.
То есть воспользоваться такой своеобразной формулой включения исключений.
То есть мне нужно взять большой прямоугольник, потом вычесть вот этот прямоугольник, вычесть вот этот прямоугольник.
В итоге оказалось, что вот эту штуку я вычел два раза, ее нужно еще раз прибавить.
То есть если расписывать в виде формулы, то получается так.
Эта задача сводится к поиску суммы на прямоугольнике, у которого последние координаты равны что-то бъ.
Вычесть значение суммы в прямоугольнике, у которого последний координат находится в xb.
Да, x-1b, точнее yb, x-1b, минус сумма в точке вот этой, это что у нас?
То есть у-1, ну и прибавить вот этот прямоугольник, который мы вычисли два раза.
То есть что это? x-1a-1.
Ну все, если вот это мы все умеем считать за вот единицы, то есть если у нас предпочитаны все суммы на вот таких вот прямоугольниках,
то и значение суммы здесь мы тоже посчитаем за вот единицы.
Идея понятна?
Ну и то же самое можно сделать с задачей rmq.
Идея такая же, то есть тоже можно построить разреженную таблицу на двумерной таблице.
Только в этом случае вам нужно считать t от i, ik, j, l.
Это будет значение минимума на вот таком отрезке от i до i плюс 2 в степени k минус 1 декартового произведения,
с j до j плюс 2 в степени l минус 1.
Ну то есть i и j задают начало прямоугольника, а k и l задают длину по вертикали и длину по горизонтали соответственно.
В этом случае время при процессинге будет естественно nm умноженное на log n, log m.
То есть размер споет к координате n, размер споет к координате m, размер споет к координате log n, размер споет к координате log m.
Ну а ответ на запрос по-прежнему за 1, потому что вы, собственно, ваш произвольный прямоугольник разбиваете на 4 прямоугольника, размеры которых имеют по каждой координате размеры 2 степеника.
Динамика РСК.
Первая динамическая структура данных, то есть напомню, что задача динамического РСК или динамического РМК заключается в том, что вам помимо того, что приходят запросы на изменения,
у нас еще периодически сам массив портится. То есть приходят запросы типа измени вот этот элемент, измени вот этот элемент и так далее.
Тут понятно, что вот те структуры данных, которые мы до этого обсуждали, они, скажем так, не очень гибкие.
Ну скажем, если мы используем массив префиксных сумм, вот этот массив префиксных сумм и есть массив a, то если скажем, даже если мне приходит какой-нибудь маленький запрос на изменение элемента x, то что мне придется сделать?
Мне придется изменить все элементы здесь, потому что, так или иначе, x, вот этот x отрагивает вот эту штуку, вот эту штуку, вот эту штуку и так далее.
То же самое со sparse table. То есть теоретически, если изменить элемент x, то этот x может входить в достаточно большое количество подотрезков.
В такой подотрезок, в такой подотрезок, в такой подотрезок, плюс еще куча других подотрезков, ну и так далее.
В общем, непонятно. То есть, во-первых, нужно найти все эти подотрезки и их как-то изменить. В общем, непонятно, сложно, долго.
Поэтому необходимо придумать какую-нибудь хорошую структуру данных, которая бы позволяла не только выполнять запросы, но и эффективно обновлять.
И вот первая структура данных, про которую мы поговорим, это структура данных, которая называется дерево Фенлика.
Нет, она называется дерево Фенлика по-русски, а в логоизвечной литературе называется binary index tree.
Вот. Как она выглядит? Давайте начнем с идеи.
Идея простая. Идея самого запроса, то есть запроса поиска суммы, она такая же, по сути, как и в префиксах суммах.
Давайте просто возьмем и научимся эффективно считать сумму на префиксах.
Опять же, если мы умеем считать сумму на префиксах, то мы умеем считать сумму на любом подотрезке. Понятно, да?
То есть, если вы AbH-у умеете считать вот такие суммы, то сумму здесь вы тоже умеете считать.
То есть вы посчитали сумму здесь, вычитали сумму здесь, вычили одну из другой, и получили сумму вот здесь.
Давайте поймем, как можно эффективно выполнять сумму на префиксе.
Значит, Фенвик предлагает следующую историю.
Давайте возьмем сумму pi от 0 до r аитах
и разобьем эту сумму на сумму нескольких сумм.
Точнее так, сумму небольшого количества сумм.
Каким образом?
Полагается это делать как-то вот так.
f от r минус 1 и равно f от r минус 1, а и плюс и так далее.
Сумма по i от 0 до f от f...
r минус 1, минус 1, минус 1, минус 1, аитах.
Давайте напишем код.
Мне кажется, так будет понятней.
q i от r выглядит очень просто.
И равное r и больше либо равно 0, и равно f от i минус 1.
Начало в таком цикле.
Тут я записываю сумму.
Изначально равна 0.
А сумма плюс равно ft от i.
Ретерн сам.
Вот эту штуку я сохраню в ячейку с номером r.
Вот эту сумму я сохраню в ячейку с номером f от r минус 1.
Вот эту сумму я сохраню в какую-то другую ячейку.
Грубо говоря, я целиковую сумму разбиваю на сумму вот таких слагаемых.
Где верхняя граница это r, то есть верхняя граница это текущее значение,
а нижняя граница это некоторая функция от r.
Общая идея понятна.
Теперь, что Фенвик предлагает использовать в качестве этой функции f от r?
Утверждается, что если я возьму в качестве функции f от r r амперсант r плюс 1,
то количество этих слагаемых всегда будет логарифмическое.
Давайте поймем почему.
Что делает функция f?
Может что-нибудь понимать на вскидку?
У вас есть число r, и вы делаете следующую вещь.
Берете r плюс 1 и андите с r и r плюс 1.
Давайте посмотрим. Допустим, у меня r равно чему?
Это какое-то начальное число r, дальше 0, и какое-то количество единиц в конце.
В двоичной системе числения.
Пусть у меня r представляется в таком виде.
Что такое r плюс 1?
Я единицу прибавляю к r. Что у меня в итоге получится?
Да, r, 1 и куча нулей.
Точнее, нули в конце.
А теперь я это все андю.
Что у меня в итоге получится?
Что тут везде получится?
Везде получится нули, ну n, побитывая i.
1 и 0 это 0, 1 и 0 это 0 и так далее.
Здесь что получится? 0 и 1 это 0.
А r с волной i, r с волной, что это?
Это то же самое r с волной.
И это f от r.
Вот это исходный r, вот это f от r.
Что сделал f от r?
Просто убрал завершающие единицы.
У меня есть r, у него есть последние единицы.
f от r берет и убирает последние единицы.
То есть ответ
убирает последовательность
младших единиц
в двоичном представлении.
Ну и теперь, на самом деле, должно быть понятно, почему
вот эта функция f от r разбивает мою исходную сумму
налогарифмическое количество под сумм.
Почему это так?
Потому что у меня было число r.
Давайте какой-нибудь пример проведем, чтобы
было наглядно.
Думаете какое-нибудь число r?
Не очень большое, не очень маленькое.
Давайте так, от
от 100 до 500.
100 сколько?
133.
Давайте для простоты представим в виде
суммы 128 плюс
что тут?
Плюс 8. Нет.
Плюс 4 плюс 1.
Ну или это 1,
0, 1.
Вот такое двоичное представление.
Давайте посмотрим,
что такое r.
Что такое отрезок r и f от r?
Значит, отрезок r и f от r это отрезок
от 133
до f от r, f от r что делает?
f от r просто берет и конечную единицу убирает.
То есть я убираю эту единицу, получается число 132.
Все, то есть
f
ft от 133
у меня хранит сумму элементов
от 132 до 133.
Дальше.
Дальше мне нужно посчитать сумму где?
Мне нужно посчитать сумму от 131.
Ну, я тут немного перевернул,
ничего страшного.
Элементы со 133 по 132 я посчитал.
Следующий элемент суммы должен начинаться со 131.
Какое битвое представление имеет 131?
132 имеет такое представление.
Да.
То есть мы убрали вот эту единицу
и вместо этой единицы поставили ноль
и в конце дописали просто две единицы.
Так.
Применяю к этому значению f от r.
Последние единицы убираются.
Что в итоге остается?
2, 3, 4, 5,
2, 3, 4, 5, 6, 7.
Вот.
То есть тут я обращаюсь к элементу ft 131,
которая хранит сумму от
128 до 131.
Вот.
Ну и далее.
127 это просто 7 единиц.
Ну и если я у числа,
которого в двоичном представлении все единицы убираю
и все единицы последние, то остается ноль.
Всё. Таким образом у меня завершается
сумма.
Тут просто сумма от 0 до 127.
Вот.
Идея понятна, да?
Понятна, на какие отрезки у вас разбивает
функция f от r? То есть на очередном шаге
у вас функция f от r
просто берет и откусывает очередную единицу
из двоичного представления.
То есть здесь откусила последнюю единицу, здесь откусила вот эту единицу,
здесь откусила вот эту единицу.
Ну а так у меня в числе длины n.
То есть если у меня массив имеет размер n, то максимальный индекс,
который я могу обратиться, это n.
То есть у меня максимальный логарифм n-бит.
Поэтому количество сумм здесь
у меня логарифмическое.
Согласны?
Ну вот.
Пока ничего, нормально.
Все вот эти рассуждения не могут показаться сложными,
но на самом деле всё, что нужно знать, это
вот эта вещь.
И вот эта формула, всё.
То есть запрос в данной структуре данных
выполняется в три строчки.
То есть мы проходим всё в цикле от r до 0,
обновляем и вот по такому правилу,
и просто добавляем в сумму очередной элемент
дерева Фенлика. Возвращаем сумму.
Работает зал логарифм.
От лога n.
Ну я думаю понятно, как выглядит
запрос на отрезке от l до r.
Запрос на отрезке от l до r
является просто запросом на префиксе r
минус запрос
на префиксе l-1.
Так как каждый из отдельных запросов
логарифм, то и суммарный запрос на отрезке
тоже выполняется зал логарифм.
Вопросы есть?
Теперь переходим к самому интересному.
Первое, а как всё это построить?
Как построить такое дерево Фенлика?
А во-вторых, причём тут обновление?
Как обновлять элементы?
Кажется, мы задачу не упростили.
Что-то придумали, что довольно сложно должно быть обновлять.
На самом деле, я утверждаю, что обновление тоже будет в 3 строчки.
Сейчас мы это увидим.
Для начала обсудим построение.
Построение довольно простое.
Трейс состоит из двух шагов.
Первый шаг.
Строим префиксные суммы P.
Ну, те самые префиксные суммы,
про которые мы на первой половине говорили.
Ну а второе.
Ft от I равно значение префиксной суммы в точке I
минус значение префиксной суммы в точке l-1.
Ft от I минус 1.
Всё.
Это tt от n,
это tt от n. Всё. Построили структуру данных
за линейное время.
Здесь понятно или пояснить?
Ft и t это просто-напросто
сумма по
тежи от
F от I до I,
ожитых.
А чтобы посчитать такую сумму, я беру сумму от 0 до I
и сумму от 0 до F от I минус 1.
Вычитаю, получаю равно то, что можно.
Всё, с построением разобрались.
Ну и обновление в точке.
Хотим
обновить
значение
ai.
Ну что мы хотим сделать? Мы хотим на самом деле
ai сделать плюс равно дельта.
То есть мы хотим взять элемент
i и увеличить его на дельту.
Что нам для этого понадобится?
Что нужно сделать, чтобы у меня вся моя
структура данных обновилась, чтобы она увидела это обновление?
Ну что?
У меня вся моя структура данных состоит из одного
из одного массива Ft. Что мне нужно сделать с массивом Ft?
Что?
Ft и t плюс равно дельта этого не достаточно.
Ну то есть у меня Ft и t действительно в качестве члена содержат
ai и t, поэтому его надо обновить.
Но у меня в принципе ai и t могут содержать и другие члены
Ft и t.
Массив Ft, давайте так.
Формально.
Нужно
обновить
все...
Давайте тут k.
Я хочу обновить окатый.
Нужно обновить все Ft и t
такие, что
окатый,
давайте так грубо скажем, принадлежит
Ft и t.
Согласны?
Ну то есть у меня в массиве Ft и t содержатся какие-то маленькие суммы.
Тут сумма,
Ft0 сумма, Ft1 какая-то сумма, Ft2 какая-то сумма и так далее.
Мне нужно среди всех этих элементов
найти такие, которые содержат внутри себя член окатый.
Да?
Беда, как это сделать?
Можно ли как-то по i
можно ли как-то по i понять
содержится у меня там k или нет?
То есть вопрос, как
по i
понять
нужно обновлять
Ft и t
или нет?
Да.
У меня k должен лежать в пределах
от i
ой, наоборот.
i должен лежать в пределах от k
k должен лежать в пределах от i
до f от i.
Согласны?
Да нет,
у меня же сумма вот такой вид имеет.
То есть если k равно f от i,
то он все еще принадлежит сумме.
Все, и осталось,
я свел задачу обновления к поиску всех таких i-шек,
которые удовлетворяют этому соотношению.
Задача понятна.
Осталось
найти все i
такие что
f от i меньше либо значим k,
и меньше либо значим i.
Вот.
Сейчас мы немного повыводим формул
и в итоге получим что-то очень-очень приятное.
Вот.
Давайте
в виде некоторого вывода оформим.
Будем строить i в порядке
возрастания.
То есть возьмем наименьшее i, которое удовлетворяет этому условию,
потом следующее повелечение i, следующее и так далее.
То есть построим возрастающую последовательность i,
которая удовлетворяет этому соотношению.
План понятен?
Возрастающую
последовательность i.
Давайте эту звездочку обозначим.
Удовлетворяю последовательность, удовлетворяющую,
удовлетворяющих
звездочки.
Ну, погнали.
И нульвое.
Это первый элемент последовательности.
k.
Все согласны, что k это минимальный i, который удовлетворяет этому соотношению.
Ну, если я возьму i меньше, чем k, то у меня вот это
утверждение будет выполнено.
Если возьму i больше, чем k, то если я возьму i равное k, то
естественно вот это будет выполнено, и вот это естественно тоже будет выполнено.
Ну, потому что f от i, да, я этого не сказал, но я думаю это понятно,
что f от r всегда меньше либо равен, чем r.
Ну, операция побитого i не может увеличить число,
потому что там какие-то биты выставляются в ноль.
Новые единицы там не появляются.
Вот, хорошо, и нульвое равное k. Отлично, уже что-то.
Теперь давайте по индукции допустим,
допустим, построили
i с индексом. Ну, какой индекс?
Ну, давайте альфа, не знаю.
Допустим, построили i альфа.
Построим следующий член последовательности,
i альфа плюс один.
Вот сейчас будут содержательные рассуждения.
Ничего не пропустить.
Давайте посмотрим на i альфа.
Как он выглядит?
Ну, посмотрим на двоичное представление числа i альфа.
i альфа выглядит каким-то таким образом.
Ну, во-первых, тут стоит какая-то альфа.
Дальше идет нолик
и куча единиц.
И куча единиц.
И куча единиц.
Ну, не куча единиц, а просто какие-то единицы в конце.
Ну, вы согласны, что любое число i предстоит вот в таком виде?
Какой-то начальный кусок, ноль, и дальше последние единицы.
Ну, произвольное количество. Тут может быть ноль и так далее.
Окей. Что мне известно?
Мне известно, что i альфа больше либо равен, чем k.
А какой вид имеет k?
Нет, давайте так.
Сначала поймем, чему равен f от i альфа в этом случае.
f от i альфа имеет какой вид?
Ну, что делает f от i альфа?
Он просто убирает последние единицы. Согласны?
Поэтому тут тоже самое альфа с волной.
И дальше на всех позициях, которые здесь стояли единицы,
теперь стоят нули.
Кроме того, мне известно, что i альфа лежит в этой последовательности.
Ну, то есть по условиям индукции, по предположениям индукции.
Eles снижают между этими значениями.
Поэтому k имеет вид альфа, с волной, ноль, и здесь что угодно.
ДА?
Ну, согласны, что я тут вместо альфы не могу поставить
никакое число, которое больше, чем альфа с волной.
Потому что иначе оно бы было больше, чем и альфа.
Также вместо альфа с волной, я не могу поставить число, которое меньше альфа с волной,
потому что оно тогда было бы меньше, чем вот это число.
Дальше, здесь обязательно стоит ноль, потому что если бы стояла единица, я бы вышел за пределы и альфа, хорошо, значит тут должен стоять ноль.
Ну а сюда я могу поставить что угодно, неравенство всегда будет выполнено.
Окей.
Ну и осталось теперь понять, точнее осталось найти
наименьший и альфа плюс один
удовлетворяющий звездочки.
Вот давайте попробуем как-то изменить и альфа наиболее, скажем так, наиболее слабым образом, так чтобы это неравенство все еще выполнялось.
Вопрос. Могу ли я изменить что-то внутри альфы?
Ну нет, подождите, не будьте так категоричны. Чисто теоретически могу.
Но чисто теоретически и альфа может измениться так, что тут вместо альфы будут стоять какие-то другие значения.
Ну чисто теоретически. Ну то есть, например, я тут поставил все единицы,
и тогда, когда я буду делать f от и альфы, у меня у альфы какие-то единицы дропнутся, и все еще вот это неравенство будет выполняться.
Ну то есть теоретически альфу я изменить могу, но я пока не хочу этого делать. Почему?
Потому что если я изменю альфу, то это будет какое-то сильное изменение.
Давайте я попробую изменить какие-то младшие биты.
Какой младший бит я могу пока изменить? Ну только вот этот.
То есть попробуем построить вот такую штуку.
Ну то есть вот этот кусок я увеличивать уже никак не могу, поэтому я увеличиваю вот этот кусок.
На вот этот кусок минимально я могу увеличивать вот до вот такой величины. И альфа единица.
Вот. Следующий этап рассуждений.
А может ли случиться так, что у меня где-то здесь будет стоять 0?
Вопрос.
Может ли здесь стоять 0?
Плохо написал.
Мне нужно будет место.
Нет, не может. Давайте пока другие тоже осознайте, почему нет.
Может ли здесь стоять 0?
Почему?
Да. Смотрите, давайте я применю к вот такому и альфа плюс один.
f от и альфа плюс один.
Чему это будет равно?
Что сделает и альфа плюс один?
И альфа плюс один уберет единички отсюда. Согласны?
То есть f от и альфа плюс один будет иметь вид альфа, один, этот нолик останется на месте,
и возможно тут изменятся какие-то там значения. Давайте я просто звездочками обозначу.
А k у меня имеет вид 0, ну и так далее. Все, неравенство не выполняется.
То есть вот этот нолик мешает вот этой f от и альфа поменять вот эту единицу, которая мне не нужна.
Понятно?
Нет.
Так как вот.
То есть вот это неравенство не выполняется.
И что в итоге остается?
В итоге остается, что у меня и альфа плюс один имеет вид альфа, один, и тут все единицы. Понятно?
Ну вот и все. Вы боялись.
Сейчас, почему вот это не выполняется?
Смотрите, давайте еще раз. Это единственный сложный момент.
Смотрите еще раз.
Я пытаюсь сюда поставить единицу.
Теперь, я задаюсь вопросом.
Можно ли сюда куда-нибудь, вот там где стояли раньше единицы, могу ли я сюда куда-нибудь втиснуть ноль?
То есть если я сюда втисну ноль, при этом изменю единицу, у меня все равно и альфа плюс один увеличится.
Я утверждаю, что не могу. Почему? Потому что если я к этой и альфа плюс один применю f, то что сделает f?
f берет и уберет все завершающие единицы, если они тут были.
То есть если тут есть завершающие единицы, f их уберет.
Но при этом дальше f не пойдет. Почему? Потому что она убирает только последовательные единицы.
Все, соответственно тут у меня возможно заменились какие-то единицы.
И f от альфа минус один, и альфа плюс один имеет вот такой вид.
Именно, да. То есть и альфа плюс один имеет такой вид, f от и альфа плюс один имеет вот такой вид, а k имеет вот такой вид.
И поэтому k никак не может быть зажат между ними.
Все, поэтому это меня не устраивает.
И единственное, что меня устраивает, это вот такая вещь. Альфа и дальше куча единиц.
То есть если мне дан какой-то и альфа, то правильным решением, то есть правильным способом получить следующий элемент по величине,
будет просто заменить ближайший ноль справа на единицу. Понятно?
То есть я взял просто первый ноль справа, заменил ее на единицу.
Давайте поймем, почему тут все будет хорошо.
Ну рассмотрим f от и альфа плюс один.
f от и альфа плюс один имеет какой вид?
Он имеет вид.
Вот тут бета, ноль, ноль, и так далее ноль.
Понятно, почему бета?
Ну потому что у этой альфы в свою очередь тоже могли быть какие-то завершающие единицы.
Да, и f их тоже сожрет.
То есть ну в любом случае b с волной меньше либо равно, чем i с волной.
Ой, альфа с волной.
Этот момент понятен, да?
Ну не обязательно, если альфа завершается нулем, то тогда...
Ну то есть если в качестве альфа я возьму один ноль, то тут по-прежнему останется один ноль.
Короче, и альфа плюс один имеет такой вид.
f от и альфа плюс один имеет вид такой.
f сожирает все единицы, и возможно что-то отжирает от альфы.
Ну поэтому тут бета, которая меньше либо равно, чем альфа.
Ну а k у меня по-прежнему имеет тот же самый вид.
Ну k я никак не изменяю.
k мне дано откуда-то сверху.
Не равенство по-прежнему выполняются.
Согласны?
Ну вот это i больше, чем k, и вот это k больше, чем альфа.
Ну вот это i больше, чем k, и вот это k больше, чем fk.
Ну почему? Потому что альфа больше либо равно, чем бета.
Задайте вопросы.
Ну и все, теперь катарсис.
Plo есть.
и альфа плюс один равно…
И вот вопрос вам.
Что это за такая функция, которая берет и альфа,
и вместо последнего нуля выставляет единицы?
А можно勝ить?
А можно выиграть?
А можно выиграть?
А можно быть львовым?
А можно сломать?
А можно선 сломать?
А можно들을 сломать?
А можноboards сломать?
А можноы сломать?
И вместо последнего нуля выставляет единицу.
Ну, давайте в терминах битовых операций.
О, и альфа, или и альфа плюс один.
А напомните, как у нас была функция f изначально?
Все.
То есть мораль.
Когда мы выполняем запрос суммы, мы пользуемся вот такой формулой.
Когда мы используем запрос обновления, мы пользуемся вот такой формулой.
Все.
Чтобы научиться писать дерево Фенга, достаточно запомнить эти две формулы.
Ну то есть, вывод сложный, а сама структура данных простая.
Давайте напишем функцию update, ну и восстановим функцию query, чтобы вы убедились.
Можете засечь, за сколько у меня это получится.
Так, update.
Значит, я обновляю i, элемент i на дельту.
Что мне нужно сделать?
Мне нужно взять i.
Делать в к, в точке к мы обновляем.
i равное k.
И пока i меньше чем n, делать i равно i, или i плюс один.
Да, ну то есть мы вывели формулу, чтобы получить по возрастающую последовательность i,
возрастающую последовательность индексов, которые мне нужно обновить, она должна иметь следующий вид.
Первый член это k, а следующий член я получаю вот по той формуле.
Все.
И что я должен сделать?
Просто взять iто-элемент дерева Фенлика и увеличить его на дельту.
Все.
Update закончен.
Query.
Query на префиксе.
В префиксе for i равное r, i больше либо равно, чем ноль, i равно i and i плюс один.
Ну и тут минус один еще добавляется.
Да, опять забыл.
Переменная, в которой мы будем сохранять сумму, sum плюс равно FTI.
Return sum.
Сколько там?
В пять минут вкладываешь?
Так, давайте последний.
Query на отрезке от L до R.
Просто return q от R минус q от R.
Время.
Все.
А вот это все дерево Фенлика.
Все.
Ну хорошо, там еще есть построение, но в принципе построение как может выглядеть?
То есть если вам в лом писать то построение, то вы можете построить построение как просто апдейты.
Просто апдейт ноль, апдейт один, апдейт два, апдейт три и так далее.
Вот это весь код дерева Фенлика вообще.
Где?
Блин, ладно.
Ну ладно, со штрафом сдал, все.
Ладно, давайте проверим баги.
Первый член тк.
Следующий член последовательности получаю вот так.
Значит i член массива FTI увеличиваю здесь.
Дальше беру R, считаю FTI, дальше перехожу к этому элементу.
Ну кажется не набагал.
Все нормально.
Значит про этот кьюри мы поговорили, он работает за log n.
Соответственно этот кьюри тоже работает за log n.
Абдейт.
За сколько работает апдейт?
За логарифм.
А почему за логарифм?
Да, да.
Что делает эта функция?
Она просто завершит последний ноль, самый младший ноль,
и заменяет его на единицу.
Сколько раз я могу добавить единицу?
Ну не больше, чем логарифм n раз.
Потому что если я добавлю больше, чем n раз, то логарифм n раз,
то я выйду за границу массива.
Это тоже логарифм.
Вот такая история.
Вот это?
А почему нет?
Вы верите, вот это работает за логарифм?
Следовательно, вот это логарифм, вот это логарифм.
Так.
Вопросы есть?
Ну и давайте итог промежуточный подведем.
В общем, дерево фенвик, оно крутое.
И оно крутое тем, что его очень быстро писать,
и оно умеет выполнять обновления в точке.
Ну по сравнению с массивом префиксных сумм.
Итак, итог.
Временно при процессинг.
За сколько мы можем построить дерево фенвика?
За сколько?
За o от n.
Ну за log n мы не можем построить,
потому что у нас всего элементов n.
Построение за o от n вот с помощью вот такой функции.
Ну либо, давайте напишем,
либо n log n,
ну если используем следующий код,
for i равно 0, to n-1,
update i.
В принципе, если в лом писать то,
то можно написать вот так.
Это будет работать тогда за n log n.
Окей?
Ну то есть, понятное дело,
инициализируем массив нулями изначально.
Изначально зануляем массив,
а потом просто последовательно каждому элементу добавляем ai.
Ну и запрос, причем неважно какой,
запрос на обновление, запрос на сумму
выполняется за o.
O от log n.
Так, давайте немного отдохнем от кода,
немного отдохнем от кода и от формул,
и просто приведем, скажем, пример работы операции
на дереве Фенвика, ну чтобы как бы убедиться,
что все понимают, как все устроено,
как это работает и так далее.
Давайте, похоже на поле чудес, но нет,
давайте загадаем числа какие-нибудь,
чтобы можно было над ними операции какие-то проводить.
Давайте заполним массив a.
Я жду.
15,
4,
минус 7,
нет,
49 просто,
49, 3, что еще?
Ноль, нормально.
17,
25,
11,
1,
нормально.
Ну и заполним массив дерева Фенвика.
Я сразу тут записал индексы в двоичном формате,
чтобы было удобнее.
В дереве Фенвика с индексом ноль, что хранится?
В нем хранится сумма с верхней границей ноль,
и с нижней границей убираем все последние единицы,
соответственно только 15 остается, да?
То есть сумма от нуля до нуля.
Здесь,
здесь хранится сумма с первого элемента
по элементу,
у которого все последние единицы за нулены.
То есть,
с нулевого по первой, согласны?
То есть 19.
Здесь хранится сумма всех элементов
с 2, ну то есть с 1, 0,
до элемента, у которого все последние единицы за нулены.
Ну это то же самое число, да, то есть,
от 2 до 2,
минус 7.
Что хранится здесь?
Здесь хранится сумма
от элемента с индексом 3,
ну то есть 1, 1,
до элемента, у которого все последние единицы за нулены,
то есть ноль.
То есть все единицы убираем, остается ноль.
42, 46, 61, да?
Так, здесь, здесь хранится сумма
от 4 до 4.
Тоже понятно, да?
Здесь тоже последние единицы,
никаких единиц нет, поэтому
сумма от этого элемента до него самого,
то есть 3.
Дальше, берем этот элемент,
1, 0, 1, то есть это 5,
и нижняя граница убираем последние единицы,
то есть 4.
То есть ноль плюс 3, 3.
Дальше, здесь
тоже последние единицы знулять не надо,
поэтому тут просто 6, 6, да?
17.
Ну и на самом деле легко заметить,
что для всех четных это выполняется.
То есть для всех четных у меня
в дереве Фенвика соответствующие ячейки хранится,
ну просто-напросто это самое число.
А здесь, здесь что у меня хранится?
Здесь у меня хранится все значения от 8 до нуля.
Да, почему?
От семерки, простите.
Потому что 3 единиц это 7,
убираю все последние единицы, остается ноль,
поэтому тут лежит сумма с нулевого по седьмой элемент.
Сколько?
Отлично.
Поверим?
Ну ладно.
103.
Если что, это не я.
Дальше.
Ну и здесь просто-напросто с девятки
убираем последнюю единицу в 8.
То есть 12.
Все, то есть дерево Фенвика представляет из себя вот такой массив.
Вот.
А я чувствую.
Отлично.
Так, а теперь давайте попробуем выполнять какие-то запросы.
Давайте какую-нибудь пару запросов рассмотрим.
Ну давайте, какие-нибудь два произвольных числа.
Два произвольных индекса.
Стройки по четверку.
Отлично.
Стройки по четверку.
Значит это все мы раскладываем в виде запроса от четверки.
Да, то есть давайте сразу представим это в двоичном виде.
Что такое кьюри от четверки?
Как вычисляется кьюри от четверки?
Мы берем Ft от четверки.
Что это?
Ft от четверки 0, 1, 2, 3, 4.
Это 3.
Дальше мы берем Ft от...
Убираем последнюю единицу.
Сейчас, нет.
Как выглядит формула?
Мы берем 1, 0, 0.
Андимся 1, 0, 1.
0, 0, 1.
И вычитаем единицу.
Получается 1, 1.
То есть 3.
Ft от тройки 0, 1, 2, 3.
Это 61.
Ну и все.
Да?
Еще раз, что мы сделали?
Мы обратились Ft от четверки.
Мы ее записали здесь.
Дальше обратились сюда.
Здесь хранится сумма от 0 до 3.
Все, значит, все элементы мы покрыли таким образом.
Все, в итоге 64.
Но это только полдела.
Теперь давайте кьюри от тройки посчитаем.
Ну а кьюри от тройки мы, кажется, уже посчитали, да?
Кьюри от тройки это просто-напросто Ft от тройки.
Ну, то есть 61.
Да, то есть 61.
Сейчас.
Нам нужно кьюри от двойки.
Понятно почему кьюри от двойки?
Мы хотим найти сумму от третьего 0, 1, 2, 3.
От третьего до четвертого.
То есть нам нужно посчитать сумму вот здесь и вычесть сумму вот здесь.
То есть кьюри от двойки.
Ft от двойки.
Ft от двойки это минус 7.
Вот.
То есть здесь хранится значение от 2 до 2.
Поэтому переходим сюда.
Тут хранится значение от 0 до 1.
То есть то, что нам нужно.
Поэтому считаем Ft от единицы.
Получаем 19.
В итоге сумма равна здесь 12, а здесь 64.
Ну и осталось вычесть.
Да.
В кьюри от 4 минус кьюри от 2 равно 52.
Сошлось?
Сошлось, нет?
Отлично.
Так, хорошо.
Давайте дальше.
Сейчас.
Да, все нормально.
Я сюда смотрел.
Да, все.
Значит кьюри от 3 до 4.
49 плюс 3.
52.
Еще кьюри или апдейт?
Да, давайте апдейт.
Какой апдейт?
Какой элемент хотим изменить?
Вот этот?
На что?
На 57.
Ну давайте как обозначим?
Пишем 57.
То есть пишем апдейт в точке 2 на...
Вот тут надо...
То есть если мы хотим изменить минус 7 на 57...
Сейчас, что вы имели в виду на 57?
Мы хотим заменить его на 57 или прибавить 57?
Заменить.
Значит мы должны прибавить 64.
Вот.
То есть апдейт выглядит как плюс равно.
То есть мы в точке делаем именно плюс равно, а не присваивание.
Так.
Что такое апдейт?
Апдейт это значит нам нужно найти все эти ft, на которые влияет этот элемент.
Ну соответственно и 0 это что у нас?
Это 2.
И 1 это и 0 или и 0 плюс 1.
То есть если 2 это 1, 0.
Убираем последнюю единицу.
Ну то есть 0.
Сейчас.
1, 1.
1, 1 просто.
Да?
Дальше.
И 2 это и 1 или и 1 плюс 1.
То есть 1, 1, 1.
3.
7.
Следующую единицу не добавляем, потому что выходим за границы.
Поэтому вот.
Вот эти три индекса, которые нам нужно обновить.
Ну давайте попробуем понять, действительно мы сделали то, что нужно или нет.
Значит какие у нас элементы дерева Фенвика отвечают за, точнее в какие элементы дерева Фенвика входит индекс 2?
Значит вот сюда.
То есть это 2 есть сюда.
То есть это 3 есть.
Дальше, дальше, дальше здесь.
Это 7.
Есть и все.
То есть все индексы нашли правильно.
Ну все осталось только все вот эти элементы, которые нашли, обновить.
Вот собственно как здесь и написано.
Все эти элементы, все эти элементы мы нашли, осталось их только обновить на плюс равно дельту.
А дельта у нас 64.
Ну то есть здесь 57.
Дальше.
Здесь плюс 64 это 125.
И здесь 64 плюс 106, 170.
Ну вот.
Похоже на правду?
Ну давайте проверим.
Допустим, допустим здесь.
Верно лишь, что сумма всех значений от 0 до 3 это 125.
15, 19, 67, 76, плюс 49, 119, 125.
Все нормально.
Окей?
Ну вот.
Дерево Фенвика оно по сути таким образом разбивает все отрезки на логарифмическое...
То есть каждую сумму разбивает на логарифмическое.
То есть, во-первых, оно разбивает каждую сумму на логарифмическое число под сумм,
а во-вторых, каждая, а во-вторых, каждая из элементов,
что самое главное, каждая из элементов,
входит всего лишь в логарифмическое число элементов дерева Фенвика.
То есть, чтобы собрать сумму на подотрезке, достаточно обратить внимание.
дерева фенвика. То есть чтобы собрать сумму на подотреске, достаточно обратиться к
логарифмическому числу здесь, и чтобы вновить элемент здесь, достаточно обратиться к
логарифмическому числу объектов здесь. Все отлично. Нужен еще какой-нибудь пример, или достаточно?
Ну, значит достаточно, окей. Так, следующий пункт, короткий. Это, мы когда говорили про
разреженную таблицу и про массив префикса суммы, говорили, что там нужно как бы вести
некоторую двумерную структуру. То есть если мы хотим обобщить на многомерный случай, то там
нужно как бы обобщить все на, ну скажем, завести двумерную таблицу, двумерную разреженную таблицу
и так далее. В общем, там как-то хитрым образом снова вычислять значения в соответствующих
ячейках. Еще одна классная вещь, которая связана с деревом фенвика, состоит в том, что дерево
фенвика очень просто обобщается на многомерный случай. То есть буквально, чтобы написать дерево
фенвика для двумерного случая, мне достаточно изменить, точнее дописать здесь три строчки. Давайте
поймем как. Обобщение на многомерный случай. Ну идея такая же. Если мне нужно посчитать
сумму от i равная нулю, ну скажем давайте до х, сумма по g от нуля до y, а и g, то это все разбивается на вот
такие вот маленькие суммы. То есть это сумма по i равная f от x, от x сумма по g равная f от y, y, а и g, ну и так далее.
Ну а это не что иное, как значение дерева фенвика в точке x, y. Вот, и при этом все вот эти вот нижние
индексы, они получаются ровно по той же самой формуле. Вот, поэтому если я хочу написать, например, запрос,
давайте напишем запрос, для двумерного дерева фенвика, то как это выглядит? Я пишу кьюри от x, y, ну то есть я хочу
посчитать сумму, что такое кьюри от x, y? Значит, я хочу посчитать сумму вот здесь. Я хочу посчитать сумму в
прямоугольнике, у которого левый угол находится в точке 0, 0, а правый нижний угол в точке x, y. Тогда кьюри от x, y
выглядит вот так. Просто for i равно x, i больше либо равно нуля, i равно i plus 1, minus 1. Дальше внутренний цикл for g
равно y, g больше либо равно нуля, g равно g plus 1, minus 1. Снова забыл сумму, отлично, sum равно нулю, sum
плюс равно ft от i g. Return sum. Все. Ну как и раньше, потому что вот этот элемент дерева фенвика у меня считает
сумму от x до f от x, поэтому следующий элемент суммы должен начинаться с f от x минус 1. Да, ну то есть
заметьте, f минус 1 всегда была, то есть и здесь, а здесь ее нет. Ну то есть чтобы обобщить дерево
фенвика на двумерный случай, мне достаточно всего лишь добавить один цикл, ну и одну размерность у дерева
фенвика. Все. Хотите подумать над тем, что он сделал, чтобы обобщить его на трехмерный случай? Добавляйте
и да, добавляйте еще один цикл вот точно такого же рода. Чуть сложнее выглядит, если вы хотите
посчитать запрос на, если вы хотите посчитать запрос не на вот таком префексе, а скажем вот на такой, ну давайте вот так, x, y, a, b. Вот если вы хотите
посчитать сумму вот на таком прямоугольнике, то снова придется воспользоваться формулой включения
исключений. Да, ну то есть понимаете. Давайте еще раз напишем, лишнего не будет, значит это то же самое,
что кьюери на прямоугольнике x, y, вот на таком большом треугольнике x, y. Дальше я должен вычесть сумму
вот здесь. Это что у нас? Это минус q, x, b-1. Минус, должен вычесть сумму вот здесь. Это q, так почему x, y? Потому что x, y, x, b-1, да и тут
a-1, y и плюс q, да и плюс вот этот вот маленький квадратик, я вычел два раза. То есть прибавил один раз и вычел два раза, поэтому мне нужно, чтобы выйти в ноль, нужно прибавить его еще раз.
Вот. То есть q от a-1, b-1. Ну вот. Ну в трехмерном случае, соответственно, тут будет 8 слагаемых, то есть подумать, как в кубе выделить нужный параллелепипед.
Вот. Ну тоже самая форма включения и исключения. То есть это на самом деле можно обобщить на произвольную размерность. Вот. Ну и апдейт. А с апдейтом, ну давайте не будем останавливаться тоже долго.
Апдейт тоже понятно. То есть для апдейта тоже добавляете еще один цикл, ну наподобие того, что был написан там, и получаете апдейт для двумерного случая. То есть если вы хотите обновить в двумерной таблице какой-то один элемент, то вы передаете ему два индекса
и проходите по одному индексу вот так, по второму индексу вот так, и внутри изменяете элемент ft и g. Все. Рассуждения абсолютно точно такие же. То есть дерево фенвика, оно позволяет очень легко обобщать себя на произвольной размерности.
Вот. Поэтому для задачи динамика rsq дерево фенвика это вот то, что нужно и быстро, и эффективно. Ну и в качестве последнего пункта давайте рассмотрим некоторое обобщение дерева фенвика, точнее не обобщение, а некоторое улучшение дерева фенвика.
Попробуем добавить ему некоторый новый функционал. Ну смотрите, прибавление в точке, конечно, хорошо. То есть вот у вас есть массив, вы можете обрабатывать запросы, найти сумму на произвольном отрезке, и плюс можете обновлять произвольный элемент.
Вот. Но часто бывает такая ситуация, что вам нужно обновить значение не только в одной точке, то есть не просто в одной точке, а нужно, скажем, обновить сразу группу элементов.
Скажем, вам нужно обновить все элементы с третьего по шестой. Ну точнее так, взять элементы с третьего по шестой и всем им прибавить, скажем, единицу, или всем им прибавить 17, и так далее.
Значит, подробнее про то, как обрабатываются такие запросы мы поговорим в следующий раз, то есть в следующий раз мы будем говорить про групповые обновления, то есть что делать, если вам нужно обновлять на целых отрезках и так далее.
Сегодня я расскажу просто небольшой трюк, какой-то подвид этой задачи можно сделать с помощью дерева Фенлика.
Значит, задача научить дерева Фенлика выполнять операцию прибавления на отрезке.
Ну, как это сделать в тупую, на самом деле понятно. То есть если вам нужно обновить все значения на отрезке, то вы просто обновляете этот элемент, этот элемент, этот элемент, этот элемент.
Работает за калоген, где k – это размер под отрезок, который вам нужно улучшить. Можно ли лучше? На самом деле можно. Можно, если воспользоваться следующим трюком.
Давайте рассмотрим, нам дан массив А, а мы перейдем к другому массиву.
Будем рассматривать не исходный массив А, а возьмем массив В, который имеет следующий вид.
А0, А1-А0, А2-А1 и так далее, An-1-An-2.
То есть просто почитаем по парной разности всех элементов А и запишем в массив В.
Для чего это нужно? Смотрите, ключевой вопрос зачем.
А затем прибавим, прибавим, прибавим дельту, давайте так, прибавим, прибавим дельту на префиксе от 0 до r.
Не так, на суффиксе. Вот у меня есть массив А.
Давайте я покажу, как прибавлять дельту на суффиксе, то есть на концевой части массива.
Согласны ли вы, что если я умею эффективно добавлять дельту на суффиксе, то я могу добавлять дельту на произвольном подотреске.
Почему? Потому что если я хочу прибавить дельту сюда, то я могу прибавить дельту вот на этом отрезке и вычесть дельту отсюда.
Тоже самый трюк. Хочу прибавить дельту здесь, для этого мне нужно прибавить дельту здесь и вычесть дельту здесь.
Поэтому давайте посмотрим, что у меня происходит с массивом B, когда я прибавляю дельту на суффиксе от r до n-1.
А происходит вот что. А 0 меняется? Не меняется. А 1-0 меняется? Не меняется.
Какой первый элемент у меня изменится в этом массиве?
Да. ar-ar-1. Он увеличится на дельту. Согласны? Ну, r-1 у меня не изменился, а r у меня увеличился на дельту.
Как у меня изменится ar-1-ar? А вот никак.
Потому что если я дельту прибавляю на суффиксе, то эта дельта у меня прибавляется как к k-r, так и к k-r-1.
И так далее. То есть an-1-an-2 тоже не меняется, потому что на дельту у меня изменился как этот элемент, так и этот элемент.
Понимаете, к чему я клоню? Я клоню к тому, что если я прибавляю дельту на всем подотреске, на всем суффиксе массива A,
то это то же самое, как если бы в массив D использовать обновление всего лишь одного элемента.
То есть я свел задачу обновления на суффиксе к задаче обновления на одном элементе.
Но правда в каком-то другом массиве B.
Все понятно? Ну и давайте посмотрим, как с этим массивом B работать.
Допустим, мне нужно найти сумму на вот таком префиксе, i от 0 до r, ai.
Как бы мне переписать эту сумму в терминах массива B? То есть массива A у меня нет, у меня есть только массив B.
Вот как мне расписать эту сумму? Ну очень просто, i от 0 до r.
А что такое ai? Как получить ai из массива B?
Ну я утверждаю на самом деле, что эта сумма от k равна 0 до i.
Вот эта штука это в точности ai. Согласны?
Ну вот я прибавляю a0, потом a1-a0, то есть a0 и a0 сокращаются, получается a1.
Дальше a1 плюс a2 минус a1, получается a2, ну и так далее.
Так, ну и давайте это попробуем как-то представить.
Как-то представить в каком-нибудь хорошем виде.
Вот это есть сумма у k от 0 до r, bk умноженное на, я хочу понять, сколько раз у меня в сумме встречается bk.
Давайте попробуем понять.
Ну смотрите, если у меня i равно 0, то что у меня получается?
Просто b0, да?
Если у меня i равно 1, то сколько тут элементов в сумме?
b0 и b1.
Значит, когда i равно 2, то у меня 0, 1 и 2, ну и так далее.
То есть сколько всего b0-иков у меня?
r плюс 1.
Да, всего 0-иков у меня r плюс 1.
Сколько всего b первых? r плюс 1 минус 1.
Сколько всего b вторых? r плюс 1 минус 2 и так далее.
То есть количество элементов bk, которые встречаются в этой сумме, оно равно вот такому количеству.
Поэтому эту сумму я могу переписать просто вот так.
Согласны?
Ну все, остался последний штрих.
Если мы смесим 1 плюс r, то будет сумма bk от 0 до r, bk минус сумма k, bk равно 0 до r.
Все.
Что мы получили?
А получили ли мы следующее? Мы свели задачу поиска суммы на массиве a к поиску суммы на массиве b.
Смотрите, раньше у меня был только a, сейчас есть массив b.
То же самое. То есть тут от 0 до r, тут тоже от 0 до r.
И плюс сумма на префиксе вот для такого массива.
То есть нужно уметь считать суммы на b и на массиве b штрих, который равен чему?
0, 1 на b первое, 2 на b второе, и так далее.
n минус 1, bn минус 1.
Все. То есть я строю еще раз заново.
Что я хотел?
Я хочу сделать массив и научиться выполнять на нем операцию поиска суммы и операцию добавления элемента.
Как выглядит операция поиска суммы?
Операция поиска суммы на префиксе сводится к операции поиска суммы на массиве bk.
То есть я считаю сумму на bk и умножаю на 1 плюс r.
И я считаю сумму на вот таком массиве.
Можно считать, что это некоторый массив b штрих a.
Я вычитаю сумму на массиве b, на массиве b штрих, и вычитаю одну из другого.
Все таким образом я нашел сумму на префиксе для массива a.
Это делается за log n, так как b и b штрих храним в дереве Фенрика.
Вот этот первый пункт.
Второй пункт обновления на суффиксе от r до n-1.
Что для этого нужно сделать?
Нужно всего лишь обновить b в точке r на дельту.
То есть обновление на суффиксе на дельту.
И обновить b штрих в точке r на дельту, умноженное на r.
Ну почему мы b обновляем на дельту?
Мы это обсуждали.
Почему b штрих я должен обновить на r дельту?
Потому что в массиве b штрих у меня хранятся не просто b, а 1 умножить на b1, 2 умножить на b2 и так далее.
Поэтому если я обновляю какой-то b r, то сам b штрих мне нужно обновить на сколько?
Ну как раз таки на r умножить на дельту.
Ну давайте пример проведем, чтобы все встало на свои места.
Давайте какой-нибудь короткий массив.
Давайте просто 0, 1, 2, 3, 4.
Что мы делаем? Мы по этому массиву строим массив b.
Этот массив в качестве первого элемента берет a0, в качестве второго элемента берет разность a1 и a0,
то есть 1, дальше берет разность вот этой штуки, ну и так далее.
То есть просто хранит последовательную разность всех элементов.
Вот этой штуке мы строим дерево Федрика.
Дальше строим b штрих, 0, 1, 2, 3, 4,
который строится вот по такому правилу.
Первый элемент 0, второй элемент 1 умножить на b1, то есть 1 умножить на 1,
дальше 2 умножить на 1, 3 умножить на 1, 4 умножить на 1.
Строим по нему дерево Федрика.
Ну и теперь что? Я хочу найти сумму, скажем, на отрезке,
ну на каком отрезке? Давайте от единицы до четверки.
Что я делаю? Давайте я сначала посчитаю сумму на префиксе от 0 до 4.
Сначала я должен посчитать сумму на префиксе для b.
То есть сумма для b, чему равна?
Равна 4.
И еще я должен посчитать сумму для b штрих.
Тоже на том же самом префиксе.
Для b штрих от 0 до 4 равна 10.
Все, ну и теперь я должен взять
первый элемент с весом 1 на r,
а второй элемент с весом минус 1.
То есть я должен взять эту сумму умножить на 1 плюс r,
вторую сумму умножить на минус 1.
В итоге у меня получается что?
r у меня равно 4, то есть 4 на 4-16,
минус 10-6.
Все, нашли ответ.
То есть сумма от 0 до 4 равна?
Тут 5 должно быть, да.
Ну r это 4, поэтому 1 плюс r это 5.
Ну действительно, сумма от 0 до 4 это 10.
Ну и дальше считаем сумму на отрезке от 0 до 1.
Снова, чтобы посчитать сумму на отрезке от 0 до 1,
мне нужно посчитать сумму для b от 0 до 1.
Вот здесь, это 1.
И посчитать сумму для b штрих от 0 до 1.
Это тоже 1.
Дальше первую штуку я должен умножить на 1 на r,
вторую штуку должен умножить на минус 1.
В итоге что получается?
r равно 1, поэтому 1 плюс 1 это 2.
Ну и минус 1,
сейчас нет, просто минус 1, равно 1.
Ну действительно, сумма от 0 до 1 это 1.
Поэтому просто сумма отрезки от 1 до 4 это 10.
Минус 1 равно 9.
Похоже на правду?
Простите.
Тут нужно считать сумму на отрезке от 0 до 0.
Потому что если мы хотим найти сумму от 1 до 4,
то нам нужно посчитать сумму от 0 до 4
на отрезке,
а потом вычесть нулевой элемент.
Тут понятно, тут везде будет 0,
то есть то же самое не буду проделать,
тут просто будет 0,
поэтому сумма это просто 10.
Ну и давайте обновление тоже выполним.
Мне приходит обновление,
я говорю, что мне нужно обновить
элементы вот эти на плюс 2.
Что я делаю?
Что мне нужно сделать, чтобы обновить
вот этот подотрезок на плюс 2?
Мне нужно все вот это обновить на плюс 2,
а потом вот это обновить на минус 2.
Согласны?
Как выглядит обновление здесь на плюс 2?
Очень просто, вот этот элемент я должен
увеличить на 2.
Вот.
И вот этот элемент я должен обновить на
2 умножить на 2, то есть 4.
Все, с этим обновлением разбрались,
теперь вот это обновление на минус 2.
Ну что я должен сделать?
Здесь минус 2, и здесь минус 2 умножить на 4,
то есть минус 8.
Все.
Короче говоря, мораль,
если я хочу, чтобы у меня работали
обновления не только в одном элементе,
но и на подотрезках,
я должен перейти от массива A к 2 массивам.
Массиву B,
которая хранит последовательные разницы элементов,
и массиву B штрих,
который массив B умножает на,
то есть каждый элемент умножает на соответствующий индекс.
Вот.
Тогда запрос суммы выглядит как?
Вы считаете сумму на B,
умножаете на 1 плюс R.
Вы считаете сумму на B штрих,
и вы читаете.
Все, это запрос суммы на отрезке.
Как выглядит запрос обновления?
Запрос обновлений выглядит просто.
Если вы хотите обновить на отрезке,
то вы обновляете на таком суффиксе,
и обновляете на таком суффиксе.
Но обновление на таком суффиксе,
и таком суффиксе, оно выглядит просто.
Вы просто обновляете один элемент здесь,
один элемент здесь,
и один элемент здесь,
и один элемент здесь.
Все.
Ну вроде уложили.
Короче, давайте подведем небольшой итог.
То есть у нас сегодня было времени много, поэтому мы рассмотрели много структур данных.
Давайте краткое резюме о том, что важно на практике.
Важно помнить, что если вам дана задача статик rsk, то есть просто нужно находить сумму на всевозможных адресках,
то просто используй массив префиксных сумм.
Если мы хотим решать задачу статик rsk, то есть искать минимумы, максимумы, наибольший общеделитель на адресках,
то мы используем разреженную таблицу, тоже писали.
Если вам нужна задача динамика rsk, и при этом у вас обновление только в одной точке,
то есть если вас интересует обновление только в одной точке, то вам приходит запрос с виду найти сумму на таком-то отрезке
и обновить, скажем, это элемент, то тогда мы пишем дерево фенлика.
Если вам нужно что-то более сложное, то мы используем не эту штуку, а то, чтобы пройдем в следующий раз.
Это просто чтобы себя повеслить.
Все, спасибо, до следующего раза.
