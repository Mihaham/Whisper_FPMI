при образовании фуге на уровне слышал такое слово сочетание так кто знает о чем он вообще так ну да
так так так рекурсивный рекурсивный это правда ну чтобы разобраться чуть такое ладно
значит поехали ну собственно хедлайнерам ближайших нескольких лекций у нас будет метод разделяй
властвуй вот на нем будет основано все вот хотя формально говоря тема у нас называется длинная
арифметика да вот именно об этом мы и будем а как же больше чем ты думаешь с нее и начнем
можно сказать и так ладно давайте попроще вопрос кто когда-нибудь в жизни писал длинную арифметику
так ага не но хотя бы вот на уровне сложение вычитания а кто когда-нибудь писал умножение
длинных чисел так а умножение длинных чисел быстрее чем закуп
кто умножает умножать числа длины n быстрее чем закуп умеешь
но я имею в виду крыша они-то это да спасибо да отлично давайте все проснулись молодцы вот так
хорошо а кто умеет писать длинное деление быстрее чем закуп даже лоб квадрат окей а залог так окей
а длинное деление чего а длинных многочленов ну ладно но соответственно давайте вспоминать и так
но о чем у нас речь да как мы с вами знаем действительно у нас к сожалению лонг-лонг даже
лонг-лонг он хранит только маленькие числа ну маленькие по количеству знаков конечно они
по величине вот но тем не менее но вот но иногда очень хочется работать чуть-чуть более длинными
числами например длина 100 тысяч или даже 100 тысяч что в таких случаях мы можем сделать ну конечно
же самый простой метод который у нас возникает есть у нас есть какие-то числа это 4 2 3 4 но не настолько не
настолько вот вот но соответственно как хранить такое число вот но то соответственно его можно
конечно загнать вектор там хранить скажем по одной циферке в чем обычно с млад начинает с младших
разрядов то есть поэтому там как бы самый простой версии там этот вектор будет выглядеть вот
примерно вот таким вот образом так 2 там 5 8 9 8 там 7 9 6 там 9 но и так но и так далее не
будут но не знаю по вам наоборот так вот тем более шерек до конца не дописывает не важно вот
значит данном случае так вот вот ну тогда мы понимать до такое число можно хранить за от его
длины и с ним уже можно делать какие-то операции вот у меня если вы хотите сложить два вот таких
длинных числа ну вот то это легко сделать за от их длины ну там формально говоря за от максимума
от их длин там плюс один ну просто складывая просто числа столбиком вот складывали так
кто когда-нибудь складывал числа столбиком ну нет ну мало ли знаете там это школьное
образование меняется может там сейчас считают что это во втором классе это делать не надо там
я не знаю нет нет ну почему нет но сумоки вот но действительно то есть как вы это понятно но
собственно вы все это сразу поэтому понимаете что реализовать это достаточно несложно ну и
вычитание тоже конечно несложно тоже за линию реализовать вот но вот но конечно оно вот это
все делается за линию вот но есть конечно более сложной операции умножение умножать тоже мы
обычно очень любим умножать нот умножать столбиком вот но правда конечно вы замечаем
что стандартный метод умножения это делать все-таки за квадрат да ну пока столбиком действительно
получается вот но правда конечно это уже бывает многовато какие оптимизации тут возможно но
самая простая оптимизация на самом деле заключается в том же что а кто сказал что в каждом разряде нужно
хранить по одной цифре вообще то есть ведь на самом деле то можно то есть как бы мы храним по одной
цифре потому что у нас основание системы счастливее 10 но с другой стороны почему бы нам не сделать
основание стиму 4 век 10 тысяч ну что к чему нас это приведет это нас придет потому что число
будет храниться то есть уже по 4 цифра в ячейке то есть в одном инте то есть получится там скажем тут
485 ну подразумевает тут какой-то 0 значит тут что будет две там 8 520 будет да что-то еще будет
9 789 ну и так далее вот можно там по 4 вот да это но это операция конечно не не симпатически оптимизирует
вот нету что повезет просто это это как бы она оптимизирует константу раз другой стороны когда
в случае вот обычно умножение это константа 16 то это неплохо правда то есть все-таки ну
соответственно ну вот ну конечно там может быть заговорками что может быть вам потребуется
тепло он глонг и поэтому там будет не 16 все-таки чуть-чуть меньше но тем не менее это все равно
значительно более того на самом деле для непосредственно ну то есть вот то есть единственное
тут вот ограничение то что кто сказал что по 10 тысяч потому что по идее еще иногда применяется
хранение просто по 9 цифр вообще то есть по модулю то есть по основанию системе члене миллиард
нет это не совсем то миллиард 7 это когда вы вам достаточно только остаток отделения это немножко
другая песня вот а в данном случае просто по основанию миллиард то есть просто по 9 цифр то есть
на самом деле пока вы только складываете числа на самом деле это уже неплохо но то есть как бы
просто где просто вы как бы в 9 раз меньше и чей памяти храните в айбе но вот то есть правда вот
умножать конечно в таких числах проблема то есть дело даже не в скорости а в том что действительно
каждое произведение у вас будет тогда порядка 10 18 попарная но вот а максимальный результат
который у вас тут в процессе может получиться это что типа 10 18 там соответственно называется
умножить на количество ячеек если совсем в тупую это делать вот ну конечно да можно пытаться
конечно делать что-то в духе что вы там взяли там аи ты умножили на бж т там умножили на бж
т отправя ну вот отправили его в какую ячейку кстати
конечно то есть как нет ну нет но на самом деле тривиально собственно это мы даже
увидим вот то есть пока так значит с это и плюс жита это вот плюс равно это плюс бж
т умножить на бж т и там сказать что-нибудь в духе что если у вас там произошло переполнение
так давайте просто прямо здесь это переполнение проталкивать дальше ну вот ну что же у нас тогда
но но то есть можно так пытаться там следить собственно увеличится лет это 8 точек или нет
вот но правда тем не менее там 4 цифры делать там 9 цифр делать а квадрат остается квадрат
в чем зовите это я пока на всех случаях деление не поминаю вот ну вот и на самом деле вот а
можно ли умножать быстрее на самом деле такая серьезная математическая проблема которая можно
сказать пищи лет стояла вообще то есть дошло даже просто до веселой смешной истории то есть
представьте 60-е годы значит где-то какая где-то аудитория некогда какая-то там аудитория михмата
мг у на своем семинаре академик колмогоров но там известный математик там частости основоположник
вероятностей там и тд и тп думаю фамилия известная и что нот и развод будет говорить что вот у нас
есть вот такая проблема умножение длинных чисел как их умножать за квадрат знают уже много тысяч
лет еще и два линии древние египтяне знали а вот как быстрее почему-то за столько тысяч лет почему-то
никто не придумал значит заключить колмогоров видимо надо искать пути каким образом можно доказать
что быстрее нельзя но буквально там едва ли не в конце семинара просто может быть там чуть
позже к нему просто подошел то ли студент старших курсов то ли аспирант младших курсов и буквально
в три строчки показал кабалгорову что он вообще не прав и умножать длинные числа быстрее чем за
квадрат можно и нужно просто простые три строчки значит что же это было вот он сказал смотрите вот
жила было у нас вот что такое вообще длинные там вот есть у нас допустим длинное число а да оно у
нас равно а 0 вот ну во первых да начнем с того что нажать числа умножать многочлен это примерно одно
и то же правда но тут просто такая мысль да что вообще как бы длинное число это что такое это там
а 0 плюс а 1 умножить на 10 ну допустим плюс а 2 умножить на 10 в квадрате плюс и так далее плюс
а n минус 1 умножить на 10 степени н минус 1 ну по идее мы представляем это в виде такой последователь
вот ну а ведь заметим что если мы вместо этого введем многочлен а т который будем хранить ровно
в виде тех же коэффициентов вот а 0 плюс а 1 т вот плюс а 2 т квадрат плюс и так далее плюс
а n минус 1 умножить на т степени вот то понимаешь что если мы хотим перемножить два многочленов вот
у меня допустим такой же многочлен и давайте сейчас я для простоты предположу что но вот эти
многочлены даже имеют одинаковое число коэффициент то на самом деле если я найду произведение этих
многочленов то я найду и произведение соответствующих длинных чисел ну вот и действительно что же
такое произведение многочленов да вот давайте вот как это вот был вопрос откуда вот это вот и
плюс же взялось вот давайте увидим это там а т на б т собственно равно то есть просто если честно
про произведение писать то тогда понятно что просто перебираем все все ашки перебираем все бшки и
попарно перемножаем их и соответствующие там степени т получается а и т на б ж т на т степени
степени и плюс же вот вот со второго из-за этого у нас вот именно а и т умножить на б ж т отправляется
именно в корреценции ежеды обратите внимание так но вот это у нас по определению вот но это
конечно пока пока это все очевидно и тут мысль следующая давайте попробуем применить метод
разделяй властой давайте вот сейчас еще прям совсем для простоты давайте еще скажем что n это
степень двойки ну вообще-то там ладно лишних нулей в конец многочленов написать это никогда не
проблема правда а симпатически это ни на что не повлияет ну да ну мы можем там отдельно обсудить
действительно за какой симпатику можно умножать числа если одной из них прям прям принципиально
короче другого вот вот но тут тоже пока не судить значит что же у нас получается получается
следующее то есть мы можем сказать что давайте вот скажем то есть введем такие числа такую
штуку как а 0 которая будет равна а 0 плюс а 1 т плюс и так далее плюс а n пополам минус 1 на
т в степени пополам минус 1 но вот и а 1 тоже введен это будет равно b 0 плюс нет бешка тут
на бы пока отношениями а тут наоборот а n пополам плюс а n пополам плюс 1 на т вот тут будьте
внимательны потому что там в будущем у нас а 0 и 1 будут будут иметь несколько другой смысл ну
когда-нибудь потом вот нет n в степень двойки размер количество коэффициент степень
двойки сами эти числа могут быть абсолютно произвольные нет но это я просто делаю чтобы
разделяй и властвуй был максимально красивый без этих там формальных округлений вот я просто
фактически это дело я просто разбираю на расчлен на 2 вот я просто теперь объявляю что у меня
теперь а т просто теперь равно а 0 от т плюс т в степени n пополам на а 1 от т вот понимаете
да то есть вот такая вот идея более того с бешкой я могу сделать то же самое вот то есть это вот
у меня теперь 4 многочлена размера n пополам а теперь если я вот это вот а т буду убирать то
что я вижу я вижу что а б равно чему равно а 0 б 0 плюс т в степени н пополам на а 0 б 1
плюс а 1 б 0 плюс т в степени n на а 1 б 1 и теперь идея что я теперь могу просто свести умножение
многочленов размера n к многочленам а нотка у нас же экскурсивном умножению вот 4 раза
многочленов размера n пополам да обратите внимание есть употребляю слова размер многочлена не путать
со степенью многочлена можно поймите степень многочлена это вот там то есть максимальный
номер не нулевого много не нулевого коэффициента вот но а размер это вот сколько коэффициентов
мне реально используется то есть как бы размера ну чаще всего размер это степень плюс один но
бывает иногда и больше особенно если вы там нулей в конец докидаем так вот ну еще раз размер
этого сколько коэффициентов вот мы реально используем вот в ранении многочлена нет просто
сколько коэффициентов кто-то из них может быть нулевым нет размера нас сейчас n потому что с нуля
размер но степень скорее всего меньше да потому что нет самое главное не какие нулевые а что
вот этот может быть нулевым то есть обратите внимание да то есть у нас многочлен какой-нибудь
там называется т в клубе это многочлен этом многочлен степени 3 правда несмотря на то что
у него коэффициент при т в квадрате например коэффициент 0 но тем не менее степень у него
3 а размер соответственно 4 у нас будет потому что мы его будем хранить в виде 0 0 1 это как минимум
а может быть и размер 8 если мы его будем хранить вот в таком виде например всякое бывает вот
аккурат и так значит что есть многочлен размера n пополам значит мы их умножаем просто рекурсивно
ну понятно что если раз там n стало равно там один или там два вот то или 50 нет на самом деле на
самом деле до в этом алгоритме кстати действительно там бывает просто что если n не превосходит там
пятидесяти то давайте перемножать в тупую просто вот но потому что оказывается что
действительно это очень быстро работает вот значит тогда если так запускаться то давайте
посмотрим за какой всем точку тогда это будет работать ну чтобы это ощутить давайте просто
напишем нашу любимую рекурренту то есть многочлены размера n умножаются за четыре умножения
многочленов n пополам ну плюс еще от каких-то мистических операций но сложение по сути там
сдвигов еще каких-то может быть но это все но теперь внимание вопрос чему равно t от n
ну да то есть мы доказали бастер теорему мы ее помним то есть чего вот то есть t от n у нас будет
равно к чему соответственно от там как легко убедиться n в степени лог 2 4 это что то же
самое что от n квадрате да ну мы про что этот что эта штука там заведомо доминирует там на то от
n поэтому от н квадрат не помогло пока да пока ничего нового не изобретено но тут хитрый
студент или аспирант говорит смотрите а нам же на самом деле вот эти два произведения вообще-то
сами себе не нужны в общем-то сумма этих произведений нам вполне достаточно правда вот и тут он ведь
заметим что заметим что а 0 б 1 плюс 1 б 0 равно а 0 плюс а 1 на б 0 плюс б 1 минус
а 0 б 0 минус а 1 б 1 вот тупо заметим что вот да обратите внимание 0 б 0 и 1 б 1 мы считаем так
и так но то есть теперь получается что если мы просто теперь вместо этих двух рекурсивных
вызовов сделаем вот этот 1 на тоже а это тоже многочлены размером пополам обратите внимание
почему
многочлены да мы и хитрый многочлены умножаем специально для этого да вот если числа то туда
приходится часаться либо доказывать что-то с округлением или это нам доказывать не надо это
надо потому что это не совсем математическая проблема ну то есть да вот потому что дата
про про реализации если будет умножать длинные числа именно таким образом да проблема есть да
ну есть ну математически математически она решается в принципе в том плане что давайте
там базовым числом считать число которое там в три ячейки влазит допустим и там поэтому при
перемножении переполнений не будет и будем быть что если там она ну вот нету я согласен
всем что дает что теоретически да такая да такая проблема есть но просто ну как сказать если у нас
будут детали что есть у нас единственная проблема что там некоторые числа вылазит за эти в битов
да и нам просто все что нам нужно это на самом деле хранить то есть остаток то есть те что будет
в последних в те что в первых то это решаемая проблема логично да вот то есть можно беззаключение
общности модели особо считать что у нас есть такое супер умножение который за от единицы
два числа там это остаток от деления на два в степени давал ее и так сказать саму
деле самой частной от этого деления вот итак значит что у нас тут дальше но хотела но значит
давайте смотреть значит что у нас тогда значит н квадрат пока все этот квадрат но с другой
стороны теперь замечаем что если мы верим что у нас получилось три умножения то как бы у нас
просто вот эта четверочка заменяется на троечку и вот неплохо так правда ну то есть пока конечно
да то есть не то о чем мы там современной науке мечтаем конечно но так как этот лог 2 то есть это
уже быстрее чем и квадрат но то есть конечно это само это число но ты так сколько ну там вообще
один так оно там один точка 5 но не совсем корень вот один точка 58 блаблабла но там на
самом деле может можете там у себя на калькуляторе посчитать вот но вот но уже уже неплохо то есть
как бы тут уже колмогоров да тут уже трижды поменялся в лице там и там просто бы и там
просто побежал это публиковать не смысл под своим именем естественно а просто ну вот то есть
там просто там вплоть до истории что там была какая-то то есть как будто там прицепом называется
послали там какое-то уже принятую статью там на самом деле статья типа стал из двух частей в
первой то что было изначально во второй вот эту но там вот что-то такое не помню уже деталей там
что-то рассказывал но но тем не менее тут конечно это надо было как можно быстрее публиковать потому
что ну действительно прорыве действительно вот да ну и конечно этого студента звали соответственно
как уж ну почти да анатолий александрович карацуба его звали на самом деле вот собственно на
самом деле такой известный математик области дискретного анализа на самом деле вот и так ну вот
но соответственно что же делать дальше дальше так сказать хорошо если тут так сделали они где быстрее
ну как бы какая тут следующая мысль приходит в голову слушайте вот вы тут на две части поделили
получился так а если на 3 и так еще она да так ну давай так делим на так делим на блоке по корень
изн каждый там в тупую да и что у нас там получает корень да корень изн выражение придумать это круто
конечно да тут хотя бы уже три выражения придумать на самом деле вы то есть вот на три части если
поделить то чего будет так ну где 9 умножение ну давайте ну куда дать прям очень интересно давайте
вот у нас там допустим а 0 плюс т в степени на 3 а 1 плюс т в степени 2 и на 3 а 2 на 3 на 3
согласен хорошо так бт равно б 0 плюс т в степени на 3 б 1 плюс т в степени 2 и на 3
б 2 так хорошо что у нас такое а б а б значит это а 0 б 0 плюс т в степени на 3 на там соответственно
а 0 б 1 плюс а 1 б 0 плюс там т в степени 2 и на 3 соответственно а 0 б 2 плюс а 1 б 1 плюс а 2 б 0
плюс да внезапно вот плюс т в степени на а 1 б 2 плюс а 2 б 1 и плюс т в степени 4 на 3 а 2
б 2 а каким образом а только если рикурсивно запустится чего
сейчас человек так один допустим
так хорошо да 0 плюс б 0 допустим на а 1 плюс б 1 то есть вот это типа вот так хорошо что там
получается ну хорошо так ну нет давайте посмотрим так так нет а это я под него и
нарисовал не но да и получается да еще придется да тут еще а 0 да но теперь у нас тогда да да но
теперь но у нас теперь сравнивать надо лог 36 не с двойкой а с лог 23 да лог 36 против лог 23 кто
больше да кстати интересный вопрос как это сравнивать то вообще да и что будет так ну
в принципе заметим да лог 3 ну пожалуйста да неважно так и что так чего надо можно ну-ка давай
вот хотя если мы сейчас на лог 32 да множим чего получится то есть один там 1 плюс лог 23 сравниваем
лог 23 в квадрате ну я просто я обе части то есть вот эту штуку вот эту штуку домножим на лог 23
что это корень из 5 минус 1 пополам а да да да да да да но да да ну в принципе да
на лог 23 лог лог 32 лог 3 да да да да да да это я это я хитрый ну вот так и что будет но
что будет 3 ну будет так возбудить нет ничего возбудим значит тут будет да тут будет 6 а тут
будет 3 в степени лог 2 3 неплохо да нет ну как сказать на самом деле конечно хотя вот не оно
как сказать там просто корень корень из трех это у нас сколько да корни и да так
но вот нет вот просто сейчас это хотя с другой стороны да вот можно попытаться оценить что
это больше чем три корни корни из трех 1 63 тем более дат сейчас три корни страта корни
нет этого не хватает так но да можно повозводить правда насколько помню
мне как сказать получалось что кстати шестерочка все-таки меньше оказалось все-таки поэтому там
вот возникает вопрос как будет а как бы это все-таки вот можно ли это все-таки за 5 произведений
сейчас системы из трех уравнений ну каких а давайте так а что еще общие те сами
себе скобчики вам напоминает вот на самом деле да то есть на самом деле да то есть можно просто
себе представить что вот а 0 1 и а 2 на самом деле как-то помимо всего прочего это еще и коэффициенты
какого-то многочлена размера 3 правда ну да то есть там конечно да они сами всем многочлены но
с другой стороны почему бы и нет вот то есть как бы давайте вот тут скажем что у нас будет такой
супер многочлен допустим а 0 плюс там я не знаю а 1 на там я не знаю кси в степени на кси плюс
а 2 в степени кси квадрат понятно да вот нет пока нету никогда нету нету нет не получится не
по-прежнему что дальше будет а дальше сотри вот смотрите то есть заметил что если я сейчас
перемножу эти два многочлена то при кси в какой-то степени будут стоять ровно вот эти вот штуки
правда но теперь заметим следующее вот важная идея которая нас сегодня который нас все-таки
будет преследовать везде если перемножить многочлены два многочлены размера 2 размера 3 то
что получится но скорее 5 ну степень 5 да ну там размера там допустим 5 вот но тогда у нас
возникает идея смотрите вот у нас то есть возникнет какой-то вот многочлен условно c 0 плюс
1 кси вот это и спереди там церковно так сказать а на б да плюс там допустим ц 2 на кси в квадрате
плюс ц 3 на кси в кубе плюс ц 4 на кси у четвертой вот а теперь внимание вопрос смотрите но вот
у нас но то есть ну и каждая цешка равна вот этим вот штукам и нам надо просто идентифицировать
этот многочлен правда но теперь вот выскакать мысль такая как можно вообще задать многочлен
размера 5 да то есть заметим что его можно интерполировать если мы тупо в какой-то
точке там тупо знаем его значение в пяти точках правда но вот это возможно вы уже просто из
линей на алгебры уже тупо знаете да нет не знаете откуда знаете тогда
а сейчас откуда знает
нет хороший метод по тематике да серёга сказал что вову сказал что там это профессор из америки
рассказывал что да да да да нет ну просто смотрите нет вот давайте смотреть вот ладно
давайте давайте вот немножко вообще поговорим а теоретически об интерполяции смотреть значит
соответственно значит что тут можно сейчас давайте вот это мы это я думаю мы уже все поняли что нет
ну это я думаю так так сейчас смотреть
ну вот мы его нет смысле не но что это что это вот просто типа вот этот виртуальный
наречен перемножил но вот этот виртуальный наречен получил вот это и заметил что на самом
деле то есть вот это то есть на самом деле связь простая то есть помните это c 0 это c 1 это c 2
так спокойно так спокойно не надо в нот как так во первых это не надо ставить знакомство
между это задавал вопрос и тупой но вот во вторых знаешь это вовно во вторых на самом деле это
задавший тупой вопрос он называется подавляющее большинство случаев на самом деле называется как
раз не тупой вот смотрите вот у нас тут действительно идея такая что если у нас есть многочлен
размера и вот снова да ну давайте там чтобы какие-то другие буквы были давайте пусть у меня будет
д т равно да д 0 плюс д 1 т плюс д 2 т квадрат плюс так далее плюс д n минус 1 т в степени
минус 1 тогда смотрите тогда я сейчас могу сформулировать вот такое интересное утверждение
пусть у меня т 0 т 1 вот у меня есть просто n каких-то чисел по парно различных давайте для
простоты даже действительно хотя на самом деле там любой поле подойдет вот так вот же есть у
ктч но вот это да нет есть алгем есть у ктч или у вас поля ну окей хорошо хорошо не вопрос
ладно значит хотя то есть тогда я сейчас формулирую мистическое утверждение на
языке собственно ли не налгивает
уже просчитали что будет дальше да
логично так ну давайте все-таки допишу вот это вот ван дер монда не путать с воландомортом
да как такие штуки говорят не думал мы живите так вот такое мистическое утверждение вот
в принципе теперь заметим следующее что если оказалось что эта матрица не вырождена то тогда
зная только эти n значения в этих точках я могу восстановить просто сам сами сам многочлен вот
правда возникает вопрос они вырождены ли она не вырождены ли она вот тут вот ну вот ну на
самом деле так давайте вот как вот я действительно вот допустим вас там встала перед вами задача как
найти ее определитель методовца так ну поехали дай чего будет дать что будет получаться значит
ну первая строчка допустим остается тоже пока да т 0 в степени минус 1 тут у нас будут нули тут
у нас что будет что 1 квадрат минус 0 квадрат значит 2 квадрат минус 0 квадрат и тут 1 степень
минус 1 минус 0 степени минус 1 и тут 2 степени минус 1 минус 0 степени минус 1 ну и так далее
там ну и давайте мало кто знает винипух на самом деле когда шел питочку он думал об
вот такая вот штука получилась вот ну да ну да ну в принципе да заметим что пока мы что в принципе
да заметим следующее что если мы берем определить это матрица заметим что эту строчку вообще можно
выкинуть в принципе да сказать что она равна 1 на определитель вот этой штуки но вот причем заметим
что эту штуку на самом деле можно торжественно вот то есть на самом деле на то в каждой строчке
может теперь выяснить вот эту разность правда то есть это равно ну я так напишу произведение по
всем и от единицы до n минус 1 значит t и того минус t нулевого на определитель что там у
нас получится теперь значит поехали 1 1 1 1 пум пум пум 1 только теперь уже тут хитрее пошло t 0
плюс t 1 тут у нас t 0 плюс t 2 t 0 плюс t 3 ведь я тут уже третье добавляю но в конце у нас все еще
останется n минус 1 так здесь получается так а здесь что получится ну здесь получится t 0
квадрат плюс t 0 t 1 плюс t 1 квадрать ну тут понятно форму сокращенного умножения да
t 0 t 2 плюс там t 2 в квадрате t 0 квадрате плюс t 0 t 3 t 3 квадрате пум пум пум t 0 квадрат
плюс t 0 t n минус 1 плюс что там получилось t 1 квадрат вот что будет дальше но да тут
тоже будет это куб плюс там там t 0 в квадрате на t 1 плюс там t 0 на t 2 и так далее еще можно
прям в конце но главное в конце написать что будет там будет соответственно там условно там t 0
в степени какой там n минус 2 получается плюс t 0 степени там n минус 3 на t 1 плюс там и так
далее плюс там в конце t 1 степени n минус 2 и тут соответственно t 0 минус 2 плюс t 0 n минус 3 t 1 так
ну вот ну пока я пишу я думаю вы уже это можете заметить действительно что я буду делать дальше
как вы думаете что я буду делать не туда тут заметили фишка что когда мы ищем определитель
можно делать вот это вычитание не только строчек но и столбцов на самом деле и не просто столбцов а я
могу из одного столбца вычислить другой столбец умноженный на коэффициент помните вот на самом
деле я утверждаю что если я тут вот как какой-то столбец сейчас по вычитываю столбцы по вычитаю
будет гораздо красивше далее на самом деле не только сейчас мы увидим это потому что ну давайте
давайте смотреть ну тут ну и тут вот ладно вот это вот я не буду уже дописывать вот но давайте посмотрим
да значит ну погодите погодите значит начнем с того что я могу из первого вычислить из второго
вычислить первый домноженный на t 0 тогда давайте вот прямо здесь тогда что у меня будет вот шлеп
шлеп шлеп правда сейчас да но более того нет заметим тут еще круче смотрите заметим что вот из
этого столбца я тоже могу вот это просто вычислить единицы там нужно на то ноль в квадрат поэтому
будет шлеп шлеп шлеп но теперь я замечу что я еще могу теперь у меня вот этот столбец t 1 t 2
и так далее t-1 если я его домножу на t 0 у меня тут получится шлеп шлеп шлеп шлеп и теперь у меня
получился столбец квадратов то есть это то есть там же я вот в этом кубическом столбце теперь
могу абсолютно также все зачистить но тут показать надо же вот что для n-1 я могу то есть я могу
заметить что у меня как минимум сначала вот тут у меня будет шлеп шлеп шлеп потом вот тут шлеп
шлеп шлеп ну и так далее в общем везде шлеп шлеп в общем ну да то есть ну даже в нашем случае даже
не предположение просто типа повторим операцию
пожалуйста пожалуйста на ваше усмотрение да то есть на спредель t и на t 0 умножить на
определитель матрицы t 1 t 2 t 3 нет вру вру вру вру рано рано это я еще написал значит тут
надо написать 1 1 1 и так далее 1 тут получается t 1 t 2 t 3 и так далее t-1 значит тут квадраты
квадраты квадраты и ой так t 1 n-1 тут t 2 в степени n-1 t 3 в степени n-1 т в степени n-1
ура ну почему ура потому что мы замечаем что это как бы то же самое что было и раньше только на
единичку меньше если мы тупо повторим все эти операции то получится в итоге произведение
просто всех попарных разностей вот то есть фактически и плюс 1 на n-1 значит t и минус t же
вот это называется да то есть вот фамилия вот такая да как-то не странно пишется она в одно слово
они в 3 хотя казалось бы вот а где а да да да да да да да да да да да да да да да да так
тут один вот вот тогда что мы из этого видим на самом деле вот на нашего это в нашем это
определитель и ну не знаю ну на самом деле так заметим что вот даже так более аккуратно он
равен нулю тогда и только тогда когда среди т-шек есть хотя бы две одинаковые нет ну ну логично тут
не совсем так я бы сказал наоборот что собственно этот факт теперь открывает возможность интерполяции
принципе но да то есть как бы да да но да да ну как бы очень хочется сказать что многощина
размера n мы интерполируем по n точкам но и теперь мы доказали что мы действительно так можем
делать более того даже у нас более четкий факт на самом деле по любым значениям в n точках
получает то есть для любых значений на любого набора значений в различных точках многощина
размера n не просто существует но еще единственным ну просто как система как решение вот такой
системы линейных уравнений вот и так то есть мы да то есть мы это действительно прям можем
делать причем одна что про что очень важно для нас однозначно значит к чему мы это вообще вот
к чему потому что вспомним так о чем мы это хотели мы вообще хотели мы у нас возникла идея что
давайте вот этот врачен попробуем интерполировать по 5 точкам откуда мы эти 5 точек возьмем вот ну
естественно но ну как как но действительно мы же замечаем что у нас же верно что там скажем ци от
кси на самом деле это равно а от кси умножить на б от кси правильно тогда вы скажете просто давайте
я просто в качестве кси подставлю числа 0 там скажем 0 1 2 3 4 вот от балды тогда что у меня
получится тогда у меня получится там скажем тогда если я вот подставлю то у меня но получится
что то есть там понятно что цет цет нуля у меня будет равна просто а 0 умножить на б 0 правда
чему будет равно ц от единицы ц от единицы будет равно вот смотрите а 0 плюс а 1 плюс и тогда плюс
а 2 на б 0 плюс б 1 плюс б 2 ну там скажем ц 2 у нас получается равно а 0 плюс 2 а 1 плюс 4 а 2 на
б 0 плюс 2 б 1 плюс 4 на б 2 ну и так далее думаю суть вы поняли да то есть тогда получается что
у меня получилось что у меня есть 5 получается я должен сделать 5 рекурсивных умножений тут
вот записано вот какие конкретно видите и по ним я могу тогда вот эти штуки про интерполировать
то есть просто там фактически решив систему линейных уравнений ну то есть условно я могу
просто записать там соответствующую матрицу там что-то в духе там какая там матрица получится вот
1 0 0 да 1 1 1 1 1 1 1 2 4 8 16 там допустим 1 3 9 27 81 и там 1 4 там 16 64 256 вот такая вот у
нас ситуация получается и соответственно вот то есть ну и заметит а что мы помнить что ашки это
конечно не формально говоря не числа многочлены но с другой стороны вот к этой же матрице обратной
существует правда вот поэтому там можем ее просто там ручками там просто найти один раз и соответственно
и просто там соответственно вот все вот эти произведения на эту матрицу домножить и получить
собственно коэффициенты вот этого произведения и тем самым получить вот эти вот 5 штучек то есть
таким образом у нас получается все-таки не лог 3 6 а лог 3
ну вот ну на самом деле обобщить это обобщить это на самом деле
Gedda что там это применять более сложную технику а просто сказать так но по аннот ну смотрите
то есть на ходе это обобщить вот сейчас нас просто сказать что у нас вот это вот три это
когда делим три константа то есть вот это вот типа матрица 5 на 5 это вот у
нас такая константа вот логично да вот то есть особенно такая константа но вот
поэтому предлагается так сказать что что тогда но тогда у нас действительно все
проблем-то вообще не понял.
В n точках никто это делать и не будет, но просто тут идея что нет просто
смотрите я могу это сделать в k точках где k будет равно
константа какая-нибудь да ну то есть такая наглость да вот пусть у меня но
просто заметил что я подобного рода интерполяцию могу сделать и для вот в
данном случае мы ее то есть изначальный алгоритм коротцубы он был для k равно 2
вот это вот для k равно 3 но абсолютно ту же махинацию я могу произвести для
произвольного k правда ну фиксируя его как константу понимаете да вот но тогда
в результате тогда что у нас получится ну так как до типа как я сказал k
константа то есть а теперь внимание вот и какая у нас симптотика получится то
есть сколько сколько нам надо вот таких произведений каждый раз сделать
ну получается да то есть получается действительно то есть там ну давайте
смотрите просто там получится то есть мы этих произведений делаем ровно там 2
n минус 1 значит на t от n поделить сейчас нет сколько нет 2 т минус 1 нет не так
2 к минус 1 конечно 2 к минус 1 от t от n делить на к плюс внезапно от и вот
кажется у нас константа да и вот и в результате чего почему
у нас в процессе умножения в матрице будет нижний ячейк и получается все еще константная правда но все-таки число прав степени как
будет почему оно никак нечаянно не разрушит нам что-нибудь мы говорим что мы умножаем в решлении и у нас в ячейках хранится какие-то числа которые вылезают в какую-то константу
почему они влезают ну вот ну для любого n ну для любого n ладно будем честны они конечно не влезут нет это не
константа нет обычно просто в этих моделях просто обычно сразу тут два варианта либо
прописывают что значит мы работаем с достаточно маленькими числами что все произведения в
это число влезут во первых либо второй вариант мы используем просто не продвинутую рам модель а просто рам модель в
которой все числа на самом деле бесконечно большие да зачем нам тогда длинная арифметика остается загадкой конечно
вот да все равно согласен но обычно просто говорят что мы у нас задачи перемножить хотя бы там многочлены но там
гарантируем что мы храним по такому количеству разрядов то есть то есть у нас такие коэффициенты
у многочленов что соответственно мы гарантируем что ответ тоже будет представим в таком виде нет в
таком виде где в смысле число достаточно маленькое чтобы лезть в одну ячейку
а хватит ли нам такой гарантии?
откуда все это есть гарантия что данного ячейка в отверстие тоже все будет хорошо?
это логичная гарантия
а не создадим ли мы по поводу решения ситуацию где нам ничего не гарантирует?
да действительно на самом деле проблема
Ну, с другой стороны, давайте подумаем, насколько сильно тут все может возрасти.
Проблема заключается в том, что у нас числа, которые тут везде возникают, начинают неконтролируемо расти.
И вот, если у нас проблема, что в одной ячейке памяти мы храним только числа, какие-нибудь w, условно не более чем 2 в степени круто фиксированного w, то как бы тут возникает вопрос, можно ли гарантировать, что у нас в процессе этого алгоритма число, количество разрядов, базовые числа увеличится не более чем в константу раз, чтобы там лучше не гарантировать.
Тут вот такие какие-то проблемы на самом деле. Да, действительно, хороший вопрос.
Но с другой стороны, давайте вот что. То есть хорошо, если у нас действительно, так пока если совсем неформально, то проблема заключается в том, что мы тут домножаем на какие-то там k в степени k, да?
И там, а потом главное, рекурсивно мы их как-то на какие-то ка в степени ка.
Главное нечаянно не начать рекурсивно умножать на одно и то же число.
Так самое страшное, что мы начнем. Но с другой стороны, сколько раз мы начнем?
Один раз мы домножаем на какое у нас там число получается?
k-1 в степени n-1, да?
Ну получается да.
А, да, еще хуже, 2k-1.
А, вот там ниже.
Все-все-все.
Нет, ну что, плохо, нормально.
Так, значит, хорошо, да.
Да-да-да-да.
Нет, ну смотрите, да. То есть мы замечаем, что мы тут, тут у нас вот эти все коэффициенты в процессе, они получаются не более чем 2k-1.
Там, действительно, в степени k-1.
Нет, просто нет. Проблема тут...
Нет, проблема тут, да. Проблема в том, что как бы мы тут рекурсивно начинаем умножать.
Но с другой стороны, конечно, сколько раз мы начинаем это домножать?
Мы замечаем, что мы это делаем лог k-n раз.
То есть получается нам вот это вот надо возвести в степень что-то типа лог k-n.
Вот.
Да, поэтому действительно можно обнаружить, что, к сожалению, там что-то типа k в степени n все-таки выплыло, видимо.
Ну ладно, это не k в степени n, это n в степени k, на самом деле, обратите внимание.
Ну то есть там по модуле, если я тут двойку вынесу, у меня тут получится 2 в степени лог k-n.
Ну, в общем, давайте, я ж могу и подписать, правда.
То есть на самом деле это равно n в степени лог k вот этого всего безобразия.
А это константа.
Ну и что? Секунду.
Ну, сердце константа, но n в квадрате там 2 тоже константа.
Как-то нас это не устроило.
Чего нас не устроило?
n в квадрате.
n в квадрате нас не устроило?
Мы числа перенажали, два же константа.
Почему бы не?
Ну, да, это большое число.
Ну вот.
Ну, да, что за нот?
Нет, ну как большое?
Сейчас, это сколько это там?
Ну да, это конечно да, k-1.
Не, ну не совсем так.
Заметим так.
То есть это равно так.
n в степени на самом деле k-1 на лог k значит 2k-1.
То есть нет, ну на самом деле это заметим, что эта штука стремится к единице на самом деле.
Логично, да?
Ну вот.
То есть это будет соответственно к единице.
Поэтому вот это все, это будет не превосходить n в степени k.
Ну вот тут конечно да.
Но на самом деле это что такое?
Это всегда вот оговорка.
Потому что в таких случаях, боюсь в статьях будут махать руками и говорить, что мы будем предполагать, что у нас w достаточно большое.
Коэффициенты достаточно маленькие, чтобы все промежуточные вычисления в них помещались.
Все.
А, потому что у нас среди вычислений будут числа такие по модулю, но не по размеру.
Ну у нас да, у нас будут числа, да.
То есть вот эти числа, которые нам тут нужны, это вот да, это n в степени k соответственно.
Вот.
То есть по крайней мере коэффициенты.
То есть можно конечно задумываться, мы что-то делаем не только произведения,
но и, то есть не только вот эти произведения в степени, но еще и тут какие-то промежуточные произведения.
Сложения там вот эти вот да.
Ну вот, то есть поэтому на самом деле по-хорошему это надо бы еще бы поточнее оценивать.
Ну вот, но пожалуй этот побенку все-таки опустим.
Вот. То есть там можно действительно либо правильнее сделать правильную оценку, либо правильную оговорку.
Вот.
Ну просто к чему нот?
Ну тем более что нот.
То.
То тем более, что просто само по себе на самом деле это такая веселая вещь.
То есть с правильными оговорками, этими всеми отсылками, что там к аналогичным атомикхипам,
теперь нам гордо говорить, что мы теперь умеем, то есть если мы все-таки верим в эту асимптотику и в k-константу,
тогда мы что понимаем?
Тогда мы понимаем, что мы на самом деле, что у нас t от n, это у нас теперь равно o от n в степени log k 2k-1.
Вот.
Поэтому формально теперь, так как вот эта штука логарифа, он стремится к единице.
Стремится.
Поэтому в результате получаете теперь утверждение.
Для любого епсилон больше нуля найдется алгоритм, который перемножает число длины n за асимптотику o от n в степени 1 плюс епсилон.
Это да.
Мы уже научились первым же делом нажать числа за log 2 4, потом за log 3 6, потом за log 4 8.
Да, ну во-первых вот эта штука дает log 2 3, log 3 5, log 4 7.
Это бесполезно, потому что log k 2k тоже сходит с к единицы.
Так, если мы умеем вот это обобщать, пока что мы для тройки сможем делать.
Сейчас, log 3 6 прям сходится.
Ну да, это log k 2 на единицу.
Так.
Log k 2 как бы ну.
Нет, а сколько у тебя там будет получаться?
Если, в общем случае.
Нет, там может быть этого и хватит.
Но на самом деле я предлагаю остановиться в этом думать, потому что у нас все равно будет алгоритм за n log n, который это все равно перешибет.
Да, обратите внимание.
Да, как это может показаться странным, но n log n круче, чем вот это.
Не кажется.
Ну вот.
Ну, хотя да, подобные вещи мы уже с вами обсуждали.
Вот.
Но тем не менее.
То есть вот, оказывается, на интерполяции можно там это так ужимать.
Правда, чем больше к, тем больше оговорок, действительно, каких-то подозрительных.
Вот.
Но с другой стороны, правда, будем честные.
Сейчас алгоритм, который мы сейчас будем за n log n обсуждать, он тоже на самом деле не лишен этих оговорок.
Потому что, как бы, если тут мы говорили, что насколько большие будут числа, то там придется вообще думать о каких-то дробных числах вообще.
Ага.
Да, по скольким простым модулям еще придется делать?
Да, да, да, да.
Ну не только.
Потому что коэффициенты маленькие должны быть, да?
Ну, в принципе, да.
Одна из надежных идей, конечно, такая.
Ладно.
Значит, это был алгоритм Коротцуба и его уминание обеими ногами.
Вот.
Ну, там да.
Ладно.
Очень, да.
Очень боюсь врать, но я подозреваю, что это все может называться алгоритмом Шенхайо Штрассана, если что.
Да.
Встречалась там фамилия Штрассан?
Нет?
Ну ладно.
Вот еще такая.
Просто Штрассан действительно известен тем, что он примерно аналогичным способом придумал, как перемножать матрицы размера n на n быстрее, чем за n куб.
Что там n в степени n куб минус...
Нет.
Там n в степени log 2,7.
Причем тоже идея в духе.
Разделим вот там эту матрицу на 4, эту матрицу на 4.
Сделаем какие-то 7 хитрых умножений разбираем пополам-пополам.
И там еще какие-то шаманские формулы.
В общем, они описаны в Корме, и в самом Корме грустно написано.
К сожалению, в статье Штрассана не говорится о том, каким образом он пришел к этим формулам.
Условно какая богиня Сида ему на ухо нашептала, но подогнал, короче.
В любом случае понятно, сейчас там матрицы умножают быстрее.
В Википедиях вообще можно увидеть какой-нибудь текст.
Что сейчас лучший алгоритм умножает матрицы за n в степени 2.2354.
Это улучшение метода Капельсмита Винограда, который работал за 2.2381.
Нет, это все, да. Практического значения это особо не имеет.
Но, как говорится, тут называется дальше, наука вещь такая.
Когда-нибудь, когда в компьютере будет нормальное количество разрядов, а не эти ваши 64,
собственно, это будут нормальные актуальные алгоритмы, которые все будут писать.
Пока имели в библиотеку.
Ну что, да. Ну, как сказать, да, правда, придет.
Бесконечность – это предел, вы это уже знаете.
Ну, как сказать, я бы сказал, ее предел равен бесконечности.
Так, вопрос был, является ли бесконечность пределом. Ответ, да, является.
Потому что бесконечность – это пределы этой последовательности.
Это другой вопрос, что также в этом случае говорят, что он расходится.
С прочими красивыми анекдотами на экзамене.
Профессор, что будет, если я попрошу вас посчитать сумму этого ряда?
Студент, я повешусь. Профессор правильно, он расходится.
Пока тут суд доделал, я тут что-то постирал.
А мы, собственно, попробуем пойти с этим всем разделяя властвой.
Нет, почему? Как раз недалеко и чуть другую сторону, может быть, даже красивше получится.
Потому что, на самом деле, от идеи разделяя властву с интерполяцией мы, собственно, далеко не уйдем.
Потому что, смотрите, как теперь нам это предлагается делать?
Да, мы продолжаем считать, что у нас n степень двойки.
Да, кстати, жестко, на самом деле.
Заметьте, что конкретно тут вы можете догадаться, что на самом деле вы делите на три части магнит,
делите на приблизительно три.
Ну, там два варианта выкрутится.
Если n не делится на три, например, то вы можете либо докинуть два нуля, допустим, в конец,
либо этот остаточек как-нибудь домножить прям вручную за линию.
И n на три будет уже округленное вниз.
Ну, там, в общем, тоже повыкручиваться можно.
По сравнению с тем, как мы махали руками внутри, это уже мелочи.
Ну вот, а сейчас у нас на самом деле просто очень жестко будет, что n это степень двойки.
Прям вот очень жестко.
Нет, на этот раз реально, вот не как обычно.
Чего? Пока да.
Ну, хотя да, это нам тоже.
Ну да.
Ну, если длины не равны, ну, как сказать, то я боюсь, там везде просто будет один и тот же лайфхак,
который пользует умножение для одинаковых многочленов как черный ящик.
Ну, давайте вот сразу вам скажу.
Потому что на самом деле, если у вас есть многочлен размера n и многочлен размера m,
ну так, поменьше, то можно на самом деле сделать следующий механизм.
В общем, заметьте, вот просто пусть у нас есть многочлен, то есть что-то черный ящик,
который умножает одинаковые длины, ну, там сейчас выясним, сколько-нибудь.
Именно, именно.
Точнее, на блоке по n.
Даже точнее будет сказать.
И их там перемножаем, потом за o от n, соответственно, приводим друг к другу.
И тогда получается, что у нас это равно.
То есть это будет просто n делить на n, на сколько вы там этим наращением домножаете.
Ну, то есть, соответственно, в идеале Фурьятина нам сейчас даст n лог m,
вот Корацубо нам дал бы n в степени условно там, ну, в базовой версии лог 2, 3, минус 1.
Вот, на самом деле.
Ну, то есть, обычно такой вот лайфак, то есть он позволяет так свести,
что если m совсем мелко, то тогда оно будет реально стремиться к o от n.
Ну, впрочем, реально, n длинные на короткое вы же, наверное, за линию домножите, правда?
А не там за n лог n какой-то.
Вот.
Поэтому нас, в общем-то, не сильно, поэтому нас не сильно смущает вот это вот ограничение
на тему того, что мы будем умножать там многочленные одинаковые длинные.
Там b1t плюс там b2t квадратом, бла-бла-бла.
Бла-бла-бла.
Вот.
Значит, смотрите еще раз, n это жестко степень 2.
Значит, тут нам говорят, тут нам говорят примерно следующее.
Значит, смотрите.
Значит, мы все еще, значит, мы не оставим идею действительно вот ровно таким образом все интерполировать.
Вот.
Но мы пойдем чуть дальше.
То есть у нас будет мечта.
То есть завести, ну, в нашем случае t0, t1 и так далее, ну, в нашем случае давайте 2n чисел,
ну, для ровного счета 2n нам нужно, правда?
И нам нужно уметь переводить многочлены из одного вида в другой.
Что я имею в виду?
Ну, давайте я вот так скажу.
Я вот хочу сказать, что у меня есть многочлен размера n.
Вот я могу представить этот многочлен в виде n чисел, в виде n его коэффициентов.
Это просто классический многочлен a.
А можно его представить, если у меня есть фиксированные вот константы, да?
Можно его представить как в виде вот такой последовательности a от t0, a от t1, a от t2, ну, и так далее.
Вот, просто если мне даны эти значения, то я, по крайней мере, называется, как говорят, это at least in principle,
то есть могу однозначно восстановить вот эти коэффициенты, как мы уже, собственно, вот там остатки даже написаны.
Но единственная проблема, что мы это можем сделать за n куб, а нам бы хотелось побыстрее.
Но заметим, что если у нас возникнет какой-то такой двусторонний черный ящик, который будет из этого получать это,
а из этого получать это, вот нот, то тогда заметим, что я, тогда мы, и нот, этот черный ящик будет их перегонять за время какой-нибудь там t' от n.
То я тогда смогу сделать умножение двух многочленов размера n за какое время?
Ну, два, давайте так, 2t' от n плюс o от n. Ну, в принципе, 2t' от n, это, скорее всего, там t' от n все равно будет, правда?
Ну, просто как-то так, но я так вот аккуратно напишу.
Ну, то есть оговоримся, как я сделаю, то есть как бы я перегоню в такой вид многочлен a, многочлен b, мне получится значение,
тогда я получу в этих точках значение многочлена c, которое является произведением, и потом перегоню обратно.
Ну, единственное, только вот важная оговорка, что я здесь говорю, что у меня есть n, но на самом деле, конечно, a и b мне придется представить как многочлен размера 2n.
Почему? Ну, потому что мы знаем, что многочлен c у нас будет размера, то есть там степень его может быть больше, чем n-1, правда?
Поэтому нам, чтобы его однозначно восстановить, нам все-таки потребуется 2n чисел, а не n.
Вот. Ну вот, то есть это вот маленькая техническая оговорочка.
То есть итак, то есть у нас теперь задача. То есть теперь у нас не два многочлена, а один. То есть я вот эту b-шку убираю.
Еще b-шку убираем. То есть когда я сказал, что знаю, как потом за 1n что-то доделать, значит, узнаю все.
О боже. Так. Ну, это называется хорошо. Так, надо ли еще более точные комментарии давать на тему того, что надо дополнительно делать, если у вас этот черный ящик есть?
Ну да. Ну и там нулики еще докинуть. Вот, это понятно?
Да.
Понятно, да. Вот, хорошо.
Значит, смотрим.
Ну как же мечта, ну да, мы уже, ну да, не то чтобы научились это делать, но конечно мы можем это для каких-то фиксированных точек за n квадрат в принципе сделать это в одну сторону и за n куб в другую.
Как же это сделать быстрее?
Но до сего момента заметим, что у нас есть еще такой потомсал для улучшения.
Мы же, заключается он в том, что мы не обсуждали ни разу, а чему сами вот эти t-шки равны.
Чему они равны? Там 0, 1, 2, 3, там 4, 5. Там 2, 3, 5, 7, 11, 13, 17.
Там минус 1, минус 2, p, e. В общем, чему угодно могли быть равны.
Практически.
Поэтому мы можем попытаться подогнать такие красивые значения, вот чтобы там формулы пересчета были максимально удобны.
Вот. Предлагается сделать следующее. Смотрите, сейчас такая мистическая штука.
Так, давайте вот эту матрицу берем, чтобы она нас не спущала.
Значит, что у нас тут будет?
Значит, мы скажем, мы введем мистическое число w.
W-n. Ну, для каждого n мы будем свое w вводить, правда?
Для каждого k скорее.
Ну, для каждого n в смысле для каждого k, да, это идентично.
Так вот, ну, обычно его все-таки w-n обозначают.
Значит, w-n...
Значит, на...
Вот давайте я так скажу, да, вот в эту сторону t3, а в эту сторону t2.
Да, вы правы, спасибо.
Значит, w-n будет обладать следующими мистическими свойствами.
Я очень хочу, чтобы w-n в степени n было равно 1.
Нет, внимание.
Но при этом я хочу, чтобы w-n в степени n пополам не было равно 1.
Этого достаточно.
Вот.
Да, в действительных числах, конечно, этого добра для m больше, чем 2 мы не найдем, правда?
Но, с другой стороны, а кто сказал, что мы обязаны жить именно в поле действительных чисел?
Ведь есть такие замечательные поля.
Например, там поле по модулю 9,9,8,2,4,4,4,3,5,3.
Да, и вот, хорошо, n равно 8, там поле f3.
И где ты такое w там найдешь?
11.
Да, и прям там найдет, чтобы восьмая степень была равна 1, а четвертая неравна.
Учитывая, что они там в десятые все равны, не тягится.
Вот проблема, да?
То есть, на самом деле, если вы хотите делать это в каком-то поле, то крайне желательно, чтобы это было поле по модулю P, которое равно...
Так, какие буквы-то подобрать-то?
Ну, не совсем.
C на 2 в степени c, c на степени k.
На степени l, давайте.
C на 2 в степени l плюс 1, ну, где c обычно нечетным просто берут.
И желательно, чтобы l было больше либо равно k.
Я утверждаю, что по модулю такого P...
Ну, просто да.
Пусть у нас есть простое число вот такого вида.
Тогда я утверждаю, что такие wn в нем найдутся.
Ну, в принципе, если я просто произнести два слова первообразный корень, то, скорее всего, вы уже догадываетесь, откуда я эти wn возьму, правда?
То есть, вот, например, так.
Ну, или другой вариант такой популярный, как все используются, это, конечно, поле еще комплексных чисел.
Ну, а в поле комплексных чисел, т.е. wn, это просто...
т.е. wn у нас будет тупо, ну, там, чаще всего пишут, z в степени 2 pi поделить на n.
Так, знакомое заклинание?
А наукотечее это было?
Нет, опять же не наукотечее.
А, наукотечее, только это, дирекля начался.
А, аки, ну мало ли.
Дирекля, дирекля большой.
Он и не закончится еще.
Ну ладно, хорошо, ладно.
Главное, что это все знает, т.е. мы сейчас не должны с вами вводиться, что это такое, как там устроено умножение этих комплексных чисел, почему там при умножении углы складываются, они перемножаются.
Вот это все не надо, да?
Великолепно, великолепно.
Значит, смотрите.
Ну, просто, на самом деле, нам только вот эти свойства, вот этих свойств, только этих и надо.
Ну, потому что, да, потому что, видимо, Тихон, когда тут это сразу стал выпить, что мне тут что-то не хватило, видимо, имел в виду, что очень хотелось бы, чтобы все степени w от 0 до n-1 были попарно различны, правда?
Да.
Ну, давай смотреть.
Дело в том, что...
Ну, давай так, смотрите.
Ну, во-первых, у числа w, n есть порядок, да, т.е. это минимальное число r такое, что w, n в степени r равно 1, да?
Ну, при этом он делит степень в 1, значит, он сам делит в 1.
Ну, вот, да.
Т.е. легко показать, что этот r, т.е. если у нас вот для n это верно, то r должен быть его делителем.
Ну, понятно, потому что если для n это верно, для r это верно, то это верно и для их gcd, там просто алгоритмы Мифклида можно это найти.
Там n-r, в общем.
Поэтому r должно быть делителем n, но с другой стороны, заметим, что у нас все делители n это степень и двойки.
Вот.
Но заметим, что если бы у нас порядок был меньшей степенью двойки, чем само n, то уж тогда в степени n пополам тоже было бы равно 1, а этого не равно.
Так что на самом деле, что приятно проверять достаточно только это.
Ну, заметим, я еще так аккуратно писал, я мог бы тут описать равно минус 1, потому что на самом деле в любом поле если число не равно 1, а квадрат равен 1, то число равно минус 1, правда?
Так, в любом поле.
А, ну да, в любом, конечно.
Разность квадратов работает в любом поле, да.
Вот.
Так вот.
Значит, что нам это wn дает?
А дает она нам примерно следующее.
Сейчас мы опять разобьем этот многочлен на 2.
Но, внимание, не путайте, я еще тоже буду называть а0, а1, но это...
Так, вот так.
Так, я вот это тоже сотру.
Забудьте все, что мы рассказывали в школе.
Не, ну как сказать.
И еще все, что мы рассказывали в школе.
Ну да, забудьте все, что мы рассказывали в школе, а потом через 5 минут.
Ну, ребят, вы что, это программа седьмого класса.
Так.
Нет, ну тут я просто оговорюсь то, что сейчас мы просто, скажем так, мы перегрузим обозначение, вот так.
Ладно, переобозначение.
Перегрузим.
Чего?
Нельзя просто так взять какое-нибудь обозначение.
Надо, пожалуй, либо на область видимости.
Чего должно быть?
На область видимости.
Либо...
Все, да, да.
А, точно, давай, давай.
А, то есть предлагаете сделать перерыв после этого, вводить вообще новое обозначение, да?
А сколько там времени?
А, давайте, сколько там времени реальности?
10-40.
Не, ну точно перерыв надо.
Или не надо.
Ладно, отлично, давайте.
Давайте.
Пока просто рассмотрим вот такое число, и мы стали обсуждать, где его взять.
Вот основное, где его берут.
А камера работает, да?
Да.
Значит, ребят, что там за обозначение?
Да, то есть основная фишка заключалась в том, что мы его брали либо берется чаще всего в комплексных числах,
либо вот в целых.
Значит, зачем нам это нужно?
Вот, поехали.
Значит, вот сейчас мы и скажем, как же это нам все делать.
То есть как же нам по коэффициентам восстановить значение в именно этих n точках.
А вот как, смотрите.
Значит, мы разобьем многочлен на два.
Значит, смотрите.
Значит, смотрите.
Но на этот раз будет верно, что a,t у меня будет равно, а потом не скажу пока, чему равно.
Я напишу два многочлена.
a0 и a1.
Но они теперь будут работать вот по такому принципу.
Значит, a0 плюс a2t плюс a4t в квадрате плюс плюс plus an-2 на t в степени n пополам минус 1.
И, соответственно, a1.
То есть, видите, вот разницу.
То есть, раньше я делил просто тупо.
Младшая коэффициент старше, а теперь коэффициенты с чётными индексами, коэффициенты с нечётными индексами.
Да, тут очень хочется сказать, чётные коэффициенты и нечётные коэффициенты, но лучше так не говорить.
Вот, значит, a n-1, а t в степени n пополам минус 1.
Красота! Благодарю.
Значит, поехали.
Значит, a t равно...
Ну, тогда можно из этого всего легко заметить, что a t равно a 0, a t плюс a 1, a t и t.
Так, да. Какие ещё символы? Да, надо добавить правильства, чтобы оно стало верным.
Ну да, на самом деле, да. То есть, что интересно?
Да, то есть мы обнаружим, что, оказывается, надо просто сюда подставить квадрат.
Ну, тогда, значит, теперь думаем, чтобы...
Ну вот, а теперь давайте заметим следующее.
Вот зачем мы эти числа брали?
Мы эти, естественно, то есть мы хотим сказать, вот t-шки, это что такое?
Ну, в качестве t-шек они у нас теперь будут просто числа w n в степени 0, w n в степени 1 и так далее, w n в степени n-1.
Вот мы ровно эти числа и хотим.
Вот.
Ну а теперь давайте посмотрим, а что будет, если я эти числа возведу в квадрат?
Что будет?
Ну, будет, соответственно, w n в степени 0, w n в степени 2, w n в степени 4 и так далее, w n в степени 2n-2.
Ну, казалось бы, те же самые числа.
Те же, но с маленьким нюансом.
Дело в том, что где-то тут в середине у нас возникнет число, ну там будет w n в степени n-2 и тут будет w n в степени n.
Ну и дальше будет w n в степени n-2, ну и так далее.
Да, но за w n в степени n напоминаю, у нас равно 1.
Вот.
Но тогда отсюда автоматически следует уже просто по свойствам там произведений там всяких степеней.
В общем, короче, школьная алкебрия уже тогда становится очевидна, что тогда вот эта штука равна w n в квадрате.
А здесь получается там, это получается w n в степени n-2.
Вот.
То есть получается, что реально различных чисел среди этих квадратов у нас получается сколько?
n пополам.
Но тогда чем это приятно?
Это приятно тем, что тогда у нас получается вот многочлены a0 и a1, они тоже размера n пополам.
И фактически нам требуется, вот, чтобы восстановить значение n пополам в дружных там точках, нам нужно, чтобы a0 и a1 найти их значение вот в этих n пополам точках.
Но что самое приятное, w n в квадрате, ну, если, конечно, n не слишком маленькое, можно вполне себе воспринять как число w n пополам.
Потому что заметьте, что оно в степени n пополам равно, естественно, единице, правда?
Но с другой стороны, если я его зведу в степень n пополам пополам, то есть n на 4, то у меня получится w n в степени n пополам, что не равно единиц.
То есть видим, что w n пополам вполне может быть использованным для наших, для таких целей.
Очень удобно.
То есть фактически, то есть нам нужно, на самом деле, чтобы перемножить значение на n, нам нужно найти одно w n вот такое.
И, соответственно, просто про теперь n. И когда мы будем запускаться рекурсивно, как вы уже догадались, мы будем запускаться рекурсивно.
То есть мы будем просто предлагать в качестве w, в качестве каждого следующего w, предыдущее w в квадрате.
Всё.
То есть таким образом мы получаем маленькую приятную вещь.
То есть мы получаем, то есть таким образом нам надо просто запуститься рекурсивно от многочлена a0 и a1, видите, да?
Значит, a0 и a1, а потом, ну вот, а потом получить эти n пополам значения, а потом просто за o от n вот по этой формуле их насчитать.
То есть вот такая вот у нас возник эта идея.
Вот. Ну, в какой-то момент, вот, возможно, даже сейчас нам всё-таки будет стоит написать код.
Вот. Потому что всё-таки в этом месте придётся поговорить всё-таки не только о том, как это делается математически, потому что математическую суть алгоритма, в общем-то, я уже почти рассказал.
Думаю, думаю отсюда очевидно, почему алгоритм работает за n лог n, правда?
Да. Да, с маленькой оговорочкой, да.
Теперь вот, чтобы разобраться полностью в математической сути, что нам нужно?
Нам нужно только понять, действительно, а как делать обратно?
Вот спрашивается, как делать обратно?
Минус?
Нет, нет, нет.
Ну, во-первых, не минусы сопряжённые, а во-вторых, на самом деле, я бы сказал, один велить на wn лучше взять.
Вот так. Ну, потому что в комплексных числах это одно и то же, а в простых числах такого нет.
Значит, смотрите, как же, значит, прямое мы сделали, да?
А теперь вот идея такая, смотрите.
Как делать обратное? Внимание.
Значит, вот прямое, когда мы делали, вот a1, a2, там, a0, a1, a2 и так далее, an-1.
Значит, мы применили вот это преобразование там с коэффициентом wn и получили ещё какие-то числа.
Вот давайте я их тоже тут назову, допустим, b0, b1, b2.
Нет, смотрите, прямое, но очень просто, смотрите.
Мы разбили этот многочлен вот на такие два, запустились рекурсивно от многочленов размера n пополам,
вычислили в этих многочленах n пополам значений в степенях вот этого числа,
а потом, пользуясь этой формулой, восстановили n значений самого многочлена a.
У нас была задача посчитать значения многочлена a в n точках.
Ну да, и мы ровно вот с таких.
Мы посчитали значения многочленов в два раза меньше количества точек, в два раза.
Вот, понятно? Вот что мы делали.
То есть вот мы получили какие-то значения b0, b1, где вот, соответственно, вот это вот b житое у меня равно,
соответственно, теперь просто будет a от a житого.
А теперь идея такая.
Давайте попробуем применить к этой штуке внезапно тоже, то есть еще раз вот сказать,
давайте b, это у меня тоже теперь значения, это какие-то коэффициенты многочлена мистического.
И, ну вот, я тоже для них сделаю вот эту всю операцию, но не с числом wn, а с числом 1 делить на wn.
Почему 1 делить? Ну вот.
Ну, заметим, что число 1 делить на wn этим же свойствам удовлетворяет, правда?
Ну а давайте посмотрим, что же у нас на самом деле получилось.
Ну, получились какие-то числа c0, c1, c2 и так далее, cn-1.
Вот.
Да.
А здесь теперь давайте расписывать.
Здесь у меня по определению c житое, это сумма по всем l от 0 до n-1.
Ну давайте я пока от t напишу.
Это будет такая сумма как t в степени l на...
А, нет, так не получится.
Значит, смотрите, нет, просто c житое это число.
Значит, это у нас будет такая штука, как, соответственно, 1 делить на wn в степени жи.
Все это в степени жи и все это в степени l.
Вот так я пока аккуратно напишу.
И, соответственно, на коэффициент b.
Видите, да?
Ну, то есть фактически я сказал, что если я воспринимаю b как многочленный и применяю вот это преобразование...
Ну ладно, что вы хотите, оно называется fft, да.
Не, оно просто fft, fast Fourier transformation.
Вот.
Fourier 7 букв.
Логично.
Вот.
Значит, смотрите.
Так, ну давайте теперь подумаем, чего это равно?
Давайте просто чуть-чуть это...
Позанимаемся раскрыванием скобочек.
Так, то есть l равно 0, n-1.
Так, значит, теперь давайте...
А, ну у нас в общем-то ладно.
Так, ну что?
Какую еще буковку ввести, учитывая, что и и к заняты?
Под индекс.
Под суммирование еще одну.
И, ну и у нас минимальная единица есть.
M.
K.
Ну ладно, M так M.
Ладно, так и быть.
Значит, получается тут такая штука, как aMt на w, соответственно, n в степени M.
Умножить на...
Значит...
Значит...
Да, 1 делить на...
А, ну да, сумма вот такая.
Да, и получается, да, 1 делить на это.
Ну, давайте кюрих это и в степени g.
Видите, да?
Вот.
Так, как-то что-то не так, да?
Да, потому что...
А, так что да.
А, вот почему да.
Потому что у нас тут g умножить на M, конечно.
Фу.
А g как у нас удается?
А.
Ну потому что bg, то есть это a, то g.
Это то же самое, что сумма там...
Так.
Тьфу.
Ой-ой-ой.
Ненавижу буковки писать, да.
Вот на самом деле, как вот.
Вот это же у нас определение, правда?
Вот.
То есть это равно...
Значит, сумма, значит, это там какого-нибудь...
АL-то умножить на WN в степени g в степени L.
Во.
Ну L понятно.
Вот.
Значит, а перечень.
Что это такое?
Значит, если мы теперь все это будем суммировать как-то по-другому,
то есть именно давайте сначала по M, а потом уже по всему остальному,
то тогда что у нас получится?
То есть будем суммировать M от 0 до M-1.
Чего дальше будет получаться?
Значит, aM умножить на какую-то странную мистическую сумму.
Значит, а именно тут будет WN в степени g умножить на M-L.
Вот.
Соответственно, где у нас тут L бегает от 0 до M-1?
Вот.
Видите, да?
Ну вот, давайте смотрим теперь.
Ну вот, теперь внимание, вопрос.
Что же это вообще такое?
Ну, не совсем.
Тут M все-таки, а не L, правда?
Ну, это не совсем.
Тут M все-таки, а не L, правда?
Вот.
Ну вот, тут как сказать?
Заметим, что...
Чего-чего?
Очень хочется сказать.
Ну, куча ли?
Ну, давайте смотреть.
Ну да.
Что...
Ну вот, WN у нас такой по циклу ходит.
Во-первых, да, заметим, что это геометрическая прогрессия, правда?
Это геометрическая прогрессия, которая начинается в числе WN в степени gM и имеет шаг.
Шаг, она имеет WN в степени минус gL.
Согласны?
Да.
Ну, когда мы... вот здесь мы переписывали, да, помнишь?
Хотя, погодите, погодите, погодите.
Вот, тогда все хорошо, только тогда где-то еще L должен быть.
Вот здесь еще L должен быть.
Вот.
А, теперь да.
То есть просто мы теперь выносим, то есть будет у нас теперь выносится тут L, а тут будет M минус g.
Во.
Да, тогда начинается, да, вот тогда все хорошо начинается.
Да, да, да, да.
Значит, тогда, значит, L и тут вообще соответственно тоже.
Тут же L.
И что дальше?
Так, ну к чему у нас, правда?
Ну, как бы, мы помним, что если у нас есть какой-нибудь там, вообще есть у нас есть какая-нибудь прогрессия там q, q2 и т.д., q в степени там, а у нас там член сам N минус 1,
да, то вот эта вот сумма у нас вообще к чему равна?
Q в N.
Да, она равна q в N и минус 1 делить на q минус 1, да?
Секундочку, можно мы пройдемся по всем шагам с самого начала, потому что у меня какой-то куча константов и ничего.
Хорошо, q2.
Значит, B-шка по определению, вот она, да?
Давайте C-шка, в C-шке наоборот, Cgt по определению, то же самое только с B-шкой.
То есть BLT на WN в степени g, только в нашем случае 1 делить на WN, да?
То есть 1 делить на WN, все это в степени g, и все это в степени L, да?
Да, отлично.
Теперь мы пытаемся посчитать Cgt.
Значит, мы это прям честно написали.
После этого не менее честно расписали каждое BL.
То есть это вот сумма aMt на WN в степени...
А в этом случае не только чак M-g.
Да, нам же надо просто...
Так L делить на единицы и при чаке M-g.
То есть просто M-g.
Ну, L ушла.
Куда оно ушло?
L было светло, L было снизу.
Или у вас шеф этот цикл?
Ну и что? Они же не сократились, они же вычислись.
Нет, у L паттернолога находится единица.
А так как у нас мы каждый раз на WN делим M-g.
У вас L это цикл.
И что?
Получается 1 или слога.
Что такое это?
А, то есть имеете в виду, что шаг будет M-g.
А первый член будет...
Так, сейчас L равно...
Ну да, просто единица.
Еще удобнее.
Хорошо.
Ладно.
Так, отлично.
Это мы что-то посчитали.
Тогда получается по этой логике мы честно пишем,
что M равно 0, N-1.
Соответственно тут АМТ.
Вот эта сумма равна теперь...
Получается так.
Вот эта штука в степени N.
То есть WN в степени N умножить на M-g.
Минус 1.
Поделить на WN в степени M-g.
Минус 1.
Но WN в степени N равно единице.
Единица в любой степени равна единице.
1-1 равно 0.
1-1 равно 0.
Вывод.
Сожитое равно 0.
Почему это подозрительно?
Потому что вообще говоря мы проделывали такую операцию,
которую, как мы знаем, можно проделать и обратно.
Ну, знаю в смысле в принципе, правда?
То есть по каждому.
А так получается, что если в два раза сделали операцию,
у вас всегда получится 0.
Да, круто.
Мы доказали, что любой многочлен на самом деле нулевой.
Многочленов не существует.
Ура!
Все.
Ну вот.
Спрашивается.
Что ж не так?
Что ж не даст нам возможности сказать, что это все у КТЧ,
надо в топку кидать.
Ну, косяк.
А что такое?
Ну, к сожалению, есть такая маленькая подлянка,
что она работает только при Q не равно 1.
То есть если Q не равно 1, тогда да.
Во-первых, это формула корректно.
Во-вторых, да, вы можете домножить на Q минус 1.
И там тогда все пошлеп-шлепается.
Да.
Вот.
Поэтому нам надо оговориться, что конечно у нас все вылетит,
кроме того случая, когда Q все-таки равно 1.
Но когда у нас эта штука равно 1?
Ну, естественно, в том случае, когда у нас ж равно, очевидно, m, правда?
То есть и жили были у нас два числа от 0 до n минус 1,
и вычислось одно из другого, и получилось что-то, делящееся на m.
Ну, соответственно, очевидно, это могло быть только когда они равно.
То есть получается это...
Ну вот.
То есть на самом деле по-хорошему надо написать теперь так.
То есть это равно.
То есть вот это вот мы суммируем по всем m, но при этом m не равно ж.
Значит мы это суммируем.
То есть это действительно 0.
Плюс переговорочка, а что получается, когда m равно ж?
Ну тогда тут просто все единички, тут получается тогда n умножить на аж.
То есть в переводе говоря, это просто равно n умножить на аж.
Вот такой маленький лайфхак.
Да.
То есть смотрите, то есть вы...
То есть обратите внимание, то есть вы просто
чтобы сделать обратное преобразование...
То есть чем обратное отличается от прямого?
Вы запускаете его просто от абсолютно того же...
То есть абсолютно такое же преобразование, как и было,
только в качестве Wn подсовываете 1 делить на Wn.
Вот.
Или в случае комплексных можно подсунуть сопряженное, но это будет одно и то же.
Все.
Нет, не все.
Потому что делаете, а потом результат надо еще на n поделить.
Видите, да?
Вот.
То есть ни в коем случае не забудьте поделить на n.
Собственно все.
То есть вот таким вот образом мы поняли, что прямое обратное преобразование в Fourier
работают за, вот, например, n лог n.
Ну вот там, как всегда, да, в каких-нибудь правильных предположениях...
Там, типа, по крайней мере, в предположении, что там либо у нас простой...
Мы нашли простой модуль, который там...
У которого там степень двойки больше, чем n.
Да?
Ну вот.
Либо мы верим, что точности, с которой мы вычисляем эти все синусы-косинусы, нам хватит.
Можно сказать верно, ведь, что нужно гарантировать такой модуль, который мы нашли.
Ну гарантировать нужно, чтобы...
Ну нам нужно гарантировать, что он имеет вот такой вид.
Сейчас, секунду.
Откуда вопрос?
Давнограмма модели, в которой мы в этом работаем,
предполагает, что размер входных данных вмещается в ячейку.
Ну...
То есть, если раз, типа, длина будет n, то n может на некоторую константу влезать в ячейку памяти.
Ну я бы сказал, n в степени некоторой константы влезает в ячейку.
Да, конечно.
Ну да.
Вот, вопрос, хватит ли нам такой гарантии, что...
will such YooQ- interessiness, что нам подходящие в этом смысле слова?
А не будет ли у нас какого-нибудь переполнения по этому простому модулю?
Ну, если мы уже делаем переполнение п-
произведение по этому простому модулю, то переполнения не будет,
просто потому что мы при каждом умножении будем брать остаток.
Но нет, переполнение в смысле в том, что мы, на самом деле, получим неправильный ответ
А правильно ответ на вот этот поле?
Ну да, ну я...
Что кондиционты тоже будут по модуле.
Ну тут оговоречка, что мы в принципе и занимаемся тем, что перемножаем многочлены вообще-то в этих полях.
А хотелось бы, чтобы...
Вот.
Ну вот. Нет, то есть да, потому что чаще у нас, конечно, проблема, что мы хотим перемножать целочисленные многочлены,
и желательно, чтобы у нас не получилось, чтобы мы умножили 5 на 5, а получили 4.9999820149.
Вот, да, вот. Конечно, хотелось бы.
Но правда, ну вот.
Но тут, на самом деле, да. Тут, конечно, тут уже более практические оговорки.
Нет, ну во-первых, конечно, тема того, насколько большие коэффициенты должны быть,
ну вы просто знаете, что если вы перемножаете два многочлена размера n,
и каждая коэффициент не превосходит, допустим, c какой-нибудь большой константой, да?
То тогда мы замечаем, что в произведении каждый коэффициент не будет происходить просто c² умножить на n, на самом деле.
Вот.
Но тогда получается n, ну вот.
Но на самом деле можно сказать, что и само n не превосходит какой-то константы c, правда?
Можно сказать той же самой, обычно так и говорят.
Поэтому получается, что у вас в процессе могут просто получиться эти числа в кубе. Все.
Они получатся в ответе.
Да.
Но у вас, например, получится n на жутко.
Кего получится?
У нас получится n на эти числа.
То есть c в четвертую уже.
Ну, условно, да.
Вот.
Но тем не менее, ну вот.
Ну, вроде когда-то.
Можешь, кеша, да, аккуратно вычислять.
Ну вот.
Но обычно об таких мелких уже не заморачиваются.
Вот.
Тем более, что знаете, тут какой чит.
Нет, просто чит заключается в том, что если мы говорим о перемножении многочленов, то нам...
Ну, хотя нет, конечно, да.
Все-таки нам не стоит утверждать, что мы перемножаем абсолютно произвольные многочлены.
То есть на это нам плевать какие тут числа.
Потому что, да, если у нас бесконечно большие числа, то любые многочлены можно перемножать за 1.
Понимаете как, да?
Нет, ну в смысле, просто давайте подставляем в эти многочлены очень-очень-очень-очень большое число t.
Ну, я не знаю там буквально.
Буквально это самое c в степени, я не знаю, n.
Может даже с запасом.
Объявляем его основанием системы счисления.
Объявляем эти числа.
Создаем их там в этой клок-клок.
Нет, ну тут еще хуже.
Потому что, нет, конечно, на 10 четвертой, но, смотри, давай так.
10 жили, были 10 четвертой, да?
Размер, типичный размер многочлены у нас 10 пятый, 10 шестой, да?
Сколько мы сказали c, n квадрат?
Ну, тогда еще сколько это? 6 на 2, 2х4, 10 четвертой.
Золомгин? Золомгин пока не убили.
Нет, n 10 шестой, а c квадрат 10 восьмой.
Что?
10 пятой, а ты с квадратным квадратом.
Так, да, проблема.
А может и нет?
В такие случаи открываешь пасхарм, там где-то прикрыты.
И кто-нибудь открывает, но нам проходит в заводчике писать.
Да, ну да, получается, 10-20-1.
Придется что-то уменьшить.
Ну, обычно, по крайней мере, на 10 пятый хватит.
Впрочем, тут другая проблема,
потому что на самом деле тут вообще уже просят считать аккуратно,
потому что, например, в комплексных числах, если применять комплексные числа,
то там еще и всякие эти дроби будут.
Поэтому чем больше n, тем больше может накопиться какая-то мерзкая погрешность.
Поэтому такая практическая рекомендация такая,
опытный факт, что крайне желательно,
чтобы результирующие коэффициенты у вас были где-нибудь до 10 в 12,
тогда вы можете сказать, что давайте получим,
в ответе мы получим какие-то числа, давайте просто их округлим до ближайшего целого.
Плюс одна вторая, и раунд работает хорошо.
Ну да, или раунд.
Если плюс одна вторая, тогда можно floor сразу писать.
Как округлить число по математическим правилам?
Ну просто да, то есть это прибавить к нему одну вторую и округлить его вниз.
То есть не что-то такое, а просто вот оно.
Будьте внимательны, потому что какой-то раунд, еще вопрос, куда будет округлять,
там отрицательные числа.
То есть тут как всегда, либо прямо прокопать этот вопрос, либо просто жестко.
Знаешь, раунд это какая-то гадость, а вот floor округляет жестко вниз,
cell округляет жестко вверх.
Вот cell вот так вот пишется.
Поэтому если вы хотите округлить число до ближайшего целого,
то на самом деле вот просто формальная математическая комбинация.
То есть округлите вниз число x плюс 0,5.
Ну как у нас округляет число по математическим правилам?
Как вы пришли к округлению числа?
Дело в том, что дефолтная реализация FFT пишется через комплексные числа.
А комплексные числа это там какие-то даблы или лонгдаблы.
То есть там даблы, лонгдаблы, синусы, кассинусы, перемножение какие-то, вот это все.
Поэтому в итоге в конце, если мы перемножали целые многочлены,
то мы, наверное, должны получить целый многочлен.
А получим какую-то дабловую гадость.
Скорее всего, там близкую к нам, но не совсем ту.
То есть вместо пятерки мы получим 4.999999998980149.
Вот чего? Не, ну наверное не настолько все-таки. Вот если это будет там это 4 миллиона, то там
возможно уже и начнутся такие проблемы. Вот поэтому говорят, что до 10 в 12, да тут вот действительно
аккуратненько, то есть это еще работает, а вот дальше лучше уже поаккуратничать, если у вас там
коэффициенты больше. Как поаккуратничать? Ну как бы если у вас коэффициенты до миллиона, допустим,
да, то каждый коэффициент можно, например, сказать, что он равен мелкий коэффициент плюс 1000 на еще
один мелкий коэффициент. Ну условно там сказать, что скажем, каждая ожитое у меня, допустим,
равно ожитое штрих плюс там 1000 на ожитое в квадрате. То есть такое, то есть тогда получается,
там у вас в принципе получится, что на самом деле АТ, например, будет работать а штриха Т
плюс 1000 на а2 штриха Т. Но правда умножение получится чуть больше, но зато они будут более
железобетонными. Ну вот, ну или там по каратсубе как-нибудь еще можно. То есть такие вот,
такие вот тут еще иногда лайфхаки возникают. Вот. Да, обязательно. Нет, ну и пока это вот. Вот.
Ну тут да, наверное, вот. То есть описать это действительно так отдельно. Пишешь сколько там у нас
времени? А, нормально у нас времени. Отлично. Вот. Значит поехали теперь. Ладно. Ну по математической
части понятно. Значит давайте теперь попробуем это написать. Значит давайте сейчас будем очень
внимательно это писать. Ну начнем с самой тупой версии. Но правда я сразу давайте я для, там скажу,
что у меня сразу у меня есть тип Т. Это вот, то есть это у меня есть вот мистический тип Т, который
вот и поддерживает все вот эти там операции. То есть я не буду прописывать вот там комплексный,
он там простой и так далее. Что? Ну да. То есть можно сказать, что да. То есть можно было бы
сказать, что давайте это попишем на шаблонах. Ну как сказать, на языке Си на самом деле шаблон в
некотором смысле прекрасно делается. Ну на уровне там пишете все с типом Т, а в начале пишете
defineT. Ну да. Зачем defineT? Давай defineT комплекс longDouble. Вот как удостоен. Так вот. Значит смотрите.
Значит как же мы это будем пытаться реализовать? Вот. Значит делать мы это будем примерно следующим
образом. Ну значит смотрите. Ну самое тупое, что можно было бы сделать, вот давайте совсем,
совсем тупое. Это конечно пишем. Вектор Т, fft. Да. Пишем только прямое, потому что с обратным мы уже,
обратное мы делаем, используя вот это fft как черный ящик. Мы уже запомнили это, да. Значит передать.
Можно маленькое отступление перед этим? Давай. Какая-то магическая шарашка, которая говорит, что если применить прямое в той два раза, а потом развернуть всех эфициток кроме первого, и что там еще сделать, типа опять залить на N. Да. Только развернуть не весь массив, а массив без дулевого элемента. Да, тоже будет работать, да.
Нет, я могу просто повторить вот эту вот запись и увидеть. Да, просто проверить. Да, так тоже работает, да. Ну по-разному, в общем, да. Нет, отдельно, да. То есть отдельная песенка. Ну да. Ну, роспись та же. Ну нет, просто суть там будет том, что там будет, тут у тебя минус степень GL, а там будет плюс GL. То есть поэтому там просто шаг
будет не WN в степени M минус G, а будет шаг WN в степени M плюс G. Поэтому у тебя получится, что CGT равно там что-то типа A там N минус G, на самом деле.
Ну почему-то, ребят. Вот. Поэтому и разворот. То есть нулевой совпадет. Вот. Ну я говорю, просто лучше вот в качестве упражнения просто распишите и вот, да. То есть типа вот, да. Так вот, дайте, я так и напишу. Упражнение.
Сделайте то же самое только тут WN. Вот. То есть, да. Это магическая шарашка есть, да. Ну это же не шарашка, а просто даже прикольная вещь, да.
Чтобы вы там еще не делили, там еще не спрятали. Вот. Что? Нет, делить, наверное, придется. Но одно дело делить. Да. Вот. Да, брать обратное не придется.
Значит, поехали. Значит, так. Перейдем в вектор INTA, тут мы даже не заморачиваемся даже там об ссылку, потому что не надо нам этой ссылки, на самом деле. Вот.
И, но самое важное, по крайней мере, с моего FFT я очень люблю передавать вот это мистическое WN. Что? А потому что все равно мы там все ими кидаться там будем туда обратно и так далее.
Ну, потому что тут два варианта. Понимаете, если я могу кинуть ссылку, а могу даже константную, ну, желательно тогда сразу константную, в таких случаях тогда если мы собираемся вектор возвращать,
тогда у нас два варианта. Либо мы переберем позначение, либо константная ссылка. Потому что когда вы, короче, не по константной ссылке, значит вы сигнализируете в том числе себе, что вы этот вектор собрались менять.
И тогда вам, как бы, в документации функции, по крайней мере, мысленной, требуется себе жестко прописать, как конкретно вы это собираетесь менять.
Константная ссылка. Это что?
Это запись вида конст вектор T.
Значит, что программа функции не имеет права менять.
То есть, как вы знаете, это две разные вещи. Вот этот конст означает, что функция не имеет права этот параметр менять.
Ну а персант меняет, что?
Как это да. Лайфхак. Хотите увидеть лекцию первыми? Приходите на нее.
Работает иногда. Более того, у вас есть эта фантастическая возможность интерактивного общения.
Да, да, да. Диалектист старших поколений это называется задавать вопросы очно.
Нет, более того, кстати, есть так тоже. На самом деле, один бывший завкафедр, ныне покойный Михаил Абрамович Ройнберг,
он вообще рассказывал, что некоторые предметы, на самом деле, иногда в Америке практикуется такой интересный момент.
Такой вариант, когда на самом деле таких вот классических лекций, когда приходит преподаватель, что-то такое рассказывает, их нет.
Ну, логика следующая, что все, что обычно рассказывается на таких лекциях, наверное, где-то написано. Правда?
Более того, по большинству предметов есть учебники даже. То есть, например, тот же мотоналис, например.
То есть, вам уже на первой же неделе выдали просто учебник по мотонализу, где там большинство этих ТРМ так и написано.
Поэтому там предлагается логика такая, что вам предлагается, что называется, зачем тогда слушать лекции,
если вы просто тогда читаете эту штуку, а на занятия приходится для того, чтобы задать вопросы лектору.
Вот. И тогда лектор будет на них отвечать. Вот, особенно есть такой интересный метод.
Вот. У нас он пока, правда, не практикуется.
Вот. Ну, Саша.
Ну нет, у нас был такой лектор, но, по-моему, долго он у нас не принадлежал.
От него остались запистики.
Нет, знаете, такой баланс, что все-таки как-то что-то не то. На пятом курсе к нам пришел такой лектор, на самом деле.
Он сказал, знаете, я мог бы вам почитать лекции по моему предмету, но у меня в логу. Почему? Потому что на сайте интуитру они уже висят.
Вот. Поэтому знаете, что, давайте-ка вы лучше послушайте эти лекции, сдадите там курсы, и я вам тогда хор поставлю.
Хор. Да, хор.
Ну вот. А потом отл, ну, давайте это надо, давайте еще там, вы там еще какую-то презентацию сделаете.
Только давайте, презентацию сделайте в конце, но давайте вы мне в течение две недели, в двух недель еще договоритесь, что и так далее.
Вот. Ну, а чем, в общем, сами понимаете, долго не придержался, короче, он у нас.
Ну, то есть нет. На пятом курсе, главное, тут баланс определенный. Получится, что с одной стороны, как бы, что-то не то, с другой стороны, конечно, спасибо ему огромное, что как бы, называется на, называется там, у нас было на две пары меньше в неделю.
То есть, знаете, на пятом курсе, когда все работают, обычно это уже как бы лишняя пара, это скорее уже, скорее такая-то техническая сложность.
Вот. Ну, это пока, да, то есть нет. Вот. Ну, у нас такого нет, ладно, давайте вернемся к делу, так, интересный момент.
Значит, смотрите, так, вот у нас вектор, там, по константной ссылке, не по константной, вот. Значит, у нас есть Wn.
Ну, конечно, с чего нужно начать любой рекурсивный алгоритм?
Ну, конечно же, да, еще, конечно, мы предполагаем, что размер этого многочлена степень двойки.
И Wn здесь соответствует. Ну, можно прям так и прописать. Я даже себе пропишу int n равно a.size.
Да, поэтому надо начать, конечно, где, то есть, конечно, для самого маленького.
Если оказалось, что n равно 1, то, так, а как же нам делать эту, действительно, во что превратиться многочлен, если у него размер 1?
Да, то есть, заметим, что если многочлен у нас размера 1, то что это за многочлен? Это константа.
Нам нужно заменить его коэффициенты на значение в одной точке, если быть точнее, в единице.
Но это значение совпадает с этим коэффициентом, свободным членом.
Поэтому мы тут просто не заморачиваемся и пишем return a.
Ну, тут нечему заморачиваться.
В противном случае, в хороших код-стайлах обычно одну строчку стараются не писать, по-моему.
Ладно, значит, поехали.
Значит, теперь, вектор t.
Ну, теперь давайте, значит, создаем a0 и a1.
Вот.
Значит, дальше пишем for int, значит, i равно 0, i меньше n, i плюс равно 2.
Тут мы и говорим.
Значит, в a0 мы запихиваем it-коэффициент.
Ну, погодите. Сначала мы пишем это просто в самом тупом виде.
Как-то правильно.
Да, обязательно. Да, конечно.
Что мы делаем теперь?
a0 равно fft, значит, a0 и Wn умножить на Wn.
Значит, a1 равно Wn умножить на Wn.
Если бы.
Нет, нам еще теперь вот эти восстановить надо.
Надо.
Значит, теперь смотрите.
То есть нам нужно пробежаться по степеням.
Но смотрите, как это хитро теперь можно сделать.
То есть чтобы подставить это квадрат.
Значит, на самом деле теперь это можно сделать так.
for, значит, int, допустим, j равно 0, j меньше n пополам, обратите внимание.
Но я тут, ладно, вы поняли.
А, можно и так писать, плюс-плюс.
Да, плюс-плюс j.
Значит, теперь у нас просто будет идея такая.
Чему равно ajt?
ajt должно быть равно a0 plus Wn в степени j на a1 от jt.
В чем проблема? Wn в степени j.
А0 jt.
Не a2 jt, не a1.
Сейчас.
Должен, должен.
Вот где это должен быть квадрат?
Например, в 2 jt.
Типа a2 jt.
Вот так посчитайте.
Ну да, но понимаете, в чем проблема?
Дело в том, что Wn в степени 2 jt, казалось бы, должен быть квадрат.
Но помните, мы же считали 2 jt.
И Wn в степени 2 jt будет как раз в jt элементе этого a0 и a1.
Нет, я хочу другое.
Я хочу написать j plus n, пополам.
Ну, и сейчас вы поймете почему.
Ну, опять, тут степень j, ну понятно, тут пишем степень j.
В степени j plus n, пополам.
На a1 jt.
Обратите внимание, да, потому что, да.
То есть мы уже обнаружили, что там просто по второму кругу идет те же самые числа.
И вот теперь можно объявить return.
Значит, a.
Честно говоря,
мне очень понятно.
А jt?
Это a0 jt.
Чего? У тебя формула обязательно для OMEA должен быть.
Так, давайте...
То есть еще...
Нет, ребят...
Да, господи, ребят, давайте распишем просто аккуратно.
A0 jt,
это a0,
это a0, точки jt.
Значит, а0 jt равно,
значит,
по определению,
значит, a0 в
wn пополам
wn пополам
в степени j, правда?
Это равно,
или что, то же самое, a0 от
wn в степени 2 j.
Вспоминаем определение.
Ну вот, по определению a0,
это равно a0
плюс a2
wn в степени
2 j,
плюс a4
wn в степени
4 j,
плюс и так далее,
плюс a n-2
на
wn
в степени
2 j
умножить на
n пополам минус 1.
Логично, да?
Или что, то же самое,
это на самом деле j умножить
на n-2, правда?
Чего?
Какой звоночек?
Ну да,
особенно когда тут написано
подозрение на спам.
Да, вот это
хорошее сообщение.
Звоночек, скорее всего, так себе.
Ладно, давайте,
как говорится, будем игнорировать спам.
Вот, значит, смотрите.
Вот получилась такая штука.
То есть мы,
ну вот,
но тогда получается,
если эта штука такая,
а a1 от j у нас будет
аналогичным образом равно
то же самое, только тут a1, a3
и так далее,
плюс a1, плюс a3
на wn в степени
2 j,
ну да,
2 j, плюс
a5 на wn в степени
4 j, плюс ну и так далее.
Но тогда получается, смотрите,
если я, то есть фактически,
вот тогда получается,
что мне надо?
А, ну да,
потому что смотрите,
если мы сейчас вот эту штуку
домножим на w,
вот эту штуку теперь домножим на wn
в степени j,
то тогда что получится?
Тогда замечаю, что
вот эти 2 j у меня превращаются в 3,
тут, соответственно, 3, 5,
тут, кстати, 1 вылезет.
И тогда получается,
что у нас при каждом коэффициенте стоит
wn в степени j
и в степени, соответствующей этому коэффициенту.
Тут соответствует,
и тут соответствует, все.
Вот, то есть получается,
вот тогда мы пишем ровно то, что надо.
То есть вообще вот в идеале
вот можно прям вот так было бы написать
пробежаться for ing от 0 до n.
Но, но вот,
но по некоторым причинам мы пишем
здесь вот это.
Ну, давайте еще тут оговоримся сразу.
На самом деле, как вы догадываетесь,
значит,
ну ладно,
по крайней мере мы сейчас как-нибудь от балды,
правда, сделав вот это известное допущение,
конечно,
мы такие все-таки себе FFD
как-то насчитали, да?
Что у нас wn
в степень j умеет так возводиться.
Как бы и сэмпи.
Чего?
Не-не-не, вот смотрите,
у меня тут записано wn в какой-то степени.
Ну, в языке C++ такой конструкции
нет.
Да, но на самом деле, да, вот сразу,
то есть это я сейчас просто для удобства формулы,
да, на самом деле, но на самом деле
так, для того, чтобы ее хорошо насчитывать,
значит, тут просто чем это приятно,
значит, одна из просто важных
оптимизаций заключает в том, что на самом деле
можно домножать тут сразу на wn в степень и пополам,
да, ну, можно
просто взять вот эту wn в степень j
и сразу домножить на wn в степень и пополам.
Да, она равна минусу единице,
поэтому на самом деле
у нас тут ничего нет, то есть тут есть умножение,
просто здесь надо написать
минус.
Видите, да?
Вот.
Ну, то есть да, то есть можно
в принципе, то есть на самом деле
по-хорошему код будет выглядеть так.
t deg, вот так я пишу,
deg wn равно
там условно 1
или там в скопках от единицы,
да?
И тогда у вас получается примерно следующая
штука. Так, где у меня тут
орудие труда?
Вот она.
Так, то есть на самом деле
по-хорошему совсем,
то есть надо написать вот так.
Вот.
Минус deg.
Тут минус deg.
Значит,
соответственно, а на самом деле еще
и конечно тут написать, что deg умножить
равно wn.
Вот.
Вот.
Ну, знаете, умножение работает,
думаю, гораздо быстрее, чем подсчет
косинуса, правда?
С другой стороны, точность, да.
Поэтому тут конечно возможно
где-то нужен определенный баланс.
Ну, вот.
Ну, вот.
Ну, вот.
Нет, на самом деле этот момент
тоже важен, на самом деле.
Действительно, это уже касается
точности.
В первую очередь тут мы все-таки ориентируемся
на скорость.
Потому что на самом...
Нет, ну, потому что на самом деле
смотрите.
Вот.
Ну, потому что тут значит
ну, как тут можно
оптимизировать по скорости?
Ну, во-первых,
конечно, одна из важных вещей,
которая нам жутко все тормозит, она на самом деле
ну, вот это на самом деле рекурсия, правда?
Не сама рекурсия.
Рекурсия маленькой глубины она уже не тормозит.
Тормозит у нас все количество
перекопирований, которые мы делаем.
Ну, да, рекурсия к перекопированию.
Да и вектора тоже.
Ну, правда, вектора мы конечно тут
это не перерисайзим, конечно,
поэтому, может, не так.
Перерисайзим, пушбеки делаем
без этого перерезаева.
Ну, могли рисайз сделать.
А мы же говорили, вектор надо...
Вектор они меняли? Чего?
Ну, они векторами меняли.
Ну, с другой стороны, смотрите, да.
Ну, вообще, в идеале, то есть первая цель,
которая у нас сегодня будет, это
попробовать написать FFT, вот действительно,
не выходя за пределы вектора.
То есть сейчас она у нас, видите, вот
он получает вход вектора, возвращает вектор,
а будет он void-овская функция,
которая будет получать вектор по неконстантной
ссылке, просто его перешаманивать.
А лучше даже не
векторомассив.
Вот такая у нас мечта.
Ну, а дальше, смотрите.
Ну, вот, давайте,
то есть вот семантику, вот я сразу
давайте рядом начну писать новый код.
Там, где бы мне его писать?
Ладно, это уже не надо нам.
А что нам
надо? Да просто свет
в оконце.
А что нам
снится? Что кончилась
война.
Куда иду я?
Вот так, где светит
солнце.
Лишь только, братцы, добраться
будет темно. Да.
Ой.
Как это называется? Что старше?
Песня или вы?
Так.
Ладно.
Та перча, смотрите. Чем мы сейчас
займемся?
Итак, вой, господа.
Значит, вот в идеале
хотел бы написать вот fft, причем
более того, вот совсем вы
не знаете, что такое c++, да?
Вот вы на сях кодите, вот давайте.
Вот.
Заказывали? Вот, пожалуйста.
Вот.
Что?
Да.
Ой, ничего. Сначала
шок, потом чуть поменяли,
получилось годно.
Вот.
Итак.
Значит, что мы тут хотим? Ну, понятно, что
ладно, начало-то логичное.
Ладно, тут, в общем-то, я думаю, сопротивление
бесполезно.
Да, это не интересно.
Значит, что дальше?
Ну, в идеале, конечно,
в идеале, конечно, хотелось бы, то есть
если бы прям тупо переписывать, то мы должны
создать через там какую-нибудь неюшку два новых
массива, там
что-то их куда-то там покопировать,
значит, их тоже заффтэшить, а потом
применить преобразование, да?
Ну, может, это даже чуть быстрее будет работать,
а может и нет.
Потому что, в общем-то, там, то есть
возможно, от вектора наполнут,
ну, то есть если особенно не pushback,
это будет примерно то же самое происходить.
В конце концов, думаете, откуда он
дополнительную память себе берет?
В конце концов, по дефолту, из той же
неюшки. Ну, может быть, вы
конечно ему подсунули какой-нибудь аллокатор, но
да-да-да, вы не знаете
таких слов, да?
Да, таким не ругайтесь.
Вот, значит, что делать?
Ну, тут теперь смотрите, какая у нас сегодня к вам
интересная фишка.
Вот давайте теперь вот внимательно
посмотрим вот на вот этот вот
форик, я вот почему-то его написал вот в таком
мистическом смысле, да?
В мистическом виде, да?
Да, возможно, из-за минусика.
Но теперь заметим следующее, что на самом
деле, если
бы А0 и А1,
вот представим себе, что жил бы у нас массив
А0, вот массив А,
и мы каким-то образом мистическим
сделали,
что у нас вот в тех же самых
вот ячейках лежит вот, тут лежит
А0, а тут лежит А1.
Ну, в смысле вот
вот так, на самом деле.
Тогда, смотрите,
какая ситуация. Тогда я вот выражаю,
что вот это преобразование,
это преобразование,
тогда можно было бы, то есть,
без всяких лишних копирований элементов,
спокойно проделать.
Потому что вы берете числа
А0 житое и А1 житое,
вот которые находятся
вот там здесь и здесь,
вычисляете вот эти два числа
и записываете их ровно сюда же.
Единственное оговорка, что вам бы пришлось сохранить
какие-нибудь переменные.
Да.
Ну, почему один?
А, ну, в этом плане, да.
То есть, ну, лишней памяти от единицы,
это понятно, да.
Вот.
Ну, я просто в том плане, что вот
я просто хотел обратить внимание,
что конкретно этот код вот в этом виде
работать не будет. Да.
Я только на это хотел обратить внимание, не более.
Потому что у нас пока более интеллектуальный
вопрос.
А как вообще так элементы переставить?
Магия.
Да, магия, да, да.
Как это? На самом деле, да.
О, рандомно, да?
Да.
А, рандомно шахлит, пока не окажется,
что порядок тот, который я дал, да.
Ну, да, мы такую сортировку
уже обсуждали, да.
Вот, окей.
Вот, но на самом деле
возникла следующая мысль.
А на самом деле конкретно вот так переставлять
чтобы вызваться рекурсивно нам не надо.
Потому что давайте задумаемся вот о чём.
Ой, как хорошо, что у нас есть большая доска.
Да, да.
Да, не знаю.
Большие примеры запутывать нельзя,
как по мне, по-моему, иногда хистой
наоборот. Чем больше пример, тем как бы он
десей.
Ну, по ситуации.
Ну, с другой стороны, да.
Но с другой стороны, нет.
Я помню, нет. У меня был хороший пример,
как я в своё время
в первые вообще понял,
понял, что такое отложенная операция
на дереве отрезков.
То есть, там просто на лекции они предлагались
на дереве глубины, ну, по-моему,
максимум 3.
Или, может, 2,2.
Пошёл там на перемене
выспрашивать, он говорит, так ладно.
И Лев, кстати, это Капилёвич и был,
он говорит, так, ну ладно.
Значит, тогда, раз у нас то время есть, можно рассмотреть
больше примеров, нарисовал больше.
И вот на большем примере как-то сразу всё ясно стало.
Да, ну, продукт, да.
Но с другой стороны, сейчас у нас ситуация будет ближе
к деревоотрескам, чем к логарифам.
Так как тоже глубина логарифам тоже разделена пополам,
в общем.
Значит, поехали.
Значит, нет, я просто, чтобы было явно,
я пишу вот такой пример.
Ну, обычно, мне кажется, там вот 16,
вот 8, мне кажется, это сейчас мало будет.
Ну, а вот 16, я верю,
всё-таки хватит.
Согласен.
Ну ладно, давайте.
Ну да, если там будет
давайте, да.
Можно, но
не очень-то иду, что да.
Так. Итак.
Значит, давайте посмотрим.
Как они будут вообще перешаманиваться?
Ну, на первом уровне
они перешаманиваются так, что
сначала будет идти
а0, а2, а4,
а6, а8,
а10, а12,
а14.
А потом
значит, а1,
а3, а5,
а7, а9,
а11, а13.
То есть, если мы в начале
переставим
эти коэффициенты вот таким образом,
научимся,
то тогда у нас получится.
То есть, фактически, код
в дефолтной версии мог бы выглядеть так.
То есть, тут шамань, шамань, шамань.
После этого запуск
значит, мы бы сказали
значит, мы бы себе сказали
t, допустим, vn2
равно wn умножить на wn.
И дальше мы бы себе сказали
fft
значит,
fft от a0 пополам
и vn2
и fft
от a плюс n пополам
n пополам vn2.
Вот.
То есть, как бы от первой половины
массива, от второй половины массива.
То есть, в массиве мы так делать умеем. Ура, правда?
Хорошо.
Вот.
Ну, а дальше мы тут вот
называется нот
дальше начали бы развлекаться.
Уже напишем.
Далеко ходить.
deck vn равно 1
значит, и дальше пишем там for int
там e равно
g равно 0, g меньше
чем это пополам
plus plus g.
Соответственно, мы пишем там t, u
равно
Чего deck?
Где?
Вот.
Значит,
пишем
ajt
равно
u плюс
deck wn умножить
на
v
ну, и здесь соответственно
aj plus n пополам
равно u
минус deck a.
Что не так?
Мы там
не использовали никакие aj
пополам.
Все, все, все.
Вот. Так.
А, ну и
deck wn умножить
равно wn.
Все. А. И на этом все.
Никаких этих ваших ретурнов лишних.
Вот. То есть, по идее
вот такое. Только единственная проблема,
что мы не очень
понимаем, что такое шамань-шамань. Правда?
Давайте его не делать.
Как таки?
Как таки делать?
Значит, затыть.
Ну, действительно, оказалась идея следующая.
Что да.
То есть, у нас тут получается, мы делаем шамань-шамань
и рекурсию.
Но на самом деле заметим, что
ну, вот, да, тут
надо очень аккуратно сформулировать так, чтобы не
придраться, что формально происходит не так.
Но на самом деле
действительно, что когда мы тут запускаем,
то все эти элементы тоже шафлятся. Правда?
А потом, когда они у себя рекурсивно
пошатаны, то они тоже шафлятся. То есть, в итоге
действия устроены так,
что мы можем сначала сделать все шафлинги,
а потом
сделать все, наоборот, вот эти
слияния.
Вообще говоря. Правда?
Ну, вот.
Ну, вот. Ну, тогда
давайте внимательно подумаем, как же это сделать.
Сделаем это так.
Ну, давайте подумаем, как тут этот шафлинг будет устроен дальше.
Ну, дальше мы видим
А0, А4, А8,
А12, а также
А2, А6, А10,
А14.
Тут очки
А1, А5,
А9, А13
и тут А3, А7,
А11,
А15.
Вот.
Вот.
Ну, вот.
На этой глубине тут уже
все просто. А0, А8, А4,
А12.
Дальше тут А2,
А10, А6,
А14.
Вот. Тут у нас
соответственно А1, А9,
А5, А13.
И тут еще
такой А3, А11,
А7, А15.
Вот.
Ну, и на самом деле еще один уровень рекурсии.
Ну, да.
Ну, пока, ну, вот.
Поэтому по факту, да,
вы уже видите, в каком порядке нам на самом деле
надо переставить эти элементы.
Пока я их тут вот этот ряд переписываю,
вот, собственно, попробуйте
найти закономерность.
Да.
Сами понимаете, что это не совсем рандом-шафленный массив.
Вот так.
До-шафленный массив.
Ну, вот. И теперь вот давайте
смотреть, что ж получится. Что ж ты за
следовательность индексов?
В скобках нет.
Ну, математика не совсем
мистик, да.
Вот.
Вот. Справивается.
Чего?
Да.
Поразительно. Я не могу в это поверить.
Чего?
Мы метим, что
между, вот, если ты посмотришь
элемент, и тот, который от него стоит,
они четыре.
Через два элемента там
ты их свапнуешь, то они неожиданно выходят.
А там обосьме один, а один свапан.
Тут все элементы такой же обосьмой свапаной.
Да.
Первое восьмой, второе, четвертый,
третья, пятнадцатый.
А некоторые не свапаны, а тут постоят
на одном месте.
Кто же они?
Да.
Мистик очень простая.
Давайте просто двоечность системе счастливей
и все эти индексы запишем.
Ну, как бы, это все четырехбитные числа.
Вот, смотрите.
0 это 0000.
8 это 1400.
4 это 0100.
12 это 1100.
Да, да, да. Начинайте догадаться,
почему я их так быстро пишу.
Там вот так вот.
1010.
Вот, да.
Ну, может, я просто, конечно, очень круто
знаю двоичное представление чисел там,
потому что я там, ну, я не знаю,
программист.
Вот.
Так вот, так вот, да.
Нет, или я просто,
или я просто догадываюсь, по какому закону
они тут расписаны все.
Во.
И чего стало понятно?
Ну, потому что это, типа, взяли просто чиселки
от 0 до 15.
Да, но важно, взяли
именно в четырехбитном виде.
Да, именно в четырехбитном.
Потому что, обратите внимание, если вы разберете вот это число
0100, если просто поразворачивать,
то может получиться единица.
А нам нужно, чтобы получилось не единица, а получилось
число 0100.
Фу, наоборот.
Да, 0100. Где оно у нас?
Число 0100.
А, 0100.
Вот оно.
Вот. А чтобы разворачиваем,
получаем 0010. Да, вот оно.
Вот. Ну, правда, формально говоря,
может это совпадение?
На самом деле, нет.
Потому что, по большому счету,
мы на самом деле отсортировали числа от 0 до 15.
Причем отсортировали очень хитро.
Мы их отсортировали по младшему индексу.
То есть, по младшему биту.
Ну, что значит? Сначала
четные, потом нечетные.
Значит, мы отсортировали сначала такие,
потом те, у которых
младше битной.
Потом внутри,
следующий парад,
мы сортируем по второму по младшести биту.
Видите? Сначала 0, потом единица и так далее.
Поэтому по факту, наверное, ничего удивительного в том,
что если эти четырехбитные представления тупо
развернуты, то мы просто по этим
четвертым представлениям их и посортировали.
Правда?
Причем более того, учитывая, что
если взять все числа от 0 до 15
и их четырехбитное представление развернуть,
то получится все числа
от 0 до 15.
Просто записанное
чуть-чуть в другом порядке очень сильно.
Но, с другой стороны, по каждому числу
теперь очень легко определить,
где оно находится.
Вот, например, троечка. Вот у нее
представление, допустим,
там, допустим, 0011.
Значит, в ней
должно находиться число 1100, а она сама,
ну, то есть она сама 0011
должна быть там, где вот 1100.
1100 это сколько у нас?
12. Да, вот оно.
Вот. То есть таким образом надо
просто действительно все...
То есть, оказывается, чтобы их изначально переставить,
вам на самом деле нужно
времени N
умножить на, а за какое
время вы там реверсите числа.
Ну, не константа
будем числами. Там все-таки
N log N в этом месте будет.
Мы можем просто
пройтись
по каким-нибудь числам. Если чтобы
это сделать, нам нужно посвапать
какие-то пары числа. Да.
Вот.
Своей.
Своей. Его
не XOR, а разворот.
И если пройдемся так по всем,
от 0 до J, то мы все числа посвапаем
по два раза, и ничего не произойдет.
Да, но мы свапать будем
по одному разу.
Да нет. На самом деле
нет, есть...
Нет, смотри. На самом деле есть
в этом смысле хак простой.
Просто
да, 4 значит int J
равно 0,
J меньше N
плюс-плюс J, и говорим,
что если
оказалось, что J меньше,
чем рев от
там допустим
называется J и N,
мы же передаем N, чтобы понимать
сколько бит реверсить, да?
Ну, можно и N, да. Можно N,
можно K, там не суть важна.
Но, соответственно, свапа.
J, T, а вот этого рева.
Ну, по-хорошему, для оптимизации неплохо
было бы этот рев, конечно, вычислить заранее.
Ну, не заранее, а в смысле
вычислить, а потом эту переменную два раза
использовать.
Но это уже локальность. То есть, на самом деле
вот эта вот вся магия,
она вот предлагает просто
уже избавление от рекурсии, дальше
вот эту вот штуку теперь надо просто реализовать
немножко по-другому.
То есть, уже внутри каких-то больших циклов.
Вот.
На самом деле вот так получается.
Ну, на самом деле, скажем так,
да, очень большие,
то есть, на самом деле очень большие желающие
могут на самом деле
попробовать проделать вот эту
махинацию на самом деле за
отн.
Ну, вам, возможно,
придется вот эти вот операции
просто прибавлять единичку к концу
прям столбиком.
Но заметьте,
вот представьте себе, что вы прибегаетесь
по числам от нуля до пятнадцати,
ну, там или от нуля до нм,
и к каждому числу прибавляете прям столбик
единичку.
Да, суммарно
это будет отн. Почему?
Потому что вы в половине случаев
будете делать одно действие.
То есть, сколько у вас там получится?
Там n пополам раз у вас получится
единица.
Значит, плюс
умножить на два, плюс n делить на восемь.
То есть, мы уже вот этот ряд вычисляли
и понимали, что
это на самом деле не происходит
n на константу.
То есть, в данном случае
можно это даже прям пощупать.
Потому что на самом деле
мы просто говорим, можно сказать, что
первым битом вы работаете n раз,
со вторым битом вы работаете
n пополам раз,
там с третьим битом вы работаете
n делить на четыре раз, ну и так далее.
То есть, поэтому суммарно
вы там изменяете там 2n бит.
Поэтому на самом деле
рев можно предпочитать даже
за о от н.
Ну, конечно, от n логн
мы от этого не избавляемся,
но тогда получается, что вот этот вот блок
начинает быть максимально
важным для нас.
Мне об этом неизвестно.
Ну, обычно тут не заморачиваются
и вот пишут прям буквально вот так,
где...
Нет, просто вы сами... Нет, я тут имею в виду,
что функцию рев вы пишете сами,
и вы ее пишете прям в тупую,
прям вайликом.
Ну, типа, все равно n логн называется
глобально не будет.
Так что этот n логн будет, конечно,
очень быстрым по сравнению с вот этим
n логном.
Пока это не n логн, пока n, но давайте
теперь смотреть, что же у нас тут
без рекульсии появится.
Значит, еще раз.
Значит, что же это за такое?
Ну, значит, теперь мы
будем переходить по уровням.
Ну, у нас уровни, значит...
То есть, нам теперь нужно пройти снизу вверх.
Ой, спокойно.
Значит, тут перейти про l равно 2,
4, 8 и так далее до n,
и тут пробежаться по всем массивам длины l,
и проделать
эти слияния, правда?
Значит, поехали.
Значит, то есть, работать будет так тогда.
Поехали. Значит, for
теперь int l
можно сказать равно 2.
Значит, l
меньше либо равно
n
l умножить равно 2.
Ну, понятно, вы тут, конечно, любители
там совсем битовых оптимизаций могут написать
x, y, z равно 1, естественно.
Вот.
Но я подозреваю, правда, что оптимизатор
это за вас делает.
Да, ну вот, так же, конечно.
Так вот. Значит, поехали.
Ну, начнем
с того, что нам бы не помешало вычислить
w, l.
То есть, потому что нам эти слияния надо делать
не по w, n вот этому, а по
w, l.
Ну, который, так сказать,
ну, у которого w
должно быть в степени l равно 1,
а не в степени n, правда?
Ну, сделать это достаточно просто.
То есть, пишем, значит,
объявляем себе локально
t w, l
равно w, n
и, действительно, for
int там, допустим,
там, допустим, n, n
равно n, там, n,
n, n больше l, n, n
там, n, n
boom равно 2
w, l умножить равно
w, l.
Понятно, откуда я это взял?
Ну, как вы смотрите, вот на этом уровне у нас
в качестве w выступает число w, n.
На этом w, n в квадрате.
Следует, на этом
w, n в четвертом. Тут w, n в восьмом,
ну и так далее.
Поэтому, видите, я просто, типа, опускаюсь
с уровня n до уровня l и возвожу
число в квадрат.
Спокойно.
Ой, Господи.
Что это называется? Знаете, как мне вчера
не везло?
Ой, собственно, мясо.
Ну, собственно, а, ну, часть из вас даже были свидетелями
отчасти.
Вот. Ну, те, кто на тренировку пришел.
Вот.
Значит.
Идем дальше.
Что у нас тут происходит?
Ну, а значит, теперь.
Значит, пробегаемся по всем этим
массивам.
Значит.
Значит, пишем, значит,
for, говорим мы.
Int, значит,
где этот массив начинается?
start, он начинается с нуля.
Там start должен быть меньше n.
Start
плюс равно,
соответственно, l.
И вот внутри
мы работаем с массивом,
начиная с st, до
st плюс l не
включительно.
Вот полуинтервал. Видите, да?
Так. И что у нас тут получается?
Так.
Ой, а можно это вот это вот выделить
и вот сдвинуть вот так вот, да?
Так было бы хорошо.
Но увы.
Значит, ладно, давайте.
Значит, смотрите,
что у нас тут будет получаться.
Во.
Значит,
тут будет получаться примерно следующее.
Значит.
Ну, внутри себя, да, придется, конечно,
пока ввести, по камере, пока так.
По камере, давайте, вот, аккуратно надо вносить
изменения в коде, то есть не все сразу, а так
по чуть-чуть. Значит, поэтому
deg, как мы пишем,
degVl у нас равно 1.
Ну, и дальше мы пишем
fort, соответственно, int
j равно 0,
j меньше, l
плюс, плюс j.
Пишем нашу эту вот любимую
классику, да?
tu равно a,
на этот раз не j, а st
плюс j, обратите внимание.
Значит, t, v,
что?
Чего, чего, чего?
Все хорошо.
Это хорошо.
Так, значит, равно
u плюс,
значит,
degVl умножить
на v. И, конечно,
st плюс
j плюс
l пополам
но u минус
degVl умножить
на v.
Так, ну и, конечно, degVl
надо домножить на vl.
Пока вроде тоже нормально.
Оп.
Так, ну, что там, ой, сколько закрывать там?
Оп, оп, оп.
Так, выйдет вот так. Этот fort закрыли,
этот fort закрыли, этот fort закрыли.
Вот.
В таких случаях, тадам!
Вот.
Такая вот магия.
Значит, что же у нас такое
теперь?
Что же у нас такое?
Получилась теперь у нас
такая нерекурсивная версия,
но кода в ней, в общем-то, даже
не стала, по-моему, сильно
больше, чем тут.
Ну, на функцию рев где-то, правда?
Но, оказывается, и это не предел
оптимизации.
Ну, потому что
как еще можно это
неосимпатически, конечно, оптимизировать?
Ну, кроме того, что эту штуку считать
за o от n, а не n лога.
Ну, на самом деле, мы понимаем, что
вот эта вот часть,
вот эта вот часть,
она, конечно, она нам
просто откровенно
самая жирная,
поэтому константу, прежде всего,
надо оптимизировать, собственно, именно в ней.
Вообще такой принцип оптимизации
несимпатической, что в первую очередь
надо посмотреть на узкие места,
то есть части кода, которые работают больше всего.
Вот больше всего, раз
у нас, на самом деле, что выполняется?
У нас больше всего выполняются вот, собственно,
вот эти вот пять строчек, правда?
Поэтому как бы хочется
пооптимизировать именно их.
Ну, что здесь самая жирная оптимизация,
самая жирная операция в них,
это, конечно, умножение.
Их три штуки.
Но, как вы уже видите,
тут есть напрашивающийся способ,
как эти три умножения
превратить в два, правда?
То есть можно просто вот эту штуку
то есть на самом деле
можно удобно сделать так, то есть
в на самом деле надо сделать не просто
эту штуку,
а сказать, что она еще
равна умножить
на degv.
Тогда у нас тут получается, я пока
за тряпочкой скажу, шлеп-шлеп.
А, вот она.
То есть просто шлеп-шлеп,
и в результате у нас остается у плюсовая
и у минусовая.
Да, кстати, вот
такая вот приятность.
То есть, в принципе, это уже одна из
серьезнейших оптимизаций, на самом деле,
получилась, потому что умножение
все-таки операция жирная.
И мы их только что тут в нужном...
Вообще, если говорить о количестве умножений
комплексных ну или каких там у вас чисел,
то мы их только что сократили
практически в полтора раза.
Ну, есть вот это вот, но это мелочь.
Вот.
Значит, ну, что еще
тут можно было бы сократить?
Ну, по-хорошему говоря,
да, тут, конечно, можно понадеяться на оптимизатор,
но вообще говоря,
по умолчанию вот эта штука вычисляется
долго.
Ну, по-хорошему давайте вспомним.
Как вообще вот, например, а вот от этой штуки
будет вообще вычисляться?
Как он будет понимать, где ему искать?
Ну да.
Ну да, то есть это говорит, что он просто
возьмет адрес начала массива А,
то есть как указателя.
Да, ну вот.
Нет, зачем он?
Да, он просто там.
Ну, по сути, самое главное для нас, что он просто
к указателю придется прибавлять вот это вот все.
То есть вычислить вот это вот все,
потом прибавить еще к указателю.
Но по большому счету
теперь заметим...
Вот сейчас я превращу этот код в
совсем магию,
вот поэтому я все последовательно
надо делать.
Но заметим на самом деле следующее.
Вот помните, мы же говорили о том, что нам
последовательный доступ к памяти, он крутой,
правда?
Вот, кстати, да, еще одно, почему этот код крутой работает,
потому что, видите, он тут
на самом деле бегает по массивам
последовательно, обратите внимание.
То есть когда у вас есть два массива, которые он сливает,
то есть он как бы вот бежит
фактически вот так вот двумя указателями,
и они двигаются одновременно,
видите, да?
Вот.
Поэтому
на самом деле, мы вместо
того, чтобы вот тут делать вот эти прибавления,
мы могли бы хранить два указателя
и просто им делать плюс-плюсики,
правда?
То есть поэтому, значит, на самом деле,
значит, теперь...
Что?
Главная оптимизация.
Ой, да, да, да.
Вот.
Особенно для, когда это указатель,
это вообще, значит, в результате получается...
Кто кокнет?
О, Господи.
Господи.
Мало нам Андрея Михайловича,
у нас еще и компилятор кокает.
Значит, смотрите.
Так что теперь
смотрим, получается так.
Поехали. 4.
Нет.
Потому что
мы вместо, значит,
вводим указатели.
Ну, я их под лирией назову.
Укабигин.
Ну, от русского слова ука, естественно,
они тоже.
Украина, это уа.
Ук, это United Kingdom, вообще,
по этой логике. Не путать.
Вот.
Ну, вот так. Поэтому ука это указатель.
Вот.
Так, значит, укабигин у нас будет
так и равно. А плюс, соответственно,
СТ.
Значит, Т звездочка
укамид.
Хотя по барабану, на самом деле.
Нет. Ну, хотя...
Ну, давайте так.
Я вот просто до красоты напишу.
Понятно, что я сейчас напишу кучу лишнего, но
укамид.
Да. Прямо это.
United Kingdom.
Так. Плюс СТ пополам.
И, конечно,
обязательно ука
Ant. А плюс
СТ плюс СТ.
А это не Инт. А это
указатель.
Так что, не-не-не. Тут это...
Как бы редкий случай, но тут у меня
все точно.
Давайте, да.
Так, Т звездочка
L равно, значит, пишем
укабигин.
Вот, ну, я... Пусть у меня будут
эти указатели L и R. Логично, да?
Чего?
Бе-е-е.
Ук...
Хорошо.
Значит, укл
значит, укр
равно укамид.
А теперь
говорим.
Значит, пишем,
что for, я даже
так не пишу, for
работаем мы пока
укр даже не меньше, не
равно укайент.
И тут пишем, значит, плюс-плюс
укл, плюс-плюс
укр.
Вот.
Первое и не меньше, второе
и все.
Чего два раза больше?
Нет, ну, да, на самом деле, да,
заметим, что по большому счету, да, вот эти
можно было не определять, а прям в укай или
укалек прописать, и тут только укайент.
Значит, теперь, значит,
поехали. Теперь, значит, пишем
T
значит, U, значит,
у нас равно звездочка
укр.
Значит, ну, давайте
тут так и быть. Ну, вот.
Значит, atv
равно звездочка,
вот смотрите, тут магия, укр
умножить, тоже звездочка, да.
Видите, да, у меня тут
звездочка большая моя, а тут
сейчас это будет одна и та же звездочка, да.
Значит,
так, derwl
у меня, да. Ну, поэтому я тут
обычно скобочки пишу, чтоб красиво было.
Значит, теперь
звездочка укл
равно у плюс в,
звездочка
укр равно
у минус в,
ну и, соответственно, ну, куда ж
без этого, derwl умножить
равно вл.
Вот.
Вот превратилось совсем, конечно, в магию.
То есть, если вам просто потом в конце
показать, что там вот, ну, рассмотрим
фурьер, он делается таким разделяем и властвуем. Как вы его
написать? Ну, там можно, ну, очевидно,
вот таким вот образом, да.
Ну, тут какая-то вот такая вот.
То есть, так слёт туда не поймёшь.
Хотя это, ну, то есть, знаете,
это если, как Шарлок Холмс говорил, ну, чё
Ватсон, вы это, в
южноафриканские ценные бумаги деньги вкладывать не
собираетесь, да? А, что?
Как вы это, откуда, с чего?
Ну, очень просто, к чему, смотрите, по
по
картинке, между вашим большим и указательным
пальцами, мне было это несложно заключить.
Чё? А как они связаны?
Вот, понимаете, да, вот я просто скрыл от
вас всю цепочку, да?
Вот, соответственно, поэтому вам кажется
магия. На самом деле, связь есть и очень простая.
Но там, связь какая-то уровня, что
якобы, когда вчера вы пришёл, вы вчера
играли, значит, она была начёрта мелом, да? Вы,
я знаю, значит, вы играли на бильярде.
На бильярде вы играете только с одним конкретным человеком,
который месяц назад
предлагал вам, собственно, в эти южноафриканские
ценные бумаги вложиться.
Только вот маленькая пр... Ну, вот, причём более того,
ваша чековая книжка заперта
в ящике моей тумбочки,
вот, и ключа вы меня не попросили.
Значит, вкладывать не собираетесь.
Да, почему, конечно,
чему чековая книжка Ватсона там лежит
в ящике у Холмса остаётся загадкой, конечно.
Ну,
но как бы, другое дело,
но как бы, я думаю, многие из вас догадывают,
знают, что да, что это я ничего
не придумал, там у Конан Дуэлли реально так написано.
О, кстати, а кто этот рассказ читал?
Хорошо.
Нет, ну, просто интересно, мало ли.
Когда-нибудь появится время, и тогда поговорим.
Не, ну, при чём тут время,
лично я обычно в классе в шестом-седьмом
обычно, там, по-моему, такое читал, поэтому...
Давайте корочество на него заставляем читать,
то обычно читать видео не будем.
Ну, как сказать.
Ну, по ситуации. Так, ладно.
Давайте корочество на Жене ещё дважды хотим.
Ещё, а.
Ну, смотрите, дальше уже сомнительно,
потому что, конечно, вот эти умножения...
Да, эти умножения
легко убрать, потому что эти степени
можно подсчитать, тем более, что синусами, косинусами
может их действительно лучше подсчитать чуть по-другому,
там, вычисляя синусы, косинусы чуть побольше.
Вот.
Ну, а, ну, как бы, ну, вот.
Ну, как-то у меня возникало ощущение, что дальнейшие эти оптимизации,
они уже там принципиального
ускорения не дадут, на самом деле.
Ну, вот.
Поэтому там, то есть, хотя это действительно
можно сделать, вот, можно попробовать,
хотя тоже, как, как, вместо умножений
там какие-то беготня по массиву будет.
Есть какая-то сайт, типа, библиотека
всех преднаписанных штук на писах.
Буст.
Она не буст называется, случайно.
Библиотека, типа, просто сайт.
Там есть, не знаю,
продолжение на простое множество, очень быстро,
это неважно, там есть МФП, которая, надеюсь,
в шестой работает, типа, 003,
может 005.
А точно именно ФФТ
или умножение?
Нет, потому что я не знаю, потому что
в мой сказоромане у меня вообще говорилось следующее,
что вот есть какая-то супер библиотека,
которая умеет умножать, действительно, там большие числа
за вот столичко, вот
там сопоставимые циферки.
Но там он говорил, что я там лазил в код
и там, ну, там не все ФФТ делает.
Нет, там что-то какими-то адскими
дефайнами, где-то ФФТ, где-то
Карацуба, где-то втупую там, в общем,
там шамань-шамань, в общем, там
уминали не просто обеими ногами,
а просто собрались, видимо,
это 20 человек и просто всеми...
Да, просто это всей
толпой, на самом деле, это все
упихивали в один тазик, да.
То есть отдельная песня. Так что вот
разные вещи, но, в принципе, вот уже для начала.
Так, ну, в принципе, вот оно.
Вот оно, наше любимое ФФТ.
Ну, значит, парадокс заключается
в том, что, да, у нас сейчас лекция заканчивается
на хорошем логическом месте, потому что
на самом деле сейчас нам... То есть мы будем
в общем много изучать, скажем так,
умножение многочленов
и связанные с ним вещи.
Но парадокс в том, что во многом мы теперь будем
это использовать как черный ящик.
То есть нам не потребуется знать, как конкретно
вы за n-лог n перемножили многочлены.
Ну, в какой-то момент нам
это появится, потому что когда мы будем
осуждать какое-нибудь многомерное преобразование
ФФТ, тут, конечно, без этого никак.
Хотя... А может, нам не удастся
обойтись, правда?
Хотя нет, нам все-таки потребуется, знаешь, что это такое,
что это такое. Но, соответственно, продолжим.
И, соответственно, я думаю, уже после перегрева.
