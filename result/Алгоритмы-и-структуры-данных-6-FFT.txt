То есть, вы в длинном тексте всюду прикладываете строчку длины s, считаете сколько символов совпадает,
сколько отличается, и если отличается не больше чем k, то мы говорим, что это не точное вхождение,
грубо говоря. Количество отличий вот этой подстроки s не больше чем k, значит мы говорим,
что вхождение не точное. То же самое здесь прикладываем, здесь прикладываем, но все подстроки
одинаково длинно рассматриваем, считаем количество ошибок, если их не больше чем k,
то побеждаем. Надо только понимать, что это вхождение не точное. Ну что-то такое. Есть идеи,
как это решать? Для каких токам мы точно делать умеем? Carve 0, Carve 1, да, это вроде был на семинарах,
но Carve 0 это вообще не очень интересно, это просто там кто-то море справит, что угодно,
вот. Carve 1 тоже вроде был на семинарах, если, ну там достаточно жадно типа действовать,
если у меня вот есть t, я хочу понять входит ли вот, начиная с этой позиции строка s не
больше чем с одной ошибкой, давайте найдем наибольший общий префикс вот этого куска и s,
значит это вот какое-то начало, потом символ, который здесь отличен от символа s, ну и дальше
тоже жадно наберем максимальный максимальную по строчку равную там суффиксу нужной длины,
и если совпало действительно вот это вот и вот это вот все кроме символа c совпало с s,
то это не точное вхождение с Carve 1. Ну там можно строчки развернуть и что-нибудь такое сделать,
то есть вам что нужно, вам нужно уметь в позиции и находить наибольший общий префикс вот этого с
s, это делается z функция, если s сюда приклеить слева, а здесь вам нужно проверить правда ли,
что вот эта вот строка равна суффиксу s соответствующей длины, если вы все развернете и
построите z функцию на s,r и t,r, то это та же самая задача, по факту вот так с двух сторон отсюда
посделали и отсюда сделали. Да, справедливые замечания, Carve 1 Modulist тоже умеем делать,
но это прям совсем не интересно и больше тоже гениально. Ну непонятно кстати вот уже,
s-1 как сделать. Ну да, как понять совпадает ли здесь и здесь хотя бы один символ.
И вы читаете единицу надо будет из позиции, когда воздвигаетесь. А как? Я тоже не знаю. Ну
тогда надо вычитать, ну окей, да это можно делать, если уметь вычитать типа, то есть когда вы
сдвигаете окошко в правную единицу, если вычесть из всех индексов единицу, тогда ок, да и так
вроде можно сделать. Согласен, да, согласен. Вот. Ну в общем случае вот непонятно как делать.
Мы хотим это сделать ну за что-то типа t log t. Вот. Да. Ну почти да. Вот. Давайте это пока оставим.
Ну блин, s не больше чем t понятное дело, если s больше, то делать нечего. Вот. Давайте это пока
оставим, к этому вернемся надеюсь в конце лекции, а теперь чтобы научиться решать эту задачу,
мы посмотрим на, собственно, быстрое преобразование Fourier. Неожиданно, да? Вот. Значит, что оно
делает на самом деле? Функционал очень простой. Он берет и перемножает два многочлена быстро.
Представьте себе, что у вас есть два многочлена. Возможно разных степеней. Один n-1, другой m-1. Вот.
И вам хочется найти их произведение. Ну, конечно, это может быть за nm, более-менее по
определению, а не думаю. Но это нас не устраивает, мы хотим построить алгоритм за n log n. Ну если n это
наибольший из степней. Вот. Ну мы его построим. Так, начнем давайте с такого утверждения,
которое вам должно быть знакомо. Что многочлен степени k однозначно восстанавливается по своим
значениям в k плюс одной точке. Существует единственный многочлен степени k, равный,
ну какому-нибудь y1 в точке x1 и так далее, равный yk плюс 1 в точке xk плюс 1, где все точки попарно
различны. Где все x и t попарно различны. Да, да, спасибо. Это правда. Это правда.
Вот. Ну вроде ничего нового, да? Вроде где-то это должны были видеть. Почему, да, значит,
почему он существует? Потому что какой-нибудь интерпретационный многочлен, там, Лагранжа или
Ньютона, ну там можно как-нибудь сделать, да? Как это делается? Например, давайте считать,
что все y, кроме одного нулевые, как построить многочлен, который ноль в куче точек, а вот здесь
вот не ноль. Ну как-нибудь можно сделать. Потом их все сложить, то есть для каждой точке строите
многочлен, который равен нулю во всех, кроме одной, а в этой одной равен y нужному, потом все их
складываете, получаете многочлен с нужными свойствами. Вот. Это существование. А единственность,
ну если у вас есть два многочлена с такими свойствами, вы один из другого вы читаете,
получаете многочлен, равный нулю в k плюс одной точке, а мы знаем, что он многочлен на степени
не выше k, а корней может быть не больше, чем k. Значит он ноль, значит неравный. Вот. Ну не записываю,
потому что это я считаю как бы каким-то пререквизитом, который вы наверняка где-то
видели. По крайней мере, доказывать это не надо, скажу так. Да. Очень сложная, да. Ну, не лень просто
писать доказательства. Вот. Хорошо. Поэтому мы будем делать следующее. Мы будем пользоваться вот этим
утверждением и перенаживать многочлены будем примерно следующим образом. Значит, как будем
перенаживать многочлены? Сделаем следующее. Давайте выберем какие-нибудь удобные точки x1 и так далее,
xk плюс 1. Так, давайте я скажу, что просто их будет одного до k. Удобные в том смысле, что, ну вот в этом
утверждении, какие x не важно, главное, что мы были попарно различны. Поэтому в моей власти их выбирать
такими, какие я хочу. Я пока говорю удобные, потом поймем, какие именно. Тут берем удобные x. Дальше
найдем значение p во всех этих точках и q во всех этих точках. Ну, n вроде как заняты уже. Ну,
k, я не говорю, что k, просто сколько точек я взял. Пусть будет k. Утверждение k плюс 1, здесь k. Это
различные области видимости у вас разные. Вот, потом тогда понятно, что такое r в каждой из этих точек.
Ну, а раз у нас есть значение многочленов по yq в точках, то значение их произведения, это просто
произведение значений. По-точечному, для любого yq. Ну, все, а дальше хочется как-то восстановить
многочлен r по этим значениям. Восстановим r по значению в этих x. Вот, такая схема нашего алгоритма
будет. Давайте сразу скажем, какой нам нужно k. Давайте я прямо сразу скажу, что k у меня будет
степень двойки. Чуть позже поймем, зачем это будет нужно, где это будет полезно. Я буду в качестве k
брать степень двойки. Ну, и чтобы утверждение мое можно было применить, мне, видимо, нужно, чтобы
k было больше, чем сумма степеней по yq. Потому что при перемножении двух многочленов их степени
складываются, но если я живу в r. Вот, тогда у меня k должно быть больше, чем степень r, то есть
больше, чем сумма степеней по yq. Более формально мне нужно было бы сюда вставить следующую фразу.
Сначала выбираем правильную степень двойки, достаточно большую. Нет, не хватит, потому что
мне вот здесь нужно, чтобы точек было больше, чем степень. А здесь степень такая, поэтому k должно
быть больше. Я выбираю вот такое k, почему степень двойки чуть позже поймем, уже в ходе алгоритма,
но все остальное ровно так вот делаем. Значит, что здесь вызывает вопросы? Как делать вот это за
быстро, за инлуген, и вот это? Вот, все остальное как бы линейно, понятно? Вот этот шаг линейный, мне
осталось решить две задачи. По набору точек, посчитать значение я многочлена в этих точках,
и наоборот по набору значений восстановить многочлен. Две противоположные задачи.
Так, ну давайте начнем с первой. И в качестве удобных х я выберу степени,
корни ката степени за единицы в поликомплексных чисел. Я перехожу в комплексные числа,
я рисую внеединичную окружность и говорю, что я рассматриваю все корни ката степени
за единицы. Что это такое? Это конечно единица, потому что один в каты это один, а также все
ее повороты на угол 2p делить на к. Вот эта точка, вот эта точка, вот эта точка, ну и так далее.
То есть я единичную окружность делю на к равных дужек, на каждый из них у меня получается очередной
корень, который, ну там скажем, вот первый из них задается как е в степени 2p и делить на к.
Вот это вот самый маленький, самый маленький корень с минимальным аргументом, с минимальным углом.
А что их искать? Ну вот они есть. Я говорю, я сейчас их буду рассматривать. Так, кто-то умер,
когда я сказал комплексные числа корни ката степени за единицы? Все? Хорошо.
Вопрос, вопрос. Хорошо. Ну, значит, видимо, всем это нормально. Давайте я вот эту штуку обзову
за, или не буду, сейчас, одну секунду. Сейчас, сейчас, сейчас. Ну придется, да. Давайте вот эту
назову Омегой сейчас. Значит, Омегой это у меня будет вот этот вот самый первый корень из единицы
ката степени. Еще раз? Нет, е в степени 2p делить на к, это число просто это самое,
вещественное. И это как раз поворот на угол. Вот, давайте в качестве Омеги возьму вот эту штуку.
И я буду считать значение обоих моих многочленов и p и q вот в этих точках. Не в вещественных каких-то
иксах, а в комплексных. Вот, значит, моя цель это найти значение p в этих точках и значение q в
этих точках. Давайте мы заметим, что они все являются степенями Омеги. Вот это вот Омега в нулевой,
это Омега в первой, это Омега в квадрате, ну и так далее. Потому что умножение на Омегу это как
раз поворот на вот этот вот угол. Так работает умножение в комплексных числах. Хорошо, значит,
меня интересует следующее число. Так, ну ладно, раз уж начал к, давайте с к буду работать.
Мне интересуют такие числа, мне их надо найти. Хорошо, давайте мы восстановим, что такое p.
Значит, я, во-первых, добиваю мой многочлен p так, чтобы он содержал ровный k коэффициентов,
если в нем было меньше, чем k коэффициентов, но у меня изначально n меньше, чем k, потому что k
больше, чем сумма nm. Я его добиваю нулями, если что. Старшие коэффициенты могут быть спокойными нулями.
И считаю, что у меня коэффициентов ровно столько, в скольких точках я хочу посчитать ответ. Дальше сделаю
следующую интересную вещь. Давайте я разобью мной многочлен на четные индексы и нечетные,
и составлю из них два отдельных многочлена. Значит, p0 это будет a0 плюс a2x плюс a4x2 плюс так далее,
ну а p1, соответственно, наоборот, все нечетные. a1, a3x, a5x2 плюс так далее. То есть, я еще и степени
срезал. Я не то что оставил a2x2, a4x4, я еще и степени срезал a0, a2x, a4x2 и так далее. И здесь тоже a1, a3x,
не x, купа x. Вот. Я срезал у них у всех степень. Тогда, триреальным образом выполняю следующее тождество.
Ну, вроде понятно, вроде работает. Но, смотрите, теперь представьте себе, что вы вместо x подставляете
корень из единицы к этой степени. Тогда x квадрат подставляется у вас и в p0, и в p1, и он уже будет корнем
k пополам-то степени из единиц. Но если у вас здесь было число, которое в k-то степени давало 1,
вы его возвели в квадрат, то теперь его достаточно в k пополам-то степени возвести, чтобы получить
единицу опять. Здесь корень k-то степени, значит, здесь корень k пополам-то степени. Если k целая,
и вот как раз, и вот как раз я это буду делать всегда, пока я не спущусь до многочленов там из одного
коэффициента, я буду всегда делить многочлены пополам, и это всегда будет работать, потому что k
это степень двойки, то есть я всегда могу так поделить пополам, что степень, что k всегда будет
четно. На каждом шаге k будет четное, поэтому я изначально взял k в степень двойки. Ну вот.
Значит, если мне нужно посчитать значение этого многочлена в k-точках, то этих многочленов мне
нужно посчитать с значением только в k-пополам-точках. Рекурсивно считаю значения здесь и здесь в тех
самых k по полам точках. То есть, если здесь мне нужны были значения в омега в нулевой, в первый,
второй, третий и так далее, то здесь только омега в нулевой, второй, четвертой, но в всех четных
степенях, то есть в k по полам точках. И здесь тоже в k по полам точках считаю рекурсивное значение этого
многочлена. Потом их склеиваю за линейное время и возвращаю ответ. Тем самым у меня получается наша
стандартная рекуррентная формула, что время ответа для многочлена степеника – это удвоенное время
для многочленов длины k по полам плюс о от k, чтобы склеить два маленьких многочленов, один большой.
Значит, как всегда, t – это k. Согласны? Ну, вроде все просто.
Нет, нет, почему же? Смотрите еще раз. Давайте я чуть-чуть поподробнее напишу. Смотрите,
вот я ввожу процедуру FFT, Fast Fourier Transform, которая принимает, давайте я скажу все, что она принимает.
Она принимает многочлен p, она принимает число k, степень двойки, и она принимает омега, вот тот самый
примитивный корень за днице. И в качестве ответа она возвращает значение p во всех степенях омеги.
Значит, возвращает p в омега в нулевой, p в омега в первой и так далее, p в омега в k минус 1.
Как она устроена? Ну, если k равно единице, давайте условия выхода напишем. Если мы спустились до
уровня, что k равно единице, а значит, и в многочлене p всего один коэффициент, значит, просто константа,
надо вернуть эту константу. Если многочлен константа, то в любой точке константа. В этом случае меня
просят вернуть значение в какой-то точке, но раз многочлен константа, то надо вернуть эту самую
константу. Давайте напишем, что return типа, ну не знаю, a0, а где a это коэффициенты p. Иначе я составляю
два вот этих многочлена p0, p1. Значит, иначе я говорю, что, ну, собственно, вот, давайте перекопирую просто
то, что там написано. Я строю два многочлена. Рекурсивно запускаю fft и прошу найти значение
во всех k пополам точках, которые являются степенями омеги квадрата. Я запускаю рекурсивно для p0 с k
пополам и омега квадрат. Потому что, если раньше меня интересовали значения во всех степенях омеги,
то теперь, когда вот здесь вот у меня х превратился в x квадрат, сюда я буду подставлять только степени
омеги квадрата. Да, ну я сказал, все четные степени омеги. Омега в нулевой, во второй, в четвертой,
в шестой и так далее. Поэтому мне достаточно узнать значение этого многочлена во всех степенях
омеги квадрата. То же самое с p1 я делаю. Это рекурсивные вызовы. Они возвращают набор значений
во всех степенях омеги квадрата. А дальше я за линейное время их склею по такой формуле. Значит,
дальше для любого i я говорю, что p в точке омега вытой, ну для любого i от 0 до k минус 1. Но я знаю,
я по той формуле знаю, чему равно значение в этой точке. А это у меня вернулось из fft вот этого,
это из вот этого. Ну там-то x стоит. Вот, поздравляю, вы написали fft. Ну типа того. Так, я зря стираю
схему. Давайте я не буду ее стирать. Так, хорошо.
Теперь получается, смотрите, мы за n log n выполнили вот этот вот наш шаг. Один из двух сложных шагов,
который пока не понятно было как делать. Мы по многочлену p, по многочлену q нашли значение в
корнях из единицы ката степени. Окей, с этим справились. Теперь давайте вот это вот сделаем,
решим обратную задачу. По набору значений в корнях из единицы ката степени, напоминаю,
мы вот эти x фиксировали в качестве корней из единицы ката степени. Я знаю за линию значение r во
всех этих точках, просто попарно перемножив правильное значение. Теперь нужно восстановить
коэффициенты r. Я знаю его значение, я в корнях из единицы ката степени. Теперь восстанавливаю
коэффициенты. Как восстановить r? Так, давайте я напишу следующее нехитрое матричное уравнение.
Давайте я не буду говорить, давайте я буду восстановить многочлен p. Неважно,
как он называется, мне удобнее будет просто p писать. Значит, давайте напишем следующее.
Столбец значений во всех этих точках получается из столбца коэффициентов путем доножения на
следующую матрицу. Значит, в первой строке будут всевозможные степени омега в нулевой,
во второй строчке всевозможные степени омега в первой, ну и так далее, в последней строчке будут
всевозможные степени омега в степени k-1. k-1 на 0, k-1 на 1 и так далее, k-1 на k-1. Ну это более-менее
определение про что такое значение многочленов точки. Как получается итая строка? Что такое p от
омега в итой? Это мне нужно взять а0 без коэффициента, плюс а1 на омега в итой, плюс а2 на омега в степени
2 и так далее. Ровно это и происходит, когда вы итую строчку отсюда перемножать на этот столбец.
У вас а0 будет перемножаться на омега в степени 0, а1 перемножаться на омега в степени i, а2 на омега
в степени 2i и так далее. Последний будет перемножаться на омега в степени i на k-1.
Да? Чудно. Давайте вот эту матрасу я назову W. Смотрите, что мы сделали? Получается вот
это вот fft, которое я здесь писал, оно сущностно берет столбец чисел коэффициенты p, умножает
его вот на такую матрицу и возвращает набор значений вот этих вот чисел. В каком-то смысле
мы научились перемножать вот такой столбец на такую матрицу за n лог n. Ну там как-то хитро делается,
но по существу ровно это и происходит. Теперь, чтобы сделать последний шаг, мне нужно решить
обратную задачу. Мне нужно по известному набору значений в точках найти набор коэффициентов,
но для этого нужно просто посчитать обратную матрицу, домножить на нее слева и победить. Давайте
я покажу, как она выглядит. Давайте определим такую матрицу. Она очень похожа на W, только
всюду вместо омеги в какой-то степени стоит омега в минус той же самой степени. Я не буду
писать полностью. В i-той строке житом столбце стоит омега в степени минус i умножить на j. Короче,
то же самое, только в степени минус еще дорисовываем. Так вот, я тогда утверждаю,
что W это почти обратное к W, а именно их произведение равно k раз единичная матрица.
Будем доказывать? Ну, вот это последнее утверждение. Конечно, нет, я понял. Ну,
нет, но все-таки надо для приличия. Не-не, мне нормально, спасибо. Ну, смотрите, давайте
перемножим. Даже такое перемножение матриц. Давайте возьмем i-тую строчку в W и перемножим,
скажем, на i-той столбец в W. Давайте возьмем строчку и столбец с одинаковыми индексами.
Что будет здесь? Здесь будут все степени омега в минус i-той умножить на j, а здесь будут то же
самое на самом деле. Здесь будет омега в степени ноль на i, здесь будет омега в степени один на i,
ну и так далее. То есть, по факту, когда я перемножаю i-тую строчку на i-тый столбец,
у меня все попарные со множествами будут взаимно обратными, и их произведение будет всегда
единица. То есть, вот это вот на соответствующей е в i-том столце будет единица перемножения. Я
так n слагаем и складываю, получаю n. Давайте напишем, при перемножении i-той строки W и i-того
столбца W, получим, давайте формально напишу, что это сумма по всем j. Там будет омега в минус
i-той, а здесь омега в j-той будет. Вот, это единица, поэтому это будет в точности k. А это как раз
содержимое клетки ii в этой матрице. На k наедничную как раз на диагонали будут стоять кашки. Теперь
при неравном же. Теперь пусть и неравно же. Значит, перемножение i-той строки и j-того столбца. Ну,
что там будет? Давайте просуммируем. Мне нужен какой-то индекс, пусть будет U. В первой матрице,
то есть W, будет омега в минус i-той, во второй омега в степени U, получается. Нет, порядок тот же,
только минус степень. У меня здесь тоже самое, смотрите, у меня в i-той строке житой столбце было
омега в i-той житой, а здесь омега в минус ij. То же самое, только знак другой. А здесь я меняю
порядок, потому что в одной столбе с другой строка. Ну давайте, сумма по всем U, омега в степени U на j-i.
Так, поскольку j не равно i, то вот эта вот омега в степени j-i это не единица. Да, давайте я обозначу
как-нибудь вот это вот омега в степени j-i за Эпсилон. Тогда здесь написана диаметричка прогрессия.
Омега в степени, эпсилон в степени U просто. Ну а геометричкой прогрессии мы суммировать умеем.
Я не умею, но, наверное, вы умеете. Что, простите? Это еще более умно. Я геометричкой прогрессии суммировать
не умею, а вы. Короче, вот так вроде будет. Геометричка прогрессии, правильно? Ну все, а это 0, потому что
Эпсилон это какая-то нетривиальная степень омеги, а омега в ката это 1. Значит, Эпсилон в ката это 1.
Ну все. Все строки кроме главной диагонали в результате получились нулевые. Все элементы кроме
главной диагонали получились нулевые. Так, ну мораль. Как сделать обратное преобразование
фурье? Смотрите, я не даром внутрь FFT передавал омегу, потому что теперь, если я вместо омеги
передам омега в минус 1, то у нас сделает ровно то, что нужно. Потому что, повторю, что делает FFT с параметром
омега. Домножает столбец чисел вот на такую матрицу. Теперь, если я всюду вместо омеги напишу омега в
минус 1, то он домножит столбец чисел вот на такую матрицу. Но только надо еще будет в конце поделить
на k, потому что это не совсем обратно. Надо в конце поделить на k. Значит, что такое обратное
преобразование фурьета? Это просто к набору значений. Давайте назову А. К набору значений применить
FFT с обратным примитивным корнем. Всюду вместо омеги писать омега в минус 1. И потом результат
поделить на k. Результат по-элементно поделить на k. Ну, это вот набор значений. Ну, это
могу написать R. Ну, короче, набор значений, которые я вот здесь вот получаю. Массив, по факту, просто.
Вот. Правдоподобно? Мы получили, да, ну, окей, давайте R здесь все-таки напишу. Мы получили,
по набору значений R в правильных точках, мы получили столбец его коэффициентов. А это ровно
то, что мне не нужно на последнем шаге. Восстановление многочлена по значению в точках. Все. Ну,
потому что давайте посмотрим, что такое обычное FFT еще раз. Обычное FFT, когда я омегу передаю в
качестве последнего параметра, это домножение набора чисел. Ну, вообще говоря, набор коэффициентов
многочлена, но на самом деле набор чисел просто. Обычное FFT это умножение набора чисел в виде столбца.
Вот на такую матрицу. И в качестве ответа FFT возвращает опять-таки набор чисел. Что такое обратное FFT?
Мне нужно умножить на матрицу обратную к W. Я ее почти знаю. Это, ну, как бы, это вот это вот еще на k
поделенное. Тогда давайте я всюду в алгоритме FFT буду вместо омеги использовать омега в минус 1.
Тогда он мне домножит опять-таки набор чисел на W. Потому что W от W отличается только тем,
что вместо омеги всюду омега в минус 1 написано. Вот, значит, если я запущу вот это FFT,
то он домножит набор чисел, который лежит в массиве R, набор значений многочлена R,
на матрицу W. И получит набор коэффициентов, которые надо еще только на k поделить перед
тем, как возвращать. Потому что вот здесь будет множество k. Ровно это я делал. Я результат поделил
на k и это и будет набор коэффициентов многочлена R. Окей? Так, ну хорошо. Еще полсекунды.
Ну вот мы живем в комплексных числах. Тут, к сожалению, такая беда, что в общем случае от этого не
избавиться. Да, то есть мы либо пишем свой класс комплекс number, либо оно используем встроен. Там
есть комплекс от double, скажем. Вполне себе можно использовать. Он делает все нужные вычисления как
надо в комплексных числах. Так, хорошо. Теперь давайте... Чуть позже давайте. Я вернусь к этому обязательно,
да, но чуть попозже. Давайте пока с этим до конца разберемся. Давайте пока разберемся с тем,
что это, если прям так написать, работает довольно долго. Рекурсивные вызовы, там всякие приколы с
памятью, что много чисел, они перенажаются, ну короче, довольно долго. И на практике оказывается,
что выгодно избавиться от рекурсии, но это прям значительно ускоряет, ну там понятно, это не
симпатичная оптимизация, но на практике в разы в разы ускоряет и обычно вот такое
ФФТ рекурсивное слишком долго работает. Давайте поймем, как избавиться от рекурсии.
ФФТ. Давайте я построю дерево коэффициентов, как они передаются в рекурсивные запуски. Вот представьте,
у вас изначально был набор коэффициентов А0, А1, А2 и так далее до А7. То есть у вас был многочлен
степени 7, у него было 8 коэффициентов, это младший, это старший. Что происходит в рекурсивном запуске?
Мы все четные отправляем налево, все нечетные направо. Мы строим два многочлена, в левый мы
сваливаем все четные 0, 2, 4, 6, в правый все четные 1, 3, 5, 7. Ну давайте вот так вот построим,
что влево у нас ушли четные, вправо нечетные. Что происходит с ними? Ну то же самое, мы каждый
второй отправляем влево, каждый остальные вправо. Здесь налево пойдут А0 и А4, как нулевой и второй,
вправо пойдут А2 и А6, как первый и третий. То же самое здесь, здесь налево пойдут А1 и А5,
тут направо А3 и А7. Так, давайте я какие-нибудь разделители буду рисовать, потому что иначе от
нечитаемых. Вот, ну и последний уровень. Многочлена с двумя коэффициентами делится на два многочлена
по одному коэффициенту. Что 0, А4, А2, А6, но они так и остаются собственно. Здесь будет А1, А5, А3, А7, вот.
Ровно так у меня передается в рекурсию вектор коэффициентов. Хорошо, теперь что происходит на
каждом уровне рекурсии? На уровне рекурсии происходит следующее. Он принимает набор коэффициентов,
набор чисел и возвращает набор значений соответствующего многочлена в правильных точках.
Вот давайте мы будем это как бы все делать на той же памяти, где эти числа хранятся. То есть,
ну грубо говоря, вот этот запуск рекурсии получает 4 числа и должен вернуть 4 числа. Давайте,
чтобы лишнюю память не использовать, на месте этих же самых четырех чисел запишем ответы
правильно. У нас получится это сделать без допамяти. Вот и мне хочется теперь эту рекурсию снизу
вверх развернуть так, чтобы в конце у меня на месте исходного массива А содержались его значения
в правильных точках. Хорошо, давайте пойдем снизу вверх. Что происходит на нижнем уровне? Во-первых,
давайте поймем какой здесь порядок чисел. 0, 4, 2, 6, 1 пока выглядит довольно довольно произвольным.
Понимаете ли вы, как они здесь расположены на самом деле?
По модуле 2 в степени k одинаково. Не очень понял? Да, ну я вот нижний уровень рассматриваю. Как они
расположены на нижнем уровне? Это правда. А вот эти вот как отличаются? Ну теорема,
да. Ну это что-то вообще неприятно. На самом деле, набор коэффициентов, точнее индексы коэффициентов
на последнем слове устроены следующим образом. Если написать индексы в двоичной системе
счастления, то они будут представлять возрастающие числа в развернутом порядке. То есть вот давайте
мы запишем все эти индексы в двоичной системе и развернем их справа налево. Здесь будет 0,
здесь будет 1, 0, 0, после реверса это будет 1, здесь будет 0, 1, 0, после реверса это будет 2, 6,
это что? Это 1, 1, 0, после реверса 0, 1, 1, это 3. Ну и так далее. По-русски можно. Смотрите,
я утверждаю, что на и том месте будет стоять число, давайте скажу, на и том месте стоит
а с индексом рев от и, где рев от и это буквально разворот в двоичной записи и в дополненный до кобит.
Давайте это запишем. Да, ну поймем, по крайней мере.
Значит, на нижнем уровне рекурсии, на последнем уровне рекурсии,
и это элемент равен а с нижним индексом рев и, где рев и это число,
полученное разворотом двоичной записи и
дополненный до кобит, напишу так. Дополненный до... А, блин, ну ладно, понятно, короче. Сейчас.
Да, нужно очень слабить, давайте напишу так. Потому что кайта 8 у меня, а не 3, к сожалению.
Да, кайта степень двойки это размер массива, а длина спуска у меня 3, ну то есть логарифм,
лог Канна, на самом деле, там надо было написать. Ну, неважно, смотрите, значит,
почему это происходит? Давайте первый шаг посмотрим. Налево в первую часть массива,
вот, в левую часть моего поддерева идут все четные. Те, у кого последняя цифра
ноль в вдовичной записи. Направо идут все те, у которого последняя цифра в вдовичной записи
это один, поэтому как раз здесь, да, после реверса у меня младший бит превращается в старший,
здесь все числа, у которых старший бит ноль после реверса, здесь все числа, у которых старший бит
один, то же самое происходит, на каждом в следующем уровне. У вас вот здесь вот числа, это 0, значит,
у вас вот есть такие числа вы налево отправляете каждое второе то есть смотри
что произошло при переходе отсюда сюда у вас у каждого числа числа был индекс
какой-то номер вы сюда написали только те которые заканчиваются на 0 только
четные затем поскольку вы их написали слева направо по факту их новый номер
это просто отбрасывание нуля ну пополам поделилась потому что 0 стал нулевым
двойка первой четверка второй шестерка третьи их индексы поделились пополам
номер в этом массиве поделись пополам теперь дальше вы все четно отправите
налево нечетные направо то есть предпоследний бит в задачной записи если
0 идет налево если один то направо ну и так далее то же самое здесь у вас было
1 3 5 7 это те у которых последний бит был один после того как вы спустили сюда
они перенумеровали с 0 1 2 3 это то же самое что отбрасывание последние
единицы ну деление пополам опять нацова вы отбросили последнюю единицу налево
отправили те у которых предпоследний бит 0 направо те у которых предпоследний
бит 1 но отсюда и велось это рев и просто разворот двоечную запись убедительно
ну хорошо ну индукция ну можно индукция вот хорошо более того смотрите давайте
вспомним что это же не просто числа это коэффициенты соответствующих
многочленов которые приходят на самый низ рекурсии но если многочлене всего
один коэффициент я его и возвращаю в качестве ответа потому что это константа
значения в любой точке это константа поэтому на этом уровне смотрите мы
получили не просто коэффициенты но сразу значение я нужных многочленов
нужных точка значения константа это сама константа
окей получается что я вот этот вот нижний уровень рекурсии то что
возвращается из рекурсии самого низу я уже сразу знаю на это просто вот вот
такой массив заполненный. Хорошо, теперь давайте научимся переходить с какого-то
уровня рекурсии на один повыше. Если я знаю, что вот здесь написаны правильные
значения в правильных точках, давайте поднимемся на один вверх, потом отсюда
сюда, потом отсюда сюда, и тем самым мы получим вот в этом массиве значение в
нужных точках.
Давайте научимся подниматься. Смотрите, что такое подъем? Это по факту мне нужно
научиться два массива, ну два подмассива, обьнять в один размер в два
раза больше длины. У меня есть два многочлена, я знаю значения в каких-то там
точках, вот в одной точке в другой, в одной точке в другой, мне нужно научиться
их склеить в один массив длины вдвое больше. Вот давайте эту склейку научимся
производить. Давайте я скажу, что вот эти два подмассива имели размер С, это
тогда соответственно имеет размер 2С. Как-нибудь я еще обзову эти многочлены,
давайте это будет у меня П, это будет П0, это будет П1. Ну и давайте скажу, что
Омега, это та Омега, которая пришла вот на этот уровень рекурсии, и мне хочется
в этот массив сложить значение П в точке Омега в нулевой, Омега в первой и так
далее. То есть вот здесь вот в Итой клетке, в Итой клетке должно лежать П от
Омега в Итой. Хорошо, давайте поймем, откуда оно берется, как получить это
значение, зная вот эти вот два массива. Ну мы с вами помним, что П от Омега в Итой
получается через П0 от Омега в два Итой и П1 от Омега в два Итой. Где они
тогда лежат? Ну вот этот чувак лежит здесь же, вот в этой же ячейке И лежит П0
от Омега в два Итой, потому что здесь в два, ну как бы в два раза меньше
коэффициентов, если здесь И, то здесь Омега в два И. А с точки зрения П1 он
находится, ну где-то вот здесь вот, П1 от Омега в два Итой. И индекс этой точки,
если здесь индекс И, то здесь индекс получается И плюс С. Ну если индекс вот этой
точки И в этом массиве, то он просто сдвинут на С вправо, индекс этой точки
И плюс С. Ну тогда я знаю, что нужно написать. Я знаю, что значение здесь, это
сумма вот этого плюс вот этого на Омега в Итой. Давайте я как-нибудь их, ну давайте
ладно, просто продублирую. П от Омега в Итой, это П0 от Омега в два Итой,
плюс Омега в Итой на П1 от Омега в два Итой. Я знаю, где они чисто лежат, я их
просто ну как бы складываю с нужным коэффициентом. Да, Омега в Итой здесь написано, Омега в Итой.
Вот, значит это значение здесь. Теперь давайте в пару с ним посчитаем значение еще вот в
этой вот точке, которая получается в индексе И плюс С. То есть это П в точке Омега И плюс С.
Я утверждаю, что оно тоже считается только через эти два значения. Что такое П в точке Омега И плюс С?
Это П0 в точке Омега в степени два И плюс два С. Но поскольку Омега в степени два С это один,
здесь остается просто Омега в степени два И. Ну то есть формально здесь было бы написано два И
плюс два С, но раз Омега это соответствующий корень из единицы для П, то значит Омега в два С,
то Омега в степени длина П это единица. Давайте подпишем, что Омега в степени два С это единица.
Поэтому здесь я могу не писать плюс два С, потому что она не меняет значение Омеги. Дальше у меня
написано плюс Омега в степени И плюс С. А скажите про вас, чему равно Омега в степени С? Если Омега
в степени два С это один, минус один. Поэтому вместо того, чтобы здесь писать Омега в степени И плюс С,
я напишу минус Омега в степени И, потому что Омега в С это минус один. Плюс поменялся на минус.
Ну и здесь остается П первая в точке опять-таки Омега в степени два И, потому что плюс два С не
влияет на значение. Тем самым мы показали следующее, что значения массива П в точке И и И плюс С
получаются только из значений с предыдущего уровня в тех же самых точках И и И плюс С. То есть если
мы знаем вот эти два числа, то мы можем их с правильным коэффициентом сложив или вычте друг
из друга получить вот это и вот это. Это то, что называется преобразование бабочки, потому что
будет вот такая картинка, а это типа похоже на бабочку. Смотрите, похоже. Типа вот это крылышки,
все дела. То есть зная вот эти два числа, мы можем их склеив вот так и вот так получить значение в
точках следующего уровня. Все, мы развернули рекурсию. Итого, что мы сделали, смотрите. Идем снизу вверх,
рекурсию разворачиваем снизу вверх. Я знаю, что на нижнем уровне. На нижнем уровне массив значений,
то есть у меня это будет не отдельные массивы, как было бы в обычной рекурсии, когда я массив бью на два,
там вектора сливаю, один вектор налево, другой направо. У меня будет один большой вектор, все вот эти
числа изначально в одном векторе лежат. Все восемь чисел в одном массиве, в одном векторе. Дальше я
поднимаюсь с одного уровня на другой. Значит, вот представьте, я там что-то посклеивал, у меня есть
один большой массив снизу, чисел значений в нужных точках. Я хочу получить массив на уровень повыше.
Но я знаю, что чтобы получить значение здесь и здесь, мне достаточно знать эти два числа. Я беру
эти два числа, умножаю второй из них на нужную степень омеги, складываю и читаю и записываю сюда
и сюда. И для этого мне даже не нужно заводить новый массив, потому что если я знаю значение вот
этих вот всех чисел, давайте я посчитаю эти два, сложу с нужными коэффициентами и положу на то же
самое место, потому что они лежат ровно над ними. И больше никакие числа от них не зависят, понятное
дело. Я могу посчитать правильно вот эти числа, записать их на то же самое место, где лежали вот
эти два старых элемента. Я про них забываю, на их место кладу то, что я вот здесь только что
пересчитал. То, что я в бабочке посчитал, вот здесь кладут сюда, здесь кладут сюда. То есть я даже не
завожу новый массив, а просто на одной и той же старой памяти применяю вот такое преобразование
по всему уровню слева направо. Поскольку никакие другие числа не зависели вот от этих, никакое
другое там п от омега вжитый не зависело ни от этого ни от этого, это легко понять, значит я
могу сразу числа сюда переписать и новую память не привлекать. Получается, мы не только от рекурсов
добавить, но еще и делаем все соединиться до памяти. Ну кажется. Вот это уже довольно быстро работает.
Смотрите, на нижнем уровне у меня многочлены из одного коэффициента, это константы. Значение
константы в любой точке это сама константа. Поэтому здесь именно вот эти числа лежат,
там никакой омегы нету. Я писал в fft, если мы дошли до массива длины 1, то значение это сама
константа. Поэтому здесь просто вот эти числа без всяких омег. Так, окей. Ну вот, хорошо.
Хорошо, тогда рекурсов развернули и все замечательно. Так, ладно. Теперь давайте
вернемся к вопросу про то, что у нас есть еще проблема точности. Да, мы изначально, скорее всего,
целочисленные многочлены взяли и перемножили, но при этом перейдя в поле комплексных чисел. Ну,
понятно, как это пофиксить в тупую. Если мы при переходе к fft использовали комплексные числа,
там что-то перевели p, вот значение в каких-то точках q перевели, поточно перемножили, потом
восстановили многочлен. Давайте просто округлим коэффициенты. Если в результате мы знаем, что, скажем,
если бы это все происходило без ошибок округления, то у меня бы в конце получился правильный
многочлен. Там ничего округлять не надо, это и так правильно. Но поскольку мы работаем на реальной
машине, там какая-то ограниченная точность, давайте просто округлим все полученные коэффициенты и
выведем их в вещественную часть. Там в комплексной тоже что-то будет, но какая-то незначительная
погрешность, которую мы игнолируем. Вот, и оказывается, что это достаточно хорошо работает,
если, скажем так, результирующие коэффициенты многочлена не превосходят чего-то типа там 10 в
11, ну 10 в 12 может быть. Вот, ну просто на практике. Наблюдение, значит, что делать с погрешностями?
Если p и q были целочисленные, то достаточно просто округлить коэффициенты, если они примерно там
10 в 11, 10 в 12 по модулю, не превосходят 10 в 12 по модулю, то достаточно просто округлить
коэффициенты r, если они не превосходят 10 в 12. Да, да, обычный раунд округления.
Ну, потому что если там лежит число 9.999, то это скорее всего 10, просто там погрешность накопилась.
Если там 10.0001, то это опять-таки 10, просто погрешность в другую сторону накопилась. Вот,
ну и как бы эмпирически такое правило, что если у вас коэффициенты вылезают в 10 и 12,
то вам хватает этого комплексного fft, там не очень сильно копится погрешность и с этим можно жить,
просто округлили, и у вас получился правильный ответ. Вот, значит другой вопрос, что делать,
если у вас коэффициенты большие, если n и m имеют большой размер, там многощины размера 10 в 5,
и все коэффициенты в них большие числа, 10 в 9, скажем. То есть давайте напишем, что,
например, если n 10 в 5 по порядку, m тоже 10 в 5, а все коэффициенты h и b по порядку 10 в 9,
то при перемножении какой у нас может быть коэффициент в r по порядку? Я бы даже сказал
10 в 23, потому что вы перемножили a на b, и так n раз. Правда же? Вот, но это, конечно, очень много,
по сравнению с тем, что эмпирически можно, надеяться, умещается в дабл или лонг дабл по
точности. Это уже прям тумач. Вот, но, тем не менее, с этим можно тоже жить.
Перейдя от комплексных чисел к вычислениям в ZP, решение проблемы точности, решение
проблем погрешности. Давайте мы вместо c будем использовать ZP. Вычислить по модулю P, где P
простое. Для этого надо понять, какими свойствами c мы активно пользовались и что нам хотелось бы
от того поля, в котором мы живем, мы же не просто так перешли в c. Нам там нужно было, мы активно
пользовались тем, что из единицы можно много корней извлечь. Что есть такое число, что ω в квадрате,
ω в кубе и так далее и так далее, все попарно различные, а ω в кат это единица. Что можно извлечь
корень ката степени из единицы и вот так вот всеми его степенями обойти все другие корни. Вот,
но в ZP это тоже иногда можно делать. Что именно утверждается следующее, что если P, ну, типа того,
да, очень похоже на первообразный, только, ну, там специальный порядок нужен. Нам надо не все порождать,
а именно корень из единицы степени 2 в степени K. Первообразный корень из единицы степени P-1,
оно надо именно 2 в степени K. Значит, утверждается следующее, что если P это 2 в атой на B плюс 1,
где B нечетно, то в ZP существует такая ω, что она является корнем степени 2 в степеня из единицы.
В том смысле, что есть такое число в ZP, что если написать все его степени,
ω в нулевой, ω в первой, ω в квадрате и так далее, вплоть до ω в степени 2 в степени а минус 1,
они все будут попарно различны, а следующая уже степень, продублировав ω в нулевой, будет равна
единице. Но это вот ровно то, что мы хотели от C, да, от поликомплексных чисел. Такое число,
что много его степеней попарно различны, а какая-то его степень, равная сама по себе степени 2,
равна единице. Ну, утверждается, что в ZP работает такая штука. Значит, ну почему? Потому что на
самом деле все, что я хочу, это элемент вот такого порядка в ZP. Если у вас было какое-то
подобие теории чисел, то вы знаете, что в ZP для любого числа, являющегося делителем p-1,
а понятно, что 2 ватта делит p-1, у вас есть фи от этого числа, чисел такого порядка.
Сейчас это запишем.
Такое утверждение, что в ZP существует ровно фи от d, чисел порядка d. Ну, коль скоро d делит
p-1. Наверняка многие из вас это где-то видели. Вот. Ну, число порядка, это вот как раз, вот омега
будет число порядка 2 в степени a, то есть его несколько первых степеней попарно различны,
а омега в d это единица, это число порядка d. Ну и вот утверждается, что таких чисел,
коль скоро d делит порядок группы, то есть p-1, их достаточно много. Их фи от d, где фи это
функция Эллера. Вот. Ну, значит, в частности, там понятно, что фи от 2 в степени a это не 0,
вот. Значит, оно существует более того их довольно много. Значит, таких омег, их оно не просто
существует, а их 2 в степени a-1. Таких омег, их фи от 2 в степени a, то есть 2 в степени a-1. Вот. То
есть их довольно много. Представьте себе, что у вас a довольно большое, b довольно маленькое,
ну, то есть как бы у вас 2 ватта, это большая доля от всего zp. Ну, значит, таких чисел довольно
много. Если вы просто случайно на рандоме эти много чисел, то одно из них очень скоро будет
именно такого порядка, который вам нужен. Да, p- простое, конечно. И здесь идут тоже простое.
Вот. Окей? Ну, давайте пример какой-нибудь. Если у нас, значит, самый классический вот во всех
таких теоретических задачах на fft модуль такой. Такое число, оно простое, оно представляется в
таком виде с очень большим a. Если у меня память не изменяет, то это вот такое число. Вот. Ну,
и в качестве примитивного корня можно взять 31. Если не верите, пожалуйста, напишите программу,
которая считает все степени этой омеги, и убедитесь, что только его вот такая степень равна 1,
все остальные попарно различны. Вот. Смотрите, получается, что это p довольно крутое в том плане,
что вот это вот 2 в степени a, а очень большое. А нам что нужно было? Давайте откатимся на шаг
назад. Чтобы перенужать два многочлена, мне нужно было найти корень k-то степени за 1,
где k больше, чем сумма степеней по iq. Ну вот, это самая k. Ну уж, наверное, у вас сумма степеней
многочлена не больше, чем 2 в 23. Это что получается? Это 8 на 10 в шестой примерно. 8 миллионов. Ну,
прилично так. Наверное, хватит. Вот. Если нет, давайте несколько таких p возьмем, посчитаем по ним по всем
остатке и получим a. Ну, если нет, ну, в общем, надо выбрать такое p, чтобы вот эта вот степень
превосходила сумму степеней многочленов. Значит, дальше, смотрите, если мы в поле zp все это проделали,
упражнение, что все, что мы сделали в c, на самом деле переносится на zp, если вот такая омега
существует. То есть, на самом деле, нигде шибко мы не пользовались какими-то особенными свойствами
поликомплексных чисел, нам самое главное было важно, что омега вот такое число. Все остальное там
тривиально следуется. Вот, переносится точнее. Ну, соответственно, тогда мы можем перемножать
многочлены в zp. Если нам zp не хватает по количеству знаков, то есть мы вот, скажем, вот здесь, мы
понимаем, что c это число порядка 10 в 23. Давайте тогда в нескольких разных полях zp1, zp2, zp3 их
перемножим, получим значение c по модулям p1, p2, p3, а дальше по китайской стереме остатках найдем их
точные значения. А если мы знаем, что они не превосходят 10 в 23 по модулю, и мы знаем их
остатки по модулям порядка 10 в 9 по 3 таким модулям, то мы их знаем точные значения. Просто по китайской
стереме остатках. Вот, поэтому, как бы, если надо прям точно считать для таких длинных больших
многочленов правильные их коэффициенты, то берите несколько полей zp с большим вот этим вот a,
чтобы у вас a было, чтобы такое a было достаточно большое, чтобы можно было
перемножать в zp эти два многочлена. Вот, по ним по всем считайте fft, ну и значит вы знаете коэффициенты
c по нескольким разным модулям, а дальше склеивайте в одно большое число. Окей? Ну, круто.
Так, ну что, я считаю тогда, что с fft мы во многом разобрались. Мы умеем перемножать
многочлены zln в комплексных, если позволяет точность, если нет, то в нескольких полях zp.
Давайте вернемся к нашей исходной задаче, с чего мы начали. Про вхождение паттернов текст с
ошибками. Как тут можно применять fft? Давайте сделаем следующее. Давайте напомню задачу.
У нас была такая. У нас была маленькая строка s, длинный текст t, и меня интересуют все вхождения
s в t не более чем с к ошибками. Хорошо, давайте я сделаю следующее. Давайте я пойду по всем символам
алфавита независимо по одному. Буду перебирать символ алфавита c из сигма. Теперь давайте для
каждого возможного приложения s в t, ну то есть у меня вот есть много подстрок в t такой длины,
вот давайте для каждого из таких из подстрок такой длины, посчитаем сколько раз туда c совпало.
То есть, что c стоит на правильном месте. Скажем, вот я прикладываю s куда-то сюда,
здесь стояло несколько цешек, здесь стоит несколько цешек, вопрос сколько из них совпадают. То есть,
грубо говоря, сколько из них не ошибки, а сколько из них правильно входит. Если я это сделаю по всем
символам алфавита и дальше по ним по всем просуммирую, то я получается узнаю сколько раз в каждой подстроке
правильной длины у меня символы совпали. Если я просуммирую a, b, c и так далее по всем буквам,
сложу сколько раз буква совпадает здесь и здесь, то я узнаю сколько у меня не ошибок, сколько у
меня правильных совпадений. Если этих правильных совпадений хотя бы s-k, то значит мы видим
вхождение не более чем с к ошибками. Значит, осталось научиться делать такое. Для каждого символа,
для каждой подстроки t длины такой же как s, узнать сколько раз c находящейся здесь, одна из
ц находящейся здесь совпадает с одной из ц, находящейся здесь. Сделаем это следующим образом.
Давайте мы заменим все символы ц на единицы, а все остальные на нули. Заменим все вхождения ц на
единицы, а все остальные символы на нули. То есть там, где были цшки, оставлю единицы,
а тут все остальные нули. Нуль, нуль, нуль, здесь все тоже нули. Тогда, что такое количество
совпадений с вот здесь и здесь? Это просто скалярное произведение двух векторов. Если я перемножу вот
это вот на это скалярно, то значение это в точности сколько цшек было и там и там на правильных местах.
Что здесь единица и здесь единица. Потому что в скалярном произведении произведение равно единице
только если и там и там стояло ц. Поэтому моя задача осталась к такой. Мне нужно во всех возможных
местах приложить под строчкой такой длины и узнать скалярные произведения вот этого вектора и
всех подмассивов вот этого вектора. Правильная длина. Осталось найти все скалярные произведения
с и всех под строк т той же длины. Той же длины. Если я это сделаю, то я как раз таки
посчитаю сколько раз вот эта цшка входила и сюда и сюда на правильных позициях и так и так и так до
каждого начала и. Так представляете ли вы как это делать с помощью ффт с помощью переножения
на гашенов предлагаю чуть подумать не любите думать сочувствую давайте вдруг получится время есть
еще дофига почему-то еще раз да да но если мы их просто так перемножим самим по себе то будет не
совсем то потому что мы представьте что вот у вас вот это вектор то есть просто многочлен да у
вас нолик единички это коэффициенты вот а если развернуть то будет то что нужно понимаю хорошо
давайте напишем давайте я обозначу вот эти нули единицы за коэффициент и б пусть будет у меня
сейчас у меня есть а 0 а 1 так далее какой-нибудь а и минус первая б 0 б 1 так далее б и минус первая
мне нужно во всех местах по прикладывать этот массив к этому и посчитать все скалярные произведения
давайте я разверну какой-нибудь из них значит давайте я скажу что пусть этот у меня остается на
месте ну хорошо давайте я скажу что ему соответствует многочлен а н-1 плюс а и минус 2 х плюс и так далее
плюс а 0 х вен минус 1 а этот оставлю в этом же естественном порядке значит ему поставлю
соответствия многочлен просто бы 0 б 1 х и так далее б и минус 1 икс минус 1 икса минус 1
теперь если их перемножу у меня при нужных степенях получит ровно то что нужно
да ну в плане коэффициенту нули единицы но перемножаю их как обычные целочисленные
многочлены то есть я не меру по модулю 2 я беру просто в р ну то есть в ц на самом деле
чтобы дальше давайте поймем давайте например посчитаем давайте я скажу что
р это перемножение по ику и он равен вот такому вот представлению ну какой-то там ц ой мамочки
вот перемножил пусть получилась так давайте посмотрим что такое c н-1
но если я просто по определению перемножу у меня получится а минус 1 на б 0 так это
не надо вообще сейчас одну секунду они не я а и минус 1 на b н-1 да потому что если я беру
здесь икс нулевой то здесь нужно взять икс в н-1 как раз не перемножиться дальше а и минус 2
домножиться на здесь то что стоит при икс вен минус 2 то есть бы н-2 и так далее вплоть до
0 которая здесь уносит на б н правда же это из нужных скалявных произведений это скалявное
произведения которая получается если приложить с в самое начало т это умножится на это плюс
это на это плюс это на это и так далее плюс это на это это одно из нужных скалявных произведений
если мы рассмотрим cn, это будет следующее нужное скалярное произведение, первые не нужны нам
нужен вот какой-то блок последних да, значит cn что такое, как получить в многочлене r коэффициент
при x в n, значит ну это например я могу взять вот это вот a n-1 и bn, да потому что если это стояло
при x нулевой, то здесь нужно x в n, плюс a n-2 b n-1, ну понятно я просто сдвигаю все bшки на 1
вперед, плюс и так далее, плюс a 0 b 1, это в точности второе нужное скалярное произведение, когда я
домножаю s на вот это вот, на сдвинутую на единицу вот эту вот массив длины, то же самое длины, но уже
сдвинутую на единицу, a 0 на b 1, с конца считаем a 0 на b 1, a 1 на b 2 и так далее, a n-1 b n,
вот ну и так далее, значит это первое нужное, второе нужное, последнее видимо будет как раз
вот то самое n-2, нет как раз это не нужно, это слишком много, ой мамочки, да не очень просто,
но смотрите вот это получается нулевой коэффициент, вот это первый, сейчас я согласен, сейчас я только сам
посчитаю, так здесь 0, здесь m-1, это получается m-m, правильно, чтобы здесь их было n штук,
да здесь вот это вот, да, мне нужно с нулевого по m-m, значит здесь мне надо m-1 получается написать,
так если я смотрю c-1, а что здесь будет, у меня вот это вот умножится на a n-1, давайте напишем,
потому что a n-1, b n-1, плюс a n-2, b соответственно m-2 и так далее, вплоть до a 0 умножится на,
так, плюс m минус n, это последний из нужных коэффициентов, в чем-то прав, хорошо, ну я тут просто
аккуратненько с плюс минус 1 разобрался, по факту мы знаем, что здесь сначала нулевой, потом
первый, потом второй и так далее, вот в нужном количестве мы их все можем посчитать, вот,
и того смотрите, мы получается за одно применение, за одно перемножение многочленов научились
находить скалярное произведение маленького вектора на все подвекторы второго, на все подвекторы
большого, я в во всех возможных местах прикладываю маленьких к большому, узнаю скалярное произведение,
просто из-за того, что я реверснул, и произведение так хорошо работает, что в каком-то смысле,
когда вы фиксируете сумму степеней, у вас как раз получается скалярное произведение одного вектора
другую после реверса вот ну а все значит мы решили задачу мы для каждого символа
ц посчитали сколько совпадений с и всех возможных подстрок да то есть сколько
раз символ ц входит в каждую подстрочку дальше просуммировали по всем символам ц и
теперь мы знаем сколько в каждой конкретной подстроке длины с символов совпадает с
символами с если хотя бы с-к то значит не точное вхождение ну все значит мы решили
эту задачу мы решили ее за сигма на м лог м в моих обозначениях где м это длина
вот ну вроде чаток неплохо какие вы ценили не за этот функцион упадет но спасибо вот вопросы
есть сейчас нет хорошо давайте тогда я сделаю очень крутую вещь и поделю сигму пополам давайте
мы научимся решать это за сигму пополам но у меня есть 7 минут что нет нет не вылезет не вылезет
смотрите то есть я сейчас я сейчас научился решать задачу использую вот столько перемножений
многочленов я хочу перемножать многочленов в два раза в два раза реже в два раза меньше раз
нет не будет никаких шаблок давайте без рофлов пожалуйста смотрите вот я вызываю перемножение
для каждого символа алфавита я для каждого символа алфавита меняю его вхождение на
единицы вот вот здесь надо будет немножко поменять все вхождение сына единицы все не вхождение на нули
на какое число менять вот вот да давайте подумаем это интересная мысль да максимальный
очевидно был n если хотите ставить типа сюда n и сколько раз n квадрат входит столько раз новое
число да это это интересная мысль ну если вам это позволяет точно ну как бы если у вас это
влезает правильный тип да давайте даже без без вот этих лишних типов ну то есть не не увеличивая
модули всех чисел да то есть идея смотреть давайте мы сразу два символа посчитаем давайте возьмем
не только цену и д сразу и посчитаем сколько раз ц правильно входит и сколько раз д правильно
входит суммарно да да да так и сделаем давайте мы фиксируем пару символов ц и д давайте мы
поменяем все вхождение ц на единицу вхождение д на и или минус и давайте на и в эске и на минус
и в тешке плюс и в с и минус и в т а все остальные поменяем на нули давайте перемножим также узнаем
все скалярные произведения тогда я утверждаю что вещественная часть всех скалярных произведений
это будет общее количество ц и д которые совпали но вот смотрите то есть у меня есть получается
строка с состоящие из единичек и ишек и нулей и длинная строка т где есть единицы нули и минус
как при перемножении у меня может получиться вещественные bladder как
получается вещественные коэффициенты при перемножении таких чисел ну либо я
перемножаю один на один тогда это как раз ц совпала с ц либо я перемножаю и на минусы
тогда получается в падении д с д поскольку и в квадрате 1-1 то минус как раз даст единичку
вещественную часть значит если я теперь посчитаю все скалярные произведения то я знаю вхождение
в вещественной части у меня будет суммарное вхождение
цшек и дэшек.
Ну да, в кватронионы хотите уйти?
Еще живисти.
Понятная идея эта?
Давайте еще раз поговорю, что я перебираю пары чисел,
то есть смотрите, вот я всю сигму разбиваю на пары,
там А, B, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D,
D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D,
D, E, D, E, E, D, D, D, E, G, D, C, G, E, G, E, C, G, F, E, E, G, E, F, E.
В чем
zusammen coopühren lijну?
xft заменяю на единицу, второй элемент пары я в первой строке
заменяю на плюс и во второй на минус i, а все остальные,
которые не в паре, заменяю на ноль.
Тогда при скалярном произведении вещественная часть тех же
самых коэффициентов, скажем там c, n-1, это есть общее количество
совпадений c-шек и d-шек вот в этом блоке, s и первой
подстроке такой же длины, общее количество вхождений.
Так нет, потому что, когда вы изначально вот то все
делали, там и так все комплексное.
Это мы не видим, мы говорим, что там все нули единицы
перемножили и получилось число, но внутри-то там комплексное.
Еще раз?
Не в пай?
А, не в zp, не в zp, да, не в zp.
Так, количество… Сейчас, секунду, количество совпадений
c и d.
Что еще раз?
Пам-пам-пам, zp, ну zp посложнее мне кажется это сделать.
Неприятно, да.
Ну, смотрите, здесь с комплексами как раз все нормально, потому
что у меня вот эти числа коэффициенты, они маленькие
по модулю.
Когда вы их перемножаете и складываете, вы за 10-12
ну никак не вылезете.
Ну, типа, там какие-то огромные должны быть массивы, чтобы
переполнится.
Поэтому в комплексных все хорошо, то есть zp тут даже
не нужно.
Ну, это тогда давайте закончим, в следующий раз еще про
фурье поговорим.
Спасибо.
