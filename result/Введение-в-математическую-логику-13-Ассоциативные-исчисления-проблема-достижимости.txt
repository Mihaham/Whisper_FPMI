Я напомню, что в прошлый раз я сформулировал теорему
о том, что множество общезначимых формул неразрешимо.
Точнее речь идет о кодировках общезначимых формул.
Мы обсуждали, как их кодировать в двоичном алфавите, в начале
в конечном алфавите, потом в двоичном.
Ну и пора начинать эту теорему доказывать.
Доказательства по видео за сегодня я не закончу,
потому что оно довольно длинное.
Начну я с того, что отчасти повторю ваш курс алгоритмов,
потому что, понятно, нужно доказать алгоритмическую
неразрешимость, и чтобы быть уверенным, что у нас
общий язык, я какие-то вещи повторю, постараюсь довольно
быстро, естественно, все без доказательств.
Вообще то, что можно доказывать неразрешимость чего-то,
выглядит как некоторое чудо.
Алгоритмов очень много, то есть по сути дела можно
сколь угодно хитроумную процедуру придумать, и
мы должны как-то все эти процедуры объяснить, что
все они ломаются.
Ну, как это делается, есть специальные задачи, для
которых это можно сделать отдельным способом, диагональным
методом, вам про него, наверное, рассказывали, а дальше используется
такая техника.
Мы плохо представляем себе все алгоритмы, но мы хорошо
умеем строить конкретные алгоритмы, поэтому если
у нас есть задача, про которую мы уже знаем, что алгоритмическая
неразрешимость, идея состоит в том, что из нее получать
новые неразрешимые задачи, и для этого используется
техника сводимости.
Значит, вам про это рассказывали, я уверен, но я повторю короткое
определение.
Язык А сводится к языку B, M сводимость меня будет интересовать.
Если существует тотальная вычислимая функция, ну,
я считаю, что у меня двоичные слова, то есть функция должна
действовать из двоичных слов в двоичные слова.
Такая, что X принадлежит A равносильно тому, что F от
X принадлежит B.
То есть если мы хотим ответить на вопрос о принадлежности
слова языка, мы можем поступить иначе, мы можем применить
эту функцию, получить какое-то новое слово F от X и проверять
уже принадлежность языку B.
Это удобно в силу следующих утверждений.
Во-первых, если A, M сводится к B, значит, если A неразрешим,
то и B неразрешим.
Вот, собственно, основной факт, благодаря которому
нам удается размножать, то есть чтобы построить,
доказать сводимость, нам нужно построить алгоритм
сводящую функцию, которая делает преобразование задач.
И это нам проще, чем бороться со всеми алгоритмами.
Ну и почему важна M-сводимость, потому что она еще и то
же самое делает для неперечислимых.
Значит, если A не перечислим, то и B не перечислим.
Это не для всех типов сводимости такое есть, но для M-сводимости
есть.
Ну и дальше важное наблюдение состоит в том, что M-сводимость
транзитивна.
Если у вас A сводится к B, B сводится к C, то тогда A сводится
к C.
В результате мы можем эти сводимости строить длинные
цепочки.
Пользуясь транзитивностью, мы можем сделать один шаг,
потом второй, то есть сложную задачу, ну вот перед нами
например цель доказать неразрешимость общезначимых
форм.
В один шаг не очень понятно, как это сделать, мы это сделаем
в несколько шагов.
Ну и наконец, что еще хорошо бы сказать про это.
А, ну да, для неперечислимости еще важно такое свойство.
Сейчас оно мне будет не нужно, но оно очевидно из определения,
что одна и та же сводящая функция, если она A сводит
к B, то дополнение к A сводит дополнение к B.
Ну это за счет того, что там равносильность, поэтому
понятно, что X принадлежит A, равносильная F от X принадлежит
B.
Это, можно пересказать иначе, X не принадлежит A, равно
сильно тому, что F от X не принадлежит B, это просто
чисто логически равносильные вещи.
Вот мы будем основываться на этих сводимостях.
Ну надо от чего-то сводить.
Я буду использовать, значит общая идея такая, если у
вас есть какая-то универсальная модель вычислений, с ней
легко связать какую-нибудь неразрешимую задачу.
Более-менее, если модель универсальная, то есть такой
базовый факт, что предсказать результат работы невозможно.
Если бы вы могли, то там известным способом строится
противоречие.
Но мне будет нужна совершенно конкретная модель, которая
у вас по счастью была, называется машиной тьюринга, одноленточная
если строго говорить.
И я сейчас напомню определение, потому что мне будут важны
технические подробности.
Для построения сводимости нужно… машина тьюринга
такая комбинаторная модель, и вот эта комбинаторная
структура нам и будет нужна.
Значит из чего она состоит?
Она состоит из двух множеств.
Из еще таких вот элементиков, из-под множества.
Я сейчас объясню весь смысл этих… Что, простите?
А, нет, это… Вот у нас такие 7 элементов будут, причем
лямбда и вот этот вот значок – это элементы множества
А, которые называются алфавитом.
Лямбда называется пробельный символ или пустой символ,
а вот этот значечек треугольника – это маркер конца.
Q0 – это элемент множества Q, множество Q называется
множеством состояний.
Значит Qf – это множество финальных состояний.
Но у вас, насколько я знаю, всегда подразумевалось,
что их два – принимающее и отвергающее.
Ну, я привык к такой большей общности, это неважно.
На самом деле деталей конкретного построения очень много.
Мне будет удобно считать, что у меня какое-то множество
финальных состояний.
Ну и, наконец, самое интересное – это дельта – это функция.
Она называется таблица переходов или функция переходов.
Она отображает пары… Так, давайте я подумаю, в каком
порядке мне удобнее записывать пары… Не помню… Неважно.
Понятно, что порядок, в котором мы записываем символы
и состояния, несуществны, но мы будем считать, что
у нас такая функция переходов.
На функцию переходов надо смотреть как на инструкцию.
То есть это вообще говоря функция, но по сути дела
мы от нее чего хотим?
Мы хотим записывать инструкции такого вида.
Видишь символ А в состоянии Q, напиши новый символ H',
перейди в новое состояние Q и сдвинься.
Вот эти… Третье компоненты значений функции переходов
– это команда движения.
То есть мы либо сдвигаемся влево, либо стоимся на месте,
либо сдвигаемся вправо.
Для удобства мы считаем, что дельта тотальная, всюду
определенная.
И я зафиксирую ее поведение на вот этом особом символе
маркера конца.
Поведение такое, что дельта от маркера конца в любом
состоянии – это маркер конца, то есть она маркер конца
не меняет, состояние может изменить, и при этом сдвигается
обязательно вправо.
Ну и соответственно, если значение функции символ
является маркером конца, то тогда это может быть
только в том случае, если в аргументе тоже стоит
маркер конца.
Почему такие условия?
Я сейчас объясню, как работает машина, напомню, вам уже
это объясняли заведомо, и станет ясно, что эти ограничения
просто нужны для того, чтобы маркер конца всегда
указывал на конец ленты.
А работает машина так, она работает с полубесконечной
лентой, самой первой ячейки которой записан маркер
конца как раз, а дальше написаны какие-то символы
алфавита.
У машины есть головка, которая смотрит на какую-то конкретную
ячейку, ячейки можно считать занумерованы не отрицательными
целыми числами, и вот головка смотрит на конкретную ячейку
и машина находится в каком-то состоянии Q, а дальше, как
я уже сказал, она смотрит на пару A и Q, тут написан
какой-то символ A, и соответственно либо движется влево, либо
движется вправо, символ здесь меняет на то, что указано
на аштрих, ну и состояние тоже меняет на Q-штрих.
Это то, что называется такт работы.
И машина циклический повторяет эти такты работы, пока не
попадает в состояние из множества QF, тогда она останавливается.
То есть множество QF нам нужно для того, чтобы сказать,
когда машина останавливается.
Ну, вообще-то, чтобы объяснить, какой полезный результат
дает машина, нужно еще определить функцию вычислимой
на машине тюринга, мне это не понадобится, я про это
особо говорить не буду, ну, может быть, очень коротко
скажу, да, значит, что-то сказать-таки надо.
Вот что в этой модели неудачно, неудачно то, что лента бесконечная.
Она бесконечная, потому что мы не знаем, сколько
памяти понадобится алгоритму для своей работы.
Поэтому мы вынуждены запасти сколько угодно много места,
значит бесконечное место.
Но это неудобно, потому что бесконечные объекты
они не конструктивные, непонятно, как с произвольным бесконечным
объектом вообще что-то конструктивное делать.
Поэтому мы предполагаем, что у нас есть сколько-то
символов в начальный момент, есть сколько-то символов,
которые не пустые, а дальше вся лента заполнена пустыми
символами.
И ясно тогда, что после любого конечного числа
тактов работы лента снова находится в таком состоянии,
что начиная с какого-то места все символы пустые.
Это вот место, когда уже идут только пустые символы,
называется концом рабочей зоны, вот эта вот рабочая
зона, давайте скажем, не уверен, что мне это понадобится
слова, но скажу на всякий случай.
Ну и вот в начале подается какое-то слово, с ним начинается
работа, и она в какой-то момент заканчивается, нужно
еще определить результат.
Как-то у вас результат, я не знаю, как у вас определялся,
его можно по-разному определять, как у вас определялся результат
работы машины?
А, все, что осталось на ленте, ну видите, как у вас сурово,
то есть нужно все, кроме результата, стереть.
Ну тогда надо и, на самом деле, маркер правого конца
конечно сразу заводить, ну хорошо, давайте считать
так, хотя, ну в общем, неважно, это почти всегда все равно
нужно, и мне это особо не потребуется, потому что,
смотрите, у меня будет такое, как говорил Орл Дабл Финг,
я буду, когда мне нужна свадимость, и когда я буду
устроить свадимость, я буду считать, что у меня
вот эта вот модель.
А когда я описываю конкретный алгоритм, я буду не стесняясь
его описывать на верхнем уровне и ссылаться на тезис
Черча Тьюринга, что любой алгоритм можно реализовать
на машине Тьюрина, не обсуждая деталей этой реализации.
Ну, вам в курсе алгоритмов что-то про это говорили,
мне уж точно на это не хочется тратить время, тем более,
что это, ну так, почти что очевидно, конечно, это
очень убогий получается язык программирования,
один массив, но правда бесконечный, вот, и команды какие-то
очень примитивные, которые противоречат парадигме
современного программирования, сплошные ГоУ-2, ну, как бы
изменение состояния, это в каком смысле аналог
команды ГоУ-2, вы идете с одной строчки в другую
строчку.
Но, тем не менее, этого достаточно, и, в общем, объяснить, как
все, так сказать, приемы программирования, которые
нам нужны реализовать на машинах Тьюринга, можно,
для этого лучше, конечно, обобщить модель, но я это
все пропускаю.
Считаю, что вам что-то про это объяснили, ну, а так
вот можете поверить, если чего-то не объяснили, поверьте,
что любой алгоритм, который я буду рассказывать, реализуется
на машине Тьюринга.
Ну, и какая задача будет связана с этой моделью?
Ну, язык даже.
Мне будет нужен такой язык.
Множество описаний машины и ее входа таких, что m
останавливается на x.
Вообще говоря, машина не обязана останавливаться,
она может никогда не переходить в множество финальных
состояний.
И вот нас интересуют такие пары, ну, точнее, опять-таки
двоичные кодировки.
Машина, как вы видите, это такой, конечно, комбинаторный
объект, но там алфавит может быть сколь угодно большой,
множество состояний может быть сколь угодно большим.
То есть все это надо как-то закодировать.
Детали кодировки я пропускаю, потому что мы уже обсуждали,
как счетные множество кодировать.
Ну, можно, например, перенумеровать алфавит, перенумеровать
состояние, записывать соответствующие двоичные
записи, там таблицу переходов, тоже там как договориться
к каких-то разделителях.
В общем, все эти детали, они не очень существенные,
их можно делать по-разному, ничего от этих деталей не
зависит.
Так вот, что про этот язык известно?
Я думаю, вам это доказывали.
Значит, h перечислим.
Но не разрешено.
Перечислимость проще всего понять так, что мы должны
уметь исполнять работу машины тюринга на каком-то
входе.
Видно, что у нас все очень конструктивно, то есть представить
все алгоритмы, которые моделируют работу машины тюринга очень
легко.
Ну а тогда уже что, тогда можно использовать представление
перечислимых ножек как проекции разрешимых, можно
считать, что у нас проекция разрешима, это помимо описания
машины, описания входа, еще указано время, количество
тактов работы, за которые она останавливается.
И тогда уже это разрешимо, потому что если вы указали
временную границу, за эту временную границу вы можете
сделать еще счетчик дополнительный, считать количество тактов
и смотреть действительно останавливается или нет.
Так что перечислимость легко, неразрешимость, там требуются
вот некоторые хитрости, типа как я сказал, остановится
ли машина тюринга до нового года, ну до нового года это
уже с ограничениями на ресурсы, а тут вообще остановится
или нет, если у нас бы такой алгоритм был, мы могли бы
его обманывать.
Я это пропускаю, для меня это будет отправная точка.
От этого языка я буду строить сводимости, то есть он уже
неразрешим, у меня есть вот эта схема, и я буду строить
сводимости.
Цель моя, ближайшая, это добраться до общезначимых
формул.
Но цель эта будет достигнута не сразу, у нас возникнет
промежуточная неразрешимая задача, про которую я думаю
вам в курсе алгоритмов не рассказывали, она связана
с задачей достижимости в ориентированных графах.
Ну вот вы должны осторожиться, потому что вас учили, я
думаю, что задача достижимости в графе хорошо решается.
Ну если у вас есть граф, надо проверить есть ли путь
из одной вершины в другой, ну там обход в глубину, обход
в ширину, куча всяких подробностей.
Есть очень эффективные алгоритмы, которые делают
на гигантских данных, можно решать задачу достижимости.
Но, все это относится к случаю, когда графы конечные,
а меня будет интересовать бесконечные графы, и все
становится уже намного сложнее.
Ну с бесконечными графами нужно, конечно, договориться
как их задавать, но я просто хочу, чтобы я сейчас буду
вводить некоторые понятия, чтобы вам было легче с
ними сжиться, я буду их, вы должны понимать, что
я просто определяю бесконечные графы, я про это еще скажу,
когда дам определение.
А технически это будет называться ассоциативные
исчисления, но еще их называют полутуевские
системы.
Значит, туэ – это математик, почему полу, потому что
потом появятся полные, они-то нам и нужны, но проще начать
с этих.
Значит, как они устроены?
Такое исчисление задается алфавитом, опять-таки, и
множеством правил.
Значит, алфавит – это просто некоторое конечное множество,
а правила имеют такой вид.
Ну, какое-то конечное тоже множество, вот это вот множество
– это и есть множество правил.
Значит, а все левые и правые части, значит, правило устроено
так, есть стрелка, есть левая часть и правая часть правила,
и левая и правая части – это просто-напросто слова
в алфавите Сима.
Это как с машиной Тюринга, формальное определение
ассоциативного исчисления закончено, если по эту часть
определение машины Тюринга, но дальше я объяснял, как
работает машина, потому что иначе не понятно, зачем
такое определение.
Здесь тоже надо объяснить, к чему все это дело.
Правило, это на самом деле, если говорить более полно,
это правило подстановки.
Мы определяем отношения, с помощью системы правил
мы определяем отношения.
Из слова У можно получить слово В, если У можно представить
в виде, ну там какой-то U-штрих, L и T, V-штрих, а В можно представить
в виде U-штрих, R и T, V-штрих.
То есть другими словами мы находим какое-то подслово
в нашем слое, которое встречается в левой части правил, и после
этого заменяем его на правую часть правила.
Вот конкретно это вхождение подслова.
В результате у нас получается, если посмотреть на это отношение,
я фактически задал ориентированный граф на множество всех слов,
потому что эта пара, она связана, то есть одно правило
задает на самом деле сразу бесконечно много ребер.
Вы можете навесить любой префикс, любой суффикс,
он не меняется, и получается так, что правил конечный,
то есть наш граф задан конечным описанием, тоже конструктивный
объект, но он определяет вот такой граф на очень
большое множество, на бесконечно большое множество слов.
И с этим, конечно, связано то, что называется транзитивное
замыкание отношения.
Я не знаю, использовали ли вот назад такие слова
вас в курсе дисклетной математики, но я сейчас объясню, что
это значит.
Это очень просто.
Что слово В можно получить из слова У цепочкой таких
замен.
То есть существует ориентированный путь в графе.
Вот то, что я говорил, задача достижимости.
Мы начинаем с вершины У в этом нашем графе слов
и хотим попасть в вершину В.
Ну, наверное, стоит какой-то простой пример разобрать.
Давайте считать, что у нас алфавит АВ.
Какие-нибудь надо простые правила написать.
Давайте так, АВ переходит в БАА, АББА переходит в БА.
Что-нибудь вот такое.
То есть длинные слова могут быть разными в левых и правых
частях.
В принципе, может одно из слов быть пустым, такое
тоже возможно.
Ну и вот, например, значит, что?
Давайте посмотрим и убедимся, что из слова БАВ мы можем
получить какое-нибудь другое слово БА.
Вот смотрите, тут я написал цепочку, каждое соседнее
связано одним из правил.
Тут я применяю правила к этому подслову и заменяю
его вот на это.
А второй раз я уже применяю вот к этому подслову и заменяю
его вот на это.
Ну а сокращённо это можно вот как раз записать с помощью
транзитивного замыкания, вот такая стрелочка со звёздочкой,
что из БАВ мы можем попасть в БАА.
Ну это простая комбинаторная модель, более общая, чем
машина Тьюринга, на самом деле ей эквивалентная в
некотором смысле.
Сейчас я ей буду объяснять, почему.
И она возникла до теории алгоритмов, в математике
было нужно решать вот всякие такие вопросы.
То есть вот когда система правил конкретная и нужно
понять, можно ли преобразовать одно слово в другое.
Собственно, теория алгоритма во многом возникла из нужд
вот таких вот решения, таких задач.
Для каких-то правил удавалось придумывать алгоритмы,
для каких-то не очень удавалось придумывать алгоритмы.
И в какой-то момент люди поняли, что может так
случиться, что у него нет алгоритм.
И это всё было до возникновения теории алгоритмов, потом
это научились уже пересказывать в правильных словах.
Ну нас, собственно, будет что интересовать?
Нас будет интересовать такая задача.
Давайте я где-нибудь, ну вот я сотру ту картинку,
чтобы она вам заведомо знакома и вряд ли так уж она.
Она нам, конечно, понадобится, но это будет чуть позже.
Это будет чуть позже.
Давайте рассмотрим такой язык.
Множество описаний, опять-таки у меня ассоциативное
числение, это конечное множество и конечный набор правил.
Ну всё это можно закодировать двоичным образом.
Можно алфавит, сигма, там, сопоставить ему какие-то числа правилом.
Ну понятно, просто пары перечислять, вот, слов в алфавите, то есть
последности этих чисел.
Соответственно, значит, мне нужно что?
Мне нужны вот такие четвёрки, то есть описание таких четвёрок.
Описание алфавита, описание правил, целевое множество,
целевое слово и финальное слово, и нам нужно, чтобы по правилам этого
исчисления мы из У могли попасть в В.
То есть такая общая задача достижимости.
Не для одного конкретного исчисления, а вот само исчисление
тоже подаётся на вход задачи.
То есть правила исчисления тоже являются частью входа.
И теорема, которую, собственно, я сейчас буду доказывать.
Состоит в том, что проблема остановки
M сводится вот к этой самой задаче достижимости.
Ну и поскольку проблема остановки неразрешима,
то, значит, это множество тоже неразрешимо.
Ну и сводимость, понятно, как должна быть устроена.
Значит, нам нужна функция,
которая получает на вход описание машины и входа.
И входа. Ну, какой-то X.
И строит по нему вот
описание ассоциативного исчисления и пары слов,
достижимость которых мы хотим проверить.
Причём условие должно быть такое, что если M останавливается на X,
это равносильно тому, что
слово V достижимое слово U.
Вот, собственно, доказательство теоремы будет, естественно,
в построении такой сводимости.
Как это делать, значит? Ну, тут надо, я вынужден был стереть уже
такт работы машины и тюринга, но вы уже с ними имели дело,
поэтому и так мысленно, я думаю, легко представить.
Машина тюринга может перемещаться только на ограниченное количество
ячеек ленты, ну, на самом деле, на одну.
Соответственно, менять состояние ленты она может вот локально только.
И поскольку почти вся лента пустая,
можно связать
с работой машины и тюринга, вот каждый данный момент есть какое-то состояние,
оно называется конфигурацией.
Значит, я его запишу вот так, U и V – это слова в алфавите A,
Q – это состояние.
То есть конкатинация U и V – это вот не пустая часть ленты.
Причём, на самом деле, у нас есть такое состояние,
когда слово V может заканчиваться на какие-то пустые символы.
Понятно, что мы их можем обрезать, потому что мы знаем,
что дальше тоже идут пустые символы.
Вот если у нас есть бесконечная цепочка пустых символов,
ну, часть из них можем добавить в наше описание,
в этом вроде бы нет никакого смысла, но мне будет удобнее так,
в дальнейшем построение.
Значит,
и мы договариваемся, вот тут я всё-таки вынужден нарисовать картинку.
Мы договариваемся, нам же ещё нужно положение головки задать.
Вот положение головки – это первый символ вот этого слова.
Оно может быть пустым, это будет означать, что просто
у нас есть пустые символы.
Ну, если у нас есть пустые символы, то у нас есть пустые символы,
что может быть пустым, это будет означать,
что просто головка смотрит на пустой символ,
и дальше справа все символы пустые.
Вот это вот,
вот это вот В,
а вот это вот О.
То есть мы положением головки разбиваем нашу рабочую зону
на два слова.
То, что до головки, и то, что после головки.
И пишем символ состояния,
мне хочется, чтобы это было слово,
то есть это слово в алфавите.
Ку в объединении с А.
И теперь я потом скажу про это подробнее,
но теперь уже ясно, что такт работы
он будет менять конфигурацию как-то локально.
То есть, поскольку изменения касаются только вот этой вот части ленты,
значит, головка может сдвинуться влево или вправо.
Вот у нас есть три очейки ленты,
над которыми может быть головка.
Здесь символ может вообще измениться.
Но ясно, что вот только про эту тройку
имеет смысл думать,
когда мы говорим об изменении конфигурации.
А все остальное не меняется.
И это очень напоминает правила ассоциативного исчисления.
Потому что, смотрите, у нас здесь похожая ситуация.
Не важно, что слева, не важно, что справа,
вот оно только изменение.
И эта идея для нас и будет основной.
Значит, мы будем сейчас последовательно ее реализовывать.
Для реализации на самом деле нам нужны
некоторые технические подробности.
Давайте, значит, вот я зафиксировал цель,
которую я хочу достичь.
Значит, у меня есть машина,
я так и буду ее описывать.
И вот мне надо объяснить,
какое ассоциативное исчисление я сопоставляю.
Ну, во-первых, какой алфавит?
Алфавитом будет объединение AQ и еще особый символ,
который я обозначу лям-да-ноль.
Почему лям-да-ноль?
Это будет такой дублер пустого символа.
В каком смысле я скажу чуть позже.
А в каком смысле я скажу чуть позже.
В каком смысле я скажу чуть позже.
В каком смысле я скажу чуть позже.
Чуть позже.
Значит, правила – это отдельная история,
они довольно сложные.
А вот слова я могу сразу сказать какие.
Это начальное слово устроено вот так.
А конечное слово – это просто два
вот таких специальных пробельных символа.
Давайте прочитаем, что написано в начальном слове.
У нас есть окаемление из этих специальных пустых символов,
а между ними написана начальная конфигурация машины.
Мы помним, что машина в начале работы смотрит не на маркер конца,
а на первый символ после маркера конца.
Соответственно, вот так это и написано.
Есть маркер конца, дальше есть какой-то вход,
который у нас в условии задачи задан, x.
И начальное состояние нужно записать перед словом x,
потому что головка смотрит на первый символ входа.
Теперь надо задать правила.
И это длинная история.
Прежде чем задавать правила, я хочу объяснить,
что мне от этих правил нужно.
Ведь цель моя в том, чтобы остановка машины на входе x
равна сильной достижимости вот из этого слова вот этого.
И мне для этого потребуется два множества.
Слов одно устроено так.
У и В у меня уже есть, поэтому давайте я как-нибудь...
Ну пусть будет x, q, y,
где q принадлежит алфавит, множество состояний, прошу прощения,
а x, y это слова в алфавите.
Я буду называть это множество...
А, принадлежит состоянием, но не всем,
а обязательно не финальным, прошу прощения.
То есть это такое буду называть рабочее множество.
То есть если вот на это посмотреть, то видно,
что мы кодируем конфигурацию машины.
То есть у нас есть какая-то непустая часть ленты.
Над ним находится где-то головка.
Символ состояния единственный в этом слое.
Поэтому он однозначно указывает на место,
где находится головка,
а сам символ указывает какое состояние машины.
То есть это вот такая кодировка.
При этом вообще говоря, y может заканчиваться на пустые символы.
Я это не запрещаю.
То есть это не то чтобы однозначная кодировка.
И мне будет нужно финальное состояние.
В принципе, похоже.
Финальное множество, прошу прощения,
но тут Q уже принадлежит как раз множеству финальных состояний.
Это далеко не все слова.
Но мне для сводимости проблемы остановки машины и тюрьмы
нужны будут только эти слова.
Никакие другие я использовать не буду.
Какие свойства требуются от правил?
Правила я пока не задал.
Я сейчас сформулирую, какие свойства в терминах этих множеств
должны быть выполнены.
Если у нас есть слово, которое принадлежит
рабочему множеству,
то применимо ровно одно правило.
И получается какое-то слово w штрих.
И w штрих принадлежит либо рабочему, либо финальному множеству.
То есть w штрих тоже является конфигурацией машины.
Причем эта конфигурация и w штрих кодируют
эта конфигурация машины на следующем такте.
То есть вот это первое свойство говорит нам вот про что.
Что если у нас есть какое-то слово, которое мы воспользуемся
как запись конфигурации машины, то правила
нашего исчисления можно применить ровно одно правило.
И после его примения я получу конфигурацию на следующем такте.
То есть после выполнения этого такта работа.
Этому обязательно нужно достичь.
И второе, что мне нужно.
Мне нужно вот что.
Что если слово принадлежит финальной части,
то тогда из этого слова достижимо.
Ну вот это вот целевое слово лямбда 0, лямбда 0.
Я утверждаю, что если я напишу набор правил,
для которых выполняются эти свойства, то тогда
я построил корректную сводимость.
Ну, если, конечно, все это строится алгоритм.
Давайте, определение пока не буду стирать.
Как это доказать?
Ну, смотрите, вот у нас есть начальное слово у.
Мы применяем наши правила.
И у нас есть начальное слово у.
Мы применяем наши правила.
Получаем какое-то еще.
Слово еще, слово и так далее.
Значит, пока у принадлежит рабочему множеству.
По строению.
Если мы применяем правила
и никогда не попадаем в финальное множество,
то что это означает?
Это означает, что машина не останавливается.
Потому что она останавливается,
когда мы попадаем в финальное состояние.
Значит, тогда у нас получается,
в нашем графе есть путь,
такой бесконечный путь, начинающийся с у.
Но v, оно-то принадлежит финального множества.
Оно никак в этом пути быть не может.
То есть, если машина не останавливается,
из u в v мы достичь несостояния.
Потому что у нас последовательность ходов из u
она однозначно определена.
И если машина не останавливается, то все.
А с другой стороны, это первый случай.
А с другой стороны, если машина останавливается,
то у нас возникает такая же цепочка.
Но в какой-то момент
мы попадаем в финальное множество.
Какое-то слово в наших преобразованиях
окажется в финальном множестве.
Что значит, что машина останавливается?
Наши же замены дают кодировки конфигурации,
ну не кодировки, а просто конфигурации,
на следующем такте работы.
Если машина останавливается, мы рано или поздно
достигнем конфигурации, в которой состояние финальное.
Ну и в этот момент мы используем второе свойство.
Вот у нас есть где-то множество лямда 0, лямда 0.
Мы можем достичь из этого финального слова
достичь особое финальное слово.
Вот, собственно, это доказательство корректности.
Но нужно вот этим двум свойствам удовлетворить.
Это не то чтобы очень сложно, но требует определенных усилий.
Значит, сейчас уже будет перерыв, поэтому, наверное,
нет смысла начинать выписывать эти правила,
потому что их все-таки немало.
Давайте еще раз, пока еще есть там немножко времени,
посмотрим на саму структуру доказательств.
Итак, мы строим свадимость. У нас есть машина,
и мы строим вот такое вот исчисление,
которое удовлетворяет таким правилам.
Альфавит я задал, начальное слово задал, целевое слово задал,
и нужно, чтобы выполнялись правила удовлетворения вот этим вот условиям.
Тогда это будет корректная свадимость.
За одним нюансом, который я почти что сознательно упустил,
но вот в перерыве может быть кто-нибудь додумается,
про что я не сказал.
Сейчас перерыв.
Важно мне сказать, что все-таки алфавит и состояние различаются.
То есть мы должны по символу уметь понимать,
это символ алфавита или символ состояния.
Ну, формально, когда мы определяем работу машины,
это даже не очень важно,
потому что у нас там в функции переходов есть две координаты,
но мне для свадимости это, конечно, нужно,
потому что это я перемешиваю их, и, конечно, нужно.
Спасибо, я забыл про это сказать.
Правила будут делиться на две группы.
Первая для нефинальных состояний,
вторая для финальных.
Давайте начнем для нефинальных состояний.
Пусть у нас есть строчка в таблице переходов A, Q,
но там куда-то.
Значит, A штрих, Q штрих.
Давайте ноль.
Значит, с командой движения нужно будет по-разному разбирать.
Вот есть такая строчка.
Тогда ей сопоставляется такое правило.
Значит, мы смотрим на A,
и должны заменить состояние,
должны заменить символ,
но мы никуда не двигаемся.
Это если A не пустой символ.
Извините, не специальный пустой символ.
Давайте я сразу оговорюсь где-нибудь,
вот здесь он появился,
тогда придется вот здесь написать.
Как я уже говорил,
вот этот специальный пустой символ
для нас ведет себя так же,
как обычный пустой символ.
Поэтому таблицу переходов я продолжу.
Таблица переходов на специальном пустом символе
такая же, как и на обычном пустом символе.
Поэтому мне нужно два правила.
Если символ все-таки мы смотрим на пустой символ,
это возможно,
тогда мне нужно дописать A штрих,
и только после этого лямбда ноль.
Это если A пустой символ.
Я сейчас буду выписывать правила,
потом мы еще обсудим,
почему выполняются эти свойства,
но удобнее, наверное, все-таки выписать
вначале все правила,
иначе обсуждать каждый из правил,
мне кажется, хуже.
Значит, давайте смотреть,
что будет, если движение вправо.
Тогда, опять-таки, вот у нас есть QA,
мы его заменили на A штрих
и сдвинулись вправо.
Это, опять-таки, если A не специальный пустой символ.
А если A специальный пустой символ,
то нам нужно вот такое правило,
A штрих Q, ну и, опять-таки,
вот этот специальный пустой символ.
Ну и, наконец-то,
движение влево.
Видите, правила немножко различаются,
поэтому их нужно выписывать
каждое по отдельности.
Значит, теперь у нас есть...
уже нам нужно смотреть на контеку,
уже нам нужно смотреть на контекст
с обоих сторон,
и слева и справа.
И типичная замена состоит в том,
что мы перемещаемся
влево, заменяя символ.
Так, а...
Да, это если, опять-таки,
A не пустой символ.
И, наконец, если A пустой символ,
мы также перемещаемся,
но теперь нам нужно
дописать вот этот вот символ A штрих.
В значениях функции перехода
в лямбда 0 нет.
Там, если значение пустой символ,
мы так пустой символы оставляем.
Ну, это все я написал правила
для не финальных состояний,
правила для финальных состояний,
они намного проще.
Значит, если у нас есть Q,
вот Q принадлежит финальному состоянию,
и оно видит какой-то символ,
ну, этот символ стирает.
Ну, единственное, что A не равно,
опять-таки, вот этому вот
специальному пустому символу.
А если символ он видит слева,
то он его тоже стирает.
Ну, может стереть.
Тут уже однозначности у нас не будет.
Ну, и, наконец,
еще одно правило, чтобы
достичь того, чего мы хотим,
это вот такое.
Если уже и слева, и справа
он видит только специальные пустые символы,
он себя убивает,
остается вот ровно то слово, которое нам нужно.
Вот такой набор правил.
Теперь мне нужно доказать,
что для него выполняются вот эти вот два свойства.
Ну, доказательства, естественно,
индукции по числу подстановок.
Предположим, что мы находимся
в каком-то рабочем,
каком-то слове из рабочего множества,
то есть у нас есть кодировка,
ну, не кодировка, конфигурация,
ну, кодировка, потому что еще лямда 0, лямда 0 есть,
конфигурация машины.
Значит, и мы применяем правила.
Во-первых, почему правило может быть применено
только одно? Посмотрите, у нас
применение правила
включает в себя символ состояния.
Он единственный.
И видно, что
если мы посмотрим на символ справа,
то у нас однозначно определена пара
для таблиц переходов.
Какое состояние, какой символ.
И для каждой такой пары у нас есть
строчка.
Значит, когда мы ее применяем,
вот давайте смотреть здесь,
у нас никто никуда не сдвинулся,
головка находится над тем же символом,
состояние изменилось,
символ изменился.
Ну, то есть все корректно преобразовалось.
Если мы смотрим на специальный пустой символ,
я хочу поддерживать вот этот вариант,
что конфигурация океймлена
специальными пустыми символами.
Ну, тогда мы не можем просто взять
и заменить на какой-то аш-трих,
у нас пропадет специальный пустой символ.
Мы делаем очень просто,
мы вставляем сюда
специальный символ. Именно поэтому мне удобно
допускать
в рабочих словах, чтобы там
были какие-то еще пустые символы,
не обрезать максимально коротко,
ну, иметь какую-то свободу,
потому что правила не знают,
что там дальше будет.
Теперь, когда сдвигаемся вправо,
ну, тут все то же самое, смотрите,
с этим символом, и команда движения вправо,
значит, этот символ у нас останется
теперь слева
от символа состояния. Ну, вот оно так
заменяется. Это не работает,
если мы нарвались
на специальный пустой символ,
потому что мы хотим, чтобы
все океймлялось
вот этими специальными пустыми символами.
Мы хотим, чтобы
вправо от него мы не уходили. Ну,
так вот мы и делаем. Мы делаем такую же
замену, но только
записываем еще этот специальный пустой символ,
который
фиксирует край
нашей рабочей зоны. Ну, и наконец,
когда движение влево, все то же самое.
В типичном случае
мы меняем символ
вот этот, но поскольку мы сдвинулись
влево, нам нужно еще смотреть
вот на этот символ, и мы оказываемся
слева от него.
Тут, конечно, вы
можете спросить. У меня был
еще слева
океймление. Зачем оно нужно?
Вот так вроде бы выясняется,
что не очень нужно, но так удобнее.
Потому что нам потом надо
стирать. Можно было бы использовать
маркер конца, но тогда
нужно было бы как-то это рабочее множество
сильно пересказывать, потому что на маркер конца
головка может выходить, и тогда
получается, что символ состояния
окажется слева. Мне удобнее считать,
что у меня есть символ, вот этот специальный
пустой, который и маркер конца тоже
ограничивает. Но в результате
B
для тех машин,
которые я определил никогда,
не может равняться специальному пустому символу.
Почему? Потому что если
мы видим вот такую
конфигурацию,
ну там что-то,
то есть вот головка вышла
на маркер конца, мы знаем,
по нашим правилам, машина
в такой ситуации
будет делать ход обязательно вправо,
то есть с маркера конца она уходит
обязательно вправо,
а это все только командам движения
влево, значит это просто
неприменимо. Таким образом первое свойство
мы проверили, и все однозначно,
то есть мы к данному
рабочему слову, если слово
не принадлежит рабочему множеству, конечно
правил может быть применено несколько, например
несколько символов состояния,
и возле каждого мы можем применить правила.
Но это нас абсолютно не волнует.
Но ведь нужно только свадимость построить.
Это исчисление больше ни для чего не нужно.
Ну и наконец второе свойство, оно
обеспечивается вот этим, потому что, смотрите,
вот мы получили какое-то финальное
слово, оно имеет вот такой вид.
Х и у принадлежат
А.
Ну, тогда мы можем применять
вот эти вот два правила
и сокращать х и у,
то есть вычеркивать по очереди символы.
В у
самый левый, в х самый правый,
длины их будут уменьшаться,
в какой-то момент они станут пустыми оба.
После этого мы получаем
вот такое как раз слово
и нам
нужно достичь лямда 0,
лямда 0, вот мы его и достигаем с помощью этого
правила. Таким образом
мы проверили,
что
вот такие правила гарантируют
выполнение этих двух свойств, а эти два свойства
вот тут вот описаны доказательства корректности
свадимости.
Ну хорошо, самое время вернуться
к тому, про что я предупредил
перед перерывом, а во всем этом
рассказе, в этом доказательстве
свадимости есть пробел.
В чем он состоит?
Ну вот в чем состоит.
Я напомню, что сводящая функция
должна быть тотальной.
То есть
у нас не любое
двоичное слово является описанием машины
тюринга или входа.
Конечно, могли бы озаботиться
тем, чтобы любое двоичное слово
кодировало какую-то машину тюринга и входа,
но мы этого не сделали.
Значит, могут быть слова,
которые не являются
кодировками машины тюринга и входа,
кодировками машины тюринга и входа.
И с ними тоже что-то нужно сделать.
Свадящая функция что-то должна
на них вычислять.
При этом, что можно считать?
Что кодировка эффективна.
В том смысле, что глядя на слово,
вы можете сказать, является она кодировкой машины и входа
или не является.
То, что я обсуждал намеками, как устроена кодировка,
ясно, что есть алгоритм, который проверяет
по слову, что действительно это корректная
кодировка какой-то машины.
Там нужно разные вещи проверять,
потому что у нас есть
ограничения на функцию переходов,
и что она тотальная,
и что там выполняются вот эти условия
на маркере конца.
Но это все делается, естественно, алгоритмически,
и тем самым по тезису
черча тюринга делается и на машине тюринга.
Но тем не менее, нужно
что-то сказать.
Вот в этой свадимости нам не хватает,
допустим, слова W
не принадлежит
множеству слов, которые являются
описаниями машины тюринга и входа.
Наша функция должна
что-то с этим словом сделать.
Давайте подумаем, что она
должна сделать, чтобы свадимость была корректной.
Нам нужна вот такая равносильность.
То есть, если
вход
описывает
машину тюринга и слово,
на котором она останавливается,
мы должны попасть
в вычисления,
где из начального слова
достижимо конечное.
А если нет,
то должны попасть в вычисления,
в которые конечное слово
недостижимо изначально.
Но тут вообще нет, конечно,
ответа, потому что это даже не машина тюринга.
Поэтому останавливается ли
машина тюринга, если ее нет?
Ну, она не останавливается.
Нам нужно отправить
это слово в какой-то конкретный
вариант
задачи достижимости,
где
ответ заведомо отрицать.
Ну, скажем такое, алфавит из одного нуля,
правил вообще нет,
начальное слово ноль,
конечное слово два нуля.
Ну, поскольку правил вообще нет,
граф состоит только из изолированных вершин.
Если слова разные,
то ни одно недостижимо из другого.
То есть вот это вот
технически нужно сделать. Здесь это просто
бывают на самом деле
свадебности, где для достижения
всюду определенности приходится
тратить больше сил. Обычно
это все вот примерно так и делается,
то есть очень часто про это забываем говорить.
Но в принципе
это нужно следить, потому что бывают случаи,
когда это не столь очевидно,
и нам требуется усилие, чтобы
этого добиться.
И можно создавать какие-то искусственные ситуации,
где этого добиться нельзя, и тогда
начинаются проблемы.
Ну, это так в теории алгоритмов
разные интересные упражнения с этим связаны.
Нас уже все
устраивает.
Нас уже
все устраивает, но теперь
нужно сделать следующий шаг.
Я напомню, я
двигаюсь в сторону общезначимых формул,
пока до них далеко, пока только какие-то
подстановки
слов, никаких тебе
общезначимых формул. И первый шаг
дальше
состоит в том, чтобы
рассмотреть вариант
исчисления, который называются
туевские системы
или симметричные исчисления.
Давайте я где-нибудь
вот здесь
это напишу, потому что
мне как-то жалко стирать, там
много мне пригодится сейчас, значит,
симметричные исчисления.
Формально это просто частный случай
общих исчислений, но только
выполняется такое
свойство, что если у нас есть правила
из УВ, то есть и правила из ВУ.
Другими словами, у нас
мы определяем фактически неориентированный
граф. То есть правила
подстановки можно использовать как по
стрелке, так и против стрелки.
Ну и получается неориентированный граф, у нас
есть два слова, они связаны между
собой, можем перейти из одного
в второе, из второго в первое.
Вот все ограничение.
Это уже называются туевские системы.
Потому что
я на самом деле их изучал, я
не уверен, что сегодня успею это
объяснить.
Получаем, соответственно, задачу
достижимости для туевских систем. Вот транзитивное
замыкание я буду обозначать тоже двойной
стрелочкой со звездочкой. Это понятно, что
такое. Это есть последовательность слов.
Каждая пара соседних
связана вот этим вот отношением,
уже симметричным отношением.
Поэтому мы можем идти как по стрелкам,
так и против стрелок.
И вопрос тот же самый.
Нам нужно доказать, что
не вопрос, а утверждение.
Что
проблемы остановки сводятся и
к туевским системам.
Почему я так все это сохраняю?
Потому что тут удивительный факт.
Вот та свадимость, которую я описал,
она, конечно, длинная и морочная, но
в ней есть очень много приятных
моментов.
В частности, она удивительным образом
работает и для симметричного
случая.
То есть вот я хочу свести
остановку машины и тюринга
к уже симметричному исчислению.
Я буду делать все то же самое.
Вот такой же алфавит, такие же
правила, все то же самое.
Единственное, что у меня тут стрелочки были
односторонние, а теперь они будут
двусторонними. Но я их даже не буду писать
двусторонними, а буду просто понимать, что
нам разрешено делать ход как
по стрелке, так и против стрелки.
Это мне будет удобно в доказательстве
именно так к этому относиться.
То есть буквально та же свадимость.
Это кажется удивительным, но
тем не менее.
Давайте посмотрим, что у нас
меняется.
Ну,
случай B не меняется
никак.
Потому что, смотрите, если машина останавливается,
то мы уже изучили,
что мы можем достичь
изначального слова конечное, двигаясь по
стрелкам, то есть применяя правила в одном
направлении. Ну и отлично, нам разрешено
в обоих направлениях применять. Значит,
в симметричном случае тоже достижено.
То есть вот это вот мы
сделали. А вот здесь сложнее,
потому что теперь нам нужно
рассматривать более сложные пути.
Мы можем двигаться как по стрелкам,
так и против стрелок.
И нам нужно доказать,
что, если мы можем достичь
финального состояния,
двигаясь как
по стрелкам, так и против стрелок, мы можем
достичь так же и двигаясь в правильном
образом по стрелкам. Тогда мы уже доказали,
что это...
Если машины не останавливаются, это невозможно.
То есть вот тут нужна дополнительная работа, и мне по-видимому
придется все-таки стереть определение свадимости,
но оно так уже довольно давно перед глазами.
Я надеюсь, что мне, собственно, хотелось его оставить до
того момента, когда я уточнял свадимость на особым случай.
Почему так получается?
Потому что у нас есть еще одно свойство.
Вот, предположим, я из слова w1 получаю по стрелке слово w2,
и w2 принадлежит рабочему множеству.
Тогда и w1 тоже принадлежит рабочему множеству.
То есть другими словами, если я хочу пойти против стрелки
из элемента рабочего множества, я только в рабочее множество
могу попасть.
Ну, это можно увидеть вот из этих правил.
Смотрите, значит, я меняю наоборот вот в обратную
сторону, но ясно, что такое изменение мне даст опять
такие элементы рабочего множества, потому что у
меня опять получается какой-то символ состояния, причем
он не финальный, потому что из финального мы не делаем
перехода.
Значит, получается рабочее множество.
То есть если у нас есть такой переход, значит, двигаясь
против стрелок, мы никогда из рабочего множества не
выходим.
По стрелке выйти можем, потому что у нас такое вот
было.
А против стрелки не можем.
И вот это вот свойство, оно будет достаточно, чтобы
доказать усиленный вариант вот этого утверждения.
Двигаясь даже против стрелок, мы все равно в финальное
множество не попадем.
Но как это доказывается?
Значит, доказывается это так.
Если мы можем попасть, вот представьте, что мы попали.
Теперь я вот как-нибудь нарисую более общую ситуацию.
Вот мы двигаемся где-то по стрелкам, где-то против
стрелок, где-то опять по стрелкам и так далее.
И попадаем, наконец, в слово из финального множества.
Значит, вот во-первых, вот этот вот последний момент,
он обязательно будет по стрелке в силу того свойства,
которое я сказал.
Если мы вообще смогли попасть в финальное множество, последний
переход был по стрелке.
Я теперь хочу сказать, что если есть такая последовательность,
то есть последовательность, в которой все шаги делаются
по стрелкам.
Этого нам будет достаточно.
Шаги по стрелкам у нас в финальном множестве в этом
втором случае не приводят.
Ну как это доказать?
Рассмотрим кратчайший путь из вот начального, кратчайший
путь в f.
Неважно в какое слово из f, кратчайший путь в f.
Я утверждаю, что он идет обязательно по стрелкам.
Ну давайте на него посмотрим.
Ну здесь собственно нарисовано, ну давайте я его перерисую.
Тут где-то с по стрелкам, где-то против стрелок.
Последний ход обязательно по стрелке.
Давайте найдем самую правую позицию, когда был сделан
ход против стрелки.
Правее у нас еще не может быть финального множества,
ну точнее уитой может уже быть финального множества,
но ход обязательно по стрелке.
Раз-то последний ход против стрелки, дальше все ходы
по стрелке, хотя бы один такой будет.
Почему я так на это упираю?
Потому что я напомню, что наши стрелки проводятся
так, что из каждого слова выходит ровно одна стрелка.
У нас однозначно применено, пока мы находимся в рабочей
множестве.
Но это что означает?
Вот смотрите, вот одна стрелка выходит в уи плюс первая,
а другая выходит в уи минус первая.
Но это означает, что уи плюс первая просто равняется
уи минус первая.
А тогда что за кратчайший путь?
Я могу просто уитое выбросить, и все, и путь станет короче.
Пришли к противоречию.
То есть кратчайший путь, он должен быть иностронним,
мы должны применять только по стрелкам.
Ну и отсюда следует уже доказательство корректности
для симметричных исчислений.
Симметричные исчисления имеют очень внятную алгебраическую
интерпретацию, и мне она как раз будет нужна, и
наверное я успею про нее рассказать, но я хотел
бы хотя бы коротко объяснить про ограниченную задачу
достижимости.
Что?
Мы проверяли это.
Ну, смотрите, вот это правило можно применить к рабочему
слову, одно из этих правил можно применить только единственным
способом.
Потому что по индукции мы доказываем.
Заметьте, что количество символов состояния не меняется,
оно все время остается равным единице.
Правила так устроены.
Значит, мы находим символ состояния и смотрим на следующий
справа символ.
По нашему построению в рабочем множестве справа
есть символ, потому что есть окаемление, по крайней
мере, лямда нулями.
Ну, значит, деваться некуда, значит, есть символ состояния
и следующий символ.
И это отвечает таблице перехода, вот все возможности,
для этой пары у нас значение в таблице перехода какое-то
записано единственное, вот мы только такое правило
можем применить.
Любое другое будет неприменимо, потому что у нас нет другого
подслова, которое начинается с символа состояния и потом
идет символ алфавита.
У нас такое подслово в рабочем слове единственное.
Ну и к нему применимо только одно из правил.
Значит, ограниченная задача достижимости.
Это я, в общем, уже немножко даже сказал, но я сейчас
хочу, вот пусть у нас есть зафиксировано какое-то
ассоциативное исчисление, даже не обязательно симметричное,
потому что в реальной жизни оно было именно для симметричного
рассматривалось.
И мы рассматриваем такой язык множество таких пар
у и в, что из у достижимо в.
И нас интересует разрешим ли он.
Ну, в зависимости от того, какой язык рассматривать,
это вот этот язык может быть и разрешимым, и не разрешимым.
Например, если множество правил пустое, как мы уже
обсуждали, там все очень легко.
Мы должны просто сравнить слова у и в, если они не равны,
то они достижимы.
Если равны, то достижимы.
Ну, конечно, это совсем тривиально, а в математике возникли
разные интересные системы подстановок, в основном симметричные
возникали.
И я сейчас, наверное, успею сегодня объяснить, почему
это с алгеброй связано.
Но для каких-то простых исчислений удавалось построить такие
преобразования, которые дают ответ на этот вопрос,
для каких-то не удавалось, и было не очень понятно,
что это возможно.
Вот важная теорема состоит в том, что существует такое
исчисление, что уже вот этот ограниченный язык не разрешим.
То есть одно исчисление.
Правила мы зафиксировали, только вот смотрим на начальное
и конечное слово.
Опять-таки, волшебная сила этой свадимости состоит
в том, что ничего сложного исписывать еще раз с три
доски не нужно.
Все уже на доске есть.
Давайте посмотрим на наши правила.
Заметьте, как они сформулированы.
Они от машины зависят только правила.
Начальное и конечное слова от машины не зависят.
Ну, значит, как получить вот такое вот исчисление?
Нужно применить нашу свадимость к такой машине, которая работает
и моделирует работу любой другой машины на данном
входе.
То есть это называется обычно универсальной машиной
тюринга, и я надеюсь вам что-то про нее в курсе алгоритмов
рассказывает.
То есть такая машина есть.
Ну вот тогда мы возьмем эту свадимость, вместо
М подставим универсальную машину, а вместо X – описание
произвольной машины и входа.
И построим свадимость.
Она будет корректной, потому что у нас всегда это работает.
То есть в этой свадимости очень важно, что правила
не зависят от входных слов.
И получаем такую сложную систему.
Конечно она будет, если реализовывать универсальную
машину как-то тупо, она будет очень длинная.
Но люди постарались, там есть исключительно короткие
примеры таких систем, для которых неразрешима и
правил там совсем немного.
Там понятно идёт, есть два параметра, размер алфавита
и количество правил.
Ну и там, я боюсь ошибиться, но по-моему рекордные результаты
типа такие.
Если алфавит двоичный, то правил нужно семь, а если
алфавит уже то ли троичный, то ли четверичный, то правил
всего два вообще можно использовать, уже будет неразрешим.
В общем, люди много этой задачи думали и разные
интересные вещи придумывали.
Я сейчас скорее хочу объяснить, за оставшееся сегодня время,
почему так важны туевские системы, симметричные исчисления.
Для этого нужно установить связь с алгеброй.
Я в курсе алгебры про это практически ничего не рассказывал,
потому что не было времени.
А сейчас придётся.
Во-первых, я напомню, что у нас есть такое понятие
полугруппа.
Я даже не уверен, что я обводил это понятие в курсе алгебры.
Это тоже множество с операцией.
Но почему это полугруппа, а не группа?
Потому что всё, что мы требуем от операции, это ассоциативность.
Любая группа будет полугруппой, потому что групповая операция
ассоциативна.
Но полугрупп, конечно, гораздо больше, потому что нам
не нужен уже нейтральный элемент.
Если есть нейтральный элемент полугруппа, называется,
извините за выражение, маноидом.
Алгебристы любят много слов, значит, маноид.
И если у нас есть алфавит и множество слов в этом
алфавите, на него можно смотреть как на полугруппу.
Почему?
Потому что у нас есть операция конкатинации, приписывание
к одному слову другое.
Она, естественно, ассоциативна.
Потому что неважно, в каком порядке вы приписываете.
Либо вы суффикс вначале приписали к бы, а потом
префикс.
Либо, наоборот, вначале приписали префикс, а потом
суффикс.
И это маноид, потому что у нас есть пустое слово,
конкатинация с которым ничего не меняет.
И это вот называется свободный маноид, и что более существенно
для меня возникает важное понятие порождающих.
Ну, про группы я тоже говорил, что группа порождается
каким-то набором элементов.
Вот теперь представьте, что у нас полугруппа задается
следующим образом.
Задается множеством как раз порождающих, то есть
это некоторое подношение элементов группы, полугруппы,
и множеством соотношений.
Вот что такое соотношение?
Ну, практически то, что я описал, только понятно,
что в алгебре стрелочки или двойные стрелочки
не рисуют, а просто честно пишут знак равенства.
Уитэ равняется витэ.
Ну, например, давайте рассмотрим, пусть сигма
это два символа, и рассмотрим в качестве R такое правило,
что R равняется BA.
Мы фактически определяем некоторую полугруппу, которая
порождается двумя своими элементами A и B, причем в
этой полугруппе обязательно произведение AB равняется
произведению BA.
Ну, то, что эта полугруппа это на самом деле пары
натуральных чисел с операцией сложения, это легко устанавливается
но сейчас для нас более важный вопрос, почему вообще
это корректно.
То есть, вот смотрите, я взял какой-то набор порождающих
и написал какой-то набор равенства, и говорю, вот
есть полугруппа с такими образующими, с такими соотношениями.
Первый вопрос, который задает человек из муренной
математики, почему вообще есть, что вы имеете в виду?
Написать можно все что угодно, а какой в этом смысл?
Вот я сейчас объясню смысл, и это объяснение как раз
используют симметричные исчисления.
Собственно, они так и появились, когда математики стали
много строить полугрупп, вот таким вот способом,
их коллеги, которые более разборчивые, стали говорить
вообще о чем вы в принципе говорите, и пришлось это
аккуратно сказать.
Вот смотрите, давайте, в результате у меня фактически
получается симметричное исчисление, алфавит и правила
Ну, то что там знак равенства вместо двойной стрелочки
понимаете, ничего не значит.
Замены мы делаем точно так же.
Я хочу определить полугруппу, как я это делаю?
Я определяю, даже не определяю, я прям честно скажу, что
отношение достижимости в данном случае является
отношением эквивалентности.
У нас же отношение исчисления симметричное, мы можем сделать
замены как слева направо, так и справа налево, и это
как обычно в случае неориентированных графов, для бесконечных
графов то же самое.
Области достижимости задают разбиение на классы эквивалентности.
То есть, отношение достижимости – это отношение эквивалентности.
Если вы можете из У достичь В, из В вы можете достичь
У.
Из У достижимо О.
То есть, это я проверил симметричность и рефлексивность.
Ну и наконец-то проверить транзитивность, тоже никакой
проблемы, если я из А попал в В, из В попал в С, как попасть
из А в С?
Ну, попасть в В, а потом попасть в С, то есть, просто повторить
эти замены.
И тогда я определяю такую полугруппу, которая состоит
из класса эквивалентности по этому отношению.
То есть, это множество, мне надо еще определить
операцию.
Операция определяется так, я напомню, что я, когда
говорил про классы эквивалентности, очень любил квадратные
скобки в алгебре.
Сейчас я это напишу точно так же.
Вот у меня есть один класс эквивалентности, есть второй
класс эквивалентности, и я хочу определить операцию
на них.
То есть, в первом классе эквивалентности есть слово
У, во втором есть слово В, тогда я говорю, что результат
применения операции – это тот класс, в котором лежит
их конкатинация.
Я надеюсь, что вы помните, какая засада с определениями
такого типа.
Нужно корректность проверять.
Давайте проверим корректность.
Предположим, что у1 эквивалентно у2, v1 эквивалентно v2, нам
нужно доказать, что тогда у1, v1 эквивалентно у2, v2, то
есть, что результат операции не зависит от выбора представителя
в классе эквивалентности.
Но в данном случае это очень просто, потому что,
смотрите, у меня есть преобразование, я длинную стрелочку нарисую,
из у1 в у2, из v1 в v2.
Теперь, как мне построить, зная, что у меня такие преобразования
есть, как мне построить преобразование конкатинации.
Ну, у нас же правила подстановки, они локальные, оттого, что
у меня появился префикс, никто мне не мешает в префиксе
сделать вот эту вот замену, получить из у1, у2, а потом
то же самое сделать, не меняя уже префикса, заменить
суффикс.
Таким образом, мы получаем корректно определенную,
корректно определенную полу-группу, и заметьте,
что в результате разумно вот тот язык, который я назвал
и это называется проблема равенства слов в полу-группе.
У вас есть два слова в полу-группе, заданные образующими
соотношениями, вам нужно проверить, равны они или нет.
Ну, это то же самое, потому что в сущности равенство
это и есть принадлежность к классу эквивалентности,
то есть фактически наша задача о симметричных
исчислениях, она кодирует вопрос о равенстве элементов
в полу-группах, и мы уже видели, что в общем случае
эта задача неразрешима, более того, есть совершенно
конкретная полу-группа, для которой она неразрешима,
вот как на правой доске написано, по универсальной
машине Тюринга, я построю просто двустороннее
исчисление, оно будет задавать какую-то полу-группу,
и с этой полу-группой будет дедам.
Вот, она уже будет очень сложной.
Ну, вот это вот, фактически я здесь ничего не доказал,
доказал какую-то корректность там, определение, но это
вот решающий шаг, то есть сводимость было трудно
строить для исчислений, а чтобы сделать следующий
шаг к общезначим формулам, мне как раз нужна вот эта
интерпретация в виде полу-групп.
Ну, можно было бы это все пересказывать в терминах
исчислений, получилось бы менее естественно.
То есть дальше я буду говорить о том, что у меня есть
полу-группа с порождающими соотношениями, и вот есть
два слова, равенства которых я хочу проверить, и буду
уже эту задачу, которая ЭК у меня обозначена, сводить
проверки общезначимости форм.
И тут симметричность очень важна.
Заметьте, что если мы рассмотрим ориентированные графы,
там тоже есть отношение достижимости, но оно принципиально
сложнее.
Оно, конечно, транзитивно, но оно не симметрично.
Кстати, получается, какой-то такой частичный квазепорядок,
его описывать гораздо сложнее, а вот отношение
экологенности мы формулами первого порядка очень аккуратно
сможем задать.
Ну, на сегодня тогда все.
