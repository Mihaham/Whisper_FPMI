Поднимите руку, кто ассоциирует полиморфизм с одним из китов ООП.
Ну так вот, говорят в вакууме, полиморфизм. Первая мысль.
Есть большой вопрос, что вы будете взяли под ООП.
Вот серьезно, потому что если вы видите РАС,
можно сказать, что там ООП есть, но при этом можно сказать, что он там нет.
Это чисто, как бы, скромное мнение о том, что ООП, а не тема того, что есть в РАСе.
Ну тогда у кого первая ассоциация с полиморфизмом, это Джава?
Нет? Ну ладно.
Короче, сегодня будет не про ООП-полиморфизм,
но вернее, не только про него, а про то, что слово полиморфизм,
оно вообще там тянет свои корни из зарождения компьютеров,
и вообще-то это слово о том, что есть в РАСе.
В общем, давайте поедем. Вперед. Вот определение вам. Прям из книжки.
Умный дядя. Вандервурд вроде.
Могу путать авторов.
Ну вот полиморфизм в целом, это...
Мы написали кусок кода, вот он выглядит как-то.
Буковки написаны.
А дальше он по-разному работает в зависимости от чего-то.
Либо вам принадлежит, либо не.
Он по-разному работает в зависимости от чего-то.
Либо вам прилетел разный объект в рантайме,
и один и тот же код работает по-разному.
Либо вам шаблон инстанцировали с разным аргументом,
и в итоге разные функции вызвались, и все по-разному работает.
То есть полиморфизм это максимально общее понятие в компьютерсиансе, в принципе.
Если вы, так сказать, полиглот и знаете много разных языков,
то у вас, возможно, такое чувство уже начинает закрадываться в вас.
Ну, наверное, на четвертом курсе должно.
Что, в принципе, полиморфизм это мега-общая тема,
и везде его делают по-разному, очень по-разному.
Я уже там что-то спылилил, по-моему, на каких-то прошлых занятиях,
но сейчас вот будет в полную меру.
Ну и вообще полиморфизм это там многоформенность,
в переводе с какого-то, наверное, с греческого.
Ну, примеров, полиморфизму вы, наверное, много уже видели,
и сами можете там миллион привести,
но если самое тупое, для скидки, это, конечно же, всякие виртуальные штуки.
Ну, очевидно, это полиморфизм.
Вот эти вещи это тоже полиморфизм.
В каком смысле своп полиморфный?
Ну, понимаете, любые, и работать с ними как бы по-разному, при этом...
Ну да.
Да, то есть как бы мы один тот же своп написали,
а дальше аргументы могут быть любые, и все работает.
Ну, как бы не только.
Мы про ADL говорили.
Вот это тоже как бы аспект полиморфизма.
Некоторые, да.
Ну, sort и exchange, понятно, по такому же принципу,
что угодно пихаем, все работает.
Но тут есть некоторая разница между своп exchange и sort,
потому что класс, на котором работает exchange,
на нем не обязательно сработает sort.
Но при этом как бы извне кажется, что все одинаковое,
и, в принципе, и то, и другое, и третье такое, статический полиморфизм.
Ну, давайте чуть поглубже в такую терминологию того,
что я вообще сейчас буду говорить.
Ну, вот поведение, которое у нас определяется нашей обобщенной нотацией,
оно может определяться разными вещами.
Это может определяться значениями,
такой первый уровень иерархии условной,
а может определяться семействами значений, то есть типами.
Причем это там происходит на этап раньше, в момент компиляции.
Обычно.
Но на самом деле нет.
Ну, не всегда в смысле.
Можно дальше пойти по этой иерархии.
Вот у нас есть значение, группа значений, типы.
Есть группа типов.
Это группа называется kind,
и в некоторых языках с этим прям явно можно работать.
Ну, вот про что это вообще?
Чувствуете ли вы отличия между значением какого-то int
и какой-то лямбой?
Они принципиально разные.
Разные какие-то категории мыслительные.
Лямбда это что-то, что можно запустить,
а int это какие-то данные, которые надо использовать.
Такое же различие есть в шаблонах.
Вот у нас есть тип, который...
Ну, просто тип.
Какие-то данные в нем лежат.
А есть тип, который шаблон.
То есть когда мы шаблонные шаблонные аргументы пишем...
Писали там сколько-то пар назад.
Я там говорил, что шаблонный шаблонный аргумент
это как будто передать указатель на функцию.
Ну, и вот пишем мы класс
или мы пишем template class class.
Вот просто шаблонный типовой аргумент
и шаблонный шаблонный аргумент.
И то, и другое с какой-то точки зрения можно сказать типы.
Но вот у них разные kind.
Потому что одно работает как функция на типах,
а другое работает как просто тип.
На уровне системы типов лямбды?
Вот, вот.
Вот это люди зашли далеко в познание бытия.
Ну, это здорово, да.
Ну, в общем, если вы хотите красоты
и наслаждения от жизни,
и системы типов крутой,
наверное вам либо в скалы, либо в хаскель.
В хаскеле тоже подобные приколы есть.
Ну, там в хаскеле можно прям явно
оперировать над kind.
Вы можете сказать, мой шаблон,
на самом деле не шаблон, конечно же, да, там,
принимает тип, у которого kind это звездочка.
И это значит, типа, не функция.
Ну, то есть, просто какой-то тип данных.
А можете сказать, звездочка,
стрелочка, звездочка.
Вот это уже будет как бы мой...
Моя штука принимает метафункцию.
И сама внутри себя туда запихивает
какой-то тип,
и уже получает другой тип,
и вот, ну, такие вещи.
Ну и на самом деле эту иерархию можно дальше продолжать.
Про это есть целая наука там
в теории типов.
Может кто-то слышал всякие гомотопные типы,
вот такие какие-то странные вещи.
Они, кажется, в этом...
Чего?
Такого умного слова я не слышал.
А, dependent types
это немножко не про это.
Тут вот в другую сторону обобщение,
про то, что вот мы там вот эту штуку продолжаем,
потому что kind это как группы
типов, а давайте группы kind и так далее.
Ну, это так, для общего развития,
в других языках это есть,
и поэтому тоже бывает полиморфизм.
Но в плюсах у нас этого все нет.
У нас только либо по типам,
либо по значениям.
Выбора не очень много.
И вот пошла такая таксономия,
что есть некоторые свойства
различных видов полиморфизма.
Вот эти вот слова вы можете
увидеть в ответах на stackoverflow,
во всяких книжках там,
во всяких обсуждениях в интернете.
Очень пламенных обсуждениях
на реддите.
Поэтому давайте проговорим про них,
чтобы примерно иметь представление,
что это за слова.
Первое очевидное разделение это на статический динамический полиморфизм.
У нас поведение может
определиться в разные моменты времени.
Либо на этапе компиляции, либо в рентайме.
Ну, на самом деле тут немножко
сложнее все.
На этапе компиляции.
А вот на какой части этапа компиляции?
Вообще-то, вообще-то.
При процессоре тоже можно себе
устроить полиморфизм.
Если постараться.
То есть что-то, что напоминает полиморфизм.
Ну, раз уж мы говорим,
что и шаблоны это полиморфизм,
то в принципе все полиморфизм.
И определение выше оно все подходит.
Ну и в линковщике можно устроить полиморфизм.
Это, кажется, на самой первой паре.
Нет, на второй.
На второй паре, кажется, или на первой.
Ну, какой-то из них вам говорил про
линковку.
Я бы упоминал, что там
подменяем целый cpp-шник
на другой cpp-шник, где все функции такие же.
Но при этом реализация у них там
пустая, либо просто ассерт стоит.
Ассерт ноль.
Но вот это тоже своего рода полиморфизм.
Мы как бы в других
модулях кода пишем просто
вызовы функций,
а потом подменяем поведение
просто другим флагом компиляции.
Да, на этот слайд, наверное, надо добавить,
что бывает, что еще все зависит
от флагов компиляции.
Такие вещи тоже бывают.
Ну вот.
Ну, кстати, я сам вот это вернулся.
Можно ли концепты
в каком-то смысле считать в подобном
плане, типа в наедине концепты
и требования для типов?
Ну, как бы формально
в какой-то
степени кажется
да, но это скорее
некоторая такая шняга,
которая позволяет закодировать
одно в другом, мне кажется.
Потому что как бы
ну вот есть у вас множество.
И в этом множестве в том числе есть функции.
Ну, на самом деле, да, там
говорим не множество, говорим какая-нибудь категория
дурацкая или еще что-нибудь вот такое, да.
Но как закодировать
вообще вот какой-то
набор множеств?
Набор значений?
Ну, типом мы умеем, да, а как еще можно
закодировать набор значений?
Тупо. Чтобы в коде можно было
проверить, принадлежит значение нашему набору
или нет?
Кажется, я вас
сломал, но это тупой вопрос.
У вас есть набор значений каких-то?
И вы хотите
уметь понимать по новому значению?
Лежит оно в наборе или нет?
Просто в рантайме?
Просто в рантайме, да.
Можно предикат написать, можно векторочек
завести, по нему искать, можно сетик.
Много способов, да, но фактически
все к функции сводится, что давайте
заведем предикат. Вот он будет нам
говорить по значению,
являемся мы
элементом множества или не являемся.
Казалось бы, тогда ну давайте
как бы вместо типов использовать функции
предикаты на значениях.
Почему это в плюсах не работает?
Вот если вы хотите закодировать тип,
в котором может лежать либо
int, либо пара флотов.
Можете ли вы написать
предикат, который как бы в рантайме,
которому в рантайме и то, и другое
можно передать,
ну и как бы, и на то, и другое он скажет
да. Или там что угодно,
любое значение, да, нам нужен предикат, которому
любое значение можно передать.
И он скажет да
только если нам передали int или там пару
флотов. Шаблоны?
не читаются. Но как бы в JavaScript вы можете, вам передают любую фигню и вы
спрашиваете, а что это за фигня? Или в Java можете, вам передают любой
object и ну ладно, не совсем можете, там вот эти вот примитивные типы, с ними
проблемы, но в Python можете, у вас просто функция, ей передали что угодно, это
любое значение и вы можете посмотреть, что это за значение, какой у него тип,
ну и как бы вот мы закодировали типы в Python без типов.
Ну нет, это не особо, тут надо почувствовать, что требуется все в runtime делать,
вот как бы на уровне, нет, он делает в runtime, если у тебя RTTI включен и
polymorph на иерархии и там ну нет, нам с любыми значениями, в первую очередь int,
всякими парами и так далее, структурками, вот, то есть в Python мы можем
закодировать множество, ну тип закодировать как просто функцию, это функция, которая
возвращает true или false для любого значения, если оно лежит в типе, то true или true,
нет, false. Так вот, концепты, это та же самая идея, но на уровне ниже, это кстати
еще одно важное наблюдение про плюсы, вот если мы на этом уровне работаем, то
плюсы строго типизированы, а если мы спускаемся на уровень ниже и работаем на уровне типов,
то строгой типизации в плюсах, грубо говоря, нету. Вы когда пишете в шаблоне класс T, значит туда
можно передать любой класс, вообще любой, это то же самое, как когда вы в Python пишете dfu от x,
вот туда можно передать любой x, любого типа, любое вообще что угодно.
Да, это предикаты на типах, то есть как бы тут у нас сделано нормально в плюсах на уровне значений,
вот мы строго решили, что мы не будем страдать фигней, какую-то динамическую типизацию вводить,
потом какими-то функциями пытаться понять, что это есть на самом деле, да, как в TypeScript,
мы сделали нормально, прямо на уровне языка семейства типов, а для типов нормально делать,
мы решили, что не особо надо, и тут у нас Python на уровне типов происходит, у нас все не типизированные
на уровне типов, ну или bash даже, да, ну в bash тоже по-моему не все строка, там как-то еще
что-то бывает вроде, а может и нет. Ну почувствовали, о чем я говорю, что вот концепты, это костыль на вот
этом уровне типов вместо kind, как бы нормальные kind в плюсы впилить невозможно, потому что
по-другому язык вообще строить надо изначально было, смотрите Haskell, или наверное Scull,
мне кажется, там тоже таким занимаются люди, но я не уверен, но Haskell-и точно этим занимаются.
Можно пример какой-то функциональности, которые есть в Haskell, в Scull, но нет в плюсах с того,
что у нас это концепты и все криво, косо не работает.
Ну вот TypeKind, да, есть такой extension, называется TypeKind, вот про него можно почитать, нет,
ну TypeKlasse это немножко про другое, мне кажется. В общем вот, да, TypeKind, вот про них если почитать,
да и в принципе TypeKlasse тоже как-то в ту же что ли стезю, вот тут я свои мысли еще не организовал,
если честно, но TypeKind, кажется, ровно про это. Про них надо почитать, потому что я сам наизусть
не помню, в какой-то момент Haskell-ом очень интересовался и прям все гуглил, смотрел,
где используется, там офигевал от того, чем люди занимаются, пока мы тут байтики перекладываем,
вот, но потом забыл, потому что было это все давно, вот, соответственно, более глубоко я в это не смогу
углубиться, но аналогия, по-моему, тут прекрасная, да, что мы как бы, также как в TypeScript, фиксит
отсутствие типизации функциями, которые возвращают true-false по значению, грубо говоря, да, вот это
на уровне значений происходит, также мы в плюсах на уровне типов фиксим отсутствие типизации,
добавляя предикаты на уровне типов, то есть концепта, ну, то есть такой дизайн нельзя назвать
плохим, но он с математической точки зрения не вызывает вот трепета в сердце, вам так не кажется,
вот если вся иерархия тут с высшими типами была выстроена, и все по красоте, тогда вот
прям трепет, красиво, а мы решили нет, ну и выбора-то особо не было, в общем, ладно, давайте дальше идти,
мы уже слишком долго говорим про это, давайте дальше про вот эту таксономию дурацкую, ну, не дурацкую,
если ей все пользуются, то она не может быть дурацкой, правда ведь? Да, тут вот есть еще такая вот
шняга, открытый и закрытый полиморфизм, или bounded, intrusive, или unbounded, non intrusive, и вот тут очень
сложно сказать, что конкретно имеется в виду, и вот эта строчка, наверное, у вас может вызывать
вопросы, у меня она тоже, конечно же, вызывает, вот умеет ли система типов проверять, определено ли
поведение, ну, по факту это наилучшая формулировка, которую тут можно привести, а что это по факту
значит? Это некоторый способ отличить ООП, в котором вам нужно наследоваться от интерфейса и менять
свой тип, чтобы войти в какое-то полиморфное семейство, от шаблонов, где с типом делать ничего не нужно,
вы просто подставляете этот тип и все работает, да, то есть если вы там вспоминаем вот этот пример
с бинпоиском, который когда-то я тут сидел кодил, что когда вы делаете интерфейс для обобщенного
бинпоиска на ООП, вам нужен интерфейс iCompareable, и новый класс нужно садиться и наследовать,
и там руками вписывать что-то, чтобы работало, когда вы пишете шаблоны, вы можете где угодно
оператор сравнения передать, а то и компаратор какой-нибудь, и все, будет работать, ну, тут вот
про это речь, да, нужно ли вам как-то менять ваш старый код, чтобы вписаться в полиморфизм,
или можно вписать кого-нибудь просто так, на самом деле очень мутная тема действительно, причем
слова эти, ну, давайте так, поднимите руку, если вы уже слышали где-то про там открытый-закрытый
полиморфизм, bounded, unbounded, на удивление мало людей, ну, вот, чуть плюс-минус, да, где-то оно встречается,
вот, вот, вот в этом проблема, потому что все используют эти слова, но никто не может толком объяснить,
что они значат. Да, ну, или даже просто в рамках плюсов, вот шаблонные концепты,
сравнивать с классами и интерфейсами, да, ну, вот в Расте там ОП устроено, оно как бы, вот,
интерфейсы ОПшные, они как бы интегрированы с концептами, грубо говоря, и это одна и та же
сущность, и как бы имплементацию методов для какого-то интерфейса вы пишете вне класса, и оно
такое открытое, типа, ну, надеюсь, основную мысль поняли, и последняя, у нас бывает single
dispatch, бывает multiple, все, о чем мы до сих пор говорили, это в целом single dispatch, да, так, я не
сказал, что это значит, сколько таких абстрактных сущностей определяет наше конкретное поведение,
ну, вот в джаве, какой dispatch, везде, single, да, там вот есть текущий объект, вот он определяет,
его настоящий рентайм-тип определяет поведение, вот иначе никак, ну, можно руками что-то
кастылять, но вот ОП классически это single dispatch, а вот шаблоны, ну да, у нас может быть несколько
шаблонных аргументов и будет вполне себе multiple dispatch, ну ладно, давайте на этом с примерами
закончим, пойдем вот, да, но когда ты пишешь код там указатель на интерфейс.foo, сколько сущностей
определяют, какая конкретная фу, в каком файле будет вызвана, нет, ну, у тебя есть один объект в коде, вот
этот объект, указатель на который ты использовал, чтобы позвать функцию, вот этот один объект, он
полностью определяет, вот его рентайм-тип полностью определяет твое поведение, да, вот про это речь
здесь, то есть в случае с ОП подразумевают, что поведение определяется значением в рентайме и
только одним, вот один объект, ты на нем метод зовешь, вот только его значением определяется,
какой метод конкретно у кого вызовется, вот, да, тобла токсинамии, это еще какая-то классификация,
которая тоже постоянно используется, вот слова от Хогг-полиморфизма, я думаю, вы вообще это,
ну, все должны были слышать когда-нибудь, правда? Теперь еще раз услышите, ну, я нашел такое
определение, некоторые общая нотация, работающая для вообще каких-то типов и никакого адекватного
способа понять с работы для нашего конкретного типа или нет, нам не предоставлена, вот он всегда
задумано, что он баундед, да, то есть мы, если бы мы в типе явно указывали, что мы там вписываемся в
какой-то полиморфную тему, то тут было бы легко понять, сработает ли наша нотация или нет,
ну, посмотри на тип, там написано сработает, значит сработает, то есть вот эта штука,
она всегда unbounded, ну и тут куча примеров накидана, потому что давайте уже от конкретики,
а вот перейдем вот от всех этих абстрактных рассуждений, супер конкретно, внезапно перегруженные
функции оператора это такой ad hoc полиморфизм статический, ну еще в хаскеле он по-моему есть,
вроде да, да, перегруженный оператор конечно есть в хаскеле или нет, я забыл, ну в плюсах точно есть,
то есть вы пишете а плюс б и вы не знаете, что происходит, то есть а может быть вектор, может быть
тинг, может быть float, может быть это какая-то монада и там плюс вообще бог знает, что делает,
ну верите мне, да, что это такой unbounded, статик, полиморфизм, общая нотация работает для непонятной
чего, ну какого-то способа адекватного проверить, что она работает, кроме как написать и посмотреть, нету.
Ну да, это такой способ проверять рабозаспособность ad hoc полиморфизма, что-то вот такое, ну и концепты
толком-то вот requires expression это именно про это, а давайте просто ad hoc проверять работает ли какие-то ad hoc
нотации, да, но с точки зрения человека, который занимается какими-нибудь теориями типов и с
тонкими материями, это все такая гадость, мерзость и вообще это, ну это грех в общем, полная ересь, а на
практике ну внезапно оказывается, что вполне достаточно и работает и все довольны, что бы хотеть-то значит.
Давайте дальше побежим, там еще три слайдика у нас буквально, а специализация это тоже такой, ну в
каком-то смысле ad hoc полиморфизм, мы можем в любом месте взять и специализировать любой шаблон для
любого типа и внезапно поменять поведение и теперь мы используем этот шаблон с конкретным типом, понятия
не имеем, какую специализацию мы получим. Смотрите, std vector bool. Linktime полиморфизма, про которую я говорил, да, вот
это вот подмена одного cппшника на другой, но оно такое тоже ad hoc, конечно никакого способа ничего проверить
тут нет, это вот вообще максимальный ad hoc, ну при процессор всякий тоже ad hoc, сюда же, а в го еще есть
интерфейсы забавные, да, вот это все было статик, пример статического ad hoc полиморфизма, вот
интерфейсы в го, кто знает го? Расскажите нам кто-нибудь из вас, троих, как там работают интерфейсы.
В одном месте пишешь интерфейс, в другом структуру, потом op и они магическим образом подходят друг к другу.
А почему они подходят?
Потому что проверяется в ронтайме, в ронтайме проверяется список методов, нужные методы есть, давай дальше, ну вот по-моему это максимально ad hoc, что только можно вообще сделать, то есть
ну не будем осуждать, го прекрасный язык, чтобы писать микросервисы, да, type erager, знаете что это такое?
В джаве, то что в джаве называют type erager, там просто был чувак, который вот как вы помнит умное слово type erager, но не особо помнит что оно значит, и когда вот джаву писал и вот придумал что, а давайте мы
дженерики сделаем вот так, вот будем заменять все дженерик аргументы на объект и все, вот он это придумал и такой нужно название, ой type erager умное слово, но я же как бы тут типы убрал, на объект заменил, назову тоже type erager.
Мне кажется такова история могла быть, появление этого термина в джаве, но нет это не про это.
Да, нет, ну я, проф деформация.
У вас есть какой-то объект, какие-нибудь методы.
Окей, ты сейчас будешь правильный ответ говорить, и ты собрался правильный ответ говорить.
Ну, да и тогда я не правильный, давайте вы не будете говорить правильный ответ, потому что вторая половина нашего сегодняшнего занятия посвящена тому, чтобы руками писать type erager с нуля.
Я могу предположить, это может быть неправильно.
Не надо, это не так важно, в общем это сегодня мы будем вот вот мусолить до последнего.
Ты знаешь толку о возвращениях, но сегодня не дойдем, я думаю.
Ну да, вот еще бывает всякая эзотерика.
В плане отхог такого динамического полиморфизма, там можно всякие извращения делать в языках, где сильные рефлексии, там каком-нибудь питоне, например.
Можете посмотреть и значение, какой у тебя тип, и тип, а какие у тебя поля, а какие у тебя методы.
Ну и отсюда можно много накуролесить всякого жуткого, но тут конкретных примеров, кажется, не будет.
А да, smalltalk есть очень современные точки зрения лютая эзотерика, но на самом деле все ОП оно пошло же из smalltalk.
Если вы хотите углубиться в корне того, откуда было есть пошло ОП, вам вот про этот язык надо почитать, и это безумно интересно, если честно.
И фотообъект.
Ну любое, в принципе, слово в твоей программе, это должен быть объект, да?
А где ты программу пишешь? Ну в каком-то окне, там текстовом, это тоже объект.
Ну и весь твой редактор, он тоже объект.
Поэтому если ты хочешь, то в своей программе можешь отправить объекту редактора сообщение, удалить мою программу, и так, ну, smalltalk это безумная вещь.
Очень рекомендую почитать, но out of scope, к сожалению, для нас.
Я правильно понимаю, что if это функтор получается?
If?
Ну, smalltalk.
Smalltalk есть объект.
If это объект.
Все, что ты умеешь делать в smalltalk, все-таки отступление сделаю.
Все, что в smalltalk можно делать, это делать объекты.
Объекты единственное, что умеют делать, это обрабатывать сообщение и слать сообщение другим объектам.
Вот это все, что есть в smalltalk, грубо говоря.
То есть весь язык основан на таком message passing между объектами.
И вот это было изначальное понимание того, что такое объектно-ориентированное программирование.
Причем, ну, все ронтаймовое, да?
Потому что никаких классов не было, никакого наследования не было.
Были только объекты и message passing между ними.
Список хендлеров различных месседжей у объекта динамически хранится в ронтайме.
Можно новый добавить в любой момент, можно убрать.
Сами объекты тоже создаются в ронтайме в любой момент.
Ну, и там была IDE, вся тоже сама написана на smalltalk,
поэтому прямо из своей программы можно было слать сообщение своему редактору.
И там какие-то безумные вещи происходят.
Я надеюсь, вас заинтриговал немножко и для общего развития вы почитаете.
Но мы должны ехать дальше, потому что есть более хорошие виды полиморфизма.
Вот это, кажется, православный полиморфизм такой самый.
Вот если вы пообщаетесь с человеком, который занимается теорией типов,
он вам что такое полиморфизм, ответит, что вот это полиморфизм,
а все остальное это ересь и надо сжечь.
Ну, тут какое-то определение есть, что мол, однородно обобщенное по типу значению код.
Ну, имеется в виду, что вы прям явно пишете некоторые параметрические конструкции,
которые работают для любого типа.
Причем гарантированно работают.
Ну, как бы шаблоны в плюсах, они не особо параметрический полиморфизм,
но в принципе да, потому что они unbounded.
Как бы в идеале параметрический полиморфизм должен быть bounded,
и, так я не подключил, нет, и в принципе должен выглядеть как в хаскеле, и все.
Вот как бы это архетип всего параметрического полиморфизма.
Вы пишете код, в нем вы говорите, что у вас есть там значения,
ну, на вход аргументы приходят, да, функции какие-то,
и у них должны быть вот такие типы.
Типы могут быть обобщенными.
Я не уверен, что это там не конкретные типы, а какие-то типы из каких-то семейств.
Семейств там задаваемых разными хитрыми образами.
И оно все очень фиксированное, очень математичное.
Ну, я не уверен, насколько легко почувствовать отличия
между шаблонами как ad hoc штукой и шаблонами как parametric штукой.
Ну, в каком-то смысле шаблоны параметричные.
И вот с концептами они как бы совсем хорошими становятся,
прям параметричные и параметричные.
Так, я теряю мысль.
Вот, Generic и Rust, давайте лучше к ним.
Про плюсы это вся как грязное.
Вот Generic и Rust это прям честный-честный параметрический полиморфизм.
Вот самый, что ни на есть.
И там у вас строгая конструкция.
Вы строго говорите, что вот такие методы должны быть,
и это значит такой type class, что называется.
Некоторое семейство типов.
Дальше говорите, функция принимает на вход тип из семейства.
Может принимать просто, а может принимать как бы динамически.
И вот просто это значит, что у вас будет что-то вроде шаблона,
а динамически значит, что у вас будет что-то вроде ОП
и виртуальных функций.
И в самой функции вы имеете право на этом значение
использовать только тот функционал, который описан в этом семействе.
И ничего больше.
Вот это вот прям самый такой православный,
строгий параметрический полиморфизм.
Ну вот на концептах в плюсах можно сделать что-то похожее
и будет неплохо.
С шаблонами ну так, плюс-минус.
Какой-то вопрос был или нет?
Значит, мне показалось.
А вот в принципе, дженерики в Java и Scala они тоже нормальный полиморфизм,
но в них есть большой недостаток.
А вот в параметрическом полиморфизме есть такое понятие, как мономорфизация.
Полиморфизм это обычно про функции вот в этом контексте.
И полиморфная функция это функция, которая умеет работать с многими видами данных.
И вот мономорфизация это получить из полиморфной функции мономорфную,
которая работает с одним конкретным типом данных.
Вот эту мономорфизацию можно делать по-разному.
Можно делать ее путем копипасты всего кода функции много раз для каждого типа.
Какой язык так делает?
В какой ситуации?
Ну раз ты так и сяк делает.
Плюсы.
Шаблоны в плюсах каждый раз, когда вы подставляете в полиморфную статическую функцию шаблонную
что-то конкретное, она генерит новую специализацию вам.
И вот отдельные, отдельные, отдельные функции.
А Java поступает наоборот.
Она как бы в дженериках при мономорфизации берет и говорит,
что все типы у меня будут одним единственным типом.
Такой void звездочка.
А какие конкретные методы мы хотим вызывать?
Она там как-то хитро запоминает через что-то рантаймовое.
Вот тут не уверен в деталях.
Вот.
И вот Rast он умеет и так, и так.
Вот я сказал DIN есть, не DIN.
Я деталей Rast не знаю, если что, ни строчки на нем в жизни не написал,
только статьи читал.
Но насколько я знаю, поправьте меня, если не прав,
можно писать в дженерик функцию как с мономорфизацией,
как у шаблонов, где будет просто копипаститься код,
так и с мономорфизацией рантаймовой,
где будет одна функция, один код,
но будет рантайм-полиморфизм,
и виртуальные вызовы это дороже стоят по первому.
Ну это похоже будет не дженерик, но да.
Просто инциклы принимают.
Ну внешний вид, кажется, не отличается у них, да?
Отличается.
Отличается, да?
То есть там не является дженерик параллельным.
А, окей, там треугольные скобочки.
Ну окей.
Ладно, наверное, тогда я не очень корректно сказал,
что в Rast и так, и так примерно одинаково.
Ну вы поняли меня, я надеюсь.
Вот, ну и в конце концов есть вот эти вот прекрасные языки.
Haskell, OCaml, вот там вот все хорошо.
Есть еще ML?
А, ну...
OCaml это есть ML, ладно.
В ГО есть дженерики.
Чего?
В ГО есть дженерики.
Откуда в ГО появились дженерики?
Они очень плохие там.
Да.
Это было очень грустно, когда я с ними работал.
Ну давайте тогда не говорите плохом, пойдем дальше.
Еще есть некоторая такая штука под названием subtyping.
Она тоже пересекается со всем предыдущим,
и тоже очень мутное разделение.
Ну...
По факту речь идет о том,
что мы умеем типы как бы наследовать как бы друг от друга.
Один тип является другим,
но не обязательно наследовать.
Ну, любое OP...
Да, вот любое наследование считается,
что у нас у типа есть подтип.
У вас есть какие-то общины,
по которым раз-то многие не читают OP,
потому что там нет наследования?
Ну и дураки они.
Потому что я вот напоминаю,
OP пошло со Smalltalk,
в Smalltalk не было наследования,
и это было OP,
и никого это не смущало.
Отсюда не OP, наследования нет.
Трех китов OP придумали PostFactum.
Когда уже было OP,
и когда его решили популяризировать
там всякие ребята из...
Да?
Тут просто проблема в том,
что самый известный язык,
в котором молятся на OP,
это Java.
Тут проблема в целенаправленной компании
по пропагандированию вот этого взгляда
трех китов, курсов по обучению Java,
где вот этому все расскажут,
тебе там паттерн...
Это тоже, кстати, интересная история.
Уже OP,
как слово, ассоциируется с OP в виде Java.
Ну да, да.
Если мы говорим, что в Расте OP,
в Хаске или OP,
я все сделаю.
Да.
OP уже смысла не имеет.
Поэтому предлагаю читать
историю происхождения всех этих смешных
терминов и языков.
Вот про то, почему Java когда стала популярной
и какими шишами,
бесплатно такими популярными не становятся,
вот про это тоже рекомендую почитать прикольно.
ЦРТП тоже можно называть саптайпингом.
Мы там тоже делаем наследование,
поэтому очевидно, что это саптайпинг.
Просто он немножко странный.
У нас как бы
базовый тип, он зависит от
родительского, ну что-то вот такое
извращенное немножко.
И конец сюрприз.
Все неявные касты, согласно
некоторым источникам, тоже считаются
таким саптайпингом. То есть то,
что вы неявно можете сконвертировать bool
к int, это почему?
Потому что bool является под
типом int.
То есть или 0 или 1, согласно языку C.
В int можно положить и 0 и 1,
значит под тип.
Еще тут кто-то кажется был со
скалой знакомый.
Там же есть вот эта вот прекрасная
возможность объявлять под типы
явно. Которая не ООП,
но что-то такое извращенное.
Когда вот
всяка вариантность всякая начинается с
наследованием, вот там кажется можно
как-то явно сказать, что один тип
является под типом другого.
Во!
Вектор животных будет под типом
вектора собак. Вот это еще один классный
пример, которого здесь нету.
Вектор
животных будет родителем
вектора собак. Вектор собак
является под типом вектора животных.
Но наследований нет,
но подтипы как бы есть.
Ну да, там интересные всякие начинаются.
В GWM что угодно
можно запихнуть, коли он полный по
тюрингу. Чего стесняться-то?
Вот, по-моему, скалы это единственный
язык, где такими укротасами занимаются,
но в целом да.
Наверное, на этом все.
Вот с этими примерами.
Итак, давайте
про C++. Вот у нас есть
vtable полиморфизм,
runtime, ну самый такой
единственный расово верный
runtime полиморфизм.
Мы там
неоднородные коллекции умеем создавать.
Вектор животных.
Круто, круто.
Мы можем сурсы не дистрибьютить своим
пользователям. То есть есть библиотеки,
которые дистрибьютят хедеры
и какую-то библиотеку
скомпилированную, DLL-ку.
Этого достаточно. Все, у вас там
все полиморфные ваши поведения будут работать.
Вы в саму эту DLL-ку можете скармливать
свои классы по интерфейсам
библиотеки, и все будет работать.
Это же вообще магия.
И не вам не нужно свои сурсы отдавать другим
людям. Не другим людям ваши сурсы
свои сурсы вам показывать не
надо.
Экономия кода в бинаре.
Это относительно, но там
камень в огород расто.
Да и не только расто.
Всегда, когда вы делаете статический полиморфизм,
вы раздуваете количество памяти.
Мы там говорили
про iCache и вот это все.
И то, что у нас
культ джавы был,
нам тоже дает преимущество. При использовании вот этого
у нас очень много опыта.
Мы знаем всякие паттерны, мы там умеем
делать хорошо, знаем, как делать плохо
не надо, но все равно делаем.
То есть, ну, витейбл-полиморфизм
в принципе всем хорош, кроме одного
он медленный.
Ну и нифига неудобный.
Потому что, если вы там колбэк какой-нибудь
передаете по интерфейсу,
ну очень неудобно каждый раз, когда вам надо
какое-нибудь продолжение
фьюча навесить, брать и создавать
новый класс. Ну это же дичь.
Не хотим так делать. А вот есть статический
полиморфизм, который на шаблонах.
Он супер быстрый, супер классный.
Там все за inline, force inline
и везде пропишем. Кайф.
Ну, сурсы придется показать
конечно всем, ну, что поделать.
Вот эта вот параметричность
и кастомизация поведения, это кажется про специализацию,
я хотел сказать, но не суть важна.
Кодом меньше можно
написать, да. Когда ВОП обычно пишете,
там начинается чехарда с иерархией
на 100 классов и какие-то факторы,
менеджеры, адаптеры, чтобы
нормально все было.
А с шаблонами можно просто взять и
ну просто написать код, там как-то
компактнее дженерали получается.
Да, типа безопасность, это очень
здорово. Вы там не можете какой-нибудь...
Ладно, у меня нет хорошего
примера, ну там всякие вот
по указателям что-то не то
такое бывает в джайве.
Наверное, нет.
Ну, короче, в джайве за затирание типов
там нужно ставить как-то аннотацию,
что типа ты не будешь
очень
плохо кастить
массив листа винтовка,
массива листа каких-то
других объектов. Ну, что-то там есть,
какие-то приколы, да, даже с
динамик кастами или как они в джаве,
инстансов и вот эти вот вещи,
там с ними какие-то проблемы могут возникнуть
в рантайме, где вы пойдете в обход
системы типов и все поломаете.
Ну, с шаблонами мы как бы все в компелтайме
делаем, поэтому не сломаем.
Ну, и наконец у нас быстро все работает.
Что хорошо.
Мы хотим взять лучше от обоих миров
в каком-то смысле, в каком,
ну, поймем позже,
потому что сейчас время кодить,
а точнее, думаю,
перерыв.
