Продолжаем говорить про динамику. Начнем с вы ворвались в банк. И там есть какие-нибудь,
ну обычно это слитки золота, ну или в общем какие-нибудь драгоценности. У каждой драгоценности
есть свой вес и своя стоимость. Давайте буду писать о тен предметов, чтобы, так сказать,
гендерно-нейтрально было. Значит, этот предмет имеет некий вес W и стоимость.
Вот, а пришли в банк вы с одним единственным рюкзаком в вместимости W.
W большое. Вместимость рюкзака. Ну и ваша задача, значит, утащить сколько-нибудь предметов так,
чтобы они все поместились в ваш рюкзак, ну и суммарная стоимость была как можно больше. То есть
вес явным образом на стоимость не влияет. Вес влияет только на то, что вы можете в рюкзак максимум W
большое набрать. Вот. И при этом условии, что сумма весов, которые вы взяли не больше, чем W большое,
вам нужно набрать максимальную стоимость предметов. Вот. Такая задача. Значит, сразу скажу, что
известно, что в такой постановке она является NP трудной. Для нас это значит, что, значит, там я
еще тоже чуть-чуть дальше, когда мы будем про графы говорить, там тоже целый пласт задач, которые
являются NP трудными, для нас это означает, что пока не мы, никто другой не умеет решать эти задачи за
полиномиальное время от размеров хода. Вот. И соответственно лучшее, на что можно надеяться,
это что-то там сверхполиномиальное. Значит, дальше мы увидим, что там как бы что-то похоже на полином,
но полином там будет зависеть от W явным образом. То есть неформально мы будем для всех возможных
частичных замощений этого W большого хранить, какой максимальную стоимость мы можем получить с такой
заполненностью рюкзака. Но если ваш алгоритм работает за время пропорциональное W, именно W,
то это уже не полиномиальный алгоритм может быть, потому что, ну представьте, у вас там W это что-нибудь
типа два в степени 64, и тогда ваш алгоритм работает за два в степени 64. Чтобы написать число два в
степени 64, вам нужно всего 65 бит потратить. Получается, что время работы оно экспоненциальное от размера
входа. Если вход там 65 бит, а время работает два в степени 64, то это экспоненциальная зависимость.
Вот. И так будет у нас, что мы будем зависеть там линейно по W, но само W описывается всего лишь
логарифмическим числом бит, чтобы его задать вашей программе, нужен логарифм бит. Итого у нас
будет как бы экспонент от логарифма, то есть полином. Вот. Поэтому как бы, вообще говоря,
это экспоненциальный алгоритм, но если W маленькое, то это что-то адекватное. Если W порядка тысячи,
сотен тысяч и так далее, миллионов возможно, то это какой-то адекватный алгоритм. А в общем случае,
если W как-то быстро растет, то время работы это уже будет экспоненциальное, ну и в общем какое-то
непозволительное. Ну так вот. Простое решение. Ну тут давайте опять вот эту, скажу, мантру. Вот давайте
мы начали набирать предметы. Сколько-то взяли, сколько-то еще не взяли, и какая-то вместимость у нас,
соответственно, уже заполнена. Вопрос, что нам нужно знать, чтобы двигаться дальше?
Ну, наверное, надо знать, какая емкость рюкзака заполнена, какую мы набрали стоимость, и в каком-то
смысле, какие предметы мы уже рассмотрели, какие предметы мы уже взяли или не взяли, и больше их
пытаться брать не будем. Но давайте тогда просто идти по всем предметам в порядке увеличения
номеров. Первый, второй, третий и так далее, н-ный. И на каждом шаге будем либо брать, либо не брать
предмет. Тогда ведем такую динамику. Значит, dp it какой-нибудь, ну пусть будет x. Это максимальная
суммарная стоимость предметов. Если мы рассматриваем только первый i из них, значит, если рассматриваем
только первый i предметов, ну а их суммарный вес это в точности x. А я напишу так, суммарный набранный
вес в точности x. То есть я знаю, какие предметы я уже рассмотрел, первый i. Знаю, что я набрал
суммарный вес точности x, и в значении dp у меня будет лежать максимально возможная стоимость,
если вот эти все условия выполнены, то какая будет максимальная стоимость. Ну дальше все довольно
прозрачно. Значит, база, давайте мы будем идти и заполнять нашу динамику по слоям, то есть порядка
увеличения i. Тогда база, это когда i равно нулю. Когда я рассматриваю 0 первых предметов, соответственно,
я ничего брать не могу. Единственный способ это взять пустое множество предметов. Тогда у меня стоимость,
тогда у меня вес 0 и стоимость тоже 0. Я могу из первых нуля предметов взять ничего, тогда стоимость
будет нулевая и вес будет тоже нулевой. А если у меня здесь что-то стоит больше нуля, тогда я такого
не могу сделать, я не могу набрать с помощью нуля предметов какой-то положительный вес. И давайте
я сюда положу число, которое является нейтральным элементом по функции максимум. То есть, например,
минус бесконечность. Я могу сказать, что нет ни одного способа выбрать из первых нуля предметов
несколько с положительным весом, поэтому их максимальная суммарная стоимость и минус бесконечность.
Такого просто нет. Значит, здесь что-то как раз фиктивное, то, чего набрать нельзя. Ну и дальше
переход. Значит, чему равно dp и tx? Я хочу выразить dp и tx через значение dp на предыдущем уровне,
то есть через dp и минус первое для каких-то там разных возможных х. Значит, вопрос. Вот смотрите,
у меня есть первые и предметов. Я хочу набрать вес х. Давайте посмотрим на и ты предмет и спросим
себя, мы его берем в наше множество или нет? Берем ли мы и ты предмет в наше множество, чтобы набрать
сумму х? Соответственно, два варианта. Либо берем, либо не берем. Если не берем, то понятно, что здесь
можно просто написать dp и минус первое х. Потому что если я знаю, что и ты предмет брать невыгодно,
то я просто про него как бы забываю, говорю, что мы его не используем. И задача сводится к тому,
чтобы выбрать из первых и минус этого предмета тот же самый вес х. То есть этот случай достигается,
если и ты предмет не берем. Тогда, собственно, эти просто значения dp будут равны. Второй случай,
когда мы его берем. Если у него был какой-то вес w и, то мне нужно из оставшихся и минус одного
набрать вес уже х-w и. Потому что я последний взял, я знаю его вес. Если суммарный вес был х,
то из всех предыдущих надо брать вес х-w и. Поэтому здесь я с помощью первых и минус одного предмета
пытаюсь набрать вес х-w и, но не забывая добавить сюда плюс ц и. Это случай, если и ты предмет
берем. Более-менее все. То есть я либо предмет не беру, тогда просто dp с предыдущего слоя с
тем же самым весом. Либо беру, но тогда мне нужно из первых и минус первого предмета и минус
одного предмета выбрать уже вот такой вот вес суммарный на w и поменьше. Но при этом к этой dp
надо добавить стоимость последнего взятого предмета, стоимости этого предмета. Естественно,
я не пишу всяких условий, что вот это должно быть больше или равно нуля. То есть если х-w и меньше
чем ноль, то я в принципе не могу рассмотреть такой вариант. То есть я не могу набрать вес меньше
чем w и, используя предмет веса w и. Поэтому когда-то это не существует. Этот вариант вообще не
рассматривается. Ну и если здесь равно минус бесконечность, если вот это вот это минус бесконечность,
то я считаю, что минус бесконечность плюс любая константа тоже минус бесконечность. Ну и в итоге
у меня форма перехода будет примерно такая. Вот я здесь её попробую вместить.
Вот собственно всё. Ну и соответственно наша динамика вот так работает. Мы сначала подсчитываем
все, то есть по всем х подсчитываем dp0х. То есть вот у меня есть нулевой уровень, он так заполнен.
И дальше каждый следующий, каждый и-тый уровень я могу посчитать через и минус 1. Вот я вижу,
что у меня dp и, то я завис только от dp и минус 1. Всё. Получается асимптотика. По времени это будет
видимо n на w, потому что у меня столько состояний динамики. Первый аргумент у меня принимает
одно из n значений, ну из n плюс 1 формально, ну неважно. Здесь примерно n значений, здесь
примерно w значений. И причем каждая насчитывается через предыдущие золотые еницы. Я просто беру
два значения и выбираю из них максимум. Поэтому вообще время работы n на w, вот значит это время.
Ну и с памятью здесь можно поступить как обычно. Можно заметить, что у меня и-тый слой зависит
только от и минус 1, поэтому память можно не всю динамику хранить, а только последние два слоя.
И тогда памяти будет просто от w. Если хранить только предыдущий слой dp и минус 1 и следующий
dp и t. Тогда в любое время нам достаточно от w и человек памяти. Постепенно что-то очищается,
что-то можно заполнять. Ну или мы можем просто хранить два массива размера w. Сначала считать,
что это предыдущий, а это следующий. И следующий заполнять через предыдущий. А потом этот мы
можем назначить предыдущим и следующий вычислять через него. То есть у меня можно всего двумя массивами
обойтись и их между собой друг друга чередовать. Сначала это предыдущий, это следующий. Я второй
высчитываю через первый. Потом наоборот про первый забываю и первый высчитываю через второй. Тогда
мне даже не нужно выделять новую память. У меня просто на двух массивах длины w они будут так друг
через друга пересчитываться. Окей? Вопрос, где лежит ответ? Еще раз? Неправда. Да, где-то в последней
строке. Ответ это максимум по всем возможным х от 0 до w dp nхt. Потому что мы не знаем,
сколько на самом деле выгодно всего запихнуть в рюкзак. Возможно не в точности w, а чуть поменьше.
Ну и тогда мне нужно просто перебрать, насколько заполнен рюкзак на последнем слое. Ну и выбрать из
них максимальное значение dp. Ну понятно, что здесь n, потому что это означает, что я могу брать любые
предметы, могу не брать. Когда здесь n, значит я могу любой брать, могу любой не брать. Рассматривать
все предыдущие dp-шки бессмысленно, потому что там какие-то предметы заведомо не включены. А здесь
можно любой брать или не брать. Так, хорошо. Вот такое решение у нас есть. Давайте второе решение,
кратко освещу тоже. Оно меняет местами стоимость и вес. Вот тут я когда проговаривал, что нам нужно
знать, чтобы динамику нашу насчитывать, я говорил, что мне нужно знать, сколько предметов мы
рассмотрели, какой текущий вес, какая текущая стоимость. И я почему-то в аргумент динамики
засунул именно вес. А мог вообще, говоря, поступить наоборот, мог засунуть стоимость. Поэтому я могу
написать другое решение. Я из лености буду писать, короче, везде dp. Давайте я веду dp и t от ct.
Давайте yt. Значит, это минимальный суммарный вес выбранных предметов. Если опять-таки можно
рассматривать только предметы с первого поитой, но при этом их стоимость это y.
Если можно выбирать только первый и предметов, а суммарная набранная стоимость это y.
Вот. Ну, естественно, это будет работать хоть сколько-то адекватно, если у вас стоимости все
маленькие. То есть представьте, что у вас веса у предметов большие, а стоимости маленькие. Ну,
там нолики, единички и двойки, например. Вдруг у вас такая задача, что у вас предметы тяжелые,
но в среднем мало полезные. Тогда вам как бы, наоборот, хочется, чтобы аргументом динамики было
что-то поменьше. Ну, вот давайте стоимость тогда возьмем в качестве аргумента. А значение это будет
минимальный суммарный набранный вес. То есть мы поменяли как бы местами вот здесь вот x и y,
которое раньше было значением динамики. Если раньше при фиксированном x была максимальная
стоимость, то теперь, наоборот, при фиксированной стоимости хотим минимальный вес сделать. Вот.
Ну и дальше, собственно, все аналогично. Давайте я просто переход здесь напишу. Значит,
чему равно dp i t y t? Тут опять, либо я i-ты предметов вообще не беру, тогда у меня стоимость
и вес сохраняется. Поэтому мне нужно просто сюда положить dp i-ты. Это случай, когда i предмет
не взят в сумму. Ну и второй случай, когда он взят, тогда у меня с помощью оставшихся и минус одного
предмета нужно брать стоимость y-ci, но зато вес растет на w i. Правильно? Ну, собственно,
очень-очень похожая формула. По сути, я поменял местами просто веса и стоимости. Вот. И тогда
получится решение за... Я напишу n умножить на c большое, где c большое – это стоимость всех предметов.
Ну суммарная стоимость, имею в виду сумма всех c маленьких. Вот. И это более смыслно, чем вот это,
в случае, когда c меньше mw. Потому что там время работы n на c, а здесь n на w. Понятно,
что эффективнее из них тот алгоритм, где меньше вот эта вот константа, c или w. Значит, выгоднее,
ну в плане времени работы, если c меньше, чем w. Окей? Так. Чудно. Ну это мы обсудили. Значит,
повторюсь, что эти алгоритмы на самом деле не полиномиальные от размера входа. Потому что вот
это вот число w, оно может быть настолько большим, что для его задания там достаточно сколько-то бит,
а само оно экспоненциально от, собственно, этого количества бит. Если у вас там 65 бит,
то значение может быть 2,64. И даже больше. Вот. Ну да, собственно, это я уже проговорил. Ладно,
не надо повторяться. Так. Вопрос есть? Хорошо.
Значит, еще одно замечание здесь скажу. Здесь опять-таки не работают всякие жадные алгоритмы.
Давайте напишу так. Неоптимальность. Будьте здоровы. Жадных алгоритмов.
Значит, ну поскольку задача NP трудная, то мы пока не можем надеяться на то, что здесь есть
полиномиальный алгоритм. И в частности, любой полиномиальный алгоритм, который я бы мог
предъявить, имеет некий контрпример, некий контртест. Но давайте рассмотрим такой алгоритм,
который как бы в каком-то смысле действует логично. Значит, давайте мы отсортируем все предметы в
порядке удельной полезности. Сортируем предметы по, ну видимо, c делить на w. То есть как бы
логично, что выгоднее тот, у кого больше плотность, ну типа стоимость деленной на вес. Тогда их как бы
наверное выгоднее всего убрать. Ну будем просто идти по этому списку предметов и брать первые
попавшиеся вот, чтобы они не переполнялись за w. Вроде логично такое предположение, что мы
предметы берем жадным образом в порядке убывания удельной полезности. Выбираем предметы.
Предметы в порядке убывания. Вот, я уже что-то на самом деле не всегда выгодно.
Давайте посмотрим почему. Ну, мне приходит в голову какой-то такой пример. Сейчас я что-нибудь
нарисую. Значит пусть будет чуть-чуть выгоднее. Нет, плохо, плохо, плохо. А нет, нормально.
Вот так. Значит, возможно, не самый удобный пример, но вот мне такой сегодня приснился. Значит,
смотрите, я их расположил уже в порядке убывания. Так, глупость, да, сказал. Момент. Да, да, да, я это
имел в виду, спасибо. Да, вот так. Теперь они в порядке убывания удельной полезности. То есть здесь
плотность чуть больше 1, здесь плотность равна 1. И вот наш наивный алгоритм что делает? Он берет вот
это и сразу заканчивается, потому что к нему больше ничего добавить нельзя и получит стоимость
1100. А можно сделать похитрее, можно на этот предмет забить, взять вот эти два, рюкзак не
переполнится, он полностью заполнится, но не переполнится, а вес будет больше, будет 1100. Профит.
То есть этот алгоритм как бы неэффективный. Ну и любые такие жадники, что давайте ассортируем предметы
по какому-нибудь компаратору и дальше будем просто брать в порядке убывания полезности. Вот это и вот.
Все, которые не переполняют наш рюкзак. Все такие алгоритмы, по крайней мере, на текущий уровень
знания человечества не всегда предоставляют правильный ответ, потому что задача НП трудная. И если бы
был какой-то такой алгоритм упорядочивания, который соответственно работает за N log N и мы потом
бы просто жадно их брали, тогда получается, что мы задачу рюкзака решили бы за N log N за полинальное
время, что пока что противоречит тому, что мы знаем о сложности вычислительных задач.
Вот. Соответственно, можете попробовать поэкспериментировать дома, если вам внезапно
нечего делать, придумать какие-нибудь компараторы, как можно было бы упорядочить предметы и придумать
пример, почему это невыгодно. Или внезапно, наоборот, у вас получится доказать, что вы правильно
посортировали, когда вы решите задачу за миллион долларов и будете очень крутым. Вот. Всем советую.
Так, хорошо. Едем дальше. Следующий блок – это динамика на матрицах. Динамическое программирование.
Ну, на матрицах как-то так уже называют обычно, я так же сделаю. Значит, здесь речь пойдет о том,
что мы будем пытаться формулу пересчета следующего значения динамики через предыдущие выразить в
терминах умножения на матрицу. Пример, самая простая задача. Есть у нас последователь, чисел
фибоначи. Задаваем вот таким вот правилом. Мы хотим найти fn для какого-нибудь большого n. Ну да,
хотим найти fn для заданного n. Пока давайте в таком виде оставлю. Без подробностей. Понятно,
можно за линию просто пройтись, поскладывать два последних числа, получать три следующие и так
далее. Но это не интересно. Это мы все умеем. Можно сделать по-другому. Можно заметить выполнение
следующего равенства. Все же умеют матрицу умножать, я надеюсь. Но тогда вы согласны с таким вот
равенством. А если я нигде не накосячил, то у меня fn это произведение вот такой строки на такой
столбец. Это верно, да, сумма двух предыдущих. А fn-1, произведение такой строки на такой столбец,
это просто fn-1. Пока все верно. Значит, если я буду продолжать эту логику, то я могу написать вот
здесь вот квадрат моей матрицы на столбец, соответственно, на два шага назад. fn-2, fn-3. Ну и так
далее. Я могу дойти последним столбцом до моей базы f0, f1. Здесь будет что-то вот такое в степени
n-1, f1, f0. Ну вот. Поэтому, чтобы найти n-ый член нашей последовательности, мне нужно всего лишь как-нибудь
быстренько возвести вот эту матрицу в степень и умножить на столбец из двух единиц. Давайте я
сразу здесь сотру, потому что не из двух единиц, а из единиц и нуля. Вот так. То есть достаточно
научиться каким-то образом быстро возводить матрицу в степень. Ну давайте этим займемся.
Быстрое или бинарное возведение в степень. Значит, начнем с чисел, но и матрицы тоже научимся
так быстро. Идея очень простая. Смотрите, пусть нам надо найти a в степени n. Пока что пусть
a это число. Потом подставим матрицу, логика будет та же самая. Значит, два варианта. Если n четное,
то мы можем найти a в степени n пополам и возвести его в квадрат. Если же n не четное, то я могу
просто одну h отщепить и домножить результат на a в степени n-1. Так, ну давайте еще я для
приличия здесь напишу условия выхода из-за рекурсии. Это единица, если n равно нулю.
Ну я считаю, конечно, что a изначально не нулевое, потому что начать задача неинтересная. Тогда
в нулевой это единица. Вот, собственно, тут написано рекурсивный алгоритм. Пусть у
меня есть какая-то функция. Я ее обычно называю binary power. Возможно, логично было называть как
binary exp, но неважно. Она принимает два числа a и n, хочет возвести a в степень n, проверяет
эти условия. Если n 0, то можно сразу вернуть 1. Если n четное, то он его делит пополам,
рекурсивно запускается binary power от a n пополам и возводит результат в квадрат. Если n не четное,
то вычитать единицу рекурсивно высчитает вот это и он нажает ответ на a. Ну давайте напишу этот код.
Если n четное, то я рекурсивно посчитаю x равное a в степени n пополам и верну x в квадрате.
Значит, иначе посчитаю a в степени n минус 1, ну и верну a на x. Вот такой нехитрый алгоритм.
Так, согласны с ним? Чудно. За сколько он работает? Почему за алгоритм? Еще раз? Ну вот иногда же на
единицу всего лишь. Да, действительно можно заметить, что если мы в какой-то момент уменьшили n на
единицу, то в следующий момент мы обязательно поделим пополам. Потому что если здесь n было нечетным,
то при уменьшении на единицу он станет четным, и на следующем шаге оно уже будет делиться пополам.
Поэтому количество раз, когда мы вычитаем единицу, короче, таких два раза в квадрат быть не может.
Потому что если мы из нечетного вышли, 1 стало четным, и потом оно уже делится пополам.
Поэтому можно сказать следующее. Из каждых двух последовательных рекурсивных запусков нашей
функции, по крайней мере, в одном n делится пополам. Ну а деление пополам может быть максимальным алгоритмом.
Если у меня деление пополам возникает, по крайней мере, в каждом втором случае, на те времена
работает максимум удвоенный двуичный алгоритм. Так, асимптотика. Получается алгоритмическая.
Да, это хороший вопрос. Вот на самом деле большая проблема с тем, как работает умножение.
Тут есть два ответа. Первый такой наиболее, хотя сказать наиболее распространен,
ну давайте так. В наших задачах, в большинстве, во всяком случае в контестах,
надо будет находить ответ по модулю, скажем, p. То есть нам не нужно будет находить само это значение x на x.
Достаточно будет найти его остаток определения на p. И тогда уже, если p достаточно маленькое число,
тогда нам жить будет сильно легче, потому что после каждого умножения можно брать ответ по модулю p.
Вот здесь взяли процент p, вот здесь взяли процент p, ну и так далее. Тогда ответ, как бы, текущая величина
никогда не будет больше, чем p. Если я умножаю там два таких числа, два вычета умножаю,
и потом беру опять по модулю p. У меня все это всегда будет в каком-то нормальном типе данных.
Это, в общем-то, даже в теории довольно неплохой подход. Потому что, если, скажем, вы найдете вот это
значение по нескольким разным простым модулям, там avn и по модулю 2, 3, 5 и так далее, по нескольким разным
простым модулям, то дальше вы можете просто покидать какое-то время об остатках, восстановить явным образом это число.
Но если вам уж надо само это число восстановить, то в принципе из значений по модулям вы можете восстановить
само это значение. Другой вопрос, за сколько это работает? Ну, короче, за сколько это точно можно?
Вторая идея, да, здесь, если нам нужен ответ в точности, то здесь нужно узнавать, за сколько работает произведение чисел.
Ну, это там какой-то аккуратный анализ. Давайте я скажу следующее, что если я возвожу в n-ую степень,
то у меня длина в худшем случае умножается максимум на n. Потому что если a это 10 вкатый, то 10 вкатый в степени n
и это 10 в степени kn. Длина как раз в n раз увеличилась. Значит, тогда в результате у меня вот здесь вот длины будут
полинамиальными по n и время работы будет что-то типа n квадрат на log n, насколько я понимаю. Но это в случае,
если мне нужно находить точное значение. На самом деле мы такого делать не будем, то есть скажем так, можно всегда провести
анализ того, что если мы хотим находить значение точно, а не по какому-то модулю, можно провести аккуратный анализ,
за сколько работают все эти умножения и так далее. Но нам всегда будет достаточно это делать только по какому-то модулю или можем
просто считать, что все вот эти вот операции арифметические работают за единицу. Мы будем жить в такой модели, нас это
в общем-то нигде стеснять не будет. Теперь к матрицам вернемся. Как умножать матрицы? Ну, собственно, точно так же, если мы хотим
найти а в степени n, где а это матрица размера k на k. Матрица k на k. Меняется две вещи всего. Во-первых, надо научиться
понимать, что такое а в нулевой. Что такое а в нулевой? Единственная матрица. Да, здесь будет просто единичная матрица размера
k на k. И здесь надо научиться понимать, за сколько работают произведения двух матриц аж мира k на k. За сколько? Четырех? Не, ну если на k на k. Нет.
Ка-куб, да. Потому что у вас для каждой строки, для каждого столбца вы n произведений считаете. Вот я сказал k на k, я более общую
задачу. Ну, давайте это здесь отражу. А в нулевой это матрица, единичная матрица порядка k, то есть на диагонали единички, вне диагонали нули.
А перемножаем мы две матрицы. Перемножаем за отка в кубе. Ну, если просто написать форму из определения, там сумма по и сумма по ж и внутри,
что сказал? В смысле, там c и t аж и t это сумма по k попарных произведений. Итого у меня три переменные, каждый из которых пробегает n значение,
получается кубичка 7 точек. Вот. А канва точно такая же. Если мы закончились в нуле, то надо вернуть единичную. Если четно, делим пополам,
если нечетно, единичку отщепляем, рекурсивно считаем а в степени минус 1, умножаем на а. В итоге будет кавкубиналуген.
Но опять-таки в предположении, что все риффметические операции работают за вот единицы. Как, например, в случае, если бы нас просили найти ответ по модулю p какому-нибудь.
Вот. Ну и тогда все мы смогли научиться находить n число фибоначи, даже не только эда, но и два последних, n и n минус первое, за время q под размер этой матрицы на логарифм от показателя степени.
То есть это будет, ну, примерно log n как раз. Поскольку матрица здесь константного размера на 2, соответственно здесь будет множество 8, как бы неявный 8, это константа можно не писать, получается логарифм просто от показателя степени.
Понятно? Хорошо.
Так, ну и давайте тогда быстро здесь же в догонку еще одну рекурренту напишем и также быстро ее решим.
Значит, пусть у меня задна последность как-нибудь так. Ну а 0, какое-нибудь конкретное значение, давайте я напишу здесь x, а 1 это y, а для всех больших ну что-нибудь такое напишу, ну вот пусть, пусть, например, что-то такое.
Я хочу просто показать, что все похожие рекурренты можно считать примерно таким же образом.
Ну здесь понятно, опять-таки у меня каждый член выражает через два предыдущих, но проблема здесь вот с этой единицей. Откуда нам в матричном умножении взять плюс один?
Прибавить кого? Да, да, да. Мы так-так и сделаем.
Я сделаю следующее. Просто напишу единичку в конце. Пересчитаем столбец, допишу единицу, выражаю этот столбец через предыдущий того же вида.
Ну здесь уже все будет смотреться нормально. Здесь будет лямбда мю единица, здесь будет единица 0,0, здесь будет 0,0,1. Профит.
Если я сделаю такое же преобразование минус один раз, то у меня вот этот столбец выразить через исходный столбец, а 1, а 0, sorry, наоборот, видимо, ух, а 1, а 0, единица.
Получается, что мы смогли выразить n-ый член через первое путем умножения на матрицу какого-то размера.
Ну и, в общем, если здесь формула какого-то достаточно приятного вида, то можно так всегда расширить этот столбец вот этих хранимых величин, чтобы на следующем уровне можно было посчитать путем умножения на матрицу просто слева.
Перев.
Так, ну что, давайте дальше продолжать. Следующую задачу, которую мы хотим рассмотреть, формулирую следующим образом.
Представьте себе, что у вас есть граф, граф задней какой-то матрице смежности, ну и давайте считать, что в нем, например, кратных ребер нет.
То есть у вас есть там какие-то точки, есть какие-то стрелочки между ними, давайте считаем, что граф ориентированный, то есть у меня есть некие ребра между какими-то парами вершин.
Вот.
И мы хотим посчитать, сколько есть путей из и в жи для некоторой конкретной пары городов, для некоторых конкретных пар точек, найти количество путей длины какой-нибудь.
Дан граф, надо найти количество путей длины к из и в жи.
Ну, путь длины к, это вы начали в и, вам нужно пройти ровно к ребер и закончится в жи.
Давайте здесь попишу, что длины ровно к, длина ровно к, ну вот такая задача.
Вы турист, вы хотите гулять ко дней, начать, не знаю, в гостинице, закончить в аэропорту, чтобы улететь отсюда.
Вам надо узнать, сколько у вас есть потенциальных маршрутов.
Причем нет ограничений на то, что локации, которые вы посчитаете, обязательно различны, вы вполне можете ходить в одно и то же место несколько раз.
Сначала простая динамика, пусть у нас фиксирована точка i, пусть dp в этой, ну пусть будет n, это количество путей из i в длины ровно n.
То есть, если я прошел какое-то ограниченное количество путей, sorry, ребер, например n ребер прошел,
мне нужно знать, где мы закончились и, соответственно, сколько способов было там закончиться.
Сколько способов закончиться в конкретном городе, пройдя конкретное число ребер.
Ну и здесь есть очень простая форма, давайте только их местами поменяю, не знаю зачем, но мне хочется.
Да, это я не сказал, но граф не взвешен и все ребра одинаковые, имеют вес 1.
Значит, формула пересчета, ну очень простая.
Если я хочу с помощью n плюс одного ребра закончиться в городе v,
то давайте рассмотрим последнее ребро, вот есть v, вот есть все входящие в него ребра.
Как я могу закончить путь длины n плюс 1 в v?
Это значит, что мне нужно построить путь длины n, заканчиваться в одной из этих вершинок и потом пройти это ребро.
Поэтому здесь можно просто написать сумму по всем ребрам u, v нашего графа,
то есть по всем входящим стрелочкам в нашу вершину.
Надо просто сложить dp, n, ut.
Мне нужно сначала добраться до вершинки u за n шагов, потом еще с помощью одного ребра попасть в v.
Значит, понятна формула?
Вот, ну и здесь видим, на самом деле, обычно самые популярные задачи на вот эту вот матричную оптимизацию,
они тогда, когда у вас, ну когда вы считаете какое-нибудь количество способов,
то есть тогда, когда у вас формула пересчета, это просто какая-нибудь сумма,
сумма произведений, например, ну или здесь в этом случае просто сумма.
Тогда мы можем на самом деле выразить каждый следующий слой через предыдущий опять-таки до умножения на матрицу.
Я могу написать вот такой большой столбец,
где первый аргумент это n минус 1, а второй аргумент все возможные вершины.
Ну давайте я, так, давайте я занумирую все вершины числами от 0 до v минус 1, видимо.
Нет, давайте от 1 до v, или не писать v минус 1.
Значит, вот есть v большое, v большое – это количество вершин в графе.
Вот есть такой столбец, есть аналогичный столбец предыдущего слоя,
то есть dpn первая, и так далее, dpn vt.
Вопрос, на что нужно домножить предыдущий столбец, чтобы получить следующий?
Что будет являться нашей матрицей?
Да, на самом деле просто матрица смежности.
То есть у меня в i житом элементе, так давайте i ж у меня уже занято,
давайте в x там y там элементе,
будет располагаться единица, если есть ребро из x в y.
Да, вот это вот давайте назову mxt yt ровно единица,
если есть ребро из x в y, ну и ноль иначе.
Это называется матрица смежности.
Почему это верно?
Давайте просто по определению проверим.
Перемножим матрицу на столбец, проверим, что получится.
Заберем x-ую строчку здесь, dp n plus 1 xt.
Чтобы его получить, мне нужно умножить x-ую строчку отсюда на первый столбец здесь.
Что такое произвление x-ой строчки на вот это?
Ну давайте напишу формулу.
Это сумма по всем y, mxy на dp n y.
Что-то не так, да?
Сейчас, видимо, наоборот сделать.
Это x из x в y, а мне нужно как бы обратить.
Ну понятно, потому что здесь в каком-то смысле у меня обратный граф рассматривается,
поэтому здесь я давайте местами поменяю стрелку.
Ну это то же самое, что матрица смежности обратного графа.
Я инвертировал направление всех ребер, изменив xy на yx.
Вот, тогда такая сумма это в точности dp n plus 1 x.
Потому что я суммирую по всем как бы предыдущим решинам на пути.
Здесь либо 1, либо 0.
1 если ребро есть, 0 если ребра нет.
И умножается на dp, сколько способов есть попасть сюда за n шагов.
Получается, что здесь как раз каждая слагаемая в этой сумме,
это либо 0, если нет ребра из y в x, либо в точности это dp, если такое ребро есть.
Получается, в точности вот эта штука равна в точности вот этой вот.
Согласны?
Вот, давайте напишем, что это dp n plus 1 x.
Ну все.
Получили выражение n plus первого славца через n-ый,
путем домножения на матрицу смежности.
И значит, если нам внезапно нужно...
Если нам нужно найти какое-то там количество путей из y в z длины ровно k,
то мне нужно просто эту матрицу зазвести в k ту степень,
получится выражение через то, что нужно.
Опять-таки, получили стандартные выражения нового слоя через предыдущий,
путем домножения на матрицу.
Нужно бинарного зазвести в нужную степень и домножить на базовый столбец,
где это, скажем, n равно 0.
Вот, может действовать так.
Давайте я немножко переформулирую.
Будет несколько более удобно.
Давайте я это назову все-таки m reverse,
потому что это была матрица обратного графа.
Давайте я веду обычную нормальную матрицу смежности.
И я утверждаю, что можно вообще обойтись без всякой динамики,
без dp, а просто возведить вот эту матрицу в степень,
и ее элементы будут сущностью показывать то, что мне нужно.
Я утверждаю, что m в степени k в позиции x, y
это то самое количество путей длины ровно k из x, y.
Можно даже динамику всю не считать, а просто возводить матрицу в степень,
и в ней будут не только лежать все пути из i до всех остальных,
а вообще все попарные количество путей из x, y для любого x и y.
Почему это верно?
Давайте доказывать по индукции.
Индукция по k.
Ну, база, например, k равно нулю.
Тогда m в нулевой это единичная матрица.
И понятно, что это отражается в точности число путей длины 0
для каждой пары вершин.
Число путей длины 0 это единица, если x равно y, то есть на диагонали единицы.
А если x не равно y, то путей длины 0 между ними нет,
поэтому в ней диагонали все нули.
Поэтому с базой все окей.
Начну переход.
Пусть m вкатый отражает количество путей длины k.
Отражает количество путей длины k.
Ну, что такое m в степени k плюс 1?
Давайте рассмотрим какой-то конкретный элемент нашей матрицы x и y.
Скажем, что m в степени k плюс 1 это m в степени k умножить на m.
Отказывается работать со мной.
Ну и дальше по формуле произвления матриц я напишу, что и x, y элемент здесь.
Эта сумма по всем, например, z.
Элемент x, z первой матрицы умножить на элемент z, y второй матрицы.
Просто определение произвения матрицы.
То есть я перебираю промежуточную столбец в первой матрице x, z в этой матрице
и потом z, y во второй матрице перемножаю и по парам складываю.
А это в точности, если я знаю, что вот это число путей длины k из x в z.
То есть я сначала пытаюсь добраться до z с помощью k-ребер
и потом с помощью одного ребра пытаюсь добраться из z в y.
Но это в точности число путей длины k плюс 1 x в y.
Потому что любой путь из x в y длины k плюс 1 устроен ровно так.
Мы сначала фиксируем какую-то предпоследнюю вершину z такую, что есть ребро из z в y.
То есть вот здесь вот это множество появляется, 1 или 0.
А до этого я должен был из x попасть в z ровно за k шагов.
И по предположению индукции вот эта штука отражает ровно это самое количество.
m в степени k в точке x, z это как раз таки количество путей длины ровно k из x в z.
Поэтому эта сумма в точности и есть число путей из x в y длины ровно k плюс 1, что и требовалось.
Вроде победа. Вроде победа мы доказали наше утверждение.
А значит теперь вот эту задачу мы могли бы решать вот так.
Мы можем просто взять матрицу смежности нашего графа,
возвести ее в катую степень и вывести элемент на предширение 1040 ежитого столбца.
То есть вот это вот количество это просто m в степени k в точке ежи. Победа.
А возводить матрицу степень мы уже умеем, мы знаем, за сколько это делается, мы умеем это делать.
Нам для этого нужно времени куб от размера матрицы, куб от порядка матрицы на логарифм показателя степени.
То есть время работы будет что-то в стиле v куб умножить на лог k.
v куб от произведения матрицы самой на себя, логарифм от собственного возведения в степень бинарного.
Вот. Нормально?
Логарифм от бинарного возведения, вам нужно m возвести в катую степень,
у вас там примерно логарифм итерации, на каждой итерации вы перемножаете матрицу,
ну там две матрицы размера v от работы dv куб.
Да. Нет? Все нормально?
Чудно.
Тогда следующая задача.
То же самое, только найти количество путей длины не больше чем k.
Мы из x в y длины не больше чем k.
Не ровно k, а не больше, чем k.
Если у вас какие-нибудь идеи, как это можно нормально было бы решать?
По всеми же по всем. На самом деле мы так и будем делать, просто будем это делать довольно хитро,
но мы же не можем все матрицы посчитать, их будет довольно много.
Но мы будем на самом деле ровно этим заниматься.
И мы сможем себя бинарно, собственно, считать все степени матрицы, сумму всех степеней матрицы.
Может расширить два раза.
Шину матрицы и зачем?
Чтобы хранить большее состояние, хранить и предыдущее состояние, которое меньше равно k и ровно k.
Сейчас подумаю.
Боюсь, что тогда вы два раза что-нибудь можете посчитать, потому что...
Сейчас, я понял мысль.
Боюсь, что вы как раз что-то можете два раза посчитать, потому что когда вы перемножаете,
вы берете путь длины меньше k, умножаете на количество путей длины меньше чем k, вы получаете два раза посчитать на одно и то же,
потому что можно путь разбить там. Путь длины меньше чем k можно представить как сумму двух путей меньше чем k половым,
многими способами. Поэтому скорее всего там что-то посчитается несколько раз. Я думаю так.
А сумму степеней матрицы можно попорно сумму тех кишек?
Нельзя, потому что может быть необратимая.
На самом деле у нас любая матрица может быть матрица графа, поэтому не обязательно совсем.
Ну давайте посмотрим. Смотрите. Действительно здесь мы знаем, что m в степени k
это количество путей ровно k, количество путей длины ровно k.
Поэтому нам как бы хочется посчитать сумму степеней m в нулевой, m в первой и так далее, m в степени k
и найти значение этой матрицы в точке x, y. Нужно найти x, y элемент этой матрицы.
Это уже верно, потому что мы знаем, что каждая конкретная матрица это количество путей какой-то конкретной длины.
Когда мы все сложим, мы получим все возможные пути всех длин.
Действительно можно было бы сказать, что это геометрическая прогрессия.
И сделать вывод о том, что ее сумма это что-то типа... Ой, никогда не умел.
Сделаю вот так.
Да? Ну, казалось бы, а почему она обратимая?
Фиг знает, может и нет.
Потому что при умножении на вот эту сумму дает, собственно, вот это.
Нет, ну подождите. Все-таки обратимая к вот этой матрице такая, что g на x для любого x...
Нет, ладно, глупо сказал.
Ну да, нет, еще раз, g это обратная к −e, если g на −e это единичная. Почему она существует?
На самом деле так нельзя делать, потому что в общем случае она необратимая.
Поэтому мы так ее и не будем.
Но мы научимся обобщать наш алгоритм бинародного задания в степень, чтобы он насчитывал не только степень, но и как бы сумму всех степеней.
Сейчас мы это сделаем.
Смотрите, раньше у меня был алгоритм binary power, который брал матрицу, брал степень и находил a в степени n.
Теперь я хочу этот алгоритм немножко подхачивать, так чтобы он возвращал не только a в степени, но и сумму всех степеней со 0 по a в степени n.
Давайте я его назову f.
Значит, эта штука будет возвращать мне пару a n и сумму всех степеней матрицы с 0 по n.
Осталось научиться такой алгоритм делать.
Но здесь формулы перешеда будут очень похожие, потому что, смотрите, давайте рассмотрим базовые случаи, как вся n равна 0.
Тогда у вас здесь единичная матрица, здесь единичная матрица, тут все понятно.
Дальше, если она нечетна, то мы хотим посчитать f от a n через f от a n-1.
Но тут все просто, если нам известно a в степени n-1 и сумма матриц от a в 0 до a в степени n-1,
то чтобы получить вот это, нам нужно первый аргумент пары домножить на a и его добавить к второму элементу пары.
Если нам известно a в степени n-1 и сумма всех степеней от 0 до n-1, мы сначала первый элемент пары домножаем на a,
получаем a в степени n, и потом его добавляем сюда, получаем сумму от a в 0 до a в степени n.
Понятно?
Так, ладно, давайте тогда напишем. Пусть вот это вот x, вот это вот y,
тогда здесь мы возвращаем x умножить на a, а здесь y плюс x умножить на a.
То есть я рекурсивно, в случае нечетного n, я рекурсивно запускаюсь от той же матрицы a и n-1.
Она возвращает мне две матрицы x и y, такие что x это a в степени n-1, а y это сумма степеней от 0 до n-1.
Теперь, чтобы посчитать a в степени n, мне достаточно x умножить на a, потому что они отличаются просто на одну степень a.
Поэтому первый элемент пары здесь это x умножить на a, а второй, это что такое?
Мне нужно вот сюда вот добавить a в степени n, но a в степени n у меня уже есть, я ее просто добавляю в конец, получаю то, что надо.
Так, это простой случай, теперь случай четного n, n четно.
Но опять я хочу научиться считать f a n через f a n пополам.
Пусть мы рекурсивно посчитали, запустили, оно нам что-то выдало, мы знаем a в степени n пополам
и сумму всех матриц от a в степени 0 до a в степени n пополам.
Но опять, пусть вот это x, это y.
Значит, что делать с первым элементом пары понятно, надо просто вернуть x в квадрате, то есть x умножить на x.
Но тут ничего хитрого нет, у этого мы уже делали, чтобы получить a в степени n из a в степени n пополам, надо просто его вывести в квадрат.
x на x умножить, это будет a в степени n.
Вот, чуть похитрее дело вот с этой суммой.
y плюс x, y. Ну да.
Ну, мне придется по крайней мере.
Давайте я вот так вот сделаю.
Я напишу сумму, которую хочу получить.
Разобью на 2 подотрезка.
Из второго вынесу a в степени n плюс 1 пополам.
Ой.
Еще раз?
Где, где?
Нет, sorry, я не понимаю, дайте я сделаю.
Я на слух x на y не воспряму.
Сейчас, что-то тут было проще же, нет?
Мне не нравится, что у меня...
А, не, все нормально, все нормально.
Я вот здесь a в степени n пополам вынесу, все ок.
Значит, смотрите, вот это будет...
Это я оставлю, а здесь вынесу a в степени n пополам.
Все, норм, я победил.
Значит, останется a в первой, a во второй и так далее a в степени n пополам.
Потому что здесь, если я вынес из a в степени n а в степени n пополам множителем, то остается а в степени n пополам.
То есть тут у меня получилось почти то же самое, что здесь за вычетом a в нулевой, что есть единичная матрица.
Поэтому я могу переписать, что у меня написано здесь y, здесь написано x, а здесь написано y минус e.
Я смог.
Правда?
Ну все.
Тогда я могу написать, что второй элемент пары это вот то безобразие.
y плюс x на y минус e.
Конец.
Да, конечно, со симпатикой все то же самое, потому что опять-таки у меня работает как бинарное воздействие в степень.
То есть на нечетных я делаю минус 1, на черных делю пополам, поэтому глубина рекурсии будет логарифмическая.
А на каждом шаге я умножаю и складываю матрицы.
Умножение работает за куб от размера матрицы.
Сколько я делаю неважно, главное, что константное количество.
Поэтому все это работает опять-таки за куб размера матрицы умноженного логарифма показателя степени.
Хорошо.
Все.
Ну и за кольцу.
Если мы научились вот это вот делать, то мы научились решать вот эту задачу.
Потому что мы научились считать вот это.
И дальше надо просто вывести элемент на першине х из страхи у столбца.
Так. Что-то как-то я быстро все рассказал.
Ну давайте еще такой сюжет.
Тоже вокруг этого.
Задача.
Так.
Давайте я для простоты опять-таки буду считать пути длины ровно к.
Но спрошу себя более простой вопрос.
А именно, не количество путей, а просто есть ли путь длины ровно к.
Есть ли путь из х в у?
Нет.
А есть ли путь из х в у?
Нет.
Есть ли путь из х в у?
Длины ровно к.
Значит, ну понятно. Можно было бы просто найти их количество и сравнить с нулем.
Ну, можно сделать, но это не интересно.
Я хочу проиллюстрировать сейчас определенную технику.
Можно там, ну типа да.
Можно сделать, чтобы лучше было.
Сейчас скажу.
Значит, смотрите.
Что можно делать?
Давайте мы будем считать не количество, а факт наличия.
То есть будем считать не количество путей, а просто узнавать есть путь или нет.
Тогда, собственно, наша динамика тоже пересчитана.
Давайте я напишу пересчет динамики.
Вот пусть, как проверить, что есть путь.
Давайте я сначала напишу.
Это значит есть ли путь из х в у длины n.
То есть это просто единица или ноль.
Единица если есть, ноль если нет.
Булисский флаг.
Тогда, смотрите, я могу написать выражение для n плюс 1v
через дизъюнкцию следующих конъюнкций.
То есть по всем последним ребрам.
Нет, просто дизъюнкцию.
Давайте я напишу так.
dp, n, ut.
Потому что, чтобы попасть в вершину v за n плюс 1 шаг,
я должен фиксировать некое последнее ребро из uv
и добраться до него за n шагов.
Соответственно, по ним по всем взять дизъюнкцию,
потому что достаточно наличия хотя бы одного такого ребра,
чтобы был путь до начала ребра длины n.
Либо же, если я хочу брать дизъюнкцию не по всем ребрам,
а по всем вершинам, от 1 до v большого,
тогда здесь можно взять конъюнкцию dp, n, u
на факс того, что есть ребро из uv.
Ау?
Нет, конечно.
Значит, m, ut, v.
Ну, где m это как раз матрица смежности.
Похоже на правду?
Чудно.
Так вот.
Я хочу ввести новую процедуру умножения матриц.
Я хочу ввести буллевское умножение матриц.
А именно, я в обычном определении произведения матриц
заменю сумму на дизъюнкцию,
а произведение на конъюнкцию.
Давайте я ее как-нибудь обозначу, не знаю,
к сорам каким-нибудь.
Пусть у меня есть две матрицы a и b.
Две матрицы из 0 единиц размера, пусть будет v на v.
Тогда давайте определим их буллевское умножение.
Ну, тут вроде как нет у кого-то стандартного значка.
Давайте я нарисую тензорное произведение,
потому что имею право.
Буллевское произведение,
которое сдается вот по тому правилу,
это дизъюнкция конъюнкции.
c и tожи t это дизъюнкция по всем k.
Давайте не буду писать пределы,
потому что как-то криво получается.
Собственно, вот ту формулу просто переложил на случай матриц призвольных.
Тогда я утверждаю, что вот та задача решается следующим образом.
Нужно взять матрицу смежности,
возвести ее в терминах вот такого умножения в катую степень
и посмотреть на ячейку с номером x и y.
Здесь, чтобы ответить на этот вопрос,
я просто беру матрицу смежности m,
возвожу ее с точки зрения нашего нового умножения Буллевского в катую степень
и вывожу ее значение в точку x и y.
Собственно, доказательства здесь вот отсюда следуют,
потому что мы ввели такую динамику как раз таки,
ее очередной слой выражается как дизъюнкция конъюнкции,
ну и мы ровно так определили бинарное умножение,
Буллевское умножение матриц.
Мы его определили так, чтобы это было ответом на самом деле.
Мы так ввели умножение, чтобы оно отражало те свойства,
которые мы от него хотим.
Осталось научиться как-нибудь быстро возводить матрицу
в нужную степень по данному умножению.
Работает все то же самое,
что отсюда вместо умножений нужны вот эти нормальные умножения Буллевские.
Давайте быстренько это напишем.
Пусть я хочу, чтобы f от a, n возвращала мне n-ую степень матрицы a
с точки зрения нашего Буллевского умножения.
Тут надо еще научиться находить эту самую единичную матрицу.
Что будет единичной матрицы здесь?
Сойдет ли e?
Вот я сейчас попытаюсь понять.
Похоже на правду.
Если я беру какую-то строчку.
Ну да, как раз она выделяет...
Да, да, да.
То есть на самом деле с точки зрения умножения вот этого или обычного
у меня единичная матрица тоже будет нейтральным элементом.
Ей это нейтральный элемент.
В том смысле, что на какую матрицу ее не умножай,
вот в этих терминах получится как раз-таки другая матрица.
Давайте переду, если не видно.
Я вот ожидал, что е – это нейтральный элемент.
В том смысле, что е на любую матрицу m – это m.
Ну и m на е – это тоже m.
Ну легко пронаблюдать, что если у вас в е на диагонали
единичка все стами нули,
то когда вы перемножаете е на m,
у вас в этом строке в житом столбце получается как раз
m и t житое.
То есть мы просто оставляем...
Поскольку здесь единица только в одной позиции,
мы просто оставляем то, что было в точке m и g,
и все будет нормально.
Ну а дальше все как обычно.
f a n – это f a n пополам умножить само на себя,
если n четно.
Да, если n четно.
Ну если n нечетно,
то я как всегда отделяю сначала
один раз нашу матрицу a
и рекурсивно считаю f a n – 1.
Если н нечетно.
Получается вновь решение за
куб размера матрицы на логарифум
чего там, видимо, k.
Да, логарифум показателя степени.
Я обещал, что это можно делать чуть быстрее,
чем вот это.
Да, на самом деле можно просто
более эффективно перемножать
строчку на столбец.
Ну давайте я напишу утверждение.
Буливское произвление матриц можно найти
за o от v в кубе делить на w,
где w длина машинного слова.
То есть это, грубо говоря, то,
что у вас помещается в регистр,
или там в int, или в long-long.
Например, если у вас длина машинного слова 32,
то у вас здесь будет n² на 32.
Куб размера поделить на 32,
или на 64.
Значит, здесь очень просто.
Смотрите, вот это две матрицы.
Мы хотим перемножить, как всегда работает
произведение, мы хотим перемножить
эту строчку на житый столбец.
Давайте побьем их на
блоке длины w.
И теперь мне что нужно?
Мне нужно побитого их умножить,
в смысле, взять побитую конъюнкцию
и взять потом дизюнкцию.
Но я умею уже брать конъюнкцию
двух слов.
У меня есть такое слово,
машинное, длина w, и вот такое.
Я хочу взять побитую конъюнкцию.
Это просто ант.
Беру дальше ант вот этого и вот этого,
вот этого и вот этого,
вот этого и вот этого.
В конце мне нужно проверить,
есть ли там хотя бы
один единичный бит.
Это надо просто сравнить эту...
Еще раз, я беру попарную конъюнкцию
вот этих, вот этих, вот этих, вот этих.
Потом это все беру под дизюнкцией,
и мне нужно проверить, что в этой дизюнкции
есть хотя бы один нелевой бит,
то есть дизюнкция не нулева.
Давайте я напишу так, вот есть
x1, x2, x3, x4,
y1, y2, y3, y4.
Я беру попарные конъюнкции,
потом их объединяю через дизюнкции.
И соответственно, если здесь
не ноль, то значит,
то значит на переченье
этой строки житого сопса в новой матрице
стоит единица.
Если здесь не ноль, то это значит,
что c и t ажито равно единице.
Понятно, что произошло?
Еще раз, смотрите, вот у меня,
как у меня считается c и t ажито,
c и t ажито, это я беру итую строчку
в матрице A, житую строчку в матрице B,
причем все, столбец, sorry,
причем это нули единицы все.
Дальше я бью на одинаковые
блоги длины w, например,
по 32 бита.
Я могу представить эти 32 бита как один int,
unsigned int, например.
Потом я их все попарно andeo,
oreo и они,
вот этот or не нулевой,
только если в конце единицы.
В итоге как раз получили ускорение
ровно в w раз, что равно длине машинного слова.
Иногда бывает полезно.
Все, спасибо.
