Последние 10 минут, да, тут, по-моему, все уже можно напоминать, тем более, что давайте, так,
ну, тем более, что давайте, так, давайте, так, сейчас, давайте по ICPC вопрос чуть позже обсудим,
потому что сейчас у нас как бы через, там, 35 или 45 минут нас по-любому отсюда выгонят, вот,
поэтому давайте, собственно, вспоминать, что там, что за фурятина у нас там была две недели назад.
Вот, но если так вкратце, то мы с вами остановились на том, что, то есть мы научились, как, если я
правильно помню, мы научились делать фурье за n log n, и так на уровне идеи вроде поняли, что как бы
то, что мы делаем, это обратимо. Вот, так, а напомните, научились мы, так, но мы с вами так и не научились,
по-моему, писать фурье нерекурсивно. Нет, ну, код мы не писали, но рекурсивно мы вроде поняли более-менее.
Что мы поняли? Давайте, итак, краткое содержание, давайте вспоминать. Значит, напоминаю, значит,
но мы сейчас даже немножко абстрадируемся. Значит, сейчас будет мистическая абстракция, да,
мы говорили о каких-то там комплексных числах, но мы говорим следующее. Ну, во-первых, напоминаю,
что мы перемножаем с вами, ну, значит, так, цель у нас в итоге оказалась следующая, что у нас с вами
есть многочлен. Многочлен размера два в степени k, а еще у нас, а еще мы живем в мистическом поле k,
то есть более поле, ладно, какой буквы можно обозвать поле? Ну, естественно, да, конечно. Вот,
почему f, да, f значит field, логично, да. Вот, что мы знаем про это поле? Значит, ну, помимо того,
что это поле, мы знаем, что в этом поле есть мистическая штука. То есть у нас будет такое понятие,
как мистическая штука, вот я ее буду называть даже qn. У этой qn есть мистическое свойство,
что qn в степени n равно 1, а qn в степени n пополам не равно 1. Да, для n равно степени 2, как вы в
прошлый раз убедились, не будем сейчас повторяться, это эквивалентно тому, что qn в степени n равно 1,
а числа 1 qn в квадрате qn в кубе и так далее по парду различны.
Да, да, конечно, важно, что n в степени 2, потому что, да, если бы n было равно 18, то это было бы,
конечно, ни черта не так просто, потому что это могло быть там какой-то q в третьей степени,
не могло быть равно 1. Ну ладно, не совсем, ну ладно. Нет, хотя нет, совсем, совсем. Вот, но для
степени 2 это вот просто такое просто упражнение, действительно, показать, что это так, что это
эквивалентно. Вот, значит, что нам надо? Нам надо с вами научиться, значит, получать по последствия
0, 1 и так далее n-1, последовательность чисел a от qn в степени 0, a от qn в степени 1 и так далее
a от qn в степени n-1. И наоборот, да, в качестве полей в основном мы используем комплексные поля,
поля комплексных чисел, но если, как мы уже говорили, если вам фантастически повезло,
если у нас там есть поле по простому модулю и простой модуль, там простой модуль P имеет
вид там q на 2 в какую-нибудь достаточно большую, например, больше, чем k степень, то такое q там
тоже найдется. И это позволит вам делать то же самое, только без всяких этих ваших точностей с
доплами. Вот. Значит, как же мы это делаем? Значит, как же эта мистика делается? Значит,
ну, выяснялось, что это делается достаточно просто, по крайней мере, на уровне идеи. Мы говорим,
что мы вводим, то есть, по крайней мере, если вот в эту сторону думать, что a0 от t мы вводим,
как наращение размера n пополам состоящийся, аккуратно, это есть формулировка, коэффициентов
с четными индексами. Да, очень хочется в этом месте употребить в словосочетании четные,
конечно, коэффициенты, но когда они даже не обязательно целы, это сомнительно. Так, t в степени
пополам минус 1. Ну, как сказать, в действительности, даже в действительности комплексных на 2 делится
все. Так что, да. А мы тут на пополам что-то хотим, там что-то это t в кубе плюс и так далее, плюс вот
такая вот красота. Почему мы неожиданно решили так развлечься? Мы решили так рассмотреть
таким наращением, потому что мы с вами обнаружили, что at равно a0 от t квадрат плюс t на a1 от t квадрат.
Мало того, что так, так еще и оказывается, так еще и оказывается следующий интересный факт,
что если вы возьмете это число qun и вот рассмотрите вот эту последовательность,
вот я вот так напишу qun в степени n пополам, qun в степени n пополам плюс 1, qun в степени n
минус 1. Оказывается, что если я всю эту последовательность возведу в квадрат,
то у меня получится число 1, qun в квадрате, qun в четвертой, qun в шестой и так далее, qun в
степени n минус 2, qun в n, но это равно 1, дальше qun в квадрате и так далее, qun в степени n минус 2.
То есть мы еще, да, вводим еще такую, такую приятность, что должно быть еще что qun пополам,
то это должно быть qun в квадрате, ну потому что q можно ввести несколькими способами обычно,
да, вот, поэтому мы вводим там для каждого, для различных степеней двойки, вводим q согласованно,
вот так. Вот, но оказывается, да, что вот эти вот числа это фактически то же самое, как 1, qun
пополам t, qun пополам t в квадрате, qun пополам t в кубе и так далее, qun пополам t в степени n
пополам минус 1, дальше 1, qun пополам t, ну и так далее, короче. То есть получается, да, что вот,
чтобы получить вот эти значения многочлена A в n точках, вот эти числа, нам нужно получается
в многочлены A0 и A1 подставить все степени qun пополам. Вот, понятно, да? Вот, понятно?
Чего? qun в квадрате, qun в четвертой, единица, qun в квадрате, qun в четвертой, qun в шестой и так далее.
Где? Да, вот она. Нет, это просто, вот пусть у меня есть как бы набор степеней qun. Ну да,
qun в степени n пополам минус 1, qun в степени n пополам, qun в степени n пополам плюс 1 и так далее.
Да, все просто. Вот, то есть оказалось, что надо просто теперь, то есть оказалось, что если мы тут
подставим, то в общем-то, ну действительно, можно прям так и написать. То есть для любого,
вот как мы писали, для любого j меньше, чем n пополам, получается, что A от qun в степени j равно
просто A0 от qun пополам в степени j. То есть, оказывается, если вы вот, вот, вот,
плюс qun в степени j на A1 от qu в степени j, но n пополам. А от an в степени j плюс n пополам,
оказывается, равно абсолютно то же самому, тому же самому, n пополам. Ну, как бы, в квадрат
возвели, получилось qun в степени n, на qun пополам в степени j, qun в степени n это единица. Вот,
и тут получается, что, а тут получалось, ну ладно, если очень вкратце, вкратце расписать, мы это в
прошлый раз делали, то окажется, что минус qun в степени j на A1 от qun пополам в степени j. Вот,
вот такой вот оказался прикол. Ну вот, ну вот, то есть, в принципе, вот, то есть, вот такой вот
логенчик получался. Вот. Так, сколько у нас там? Нормальное время? Нормально. Вот. То есть,
вот такое заклинание. Ну вот, и, и, соответственно, чисто теоретически оно на самом деле, на самом
деле приводило, могло привести к следующему коду. Вектор k, fft. Значит, я бы сказал так.
Чего? А от qun в степени j, plus n пополам. Ну равно A0 от qun пополам в степени h. В общем,
то же самое, что и здесь, только вместо плюса минус. Прям копия. Вот. Да, то есть, qu здесь,
я имею в виду, что qu тождественно равно qun. Ну, да. Ну, а мега мы просто использовали в комплекте
числа. А я здесь пишу qu, чтобы подчеркнуть, видишь, что это произвольное поле. Вот. Ну и говорим.
Там пишем int n, как всегда равно a.size. Ну, там можно там даже для разбитом написать,
что assert там, я не знаю, n, степень двойки. Если прям очень-очень-очень надо. Ну, там надо
проявить, что assert там n, степень двойки, что q обладает вот этими свойствами приятными и так далее.
Там, но это если очень хочется, на самом деле обычно этим никто не занимается,
что q в степени n равно 1, q в степени n пополам не равно 1. Ну и говорим. Если оказалось,
что n равно 1, то надо естественно выброситься из этого fft с криком a. Вот. Просто a. Вот.
Ну да. В противном случае мы завоем вектора a0, a1 и дальше говорим. For instance,
i равно 0 и меньше n и плюс равно 2. Говорим. Значит, в a0 мы пихаем. Так, ладно, не i, а g.
Ну ладно, когда мы перешли в поле уже по барабану, ну лучше g давайте.
Значит, вот получается так. a1.push, а в a1 пихаем a0. То есть как раз вот то, что надо. Товарищи
с четными коэффициентами отправляются в 0, товарищи с нечетными коэффициентами отправляются,
ну ладно, нечетными индексами отправляются в 1. Вот. Понятно, да? Вот. И теперь немножко наоборот.
Так. Ну и теперь говорим. Смотрите. a0 равно fft от a0. Нет, неправильно. Для того, чтобы немножко
оптимизировать, давайте я веду так. kqq равно q умножить на q. Ну логично, да? Ну как записывать q
умножить на q? В алгабрите записывается как qq, логично. Так, вот. Ага. Да-да-да. a0 превращается.
Давайте fft с a0 и qq, когда вы будете знать текст?
Так вот, значит теперь немножко, ну вот, и самая магическая строчка.
Значит теперь я пишу kqdeg равно 1. Ну, верим, что в нашем поле, наверное, есть 1.
Вот. И дальше мы делаем следующее.
Так. Как это называется? Здесь мы используем наше выражение.
Можем ли мы использовать нормальный маркер? Как сказал бы классер.
Так вот. Дальше пишем int g равно 0, g меньше, чем n попало, плюс, плюс g.
И тут мы говорим. Ну, здесь я уже сразу пишу с оптимизациями, мы это в прошлый раз обсуждали.
Значит, значит k, допустим, какой-нибудь, а, ну так пишут, u равно ajt, kv равно aj плюс n пополамt, умноженное на qdeg.
Вот. И дальше мы пишем ajt равно u плюс v, aj плюс n пополамt равно u минус v, и что-то еще.
А, и, конечно же, его величество qdeg умножить равно q.
Блээээ. Какое безобразие, что делать-то, а?
Мы в прошлый раз оптимизацию уже обсуждали.
Нет, не обсуждали. Так, ладно. Да, обсуждали, но не с вами, да. Это, да, точно, да, это в 11 классе было, да.
Так.
Бывает.
Ну да.
Вот.
Вот теперь хорошо.
Нет, нехорошо.
Мы пишем обычный код, или уже какой-то...
Ну, и то, и то.
Ну, как сказать, пока мы пишем рекурсивный код.
Ну, точнее, как пишем.
Нам осталось только выброситься с криком a, как всегда.
Так. Вот. И вот все.
Вот так вот выглядит код.
Так, почему как, кстати?
F уже. Мы ж поле F называем.
Да, мы здесь уже кофигу уже.
Ну, что делать?
Нет, ну можно взять type-def, kf, там вот это все.
Ну, знаете...
Какой type-def? Defi?
Да, это шедевр, конечно, да.
Так.
Вроде никто не знал.
Да тут вообще что-то вон...
Кошмар вон съездил, вон что-то ведь...
Ну, знаете, вот он съездил под Гладыш, ему поплохело что-то.
Ладно.
Ну вот. Ну, в общем-то, пока в этом коде, в общем-то, ничего экстраординарного не написано. Правда?
Есть такое, да?
Какая-то лагерь, по-моему.
Какая-то магия.
А почему мы один раз умножаем qdek на q?
А потому что мы тут параллельно этот qdek в степень возвоим.
Видите, там же должна быть qm в степени g.
И поэтому мы тут, когда прибираемся фориком, мы как бы вот qdek...
qdek это вот текущий...
Да?
Нет, только в одном месте.
Все, вот теперь хорошо.
Нет, qdek все.
Я вторую q убрал.
Не, ну если совсем плохо видно, я могу то же самое по телевизору показать.
Давайте.
Так, сейчас попробуем.
Нет, рекусивный код.
Так, я, кстати, надо покопаться, может у меня там код даже есть.
Ой.
Рекусивный код есть на Ямасе.
Ну, там...
Причем там почти такой же код, как мы сейчас написали.
Ну, логично.
Слушайте, вот зазвоните мне.
Да.
Значение.
Ну, например, мы из коэффициентов многочленов получаем значение многочлена вот в степенях кушки.
Обратно? Нет.
Ага.
Так.
Так, ладно.
Так, а камера готова смотреть телевизор?
А, готова, вижу.
Так.
Ну, пока там.
Ну-ка, давайте попробуем.
Так.
Так, где я? Так.
Так.
Так.
Тут кодов нет, обидно.
Ну, ладно, так.
Ну, в принципе, да.
Ладно.
Так, ладно, давайте.
Ой.
Ой, что тут было такое?
Боже.
Не, ну да, нет, я в Бангладеште там...
Так.
Так.
Так.
Не, это не Бангладеш, это его нормальное состояние.
Так.
Так, значит.
Так.
Не, это не Бангладеш, это его нормальное состояние.
Так.
Не, ну, кстати, Бангладеш очень милая страна оказалась.
Ну, как сказать?
Мы не то чтобы...
Мы только там два часа, видимо, были
в самом Бангладеше, собственно.
В остальное время нас как бы возили
из пятизвездочного отеля
в, собственно, место проведения финала.
Аккуратненько огороженное
от внешнего мира.
Вот.
Поэтому... Ну, мне понравилось.
Вот так.
Но это отдельная, но это отдельная песня.
Сейчас давайте не будем на это время трясти.
Это следующая лекция.
Ну, а что следующая лекция у нас когда-то?
Через полтора часа потом будет, да?
Ой.
Так-то вполне себе мило, да.
Как бы имело смысл выходить до финала, чтобы там...
Так. Ой.
Ну...
Ну, как сказать? Мне было сложно.
Я по возрасту бы не проходил.
Поэтому мне... Я ездил в Екатеринбург.
Екатеринбург тоже хороший город.
Так, Олимпиадная...
Так, сейчас...
Уфты, лекции, семинары.
О, вот сейчас мы вот сюда этот
ФФТ и положим.
Значит, смотрите.
Сейчас поедем.
Итак, супер-код.
Итак, начну...
Начинаем.
Пожалуйста.
Ага.
Так.
Так, ну я так.
Так, ладно.
Значит, поехали.
Начинаем с того, чтобы получить бан
на предыдущей паре?
Да, но мы не на предыдущей паре.
Пожалуйста.
Здесь, кроме туды,
ничего не смущает.
Вот.
Ну, нет.
Еще эти парни на лонглог как-то не стоят.
Ну, это ладно.
Какой лонглог? Тебе должно смущать,
что тут темплейта не стоит.
Вот так.
Ну, это, знаете, давай...
А вы все еще не знаете,
что такое темплейта, да?
Ну, я на них любую задачу сдавал.
Ну, основа знает, а он только не знает.
А основа там, динамику, наверно,
тоже знает, да?
А мы с вами видимо только в следующем семестре узнаем,
что такое динамика.
Да.
Ну, тоже видимо в следующем семестре, да.
Не, ну,
как сказать, на DFS основаны важные алгоритмы,
как там, поиск, компонент всяких
связностей, а также дерево
доминаторов, да. Они основаны
доминатором? А, как же!
Ну, DFS-то зачем вы?
Ну, в смысле, дерево доминаторов
или какая-то структура
специальная для хитовства?
Тебя поздно, ты думал,
что мы едем на динамику?
В DFS
вы кученым чем-нибудь.
Ну, ты DFS-то скидываешь?
Да.
Я не знаю,
не знаю.
Сейчас вы загоните.
Я не знаю.
Я не знаю.
Я не знаю.
Вы не договаривайтесь.
Вы не договаривайтесь.
Вместо N
минус 3,1
написать знак безотвержность.
И сколько раз?
Все, какой экдак по инвлежности, где?
В динамике.
А что вы выясняете
перед летом?
Ну, не дойди.
Это вообще так не доехать.
Это вообще так не доехать.
Это вообще так не доехать.
Так!
Не, не дойди!
Не, не дойди!
Можно быть умной операцией
на степень блоки.
За 1,3
за 1,3
за 1,3
Н, N минус 1,3
Н, N минус 1,3
Вот, не взрослись.
Так, ну что?
Пока все понятно, да?
Да, да.
Так, вот.
Там, обратите внимание,
у нас там формула к степени QN
а не QN пополамтова,
поэтому домножаем именно на Q,
не на QQ.
Не точно.
О!
Вот теперь хорошо.
То есть, вот как мы можем увидеть, вот...
Вот...
Нет, ну, как бы, по крайней мере,
сейчас должно быть вроде понятно, что происходит, да?
Так вот, понятно,
почему этот код действительно делает то,
что мы себе заявляли?
Ну, утверждение, что нажитые
итерации QDEC это в точности
Q в степени G.
Но у нас в итерации всего типа...
N пополам.
Правильно.
Да, но обратите внимание,
мы на каждом шаре по два значения заполняем,
пользуясь мистическим свойством.
Ну, потому что здесь, как бы,
я могу здесь порисовать еще, да?
Что значит...
То есть, A от QN
в степени, соответственно,
G плюс N пополам, видно тут что-нибудь?
Ну да, это я вот покажу, откуда тут вот берется, да?
Это что такое?
По определению,
это, как бы, что такое?
Это, как мы выяснили, это равно
значит,
многочлен A0.
Так, там видно, да?
Да, видно.
QN в степени вот этой штуки.
Ну, короче.
Вот.
Ой.
Это чего?
A0 от QN в степени
G плюс N пополам.
Ну, это я типа в техе пишу.
Да, да.
Здесь еще в степени, как бы,
еще два умножить на это.
Мы же квадрат возводим, помните?
Ну, типа...
Да, два умножить на G плюс N пополам, да.
Вот.
Теперь, что это такое?
Вот.
Значит, теперь заметим, что
QN в степени 2...
То есть, это то же самое, что...
Вот давайте я могу так написать выкладку.
Ну, по факту, да.
Да, два G не равно G плюс N пополам.
Вот у нас же там
минус стоит за этой строке, нет?
Сейчас.
Сейчас увидите, откуда он берется.
Ну, пока тут в степени N пополам находится.
Значит, начнем с того,
что QN в степени N равно 1,
поэтому вот это N я стираю аккуратно.
Нет.
Высчитаем значение многочлена A
в точке QN в степени G плюс N пополам.
Вот.
Я тут пошаманил, пошаманил выкладку.
Я обнаружил, что вот тут внутри
стоит QN в степени 2G.
Вот. А еще QN в степени G плюс N пополам.
Еще я знаю, что QN в степени N пополам
равно заведомо минус 1.
Ну, потому что если оно не равно...
То есть, жило было поле.
И был в нем х,
у которого квадрат был равен 1,
но сам х единицы равен не был.
Чего равен х?
Простое упражнение на УКТЧ.
Такое на оценку 0.
Там, да, да, на оценку минус 3 даже где-то.
Соответственно, что это минус 1.
Так что получается вот N пополам
мы тут превращаем вот в минус.
И еще остается заметить,
что QN в степени 2G.
Это для нас то же самое, что
QN пополам T в степени G.
Мы в позиции A, G плюс N
плюс пополам.
G плюс N пополам, они
в включении 2D-членов,
2.Q в степени N.
G плюс N пополам, да.
Вот.
То есть оказывается, видите, что
формула оказывается абсолютно той же,
что и для ожитого обычного,
потому что для ожитого было бы написано абсолютно то же самое,
только тут было бы плюсик, а не минусик.
Поэтому здесь это
превращается вот в такой красивый код.
То есть здесь вот я специально
написал U и V, потому что иначе пришлось бы
делать вместо вот 2 умножения,
как мы делаем 3.
А это прям принципиальная оптимизация,
которая так в полтора раза ускоряет
код, ну почти в полтора.
Вот.
Да теперь у нас есть...
Так, ну сейчас тут понятно,
что тут написано?
А у нас снизу нижняя закомментированная строчка там
A0 от чего?
От QN пополамтова
в степени G.
Это фигурные скобки такие.
QN пополамтова.
Да.
Но в нашей терминологии QQ.
У нас
QN пополамтова в степени G.
Да не в степени
пополамтова.
Это Q в степени... это QN пополамтова
в степени G.
Ну да, вот если вам так удобнее,
можно так.
Почему QN в степени
пополамтова?
Ну потому что, смотрите,
потому что это, смотрите,
прямое уравнение
x квадрат... там
x умножить на x равно 1.
Это эквивалентно тому,
что x умножить на x минус 1 равно 0.
Это эквивалентно тому,
что x минус 1 умножить
на x плюс 1 равно 0.
Но раз у нас...
Ну вот.
Так, ладно, там в аксиомах поля есть
какая-нибудь там описание, что
как бы два не нулевых элемента
произведения дают что-то не нулевое.
Да, в поле не отделитель нуля
это часть определения поля.
Так как это поле,
то получается отсюда следует, что
x лежит в множестве
1 и минус 1.
Ну in это типа... в техе это знак
вот этой принадлежности множества.
1х принадлежит сразу
это множество.
Ну он принадлежит этому множеству, кто-то из них.
Вот и все, поэтому как бы...
То есть я как бы в определении ровно по этой причине
описал не равно 1, я написал более слабое
требование, но на самом деле если бы я написал,
что там равно минус 1, это было бы абсолютно
то же самое. Вот.
Так вот.
Значит, так вот так у нас пишется
ФФТ. Ну а теперь, видимо,
пока нас, прежде чем
нас выгнали, но пока нас не выгнали,
сейчас мы, значит, ну у нас
сегодня много целей и обратные
все они, что приятно, независимы.
Но пока раз уж мы смотрим на
собственно этот код, давайте попробуем
сделать первый шаг для того, чтобы сделать его
не рекурсивным.
Вот.
Не.
Значит, во-первых, скопировать.
Значит, а теперь давайте себе представим
вот что.
Значит, можно
на самом деле сделать так. Давайте себе представим,
что мы
не хотим ничего,
что мы хотим, как бы,
типа не вылезать за пределы
А.
Обратите внимание, от старого кода
что поменяется? Поменяется только одно.
Вот. Понятно, да?
Да.
Это действительно все.
Да.
Вот.
Более того, можно совсем развлечься и даже
еще подумать, а что делать, если мы хотим
не вектора, а массивы?
Ну, чтобы еще оптимальнее было.
Чего? А, потому
для этого надо переставить.
Для этого надо элементы
мистическим образом переставить, чтобы сначала шли
0, 24, 6, 8, потом 1, 3, 5, 7.
Если мы поверим, что у нас такое
есть, то на самом деле
это может работать следующим образом.
Сейчас я еще одну версию
напишу, смотрите.
Ой, о боже.
Сейчас увидите.
Вот. Значит, смотрите, на самом деле
то есть, как бы, делаем следующее.
То есть, во-первых,
а потому что массивы быстрее
векторов работают.
Но это, блин, может же сначала сделать
оптимизации, которые не влияют
на то, что век не век,
а потом уже оптимизируем на что-то.
Ну, вот.
Не, ну как? Ну, что такое глубоко?
Пока как бы не глубоко. Тут как бы
нет, тут как бы, все равно, следующая идея,
которая нам все равно понадобится.
Значит, смотрите.
Вот единственная проблема, что я тут, конечно,
мог забабахать вот что-нибудь, типа
там f, там, я не знаю,
звездочка а0 равно нью, там,
я не знаю, нью, f,
а тент пополам, вот да,
но согласен, если честно.
По времени мы
зафигеем,
поэтому мы здесь
делаем так.
Давайте пока не убирать векторов, берем векторов.
Смотрите, сейчас будет читерство красивое.
Переставить элементы
а.
Нет, ну, скажем так, просто за оставшееся
время мы этого не сделаем.
Мы только подготовиться успеем.
Нет, мы его не удалили, мы его теперь передаем.
Вот, допустим, что у нас есть
мистическая функция,
которая умеет заод
единицы дополнительной памяти
вот так переставлять элементы,
желательно еще и за линию, чтобы работало.
Ну, как со свопом?
А, а,
вперед забегаешь, вот конкретно,
если надо только вот на
сначала четное, потом нечетное,
ты так просто так не сделаешь.
Вот, значит, fft теперь запускается,
что такое массив а0?
Ну, на самом деле теперь массив а0
это просто массив, на самом деле,
это просто массив, на самом деле,
массив а0 это просто массив, начинающийся там же,
где а длинным пополам,
а массив а1 это теперь
массив, который начинается
в месте а плюс
и пополам и тоже длинным пополам.
Так, и теперь как удалить
вот это вот а0?
Удалить его неожиданно
просто.
Да, то есть на самом деле вот так надо.
Нет, обратите внимание, кстати,
почему тут уев прям так отдельно выносится,
видите, что магия заключается в том,
что вы берете два элемента и заменяете
их на два элемента.
Ага.
Вот получается такая красота.
Есть еще одна эпичная оптимизация,
давайте последнее, что скажу.
Прям тут сразу хочется ее делать,
потому что это такая важная
оптимизация. Вот что мы делаем
n log n раз? Обращаемся к массиву, правда?
То есть прибавляем
к а, вот эти жишки там и так далее.
Зачем?
На самом деле это делается
вообще совсем мистическим образом.
Внимание.
Значит, f
звездочка st равно a,
звездочка, допустим,
mid равно a плюс
n пополам.
Значит, звездочка, допустим,
так,
ukl
равно
указатель?
Да.
Что за мем?
Вот.
ukl, ukr.
Значит, сейчас вот это, сейчас просто весело будет.
Сейчас вот вместо вот этой магии.
А ukl точно
у нас указатель?
Потому что ukr
значит, сейчас
сейчас вообще
хорошо будет.
f u равно
ukl
f v равно
ukr
ukl
равно u плюс, а, ну да,
пардон, конечно, тут умножить надо обязательно
на кудек обязательно.
ukr равно u минус
v.
Все-таки ошибка.
Что?
А,
кошмар какой.
А так?
Во.
Так, че?
То есть у нас просто st min
не существует, чтобы существовать?
Чего?
Да, мы что-то очень странное написали.
Не, на самом деле он существует для того, чтобы
я тут
написал, вот вместо вот этого
фора я написал
while
ukl неравно
mid.
А пригодится потом.
Сейчас ни зачем.
Ах да.
Сейчас ни зачем.
Нет.
Но мы ей
просто воспользуемся, когда мы писали некурсивный код,
поэтому я ее оставлю.
То есть смотрите, вот такая теперь у нас красота.
Если я сейчас вот это все
комментарии уберу,
то получится
вот такой красивый код.
Ну, можно и убрать.
Ну, как сказать, ладно, пока их
не трогайте, может и не сильно,
но тут как бы
ну, скажем так,
чуть-чуть дольше должны
работать, просто потому что
оберточка все-таки.
То есть итератор будет тот же самый указатель,
но там будут какие-то навороты, поэтому чуть-чуть дольше
наверное будет.
Нет, ну да, просто смотрите, тут как бы важная
фишка всегда заключается в том, что
нет, просто тут важная фишка, что мы
значение массива не вычисляем, тут
у этого кода еще приятная конечно
такая приятность есть, что
вы на самом деле к памяти обращаетесь подряд,
а не рандомно.
Помните, мы когда обсуждали внешнюю сортировку,
мы говорили о том, что обращаться
к памяти подряд гораздо быстрее,
чем обращаться в рандомное значение.
Вот.
И вот здесь у нас, ну вот и здесь
это отчасти этого иллюстрация,
ну то есть конечно это, и здесь в общем-то
это тоже было так.
Ну вот, но здесь как бы мы этим совсем
уже воспользовались, то есть видите, мы там даже не плюс-плюсов
никаких не делали, то есть плюс-плюс
делает только тот, то есть можно тут,
то есть на самом деле правильно тут вообще писать вот так.
Вот тут сейчас
совсем взбодробительно будет.
Пушка, да.
Вот на самом деле это вот так пишется.
Ну при большом желании можете еще
в эту вот инициализацию еще
кудек впихнуть,
но...
А почему?
Это очевидно.
Ну это очевидно.
Ну слава, ну и ладно,
но я не знаю, да, а что?
Мещерин дал вам уже задание написать
длинную арифметику? Да.
Через FFT еще недели назад. А,
молодец. Что-то ты и хотел. Так.
Ладно, ребята, значит,
поехали. Итак,
на чем мы остановились?
Мы остановились вот на этом
вот.
Мы обнаружили, что в принципе рекурсивный
FFT можно написать в одном
красивом массиве без этих
ваших там векторов,
если у нас есть
вот такая мистическая функция.
Вот.
Желать то, чтобы она работала за
O от N времени и O от единицы
дополнительной памяти.
Как это делать, я не знаю.
Не в последнюю очередь,
потому что нам это на самом деле
не надо.
Почему?
Потому что на самом деле следующая цель,
которая у нас будет, давайте просто наконец
избавимся от рекурсии.
Извините, то есть мы не будем
обвалить эти элементы в таком порядке?
Да.
И не будем мы это делать вот
почему.
Не судьба.
Ага, сейчас.
Так, мечта.
Сейчас вы увидите
собственно почему.
Потому что на самом деле, смотрите.
Давайте вот внимательно посмотрите.
Нижняя часть заключается в том, что
у нас есть массив
и мы с ним просто
делаем маленькое линейное шаманство.
Вот.
Значит, да.
Чтобы было действительно максимально
хорошо, сейчас я покажу.
Сейчас я буду показывать на примере
Смотрите.
А нулевое.
А первое. А второе.
А третье. О маркер.
Хорошо пишет.
Так что смотрите.
Вот.
О.
О. Отлично.
Так вот. В чем заключается шаманство?
Если верить этому коду,
то происходит следующее.
Мы его переставляем вот в таком порядке.
Все элементы.
А может не надо примеры длины миллиард
рассматривать?
Я не рассматриваю примеры длины миллиард.
Я рассматриваю пример длины 16.
Нет, скажу так.
Я в свое время пытался проводить
на примеры 8, это вообще ненаглядно.
А 57 – степень двойки.
Нет, я могу нарисовать 64.
Нет, ну 64, то знаете,
я отдельно в студии должен написать
что-нибудь за 3 часа, а потом перемотка
под балалайчик.
Значит, смотрите.
Не волнуйтесь, на самом деле это недолго.
Итак, мы распилили
на четные индексы и нечетные индексы.
Дальше происходит
тут какое-то независимое
шамань-шаманство.
Тут происходит независимое шамань-шаманство.
Потом мы пробегаем двумя указателями
по вот этим элементам
и каждую пару там тоже
перешаманиваем.
Два указателя у нас называются
УК-левый и УК-правый.
Логично, да?
То есть как бы все честно
и на понятном языке.
А теперь мы искать такая идея.
А что мы делаем?
Давайте попробуем развернуть следующий слой рекурсии.
Следующий слой рекурсии
скажет нам,
что мы, значит, вот этот подмассив
распиливаем на A0,
A4, A8, A12,
а потом A2, A6,
A10, A14,
потом A1, A5,
A9, A13,
A3, A7,
A11, A15.
Доделаем, посмотрим.
Смотрите, то есть можно было
два слоя рекурсии
на самом деле развернуть.
Давайте упорядочим элементы сразу вот так.
Потом внутри каждого массива
длины 4 сделаем вот это вот шамань-шамань.
Потом, значит, по этой паре
пробежимся с ку-ку,
здесь пробежимся
по этой паре с ку-ку,
а вот потом по этой уже паре
полученных массивов пробежимся с ку-ку.
Понятно, что я сказал, да?
Вот.
Ну, вы помните, ку-ку это у нас
ку в квадрате, да?
Вот.
Ку-ку, да. Ну, можно ее называть ку-кушкой,
если хотите, да.
Вот. Ну так вот.
Давайте разберем следующий слой рекурсии.
Да, этот слой рекурсии
мы сделали с ку-ку,
этот сделали с ку-ку.
Ну, следовательно, слой с ку-ку...
Не, ку-ку ку-ку.
А, да, действительно.
Почему?
Ку в четвертый, да.
А на экзамене будут спрашивать
тедолы при ализации
физико-физики?
Не, ну это святое, ребят.
Более того, вам на любом контесте,
где задача на фурье, будут спрашивать.
Потому что
дело в том, что то, к чему мы стремились,
работает 10 раз быстрее.
Поэтому, как вы напишите рекурсию, вы получите свой трейл
и будете сразу скажут, ну что, нет, фурье писали,
ну просто, а что, ну просто
наш НЛОГН 10 раз быстрее НЛОГНа вашего,
ну что мы можем сделать?
Мы не оптимизировали,
ну просто, да. Ну, то есть оптимизировали,
ну вот, соответственно. Вот.
Так вот.
Значит, есть так
разворачивать, то получается следующее.
У нас есть вот такие массивы.
Значит, А4, А12,
А2, А10, А6, А14.
В общем, короче, да, такие.
Так, я тут лучше уже перемотаю,
конечно, да, тут.
Так.
3А11, А7 и А15.
Ну и что, что да, ну вот.
То есть, теперь надо сделать шамань-шамань на вот
в восьми массивах длины 2.
А потом уже делать сначала вот
два указателя
с кув четвертый на вот этих вот
парах массивах.
Там пум-пум и пум-пум.
Ну вот, ну потом, а потом, соответственно,
вот на этих парах с ку-ку и нас с этой ку.
Вот.
Господи.
Вот знаете, вообще считается,
что шутка постов Дориной несколько раз,
она как бы перестает быть смешной.
Что-то по вам не скажешь.
После некоторой ретерации
она начинает наоборот наэмбирать.
Там пора разыграть другие краски.
Ну это да. Нет, ну нет, как сказать,
если она референ, это, конечно, да.
Но тогда она хоть в разных контекстах
должна возникать, что ли, я не знаю.
Вот.
Ну ладно.
Не, классно было бы так биатлоны, конечно,
выигрывать с одной и той же шуткой.
Ну.
Так. Вот. И наконец.
Классно было бы ICPC
выигрывать с одним и тем же кодом.
Ну.
Да, да, да.
Ну.
Нет, там хороший год был,
хорошие задачи такие, халявники.
Ну.
Так вот.
Значит, смотрите дальше.
Ну вот. И наконец,
когда мы берем совсем уровень, то есть мы уже
переходим в рекурсию, когда у нас
запускаются массивы длины 1. Теперь надо
сделать с ними шаманство, а потом
уже сливать. Но шаманство
с массивом длины 1 сделать
очень просто. Это шаманство заключается в том, чтобы
ничего не делать, сказать,
что все в порядке.
То есть в результате
мы получаем, что на самом деле,
как избавиться от рекурсии, это очень просто.
Надо просто научиться вот не так
переставлять элементы, а сразу
вот таким образом.
Обратите внимание.
Просто вот таким образом переставляем.
А потом после этого
ну, соответственно, значит
сливаем.
Да, теперь вы искать вопрос.
Как переставить элементы вот таким
образом?
Чтобы получить ответ, на самом деле давайте просто
запишем эти индексы
в двоичной системе счастлей.
Ну, у нас 16,2 в четвертой,
поэтому пишу 4 бита.
0,0,0,0. Тут
1,0,0,0. У четверки будет 0,1,0,0.
Так, тут у нас 12.
Это будет у нас сколько? Это будет 1,1,0,0.
Тут будет 0,0,1,0.
Тут будет 1,0,1,0. Теперь
вот можете пока
угадать, как я так быстро
пишу.
Ой, ой, ой, ой, ой, ой.
Ой, ой, ой, ой, ой, ой.
Вы пропустили? Нет.
Нет.
Нет, подожди.
Это просто же не в первый раз.
Высказите, не запомните.
Чего, чего?
Нет.
Нет, у меня все сошлось. Я ничего не пропустил.
Да?
То есть, обратите внимание.
Просто если вы причитаете то же самое справа-налево,
то это будет число 0,1,2,3,4,5.
Нет, справа-налево это будет 15,
7, 11, 13.
Нет, я имею в виду, каждый из этих чисел
вы причитаете. Вот возьмите биты.
Не слева-направо причитайте, что вот тут был 12.
Справа-налево. То есть, 0,0,1,1.
И это тройбан.
И, в общем-то, ничего удивительного
в этом нет. Потому что, по большому счету,
что вы сделали? Вы отсортировали
числа по младшему биту.
Сначала четное, потом нечетное.
Второй параметр.
Второй по младшести бит. Потом третий, четвертый
и пятый.
Ну, собственно, ничего удивительного.
То есть, с тем же успехом вы могли просто взять
четырехбитное представление этих чисел,
развернуть их и отсортировать по ним.
Или, что то же самое,
для каждого числа
просто сказать, вот у меня есть число,
давайте я его четырехбитное представление разверну.
Вот у меня было пять.
Вот я его развернул, у меня сколько там получилось?
Отлично, значит, здесь должно стоять десятое число.
А на десятой позиции,
кстати, пятая.
Очень удобно, правда?
Невероятно.
Вот. В результате
это приводит нас к тому,
что наш супер ФФТ
превращается в следующее.
Вот, значит, смотрите.
Так.
Так.
Вот.
То есть, в результате
магия работает так.
Значит, можно сделать так.
g меньше n плюс g.
Значит, пишем так. int
rev g равно
reverse
reverse
bits
от g и n.
Тут обязательно надо просто по числу g, вы же однозначно не скажете,
сколько в нем bit, да, потому что
ведущие нули, не понятно, сколько ведущих нулей вам надо.
Вот. Поэтому пишем reverse bits.
Но это функция, которую там можно самостоятельно реализовать.
n.
А без разницы, можно так и так.
Ну, просто вы там в форе будете писать
плюс плюс k, или n делить равно 2?
Можно писать n хресь хресь
равно 1.
Когда мы начали функцию
передавать n, а
когда статистически. Ну да.
Ну вот. И дальше
то есть, каждую пару надо посвапать.
Тут применяется такой классический лайфхак,
что если g меньше rev g, чтобы два раза не свапать,
то пишем свап.
Вот. Все.
И никаких
этих ваших рекурсий.
А reverse bits
это что?
Чего? Чего не так?
Reverse bits это что?
Это
взять битовое представление
вот этого числа, log n bit
и развернуть и записать его bit в обратном порядке.
Самому написать или там есть что?
Нет, самому написать, да.
Сишность функции я такое не знаю.
Ну вот. Чисто в этом был вопрос. Есть ли что-нибудь уже?
Нет. Ну, если бы я знал,
я бы, собственно, тут какую-нибудь такую функцию не писал.
Ну да.
Так вот.
Значит, в результате. Что теперь надо делать?
Теперь надо идти
по... Теперь надо...
Теперь надо сливать. Теперь пишем
for int l равно
2. Значит, будем сливать массивы длины l.
Из двух массивов
по l пополам. То есть, работать это будет вот так.
Вот.
Ну, напишу пока как понятнее.
Ой, ну, господи.
Пока так напишем, потом можем и...
То есть, видите, чтобы написать вот эту оптимизацию.
Мы же тоже там заморочились, да?
Ну, и теперь идея такая.
Начнем, пишу так.
Ну, давайте так. Я вот могу написать.
Скажите, пожалуйста, вот этот цифровар, он...
Он сделал всю работу, он нам оставил массив, как мы хотели.
А че bit.vg?
Да?
Ну, вот.
Так, ну, во-первых, надо изобрести q,
с какой степени у нас тут будет.
f, c, q.
Типа k-not.
Значит, оно будет равно у нас.
Понятно. q.
Значит, for int.
Вот я так сделаю. l, l.
Равно, допустим, l, l, l.
Нет, равно, но n.
l, l больше, чем l.
Диф равно 2.
cq уносит равно cq.
Откуда я это взял, да?
Смотрите, давайте разбираться.
Почему вы не заведете?
Потому что, смотрите, давайте посмотрим,
с каким q я должен сливать вот на каждом уровне.
Почему вы не будете его пересчитывать
просто на каждый раз, уменьшая цифру,
картриджа?
Нет, я так и буду делать.
У меня есть цикл, надо вычислить еще.
Это как бы у нас по-моему лог не выйдет.
Его лучше вычислить, мне кажется, во внешнем цифре,
а потом просто делить каждый раз.
Это не принципиально,
потому что это лог квадрат действий.
А бит мы разворачиваем из логерита?
Да.
Вот этот первый цикл, он dn.
Изначально мы развернем в одну сторону,
а потом развернем обратно.
Нам dn делен надо нужно идти, нет?
Нет, то почему?
Сначала мы сливаем,
сначала мы получаем под массивы длины 2
из-под массива длины 1,
потом под массив 4 из-под массива 2,
потом 84, потом 16.
В конце мы получаем массив n из-под массива длины n пополам.
Теперь давайте смотреть,
сколько раз я это q должен
возводить в квадрат?
Если у меня l равно n, то нисколько.
Если l равно n пополам,
то видимо в два раза, чтобы у меня qq получилось.
Потом n в четвертой будет
в четвертой и так далее.
Вроде все правильно.
Это указатель
на, так сказать,
после конца массива.
Значит, смотрите.
Работает теперь будет так.
Вот вы тут спрашивали, зачем st?
Я буду говорить
st равно a
st равно a,
st не равно агент,
st плюс равно, соответственно, l.
Будьте здоровы.
И поехали.
Ну и теперь поехали.
Указатель mid
значит у нас будет равен
к чему у нас там равен?
st плюс l пополам.
И дальше можно написать f звездочка
с
c
что?
А какой надо?
Ну я не знаю,
а вот
а вот тут
а вот эта строчка
вообще тогда?
А за такое вообще банда.
Вообще
без объявления войны причем.
Мы еще и воюем.
Просто паром по голове
и все.
Паром по голове.
Так вот.
Здесь я могу просто
пипастить.
Смотрите.
Это нормально,
потому что мы тут сейчас
переписываем.
Я таб жму.
Вот я вот так выделяю, жму таб.
Вот, пожалуйста. Могу нажать shift таб,
оно двигается назад.
Чего?
Пожалуйста.
Вот.
Ой, свет там
выключить.
Ага.
Ну l это
длина подмассива,
корректного подмассива, который мы сейчас
хотим получить.
Слив подмассива, длина l пополам.
У меня есть корректная
массива длины l пополам,
я хочу из них получить корректная подмассива длины l.
Что такое корректная?
Вот в этом смысле.
Потому что еще раз.
Что у нас делает по всей рекурсии?
Рекурсия
немножко в другом порядке,
я если бы представлял
элементы вот таким образом,
потом из каждой пары элементов делал格ой то массив длины 2
с помощью такого слияния.
потом из каждой пары соседних object
делал этот массив длины 4,
но потом 8 и 16.
Немного не в таком порядке.
Получалось, что сначала делала все тут,
потом все тут, но
давайте делать послой,
сначала все массивы длины 2,
потом все массивы длины 4,
вот я утверждаю, что ровно
по 115 строчки явно что-то не так, как мы хотим
почему?
потому что мы единицу на два делим
это L
нет, смотрите, вот единица, вот L
видите отличия?
в цвете, да?
нет, в цвете тут вот эта штучка еще, видите?
код, который g меньше, чем refg
мы переставляем, работает
но потому что
мы просто внимательно посмотрели
на то, каким образом переставляются элементы
на нижнем уровне относительно верхнего
и обнаружили, что
на месте
на позиции g
там, где было ожитое, становится
refg
мы так обнаружили
почему Q нигде не использована?
что?
Q, да?
да
поэтому да, правильнее, на самом деле, и тут
давайте вот, чтобы это подчеркнуть
давайте везде тут CQ
назовем
это будет
Q в степени
2 в степени N
ну это
Q в степени N поделить
на L я бы сказал
на что, чувак, где?
в 113 строке
нет, ладно, N пополам поделить
в 113 строке
CQ возводится
в квадрат, все нормально
мы убавили в квадрат
да
потому что у нас
на каждом инкурсивном запуске
вы бы передавали QQ
то есть Q в квадрате
теперь мы говорим, что если мы сейчас
перешли с уровня N на уровня L
то значит, сколько раз мы делили N
на 2, чтобы получить L, мы должны были
Q возвести в квадрат
вот чем мы это делаем
чем мы и занимаемся
вот
так что вот в принципе
таким образом можно это написать
как было правильно замечено
эти лишние цикушки можно заранее вычислить
это тоже даст маленькое ускорение
можно что-то там
ну там разные варианты
если вы делаете по простому модулю
то у вас с точностью никаких проблем нет
если делаете в комплексных числах
от long doubles, то там с точностью
какие-то проблемы есть
ну а сколько проблем?
ну скажем так, есть практическая рекомендация
желательно фурия адекватно работает
если у вас там итоговые коэффициенты
где-то 10 в 11 и 10 в 12
если там изначально
дал что-то порядка 1000, то вообще нормально
ну да
ну все
но если там больше коэффициентов, то значит вам придется
принимать какие-то меры
что, то есть если коэффициенты больше 1000
то у нас даже long doubles никак не помогут?
если больше 10
ну тогда да, но сами по себе
нет, если при этом еще и длина массива, то есть конечно большая
то есть если вы перемножаете
миллионы
многочлены там
числа порядка
больше чем 10 в кубе, то да, у вас могут быть проблемы
то есть на long doubles, где здесь в кубе
должно быть какая-то проблема
ну вроде как да
откуда взялось 10 в кубе?
ну то есть А3
предположим, что у тебя все коэффициенты порядка 10 в кубе
и длина массива
10 в шестой, тогда и то коэффициент
в перемножении многочленов, мы же да
напоминаем, мы перемножение многочленов
все это делаем, оно получается сколько?
у вас там 10 в шестой раз, получается 10 в кубе на 10 в кубе
и того 10 в двенадцатый
по грамм застава
ну вот
ну да, нет
просто в конце у вас получится
ну допустим вы перемножаете
целый многочлен на целый многочлен
если вы делаете там в комплексных числах
long doubles, то у вас и получится в конце
какие-то комплексные long doubles
и в идеалах кажется, что они должны быть близки к целым числам
поэтому там в конце
все что вам будет делать, это их как-то округлить
ну вот утверждается, что если
итоговые коэффициенты будут больше 10 в двенадцатый, то в округлении
могут возникнуть проблемы
то есть там погрешность будет чуть больше, чем
хотелось бы
у нас просто прописают задачи
ну вот
а саму куму вычисляем
с помощью
синусов и косинусов
ну да, ну в комплексных числах
да
ну или там
по модулю какого-то
да, чего?
у нас в итоге порядок
нам еще свалпать надо
после этого
зачем нам кого-то свалпать
что с ними?
у нас ну плюсак
просто прикол
напишите biginteger, где нужно написать их вот
и еще куча разных методов
и чтобы это нормально там
вводить-выводить, видимо придется
это делать в каблах, потому что по модулю
супер неприятно хранить
почему неприятно по модулю?
да
по модулю или чего, не слышите?
по модулю
или в комплах
ну в большинстве случаев в комплах пишут
а почему?
потому что это универсально
а еще они постоянно работают
да, но просто по каким-нибудь модулю
проблема такая, что
если писать по модулю 998
244353
теоретически можно, но
только если вы гарантируете, что у вас все коэффициенты
будут меньше
если будут, то вот пожалуйста
тогда это будет даже хорошо
работать
чаще всего это не совсем так
впрочем, эта проблема на самом деле конечно
решается с помощью китайской теории
об остатках
ну в плане, сделайте два FFT по двум таким модулям
такого порядка, скомпонуйте, возрадуйтесь
вот
вот там да, начинаются подобные
приколы, а как это считать?
ну это другой вопрос
по модулю
ну просто из такого
да
ну вот, так, ну все
так, ну в общем да
можно наверное еще какие-нибудь версии допиливать
но вот основная суть такая
это вот что касается
самого FFT
если тут какие-то вопросы
оценку чего?
разговор зашел о том, что
если мы вычисляем в комплексных
лонг-доблах, то у нас проблемы есть
проблема в том, что
как бы итоговый ответ вы получите не точно
ну по умолчанию, потому что откуда вы
ну давайте вспоминать, откуда вы такое
кумистическое возьмете вообще?
найдите такой корень из единицы, да
к сожалению, в действительных числах такого нет
но он есть комплексно
не, он может быть в простом
либо вот мы говорили
или по простому моду, или еще один
ну вот
есть комплекс
и проблема
в чем проблема?
ну проблема в том,
что когда комплексный числа
от лонг-доблов то у вас будет не точно
то есть ответ итоговые коэффициенты
переполнения будут у вас не 5, а что-нибудь там
4, 9, 9, 9, 9, 9, 9
9 умножить на 0, 0, 0, 0, 0, 0
сколько-то там
что мы с этим делаем?
ну по дефолту округляем видимо до ближайшего
действительно, вы добавляем 0,5
А если у вас будут слишком большие дефиценты, то как бы могут быть проблемы.
Кстати, а можно использовать тригнометрические всякие штуки, типа синусумы, это будет...
В смысле?
Ну, типа в итоге выразить просто синус с угла плюс косин с угла.
Да, сейчас, не понял.
Нет, ну если вы там с шишами...
Чтобы работать с углами, а не с дублами.
Но, как тебе сказать...
Нет, если ты напишешь свое там поле расширения комплексных чисел,
там расширение действительных чисел соответствующим корням, то можно.
А слава богу, сейте его и написать, да.
Нет, хотя, в общем-то ладно, у меня в моих внешних бильярдах что-то подобное сделано, это да.
Не для произвольного Н, конечно, только для конкретных, но там...
Но гадость там та еще.
Просто там, когда начнешь такое писать, там у тебя свое поле, да, то у вас есть маленькая проблема, что...
А нет, здесь никаких проблем не возникнет, здесь просто вычисляем и все.
А нет, проблема возникнет, потому что если ты напишешь просто Q и будешь рассматривать уркновечен,
то тебе придется каждое число хранить как линейную комбинацию соответствующей степени и кушки.
Ну, мы-то стараемся забежать.
Нет, а это просто в явном виде хранить не поможет.
Поэтому нужна вот просто мистическое число, которое работает.
То есть что значит округлить до ближайшего действия?
То и значит.
До ближайшего целого.
От целого?
А, ну в смысле, да.
Ну если у нас целые коэффициенты были, то мы округляем до целого.
Да, ой, да, да, да, все.
Все, ребят, все, я... Да, да, да, да, да, я и вообще все, а сегодня еще...
Ночью сегодня я провел летящим из Стамбула, собственно, на самолете, так что да.
Так что да, я сегодня...
Спасибо.
Спасибо за понимание.
Вот.
Так что да.
А, ну да, я вас еще и предупреждал.
Да, вы держались.
Да, да, да.
Ну не то, чтобы я держался, в общем-то, да.
Так, ладно, еще тут вопросы есть какие?
А дальше что?
Дальше?
Ну следующий блок начинается как-то...
Как это развернуть?
Вот теперь смотрите, вот просто можно...
Нет, по идее можно... Тут задача такая, вот у нас есть FFT.
Жил бы многочлен, размеры степени двойки, надо получить по нему значение в точках.
А теперь обратная задача, данные значения в точках надо получить коэффициентами.
Кажется, что эту функцию можно даже не переписывать, куда другое передать или там что-то такое.
Ну вот, тут как бы два момента, да.
По идее, конечно, вот этот код явно выглядит так, что можно его, конечно, легко развернуть.
Кстати, рекурсию надо убрать.
Можно посчитать, ну, значение на A, ну, значение на B, и потом перемножить, да.
Ага, а потом для значения на C обратно сделать.
И все это даже не для N2N еще сделать, чтобы там про запас было.
Давайте вот этот...
Ну это просто, это эти все детали из прошлой лекции, которые я сейчас опускаю.
Да, еще нужно довести до степени двойки каждой задачей, да?
Да.
Да, это святое.
До степени двойки нам прям жестко принципиально.
Так вот, казалось бы, как делать FFT?
Да, можно просто развернуть этот код.
То есть там сначала вот эти форы в другом порядке делать, да.
Там с уровня вверх, уровня вниз.
Вот это вот преобразование заменить на обратное, да.
В принципе, можно развлечься.
А потом в самом конце еще вот эту вот штуку забабахать.
Но, оказывается, этого делать не нужно.
Почему это делать не нужно?
Ну потому что смотреть.
Давайте внимательно посмотрим.
Сейчас мы...
Так, давайте временно уберем экранчик и снова позанимаемся алгеброй.
Лигейной.
Вот.
Потому что смотрите, чем мы...
Ну как бы как всегда, глобальный вопрос.
Чем мы вообще тут занимаемся?
Скажите, пожалуйста, мы уже не успели обсудить, как разворачиваться?
Э-э-э, нет.
Ну, мы обнаружили, даже если на уровне рекурсивном, что в принципе это явно-то как-то делается.
Вот.
Это все, на чем мы остановились.
Сейчас мы обсудим, как это делается на самом деле.
Потому что смотрите.
Что такое FFT?
По большому счету, FFT, как следует из предыдущего обсуждения, делает следующее.
Оно берет вектор...
А 0, а 1, а 2, и так далее.
А, n-1.
И домножает его на матрицу.
Какую?
А вот такую.
Как говорится?
Как говорится?
Как говорится, какую на матрицу Вандермонда?
Вандермонда
Мы уже в прошлый раз упоминали такую фамилию.
И вас на линале тоже должны упомянуть такую фамилию.
Ну да.
Да, мало кто знает, но если ходить на матрицу...
Если ходить на матрицу Вандермонда, когда у нас...
У нас нет фамилия.
И если у нас нет фамилия?
Да.
А если у нас нет фамилия?
И у нас нет фамилий.
Так.
но если ходить на линал можно много полезного узнать
чего на все оси из маленьких
вау
это называется испорченный телефон но знаете
вот такая вот красота теперь у нас есть задачка эту матрицу теперь надо обратить
что за каламбуры пошли
ой и потом что-то омская птица уже умерла много лет назад а вот какой-то сайт который
специализировался на подобного рода каламбурах там я не знаю там знаете это там надежда крупская
вера брешнева там вот это вот все так понятно и он стал вот тёмскую птицу так как обращать
такую матрицу вот действительно такая вот небольшая интрига так а что давайте повесили
давайте обратим эту матрицу чем вообще париться мы бы чули на ла не знаем что ли значит смотреть
давайте для простоты я сделаю матрицу поменьше давайте матрица длины 5 я думаю это будет максимально
наглядно но мы же можем себе вообразить корень пятой степени из единицы правда
6 9 12 4 8 12 16 так ну давайте вспоминать как мы тут обращаем 1 1 1 1 1 так что там у нас дальше будет
так ну давайте вычитаем единицу так так значит тут будет смотрите 1 0 0 0 и тут везде будет
минус 1 минус 1 минус 1 минус 1 так что будет тут да это мало связано с тем что реально
почему ну нет ну просто давайте просто обратим матрицу что бы нам ее не обретить
потому что если вы перемножите скажем вот этот вот столбец на этот вот вектор то это
абсолютно то же самое как вы многочлен с такими коэффициентами подставите в качестве т куб кубе
ну потому что получится а 0 плюс а 1 умножить на кубе плюс а 2 умножить на куб 6 ну и так далее
но потому что я вот взял вот эту строчку для примера там если вот эту строчку домножите
подставите к у второй если эту ку и так далее так что тут все очень просто вот при атаке
соперника да мы так вот так так вот так я вот вывесили вот красота правда так
так что там у нас будет дальше так ну теперь только напомните мне я имею право делать то
же самое со столбцами не а в чем проблема то что приобщение матрицы они имеют право там еще и со
столбцами то же самое делать чего с нюансами нет почему там вот смотрите механизм обращения
матрицы был вроде как такой я значит просто делаю значит добиваюсь того чтобы это матрица
стала там единичной при этом и начинать единичной матрицы делаю ровно те же преобразования тогда
когда тут будет 1 и дд дд тут будет соответственно то что мне надо работает это работает это за счет
того что я как бы на самом деле для того чтобы вычесть там строчку из какой-нибудь другой строчки
я должен там домножить это там матрицу слева на какую-то там фиксированную матрицу я домножаю это
домножает вот у меня почему-то жуткое ощущение что вроде как должно существовать вроде то есть так
вроде можно без нюансов но я не знаю если существует смотрите существует матрица на
которой давно же вот это слева и получится как будто я просто прибавил ко второму столбцу
первой то вроде как этого должно хватать вот ну вот так сейчас какие ксы чего какие ксы не понял
так ну ладно так ну ладно если так ну ладно нет то в принципе ладно на самом деле нам не сильно
глобально можем как бы столбца со столбцами ничего не делать а можно просто заметить что
здесь все делится на q-1 неплохо так правда давайте значит тут будет один один тут я побольше
нарисую так тут будет 1 0 0 0 0 тут получится так минус 1 делить на q-1 тут получится 1
делить на q-1 ну и слава богу 0 0 0 тут получится ладно ну-ка минус 1 делить на q-1 минус 1
делить на q-1 минус 1 делить на q-1 0 0 0 0 0 0 0 так что получится тут ну тут получится что-то
посмешнее так тут получится 1 q плюс 1 так давайте давайте так сказать 1 1 плюс q 1 плюс q
плюс q квадрат 1 плюс q плюс q квадрат плюс q в кубе да да так тут у нас давайте 1 плюс q
тут получается 1 плюс q плюс q квадрат плюс q в кубе тут 1 плюс и так далее плюс что штутку
в пятый 1 плюс и так далее плюс q ну соответственно седьмой да так тут у нас получается 1 плюс q плюс q
квадрат так тут q в пятой чего что не так но вот пока так что не так где я пока как бы
каждую строчку поделился чем-то на q-1 возможно зря я это сделал но вот так не одно просто уже
интересно просто что получится так 1 плюс и так далее плюс q 11 1 плюс и так далее плюс q у 15 так
спрашивается так как-то переча это обращать но теперь кажется пришло время что-то по вычитать
так вот давайте я может быть даже не буду стирать а давайте я попробую просто вычесть
вот например вот эту строчку из допустим вот этой что будет тогда ну во-первых здесь мы поубиваем
единичку здесь мы убиваем 1 плюс q здесь у нас сумма идет от куб кубе здесь у нас сумма идет от
q в четвертой да и с третьей строчки я вычел пока вторую и у меня получилось но здесь получается 0
здесь получается минус 1 делить на q минус 1 вот теперь значит да не будем значит да не значит
попробуем не бежать тут может быть действительно где-то впереди паровоза а вместо этого скажем
следующее так но давайте вот допустим попробуем теперь из этой строчки из четвертой строчки
по вычитать первые две хотя нет правильнее было сделать немножко по-другому правильнее на самом
деле да сначала вот давайте из четвертой строчки сейчас вычтем третью что у нас получится тот
получится q в кубе тут получится q в шестой плюс q в седьмой тут получится q в девятой плюс q в
десятой плюс q в одиннадцатой а тот получится 12 13 14 15 вот так что правильно пока или нет
да ладно что-то да что-то не знать как раз еще раз был порядок в смысле порядок 5 какой
порядок но сначала мы из третьей строчки вычтем вторую потом мы решили сейчас вот из пятой
строчки вычислить четвертую нет ну как сказать там будет это из цикла надо угадать ответа
потом обнаружить что он всегда заходит вот так вот ну ладно на самом деле да если вы внимательно
посмотрите это и угадайте закономерность то явно будет получаться вот что-то такое смотрите
q 6 плюс q седьмой и тут вот так значит тут у нас что q в 8 плюс и так далее плюс q в одиннадцатой
а тут на самом деле будет 0 и тут будет минус один делить на q минус один вот спрашивается
так что у нас теперь можно сделать слушайте а то прям точно нельзя столбцы друг с другом вычитать
а вот я вот пытаюсь вспомнить а какая она на самом деле но да но как сказать если вы зафиксируете
конкретное куда там будет больно но фишка но в данном случае мы должны начать пользоваться
тем что кув пятый равно один прочим ладно ладно давайте действительно забьем на это так просто
видимо не получится придется просто подумать что ж там должны быть за столбцы так изе но то на
самом деле просто магия на самом деле оказывается ну тут разные магии бывают вот одна из магии
звучит так да вот например давайте создадим ту же самую магию от кув минус 1 вот давайте я
вот возьму вот эту вот матрицу один да ку ку квадрат один ку квадрат ку четвертый
но вот но нет но как сказать знаете я просто не очень люблю это из цикла заветим что вот
это вот работает но как сказать получается смотря что мы там дальше должны делать дальше
возможно вот эти строчки должны на ку как-то поделить потом что-то тут вычесть там но может
а не но да тут вообще на куб придется а тут еще он это на кув кубе какие-то делить носим гады
ладно значит давайте действительно значит очень хочется попытаться действительно как-то да
множить эту матрицу на вот такую на абсолютно то же самое только вместо ку я подставляю кув минус
1 вот так это будет ку минус 2 кув минус 4 и так далее ку минус 2 и минус 1
что получится получится какая-то мистическая матрица dnn где внимание dgtkt равно сумме по всем
l от 0 dn минус 1 значит q в степени g умножить на l умножить на q в степени чего минус l умножить
на к согласны или что то же самое это сумма л так степеней числа q в степени l минус
к ладно жи минус к вот чему это равно ну как известно 1 плюс z плюс z квадрат плюс и так
далее плюс z в степени n минус 1 у нас равен к чему ну вот то есть это равно z поделить на z
минус 1 известная формула из 7 класса ладно из 8 ну максимум вот ну соответственно значит это
равно пишем q в степени g минус к соответственно в степени n минус 1 поделить на q в степени g
минус к минус 1 но мы знаем что q в степени n равно 1 правда да получается это равно 1
минус 1 поделить на q в степени g минус к минус 1 равно 0 буга гашу не так а шоу а шоу такое
а шоу формула не работает что ли ой смотрите классно мы сделали круче мы искали матрицу чтобы
домножить на вот эту и получить единичную а нашли матрицу что домножили не получили 0 да
какой безобразие ну да действительно заметим что это формула работает естественно только
в том случае когда z не равно 1 то есть это значит этот переход тоже будет равен когда q в степени
g минус к не равно 1 а это происходит очевидно тогда и только тогда когда g не равно к то есть
получается что везде кроме диагонали будут нули это уже похоже на правду правда вот а если у нас
а теперь давайте посмотрим что если у нас d же житое но даже житое тут все просто сумма от
нуля до n минус 1 значит q в степени g l умножить на q в степени минус g l ну шлеп шлеп 1 в общем
короче n то есть мораль то есть получается d н н это банально единичная матрица размера n умноженная
на n то есть обратная матрица к ушкам это такая же матрица от q минус 1 только еще надо поделить
на n да ну ков минус 1 ну ку в степени минус 1 да какая-то матрица у которой я вот тут написал
вот оказывается чему вот к сожалению нам не удалось избежать заметим что но но что поделать
ну потому что мы часто перемножили две матрицы доказали что эта матрица состоит из
н-ок на диагонали и нулей в остальных местах мы вот это аккуратно доказали вот и все приводит
нас к это к следующему вот теперь заметим то есть нам нужно чтобы сделать fft получается нам
нужно все домножить на матрицу только не завище не от q от q в минус 1 но заметим что q в минус 1
это тоже хорошее число тоже n степень равна единице а n пополам той степени единица не равна правда
то есть это означает что она тоже может быть передана fft как параметр в результате
ну число q в минус первой обладает теми же хорошими свойствами что и q ну то есть что
не военная степень равна единице n пополам ты не равна это это означает что как бы если я
могу q передать fft вот вот вот fft то я и q 1 делить на q тоже могу передать ну то есть q в минус 1
ну вот в результате обратно fft инф fft на самом деле то есть если нам передает q ну нам понятно
параметр того какие значения в каких степенях какого ку нам выданы то идея очень простая мы
запускаем fft от a то есть просто от 1 делить на q то есть q минус 1 и не забываем
потом поделить на n все
вот понятно что не так ну это мы взяли но просто 1 делить на q скорее всего у вас не получится
в твоем поле единица ну а единица делить на q это обратный q элемент в этом поле да
потому что мы обнаружили что-то обратно там от матрицы та же самая матрица с q в минус первой
это не совсем обратная матрица давно жена на n
но мы не хотим здесь получать матрицу мы не хотим получить массив а домноженный на эту обратную
матрицу но да нет не на вторую матрицу она обратную к первой это но оказалось что обратная к первой как
у нас выяснилось это вот эта матрица только еще на n деленное а потому что если мы умножить это
будет д а д это е на н да поэтому чтобы получить но вот поэтому на самом деле вот можно вот скорее
так писать тоже кстати вполне универсальный низ от поля не зависит но ку в минус 1 ку в минус
первое что такое это 1 делить таку потому что мы кастуем единицу к полю f больше ничего не
делаем но правильно но я не знаю я не но как сказать я мне в чем-то на автомате ощущение что
инс на ку не на f не делится но нет это зависит конечно от перегрузки вашего оператора но
скорее всего это не будет работать потому что скорее всего там минус 48 делить на ваш f он
скорее всего не умеет вот но мне так кажется вот конкретно единицу он скастует но по-хорошему
до правильно конечно на самом деле написать f1 вот так ну статики но там какой-нибудь статическую
перемене почему статическая переменная с какого перепуга там типа завести статические
под 0 единицу и минус 1 нет ну почему либо завести либо get one тут какой-нибудь статическую
функцию написать как угодно это все не но ладно как ладно мы тут не самый формальный код ладно
если вам так удобно вот вам один делить на ку наслаждайтесь вот вот такой вот красота
и сейчас чего мы чего начали
ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да ну да
ну типа давайте ну давайте покажу просто как это теперь будет вред
значит смотрите работать это будет так вот если вы хотите перемножить два многочлена вектор
int допустим а и вектор int b я даже буду по константной ссылке передавать и допустим мы поверим что
их коэффициенты там итоговый не превосходят чего вам надо значит смотрите как-то тогда
будет выглядеть значит но на счет int n равно 1 как теперь перемножение многочлена выглядит
теперь так ну по и значит
вот ну находим ближе первую степень двойки которые не меньше ни а ни
да умножаем еще на два чала да спасибо теперь умножаем еще на два потому что нам запасом надо
помните да ну вот и конечно и теперь заводим собственную да давайте я так комплекс
long double cld значит заводим наша любимая массива cld c а равно new cld от n
ну и про цб еще не забудем
там да вы стояли есть тип комплекс это прям комплексные числа да чтобы они работали можно
подключить include комплекс но введение псевдонима на какой-то тип у нас такое не пока ставим у
using и using cld равно пожалуйста пожалуйста как пожалуйста как скажете как скажете у нас
вот такое да да да да да да да да да да да да да да да нет сайзов от массива он выдаёт
сколько байт в массиве. Это не динамия, в смысле, почему не делает.
Сейчас вот именно он же байтами выполняет, а у нас числа, у нас же не чары хранятся.
Какая разница? Спеца, да, внимание, но тут интересно,
в C++, в C++, ну обычно w и long w устроены так, что 0 кодируется полностью нулевым набором бит.
Чего? Чем, если что.
Сайзов СА и Сайзов СБ нормальны.
Сайзов не работает так, он назначает размер-оказатель.
Да, это размер-оказатель.
Пожалуйста.
А теперь смотрите, теперь в лице кушки, познакомьтесь, CLD-Q,
так, CLD-ang, ну, во-первых, так, ну, во-первых, вам не помешается статическая константа.
Во-первых, NP, во-вторых, у меня в визуалке ее как бы по-included нормально не получается.
Почему?
Это универсально от всех тестирующих, от всех компиляторов, от всех тестирующих системах.
Ну, я под этим засылал просто во что угодно, и оно везде работает.
Молодцы.
Ну, молодцы, вы используете, давай так, вы используете так, я вот использую так, в общем, на вашу усмотреть.
А хос L, это в лонгтаблак она считает?
Она бы без этого не посчитала в лонгтаблак.
Не, ну, посчитала бы, но я вот люблю QSL, чтобы просто для явности.
Знаете, в дзене одного языка, как говорится, явное лучше, чем неявное.
Ну, это означает, что это примерно как бы едино для всех, внутри всех вызовов этой функции.
А функции тоже есть.
То есть он каждый раз себя заново не пересчитывает?
А хос L будет вызываться только один раз, да?
Так вот, вызываем Q, и теперь, смотрите, немножко магии.
Ну, во-первых, значит, запускаем FFT от C, A, N, и что-то там еще, что-то там это Q.
И то же самое от B.
Вот.
Ну, здесь, чтобы лишний массив не плодить, вот легче уж так написать.
После этого FFT от C, A, N, значит, 1.0 делить на Q, дай бог, чтобы для комплекса это работало.
Ну, для конкретного комплекса можете вообще, на самом деле, вместо этого написать тут вот.
Вместо этого можно написать Q.conj.
Ну, мало кто знает, но для того Q, который мы выбрали, обратные и сопряженные – это одно и то же.
Потому что модуль один.
Именно.
Да, это обратные FFT, да.
А, ну да, правильно написать.
Да, правильнее, конечно, написать, конечно, in FFT, да.
Да, теперь остается только перернать это.
Ну, ладно, может быть, правильнее.
Может быть, даже вот так правильнее написать.
Ну, просто размер реального произведения, он будет вот такой.
Ну и что?
Нужно просто потом селить ручьи нули и все равно удалить.
А ну так.
Может быть, так ледевые ручьи нули удалять.
Сейчас непонятно, почему мы не читаем ледницу.
Ну, потому что последний коэффициент имеет тут номера A.size-1 и B.size-1.
Произведение – это коэффициент, их произведение пойдет в коэффициент A.size plus B.size-2.
Что он был последним, поэтому мы тут пишем –1.
Нормально, нам никто и не гарантировал, чтобы А нет.
Вот, допустим, мы взяли произведение 9 на 9.
У нас мы получили 81.
Сами по себе 9 были размеры 1.
Когда мы переножили, то мы получили…
Мы перемножаем многочлены, а не длинные числа.
Хотите перемножать длинные числа – это значит сводить их в перемножение многочленов,
а потом развлекаетесь там с переносами.
Ладно, сейчас вы увидите.
То есть мы, обратите внимание,
перемножаем поле, но мы все, мы не заморачиваемся.
Ну вот, но здесь я пишу обычно что-то типа floor L от… значит…
Потому что мы прибавляем 0,5.
Да.
Если вы хотите округлять по математическим правилам
до ближайшего целого, то это вот да.
Нет, там есть какой-нибудь раунд.
Ну могли, а могли так.
Который под капотом делает то же самое, на самом деле.
Да, да, да.
Вот.
А, и самое важное.
А в мейджине там можно будет задержать какой-то большой мусор?
Сейчас.
Конечно.
Вот да.
Да, киваруешь.
В мейджине там может лежать какой-то большой мусор?
Большой нет.
Ну там скорее всего будет не сильно, ну там не сильно большой,
но понятно, что чем больше коэффициенты, тем возможно он будет и больше.
Если ты перемножаешь целые числа,
он у тебя только за счет неточности доблов появляется.
Поэтому он не сильно большой.
Ну типа он не будет на порядок больше, чем у тебя в целой, ну точнее вещественной части.
То есть если у тебя вещественные числа то же самое же.
В смысле?
Как ты...
Там небольшая проблема, что у нас прям конкретные проблемы с точностью могут начаться.
Ну в плане, здесь мы видишь плюс 0,5 и округляем вниз, а вещественных у нас не будет большой точности.
Мы не знаем как...
Что так, что так у нас точность теряется, потому что мы...
Ну в целых у нас так точность не потеряется, если они у нас не сильно большие были.
У нас Q это вещественное число.
Ну да.
И мы целые числа мы не жали на Q.
Да.
Да.
Но у нас из-за того, как с алгебрической точки зрения во второй устроена,
в идеале должны получиться целые числа,
если...
Ну да, целые числа.
Если мы не пролетаем по точностям, мы пролетаем.
Да.
Ну вот округляет вниз тот раунд, поэтому я вот не люблю использовать,
потому что я не знаю как он там работает для отрицательных чисел.
То есть там минус 3.5, он будет это в сторону минус 3 округлять или минус 4.
Так же он работает, он сам вот так написан.
Да, ну окей, еще.
Потому что ничего умнее там написать нельзя.
Знаете, в процентиках написали что-то более умное.
Знаете, там почему-то минус 20, 12 процент 7 не равно,
же 2 почему-то.
Потому что написали что-то более тупое.
Ну вот мало ли, может тут тоже, я же не знаю.
Так, ну ладно, короче.
Очень короче, перемножение многочленов выглядит вот примерно,
вот таким вот образом.
Вот понятна?
Так, ну это перемножение именно многочленов.
Значит, если очень хочется перемножить именно длинные числа,
то как бы это может выглядеть примерно следующим образом.
Ну давайте я вот предположу, что мне и передают основание.
Если так формально смотреть, то можно заявлять, что в плюсах
и деление в целых числах работает неправильно.
Ну потому что мы берем деление с эквалинием.
Да, мы берем целую часть, то есть у нас должно быть
деление с эквалинием вниз.
А если мы делим там отрицательное на положительное,
вообще не так, что такое.
Там получается просто мы делим два модуля.
Да.
Ну да, ну вот я и говорю, что если так смотреть, то у нас
деление с эквалинием ноль.
То есть по моду.
Ну да.
Ну у нас и модуль с эквалинием ноль.
Нет.
Ну типа если у тебя положительное число n-1 по модуле,
то это будет не минус один.
Ну короче, я имею в виду модуль, не очень понятно,
что значит эквалиния.
Ну да, но в общем, он работает в той же логике,
что и деление.
Он работает в логике, что если мы берем частное к нему,
то должно получиться само число.
О, да.
Я тут пока еще немножко магии написал.
Магия?
Магия.
Магия.
Ну ладно, никакая-то не магия, конечно, на самом деле.
Но могу бейс написать, надо.
Нет, ну если у нас тут бродят всякие ука, так что, знаете,
ОС.
Вот, ну ладно, я тут, конечно, всякие удаления ведущих
нулей я, конечно, тут не убирал, но это уже локальность,
это уже детали.
Это вы уже сами будете писать длинную рифметику, напишите.
Вот, а теперь начинается шоу.
Так.
Или начинается.
А какое шоу?
Разное.
Так.
Так.
Не, сейчас я, нет, я просто прикидываю.
Ну, просто, знаете, просто по FFTшку у нас куча блоков
на самом деле, того, что вообще можно делать.
Можно спойлеры, пожалуйста.
Ну, смотрите, так, что как минимум на вскидку надо.
Ну, конечно же, деление.
В общем, деление многочленов и деление чисел.
Вообще разные вещи.
Зато деление извлечения корня, это будет одно и то
же.
Деление многочленов и чисел – разные вещи.
Абсолютно.
Ну, значит, так, если вы делите многочлены и знаете,
что они поделятся нацелло, то да, это тогда одно и то
же.
За какую осень точка?
А мы числа сможем любые делить?
Ну, в поле.
Не, понятно, в поле.
То есть у нас там не будет никаких нюансиков.
Нет, ну как сказать, числа мы будем честно делить
со… Числа мы будем делить с остатком.
Точнее, а с остатком, b соответственно еще иногда,
еще столбиком до интересующего нас знака.
И многочлены будем делить, и числа будем делить.
Нет, нет, на этот раз нет вообще ни одно и то же.
Я пытался на гуглить, там было что-то очень странное,
там два деления, если у нас длины относятся вот так
или вот так, это я где-то на алгоритмике, по-моему,
такое.
Так, ну ладно, значит у нас алгоритмика разная алгоритма,
окей.
То есть там прям какая-то дичь, я…
Ну я понял, ладно.
Ну вот, по-моему, по модулю деления там есть еще всякие,
но, во-первых, надо узнать как-то, потому что…
Как там задачи, как задачи с помощью этого решать,
а задачи там бывают не тривиальные.
Вот тут на финале одна… Ой, извините про спойлеры.
Ладно.
Не.
Так, нет.
Ну все, ладно, симус я вам не обещаю.
Так, после деления что там еще будет?
Да, ну будут всякие, ну будут всякие, ну, во-первых,
там всякие задачи, всякие там мелочи типа там,
и нахождение действительно многочлена,
многочлена размера n в n уже на этот раз в произвольных
точках будет, будет, наоборот, интерполяция там.
Ну вот, ну, конечно, многомерная FFT там и так далее.
Вот это вот, это вот все.
И это, возможно, я еще что-то забыл, потому что я помню,
что у нас там много всего на эту тему есть.
Среди которых голосовали за FFT.
А какая разница?
Либо сейчас, либо… Не, Больтова я вас обрадую.
Да.
Закончим мы семестер на том, что, как бы, да, у вас
на это все будет шикарное домашнее задание.
Мы закончим на FFT.
У нас есть big integer, блин, от мещерина.
Вот отлично.
А я вам еще накидал, а я вам еще накидал контестик
на FFT.
Так что напишите один код и будете выпихать два контеста.
Кайф.
То, что надо.
У нас будет контест покучен на этом семесте.
Нет.
В этом семесте мы FFT закончим.
У нас будет контест на FFT.
Может я еще на строчке какие-нибудь задачи добавлю,
потому что, как выяснилось, что там на финалах могут
и задачи на сортировки давать.
Можно я на 19 декабря публиковать, пожалуйста?
Хорошо, публикую 18.
А куда дедлайн будет по домашней?
Ну, дедлайн, я думаю, будет сопоставить тоже с примерно
дедлайном, собственно, курса, потому что…
Будут ли там, на самом деле, ревьюшные задачи, я не уверен.
Дедлайна курса есть просто два.
Есть зачет.
А, зачет, зачет, конечно.
Так, ладно.
Итак, попробуем.
Давайте сейчас будем делить.
Итак, сейчас будет.
Так, вот теперь…
Так, ладно, кто тут спал, кто знает фурия,
наоборот, пришло время просыпаться.
Сейчас начнется магия.
Ладно, если в делении многочленов магия будет относительная такая,
то как бы там…
То потом, когда мы начнем делить реально числа,
вот там начнется…
То там уже придется вспоминать еще,
что вы там сейчас нам это анализе проходите.
А можно не надо?
Нельзя.
Рэд и Тейлора?
Ну да.
Ну, скорее формулам и Кларой она, если быть.
Сейчас как там это?
Сейчас там как-то остаток…
Пиано, пиано.
Нет, пиано – это просто ОАТ.
Есть там достаточно чем-то в более адекватном виде.
Вот.
Вот скорее он нам понадобится.
Но не волнуйтесь, там порядок максимум второй, так что не страшно.
Что, хэши чего?
Пиано.
Ой, пиано, форта.
Ой, Господи, так.
Фордебел.
Ага, ой, да.
Фордопал.
О, Господи.
Да, там томверда – это хорошо, конечно.
Так, ладно.
Ладно, давайте пока что-нибудь похалявнее.
Так, господа, немножко халявы.
Давайте смотреть.
Итак, это уже было.
Нет.
Сейчас мы с вами
будем делить
многочлены.
Ну, в идеале…
Ну, сначала мы хотим
поделить многочлены с остатком.
Но начнем мы не с этого.
Место деления
многочлены с остатками
мы будем делить многочлены
по модулю Q в степени N.
Итак, что означает
делить многочлены по модулю Q в степени N?
Фу, по модулю T в степени N.
Это означает, что, допустим,
у меня есть…
Там P от T равно…
Ну, ладно, A от T равно,
как всегда, там, A0 плюс
A1 на T плюс
A2 в степени T квадрат плюс
и так далее, плюс, допустим,
A, там, N-1
на T в степени N-1.
И вот,
на T в степени N-1.
И есть у меня многочлен B.
То же самое,
только до M.
Я очень хочу найти такой
многочлен C,
что A сравнимо
с BC по модулю
T в степени N.
Ну, что это значит?
То же самое.
A равно BC
плюс T в степени N
умножить на какой-то
мистический многочлен D.
То есть, допустим, меня интересуют
какие-то младшие слагаемые,
а то, что у меня там происходит
на N порядке, я сбиваю.
Но это, кстати, очень в стиле
как раз тех самых рядов Тейлора.
А?
Да, сравним многочлены
по модулю T, T в степени N.
То есть, все, что там, T в степени,
при коэффициентах...
Ну ладно, даже...
До чего?
А вот они разными длинными будут.
Но, на самом деле, с точки зрения
вот этой задачи,
мы вообще можем считать, что тут все одинаковые,
они тут оба до K, на самом деле.
На самом деле.
Вот.
Ну, потому что
в этом вот равенстве
будет выполняться, если вы
A к B и C добавите что угодно
умноженное на T в степени K
или T в степени K плюс 1
и так далее.
Равенство, правильным или неправильным,
от этого не перестанет быть.
Чего еще раз?
Ну да.
По факту так оно и есть, да.
А вот.
Теперь выясняет вопрос.
При каких A и B
такое C
вообще существует?
Давайте так. Всегда ли такое C существует?
Да, и при каких
A и B оно не существует?
Чего?
Ну да, если B равно 0,
а не равно 0, то очевидно такого C нет.
А еще,
это хорошо, да, это достаточно,
чтобы ответ не существовал.
Ну да, но тут бывает по-разному.
Ведь заметим, что
Б свободных членов
как бы больше, чем
А видимо.
Ну да,
но фактически да, если тут в начале
B стоит больше нулей, чем
А на самом деле.
Вот.
Но давайте так.
Давайте оговоримся, что
предположим, что B0
не равно 0, давайте сразу оговоримся.
Тогда я утверждаю, что C
существует единственно всегда.
Почему так?
Ну, например, если вы попробовали,
потому что на самом деле начинает работать
просто метод деления столбиком.
Вот чтобы это
продемонстрировать, давайте я сейчас
допустим скажу, что K у меня равно
опять 5
и поделю какой-нибудь там веселый многочлен.
Ну я не знаю, 7 минус 4T плюс
2T квадрат
плюс 3T
в четвертой минус
А все?
И поделю я его на какой-нибудь красивый
многочлен. Ой нет, я третью степень
произвел.
Плюс
5T в кубе пусть будет.
И минус 3T в четвертой.
А тут я напишу
что-нибудь типа 2
плюс 3T
минус 5T
в квадрате плюс 6T
в кубе плюс
Т в четвертой, чтобы уже совсем
не заморачиваться.
Значит, честно делим
как это работает.
Ну, во-первых, да, какой должен быть младший член
этого коэффициента? Ну, очевидно, такой, что
эта штука умножить на 2 должна быть
равна 7 без вариантов, правда?
Поэтому пишем
7
вторых.
В поле
рациональных чисел, допустим.
Ну, давайте
уж, чтобы понятно было происходящее
давайте.
Ну, делить по модулю 11,
не.
Значит, поехали.
Тут у нас получается 7.
Так, плюс 21
вторых Т.
Минус
значит, соответственно,
35 вторых Т.
А мы начали
делить с конца.
Господи.
Какой ты добрый, Миш.
Как мы додумались до этого?
Что?
Как мы додумались до того, чтобы делить столбиком?
Нет, чтобы делить с конца. Мы же так никогда
столбиком не делим. А вот чуть позже я вам
расскажу откуда мы это взяли.
А нет, может отчасти для этого я вам
сейчас свои собственные деления и провожу
деление столбиком. Чтобы у нас сейчас там
занавелись. Чтобы у вас
было ощущение, что, в общем-то, отделение классическим
столбиком и, в общем-то, нормальные
деления навещения мы далеко не ушли.
Смотрите. Тут 7 вторых.
Так, значит, тут я нарисовал,
вычитаем.
Так, 7,7, ну шлёп-шлёп мы этого
и добивались.
Так, минус 29 вторых Т.
Плюс
39 вторых Т квадрат.
Так, минус
16 Т в кубе.
Минус
13 вторых Т
в кубе.
Так,
отлично.
Так, дальше у нас должно идти
что-то при Т. То так, чтобы
домножить эту штуку на два, было вот это.
То есть, получается, пишем.
На самом деле, минус
29 четвертых Т.
Ну и тут получается
минус 29 вторых Т.
Так, что тут у нас дальше?
Теперь домножаем это на три. Получается
87 четвертых Т
в квадрате.
Так, что там у нас дальше?
Так, что у нас получается так?
29 умножить на 5. Это сколько?
Правильно. 145. Молодцы.
Очень активно.
Наверно. Может быть.
Так, значит, далее.
Домножаем на 6. Это то же самое.
Домножить на 3 и поделить на 2.
87 вторых.
Т в четвертый.
Т в пятый мы не пишем,
потому что оно отправляется в модуль.
Понятно, да?
Да, но на самом деле,
если вы аккуратно помодитесь,
вы обнаружите, что действия, которые мы делаем,
они более-менее вынуждены.
То есть, мы вынуждены
нашли этот коэффициент.
А дальше все, что остальное
должно делиться на Т, поэтому следующий коэффициент
тоже оказывается вынужденным.
Так, значит, тут у нас получается шлеп-шлеп.
Так, 39 умножить на 2.
Сколько?
78.
Так, 78 плюс 87.
165.
Так, что у нас тут?
64, 145.
Так, ага, 200.
Минус 209 четвертых Т в кубе.
О, соточка!
Ну ладно, 50.
Не, видите, они такие уж убойные вычисления
получаются на самом деле.
А почему у нас
87 вторых у нас, а не 87 четвертых?
Это четвертых.
Так, дальше.
Так, значит, теперь 165.
Что у нас дальше получается?
165 восьмых.
Ну все логика понятна.
Не, ну что, ну давайте хоть одну
интерацию-то. Ну тут, видите, тут
сейчас быстро это все закончится.
А оно там получилось Т в пятой,
поэтому его можно не вычислять.
Ну, то есть там просто тут, на самом деле
как бы, можно сказать, за этой стенкой
там еще какие-то там Т в пятой водятся.
Но с точки зрения по модулю
они нас не волнуют. Нам главное, чтоб тут
остался, нам
главное, чтоб тут нолик остался.
Значит так, пишем
165 четвертых Т в квадрате.
Так, тут у нас что? Домножаем
на 3. 165 умножить на 3. Сколько?
495.
Вот, да, это я умею, да.
О, 165 умножить на 5.
825.
Браво.
Так.
О. Вычитаем.
Так.
Ну, как всегда, 209.
Так, сколько там? 418
плюс 495.
895 плюс 18.
913.
913 8Т
в кубе, минус
1220
куб.
Да, правильно.
1225 восьмых Т в четвертых.
Все нормально.
Ах, да, действительно.
Ладно, просто 225.
А, тоже чушь, да.
Да, минус
400 плюс. В общем, 425
и плюс. Да, все нормально. Вот так.
Чего? Где?
Где вот
вот тот?
913 8.
Вот здесь?
Ну, минус 209, минус
455.
А?
Столбик такой все равно.
Почему мы его воврат?
Потому что, я же огласил задачу.
Мы как бы делим по модлю
Т в степенька. Это не то деление столбиком,
которое мы обычно делали.
Мы другую задачу решаем.
То, что вы сейчас делали, можно было делать в обратную сторону.
Что значит в обратную сторону?
Нет, погоди, погоди. Мы не многочлены делим.
Мы не делим многочлены с остатком в классическом смысле.
Мы делим многочлены по модлю
в степенька. Это принципиально другая операция.
Пока. Поэтому как бы
мы ее делаем вот в
Ну, как, Падик?
А как она будет с другой стороны работать?
Я вот поделю четвертую степень
Получу там три, что-то вычту.
Тут будет меньше четвертой степени, а тут четвертой степень.
Что вы дальше делать будете?
Напишу ноль, и выиграл.
Ну, вот.
А нельзя. У нас тут, видите,
об этих временах у нас остатков нет.
У нас есть вот этот вот аут
в той степеника.
Ну и последний член, который у нас остался,
пишем, минус
913 шестнадцатых.
Вот, давайте. Финальное.
Чего там 405?
425.
Там же был
минус сверху.
Чего?
Тут было минус 400,
минус 408. Тут мы прибавили 825.
Получилось плюс 425.
Да, это 825.
Так, ну поехали.
Минус 913
восьмых в кубе.
Теперь надо просто так.
913 на 3 умножить.
Сколько у нас там получится? Ой, какие халявные числа.
2739.
Шестнадцатых.
Четвертый.
Окей.
Так.
Так, 850.
Да, значит.
Ага.
Ага.
Ну да, логично.
А нет, не логично.
А тут плюс 850 надо.
3,5.
Халявно, да. 3,589 шестнадцатых.
Вот.
Ну и последний
член, который тут окажется,
это соответственно плюс 3589
32
Т в четвертый.
Ну тут понятно.
Т в четвертый.
Все.
А как же?
Не, ну это халявно.
Так.
А?
Да, мы поделили многочлен
А на многочлен В
по модулю Т в пятый.
Вот чисто теоретически это примерно вот так
делается. На уровне определения,
по крайней мере.
Да, теперь нам надо два.
Во-первых, как это сделать
быстро там за энлогенов, во-вторых, зачем
мы вообще это ввели?
Чего?
Ну действительно, да.
Заметим, что если у нас
В0 не равно нулю,
В0 не равно нулю,
то мы в принципе можем
на самом деле
к многочлену В
найти обратное.
Логично, да?
Значит, как
мы это будем делать?
Ну если мы найдем обратное,
то тогда, чтобы поделить А на В,
надо просто А умножить на обратное.
Логично, да?
То есть, хотим найти такое В-1,
чтобы В умножить на В-1
было сравнимо с единицей
по модулю Т в степени N.
Логично, да?
В смысле?
Ну как бы, если мы найдем такое обратное,
то мы А сможем поделить на В, вот в этом смысле.
Ну это
определение многочленов
В-1.
Да, вот из этого механизма следует,
что он существует.
И В-1
это В на В-1?
Ну типа.
А, ну ясно.
Вот.
Теперь Ч.
Внимание, внимание.
По модуле ТК?
А, у нас К, ну ладно.
Так вот.
Давайте сделаем вот как.
Давайте скажем, что
К это у нас, как всегда,
степень двойки, на самом деле.
Там 2 в степени L, допустим, да?
И давайте еще скажем, что
B от T.
Ну, что такое B от T?
Если мы уж по модулю Т в степень К,
то это равно B1T плюс B2 в степени T
в квадрат, плюс и так далее, плюс
и так далее.
Логично, да?
Внимание.
Давайте скажем, что
B от T.
Это равно B0T
плюс T в степени К пополам
на B1T.
Помните, вот как мы в каратсубе делали.
Ну, то есть B0 и B1
это многочлены размера К пополам.
Понятно, каким образом.
Нет, только в каратсубе.
А где еще?
Т в степени К.
Т в степени К,
только в классическом каратсубе мы так делали.
Теперь немножко...
Ну вот.
Теперь, значит, идея такая.
Значит, давайте
найдем
рекурсивно
B0 в минус
1.
То есть пусть у меня B0 в минус 1
это такое многочлен, что B0
было сравнимо
с единицей по воду LUT
в степени К пополам.
Вот, понятно, да?
Вот, допустим, мы это
откуда-то взяли.
Только для B0?
Ну, только конкретно для B0.
Я утверждаю, что больше нам и не понадобится.
Вот почему.
Давайте скажем, что
B в минус 1
значит
чему это равно?
Я утверждаю, что
B это равно B0 в минус 1
плюс T в степени К пополам
на какой-то мистический многочлен E.
Ну, так я могу тоже этот многочлен разбить
на те, у кого
коэффициенты меньше, как пополам,
и начинать с К пополам, да?
И более того, достаточно очевидно,
что первые К пополам коэффициентов
ровно B0 в минус 1 будут, правда?
Ну,
не очевидно.
Очевидно же два выделения.
Еще раз.
А, да, логично.
Чего?
Ну, не делим, а обращаем.
Ну, утверждается, что
если вы хотите найти в этом обращении
первые К пополам коэффициентов, то для этого достаточно
обратить вот это.
Ну, потому что, смотрите, давайте вот
представим себе, что B в минус 1
это равно, там я не знаю,
F плюс T в степени К пополам
на E, да?
И тогда мы с вами знаем, что
единица сравнима по модулю
T в степени К пополам с B
на B в минус 1, да? Это равно
B0 плюс
B1 на T в степени К пополам
умножить
на F плюс T пополам
на E.
Да, это равно
B0F, вот я так
если раскрою скорую, плюс T в степени К пополам
на очень много
чего. Это сравнимо по модулю T в степени
К пополам с
B0F.
Все. Так что вывод F
равен B0 в минус 1.
Что?
И還有 T в степени К пополам
Ну, неважно. Давай again.
Мы, получается, ищем по модулю
F в степени К пополам.
Ну, когда я беру diesel
по модулю T в степени К по полам,
мусор, как раз, отбрасывает.
У нас же, вот там, да、
мы считали F в степени
К. Но если у нас есть
равенство по модулю T в степени K, то это же
равенство работает и по модулю T в степени К пополам.
Ну, когда вы берете просто t в меньшей степени, вы просто лишние еще несколько коэффициентов отбрасываете.
Вот. Так что получается вот этот f, так что теперь мы можем уже точно утверждать, что это b0-1, да?
Ну, а теперь смотрите. Теперь давайте внимательно...
Ну, кажется, осталось найти обратный f-0 и их...
Не-не-не, ну там, погодите. На самом деле... Ну, давайте еще раз то же самое напишем.
Итак, значит, мы ждаем 1 сравнимо по модулю t в степени k на...
Значит, b0 плюс b1 на t в степени k пополам на какой-то там b0-1 плюс e на t в степени k пополам.
