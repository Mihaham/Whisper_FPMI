Сегодня последняя лекция первого модуля, который посвящен всяким железякам.
Мы раньше рассматривали такое понятие, как вычислительный процессор. Что это такое? Это
какие-то блоки, которые могут выполнять разные операции над регистрами, как-то взаимодействовать
с памятью. Причем чтение загрузка у процессора быстрее всего осуществляется именно с кэш памятью.
Но на самом деле иметь просто какой-то набор вычислительных блоков, набор регистров без
возможности как-то связаться с внешним миром, чтобы можно было выявлять результаты выполнения
работы, это как-то не очень осмысленно. И хотя большинство современных систем делаются в формате
системы на кристалле, когда у вас есть одна большая микросхема, на которой можно запихать и несколько
ядер обычного процессора, несколько ядер графического сопроцессора, какую-то периферию,
но чаще всего такие системы на кристалле используются в мобильных устройствах,
телефоны, планшеты, но в какой-то степени это относится в том числе и к современным
обычным десктопным процессорам, внутри которых запихали какую-то часть периферии, например,
контроллер управления памятью, но на самом деле так было не всегда и у большинства современных
компьютеров на самом деле архитектура она очень похожа идеологически и с программной точки зрения
на очень старинные компьютеры еще до эпохи x86, а именно со времен 8-битных процессоров. Что
такое процессор? Это просто некоторая микросхема, которая позволяет общаться с внешним миром,
используя какие-то сигналы через шину данных. Что такое шина? Шина это какая-то последовательность
рядом идущих проводников. Обычно размер шины, то есть количество проводников, связанных между
собой идеологически, определяется разрядностью процессора, то есть если процессор у нас 8-битный,
у него 8-битные регистры, то как правило шина данных у него будет тоже 8-битная, то есть за один
такт он позволяет с внешним миром передавать только 8-бит. Кроме шины данных, на которые как раз
передаются сами данные, есть еще шина адреса. Обычно она не всегда совпадает, по разрядности с
шиной данных может быть больше. Вот шина адреса она предназначена для того, чтобы выбирать либо
различные устройства, либо внутри устройств разные ячейки памяти, если например это оперативная
память, либо что-то с буферизацией. Точно так же, как и шина данных, шина адреса состоит из
множества проводников, но если у вас 16 контактов на шине адреса, то вы можете адресовать максимум
2 в 16 байт, но это получается 64 килобайта. Кроме того, обычно на всех системах есть контакт под
названием clock, что это такое? У нас все устройства должны работать с некоторой фиксированной
частотой, чтобы как-то синхронизироваться между собой. В старых системах частота была порядка
нескольких мегагерц, в современных системах, хотя процессоры работают на частотах уже в
несколько гигагерц, сами системные шины все-таки они работают на частотах сотен мегагерц, поскольку
не все устройства очень быстро. И если у вас есть несколько устройств, пусть даже однотипных,
например, много разных микросхем памяти, чем больше микросхем памяти вы стоите, тем больше у вас
оперативной памяти доступна, то нужно иметь возможность выбирать каждую микросхему по
отдельности. В старых системах для этого использовался дешифратор, это микросхема, которая принимает на
вход некоторые 4 бита для того, чтобы выбрать в десятичной записи какую-то
конкретную микросхему и включить ее для взаимодействия. Все остальные микросхемы, которые
подключены к общим шинам адреса и данных, они оставались без взаимодействия. В современных
системах что-то подобное реализуется в микросхемах памяти, то есть когда вы втыкаете какую-то планку,
вообще что из себя представляет планка памяти? Это одна микросхема с контроллером, обычно по центре
планки располагается, и куча одинаковых микросхем, которые навешаны на одни и те же контакты. И кроме
того, у систем могут быть артагональные адресные пространства как для обращения в память,
так и для взаимодействия с межней периферией, так называемые порты ввода-вывода. В старых
системах они обычно переключались отдельным контактом, то есть режим работы был, когда вы
на адресной шине выставляли либо адрес памяти, либо адрес какой-то периферийной микросхемы. Почему я вам
рассказываю всю эту историю? Потому что с программы точки зрения многое из этого до сих пор актуально,
хотя физическая реализация у нас совершенно другая. Что такое порты ввода-вывода? Это некоторые
устройства, которые адресуются точно так же, как память. На самом деле порты ввода-вывода бывают
двух видов. Некоторым из них соответствует какое-то отображаемое в реальное адресное пространство,
то есть у вас может быть оперативная память, в которой вы обращаетесь, и в каких-то соседних
физических адресах может располагаться данный не в памяти оперативной, а, например,
видеопамять. Так реализован, например, протокол VGA, то есть некоторый минимальный интерфейс на
всех PC-компьютерах до запуска их сервера, который позволяет отображать консольный текст либо
простую графику через фреймбуфер. Портмэпт это как раз противоположность, это ортогональное
адресное пространство, через которое можно взаимодействовать только специальными командами
процессора для Intel IN и OUT. Одновременно процессор не может адресовать и память, и
порты ввода-вывода. То есть процессор должен, если вы хотите что-то вывести, например, через обычный
портмэпт порты ввода-вывода, например, это взаимодействие с жестким диском, то процессор должен
прочитать что-то в регистр из памяти, затем с помощью команды OUT записать это в порт
вывода, при этом временно память отключить. Как можно посмотреть, какие порты у вас вообще в
принципе есть. Есть файлы системы PROCFS, для того чтобы там что-то смотреть, нужно
иметь права рута, просто так вам ничего не покажут. В PROCFS у вас есть
такие файлики как IO ports, в которые содержится информация про порты ввода-вывода, к которым
можно обращаться с помощью команд IN и OUT. Естественно, для этого вы должны находиться в
привилегированном режиме работы процессора. Каким устройством можно обращаться через такие порты?
Это могут быть разные таймеры, клавиатура, устройство для прямого доступа в память, демо,
контроллер ATO дисков, он же SATA, ну и разные устройства для конфигурации, управления. На самом
деле у меня не совсем честная система, поэтому список устройств он достаточно странный, не
совсем честный, потому что это виртуалка Parallels. На реальном физическом устройстве у вас могут
быть совершенно другие устройства. Адреса ввода-вывода для портов, с которыми можно
взаимодействовать с помощью специальных команд процессора, они 16-битные, но на самом деле очень
много их и не нужно, поскольку вот и вывод в какие-то порты, он осуществляется последовательным
образом. Другой способ взаимодействия с портами, это некоторые отдельные устройства, которые можно
посмотреть в PROC.IO.MEM, это те устройства, взаимодействие с которыми осуществляется просто самыми
обычными инструкциями MOV, то есть с записью в память, но с записью в память по определенному адресу.
Здесь можно взаимодействовать с таблицей прерываний, можно взаимодействовать с видеопамятью режима
VGA, который на самом деле не очень много, это не вся видеопамять, что еще интересного, но в основном
то, с чем можно взаимодействовать для конфигурации устройств, плюс еще контроллер SATA и контроллеры
USB. Кроме портов водовывода, каждое устройство имеет связь с процессором под названием
аппаратное прерывание, то есть кроме диапазона адресов портов водовывода, либо отображений на
память, диапазона вывода и вывода, у каждого устройства есть некоторые прерывания, для чего они
нужны. У процессора есть один контакт под названием интеракт, как только на этот контакт подается
положительный сигнал, логическая единичка, то процессор немедленно приостанавливает свою работу,
и дальше он должен выполнить какой-то обработчик прерывания. Что именно за обработчик, это зависит от
того, какое устройство нам послало сигнал на прерывание. Сами обработчики обычно реализуются
ядром операционной системы, а если у вас ядро операционной системы пока еще не загружено,
то у вас есть базовая подсистема водовывода, он же биос, некоторая флеш-память, которая содержит
минимальный набор функциональности для того, чтобы компьютер мог включиться и загрузиться и вообще
что-то делать. После того, как процессор обработает прерывание, он может дальше продолжить свое
выполнение. Как классические прерывания были устроены? Если рассмотреть процессоры 80-х,
начала 90-х годов, то обычно прерывания реализовывались одной либо двумя микросхемами,
которые включены в каскад. У каждого прерывания был свой номер от 0 до 15. Чем меньше номер
прерывания, тем более высокий приоритет. То есть у нас одновременно несколько устройств могут
подать сигнал о том, что возникло некоторое событие, и в этом случае больший приоритет имеет тот,
у которого номер прерывания меньше. В совсем старых системах прерывания, конфигурируясь вручную
с помощью джамперов, то есть что у нас происходит, когда какое-то устройство может взаимодействовать.
Оно подает сигнал на прерывание. Дальше контроллер прерывания подает сигнал на прерывание процессору.
Процессор опрашивает через шину данных этот контроллер, а что именно за устройство потребовало
внимание, и в зависимости от того, какой номер ему выдал контроллер прерываний, дальше процессор
выполняет какую-то функцию из области ядра. В современных системах никакой двухкаскадной
системы нет. Прерываниями занимается отдельная микросхема, это программируемый контроллер
прерываний. Что он делает? Он предназначен для того, чтобы получать прерывания от различных
устройств, и в отличие от более старых систем, где для каждого устройства был зафиксирован
жестко аппаратным образом порядковый номер прерываний и его приоритет, здесь прерывания
складываются в очередь, и контроллер прерываний имеет таблицу с приоритетами, которая задается
программно, на стадии загрузки компьютера, на стадии инициализации ядра, и дальше последовательно
обрабатываются уже прерывания, и устройство будет легко переконфигурировано. Где можно посмотреть
информацию о том, каким устройствам, какие прерывания связаны, вообще у каких есть прерывания.
Рядом валяется файлик под названием interrupts в PROCFS. Здесь мы видим аппаратный таймер, устройство
управления питанием, SATA-контроллер, звуковая плата, два контроллера для USB, точнее три контроллера
для USB, и legacy контроллер прерываний, который обозначен как Intel 8042, это как раз по названию
исходных старинных микросхем для того, чтобы можно было подключать какие-нибудь старые устройства,
но опять же это может быть виртуальное устройство и физически к старому контроллеру прерываний
ничего не подключено. Кроме того, есть некоторые специальные сигналы под названием не маскируемые
прерывания. То есть аппаратные прерывания процессор может временно приостанавливать,
например, когда выполняет какую-то операцию критичную по времени, какой-то код критичный по
времени, он может временно остановить выполнение прерываний. И есть отдельный канал, отдельный
контакт на процессоре, так называемый не маскируемое прерывание, которое в принципе никак нельзя
перехватить или запретить. Но не маскированные прерывания обычно используются в промышленных
компьютерах, например, для каких-нибудь аварийных кнопок. Как вообще процессор может взаимодействовать
с каким-то устройством? Например, устройство по названию жесткий диск. Он может передавать
данные, читая это сначала из памяти в регистры и потом записывая через команды in и out уже
непосредственно в порты ввода-вывода. Чем такой подход плох? Он очень медленный, поскольку здесь
требуется читать последовательно каждое машинное слово, все это прогонять через регистры, и процессор
во время взаимодействия с каким-то внешним устройством через обычные порты ввода-вывода не
может заниматься чем-то более полезным. Ну и альтернативой к такому подходу является прямой
доступ в памяти, когда поддерживаемому прямой доступ памяти устройству либо контроллеру указывается
некоторое место оперативной физической памяти, с которой он может взаимодействовать. То есть
ядро перед взаимодействием аллоцирует несколько страниц памяти, дальше указывает устройству,
что тебе разрешено писать либо читать сюда-отсюда. Все, дальше устройство уже непосредственно
напрямую взаимодействует с памятью через один из каналов DMA, и как процессор узнает о том,
что операция была уже выполнена. Устройство посылает информацию о том, что он закончил
взаимодействие контроллеру DMA, дальше контроллер DMA сам по себе генерирует прерывания. Эти
прерывания обычно имеют самый высокий приоритет, и процессор, обрабатывая прерывания от контроллера DMA,
понимает, что какое-то устройство с определенным номером канала DMA завершило взаимодействие и
значит, можно либо записать в память следующий кусок данных, например, если вы используете
периферийные устройства для записи, либо наоборот понимает, что данные были прочитаны и уже
находятся в памяти, с ними как-то можно работать. На самом деле взаимодействие с жесткими дисками
через обычный неэффективный ввод-вывод, он был распространен достаточно давно и во многих
операционных системах, включая MS-DOS, до сих пор используется именно этот способ взаимодействия.
То есть, если вы используете компьютер без операционной системы, либо решите написать свою
операционную систему с нуля, то самый простой способ взаимодействия, который описан во многих
тьютериалах, это как раз взаимодействие через команды IN и OUT, очень медленный доступ. Более того,
есть курс по разработке и внутреннему устройству операционных систем. Классический курс
«Разработка операционных систем» от университета MIT и специально для этого учебного курса была
разработана простая система UNIX-подобная XV6, до которой бедные американские дети учатся писать
свои операционные системы. В этой операционной системе приводятся примеры только для того,
как взаимодействие с диском через порты ввода-вывода неэффективно. Немного рекламы. Один из магистрантов
нашей кафедры написал свою операционную систему, похожую на XV6, с теми же самыми целями,
для образовательных целей. Если вы доживёте до следующего семестра, точнее до третьего курса,
весельного семестра, тогда у вас будет возможность взять курс по выбору по разработке операционных
систем, как раз на примере системе под названием HelloOS, где реализован доступ к диску с использованием
DMA. Кроме портов ввода-вывода, есть доступ к оперативной памяти. Хотя в старых системах обычно
отдельно использовался адрес отдельно шиноданных, в какой-то момент, когда микросхем памяти стало
очень много, это оказалось неудобным, просто потому что много проводников. Более того,
память вы можете наращивать, для этого используется отдельный интерфейс под названием DDR, то есть вы
покупаете планки памяти, которые можете вставлять в некоторый унифицированный разъём. Что это за шина
такая? Это шина, которая позволяет параллельно передавать 64 бита информации за один сигнал,
но что такое один сигнал? Если в классической передаче данных у вас на один такт взаимодействия
передаётся только один бит, то double data rate по названию означает, что вы передаёте за один
тик целых два бита. За счёт чего это осуществляется? На самом деле, переключение между логическим нулём и
единицей, то есть между нулевым напряжением и верхним порогом, например, 3 вольта, оно происходит
неоднократно. Сначала есть быстрое нарастание, а потом быстрый спад. Так вот, можно фиксировать не
только сам факт того, что у вас сигнал стал положителем, то есть появилось напряжение на
каком-то пене, а отслеживать то, что напряжение увеличивается, то есть нарастающий фронт,
либо, наоборот, напряжение спада. Поэтому за один такт можно передавать сразу два бита, и этот
способ часто используется во многих шинных передачи данных, в том числе при взаимодействии с
памятью. И сколько можно передавать данных за одну секунду, используя обычную шину памяти. Но здесь
у разных планок памяти есть отдельные характеристики. Во-первых, на какой частоте
максимальные эти планки памяти могут работать. Обычно они больше одного гигагерца, если посмотрите
на современные планки, в том числе не самые дорогие. При этом за один тиг вы можете передавать два
бита данных, и разрядность большинства современных планок памяти это 64 бита. То есть, если у вас
частота полтора гигагерца, то вы можете передавать на один канал в секунду три миллиарда бит,
или достигать суммарной скорости примерно 24 гигабайта в секунду. Но у планок памяти есть
некоторые лаги по доступу, потому что данные между контроллером памяти, которые обычно внутри
процессора, и самим самим планками памяти, передаются последовательно большими кусками. В виде
набора команд, когда выбирается какой-то большой блок в оперативной памяти, и дальше выполняется
операция чтения или записи последовательно нескольких непрерывных кусков. И обычно есть еще
отдельный параметр, это таймингс. Чем он меньше, тем лучше. Он обычно определяет количество тиков,
требуемых на начальный доступ к памяти, на выбор ячейки в строке и в столбце, которые требуются для
взаимодействия. То есть, взаимодействие с оперативной памятью, оно хоть и достаточно быстрое по
количеству передаваемых данных в секунду, но оно не самое быстрое для случайной выборки,
для произвольного доступа. Этот недостаток обычно компенсируется наличием в процессоре кэшей из
статической памяти, обычно данные загружаются одним большим блоком в кэш-память, а дальше процессор
непосредственно работает уже с быстрой кэш-памятью. Кроме оперативной памяти, другая параллельная
шина, раньше часто используемая в компьютерах, сейчас уже сильно реже, это PCI и одна из ее
разновидностей под названием AGP. В этих шинах использовалась 32 либо 64-битная в последние
годы. Шина, которой была смещена, шина адреса, шина данных, там просто чередовались данные, то есть
сначала выборка адреса, потом шина данных. Разгонялась эта шина до 533 мегабайт в секунду. Почему
шина PCI до сих пор актуальна? Потому что с программной точки зрения шина PCI express, она мало чем
отличается от PCI и от AGP. При этом у вас могли быть на системной плате несколько разъемов, которые
находятся рядом, и они все были припаяны к одной и той же шине, то есть на одних контактах было
сразу несколько разъемов. И устройства могли взаимодействовать как между собой, так и с
центральным процессором. Для того, чтобы не было никаких конфликтов, всегда должно быть устройство
под названием орбитр шины. Обычно эта роль выполнялась чипсетом на системной плате. И для того, чтобы
уменьшить нагрузку на шину, для видеокарт был разработан специальный порт AGP, который на самом
деле является тем же самым PCI, но только с отдельным выделенным каналом для ускорбка процессора и
памяти. Вот что доступ к памяти, что шины PCI и AGP являются параллельными шинами, то есть они
позволяют за один такт передавать сразу несколько бит информации. С одной стороны, это очень такое
разумное решение, то есть у вас есть несколько контактов, и чем контактов больше, тем больше
данных вы можете в секунду передавать. Но в то же время есть и обычные физические недостатки,
связанные с тем, что у вас проводников много. Во-первых, они оказывают влияние друг на друга,
то есть слишком много проводников на большое расстояние, если делать, то они будут создавать
помехи, и данные будут портиться, их придется заново отправлять. Другая проблема связана с тем,
что параллельные интерфейсы нужно очень аккуратно разводить на системных платах,
и учитывая их ограниченную площадь, это не всегда бывает возможным. Что будет,
если шину, которая работает на высокой частоте, развести не очень аккуратно,
то есть делать все проводники не рядом идущими друг с другом, а раскидать так,
как получилось развести. У вас может быть так, что некоторый старший бит имеет очень небольшое
расстояние между энкросхемами, а какой-нибудь младший бит, наоборот, может иметь очень длинные
расстояния. И здесь уже на высоких частотах будут проявляться такие эффекты, как скорость,
скорость распространения сигнала. Какая у нас самая большая скорость возможная в мире? Скорость
света. Но скорость света это идеальная недостижимая скорость. На самом деле,
скорость распространения токов проводника, она не сильно больше половины от скорости
света, и когда речь идет про частоты в сотни мегагерц, здесь плюс-минус несколько сантиметров
уже могут существенно сказываться, поскольку если у вас данные приходят не так, как у вас с разной
скоростью, то у вас может быть один тик по частоте синхронизации, по каналу синхронизации. В это
время вы прочитаете один бит, который был отправлен раньше, и какой-то бит, который относился
вообще к предыдущему байту, был отправлен раньше, но он еще не дошел. Поэтому параллельные шины,
они не были распространены, точнее сейчас они не очень распространены, там где у вас есть какие-то
гибкие провода, то есть если вы вскроете системный блок, то маловероятно вы найдете какие-нибудь широкие
шины, хотя в старых компьютерах конца 90-х годов такое встречалось, но тогда частоты были сильно
меньше. Сейчас происходит постепенный отказ от использования параллельных шин в пользу
последовательных. По названию тут уже понятно, что параллельная шина, когда вы параллельно
передаете сразу несколько бит, и чем шире шина, то есть чем больше бита одновременно вы передаете,
тем больше данных, с большей скоростью вы можете передавать. Последовательные интерфейсы как раз
наоборот передают не так много данных, но зато делают это с очень большой частотой. Что здесь обычно
требуется для реализации кодоконтроллера шины? Обязательно требуется буферизация, то есть если вы
хотите передать один байт информации, используя только один проводник, то вам нужно за восемь
тактов отправить эти восемь байт, а принимающая сторона, прежде чем прочитать этот байт, должна
все эти биты сложить в какой-то буфер и дальше уже передать по параллельной шине к какому-то
устройству, с которым она работает. И вот современная реализация шины PCI, которая называется PCI express,
которая использует ту же самую логическую организацию, то есть это тоже интерфейс, как PCI,
который использует передачу сообщений между разными устройствами, но принципиальное отличие
от классической PCI в том, что он сделан как последовательная шина, но работающая с высокой
частотой. Причем в зависимости от того, насколько требовательное ваше устройство к скорости
передачи данных, оно может использовать не все, только часть из каналов передачи данных. Каждый канал
передачи данных это четыре контакта, два контакта в одну сторону и два контакта в другую. Почему два
контакта? Потому что при последовательной передаче данных для избежания возможных, воздействия
каких-то возможных помех, используется подход под названием дифференциальная пара. В чем идея
дифференциальной пары переводников? Допустим, вам нужно передать данные даже на какое-то
большое расстояние, и где-то посередине к вам прилетает какая-то помеха. Для того, чтобы эту
помеху устранить, есть простая идея, которая заключается в том, что вы передаете один и тот же
сигнал по двум независимым каналам связи, но по второму проводнику вы передаете его инвертированно,
и эти проводники идут рядом. Если прилетает помеха, то она затрагивает обычно сразу два
проводника, и помеха набывает в сторону либо повышения напряжения, либо понижения, и она
одновременно воздействует как на прямой сигнал, так на инвертированный. Приемник, соответственно,
берет сумму с отрицанием этих двух сигналов, и в том случае, если вы и на положительный проводник,
и на отрицательный, получили одну и ту же помеху, то изменения будут одинаковые, и они просто
компенсируют друг друга уже на стадии суммы. Вот это называется дифференциальная пара, и за счет
использования дифференциальной пары удается очень существенно поднять тактовые частоты на
проводниках, в том числе на достаточно большие расстояния. Например, HDMI-провод, USB-провода,
они все работают на очень высоких частотах, и тем не менее, несмотря на то, что это обычный провод
с прорезиненной оплеткой, ну хорошо, там есть еще экранирование, но не самый тяжелый провод,
достаточно гибкий, данные передаются без помех. Так вот, внутри PCI-Express у вас может быть несколько
таких вот пар, да еще и в каждую сторону, то есть x1 это 4 проводника, x2 это, соответственно, в два
раза больше. Видеокарты обычно используют самые тяжелые варианты PCI-Express, какие-нибудь простые
устройства типа звуковых карт, ну и даже SATA-контроллер, если он у вас внешний, то все
равно больше, чем x4, обычно редко используют. Ну и еще одним отличием шины PCI-Express от обычной
шины PCI-Express является то, что здесь используется топология звезда, а не последовательное навешивание
нескольких устройств на одни и те же шины, то есть есть некоторый центральный свитч, который связан
уже с процессором, и дальше к этому свитчу подключаются разные PCI-устройства. Ну и в некоторых
процессорах может быть реализация контроллера PCI-Express, то есть как раз этого самого центрального
свитча. И большинство устройств, которые у вас расправлены на материнской плате, особенно тяжелых
устройств, ну с точки зрения передачи данных, это как правило PCI-устройства, и посмотреть их полный
список можно с помощью команды lspci. Что есть у каждого устройства? У него есть некоторый порядковый
номер, ну и PCI-устройство при подключении сообщает некую информацию о себе, которую можно выяснить,
в том числе через команду lspci. Типовые PCI-устройства, ну кроме разных мостов на старые интерфейсы PCI
и ESA, это SATA-контроллер, мультимедиа-контроллер, VGA-контроллер, это видеокарта, ну виртуалки,
напоминается, как что-то виртиво GPU, у вас может быть либо Intel, либо Nvidia, либо еще что-нибудь,
ну и USB-контроллеры. Все это достаточно быстрые устройства, с ними необходимо очень быстро
обмениваться данными. Да, ну и все PCI-устройства поддерживают механизм прямого доступа к памяти,
то есть взаимодействие с устройствами PCI-экспресс не производится с помощью команд in-out,
все происходит достаточно быстро. Так, ну и кроме высокоскоростных шин PCI-экспресс бывают
низкоскоростные шины. Самая простая из них называется I2C. Что это за шина такая? Это шина,
которая использует помимо питания всего лишь два провода. Один провод предназначен для передачи
тактового, информации тактового генератора, то есть там примерно с одинаковой частотой идут сигналы
положительные либо нулевые. И второй канал, это канал для передачи данных, собственно,
по которому передаются биты, относящиеся к сообщениям. И по времени сигнал тактовый и сигнал,
который передается по проводу данных, они должны совпадать. Если в момент положительного сигнала
на тактовом проводе у нас нулик на данных, то это значит логический ноль, если единичка,
то логическая единичка. Переключение между ними это по сигналу с тактового генератора. В чем
особенность шины I2C? Она предназначена для того, чтобы работать на небольших тактовых частотах,
но здесь не требуется какой-то точной синхронизации разных устройств. Поскольку синхронизация,
она производится уже самой шиной, и устройства могут в принципе даже работать с разной скоростью.
В этом случае выбирается просто скорость, с которой могут работать все устройства. На одну шину
I2C может быть навешано достаточно много устройств, и взаимодействие осуществляется с помощью
сообщений, и у каждого устройства есть 7-битный в редких случаях расширенный 10-битный идентификатор,
которым можно обращаться. Что у нас реализуется через устройство I2C? В виртуальной машине я
не могу ничего вам показать, потому что устройств I2C в виртуалке просто нет. Если вы запустите
утилиту I2C Detect на ноутбуке, то вы, например, можете, я имею в виду не в виртуалке, а на настоящем ноутбуке,
то сможете, например, увидеть устройства, такие как регулятор громкости, регулятор яркости экрана,
то есть те устройства, которые не требуют большой объем передачи данных, но при этом требуют
максимальной простоты для подключения. На телефонах эта шина может использоваться для подключения GPS,
гироскопа, компаса, всяких датчиков освещения, опять же, всей периферии, которая не слишком
требовательна к скорости. Ну и я отдельно открыл вкладку с Raspberry Pi. Я все время влагонюсь под
рутом, потому что взаимодействие с устройствами, в том числе получение достоверной информации,
оно недоступно часто обычному пользователю. Вот у Raspberry Pi есть встроенный I2C контроллер.
Что такое плата Raspberry Pi, представляете? Там есть еще гребенка из сорока контактов. Вот два контакта
из них, это как раз шина I2C, на которой вы можете навешивать всякое внешнее оборудование. В обычных
десктопных либо сервенных системах эта шина может использоваться, например, для контроля за
скоростью вращения вентиляторов, ну и температурой процессора, то есть всякие устройства для
мониторинга. И некоторой разновидностью шины I2C, немного упрощенной, является интерфейс под
названием SPI, который требует уже для взаимодействия минимум три провода. Если у вас только два устройства,
либо больше четырех проводов, если у вас несколько устройств, вот на шине I2C вы все навешиваете
всего лишь на два провода, и по ID отдельные устройства понимают, к кому из них обращается
хост-контроллер. В случае с SPI у вас может быть взаимодействие только между двумя устройствами,
и кроме того вы можете передавать данные в две стороны. Кроме шины для передачи тактовой информации,
есть шина для передачи данных от мастера к подчиненному, мастер слейф, терминология,
которая скоро будет запрещена, но пока еще нет. Ну и в обратную сторону, это два независимых канала
для передачи данных. И плюс отдельный канал под названием Chip Select, либо Source Select,
Sink Select, который предназначен уже для выбора отдельного устройства, если вы навешали несколько
микросхем, например, подключили к одному микроконтроллеру. Вот шина SPI обычно используется в микроконтроллерах,
потому что ее реализация еще более простая, чем I2C, здесь не требуется поддерживать какие-то
идентификаторы. Обычно по SPI цепляются, например, контроллер жидко-кристаллических экранов,
какие-нибудь датчики температуры, датчики управления двигателями, там скорость вращения,
ну и так далее. То есть если вы чего-то клепаете на Arduino, то наверняка с этой шиной сталкивается.
И кроме того, помните, когда я вам показывал гравитапу, которая светилась разными огоньками,
я же ее предварительно как-то прошивал, то есть программу с компьютера закидывал на микроконтроллер,
и вот взаимодействие было опять же по шине SPI. То есть для контроллеров на базе AVR,
там если вы зажимаете при включенном состоянии контакт Reset, то некоторые контакты превращаются
в SPI, и вы можете через них заливать туда разные прошивки. Так, ну и более универсальным,
некоторым промышленным стандартом низкоскоростных шин для передачи данных последовательных,
является интерфейс UART. Причем UART это именно логический интерфейс, а не физический,
который описывает, как можно передавать данные. Он передает данные последовательно, причем в
разных форматах вы можете, например, помимо самих данных передавать еще битчетности, и кроме того
устройства, в отличие от шины SPI или шины I2C, обязаны сами поддерживать некоторую частоту
по договоренности. Здесь частоты бывают от 300 бит в секунду. Есть такой термин по
названиям BOD, это дословный перевод с английского BOD, количество бит полезной информации в секунду,
то есть количество бит, за исключением стартовых, стоповых и контрольного, и характерные скорости
работы. Это от 300 бит в секунду в самых простых случаях, до того, что использовалось в последних
модемах, перед тем как... Да, штуковина, которая втыкается в телефонную линию, пищит противно, да.
Кто помнит, из тех, кто застал модем, кто помнит, с какой скоростью они работали?
56 тысяч, это был максимум достижимый на наших качественных телефонных линиях. На самом деле,
у меня, например, 56 тысяч никогда не удалось выжимать, обычно там 48 тысяч в секунду. Вообще,
протокол позволяет до, с помню, 112 тысяч BOD вытягивать. То есть, данные, в принципе,
можно передавать относительно быстро, но не так быстро, как это можно делать по USB. В чем
прелесть протокола UART? В том, что он стандартизован, есть куча инструментов для работы с этим
протоколом. Если у вас есть последовательный порт, как в современных компьютерах, в которых нет
COM-порта, можно обеспечить себе подключение через последовательный UART-порт. Есть куча всяких
устройств переходников с USB на UART, причем бывают как переходники на 5-вольтовую логику, которая
используется для подключения Arduino, взаимодействия с Raspberry Pi, так и классические интерфейсы,
которые работают на напряжении до 15-ти вольт, обычные RS-232, как в старых компьютерах. И очень
много промышленного оборудования оснащено как раз интерфейсом RS-232 или B432, которым вы можете
подключить через переходник обычный USB, ну и дальше взаимодействовать как с обычным символьным файлом.
Вот устройство DFTTI чего-нибудь, TTI S, TTI USB, это как раз все те устройства, которые связаны
с отдельными каналами, которыми вы подключаете эти устройства. Можете передавать туда обычную
символную информацию. Ну и завершаем наш сегодняшний рассказ и вообще весь блок про железяки
современными протоколами передачи данных. Это последовательная шина USB, название USB это
Universal Serial Bus, универсальная шина, которая может подключать все что угодно. Есть куча разных
разновидностей разъемов, но вот если мы не затрагиваем USB SuperSpeed, то есть USB третьего
стандарта, то классическая шина это четыре контакта, два из которых это питание, земля и 5 вольт и одна
дифференциальная пара. По такой шине можно передавать данные до 400 мегабайт в секунду, то есть
достаточно приличная скорость. Причем канал передачи данных здесь полудубликсный, то есть вы
одновременно можете либо читать данные, либо передавать, либо чередовать. Вот D+, D- в этих
контактах означает, что это просто разные куски одной и той же дифференциальной пары. Ну и что у
нас есть из USB устройств на произвольно взятом компьютере. Вообще у каждого USB устройства есть
уникальный vendor ID и device ID. Как их получить? Их надо купить. Просто так вы, конечно, можете
их использовать, но это будет что-то около кустарное. У каждого устройства есть некоторый стандартный
класс, он определяется одним байтом. Для чего нужно задавать класс устройства? На случай, если
у вас нет какого-то стандартного, нет какого-то специфичного драйвера устройства, в терминологии
Linux это называется модуль ядра, но ваше устройство ведет себя по какому-то стандартному протоколу
взаимодействия. Например, клавиатура, флешка. Вы же под каждую клавиатуру, каждую флешку не
устанавливаете отдельный драйвер, просто втыкаете и оно просто работает. Потому что есть некоторый
унифицированный класс устройств, вот он как раз определяется одним байтиком device class. И
кроме того, каждое устройство может иметь свой индикальный идентификатор, который стоит из 4 байт,
это vendor ID plus device ID, которые продаются USB консорциумом, то есть для того, чтобы назначить
себе легальный vendor ID, его нужно купить. Ну и посмотреть это все можно в выводе команд ls usb.
Вот по умолчанию, да опять же у меня виртуалки там не очень наглядно. Есть несколько устройств,
вот числа, первое означает как раз vendor ID, второе device ID, кроме как виртуальной мыши параллель,
у меня ничего нет. А для чего нужны уникальные идентификаторы USB устройств? Для того,
что воткнув любое USB устройство в компьютер, можно было понять, а с чем вы работаете и
вручную это не настраивать. То есть, когда втыкаете какой-нибудь USB устройство, то ядро ищет у себя в
таблице по известному vendor ID и device ID, а что это за устройство, если оно находится, то загружается
соответствующий модуль и используется взаимодействие с помощью определенного драйвера. Если не находится,
то смотрится уже класс устройства. Вот USB с опцией Minus T отображает чуть более подробно информацию о том,
что это за устройство и какие драйверы они используют, к нему для ядра, а также к какому классу они относятся,
используется некоторый generic class. Ну и современная вариация протокола USB, которая USB третьего
стандарта, подразумевает, что USB 3 это те разъемы, которые синего цвета. В чем их особенность?
Там на самом деле не четыре контакта, а девять. То есть, вы можете воткнуть обычный четырехконтактный
разъем и получить обычный USB порт. Если вы такаете девятиконтактный разъем в порт USB третьей версии,
то вы еще получаете две дополнительные дифференциальные пары. Причем, каждый этих
дифференциальных пар работает только в одну сторону. Одна для передачи данных, другая для приема.
И дальше, какие возможные варианты? Вы можете использовать эти дополнительные дифференциальные
пары просто для ускорения скорости передачи данных по USB. Еще есть такой разъем как USB Type-C.
В чем его особенность? Вы его можете втыкать в разные стороны. За счет чего это достигается?
Тут симметрично есть два контактика под названием CC1 и CC2. Это configuration сигналы,
которые определяют, какой стороной вы воткнули этот разъем. Дальше все остальные контакты,
они примерно симметричные и не сильно влияют, как вы воткнете. Кроме того, помимо одного основного
порта низкоскоростного шины контактов D+, D-, тут есть еще двух дополнительных 2A3 и
A10 и A11, это как раз две дополнительные дифф-пары. Есть еще дополнительная линия,
под названием Sideband, которая может использоваться для альтернативного подключения, для альтернативного
использования того же самого разъема с какими-то дополнительными портами. Кроме того, если вам не
нужны высокоскоростные дифф-пары, то они тоже могут использоваться для дополнительных протокол.
Какие возможные сценарии использования разъема Type-C? Во-первых, я могу взять и воткнуть блок
питания в обычный Type-C. Этот блок питания выдает 20 вольт и 65 ватт, то есть там не только напряжение
в 4 раза выше, но и больше ток, который он выдает. За счет чего это достигается? За счет того,
что дополнительные дифф-пары используются просто как контакты для дополнительной подачи тока.
Это один из сценарий в использовании. Другой сценарий использования это использование разъема Type-C,
чтобы он мог помимо USB передавать видео-данные по протоколу DisplayPort либо HDMI. Ну вот,
собственно, то, что вы увидите, втыкается в обычный, точнее не совсем обычный Type-C.
Простой переходник. Дальше с этого переходника видео идет на трансляцию и на проектор. Вот здесь
есть некоторые маленькие замечания, что не в каждой Type-C вы можете воткнуть переходник
на HDMI. Почему? Потому что здесь подразумевается, что один разъем может использовать как USB-контроллер,
так и видеокарта. Если у вас просто в ноутбуке или вы купили отдельный какой-то переходник с USB
на Type-C, то у вас будет обычная реализация USB. Это в оси не будет подразумевать, что вы можете
использовать какие-то контакты для передачи HDMI данных. Ну и в телефонах, кроме того, есть еще
возможность воткнуть в Type-C обычные аналоговые наушники и микрофон. За счет чего это достигается?
За счет того, что стандартные USB-каналы, которые D+, D- используются просто под вывод звука.
Одна из шин sideband используется для подключения микрофона. Ну и поэтому в Type-C можно воткнуть
какую-нибудь гарнитурку, и она тоже будет работать без всякой цифровой схемы.
Так, ну на этом про железяки все. Вы видите здесь заяца. Это означает, что лекция закончилась,
а еще заяц повесился. И значит, что больше вы его уже не увидите. И первый модуль у нас закончился.
В связи с этим некоторые организационные объявления. Во-первых, я в общем чате под
названием важное объявление закинул разболовку. Она может вам показаться несколько жесткой,
но жесткой для тех, кто претендует на оценку от L10, потому что это максимально возможный балл.
Ну опять же максимально возможный балл можно достичь, даже если сдать не все на максимум.
Оценки 8 и 9, они вполне достижены. Это первый момент. Второй момент. У вас ожидается контрольная
по теоретическому материалу. Как подготовится контрольная по теоретическому материалу?
Посмотреть все лекции, будет рассказываться материал, то есть в контроле будет спрашиваться знание
материала из лекций, плюс немножко соображалки. Немножко соображалки знают, что вы хотя бы
что-то посчитать на бумажке тоже сможете. Речислительные задачи тоже будут. И самое интересное,
мы живем с вами в очень странное время, когда мы заранее не знаем, где мы будем через неделю
находиться. Либо в этой аудитории вы будете писать контрольные бумажки, либо может случиться так,
что нас просто закроют, и в этом случае придется контрольным все равно писать, но только делать это
в онлайн формате. Так что заранее, к сожалению, сейчас пока не могу это предсказать, в каком формате
будет. То есть я надеюсь все-таки, что нас через неделю пока еще не закроют, а вот зато нас
гарантированно закроют с 30-го числа. Что это означает? Означает, что учиться все равно вы будете,
но просто будет дополнительное время для дистанционных сдач домашек, но материала не будет.
То есть второй модуль мы начинаем после того, как закончится мини-карантин, вроде обещают
7 ноября, что все закончится. Пока никого официального приказа не было, но если царь батюшск сказал,
кто же ему будет противоречить? Наверное, никто не решится. Ладно, есть ли у вас вопросы по
содержанию всего модуля, например? Вопросы перед контрольной? В прошлом году с контрольными было
проще, они писали раз в семестр. Может, конечно, это не проще было для них, потому что больше
стрессовой ситуации за каждое семестр. Скорее спросите, как это было в позапрошлом году и в
когда контрольная была два раза в семестр. Ничего, нормально писали. У вас будет дополнительное время
до сдать все это, в то время, пока у нас такие странные недоконикуи. До контроля не обязательно,
то есть итоги все равно будут подводиться позже. То есть контрольная и решение контеста,
это две независимые части одной оценки. Ну ладно, если вопросов нет, тогда вы можете быть свободны.
