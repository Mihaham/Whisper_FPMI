у нас сегодня будет весьма такая разгрузочная лекция потому что мы сегодня переходим к блоку
по геометрии вот ну и сегодня сначала будут совсем простые вещи совсем элементарная геометрия
и в конце мы еще посмотрим на переангуляции
я надеюсь что первую половину вы откуда-нибудь уже знаете из каких-нибудь курсов линала или
алдема смотря что у вас там было в на первом курсе ну и вот всякие там скалярные векторные
произведения расстояние точки до прямой все вот эти формы мы сегодня выпишем чтобы освежить
в памяти потому что это нам будет нужно до конца ну в общем во всем этом блоке про геометрию это
нужно будет помнить как примитивы соответственно мы должны помнить как с этим работать давайте это
себе освежим в памяти чтобы потом могли использовать начну первым что нам нужно это примитив точки или
вектора да значит я не сказал но мы пока что живем в р2 на плоскости только в р3 мы может
когда-нибудь и выйдем но это не точно пока давайте считай что мы живем в р2 все на плоскости у нас
тогда соответственно что точка что вектор за 2 координатами x и y вот ну и поскольку на
самом деле любой вектор мы можем воспринимать как точку и наоборот да потому что такой вектор
направленный какой-то отрезочек тогда если его приложу к точке 0 0 то его конечный координат
как раз x и y поэтому у нас есть как бы взаимно однозначное соответствие между точками и
векторами да между радиус векторами ведущими в эту точку поэтому чтобы сильно не думать у меня
будет одна структура которая может хранить себе и точки вектор потому что все равно это как
бы сущность оставившись двух координат давайте их вместе хранить в одной структуре и интерпретировать
как хотим либо это точка на плоскости либо это радиус вектор как бы из 0 0 в эту точку ну то есть
по сути направленный отрезок в эту точку поэтому здесь нужно будет что-то типа структ поинт и
внутри там два поля интык с интык
в этой структуре давайте напишем всякие удобные операторы плюс минус умножить чтобы можно было в
коде оперировать с этими точками и векторами также как мы с ними оперировали бы на бумаге во всяких
формуках ну значит нужен оператор минус да давайте не буду полностью сигнатуру писать
понт оператор минус ну и там еще перейдем к какой-нибудь другую точку азр вот боюсь что
нам надо передавать по ссылке по константной все такое но я не буду полностью это прописывать вы
лучше меня знаете как писать все это из курса плюсов вот значит ну что такая разность точек
есть какая-то точка xy и какая-то другая точка которая хочу вычислить из исходной то нужно
просто сделать по по компонентное вычитание тикс минус азр x и y минус азр y разность двух точек
да которая в частности позволит нам получать вектор из точки а в точку b потому что если есть
две точки а и б я хочу получить вектор ведущий отсюда сюда собственно правильный отрезок то
нужно просто будет из конца вычислить начало ровно в соответствии с этим оператором минус да
у меня есть точка b точка направленный отрезок ведущий из начала в конец это конец минус
начала всегда b минус а вот ну и поскольку а и б это точки то разница между ними это тоже
точка которую можно в частности воспринимать как вектор начну оператор плюс аналогично здесь
минусы меняются на плюсике ну еще можно скажем оператору умножения какую-нибудь константу написать
пусть будет на целую пока что опять размножение на целую константу это нужно как бы вектор
умножить в карас карас его приложить соответственно его координат тогда просто множество на к
x на к y на к вот это соответствует тому что вектор x y мы откладываем карас в одном том же направлении
так дальше примите прямой расскажите пожалуйста как мы будем хранить прямую еще раз да с
тремя параметрами а б ценность мы все прямые будем хранить виде а икс плюс б игрек плюс с
равно нулю да конечно какой-нибудь там более школьное классическое представление так как
игрок равно к икс плюс б но оно не задает не все прямые да в частности оно не задает видимо
вертикальные прямые где x где x равен константе поэтому такой вид мы использовать не будем да
потому что значит давайте напишем не позволяет хранить вертикальные прямые позволяет хранить
вертикальные прямые ну поэтому мы так делать не будем а вот такой вид обобщенный да с тремя
коэффициентами он позволяет хранить любые прямые вертикальные горизонтальные любые другие наклоны
значит в принципе вот этот метод хранения прямых мог бы быть валидным такое явное выражение
y через x если например мы нашу изначальную картинку как-нибудь подвинем на случайный угол ну скажем
относительно начала координат подвинем всю картинку на некий случайный угол тогда понятно
дело что никакая прямая не может стать вертикальной потому что из-за того что мы подвинем все на
случайные угол то с вероятностью один ну еще только вертикальная прямая это значит что там настоящ ruled
от коке к cs2 в двух точек одинаковые abscis и да кардиналы по x и вот прямая ими ими задаваемая
будет тогда вертикально потому что при вып − случай lasted так так же того что на двух точек
останутся одинаковыми view abcism и если это были из ход на разные точки она должна 0 если
угол выбирается случай金襡 как зарегинометрический преобразование на на какой-то угол
умножается все. Вот. Понятно, что тогда никакая прямая вертикальна стать не может. Ну как бы
это все хорошо в теории, да, но тогда это все как минимум добавляет нам какие-то проблемы с
точностью. Потому что когда мы вводим какое-то региономическое преобразование, умножаем нам
от этого поворота все наши координаты точек, то мы как минимум переходим от исходных координат
к каким-то более неточным что ли. Мы там умножаем на косинусы-синусы. Косинусы-синусы как
бы не очень простые функции считаются какой-то погрешностью, тогда нас соответственно вся
картинка уже будет не очень точна. И как бы даже если у нас изначально все точки были целочистыми,
вот я пока что пишу, что у меня x и y всегда целые, вот здесь у меня ниты, то после поворота на
случайный угол, конечно, все сразу ну как минимум в дабл перекоит или в лонг дабл, если мы хотим гнаться
за точностью. Поэтому это как бы такой, ну не очень понятно зачем нужный компромисс. Давайте пока
стараться, если исходные координаты были целые, давайте пока стараться как можно дольше поддерживать
все остальные координаты тоже целыми. То есть все что пока делаем, давайте стараться чтобы оно было
целочисленное, чтобы не было никаких погрешностей. Потому что когда мы скажем, ну если мы будем
решать какую-то задачу проверить пересекаются ли какие-то два отрезка заданные своими концами,
вот если мы, скажем, запишем уравнение этих прямых в каком-нибудь виде, где a, b, c,
дабловские числа вещественные, да, ну с плавающей точкой, попробуем как-нибудь пересечь, то проверка
того, что эта точка лежит на отрезках, она, ну как бы может быть не очень точно, потому что в
зависимости от того, какая у нас там погрешность накопилась, вот если эта c была вот здесь,
вот или вот здесь, вот где-нибудь рядышком, у нас может ответ меняться, потому что точка пересечения,
если она не представляется точно вдовечной системе счисления с каким-то маленьким числом
знаков, то она может быть не в точности в точке пересечения, а где-то вот там рядышком из-за
ошибок округления, из-за погрешностей всяких. Вот, поэтому, случай, когда, скажем, c совпадает с
точкой пересечения, а точка пересечения при округлении куда-нибудь вот сюда попала, рядышком,
или там вылезла, вылезла за отрезок cd, мы тогда скажем, что они не пересекаются, хотя пересекались.
Поэтому, как бы, лучше всегда стараться, если у нас исходные координаты целые, как можно дольше
хранить все в целых и не переходить к доблам, если это только критически вам, ну, не нужно.
Вот, либо вот в таком случае можно было бы, например, все хранить в дробных числах, написать
как-нибудь свой класс rational, вы его наверняка тоже предотписали, то есть хранить все числа в
виде дробей, поделить на q, а если p и q там достаточно большие, если еще написать свою длину
арифметику, например, тогда можно хранить вот эти координаты пересечения прямых в виде дробей,
да, и с дробями уже точно работать. Ну, давайте с rational мы не будем работать, мы будем считать,
что мы работаем в интах пока что. Ну вот, значит, прямые будем хранить таким образом, и нам нужно
научиться строить, значит, задавать прямую как минимум по двум точкам. Есть две точки p и q различные,
надо написать такие a, b, c, что они задают прямую, проходящую через эти самые точки по и q. Вот,
ну поскольку здесь на самом деле есть некоторая неоднозначность, из-за того, что это уравнение
остается как бы уравнением тоже прямой при домножении на любую, не на любую константу лямбада,
если все коэффициенты домножу на лямбда, у меня уравнение не изменится, то на самом деле и здесь у
меня этих прямых может быть бесконечно много, проходящих через данные две точки, и мне подойдет
любое из них, мне подойдет любое описание прямой из всех возможных. Ну, давайте напишу вот такое.
Значит, a это разность y, b это разность x в противоположном порядке, а c это px-qx.
Я задаю координацию следующим образом. Я ожидаю, что они подойдут и будут задавать ровно ту самую
прямую, как нам нужно. Ну, даже если это взялось с головы, чтобы проверить, что это подходит,
нужно просто подставить в это уравнение обе точки по и q, проверить, что с данными коэффициентами там
будет нолик. Ну, давайте скажем, для точки p это сделаем. Значит, a это вот это, умножить на p.x это
нужно. Дальше, плюс b это вот это, умножить на p.y, и плюс c, px на qy, минус py на qx. Вот.
Если аккуратно здесь посмотреть, то вроде все должно сократиться. Вот здесь вот py на px сократится
вот с этим минус px на py. Дальше qx на py. Вот оно с плюсом и с минусом. Ну, и наконец qy на px вот оно
с плюсом и с минусом. Значит, это все равно нулю. Поэтому напрямой, в которой я явным образом вот так
вот задал координаты, у меня лежит точка p. Ну, и аналогично я поставлю в уравнение прямой точку q,
и получится, конечно, что она тоже на ней лежит. Поэтому можно просто как-нибудь выучить вот эти вот,
выучить эти формулы, и тогда по строению точки по двум прямым нужно просто, можно просто писать вот
так. Просто в биле координатки они задают вам a, b, c. Вот. Начну и здесь тоже заметим, что если
исходные координаты были целые, то здесь пока что все тоже целочисленные. А, b, c пока что целые.
Можно, конечно, было бы поделить все координаты a, b, c на некую общую константу. Скажем, чтобы
сделать направляющий вектор этой прямой единичным, чтобы у него была одничная длина. Но тогда здесь бы
пришлось делить это все там на что-то. На корень, за квадрат, за квадрат. И у меня бы сразу a и b перестали
быть целые. Вы давайте пока не делайте этого. Так. Что еще можно про прямую сказать? Если у нас
есть прямая, заданная вот таким уравнением, у нее есть два основных вектора. Это вектор направляющий,
то есть коллинеарный с прямой, и вектор нормальный перпендикулярный с прямой. Пусть нормальный будет
n, направляющий будет l. То есть тогда у нормальной координаты это a, b, а у направляющего координат это b-a.
Вектор нормальный, то есть тут прямой угол. Это направляющий вектор.
Ну почему это верно? Давайте сначала с направляющего начнем. Почему этот вектор
коллинеарен прямой? Давайте возьмем произвольную точку на этой прямой. Пусть у нее будет координат на x,
y. Давайте прибавим к ней вектор l. Соответственно у нас получится x плюс b, y минуса. И заметим,
что если исходная точка лежала на прямой, то есть удовлетворяет уравнению, то эта точка тоже
будет лежать на прямой, то есть удовлетворяет уравнению. Потому что что у нас было? У нас
было ax плюс by плюс c равно нулю. Теперь я к этой точке добавил какие-то там поправочки,
да, плюс b, минуса. И хочу проверить, что эта точка тоже лежит на прямой, потому что прямая
это в точности множество точек, удовлетворяющих такому уравнению. Давайте вот сюда поставим
обновленные координаты. То есть a на x плюс b, плюс b на y минуса, плюс c. Это в точности вот
эта штука плюс ab минуса b, да, то есть она тоже равна нулю. Поэтому мы получили две точки,
лежащие на прямой. Соответственно, направляющий вектор это вектор разности между любыми двумя
различными точками на прямой. В частности подойдет b минуса. Ну еще в частности подойдет, скажем,
наоборот, минус b запятая a. Он будет просто смотреть в противоположную сторону. Ну и значит,
если это направляющий, то перпендикулярный к нему это будет нормальный вектор. Можно легко
убедиться, что n действительно перпендикулярен к l просто потому, что у них нулевое скалярное
произведение. Значит, итак, l это направляющий вектор, а скалярное произведение n на l это что
такое? Это опять ab минус ba, то есть ноль. Значит, n это нормаль. Просто потому, что это
вектор перпендикулярный прямой, значит, это просто нормальный вектор по определению.
Так, ну и вот здесь, да, если я говорю про нормаль, то очень часто нам нужно будет именно, скажем,
единичный вектор нормали или единичный вектор направляющий. Тогда нам нужно будет его
нормировать. В этом случае можно будет поделить обе координации нашего вектора на корень за
квадрат плюс b квадрат. То есть просто я поделил координаты вектора на длину вектора. Длина
вектора будет как раз корень из суммы квадратов в координат. Значит, это будет единичный вектор
нормали. Единичный вектор нормали. Ну и здесь уж, извините, да, если мне нужен единичный вектор,
то у него очень вряд ли будут целочисленные координаты, потому что целочисленных единичных
векторов всего 4, а нормальных бесконечно много. Вот, поэтому здесь мне уже придется
переходить к каким-то не целым доблам или лонг доблам. Ну и, соответственно, извлекать корни. Это вот
первое место, где уже точно нужно переходить к не целым числам. И, соответственно, если я хочу
заводить прямые, у которых единичные векторы, ссори, у которых векторы нормали единичные,
то мне нужно будет поддерживать, что у них все координаты, ну точнее сумма квадратов,
первый-второй координат единица. Я могу изначально в уравнении такой прямой поделить
все коэффициенты на вот этот самый корень, и тогда у меня сумма квадратов a и b станет равна единице.
Давайте напишу, что k это корень из a квадрат плюс b квадрат. Тогда, соответственно, нормировка
это деление, давайте напишу a слешавну k, b слешавну k, t слешавну k. После этого у меня сумма
квадратов первых двух коэффициентов, то есть вот этих двух, центр равна единице, потому что я их
поделил на k оба. Ну и, соответственно, вектор нормали будет просто совпадать с вектором a, b. Вот
какие здесь написаны числа, такие и будут координат у вектора нормали. Мне, соответственно,
ничего потом нормировать не придется. Но это мы сделаем только в случае, если нам реально
нужны векторы нормали, потому что здесь мы переходим к не целым числам. Попросы может быть.
Да, ну пока, пока как бы тут ничего сложного не будет. Значит дальше расстояние точки до прямой.
Есть прямая, есть точка. Давай что-нибудь координат x0, y0. Мне нужно, ну скажем, давайте сразу
найдем и расстояние, и проекцию точкой прямую. То есть вот есть такая точка, мне нужно опустить
перпендикуляр и, во-первых, найти основание перпендикуляра, во-вторых, найти длину, собственно,
того, что мы опускали. Для этого давайте сделаем следующее. Пусть я точка P, пусть n это вектор
нормали, единичный вектор нормали. Тогда, чтобы опустить перпендикуляр напрямую, мне нужно к
точке P несколько раз добавить вектор n, то есть n умножен на какую-то лямду, допустим. Так,
чтобы результирующая точка лежала бы напрямой, а x плюс b y равно 0. То есть это некая точка P плюс
лямда n. Да, мне нужно, чтобы эта точка лежала напрямой. Ну давайте напишем, что значит, что вот
эта точка с такими координатами, что вообще за точка с координатами P плюс лямда n. Эта точка
с координатами x0 плюс лямда a, y0 плюс лямда b. Потому что сложения у нас по координатные. Ну и все,
нужно поставить это в это уравнение, понять тогда, чему равно лямда. Давайте подставим.
A на x0 плюс лямда a, плюс b на y0 плюс лямда b, плюс c равно 0.
Лямду вынесу.
Вроде так. Лямда на a квадрат b квадрат равно минус, да, c, a x0 либо y0. Ну вот мы знаем лямду. И если
вот это изначально была нормированная прямая, то это будет просто единица. Потому что после
нормировки у меня сумма квадратов первых коэффициентов это единица. Значит, это ешная
единица. И лямда равно просто минус a x0 плюс b y0 плюс c. Ну нет, ладно, давайте не буду так
считать. Давайте здесь будет просто a квадрат b квадрат. Пока рано. Вот так оставим. Ну и теперь
значит, что такое тогда расстояние? Расстояние это длина этой проекции, то есть длина вектора ln.
Расстояние от точки p до прямой l, если это была прямая l, это просто длина вектора лямда n.
Значит, ну длина вектора лямда n это модуль лямда умноженный на длину n. Модуль лямда мы знаем,
здесь нужно просто убрать минус и на скобке повесить модуль. А длина n это корень из a квадрат
плюс b квадрат, потому что n это как раз таки вектор с координатами ab. Значит, корень из
a квадрат плюс b квадрат здесь сократится. Останется такое выражение.
Окей? Вот, настояние от точки до прямой. А теперь проекция. Проекция. Ну я не помню,
как это обозначается. У меня пусть будет проекция на l от точки p. Это мы знаем, что это p плюс лямда
n. p плюс лямда n. Давайте забудем, что он единичный. Давайте скажем, что он произвольный.
Если он был произвольный, тогда все по-прежнему верно, и это результирует формулу. А если он
был единичный длины, то у меня вот здесь единица, ну и здесь тоже единица. То есть это верно и в общем
случае, но если изначально все было единичной длины, то я могу забить на знаменатель, потому
что он единичный. Ну и на это я мог тоже забить, потому что он единичный. Формула останется та же,
просто без деления на корень, который будет единицой равен. Так, ну и проекции. Давайте,
наверное, я не буду дописывать эту формулу, потому что понятно, собственно, вот он ответ.
Начальная точка плюс лямда умножить на n, лямда я знаю, n я знаю, ну и все нужно просто как бы
умножить там векторное число, прибавить, и это будет ответ. А поскольку мы знаем здесь все
составляющие этого ответа, то проекцию мы тоже умеем находить.
Так, значит, с точкой прямой мы вроде все сделали. Ну, в частности, позволю себе заметить, что условия
того, что p лежит на прямой равносильны тому, что расстояние равно нулю, равносильны тому,
что вот здесь стоит ноль, то есть числитель ноль, то есть точка удовлетворяет поравнению прямой.
То есть случай, экстремальный случай, когда точка лежит на прямой, здесь все сходится,
это в точности, когда числитель равен нулю. Дальше давайте научимся пересекать две прямые.
Пересечение двух прямых. Соответственно, a1x плюс b1y плюс c1 равно нулю и a2x плюс b2y плюс c2 равно нулю.
Так, как мы будем решать такую систему? То есть, по сути, мне нужно решить такую систему
линейных уравнений, ну и, скажем, сказать, сколько у нее есть решений. Как мы решаем
такую систему, кто-нибудь помнит? Ну, если у нас есть конкретные числа a, b, c, то да, но в компьютере
лучше немножко по-другому. То есть в гауссе может быть такая проблема, что если у вас там кто-нибудь
из этих равен нулю, тогда нужно отдельный ифать. То есть, грубо говоря, какую перемену вы считаете
главной, а какую через нее выражаете. И поэтому, короче, писать это не очень приятно. То есть,
на бумажке, наверное, это проще, но в коде лучше немножко по-другому. Как мы еще решаем систему?
Краймером, да. Для этого мы вводим определитель. Значит, давайте переформулируем все на языке матриц.
Надо решить такую систему уравнений. Значит, она решается в частности методом краймера. Мы, во-первых,
считаем определитель исходной матрицы 2 на 2. То есть это просто a1, b2, минус a2, b1. Дальше мы пытаемся
столбец вот этих свободных членов подставить вместо каждого столбца исходной матрицы и считаем
все такие определители. То есть delta1 это определитель матрицы, где я вместо первого столбца
ставлю столбец свободных членов. То есть это минус c1, минус c2, b1, b2. Ну что это такое? Это там
что-то. b1, c2, минус c1, минус b2, c1. То же самое delta2. Это когда я второй столбец заменяю на столбец
свободных коэффициентов. То есть это определитель матрицы a1, a2, минус c1, минус c2, равно a2, c1, минус a1, c2.
Значит, посчитали определитель. В общем случае, когда здесь матрица еще большего порядка, можно
соответственно столбец свободных членов подставлять вместо каждого столбца, считать все такие
определители. Ну и дальше утверждается тогда, что ответ
x,y это точка delta1 делить на delta, delta2 делить на delta. В случае, конечно, если delta не 0.
Значит, если delta не нулевая, то у нас точка перещения прямых однозначно задана. Вот она
считается по таким вот формулам. Вот что тут написано. Значит, что такое случай delta не равно
нулю. Значит, delta вот оно. Это 1b2 минус a2b1. И это в каком-то смысле, как это называется, мы чуть
позже это подъем. В общем, псевдовекторное произведение нормальных направляющих векторов.
То есть если я напишу здесь направляющий вектор, здесь направляющий вектор и напишу их, ну то есть
это как бы а-ля векторное произведение. Давайте напишу формулу. Если есть два вектора, x1 и y1.
Так, давайте я напишу квадратные скупки, бог с ним.
То вот такое их псевдовекторное произведение это по сути ориентированная площадь прелограмма
натянутого на эти два вектора. Вот есть вектор x1 y1, вектор x2 y2. Я натягиваю на них параллелограмм и
считаю его ориентированную площадь. Она идет со знаком плюсом, если этот поворот положительно, то есть
против всего стрелки с знаком минус, если он будет отрицательный. Вот это дает такой формулой. Ну и
соответственно, да, то есть это как бы объем двумерной фигуры с базисом из этих двух векторов.
И соответственно, равенство нулю вот этого вот определителя, это как раз таки означает, что два
вектора, два направляющих вектора наших прямых, скажем два нормальных вектора, неважно, два
направляющих вектора наших прямых задают параллелограмм нулевой площади. То есть они как бы
ну либо коллинеарны, либо противонаправлены. То есть когда такой параллелограмм имеет нулевую
только если у нас векторы с�想 направлены, либо они противонаправлены, то есть в любом случае
они коллинеарны. А если векторы направляющие коллинеарны то и прямые параллельные, значит у
них ну явно ни одна точка и slack OR 0 либо бесконечно много. То есть либо они параллельны,
либо они просто совпадают. В противном же случае если у нас вектор не параллельный, если у нас
направляющие векторы не параллельны, тогда определитель не 0 и у нас точка, trivial temple
задается вот по такой формы. А если вы не верите или если вы не знаете метод Крамера,
то можно просто явно подставить эти координаты в это матричное уравнение, проверяю, что здесь
все сойдется. Вот, ну и здесь что мы, значит, что мы добились, у нас сейчас координаты могут
быть рациональными. Если у нас исходные все координаты были целые, соответственно, координаты
прямых были тоже целыми, дельточки у нас целые, а здесь возникает отношение дельт. А если мы хотим
считать все точно и без погрешностей, то, ну, можно завести класс rational, который как раз хранит
числитель-заминатель, там, делепехтный наибольший общеделитель, чтобы не плодить лишние, ну как бы
лишние разряды в запястье, вот, и хранить это как дробь. Ну, либо хранить как не целое число, да,
число с плавающей точкой, но тогда могут возникать проблемы какие-то округления, погрешности,
всякие проблемы с точностью, и тогда, в частности, все сравнения нужно произвести с некоторой
опять-таки погрешностью epsilon. А если мы знаем вот эту точку, если мы знаем, скажем, вот эту точку,
и нам еще, нас еще про нее что-то спрашивают, скажем, лежит ли она на какой-то третей прямой.
Мы посчитали эту точку, ну, приблизительно, да, с какой-то погрешностью, и нас спрашивают,
лежит ли она вот на такой прямой. Ну, подставляем ее в уравнение третей прямой, и уже проверяем,
что это не ноль, а, скажем, число, ну, не очень большое, что-то в, там, в интервале минус epsilon
до epsilon, где epsilon что-нибудь, какая-нибудь маленькая погрешность, да, потому что если у нас вот здесь
в определении появляется некая неточность, то есть, соответственно, потом при подстановке этих
неточностей в уравнении прямой, у нас ответ может быть не ноль, а, ну, примерно ноль. Соответственно,
если он попадает в некий маленький интервал, содержащий ноль, то мы говорим, что все хорошо,
и, соответственно, все вот эти проверки надо делать с точностью до epsilon, потому что все равно вот
это вот в ноль очень вряд ли обратится, но где-нибудь рядышком с нулем будет лежать.
Так, окей, прямые пересекли.
Дальше пересечение прямой окружности.
Пересечение прямой окружности.
Ну, тут есть куча способов как это делать.
Значит, самые плохие – это те, которые используют какие-то тригонометрические функции. Скажем,
как можно было бы решать, ну, то есть, по сути, мы должны решить некую систему уравнений,
что ax плюс by плюс c равно 0 – это уравнение прямой, и уравнение окружности – это что x
минус x0 в квадрате плюс y минус y0 в квадрате – это некая r в квадрате, да? Ну, что точек,
удаленных на расстояние r от точки x0 и y0. Вот. Значит, ну, можно действовать по-разному.
Самый плохой способ, я не буду его даже прописывать, это что-нибудь в стиле взять вот
этот вот, ну, опустить проекцию, посчитать, соответственно, этот вектор проекции,
да, вектора, который надо опустить. И потом можно посчитать углы от этой точки, от центра до
точек пересечения, потому что мы знаем этот прямоугольный треугольник. Ну, скажем, что-нибудь
в стиле, давайте повернем этот вектор на некие углы, влево-вправо, против часовой и почасовой,
и получим какие-то вот эти точки, если мы еще правильно умножим этот вектор на нужные длины.
Вот. Это очень плохо, потому что мы переходим к тригонометрии, хотя этого можно, на самом деле,
избежать. Ну и вообще, соответственно, у нас во всем этом, во всей этой планеметрии, у нас есть,
как бы, функции, я бы сказал, трех родов, да, операции математической. Первый — это всякие
умножения, сложения, вычитания, деления. Это, ну, максимальная точность. Если мы живем в доблах,
то это ассоциируется с минимальной погрешностью. Дальше идут всякие извлечения корня. Ну да,
просто извлечение корня. Оно бывает. Вот оно было, когда считали проекцию, нам здесь надо было
извлекать длину корня. Ну, понятно, что это более сложная операция, чем деление, значит, точность
там тоже больше плывет. Ну и самое плохое — это всякие косинусы-синусы, потому что они еще более
неточные. Как они там считаются, вообще Бог его знает. Может там какой-нибудь ряд Тейлора раскладывается,
косинус по ряду Тейлора раскладывается и там где-нибудь обрубается. Ну в общем там с погрешностью
все максимально нехорошо, поэтому тригонометрии лучше тоже избегать, пока это возможно. Вот,
ну здесь это возможно. Итак, опять, как это решать? Можно, скажем, выразить из первого
уравнения х и поставить его сюда, решить квадратный уравнение относительно у, но это работает только
если а не ноль. Если а ноль, тогда нужно разрешать относительно у и подставлять у сюда, но это работает
только если b не ноль. Поэтому, как бы в таком случае, в случае выражения, как бы, ну, наиболее
естественного хода решения надо ифать два случая, соответственно, каждый из них программировать
это не очень хочется. Поэтому мы поступим немножко по-другому. А именно мы посчитаем проекцию центра
на нашу прямую. Это мы уже умеем делать. Давайте это была там точка с, это будет точка п, проекция.
Проекцию мы уже опускали. Дальше. Ну что, надо сказать, что если расстояние от точки от центра до прямой
больше, чем радиус, то решений нет. Если расстояние от центра до прямой l больше, чем радиус, то решений
нет. Значит, это вот такой вот случай, да. Просто прямая лежит дальше, чем окружность. Во-вторых,
если дистанс с точности равен r, то решение ровно одно, у нас происходит касание. Что решение это
проекция. Ну просто п. Такой вот случай. Касание происходит. Ну и третье, если дистанс меньше,
чем r, то у нас будет два решения. Их можно уйти, например, так. Мы знаем точку п, мы знаем направляющий
вектор прямой l. Мы на самом деле знаем вот это вот расстояние. Потому что это катет в
прямоугольном треугольнике. Один из катетов, в котором это расстояние от с до прямой. А гипотенуза
это просто радиус. То есть мы знаем гипотенузу, мы знаем один катет, значит мы знаем второй катет.
Отсюда мы можем просто сказать, что точки пересечения это п, плюс-минус направляющий
прямой умножить на длину этого катета. Значит, мы знаем, собственно, те самые две точки. Давайте
это напишем. Пусть x это корень квадратный из r в квадрате минус дист от c до l в квадрате.
Это как раз длина вот этого катета, длина вот этого отрезка. Вот это x и вот это x. Значит,
в качестве ответа нам нужно отступить от p в обе стороны, x умножить на единичный вектор,
на единичный вектор нашей, ну направляющий вектор нашей прямой. Если, так, кончились у меня буквы,
допустим, будет m маленькая, направляющий единичный, единичный направляющий вектор
для l, то ответ это две точки, соответственно, p плюс xm и p минус xm. Потому что нам нужно отступить
от p в любую из двух сторон на расстояние x вдоль вектора m. Ну, если он единичный
длинный, то это просто вот такая вот добавочка к точке p, плюс xm или минус xm. Вот, ну и все,
мы знаем все точки пересечения. Окей? Кайф.
Так, последняя пересечения – это пересечения двухогружностей.
Пересечения двухогружностей. Первая задается вот таким вот уравнением,
вторая вот таким. Надо найти все их точки пересечения. Так, опять жду ваших предложений.
Наверное, выражать, скажем, x из одного уравнения поставить в другое совсем
убесно, потому что тогда это будет квадратное уравнение, там будут страточные штуки,
мы корни этого уравнения еще в другое подставляем. Найдем уравнение как? Отношение чего?
Сейчас, одну секунду, пытаюсь понять. А, да, я понял, типа вы строите линию центров,
понимаете в каком отношении делит радикальная ось этот самый отрезочек и строите перпендикулярную
к ней. Да, окей, валидная идея, но получить уравнение можно сильно проще. Можно на самом
деле просто вычесть из одного уравнения другое и получить ровно то, о чем вы говорите. Это будет
вот эта прямая, потому что она, ну, как бы множество решений вот этой системы и этой системы,
сдобавленным этим, это одно и то же, потому что при вычитании уравнений у вас решения не
меняются, значит эти две точки также будут лежать на этой прямой. Поэтому, значит, ну,
формально можно сказать следующее, что система вот такая, равносильный системе вот такой.
Ну, потому что, если какая точка x y удовлетворяет этой системе, то она удовлетворяет 1,
потому что вот и она удовлетворяет этому, потому что удовлетворяет этому, и этому,
значит их разности тоже. И наоборот, если какая-то точка удовлетворяла этой системе, то она удовлетворяет
это единицы, и двойки, потому что раз этим, то их разности
это минус это.
Значит, двойки тоже удовлетворяют.
Поэтому множество решений у обеих систем одинаковое.
Значит, вместо того, чтобы решать вот это, мы можем
решать вот это.
От этого множество решений не изменится.
Ну, а если я вычту одно из другого, то у меня как
минимум сократятся здесь x квадрат, y квадрат, и на
самом деле здесь получится просто уравнение прямой,
которое и будет на самом деле вот этой радикальной
осью.
То есть, в случае, если у них есть две точки пересечения,
как раз проходить через эти две точки, потому что множество
решений не изменилось.
Так, ну давайте напишем, что такое 1 минус 2, значит,
x квадрата сократились, здесь будет, не знаю, зачем
2x x1 плюс 2x x2, дальше, плюс x1 квадрат минус x2 квадрат,
плюс минус 2y y1 плюс 2y y2, плюс y1 квадрат минус y2 квадрат
равно r1 квадрат минус r2 квадрат.
Вот такое уравнение.
Это уже уравнение прямое.
Потому что вот x на константу, вот y на константу, ну а это
все одна большая константа.
Если перенести в левую часть, то будет плюс c.
Вот, ну и соответственно все, нужно просто будет пересечь
окружность с вот такой прямой, а это мы уже умеем делать.
То есть, на самом деле, просто одно вычитание и сведение
задач к предыдущей.
Ну и поскольку мы доказали, что множество решений не
меняется, то эта задача ровно такая же, как исходная.
Значит, никаких там дополнительных ифов делать не нужно, никаких
условий больше не надо перебирать.
Единственное, надо понять, когда это, ну настоящая прямая,
когда это не прямая вообще, то есть, когда у нее а равно
b равно нулю.
Это не прямая, если у нее, ну, коэффициенты при a и b это
нули, тогда либо это там, скажем, вообще 5 равно нулю,
то есть, это система без решений, либо это нуль равно нулю
и соответственно любая точка подойдет.
Это будет соответственно в случае, когда окружности
либо концентрические, либо они вообще совпадают.
Вот, ну давайте, давайте, давайте поймем, когда вот
это происходит, когда a равно b равно нулю.
То есть, у меня что, у меня x1 равно x2, а y1 равно y2.
Это в точности, вот эта вот система, равносильна
тому, что мы получили какую-то кривую прямую, ну неправильную
прямую.
Да, потому что раньше мы считали, что прямая нормальная,
ну, какая-то реально задающая некую прямую на плоскости.
И это происходит, если только если хотя бы одна из a и b не
нуль.
Значит, соответственно, плохо, когда у них нулевые
и a и b, а это в точности, да, то есть мы просто смотрим
сюда, а это что такое, это 2x2-2x1 равно нулю только если
у них равны x, b равно нулю, b это что такое, 2y2-2y1 равно
нулю, если только если y1 равно y2.
Поэтому проблемы могут возникать только если у них
совпадают центры.
Ну, давайте тогда, окей, то есть все-таки, наверное,
одна проверка нам будет нужна, в самом начале давайте
сравним, если у них одинаковые центры, то мы понимаем, как
ведет себя ответ.
Если у них одинаковые центры, то это либо концентрические
окружности с разными радиусами, тогда нет решений, либо
это просто одна и та же окружность, тогда решение
это все точки лежащие на этой окружности, так, вопросики,
хорошо, а у нас получится ну просто какая-то прямая,
ну то есть если окружности вот так вот как-то расположены,
то какая-то прямая просто, тоже на самом деле радикальная
окружность, но не пересекаешься ни с одной из них, так, хорошо,
ну и последнее из элементарного, это скалярное и векторное
произведение, давайте я буду писать все-таки векторное
произведение, потому что мне лень говорить много
букв, значит скалярное что такое, есть два вектора,
x1 и y1, x2 и y2, соответственно a и b, скалярное их произведение
две формулы, первая через координаты, вторая через
длины и угол между векторами, длина вектора a на длину
вектора b на костюм с угла между ними, длина на длину
b на костюм с фи, вот, начну это давайте без доказательств,
это когда-то наверняка было, даже в школе наверно,
вот скалярное произведение, значит, что это такое, точнее
зачем это может быть нужно, например, за тем чтобы
понимать какой угол между двумя векторами, вот есть
два вектора и мы понимаем, что скалярное произведение
между ними, мы можем его вот так вот считать, то
есть вот эта формула, грубо говоря, для подсчета, а эта
формула для качества анализа, и поэтому в частности
мы видим, что знак вот этого проведения всего дает
нам как бы понимание о том, какой угол между векторами,
если знак положительный, то значит угол острый,
костюм положительный, если угол острый, если равенство
нулю, значит, вектор ортогональным, угол прямой и соответственно,
если знак скалярный произведения отрицательный, то угол тупой,
костюм отрицательный, давайте°' нарисуем, Buddha
больше 0, угол прямой осенус равен 0, угол тупой осенус
меньше 0. Соответственно, посчитав скалярные произведения
по формуле через координаты, мы можем заключить о том,
каково типа угол между векторами? Острый, тупой или прямой?
Это скалярные произведения. Давайте еще векторные нарисуем.
Опять два вектора A, B с координатами x1, y1, x2, y2. И их векторным произведением
я буду называть вот такую штуку x1, y2, x2, y1. Это как раз та самая ориентированная площадь
параллограмма. Пожалуйста, будьте внимательны. В нормальной математике A, B в квадратных скобках
это нормальное векторное произведение, то есть это вектор, лежащий в перпендикулярной
плоскости, длина которого ровно вот такая. Но мы пока живем в плоскости, то есть вот как бы,
я не знаю, как это лучше обозначить, поэтому буду обозначать смешивая квадратные скобки
наши с обычным пониманием. То есть это вот по сути длина вот того вектора, длина вот нормального
вектора. Давайте нарисую. У меня здесь есть два какие-то вектора на парте. Их векторное
нормальное произведение, оно нормальное в смысле, как бы, в определении обычном,
это вектор в перпендикулярной плоскости, длина которого равна площади параллограмма,
натянутого на вот те два вектора. А нам не нужен будет выход в третье измерение, потому что мы
живем в плоскости, нам как бы не зачем это третье измерение. У нас будет просто написано площадь
параллограмма или длина вот того вектора. Достраиваем параллограмм, считаем площадь.
И более того, этот параллограмм у нас будет как бы ориентированный, и площадь будет ориентированная,
что мы вот этот угол меряем при переходе от A к B. И соответственно, если он по часовой стрелке,
то это отрицательное направление, площадь отрицательна. Если он против часовой стрелки,
то есть в положительном направлении, то у нас соответственно площадь положительна. Ну а площадь
параллограммы это что такое? Это A на B на синус phi, произвление длины на синус угла между ними.
Где phi, вот здесь важно, phi это ориентированный угол. И это угол поворота от A к B. Если он против
часовой стрелки, то все хорошо, угол положительный. Если он по часовой стрелке,
как здесь, то угол отрицательный, соответственно, площадь отрицательная. И поэтому исходя из вот
этой вот записи, исходя из этой формулы, по векторному произведению мы можем понять,
в какую сторону находится направление кратчайшего поворота от A к B. Либо по часовой,
если отрицательный векторный произведение, либо против часовой, если оно положительно.
Опять давайте я это нарисую. Значит против часовой у нас вращение, против часовой,
если синус phi положительен. Значит, если синус phi это 0, то тогда они либо сонаправлены,
либо противонаправлены. Так нарисую. То есть они коллинеарны. Если только если синус phi равен 0,
потому что синус phi равен 0, то в 0 и в π. То есть это как раз 0, это π. Ну и соответственно по часовой
это когда у меня что-то, например, вот такое. Когда кратчайший направление поворота по часовой
стрелке. Вот часовой. Это соответственно синус phi меньше 0. Значит знак вот этого выражения позволяет
мне понять, в какую сторону находится направление кратчайшего поворота. А также мы в частности
умеем проверить сонаправленность двух векторов. Это вот там, когда мы определитель считали в
методе Краймера. У нас определитель был нулевой, если только если векторы сонаправлены. Вот как раз
это случается. Ну вроде с этим все.
Вот, окей. Значит вроде с элементарными всякими штуками разобрались. Теперь давайте
к треангуляциям перейдем. Многоугольников. Ну, пример. Есть какой-то многоугольник странный.
Мы хотим разбить его диагоналями на треугольнике. Диагональ это такой отрезок между вершинами,
не соседними, который целиком лежит внутри многоугольника. Я могу нарисовать, например,
что-нибудь вот такое. Нет, это не интересно. Вот, например, треангуляция. Был исходный нормальный
многоугольник. Я провел в нем какие-то диагонали, не пересекающиеся. Так что теперь все разбилось
на треугольники. Все треугольники в объединении дают исходный многоугольник. Вот, и мне нужно
найти, ну, например, задача такая. По данному многоугольнику найти какую-нибудь его треангуляцию.
Значит, зачем это может быть нужно? Ну, например, последующей причине. Вот представьте, что у вас
есть некое помещение, видим многоугольника, ваша комната это многоугольник, огорожена стенами.
Вы хотите все ваше помещение подсветить лампочками. При этом, когда вы ставите лампочку в какую-то точку,
считая, что у вас все плоское, не объемное плоское. Значит, когда вы ставите лампочку в некоторую точку,
она защищает все, что достижимо, как бы не заходя за стены. То есть вот это вот все она достигнет.
Но как бы вот сюда она уже не зайдет, потому что здесь есть ограничение в виде стены,
и она за угол не заворачивает. И вам нужно, ну, например, поставить как можно меньше лампочек так,
чтобы весь многоугольник осветить. У вас есть, например, какая-то картинная галерея, вы хотите
поставить там лампочки, чтобы все было видно, или каких-нибудь бабушек-охранец, которые будут
стоять и смотреть, чтобы никто на картинах ничего не рисовал. И, соответственно, у каждой бабушки есть
некое поле обзора, соответственно, за углы она ходить не может, потому что она сидит на стульчике.
Вот. Ну и, соответственно, задача, да, нужно как-то, нужно как-то все покрыть. Один из возможных
способов – это отреангулировать наш многоугольник, представить его как объединение
треугольников, но дальше в каждом треугольнике понятно, что можно поставить по бабушке в любой
точке, потому что если у нас есть треугольник, какой бы он ни был, мы одной бабушкой можем
его полностью обслужить. Она все видит внутри этого треугольника, куда ее не поставь. Вот.
Не минимальная, конечно, да. Ну, одно из доступных. Минимальная – это не простая задача,
я даже не уверен, что вообще за пленум решаемая. Вот. Ну, как какое-то. Вот. И поэтому, в частности,
может быть интересна треангуляция. Определение в итоге. Диагональ многоугольника – это
отрезок, соединяющий две несоседние вершины. Две несоседние вершины. Такой, что, ну давайте
формально полностью напишу, все его внутренние точки лежат во внутренности многугольника.
То есть, на самой диагонали, кроме концов, все точки лежат строго внутри многоугольника.
Значит, плохие примеры, чтобы все все поняли, значит, о чем речь. Ну, понятно дело, что если
есть вот такой вот многоугольник, то, конечно, вот это не диагональ, потому что она лежит вообще
целиком вне многоугольника. Что еще может быть? Может быть, что-нибудь вот такое. Так. Сейчас,
одну секунду. Ну да, нет, все нормально нарисовал. Что-нибудь вот такое. И тогда вот это не диагональ,
потому что она частично то там, то тут лежит. И наконец, последний плохой пример. Вот такая
картинка. Когда вы соединили две точки, у вас на этом отрезке лежит другая вершина многоугольника.
Это тоже плохая диагональ, потому что тогда, на самом деле, надо разбить вот на такую и на такую
отдельно. Вот эта большая не считается диагональю, а эта считается диагональю. Отдельные маленькие
кусочки считаются.
Ну и, соответственно, определение на триангуляция многоугольника.
Это, давайте я напишу, покрытие многоугольника не пересекающимися по внутренностям треугольником,
стороны которых это стороны и диагонали. Это ощущение многоугольника не пересекающимися
у внутренности треугольником, стороны которых это либо стороны исхода многоугольника, либо его
диагонали. Стороны которых, стороны или диагонали исхода многоугольника.
Определение более сложное, чем интуитивное понимание. Ну, конечно, надо покрыть его
не пересекающимися треугольниками, где можно проводить как бы в качестве сторон, можно
брать только стороны или диагонали исхода многоугольника. Если формально все проговорить,
то вот оно такое. Определение, значит, если многоугольник задан перечислением своих
вершин в каком-то порядке, если многоугольник задан перечислением своих вершин v1, v2, vn в порядке
обхода, то треугольник v и минус один v и v и плюс один называется ухом. Интуитивно,
если его можно безопасно отрезать. Иначе говоря, если внутри и на границе этого треугольника нет
других вершин. Ухом это не я придумал слово, это более-менее общепризнанная терминология. Уши
если внутри и на границе этого треугольника нет других вершин многоугольника. Ну а смысл ровно
такой, что его можно безопасно отрезать и решать задачу на меньшем многоугольнике. Ну пример
какой-нибудь. Если что-нибудь такое нарисую, например, вот это это ухо. Потому что я взял три
подряд идущие последовательные вершины в нашем многоугольнике. В этом треугольнике, построенном
по этим трём вершинам, ничего больше нет. Никакая другая вершина не лежит ни внутри, ни на границе.
И это как бы и значит, что как раз можно спокойно это ухо отрезать, потому что в нём ничего больше
не лежит. Этот треугольник целиком лежит внутри нашего многоугольника и больше ничему не мешает.
Я могу его спокойно отрезать, это ухо отрезать и дальше треангулировать оставшуюся часть. То есть
я по сути одну вершинку просто исключил из нашего многоугольника. Ну и тем самым как бы у меня
ну задача свалилась, задача попроще на многоугольнике без одной вершины.
Утверждение в любом многоугольнике есть хотя бы одно ухо.
Есть хотя бы одно ухо. И соответственно, если мы докажем, если мы придаём какой-то алгоритм поиска
какого-нибудь уха, то у нас тогда алгоритм триангуляции может быть такой. Давайте найдём
в исходном многоугольнике ухо, отрежем его, получится многоугольник поменьше. Дальше отрежем
от него ухо, получится ещё многоугольник поменьше и так далее и так далее, пока не останемся в конце
треугольник, который сам по себе является своей треангуляцией. Ну доказательства, почему у уха всегда есть.
Индукция по n по числу вершин в многоугольнике, индукция по n. База n равно 3 тривиальная,
это случай, когда многоугольник это треугольник, и он и является и своей треангуляцией, и своим
же ухом единственным. Здесь в частности есть ухо, можем вот это отрезать, это как бы внутри нет
никаких других вершин. Переход. В переходе давайте мы скажем, что обязательно есть хотя бы одна
выпуклая вершина. Есть вершина, угол при которой меньше 180 градусов. Угол при которой меньше p,
потому что если все углы хотя бы p, то там не сойдется необходимая сумма углов. Сумма углов
многоугольника это p на n-2, если все хотя бы p, то значит сумма углов будет хотя бы pn,
противоречие. Что такое угол при вершине? Ну понятно, вот у нас есть некий многоугольник,
что такое угол при вершине? Это вот как бы угол между двумя сторонами, соседними, направлены
во внутренность нашего многоугольника, то есть вот здесь вот угол меньше p, а вот здесь вот угол,
когда мы рисуем при этой вершинке, он больше p, он вот такой, он как бы развернутый, потому что
здесь некая не выпуклость наблюдается, то есть у меня вот внутренняя часть этого угла, вот она,
точнее наружная, она меньше p, она как раз лежит вне многоугольника, а та, которая внутри
многоугольника, она больше, чем p, то есть я как бы пытаюсь перейти от одного вектора к другому за
счет вращения только внутри многоугольника, и вот этот угол я измеряю, какие-то больше p,
какие-то меньше, вот хотя бы один меньше p есть, а иначе, иначе не сойдется сумма углов,
не сойдется сумма углов, которая, как мы наверное помним из какой-нибудь школьной программы,
это всегда p на минус 2, сумма углов на многоугольник всегда ровно такая, вот, значит такая вершина есть,
давайте ее поизучаем.
У сейчас какая-то вершина v и, соответственно, у нее есть две соседние, v и минус 1, v и плюс 1,
предыдущая и следующая. Идеальный случай, если это ухо, если треугольник образует ухо, то все
замечательно, мы его можем просто отрезать, мы его нашли и, собственно, переход доказан.
Значит, что плохого может быть, если это не ухо? Плохо может быть, если где-то здесь лежат другие
какие-то точки, если где-то внутри этого треугольника или одного границы есть некие другие вершины или
какие-то другие точки нашего многоугольника. Ну, смотрите, точек, которые пересекали бы вот эти две
стороны, точнее, сторон, которые пересекали бы вот эти две стороны, у нас нет, по предположению,
которые я не сформулировал. Мы считаем, что многоугольник простой. В любом простом многоугольнике.
Значит, простой — это тот, у которого вот эта вот ломаная, проходящая по всем сторонам,
она не самопересекается. То есть, ломаная, давайте я нашу ломаная периметра, периметра не самопересекается.
То есть, чего-нибудь вот такого у нас нет. Вот это считается, что это неадекватный многоугольник,
мы так и не рассматриваем. У нас многоугольники всегда простые. Соответственно, тогда у нас,
ну, как ломаная устроена, где-то начинается, вот так вот проходит, вот так идет и дальше
где-то заканчивается. Понятно, что она не может пересечь, как бы она не может зайти здесь, не
может зайти здесь, потому что это стороны. У нас тогда было бы самопересечение. Значит, такого не
бывает. Проблема могут быть только вот с этой вот диагональю, потому что это не сторона,
и сюда может кто-то заходить. То есть, например, может быть что-нибудь вот такое. Вполне себе
такой многоугольник может быть. И у нас тогда во внутренности нашего треугольника кто-то есть.
Это плохо. Вот. Ну, соответственно, давайте пропишем два случая. Первый, что если это действительно
ухо, если v и минус 1 v и v и плюс 1 это ухо, то победа. Мы уже все доказали, потому что надо было
доказать существование хотя бы одного уха. Значит, иначе внутри этого треугольника кто-то есть.
Внутри этого треугольника кто-то есть. Может быть несколько точек. Давайте нарисуем что-нибудь
совсем плохое. Вот такие точки, вот такие. Короче, что-нибудь очень плохое может быть
внутри этого треугольника, может быть много точек. Так вот, давайте тогда среди всех плохих точек,
среди всех вершин, находящихся внутри нашего треугольника или на его границе, выберем самую
далеку от прямой v-1 v-1. Среди всех вершин многоугольника,
попадающих в треугольник вот этот самый. Выберем самую далекую от прямой нашей севдодиагонали.
Ну вот здесь это, видимо, будет вот эта точка. Пусть такая некая вершина q, ну или давайте
лучше vg. Тогда утверждаю, что v и vg это диагональ. Пусть выбранная точка это vg, тогда v и vg это
диагональ. Выберите диагональ. Еще раз, среди всех потенциально плохих точек я выбрал самую
далекую от прямой, вот она vg, и тогда утверждаю, что отрезок, соединяющий v и с этой самой точкой,
это обязательно диагональ. То есть, что такое диагональ? Это отрезок между вершинами, такой,
что вся его внутренняя часть не пересекается со стороны многогольника, то есть она целиком
внутри многогольника. Значит, если бы это было внезапно не так, и если бы на этом отрезке v и vg...
Так, еще раз, какое у нас определение, что внутренние точки лежат во внутренности
многоугольника. Ну да, смотрите, если предположить, что не все точки этого отрезка лежат в многоугольнике,
то, грубо говоря, у нас должна была быть какая-нибудь вот такая картинка, что где-то
вот здесь вот этот отрезок пересекает либо сторона, либо на нем лежит вообще какая-нибудь
вершина другая. Да, ну потому что у меня понятно, что эти точки лежат внутри многоугольника, а дальше
не все лежат во внутренности, то есть как бы кто-то лежит либо на границе, либо вовне, значит,
ну какая-то страна точно его пересекает. Ну извините, если вообще здесь лежит какая-то другая вершина vk,
то мы неправильно выбрали vg, потому что vk это другая вершина, лежащая внутри треугольника v-1,
просто потому что она лежит на этом отрезке, и она более далекая от этой стороны. Значит,
почему vk более далекая от прямой v-1 v и плюс один? То есть на самом деле нам достаточно показать,
что вот по эту сторону от прямой, точнее мы знаем, что по эту сторону от прямой нет других точек,
нет других вершин нашего многоугольника, просто потому что vg самая далекая от той прямой,
значит, нет никаких других вершин по эту сторону от прямой внутри этого треугольника. Ну собственно,
значит, как раз что в частности на этом отрезке других точек нет, поэтому здесь не может быть
никаких других точек. Вот, а если бы здесь было какое-нибудь пересечение со стороной,
что-нибудь вот такое было бы, например, ну тогда понятно, что хотя бы один из концов этой стороны
лежит обязательно вот в этой полуплоскости, потому что если оба конца лежат вне полуплоскости,
то этот отрезок не может пересекать этот отрезок, потому что вот этот целиком в нашей
полуплоскости лежит, ну и значит тогда один из концов должен опять-таки лежать в этой
полуплоскости, ну иборле того он должен лежать в этом треугольнике, потому что
Короче говоря, никаким образом этот отрезок не может лежать вне нашего многугольника,
на нем нет других вершин, и он не может пересекаться никакой другой стороной,
потому что если пересекался, то, скажем, вот этот его конец должен был бы быть той самой вершины,
куда мы провели вот это ребро, потому что это более далекое от этого.
Давайте что-нибудь из этого напишем.
На 3 ВИ, ВЖ не может быть других вершин.
Так как иначе ВЖ была бы не самой далекой прямой.
И более того, этот отрезок не может никим пересекаться никакой стороной.
Отрезок ВИ, ВЖ не может пересекаться никакой другой стороной,
не может пересекаться другой стороной многугольника.
Ну как раз вот по этим причинам, что раз точка пересечения лежит дальше от этой прямой,
значит хотя бы один из концов этой стороны лежит дальше от этой прямой, чем ВЖ,
и внутри нашего треугольника, потому что иначе было бы сам пересечение.
Так как в противном случае, один из ее концов точно лежит внутри треугольника,
и дальше от прямой выемнуться не выплески, ничем в ВЖ.
Вот, противоречие, потому что ВЖ самая далекая. Ну все, значит диагональ.
А раз мы нашли диагональ, то можем на самом деле нашу задачу разбить на две. Мы можем наш
многугольник представить в виде двух. На то, что там, грубо говоря, выше диагональ и то, что ниже.
Мы нашли некую диагональ, вот она, и соответственно здесь там что-то было еще вот такое.
Бог пойми что. Давайте эту диагональ проведем. Когда мы разбили наш исходный многугольник на
два куска, верхний и нижний, оба эти куска это какие-то корректные многугольники,
значит по предложению индукции, ну в них меньшее число вершин, в каждом из них меньшее число
вершин, значит по предложению индукции и здесь есть ухо, и здесь есть ухо. Так, сейчас, одну секунду.
Кто-нибудь видит проблему? Вот я сказал, что да, они могут проходить вот здесь верно. Может быть
такое, что уши, которые мы нашли, они вот такие, и в обеих частях они как бы корректные,
но во всем многугольнике это не уши, это вообще какие-то отдельные куски.
Верно, ровно так мы и сделаем, да. Значит давайте тогда переформируем утверждение,
что всегда есть хотя бы одно, а если n хотя бы 4, то есть хотя бы два, вот так. Есть хотя бы два уха.
Не пересекающиеся по внутренностям, не пересекающиеся по внутренностям, да, отлично.
Так, все, подправили утверждение, база остается такой же, все стригуем, ну понятно, там одно ухо,
значит что здесь? Тут пока что все, мы не, мы не, мы не, мы не, мы не, мы не, мы не пользовались
существованием ушей, мы доказали, что есть диагонали, вот мы ее нашли. Дальше, мы знаем,
что каждый из двух половинок, это либо треугольник, либо там внутри есть хотя бы два уха,
не пересекающиеся по внутренностям. Если хотя бы одна из них треугольник, то есть вот такая
картинка, а другая не треугольник, то можем просто взять из этого не треугольника два не
пересекающихся уха. Опять плохо, сейчас, на секунду. Да, одно из тех, которые не содержат этой стороны,
да, да, да, действительно. Окей, давайте тогда все случаи аккуратно нарисую, чтобы ничего не
потерять. Самый простой случай, когда у нас обе, обе штуки треугольники. Ну тут понятно, да,
просто у нас как бы два треугольника, они лежат по разные, по разные стороны от нашей стороны В
и ВЖ, понятно, что они как раз все самые два уха. Значит, если один треугольник, а другой какой-то
большой наугольник, в котором хотя бы два уха по предположению индукции, хотя бы два, и причем
эти два уха не пересекаются. Значит, тогда, поскольку они не пересекаются, то максимум один, одно из этих
ушей содержит эту сторону, да, то есть вот этот наугольник и максимум одно из ушей содержит эту
сторону, потому что если хотя бы два, то значит, ну там какая-нибудь точка бесконечно близкая к этой
стороне лежит в обоих треугольниках. Значит, ну в худшем случае у меня есть что-нибудь вот такое,
ухо, и еще вот здесь вот ухо. Тогда я могу взять треугольник, вот этот вот, и одно из тех двух ушей,
которое не содержит этой стороны В и ВЖ. Значит, треугольник, треугольник плюс одно из ушей,
не содержащие стороны В и ВЖ. Вот, ну и в последнем случае, когда у меня оба наугольника какие-то
длинные, вот такие вот, каждым из них есть хотя бы два уха, то выполняется опять то же самое,
в обоих наугольниках есть хотя бы по одному уху, не содержащему вот этой вот стороны. Значит,
они будут корректными ушами в большом наугольнике. Берем по одному уху из обоих частей, из обеих
частей, опять-таки не содержащим стороны В и ВЖ. Поскольку они по предпочтению индукции
внутри не пересекались, значит, хотя бы одно не содержит этой стороны. А значит,
они являются корректными ушами во всем большом наугольнике. Вот, ну все, вроде доказали,
да, значит, всегда есть два уха хороших, не пересекающихся по внутренности. Вот, значит,
на самом деле то, что нам вот про два уха, нам нужно было только, чтобы индукция корректно у нас
прошла, на самом деле содержательная часть вот она, что всегда есть хотя бы одно ухо. И мы более
или менее предъявили алгоритму, как его искать. Так, извините, что задержал? Сейчас, две минуты.
Значит, алгоритм FindEar. Значит, как он работает? Он работает за линейное время. Он берет
наугольник, находит в нем выпуклую вершину вот этой самой ВИ, проверяет этот треугольник на то,
является он ухом или нет. Если не является, то берет эту самую ВЖ. То есть, пока что просто нашел
такой диагональ. А дальше он запускается рекурсивно либо здесь, либо здесь, ищет одно ухо.
За время, так, может быть, плохо, да?
Ладно, давайте, давайте, не буду задерживать. Давайте в следующий раз вот здесь добьем,
как довести это до конца. Спасибо.
