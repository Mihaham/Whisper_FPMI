Добрый день, давайте начнем. В прошлый раз мы с вами начали говорить про классическое
метапрограммирование. Поговорили про такие сущности, как определители типов,
которые позволяют для произвольного шаблонного параметра определить,
содержится ли его констант или нет, содержит ли этот тип ссылку или нет,
является ли он указателем, ну и так далее. В общем, обсудили общую схему того,
как можно писать определители типов. И также поговорили про то, как писать
модификаторы типов, то есть как, соответственно, изменять шаблонный параметр, который мне
передали на вход, то есть как избавляться от константности, если она вдруг там внутри
зашита, как избавляться от ссылочности, указатель, и так далее. Тоже обсудили такую общую схему.
Также поговорили про if-const-export, который позволяет, зависимо от каких-то условий,
которые проверяем на этапе компиляции, компилировать какую-то ветку кода или нет.
Ну и в конце мы с вами остановились на том, что написали на самом деле свою собственную
реализацию функции stdmove. Напомню, в чем там в чем-то стоит суть. Функция stdmove делает так,
что передаваемый ей на вход объект должен восприниматься как R-value. То есть я хочу, чтобы
в результате вызвать stdmove, у меня был бы прежний объект, но при этом он, с точки зрения компилятора,
воспринимался бы как R-value. Это можно сделать, если выполнить так называемое
преобразование L-value to R-value. Грубо говоря, если вам податься на вход R-value, то мы оставляем
его без мнений. Если на вход подается какой-нибудь L-value, то мне нужно
преобразовать его в ссылку на R-value. На самом деле, давайте ссылаться на этот объект,
как будто бы это был R-value. Как мы этого достигли? Тут три ключевых момента. Первый момент,
что мы принимаем. Так как функция stdmove может принимать в себя все что угодно, то есть произвольную
категорию значения, будь то L-value, будь то R-value, поэтому мы принимаем объект по универсальной ссылке.
Дальше, что мы понимаем? Мы понимаем, что функция stdmove должна вернуть в любом случае, чтобы ей не
передали, она должна вернуть ссылку на R-value. То есть она должна вернуть объект, как если бы он был R-value.
Соответственно, что мы для этого делаем? Понятное дело, что универсальная ссылка устроена таким
образом, что она может в теории сохранить в тип T какую-то ссылку. Например, тип T может
быть выведен как int амперсан, может быть выведен как int или там может быть выведен как const int амперсан.
То есть в зависимости от того, содержит ли у меня тип T ссылку или нет, понятное дело, что
возвращаемое значение будет от этого меняться. То есть я не могу тут просто написать возвращаемое
значение, например, t двойного амперсана. Почему? Потому что мы знаем по правилам сворачивания
ссылок, что если у меня вдруг внутри t зашита амперсант, тогда амперсант плюс два амперсан,
в итоге один амперсант, тогда у меня будет возвращать обычную L-value ссылку, а не R-value ссылку.
Так вот, чтобы эту проблему победить, я воспользовался модификатором типа RemoveReference. Что я сказал? Если
там вот внутри типа T зашита какая-то ссылка, то ее нужно убрать. То есть, грубо говоря, после
выполнения вот этого модификатора типа у меня тут вместо этого, вместо вот этого псевдонима,
подставляется тип, на котором не будет висеть никакой ссылки. То есть это будет просто-напросто тип,
возможно, с каким-то const-квалификатором. Ну и дальше уже вот на этот голый тип,
на котором не навешано никаких ссылок, я навешиваю двойной амперсант. Ну если
навешание двойного амперсанда на тип без ссылок, да, дает мне краски R-value ссылку.
Вот ровно то, чего я хотел. В return делаю по сути то же самое. Точнее делаю ровно то,
что от меня требуется. Я беру X и применяю к нему статикаст вот к нужному типу. Это
RemoveReference T двойной амперсант. Окей, вспомнили? Хорошо, давайте потихоньку поднимать планку и
поговорим про... теперь поговорим про функцию SDForward. Стэмплот класс T. Значит, есть функция
forward, которая что-то принимает, что-то возвращает, ну как-то работает. Вот, ну это сначала вспомним,
что вообще делает SDForward. Вот, какой вообще типичный кейс использования SDForward? Ну,
на самом деле, чуть ли не единственный кейс правильного использования forward. Значит, есть
у меня есть какая-то функция, да, пусть есть функция F, тоже шаблонная. Стэмплот класс T. Вот,
функция F принимает T по универсальной ссылке. Вот, мы принимаем T по универсальной ссылке,
дальше вдруг и дальше в какой-то момент. Я хочу этот X передать какую-то другую функцию, да, то есть,
ну что означает forward? Forward буквально означает передать вперед, да, то есть, ну,
пробросить дальше. Вот, собственно, forward как раз таки используется тогда, когда мне
нужно аргумент функции, пробросить куда-то дальше, причем не изменяя его самого, да, то есть,
если мне вдруг передали lvalue, я хочу передать дальше как lvalue. Ну, как lvalue, как ссылку на исходный
объект. Если мы передали как rvalue, я хочу, чтобы он не дальше, он пошел как rvalue. Вот, то есть,
самые типичные кисли использования это такой. Значит, я пишу F, вызываю какую-то другую функцию,
допустим G, и передаю туда с помощью SD forward, причем обязательно передаю вывезенный тип T, да,
и дальше передаю туда X. Вот типичный пример использования SD forward. То есть, SD forward что
делает? Смотрите, тут прикол в том, что X, X это переменная. Как, я надеюсь, мы с вами помним,
переменная это всегда lvalue, да. То есть, смотрите, если я тут просто напишу G от X, то аргумент X,
функцию G будет всегда передаваться как lvalue, да. Ну, а что если функция G умеет принимать только
rvalue, да, и на самом деле изначально функцию F я передавал rvalue, вот. То я бы хотел, чтобы на самом
деле, вот, если я передал функцию F в X как rvalue, я хотел, чтобы он и дальше, а функцию G тоже
передавался как rvalue. Знаете, вот такая вот получается, такая вот бешевная передача, да, то есть,
то, что я передал в F, то же самое должно передаться в G. Вот как раз таки, как раз таки этого и
добивается SD forward. То есть, грубо говоря, SD forward делает следующее. Если я X изначально, если я в X
изначально передал lvalue, да, то и, соответственно, функцию G он должен передавать как lvalue, да, то
есть, не изменен, то есть, тип не без изменений. Если же я в качестве, если же я в аргумент X передал
rvalue, да, то и в G он тоже должен передавать rvalue. То есть, forward, то есть, forward превращается в
в этом смысле в move, да, то есть, если изначально X был lvalue, то forward просто-напросто возвращает
исходный X. Если же X изначально был rvalue, то я должен передавать, то SD forward ведет себя как SD
move, да, то есть, мы говорили, что forward – такой условный, условный move. Ну и, наконец, как forward
понимает, как forward понимает, что было изначально lvalue или rvalue, ну, как раз таки, вот по выведенному
типу T, да, то есть, мы с вами помним, как работает универсальная ссылка. Если я в универсальную ссылку
передавал rvalue, то тип выводится без имперсанда, да, допустим, int. Вот, если же я в аргумент X
передал lvalue, да, то тогда у меня универсальная ссылка, точнее, шаблоны параметра T выводится как
ссылочный тип, да, тогда у меня выводится int ссылка. Вот, ну и в зависимости от того, что мне передали
int или int ссылка, ну, точнее, что forward передали, да, сюда int или int ссылка, он, соответственно,
либо делает SD move, либо не делает SD move. Окей? Хорошо. Ну, давайте в связи с этим подумаем, в связи с этим
подумаем, что нам нужно написать. Давай, ну, самое простое, наверное, начать с того, а что должен
возвращать SD forward? Вот, смотрите, я в SD forward явно, вот, обратите внимание, еще один момент, в SD forward
я всегда тип передаю явно, то есть, я всегда указываю шаблонный параметр, с который я вызываю forward,
да, иначе у forward нет никакого шанса понять, а что же изначально объект X был, да, потому что X тут
в данном контексте всегда будет lvalue, поэтому, чтобы с forward понять, что делать, мы, соответственно,
всегда передаем шаблонный параметр t. Так вот, смотрите, смотрите, чего хочется, если вдруг t это lvalue
ссылка, да, если вот тот тип t, точнее, вот этот тип t, который сюда передал, если это lvalue ссылка, то я хочу
возвращать, то я хочу возвращать, собственно, lvalue ссылку, если t это rvalue ссылка, я хочу, чтобы
тут была rvalue ссылка, точнее, если t это просто обычный тип, то я хочу, чтобы тут возникала
lvalue ссылка. Что я тут могу написать такого, что ведет себя именно так, как я хочу?
Ну, смотрите, я хочу применить какое-то преобразование к f, к t, давайте, вот, смотрите, давайте так, вот, я
условно напишу, как-то, давайте так, f с крышкой, да, я хочу применить такое преобразование к t, ну, или давайте,
я хочу такое преобразование, которое из вот такой t делает inte двойного амперсанта,
которое из int двойного амперсанта делает int двойного амперсанта,
и которое из int один амперсант делает inte один амперсант. Что это за преобразование?
что
да согласны ли вы что если я просто вот
этому типу применю два персанда
допустим и два персандаgrund
apho
да или если же моего баточатого
cinmot물 получу один апперсант по
правилу сворачивания ссылок chat
на самом деле возвращать значений все
просто мне нужно просто вернуть это
двойной персант
потому что если это содержится какая-то
какая-то ссылка, то ссылка станет той же самой. А если в t не было ссылок, то это будет t-двойная ссылка.
То есть ровно то, чего я хочу. Так, окей. Так, ну и, соответственно, ретёрн.
Ретёрн более-менее тоже понятен. Делаем статик cast к t-двойной
персант от x. Статик cast к t-двойной персант x. Хорошо. А вот теперь давайте
разбираться с принимаемым значением. Кто принимает sd forward?
Ну, смотрите, на самом деле тут, чтобы понять, что принимает sd forward, нужно, в общем, нужно
понять, в каких контекстах используется sd forward. Смотрите, опять же, sd forward используется всегда
в контекстах, когда у меня есть какая-то переменная, когда у меня есть какой-то аргумент,
который был принят ранее по универсальной ссылке. И дальше я этот аргумент передаю в sd forward.
То есть, на самом деле, что всегда передаётся в sd forward? Да, смотрите, обратите внимание, что в
sd forward всегда передаётся l value. Потому что forward всегда используется в паре в связке с
универсальной ссылкой. Вот, если он всегда используется в связке с универсальной ссылкой,
то, соответственно, ему на вход всегда передают l value, то есть всегда передаёт аргумент
какой-то функции. Понятно? Вот. Поэтому for всегда принимает lvalue.
Всегда принимает lvalue. Поэтому, вообще говоря, можно было бы, наверное, написать
тут что-то наподобие такого. Типа t&x. Вот. Можно было бы написать
что-то наподобие такого, и в целом, более-менее, это бы работало. Вот. Но на самом деле,
в стандартной библиотеке это реализовано, эта штука реализована немного иначе.
Ну, по следующей причине, смотрите. Опять же. Мы с вами
говорили о том, что forward работает только так и не как иначе. До sout HIV,
и я forward обязательно должен передавать шаблонный параметр. Вот. Вот это вот
шаблонный параметр в треугольных стелках t, и я всегда должен передавать явно.
Вопрос, что произойдет, если я вот в такую реализацию не буду передавать
явно шаблонный параметр? Ну, смотрите, если я в такую реализацию явно не буду
передавать шаблонный параметр, то у меня в качестве typo-t, в качестве typo-t
всегда будет уводиться какой тип.
Ну, всегда будет вводиться тип без имперсанда, да?
Представьте себе, что, например, тип XA — это int.
Инт-ссылка или просто тип XA — это int.
Если тип XA — это int, то, соответственно, если я буду
передавать сюда, то в качестве TpT мне всегда будет вводиться
просто int.
Потому что X — это будет просто ссылка на int.
Понятно?
А если в качестве TpT всегда будет вводиться просто
то, соответственно, тут я всегда... то forward будет работать, по сути, всегда как sdmove.
Поэтому, чтобы запретить вот такие вот вызовы, чтобы запретить пользователю вызывать forward
без указания, без явного указания шаблонного параметра, можно написать вот так.
Точнее, стоит писать вот так. Давайте я тут напишу std
removeReference от t, ссылка x. Вот. Вот. Почему это гарантирует, что я std forward всегда могу вызывать только так и не как иначе?
Потому что если я вдруг тут не напишу, если я вдруг тут не укажу явно шаблонный параметр,
тогда у компилятора возникнет следующая задача. Ему нужно будет тут в качестве типа t, ему нужно будет тут что-то подставить в качестве типа t,
чтобы будет подходить по тот вызов. Вот. Но, естественно, эта задача для компилятора не решаемая.
Почему? Потому что, смотрите, в теории, потому что, смотрите, removeReference, потому что ему нужно понять,
во-первых, для каких типов t... Допустим, представьте, что я туда в качестве x передаю int.
Вот, представьте, я передаю int. Тогда компилятору нужно понять следующее. Ему нужно решить вот такую задачу.
removeReference t равно int. То есть ему нужно понять, для каких типов t вот эта штука будет давать int.
На самом деле, эта задача не то чтобы разрешимая. Почему? Потому что ему надо заглянуть в шаблонный класс removeReference,
подставлять туда различные типы. То есть ему нужно вообще подставить туда всевозможные типы,
чтобы понять, для какого типа t вот эта штука дает int. Понятно? То есть ему нужно явно
проинстанцировать все классы, чтобы понять, а в каком же случае, на самом деле, у него действительно
будет храниться ваполи type типа int. Это, во-первых. А, во-вторых, на самом деле, у компилятора может
быть, на этапе вызова stfors, у него может не быть полной информации, а вообще всевозможных
специализациях этого класса. Потому что с класса это может быть как-то специализирован. То есть я
могу указать, что, например, для вектора stmoveReference тоже дает int. Таких ситуаций, естественно, компилятор
тоже обработать не сможет. Ну или просто представь себе, что у меня stmoveReference, там, допустим,
для нескольких типов, допустим, не знаю, для int, для вектора int, не знаю, для дека int, выдаёт нам
на выход int. Тогда тут задача тоже неоднозначно решается. В таком случае компилятор не делает
никакого вывода типов. В этом случае, если я дописал stfors без написания аргументов, компилятор
просто нам пожалуется, он скажет, что я не знаю, какой тип мне выведете. В этом контексте тип t не
выводим. Окей? Потому что вот эта задача, она сложная. Ему нужно просто посмотреть на этот шаблонный
класс, подставить всевозможные типы и понять, при каких типах t у него там будет int. Естественно,
компилятор такими вещами заниматься не будет. Ему нужно всегда четко понимать, а вот какой
конкретно шаблонный класс нужно инстанцировать. Окей? Есть ли вопрос? Хорошо. Давайте тогда двигаться
дальше. И следующие ключевые слова на очереди это decal type и decal val. Давайте поговорим про них.
Смотрите, decal type это очень интересное слово ключевое, которое означает следующее. Decal type может
применяться либо к переменным, ну, идентификаторам, либо к переменным, либо к выражениям. И в зависимости
от этого decal type ведет себя чуть-чуть по-разному. Давайте рассмотрим сначала самый простой случай,
когда decal type применяется к имени переменной. Вот. Как это работает? Смотрите, если я напишу decal type,
если я напишу decal type от какой-то переменной, то на месте вот этого вызова, на месте вызова
decal type подставится тип, с которым объявлена данная переменная. То есть смотрите, представьте
себе, что у меня есть переменная int x, у меня есть const slot y, у меня есть const int % rx. Вот. Я могу,
смотрите, допустим, я в какой-то момент хочу объявить переменную a, которая имеет ровно такой
же тип, что и x. Вот. Ну, по какой-то причине я хочу, чтобы у меня была переменная a, которая имеет
ровно, ровно, прям тоже самый тип, что и x. Вот. Что я могу сделать? Я могу написать decal type x a
равно нулю. Что пройдет в этом случае? Компилятор во время компиляции программы, он посмотрит на
это decal type от x, посмотрит, какой тип имеет переменная x, вот, прям вот, а с каким типом объявлена
переменная x. Вот. И вместо этого decal type от x подставит конкретный тип int. Вот. То есть в данном
случае вот эта точка, она полностью эквалентной int a равно нулю. То же самое с decal type y, b равно 1.
Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот
Вот. Ну при этом я знаю, при этом я знаю, что..
Этот вектор содержит структуры, у которых есть поле x
Ну представьте в 분들은, что мне есть вектор, у которого есть есть... Ну, представьте в
Что у меня есть вектор
Вектор хранит элементы, точнее структуры у которых есть поле x
Ну при этом тип самого поля x я не знаю
И все что я хочу сделать, это взять исходный вектор
И сделать из него вектор элементов
Ну, где из каждого элемента вектора я достал поле x
Ну грубо говоря сделать следующее
для каждого элемента из V, вот, просто-напросто сделал
lm.x и запихнул его pushback в какой-то другой массив.
То есть, просто-напросто создал копию массива V,
но при этом скопировал не сами элементы, а скопировал
только поля X.
Смотрите, какая тут может быть проблема.
Я написал эту функцию шаблонной, и проблема тут заключается
вот в чем.
Если у меня вектор содержит произвольную структуру,
в которой есть поле X, я не знаю, какого типа эти
поля X.
Все, что я знаю, это вектор содержит объекты, структуры,
у которых есть поле X.
Какого типа эти поля структуры, я не знаю.
Но, смотрите, мне же нужно как-то будет в этой строчке
объявить результирующий вектор.
То есть, мне нужно сказать, что вектор будет содержать
элементы того же типа, что и поле X у элементов вектора
V.
В этом случае я могу как раз-таки воспользоваться
трюком с decal type.
Я могу написать, если вектор содержит те же самые типы,
что и тип у какого-то элемента вектора, у поля произвольного
элемента вектора.
Тут конкретно я беру нулевой элемент вектора, говорю,
обратиться к полю X и взять его тип.
Окей?
Смотрите, тут важно понимать то, что decal type ровно как
и sizeof, ровно как и операция noexcept, decal type не вычисляет
то, что находится у него внутри круглых скобок.
В теории у меня вектор может быть пустым, но даже если
вектор пустой, то вот эта строчка не приведет
никакой ошибки.
Почему?
Потому что на самом деле эта штука не вычисляется,
она же анализирует с компилятором.
То есть компилятор просто-напросто чисто формально смотрит,
ага, есть вектор.
Окей.
К вектору можно применить квадратные скобки?
Да.
К вектору можно применить квадратные скобки.
Окей.
А эти квадратные скобки что возвращают?
Ну, квадратные скобки у вектора возвращают const, там, const
s ссылка.
Да.
То есть он видит, что квадратные скобки возвращают const
100%.
Окей.
А если я к вот этому объекту применю точка X, то какого
типа будет эта переменная X?
Ну, соответственно, там, допустим, переменная X будет
иметь тип int.
Вот.
И поэтому вместо вот этого decal type компилятор подставляет
int.
Окей.
То есть компилятор просто-напросто анализирует это выражение.
Вот.
Он просто-напросто думает, ага, а что является возвращаемым
типом вот этого выражения?
Вот.
И, точнее, не возвращаем тип, а что является, точнее,
с каким типом объявлена вот эта переменная X, которая
относится к элементу v0.
Вот.
Ну и, соответственно, просто-напросто тут создается вектор из вектора
элементов, которые совпадают по типу с полем X элементов
вектора v.
Вот.
Ну и дальше я просто-напросто делаю pushback value.x для каждого
элемента вектора v.
Окей.
Нормально?
Да.
Да.
Да.
То есть можно при написать const decal type at X, звездочка
p равно, не знаю, address x, как-то так.
Да.
Ну decal type at X это, ну просто, можно считать, что это обычный
тип, на который можно вешать константности, ссылки,
звездочки и так далее, и так далее.
Вот.
Так.
Еще вопросы.
Окей.
Теперь.
Вот это то, что касается применения decal type к переменам.
Значит, еще раз.
Да.
Если я применяю decal type к какой-то переменной или к
на самом деле идентификатору, то он просто-напросто возвращает
тип этой перемены или тип этого идентификатора.
Вот.
Decal type ведет себя чуть иначе, если я применяю decal type к выражению.
Да.
Ну что значит выражение?
Ну выражение значит, что некоторая вычисляемая последовательность
операции оперантов.
Вот.
Ну то есть условно, если я напишу decal type at X, он не вернет
тип, с которым объявлен X.
Если я напишу decal type от X плюс X, то decal type будет
вести себя иначе.
Как?
Ну вот, собственно, все показано на слайде.
Смотрите, decal type анализирует выражение и смотрит на возвращаемый
тип.
И вот тут смотрите, важно.
Если возвращаемый тип, если возвращаемый тип выражения
— это просто, ну, если возвращаемый тип выражения — это просто
какой-то тип, ну, например, ну, не знаю там, сложение
двух интов — это int.
То в этом случае decal type в качестве типа подставляет
ну просто, просто сам тип.
То есть просто int.
Вот.
И если же выражение возвращает ссылку, вот это вот важный
момент, если выражение возвращает ссылку, lvalue-сылку, то
и тип выводится как lvalue-сылку.
Ok.
Вот.
Если же выражение возвращает, возвращейт, lvalue-сылку, если
выражение возвращает lvalue-сылку, ну или возвращает
так называемое X-value, вот, то decal type, то decal type
подставляет тип с двойным амперсандом.
Ну, вы можете сказать, ну, как бы, ну, а что изменилось?
А изменилось следующее.
Смотрите, если я пишу декл-тайп от x, ну, допустим, представьте
себе, что x объявлено так, x равно 0, то вместо декл-тайп
будет подставлен просто нам просто int, да, почему?
Потому что x объявлен стипом int.
Далее, если я напишу декл-тайп от плюс-плюс x, то смотрите,
что происходит.
Вроде как плюс-плюс x и x это одно и то же, да, ну,
мы уже говорили о том, что плюс-плюс x возвращает
самый исходный x, да, вот, но с точки зрения декл-тайп
это разные вещи.
Почему?
Потому что это декл-тайп, примененный к переменной,
а это декл-тайп, примененный к выражению, а что возвращает
это выражение?
Это выражение возвращает ссылку на int, да, вот, поэтому
декл-тайп тоже выведет тип как int ссылка.
И еще один момент, возможно, странный.
Есть на слайде, да, есть, вот он предпоследний.
Если я применю декл-тайп к скобках x, что это такое?
Это, смотрите, вот этот декл-тайп, он применяется к переменной,
а вот этот декл-тайп применяется к выражению, к выражению,
который состоит из круглых скобок, и в которых написан
внутри x.
Понятно?
То есть вот это, вот это, то есть в коде C++, понятно
дело, что это валидная строчка на C++, потому что это выражение,
то есть я могу написать x, могу написать круглые скобки
x, то есть круглые скобки C+, они используются для указания
приоритет операции, да, то есть тут как раз таки
я говорю, что вот в этом выражении, которое состоит
из x, в первую очередь нужно вычислить x, вот, но опять
же, с точки зрения декл-тайп, это уже выражение, это не
переменная, это выражение, и поэтому он его воспринимает
как int&&, ну почему, потому что это выражение вычисляется
в x, да, ну а x это lvalue, как любая другая переменная,
окей?
Вот, ну давайте, ну давайте поупражняемся, вот, например,
я написал декл-тайп вот x+, что у меня выйдется в качестве,
что у меня выйдется в качестве типа, что возвращает x+, да,
x+, то есть x возвращает просто int, да, не ссылочный, не lvalue
ссылок, не lvalue, а просто int, да, просто какое-то временное
значение.
Поэтому в первой строчке в качестве типа выведется
сам, выведется просто int.
Дальше, декл-тайп от plus plus x, int&&, да, это обсуждали,
вот, plus plus x это выражение, которое возвращает lvalue ссылку
на исходный объект, вот, поэтому в качестве, ну поэтому
вместо декл-тайп тут подставится просто int&&.
Дальше, декл-тайп от x+, да, просто int, потому что x+,
Возвращает просто временное значение, просто int, который хранит старое значение x.
Да, поэтому тут просто вы видите int. Даша, декл-тайп с круглоскопкой x.
Да, это обсудили. Круглоскопки x уже воспринимаются как выражение, не как переменная.
Вот, поэтому тут вернется int амперсанат.
Ну окей, декл-тайп, вот sdmove от x.
int двойной амперсанат. Да, почему? Потому что sdmove, как мы с вами обсуждали, вот.
Он возвращает тип с навершением его двойной ссылкой.
Поэтому декл-тайп, ну просто посмотри, что возвращает sdmove, и ну скажешь что.
Ну окей, там возвращается int двойная ссылка.
Окей?
Нормально?
Хорошо.
Так.
Ну и наконец еще одна форма декл-тайп. Это декл-тайп от авто.
Давайте сначала посмотрим на верхний пример.
Ну мы с вами как-то обсуждали, ну как-то, значит, когда мы с вами говорили про шаблоны,
мы с вами говорили про то, как выводится шаблонный параметр.
И дальше мы с вами сказали, что если я объявляю переменный с помощью plate-холдера авто,
то тип авто выводится так же, как шаблонный параметр.
Ну, допомним, как выводится тип авто.
Тип авто выводится так.
Если справа стоит какой-то ссылочный тип, то ссылки отбрасываются, и просто получается тип.
Там константности, ссылки и т.д. отбрасываются, и т.д.
Если же, если же я хочу, чтобы там не отбрасывались ссылки,
я хочу, чтобы не отбрасывались там константности и т.д.,
если я хочу, чтобы тип моей переменной с точностью был бы скопирован с выражения
я или с переменной, которая стоит справа, я могу воспользоваться деколтайп от авто.
Что это означает? Деколтайп от авто означает следующее, что y объявлен так, как если бы вместо
вот этого авто было в точности прописано выражение, которое стоит здесь. То есть вот этот деколтайп от
авто y равно x означает деколтайп от x, y равно x. Деколтайп от x возвращает volatile int. Почему?
Потому что x объявлен как volatile int. Поэтому y будет иметь тип volatile int. Дальше деколтайп
авто z равно plus plus y означает применение деколтайп к plus plus y и ровно такой тип и будет
иметь z. Но так как деколтайп от plus plus y это ссылочный тип, то есть volatile int ссылка, то
соответственно z будет иметь ровно такой же тип. Ну и наконец деколтайп авто t равно круглоскопки x.
Это вот там обсуждали. То есть я применяю деколтайп круглоскопкой x и ровно таким типом
объявляю переменную t. То есть деколтайп авто говорит следующее. Нужно вывести тип,
но не по правилам авто, а по правилам деколтайп. Нормально? Ну и собственно почему это все? На самом
деле вот то, что мы с вами писали до этого. Смотрите, вот тут мы когда реализовали forward,
когда реализовали move, нам тут приходилось дублировать тип, который мы писали
возвращаемые значения. Так вот, эти примеры могли сильно упростить, если просто написали вместо этих
типов деколтайп от авто. И здесь тоже вместо возвращаемого типа можно было просто написать
деколтайп авто. Как работает деколтайп от авто? Точнее так, давайте, мы кажется об этом,
мы явно об этом не говорили, но давайте сейчас проговорим. Я для возвращаемого значения функции
могу использовать тоже авто. Что это будет означать? Это будет означать, посмотри на return,
посмотри на возвращаемое значение return и выведи тип, ну как бы ты выводил шаблонный параметр.
Ну опять же, напомню, что если ввожу по правилам авто, то это означает, что я отбрасываю ссылки,
отбрасываю константности и так далее и так далее. Смотрите, ну тут же мне не нужно отбрасывать
ссылки. То есть я тут на самом деле не хочу, чтобы ссылка отбрасывалась. Я хочу, чтобы вернулся именно
на этот тип, который тут есть. Именно поэтому я говорю, что я хочу вывести возвращаемое значение
не по правилам авто, а по правилам деколтайп. Вот деколтайп, вот авто и так далее. И тогда вот сюда
подставится тип, который будет равен, который будет эквивалентен применению деколтайп к вот этому
всему. Ну а соответственно значение, точнее типом вот этого выражения, является remove reference
t в двойной амперсант, поэтому тут тоже будет remove reference t в двойной амперсант.
То есть возвращаемое значение авто говорит о том, что ну просто выведи тип, отбрось ссылки,
отбрось константности, вот эти все правила и подставь туда нужное
возвращаемое значение. А деколтайп, это авто говорит, что нет, применить деколтайп к возвращаемому
значению return и подставь туда вот это вот значение. Не значение, а тип. Еще один пример применения
деколтайп. Представьте себе, что у вас есть два массива, два массива разных типов, два массива,
которые содержат элементы разных типов. Есть тип T и есть тип U. В чем может быть проблема?
Ну понятно дело, что если у меня, допустим, один массив содержит N3, второй массив содержит
таблы. А да, в чем задача, собственно. Мне подают вновь код два массива, я хочу получить из них
третий массив, который является просто элементной суммой этих двух массивов. Ну грубо говоря,
я сохранил два вектора, в геометрическом смысле два вектора, но при этом один вектор
хранит N3, другой вектор хранит таблы. Я хочу просто и напросто их чисто математически,
геометрически сложить друг с другом. Смотрите, в чем проблема. Проблема состоит в том, что непонятно,
чему будет равен тип результирующего вектора. Ой, простите, да, результирующего вектора или
результирующего массива. Ну потому что в зависимости того, какие типы мне передали,
допустим, если мне передали вектор, который состоит из N2 и другой вектор, который состоит из N2,
то окей, все понятно. Результирующий вектор будет хранить N3. Если мне передали вектор из N2 и
второй вектор из N2, то окей, будет вектор из N2. Ну и так далее. Я хочу, чтобы программа сама
определяла, а какие элементы будет хранить результирующий вектор. Так вот, ровно это,
как раз таки, можно сделать с помощью декл-тайп. Вот у меня есть SRA типов T, у меня есть SRA типов U,
то есть потенциально разных типов. Ну и понятное дело, что я хочу создать массив результатов.
Вот, чтобы создать массив результатов, мне нужно в качестве первого параметра передать тип хранимых
элементов. И вот, собственно, тип хранимых элементов я могу записать вот таким образом. Я могу сказать,
а давай-ка посмотрим, что произойдет, если я сложу два типа, ну если я сложу два объекта типа T и типа U.
Вот, то есть я просто напишу LHS 0 плюс LHS 0, то есть сумму двух элементов, применяю к этому декл-тайп,
и, как раз таки, получаю тип суммы двух элементов. Вот. Ну, тут я еще дополнительно себя защищаю
с помощью применения модификатора removeCVREF от T. Ну, removeCVREF означает, что нужно убрать и
константные, и константы, и волатайлы, и референсы, и так далее. Ну, по понятным причинам, потому что,
если вдруг у меня операция сложения для каких-то типов перегружена, и эта перегрузка возвращает,
допустим, конст стринг, то, естественно, я не хочу, чтобы у меня в массиве были констринги. Вот,
поэтому я говорю, что посчитай, какой тип будет урезетирующей суммы, и вот с этого типа сними
константности, ссылки, и так далее, и просто вставь тот тип, который, ну, просто вставь голый тип,
без ссылок, константности, и так далее. Вот. То есть, таким образом, я создал массив элементов,
я создал массив элементов такого типа, который получится при сложении двух типов, там, двух
элементов типа T и типа U, вот. Ну, и даже спокойно заполняю этот массив суммами LHS и LHS. Окей? Да.
Нет, почему? Нет, погодите, у вас может быть просто такая вот ситуация, что у вас есть,
не знаю, у вас есть интовый вектор, допустим, не знаю, или, допустим, флотовый вектор, есть
дабловый вектор. Вот. Вам нужно получить их сумму. Вот. Вы просто пишете обобщенный алгоритм,
который работает в этом случае. То есть, если есть два типа, которые можно сложить друг с другом,
ну, или, на самом деле, не то, что пукот стайл, ну, смотрите, у вас может быть вполне себе такое,
что, а, ну, представьте, у вас есть массив, допустим, указателей и есть массив интов. Указателем
же можно прибавлять числа и числа? Вот. Ну, и, соответственно, вот в этой ситуации тоже все сработает.
То есть, вы каждому указателю прибавите, прибавится соответствующий сдвиг. Все нормально. Вот. То есть,
это просто универсальная функция, которая позволяет сложить вектора, ну, или массивы разных, массивы
разных типов. Вот. Ну, и ведет себя более-менее предсказуемым образом, да. То есть, у него в качестве
результатов будет ровно тот же самый тип, который получается при сложении типа T, ну, при сложении
объектов типа T и типа U. Вот. А тут, тут есть, тут есть небольшая проблема. Ну, точнее, на самом деле,
большая проблема. Которая заключается вот в чем. Смотрите. Ну, значит, да, тут еще пример,
тут еще пример того, как можно воспользоваться noexcept. То есть, я еще хочу, допустим, дополнительно
завести спецификатор noexcept в зависимости того, является ли сложение двух, является сложение
элементов типа T и типа U noexcept или нет. Но это ладно. Тут есть следующая более, в общем, такая
идеологическая проблема. Вот, смотрите. Представьте себе, что у меня есть какой-то тип T и у меня есть
какой-то тип U. И представьте себе, что в какой-то момент, ну, в программе моей, я хочу завести тип,
ну, точнее, я хочу создать переменную X, ну, хочу завести переменную X, ну, допустим, равную нулю,
которая бы имела ровно тот же самый тип, что дает сложение объектов типа T и типа U. Ну, короче,
я хочу, чтобы тип X, чтобы тип MxA был тип, который получается при сложении объектов типа T и типа U.
Ну, допустим, вот у меня есть переменная TA, у меня есть переменная TB, вот. И я хочу, грубо говоря,
сделать вот декл-тайп вот A плюс B. В чем проблема? Проблема заключается в том, что вот если я хочу
получить тип какого-то выражения, тип какого-то выражения, который применяется, ну, типа какого-то
выражения, мне необходимо для этого либо создать переменные этого типа, либо написать какое-то
выражение, которое бы давало нужный мне тип. Вот, например, как здесь. Чтобы, например, получить тип
сложения двух, чтобы получить тип сложения T и U, да, мне необходимо было получить LHS от нуля и RHS
от нуля. Но все тут потенциальная проблема. А потенциальная проблема тут заключается в том,
что представь себе, что я в какой-то момент написал, ну, представь себе, что мне, на самом деле,
в сумму передали на вход массив нулей. Ну, точнее, не нулей, простите, а массив нулевого размера.
Да, SDRA нулевого размера, SD и второй SDRA нулевого размера. Значит, по стандарту SDRA нулевого
размера, они должны поддерживаться. Ну, причем они поддерживаются так, что, ну, точнее, там, на самом
деле, я уже не помню никак, в общем, там в теории, по-моему, может быть такое, что у массива нулевого
размера нельзя позвать квадратные скобки. Вот. И тогда тут возникает проблема. Да, если у массива
нулевого размера нельзя позвать квадратные скобки, тогда, соответственно, это просто не скомпилируется.
Вот. Ну, хотя, вроде как, хотя, наверное, при сложении двух массивов нулевого размера хотелось бы
получить просто массив нулевого размера, да, хотелось бы, чтобы это скомпилировалось. Вот.
Это первая проблема. А вот вторая проблема, которую я как раз тут описывал, заключается в следующем. Вот.
Мне нужно получить, мне нужно получить переменную, в которой будет храниться результат сложения двух
переменных x и y. И при этом я хочу написать какой-то тип. Хочу написать, хочу написать какой-то тип. Вот.
Но в чем тут проблема? Смотрите, чтобы написать, чтобы создать переменную z, которая имеет тот же
самый тип, что и сложение x плюс y, мне пришлось для этого создать перемены x и y. Ну, а хотя, на самом
деле, возможно, мне сами перемены x и y не нужны. Понятно? Вот. То есть, я хочу создать переменную z,
которая имеет тот же самый тип, что и сложение двух объектов типа t. Вот. Но, соответственно, мне для этого,
чтобы написать декл-тайп соответствующий, мне пришлось создать переменную x и переменную y.
Хотя, они, возможно, мне совсем-совсем не нужны. Тут можно сказать следующее. Смотрите. Ну, а давайте
я поступлю так. Вот. Например, вот в этой задаче. Давайте я не буду создавать переменные a и b,
а напишу вот так. Напишу декл-тайп от t плюс u. Ну, что тут происходит? Я говорю, давайте создадим
t по умолчанию, создадим u по умолчанию и сложим два этих объекта по умолчанию. Пrites посмотрим,
что за типа получится. И ровно этот тип сохраним... и ровно этот тип сохраним в перемену x. Вот. Но,
в чем проблема? Проблема в том, что мне никто и гарантирует, мне вообще никто не гарантирует,
то, что тип t и тип u имеет конструктор по умолчанию, согласны? Вот. А что если, например, тип t и тип
u конструктор по умолчанию не имеют? Ну, тогда получается... если такое выражение, я написать
имею право но все-таки наверное ну все-таки наверное хотелось бы да хотелось бы
уметь анализировать анализировать выражение при этом не создавая никаких
конкретных объектов проблема понятно окей как будем решать вот проблема и
проблема решается с помощью специальной функции decal val давайте про нее поговорим
значит decal val это конечно функция mem смотрите вот все что известно про
функцию decal val вот представь себе что у вас есть специальная функция давайте я
ее напишу я допустим написал std decal val int пугу и скобки
короче все что я знаю про эту функцию это то что она возвращает int все больше я
больше я про нее ничего не знаю или я могу сказать decal val от флот амперсант
опять же все что я знаю про эту функцию то что она возвращает тип флот амперсант
про то как она устроена про то там что она внутри себя делает я ничего не знаю все что я знаю то
что вот она возвращает именно то что мне нужно вот для произвольного типа t для произвольного типа
D kernel reversed ровно то что нужно окей вот теперь смотрите допустим допустим меня есть такая вот
замечательная допустим есть такая замечательные функции декала которая вот чтобы я в нее и передал
она сможет это вернуть выглядит как решается проблема эта проблема решается очень просто есть у
меня есть такая замечательная функция которая может вернуть то что угодно я пишу по первост logic
Декалкайп, потом могу написать декалвал от t плюс декалвал от u, x, ну и допустим ровно нулю.
Что это будет означать? Это будет означать следующее, что тип x будет совпадать с типом вот этого выражения.
А что это за выражение? Тут из этой функции возвращается объект типа t, из этой функции возвращается объект типа u.
Дальше они складываются, и результативающий тип является типом x.
При этом обратите внимание, что я тут вообще не предполагаю ничего.
То есть я не предполагаю, что у t есть конструктор, что у u есть конструктор.
То есть я вообще не знаю, как устроены типа t и типа u.
Более того, я не знаю, как устроена функция декалвал.
Все, что я знаю, то, что декалвал возвращает ровно то, что нужно, именно тот тип, который есть, тип t.
Декалвал мы можем использовать всегда в тех контекстах, когда мы хотим как будто бы создать какой-то объект,
чтобы проверить его возвращаемый тип или свойства возвращаемого типа.
Но при этом мы не можем опираться на то, что, допустим, у типа есть какой-то конструктор,
или, допустим, мы не хотим создавать объектов.
Вот если мы не хотим создавать объектов типа конкретного,
мы можем просто воспользоваться декалвалом.
Тут может возникнуть естественный вопрос.
А как на самом деле устроена декалвал?
Декалвал — это какая-то стандартная функция,
которую я придаю в стандартной библиотеке.
И как так получается, что декалвал может вернуть вообще все что угодно?
Ответ такой.
Как реализовать функцию, которая может вернуть все что угодно?
Ответ — никак.
Все плюс-плюс, есть прекрасная возможность не писать определение функции,
если на самом деле определение функции не требуется.
Так вот, декалвал устроен следующим образом.
Template class T.
Ну и давайте я напишу свою версию декалвал.
Декалвал не принимает никаких аргументов и возвращает все.
Вот это по сути все, что нужно от функции декалвал.
Все тут важно понимать.
Важно понимать то, что функция декалвал
на самом деле никогда не будет вызываться в реальных выражениях.
То есть в выражениях, которые будут реально вычисляться.
Декалвал — это специальная функция,
которая должна быть использована только в так называемых не вычисляемых контекстах.
То есть в контекстах, когда вычисление самой функции не требуется.
Ну какие это контексты? Мы с вами уже про них знаем.
Например, sizeof.
Это контекст, например, noexcept.
То есть если я просто хочу проверить какие-то свойства,
то есть просто-напросто операции, которые проверяют свойства,
они вычисляют выражение.
Или, например, decaltype.
Декалtype тоже не вычисляет выражение,
он просто-напросто его анализирует.
А если компилятору нужно просто-напросто проанализировать выражение,
то естественно и определение функции ему не нужно.
То есть компилятор просто-напросто смотрит на объявление функции,
ага, в функции декалвал,
она возвращает тип T2n.
Ну все замечательно.
Значит она возвращает то, что нужно,
или она возвращает T2n.
Я могу это использовать для проверки нужных мне свойств.
Окей? Да.
Ну да, нет, не то что это я.
Там скорее всего ошибка линков.
Если вы просто-напросто в коде напишите,
вызовут функции декалвал,
в каком-то вычисляемом контексте,
то получите ошибку компиляции, ошибку линковки.
Потому что вы вызовете функцию, у которой нет определения.
То есть опять, функция декалвал,
это по сути та же самая функция,
это еще одна из такой череды функций,
которые обманывают компилятор.
То есть функция декалвал говорит,
да, окей, я там это возвращаю, именно это.
Вот, как бы, можешь не переживать.
Окей?
Такой немного тонкий вопрос.
Как вы думаете, зачем тут возвращать именно T2n%?
Ну то есть почему бы тут не написать,
просто-напросто...
Т.
Да.
Какая перегрузка?
Не, ну смотрите, как бы,
если я напишу,
если я напишу,
допустим, декалвал от
int%
то тут в качестве возвращаемого значения будет
стоять int%.
Вот. Ну то есть тот тип, который я передам сюда,
он в точности,
он будет стоять
в точности,
он будет стоять в точности,
он будет стоять в точности,
а я передам сюда,
он в точности скопируется вот сюда в возвращаемое значение.
Я то есть если sandwichу декалвал от
tmp%, то у меня here будет
в возвращаемом значении int&%
если я напишу int%
то у меня будет2tnt%,
если напишу int'
то в возвращаемом значении будет un.
То есть вам кажется, что я ровно это и хочу.
Чтоб функция декалвал возвращала ровно То, что я прошу.
Ну вот почему на самом деле
в библиотеке, почему на самом деле лучше возвращать именно этот двойной амперсант.
На самом деле тут проблемы в следующем. Если я возвращаю t,
то тут, возможно, следующая проблема. Представь себе, что я вызываю декалвал
для типа t, у которого нет ни конструктора копирования, ни конструктора перемещения.
Тогда у компинатора возникнут вопросики. Погоди, вот ты вызываешь функцию декалвал
для типа, у которого нет ни конструктора копирования, ни конструктора перемещения.
У компилятора возникает вопрос. Погоди, а как тогда этот объект t вернется сюда?
Логичный вопрос. Вот у меня есть функция декалвал, которая возвращает какой-то объект,
который нельзя ни скопировать, ни переместить. То есть, грубо говоря, компилятор понимает,
ага, этот объект, видимо, как-то создается внутри функции декалвал,
ну или как-то он его получает и дальше возвращает наружу.
И соответственно, компилятор вот тут должен подставить какой-то код,
скопировать из функции вот сюда, или переместить из функции вот сюда.
upport.otago.ru Но если компилятор видит, что у типа нет ни конструктора копирования,
ни конструктора перемещения, то он задаст вопрос.
Хорошо, а как я это должен сделать? И вот тут возникнет ошибка компиляции.
Потому что компилятор скажет, погоди, тип не копируемый, тип неперемещаемый,
поэтому из функции, из этой функции, вот сюда я не смогу поместить объект. Понятно?
exploit()
Так, смотри еще раз. Чего анализ?
Попустим, компилятор анализирует вот такое выражение.
Давайте проанализируем компилятор. Что понимает компилятор?
Чтоб понимает что тут вызывается функция f, дальше вызывается функция g
дальше кот 거의 готова bater deeds
и только потом крь Mountaintest
то есть он же не дурак, он понимает, что из функций объект должен как-то вернуться вот в это место.
Естественно, компилятор задаётся вопросом, типа, а вообще, возможно ли из функции вернуть этот объект или нет.
То есть вообще объект нужно скопировать сюда или объект нужно переместить сюда или нет.
Поэтому, чтобы у компилятора не возникало таких вопросов,
я пишу это и двойной персант.
Почему компилятор в этом случае не будет никаких вопросов?
Потому что если функция декалвал как-то смогла создать эту ссылку, то значит объект точно есть, объект точно существует.
И плюс, на самом деле, ссылки не требуют копирования.
Потому что ссылка означает вернуть именно ту самую область парстанции, которая связана вот с этим объектом.
Ну и на самом деле тут двойная ссылка даёт мне следующее преимущество.
Если я в декалвал передал int&, то int& плюс двойной персант даст мне просто амперсант.
Да, ровно то, чего я хотел.
Вот, если я передам int& и двойной персант, то тут тоже выйдет тип int& и двойной персант.
Если я передам int, то тут выйдет int& и двойной персант.
Ну, по сути, то же самое, то есть неважно, там я передал это или это, да всё равно декалвал вернёт rvalue.
Понятно?
itional process tie
Ну нет, можно получить просто т, но для этого вы просто, наоб Zug А сейчас, можно ли получить просто Т?
Ну вот. Смотрите, опять же, если вам нужно получить просто Т, то кажется, что это –
Ну кажется, это нельзя сделать в универсальном контексте
Погодите. Нет, это короче кажется что нельзяFred в универсальном контексте.
Потому что по тем причинам, которые я описал ранее, объект может быть не копируем, объект может быть не...
Короче, если вы просто пишете t, это вы утверждаете, что в какой-то момент должно произойти создание этого объекта.
То есть если вы написали decalval, то есть decalval, а просто t, ну просто, допустим, от int или какого-то типа,
это означает, что в любом случае должен быть создан объект.
Ссылка же говорит, ссылка не говорит о том, что объект должен быть создан.
Потому что ссылка может связываться с объектом, который уже был создан где-то ранее в глобальной памяти или где-то еще.
А если вы пишете просто tip, то это означает, что объект обязательно должен быть создан.
И дальше у комплиатора могут возникать вопросы типа, а как он создан, а как я его скопирую, а как я его перемещу и так далее.
А тогда вы можете, ну тогда, скорее всего, вы можете сделать так.
Тогда вы можете просто написать t, вот decalval.
Ну тогда decalval вернет вам какую-то ссылку, и вы говорите, что давайте эту ссылку, я с помощью этой ссылки там либо скопирую, либо перемещу в t.
Можно мы через это скопируем.
Ну это опять же, если вы прям уверены, что tip.t либо копируем, либо перемещаем.
Так, еще вопросы.
Да.
Ну что значит ссылочные сложения?
Ну в плане того, что у нас в плане перегрузки очень �iny же отм valeurется,
и поэтому у нас либо есть сложениеpendol, либо есть сложениеdevirtual resilience,
или esqlo attitudes?
В俺 smiles, yes.
Б punching.
Я даю тебе defending object и airborne object.
SDK.
Либо есть сложение для кодов, либо есть сложение для двух ссылок.
Нет, вы можете написать сложение для lvalue и сложение для rvalue.
То есть по типу перегрузки ссылки.
Более-менее, смотрите, вот эта ситуация, вот этот декалвал,
покрывается все возможные варианты.
Потому что декалвал может вернуть либо lvalue, либо rvalue.
Если у него передали lvalue, то он вернет как раз к rvalue ссылку.
Если у него передали lvalue, то он вернет lvalue ссылку.
Даже если там есть какая-то функция или какой-то метод,
который зависит от категории значения, то, опять же, у вас все случаи покрываются.
То есть есть lvalue ссылки, есть rvalue ссылки.
И в целом декалвал все случаи более-менее покрывает.
Еще вопросы?
Я уже показал, как можно исправить вот этот пример и предыдущий пример.
Просто вместо lcs от 0 и rcs от 0 записать декалвал от t и декалвал от u.
То есть я говорю, что неважно как, откуда-то у меня есть объект типа t,
откуда-то у меня есть объект типа u, и просто их нужно сложить.
Просто нужно понять, а что произойдет в результате их сложения.
То есть это делается с помощью декалвала,
тогда мне не нужно создавать никаких дополнительных переменных,
не выдумывать никаких выражений.
Все в итоге сработает и так.
Это более-менее тоже обсудили.
Есть ли вопросы?
Давайте перейдем к следующей теме большой.
Это еще одна ключевая аббревиатура c++, которая называется SFINAE.
Что такое SFINAE?
SFINAE расшифровывает как substitution failure is not an error.
То есть ошибка в установке не является ошибкой.
Это на самом деле одно из правил c++, которые мы с вами не обсуждаем до этого.
На самом деле в нем и необходимости особо не было.
Давайте обсудим его сейчас.
Что означает эта фраза?
Неудачная обстановка? Нет, это не ошибка.
Эта фраза говорит следующее.
Если вдруг в результате подстановки шаблонных параметров
у вас возникла какая-то несуразица, какая-то билиберда,
то компилятор просто этот шаблон не рассматривает в качестве возможной перегрузки.
Давайте перейдем к примеру.
Да, вот смотрите.
Представьте, что у меня есть две шаблонные функции f.
Первая шаблонная функция f принимает int,
вторая шаблонная функция f принимает long.
Но при этом первая функция f возвращает temp%,
а вторая функция f возвращает тип t.
Смотрите, что происходит.
Представьте, что я вызываю f дальше в треугольный скоплочар от нуля.
Смотрите, как это работает.
Если я в качестве типа t в первую и вторую функцию подставлю char,
то первая функция будет возвращать char ampersand,
а вторая будет возвращать void.
Пока все нормально.
Если я подставлю f в треугольный скоплочар,
у меня будет существовать первая версия функции f,
в которой в качестве шаблонных параметров подставил char,
и вторая версия шаблонной функции f, в которой я подставил char.
То есть они существуют одновременно.
И даже когда я функцию f вызываю от нуля,
у меня происходит выбор перегрузки.
То есть выбор функции между int и long.
соответственно, так как 0 имеет тип int, то, соответственно, будет выбрана первая функция, окей?
А теперь смотрите, что происходит дальше. Дальше я вызываю функцию f и передаю ее в качестве шаблонного параметра void.
В чем тут проблема? Проблема тут заключается в том, что
ссылки на void не существуют. То есть, ну, нельзя создать тип ссылки на void.
Поэтому, если я подставлю вот это вот f от void в первый шаблон, то у меня в компилятор возникнет ошибочная конструкция вида
ссылка на void.
Что мы можем предположить, что в этом случае произойдет? Ну, смотрите, компилятор мог бы поступить так.
Компилятор мог бы сразу запаниковать, сказать, погоди,
тут ты подставил функцию f void, и в качестве pt подставил void, у тебя возник void.impercent.
Соответственно, он мог закричать об ошибке, сказать, что все плохо,
значит, такой функции f существовать не может.
Но правило SFINAE говорит следующее, что если вдруг я подставил какой-то шаблонный параметр, и у меня возникло какой-то несуществующий тип,
или просто возникла какая-то ошибочная конструкция, то компилятор просто игнорирует эту шаблонную функцию.
Он говорит, окей, вот эта шаблонная функция не подходит, потому что в результате подстановки в нее возникает какая-то некорректная запись.
Поэтому эту шаблонную функцию он просто игнорирует и рассматривает другие.
И вот именно в этом случае, когда я передаю f от void, у меня первая функция игнорируется, потому что в ней возникает ошибочный тип, и
таким образом, в результате вызова f от void, у меня существует только один кандидат на перегрузку, это f от long, и
поэтому, несмотря на то, что я туда передал ноль, у меня вызовется все равно f от long, потому что первые функции как бы,
ну, которые существуют с параметром void, ее как бы не существует.
Окей?
Нормально? Вот. То есть, если в результате подстановки шаблона к параметрам возникает
ошибочная конструкция, то это не приводит к ошибке сразу. Просто написать компилятор, этот шаблон игнорирует до поры до времени.
Вот. Значит, еще один пример.
Давайте напишем структуру,
в общем случае, которая будет проверять, можно ли на тип навесить ссылку или нет.
Смотрите, как все устроено.
Все устроено так. Я напишу структуру из referenceable, то есть, можно ли навесить на тип ссылку или нет.
А, я вспомнил, нет, тут, короче, написано ерунда, в общем, нет, так не работает. Прошу прощения. Давайте дальше сразу. Другие примеры.
Смотрите.
Смотрите. Вот еще пример. У меня есть функция, у меня есть шаблонная функция a,
шаблонная функция a, у которой в качестве второго шаблонного параметра выступает тип,
тип массива размера n%2.
Вот. И есть, соответственно,
шаблонная функция a, которая содержит всего лишь один шаблонный параметр n. Смотрите, что тут происходит.
Допустим, точнее, допустим, вот я тут вызываю функцию a шаблоном параметром a, шаблоном параметром 5. Что тут происходит?
Тут вместо n-ки подставляется 5, и
тут вместо n-ки тоже подставляется 5, в итоге получается в качестве второго шаблона параметра выводится массив витов размер 1.
Вот. То есть в итоге первая шаблонная функция – это шаблонная функция с параметрами 5 и массив Nordic, размер 1.
Вот. И вторая шаблонная функция, то есть я подставляю этот параметр и во вторую шаблонную функцию, так они обе,
так не обе шаблонные функции а, я подставляю сюда 5, получается просто шаблонная функция a с параметром 5.
То есть у меня одновременно в программе существует и первая шаблонная функция, и вторая шаблонная функция,
при этом первая шаблонная функция имеет 2 параметра,
вторая шаблонная функция имеет 1 параметр. Вот. И дальше в эту шаблонную функцию я передаю значение 0.
ну и дальше все происходит ровно как ровно по правилам перегрузки да то есть у меня существуют
две версии функции одна принимает int и другая принимает long ну соответственно если я передаю
int то естественно выигрывает функция которая принимает int но если я вызову a в трикольных скобках
2 от нуля тут будет другая ситуация тут как раз таки будет вот эта самая свиная контекст смотрите
что происходит тут происходит следующее я подставляю в качестве n шаблонный параметр 2 вот
предоставляете два и дальше здесь пишется следующее int от n процент 2 получается
массив int размера 0 но но по стандарту c++ массива размера 0 запрещено просто
просто запрещены то есть невозможно создать сишный массив размер точнее так скорее всего
.: компилятор какой-то разрешают это сделать но строго по стандарту массив размеры 0 запрещены
вот поэтому с точки зрения компилятора с точки зрения компилятора вот этот тип существовать
то есть массив int-ов размера 0 существовать не может, и поэтому этот шаблон вообще в принципе не
будет учитываться в перегрузке при вот этом вызове. А во втором случае я вместо n-ки подставлю
двойку, в итоге у меня будет шаблонная функция a с параметром 2, ну и так у меня больше никаких
других кандидатов нет, то тут вызовется функция a, которая принимает лонг, то есть вторая версия
функции. Еще один пример. Представьте себе, что у меня есть снова две шаблонные функции b, одна
принимает int, другая принимает лонг, но при этом первая возвращает t, а вторая возвращает просто t.
Что происходит? Я вызываю функцию b с шаблоном параметром вектор int-ов и передаю ей 0. Значит
тут вместо шаблона параметра t выводится вектор int-ов, тут вместо шаблона параметра t тоже выводится
вектор int-ов, ну и у вектора int-ов, естественно, есть внутренний тип value type. Соответственно,
одновременно две функции, две версии функций b. Когда я передаю туда значение 0, и естественно
перегрузку выигрывает первая функция, потому что 0 — это int, а не лонг, ну соответственно
по точному соответствующему выигрывает именно первая функция. А во втором случае смотрите,
когда я в качестве шаблона параметра t передаю int, то вторая функция инстанцируется нормально,
потому что в качестве типа type просто installs int. А тут в качестве типа type原 first NFM подставляется int
и дальше пишется intHIN value type, но естественно у н neat onionsrovу в Bendake measure нет, поэтому снова Hess
Возникла ошибочная конструкция, и эту версию функции компилятор просто игнорирует.
Поэтому тут при вызове функции bint от нуля будет приниматься в внимание только вторая функция,
но, собственно, ровно она и будет вызываться.
Да, ну и, соответственно, что здесь?
Здесь происходит ровно то же самое.
Если я передаю два консчер звездочки, то тут выводится консчер звездочка,
тут выводится консчер звездочка, но дальше я пишу дегалта под х плюс у.
Но так как два указателя сложить нельзя – QUADrieben, чисто diesized ourselves –
тут возникает ошибочная конструкция.
И, снова, по правилам свминое, так как в результате обстановки шалонового параметра
в overc obviously Ste helper的话 возникла ошибочная конструкция,
первая функция просто нам stronger אךot в Warszаве будет учитываться.
Поэтому будет учитываться только вторая функция,
вместо typo t подставим кончер ё.
Тут вместо typo u подставим кончер ё.
Все, будет вызвана вторая функция.
А если я вызову t от 1 до 2, то все будет ок animals.
Почему? Потому что跟你 typo t и выолнится int.
Сложить 2 int я могу, в результате получится int, то есть получится функция C, которая принимает 2 int и возвращает int.
Вроде как вторая функция тоже подходит, но по правилу наименьше количества подстановок будет выбрана именно первая функция.
Понятно?
То есть этот правил с FinAE говорит о том, что какие из шаблонных функций компилятор будет рассматривать в качестве потенциальных кандидатов на выбор перегрузки.
Что важно понимать, вот как я уже сказал, FinAE это правило, которое относится только к подстановке шаблонов параметров.
И причем это самое главное, FinAE относится только к подстановке шаблонов параметров. При инстанцировании шаблонов FinAE не работает.
То есть если компилятор уже выбрал какую-то перегрузку, я надеюсь, мы с вами помним о том, что компилятор сначала выбирает перегрузку, сначала выбирает, какой шаблон используется, и потом его инстанцирует.
Так вот, если в процессе инстанцирования возникла ошибка, то это уже не FinAE, это уже прям ошибка, это прям ошибка компиляции.
Ну, давайте посмотрим какой-нибудь простой пример, а, ну вот, те же самые примеры, но только я вынес ошибки непосредственно внутри функций.
Смотрите, что тут происходит. У меня есть шаблонная функция A, которая принимает int, есть шаблонная функция A, которая принимает long.
Оба они параметризованы одним и тем же шаблонным параметром. Я вызываю A0, 0.
Смотрите, то есть тут можно подумать следующее, ну смотрите, вот в этой функции происходит создание массива размера 0.
Ну а так, как массивы размера 0 запрещены, то соответственно должна быть выбрана вот эта функция.
Ну вот нифига, потому что, напомню, FinAE работает только при подстановке шаблонных параметров.
А что такое подстановка? Подстановка – это именно анализ сигнатуры функции.
То есть, смотрите, когда я подставляю A0, тут вместо n подставляется 0 и все окей.
Ну, функция нормально, то есть я вместо n подставил 0, функция A возвращает void, принимает int. Все прекрасно.
Дальше, сюда подставляю 0, значит шаблонная функция в качестве шаблона параметра принимает 0, возвращает void и принимает в качестве типа long.
Дальше, я среди этих функций выбираю ту, которую сможет принять 0, но 0 может принимать первая функция, потому что там точная соответствия.
И только после того, как я выбрал эту функцию, то компилятор уже определился, компилятор выбрал первую функцию.
Вот, компилятор выбрал первую функцию и начинает ее инстансировать, начинает генерировать из нее код,
но в процессе генерации кода у него возникла ошибка, все, это ошибка компиляции.
Даша, говорите, ой, что-то у меня там не получилось ее инстанцировать, давай-ка я выберу другую функцию. Нет, все, комплинатор сначала выбрал функцию и потом ее инстанцирует.
Если в процессе инстанцирования произошла проблема, то все, это уже ваши проблемы. Да.
Если у нас сейчас инстанцирование где-нибудь происходит в другом файле, в общем?
Ну, то же самое.
Комплинатор, смотрите, когда вы вызываете функцию, там, не важно, шаблоны и шаблоны, ему же сначала нужно понять, что это за функция, какую версию выбрать.
И по ссылке шаблонов параметров, она как раз отвечает моменту выбора перегрузки.
То есть, FNAIR работает в момент, когда комплинатор пытается понять, а какую функцию ему вызвать.
Ну, естественно, тело функции вообще никак не может повлиять на то, какая функция будет выбрана.
Ну и все остальные примеры ровно те же самые.
Напомню, что в втором примере у меня VLUType встречался в возвращаемом значении, тут я VLUType вынес внутрь функции B.
И, естественно, вот этот внутренний VLUType никак не будет влиять на SFINAE, потому что реализация функции на SFINAE никак не влияет.
На SFINAE влияют только принимаемые параметры и возвращаемые значения.
Ну и, собственно, для чего нужно SFINAE?
На самом деле правило SFINAE нужно было как раз какие-то для того, чтобы было приятно программировать,
чтобы комплинатор не выдавал ошибки, если у вас есть несколько шаблонов кандидатов,
и вдруг в каком-то шаблон кандидата возникла проблема, чтобы вам было приятнее.
Грубо говоря, комплинатор просто не обращал на это внимания и вызвал ровно ту функцию, которую вызвать можно.
В общем, внезапно в какой-то момент разработчики на C++ выяснили, что с помощью SFINAE можно метапрограммировать.
С помощью SFINAE, с помощью правил SFINAE, можно писать различные другие крутые штуки,
которые нельзя сделать с помощью тех вещей, которые мы делали до этого, кроме определительных типов, модификаторов.
С помощью SFINAE можно делать много всяких других классных вещей, например, в частности, узнавать,
а есть ли у этого типа метод F, есть ли у этого типа перемещающее присваивание и так далее.
Об этом, видимо, уже поговорим в следующий раз.
На сегодня все.
