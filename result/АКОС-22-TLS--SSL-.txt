Всем привет! Всем, кто на этот раз-то не присутствует на лекции, смотрит ее, наверное, в записи, я надеюсь, на это.
Тема сегодняшней лекции — это прикладные аспекты шифрования, то есть никакой большой теории про это не будет.
Курс вообще не про это. И, более того, про криптографию. Тут надо больше изучать на математических дисциплинах.
Итак, протоколы HTP и транспортный протокол, который называется TLS, иногда его еще называют не очень корректно SSL.
Что это такое? Для начала вспомним общую иерархию, она же модель оси, стеозаимодействия, в которой очень много уровней.
На самом деле эта модель очень старая и в современном мире выделяет только четыре уровня, верхний из которых является уровень процесса,
который, в свою очередь, можно условно разделять на некоторые подуровни, не всегда это бывает осмысленно.
И там есть уровень сеанса, к которому как раз относится протокол TLS.
Что это такое? Это дополнительный уровень абстракции, предназначенный для того, чтобы прозрачно шифровать какие-то данные.
Что происходит, когда вы подключаетесь к какому-то ресурсу по обычному протоколу HTP?
Вы открываете socket, подключаетесь к серверу и начинаете взаимодействовать в обычном текстовом виде.
Если вы хотите, чтобы ваши данные не летали по сети в открытом виде, то нужно предварительно что-то сделать,
установить соединение, переключиться на протокол TLS и затем уже поверх этого протокола TLS передавать данные, которые будут уже шифроваться.
Зачем вам нужна эта задача, шифровать данные?
Давайте посмотрим, что у нас будет происходить, когда вы сделаете обычный HTTP запрос куда-нибудь,
на example.com и при этом по обычному протоколу HTTP.
Почему именно example.com? Потому что сейчас в интернете практически все перешло на протокол HTPS, а example.com еще остался.
Вот мы загружаем какие-то данные, давайте посмотрим, что может узнать какой-нибудь злоумышленник, который захочет что-то нехорошее сделать.
Так, запускаем наш любимый VRShark, огромное количество взаимодействия, но давайте немножко его пофильтруем,
для этого выясним IP адрес example.com и поставим фильтр только на интересующий нас домен.
Так, IP адрес меня интересует вот такой.
Так, ладно, перезагружаем страницу и смотрим, что у нас отправляется.
Во-первых, у нас отправляется некоторый HTTP запрос, который представляется обычным плентекстом,
этот запрос, соответственно, можно найти в выводе VRShark.
В ответ нам тоже что-то отправляют и опять же VRShark это все видит вот в таком замечательном виде.
Ни о какой приватности данных речи не идет, ваш провайдер имеет полный доступ к вашим данным, ваш провайдер может в том числе эти данные модифицировать.
Я как-то даже один раз столкнулся в реальной жизни с тем, что провайдер подсовывает какие-то данные,
до тех пор, пока протокол HTPS не был распространен повсеместно.
Банально московское метро с бесплатным Wi-Fi, но бесплатный сыр бывает только в мышелувке,
соответственно, московский метрополитен вставлял в странички свои блоки с рекламой, иногда даже что-нибудь ломал,
стремится просто развалить.
Это один из примеров, зачем все-таки нужны любые данные шифровать, не только данные, которые содержат какие-то читательные данные.
Что можно здесь поделать? Мы можем использовать протокол HTPS с звуковкой.
Что у нас здесь тогда будет происходить? У нас происходит обмен сертификатами,
ну и дальше какое-то взаимодействие, из которого мы в принципе никакие данные извлечь уже не сможем.
При этом сам протокол HTP является текстом, то есть можно запустить telnet,
подключиться к какому-то удаленному серверу, вручную набрать команды get что-то там,
номер протокола обычно в текстовом виде HTP 1.1 и получить его от страницы.
Если вы хотите использовать протокол SSL или HTPS, то здесь уже можно использовать инструмент из фреймворка OpenSSL.
Мы несколько раз еще будем сегодня обращаться к этому фреймворку.
Это команда, у которой есть много других подкоманд,
поскольку OpenSSL это просто набор инструментов одной подставки.
И вот в частности s-клайнт – это инструмент, который позволяет установить соединение с каким-то сервером,
используя защищенный протокол HTPS.
Мы подключаемся с помощью OpenSSL к серверу Яндекса.
Происходит обмен шифрами, проверяется подлинность сертификата.
После этого мы можем писать обычные HTP запросы в текстовом виде и получать осмысленные ответы.
Ну и вот этот вывод – это все страничка Яндекса.
Немножко о том, как это все правильно называется.
Очень часто протокол называют SSL, что не очень корректно,
поскольку SSL – это проприетарный протокол разработанной компанией Netscape.
Затем он был стандартизован, переименовался в Transport Layer Security.
Именно стандартизованные международные названия TLS являются более правильными, в отличие от SSL, хотя идеально это не то.
Есть разные версии. Последняя версия, которая повсеместно используется уже всеми браузерами, всеми серверами,
это версия 3. Подробно на версиях тут останавливаться смысла не имеет.
Как мы все-таки можем устанавливать защищенное соединение, учитывая, что у нас и так уже есть какие-то сервера,
которые работают на определенных портах, и нужно получается выдавать какой-то другой контакт.
Решается двумя способами. В случае с HTTP можно просто сделать отдельный порт для прослушивания защищенных соединений, вместо 80-го.
В некоторых случаях, например, в почтовых серверах тоже используется обычное текстовое взаимодействие, текстовая команда,
и есть отдельная команда, которая инициирует переход в режим TLS со всем последующим ханшейкой.
Зачем это все нужно? Во-первых, нужно иметь возможность проверять, не вклювываться ли кто-нибудь в ваше соединение.
Тоже не добросовестный провайдер может быть, Wi-Fi, router, может сдержать какие-то закладки.
Кроме того, данные нужно иметь шифровать, и вообще индустрия цифровых сертификатов, почему их по всем местам не вводили.
Это был достаточно выгодный бизнес для ряда американских компаний, потому что для того, чтобы настроить свой сервер, работающий по протоколу HTTPS,
вам нужно иметь подписанный, третей стороной, сертификат. Цифровая попасть она тоже стоит денег, но не так давно появился некоммерческий проект,
по названию Let's Encrypt, благодаря которому можно получать подписанные сертификаты, которые имеют не очень большой срок действия, но тем не менее они работают бесплатно.
И именно с тех пор, как начали выдавать массово дешевые и бесплатные сертификаты, практически весь интернет перешел на шифрованные соединения.
На чем это все основа? Некоторые основы криптографии. Есть три класса криптографических алгоритмов, которые используются на практике.
Самый простой, один класс набора простого использования, это вычисление хэшей. Кто помнит в курсе алгоритмов, что такое хэширование?
Помните? Молодцы!
Итак, напомню, что хэш функция, это функция, которая принимает на вход достаточно большие данные произвольного размера и выдает какое-то скалярное значение.
Обычно это число, причем число может быть с достаточно большой разрядностью, не обязательно 32 битная, может быть 128 битная, может быть 256 или 512 битная.
Но общий смысл в том, что это число имеет фиксированный размер.
Особенность хэш функции в том, что по вычисленному хэш значению вы не можете обратно восстановить данные. Это в принципе невозможно.
При этом для хорошей хэш функции гарантируется, что хэш значения от разных данных будут разными.
Хэш значения от одинаковых данных будут одинаковыми, но это в случае идеальной хэш функции. Ничего идеального в этом мире не бывает.
И есть исследования, которые посвящены тому, чтобы найти какие-то уязвимости в хэш алгоритмах, то есть найти какие-то одинаковые разные данные, которые будут давать один и тот же хэш.
И ситуация, когда вы нашли такие данные и хэши их совпадают, это называется компрометация хэш функций.
По этой причине хэш функций существует в достаточно большом количестве. Хэши размеров 128 бит уже не используются, потому что они уже давно скомпрометированы.
Самый стойкий шифр, который на текущий момент пока еще не узнан, это СИЧ 512 бит.
Есть еще некоторые хэш функции, которые в принципе не нацелены на то, чтобы гарантировать уникальность хэшей для разных данных, для которых это не особо принципиальная, например, хэш функция для проверки целостности данных.
Алгоритм CRC32, который используется для контроля целостности файлов или вообще даже битчетности, это тоже формально можно считать хэш функций.
Хотя про него можно сказать, что он в половине случаев будет давать результат, который будет совпадающий с какими-то другими. Но зато он очень простой в железной реализации.
Для чего нужны хэш функции? Во-первых, поскольку у нас результатом хэширования, неважно каких данных, является какое-то число, то это очень удобно для какой-то индексации в хранилищах, но банально ключи в базы данных, которые с очень высокой вероятностью будут уникальными.
Могут быть использованы для проверки целостности данных. Например, если вы скачиваете из образ какой-нибудь линк дистрибутива, то обычно рядом где-нибудь лежит файлик, который содержит хэш значения для проверки того, что вы правильный файл скачали из правильного места, потому что файлы бывают раскидываться по зеркалам, и мало ли кто выложил на свое зеркало.
Ну и плюс, что файлы действительно до конца. Ну и в том числе хэш значения могут быть использованы для авторизации с использованием паролей. Это совсем не для всех очевидный момент, поэтому почну на небольшом примере.
Допустим, у нас есть пользователь под названием админ, и у него есть пароль QWERTY123. Как можно хранить какой-нибудь базы данных пользователей и их пароль?
Если мы будем хранить именно в текстовом виде QWERTY123, а сверять их в текстовом виде, то, очевидно, эта система будет не очень безопасной, потому что сис-админ, который имеет админские права, либо вообще хоть кто-нибудь, кто возьмет копию этой базы данных, будет знать все пароли, что не очень хорошо.
Как можно поступить? Мы можем пароль QWERTY123 закодировать каким-нибудь специфичным образом, например, используя любую хэш-функцию, пусть даже не самую стойкую, например, MD5.
Вот мы получаем значение, да, вывод хэш-функции на практике, это просто строка, которая содержит 16-личную запись какого-то большого числа. Здесь 128 бит, соответственно, 128 бит это 16 байт, которые могут быть закодированы.
Так, без переноса строк, вроде ничего визуально не поменялось, но хэш-функция у нас изменилась.
Что нам нужно сделать теперь с этим хэжа значения? Вот это хэжа значения мы можем теперь смело хранить, и вот из этих циферок обратно извлечь пароль QWERTY123 мы уже никогда не сможем.
Если мы опечатаемся паролем QWERTY124, естественно, мы будем иметь другой хэш, и тем самым система авторизации может сверить сами хэши и принять решение о том, можно ли допускать пароль пользователя или нельзя.
Это очень простой и прощенный способ, как организовать парольный ход в систему. На самом деле не идеальный парольный ход в систему, потому что у нас есть пользователь admin с паролем QWERTY123, и, допустим, у нас есть пользователь под названием Вася, который имеет пароль 123.
Что вы можете сказать про этот пароль, глядя на эту базу данных?
Ну, невозможно, а точно. Если у нас равны хэши, то можно сделать вывод о том, что они получены из одинаковых данных, и, соответственно, если вы хотите компрометировать систему, получить админинские права, вы видите, что хэш админинского пароля совпадает с паролем некоего Вася, то что можно сделать?
Можно купить бутылку водки, поставить Вася, сказать Вася, скажи-ка свой пароль, и этот пароль будет подходить к пользователю admin, что не очень хорошо.
Поэтому, на самом деле, в реальных системах авторизации используют дополнительные сведения, например, могут быть оди пользователя, логины или еще какие-нибудь рандомные данные, какие-то фиксированные рандомные данные, известные на стадии проверки.
Добавляют их исходным данным, подмешивают, еще такая операция называется подсаливание исходных данных, для того, чтобы увеличить количество разных вариантов.
Так, это один из примеров, когда осмысленно использовать фрикографические хэш-функции.
Что еще бывает помимо хэшей?
Помимо хэшей есть обычно шифрование симметричным ключом.
Как эта штука работает? У вас есть некоторые данные, которые разбиваются на блоки одинакового размера, и они кодируются с помощью некоторого блока данных, который называется ключ.
Как правило, ключ имеет тот же самый размер, что блоки данных, на которые бьется весь поток, либо кратный ему.
С помощью этого ключа происходят разные манипуляции над блоками данных.
И вот важное отличие от функций хэширования, что на выходе мы получаем объем данных примерно такой же, как у нас был в исходных незашифрованных данных.
И применяя этот секретный ключ в обратную сторону, мы можем данные декодировать.
Примеры алгоритмов симметричным ключом, панорические, классические, это родом из 70-х годов, под названием ДЭС.
В принципе, этот алгоритм можем давать даже в качестве заданий на реализацию, он не особо сложный.
ДЭС это американский, был еще советский под названием ГОСТ, очень похожий на ДЭС.
Алгоритмы АЭС, БОФ, это чуть по современию, это американские, естественно.
Есть еще алгоритм под названием Кузнеевича, который уже не советский, а российский.
В полный список есть много разных алгоритмов шифрования.
И в разных поставках, в разных дистрибутивах OpenSSL они могут различаться.
Количество поддерживаемых шифров.
Команда OpenSSL-SHIFRS показывает, какие шифры доступны конкретно вашей реализации.
Наиболее столькие алгоритмы — это алгоритмы семейства АЭС, что означает разные цифры в названиях алгоритма.
Это размер блока данных, к которому применяется ключ.
Размер блока — это размер ключа.
На счет АЭС согласен, что блоку 256 бит все равно фиксирован.
У нас есть размер ключа. Чем больше размер ключа, тем более стойкий.
И еще есть разные варианты. После названия АЭС, например, 256, CBC, ECB — это способы применения ключа к какому-то блоку данных.
По умолчанию АЭС использует алгоритм AES 256 CBC, который называется код блокчейнинг.
Что это такое и как это влияет на кодирование данных?
Способы применения ключа в рамках алгоритма кодированным блокам.
Мы берем все данные, разбиваем их на равные куски и применяем ключ независимо каждому отдельному кусочку данных.
Такой способ называется электронный код блок. Название, конечно, странное, но тем не менее устояшееся.
Чем такой способ хорош? Здесь мы можем закодировать большие объемы данных, а потом, если нам все данные не нужны, то можем указатель чтения прокрутить блока в середине и прочитать только нужный блок и декодировать.
Работает быстро. Чем такой способ плох? Плох тем, что он не учитывает возможности ситуации, что данные у нас могут быть похожими.
Для того, чтобы сделать хорошее качественное шифрование, часто используется шифр блокчейнинг, либо разные варианты, которые похожи на шифр блокчейнг.
После того, как мы закодировали очередной блок, результат закодированной данной, полученный на предыдущем блоке, мы используем по разглядной операции исключающего или для кодирования очередного блока.
В этом случае нам нужен еще один начальный блок, который называется инициализационный вектор. Как правило, он получается из самого ключа.
И как это влияет с точки зрения качества шифрования. Можно провести эксперимент в гимпе, сохранить пингвина в некотором формате, который не содержит заголовки.
Это один и тот же алгоритм IS, но один использует шифрование отдельными блоками, а другой использует информацию о соседних блоках.
Ну и какие-то общие очертания пингвина все-таки можно разглядеть. Если мы на каждом блоке исполним информацию от предыдущего, то здесь видит пингвина на самой правой картинке.
Как можно пользоваться в команды строки инструментами OpenSSL для того, чтобы закодировать какие-то данные.
Немножко выпадаю в втором практике. Команду ENG с опцией minus-shifers просто выдает какие есть у вас доступные шифры.
Давайте сделаем какой-нибудь файл, который содержит секретные данные.
И сделаем так, чтобы этот файл...
Вот мы получили файл hello.txt, замечательно.
Теперь сделаем следующий трюк.
OpenSSL, закодируем, используем IS-256.
Команда уже почти написана.
У нас тут спрашивают про пароль, но давайте это будет самая распространенная пароль QWERTY.
Получилось. Теперь смотрим на содержимое нашего файла, который мы закодировали.
Получаем какой-то abracadabra, никакого слова hello здесь внутри не содержится.
Зато он содержит какие-то бинарные данные. В том числе могут содержаться какие-нибудь не печатаемые символы.
Это вполне допустимо.
Теперь обратная операция, как это все декодировать.
Тоже самое. Инкодинг, но с опцией –D сделать обратную операцию.
Обязательно нужно указать, какой алгоритм шифрования мы используем.
Имя входного файла я указывать не буду, потому что я знаю, что результат должен быть текстовым. Его можно вывести на экран.
Так, вводим пароль QWERTY. Получаем строчку hello.
Теперь все то же самое, но вместо QWERTY я наберу afdf на клавиатуре.
Включаем бабах, ошибку. Решифровка не удалась.
Еще один трюк, связанный с криптографией, заключается в добавлении соли.
На что оно влияет? Еще раз кодирую файл с тем же самым паролем QWERTY.
Давайте посмотрим на полученные файлы.
Есть файлы размером 32 байта hello, также файлы размером 32 байта.
Это еще раз закодированный файл, который содержит строчку hello, закодированную паролем QWERTY.
Так, являются ли эти файлы одинаковыми?
Поскольку у нас всего лишь 32 байта, поэтому можно использовать hexdump.
Что мы здесь видим? Какие-то байтики у нас различаются.
Если я сделаю еще один зашифрованный файл, полученный из того же самого исходного файла,
с тем же самым паролем я опять получу файл, который будет отличаться.
Это следствие того, что файл добавляется в случайные данные для того, чтобы усложнить процесс декодирования.
Эти случайные данные называются солью. В принципе, в канале OpenSSL можно указать эту соль самостоятельно.
Соль это 8 байтов.
Задать в 16-речном виде QWERTY.
И соль, в отличие от ключа, явным образом хранится в самом файле.
Если вы увидите содержимое файла в текстовом виде, то будет строчка, которая называется salted, подчеркивание.
Дальше какие-то байтики. В hexdump можно наблюдать 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8.
Эти самые 8 байтов. Цель стоит не скрыть ее, а просто добавить какую-то рандомизацию в определенные данные.
На самом деле использование соли не является обязательным.
Если нету строки начинающего в соусе подчеркивание, то алгоритм IES просто соли не будет использовать.
Чем плох механизм шифрования симметричным ключом?
Плохом тем, что мне приходится вводить пароль QWERTY как для шифрования, так и для расшифровки.
Ключом может быть не только пароль. В 256 бит можно сбихать достаточно большие данные, не только текстовые.
Ключевая проблема заключается в том, что пароль нужно как-то передать человеку, который будет данные расшифровывать.
И это бывает не всегда возможно.
Поэтому в интернете используется немножко другой способ.
Это шифрование пары ключей, один из которых является публичным, другой является приват.
Они генерируются одновременно и являются неотклеенной частью одного большего ключа.
Публичный ключ обычно используется для того, чтобы данные можно было зашифровать, но он не пригоден для того, чтобы их расшифровать.
Поэтому можно смело передавать, публиковать, ничего страшного не произойдет, если он попадет в ненадежные руки.
Приватный ключ нужен как раз для расшифровки.
Приватный ключ в принципе никак невозможно получить из публичного ключа, поэтому шифрование достаточно верно.
Примеры таких алгоритмов это американские РСА, есть российский аналог, называется ГОСТ, но и более современные алгоритмы.
Это свои обописи, основанные на матапарате лептических крывых, где применяется шифрование с открытым ключом практически везде.
Начинают протокол HTPS и в том числе в протоколе СССР.
Как работает это шифрование? Допустим, есть гражданка Элис, которая хочет передать товарищу Бобу какие-то секретные данные.
При этом есть одно важное дополнительное ограничение.
Элис и Боб не могут лично пересечься и передать какой-то ключ, не могут использовать никакой публичный канал связи для того, чтобы ключ передать.
Мы банально познакомились в Тиндере, Элис хочет отправлять нутцы и не хочет, чтобы нутцы разошлись по всему интернету.
Что можно сделать? Боб может сгенерировать пару ключей, приватный ключ, который он оставляет у себя и держит в надежном месте, чтобы никто не утащил, и публичный ключ.
Этот публичный ключ Боб переводит Элис. Затем Элис шифрует данные, используя ключ Е, который передал ей Боб, и отправляет данную зашифрованную.
Затем Боб применяет этот самый ключ Д, который он Элис вообще не показывал, но этот ключ возможен для того, чтобы расшифровать данные.
Элис при этом, кстати, данную расшифровать не сможет, и если она исходник потеряет, не судьба значит.
Как этим можно воспользоваться на практике?
Во-первых, нам нужно сгенерировать пару ключей. Для генерации пары ключей используется подкоманда GenRSA, OpenSSL, GenRSA, указываем имя выходного ключа и его размер.
Размер указать не обязательно, по умолчанию 2048 Б.
У нас генерирован файл, который содержит пару ключей. Из этих ключей мы можем извлечь публичную часть.
На самом деле, чем больше ключ, тем, казалось бы, лучше. Давайте сделаем ключик размером 4 килобайта.
Вот он очень дольше генерировался, можно сделать еще больше.
Медленно. Я всего лишь два раза увеличил выходного ключа. Обратите внимание, как медленно он генерируется.
А если я скажу сделать ключик размером 65 килобайт, то 8 килобайт я дождался. Если я скажу ключик побольше, то до конца пары мы этого не дождемся.
Итак, вот мы сделали пару ключей. Затем отсюда надо извлечь публичную часть.
Так, RSA, имя файла, это наш приватный ключик, текстовый файл для вывода и операция под командой RSA опубликовать публичный ключ.
Вот у нас появился ключик рядом, который называется public key. Этот ключик мы теперь можем передать товарищу, товарищу Элис.
Дальше. Товарищ Элис может сделать команду OpenSSL RSA OTO. Страшно выглядит.
Ян Критт.
Так, используя публичный ключ, это public.key и входные данные. Файл назывался helloText. Запишем что-нибудь типа out RSA.
Так, мы получили файл helloRSA. Давайте теперь его расшифруем. OpenSSL под командой RSA OTO, где Критт.
Для этого нам уже требуется наш приватный ключ. Мы получили декодирование того теста, который мы захотели.
Еще один эксперимент. Давайте мы теперь поменяем наш приватный ключ на публичный.
Ошибка. Сделать это мы не можем. Какие у нас есть ограничения? Допустим, мы хотим зашифровать большой объем данных.
Слово hello не интересно, потому что здесь всего-то 5 символов плюс символы приноса строки. И он забыл меньше, чем размер ключа.
Можно сделать 151 килобайт. Нормально.
Теперь шифруем какой-нибудь большой файлик. Для этого используем публичный ключ.
И получаем ошибку, что для данного ключа размер данных слишком большой. Это существенное ограничение алгоритма RSA, потому что мы не можем закодировать данные больше, чем размер ключа.
Как можно использовать эту схему? Полезная схема. Казалось бы, очень красивая. Вариант первый. Можно просто побить данные на независимые кусочки, шифровать их отдельно.
Чем это плохо? Мы получаем ту же самую ситуацию, что с ECB-пингвином. Подход, который используется на практике, это совместное использование алгоритмов с открытым ключом и симметричным ключом.
Что на самом деле происходит в браузерах? Сначала браузеры используют алгоритм RSA либо лептические кривые.
Достоверяется в том, что нужная ассервация является нужным. Затем генерируется случайно ключ для алгоритма IS. И этот ключ передается с использованием алгоритма RSA.
Какие здесь могли быть проблемы? Хорошо, Элис умеет отправлять нутцы ГОГО, но при этом ГОГ должен был через открытый канал связи опубликовать свой публичный ключ.
Если использовать ненадежные каналы связи, то этот ключ может быть кем-то перехвачен. Что может сделать какой-нибудь нехороший человек, используя публичный ключ БОБа?
Какой-нибудь нехороший человек может закодировать какие-нибудь фейковые данные и отправить в БОБ. БОБ будет честно думать, что эти данные прислала Элис, поскольку ключ отправлял только Элис.
И тем самым может не увидеть никакой разницы. Как эту проблему можно решать? Здесь нужно удостовериться, что Элис действительно Элис, а не кто-то, кто себя за нее выдает.
Должен быть третий человек, которому все доверяют, который может сказать, что Элис действительно Элис и подписать, например, какой-то ее ключ.
Для этого используется сертификат публичного ключа. Это сертификат, который выдается какой-то сторонней компанией, и этот сертификат удостоверяет, что ключ, который вам прислали, действительно является Элис.
То есть когда вы подключаетесь к какому-то серверу по протоколу HTTPS, то вы можете наблюдать, что у сервера есть какой-то сертификат, он имеет определенный срок годности.
Этот сертификат выпущен к какой-нибудь конторе, типа Semantic, Commodo, или Aletsyn Crypt. Немножко подробнее по ключи.
Итак, Элис хочет отправить Бобу данные. До этого можно воспользоваться некоторым традиционным центром, который точно так же сначала генерирует пару ключей, публичный и приват.
Этому центру все доверяют, и публичный ключ доступен всем участникам взаимодействия.
Дальше. Элис хочет отправить какие-то данные Бобу, но хочет сделать так, чтобы Боб мог убедиться, что это действительно Элис.
Для этого Элис генерирует пару ключей и свой публичный ключ отправляет авторитационному центру.
Авторитационный центр вычисляет хэж значения, который является уникальным для разных данных. Он вычисляет хэж значения для публичного ключа, и затем шифрует это хэж значение, используя свой приватный ключ.
Естественно, авторитационный центр не должен выдавать и никак светить своих приватных ключей.
И вот этот подписанный зашифрованный сертификат доступен и Элису, и Бобу.
Соответственно, как Боб может удостовериться, что мы действительно правильный человек, отправив данные.
Он может использовать публичный ключ для того, чтобы расшифровать этот сертификат и удостовериться, что ключ действительно был выпущен Элис, что хэж совпадает.
Ну и как-то все выглядит в реальности.
Когда вы установите ТЛ-соединение, сервер присылает сертификат клиенту.
Дальше клиент проверяет сертификат, используя базу данных корневных сертификатов.
То есть в каждом браузере вы можете найти список сертификатов.
Иногда в некоторых системах это можно найти не в настройках браузера, а в настройках самой операционной системы.
То есть множество сертификатов ключей, которые доступны всем приложениям, а не только одному конкретному браузеру.
После этого клиент генерирует пару ключей уже для текущего сеанса, отправляет серверы и начинает взаимодействовать.
Что такое корневые сертификаты? Где их можно взять?
Корневые сертификаты обычно соответствуют каким-то организациям, которые подписывают другие сертификаты.
И раньше надо было платить достаточно большие деньги, чтобы ваш сертификат подписала какая-нибудь компанию, доставляющую центр.
В то же время, даже если вы заплатили большие деньги за свой сертификат, это еще не значит, что всегда можно вам доверять.
Периодически бывают скандальные утечки, из-за чего приходится отзывать очень много сертификатов, выпускать экстренное обновление к браузерам.
Редко, но бывает.
Второй вариант, если вы не хотите вообще никому доверять, либо против нас ввели санкции и никто не хочет подписывать наши сертификаты,
то можно просто выпустить свой корневый сертификат, добавить его в браузеры всех ваших потенциальных клиентов, всех ваших сотрудников,
и считать, что этот сертификат, которым вы подписываете свои веб-ресурсы, тоже надежный для определенного круга лиц.
В общем-то у нас за государством сейчас то же самое происходит с госуслугами. Браузер Яндекс содержит дополнительные сертификаты.
Ну и еще один способ, как можно подписать свой сертификат для своего сервера, есть бесплатный сервис Let's Encrypt.
Замечательным тем, что там практически ничего не нужно делать.
Просто вставим через APT ГЭЦ или еще что-нибудь, команду по названию CertBot запускаем, и все, и пользуемся счастьем.
Очень простой механизм получения сертификатов упрощен настолько, что проще некуда и грехами располиваться.
Что такое сертификат, то есть что делает доставающий центр?
Доставающий центр, на самом деле, это не просто контора, которая налево-направо всем раздает сертификаты, подписывает.
Вовсе нет. Нужно удовлетворять некоторым минимальным требованиям.
В случае с Let's Encrypt нужно подтвердить, что вы действительно получаете сертификат на тот сервер, для которого запрашиваете.
Для этого нужно с правами рта, либо с правами того пользователя, который имеет доступ на запись в каталог вашего веб-сервера.
Запустил CertBot, он скачает с Let's Encrypt какие-то данные, которые нужно будет обязательно положить на ваш сервер, дальше с вашего сервера по доменному имени.
Эти данные получаются, тем самым происходит проверка, что вы действительно не на условные яндексеры пытаетесь получать сертификат, а на свой сервер.
И это считается достаточным для того, чтобы подтвердить, что действительно вы являетесь владельцем сертификата.
Более серьезные конторы могут выполнить дополнительные проверки, например, потребовать ваши паспортные данные.
Так, ну и сертификат дальше просто прописывается к веб-серверу Apache либо Nginx, кому что больше нравится.
И стандартная практика сейчас является то, что на 80 порту делается простая переадресация, то есть код возврата 301.redirect на новый URL, который отличается от исходного только наличие буковки S названием протокола.
Так, ну и сегодня я вам показывал использование команды OpenSSL.
На самом деле, пакет OpenSSL содержит не только одну команду с кучей возможностей, это еще и библиотеки, которые в том числе можно использовать в своем программном продукте.
И OpenSSL на самом деле используется практически как стандарт де-факто.
В многих продуктах для него естественно есть уже готовый написанный CMakeMobile, есть сборки под Windows.
В общем, все хорошо, все замечательно. Точнее, почти все хорошо, все замечательно, если не считать того, что исходный код OpenSSL, он не самый аккуратный.
И это обнаружилось в 2014 году, когда выяснились подробности бага по названию Hardlead в этой библиотеке OpenSSL.
Начали проводить аудит, но выяснилось, что очень много написано коровами руками.
И был создан альтернативный проект Fork OpenSSL, из которого выкинули много легоси.
Называется он LibreSSL с точки зрения программного интерфейса, с точки зрения сигнатуры команд.
Они практически совпадают, и в некоторых дистрибутивах есть даже возможность выбора, из какого пакета ставить OpenSSL.
Либо из настоящего OpenSSL, либо из пакета LibreSSL.
Ну и соответственно там есть несколько библиотек, которые можно также использовать из своего СИШного кода.
LibreSSL на самом деле немножко хуже OpenSSL в плане количества поддерживаемых алгоритмов.
Но основные алгоритмы там все равно реализовываются.
На этом все, есть ли у вас вопросы?
Кажется, в Иране сказали, что нельзя в мире это программство предназначать.
Использовать там публичную фигню Стаскевасова и наоборот.
Кажется, что если использовать ключи в другом порядке, то мы получаем еще один довольно простой механизм подпись.
Возможно, да.
Так, ладно, еще вопросы есть.
Ну если нет, тогда электро закончилось.
