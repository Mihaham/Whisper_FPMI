Так, ну ладно, давайте начнём.
Сегодня последняя лекция в курсе. Она посвящена лямбодисчислению и операциями с нумералами Чорча.
Значит, я напомню, что такое нумералы Чорча.
Значит, нумералы Чорча выглядят так. Есть для каждого натурального числа есть соответствующий нумерал, и они все выглядят примерно одинаково.
Значит, ноль, подчёркнутое число – это нумерал. Нумерал 0 – это лямбда fx.x. Нумерал 1 – это лямбда fx.fx. Нумерал 2 – лямбда fx.f.
Тут всегда хочется написать ещё одну скобку, так в принципе можно делать, но не нужно.
Ну давайте, нумерал 3 – лямбда fx.f от f от fx. Ну и так далее.
Значит, нумерал N – это лямбда fx.f от f от fx. Здесь f повторено N раз.
Вот и так далее.
А с чем смысл? Смысл в том, что нумерал – такая функция, которая переводит функцию f в N композицию функции f.
А дальше стоит вопрос о выражении отличных функций.
То есть в целом она, как говорят, комбинатор g представляет функцию g малая, которая получает k натуральных чисел и возвращает натуральное число.
Если для любых N1 и так далее Nk, g дальше N1 и так далее Nk, это будет g от N1 и так далее Nk.
То есть если записать сначала комбинатор, потом k нумералов, то полученный лямбда term будет равен нумералу для значения функции g.
Причем можно расширить это определение и для случаев не всюду определенной функции g.
Можно сказать, что если g от N1 и так далее Nk не определена, что тогда соответствующий комбинатор g, который приписан на N1 и так далее Nk, не должен иметь…
не должен иметь нормальной формы.
Соответственно, именно это определение дает альтернативное понятие вычислимости функции.
Можно сказать, что функция вычислима, если она предстоит каким-то лямбда комбинаторам в этом смысле.
И оказывается, что такое определение будет равносильно всем остальным определениям вычислимости, из которых главное для нас это определение через машину чьюринга.
В одну сторону это не очень удивительно.
Если нас не интересует эффективность, то вроде понятно, что…
Да, тут именно нужное определение, что мы можем записать такой комбинатор, применять там все возможные преобразования и, соответственно, ждать, когда у нас появится нумерал.
Тут нужно только сказать, что преобразование обратной метаредукции тоже будет вычислимым.
В общем, тут есть технические сложности, но концептуальная идея простая, что у нас есть такое выражение, мы к нему применяем все возможные преобразования.
Вот, и, соответственно…
А, кстати, на самом деле можно еще доказать через черчеросыра, что если у нас какой-то терм равняется нормальной форме,
то там в процессе этого равенства можно не использовать операции обратной метаредукции, а использовать только метаредукции альфа-конверсии.
Вот, и тогда получается, что алгоритм будет таким, что мы напишем выражение, будем туда применять все возможные редукции конверсии и ждать, пока встретится нумерал.
Значит, если встретился нумерал, то это и будет значением.
Ну, а если процесс будет бесконечным, то тогда, соответственно, это все никогда не закончится, но так и должно быть, если функция не определена.
Значит, это идея в одну сторону. Почему? Это то же самое, что вычислимость, что если это верно, то тогда функцию уже можно вычислить.
Ну, а в другую сторону, что если функцию уже можно вычислить, то это как раз если мы представим архиметические функции,
то тогда мы сможем все вычислимые сделать, потому что через архиметические можно выражать строковые, через строковые работы машины тюринга,
и тогда получается, что мы любую машину смоделируем. Так что, в общем, в целом, видимо, понятно, что это то же самое, что вычислимость.
Но сегодня возникает вопрос, а как, собственно, все это моделировать, то есть как выражать разного рода функции.
Значит, последнее, что у нас было в прошлый раз, это прибавление единицы.
Значит, комбинатор инкриментации, прибавление единицы, это было λnfx точка f от nfx.
Ну и мы обсуждали, что вот это вот n делает n раз примененные в самом себе, а вот это вот f прибавляет еще одно, получается, что n плюс 1 как раз.
Ну, аналогично можно сложение, ну а можно выражать вот так вот, да, написать просто lambdamn точка m,
инкримент m. То есть, что, когда вы прибавите m, значит, m раз приводит единицу.
Но вот такая запись на самом деле так и устроена, да, потому что когда мы...
Ну давайте я покажу, почему это будет так.
Потому что тогда add, а дальше mn, и это будет, соответственно, m inc n.
Значит, а это будет, соответственно, λfx точка f от f и так далее, вот fx, inc n.
А дальше, смотрите, помните, что вот это λfx, это сокращение от λf точка λx.
Вот, ну сначала за счет λf, у меня inc сюда вместо f появится, а потом за счет λx, n, номерал, поставится вместо x.
То есть, это будет, значит, increment от increment и так далее, значит, от increment m.
Вот. Ну вот, получается, что мы m раз, m раз инкриментировали n, то есть, увеличили на единицу.
Но это как раз и получится m+.
Вот. Ну вот, это один подход, а можно прямой это написать.
А так, значит, давайте я это другим цветом нарисую, в том смысле, что это будет не тот же самый, на самом деле, комбинатор, но выполняющий ту же функцию.
Значит, можно альтернативно написать, что add, это будет λm nfx точка, значит, а тут будет mf от nfx.
Ну и, соответственно, вот такая запись позволяет сразу вместо того, чтобы много раз инкриментировать,
сразу написать m раз f, f от f от f, m раз, а потом еще туда поставить f от f от f, n раз.
То есть, фактически тут будет вот такое равенство использоваться.
Композиция m-той итерации на n-ту итерацию, это будет m плюс n-та итерация.
Вот, значит, это вот сложение. Есть какие-нибудь вопросы.
Так, значит, ну если сложение все понятно, то переходим к умножению.
Ну опять же, умножение, в принципе, можно определять как итерированное сложение.
Да, там, m раз, прибавлять n к нулю. Вот, но канонический способ это опять же действовать иначе.
Написать вот так, вот, λm nfx точка m от nfx. Вот, обратите внимание на скобки.
Да, что именно, именно nf взято в скобки.
Соответственно, это построено на идее, что, значит, если мы n-ную итерацию возведем в m-тую степень,
то будет f в степени n. Вот.
Значит, ну, соответственно, можно немножко подробнее расписать.
Значит, мульт mn. Значит, это вот, смотрите, когда мы m и n подставили, то вот эти λm и λn ушли, а fx остались.
То есть будет λfx, а тут будет m от nf от x. Вот.
Так, ну, собственно, можно после этого λfx за собой не таскать.
Да, посмотреть на то, что после λ стоит.
Значит, вот, значит, м от nfx.
Так, и чтоб не путаться, давайте у m какие-нибудь другие.
Значит, λdgy тоже будет g, aj и так далее.
Вот gy.
nfx.
Ну и после этого получается, что мы подставляем.
Значит, вот это вот nf. Подставляем сюда, вот сюда.
А x подставляем, соответственно, вот сюда.
Ну и после этого что же получится.
Вот, ну, получится, что и должно быть.
Значит, тут будет nf.
nf и так далее.
nfx.
Ну и вот это вот фактически теперь получается прибавление m раз n самого к себе.
То есть тут...
Заметьте, что, в принципе, вот эти вот скобки, они не нужны по нашему соглашению.
Вот.
То есть тут, если опять же расписать...
Давайте я вот это n теперь распишу.
Вот тут будет λ, какой-нибудь еще, там hz.
.h от h и так далее от hz.
Так, дальше тут будет f.
И дальше будет все остальное.
Нф и так далее.
Эти скобки по соглашению можно снять.
Ну и теперь получается, что вот это вот f.
Значит, вот это вот f будет подставляться вместо h.
Сюда-всюду.
А вот эта вот вся эта большая скобка подставится вместо z.
Ну и тогда получается, что тут будет...
Значит, тут будет f от f и так далее от f.
А вот это вот по предложению индукции можно считать, что тут будет...
Тут будет как бы m, m-1 на n.
Значит, m-1 на n.
fx.
Так, в общем, закрываем.
Ну и все вместе будет m на n, потому что здесь вот этих вот как раз будет m штук.
Нет, n штук их будет.
Да, они же вот отсюда брались.
Значит, здесь n раз.
И как раз, если мы n добавим вот сюда, то будет как раз mn, что не нужно.
Так, ну что, пример понятно?
В общем, основная суть вот в этом зеленом равенстве.
А вот это уже подробный, аккуратный анализ, почему действительно именно так получится.
Так, ну что, понятно?
Дальше такими же элементарными методами...
Таким же элементарными методами можно возведение в степень получить.
Ну то есть как элементарными?
Будет элементарная запись, но не совсем элементарным доказательством.
Считаю, что я его пропущу, оно такое довольно громоздкое.
И вообще поучительно, самостоятельно попробовать его провести.
Во, значит, сейчас у меня все с большой буквы, так что давайте...
Значит, экспонента имеется в виду от двух аргументов, где первый аргумент в степени,
и второй аргумент.
Так, тут будет лямбда mnfx.nmfx.
То есть тут, в общем, имеется в виду следующее.
Да, утверждается, что если мы подряд запишем...
Так, ну это контактинация, да, ее вообще обычно...
Давайте, чтобы не получилось с умножением, напишу вот так вот.
Значит, если мы подряд запишем номерал n, а потом номерал m,
то мы правой на самом деле возводим в степень левого.
Вот.
Но это пусть остается в качестве задачи такой.
Значит, это вот задача.
Ну, рекомендуется, скажем, 3 и 2 в разных порядках друг на друга поперемножать,
посмотреть, что там получается.
Ну и потом понять, как это в общем случае происходит.
Так. Ну ладно, это вот то, что можно сделать элементарными методами.
А дальше вообще в архиметике 4 действия основных.
Кроме сложения и умножения, есть еще вычитание и деление.
И для вычитания и деления нужны некоторые специальные ухищрения.
Так, ну давайте посмотрим вычитание.
Значит, ну на самом деле главное это получить вычитание единицы.
А, ну вообще, прежде чем говорить про вычитание, нужно сказать, что мы имеем в виду.
Потому что не всегда же можно вычесть натуральное число.
Ну и можно это делать разными способами.
То есть один способ, если уменьшаемое меньше вычитаемого, то не определено.
Но мы не так будем делать.
Значит, это у нас будет функция максимум из m-n и нуля.
То есть это как бы срезка такая, что если результат меньше нуля, то мы возвращаем 0.
Вот, и тогда ясно, что главное это определить вычитание единицы.
Значит, то есть максимум из m-1 и 0.
Ну, то есть, по общему говоря, это 0 остается нулем, а все остальное уменьшается на единицу.
Вот, потому что тогда можно сделать так же, как мы делали с осложением в первом варианте.
У осложений в первом варианте было m раз инкремент, а тут у нас будет n раз декремент.
Да, потому что тогда получается, что subtract будет лямбда m-m.
Если мы вот так вот именно из m вычитаем n, то нужно n раз применить декремент к m.
То есть самое сложное, это вот взять декремент.
Ну, оказывается, что это нельзя просто так взять и сделать, а нужна сначала некоторая специальная подготовка.
Вот, и сначала придется, сначала освоим логические операции и операции с парами.
Значит, что мы вообще хотим от логических операций?
Ну, мы хотим какие-то логические константы, во-первых.
Я понимаю, что все есть функции, а функции есть лямбда-комбинатор.
То есть, логические константы это тоже какие-то такие функции, считаем, лямбда-комбинатора.
Но нужно, чтобы были еще другие функции, которые вывели бы себя как логически обычные функции.
И, соответственно, на этих логических константах работали как положено.
То есть мы, например, хотим логические операции.
Значит, мы, например, хотим константы.
Значит, константа true и константа false.
Вот, ну и, например, функция...
Ну, например, такие, что and true true равняется true.
Значит, там and true false равняется false.
Значит, and false true равняется false.
И and false false равняется false.
Ну и аналогично для других.
И для других логических функций аналогично.
Вот.
Хорошо.
Значит, это то, что мы хотим.
Теперь, как этого добиться?
Значит, в принципе, возможно, разные ситуации, разные подходы.
Так же, как и с номералами.
Но я один удобный расскажу.
Значит, удобно делать так.
Вот, смотрите, false на самом деле будет равняться нулю просто.
Значит, false равняется нулю.
Но только я вот так вот запишу lambda.xy.y.
И это же получается...
Ну, как функция, это получается проекция на вторую координату.
Значит, это проекция на вторую координату.
Вот, а true...
Так, ой, тут много черточек.
Значит, true это номерал 1.
Ой, нет, наоборот.
Так, true, наоборот, не равняется номералу 1.
В отличие от того, что можно было бы подумать,
это вот, что lambda.xy.x или всякого у.
И это не равно номералу 1.
Вот, но зато это симметрично получается проекция на первую координату.
Проекция на первую координату.
Вот, как же тогда, значит, как же тогда
логические операции выражать?
Ну, например, можно заметить следующее,
что вообще можно писать про конъюнцию, например,
что такое p и q.
Ну, можно сказать, что это 0, если p равно 0,
и q, если p равно 1.
Вместо аналогичного
можно писать, что...
Написать, комбинатор end
будет lambda pq.pq false.
Значит, и что здесь будет происходить?
Если p равно 0,
ну, например,
end, потом false, потом q.
Значит, это что такое будет?
Это будет false q false,
и это равно false.
Потому что вот этот вот false первый, он из следующих двух комбинаторов
выберет второй, потому что false всегда второй выбирает.
Ну, а если, соответственно, end true q
q написать, то это будет true q false,
и это будет q.
Вот.
Ну, а в самом деле можно и чуть попроще написать.
Можно также написать, что p и q будет равняться
p, если p равно 0,
потому что если p равно 0, то 0 равно p.
И можно заменить на p.
Вот.
И q, если, соответственно, p равно 1.
И тогда будет немножко попроще.
Значит, тогда end будет
lambda pq.pq.p.
Вот.
А or
можно написать lambda pq.p.pq.
Значит, наоборот, если p равно 1,
то тогда дизюнкция верна, и она же равна p.
А если p равно 0, тогда дизюнкция равна q.
Вот.
То есть, вообще, в целом, смотрите, в целом,
тут логические значения придуманы так, чтобы подходить
под тернарный оператор.
А то есть, что такое тернарный оператор?
Что если первый аргумент истинен,
то он равен второму аргументу,
а если ложен, то равен третьему аргументу.
Но здесь ровно это и происходит.
Точнее, не здесь вот, а вот здесь вот.
Да, он как раз...
Первый аргумент есть логическое значение,
то из следующих двух он выберет
либо первое, если он истинен,
либо второе, если он ложен.
Вот.
Соответственно, всякие другие логические операции
можно аналогично сделать.
Но не всегда можно избавиться от константа.
То есть, например, нот так не получится.
Значит, нот будет что-нибудь типа лямбда p,
лямбда p, точка p, false true.
Значит, если по истину, тогда вернется ложь,
если p ложь, то вернется истина.
Вот.
Так, нот это логическая операция.
Есть какие-нибудь вопросы?
Так, значит, тогда следующая это
операция над парой.
Так, а что мы хотим от пары?
Ну, как всегда, мы хотим у пары
брать первую и вторую компоненту,
первую и вторую компоненту,
левую и правую.
И, соответственно, нужно, чтобы был оператор пары,
который изготавливает некоторый код пары,
и операторы взять левую и правую,
которые ему обратны.
То есть, для пары...
Значит, комбинаторы, комбинаторы пары будут pair left и right.
Так что мы хотим, чтобы было выполнено,
чтобы left, взятый от пары x, y,
обратите внимание на скобке,
значит, это должно быть x,
а, соответственно, right,
взятый от пары x, y,
это должно равняться y.
Можно сказать, что мы хотим уравнение решить.
То есть, мы хотим найти такие
pair left и right,
чтобы для любых x, y были бы верны
вот эти два условия.
Вот такое вот задание.
Сейчас будет звонок, давайте после прерыва
я расскажу,
как это делать при помощи
true и false.
Так, прерыв 5 минут.
Ну, действительно, эти три комбинатора pair left и right
основаны на логических операциях.
Значит, а именно будет pair x, y,
x, y,
x, y,
x, y,
x, y,
а именно будет pair,
pair это будет
λx, y,
pair.pxy,
значит, left,
значит, left это будет λp.ptrue,
и right это будет λp.pfalse.
Значит, почему это сработает?
Ну, легко понять,
что pair x, y
это будет λp,
да, уже без x, y,
а просто λp.pxy.
Ну, а дальше,
значит,
left,
вот pair x, y,
значит, это будет
λp.ptrue,
тут будет
λp.pxy.
Дальше что происходит?
Значит, дальше начинается бета-редукция.
Значит, я вот эту вот штуку
вставляю вот сюда вот.
Да, значит, и получается
λp.pxy,
а потом true.
А после этого я
вот эту вот штуку true
вставляю вот сюда,
вставляю вот здесь,
вставляю вот здесь,
вставляю вот сюда вот,
и получается true.xy.
Значит, будет true.xy,
ну, и это x, да,
потому что они действуют
как торнарный оператор.
То есть, тут,
вот, такая конкатинация действует
как торнарный оператор.
Вот. Ну, с это left,
а right полностью аналогично,
только вместо true будет false,
так.
Так.
Ну, че, согласны?
Вот, хорошо. Комминаторы пары у нас есть.
Вот. Ну, а теперь можно
приходить к вычитанию.
Значит, вычитание единицы
декремент.
Значит, вычитание единицы.
Значит, тут идея,
которая называется трюк
клинья.
Значит, ну,
историю рассказывают, что
клинья там долго думал,
надо всем как это сделать,
а потом у него заболел зуб мудрости,
и вроде то ли его вырвали этот зуб,
и он после этого придумал,
то ли наоборот.
Сначала придумал, потом вырвали.
В общем, можно где-нибудь литературы поискать.
Но, в общем, поэтому еще это называется
трюком зуба мудрости.
Что клинья придумал?
А придумал следующее.
Что он рассмотрел?
Вот такое преобразование,
такую цепочку преобразования.
Смотрите, значит, пара x, y
преобразуется в пару f от x, x.
f от x, x.
Значит, это преобразуется в пару
f от f от x,
f от x.
Значит, а тут будет,
соответственно, там
f кубя,
f квадратя
и так далее.
Итак, если это n раз сделать,
то тут будет
fnm от x,
а тут n-1
от x.
И на самом деле вот эта вот вторая часть
это ровно то, что нам нужно.
Да, то есть идея следующая,
что как бы сделать...
В чем трюк заключается?
Значит, трюк заключается в том,
что вот это вот,
значит, повторить
n раз
и взять
вторую часть.
Тогда это будет ровно то,
что нам нужно.
Вот.
Так, ну...
Хорошо.
Значит, как...
Как это теперь записать?
Что нам нужно?
Во-первых, нужно от функции f
перейти вот к такому преобразованию.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Так.
И давайте сначала вот это вот.
Значит, это назовем
deckfn, то есть как бы
функция для декремента.
Вспомогательная функция
для декремента.
Да, значит, это...
Значит, f
нужно преобразовать
соответственно функцию,
которая x, y
преобразует
в f от x и x.
Так, значит,
это у нас будет выглядеть следующим образом.
Значит, лямда
fp,
потому что этот аргумент это пара.
Значит,
pair
от
f
от left
pair.
И просто
left pair.
Вот. Вот это вот это самое
deckfn. То есть, смотрите, если сюда f подставить,
то вот это вот лямда f у тебя
останется лямда p.
Вот. И тогда как раз получается, что мы
из пара x, y берем только x,
потом устроим f от x
и образуем
из них снова пару.
Вот.
Ну, а теперь, собственно,
сам декремент.
Декремент
будет выглядеть так.
Лямда
nfx
точка
right
от
следующей
штуки.
От n раз
примененной
из многогаитной функции
deckfn.
Примененной из многогаитной функции
deckfn.
Значит, примененной
так, наверное, вот так вот нужно
сделать.
И
pair x, x.
Значит, зачем тут именно
x, x?
А для случая
значит, pair x, x
нужен для случая n равного 0.
Потому что если n равно
0, то тогда нам
ничего не нужно менять.
И тогда n
равному 0 ничего не сделает. Оставит пару из
x и x.
И тогда right возьмет x. Это нам и нужно.
Вот. Если n больше 0,
то тогда мы как раз
значит, deckfnf
это вот это вот преобразование.
Применение
к паре из x, x.
Получим такую штуку, возьмем правую
часть. И будет как раз
n минус первая итерация,
а λfx тут как раз останутся.
Вот. Поэтому получается, что
значит, нам нужно, что
декремент от 0
равняется 0.
Декремент от n плюс 1
равняется n.
Так. Ну чего, понятно?
Нужно здесь что-нибудь пояснять
подробнее.
Как этот трюк работает?
Сейчас. Чего? Вот это как
используем. Ну, смотрите.
Вот. Вот это вот pair x,
это то же самое, что вот здесь.
Ну, вместо x, y мы и y тоже равно x берем.
Потом
deckfnf
это вот каждый из вот этих вот преобразований.
Оно
согласно
одной и той же функции делается.
Мы от левой части
берем f и
ставим снова налево,
а саму без изменения левую
часть ведем направо.
Соответственно, мы n раз
применяем вот такой преобразований
к pair x, x. Это означает, что мы
вычисляем вот эту вот цепочку.
После этого берем правую часть, то есть
берем как раз вот эту вот штуку.
Ну, смотрите, если все равно не понятно,
так на слух, то попробуйте для маленьких
чисел просто непосредственно все расписать.
Когда там 0, 1, 2,
наверное, станет понятно.
Ну вот, соответственно,
если мы единицу научились вычитать,
то после этого
берем.
Давно уже было.
Во, значит,
тогда мы сколько угодно
можем вычитать по этой формуле.
Вот так.
Ну, остается деление.
Вот, деление уже нужно
выполнять общим методом
через рекурсивное программирование.
Деление общим методом
общим методом через
рекурсивное программирование.
Потому что, значит,
деление у нас будет числочисленное.
То есть оно пускай будет всегда
определено как целая часть.
То есть деление
будем считать как целая часть
m делить на n.
А, но сначала, прежде чем
вот еще так,
чтобы научиться делать деление,
на самом деле нужно сначала научиться делать сравнение.
Потому что хочется делать следующее.
Надо написать, что целая часть
m делить на n.
Это будет 0, если m меньше n.
И, соответственно,
1 плюс целая часть
m-n делить на n.
Иначе.
Значит, такое рекурсивное определение.
Но, соответственно, вопрос
как проверить?
Значит, как проверить
что m меньше m?
Ну, на самом деле достаточно научиться сравниваться
с нулем, потому что вы читать мы уже научились.
Вы читать научились,
соответственно, можно написать, что
m меньше n
тогда и только тогда,
когда
n-m
не равно 0.
Ну, где минус понимается в нашем смысле
со срезкой.
То есть, вот это получается
как
максимум из n-m
и 0.
Но, поскольку
отрицание мы тоже научились делать,
то достаточно
научиться проверять равенство 0.
Соответственно, получается, что вот мы свели
задачу
к вопросу равенства 0.
Значит,
соответственно, нужно
нужно проверять
равенство 0.
Читаем, нужно какой-то предикат
из 0,
который обладает следующими свойствами.
Значит, из 0, 0
равняется true,
а из 0,
n плюс 1
равняется false.
Вот.
Ну, в общем.
Значит, из 0
будет вот что такое.
Значит, это будет лямбда m.
Тут будет m
а тут будет n
лямбда x
точка false
true.
То есть, смотрите, что тут
говорит, что мы как бы итерируем n раз
константу лож
и примеем ее к true.
То есть, мы хотя бы один раз
итерируем, то результат будет константой лож.
Но если мы ни разу не итерируем,
то будет то, что изначально было
и изначально было true.
Вот.
Если подробнее расписать,
значит,
из 0, 0.
Значит, это будет
0
лямбда x точка false
true.
Ну, а 0 то же самое, что false,
а false то же самое, что взятие
второй координаты.
Это будет true.
Вот.
Значит, а из 0
n плюс 1
значит,
это будет вот такое.
Тут будет лямбда fx
f.
Дальше что-нибудь, неважно что.
Значит, дальше лямбда x точка
false
и дальше true.
Значит, соответственно, дальше это будет
Так, давайте я распишу.
Обычно.
Значит, вот это вот лямбда x точка
false поставится вот сюда вот.
Вот. Ну, а true даже неважно,
куда денется. В общем, true оно
куда-то вот сюда вот в это многоточие
подставится.
Вот. Совершенно
будет
будет лямбда x
точка false.
А здесь что-нибудь
будет. Ну, и
соответственно, это будет
false.
Потому что если мы в константе заменим x
на что угодно,
то останется та же самая константа.
Вот. Вот это вот последнее
может быть неинтуитивно
выглядит, но это правильно, потому что
это beta-редукция, потому что
мы все вхождения x
заменяем на вот это выражение,
но у нас нет ни одного вхождения x, поэтому
остается то, что было.
Вот.
Ну вот, соответственно, получается,
что мы с нулем сравниваем.
Раз с нулем сравним, то и вообще
сравниваем.
А тогда у нас есть рекурсивная форму
для деления, но только
непонятно, как собственно
эту рекурсию выполнить.
Так. Ну, смотрите, значит,
можно
и можно взять
и, нечто же сумняшусь,
взять просто и записать
вот так вот.
Значит,
что мы хотим?
Мы хотим
какой-то такой
стабильной формы
для деления.
Значит, мы хотим
какой-то div,
division.
Значит, мы хотим, чтобы он работал так.
Значит,
λdmn
точка.
Так, давайте считать,
что мы уже
определили комбинатор
сравнения.
Мы фактически уже сделали, чтобы не расписывать
подробно, значит,
lt это less than.
Значит, less than
mn, значит, если
m меньше n,
тогда это будет
константа ноль.
А иначе
это будет
инкремент
от
деления,
тут будет sub
так, значит, мы n из m вычитаем,
значит, sub mn,
тут останется n
и, собственно, все.
Вот.
Ну, казалось бы, вот так вот нашу рекурсивную формулу записали,
но проблема в том, что
у меня теперь это самое div
и слева и справа.
Division
получается
и слева и справа.
Вот division и вот division.
То есть это получается
уравнение.
Уравнение
на div.
Ну вот, если мы это уравнение решим,
то решение будет, соответственно,
комбинатором деления.
Так, как же
решать
такие уравнения?
Вот есть общий метод.
Значит, общий метод
это комбинатор неподвижной точки.
Также, вот этот сейчас
называют y-комбинатор.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Значит,
они называют разные формулы для y-комбинатора.
Каждый из отцов-основателей
этой области
придумал свой.
Там есть комбинатор Чорчо, комбинатор Кария
и еще несколько комбинаторов.
У Клиния я не помню.
У Клиния вот трюк придумал.
Вот.
А комбинатор неподвижной точки, ну может, тоже был такой не свой.
Вот.
Ну вот, например,
значит, например, можно
вот такой вот y-комбинатор взять.
Так.
Значит,
λ
x, y
точка y
от x, x, y
и еще раз
λ, x, y
точка y от
x, x, y.
Вот.
А смотрите, какая замечательная вещь.
Посмотрим теперь
на y, f.
Где f?
Это там какой-то еще комбинатор.
Так.
Давайте я даже на следующей доске,
чтобы у меня было много места.
Так.
Y, f.
Сейчас еще раз перепишу.
Значит, λ, y, точка y
от x, x, y.
Значит, обратите внимание на скобки.
То есть, вообще, правильно расстановка скобок
здесь очень важна.
Вот.
И еще f.
Ой, сейчас.
Не подождите, я же не то написал.
Сейчас.
Да, да, да, я не то написал.
Там было правильно.
Давайте я тут исправлю.
λ, x, y
λ, x, y должно быть.
Ой.
Ой, а что произошло?
Брос переключился.
Все, ничего не пропало.
λ, x, y.
И тут λ, x, y.
Вот. Так вот, смотрите.
Вот это вот.
Значит, вот это вот.
Вот эта вот часть, она
вместо x подставляется.
Так вот.
Вот сюда вот.
И вот сюда вот.
А вот эта вот часть
f.
Вместо y.
Вот сюда вот и вот сюда вот.
Вот. И что ж получается?
Значит, получается
f.
Дальше скобка.
Вот это вот открывается.
Дальше будет
λ, x, y.
x, x, y.
Значит, еще раз
λ, x, y.
x, x, y.
И после этого
f.
И теперь скобка,
вот эта вот скобка,
вот здесь закрылась.
Ну и теперь, смотрите, если посмотреть,
что вообще в скобках происходит,
то видно, что это ровно то же самое,
что было в предыдущей строчке.
То есть, это получается
f
от y, f.
Вот.
У нас любой...
Значит, любой комбинатор,
для которого при любом f
выполнено это свойство,
называется y-комбинатором.
Комбинатором неподвижной точки
Комбинатором неподвижной точки
Неподвижной точки
называется
любой y
такой, что при любом f
при любом f
верно
y, f
равно f от y, f.
Вот.
Так.
Таким образом получается, что
y, f
значит y, f
будет неподвижной точкой
комбинатора f.
То есть y, f
это неподвижная точка
неподвижная точка преобразования
f.
Вот. Это очень хорошо.
Это очень хорошо, потому что
теперь нам нужно только понять
неподвижная точка
какого преобразования
должен быть наша искомая div.
Давайте вернемся к уравнению.
Вот. Вот наше уравнение
для div.
У какого преобразования
вот этот div должен быть неподвижной точкой?
Ну, а у того, который вообще
все что угодно подставляет
в такую формулу.
То есть мы подставили div
вот сюда вот
и у нас получилось то же самое,
что было изначально.
То есть вот div это неподвижная точка
преобразования, которая
берет комбинатор и подставляет его вот сюда,
вот в эту формулу.
Вот.
Ну, соответственно, осталось это f написать
и будет решение.
Так.
Значит, тут
div fn,
вспомогательная функция
для деления.
Значит, это будет вот что.
Значит, это будет
лямда gmn.
Ну, а дальше нужно переписать.
То есть там было, давайте я заново напишу,
не буду копировать.
Лямда gmn.
Если less than
mn.
Значит, если m меньше n,
тогда константа ноль.
Значит, а иначе
нужно инкриментировать.
Что нужно инкриментировать?
Ну, результат деления,
то есть вот сюда как раз нужно ставить
функцию g,
примененную
к вычитанию
из mn.
Так.
Все вроде, да?
Так, давайте сравним.
Бывает то же самое, да?
А, n я забыл, да?
N я забыл.
Так, n нужно вот сюда вот.
Так.
Вот сюда вот n.
Вот, теперь правильно.
Ну вот, а после этого
сам div
будет неподвижная точка,
а неподвижная точка будет y
на div fm.
Ну вот,
а после этого
сам div
будет неподвижная точка,
на div fm.
Вот.
Ну, на самом деле, рекурсивное программирование
это очень такой мощный инструмент.
Да, значит, а может
очень много чего можно
сделать при помощи рекурсии.
Да, можно, скажем...
Ну, а сами
можно остаток считать.
Да, значит, можно аналогично
написать, например,
mod.
Это будет y.
Значит, а тут будет
аналогичная штука,
lambda gmn.
Так, только чуть-чуть по-другому.
Значит, если m
меньше n,
то тогда будет просто m.
Остаток по делению на n
это само число, если оно меньше, чем m.
Вот. А иначе
ничего ингредиентировать не нужно,
а нужно просто взять
модуль от...
не только не модуля,
а g.
Значит, g
от, соответственно,
mn и n.
Так, вроде бы правильно, да?
Значит,
вычитаем m, а остаток тот же самый.
Вот. Это, конечно,
прям что, если по этой форме прямо вычислять,
то это, конечно, совершенно не это самое,
неэффективное дело.
Не нужно так на самом деле
вычислять остаток, это будет очень долго.
Вот. Но
если нас это не заботит, заботит, в принципе,
теоретическая возможность,
то вполне годится.
Вот.
Ну а если у нас есть умножение
и модуль,
то у нас есть бета-функция Геделя.
Да, потому что там, собственно,
больше ничего не использовалось.
Ну, сложение еще, да?
Да, значит,
соответственно,
сложение, умножение
и модуль
дает бета-функцию Геделя.
Ну а бета-функция Геделя вообще все что угодно дает,
все выразимое.
Вот. И, соответственно, можно
через это вообще
через это выразить, в принципе,
все вычислимые функции.
Все вычислимые функции.
Вот. То есть действительно получается
альтернативная модель вычисления.
Вот. И тут же можно, в принципе,
тут повторить проблему остановки.
Это я уже не успею подробно
рассказать, но, в принципе, можно
точно также поставить вопрос.
То есть, давайте я
по крайней мере сформулирую.
Да, значит, аналог
аналог
аналог
неразрешимости проблемы остановки
да, значит, что
нет
нет комбинатора,
значит, который
получает
ну, даже может
просто другой комбинатор на вход
получает
другой комбинатор
и говорит
есть ли у него
есть ли у него нормальная форма
Вот. Ну, и так кажется, например, точно также,
если бы он был, то мы бы его там
применили сам к себе и
сделали наоборот.
Вот. В общем, это
на самом деле вот эта вот идея диагонализации
она тут всюду есть, да, и
в вычислимости, и в арифметике, и вот
я вот лямбое исчисление.
Так. Ну, ладно,
остается три минуты.
Вот. И остается только
рассказать какую-нибудь веселую вещь.
Напоследок
значит, напоследок
я расскажу
вот что.
Значит, есть другой
y комбинатор
называется y комбинатор
Клоппа.
Ну, тут уже для русского уха сама по себе фамилия смешная,
но
смешное тут не это
с математической точки зрения.
Вот.
Значит, а именно
значит, здесь
смотрите, сначала есть такой
комбинатор L.
Так.
И он выглядит так. Смотрите, лямбда,
A, B, C, D, E, F, G,
H, I, J, K, L,
M, N,
O, P, Q.
Дальше R пропущено.
S, T,
U, V, W,
X, Y, Z
и после этого R.
Вот. Это не случайно.
После этого идет следующее.
Тут будет
R,
а здесь в скобках
написано this is
a fixed
point
combinator.
Во.
А сам Y будет еще
этими самыми L
приписанными
26 раз.
Вот. Давайте я прям явно
напишу.
Так, 5.
10.
Так, сейчас не влезет.
Так.
Это 15, да.
20.
Так. 23
вообще не влезло немножко.
26 раз.
Значит, 26 штук.
Вот.
Вот такая вот штука работает
точно так же,
как и предыдущий Y.
Вот. И на самом деле
вот это единственный способ
запомнить.
Сможешь, конечно, вызубрить.
Вот.
Что вот так же, как здесь, только там покороче.
Вот. Тоже смотрите, что получается.
Ну, видно, что вот это
вот R. Значит, R играет
ту же самую роль,
которая вот здесь играл Y.
То есть Y повторяется вот здесь.
И вот здесь, если посчитать
буквки,
вот это все
кроме R, вот тут, смотрите,
вот 5, 10,
15,
20, 25,
26, да, ровно 26 букв.
Вот.
И эту тоже, да,
26 букв.
В общем, если действительно это
начать расписывать, да,
Y, F,
то вот будет как бы первая L,
потом еще 25 штук L и потом
F.
Соответственно, вот эти вот
25 штук L, кроме первой,
они поставят вместо всех букв латинского
аферита, кроме R.
Соответственно, вот здесь будет F.
Вот это все заменится на
L. Не важно, что тут повторяются
буквы, это все
на одну и ту же заметится, все равно.
И здесь тоже будет F.
И вот здесь останется ровно 26 L,
как и было.
Поэтому это действительно работает.
Вот.
Ну все, спасибо за внимание.
