Следующий пункт будет вот о чём.
Нет, про множество наследований мы потом будем говорить.
А она у нас вообще забанена или не вообще?
Нет, но нам пригодится более того однажды, даже не однажды.
Так, следующий пункт.
Это видимость и доступность методов родителя.
Ну вот смотрите, у меня есть класс Base, и в нём есть какой-нибудь метод f,
в котором будет один, и есть ещё, не знаю, поле x, есть derived наследник Base,
в котором есть поле y.
Ну давайте пока я безобидно вот так сделаю, назову по-разному, тут ничего интересного.
Всё понятно, это работает.
Что вы там обсуждаете, вы как-то очень громко.
Нет, ну тут всё понятно, тут нечего показывать.
Давайте я, чтобы было интереснее, это поле тоже назову x.
Как он называется 4,2?
Видимость и доступность методов родителей.
Ну, я бы сказал, видимость и доступность методов принаследования.
Вот, смотрите, я создал класс Base, и в нём поле x, а потом унаследовал от него derived, и в нём тоже сделал поле x.
Что же теперь будет?
Корректно ли так вообще делать?
Правильно, ну ты послушал, мы пока на перемене разговаривали про это.
Ну да, всё правильно, всё нормально, это нормально, это совершенно нормально,
типичная ситуация для плюсов, есть более локальный скоп и менее локальный скоп.
Вот если я сейчас выведу x из d, то выведется 1, потому что тот x, который в derived, он более предпочтительен.
В x конечно же есть и x из base, там их два теперь x в derived.
Но, значит, поскольку x, ну поскольку я из derived доберу x, то по умолчанию берётся этот.
А могу ли я взять x из base?
Вот, у меня есть derived, а я хочу x взять в нём из base.
В нём есть оба x, первый x не делся, он в нём по-прежнему есть.
Просто по умолчанию у меня derived выводится.
А как мне x из base достать?
В каком месте нужно base 2.0 написать?
Правильно, вот вы уже начинаете понимать, вот так надо написать.
2.0 и 2.0 более высокий приоритет, чем у точки, именно по этой причине, кстати.
Всё, теперь я взял x из base.
То есть оба x есть.
Ну ладно, тогда более интересный вопрос.
А вот я взял и функцию назвал так же.
И вызвал.
Ну, ничего интересного, выведется 2 просто, да? Нет.
Что?
А, потому что я пытаюсь, да, конечно.
Вот, и вызвал.
Ну, выведется 2.
Вот, я могу написать base 2.0.
Выведется 1.
А что если у меня ситуация такая?
Ну, сначала простой вопрос.
Вот, допустим, вот эта функция приватная.
И я не написал base 2.0. Что будет?
Молодцы, все уже правильно понимают, куда это работает.
Приватность не влияет на выбор версий перегрузки, конечно же, никогда.
Приватность просто означает, что вам запрещено.
То есть никакой подмены одной функции другой из-за приватности не случится.
Просто вам будет запрещено.
Хорошо, тогда вот такой вопрос.
А что теперь будет?
Ну, вообще, было бы логично, чтобы вызвалось из базы.
Значит, у меня в базе есть функция double, а в derived такая же функция от int.
А я вызываюсь из derived от double.
Выбирается с точно совпадающей сигнатурой, потому что первый приоритет при разрешении перегрузки.
У нас не происходит перегрузки.
Там, наверное, conversion все-таки.
Так, ну давайте голосуем. Демократический процесс.
Кто считает, что вызовется версия из базы?
Кто считает, что вызовется версия из derived?
А кто руку не опустил после первого?
А кто не знает? А кто думает, что CE?
Или UB?
Нет, ну явный каст будет.
Да.
Ну опять большинство ошибается.
Иначе бы я не задавал эти вопросы.
Вы вообще можете, кстати, уже заметить, что всякий раз, когда я устраиваю голосование,
это значит, что ответ, скорее всего, будет не тот, который все считает.
Да.
Интуиция здесь тоже подводит.
На самом деле вызовется от int.
И работает вот это... как?
Да, это не перегрузка функций.
Дело в том, что вот эти функции...
Короче, функции f от derived, f от double, f от int, они неравноправны здесь.
Они...
Ну, помните, когда мы с вами открывали, впервые изучали перегрузку,
там была страница overloading resolution, вот эти огромные длинные правила?
Я вам уже один раз напоминал, что там есть несколько стадий.
Первая стадия — это отбор кандидатов.
Вторая стадия — это выбор кандидата из подходящих.
И третья стадия — это проверка доступа.
Вот.
Так вот, если бы эти функции конкурировали на стадии выбор лучшего кандидата,
конечно, выиграла бы от double.
Но проблема в том, что функция f от double не попадает в кандидаты.
Она не рассматривается.
Дело в том, что если в области...
Ну, если в более локальной области видимости, то есть в derived есть уже f,
то версия от double не рассматривается в базе.
Набор кандидатов останавливается, как только мы увидели какие-то f в derived.
Короче, f от double в перегрузке не участвует.
Поэтому выберется, значит...
Ну, мне warning сказали, что...
Видите?
Вот.
Но веселее то, что даже если у меня вот такая ситуация,
сказалось бы однозначно какую функцию вызывать,
все равно она не вызовется, будет CE.
То есть это вот то, о чем название этого файла — methods-hiding.
Если у меня какая-то функция объявлена в derived с той же сигнатурой,
что была в base,
то она перекрывает видимость,
и теперь мне f из base невидимо.
С тем же названием, не с той же сигнатурой.
С тем же названием, конечно, да.
Вот.
Вот здесь ситуация в том, что мне f видна,
но доступна, но не видна.
Это название — видимость и доступность.
Помните, я говорил, что бывают видимые, но недоступные вещи?
Часто бывает, смотришь на что-нибудь, так хочется, а нельзя.
Вот.
А бывает доступные, но как бы ты бы и мог,
но не дотянуться, не видно.
Вот здесь ситуация, когда просто не дотянуться.
Можно было бы, но не дотянуться — недоступно.
Вот.
Это значит, ну, затмение.
То есть f перекрывает видимость того.
Ну, я мог бы сделать аналогично,
ну, а недоступно — это когда вот так.
То есть я мог бы сделать private вот эту,
ну, это пример, который я уже показывал.
Я мог бы сделать эту private от double,
а ту public от double.
Но она и так public.
И мне бы это не помогло.
Это все равно было бы ce.
Потому что эта штука видна, но недоступна,
а та доступна, но не видна.
Не видна — это значит, не участвует в конкурсе на перегрузку.
Прости, а у нас уже все было плохо
только потому, что у них были одинаковые названия,
даже не одинаковая сигнатура?
Что значит, все плохо? У нас все нормально.
Сейчас.
Почему, когда у тебя вот f в базе от double была,
а в диракти была просто f от пустоты, то было ce?
Потому что я вызвался от double.
Да, но вот в базе же есть от double.
Нет, она не видна.
Ее нет, она не рассматривается.
Я же про это и толдычил тут пять минут.
То есть мы в принципе не можем...
Не рассматривается версия из базе,
если есть такие имена в derived.
Скрываются они за ними.
У тебя в более локальной умности видимости уже есть такое имя.
Это имя не видно тебе.
Только от имени я же говорю. Только от имени.
От имени.
f уже есть в derived, поэтому f из базе не рассматривается.
Да.
Обравниваешься, чтобы так же работать с переменами.
То есть сейчас у нас есть x в внутреннем и внешнем.
Так и работает.
Так и работает.
Я только что до этого показывал.
Если я d.x пишу, то это получается я беру x из derived.
Я могу x другим типом здесь сделать.
Даже если могу private?
Конечно.
Даже если x private, все равно обращение к x,
сначала происходит определение того, к чему я пытаюсь обратиться,
а потом можно ли мне к этому обратиться.
Private проявляется в последнюю очередь и к полям, и к методам.
Хорошо.
Но, конечно же, я могу здесь написать вот так же.
Я могу написать d.base2.2.f.
Это вот то, о чем вы спрашивали.
А что за grain внутри сына?
А вот что.
Когда у вас внутри объекта...
Ну, воспринимайте это так, как будто у вас внутри d есть такая вот
внутренняя область видимости, в которой что-то напехано еще.
И вы можете к ней явно в нее проникнуть,
если вы хотите d.base сказать.
Но если бы здесь было private написано на следовании,
то, конечно, это было бы CEP.
Со словами, вам запрещено обращаться к...
Ну, base это приватный родитель.
Понятно?
Вот.
Однако есть следующая возможность.
Вот у вас, допустим...
Ну, вот вы определяете наследника,
и вы хотите, чтобы методы родителя у вас все-таки были доступны,
несмотря на то, что вы их затмили другими именами.
То есть вы хотите, чтобы все-таки...
Чтобы, короче, f от double наравне к перегрузке участвовал,
несмотря на то, что вы доопределили f.
А ты им скажем.
Нет.
D.
А дальше имя.
Внутри D есть, как бы, внутренняя такая областидимость под названием base.
И из нее я беру f.
Двойное двоеточие приоритетнее, чем...
точка.
А точка приоритетнее, чем круглые скобочки.
D есть не переменная.
Внутри D есть, как бы, такой...
Ну, считайте, что такое контейнер.
И в нем есть, как бы, внутренняя еще переменная,
и еще другие методы.
Это D двойное двоеточие приоритетнее.
Это вот так вот считается.
Здесь я указываю qualified ID, то, что называется.
Я говорю f с префиксом откуда.
Я говорю, у объекта D вызвать не обычную f, а вот f отсюда.
Так вот, я могу...
захотеть, чтобы в derived, тем не менее, была видна f от double,
и чтобы она участвовала в перегрузке наравне с...
этой.
Тогда я могу написать using.
Using base...
Вот если я так напишу,
то теперь уже будет нормально работать перегрузка.
Когда я написал здесь, в области видимости derived,
using base f,
я привнес все версии f сюда,
и теперь они наравне участвуют в перегрузке вместе с версиями из derived.
И вот теперь вызовется f от double.
Когда ты объявляешь функцию, ты не можешь ей...
Ты объявляешь функцию в пространстве derived.
Ты не можешь, объявляя функцию в каком-то пространстве,
присвоить ей как бы другой префикс.
Если ты объявляешь f в derived, то она будет из derived.
Ты не можешь при объявлении задать квалифицированное имя.
Вот, так можно привнести только сразу все f.
То есть я не могу отдельно привнести, допустим, f от double.
Если я привнесу f, то все версии.
Я могу также и x привнести.
Вот, смотрите, я написал using base x еще.
И теперь у меня будет...
Ну, на самом деле, это CE уже на этапе, когда я написал using,
потому что переменную привнести сюда так нельзя.
Это будет, значит, конфликтующее имя переменной.
Вот.
Теперь интересный вопрос.
Вот если эта base была private...
Ну, если эта base была private,
то я ее using сделать не смогу из derived, очевидно.
А если она была protected?
Ну, вот нет.
Если я пишу using, то я в паблик ее привношу сюда.
Когда я в публичной области derived написал using base f,
несмотря на то, что base f protected, но мне-то она доступна,
я ее сделал доступно извне теперь тем самым.
То есть это нормально будет работать, несмотря на то, что там она была protected.
То есть я как бы вытащил ее наружу и разрешил внешним ей пользоваться.
Вот.
Ну, вот вот.
То же самое с конструкторами.
Вот у меня есть, допустим, конструктор base от чего-то.
А от derived нет, а у derived нет такого конструктора.
Я могу захотеть, чтобы derived можно было конструировать
от того же от чего base конструировался,
в derived нет дополнительных полей и я не хочу derived переопределять кучу конструкторов от того
же самого от чего base был тогда я могу написать using base 2.2.base вот эта конструкция очень важно и
очень часто применимая только начиная c++11 появилась то есть я пишу using base base и тем
самым я разрешаю создавать derived от всех тех наборов аргументов от которых base было можно
создать правда таким образом не наследуются конструкторы копирования и конструкторы перемещения
ну короче конструктор копирования так не унаследуется вот если я скажу base b а потом скажу derived
d равно b то это не будет компилироваться потому что конструктор копирования такой конструкции
не наследуется вот нельзя вызвать нечего сконструировать derived вот но если я просто
скажу base b от чего-нибудь там ну derived d у меня теперь derived d кстати у меня должно быть можно
сконструировать сейчас наверное потому что у derived а нет нельзя потому что теперь у derived
есть какой-то конструктор и он только от от этого разрешает себя ну вот короче теперь derived
можно создавать нельзя потому что он protected что а прекрасно значит для конструкторов такая
штука не работает конструктор обязательно надо чтобы был паблик чтобы так работала ну хорошо
так ну вот теперь работает все короче я теперь могу derived создавать от int унаследовал
конструктор из base запомните эту конструкцию она часто нужна и она нам еще один раз спасет
жизнь буквально это будет очень весело и задорно но в конце второго семестра ну да
наследование конструкторов из родителя вот потому что так решил комитет по стандартизации
ну я не знаю как еще ответить ну вот почему-то видимо они забыли закастылить ну типа обычные
функции если привносит что они работают а конструктор если протекто привносить не
работает почему-то так давайте сейчас как раз я начну отвечать на этот вопрос и тем самым
перейдем к пункту 3 следующий пункт это нас значит конструктор и деструктор и принаследовании
пункт 4 3 называется конструктор и деструктор и в случае наследования
прежде чем говорить о конструкторах и деструкторах надо поговорить о том а как
вообще объект памяти устроен когда у нас наследование но вот на самом деле когда у нас
наследование я уже неоднократно эту метафору использовал но можно сказать сейчас прям прямым
текстом что в дирайвде создается прям часть называемая бейс то есть буквально когда у вас
есть класс наследника класс родитель то в классе наследники есть прям кусок называемый бейс и
он создается сперва прежде чем начать создавать настройку дирайвд когда у вас что-то наследник
чего-то то это означает что вот оно надстройка над ним дирайвд такая надстройка над бейс в которой
возможно есть какие-то дополнительные поля но перво-наперво обязательно создается бейс когда
вы создаете дирайвд то есть вот опять допустим у меня есть структура бейс и в ней есть какие-то
поля не знаю стд вектор int в
и вот у меня есть наследник
ну и тут есть еще какие-нибудь поля не знаю стд стринг и дабл вот я определяю конструктор
наследника но давайте начало когда мне нет никаких конструкторов вот что происходит когда
я создаю бэйз а нет никаких явно объявленных конструк perceber merchant и нет никаких явно
объявленных конструк dawn сначала создается бейс потом дирайвд то есть сначала инициализируется
вот это поле, потом создается вектор, после этого часть base считается созданной, после этого
настраивается над ним derived, создается значит строка, потом double. Я могу это проиллюстрировать
вот таким образом явно, сказав вот здесь вот что-нибудь такое. То есть когда я создаю derived,
у меня обязательно перед этим вызывается дефолтный конструктор base. Часть derived не начнет
создаваться пока не закончится создание base. Если у меня в base есть дефолтный конструктор,
то он и вызовется, ну при этом если у меня в base есть другие конструкторы, то они не вызовутся.
У меня вызвается именно дефолтный конструктор, потому что дефолтный конструктор derived вызываю.
Он по умолчанию дефолтный конструктор base вызывает. В каком порядке это работает. Сначала
инициализируется поля base. потом конструктор base отрабатывает и только потом начинает
унициализироваться поля derived. А потом, если есть, вызывается тело конструктора derived.
Вот сейчас выяснится 1.2. Ну, как вы можете догадаться, с деструктурами то же самое в обратном
порядке. Когда уничтожается объект derived, то сначала вызывается деструктур derived,
потом уничтожаются поля derived, потом вызывается деструктур base, и потом уничтожается поля base.
Вот сейчас выведется 1.2.-2.-1. Обязательно, всякий раз, когда создается derived,
сначала создается base, потом надстраивается derived. Когда уничтожается derived, сначала разрушается
та часть верхняя, которая derived, а потом то, что ядро его, это base. При этом всегда сначала
тело деструктора отрабатывает, а потом разрушаются поля. Так, есть ли вопросы здесь?
Если у base запретит дефолтный конструктор, то мы не сможем derived создать? Конечно. Если я
здесь напишу base равно delete, то разумеется derived по умолчанию тоже создать не получится,
потому что непонятно как base создать, base явно запрещено создавать по умолчанию.
Вот. Сейчас, а вот это string, такая же строка, которая лежит в библиотеке string? std string, да, а что?
А как ты ее создал без библиотеки string? Она в ее string просто подключена. То есть даже если
ты отключишь vector, то ты все равно так можешь написать? Нет, она, да. Но в ее string просто
заинклужен string, поэтому, когда я заинклюзил его string, string не нужно инклюзить, можно не
инклюзить. Так, окей. Хорошо, но теперь, если я хочу конструкторы не по умолчанию. Допустим,
у меня здесь есть конструктор не по умолчанию, но вот конструктор по умолчанию нет. Есть какой-нибудь
конструктор не по умолчанию от int, который инициализирует вот этот x. Теперь я опять не могу
создать derived по умолчанию. Понимаете почему? Потому что не объяснено как создавать base,
поскольку у base есть не дефолтный конструктор явный, то компилятор уже не генерирует для него
дефолтный конструктор, а поскольку я в derived не сказал чем проинциализировать base, то он не
знает чем унициализировать, дефолтный конструктор не работает, будет ce. Вот, и вот здесь в конструкторе
derived, если я не, вот когда я вхожу, когда я пишу конструктор derived, смотрите, мне что написал
компилятор. Конструктор для derived должен явно инициализировать base, у которого нет
дефолтного конструктора. Вот если я не указал в конструкторе derived чем инициализировать base,
он пытается base инициализировать по умолчанию, дефолтным конструктором, соответственно. Но
поскольку так не работает, мне нужно в derived указать сначала чем инициализировать base,
прежде чем derived начинать. И вот для этого опять используются списки инициализации. Как они
используются? А вот так я пишу base от чего? Поскольку мне дефолтный конструктор base вызывать
не получается, нужно написать от чего я создаю base, прежде чем начать издавать derived. Ну,
такие делегирующие конструкторы у нас были с вами, когда мы вызов одного конструктора из
другого обсуждали, но тут вызов конструктора родителя из конструктора потомка. Я могу
дальше, после того как написал чем инициализировать base, перечислить еще чем инициализировать свои поля.
Допустим, d инициализировать надо каким-нибудь другим числом. Я могу в конструктор сюда принять,
например, double d и сказать, что я d инициализирую вот этим, а base нулем. Или я могу вот так сказать,
типичная ситуация, я принимаю x, base инициализирую этим x, а свое поле вот тем,
чем мне дали. Вот все теперь корректно работает. То есть мне, когда дают параметры моего конструктора,
я сначала обязан, причем это обязательно, сначала нужно сконструировать base, либо оно будет по умолчанию
сконструировано, а иначе c и передать ему аргументы туда, и оно будет там работать. Ну, соответственно,
до того как сконструироваться, оно сконструирует свои поля и так далее, а потом через запятую
перечислить, чем я свои поля инициализирую. А, ну да, потому что мне нужно здесь от чего-то
вызваться. СТР само может сконструироваться по умолчанию, мне не надо писать, чем его
приницилизировать. Да мне и d и x не обязательно было писать, я просто хотел их чем-то принцилизировать,
а v и СТР спокойно по умолчанию нормально создадутся, пустыми просто. У v и у СТР вызовутся
конструкторы по умолчанию, поскольку я не написал какие вызвать, вызовутся по умолчанию.
Компилятор в любом случае сначала инициализирует СТР, потом d,
но СТР инициализирует пустой строкой, поскольку я не написал чем, а d инициализирует тем,
чем я написал. Значит еще раз, как работает этот пример? По шагам. Я вызываю конструктор d от
двух чисел, попадаю сюда, компилятор видит, ага, начинаем создавать дирайв, значит первым делом надо
создать бейс. От чего создать бейс? Вот от чего здесь написано. Идем, создаем бейс, пока ничего с
дирайвом не делаем. Хорошо. Начинаем создавать бейс от x. Так, прежде чем создать бейс, нужно
сначала инициализировать поля. Сначала надо инициализировать x. Чем инициализировать x? Тут
написано чем. Вот этим. Инициализируем. Дальше надо инициализировать вектор. Чем инициализировать
вектор? Не написано чем. Значит создаем вектор по умолчанию. Что значит создаем вектор по умолчанию?
Вызываем вектору конструктор по умолчанию. Вектору сначала надо инициализировать поля.
Чем их инициализировать? Ну там написано СЗ, КЭП, там вот этот указатель. Все сделали, окей.
Конструктор вектора отработал. Закончился конструктор вектора. Отлично. Инициализируем
поля бейс. Заходим наконец в тело конструктора бейс. Выполняем тело конструктора бейс. Все,
создали бейс. Отлично. Возвращаемся сюда. Бейс создали. Пора инициализировать поля дирайв.
Сначала СТР. Чем инициализировать? Не сказано. Значит по умолчанию. Значит называем конструктор
стринг по умолчанию. Значит инициализируем сначала поля ему. Там по умолчанию этого стринга.
Окей. Тело конструктора стринг потом. Отлично. Стринг создали. Теперь Д. Чем инициализировать Д?
Написано чем. Вот этим. Отлично. Создали Д. Все, поля инициализировали. Вызываем
наконец тело конструктора. Выводим два. Все, тело отработало. Дирайвт создан. Классно. Вот так
это работает. Когда деструктор отрабатывает? Все в обратном порядке абсолютно. Вызывается область
видимости. Дирайвт заканчивается. Вызывается деструктор дирайвт. Первым делом тело деструктора.
Выводим минус два. Отлично. Тело деструктора отработало. Пора разрушать поля. Сначала убираем
Д. Снимаем Д со стека. Тут нечего вызывать. Потом СТР. Значит надо вызвать деструктор СТР сначала.
Вызываем. Отрабатывает тело деструктора СТР. Снимаем со стека поля СТР. Отлично. Разрушили
часть дирайвт. Теперь пора разрушать бейс. Сначала отрабатывает тело деструктора бейс. Выводим минус
один. Теперь пора разрушать поля бейс. Уничтожаем вектор. Точно так же деструктор. Потом поля. Потом
снимаем со стека Х. Все, деструктор отработал. Закончили разрушать дирайвт. Строго в таком порядке.
Это надо понимать как работает. Если мы напишем using конструктора бейс. То есть допустим я напишу
здесь using base 2.2.base. Тогда я дирайвт научусь создавать от единицы просто. Как это будет работать?
Просто дирайвт в этом случае будет по умолчанию инициализироваться. Часть дирайвт. То есть я
задаю дирайвт D от единицы. Тут написано using base от бейс. То есть OK. Часть дирайвт сама
инициализируется. Тело будет пустым. Вся часть которая инициализирует бейс остается как раньше.
А часть которая инициализирует дирайвт. Давайте на всякий случай проверю. Ну да. А часть которая инициализирует
дирайвт просто у нее пустое тело, но поля инициализируется по умолчанию. Ну что там написано то и будет в этом
конструкторе. Тогда это конфликтующее определение. Вот такие дела. Значит вот здесь можно инициализировать
только свои собственные поля. Я не могу здесь написать X в скобочках что. То есть вот так я не могу
написать например. Вот вместо base X написать вот так не могу. CE. Нет у меня поля X. Я могу только
делегировать родителю инициализировать его поля. А сам инициализировать свои. А так не могу. Это будет
CE. Вот и последняя штука о которой я расскажу в этом пункте. Это так называемая empty base optimization.
empty base optimization. Это вот что. В скобочках EBO. Иногда в коде STL вы можете встретить такую
аббревиатуру EBO что-то там. Вот это означает empty base optimization. На самом деле мы с вами. Я сейчас про
нее расскажу. Вот. А пользоваться мы ей начнем в задачах по интересе во втором семестре. Как работает
empty base optimization. Ну что такое empty base optimization. Эта штука которая говорит следующее. Если у вас в
родителе нет полей. То не надо ему место занимать. Ну смотрите если у вас есть пустая структура. Ну вот
допустим. У меня есть такая структура. struct empty. Весьма между прочим полезная. Очень часто
нужная. Я попрошу. И вот есть значит. Наследник empty. Чему равен size of от empty. Чему. Единица.
Почему 8. Потому что любой объект хоть один байт занимать должен. Если бы у вас объект не
занимал нисколько байт. То это бы означало что его адрес совпадает с адресом следующего за ним
объекта лежащего на стэке. Но так нельзя. Тогда empty это. Ну объект класса empty сколько занимает.
Когда я спрашиваю size of empty. Я спрашиваю сколько будет занимать объект класса empty. Также как
size of empty я спрашиваю. Вот сейчас будет один. Ну значит тут много чего еще не работает. Вот это
мы закомментируем. Вот сейчас будет один. Понимаете почему один. Да кто понимает. Все понимают
почему один. Не ноль. Не может быть размер объекта равен нулю. Потому что так решил комитет по
стандартизации. Да 4 было бы. Если был бы чар то был бы все равно один. Если был бы дабл то 8. Если мы
зададим вектор empty то мы просто займем память. Если мы зададим вектор empty то у нас будет да вектор
объектов каждый из которых размеры один. Ну шучу просто займем память. Мы ничего там не будем хранить.
Ну да. Но тем не менее размер объектов. Это мы уже обсуждали в предыдущей главе. Я говорил что никакой
объект не может занимать ноль байт. Потому что тогда нельзя было бы. Потому что тогда было бы
нельзя различить два соседних объекта по их адресам. Вот поэтому хоть один байт занимать должен.
Но вот я сейчас спрошу а чему равен размер empty derived. И как вы думаете чему он будет равен.
А вот и нет один тоже. Но вы скажете в нем же есть часть от empty которая один байт занимает.
А есть еще он сам который один байт занимает. Ну вот в этом то и заключается empty base optimization.
Если у вас есть наследник родитель который в котором нет полей то разрешается этому родителю
никакую часть не занимать в памяти вашей. Ну вот эта вот штука которая родитель от вас составляет.
Она будет действительно пустой если вы наследник. Нет empty существует. Ну что значит empty не существует.
Область видимости в рантайме оно просто байт не занимает. Но оно существует как сущность в
компайл тайме к ней можно обращаться и так далее. Наличие методов никак не влияет на
размер. Не влияет пожалуйста я могу. Поля методы они же не занимают памяти. Поля это переменные.
Методы это функции. Чего? Фактически. Есть ли в памяти где-то лежащий объект типа empty когда мы
создали empty diray. Видимо нет если размер не меняется. Ну нет получается нет. Ну как
компилятор формально выполняет все что должен выполнить. Он просто вызывает его конструктор.
Если у него будет конструктор он сделает код конструктора. Но поскольку полей нет он забьет
и empty diray класть начнет на то же место на котором по идее адрес вот этого empty был. Ну адреса кого
начинается подать. Это же один объект. Просто часть одного объекта. У меня же нет отдельно прям
полноценного объекта empty. Просто это часть объекта empty diray в которой внутри. Вот смотрите
я в empty diray объявил char. А в empty объявил f. Это ни на что не повлияет. То есть в empty diray теперь
один действительно настоящий char. А в empty функция f. Но функции не влияют на размер объекта. Только если
они не виртуальные. Но об этом потом. Вот все еще один. Вот если здесь будет char то это уже поменяет
дело. Теперь будет два в empty diray. Кажется. Нет все равно один. Ха. Значит это работает в обратную
сторону. А я думал не работает. Да но empty diray значит тоже можно не не не достраивать.
Так понятно как работает empty base optimization. Зачем вообще может потребоваться наследоваться от
пустого. Пустого чего. Только метод. А защищать смысл. Например. Да ну да чтобы методу наследовать.
Ну. Я бы вам привел примеры. Ну давайте я вам просто скажу что большая часть примеров
наследования в этом курсе будет наследованием от пустого класса. Трудно убедить вас каким-то
конкретным примером. Но к концу года вы поймете что как правило от пустых наследоваться нам и
предстоит. В основном потому что нам методы нужны будут и не поля. Зачем там. А что там методы то они
вообще будут делать пустого. Что. Нет виртуальные это уже не пустой будет. Он уже будет занимать.
Если вы сделаете цепочку больших наследник empty diray empty diray diray и так далее у них у всех
суммарно будет размер один я думаю. Все сожмутся кроме одного. Ну да empty diray тогда
будет нулем. Ну они и сожмется. Да я вот показал тоже все равно один занимает. То есть не важно
какой из цепочки у нас. Ну да да он их видимо сжимает все. Я думал он только родители но и этого
тоже сжимает. А как у нас может быть пустой класс наследника. Что. В чем проблема. А в чем я не
понял вообще в чем проблема. То есть по сути мы сглаживаем все поля и делаем все равно один.
Чего. Ну ладно. Не важно. А зачем. Подожди что тебя смущает. Если у нас класс наследуется какого-то
то как минимум у нас следуют все поля своего родителя. Ну понятно в нем есть часть родителя
которую ничего не добавляет. Ну я имею ввиду надстройка пустая. Ну мы говорим про empty
base optimization. Вот у меня сейчас empty не пустой а empty diray пустой. И суммарно они занимают один байт.
Хотя если бы я каждого из них создал по отдельности они бы занимали по одному байту каждый. Но поскольку
empty diray пустая надстройка на демпте то она ничего не добавляет к нему и суммарно не занимать один
байт все еще. В этом. История. А если у нас в немте будет сейчас поле какое-то интовое. Ну будем выделять
внешнюю память. Если в empty будет интовое поле. В смысле лишнюю память. Конечно int я должен
положить на адрес кратный четырем. Поэтому три байта будет пропущено. После чара. Потому что это
должно лежать перед этим. Соответственно если я в empty diray положу int. У меня размер всего вместе станет уже восемь.
А зачем нам. У нас пустой класс. Если в нем какие-то методы они же все де-факто статические. Что?
У нас нет никаких полей. Нет они не статические. Примером такого класса является например локатор.
Вот у него вообще не статические методы. Нифига. Ты берешь объект локатора и ему говоришь выдели память.
Они же ничего не меняют внутри самого объекта. Они не относятся никому объекту. Относятся. Ну по
смыслу относятся. У тебя данных никаких не хранится. У тебя stateless объект. Но это не значит что нужно его
функции делать внешними функциями. Ты все еще считаешь что этот объект что-то умеет. И ты у него просишь это сделать.
Давай просто мы дойдем до ситуации когда мы с этим столкнемся и ты увидишь что оно так действительно
работает. Просто сейчас мне трудно это на абстрактных абстрактно объяснить. Ты увидишь это на конкретных
примерах через несколько лекций. Что у нас в таких ситуациях будет очень много. Все вот теперь я
перехожу на доску и наверное буду на ней оставаться до конца сегодняшнего вечера.
Сайзов объекта. Паля выравниваются.
Объект кладется так чтобы int лежал на адресе кратным 4. Дабл лежал на адресе кратном 8. Чтобы все поля размера 4
лежали на адресе кратном 4 и так далее. По фундаментальным типам выравнивания происходит а не по большим типам.
Вектор должен класситься на адрес кратный 8. Потому что в нем поля это указатель и указатель и указатель и два сайса.
Указатель должен начинаться с адреса кратного 8. Когда был викинин, то у нас это заняло только 12 байтов.
Нет 16. Потому что дополнится до 4 чтобы следующий объект такого типа лежал на правильном адресе.
Мы это разбирали уже. Так вот сейчас будут интересные веселые картиночки. Мы начинаем замечательное приключение в мир приведений типов принаследования.
Сейчас будем графы рисовать. Сейчас пока еще не так весело будет, но вот через полчасика совсем весело.
Значит Type Conversion в случае наследования.
Вот смотрите.
Может кстати я и рано на доску перешел. Ну ладно. В следующем пункте точно надо будет рисовать, там иначе никак.
Вот смотрите у меня есть Base и Derive. Но я не буду писать снова что там структура. Вот у меня есть Base и Derive.
В чем вообще смысл наследования? Я могу использовать Derive там где ожидается Base.
Ну то есть Derive частный случай Base. Derive это тоже Base. Если меня ожидает Base, то я могу Derive отдать.
Допустим у меня есть функция которая принимает Base по ссылке.
Вот. Ну не буду имя ему давать никакого. Вот. Могу ли я в эту функцию отдать Derive?
Конечно могу. В этом смысл наследования. Но совершенно верно. Только если наследование публичное.
Значит тут первое что я могу сделать. Если у меня есть Derive D. Я могу функцию которая ожидает Base отдать D по ссылке.
И функция будет работать с ним как будто это Base. Ведь все что есть у Derive есть и у Base. Все что есть у Base есть и у Derive.
Значит если мне отдали Derive, то мне он полностью подходит. Ну соответственно если я здесь из этой функции буду вызывать какие-то его методы, то будут вызываться те их версии которые от Base, а не от Derive.
Понятно. Потому что я его как Base принял и компилятор статически его, значит все методы и поля будут из Base брать. Вот.
За сколько он проведет конверсию? Что значит за сколько? Он может сказать что использует только поля Base. Ну. Ничего не понял. Что он должен сказать?
Мы ему передали Derive. Да. Вот. Он сделает полную копию или он... Нет он ссылку уже принял. Да.
Получается он не будет делать полную копию. Никакую копию он не будет делать. Он ссылку принял. Он смотрит на Base. Это же ссылка. Мы смотрим на этот объект как будто это Base.
И все что мы от него вызываем берется из Base его части. Никакой копии не делается. Если у вас константная ссылка на Base, то то же самое, но при этом мы сможем вызывать только константные методы из части Base.
Ну то есть полная аналогия с тем как вы передаете константный и не константный. На самом деле это важная, это очень правильная аналогия.
У вас бывает допустим Int и вы передаете его по ссылке как константом персант. Вот. И то же самое вы можете Derive передать по ссылке как Base.
Свободно. Не явно. И это будет означать, что из этой функции вы можете, вот это бы означало, что вы можете только те операции над Int делать, которые константные относительно, которые помечены конст.
А если вы приняли по ссылке на Base объект Derive, то это означает, что вы можете только те его методы вызывать поля, которые у него от Base взяты. Ну которые из части Base его.
А если вы еще и конст дописали, то это значит, что вы только те из них можете вызвать, которые из Base да еще и конст помечены. Все логично, все понятно.
Вот. То же самое с указателем. Если я принимаю Base по указателю, а сюда даю адрес Derive, то тоже работает все прекрасно. Я могу указать под указатель на Base под ссылку Derive.
И по этому указателю я смогу вызывать, опять же, все поля и методы этого объекта, которые из Base взяты. Из Derive не смогу, а из Base смогу.
Вот. То же самое, если я конст Base звездочку приму. Опять же, я смогу по этому указателю вызывать все те методы и поля, которые взяты из Base и при этом еще и конст помечены.
Вот. Хорошо. А что если я по значению принимаю, как работает этот газ? Это вообще будет работать?
Ну, нам тогда нужен какой-то конструктор от Derive просто.
Ну, он автоматический.
Вот. Другими словами, могу ли я написать, ну, то есть предыдущие три случая, по сути, говорили, что я могу написать Base&B равно Derived.
Ну, Base&B равно D. Вот это неявный каст от наследника к родителю, который разрешен. То есть по ссылке на родителей я могу подсунуть наследника. Это окей.
Если наследование публичное, только я напоминаю, если приватное или защищенное, то это не работает. Это первый момент.
Да. Вот если у вас наследование приватное или защищенное, а вы находитесь не в методе соответствующем какого-то класса, то это будет CE.
Потому что приватное наследование в том числе означает, что вы из внешних функций не можете делать каст к родителю от себя.
Допустим, функция Main не может использовать тот факт, что вы, в частном случае, Base. Поэтому при приватном наследовании вот такая конструкция будет CE.
Только если вы при этом сами находитесь не в методе Base, в котором создали зачем-то лишний объект Derived, и в нем вот так сделали.
Если вы это все напишете в методе самого Base, при приватном наследовании Derived от Base, то это, конечно, сработает.
Потому что из методов Base можно пользоваться тем фактом, что это наследование.
А из внешних функций, которые не друзья, нельзя так писать. Из друзей можно быть.
При защищенном наследовании тоже сработает.
При защищенном наследовании это сработает только если вы в методе либо самого Base, либо Derived, либо наследника Derived, либо друга.
Защищенное наследование значит, что вам можно этим пользоваться из всего того, что я перечислил, но не из внешних функций.
Сейчас если я напишу дальше B равно какому-то другому Base, то у меня Derived поменяется только часть, которая Base.
Ну вот в D у меня...
Да, это отличный вопрос.
О, кстати, прекрасный вопрос.
Если вы замените здесь Base на что-то другое, то есть если у вас в Base есть оператор присваивания,
от какого-то другого Base, а при этом вы работаете со ссылкой на Derived, ну да, у вас часть Base поменяется.
Вот та надстройка Derived останется, а Base поменяется.
И соответственно, если эта надстройка Derived как-то странным образом использует то, что было Base, понятно, может произойти страшное.
Ну то есть если она использует какие-нибудь указатели на то, что там было,
то после оператора присваивания произойдет какая-то неприятная...
Ну да, вроде как да.
Ну в такой случае это какая-то изотина.
Ну это странные экискейты, понятно, но...
Кстати, проверьте, что это так работает, что я насаневался.
Ну по идее нужно так работать, чтобы вы присваиваете и меняется часть Base.
Вот, ну, с указателем то же самое, то же самое с Const.
Вот, понятно, ну, Константность независимо значит работает.
Все правила с Константностью сохраняются.
Ну вот, что если я здесь имперсант не поставил, я писал Base B вновь.
Что тогда будет?
Тогда будет так называемая срезка при копировании, по-английски называется slicing.
Вот то, что здесь написано, называется slicing.
Эффект срезки.
А произойдет копирование части Derive, которая является Base.
Причем неважно у вас там был конструктор явно и нет.
То есть вызовется конструктор копирования Base от Base.
Вот от той Base, которая была в Derive.
Вот там были какие-то поля, вот они и будут копироваться.
Ну если у вас для Base определен отдельно,
вы сами определили конструктор копирования для Base, то он вызовется.
То есть из Derive будет забрана часть Base изкопирована в этот новый Base.
А часть Derive останется как бы нетронутой.
Просто у вас создастся копия куска, ну то есть грубо говоря,
на картинке это вот так.
То есть у вас есть Base и есть настройка Derive.
И вы вот так вот взяли и скопировали Base.
Типа срезали, а вот эту часть не тронули.
Но это если мы ничего дополнительнее не делаем.
Если мы Base сделали конструктор от Derive, то он...
Да, если вы Base сделали явно конструктор от Derive,
что странно.
Там вам нельзя конструктор выше, он более низкий.
Нет, вы можете его...
Сейчас я только думаю, получится ли у вас это вообще написать.
Потому что вам для этого придется...
Вам придется Forward Declaration Derive сделать.
Ну, почему нет?
То есть вам придется написать класс Derive, потом класс Base и определение этого класса.
А потом... А как вы будете поля Derive использовать?
То есть вам, чтобы написать определение Derive,
нужно... Ну, чтобы вам использовать в конструкторе поля Derive...
А, ну хотя...
Вы можете сделать Forward Declaration метода, потом сделать определение Derive со всеми ветами,
а потом уже Definition самого метода.
Кажется, тогда получится.
Ну, типа.
Ну да, тогда, кажется, будет работать.
То есть вы можете...
Ну, не понятно зачем, Дан, то есть если вы определите свой конструктор Base от Derive, то да, он вызывается.
Это странный, конечно, сценарий.
Вот.
И опять же, если наследование приватное или защищенное, то это тоже не будет работать.
Ну, только если вы не в члене или в друге, или где там полагается быть, чтобы это работало.
Ладно.
А теперь, вот что.
А как по обратную сторону?
Вот, если у меня есть Base,
а я хочу из него сделать Derive.
Ну вот, у меня есть ссылка на Base,
а я хочу опять сказать, что это Derive, на самом деле.
Ну вот.
Вот, ваша любимая.
Как и с Const, я хочу, по какой-то причине, зная, что это на самом деле Derive,
считать его Derive, да мы не боимся.
Как я могу ли это сделать?
Ну, если он изначально был Derive, то почему бы и нет?
Да, но как это написать? Вот так это, конечно же, не скомпилируется.
Вот.
А какой каст?
Не, не скомпилируется.
Сас, ссылка.
Значит, какой каст мне надо использовать?
Если я хочу под Base,
иметь ссылку на Base,
считать ее ссылкой на Derive.
Да все проще, StaticCast работает просто.
Значит, на самом деле сработает обычный StaticCast.
Никакой его DynamiteCast,
и ReiterBedCast пока не нужно.
То есть, я пишу Derive and Impressant равно StaticCast
к Derive and Impressant
Вот. Заметьте, кстати, к ссылке.
То есть, я пишу Derive and Impressant.
D D равно StaticCast к Derive and Impressant.
Вот.
B и нормально работает.
Вот.
Правда вопрос.
А что, если на самом деле там был не Derive,
а Base настоящий?
Ну, тогда убы.
Ну, то есть, после этого
я могу обращаться к D D,
как будто это настоящий Derive.
Вот. Вызывать у него какие-нибудь методы специфичные для Derive.
Поля вызывать.
Ну, как будто это настоящий Derive.
Но, дело в том, что
компилятор будет просто
соответствующие сдвиги делать.
У меня было в Derive, например, поле
Допустим, в Base был Int,
а в Derive был еще поверх него
какой-нибудь другой Int, я не знаю.
И я, по сути,
ну, то есть, по сути,
когда я написал так,
я просто считаю, что вот у меня ссылка
на эту часть Derive.
А когда у меня был Base,
я как бы считаю, что на самом деле ссылка
теперь, вот этот кусок памяти,
вот он раздулся. То есть, я смотрю на него
как будто это Derive, и вот эта часть памяти
тоже считаю своей теперь,
и там реально был Derive.
Мне повезло, я действительно буду
к нему обращаться,
к его полям методом. А если нет, то
обращение к ним будет убыло.
Ну, как при касте
от константа
к неконстанте.
Вот эта схема,
которая нарисовалась константностью,
она очень
похожа аналогия. То есть,
у вас есть
вы можете
свободно кастовать
в эту сторону.
То есть, вы можете обычный int,
как и конст-инт,
отдать по константной ссылке
свободно куда-то, без кастов
явных.
Только я наоборот
сделал, надо здесь написать.
Надо не так сделать.
Короче, вы можете
по константной ссылке, обычный
int
вы можете отдать
как по такой ссылке,
так и по такой ссылке,
константный только
по константной ссылке.
А если вы хотите константный int
отдать по неконстантной ссылке,
то вам нужен const-cast.
Вот такая схема у нас была с вами.
Вот тут вот const-cast.
То есть, это такая вот
опасная операция.
Вы можете это сделать, но если вы
не отгадали и вам не повезло, будет убыло.
И абсолютно аналогичная схема
с наследованием.
Вы можете
как base
вы можете
derived
вы можете derived
отдать как по ссылке на derived,
так и по ссылке на base.
А вот base, чтобы отдать по ссылке
на derived, вам нужно
статик-cast, и вот он опасный.
Если вам не повезло, будет убыло.
Вот это будет убыло.
Вот, но cast этот
статический.
А почему он статический? Что значит слово
static?
Что в compile-time понятно?
Что в compile-time понятно? Он успешный или нет?
То есть, статик-cast не генерирует
никаких процессорных инструкций, как мы уже
говорили, за исключением одного случая,
который скоро будет.
Но он не генерирует
процессорных инструкций в том смысле, что
компилятор просто говорит, окей,
теперь я считаю, этот тип derived.
И отношусь к нему так, генерирую инструкции
и ассамбленные в соответствии с тем, как будто
поля у него и все derived присутствуют.
То есть, никакой runtime-проверки
корректно это cast или нет, не
происходит.
Тем не менее, кое-какие
проверки все-таки происходят
в статик-cast. Например, какие
преднаследования?
Например, приватность.
Вот если у вас наследование
приватное, то статик-cast вам все равно выдаст
цель. Он скажет, вам запрещено
кастовать base-derived, потому что
это же приватное наследование.
То есть, статик-cast
не проверяет, действительно ли
является base-derived, но он и не может
это проверить никак в compile-time.
Но вот проверить, что наследование
приватное и что вообще, то есть, что они
действительно являются один наследником другого.
Например, если у вас есть какая-то иерархия в бок,
то есть там сложный граф наследования
и вы куда-то вот отсюда-сюда пытаетесь.
Статик-cast вам не скажет.
То есть, если у вас прямая только цепочка
от родителей к наследникам
и это все паблик по всей
цепочке, то статик-cast вам
скастует. А если там где-то по дороге
было private или protected, а вы не в друге
и не в члене и, короче, не там,
где полагается, то это
будет CE со словами нарушения прав
доступа, не скастует вам.
Так.
Окей, да?
Но есть еще reinterpret-cast.
Но reinterpret-cast, конечно же,
работает как обычно, он не смотрит
не проверять ничего.
Просто скастует вам в любом случае
что угодно, чему угодно.
Ну, то есть, даже если у вас
наследование приватное,
то вы можете reinterpret-cast-ом скастовать
значит, ссылки
да вообще на что угодно, не важно
приватное наследование, хоть вообще
нет наследования, reinterpret-cast-ом
можете скастовать. Но если на не отгадаете
там на самом деле был нет, то это же, конечно же,
убер.
Кстати, заметьте, что статик-cast здесь
к ссылке. Обычно мы статик-cast писали не
к ссылке, а к полноценному объекту
типу. А здесь я пишу статик-cast
к ссылке, как же так?
Но вот для наследования статик-cast к ссылкам
работает, к указателям тоже.
Вот. reinterpret-cast всегда
к ссылке в указатель. reinterpret-cast новых объектов
создавать не умеет, как мы уже говорили.
Но, если у меня определен конструктор
derived от base был друг,
то статик-cast и без ссылки
сработает. Вот так без ссылки... В обычной
ситуации статик-cast без ссылки не сработает,
потому что нужно начать создание, пожалуйста,
новый derived из base. А как его создать? Обе их знают.
Но если у derived определен
конструктор от base,
то статик-cast поймет, как создать derived от base
новый и создаст. И это будет тогда
правильно работать.
Сейчас, а у нас есть какой-нибудь способ нормально
в runtime проверять
является или вот конкретная
эта ссылка?
Пока нет, но скоро будет.
Пока нет.
Способ называется виртуальность.
Так.
Ну, слушайте, давайте, наверное...
Ну,
по приведению указать приведение
из ссылок я сказал, значит,
особенности приведения вверх и вниз,
значит, аналогия с конст, не конст,
значит, интерпрет-cast и статик-cast,
приватность членов наследования
и вот еще что.
В этом пункте
давайте я скажу вот щепку вещь.
Вот вы знаете,
есть такая аббревиатура
solit,
то есть
solit.
Кто слышал?
Значит, а кто помнит,
хорошо пробоваться.
Так, s это single responsibility.
Да.
Single responsibility,
open plus principle.
Да.
L это
leskov principle.
Блин, я сам забыл,
что последние две буквы значим.
Там что-то из одного.
Dependency injection,
по-моему.
А, это я забыл, что.
Interface segregation, точно.
Не важно, заберите, что это такое,
вам потом расскажут.
Я сейчас про это поговорю.
А что такое принцип подстановки лесков?
Значит,
вот есть такой принцип,
ну, вот, типа, это
хорошая аббревиатура,
обозначающая пять хороших
вещей, которые
следует соблюдать при объектно-оритированном
проектировании. И вот одна из них,
это лесков substitution principle.
Что говорит этот принцип?
Во всех контекстах,
где можно использовать
собственно базовую классу.
Ну да, то есть, по сути,
он говорит примерно следующее, что
должна быть подстановка работать
корректно, что всегда, когда вы
используете,
если где-то ожидается базовый класс,
то всегда туда можно отдать производные от него,
и ничего не сломается, его никогда не порушится.
Вот. И в связи с этим,
тут я хочу сказать,
рассказать об одной истории,
которая называется, проблема,
по-английски она называется circle ellipse problem.
Проблема круга и эллипса.
А по-русски, можно сказать,
проблема квадрата и прямоугольника.
Вот.
Возможно, вас когда-нибудь...
Есть несколько вопросов.
Ну, слушайте, многие вещи
переводятся не так, как хотелось бы.
Так вот, вопрос.
Вот вы реализуете иерархию
геометрических фигур.
Правильно ли сделать квадрат
наследником прямоугольника?
Да, проблема в том, что
первая проблема уже намечается
в том, что для хранения прямоугольника
нужно два числа, а для квадрата
у вас прямоугольника
нужно помнить больше параметров,
чем у квадрата.
Если вы квадрат делаете наследником
прямоугольника, то получается, что у вас
квадрат хранит все то, что прямоугольник,
то есть длины двух сторон, допустим,
и возможно еще что-то дополнительное.
Хотя на самом деле, квадрата нужно хранить
меньше, чем прямоугольник.
Но хуже даже не это.
Хуже то, что у прямоугольника
в принципе могут быть методы, которые
его модифицируют так, что
к примеру прямоугольника вполне может быть метод
скейл по горизонтали.
И если вы унаследуете квадрат
от прямоугольника в такой ситуации,
то квадрат перестанет
быть
квадратом,
если вдруг
кто-то от него такой метод вызовет.
То есть если вы случайно
вызовете, если вы начнете вызывать
методы родителя, которые
не подходят, так сказать,
под концепцию вашего наследника,
то у вас наследник потеряет
смысл свой, у вас квадрат перестанет быть квадратом.
Поэтому в этом заключается
circle ellipse problem, но там та же самая проблема,
только с кругом и эллипсом.
Казалось бы, круг разумно
сделать наследником эллипса.
Но вот не совсем, не всегда.
Если у вас у эллипса есть методы
растяжения по горизонтали,
и к тому же эллипс еще хранит 2 числа, круг 1,
это не очень хорошее
проектирование.
Ну вот мораль.
Мораль в том, что не всегда
то, что мы воспринимаем
как А является частным
случаем В в объектно-линейцированном
программировании стоит выражать наследованием.
То есть казалось бы
квадрат частного случая прямоголика, да.
Но всегда ли
подходит для наследования
это? Нет. Вот наследование
иногда приводит к неожиданным
побочным эффектам,
которые казалось бы вроде
с точки зрения здравого смысла,
вроде как одно частный случай
другого, но ввиду того,
как устроено все в программировании,
не всегда наследование
можно отразить эту мысль.
У вас будет задача
следующая геометрия.
Как я уже предупреждал там
в чате. Там нужно будет
реализовать иерархию геометрических фигур
и там вам все-таки нужно будет сделать
квадрат наследником прямогольника.
Вот.
Ну, имейте в виду,
что это плохо и так делать не надо,
но мы вас все равно наставим.
Почему тогда лучше не сделать
прямогольник наследником квадрата?
Просто квадрат сделает два числа и сыграет.
Ну, потому что
прямогольник это не частый случай квадрата.
Это уж совсем как-то ломает логику.
Но нам что так, что так придется
хранить два числа, если мы
квадрат сделаем наследником.
Ну, у меня нет правильного ответа на вопрос
как надо. Иногда можно,
да, косяк, но прямогольник делать в частном случае
квадрата уж точно не стоит.
Потому что у вас... Мы, наоборот,
его расширим. Мы наследуем все, что было
в квадрате и расширим
методами, которые используем только
прямогольника.
Ну, тогда если ты будешь по ссылке
на квадрат получать иногда
прямогольника, так вообще куда годится?
Ты же смотришь,
ты должен отдавать
наследника везде, где
ожидаешь родителя.
Поэтому вот.
Ну, а так мы тоже можем получить
прямогольники и методы. Ну, если у вас
неаккуратно прямогольники и методы плохие,
ну, то да. Ну, короче, проблема.
Это дилемма. Тут непонятно как правильно,
но вот просто имейте в виду,
что наследование не всегда
отражает буквально, что одно часть звучит в другом.
Чего ты так просить хотел?
А мы можем сделать так,
что у нас у нас стрелька будет, наверно, меньше метров
чем у главного, то есть
хранящаяся квадричность?
Вы можете
в приватной части наследника
написать юзинги публичных методов
родителя.
Тогда они привнесутся в областидимость
и станут приватными для внешних
пользователей.
Ну, в принципе,
можете.
Давайте сделаем
еще один перерыв.
Следующее,
о чем надо поговорить,
это замечательная тема,
которую вообще-то, может быть,
надо было бы и
на следующий раз отложить,
но уж ладно, раз у нас три пары, давайте.
Значит,
прекрасная
и божественная
особенность языка C++
это возможность
множественного наследования.
Multiple inheritance.
Это ситуация,
когда вы можете унаследоваться
от нескольких предков сразу.
Вот.
И вот сейчас
будет много веселых картиночек.
Очень веселых.
Я могу написать
в
объявлении класса,
что он наследник сразу двух.
Там напишу
класс сын, и вот он
паблик мазер,
паблик фазер, допустим.
Но я сейчас буду рисовать
стрелочки.
Там.
Ну и тут определение. Вот я просто
объявил наследование от двух классов
сразу. Я мог бы, конечно,
от кого-то из них приватно унаследоваться, от кого-то публично.
Вот.
Ну, много от кого-то защищенно.
Промножечное наследование
сразу возникает
много интересных
историй.
Вот, например,
что делать, если у меня
и в мазер есть поле х, и в фазер есть
поле х?
То когда я унаследовался
от сына и пишу с.х,
ой, унаследовался от них обоих, и пишу
с.х, это
неоднозначность.
Потому что непонятно, какой х
брать. Их там два, и оба одинаково
хороши, ну или одинаково
плохи. Если бы я в сыне
свой х объявил, то это было бы
предпочтительнее. Ну, из мазер пришел
х, из фазер пришел х, непонятно,
какой брать. То же самое,
если у меня функции
разные, там есть функции
от разных типов
с одинаковым названием, они
равноправно участвуют в перегрузке,
что от мазер, что от фазер. Если у меня
есть f от int, f от double,
вот на этот раз уже не будет
сокрытия, а будет
одинаково хорошо, и
среди них будет полноценная перегрузка. Но если
из мазер, из фазер пришли функции с одинаковыми
сигнатурами, одинаковыми именами, то будет опять
неоднозначность. Потому что непонятно,
какую вызвать. И вот чтобы
стало понятно, какую вызвать,
иногда приходится использовать квалифицированные
имена опять. То есть я могу писать
с.мазер2.2.х
и говорить, что я
беру
х из нее.
Вот.
Как устроено,
соответственно, в памяти это,
когда я объявляю множество наследований.
По порядку создаются эти предки.
То есть сначала создаются часть мазер,
потом часть фазер,
потом
сын. То есть вот надстройка
такая над ними.
То есть в сыне есть кусок мазер, кусок
фазер.
Вот.
Ну, с конструкторами, деструктурами все
также работает. То есть, когда мы создаем сына,
сначала нужно объяснить, как создать маму, потом
объяснить, как создать папу, потом проинициализировать
поля сына.
Как работает
приведение типов?
Если у меня есть
сын,
в нем есть,
ну он наследник двух родителей,
то
допустим, я хочу
сделать каст к маме.
Ну, вот я пишу
сын s,
потом говорю мазером персант
m равно s.
Все нормально работает.
Вот. Ну, соответственно,
у m я смогу вызывать поля и методы, которые
от мамы пришли. Да?
Ну, опять же, считаем, что
наследование публичное, все хорошо. Если
публичное, то дополнительные эффекты возникают.
А что происходит,
если я говорю father
ampersand f равно s?
Тут происходит интересная
вещь, потому что
ввиду того, как это в памяти размещается,
father-то начинается
не по тому же адресу, по которому начинается
сын.
И получается, что
вот эта ссылка,
которая на самом деле указатель,
она указывает не на ту часть.
То есть адрес
f не такой, как адрес s.
Я
инициализировал ссылку на отца с сыном
и получил объект с другим адресом,
нежели был у сына. Ну, потому что
папа-то вот тут начинается,
тут еще перед ним мама была. Если там
empty-base-optimization, то ладно.
Но если мама не пустая, то father будет
с другим адресом.
И забавнее, особенно всего,
это когда я пишу вот так. То есть если я напишу
father звездочка f
равно ampersand s,
то получится, что я
ну, сделал сдвиг указателя
неявный. То есть
адрес s был каким-то,
а когда я father звездочку
пронициализировал им, значение указателя
поменялось. То есть численное значение
вот этого указателя не такое, как этого.
Вот.
Ну ладно. А если
я хочу static-cast
делать, если я хочу, например, от
ну, в обратную сторону.
Да, ну понятно,
что я могу срезку также делать. От
сына к мазер, от сына к фазер. Я могу копию
делать. Ну, то есть
срезка по-прежнему работает. Я могу
передать, принять мазер
по значению и отдать сына. Создастся
копия части мазера. Я могу принять
фазер по значению и отдать сына.
Создастся копия части фазера.
А если я в обратную
сторону хочу касты делать? То есть
получается, вот если я хочу мазер
скастовать, ну, ссылку на
мазер мне дали, я хочу скастовать ее к ссылке
на сына. Ну, все также работает.
Если мазер публичный наследник, то просто
static-cast будет считать, что тут еще
правее фазер лежит, а потом
значит сын. А вот если
мне дали ссылку на фазер
и я сделаю static-cast
к сыну, то значит этот static-cast
приведет к тому, что указатель сдвинет
обратно.
Да, ну, то есть
мне дали ссылку, ну, или указатель на
отца и сказали static-cast к сыну.
Если наследование публичное,
то static-cast, поскольку он же
знает, как в памяти расположена вся эта хрень,
он понимает, что если мне дали фазер,
а просят из него сделать сына, значит
надо указатель сдвинуть обратно вот на столько
каков размер мазер. Таким образом,
после static-cast одного указателя
к другому, у вас изменяется чистое значение
указателя на вот размер мазер влево
или вправо, смотря в какую сторону вы
кастуете.
Вот.
И это такой интересный эффект.
То есть, когда вы static-cast делаете,
иногда у вас все-таки,
это вот то, что я говорил, иногда у вас static-cast
приводит к изменению численного значения указателя.
Например, при множественном наследовании.
Да.
Ну, потому что
он же знает, конечно, он знает, что такое sun
и знает, как он устроен.
Мы сделали static-cast
к sun-у
от просто фазер. По-настоящему
указателем на фазер не
стоит sun, а стоит
фазер. Он просто сдвинет указатель
на фазер. Он сдвинет, да-да, конечно,
но он будет считать, что и тут что-то есть
не фазера, относящийся к сыну, и влево от
него что-то есть. Вот.
А, как бы работал reinterpret-cast, кстати,
в этой ситуации?
Reinterpret-cast'у пофиг,
он ничего бы никуда не сдвигал. То есть, если я
сделаю reinterpret-cast фазер к сыну,
то я буду считать, что с этого места mother начинается
отныне.
Понимаете, да? То есть,
static-cast, он, во-первых, проверяет приватность
и можете ли вы кастовать в принципе.
Если можете, то сдвигает сюда.
А reinterpret-cast ему пофиг на приватность, он просто
считает, что с этого места начинается
теперь, ну, поскольку первая там mother, то
сначала, то отсюда будет начинаться mother,
по моему мнению.
Вот. Так вы можете интересное UB
получить.
Это ты в KFC, что ли, успел сбегать быстро,
или куда?
То есть, ты до Тимки добежал просто.
А вот зачем ты спрашивал, сколько времени перерыва?
Я успел даже десять минут.
Нормально, нормально, да, неплохо.
Только, жалко, да есть
не успел.
Мы же можем
в случае reinterpret-cast
сами на size of mother подвигать?
Пожалуйста.
Может...
Вы можете вообще типы не использовать,
вы можете только char звездочками оперировать,
если вам так удобно. Я в принципе
так может быть сразу легче,
что стесняться.
Ну void звездочки неудобно,
с ними арифметика не работает.
Char звездочки лучше всего.
Они ровно подряд
там нет никаких услуг. Не, ну как?
Тут могут быть какие-то пэддинги
из-за полей, но они подряд конечно подряд.
Ну да.
Кстати, хороший вопрос.
Кстати, это
хороший вопрос.
Да, это кстати хороший вопрос. Смотрите, вот
допустим у вас mother состоит из одного чара,
а father состоит из int.
Тогда mother подряд за mother
пришлось бы, ну они бы
просто чар за чаром лежали.
А father начинается с int, поэтому между mother
и father будет дополнительный еще пэддинг.
То есть это не обязательно size of mother.
Это size of mother плюс еще
возможно какой-то дополнительный пэддинг,
чтобы father нормально лег.
Да, так что
видите, тут все не так.
Потому что int нужно
класть по адресам кратным
4, я же говорил уже.
Вот.
К чему?
Статик кастом
нормально, неявно конечно
не кастуется.
Потому что я в предыдущем
пункте рассказывал, что каст вниз по иерархии
через статик каст разрешен, вот он.
Вверх
неявный каст вообще разрешен.
Не надо никакой статик каст писать.
Сын это частный случай отца.
От сына к отцу каст неявный.
И к указателе,
и к ссылке, и
и по значению можно.
Вот, но
самое интересное конечно возникает
вот когда. Это то, что
из вас тут уже кто-то говорил.
Самая веселая ситуация
это моя любимая ситуация.
По-английски называется
Diamond Problem. А по-русски
как это переводится?
Ромби. Правильно.
Как перевести Diamond? Конечно же
ROM.
Значит
Вообще-то
алмазная.
А?
Возможно.
Ну можно
бубновая проблема сказать еще.
Проблема
бубей.
Это как
знаете есть проблема борсука.
Правда называется борсука, но
можно называть проблем борсука.
Так вот.
Проблема вот
как бы ее не называть. Ну по-русски называется
проблема ромбовидного наследования.
Ромбовидное
наследование. Ну вы уже догадываетесь
наверное в чем проблема.
Ну у нас фаттер
манер от одного. Да теперь
сейчас у нас будет немножко
значит да сейчас у нас будет
вот эти самые смешные картинки которые я очень люблю.
Представь что у вас есть сын
который родителем
является мама.
А еще его родителем является папа.
А у мамы и папы есть
общий родитель.
Я могу говорить родитель
один, родитель два если кого-то это
смущает. Значит
так вот есть общий родитель у них
всех. Игру
престолов я не смотрел.
И что
вы думаете произойдет?
Значит
ну как
видите здесь возникла ромбовидное наследование.
Теперь вы знаете
как это называется правильно.
Значит
вот допустим у меня у Грэнни
есть поле х.
У
матор есть поле ну давайте
я их буду называть по
буквам. Значит у Грэнни есть поле г
у мамы есть поле м.
У папы есть поле ф.
И у
давайте я буду называть не фазер а дедди
по некоторым причинам.
Я буду говорить мам, дед ну типа ласково.
Ну просто ф мне еще понадобится для обозначения
функции. Я не хочу чтобы поле называлось
ф. Значит у папы есть поле д
и у сына есть поле с.
И вот я создаю сына и пишу
с.ж.
Что происходит?
Ну казалось бы
надо взять же из бабушки.
Но вопрос
из какой бабушки?
Их на самом деле
две.
Вот эта картинка
она неправильна.
То есть наследование называется
ромбовидным. Но на самом то
деле
когда вы пишете
если у вас матор это паблик Грэнни
фазер это паблик Грэнни
а сын это паблик матор паблик фазер
вы помните как
создается сын?
Я напоминаю
сначала когда мы создаем сына нужно
создать маму. Чтобы создать маму нужно создать бабушку.
Создали бабушку надстроили на ней
маму. Отлично создали маму. Теперь
создаем папу. Но чтобы создать
папу нужно ему свою собственную бабушку создать.
И он надстраивает
А как?
Какие конструкторы могут быть у них?
Вот когда папа
создается
они вот так кладутся в память.
То есть на самом деле при таком наследовании
у вас вот здесь внутри мамы
есть кусок являющийся бабушкой
и внутри папы
есть кусок являющийся бабушкой.
И только над это все надстраивается сын.
И то есть на самом деле у вас в этом
вот сайзов такого объекта
будет 20.
У вас будет 5 интов, а не 4 в нем
лежать, потому что этот будет продублирован.
У вас два раза бабушка.
Одна бабушка от мамы пришла, другая от папы.
И вот это будет неоднозначность.
Как устранить неоднозначность?
Ну, вы уже знаете как.
Можно писать s.mam
g. Это вы получите
g из бабушки. Из маминой бабушки.
Можно писать father
d. Вы получите
g из папы. Папиной бабушки.
Если напишите s.grenny
это вас не впасет, потому что
бабушек по-прежнему две.
Раньше у нас была проблема с тем, что
мы не можем назвать из сына бабушку,
потому что непонятно,
потому что доступа нет, а теперь мы из сына
не можем назвать бабушку, потому что
их две и непонятно какую.
То есть обращение к бабушке
неоднозначно.
Если бы в маме тоже лежала примерно g
то нужно было бы еще 2.2.grenny
Да, если бы в маме лежала
еще g, то написав
s.mam2.g мы бы получили g из мамы,
а чтобы получить g из маминой
бабушки нам бы пришлось писать
mam2.2.grenny2.2.g
Вот.
Ну ладно с ними с переменными.
Хуже вот что. Представьте,
что у вас вот здесь еще объявлен метод f.
Просто метод f.
Ничего особенного.
Как вы думаете
s.f
нормально сработает?
Нет, конечно.
Это тоже неоднозначно.
Из какой бабушки вызвать f?
Из первой или из второй?
Вопрос на
понимание.
А почему это неоднозначно?
Там же одинаковый метод f.
Это же один и тот же класс.
Правильно.
Потому что метод
самого метода один и тот же.
И этот метод он в свою очередь может
взаимодействовать с полями бабушки.
А тут уже важно с какой бабушки.
Если этот метод как-то модифицирует
поля, вот это поле g,
то важно из какой бабушки его вызвать.
Вы не можете вызвать метод f
не понимая из какой бабушки он взят.
Поэтому когда вы вызываете
метод вот так вот при таком наследовании
вам опять-таки нужно указывать
через кого вы вызываете? Через маму или через папу?
Вот это и называется
проблемой ромбовидного наследования.
У вас у наследован один и тот же класс
два раза через разных промежуточных родителей.
Люди очень часто
на экзамене
в ответ на вопрос
что такое diamond problem говорят
ну это когда у меня в маме есть x и в папе есть x
и вот неоднозначность между ними.
Нет, это не diamond problem.
Это обычная неоднозначность.
А diamond problem это когда у вас один x казалось бы
и один f и он в бабушке.
Но из-за того, что у вас
два раза она у наследована через промежуточных разных родителей
у вас получается
значит разное
у вас получается что он дублируется.
Представьте кстати теперь
что вот это наследование приватное.
Да, вот представьте что я написал следующее
вот эти все наследования публичные
и вот это публичное, а от папы к бабушке приватное.
Что теперь будет?
Правильно, ничего не поменяется.
По-прежнему будет неоднозначность.
Потому что приватность никак не влияет
на выбор версии, она влияет только на доступ
к нужной версии. Если вы напишите
s.mam2.f
вы получите то что нужно
если вы напишите sd2.f
вы получите ce
из-за ошибки доступа.
Да.
Видимость этого метода
по-прежнему есть. От того что оно
приватное, у вас не пропадает его
видимость, он вам виден, но не доступен.
Если у вас одна из версий
приватная, а другая публичная, это никак
не устраняет неоднозначность.
У вас все еще будет неоднозначность,
просто если вы уточните неправильно, то будет
ce по причине уже ошибки доступа.
Вот.
Ну, будет все еще неоднозначность.
Ну, просто она вся будет
еще с ошибкой доступа и в целом
не очень страшно. Ну, это вопрос в том, как
реализован компилятор, что он
какое сообщение об ошибке он выдаст, но по идее он
должен выдать сообщение о неоднозначности, а не
ошибка доступа, потому что
выбор версий до
проверки доступа происходит.
Я в плане, что если у нас вот эти
два приватных наследования, то в целом
нам уже не так страшно остановится,
потому что
ну, в смысле, что
неоднозначность появляется только
с точки зрения логики,
оно появляется только с теми методами, которые
мы и так не должны быть. Ну, да.
То есть, что оно
не совсем страшно, если
предок у нас следует
два раза. Ну,
нет, такое бывает.
Просто надо понимать, как это работает.
Вот.
Ладно, хорошо, смотрите, теперь такая ситуация.
Вот представьте, что я написал.
Не хочу писать
это на доске.
Представщик написал, что у меня есть
класс Грэнни,
есть класс Мам,
наследник Грэнни,
а есть класс Сын, наследник Мамы и еще
наследник Грэнни.
То есть, я два раза унаследовал бабушку,
один раз напрямую, а другой раз через маму.
Картинка будет выглядеть так.
Вот я унаследовал маму,
которая унаследовала бабушку,
а еще я унаследовал
бабушку напрямую.
Что в таком случае
будет происходить?
У нас будет две бабушки,
одна из которых
через маму,
а другая напрямую.
Вот.
Как вы думаете,
почему комитет по стандартизации
не запретил
к чертовой матери
вообще так писать?
Честно говоря, я не знаю.
Но так можно писать,
но при этом одна из бабушек
будет вам полностью недоступна,
кроме как через интерпреткаст СУБ.
Смотрите, какая ситуация.
Если у вас в бабушке сейчас есть какой-то поле
или какой-то метод,
то как его у сына вызвать?
Вы можете, написав
s.mam2.2chf,
вызвать версию через маму пришедшую,
но версию напрямую унаследованную
вы никак не можете вызвать.
s.mam2.2chf.
Grand это не однозначность.
И у вас нет способа
просто обратиться к полям этой бабушки
напрямую, не через маму.
Вот сказать, что вы обращаетесь к полю через маму
вы можете, а вот так вы просто
не можете никак сказать, что вы не обращаетесь.
Ну давайте посмотрим,
как это устроено.
Вот у меня сначала лежит бабушка,
потом над ней надстроена мама,
потом еще раз лежит бабушка,
а потом над всем этим надстроен сын.
Ну соответственно, зависит от размеров
всех этих штуковин,
вы понимаете,
как это в памяти расположено,
и вы таким образом можете скастить...
А, правильно,
это хороший вопрос.
Про статик каст при ромбовинном наследовании я ничего не говорил.
Ну, статик каст к маме
сработает корректно.
Просто он скастует вот к этой штуке.
А как работают касты при
множестве наследований?
То есть, если я возьму сына
и попробую написать вот в этой ситуации
грейни амперсант
g равно s,
то что произойдет?
А тоже будет
ce,
и ce будет
по причине
ambiguous cast,
неоднозначное приведение типов.
То есть, получается,
из бабушек, которые напрямую,
мы можем брать только переменные?
Ничего мы не можем из нее брать.
Почему переменные не можем?
Ну, напиши, как ты их возьмешь.
Ну, допустим,
в грейне жалово g, а...
s точка g.
Ну, если мы будем брать
только переменные,
то мы будем брать
неоднозначное приведение типов.
То есть, если мы будем брать
с точка g.
Какое g? Через маму или напрямую?
Ну да, плохо.
Тогда какой в этом смысл?
Никакого. Я не знаю, зачем
это так можно делать, но
так можно писать, но я вам просто объясняю,
что будет, если так написать.
Эта ситуация
называется inaccessible base class.
Когда вы унаследовали
предка,
к полям и методам которого
никак не можете достучаться.
Кроме как через reinterpret cast.
Это, короче, вот такая вот
проблема.
Так вот, если вы делаете
static cast от сына к бабушке,
что здесь, хоть неявный
cast, хоть static cast,
даже если вы вот так делаете,
хоть поинтеру, вы
получаете одну и ту же ошибку
ambiguous cast.
Ну, как это называется, ambiguous
господи.
Неоднозначный предок.
Ну нет, не ancestor он
пишет, какое-то другое слово.
Ambiguous parent, ambiguous base.
Вот, ambiguous base он говорит.
Неоднозначная база.
Неоднозначная база.
Ambiguous base, да.
Вот.
Ну, проверьте.
И здесь вы тоже не сможете скастывать
сына к бабушке напрямую.
Но вы можете
скастовать сначала к маме, потом к бабушке.
То есть вы сначала
заводите ссылку на маму
и говорите, мам
амперсант M равно S.
А потом гренни амперсант G равно M.
Вот так получается.
Это нормально работает.
Причем, если вы даже напишите static
cast к мам
2.2.grenni
амперсант, это все равно
будет неоднозначность.
Потому что название типа мам 2.2.grenni
это все же самое,
что и название типа просто
гренни. И кастовать к нему это все равно,
что кастовать просто гренни, а это неоднозначность.
Да.
Указатель на мам
через S.
Чего? Какой указатель на маму?
А нет, указатель
на гренни через S.
Где? Здесь?
Здесь.
Это ссылка на гренни.
Для вот этой картинки
мы написали красный код.
Я бы получил ссылку
на ту гренни, которая через маму.
Это если мы написали S.2.2.grenni
Чего? Я вот так
написал и получил ссылку на ту гренни,
которая через маму.
Можно ли было получить ссылку на гренни,
присвоив S.2.2.grenni?
Что?
Я не понимаю, что ты хочешь написать.
Выйди напиши, я не понимаю.
Вот здесь написав вместо M
S.2.2.grenni или нет?
S это объект,
у него нельзя брать 2.2.grenni,
можно только у типов брать 2.2.grenni.
Что такое
S.2.2.grenni берется
либо у namespace, либо у названия класса,
а S это объект, как у него 2.2.8grenni.
Что?
У нас есть допустим S,
который от мамы D,
и мамы D это не от гренни.
Если мы захотим сделать grenni равно S,
то это тоже объект.
У нас есть S, который от мамы D,
и мамы D это не от гренни.
Я хочу сделать
grenni равно S.
Мы есть элементы типа grenni.
Grenni G равно S?
Да.
Ну да, конечно, непонятно,
из какой гренни
создавать эту гренни?
Их же две там.
Ну, сделать S.mam
то можно.
Что такое mam это не поле,
нельзя через точку к нему обращаться.
Подожди, mam это
ну как, ты не можешь
написать не S.2.2.mam,
не S.mam, потому что
это не законченная
ну, это вообще бессмысленная фраза,
что S это не область видимости, чтобы
не и 2.2. делать.
А точка mam, это как будто
mam это поле какое-то, но mam это никого не поле,
это название внутреннего типа.
Нет,
ты можешь здесь написать static cast
к мамам персант, ну то есть
ты можешь написать grenni G
равно, а тут написать static cast
к мамам персант от S.
И так ты вот этот шаг
запрячешь в одно действие.
Так это сработает.
Потому что это приведет к тому,
что он ссылку на mam сделает,
ну и тем самым поймет, что однозначно
grenni уже.
А дальше он сделает неярные...
Ну, дальше он сконструирует
grenni из той части mam, которая
grenni.
Когда мы так делаем наши...
Как делаем?
Вот так.
Вот так.
Вот так делаем.
Да, вот так.
Руки оторвать надо вам, если вы так делаете.
У нас же F, которая у grenni,
она в более локальной области лежит,
разве нет? Чего, чего?
F, которая у grenni, она лежит в более локальной области.
У какой grenni?
У нашей, которая
ближе к нам.
Ну, которая через mam, она явно дальше...
Нет, нет.
У нас две grenni, они обе одинаково
хороши. Ну, как вам сказать?
Потому что так
решил комитет по стандартизации. Ничего не могу
вам сказать.
Слово grenni приводит к неоднозначности.
Если бы S точка grenni
было однозначным, то это означало бы, что у вас
и касс не работает. Ну, короче,
нет, это неоднозначность.
Наши поля более приоритетны, чем поля
наших родителей. Да, но
между родителями там уже нет разницы.
Вот.
Так.
Ну, да,
это неоднозначность.
И при приведении типов
неоднозначность.
Да.
И если
вы вниз кастите
от grenni к сыну,
это тоже неоднозначность.
Потому что непонятно, это вы кастите, как будто
вы были второй
или первой его бабушкой.
Но, конечно же, reinterpret cast
ему на всё наплевать. Вот
если мы reinterpret castом будем
кастить grenni к маме, он ничего не сдвигает
просто. То есть, grenni к сыну кастовать
не проблема. Просто будем считать, что вот отсюда
начинается сын. Или будем
считать, что вот отсюда начинается сын, просто залезем.
Тут будет мама, потом папа, потом сын.
Ну, короче, не проблема.
Вот.
Наследоваться несколько раз напрямую
от одного и того же класса нельзя. То есть, прям написать
public mother, ещё раз public mother, нельзя.
Но вот такими вот
хитрыми, хитросплетениями
можно, значит, создать
сложный граф наследования.
И ещё
static cast не умеет кастовать
ну вот
side cast так называемый. То есть
нельзя сделать каст от мамы
к папе static castом.
Он не
поймёт. Ну вот, можно кастовать static castом
только вниз и вверх по иерархии.
И то, если это однозначно, если там
всё публично. А от мамы к
папе нельзя сделать static cast.
Ну да, это поэтому
и нельзя, потому что, ну, это теоретически
непонятно как, через что. То есть
может быть, у них есть разные
общие пред, разные общие потомки
и через кого.
А если у нас есть стрелочка из мам в дед, то у нас
снова всё вот это плохо и мы можем пользоваться только
reinterpret, кастами. Стрелочка из мам в дед
это как?
В смысле, ещё вот так кто-то из кого-то
унаследовал?
Господи
Авраам родил Исаака, Исаак родил
Акова.
Ну,
что за вопрос был?
Мы можем пользоваться
только reinterpret, кастами.
Это очень плохо.
Я не знаю, чё.
Ну, короче, я всё сказал, вы всё поняли.
В общем, если, да.
Соответственно, ну да,
если наследование приватное, то я уже объяснял, это никак
не влияет, не однозначно сохраняется,
просто у вас ещё иногда доступ пропадает.
Что?
Из мам в дед нельзя кастовать static cast.
Да, что?
Нельзя просто, потому что это несовместимые типы
с точки зрения static cast. Ни один не является
предком другого.
Так.
Чё, есть ещё вопросы?
Если мы определим конструктор,
допустим, в деде от мамы,
то он, то сможем, да.
То static cast сработает. Да, сработает.
Только к объекту,
а не к ссылке и не к указателю.
Но если мы в деде определим
оператор каста к мамам персант,
то будет и static cast к ссылке работать.
Не забывайте,
что мы всегда можем определить в своих классах
явные касты к
любым указателям и ссылкам
и другим объектам. То есть,
мне ничто не мешает в
да, мне ничто не мешает в деде
папе определить оператор
к мамам персант, который
будет разрешать static cast
и кастовать дед к ссылке на мам.
Сейчас. Как? Что?
Как мы такое?
Как мы такое?
Там же нужно будет
возвращать эту ссылку.
Ну, что-нибудь вернем,
господи, проблемы что ли. Найдем, что вернуть.
Создадим статический дед и вернем
ссылку на него. Проблем-то.
Значит, статический дед?
Статический дед, статическую папу
создадим и вернем ссылку на него.
Он задастся в статический память?
Конечно, он же статический.
У нас никак не получится
циклическое наследование?
Циклическое наследование нельзя делать.
Если компилятор обнаруживает циклическое наследование,
это СЕ.
Ну, это понятно просто не может
ему никак не сконструировать.
Он замкнется в цикл, да.
А, то есть статически так можно
сделать, чтобы он
его нашел?
Ну да, вы forward declaration делаете,
class son, потом class mother public son, а потом
вроде можете, но
это не во...
в общем, СЕ, короче.
Это просто объявление?
Да, это объявление до определения.
Как объявить структуру? Просто написать...
Struct test. запятой.
Так, ну и последний пункт в этой теме,
который вообще-то мы
на предыдущей паре должны были.
Ну ладно, господи.
Так, значит, последний пункт, это самая замечательная вещь,
которая называется
virtual inheritance.
Знаете, есть такая песня virtual
insanity.
Вот у нас сейчас будет virtual inheritance.
Есть что-то общее?
Да.
Значит, виртуальное наследование.
Я специально не стер
вот эту картинку.
Потому что виртуальное наследование,
только, пожалуйста, не путайте его с виртуальными
функциями, они имеют мало общего.
Если кто-то из вас знает о том, что такое виртуальная функция,
вы молодец, но
это сейчас знаний вам не пригодится.
Потому что виртуальное наследование
это совсем про другое.
Не путайте их, пожалуйста.
Виртуальные функции – это совершенно другой механизм.
А у них есть кое-что общее,
но мало общего.
Виртуальное наследование – это следующая штука.
Это когда вы
объявляете
какого-то наследника
общим для всей иерархии.
И если он у вас повторяется, то он не дублируется.
Ну вот,
например, вот как раз в этой ситуации
я могу сделать Гренни виртуальным наследником
мамы и папы,
и тогда эта Гренни будет общая на всех.
Вот я буду
виртуальное наследование пунктиром рисовать.
Вот если я
сделаю виртуальную
Гренни,
как это пишется?
Я говорю
StructMum
и пишу
public virtual
public
virtual
Гренни.
Ну и то же самое
с папой.
А сыну я просто пишу
public mum, public dead.
Я эту бабушку
сделал виртуальной.
К чему это привело?
Это привело к тому, что эта бабушка теперь общая.
И теперь уже
это
не дублируется
поля в сыне.
Теперь если я напишу
s.g
или s.f из бабушки,
это работает.
Да, я сделал виртуальной
бабушку и здесь, и тут.
И теперь это уже
неоднозначность, то есть s.g
однозначный вызов, и s.f
однозначный вызов.
И статик каст от сына к бабушке
теперь однозначно работает.
Остается
только один вопрос. Как
это возможно? Что же происходит
на самом деле в этот момент?
Как компилятор реализовывает это?
Сначала все кардивальное, видимо,
а потом остальное.
Значит,
когда у нас есть виртуальное наследование,
компилятор объединяет все экземпляры
вот этого virtual класса
в один и кладет его
где-то отдельно. На самом деле,
если наследование виртуальное,
то в памяти выглядит это следующим образом.
Сначала лежит
мама, потом лежит
папа, потом
над ними надстроен сын, а справа
от них отдельно лежит бабушка.
А в маме бабушка уже не лежит.
А в маме бабушка уже не лежит.
Вот эта бабушка, она в самом
конце общая для них.
Если мы создали
объект мам,
то там сначала
бабушка тоже в конце будет лежать.
Да, ну я не знаю. Возможно, компилятор
это соптимизирует и не будет.
Но я вам рассказываю, как лежит
вот в такой ситуации.
Значит, не будет класть ее в конец, если можно
не класть. Зачем, если она все равно одна?
Зачем переусложнять, если можно не усложнять?
Ну вот если бабушка действительно
одна на двоих, то ее
компилятор, ну по крайней мере GSC
я тестировал, кладет в конец.
И как же тогда конструктор работает?
Тут есть проблема
и посерьезней.
Как
вообще
мама узнает, где
ее бабушка?
Вот представьте, что вы реализовываете
какой-то метод мамы. Этот метод обращается
к полям бабушки, которые ее предок.
А как мама
понимает, где эти поля памяти
относительно нее самой?
Что?
Если мы в маме, мы вообще не знаем, что от нас
кто-то унаследовался. У нас от мамы
может быть очень много других наследников, может
быть первый папа, другой
еще кто-то у мамы был. И они
все, значит, породили
разных сыновей. И вот эта бабушка,
она для них для всех, ну
у них там разные иерархии. И в одном случае
бабушка от мамы вот на таком расстоянии,
и в другом случае бабушка от мамы на другом расстоянии.
Как мама в своем методе
понимает сейчас бабушка моя
на каком от меня расстоянии, чтобы
туда поля модифицировать?
Это значит, что маме нужно хранить
на самом деле дополнительный указатель
на то, где лежит ее
бабушка сейчас, если бабушка виртуальная.
Откуда мама знает
как далеко бабушка лежит от нее?
Бабушка
общая для мамы и для папы.
Вот представьте, что у меня есть вот это,
а еще кроме этого есть
Д2, а еще
я не знаю, медведь
и они все тоже
виртуально.
Ну я не знаю.
Ну представьте, что еще есть дочка,
у которой еще есть
другие родители,
и вот она тоже унаследована
от этой мамы,
а все они унаследованы
от вот этой бабушки виртуальной.
Ну давайте, не знаю,
здесь будет не папа, а какой-нибудь, не знаю,
волк. Ну вот, смотрите.
Ну смотрите,
вот представьте, что у меня есть
вот такая иерархия
и одновременно с ней существует такая иерархия,
ведь ничто же не мешает.
Тогда вот в этой ситуации
мама будет лежать за ней папа, потом
сын, а тут будет сначала
мама, потом значит волк,
потом медведь,
потом дочь,
а бабушка уже потом
после этого всего добра.
И в методах мамы я вообще
говоря не могу знать
насколько далеко от меня бабушка лежит,
моя виртуальная.
Поэтому маме необходимо в себе хранить
дополнительно поинтер
на то, где лежит ее бабушка сейчас.
Если у меня есть
виртуальный родитель, то мне необходимо
помнить, где он от меня,
насколько далеко сдвинут в данной конкретной ситуации.
Потому что могут быть разные
иерархии, в которых я участвую вместе с этой
бабушкой, и в каждой из этих иерархий
бабушка будет у меня на разном расстоянии.
Поэтому виртуальное наследование
приводит к тому, что у мамы
и у папы хранятся дополнительно
по 8 байт-поинтеры,
указывающие на
бабушку, где бабушка.
А?
Да, то есть теперь мама выглядит так.
В ней лежит
поинтер,
то есть в маме лежит поинтер,
потом лежат обычные
поля мамы, потом
опять лежит поинтер,
потом лежат обычные поля
папы, потом лежит
сын.
А потом лежит бабушка,
и вот на эту бабушку указывает поинтер.
Какую цепочку?
Какую цепочку?
Справа.
Значит, одна
бабушка общая. Вот для
всякого виртуального предка вам нужно хранить указатель
на это виртуального предка, где он относительно
вас, а обычно он в самом конце лежит.
И вот этот виртуальный предок
будет общий для всех тех, у кого
он помещен как виртуальный. Что ты хотел
сказать?
Почему мы для S не храним указатель
на G? Почему мы для S не храним
указатель на G?
Потому что S начинается
с мамы, а у мамы и так есть
указатель.
Про S и так понятно,
что для S не надо хранить дополнительный
указатель, потому что
у сына, где лежит бабушка, и так
можно понять, зная, что у сына есть сначала мама,
папа, а они-то знают, где их бабушка.
А ты что хотел спросить?
Генерируем
и она у нас лежит в конце.
Ну это не документировано стандартом,
где она лежит. Компиляторы так реализуют,
насколько я знаю, я проверял.
У нас сейчас сын, мама
и мы создали бабушку. Она лежит
после сына в памяти. То есть
когда мы придем к отцу и от него построим бахов.
И от него что-то построим.
Когда у нас бабушки
на память должны как-то сдвинуться.
То есть мы еще тратим время на то, чтобы сдвинуть
бабушку.
Так, подождите, давайте по порядку.
Я не понял проблему.
Какая проблема?
Мы ничего не знаем.
Райков.
Райков.
Райков.
Райков.
Райков.
Райков.
Райков.
Райков.
Райков.
Райков.
Мы ничего не знаем о Райкове отца.
Мы запустили через маму.
Мы создали бабушку.
Положили бабушку после сына.
Да.
Мама, отец, сын, бабушка.
А потом мы еще от отца запустились
и там он все как обычно создавал.
А, то есть ты хочешь сказать, что здесь
могло быть что-то еще,
что-то раздутое, да?
Мы раздули и подвинули бабушку.
И мы двигаем бабушку.
То есть мы играли время на взрыве на 3 бабушки.
Нет, смотри.
Когда ты создаешь сына,
ты ж заранее знаешь,
какой размер будет у всех его предков.
Если ты создаешь сына,
то прежде, чем создавать сына,
ты рассчитываешь, сколько суммарно
места потребуется, чтобы всех положить.
И поэтому ты бабушку сразу кладешь, куда надо.
Чего, чего, чего?
Потому что в разных
иерархиях бабушка может лежать
на разных расстояниях.
Когда ты создаешь конкретную иерархию,
ты этот поинтер инициализируешь,
понимая, что ты сейчас сына создаешь,
а не какого-то еще зверушку, у которой
бабушка будет дальше лежать.
В методах мамы, вот когда методы мамы
реализуются, в них ты обращаешься
к полям бабушки.
А эти поля где относительно тебя?
Это зависит от того, твоя мама
сейчас является родителем кого.
Если ты в методе мамы,
которая там дочка,
сыночек, волченок,
то у тебя эти поля
они на таком расстоянии от тебя.
А если ты вот в этой маме, которая является
частью сына, то эти поля на другом расстоянии
от тебя. И в маме ты не можешь
заранее знать, эти поля будут на каком
расстоянии от тебя. Это зависит от того, кто от тебя еще унаследовался.
А раньше у тебя бабушка была
всегда внутри мамы, и ты знал, что это она
единственная.
Твоя.
Почему мама не может посмотреть
на дочь
и просто сказать...
Подожди, что значит посмотреть на дочь?
Мама ничего не знает о дочери.
Дочь и наследник мамы, а мама
сама по себе о дочери ничего не знает.
Ты реализуешь класс мамы, от него может
унаследоваться кто угодно. Может там не дочь?
Я специально писал дочь, потому что
ты меня спросил, почему мама на сына не может посмотреть.
Потому что может у нее не сын, а дочь на самом деле.
Потому что там еще какой-нибудь зверь.
И как мама может заранее знать, кто от нее унаследуется.
Чтобы обратиться к маме, мы должны
обратиться к дочери.
Где? Когда?
У нас дочь, мама.
Если у нас есть переменная Dota,
у нас есть объект класса Dota.
Чтобы обратиться к маме, мы должны обратиться
к самому нашему объекту.
Ну D.m, да.
Это какой-то поле мамы.
И отсюда уже мама будет знать, где лежит бабушка.
Да не будет мама знать, где лежит бабушка.
Вот ты реализовываешь класс мам.
И в нем есть
поле X, и оно
наследник бабушки. И вот из бабушки
ты унаследовал поле X.
И вот ты говоришь, вывести
X. Где
этот X? Во что должен я транслировать
этот код в Assembler? Какой?
X откуда взять мне? Вот этот X
откуда взять? Я сейчас реализую метод мамы.
Я ничего не знаю, кто от меня еще унаследуется.
Вот код метода F,
что я себя должен представлять?
Вот в инструкциях машинных, что он
себя должен представлять? Откуда я знаю этот
X, где относительно меня находится?
Вот
он из бабушки, но где бабушка
я же не понимаю, потому что это зависит от того,
часть какой иерархии я сейчас.
Поэтому мне приходится
вот это транслировать в то, что я
иду на pointer, вот этот,
прыгаю туда, и оттуда беру X.
Так, ну есть еще одна проблема,
да тут много проблем в принципе.
А как кстати
каст теперь работает?
Ну хорошо, вот если я делаю
каст сына, сына к отцу,
как это работает?
Ну нормально работает,
потому что от сына я знаю, где отец
относительно сына. И если я
делаю каст сына к маме, я тоже знаю,
где мама относительно сына.
А если делаю каст сына к бабушке, это как
работает? Ну тоже нормально, я знаю
относительно сына, где бабушка, а вниз
как это работать будет?
Вот как
будет ли работать и как, например,
каст от мамы к сыну?
Ну в принципе мы знаем, что
у нас есть сын в итоге, соответственно
понятно, как
если мы знаем, мы кастуемся к сыну, мы знаем,
что между мамой и сыном есть
еще отец. А вдруг
от сына кто-то еще унаследовался?
И тут дополнительно
достроено что-то еще, и бабушка
на самом деле...
А вот у нас указатель есть, мы знаем,
где именно.
Сейчас, нет, ну от мамы к сыну кажется
однозначно, потому что даже если там
что-то еще достроено, то оно все после сына
будет лежать. Да, да, да.
От папы к сыну аналогично.
А от бабушки к сыну как это будет работать?
И будет ли?
А почему не будет?
От бабушки к сыну в идее у нас может быть
просто по-разному унаследованы и
может не существовать.
У нас же виртуально.
У нас бабушка не знает,
где лежит начало сына.
Да, вот как быть?
Стоп, у бабушки
что-то перед бабушкой может лежать
что-то еще. Поэтому фиг знает,
где конкретно эта бабушка лежит.
То есть у нас сын может...
Стоп, почему... Вот как
работает каст от бабушки к сыну?
Еще и от дедушки.
Еще и от дедушки.
Нужен динамик каст?
Нет, никакой динамик каст не надо.
Динамик каст вообще не об этом
не приплетать его сюда.
Вот давайте посмотрим, как это
работает. Я просто
уже сам не уверен.
Хочу это затестировать.
Чего?
Ничего у нас не вызывается.
У нас ссылки кастуются.
Какой конструктор?
Ну, оно просто...
А этого мало?
Это, по-моему,
очень много уже.
Это превращает это иерархию вот в это.
Что?
Ссылка кастуется. Вы просто маму считаете
сыном. Все.
Так же.
Нет, от папы к сыну вы сдвигаете ссылку.
На начало сына.
Стоп, то есть мы до этого знали, что это у нас сын,
то ссылка указывается на папу,
который лежит в сыне.
Да.
Сейчас.
Вот вы кастуете от папы к сыну.
Да, давайте подумаем,
как это происходит.
Знает ли он, куда сдвинуть
ссылку?
Да, потому что у нас
внутри всего этого
блока ничего лишнего
не лежит. Там лежит только
сын, его предки, которые не виртуальные,
а которые... Да, если
ну, мы знаем, что у
сына родители это только мама и папа,
у них есть виртуальная бабушка, которая не важно, где.
Да, указатель у нас есть на нее.
А мама и папа, после них
гарантированно лежит сын. Да.
Поэтому от папы к сыну скастывать мы можем
просто сдвинув влево на размер мамы.
Да. С учетом виртуального
поинтера.
Влево. Потому что от папы
правее сына начинается. Сын начинается
с мамы.
Так. Хорошо.
Вот давайте сейчас посмотрим.
Вот у меня есть структура
Грэнни,
и в ней я заведу, значит, Ж.
После этого я заведу структуру...
А выключите свет там
снова. Структуру мам,
ну, матор,
и напишу, что это
virtual
public
Грэнни. Блин.
Public Грэнни.
И тут заведу поле М.
Вот.
А еще заведу структуру
father
и напишу,
что это тоже virtual,
public,
Грэнни, и тут заведу
поле F.
И наконец заведу сына,
который
будет просто...
Да.
Да.
Вот. И тут будет поле S.
Вот теперь у меня вопрос. Какой будет размер
всего этого добра?
Бобра.
Вот. Для начала, какой будет
размер? И давайте попробуем понять,
из чего это все
состоит. Size of S.
А что такое
S?
А, я не создал... Ну,
size of... Хорошо, давайте я сделаю сына
sunS
и сделаю size of S.
Вот.
Значит,
g++
virtual inheritance.
40.
И давайте силенгом для надежности
скомпилируем.
40 тоже.
Значит, давайте поймем, из чего
состоит все это добро.
Сколько занимает бабушка?
Бабушка лежит в конце, да?
У нас мама занимает
pointer и poly int.
То есть мама занимает... И нужно
padding до папы. 16.
Еще
16 занимает
сын.
Еще 16
занимает папа.
Это уже 32.
Вот. А после папы
лежит сразу сын. Там никакого
pointer не лежит.
Ну, ни с чего. После папы лежит
сын. После папы нужно класть сразу int.
Поэтому padding не нужен. Поэтому после
папы мы можем сразу класть
int, который S.
А следующим за ним сразу
класть int g из бабушки.
Видимо, pointer лежит после
всех poly...
Да почему? Нет, подождите. Вот, смотри.
Если у нас лежит сначала pointer,
потом poly int,
тогда у нас получится 16 на mother.
Ну.
А дальше у нас получится
12
в father и
padding дальше не нужен, потому что еще int
кладется нормально.
А, вы имеете в виду, что
padding... Все, я понял. Вы имеете в виду, зачем
padding папе? Да. А padding папе
мне кажется для того...
Ну, мне кажется, он не умеет сжимать. Ну, давайте
проверим. Мне кажется, он не умеет сжимать просто...
Короче, сейчас мы просто проверим.
Я просто сейчас выведу все
адреса, и мы увидим, как это лежит.
Вот, я сейчас спрошу, где лежит M,
где лежит F.
И где лежит
S.
И где лежит G.
Нет, сначала давай скомпилируем нормально.
Вот.
Компилируем.
Смотрим.
68, 70, 80,
84, 88.
Сначала адрес
S.
68.
То есть объект начинается с адреса 68.
Да?
Поле M лежит
по адресу 70. То есть
через 8 байт, поскольку у нас 16-ричное.
То есть первые 8 байт
от начала объекта до M чем-то заняты.
Чем? Ну, поинтером как раз и заняты.
Дальше F.
А F где лежит? 80.
F лежит через 32 вообще.
То есть у нас M,
после него
4 байта padding,
потом поинтер
через 16.
И потом только F. То есть у нас пропущено 8
и еще 8.
То есть все сходится.
У нас лежит сначала...
Это соответствует рисунку, которую я нарисовал.
У нас сначала лежит
поинтер
8 байт,
поинтер,
потом лежит M,
потом 4 байта padding,
потом лежит поинтер
чем-то заняты 8 байт,
потом лежит F.
Что дальше?
Дальше 84
у нас там лежит S.
Да? S и G.
То есть M лежит по адресу 70
плюс 8,
плюс 8. Тут лежит F.
Сразу после F притык лежит
S
и 88 лежит G.
Все сходится.
Здесь действительно нет padding.
А почему тогда размер
40?
А потому что здесь еще padding 4,
чтобы положить следующего
сына после этого.
Вот так устроен
объект при виртуальном наследовании.
Потому что следом
за матор нужно положить поинтер.
Отцовский.
А ему нужно кратность 8 байта.
Потому что после
всего этого объекта нужен padding,
чтобы следующий объект снова положить с адреса кратно 8,
чтобы подряд массивы класть можно было.
Вот начало мамы.
Вот начало папы.
Где папа? Вот же.
А где моя мама?
Так вот же она.
Потому что папа
начинается с поинтера.
Для этого нужно кратность 8 байта.
Понятно, как устроен объект при виртуальном
наследовании?
А как касты все-таки работают?
Ну окей.
От сына к папе,
от папы к сыну.
Потому что там без него можно обойтись.
Ну действительно.
Там же и лежит инт сразу.
Вот смотрите.
Ну вот если я кастую
статик каст, отец гре..
Ну вообще понятно.
Вверх не интересно.
От сына что к маме, что к папе, понятно как каст работает.
Вот как работает каст от
ну давайте я заведу
гренне
же.
И как я значит от
гренне например скастую
к сыну.
Да хоть к маме.
От гренне к маме.
Я могу как-нибудь скастовать?
А от сына я написал,
а не от бабушки.
Вот могу ли я бабушку скастовать
к маме?
Нет.
И это логично.
Потому что, а как?
Если это не виртуальное наследование,
то как вообще статик каст может
догадываться где лежит мама относительно
этой бабушки? Да никак не может.
Правильно? То есть при виртуальном
наследовании статик кастом
вниз кастовать я не могу.
Ну так же и к сыну я не смогу скастовать.
Потому что
бабушке, относительно бабушки
совершенно непонятно куда
сдвиг делать.
Значит cannot cast
granny to son via virtual base
гренне. Не получается
из-за того что виртуальное наследование не получается
ничего скастовать.
Если бы наследование было не виртуально,
то мы могли бы так скастать?
А если бы не виртуально, то конечно смогли бы.
И это бы не сделало
никакого... Ну просто мы бы считали, что
да, сын лежит.
Отца к сыну?
Да, должны.
Сейчас.
А может и нет. Давайте поймем.
Ну давайте поймем. Вот если у меня есть father f,
давайте подумаем, можем
или нет.
Ну,
кажется это теоретически реализуемо,
а работает ли? Ну да, работает.
Собственно, да. Папу к сыну можем.
И маму к сыну можем,
ну а бабушку не можем, потому что бабушку ни к чему
не может, потому что непонятно где ее потомки
относительно ее сына.
Ну, получается так, да.
Почему это UB?
Сейчас это UB, потому что у нас
под father настоящий сын, да.
Не father, а сын.
Ну и адреса полученного,
вот если я возьму адрес этого,
как я уже говорил, адрес этого и адрес исходного f
будут разными, потому что сдвиг произошел.
По сути, статик к
сыну от папы сдвинул влево его
на размер мамы. Да.
Я понимаю, что указатель, который
лежит у мамы, он получает
значение вот в момент
определения конкретного сына.
Ну, то есть... Не сын,
конкретного потомка.
То есть в зависимости от
того, кого именно мы сейчас создаем,
указатель разными числами инициализируется.
Потому что я нарисовал
пример, у тебя может быть мама, от нее
еще там пять зверушек, и вот тогда
бабушка будет дальше лежать, поэтому вот
этот указатель нужно...
Вот.
А, кстати,
а вот что
вы думаете сейчас мне выведется,
если я вот это спрошу?
Estadese Out
Сын начинает с указателя, да?
А давайте
просто спросим, что это за указатель?
Ну,
сын, он же с указателя
начинается? А давайте
и узнаем, что там за указатель-то такой.
Указатель на что?
Почему это не скомпилируется?
А, ну мне надо
сейчас. Мне надо не так
сделать, мне нужно сделать...
Сейчас, подождите, что мне надо сделать?
Вот так скомпилируется.
Ну, потому что
к указателю
это к R-value, я только указатель
не могу кастовать к указателям,
а тут я сказал
Re-Interpreter-Cast
считай, что
тип S это ссылка
на указатель, ну то есть
теперь воспринимай S, как будто это
был указатель на int, вот его мне и выведи,
давайте попробуем.
Это что-то очень странное.
Да, это что-то очень странное.
Куда же ведет этот указатель?
Мы что-то очень странное написали
в принципе.
А как мы объект
кастим указатель?
Re-Interpreter-Cast.
А что это вообще происходит?
Давайте мы на всякий случай убьем
кусок, который у S
не работает.
Каст.
Сейчас, ну я сказал ему,
считай, что S это на самом деле был указатель на int
и вот ссылку на этот указатель мне скастуй
к нему. Ну хорошо, ну давайте
я не знаю.
Ну давайте, я не знаю, сначала
считать его, ну я не знаю, как это.
Да, я беру биты S
и говорю, считай, что это биты,
которые означающие указатель на int.
И вот его мне и выведи. То есть я первые 8
байт S таким
образом вывел. Ну это какое-то странное
число, оно не похоже на указатель,
не похоже на адрес чего-то из этого.
А?
Нет, указатель на int
я же вывел, а не сам int.
Да потому что я, ну блин,
ну подумайте, ну потому что я
взял S и сказал, считай, что S
это указатель на int. Его и выведи
мне.
Указатель на ссылку вообще не бывает.
Я сказал, считай, что S это указатель на int. Окей.
Если б я хотел считать, что
int это double, S это double, я бы что сделал?
Я бы вот так написал, правильно?
Не создает новых объектов.
Мы кастим к ссылке. Я говорю
сейчас, считай, что S это double и выведем мне значение
этого double. Вот сейчас выведется
мне некий double.
Первые 8 байт S
прочитанные как double. Теперь я сказал,
прочитай первые 8 байт S как
указатель на int.
И выведи мне их. Вот я их вывел.
Это загадка, почему же там такие странные,
почему там такой странный указатель?
А давайте тогда вот что сделаем.
А давайте разберем другой пример.
Допустим,
у меня
два виртуальных родителя.
Вот смотрите, у меня пусть бабушка
теперь будет не виртуальной,
зато мама и папа
виртуальные.
Что тогда будет?
Ну, вопрос, сколько
это в памяти будет занимать и что будет где
лежать?
Так, давайте
поймем, как это будет лежать.
Ну, давайте сначала пофантазируем, а потом
попробуем
скомпилировать. Во-первых, это C и E,
потому что неоднозначность обращения к G.
Потому что теперь опять две бабушки.
Но сейчас
я это исправлю. А давайте
пофантазируем, как это в памяти должно лежать
теперь.
Сначала
Ну, у нас есть
сын.
Сын, он начинается с бабушки.
Ну, он начинается с мамы, а мама виртуальная.
Значит
сын начинается с указателя на
маму,
после чего лежит указатель на папу,
после чего лежит
S
и вот сын.
После этого лежит бабушка,
а потом мама,
а после этого лежит другая бабушка,
а потом папа. Вот так
быть устроено какой размер у этого всего должен быть значит 8 плюс 8 16 плюс плюс да то есть вот
это 24 да вот это 24 должно быть а тут должен быть паддинг тут не должно быть паддинга да потому
что дальше сплошные инты то есть на самом деле 8 и 8 16 20 ну 16 и 5 интов 30 ну на самом деле еще
4 чтобы следующий положить да ну что страшное я не понял 16 и 5 интов то есть 36 и еще 4 паддинг
чтобы следующего сына положить должно быть 40 давайте проверим правда ли это я только сначала
закомментирую вот это давайте посмотрим нет 32 как же так вышло казалось бы должно быть 40 байт
ну уж как минимум 36 даже если этот паддинг не считать а оказалось 42 как же так получилось
32 почему на 8 байт меньше чем мы насчитали потому что на самом деле два указателя подряд хранить
не эффективно он этого не делает этот указатель указывает не напрямую на бабушку на предках а он
указывает на некоторое место в памяти где лежит список других указателей
на самом деле этот указатель он не на значит не сюда этот указатель он кое-куда вовне а вот
там уже лежит настоящий указатель и сделано это как раз для того чтобы есть у вас много виртуальных
предков этот указатель вы бы не хранили весь этот огромный массив указателей у себя вы хранили
бы указатель на так называемую сейчас я скажу вот это страшное слово виртуальную таблицу в которой
хранятся все нужные вам указатели куда ходить если что поэтому и адрес у нее такой странный он
это вообще указатель на статическую память на самом деле она в статической памяти хранится
потому что это некоторая информация относительно работы всей программы только правда не очень
понятно как там хранить указатели на конкретные объекты ведь если она статическая вот да там
хранятся сдвиги на самом деле они указатели то есть на самом деле вам надо знать не указатель
же а сдвиг ну вот по сути они там скорее всего хранятся скорее всего я уже тут не берусь
говорить как это точно устроено то есть на самом деле с двумя виртуальными предками объект выглядит
не так в нем сначала указатель потом значит сын потом с вот это 8 байт потом с потом g от мамы
потом м потом g от папы потом f 8 16 24 28 и 4 байта пэдинг чтобы уместился следующий сын нормально
вот ну можно затестировать ну в принципе можно можно проверить что так оно и есть скорее всего
то есть я могу сейчас только убрать вот эту неоднозначность с g там s точка мам 2.2. же допустим я
попрошу ну и в принципе можно мазер да вот и на самом деле я могу знаете что попробовать еще
сделать я могу попробовать вот что сделать сейчас я попробую вот так сделать у меня
у меня сын начинается с поинтера да давайте я попробую вот так сделать нет секвел я не
схватил ну и просто я это ну она просто константная по идее должна быть то есть
если бы я ну а нет минуточку не так я должен сделать не это я должен вот эту штуку интерпретировать
как указатель а потом разыминовать и вот ему то присвоить уже единицу вот давайте так попробуем
вот я доказал вам что мы на самом деле в статическую память ведем этот указатель ведет
ну не хорошо не в статическую то есть он ведет куда-то где на самом деле мы не можем менять по
этому адресу ну то есть там может быть на самом я вам не доказал что это прямо обязательно
статическая память может это просто вообще не указатель был но скорее всего это просто указатель
который ведет в какую-то область память кормить нельзя вот там хранится дани указатель но да вот
но можно проверить что тут вывелось ну давайте уж не будем вот ну и давайте последний пример
про последний пример который я вам покажу сегодня блин виртуальные функции мы уж не начнем сегодня
жалко ну ладно значит последний пример это когда у вас один и тот же класс унаследован и виртуально и
не виртуально точку да там сначала выводится 32 а дальше адреса без пробела вот представьте
теперь что я сделал следующее я сделал опять ту же самую старую иерархию как была с мамой папой
и бабушкой но на этот раз я виртуал написал только в одном месте я сделал вот эту бабушку вот вот
здесь я написал виртуал а тут я не написал виртуал ой я вас обманул это еще не последний пример будет
потом последний но я говорил что под задержу вас ничего страшного зато вы сегодня спали долго вот
так если я сделал что тогда будет как это будет выглядеть ну то есть я один раз виртуал написала
второй нет что будет тогда будет две бабушки одна виртуальная другая нет начинаем сначала указатель
после чего мама после чего папа но папа начинается с бабушки вот это папа после чего сын после чего
мамина бабушка то есть выглядит теперь это будет так чего чего чего нет что мамин указатель
указывает ну куда полагается это вот указывает в итоге сюда да то есть теперь мы опять имеем
неоднозначность то есть если вы делаете виртуал какой-то класс то его надо везде делать все
виртуал экземпляры схлопываются в один он кладется в конец а не виртуал они дублируются то есть
если у вас один раз виртуал много раз виртуал бабушка еще сколько-то раз не виртуал то все
не виртуал будут копиями друг друга и одна будет виртуал общая которая виртуал борется с
неоднозначностью вот это не очень ну в смысле так можно писать но это довольно плохо потому что
у вас ну вы можете конечно так сделать но это будет означать что у вас значит часть что у
вас проблема не побеждена виртуально у нас следует ну короче это просто чтобы понимали как это
вот напоследок я хочу вот что сделать вот теперь уж точно напоследок конечно не
однозначность будет конечно их же две вот напоследок я хочу вам показать вот что тут я уже
просто не в состоянии значит рисовать на доске уже я просто покажу вам картинки нарисованные за
меня вот в этом замечательном документе который он активно рекламировал есть замечательная глава
про наследование
тут есть похожие картиночки
где описано как работают множественно на следовании и виртуальные наследование вот
это значит картиночка при не виртуальном наследовании вот эта картиночка при виртуальном
наследовании да вот здесь нарисована собственно ну тут есть значит понятно что разобран
случай когда можно то что я сказал можно сделать и виртуального и невіртуального предка тогда
Да, все виртуальные вхождения B в класс Lattice, какое классиво название, решетки классов соответствуют одному подобъекту, а остальные, значит, дублируются.
Но больше всего мне нравится вот это. Тут есть прекрасный пример, как работает поиск имен в случае, когда у вас есть и виртуальные, и не виртуальные предки.
То есть представьте, что вы унаследовали бабушку виртуально, а другую не виртуально, и начали делать всякие вот эти вот вызовы.
Вот смотрите, когда у нас присутствует виртуальный класс, скрытое объявление может быть достигнуто через путь, через решетку подобъектов, которое не проходит через скрывающее объявление.
Что-то написано. Это не неоднозначность. А то же самое с невиртуальными это неоднозначность. Ну да, это соответственно то, ради чего виртуальность придумана.
Вот у меня есть структура V, в ней есть метод F и X, структура W, в ней есть G и Y, и вот я делаю виртуального предка V и не виртуального W.
Вот. И структура C делает виртуального предка V и не виртуального W. И вот так это выглядит.
И соответственно, если я теперь из D вызываю какие-то имена, которые были в V, то я вот по этому пути прохожу и неоднозначности не возникает.
То есть если я попадаю, если я по вот этой вот решетке, по вот этой вот, как она называется, lattice, прихожу в виртуального предка, только в виртуального, по этим названиям.
То есть все эти названия, они из одного и того же виртуального предка ведут меня в одно и то же место, то это не неоднозначность.
Но если у меня возникает неоднозначность, вот у меня еще в структуре B объявлена F, которая скрывает вот это F.
И G, у меня в структуре B, смотрите, у меня в структуре B объявлена F и G и X и Y. То есть оно скрывает все, что есть в этих двух классах.
Вот, и если я из D обращаюсь к X, то я получаю X вот отсюда. Если я из D обращаюсь к F, то я опять получаю F вот отсюда, из B.
А если я обращаюсь к Y, то у меня неоднозначность взять его отсюда, либо отсюда, либо отсюда.
Короче, то, что в B объявлено, оно скрывает виртуальные штуки за собой, но не скрывает вот эти.
Вот если я в B наобъявлял то, что конфликтует с виртуальным объявлением, вот у меня в B было F и X.
И в B я объявил F и X. И вот если я из D пишу F и X, то B прячет за собой виртуальность, вот этот путь через C в В не рассматривается и выбирается вот эта версия.
А если у меня не виртуальная G и Y, то возникает неоднозначность, потому что конкурирует версия из B и версия из W, которая пришла из C.
Вот такая замечательная картинка, очень мне нравится, так сказать, для дополнения прекрасной картины того, как работают виртуальные наследования и поиск имен.
Вы поняли этот пример?
Я подумаю.
А давайте…
А давайте нет.
А можно вас снова перевести?
Все, короче, я закончил.
