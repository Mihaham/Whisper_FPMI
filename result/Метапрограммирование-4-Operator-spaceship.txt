И начинаю рекординг здесь.
Тут идет, там идет.
Ну вот, то есть была трехчасовая лекция, мы устали от лекций,
поэтому сегодня тоже будет лекция.
Но только полуторачасовая.
Дальше у нас будет практика, вы не поверите.
Мы прям код попишем вместе.
Вот, а про лекцию.
Что-то, я думаю, не хватает.
Кликера не хватает.
Кликер.
Вот это.
Плохо, да?
Стало лучше.
Можно половину...
Нет?
Или там нету кнопочки, чтобы половину включить?
Там раздельные выключатели?
Нет.
Ну ладно.
Ну давайте.
Нормально видно.
Начинаем.
Все хорошо.
Все, прекрасно.
Сегодня у нас будут космические корабли и друзья.
Ну может кто-то что-то уже слышал про это и понимает
о чем.
Но так со стороны.
Да, он самый, там flying saucer его называют, то есть летающая
тарелка.
Работает?
Не работает.
Вот так сработает?
И так не сработает.
А он включен?
Он всегда включен.
Это же инфракрасное просто.
Ну пожалуйста.
О!
Все.
Работает.
Тарелка.
Я 크� 소�енку proplex и еще одна.
Эм...
Д conjugating.
Ну, что-то каждый раз оно через 10 секунд включается.
Вот, C++20 у нас наконец-то сделали нормально то, что у всех нормальных людей было нормально с самого начала.
Но у нас всегда была боль.
Ну, это такое краткое резюме того, что будет дальше в подробностях.
Добавили новый оператор смешной, выглядит как летающая тарелка.
Добавили, не поверите, дефолтные операторы сравнения.
Даже по названию уже можно догадаться, что это, но там есть некоторые детали тонкие.
И вот это.
Ну, тоже можно по названию догадаться.
Если не догадались, то давайте слушать внимательно.
Начинаем мы с дурацкого вопроса, как обычно.
Вот эти вещи равносильны?
Нет.
Да, у нас там есть понятие.
Ну, тут даже подсказка есть.
Ну, вы флоты.
Ну, когда в армии флот плывет.
Флоты, да?
Floating Point Numbers.
Почему для них вот это все не выполняется?
Там сравнение не будет.
Нет, с нормальными флотами должен выполняться проблема с нанами.
Да, именно так.
Там наны всякие разные и бесконечности, по-моему, тоже.
Они как-то вот в эту всю картинку не очень вписываются.
Ну, и да, вот понятие такое Loom было.
Линейно-порядочное множество на MatLogia.
Ну, даже неважно, если вы его не помните, но я надеюсь, что помните.
Вот это.
Еще такая смешная штука.
Уже нет отдельного слайда? Нет.
Подскажите, Женя.
Да, тут не хватает слайда.
Ну, это, короче, буквально то, о чем вы говорили вчера,
про симпатическую разницу.
Ну, как бы да, но не совсем.
Тут добавляется новая деталь.
Вчера я говорил про равенство представлений и равенство значений.
Ну, не вчера, на прошлой неделе.
Да, там было представление в битиках.
И значение как...
Ну, как что-то такое симантическое, что вы сами придумываете.
Если оператор ровно-ровно для вектора, то
два вектора разных, с одинаковым набором.
Идеи должны быть равны, но они не неотличимы.
Да.
Вот это, кстати, тоже правда, потому что есть точка дата.
И мы можем эту точку дата сравнить и понять, что они на самом деле отличимы.
То есть как бы нам оператор равенства, говорит, и не равны.
Но можно сделать некоторое преобразование и понять, что
ой, на самом деле там какие-то детали имплементации внутри разные.
И вот второе, это именно про вот детали имплементации,
которые можно наружу вытряхнуть.
То есть там любые какие-то структурки вы делаете,
и для них компаратор только по одному полю из нескольких,
вот ровный этот случай.
Ну и вот штука слева называется equality в дальнейшем,
а справа equivalence.
Наоборот.
Слева equivalence, справа equality.
Да никак.
Ну почему я про все это рассказываю?
Потому что в плюсах, как обычно, покрыли крайние случаи.
Эти крайние случаи у вас будут возникать далеко не всегда.
В повседневной жизни у вас все это одно и то же,
и все нормально, и все круто.
А когда крайние случаи возникнут,
вы вспомните, что что-то я об этом говорил,
откройте с папе-референс, и по остаточным знаниям
поймете, что там написано.
Вот, ну и вот понятие сохранения равенства.
Помните, оно было?
Оно ровно про это.
Про то, что никакое выражение нельзя написать,
которое нам позволит потом отличить эти значения.
Ну я надеюсь, это все пока несложно.
Ну так к чему все это рассказывается?
К тому, что есть теперь три янамо классных.
Да, это янамо.
Здесь нигде не подписано, но это они.
Они нужны, чтобы моделировать разные типы порядков.
Смотлога.
Легко догадаться, что стронгордеринг — это вот именно лум,
линейное упорядоченное множество.
Тут вообще, переведя, понимаем, что это частично упоряд...
Сейчас.
Линейно... Да, я вроде правильно сказал.
Линейно упорядоченное множество — это частично упорядоченное множество.
Ну просто понятно, и вроде как должно быть понятно, зачем это, да?
Как бы есть типы, для которых вот только частичный порядок можно гарантировать.
Встречаются все-таки, хорошо бы про них уметь говорить на стандартном языке.
Зачем посерединке штука?
Вот из этой подводочки про эквивалентность равенства.
Догадайтесь.
Есть типы, которые не гарантируют то свойство, что больше-меньше значит равно?
Нет.
Наоборот, первая планета, вторая — нет?
Что первая, что вторая?
Первая — то, что меньше-больше, а вторая — это эквивалентность.
Эквалити-эквивалентность.
Окей. Меньше-больше, сейчас, не меньше и не больше, следовательно, равно
выполнено и тут, и тут, и в стронговый виг.
И то, и другое, и линейно-упорядоченное множество с точки зрения теории.
Да?
В чем отличие?
В том, что...
Строгая и строгая есть, меньше и меньше равно?
Нет, тоже не это.
Меньше и меньше равно есть везде здесь.
И они все консистентно себя ведут, там все от вас требуют и все гарантируют.
Разница в том, что понятие эквивалентности и равенства, они отличаются для стронговик.
Вернее, для виг они разные, для стронга они одинаковые.
Ну, да. Я не услышал просто формулировку, которая была бы мне понятна.
А если мне не понятна, то, наверное, и вам не понятно.
Ну, я предполагаю.
Я тоже пока не понял.
Не понял. Сейчас будет подробно.
Первый сохраняет равенство.
То есть, оператор равно-равно, вот здесь, как и меньше, и больше, и все остальные, они должны сохранять равенство.
Это значит, что если вы берете точку из двух интов и делаете компаратор, который сравнивает эту точку только по первому из интов,
то вы стронгордеринг не можете пользоваться для такого компаратора.
Понимаете, о чем я?
Сейчас еще раз помню.
Давай попишем.
Не крути так быстро камеру, если я иду сюда зачем-то, наверное, я вернусь.
Что я хотел написать?
О чем мы говорили?
Стронг и виг.
Да, точка.
Точка XY.
И мы говорим, что там...
Я супер псевдокодом напишу.
P2.x
Можно вопрос в рамках equality, code и equivalence?
То есть, если, ну, выполняется, что если равно-равно, то оно именно equality, то есть неотличимым.
Равно-равно это эквилентность.
Что значит выражение, которое показывают, ну, что нет выражений, которые показали бы отличимость?
Взятие адреса у перемен, например.
Это является штук, который отвечает?
Отчаянно никто не верит, что оператор взятия адреса и хвалили по визио-органу.
Да, тут есть куча маленьких деталек, таких как точка дату вектора, вот это вот взятие адреса.
Ну, как бы, да, их не рассматриваем, их вот под ковер.
Ковер, про это не считаем, у нас абстрактная машина C++, они не в счет.
Вот, про что я говорю.
Если вот такую структуру рассмотреть, две точки, точка из двух нтов, лотов, неважно.
И делаем операторы всякие, все вообще делаем операторы сравнения для двух таких точек, только по иксу.
Ну, в алгоритмах такое писали точно, правда? Нет?
Ну, там есть всякие алгоритмы, где надо точки по иксу посортировать.
Ну, да, в 2D за n log n.
Чего-чего?
Ну, да.
Ну, вот представьте, что вот такое написали.
Вот он, как бы, частичным множеством, частично-приличным множеством не является тогда эти точки, да?
У нас здесь любая точка с любой сравнима.
Это ничум, это лум.
Но мы можем взять у двух точек, которые с точки зрения вот этих всех операторов равны,
ну, то есть у них x равен, взять их y, y сравнить, и окажется, что, ой, не равны точки были.
То есть с точки зрения наших там вот этих операторов сравнения они равны,
а по факту мы можем их отличить, просто взяв их y и сравних в y отдельно уже, как nt, да?
Знаете, в чем разница?
Поэтому вот Стронгорденинг говорит, что так нельзя.
Не должно быть такого, что вы какие-то данные можете извлечь из своих структур
и потом отличить их, в то время как операторы сравнения вам говорят, что они равны.
А флаты, еще раз, флаты это лум.
Флаты это лум. Нет, чум.
Паршалордеринг.
Потому что там есть...
Наны.
Да, наны, несравнимые ни с кем, везде фолс, и там вообще что-то странное.
Кажется, что тогда Стронгордеринг это просто сравнение над риск.
Нет, нет, нет.
Если мы сравниваем две точки по x и по y лексикографически, то это вполне себе Стронгордеринг.
Не считается.
Да, не считается.
Вот это все не считается, это все другое.
Не смотрим сейчас в память.
Это семантика такая более высокоуровневая.
Нет.
Нет, да, нет.
Подожди, Андрей, сейчас...
Побитого они не обязаны совпадать.
Давайте еще раз.
Побитовое совпадение называется равенство представления.
У любых данных есть представление битовое, да?
Но концептуальные эти данные могут значить что-то более такое абстрактное.
Понятно, что два n-та, они в памяти два n-та, в битах два n-та и везде два n-та.
Но если мы этими двумя n-тами моделируем рациональные числа, то что это значит?
Что на самом деле мы представляем себе как значение отношения этих n-тов.
Просто мы в битах записываем их по отдельности, а не уже их отношения.
И с нашей интуитивной точки зрения значения 2,4 и 4,8 оно одно и то же.
И то и другое представляет одну вторую на самом деле.
Вот все эти значения они одно и то же.
Одно и то же рациональное число.
То есть если мы такие рациональные числа пишем, то мы, наверное, в приват засунем вот эти вот n-ты,
которых будет класс, там будет приватная часть, в нем будут два n-та.
Снаружи к ним доступа не будет.
Но снаружи будет оператор сравнения для такого рационального числа.
Куча их.
И вот они будут сравнивать как нормальные рациональные числа эти байтики
и вполне себе будут образовывать стронгордеринг.
То есть побитовые представления не совпадают, но стронгордеринг все равно есть.
Можем его организовать.
Да, и нельзя из этого привата достать.
Понятное дело, что хаками можно. Говорим про хороший код.
То есть если вы сделаете метод getRowDenominator или getRowNumerator, то это все сломается.
Вы уже сможете их достать, сравнить, ой, они не равны, а нам сказали, что сами дроби равны, все сломалось.
Тогда все нормально будет.
Потому что ты из разных представлений битвах вытащишь для одной и той же дроби
один и тот же числитель или один и тот же знаменатель.
И все будет ток.
То есть даже не то, что все в привате, а просто инварианты нужно сохранять.
Вы должны разрабатывать структуры, классы или структурки,
которые свои внутренние инварианты не дают им протекать наружу.
Не дают протекать наружу формата представления данных.
Понимаете, о чем я так философски?
Окей, я вижу, вам наскучило. Давайте пойдем дальше.
Зачем нам дополнительные требования сохранить сохранение реальности? Что оно нам дает?
Оно нам дает возможность рассуждать о коде, не получая какие-то странные приколы.
Просто это естественно работать с значениями, как с математическими значениями.
Что там битовое представление...
Ну, над обительными представлениями думать не хочется, хочется думать о значениях.
В голове иметь какую-то абстракцию.
Эту абстракцию, вот как просто вертеть ее как математический объект
и на основе этого писать код, чтобы он работал.
Как только вы даете своим битовым представлениям протекать наружу в обход абстракции значения,
код становится писать сложнее, могут быть неожиданности.
То есть все вот это вот, это про то, как писать правильный код.
Если у вас стронгординг, то вы в шоколаде все хорошо, все правильно делаете.
Обычно так и получается.
А если что-то послабее, то надо уже задуматься, не пошло ли что-то не так и нормально ли все.
Давайте идти дальше, потому что там еще много слайдов, я боюсь, я вперед уже забежал.
У этих янамов, я напоминаю, это были янамы, которые как бы классифицируют типы компараторов,
но у янамов есть элементы, которые дают ответ на вопрос сравнения.
Вот два элемента, сравни мне их.
Стронгординг вам может сказать less, equivalent, equal и greater.
Но equivalent и equal у стронгордера это одно и то же значение.
Один и тот же элемент янама.
Да?
Ну, легко догадаться, что у...
Вот тут еще в таком формализме то же самое написано,
что любая функция, которая как бы сохраняет вот этот контракт абстракции,
она не может взять и различить.
Вот все.
Мы считаем вместе с этими побочными эффектами или без?
Со всеми побочными эффектами, со всем таким.
Внутренний счетчик просто увеличивает.
Как с каждым уже зовут.
Наверное, чистая функция, надо сказать.
И без всяких адресов.
Ну да.
Мы сразу все отсекли.
Ну, equality preserving, да.
Смотрите, если вы хотите очень точные, очень максимально точные формулировки,
их можно открыть в стандарте, но там, к сожалению, вот не столько строк, а вот столько.
В этом проблема.
То есть тут надо учитывать.
Если мы обовляем рецензивные числа и глянем за динаминатор, то мы получаем q-кордеринг?
Да.
А что с ней?
Они разные просто.
Ну окей, у строн-кордеринга это одно и то же.
Вот просто эти элементы янамы, они равны.
Давай q-кордерингу.
А, да.
Тыры-пыры, объекты равны, неразличимый по концу ссылкам.
Вот это вот прям, по-моему, цитата из стандарта.
Идея в этом.
Окей.
У q-кордеринга уже нет просто equal.
Мы не можем на равенство сравнивать то, что реализует q-кордеринг, только на эквалентность.
То есть тут абстракция такая, что ваш компаратор реализует какой-то порядок,
но который не совсем естественный для этих данных.
То есть он учитывает не все данные, например.
Или как-то нарушает абстракцию.
Такое тоже бывает, поэтому он есть в стандарте.
Но лучше стараться так не писать.
Ну, если вы там для точек все-таки пишете компаратор, который только по одной из точек сравнивает,
то вот такой он будет.
И partial.
Тут еще один вариант добавляется.
У нас бывает, что вообще несравнимы два элемента, так как порядок частичный.
Ничего космического, все окей.
Да, вот тут странный вопрос, странно сформулированный.
Непонятно, что я спрашиваю, да.
А я спрашиваю вот что.
Вам откуда-то с неба прилетела в автопеременную один из элементов одного из этих янамов.
Написали там auto x равно, непонятно что.
В обратку прилетел один из этих вот элементов одного из янамов,
непонятно какого, и хочется понять, что он как бы в целом значил.
Больше, меньше, равно или там вообще что-то непонятное.
Это, кстати, нас отсылает к тому, о чем мы с самого начала говорили про спаны.
Такая ситуация, где непонятно, что прилетело в обобщенном коде возникает,
когда у вас еще один шаблон, вы даже не знаете, какой из янамов используете,
и надо как-то выкручиваться.
Ну, а нас позаботились, нам позволили сравнивать эти элементы
любого из вышеперечисленных янамов с нулем.
Ну и понятно, что будет, да.
Мы сравниваем элемент, и при сравнении less будет меньше нуля,
equal and equal будут равны, greater больше, и просто не равен ему unordered.
То есть, на самом деле, это вот какой-то дебильный подхак, мое честное мнение.
Можно было бы сделать функцию из less, и для всех less-ов из трех янамов возвращать true.
Ну, идея в этом.
А вот это вот не равно, это is unordered на самом деле.
Ну оно как бы имеет некоторую такую интуитивную интуицию, но в целом...
Короче, про лего сейчас дойдем.
Потихонечку давайте.
И внимание.
Про UB в стандарте на ровном месте.
Сравнивать можно только с литералом ноль.
Если вы напишите в коде сравнение с чем угодно другим для этих янамов,
то это UB.
Почему? Зачем? Ну, вот так вот.
Идем дальше.
Но дело, что эти штуки образуют такую некую иерархию.
Как бы strong он является и weak, и partial.
Weak при этом является partial.
Ну и...
Короче, картинка.
Их можно кастить даже, по-моему, друг к другу, если я не ошибаюсь.
Прям просто брать, и как значение кастить, и все будет работать.
Окей.
Зачем все это было нужно?
Вот для этого главного персонажа сегодняшней программы,
оператор Spaceship.
Его возвращаемое значение
это как раз один из элементов одного из...
Окей.
Возвращаемый тип.
Один из этих янамов, возвращаемое значение, элемент одного из них.
LAS, less equality, equal, или просто strong order.
Вот это типы.
Вот эти элементы?
Это янамы, да?
Возвращать из этого оператора мы обязаны тип янам.
То есть какое-то из значений этого янама.
Причем и сам янам тоже нужно выбрать.
То есть для каждого типа вы, когда пишете сравнение,
вы выбираете одно из этих трех,
и пишете оператор Spaceship.
Пока не понятно, зачем.
А возвращает он либо strong, либо weak, либо partial order.
И в своей реализации, соответственно, одно из значений.
Почему-то очень сложно сформулировать то, что я хочу сказать.
Функция возвращает янам.
Понятно же, да?
Будем надеяться, что да.
Можно писать и как просто глобальную штуку,
то есть вне класса.
А можно писать как member класса.
Тогда неявный второй аргумент это класс.
И из двух аргументов понимаем, что это бинарный вообще-то оператор.
Нужно писать там x меньше равно больше y.
И что-то произойдет.
Так вот, что произойдет?
Эта штука сравнит, по идее, сравнит x и y.
И даст вам как элемент одного из этих янамов ответ,
что там было на самом деле.
Ага.
Поняли, что такое Spaceship?
Так, ну сейчас давайте пока чуть-чуть придержим коней.
То есть он, получается, по элементам скажет,
в каком порядке они относятся?
Окей, нет, это просто Memcmp обобщенный.
Знаете функцию Memcmp?
Да.
Она сравнивает строки и говорит,
1 если больше, 0 если равны,
минус 1 если меньше.
Это удобно, потому что местами в коде вы хотите сделать 3 бронча.
Один бронч меньше, другой бронч больше, третий равны.
Бывает такое.
Стандартные старые операторы сравнения C++ вам не позволяют взять
и за одно сравнение понять, какой из трех вариантов там был.
Вы можете сравнить на меньше либо на равно.
Ну и если вы хотите все три варианта как бы разобрать,
вам нужно два раза вызвать какой-то оператор в сравнение.
Для строк, например, это неэффективно.
Понимаете, нам в два раза пробежаться по строке нужно,
по двум строкам.
Первый раз мы пробегаемся, сравниваем, что одна меньше другой,
поняли, ой, нет, она не меньше,
но еще же они могут быть равны,
поэтому второй раз запускаем оператор сравнения,
уже оператор равно-равно,
и проверяем, равны ли строки.
Неэффективно, да?
Хочется один раз пробежаться и сразу как Memcmp вернуть,
просто меньше, больше или равны были элементы.
Вот оператор spaceship призван делать ровно это.
А вся эта билиберда с разными ордерингами,
потому что не получается так просто сказать,
что все типы, в принципе, сравниваются одинаково,
все нормально, давайте там возвращать int.
Что-то должен вернуть Memcmp в случае, если там несравнимый...
Ну ладно, Memcmp ничего не должен никому.
Короче, янамы, мне кажется, понятно, зачем добавили.
Понятно ли вам?
Можно вопрос?
Да.
Почему только в 20 плюсах это добавили?
Потому что долго не могли договориться,
что такая штука нужна, очевидно.
А вот об этом не могли долго договориться,
что должно происходить с этими тремя штуками,
какие должны быть, какие не должны быть.
Ну да, там...
Задай мне вопрос.
Он стесняется.
Задайте кто-нибудь другой вопрос.
Или это очевидно сейчас, что spaceship...
То есть, какой рецепт теперь?
Ну, зачем это понятно, да?
Умеем сравнивать, все круто.
Рецепт.
Вы написали свой класс,
хотите его запихнуть в какой-нибудь unordered map.
Фу, ordered map, map просто.
В map или set?
Класс set.
Нужны операторы сравнения.
Вы теперь пишете не шесть операторов, а один.
Вот этот.
Но перед тем, как его писать, вы должны понять,
к какой категории порядков относится ваш класс.
Категории три.
Strong, weak, partial.
Лучше всего, если вы напишете такое сравнение,
которое будет его относить к strong.
Иногда это неестественно.
То есть, можно за уши притянуть побитовое сравнение всегда,
но смысла в таком сравнении будет мало, да?
Опять же, пишем рациональные числа, два nта.
Ну, хотим strong, давайте там побитого сравним
в представлении ntoflix графически.
Бесполезно.
Weak иногда бывает более естественно.
Partial совсем в редких случаях, если у вас что-то исключительное.
Выбрали yinam, написали сигнатуру,
и дальше пишете свое сравнение,
где код сравнения настоящий,
и возвращаете один из элементов yinama.
Меньше, больше, равно, неравно.
Во!
Поняли?
С 20-х плюсов вы больше не пишете.
Никогда руками операторы меньше, операторы больше,
меньше равно, больше равно.
Я так говорю уверенно.
Ну, скоро увидим.
Перед этим надо посмотреть на новый концепт.
Мы же любим смотреть на концепты жуткие.
Ну вот, класс называется, корректно,
three-way comparable
для категории конкретной сравнения.
Если, во-первых, вот это и вот это,
это мы, кажется, в прошлый раз
примерно что-то такое видели,
но давайте просто подсказки откроем.
Просто вот равенство и неравенство
нормально работают.
То есть там все требования уже наложены про...
Короче, все ждут.
Концепты мы смотрели.
Да, в прошлой лекции оно есть.
Пересмотрите, если хотите.
Кроме, вот там называлось
просто equality comparable with,
а здесь weekly.
Теперь понимать должны, в чем разница.
Equality preservation не требуется.
Тут тот концепт, который мы раньше смотрели,
он был полноценный концепт в STD,
который вы сами можете использовать.
И там требовался equality preservation.
Здесь не требуется.
Вот такой прикол.
Потому что вот этот весь концепт
в целом должен для всех категорий работать.
OK.
Partially ordered тоже понятно,
что меньше, больше, всякие вот эти штуки
определены, консистентны.
То есть все математические правила,
что если меньше, то можно поменять местами.
Вот это все фиксируется.
Ну и тут какие-то еще мелочи.
Ну вот эта мелочь там...
Что-то...
Давайте просто вы посмотрите.
Сначала.
Потому что я чувствую, что если я просто говорю вслух,
то вы меня слушаете, а это не смотрите, и нехорошо.
Да?
Третье, что требуется компресс,
он вот здесь приведен.
То можно сказать, что вот это вот заклинание значит.
Да, именно так.
То есть требуется, чтобы вот это вот выражение
вернуло какую-то категорию,
ну то есть возвращаемый тип этой функции
был какой-то категорией,
которая хотя бы настолько сильная,
насколько попросили изначально.
То есть любой Strongly Comparable
будет и Паршали, и Викли,
и любой Викли будет Паршали.
Во.
Едем дальше.
Тут, кажется, больше ничего нет.
Да, для встроенных типов
у нас оператор спейс-шипа определен.
Понятно как.
Здесь есть маленький подвох.
Ищите подвох.
Где здесь на самом деле...
Андрей, тихо.
Ты молчишь.
Кто из вас лучше всех знает плюсы?
Что-что?
А почему ты считаешь, что Вик
Ордеринг Пойнтеров?
Что это значит?
Нет, просто сам указатель
по себе это значение.
Да, мы его рассматриваем
как значение, как число.
Да, вот сравнение указателей
не является сравнением объектов,
на которые они указывают.
Но это правильное замечание,
что подвох именно в указателях.
Где он?
Никто не видит подвоха.
Да, нолпы Т это не проблема,
это просто нолик.
Да, тут я выделил,
что флотинг-поинт подвох.
Нет, подвох,
ну, конечно, он определен только для конкретного типа.
То есть для всех Т-звездочка
с конкретным Т их можно сравнивать,
получить стронг Ордеринг.
Но, забавный факт,
если вы сравните два произвольных указателя,
которые не указывают
на часть одного и того же объекта,
это УБ.
То есть выделили один массив,
другой массив, и решили посмотреть,
кто из них в памяти раньше лежит,
а кто позже.
Сравнили их бигины или их даты,
УБ.
Если с кастом кинт по ТРТ,
все будет хорошо.
Но это при условии,
как вообще рекомендация
implementation defines.
Это умные слова.
А что на самом деле происходит?
Они пытаются поддерживать архитектуры,
где виртуальная память
не является последовательной.
Разве в NUMA это как-то используется?
Хороший вопрос.
Кто-нибудь знает здесь,
что такое NUMA?
Это скорее, когда на материнке
много процессоров, что-то такое.
Я тоже не особо могу...
Ходят там легенды,
что в дата-центрах сейчас ставят
на одну материнку по пять процессоров,
и у каждого из них отдельная память.
Но, по-моему, это не про это.
По-моему, это про экзотические,
старинные системы, которые давно
никому не нужны и никто ими не пользуется.
Может и про NUMA.
Короче, это такая вещь,
в которой разбирается полтора человек на планете.
И вот им это важно, что там...
Ну, как-то так.
Вот им важно, что там УБ,
что есть ли из разных объектов
сравнивать указатели.
На практике это никогда не ломается,
прекрасно работает.
Поэтому решили бахнуть стронг,
что, конечно, забавно.
Вы как бы сравнить-то можете,
результат мы вам всегда скажем,
но в какой-то момент дракон может
вылезти из компьютера.
С ТДЛС? Нет, потом все будет.
Мы же помним, что у НТДС
создавались основные
драконоператоры?
Фалбекки какие-то.
Я такие вещи не известно.
Пора это будет.
Что ты спиллеришь?
По-моему, нельзя один объект
на разных распределенных штуках
выделить. Там вот так не работает.
Просто вся эта схема. Не уверен.
Я здесь не советчик, я решил
распредамень не заниматься,
это было волевое решение,
поэтому я не могу про них ничего
рассказать, кроме каких-то вот таких
научпоп.
Потому что оно все не визуальное,
в графике как-то картиночки классные.
Да, тут строчка появилась,
пока вы отвлекались, давайте
поменьше как-то отвлекаться.
Про булы.
Тут тоже
такая смешная деталь,
что мы как бы пытаемся
ограничивать всякие дурацкие
implicit конверсии,
даже в плюсах как.
Функция принимает
yinam, можно туда передать true.
Спокойно.
True конверсируется в int,
а yinam, который не класс,
он по умолчанию является int.
Вот тут пытаются это как-то
отпилить. Не уверен,
что это к чему-то приведет,
но в какой-то момент у вас ошибка
компиляции будет и здорово.
Да, про потенциальную B мы
сказали.
Вот, сейчас
будет самый сок.
То, чего мы ждали годами
и дождались.
Вот этот код
скомпилируется.
Почему?
Ну,
ты понял, значит,
в чем суть.
Поняли ли остальные?
Да, да, да.
Да, вот просто теперь
не надо никогда оператор
не равно писать. Вообще никогда.
Он сам по магии появляется.
Сколько плюсам лет?
30, 40, 50?
Ну,
ну,
сколько плюсам лет? 30, 40.
Спустя 40 лет мы научились
автоматически в компиляторе
прописывать восклицательный знак
и скобочки, что там не A равно
B. Круть.
Да, но ведь и так
тоже работаем.
То есть, вот почему я сказал, что
больше не надо никакие операторы писать,
потому что один спейс шип реализовали, все
сравнения работают.
А в чем проблема?
Примеры все будут
абсолютно одинаковые.
Вот так еще бывает.
Да, вопрос.
Ну, вот чтобы
из равно-равной
была Вадима неравно,
почему это
не можно?
Ну, потому что приходят и говорят,
ну, раз вы это добавляете,
добавьте еще, чтобы операторы меньше-больше
друг из друга выражались.
Нет, ну, ты приходишь в
комитет, тебе говорят,
ну, вот раз вы это делаете,
то сделайте и это тоже, пожалуйста.
Но ты приносишь сделанное, тебе говорят,
ну, это ж неудобно, давайте добавим какой-нибудь
оператор сравнения для всех трех сразу.
И вот мы как бы уперлись
в старых баранов.
Да, в общем,
бюрократия. Почему это все так поздно пришло,
это все бюрократия.
Вот такое еще переписывание бывает.
На старом слайде
просто было про то, что
оператор spaceship можно переписывать
как, компилятор умеет
переписывать как оператор сравнения.
Теперь про
разные типы.
Здесь оператор сравнения равенства,
он принимает
два разных типа.
Причем первый, ну, вот this,
он как первый аргумент идет всегда.
А второй аргумент, тут какой?
Q. То есть
аргумент C, второй Q. А здесь
какой порядок снизу?
Наоборот.
Она переписала. Даже аргументы местами
получается уметь переписывать.
И spaceship тоже может.
Давай полную табличку.
Вот это полная табличка, все,
чему научили компиляторы в двадцатых плюсах
по переписыванию. Равенство
переписывается по
часто симметричность называется,
да, коммодативность
что-то другое.
Сейчас, про что эта табличка была
на самом деле?
Окей, все, тихо.
Давайте просто дальше по ней пойдем.
Неравно через равно переписывается.
Да, то есть если у вас определенный
вот, про что табличка.
Здесь написано, какой должен быть оператор
определен. А вот в той табличке
какое выражение
мы будем использовать вместо
изначального выражения.
Если изначально было равно,
то мы попробуем использовать равно с
другим порядком, и выражение
в итоге будет такое.
Если увидели неравно,
попробуем найти равенство.
Причем в обоих направлениях.
И перепишем.
Вот, как я говорил,
восклицательный знак, скобочки.
Со всеми
операторами сравнения, меньше, больше,
меньше или равно, больше или равно,
все одинаково.
Всегда увидев такую штуку, мы пытаемся найти
спейс-шип и переписываем как
спейс-шип...
Спейс-шип собака
ноль. Где собака это изначальный
оператор. Или наоборот
ноль собака спейс-шип.
Вот.
Если так задуматься, то
понт вот этого всего в том,
что вы можете взять и из спейс-шипа
вернуть int
memcmp.
Вот как бы под это все немножко подстроено,
чтобы мы были обратно совместимы
с C до каких-то вот невероятных просто
высот. Ну и сам спейс-шип
тоже переписывается внезапно.
Сменой порядка аргументов.
Но как же я вам, блин, не рекомендую
пытаться сравнивать на меньше, больше,
разные типы. Это какая-то дичь.
Лучше такой код просто не писать.
Вопрос, если мы захотим двойно
сравнить вот эти
коды.
В X у нас пролетела STD
Strong Ordering Less
и мы
сравним это с the Big
SGP.
Ты их можешь прикастить
к, типа, к наименьшему общему кратному.
Они же друг друга кастятся.
Но оно автоматически скастится или нужно
будет скаститься? Не знаю.
Ну, таких проблем у тебя не возникнет,
потому что проблема с всеми этими
ордерами возникает, когда ты пишешь
какие-то сложные алгоритмы, которые
используют сравнение и хочешь, чтобы они
работали с любым legacy.
Вот каким бы оно плохим не было.
На нашем курсе
нету таких вот задач, где бы
просто написать алгоритм и
аккуратно использовать
шаблоны
на меньше, больше.
Возможно, такие задачи
стоит сделать, но сейчас ее нет.
Да и в жизни ты вряд ли в какой-то момент
такое будешь делать.
Но если будешь, то вот это все придется
перечитать заново, конечно же, и учесть.
Ну, в целом,
если ты пишешь новый код,
то сейчас будет простой рецепт, который
позволит все быстро просто
чтобы нормально было.
Давайте просто дальше пойти.
Поняли, как все это переписывается.
Вот тут некоторые вещи называют
разными именами. Есть
синтетические кандидаты,
а есть типа
обычные, переписанные.
Видите, в чем отличие?
Вот синтетические
это те, у которых местами аргументы
поменяли.
Дурацкое слово, но
вот так их называют.
Поверлот-резолюшн.
Помните, что это? У нас там был
целый списочек, что типа три пункта,
как мы выбираем какую функцию вызвать.
Последний пункт был выверать из множества
имен функции самую подходящую.
Но вот я сказал, что его не поменяли
в двадцатых плюсах. Нет, поменяли.
Добавили
вот это вот правило,
что когда мы пытаемся найти оператор
подходящий
для какого-то сравнения,
то мы сначала пытаемся
найти обычный оператор,
определенный пользователем, потом
пытаемся использовать переписанные кандидаты,
то есть здесь белые строчки.
То есть равно,
не равно выразить как равно
или какой-нибудь меньше, больше и прочее,
выразить как spaceship.
И только в последнюю очередь, если совсем не повезло,
то пытаемся вот эти вот synthesize.
Сложные какие-то правила, да?
Мораль не надо определять.
И всякие меньше, больше,
и spaceship, потому что
что-нибудь запутается у вас, и все будет плохо.
Лучше один spaceship
и о.
Вот.
Чувствую, что какого-то слайда не хватает.
Так делать можно.
Внезапно.
Да ни в чем.
Просто это немножко странно.
Мы из оператора spaceship
возвращаем int, да?
Какой ордеринг?
Вот это правильный вопрос.
Вот он к вам,
он не ко мне.
Табличка есть,
пример есть.
Вот.
Что нам сделают?
Ну да.
Ну, с предыдущим примером
по аналогии. Просто смотрим в табличку,
как она переписывается.
Да, вот там выражение
есть, самая правая колонка.
Вот это будет переписано
как выражение самой правой колонки.
И в этом выражении уже можно понять,
какие типы сравниваются,
и какой тогда будет ордеринг.
Не на меня надо смотреть,
на табличку.
Какой?
Ну, вот в первом случае,
во втором.
Тут два примера.
Ну, первый очевидный.
Скажите мне, какой тут будет тип?
Int.
Никакого переписывания не произойдет.
По overload resolution у нас есть
просто оператор spaceship, вот его и используем.
А во втором случае,
просто оператора spaceship мы не найдем.
Да, вот какой из них,
какая строчка подойдет?
Да, вот самая последняя строчка,
где мы поменяем их местами.
Так, вот у нас выражение
B и A.
Ну, наша неудача в том,
что там A и B наоборот названы.
Ну, мы, короче, это перепишем,
переставим их местами,
потому что такой оператор spaceship
не подойдет.
Ну, в этом случае мы не найдем
оператора spaceship,
переставим их местами,
потому что такой оператор у нас есть.
И выражение в итоге будет какое?
A фигурный 0,
spaceship A, spaceship B.
То есть, если на самую правую
нижнюю ячейку посмотрите,
провалидируйте.
Там будет spaceship
между нами.
Да, и это будет
strong, правда ведь?
Да, вот, то есть, кто сказал
strong, кажется, это ты первый был.
В общем, действительно будет strong,
что достаточно странно.
Может и не странно.
Может.
И за счет
переписывания у вас
начнет происходить какая-то дичь.
Ну, зачем
это сделано? Под memcpy.
Здесь предполагается написать
memcmp.
Memcmp возвращает int
минус 1, 0, 1.
За счет
всей этой фигни
у вас все, в принципе, будет работать.
Но опять же, лучше
так не делать. Лучше
избавляться от legacy, переписывать его
и делать нормальный ордеринг.
Чтобы вот это
в голове не хранить табличку там.
Вообще ужас.
Нам добавили много функциональных
объектов, смешных, в стандартную библиотеку.
Ну, то есть, less были,
все были, кроме
mpr3way, да?
Ну, про них
что-нибудь помните? Что это такое?
Что? Нет, вы не помните,
что это за функциональный объект
std less?
Ну да, просто
тип, у которого есть
оператор круглые скобки, который делает
то, что он говорит.
Мне кажется, я сегодня туплю.
Сейчас.
Фулбек, будут сейчас
фулбеки, так.
Сколько времени? Нормально
времени, мы идем более-менее
хорошо. Нет, быстрее
бы.
Вот.
Бонус, как раз,
который заспылирили, мне казалось, тут
больше слайдов, но их меньше.
Поняли, что это значит?
Без УБ.
То есть, если вы сравниваете
через вот эти функциональные объекты
указателя, вам
уже УБ на указателях
не будет.
Как они этого достигают,
это их забота, но
вот магия.
Ну, то есть, что это вам позволяет делать
на самом деле? Это вам позволяет
запихнуть, не так,
сделать мап из указателей
во что-то другое.
Потому что если бы указатели
на объекты, которые никак не связаны,
нельзя было вообще сравнивать,
то мы бы как бы мап не смогли
из указателей во что-то сделать, да?
Вообще беда.
Можно, но только через пятую точку нужно
через эти функциональные объекты идти.
Да, про легаси.
Для легаси уже
много чего сказал, что нужно.
Вот мы написали новый бинпоиск,
оригинальный,
и вписали туда вот этот вот
с ревей, чтобы было быстрее.
Тут он меньше,
больше, равно три случая.
Воюзкейс.
Но вот надо утверждать, что не так.
Надо писать вот такое заклинание.
Про то, как, собственно, алгоритмы писать.
Заклинание
крайне магическое.
Вот почему
речь идет
о легаси.
Мы написали вот этот меньше равно больше,
но был ли там пункт
про переписывание меньше равно больше
через обычные операторы сравнения?
Там был просто спейс-шип.
Вот если мы сюда
попытаемся подставить тип,
который не современный, о легаси,
и в нем просто по отдельности
оператор меньше, оператор больше,
равно и так далее.
Что будет?
Ошибка будет. Почему?
Правил переписывания спейс-шип в старые
операторы нет.
И это задумано так не случайно,
а специально.
Что там цикл может возникнуть,
что вы туда-сюда переписываете?
Наверное, не может.
Но в целом вот эта шняга
позволяет совладать со старыми классами,
для которых нет оператора спейс-шип.
И там сейчас опять начинается
целая стена
разных таких штук.
То есть,
что это все значит?
Сейчас, первые три, что значили?
Мне кажется, на следующих слайдах
будет. В общем, что вот это за strong
order, weak order и partial order
fallback? Это говорит,
что попробуй сравнить
оператором меньше равно больше,
но если не выходит,
если обычные старые операторы меньше,
операторы больше и так далее,
и думай, что
order вот такой, как тут написано.
По-моему, так.
Давай вот сюда сразу смотреть.
Тут просто по реализации
проще понять, что происходит.
Мне кажется, еще больше, чем в прошлый раз
туплю. Знаете, почему?
Я до четырех ночи заполнял
интерплан аспиранта.
Так что, прошу прощения,
я не выспался от слова совсем.
За тупы идут.
Да, и поэтому я уже
успел хотеть спать обратно.
Это функции, да?
Стена шесть штук, я их
на две штуки, две категории разбил,
одни из fallback, другие просто.
Функции
принимают два аргумента и делают следующую
последовательность действий.
Во-первых, они являются CPO.
Что это такое, мы узнаем попозже.
Пока что это значит, что
можно кастомизировать и вот сюда
впендюрить свой callback, как бы.
Вообще кастомный, со стороны.
Странно
звучит сейчас, не будем об этом.
Внезапно
вот эти функции гарантируют
для флотов total order,
то есть strong.
Как, почему?
Гарантируют.
То есть они как бы по приоритетам
идут, если нашлась какая-то
кастомизация, чтобы это
не было. Но это то, что вы руками пишете,
оно перехватывает управление вот этим всем.
Если нашлось, то и запускаем
ее, если флот, то делаем
вот этот костыль странный, иначе
three-way spaceship, иначе
пытаемся сравнивать с более сильным
order.
То есть о чем этот вот order?
То есть spaceship
как бы пытается делать
именно с
таким order, который вы попросили.
По-моему так.
А fallback
делает то же самое, что и первое,
но еще и пытается выражать
через меньшее и равенство.
Вот так вот. То есть
поддержка legacy вообще
во много стизей. Если у вашего legacy есть
вот эти операторы, то через них выразится
круто, если нет, то можете
вот сюда впихнуть кастомизацию, как
неважно, таким образом
подкостылять, да еще и флоты
вот почему-то тоже подкостыленные.
Сейчас
не могу сказать зачем.
Но если честно, это очень полезно,
что каждая
функция, они как минимум
всегда возвращают
ordering, в отличие от оператора spaceship,
который вот благодаря тому,
более ранних примеров, иногда не творится.
Да, вот это тоже
как бы полезно,
да. Коль скоро
мы позволяем spaceship возвращать
int, кто-нибудь это будет делать,
поэтому нужно позаботиться о том, чтобы это
не сломало наш код и использовать вот эти функции
на самом деле. Да.
Кажется, что
вот std exporter
в частности, кстати,
неправильно сказал.
Кажется, что std compare freeway
учитывает тоже, что кастыль для
флотов добавляется там для указателей.
Да, для указателей.
Кажется, что хочется не всегда
пользоваться compare freeway, а не
spaceship.
Да, на самом деле ты в обобщенном коде никогда
не хочешь оператора spaceship писать.
Ты хочешь использовать всегда одну из вот этих
трех функций.
Вот вообще реально всегда.
Если твой алгоритм требует
strong ordering от типов,
то пиши вот этот. Если
и wix идет, то пиши этот.
Если вообще partial достаточно, у тебя там
топологическая сортировка
по partial order,
то partial.
Оно ошибку выдаст, по-моему.
То есть если прямо у объекта определен
оператор spaceship с partial order,
а ты пытаешься их сравнить через
strong order, то это
ошибка.
Вот это фара из тоф в объекте,
ну в классе.
И вот я говорю, что...
Ну как? Он просто декл-тайп
от a, spaceship, b.
Знаешь, какой там тип?
Ну и все.
Сразу понятно, какой это из ордеров
и подходит ли он тебе.
То есть как бы если кто-то определил специально
неправильный spaceship с неправильным
ордером, то это вам вообще все сломает.
Тут никак не закострелять,
как кажется,
кроме CPO.
То есть вот это CPO еще и позволяет закострелять,
если кто-то плохой оператор сделал.
Давайте не будем о плохом мораль
вот этих всех тонкостей, что
есть дурацкая процедура о том, что нужно
сделать, чтобы
нормально вызвать в обобщенном коде
spaceship.
Если вы слушали внимательно, вы ее наверное
сейчас поняли. Если нет, то просто
используйте вот одно из этих трех.
В вашем шаблонном коде
пишите не spaceship, а вот это.
Все, едем дальше.
О чем это мы?
Да, для точки
хотим лексографический порядок.
Как-то тупо, да?
Вот если это будет точка
из трех координат, то тут еще один
IF добавится тупой. Если из четырех,
то еще один IF.
Ну как-то ежу понятно, что имеется
в виду, правда? Это тупой
машинный код. Вот можно его
на питоне сгенерить.
А можно...
А, нет,
это пока не про это, что ли?
Я запутал себя. Черт побери.
Что здесь происходит?
Нет.
А, да.
Давайте это пропустим.
Это все нафиг не надо.
Вот.
Оператор равенства.
Дефолтный.
Угадайте, как он работает.
Нет, не побитого.
Вот ко всем полям это правильно.
Теперь надо сформулировать, что такое поле.
Но оператор spaceship
тоже есть дефолтный.
Какой он порядок будет делать
на полях?
По всем полям по-разному можно
спросить.
Ну, вот как бы да.
Самый естественный
это лексиферический порядок. Именно он и
будет. Вопрос в каком
порядке поля считается?
Да, и где
вообще поля?
Ну, сейчас будет.
А, да, даже вот так можно.
Внезапно. То есть тут я говорил, что можно
spaceship и конкретный ордер указать.
А теперь
я говорю, что можно не указывать
ордера, просто авто
написать, и вам его сами выведут.
Но, я думаю, интуитивно можно представить себе,
как это будет работать и должно
работать. Давайте на всякий случай разберем.
Вот так делать нельзя.
То есть только два варианта.
Оператор равенства и оператор spaceship.
А зачем вам какие-то дефолтные операторы меньше,
если есть дефолтный оператор spaceship?
Они через spaceship выводятся.
Ну, да.
Поэтому ничего нельзя,
все это запрещено, оно все выводится. Не надо
их больше писать, эти операторы.
Просто не надо, никогда.
Идем дальше.
Вот, что такое поля.
Тут вводится такое понятие,
опять новый стандарт впихнули.
Проширенный список
подобъектов.
Просто мы не можем.
Значит, берем список базовых классов,
берем все поля,
но если среди этих полей
есть массив C,
то есть int A в квадратных скобках
8, то они как бы разворачиваются
поэлементно и добавляются
в этот список.
То есть список состоит из вот этих
вот объектов,
подобъектов.
Ну, и мы просто их сравниваем
в электрографическом порядке либо
подряд.
То есть вот, дефолтный оператор сравнения
работает так,
дефолтный спейс-шип работает
вот так.
Причем
сейчас, вот это авто, да.
Привет.
Ты пришел к нам послушать?
Ну, приходи, заходи,
только поздно. Надо вот так, и вот
перед камерой у тебя выбора к сожалению нет,
чтобы все видели, кто
опаздывает.
Какой порядок?
Ну, потому что
ты можешь сравнить точки сначала по
X, потом по Y, а может
сначала по Y, потом по X.
Это будет не одно и то же.
Поэтому, когда ты делаешь свой
оператор сравнение, нужно как бы
учесть это.
Вот, и да,
я не сказал, поля здесь подряд добавляются
в порядке объявления, просто сверху вниз.
Ну, вот это самое естественное,
что можно было придумать. Сначала идем
родительские классы, потом поля, потом
и потом все.
Про вот этот вывод авто.
Тут опять закавыристые детали как раз,
одно из того, из-за чего они могли договориться.
Ну, понятно, что мы проходимся по всем
полям и видим, что у каждого из них
есть какой-то оператор спейс-шип, да.
Дальше начинаем
посмотреть, что они возвращают.
Weak, strong, partial.
Берем как бы
наибольшее из них,
наименьшее.
То есть, если хотя бы одно поле
partial, то и вся структурка
ваша тоже будет partial.
Ну, например, из-за этого
для точки из двух флотов
как-то не очень прикольно получится,
если вы напишите вот с авто здесь, да,
вам выведут, что
у вас точки тоже
partial, возможно, вы хотели не этого.
Ну, и да,
выводят, выводят, выводят,
получают что-то, и оно и превращается
в авто.
Сейчас был ли тут, вот, отлично.
Если же вы явно указали, что я хочу
вот такой ордеринг, а не какой-то другой,
то вам будут проверять
еще, что
все
поля, они как бы имеют
хотя бы настолько сильный оператор
сравнения, spaceship.
Ну, то есть, вот,
это must be convertible
turret T. Помним где-то
на подкорке, что эти янамы кастятся друг
другу.
Проверка.
Какой здесь будет ордер?
Вик,
Вик,
потому что флоты
флотов Вик,
partial.
Правда ведь? Правда.
Ура.
Тут еще что-то про legacy.
Они еще синтезируют ордер.
О, да.
Потому что мы хотим еще и так делать.
Вдруг у вас в полях есть legacy класс,
у которого нет spaceship, а вы все равно
хотите сделать дефолтный spaceship?
Ну, мало ли.
Вдруг вы там boost разрабатываете
какой-нибудь?
Сейчас нам как-то помогут, да?
Да, нам помогли. Сказали, что
сравнение идет через
since reway
rete.
Который выглядит
вот так.
То есть, ну, да,
накрутили.
Даже когда вы дефолтный оператор spaceship объявляете,
у вас оно там пойдет искать
операторы legacy,
операторы сравнения, из них пытаться
составить нормальный
spaceship. Причем spaceship
генерируется по-разному,
в зависимости от того, какой ордеринг
вы запросили.
Он генерится
как бы не при вызовах,
при вызовах он не генерится,
когда вы просто пытаетесь вызывать spaceship,
он не сгенерится.
А когда вы пытаетесь
сделать дефолтный оператор spaceship
с конкретным типом,
вот здесь вот,
да, и одно из
полей этого класса legacy,
то есть у него нету spaceship,
он генерит,
он как бы не то чтобы
генерит, но он сравнивает
как будто бы есть spaceship
по следующему алгоритму,
то есть получает результат
spaceship для этого legacy класса
следующим образом.
Вот это вот зашито в spaceship,
то есть spaceship не регенерится,
но все это проверяется.
Да, вот все это зашито в равно
дефолт молшебное.
Если вы запросили strong,
то оно будет сравнивать просто двумя
сравнениями, если weak, ну в принципе тоже.
Еще раз, я может быть пропустил,
можно чуть-чуть сказать назад,
если я скажу
оператор spaceship
const равно
default и там
strong quartering,
поэтому у меня там будут флоты
или точки, ну не точки,
ладно, флоты будут,
то он выдаст ошибку?
Хороший вопрос.
Не знаю.
Может и выдаст, надо проверить.
Тут
не об этом речь,
тут речь о моментах,
когда у тебя вообще не определен оператор spaceship
для одного из классов.
Наверное, он должен выдать ошибку, да.
Но тут ситуация была такая,
вот в S есть E,
у E нет spaceship, а мы все равно хотим
дефолтный spaceship.
Разрешается это следующим алгоритмом,
что те классы, у которых нет spaceship,
мы сравниваем либо вот так,
если запросили strong, либо так, если weak,
либо так, если partial. Обратите внимание,
в случае partial, а тут два раза
на меньше проверяются.
Прикол, да?
Ну да, да, типа там, если...
Я искренне молюсь, что нет.
Тут задумано, что это legacy класс,
у которого есть вот эти операторы меньше
и равно.
Тогда это не просто legacy,
это то, что нужно сжечь.
Это ересь.
Если происходит, то это просто вообще убой
и застрелись.
Возможно. Давайте перейдем
к морали или еще какой-то вопрос.
Хочу закончить со spaceship.
У нас вот в legacy классе,
у которого вот по такому алгоритму
является spaceship,
у него внутри флоты,
и я скажу ему strong ordering.
Он же проверит, он нормально все сделает.
Да, да.
Это же фигня. Да нет.
Предполагается, что ты legacy код тоже писал,
когда в здравом эме был,
поэтому ты там придумал, как гарантировать,
ну, заглянув в будущее, что там потом
будет важно сохранять равенство
и иметь полные порядки,
ты как-то продумал, что должно в случае
nano происходить, что там никакие
приватные данные наружу не улетают,
если это не так, то в принципе
оно тоже в целом все будет работать,
но можешь ждать сюрпризов.
Нет, вот в случае, когда legacy,
ты по legacy классу
не можешь понять, какой
ordering на нем. Вот в чем соль.
Поэтому надо явно ordering указать,
авто здесь написать нельзя уже.
На самом деле нет, это просто такая
человеческая абстракция
про то, какие бывают типы
сравнимых классов.
Это категории сравнения классов.
Вот так же, как выражение делится
на lvalue и rvalue, классы,
для которых определено сравнение
в каком-то резонном смысле, делится
на три категории, weak, strong, partial.
Это в человеческом понимании.
А в коде мы пытаемся сделать так,
чтобы все, что происходит, соответствовало
нашему пониманию.
Получить
ordering
без оператора spaceship нельзя.
Это единственный
способ сказать, что
за ordering твоего класса.
Это намеренно так сделано, чтобы нельзя было
просто пойти и какому-то старому
legacy-классу через какой-нибудь trait указать,
что ты на самом деле strong.
Это специально не сделали.
По-моему, я надеюсь.
Давайте дальше
пойдем к уже
итогам. Дельные советы
про то, что
надо делать и что не надо делать.
Это старый
совет, такой вы уже наверняка
видели.
Не надо пытаться выпендриваться, использовать
операторы сравнения для каких-то своих классных
monads или еще чего-нибудь такого.
Только сравнивать.
Человек пишет меньше, он не ожидает,
что это будет какая-нибудь функциональная операция,
какого-нибудь бинда, кого-нибудь куда-нибудь.
И все они должны быть определены,
всегда.
Ну да, то есть
либо сравнить можно только на равенство,
либо на все операторы, либо
вообще нельзя сравнивать. Три варианта
других не надо делать, пожалуйста. В современном
мире это выливается в то, что вы либо
определяете только оператор равно,
либо определяете только оператор
spaceship,
по идее. Но
в компиляторах бывают баги, которые заставляют
вас и равно тоже определить.
Я сталкивался в прошлом году.
Идет ли у нас запись?
Идет.
Я думал, что это специально,
то есть на равно же можно,
если у нас скажем два вектора, можно очень быстро
на равно сравнить просто по сайту.
Что? Как?
Как?
Надо пройтись по обоим векторам,
чтобы их на равно сравнить.
Да, но если мы сразу видим,
что сайты неравны, то можем быстро
по сравнению.
Возможно,
возможно.
Опять тонкий момент.
Ну равно должен переписываться через spaceship,
а он не переписывается через spaceship.
Стоп, что я говорю? Вы помните
табличку?
Все переписывается через spaceship.
Нет, равно не переписывается.
Равно не переписывается через spaceship.
Да, все.
Да, это выкинули.
Вот, у меня осталось небольшое
отложение с прежних лет.
Да, надо писать либо только
оператор равно, либо и spaceship, и равно.
Все. То есть через spaceship
понимать равенство можно,
но не стоит, потому что вот пропиров
только что сказали с размерами, да.
Все абсолютно верно. Поэтому да,
не требуется насильно.
Да, вот это. Все, что вы сравниваете
должно быть под множеством того, что вы
копируете. То есть если
вы делаете какой-то оператор копирования
у своего типа,
и что-то, что вы используете в операторе
сравнение не копируете,
то вы очень быстро получите нарушение
стронгордеринга.
Из-за вот этих свойств сохранения равенства
там все полетит, так делать не надо.
Почему под множество, а не все
и ровно все?
Потому что у вас может быть какой-нибудь
кэш, который
не особо влияет на что-то,
но он просто есть.
Используйте стронгордер.
Вот эта вот строчка называется
переводится на русский как
используйте только стронгордер.
Дефолтный оператор всегда предпочитает
в 99% случаев их достаточно,
потому что вы объявили какую-то структуру
просто чтобы как-то данные сгруппировать,
теперь там в мап понадобилось
или в сет засунуть.
Вам все равно, что там происходит, какой
оператор, ну дефолт прекрасно.
Ну вот в случае точек
геометрических фигур
и прочего, где у
объекта нету естественных
порядка на них,
вообще не надо определять спейс шип.
Тут, по-моему, тоже где-то было.
Ну во-первых, вот это.
Я тут говорил про мапчик, сетик,
определите дефолт спейс шип и все хорошо,
нет. Не надо определять на самом деле
спейс шип, только потому что вы хотите
в мап или в сет засунуть что-то.
Тут опять идет апелляция к
человеческой логике.
Вот вы когда видите, что
экземпляры класса можно сравнивать,
вы ожидаете какой-то адекватный порядок.
Лексикографический порядок на всем
подряд он может быть неадекватным
в большом количестве случаев.
Для точек на плоскости
лексикографический порядок он неестественный.
Про комплексные числа
не зря говорят, что их там невозможно упорядочить.
Потому что так и есть, и вот с
человеческого понимания нормальный порядок
это не лексикографический.
Сетили по полярному углу весьма-весьма
и он... Ну у тебя все равно это
будет не нормальный порядок,
а с отношением эквивалентности.
Это будет викордер как раз.
Вот если ты по полярному углу
сортируешь комплексные точки,
комплексные числа,
это будет викордер.
Потому что у тебя на одном
луче может лежать много-много
точек, которые...
То есть сначала по полярному углу, потом по
расстоянию. Окей.
Все равно непонятно...
Все равно непонятно, является ли это
естественным каким-то порядком для них.
Можно дружить ли далее
с какими-то другими операциями?
Полезно ли это на практике? Но вот окажется, что нет.
А поэтому не следует
брать и впендюривать во все классы подряд
дефолтные операторы-сравнения
и вообще операторы-сравнения.
Лучше бы напишите компаратор отдельный,
прокиньте его руками в
сам мапчик или сам сетик.
Потому что кто-то другой, кто начнет пользоваться вашими структурами,
он может не ожидать таких
странных порядков.
Порядки должны быть такими
естественными.
Если...
В каком-то смысле мне кажется,
что в случае с флотами,
тот порядок, который по умолчанию
встроен в свой язык,
он...
ну...
внесть к тому, что мы
должны вводить
свой оператор равно, который там
учитывает небольшие смещения.
В этом случае какой-то совет есть?
Нет, так
правильно все.
С флотами все правильно сделали,
потому что флоты по своей
природе это
не действительные числа и даже не рациональные.
Это хитрая конструкция.
И чтобы корректно с ней работать,
нужно понимать, что ты делаешь,
понимать, с какой погрешностью ты работаешь
и брать эпсилон меньше этой
погрешности.
Это все вопрос просто и вычмотов такой.
И если в языке просто за вас выберут,
что мы будем сравнивать
флоты с точностью
1e-7.
Но это будет невозможно использовать
на практике.
Что вдруг у вас числа как раз близкие к 1e-7,
и вам там вот чуть-чуть не хватает,
а они там... зазор взяли слишком
большой.
Ну или наоборот. Вдруг у вас огромная
погрешность, и вам все-таки хочется сравнивать
с точностью до 1e-3.
Ну и сами же флотания не
равномерно распределены?
Тоже, тоже, да.
Тут просто нет хорошего числа, чтобы выбрать
с какой точностью. Поэтому решили
во всех языках ничего
не делать с этим.
Тут два пункта еще.
Вот это вообще непонятный пункт.
Третий.
В целом не используйте просто викордеринг.
Он как бы есть для некоторых
особых случаев нужен, но лучше
избегать.
Ну как бы да, но лучше всегда
самое хорошее, потому что
что ты с паршал порядочной штукой
сможешь сделать?
Ты даже посортировать не сможешь.
Но вообще как бы
флоты ты можешь посортировать, потому
что там всегда через вот эти вот
синт три вей
штуки. Это кажется старый термин.
Короче, вот эти шесть функций, которые мы
видели, половина из которых fallback,
половина обычная. В обобщенном коде
надо вот не spaceship, а их использовать.
И будет все хорошо.
Да, да.
Но если вы хотите запретить legacy, то можно без
fallback. Вдруг вам так надо.
Вот тут был совет
про то, что надо
операторы сравнения делать
свободными функциями, а не методами.
Какой-то фиговый совет.
А, ну там про разные типы было, да?
Про разные типы,
что там... Привитения
какие-то.
Да, ну теперь из-за синтеза все хорошо,
но я скажу, что и это все фигня.
И вот это
тоже фигня.
Надо делать friend-off.
Да, кстати,
я там выше объявлял
friend-off прямо внутри класса.
Это не смутило?
Вы такое видели уже?
Давайте я найду.
Нет, я хочу, чтобы определение было.
Не только объявление, но и определение.
А тут не хватает ключевого...
А, нет, да.
Так, черт.
Ладно, короче,
можно вот прям здесь объявить
саму функцию.
Это ее определение, а можно ее объявить
прямо здесь. И вот этот способ
я считаю оптимальным. А почему
чуть попозже узнаем...
Так, давайте все.
На этом же у нас кончились приколы.
А, ну тут вот вообще
никогда не используйте
partial ordering.
Все знают, что с такими типами делать
и куда их засунуть вообще можно.
Ну, возникает вопрос, опять же,
зачем стандарт добавили?
Но, вероятно, кому-то это очень нужно было.
О, сейчас узнаем,
почему про friend-off хорошо.
Надо только посмотреть на время.
Мы сколько здесь уже?
Час 45.
Наверное, время перерыва.
И дальше нужно будет...
Да, давайте перерыв
50 минут.
55, окей.
Перерыв, и потом возвращаемся.
И нам надо голопом по европам, чтобы еще
код пописать.
Что-то как-то затянулось.
