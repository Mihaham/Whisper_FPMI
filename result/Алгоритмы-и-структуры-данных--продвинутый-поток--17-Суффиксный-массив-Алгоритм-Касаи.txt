Ну, мы, напоминаю, да, мы снова живем в мире, в котором у нас основная цель решить задачу вида дан текст,
и нам даются какие-то подстроки П, и надо для каждой П в онлайне желательно за быстро,
за П или чуть-чуть помедленнее пытаться отвечать на всякие вопросы. Всякие вопросы будут в духе,
входит ли это подстрока в текст, так как подстрока да или нет. Один из вариантов возникает, конечно же,
суффиксной массив. Что же это такое? Ну, и здесь определить его очень просто. Это, пожалуй,
самая простая такая структура, на самом деле. Вот, допустим, строим, как говорится, по классике,
для строки АБОЦАБО. Значит, у нее, ну, какие суффиксы у нее есть? Ну, помимо пустого суффикса,
у нее есть, значит, суффиксы, соответственно, там суффикс номер 6А, суффикс номер 5ВА,
суффикс номер 4АБА, суффикс номер 3ЦАБА, суффикс номер 2АЦАБА, суффикс номер 1БЦАБА,
и суффикс номер 1АЦАБА. Заведем, что эти суффиксы мы, в принципе, можем и отсортировать
и психографически. Вот, давайте их отсортируем. Вот, при этом даже, ну, как мы их нарисуем? А давайте
так нарисуем. Вот, если мы их отсортируем, что будет? Будет А, будет АБО. Вот, дальше что у нас там будет? АБЦАБА,
соответственно. Так, что там дальше? АЦАБА, соответственно. Так, еще будет... Ну, дальше, вот,
наконец, начались строчечки с буквы Б, ну, и быстро заканчиваются их тут всего две. Ну,
а строчечек начинающих с буквы С вообще одна. Вот. Ну, и самое теперь приятное, что можно сделать,
это не выписывать сами суффиксы, а оставить только циферки. Получился такой массив,
такой перестановка чисел от 0 до N-1. Да, в этом мире, как вы уже поняли, мы живем в 0 аддексации.
Вот. Ну, и получается вот такая перестановка чисел от 0 на длинной строке минус 1. И это и есть суффиксный массив.
Суффиксный массив.
Опа. Собственно, да. Запомните, вот здесь не сложно. 640, 25, 13, звоните. Вот. Значит, ну, вот. Чем он
нам может помочь? Ну, на самом деле, да, помочь он может вот чем. Ну, опять, уже, как минимум,
если вы этот суффиксный массив уже построили, то на самом деле, если вам приходит какая-нибудь строка
фет, и вы ее где-нибудь ищете, то, ну, по крайней мере, то вы пытаетесь найти там, есть ли у нее вхождение,
то, ну, как минимум, за время O от, допустим, P на, соответственно, log s, в принципе, ее вхождение
или их отсутствие найти вполне себе можно банальным, без поиска по ответу. Правда? Ну, даже если у вас
есть только сам массив, потому что, ну, понятно, что с самими суффиксами, если у вас есть сама строка,
то для не самых больших текстов, в общем-то, этого уже хватит. На самом деле, особенно если учесть,
что вам реально O от P, на самом деле, не в сильном многих случаях будет происходить. Ну, вот. Ну,
на самом деле, конечно, если использовать какие-нибудь, может быть, какие-то более
продвинутые штуки, то, может быть, у нас, вот, мы посмотрим, получится и что-то побыстрее. Что-то
побыстрее. Вот. Что же это за более быстрые штуки? Да, пожалуй, знаете, мы пойдем немножко неожиданным
таким путем. Мы сначала попробуем что-то с суффиксным массивом сделать, а потом в конце
мы его попробуем построить. Ну, тем более, что алгоритм, который мы будем использовать,
он там относительно черный ящиковый. Вот. Вот, допустим, у нас есть черный ящик, который там
с небес по факсу присылает нам суффиксные массивы. Что с ним можно еще делать? Вот. Ну,
еще с ним можно делать следующее. Вот у него есть такой красивый нападник. Будем его даже похожим
делать. Значит, ну, и здесь мы ведем такое определение. Да ладно. А, ну ладно, если уж нападник,
то нападник. Ну, нападник у синего цвета, наверное, логично. Так. Так. Вот. Определение.
Допустим, пусть, вот я сейчас абстрактно напишу, x и y это произвольные строки.
Тогда ведем такое понятие, как Lcp от x и y. Это будет равно максимуму такого l,
что x от 0 до l-1 равен y от 0 до l-1. Упражнение на знание английского языка. Как расшифровывается
аббивиатура Lcp. Да. Ну, или логист. Вот. Логист. Вот. То есть, видимо, да, такое понятие мы
видели для произвольных двух строк. Вот. Ну, а теперь можно. Мы ведем теперь мистический массивчик
Lcp. Будем говорить, что пусть у нас это s строка, s равно, естественно, s от 0 до l-1, допустим,
и что-то еще. Вот. А, ну вот. Ну, допустим, а. Допустим, sa. Ее суффиксный массив.
Тогда мы введем такое мистическое понятие, как. Тогда, значит, мы введем такой массив Lcp от 0 до l-2.
А. Это массив чисел. Такой, что. Lcp и t. Вот. Это будет равно Lcp двух суффиксов. Каких? Ну, соответственно,
стоящих в и-той позиции и в и-плюспе. Вот. Формальное определение может выглядеть так.
Вот. Это называется массив Lcp. Вот. Вот такой массив там. Ну, теперь нулевой элемент. Чему равен? Ну,
давайте посмотрим. Нам нужно посмотреть на суффиксы a и aba и найти у них наибольший общий
префикс. Он очевидно равен единиц. Вот так мы нарисуем. Здесь он будет равен троечке.
Здесь он будет равен единичке. Здесь ноль. Вот. Здесь два, здесь ноль. Тринадцать, десять, двадцать.
Ну, давайте пониже чуть-чуть нарисуем. Ну, здесь все просто. Вот. То есть, ну, на самом деле сам по
себе суффиксный массив используется крайне редко. Обычно вместо использования суффиксного массива
подразумевают, что используют суффиксный массив плюс вот эту, ну плюс вот этот мистический
массивчик. Вот. Что можно с ним делать? Ну, в первую очередь заметим, в первую очередь заметим,
что если у вас есть суффиксный массив и еще есть Lcp, сам по себе этот массивчик Lcp, то на самом
деле вы можете пытаться что сделать? Вы на самом деле можете пытаться искать Lcp у произвольных суффиксов.
Как это делать? Ну, на самом деле оказывается, но тут важно окажется такое достаточно простое,
но того не менее фундаментальное утверждение. Мы говорим, что пусть у меня ноль меньше либо равно,
допустим, и меньше g меньше модуль s. Вот той самой s. Я уже не буду переписывать,
что s там это строка, там s i и суффиксный массив. Тогда утверждаю я. Значит, Lcp,
вот тут надо аккуратно, аккуратно. Lcp суффиксов, стоящих на итой и житой позиции,
равен, оказывается, минимум из таких величин, как Lcp it, Lcp i plus 1 и так далее.
Далее до Lcp g минус 1. Вот такое внезапное утверждение. Откуда же оно бегается?
Ну, бегается оно из достаточно простого. Вот, допустим, давайте нарисуем какой-нибудь
абстрактной суффиксной массив. Вот тут какие-то суффиксы. И между ними есть какие-то вот эти
вот Lcp. Вот. И, допустим, там мы хотим найти Lcp между, допустим, вот каким-то, ладно,
можно с краю, вот этим и вот этим. Вот у них есть вот этот вот минимум.
Пришел какой-нибудь запрос, давайте извне. Ну, давайте, раз пришел извне,
давайте еще и цвет какой-нибудь извне пробуем. Так, вот сегодня все цвета одинаковые какие-то.
Так, смотрите. Так, то есть тогда что мы видим? Ну, мы видим, что если рассмотреть минимум,
то мы обнаружим, что Lcp между этим и этим не меньше, чем вот этот минимум. Почему? Ну,
потому что вот если этот минимум равен, допустим, там z, то мы видим, что первые z символы совпадают
у этого и этого, у этого и этого, у этого и этого и так далее. То есть получается у этого и этого они
совпадают. Вот. Что нас дальше? Ну, тогда, ну, может быть, Lcp между ними больше, вдруг следующие
символы совпадают. Ну, тут, на самом деле, два варианта. Ну, во-первых, в первом случае может
оказаться, что у какого-то из суффиксов на отрезке, ну, во-первых, то есть утверждение следующее,
что заметим, что так как у нас первые z символов совпадают, то суффиксы на этом подотреске
отсортированы по z плюс первому. Логично, да? Вот. Ну, электрографически порядок так устроен. Ну,
тут два варианта. Во-первых, может, конечно, так случится, то есть надо взять и рассмотреть
случаи, когда, может, на одном из этих суффиксов просто нету этого z плюс первого символа. Ну,
тогда легко убедиться, что это вот это вот он и есть. И тогда Lcp точно ракуло z и ничему охраня. Но если
все эти символы z плюс первые существуют, то тогда получается строки у нас откровенно отсортированы
но раз они отсортированы и где-то вот существует ситуация, когда z плюс первые символы не равны,
значит, получается, что в начале и в конце они тоже равны. Вот так вот примерно может выглядеть.
Доказательства, действительно, ничего сложного тут нет. Ну, что это нам теперь дает? Это нам
теперь дает маленькую приятную, то есть маленькую приятную возможность убедить считать Lcp для
произвольных суффиксов. То есть вам остается только там, то есть что можно сделать? Ну, во-первых,
нужно, ну, конечно, там надо найти, конечно, к суффиксовому массиву обратную перестановку,
чтобы там для каждого суффикса находить, где он в суффиксном массиве находится, но это легко.
Ну, самое интересное, конечно, что вам останется только написать какую-нибудь интересную структуру
данных, которые на статическом массиве ищут минимум на отрезке желательно за 1. Ну,
на практике там используют sports table, ну, вот, но чисто в теории, если мы хотим какого-то
мистического идеала, то у нас есть всегда алгоритм фараф полтон блендера. Ну, и так,
если мы мечтаем, что мы все, что мы тут сказали, мы построим за линию.
Но, правда, даже если мы все это построим за линию, то вот, тогда, если какая-то вопрос, как же это
использовать, ну, вот, например, как мы, например, могли бы с помощью суффиксного массива искать
подстройки в строке. Вот так это сделать. Вот у нас предлагается такая не очень приятная
асимпточка PLOGS. Можно ли ее как-то улучшить? Как бы ее улучшить? Вот, но, на самом деле,
я утверждаю, что, действительно, ее можно улучшить до асимптотики. Вот, мы попытаемся решить за PLOGS.
Казалось бы, а без PLOGS-а нельзя, может быть, с суффиксным массивом, с суффиксом деревья умели
без PLOGS-а. Но есть мистический факт. На самом деле, не особо-то и умели. Потому что мы там,
потому что тут, на самом деле, в суффиксном массиве возникает тоже, действительно, такая интересная
мысль. Вот, действительно. Вот мы с вами, конечно, живем обычно в мире, когда у нас размер алфавита
конечен. Ну, там, конечен, причем, сильно ограничен, типа, 1, 2, 26 константа. А теперь возникает
вопрос. Предположим, что у вас строки состоят из тех самых камешков, которые мы умеем только на
весах сравнивать. И при некоторой камешке эти весы могут говорить, что они, оказывается, равны.
Вот, внимание, вопрос. За какую асимптотику мы тогда, в лучшем случае, можем построить суффиксный массив?
Обе стройники.
Вот, можно ли, действительно, построить тогда суффиксный массив быстрее, чем ZS log S?
Вот, то есть, смотрите, какая интересная подлянка. Что, оказывается, что если бы у нас, действительно,
были рандомные камешки, то, оказывается, быстрее, чем ZS log S, нельзя, потому что тогда сортировку массива
из N различных камешков можно свести к построению суффиксного массива. Да и неразличных тоже,
в общем-то, можно построить суффиксный массив, потом пробежаться за лигию, проверить, кто там,
кому равен, а кто там, кому нет. Вот такая вот неожиданная мистика. Ну, с другой стороны,
с другой стороны, погодите, погодите, суффиксный массив же очень легко строится за, на самом деле,
линию. Смотрите, мы за линию построим, вот давайте так, возьмем эту строку S, припишем к ней диезик
и построим суффиксное дерево. Вот мы же в прошлый раз умели его строить за линию, было дело?
Было, да? Не, не, я помню, это мы были в прошлый раз. То есть, нет, когда там это были,
то есть, может, это были там 5 других человек, но нет, не тот случай.
У нас там был же этот лог Уфовита, да? Да, вот действительно, тут вот действительно очень...
А с этой там, видимо, лого Толкувили превращается в лого ТЭЦ. Ну да, да, именно, именно. То есть,
вот обратите внимание, да, что, а, вот тут уже не надо договаривать, каким образом бы суффиксный
массив у собственного дерева был бы, да? Ну, я на всякий случай скажу. Да, понятно. Может быть,
для обойти порядка. Ну, понятно, да. Ну, а зачем я вставил диезик? Ну, потому что иначе мы будем
не очень... Ну, потому что нам это нужно для суффиксного... А зачем нам это нужно? Для удобства мы
делали, добавляли диез в конец. Для какого? Зачем? Чтобы у нас все эти суффиксы были листьями.
Заканчиваются листьями. Во, именно. Да, потому что идея у меня была такая, построим суффиксное
дерево, заметим, что теперь все суффиксы будут заканчиваться в листе, ну и при этом, если диезик
меньше, будем считать это символ, который меньше, чем все, что в строке есть, то тогда порядок конкретно
вот этих суффиксов не поменяется никаким образом. Вот. И тогда, оказывается, после этого нам останется
только пройтись по, действительно, нашему дереву ДФСиком и, в общем-то... Ну, понятно, мы с помощью
на дереве можем хранить глубину строки, в которой мы находимся и, собственно, вывести. Вот. Ну, вот тут-то
и вылезает. Оказывается, что у нас там, на самом деле, мы строили не за линию как таковую, а за линию на
логарифму алфавита. Или, если бы вы заменили мапчик на массивчик, то это было бы за, там, линию умножить
на алфавит по памяти. Вот. Так что здесь, получается, вот надо аккуратнее. То есть, на самом деле, логарифм там
тоже вылезает. То есть, на самом деле, если мы строим суффиксное дерево для камешков, то, как бы, тоже
придется смириться с тем, что это, наверное, SlogS. Ну, то есть, реальность может быть и побыстрее, но, по факту,
ну, побыстрее, чем за SlogS не получится, потому что с помощью суффиксного дерева сортировка вполне
возможна. А, ну и, кстати, в качестве добивочки еще заметим, что с помощью суффиксного дерева,
в статье ЛЦПшки вас выкладываются достаточно бесплатно. Вот. Поэтому, на самом деле, P plus SlogS
это, на самом деле, не самая плохая ассетточка. Ведь, кстати, если по этой логике вдуматься, то на камешках,
на камешках, вообще-то, мы и в суффиксном дереве эти вхождения тоже за эту ассетточку ищем.
Потому что в каждой вершине-то вы там лезете в маточку и за SlogS ищете соответствующий камеш.
Вот. Так что, на самом деле, не такая уж плохая ассетточка. Вот. И вот это, что же с ней можно сделать.
Значит, ну, как вы догадываетесь, SlogS, конечно, все еще подразумевает бинарный поезд-падвит.
И делать мы это будем так. Значит, вот у нас есть снова какие-нибудь вот эти вот это вот штуки все.
Ну, я не буду там предполагать, что там кто-то из них вот какие-то. И, ну, допустим, мы тут находимся,
вот бин поезд говорит нам, что ответ где-то вот это у нас L, вот это вот L, это вот L.
Ну, что означает L? Это означает, что L у меня меньше, чем P, а R, то есть вот этот суффикс меньше,
чем P, а этот суффикс больше, чем P. Да. Сейчас мы для простоты будем просто отвечать на вопрос,
существует ли такая подстрока, да или нет. Ну, понятно, что если мы хотя бы один суффикс,
начиная сейчас с P, найдем, то есть у нас будет задача там найти все или там их количество,
то там тоже там бин поездка с помощью вот этой вот всей черной магии, собственно, мы найдем без труда.
Вот. Так вот. Значит, в качестве варианта еще будет важный момент, что мы будем хранить такие зелено-рыжие
вещи, как LCP-L и LCP-R. Вот. Так вот. Догадывайте по цветовой хайме, что это такое.
Ну, с этим суффиксом, суффиксом массива, да, LCP-L это равно, просто да, пишем, вот так и пишем прямо,
LCP от строчи P. Ну и, соответственно, так нет, побольше. Так. Ну вот. Ну и здесь, соответственно,
вот тут S, конечно, M-L. Вот. Ну и здесь я уже не буду переписывать, но вместо, так также есть LCP-R,
и здесь абсолютная копия завыччена того, что вместо L тут допишем L. Да, и мы будем такие штуки поддерживать.
Так. Ну давайте этот суффикс мы тоже подлиннее нарисуем. А перечка. Ну вот теперь что говорит
там бинпульс? Бинпульс там говорит, ага. Так. Вот возьмите какой-нибудь мид. Вот. Вот. Возьмите
какой-нибудь мид. Ну и в смысле захватить Смоленскую площадь, конечно, да. Вот. Ну вот. А возьмите
суффикс посередине. Вот. И, соответственно, ну, и скажите, пожалуйста, ну во-первых, найдите LCP-MID,
а во-вторых, скажите, пожалуйста, а в какую сторону вообще надо двигаться. То есть этот суффикс больше
или меньше. Ну что можно сказать про LCP-MID? Ну да, давайте рассмотрим в случае, когда,
то есть предположим, что LCP-L меньше либо равно LCP-R. Почему мы так можем предположить? Ну потому
что если LCP-L больше, то мы будем делать то же самое, что скажем дальше, только симметрично. Вот.
Тут, в общем-то, не принципиально. Итак, LCP-L у нас меньше либо равно LCP-R. Что мы тогда можем сказать?
Тогда у нас сразу возникает мистическое утверждение о том, что LCP-MID, наверное,
больше либо равен LCP-L. Нет такого ощущения. Да. Ну и в какую сторону тут тогда, естественно,
мыслить? Мыслить, естественно, такое. А давайте-ка, начиная с LCP-L, будем насчитывать LCP-MID в тупую.
Ну потому что будем насчитывать, насчитывать, насчитывать и насчитывать, и все. То есть насчитали,
ну и тут соответственно за одной быстренько выяснили, куда идти налево или направо. Вот такой
простой алгоритм. Пока не начнешь думать, за какой симметричкой он будет работать.
Вот как бы показать, что он, ну действительно, казалось бы, работает хорошо. Потому что идея,
он должен работать до Log S на бинпуиске и нод P на увеличение самих LCP-L или LCP-R,
которые у нас типа не уменьшаются. И каждый шаг, казалось бы, кого-то из них доувеличивает.
Так мы определяем, где будет сам P, то есть мы не ищем максимум LCP, мы просто пытаемся понять,
вот с P он будет находиться от L до MID или от MID до R, а мы это понимаем, смотря на следующую
букву, после конца LCP в MID. А если она меньше, чем то, что в P, нужно идти направо, если больше,
то в лево. Это вроде понятно, почему работает. Ну да, почему именно работает. Почему за нормальный
субточек. А к чему? У нас можно посмотреть на сумму LCP-L и LCP-R. Каждая такая операция увеличивается на 1,
а не превосходно 2 LCP-R. Ну да, казалось бы. Но я утверждаю, что где-то здесь закралась одна маленькая подлянка.
Я постарался обмануть, еще правильную картинку нарисовал. Хорошую картинку, красивую. Хотя и на этой
каким-то уже на самом деле есть одна подлянка, уже может быть и на некую подлянку.
Если, например, LCP-MID оказался меньше, чем LCP-R, и мы пошли налево, то у нас сумма уменьшилась. Да.
Ну вот, действительно, первая проблема. Казалось бы, давайте предположим, что LCP-MID не дошел до LCP-R,
и не просто не дошел, а выяснилось, что мы после этого еще и пошли влево. И тогда сумма LCP-R уменьшилась.
Казалось бы, алгоритм обвалился. Но такого, кажется, не бывает. Да, но только замечаешь,
что такого не бывает. По одной простой причине. Дело в том, что, смотрите, если он вот дошел
так куда-то вот до сюда, то тогда мы обнаруживаем, что вот этот символ совпадает с очередным символ
строки P, а этот символ меньше. И тогда получается, что мы, раз уж мы тут сдвинулись, то мы как бы
в этот подотрезок и пошли. Получается, да, такого не бывает. То есть, если мы тут уже шли, шли, шли,
шли и не дошли до LCP-R, то мы точно пойдем вправо, и получается, просто LCP-R на эту величину увеличивает.
Но есть еще одна проблема все равно. Какая? Даже если MID он оказался большой, но мы пошли влево,
то у нас сумма увеличилась на LCP-MID минус LCP-R. Да, вот смотрите, если внимательно посмотреть,
если мы дошли до LCP-MID, который прямо далеко за LCP-R, то на этот раз могло оказаться,
что мы все-таки пошли влево. Обратите внимание. Кажется, что нам не помешало бы, если мы могли быстро,
но вот именно LCP-Suffix, тогда все работало бы. LCP-Suffix. Ну да, ну на самом деле, то есть идея такая. То есть,
действительно, может так случиться, что мы пойдем вправо, и тогда заметим, что мы тут, то есть,
мы вот эти вот LCP-R минус LCP-L, как бы в монетках не учили, можно сказать. Но идея очень простая,
на самом деле. Вот этот вот первый шаг до LCP-R, на самом деле, мы можем сделать за О от единицы,
если у нас есть суффиксный массив, есть LCP-шки, и на них еще этот фаров Colton Bender. Ну или там,
я не знаю, эти ваши спорсы. То есть, тогда мы просто за, как бы, если, то есть, как бы, ну вот, то есть,
минимум из LCP-MID и LCP-R, мы можем на самом деле теперь найти за О от единицы, банально,
найдя LCP между этим суффиксом и этим суффиксом. Если он хотя бы LCP-R, значит и тут можно
строктовать LCP-R. А если нет, то значит, тогда мы прям за О от единицы тут еще и понимаем, кто он.
И у нас вариант, что сумма LCP-L и LCP-R увеличивается постоянно? Ну да. То есть, да, она увеличивается,
причем, видите, увеличивается, в чем каждый шаг в тупую увеличивает ее. Нет, ну вот. Ну да,
тем более, да, у нас, да, еще это отдельное дополнительное доказательство, что, да,
эта сумма не уменьшается. Да. Совершенно верно. Так что получается красота, и вот получается,
за P плюс лог С оказывается, строку P вполне найти можно. Ну и почему-то возникает жуткое подозрение,
что быстрее, скорее всего, и нельзя. Ну потому что, опять же, если у нас рандомные камешки,
то быстрее нельзя. Ну, конечно же, если нот. Ну, с другой стороны, а если бы на нот, правда,
можно задуматься о другом. А если у нас все-таки массив константного размера? А, ну что тогда?
Тогда можно было бы, конечно, сказать, давайте уже построим суффиксные деревья и не будем париться.
И, на самом деле, я скажу даже, давайте. Сейчас есть ли массив константного размера? Альфавит константного
размера. То есть можно построить суффиксное дерево. То есть, ой, это надо Этого Ука не написать, да. А теперь
еще один мистический факт. Как, на самом деле, ищется суффиксное дерево? То есть, на самом деле,
я утверждаю, что если у вас есть суффиксное дерево и ЛЦПшки, то суффиксная массив, то суффиксное дерево,
вы можете построить на халяву. Ну, вообще говорят, да. То есть, по большому счету, да. То есть,
фактически, вот если вкратце здесь пересовываем просто протокол, то есть, где от каждого суффикса
должен затвитвиться следующий. То есть, там, коре, то есть, по идее такая. Здесь есть суффиксная массив,
есть ЛЦПшки. Что вы делаете? Вы рисуете первый суффикс. Значит, вот в нашем случае это будет суффикс,
допустим, вот от 6 до 7 по группе А, да. И находитесь теперь вот в этом листе. Теперь, суффикс АВА. Так, он
должен отвитвиться от этого на глубине 1. Так, мы находимся на глубине 1. Поэтому все, что мы
делаем, это рисуем тут по букве В, переход, значит, по, значит, 5-7. Да, мысленно подразумеваем,
что тут буква А, а тут буква А. Так, мы находимся на глубине 3. То есть, да, полезно находиться именно
вот на глубине, где мы только что остановились. Так, теперь нужно отвитвиться на глубине 3. Так, мы
находимся на глубине 3. Ой, кайф какой. Так, ну отлично. Рисуем переход по букве С. Там, соответственно,
3-7. И, в общем-то, то самое. Итак, мы находимся на глубине 7. Теперь надо отвитвиться на глубине 1. Так,
мы находимся на глубине 7. Ой, слишком глубоко. Так, скачиваем наверх. Эта вершина находится на глубине 3.
Так, глубоко идем. Эта вершина находится на глубине 1. О, подходит. Ура. Значит, от этой вершины мы
отвитвляемся и строим опять, значит, букву С. Тут, соответственно, 3-7. Ну и, соответственно, тут какая-то цала.
Так, следующий. Отвитвляется от предыдущего на высоте 0. Вот, ну здесь понятно. Так, здесь мы на глубине 5.
Это много, здесь на глубине 1 много, здесь на глубине 0 кайф. Значит, пишем букву В. Там пишем 5-7. Радость В.
Вот, и мы на глубине 2. Так, теперь надо отвитвиться на глубине 2. Ну вот, 3-7. Так, и теперь надо
отвитвиться на глубине 0. Ну, подымаемся, подымаемся. Да, то есть здесь, на самом деле, не самый показательный
пример, потому что, в принципе, конечно же, на самом деле, в других строчках могло возникнуть так,
что вам придется посредине либра отвитвляться и ту самую новую вершину создавать. Могло быть такое. Ну,
такой самый типичный пример. Это, на самом деле, строка, например, ААААБ. Тогда здесь будет происходить
так. Вы сначала нарисуете вот это вот АААБ, потом говорите, так, следующий должен отвитвиться на
глубине 6, а вы находитесь на глубине 8, поэтому тут где-то в районе двух символов придется распилить и
собственно по букве В переход отправить. Теперь от него надо, соответственно, отвитвиться уже на
глубине получается 5. Тогда идем так. Здесь это глубина 7 много, это глубина 6 много, вот где-то здесь
глубина 5, строим вершину, двигаемся, ну и так далее. Понятен принцип, да? Вот, но важно, но как бы
почему мы строим, как бы находимся именно там, где мы закончили, потому что получается, что вы это
сделали за линию, ну там, за линию умножить на сколько вы там с мапочками работаете, естественно,
хотя пока вы строите, можете просто push back на самом деле. Вот, и тогда, ну вот, и тогда получается,
что вы фактически сделали такой красивый твест по этому дереву, и получается это работает за линию.
Так что, картинка называется, как на самом деле строить стуфиксное дерево за линию. Ладно, правда,
заговор. Для этого вам придется откуда-то взять стуфиксные массивы за линию. Ну да, в принципе,
часть этих применений на самом деле можно так и выкинуть, да, как решать задачи с помощью
стуфиксного массива. Так, есть стуфиксный массив, есть ЛЦП, так, строим дерево, решаем с деревом,
все. На уровне идеи, в принципе, дальше можно не думать. Ну вот, но с другой стороны, хотя,
как минимум, под строки в строке, может быть, где-то даже чуть-чуть быстрее. Сколько у нас там времени?
Ну, соответственно, давайте смотреть, что же тут тогда, значит, как же это все, из какой магии
находить. Ну да, у нас не так много времени, поэтому давайте смотреть. Ну, начнем с того,
что как построить ЛЦП. Ну, кроме того, что, в принципе, в некоторых местах, кстати,
так и говорят, как построить ЛЦП. Так вот, ну, начнем мы вот с чего. Мы начнем с того,
что попробуем построить ЛЦП. Так, с конца идем. Раз мы идем с конца, то как бы, ну вот,
то, итак, значит, предположим, что у нас есть строка С, и у нее есть суфиксный массив.
Суфиксный массив, я скажу. Мы очень хотим построить массив ЛЦП. Да, редкий, да, очень интересный
случай. Действительно, что этот алгоритм не привязан к построению суфиксного массива сам по себе,
значит, он вот так и говорит, дайте мне строку С, дайте мне суфиксный массив, и после этого я
вам построю этот ЛЦП за Лиги. Вот. Ну, алгоритм, соответственно, как называется алгоритм? Ну,
соответственно, по авторам. То есть это называется будет у нас сейчас алгоритм Ари Кавы, Ари Муры,
Касай, Ли и Парк. Ну, соответственно, у нас есть алгоритм четырех русских, алгоритм двух
китайцев. В данном случае как-то, ну, как сказать, ну, тут очень сложно обратить внимание. Последние две
фамилии не дают, возможно, сказать, что это алгоритм пяти японцев, а называется алгоритм пяти
азиатов как-то некорректно. Поэтому алгоритм более известен как алгоритм Касай и других. Видимо,
там Касай первым автором стоял. Причем, да, как говорят в таких случаях, да, на самом деле алгоритм,
говорит, он проще, чем его название на самом деле. Сейчас вы в этом убедитесь. Ну, как убедитесь? Ну,
поднимите руки, кто знает вообще этот алгоритм. Ну, скорее всего, не с таким названием. Да ладно. Не, не знаю,
обычно олимпийские высокого уровня это здоровье. Ну, окей, ладно, в общем, в школе он мог вам и не пригодится.
Значит, смотрите, алгоритм на самом деле очень простой. Значит, идея такая. Давайте заведем ту самую
мистическую обратную перестановку. Заведем массив P от 0 до n-1, где для любого i будет верно,
что P от SA, что SA от P-i-того равно i. Ну, короче, в P-i-том написано, где в суффиксном массиве
находится i в суффиксном. Ну, построить эту обратную перестановку, понятное, труда не составлять, мы уже говорили об этом.
Вот. Так вот, идея такая. Значит, будем строить LCP, будем насчитывать,
значит, будем насчитывать LCP в следующем порядке. Сначала насчитаем LCP от P-0, затем LCP-P-1, LCP-P-2 и так далее.
Вот, в таком порядке будем эти LCP-ки насчитывать. Вот. Насчитывать будем, как это у нас водится в теористров, в тупую.
Пользуясь мистическим утверждением. Я утверждаю, что каждое следующее LCP, если оно, конечно, существует,
это не буду совсем формально прописывать, оно больше либо равно, чем предыдущее, минус этим.
Ну, давайте подумаем, откуда же такое? Ну, во-первых, если мы поверим в это утверждение, то тогда эти LCP-ки можно насчитывать в тупую реально за линию.
Ну, потому что, по большому счету, мы начинаем с нуля, каждый шаг в тупую увеличивает нашу текущую штучку, и когда мы приплывем к следующей, мы как бы ее либо уменьшаем на единичку, либо не уменьшаем.
Магия какая-то? Все нормально, да? Хорошо. Ну вот. И тогда получается, что суммальное количество этих шагов в тупую у вас будет не более чем два, там два модуля, получается.
Логично, да? Вот. То есть код там совсем какой-то минималистический получается, остается только понять, откуда же мы взяли это утверждение.
Ну, классическая идея. У нас есть LCP от двух суффиксов, если мы уберем от них по первому символу, то...
То останется два суффикс.
То LCP не более чем на один уменьшится.
Да. Ну, давайте я сейчас нарисую и покажу то же самое.
Да-да-да-да-да. Да-да-да-да-да. Да-да-да-да-да. Да-да-да-да-да-да. Да-да-да-да-да. Да-да-да.
Ну, значит, ну вот, действительно, давайте вот предположим, что у нас жил-был и ты суффикс, то есть вот где-то на этой позиции, то есть S-А от какой-то позиции, поз.
Ну вот, sA от поидитого, допустим, да, равно И, да, вот.
Сначала был ИТ-суффикс, и было у него вот тут LCP.
Это вот будет LCP, так сказать, поидитого.
Теперь у нас два варианта.
Ну, да, как говорится, что если LCP это было равно 0, то утверждение автоматически верно и неинтересно.
Но если оно оказалось чем-то нетривиальным, то заметим, что вот у нас тут есть суффикс номер И, тут есть суффикс номер, ну, допустим, Иш-3, да.
Тогда заметим, что если мы отпилим от них этот первый совпавший символ, то получатся суффиксы номер И плюс 1 и Иш-3 плюс 1.
Так как ИТ был меньше Иш-3, то получается, что И плюс первый суффикс меньше, чем Иш-3 плюс 1.
Тогда получается, что если мы возьмем вот этот вот ПИ плюс первый, то он находится где-то заведомо левее, чем Иш-3 плюс 1.
В чем не просто левее, а LCP между ними как минимум вот это вот LCP при ИТ минус 1.
То есть вот как минимум столько совпадающих символов у них точно есть.
Но если у них столько совпадает символов, то тогда у этих двоих совпадает как минимум столько, то есть может столько, а может и больше.
Вот эти суффиксы, они подсенсированы по вырастанию?
Ну, конечно, по определению суффиксного массива.
Да, конечно. Вот и все.
Картинка-то немножко странная получается.
Каким образом И плюс 1 и Иш-3 плюс 1 не достаточно стандартны?
Нет, ну такое реально-то может быть.
Ну, скажем так.
Ну, во-первых, такое может быть, если они прямо во втором символе отличаются.
Причем этот символ меньше XA, этот символ больше XA, во-первых.
Ну вот.
А, ну а во-вторых, тут может быть в принципе, что если тут XXXXXXX и тут XXXXXXX, а вот в месте, где они различаются, тут A, тут Z.
Тогда вот так они расходятся.
В принципе, такое тоже возможно.
Ну, конечно, отметим, что рассуждение никак не привязывалось к тому, где относительно И этого суффикс находится вот этот и вот этот.
То есть, ключевое утверждение для нас это то, что вот этот суффикс находится левее вот этого. Все.
Мы только этим пользовались, обратите внимание.
А то там, знаете, есть классическая задача в башне на тему того, что до нас строка S отсактируете ее циклические сдвиги.
И найдите их, а, и найдите их в ЛЦПшке, что самое главное.
И там вот оказывалось, что аналогичного рода алгоритм там просто так не работает.
Ну, потому что там оказывалось, что если от двух одинаковых циклических сдвигов там отпилить типа один символ, да, ну или там перекинуть его в конец,
то получатся абсолютно равные циклические сдвиги и в каком порядке находятся они в этом массиве непонятно.
Вот. Ну это почему-то. Зачем я вам сапеллирую?
Можно еще раз объяснить?
Все.
Еще, еще просто какого-то.
Значит, еще. Значит, как-то, значит, смотрите.
Рассмотрим вот ЛЦП вот этого пейнтова, да.
То есть вот у нас есть суффикс номер и есть суффикс номер H3, который стоит с ним рядом.
ЛЦП между ними равно вот чему-то.
Если это, ну, если это что-то равно нулю, нам не интересно, но если это суффикс номера H3, то нам не интересно.
Если это, ну, если это что-то равно нулю, нам не интересно.
А если оно больше или равно одного, значит у них, у этих суффиксов как минимум первый символ совпадает.
Если мы этот первый символ обоих отпилим, то у нас образуются суффиксы номер и плюс один и H3, номер и ширина плюс один.
Заметим, что суффикс и плюс один, во-первых, меньше, меньше, меньше суффикса и ширина плюс один.
И ЛЦП между ними, это как минимум вот это ЛЦП минус один.
Ну как как минимум, просто разные на самом деле.
Ну так как и плюс первый меньше, чем H3, значит получается P и плюс один меньше, чем P от H3 и плюс один.
То есть и плюс первый суффикс находится в суффиксном массиве левее, ну в смысле раньше, чем H3 и плюс один.
Ну что тогда?
Ну тогда замечаем, что если вот между, у этих вот ЛЦП, типаELCPE минус один, то тогда у Этого и у Этого ЛЦП не меньше.
Ну потому что, если вот у Этого и у Этого вот столько минус один символов совпадают,
то тогда и у всех вот этих суффиксов первые, первые эти столько минус один символов тоже совпадают.
значит ЛЦП вот между этим вот этим как минимум вот столько минусы шой требовалось шой требовалось
ну потому что потому что смотрите потому что нас интересует и как бы где находится и плюс первый
суффикс то есть и плюс первый суффикс в смысле тот кто начинается с и плюс первый символ на строке
а не тот кто находится в суффиксном массиве на соответствующей позиции
ну потому что в реальности это позиция п и т а это п и т плюс 1 здесь вот и написано то
к сим ближе что с а от пи того равно и то есть давайте если если вас это смущает давайте по
другому давайте скажем что это супер с номер и это суффикс из 3 и это позиция соответственно
п и а это позиция п и плюс 1 ну да она же п из 3 вот так уже не смущает вот и все точите чем приятен
алгоритм он приятен тем что он работает за линию чем обратить внимание никаким камешком не привязан
да то есть не возникает эта линия ну в смысле ли не умножить на размер алфавита там такого
тут нет тут честные то есть поэтому да то есть поэтому алгоритм даже отдельно статья по нему
идет отдельно соответственно то есть она да но то есть как в этот алгоритм то есть это такой вот
маленький ящичек который может быть приложен к любому алгоритму поиска суффиксного массива
в данном году мы играем ну ищем в цлиципле в порядке то есть сначала мы ищем ну как бы
на левой потом до первого да именно и они каждый раз до них вверх до рождения да то есть
каждый следующий это как как минимум как предыдущий минус один из этого следует что
оно что мы как бы проверяем да что суммарная в ту что суммарная в тупую работает за ними
да так что дал при этом работает за вот такой вот у нас красота
ну а теперь остается собственно финал как же нам построить собственно суффиксы массив
ну мы сейчас предъявим такой классический алгоритм но продукция да у нас каковому
сожалению работа будет за это но как вы поняли что в общем случае быстрее в общем-то и нельзя
но тем не менее мы попробуем и сделать начинаем собственно строить суффиксный массив
так вот суффиксный массив как же его строить первая идея возникает такая и так вот жил была
желанная строчка первая значит построение суффиксного массива мы сведем к построению
к сортировке циклических зверей то есть если допустим начать писать код то на самом деле
я вам так сразу скажу вот допустим если у вас будет vector int допустим findSuffixArray
то на самом деле код будет в коде будет написано буквально следующее vector int
sA равно sortCyclicShifts только не от строти S, а от строти S плюс
например где ездит но на самом деле чтобы совсем надежно могло бы быть можно вот так написать
просто нулевой символ добавьте и все ну или там 96 там вот значит теперь выпиливаем
ну теперь замечаем что там первым циклическим звегом там будет идти циклический звег начинается
с этого нулевого символа поэтому можно сделать там скажем к сожалению вектора нету по backup
поэтому пишем вот какое-то вот такое заклинание допустим и после этого все return sA
откуда это берется вообще ну давайте картинку нарисуем она нам все равно пригодится
допустим вот у нас есть строка abatsaba вот давайте вспомним у нас был тулькостный массив
оба оба цаба цаба вот это все да баба цаба и цаба ну вот ну теперь замечаем если мы в строке приписали
этот диезик но опять у нас добавился суффикс состоящий из диезика но заметим что относительный
порядок всех этих суффиксов никак не поменялся именно потому что диезик он меньше всех символов
строки есть это важно но также заметим что так как эти строки по парно различны да то получается
каждая там строга меньше предыдущей и тогда получается что если мы не причем что самое
важное ни одна из этих строк теперь когда мы добавили диезик не является префиксом следующий
видите да то есть как бы когда мы их сравниваем то есть мы до того как достигнем конца одной строк
мы там наткнемся на разные символы поэтому оказывается что если мы тут припишем
соответственно еще тут строчки то получается получается оба цаба оба то получается что
действительно можно сортировать у этой строки уже не спроте а циклический и получится ровно
точно поэтому начиная с этого момента мы забываем о всех диезиках и строй и решаем такую задачу дана
строка с и мы строим циклические и сортируем ее циклический а в качестве добивки вы кстати
объявляем строку в некотором смысле бесконечной то есть такие циклические из лиги ее бесконечность
то есть ну заметил что я тут могу еще еще тут допилить и език оба цаба вот это все но
и так далее строчка у нас такая бесконечная будет такая зацикленная
как мы этим будем пользоваться допоминаю да мы больше не строим суфиксный массив мы сортируем
циклический делаем ну вот так вот ну идея такая мы будем сортировать ну можно коротко
мы будем сортировать эти циклические сдвиги значит сортируем по первому символу сначала по первому
символу потом по первым 2 символы
потом по первым 4 символа
потом по первым 8 символом потом ну 16 32 64 и так далее ну в самом конце мы
отсортируем по первым не менее чем n символом и получается что мы тогда циклические сдвиги
отсортировать но все что нам остается это каждый из этих шаров проделать за линию
ну ладно каждый из этих шагов кроме первого что может так если мы по нам подсунуть камешки то
в общем даже уже первый первый шаг быстрее чем за линию не отсортируем быстрее чем за
но я утверждаю что переход от каждого шага к следующему мы элементарно сделаем за линию
дело в том что предположим что значит работать это будет следующим образом вот давайте я попробую
тут на картинке по рисовать и получается вот примерно такое
вот значит да вот давайте предположим что мы отсортировали суффиксы то есть не суффикс
а вот эти вот циклические сдвиги теперь бесконечным рисовать по первым и допустим символом
тогда заметим что если я их отсортировал то у меня будет идея такая я буду их не просто
сортировать а каждой подстроке длины l присваивать мысленно какой-нибудь красивый красненький
0 0 1 1 2 3 3 4 ну догадывается если разным присваиваю разным разным разное порядке возрастания
очень удобно как же теперь отсортировать по первым 2 но теперь заметим что вот эти вот подстроки
длины они тоже перенумерованы правда то есть тоже тут конечно же сильно более рандомные числа тут
уже начинается там 5 8 4 3 там 2 0 1 но тем не менее но то есть эти числа есть и вы теперь
но и на самом деле вы теперь можете отсортировать просто ну как-то как-то у нас
называлось радик сортом каким-нибудь или как у нас это называлось ну там либо радиус
либо карзикарванная сортировка там то есть действительно то есть по большому то есть по
большому счету каждый и каждая подстрока дыны 2 и теперь задается как пара чисел причем чисел
от нуля до н обратите внимание до 1 а то и меньше поэтому то есть вам теперь нужна за линейное
время отсортировать n по чисел как же это сделать ну сделать стандартным алгоритмом устойчивых
то есть сначала отсортировать по вот этому то есть по второй части а потом устойчивым образом по
первой помните было дело да и оба раза это легко делается за линию то есть на уровне
понимаете да понимаете да вот ну в общем-то но на уровне идеи алгоритм на этом в общем-то
заканчивается вот ну в принципе так ладно время у нас вроде вышло мы начали с опоздания
ну можно да можно вот да да ну раз мы начали с опоздания можно тогда есть чуть-чуть кода подписать
еще вот то есть вылететь код ну здесь так вот имеет смысл вот и взять что правильная его
реализация на самом деле как бы константу тут может хорошо оптимизировать и так поехали
вектор импс сорт так как шейт значит ну начнем с того что давайте отсортируем по первым
ну раз уж это стрим кто обычно все-таки сортирует за линию сортирует так а ну а первых давайте
значит создаем вектор int аж ну соответственно различных букв у нас будет бывает сколько правильно
256 так какие нам еще рептора потребуется значит ну давайте сразу перепишем до аж аж
нет ладно это н аж аж нам просто а также нам потребуется а на ци и н ци
нет все правильно так смотрите как будет выглядеть сортировка по собственному символу значит ну
во первых фор пишем все просто чар ц 2. с плюс плюс аж ц ну тут понятно ну
дальше стандартный код фор инт и равно один и меньше все пишу и думаю а если
сейчас быстро включу компьютер я могу просто презентацию показать и тут уже написал
какой вариант предпочитаете можете ну вот ну можно так ну как бы тут тут как всегда
ну показать на презентацию будет это и будет быстрее а можно написать так и тогда как бы
это будет учили как оба варианта имеют преимущество и недостатки как вы предпочитаете ну вообще да
или давайте демократия давайте кто за то что продолжит писать код тут и меньше ну допустим
не скомпилизованной там где-нибудь вставить и там строчку что н равно с точкой венгста
ладно я сам ставлю
вот тем более что все равно тут надо 256 а лучше аж сайс но аж и т плюс равно аж от и
вот теперь а точка ассайн на n и дальше фор значит пишем им и равно и минус один и больше
либо равно нуля и и мы вот тут сейчас сейчас будет мистическое заклинание минус минус аж от
немножко заклинание но есть но мы конечно прошел году уже подобного рода код писали так
что ничего страшного пока будет не страшно так теперь бы нам номера насчитать
теперь сделаем так смотрите ну а первым давайте с ну теперь теперь бы для для каждого
так для каждой подстроки длиной 1 насчитать бы ее номер значит пишем ц.рисайз от ц а нулевое
равно нулю ну и дальше фор как всегда мне хочется прям на сях писать и что бы тут пишем
с а и т ну как уже догадываетесь чему равно да с а и минус 1 плюс верно ли что с и т равно
но не самая оптимальная версия потому что возможно вы слишком много раз вычитаете
вон а и т минус первое вот это хотя да тут особо никуда не денешься так дальше начинается
самое интересное так пожалуй дальше начинается настолько самое интересное что я пожалуй это
самое интересное буду сверху писать чтоб красиво было ну тут понятно пишем функцию
теперь мы переходим но здесь полик закончился если что поэтому пишем пишем теперь так но
давайте эти на и мц нам по-любому пригодятся поэтому можно сразу на точка рисайз м ц.рисайз
дальше поехали дальше пишем фор теперь и мц и равно один и меньше и и плюс равно и
и вот здесь мы должны эти пары отсортировать то есть смотрите что у нас есть у нас уже
значит и вариант будет такой у нас уже есть на этот момент массив а в котором хранятся подстроки
длины l отсортированная по первому м символу понимаете да но и ну и у каждой строки еще
есть номер номер и он хранится в ц.рисайз казалось бы мы теперь должны сделать две
сортировки подсчетом сначала вот этих подстрок а потом вот этих правда нам нужно похоже что
для правых номеров насчитать сколько левых у нас есть для правого счета сколько левый
здесь нет то есть да нет вот сам фишка в том я просто смотри сейчас как бы сейчас логика такая
казалось бы сейчас просто два раза должны что-то насчитать то есть два раза сделать вот
примерно эти операции. То есть насчитать массив h, пробежаться и потом перезаписать. Правда, Иван?
Ну вот. Ну, можно было бы так написать, это будет работать, кстати.
Но мы применим пару мистических оптимизаций.
Во-первых, заметим, что h имеет смысл насчитывать только один раз.
Потому что заметим, что массив h, он на самом деле и здесь, и здесь будет один и тот же, потому что набор чисел один и тот же.
Согласны?
Вот. Согласны?
Вот. Поэтому давайте вот массив h насчитаем один раз.
То есть как мы его насчитаем?
h точка стичем. Останет смысл.
n ноль.
for int i равно 0 и меньше n плюс плюс i.
h от чего там? Ну цель этого, конечно.
плюс плюс
for
i равно 1 и меньше n плюс плюс i.
Что там еще?
Ну вот. Понятно. h i t плюс равно h i минус 1.
Вот на h насчитали.
Можем их куда-то даже сохранить, но мы не будем этого делать.
Вообще-то мы много раз уже начинали с мультиклей.
Ну да, но я имел в виду, что мы должны были насчитать это вместо двух раз внутри одной интеракции цикла, мы могли насчитать это.
Нет, понятно, что там потом все поменяется.
Вот.
Вот.
В принципе, знаете, можно на самом деле еще задуматься о геосимпатической оптимизации, что эти h насчитывать при насчете c шагов.
Понятно, да?
Ну да.
Ну то есть, если они совпадают, то нет чего.
Ну да, можно в принципе.
Ну да.
Ну это ладно, чуть позже подумаем.
Мне будет немножко привычнее, но тем не менее.
Но основная оптимизация не в этом.
Основная оптимизация означает, что мы не только h будем насчитывать один раз.
А фишка еще будет в том, что мы и сортировку подсчетом вот это перезаписывание a будет делать не два раза, а один.
Потому что идея такая.
Дело в том, что сейчас в массиве a у нас мы по первым a символам отсортировали все, правда?
А теперь идея такая.
А давайте из всех a-шек вычтем l.
Ну по модулю n, конечно, обычно.
Тогда я утверждаю, что у нас появятся циклические сдвиги, отсортированные уже не по первым a символам, а по вторым.
Неплохо, правда?
То есть получается, что ничего дополнительно особо делать не надо для того, чтобы отсортировать эти циклические сдвиги по вторым l символам.
Надо просто взять вот этот уже отсортированный массив по первым и уменьшить на это все.
Понятна логика?
Поэтому по факту все, что мы должны сделать, это из a-шек вычесть l и эти a-шки потом уже устойчивым образом отсортировать уже по себе.
В результате дальше будет писаться абсолютно неожиданный...
Сейчас совсем листика будет.
Значит, for int i равно m-1,
i больше либо равно 0,
0,
и дальше будем говорить.
Значит, n, a,
минус, минус h
от c,
от аитова,
в чем даже не от аитова,
а от аитова плюс n,
минус l процент n
равно
a-i-t плюс n,
минус l процент n.
Ну как бы логично, взяли очередной суффикс, ну в смысле сдвинули его на l,
взяли его цвет,
подсвету номер корзины, вычли из него один и записали.
Удобно, правда?
Зачем выдвигать на l? Почему не плюс или а?
Изначально в массиве a они отсортированы по первому n-силу.
Если сдвинуть на l именно в минусы,
то тогда они отсортироваются по второму.
Вот такая красота получается.
Ну и теперь остается насчитать...
А, ну во-первых,
перенести то, что в массиве a в массив а,
это делается за у от единицы
простой командой a.swap of n.
Ну и что теперь надо сделать?
Теперь n-сшки надо насчитать,
то есть новые цвета.
Насчитываем абсолютно тем же образом.
А нулевое равно нулю.
Ну и дальше for int и равно нулю.
1 и меньше n плюс плюс и.
Ну и дальше можно так и написать.
n-саит равно, соответственно, n-са и минус первое.
Плюс...
Ну и здесь пишем саит равно равно,
са и минус первое.
Ну и что дальше надо написать?
n, n. Чего? Чего? Чего происходит?
И ну и здесь еще придется написать
и еще придется писать c от аит плюс l процент n равно равно
c от аи минус аит плюс l процент n.
c.swap от n-с
Ну и все. Цикл на этом заканчивается.
Вот. Ну и остается только сказать,
корритория, соответственно, а.
Все.
В уконении букв было больше.
Вот.
Тут как бы написан год, в котором реализована основная оптимизация,
заключаясь в том, что две сортировки подсчетов,
то есть надо делать не два логоинсортировок подсчетов,
а только логоинсортировки подсчетов.
Ну то есть есть подозрение, что это не самая оптимальная реализация.
То есть, ну я просто не стал так дописывать,
чтоб совсем уже мобильный наводить.
Ну основная оптимизация не помешала бы, конечно,
вот от этих процентчиков избавиться.
Ну вот. Ну там, то есть можно от них избавиться,
если написать там функции вычитания по модулю и сложения
по модулю через рефы.
Это как минимум.
Вот. Ну а также я бы еще скорее всего
можно задуматься на тему того, чтоб вот в этом
и вот в этом вот местах как-то более адекватно насчитывать h,
потому что видите, мы тут тратим какие-то лишние коны,
а на самом деле вот эти вот лишние фолики,
на самом деле вот эти вот тратить не лучше.
Потому что обратите внимание, что здесь на самом деле
можно было сказать что-то более аккуратное,
если вот тут произошло равенство,
то мы просто типа h.back++ говорим.
Просто, а если произошло, если тут вот...
А, кстати, не правильно написал.
Неравно, да.
Да, кстати, неравно.
И тут надо отклицать на значку.
То есть тогда, если тут произошло неравенство,
то надо просто попушбэкать предыдущее число
и прибавить к нему идею ничего.
И тогда, на самом деле, вот в этих вот двух фоликах
уже необходимости не будет.
Понятно, да?
Ну там вопрос, конечно, за сколько у вас там будет back работать,
но тут можно сразу h, конечно, пресайтить на n
и хранить, где мы остановились, и назвать это callfc.
Вот.
То есть я думаю...
Все эти операции работают за log n,
поэтому, мне кажется, это оптимиза...
То есть ускорение ощутимое должно дать.
Так что вот это соответственно.
Так что будете там и так писать им референс документ
когда-нибудь, я надеюсь.
Так, это ты что пишешь?
Это вот это.
Вот это?
И что, попутно сравнивай с Emax?
Да, потому что там больше оптимизации.
Все в Emax-то?
Да.
А что в Emax-е?
Там в меньшем сравнении процент по модерами.
Ну я...
Ну я сказал.
Этих можно исправиться вообще.
Ну просто...
Они там прям...
Ну как же интересно.
У меня этим реализация чуть привычнее.
Тут, правда, c конечно, но это можно поправить.
Ух ты.
А, она прям совсем минималистичная.
Это цикл.
А, вот это вот все.
Один h, а...
Ну вот да.
А, вот это я имел в виду, да, что h.
А, ну да, то есть h называется...
Тут h-то центр.
Ага.
Нет, вот я про это и говорю, что на самом деле...
То есть на самом деле, минус-минус h можно...
То есть я говорю, что вот это вот h можно отдельно не насчитывать, а можно там вот при вычислении c-шек сразу считать.
Чего?
Ну что такое?
Это нормально.
Ну это над множество c-шек, все нормально.
Нет, может там есть какие-то вещи, которые все-таки были всяко все-все отменены, но...
Ну там типа эти же было что-то.
Так, ну ладно.
Да, соответственно, да, можно подоптимизировать, но как бы вот на уровне идей по камере разобраться можно.
Ну ладно, кажется, на этом...
Так, ну в общем, на этом, кажется, заканчивается примерно все, что я хотел сказать про сутоксный массив.
Так что теперь можно пойти кушать и соответственно...
И тогда после этого мы тогда перейдем к сутоксному массовому.
