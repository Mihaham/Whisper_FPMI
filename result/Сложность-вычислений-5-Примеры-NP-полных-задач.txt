Здесь возникает целое семейство задач, которые в каком-то порядке решаются. В общем, возникает то, что
называется сеть сводимостей на Web of Reductions. Сначала мы в прошлый раз доказали NP полноту задачу
3SAT. Выполним 3KNF. Дальше мы ее к одной сведем, дальше задачу к другой, другую к третьей и так
далее. В общем, картина, которую я планирую расписать, вот такая. Есть 3SAT. Дальше она
сводится к... Это я назову D HMPath. То есть D особый directed, ориентированный гамильтонов
цикл. То есть гамильтонов цикл, не цикл, извините, а путь. Значит, гамильтонов путь, path в ориентированном
графе. Дальше, а вот дальше этот самый путь можно в две стороны сводить. Во-первых, можно делать
внеориентированную графию. Это называется U HMPath. Значит, гамильтонов цикл в неориентированном
графе. Извините, опять заговорю. Значит, гамильтонов путь в неориентированном графе,
а может быть гамильтонов цикл в ориентированном. Вот и дальше. Значит, каждая из них может быть
сведена к U HMPath cycle, то есть к гамильтонов циклу в неориентированном графе. Но это
самое неинтересное. Значит, вот эта сводимость точно такая же, как вот эта вот, а вот эта вот
точно такая же, как вот эта вот. То есть это такое бесплатное приложение получается. Ну и в принципе
можно еще продолжить это свести к задачкам уважора. Значит, это traveling salesperson problem.
Вот. Ну и в принципе могут быть еще вот у задачек уважора есть очень много разных вариаций,
и многие из них НФ полные. Соответственно, вот дальше этот принцип можно продолжать. Так,
теперь давайте я еще здесь выпишу, что это за задача. Ну, давайте я в общем выпишу HMPath. Ну,
а тут соответственно есть варианты DEU. Тут есть на вход дается тройка. Значит, тройка GST. Значит,
такая, что в графе G существует гамильтонов путь из S в TA. Вот. Значит, гамильтонов путь означает,
что он один раз проходит через каждую вершину, но и при этом тут фиксированы начало и конец. То есть
он обязательно должен начинать в S и заканчиваться в T. Вот. Кстати, тут еще одна вариация возникает,
а что если не фиксировать, а спрашивать, есть ли хоть какой-то путь, который проходит через все
вершины, да, и где-то начинается, где-то заканчивается. Вот. Ну, обсудим тоже какой-то
момент. Можно обсудить почему та задача тоже NP полная. Вот. Ну, а соответственно HMPcycle,
то есть гамильтонов цикл, но тут только грав да, но уже без выделенных вершин. Да, соответственно,
тут точно так же, но гамильтонов цикл, то есть замкнутый маршрут, который ровно один раз
проходит через каждую вершину. Вот. Ну, а TSP тоже можно по-разному формулировать. Но
я давайте так. Формулирую, значит, TSP. Это множество троек, где есть граф, функция весов w и еще
некоторый порог. Ну, можно дать и D от слова distance. Значит, граф, веса и расстояние. Значит,
такое, что существует цикл, проходящий через каждую, да, веса, это что такое веса, это функция
из ребер графа в числа. То есть на каждом левре есть число. Это ввешенный граф называется.
Значит, существует цикл, проходящий хотя бы один раз, не меньше одного раза через каждую вершину.
Соответственно, суммарным весом не больше, чем D. Значит, вот это уже задача оптимизации. То есть
задача такая, что коми в Эжор ездят по разным городам и должен в каждом городе побывать хоть
один раз, чтобы там что-нибудь продать. И, соответственно, вопрос, сможет ли он это
сделать, затратив, да, там проехав суммарное расстояние не больше D. А вот это w — это
кросс-функция, которая говорит, сколько времени или там сколько по расстоянию ехать из одного
города в другой. Вот. Соответственно, тут бывают самые разные вариации. Например, можно требовать,
но простейшие задачи — это так называемый ефклидовый коми в Эжор, когда вот эти веса возникают
просто из-за обычного расстояния геометрического, ну в каком-то пространстве. Вот. Бывает метрический
коми в Эжор, когда веса какие угодно, но выполняют соединенность треугольника. То есть это все-таки
смысл именно в том, чтобы там как-то ехать. И, соответственно, всегда можно из города A в город
B поехать через город C, и поэтому расстояние напрямую будет уж не больше, чем если заезжать в город C.
Поэтому выполняется, наверное, с треугольника. Но можно, в принципе, и это ослабить, да, говорить,
что это не расстояние, а просто какие-то числа, и что если я иду из города там A в город C,
то тогда там вниз может быть очень большое расстояние. Вот. Ну а дальше там может быть,
например, может быть, например, такая постановка, что надо просто в каком-то
порядке их посетить ровно один раз. Например, это полный граф, веса какие угодно, нужно посетить
ровно один раз каждый город, ну и чтобы сумма этих затрат была как можно меньше. Вот. Ну,
соответственно, вот это можно и рассмотреть так практически. Может это быть, на самом деле,
например, не комивая Azure, а какой-то такой автоматический тестировщик программ,
который должен там все ситуации, которые в программе могут быть, проверить. И он их в каком-то
порядке что-то где-то переключает, какие-то характеристики, и, соответственно, должен
что-то вот так переключить, чтобы все ситуации проверить. Вот это вот пример, пример задач,
которые не связаны с поездками, но при этом собуются задачками Azure. Вот. Ну и так далее.
Значит, и так далее. В общем, кучу разных, кучу разных вариантов можно рассмотреть. Так. Ну,
давайте я начну показывать все эти сводимости. Значит, самое главное будет первое. Значит,
самое главное будет первое, значит, когда мы вообще как бы совершаем прыжок из мира
бульевых формулов в мир графов. Так. Значит, смотрите. Вообще общая идея, когда мы трясат
куда-то сводим, то что нужно сказать? У нас в этих формулах есть какие-то переменные и какие-то
скобки, дизъюнкты тремя литералами. И, соответственно, нужно внутри той конструкции,
которую мы строим, в данном случае внутри графа, иметь некоторые фрагменты, так называемые гаджеты.
Значит, гаджеты для переменных и гаджеты для скобок. Как-то нужно их описать. При этом гаджет
для переменной должен быть таким, что там есть какие-то два варианта. Один вариант соответствует
истине, другой соответствует лжи. Ну а гаджет для скобки каким-то образом соответствует тому,
истинен один из составовечек литералов или нет. Ну вот, значит, гаджет для переменной выглядит
вот так вот. Гаджет для переменной выглядит вот так, такой ромбик. Сейчас я сначала вершинки
нарисую, чем он идет вот сюда, вот так вот, потом вот так вот, так, потом вот так вот. Так, и при этом
здесь все туда-сюда. Вот эти все ребра двухсторонние. Вот такая вот штука соответствует переменной.
Соответственно, ее нужно проходить сверху вниз. И, значит, можно сказать так, что можно обходить
двумя способами. Есть зигзаг, вот такой вот нормальный, и есть, наоборот, загзиг. Загзиг вот такой вот
симметричный. Соответственно, если нужно пройти сверху вниз, да и вообще, если нужно все вершины
обойти, то вообще никаких других способов нет. Из-за односторонности вот этих ребер нужно начинать
сверху, заканчивать снизу. Дальше здесь выбор один из двух, а дальше, если он сделан, то автоматически,
если мы сюда пройдем, то вот эти мы никогда не посетим. Дальше, собственно, никаких других
вариантов нет. Соответственно, должны проходить вот так вот. Вот, значит, и дальше мы из таких
гаджетов, значит, такие гаджеты делаем для каждой переменной и строим такую гирлянду. Значит,
это вот для переменной P, дальше такая же гирлянда, такой же гаджет для переменной Q,
и тоже все туда-сюда. Вот, можно сцеплять их вот так вот, да, можно делать отдельную
перемычку, это неважно. Значит, дальше для R, и так для всех переменных, которые у нас тут есть.
Так, я пока не сказал, насколько длинны вот эти цепочки внутри гаджетов должны быть, но это сейчас
станет понятно. Значит, заведомо хватит 3 умножить на число скобок, ну, еще плюс один. В общем,
реально надо следующее. Реально нужно, чтобы для каждой скобки была выделена пара вершин,
которая как-бы была совершенно отдельна. Вот, значит, вот эта вот часть гирлянды для переменных,
и дальше она дополняется так. Значит, пусть у нас будет P, например, или не Q, или R. Тогда
смотреть, что мы делаем. Вот у нас P, как раз гаджеты PQR, и переменные PQR входят. Если у нас
входит сама переменная без отрицания, то, значит, мы выбираем вот эти вот, отступаем,
пропускаем одну вершину, выбираем вот эти вот две. И дальше говорим так, что вот из левой из них
отправляем ребро сюда, а потом возвращаем в правую. Вот, а если не Q, значит, если с отрицанием,
то наоборот. Из правой вершины отправляем ребро сюда, и возвращаем в левую. Вот, ну и последняя
тоже тут из левой, соответственно, из левой сюда. Возвращаем в правую. Вот. Хорошо. Зачем так
сделали? В чем идея? Ну, идея такая, что, смотрите, если у нас, если мы идем зигзагом, то мы можем в этот
момент пойти вот в эту вершину, вернуться в соседнюю и продолжать идти зигзагом. Вот. А вот если
мы шли загзигом, то мы не могли бы вот отсюда пойти сюда и вернуться сюда же, потому что эта
вершина мы уже прошли. А с отрицанием, наоборот, если мы идем загзигом, то мы можем пройти вот
этой правой вершины, прийти сюда, вернуться сюда и пойти дальше. А наоборот, с зигзагом бы не
смогли, ушли бы сюда, надо было бы возвращаться туда, где мы уже были. Вот. Значит, вот получается
такая картина. И, соответственно, понятно, что делать, если у нас форма выполнима. Значит,
если форма выполнима. Да. Значит, тут дальше, если перенена входит в много разных скобок, то для нее
тут нужно отдельные другие еще пары выбрать. Вот эту одну пропустить, следующую пару для
другой скобки, одну пропустить, следующую пару для другой скобки. И, соответственно, в цепочке
должно быть столько вершин, чтобы на все скобки хватило. Вот. За этим достаточно в каждом гаджете
выделить достаточно вершин для всех скобок. Вот. Так вот, если форма выполнима, тогда есть такой
канонический путь. Есть канонический путь. Значит, идем по гаджетам. Идем по гаджетам.
Соответственно, если P i t равно 1, то обходим вот так вот. Если P i t равно 0, то обходим вот так вот.
И, соответственно, при первой возможности посещаем вершины, соответствующие скобкам.
Значит, при первой возможности посещаем вершины, соответствующие скобкам. Вот. А возможности это
обязательно наступит, потому что в каждой скобке естественный литерал. И в тот момент,
когда мы проходим по соответствующей переменной, мы сможем эту скобку посетить. Так. Понятно?
Хорошо. Но этого недостаточно. Нужно еще обратно доказать, что если есть путь, то форма выполнима.
Обратно. Пусть есть путь. Вот. Значит, тогда смотрите. На самом деле, если он канонический,
то более-менее точно так же можно обратную сторону провести. Если он канонический, то тогда все обратимо.
Значит, можно обратить рассуждение. Да, то есть как обратить, что, соответственно, если мы
обходим зиг-загом, то переменная равна единице. Если обходим заг-зигом, то переменная равна нулю.
И поскольку мы смогли посетить вершину и вернуться туда же, то, значит, соответствующий литерал,
входящий в скобку, будет истинным. И так со всеми скобками, раз мы все вершины посетили, значит,
форма истины. Вот. И проблема только в том, что нужно исключить не канонические пути.
Когда путь идет, например, вот так вот, но тем не менее уходит вот по этому ребру, уходит туда, но сюда он
вернуться не может, он возвращается еще куда-то. И там как-то еще ходит, куда-то перескакивает, что-то такое
делает. Нужно показать, что такого быть не может, что он все вершины посетить не сможет.
Но в данном случае в такой ситуации это очевидно, потому что если он уйдет вот отсюда, вот тогда вот
эта вот вершина останется заведомо непосещенной. Потому что она останется висячей, да, нам нужно...
Да, кстати, я что-то говорил, что вот есть S и T, начальник, конечно, вершина, я тут их не указал,
но имеется ввиду так, что вот эта самая верхняя, это S, самая нижняя, это T. Вот. Ну вот, и нам нужно
прийти сюда, а у нас осталась висячая вершина, мы в нее, может, не сможем прийти, а вот выйти из нее
точно не сможем, поэтому продолжить долгомельтонного пути не получится. Вот. Ну и так как раз вот если мы
оставляем вот эти вот пробелы между парами, которые отводятся на посещение туда, то такое заведомо будет
работать. Значит, такое заведомо будет работать, заведомо будут висячие вершины. Такое рассуждение,
в смысле, будет работать, что у нас остается висячая вершина, которая точно не будет посещена,
если мы пошли как-то не в том направлении. Так, ну да, значит, дайте это я отдельно напишу,
значит, не канонического не может быть. Значит, так как при сходя с гаджета и возвратив другой гаджет,
и возвратив другой гаджет остается висячая вершина.
Вот. Которую уже потом нельзя посетить. Да? Ну вот. Вот. Поэтому все нормально. Какие-нибудь вопросы?
Нет, по гаджету мы не можем вернуться наверх, потому что у нас все ребра сверху вниз. А неважно,
да, в принципе, мы можем еще пройти вот так вот и сразу пойти сюда, но тут точно так же,
точно так же останется висячая вершина. Нет, мы в принципе, мы сможем вернуться сюда, но посетить
вот эту оставшуюся висячую вершину и из нее потом уйти мы уже не сможем. А потому что нельзя
второй раз посещать. Это же гаметонов цикл, путь, точнее. То есть тут как раз специально вот эти вот
перемычки, их уже нельзя второй раз посещать, поэтому так. Вообще, насколько я понимаю,
даже если эти пробелы не делать, все равно будет верно, но там будет какое-то сложное рассуждение.
Почему, если вот здесь будет вплотную, и дальше вплотную, то почему все равно все нельзя обойти.
Там, на всякий понявший, если мы сходим, там как-то все разваливается и не должно
получиться и везде все исправить. Вот, так. Ну, дальше, давайте я покажу, как путь к циклу сводить.
Так, значит, вот пусть у меня какой-то граф есть, на самом деле неважно, ориентированный,
не ориентированный. В нем есть S и в нем есть T. Вот. Ну и первая идея такая. Давайте мы просто
возьмем и вот такое вот ребро добавим наоборот из T в S. Тогда, если есть путь из S в T,
то вместе с этим ребром будет цикл. Видите ли вы ошибку в этом рассуждении?
Но да, да, дело в том, что нужно и в обратную сторону. Значит, в принципе, конечно, вот эта
часть верна. Если был путь, то с добавлением вот этого ребра будет цикл. Но, в принципе,
может быть цикл в новом графе, который это новое ребро не затрагивает и в котором S и T не подряд.
И тогда может быть так, что есть цикл, где S и T не подряд, но при этом пути из S в T в
исходном графе не было. Ну, например, если в играх это просто такой цикл,
там S и T с разных сторон, тогда там ясно, что нет пути из S в T. Вот. Но когда мы добавим такое,
то появится как бы цикл, никуда не денется, если уж он был. Вот. Ну а чтобы от этого избавиться,
нужно тут еще посередине добавить еще одну вершину, какую-то новую W, хранением ориентации.
И вот тогда-то в ту сторону все точно так же был путь. Мы добавили два ребра,
получился цикл. А в обратную сторону, смотрите, если тут есть гамильтонов цикл, то он обязан
проходить через новую вершину W. А у W вообще всего два ребра, одно входящее, одно исходящее,
значит они на этом цикле должны быть. Вот. Значит, на этом цикле есть цепочка T, потом W,
а потом S. Ну а весь остаток этого цикла будет как раз путем из S в T в исходном графе без вот
этой добавки. Вот. Ну ничего, понятно? Так, отлично. Отлично. Так, теперь давайте поговорим,
как ориентацию снимать. Значит, переходить... Да, вот это рассуждение, но годится и без ориентации
тоже. Да, если тут просто это ребра, то все равно должны быть эти два ребра подряд, и тогда есть путь
вот там. Так. Хорошо. Значит, теперь, как сводить ориентированный путь к неориентированному. Так. Ну,
смотрите, опять же, первая идея, а мы просто вообще забудем ориентацию. Тогда, если был там путь,
то и он и останется. Но, конечно, та же самая ошибка. Может быть так, что за снятие ориентации путь
есть, а до снятия его не было. Нужно не только чтобы старый сохранился, но и чтобы нового не
появилось. Вот. И для этого идея такая, что мы каким-то образом попробуем записать, закодировать
ту ориентацию, которая была, через неориентированные ребра. Так. Ну, это делается вот так вот. У нас
какая-то вершина X превращается в такую тройную вершину. X in, X mid и X out. Так, что средняя соединена
входной и выходной. И больше вообще ни с кем. Ну, то есть получается, что если у нас была какая-то
вершина, да, у нее было, были какие-то входящие ребра, были какие-то исходящие. На то дальше
получается такая штука, да, она получается тройкой. И у тех всех тоже тройки. И, соответственно,
дальше мы делаем следующее. Если у нас было ребро из одной вершины в другую, то мы теперь
соединяем входную, наоборот, выходную вершину, которая из первой тройки, со входной из второй
тройки. Соответственно, здесь тоже вот так вот. Ну и дальше более-менее понятно,
почему сохранится, да, например, если вот мы прошли вот по этому ребру, потом по этому ребру,
на то здесь мы соответственно идем вот так вот, потом вот так вот, потом вот так вот,
потом вот так вот, потом
в выходную. Дальше проходим через
vi,
оказываемся в выходной, идем в следующую входную, и так далее, все проходим.
И опять же нужно доказать, что не получится нового пути или цикла
паразитного. Потому что, в принципе, мы что могли сделать? Мы могли пройти вот так,
вот пройти сюда, дальше вместо того, чтобы пойти сюда, пойти куда-то вот сюда,
как бы по ребру, как бы обратно. Но опять, в принципе, то же самое, ровно за этим
нам и нужна средняя вершина. Если мы здесь пошли не в том направлении, то у нас
средняя вершина останется висячей, и мы ее потом не сможем посетить. Вот, поэтому мы
обязаны вот так вот проходить и никак иначе. Вопрос какие-нибудь?
Так, ну ладно, это сейчас перерыв, 5 минут. Чуть-чуть поговорим про коммивоежора,
и потом еще пару тем, я хочу затронуть. Значит, вот осталась последняя задача в этой
сети, это задача о коммивоежоре. Вот, ну на самом деле очень легко, скажем,
Гамильтонов цикл сводится к коммивоежору, как там написано. Ну, самое простое,
например, что просто граф тот же самый, веса всеединичная, а порог D это просто
число вершин. То есть, можно ли обойти все вершины, затратив расстояние n? Но это как раз
тогда и только тогда, когда есть Гамильтонов цикл. Да пусть даже можно, тут это совершенно
неважно. Но если еще и нельзя, то там получится не просто Гамильтонов цикл, а еще короткий Гамильтонов
цикл. Вот, а тут можно, но все равно, если у вас цикл и все вершины посещены, то никакая повторяться
не может по принципу дирехля. Если цикл влит на n и n-вершина посещена, то значит ничего другого быть
не может. Вот, можно рассматривать разные другие варианты. Например, если требовать, что это полный
граф, то, например, можно сказать так, пусть те ребра, которые были в исходном графе, будут веса
1, а те, которых не было, будут веса 2. И тогда, если мы заянно обошли, то все равно мы прошли
приорванным веса 1. Вот, и поэтому, кстати, поэтому получается, что уже за дачками воежора, где веса
либо 1, либо 2, уже будет NP полной. Вот отсюда же, на самом деле, возникает вот такой задач куми воежора,
где нельзя как раз повторять вершины, но зато все ребра есть какими-то весами. Вот с такой задачей
получится, что трудно не только точно решить, но и приблизить. Потому что, в принципе, можно
ставить задачу так. Ну хорошо, допустим, мы не сумели найти точное оптимум, точный минимум, но
может, ну хоть приближенно его сможем найти. Вот, но в такой вариации даже
приближенно нельзя. Значит, вариация, что полный граф с весами, полный граф с весами,
и нельзя повторять вершины. Повторять вершины нельзя. Значит, тогда можно сводить так. Может,
что точно был граф, и, соответственно, если было ребро, то вес равен единице. А если не было,
то тогда вес равен какому-то большому числу m. Вот, тогда, соответственно, если был,
значит, если был гамильтонов цикл, то тогда тут есть цикл веса m, цикл веса m. Вот, а если не было,
то тогда только веса, ну может быть, больше либо равно m. Ну, тут можно даже плюс или минус 1 написать,
это всё не очень важно уже. Значит, больше либо равно m. Ну, вот это я могу каким угодно выбирать,
и тогда получается, что как бы вот это вот оптимальное значение вот в этом случае может быть
сколь угодно больше оптимального значения в этом случае. Значит, вот это m поделить на n
сколь угодно велико. И отсюда очень легко получается, что уже приближение с любой
точностью будет NP трудным. Ну, то есть что значит приближение NP трудно? Ну, это означает,
что представьте, что у вас есть какая-то программа, которая умеет находить ответ,
который не больше, чем в k раз, больше, чем минимальный. Но тогда, если это k будет меньше,
чем вот это отношение, тогда уже такая программа позволит решить задачу гамильтонов цикля. Потому
что, соответственно, если получилось меньше, чем вот столько, значит, если меньше, чем m,
значит уже гамильтонов цикл был обязательно. А если не получилось, то не получилось.
Ещё раз. Значит, ещё раз. Пусть у вас есть какая-то программа, которая умеет говорить
следующее. Она умеет, например, говорить число, которое больше либо равно оптимального значения,
но меньше, чем какое-то k умножить на оптимальное значение. Вот она с точностью k умеет решать
задачу минимизации. Вот тогда, если k меньше, чем вот столько, то тогда такая программа позволит
решить задачу гамильтонов цикля. Что мы по гамильтонову циклу построим вот такую задачу
Комиевого и Жора, и дальше либо ответ ровно n, и тогда нам приближающая программа даст не больше,
чем каен, и каен будет меньше, чем m большое, и любое число меньше, чем m большое сообщит нам,
что гамильтонов цикл был. Ну либо, соответственно, она сказала больше, чем m, и это значит,
что цикла не было. То есть даже такое приближённое решение уже позволит решать
гамильтонову цикле. Вот, и вот тут поведение совершенно разное для разных задач. То есть вот тут
вот такая вот вариация задач Комиева и Жора получается сложна для приближения с любой точностью.
Вот, а вот разные другие, например, наоборот, будут решаться приближенно. Например, задача в рюкзаке
может быть решена приближенно. Или, например, тот же Комиевый и Жор, но для Евклидова расстояние тоже
может быть решён приближенно. Это Орора придумал в своё время. Там не такое уж простое рассуждение,
но, в общем, можно решить. А вот, например, если задача метрическая, да, это получается не метрическое,
потому что если мы можем пройти, то как-то в обход. В обход будет сколько-то ребер, а тут прям m большое.
Соответственно, это не метрическая задача. А для метрического Комиева и Жора известен ещё в 70-х
годов алгоритм приближения с точностью 1,5. Да, значит, он долгое время был известен под именем
алгоритм Кристофидуса, но недавно откопали, что новосибирский учёный Сердюков одновременно и
независимо тоже его придумал, и теперь его называют алгоритм Кристофидуса Сердюкова.
Вот. И там ещё недавно было какое-то совершенно миниатюрное улучшение, которое ещё и вероятностное,
что, в общем, там что-то в среднем получалось, вместо 3 вторых, там получалось 3 вторых минус
какое-то совершенно миниатюрное число, типа 10 в минус 36, там что-то такое. Ну, вот это в теории
часто бывают такие достижения, что изменения в каком-то там восьмом знаке, ну а тут вообще в 36-м знаке.
Вот. И это, тем не менее, все изучают. Вот. А есть также оценки с другой стороны, что там с какой-то
точностью, типа там 122-121, уже НП трудно приближать. Вот. И соответственно, вот есть зазор. Есть зазор,
между 3 вторыми и 2-мя 121-мя, между которыми непонятно, насколько сложны задачи о приближении. Вот.
И это тоже очень хорошая область, трудность приближённых вычислений. Значит, в этом курсе мы это изучать не будем,
чуть-чуть поговорим в топ-главах. А потом, может быть, если будет желание, через год прочту спецкурс.
Эти темы, это называется PCP, варианта проверяемой доказательства. Вот. И там, удивительно образом,
совершенно разные, на первый взгляд, вещи друг с другом связаны. Вот. И это, в принципе, тоже вполне
местами передние краи науки. Значит, там были очень большие продвижения в начале 2000-х годов, 15-20
лет назад. Сейчас немножко это приутихло, но, тем не менее, там многие задачи остались открытыми.
И можно про... С одной стороны, можно пытаться придумывать более эффективные алгоритмы, которые
решают те или иные задачи. С другой стороны, можно пытаться более сильные оценки доказывать,
что с какой-то меньшей степенью приближения будет МП трудно задачи приблизить. Вот. Так, хорошо.
Значит, про что еще я хочу поговорить? Да. Кто, Perfect Matching? Нет, парсочетание,
как раз, полиномиальная задача. Ну, конечно, да. Не, вот это совершенно полиномиальная,
а вот если максимизировать, там, максимальная, вроде тоже полиномиальная. Ну, совершенно что такое,
что мы находим набор ребер, которые попарно не пересекаются. Вот. Это не просто полиномиальная,
а это именно при решении этой задачи Эдманс придумал класс П. Он сначала придумал алгоритм
с тягиваниями лепестков, а потом сказал, что вот он полиномиальный, и как раз полиномиальным
и нужно считать... Ну, как полиномиальным, нужно определять все эффективное. Вот. А вот если у вас
не парсочетание, а сочетание по тройкам, да, например, у вас есть какой-нибудь там гиперграф из
треугольников, и нужно найти не пересекающие треугольники, как можно в большем числе. Вот такая
задача уже Энп-полная. Вот. Так, хорошо, значит, про что я еще хочу сказать. Но есть еще вот несколько
важных Энп-полных задач, которые такие архетипические, одна из них CLP. Значит,
CLP — это целочисленное линейное программирование. Вот. Но это можно формулировать по-разному. Вот.
Но, например, можно спрашивать так. Вот у вас есть какая-то целочисленная матрица и какой-то
целочисленный вектор, и вопрос... Ну, например, вот так вот. Да, какое-то неравенство, и вопрос
имеет ли решение в целых числах. То есть A — целочисленная матрица, B — целочисленный
вектор. И спрашивается, есть ли у системы неравенств, которые заданы этой матрице, целочисленное
решение. О, значит, если вопрос о целочисленности не станет, то это просто обычное линейное
программирование. И, соответственно, там на самом деле есть полиномиальное решение, хотя на
практике как раз используется экспедиционный симплекс метод. Экспедиционный, в худшем случае,
симплекс метод. Вот. Значит, на самом деле очень многие задачи удобно формулировать в таких
терминах. Вот. Ну, например, например, вершинное покрытие можно так сформулировать. Да,
для каждой вершины ввести там переменную xv, написать, что это xv больше либо равно нуля, xv меньше
либо равно единице. Соответственно, единица значит, что мы вершину берем, ноль что не берем. Значит,
дальше сумма всех xv будет меньше либо равно, чем k. Это означает, что мы не больше k вершин взяли.
И при этом для любого ребра, для любого vw из ребра, получится, что xv плюс xw будет больше либо
равно единице. Да, то есть из двух концов каждого ребра хотя бы один мы взяли. Вот. Ну, вот как раз
получается большая система линейных равнений, линейных, извините, неравенств с целыми
коэффициентами. И более того, даже значение либо ноль, либо единица. А решить, да, понять, есть ли у
этой системы решение, то же самое, что решить задачу о вершинном покрытии. Вот. Ну и так, на самом
деле, ну, в принципе, уже из этого можно сказать, что про вершинное покрытие мы доказали, что оно
mp-полное. Значит, мы его вот так вот свели, и это тоже будет mp-полное. Вот. Но реально там очень много
разных задач, так удобно формулировать. Но на самом деле, я так сказал, я кое-что запрятал. На самом
деле, когда мы так свели, мы доказали только mp-трудность. А чтобы сказать mp-полноту, нужно
еще отдельно сказать, что эта задача лежит в mp. И это, на первый взгляд, очевидно. Ну как, если
решение есть, то мы его предъявим и проверим. Но на второй взгляд, совсем не очевидно, потому что
нужно не просто чтобы решение было, а чтобы оно еще было не слишком большое. Понятно, да? Нужно
не просто число переменных должно быть маленьким, но и сам размер решения должен быть не больше
чем экспоненциальным, чтобы по линомерным числам битов можно было эти числа записать. Вот.
Ну, это, на самом деле, можно доказать. Я думаю, я сейчас подробно не буду на этом останавливаться,
но идея на конструкцию такая, что мы доказываем, что если есть какое-то решение, то есть не слишком
большое решение. А как мы это доказываем? Мы предполагаем, что там все решения слишком большие,
берем из этих слишком больших самое маленькое и показываем, что его можно еще уменьшить, если оно
все-таки действительно слишком большое. Но потому что там идея такая, что... Ну, смотрите, если у
нас х это решение системы а на х равно нулю, целочистое решение системы а на х равно нулю,
то тогда можно его просто добавлять и вычитать как угодно. Ну и, грубо говоря, там, в общем,
в общем, так подстраивается, чтобы как бы то решение, которое есть, как-то все-таки сдвинуть,
чтобы все компоненты были не слишком большими. В общем, интуиция примерно такая, конкретика там,
в общем, такая линейная алгебра. Я думаю, что я сейчас пропущу, потому что я еще хочу про другие
вещи успеть поговорить. Вот. Ну, значит, вот это CLP вполне на практике часто используется. Есть даже
специальные там программные комплексы, решатели такие, солдеры, которые решают особо эффективно,
но они все равно не могут точно решить, потому что это полная задача, но они, в общем, все
оптимизации, которые могут, делают. И есть такой специальный рынок этих решателей. У IBM есть
программа CPLEX, а есть еще там группа товарищей, которые оттуда вышли и свою сделали, называется
Гуроби по их соответствующим фамилиям. Есть, в общем, еще несколько. В общем, тут мы прям с такой,
с индустрией сталкиваемся, потому что действительно такие задачи решать надо,
и, соответственно, фирмы готовы за это платить, а некоторые IT-компании, которые обслуживают
меня, маленьких пользователей, а большие фирмы, они как раз в том числе решением таких вещей
занимаются. Вот, хорошо, значит, и еще одна вещь, которую хочу сказать, это, ну, можно рассмотреть,
можно сказать, что это язык теорем. Значит, можно сказать, что theorem set – это множество
записей в какой-то формальной системе, доказуемых теорем. И, соответственно, если мы просто
спрашиваем, доказуемы теоремы или нет, то это вообще неразрешимая задача, как нас там Геодали учат,
Юринг и все остальное. Вот, но, значит, если мы ограничим длину записи, скажем, что тут пара из
фи и к единиц, значит так, что у фи есть доказательства длины не больше к. Вот, вот эта задача уже лежит в НП.
Ну и является НП полной более-менее для любой разумной формальной системы, в которой вы записываетесь
эти доказательства. Но если, например, речь идет о формальной арифметике, то нужно просто, ну, не знаю,
если вот это вот, например, CLP записывать, то это просто, да, это же и есть арифметика с натуральными
числами, ну или там с целыми, да, это все-таки целое число, но все равно, значит, целочисленную
арифметику можно выразить через натуральные числа и просто все вот это вот записать как бы,
как формулировка теоремы. Вот, ну а тут как бы, ну, теоремы, что существует х, да, такое, что вот это
верно. Ну а такие теоремы, в принципе, можно доказывать через предъявление этого х и, соответственно,
проверку. Но если это там что-нибудь другое, мы хотим записывать какие-нибудь логические формулы,
ну тоже, у нас формальная система должна уметь каким-то образом кодировать були в алгебру и,
соответственно, доказательства будут, что вот есть такое значение, если мы его подставим,
то там будет единица, да, будет формула выполнима. Вот, хорошо, вот это вот связь, наоборот,
с основанием математики. Ну что, есть какие-нибудь еще вопросы? Так, я хочу еще про одну вещь рассказать.
Значит, еще одна вещь, это сложность задач поиска.
Значит, потому что на самом деле, как правило, нас интересует не вопрос есть или нет что-то,
ну, бывает так, что на самом деле интересует вопрос есть или нет, да, например, когда нас
интересует простое число или нет, то если оно составное, то обычно нас не интересуют,
какие множители, да, потому что мы хотим простое найти. Вот, но чаще, когда вот мы решаем задачи
там CLP, там задачками Вежиора, что-то ищем, то желательно не просто понять есть этот объект или
нет, а прям таки его найти, если он есть. Вот, и вот это вот называется задача поиска. Задача поиска.
Тут V от XY, V от XY, какой-то предикат, и нужно, соответственно, по X, значит, по X нужно сделать
одно из двух. Либо, значит, либо найти Y такой, что V от XY равно единице, либо написать какой-нибудь
ответ нет, да, если не существует такого Y, что V от XY равно единице. Вот, вот это задача поиска. Вот, и
оказывается, что для NP-полных задач задача поиска и задача распознавания эквивалентная. Теорема
для NP-полных задач. Так, давайте я еще напишу покрасивее. Значит, для NP-полных языков, для NP-полных
языков задача поиска эквивалентна задаче распознавания, что, значит, эквивалентна, но эквивалентна
можно сказать, что эквивалентна по куку, но в том смысле, что если мы научились решать одну задачу, то мы сможем решать и другую,
обращаясь к первой полинейное число раз. Это в одну сторону это очевидно, потому что задача поиска более сложная.
Дальше задача распознавания, что нам нужно просто в первом случае сказать 1, в втором случае 0. А тут нам просто больше информации, да, ну и мы можем
забыть, какой именно Y найден, если он найден и говорить да. Вот, если не найден и говорить нет. Вот, поэтому задача поиска получается сложнее.
В общем, случая. Вот. Ну, доказательства такое. Так, дать я, опять же, немножко неформально основную идею расскажу. В общем, я расскажу,
на примере задачи Акликия. На примере задачи Акликия. Вот. А в общем случае, то в принципе нужно доказывать сводимость,
то, что называется Полевину, которая еще и позвалила задачу поиска, сводить задачу поиска. В общем, про это я на лекции не буду подробно говорить.
Так, значит, например, задача Акликия. Ну, смотрите, пусть у нас есть вершина, да, у нас задача, значит, по графу G и K нужно найти клику,
найти клику, то есть полный под граф на K вершинах. Так. Ну, понятно, а мы умеем понимать есть клика или нет.
Ну, ясно, что первый шаг будет просто как раз спросить, есть она или нет. Да, если нет, то сразу сказать, что ее нет. Если есть, то начать ее искать.
Да, то есть первое, это есть ли клика, значит, на графе G, в графе G размера K. Еще дальше, если нет, то тогда и на нет и суда нет, как говорится.
Тогда сразу ответ, что Y нет. Вот, если да, если да, то мы начнем ее искать и начнем искать следующим образом.
Выберем вершину V. Значит, выберем вершину V и спросим, есть ли клика в G без вершины V и размера K.
Да, то есть вот нам сказали, да, что вот клика есть, а вот если вот эту убрать, то она все еще есть или уже нет? Значит, если есть, то, соответственно, ищем рекурсивно.
Значит, ищем рекурсивно, у нас теперь получилось, что граф содержит на одну вершину меньше. Ну, понятно, что уже можем не спрашивать изначально, да, рекурсивно сразу вот сюда. Следующую вершину набираем и так далее.
Вот, если нет, тогда какой вывод? Да, вот у нас граф G, вот вершина V. Вывод такой, что эта вершина точно есть в любой клике.
Да, то есть в принципе, когда мы тут сказали, да, то, может быть, там есть одна клика, которая содержит V, а другая, которая не содержит V, и мы найдем ту, которая не содержит.
Вот, но раз уж без V нету клики, то, значит, она точно есть, а все остальные K-1 должны быть вот среди ее окрестности.
А все остальные K-1 должны быть не просто где-то, а должны быть именно с ней соединены. Вот, тогда мы тоже ищем рекурсивно, но уже другой подставляем.
Ищем рекурсивно, а тут получается как бы в окрестности. Давайте я так напишу, neighbor от V, и уже K-1.
Ищем-ыщем, находим и добавляем ту самую K. Не ту самую K, а ту самую V. У нас клик размера K-1, мы добавляем вершину V, получаем клик размера K.
Ну вот, аналогично, можно для любой по полной задачи, но чтобы доказать, нужно доказать, что там все сводится к клике не абы как, а еще и как бы сохраняя сертификаты.
Так что, по этой клике можно было найти то, что нам нужно было найти в той задачи, которую мы сводили.
На самом деле, если аккуратно проанализировать ремку Клевина, то там как раз сводимость именно такая.
Исходя из выполняющего набора, можно найти прям Y, который в исходной задаче был.
Можно аналогичную процедуру сделать для формулы.
Например, мы ищем выполняющий набор, умеем определять выполнимость формулы.
Можешь делать так. Если мы первую переноску поставим равную нулю, то тогда форму будет выполнима?
Если будет, то мы ищем дальше выполняющий набор. Если не будет, тогда, значит, поставим единицу и до нее ищем.
В принципе, такое же можно для выполнимости и много для чего.
Вот, какие-нибудь вопросы?
Ну, типа того, да.
Нет, смотрите, в любом случае тут, конечно, ситуация несимметричная.
То есть, если в одну сторону мы один раз запускаем задачу поиска и непосредственно ее результат используем.
То есть, это что-то похожее на сводимость по карпу.
А в другую сторону нам действительно нужно много раз запускать.
То есть, только это утверждается, что все-таки запуская много раз, мы сможем решить задачу поиска, запустив N раз задача распознавания.
Вот. Да, тут, конечно, еще нужно что-то сказать про то, что это все быстро закончится, но тут это легко.
У нас каждый раз либо граф уменьшается, либо и граф уменьшается, и число уменьшается.
То есть, суммарное число шагов будет точно не больше, чем число вершин в графе плюс K.
Ну, даже просто не больше, чем число вершин в графе.
То есть, это будет полинвайльное число запусков.
Вот, значит, в принципе есть еще ненаполонные задачи, для которых тоже такая эквивалентность есть.
Например, задача об изоморфизме графов.
Оказывается, что если вы умеете проверять, есть ли изоморфизм графов, то вы умеете и находить этот изоморфизм.
Вот. Но сейчас я уж не успею рассказать, может, на семинарах будет.
Вот. Но есть задачи, для которых заведомо задача рассматривания проще, потому что у нее ответ тривиальный.
Например, есть задача поиска найти у числа простой делитель.
Соответствующая задача с бинарным ответом тривиальная.
Но вопрос, есть ли у числа простой делитель? Думать не нужно.
Нужно сразу отвечать, что да, есть. Мы все это прекрасно знаем.
Но это нас не спасает, а может даже наоборот. Усложняет задачу.
В общем, все знают, что простой делитель есть, но тем не менее искать его не получается.
Вот. Ну и вот есть такой целый класс задач, называется TFNP.
Я даже напишу. TFNP.
Расшифровывается Total, Functional, NP.
Functional означает, что задача поиска, там как бы ответ, это не да или нет какой-то объект.
А Total означает, что всегда ответ есть.
То есть вот этот нижний вариант просто исчезает, остается только верхний.
Но тем не менее, для ряда задач, TFNP, задача поиска сложная, предположительно.
И для кучи задач никто не умеет решать.
И вообще там очень интересная теория.
Опять же, может быть мы ее изучим на доп. главах, теми кто будет ходить.
Так, ну все, на этом все на сегодня.
И на самом деле все с NP полнотой.
В следующий раз я уже планирую что-нибудь другое.
Либо про полинальную память, либо про полинальную иерархию.
Подумаю, в каком порядке.
Ну все, спасибо.
