Мы с вами прошли, научились спрашивать нужные вопросы,
потом у нас была трехзвенняя структура, и на этом все.
Мы кешированию не приступали.
Самая большая боль кеширования.
Понеслась.
Итак, мы сейчас с вами идем по инструментам, которые
мы можем применить, ничего особо не переделывая.
У нас есть проект, он как-то работает.
Нам нужно, чтобы он рос, выдержал большую нагрузку.
Ну окей.
Разбили на три звена.
Хорошо.
Кеширование.
Очень простая пирамидка.
Здесь у нас наверх идет скорость отклика.
А вот сюда цена байта.
Компьютер неоднороден, в нем дофига раз личного
рода слоев, фига раз личного рода устройств.
И компьютер, по большому счету, огромная машинка
для перемалывания данных.
Эти данные хранятся в компьютер.
Они хранятся в разных, не знаю, на разных средах.
Вот здесь у нас что?
Да.
Очень дешево, очень много можно хранить, но очень
медленно.
Дальше.
Дальше.
Я бы сюда добавил еще сеть.
То есть для какого-то компьютера, который занимается вычислением,
данные могут лежать не на нем, они могут лежать
в сети, где-то в другом компьютере, а это еще медленнее.
Вот примерно так.
Регистровая память очень дорогая.
Там их всего, там очень ограниченное количество.
Даже в нашем Эльбрусе, относительно нашем Эльбрусе, ребята пошли
по интересному пути, они регистров сделали очень
много.
То есть как бы регистровой памяти в Эльбрусе очень
много.
Но все равно недостаточно, не сравниться даже с каким-то
одним уровнем кэшей.
Так, что это для нас значит?
При первой возможности, при первой возможности идем
наверх.
Лежит у нас какой-то огромный кусок здесь, нам нужно
с ним какие-то вычисления провести, провели, положили
в память.
Рассчитываем дальше.
Вот над этим мы как правило не властны, если мы работаем
не на Assembler, а на более-менее высоком языке программирования.
Это как правило удел процесса.
Но вот эти две вещи, даже вот эти три я бы сказал,
ну это одно и то же, да?
То есть как бы система хранения на диске, да?
Вот эти три вещи, это наша эта, наша все, здесь мы можем
управлять.
Получили что-нибудь с сети, что нам важно, сохранили
кэш.
Подняли что-нибудь с диска, прочитали с базы данных,
провели вычисления, но закрывайте уже.
Провели вычисления, положили в кэш.
Очень простой принцип.
Теперь давайте подумаем, а что, что мы туда можем
положить кэш?
Ну вообще в принципе, какие элементы.
Окей, сырые данные, данные с предварительной обработкой
агрегации и так далее, не знаю, обработаны.
Давайте плюс и минус.
Сырый.
Это плюс, да, согласен.
Так, ага, можно больше операции, ты один раз положил, а потом
из них чего-то, чего угодно вычисляешь, причем несколько
раз.
Вот смотрите, вот на основе чего вы будете принимать
решение, например обработать данные или сырые?
Ну, попробовать, да, попробовать посмотреть, как вы собираете
их потом использовать, то есть, например, вполне
возможная конструкция, когда у вас, не знаю, страничка
какой-нибудь сайта или сервиса, она состоит из различных
вариантов отображения одного и того же.
То есть у вас данные одни, а вариантов отображения
их, например, десять.
Может быть такое, ну может быть, я не знаю, какой-нибудь
финансовый сервис, аналитическо-финансовый сервис.
В таком случае один раз взяли, один раз данные положили,
а затем их пересчитываете в разные виды.
Или, например, это отображение очень сильно зависит от
того, какие фильтры ввел пользователь, а фильтров,
например, двадцать, и они могут комбинироваться,
и раз, и получается, что у вас там не знаю, двадцать,
или двадцатой степени вариант, ну или сколько-то
там, да, то есть ну дофига, да, то есть как бы кашировать
обработанные данные, ну явно, явно плохо, закашировали
сырые и дальше под каждого пользователя начинаете
их фильтровать.
Обработанные данные лучше, занимают меньше места,
в этом плане лучше, да, занимают меньше места, уже произведен
расчет предварительный, да, не знаю, прям конечный,
и вы сохранили результат, но доступ к сырым данным
у вас уже не, ну вы можете, конечно, хранить то и другое,
но, как правило, кроме скорости отклика у вас есть еще вот
этот вопрос цена, и вот этого у вас просто тупо меньше,
чем жесткого диска, и как правило раз так, не знаю,
в 40-50, и за вот эту историю у вас бьются и процессоры,
и процессы, и базы данных, и вообще все, да, вы не сможете
положить все кэш, вам придется выбирать.
Ребят, я не знаю, какой будет проект, но я описываю
варианты, да, то есть выбирать между этим и этим нужно
действительно на основе того, как эти данные будут
использоваться. Дальше, что еще? Обработанные данные.
Посчитали, сложили, там, я не знаю, здесь огромное
полотно, здесь отфильтровали, вычинили нужные столбцы,
просуммировали, положили.
Дальше. Согласен. Представление.
Там, с простым языком, готовый HTML-блог, ну, например,
вы будете вводить погоду как-нибудь красиво, бачок,
кусочек Москва, пасмурно и так далее, да, и вы будете
вводить филтрование, вы будете вводить филтрование,
вы будете вводить филтрование, вы будете вводить филтрование,
вы будете вводить филтрование, вы будете вводить филтрование,
вы будете вводить филтрование, вы будете вводить филтрование,
вы будете вводить филтрование, вы будете вводить филтрование,
вы будете вводить филтрование, вы будете руководить, вы
будете вводить филтрование, вы будете PuS Ducking access, вы
будете вводитьharma, вы будете вводитьzamп Omni Linux
voluntary data, вы будете вводить Metal Users, order 리�트黃profit,
при каждой построении рисовать это штемель в лодке можно, но это не самый
выгодный вариант. В данном конкретном случае это не самый выгодный вариант.
Нет, ты картинки туда не вставляешь, вот сюда. Да, то есть картинки, ты вставляешь на них ссылки.
Ну да, данных здесь побольше хранится, чем вот здесь. Если ты хранишь два числа,
я не знаю, состояние облаков и температуру, а здесь у тебя уже маленький штемель кусочек,
но это всё равно небольшие различия. Здесь тебя, не знаю, 10 байт, а здесь 100.
А это может быть не очень много, да, не очень большая разница и не очень важно,
но времени может экономить много. Например, если ты действительно на каждой странице хочешь его.
Ладно, дальше, четвертый вариант. Что еще? Куда дальше? Чем можно еще хранить?
Да, целая страница. Если вас когда-нибудь спросят, я вам этого не говорил, но это очень удобный,
не простой способ. Ну, представли, ну, HTML-блог, представление данных. То есть это обработанные,
то есть смотри, сырые данные, полностью просто вытащенные из базы или поднятые из диска. Здесь
мы над ними немножко поработали, что-то посчитали, как-то их пересчитали, сохранили в удобном для нас
виде. Здесь мы их начинаем оформлять. Они же тебе все равно не выводятся, ты же не можешь отдать
краузеру кусок данных. Ты их должен оформить в язык, который он понимает. HTML или JSON или еще
что-то, да. Но в любом случае ты должен произвести какие-то манипуляции, оформления. Потому что здесь
у тебя блог этой странички, а здесь у тебя целая страничка. Чем отличаются? Давайте прикинем. Ну,
как минимум. Ну, грубо говоря, вот у тебя, хотя любая страничка состоит из десятков,
разных. Когда я говорю любая страничка, это практически любая страничка. Те же самые
принципы каширования в мобильных приложениях, те же самые принципы каширования в банкомате,
в мобильных приложениях по большому счету. Все одно и то же. Логика одна и та же. Кто? Банкомат?
Понятия не имею. Надо подумать. Вот давай подумаем. Вот страничка банкомата. Кнопка
баксы, рубли, снять, оплатить и так далее. Вот здесь баланс. Здесь инфамилия.
Выгодно нам кашировать целую страницу?
В смысле, в нечастке? У меняется каждый... У тебя люди приходят в разные банкоматы. У тебя вот этот
блок, у тебя вот этот блок и вот этот блок меняется каждый раз. Ну, подожди, тогда зачем нам
кашировать всю страницу? Понимаешь? Да, вот для такого подхода самый лучший вариант каширования
представления с мельбоком. Кнопка оплата, кнопка снять баксы, снять рубли, она всегда одинаково выглядит.
Я утрирую. Давай поставим, что это главная страница Яндекс. И здесь у нас есть имя пользователя,
есть он залогенен. Там, я не знаю, погода, новости последние, блок рекламы, что-нибудь еще. Логотип.
Вот вы бы как кашировали блок Яндекс? Логотип на это всегда. Имя не Яндекс, а ваше имя, если вы залогенен.
И также кусочек про сколько у вас писем или сколько там еще чего. Итак, придумываем каширование для
главной страницы Яндекс. Куча различных информационных блоков, новости, погода, курс валют, я не знаю,
что еще там у него есть. Последние какие-нибудь там, не знаю, закачанные картинки, видосики и так далее.
Ну, в общем, короче, много разных блоков. Имя, мое, если я залогенен. Ну и логотипчик оформления.
Вот давайте так еще раз. Стоп, стоп, стоп, стоп, стоп, стоп. Мы пока не можем договориться. Что происходит?
Вот смотрите, вот есть кэш. Я начинаю вычисление. Пришел запрос в первый раз. Я начинаю вычисление.
Мне сначала нужно проверить, есть ли информация, которую мне нужно вычислить в кэше. Я делаю запрос. Есть информация?
Мне говорят, допустим, информации нет. То есть если информация есть, то как бы все, конец. Я нашел то, что мне нужно.
Вычисление одного блока. Если информации нет, я начинаю ее вычислять. Вычисление. Вычислил. Потом положил кэш.
И потом уже конец. То есть кэш не бесплатно делать. Если вы выйдете для какого-то элемента кэш, вы всегда будете проверять, он есть или нет.
Этот поход у вас тоже занимает время. Вопрос на это? Да. Мы сейчас говорим про серверный кэш?
Это не бесплатно. Нет золотого инструмента, золотой пули нет. У вас каждый раз есть плюсы и минусы. Можете внедрить кэш? Можете.
Но имейте в виду, что время выполнения каждого запроса чуть-чуть увеличится. То есть у вас, например, вычисление занимало 100 миллисекунд, а поход к кэш занимает 10 миллисекунд.
Теперь у вас каждый запрос, который вычисляет данные, которого нет в кэше, будет занимать 100 миллисекунд. Но каждый запрос, который в кэше есть, будет занимать всего 10.
Это называется так называемый параметр hit-miss.
То есть сколько раз вы попадаете, вот идет поток запросов. Сколько раз вы попадаете в кэш, сколько раз вы не попадаете в кэш. Итак, внимание, вопрос. Вот для вот этих параметров.
Учисление 100 миллисекунд, а кэш, ухождение в кэш занимает 10 миллисекунд. При попадании 70 процентов имеет смысл, нет? Вот входные параметры.
70 процентов попаданий, то есть 70 процентов кэш находит. В кэше находится то, что нам нужно. Есть миллисекундное ожидание, 100 миллисекундное вычисление.
Правильно ли я сделал, что внедрил кэш? В среднем.
Ты совершенно прав, еще вот здесь плюс здесь.
Нет, не любой. Сейчас посчитаем. Вот, хождение в кэш 10 миллисекунд. Давайте даже так, не будем его считать, просто для простоты.
Итак, все очень просто. Даже без статистики, на пальчик. В 70 процентах случаях у нас запрос...
43, окей.
Среднее время выполнения запроса у нас, средняя температура по больнице 43 миллисекунды.
Считаем один, не будем париться. 140, окей. Это лучше, чем 100. Давайте смотреть дальше. 90.
Давайте посмотрим, насколько. Сколько? Хорошо. 30 процент на пропадание кэш.
Ну, правильно 120, конечно, но я просто для простоты. Я считаю, что вот так, 5,5.
Блин, за ноды. 10 ноль, все, это бесплатно. Нет, все равно где-то будет. Здесь у нас 80, да?
Ну, короче, вот в этом нашем конкретном примере, да, то есть где-то есть эта цифра. И она не ноль, она больше ноля. 20 процентов, 10 процентов, где-то мы сломаемся. Сколько, 10? 10 процентов мы ломаемся.
Это вот в этих параметрах. Они могут быть другие. То есть вам стоит, когда вы это состартуете, когда вы думаете, как вы будете делать, стоит посчитать.
Так, возвращаемся к Яндексу. Какие у нас здесь элементы меняются, какие нет? Вот к Яндексу. 100 тысяч запросов в минуту.
Что бы вы здесь кешировали? Почему все, что не пользовательское?
Ну да. Даже новости можно кешировать. Потому что они вряд ли обновляются каждую минуту.
Да. И так вот все правильно. Кешируем все, что не персонализировано. А почему персонализированное не хотите кешировать?
От чего зависит? Давайте подумаем.
Давай так. Кэш фамилии можно записать дофига. Можно записать миллион, сто миллион. Фамилия-то что она?
Ну, подожди, смотри. Ну да, все правильно. Давай думать просто какое уравнение.
Итак, первое. Имя пользователя, возможно, вычисляется не быстро. Потому что там не только имя, там еще количество, например, последних сообщений в нем, в почте, еще чего-то, еще чего-то.
Вот такой блок, довольно стрёмный. Вычислять его долго. Но, если он у нас в кэше есть. Короче, здесь у нас, я к чему веду? Здесь у нас как бы с вами, ладно, у нас с вами двухуровневая hit-miss, вот это вот соотношение hit-miss двухуровневая.
Первое. На первом уровне оно касается самого пользователя и третьего самого пользователя. А на втором уровне это тоже нужно на более высоком. Это тоже нужно учитывать. А какой вообще процент пользователей за логинин?
Сколько пользователей за логинин?
Окей, то есть если пользователь не за логинин, то мы показываем там заглушку, а если за логинин, то идем по длинному пути.
Ну, можно. Смотрите, я к чему. Если неизбежно придется ходить в кэш, то есть нам для того, чтобы вывести им фамилию, нам неизбежно придется ходить в кэш.
То есть если мы обнаружили на первом этапе, а там что пользователь за логинин, что какая-то кука с логином, с авторизацией у него есть, нам все равно идти в кэш.
Ну, давайте думать. Я сам запутался. Так, стоит ли Яндекс кэшировать? Яндексу срочно нужно знать. Стоит ли ему кэшировать пользователя? На что мы будем с вами опираться?
Ну, давай, допустим, за логининов у нас 80%. 80% у нас за логинины.
Как часто? Вот. Вот, я понял, смотрите. У нас вот этот вот параметр hit miss radio, его нужно считать не для всех пользователей сразу, а для одного.
Думаете? Да, для всех пользователей бессмысленно, он очень низкий, он никогда не сыграет, но проблема в том, что у нас пользователь приходит и начинает по сайту ходить.
И вот со время жизни его сессии. То есть у нас, грубо говоря, пользователь приходит в первый раз. В первый раз у нас этого параметра, про него ничего мы не знаем, и у нас там пусто.
Но потом он по сайту ходит, он что-то ищет. Он же не просто набрал главную Яндекс посмотреть, какая она красивая, он что-то пришел, поискал, посмотрел, побродил 1-2-3 странички, посмотрел и потом уже свалил.
Вернется... Сейчас поговорим, сейчас поговорим о том, где хранить. То есть, по большому счету, у нас в данном конкретном случае, у нас сообщение hit miss radio выражается в то, сколько сессий он посмотрит.
Сколько страниц в среднем он смотрит за 1 проход, за 1 сессию.
И вот в этом выражении, вот здесь, в вычислениях, у нас будет уже, мы будем считать экономия по страницам.
Давайте вот точно так же. У нас 100 миллисекунд занимают расчеты, 10 миллисекунд занимает хранение. Проход в кэш. И пользователь смотрит 5 страниц.
Это означает, что у нас первый поход 110, правильно? И еще 4 по 10. И все это делим на 5. Получилось? 30.
Сейчас поговорим. Мы уже два вопроса, которые ты бросил, с которыми нам можешь поговорить. Это вымывание данных из кэша и... Так, окей. Это если 5 страниц. А если 2? Все еще хорошо.
Это не страница кэша, это страница, сколько он смотрит за 1, за 1 сессию пользователей. Потому что первый у тебя поход большой.
У тебя всего 5 страниц. Первый из них будет первый, тебе нужно данные посчитать, поэтому он будет расчет плюс сходить в кэш, а все остальные будут только сходить в кэш.
1, 2, 3, 4, 5. Не страницы. Мы их кладем в кэш, пока только им по миллионам. Сколько страниц он в среднем посмотрит? Сколько раз нам эта информация потребуется?
Хорошо, с двойкой тоже просто. А от какой-нибудь параметром типа 1 и 2, средней температуры по больнице начинается уже история. Уже надо будет думать.
А там скорее всего где-то что-то такое. То есть там вряд ли какое-нибудь большое целочистое. Так, что кэшировать, разобрались. Надо, не надо кэшировать, более-менее разобрались. Теперь где кэшировать?
Давай.
Это действительно хороший вопрос. Мы довольно сильно натянули сову на глобус. Не факт, что так будет. То есть по-хорошему, именно сколько в течение сессии, и сколько длится сессия.
Еще и это нужно учить. Если сессия у него в среднем 30 минут, то за это время информация протухает. То есть у тебя всегда для этих расчетов по большому счету добавляется еще один параметр.
А именно, как часто меняются эти данные? Имя не меняется. Мы же там храним, например, еще количество писем, которые не открыты.
Сейчас поговорим. Не гони. Что решили? Где? Какие у нас варианты? На сервер или у клиента? Если мы у клиента храним, в чем плюс и минус?
У клиента есть просто одна колоссальная задница, если мы храним эту информацию у клиента. Он может удалить. Это не самая большая, потому что в этом случае он просто сходит к нам и еще раз сидит.
Вы ему не понравились?
Для безопасности может плохо, да?
Но это все равно не самая большая жопа. Самая большая жопа в чем?
Тоже не самая большая жопа.
Ну, пофиг. Мы же ему в компьютере нагадили. Пусть лежит.
Да, у вас нет инструмента для того, чтобы эту информацию управлять.
А если он... Нет, ну подожди. Этот инструмент заключается в том, что ты ему говоришь, насколько сохранить. Сохрани.
Ты ему сказал, сохрани, например, на месяц. У тебя нет возможности, если у тебя что-то случилось, взять и изменить эту ситуацию.
Сейчас месяц не прошел. Второй день идет.
Это исключительно пассивный метод кэширования, скажем так. То есть положил, и оно лежит. И все, оно будет лежать сколько-то.
Как?
Кэш? Нет, это браузерная история. Ты браузеру сказал, сохрани вот эту картинку навечно.
Можно ли Джаваскриптом сказать вот этой картинке, измени время хранения? Я не уверен, что это может.
Да, можно. Но если у тебя какие-то... Ну да, просто заменить. Это если мы речь идет про картинку, а если речь идет про какие-то сложные данные, кусочки данных.
Точно так же работает. Кукифайл это маленький кусочек, который у тебя...
Так, давай вопрос еще.
Да, но ты ему сказал, ты ему в начале пути говоришь, сколько ты будешь жить этому файлику, этой куки.
Ты этой куки говоришь, эта кука действительно на месяц. Все, забудь, в течение месяца ты не властвуй над ней.
Она сохранилась в браузере. Не у тебя, не в Джаваскрипт-коде, ты не имеешь доступа. Браузер месяц не прошел, отправляю куку.
Ты уже хочешь ему проорать, ну сходи, спроси у меня, валидная ли это кука. Браузер это просто делает до тебя, до всех запросов.
Сейчас уже сложно себе представить, но раньше были такие конструкции, чтобы браузер мог поднять тебе, показать тебе страницу, не ходя в интернет вообще.
Ну сейчас можно, но как правило так никто не делает, все страницы махровые, толстые, Джаваскрипты, все прочее.
Короче, это можно сделать. Браузер все сохранил у тебя, у себя. Если ты надавал правильную заголовку, он все сохранил, он тебе даже не пошел.
У тебя сайт уже закрылся неделю. А браузер тебе все показывает, то и показывает.
Это круто, если тебе не нужно ничего менять. Действительно, у вас есть два варианта. Вы можете отдать максимум пользователю, а можете сохранить у себя на сервере.
Обычная логика это отдать пользователю все возможные картинки. Все, что реально не меняется годами.
Картинки, видосики, логотипчики, CSS, и так далее. А потом менять феш в названии или менять какую-нибудь буковку в названии, если что пойдет не так.
Память пользователя? Совсем не жалко.
Он же тоже не дурачок. Он уже научился периодически кэш-чистить и все такое. Именно против таких разработчиков, как мы.
Данные, как правило, у пользователя не хранятся. Как правило, нет. Некоторые проекты используются в истории, но как правило все кэширование данных используется на серваке.
Так, теперь проблема ограниченности кэша. Да, то есть кэша у нас скорость отлика растет, но цена тоже растет. Рам дорогая.
И мы не можем сделать бесконечный кэш и положить в него все. Есть так называемые стратегии вытеснения.
Какие вы знаете стратегии вытеснения? Вы должны были проходить, по-моему.
Ну, в общем, как бы две самые...
Пифо, пифо. Да. LRU.
Когда устанавливаете кэш, подумайте в том числе об этом. Что это означает? Это означает, что будет происходить, если место в кэше кончилось.
Вот место в кэше кончается.
Last, recently used. Наименее часто используемый. Самое редкое использование.
Первый вошел, последний вошел, первый вышел, первый вошел, первый вышел.
Ну, вот это для кэша это, конечно, бессмысленно. Вот эта история для кэша бессмысленна. Это stack.
Вот в этой стратегии у тебя тупо уничтожается самый старый.
Ну, то есть вот как бы ты кладешь в кэш потихонечку? Уничтожается?
Да, ты прав. Нет, подожди. Нет, все правильно.
Да, все правильно. Самый старый. Это, грубо говоря, конвейер. Вот сюда кладешь, отсюда он сваливает.
Вот это самое часто встречается. Чаще всего встречается в кэшовых программах, потому что она простая и тупая.
Вот это самое правильное по ловке вещей. Но вот подобная стратегия, то есть предполагать, что кэшу в самой программе кэш,
это тоже программа, которая у вас на серваке работает, ей нужно вычислять постоянно и следить за статистикой.
Не все кэши это делают. Не все кэши это умеют делать.
Ну, в общем, вы должны иметь в виду о том, что всегда кэш – это не тот инструмент, который можно положить данные и надеяться, что они там есть.
Их там может не быть по десятку причин. Перезагрузка. Кэш только стартовал. Процесс кэша прибили.
Я не знаю. Бешеный сисадмин. Хаосманки сработал. Знаете инструмент хаосманки? Бешеный обезьян.
Вы спроектировали проект, вы его запустили на нескольких серверах, еще что-то он работает на нескольких процессах, потом запускается хаосманки.
Хаосманки – это бешеная обезьянка, которая в случайном порядке прибивает процессы, работающие на ваших серверах.
Вы не знаете, какой она убьет. У нее нет ограничений. Просто что-то случайно проверка на отказу устойчивости системы.
То есть что произойдет, если у тебя что-то закрэшится? Она может прибить, я не знаю, операционку.
Ну а чего? Если у вас масштабируемая система, работающая на нескольких серверах, ваш проект должен продолжить работать.
Вы не знаете раньше, что умрет диск, операционка, память посыпется, какой-нибудь процесс где-нибудь сдохнет и так далее.
Вот хаосманки имитируют работу вот такой случайных проблем.
Короче, но самая часто встречающаяся причина, почему данных нет, потому что кэш решил их вычистить по какой-то своей внутренней логике.
Там могут быть какие-то сложные процессы. То есть LRU сложно вычислять, потому что нужно за каждым элементом кэша следить.
Ну бывает какие-то комбинации, еще что-то, там может что-то думать. Короче, полная жесть. Мы над этим, как правило, не властны.
То есть даже если вы говорите, сохрани этот элемент в кэше на час, вы не можете быть уверены, что через час он там все еще будет.
Что он там через минуту будет, вы не можете быть уверены. Это вот первое правило работы с кэшом.
Он ее использует как рекомендательную, вот так скажем. То есть больше он хранить не будет. То есть 61 минуту он не прохранит.
Вот это можно сказать гарантированно. Но 59, 59 тебе тоже не гарантировано. Очень важный момент, ребят, про кэш.
Я идем дальше. С кэшом говно и боли очень много. Это сложно. Как вообще в принципе происходит работа с кэшом?
Ключ значения. То есть, как правило, кэш хранит ваши данные по ключу. У вас есть ключ, некое уникальное значение.
А кэш обещает, что он вам по этому ключу достанет данные. Что такое ключ? Ну это может быть, например, mindpage. Какая-то строка.
Mindpage это как бы главная страница. Как угодно вы можете назвать. Можете написать главная страница.
Самое важное, чтобы все части вашей программы, все элементы вашей программы или все, кто ходит в этот кэш, знали о том, что по ключу mindpage кэш вернет в ним кусок главной страницы.
То есть, по большому счету, для того, чтобы нормально кэш заработал, вам нужно придумать, достигнуть некой договоренности о том, как вы именуете элементы ключей.
Ну как вы именуете ключи. И как храните данные. Вот вы договариваетесь один раз. Mindpage. И все, все между программистами сидите, в 20 ром программируете один тот же код. Договорились. Mindpage.
Так. Подкидываю вам проблему.
Наверняка как. То есть, когда вы производите операцию положить в кэш, вы указываете ключ, вы указываете данные и вы указываете время.
Насколько. Сколько эти данные валидны. Вот этот вот минимальный, минимальный набор. Ключ и время. Ключ, время, данные. Ключ, время, данные.
Первая проблема. Ну представьте себе, что ваш компьютер перегрузился. В кэше ноль.
Перегрузился. В кэше ноль.
Кэш пустой. Что будете делать?
Да, окей. Ну тогда, конечно, диски можно хранить, но тогда у нас все замедляется.
Лениво сбрасывать. Иногда дампить. Хорошо, окей. Но там вообще это может быть дохрена.
Кэше. Несколько гигабайт.
Хорошо.
Еще раз. Перед загрузкой положить.
Не, может быть случайная история. Эскаватор. Самая любимая тема наша.
Перерывает кабель.
Мы не знаем. Ну давай так. Допустим мы его, допустим мы его пытаемся сбросить на диск. Хорошо.
Но если он большой и сбрасывает, то мы можем лениво. А читать лениво мы не можем. 8 гигабайт поднять диск, например.
8 гигабайт абсолютно нормальный. Размер кэша.
8 гигабайт. Сколько собираешься его читать? Ты будешь несколько минут читать.
Ну ладно.
Окей. Итако. Проблема, которую мы сейчас решаем называется холодный старт.
Это нужно холодный кэш не прогретый. Это сленг. Прогретый кэш это как раз кэш, который заполненный.
Отвечает все самые часто встречающиеся вопросы в нем есть.
Холодный старт. Кэша нет. Первый ваш вариант сбрасывать все на диск.
Сбрасывать все на диск. Минус этого варианта в том, что очень длинная будет загрузка.
Прям очень длинная будет загрузка. Вы будете качать весь кэш.
А там есть данные, которые прям очень нужны. Данные, которые нафиг не нужны.
Данные, которые уже протухли 10 раз и так далее. Пока не закачаете, не узнаете.
Так-так. Плюс закачивать. Еще варианты. Как будете решать?
Да, но это же у тебя вал запросов. У тебя кэш пустой.
То есть у тебя каждый запрос первые несколько минут будет вычисляться.
И дальше начнется жопа, которая называется гонки.
Ты будешь каждый запрос вычислять. У тебя будет вычисляться все меньше и меньше и меньше.
В смысле медленнее и медленнее, потому что у тебя процессор будет перезагружен.
У тебя соответственно еще больше. И вот такой вал пойдет.
Ну, подожди. У тебя кэш, как правило, единый для всех бэкэндов.
Нет, это как раз хорошо, потому что иначе у тебя и не может быть.
Ну, он не должен на одном серваке быть. Окей.
Ну, давайте. Это очень сложно.
Хорошо, второй вариант. Это просто надо распределить его.
Но. Вы, как архитекторы, всегда должны искать самый простой способ решения проблемы.
Вот когда ты хочешь себе сделать распределенный кэш, ты себе раз фига и фонд оплаты труда увеличиваешь.
Есть инструменты, но ими тоже нужно уметь пользоваться.
Создаешь новую точку отказа, за ней нужно следить и так далее.
Задачу решаем самым простым способом. В большинстве случаев, в 90% случаев ваш сайт, в 99% случаев ваш проект влезет на один сервак.
В 99,5% случаев тебе никогда не потребуется распределенный кэш.
Просто потому, что тебе достаточно будет одного.
Я, если честно, почти по-моему не знаю кэшей, которые так умеют делать.
На самом деле таких инструментов нет. Почему-то их нет. Я думаю, что какая-то есть логика.
Хорошо, сбрасывать не все. Это вариант.
Если есть такой инструмент.
А более простой способ есть?
Чтобы не нагружать диск, еще что-нибудь. Какой-то более простой способ.
И закачивать, потом не стартовать, кучу времени, пока у тебя несколько гигабайт скачать.
Ну это радикально.
Извините, ребята, у нас кривые архитекторы, поэтому вы подождете.
Нет, так не пойдет.
А давай придумаем вариант, который нам позволит и работать при холодном старте, но при этом никому не отказывать.
Думайте.
Может быть, отказать некоторым запросам.
А в какой момент ты перейдешь к другой схеме обратно?
А если будет, то мы его...
Как ты это программировать будешь? Как ты это будешь поддерживать?
У тебя кто-то должен будет считать этот запрос, куда относится каждый раз.
Это все очень сложно, проще.
Я пока воспользуюсь волшебным инструментом.
Да.
Огонь.
Так, ну...
Давайте, давайте, давайте, давайте.
Очень простое решение.
Ты же его предложила, по-моему?
Да, ты, ты, ты.
Вспоминаю, что ты предлагала.
Нет.
Это неправильно.
Ну...
Итак, в чем у нас проблема?
У нас проблема в том, что у нас идет вал запросов.
Идет вал запросов.
Во время старта.
И мы боимся под этим валом запросов валить.
Но, ну, например, допустим, у нас обычный новостной сайт.
Чем характерен новостной сайт?
Вообще любой проект чем характерен?
Правила Парета.
Ну, а теперь свяжите это все.
Так.
И что с этим можно сделать?
Да блин, ребят, у вас...
На главной странице любой новостной сайт...
Не знаю, 80...
Ну, не 80, хорошо.
30% запросов это главная страница.
Одна.
Закешировать одну главную страницу.
И вы сократили себе...
Улегчили жизнь на 30% уже.
Да.
Масильный прогрев.
Перед тем, как стартануть...
Выполнить и положить кэш...
Кэш...
Те самые часто встречающиеся страницы.
Потому что здесь ты не знаешь, что ты закачиваешь.
Ты закачиваешь просто большой блок.
Его закачивать долго.
А здесь ты выполняешь 100 запросов.
Это просто на порядок быстрее будет.
Скорее всего, это будет быстрее и проще.
Потому что вот здесь тебе нужно...
Для того, чтобы...
Если ты хочешь закачивать, например, не все...
Тебе нужна какая-то очень сложная...
Сама вот эта вот программа кэширования,
которая будет за собой следить,
LRU считать и так далее.
А здесь все очень просто.
Очень тупо.
Тупое решение. Самое хорошее.
То есть просто надо просто стартуйте.
Запускайте.
Вызывайте 100 страниц сайта.
И все.
Даже специально ничего не надо писать.
И вы гетом.
Делайте запрос к сайту.
На 10 страничек.
Положили их в кэш.
Ну, в смысле, пока вы их делаете,
сайт их сам положит в кэш.
То есть он же вычисления производит и так далее.
И только после этого отпускаете пользователей.
И у вас значительная часть нагрузки прогрета.
Она работает.
Так.
Идем дальше.
Это еще не все.
Ну, почему?
Ты же можешь...
Ну, вообще, ты, скорее всего, знаешь,
как работает твой проект.
Ты знаешь, что есть главная страница и так далее.
Да, может, не повести.
Но...
Ну, как бы, с чего бы это?
Если все конкретно читают какую-то конкретную новость,
например, на какую-то конкретную страничку.
Да нет, скорее всего, знаешь.
Оставь...
Оставь...
Первыми запросами от пользователей...
Почему мы прогрели?
Потому что пользователи...
А что делать все остальные?
Пользователи ломанутся сразу все.
Ты не можешь взять первых 100 пользователей,
обслужить их,
остальных заставить подождать.
Вот.
Да.
То, к чему мы приходим сейчас.
Любимая тема
всех High-Load-разработчиков.
Race Condition.
Итак, у нас есть
клавиатуры.
Ну, я не знаю,
как это делать.
Ну, я не знаю,
как это делать.
Ну, я не знаю,
как это делать.
Итак, у нас есть кэш.
В нем есть...
В нем лежит
главная страница.
Так, слушай меня. В нем лежит
главная страница. Итак, главная страница
протухла.
То же самое означает все.
Она больше не работает. Она больше
не валидна.
В кэше
данные старые, устарели.
И вот идет
запрос первый. Встречает о том, что
главная страница протухла.
Начинает ее вычислять.
На вычисление у нее, например, уходит
100 миллисекунд.
Не очень много.
Но это главная страница.
И за 100 миллисекунд еще
пять процессов придут и обнаружат, что
главная страница протухла.
И начинают ее вычислять.
Что делать?
То есть мы тупо
греем воздух.
Хорошо, если их всего пять.
А если их, например, пятьдесят,
то тогда вот этот процесс,
когда придет, столкнется
не знаю, пятидесятый процесс,
столкнется уже
с конкретным возросшей нагрузкой
на сервах. И его вычисления займут
уже не сто миллисекунд, а
тысячу или хотя бы двести.
За эти двести миллисекунд
произойдет что? Еще прибежит сто.
И вот этот вот сто пятидесятый
столкнется, что серверу нашему
конкретно плохо.
Поняли, да, проблему?
И здесь у него вычисления займут
уже тысячу миллисекунд. И все.
Наш сайт лег.
Гонки.
То есть вот кто быстрее?
То есть как бы этот, этот, этот, они все
одновременно начинают вычислять одно и то же.
Поэтому гонки.
Не, подожди.
Когда он закончил,
они уже перестали.
А, ты имеешь в виду, что где-то здесь это
закончится? Ну да, согласен.
Вот этого у нас не будет.
Но у нас сайт может
лечь за одну,
за как бы за одну институт маленькую,
за один промежуток.
А как мы будем делать?
Как нам быть?
Так. Хорошо.
То есть первое предложение,
что вот этот вот чувак не просто начинает
считать, но и ставит где-то
флажок о том, что он считает.
Где?
Где ему ставить этот флажок?
Как мы узнаем, что страница протухла?
Нам кэш ничего не возвращает.
Мы сделали запрос по ключу
MainPage в кэш, кэш нам сказал.
Ничего нет.
Это фонд оплаты труда
даже не на 10,
это на 30%
увеличил
одним словом.
Одним словом mutex, да.
И потом.
Есть еще проблема.
У тебя это все может происходить
на разных серверах,
на разных бэкендах.
У тебя несколько бэкендов,
у тебя несколько бэкендов
пользуются одним кэшом.
Мы ей сказали
закэшируйся на час.
Час прошел,
она протухла.
Ну, давайте, где мы флаг
будем хранить?
Где распределенно мне?
Какое распределенно?
А?
Нет.
Проще.
Давайте проще.
Окей.
В кэше согласен.
А где в кэше?
Отдельный ключ
сделаем.
И такой делаем ключ
который называется
MainPage.
Run.
И в нем будет единичка или нолик.
И единичка что будет означать?
Единичка или нолик?
Единичка будет означать
что в данный момент
процесс считается.
А нолик что?
Даш, что никто не считает.
Окей, мы написали единичку.
Вот этот процесс
написал тогда единичку.
Проработал половину времени
и сдох.
Бывает.
Не, на нескольких машинах
как правило.
То есть мы говорим о том, что вот эта единичка
валидна
100 миллисекунд
или 200 миллисекунд с текущего момента.
Умер процесс.
Процесс вычисляющий, который
единичку поставил, он помер.
Вы хотите установить
этот ключ на 200 миллисекунд.
Ну нормально.
Установили, окей, хорошо.
Мы можем
отметить, что процесс внезапно помер.
И тогда кто-то,
через 200 миллисекунд
он вновь
получает здесь пустоту.
И вновь ее
занимает. Хорошо, что с остальными?
Остальным что делать?
Вы не можете их подвесить.
Это невозможно.
Мы как?
Подожди, а как?
Ты сказал
закешировать главную сравнительницу на 1 час.
Все, через
час кэш тебе говорит.
Нет.
Мне ничего не плачет.
А как мы тогда будем собираемся
узнавать о том, что
она все-таки реально протухнет?
Это что-то из цивилизации.
Это не...
Нет.
А как
ты будешь проверять?
Подожди, кэш
очень простая штука.
Ключ значения, время.
А как
ты посмотрел
по ключу?
Это время
устанавливается только
в момент
выполнения
процедуры
загрузки в кэш.
После этого она тебе недоступна, ты его не можешь вытащить.
Кэш тебе его не
отдает, он где-то внутри хранит.
Хорошо, я понимаю все, что ты говоришь.
Ты можешь внутри данных
хранить.
То есть данные могут быть
сложными.
Данные могут быть
сложными.
Данные, которые вы храните по ключу,
это может быть массив,
в котором первое это данные,
а второе, например,
время.
Можно?
Только мы это
только что придумали.
Итак,
мы с вами
устанавливаем вот это время,
системное время кэша,
надолго, не на час,
не знаю,
на 100 часов.
Туда мы сохраняем данные,
а вот здесь мы пишем,
ну я не знаю, что мы пишем.
Время, когда мы обновили.
Время, когда мы обновили, да.
Окей, хорошо, мы пишем время
обновления.
Теперь вот здесь
первый запрос пришел.
Сделал запрос по ключу,
поднял вот это данные и вот это вот время
обновления. Проверяет время обновления.
Прошел час,
то есть как бы валидно еще вот
эти данные или нет.
Причислил, получилось 60, не знаю,
61 минуты.
Невалидно. Все, ставлю вот этот
вот положок на 200
миллисекунд, начинаю вычислять.
Второй запрос пришел.
Берет данные по ключу
отсюда, смотрит,
так, данные
невалидны, их нужно начать вычислять.
Проверяет, могу ли я начать
вычислять? Нет, нифига не
могу, кто-то уже занимается этим.
И тогда я что делаю? Я отдаю
вот эти старые, устаревшие,
протухшие данные пользователю.
Ну и что? Это зависит от данных.
В большинстве случаев можно.
Потому что здесь
речь реально о
100-200 миллисекунд, которые тебе
помогут избежать гонок.
Да?
Соответственно все запросы, которые
приходят, попадают на вот этот период
пересчета, они вот так работают.
А второй кусочек,
первый процесс, досчитал
и обновляет
и данные, и время обновлений.
Что вам еще дает то, что вы сюда кладете
время обновлений?
Не вот сюда вы кладете, не в системное
время кэша, вы говорите
о том, что это живет только день,
только не знает час, а вот здесь,
что вы каждый раз вычисляете, что вам это
помогает?
Его легко менять.
Вы можете
осуществлять ту самую деградацию функциональности.
Вот БАД за это время
Россия еще на кого-нибудь напала.
Все, опять понеслась
новости, еще что-нибудь, еще что-нибудь.
Просто увеличивать это время.
У вас здесь уже теперь не час
проверка, а, например, три.
Ну, это смотря на сколько
если у тебя
продуктовые ребята сильнее,
они заставят тебя время уменьшить.
А если архитекторы, то они время
увеличат, потому что нагрузка растет.
Все прибежали,
смотри.
А ты же каждый раз, когда
ты кладешь вот эту вот пару
вот эту вот пару,
вот эту вот пару,
кладешь вот эту вот пару,
ты эти 100 часов прибавляешь.
Ну, в смысле, ты вот эту пару кладешь
на 100 часов вперед.
На 100 часов вперед.
Из головы.
Почему не сделать вечный?
Можно сделать вечный?
Можно сделать вечный, да?
Сколько угодно.
Ну, не важно, просто главное, чтобы больше, чем
время. Так, ребят,
с кашом еще не все.
Сколько времени нужно?
Хорошо.
Ну, я вам
одну задачку надам.
Знаете,
что еще можно сделать?
Можно вот эту вот штуку тоже сюда
внутрь положить.
Как иногда делают.
Можно?
Можно, не обязательно.
Так.
Так умирает вот эта история.
Флага?
Да, окей, а флаг может быть
просто... Согласен.
Можно так, да.
Можно флаг точно так же через время сделать.
Да.
И 200 секунд сомнем на часах.
Так.
Окей, а теперь
вот мы у нас все это сделали,
все это работает.
А теперь приходит редактор, скотина, и публикует
новость.
И мы должны
главную страницу сбросить.
Она не просто
устарела. Там данные
невалидные.
Нам нужно провести так называемую
инвалидацию кэша.
Что нам делать?
Итак, приходит редактор и публикует
новость.
Ну,
да, смотря
что мы храним внутри
этого ключа, конечно, но допустим
мы там умные ребята и храним только
реальные данные.
Без HTML, без всего.
Итак,
то есть первый вариант
это взять
и перезаписать значение
при записи.
Так?
Итак, к нам пришла новая новость.
Новость.
Мы берем
и тем же самым процессом,
который эту новость сохраняем,
перезаписываем кэш.
Перезаписываем.
Так еще есть вариант?
Нет, но
чем плохо тут вариант?
Давайте придумаем.
Давайте поймем.
Ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
во-первых,
если часто публикуется. Но это ладно.
Вряд ли она часто публикуется, скорее всего.
Здесь есть одна проблемка.
Она заключается в том, что мы потенциально
не знаем,
у нас с вами
простой такой пример, очень, очень
такой выхлопченный, примитивный.
Главная страница, кэш главных страниц.
Но не всегда мы знаем, где конкретно
которые мы сейчас перезаписываем, будут использоваться.
Они могут использоваться не только в MindPager,
они могут использоваться в десятках других мест.
Вот если мы говорим конкретно про новости,
то будет обновляться главная страница,
страница раздела, страница последней публикации,
страница автора этого,
страница тематики и так далее.
То есть количество кэшей,
которые нужно будет пересчитать,
оно может быть очень велико.
Некоторые из этих кэшей могут вообще никогда не использоваться
или очень редко использоваться.
Например, мы обновляем новость,
не то чтобы мы обновляем MindPage,
мы обновляем новости в Мухосранске.
Там 5 человек с интернетом.
Они заходят в интернет очень ред.
А ты все равно новость перезаписал.
И кэш перезаписал.
Мухосранск News.
Такой ключ у нас.
Вот тебе минусы этого варианта.
То есть ты не всегда знаешь,
что конкретно тебе нужно перезаписать,
потому что это может быть большая сложная система.
А второе, ты можешь зря перезаписать.
Можем.
Да, это принципиально другой вариант.
То есть в этом случае ты перезаписываешь кэш при сохранении новости.
При сохранении?
А вот здесь вариант.
Ты насильно его, как бы говоря, портишь.
Насильно протухаешь кэш.
Это не по-русски, но смысл такой.
То есть ты говоришь, что вот этот ключ более невален.
Если кто-то, кто сдачно столкнется с ним, пересчитывай.
Например, ты что можешь сделать?
Просто берешь и вот это данные обнуляешь.
Вот это вот у нас время.
Стираешь его.
Ставишь его в прошлое.
Еще что-нибудь.
И тогда, при первом запросе от пользователя,
у нас начнется вся наша петрушка.
Дайте пересчитать.
Здесь еще третий вариант.
Да.
Сейчас это обсудим.
Это время нужно менять во всех местах, где закэшированы эти данные.
Нет, здесь у нас несколько проблем.
Основная проблема, почему этот вариант не выбирают,
то то, что ты не знаешь заранее, этот кэш нужен кому-то или нет.
Он может просто никакому быть не нужен.
Редко используется.
Это первая проблема здесь.
А вторая проблема, которая здесь есть,
это то, что вычисления могут занимать много времени.
И не всегда.
То есть редактор, например, подождет.
А если это не редактор, а, например,
я не знаю,
какая-нибудь банковская система.
И нужно очень быстро принять платеж.
И она не может ждать, пока пересчитается кэш.
Вот как быть в такой ситуации?
То есть пойти по вот этому варианту.
Но не очень хорошо, потому что все-таки это долго вычисляется.
И мы ни в коем случае не можем показать пользователю устаревшие данные.
Да.
Но мы не можем это сделать при публикации.
Когда нам это делать?
Чего?
Устаревшие данные?
Не в любой системе.
В новостях – да.
Они не поймут.
Я сделал запрос, а у меня по-прежнему бабки на счету.
Или наоборот, мне перечислили, а денег нет.
Ну что за фигня?
Итого, бывают ситуации, да?
То есть новости – окей, хорошо.
А допустим, это деньги, приходит денег.
Может быть хороший вариант.
Просто нельзя кэшировать.
Может быть.
А если все-таки кэшируем, то как?
Пикс между вот этими двумя вариантами придумайте.
Еще варианты.
Итак, вот здесь мы
насильно его
удаляем, конечно.
Говорим, что он протух.
И мы его удаляем прямо сейчас.
При записи.
Если пересчитать при записи – нельзя.
Потому что долго.
Но и старая версия
кэширования удалять тоже нельзя.
Как нам быть?
Сначала что сделать?
Ты не можешь пересчитывать
именно в момент записи.
Потому что момент записи
тоже нужно быстро, это нужно моментально ответить,
что все, деньги ушли.
Давайте, давайте, давайте, давайте.
Обмануть.
Короче, вы говорите
клиенту, о том, что
окей, мы все пересчитали, деньги отправлены.
Это говорится клиенту.
Все окей.
И ставится задача на пересчет.
Потом мы протухаем кэш
на всякий случай, вдруг он такой быстрый, что
он, я не знаю,
из двух окон смотрит.
Мы протухаем, насильно протухаем кэш.
И тут же ставим задачу.
Пересчитай.
Поэтому мы насильно протухаем кэш.
Нет, подожди.
Смотри, там есть разное.
Если ты говоришь про
какую-нибудь платежную систему,
там есть несколько уровней
различного рода.
Понятное дело, что есть некий уровень,
на котором все фиксируется как есть.
Ты считал, у тебя деньги считались,
она тут же сюда записывается.
И она тебе
не пикнет до тех пор, пока она
не считает.
Но у тебя же не только это,
там еще есть какие-нибудь отчетики,
еще что-то,
у тебя может быть какой-нибудь личный кабинет,
какие-то цифры, отображения и так далее.
То есть есть контур,
в котором все абсолютно как есть,
а есть контур, куда-нибудь сменения докатываются,
где уже не так важно.
То есть, там не знаю, какое
банковское приложение, например.
Короче, да, так делают.
Иногда так делают.
То есть клиенту мы отдаем информацию о том,
что мы все сделали, чувак.
Мы стираем этот кэш,
говорим о том, что он неволидный.
И ставим задачу на пересчет.
И в фоновом режиме она считается.
Так, все.
Последняя проблема с кэшом.
С этим волшебным и очень
легким инструментом.
Последняя проблема. Она звучит так.
Итак, мы сбрасываем.
Пришла новость.
И нам нужно сбросить.
Кэш, главная страница.
Кэш, страница раздела.
Кэш,
последняя новость.
Кэш, новости,
где это произошло?
В Москве.
В Москве.
И еще сколько-то.
Мы не знаем заранее сколько.
Не то, что мы не знаем заранее сколько.
Но у нас сайт растет.
И данные построены.
Придумывают новые странички.
Продакты работают.
Что-то новое. Какие-то новые блоки.
Экспортируем новости на другие сайты.
И так далее.
Это механизм, который у нас при записи
мы его сделали.
Сохраняется новость на редакторский интерфейс.
У нас вариант.
Либо мы постоянно редакторский интерфейс апдейтим
и при любой добавленной
новой странички вносим информацию
об этом вот сюда.
У нас редакторский интерфейс
через какое-то время это какая-то совершенно
махровая, невероятная штука, которая знает вообще
все про наш сайт.
Либо мы придумаем какой-то другой способ.
Понимаете проблемы, да?
Так называемая когерентность кэшей.
То есть у нас некоторые кэши
связаны с друг с другом.
Что вот нужно сбросить
главную страницу. Почему?
Потому что там, блин, вот первая строчка
это последняя новость.
Страницу раздела. Почему?
Потому что первая строчка, последняя новость.
Какая новость?
Так сайт у нас спроектирован.
Красивый очень.
Новости в Москве, понимаешь?
Новости на карте.
Что угодно может быть.
Новости от определенного
автора.
Архив новостей, где они
уже не в хронологическом порядке,
а, например, там, я не знаю,
в алфавитном.
Что нам делать? Существует какое-то
энное количество кэшей,
и нам про них все знать, ну, очень
затратно.
То есть это нам нужно
строить некое дерево,
вот эти связи о том, что
если ты сбрасываешь,
если происходит событие,
новая новость, нужно сбросить один
кэш, например.
Второй и третий.
А потом еще кругами.
Если ты сбрасываешь
вот этот кэш,
нужно сбросить еще
четвертый, пятый и шестой.
А если сбрасываешь шестой,
то нужно еще и девятый захватить.
И понеслась.
Может такое быть? Может.
Что делать?
Жопа.
И наш красивый кэш разваливается.
У нас все было так хорошо.
Ну.
А как?
Лады.
В следующий раз вы мне рассказываете,
как кэши могут подписываться на свое
обновление.
Ой, нет, вот без вот этого всего.
Какой брокер сообщить?
У нас кэш и PHP.
Все.
Без мютектов
и локов. Нет.
Это запрещенные слова.
Все проще.
Надо придумать, ребят, это алгоритм.
Нужно придумать именно инженерное решение.
Без каких-то сложных...
Давайте так.
Ограничение. У вас есть только кэш.
Все, больше нет ничего.
Ну PHP. Да.
Я имею в виду, что
решение этой проблемы
допустимо с помощью кэша.
Можно решить с помощью кэша.
Это будет самое красивое и элегантное решение.
Думайте как.
Все.
Расходимся.
