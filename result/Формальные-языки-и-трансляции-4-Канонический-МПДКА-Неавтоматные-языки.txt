так всем доброго дня мы с вами продолжаем сегодня не знаю получится у нас быстро
или не получится но если что время перерыва украдем вот приношу извинения я думаю в следующих
парах у нас такого не будет значит сегодня нашей целью будет закончить тему вообще
связано с автоматами вот и чтобы в следующий раз мы могли перейти на другую тему я пока не
знаю кто будет следующую лекцию читать возможно я возможно виталий вот пока еще не решили ну
потому что мне возможно в какое-то место надо будет уехать вот дать вспомним что у нас было
в предыдущих сериях так это был спойлер кто умеет спойлеры читать никто что было на прошлой
лекции да первое что мы сделали мы доказали что по любому регулярному языку можно построить
конечный автомат по любому конечному автомату может построить регулярный язык ага что еще мы
с вами сделали да мы определили понятие эквалентных состояний в пдк и определили
понятие эквалентных слов по по языку и какой мы автомат с вами построили в конце прошлой лекции
мы построили по любому mpdk pdk без эквалютных состояний а на чем мы там не закончили по
мы в итоге вы закончили да мы закончили на самом конце вон там было 4 свойства которые надо было
доказывать долго и муторно вот и сегодня мы с вами продолжим эту штуку вот а факт на самом
деле заключается в следующем что мы не совсем построили минимальный пдк мы построили его про
образ потому что в минимальном пдк ну давайте скажем что это будет у нас пдк с минимальным
количеством состояний вот и мы будем доказывать что он является наименьшим то есть он будет
единственным с точностью до изоморфизма значит мы будем доказать следующий факт что у нас
автомат минимальный пдк том и только в том случае когда у него во-первых любые два состояния
попарно не эквалентны есть второе условие что все состояния достижимы из стартового вот эти
факты мы с вами будем доказать давайте поймем какого свойства нам не хватало для того что в
прошлый раз сказать что наш построенный автомат является минимальным чего нам не
хватило до достижения стартовых состояний а давайте подумаем ну пока я пока говорю пока
доска сохнет просто я хочу сказать следующую давайте мысленно прокрутим идея допустим у
нас с вами есть минимальный пдк да вопрос что можно сказать если в нем есть какие-то два
эквалентных состояния что можем сделать объединить их то есть построить на самом деле построить
автомат без попарно эквалентных состояния потому что мы два эквалентных состояния переводим в
одном множестве это раз да я пока говорю я жду пока доска высохнет вот значит строим вот
такой вот автомат отлично а если у нас есть какое-то состояние недостижимые стартового то что
мы с ним можем сделать удалить и при этом язык который у нас остается распознаваем этим автоматом
никак не меняется давайте эвристически поймем почему это так ну да если мы в терминах
конфигурации напишем то получается у нас не может быть из конфигурации стартовое слово произвольное
слово ну стартовое состояние произвольное слово в этом недостижимом состоянии любого слова то
есть у нас просто состояние конфигурации не определено для вот этой пары то есть они не
находятся не находится в одном классе так сказать в одном отношении вот поэтому недостижимый мы тоже
можем убрать убираем состояние и так далее вот а теперь мы с вами начнем доказывать следующий
факт почему это работает вы обратную сторону давайте формулируйте арену
минимальные тогда и только тогда когда любые
такие валентные и все состояния достижимые стартового
попарно да если бы они были бы все попарно эквалентно то понятно что это было бы одно
состояние так и все состояния достижимые стартового значит доказательства в одну
сторону мы уже с вами обсудили называется уменьшаем число состояний
если не так а в обратную сторону давайте посмотрим у нас с вами предположим что у
нас есть м которым автомат в котором любые два состояния являются попарно не эквалентными
помните у нас было с вами некоторое соотношение на количество состояния в автомате и мощность
множество сигмаса звездой кто его мне может напомнить она была у нас какая сверху ограничена
на на произвольной автомате вот и хочется вот вот это вот место что-то подставить
да оценку снизу поставить хочется сказать что это будет как раз количество состоянием нашему
пдк м нашим автоматем который сейчас есть и тогда этот автомат явно будет сразу минимальным по
количеству вершин давайте вспомним как мы вот этот факт доказывали какая лемма у нас была
мы говорили что у нас сигма со звездой л это объединение среди классов в альку
напомню что такой альку альку это у нас множество слов в которых дельта q 0 w равно
да совпадение правых классов то есть мы приписывая справа произвольный суффикс либо
мы попадаем язык либо не попадаем язык и навременно вот ну то есть получается у нас
следующее свойство то есть если у нас и как мы этот факт доказывали давайте вспомним
мы говорили что если два если два у нас как сказать мы сказали следующее что если у нас
два произвольных слова попадает в одно состояние то они эквалютны да здесь необходимо сделать что-то
обратное чтобы получить противоположную оценку поэтому давайте посмотрим значит для этого мы
сделаем следующее пусть у нас в м нет эквалютных состояний да и мы будем доказывать следующее что
если у нас дельта от q 0 по слову дв 1 не равняется дельта от q 0 по слову дв 2 то что хочется сказать
про эти два слова да что они продлежат класс мы разно-классовая эквалентность
тогда смотрите так как у нас в автомате нет эквалентных состояний да то есть это
значит что сейчас из этого будет следовать что не эквалентно по слову дубль во 2 да и со
состоянию нас не совпадают они не эквалентно а теперь смотрите что мы сделаем мы говорим
что существует у такое что дельта у 0 в 1 у принадлежит f давайте скажем сразу без ограничения
общности потому что неважно как мы смотрим на эти два слова и дельта от дельта q 0 не принадлежит f вот
это чему эквалентно опять же мы понимаем что это двойное дельта мы можем конкатонировать то что
у нас было поэтому получаем дельта q 0 в 1 у а это эквалентно тому что у нас
дубль в 1 у принадлежит языку l а это получается эквалентно тому что дельта
у не принадлежит f а это эквалентно тому что дубль в 2 у не лежит в л то есть у нас
существует такое слово у что в 1 у лежит в л а в 2 у не лежит в л а потому что у нас
состояние не эквалентно между собой это значит что существует слово который различает эти два
состояния но мы говорим только без ограничения в общем в общности что здесь принадлежит а здесь
не принадлежит можем повернуть знаки и получается что у нас с вами что в 1 не эквалентно дубль в 2
а теперь давайте подумаем что из этого следует что в нашем автомате если у нас состояние не
совпадают ой если у нас мы приходим в разные состоянии то мы попадаем в разные классы
эквалентности ну из этого следует что количество состояния как минимум столько же ой сейчас скажу
слова не эквалентны тогда и только тогда когда существует какое-то слово что приписывая к
нему справа мы в одном слове попадаем язык в другом не попадаем это определение мы давали в
прошлый раз вот это значит смотрите что давайте рассмотрим просто все состояния в нашем автомате
и смотрите здесь важно играет роль что все состояния достижимые стартового
да давайте пронумеруем то есть у нас состояние будет ку-1 ку-0 ку-1
для каждого существует слово
кукаты из этого следует что w 0 w попарно не эквалентно
а это значит что количество классов
не меньше чем количество классов автомате количество состояния в автомате
давайте я все-таки напишу здесь куштрих и напишу для произвольного автомата
да то есть вот оно играет свойство о том что все состояния достижимые стартового тогда
и ку-1 и получается наш автомат m на самом деле минимальный то есть мы доказали
что через количество классов эквалентный сигма со звездой по l то что количество
состояния наш построенном автомате не больше чем количество состояний в произвольном другом
автомате это доказательства понятно какая а вот это откуда мы начали рассуждать просто пусть у
нас две вершины пусть у нас есть какие-то два состояния ку-1 и ку-2 которые не совпадают
каким-то образом но существует два слова просмотрим два произвольных слова которые приводят нас в
разных в разных состоянии старта и докажем что они не эквалентны будут да это мы предполагаем
тогда что мы можем сказать про минимальный автомат чему в нем равняется количество состояний
да множество классы эквалентности по языку да то есть количество состояния минимального
зависит не от автомата а от языка можем ли мы сказать что автомат тогда будет зависеть от
языка минимально и на самом деле ответ на этот вопрос положительный да это собственно доказательства
вот и теперь мы будем доказывать единственность этого автомата с точностью до изоморфизма
что сегодня у нас у нас сухих тряпок сегодня нет ну ладно в общем будем доказывать что для
любого автомата существует единственная с точностью для любого минимального пдк существует
единственной с точностью до изоморфизма минимальный автомат такой что л равно л от
вашем дать скажем единственность для любого l существует единственный
с точностью до изоморфизма а теперь давайте подумаем как определить изоморфизм
да во-первых он должен сохранять состояние во-вторых он должен сохранить переходы и
третьего что он должен сохранять завершает состояние да так такое что
давайте зададим определение значит давайте обозначим си
физом если значит во-первых но я не знаю давайте не будем говорить что а наверное надо сказать да
q1 и q2 объективны q02 то есть стартовая переходит стартовая си ну поскольку это би так стоп
давайте я скажу следующее что в си я плохо написал да иску
не давайте изоморфизм будем определять только для пдк так си от q01 равняется q02 си от f1 равняется
f2 да и получается что еще нам нужно ну тут можно писать все дельта 1 равняется дельта 2 но я
напишу следующее сейчас секунду да давайте напишем что если у нас получается есть переход
из q1 по а в q2 принадлежит дельта тогда я только тогда когда получается си от q1 а
си от q2 принадлежит дельта 2 то есть переходы согласованы я не знаю что делать сегодня с
этой доской вот определение такое и да вот можно так определить и давайте вот сделаем вот
такую вот вещь ведем такое понятие как канонически минимальный полный детерминированный автомат да да и
сейчас и напишу смотрите а что мы доказали с вами мы доказали с вами на самом деле что если язык
автоматный да то сигма со звездой количество классов эквалентности оно конечно да потому что
если у нас язык автоматный то для него существует автомат да а если для него существует автомат
то он ограничивает сверху количество классов эквалентность сигма со звездой по этому языку
поэтому мы можем построить автомат вот потому что нам важно было как конечно
количество классов эквалетности. Итак, обозначу его m0.
Так, смотрите, как он обозначается. Это сигма со звездой по l, а алфавит у него
будет сигма. Значит, дальше множество переходов пределим. Класс эквалентности
пустого слова будет являться стартовым состоянием, а завершающим состоянием
будет следующее. Множество классов эквалентности слова w такое, что w принадлежит языку l.
И будем говорить следующее, что переход от класса эквалентности u по слову a равняется
класс эквалентности слова ua. Так, ну теперь давайте поймем, что нам надо сделать для того,
чтобы сказать, что этот автомат вообще существует. Во-первых, нам надо доказать,
что все состояния существуют, все они не эквалентны попарно. А вас не смущает,
что там завершающие состояния так определяются? А вас не смущает, что переходы так определяются?
Да, сразу скажу, что l автоматный язык у нас. Давайте я напишу. Давайте проверим свойства этого
автомата. Первое свойство, которое нам надо проверить, следующее, что если u эквалентно v,
u лежит в языке l, то v лежит в языке l. Почему? Это мы доказываем согласованное
множество завершающих состояний. Да, допишем слово. Значит, u эквалентно v это значит,
что для любого слова w, которое в нашем случае мы положим равное epsilon, l тогда и только тогда,
когда v принадлежит l. Это у нас u будет, это у нас будет l. Завершающее состояние мы с вами
согласовали. А дальше, что нам надо согласовать с вами? Переходы. На самом деле, кто-то может
сказать, что мы повторяем лишнюю работу. Как говорят принципы чистого кода do not repeat
yourself. Но тут это, к сожалению, не совсем срабатывает, поэтому мы будем исполнять
принцип wet. Кстати, вы знаете, что такое принцип wet в программировании? Как расшифровывается?
Да, да, да. Именно так он расшифровывается. Да, забавно. То есть, либо сухой, либо мокрый.
Что? А, вот здесь? Ну, мы говорим, что мы хотели бы, чтобы по переходу из класса эквалентности мы
попадали бы в класс эквалентности. Пока непонятно, почему это может работать. Для этого нам надо
доказать следующий факт, что если у нас u эквалентно v, то из этого будет следовать,
что уa эквалентно va. Почему это так? Да, потому что вот это что у нас такое? Мы говорим, что uv для
любого v, uv лежит l тогда и только тогда, когда vw лежит vl, но если рассмотрим w равное ax,
то мы получим uax лежит vl тогда и только тогда, когда vax лежит vl. Ну и получается у нас вот
это условие выполнено для любого x. Да, поэтому из этого будет следовать эквалентности. Третье,
что нам надо доказать, что это pdk. Почему это pdk? По любой буквы есть переход. И он
переходит к автоклассу. Так, дальше нам нужно доказать, что это минимальный pdk. Ну да,
мы можем сказать, что в нем третий. А теперь нам надо понять, почему он будет являться наименьшим.
Так, вспоминаем курс теории чисел. Что такое минимальный, что такое наименьший?
Да, минимальный это тот, меньше которого нет, а наименьший это тот, который не больше,
чем все остальные. Да, то есть мы определим, смотрите, давайте мы будем на автоматах,
на самом деле можно определить частичный порядок. Грубо говоря, один автомат будет не больше,
чем второй автомат. Мы про pdk говорим, что если из большего автомата можно схлопнуть некоторые
вершинки и получить меньший автомат. Вот, и в таких терминах наш автомат получится наименьшим.
Вот. Меня просто, так сказать, в прошлых запусках этого курса, ну в прошлом запуске,
меня ругали, почему спрашивают факт доказательства. Значит, почему существует наименьший pdk,
ой, почему существует минимальный pdk в классическом определении минимального pdk. Давайте сформулируем
халявное доказательство, которое вообще не отражает факту по курсу. Напоминаю, минимальный pdk
это pdk, в котором наименьшее число состояний. Почему он существует? Да, значит, существует
автомат, в котором состояние как можно меньше. Вот он минимальный, все, отстаньте от меня. Вот,
а на самом деле мы как раз сказали, что у нас автомат будет наименьшим, потому что в нем все
состояния будут попарно не эквивалентными, то есть нельзя схлопнуть его ниже. Чего? Ну вот,
но если мы сейчас это все все автоматы сведем к общему знаменателю, да, скажем, что он один,
тогда у нас не получится, что в нашем частичном порядке есть там, грубо говоря, вот такие два
автомата. Вот. Да, с точностью до изоморфизма, то есть мы разрешаем, да, для этого мы, то есть мы
говорим, что два автомата на самом деле одинаковые, если они одинаковые с точностью до изоморфизма.
Вот, давайте доказывать этот факт, значит, для этого нам нужно построить канонический изоморфизм.
Пусть у нас с вами есть автомат m, который считается тоже минимальным.
Давайте назовем дельта ноль тогда. Давайте определим канонический изоморфизм.
Определим изоморфизм си из q в сигма со звездой,
то доказывается, куда он будет бить наш этот ксиатку.
Ну, в какой-то класс эквалентности. Ну да, утверждает, что это... Так, стоп. Да, сейчас, секунду.
Давайте напишу такое. Помните льку, как мы определили? Это все слова,
которые доходят из стартового состояния до кутова. Тогда что нам необходимо доказать?
Да, нам надо доказать, что си изоморфизм.
И смотрите, делается следующий факт. Давайте я немножечко проговорю. Вообще пусть у нас есть
два автомата, любых, два минимальных автомата. Тогда, если мы построим с вами канонический
изоморфизм, образно говоря, у нас был автомат м1 и м2, тогда мы можем построить си1 из q1 и си2 сигма со звездой по л,
такие что... Ну, это изоморфизмы. Тогда скажите, как можно сделать изоморфизм из м1 в м2?
Да, взять си1 и построить си2 в м1, то есть композировать. И тут надо будет доказывать,
что эта композиция является изоморфизмом. Так, давайте промотаем.
Да, тогда получается, что любые два автомата изоморфны просто через этот канонический изоморфизм мы используем
как медиатор. Да, любых два минимальных автомата изоморфны между собой. Итак, давайте проверим,
что необходимо показать. Первое, что необходимо показать, что psi от q0 действительно будет пустое
слово. Это почему? Да, корректность, давайте корректность.
Так, почему? Ну да. Так, сейчас секунду. Ну, здесь нужно сказать следующее, что дельта от q0 по
epsilon равняется q0. Да, это значит, что epsilon принадлежит, так сказать, чему? Да, psi от q0.
Сейчас скажу, что здесь мы используем, чтобы в нашем автомате одинаковое количество состояний.
То есть, что в нашем минимальном автомате все автоматы имеют одинаковое количество
состояний. Следующий факт, который нам надо проверить будет, это, наверное, согласованность
переходов. А, не, ну, что завершающее состояние совпадает. Второе. Это почему?
Ну да, во-первых, у нас мы понимаем с вами, что, грубо говоря, если мы возьмем вершинки qf1, qfkat,
qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt
Qường qt Qfqt Qc1
Qc1 Qc1 xdxfd xdx fd xDx selection xc1 Qc1 xQc1 card xdx幸 и xdx fdselection
будет равняться QFGT.
Вот. И каждый из WFGT будет обрабатывать свой класс.
Почему у нас там в состоянии не принадлежат P?
Потому что они и принадлежат F.
А? Да, да, да, да.
Вот. Ну и получается WFGT это канонический представитель в каждом из...
в каждом из состояний.
То есть смотрите, мы здесь все равно пользуемся тем фактом, теми фактами, которые мы доказывали при построении минимального автомата.
И третье, что нам надо доказать, что если delta Q1A равно Q2,
то delta от переходов равняется psi от переходов.
Ну а это как сделать?
Третье. Если у нас получается delta от Q1...
Ой.
...psi.
Угу.
Ну, смотрите, тут достаточно все просто.
А если psi от Q1 это какой-то классы квалитности U...
А, psi от Q2, да.
Угу.
А, тогда смотрите, чему равняется...
Да, тогда delta от...
Ага.
Это класс UA.
Угу.
И тогда нам нужно доказать, что если у нас какое-то слово лежит в этом классе квалитности, да, в Q2,
то тогда мы попадаем в классы квалитности слова UA.
Еще секунду, давайте поймем, как это сделать.
Я сейчас хочу красиво написать.
Значит, psi Q2...
Нам надо доказать, что это...
psi от Q2 равно delta от UA.
Ну, psi от Q2 это psi от delta от Q1 по A.
Стоп, что?
Ну, нам известно, что Q2 равно delta от Q1 по A.
Q2 равно delta от Q1 по A, да.
Значит, psi от Q2 это psi от delta от Q1 по A.
А в этом классе лежит некоторый...
Стоп, а почему psi от...
Не-не-не, нам это как раз доказать надо вроде бы.
Ну да, можно так сказать.
Сейчас, секунду.
Ну, тут по-хорошему надо писать все в терминах слов.
Да, то есть у нас, допустим, оказалось, что...
psi от Q2...
это класс эквалитности Q...
класс эквалитности некоторого слова W.
Тогда нам надо доказать, что V эквалентно W... это...
V эквалентно UA. Нам надо вот это доказывать.
Ну, смотрите, как это делается.
Значит, что такое вот это вот все?
Напоминаю по определению.
Что такое psi от Q2?
Это слово W. Значит, тогда из этого следует, что...
delta от Q0V...
равняется Q2.
Угу.
А с другой стороны?
delta от Q0UA...
это что такое? Это delta от Q0U...
и перейдя это еще раз по A.
А это, собственно, тоже будет Q2.
Вот. А поскольку наш автомат с вами минимальный...
то что мы можем в нем сказать?
Если мы переходим в состояние... да, доходим до какого-то состояния...
да, вообще до произвольного состояния...
то, по сути, не важно, приписывая какое слово справа...
мы одновременно либо попадаем в конец, либо не попадаем в конец.
Из этого будет следовать как раз, что...
W эквалентно UA.
То есть тут надо было воспользоваться определением нашего канонического изоморфизма.
То, что W принадлежит LQ.
Так, вас еще нет.
Вы еще держитесь?
Так, на самом деле мы...
Ну, мы не доказали, кстати, инъективность с вами.
Мы не доказали, что эта штука не инъективна.
Давайте инъективность проговорим быстренько.
Предположим, что Psi от Q1 равняется Psi от Q2.
Да, тогда что у нас получается с вами?
У нас существует такое слово,
которое приводит по одному слову в одинаковые... в разные состояния.
Якобы в разные, если бы эта штука была бы не инъективной.
Но можем ли мы по слову прийти в одно и то же... это...
по одному и тому же слову прийти в два разных состояния?
Хорошая DKA.
Ну да, хорошая DKA.
Вот, тогда эти два состояния совпадают.
Значит, это состояние объективно.
Это мы тоже с вами обсудили.
Это мы тоже с вами обсудили.
И переходы мы тоже согласовали.
Итак, то есть канонический изоморфизм мы с вами построили.
Так?
Теперь докажем, что если у нас есть два автомата,
M1, M2, PDA,
то вот такая штука, которую мы с вами определили,
является каноническим изоморфизмом.
Вот.
Сейчас, секунду.
Да, тогда эта штука будет являться изоморфизмом из одного автомата в другой.
Единственное, что, скажите, здесь бы неплохо было бы показать.
Чтобы действительно сказать, что композиция изоморфизмов это изоморфизм.
Ну что, обратно... то есть обратно и изоморфизм тоже можно было бы изоморфизм делать?
Ну да.
Давайте поймем, верно ли это.
Что обратно к изоморфизму в том плане, который мы определили, тоже будет изоморфизмом.
Но обратная биекция биекции.
Если у нас был переход там, то у нас есть переход там.
То есть у нас по факту еще биекция между множеством переходов дельта строилась.
Согласованность переходов.
Да?
Вот.
Завершающее состояние тоже вроде бы строится, по сути, между собой биективно.
Сохраняет структуру.
Но поэтому, применяя каждый из этих свойств к автомату...
Ну, для каждого из этих нож по факту построили биекцию, а композиция биекции – биекция.
Вообще-то это вообще свойство для всех твоих моделей и так далее.
Ну да.
Ну, все-таки стоит проговорить.
Ну да.
Итак, теперь смотрите, как мы можем два МПДК проверять на эквалентность.
Мы строим минимальный ПДК для языков, проверяем МПДК на изоморфизм.
Тут вопрос, как строить МПДК, но давайте предположим, что у нас есть два минимальных автомата.
Скажите мне, пожалуйста, проверка двух графов на изоморфизм – это какая задача?
По сложности.
Ну, тяжелая какая-то.
Возможно, тяжелая, но тогда всем банковским системам хана.
Значит, ну, если тяжелая, то тяжелая.
А скажите, почему проверка двух автоматов на изоморфизм – это все-таки не тяжелая задача?
Ну, полных автоматов.
Почему?
Ну да, потому что на самом деле у нас на переходах автоматов написаны буквы.
И мы, по сути, можем сказать, что у нас, не знаю, если мы построим автомат с переходом для каждой буквы,
то степень каждой вершины в этом автомате будет равна единице.
То есть, по факту, это будет функция.
А там проверить две функции на изоморфизм.
Ну, это уже какая-то, мне кажется, не сложная задача.
Ну, то есть, вам нужно просто проверить, что если у вас есть переход по одной букве и переход по второй букве,
вам просто, не знаю, можно мапчик хранить, STD-мап, который просто будет обновляться с проходом BFS по нашему PDK.
Если вдруг у нас какая-то неконсистенция си обнаружится, допустим, мы перешли по одному переходу в одно состояние, оказались в другом,
значит, скорее всего, у нас два автомата не изоморфны между собой.
А теперь вопрос.
Как строить минимально PDK?
Так.
А теперь я спрошу, у кого был минимальный PDK?
У кого был минимальный PDK?
Ага.
Значит, у вас, по идее, уже должен быть этот факт был озвучен.
Как строить?
Большая табличка.
Да, большая табличка.
На самом деле, для того, чтобы строить эквивалентность MPDK, нам нужно эквивалентность MPDK.
На самом деле, для того, чтобы строить эквивалентность MPDK, нам нужно эквивалентность определить не для всех слов, а для слов ограниченной длины.
И мы это с вами как раз сейчас будем делать.
Необходимо получить не эквивалентные состояния, но у нас есть только слова.
В общем, идея такая, вводим эквивалентность по словам малой длины.
Мы ему говорим, что два слова эквивалентны по N.
Если для любого слова длины не больше, чем N, у нас выполнены условия эквалентности.
А?
Ой, да, эквалентность состояния по словам малой длины.
Так, где мы будем писать?
Опять же говорю, что мы здесь фиксируем язык L.
Ой, блин, уже то.
Давайте покажем следующее свойство.
Скажите мне, пожалуйста, следующую вещь.
Если Q1 и эквалент на Q2 по слову N плюс 1, то из этого что мы можем вывести?
По N, да.
А еще что мы можем сказать про tilde N?
Какое это отношение?
Отношение эквалентности, конечно.
А теперь давайте построим цепочку следующего толка.
Опять же, мы можем определить фактор множества.
Ой, это и все история. Q от tilde N.
Разбей на классы эквалентности.
Вопрос. Как между собой связаны вот эти два класса?
Кто кого?
Первый не больше, чем второй.
Хорошо. Первый не больше второго.
Ну и в итоге мы можем с вами простроить эту цепочку.
Чем мы этим множеству сверху можно ограничить?
Q slash tilde.
Да, Q slash tilde. Либо Q slash tilde бесконечность.
Ну и в итоге мы можем с вами простроить эту цепочку.
Чем мы этим множеству сверху можно ограничить?
Q slash tilde.
Да, Q slash tilde. Либо Q slash tilde бесконечность.
А теперь вопрос, который я хочу задать.
Если у нас в каком-то месте у нас бесконечная цепочка знаков не больше,
то что можно сказать про это?
То что можно сказать про эту цепочку?
У нее есть предел.
У нее есть предел. Ладно.
А если мы рассмотрим про предель, ой, про дискретный случай,
это все-таки у нас на тро...
Да, с какого момента они станут все одинаковыми?
Вот.
И давайте докажем следующий факт.
По факту это будет LEMO.
Которое на самом деле нам скажет, что при первом нарушении...
При первом знаке равенства мы можем останавливаться.
Значит, оно говорит следующее.
Если у нас Q1 эквалентно Q2,
следует, что Q1 эквалентно Q2 по множеству словам длины не больше, чем n плюс 1,
то получается Q1 эквалентно Q2 по n плюс 2.
Так, сейчас давайте-ка я точно сформулирую это все дело,
потому что кажется, я мог сформулировать это не так.
А?
Да, не особо. Я утверждаю просто следующее, что если у нас
два состояния внезапно ультворяли этому соотношению,
да, грубо говоря, что при добавлении классов у нас с вами ничего не произошло,
то и дальше у нас при добавлении классов ничего особенного происходить не будет.
Итак, давайте вот так скажем.
Вот лучше вот так говорить.
Да, да, да, согласен.
Из этого следует это, то будет...
будет выполнено вот это свойство.
Итак, давайте посмотрим следующее.
Что такое... сейчас.
Нам нужно сделать хитрый фильм тушами.
Значит, давайте рассмотрим два слова.
Сейчас.
Что происходит с произвольными словами длины не больше, чем n плюс два?
Рассмотрим произвольные q1, q1, q2.
Давайте рассмотрим для любого слова длины не больше, чем n плюс два q1.
Так.
Вот, выполнено вот это следующее соотношение.
Смотрите.
Чему это утверждение эквалентно?
Ну, во-первых...
Я хочу сказать, что мы просто сейчас будем... это в итоге будет...
Давайте так напишу.
q1.
Вот это утверждение эквалентно этому.
Вот это утверждение эквалентно этому.
Вот это утверждение эквалентно этому.
А теперь смотрите, что сделаем.
Если в нашем слове длина хотя бы два, то можем написать следующее.
Угу.
Ну, первую букву вытащили.
Угу.
А тогда вот это как переписывается?
Если мы букву a фиксируем.
Давайте фиксируем букву a.
Плюс один, да.
Угу.
А это чему эквалентно?
Какие состояния у нас тогда n плюс один эквалентно?
Да.
А из этого что будет следовать?
А?
Эти же два состояния уже n эквалентны.
У нас классы не расширились.
То есть если мы из класса n-того в n плюс один перешли,
и состояния у нас не увеличились,
то тогда, типа, если у нас...
была n плюс один эквалентность для каких-то произвольных состояний,
то этот класс, грубо говоря, не расширился, он остался тем же самым.
Поэтому если для двух вершин у нас выполнена n плюс один эквалентность,
то для этого класса, для этих вершин, будет выполнена n эквалентность.
Вот это основная идея перехода.
Мы сказали следующее, что если у нас q1 эквалентная q2 в n плюс два,
это значит, что если для любой буквы a, у нас будет выполнено вот это свойство.
Да, n плюс один эквалентный, q2 эквалентный, q1 эквалентный, q2 эквалентный, q2 эквалентный.
У нас будет выполнено вот это свойство.
Да, n плюс один, да.
А из этого будет следовать, если это свойство выполнено,
из этого будет следовать, что дельта q1 а уже n эквалентна.
А теперь нам надо вот это все провернуть обратно.
Ой, сори.
Что у нас получается?
У нас получается следующее, что для любого a,
для любого слова u такое, что u не больше, чем n,
дельта q1 по au
а u лежит в f, да?
А это чему эквалентно?
А это эквалентно тому, что у нас q1
n плюс один.
То есть рассмотрим два произвольных состояния,
если они были n плюс два эквалентны, то они тоже будут n плюс один эквалентными.
Ох, стоп, стоп, стоп, стоп.
В смысле?
Так, сейчас, секунду, мне надо было наоборот, видимо, да?
Да, мне надо было эту всю историю наоборот провернуть.
Да, да, да, да.
Мне надо было доказать, что если две вершины n плюс один эквалентны,
то они будут n плюс два эквалентны.
Давайте фиксить.
Когда вот я делал f с частичками n,
и я подумал, что состояние отель находится на азии,
и кое-кто отель находится на азии,
я переведу по общему отношению.
Ага.
Хотя они были эквалентны по азии.
Да, так, давайте посмотрим,
будет ли это корректно, если мы эквалентно заменим на не эквалентно?
Не, не, не, сейчас, секунду, дайте-ка это.
Я, по-моему, еще зала...
Так, давайте посмотрим, что тут предъявляется.
Да, да, да, да, да, так.
Смотрите.
Хотите научу это читать?
Надо читать в обратном порядке.
У нас же следствие будет спереди.
А?
Мы не в следствие, а по стороне.
А, давайте нам, единственное, вот тут надо понять, что это...
Смотрите, на самом деле следствие такое у нас.
Я утверждаю, что здесь знак туда-сюда.
Почему?
Потому что мы говорили, что если любых двух состояний,
если у нас n эквалентность,
то она станет n плюс 1 эквалентностью.
Выполнено. У нас это условие выполнено.
Да, поэтому здесь мы можем вернуться вот сюда.
В обе стороны.
Отсюда-сюда это верно просто так, просто по определению,
а отсюда-сюда эта история верна,
потому что мы используемся нашим свойством.
Ага.
Понятно, почему мы можем все это выражение читать снизу наверх?
Давайте я напишу даже.
Все, доказали.
А?
Не, ну можно.
Только когда рассказывать экзаминатору, рассказывать в обратном порядке.
Ну, то есть давайте еще раз.
Если q1, q2, n плюс 1 эквалентны,
тогда для любого слова длины не больше, чем n плюс 1,
у нас выполнена эта штука.
Давайте рассмотрим первую букву.
И тогда окажется, что у нас delta q1a и delta q2a будут n эквалентными.
А если они n эквалентны, то они n плюс 1 эквалентны.
Тогда для любого слова u длины не больше, чем n плюс 1,
у нас есть эквалентность.
Приписываем букву a, поскольку у нас буква a произвольная,
то это верно будет для любого слова длины не больше, чем n плюс 2.
Перевернули.
Такой факт.
Теперь смотрите.
Как строить...
Так, количество левым понятно?
То есть получается, если в какой-то момент количество классовой количества совпало,
то дальше можно не двигаться.
А и на семинарах вы как раз это делаете.
Но мы с вами это делаем.
Да, Вить?
Помните, была табличка, где мы смотрели переходы по букве a по букве b
и смотрели, разбиваются ли у нас классы.
Если у нас классы разбиваются, двигаемся дальше.
Если не разбиваются, заканчиваем.
Вот.
Собственно, и количество состояний, за которые это происходит,
это количество состояний минус 2.
Потому что у нас внизу q0 это 2.
Это у нас завершающее или незавершающее состояние.
А в конце у нас количество классов q.
Вот.
Теперь как строится алгоритм.
У нас q0 это f или q без f.
И дальше у нас расширяется класс тогда, когда
либо у нас q1, q2 не эквалентны, а q1 и q2 оказались не n плюс 1 эквалентны.
Значит, у нас есть переход по букве, который перевел нас в разные классы.
Ну и собственно, переход по первой букве,
то есть если мы смотрим слово длины n плюс 1,
первая буква у нас н плюс 1.
Смотрим слово длины n плюс 1.
Первая буква нас переводит в класс эквалентности по n.
То есть на одну букву меньше.
Значит, кто хочет, тут есть замечательный пример,
в котором можно прямо проехаться по этой штуке.
В общем.
Не-не-не, но это семинарский блок,
поэтому все-таки я советую перед контрольной посмотреть.
Да, и кстати, про контрольную.
Контрольная будет на шестой неделе курса.
Вот, первая контрольная.
А то Виталий меня просил передать.
У нас четвертая...
Стоп.
У нас четвертая лекция, да.
То есть еще будет лекция,
а после лекции неделя будет контрольная.
Вот, теперь смотрите, это одна из задач контрольной будет.
По регулярному выражению надо будет построить импдк.
Давайте поймем, что нам надо делать.
Нам нужно построить nk с однобуквенными переходами,
убрать epsilon-переходы.
Строим dk.
Тут, кстати, знак не более пропущен.
Строим dk.
Строим pdk.
Минимизируем его.
Вот.
Пять.
Это самая муторная.
Пара, пара, да.
Да, она будет на семинаре.
Ну и, наверное, коллеги-семинаристы вам рассказывали,
что это все можно запрогать.
Во.
Значит, давайте дальше двинемся.
А на самом деле те факты, которые у нас сегодня были,
позволяют привести примеры неавтоматных языков,
которые не являются автоматными.
И вот за последние 15 минут нам надо разобраться с этим.
Значит, первая теорема, которая у нас будет,
это теорема Махилла Нейроуда,
которая говорит следующим,
что язык автоматный тогда и только тогда,
когда количество классов эквалютности конечна.
Так.
Мы, кажется, в прошлый раз делали безуспешную попытку
это доказать.
Итак, давайте докажем.
Да.
Значит, L автоматный.
Существует PDK.
M.
L от M.
Да.
И в чем, как ограничивается у нас количество состояния
количества классов эквалютности?
Ну да.
В обратную сторону.
Да.
Строим так, как sigma.
То мы проведем алгоритм построения.
Поскольку я не любитель аббревиатур, давайте напишем M0.
У нас у него было определение.
Я прямо написал, что это M0.
Ну все.
Обратно.
Мы сказали, что количество классов эквалютности бесконечно.
Ой, конечно.
Значит, мы можем построить по языку канонические MPDK.
Он не зависит от инструкции, он зависит только от языка.
Что упал?
Не упал.
А.
Господи.
Ладно.
Давайте докажем один пример, который крайне интересный.
Ну мы с этим языком еще поработаем.
Значит, пример такой.
Почему он не автоматный?
Нам необходимо привести бесконечное количество по пару неней эквалютных слов.
А bright and dark?
Мы не будем делать это.
Мы будем делать это по параметрам, по параметрам.
Мы будем делать это по параметрам.
Мы будем делать это по параметрам.
А на предыдущем этапе?
Ну да.
слов? N произвольная. Да, да. Мы говорим, что для любых N и N, неравных N, N, а в N не
эквалентно A в N-ты. Почему? Мы что, рассмотрим слово W равное? B в N-ты, получаем A в N-ты,
B в N-ты принадлежит языку. L, ой, наоборот. Все. Ну, неравном можно сказать, неважно.
У нас количество букв должно совпадать. Вот. Вот мы научились на лекции решать еще
одну задачу с контрольной. Ну, нет, конечно, они будут сложнее, на семинарах будут рассмотрены
примеры, но там нужно будет по языку понять, является он автоматным или не является. А в N-ты,
B в N-ты это первый пример не автоматных языков. Но есть еще один факт, который мы сейчас тоже,
несмотря на то, что у нас осталось десять минут, мы с вами его тоже докажем. Он называется
лемма о разрастании. И это слово у нас прозвучит далеко не один раз. В англоязычном
литературе называется помпинг лемма, лемма о накачке. Так, собственно, это мы посмотрели.
Вот. Я пока ищу зарядку, а вы вдупляете, что тут происходит.
Значит, лемма о разрастании. В чем она заключается? Что существует такое слово,
что существует такое P, что для любого слова из языка такое, что его длина хотя бы P. Существует
разбиение на слова x, y, z. Для любого слова существует разбиение такое, что v равно x,
y, z. Длина x, y не больше, чем p, y не пустое. И тогда для этого слова мы можем разрастать серединку.
Не, прикол в том, что… Нет, длина y… Да, существует разбиение на слова x, y. Существует
такое, что оно будет выполнено условием, и для любого k будет выполнена такая фигня.
Так. Для любого слова… Существует P. А? P это константа какая-то.
Так, доказательство. Рассмотрим автомат с однобуквенными переходами.
С однобуквенными переходами такие, что l от m равно l. И положим P равное
количеству состояния в автомате. Тогда смотрите, если у нас длина слова хотя бы P… Что мы можем
сказать? Если длина слова хотя бы P равное количество состояния в Q, то если мы рассмотрим цепочку,
смотрите. Ну, допустим, это у нас v1, и так далее, vkt. w1, vkt. За один переход мы переходим qe, t.
Ну, давайте напишу. qe, t получается v, it, plus 1, и так далее, vkt. qk, t, которая, опять же,
у нас будет в завершающем состоянии, l. Что мы можем сказать про последовательность q0, и так далее, qk, t?
Ну, смотрите. Всего членов последовательности хотя бы k, plus 1 здесь. Это равняется как минимум
больше равно, чем к количеству состояния plus 1. А сколько у нас состояния в этом автомате? q.
Впоминаем принцип дирекле. Существуют две вершины, в которых qe равно к уже тому. Возьмем
минимальное такое же. Давайте я теперь картинку покажу просто. Вот тут вот у нас и qe,
и вот тут у нас qt. Тогда давайте вот эту вещь обозначим за x, эту за y, эту за z.
Тогда у нас для любого k x, y, y, z будет лежать в языке? Да, почему? Ну, сколько-то раз по циклу
прошлись, и ладно с ним. Дальше скажите мне, почему длина x, y не больше, чем p? Это самое
интересное, что тут здесь есть. Мы взяли минимальное такое g. Минимальное g, следовательно q0, qg-1 различно.
Но из этого будет следовать, что g-1 не больше количества состояния минус 1. Вот так вот.
Ой, это получается не больше, чем количество. Сейчас, секунду. Нумерация 0. Это получается,
если у нас 1. Это q. Не, количество состояния минус 1, да. Вот, а слово w1, wg, начнем длина не
больше, чем количество состояния. Вопрос, почему игрок не пустой? Да, иначе и равно g.
Я автомат, у нас однобуконными переходами. Так, теперь смотрите. Я сейчас буду писать страшную
вещь, но нам надо ее написать для того, чтобы мы с вами ее могли понять. Напишем отрицание этой
фигни. Так, что нам надо сделать для того, чтобы написать отрицание? Да, для любого p существует такое
слово, длина слова, хотя бы p. Такое, что для любых w равна x, y, z. Таких, что длина x, y не больше p,
длина y не равняется нулю. Дальше. Существует k. Тут что? Не лежит в языке l. Из этого следует
что? l не автоматный. То есть смотрите, по сравнению с вот этим страшным свойством, что нам говорит
отрицание? Нам достаточно подобрать одно слово для произвольного p. Достаточно рассмотреть его
произвольное разбиение. Кстати, сразу скажу, контрольный. Если где-то в ваших мыслях проверяющий
увидишь, что здесь знак не для любого a существует, вам поставят ноль за задачу. Такие правила.
Если в мыслях на контрольной будут здесь внезапно вместо знака для любого, окажется знак существует.
Это такая критическая ошибка. Ладно, давайте воспользуемся этим для слова awn и bwn. Для
нашего языка awn и bwn. Рассмотрим p из лемы. И рассмотрим слово w равное awp и bp.
Тогда что мы можем сказать про слова x, y? Рассмотрим произвольный x, y и z. Если у нас длина
x, y не больше чем p, то что из этого следует? Да, из этого автоматически будет следовать,
что из устройства нашего слова x равно awn, y равно awm, но az равняется awp-m-l на bp.
Какое слово тогда нам не подойдет? Какое слово выбьет нас из автомата? Да, x, y квадрат нас выбьет из языка.
Что у нас получается? А в чем?
Am больше нуля, ну потому что у нас игрок не пустой.
Из этого получаем, что l не автоматный. Не поверите, мы даже уложили сегодня вовремя.
Вот, в общем, смотрите, давайте подытожим, что мы сегодня с вами научились делать. Мы с вами,
во-первых, построили минимальный pdk, доказали, что он является наименьшим, и дальше, значит,
да, тут еще дополнительные трюки, которые можно применять. Можно их тоже в их семинаре посмотреть.
В общем, мы построили с вами наименьший автомат сегодня, раз, доказали, что он именно наименьший,
и три, мы посмотрели, как можно доказывать, что языки не являются автоматными. Все, в следующий раз
будет уже другая конструкция, которая немножко обобщает конструкцию автомата.
