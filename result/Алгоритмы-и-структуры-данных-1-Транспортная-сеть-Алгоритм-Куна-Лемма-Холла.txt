Ну, во-первых, давайте вспоминать, какую задачу мы вообще решаем в принципе.
Ну, формальное определение можно сказать так.
Пока еще нельзя, конечно, формально сказать, позже скажем.
Но у нас действительно есть какой-то ориентированный граф, по которому мы можем пускать какую-то воду.
Ну, а естественно у каждого ребра есть пропускная способность.
Так, что тут? Видно, что написано? Да, нет, наверное. Хорошо.
Значит, есть какая-то вода, то есть есть какая-то пропускная способность, то есть означает, что в единицу времени по этой трубе может протечь не более чем столько-то воды.
То есть это такой классический пример.
Но наша задача, тут конечно возникает подлянка.
Какая у нас цель? Наша цель как бы протащить из точки S в точку T как можно больше воды.
Но интуитивно картинка может быть на самом деле неправильная, если бы формулировать так.
Более точная формулировка говорит, что нам надо наладить бесперебойный процесс перекачки воды из точки S в точку T так, чтобы в единицу времени из S в T перекатывалось как можно больше воды.
То есть скорее такая задача.
Ну, кстати, можно отметить, что если кому-то неудобно это мыслить в терминах воды, можно мыслить еще в терминах автомобилей на самом деле.
Потому что на самом деле можно вообразить себе, на самом деле часто предлагается такая интерпретация, что на самом деле ребра это дороги на самом деле, а пропускная способность это какое количество машин в единицу времени по ним может проехать.
Это работает гораздо хуже с точки зрения применимости на практике, потому что на практике в основном проблема в том, что, блин, это машины.
Ну, люди действуют неоптимально.
Нет, ну, нет, ну, конечно.
Но это больше, тем более близко к практике.
Ну, может быть, может быть.
Да, хорошо.
Ну, как сказать, да.
Ну, тут водопроводи тоже там по-разному.
То есть обычно такой трубопровод работает, конечно, в предположении, что мы монополисты.
Вот изначально мы будем мыслить, что мы монополисты, то есть у нас есть полный трубопровод, и мы сами своими ручками решаем, сколько воды мы можем прокатить в единицу времени.
Вот.
Потому что в некоторых случаях бывает, что это не так.
Вот.
Но тем не так или иначе надо формально сформулировать, что мы хотим.
Значит, формально говорим так, смотрите.
То есть можно уже формально сказать, что там есть определение сети.
Вот есть такая сеть.
И у нее есть пропускная способность.
То есть, ну, просто фактически это граф, на каждом ребре которого определено неотрицательное число С.
Правда, здесь видите оговорочка.
Мы здесь пишем С от УВ, на самом деле, которое больше либо равно нуля.
Вот.
Но на самом деле, конечно, граф ориентированный, могут быть в принципе и кратные ребра.
Но с точки зрения нашей задачи чаще всего нам более-менее все равно.
На самом деле у нас там есть ребра, если у нас кратные ребра с пропускными способностями 1,2,5,
или у нас есть одна толстая труба пропускной способности 8.
Теоретически нам надо пригодится пропустить 5 литров по первой, 2 по второй.
Ну теоретически может.
Но там это уже дополнительные условия.
Обычно этого не требуется.
То есть мы все-таки с базы начнем.
Вот.
Но тут оказывается интересно.
Просто на самом деле тут можно вводить определение двумя разными способами.
Потому что вот смотрите.
Потому что как вы себе воображаете граф?
Потому что граф можно вообразить себе с помощью ориентированным способом.
Но с точки зрения презентации предлагается воображать его себе неориентированным способом.
Это означает, что А. У вас нет кратных ребер.
Б. Удобно считать, что у вас между любыми двумя вершинами ребро есть.
Просто у некоторых из этих ребер пропускная способность 0.
Как вам удобнее считать?
Называется ребро, существует оно нулевое, или у меня нет нулевых ребер.
Просто если ребро нулевое, то оно не существует.
О господи.
А, вот да.
Да, нет, это просто пример.
Но там все основное, что там было, это определение сети.
А есть определение потока.
Предпоток.
Не, какой предпоток, господи.
Кошмар, че, бурашка и предпотоки, ужас какой.
А теперь давайте посмотрим.
Если вводить определение такое формальное, то получается немножко странно.
То есть оно не самое интуитивное.
То есть есть как бы, может быть, более интуитивное.
Но тем не менее, с таким потоком оказывается очень удобно мыслить.
Смотрите, какая логика здесь.
Формально говоря, поток это не какая-то вода текущая.
То есть поток это функция, как всегда.
Функция, которая по двум вершинам говорит, сколько воды от одной к другой течет.
Только с тремя маленькими оговорками.
Во-первых, у нас есть антисимметричность,
которая по сути говорит о том, что если мы говорим, что из пункта А в пункт Б течет 5 единиц жидкости,
то то же самое, что говорит, что из пункта В в пункт А течет минус 5 единиц жидкости.
Да, так вот.
То есть такое стандартное завихрение веселых математиков.
Но оказывается, это действительно так удобно.
Но дальше следующее ограничение, оно более естественно.
То есть как бы, может быть, сколь угодно в минус,
но тем не менее у нас поток между двумя вершинами не превосходит профессиональную способность.
Здесь мы вынуждены признать, что...
То есть здесь оказывается, что между двумя вершинами может течь поток, даже если пропускная способность ноль,
потому что он в принципе может быть отрицательный.
Нет, но это нормальная ситуация.
Вы же на физике тоже сталкивались, что казалось бы, что через конденсатор оказывается ток может течь.
Хотя как он может течь, если это тупо вот такие две пластины, не связанные между собой?
А вот оказывается течет, скотина.
На чем вы сталкивались?
На физике?
Нет.
Да.
Это что?
В школе у вас физика была, не знаю.
Я говорю, у меня это была программа 10 класса, я не знаю.
Нет, конденсатор это вот такие две пластины, такие длинные, такие ноты.
И между ними такое небольшое расстояние.
Вот.
Ну это да.
Да, понятно, здесь собрались те, кто не хочет это изучать глубоко.
Да, я понимаю, поэтому да.
Но тем не менее.
То есть мы мыслим в том, что да.
Но это второе.
Но есть третья ситуация.
Но третья, это вот для нас важно.
То есть это сохранение потока.
Вот, ну здесь так, здесь написан какой-то текст.
Но по сути он означает следующее.
Что мы перегоняем воду из точки С в точку Т.
Это значит, что мы подразумеваем, что вода может появляться
только в точке С и исчезать только в точке Т.
Ну, по крайней мере в идеале.
На самом деле вода может теоретически появляться в точке С и исчезать из нее, в принципе.
Равно как и наоборот.
Но самое важное для нас это то, что больше она нигде не появляется и не исчезает.
Это выражается вот этим условием, которое говорит о том, что суммарное количество воды,
которое вытекает из любой вершины, значит из любой вершины У,
не совпадающей с истоком истоком, вот это важно, равно нулю.
То есть вот такое вот, это вот математическое определение поток.
Ну, видите, оно подразумевает, что у нас там есть какие-то отрицательные потоки.
Не всегда в этом это удобно мыслить.
Так, дальше пока не надо читать, потому что дальше лучше посмотреть сюда.
Потому что в этом месте тогда я сейчас вам покажу другое определение потока.
Но для этого нам придется пойти до доски.
Так, но для этого абсолютно, на самом деле абсолютно формально.
Абсолютно. Так, первую очередь, мне кажется, нам нужно сделать вот это.
Так, ну что?
Ну что, доска там видна?
Ну что, фамилия какого известного преподавателя сейчас на доске?
Да, может ли ответить на этот вопрос рандомный телезритель?
Нет, это какая-то вопрос.
Вы имеете в виду назвать его имя, фамилию или?
Да нет, это nicknames of teachers.
Вы имеете в виду назвать его имя, фамилию или?
Да нет, это nicknames of teachers достаточно.
Ну там не самое сложное отчество, знаете?
Ну оно не самое типовое.
Ну как вам сказать, знаете...
Ладно, отчество оно сложное, но он, конечно, молодец.
Видимо, не угадал каким макером писать.
Ну ладно.
Нет, ну знаете, как бы...
Ну я не знаю.
Не, ну пыщ-пыщ там и сделаем, это не проблема.
Ладно.
Ну ладно, это не принципиально.
Он не настолько их обозначил, чтобы доской нельзя было пользоваться.
Значит, альтернативное определение потока,
такое более программистское, на самом деле,
которым вы, на самом деле, по умолчанию пользуетесь,
когда обычно кодите потоки,
оно выглядит другим способом.
Но вот они выглядят по-другому.
Она говорит, значит, то есть оно говорит...
Ну понятно, ну то есть сеть...
Давайте, ну я уж что-то для полноты напишу,
что вот пишем, определение.
Сеть называется это...
Там, соответственно, можно сказать V,
то есть там G равно V, E,
ну и, соответственно, C.
Где C...
А, нет, неправильно.
C, S, T.
На самом деле, если формально писать определение сети,
то в ней есть понятие исток, исток.
То есть это часть определения.
То есть обязательно...
То есть просто пропускные способности указать недостаточно.
Вот.
Хотя разные определения бывают,
потому что, в принципе,
можно рассматривать сети без истока истока.
Мы это будем делать, когда будем рассматривать циркуляцию.
Но там, в принципе, можно просто сказать,
так ладно, пусть исток вот это,
исток вот это, но на самом деле нам по барабану.
Давай.
Вы будете...
Ну, короче, вы будете выспрашивать определение.
И если будете,
то можно ли пользоваться
тем, которым было в презентации?
Ой, ну...
Ну, скажем так.
Я буду спрашивать оба определения.
То есть тут как бы мне
хочется... Тут важно
просто понимать, что это как бы более математическое.
То есть оно как бы навешивает
по сравнению с этим...
Так, давайте не буду еще...
Черт, я ее комментирую, лучше я сначала напишу определение,
потом мы их будем сравнивать.
Итак, смотрите, сеть, это просто определение вот такое.
То есть формально говорим, что V еет, понятно,
вершины ребра, C
просто такая вот
функция.
То есть это пропускные
способности.
То есть это называется пропускная
способность.
Значит, S
это вершина,
она называется исток.
T это вершина,
не равная истоку,
это сток.
Вот. То есть
мы
можем ввести вот такое определение сети.
То есть
на самом деле вот в этой части
определение, то есть на самом деле
пишут, что C это все-таки вот такая
функция.
Вот так.
То есть вот где мы определяем
поток на матрице смежности,
здесь тогда пропускная способность зависит от вершин.
Поэтому мы там пишем C от УВ
на самом деле. Вот.
Ребра ориентированные
да.
То есть давайте
напишем. То есть да, тут надо было бы написать,
что V е это
ориентированный граф. Да, очень важно,
спасибо за замечание, что ребра
ориентированные.
Ну, то есть конечно могут быть и не ориентированные,
но по умолчанию они ориентированные.
Значит далее.
S такое,
T это
сток, значит вот так сеть мы определили.
Теперь идем дальше.
Значит определение.
Теперь обычно так везде пишем.
Пусть у нас
G равно там соответственно
V,E,C,S,T.
Это сеть.
Тогда
говорим мы
поток
значит F
значит это тоже
функция.
То есть это функция.
То есть это такая
функция F.
Значит откуда-куда.
Вот здесь мы пишем. То есть
где каждому ребру сопоставляется
какая-то величина потока.
Причем в этот раз, обратите внимание,
она не
отрицательная.
То есть если у нас ребра ориентированная,
то мы торжественно заявляем,
что
пункт A в B
минус 5 течет не может.
То есть дорога ориентированная.
Поэтому
все разговоры.
Слушайте,
из Новгорода в Твери есть ли
дорога? Да.
Но ехать можно только туда.
Что за мелочи? Давайте мы просто напишем,
что машина едет не из Твери
в Нижний Новгород, а из Нижнего
в Твере едет минус одна машина.
Ну вот.
Но в этом случае
подобные разговоры приравниваются
к даче взятки и коррупции.
Соответственно.
Почему?
Нет, мы тут ничем нелегальным
не занимаемся.
Вот.
Здесь я говорю, что в этом определении мы
все мыслим удобно, что у нас
вода течет
никакими нетривиальностями,
что у нас туда течет минус
5 единиц жидкости, мы этим не занимаемся.
То есть мы говорим, что
все так течет, но есть
маленькие оговорки. Какие оговорки есть?
Есть две оговорки.
Во-первых.
Значит, первая оговорка.
Ладно.
И первая оговорка. Вторая оговорка.
Говорит о том, что у нас
для любого ребра E
верно, что
F от E меньше либо равно
C от E.
И есть
третья оговорка. Почему я пишу
вторая-третья? По аналогии с тем, что есть.
Потому что первой оговорки нет.
Потому что у нас как бы
обратного ребра нету,
так сказать.
Это не внимание определения потока.
То есть вы конечно там
если кто-то писал, то конечно у вас там начинаются
фантомные ассоциации, типа там обратное ребро,
там остаточная сеть.
Но погодите, у нас еще такого нету.
То есть конечно это все будет,
мы никуда не денемся от этого.
Но помните, это тоже не более
чем абстракция.
Такая удобная абстракция.
Поэтому первая нет, а вот третья есть.
Как же написать сохранение потока?
Но сохранение потока нам теперь реально придется писать,
что сколько втекает,
столько вытекает.
Поэтому придется писать
это следующим образом.
То есть любой вершины У,
которая не исток и не
сток,
оказывается, что сумма
по всем
ребрам таким,
которые входят
в вершину У,
равна
сумме потоков
по всем ребрам таким,
что стартовая
вершина этого
ребра равна У.
То есть
если брать более
приближенное к реальной жизни
или реальному программированию определение
потока, оно бы выглядело
вот таким образом.
Понятно, да?
То есть в общем-то
на уровне
математической абстракции
всегда можно выбирать
какое определение, потому что понятно, что это
более-менее одно и то же. Правда?
Ну, то есть, по крайней мере,
перевести поток,
сети поток из этого вида в этот,
в этот, в общем-то, труда особо не составляет.
Сейчас у нас в таком
определении не может
вытекать
в исток?
Нет, почему?
Втекать в исток
вполне может.
В смысле, пойти
в истоке и прямо из него же
выйти? Нет, погодите,
это другое ребро уже будет.
Нет, может быть ситуация, когда
вода по какому-то ребру втекает
в исток, и в это время по другому
ребру из истока вода
вытекает. Такое вполне может быть.
Сейчас
не так
сформулирую. Мы же хотим,
чтобы, как бы говоря,
все, что пошло
через исток, потом
вышло через сток.
Ну, в идеале, в идеале
хотелось бы. Это у нас такая
мечта, да.
Это тут достигается.
Ну, в максимальном потоке
это и так? Нет, погоди,
но это не совсем то.
Значит, да, вот достигает действительно естественный вопрос.
Да, чисто математический вопрос.
Да, кажется естественным, да,
то есть кажется естественным, что
втечет в сток может только
то, что вытекло из истока,
потому что вода вроде больше нигде
не скапливается.
То есть там
вот эти вот третьи условия
в обоих интерпретациях говорят нам, что
вода нигде не появляется
и нигде не исчезает, кроме истока истока.
Да.
Нет, да, она может циркулировать
по кругу, но это как бы и свыкло,
что вот изначально дано, вот
из поколён веков так повелось, но
как бы не появляется, не исчезает.
Вот.
То есть да, но вот, то есть да,
сразу оговорить сюда, как выглядит сеть.
То есть типичная какая-нибудь сеть, обычно
мы можем рисовать вот таким вот образом, да,
то есть вот это какой-нибудь вот такой ориентированный граф.
Чик.
Вот.
Так, как-нибудь вот так вот
можно сделать даже.
Вот.
Ну, то есть, ну вот,
и обычно мы будем писать чаще всего
вот так, смотрите. То есть вот есть у нас
пропускные способности, как-нибудь от
балды, два, четыре там,
восемь, шесть, пять,
четыре, ну я сейчас от балды пишу, сейчас
не принципиально, четыре.
Вот, а поток хочется писать
следующим образом.
То есть вот, где-то вот
слева, я вот тут буду писать, что тут течёт, допустим,
две единицы потока.
Да, где я не нарисовал, будем по умолчанию
считать ноль.
Вот. Ну, в принципе, вот это, вот это вполне себе
поток, по крайней мере, вот по этому
определению. Ну, я могу нарисовать матрицу
смежности, согласно там, но в этой
матрице смежности тогда из этой вершины,
ой, забыл нарисовать это.
Вот. То есть из этой вершины
в эту будете четыре единицы потока,
а из эту в эту типа минус две.
Вот. Ну, вот
по этому определению такого нет.
Вот.
Значит, далее, что у нас тут ещё
происходит?
Ну, в принципе, заметим, что
да, видим, что здесь
максимально наглядно видно, что у нас из эстетик
ещё две единицы жидкости в единицу времени.
Вот.
Ну, в принципе, да, можно теоретически развлечься
и забабахать вот что-нибудь подобное.
Во.
То есть, видите, как, ну вот,
то есть как интересно, то есть заметим, что
из эстетик течёт всё ещё две единицы жидкости.
Да. Ну, вот я и хочу отметить,
да, что как бы в потоке
не обязательно вся вода течёт из эстетик,
потому что в принципе есть вот такие,
могут быть вот такие циклы. То есть, более того,
я могу здесь даже ноль нарисовать
и получается такой парадокс.
То есть, как бы сеть вроде работает,
какая-то вода течёт, но тем
не менее из эстетика вода
ничего не перетекает.
То есть, такое
бывает.
Вот. То есть, что-то
из, знаете, что-то из цикла, что
как бы, то есть, вроде сеть
ничего полезного не делает, но как бы
рабочие места мы обеспечиваем.
Что-то из цикла очень точное определение.
Вот.
Да.
Вот.
Так что тут
то есть, видите, поток, вот вещь такая.
То есть, поток так подразумевает, что какая-то
вода может как бы циркулировать.
Вот. То есть, понятно, что
я привёл пример одного цикла,
но тут они могут быть несколько.
А, ну, например, что-то далеко ходить. Я могу ещё вот так
нарисовать, в принципе.
О.
А нет, так не могу.
О. А вот так могу.
Вот так.
Ну, то есть, видите,
как бы тут более сложная структура, то есть, хотя она
конечно декомпозируется на два цикла.
Давайте к композициям чуть позже поговорим.
Вот.
Ой.
Итак.
Вот.
Но вот возник уже действительно важный вопрос.
Да.
То есть, возникает
действительно важный вопрос, почему, например,
в таком определении, да и, в общем-то, в том,
действительно оказывается, что
сколько воды вытекает из-за стока,
столько втекает. То есть, в общем-то...
В первом определении мы какие-то ограничения на С
от УВУ накладываем?
Эээ...
Как мы действуем с тем, что у нас...
Нет, на С мы никаких определений
ограничений не накладываем.
С от УВУ и С от ВУ никак не связаны?
Да, С от УВУ и С от ВУ никак не связаны
ни в этом определении, ни в этом.
Это тебе дали сверху.
Вот. Нет, то есть, это просто
размеры труб. То есть, единственное ограничение,
которое есть здесь, то, что они не отрицательные.
Вот.
Это все, что дано.
Вот. Ну, теперь вытекает...
Ну, если мы хотим определить, что сколько вытекло,
столько втекло, нам бы действительно определить.
А что такое вытекло-втекло?
И вообще, что такое величина потока?
Какой поток вообще лучше?
Ну, нам, конечно, лучше, чтобы
чем больше мы перекачиваем из С в Т, тем лучше.
Но теперь надо определить.
А сколько воды мы прям вот перекачиваем
из С в Т?
Ну, разница...
Ну, вот.
Ну, а мы видим, да, здесь
в этой сети определение очень просто.
Сколько воды вытекает из Истока, но с учетом
отрицательности, обратите внимание.
То есть, важный момент,
да, то есть, если я напишу...
То есть, вот в этой терминологии определение,
то тогда у меня получится чуть по-другому.
То есть, здесь мне придется
написать. Определение 1
это, значит, модуль
ФС. Да, вот эту штуку
я называю обычно модуль ФС. То есть, типа
пропускная способность, определенная через Исток.
Ну, не пропускная способность, а вот
величина потока.
Она равна
сколько воды вытекает
из Истока.
То есть, пишем...
Это временное обозначение, которое потом
обозначается просто на модулях, да?
Ну, по факту, да.
То есть, E точка start, пардон,
равно S.
Почему мы не вычитаем то, что это было?
Потому что я это еще не дописал.
Вот, я вот хочу обратить
внимание, что в этой, смотрите,
в этой пределе тупой
такой, так сказать, это...
Сейчас, каким точным русским
словом заменить английское straightforward?
Прямолинейным.
Да, прямолинейным.
Нет, это как литературно слишком.
Да.
Да, лобовым.
Во. Да. А.
Лом. Да, тупо. Да.
А дуболомным. Во.
Вот дуболомным. Вот это да.
Вот это дуболомное определение,
но тогда оно приводит к тому,
что приходится писать вот это вот.
То есть, приходится вычитать, сколько
вернут. То есть, как бы...
То есть, чтобы не было такое,
что на самом деле у нас вытекает аж на миллион
воды, просто полмиллиона возвращается
в качестве отката там какого-то.
Ну да.
Не, ну если уж мы говорим о коррупции,
ну как бы да, нет. Вот здесь все явно
прописано, что есть вода, которая вытекает,
а есть вода, которая возвращается.
А здесь?
Нет, а вот здесь
к челке?
Нет, здесь это прописано.
Вот E маленько принадлежит E большое,
там что-то явно прописано, и не E
старт равно S.
В смысле, E точка старт равно S.
Я бы просто обозначал на самом деле S
стрелочка, а входящий
стрелочка S.
Нет, ну может так, но я здесь пишу
максимально формально, потому что там если
чем более такие определения вводить,
то есть вероятность, что кто-то
просто не поймет, что в голове не та картинка.
Да, совершенно верно.
Ну и туда.
Нет, мы это делаем
сейчас мы определение пишем только для
истока, но это на самом деле
нет, правильные вопросы, которые вот говорят о том,
что действительно заниматься формализмом полезно.
Почему?
Потому что, да, интуитивно вот могут такие вопросы
возникать, и это как бы говорит, что может быть
мы неправильно как-то это говорим, или что-то такое.
Вот.
Но оказывается, ну вот,
но чуть позже убедимся, что на самом деле ничего страшного
там в этом нет. То есть, в принципе,
если по какому-то циклу вытекла вода,
протекла и вернулась, то на самом деле
мы ее прибавили к потоку, мы ее вычли,
она не считается.
Если она в цикле крутится, она не возвращается.
Нет, если она крутится в цикле
несвязанном СС, то, да, мы ее и не считаем.
Потому что для нас поток это сколько перетекает из СВТ.
Если у тебя цикл несвязанный СС,
пофиг, если он
связанный СС, то мы вычтем.
Если там есть какой-то припирил, то так быть не может.
Ну как-то так.
Но важный момент такой,
потому что одно дело наша интуитивная
картинка, другое дело еще все-таки
работает ли
формализм. Потому что формально
F это просто
какая-то функция,
которую мы избрали. Вот такая функция
с вот такими свойствами.
Возникает вопрос,
ну вот есть определение, сколько воды
вытекает, почему здесь
никакого минуса нет?
Вот минус прописан вот здесь.
Видим, да?
То есть просто, когда вода
вытекает в нас, то мы это
учитываем просто со знаком минус.
Поэтому здесь получается,
оказывается, видите, мы пишем короче.
Видите, да?
Или не видите?
Нет, ну мало, просто я смотрю,
кто-то смотрит, щурится, поэтому
не знаю. Вот.
А вот есть второе определение.
Почему? Надо определять,
как бы из истока, мало ли там, что там
по откатам берется, надо определять не
сколько вышло из истока, но
то, что до стока дотекает.
Вот. Правда там могут быть
симметричные накрутки.
То есть я думаю, до меня дотекает пять, а мне нужно
продемонстрировать, что дотекает десять. Ну давайте я тут
циклик какой-нибудь забабахаю.
Теоретически могло бы быть.
Но здесь
заметим, что здесь такой циклик как бы
ничтожится, очевидно. Ну а здесь,
как вы понимаете, здесь можно написать тоже
идентичное определение.
Да, то есть тоже там
будут модуль ft
равен, соответственно, чем он там
равен. Там тоже сумма f от
e минус сумма f от e.
Вот.
Только здесь
оговорка, что тут
сколько втекает во-первых в сток
и тут конечно сколько
вытекает из стока.
Вот.
Вот.
Интуитивно кажется, что
если вода нигде не появляется и не исчезает,
а мы прям вот прописали, что у нас такое должно быть,
то интуитивно
уже кому-то вообще кажется, что
уже из этого следует, что в общем-то
эти две величины должны быть
эквивалентны.
Но как бы вы уже понимаете, что
формально это не ответ, хотя конечно
кого-то спрашивает, кто-то так пытается удивленно,
что вода нигде не скапливается, все.
А чего вы от меня еще хотите вообще?
Ну вот.
Как вам сохранение
достаточно
антисимметричности только?
Нет.
Просто сумма
всех f и краб на 0.
Ну не скажите. Вот давайте смотреть.
Ну вот давайте разбираться.
Вот сразу говори, вот у нас возникает
лемма о том, что
определение 1, определение 2
и т.д.
Вот.
Ну и вот тут собственно
доказательства.
Значит, ну давайте попробуем.
Да, тут описан какой-то
текст. Так что давайте
попробуем написать это, расписать это в более
цивильном виде и понять, что это
вообще значит.
Значит, смотреть.
Так, ну ладно, это я уже могу
вот в принципе стирать.
Марил? Марил.
Нет.
Конечно понятно, что это
все по телевизору pokажут.
Вот, значит, смотрите, теперь давайте посмотрим, что же там написано.
А написано там примерно следующее.
Там написано, что ноль равно...
Чему же равен нулю?
Что же равно нулю?
А нулю равно следующей эпической суммы.
Мы прибираемся по всем вершинам не из стока из стока.
Вот.
И в каждой из них суммируем, сколько воды вытекает.
Вот так вот пишем.
Видите, да?
Это верно тупо по третьему свойству.
Потому что, видите, мы тупо сложили вот такие величины, которые равны нулю.
Видите, да?
Вот.
То есть это вот можно так действительно формулировать.
Ну а теперь заметим следующее.
Что я могу в принципе сказать, что эту сумму можно разбить на два слагаемых.
Где слагаемые на сумму, в которой вершина В тоже не из стока из стока.
Вот так вот, да?
Вот.
И то, что собственно вытекает из стока и вытекает из-за стока.
То есть можно просто вот так написать.
Так, только здесь я пишу.
Так, нет, не так.
Вот так пишем.
Тут мы пишем С.
И тут мы пишем вот так.
Вот.
Вот.
Ну а теперь, ну вот.
То теперь замечаем, что у нас есть мистическое первое свойство.
Антисимметричное.
Ждю.
Ага.
Да.
Да, неправ, неправ, неправ.
Да.
В, С, В, Т.
Да, прошу прощения.
Неправ, неправ, неправ, неправ.
Какая?
Подождите.
По токе мы сейчас изучаем первое.
Да.
Да, я сейчас просто расписываю доказательства, которые вот там.
То есть вот как бы.
То есть да, к сожалению, да, его там можно, его там нужно как бы еще раз парсить.
Но соответственно.
Значит, смотрим.
Ну вот.
Ну а теперь замечаем, что по первому свойству вот это можно убить.
Видите, да?
Потому что мы тупо пробегаемся по парам вершин одного и того же множества и суммируем
F от УВ.
Поэтому там в силу антисимметричности там напарники убиваются.
Вот.
СТ.
Ну да, то есть если совпадает, то все равно работает.
Да.
Поэтому здесь можно аккуратненько, ну и здесь вот можно там вот промотать несколько
нот.
То есть пробегаемся, сколько у нас тут F от ВС.
Ну я просто переписываю, чтобы пока не запутаться.
Вот.
Ну в принципе можно заметить, что на самом деле вот эту оговорку без СТ я могу в принципе
и выкинуть.
Вот.
То есть могу сделать вот такой переход.
Ну опять из антисимметричности.
Ну по сути да, потому что, во-первых, по антисимметричности, да, заметим важное
приятное свойство.
F от УУ равно нулю так или иначе.
Вот.
Вот соответственно.
Поэтому что я здесь добавил, поэтому по сравнению с этими нулями, что я тут добавил?
Тут я добавил F от СТ, как бы да, а тут я добавил F от СТ.
Они друг друга поубивали, поэтому, собственно, ничего не поменялось.
Вот.
Но тогда что это такое?
Заметим, что вот это вот F от ВС плюс F от ВТ равно минус величина потока по истоку
плюс величина потока по стоку.
Все, доказательство окончено.
Вот.
То есть вот такой формальное доказательство получилось.
То есть действительно оказывается, что по такому определению, сколько втекает,
столько и вытекает.
Не больше и не меньше.
Ну в качестве упражнений вам остается провернуть то же самое доказательство,
но в другое определение.
Ну то есть суть будет абсолютно так же, только букв придется тут писать в два раза больше,
потому что внутри каждой этой суммы вам придется тут в явном виде писать,
типа сколько вытекает, минус сколько втекает.
Вот.
А так просто свойство антисимметричности позволило вам этого не писать.
Вот.
Значит это нас и приводит к тому, что получается, что это два определения эквивалентные,
тогда эту величину мы теперь называем просто модуль F и объявляем, что это просто величина потока.
Так.
Есть ли тут какие-то вопросы?
Маленькая тонкость еще про то, что мне не очень понятно, почему топливный, который вы дали,
и той эквалентной с точки зрения материи, потому что там вот вы рассматривали ребра.
Да.
Ну.
Нет, отвечу.
Нет, я отвечу.
Я отвечу.
Идея в следующем.
На самом деле оно эквивалентно более-менее в том плане, что, как я уже сказал,
что если у вас есть кратные ребра, там три трубы, допустим,
то с точки зрения этого определения просто это одна большая труба с общей пропускной способностью.
Нет, это понятно получить.
Из того, это мы свели мотоопределение к этому обратную сторону.
Нет, обратная сводится просто совсем в тупую, просто в обратном случае не будет кратных ребр.
Сейчас.
То есть, во-первых, можно просто в тупую сделать, только просто с оговоркой,
что, во-первых, не будет кратных ребров, то есть могут быть ребра с нулевой пропускной способностью.
Правда, это нас не сильно волнует.
Нет, просто здесь у нас граф по факту не ориентирован.
Нет, почему нет?
На самом деле нет.
Ну, не совсем так.
Граф ориентированный.
Не ориентированный, а с мультирёхами.
Здесь вот без мультирёха.
Да.
Да, то есть, конечно, то определение более практично,
потому что оно, во-первых, подразумевает мультирёбра, точнее их возможность прямо с ними работает,
а во-вторых, что самое главное, почему оно практичнее,
оно не подразумевает, что размер графа обязательно в квадрат.
То есть, если у вас там сеть в реальности на 100 тысяч вершин и 200 тысяч ребер,
то определение его кушает, а это не особо.
То есть, это нам может быть важно именно с нашей практической точки зрения,
когда мы будем время исследовать.
А мы же будем исследовать.
То есть, у нас же там 8 точки будут какие-то там всякие зекорни и СВ там какие-то возникать, да?
К сожалению, будут.
Нет, почему к сожалению?
Там как раз красота.
Что, разве не кайф, что это?
Оказывается, если у тебя 2 доли граф на 100 тысяч вершин и 200 тысяч ребер,
то про сочетание ищется.
Кун заходит просто.
Ну, как бы...
Кун заходит, ну, удачи, удачи.
Честно скажу, у товарища Данилюка другое мнение по данному вопросу.
Межсорт 3?
Нет, он может этого не знать, потому что он не знает, что это так называется.
Там полный протокол межсорта, наверное, он там в том или ином виде сталкивался.
Это, конечно, типичная программистская там попытаться доказать человеку, что он тупой,
потому что он не знает, что означает вот эта аббревиатура.
Там выясняется, что да, он как бы прекрасно ей пользуется,
просто он первый раз слышит, что она так называется.
Ладно, ну, это мы с тобой.
Кто больше, чем Динец?
Кун больше, чем Динец.
Ну, там по-разному, ладно.
Нет, на самом деле просто я почему умненько упомянул,
просто у него есть типическая задачка на эту тему,
с которой мы чуть позже обязательно столкнемся.
Да.
Ну, то есть это шедевры.
Ну, я думаю, что это шедевры.
Ну, я думаю, что это шедевры.
Ну, я думаю, что это шедевры.
Это шедевры.
Прям на эту не гарантирую.
Но домашнее задание, естественно, на потоке будет.
Ну, вообще...
Чем отличается контест от подобных?
Ну, потому что нет, домашнее задание конкретно на эту тему,
как будто конкретно на эту тему Данилюка будет отдельный конкретный контест.
А у нас этого, как вы догадываетесь, не будет, у нас как бы будет единый контест.
То есть понятно, что там задачи будут на много чего, но соответственно.
Ладно.
Смотрите.
Так вот, вот мы дошли до примера, кстати.
Да.
Так.
Ага, да-да-да.
Только давайте не...
Но давайте все-таки аккуратно, произведите уважение к реально существующим городам в Канаде.
Вот.
Так что, соответственно.
В конце концов, да, видите?
То есть это отдельно.
Интересно, что как бы...
Что как в авторы картинки выбрали именно города Канады, почему-то.
Но, соответственно, почему бы и нет.
Может они там все четыре канадца, я не знаю на самом деле.
Вот.
Ну вот, в принципе, действительно можно действительно вот думать, что у нас дороги устроены это вот таким образом.
То есть, скажем, из Калгари до Ригины может доехать не более 14 машин в единицу времени.
Вот.
Но это неплохо, потому что, скажем, из соскотуна до Калгари может приехать не более чем 9.
Вот.
Но, соответственно, да, мы можем сказать, что давайте скажем, что там и стоком является Ванкувер, там стоком является Винни-Пек,
и нам жутко интересно наладить бесперебойную передачу каких-нибудь грузовиков из Ванкувер-Винни-Пек, чтобы там каждый день приезжало как можно больше.
Вот.
Что же у нас получается?
А получается...
Но, в принципе, да, вот у нас есть пример потока, то есть мы решили, что действительно отсюда из Ванкувера в Эдмонтон будет ехать там 11 грузовиков, допустим.
Из Эдмонтонов-Соскотун 12.
Так, что там, обсуждение какое-то пошло, вопросы?
Вот.
Ну здесь у нас 12, здесь 15 и так далее.
Вот видите пример.
Ну здесь все просто, величина потока 19.
То есть мы надеемся, получается каким-то мистическим образом 19, соответственно, грузовиков каждый день выезжают из Ванкувера.
Что такое 8-13 грузовика?
Нет, это не 8-13, это не 8-13, это 8 из 13, вот то, что тут нарисовано.
То есть как бы пропустая способность 13, но едет 8.
Ладно.
Вот.
И вот таким вот образом мы добиваемся того, что едет целых 19, собственно, грузовиков в единицу времени.
Да.
Теперь внимание, вопрос.
Да, можно ли это оптимизировать?
Да, там цикл есть, можно убавить.
Но это оптимизация, скажем так, чтоб по дорогам меньше кто-то ездил, но не более того.
Он в другую сторону ведет, тогда нельзя.
Ну по-разному.
Ну вот теперь надо, ну тут надо вот действительно думать.
Так, вот как же это понять?
Я вижу разрез.
Я тоже.
Можно убавить 4 из цикла и добавить еще 4 потом.
Чего, куда?
Да, вот ребро, видите, которое диагонально с права вверху, в лево вниз.
Так.
Да нельзя в другую сторону пускать, у нас же уже ориентированы.
Нет, тут, смотри, нет, эту четверку можно перенаправить сюда, это правда, но тогда здесь будет втикать на 4 меньше, поэтому здесь...
Нет, у нас есть разрезы 12, 17, 7, 4, 4.
Как вы еще хотите больше?
Вот можно его двумать.
Первый цикл 2, 3, 4.
Удаляем 2, 3, 4.
Ага, ну да.
Ну можно об этом думать, да.
То есть что-то может, да.
Но тут вот действительно важный момент оказывается, просто чисто иллюстрируется.
Что если у вас задача придумать, взять, вот у меня еще есть какой-нибудь новый грузовик и хочется найти для него маршрут, то мы видим действительно утык.
Потому что мы заметим, что как бы, допустим, он отсюда уже выехать не может, там допустим здесь как-то проехать не может, так что кажется, что тупик.
Вот, то есть так он проехать тоже не может.
Кажется, что увеличить поток нельзя, но это называется жадно нельзя.
Вот, то есть как бы жадно, то есть если мы хотим только увеличивать потоки, нельзя.
Но как правильно замечено, то есть действительно что-то тут, какие-то оптимизации возможны.
Как минимум давайте, можно оптимизировать дорогу действительно, чтобы вот по этому циклу отменить одну машинку.
Вот, то есть одну машинку, это как минимум, то есть поток не изменит, но будет меньше ездить.
Но зато неожиданно выяснится, что тут окажется 11, тут окажется 0 и в принципе вот по этому пути можно еще что-то протолкнуть оказывается.
То есть оказывается, то есть надо, то есть как честно, то есть оказывается, да, если мы пожертвуем каким-нибудь потоком, который уже есть, то может оказаться, что мы потом можем пустить больше.
Или циркуляцию какую-нибудь поотменяем, или что-нибудь еще в этом роде.
Так, но давайте посмотрим, как это предлагается, поэтому предлагается такой более продвинутый, хотя тоже жадный подход.
Да, то есть классический подход здесь называется остаток читая сеть.
Значит, внимание, да, то есть помните, то есть точки зрения практики можно сразу сказать, что остаточной сети не существует.
Помните, да, то есть остаточная сеть не существует, то есть это математическая абстракция.
То есть как бы условно говоря, когда вы будете там командовать какой-нибудь там тетеньке на вот этом руле,
в конкретном усле водопровода, то есть она не будет ничего знать об остаточной сети.
То есть она будет понимать только простые запросы вида, сколько пускать в литрах, соответственно.
Но нам в абстракции оказывается удобно мыслить, вот давайте ввести остаточную сеть по принципу, по какому?
По какому? Вот по такому принципу, то есть по каждому ребру мы пишем, а сколько у нас?
Так, что там опять за параллельное обсуждение?
Все, можно продолжать?
Или нельзя?
Можно?
Нет, ну просто не очевидно, мало ли о том, что вы что-то так активно обсуждаете, я не знаю.
Смотрите, предлагается такое, пишем остаточную пропускную способность, то есть формально говорим так,
пусть у нас есть сеть с пропускной способностью и с током с током, и в ней течет поток f,
тогда остаточная сеть, это сеть с теми же самыми, то есть там теми же самыми с током с током и с графом примерно,
но с маленькой, но пропускная способность у нас cf, остаточная, теперь другая, это просто, то есть разность между пропускной способностью и исходной, сколько там течет.
Ну или в переводе говорят, сколько еще воды можно пустить по этой трубе?
Вот.
Вот.
Ну, скажем, пример можно тот же и привести.
Правда видите, как интересно сразу, что с одной стороны тут формально, математически тут все понятно, но с другой стороны это не совсем связано вот с этим.
Правда ли, что это не минус перед c, а типа так t?
Это t.
Ну то есть не минус.
Нет, боже упаси.
Это не минус.
И теперь вот смотрим.
Правда ребра у нас с точки зрения картинки появляются как будто новые ребра.
Видите, вот у нас было ребро 8 из 13, тогда в остаточной сети мы с одной стороны говорим, что в эту сторону можно пустить еще 5 грузовиков,
но оказывается формально, что у нас появляется вот такое ребро, потому что формально, потому что вот это ребро есть, просто у него пропускная способность ноль.
Но по вот этому математическому определению в эту сторону едет минус 8 грузовиков.
Поэтому получается можно пустить еще 8 грузовиков.
Ну это классическая ситуация, то есть есть же стандартный мехматовский анекдот на эту тему.
И как раз вот это произошло.
Там ехало минус 8 грузовиков.
Нет, более типичная ситуация такая, значит такая лекция, на лекцию пришло 3 студента.
Внезапно пятеро встают и уходят.
Электрогрузство думает, ну вот сейчас еще двое придут, вообще никого не будет.
То есть это вот типичная ситуация, с которой мы тут живем.
А потом появляется человек, который 3 раза подряд заходит, не выходя.
Нет, ну почему?
Нет, ну почему не выходя?
Он как бы зашел, вышел, зашел, вышел.
Он зашел, зашел, зашел.
Это как?
Ну нет, ну нет, это уже, да.
Но это как следить, это как бы вас вводит в заблуждение, если вы не знаете, что есть другой выход.
Потому что нет, конечно, на этом основан этот стандартный герметик.
Действительно, как обмануть злую консьержку, которая не хочет пускать гостей.
Очень просто.
Значит, вы так входите.
Ну, значит, если вы житель, она вас знает.
Вы входите, говорите, привет, тетя Люба, погодка сегодня отпад.
О, привет.
Ну вот, значит, вы там поднимаетесь на пятый этаж, открываете окно, спускаетесь по пожарной лестнице.
Значит, вы входите, дверь, и говорите, привет, тетя Люба, погодка сегодня отпад.
А разве не ты только что зашла в этот момент?
Значит, вы входите, дверь, и говорите, привет, тетя Люба, погодка сегодня отпад.
А разве не ты только что зашла в этот момент?
Ну что вы, тетя Люба, опознались.
Значит, с улыбкой поднимаетесь на пятый этаж, выходите из окна, спускаетесь по лестнице.
Ходите, привет, тетя Люба, погодка сегодня отпад.
Но где-то максимум на седьмой интерации тетя Люба падает без сознания.
Вот, ну, собственно, стандартный гералашевский метод.
Там, собственно, он очень красочно описан.
Вот.
Он основан на том, что бабушке не пришло в голову, что есть и другой выход.
Да.
Ну и тем более, что это были старые времена, там у него камер видеонаблюдения за всеми окнами не было, поэтому, соответственно.
Асад.
Ну вот.
Вообще-то, да.
Вот.
Так вот.
Ну, это, соответственно, немножко другое.
Так что у нас тут обычно все-таки, как бы, вошел, то есть, вошел, вышел все-таки.
Вот.
Ну, в общем, на эту тему будем тоже обсуждать.
А пока же так.
Значит, зачем нам нужна эта остаточная сеть?
Потому что, в таком виде, остаточная сеть позволяет нам судить, а где еще можно пустить воду.
Но что такое пустить?
То есть, в остаточной сети, если ее вот так вот нарисовать, то оказывается, что появился путь из С в Т по ненулевым ребрам.
По ненулевым в остаточной сети ребрам.
Вот они.
Но что это означает?
Можно ли, очень хочется по этому пути пустить поток.
И оказывается, в некотором смысле это вполне можно сделать.
Потому что, ну, скажем, вот тут 5, 4, 5, ну, значит, надо пустить 4 единицы жидкости.
Так, ну, что значит по этому ребру пустить 4 единицы жидкости?
Ну, 8 увеличить до 12, правда?
Тут все нормально.
Но здесь, казалось бы, как тут пустить 4 единицы потока, если у вас ребро ведет только сюда?
Очень просто.
Надо просто отменить 4 единицы потока, которые в эту сторону идут.
Тогда как раз получается, что отсюда-сюда будет течь на 4 единицы больше.
Было минус 4 единицы, стало 0.
Очень удобно.
Почему это ребро 4, а не 13?
Почему 13?
Посмотрите, тут 4 из 9.
Нет, смотрите, тут фишка такая.
В эту сторону получается 9 минус 4, то есть вообще 5?
Нет, ну, а в ту?
А в ту сторону на самом деле, то есть на самом деле тут ребро, то есть с точки зрения нашего определения,
там на самом деле нарисовано ребро, и тут должно быть написано минус 4 из нуля по-хорошему.
Ну и мы получаем 9 минус минус 4?
Нет, не получаем.
Потому что в эту-то сторону пропускная способность не 9, а 0.
Вот, да, это важно, обретите внимание.
То есть пропускная способность симметричной не является, боже упаси.
Это важно.
Поэтому здесь получается нот, то есть минус 4 из нуля.
Вот, то есть да, но видите, как интерес получается, то есть в матрице смешности в общем-то новых ребер не появляется,
просто мы их тут не везде рисовали, а вот в определениях вот этой доски на самом деле у нас проблемы.
То есть там эту остаточную сеть еще придется придумывать.
Потому что, смотрите, то есть здесь формально, внимание, формально, остаточную сеть придется допиливать следующим образом.
Смотрите.
Ф от УВ?
Ну если Ф от УВ, Ф от ВУД, почему-то, да?
А погодите, мы тут Ф не определяли, мы здесь определили, только смотрите, мы определили понятие остаточная сеть.
Понятие остаточная сеть и понятие поток в ней, это разные вещи.
Да, имеется в виду, просто здесь пока иллюстрируется следующее, что если у вас есть остаточная сеть и в ней есть путь из СТ по не нулевым ребрам,
то на самом деле этот путь показывает, где можно увеличить поток.
То есть вот пустить в остаточной сети вот эти четверочки, чего?
СФ?
СФ, да, это индекс Ф, кстати, обратите внимание, не видно, да, это важно.
Да, это индекс Ф.
То есть что означает, что вот тут можно пустить 4, то есть в реальной жизни с точки зрения там, собственно, реальных бабушек получится так,
мы говорим, что тут плюс 4, тут отмена 4 и тут плюс 4.
То есть видите, у нас такая идея, кстати, уже где-то крутилась, что давайте отменим вот эти четверки, тогда эту четверку нужно куда-то перенаправить.
То есть здесь-то можно четверку перенаправить, но тогда здесь втекает, тогда сюда втекает на 4 единицы меньше.
Откуда эти 4 единицы взять?
Ну вот, оказывается, можно просто по этому ребру пустить четверку.
Вот.
То есть ну вот, ну оказывается, мы нашли это с помощью вот такой классической технологии.
Это вот называется остаточная сеть.
Ну вот.
То есть так она вот выглядит, но формально с точки зрения программирования нам придется ее с вами как-то определять нетривиально.
Потому что здесь придется тут немножко пописать.
Потому что там-то мы еще воспользовались тем, что в принципе у нас в серии образ существует просто у некоторых большинства пропускная способность 0,
а тут этих ребер не существует и их придется в явном виде ввести.
Вот, понимаете, да?
Поэтому предлагается следующее, то есть пусть у нас значит сеть, значит g равно там v, e, c, s, t, это соответственно сеть.
Но мы все еще не хотим делать квадрат, мы хотим определять.
Да, это, нет, это вот альтернатива.
Нет, почему я как бы цепляюсь за эту альтернативу?
Потому что как бы понятно, что граф в виде матрицы смежности вы будете хранить не всегда.
То есть скорее всего вы, наверное, список смежности вы хотите все-таки хранить.
Вот.
Поэтому как бы хочется, поэтому очень хочется действительно сеть строить так, чтобы в ней хранить только те ребра, которые реально надо.
Вот.
Итак, пусть у нас g это сеть, а пусть af поток в ней.
Тогда, остаточная сеть, остаточная сеть cf, не cf, а g с индексом f.
Вот мы будем значит остаточную сеть тоже определять как той же буквы, что исходную сеть, но с индексом f типа по потоку в ней.
Видите, да?
Значит gf, это сеть.
Значит v, e с индексом f, c с индексом f, s и t.
Ну v, s, t понятно.
Что такое?
Значит, а что такое e, f?
А вы точно хотите вонять разные значения g и c?
G и c в смысле?
В смысле g это сеть, c это пропускная способность в ней.
Не путайте.
Вот.
Значит, где получается, как определяется e?
Значит, где, смотрите, e, f равно, просто по определению это я так присваиваю, ну помните, да?
Значит, оно равно, я так скажу, e объединенное с обратными ребрами, я так это назову,
рев от e.
Вот так скажем.
Ну в общем так, я скажу так, рев от просто e, да?
То есть, ну рев от вот этого вот ребра, которое вот u, v что-нибудь, да?
Оно равно просто ребру v у что-нибудь, да?
Ну просто вот разворот ребра, операция такая, да?
Ну вот.
Ну а здесь это именно разворот ребра.
Значит, какая у него будет пропускная способность, я сейчас скажу.
Вот. То есть, рев от e, это естественно просто называется множество рев от e, где пробегаемся по всем ребрам.
Вы видите, почему у вас множество?
Вы имеете в виду, что ребро задается не только в начальной и конечной вершины, а еще какими-то параметрами?
Ну на каждом ребре у нас вообще еще там пропускная способность какая-то написана, там это.
Хотя ладно, давайте, пожалуй, для удобства действительно давайте уберем это.
Хорошо. Рев от u, v равно v, то есть просто вот так.
Чего? Что не так?
Что не так?
Вот. А теперь смотрите, при этом c, ну вот.
При этом, значит...
Чего-чего-чего?
Могли быть.
И более того, для каждого...
Ну опять, может, немного некорректность, но здесь имеется в виду следующее.
Для каждого кратного ребра вводится свое обратное.
То есть количество ребр прям вот в явном виде удваивается.
Даже если у ребер там обратное уже было, то мы его...
Ну да, но там это уже другое.
Отдельная песня, как вы это будете конкретно кодить, но мы чуть позже об этом поговорим.
И вот здесь у нас технология, чтобы их как бы с кратным действием не зависеть.
Теперь надо ввести, значит, понятие.
Значит, cf от e, оно равно чему?
Оно равно просто c от e минус f от e,
если ребро лежит...
Значит, если оно из e, а если оно из rev от e,
то тогда это получается просто f от e.
То есть f от, так сказать,
называется e',
если оказалось, что действительно e равно rev от e'.
e' лежит в e.
Ну я, может, опять Никузева написал, конечно.
Но имеется в виду следующее, что остаточная пропускная способность говорит так,
что если это рев от e, то это значит, что у ребра есть рев от e.
Если это пропускная способность говорит так,
что если это сделать то ребро, которое было раньше,
то просто тогда разность между пропускной способностью и сколько реально потекло.
А вот если это обратное ребро,
то как бы мы говорим, что если по ребру текло 5 единиц жидкости,
значит по этому обратному можно те самые 5 пустить.
То есть формально можно сказать так.
Ну не отменить, а это еще не отмена потока.
Возможность отменить поток.
Ну, e',
e равно
рев от e',
где...
Вот так, да, пардон.
Да, спасибо, спасибо.
Нет.
А нет, правильно.
Нет, то есть мы говорим, что если e – это разворот какого-то ребра из e'.
Пусть у нас было ребро из e',
из разворота которого получилась наша e'.
Тогда остаточная способность этого ребра – это вот поток пущенный.
Так что нет, здесь штрих на месте.
Ну сейчас мы его не учитываем.
Нет, другое дело, что в этой сети тоже можно пустить поток, конечно же, какой-то.
Какие-то может быть больше, меньше.
Но, как я сказал, пока нам это не так принципиально.
То есть пока мы просто...
Вот есть понятие остаточная сеть.
Это вспомогательная математическая абстракция,
в которой мы можем удобно понимать, значит, нельзя ли увеличить поток.
По крайней мере, на уровне лайфхака.
Потому что на уровне лайфхака мы знаем, что если в остаточной сети случайно
есть путь из s в t по ненулевым пропускной способности ребрам...
Важно, что именно по ненулевым, да?
Мы это пока не доказали.
Мы пока это не доказали.
Нет, почему?
Нет, ну на самом деле мы уже...
Ну практически очевидным вот из этой картинки является следующий факт.
Если в остаточной сети найдется путь из s в t по ненулевым ребрам,
то увеличить поток в исходной сети можно.
Это вроде должно быть очевидно, да?
Про то, что если такого пути нет, то и поток максимальный, я еще ничего не говорил.
Сейчас, если найдется путь по ненулевым ребрам, то мы запускаем по нему...
То в исходной сети мы просто соответствующие единицы потока по этому пути запускаем.
Потому что этому пути, то есть каждому ребру из этого пути соответствует,
либо ребро из исходной сети, по которому можно еще столько пустить,
либо ребро, идущее в другую сторону, по которому столько единиц воды можно отменить.
Поэтому делая последовательно это, мы, собственно, и увеличиваем поток в исходной сети.
То есть можно его отменить на минимум из пропускной способности по пути.
Ну ладно, из первого определения это вообще видно?
Нет, ну вот.
Ну и с второго на самом деле тоже, потому что здесь мы просто в явном виде
прописываем... То есть здесь просто в явном виде прописано то же самое.
Потому что за счет чего мы можем поменять поток по какому-то ребру?
За счет того, что с одной стороны мы можем пихнуть больше, если такая возможность есть?
Это вот первый случай.
А второй случай говорит о том, что можно еще поток по ребру уменьшить,
и это идентично тому, что мы пустили воду в обратную сторону.
То есть на самом деле это продолжается иллюстрация того, что это в общем-то об одном и том же,
просто с немножко разных точек зрения.
То есть точки зрения формальных математических результатов это первый подход, конечно, в разы лучше.
Но в реальном кодинге, конечно, вы не хотите, вам не захочется кодить матрицу смежности
по очевидным причинам, поэтому придется думать.
Но на самом деле...
На самом деле потоки же применяются обычно все-таки не на статусе.
По-разному. Почему?
Если вы изучите про сочетание в дольном графе, то и до ста тысячах применяется вполне.
И это нормально.
Тем более, что иногда не всегда же потоки вам надо супер максимально найти.
То есть, конечно, чаще всего, если у вас задача, дан граф, найти максимальный поток,
то чемпионский алгоритм, по-моему, сейчас в ЗВЕ работает, если я правильно помню.
Вроде как вам самое чемпионское, что есть, это алгоритм 2015 года ЗВЕ.
Лучше пока, в общем случае, пока вроде не придумали.
В смысле только в 2015 году придумали ЗВЕ?
Ну да.
Итока да.
Ну, насколько я честно, статьи прям так глубоко я не копал, но, насколько я помню,
там с табличкой в Википедии, там показано было про ЗВЕ.
А у нас же такого не будет.
Нет, такого, к сожалению, нет.
Ну, по-разному нет, почему нет.
Ну, как сказать, нет.
Если нет, у нас как бы легко возникнет ЗВЕ.
Ладно, правда с оговоркой, что для этого потребуется сплей деревья, но твой линкат.
Да.
Ну, как бы, но линкат у нас уже был, мы даже убедились, что там логарифом не лог квадрат,
поэтому как бы не проблема.
Вот.
Значит, соответственно.
Ну нет, у нас как бы, да, но зато как бы так как ВЕ приматрица смежности этого икупа,
кубических алгоритмов у нас будет даже несколько.
И вообще-то выясняется, что они, кстати, не так сложно пишутся.
Вот.
Ладно.
Так, смотрите.
Но если говорить, кстати, тоже о формализации, то на самом деле тут вводится еще,
то есть можно еще ввести пару понятий.
Каких-то вот таких.
Аюшки.
В том определении все-таки потока, да.
У нас у всех обратных ребер поток статичен.
Это не странно, нет?
Ну, то есть если ребро обратное, то у него величина потока всегда равна
опровосной способности его инвертированного ребра.
Ну, такая, погодите, вы не путаете понятие сеть и понятие поток,
мы в этой сети никаких потоков вообще не пускали.
Нет, не совсем.
Потока мы пока не пускали.
То есть мы говорили, у нас была сеть G исходная, мы в ней пустили поток F.
По этой сети и этому потоку мы построили остаточную сеть.
Это просто такая иллюстрация на тему того, сколько еще воды теоретически,
где можно пустить.
Все.
Никакой воды там нет.
Естественно, если вы меняете поток, то поток не пустит.
Теоретически, где можно пустить.
Все.
Никакой воды там нет.
Естественно, если вы меняете поток в исходной сети, то и остаточная сеть
естественно меняется.
СЕ это опровосная способность.
То есть это сколько мы теоретически максимум можем...
FЕ это сколько мы пустили.
Да, FЕ это сколько реально пустили.
СЕ от Е сколько можем.
Формально увеличение потока по остаточной сети можно расписать так.
То есть формально можно расписать так.
Пусть у нас есть сеть G и F-поток в ней, пусть есть F', который в остаточной сети.
И тогда можно определить увеличение потока F на этот F'.
То есть обратите внимание.
F' это поток в сети GF.
То есть это разные миры.
F живет в сети G, значит F' живет в сети GF.
Тогда, оказывается, F можно увеличить на F'.
То есть я так даже не путь нахожу, а просто увеличиваю аж на целый поток.
Увеличение, понятно, делается автоматическим образом.
И только в качестве упражнения вам только остается показать, что вот это вот увеличение
F' это, во-первых, корректный поток в сети G,
и величина которого равна реально F'
Понятна логика, да?
Но не будем сейчас, наверное, для экономии времени расписывать действительно,
как это выглядит вон там.
Но думаю так, общая суть ясна.
Значит, общая суть ясна.
Тем более, что, ладно, то есть, если возникнет вопрос действительно,
как это кодить в виде списка смежности,
то, на самом деле, сразу можно сказать,
что максимально удобным способом оказывается следующее,
что вы для каждого ребра просто сразу делаете список смежности,
но для каждого ребра автоматически создаете обратное.
И как бы гарантируете, что между ними такая связь,
что если по одному течет поток F, по другому автоматически течет минус F.
То есть, кстати, да, правильнее даже в коде еще продумать инфраструктуру так,
что если вы там пустили по ребру поток,
то автоматически по другому ребру течет минус только.
То есть там в идеале.
То есть в идеале там обычно надо строить так,
чтобы у вас там иным способом поменять поток просто не было невозможно физически.
Вот.
То есть это, кстати, такой подход,
когда вы рядом с каждым ребром храните типа обратное,
то такой подход, он как бы сочетает в себе лучше
и из списка смежности, и из матрицы смежности.
В смысле К-41 вы хотите делать?
Ну, нет, К-41 это уже более техническая деталь.
Потому что К-41 это если вы действительно там храните все ребра в едином большом списке
и векторы векторов,
только храните номера ребер в этом списке.
Потому что в принципе кто-то этим не занимается,
а вместо этого там кидается указателями.
Нет, указателями не надо,
потому что не надо кидать указатели на элементы вектора.
Вот.
Но в принципе теоретически кто-то пишет так,
что допустим вы создаете два ребра,
одно добавляете в один список,
другой в другой,
и в каждом ребре храните,
а в другом списке мой напарник находится под номером вот таким-то.
Ну, в принципе так тоже можно.
Реально, конечно, так делать не надо.
То есть оптимально, конечно,
это создать вектор векторов так,
чтобы рядом с каждым ребром хранилось обратное.
Если вы хотите по ребру найти обратное,
то как бы берем индекс и делаем К-41.
Так, а сейчас понятно, что я имею в виду вообще?
Или нет?
Нет, лучше, если не понятно,
я просто могу сказать подробнее.
С этим не сталкивались, я не знаю.
Но если понятно, о чем речь, то хорошо.
Ладно.
Впрочем, не суть.
Ладно.
Чего?
Ну, это не принципиально.
Ну, скажем так, это как бы формальное доказательство.
Я думаю, не думаю, что имеет смысл тут сильно прокапываться.
Потому что как бы
возможно вам будет быстрее то же самое
прописать самостоятельно.
Пожалуйста.
Вот.
И так, то есть по этой лемме получается,
что у нас, если в остаточной сети есть увеличивающий путь,
то оказывается поток f можно увеличить.
Ну, пока эта лемма говорит только одно,
что в остаточной сети есть путь, значит можно увеличить.
То есть это продвинутая версия.
То есть мы думали, можно ли поток увеличить?
Первый вариант жадно.
Просто можно ли там найти какой-то путь в исходной сети,
по ненасыщенным ребрам?
Да, на всякий случай сразу еще введем такое понятие,
которое мы интуитивно постоянно пользуемся.
Ребро насыщено, если по нему потекет максимальный поток
с соответствующей пропускной способностью.
То есть если f равно c, то как бы ребро насыщено.
В ином случае оно ненасыщено.
Так вот, можно в исходной сети просто посмотреть,
без всяких там, без изобретения всяких обратных ребр,
можно ли дойти от st по ненасыщенным ребрам.
То есть есть такой жадик.
То есть если можно, значит поток можно увеличить.
Вот это строго более продвинутая вещь.
То есть как бы существует ли путь в остаточной сети?
То есть мы говорим, что мы можем идти не только по ненасыщенным ребрам,
но еще и можем отменять потоки, то есть ходить по обратным ребрам.
То есть как бы это более продвинутый жадник,
строго более продвинутый,
потому что предыдущее все он включает.
Но как со всяким жадником возникает вопрос,
а всегда лед работает?
Ну скорее все лед находит.
Нет, ну почему?
Ну что такое все?
Ну в плане доказания, что он всегда работает, но возможно он...
Нет, что значит всегда работает?
Тут возникает как бы вопрос...
Нет, что такое корректность опять же?
Все корректно, как бы потоки, которые находят корректны.
Вот это мы догадали.
Да.
Тут возникает вопрос, найдем ли мы максимальный поток?
Хотя на уровне математики возникает вообще вопрос.
Да, но тут формальный вопрос вообще.
А что такое максимальный поток в принципе?
С максимальной?
Ну допустим да, это что-то типа
рассмотрим все возможные потоки и рассмотрим их величины.
Из этих величин выберем максимальный.
Да, но сразу возникает вопрос,
что взять мы можем, к сожалению, только супремум.
И у нас сразу возникает вопрос,
может быть максимального потока не существует в природе?
Потому что может быть этот супремум,
просто конкретно супремум не достигается,
существуют только потоки сколь угодно близкие к нему.
Либо он бесконечный.
А самое худшее, теоретически еще и бесконечность.
Если мы берем потоки, то у нас по идее, что достигается, либо он бесконечный, то не достигается.
Не факт, потому что даже в целочисленных сетях мы не обязаны пускать потоки целочисленные.
Да, но правда нет, мы конечно сразу можем сказать,
что ладно, величины потока все-таки ограничены,
потому что величина потока не может превосходить, например,
суммы пропускных способностей ребер, исходящих из стока, например.
Ну, можно и так, но то, что я сказал, просто напрямую из определения следует.
А так мы просто в доказательстве того упреждения, да.
То есть оценивать можно с полпинка, да,
что просто С большое умножить на модуль Е, все, в принципе, это больше не бывает.
Это да, но можно более точно оценить,
что обычно все-таки речь идет о модуле С на количество ребер там исходящих.
Вот, но не важно, оно ограничено.
Но из этого понятно, это супраймум не будет бесконечностью.
Ну, достаточно доказать, что нам не нужно брать дробные веса ребер.
Чего доказать?
Если мы так намажем, что не нужно брать дробные веса ребер, сразу становится конечной.
Да, но если только целочисленные сети.
Ведь в определениях никто не сказал обратить внимание,
что профессиональные способности обязательно целые.
Вот тогда возникает вопрос.
Существует ли максимальный потом?
На самом деле нет.
Нет, правильно.
Абсолютно правильная идея.
На самом деле ситуация такая.
Рассмотрим последовательность потоков, пропускная способность которых сходится к супраймуму.
Бесконечная последовательность потоков.
Каждый из этих потоков предлагает сколько-то пускать по первому ребру.
Получается последовательность эфок, который предлагает запустить по первому ребру.
Эта последовательность ограничена.
Ц-шкой своей.
Следовательно, потерями бойца на Вейкстраса...
Ну колебания...
И что?
Это не приводит к колебаниям величин поток.
Это приводит к колебаниям того, что бывают нулевые потоки, в которых вода где-то куда-то течет.
А почему по первому ребру можно будет пустить...
Нет, а причем тут сходится?
Ну смотри, утверждение такое.
Нет, там просто говорится, что раз величины ограничены, значит потеряемые бойца на Вейкстраса,
или по какой там, я не помню названия, можно выбрать сходящуюся подпоследовательность.
Что нужно подпоследить?
А, да, очевидно.
Сходимость по качеству ребра.
Нет, смотри, имейте в виду величины.
То есть мы сказали так, что в каждый поток пускают сколько-то по первому ребру.
То есть получается последовательность потоков индуцирует последовательность чиселок.
Сколько опускается по первому ребру?
Это последовательность чиселок ограничена, потому что она н toma.
Следовательно, можно там, из нее можно выбрать сходящуюся подпоследовательность.
Поэтому давайте в последовательстве потоков возьмем вот эту подпоследовательность,
так чтобы поток по этой штуке сходился.
Вот, потом повторим операцию по второму ребру, по третьему ребру и так далее,
пользуясь тем, что мы все-таки с конечными графами работаем.
А мне не очень нравится, почему величина потоков у Супраимома будет действительно...
Нет, мы получили последовательность потоков величины, которых сходятся к максимальному,
но теперь остается только убедиться, что по каждому ребру f сходятся куда-то.
Почему Супраимом по потокам стремится к Супраимому по величинам?
Нет, там не совсем так.
Пока у нас получилась последовательность потоков, величины которых сходятся к...
Нет, смотри, что у нас получилось?
У нас получилось...
Где раз мы применили тюрему Бальца Неверстраса?
Это привело к тому, что у нас теперь есть последовательность потоков,
величины которых с одной стороны сходятся к Супраимому.
Это с одной стороны.
А с другой стороны, мы замечаем, что по каждому ребру
по члену F-ки имеют какой-то предел.
Да, это пока все, что мы сделали.
Да, но на самом деле, да, сделали мы, в общем-то, все.
Остается только сесть и аккуратно доказать,
что мы можем рассмотреть поток,
F-ки которых, это те самые пределы.
Остается только показать A, что это корректный поток,
и B, что его величина равна чему надо.
Но оба раза это, я думаю, достаточно очевидно.
Просто потому что понятно, что если у вас есть...
Ну, мы помним, что если у нас последовательность
не превосходит какой-то C-шки, то ее предел тоже этой C-шки не превосходит.
Там еще нужно, чтобы сумма 0, но она всегда 0.
Да, она всегда сумма 0, поэтому и предел суммы будет,
тоже как сумма пределов, поэтому тоже 0.
Что там еще надо?
А, ну и величину, но величина это тоже сумма каких-то ребер,
поэтому там сумма...
Нет, не совсем.
Величина потока это, извините, сколько у тебя вытекает из-за стока.
Да, но у нас сумма имеется величина как раз вот этому штуку.
Ну, это да, ну да.
Из этого следует, что величина вот этого предельного потока
это действительно предел величины сходных потоков.
Это доказывает, что мы в явном виде построили поток с такой...
Ну да.
Да, именно.
А мы прям...
Так, все будет понятно, да?
Нет, сейчас еще пока думаем.
Так, ну все, удалось разобраться.
Да, то есть да, тут нетриониальный момент, но как бы да.
То есть мы взяли последовательство потоков
с величинами, стоявящимися к чему-то,
оставили из нее под последовательство,
которое сходится не только по величине потока,
но еще и по каждому ребру по члену,
совершили предельный переход и убедились, что...
И тем самым получили сеть, у которой просто...
Получили корректный поток, у которого величина является этим супремовым.
То есть в принципе уже из этого можно сообразить,
что максимальный поток всегда существует, осталось только его найти.
То есть иронично на самом деле исключается в том,
что доказательством на самом деле существования максимального потока
является практически любой алгоритм, который мы сейчас будем изучать.
Ну, точнее тот факт, что он будет работать за конечное время.
Ну вот, но на самом деле убедиться в этом можно и заранее.
Так, да, можно переходить и дальше, но...
Внимание, вопрос. Да, на чем мы остановились?
Мы убедились, что максимальный поток существует,
то есть существует поток, у которого величина максимально возможна.
Да, мы даже убедились, что это да, именно максимум, а не супремов.
Осталось только... Ну вот, и более того, у нас даже возникла
мистическая жадная технология.
Жадная технология говорила, что вот у нас есть остаточная сеть,
и мы можем говорить, ой, а давайте-ка, что мы сейчас сделаем?
То есть, а давайте-ка найдем путь вот этот вот, да?
То есть, дадем... Построим остаточную сеть, попробуем найти путь.
Если путь нашелся, значит, пускаем по нему поток.
Если... Ну вот. И как бы так, и теоретически, я даже заранее скажу,
это может называться метод Форда Фолкерсона.
Давайте так просто искать в остаточной сети поток
и там каким-то образом эти пути находить,
и будем так делать до тех пор, пока путь находится.
Но не поток, потому что поток мы как-то рекурсивно задавали.
Нет, но не поток, а путе, я имею в виду.
То есть, путь, по которому можно пустить поток.
Ну вот, возникает естественное...
Ну вот, но предположим, что мы такого пути не нашли.
Не нашли.
Возникает естественный вопрос, верно ли, что следует ли из этого,
что поток максимальный?
Или может быть, мы уперлись в какой-то неудачный локальный максимум,
который локальный, но не глобальный?
Да, возможно, кто-то сейчас начинает ругаться какими-то словами типа
Матроид.
Ну, может и нет, я не знаю.
Ну, мало ли там, что там...
Ну, мало ли, кто-то из вас был в Тень кофе, а там Тень кофе, вроде,
там ругались такими словами.
Не знаю, возможно, ни в каком.
Ну, как сказать, видимо, столкнуться в ней можно везде,
потому что, нет, я вам честно скажу, я до текущего момента, к сожалению,
вот дожил до своих вот этих вот так седых волос и так и не понял,
что, ну, а ты и так и не узнал, что такое Матроид, на самом деле, если честно.
Нет, ну как?
Нет, смотри, смотри, смотри с точки зрения чего.
Нет, смотри с точки зрения чего, потому что, на самом деле, как бы...
То есть, сформулируем так, то есть, если вы утверждаете,
что достаточно знать то, что знаю я, то как бы, то да,
это вам хватит, чтобы знать этот курс, конечно, но не более того.
Слушай, а честно скажу, для того, чтобы там, то есть, скорее всего,
чтобы там выиграть чемпионат мира ACPC, наверное, знать надо чуть-чуть больше.
Ну, или, пока ими, кодик чуть-чуть лучше надо.
Но это выражается, как минимум, в том, что я просто как бы сейчас не тренируюсь
и так далее.
Ну, не говоря уже о том, что там, понятно, уровень финала 2014 года
и уровень финала 2023-го, это немножко разные уровни все-таки.
Но, впрочем, это ладно, это уже другой вопрос.
Значит, смотрите.
Как говорится, да, поэтому, в принципе, можно сказать, что...
То есть, общая знания, что Матроид, это, видимо, такая абстракция,
которая может теоретически обобщить какие-то жадные ситуации,
которые иногда возникают.
Да, потому что там утверждается, что там Матроидную структуру
имеют какие-то остовные деревья, например, или что-то еще в этом роде.
Но мы не будем это лезть, а на самом деле мы будем работать с потоками
прямо так, как они есть, и сводить это к чему-то великому мы сейчас не будем.
Но мы еще сейчас...
Но перед тем, как доказывать...
Ну, тут на самом деле еще главный вопрос, потому что, знаете,
всегда просто говорят, кто знает, что такое терема Форда Фолкерсона?
Обычно поднимают руки все, но, на поверху, оказывается, что там
многие считают, что терема Форда Фолкерсона, это что...
Как это формулируется?
А, ну, просто, да, что если в остаточной сети пути нет,
значит поток максимальный.
Да, тогда и только тогда.
Так вот, в нашей терминологии нашего курса это не вся терема Форда Фолкерсона,
это только ее часть.
Значит, но чтобы...
Что?
Что 3DMO?
Тут 3DMO не надо, спокойно.
Не, ну, я не знаю, можно, наверное, придумать алгоритм поиска
максимального потока с помощью 3DMO, конечно.
Но зачем?
Ну, это...
Ну, слушай, если задаваться таким вопросом, можно вообще
много чего обвалить.
А потом поймешь, что зря, на самом деле.
Ну, то есть, ладно, философия, это...
Как бы спокойно, философия, это философия, как бы,
философия науки, это то, с чем вы столкнетесь,
начиная с 4-го курса.
Сначала 4-й курс, потом инистратура, потом инспирантура.
Так что, поэтому зачем это все?
Мы как бы будем в меньшей степени задаваться этим вопросом.
Значит, смотрите.
Значит, нам потребуется понятие разрез.
Значит, внимание, не путать.
Потому что, да, поняли, то есть мы уже сталкивались
с понятием разрез, когда изучали остовы.
Но здесь мы столкнемся...
Но здесь разрез немножко не то.
То есть, казалось бы, да, это тоже разбиение вершин
на два множества, да, два не пустых, что важно.
Но здесь есть важная, просто принципиально важная оговорка.
Что мы не просто разделяем на два множества,
мы требуем, чтобы исток был в первом из этих множеств,
в первом из этих множеств, а Т в другом.
Или я эти множества еще называю долями разреза.
Вот.
Это называется разрез.
Идем дальше.
Ну, дальше тут просто формально пишем.
Пропускная способность разреза это...
Так, вот тут тоже внимательно.
Так, ребят.
Так, внимание, тут бы как бы детали лучше не пропускать.
То есть как бы, знаете, да.
То есть, смотрите, что такое пропускная способность?
Это, конечно, что все просто.
Сумма пропусты способностей всех ребер, которые ведут из С в Т.
Значит, но тут очень важно.
Когда мы говорим про пропускную способность разреза,
мы имеем в виду именно ребра, которые ведут именно из С в именно Т.
То есть, ребра, ведущие назад, нас не интересуют.
Но, впрочем, конкретно в пропускной способности, в общем-то,
это нас особо не волнует.
Вот.
А вот сейчас будет прям совсем нетривиально.
Потому что дальше мы вводим понятие чистый поток через разрез.
Вот нам жутко интересно.
Жила-была вот сеть.
Мы, значит, тут нарисовали какую-то границу.
Какую мы границу нарисовали.
Вот.
Вот. Вот такая.
И получается примерно следующее.
Ну вот. И нам жутко интересно,
сколько воды проходит через эту границу.
Но здесь надо аккуратно формулировать.
Потому что, казалось бы, мы пишем то же самое, как в пропускной способности.
Просто суммируем серебра, которые идут из вот отсюда сюда.
Но здесь, конечно, есть маленькая подлянка.
А как вы думаете, как бы мы написали определение,
если бы мы были в другом определении потоков?
Ну, вычислил бы еще просто то, что...
Да. То есть будьте внимательны.
Тогда нам бы пришлось сколько течет в эту сторону,
минус сколько течет в эту сторону.
То есть, как всегда, здесь это учтено,
потому что у нас вот минуса тоже считаем.
Понимаете, да?
Это вот очень важно.
Просто важно на это обратить внимание.
Ну, в принципе, и логично.
То есть сколько воды перетекает через эту границу.
Ну, естественно, наверное, полагать,
что если у нас вода появляется только в истоке и исчезает только в стоке,
то, наверное, логично, что через эту границу столько и притекает.
Но это, конечно, приходится формально доказывать.
То есть так и доказываем, что для абсолютно любого разреза
верно, что чистый поток через этот разрез равен тупой величине потока.
То есть и было у нас два определения
величины потока, а мы сделали из них два в степени n,
два в степени n минус два, определение потока.
Так, подождите, вы говорите, что мы сейчас доказали,
что Макс Поток равен медразряд?
Нет.
Так, я дошел только до сюда.
Я пока еще ничего не сказал.
Я пока сказал, что у нас есть мечта доказать, что там Макс Поток...
Да, то есть такая мечта у нас будет, это уже так,
но это ты пока забегаешь вперед.
Пока я еще такого ничего не сказал.
Пока я сказал, что мы просто захотели рассмотреть разрез,
то есть нам просто стало интересно, что, допустим,
течет у нас какая-то речка, и мы думаем, насколько эта речка
мешает нам действительно запустить там сильно большое число грузовиков.
То есть это просто способность, сколько мы тут теоретически грузовиков
суммарно можем пихать по всем мостам, которые через нее едут.
Чистый поток это же, сколько реально грузовиков едет.
Но при этом соговорка, что у нас у какого-то грузовика маршрут
тут предполагает пересечение реки несколько раз,
то мы должны в такой ситуации не три раза его считать, а все-таки один.
Но здесь это автоматически считать, потому что нужное число раз с минусом
посчитается, ничего страшного.
Разное время.
Чего?
Разное время.
Нет, ну как сказать, разное время?
Ну тут вот, да, тут это, конечно, может немножко путать.
Но тут вопрос о правильном восприятии, потому что, да,
к сожалению, да, проблема, что грузовик едет в течение какой-то количества
времени, а мы как бы уже фиксированы картинки.
Говорим, что тут едет сколько-то машин, тут едет и так далее.
Но тем не менее очень удобно говорить, очень удобно мыслить,
вот, видимо, чуть позже обсудим, в терминах декомпозиции потока на самом деле.
Значит, смотрите, ну вот, ну, значит, возникает такая лемма.
Ну как ее доказать?
Так, ну доказать, что понятно, да?
Ну вот.
Что?
Ну, это, нет, я не понял, чем это отличается от того, что вы сказали, что мы еще не сказали.
Ну пока еще ничем.
Ну пока, пока, как бы да, есть лемма, что чистый поток через разрез равен модуле F, все.
Это просто величина потока в том определении, которое у нас было.
Нет, сейчас, стоп, что?
Ну, в смысле?
Ну, в смысле между S и T?
Ой, не туда.
Да, между S, ну вот, вот у нас модуле F, определение.
Это определение величины поток.
Так вот, я утверждаю, что чистый поток через разрез, что чистый поток через разрез,
это в точности величина этого потока.
Так, чистый поток через разрез индуцируется потоком F.
То есть у нее есть величина, называемая чистый поток, вот это F от S-T.
И вот утверждается, что эта величина совпадает с основной величиной разреза.
Вот.
А, ну давайте посмотрим, что тут вообще написано.
Ну, написано тут, ну я не знаю, прям хочется на самом деле вот это заклинание
на самом деле прям на картинке изобразить.
Просто, звучит так, условно.
Потому что, вот жела была сеть, вот жел был разрез.
Теперь посмотрим.
То есть то, что там написано, иллюстрируется так.
Что такое величина потока?
Это сколько вытекает из истока.
То есть может быть вот так, может быть вот так, может быть вот так, это и так.
то есть может быть вот так, может быть вот так, ну и так далее, понимаете, да?
А теперь давайте к этой величине прибавим для каждой вершины еще вот по такому солнышку.
Вот тут по солнышку, вот тут по солнышку, там, ну и так далее.
Ну солнышка в данном случае, берем вершину, берем вершины вот с этой стороны разреза,
вот тут С, тут Т, и прибавляем к этой величине просто все F по всем ребрам, выходящим из вершин.
Даже с своей стороны, да.
Чего? Ну что, нет, эта вершина должна быть с этой стороны, но куда ребра идут, там, сюда или сюда, нам не важно.
А, в плане мы взяли суммарную величину потоков по вершинам слева?
Нет, ну не совсем.
Ну суммарный поток, выходящий из всех вершин слева, да.
То есть это как раз во втором определении?
Да.
Да нет.
Нет, во втором определении нам надо...
Нет, скажем так, просто нам надо было бы вычитать, потому что сейчас-то можем сказать, почему мы имеем право такое солнышко добавлять, потому что оно все равно равно нулю.
Потому что, помним, суммарный поток выходящий из любой вершины, кроме истока, равен нулю, мы помним, да.
Поэтому взяли солнышко.
Но тогда, ну с другой стороны, заметим, как правильно замечено, что тогда у нас получается, ну то есть у нас там получается, давайте вот, то есть получается модуль f равен, получается сумма по всем, значит, вершинам в s, значит, сумма по всем u, f от uw.
То есть f от vu.
Вот.
То есть это мы вот все эти солнышки добавили.
Но теперь заметим, что по антисимметричности все ребра, все, между всеми парами вершин слева у нас ребра поубивались.
Но раз они поубивались, то остаются только те ребра, которые заканчиваются не в s.
То есть тогда получается, что остаются только ребра те, которые начинаются все еще в s, но заканчиваются они уже все-таки в t.
Но это прям, но это прям определение чистого потока через разрез.
Все.
Ну то есть там, конкретно там в тексте написано, что в этом месте, что это равно просто сумма, то есть такая сумма по доле s.
Вот.
Но там плюс тоже самое, но...
Ну вот, но теперь в долю t.
И оказывается, что это равно вот этому просто потому, что вот это вот, это, собственно, оно само себя убивает.
Вот.
Так что вот такая несложная лемма, но из нее есть не менее простое, но очень важное свойство.
Что для любой, то есть свойство, что для любого s и t, то есть на самом деле лему можно было сформулировать так, что теперь для любого этого разреза st, верно, что f от st, то есть модуль ft, который равен этому, не превосходит c от st.
Но это не следствие, а просто.
Ну потому что f от st, c от st, они определяются одинаково, то есть сумма по одним и тем же ребрам, только тут суммируются f-ки, тут суммируются c-шки.
Так как f-ки не превосходят c-шек по члену, то и сумма не превосходит.
Вот.
То есть пока, видите, просто как будто на уровне какой-то польцевой магии получается.
Да даже и магии никакой.
Внимание разреза мы, получается, определяем.
Ну да.
Ну да, то есть да.
Ну не совсем.
Почему?
Пока мы просто говорим, ну изначально мы говорим, что заметим, что модуль f не превосходит пропускной способности любого разреза.
Да?
Вот.
Но тогда разрезов у нас всего, конечное количество, 2 в степени v-, там модуль v-2, если быть точнее.
Да?
Вот.
Тогда получается из всех разрезов можно выбрать минимальный, естественно, по пропускной способности и сказать, что модуль f не превосходит на самом деле пропускной способности,
минимальный из этих пропускных способностей.
Вот.
Понимаете, да?
Чистый поток у всех одинаковый, да?
Чистый поток?
Ну да.
Чистый поток по всем.
Ну то есть так, если любой поток f индуцирует 2 в степени модуль v-2 чистых потоков вот этих.
Но они все одинаковые и равны собственно великим.
Но заметим, что величины потока, вот когда мы их определяли через исток и через сток, это на самом деле тоже просто двух примеров.
То есть это примеры просто двух чистых потоков через два разреза.
Просто в первом разрезе у вас там доля s состоит только из истока, во втором доля t состоит только из стока.
Вот.
То есть по большому счету получилось обобщение такое.
Что такое qed?
Quod, random, random.
Что и требовалось доказать по-латински.
Ну вот.
Ну это просто стадакное сокращение.
Вот.
Просто ради кет.
Нет, qed.
Вот.
И так получается важное свойство, что modul f, то есть пока простое свойство, что величина потока не происходит пропускной способностью минимального разреза.
То есть такая верхняя оценка.
Точна ли она?
И вот теперь-то мы можем в полной мере сформулировать теорему Форда Фолкерсона.
То есть она говорит так.
Мы ее будем формулировать так.
Пусть у нас есть сеть, а в ней течет поток.
Тогда оказывается три утверждения эквивалентные.
Ну то есть либо одновременно все три верны, либо все три не верны.
Утверждение первое f, максимальный поток.
Ой, а можете на прошлом ставить?
О господи.
А что там так?
Что там?
Вот.
То есть первое f, максимальный поток.
Второе утверждение говорит, что в остаточной сети нет увеличивающего пути.
Ну понятно, что такое увеличивающий путь.
То есть это путь по ненасыщенным ребрам в остаточной сети.
То есть такого пути в остаточной сети нет.
И третье утверждение, что существует разрез, для которого, то есть профестория способности которого равна величине этого потока.
То есть на самом деле в полной версии теория звучит именно так.
Вот, понятно?
Вот, да нет, наверное?
Вот.
Ну а теперь вот.
И остается только доказать эквивалент.
Ну как доказывать?
Ну из первого следует второе очевидно.
Точнее наоборот, очевидно, что если увеличивающий путь есть, то поток не максимальный.
Вот.
То есть мы это просто практически на пальцах видели.
Так.
Ну и замечаем, что если величина...
Ну с другой стороны, и стройки следует автоматически единица, потому что если мы уже достигли профестория способности какого-то разреза, то больше уже не будет.
То есть в этом мы тоже только что уже убедились.
Так что получается для окончания доказательства нам нужно доказать, что если увеличивающего пути нет, то тогда оказывается, что можно найти вот такой разрез.
То есть вот что нам осталось сделать.
Ну вот это достаточно легко сделать.
Более того, попутно можно еще...
То есть более того, это делается просто тем, что вы просто алгоритмически находите этот разрез.
Вот.
Я бы скорее доказывал, что из того, что наш поток меньше, чем минимальный, существует увеличивающий путь.
Ну можно так, но кажется мне...
По одной вершинке, по левую долю, по идее кажется должно быть.
Можно пытаться добавлять, а можно сказать попроще.
Ну вот, просто алгоритмически удобно просто сказать так.
То есть доказательство такое.
Пусть у нас есть остаточные сети в неувеличивых причине, то есть и в ней по ненулевым ребрам дойти до t нельзя.
А давайте запустим DFS и найдем, до каких вершин дойти можно.
Давайте и скажем, пусть доля S это вот докуда дойти можно.
Вот любым просто DFS запустили и возрадовались.
Тогда что получается?
Да, t в нем не лежит.
Ну понятно, да, t большое это дополнение S.
Ну значит, понятно, т, то есть сток у нас естественно в доле t лежит.
Но с другой стороны мы замечаем, что из S в t ведут только насыщенные ребра.
Насыщенные в исходной сети или то же самое нулевые в остаточной сети.
Но тогда по определению этого множества получается, что для любой пары вершин, первая из которых возрадовалась в t, оказывается, что f равно c.
То есть следовательно, во-первых, S и t это корректный разрез.
И при этом оказывается, что чистый поток через этот разрез равен пропускной способности этого разреза.
Все, разрез найден, ура.
Мы изначально утверждали, что там нет лечеб.
Что-что?
Мы пришли к противоречию, да?
Нет, мы не пришли, нет.
Мы здесь не шли никакому противоречию, потому что мы не делали ничего противного.
Мы доказывали, что из второго пункта следует третий.
То есть мы про максимальность вообще забыли.
То есть мы говорим, пусть нет увеличивающих путей.
Тогда мы взялись найти разрез, пропускная способность которого равна величине нашего потока.
И мы ее нашли.
Очень простой.
Запустим DFS из истока по всем ненасыщенным ребрам.
И сказали, что пусть это будет множество S.
А t это все остальное.
Это разрез.
Почему?
Потому что так как до истока дойти нельзя, это было предположение 2, то получается, что это разрез.
Но с другой стороны, оказывается, что для всех ребер, ведущих из S в t,
для всех таких паровершин, оказывается, что поток между ними равен пропускной способности в точности.
Потому что они насыщенные?
Да, потому что они насыщенные.
Если они DFS по ненасыщенным шлейфам?
Именно.
А старшееся значит, что они насыщенные?
Получается, да.
Если ребро ведет из Ft, значит оно насыщенное.
Тогда получается, что по всем таким ребрам F равно C.
Но значит, тогда пропускная способность этого разреза, как сумма по всем таким ребрам,
в точности равна сумме F по всем таким ребрам.
А так как сумма всех таких ребер это модуль F, то получается радость.
Как вы разделили S и t?
Нет, еще раз.
Так и разделили.
Мы сказали, что S это до чего DFS дошло.
T – все остальное.
Все.
Потому что он не дойдет до…
Он не дойдет до T.
Да.
Потому что они насыщенные.
Нет, нет, нет, нет.
Да, он не дойдет до DFS, не дойдет до T.
Потому что пункт 2 как раз то же самое говорит.
Что такое увеличивающий путь?
Это путь по ненасыщенным ребрам от S до T.
Все.
Так что оказалось, что пункт 2-3 тоже не сильно сложный, оказывается.
Вот.
И это, между прочим, очень сильно помогает.
Вот.
Потому что…
То есть, вот этот пункт помнить очень важно.
Потому что на самом деле, то есть если брать какое-нибудь там спортивное программирование,
то там иногда встречаются задачи на потоке.
Более того, иногда даже на финалах попадаются.
Вот.
Ну вот.
И на самом деле эти задачи делятся…
Да, можно разделить на…
Ну то есть во всех этих задачах, да, задача сводится к тому, что надо построить сеть.
Но теперь вопрос, а что в ней делать дальше?
Так вот.
Ну пока отбросим Минкос, но если задача на обычный поток, то у вас два…
То на самом деле у задач бывает два варианта.
Первая задача, то есть вам нужно найти, собственно, максимальный поток,
и этот поток как-то проинтерпретировать.
И второй тип задачи – это, где вам на самом деле нужно найти не максимальный поток,
а только минимальный разрез.
Именно это им проинтерпретировать.
Вот.
Нет, ну я сейчас просто приведу пример обоих подходов.
Ну, самый простой подход, то есть по первому примеру,
самый простой подход – это, конечно, там поиск просочетания в двудольном графе.
Нет, ну давай сейчас вот уже.
Да.
Как это?
Ну тут по-разному может быть, да.
Потому что там… Ну сейчас я это просто покажу.
Вот.
То есть тут надо это оговорить.
То есть, видимо, про просочетания мы в какой-то момент там,
видимо, должны будем поговорить подробнее.
Подробнее.
Ну почему-то надо подумать.
Можно, в принципе, сегодня.
Так.
А можно и не сегодня.
Так.
В общем, тут по-разному можно мыслить.
Значит, смотрите.
Но это тоже как бы важный момент.
Ну как бы в чем у нас заключается поиск просочетания, да?
Ну вообще у нас задача поиска просочетания звучит так.
Дан неориентированный граф, найдите, пожалуйста, максимальное по количеству множество ребер,
которые такие что, никакие два из них не имеют общего конца.
Ну формальная произведение звучит так.
И более того, такое определение не требует, чтобы граф был вообще двудольным, правда?
Понятно.
То есть более того, не знаю, мы тоже вряд ли до этого доживем,
но теоретически есть там алгоритм ЗВЕ, который ищет просочетания даже в не двудольном графе.
Там, кодовое слово сочетание сжатия соцветий.
Вот.
Но если мы говорим о двудольном графе,
то есть допустим, вот у нас есть, как-то вот так мы обычно будем изображать две доли.
То есть что такое двудольный граф?
Когда у нас граф можно разбить на два множества, так шеребры соединяют только вершины разных долей.
И вот у нас задача найти максимальное просочетание в таком графе.
Как же это сделать?
Ну, в левую долю.
Ну да.
В обстрепении m.
Да.
Чего два?
А, ну можно, кроме того, что это можно сделать перебором, естественно, полным.
Да.
Но на самом деле делаем так.
Построим из этого графа сеть.
То есть все ребра, во-первых, ориентируем.
И объявим, что они пропускной способности 1.
Во-вторых, введем исток исток.
Исток будет такой слева.
И из него будут вести ребра всех вершин.
Во всей вершине левой, внимание, левой доли.
Понимаете, да?
Вот.
И есть доля t.
Вот.
И получается примерно следующее.
Вот.
И тут тоже единицы.
Тогда я утверждаю, что задача поиска просочетания свойствует задачу поиска максимального потока в этом графе.
Почему так?
Да просто потому, что а как в этом графе вообще может выглядеть поток?
Ну, если не вспоминать там какую-то остаточную сеть, да?
Как оно может выглядеть?
Да очень просто.
Да единственным образом.
Просто, то есть как бы все, то есть поток это набор вот таких вот путей, которые по вершинам, кроме SCT, не пересекаются и вообще состоят из трех ребер.
Нет, по вершинам не пересекаются.
Ну, по SCT они, смотрите, по SCT они могут пересекаться.
Вот.
Но при этом заметим, что, ну скажем так, если мы рассматриваем, ну во-первых, тут надо оговориться, что, конечно, максимальный поток, как мы говорили, не обязан быть целочисленным.
Но с другой стороны, из сериала Муфорда Фолкерсона автоматически следует, что в целочисленной сети на самом деле существует максимальный целочисленный поток.
Ну, просто потому что, давай.
Разрез.
Просто потому что, ну метод Фордов, нет, ну да, нет, из самого разреза будет следовать только, что его величина целая.
Но не будет следовать, что он по всем ребрам течет целое число.
Вот.
Ну а как бы фишка будет в том, что на самом деле просто в целочисленной сети методом Форда Фолкерсона можно просто находить пути в остаточной сети и пускать по нему целочисленный поток.
И более того, рано или поздно этот принцип реально закончится.
Но более того, кстати, в этом графе, если вы будете таким образом искать поток, то есть просто честным ДФСом в остаточной сети искать потоки, то это сработает за время ООВЕ.
Да, видите, я тут не случайно пишу профессиональную способность 1 специально для того, чтобы разные единицы потока не могли пройти по одному и тому же вот этому ребру.
Понимаете, да?
Ну скорее для того, чтобы мы не могли из одной вершины.
Ну да, то есть это приведет к тому, что тогда получается, что если мы возьмем синие ребра, которые попали в поток, то окажется, что они образуют парасочетание.
И более того, по любому парасочетанию поток такого вида можно легко построить, и более того, величина потока будет равна размеру парасочетания.
Поэтому получается, что найти максимальное парасочетание в двудольном графе – это то же самое, что найти поток вот в такой сети.
Понимаете, да?
И более того, это будет работать за ООВЕ.
Вот, ну можно так сразу выйти, да, кто-то скажет, что да, кто-то тут пишет кун и говорит, что кун.
Что-то кун, кун, давайте куном все искать.
Но кун работает ровно за такую синтетику.
Да, но тут мы что-то понимаем, что формально мы не знаем, что такое алгоритм куна, да?
Я не знаю, возможно, а кстати это и дело.
Правда ли, что кун будет просто то же самое?
Но я утверждаю, что кун – это на самом деле оптимизированная версия вот этого самого алгоритма.
Причем более того, знаете, тут что интересно, сейчас у меня будет несколько математических и иллюстраций на эту тему, да, что обычно вот понятно, что многие из вас, конечно, изучали алгоритм куна до того, как познакомились с понятием поток, да?
Ну есть такое подозрение, да?
И тогда, но тогда у вас там могли быть какие-то проблемы с тем, чтобы доказать, что алгоритм куна вообще работает, да?
А зачем это так? Мы не доказывали.
Да ладно, вам просто сказали, что вот такие, так вот ищутся удлиняющие цепи, вот почему-то работает?
Нет, у них проблемы были, кто доказывает.
Нет, у нас там, ну как сказать, я не знаю.
Ну тут кто как.
Как бы да.
В олипиадной школе обычно принято доказывать.
Но правда там доказательства, но как обычно там может выглядеть какое-нибудь типичное доказательство того, что этот алгоритм работает, да?
То есть там говорили, что, но там все сводилось к тому, что там рассмотрим ваши текущие просочетания и рассмотрим максимальные просочетания, да?
Тогда у вас получится какой-то граф, у которого степень вершины не превосходит двух.
Логично, да?
Но если вы составили граф из двух просочетаний, да?
И тогда как в графе со степенями вершин не более чем два выглядят компоненты связности?
Это как бы либо такие цепочки, либо такие циклики, да?
А там же мы к сору берем, просто читаем.
Ну особенно если вы к сору возьмете, да?
Ну к сору в смысле, что выкинем ребра, которые попали и туда и туда.
Ну там дальше техник, которая нота.
Зачем?
Зачем у нас будет цикл где-то два?
Ну по-разному.
Ну так, чисто для удобства, не важно.
Тогда у вас оказывается, что есть какие-то компоненты связности,
и оказывается, что в циклах ребер обоих просочетаний одинаковое количество, очевидно.
А вот в цепочках как повезет?
То есть в цепочках может быть одинаковое количество ребер, может на одно больше у первого просочетания, может быть на одно больше у второго.
Но так как максимальная типа больше вашего, то должна быть цепочка, у которой, значит, на одно ребро из максимального просочетания больше.
Но оно, собственно, удлиняющей цепью оказывается.
Это какое-то очерное доказательство, по-моему, нам сложнее рассказывать.
Да?
Нет, у тебя просто мозг начнет уже работать с тех пор.
Может быть, может быть.
Ой, ну нет, может, на самом деле просто, да, уже просто что-то удалось понять.
У меня такое было, когда я как-то был так, вот на втором курсе, когда я изучал доказательства Терема Каши, там вот это вот, а существование единственности Дифура,
на одной из ближайших лекций, видимо, будет доказательство.
Доказательства?
Нет, ну на лекциях доказательства будет.
Ну, жалко, жалко.
А жалко, это у нас просто все было.
И там как бы было какое-то мощное доказательство, аж на 3-4 страницы учебника, какие-то действия.
Я его даже выучил, я его вроде даже воспроизводил.
Но потом, но потом через где-то прошел где-то год-полтора, я прочитал просто то же самое доказательство в учебнике по Функану.
Оказалось, что с точки зрения, то есть если подняться выше просто в мыслях терминам метрических пространств и сжимающих отображений,
то оказалось, что там просто доказательство на полстранический, оно там просто полуочевидное оказывается.
А можете прислать?
Ну, прислать не смогу, но просто у вас там будет просто...
Нет, для этого мне нужно вспомнить учебник по Функану, но скорее всего вы просто на третьем курсе с этим столкнетесь.
Нет, ну там просто суть в том, что я могу просто сказать, что там как бы теорема искала, то есть как бы диффурт как выглядит, как f, то есть как он там выглядит.
f штрих равно там какая-то функция g от x f.
Ну, где x это переменная, а f это типа функция, там какая-то такая.
Вот, но там теорема звучала так что эквивалентно тому, что там f равно там, называется там, интеграл g от x f.
Там по x равно, допустим, ну не важно, просто интеграл, короче.
Вот, но если прям уточнить от x 0 до...
Но там точнее так.
Да, f от x 1, да.
Да, мы неожиданно перешли к диффурам, да, я не знаю.
Да, потому что я дапши-лектора, как всегда, понесло куда-то не туда, да.
Ну, что делать?
Это вас недавно удивляет, вроде как не первый семестр работает.
Ну вот, то есть там можно по идее вот так вот сказать, просто это какая-то такая функция.
То есть получается, что на самом деле можно сказать, что давайте, то есть можно сказать, что давайте, что пусть у нас f от f присвоить вот этот вот интеграл, да.
То есть это как бы типа функционал такой, да, то есть такое отображение.
И там просто доказывается, что при каких-то там условиях, там этих липшиц, там по-моему, или какие-то еще там умные слова, там в какой-то окрестности, оказывается, что это преобразование в некотором смысле сжимаемое.
То есть условно говоря, там можно потому что между функциями ввести там какое-то расстояние, выясняется, что он меньше единицы, и тогда из этого будет следовать, что там существует неподвижная точка.
Это и есть решение диффура.
Там отдельная песня, как доказывать единственность, но это там уже другая история.
Это как мы в лямбдах функцию доказывали, типа то, что существует, ну вот этот Y комбинатор, то, что рекурсивно можно функцию тут давать.
Да, вы так доказывали, да?
Ну мы доказывали, типа рекурсивно можно давать функцию, потому что есть Y комбинатор, который находится в неподвижную точку.
А дальше неподвижной точкой как раз будет рекурсивно заданная даша.
А, ну наверное, да.
Ну да, ну а что делать, идеи могут и в других местах возникнуть.
Ну да, ну наверное, ладно, так.
Это мы все обсудим.
Так, окей, ладно, все, по диффуру и поговорили.
Ну, хорошая вещь, наверное, это я не знаю.
Да, но это уже другое.
Тем более, что мусимантика есть преимущество, то есть я не могу ее анонсировать, потому что она у вас уже была.
Вы уже по ней экзамен сдали, все.
Ну не все.
Мы все знаем мусимантику.
Да, наверное, да.
Так вот, так, тихо, тихо.
Так, что там опять за шум пошел?
Значит, смотрите, вернемся к куну.
Ну с куном, да, то есть там доказательства, то есть это была иллюстрация, да, к чему мы вышли на диффуре, это иллюстрация того, что там какие-то доказательства со временем могут казаться более простыми.
Потому что могут, ну вот.
Но на самом деле вот интересно, что на самом деле надо просто, то есть чтобы доказать алгоритм куна, то есть правильнее просто этот алгоритм куна просто из этого вывести.
Потому что по большому счету давайте думать, как выглядит, ну вот.
Потому что в принципе можно за ОАТВ просто запустить стандартный метод фотофокерсона, то есть искать вот эти вот пути от СТ ДФС.
Но теперь давайте внимательно подумаем, а что такое вообще поиск вот этой, как тут выглядит вообще остаточная сеть, короче?
Как она тут выглядит?
Очень просто.
То есть вот допустим у нас, вот мы нашли случайно вот такого рода просочетания, да.
Вот такое, например, вот такое.
Ну вот и давайте еще какую-нибудь рыбку возьмем.
Вот такое давайте.
Тогда остаточная сеть выглядит вот таким образом.
То есть ребра, то есть у нас как бы ребра, то есть ребра из просочетания у нас как бы теперь смотрят справа налево, все остальные слева направо, правда?
А теперь вопрос, как нам теперь дойти от СДТ?
Но чтобы дойти до СДТ надо выйти из С, то есть пройти по ребру, которая как бы с просочетанием не связана, то есть вот по какому-то вот такому ребру, да.
Дальше пройти по какому-то ребру, не из просочетания вправо,
вернуться по ребру из просочетания налево, то есть опять пройти вправо по ребру, не из просочетания,
пройти по ребру из просочетания направо, несколько раз так туда, сюда сделать
и в конце концов дойти до вершины, которая не связана с просочетанием, или что то же самое,
то есть из нее есть вот это красное ребро прямо в сток.
прямо в сток. И вот удлиняющий путь, как мы бы его называли в терминах остаточной сети. А в терминах
просочетания это называется удлиняющая цепь. Что такое удлиняющая цепь? Это как раз путь вот такого
вида, который начинается в вершине левой доли, не покрытой просочетанием. Идет по ребрам так,
что ребра не из просочетания, а чередуются с ребрами просочетания. Заметим, что мы придумали
алгоритм Куна. Ну вот, и заканчиваем. Почти не совсем. Не совсем. То есть по факту теперь... Нет,
это еще не совсем алгоритм Куна. Потому что пока алгоритм... То есть это нам предлагает делать так.
То есть, во-первых, давайте удалим СТ и будем говорить, что мы будем искать не путь из СПТ,
а как бы мы будем пытаться запускать ДФС из всех вершин левой доли, не покрытыми просочетанием.
И при этом будем считать, что все ребра не из просочетания ориентированы вправо,
ребра из просочетания ориентированы влево. И наша задача найти вершину правой доли,
не покрытой просочетанием этим ДФС. Вот. Это фактически... То есть мы алгоритм
пока идейно не поменяли, но поменяли чуть-чуть его реализация. То есть следующий шаг, это как
нам понимать вообще... То есть следующий шаг будет там говорить, как нам понимать для вершин левой
и правой доли, покрыта она просочетанием или нет. Но оказывается такая удобная идея, что удобно... То
есть вообще, как нам удобно разворачивать ребра. Потому что по дефолту это будет означать, что,
хотя мы хотим развернуть ребро, мы его должны в явном виде выпилить из списка смежности, а вместо
него там отсюда в список смежности добавить и обратное. Но на самом деле следующая оптимизация,
что как минимум для вершин правой доли, этого делать не нужно. А что нужно делать? Просто надо
для вершины правой доли, то есть как бы если у нас вот эта вершина, вот эта доля L, а доля R,
то тогда нам нужно ввести для... То есть ввести вот эти вершины от одного до модуляр. То есть
где R – это напарник в левой доле. То есть как бы с кем я связан в просочетании в левой доле.
То есть это как бы... То есть как бы вот либо этот напарник, то есть либо он может быть еще
минус один, если такого напарника нет. И тогда DFS можно немножко сократить. То есть DFS тогда
можно сократить, когда оно говорит, что мы пришли вот в эту вершину и говорим так, что если в этой
вершины минус один, вот где-то здесь, то мы победили, мы нашли удлиняющую цепь. А если не минус один,
то единственное, куда дальше может пойти DFS – это по вот этому напарнику, то есть в ПР. То есть
мы DFS сразу от ПРшки запускаем. То есть отсюда в Кунии возникает вот эта вот замечательная штука
и в ПР от В равно минус один или DFS от ПР от В. Сейчас. То есть, ну короче говоря, еще раз,
мы говорим, что мы хотим найти путь от цепи из С в Т. Ну да. Мы говорим, что он как-то идет туда,
потом путешествует между ними, между ними и идет, соответственно, потом в Т. А дальше, чтобы
путешествовать, да, чтобы идти направо, это должно быть еще не взятая ребро, да? Не обязательно. Не,
как угодно. На самом деле заметим, что специально разворачивать ребро не надо, потому что DFS,
ну давайте вспомним. Да, я тут, конечно, может немножко рассчитывал, что вы все помните,
как бы как пишется Кун. Ну вот. Ну я, значит, сейчас. Ну, смотрите, DFS, из него стандартная
реализация обычно звучит так. Use a tattoo равно 1. Значит, for сейчас. Ну, давай ты сейчас попытайся
еще чуть-чуть понять 30 секунд, а я тут код все-таки напишу, чтобы мы тут предметно
разговаривали. For. Там, значит, для всех ребер там УВ. Если оказывается, что не. Если оказывается,
что. А нет, неправильно. Вот тут оказывается, да. В стандартной реализации тут еще удобнее
писать так, что если не. То есть если оказалось, что use a tattoo, то мы просто сразу выбрасываемся с
криком false. И только после этого пишем там use a tattoo равно 1. Значит, и тут for от УВ. Значит,
Е. Значит, оказывается, что если пр от В меньше нуля или DFS от пр от В. Это просто очень
удобно. Смотрите, то есть могло так случиться, что вы прошли, что на самом деле вершина УВ уже
в пресочетании находится. И более того, вы по этому ребру в пресочетании и прошли. То тогда этот
DFS просто вернет вас в себя же и вы тут же выброситесь. Поэтому тут как бы лишних символов писать не надо.
То есть поэтому если DFS, то тогда оказывается, что желательно это пресочетание переписать. Но
как бы если вы тут вот так шли-шли-шли, не надо просто из всех этих вершин пр перебросить на туда,
куда вы прошли. Поэтому дальше тут пишется, что пр от В равно У теперь и return true. То есть
стандартный DFS в куне. А, ну и в конце, конечно, return false. То есть если вы там раньше не
выбросились, значит нам не повезло. То есть вот стандартный DFS в куне выглядит ровно таким
образом. То есть на самом деле это действительно очень красиво выглядит. То есть единственное,
то есть что можно оказывается удлиняющие цепи искать так, если вы гарантируете,
что вы там в мейне где-то или там в основном алгоритме DFS запускаете только из вершин,
которые пресочетаниями не покрыты. Но это еще не алгоритм куна. Потому что в реальности,
да, потому что на самом деле, ну вот, потому что как бы по дефолту мы пока пришли к следующему
алгоритму. Так, как у нас там пресочетания будет? А, find matching. Потому что найти пресочетания
обычно звучит так. То есть как-то там. Ладно, давайте пусть он возвращает хотя бы размер этого
пресочетания. То есть пока этот алгоритм может быть написан так. ans равно 0. Так while true. Значит
мы говорим, значит bool там, я не знаю, из ok равно false. Значит перебираем все вершины в левой доле,
там for вот так вот у и говорим, что если не у in matching, то есть если пока вершина у не в
matching, то значит мы можем написать так, что значит если оказалось, что то нет оговорка,
то значит придется запускать dfs. То есть пишем, значит там условно говоря user.assign там на модуль
l там 0. То есть если dfs atu, то что мы тут делаем? Plus plus ans там соответственно и там из ok
равно true. И в принципе, ну тут как угодно, можно брякнуться, можно не брякнуться, неважно.
Ну разумеется. Вот, ну и тут в конце return ans. То есть видите, то есть на самом деле это не
совсем кунг. То есть в таком виде, кстати, алгоритм еще и может наверное, но он да,
он формально может не за we работать даже. Где брек? Где брек? Ни одного брека нет.
Не, если я тут брек напишу, он будет брек на for. Ну ладно, правильно. Ну можно как угодно,
можно там, можно так написать bool из ok равно true и дальше написать while из ok,
значит пишем из ok равно false и бла-бла-бла. Вот теперь хорошо будет. Вот, ну как, значит как
тут вернуть we? Но на самом деле нет, вернуть we на самом деле несложно. Потому что на самом
деле просто зачищать юзет на самом деле надо не здесь, а вот здесь. Почему это? Нет, не совсем,
смотрите. Нет, в чем проблема? То есть заметим, что если мы юзет запустили только так, то заметим,
что мы на самом деле, то есть эти DFS на самом деле по каждой вершине проходят не более одного раза,
и получается, что суммарно они на каждой итерации работают за e. Не, юзды-то можно вообще не
достигнуть, потому что есть же метода. Нет, ну почему? Нет, на самом деле я правильно говорю так,
как только вы нашли, то есть пока вы не, если вы запустили DFS и не нашли удлиняющую цепь,
то вы можете запуститься от другой вершины, не стирая старые юзды, потому что по старым вершинам
ходить бессмысленно. Но как только вы удлиняющую цепь нашли, тогда юзды придется зачистить,
потому что граф изменился, потому что граф изменился. А, ну в том плане да, что нет,
то это не да. Ну то есть есть, конечно, момент, что юзды можно там сделать технологию, которая
зачищает юзды за от единицы, но на самом деле это бы сильно не помогло, потому что,
если вы каждый раз здесь зачищаете юзды, то как бы сам DFS, каждый DFS будет отдельно работать за
от e, а не все, а так мы можем сказать, что на каждой итерации вайла все DFS будут работать за от e
суммарно. Тут в этом дело. Ну почему? При такой реализации этого не будет происходить,
потому что если вершина однажды помечена DFS, то второй раз он просто войдет в вершину и скажет,
ой, она помечена и до свидания сразу. А потом мы ее обнулим. Да, но мы ее обнулим на следующей
итерации вайла. А итераторе вайла у нас V раз, да? Да, и таким образом. В квадрат E. Нет,
никаких V квадрат E. Почему? Смотрите, у нас не более чем, ну то есть у нас итерация не более
чем E на размер просочетания. Кстати, вот в реальности-то. Ну потому что на каждой итерации,
кроме может быть последней, хотя бы одна удлиняющая цепь найдена будет. Вот, одна найдена будет.
Но внутри одного и внутри одного вайла суммарно все эти DFS работают за V плюс E. Суммарно,
не каждый DFS работает за V плюс E, а все вместе они внутри одного фора работают за V плюс E.
Она говорит, проходимся по всем вершинам левой доли. И если вершина не в просочетании,
то мы пытаемся из нее найти удлиняющую цепь, DFS запуская. Если получилось, то значит,
мы говорим, что размер просочетания увеличился на один. Нет, юзды мы здесь не обнуляем,
потому что, то есть мы могли бы просто брякнуться на самом деле. Но в принципе,
можно еще оставшиеся DFS запускать, чтобы на той же итерации еще просочетания увеличить.
Если у нас граф типа из двух вершин ведет ребра в одну. И что? Мы сначала возьмем пару. Ну,
можете нарисовать. Ну и что? Мы сначала возьмем первое ребро, потом возьмем второе,
потом пытаемся взять второе, но ничего в итоге не увеличим. Не увеличим, так и должно быть.
Да, мы придем сюда. Сделаем лишний итерации. Кажется, это должно влиять на время выполнения.
Да нет, а симпатически это ни на что не влияет. Если два, то окей, но если у нас такая длинная цепочка.
Нет, смысл длинная. Я имею ввиду, вот у нас вот так идет длинный путь туда-сюда, а в конце у
нас куча ребер входит в последнюю вершину. Сейчас, ну я не знаю. Вот, а в самую последнюю
вершину входит просто куча ребер. Вот в эту? Да. И что? Да, только, ну смотри, ну максимум,
чтобы, не будем. Потому что, смотри, первая итерация ДФСа, допустим, попытается тут прогуляться по
всем этим вершинам, попытается что-то найти и ничего не найдет, но она все эти вершины пометит,
потому что следующий трансвыгрывает так, говорит, я должен пойти сюда, прэшка отправляет меня сюда,
а эта вершина уже с юзидом, поэтому мы просто за 1 из нее выбросимся, и больше она никуда не
пойдет, поэтому до свидания сразу. Ну то есть нет, это такой лайфхак, что у нас такой отложенный юзид,
то есть вместо того, чтобы пометить сразу эту вершину юзидом, как в обычном ДФСе, мы говорим,
что да, то есть у нее единственный напарник, но этот напарник пометен юзидом. Так что нет,
никаких проблем здесь нет. То есть вот есть алгоритм, он все еще работает за WE, даже работает
не за WE, а за размер просочетания плюс один на E на самом деле он работает, но это не совсем
кун, потому что есть подозрение, что вас учили куну, наверное, в более простой версии этого кода,
потому что обычно стандартный кун все-таки пишется по-другому. Он пишется так, то есть
перебираем тупо один раз все вершины левой доли и говорим, значит, зачищаем юзид.
Нет, как только граф изменился, зачищать надо. Пока он не поменялся, зачищать не надо. Вот,
но сейчас мы и поговорим на эту тему. То есть дефолтная версия, поэтому зачищаем, что там,
если там повезло DFS от U, то значит плюс плюс ans. Вот и все. То есть обычно куну пишут все-таки вот так.
Вот, но правда этот алгоритм в честную работает за WE, а не за размер просочетания на E. Но на самом
деле его легко сделать, то есть эту версию легко сделать и за размер просочетания на E следующим
образом. Не, не совсем. Не-не-не-не-не. Нам главное, чтобы... Да, юзид assign, значит, модуль L0, то есть
зачищаем здесь, здесь не зачищаем, а вот зачищаем, когда DFS что-то нашел. То есть принцип такой, что если
DFS ничего не нашел, то имеет смысл сохранить пометки вершин, по которым он прошел. Почему? Да,
правда, но да просто потому, что пока граф не поменяется из этих вершин, ходить куда-то бессмысленно.
Вот. Соответственно, паранот. То есть это и цикл. Если мы ничего не нашли, то соответственно и не
судьба. Вот. Так что вот такая вот получается красота. Вот. Значит, паранот. Но, к сожалению,
как бы у этого алгоритма есть пока большое преимущество по сравнению с Куном. Преимущество
заключает в том, что этот алгоритм... Да, этот алгоритм доказатель... Теперь мы уже знаем,
что он доказательно правильный. А вот с этим, к сожалению, есть одна маленькая подлянка.
Принципиальная разница. Потому что, смотрите, здесь мы на каждой итерации из всех вершин
неисправосочетания запускаем DFS. А здесь мы просто из каждой вершины один раз запускаем DFS,
получилось-получилось, не получилось. До свидания. То есть мы как-то почему-то верим,
что мы если из какой-то вершины левой доли запустили поиск удлиняющей цепи, ее не нашли,
то мы почему-то свято верим, что больше не найдется никогда. Нет, может найти, но этой
эквивалентом там может найдется из какой-то новой вершины. Почему это? Нет. По индукции доказываем,
что каждый раз у нас максимальная просторность. А, ну можно и так. Мы просто верим, что да,
если на... То есть можем пытаться что-то... Или как-то еще пытаться, и факт остается фактом.
В общем, доказательств тут пока особо нет. В принципе, пока вы не вводите потока,
на самом деле получается одно из самых сложных, по-моему, едва ли не самое сложное место в
доказательствах, кстати. Потому что как-то доказывать на уровне удлиняющих цепей вот этих,
вот там на пальчиках. Нет, когда вы добавили, но с другой стороны, а кто... Но тогда вам просто
надо доказывать, что на к... Мы по индукции доказываем, что на к отритерации у нас максимальная
по рассчитанию на префикс есть к вершину. А, ну да, то есть тогда надо просто аккуратно
поговорить, что если вы добавили вершину со всеми ребрами по рассочетанию, увеличилась на один,
то обязательно... Ну окей, хорошо. Ну, можно доказывать и так, но мы докажем по-другому,
потому что как бы... У нас какая цель? У нас как бы... То есть, знаете, мы сейчас пытаемся
продемонстрировать, что вся эта теория про рассочетание, это просто простое следствие
теории Форда Фолкерсона, на самом деле.
Вот, нет, но на самом деле мы сейчас это докажем в более крутый способ. Раз уж мы пришли из теории
потоков, то я сейчас просто докажу одно маленькое утверждение из теории потоков,
с которого это напрямую следует. Такое более общее. Звучать оно будет следующим образом.
Давайте, временно забыли о просочетаниях. Значит, временно забыли о просочетаниях. И делаем мы вот что.
Значит, представим себе... Итак, мистическая лемма. На теорию не тянет, а утверждение тоже как-то
слабо. Значит, лемма. Пусть у нас g это сеть, в которой мы ищем поток методом Форда Фолкерсона.
Наверное, надо было следующий слайд включить. Это я называю методом Форда Фолкерсона. Изначально
обнуляем просто сеть. То есть, говорим, что у нас потока пока вообще нет. Пока в остаточной сети
есть путь из st, я подразумеваю путь по ненасыщенным рогам, естественно, то мы вдоль этого пути
пропускаем поток максимально возможной величины, который по этому пути проталкивается сейчас.
Понятно, да? То есть, внимание, это метод, это не алгоритм. Почему это не алгоритм? Потому что никак
не сказано, каким конкретным образом мы ищем этот путь. Если мы, скажем, ищем фс, то это внезапно
станет алгоритмом. Но если я скажу, что мы ищем жестко dfs, то да, это уже алгоритм. Или если я скажу,
ищем этот bfs, то это станет именным алгоритмом. То есть, это будет называться алгоритмом Эдмонса Карпа.
Вот. Если я скажу ОМД, это другой вопрос. Это я называю методом Форда Фолкерсона,
значит, у нас будет вот с вами такая терминология. Итак, ищем поток методом Форда Фолкерсона.
Пусть, значит, я сформулирую так. Пусть перед какой-то итерацией из некоторой вершины В
нельзя, ну я так, давайте неформально уже так сформулирую, нельзя дойти до t, ну в смысле в gf,
там gfqr, я так скажу, по ненасыщенным ребрам. Ну я пишу fqr, потому что типа вот у меня, значит,
я тут делаю сколько-то итераций, после каждой итерации у меня в сети g течет какой-то поток,
пока, естественно, не максимальный. Итак, пусть перед какой-то итерацией выяснилось,
что я из какой-то вершины В, оказывается, до t дойти не могу. Да, внимание, то есть,
заметим, сеть не обязательно единичная, то есть сеть может быть какая угодно. Тогда после этой
итерации, итерации, пути из этой вершины В в t по ненасыщенным ребрам, по ненасыщеным ребрам,
появиться не могло, заявляю я. То есть, на самом деле, видите, то есть, если у вас вот вы сделали
сколько-то итераций, обнаружили, что из вершины В, то вы уже не доберетесь. Тогда утверждается,
что вы больше никогда до нее не доберетесь, можете ее просто там в ней какой-нибудь там супервечный
юзит на нее повесить. То есть, если мы сейчас докажем такую лему, то из нее тогда уже
правильность алгоритма Куна следует сама собой. Понимаете, да? Ну, потому что если мы запустим
DFS из какой-то вершины, если из нее удлиняющая цель была найдена, то мы больше из нее DFS запускать
не будем, потому что эта вершина войдет в просочетание. Но если мы запустили из нее DFS и
удлиняющей цепи не нашли, то тогда, получается, больше никогда и не найдем, потому что, как мы
помним, по большому счету то, что мы делаем, это просто метод Форда Фолкерсона. Просто мы там это
чуть-чуть оптимизировали, но если бы мы делали вот в исходной вере вот это вот с этой вот этой
всей радостью с зелеными и красными ребрами, то тогда получается, что если из этой вершины путь до
Т не нашелся удлиняющая цепь, значит больше никогда не найдется, можно из нее DFS не запускать.
Понятно, да? То есть, получается, да. То есть, на самом деле свели задачу к более серьезной. То
есть, оказывается, это просто более серьезный факт. Но теперь внимание, вопрос. А почему же этот факт
вообще верен? Почему так? Ведь, казалось бы, в результате каждой итерации Форда Фолкерсона у нас
могут появляться новые ненасыщенные ребра. Логично, да? Потому что каждый раз, когда вы
пропускаете поток по какому-то ребру, то у обратного ему ребра появляется какая-то
ненулевая пропускная способность, остаточная, правда? Ну, если она и была ненулевой, то она останется
ненулевой, просто она станет больше. Но могло и появиться. Но, как бы, когда появляются новые
ребра, наверное, путь может и появиться. Но, оказывается, нет. Или вам это в ДЗ задачку дать.
Не, ладно, не буду. Значит, смотрите. То есть, доказательство здесь выглядит очень просто.
Смотрите как. Допустим, после этой итерации путь в Т неожиданно появился. Вот он, да? Тогда,
смотрите какая ситуация. Перед этой итерации этого пути не было. Что это означает? Значит,
какие-то ребра только что появились. А это означает, что перед этой итерации были какие-то
вот такие ребра, по которым вот этот путь проходил. Вот их тут несколько таких ребер. И получается,
имел место какой-то путь из С в Т, который как-то ходил-ходил-ходил-ходил-ходил,
прошел по этому ребру, ходил-ходил-ходил-ходил-ходил, прошел по этому ребру, ходил-ходил-ходил-ходил-ходил-ходил,
пришел в Т. Да, порядок ребер вообще может быть не таким, естественно. А теперь резко появился.
Ну, потому что что такое итерация? Мы нашли какой-то путь из С в Т и пропустили по нему поток.
Вы взяли все ребра, а почему они в обратном? Нет, смотри, потому что после этой итерации из С в Т
неожиданно появился путь. Значит, посмотри, перед итерации пути не было, после итерации путь
появился. Это означает, что каких-то ребер на этом пути не было. То есть, какие-то были насыщенные,
стали не насыщенные. Ну да. А как насыщенное ребро могло стать не насыщенным? То есть,
могло быть только по одному, что мы по обратному ребру протолкнули поток на предыдущей итерации.
То есть, на предыдущей итерации был вот такой путь, который проходил вот по таким ребрам. А теперь
давайте пойдем из вершины В по вот этому пути. То есть, теперь давайте думать. Все ребра этого пути
существовали перед итерацией. Доходим до первого ребра, до вот этой первой красненькой вершины.
Нет, хочется дойти не до первой. До первой. Потому что, смотрите, до сюда мы как бы дойти и так и так
можем. Но по этому отрезочку пути мы можем прогуляться как после итерации, так и перед
итерацией мы могли, потому что все эти ребра перед итерацией были. Вот. Но теперь заметим,
что перед итерацией мы могли из вершины В пойти по этой части пути, а из этой вершины
пройти по вот этому остатку красного пути в Т. Значит, получается, что мы просто в явном виде
построили путь из В в Т перед этой итерацией противоречия. Нет, красный это путь вот этой
итерации. Вот давайте, вот это какой-то итерации я буду выделять красненьким. Потому что тем я
почетру, что красный путь это путь, вдоль которого был протолкнут, проталкнут, пропущен поток в
результате этой итерации. Какой синий ребро? Нет, это В и Т это не ребро, это путь. То есть путь у нас
после итерации В и Т был путь. Тогда какие-то из этих ребр только появились только что, хотя бы
одно ребро-то появилось только что. Мы, допустим, нашли путь, в котором был протолкнут из вершины В и Т. Да, после итерации.
Но тогда какие-то из этих ребер, какие-то ребер были, работали и перед итерацией, какие-то работали,
появились только после. Вот, но тогда давайте идем по этому пути до первого ребра, которое появилось
после. Да, но выяснилось, что из этой вершины, так как она лежала на этом пути итерации,
значит получается перед итерацией мы могли из этой вершины по вот этому пути дойти до Т. А что если до этой вершины было удаленное ребро?
Не было, потому что тот алгоритм говорит, дойдем до первого такого ребра. Первого в смысле на пути от В и Т.
Первого какого? Ну, смотрите, вот от В и Т есть ребра. Первый, второй, третий, четвертый, пятый и так далее. Давайте дойдем до первого
ребра, который... То есть будем идти до первого ребра, которое перед итерацией не существовало.
Это ребра, которые у нас уже заложены в наше просочетание. Какое просочетание? Так, мы влеме забыли о просочетании.
Сейчас синие ребра это просто какие-то ребра к графику, верно? Нет, то скажи так, это какие-то ребра, которые образуют путь, который появился после итерации.
То есть этот путь синий, это путь после итерации, который как бы у нас появился? Да. То есть мы раньше не могли до этой итерации построить синий путь? Да. А после смогли? Да.
Или после он у нас появился? Нет, после, ну да, но это означает, что если до не могли, а после смогли, значит до его не было, а после он был.
Ну, в смысле? А после он резко появился.
Да. Раньше у нас не было возможности, а теперь у нас появилась возможность на не факт, что мы её реализовали.
Чёрт, ну это...
Философская рассуждение.
Нет, не совсем. У нас предположение было, что из вершины В перед какой-то итерацией, перед, нельзя было вообще найти из ВФТ, то есть вообще никакого пути по ненасыщенным ребрам не было.
И мы пытаемся доказать, что после этой итерации тоже такой возможности не появится.
Всё, схема, да. То есть дальше схема говорит, что после этой итерации, допустим, после какой-то такой путь появился.
Короче говоря, если ты был безнадёжный, то ты останешься безнадёжным.
Ну, можно так сказать, наверное.
Миша, позитивная мысль.
Не, ну а что? Не, ну какая-то позитивность в этом есть, потому что это как бы позволяет вам с хорошим настроением не тратить куда-то энергию.
Другой вопрос, что проблема, что это надо ещё сильно поверить, что вы в чём-то безнадёжны, а на самом деле чаще всего это не так.
Это будет обнадёжность в безнадёжности.
Да, ну я не знаю. Нет, просто где-то это может превратиться в выученную беспомощность на самом деле.
А это бывает иногда просто психологически, там просто симптом психологической проблемы иногда на самом деле.
Можно ещё раз, у нас в СССР не было, и он появился.
Так, у Кости был вопрос в другом, чего говоришь?
Нет, противоречие заключается в том, что мы доказали, что перед этой итерацией оказалось, что путь из ВФТ всё-таки существовал.
Да, не конкретно этот, но существовал.
А, очень просто.
Рассмотрим путь из ВФТ, который появился.
Тогда на этом пути какие-то ребра перед этой итерацией существовали, то есть были ненасыщенными, а какие-то были насыщенными, но разносытились в результате итерации.
Тогда идём по этому пути, по ненасыщенным ребрам, до первого ребра, которое разносытилось.
Но тогда как оно разносытилось?
Что такое итерация?
Итерация Форда Фолкерсона – это когда мы нашли из СФТ какой-то путь по ненасыщенным ребрам и пропустили по нему поток.
И оказывается, по этому ребру такой поток прошёл.
Но тогда что это означает?
Это означает, что из этой вершины перед этой итерацией был путь в Т, по ненасыщенным ребрам.
Это означает, что мы из В до этой вершины могли дойти перед итерацией и из этой вершины до Т тоже могли дойти.
Значит, могли дойти до Т.
Вот такая, на самом деле, красота.
Логичным образом можно, кстати, доказать, что если вы из устока до какой-то вершины В дойти не можете в процессе Форда Фолкерсона в какой-то момент,
то и дальше вы до него не дойдёте, можете не заморачиваться.
Вот, понятна логика, да?
То есть это, на самом деле, такая полезная лемма.
То есть тоже так её полезно помнить.
Но из неё автоматически следует кунчик.
Вот, понятно, да?
Вот.
Более того, такой...
Что?
В кончике мы идём...
В кончике мы...
Мы ищем путь только по префиксу или вообще по всем вершинам второй доли?
По всем вершинам.
Нет, мы запускаем ДФС из всех вершин второй доли каждый по одному раз.
По факту мы ищем на префиксе,
потому что ДФС может войти в вершину левой доли
только при группе сочетания или стартовав из неё.
Поэтому по факту ДФС из пятой вершины левой доли может пройти только по первым четырём.
Я имею в виду, что геопитетическая ситуация...
Сейчас.
Если мы...
Нет, по идее мы по всем должны искать,
потому что...
Нет, то есть в левой долю?
Нет, но вот, допустим, у нас был граф,
и с первой вершины во вторую идёт ребро.
Ну и что?
И всё.
Тогда на первой террации, если мы берём только первую вершину, из неё нет пути в Т,
тогда мы добавили ещё вторую вершину,
появился путь в Т через вот это ребро 1,2.
Как это?
Нет, при этом на префи...
То есть можно сказать так,
после 10 терраций куна вы найдёте максимальное просочетание,
если в левой доле оставить только первые 10 вершин.
А в правой все остаются?
В правой, естественно, все остаются, да.
Ну тогда, кстати, тогда не так очевидно,
почему работает по индукции доказательства.
А вот так.
А вот поэтому я тут какие-то сложные леммы доказываю.
Поэтому я и доказываю, что если...
Потому что основное, что нам надо в этом куне доказать,
то есть, в принципе, достаточно доказать следующее,
что если ты запустил ДФС из какой-то вершины левой доли
и удлиняющей цепи не нашёл,
то кун в этом месте гордо заявляет,
что больше она никогда и не найдётся.
И доказательства на самом деле сводятся
к вот этой лемме.
То есть нет, можно там
как бы на языке удлиняющих цепей
аккуратно доказать, что если в будущем удлиняющая
цепь найдётся, то она и тут была,
но соответственно.
Так, есть ли тут ещё по
вот этой весёлой части вопрос?
А мы говорим там, что синие ребра – это насыщенные ребра?
Не, наоборот, ненасыщенные.
Это ребра, которые оказались ненасыщенными
после итерации.
Да, вот тут, конечно, надо не запутаться, соответственно,
кто тут насыщенный, кто тут нет.
Вот.
А правда ли, что мы, вот мы нашли
какой-то путь из ВФТ в Куне
и насытили его?
Может, у нас остался ещё какой-то путь?
Наверное, такое не могло быть, да?
Сейчас, если мы из ВФТ,
чего ещё равно?
Нет, то мог быть какой-то другой путь, а какая нам разница?
Тогда не сработает эта лемма,
потому что мы после того,
как насытили путь из ВФТ,
у нас нет ситуации,
что вот это вот...
Нет, пароди, мы про Куна говорим, или вообще про лемму?
Но лемма окей.
Нет, в Куне,
если мы нашли удлиняющую цепь,
то эта вершина с этого момента
вошла в просочетание.
Этим это важно.
Но путь из неё мог остаться.
Да, но будущие ДФС, это будут через неё проходить
вполне себе, если надо.
Поэтому там никаких проблем нет.
Ну, то есть, да.
Если сейчас путь есть,
то в будущих итерациях
какие-то другие пути могут
существовать.
Скажем так, я просто не вижу,
почему отсюда напрямую свернут Кунь?
Ну, почему?
Потому что мы говорим так,
потому что Кунь говорит так,
что запускаем,
а мы не запускаем,
а мы не запускаем,
а мы не запускаем.
Так что, потому что Кунь говорит так,
что запускаем ДФС в вершины
каждой левой доли.
Если запустили не сработал,
значит, из неё никогда ничего не будет.
Если не сработал,
это значит, что не было пути, да?
Да, не было пути,
а значит, никогда и не будет.
А если сработал, то из неё
ДФС мы больше никогда запускать не будем,
потому что она в просочетании.
Мы же запускаем ДФС,
исходный ДФС запускаем,
только из вершин левой доли не из просочетания.
И должны дойти
до какой-то вершины правой доли
тоже не из просочетания.
Вот, поэтому
как бы да. То есть сработало ОК,
не сработало, значит, никогда не будет.
Так что вот получилось.
Так что вот так работает Кунь
за симпточку, даже не за ВЭДИ,
а за ОАТ.
Там, соответственно,
анс плюс один
на Е.
Вот.
Так что вот такой вот красота.
Но правда, чтобы сделать
не ВЭДИ, а вот размер просочетания
плюс один на Е, то как бы надо
правильно зачищать.
То есть ещё раз говорю, напоминаю,
что если запустили ДФС и не нашли удлиняющую цепь,
то зачищать юзит не нужно.
Потому что пока граф не поменялся,
у вас просто сохранятся пометки,
что туда ходить не надо,
потому что только шоу ходили и не надо.
Так, но это вот такой типичный пример
просочетания,
это задача, о которой вы
свели к задачу поиска потока,
и вам интересен именно поток.
Потому что в принципе есть такие
более сложные задачи.
Есть вот такая задача,
которая может быть не очевидной, хотя вряд ли.
Задача про кубики.
Не та задача про кубики,
где привидение какое-то,
любят играть во что-то,
зеркало поставили.
Эту мы тоже будем обсуждать,
но очевидно в другое время.
Господи, какие хэшы?
Это префикс функции.
Я знал весь контест стириусов,
которые нужно было использовать,
все эти Z функции.
Да понятно, что так можно делать.
Скажем так,
у меня было три периода в жизни
по поводу строчек.
Первый, я принципиально не любил хэши
и старался решать только честными методами.
В какой-то момент на каком-то
МИП-топане я наткнулся
на задачу, которая принципиально не
хэшами решалась.
Или там что, с жуткими уконенными
какими-то.
После этого я наоборот, я прям полюбил хэши
и стал просто их упихивать везде.
Но кончилось тем,
что там была какая-то задача, где дана
строчка на миллион, и там нужно было решать
хэшами бинпоиском за N лог N или префикс функции за N.
Хэши и бинпоиск затейлились.
После этого я перестал так
любить хэши.
Вот.
Чего?
Чего хэши и сувмасс?
Хэши через сувмасс.
Мы вспоминаем вот таковый
построитель сувмасса.
А?
Не, ну да, да, да.
Не, ну да.
Если у вас хэши сводится только к тому,
чтобы сравнить две строки, равны ли они,
то да.
Но после этого надо написать сувмасс,
на нем нужно написать спарсы, и в эти спарсы еще лазить.
А нет, надо написать сувмасс,
потом нужно по сувмассу написать
лцпшки,
на этих лцпшках написать спарстейбл.
А,
ну да.
Нет, на самом деле
ну можно.
Не, ну да, можно, но это
если уровень, это подразумевает, что вы реально
сувмасс за НЛОГН строите.
А если вы там построите другим алгоритмом
за ОАТН, ну такой, какой типичный
алгоритм построения сувмасса за ОАТН?
СОИС, конечно.
СОИС, конечно.
Да, боже упаси, господи. Нет, самый стандартный алгоритм
это строим украниным
суффиксное дерево и запускаем
ДФС. Там вы еще
лцпшки за бесплатно найдете.
Это размер алфавита?
Ну,
будет там
Н на лог алфавита.
В подавляющей большинстве случаев лфит константный.
Нет, оно, конечно, да, если у вас там
лфит и камешки, то алгоритм за НЛОГН
оптимальный, это да. То есть быстрее
не бывает.
У нас будет субдерево?
А, как же. Нет, субдерево не автоматно.
Ну, конечно.
Нет, укранин будет, не волнуйтесь.
Он укранин?
Нет, ну, один из нет алгоритмов
поиска субдерева за линию
ДШШ и даже больше укранин далеко не первый.
Просто он считается наиболее простым прямым
алгоритмом.
И более того, он приятный тем, что
он как бы итеративный.
То есть алгоритм подразумевает так, что
если у вас есть строчка и есть субдерева,
если вы приписали к ней символ,
то вы как бы чуть-чуть пошаманили
и получилось
дерево для новой строки.
Но там, к сожалению, алгоритм
амортизированный, но
тем не менее. Но он считается наиболее
простым, потому что там есть какие-то более старые
алгоритмы Вакка Маккрейта или там
какие-то Вайнера там какого-нибудь там
и так далее. Но они как бы просто
вам как бы подключили вот там
ну не подключили, а там просто вот вам
строчка, я там полная строчка, я под ней
там почесался, почесался, вот вам субдерева.
Вот.
Ой, подождите, а можно еще плюс символ писать?
Нет. Говорит, могу только заново пойти.
Вот.
Ну вот.
Значит, ладно, вернемся в протокол.
Значит, это был нот.
Задача про сочетание. Так вот, задача про кубики.
Задача про кубики может
звучать так. Ну, короче говоря,
дам набор из там
200 кубиков
и
нам хочется... Ну, кубик,
что такое кубик? Это значит, у него есть шесть граней,
на каждой написана какая-то буковка.
Можно ли из этих кубиков собрать какое-нибудь слово
за вечность?
Ну, или какое-нибудь любое другое слово.
Вот. Ну, известная такая задача, да?
Ну, может неизвестно, но
как она решается, но тупой способ очевидный.
Левая доля кубики, правая доля
позиции в слове, буковки прям,
строим и в явном
виде делаем про сочетание.
Что-то я запутался.
Почему нельзя проверить, что у нас
есть буквы В, Е, Ч,
Н, О, Э?
Что может В, Е, С, Н, Т, С, что В, Е
находится на одном и том же кубике?
Да, вот есть такая
маленькая подлянка, да.
Вот.
Но на самом деле
это решение, если вы знаете не просто
не только там какого-то тупого куна,
но и все-таки потоки, то решение можно
оптимизировать для больших ограничений.
Потому что, предположим,
что окажется,
как оптимизировать?
Потому что оказывается следующее,
что у вас может быть очень много ребер.
Например, если у вас
есть 200 кубиков
и строчка длины 200,
и
на всех их написана одна и та же буква,
то грав вы построите размеры 40
тысяч ребер.
Но на самом деле это достаточно легко оптимизировать.
Каким образом?
Нужно просто
букву
ввести.
Потому что, по большому счету,
нас не интересует порядок букв,
нас интересует про каждую букву, по большому счету,
сколько раз она встречается.
Поэтому на самом деле в правой доле
встроим то же самое
типа просочетания,
но в правой доле у нас только
вершинки A, B, C, D, Z.
А здесь ребрышкой пропустой способности
не один, а
сколько раз эта буква встречается в слове.
Понятно, да?
То есть можно вот такое
там можно тут уписывать.
То есть мы говорим, что
у нас есть объекты,
которые ассинктически работают за констанцию?
Нет, нет, нет, нет.
Смотри, это у тебя
потому что в правой доле 26 вершин,
а в левой-то у тебя количество кубиков...
26 в шестой.
Ну да.
Нет, ну кубик...
Нет, ну как сказать, на самом деле идея,
потому что у вас в домашнем задании будет задача,
в которой такой хак все-таки прокатывает.
Как называется карточка.
Да.
Не за константы, потому что мы не знаем,
сколько кубик, сколько видов, какого кубика.
Нет, в смысле раз вверх сети будет
количество вершин и ребер, будет не происходить константы.
Вот так. То есть другой вопрос, да,
что конечно пропустые способности константы
и быть уже не обязаны, но соответственно.
А.
Решение?
Ну решение такое.
Значит, для каждой...
Строим такую же сеть, где
в левой доле находятся кубики,
тут все честно, да.
А в правой доле буковки.
То есть не само слово,
а только буковки, 26 вершин.
Из каждой из них в сток
выведем ребро пропустной способности не один,
а сколько раз эта буква встречается.
То есть, например, если у нас
было слово аббатсаба, то здесь было бы 4,
тут было бы 2, тут было бы 1.
Вот. Ищем в такой сети
максимальный поток.
И, собственно, там, допустим, в эту вершину, допустим,
входят там, допустим, 4 ребра,
это означает, что вот из этих 4 кубиков
мы букву а и возьмем.
Вот такая идея.
Но, в принципе, как уже было сказано,
принципиально разных кубиков
не более, чем 26 в шестой,
там можно еще более точную оценку подогнать.
Там, по-моему,
там что-то типа
C из 26 по 6 чертой
или что-то в этом роде.
Да, C из 26 по 6 чертой.
Это C из 31 по 5.
Это чуть меньше.
Вроде. Вот.
Тоже тут можно аналогичное
сжатие сделать.
Нет, ну просто реально, если вы понимаете,
что у вас существует две вершины,
в которые входят ребра
из одних и тех же вершин
и из которых ведут ребра
в одни и те же вершины одинаковые,
то, как бы, возникает естественный вопрос,
почему бы нам
эти вершины не объединить.
Вот.
Ну, там что-то типа такого.
Ну, бывают там и более
продвинутые задачи.
Сейчас какая...
Сейчас, ладно, давайте, прежде чем мы пойдем
еще раз на перерыв, кажется, тоже время уже пришло,
там какие еще были задачи?
Нет, там еще была задачка...
А, но есть еще веселая задача про монетки.
Не сталкивались?
Там что-то Петя коллекционирует
монетки.
И монетки существуют всего там,
допустим, какого-то ограниченного количества типов.
Там 100 типов у них.
Каких-то монеток у Пети нет,
а каких-то, наоборот, много.
И тут оказывается, что Петя, в принципе,
те монетки, которые у него лишние,
то есть если какого-то
типа монеток у него больше,
то он их готов выменивать.
Но выменивать у нас там,
по правилам мира, можно только одну
монетку на одну монетку,
но при этом оппонент
согласен поменять
монетку на монетку только
в двух случаях. Только при двух условиях.
Первое, ему дают монетку,
которой у него нету.
И второе, он отдает монетку, которой у него тоже в излишке.
Это каждый момент времени.
Да.
То есть в каждое время я смотрю.
Петя обнаруживает, что Вася
готов меня обменять монетку
номер пять на мою монетку номер семь.
Если у него
нет монетки номер семь,
а монетки номер пять у него
хотя бы две.
И там, собственно, задача, какое максимальное
количество различных монеток Петя в итоге
при правильной организации обменов
может получить.
Вот, понятная задача, да?
Ну,
чего?
Ну, оппонентов тоже может быть
много, и дано, естественно,
и Петя еще и знает, там, сколько у кого,
у сколько у кого и каких монет.
Но тоже там везде по сотки
всего.
Ну вот, ну и там,
в общем-то, оказывается, что
ну, то есть оказывается, что
оказывается, что там надо
просто тоже там, если вкратце там,
построить сеть, где там
вершинами будут монетки, соответственно,
то такие типы монеток, а
между двумя монетками там есть действительно
какое-то ребро, какой-то пропускной способности
там семь. Это означает, что
я теоретически, что теоретически Петя
может обменять там семь таких
монеток на семь таких монеток у вот этого
вот менялы.
А нет, не может.
Нет, он такую монетку
может обменять только одну, поэтому просто
рисуем единичную эту.
Он хочет получать только те монеты, которых у него нет.
Да.
Он не может быть умным,
чтобы копить какие-то другие, потом их
обменивать.
Сейчас, а может, нет, надо подумать,
ой, а нет, вру. Может, кстати, может.
Может, может, может. Ладно, вру.
Петя обменивает все что угодно, да.
Да, вру.
Чего?
Нет, оппоненты, нет, они люди тупые.
Все, они...
Они говорят, я готов обменивать, только если ты мне
дашь то, что у меня нет, и я тебе отдам то,
что у меня еще есть.
Да, с друг другом они не меняются.
Да, с друг другом они не меняются.
Да, Петя умный, да.
Нет,
я не дай.
Как говорится, я ни в коем случае не хочу
обменить никакого конкретного Васю,
просто мы зафиксировали Петю, значит будет
Петя, да. Но там в условии Петя был,
так что все вопросы к составителю
условия, да.
Вот.
Вот.
Да хоть Серега, Господи.
Так.
Значит...
Нет, ну и там вот действительно...
Ну там просто вот оказывается, что надо
такое построить, то есть как бы понятно, что
между двумя монетками действительно получается
там, то есть
каждый возможный обмен фиксируется,
получается. То есть там
оказывалось, ну там технология оказывалась примерно такая,
что каждый там
то есть как
единичным ребром фиксируется,
что как бы вот эта монетка может быть обменена
на вот эту.
Вот. Но с другой стороны у самого
Пети, вот мы из сток типа Пети рисуем,
да, то есть у него как бы есть, мы
рисуем там ребро пропускной способности
5, если оказывается, что изначально у
Пети 6 монет такого типа.
Вот, понятно, да?
То есть там
6 понятно, что в эту вершину можем еще как-то
пройтись, и вот как было правильно замечено,
мы эту монетку можем еще другим способом
получить.
Потому что действительно мы там можем пойти там по цепочке,
эту монету принять на эту, эту, на эту, на эту,
на эту, а потом выменить там то, что нам реально надо.
Вот.
Да.
Ну вот.
А, а можно даже не 5.
Можно написать
как бы
Мне кажется 5. Мы пишем,
а вам пишем, в котором у нас ребра
из стока. Да, на самом деле
да, потому что важный момент, что
из каждой такой монетки
нам бы в идеале есть по одной
монетке допустим 100.
Вот.
То есть просто
потому что каждый такой путь
будет говорить о том, что у Пети в результате цепочки
обменов появилась какая-то
монетка.
Ну либо появилась, либо, видите, если она была,
то как бы мы можем одну единицу потока
провести через эту вершину.
Или мы оставляем вариант, что
может быть нам выгодно все эти 6 монет
на что-нибудь поменять.
Да, это другой вопрос, да.
Хотя возможно примерно из этой технологии
потом вы уже доказываете, что на самом деле
идею монетку выменивать бессмысленно.
Ну там как бы на самом деле
там аккуратность нужна, но обычно
тут это не нужно, потому что просто вы там
строите такого рода сеть, как бы потом
строите поток, декомпозируете его
на пути, соответственно, и каждый
путь это на самом деле такая цепочка обменов.
То есть это
я просто привел еще как пример
такой нетривиальной задачки, в которой нужно
построить сеть, найти в ней поток
и этот поток конкретно
проинтерпретировать.
Но на самом деле как бы не менее
популярным является
как раз наоборот там примеры задач,
в которых ваша цель на самом деле
построить сеть, но к задаче
имеет отношение не сам по себе поток,
а именно минимальный разрез.
Но такие задачи, видимо,
мы рассмотрим после перерыва.
Продолжаем
веселую киношку.
Значит, итак, следующий тип задачек.
То есть это задачи, где
нам поможет именно разрез.
Ну, одной из просто, может быть, классических
задач на эту тему
является, любимая мной задача,
называется
Ярость и команды.
Вот.
Не-не-не.
Нет.
Не-не-не.
Значит, смотрите.
Представьте себе
ситуация. Представьте,
вы организовали стартап.
Ну, типичная ситуация
такая.
Что такое обычно стартап поначалу?
Это когда у вас где-то там 5 человек
условно максимум.
И вы все условно,
ну, не то, чтобы все делают все,
но более-менее работаете за одним столом,
все в курсе, что делает каждый,
то, что вы все обсуждаете и так далее.
То есть вы как бы все вместе,
вы как бы едины и так далее.
Вот.
Но, как это
часто бывает, стартап оказался
успешный.
Как это не часто бывает.
Ну,
ну, все относительно, но
стартап оказался успешен.
И
ваша команда начала расти.
6, 10,
50, 100.
И вы поняли, что уже как-то
места в кабинете
заканчиваются.
И вообще сложно уже так
жить так, что мы как бы все знают
все, все едимы и все все понимают.
Это уже
заговаривает пост.
Поэтому вы решили,
лимит количества людей для каждой команды
твой, но суть одна.
Вы решили,
что пришло время обводить какие-то отделы.
Ну, с чего вы
начали? Ну, начали с того,
что вы решили поделить
вашу компанию
на две команды.
Ну, например,
будем называть их, например,
программистами
и тестировщиками.
Нет, у нас две команды,
не три.
Так что нет,
уборщики это не то, уборщики это
как бы просто клининг фирмы,
которая отдельно там нанимается,
это не интересно.
Ну, не говоря уже о том, что может у вас
и фиксировано офис, а нет, вы там у кого-нибудь на хате
сидите, господи.
Нет, ну это в общем не важно,
это уже отдельная песня. Может вы там
офис какой-нибудь арендуете в какой-нибудь бизнес-центре
и так далее, не важно.
Решили поделить
на программистов и тестировщиков.
Ну, в принципе, вы так подумали,
ну, в принципе,
у вас все, как это часто бывает,
там люди крутые, могут круто программировать
и круто тестировать.
Вот. Поэтому
как же поделить?
У вас тут целых два степени способов, как это сделать.
Ну, вы решили,
ну, вы как-то
еще более часто бывает очень любите своих сотрудников,
поэтому решили спросить
их в их мнении.
Значит, провели,
провели опрос и
выяснили следующие
интересные особенности.
Оказалось, некоторые люди
хотят быть программистами
и не хотят быть тестировщиками.
Но тут все не совсем
бинарно.
Тут оказывается следующее,
что какой-нибудь Петя говорит,
я хочу быть
программистом. Слушай, а может так случиться,
что нам тебе придется делать тестировщиком?
Ну вот. Но тогда выяснилось,
что
Петя расстроится.
И расстройство
Пети
мы выразим величиной
А с индексом Петя.
Вот.
То есть это какая-то величина больше нуля.
Вот.
Это означает, что мы, значит,
то есть если мы, то есть Петя
может быть программистом, если вы его сделаете
тестировщиком, он будет
плакать. Уровень его плача
значит А Петя.
Вот.
Ну, во-первых,
минимизировать.
Тем более, что есть и
тем более, что есть другое.
Оказывается,
оказывается, например, некоторые очень любят
тестировать.
Ладно, не будем отходить от классики.
Значит, теперь Вася очень любит тестировать.
Давайте лучше Витя.
Что инаком он любит тестировать?
Нет, ну ладно, нет, просто Петя и Вася это как-то более классично.
Я-то могу, конечно, написать хоть
Аскольд и Эдгард, господи, но там
все-таки.
Значит...
Ой. Ага.
Елось Валера. Да, Елось Валера.
Да-да-да.
Ой. Ладно.
Короче говоря,
Вася очень хочет быть тестировщиком.
Если у него
не получится быть тестировщиком,
его посадят все-таки программировать.
Вася расстроится.
Вот. Ну, уровень В.
Ну, Петя и Вася я пишу условно, потому что
на самом деле
у каждого,
оказывается, члена команды
есть какое-то мнение на эту тему.
Еще более того, чиселки, естественно, разные.
То есть, наоборот,
мы знаем, что кому-то
для кого-то
это Ашка означает, ну, я чуть-чуть расстроился.
Я все-таки больше люблю программиру, чем
тестировать, но в принципе...
Но так мне не особо принципиально.
Буду плакать.
Буду плакать на один.
Нет, а тут я буду
плакать немножко здесь. Тут я буду плакать
чуть побольше. Не то чтобы плакать, но просто
я привык программировать.
Если вы меня сделаете тестировщиком,
мне придется переключаться. А когда я переключаюсь
на новую задачу, я некоторое время
злобный.
Но это быстро пройдет, поэтому так.
А это если он больше любит программировать,
а то это если он любит тестировать?
Да. Уважно.
Вот.
И в принципе
все нот. А кто-то
может наоборот. У кого-то там этот уровень может быть
10-9.
Потому что
не знаю. Потому что программистка
далеко не та Лиса,
допустим.
Она наоборот. Если ее заставят тестировать,
она будет просто возмутиться так,
что...
Я не обезьяна!
Ну может и так, ладно.
Ну да, может у нее вражденная
такой какой-то небольшой
глюк в мозгу, и она там слово тестировщик
почему-то подменяет на слово обезьяна.
По каким-то причинам.
Да, вот.
Ну там вся... Ну у этих программистов
стартапов всякое бывает, там конечно всякие
издвиги. Вот. Поэтому да.
Поэтому если Лису сделать
тестировщицей, то она
взводит на уровень 10-9.
Вот совсем.
И теперь задача.
Ну казалось бы да. Нам хочется, ну понятно,
что скорее всего разбить так, чтобы никто не плакал
невозможно, естественно. Но хочется плакать было
как можно меньше. Пока задача решается
просто. Давайте просто тех, кто хочет быть
программистом, сделаем программистами, кто
хочет быть тестировщиком, делаем тестировщиком.
Но хотим суммарного плача, или это
можно больше? Нет, как можно меньше.
Или Brittany плач suffice?
Нет. Но хотим, чтобы
суммарного плача было как
можно меньше. Чтобы они плакали
где-то там тихо.
Ну чтоб суммарно потише.
потому что мы все равно, хоть у нас будет две комнаты одни-одна, но все-таки общее настроение.
Я тут минимизировал максимальный плач.
Нет, тут другая задача. В таком виде она кастривиальна, но дело в том, что у Вазикова еще одно мнение.
Это одна интересная особенность работающих в стартапе людей.
Дело в том, что если люди работают в одном стартапе, они иногда дружат.
Вот, бывает такое.
Не, дружбу отменять не надо, дружба, наоборот, хорошо влияет на дружный коллектив.
Не то чтобы мы опускаемся до этой пошлости, что мы не просто стартап, мы одна семья и так далее.
Если начальник не может решить проблему дружбы двух людей, то это плохой начальник.
Ну, не, ну как сказать.
Скажем так, понимаете, если у некоторых людей сильно дружба, то, наоборот, как бы они не решили проблему начальника, который пытается решить их проблему.
Вот, так вот.
Но, значит, анализ оказался следующий.
Что значит, товарищи какие-нибудь там?
Ну ладно, давайте. Так, какие у нас там товарищи будут у нас?
А, Леша и Слава?
Нет, Леша и Слава.
Нет, тут конкретная отсылка.
Конечно, Леша и Слава вот хотят работать вместе.
Им не особо принципиально в каком отделе, с точки зрения дружбы, по крайней мере.
Но если их разлучат, так если их поставить одного, программировать другого, тестировать, то, соответственно, они тоже будут плакать.
Сумарно.
Чего?
Или каждый.
Сумарно.
Сумарно.
Ну, когда люди дружат, плач сумарен.
Но оказалось еще неожиданные спецэффекты.
Да ладно.
Нет, ну там...
Да какой гиперграф?
Нет, там еще жалко, у меня черного маркера нет, но неважно.
Оказалось, есть еще интересный спецэффект.
Мы знаем, у кого он есть.
Нету черного.
Или это тот самый черный, который не стирается.
Да.
Да.
А нет, стирается, смотрите.
Жалко, жалко.
Черт, тут жалко.
Вот были у меня времена, когда я притаскивал 12 разноцветных маркеров, конечно.
Вот, надо быть, наверное.
Попарно разноцветных?
Ну да, да, да.
У меня там были рыжие маркеры, фиолетовые там маркеры, там коричневые маркеры, там все, что угодно.
Вот.
Ладно.
Ладно.
Так.
Давайте не будем тратить время, а то сейчас затянется еще.
Вот.
И значит, оказалось еще.
Потому что оказалось еще всякие спецэффекты.
Потому что отношения между людьми всякие, потому что вот та же, ну вот.
Потому что, например, там есть какая-нибудь алимистика, которая просто не хочет быть тестировщицей.
А кто-то наоборот.
Ну вот.
А кто-то наоборот.
Услышавших, ну вот.
Там не хочет, там, ну вот.
А кто-то наоборот.
Ну вот.
Нет.
А кто-то говорит.
Нет.
А нота.
Но с другой стороны, потом какая-нибудь та же самая Алиса или кто-нибудь еще в этом роде.
Неожиданно заявляю.
Слушайте.
Нет.
Ну тестирование.
Нет.
Ну тестирование.
Знаете, что мне не нравится?
Нет.
Можно, конечно.
Ну просто я себе представлю, что вот этот вот козел Жора там.
Нет.
Нет среди вас Жора.
Нет.
Нет.
Нет.
Нет.
Ну просто.
Все в телевизоре.
Ну все в телевизоре, да.
Ну ладно.
Да, прости, там Жора.
Да, мы не вели тебя в виду.
Да.
Вот.
Ну короче говоря.
Ну просто если, просто если, знаете, что это такое, что это?
То есть если, если я буду проигрывать, этот козел Жора будет меня тестировать.
Это что за безобразие вообще?
Да я вам тут всем.
Я вам тут устрою.
Я вам тут все раскисую.
Я, в общем, короче говоря, вы посчитали ущерб.
И поняли, что он равен D.
То есть D, Алиса и Жора.
Да.
Вы считали, сколько Алиса разнесет?
Мы, это означает, мы посчитали, значит, сколько еще ярости будет, если выяснится, что Алиса окажется программистом, а Жора окажется тестировщиком.
Но ее устроит.
Если Алиса будет тестировать Жору, ее устроит.
А вот если Жора будет тестировать Алису, Алиса взводит.
Чего еще раз?
Что такое D?
D.
Значит, еще раз.
Формально, D.
Для двух людей, например, Алиса и Жора, оказывается, что если Алиса окажется программистом, а Жора окажется тестировщиком, то тогда ярость увеличится на вот эту величину.
Именно так.
Но если Алиса окажется тестировщиком, а Жора окажется программистом, то будет все нормально.
А если они будут в одной весовой категории, то тоже нормально?
Тоже нормально.
А что за черт?
Насколько люди будут недовольны, если их поселят в разные команды?
Да.
Зачем столько отношений?
Нет, потому что мне просто хочется как можно больше различных.
Хотя вот как мы сейчас увидим метод решения, то есть видим, просто не все работает.
А C не будет, как мы говорили, что Леша будет злиться на половину?
Не-не-не-не, обратите внимание.
Тут будет плохо, если они...
А, ну в принципе, да.
C это как все давно жить на два.
Да, но здесь давайте D оставим, потому что тут будет важный момент, поэтому мне хочется...
Мы всегда оставим C.
Ну да, ну хорошо, можем.
Хорошо, да.
Можем D.
Хорошо, давайте D сделаем зеленый тогда.
Вот так.
Вот.
D, D, Лиса и Жора больше 0.
Хорошо.
Знаете, хорошо.
Ну а теперь вот такие вот у вас пришли сведения.
Сведений много.
Более того, каждое сведение, более того, одного и того же человека может касаться несколько таких сведений.
Ну потому что кто-то может плакать и от этого, и от этого, и от этого в принципе.
Ну да, ему в принципе не нравится.
Нет, в смысле, потому что его...
Ну нет, вы просто его устраиваете и высвоит то, как это происходит сейчас.
Разве C не сводится к D?
Сводится, сводится.
Вот поэтому я зеленым перерисовал, что C на самом деле сводится к двум D.
Хорошо.
Да.
Ну вот.
Но теперь возникает вопрос.
Но теперь вот возникает вопрос.
Как же такую задачу решать?
И казалось бы, причем тут потоки вообще, да?
Ну вот.
Да, но это типичная задача, где надо строить сеть, но искать в ней не поток, а разрез.
Одно и то же.
Нет.
Нет.
Ну как бы идея на это не одно и то же.
Потому что разрез теоретически можно найти как-нибудь еще.
А, это реально разрез.
Да.
То есть в данном случае наша задача построить сеть, в которой минимальный...
Ну в идеале...
То есть идеальная ситуация такая здесь.
Мы построим сеть, в которой пропускная способность каждый...
То есть каждый разрез это будет символизировать, как мы пытаемся поделить.
А пропускная способность этого разреза будет соответствовать ярости,
которая получится именно в этом разрезе.
И тогда ваша задача будет найти просто минимальный разрез.
То есть там отдельная песня, что он ищется максимальным потоком,
но это уже там в черном ящике написано.
То есть если вы придумаете как искать минимальный разрез без потоков лучше,
то значит вам вообще нет.
Тогда эта задача перестанет быть задачей на потоке.
Но пока правда, к сожалению,
оптимальный известный алгоритм поиска минразреза сводится к потоку, поэтому увы.
Вот.
Итак, как же мы это будем делать?
А очень просто.
Значит, смотрите, товарищи...
Нет, так-то поток же сводится к разрезу?
Нет.
Ну смотри, как это?
Ну поток обычно ищется вот как поток.
Разрез?
Я имею в виду, что поток сводится к задачи разреза в целом.
Если будет возможность...
Ну нет, не совсем...
Ну как сказать?
Если бы в чиселку получить...
Да, если в чиселку, то да.
В рёбра, то кажется, что нет.
То есть нет, там отдельная песня, можно задуматься.
Предположим, что ты там...
У тебя есть какой-то там...
Выражая как это?
Черный ящик?
Или выражаясь как-то от логики?
Оракул?
Вот это.
Который...
Которому ты можешь подсовывать там любой разрез,
он тебе с небес по факсу присылает его пропускную там...
Нет.
Способность я сам могу?
Нет, хотя нет.
То есть, точнее так.
Допустим, у тебя есть оракул,
который по сети сообщает тебе величину минимального разреза.
Тогда будет интересно, да.
Там какой орхет тогда тебе нужен?
Сколько таких запросов тебе надо,
чтобы вообще хотя бы найти сам минимальный разрез,
во-первых.
А во-вторых, еще и построить по нему поток.
Поток же не только сообщает величину, но и говорит сам поток.
По идее оракул тогда должен говорить и разрез сам тоже.
Ну, допустим.
Допустим.
Просто можно ли по этому...
И настолько быстро из этого восстановляется поток.
Ну да, ну да, ну да.
Вот.
Ну так вот, ладно.
Итак.
Как строим сеть?
Ну, естественно, каждый участник у нас,
нашего стартапа, значит, это вершина.
Также мы вводим, допустим...
Ладно, правильно, видимо, я сделал так.
Вводим и сток.
Сток.
А, ну да.
А, нет.
Черт.
Черт.
Так я что-то с цветами напутал, да?
Нет, давайте вот, чтобы с цветами все соответственно было все-таки.
Или ничего.
Ну, у нас проблема в том, что типа дискретно изменяется.
Если петь чуть-чуть программиста,
то он сразу плачет сильно, а если не чуть-чуть,
а если вообще не программист, то плачет на ноль.
Почему?
Нет, ну в смысле, в смысле, не понял.
Нет, в данном случае это говорит о том,
что если петь программиста, он не плачет вообще.
Но если петь тестировщика, он плачет и жестко, да.
Ну, к сожалению, у нас такая команда...
Ну, у нас как бы все просто.
У нас человек либо как бы либо программист, либо тестировщик.
Вот такие у нас два отдела.
По крайней мере, так изначально выглядит.
То есть там другой вопрос шел, понятно.
То есть тестировщики там, возможно, тоже все так ходят.
Как минимум тестовые примеры автоматические.
Но как бы понятно.
Ну да, но это уже там, да.
Ну, у нас вот так.
Ну, как сказать, мы люди простые,
у нас в стартапе обычно.
То есть вы же там,
не начинайте там приходить
и разговаривать с ними в каких-то там
умных языках, там каких-то там
с полудепутатскими диалектами
какими-то вот этими всеми.
Так.
Вот, значит, смотрите.
То есть вот будем считать, что давайте,
вот у меня есть исток, он будет соответствовать
как бы и доля S,
у меня будет соответствовать доле
программистов.
А
красная T будет соответствовать
доле тестировщика.
Но это идейно.
То есть я, например, да, цель у нас
составить такой граф, чтобы
у любого разреза была пропускная способность
равная ярости при соответствующем
разбиении в стартапе.
Как это сделать? Ну, потому что вот
как вот добиться того,
например, пусть у меня есть Петя.
Ну, давайте
себе вот вообразим вот
такой разрезик.
И вот нам очень хочется, чтобы вот этот
вот Петя, вот он допустим,
да, а нет, так неправильно.
Так, Петя у нас синенький,
поэтому пишем вот так.
Так, вот.
Вот.
Да. Значит,
соответственно, Петя синенький.
И теперь нам хочется, что если Петя оказался
в доле тестировщиков, он плачет,
а если в доле
программистов, то нет. Как нам этого добиться?
Наоборот, очень понятно.
Надо просто нарисовать вот
такое ребро из истока
третью пропускной способности
о Петя.
Все.
Ну, да.
То есть тогда, видите, то есть это ребро как бы
войдет в разрез, если
Петя будет тестировщиком и не войдет,
если окажется программистом.
Вот, видите, очень удобно.
Так, что у нас еще есть?
Так, ну
Б это симметричный случай.
Что надо сделать с Васей?
Сделать его тестировщиком.
Как его сделать тестировщиком?
Привести в сток.
Ага, да.
Вот. Привести ребро
из Васи в сток
с пропускной
способностью Б Вася.
Вот.
Так.
Вот теперь давайте посмотрим.
А вот теперь интересно.
Вот у нас теперь произошла
радость с Алисой и Жорой.
Ну, вот давайте
допустим, вот тут я нарисую, вот это у нас
где-то здесь будет Алиса.
А вот это будет Жора.
Как нам теперь, то есть надо теперь сделать так,
чтобы у нас
Дэшка,
значит, то есть надо
теперь сделать так, чтобы
значит, если Алиса оказалась
программистом А Жора тестировщиком,
то мы, то тогда значит
плач сработал.
Если нет, то нет.
В любом ином случае нет.
Как нам это сделать?
Да, тут очень важно, что мы здесь проводим
именно ориентированное ребро
именно из Алисы в именно Жору.
Соответствующей пропускной
способностью
Д Алиса и Жора.
Вот.
То есть обратите внимание, видите?
То есть если Алиса программист
Жора тестировщик, то это ребро в разрез входит.
Если Алиса и Жора оказались
оба тестировщиками либо программистами,
то ребро в разрез не входит.
Но если Алиса оказалась
тестировщиком и Жора программистом,
то это ребро в разрез
внимание тоже не входит.
Понимаете, да?
Потому что ребра, которые идут отсюда-сюда,
нас в разрезе не интересуют.
Вот это очень важно.
Поэтому я хотел обратить на это внимание.
Вот.
Именно поэтому, когда у вас есть
вот это симметричное отношение,
что Леша и Слава просто дружат,
то тогда нужно, чтобы Леша и Слава...
То есть тогда
Лешу и Славу...
Ну тогда пополам делить не нужно, короче.
Нет, пополам не нужно делить, боже упаси.
Надо просто нарисовать
фактически два ребра.
В обе стороны.
И тогда если они окажутся в разных отделах,
то тогда
сработает ровно одно.
Если у нас ребро не в какую сторону,
она разве не интересится на комминус?
Нет-нет-нет.
У нас нет никаких обратных ребер.
Мы строим сеть.
У нас из ТФС ребро?
Нет.
Это с минусом берется,
когда мы говорим о потоках,
но не о пропускных способностях.
То есть вполне может быть,
что у вас есть труба,
по которой вы течете отсюда-сюда,
а есть труба, которая течет отсюда-сюда.
Ну то есть две стороны.
И более того, пропускные способности могут различать.
Может быть так, что в одну сторону у вас 5 полос,
а в другую 3.
Пропускная способность это только...
Это сумма тех, которые...
Нет.
Пропустая способность это...
Это такое чиселка на ребре.
Это сколько потока может в единицу времени
этому ребру течь?
Это...
Пропускная способность для разреза.
Нет, пропускная способность разреза это мы перебираем
все ребра, которые ведут из доли С в долю Т
и суммируем их пропускные способности.
Вот так.
То есть тогда в эту...
То есть если эту пару разрез разлучит,
то ровно одно из этих ребер в разрез войдет.
Поэтому получится то,
что надо.
То есть вам останется только построить такую сеть,
найти в ней минимальный разрез.
И, скорее всего, потоком или каким-то другим способом.
И, соответственно, победить.
То есть вот...
Часто дают задачи на поток,
которые правильно называть задачами
на разрез.
Вот.
То есть вот такая типичная
ситуация.
В принципе,
там начинаются вообще всякие
умные лайфхаки в духе,
что...
То есть иногда
там надо придумать
что-то в духе, что
если, например...
Иногда нам говорят, что есть вот
уровень заприти... То есть как бы
будет плакать, а есть уровень, что Петю нельзя
сделать программистом, потому что он там
молодец.
Но просто известно, что Петя должен быть
глава отдела программистов тут без вариантов.
Ну вот. Как тогда такой запрет сделать?
Ну...
Зачем?
Ну да.
То есть тогда просто нарисовать штраф
плюс бесконечный.
Ну да.
Можно считать, что да.
Можно отправить Петю в сток.
Но чаще просто удобнее бывает вот так.
Потому что ровно так же, если нужно запретить
вот такую ситуацию, например, то тоже выгодно
просто добавить по ребро плюс
той способности плюс бесконечно.
А как сделать так, чтобы в одном отделе было ровно
не искать?
Вот это такими методами
боюсь никак.
Ну или мне слёто непонятно.
То есть, к сожалению, да. То есть этот метод
не всесилен. Потому что в идеале наоборот
бы хотелось, что там какие-то люди
наоборот там не дружат. Ну ладно, не дружбу
мы, видимо, можем вот так вот.
Нет, точнее наоборот. Какие-то люди
очень хотят быть в разных отделах,
например, и если вы их пихнёте
в один отдел, они будут плакать.
Да, и как так? Никак.
По крайней мере, таким методом никак.
Ну может быть там
может такими не знаю, но тут вот
то есть, к сожалению, да,
задача в этом сфере не всесильна.
То есть тут, к сожалению,
работают только специальным образом
подобранные ограничения.
Сейчас я правильно понимаю, что
с того, что вы нарисовали, нельзя
из С попасть в Т по этой сети?
Почему? Вполне можно.
Потому что из С вы там
попадаете в Петью, из Пети попадаете
куда-то там, как-то вот так и попадаете
в Т вполне.
Нет, может так, что не можете, это означает,
что у вас найдётся разрез ноль.
Это означает, что вы можете
вообще разбить
всех на отдел и так,
что вообще никаких проблем не будет.
Да, логично.
Ну просто будет у вас размер ноль,
это разрез ноль, это нормально.
То есть понятно, что если у вас этим всем
требования ограничиваются, давайте вот аккуратненько
эту линию проведём и возвращаемся.
То есть давайте Пети будут программистом,
все будут тестировщиками, всё хорошо.
Вот.
Ну там, господи, там
всякое там может быть.
Ой, господи.
А вообще стоимость
бесконечности,
это вообще легально в точки зрения
определения подобия? Нет, это
легально, потому что, как это часто в Олимпиадах,
ты вместо плюс бесконечности напишешь 10 девятый.
10 девятый легально,
короче, можно поставить такое число,
которое больше, чем всё в цену.
Ну вполне можно.
Ну да, да, да, да.
Нет, там разное.
Нет, ой, господи.
А у нас там не сильно много времени, господи.
Так, что я ещё хотел-то?
А нет, ладно, просто да.
Нет, ну ладно,
нет, у меня, конечно, был большой соблазн,
он прямо рассказал сразу Hard Life, конечно, да.
Ой, это
одна из легендарных
задач, которые никто не решил
на полуфинале.
Ну,
переводится так, да.
Но это ладно.
Но это ладно,
я ещё в своё время
расскажу.
Но пока, на самом деле,
нет, на эту тему можно тут ещё.
На самом деле, удовольствие можно получить,
не только решая именно Олимпиадные задачи,
но и чисто математически.
Потому что одним из моих любимых
примеров, например, работы
с потоками и разрезами
является знаменитая Леммо Холла.
Вот, кстати,
вы на дискретке там не сталкивались ещё с такой?
У нас не было дискретки.
А, графов не было.
Ну, понятно,
ладно.
Но просто, на самом деле,
да, просто есть такая там,
пока в математическом мире известная такая
Леммо Холла, но которая вот
очень интересна. Это тоже такой пример,
когда доказывать её, на самом деле,
через потоки оказывается легко, приятно.
А в остальном случае...
Ну, там, знаете,
на самом деле, скажем так,
если вы олимпиадник по информатике,
но пришли случайно олимпиаду по математике,
то есть классы задач, в которых вы будете иметь преимущество.
Но там, вы же в каких-нибудь задачах на графы
неожиданно работает идея вида запустим DFS?
Или там, в каких-то задачах говорят,
просто давайте посчитаем,
там бывает какая-то счётная задача,
и там, на самом деле, просто, если вы владеете идеологическим программированием,
то вы там просто изобрели формулу DPS,
доказали её, а потом честно табличку заполнили.
Ну, там бывают такие задачи.
Вот.
А бывает, например, вот такая. А бывает классическая задача,
а там, скажем, докажите Леммо Холла.
Или она ещё известна как теория
Леммо Холла.
В чём задача?
Ну, вот.
Классическая формулировка звучит так.
Значит, классическая формулировка
звучит так, допустим.
Значит, там N мальчиков
и N девочек
хотят пойти на бал.
Вот. Ну и мальчики, соответственно, хотят девочек
пригласить на бал.
Но, как и так часто бывает,
как говорится,
мальчик может пригласить девочку на бал.
Только если она ему нравится.
Да.
Ну, в этой задаче всё примитивно.
То есть, как бы, мальчик – это существо
примитивное. Ему девочка либо нравится, либо не нравится.
А чё?
Ну, нет, просто нет. У нас в какой-то момент
может быть там постановка задачи всё-таки
более продвинутая.
Не, не, не.
Жать и соцветить – это другой вопрос.
Да.
Не, не надо.
Да, да, да, да.
Вот. Нет, у нас в этом смысле
нет. У нас всё, как бы, да,
всё примитивно. Но, как бы,
мальчики, ну, мальчики, значит, тут
нарисовали граф, что как бы,
какие девочки нравятся.
И теперь у мальчиков задача
договориться так, чтобы они, значит,
смогли договориться, кто, какую девочку
зовёт.
Но, внимание, вопрос.
Ну, вопрос, можно ли это? Ну, понятно, что
с точки зрения программирования, да, составьте
двудольный граф, там построите просочетание.
Но
нас это интересует с точки зрения математики.
То есть, какой критерий должен выполняться?
И вот есть
лемма-хола. Она говорит вот что.
Так. Вот, допустим,
у нас есть,
значит, да, вот этот вот
двудольный граф, значит, там
левая доля мальчики, правая доля девочки.
Вот.
Соответственно.
Ну, вот.
И, в принципе,
допустим, у нас есть какое-то
подмножество.
Ну, допустим, так, для каждого
мальчика у нас есть множество
эноту. Что такое эноту?
Это типа
множество девочек, которые ему нравятся.
А можно
рассмотреть подмножество
мальчиков и по ним
рассмотреть подмножество девочек,
которые нравятся...
Вот, короче говоря, это просто объединение.
Ну, короче говоря, то есть это...
То есть по каждому множеству мальчиков можно рассмотреть множество девочек,
каждое из которых
нравится хотя бы одному из этих мальчиков.
Ну, вот.
Ну, теперь мы можем заметить, что
если мы хотим прям,
то есть идеальную ситуацию,
чтобы все мальчики девочек
позвали, то что нам нужно,
нам тогда желательно, чтобы
в каждом подмножестве,
для каждого подмножества у было верно,
что в эноту девочек, наверное,
не меньше, чем самих мальчиков
в этом множестве, правда?
Ну, потому что если пяти мальчикам суммарно нравятся
три девочки, то есть проблемы.
Трех девочек на пять мальчиков не хватит.
Вот.
То есть, поэтому,
на самом деле, видите, бывает очень легко
доказать, что, не, ничего не получится.
Вот этим пяти мальчикам нравятся всего три девочки,
так что до свидания. Да, проблема.
А теперь предположим, что такого подмножества не возникло.
То есть, любому подмножеству
мальчиков нравится количество девочек,
не меньше, чем самих этих мальчиков.
Вот. Оказывается, что этого достаточно,
чтобы совершенное просочетание существовало.
Ну, совершенным я называю просочетание, которое покрывает все вершины.
И в результате
это звучит так.
То есть, существует совершенное просочетание.
Совершенное
парусочетание.
Парусочетание.
Тогда и только тогда,
когда для любого
подмножества мальчиков
верно, что размер N2
больше либо равен
размеру U.
Это подмножество R, верно?
Да, N2 это подмножество R.
Ну, как я уже сказал, подмножество девочек,
которые нравятся
хотя бы одному из этих мальчиков.
Ну, хорошо. Ну, давайте напишу.
Хотя...
Нет, лучше давайте.
На самом деле, Леву можно доказать,
если сказать, что
совершенным называется парусочетание, которое покроет всех мальчиков.
Да, чтобы мальчикам было хорошо.
Вот, честно скажу, я хотел
избежать этой ситуации, поэтому
N2 равно R.
Ну, конечно, понятно, что там...
Все еще девочкам может быть не очень хорошо.
Нет, ну понятно, что
если у нас
на 10 девчонок
оказалось тут 9 ребят,
то ничего не поделаешь.
Да, как минимум одна девочка будет страдать.
Девочки...
9 мальчиков пригласили 9 девочек.
Вопрос.
Умеют ли девочки говорить?
Ну...
Причем тут говорить?
Ну, не знаю.
А!
Чего еще раз?
Любое...
А, оговорился.
Да, в данном случае
вот так.
Но это означает,
что размер N от этого
мальчика равно нулю, что меньше,
чем размер N, что состоящий из этого мальчика.
То есть как бы, да, это условие автоматически
подразумевает, что из каждого мальчика
торчит хотя бы одно ребро.
Можно ли считать мальчика, которому не нравится
ни одна девочка мальчика?
Ну, как...
Ну, тут как бы оговорка.
Никто не сказал, что ему не нравится,
что ему не нравятся
девочки не из этого множества.
То есть как бы...
Мне очень нравится девочка,
но я не могу ее позвать на бал,
потому что она сейчас находится в Австралии, а бал через час.
Так что, соответственно.
Такое же тоже может быть.
А, ну да, и это не мультик таинственный портал,
и ее не в Ирландии.
Соответственно.
Тем более, что это не мультик, да, неважно.
Ну, хорошо.
Идем дальше.
А теперь спрашивается,
как доказать эту лему?
Так, ребят, ау.
Вот как доказать такую лему?
Казалось бы, при чем тут
потоки, опять же, да?
Ну, опять, потоки не при чем.
А вот разрезы...
Ну, в одну сторону понятно,
что если просочетания существуют,
то понятно, что любому множеству мальчиков
нравится как минимум девочки из просочетания.
В одну сторону очевидно,
а вот в другую вопрос.
Да, но на самом деле
оказывается, что
с разрезами тут на самом деле все хорошо.
Потому что что нам нужно доказать?
Нам нужно доказать, что
если вот размеры
обеих равны n, нам надо просто доказать,
что...
Ну, например, давайте сведем
к поиску просочетания потоком.
То есть что это означает?
Это означает, что давайте строим
вот эту нашу технологию.
То есть вот...
Строим вот это вот.
Строим вот это вот.
Т-шку какую-нибудь там...
Вот так вот, вот так вот и вот так вот...
Да?
Стандартная сеть.
И теперь надо показать, что в этой сети
есть поток размера n.
Как показать, что в этой сети есть поток размера n?
Надо, наверно, показать,
что максимальный поток
здесь имеет размер не меньше n.
Но так как максимальный поток
по тяжелям Форд и millimeter равен величине минимального разреза.
Значит, надо показать, что величина
минимального разреза здесь не меньше
н или что то же самое, достаточно показать, что величина любого разреза в этой сети не меньше n.
Логично, да? Ну поехали. Рассмотрим произвольный разрез в этой сети. Вот,
это доля S, это доля T. Это доля S. Мальчики, это доля T. Хотя нет, это не то, потому что есть
мальчики и девочки в доле S и в доле T. Это не то. Ну, значит, давайте смотреть. У нас оказывается,
что в доле S у нас есть мальчики, мы их назовем L, S. И есть соответственно еще какие-то девочки,
мы их назовем R, S. Вот, а есть мальчики в доле T, L, T и девочки из R, T. А что там, на R, T нету девочек?
Какого фаб-фа? Но кроме того, что фаб-фа не существует, ничего не имею. По-хорошему,
да. Нет, S и T это доли. Мальчики это L, девочки это R. Ну в смысле разрез не спрашивает. Да, S и T
это какой-то разрез. То есть мы построили сеть, мы взяли мальчиков и девочек и каким-то
произвольным образом порезали. А теперь давайте думаем, чему равна пропускная способность этого разреза?
Значит, поехали. С от СТ равно. Какие ребра у нас пересекают этот разрез в нужном нам направлении?
Ну давайте слева не с этого начнем. Во-первых, из стока в L, T. Поэтому сразу пишем красненьким модуль L, T.
И плюс сразу зелененьким еще пишем давайте симметричный вариант R, S. Вот эти вот ребра.
И плюс, как вы абсолютно правильно заметили, я так напишу С от L, S запятая R, T.
Нет, это просто какой-то разрез. Мы исследуем его пропускную способность.
СТ способность разреза. Нет, это большие S, T, видите. Так что привыкайте к языку.
Как бы это еще просто. Будет у вас макроэкономика. А у вас не будет макроэкономики, да ладно.
У кого-то будет. Вот там просто вас завалят сразу буквами.
Да. Веселый курс, очень полезный. Курс экономики. Первый семестр микроэкономика,
второй макроэкономика. То есть первый курс. Вы фирма и пытаетесь оптимизировать свой доход.
Макроэкономика тоже все просто. У вас на кухне стоит печатная машинка,
которая умеет печатать деньги. Вам нужно понимать, что будет происходить в экономике,
если вы напечатаете лишнего или, наоборот, запылесосите эти деньги обратно.
Обычно это кухня печатная машинка называется Центробанк.
Сейчас курс русского языка, ну видимо он же риторика, он же там вот это все не важно.
Вот там история конечно была. Тут без вариантов. Да, конечно. А ну из обязательных там по-моему
слету все. То есть там есть еще дополнительные конкурсы по выбору. У меня там была годовая
история кино. Ну я так ходил, но вот там было весело. Ладно, так давайте, так. А то у нас там время
потихоньку выходит по-моему. Да, три минуты назад вышло, поэтому давайте сейчас быстренько вот эту
задачу добьем. Да, погодите, спокойно. Потому что нет, нет, на самом деле тут все еще круче.
Потому что, смотрите, сейчас я тут давайте попишу. Значит, это равно lt плюс модуль rs, а вот это,
я скажу так, плюс c от, значит ls, вот я так напишу, lsr минус c от ls rs. Видите, да?
Хотя нет, так мы писать не будем. То есть это верное утверждение, но мы так писать не будем,
пожалуй. Оно нам не поможет. Потому что, смотрите, нам надо бы попытаться воспользоваться нашим
условием. Вот давайте попытаемся для множества ls использовать вот это условие. Тогда мы знаем,
что вот это вот. Знаете, как мы напишем? Я напишу так, модуль n от ls пересеченная с rt. Ну,
смотрите, сколько Реберта ведет из ls в rt? Ну, не менее, чем сколько у меня вообще соседей есть в
этом множестве rt, правда? Ну, может быть и больше, потому что там из разных мальчиков в одну и ту
же девочку может вести ребро. Ну, бывает же так, что девочка нравится больше, чем одну мальчику,
правда? Ну вот, я бы сказал, это даже скорее нормальная ситуация, чем нет. Ну вот, соответственно.
Но, тем не менее. Сейчас, еще раз, n от ls это все торчащие ребра, да? Да, n от ls это просто,
нет, это все девочки, в которых торчит хотя бы одно ребро из этих ls. Но я, как бы их,
видите, пересекаю с rt, видите, да? Вот. Но смотрите, как я сделаю. Теперь я делаю аккуратненько.
Значит, это равно модуль lt плюс модуль rs плюс модуль n от ls, внимание, минус n от ls, пересеченное с rs.
Ну, я такую теоретику множественную операцию написал, да? Смотрите. Это больше либо равно,
чем, смотрите, модуль lt плюс модуль n от ls и все. То есть, обратите внимание, я просто убил вот эти два слагаемые.
Ну, потому что очевидно, что размер этого множества больше либо равен, чем размер этого множества,
пересеченное с чем бы то ни было, правда? Поэтому осталось это. Ну, я обнаружил, что просто вот это
минус вот это больше либо равно нуля. Ведь я тут больше либо равно пишу, поэтому я как бы их типа
убил. То есть, я их как бы сократил. Ну, потому что я утверждаю, что вот это равно,
вот этому. Нет, n от ls равно n от ls, пересеченное с этим, плюс модуль n от ls, пересеченное с этим.
Это верно, потому что n от ls само по себе это как бы под множество вот этого. Вот то, что я тут написал,
это верно всегда. А теперь я пользуюсь вот этим условием. То есть, по предположению,
оказывается, что размер вот этого n от ls больше либо равен, чем размер ls. Ну,
тогда модуль lt плюс модуль ls равно модуль l. Все. Скажем так, кто-то, я не знаю, можно это дать в
домашнем состоянии, кто-то докажет там действительно по индукции, там будет что-то про индукцию,
про удлиняющие цепи. В принципе, да, у кого-то оказывается даже несложно. Вот. Но на самом деле,
вот просто я сильно радуюсь, видите, что с точки, как бы, если вы там пришли на Олимпиаду по
математике из программирования и знаете вот теорию Форда Фалкерсона, то в общем-то вы тут все,
то в общем-то вот это вот вы сделали достаточно на халяву. Вот эту лему мы доказали. Точнее,
что вот отсюда следует вот это. То есть еще раз сворачиваем. Мы доказали, что у любого разреза,
то есть разрез абсолютно произвольный, пропускная способность не менее чем n. Следовательно,
у минимального разреза пропускная способность тоже не менее чем n. Следовательно,
существует максимальный поток, имеет размер не менее чем n. Значит, существует
просочетание размера не менее чем n. Ура. Все. То есть вот такая цепочка оказалась. Такая вот
очка очень красивая. То есть на самом деле, чем понятно, то есть мы доказали, на самом деле,
казалось бы, просто чисто математический факт. Казалось бы, из мира математики программирование
тут казалось бы не при чем. Но на самом деле, вот оказалось, что оно при чем и очень даже. Вот.
Так что посмотрим. В принципе, у нас где-то там еще будет пара задач действительно на подобное.
То есть что-то, может быть, у вас все-таки будет в домашнем задании. То есть там просто есть еще
одна важная задача, которую тоже нужно знать. Но, возможно, я вам ее в домашнее задание оставлю.
То есть там тоже на самом деле вы сможете просто применить абсолютно ту же технологию и тоже
на халяву ее решить. Вот. Ладно. На этом тогда мы останавливаемся. Увидимся через неделю.
