Последнее, что мы доказали, была такая теорема о графике.
Теорема о графике. Она нам говорила, что для любой частичной функции,
ну можно считать из натуральных натуральный, хотя для пар, троек и прочего это также работает,
F вычислимо тогда и только тогда, когда F как множество пар, то есть F перечислимо.
Почему о графике? Ну мы воспринимаем F как множество пар, как график функций.
Отсюда у нас были следствия, что образ и прообраз перечислимого множества
под действием вычислимой функции является перечислимым.
В частности, если F вычислимо, то ее область определения, ее область значений перечислима.
Нашей задачей на самое ближайшее время является получение некоторых
эквивалентных перечислимости свойств. Итак, давайте попробуем.
Прежде всего, мы дадим такое определение. Ну пусть у нас есть какое-то множество,
например, натуральных чисел, но как обычно на пары, тройки и прочее это все тоже распространяется.
Мы говорим, что хи с чертой из n в, ну на самом деле в 1 подчеркнуто.
Хи с чертой называется полухарактеристической, ну не один чертой, пусть будет два черта, это неважно,
называется полухарактеристической, то есть характеристический, но полу, не полностью.
Полухарактеристической функцией множества тогда и только тогда,
когда для любого числа это хи у нас устроено следующим образом.
Мы с вами вступаем в мир частичных функций. Помните, были такие, которые не везде определены.
Когда это значение единица, если n попадает в а, и оно не определено, если n не попадает в а.
Что означает этот знак, помним? Он применялся нами для частичных функций, означает он следующее, давайте напомним.
Это означает, что или f от x и g от y не определены, либо оба не определены, либо оба определены, а значения равны.
Я буду читать этот символ как совпадает.
Это естественное обобщение понятия равенства значений для частичных функций, то есть два выражения, которые могут быть не определены,
они совпадают, если они одновременно не определены, оба не определены, или оба определены, но значения равны.
Например, я могу сказать, что один разделить на ноль совпадает с два разделить на ноль, правильно?
Вот полухарактеристическая функция, как она себя ведет, она определенная равна единице на а, а вне а она не определена.
Какой будет у полухарактеристической функции домен? Где она определена? В точности на а, это понятно? Ясно это?
А теперь давайте посмотрим, какая связь с перечислимостью.
Утверждение А перечислимо тогда и только тогда, когда полухарактеристическая функция вычислима.
Помните, мы говорили, что разрешимость эквивалентной вычислимости характеристическая функция.
Так вот, перечислимость эквивалентной вычислимости полухарактеристической функции.
Ну, в одну сторону, почему, если перечислимо, то она вычислима? Как ее вычислить?
Нам нужен какой-нибудь алгоритм для этой полухарактеристической функции.
Давайте его, так сказать, условно напишем на таком псевдокоде.
Вот нам дали n на вход. Нам надо посчитать значение полухарактеристической функции.
Что мы делаем? Запускаем бесконечный цикл, и что делаем?
Делаем шаг А красивого. Пусть А красивый перечисляет А.
Помните, у нас был алгоритм-перечислитель?
Ну, этот алгоритм может что-то вывести, правильно?
Если А вывел n, вот наше входное значение, то, останов, возвращаем 1. Понятно?
Почему такой алгоритм вычисляет полухарактеристическую функцию? Доказываем.
Если n принадлежит ее домену, то есть А, мы дождемся появления n, вернем единицу.
Если n не принадлежит ее домену, то такой алгоритм зацикливается.
Как им должно быть по определению вычислимости? Понятно?
В другую сторону более-менее очевидно из того, что мы доказали.
Ведь если полухарактеристическая функция вычислима, то ее домен мы знаем.
Мы знаем, что домен вычислимой функции всегда перечислим.
Значит, если она вычислима, то ее домен, то есть А, перечислим.
Каким образом перечислимость эквивалентна вычислимости полухарактеристической функции?
Согласны? Сейчас мы дадим еще одну характеристику.
Можно стереть определение полухарактеристической?
Это функция, которой единица на множестве не определена в ней Иван.
Утверждение два. Если А не пусто и перечислима, то существует вычислимая,
я отдельно напишу специально, тотальная функция, то есть определенная на всех натуральных числах,
такая, что А это просто range нашей функции, то есть f от нуля, f от единицы, f от двойки и так далее.
Понятно? В каком смысле мы можем перечислить множество?
Мы можем его перечислять в смысле алгоритма перечислителя, но есть и другой возможный смысл.
Мы можем считать, что перечислимость означает, что есть такая функция, которая порождает наше множество.
Вот считаем f0, f1, f2 каждое законеченное время, это будут все значения нашей функции и только они, правильно?
Согласны? А если па было пустым, это было бы верно?
Ну как range тотальной функции может быть пустым? Никак.
Ну как это доказать? Нам надо по сути дела объяснить, как такую f посчитать, имея перечислитель.
Ну смотрите, а не пусто, значит в этом а что-то есть, правильно? Существует какое-то такое а малое, которое принадлежит а.
Но если оно принадлежит а, то перечислитель, как обычно считаем, что а красивое перечисляет а.
Следовательно, существует какой-то шаг. Существует шаг k, такое что а, ну даже просто, существует число k, что а красивое выведет а малое на шаге k.
Правильно? Ну это неправильно. А не пустое, значит перечислитель выведет хотя бы одно число, согласны?
Правильно. Какое-то число будет выведено самым первым. По принципу наименьшего числа можно найти наименьший шаг, на котором будет что-то выведено.
Тогда, значит, пускай наименьший шаг, когда что-то выведено самым первым.
То есть мы хотим зафиксировать самый первый шаг, когда что-то выводится, и само это выводим в выведенное значение, согласны?
Имеем право так сделать. А теперь давайте определим функцию f. Мы ее определим следующим образом. Неформально будет ясно, что она вычислима.
Пусть f от нуля это наша а0, то значение, которое вывелось первым. А вот для любого n f от n плюс 1 это будет знаете что?
Не, не максимум. Мы не будем сравнивать выведенные значения. Это будет последнее значение, последнее число, которое наш алгоритм перечислитель вывел за k плюс n плюс 1 шаг.
То есть как это работает? Смотрите, нам надо, чтобы функция была тотальной, правильно? Если уже в нуле должно быть какое-то значение.
Мы возьмем самое первое число, которое вывел наш перечислитель. А дальше мы что делаем? Мы для каждого следующего аргумента эмулируем вот столько шагов перечислителя, выполняем.
Правильно? На некоторых шагах возникают новые числа, мы их выводим. А если на шаге k плюс n плюс 1 ничего не вывелось, что мы возвращаем? Мы возвращаем прошлое значение, понятно?
То есть нам надо обеспечить тотальность этой функции. Как это работает? Зря стер утверждение 1.
Тогда полухарактеристическая вычислима. Для мной предшедших полухарактеристическая это как характеристическая. На множестве она дает 1, а вот вне множества она не определена.
Значит, ну что можно сказать о такой функции? Очевидно, что эв вычислима. Вот по сути дела алгоритм, как ее считать. Очевидно ли, что все, что она выводит, это элементы А?
Очевидно, потому что все, что она выводит, напечатал перечислитель. Наиболее тонкий момент. Очевидно ли, что она выведет все те значения, которые перечислитель вывел?
Потому что каждое значение будет напечатано впервые на каком-то шаге с номером большим или равным k, потому что k это первый шаг, когда что-то будет напечатано.
Каждое значение в какой-то момент будет последним напечатано. Оно будет выведено. Как это происходит? Как мы функцию f определяем?
Вот если у нас шаги, если у нас тут шаги, смотрите, вот как работает перечислитель. Он на некоторых шагах что-то выводит.
Вот впервые он на шаге k выводит а0. Потом он еще что-то выводит, еще что-то, еще что-то, еще что-то. Согласны?
Но мы не можем допускать пустых промежутков. Значит, как наша функция устроена?
Во-первых, у нас f от 0 это то, что выведено на шаге k. А дальше мы ее вот так вот дополняем.
Понятная идея? Делаем тотальный. Согласны? Вот как это работает.
Итак, любое непустое перечислимое множество это область значений вычислимой функции. Согласны? Можно стирать? Вычислимый даже тотальный.
И последняя. А перечислимо? Ну, а имеет какую-то размерность там k.
Ну, для простоты можно считать, что, ну давайте, а состоит из наборов длины k. А перечислимо тогда и только тогда, когда существует b на единицу больше размерности.
Такое, что b разрешимо. И наша a это что такое? Ну, это проекция b. Ну, как это обозначить? У нас была проекция на одну координату, но проекция на первый k координат вас не шокирует?
Не понятно, что это такое? Как бы нам это обозначить? Ну, вот проекция на координаты с первой по кату. То есть это первый k координат пары с b, да?
Что? Размерность n? В степени k плюс 1. На единицу больше. Давайте только k мы переименуем в другую букву лучше, t. k я использую для другой цели.
Ну вот, то есть что это такое? Это все такие наборы длины k, что существует y такое, что набор x, y попадает в b. Понятно, что такое проекция? Ну, первые там t координат. Согласны?
Итак, каждое перечислимое множество это проекция разрешимого множества на единицу больше размерности.
Доказательства. Ну, в одну сторону на самом деле мы это проходили, мы понимаем, что если b разрешимо, то тогда b, конечно, перечислимо. Согласны?
А проекция перечислимого любая, что на одну координату, что на несколько, она перечислима. Согласны? Поэтому справа налево, справа налево утверждение очевидное. Согласны?
Ну почему? Ну если я могу перечислять набор длины t плюс один, я запускаю перечислялку, но печатаю только первый t координат. Это будет причисление а, правильно?
А вот другую сторону чуть менее тривиально. Тут надо заняться таким делом, как подсчет шагов. Смотрите, значит нам дано, что а перечислимо.
Что это значит? Значит, что существует алгоритма красивая, который перечисляет а. Согласны?
А теперь я множество b определю следующим образом. Что такое b? b это все такие пары x, k. Размерность, ясное дело, на единицу больше размерности x.
Это все такие пары, что а выводит x на шаге номер k.
Смотрим, когда у нас x попадает ва? Ну тогда и только тогда, когда для некоторого k а выводит x на шаге k, правильно? Это из определений перечислителя.
Но то есть и получается, что тогда и только тогда, когда существует такое k, что пара x, k попадает в наше b. Согласны?
Итак, а действительно проекция нашего b. Только почему b разрешима? Тут такой неформальный аргумент, интересное свойство алгоритмов. Я эту мысль разовью сейчас.
Почему b разрешима? Ну смотрите, но мы верим, что алгоритмы можно эмулировать, можно исполнять по шагам. Я могу как мне проверить принадлежит ли пара x, k множеству b?
Надо запустить перечислитель на k шагов и посмотреть, вывел он x или не вывел. Понятно, что эту саму процедуру можно сделать за конечно много шагов.
То есть, что такое разрешимость? Это перечислимость с подсказкой. Перечислимость – это кванторсуществование. Существует номер шага, на котором будет выведена.
А разрешимость возникает, когда мы указываем номер этого шага. Если подсказка есть, мы можем k шагов прокрутить и за конечное время посмотреть, выводит или нет. Понятно?
Итак, каждая перечислимая множество – это проекция разрешимого множества некоторого на единицу больше размерности.
Так, а теперь давайте соберем все это вместе. Можно стирать?
Теорема 4. Эквивалентное определение перечислимости.
Для любого множества, ну неважно принадлежащего там n, то пусть будет n в степени t.
Для любого а следующие свойства равносильны. Первое свойство – а перечислимо.
Второе свойство – существует вычислимая функция f частичная. Такая, что наша a – это домен f.
Вычислимые множества – это в точности области определения вычислимых функций. Область определения вычислимой функции всегда перечислима.
И обратно, если а перечислима, то такая функция есть. Какую можно взять? Мы доказывали, что полухарактеристическая будет обладать таким свойством. Согласны?
Так, это у нас утверждение 1. Что дальше? Третье свойство – если а перечислимо, то существует вычислимая, внимание, тотальная f.
Давайте так. Тогда если а не пусто, то существует вычислимая тотальная f, такая, что а – это ее область значений. Ну это откуда? Это утверждение 2, правильно?
Четвертое. Существует вычислимая, но не обязательно тотальная функция f, такая, что а – это ее рейндж. Ну почему? В одну сторону.
Но из третьего следует четвертое. Если а не пустое, то в качестве вычислимой функции f можно взять вычислимую тотальную. Если а пустое, то она будет рейнджем какой вычислимой функции?
Нигде неопределенной функции. Давайте сразу ее заведем. Вот функция дзета. Нигде неопределенная функция, нигде неопределенная функция.
Этот дзета вычислимо. Согласны? Вы все писали алгоритм, вычисляющий дзету? Он принимает любой вход произвольный, зацикливается. Писали алгоритм для дзета?
Нигде неопределенная функция, она имеется. Если а пустое, то она будет рейнджем нигде неопределенной. Понятно?
И пятое свойство. Оно, как мы знаем, по утверждению 3, эквивалентной перечислимости.
Кстати, а почему, если существует вычислимая функция такая, что а является ее рейнджем, то а перечислимо?
Ну потому что рейндж вычислимой функции перечислим, правильно? То есть в эту сторону последствию ноль. Понятно?
И пятое свойство эквивалентной перечислимости. Существует b на единицу больше размерности.
Такое, что b разрешима, и наша a это проекция b, ну, например, на первый t координат.
Понятно? Все переходы обоснованы, или есть сомнения какие-то? Какие сомнения?
Итак, какие же свойства эквивалентной перечислимости? Перечислимое множество – это то же самое, что области определения вычислимых функций.
Это то же самое, что области значения вычислимых функций. Не пустые перечислимые множества, это то же самое, что области значений вычислимых тотальных функций.
Перечислимое множество это то же самое, что проекция разрешимых множеств на единицу большей размерности.
Понятно? Вот такая теорема.
А теперь пойдем далее, и сейчас мы введем некоторые новые понятия.
Одно из них будет ухватывать ту идею, которую мы использовали здесь.
Помните, когда мы исполняли алгоритм на к шагов?
И не только здесь.
Определение.
Пусть АА какой-либо алгоритм. Ну, такое слегка неформальное определение.
Мы можем ввести так называемый Т-предикат.
Т от А. Что такое Т-предикат?
Т-предикат говорит нам, ТХК говорит, что алгоритм А на входе Х останавливается за к шагов.
Понятно?
И другой вариант Т-предиката. Ну, можно считать, что Х это набор, можно считать, что это число, это неважно.
И другой вариант Т-предиката.
ХYК. Что это означает?
Алгоритм А на входе Х останавливается за к шагов, включаем интуицию, причем здесь Y.
Да, и выводит Y.
Понятно, что за Т-предиката?
Так вот, мы от нашей модели алгоритмов, от того, что такое алгоритм, от возможных уточнений этого понятия или из нашей интуиции,
мы требуем такое свойство алгоритмов своего рода аксиому.
Такие Т-предикаты разрешимы.
Понятно, что значит разрешимы?
За конечное число шагов можно по каждой паре или, соответственно, тройке узнать, верно для нее это или нет.
Вот это свойство алгоритмов, на которые мы опираемся.
Всегда можно за конечное число шагов проверить, правда ли, что алгоритм А на входе Х останавливается за к шагов, по входу ХК.
Также можно по входу ХК узнать, правда ли, что он остановился за к шагов на входе Х и выдал Y.
Понятно это?
Вся наша наука основана на том, что эти свойства разрешимы.
Ясен этот момент?
Поехали дальше.
На самом деле я еще одну теорему пропустил, к сожалению.
Ее следовало бы рассказать в прошлый раз, но я просто забыл.
Значит, это так называемая теорема Поста.
Она очень проста.
Тем не менее давайте ее отметим.
А разрешима тогда и только тогда, когда А и его дополнение перечислимы.
Оказывается, нам еще такая теорема нужна.
Она больше относится к прошлой лекции, но в одну сторону.
Если А разрешима, то, конечно, и А и его дополнение разрешимы.
Помним, что дополнение разрешимого разрешима?
Надо узнать принадлежит ли ХА и обратить ответ.
Ноль в единице, единицу в ноль.
Нормально?
Так, ну а если они разрешимы, то каждое разрешимое множество оно также перечислимо.
Справедливо?
В другую сторону чуть труднее.
Значит, как мы делаем?
Нам нужно разрешитель придумать для А.
Вот у нас есть какой-то вход N.
Что мы будем делать?
Поочередно делаем шаги.
А красивого и чего?
И А красивого штрих.
Где что это такое?
Пусть А красивое перечисляет А,
и А красивое штрих перечисляет А с чертой.
Правильно?
Если А красивое вывел N, то что?
Возвращаем единицу, значит мы попали в А.
Не понятно?
Нет, не понятно.
Если А красивое со штрихом вывел N,
то возвращаем ноль.
Как это работает?
Ну смотрите, ведь у нас любое N точно принадлежит либо А, либо А с чертой.
Правильно?
Значит, либо один, либо другой перечислитель его обязательно напечатает.
Мы перечисляем множество и дополнение параллельно.
Шаг в перечислении множества, шаг в перечислении дополнения.
За конечное число шагов N появится в выводе того или другого перечислителя.
Согласны?
И нам остается только заметить в выводе какого из них оно появится.
Понятно теорема Поста?
Она показывает довольно простую мысль.
Перечислимость это половинка разрешимости.
Поэтому ее часто называют полуразрешимостью.
И там же, как видите, живет полухарактеристическая функция.
Разрешимость эквивалентна перечислимости множества и его дополнения.
Понятно?
А теперь давайте двинемся немножко дальше.
Сейчас мы опять обратимся к нашей интуиции или, если угодно, к эксиумам каким-то,
или, если угодно, к свойствам нашего конкретного языка программирования.
Сейчас мы поговорим о такой вещи как универсальный алгоритм.
Ну хорошо.
Возьмем ваш любимый язык программирования.
Какой?
Плюсы. Но мне не нравится там компилятор.
Пусть будет питон.
Питон – интерпретируемый язык.
Как он работает?
Дело в том, что там есть интерпретатор.
Правильно?
Вы ему подаете на вход какую-то программу и, возможно, какие-то аргументы этой программы.
Согласны?
Обратите внимание, все алгоритмы, которые вы пишете на питоне, вы выполняете более или менее так.
То есть, по сути дела, ваш код является аргументом, является входом.
Для чего?
Для некоторого универсального алгоритма.
То есть, можно рассматривать вашу программу как аргумент другого алгоритма.
Более того, мы верим, что любую программу, которую можно реализовать на питоне, можно таким образом выполнить.
Мы верим, что каждую вычислимую функцию можно вычислить и на питоне.
Это вариант того, что называется тезис Тьюринга.
Любую вычислимую функцию можно вычислить конкретно фиксированной модели вычислений.
Но вот тезис питона – любую вычислимую функцию можно вычислить на питоне.
Доказать это нельзя.
Потому что непонятно, что такое вычислимая функция.
Если вы уточните это понятие, то возникнут теоремы, что один язык программирования эквивалентен другому.
Например, все, что можно вычислить на Си, можно вычислить на Питоне, и наоборот.
Все, что можно вычислить на машинах тюринга, можно вычислить там в безтипу, в лямбдоисчислении или еще какую-нибудь модель можно взять.
Понятна идея?
То есть, фактически, если понятие вычислимость и уточнять, оно превратится в вычислимость в каком-то конкретном языке программирования.
Во всех наших рассуждениях мы язык не фиксировали, а рассуждали о нем довольно расплывчато.
Тем не менее, языки, которые существуют на практике, наводят нас на мысль о том, что существует универсальный алгоритм.
Где у нас, который по сути дела принимает два аргумента.
Программу и вход этой самой программы.
Ну и программу типа исполняет. Понятно?
То есть, он делает то же самое, что делала бы программа.
Вот эта вот команда, как мы понимаем, она эквивалентна такой.
Этот алгоритм, по сути, делает то, что делает эта программа.
На самом деле, вот эта штука реализована через это.
Понятно вообще, о чем я вещаю? Вы же программисты.
Так, хорошо.
Теперь давайте внимательно посмотрим на эту программу.
В случае питона, что это такое?
Это конечный набор чего?
Байтов.
Это какое-то конечное слово, правильно?
Конечное слово в конечном алфавите.
Мы его можем закодировать натуральным числом.
Согласны?
Не каждая последовательность байтов является программой на питоне.
Сколько корректных программ на питоне?
Ровно счетно много, легко доказать.
Не более чем счетные, можно построить не менее чем счетно корректных программ.
Правильно?
Вот.
То есть по сути дела, можно программы это же действительно натуральными числами.
Понятно это?
И при этом мы надеемся, что каждая вычислимая функция вычисляется некоторой программой.
Понятно?
Все эти соображения подводит нас к следующему определению.
Функция У.
Это частичная функция двух натуральных аргументов.
Это пока не алгоритм, а функция.
Называется универсальной вычислимой функцией.
Ну в классе функции одного натурального аргумента, но я не буду уточнять.
Называется универсальной вычислимой функцией.
Универсальной вычислимой функцией.
Сокращенно УВФ.
Я постоянно буду использовать это обозначение.
Она называется универсальной вычислимой функцией тогда и только тогда, когда обладает следующими свойствами.
Вот универсальная вычислимая функция не похожа на морскую свинку.
Морская свинка не имеет отношения ни к свине, ни к морю.
А вот универсальная вычислимая функция вычислима.
И универсальна.
Ну а что значит универсальна?
Универсальна значит, что она реализует каждую вычислимую функцию одного аргумента.
Давайте запомним это, поймем и запомним.
Для любой вычислимой Ф, для любой вычислимой функции одного аргумента, существует что?
Существует программа, но в нашем языке программирования у нас программы это сразу натуральные числа.
Существует такая программа, что?
Для любого х то, что функция у вычисляет на входе нх, совпадает с тем, что функция Ф вычислила бы на входе просто х.
То есть каждую функцию можно, по сути дела, заменить на подстановку некоторого специального аргумента у.
У умеет считать все вычислимые функции.
Для каждой вычислимой функции можно дать соответствующий аргумент.
Неформально это соответствует тому, что число n это программа для функции Ф.
Язык программирования у универсален, но есть его, для него есть такая функция.
Если для любого Ф существует n. Понятно?
Ну мы же об этом говорили, но вы пропустили.
Это, как мы это понимаем, вот если у нас есть два выражения, которые могут быть неопределены.
Это означает две вещи. Оба неопределены или оба определены и равны.
Например, один разделить на ноль совпадает с два разделить на ноль, то и другое неопределено. Понятно?
Я использую это обобщение вместо равенства, потому что они могут быть и неопределены.
Понятно это? Вот это вот n имеет специальное название.
Н называется индексом, индексом или номером, или номером функции Ф относительно у.
Содержательно же это программа для функции Ф, понимаемая как натуральное число. Понятно?
Какой вопрос?
Еще немного терминология.
Пусть у нас В какая-нибудь функция двух аргументов.
Для любого n определим функцию Вn. Это будет функция одного аргумента. Как она определяется?
Она определяется вот таким вот уравнением.
Вn от х понимается как В от n от х. То есть мы первый аргумент фиксируем. Вы не шокированы?
У вас на мотоне такое было?
Вn называется n-тым сечением, n-тым сечением В, ну по первому аргументу, по первому аргументу.
Понятно, что такое n-тый сечение? Функция одного аргумента, когда мы значение фиксируем.
Почему сечение? Ну вот у нас n-ки, вот у нас x-ы.
Вот как бы график функции В, да, такая типа поверхность, может быть с дырками, потому что она не всюду определена.
Ну вот если мы значение n зафиксируем равным чему-то, что у нас получится?
Ну вот у нас получается такой, что мы этот торт разрезали. Вот тут вот.
Параллельно оси в точке н-ноль, понятно? На срезе получилось сечение.
Ясно это? Очень наглядное понятие.
В терминах сечений вот это как будет выглядеть требование универсальности?
Что функция n-тый сечение у равна функции f?
То есть что такое универсальная функция, которая среди своих сечений содержит все вычислимые функции?
Меньшего числа аргумента, в данном случае одного. Понятно?
Обратите внимание, здесь стоит не совпадение, а равенство.
Все помните, первый семестр две частичные функции равны тогда и только тогда, когда их значения совпадают во всех точках.
Понятно это?
Что мы утверждаем о универсальной вычислимой функции?
Об универсальной вычислимой функции мы утверждаем то, что она есть.
В конкретном языке программирования это теорема.
Надо универсальный алгоритм построить, то есть написать на питоне интерпретатор питона.
А что вы сомневаетесь в том, что это можно сделать?
Очень даже, но компилятор c написан же на c и ничего.
Написан ли реально используем интерпретатор питона на питоне, я сомневаюсь.
В принципе это можно сделать.
Итак, то свойство алгоритма, в котором мы будем пользоваться, такое.
Существует хотя бы одна универсальная вычислимая функция у.
Можно.
И что?
Но его можно с нуля написать.
Итак, в нашей теории мы верим, что универсальная вычислимая функция существует.
Этому нас учит практика, потому что функция, которая вычисляет программы питона,
это более или менее есть универсальная универсальная функция.
По модулю незначительных отличий, что на питоне не каждое натуральное число это программа.
Ну, можно сказать и так.
Это свойство алгоритмов, свойство модели.
Но мы не можем сейчас это доказать.
Для этого надо уточнить понятие алгоритма.
Итак, какая существует?
Давайте сразу ковать железо пока горячо и зафиксируем какой-нибудь алгоритм, который вычисляет эту у.
Но если она вычислима, есть же вычисляющий алгоритм.
Пусть у красивая, это некоторый алгоритм, вычисляющий у.
Теперь мы введем t-предикаты.
Там были t-предикаты для какого-то алгоритма, а сейчас мы введем t-предикаты для, по сути дела, этого у.
Просто t от n от x от k.
Что это такое?
Ну, это t-предиката от u для входа n, x и k.
Понятно, что имеется в виду?
То есть это свойство, которое говорит, что у красивая останавливается за k шагов на входе n, x.
И вот такая бяка разрешима, как и всякий t-предикат.
Мы можем запустить универсальный алгоритм на входе n, x на k шагов и посмотреть, остановился он или нет.
Понятно это?
Аналогично t-штрих от n, x, y, k.
Что это такое?
Это t-предикат со штрихом для нашего у.
То есть имеется в виду что?
Что у красивая остановится за k шагов на входе n, x и выдаст y.
Согласны?
Оба свойства разрешим.
Сейчас мы прямо не будем этим пользоваться, но давайте себя заметим.
Понятно это?
Мы зафиксировали uvf и связали с ней 2t-предиката.
Даже зафиксировали не просто сам uvf, но и некий алгоритм ее вычисляющий.
В принципе, их может быть много.
Понятно?
Вы не шокированы?
Знаменитая проблема остановки.
Сейчас мы явно построим пример неразрешимого множества.
В прошлый раз мы говорили, что такое множество существует, потому что всего под множеством натурального ряда континум.
А разрешимых множеств лишь счетно много, потому что счетно много алгоритмов.
А сейчас мы приведем явный пример.
На этой конструкции держатся многие-многие-многие другие.
Определение.
Вот здесь и далее u будет какая-то uvf.
Какая неважна?
Какая-то.
Пусть u это uvf.
Положим k, ну можно считать с индексом u.
Иногда будем писать, иногда не будем.
Что такое k с индексом u?
Это просто все те и только те натуральные числа, что u от nn определена.
Как вам такое?
Ну индексу я не буду писать.
k с индексом u.
Аналогично, s это все такие пары натуральных чисел, что u от n от x определена.
Батюшки, что это такое?
Что такое s?
Домен функции u.
Согласны?
Непонятно это?
Все такие пары программа-аргумент, где программа останавливается на аргументе.
Еще мы введем функцию d.
Функция d задается таким уравнением.
d от x это u от xx.
Как вам такая функция?
d называется диагональю uvf.
Согласны?
Слушайте, а что такое k?
Это же домен функции d.
Справедливо?
Итак, с функцией u мы связали функцию d и два множества.
k домен d и s домен u.
Согласны?
Вы не шокированы?
Давайте сделаем наблюдение.
Замечания.
Так как у нас u вычислимая функция, правильно?
Тогда s, который является ее доменом, какое множество?
Перечислимо.
Домен вычислимой функции перечислим. Согласны?
Был такое?
Так, вы согласны, что функция d является вычислимой?
Ну, это видно из этого уравнения.
Согласны?
Ну, а если она вычислима, то ее домен k...
ее домен k обязательно перечислим.
Итак, множество k и s перечислимо. Согласны?
Какая у нас была прошлая теорема? 5, что ли?
Теорема Поста.
Теорема 6.
Неразрешимость проблемы самоприменимости.
Множество k неразрешимо.
Множество k неразрешимо.
Заметьте, но перечислимо.
Согласны?
Вот перечислимо неразрешимое множество.
Мы доказываем, что перечислимость отличается от разрешимости.
Как мы рассуждаем от противного?
Допустим, k все-таки разрешимо.
Давайте рассмотрим некую функцию.
Назовем ее f.
Наша функция устроена следующим образом.
Она возвращает единицу, если n не принадлежит k.
И она не определена, если n принадлежит k. Что это такое?
На самом деле это полухарактеристическая функция дополнения k.
Согласны?
Я утверждаю, что f вычислимо.
Но почему?
Ну, можно формально. Если k разрешимо, то дополнение k разрешимо.
Если k разрешимо, значит дополнение k перечислимо,
значит его полухарактеристически вычислимо.
На пальцах.
Ну как вычислить f? Нам дали на вход n.
У нас по предположению k разрешимо. Правильно?
Проверим n на принадлежность k.
Если ответ нет, выдаем 1.
Если ответ да, мы всегда можем искусственно зациклиться.
Это понятно? Поднимите руку, кому ясно, что f вычислимо.
Не всем. Кому не ясно, почему.
Еще раз на пальцах. Как посчитать a, f от n?
У нас k множество разрешимостей.
Значит за конечное время можно алгоритмом любой n проверить на принадлежность k.
Проверяем. Если ответ нет, выдаем единицу останов.
Если ответ да, входим в бесконечный цикл wild true.
Непонятно? Все равно непонятно?
Еще один аргумент. Но что можно сделать?
А ну нет, это не очень хорошо.
Ладно, ну что, понятно?
Но смотрите, раз эта функция вычислимая, а у универсальная, это же что означает?
Значит существует такое число, ну допустим n 0 или давайте m.
Существует такое число m, что наше f это mt, сечение u, правильно?
Или другими словами, существует такое m, что для любого x, f от x совпадает su от m от x.
Согласны?
Но это для любого x верно. В частности...
В частности мы можем посмотреть, что такое f от m. Что такое f от m?
Вот f от m.
Вот f от m, или что то же самое, d от m. Согласны?
Вопрос, принадлежит ли m множеству k?
Ну либо принадлежит, либо нет.
Так, допустим m принадлежит множеству k.
Тогда вот по этому определению f от m не определена. Согласны?
Но f от m совпадает su от m от m. Следовательно, u от m от m не определена.
Следовательно, m не принадлежит k.
Противоречие. Значит, не может так быть, чтобы m принадлежало k.
Значит, m не принадлежит k.
Предположим, m не принадлежит k.
Так, тогда опять же по определению у нас f от m равно единицей, в частности, определено. Согласны?
Значит, что получается? Получается, что u от m от m тоже определено. Согласны?
Получается, что m таки принадлежит k. Опять противоречие.
То есть, m не может ни принадлежать ни не принадлежать k.
Мы вывели противоречие, допустим, что k разрешимо. Значит, k неразрешимо. Понятно?
То есть, что мы сделали? Мы запросили, принадлежит ли nk, и сделали наоборот.
Принципиально здесь мы узнали, что n не принадлежит k за конечное время, выдали единицу. Понятно это?
Итак, множество k является неразрешимым, но перечислимым.
Следствие 7. Множество дополнения k неперечислимо.
Это пример неперечислимого множества. Почему?
Ну, потому что если оно перечислимо, то тогда у нас и k, и его дополнение перечислимо. Согласны?
Мы же знаем, что k перечислимо.
Значит, по теореме Поста, по теореме Поста тогда k было бы разрешимо. Что не так? Согласны?
Согласны? Итак, дополнение k – это конкретный пример неперечислимого множества. Согласны?
Понятно это? Следствие 8. Неразрешимость проблемы остановки.
Что такое проблема остановки? Проблема остановки неформально звучит так.
Надо по программе и по ее входу узнать, остановится ли эта программа на входе или нет.
Придумать алгоритм, который за конечное число шагов бы это узнавал для любой пары, программа-вход, ключевые слова, для любой пары, один алгоритм.
Такого алгоритма быть не может, что в нашей теории выражается как то, что s – неразрешимо.
Нельзя по входу программа и ее вход алгоритмически проверить, остановится она или нет, то есть определена у от n от x или нет.
Множество s неразрешимо. Ну как это доказать?
Здесь мы впервые увидим так называемое сведение, тоже очень распространенная естественная идея.
Смотрите, давайте посмотрим на определение множества k и сравним его с определением множества s.
Вы согласны, что n принадлежит k тогда и только тогда, когда пара nn принадлежит s?
Таким образом, что я вижу? Я вижу, что характеристическая функция k, она равна характеристической функции s на входе nn.
Поэтому если х и s вычислимо, то тогда и х и k вычислимо, то есть тогда было бы k разрешимо. Что не так? Понятно?
Ну если бы я умел любую пару проверять на принадлежность s, я мог бы любое число проверить на принадлежность k. Как?
Взять входное число, изготовить из него пару nn и спросите, принадлежит ли она s. Понятно? Вы не шокированы?
Нормально? Вот неразрешимость проблемы остановки. Ещё несколько замечаний.
Оказывается, любая вычислимая функция хоть где-нибудь, но совпадает с диагональю. С d.
Это принципиальный момент. Он позволяет доказывать невычислимость функций. Если какая-то функция всюду отличается от диагонали, то она точно невычислима.
Давайте это докажем. Лемма 9 или какая там лемма? Лемма 9. Пусть у f, как обычно.
Тогда если функция f, если функция вычислима, то обязательно существует такое натуральное число, где она совпадает с функцией d.
Может быть они обе не определены, но всюду отличаться от d она не может. Доказательство этого крайне полезного утверждения буквально однострочное.
Значит, как это сделать? Ну раз f вычислима, а у это uvf, то существует такое n, что для любого x у от n от x совпадает с f от x. Согласны?
Согласны? Ну подставим сюда вместо x и n. Что получится? Значит, существует такое n, что у от n от n совпадает с f от n. Ну что такое у от n от n?
Это d от n есть. Согласны? Итак, никакая вычислимая функция не может всюду отличаться от d.
Давайте представим себе какую-нибудь функцию частичную. Вот она где-то определена, а где-то нет. Согласны? Но мы можем в принципе функцию продолжить.
Это что значит? Это значит доопределить ее на некоторых точках, где она раньше не была определена. Не обязательно на всех. Понятно?
В таком случае мы говорим, что функция g продолжает f. Это что значит? Ну просто график f включен в график g. Не более того. Понятная идея?
Лемма 10. Функция d не имеет вычислимого тотального продолжения. Вот это вот может быть странное свойство, но оно естественное. Не имеет вычислимого тотального продолжения.
Мало того, что она сама не везде определена. Ее даже нельзя так доопределить, чтобы получилась вычислимая функция.
Сейчас, минутку. То есть, если g продолжает d и g тотально, то g не вычислима.
Любая функция, которая продолжала бы d, вот представьте себе, что у нас вот есть d, она где-то определена, где-то нет. Предположим, мы ее доопределили на всех точках каким-то образом.
При этом не может получиться вычислимая функция. Понятная идея? Доказательства очень простые.
Допустим, что g действительно продолжает d, а g тотально. Выопределена во всех точках. Давайте рассмотрим такую функцию. Рассмотрим h. Она тоже будет тотальна. h задается следующим уравнением.
h от x. Заметьте, я пишу равенство, потому что функции здесь всюду определенные. h от x это g от x плюс 1. Как вам такое?
Рассмотрели функцию h? Я утверждаю, что функция h всюду отличается от d, а значит не вычислима. Доказательства.
Вы согласны, что каждое число либо принадлежит домену d, либо нет? Если оно принадлежит домену d, чему у нас равно d от x?
d от x равно g от x. Почему? Потому что g это продолжение d. Где d определена, они совпадают. Согласны? d равно g от x. Но g от x не может быть равно g от x плюс 1.
Значит d от x и h от x различны. Они не совпадают. В точках, где d определена, они отличаются друг от друга. Согласны?
А что будет, если x не принадлежит домену d? Но все довольно просто. d от x, ведь она будет не определена в таком случае.
А h от x, чему бы она не была равна, но она же всюду определена, она будет определена. То есть они точно не совпадают.
Что же мы видим? Мы видим, что для любого x h от x отличается от d от x. Отсюда следует, что h не вычислимо. Согласны?
Но с другой стороны, если бы g была вычислима, то и h была бы вычислима. Если g вычислима, то тогда и h вычислима.
Вывод. g не вычислима. Итак, функцию d нельзя даже определить таким образом, чтобы она сделалась тотальной, но сохранила вычислимость. Согласны?
Ну и самое последнее. Вот прям самое последнее. Мы на семинаре это используем.
Лемма 11. Существует вычислимая функция f, внимание, она из натуральных, но она принимает только два значения, 0 единица.
Существует вычислимая функция f, принимающая только два значения, такая, что у f нет вычислимого тотального продолжения.
Существует такая функция, которую нельзя продолжить до вычислимы тотальной, при том, что она принимает только два значения. Согласны?
Сейчас мы ее построим, и все. И гулять пойдем. Она устроена следующим образом. Вот смотрите, если d от x определена и равна 0, мы вернем что?
1 мы хотим отличаться от d. Если d от x определена и d от x не равна 0, мы вернем 0. Если d от x не определена, мы вернем неопр.
Почему эта функция вычислема? Это очень просто понять, каким же образом. А вот каким f от x это 1 минус d от x.
Ну смотрите, если d от x определена, ну только не 1, а там 1 минус 5. Давайте так, усеченное вычитание. Понятно, что такое усеченное вычитание?
Ничего не понятно. Усеченное вычитание это максимум из нуля и разности. Ну, например, 5 минус 2 это 3, а 5 минус 6 это 0. Понятно?
Ну то есть как оно работает? Если d от x это 0, мы возвращаем 1. Если это 1 и больше, мы возвращаем 0. А если d от x не определена, ну это выражение не определено.
То есть функция вычислимая, согласна? Почему у нее нет вычислимого тотального продолжения? Ну если оно есть, то тогда оно всюду будет отличаться от d.
Я так конспективно напишу, без подробностей. Если g это продолжение d и g тотально, то g всюду отличается от d.
Следовательно, g не вычислимо. Ну почему она всюду отличается от d? Ну там, где d не определена, там g определена, потому что она тотально, значит, отличается от d.
А там, где d определена, там g принимает то же значение, что и f. Ведь домен нашей функции f равен домену d, правильно?
Она определена всюду, где d, но на домене она отличается от d. Она и на домене, и вне домена отличается от d, значит g отличается от d. Значит, она не вычислима. Понятно?
Мы построили пример вычислимой функции, принимающей только значение 0,1, которую нельзя продолжить до тотальной вычислимой.
Этот пример мы используем на семинаре для важной конструкции, являющейся усилением теоремы о том, что существует перечислимое неразрешимое множество.
Теорема о неразрешимости, проблемы с самоприменимостью, ну или проблемы остановки, вопросы?
Ну уже мысленно на следующей лекции. Я понимаю. Спасибо за внимание. До свидания.
