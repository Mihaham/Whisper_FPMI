Прошлый семинар прошел по такому сценарию.
Мы сначала обсудили какие-то вопросы, накопившиеся по
домашним задачам.
Что мы там делаем, почему мы делаем именно так.
А второй половины мы начали говорить про тестирование.
У меня есть план рассказать вам, как устроено тестирование
в нашем курсе, как устроено вообще тестирование подобных
вещей, которые мы пишем.
Мы еще хотели про стег договорить, да, это правда.
Начнем с этого, потом поговорим про вопросы, которые у нас
в задачах есть, и отдельный топик, который мы, наверное,
сегодня не успеем разобрать, если все пойдет хорошо.
Это тестирование про санитайзеры, про fault injection, про все
механики, которые в нашем курсе используются, потому
что мне кажется, что без этого писать сложный конкурентный
код хорошего качества, надежный, невозможно.
И вообще, тестирование это то, о чем нужно подумать.
Если мы говорим про большие и сложные проекты, то тестирование
это то, о чем нужно подумать в самом начале, потому что
иначе потом будет уже поздно.
Ну что, давайте с чего-то начнем, и начнем, вы говорите
начнем со стеков, которые мы разбирали в прошлый раз.
Ну хорошо, тогда мы переместимся сейчас на экран, на доску,
чтобы у файмеров стеки не качались, и мы столкнулись
с тем, что совершенно наивно действовать нельзя, потому
что, может быть, совершенно, давайте по порядку, стеки
не могут переполняться.
Мы полоцируем как файмер стеков с фиксированного
размера.
Он может, разумеется, закончиться, но я не знаю почему.
Не только потому, что он бесконечная реку, а потому,
что мы пишем в использовании какие-то очень большие и
сложные библиотеки, в которых огромное количество
различных вызовов, аргументов, и вот стек наш переполнился.
Первое, о чем мы должны позаботиться, это о том, чтобы программа
от этого, наоборот, упал, можно быстрее, потому что
программа, которая не работает, не может сделать ничего
плохого.
Программа, которая работает, она неправильная, может
навредить.
Поэтому первое, что мы сделали в прошлый раз, сказали,
что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной
подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
И мы сделали, что у нас есть фамилия с будинной подстек.
Хорошая практика.
Хорошая практика.
Пожалуйста, следуйте игре.
Пожалуйста, следуйте игре.
Пожалуйста, следуйте игре.
Если этой страницы guard page не будет, она называется,
Если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
если этой страницы guard page не будет, она называется,
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
ну и первая наивная попытка состояла в том,
что мы пытались выделить новую память под stack
есть две проблемы
первая проблема стоит в том,
что вот у вас в программе есть
какие внутренние ссылки
у вас на stack лежит какая-то
вы написали функцию,
в ней ваша переменная
его ссылка идет перед революционной функцией
его ссылка идет перед революционной функцией
теперь у вас где-то на stack есть ящик памяти,
которая следует надо из любой ящики на stack
теперь у вас где-то на stack есть ящик памяти,
которая следует надо из любой ящики на stack
если вы просто скопируете память,
если вы просто скопируете память,
если вы просто скопируете память,
как вот на CBI,
то вы получите, что на этом stack
то вы получите, что на этом stack
давайте слайдить вот сюда
неприятная история
давайте подумаем,
как можно было бы эту проблему разрешить
давайте даже не будем думать,
как ее разрешить
потому что одна проблема есть
и, может быть, нужно делать и не так, и не так,
а каким-то третьим способом
вот третий способ состоит в том,
что давайте я, к сожалению, вернусь
я не буду опускать проект,
чтобы нам не было выпить
долго
не работает, да?
работает
ну давайте я так покажу
есть альтернативный подход,
который состоит в том,
что мы перестаем считать stack непрерывным
то есть у нас stack заканчивается
и мы выделяем просто для stack
новый сегмент
мы не переносим память,
потому что тогда вот у нас поедут все ссылки
мы просто алоцируем новый сегмент stack
и живем на нем
ну, конечно же, так работать не будет,
потому что процессор-то он ожидает
непрерывного stack'а
он уже код скомпилировал,
а под ним вот внезапно stack меняется
поэтому так можно делать
это называется сегментированные stack'и
но так можно делать только если вы компилятор
то есть вы говорите компилятору,
что я хочу использовать сегментированные stack'и
и он в начале каждой функции
помещает специальный пролог
в котором что он делает
но он прикидывает сколько stack'а
компилятор же компилирует функцию
он знает, каков размер ее stack'ового фрейма
тут есть какие-то маргинальные исключения
типа динамическая локация на stack'е, функция лока
но, допустим, нормальные люди мы ее не зовем
поэтому мы знаем, каков размер наш stack'овый фрейм
мы записываем, где он должен кончиться
там в R10
а потом мы из thread-локальной переменной
мы сравниваем вот это значение
границы очередного stack'ового фрейма
с границей stack'а
и если оказывается, что нам не хватает
текущего stack'а
для того, чтобы выполнить текущий вызов функции
то мы вызываем служебную процедуру
локации нового сегмента stack'а
и как бы перепозиционируемся относительно него
вот эта проверка и перепозиционирование Rasp
разумеется может сделать только сам компилятор
но поэтому мы сообщаем флажком специальным
что мы собираемся алоцировать stack таким образом
наращивать его и назвать здесь stacklet
и вот происходит перепозиционирование в случае падания на границу
но это некоторый оверхед
то есть вы добавляете такую прологу каждую функцию
но если предположить, что stack будет переполнится нечасто
то это в конце концов одно сравнение с thread-локальной переменной
кажется, что это не очень дорого
но беда не в этом
вообще, решения рабочие так можно делать
так можно расширять stack'и
и так пытались делать
в го, кажется, пытались так делать
и в расти так пытались делать
но в зале времен в расти было еще совсем по-другому
но тем не менее
в ссылках к курсу есть
сейчас я найду ее
неожиданно у меня застались этими stack'ами
короткая статья с интересными ссылками на обсуждение
конкретное от одного из разработчиков языка Rast
и там он описывает такую трудность
почему сегментированные stack'и плохо подходят к такому
потому что у них совершенно непредсказуемая модель стоимости
вам очень сложно под них оптимизировать код
почему?
но представьте себе, что у вас есть какой-нибудь цикл
в котором очень много, очень часто вызывается какая-то функция
и вот
вызов этой функции выпадает на границу stack'ов
и нужно какие-то нетриальные действия совершать
было бы хорошо, если бы у вас был такой цикл
а теперь представим, что вы повлияли
вы пооптимизировали, чтобы такого не было у вас
а потом приходит новый сотрудник в вашу команду
и рефакторит код
и пишет какие-нибудь дополнительные вызовы функции
что-то там
что-то такое
что-то такое
что-то такое
какие-нибудь дополнительные вызовы функции
выделяет методы
и ваш stack немного сдвигается
и вот вы снова попадаете на эту границу
и это же контролировать совершенно невозможно
невозможно предсказать, потому что вот эти границы stack'ов
они в коде не заметны, они прозрачны
в итоге просто невозможно
учитывать вот этот overhead, невозможно на него влиять
невозможно его предсказывать при написании кода
так что такой подход существует, но от него в итоге
отказались
возвращаемся на доску
ну вот в Rust'е говорят, что
future в Rust'е — это вот такой
perfectly sized stack, что это значит, это отдельная история
мы однажды про это поговорим
где-то уже в апреле, наверное, не быстро
а пока
проблема
как проблему можно все-таки решить?
проблему можно решить в очень красивый способ
мне кажется, безумно красиво, но только если вы пишете свое загомирование
вот скажем, решить проблему на уровне блячечи трудно
а вот если вы пишете свой собственный год, то внезапно у вас появляются инструменты
и мне кажется, что сочетание идеи
и сочетание разных механик обезумительно
смотрите, первая проблема
вот есть такие ссылки
что мы могли бы делать, если бы написали за плюс-плюс?
ну, мы бы изобрели какую-то иллюмистику
мы бы пошли просто по 8 байтовым кусочкам
стака и смотрели
если содержимый кусочек похожего поэта
то есть вкладывается в диапазон
то, возможно, это ссылка на наш собственный stack
и нужно ее исправить подсюда
будет ли это работать?
точнее, и на пяток делаем
вот скажем, есть попытки написать сборщик мусора
за с плюс-плюс, слышали вы такое?
вы слышали, там нужно с чего начать?
там нужно открыть графобъект, искать живые объекты
а для того чтобы искать живые объекты
нужно с чего-то начать, с чего обычно начинают?
начинают с того, что называется gc-рус
чтобы попасть в какой-то объект, вы же в первую очередь
в первую очередь вращаетесь в какие-то перемены
локальные перемены, то есть все пути в кучу идут со stack
и вот если вы пишете сборщик мусора
то нужно понимать, какие ссылки со stack ведут
вот если вы пишете такой консервативный
бочек мусора, на с плюс-плюс даже
то вы используете такую рейстику, что это значение
памяти похоже на Пойнтер
вы увидите это Пойнтер
то сборщик мусора не безопасен, потому что вы рассматриваете
если на бурбайке Пойнтер, он куда-то ведет
и возможно в эту память не соберется
ничего плохого не случится
ну а здесь если мы перепутаем, то будет плохо
как помогает то, что мы пишем го
и это такое
го есть техническая сборка мусора
и сборщику мусора в го
нужно обходить граф объект
нужно создавать на stack
поэтому сборщику мусора в го нужно знать, какие
байки на stack играют с Пойнтером
для сборки мусора, для решения stack
поэтому для вашей горутины хранится bitmap
где для каждого кусочка 8 байков
хранится флажок, который является
кусочек на stack Poynter
и этот bitmap заполняется
условно копиатором
если он размещает этот Poynter на stack
то он заполняет флажок bitmap
и в итоге у нас в runtime есть
bitmap, который размечает
в котором размечен этот stack
так что го, какая проблема решена?
просто всего того, что го и сборка мусора
го мог бы найти вот такие ссылки
и корректно их переставить
но это не единственная проблема
потому что
это может быть даже и самая большая проблема
у нас есть одна горутина
а есть другая горутина
у нее тоже есть свой stack
и вот этот stack
на этом stack лежит Poynter
на наш stack
это уже совсем печально, потому что
если мы ссылки будем висеть в омлинайте
то чтобы найти такие ссылки
нужно вся горутина обойти
а их могут быть до света тысячи миллиона
задача абсолютно безнадежная
и решение еще более лопкое
чем с bitmap, который переиспользуется
из сборки мусора
решение такое
если вы знакомы с го, то вы знаете
вы знаете, что вы можете алоцировать
примерно на куче и на stack
вы не можете алоцировать объект на куче и на stack
потому что в языке нет понятия
в языке вы просто алоцируете объекты
а объект уместить решает как реактор
как он это делает?
он использует escape analysis
а в чем его запись?
вы знаете, его про сборку мусора что-нибудь
в частности про гипотезу похоронения
но гипотеза звучит так, что
чаще всего умирает молодой объект
высокая детская смертность программ
поэтому сборка мусора
обычно делится на два уровня
сборка мусора и алоцированных объектов
сборка мусора объекту прожили долго
если объект прожил достаточно долго
то он скорее всего долго еще и проживет
если он пережил детство, то он проживет долго
либо же он...
например, классический сборки мусора
используют две разных ставии
сначала объект алоцируется в этих язлях
если он пережил дни асфе, то он перемещается
в общем, дело живет надолго
потому что программа так и устроена
такого нет, потому что идея такая
если компьютер понимает
что объект не нужен
за пределами вызова функции
то он алоцируется у нас в теке
если же компьютер понимает, что pointer
и что адрес объекта алоцированного
если созданный внутри вызова функции
покидают эту функцию
и утекают в другую часть программы
то объект алоцируется на куче
это решает сам комператур
как можно получить ссылку с одного стека в другой
нужно чтобы pointer убежал
а если pointer убегает, то объект алоцируется на куче
итого, от них ссылок просто не бывает
ну и чуть сложнее еще не бывает
ссылок с куча над стеками
вот если мы такое запретим
то нам не нужно придумать такие сценарии
то есть в силу того, что у нас есть
скейп анализа такого свойства, то таких слуг не бывает
поэтому мы про это не думаем
но с помощью разметки
в рамтайне для сборки мусора
мы их используем
и можем привести стеку, проверить внутренний ссылок
и в горло стеки растут
фактически не могли расти бесконечно
кажется, там есть какой-то хард-лимит, типа 1 гб
но стеков на 1 гб кажется больше, чем...
кому бы не могло поработать
очень интересно, насколько это было задумано
потому что здесь такая схитная комбинация
свойства скейп анализа и сборки мусора используется
насколько это было задумано
с самого начала
я правильно понял, что
если компилятор видит
что на какую-то переменную
будут потом ссылаться
то он алоцирует ее на кучу
если куча
то у нас все указатели остаются валидными
потому что ты не стекал
а как тогда может появиться указатель
изнутри стеков внутреннего же?
не знаю, у тебя может быть в той же функции
это же не утечка
еще раз
у тебя же может быть внутри такого фрейма ссылка
это уже не очень важные детали
важно, что
у нас разметка для стек в любом случае есть
мы можем пользоваться
и у нас есть
но вот такие внешние ссылки в себя
мы точно уже запрещаем скейп анализа
а что с адресами выбраться на скейп?
так это адреса в коде
ну а что с ними?
ну да
а что с ними не так?
почему?
адрес возврата это адрес вместо в коде
у себя есть сегмент памяти там, где написан текст программы
там ссылки дают
это внешние ссылки
ну что, с этим мы кончили
и давайте мы обсудим
какие текущие задачи
я не знаю, вот на...
на прошлой плаве с другой группой
мы обсудили
как лучше оформить, написать тредпул
вот я в чатике общался с кем-то
не уверен, что с кем-то из вас
про то, сколько полей в частности
должно быть от тредпула
давайте я перескажу эту мысль
а вы подумайте над своими вопросами
хотя не все очень активны сегодня
так вот
вопрос такой
как понять, что вы написали хороший тредпул
или плохой тредпул, как их отличить
это простой критерий, по которому можно
проверить качество своего кода
убедиться легко, что тредпул ваш не самый лучший
но это правило довольно универсальное
я его в чате писал, повторю
если у вас в коде в пределах одного класса
одной функции есть какая-то
операция типа запуска спутников в космос
и в то же время есть операция разыменования
то с вашим кодом возможно
что-то не в порядке
потому что он на уровне одного класса
или одной функции сочетает в себе действия
очень разного масштаба
очень разной степени абстракции
и в хорошем классе
правилам мы работаем в пределах одного уровня абстракции
что это значит для тредпула
тредпул это некоторый компонент
который кажется составлен из других компонентов поменьше
в частности в нем есть очередь
в которую хранятся задачи
и вот эта очередь сама по себе не такая уж деревиальная
там буфер, кондвар, мютекс, какая-то синхронизация
но тем не менее тредпул про детали реализации этой очереди
ничего не знает
для него есть просто класс очередь
не тот шаблон, который мне нужен
есть просто класс очередь, которая реализует
вот этот API и гарантирует, что
метод take заблокируется до тех пор, пока не появится элемент
или не будет вызван close или cancel
с другой стороны, с стороны продюсеров
как это очень реализовано, полупотоков не важно
важны ее свойства, ее интерфейс
и вы этим пользуетесь
а дальше у вас есть другая задача в поле потоков
а именно реализовать wait idle
дождаться, пока пул не опустеет
первое наблюдение
если вы хорошо поняли API, то вы должны заметить
что wait idle и stop
вообще у них совершенно не то что
несвязанная семантика, но перпендикулярная вообще-то
потому что stop он про воркеры
и про очередь, там выключить очередь
остановить воркеры, а wait idle
он на пул не влияет
и ни с очереди, ни с воркерами не работает
wait idle просто подсчет задач
когда мы говорим submit, у нас видимо число задач
увеличивается, когда воркер завершает задачу
число задач уменьшается, а в wait idle мы хотим дождаться нуля
про очередь мы здесь кажется не думаем
и это хороший API, потому что метода
артагональна, это значит, что их можно комбинировать
можно вызывать только один, можно вызывать оба
в зависимости от того, как вы пулу используете
так вот, у вас есть такая вот задача
подсчитывать задачи
и что вы можете в коде написать
вы можете в коде написать прямо в полях класса threadpool
мьютексы, кундвары, счетчики
и вот вы смотрите на поля и с одной стороны у вас есть
потоки воркеры, понятно о чем речь
очередь, понятно о чем речь, а дальше какие-то
мьютексы, кундвары, счетчики
и смотрите, очередь, сущность довольно высоко
в уровне, понятно что она делает, а что делает
мьютекс, сам по себе он ничего не... ну в смысле
он сам по себе не полезен, он реализует некоторые
в смысле он помогает реализовать нечто
кундвар, какая у него семантика, у него
самостоятельной семантики вообще нет, мы дожидаемся
какого-то события, какого-то события вообще не ясно
вот это признак того, что у вас в коде
нарушены... смешиваются
разный масштаб и где-то у вас сущность высокого
уровня лежит, а где-то у вас какие-то детали реализации
и возникает такое естественное желание получить
такой модульный код, вот эту задачу
подсчета других задач, просто выделить в отдельный
компонент
и ну... я не хотел это делать сразу
но сейчас в условии есть подсказка про то, что
есть... да, есть
про то, что ну посмотрите на мир вокруг, как он устроен
то есть с одной стороны, да, мы считаем задачи
с одной стороны, но компонент, который мы хотим выделить
мы хотим... но он мог бы быть полезен
сам по себе, так же как очередь полезна
сама по себе, не только для реализации полного атак
и вот такой счетчик, который в ГО называется Weight Group
мне больше по душе название типа Workout
там подсчет работы некоторые абстрактный
вот он может быть использован сам по себе для синхронизации
вот в ГО пример такой, мы запускаем 5 ГРУТИН
в счетчике мы... ну, перед запуском мы увеличиваем счетчик
в конце каждого запуска
вот defer означает, что этот код вызовется при завершении
исполняемой процедуры, вызовется дан
это минус 1 и Weight Group Weight
дождется, пока счетчик вот этой работы
не опустится до нуля
и вот можно синхронизировать потоки, а можно считать
задачи в стратпуле, и кажется, что и там, и там
того и того же интерфейса будет достаточно
это говорит нам о том, что декомпозиция, возможно, разумная
что стоит ее использовать
еще один критерий разумной декомпозиции
ну, тут можно разные привести
вот если декомпозиция разумная
то вот, во-первых, вы получаете компоненты, которые полезны
сами по себе, за пределами вашей задачи
во-вторых, код самого стратпула
в идеале упрощается
ну, это не симмофор, это какой-то примитив
который чем-то напоминает, он скорее на барьер похож
но я бы не стал тут смешивать, это все-таки у него отдельное название
своя собственная семантика, понятно, что это можно
написать с помощью опять минуток, секунд два, какого-нибудь
впрочем, не только так
ну, это какой-то примитив, который
фиксирует правило ожидания какого-то события
вот в задаче про кундвар написано, кундвар-кундвар
что кундвар сам по себе симантики не имеет
но мы его используем для разных примитивов синхронизации
и в каждом примитиве синхронизации симантика своя
вот там, у барьера одна, у симмофора другая
у вейт-групп третья какая-то
и вот мы можем такую штуку выделить
и второй вейтпоинт в том, что третпул станет проще
все вызовы там буквально из двух-трех строчек
и вот все на одном уровне абстракции
на одном масштабе, и вот такой третпул
там, не знаю, его реализация читается просто
как документация симантики
сабмит, положить задачу в очередь, вылечить счетчик задачи
в правильном порядке, возможно
вейт-айдл, дождаться, пока счетчик опустится до нуля
стоп, закрыть очередь, остановить потоки
с одной стороны реализация, с другой стороны
буквально документация, что пул делает
код получается очень простой
ну и еще одно приятное свойство
такого модульного подхода стоит в том, что если
декомпозиция удачная, правильная, то
можно оптимизировать независимо разные компоненты
вот скажем, с мьютоксами и кундварами
голыми в третпуле очень легко написать плохой код
в котором будет нечто подобное написано
мы говорим сабмит, а в нем берем мьютокс
какой-нибудь, увеличиваем счетчик
и прямо под этим мьютоксом еще пут в очередь делаем
а в нем свой мьютокс, там мьютокс, положенный в мьютокс, хотя вот
смысла в этом вообще никакого нет, это просто неаккуратный код
но если мы разделим это на два компонента, то такого кода
просто не получится, потому что мьютоксы у них будут внутри
спрятаны
кроме того, тут мы так
случайно, можно сказать, повысим эффективность
кроме того, сами эти классы, weight group и очередь ожидания
weight group и очередь элементов задач блокирующих
их можно реализовать по-разному, можно оптимизировать
но очередь задач оптимизировать пока не будем
это разговор про локфрии скорее
а вот weight group можно написать очень по-разному
самая простая реализация, самая разумная
это мьютокс, кундуар и счетчик
но можно так постараться, чтобы weight group
на add и done, на самые частые вызовы свои
выполнял только одно тамарную операцию
чтобы он был очень легкий
правда при этом
тут нужно меня аккуратно правильно понять
потому что можно написать его на одном атомике
очень грубо, очень некачественно
вот я говорю не про плохое решение
которое очень легко написать
я говорю, что есть решение с мьютоксом и кундуаром
очень просто и разумное
а есть решение на атомике с мьютоксом
с weight'ом, оно довольно хитрое
оно чем-то напоминает идею барьеры
вот в хорошем решении
семантика weight используется
то есть я дожидаюсь, пока значение изменится
но имейте ввиду, что вот этому классу weight group
не подходит семантика weight
он не дожидается, пока значение изменится
он дожидается, пока счетчик не опустится до нуря
вот это weight'у не соответствует
но можно написать так, чтобы семантика weight group weight
выражалась через мьютокс weight прямолинейно
что действительно ожидание смены значения
будет означать, что задачи кончились
вот можно написать такой аккуратный код
но это скорее вопрос для защиты
вот такая история
вопрос, может быть, какие-то
вы говорили, что задача тройлог
он отчасти про то, чтобы узнать про инструкцию компея
Exchange, но отчасти там есть что-то глубже
и вы говорили, что если вам напомнить, то вы расскажете
а давай на защите расскажу
ну или спрашиваю, я не знаю
но это интересная история, но довольно маленькая
довольно локальная
мне кажется, что сейчас можно про какие-то более масштабные вещи поговорить
я зачитывал ассистенту
а?
я ассистенту зачитывал
ассистенту, да
ну ладно, найдем повод, я расскажу
вот может быть непрямо сейчас, может быть в локфрии это будет тоже разумно сделать
ладно, давай я сам на что-то внимание обращу
вот что в тредпуле появилось
и что появится в задаче про карутину
что мне кажется полезно знать
то, что мы на лекциях не обсуждали, а если мы на лекциях не обсуждали, а в задачах уже есть
это вот такая вот штука
ну вернее не такая, потому что это некоторая наша альтернатива механизму
который называется тредлокал
тредлокал, да
это некоторая интересная штука
и о чем она?
вот у вас есть локальные переменные
вот, представьте, что у вас есть потоки, да
и у вас есть вот какие классы переменных? есть локальные переменные, это переменные, лозированные на стэке
у каждого по тока, эта переменная своя собственная
когда он обращается, он обращается только к ней
к другим переменным, на других стэках обращаться, разумеется, нельзя
нельзя.
Вот здесь глобальные переменные.
К ней могут упрощаться все потоки, и она у всех
одна и та же.
А есть еще трудлокальные переменные.
Это довольно особенная переменная такая, что у
нее одно имя.
То есть как будто бы это ячейка памяти, которая
адресуется некоторым именем, но при этом воплощение
этой ячейки у каждого потока свое.
То есть имя одно, но у каждого потока она разная.
Это довольно нетривиальная штука.
Мне кажется, что мы такого не видели.
Я не знаю, вы видели вы такое где-нибудь?
Но вот они здесь появляются, и нам здесь нужно в threadlock
или хранить поинтер на текущий пул поток, чтобы из потока
воркера его легко можно было найти.
В threadpool это скорее забава, потому что вам самим в реализации
это не нужно было.
Но смотрите, когда вы будете писать задачу про крутину,
давайте я открою ее ритми, то вы там пишете многопоточные
файберы, и у них есть функция yield, и вот в этой функции
yield вам уже неизбежно потребуется threadlock.
Собственно в threadpool это переменный threadlock появился,
чтобы вы могли здесь его в частности понять, что
вам нужен и использовать его.
Вообще, что хочется сказать в связи со всем этим, с этой
задачей прошлой лекции, которая была в субботу?
Мне кажется, что эта лекция, хоть и новая, но она в том
или ином виде раньше была в курсе, но не в виде лекции,
а в виде семинара.
Сейчас, мне кажется, это одна из самых важных лекций
всего курса, потому что в ней сходится все, что было
до, а с другой стороны, все, что будет после, за исключением
модели памяти, из этой лекции тоже будет следовать.
И планировщик будем развивать, и коррутины будем развивать,
и там в разные стороны пойдем от нее.
И вот сейчас в курсе очень многое меняется, потому
что, объясню, как на это можно смотреть.
Мы с вами до этого момента занимались каким-то баловством
таким локальным, брали мьютерс, там какие-то строчки,
три строчки тут, строчки там, какие-то мьютеры, атомики,
кондвары, какие-то небольшие манипуляции, продумать в
голове все пересечения, переключения, интерливинги.
Дальше так продолжаться не будет, потому что это,
конечно, не совсем правда, но я бы сказал так, что если
говорить про... если не говорить пока про локфрия, про локфрия
нам пока знать не обязательно, то нам ютоксных кондварах
мы более-менее все разумные паттерны синхронизации
освоили уже.
То есть мы вот с такими техническими вещами разобрались.
Ну, я понимаю, что, наверное, не до конца, но это другая
история.
Но, в принципе, вот задачи, которые есть в ютоксных
кондварах, они покрывают очень много всего, что можно
про вот такую синхронизацию знать.
А дальше мы хотим с вами в курсе строить какие-то
более высокоуровневые вещи, и там эта синхронизация
будет возникать просто как вот некоторые маленькие
строительные блоки.
Но вещи мы делаем гораздо сложнее, гораздо масштабнее.
Вот мы сейчас начинаем писать вы, собственно, ГО, и...
Ну, я вот вроде вас не обманываю, мы собираемся в этом довольно
далеко продвинуться, в смысле мы вот здесь уже
напишем какие-то грутины, дальше мы напишем следующие
задачи примитива синхронизации для них, потом мы напишем
канал селект, потом мы пойдем как это интегрировать
фьючами, про которые отдельная история еще будет, как это
все обобщить, но чтобы сделать этот фреймворк расширяемым,
можно будет дожидаться не только на каналах, на
мьютексах, а на каких-то своих примитивах.
Короче, становится сильно сложнее, но, обратите внимание,
становится сложнее не потому, что нужно больше кода
писать.
Вот, я могу быть не совсем точен, но скорее всего в задачи
про крутину потребуется написать меньше кода,
чем в задачу на трэдпул.
Ну, как бы, задача на трэдпул вложена в крутину, но вот
если не брать в расчет перенесенный код, то нового кода там будет
даже меньше.
Но написать его, мне кажется, будет сложнее, не потому
что он требует какого-то, там сложнее переключения,
наоборот, там ничего такого не будет, сложность там
совершенно в другом, вот, я условия дорабатываю периодически
и на днях, на днях, задача добавилась, в воскресенье
я, может быть, вчера или позавчера добавил такой
пункт, что как вообще понять, что вы делаете что-то разумное
в задаче, как понять, что вы понимаете вообще ее условия,
ее замысел.
Вот задачи вам говорят, что мы хотим сделать многопоточные
файберы, мы хотим сделать их из, там, с комбинировав
пул потоков и с программы.
И вот задачи появляются с разными сущностями, которые
похожи, но которые все же отличаются.
Задача – это карутина, это файбер.
И вот неплохо было бы при решении задачи понять,
прежде чем ее писать, может быть, или по ходу, вот, где
границы проведены между этими понятиями, чем они
отличаются, за что каждый из них отвечает.
Вот мы пишем файберы, файберы и за что файбер означает
задача, как она выглядит, как в файбере используется
карутина, чем она от самого файбера отличается.
Потому что в первом приближении это можно не почувствовать.
Вот я бы сказал, что сложность этой задачи и сложность
многих последующих задач будет даже не в том, не только
в том, чтобы код написать, а в том, чтобы понять, что
вокруг происходит, понять дизайн, которым мы собираемся
пользоваться, по нему декомпозицию, которую нам предлагают.
Вот подумайте сами, написать свои многопоточные файберы
– это же выглядит сложной задачей.
Ну, по крайней мере, неделю назад, вот без лекции прошли,
по крайней мере, это сложно придумать, сев и начав
думать, вряд ли вы придумаете этот дизайн.
Людям потребовалось некоторое время, некоторая история,
чтобы к этому дизайну прийти.
И сложность этой задачи в том, чтобы понять, как
этот дизайн устроен.
И потом уже его просто воплотить.
Я обычные решения задач не рассказываю, на самом
деле на лекции я рассказал полностью решение задачи.
Но это не чувствуется, потому что само решение довольно
сложное.
И вот вы, разбирая шаблон задачи, надеюсь, это увидите.
Шаблон тоже очень разумный, пожалуйста, попытайтесь
понять все, что там написано, и вообще все, что в условии
написано.
Потому что многие вещи там написаны довольно, ну,
скажем так, странно.
И, например, вам говорят, что мы теперь не будем
вызывать вот этот пула метод Submit.
Мы будем вызывать функцию Submit, которая сейчас реализована
вот так вот.
Она получает лямбда и бросает ее в пул.
Ну, как бы зачем нам такая странная косвенность.
Ну, оказывается, что можно из этого извлечь очень
важную, очень большую опцимизацию для пула потоков, для файберов,
для вообще светлого будущего нашего.
Или там задача, ну, это такие уже вещи, ну, в общем, про
настоящее программирование, а не вот про такие вот пазлы,
которые были в метоксах в ганварах.
Например, там предлагают, что вот можно, ну, у нас
есть переключение контекста, и можно, в принципе, с помощью
него было бы делать разные вещи, там файберы писать,
карутины писать, там генераторы писать.
Но мы хотим сначала построить некоторый вспомогательный
класс Karoutine.Impel, потом уже его переиспользовать.
Вот почему у нас есть такой класс, который стеками
не управляет, у которого саспенд небезопасный.
Вот почувствовать, почему дизайн именно такой от вас
требует тоже каких-то усилий, и при чтении условий наверняка
не будет понятно.
Что еще?
Наверное, сложность еще в том, что теперь эти задачи
требуют, ну, такого более широкого понимания программирования.
Вот, я не знаю, вы проходите лабы по алгоритмам, и чтобы
решить любую лабу по алгоритмам, написать любой сложный
там, не знаю, суффиксное дерево, любое, нужно примерно
нулевое знание языка.
Вот вы знаете C, вы знаете там Container STL, все, вы можете
что угодно написать.
Но программирование так не устроено, в программировании
очень много задач разных, и для этого требуют, ну,
и для решения требуются самые разные вещи.
Вот, например, ну, Treadlock'a поговорили уже, другой пример
— интрузивность, про которую мы пока мало знаем, но вот,
которую можно здесь использовать.
Или, например, управление памятью.
В условиях говорят, можно ли использовать Do-read-this?
Вот вы не часто пишете такой код.
Ну, есть такое простое правило, что, скажем, не нужно вообще
писать New Do-read руками в программе на C++ современном,
потому что у вас есть make-shared, make-unique, и вам говорят, ну,
зачем вам Malog-free, тем более, New Do-read?
Ну ладно, New можно писать только для того, чтобы сделать
плейсмут New, когда вы пишете, там, не знаю, свой вектор,
это может быть еще полезно.
Но вот зачем вам прямо Do-read-this сделать?
У вас же есть чередпоинтер и никпоинтер.
Ну, ответ такой, что любая языковая конструкция — она
нехорошая и неплохая — это инструмент, и вот бывают
разные сценарии.
Когда вам говорят, не пишите никогда так, то вам говорят
на самом деле, что в 99,9% случаев не пишите так.
Но есть сценарий какой-то сложный, хитрый, специальный,
где вот такая функциональность в языке будет полезна.
И вот именно она и нужна.
И вот, и вам говорят, что не пишите никогда, потому
что детали сложные.
Но вы же разумный человек, вы понимаете, что если в
языке что-то есть, то, возможно, для этого есть какие-то
прикладные сценарии.
Ну вот здесь я утверждаю, что в Fiber'е разумно писать
Do-read-this.
Можно и без него написать на самом деле, и в этой
задаче, может быть, даже покажется, что так лучше.
Но забегая вперед, нет, не лучше.
Как бы сложно про будущее объяснить, можно только
не поверить.
Но, по крайней мере, поймите, как можно, в смысле, что
можно так, можно иначе, и мы об этом поговорим.
Опять же, вопрос про программирование.
Там про оптимизация.
Вот не знаю, какие у вас отношения к оптимизациям,
но вот в настоящем промышленном коде оптимизация, они, во-первых,
не про асимптотики никогда, во-вторых, не про ассемблеры
какой-нибудь.
Оптимизации, они, скорее, вот про какой-то грамотный
дизайн.
Вот у нас здесь есть важная оптимизация, это там стэк
локаторов, тьфу, локатор стэков, в котором есть эти
самые стэки, которые нужно переиспользовать, например.
Потому что они лоцируются дорого.
Там M-map делается, M-protect, изколы.
Вот в хороших, быстрых Fiber'ах, разумеется, не должно быть
изколы при создании.
Или вот эта самая интрузивность, это еще одна мощная оптимизация.
Вот мы говорим threadpool-submit, а что в submit попадает?
Задача, да?
А что такое задача?
Это unique function.
Знаете ли вы, что такое type erasure?
Ну вот представьте, что вы, у вас есть две лямбды.
Можете ли вы их положить в вектор?
Не можете, конечно, потому что у них типы разные.
А можете ли вы положить две STD function-вектор с одной
сигнатурой?
Какой-то обман, да?
Как так получилось?
Видимо, как-то, ну, то есть, unique function, STD function стерло
конкретный тип лямбды и заменил его чем-то общим.
Ну, в этом есть некоторый overhead.
Внутри allocation спрятано.
Вот если вы не знаете, как написать STD function, подумайте.
Ну, я однажды расскажу, пока не очень важно.
Главное, что внутри allocation скрытые.
Или, скажем, вот вы бросаете задачу в пул потоков, ну,
там, задачу, которая исполнит кусочек файбера.
А что такое submit в пул потоков?
Это добавить задачу в очередь.
А что такое добавить задачу в очередь?
Сделать pushback в, не знаю, дэк.
Это еще одна локация.
Нужна она там или нет?
Вот над этими вопросами можно размышлять и можно
в конце концов, ну, я так забегаю вперед совсем далеко,
в том, что можно сделать так, чтобы в наших файберах
allocations при исполнении не было.
То есть они перепланируются, они берут mutex, они там ждут
на каналах, на селектах, а allocations при этом в коде
вообще ноль.
Это довольно хитрое свойство, которое, в общем, которого
можно добиться и опять же сделать это, это настоящая
сложная оптимизация, и она абсолютно не про Assembler
и не про какие-то асимптотики, не про структуру данных.
Я бы сказал, что программирование настоящее большое, но выглядит
как примерно вот такая задача.
Много инструментов разных может понадобиться, можно
в много направлений пойти, много оптимизаций сделать.
С самых разных сторон код улучшать.
Что еще можно было бы сказать про задачу, которую мы, наверное,
еще не начали решать?
Ну, я бы вам порекомендовал сделать бонусный уровень
про генератора.
Я на лекции показывал, что можно делать такой хитрый
конвейер.
Ну ладно, эта ссылка не ведет никуда в интересное
место.
Такая вот хитрая функция, которая дожидается значений,
и может быть передает дальше.
Вот мы здесь говорим Send, и внутри этого Сенда вызывается
на самом деле очередной шаг консьюмера.
Ну вы, возможно, если вы писали на Питоне, то вы
к этому привыкли, вы знаете, что там такое с Поширядом.
Ну вот, опять полезно увидеть, как это можно реализовать
все плюс-плюс, причем реализовать через некоторый общий механизм,
не то, что в смысле наследования базу, но некоторую такую
общую базу функциональную, Crouting Imp.
Короче, осмыслить дизайн, вот, все части этого условия
и весь предложенный дизайн, это само по себе сложно.
Это новый класс задач, и дальше у нас задачи будут
скорее большими, чем маленькими.
Иногда будут маленькие встречаться, но сейчас мы
все уже вот эти маленькие паттерны синхронизации
изучили, дальше мы из них хотим собирать сложные
фреймворки.
Ну и да, я хотел сказать, чуть не забыл, мы же в чате
предложили чудесную идею, она мне прям очень понравилась,
ну в смысле, я хотел ее сделать, но прямо не до такой степени,
как предложили, а мне она и понравилась.
Вы смотрите, вы написали Mutex и Condvar с помощью Atomic,
да, потому что ElectroDipool с помощью Mutex и Condvar, что
можно было бы сделать, ну прямо сейчас можно было
бы сделать.
Взять и в задачу вставить ваше решение Mutex и Condvar,
и получится, что вы сделали Treadpool с помощью одного Atomic.
Ну, конечно, выделив компоненты перед этим, но тем не менее,
по сути, вам нужен был один Atomic.
А дальше мы этот Treadpool будем использовать для Fiber'ов,
а дальше мы сделаем Mutex и Condvar, вот, и там много всего,
и в итоге, ну, если вы получите Othel, то, мне кажется, что
у вас будет возможность в конце курса собрать это
все в одну библиотеку, где буквально из одного из
тогда Atomic, это все, что нужно от стандартной библиотеки,
можно будет построить свой ГО, который умеет много
всего.
А Futex?
А Futex, ну мы же тоже напишем его.
Ну, в смысле, я говорю про Atomic, в смысле, я говорю,
что нам нужно от компьютера уметь блокирующее ожидание,
уметь искол Futex и уметь автомарные операции для синхронизации.
И это все, что нужно, чтобы построить что-то сложное.
Ну вот, мы это все в виде Atomic'а получаем, а все остальное
мы с помощью Atomic'а можем сделать сами.
Понятно мысль?
Вот, ну, то есть, понятно, что мы можем и мы так по
шагам делаем, но я надеюсь, что будет финальный шаг,
где можно это все слепить вообще в одно.
Кажется, что это будет занятно.
Кроме того, у нас еще, ну, я сразу предупреждаю, что
тут кого-то может огорчить, что мы двигаем код из задачи
в задачу.
Так, к сожалению, будет происходить, потому что
мы двигаем код, иногда его немного меняем.
И вот скажем, мы Treadpool еще раз будем переиспользовать,
и мы подвинем его еще во вложенную директорию и так немного
обобщим.
Короче, вот мы так наблюдаем за эволюцией этого всего
кода, и через два месяца мы уже можем, ну, довольно
много себе вещей словно представить вот сразу в одной картинке.
У нас еще Future появится, который мы тоже интегрируем
сюда к Fiber'ам.
Эта вот лекция будет, которая через раз суббота, два суббота,
третий суббота.
Вот мы поговорим про Future.
Да, кстати, Future я по-прежнему рекомендовал в канале,
рекомендую и сейчас.
Задачу это сделать, потому что дальше, в будущем, ну,
в будущем вам говорят, сделайте плохие стады Future
бесполезные.
И, ну, они действительно плохие и бесполезные, я вас
не обманываю ни в коем случае, но дальше мы поговорим
про хорошие Future.
Потому что вот здесь Future — это такой, ну, одноразовый
условный канал для передачи значения.
На самом деле Future, конечно, не для этого нужны.
Вот я не знаю, пугает ли вас это слово, Future — это
Это такой инструмент для композиции вычислений.
Fiber — это инструмент для композиции вычислений,
и Future — это инструмент для композиции вычислений.
Я вам на лекции расскажу.
Вот скажем, Twitter, они пишут, что у них все свои сервисы,
они пишут на фреймворке, там, где есть RPC, Future и декораторы
для них.
То есть это такое средство, с помощью которого они
свою логику описывают, своего кода.
Ну, мы это все увидим однажды, и чтобы мы к этой лекции
были готовы, чтобы у нас были какие-то минимальные
представления о том, что такое Future, как оно реализовано,
вот нужно сейчас задачу решить.
Ну и плюс они объясняют нам, как можно решить проблему
с тредпулом, потому что тредпул, кажется, не умел дожидаться
конкретной задачи и не умел вернуть из нее значение.
Ну вот мы в этой задачи, в этом примере увидим, что
тредпулу не нужно, потому что если у нас есть Future
и тредпул, то можно их скомбинировать и получить
то, что мы хотим.
Можно написать маленькую функцию вспомогательную,
которая просит задачу в пул с промиссом, а нам сразу
вернет Future.
Но для этого тредпул дорабатывать вроде бы не требуется.
Ну что ж, вот, наблюдайте, как все это происходит, потому
что тут постепенно разные вещи начинают собираться,
они не то чтобы мы, не то чтобы какие-то независимые
вещи делаем.
Ну тут барьер, симафор — это какие-то маленькие такие
бесполезные штуки, такие маленькие учебные примеры,
а вот все остальное, мне кажется, что оно собирается
в одну большую картину, и нужно, чтобы она у вас
накапливалась в голове.
Подкиньте вопрос, может быть, потому что я вот что хотел
сказал вроде бы, а что вы хотели, я не знаю.
Мне кажется, не знаю, можно считать, что это, смотрел
обыкновенное чудо.
Или читал, может быть, пьесу.
Ну короче, есть такая замечательная пьеса, шварца советская.
Там такой король, Самадур.
Коротко это мне захотелось, потому что Weight Idol — это
имя, которое так хорошо описывает семантику метода.
Вот Weight плохо его описывает.
И там в чате уже начались вопросы, а что делает Weight,
чего он там у меня дожидается.
Ну в самом деле непонятно.
А что делает Weight Idol, понятно даже школьнику.
Это же большая удача придумать такой набор методов с такими
хорошими именами, чтобы все было сразу ясно.
Так что нужно, чтобы код был лучше, потому что нам
с ним долго еще жить.
Какой-то необходимости, ну разумеется, необходимости
в этом не было.
Но я, конечно, оставляю за собой некоторые… Я хочу,
чтобы этого было меньше, но все же я считаю, что
у нас возможны в курсе моменты, когда я ломаю немного
шаблоны, потому что я считаю, что глобально это пользу
нанесет всем.
Ну ценой некоторых конфликтов при апдейте репозитория,
при слиянии каких-то.
Ну неприятная ситуация, но иногда ничего не пойдет.
В прошлый год был метод Join, и у него была такая совмещенная
семантика.
Это такая стандартная штука вообще-то в тредпулах,
но вот текущий опиум гораздо лучше.
Курс совершенствуется, никто этого не замечает, конечно,
но вот с каждым годом… И за счет того, что он совершенствуется,
с каждым годом мы делаем все больше и больше, потому
что все более гладко и гладко все проходит.
Так что мы в этом году можем дойти необычайно далеко.
Такая история.
Вообще то, что мы делаем, люди пишут, ну не знаю, это
пишут какие-то очень старшие разработчики на самом деле.
Вот.
Но, конечно, это не означает, я не пытаюсь сказать, что
вы придете в курс и станете старшим разработчиком.
Нет, так не работает вселенная.
Ну потому что самые сложные вещи в курсе делаю я все же.
То есть, но то, что мы делаем, это действительно сложно.
Сложно не просто так бы запомнить много там нюансов
в суффиксном дереве, а вот по-пограммистски, по-инженерному
сложно.
В конце концов, мы получим довольно неплохой год, если
мы напишем, ну если вы напишите его хорошо, то вы не будете
за него стыдиться.
Знаете, говорят, что вот есть такой код, который проиграет
только ваша мама.
Вот можно написать очень хороший код.
Вопросы еще.
Я, кажется, про адреса не тазерный.
Успеваю с вами поговорить, что меня скорее печарит.
Не успеваю.
Мне нужно минут, не знаю, двадцать.
Я боюсь, что просто нас вытеснет в конце.
Я бы не хотел это сделать.
Я бы не хотел это сделать.
Я боюсь, что просто нас вытеснет в конце.
Я бы не хотел, чтобы нас вытесняли.
Ладно, в следующий раз мы это разберем, может быть,
не страшно, потому что все равно я не только про него
хочу рассказать, а еще про что-то другое.
Может быть, у вас вопросы просто есть по домашкам
еще.
Ну, желательно по каким-то новым, ну или по темам лекций
последней, потому что, ну наверняка что-то должно
быть.
Неужели прям все ясно?
Это может быть вы большие молодцы просто, я не
сомневаюсь, но даже если бы вы были большими
молодцами все, то у вас были бы более сложные
вопросы.
Да, давай.
Ну была такая, да.
Спинлок.
Ну, да.
Ну, да.
Ну, да.
Ну, да, вот.
У меня вопрос, почему, в смысле,
если вы будете смотреть, то
вы заткнулись в историю,
не вижу в этом центре инструкцию Exchange.
Ну, это хорошо, что ты увидел, но ответа пока нет
вопроса нет. Эта тема про модели памяти, она будет
через субботу. Нет, давайте рискнем, потому что
что это у нас? Семинары разъезжаются в
двух групп, не дело.
Давайте все-таки попробуем про адрес
CineTizer поговорить.
А если нас вытеснили из
аудитории?
Можем, наверное. Я бы хотел скринкаст
склеить просто.
Давайте попробуем начать сейчас, но
успеем успеем, я пытаюсь
быстро, гладенько все объяснить.
Итак, мы переходим
portions.
Мы хотим поговорить про тестирование
поговорить про тестирование кода, потому что... Давайте я вам объясню, в чем сложность.
В том, что любой сложный код нужно тестировать, разумеется, а любой
недотерминированный код нужно тестировать гораздо аккуратнее, потому что
недотерминированный код гораздо сложнее, потому что для него
юнит теста не напишешь, не переберешь аккуратно все поведения, не поверишь в все инварианты, и вот чем
сложнее код, который мы пишем, тем... Ну, вы представьте себе, мы пишем примитиву
синхронизации, мы пишем свой собственный го, там всякие переключения, сплю свои
капы, какие-то перепланирования. Вот вы написали там свой мьютокс, свой
кондвар, свой тредпул. Почему вы уверены, что вы правильный код написали? Почему вы
уверены, что он правильный синхронизирован? Вот если вы просто напишете стресс-тест, то
вам это не поможет, потому что сложные баги в стресс-тестах не появятся, скорее
всего. И вот в курсе, мы используем целый набор инструментов, и в частности, мы
используем... Ну, мы там используем фут инжекшен, мы используем там файбры для
чего-то, вот сегодня точно про это не успею, а еще мы используем санитайзеры. И я бы
хотела поговорить немного про них. У нас санитайзеров два. У нас адрес санитайзера и тред санитайзер.
Адрес санитайзера, он про проблемы работы с памятью, про memory safety,
тред санитайзер про тред сафти, то есть про датарейсы. Но вот что такое датарейс,
как работает тред санитайзер, объяснить сложно, потому что он находит датарейсы,
а что такое датарейс, я еще строго не определял. Я сказал, что это два
несинхронизированных обращения к ячейке памяти, среди которых одну запись. Но это
пока не строгое определение, строгое будет в моделях памяти. А вот адрес санитайзера это то,
что кажется понятно нам сейчас, и это вещь более универсальная, потому что она будет просто
проработать с памятью. Вот давайте посмотрим на пример. Вот такая функция badStringView.
Знаем ли мы, что такое string? Это класс, у которого есть поле, там, чарзвездочка у
pointer на буфер, есть размер, и вот когда мы создаем строку, на кучу алоцируется буфер для нее,
когда строка разрушается, буфер освобождается. Когда строка копируется, копируется буфер,
то есть алоцируется новый, копируется его содержимое. А есть stringView. Что такое stringView?
Это по сути тоже пара, чарзвездочка и размер. Но в отличие от строчки stringView памятью не
владеет, просто ссылается на нее. Копирование stringView бесплатно, копирование двух полей. Поэтому,
кстати, stringView не передавайте по ссылке, передавайте по значению всегда. Очевидно,
в этом примере со stringView есть некоторая проблема, потому что вот здесь мы ссылаемся на строчку
hello, а после этого вызывается деструктор строчки тест, и буфер, видимо, освобождается. Мы отдаем память
локатору. Блок уже не адресуем, но при этом stringView ссылается на него, и здесь мы печатаем
какое-то содержимое. Будет ли это работать? Сейчас, подожди, ну тут что бы ни было, все равно
программа некорректная, да? Правда ведь? Ну она некорректная, ты обращаешься к памяти объекта,
который разрушен. Что значит, как бы он не был реализован, это не то, что ты хочешь. Еще раз,
речь не про то, как работает компьютер, речь про семантику. У тебя объект разрушен. Почему ты,
рассуждая про семантику программы, рассуждаешь про конкретную оптимизацию, которая сделана в конкретной
библиотеке? Это, кажется, не должен делать, это нарушение абстракции. У тебя абстракция
что значит? Нет, код, конечно, некорректный, потому что мы ссылаемся на строчку, которая уже не
существует. Если она отцирована на куче, то это точно и беда. Если она отцирована на стэке,
ну ладно, строчка пока короткая, это правильное замечание, но пример, смотрим-смотрим, работает.
Да я знаю про ССО, я говорю, что она и так не упадет.
Она и так и так неправильная, и так и так работает, но тем не менее,
для того, чтобы эти ошибки найти, у нас есть адрес санитайзера. Адрес санитайзера — это
инструмент в компиляторе. Мы ставим флажок fsanitizer-dress, запускаем этот код, и что мы видим?
Вот в этом примере. Хип юз офтофри. Неудобство. Ну, если исправить здесь вот так вот, то не то,
чтобы станет лучше. Мы получили стэк юз офтоскоп. В любом случае, это проезд по памяти.
Ну, здесь строчка лежит на стэке, вот со знаками восклицания, она лежит на куче,
но тем не менее, что произошло? Строчка разрушилась, мы аллокатора дали память,
аллокатор ее положил поинтер на освободившийся блок куда-то в себя, ну а байт это в памяти остались,
мы просто на них сослались. Поэтому программа не падает, но это плохо, а нехорошо,
потому что хорошая программа не работает, когда она совершила ошибку. Когда в ней появился бак,
программа должна упасть. Вот для этого есть адрес санитайзер, и он такие ошибки нам обнаруживает.
И вот нам интересно, как он устроен. Почему нам интересно это вообще понятно,
а почему нам интересно это в конкретном курсе? Потому что мы пишем конкарнси, а конкарнси,
ну ошибки в конкарнсе, какие-то рейс-кондишны часто могут проявлять себя как неправильная
работа с памятью. Ну вот пример, у нас есть односвязанный список, который я уже показывал,
кажется, не один раз, и мы с ним работаем из разных поток. Чем эта работа может закончиться?
Разными исходами. Во-первых, мы можем получить heapUseAutoFree в методе forwardListPop вот в этой строчке.
Почему? Потому что пришли два потока, они оба прочли одну и ту же голову в локальную переменную,
потом один поток головы переставил, удалил голову, а дальше мы вот здесь по этому поинтеру
пошли в удаленный блок, удаленный узел и попробовали прочесть next. Ну вот использование памяти после ее
освобождения UseAutoFree. Вот если перезапускать этот код, то через некоторое время, повезло сразу,
реализовалось double free. Два потока вошли в поп, прочли один и тот же pointer, переставили один и тот же,
переставили point голову вперед на одно и то же, и потом дважды удалили. Пять проблем. Ну то есть у нас
проблемы с памятью проявляются, проблемы с синхронизацией проявляются как проблемы с памятью.
Вот поэтому мы в курсе используем адрес-санитайзер, потому что просто он ищет байлист работы с памятью,
а во-вторых, эти баги могут быть средствами ошибок с синхронизацией. И так, что нужно про
санитайзер вообще глобально знать? Ну вот санитайзер хочет нам обеспечить memory safety, но точнее он
конечно не может обеспечить ее, он всего лишь пытается обнаружить ошибки. Если в программе,
в исполнении программы ошибка проявилась, то санитайзер ее найдет, а может и не найти,
может пропустить, потому что он работает не идеально. А может быть в конкретном исполнении
программы в программе ошибка есть, а в конкретном исполнении она не реализовалась. Санитайзер тоже
ее не найдет поэтому. Санитайзер проверяет исполнение, а не программу. Поэтому он нам может сказать
точно, что ошибка есть, но если он говорит что ошибки нет, то это само по себе не доказывает,
что программа корректная. Но есть же альтернативные подходы. С++ такой подход. Мы собираем программу с
санитайзером и находим ошибки. Есть другой подход, другие подходы к memory safety. Как гарантировать,
что в программе нет висящих поинтов, которые указывают на освобожденную память уже?
Чуть более общие слова нужно сказать. Как обеспечить в языке memory safety? Самое очевидное
и пример. Сделать автоматическую сборку мусора в языке. У вас просто нет явных
аллокаций. Вы не делаете делаллокации просто руками. За вас, за вас их делают сборщик мусора,
делают их тогда, когда это безопасно. Когда гарантированно вы не можете в памяти обратиться,
потому что у вас не осталось никаких способов до этой памяти добраться по ссылкам.
Можно понимать автоматическую сборку мусора в двух смыслах. Можно представить себе автоматическое
управление памятью в двух смыслах. Это сборка мусора, то есть гарбыч коллектор, и это референс
каунтинг. В принципе, две стороны одной медали. Не то, чтобы это разные подходы. Они в
каком-то смысле двойственные. Давайте подумаем, а за что мы в таких подходах платим? Потому что
это же не бесплатно. Нам дают memory safety, но мы должны зачем-то за нее заплатить. Вот какова наша
плата за безопасность? За отсутствие такого класса ошибок в программе? Так а плата-то в чем состоит?
Непонятно. Мне кажется, что плата состоит в паузах. Но если мы говорим про простой сборщик мусора,
самый такой наивный stop the world, то иногда ему нужно остановить исполнение вашей программы,
чтобы зафиксировать граф объектов, а дальше этот граф объектов размером 100 гигабайт,
30 секунд обходить. Вот 30 секунд ваша программа не отзывается. Неприятная ситуация. В плюсах
нет сборки мусора. У нас memory safety в плюсах нет. Давай сразу до этого договоримся. Поэтому это не
решение. Мы можем писать баги. В джайве мы такие баги написать не можем. Как классы, они отсутствуют.
Но за это мы платим тем, что мы имеем overhead при исполнении. Во-первых, мы имеем overhead в смысле
пауз сборщика мусора, а во-вторых, если мы говорим про современные языки и про более отзывчивые
приложения, то там сборка мусора по-другому устроена. Там она не stop the world, там она concurrent.
То есть у вас одни потоки мутируют граф объектов, они так называются мутаторы, а другие потоки обходят
граф и помечают красить его в три цвета. И тут появляется дополнительная overhead, потому что
паузы иногда бывают все же, пусть даже и короткие, но когда вы одновременно конкурентно меняете
граф и обходите его, вам при мутации, при изменении графа, при переставлении ссылок, вам нужно
исполнять некоторый служебный код, который вы тоже за это платите, чтобы просто сборщик мусора
знал, что граф поменялся. И в принципе тут можно сразу увидеть аналогию с референс каунсингом,
потому что вы всегда платите в референс каунсинге, когда вы переставляете ссылку, вы счетчик
уменьшаете и увеличиваете. Поэтому референс каунсинг, это скорее два конца спектра,
автоматическая сборка мусора и референс каунсинг. Они не то чтобы разные, они противоположные,
но по сути они выполняют одну и ту же работу, они просто по-разному ее группируют. Ну референс
каунсинг, там свои проблемы, там он в C++ не безопасен, он сам по себе не гарантирует проблему,
не решает проблему с циклами, а в C++ shared pointer еще плохо, потому что в нем автоматический
счетчик ссылок. У вас программа однопоточная, а счетчик ссылок атомарный, вы платите вообще
ни за что. Это очень плохой дизайн, вот в C++ такого навал. Хорошо, есть ли альтернативный способ,
как обеспечить memory safety без такого оверхеда? Мы хотим и memory safety, и отсутствие оверхеда при
исполнении. Известен ли вам способ, как этого достичь? Ну статический анализатор есть примерно
в одном месте в языке Rust, но это не то чтобы статический анализатор, этот подход не работает,
это работает, когда у вас есть язык, который, система типов языка, это все позволяет делать.
Вот система типов в языках программирования, это очень сложная тема, она не про то, что там строчку
не складывается числом, она в общем случае про описание свойств программы, эти свойства могут
быть самыми разными. Вот в Rust есть такое свойство, такой вариант, который вы поддерживаете для вашего
кода, что вы не можете в коде иметь разом две ссылки на одну и ту же память, такие, что по крайней
мере через одну ссылку вы можете в память писать, или ударять там, или что-то подобное делать. Вот скажем
программа на C++, вы создаете вектор из двух элементов, вы берете pointer на первый его элемент,
а потом вы делаете pushback, и ваша программа разваливается, потому что вектор перелатировал
буфер, а ваш pointer так и остался, он вот висящая ссылка у вас, и вот вы здесь получаете юзовство
free. В Rust такая программа не комперируется, потому что вы не можете получить две мутабельные ссылки,
но это с одной стороны здорово, потому что Rust статически запрещает вам неправильные
программы, но конечно же Rust не может отличить правильные программы от неправильных, он может
просто отличить программы, в которых есть некоторые паттерны по сути, так что он запрещает конечно
программы с ошибками, а еще запрещает какие-то разумные программы. Скажем, в таких ограничениях
нельзя написать вдвусвязанный список, это довольно печально, но поэтому в Rust есть некоторое
небезопасное подможество, из-за того, как вы можете писать код, в котором могут быть нарушения
memory-safety, но вы можете дальше спрятать этот код за безопасным API, и там короче есть целая работа
по формализации всего этого. А еще смотрите, какое интересное свойство из этого решения в Rust
следует. Вам говорят, вы не можете иметь два поинтера на одну и ту же ячейку так, чтобы через один
поинтер можно было писать. А теперь вспомните, что такое датарейс. Это ситуация, когда у вас два
потока, которые пишут в одну ячейку несинхронизированно, в смысле два потока, которые обращаются
к одной ячейке несинхронизированной, и по крайней мере одно из обращений в запись. Так вот, если Rust
просто запрещает в своих программах иметь два таких поинтера, то у вас не только memory-safety будет,
у вас еще будет датарейс-safety. У вас датарейсов не будет. Это вот еще один пример, что работа с
памятью и buggy-синхронизация, это какие-то очень связанные друг с другом вещи.
Ну что, дальше нужно говорить уже конкретно про адрес санитайза, про то, как он эти проблемы
решает. Ну давайте, наверное, сделаем это после перерыва. Все-таки перетянемся в соседнюю
аудиторию. Такая у нас пауза возникла. На чем мы остановились? Мы поговорили, что мы хотим искать
ошибки, связанные с обращением к памяти, висящие указатели double-free. Хотим искать эти ошибки просто
потому, что в любом сложном коде такие ошибки полезны отлавливать, а во-вторых, потому что эти
ошибки в контексте нашего курса свидетельствуют, могут говорить о том, что у нас проблемы
с синхронизацией. Вот мы обсудили, что есть разные подходы вообще как такие ошибки, но не то чтобы
обнаруживать, а скорее предотвращать вообще. В принципе, это автентическая сборка мусора,
это не то что правильная система типов, специально решающая такую задачу. Или в C++ это санитайзер.
Санитайзер — инструмент, который обнаруживает ошибки не в программе, а в конкретном исполнении. И мы
сейчас хотим поговорить, как он устроен. Важно заметить следующее с самого начала, что мы...
Можно себе представить разные инструменты. Так вот, санитайзер — это инструмент, который целится в
программы большие, скоро угодно большие. То есть он в промышленные программы целится, какие-то
проекты из миллионов строчек. И это означает, что адрес санитайзера должен работать с большим кодом,
с большими кучами. И желательно давать как можно меньше аверхед. То есть мы можем, наверное,
придумать очень разные проверки, которые бы позволяли находить наши ошибки. Но адрес санитайзер
может делать довольно просто, должен делать по возможности простые вещи, чтобы сочетаться с
сложными программами. Итак, как же адрес санитайзер должен быть устроен? Ну, это можно понять,
глядя вот на этот код. Вот мы его запускаем и здесь обнаруживаем, не знаю, что у нас сразу получится,
юзов-тофри, нам повезло. Вот адрес санитайзер поймал ошибку сразу же. Вот мы в этом месте
обратились к полю объекта на куче, который уже был деалацирован, и прямо в точке этого обращения
мы сумели на ошибку обнаружить. Это очень важно, потому что дальше бы там все как-то каскадом
накапливалось, уже непонятно, что бы произошло. А это также означает, что адрес санитайзер,
видимо, выполнил проверку прямо вот здесь, прямо в этом обращении. Как же он это сумел сделать?
По какому принципу вообще работают санитайзеры? Санитайзеры состоят, как правило, из двух
компонентов. С одной стороны, они выполняют инструментацию кода, то есть исполняется не наша
программа, исполняется программа, в которую комператор вот с флажком fsanitizeaddress вставил
рядом с обращениями к памяти проверки. То есть вокруг этого, перед, условно, этим обращениям
памяти находится некоторый служебный код, который проверяет, что память адресуема, что она вообще
сейчас выделена локатором. Ну, во-первых, нам нужна инструментация, то есть нам нужно такие
проверки в код вставить, а во-вторых, нам в runtime-е нужна какая-то структура данных, которая сможет
эти проверки обслуживать. То есть нам нужно, ну, я, конечно, утрирую, но, грубо говоря, нам нужно для
каждого байта памяти знать, адресуем он или нет. Вот мы такую проверку здесь вставим и проверим,
но я, конечно, говорю неправду, потому что прям для каждого байта знать, адресуем он или нет,
нам не требуется. Почему? Потому что нужно вспомнить про такое свойство работы с памятью, такое
свойство локатора, как выравнивание. Ну, вот процессор ожидает, что наши данные выровнены,
и компилятор это выравнивание соблюдает, и если вы обращаетесь к молоку и получаете этот блок
памяти, то этот блок памяти всегда выровнен по 8. То есть, если вы алоцируете в динамической
памяти какой-то объект, то его адрес кратен восьми. Это означает следующее, что если мы посмотрим на блок
из восьми байт в памяти, ну, выровненный блок из восьми байт, то в каких состояниях, то может ли
быть такое, что, скажем, вот первые два байта в этом блоке не алоцированы, а третий байт алоцирован.
Возможно ли такая ситуация? Нет, невозможно, потому что любой объект, который был бы алоцирован,
был бы выровнен по 8. Поэтому, если мы посмотрим на каждый блок размером 8 байт, то он бывает в восьми
состояниях. Он может быть полностью адресуем, то есть все байты его адресуемые, либо адресуемые
первые 7 байт, либо первые 6, либо 5, 4, 3, 2, 1, либо блок вообще не адресуемый. Это я сейчас к тому
говорю, что нужно разобраться, а какую метаинформацию о состоянии памяти адрес Sanitizer должен
поддерживать время исполнения. Вот он должен для каждого 8-байтового блока помнить, сколько байт в
этом блоке доступно для чтения записи. Для каждого 8-байтового блока ему нужна метаинформация размером
в 1 байт. Как адрес Sanitizer это поддерживает? Адрес Sanitizer подменяет аллокатор в программе.
Когда он выделяет память, то он для блоков выделенных помечает в служебной части памяти,
что эти блоки адресуемы. Когда он освобождает память, он эти блоки в некотором смысле отравляет.
Но что именно я имею в виду? Тут я вам рекомендую обратиться к статье про адрес Sanitizer. Она,
по-моему, очень... она 12-го года, но с тех пор Sanitizer не сильно менялся, и статья очень простая,
и в нем очень много содержания. Адрес Sanitizer подменяет аллокатор, и у этого аллокатора есть
зона, собственно, кучек, где аллокатор выделяет память, и есть зона, которая называется Shadow Area,
или Shadow Memory. Это зона, в которой лежат служебные байтики, которые описывают состояние 8-байтовых
блоков в куче. И когда адрес Sanitizer аллоцирует память, он в Shadow Area для аллоцированных блоков
помечает, что они адресуемы. Когда освобождает, он помечает, что они не адресуемы теперь больше.
А когда мы к ним обращаем... а когда мы обращаемся по Pointer в программе, то на стадии инструментации
кода адрес Sanitizer помещает вот такую проверку. Вот мы собираюсь в программе прочесть такой адрес.
Перед этим обращением адрес Sanitizer вставил... компилятор вставил такой код. Мы берем этот
адрес, делим его на 8, то есть получаем фактически индекс 8-байтового блока, и добавляем к этому
индексу магический offset, который означает вот начало Shadow Area, начало Shadow Memory. То есть мы
вычисляем здесь для вот 8-байтового блока адрес байта, в котором лежит статус. И смотрим,
если тут в этом служебном Shadow адресе написано 0, то это означает, что все 8-байт адресуемы.
Если же он не равен 0, то значит адресуема какая-то только часть байта или вообще никакие,
поэтому мы пишем отчет. Вот, кажется, и вся механика. И вы смотрите, когда мы
получили User-free, то нам адрес Sanitizer в отчете вместе со стэками написал еще и кусочек Shadow
Memory. Вот мы обратились к какому-то байту, и вот смотрите, в каком он был. То есть мы читали узел
списка, перед этим чтением мы обратились к служебному байту в Shadow Memory, и в этом байтике
была написана такая же стеричная константа FD. То есть этот 8-байтовый блок был освобожден уже
отданного локатора. Вот когда мы отдаем память локатору, локатор записывает в Shadow байта этого
блока вот такую вот константу. Понятная идея. Ну и теперь вопрос на понимание, а что будет,
если программа вот алоцировала что-то на куче, потом поставила ссылку на эту память, а потом
память была освобождена, отдана локатору, потом локатор ее перевыдел какому-то другому коду,
а дальше мы по исходной ссылке решили прочесть. Ну то есть случилось некоторое оба. Память была
адресуема, потом стала не адресуема, потом снова стала адресуема, и мы при обращении вроде бы вот
эту проверку, вот эту проверку прошли успешно. Там написано ноль сейчас, то есть блок адресуемый,
хотя в программе явно что-то идет не так. Ну вопрос просто будет ли, в смысле что будет,
найдет ли адрес санитайзера ошибку или нет? Ну ошибка есть и адрес санитайзера, скажем так,
он постарается ее найти, потому что что он сделает? Когда вы освобождаете память в программе,
то вы отдаете ее локатору санитайзера, а санитайзер вот о чем думает. Он думает, что,
ну если я эту память сразу переиспользую, то возможно у пользователя будет юзоста фрио,
и мы не заметим этого. Поэтому санитайзер кладет этот блок памяти, который мы ему отдали,
в такую очередь, которая называется карантином. И вот блок из карантина еще некоторое время не
переиспользуется для локаций, чтобы дать возможность пользователю в него наступить и получить ошибку.
То есть блок в карантине, он уже отравлен вот этими служебными байтами, ну не сам блок,
а Shadow Memory для него отравлены этими байтами, этими значениями, и пока он там мринуется в
карантине, ошибка будет обнаружена. Если ошибка пройдет спустя слишком долгое время,
то возможно мы ее пропустим. По поводу оверхеда. Ну смотрите, у нас есть для каждых восьми байт еще
один служебный байт. Это вроде не так много. Если программа требует, не знаю, сотни гигабайт
памяти, то такой оверхед допустим. А с точки зрения производительности, мы, кажется, вместо одного
обращения к памяти теперь делаем два. То есть у нас было одно обращение к памяти, теперь добавилось
еще одно служебное. И вот оттуда берется примерно оверхед в два раза для адрес санитайзера.
Я не знаю, где-то в документации это должно быть написано, что ожидаемое замедление в два раза,
но вот ровно потому, что теперь на каждое чтение ваш выполняется еще чтение Shadow Memory.
Ну и еще один класс ошибок, которые возникают в программе и который адрес санитайзера обнаруживает,
это выход за границы массива. Вот мы алоцируем блок и можем выпасть по индексу за его край. Если не
сделать ничего специально, то ошибки скорее всего тоже не будет, потому что рядом с вашим алоцированным
блоком лежит может быть блок какого-то, не знаю, другого вектора или чего-нибудь подобного, так что
программа продолжит работать, пусть и неправильно. И чтобы такие ошибки обнаруживать, адрес санитайзер
выполняет такой трюк. Когда он алоцирует память, какой-нибудь такой кусочек, то слева от этой памяти
он оставляет некоторый зазор, который называет Redzone, и служебно и Shadow Bytes для этого Redzone
заполняются специальным флажком. Вот мы их видим, здесь FA — это левая Redzone для объекта на куче.
Вот на всякий случай, вот эти вот Bytes — это не прямо Bytes в памяти, не в куче, это Bytes в Shadow
Memory для кучи, понимаете, да? Вот, то есть слева от вашего выделенного блока есть служебный блок,
для которого Shadow Area отравлено вот специальным значением. Так что если мы переполним или там
выпадем через край, то мы в какую-то Redzone попадем и опять сломаемся. Это все похоже на
GuardPage в стеках, которые мы обсуждали на прошлом семинале, на реакции не обсуждали, по-моему. Но
механизм тот же самый, то есть чтобы упасть побыстрее. Наверное, последнее, что сейчас я скажу — это...
Ну, по карантинам я сказал, про проверки я сказал, про... Ну, есть проверки со стеком,
тут не точно так же, конечно, но похожим образом все устроено. Есть такой забавный нюанс,
который вот делает адрес-синитайзер хорошим промышленным инструментом. Ну, во-первых,
он вносит маленький оверхед в исполнение программы, по крайней мере старается его
минимизировать. А во-вторых, адрес-синитайзер генерирует очень хорошие отчеты. Вот без хорошего
отчета инструмент тестирования обычно не годится. Вот адрес-синитайзер вам пишет много информации,
он пишет, во-первых, что юзовство free по такому-то адресу, а дальше он печатает три стека. Во-первых,
он печатает, где именно вы наступили на освобожденную память. Вот здесь сообщает он,
вот стэк, то есть мы внутри метода forward list pop. Хорошо, но этот стэк легко нарисовать,
потому что мы сейчас в нем, мы там вот наступили в shadow memory, который писать нельзя. Есть еще два
стека. Адрес-синитайзер сообщает не просто, где он в память наступил освобожденную, он сообщает
нам еще, где она была освобождена и где она была алоцирована. Сейчас. Была освобождена и была
алоцирована, то есть целых три стека. Откуда он их берет? Ну это довольно красивый инженерный нюанс,
когда локатор алоцирует блок для вашей программы, он же слева оставляет RedZone с отрабленными
ShadowBytes. Так вот он в этой левой RedZone не сохраняет стека локации. А когда он диалоцирует блок,
когда вы диалоцируете блок и отдаете его в карантин, то он лежит в этом карантине и синитайзер
внутри этого блока, уже освобожденного, кладет стэк диалокации. Если вы успели к этому блоку в
карантине обратиться, то, во-первых, вы узнаете, что там ShadowBytes отравлены, поэтому вы получите
ошибку и вы имеете два стека, где вы освободили блок и где вы его алоцировали. Ну и последняя такая
забавная штука, мне кажется, она подходит к завершению всей этой истории. Смотрите, вот у вас была
программа, собранная с адресинитайзером. Вы ее собрали с адресинитайзером, потому что вы думаете,
что в ней есть баг, но у вас есть основания верить, что там есть баг, вы хотите его обнаружить. Но ваша
программа сломана, она же плохо работает с памятью, пишет и читает не оттуда. Вот что, если она начала
писать прямо в Shadow Memory? Вот если ваша программа пишет не туда в кучу, то с помощью Shadow Memory
санитайзер это обнаружит. А что, если ваша программа пишет прямо в Shadow Memory? Она же просто
разломает санитайзер. Вот это решается, мне кажется, довольно остроумно, потому что перед
любым обращением к памяти в программе вставляется код с такой проверкой. И вот если вы даже
обращаетесь к Shadow Memory неаккуратно, вот напрямую, то сначала выполнится код, который вычисляет Shadow
Address для Shadow Memory, то есть Shadow Memory для Shadow Memory. И санитайзер так размещает все вот эти
структуры, то есть HIP и Shadow Memory в памяти, чтобы Shadow Memory от Shadow Memory отображалась в специальный
сегмент памяти, на который адрес санитайзер ставит mprotect и запрещает туда записи чтения. И
если вы собираетесь записать в Shadow Memory что-то, то перед этим выполнится проверка, вы вычислите
адрес Shadow Address от вашего адреса, попадете в защищенный блок, и там вы разломаетесь. Таким
образом, санитайзер, он, конечно, понимает, что по одним программам может быть неправильное,
разломанное, но он не даст вам писать в его структуры данных и ломать самого проверяющего. Ну,
это реализовано так, что просто в реализации аллокатора аккуратно подогнаны и подобраны все
адреса. Ну, вот такая история. Мне кажется, очень простой механизм, и при этом очень мощный,
если вы пишете на C++, то вы непременно должны им пользоваться. Нет никаких причин не пользоваться
им при написании хоть сколько-нибудь сложной программы. Мы им пользуемся каждый раз,
но вы им пользуетесь каждый раз, когда в тестах запускается сборка Faulty Tracesun. Там есть Fault
Injection, про который мы сегодня не успели поговорить, и там есть адрес санитайзер, который пытается
увидеть, что Fault Injection привел к тому, что у вас есть кондицион, который привел к разламыванию
памяти. Нет, еще раз, у B, есть у B сам отдельный, который ловит у B, то есть тут не надо
так обобщать, но здесь мы ловим ошибки вращения. Да, это разумный инструмент. При программировании
на C++ некоторые стандарты уже невозможно им не пользоваться, но в нашем курсе у него
такая вот своя особенная цель еще.
