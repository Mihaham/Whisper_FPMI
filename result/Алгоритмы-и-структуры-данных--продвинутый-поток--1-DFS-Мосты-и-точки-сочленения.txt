поэтому в итоге да поэтому начнем мы с такого замечательного сладостного
чарующего выпадительного алгоритма как dfs да наконец-то мы узнаем что это такое
вот ну мало ли да отбор говорит о том что вы сталкивались с этой аббревиатурой да вот
нет и очень-то ладно на самом деле если отставить шутки то в общем-то конечно мы с ним уже работали
потому что мы с вами уже обсуждали деревья как ведь какая нот там деревья там поминали какую-то
динамичку там и так далее и тому подобное вот ну то есть да там вот возможно бы там упустили какие-то
еще пару там каких-то простых моментов но как бы ладно уж то есть наверно сейчас нет смысла читать
вам это это в лекцию типа дети динамическое программирование это там вот это все вот но
кое-что вот но какие-то вот базовые вещи нам дфс и поговорить придется вот ну потому что мосты
точней сочинения но давайте так кто умеет находить в графе мосты так хорошо кто умеет так кто умеет
находить в графе мосты за линию до важного точения так вот правильно правильно правильно так уже
двойне так двое уже не так двое уже не умеют да или просто линии руки подымать ну мало ли
а может это тень кофе изучалась просто да правильно господи что там посещать да да да как
говорится на метод сирийских межнаров изучаем все сами да окей вот хорошо пойдем дальше более
продвинуты повысим планочку кто знает что такое точки сочинения кто умеет их искать за линию
уже уже больше да да да да да да да господи да вот хорошо но тут есть куда повысить планку
а кто умеет искать компоненты реберной двухсвязности а кто умеет искать их за линию ну да глупо было бы
предположить конечно вот а кто умеет искать компоненты вершинной двухсвязности вот а за линию так
ну ладно сирийские занятия будет интересным да я делал даже не в том что сегодня ожидается
дерево доминаторов так кстати даже интересно а кто умеет писать дерево доминаторов вот круто
сейчас нет но как сказать нету я сформулирую так смотрите тут диспозиция такая конечно там
для каких-нибудь олимпиадных целей там будет алгоритм за н логен у нас он тоже возникнет но
возможно какой-то момент то есть идеальный алгоритм который предлагался в оригинале
тарьяном он работает за е на обратную функцию кирмана вот да ту самую шоу в снм но это но без
отсылки на снм да нет там но там возникает сжатие путей и возникает пара интересных теории нет я вам
так скажу я конечно сейчас рискну на каркать но на самом деле раз мы идем в таком хорошем темпе то
как бы есть надежда что мы попробуем изучить действительно откуда высоты шоу это за обратная
функция кирмана и откуда высотами она берется вот за одной здесь нет на самом деле как показывает
практика это не так тоже не так страшно как кажется то есть ну не софт хип реально но вот нет
но я не знаю ну просто я не знаю вы мне кто-то на экзамене софт хипов вообще по-моему уверенно
расписал насколько я помню так что и вот так что соответствует так что да но вот так но вот но
для но вот но правда до этого мы дойдем до все это то есть это все у нас алгоритмы на дфс но для
этого дфс придется по изучать начну давайте вспомним что же вообще такой дфс принципе да
насчитывайте то есть ведем какие-то базовые понятия то есть дфс у нас это такой обход графа
то есть обход графа который работает по принципу вижу куда мы куда мы еще не ходили а ну-ка быстро
пошли вот ну давайте тут давайте воспомним какой-нибудь код то есть какой-нибудь
классический но вот обычно вот как он выглядит жил был дфс так что приходим в вершину в и что
мы соответственно делаем делаем мы следующие значит ну обычно но вот то есть обычно там
появляется какой-нибудь массив юзет в котором мы просто помещаем что мы в эту вершину уже
ходили но мы сейчас поступим немножко по-другому мы скажем что там калор от в равно е дфс грэй
да немножко магии да значит сразу давайте скажем что у нас возникнет о о кайф у нас в этом
семестре две доски классно вот да но обычно просто действительно то есть если вы вводите там
какие-то экзотические понятия то лучше конечно вводите ена да что-то как бы как вы уже наверно
без сомнения знаете дфс часто принято красить вершины цвета да то есть у нас как-то работает то
есть это вот работает там е там дфс калор и здесь перечисляем какие-нибудь константы какие у нас
будут константы константы у нас будут значит е дфс вайт ну я дфс это пишется чтобы они
отличались от других констант каких-нибудь си вот ну чтобы было понятно что это отсюда да так
да на всякий случай уже не надо объяснять штуку я нам да но вот ну естественно да вот ну как кто
из вас продвинутом потоке по плюсам понятно так ну мало так ну ладно ну в любом случае ладно
на знание ена мы это влиять не должно конечно так так значит то есть вот вводим такую красивую
штуку вот то есть да обычно конечно помещается что это 0 1 2 но конечно как вы знаете выбор я
написать 57 179 2007 будет в общем-то тоже самое вот ну не важно но делаем мы это зачем то есть
мы идея в том что обычно белым мы помечаем вершину в которую дфс еще не вошел серым вот
мы помечаем вершину в которую дфс вошел но еще не вышел и в самом конце у нас появляется вот
это вот там соответственно калор от в равно е дфс блэк вот
а действительно так нет ученым мешает что-то кому она до компилятору мешает да вот значит
смотреть for имт у значит граф а то вы ну то есть там если мы пишем просто дфс то обычно тут
обычно получается что и там пишем калор от в равно равно е дфс вайт да действительно
наверное нет а калора туда да значит е дфс вайт то соответственно пишем там дфс от то есть
самый простой дфс будет выглядеть вот так вот можно еще добавить скобочки их можно
обычно сразу добавлять потому что ну на самом деле крайне редко дфс используется
прямо вот чисто в таком виде ну чисто в таком виде он не используется никак обычно да потому
что ну как сказать но даже да обычно такой кодки пишут когда нужно проверить там лежит ли вершина
в компоненте связанности но во первых для этого тогда нам серый черный цвета не нужны откровенно
а во вторых кстати об этом сегодня об этом будем говорить как говорится а что такое вообще
компонента связанности кстати аптечка так вот да вот ваша отношение эквивалентности только по
нот по понятию эквивалентность или понять да или понятие достижимость да то есть мы будем
говорить то есть можно там просто написать определение но я не буду даже его писать я
думаю оно и так очевидно да мы будем говорить что там из вершины у достижима вершина в вот так
вот да но из вершины у ну ладно но то есть там опасно тут крыша так рисовать потому что у нас
тут в дереве доминаторов это стрелочка будет означать немножко другое но тем не менее вот
значит из у может дойти по вершине до вершины в если существует путь и тут мы неожиданно понимаем
чем у нас не ориентированные графы отличаются от ориентированных отличаются они тем что в
не ориентированных графах значит понятие достижимости это отношение эквивалентности
вот вот а в не ориентированных графах неожиданно нет да вот редкий случай на самом деле да что
действительно только то есть на самом деле два теси фиксирность на месте в ориентированных
графах транзитивность тоже на месте да если дойти от можно дойти от удавы может идти от
удавы тоже дойти можно но симметричности там нет вот и с одной поэтому да и но поэтому
значит сразу действительно то есть важный то есть такой момент точно вот то есть желательно
но вот что крыша лужа не желательно ляпать что там если мы говорим об ориентированных графах то
конечно ляпать что там две вершины лежат там в одной компоненте связанности это как минимум
так чтобы быть осторожным вот то есть да понятно когда-то в контексте конечно в
какой-нибудь задачи хочется это обсуждать но лучше сразу оговаривать вот так что
pawnet mantel в ориентированном графе кстати отметим даже в ориентированном графе то есть обычно
есть понятия слабая связанность и сильная связанность значит что такое то есть говорят что там то
то есть слабая связность это говорим, что давайте во всех рёбрах просто отменим ориентацию.
Ну тогда получит обычный ориентированный граф и получит компоненты связности и там и это называется слабая связность.
То есть две вершины слабо связаны, если от одной вершины можно дойти до другой.
Но плевав на направление и есть понятие сильная связность.
Сильная связность.
что такое, то есть мы говорим, что две вершины сильно связаны,
если из одной вершины можно дойти до другой и из другой вершины можно дойти до одной.
То есть можно не только дойти, но и вернуться обратно.
Ну, соответственно, дойти компоненты слабой связности тривиально,
найти компоненты сильной связности за линию умеет, кстати, кто.
Так, спасибо. Так, ух ты, да, не так много, да. Ух ты, как я не пушусь.
Так, для сравнения, кто умеет писать FFT? А, прям все в Петрозаводск уехали, да, или что?
Окей, ну ладно, так, понятно. Нет, просто как-то, да, попрошу, попрошу мы семестра,
там просто мне кажется, что на подобные вопросы тут прям вся толпа будет руки подымать, вот.
Так, хорошо, кто умеет перемножать многочлены быстрее, чем за квадрат?
Хорошо, кто умеет перемножать многочлены за N log N? Ага, нет, знаете, что самое страшное? Нет,
на самом деле, формальный ответ я боюсь, что практически никто на самом деле не умеет,
но я просто для тех, кто знает, сразу скажу. Дело в том, что мы там подразумеваем,
что там есть комплект какие-то комплексные числа, с которыми мы умеем работать как будто
за от единицы, наплевав на точность. Но на самом деле, если там все-таки байтики ограничены,
если это реально анализировать, то там в общем случае придется признавать, что асимптотика
это что-то типа N log N, или что-то в этом роде. То есть на самом деле алгоритм реально за N log N есть,
но это какой-то тоже алгоритм типа 2015 года, насколько я помню. Но так тоже, на самом деле,
мелкая формальная оговорка. То есть мы на эту оговорочку так наплюем, но тем не менее.
На этом мы говорили про связности, отношение к валентности, отношение к валентности у нас,
конечно, сегодня будут играть важную роль. Потому что действительно замечаем, что найти компоненты
сильной связности, конечно, окажется значительно сложнее. Но, конечно же, давайте подумаем,
что еще можно вообще делать DFS. Какое у нас обычно первое? Давайте вспомним какое у нас первое
применение. Так давайте более простой вопрос. Кто умеет искать цикл в графе? То есть дан граф,
найдите в нем цикл или скажите, что его нет. За линию. Но тут смотрите, действительно,
что у нас тут есть. То есть это первая обычная задача, в которой вот эти вот цвета возникают.
То есть у нас там возникает понято, потому что как мы это делаем, например, в ориентированном
графе. То есть на самом деле, то есть где-то вот здесь на самом деле можно там написать,
давайте другим маркером напишу каким-нибудь. То есть что-нибудь там. То есть Элза там,
допустим, если там color atu оказался серым, то, соответственно, я напишу наш лицикл.
В принципе, можно вот уже идентифицировать, что цикл обнаружен. Конкретно его идентификация
может выглядеть так. Потому что вообще заметим, что, ну просто можно заметить,
что в каждый момент времени DFS все серые вершины образуют какой-то нот, ну практически стэк.
То есть обычно в этом месте можно добавлять вершины в стэк, а в этом месте из стэка
доставать. Ну и, например, и тогда кажется, что в каждый момент времени серые вершины
образуют путь из так называемого корня. Вот. Почему я говорю так называемого? Потому что обычно
вот в неориентированном графе понятно, что в каждой компоненте связности вы обойдете всю
компоненту связности. А в ориентированном графе, ну как минимум у нас нет понятия компонента
связности. А вторых, даже компоненту слабой связности вы обойдете, ну если повезет.
Чего? Вот. Ну сильную точно обойдем, да. То есть понятно, мы обойдем компоненту сильной связности,
мы обойдем все, вообще все компоненты, которые из нее достижимы, но там, условно говоря, будет там,
что типа мы обошли вот там что-нибудь вот такое, а вот тут откуда-нибудь еще тут из аута еще тут
какие-то ребра сюда торчат. И эту вершину мы уже, может, и не обошли вполне. А может обошли,
там как повезет. Вот. Это у нас дело известно. Так. Вот. Но тем не менее у нас действительно,
вот. Но тем не менее гарантируется, что DFS цикл найти можно, если просто пробежаться по
всем вершинам и с каждой белой на текущий момент вершины запускать этот DFS. Тогда очевидно цикл будет
найти. Так. А если цикла у нас нет, тогда у нас есть место. Ну тоже надо вспомнить топологическая
сортировка. Так. Что такое топологическая сортировка? Ну да. То есть оказывается,
что если цикла нет, то вершины можно расположить слева направо в таком порядке, чтобы все ребра
прошли слева направо. Так. Ну-ка. Кто умеет такую топологическую сортировку искать? Так. А за линию?
Ага. Хорошо. Так. Ну на всякий случай напомню. Да. Идея на самом деле предельно простая. То есть.
То есть на самом деле вот. То есть идею можно закодировать одной фразой. Просто вот сюда в
конце нужно написать. То есть надо просто завести массив топ-сорт. И когда вы выходите из вершины,
надо в начало этого массива запихать вершину В. Ну можно сказать, что 8-массив это дек на
самом деле эстрелевский. Ну. Нет. Да. Классическая реализация конечно push-back и reverse, но
идейно это push-front. Вот. Идейно это. Ну вот. Да. Идейно у нас, конечно, push-front. Хотя отдельно
могла быть интересный вопрос. Это конечно. Там попробовать. А попробовать теперь доказать,
что такой топ-сорт действительно сработает. Нет. Что он вообще. Нет. Понятно, что DFS работает
за V plus E. Это, конечно, сомнения не вызывает. Нет. Push-front. Нет. Ну мы верим, что push-front работает
за от единицы. Потому что. Ну скажем так. В принципе можно сказать, что это дек. Как я уже сказал. Потом
можем пробежать с форком. Можно сделать push-back и там reverse. Это неважно. Важно другое. Потому что
математически самый интересный вопрос. А почему полученный порядок вершины имеет отношение к
топологической сортировке вообще. Что такое после. Что такое после. Что такое в этом контексте.
Я не понимаю, что это такое. Нет. Ну где-то в реве. Ну вот. Нет. Ну пока смотрите. Нет. На самом
деле здесь пока никаких обратных ревер нет. Хотя, конечно, вы правильно догадываетесь,
чем мы займемся дальше. Вот. Но на самом деле доказать, конечно, все гораздо проще. Потому
что. Смотрите. То есть рассмотрим ребро. То есть будем говорить так. Рассмотрим ребро. Нет. Не так
мы его рассмотрим. Рассмотрим ребро УВ. Давайте его возьмем и рассмотрим. Значит нам нужно доказать,
что вершина У будет идти в этом топ сорте раньше. То есть в переводе говоря вершина УВ мы по
до вершины У. Логично, да? Значит, смотрите, как мы это будем делать. Делать мы это будем следующим
образом. Значит, жила была вершина В. Ну вот. То есть в какой-то момент ДФС пришел в вершину У
и рассмотрел, ну помимо прочего, там поперебрал, поперебрал и нашел вершину В. А теперь давайте
подумаем. Какого цвета вершина В была в этот момент? Ну тогда смотрите, что произойдет если вершина В была
белой. Ну да. Тогда мы просто замечаем, что тогда ДФС просто пойдет в вершину В. Значит что-то там
поработает и выйдет из вершины В, добавив ее в топ сорта. И это происходит до того, как у нас
вершина У закончилась. Поэтому если вершина В была белой, то с этим ребром все в порядке.
Что дальше? Если вершина В была, ну давайте простой случай, черной. Ну поздравляю. Если она черная,
значит она уже добавлена, все, уже радость. А если вершина В серая? Ну не противоречие, а просто это
означает, что у нас налицо цикл. То есть на самом деле, видите, никаких понятий там обратных
вводить не нужно. То есть на самом деле доказательства, собственно, работает и так. Вот. Так что нет. Тут,
в общем-то, все достаточно просто. Вот. Значит так. Что у нас еще? Сейчас все-таки достану тетрадочку,
потому что сейчас я должен сформулировать еще пару. То есть на самом деле тоже очень простых утверждений,
но знать их надо. Ну просто скажем так, просто культурная часть такая. Да, то есть, конечно,
то есть понятно там для всех летали обянников, обычно эти утверждения будут самоочевидными. Вот.
Но тем не менее. Вот. Так. Но с другой стороны, тем не менее, просто диспозиция такая. А кстати,
представьте себе, что вы в 75-м году. Значит, что такое 75-й год? Значит, пока я тут листаю тетрадку.
75-й год. Это когда у нас... 75-й год – это год выхода статьи, вот такой статьи Depth for Search and its Appliances.
Автор статьи, просто хедлайнер сегодняшнего занятия, Роберт Эндрит Ариян. Ну, скажем так,
по-моему, едва ли не все, практически все алгоритмы, которые мы сегодня будем изучать,
пока мы до какого-то момента, на самом деле это алгоритмы Тарьяна. Ну или как минимум соавтор,
то есть, ладно, там, допустим, дерево доминаторов, допустим, у него там соавторстве с кем-то,
но тем не менее. Вот. Но с другой стороны, там, ну вот. Просто вот это интервот. То есть,
это, возможно, едва ли не первая статья, в которой действительно там этот ДФС активно изучает.
То есть, не то чтобы там понятие о том, что граф можно вот так вот обходить рекурсивным образом,
или как минимум дерево. То есть, в принципе, там понятия были и раньше. Вот. Ну я. Чего? Ну вот.
Ну, как сказать, придуман, не гарантирую. Но судя по статьям, выглядит да. Я бы даже больше
скажу. На самом деле, то есть, более того, на самом деле, к моменту 75-го года уже были хорошо
известные и все там, и все там, не только БФС, но и даже там все, все там Дэйкстры, Флойды,
Форды, Белманы, а также все алгоритмы основных, основные алгоритмы основных деревьев.
Потому что это все, это все, ну скажем так, алгоритм Дэйкстрен датируется 59-м годом, кстати. Вот.
То есть, там алгоритмы примокраскала тоже какие-то 50, алгоритм Барувки вообще 26-й. Вот. Да, это да. То
есть, отдельно компов не было, алгоритм уже был, да. Вот. Это вообще, это вообще отдельная песня там.
Вот. Так что, но вот. Поэтому, но вот. Но вот. А в этой статье, но вот. Нет, просто статья интересна тем,
что действительно, то есть, представьте, просто представьте, что если первая статья ДФС, то как бы
это не то. То есть, это вы допустим, олимпиадники, вы где-то там класса седьмого, там максимум восьмого,
там этим ДФС просто пользуетесь просто автоматически, просто кушаете на завтрак там и так далее. Вот.
Поэтому, то есть, для вас это все просто, для вашей среды это просто абсолютно естественно и очевидно.
Вот. А допустим, на момент 75-го года вы пишете статью и там все, представьте, что все это окажется
не очевидно от слова вообще. Там типа, там. То есть, еще придется какую-то тратить энергию,
чтобы понять, скажем, что вот это вот цикл ищет, например. Ну вот. И так далее. Так что тут вот такой
вот интересный момент. И это при том, что, да, в этой статье доказываются какие-то свойства, то есть,
едва ли не рассматривается, как искать цикл, но, конечно, основной ядро, то есть, там, основной
интерес, конечно, этой статьи, это то, что в ней описано, как искать компоненты вершины двусвязности
и внезапно, как искать компоненты сильной связности. Да. Собственно, мало кто знает, но просто окажется,
они ищутся одними тем же алгоритмом. Вот. Ну, как говорится, да, мосты, да, мосты,
то и мосты, естественно, прилагаются. Так. Так, где у меня эта штука-то вообще? Так. Метод
малых пространств. Сейчас. Так, где у меня тут? Давай. Инвериант следующий, что вершины,
значит, там написано как в таком порядке, что все ребра идут слева-направо. То есть, там, ну,
типа от меньшего индекса к большему индекса. Раньше, да. Да, это просто определение понятия
топологическая сортировка. То есть, порядок вершин называется топологическая сортировка, если...
Нет, если вершина В была белая в тот момент, когда мы это ребро рассматриваем,
то тогда ДФС тут же запустится, значит, от вершины В, что-то там поделает, неважно,
что, и выйдет из вершины В, записав его в массив топ-сорт. И это, и согласно устройству ДФС,
это произойдет раньше, чем мы будем выходить из вершины В. Вот и все, собственно. Так что тут
достаточно... Так, вот дерево доминаторов пошло. Классно. Так, вот они у нас мистические леммочки.
Значит, давайте немножко попишем леммочки.
Значит, смотрите. То есть, просто давайте немножко. Тут разные утверждения,
причем тут давайте будем внимательны, потому что, кстати, как показала практика,
там, скажем, у нас мы можем столкнуться с технологическими разногласиями даже.
Потому что, например, там в билет, у вас будет там билет, скажем, лемма о белых путях. Ну вот,
и как, к сожалению, бывали председатели, что мне просто приходит и рассказывает абсолютно не то.
Потому что выясняется, что там почему-то Вики конспектор говорит, можно было подумать,
что лемма о белых путях это что-то другое. Вот. Ну там действительно есть там что-то подлянка,
что там не две вещи называются леммами, поэтому так. Так, ну так, смотрите, леммочки. Значит,
давайте попробуем просто пока прописать. Да, то есть, немножко простые. Вот. Значит, в принципе,
я, то есть, доставлю я вообще. Вот вы тут, конечно, сейчас вот обсуждали, куда может вести ребро и
так далее. Но на самом деле можно даже, в принципе, сформулировать такое утверждение. Не существует
момента времени. Ну, тут имеется в виду, что мы запустили ДФС. Ну, в каждый момент времени ДФС
находится в какой-то вершине, и какие-то вершины покрашены там в серые, какие-то в черные, какие-то
в белые. Так вот, не существует момента времени, в который есть ребро из черной вершины в белую.
Ну, скажем так, да. Нет, тут договоримся. В такой реализации, да. То есть, конечно, в реориентированном
графе тут придется еще писать оговорку, по какому ребру мы сюда пришли. Да, именно ребру,
чтобы, если мы хотим еще и кратные ребра покрывать. Да, если нет кратных ребра, конечно, достаточно
просто там вершину плыли писать, но эти детали мы сейчас опустим для простоты. Сейчас речь не
об этом. Значит, давайте поймем вот это лемма. Хотя тут сразу даже интересно, а что, там ребры
из черной в серые бывают? Ну, действительно, лемма доказывается, конечно, очень просто,
потому что, как бы, только вот рассмотрим момент времени, когда мы вершину вообще только что
покрасили в черный цвет. Спрашивается только, значит, тогда перед этим мы пробежались по всем
ребрам, торчащим из нее, но если мы там видели белую вершину, мы, она, эта вершина ровно в
этот момент времени белый быть переставала, правда. Ну, собственно, в общем-то, доказательства на этом
заканчивается. Но возникает вопрос. И более того, кажется, что если мы в нее пошли, по выходу из нее
она становилась не просто серой, а еще и черной. Вправивается. А может ли быть так, что, а может
ли вообще в какой-то момент времени существовать вообще ребро из черной вершины в серую? Да, каким образом?
Чего? А, прям из двух вершин? Нет, из двух не хочу. Нет, на самом деле давайте просто можно и
более общий пример спокойненько привести, на самом деле. То есть просто рассмотрим вот просто
обычный цикл. Смотрите, тогда запускаем ДФС из этой вершины, и тогда у нас серыми становятся вот
тут все вершины. Серая, серая, серая, серая. И упа, тупичок. Вот. Более того, в этот момент мы
красим тогда, значит, мы начинаем их, видите, красим вот эту вершину в черный цвет. Ну, вот вам и ребро.
Ну, я, нет, я поэтому тут текстом и написал. Да, это уже, нет, смотрите, в этой лемме подразумевается,
что мы просто запустили ДФС и ничего дополнительно не делаем. То есть, ну, здесь, допустим, нашли цикл,
обычно не подразумевает, что обычно мы там прям резко выбросились с криком ай-ай-ай. Точнее,
наоборот классно. Вот. Да, ну, понятно, что зависит от задачи, там в разных задачах надо разные вещи
делать, но вот. Вот, но здесь просто мне хотелось показать, что вот да, что ребра из черных вершин
в серую могут быть, конечно, от слова вполне. Более того, а могут быть даже одновременно из вершины
торчать ребра как в серую вершину, так и в черную, в общем, никаких проблем нет, правда. Ну, там,
пожалуй, там, я не знаю, например, вот как, ну, например, самый тупой пример вот такой, там,
может, могут быть и другие примеры, это, в общем, не очень интересно. Значит, такая вот лемма. Значит,
что у нас тут еще? Так, а вот тут, так, вот давайте попробуем еще писать. Значит, какие у нас еще вещи?
Так, а вот второй леммой как раз идет то, что у нас будет проходить под названием лемма о белых путях.
Так, сейчас такая немножко сложная, сейчас будет это сложно сочиненная лемма. Вот.
Вот, значит, смотрите, говорится, ничего себе. Да, значит, тексты будут. Значит,
значит, ладно, напишу так, рассмотрим моменты времени. Значит, ладно, рассмотрим моменты времени.
Когда вершина, там какая-нибудь вершина В, абсолютно произвольная, была покрашена
в серый и черный цвета.
Так, да, пусть это первый и второй момент времени. Так, ну, здесь я напишу короче,
ну, давайте просто обозначение ввожу. Пусть это там, допустим, ТВ, там С и ТВ, нет, ТВС,
нет, ТВР и ТВБ, нет. Слушайте, а действительно, да, как называют эти времена олимпегики,
олимпегики их называют триентраут, да, да, вы абсолютно правы, да. Так, еще что-то изобретать
велосипед, да. Формально я должен был, видимо, чуть позже сказать, что, что такое триентраут,
но думаю, вы так или иначе, так или иначе мы с этим сталкивались, а в прошлом семестре.
Теперь не сталкивались? Ну, когда, нет, когда мы запускали ДФС по дереву, мы говорили, что у нас
есть время входа и время выхода. Давайте я тут формально, обычно в этом месте возникает такой
код. Значит, смотрите, вот сюда вставляется стрелочка, то есть вот мы будем называть time in,
значит, от В равно, так обычно тут пишут current time++, вот, ну вот, ну а сюда, соответственно,
вписывается time out равно current time++, вот такая красота здесь, вот, то есть это на самом деле
просто определение, но вводящееся в том числе естественно, ну хотя нет, Тарьян, кстати,
знаете, я так вам сразу скажу, Тарьян, кстати, не вводит определение time in и time out, мы будем
пользоваться, потому что мне кажется так органичнее, но Тарьян в дереве доминаторов будет говорить
вообще наглую вещь, он говорит, а давайте запустим ДФС и переименуем вершины вот по time in,
и начинает потом леммы даже в этом виде сформулировать, так что будете читать статью,
имейте в виду сразу, потому что там без этой оговорки, естественно, там какие-то
основополагающие леммы будут тупо неверные, вот, соответственно, да, но в принципе вот часто
в ДФС, то есть там, я думаю, ну вот, хотя интересно, хотя ладно, если вы не писали там, допустим,
если вы никогда не искали мосты и точки сочленения, по крайней мере кто-то из вас, то, возможно,
вы в произвольных графах time in и time out не пользовались, хотя с другой стороны, а как же вы
еще определяете, является ли вершина предком другой, заприкалька, нет, заприкалька из-за
квадрата, да, подняться из одной вершины на нужную высоту с алгоритмом там двоичным подъемом,
да, тем более, что мы эти золотые единицы уже умеем делать, да, хотя правда маленькая оговорка,
так, я сейчас слета не помню, но, по-моему, в этом алгоритме, в алгоритме Ancestor Queries, мы там
нигде не пользовались тем, что мы умеем искать, это проверять золотые единицы, является ли вершина
предком другой, ой, а может даже и не пользовались, кстати, да, чего, ну, не важно, ладно, в общем,
короче говоря, на самом деле, вот есть понятие время входа, время выхода, да, то есть мы говорим,
что у нас есть, если у нас там n вершин, то у нас есть два n момента времени, то есть в которое мы
входим вершину и выходим, собственно, пишется это вот буквально так, ну, я там, инициализация
простая, да, что там, изначально current time равен, например, нулю, хотя если он будет равен 57,
тоже большой беды не случится, вот, далее, значит это, значит, time in, time out это полное название,
чаще, конечно, пишут time in, time out для краткости, мы будем использовать оба обозначения, вот, так вот,
так вот, пусть у нас есть time in от v и time out от v, да, даже, вот, так даже еще круче, тогда,
значит, какие у нас тут утверждения начинают быть верны, значит, что мы будем считать леммой о
белых путях, значит, будем их считать так, значит, во-первых, значит, так, ладно, напишу,
как есть тут, значит, вершины графа g без v, то есть все остальные, бывшие черными, так, бывшие
черными и серыми в момент времени t и на t будут таковыми и в t out от v,
это такой первый утверждение, ну, как доказать, но имеется в виду, что черные вершины останутся
черными и, собственно, это самая-таки реальная часть, серая вершина останется пока серой,
ну, в принципе, это логично, потому что кто такие серые вершины в тот момент времени t и на t, да,
то есть это просто в точности stack до вершины v, то есть из этих вершин у нас идут рекурсивные
запуски и мы эти вершины не перекрасим, пока мы не выйдем из вершины v, так что, да, это дот,
то есть утверждение там может быть достаточно простое, вот, но, значит, а вот дальше начинается
уже интересное, так, вершины, значит, g без v бывшие белыми, бывшие белыми в момент времени t и от v
будут, будут в момент времени t и от v, так, да, но, первым заметим, что серыми они быть не могут,
потому что когда мы будем выходить из вершины v, там, то серыми в момент времени t будут ровно
те, кто были серыми в тейне, правда, вот, но это не все, да, это я сейчас напишу, но сразу готовить,
это не все, то есть будут они либо белыми, либо черными, причем они будут черными тогда и только тогда, когда
ну да, то есть, ну вот, причем они будут, ну, вершины, когда я тут пишу вершины, это, конечно, да,
формулировка не очень хорошая на самом деле, потому что может вести тоже в заблуждение,
правильнее было бы написать, конечно, так, то есть произвольная вершина u, она, ну,
которая была белая, она будет либо белой, либо черной, причем будет она черной тогда и только
тогда, в чем тонкая разница, что может возникнуть ощущение, что тут все прям вершины будут либо
белыми, либо черными, это, конечно, не так, вот, то есть, как бы неверно, что там все белые вершины в
момент времени t и на твои вершины, они там в t, а вот от v прям неожиданно перекрасится, но каждая конкретная
вершина, она перекрасится в ч, тогда и только тогда есть путь из v только по белым вершинам,
поэтому это называется лемма о белых путях, вот, то есть важный момент, что не просто есть путь,
а есть именно белый путь. Объясняем мы это так, значит, кто в момент времени t и на твои серые вершины,
те, кто находится в этот момент в рекурсивном стеке, ну у нас серый вершин в каждое времяrop
eka в рекурсивном стеке находится, вот говорим себе. То есть, когда мы t и на твоей, это момент времени,
когда мы добавляем вершину в это рекурсивный стек, то есть вот у нас есть верно. А теперь
заметим следующее, что такое момент времени t!!] это значит, что мы зашли вершину v побегали,
побегали, побегали, побегали, все, что-то еще подобавляли в стек, мы все подостали и теперь еще и
и достает вершину В. То есть это означает, что в этот
повитрение серыми будут ровно те же, кто у нее там
раньше лежал. Вот. То есть просто вот такое логичное
устройство. Вот. Так что вот такие вот у нас еще леммы
возникают. Так. Ну что, есть ли тут еще какие-то вопросы?
Так. Ну тут пока, да, тут пока вроде нет, ну и действительно
откуда тут еще их пока. Действительно, некуда,
не откуда им взяться. Так. Ну что у нас еще есть? Но
действительно тут уже кто-то упоминал. Конечно, на самом
деле можно еще заметить, что так как у нас ДФС это
обходит не дерево, то на самом деле ребра начинают
конечно, то конечно у нас возникают еще какие-то
свойства, связанные с тем, как ребра, по которым
ДФС, так сказать, не пошел вообще устроена в этом графе.
И что из этого можно сделать? Ну, значит, для этого просто
давайте введем классификацию ребер относительно ДФС.
Значит, ДФС, ну когда, значит, классификация, значит, сразу
предупрежу, она может отличаться от той, которая там вам когда-то
может быть водилась. Потому что понятно, что вы когда-нибудь
там сталкивались с понятиями там обратной ребротом, например,
обратное ребро точно. Перекрестное не гарантирует, а вот обратное,
наверное, сталкивались. Но мы введем определение так.
Значит, мы будем говорить, что в первую очередь, если мы запустим ДФС,
в чем ДФС запустим по принципу, там пробежимся по всем вершинам,
что если там color от V равно-равно там EDFS white, то, соответственно,
там DFS от V. То есть я имею в виду, что мы железно запустили
ДФС так, чтобы по всем вершинам пробежались. Так вот, значит,
тогда первое, что появляется в графе, это то, что я буду
называть ребра дерева ДФС или ребра леса ДФС. То есть это, собственно,
ребра, вот эти вот ребра, по которым ДФС, собственно, пошел.
Вот. Ну, то есть очевидно, что эти ребра образуют лес. Вот.
Так, вот так, вот так, тут еще, рядом еще бамбу-ча. Так, вот какая-нибудь.
Еще такие бамбу-ча. Вот. Вот. Значит, это у нас будет называться ребра дерева ДФС.
Но помимо них у нас будут еще другие ребра. Какие у нас еще ребра бывают? Бывают ребра,
которые соединяют какую-то вершину с ее потомком. Но при этом это ребро в дерево ДФС не вошло.
Это может быть выглядит так, может быть выглядит так, может даже вот так, там кратные ребра бывают.
Ну и из корня, конечно, тут все что угодно может идти. Что? Предки корня. О, Господи. Ну, знаете,
так. Ну нет, тут как мыслить, что такое предок. Знаете, это прикол, да, там команда КВМ поет
там песню действительно про родителей. Там добра песня про родителей. Давайте,
давайте может быть споем про наших предков. Давайте homo erectus. Ну вот, там спасибо,
что ты был, что ты там взял камень к палке и прикрепил. Давайте предков всех животных,
а там, ну вот и там до большого взрыва дошли. Ладно, это я, к сожалению, сейчас не воспроизведу.
Рекомендую отдельно, потому что уже закончилось тем, что они начали петь Оду просто ничего,
по принципу. А что было до большого взрыва? Ничего, спасибо, что ты был там. Ну и так далее.
Вот, ладно, так вот, эти ребра мы будем называть прямые. Значит, что еще бывает? Бывает еще ребра,
которые наоборот. Да, если мы говорим об ориентированном графе, то бывают ребра,
которые соединяют предка наоборот, потомка с предком. Ну вот, да, эти ребра, то есть вот как-то так,
ну на абсолютно произвольную высоту это может происходить. Вот так. Значит, такие ребра у нас
будут называться обратными, да, я для них еще и цвета ввожу. Ну, впрочем, я надеюсь, что, ну,
собственно, я думаю, там все соответствующие алгоритмы, я надеюсь, мы сегодня обсудим,
поэтому как бы это будет такое локальное обозначение. Вот, значит, это у нас ребра,
значит, обратные ребра. И есть, конечно, все остальные, которые соединяют непредка с непотомком,
непредка непотомка с непотомком непредка. Дальше смотрите. Да, то есть это вот какие-то вот такие
вот веселые ребра. Зелененькие, красивые, зелененькие, радостные. Ну, что сразу мерзкие,
нормальные ребра. Вот, ну, смотрите, да, тут, смотрите, значит, еще важный момент на уровне
нашей с вами договоренности. Да, ну, во-первых, да, эти ребра называются перекрестными, я их так и
напишу. Перекрестные. Значит, смотрите, прикол. Значит, они называются перекрестные ребра. Значит,
да, я их тут, вы можете заметить, что я их почему-то все эти ребра рисую справа налево. Так вот,
это не случайно, потому что нам очень удобно будет мыслить, то есть рисовать, знаете как,
то есть рисовать, что как будто, то есть воображать, что когда ДФС шел, он как бы шел слева направо.
То есть он как бы ДФС, во-первых, начался с этой вершины, сначала пошел сюда, потом, потом сюда,
сюда, сюда, значит, там вернулся сюда, потом сюда, дальше там сюда, сюда, сюда, ну и так далее. Вот.
Вот. Тогда в таком предположении, в таком предположении действительно оказывается,
что все перекрестные ребра будут нарисованы справа налево. Ну, неграмотно, не совсем грамотно
так говорить, это, конечно, уже известные нам шутки, знаете, помните, это там мальчик,
который не знал сторон света, каждый, там каждый лет смотрел, как птицы улетают направо, вот это
все. Вот. Ну, как бы нам не очень хочется говорить. Вот. Поэтому мы эту зеленую лему сформулируем
немножко по-другому. То есть лемма, значит, пусть, ой, нет, зря я, вот в этом месте я пишу зря, конечно.
Так, ой, интересно, мне эта лемма там под номером проходит или? А, на самом деле, проходит. А, проходит.
А, то, что я хотел написать, она называется, а, ну ладно. А, хотя нет, она никак не называется,
поэтому могу писать. Ладно. Значит, смотрите, в общем, короче, давайте еще просто леммочка.
Но давайте, важное для нас замечание, если ребро УВ перекрестное,
вот, то неожиданно выясняется, что таймин от У, он больше, чем таймин от В. То есть в экшену У
мы зашли позже, чем зашли в экшену В. Ну, в общем-то, это логично, да? Ну, почему так? Ну, просто потому,
что предположим, что мы в экшену У зашли раньше. То есть мы зашли в экшену У, а в экшену В еще ДФС не заходил,
то есть она белая. Ну, тогда как бы, в принципе, да. Хотя в данном случае можно было и попроще.
Ну, в данном случае можно просто заметить, что тогда заметим, что вершина В уж точно будет обойдена до
того, как мы бы. Ну, вот, точнее так. Отсюда следует такое, что очевидно, что вершина В будет по любому
потомкам вершины У в дереве ДФС. И как следствие, это ребро окажется либо прямым, либо ребром дерева
ДФС, либо прямым. Вот так. Ну, на самом деле, смотрите. Ну, во-первых, тут еще неожиданно, раз мы
тут ввели понятие тайм-ин и тайм-аут, то в принципе, кстати, еще там для, чисто для формулировки,
оказывается, удобно еще можно ввести понятие тайм-сегмент. Да, просто отрезок времени,
просто отрезок на числовой прямой такой просто. Вот. Потому что, ну вот. Ну, потому что возникнет
такой чисто практический вопрос. Так, ой, мне тут все так, что мне похоже, а мне тут все понадобится.
Еще я пошел. Так, так. Значит, смотрите. Потому что, на самом деле, возникнет такая идея, что нам
вообще-то по ребру хотелось бы уметь определять. А вообще какое оно? Оно там дерево ДФС, оно прямое,
оно там вообще обратное, перекрестное. Как мне вообще это сделать?
Нет, ну не просто рандомный граф, а мы запускаем там ДФС. Вот. Ну, в принципе, да. Ну, вот. Да,
ну надо смотреть. Ну, на самом деле, можно заметить следующее, что, ну, во-первых, для этого нам нужда,
ну, ребро дерево ДФС идентифицируется просто, да. Ну, на самом деле, так. То есть, просто можно
вообще в принципе заметить, что у нас потомок, то есть у нас обратные ребра, которые тут ведут из
потомков предка, да. Прямые ноты, которые идут из предков потомка, а перекрестные все остальные.
В общем-то, если бы у нас было просто дерево, мы бы умели, мы это легко определяем. Я даже не
буду выписывать лему, да. Потому что мы помним, что если мы запускаем, например, на дереве ДФС и
проверяем, кто у нас там тайм-ин и пишем тайм-ин, тайм-аут, то мы помним, что там вершина У является
предком вершины В, если тайм-сегмент от В является под отрезком тайм-сегмента АТУ, правда. То есть,
как бы, то есть мой отрезок содержится в отрезке моих предков, в моем отрезке содержится отрезки
все моих потомков, а со всеми остальными я тупо не пересекаюсь. То есть, как бы, это вот вложенные
отрезки. Да, я, пожалуй, не буду даже писать лему. Я думаю, да, будет, на самом деле, можно на самом деле
здесь попроще. То есть, единственное у нас с этой точки зрения проблема будет это отличить прямые
ребра от ребер дерева ДФС. Но как это работает? Ну, работает это вот, давайте вот, можно код немножко
расширить. Ну, смотрите, нет, просто как будем записывать? Потому что нет, мы это будем делать
просто в порядке ДФСа. Вот. Потому что, ну, на самом деле, какой-нибудь так ДФС можно записать
действительно там следующим образом. Даже, ой, давайте, можно, конечно, можно писать ИФ, но вы
изучили еще один продвинутый оператор С++. Ну, это какой? Ну, вот. Ну, вот. То есть, да, давайте,
вот так. То есть, как он пишется? Он пишется так. Значит, switch, соответственно, color от U. Ну,
тут я блок, пожалуй, напишу. Вот. Так. Значит, пишем, соответственно. Значит, пишем. Значит,
case E DFS white. Вот. Ну, тут обычно мы пишем, что, значит, там VU это, соответственно, ребро дерева ДФС.
Так, что мы тут дальше делаем? Ну, там обычно в этом месте, собственно, ДФС от U запускаем.
Так. Ну, и не забываем о том, что надо еще обязательно бряк писать. Помним, да, что switch,
как бы он вещь такой, кейс это просто метка. Вот. Так, что у нас еще? Так, кейс, если у нас,
нет, неправильно пишу. Как говорится, как правильно писать? Правильно писать, конечно,
рыженьким. Case E DFS gray. Вот. То, значит, в этом случае VU обратная. Вот. Ну, там можно что-то
с этим делать и тоже бряк. Вот. Так, что у нас еще есть? Так. Нет, в черном случае ребро дерева ДФС мы уже
обошли. То есть надо теперь отличить прямое ребро от перекрестного ребра. Вот. Ну, тут на самом деле как
повезет. Поэтому я, так как у нас пока сомнения, я напишу красненьким. Так. Давайте. Case E DFS black.
А, ну да, можно было, да, логично, наверное, черным было написать. Case DFS black. Ну, теперь как отличить?
Как теперь, как мне теперь отличить прямое ребро от перекрестного ребра? Ну да. Ну, давайте вот
просто наши лем, зеленые лем мы и воспользуемся. Если оказалось, что... Нет, стоп. Так. А, ну да,
собственно, если, ну вот. То есть, да, если оказалось, что у нас, да, тут у нас немножко... Ой, давайте лему
переформулируем тут. Вот. Нет, просто либо тут переписать, либо DFS, ну как бы, да. Вот. Значит,
таймин от В должен быть больше. То есть, если оказалось, что таймин от У меньше, чем таймин от В,
то что? То значит, ребро ВУ перекрестное. Ну вот. В противном случае. То есть, иначе ВУ прямое.
Так. Ну вот. Уже не надо. Нет, ну как бы, да. Нет, все гораздо проще. Ну, потому что, скажем,
прямое ребро это наш потомок. То есть, мы как бы в него сходили, потом вышли. Поэтому, ну вот. То
есть, это означает, что таймин от У будет просто по-любому больше, больше, чем мы. Все. Так что,
на самом деле, проверять таймал даже не надо. С этой точки зрения, конечно, может быть, мы... То есть,
мы на самом деле здесь вот эти прямые ребра не очень корректно рисуем, кстати. То есть,
на самом деле, конечно, можно, ну просто, чтобы... Нет, ну не... Да, потому что, конечно, корректнее
было бы их, конечно, вот как-то вот так-то рисовать. Ну, скажем так. Дело в том, что для того,
чтобы это ребро стало прямым, мы должны были сначала вот по этому пути пройти, вернуться,
а потом уже вспомнить, что это ребро есть. Я вот это имею в виду. Раз уж у нас тут такая технология,
поэтому вот так. Вот так вот надо. О, ребро есть неоткуда классно. Так. Ну вот, вот это вот. Ну и
так далее. А вот здесь хорошо нарисовано. Так. И вот так еще можно. Арабский ДФС. Нет, ну да, там
была лекция, что всю математику, на самом деле, в какой-то момент арабы в математике были,
там гораздо продвинутее европейцев, но потом что-то пошло не так. Ну да. Какой из... Вот.
Значит, ваупрямо. Значит, соответственно, вот мы уже научились определить перекрестные ребра,
прямые ребра. Значит, и какие-то вот так. Значит, и конечно так, что у нас так... Что-то я еще забыл.
Вот. Да, то есть, в принципе, вот у нас есть действительно какие-то такие ребра, мы действительно
можем изучать их какие-то свойства. Мы, собственно, нам, собственно, придется как-то этим пользоваться.
Но, с другой стороны, важный момент, потому что... Важный момент, что все это, верно,
это все такая красота в абсолютно ориентированных графах. Значит, давайте подумаем, а что... Чем
будет отличаться неориентированный граф? Ну, в некотором смысле, да. То есть, ну, во-первых,
давайте... Да, в неориентированном графе вообще удобно считать, что граф связан. Потому что,
если он не связан, то мы обычно там просто в каждой компоненте связанности будем жить независимо. То
есть, ДФС у нас, очевидно, в неориентированном графе обойдет всю компоненту связанности. То есть,
не будет каких-то еще там доп-ребр, которые откуда-то ведут. Видите, у нас тут вот перекрестные ребра
вот эти вот идут из соседних деревьев. Да, вот эти. Вот тут очень, да, вот это вот важные моменты, да. То
есть, тут произвольно абсолютно могут идти. Вот. Тут этого не будет. То есть, в неориентированном графе у
нас все деревья независимые, не связаны никак с друг с другом. И у нас, внимание, нет перекрестных ребер.
То есть, можно еще ввести такую леммочку, еще одну зеленую лему. Лему 4 даже можно написать ее. В
неориентированном графе нет разминки. Перекрестных ребер. Ну да, как это.
Вот. Так. Ой. Вот. Так что вот такая. Да, а почему это так-то вообще? Ну, потому что,
по определению, перекрестные ребра, это те, которых нет в неориентированном графе. Да, замечательно.
Нет, если оно было таким, тогда да, по определению. Ну да. Рассмотрим ребро. Рассмотрим момент времени,
когда мы впервые вошли в какую-то из его вершин. Вот. Утверждение. Вторая вершина
будет, по-любому, станет потомком. Ну да. Либо прям ребенком, либо потомком. Вот. Да. То есть,
просто такое утверждение. Поэтому перекрестных ребер нет. То есть, все ребра, кроме ребра дерева,
соединяют нас либо потомком с предком, либо с предком с потомком. Причем, более того,
в неориентированном случае, это еще и одно и то же. То есть, прямые обратные ребра, они так идут,
в общем-то, вот так вот вместе. Вот. То есть, можно их как-то вот так вот нарисовать. Вот. То есть,
это типа одно и то же. Но мы, соответственно, мы не будем, соответственно, рисовать прям
двуцветные ребра. И просто будем по умолчанию считать такие ребра обратными. Вот. То есть,
поэтому это обычно имеется в виду, когда говорят о том, что в неориентированном графе есть только
ребра дерева DFS и обратные ребра. Вот. И это нам, собственно, иногда в некоторых задачах и начинает
очень сильно помогать. Ну, как минимум, там базовые задачи, которые, на самом деле, как выясняется,
почему-то в школе там не сильно умеют решать. Это какие, вы знаете, вот встречали вы когда-нибудь
такие задачи с каким-то таким веселым сюжетом в духе там дан связанный граф, в котором там
количество ребер не более чем количество вершин плюс пять. Найдите что-нибудь там, я не знаю. Нет,
просто я помню, я даже сам пару задач таких давал на самом деле когда-то. Ну да, нет. Вот
у меня такая была. Нет, у меня в свое время была, ой, не надо это, надо ли это. Ладно. Не надо было
это, может. Нет, я просто эту задачу когда какие-то контесты иногда даю. Нет, ну просто нет. Ну,
на учебное. Но не важно. Нет. Задача теперь такая. Дайте, вот была веселая, но выясняется,
что там не все умеют справляться. То есть, задача такая. Дан граф, количество е в нем не более чем
в плюс один. Скажите, пожалуйста, а сколько в нем циклов? Вот. Вот такой момент. То есть,
на самом деле, просто если... То есть, на самом деле, как задачу решать? Ну, во-первых, проверяем,
что если е равно в минус один, то циклов нет. Ну, простых циклов имеется в виду. Да, спасибо за
уточнение. Да, естественно, имеются в виду простые циклы. Да. Если е равно в просто тогда цикл железобетонно
один. Мы его даже можем вывести там при желании, но он один. И вот начинается действительно интересный
вопрос. Причем, кстати, его достаточно просто вывести, потому что возьмем вот это обратное
ребро и, в общем-то, вот оно цикл нам и гарантирует. А дальше начинается момент. А как найти,
например, второй нот? А что делать, если у нас е равно в плюс один? Или что-то уже самое?
Обратных ребер в графе два. Ну да, то есть, тут, конечно, начинаются какие-то случаи, которые надо
как-то хорошо рассматривать. Потому что у нас есть два обратных ребра, у них есть пути. Вопрос,
связаны ли эти, пересекаются ли эти пути как-то по вершинам? И тут надо проверять, потому что самый
простой случай для нас — это если эти пути не пересекаются. То есть, например, вот как-то вот так,
например, эти обратные ребра устроены. Или там вот как-то вот. То есть, может быть, как-то вот так
там дерево устроено. Может быть, как-то вот так. Или там это ребро потомок вот этого и так далее.
Если они не пересекаются или там как-то вот хорошо соприкасаются, то циклов у нас там, оказывается,
два. Вот. Ну, в принципе, кстати, да, если они именно соприкасаются по одной вершине, то,
в принципе, да, то вот вам, пожалуйста. То вполне себе оказывается, что циклов два. Но если у них
есть общее пересечение, то есть, если эти циклы пересекаются по какому-то пути, то тут, конечно,
момент. Ну, то есть, на самом деле так. Задачи я не буду сейчас разбирать все случаи. Ну, вот. Ну,
там какие-то возникают. Но суть заключается в том, что у нас, то есть, граф будет устроен так. То есть,
у нас есть будут какие-то две вершины, соединенные тремя путями в итоге. И от них там какие-то деревья
расходятся. И теперь остается только вопрос. Сейчас.
Нет, может задача не так формулировалась. Сейчас надо спорить просто. Ну, хотя да. Ну, ладно,
задача по-другому формулировалась. Не важно. Вот. А, ну, вот. А, ну, вот. А, там был вопрос. С
какими способами можно удалить. Там можно такую задачу дать. С какими способами можно удалить
два ребра, чтобы граф остался связанным, например. Вот. Ну, например, так. Да. Ну,
например, да. Понятно. Вот для этих двух циклов просто найдите длину цикла. В чем длину цикла
найти очень просто. То есть, просто запустим ДФС, посчитаем глубины в ДФС. Правда? И тогда тут
как бы количество ребер тут найти легко, как разность высот плюс один. Вот. Тогда тут будет
произведение. Дан связный граф. В нем там, допустим, е равно в плюс один. Хочется удалить
там два ребра так, чтобы граф остался связанным. Спрашивается, с какими способами можно это сделать.
Нет. Ну, как сказать. Наверное, не очень хочется, наверное, тут вспоминать. Я тут
спросил, как искать мосты. Да, это, по-моему, подняли руки не все. Так что тут такое. То есть,
это надо еще вспоминать. Там, конечно, алгоритм простой, конечно, но тем не менее. То есть,
проект надо вспоминать мосты, надо вспоминать еще там желательно какие-то свойства знать,
половину из которых вы докажете в домашнем задании. Вот. Это так. Вот. Ну, вот. Но если они
пересекаются туда, тут, конечно, понятно, что надо как бы удалить какие-то два ребра из вот этих
трех путей, но при этом не из одного. Нет. Ну, ответ, конечно, понятно. Ну, там самый простой
способ найти ответ, это два простых способа. Либо есть найти длинные этих трех путей и сказать,
что ответ это типа это на это, плюс это на это, плюс это на это, например. Или там можно было
сказать, что тут ответ ССН по два, минус СС, все вот это по два, минус СС, вот это по два,
минус СС, это по два, минус СС. Можно так, например. Ну, то есть, в общем, десятью способами какой
вам удобнее. То есть, самая фишка в задаче будет только вот эти пути найдите. То есть, там вам
придется рассмотреть случаи, потому что там как-нибудь... Ну, например. А, ну, то есть,
самое тупое, это можно сделать, когда вот тут еще две... То есть, вот как-то вот так. И это рыжее
ребро, допустим, идет вот куда-нибудь вот сюда. Тогда вот это пересечение, вот оно вот здесь. Видите,
да? То есть, например, да. То есть, ну, там, ну, честно скажу, то есть, на самом деле в подобных
задачах, там один из самых удобных лайфхаков, это взять все вершины, с которыми соприкасаются,
значит, вот эти обратные ребра. Объявить типа у нас. Назовем вершину хорошей, если вот у нее есть
обратное ребро. Вот тут или там вот еще. Точнее так. Вот тут и вот тут. Да, у нас тут их два такие,
две такие ребра. Ну вот. И потом сказать, что давайте еще объявим хорошей, допустим, еще вершину,
являющейся LCA каких-то двух хороших вершин. Вот. Ну, вот. Ну, то есть, так. То есть, там по большому
счету, то есть, вот эти вершины оказываются на самом деле достаточно. То есть, важными оказываются
именно эти вершины, по большому счету. Потому что, по сути, оказывается, что это просто, то есть,
эти вершины соединены между собой какими-то путями, на которых там висят какие-то деревья. И обычно там,
с точки зрения, часто с точки зрения задачи, оказывается, что эти деревья там уже не принципиально.
Ну, там разные задачи были, потому что там, не знаю, то есть, фишка была, когда я там просто даже
на квалификации какого-то года дал просто задачу вот на это. А потом приехали на полуфинал,
и там Гена Короткий мечтал задачу на это. Вот. Ну, не такую же, естественно. Но как бы вот оказалось,
что вот, как говорится, сюжет, как говорится, то есть, в принципе, сюжет вот иногда нет-нет и
это появится. Вот. То есть, там все что угодно. Потому что там вообще, если ребер не много там,
например, будет там их лишних пять, то там бывают там запросы в духе, даны две вершины,
а сколько между ними простых путей существует, например. Ну да, да, да, да, да, да, да, да, да,
и качаешь, и можно, да, да, да, тут, да, все, да, то есть, все что угодно, то есть, развлекаться можно
бесконечно долго, да. То есть, конечно, можно там покопать в историю, потому что, конечно, если там,
видимо, сейчас прийти на членов дать такую, то там, возможно, задача будет отвергнуть с формировкой.
Этого было уже миллион раз. Там такое, так что вот. Так. Вот. Да. Есть вот такие вот эффекты,
тоже поговорили немножко. Значит, ладно, надо тогда переходить. О, они перейтили нам к перерыву. Да,
пришло время перерыва, пожалуй, да. Ладно, значит, мы рассмотрели, соответственно, какие-то достаточно
базовые вещи. Теперь мы расслабляем нот. Значит, теперь перейдем к каким-то уже, значит,
более продвинутым алгоритмам. Значит, ну, на самом деле, как я сказал, сейчас мы с помощью
DFS изобретем просто, ну, не мы, а вслед за Торианом, соответственно, изобретем метод, который будет
одним просто одним махом искать практически все. Вот. Ну, у нас получится, конечно, что это будет,
но вот опять их будет три, поэтому получится будет уровень easy, уровень medium и уровень hard.
Как же мы это будем делать? Чего? Чего? Поиск элеробцикла? Нет, это да. Это тоже DFS,
но немножко другой. Хотя да, надо будет его тоже упомянуть в какой-то момент. Но сейчас давайте
пойдем по основной магистрали. Ну, во-первых, ведем определение. Сейчас мы некоторое время будем
говорить о неориентированном графе. Значит, определение такое. То есть мы говорим, что у нас,
значит, граф пока неориентированный. Так вот, значит, определение. Ну, с одной стороны, у нас
есть такое понятие, значит, как мост. Что такое мост? Значит, ну, пишем прям по определению. Да,
мост – это ребро, удаление которого
приводит к увеличению количества компонентов связности. Ну, и да. Ладно, сказанул, ну, что делать?
О, поместилось. Вот. Вот. Значит, есть у нас действительно такие вот простые вещи. Вот.
Значит, что у нас еще есть? Вот. Ну, в принципе, вот было бы интересно, конечно, научиться в
неориентированном графе как-то такие мосты искать. Вот. Но рядом с ним у нас, конечно,
будет находить еще одно понятие. Значит, тоже. Так, ой. О, тут еще. Ой, еще маркеры есть.
Нет, этим писать нельзя. Ой, а чьи перчатки? Что? Господи, кошмар. Включает кто-то рандомно.
А чьи перчатки? Отрезок сочленения. Ничего себе. Отрезок сочленения. Это я еще не спрашиваю шутку.
Отрезок сочленения вообще. Да? Ничего себе.
Так, ладно. Значит, я тут кое-что забыл. Нет, ну да, я тут ДФС. Нет, я тут забыл, что тут это еще надо.
Так, сейчас. Нет, это просто я тут неожиданно вспомнил, что у нас тут был просто недописанный ДФС.
Вот тут важно. А то если вершина никогда не делается к черным, то на самом деле вся эта технология летит в трубу.
Вот. Поэтому как бы, называется к черной, должны, ну вы поняли. Так вот. Значит, ладно. Теперь я беру нормальный какой-нибудь маркер.
Я надеюсь, что он нормальный. И, значит, определение. Значит, вершины УЮВ. Реберна двусвязаны.
Если, как хочется написать, из одной в другую можно пустить поток величины два. Но существует.
Два. Реберна не пересекающихся пути соединяющих УЮВ.
Тут, конечно, не тривиальные тут слова есть. А именно, что такое реберна не пересекающиеся?
Это означает, что существует два пути, у которых нет общих ребер. Вот. То есть можно их пытаться, можно себе, вот.
Вот. Вот. Можно и в принципе себе вот так как-то воображать. Но не нужно. Потому что лучше, конечно, их воображать как-то вот таким вот образом.
Ну, хотя бы таким. Не, дело не в извилисисти. Дело, на самом деле, в том, что общие вершины у этих путей могут быть от слова вполне. Логично, да?
Вот. Соответственно, да. То есть общие вершины должны, то есть общие вершины могут быть, но не общие ребра.
Так вот. Ну и соответственно важное утверждение, оно же теорема. Очень пафосно звучит. Реберная двусвязность отношения эквивалентности.
Да, прям звучит как предвыборный лозунг. Вот. Реберная двусвязность отношения эквалентности, там фабрика рабочая, вот это все.
Вот. А, ну да, вся власть учительного собрания, естественно, да. Вот. А я вот в школе учился, у нас этот плакат даже висел.
Нет, ну не этот. Да. Да. Хотя, нет, ну да. Нет, у нас там, да. Слушайте, а может повисеть, да. Ой. А или мерч такой, шарфик заказать вот с этим вот.
Ой, такой олимпиадный шарфик, да. Реберная двусвязность отношения эквалентности. Да, да, да. Нормально, да. Ага. Так вот, хорошо. Да, да, да, да. Красно-черный. Да.
Да. Когда красно, да. Это называется, да. Называется дикарда. Дикардач не нужен, красно-черные деревья наши все. И так далее.
Ну. Ой, АВЛ слишком много поворотов, а вот красночерные. Да, да, да, да. Ой, да. Ой, да, да, да. Это уже там вообще дебата надо устраивать.
Ладно. Значит, пока у нас действительно вопрос, а почему этот лозунг вообще это не просто лозунг, а имеет отношение к делу.
Но давайте думать. Нет, ну в принципе, заметим, да, что нам нужно, чтобы доказать, что это отношение эквалентности.
Ну, как всегда, рефлексивность, симметричность, транзитивность, да. Ну, рефлексивность на лицо, симметричность тоже, да.
Да, потому что, да. Ну, рефлексивность, ладно, такая не тривиальная, но как бы, да. Как бы, да. Мы с этого ржем в третьем классе, но да.
Любая вершина сама с собой соединена значит двумя путями, состоящими из одной вершин. Да. Общих ребер у этих путей нет.
Да. То есть, как это, путь не пересекается сам с собой.
Чего? А вот так. Ну, нормально, что вот, да, два. Ну, как бы, да. Ну, существует два пути, да, они совпадают, да.
Ну, вот. Ну, как бы, да. Ну, что? Да, все. Это называется команда. Это называется команда КВН Прозрачный гонщик.
Да, знаете, команда, в которой там на сцене никого нет, это все шутки говорит автоматический голос.
И так это, уважаемые жюри, если вы не набираете достаточное число команд в сезон, это не проблема.
Я с легкостью могу разделиться на две-три смешных команды. Ну, вот. Ну, и все, в общем-то. Вот. И отбивочка звучит.
Вот. Ну, здесь примерно то же самое. Ой, гуглоните там отдельно, не пожалеете, на самом деле, да.
Вот. Вот. Да. Как это называется? Кто-то скажет, что вы...
Так, если я сейчас начну это воспроизводить. Поэтому лучше перейдем, лучше перейдем к транзитивности.
Потому что транзитивность, это да. Если вы, потому что транзитивность, вот как показывал, вот давным-давно, когда начали, когда мы на семинарах,
собственно, еще там у нас были какие-то, когда теоретически задачи еще принимались устно, хотя у вас тоже такие.
Там выяснялось, что будем... на самом деле, если попросить вас доказать, то вы Seka и очень большие проблемы,
потому что, казалось бы, среди простых каких-то элементов, которые там обычно по информатике и оли b.
would just procack it tömo Ber pardonım to present time, to this understand the moment, to this acat Hey, I still cope Chませ, это оказывается, что доказательство там то вот.
не будет, смотрите. То есть доказательство будет такое, значит, в чем у нас? И так вот у нас,
что нам нужно доказать? Жили-были вершины УВ и ВВ, да, то есть как бы У и В рёберно-двусвязные,
В и В рёберно-двусвязные, да. Так вот, смотрите, значит, технология доказательства такая. Рассмотрим
вот эти вот два пути, значит, У и В. И мы знаем, что они рёберно не пересекаются. Вершина могут,
но я сейчас не буду это рисовать. Значит, идея такая. Так, ну если, значит, берем вершину В. Ну тут
достаточно, сейчас вот то, что я расскажу, это, на самом деле, достаточно общий случай. Значит,
у нее есть два пути, которые соединяют ее с вершиной В. Значит, пойдем по одному из этих путей. Будем
прям идем от В до В. Идем, идем, идем, идем. Он там может, может идти как угодно, но рано или
поздно он впервые окажется на вершине, которая лежит на этих двух путях. Ну потому что в худшем
случае, может быть, это будет сама вершина В. Ну тут крайний случай, если он просто придет
в саму вершину В. Это вот, вот в этом случае, например. Или, может быть, наоборот, кстати, сама
вершина В может оказаться сама такой вершиной вполне. Вот, но на самом деле случай здесь все
равно общий. Вот, теперь пойдем по второму пути и тоже найдем вот какую-то клеммочку. Я это называю
метод клеммочек. Вот, тоже дойдем от В до В на первой вершине. Ну теперь я утверждаю,
что нам достаточно. Вот, то есть, могут быть, но на самом деле на доказательства это не влияет
практически никак. Потому что, то есть, я могу, то есть, на самом деле, я могу рассмотреть два
случая. Ну, в принципе, смотрите, если они пришли на разные пути, то, в принципе, вот, в общем-то,
вот вам два реберно-непересекающихся пути, потому что все части этих путей там состоят из попарно
различных ребер. А какая разница? А какая разница? Я, скажем так, из любого непростого пути я могу
взять просто простой подпуть. То есть, кто не пересекался, тот пересекаться и не будет. Так
что, в данном случае, это не проблема. Ну, хотя, нет, везде, конечно, по умолчанию считается,
что путь простой, но вот. Да, то есть, в принципе, да, тут можно нарисовать соседнюю картинку. Да,
и сказать, что клеммочки там могут действительно подцепиться, на самом деле, в абсолютно любом
порядке, кстати, да, и с другой стороны. Но суть-то одна. То есть, суть одна и заключается в том,
что у нас есть цикл с участием, реберно-простой цикл с участием вершины У, и мы к нему подсоединились. То
есть, надо просто через, теперь, вот пути искать, просто через разные стороны этого цикла. То есть,
вот так и вот так. Могут. Да, совершенно верно. Именно поэтому мы очень аккуратно
определяем клеммочки. Мы идем от вершины У до вершины В до первой вершины, которая лежит на
этих путях оттуда В. Да, вот в этой нечеткости и начинается причина, по которой, собственно,
многие решения валились. То есть, да, пересечений может быть много, они там могут действительно,
то есть, пересекаться. То есть, эти пути с этими могут там пересекаться, конечно, хоть вот так.
То есть, там этот путь может там вообще, может по этому циклу вообще попереплесать. Особенно,
если мы еще и... Особенно, если мы разрешим еще быть непростым, то вот. Ну, соответственно. Да,
ну видите, тут очень не принципиально, с какой стороны от вершины В на самом деле эти две
клеммочки подсоединились. Более того, в нашем случае вообще, давайте я могу еще для пояснения
так нарисовать, что могут быть вообще там какие-то экзотические случаи в духе, что там подключение
произошло, а там, допустим, вообще к одной и той... К одной и той же вершине, кстати, вполне могло
быть. Но это нас тоже, в общем-то, не шибко волнует, потому что вот так получается. Более того,
эта вершина могла быть самой вершиной В, а могла быть самой вершиной У, как я уже сказал, вершина В.
То есть, там, ну, то есть, в принципе, да, то есть, да, это могла быть вершина В или вершина В могла
уже тут оказаться, в принципе. Но вот, но на самом деле, кажется, как бы предлагаемое много доказательства,
кажется, автоматически учло все. Вот, то есть, просто с двух сторон цикла, значит, соответственно,
ходить. Ну, то есть, конечно, да, там можно, скажем так, можно попредираться, конечно, на тему того,
что что такое сторона цикла и как вот это вот с разных сторон ходить, особенно учитывая, что эти
пути, в принципе, могут там по одним и тем же вершинам ходить по один и тот раз, причем еще и в
рандомном порядке. То есть, у них могут быть, например, там, там пять общих вершин, причем один
путь проходит их порядке 1, 2, 3, 4, 5, а другой проходит их порядке 3, 5, 1, 4, 2. Вот, так что там,
вот, но это уже, как вещам, уже цепляться не будет. Так, ну, вот таким образом мы убедились,
что реберно-досвязанность это отношение и квалентность. Вот, вот, теперь, но теперь возникает
такой интересный вопрос. Значит, как же устроены в графе компоненты реберно-досвязанности?
Круто. Да, сколько будет 1 плюс 3? 3 плюс 1, потому что сложение коммутативно.
Вот, а почему оно коммутативно? Потому что, ну, например, 1 плюс 3 равно 3 плюс 1, да. Вот, ну,
смотрите, ну, на самом деле, тут нам, конечно, интересно, как-то, ну, нам хочется, конечно,
найти мосты и реберно-досвязанность вообще. А теперь думаю, как мосты вообще связаны
с реберной досвязанностью? Да, нет, ну, на самом деле, да, возникает, конечно, интересный момент.
То есть, можно сразу сформулировать такую леву. Ребро УВ, значит, не является мостом тогда и только
тогда. Когда, значит, У и В реберно-досвязаны. Вот. Значит, ребро УВ не мост,
реберно-досвязаны. Действительно, почему так? Ну, справа-налево, да. Потому что справа-налево
это то же самое, что и хорошо. Если это мост, то, вершина, ну, мост не может соединять реберно-досвязанные
вершины. Так. Сейчас, спокойно, погодите. Нет, спокойно. Да, давайте так. Да, что такое? Да,
справа-налево. Пусть вершины реберно-досвязаны. Тогда, если мы удалим ребро между ними, то порушатся
не более чем один из этих двух реберно-досвязанных путей, значит, они остались связаны. Противоречие
с тем, что это мост. Следовательно, это был не мост. Вот. Следовательно, это был не мост. Ну,
правда, да. Там, конечно, формально, правда, можно придраться так, что как бы ребро-мост,
это как бы хочется, конечно, сказать, что ребро-ув-мост тогда и только тогда, когда его удаление,
когда после его удаления вершины уев лежат в разных компонентах связанности. Формально говоря,
кстати, это не, формально это не эквивалентно вот этому утверждению. Ну, вот этому определению,
в смысле. У нас в определении писалось что-то другое. То есть, у нас, я написал увеличение
числа компонентности. Мог написать еще так. Найдутся, то есть, другими словами, найдутся две
вершины по удалению, так такие, что по удалению этого ребра они перестанут там быть соединены путем.
Вот. Нет, это так, просто немножко о формализме, потому что, да, то есть, конечно, довести до
этого формализма никаких проблем, потому что там это будет, потому что можно сводить их к тому,
связаны ли уев, потому что как бы любые пути между любыми двумя вершинами, они делятся на те,
которые проходят через УВ, и те, которые не проходят. Вот. Потому что, в принципе, то есть,
если удаление в УВ, если путь между ними не проходил через УВ, то ну и хорошо. А если путь
проходил через УВ, то если выяснится, что по удалению этого ребра между УВ все еще есть путь,
то значит, и между всеми вершинами тоже путь есть. Так что, в общем, да. Тут, в общем, не сильно
интересно. Хорошо. Таким образом, да, если ребра двухсвязаны, то ребро действительно не мост. Так,
ну а если оно... А теперь давайте наоборот. Да, если ребро УВ не мост, то значит, это выясняется,
что значит, это означает, что по удалению ребра УВ, как минимум, между вершинами УВ все еще можно
дойти. Ну иначе, пока число компенсовязанности увеличилось, правда? Но раз между ними может дойти,
значит, до удаления этого ребра тут два ребра не пересекающихся пути было, значит, да. Да, в общем,
ЛЕМА действительно очевидно. Прям вот ну совсем. Классно. Так. Ну а теперь вот выясняется... Ну вот,
ну тут, конечно, да. То есть разной аккуратности надо довести. Вот. Вот. Но на самом деле, да,
истинная аккуратность, это, конечно, если смотреть, как искать компоненты, там точки сочленения,
значит, по Ториану. То есть этот алгоритм будет вот так, как мы сейчас напишем, но там так
скупулезно все доказывалось. Вот. Значит, смотрите, про мосты такое. Так. А, ну еще, конечно, ладно,
простая ЛЕМА, тут совсем простая ЛЕМА. Мост — это, конечно, ребро дерева DFS. Да, если мы запустим... Ну,
если мы тут запустим в графе DFS, то это ребро дерева DFS. Так. Ну как это доказать?
А, ну можно. А, ну в принципе, да, можно и так сказать. Да. Да, действительно, оказывается,
да, такое есть вариант красивого доказательства. Видео, что, как мы уже с вами выяснили,
где там в неориентированном графе есть только ребро дерева DFS и обратные ребра. Предположим,
что мостом осталось, оказалось обратное ребро. Но заметим, что удаление обратных ребер, обратных
ребров, обратного ребра, никакой связанности не повлияет. Потому что, в общем-то,
скелет связанности, в общем, ребро дерева DFS обеспечивает. Все, доказательства окончены.
Вот. Ну вот. Так что в принципе, ну вот. Так что можно так доказывать. Да. То есть это даже
проще всего. Да, тут даже парадоксально, что можно даже все обратные ребра удалить,
а граф останется связан. Ну вот. Как-то, да. Да, наименьше по числу ребер, действительно,
да. Не единственное, конечно. Ну, потому что, да, добавление каждого обратного ребра даст вам
возможность удалить что-то из, да, из скелет, из ребра дерева DFS, да. Не, ну это скелет, да,
по сути, на самом деле, да. Вот. Вот. Значит, смотрите. Так. Ну, теперь вот вытекает такой
вопрос. Да. Значит, хорошо. Да, действительно. Значит, ребровое не мост. Да, хоть. Ну вот. Но
теперь вот вытекает действительно вопрос. Ну, допустим, у нас есть какой-нибудь там мистический
черный ящик, который говорит нам, какие две вершины ребер, ну то связанные, какие нет. Вот.
Тогда, вот, тогда, конечно, как говорится, мосты мы тогда действительно уже нашли. А теперь на
оборот. А теперь давайте на оборот. Вот. Нет, зачем за квадрат? Просто. Нет, ну если нет,
черный, если черный ящик прям честный DFS заново запускает, ну, конечно, да, квадрат. Но правда,
оно сейчас интересно другое. Давайте подумаем вот о чем. А если нам, допустим, нам известны все
мосты. Вот мы знаем, кто мост, кто нет. Можем ли мы определить компоненты реберной связности? Так вот.
Очень хочется сказать, что да, действительно, давайте просто тупо удалим все мосты и тогда
оставшиеся компоненты связности. Ну, точнее так, рассмотрим чисто дерево DFS, во-первых. Рассмотрим
чисто дерево DFS и удалим все мосты. Утверждается, что оставшиеся компоненты связности будут,
оставшиеся компоненты связности окажутся компонентами реберной связности. Да, был бы,
но на самом деле спрашивается, почему. Нет, да. Мы уже показали это. Да, но это еще не так. Из этого
следует следующее, что там каждая оставшаяся под дерево, вот это под дерево, так сказать. А давайте я
картинку нарисую, потому что это нам по-любому пригодится. Так, давайте. Так, ладно, вот это,
я надеюсь, можно убрать уже, да? Я думаю. Так. Нет, не совсем. А вот не совсем. Нет, смотрите,
получится на самом деле так. То есть, если вот тут нарисовать вот большое, большое, красивое черное
дерево. Да, это черный чемодан. Да, рисую я пока целенаправленное чисто дерево DFS, то есть,
как бы тут понятно, я имею в виду, что тут еще какие-то ребра еще есть. Так, и допустим, выяснилось,
что у нас мостами является типа что-нибудь вот это, вот это, вот это, там вот это, вот это, вот. Вот.
Ну, допустим, ладно. Хорошо, вот это и вот это. Вот. Тогда у нас, действительно, если удалить
чисто мосты, то граф распадется вот на такие компоненты. Точнее, дерево распадется, прошу прощения.
Ай-яй-яй. Это очень. Нет. Это если границу рисовать. Так, так, так, так, так, так, что еще? Что это такое?
Вот. Вот. Не, ну, как сказать, господи. Хотя это называется, да, что тут, как говорится, пугаться тут
нечему. У нас была центроидная декомпозиция, так что нормально. Да, да, да, да, да, да. Да,
у нас был софт хип после этого. Вот. У нас еще есть потоки и строки, кстати, я так напомню. Вот. А,
я еще молчу про вероятность. Ну, конечно, построил суффисное дерево, запустил ДФС,
все. А вот, нет, нет, нет, всяких вот этих вот Киркянинов-Сандерсов, что-то не обещаю.
Ну, вот. Хотя, ну, посмотрим по темпам, может и быть. Вот. Нет, нет. Отвечу на
самом деле на вопрос. Нет, он может, нет, ну, как сказать-то, Луканин как бы не славится супер
быстрой константой на самом деле. Хотя, нет, можно, конечно, и суффисный автомат, суффисный автомат,
и щедов ДФС, но на самом деле там просто чемпионат в этом мере в науке идет на тему того,
насколько мало сравнений между символами вы можете сделать. Вот. Что-то такое. Ну, там, конечно,
ну, вот, как говоримся, конечно, там в предположении, что там все символы, ну, хотя бы числа от одного до
Н или там от одного до константы. Почему это принципиально? Потому что, ну, на самом деле заметим,
что есть совсем произвольные элементы, которые сравните только по компаратору. Суфмасс быстрее,
чем Злоген вы не построите, в принципе. Потому что как отсортировать по паре Н по паре различных
камешков? Построим суфмассив, все. Вот. А мы... Да. Да. Поэтому в этом месте обязательно надо
оговариваться, что, предположим, что это символы, это все-таки числа от одного до хотя бы Н. И тогда
уже действительно какие-то линейные алгоритмы появляются. Ну, и там появляется там, что типа я
могу за 5 Н, я могу за 4 Н, там я могу за 3 Н минус два с половиной или что-то. Нет, ну, это я отбалдывал,
конечно. Там, ну, чемпионат вот какой-то в этом направлении. Да, два Н плюс пятьдесят семь. Да,
точно. Вот. Ну, то есть там какие-то такие чемпионаты, там разные алгоритмы и вот это вот все. Вот.
Так. Так, так, смотрите, что-то еще надо. Так, так, так, так, так, так, так, так, так, так. Вот.
Поэтому так. То есть там, то есть на самом деле вопрос действительно не такой тривиальный,
действительно там алгоритмы есть, они там борются между собой, там, естественно, в том числе по
скорости. Так что, да. Вот. Ладно, это было лирическое отступление. Да, до строк мы еще доживем.
Да, традиционно мы до строк доживаем на втором семестре. В третьем, да, на втором курсе. Ну,
как бы да, просто как бы обычно так. То есть обычно так. Как бы часто считается, что там
действительно обычно до строки верятся алгоритмы точно то, что хочется изучать на втором курсе.
Потому что, во-первых, на втором курсе вы начинаете изучать основы Термера, во-вторых,
а во-вторых, вы как бы изучаете на втором курсе, что такое автомат, если не вы работаете. Ну,
просто суффиксный автомат будет, я думаю, сильно проще обсуждать, если вы там перед этим там
хорошо изучили, что это такое. Вот. Так вот. Так далее. Ладно. Мы вернемся к делу. Да. То есть,
в принципе, у нас был прецедент, когда потоки, в принципе, вполне себе во втором семестре оказались.
Вот. Вот. Значит, смотрите. Значит, хорошо. Ну, вот. Ну, на самом деле, значит, смотрите. Действительно,
что можно сказать? У нас получились вот такие компоненты, но про них мы, конечно, гарантированно
можем сказать по транзитивности, что каждая из этих под деревьев. Да, кстати, да, интересный факт.
Да, это можно назвать под деревом, потому что заметим, что вот эти вот компоненты, они там
с ребрами дерева ДФС образуют корневое дерево. Обратите внимание. То есть, оно подвешено даже на
какую-то вершину. Давайте я вот обращу на это внимание. Вот. Вот. И смотрите. То есть, ну вот,
какая ситуация. Ну, вот. Но формально у нас, то есть, конечно, верно, что пока доказано,
что каждое такое под дерево лежит целиком в одной компоненте реберной двусвязности. И еще нам
гарантируется, что если две, два этих под дерева соединены ребром, то они не из одной компонент.
Формально говоря, из этого не следует, что, скажем, вот это дерево и вот это дерево на самом деле не
лежат в одной компоненте реберной двусвязности. Вот. Ну, правда, эти с этим не связаны, потому что,
ну вот. Ну, вот. Ну, вот. Ну, хорошо. Допустим, снизу. Но это если ребро. Ну, не ребро,
скорее, путь. Так. Но, действительно, заметим, что если какие-то два под дерева будут соединены
там, соединены хотя бы двумя путями, то скажем, вот, какой-нибудь вот там, ну, ну, скажем так,
то есть, между корнями этих двух путей, давайте вот корни рассмотреть, да, есть какой-то путь,
собственно, под дерево. Вот. И, в принципе, да. То есть, действительно, тогда оказывается,
что если этот мост, вот, допустим, там первый удалить, то оказывается, что второй путь какой-то
есть. Ну, да. Ну, тогда, в принципе, из этого уже автоматически следует, что это не мост. Да. Это
у нас, собственно, противоречие. Так что, следовательно, получилось так. Но, и это дает нам,
на самом деле, возможность, конечно, кое-что искать. То есть, на самом деле, конечно, в чем у нас
мечта? Почему я обращаю внимание именно на корень? Вот. Потому что наша цель, ну, правда, отсюда
можно сделать, на самом деле, вывод, что вот вопрос. Вот нам интересно, когда вершина является корнем?
Вот там задача. Хочется найти вершины, которые являются корнем своей компоненты. Да. Ну, хотя,
по сути, получается, либо ребро в родителе является мостом, либо это стартовая вершина еще.
Да, действительно, у нас так получается. Просто, смотрите, если бы осталось только так, если у
нас есть какой-то черный ящик, который сообщает нам, что вершина корень, то, на самом деле, у нас есть
уникальная возможность, на самом деле, автоматически находить и мосты, и точные сочленения. Я вот сейчас
абстрактно сейчас сделаю, потому что вот сейчас, собственно, технология Тарьяной проявится. Потому
что мы этой технологии найдем сейчас и мосты, потом мы найдем точные сочленения, а потом даже
компоненты сильной связности. Да. Вот. Да, то есть, возможно, это не тот алгоритм, к которому вы
привыкли. Нет, потому что нет. Дело в том, что в компоненте, нет, смотрите, просто в компоненте
сильной связности просто есть два алгоритма поиска. Один более популярный в олипиадах
использует два ДФСа, а мы будем использовать один. Вот. То есть, первый называется алгоритм Косараю.
Обычно в олипиадах дают два, потому что два очень тупых ДФСа. Нет, мы это тоже обсудим, но
называется там не совсем вместе с этим. Так, ну вот, значит, смотрите. Так, то есть,
вот давайте ДФС, значит, запускаем. Так, значит, ДФС. Значит, смотрите. Значит, идея будет такая.
Значит, смотрите. То есть, предполог, как я сказал, пусть у нас есть черный ящик,
который умеет для вершины говорить, является ли она, значит, корнем своей компоненты
в связности. Понятно, да? Тогда, на самом деле, то есть, если у нас такой черный ящик есть,
то код может выглядеть следующим образом. Да, я тут все и стирать не буду, потому что вот эти
вещи мы, да, серые, черные цвета нам, естественно, понадобятся. А еще нам понадобится стэк. Так,
какой бы нам цвет еще забабахать? А, ну красненький, Господи, ладно, красненький
мы уже обозначаем остыка. Значит, пишем стэк, называть мы его будем, да, СТ. Вот, ну да, была
мода, вообще несколько, да, несколько, да, несколько команд МГУ назывались МСУ СТ. Почему СТ? Потому
что Саратов Тим. Вот. Нет, МИТ чайки, наверное, немножко не то. Ну вот, значит, смотрите,
значит, во-первых, в этот стэк мы пушим, соответственно, нашу вершину. Вот, а теперь
внимание, то есть общая технология, она вот прям совсем общая будет. И получится следующее. Значит,
и потому что в конце, когда у нас вершина, значит, приходит, значит, идея будет такая. Значит,
пишем. Если оказалось, что В корень своей компоненты, компоненты, компоненты, там,
рыбарные двухсвязности, то делаем мы следующее. Тогда я утверждаю, ну, в стэке понятно, значит,
будут сколько-то вершин, потом вершина В, потом еще какие-то вершины. Так вот, мистическим образом
я утверждаю, что в этот момент времени все, что идет от, начиная от вершины В до конца,
в точности является компонентой рыбарной двухсвязности. Вот. Ну, то есть, работать будет вот
примерно так. То есть, смотрите, то есть, условно, да, то есть, мы запустим ДФС, вот все это будем
прямо аккуратненько добавлять в стэк. Добавляем, добавляем, добавляем, добавляем, добавляем. И вот
выходим из этой вершины и, ажидно, выяснили, что она корень. Ну, тогда, значит, мы, да, как
будет работать алгоритм, да, тут надо сформулировать алгоритм, чтобы доказывать, что он работает. Да,
это важно. Нет, ну, чаще бывает, что просто заметим пару свойств, из которых алгоритм будет следовать
очевидно. Тут немножко по-другому. Тут важно, что алгоритм будет такой. Значит, пишем, что какой-нибудь
там вектор int, там int. Допустим, comp и, значит, и делаем сейчас применим такой алгоритм как
do while. Значит, там comp.pushback от st.top. Что, не знаете такого оператора?
Нет, do while. Нет, оператора go to вообще не существует. Ну вот.
Вот. То есть вот такой вот валик нас ждет. То есть, короче говоря, достаем из стека все до вершины
w включительно. Вот я использую do while, потому что вершину w я тоже хочу достать. Вот. Тогда я
утверждаю, что то, что я достал, это компоненты. То есть, как видите, то есть нам для этого надо
просто четко определять, кто корень. То есть, какие вершины являются корнями своих компонентов,
какие не являются. Если я это знаю, то вот этот вот стек прекрасно работает.
Заметим, что компоненты. Заметим, что когда мы входим в какую-то вершину, то есть в какую-то,
но там доказать, что у каждой компоненты есть, так сказать, компоненты потомки. Вот. И остается только
заметить, что действительно там, ну просто аккуратненько по индукции, утверждение,
что в поддереве каждого корня, что в поддереве каждого корня на самом деле на выходе из этого
корня, там все компоненты ее поддерева такжественно будут уложены правильно и ликвидированы из стека.
Почему это будет так? Ну ладно, очевидно, что когда мы будем из этой вершины выходить,
мы из стека все достанем. То есть, это по-любому очевидно. И тогда получается доказательство такое,
что вот жила была компонента, и на ней тут, допустим, там на мостах что-то висит. По
предположению индукции заметим, что если мы тут по мосту из нее вышли, то мы это поддерево
по-любому зачистили. То есть тут зачистили, тут зачистили, тут зачистили. Но при этом заметим,
что вот сами вот эти вот, так как эти вершины не были идентифицированы как корень, то соответственно
они все тут в стеке оставались и никто их не удалял. Но как бы если мы вышли, мы тут же потом
вернулись, все зачистили. Вот поэтому и окажется, что в стеке вот на момент выхода из корня окажется
ровно то, что надо. Вот такая красота получается. Остается только идентифицировать кто тут мост,
вообще. Потому что дальше технология будет звучать так. То есть получается for int u gre от v.
Значит дальше будем говорить, что ну здесь пока все просто. Если оказалось значит color
r2 равно равно e dfs white, то что мы делаем? Запускаем dfs atu. То есть можно в принципе так сказать.
И дальше после этого выясняется там, если значит v u, то есть если ну короче там u корень
свои компоненты. Вот опять то же самое. Если это корень свои компоненты, то значит v u мост.
Вот. Идеально в принципе все. Ну кроме того в каком смысле все. То есть если у нас есть черный
ящик, который по вершине там после dfs из нее умеет понимать это корень вообще или не корень,
то мы победили. Вправивается. А как теперь нам определить? А теперь как же собственно
этот небеса и факс изобрести вместе с черным ящиком, как всегда? Ну как? Ну смотря что такое
далеко. Потому что мысль, да, значит действительно. Классическая технология говорит так. То есть нам
надо определить, ну обычно определяют наоборот конечно, что является ли это мостом. Ну да, мы уже
бьемся тогда и только тогда. Тогда давайте думать. А что означает, что вот допустим вот это ребро не
является мостом? Нет, давайте лучше отдельно нарисуем. А что означает, что вот это вот допустим
какое-нибудь ребро дерева dfs не является мостом? Означает это маленькую вещь, что вот как бы на
этом вершине висит большое такое поддерево dfs, да, и из него каким-то образом, то есть и у нас
существует какой-то путь, который ходит тут по этому поддереву, поддереву, поддереву, но как-то в
итоге все равно приходит в эту вершину. Ну да, ну смотрите, если вот пусть это не мост, тогда
существует еще какой-то путь, который соединяет вот эту вершину, вот эту вершину. Рассмотрим этот
путь. Значит, он некоторое время идет по поддереву, а потом когда-то впервые его покидает. Но заметим,
что выйти из поддерева, как можно выйти из поддерева? Можно выйти из поддерева, ну у нас все, ну вот,
ну у нас в принципе заметим, что у нас ребра все, либо ребра дерева dfs, либо обратная. Но по ребру
дерева dfs мы выйти не можем, потому что вот оно, мы как раз его пытаемся обойти. Значит, выйти из
него можем лишь по обратному ребру. Но заметим, что так как это вершина, тут все вершины являются
потомками вот этих двух. Вот, то есть это вот, то есть тут на самом деле имеет место какое-то
дерево аккуратное. Вот как-то так. Ну ходить тут, да, внутри тут все может происходить все что угодно.
Ну вот, то соответственно, да, это у нас какое-то обратное ребро, которое идет в какого-то предка,
причем видимо этот предок, причем это предок не вот эти вот предки, потому что они все в этом
поддереве лежат. То есть, следовательно, они идут либо в эту вершину, либо уже в какого-то ее,
но вот ее тоже какого-то предка. Вот, пока это не доказается, пока это заметим, что, то есть мы
замечаем, что если ребро, можно сказать, если только, если ребро дерева dfs не является мостом,
то мы из поддерева вот этой вершины, то есть из поддерева этой вершины, откуда-то, из какой-то
вершины по обратному ребру, можно попасть в предка этой вершины. Причем в строго в предка. То есть вот,
ну сюда, может сюда, сюда, но короче в предка этой вершины, которая сама не является. Да. Вот. Остается
только определить, а существует ли такое ребро. Но на самом деле такое, ну вот, существование такого
ребра на самом деле вполне себе легко проверяется, если мы сейчас с вами введем просто еще одну
стандартную, действительно, как бы сказать, своего рода динамику на дереве. В данном случае динамику
на дереве dfs. Мы ее будем называть, значит, внимание, ввожу новое определение. Значит, определение.
Значит, uptime от вершины какой-нибудь v. Что это такое? Это минимальный такой, значит,
таймин от w. Такой, что, значит, такой, что у w это обратное ребро, именно обратное.
Значит, у w обратное ребро. Да, тут важно, но имеется в виду, что именно в этом порядке. То есть w предок.
Вот. Обратное ребро, значит, а вершина у потомок v. Вот. То есть обратите внимание,
по такому определению uptime бывает и плюс бесконечностью, потому что из-под дерева вершины v может в принципе не вести
никаких обратных ребр никуда. Но может быть плюс бесконечность, она может быть даже, может там,
она рассматривает в принципе обратные ребры. Вот такие тоже, кстати, вполне. Вот. Ну вот,
возникает два вопроса. Как бы, как это, как uptime найти и чем это нам поможет. Но чем это нам поможет,
думаю, достаточно очевидно. Поможет на это так, потому что возникает маленькое утверждение.
Утверждение говорит такое, что если у нас есть там, где идем мы тут по DFS и вот у нас
образовалось ребро v-u. Ну давайте у нас сегодня как-то устарелась традиция, что u это ребёнок v.
Тогда утверждается, что v-u мост тогда и только тогда, когда uptime от u, ну по сути можно сказать,
строго меньше, чем time in от u. Вот. Ну потому что, если v-u не мост, то как бы, то есть вот это
вот замечание, то на самом деле доказательство здесь изображено. То есть смотрите, а именно. То есть
пусть вот это вот v-u, да, и пусть это не мост, тогда из u существует какой-то путь.
Ага, да. Да, согласен, согласен. Не-не-не, в вершину. Почему?
Нет, почему? Вот это вот такого ребра нас вполне устраивает. Да нет, у не живе. Да, у нас у не живе.
Да, это не совсем тривиально, соответственно. Что? Uptime от u больше ли было time in от u. Да, и тут и тут
у. Да, на этот раз не ошибка. Вот. Нет, ну как сказать, нет, можно написать строго больше time in
от v, на самом деле то же самое будет. Да, но я так пишу, time in от u. Ну вот. То есть да, если v-u не мост,
то значит есть путь на этом пути. Первое ребро, которое выходит из-под дерева u, это как раз обратное
ребро ведущего в какого-то v или предка, и оно нам дает uptime меньше, чем time in от u, потому что у
всех предков у time in меньше. Вот. Ну и наоборот, если такой путь, то есть если ребро не мост,
то такое ребро найдется. Ну и наоборот, если такое ребро из-под дерева в предка найдется,
то тогда это уже очевидно не мост. Все. Осталось только научиться этот uptime пересчитывать. Но здесь
уже действительно динамик, потому что я заметил, что uptime легко пересчитывается через uptime детей
и обратные ребра, торчащие из меня. Вот. Спрашивается, да, какие ребра торчат из меня. Вот. Кошмар. Вот.
Ну да. А это неважно. Ну потому что заметим, что можно сформировать утверждение, что... А давайте
давайте так. Первое вот так. И второе. Просто чисто лежит там. А ладно, не так. Ну ладно. Ладно.
Второе. В корень своей компоненты. Там своей. Компорт 2. Компорт 2. Компорт 2. Ну да. Когда?
Как гран-маман, только комптор 2. Тогда и только тогда. Когда? Получается, как жаль, что тут нельзя скопипастить.
У больше либо равно, чем time in. Нет, почему? Нет, если вообще нет обратных ребер, то uptime
будет вообще плюс бесконечности. Ну да. Минимум пустого множества плюс бесконечность. Да. Да. То есть я пишу. Я сейчас, конечно, буду писать не совсем такую версию,
которую обычно... Ну в Олимпиадах вообще иногда uptime инициализируется просто таймами себя. Да. Значит, смотрите. То есть код в итоге получается такой.
То есть тут немножко... Ладно, давайте я это и затру, потому что тут, конечно, придется кое-что пересчитывать. Вот.
Значит, дальше, потому что... Да, заметим, что здесь нам придется не только сделать push и, конечно, сделать инициализацию. Да.
Uptime от V равно плюс бесконечность. Вот. Значит, поехали. Значит, поехали куда? Значит, дальше. For int u2.gr от V. Так. Ну, проверяем.
Значит, ну во-первых, если оказалось, что... Значит, вершина белая. Color от U. Ай, господи. Sinti сказала порвать. Вот. То есть если вершина белая, то тогда...
Значит, тогда мы запускаем DFS от U. Значит, сразу... Ну вот. И тут, соответственно, пишем. Если... Значит, ну это мы для моста пишем, да, что если оказалось,
что uptime от U там больше либо равен time от U, то, значит, пишем, соответственно, U. Значит, VU мост. Вот. Да, доставать. То есть пока просто мост. То есть доставать из стека мы ничего не будем, потому что мы это делаем вон там, мы это уже сделали. Вот.
Вот. Это вот у нас точка запятой. Да, можно вот так даже напишу. Вот. Но еще нам, конечно, придется этот uptime все равно поапгрейдить. Значит, пишем, что uptime от V. Min равно uptime от U.
Вот. Ну раз мы... Да. Вот. Это если вот. Но придется рассмотреть еще второй случай. Так. Ну если вершина оказалась серой, на этот раз нам придется об этом вспомнить. Color от U. Ой, неправильно.
Вот. То. То что?
Вот. То пишем, что uptime от V тоже min равно, но на этот раз не перепутайте именно time in.
Так. Да, спасибо. Да. Смотрите, действительно важная оговорочка. Что в такой реализации скорее всего. Да, скорее всего мы... То есть скорее всего мы попытаемся... То есть вот сюда попадет ребро дерева DFS, по которому мы вообще в вершину V попали.
Вот. Ну значит, смотрите. Значит, делай так. Пока я пред... Давайте так. Предположим все-таки, все-таки что... Нет, хотя...
Значит, давайте так. Ладно. Напишу все-таки. Как-то напишу, что приближено к идеальной реализации.
Ладно. Ладно. Да, буду передавать ID-шник ребра. И до поры. Вот. Ну вот. Ну ID типа поры, потому что. Ну просто ID это типа передаем какое-то ребро, а тут ID поры это значит ID-шник.
Вот. Да. Значит, for. Смотрите. Значит, а вот тут я... А тут я немножко в полупитоновском. Хотя даже в питоне, по-моему, так нельзя.
Вот в полупитоновском стиле так вам напишу. Значит, буду перебирать ребра и как бы автоматически их вот воспринимать как картежик V, U и еще ID-шник.
Да, давайте. Какие молодцы. Ну что? Вектор, edge и все проблемы. Чего? Нет, если... Нет. А, хорошо. Вектор. А, что тогда? Вектор векторов edge, sorry.
Нет. Ну чтоб V был вектором ребер. А если это, извините, стракт на три поля? Нет, стракт на три поля можно. Да, стракт на три поля я делаю. А вот вектор нельзя, потому что... Нет, вектор нет. Ну вот.
Короче, оптимально, видимо, делать array или свою собственную структуру из трех полей. Так, ладно, короче. Так, давайте так. Пишу как было, потому что, да, тут цель просто чтобы удобные обозначения были.
Потому что я не хочу тут тратить строчки на этот... Потому что я могу тут описать, потратить две строчки, написать, что U равно E точка там, finish ID равно там это и так далее.
Да, поэтому здесь важный момент. Действительно, ради чего мы все это делаем. То есть end-end ID не равно ID per. Вот это важно.
Ну, по-хорошему, в принципе, может имел бы смысл тут часто сразу писать, просто в начале, что если ID равно ID per, то все выбрасываемся в нераде. Ну вот здесь мы так ставили.
Это означает, что у нас теперь тут в ГР хранятся ребра, в каждом из которых хранится начало ребра, конец ребра, ID.
Что мы это делаем? Потому что в списке смежности каждый ребро хранится обычно в двух экземплярах.
Потому что оно будет храниться как ребро из VVU и как ребро из UVV обычно. Вот.
Но еще для того, чтобы мы избавляться от кратных ребр, мы еще будем говорить, что у нас хранится ID, и поэтому чтобы сравнивали это то же самое ребро или нет.
Какую проблему это решает? Это решает проблему, что если у ребра есть кратное ребро, то тогда мы ни одну из этих ребер не воспринимем как мост.
Ну вот. Ой-ой-ой. Мне страшно.
Нет, просто да. Ну да. Нет, можно просто удалять, но на самом деле да, есть вот такая.
То есть в принципе, на самом деле честно скажу, это был такой, можно сказать, уровень, ну где-то, может быть, это был уровень изи.
Хотя мы, конечно, сделали сложнее, чем это могло быть, потому что идея, как было сказано, да, можно было просто удалить мосты и найти все компоненты.
Может быть, где-то поэтому это и изи.
Потому что мы теперь, так, есть ли тут вопросы?
Да нет, наверное, нету?
Ладно, тогда переходим на следующий уровень.
Какой уровень, медиум?
Так, смотрите, сейчас я, пожалуй, знаете, как мы сделаем.
Значит, сейчас это определение, да, сейчас надо вот это, как это надо сделать.
Определение надо стереть, а вот картинки не обязательно.
Так, значит, внимание, определение.
Ой, блин, зачем я определение стер?
Да просто понятие, просто поехали теперь.
Точка сочленения, да вот тут и проблема, что да, точка сочленения, это вершина.
Точка сочленения, это вершина.
Удаление которой вместе с инцидентными ей ребрями.
Так, надеюсь, вас уже не пугает это умное слово.
Не знаю, не знаю.
Не знаю, не знаю.
Приводит к увеличению
числа компонент связанности.
Так, вот теперь у нас такая неожиданная задачка.
То есть надо найти точку сочленения.
Сейчас, чего, чего?
Сейчас кого убрать?
Где сейчас? Нет, погодите.
Нет, погодите, ой, нет, это все не про мосты, нет, давайте так.
Аптайм мы оставим, потому что определение аптайма никуда не денется.
И мы его, забирая вперед, будем насчитывать.
Ну а теперь маленькая фишка.
Значит маленькая фишка, ну вот.
А теперь нам нужно написать какое-то определение.
Так, и сказать, что вершинная двусвязанность это...
Вот, так, ну а теперь проблема.
Что хочется сказать?
Конечно хочется сказать, что вершинная двусвязанность,
в принципе это будет правда, да, что там какие-то там две вершины будут наверно вершинно двусвязаны,
если их можно соединить на этот раз там путями, которые вершины не пересекаются.
Вершины пересекаются только по вершинам.
Ну если быть точнее, да.
Да, но проблема даже не в этом.
Проблема, что даже если мы добавим вот эти оговорки,
то у нас возникнет на этот раз проблема с транзитивностью.
В общем, на этот раз реально проблема.
Вот, в такой ситуации.
У и в вершины двусвязаны, в и в вершины двусвязанности, а у и в вот нет.
Вот, да.
Ну вот это, да вот, это печаль.
Ну, как всегда, как сказать, да, можно, конечно, сразу депрессивировать,
что это прямо уже фиаско и грустить,
а можно, как всегда, дать возможность.
Ну, вот, то есть, наоборот, сделать шов круто,
то знаете как-то, да, как это, да,
как это бизнес сэнами, да, знаете, как это, знаете, такая ситуация,
это бизнес сэн из Америки, да, очень про там просит вас,
значит, услать, услать подальше одного парня, чтоб прижать к рукам его бизнес.
Вот, ну парень там раздолбайный, ну просто там богатенькие наследки.
Вот, значит, шо вы делаете?
Значит, у этого парня, оказывается, есть, значит, такой какой-то предок-пират,
у которого там, видимо, где-то могли быть сокровища.
Значит, вы изготовляете карту и подсовываете ему ее.
Значит, ну там, подсовываете.
А еще потом, значит, выясняете, что там есть еще один такой же пример.
Да, родственник там, видимо, пятиюродный брат.
Вы ему даете такую же.
Вот.
В расчете на то, что они там встретятся на лобном месте и друг друга перестреляют.
Вот.
Вот.
Ну, как бы да.
По идее, но тут по-разному, они могут просто прийти друг друга перестрелять,
а могут чуть-чуть пострелять, пообщаться, выяснить, что они родственники и стать друзьями навек.
В общем, настолько большими друзьями, что даже любовь к одной и той же девушке их не разлучит.
Да.
Как говорится, да.
Я не спрашиваю вас, как назывался роман.
Назовите автора.
Это называется.
Что, не сталкивались с таким романом?
Нет?
И с фильмом 92-го года тоже?
Нет.
Сердца трех ничего не говорит?
Нет.
Слушайте, посмотрите, очень красивый.
И посмотрите и почитайте там, собственно, Джека Лондона такой роман.
Заметь там.
Так что, да, замечательный роман.
Да.
Вот.
Там, соответственно.
Вот.
Очень красивый.
Значит так.
Поэтому, значит, просто действительно можно действительно там, действительно просто погибнуть это,
а можно на самом деле действительно там, наоборот, просто там понять, что до этого, собственно, не жил вовсе.
Что же дает нам действительно это вдохновение и просто ощущение, что действительно вот только сейчас мы начинаем жить.
А дает нам следующее определение.
Вершинная двусвязность.
Точнее так.
Рёбра.
Значит, значит, я тут так напишу.
Рёбра.
Значит, А, Б и С, Д.
Ну, типа новая жизнь так до конца.
Вот.
Вершинная двусвязность.
Вершинно двусвязные.
Ну, двусвязанные.
Если
существует
два,
на этот раз абсолютно вершинно не пересекающихся пути.
Вершинно не пересекающихся пути.
Весь вся
пути.
Что?
Смотрите.
Соединяющие.
Значит, тут надо аккуратно А с С и Б с Д.
Или
А с Д
и Б с С.
Вот я так напишу.
Нет, тут и прикол.
Ради чего я всё это писал?
Почему я тут не написал такое тупое, что эти двари брали?
Они лежат на вершинно простом цикле.
Вот я мог так написать, да?
Но есть тонкая разница.
Как раз именно из-за рефлексивности.
Потому что как бы мост, да, тогда получится, что мост не вершинно не двусвязан с самим собой.
Ну, потому что мост не лежит ни на каком цикле.
Вот.
Но.
Да.
А то да.
Да, надо было бы, чтобы цикл был действительно рёберно простой.
Не вершинно простой.
Но на самом деле, да, в данном случае оказывается, что если мы это ребро воспринимаем как А, Б и С, Д,
и как бы получается есть путь, который соединяет одну вершину с самой собой и другую вершину с самой собой.
Да.
Они не вершины, они рёберно не пересекаются.
То есть я мог написать определение, что ребра, вершины двусвязаны, если они либо совпадают,
либо через них можно привести простой, вершина простой цикл.
Ну, вершина простой, значит по каждой вершине проходимся не более чем один раз.
Да.
То есть только вот с этой оговоркой, чтобы была рефлексивность.
Вот.
А теперь теория.
Да, то есть действительно фишка оказывается в том, что вершина двусвязанность – это отношение эквивалентности
на ребрах, не на вершинах.
На вершинах даже более сильные условия, чем вершины, они не по ребрам не пересекаются, не по вершинам не пересекаются.
Да, совершенно верно.
Но как выясняется, это не является отношением эквалентности на вершинах.
А на ребрах?
Ну, давайте разбираться.
Хотя картинка, в общем-то, сейчас практически не поменять.
Сейчас я её сотру, чтобы нарисовать такую же только на ребрах.
То есть тот даже ещё и случаев меньше, кстати.
Ну ладно, в общем-то, хотя это страшно.
В прошлый раз был один случай, как тут будет меньше.
Вот.
Значит, смотрите.
Ну ладно, симметричность, в общем-то, так или иначе, у нас сомнения не вызывает.
А вот транзитивность.
Ну ничего страшного.
Ещё страшного.
Значит, рассматриваем ребра AB, CD и EF.
Так, значит, у нас есть цикл через AB и, допустим, CD.
Допустим, вот такой.
Ну, если тут DC, то доказательство не поменяется.
И так жило было EF.
Вот это вот ребро EF.
Так, ну доказательство абсолютно такое же.
То есть берём вот этот вот, от вершины E есть какой-то путь, то ли до C, то ли до D.
Идём по этому пути от вершины E до первой вершины, которая попадает на этот цикл.
Теперь берём путь, который идёт от вершины F, то ли до C, то ли до D.
Таки, наоборот, то ли до D, то ли до C.
Вот, и тоже идём до первой вершины, которая лежит на этом цикле.
Ну, собственно, всё.
То есть мы двумя клеммочками подцепились к вот этому циклу.
Это не будет одна вершина, потому что эти два пути вершинно не пересекаются.
Да, в данном случае этого не будет.
Да.
Вот. Нет, на самом деле, я, значит, набираю вперёд.
Значит, у вас, соответственно, в домашнем задании появятся две шикарные задачи,
в которых нужно будет доказывать, в каждой из которых нужно будет доказать эквивалентность семи утверждений.
Нет, причём там шикарно на самом деле, да.
Нет, нет, достаточно простые.
Но там будет, например, такие какие-то, такого рода.
Пусть, например, там G-связанный граф с не менее чем тремя вершинами.
Тогда утверждение первое – в графе нет мостов.
Вот.
Ну вот и далее там, скажем, и будет там что-нибудь типа, для любых вершин УВ и В различных, будет там, там не что-то,
сейчас вот именно через вершины или через…
А, ну да, видимо для любых там УВ и ребра Е, будет там, допустим, существовать путь, ну там, существовать путь там, от УВ, не содержащий ребро Е.
содержащий ребро е или там будет там для любых ув и ребра е будет содержание
нот там будет существовать путь это дот или там для любых ув и ребра и вершины
w будет существовать просто дот путь там будет существовать ребер на простой путь
который соединяет у и в и проходит через даблы ну и так далее тому подобное
вот значит да сразу скажу что в этих утверждениях на самом деле пользоваться
из лекции можно будет только определениями но попробуйте но она вам
не поможет скажем так это там чисто математические утверждения которые там
доказываются без всяких дфс то есть это как бы да то есть то есть это там
чистая математика но там вот действительно красиво потому что
что вот скажем и вот а вот теперь бывает вопрос есть ли в графе точка сочинения
допустим да и там вот так кажется что точка сочинения оказывается точка
сочинения в графе нету тогда и только тогда когда например там для любых там
для любых вершин ув вв существует путь простой путь вообще вершина который
проходит который идет из ув и проходит через w вот или там еще тогда и только
тогда когда для любых ув w существует путь из ув и не содержит w
оказывается если для любых то это оказывается эквивалентное утверждение
вот такого типа да то есть это будет действительно весьма неожиданно то есть
оказывается что там нет там такое было нет на самом деле да то есть хит сезона
дайте потому что нет просто это действительно можно хорошо прокопать потому что полное
ощущение что действительно если это хорошо прокопать то можно там действительно и два
линии потом прийти на полуфинал и решить задачу которую там скажем не решили елки палки на
прошлом полуфинале да хотя у них было казалось бы 40 минут спокойного обсуждения но они
не решить но такое бывает да нет если бы нет там нет там нет там была какая-то более там продвинутая
задача на дерево но как бы если вы понимаете но но если там вот понимаете вот эту теорию то как
бы в эту задачу обычно решаете то есть там потому что атака пошла да там какой-то как
компоненты что там через что там ну хотя да там первую очередь там видимо фишка что там
внутри этого компонента через любые два ребра можно реально вот именно цикл провести и там
этим надо пользоваться вот задачи сейчас не помню да и не должен сейчас наверное там по
телевизору собственно рассказывать там собственно разбор с решением задачи которые была на прошлом
полуфинале пошло прошлого года вот ну ладно календарно за прошлого но вы понимаете вот так
вот так ну хорошо ладно мы поняли что вершина двухсвязанность отношении
эквалентности теперь высказать вопрос как вы думаете как связана точка
сочленения и вершина двухсвязанность сейчас сейчас нет почему нет ну вполне себе ну давайте
утверждение какой-то точек вершина в является точкой сочленения тогда и только тогда когда
инцидентные и ребра инцидентные и ребра принадлежат
как минимум
двум различным компонентом вершины двухсвязанности
вот
так но слева направо действительно ну давайте попробуем да тут уже доказательства придется
конечно поговорить подробнее да жила была вершина есть которые там торчали хотя бы два
ребра разных компонент тогда есть подозрение что по удалении этой вершины вот эти две вершинки
очевидно связаны между собой путями путем то есть они связанными быть не буду они будут почему
потому что если они якобы были связаны то тогда эти ребра принадлежали одной компоненте вершины
двухсвязанности противоречие вот значит стоп так что я просто в другую сторону доказал
я сказал предположим что у нас есть хотя бы 2 2 тогда действительно найдут найдутся две вершины
которые перестали быть связаны до свидания тогда утверждение тогда это точка сочления и потому
что вот так вот а вот в обратную сторону брата если это точка сочления то значит мы ее удаляем и
найдутся две вершины которые с ней ноторы которые были с ней связаны но после этого отвалились
утверждение вот эти 들ил вот эти ребра очевидно были значит не из одной компоненты почему чтобы
или бы они ноут ну были бы они из одной компоненты то чтобы но то очевидно тогда эти пути могли
выглядеть только что это пути здесь второй путь вот такой но тогда тогда оказалось что эти вершины
этот тогда эти вершины бы тогда не отвалились друг на друга может этот цикл там вот это пути
полностью отвалился от остального графа это могло быть но вот но вот но в любом
случае они отвалятся вместе они в разные компоненты связанности вот вот
собственно и все вот так что теперь но вот так же но вот но теперь действительно
будет такая то есть будет такая интересная такая нетривиальная задача
спрашивается здесь уже придется прям вот действительно может быть там сильно
более скрупулезно все продумывать потому что смотрите но прошли первый
сказать вопрос как найти общие компоненты революционной связанности
точнее сочинение ну допустим если мы найдем компонент вершин
связанности то точнее сочинение мы как-нибудь найдем да а теперь давай но
теперь придется думать а как же вообще наши компоненты выглядят вот в этом
деле и обеду вот как они тут выглядит то есть к сожалению мостами тут уже не
обойдешься то есть конечно верно что да то есть заметил что действительно мост
это конечно уникальная штука да потому что я могу на экзамене спросить как в
науке называется ребро но три бро которое содержится в компоненте вершины
двух связанности размера 1 да оно называется мост да как легко убедиться да да но не то
чтобы это определение конечно да но вот да но вот то соответственно да в принципе из этого
следа но тот на самом деле можно задуматься вот о чем смотрите давайте внимательно подумал
хорошо мост это такой интеллектуальный ребро которая действительно живет в себе любимым а как
вообще определить вот хотя бы по скелету давайте думать дерево dfs вот допустим есть
ребро и у меня есть вот ребро ведущий куда-то в ребенка эти два ребра они вообще хотя бы из
одной компоненты вершины до связанности как нам это определить
так не факт если но если она не является то конечно да другой вопрос откуда мы знаем
но на самом деле все определить это гораздо проще потому что на самом деле как бы проверить вот
эти два два ребра лежат ли они в одной компоненте оказывается нам помогает просто
вершины потому что оказывается что можно за ну просто опять же можно заметить что если у
этой вершины оптаем значит меньше либора то есть там меньше вот вот этой вершины даже да то тогда
так что происходит уже прям прям статью тарян уже читать но вот то тогда оказывается что из
этого под дерево есть обратное ребро в какого-то предка то есть сюда или выше и тогда получается
что это обратное ребро образует цикл с участием этих двух ребр правда но с другой стороны если
такого ребра нет то мы вынуждены заключить что до эти ребра не из одной компоненты вот то есть
получается там тогда и только тогда да то есть как бы да есть то есть ну просто да то есть если
из одной компоненты то есть цикл но ты по Wohn если они не из вот тут так если оптаем меньше
то значит они из одной компоненты с другой стороны если они из одной компоненты значит из этого
значит отсюда есть путь сюда без вот этих ребер да то есть да без вот этого вот то есть
это там то есть без вот этой вершины то есть это задает на этом пути есть какой-то первое HC
да то есть то технология единая поэтому ты поэтому я так скупулезно прописывал
технологию потому что вот делается прям буквально то же самое поэтому
смотрите теперь вытекает правда другой вопрос
смотрите а верно ли что ну хорошо допустим мы набрали какие-то вот такие
под деревья то есть тогда получается таких вот ребер дерево dfs которые будут
готовых там вот любые ребра здесь соседний но то есть ребра то есть какие-то вот любые
ребра внутри тут обязательно одинаковые да правда тут может быть куча оговорок на
самом деле это все конечно совсем некорректно потому что тут конечно все там потому что на
самом деле да тут вообще надо все стирать потому что но вот больше деревья тут будет
выглядеть совсем по-другому потому что если мы будем рисовать их на деревьях то в общем-то
деревья то есть теперь различные деревья они не пересекаются по ребрам но могут пересекаться и
по вершинам вот там какой-то там что-то еще там тут вообще красота красота красота красота
вот и в принципе может оказаться что если мы тут сравниваем только действительно только
ребро своими соседями одинаковые не компоненты не дает можем быстро сделать то на самом деле
эти одинаковые то у нас появится какие-то связанные множество которые могут выглядеть
вот так вот как-то вот так вот вот как-то вот так вот что еще может быть
то есть вот так вот вот красота да так ну так и быть вот это мост и вот это мост а это нет
так ну и тут как мы там не будем сильно париться вот как-то так
то есть как бы то есть получается связанная то есть как бы связанное множество из разных
ребер могут оказаться то есть вот прицеплены вот таким образом правда я тут конечно не сам
как будто не самый общий случай нарисовал но вытирает правый вопрос а могут ли оказаться два
два таких связанных множество которые между собой как бы напрямую не связаны но тем не менее
оказаться из одной компонент и вершина до связки может быть такое как вы думаете
хочется сказать что нет да очень хочется
но да то к сожалению да если было очевидно вот тут видимо поэтому дал тарьяна там начинается
там просто едва ли не куча лем там 4 3 4 4 там 4 3 1 там 4 3 2 и так далее
нет это уже другой нет это если мужа компоненты эти нашли туда но это есть двух уже нашли а мы
их пока тут еще только ищем то есть мало того что их это мы еще только на скелете дерево
дфс нашли а тут именно там же еще остальные ребра есть вот да но хотя другой стороны действительно
можно заметить вот что да то есть у каждой комбинации но вот тут на самом деле что нужно
вообще доказывать но много чего нужно доказывать на самом деле ладно много чего нужно доказывать
а на самом деле у нас там время перерыва пришло поэтому вася причем тут действительно настолько
мутно то что действительно как может вообще выглядеть какой-нибудь типичный граф с точки зрения там
вершины двух связки но на самом деле там можно его себе иногда воображать просто как вот такого
снеговичка ну такого экзотического снеговичка конечно да да вот ну например вот можно на
цикликах каждый компонент и вершины двух связности она тут конечно и может быть поэкзотичнее она не
обязана быть циклом более того вовсе не обязательно что компонентом допустим вершины
двух связных граф обязательно является там обладает каким-то хамильтоновым циклом там
с лишними ребрами ну тупой пример конечно вот какой-нибудь вот такой вот и вот еще вот хотя
нет вот это ребро как раз все портит да придется еще вот тут дописать вот вот да вот тут и давайте
вот тут для надежности но то есть какая-то такая вот гадость и вот такие вот то есть и вот
и вот такие вот круглешки в общем-то друг за друга в вершинке цепляются идейно так но как бы раз
эта интуида но т.е. интуитивно вот то есть интуитивно можно себе воображать так принципе из
эту интуиции в общем-то алгоритм уже можно вывести но если но как бы это у нас не компоненты ребрин
двух связ serio тут само уже так не просто очевидно то есть мосты так не поудаляешь поэтому придется
думать поэтому видимо что-то подумал так видимо придется тут немножко больше
формальности вести для этого доказать стоп того шах вот ой так с чем но доказать нет
ой мы много чего доказываем потому что давая но вот потому что там на самом деле есть еще
вообще нет ревяльная такой нетривей на утверждение которым нам придется подумать
значит смотрите тут какая и че смотрите тут какая интересный потому что дело в том,
что нам подлянки еще будет заключаться в том, что как бы если раньше мы масты искали только на
дереве да, то теперь нам нужно сформировать и вершины в принципе тоже все лежат на дереве да,
то у нас теперь есть еще и ребра, которые у нас есть какие-то обратные рёбра, которые сюда не
вошли то есть нам еще только то есть на самом деле общий план действий который
мы тут собираемся такой вот мы хотим вот мы тут сейчас я чуть более формально
определю вот что такое вот эти под деревья то есть я хочу то есть я хочу
сказать следующее давайте прям сразу скажу и напишу да что мне есть такие вот
так сказать деревья вершины под деревья вершины ду связанности прям я так и
напишу определение нет значит назовем скажем что вот виду я сейчас тут
спонтанное слабосочетание сейчас введу значит под дерево вершины ду связанности
ду связанности
значит смотрите да под дерево вершины ду связанности это максимальное по
включению
связанное множество множество
ребер дерево дфс
лежащих в одной компоненте вершины до связанности
а вот в прямом но вот будем говорить что если мы прям вот рассмотрим только
эти ребра вместе с их вершины то они будут образовываться что ой я забыл
максимально ну максимальное по включению пустое как бы да да как в науке называется
минимальное по включению множество пустое лежащих в одной компоненте вершины ду связанности
вот
но максимальная по включению
нет почему любые два ну смотрите нет почему не единственно потому что если какие-то два множества
таких ребер пересекаются по ребру то вообще-то их можно объединить в единое связанное ребро из
одной компоненты это единосвязное множество вот ну то есть по сути я хочу взять дерево
ребра дерево dfs да но для каждого ребра я вот могу смотреть какие-то соседние ребра и
сказать вот я знаю про не про них что какие-то из них одной компоненты связанности со мной
какие-то нет ну ладно тут еще ладно есть тут еще крыш мелкая говорочка что конечно иногда
бывает что у вершины там внутри там как бы несколько детей какие-то из них там из одной
компоненты какие-то из другой ну какие-то из третьей вообще вот но допустим это мы собственно
вот так вот я хочу просто рассмотреть то есть пока я хочу такие деревья найти но во-первых
да не плохо было бы убедиться что разные деревья содержит но вот что разные деревья
содержит ребра из разных компонентов и деревья состоят из ребер разных компонент вершины
до связанности поехали ладно как вы видите не уверен что там пойдет по тарьяно если вам не
нравится схема, которую сейчас предложу я, вы можете почитать оригинальную статью Тарьяна.
Ну, как я уже сказал, depth first search and this is plans. Чего? А, там под ром называют? Ну, ладно. Ну, да. Ну, вот. Ну, хорошо. Ладно. То есть она там называется, там еще куча лемочек,
доказывается вообще мелких. Вот. Ну, вот. Значит, поехали. Лемма 1. В разных под деревьях вершинной двухсвязности, ой, ой, ура, мы спотанно ввели новую аббревиатуру. ПВД.
Нет, главное, кстати, у меня с лету нет ассоциации даже. По-моему, по-моему, мы ни с чем не наложились. А чего в линуксе? Все привексов. Да, но, во-первых, по-русски там скорее всего будет другая.
А, во-вторых, на английском языке это будет не то же самое, как и у нас, потому что наши верток список через В, а там walking через W. Вот.
Ну, допустим, ладно. Хорошо, что мы не физики, да. А или среди вас есть физики. Ну, мало ли вроде. Ну, да.
Да, воздушная, воздушная, висантная. Вот. Ладно. Так, все. Значит, в разных, значит, этих вот ПВД содержатся ребра.
Ребра. Так, ну, во-первых, да. Так, ну, мы, когда называем под дерево, ладно, я не буду, ладно, можно прописать нулевую лему на тему того, что это подвешенное дерево.
Правда? Вот. Подвешенное хотя бы за одну вешину. Вот. Содержатся ребра из разных компонент вершинной двухсвязности.
Из разных КВД. Нет, КВД уже вызывает ассоциации. Нет, нет, нет, КВД просто главную букву М сначала не добавлять.
А так вот. Вот. Так вот. Разных ПВД содержатся ребра разных КВД. Почему? Вот. Ну, здесь вроде как. Вот.
Ну, здесь нот. А, действительно, почему? А вдруг у нас там есть какие-то вот разные деревья и называется нот, которые соединяются почему-то через дерево DFS.
Почему-то каким-то путем без них. Так, ну да. Ну, попытаемся. Ну, давайте смотреть. Хотя доказательства на самом деле такое.
Формально можно сказать так. То есть, как эти деревья относятся друг к другу? Там либо одно из них предок другого, либо они как-то вот в параллельных каких-то живут
там под деревьях через какое-то лца связано. Правда? Ну, на самом деле, но заметим следующее, что если я рассмотрю путь между этими деревьями по дереву, то как бы хотя бы у одного из этих деревьев этот путь будет проходить через, так сказать, родительское ребро, по которому мы вообще входим. Правда?
Так понятно, о чем я говорю? То есть, там есть одно дерево, другое, и там есть у каждого дерева, кроме корневого, есть ребро дерева DFS, на котором это все вообще висит.
Что? Что-то не то? Я пока нет. Сейчас мы говорим под деревом, я имею в виду под дерева вот этого.
Обратно, ну вот. То есть, вот так вот образовалось, что у нас тут есть два под дерева, и почему-то оказывается, что они из разных компонентов, там, двухсвязанности.
Вот. Но теперь, заметим, рассмотрим путь, который их соединяет. Я утверждаю, что у одного из этих под деревьев этот путь как бы идет, как бы через родителя корня этой вершины, этого дерева.
Хотя бы одного точно, может и у двух, если через лца, то прям вот так вот будет. Вот. Ну а если предок потомок, то вот там снизу вверх вот так.
Точно знаем, что вот эта вершинка, это точка свиньи.
Которая черная, которая предок.
Ну, кстати, да. Но само по себе это нот. Но само по себе это нот. Но само нот с одной стороны должна быть.
Но с другой стороны, сейчас мы также докажем, что она и не является.
Ну хотя ладно, хотя ладно по барабану. Может и не так, хотя, а может и является.
Нет, ладно, нет, на самом деле, может она является, нет, понимаете, тут как бы она может являться точкой сочленения.
Там по другим причинам просто, тут как бы вопрос, может там как бы отвалится, там по разным причинам может быть точка сочленения.
То есть может там все развалится или просто отвалится какая-нибудь маленькая веточка.
То есть там какие-нибудь, ну потому что это какая-нибудь достаточно типичная ситуация.
Давайте сразу уговоримся, что может быть, когда у нас дерево устроено как-то так.
То есть у нас есть какая-то мистическая компонента.
Так, где, где режима? Вот он. Ух ты, за стаканчиком спрятался, молодец.
Вот, значит, смотрите, потому что компонент типичный может быть так.
В общем, жила была, то есть вот такая вот красивая компонента, а на ней висит что-нибудь вот такое.
То есть обратите внимание, да, то есть как бы даже такая парадоксальная картинка.
То есть как бы у нас, то есть вот это вот с этим ребром в одной компоненте вершину друг в связности, а вот с этим уже нет.
То есть, потому что, видите, если удалить эту вершину, то как бы вот эта штука не развалится, но треугольник от нее уйдет.
Вот, так что там, то есть как бы это, поэтому там говорите о том, что это точка сочленения.
Ну, то есть, да, то есть она, конечно, видимо точка сочленения, действительно, да, потому что, видимо, потому что это ребро с этими ребрами в разных компонентах лежит.
Одно из деревьев, вершина будет как у изначального дерева. У изначального дерева вершина не обязательно на точке сочленения.
Нет, у одного тогда, но мы рассмотрим то дерево, из которого путь идет через родительское ребро. Да, мы ее рассматриваем.
Вот, то есть, скажем так, есть, конечно, метод, давайте докажем, что это не точка сочленения, но я боюсь, что у нас не получится.
Там просто левая поддельная. Чего?
Ну, там самая высокая вершина, например.
Нет, в смысле, не важно, нескольких в дереве ДФС не будет, чтобы это было.
Если вы возьмете в дереве любое просто связное подножие ребр, тогда у нее будет один ярко выраженный корень.
Потому что не может быть так, чтобы вы были связаны подножие, у него выяснилось, что у него есть две самые высокие вершины.
Нет, я имею в виду, не обязательно брать самую высокую вершину.
Ну, нет, в качестве корня мы будем брать самую высокую. Ну, если вы спрашиваете, что такое корень, это вот самая высокая вершина.
Да, зачем мы это просто требуем?
Вот.
Например, когда мы делали смастер, это имелось бы?
Нет, просто удобно, потому что в данном случае просто удобно, именно корень и конкретное ребро, которое должно быть из другой компоненты, казалось бы.
Но, теперь смотрите. Нет, просто я сейчас объясню, почему я именно так хочу.
Потому что рассмотрим, допустим, вот это ребро и вот это ребро.
Ну вот, как бы есть жуткое подозрение, что эти ребра, то есть мы утверждаем, что эти ребра вершины были связаны.
Равно как и все остальные.
Тогда что это означает?
Это означает, что от этой вершины до какой-то из вот этих можно дойти, минуя вот эту вершину.
Ну, потому что их соединяют какие-то два вершины и пересекающие пути.
Значит, на одном из этих путей этой вершины нет.
То есть эта вершина соединяется то ли с этой, то ли с этой.
Но это даже не важно.
Потому что как этот путь вообще может выглядеть?
Путь может выглядеть так.
Рассмотрим уже глобальное под дерево этой вершины.
Не под дерево, а вот вершина двух связанности, а вот именно прям под дерево.
То есть этот путь должен из этой вершины как-то выйти.
То есть он тут, как мы уже раньше говорили, этот путь шел-шел-шел-шел-шел как-то тут по дереву шел-шел-шел и бах-бах вышел.
Но, напоминаю, выйти мы можем только через обратное ребро,
которое ведет еще раз не в эту вершину, значит выше.
Вот, но тогда поздравляю.
Тогда это ребро с, действительно, по крайней мере вот этим ребром вполне себе в одной компоненте вершин двух связанности противоречий.
Да, кстати, подляночка.
Эта картинка тоже немножко обманывает, потому что, как бы, у вас может возникнуть ощущение,
что все дети этой вершины, дети в глобальном дереве ДФС, лежат в этой вот КВДшечке.
В этой ПВДшечке. На самом деле нет.
То есть вполне вероятно, на одной вершине может таких деревьев висеть вполне себе.
Они тут гроздями могут быть.
Ну, просто действительно, то есть вот такая типичная ситуация на самом деле.
Давайте еще раз обсудим это.
То есть какая-нибудь такая тупая типичная ситуация, но очень содержательная.
Это вот такое, вот такое, вот такое.
Вот. То есть вот такое вот.
И в качестве веселья еще вот такое.
То есть такая типичная ситуация.
Более того, в принципе, может быть, на самом деле еще фишка. Смотрите.
Вот еще такая ситуация бывает.
Вот эти птичка, это вполне себе компоненты вершины.
Вот. Так что тут разно.
То есть, как вы помните, то есть тут может что-то еще.
Ответвление. Какое-то еще ответвление куда-то там в другую сторону вполне себе.
Ну, в принципе, да.
Нет, в принципе, да.
Сейчас, как я, который должен быть точкой сочинения. Стоп, стоп, стоп.
Мы здесь вообще не пользовались тем, что это точка сочинения или не точка сочинения.
Вот тут надо быть аккуратно, потому что она может быть там точкой сочинения.
Просто по причине того, что тут еще что-то левое лежит.
Ее статус не поменяется, поэтому лучше этим не пользоваться.
Поэтому давайте поаккуратнее.
Вот с этим. Какой вопрос?
Да.
Нет, понятно, что если есть цикл, то все ребра на нем лежат вот так.
Да, но мы рассматриваем чисто ребра дерева DFS
и хотим сказать, чтобы они связаны были именно по ребру дерева DFS.
То есть, да, тут, конечно, мало ли как они связаны.
Другой вопрос, что выясняется, что у нас тут о перекрестных ребер у нас особо нет.
То есть, оказывается, мы опять воспользуемся тем, что связь у нас только здесь.
То есть, еще раз напоминаю, больше упаси.
Мы здесь забыли, что это точка сочинения, не точка сочинения.
Неважно. Мы здесь сказали другое.
Что мы сказали? Что раз.
То есть, мы рассмотрели одно из корневых ребер этой компоненты.
Мы выбрали такую компоненту, такую, что путь из нее в другую ведет через ребро из корня.
Теперь мы говорим.
Так, жила была вот это ребро.
Ну вот, это ребро связано с каким-то другим ребром.
Из вот этого соседнего дерева.
Двумя вершины, не пересекающимися путями.
Следовательно, из этой вершины можно без вот этой точки.
То есть, без вот этой точки.
Значит, попасть сюда.
Но выясняется, что чтобы попасть из этой точки, нужно выйти из-под дерева этой точки.
Выйти из нее мы можем только через обратное ребро.
Но обратное ребро, не проходящее через эту вершину, гарантирует нам, что вот это ребро...
Видимо, это ребро.
Правильно даже сказать, не вот этой вершины под дерево, а даже вот этой вершины под дерево.
Оно нам гарантирует, что вот это ребро и это ребро лежат в этой компоненте вершины.
Связывайте противоречие с выбором этого места.
То есть, доказать, что это...
Скажем так, из того, что этот путь существует, то есть отсюда не следует, что эта вершина не является точкой сочленения.
Просто она может по другой, просто из-за там левого отростка, является точкой сочленения.
Сейчас.
Нет, то смотрите, в принципе, да.
Сейчас.
На самом деле не все.
На самом деле, хорошо, давайте сформулируем такую лему.
Ладно, даже не красненькую, давайте.
Смотрите, там у себя рыженькую лему.
У вас в этих планшетах, там можно цвет, наверное, поменять автоматически.
Я сказал, рыжим.
Господи.
Так.
Значит, пусть оказалось, что там, допустим, какой-нибудь там УВ, обратное ребро.
Именно в эту сторону.
Обратное ребро.
Та-дам!
Та-дам! Та-дам!
Та-дам! Пум!
Вот.
Значит, тогда...
Значит, и снова у нас, да.
Тогда путь.
По дереву ДФС.
Из У, из ВВУ.
Лежит.
В одной.
КВД.
Ну, давайте такую.
Ладно, такую лему тоже рассмотрим.
Ну, так, чисто для...
Ой, ПВД, ПВД, ой.
Господи, наводил тут аббревиатуру.
Господи.
Ой, давайте математики наводят тут, а потом разбирайся.
Так, ПВД, КВД.
А, это вы еще экономику не изучали, впрочем, да.
Там вообще наводят буковки, и вы будете им жонглировать.
Вот.
Давай.
Да, в одной компоненте с, допустим, вот этим ребром.
Доказательства такое.
Потому что вот это ребро с этим, по нашему предположению, лежат в одной компоненте вершины двух связностей.
Но они разделены там деревом.
Мы между ними провели эти два пути, и выяснилось, что из этой вершины можно до этого ребра добраться, минуя вот эту вершину.
Вот.
Как устроен этот путь?
Этот путь ходит по под деревом этой вершины и в какой-то момент из него первый раз выпрыгивает.
Выпрыгивает он только по рыжему ребру.
Рыжее ребро идет выше этой вершины, но и выше этой вершины, раз мы ее минуем.
Но тогда получается, есть вот это ребро и это ребро, и есть ребро, которое соединяет под дерево этой вершины с предком этих всех вершин.
Тогда получается, что это рыжее ребро вместе с деревом DFS образует цикл, который проходит, в том числе, через эти два ребра.
В одной компоненте вершины двух связностей, да.
Это было вот.
Так, вот Лемма вторая.
Она тут, конечно, попроще.
Тут она вообще очевидна в такой формулевке, но полезная.
На самом деле она просто нам говорит, что если мы хотим нарисовать какие-то другие ребра,
то есть другие ребра, то мы вынуждены заключить, что они все лежат внутри.
То есть мы удивились, что убедились, что эти деревья в некотором смысле не объединяются.
И более того, оказывается, что внутри каждого такого дерева лежат все обратные ребра.
То есть по сути мы доказали, сложно это формализовать,
но то, что мы нашли, это скелет.
Вот это скелет, то есть это скелет и компонент вершины двух связностей.
Вот.
Но для того, чтобы найти, нам придется заметить еще одно очень важное, что.
Вот.
Чего?
Не, все еще круче.
Значит, у корня ПВД ровно один ребенок.
Ну, имеется в виду в ПВД, конечно.
В реальном дереве, конечно, их может быть сколько угодно.
Да, это важный момент.
То есть дерево висит не просто на одной вершине, но на одном ребре.
Нет, в общем-то, ничего неожиданного в этом нет.
Потому что, ну, то есть доказали, ну, вот.
Ну, то есть на самом деле, да.
То есть это может быть сейчас слет и неожиданный слом.
Ну, в общем-то, действительно, если у нас обнаружилась такая неожиданная ПВДшечка, допустим, да.
То есть какая-нибудь вот такая вот ПВДшечка.
И тут у корня образовалась неожиданно там.
Все.
Ладно.
Так, какой у нас цвет максимально похож на черный?
Ну, это тогда.
А, ой, тогда-тогда-тогда-тогда.
Да, во.
Все отлично, все спасибо.
Ой, да что ж такое, все спасибо огромное.
Вот, господи.
Что бы мы без Таисии делали.
Во.
Вот.
Вот.
Вот он.
Вот она.
Да.
Вот.
Значит, да, если у нас тут есть хотя бы два ребра или больше, да.
То тут теперь возникает вопрос.
А как, простите, связаны эти вершины без этой?
Ведь если эти вершины двусвязаны, значит эта вершина связана с этой каким-то путем.
И без этой вершины.
Как выглядит этот путь?
Так.
Ну, как-то, наверное, выглядит.
Только перекрестных ребер у нас нет.
Поэтому давайте стандартное доказательство.
Да.
То есть вот стандартное доказательство.
Берем обычную пластиковую бутылку.
Вот, в которой висит поддир в этой вершине.
И пытаемся, значит, пойти сюда.
Идем, идем, идем, идем, идем, идем, идем.
И обратное ребро.
Ура.
Почему ура?
Потому что это обратное ребро.
Раз оно идет не только выше этой вершины, но и этой.
Это означает, что тут есть какой-то родитель.
И даже несколько.
И все эти ребра тоже в одной компоненте вершины двусвязанности.
Противоречие.
С тем, что это корень.
Ура.
Вот.
Что?
Не, лему два.
Ну, лему два мы просто доказали, что...
Ну, по сути, да.
Ну, да.
Все это исследует из того, что...
По сути, да.
Обратное ребро образует деревом ДФС цикл.
А так как это цикл, то тогда получается, что это одна компонент вершины двусвязанности.
Ну и очевидно, что, по крайней мере, этот путь точно в одной ПВДшечке лежит.
Вот.
То есть важный момент.
Вы видите, кто-то, внимание, могли обратить внимание, что у меня тут как-то в подделье...
Почему-то я тут...
У поддельев действительно у каждого корня только один ребенок.
Но я это рисовал не случайно.
То есть, собственно, вот по этой причине.
То есть, кстати, самое смешное, что по модулю этого факта, конечно, дерево...
То есть деревья на самом деле могут быть устроены абсолютно произвольно.
Ну, например, потому что...
Ну, например, там самый тупой пример.
Я могу нарисовать абсолютно любое подвешенное за одно ребро дерево.
И из каждой вершины в корень дерево отправить обратное ребро, например.
Вот.
То есть это на тему того, какие там...
То есть там внутри, конечно, после этого одного ребра там витления могут быть от слова какие угодно.
Вот.
Поэтому теперь...
Но смотрите, знаете, что это нам дает?
Это нам дает возможность, важную возможность на самом деле, добавить...
То есть это нам дает возможность теперь действительно пытаться...
То есть теперь говорить, что компоненты у нас висит на ребре.
И смотрите, как теперь это...
И это нам дает возможность теперь найти компоненты вершины двусвязности.
Вот этой вот уже имеющейся у нас технологией.
Потому что в этой технологии теперь нужно определить, что ребро дерева DFS.
То есть теперь у нас есть понятие корневое ребро компоненты.
Да.
Теперь заметим, что корневое ребро компоненты.
Ну да, можно еще употреблять ПВДшечки.
Но видим, что у нас ПВДшечка и компоненты, как мы уже убедились, это одно и то же.
Вот.
Вот так.
Вот так.
И вот так.
Вот.
А, и вот так, конечно.
И теперь надо просто про каждое ребро...
Теперь у меня идея такая.
То есть я хочу теперь просто про каждое ребро теперь научиться понимать.
Это ребро является...
Каждое ребро является ли оно корневым в своей компоненте вершины двусвязности?
Да или нет?
Потому что если я это определю, то тогда сделаем вот как.
Потому что теперь код будет выглядеть немножко по-другому.
Да, ну там скопипастя там у себя.
Потому что смотрите.
Я вам сразу скажу.
Сейчас будет немножко магии.
Смотрите, веселая технология.
Смотрите.
Во-первых, потому что я убрал эту строчку.
Почему я ее убрал?
Ой.
Потому что тут все надо убрать.
Ладно, будем писать вместе.
Будем писать вместе.
Да, ну вот.
То есть это оставим.
ColorDFSBlack оставим.
Вот это тоже уберем.
Почему это уберем?
Потому что, как вы уже догадались, в стеке мы больше вершины не храним.
Мы в стеке теперь храним ребра.
Вот.
Да.
Значит, поехали.
Значит, поехали.
Значит, фор.
Значит, тут я напишу так.
Edge.
Значит, E равно там, соответственно, VUID в граф от V.
Ну, было граф.
Ну да, да, да, да.
Ой, ну и что такое?
Ну что, в крепком решке 5 же вы можете ехать там.
Там погоня идет.
То есть по Москве, то по Будапешту, то по неизвестной местности и так далее.
И все это прямо на соседних улицах.
Да, ну как-то нормально.
Вот.
Да, конечно, это из цикла.
А кто сказал, что крепкий решет 5 – это крутой фильм, конечно.
Ну, знаете, как в некоторых сериалах про авиакатастрофу.
Знаете, как бывает, да?
Я вам такой рассказал, что там просто действительно авиакатастрофа.
И там второй пилот говорит, ладно.
Ладно, единственный успокаивает, что наш сериал американский,
поэтому конец должен быть хороший.
Ну, первый пилот так спокойно развлечивается и на чистом русском и говорит,
а кто вам сказал, что это американский сериал?
Ну вот.
Наспотя, что такое плохо.
Нет, обычно типичный американский сериал.
Нет, нет, у тебя типичный, да.
Есть в концертах какой-нибудь крепкий решет 2.
Там самолет упал, там все погибли, там взорвались, там, значит, куча народу погибла.
Но в итоге все хорошо, потому что главный герой спас жену.
Но там это как…
Не, ну да, там типичная ситуация.
Да, как это…
Ну, ой, так, ладно.
Длинные ассоциации.
Господи, как мы столько…
Господи, откуда у нас 54 билета?
Вот вообще, такими темпами откуда у нас 54 вопроса вообще в билетах на экзамене было?
Я ж вас это, как говорится, там по кино-то не гонял.
Вроде так.
Да.
Не.
Значит, ладно.
Тихо, тихо.
Так, тихо.
Ну, погодите.
Нет, погодите.
Мне самому интересно, сколько у нас будет вопросов еще.
Тихо, тихо.
Значит, граф.
Значит, бежим.
Ну, во-первых, начинаем.
Так, давайте…
Значит, здесь я тут ввел скобочку, потому что мне прям очень хочется сказать, что
если id равно id per, то мы выбрасываемся с криком continue.
Все.
Не хочу об этом думать.
Вот.
Значит, дальше идем.
Значит, если…
Значит, теперь.
Если оказалось, что color от u равно равно…
Значит, e dfs white.
Вот.
Ну, как бы цвет белый, поэтому пишем черный.
Логично.
Вот.
Так.
Как говорится, какие шутки?
Вы уже еще час назад прокрутились в голове.
Да.
Вот.
Значит, смотрите.
Так.
Ну, поехали.
Значит, пишем, во-первых…
Давайте так.
Dfs от, во-первых, u и, конечно же, там…
Значит, этого id-шника.
Так.
Так, не забываем пересчитать uptime.
uptime от v там, как всегда, min равно uptime от u.
Так.
Что еще пишем?
И теперь…
Так.
Ну и теперь приходит время ввести что-то красненькое.
Если оказалось, что v у корневое ребро своей компоненты,
там вот, короче, свои pvd, будем до краткости писать,
да, то…
И тут я понимаю, что я кое-что забыл.
Как говорится?
Что я забыл?
Что я забыл?
Да.
А забыл я…
Ой, да, самое важное, что я тут забыл.
Вот сюда, в самом начале, вставить наше ребро e в stack.
Да.
В самом начале, именно перед…
Это важно.
Это надо сделать именно перед dfs.
Обращаю на это внимание.
Да.
В общем, вряд ли не сохраняться.
Да.
Ну вот.
Да.
Осталось только выяснить, какие варианты.
Да.
Мы еще пока не вводили.
Да.
Знаете, когда…
Как это называется?
Да.
Как говорится, мы сдали десятую задачу.
Надеюсь, команды не…
Там противники не успели объявить тайм-аут.
Все были, что какие тайм-ауты на контестах.
Вот.
Ладно.
Сложный прикол.
Так.
Значит, смотрите.
Значит, если, короче, ладно, даже не v у, а вот именно
где оказалось корневое ребро pvd, каким-то мистическим
образом, то что мы делаем, то значит тогда…
Да, да, да, да.
Ну да.
То есть, пишем вектор, как всегда.
Вектор, на этот раз edge.
Comp.
То есть, как всегда, do, значит, как всегда, значит,
comp.push.
Comp.push от st.top.
Там st.pop.
While.
While, show.
While, show.
Ну, while, понятно, e.
Ну вот.
While.comp.
While.comp.back.id не равно id.
Вот.
Так, ладно, это мы тоже уберем.
Вот.
То есть, просто технология хочет вот такая же.
То есть, если мы идентифицировали корневое ребро, то значит
хочется сказать, что все, что висело на нем, сейчас
вот в стеке после него и висит.
Вот.
Но, правда, для этого нужно много чего сделать еще.
А именно, очень-очень-очень аккуратно обработать…
Да.
Значит, во-первых, да, потому что надо написать, если
ребро обратно именно в этом направлении.
Там еще надо желательно следить, чтобы ребро не было
добавлено в стек в два раза.
Ну, ребром дерево DFS, конечно, мы это надежно делаем вот
в этом месте.
Да, именно.
Поэтому, значит, если оказалось, как мы проверяем, что ребро
обратное, мы проверяем, мы пишем.
У нас, опять же, есть… То есть, если color от u равно
e dfs grey, как вы пишете, господи, вот…
Господи, все про серый мы пишем.
Рыжий про белый, черный…
Скажется вот.
Вот, внимание, вопрос.
Да, кстати, да, как вы думаете, почему вообще введены все
цвета именно белый, серый, черный, а не вот там красный,
желтый, зеленый?
Так это не верно движению, как минимум, потому что
я это не слышал, чтобы он умер.
Во-первых, напоминает.
Нет, я думаю, все гораздо проще.
Нет, я еще не пришел в голову.
Причина, я думаю, та же, почему там в оригинале, в линкате
там ребра сплошные и пунктирные, а не красные и зеленые.
Да, потому что, да, потому что статьи все-таки в основном
черно-белые печатаются, поэтому…
Особенно в те времена не то, чтобы там, называется,
разбежишься на цветных этих, поэтому там…
В те времена красно-черные.
Ну ладно, нет, красно-черные…
Нет, ну не важно, красно-черные, это как бы там к авторам
вопрос, почему там оно именно красно-черное, но…
Зачем это все вообще, да?
Ну не знаю, с другой стороны, зачем это все, наверное,
я думаю, там это на фистехе, на многих предметах возникает
такой вопрос.
Кроме чего?
А, на мотлоге все логично.
Да, мотлог понятен, он нужен для того, чтобы на
насталих предметах была хоть логическая связанность.
Ну да, не, ну пойдите, там на батарее не возникает,
господи, зачем нам эти интегралы вообще нужны?
А чтобы обращать производную, зачем нужно производную?
Ну а наш вот так, чтобы касательно искать…
Ну да, нет, ну там везде, на самом деле.
Нет, хотя нет, в этом смысле да, потому что кто-то так
расстраивается, что там, допустим… Нет, на самом деле, если
серьезно, на самом деле есть, и тогда бывает грустно,
что вот вы там, допустим, физику не учите, на самом деле
в физике там действительно многое возникает, зачем это
все, где вообще-то надо, хотя вот да, нет, не вот это.
Нет, к сожалению, в физике нет, максимум, да, где-то
рядом в биологии может быть анализ ДНК, и там
каких-то тут угорит мы на строчках, но и то там.
Ну это все, конечно, да, но ладно, математика – вещь такая.
Вот так вот, значит, есть у нас, значит, есть у нас
наше ребро, соответственно, ведет в серую вершину, значит,
это оно именно в этом направлении рыжая, и поэтому именно,
значит, поэтому, значит, нет, надо сделать две вещи.
Во-первых, про апдейтить аптайм, не забываем, аптайм
в общем, про апдейтить именно таймином, таймин от У,
но и совершенно верно, st.push этого ребра.
Да, нет, надо красненьким это все-таки написать.
Вот, обработали.
Да, а если это ребро прямое, и мы его рассматриваем
как прямое, то ничего делать не надо.
Так, ну и в общем-то все, остается только в конце объявить
тайм-аут, хотя самое смешное, что тайм-аут можно не объявлять.
Да, таймином нам на самом деле достаточно, но объявить
вершину черной нам, конечно, надо.
Color от V равно EDFS black, наконец-то в соответствии с цветом.
Так, да, все.
Так, ну что ж, поздравляю.
Мы нашли компоненты.
А, вот я тут забыл еще важную там еще строчку.
Там вот, да, save, save-comp sqvd.
Ну, типа сохранить vector-comp как компоненты вершин
двухсвязи.
Вот, то есть в принципе получается действительно так,
и доказательства, в общем-то, примерно такое же.
Именно вот для этого мы доказывали, что если мы вышли
из компоненты, то мы в нее там, в поддеревье, уже не
вернемся.
Вот, и в поддеревье, и там в будущих каких-то деревьях.
Поэтому как бы мы тут действительно можно аккуратно
все добавляем, но как бы если мы вошли, то есть выйти
из компоненты там, в поддеревье, можем только через корневое
ребро.
Соответственно потому что, ну вот, потому что одновременно
мы замечаем, что корневое ребро это первое ребро
компоненты вершины двухсвязи, которое вообще попало в
ДФС.
Видите, да?
Которое ДФС вообще увидел.
Поэтому, действительно, ну вот, поэтому там вот
действительно про каждый компонент все это по индукции
говорит, что есть компоненты, есть то, что на ней висит,
и просто по индукции аккуратненько доказывается, что все,
что на ней висело, оно бы, оно, собственно, из стека
удалилось, поэтому, ну вот.
А вот эти вот серебра, в том числе обратные, которые
тут лежат, они тут тоже останутся.
Вот.
Остается только, значит, смотрите, остается только
вопрос, как найти точные сочленения?
Ну да, есть, конечно, метод имени удаления мостов.
Ну, то есть, видно потом в тупую пробежаться и посмотреть,
какая вершина принадлежит больше, чем одной компоненте.
Но этого, конечно, не нужно делать.
Потому что, на самом деле, тут утверждение очень простое.
Ну, тут, конечно, правда, с подлянкой.
Обычно, если вам где-нибудь там в какой-нибудь ЛКШ
или там где-нибудь еще.
Вот.
Или там в любом другом Тинько Яндексе что-нибудь рассказывали.
Вот.
Ну хорошо, да.
Ну и Сириус тоже, да.
Нет, ну мало ли.
Вот.
Нет, ну это могли рассказывать, господи, хотя некоторые алгоритмы,
возможно, вы слушали по нескольку раз.
Не успели?
Не успели, что ли, Яндекс?
Мы выписались, да.
А как появился?
О, Яндекс.
Я поэтому называю Тинько Яндекс.
Потому что до этого он был Тинькофом, да.
Вот.
Понятно, что Яндекс вам уже ничего не рассказали.
Но как бы, как бы я скажу, команда была та же.
Вот.
Надо ее Тинько Яндексом называть, чтобы там было понятно.
Вот.
Ну вот.
Но там, скорее всего, просто говорили.
Как искать точку осуществления?
Не знаю, правда, как это доказывали.
Хотя нет.
Самое смешное, что там алгоритм можно без всего этого доказать.
Но из нашего уже и так очевидно, что, в общем-то...
Ну, то есть удержание такое, что, наверное, там...
Ну, во-первых, так.
Тут, конечно, есть разница все-таки.
Есть вершина корень дерева или не корень.
Корень глобального дерева.
То есть если вершина корень, то тут все просто.
На точку осуществления тогда и только тогда, когда действительно у нее нот...
Когда у нее хотя бы два нотка.
Ну, скажем так.
Когда из нее торчит хотя бы два корневых ребра.
То есть, по сути, она два раза пошла вот в этот ДФС.
Хотя...
Ладно, вру.
Нет, ну ладно.
Там...
Ну, точнее так.
Просто любое ребро, по которому оно пошло из корня, это по-любому корневое ребро.
Правда?
Да.
То есть там просто фишка будет в том, что если это не точка осуществления,
то мы из вершины пойдем по одному ребру.
И в общем-то тут уже все обойдем, потому что без этой вершины тут уже отсюда можно дойти по белым путям.
Вот.
То есть, поэтому, если это так, то да.
Если это нет, то значит мы одну компоненту обойдем.
Придется вторую идти.
Поэтому просто у корня, если там хотя бы два раза же не удовлетворяется, значит точного соединения нет.
Нет.
В любом ином случае тогда у любой другой вершины есть такая компонента...
Значит, есть ребро, которое ведет в родителей компонента, связанная с ним.
Да.
И может быть какие-то другие.
Но, очевидно, другие могут быть только, если из нее торчит какое-то корневое ребро вниз.
Ну вот.
Да.
Как мы определяем, что ребро корневое?
Ой, точно.
Господи, самое важное забыли, да.
А как мы, собственно, вот это-то определяем?
Как определить, является ли ребро корневым?
Видимо, надо посмотреть, если есть В и У, У типа ниже.
Тогда у нас пытается проверить, что off-time от У.
Да.
Да, наоборот, В и У.
Да, как понять, чем отличается корневое ребро от не корневого?
Получается меньше...
Либрайн В?
Угу.
Нет, больше правильная.
Ну да.
Потому что может быть ближе.
Так, ну да.
Нет, ну давайте так.
Я просто напишу это утверждение.
Просто мистическая, даже может быть, уже теорема.
Там пусть У.
Я тут даже напишу зачем-то.
Пусть У именно ребёнок В.
В дереве DFS.
Тогда это ребро В и У.
Тогда ребро В и У.
Значит, корневое...
Корневое В, соответственно, в КВД.
Ну вот, так сказать.
Теперь можно об этом говорить.
Тогда и только тогда.
Когда?
Да, таймы на этот раз от В.
Потому что на этот раз обратите внимание...
То есть на этот раз обратите внимание, какой там обратное ребро ведущее.
То есть ведущее как раз вот куда-нибудь вот сюда.
Сюда нас вполне устроит.
Вот.
Да, да, да.
То есть доказательство очень простое.
Что если оно корневое...
То есть суть такая.
Что на самом деле утверждение такое,
что пусть у нас есть ребро...
Ну, во-первых, так.
Если оно в дереве DFS...
То есть если В корень, то как бы всё очевидно.
Ну, оно просто любое.
Потому что любое ребро DFS корня,
оно по-любому корневое.
В своей КВД.
Это мы уже выяснили.
А теперь пусть ребро ВУ не корневое.
Тогда утверждение такое.
Как мы уже увиделись.
Ребро ВУ лежит в одной...
Оно корневое тогда и только тогда,
когда оно не лежит в одной компоненте
с родительским ребром В.
Правда?
Но эти два ребра лежат в одной компоненте
в вершине до связности.
Тогда и только тогда,
когда обратное ребро из-под дерева У
куда-то выше В.
То есть когда аптайм от У меньше
строго на этот раз,
чем таймы над В.
Видите, да?
То есть обратите внимание,
это более слабое условие,
чем то, что это ребромост.
То есть мост требует,
что обратные ребра выше вершины У
не высовываются.
А то, что это корневое ребро,
для этого достаточно,
потому что у тебя просто на равенство.
На равенство?
Да, они должны быть в одной компоненте.
Ребро тогда...
Нет, чего? Где? Почему на равенство?
Аптайм от У... Нет, почему?
Если ребромост, то аптайм будет строго
больше. Да.
Так что на равенство.
Поэтому так. Но я говорю, у меня
еще тут фишка, что у меня...
Я тут стер, но хотя я тут должен написать,
что...
Тут я еще должен написать, что
аптайм от В равно плюс бесконечность,
напоминаю.
Вот. Поэтому точные сочления,
я тут не буду сейчас вставлять в код,
на самом деле можно найти и внутри этого кода тоже.
Нет, в принципе,
это действительно, на самом деле, да.
То есть там действительно возникает интересная задача.
Вот.
Ну, потому что, да, вот кто-то уже упоминал,
потому что там часто иногда бывает, что
можно на самом деле...
То есть если рассматривать так компоненты,
то действительно
будет получаться действительно такое
пухленькие снеговички такие, связанные
между собой.
Ну, вот такой вот. Ну ладно.
Вот. Ну вот такой.
Вот.
Да.
Ночебурашка тоже.
Ну а что?
Вот.
Нет, ну шо покляк.
Не, ну ладно.
Это уже какой-то странный чебурашка, конечно, да.
Вот.
Не, ладно. И так уже тут шейка какая-то
странная, да.
Такой жирафик, да.
Да-да-да.
Вот.
Да-да-да.
Вот.
Нет, жираф
тут реально какие-то ноги рисовать надо, да.
Бамбуковые. Вот.
Бамбуковые ноги, да.
Ладно. Ну вот. То есть в принципе это
действительно так выглядит.
Ну ладно, скорее вот так, наверное.
Вот.
Но просто фишка в том, что действительно
на самом деле иногда, то есть можно иногда прям
в явном виде на самом деле построить
какие ноты. То есть построить
какой-то такой двудольный граф, в котором
в одной доле находятся вершины,
а в другой как бы компоненты вершины
двусвязности.
Чего?
Значит вот такой объект. Рассмотрим
двудольный граф, в котором
лежат в одной доле
вершины исходного графа, а в другой
компоненты вершины двусвязности.
Тогда кажется, что
во-первых, через этот граф дерева будет.
Да, соединяем вершину
с там, проводим ребро
между вершиной исходного графа и компонентой,
если эта вершина к ней имеет отношение.
Ну то есть инцидент на какому-то ребру
из этой компоненты вершины двусвязности.
Тогда легко убедиться, во-первых,
что это дерево.
Вот.
Ну в качестве упражнений оставим.
Ну кстати, там Тарьян вообще сидел, доказывал, что там
какие-то это, что любые компоненты
вершины двусвязности две, допустим,
имеют не более чем одну общую вершину.
Ну да, ну скажи,
само общее упражнение очевидно,
но как бы там, видимо, потребовалось его
явно сформулировать.
Вот.
Ну это нормально.
Ну там, не помню, не важно.
Вот, значит, ну вот.
Во-первых, вот этот граф вдоль будет, во-первых, деревом.
Ну а во-вторых, там в нем, в этом дереве
можно, ну вот.
Ну во-вторых, да, там вершина является точкой сочленения,
допустим, тогда и только тогда, когда она,
когда там, в вдвудольном графе
она не висяча.
Внезапно, да?
Вот.
Ну и оказывается, да.
Ну и там, ну я не знаю, там, отдельная
песня вообще, там, слета не скажу,
но, например, там, но иногда вот это
дерево как-то полезно воображать, потому что там вот
во всех задачах, где возникают компоненты
вершины двусвязности, иногда полезно воображать. Правда, я не помню,
струту с дочью, в которой его надо реально кудить.
Вот.
Хотя там может...
Мэр.
Пример-министр.
Пример-министр, да.
Так, ну...
Два вершины не пресекающихся пути
между двумя вершинами.
Так.
Так, два не пресекающихся пути,
буквально именно найти?
Нет, ну...
Нет, ну...
Скажем так, да, да, ну...
Ну, кстати, интересная задача, да,
напиши поток и возрадуйся нет самое самое смешное что как бы тут надо еще придумать на этом
основе решение которое по своей сути не окажется более сложной реализации потоков вот так ладно кто
знает что такое поток вообще ну да ну без этого там это я знаю да потока это тот это продвинутый
вот это основной вот это или там да поток а да вот это вот это когда в каждой точке вектор там
вот это или там поток а но этот вот это insta instream out stream там вот это нет чего страшное не
почему современное вот как бы сегодня после но сегодня на семинаре второкусники вообще узнают
что поток это на самом деле а это вот это вот да когда компьютер одновременно несколько действий
делают вот да то есть на самом деле так с этим вот я вытаскиваю как я все нет то есть нет только
чисто программирование до слов поток можно перейти как threat можно перейти как stream можно
перейти как flow да то есть в этом курсе мы будем изучать flow в прошлом году вы изучали что такое
стрим в четвертом семестре а нет что в прошлом году в прошлом а вы давайте так вы уже на си плюс
плюсе изучали стримы ну вот ну ладно возможно возможно сейчас покопать ну может там в один
стандарт так что-то новое не знаю ну скорее что-то вели но вот и но вот так конечно и в четвертом
семестре вас ждут соответственно стрелит там четвертом семестре в пятом тоже там будете
работать уже с френдами вот так ладно так значит теперь да допустим давайте подумаем над задачей
да так да не все знают ну кто значит такой поток хотя кто знает ладно может даже не может даже
прямо спросить а кто когда-нибудь решал просто задачу улитки хотя самое смешное что задача
буквально хотя нет самое страшное что задача буквально такая же не там просто данграв даны
две вершины найдите между ними два реберна не пересекающихся пути нет там в тупой версии даже
хотя но не дадут область по паре лайфхаков да так а мы сейчас а мы сейчас хотим именно вершины
нет давайте так нет ладно есть тупая версия существует ли два хотя бы два пути да или нет
да то есть тогда надо проверить лежат ли лежит вершины в одной компоненте как проверить
но да то есть но вообще кстати это уже не тривиально потому что даже если мы построим
наши двудольный граф там двудольный граф квд то как бы надо проверить верно ли что этим двумя у
этих двух вершин там эти две вершины связаны там с одной компонентой вот кстати действительно
интеллектуальная задача как это сделать как это сделать если одна из этих вершин не точка
сучленения то конечно это сделать очень легко а если обе эти векшины точки сучленения то как бы
так да вот так чтобы туда туда и туда
а вопрос сколько это сколько таких векшин вывести а а вот и да так а да да если у нас а
один один запрос нет да да да да ну согласен тогда в этом ну хотя по-разному
смотреть давайте скажем о чем мы говорили да что есть у нас в исходной задачи хотя бы
только один запрос то конечно там надо просто там проверить действительно лежат ли они в одной
то есть для каждой вершины то есть проверить эти списки компонент рыбы вершины до связи
которым они принадлежат проверить пересекаются ли они просто вот да да да да вот если да если
много пар то то как бы да у нас да если если много пар то у нас проблема хотя конечно слет
у меня возникает просто сразу ассоциация с корневухой стандартной но потому что утверждение нет
смотрите утверждение такое допустим я но там тупое решение такое каждое каждый список компонент
я записываю запишу хэшмап тогда идея такая у меня есть две вершины у каждой из них есть
хэшмап вопрос пересекаются ли хэшмапы да теперь если у одного из этих хэшмапов размер меньше
чем корень из н или там корень из е я пока там слету не знаю но пусть будет там корень это там
да корень из е давайте пусть будет то а так это тогда я за корень из е в принципе пересечение
проверил правда а теперь предположим что этих двух вершин значит списки больше чем корень из
е вот тогда у меня неожиданная тупая идея тупая идея называется а заметим что таких вершин в
принципе немного потому что если каждый из этих вершин но потому что но если каждый но скажем так
смотрите ну давайте так смотрите количество каждой связи вершины и компоненты рюберной
связи соответствует ребро в дудольном графе оно дерево следовательно этих связей не более
чем даже не более чем ровно 2n минус 1 логично да значит 2н минус 1 вот значит да то есть
то есть это но вот то есть этих связей значит что это означает это означает что значит ука значит то
есть если мы просумируем каждый вершины количество связей то получится их суммарно
сколько там 2н минус 1 следовательно если мы хотим разобрать вершины которые связаны с
более чем корень из н компонентами значит их тоже не более чем там 2н минус 1 поделить на корень из
это тоже от корня вот это дает нам возможность делать тупую вещь а давайте все такие пары вершин
заранее переберем и предпочитаем для них ответ то есть предподсчет получится за что-то там где корни из
вы ну да нет а посмотри какая нота нет ну да нет но есть у нас задача но там разрешет
дай читам можно вычислить список да вы писать или там что-нибудь еще нет ну в принципе дайте я
честно скажу да не смотря какая задача да то есть конечно есть у нас задача данные две вершины
один запрос то вообще задачи не о чем да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
да да да да да да да да да да да да да да
да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да при возведении
как это можно сделать ну например мы умеем там вообще-то за там какие-то за тупые предподсчеты
там просто быстро расстояние между любыми двумя вершинами искать помните но типа глубина одной
глубина второй минус там две глубины лцашки но в данном случае все еще тупее потому что на
самом деле у вас там как бы две вершины нас а на самом деле друг от друга находится на расстоянии
два только только в двух случаях первый случай у них общий родитель второй случай у родителя
одной из них родитель это она все оба случая проверяются значит в одном графе берем родители
там все вершины и вершины исходного графа вот а в другом акции про два минусом я наврал компонента
а нет хотя нет компонент с не более чем и минус один да вот а в другой доле мы рисуем
каждая вершина соответствует компоненте вершины до связности да ребер да чего каждой компоненте
вот да и тогда вершина соединяется с компонентой если там в исходном графе она в ней там не имеет
отношения то есть инцидент на ребру из этой компоненты вот так вот то есть если так проверить на
расстоянии два это легко но в принципе да могла бы быть задача да классическая задача конечно
такая веселая так что-то с ним гоняет никто ну ладно вот то есть данные две вершины в графе скажите
то есть да то есть как бы мы хотим рассмотреть какие-то все пути от удове теперь возникает
вопрос нам хочется найти все вершины через которые любой путь от удове точно пройдет
ну хотя бы сколько их но утверждение такое да мистическое утверждение да заключается в том
что да что надо посмотреть в этом вдольном графе компонент надо просто найти расстояние от удове
поделить его пополам и более того все а если надо сами вершины найти то надо просто на этом
hil exit там все вершины вывести вот потому что что этот путь там что этот путь будет означать
пока вот если вот это вот типа компоненты то есть ну суть будет такая что компоненты то есть
на самом деле значит получается они будут просто зацеплены друг за друга вот таким вот образом
понимаете да вот и ну вот и тогда получается но и тогда может быть не совсем очевидно
очевидно, но там можно подумать, аккуратно доказать, что действительно, во-первых,
что действительно путь обязан пройти через вот эту точку, значит, потом по этой компоненте
прийти вот эту точку, потом через вот этой компонент прийти эту точку и так далее.
Внутри отсюда-сюда можно дойти без любой вершины, тут внутри без проблем. Вот, но без этих мы уже
не обойдемся. На самом деле можно себе воображать это и так. Смотрите, как естественно рассмотреть путь,
то есть на самом деле можно рассмотреть как минимум путь в дереве DFS. Вот жила была тут вершина U,
тут вершина V, допустим, и мы, допустим, отсюда-сюда просто по дереву DFS идем. То есть когда-то мы идем по
компоненте, но когда-то эта компонента меняется. Но меняется она навсегда, и у нас получается
действительно такая цепочка. Вот, но на самом деле теперь остается только утверждение, что любой
простой путь, во-первых, за пределы этой почте никуда не выйдет. Вот, ну, точнее там просто фишка будет
в том, что действительно есть. Нет, по дереву тогда, но нам просто интересно, как выглядят другие пути.
Ну может быть, да. Нет, ну там есть, там по-разному можно делать, можно прям
честно через LCA так рассматривать, как они тут выглядят. То есть там какие-то вот эти
вот развлечения начинаются. Ну ладно, там очень можно. А потому что в пути там будет путь такой
вершина компонента, вершина компонента, вершина компонента, вершина, но там пополам может минус 1. Вот.
Да, то есть такое можно решать очень там. Да, то есть если воображать, хотя бы воображать себе такое
дерево, то можно много чего делать. Вот, так что да, тут разные задачи есть, конечно. Так, ну ладно,
к сожалению, до уровня Hard мы сегодня не добрались. Хотя, не знаю, мне уже ощущение, что может быть это и был
Hard, но нет, на самом деле почему будет Hard? Значит просто анонс, значит перейти двум
мостик на следующий раз. Значит следующий раз, да, вот это все, спасибо огромное, сразу. Нет, нет, а этот тоже ваш? А, именно этот и ваш есть, да, да, да. Вот. Нет, смотрите, значит анонс на следующий раз,
потому что следующий раз будем изучать компоненты сильной связности. Значит, мы попробуем применить ту же
технологию, тоже искать, запускать DFS, искать корневые вершины, но фишка будет в том, но у нас будет
проблема. Здесь мы сильно пользуемся тем, что у нас помимо дерева DFS есть только обратные рёбра, а там есть и другие. Да, ну прямые можно выкинуть, но с точки зрения сильной связности прямые рёбра можно выкинуть, а вот с обратными, а вот перекрёстные нет. И вот, и там много будет, там разные подляночки, ну и на этом мы соответственно, ну вот, и соответственно будем изучать. Но кажется, нас уже начинают выгонять, поэтому, вот, поэтому будем искать.
ПРОДОЛЖЕНИЕ СЛЕДУЮЩЕГО ПОЛИЦЕЙСКОГО ВИДЕО
