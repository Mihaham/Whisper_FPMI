Я сегодня хотел рассказать про алгоритм поиска парсочетаний,
на всякий случай спрошу, не было ли это у вас уже
где-нибудь там те ремы холла такого не было да в принципе бываешь даже в мошколах изучают
лк тг а нет я понимаю для меня просто лк тг означает летняя конференция турнира городов
и там прям с доказательством было понятно да хорошо ладно мне но собственно я хочу по
двум причинам поговорить про эту тему да и вообще этот уже традиционно включается
во-первых это интересно интересно само по себе да это относится там центральным алгоритмом
вот ну и соответственно посмотреть я это я на эту тему хочу не из точки зрения собственно
математики доказательства с точки зрения алгоритм в которые возникают вот ну а вторая
причина историческая даже на самом деле именно в статье которая это описывала даже нигде
те ремы холла а где те те те рема об алгоритме стягивания цветков значит и ремы этманса вот
в той статье впервые было написано что полиновия значит быстрая да то есть там статья была примерно
так устроена что этман сначала доказывает что его его алгоритм работает потом оценивает время
работы этого алгоритма и потом говорит что вот видите получился поляном вот ну и вообще надо
сказать что вот поляном это эффективно вот это был еще 1965 год еще до постановки про пнп вот
этом это важно в историческом плане так но хорошо значит вот значит у нас алгоритма
алгоритма поиска паросочетаний значит так вообще паросочетания но по определению в
графе паросочетания это набор ребер которые не пересекаются по вершинам что вообще
паросочетания это набор ребер не имеющих общих концов вот значит сначала
разберем лучи двудольного графа
значит поэтому там теория мы холла еще час называть там теория о марьежах да потому что
предполагает что вот есть там юноши и девушки и у них есть какие-то предпочтения ну это значит
есть теория мхоп предпочтения где там устойчивый паросочетания а есть принципе приемлемые
паросочетания да что у каждой стороны есть список партнеров с которыми они готовы быть в паре вот и
это все выглядит как не предудольный граф какое-то количество вершин с одной стороны
есть какое-то количество вершин с другой стороны какие-то ребра даже вот как-то идут
так значит я тут нарисовал а значит я тут нарисовал что у меня в левой части на один
элемент меньше чем в правой части вот поэтому совершенного паросочетания здесь не получится
дальше совершенно называется паросочетания в котором каждый вершина участвует значит
совершенное паросочетания вот это значит такое такое в котором участвуют все вершины
значит дальше есть максимальные паросочетания и наибольший паросочетания и это немножко разные
вещи дальше как вообще когда говорят о частичном порядке то максимальные означает элемент меньше
элемент больше которого нету она и больше означает но тут больше всех вот но здесь имеется в виду что
максимальная максимальные паросочетания означает не увеличиваемые не увеличиваемые
вот ну а наибольшие паросочетания это содержащие наибольшее число ребр
наибольшее паросочетания это содержащие
наибольшее число ребр вот и это не одно и то же да значит вот простейший пример
значит простейший пример когда у вас ну например вот так вот соответственно если мы возьмем
значит если мы возьмем вот это вот ребро то одно это ребро будет не увеличиваемый паросочетания
потому что тут больше никого нельзя добавить вот соответственно максимальная конечно будет
на то есть вот это вот будет это будет максимальная а наибольшее наоборот другие два будут вот эти
вот будут наибольшее но наибольшее потому что больше никак не может быть так так что это
разные вещи но и максимально искать очень просто да максимально ищется простейшим жадным алгоритмом
просто берете ребра пока еще можно взять да если нельзя взять значит оно есть максимальное по
определению вот поэтому значит с максимальным никакой проблемы нету вот ну соответственно
а значит основная задача наибольшее по рассчитания да потому что к ней совершенно легку сводится
значит если вы ищите наибольшая если в нем столько ребер сколько вершин в каждой доле то оно и будет
будет и совершенное вот если наибольшее если наибольшей не все вершины входят значит совершенно
нету значит существует совершенное существует совершенное тогда и только тогда когда значит
в наибольшее ходят и вершины
поэтому основная задача это задача наибольшим по рассочетания вот значит в прочем про именно
про совершенной есть вот эта известная теорема холла так давайте я ее сформулирую ну и докажем
так значит теорема холла 4 холла о совершенных по рассочетаниях да или там о марьежах ее называют
значит смотрите существует совершенная пара сочетания
тогда и только тогда когда но на самом деле бывает еще так что совершенно называют как максимально
возможная да то есть так чтобы хотя бы в одной доля все были включены ну либо может сказать что
заранее сказано что да что слева и справа одинаковое количество вот значит существует
совершенно пощадка тогда и только тогда когда для любого множества да значит тут может кинуть
обозначение да значит давайте графя левая часть правая часть и рёбра
да значит удольный граф значит существует тогда и только тогда когда для любого под множество
с под множество l значит размер множество соседей больше ли браин чем размер нововица
значит вот это вот и на тес это но что вершин но что вершин естественно р значит соединенных
соединенных хотя бы с одним элементом вес
вот но то есть что здесь происходит какие какие могут быть нарушения ну например может быть
если с одного элемента и это элемент вообще ни с кем не соединен ну тогда понятно что совершенно
не получится сделать вот да еще это предполагаю что либо у нас заранее задано что или р одного
размера либо мы совершенном называем то у которого все вершины л входят а и а и как получится да
значит может быть так что есть один элемент который вообще ни с кем не соединен так тогда
здесь будет один а здесь ноль будет нарушение но и понятно что это элемент мы никак включить не
сможем может быть ситуация такая что есть два элемента у которых ровно один сосед и сосед один
и тот же вот но тогда тоже ясно что максимум в одному из них можно этого соседа включить
пара сочетания ну и так далее и так далее в общем вполне может быть там что у каждого из них
что например с 10 элементов у каждого из них 9 соседей но это одно и то же но что с девяти
соседей тогда соответственно хотя бы один элемент пары не хватит вот ну и так далее
так хорошо значит тут более более менее очевидно необходимость на то есть и существование
совершенно про сочетание это следует более менее очевидно так знаете я все к нему писать очевидно
да распишу немножко да что у каждого у каждого элемента с должна быть своя пара
должна быть своя пара вверх и все эти все эти пары это различные элементы и на тес
вот значит ну тогда более менее очевидно получается да что значит в вн от с есть по
крайней мере столько же различных элементов сколько есть в с значит все получается значит
размеры размера н от с будет не меньше вот значит это лево направо так сейчас камеры
доску это не снимает значит это слева направо значит теперь справа налево справа налево уже
совсем не так очевидно вот и будем доказывать от противного на то есть предположим что
совершенного нету но какое-то то есть и возьмем самое большое значит возьмем наибольшее значит
пусть совершенного нет значит рассмотрим наибольшее значит и значит назовем его м
так но и будем дальше будем доказать если оно не да значит если оно не самое несовершенное
то его на самом можно еще увеличить но то есть как это можно дальше то ты можешь делать как
рассуждение противного возьмем наибольше если он несовершенен то покажем что он не наибольшего
можно увеличить а можно просто сказать что любой несовершенно можно увеличить и мы будем
увеличивать увеличивать увеличивать пока не дойдем до совершенного и это же даст и алгоритм
поиска если мы сможем понять как именно увеличивать значит рассмотрим наибольшее м и покажем что
его можно увеличить покажем что его можно увеличить вот так у нас получает противоречие
так получается противоречие и заодно получается алгоритм поиска если у
нас есть процедура процедура этого увеличения да то можно его последовательно применить
да значит в общем что также получится алгоритм поиска начнем с какого-то значит
например одного ребра и будем последовательно последовательно увеличивать
и будем последовательно последовательно увеличивать
но и заодно видно почему эффективно получится да потому что у нас каждый раз
если мы увеличиваем то мы увеличим хотя бы на одно ребро вот поэтому мы можем
n раз увеличивать и дальше те слену то число вершин в каждой доля вот и соответственно
если процедура поиска вот это увеличение значит сама по себе полиномиальное но
то мы ее н раз применим и получим в итоге значит полиномиальное время
вот хорошо значит теперь как мы это будем делать значит тут основной инструмент это
вот так называемый улучшающий путь улучшающий путь по английски augmenting path
значит улучшающий путь устроен следующим образом значит это спочка вершин в
все вершины разные на то что получается а 0 1 2 и так далее значит это обязательно будет
нечетное число ребер что будет адвокат и адвокат плюс первая значит это улучшающий путь путь если
так первая ну первое может сказать что все аи ты различная я и ты различная второе второе что
концы этого пути не входят в парсочетание на то есть вот это а 0 и а 2к плюс 1 не входят в м да но
это не универсальное понятие улучшающего пути это улучшающий именно для конкретного
парсочетания да то есть путь улучшающий м вот соответственно первые последние вершины не
входят в м вообще вот и более того значит все ну все ребру которых все соседи вершины у которых
первые вершины мечетный номер не входят в м да то есть а 2 и т и а 2 и плюс первая не входят в
м но входят все-таки в я да то есть это ребро из графа то есть это будет лежать в е без м
ну а все и наоборот нечетная чета 2 и плюс 1 на 2 и плюс 2 ходят в м вот то есть в этом пути
значит в этом пути есть такое чередование да то есть получается что выглядит он каким-то
таким вот образом да значит например если на вот так вот я буду элемент м рисовать значит вот так
вот просто ребро вот он как-то вот так вот он выглядит и тогда что тут получается получается
мы можем заменить вот эти вот три ребра из м на 4 ребра неизвестно соответственно есть такой путь
есть есть такой путь есть то можно и ребра которые в нем и в м заменить на те которые в нем и не в м
значит если есть улучшающий путь то можно заменить можно заменить
его ребра его ребра из м на его ребра неизвестно и тогда это тоже будет пар сочетания ровно
потому что оно ли первой последней вершины в м не входит на то есть отсюда нет никакого
ребра вот такого жирного отсюда тоже нету поэтому того что мы так заменили у нас это не перестанет
быть пар сочетанием вот но то есть тут получается что-то типа такой рецепт но реакции да что мы
хотим вот этому элементу найти пару на наш нашли но это уже был в паре вот с этим поэтому мы
тоже что-нибудь другое находим да и так это и идет зигзагом и потом вот это вы наконец находим
элемент который ни с кем паре не состоял вот но теперь вопрос почему улучшающий путь
существует и как его искать значит если он если он есть мы его нашли то тогда можно применить
вот процедула увеличение так значит но вот первый называется лемма бержа
лемма бержа если пар сочетания не максимальная если пар сочетания не максимальная то существует
улучшающий вот но и второй вопрос как его искать но на самом как вопрос о том как его искать даже
немножко попроще ой не наибольшая да правильно так да спасибо да если если пар сочетания не
наибольшая то существует улучшающий путь ну да с как бы с не максимально тоже было верно это очевидно
значит принципе еще нужно читать путем отдельное ребро не в пар сочетания чтобы это было верным
значит нужно вырожденный в случае когда там кара в нулю тоже считать улучшающим путем вот
вот ну а и значит искать его можно процедуры типа поисковая в глубину да значит а именно мы берем
какую-то вершину дальше берем берем какую-то вершину не в пар сочетания с одной стороны да и как
бы выстраиваем такое дерево на что у нас значит берем как бы всех соседей на если у нас какой-то
сосед не в пар сочетания да то тогда мы можем просто трибров добавить на соответственно если у
нас все соседи в пар сочетания на то мы как бы идем сюда и у нас теперь слева позиция получается
столько же столько же точек сколько было здесь соседей и дальше мы из каждой из них опять же
смотрим все выходящие ребра в еще не рассмотренные вершины на если какое-то ребро там идет в вершину
не в пар сочетания то мы снова нашли да значит такой зигзак вот если не тоже все пар сочетания
то и ищем снова те те которые с ними соединены вот ну и так далее получается что в этой процедуре
мы ну какие-то ветки у нас будут обрываться даже когда у нас очередной вершины лево будут все
соседей уже рассмотрены ранее справа вот али в какой-то момент мы доберемся вот досюда вот
на такой вершины справа у которой уже соседей слева не будет в пар сочетания
вот но в общем-то можно аккуратно оценить сколько это времени будет занимать вот
значит дать докажем что есть действительно будет будет что искать так смотрите вот пусть
значит пусть им это текущие пар сочетания им текущие пар сочетания вот а им со звездочкой
это наибольшие пар сочетания значит и мы рассмотрим
рассмотрим такую вещь им твор им со звездочкой значит им сором со звездочкой то есть те рёбра
которые ровно в одном из мм со звездочкой значит рёбра
ходящие ровно в одно ровно в одно из мм со звездочкой
значит тут получается что у каждой вершины степень будет не больше двух
наш каждой вершины максимум в одно ребро входит в мм максимум в одном рам со звездочкой
значит у этого под графа у этого под графа и степени не больше двух значит 0 1 или 2
это значит что как он выглядит но я знаю что он стоит из циклов цепочек изолированных вершин
да то есть получается что он состоит из циклов из циклов цепочек и изолирных вершин
вот а при этом рёбра
рёбра из м и им со звездочкой передурится это вот за этим я брал кор да потому что
вообще принес можно было просто все рёбра из м и им со звездочкой брать это все было бы верно вот
но вот про чередование было бы неверно да потому что если бы я не взял ксор то одно
ребро могло быть сразу и в м и в им со звездочкой а так оно либо в одном либо в другом вот раз
они чередуются значит все циклы четной длины вот правда про двудольный граф мы это и так
знали в вдольном графе все циклы все циклы четной длины но на самом деле это лемма верна
и для небу вдольного графа значит поэтому я так в общем не доказываю значит все циклы четной длины
но это раз не чёт длины и м и им со звездочкой чередуют значит у них поровну рёбер из м и им
со звездочкой если цепочка четной длины там тоже поровну из м и им со звездочкой если не
чётный то какого-то одного из них на один больше но поскольку всего в им со звездочкой больше рёбер
чем в им то должна хотя бы хотя бы одна цепочка которая тоже рёбер из им со звездочкой больше
чем в им но вот эта цепочка и будет улучшающим путем так дайте я вот тут вот допишу значит
существует цепочка которой элементов им со звездочкой на один больше
тем элементов им значит она будет
она будет улучшающим путем на потому что мы как раз начинаем им со звездочкой да
значит потом им им со звездочкой им и так далее но вот так вот она и будет выглядеть вот
вот ну все значит получается доказали это мы что доказали мы вообще пока еще никак это не
связали с условиям тиремы холла пока что мы доказали что можно улучшить не не наибольший
парсочетание вот флага сейчас перерыв сделаем и в конце докажем тиремы холла с ним в конце
в начале 2 половины а потом пойдем к недвудольным графам так дать продолжим
значит теперь вот это вот все надо связать с тиремы холла да значит пока что
значит мы что доказали значит мы связали улучшающий путь с тем что сочетание наибольшее вот а мы
хотим что доказать что если у каждого множество слева соседей больше чем элементов самого
множества тогда лучший путь есть вот но это сами легко понять вот по этой картинке чему это
будет так что смотрите пусть у нас значит пусть у нас сочетание не там нет нет совершенного да
значит есть наш есть наибольшее вот раз он несовершенно значит какая-то вершина слева есть
из нее должно какое-то ребро ну либо там из нее вообще ребр нет и у нас условия нарушена вот дальше
дальше если у этого ребра если это ребро пока не входит парсочетания если если вот это вершина
пока не входит парсочетания тогда можно вот это ребро добавить и соответственно этому все
закончится есть но входят на что рассмотрен советско ребру который входит дальше смотрите
если вот у этих на двоих только один сосед то нарушен наши условия вот значит что ну значит
вообще может быть что отсюда еще много выходит вот но дальше что может быть но мы на
самую такую штуку возьмем для каждого соседа вот этой вершины значит если у этой шли есть
какой-то сосед который не входит парсочетания то мы добавим это ребро если они все входят да
то мы как бы вот для каждого из них да значит добавим там вот такую вот штуку
вот и все равно да что-то на этой картинке тут получается 4 вот таких вот вершины да и
3 сосед слева в правом смысле вот значит если если не у одной из значит у этой мы уже всех
всех соседей взяли если не у одной из этих нету соседа не среди этих трех вершин то у нас
нарушено условия вот значит хотя бы у одной из них значит есть сосед не из этих трех где-то
еще но опять мы возьмем всех таких соседей если один из них не в парсочетании то мы получим
улучшающий путь если не все в парсочетании то мы снова возьмем ребра в левую часть но и так
будем наращивать и рано или поздно ли получим улучшающий путь либо получим нарушение условия
так ну что это понятно
нет они могут поискаться потому что вот это у нас парсочетания да рассвет парсочетания не
могут в одну и ту вершину прийти вот поэтому они будут разветвляться ну и более-менее да
значит более-менее односамый тархаежная процедура который улучшающий путь ищется вот его
ровно так и надо искать мы возьмем какую-то вершину не в парсочетании возьмем всех ее соседей
вот возьмем ребра в парсочетании в которые они входят возьмем снова всех соседей вот ну и
так далее и либо ну и раз у нас полемия улучшающий путь есть то рано или поздно такой процедуры мы к
нему должны прийти вот а при этом у нас каждый раз задействуется какая-то новая вершина значит
это будет процедура там не длиннее вот так ничего понятно но я и я считаю что у нас получается что
мы разобрались полностью с кучей вдвудольных графов значит я только хочу подчеркнуть следующее
то проверять условия теремы холл непосредственно и это как раз долгая процедура да потому что
перебирать все множество там для них вычислять но что соседей всех под множество будет экспедициальное
количество вот поэтому на самом деле хотя терема холла математически красиво и полезно и связано
с разными другими утверждениями но применять ее для проверки существования совершенно
парасочетания это идея плохая значит вместо этого нужно просто строить наибольшие парасочетания
вот таким вот образом и либо оно построится и будет совершенное либо в какой-то момент оно
остановится да и значит совершенно не будет вот что на самом деле вот такая такая процедура она
если есть улучшающий путь найдет его а вот если нет то она остановится не найдя его значит его нету
вот так ну чего понятно так ну ладно тогда переходим дальше переходим к случаю нет
вдольных графов 2 это случай лучей нет вдольных графов значит что здесь можно сказать ну конечно
никакой терема холл тут уже нету потому что нельзя вот так вот разделить на две части вот
но тем не менее есть понятие улучшающего пути да то есть понятие парасочетания остается да
значит парасочетания набора ребра которые не пересекаются по вершинам соответственно
понятие улучшающего пути тоже остается и лема берже тоже остается верный да что-то остается
понятия тогда остаются остаются понятия парасочетания включая совершенное наибольшие
максимальное значит тут с понять парасочетания значит улучшающего пути
значит и также верна лема берже
значит но чем может быть проблема значит может быть проблема с поиском улучшающего пути
значит может возникнуть может возникнуть проблема с поиском
улучшающего пути значит что может быть проблема и почему не возникал раньше но
дело в том что раньше мы не не могли в общем прийти в одну и ту же точку да то есть мы как бы
строили вот такое вот дерево да и у нас все вершины как-то в него вставали а здесь
можно смотреть что получится значит вот мы значит начинаем строить улучшающий путь
значит как-то его так строим
так сейчас
и пришли вот так вот ту же точку где мы уже были значит поскольку граф нет вудульных тут
возможно нечетные циклы ну и мы так гуляя по дереву могли в этот нечетный цикл и войти вот
но и как после этого да не поймать что делать да то есть мы как бы вернулись туда откуда приходили
да и дальше этот путь на расчет нельзя вот и вполне возможно значит вполне возможно нужно было
идти не по нему а ну и вообще тут как бы его нельзя переключить да потому что если вы
переключаете тут тоже получается что вот этих жирных ребер уже имевшихся на одно больше чем
наоборот на одну меньше чем тонких но тонкий не образует парусочетания вот поэтому так взять
переключить не можем вот и кроме того значит тут возможно это альтернативная цепочка которая
может быть будет даже длиннее так может быть длиннее может быть даже не длиннее а вот этих
вот нету она такой же длины но как бы с этой цепочкой можно переключить да да конечно пришли
вот сюда то мы не можем взять переключить то есть в общем идеи в том что нам как бы как нужно так
построить алгоритм чтобы мы находили именно вот эту цепочку да они ту которая сворачивает
само на себя вот понятно до сложности так ну ладно
сейчас что еще раз так я про то и говорю да я про то и говорю что цикл нам не подойдет
как увеличивающий путь вот но при этом нужно как то с него сходить а мест где нужно сходить
может быть много поэтому как если это напрямую делать то будешь какой-то экспоненциальный перебор
вот ну вот значит вот собственно что придумал эдмонс он на верх он придумал такую штуку
не нечетный цикл где чередуются до ребра из ваш сочетание не из него кроме вот одной
точки в которой приходит снаружи и он придумал что его можно стянуть алгоритм эдмонса
значит заключается в том что значит мы
тянем виток вот то есть построим новый граф который вместо вот этого цветка будет одна вершина
построим новый граф
которым вместо цветка
значит будет всего одна вершина
но они как бы исчезнут вместе но смотрите значит тут что может сказать про цветок что из
него выходит ровно одно ребро из пар сочетания на то есть вот из остальных вершин могут какие-то
ребра выходить но они точно будут не участвовать пар сочетания да да да да цвет цветок это цикл
нечетной длины в котором каждый второй в пар сочетания а вот у одной вершины где сходят
два не из пар сочетания тоже обязательно есть какое-то выходящее ребро что здесь вот есть
выходящее ребро тоже из пар сочетания вот то есть в общем получается что значит теперь вместо той
картины которая была да значит вот вот тут как раз будет как бы вот большая такая вершина
вот и из нее да я так условно покажу дат похоже на то что там нарисовано значит из нее будут
выходить всевозможные ребра вот во все те которые раньше были соединены с вершинами
этого цикла вот ну значит остаток будет так вот я стараюсь точно перерисовать
вот значит ну и теперь получается что вот это вот новая вершина которая соответствует цветку
она тоже входит пар сочетания значит той вершиной которая раньше была соединена 100 вершины цветка у
которых у которой оба ребра внутри цветка не из пар сочетания да то есть вот так как у нас было
одно одно ребро приходящее из из вне витка в цветок и который было по из пар сочетания так оно
вот здесь вот и осталось вот значит теперь тут ждать следующее что мы получили граф меньшего
размера да начнем меньше вершин но и меньше ребер автоматически нам все все все ну даже
неважно что ваше меньше вершин да но ребер меньше потому что все все все которые внутри
до 4 исчезли вот ну и тогда на что говорится говорит что если в новом графе мы найдем
улучшающий путь то тогда его можно превратить в улучшающий путь в старом графе значит
улучшающий путь в новом графе можно превратить ва улучшающий путь в старом
ну конечно интересен случай когда улучшающий путь в новом очеред цветок проходить на что же
такая процедура разлетеленная дальше могли где-то найти цветок его стянуть а потом в
итоге оказалось что улучшающий путь этот цветок вообще не затрагивает это да где-то там еще
проходит вот так что интересен конечно случай когда он через цветок проходят вот ну тут
что нужно делать значит ну
что вообще нужно делать значит нужно взять все все ребра которые вот в этом новом графе
рёбра которые есть новым графе они есть и в старом графе но старом графе тут получается разрыв
да тут как будто отдельно вот такая цепочка значит отдельно такая цепочка но это цепочка
как раз нужно соединить внутри цветка значит именно вот здесь вот вот но при этом обратите
обратите внимание что если тут какой-то в каком другом месте да было бы да то есть тут пусть
Пусть вот это там как-нибудь по-другому закончилось, а мы нашли вот это вот.
Значит, тогда если мы пойдем вот как бы по этой части, то это будет неправильно,
но в том-то и дело, что мы можем идти как понязо, так и поверху.
Вот сюда вот нужно идти понязо, вот так вот, а сюда нужно идти поверху, вот так вот.
Да, и в том и другом случае получается, что и вот с этим хвостом получается улучшающий путь,
и вот с этим вот получается улучшающий путь.
Как раз за счет нечетной длины циклы мы можем и там, и там прийти как бы с нужной чётностью к старту,
к старту оставшейся части.
Так, ну чего, понятно.
Ну вот, что есть получается алгоритм такой.
Начинаем искать улучшающий путь, вот в исходном графе, каким-то таким поиском в глубину.
Значит, если этот поиск привел к цветку, то мы этот цветок стягиваем.
Ну, если забоиться об эффективности, нужно сохранить какую-то информацию из предыдущего этапа,
но в принципе в теории можно с нуля начинать.
Вот мы его стянули, запомнили какие там были ребра внутри стянутого цветка,
и заново начинаем процедуру поиска улучшающего пути рекурсивно.
Ну, поскольку у нас каждый раз уменьшается размер графа, то для совсем маленьких графов всё очевидно,
если там две вершины, то понятно, откуда брать улучшающий путь.
Вот, а потом, соответственно, мы начинаем поднимать улучшающий путь на исходный граф.
Вот, сколько времени это будет работать?
Ну, смотрите, поскольку у нас каждый раз уменьшается размер графа,
ну и на самом деле он сокращается минимум на два.
Потому что самый маленький цветок – это треугольник.
Вот, соответственно, будет шагов рекурсии не больше, чем энтополам.
Ну и, соответственно, превращение на неразборчивый граф,
ну и, соответственно, превращение улучшающего пути в новом графе,
до улучшающего пути в старом графе.
Ну и тоже какая-то там простая процедура.
Вот, то есть получается энтополам этапов.
Вот, и на каждом тоже какая-то, ну уж не больше, чем энн, наверное.
Тут как бы есть некоторые, там можно более точные оценки делать из-за того, что у нас,
либо у нас какие-то очень простые восстановления, вот это вот,
либо у нас очень сильно размер падает.
На это будет меньше шагов рекурсии.
Ну, в общем, домен в квадрате вроде должно получиться.
Ну, правда, это вот, если у нас тягиваются, да, вообще-то это же у нас поиск глубины,
и мы там должны все ребра обрабатывать, да, и тогда уже этот поиск там, наверное, в квадрате займет.
Но тогда, если мы его умножим на число рекурсии, это будет типа n в кубе.
На число шагов рекурсии это будет типа n в кубе, вот.
Ну вот, примерно это, собственно, Эдман списал свои стандарты.
И после этого он написал, что вот, видите, у меня тут n в кубе.
И это хорошо, потому что это растет не слишком быстро.
Вот. И там у него на паре страниц дискуссия, что вот, если это в какой-то степени, да,
то это нужно считать быстро.
Вот.
Вот.
Вот.
Значит, вот такая история.
Есть ли по ней какие-нибудь вопросы?
Спасибо.
Ну, значит, тут нужна...
Значит, смотрите, идея такая, почему n в кубе, что n шагов рекурсии
и на каждом шаге есть и н шагов рекурсии,
и у каждой этой степени есть и н шагов рекурсии,
и это не то, что и на каждом шаге.
То есть это не то, что и на каждом шаге.
что n шагов рекурсия и на каждом шаге мы вообще говоря запускаем пояс глубину вот а
пояс глубину но после того чтобы еще искать вот такие вот пути с чередованием вот а пояс
глубину подразумевает а ну и я имею в виду число вершин да да то есть по пояс глубину
подразумевает там перебор ребер какой-то да ребер как раз может быть порядком в квадрате
вот хорошо начну а сам деле это некоторые малая часть этой области которая рассказала
что тут есть много разных алгоритмов значит есть всякие взвешенные варианты значит есть связь
с теоремой о максимальном потоке минимальным разрезе и там рассказывали где-нибудь
не мин кат макс флоу там форда фолкер сона не знакомые слова что форда фолкер сона
или еще там мин кат макс флоу это называется корма не конечно да в корму нет и есть вот
в общем это все с этим может быть связано значит особенно значит например для вдольных
парсочетаний значит можно сослаться вот значит можно сослаться на теорему о минимальном разрезе
максимальном потоке значит вот там какой-то граф дальше ты и можно
добавить еще источник добавить сток на и сказать что мы хотим как можно больше поток провести
отсюда сюда тогда вот в этой части этот поток должен идти по парсочетанию на то есть тут нужно
но имея ввиду что вот там по каждому ребру мы можем провести максимум единицу на тогда вот
это вот единица пришла сюда значит и она должна да тут конечно еще важно у нас дискретно задачи
или непрерывная да то есть непрерывная обозначала что может как-то делиться вот так вот вот дискретная
ну а считать что у нас просто в каждое каждое ребро либо полностью занято либо вообще не
занято вот тогда это получается ровно задача максимальный парсочетания он наибольшим
задача наибольшим парсочетаниям вот хорошо
значит что еще можно сказать с кем-то еще связано есть например связь вот с чем на
первый взгляд совершенно другой задачи на самом то же самое значит есть такое понятие
перманент не слышали такое понятие слышали о каком контексте у матрицы да конечно да не все
вообще смотрите перманент это такая штука которая вычисляется как детерминат только без знаков
да то есть перманент значит перманент матрицы а это значит сумма по всем перестановкам сигма
если матрица n на n на сумму по всем перестановкам сигма тут будет произведение по и от единицы до
n а и ты и сигма ты ты вот вот если тут еще будет минус один степени счетность перестановки это
будет определитель на детерминат дальше давайте это напишу значит а вот у детермината здесь
на том минус один степени сигма вот и для детермината есть алгоритмы подсчета на там
через какой метод гаусса да или там раскладывать там по строке и столбцу не раскладывать на это
сейчас на труде тоже работает да но можно там приводить преобразованиями гаусса да там
ступенчатому виду а вот письма виду просто перемножить на диагонали это будет будет детерминат
довольно быстро происходит может быть еще какие-нибудь там или у разложения там какие-то
в общем есть разные методы вот вот для для перманента никаких нормальных методов неизвестно
вот то есть понятно что можно почитать по определению но перестановка всех
вот соответственно это будет вот какое-то вот такое большое реальное множество на
факториала даже еще немножко больше чем линейный экспонента на факториал это не два в степени цена
на два степени цены цена и налог и вот значит соответственно по по определению перманент а считается
нас считается за экспоненциальное время вот а других методов неизвестно
других методов неизвестно значит при этом у него есть много разных приложений значит но в
частности ясности перманент связан со числом пар сочетания с числом совершенных пар сочетаний
Число совершенных паросочетаний в двудольном графе
Это перманент матриц, который называется матрицей ТАТТА
Есть матрица смежности, это аежит, аежит равно единице, если есть соединенный ребром
Но если у нас граф двудольный, то мы знаем, что в половине этой матрицы это нули
Число совершенных паросочетаний в двудольном графе это перманент его матрицы ТАТТА
Матрица ТАТТ это кусок матрицы смежности
Но если у меня граф двудольный и неориентированный, то тут будут нули
Если вот это ль, вот это р и здесь вот это ль, вот это р, то внутри ль ребр нет и внутри р ребр нет
А вот эти вот друг с другом будут транспонированы
То есть тут какое-то б, а тут б транспонированы
Но вот это вот б и будет матрица ТАТТА
То есть тут получается, что б и аежитое равно единице, если пара l и t и r аежитое лежит в е
Значит, где l и t и t вершина слева, а е аежитое это вершина справа
Так вот, у этой матрицы перманент равен к раз числу совершенных паросочетаний
Так, и чему? Очевидно
Не очевидно, ну сейчас
Ну да, совершенно верно
Совершенно верно, значит, если все а и t сигма от и t равны единице, то тогда множество пар и t сигма от и t это совершенные паросочетания
Ну и наоборот, на самом деле
Любое паросочетание задает некоторую перестановку
И в этой перестановке и должно быть соединено с сигма от и t
Ой, только не а, а, б
Вот, и это там, это а, тут это уже б
Да-да-да, мы, во-первых, считаем, что у них одинаковое число, иначе заведом нет совершенных паросочетаний
А дальше мы просто фиксируем какую-то нумерацию в левой доле и какую-то нумерацию в правой доле
Вот
Хорошо, значит, отсюда получаем, что, смотрите, какой эффект
Да, значит, сравнить перманент матрицы, то есть выяснить перманент равен нулю или нет, это задача простая
Выяснить верно ли то перманент b равен нулю, это простая задача
По крайней мере, если у нас, если b из нулей единиц
Значит, b из нулей единиц
Потому что и наоборот, любая матрица из нулей единиц дает двудольный граф
И тогда выяснить, равен ли перманент b нулю означает выяснить, есть ли хоть одно совершенное паросочетание
А это ровно то, чем мы занимались в первой части лекции
То есть выяснить, равен ли перманент b нулю, это простая задача
А посчитать точно
Значит, посчитать точно
Сложная
Вот так, ну, давайте я слова напишу, а уже не успею объяснить, что они означают
Sharp P полная
Вот, это да, это такой класс, это класс задач подсчета
Значит, класс задач подсчета, когда нам нужно выяснить, как бы, сколько у нас подходящих сертификатов, фактически
Вот это, смотрите, дайте еще минуту, скажу
Поэтому вот эта вот задача сложнее, чем
Сейчас, нет, не так
Вот это вот эффект, который мы здесь наблюдаем
Это эффект, которого нет для ANP полных задач
В том смысле, что для ANP полных задач сложно уже понять, есть ли хоть один сертификат
Да, то есть понятно, что сложно посчитать число выполняющих наборов у формулы
Потому что даже понять, есть ли хоть один, это уже сложная задача
Вот, а здесь получается, что есть ли хоть один, мы понять можем легко
Вот, а вот посчитать точно количество не можем, но тут вот эта сложная конструкция, на самом деле
Что это означает, ну вот, ну а Sharp P это вообще задача подсчета
Каких-то объектов, когда мы можем понять, по объекту подходящий он или нет
То есть, можно считать, что это подсчеты сертификатов для ANP
Вот так, ну все, спасибо за внимание
Так, следующий раз последняя лекция получается
Наверное, я про задачу апроксимации поговорю
