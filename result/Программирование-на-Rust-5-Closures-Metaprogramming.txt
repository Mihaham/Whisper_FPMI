Ну что ж мы начинаем пятую лекцию. Пятая лекция у нас будет про средства метапрограммирования,
которые устроены в REST. На самом деле их больше, чем просто макросы, которые мы будем преимущественно
изучать на этой лекции, но остальное у вас останется в домашней лекции как бонусное.
То есть, например, как мы дальше узнаем, есть средства, с помощью которых можно делать на трейтах
такие штуки, которые позволяют в Compile Time интерпретировать какие-нибудь языки.
Ну то есть трейты, Turing Palme, проще говоря, в REST. Мы это изучать, конечно, на лекциях не будем,
потому что есть прекрасная штука, называемая макросами, и template метапрограммирование,
которое вы могли видеть в плюсах, что там пишут интерпретаторы языков. В общем-то,
в REST есть гораздо более прикольные штуки. В этой лекции мы посмотрим на closures,
буквально немножко поговорим про метапрограммирование в целом,
про декларативные макросы, процедурные макросы, и немножечко посмотрим на те макросы,
которые есть в стандартной библиотеке для упрощения нашей жизни.
Вот closures. Ну и с ними уже однозначно сталкивались домашние. Выглядят они вот так вот.
У нас есть какие-то палочки такие, а там внутри какой-то код. В данном случае у нас всего лишь
одна строчка, поэтому мы можем, например, написать их без фигурных скобочек.
Если вам захочется несколько строчек, то в таком случае нужно добавить фигурные скобки.
Итак, ну я думаю, то, что происходит в коде, вам полностью понятно. Скажите,
пожалуйста, в чем разница между closures и обычными функциями?
Ну давайте так, я чуть-чуть изменю вопрос. Чем отличаются лямбды от функций плюсов?
Да, closures захватывают окружение. Это такая анонимная функция,
которая может использовать переменные из скопа. Например, в данном случае у нас equal to x захватывает
x, и мы сравниваем там y с x в ассерте. Естественно, ассерт проходит. С обычными функциями так бы не
получилось, потому что они умеют только что-то принимать на вход и что-то использовать из глобального
скопа. Вот так. В отличие от обычных функций closures смогут выводить типы. То есть в расти мы обычно
требуем от функций, чтобы мы написали конкретный тип, который они принимают. То есть ходные типы
и выходной тип. Это нужно для того, чтобы type inference работал хорошо, чтобы мы в самом коде не писали
никаких типов и писали только то, что возвращают сами функции. То есть там есть такая система типов,
называется Hindley-Millner. Мы, конечно же, не проходим, потому что это математика. Это алгоритм такой,
который позволяет выводить типы, которые используются в коде, основываясь на том,
как они используются. Собственно, в расте используется вариация такой алгоритм.
Скажи по-гробче. Да, я точно включил запись. Там есть оранжевая точечка сверху.
Option.t map не помню, что такое. Вот мы как раз с option, как он переводит option.t в option.u.
Map это такая штука, которая принимает на вход функцию. Если у тебя наун, то возвращайте наун.
Как видите, в первом случае мы явно написали типы, которые мы хотим от Clojure. То есть точно так же,
как и функции. Там двоеточие, такой-то тип, стрелочка, такой-то тип. Возвращаем. И с
Infrared мы не написали никаких типов, раз все за нас вывел. Это сделано так потому,
что Clojure используется в таких контекстах, в которых можно очень легко вывести типы
используемых переменных, и потому они не требуются. То есть просто потому, что такое
прагматичное решение, это удобно, и поэтому в отличие от функций все выводится. Давайте попробуем
повторить функциональность option.map. Возможно, вы видели когда-нибудь даже
определение, пока вы решали домашки. Ну, оно, конечно, чуть-чуть по-другому здесь написано,
потому что в этом примере это не часть option, а это какая-то отдельная функция,
которая принимает на вход option. Работает, в принципе, точно так же. У нас есть какой-то
option, который мы принимаем на вход, потом есть transform. Мы матчим наш option, и если это сам,
то возвращаем сам transform, иначе нам. Возникает вопрос, а что же на место точечек поставить?
Какой тип у того, что принимается на вход мэпа? Нижнее подчеркивание, оно в этом контексте,
конечно же, ничего не выедет. Функция должна быть конкретным, конкретный тип. Мы, конечно,
хотим, чтобы transform был каким-то объектом, который callable, то есть, который мы можем вызывать.
Когда мы хотим врасти, абстрагироваться относительно какого-то свойства, то мы используем
trait всегда. Хочется придумать какой-то trait, который у нас transform будет каким-то типом T,
и этот T будет исполнять какой-то trait, который будет означать, что у нас объект вызываемый.
Давайте задизайним этот trait. Во-первых, у нас такая идея. Я заранее говорю о том,
что она точно такая же, как и в плюсах. В плюсах лямбды работает точно так же,
как closures. Идея такая. Компилятор генерирует структуру, которая имплементирует какой-то trait.
То есть, если вы пишете closure, то на самом деле компилятор – это такой синтактический сахар
для какой-то сгенерированной компилятором структурки, в котором будет класть объект со
scope. Остальное будет с глобального scope, либо то, что на вход, мы принимать на вход, либо
брать с глобального scope. Вы когда-то говорили, что closures – это зеро cost abstraction. Да,
мы сейчас это увидим. Он даже еще более зеро cost abstraction, чем в плюсах, потому что мы на самом деле
можем тип вывести. Вот. У нашего trait будет, естественно, только одна функция. Это значит
вызвать функцию, собственно. Круглые скобочки. Так как в Rasty у нас нет вариадик. Вариадики есть
некоторые преграды для того, чтобы их добавить. Подробно мы о них говорить не будем. Если
интересно, можете погуглить. Есть люди, которые пишут целые списки того, почему не нужно добавлять
вариадики в Rast. Вместо этого мы будем использовать tuple. Во время имплементации этого trait.
Поэтому у нас на самом деле будет наш trait принимать на вход аргументы не в качестве
какого-то списка вариадик аргументов, а какой-то tuple, как один аргумент. Ну давайте примерно так
и сделаем. У нас есть какой-то trait, который принимает на вход input. Input generic. Output это
какой-то ассоциированный тип. И вот функция transform есть. Ну это мы так назовем наши круглые
скобочки. Вот. Ну соответственно какой-то input на вход приходит и output. Так. Ну скажите мне,
почему мы должны в этом trait'е вообще писать self? Зачем нам тот нужен?
Ещё раз повтори, пожалуйста. Да, как раз потому, что у нас self как раз сохраняет наш скоб
текущий. Поэтому мы обязаны использовать self. Он является нашим storage для того,
что мы приняли на вход. Вот. Если, кстати говоря, если вы будете внимательно посмотреть на этот
вот trait, у вас возникнет вопрос, почему мы, например, input написали как generic, а вот как
ассоциированный тип. Знаете, я честно вам скажу, я не знал ответа на этот вопрос. Я пытался погуглить,
нашёл только два места, в котором про это можно почитать, и ни в одном из них не пришли никакому
разумному решению. Вот. Поэтому, если вам интересно почему, то я не знаю точного ответа. Я могу
только предположить, что, возможно, это для того, чтобы сэкономить, например, ну, запревентить
quote-blood, например. Ну, то есть для того, чтобы у вас есть структурка, и вы могли для разных
input'ов использовать одну и ту же структурку. То есть, если у него scope состоит из одинаковых
типов переменных, в таком случае вы могли бы одну и ту же структурку использовать для разных
input'ов. Это так. Ладно, в общем, забейте, если что, это такая вещь, которую всё равно никто,
видимо, не знает ответ, поэтому... Это выглядит как такой отголосок того факта, что в плюсах нельзя
делать перегрузку по типа возвращаемого значения. Ну, здесь можно было бы сделать так, что у тебя
внутри type input и type output. И ты бы мог, грубо говоря, перегрузку сделать как... У тебя,
с одной стороны, для одной структуры могла бы быть только одна имплементация трансформа.
Мог бы быть только один input и один output указан. В такой вот имплементации ты можешь для одного
output'а указать много input'ов для одной структурки и, соответственно, переиспользовать её. Я, правда,
не знаю, зачем это нужно, но как есть. Возможно, для того, чтобы как раз уменьшить число типов.
Возможно, какие-то ещё более глубокие вещи, связанные с теорией типов есть. Ну, я тут,
конечно, не знаю. И никто, судя по всему, в Гугле тоже не знает. Сам факт, что у нас будет
примерно вот так вот это выглядеть. Вопрос, а что нам нужно из этого точно? Нам нужен self,
mute self или ссылочка на self? Ну, ты почти прав с точностью наоборот. На самом деле,
подходит каждый из них по-своему. Смотрите, у нас юзер, если у нас будет self, то в таком случае,
когда мы будем вызывать наш closure, то в таком случае она умрёт. Мы сможем её вызвать только
один раз. Ну и с другой стороны, мы ещё будем при этом внутри closure владеть объектами, сможем
их дропать и всё такое. Mute self мы с одной стороны не будем владеть объектами внутри closure,
но сможем мутировать. У нас уникальный доступ, скажем так. И, соответственно, ссылка, мы не
сможем ничего мутировать, но точно так же, как и в случае с mute self, сможем много раз вызывать наш
closure. Получается, что кажется, что это зависит от того, какой у нас юзкейс. Как сказал, как тебя
зовут, кстати? Данил. Как сказал Данил, у нас компилятор умный, он подстроится. Сейчас мы увидим,
как это будет выглядеть, когда дойдём до реального применения. Ну, в общем-то, мы, естественно,
хотим выбрать самую-самую высокую строчку из тех, что нам подходит. Потому что, если нам
достаточно вызвать один раз closure, то почему бы её сразу же не съесть? Давайте попробуем
имплементировать для селфа. Если мы для селфа это сделаем вот так вот, то у нас будет вот такой
трейв с селфом внутри. У нас будет мэп, который будет принимать на вход какой-то тип тэ,
который имплементирует, transform, с типом, соответственно, x в качестве входного и выходным в качестве
входного y. У нас option x приходит option y. Как видите, тут понятно, да? А это ты специфицируешь, какой
конкретно там ассоциированный тип? Просто там же t может быть самым разным, а входной тип может
быть одинаковым, а выходной разным для разных типов. Поэтому тебе нужно специфицировать,
какой ассоциированный тип ещё будет. Для этого такой синтаксис предназначен.
Ну, generic ты можешь имплементировать для одной структуры разные трейты с разными
generic. Ну, то есть в плане, что если ты для одной структурки, в случае transform,
можешь для разных input'ов имплементировать свой структур, trade для своей структуры.
Вот. А если бы это был ассоциированный тип, тогда бы ты смог только одну сделать
имплементацию. Потому что generic ты как бы generic по всем input'ам, а ассоциированный тип он
просто как бы фиксирован. Вот для этих входных параметров, для этого input'а ассоциированный
тип output. Он только один, он не generic.
Ну, это похоже на то, что нельзя перегружать только по украшаемому значению. То есть мы
просто конкретно всегда по типам входных данных можем установить тип выходных. То есть мы
каким образом социальное соответствие устанавливаем?
Ну да, да. Я тоже думал, что про инъекцию-сюръекцию, может быть оно как-то из-за этого уводится.
Ну да, да. Ну, как-то не знаю. С другой стороны, вроде бы почему бы не оставить type input? Не
знаю. Вроде бы и так должен все работать. Ладно. Разве что только логично, что input
параметры это generic, а output параметры это ассоциированный тип, то есть какая-то логика.
Вот там есть, но она немножко туманная. Ну, давайте пойдем к тому, как это использовать.
Вот мы сделали наш опцион. Это сам, двойка. Соответственно, x. И сделали map. Смотрите,
как у нас map работает. Мы создаем тип adder. Кстати, adder же объявил здесь. Я продолбал adder.
Как же так вышло? В общем, там должен был быть слайд, где еще объявляется структура adder,
для которой имплементируется трансформа. Внутри трансформа просто происходит суммирование.
Ну блин, я помню, что это писал, но куда-то продолбался слайд. Не знаю, как так вышло,
но потерялся. Я думаю, что в принципе понятно, что там просто имплементируется trait для adder.
Соответственно, когда мы его запихиваем, он работает. Мы внутри сможем вызвать трансформ
от нашего adder. И все хорошо. Итак, с этим слайдом понятно?
Здесь Rust еще использует, ну, реально Rust использует trait.fn.mute.fn.once. Они так называются.
Они, конечно, называются intranform вот так вот. Они имеют вот такую вот сигнатурку.
У них точно также input-параметры есть, которые называются args. Есть output-параметры. Ну output,
как видите, только один в fn.once. А дальше вы можете обратить внимание, что fn.mute, например,
от fn.once наследуется, а fn.fn.mute. Ну потому что вам ничего не мешает вызвать с владеющими
значениями closure, если у вас fn. Просто вы не владеете значениями, у вас там только ссылки
внутри. Почему бы эти ссылки не съесть? Никакой проблемы нет. В общем, это может немножко запутать,
потому что казалось бы, что fn мы там можем выводить много раз, а здесь fn.once только один раз,
и у нас получается вот такая вот последовательность. Но если вы внимательно посмотрите на self,
то вы поймете, почему так происходит. Потому что self на самом деле нам дает
самую маленькую власть, когда мы говорим про closures, а самую большую дает ссылка на self.
Получается, если у нас тип реализует trait fn, то он также реализует fn.mute. Да, и fn.once тоже.
Так, и как же на что? Внутри можно делать абсолютно то же самое,
то есть внутри com.mute можно делать то же самое, что и внутри call. Просто что в том случае ты
владеешь, мутабельную ссылку возьмешь, а там ты вообще заберешь объект в случае fn.mute.
Мы можем выразить call через com.mute или наоборот? Мы можем выразить com.mute через call. Внутри мы
просто call сделаем. Точно так же мы можем в call.once написать просто com.mute. Здесь вот как-то,
мне кажется, реверсная такая зависимость, но если на self и посмотреть, становится понятно.
Реальный мэп, конечно, полная имплементация, все в стандартной библиотеке, наслаждайтесь,
вот она выглядит вот так. У нас есть option.tap, в котором мы generic есть, мы generic по типу U и по
функции f. Причем у нас есть ограничение, что f представляет из себя какую-то структурку,
которая имплементирует fn.once, которая переводит f, и соответственно у нас то же самое,
что мы писали с transform, который мы придумали. Вот как-то так. Тут понятно. Это особый магический
констрейн с стрелочкой. Да, кстати, я еще не сказал, вот это особый синтаксис для этого трейта.
Вы пишете вот здесь вот в скобочках просто входные типы через запятую,
а после этого в стрелочки выходный тип. Ну просто потому что это удобно.
Так, точно так же как в плюсах, вы не можете взять реальный тип, ну в плюсах вы не могли взять тип
лямбдф, в Rust вы не можете взять конкретный тип clause, а вообще никак. Потому что это... что?
В плюсах можно взять. Такое там декл-тайф.
Ну правда декл-тайф нормально там, заработал только 200 плюсов, но заработал.
Так, ну в общем, так как это тип нельзя объявить, то в таком случае мы вынуждены использовать не конкретный
тип clause, а использовать импл трейд или использовать дин трейд, ну то есть указывать через трейд что-то.
Вот, например, у нас return closure возвращает closure, который принцит hello world если его вызвать.
На имплимитирует fn от нуля аргументов и, соответственно, ничего не возвращает.
Так, ну и соответственно точно так же можете использовать и дин трейд, как я сказал.
Вот у нас, например, есть две closure, которые ничего не принимают на фото и что-то возвращают,
то есть и 32. В одном случае у нас там что-то выводится, а потом чиселки считается, и в том случае просто чиселка.
И в качестве ссылки на 1fn и 32 мы вот положили это вектор.
Тут понятно? Просто самый обыкновенный трейд получается.
Так, получается, что еще и любые функции имплимитируют эти трейды, то есть вы это не видите,
но компиляторы для самых стандартных функций тоже его имплимитируют. Вот у нас есть fncast,
который просто берет x и 32, добавляет единичку и перевозит в i64, ну просто какой-то пример такой.
И функция, которая принимает на вход что-то, что имплимитирует fnonce из 32 в i64.
И внезапно вы в мейне можете сделать funcatcast. Cast, как вы видите, это уже не какая-то closure,
это глобальная функция, которую вы можете тоже запихать, потому что она тоже имплимитирует
соответствующие трейды. Более того, они все имплимитируют и fnonce, и fnmute, и fn, то есть имплимитируют fn.
Это какой-то уникальный синтакс из того, что мы после названия трейдеров пишем там скобочки,
стрелочки. Да-да, я вот как раз приговорил, что у нас здесь в скобочках выходные типы,
через запятую, здесь вот через стрелочку выходные типы. Это особенно для fn, fnonce, fnmute.
То есть получается, что в расти оператор круглых скобочек, это определяется точно так же трейдерами,
как и все вещи в расте, в принципе. И, конечно, мы бы хотели, возможно,
ворлодить этот оператор для своих типов, но это пока что, возможно, только в nightly.
То есть stable у вас не получится, вот если вы в nightly включите,
там можно будет вполне перегрузить для какой-то своей структурки fnonce, fnmute, fn, если захотеть.
Если это в nightly, то это через несколько месяцев?
Ну, не обязательно, может быть несколько лет. Это как быстро пойдет разработка, когда решат,
что фича там достаточно покрутилась, что уже поняли, что она ничего не ломает,
что она протестировалась, там нет багов никаких, то она попадает в бету, потом stable.
То есть когда они фичу решают замержить.
Так, еще есть такое понятие как function pointers. Чтобы вы не путались, вот есть еще fn с маленькой буквы.
Fn это уже function pointer, это уже конкретное указатель на конкретную функцию. Он не может быть null.
Кстати, давайте я пока тоже вспомнил, вот такие вот штуки можно делать даже для всяких имплов структур.
То есть там просто в качестве первого аргумента будет self. Причем self будет определену, естественно.
Извините, что я так пришел. Только помню, нужно сказать, что вообще все функции имплементируют, которые вы видите.
Так, ну, в общем, смотрите, у нас есть fnadd1, который добавляет единичку к usize,
и у нас есть pointer на add1, это fn из usize в usize. Как вы можете заметить, я могу точно так же просто вызвать эту функцию.
Fn это уже конкретный тип, в отличие от trait, который мы поговорили уже. Он тоже имплементирует trait fn с большой буквы, соответственно, можно его вызывать.
Это самая полезная вещь для ffi, а вообще в целом в Rust вы, наверное, никогда не будете встречаться с function.pointer'ом.
Вот как-то так. Ну и как вы можете заметить, еще у нас function.pointer для closures еще работает, но это в тот момент, когда мы знаем, где closure находится.
Например, еще, кстати, здесь не смажь type, забыл сказать, смотрите, вот здесь так closure, который берет аргумент внешний, взял.
Ну и, в общем-то, раз уж у нее появляется какая-то структура, какой-то input, там-то соответственно она уже не является function.pointer'ом каким-то, у нее есть кроме input типов еще какой-то scope, соответственно, fn она не имплементирует.
А менять, соответственно, указатель на function нигде?
Менять можно, но он никогда не может быть.
То есть переприсвоить?
Переприсвоить можно.
Давайте сейчас поймем, как у нас Rust вообще захватывает переменные. В плюсах у нас там были квадратные скобчики, в квадратных скобчиках мы писали, как мы типа конкретно берем.
Давайте сделаем такое объявление, структурка t и возьмем три функции.
Нам будет владеющие брать, потом поументабельные ссылки и посылки t.
Такое простенькое объявление.
Что ж, соответственно, x, y, z у нас это т.
И внутри closure у нас by-ref вызывается от всех трех ссылок.
В этот момент closure еще является fn просто.
Потому что все, что она берет, она берет все по ссылке.
Соответственно, структура closure из себя представляет просто три ссылки.
На x, на y, на z.
Когда вы сделаете by-new to y и z, то в таком случае вам уже нужно будет взять мутабельную ссылку.
И в этот момент раз решит, что вообще-то ваша closure должна брать y и z по мутабельной ссылке внутри.
И будет их хранить также в структурке, которая там будет внутри создавать компилятор.
И, соответственно, эта closure будет имплементировать уже fn mute.
Ну и вот последнее, если вы допишете еще by-value z, то в таком случае z придется взять уже по значению.
Closure начнет имплементировать только fn once.
Ну и, соответственно, внутри там будет мутабельная ссылка на x, мутабельная ссылка на y и просто z.
Это политический код?
Да, это политический код. Просто какой-то примерчик.
Примеров там же не было, ничего подобного. By-ref, оно само как-то...
Ну, by-ref, это же мы сами просто что-то имплементировали, просто чтобы его повызывать как-то там.
Наш тип t.
Вот.
Ну структура closure соответственно будет примерно такая.
Ну там fn once будет как-то имплементирован, потому что у нас z это владеющий тип.
И когда мы будем создавать эту closure, ну там компилятор за нас ставит нужный код,
он создает наш environment вот с такими вот параметрами.
Ну перед тем, как... В тот момент, когда вы будете создавать closure.
А, то есть это означает, что в том примере кода z, оно во всех трех местах будет в копии из environment?
Даже не копия, а мувница внутрь.
То есть, смотри, когда ты будешь создавать себя, z будет z и scope.
То есть оно мувница в closure в момент создания.
Компилятор кто будет знать?
Когда ты возьмешь мутабельную ссылку, если ты не будешь использовать closure,
а дальше попробуешь еще что-то по мутабельной ссылке сделать, компилятор на тебя пожалуется.
Скажет, что у тебя здесь мутабелл боровый, и здесь ты пытаешься еще один мутабелл боровый сделать, например.
Ну то есть он все это трекает, соответственно, по всем правилам раста.
Все работает очень банально.
Ну вот если вы попробуете, раз что fn once имплементировали, попробуете ее дважды вызвать,
то у вас это не получится, потому что z вы внутрь замували,
и никак вызвать closure дважды не получится.
Ну это логично, потому что у вас внутри какой-то боевой бью кол,
у вас z мувница после первого вызова, и во время второго вызова вы уже ничего сделать не сможете.
То есть z у вас просто нет, не существует.
Поэтому вот тому, как раст определяет, как он захватит применное, понятно?
Он захватывает минимальным необходимым образом, то есть по ссылке, мутабельной ссылке или по значению,
в соответствии с тем, как вы пользуетесь внутри своими переменами.
Ну и fn соответственно имплементирует тот, который соответствует тому, как вы захватили перемену.
Ну смотрите, у нас здесь есть такой примерчик, что если мы хотим вернуть положение.
У нас, например, есть здесь мой кадр, который принимает на вход x и возвращает какую-то функцию,
которая прибавляет x к еще какому-то своему аргументу.
Вот видите, вот в fn main я создаю эту closure, которая с тройкой будет.
Если я вызову f1, то это будет 4, а если f10, то это 13.
Самая интересная конечно здесь часть, это импл fn i32 в i32.
Когда мы пишем импл, компилятор понимает, что возвращаемое значение должно быть каким-то таким типом.
Ну и компилятор соответственно там подставляет какой-то свой компиляторный тип, и вы можете вернуть closure.
В терминах плюсов вам понадобится использовать std function, то есть это была бы локация на стеке.
Несмотря на то, что лямбды работают точно так же, как и closure, то есть там по сути структурка тоже все точно так же.
А также, если вы хотите closure откуда-то вернуть, то вам нужно использовать std function для того, чтобы она хранила ваше closure.
Вообще достаточно просто использовать авто, если надо пошло.
Авто в ретурне, не мешайте.
Ну типа да, сделать возвращаемый тип выводимый.
Тут то же самое, тут вывод типа на сканскрайне видит дрейт.
А это точно будет работать в плюсах?
Авто на лямбды.
Просто это немножко особенный тип по сравнению с окружающими.
Ты про то, что будет ли работать попытка вернуть лямбду из функции, если пометить?
Да, мне почему-то кажется, что кого-то не сработает.
По-моему должно работать.
Мы можем потом проверить.
Окей.
Так.
Ну да, еще кстати говоря, видите импл?
И здесь вот если вы попробуете это на самом деле скомпилировать, то в таком случае у вас возникнет такая проблема.
Расскажет, что х внутри недостаточно много живет.
Потому что closure может пережить собственно сам х.
Х, заметьте, он, да, смотрите х, он здесь вот владеющий.
Здесь вот вы для того, чтобы сделать плюс, вам достаточно ссылки.
Ложе соответственно имплементирует fn, возьмет х по ссылке.
Кто бы сядет сюда выходить из этого скопа, то в таком случае у вас х, ну он уже дропнется.
Ну да, это в данном случае и 32, но если бы это была какая-то более сложная структурка, которая не копия даже, то это было бы даже очевиднее.
У вас дропнется х и соответственно ссылка станет неволидной.
Это ссылка на какую-то переменную на стеке, которую уже нет.
Раз это ловит, говорит, что так.
Так.
Сейчас подождем.
Вот, у нас здесь вот х, так как дропнется, у нас тараст вылавливает и говорит, что так нельзя, нельзя возвращать такое в closure.
Если же вы хотите все-таки вернуть такое closure, то вам нужно использовать ключевое слово move.
Move говорит, что все, что вы будете использовать внутри closure, нужно именно замувать внутрь.
То есть строго все замувать, не брать никаких ссылок, ничего.
Это полезно, например, когда вы как раз возвращаете closures, когда у вас речь про всякую многопоточность, вы там создаете какие-то объекты, например, на стеке, а потом внутрь их move и идти к новому 32, например.
Потом вы видите более конкретно примеры.
Это ключевое слово означает, возьми все из scope, именно как владеющее, то есть move не внутрь.
Это к closure.
Это, ну да.
Это конкретно к самим значениям, которые находятся на scope.
Они будут муваться внутрь closure.
Сейчас я, наверное, даже покажу более конкретный пример.
Это не тот move, про который есть EDMove или что-то такое.
Немножко другое.
Имейте в виду.
Вы можете выполнить наш пример, который совсем еще недавно был.
В принципе, environment будет вот такой вот.
Если вы сделаете move.
То есть, заметьте, я написал closure, move.
То есть, здесь до этого не было move, а теперь появился.
Environment теперь стал вот таким.
Все по Т.
Ну как вы можете понять, что это такое?
Ну как вы можете понять, в Rust нет такого контроля, как в плюсах.
Там очень-очень точно, что мы там возьмем по ссылке, что скопируем, что мувим.
Могли указывать, а здесь нет такого.
Но правда в том, что правил Rust на практике достаточно.
Если вам хочется что-то более конкретное, то я вам даже могу сказать такую штуку.
На крейт SEO есть такой крейт, называется closure.
И он позволяет с помощью макроса брать именно такой fine-grained control.
То есть, сказать, что возьмете по ссылке, что по мутабельной ссылке, что по значению.
Правда в том, что у этого крейта всего лишь 11 тысяч скачиваний,
против какого-нибудь стока, у которого 50 миллионов скачиваний.
Поэтому, скорее всего, это никому не нужно.
И в итоге то, что в плюсах там есть очень конкретный контроль,
он, наверное, просто бесполезен на практике.
Так, еще важный момент.
У каждой closures разный тип, даже если они вообще одинаковые.
Смотрите, у нас есть даже тут и функции, и closures.
Можете такой примерчик сейчас посмотреть, пока я попью чуть-чуть.
Тут у нас есть две функции какие-то абсолютно одинаковые,
которые принимают на вход X и две closures, которые возвращают просто единички.
И у всех этих IDM разный тип, абсолютно у всех.
Даже несмотря на то, что это одинаковые функции.
Более того, есть пример снизу, что если вы захотите все запихать вектор,
то у вас не получится, потому что у всего этого разный тип.
Вот make closure возвращает какую-то лямбду, которая просто берет n и возвращает n.
Если вы возьмете make closure и make closure, то у вас это скомпилируется,
потому что у вас это одинаковая лямбда с одним и тем же типом.
Вы возвращаете одну и ту же лямбду здесь и здесь.
Да, они просто разные моменты создались.
А вот здесь вот именно две разные лямбды, потому что они в двух разных местах сделаны.
То есть каждая лямбда, она разная.
Так, вот был вопрос.
У нас все же в расте такой зерокост.
Здесь у нас вроде бы какие-то мувы происходят.
Что-то с виду дорогое.
Но на самом деле это конечно не так.
Потому что на самом деле компилятор знает, как вы всем этим пользуетесь.
Структурка на стэке находится.
Если вы возвращаете, вы можете вернуть на стэке, как вы увидели,
написать имплэлфэн и у вас остается.
Все очень быстро.
Ну и это на самом деле очень классно,
потому что компилятор всякие, если вы напишете век, итер, мэп,
эти штуки все заинлайнятся.
Во-первых, во-вторых, они там викторизоваться будут.
То есть это все очень быстро работает.
И поэтому клоузжа это действительно зерокост абстракшн.
Ну и это все очень классно.
И поэтому клоузжа это действительно зерокост абстракшн.
Вот как-то так получается.
Какой вопрос, мы делали мув,
потому что он не мог предсказать lifetime.
А я мог ему предсказать lifetime?
Нет, он же знает, что X дропается.
Ты ему не мог никакой lifetime предсказать.
А, да, поскольку у него посылки нет.
Ну и более того, там нет такого контроля,
и он не нужен на самом деле.
Ну в общем плюсах, в принципе,
лианды работают точно так же,
за исключением одного момента, который называется std-фанкшн,
и который, например, в курсе Рома Липовского
просто переписан на какой-то уник-фанкшн.
Я сейчас даже забыл причину конкретную.
У него есть мув вон ли колбеки?
Да, мув вон ли колбеки.
Вот примерно что-то такое.
Ну не знаю, это претензию не к плюсам,
а к стандартной библиотеке.
Ну это все-таки к плюсам, потому что это std.
То есть если ты придешь в плюсы,
то тебе придется писать что-то свое, если тебе захочется.
Вместо того, чтобы в стандартной библиотеке пользоваться.
Соответственно, это как-то не унифицирует между собой код,
это хранение.
Давайте еще сейчас скажу.
std-фанкшн тлов, потому что он внутри
использует локацию на хиппе,
то есть там точно такой же фетпоинтер.
Конечно, на практике там используется еще SO.
Small Object Optimization.
Но это не всегда работает.
И зависит от use-case.
В Rust все closures локируются на стеке.
И если вы хотите стд-фанкшн,
то используйте box-din-fn.
И заметьте, что это очень хорошо абстрагирует.
И стд-фанкшн как-то совсем ничего не говорит
по сравнению с box-din-fn, что на самом деле происходит
в этом объекте. Box-din-fn говорит,
я там динамически храню, то есть у меня там какой-то
трейд-объект fn, который можно вызвать.
Вот это как раз уже еник-фанкшн получился.
Box-это же exclusive ownership.
То есть ты имеешь в виду, что
можно и rss-ку написать.
Это просто придергка, что не совсем одинаково.
На самом деле это круто, потому что мы просто
взяли и собрали еник-фанкшн с того, что есть.
Ну да, мне это тоже очень нравится.
То, что в Rust эти абстракции очень хорошо
друг на друга накладываются, как будто мы пишем
в каком-то функциональном языке с чистыми математическими абстракциями.
И при этом это красиво и практично.
А если говорить про closures, есть какие-то вопросы?
Кажется, это должна быть достаточно простая тема.
Потому что вы все знаете список.
Давайте поговорим про метапрограммирование.
Я так понимаю, в этой аудитории
только один человек проходил курс про метапрограммирование.
Это так?
Ну ладно, я себя отрезаю.
Знают ли слушатели курса по-раз,
что такое метапрограммирование?
У нас на плюсах были немножко всякие
enable if максимум.
Элементы метапрограммирования.
Причем не самые красивые.
Поэтому приходите в четвертом курсе
на метапрогу, если она будет.
Она должна быть лучше.
Мне, если честно, метапрограммирование не понравилось
на плюсах совсем.
Вы поймете, почему мне она не понравилась,
когда вы видите макросы.
Макросы более сильный инструмент и удобный.
Метапрограммирование – это код, который генерирует код,
просто говоря.
Есть всякие языки программирования.
Я в них не разбираюсь, вроде BML или Lisp.
Я, чтобы не соврать, не буду точно говорить.
Где есть всякие инструменты, которые позволяют
коду модифицировать самого себя в runtime.
Это, конечно, прикольно, но кажется, не очень нужно.
Мы вместо этого сфокусируемся на примере
кода, который генерирует код.
То есть более узким, в таком смысле, метапрограммирование,
которое в плюсах реализовано на темплейтах
и в расте, как мы видим, реализовано на макросах.
Примерно понятно, что значит код генерирует код.
А уже текст программ будет?
Да.
В смысле плюсов это были бы какие-то типы.
Вот.
Когда нам нужно метапрограммирование?
Когда я лень писать.
Ну, метапрограммирование, смотри.
Раз, что код генерирует код, то первое, что хочется с ним сделать,
скорее всего, сделать так, чтобы код сделал за тебя всю грязную работу.
Всякие boilerplate, наверное.
Это как минимум.
Потом, в случае плюсов, есть всякие хаки, которые позволяют
выбирать имплементации и все такое.
В расте, кстати, тоже есть.
Там называется trade specialization.
Я надеюсь, у нас в Домашке будет на этой задачке.
На следующей неделе.
Еще всякие оптимизации.
При калькуляции всяких значений, табличек.
Там можно, например, идеальные хэш-таблицы делать в compile-time.
С помощью этого программирования.
Вы заранее знаете список значений, по которым вы будете по ключам идти.
Соответственно, вы можете сделать в compile-time идеальную хэш-таблицу,
которая будет все делать за вот единицу без коллегии.
Вот.
Ну и всякие другие можно оптимизации придумать.
Например, сгенерировать заранее всякие таблички
для каких-нибудь алгоритмов.
Это алгоритм зависит, конечно.
Например, алгоритмом всякие хэширования, разные таблички могут требовать.
В зависимости от input-параметров.
И поэтому их можно сгенерировать с помощью средств метапрограммирования.
Вот.
Ну, можно вставить части исходников прямо...
Ну, какие-то данные из файлов прямо в исходный код программы.
Например, если вам нужно вставить какую-то картинку прямо в исходный файл.
Это иногда бывает полезно.
Если вам хочется, чтобы все быстро работало и чтобы вам не...
Ну, даже не быстро работало, чтобы клиенту дать только один бинарник, например.
Вместо того, чтобы давать папку, в которой будет бинарник и какие-то картинки лежат.
Чисто для примера.
Так, ну, про boilerplate код мы сказали.
Например, там если что-то очень часто повторяется, можно вместо этого сделать ползу,
которая будет сдавать что-то генерировать.
Или, например, диасельки.
Диасельки это особенно...
Особенно такая важная ерунда, когда мы говорим про всякие вещи, связанные с фронтэндом.
Я тут не сильно разбираюсь, что это, потому что я не фронтэндов разработчик,
но кажется, что это не фронтэндов.
Я не фронтэндов разработчик, но кажется, что те,
кто разрабатывает на таких больше бэкэндовых языках,
то у них обязательно какие-то диасельки допоявляются,
для того чтобы проще всякие разметки делать и все такое.
Например, там JetBrains, я знаю, используют для ID-шек своих специально диасельки.
Что ж, ну, какие у нас есть средства метапрограммирования в плюсах?
У нас есть такие два главных средства.
Это template-metaprogramming и defined AC.
Ну, template в плюсах – это такая тюрем полная вещь,
с помощью которой можно писать компилятор на C++, на C++-templates.
Если сильно захотеть, то можно, только никому это не нужно.
Ну, еще тут важное замечание на слайде есть,
что вы можете написать любую программу в математическом смысле.
То есть она из любого input может сделать любой output.
Например, в более практическом смысле, например,
сходить в базу данных, добыть какую-то строчку из таблички,
вы, конечно, с помощью template-ов не сможете.
Это нужно делать, например, на уровне системы сборки.
Потому что плюсы так не умеют просто.
Ну, и, наверное, если вы уже пользовались как-то template-ами,
то вы могли заметить, что это какая-то такая джедайская техника,
достаточно сложная, ее достаточно сложно изучать.
Более того, она еще и редко применяется.
То есть бывают такие случаи, когда нужно,
но обычно обходится без метапрограммирования.
Еще есть припроцессор Define.
У него такая проблема.
Дело в том, что он работает на уровне файла исходного кода.
То есть он ничего не знает про то, что лежит в этом файле.
Он просто берет и в тупую, и в глупую,
меняет все обхождения какого-то слова,
ну, паттерна, на то, что вы укажете.
Вот.
Ну, это, с одной стороны, это удобно бывает,
но с другой стороны, за счет этого могут выстрелить самые рандомные ошибки,
где у вас там, например, какая-нибудь скобочка куда-то пропала,
или, не знаю, там Define-ы пересеклись,
и в итоге у вас получается какая-то очень стрёмная ошибка в компиляции.
Просто потому что у вас там в Includes как-то очень стрёмно Define-ы лежат.
В общем, это такая небезопасная вещь,
которую нужно пользоваться с осторожностью.
Как-то так.
Знакомы с этими инструментами?
Ну, как-то так.
Что же у нас в Raster?
У нас, на самом деле, конечно, больше, чем макросы есть,
но мы будем на лекциях изучать только макросы,
потому что их, в принципе, достаточно для всяких юс-кейсов,
а для большего, ну, это, наверное, какие-то приколы,
например, то, что есть ссылка к снизу,
макросы это супер мощная вещь.
Это вплоть до того, что вы можете брать просто
в произвольной последовательности токенов и превращать в произвольный Rust-код.
Причём, по сути, это Rust-код, который генерирует Rust-код.
Вам ничего не мешает в макросах читать файлы,
ходить в сеть, там, не знаю,
биткоины майнить на компьютере того,
кто компилирует ваш код в собственной библиотеке.
Ну, там есть какие-то, конечно, защиты от этого.
Да, да, вот есть там какие-то сподвижки
на то, чтобы сделать макросы более безопасными.
В целом, конечно, можете не беспокоиться в упенсорсных библиотеках,
что такое появится, ну, потому что не появится.
Просто это всё очень в большом числом людей просматривается.
Но вообще, в целом, будьте аккуратны с тем,
чтобы компилировать произвольный Rust-код,
потому что он может прямо что-то сломать.
Да, и украсть там пароли и всё такое.
На самом деле, в Rust можно всякую магию делать на трейтах и объектах.
Ну, там, то есть, generic metaprogramming, всякие трейты объявлять прикольные.
И так как это всё делает Turing полно,
то в таком случае, вы можете писать тоже код,
как вы хотите.
Ну, в общем-то, да.
Ну, в общем-то, да.
Ну, в общем-то, да.
Ну, в общем-то, да.
Ну, в общем-то, да.
Так что juste inauguration城 ana и, как и в плюсах, произвольный код.
Более того, я вам скинул здесь два примерчика.
Это вот на русском.
От одного человека, который написал fist vive в compile time.
Достаточно простая и при этом прикольная статья.
А вторая она про то, что, там, «не помню, какой точно язык»,
«какой-то язык Тюринг полный имплементируется на системе типа в Rust»,
соответственно, доказывают, что система типа в Rust-а тюринг полна.
То есть, эта статья, по- сути, сделана для того, чтобы доказать,
Раста полна
Все, мы закончили наш интро
Надеюсь, вы поняли, что такое это программирует
Ну давайте перейдем тогда к декларативным макросам
Давайте перед тем, как мы перейдем, посмотрим такую мощь
Смотрите, просто взяли произвольный синтез
Запихали просто JSON в Rast код
Это такой крейд, называется cert
Про который мы уже говорили, кстати, в какой-то раз
Он предназначен для того, чтобы всякие форматы серилизовывать и десерилизовывать
Ну как вы можете заметить, это название даже CRD
Собственно, в CRD JSON есть такой макрос, который позволяет вставлять JSON прямо в код
В какой-то момент, даже в ровере, вместо того, чтобы использовать мультипарт в request
Использовался просто JSON и отправлялся как строчка
Это все прекрасно работало
Ну то есть, я использовал CRD JSON, а потом просто вспомнил, ага, точно, тут есть мультипарт, можно воспользоваться
Ну давайте посмотрим на то, как вообще их писать
Смотрите, вот мы создаем вектор и делаем push push push единички
Такс, ну нам хочется это как-то сократить, да, это какой-то boilerplate
Ну давайте напишем макрос на это
Ну то есть, он выглядит так в стандартной библиотеке
Тут, например, единичка три раза или вот вектор из трех единичек
Мы уже наверняка пользовались домашней этой штукой
Так, ну что ж
Страшно, да?
Ну что ж, мы сейчас будем по частям разбирать вообще все непонятные моменты, что есть в этом макросе
То есть, не пугайтесь, это далеко не последний слайд конкретно CreateVec, мы будем его постепенно рассматривать
Итак, макросы декларативные
У нас объявляется с помощью ключевого слова macro-rules
Из себя оно тоже представляет макрос, но только специально для компилятора
Кстати, вы когда смотрите на этот макрос, даже интересно, вы примерно понимаете, что в нем происходит?
Ну это выглядит как pattern matching, что в зависимости от того, что написано после макроса, мы генерируем нужды нам кожи
Да, а Маш, чуть-чуть конкретнее рассказать, что происходит в строчке
Ну вот у нас CreateVec
У нас был вот до этого Vec, который на стандартной библиотеке в двух формах
И здесь нас подчислили обе формы за implementation, то есть сначала там элементы и сколько раз он должен повториться
Ну, это конвертированный код, который делает new, resize
Ну да, и resize он заполняет этот вектор
На втором случае мы о чем-то не делаем, да?
Ну мы про это поговорим, кстати
Ну это пока что без резервов просто
Вот здесь вот повторяется push
Ну да, мы не знаем, во сколько, да
Ну пока что мы просто push
А потом у нас будет прорезерв
Итак, с этим понятно
Давайте посмотрим на частично удаленный код
У нас есть CreateVec, который выглядит
Ну вообще CreateVec сам себя выглядит как янам
Какая-то часть слева, потом стрелочка, какая часть правого
Часть слева называется matcher
То есть это то, какой паттерн мы берем
Ну, слева в общем паттерн, на котором мы пытаемся смачиться
Вот здесь можно заметить первое паттерн это какое-то выражение
Потом точка запятой, еще одно какое-то выражение
В втором случае у нас будет здесь написано, что повторите какое-то выражение
Через запятую произвольное число раз, ноль или больше
Так, да
То, что справа называется transcribers
Это такие определения, которые не везде всплывают, но они есть
Вот слева matcher, справа transcribers
Да, и сам код, и код, зачем он поменял только
А у нас есть слева вот эти вот аргументы, которые value, count
То есть через доллары написано
Это называется метапеременная, meta variables
Они специфицированы с помощью доллара
После самой переменной, ее название, это метапеременный
Мы пишем ее тип
Типов у нас несколько
У нас есть export, что есть выражение
Выражение это там 1, плюс 2, плюс 10, минус 3
Поделить на 2 функции от всего этого и так далее
То есть какое-то произвольное выражение
Statement есть
Есть тип произвольный
То есть можно типы, в том числе макро составлять
Идентификаторы
Чуть-чуть более конкретно
Например, если вы сделаете
Хотя, наверное, там дальше будет пример
Так что давайте я пока что скажу, что просто идентификатор
Например, это когда вы делаете let x равняется 3, x это идентификатор
Так
Ну или какое-то ключевое слово можно вставить
У нас есть expressions, есть statements
Expression это какое-то выражение, какое-то число
А statement это
Через точку и запятое что-то
То есть просто какой-то кусок кода
Expression это выражение какое-то, которое имеет значение
А statement это конкретно кусочек кода
Как-то так
Потом есть блок
Блок это что-то в фигурных скобочках
То есть scope, грубо говоря
Есть token3
Token3 это уже такая вещь, очень важная в теме макросов
Token3 это какой-то код
Который находится внутри круглых скобочек
Квадратных скобочек либо фигурных скобочек
То есть token3
Наверное, когда мы дойдем до процедурных макросов
Мы поподробнее поговорим
Потому что декларативные макросы обычно
По позиции expressions и типами
Ну еще идентификаторами
Ну и литералы там всякие
Можно там чиселки, например, написать строчки
Писать макросы
Чтобы повторить какой-то паттерн
Какое число раз
У нас есть такой специальный паттерн
Это доллар, скобочки
И после этого звездочка, плюсик
Либо вопросик
Ну как может догадаться
Звездочка ноль или больше раз
Плюсик это один или больше раз
А вопросик ноль или один раз
То, что в скобочках
Оно будет подразумеваться
Что в скобочках есть
Ну как можно догадаться
В скобочках оно будет подразумеваться
Что оно будет матчиться
Как сколько-то раз повторяющийся
Отличный вопрос
Здесь вот видишь есть запята
Если ты напишешь
Ну мне кажется на следующем слайде это будет
Да
Можно как раз написать
Сепаратор
До того как ты напишешь звездочку плюсик
Либо вопросик
Звездую, точку запятой, стрелочку
Ну тоже тебе нравится
Не все разрешено
Потому что
Декларативные макросы у них
Ограниченный синтакс сейчас по сравнению с процедурными
Например после expression ты не можешь
Секономерно написать палочку
Но палочка потому что она OR
И соответственно рас не будет знать
А это конец выражения
Или это продолжение его
Не сможет просто поматчить и понять где что
Ему нужна какая-то определенность
Ты точно тебе скажешь что выражение закончилось
А это нет
Соответственно раз за этим следи
То будешь давать compile time ошибки
Если ты не сможешь это использовать в качестве сепаратора
Если между ними ничего не будет
То он разделяет по
По пробельчику
Ну или по табу
Ему без разницы можно enter
Ну как сказать
Там просто чтобы главное
Был какой-то промежуток
Типа пустой промежуток
Так
Давайте напишем чтобы понять
Repetitions чуть-чуть получше
Такой немножечко странный макрос
Но зато будет чуть-чуть понятнее
Что происходит
Посмотрите на него внимательно
Попробуйте понять что происходит
Кстати еще возможно вас может запутать
Здесь это фигурные скобочки
Видите?
Это у нас были квадратные
Теперь фигурные
На самом деле нам без разницы что писать
Круглые, квадратные или фигурные
Макрос со всеми может работать
В том числе если вы напишите фигурные
Вы можете экземпл потом вызвать квадратные
Как я например сделал
Это не является частью матчинга
То есть это просто то что вы ставите
Для вашего удобства
Чтобы было лучше видно что внутри
Что-то происходит
Абсолютно верно
Сколько-то expression через запятую
Кстати
Точно так же как и везде
Rust позволяет писать
Вот эту запятую писать или не писать
В конце этих expression
Без разницы
Если вы напишите один запятая, два запятая
То же самое что один запятая, два
Просто позволяет эти разделители
Повторять в конце для вашего удобства
Воскресательный знак означает что?
Воскресательный знак это специальная штука для макроса
То есть когда ты вызываешь макрос
То ты должен с воскресательным знакомым вызывать
Компилятор когда будет это партией
Он поймет ага это макрос
И будет по сравнению с ним работать
Чуть конкретнее попозже поговорим
Ну действительно тут какое число выражений
Стрелочек какое число выражений
Чуть-чуть усложнили задачу
Что здесь?
Буквально капельку
Да просто скобочковый округ поставили
А теперь мы еще зафигачили вот так
Ну на самом деле там без разницы
Ну конкретно в данном случае
У нас чуть-чуть попозже
Будут слова о том
Почему нужно одну ставить
Почему нужно ставить две
Конкретно в данном случае без разницы
Давай пока что скипнем
Ну да в общем в скобочках
Через запятую какие-то такие же выражения
Просто повторили какое-то число раз
То что было вот тут через запятую
Ну то есть вы можете писать внутри
Repetitions, еще repetitions, еще repetitions
Но как вам нравится
Все это раз будет мачить
Подсвечивает только открывающийся
И вот здесь вот
И вот здесь вот
И вот здесь вот
И вот здесь вот
И вот здесь вот
Подсвечивает только открывающийся
И скобка
Ну это недостаток
Синтаксиса
Минтед для тех
Он не умеет просто так делать
Так у нас тут чуть-чуть
Поврезался
Не обратил даже внимания
Ладно
Что ж давайте вернем
На место код
Когда мы пишем
Первые фигурные скобочки
Для того чтобы означать, что у нас вот здесь начинается
Собственно наш код
Который мы вставляем
А вот вторая нам нужна
Если у нас внутри несколько выражений
То есть у нас конкретно здесь
В первом
Мачере
У нас вот здесь transcriber точнее
У нас вот здесь два выражения
Потом век возвращаем
Как бы из скопа
Вот этот вот скоп у нас означает эти вещи
Если мы будем писать createVect
Он грубо говоря
Не совсем правда
Но ставит в этих фигурных скобочках
То, что он внутри сделал
Просто заменит
Хардение макроса вот этим
Вот здесь смотрите
У нас только одно выражение
Поэтому давайте без фигурных скобочек
Сразу же вернем
И он заменит макрос на просто вот эту строчку
Это был node.exemple
А ну это node.exemple
Это как раз потому, что здесь у нас нет фигурных скобочек
Это в этом смысле
А почему мы вообще рассматриваем
Эти случаи, если звездочка
Предполагает
А вдруг тебе хочется сразу же просто век не увернуть
То есть даже чтобы не было никаких вопросов в комплятуре
Не на клип получится?
Потому что матч ценей 1,5 и 3?
А вот и нет, потому что
Раз матчет их линейно
Просто приходится твой патрон такой
Ага, так, о, подошло
Как-то так
Ну как матч
Да-да, как матч работает
Именно так
Поэтому ты можешь писать даже какие-то
Повторяющиеся вещи
Я, кстати, не уверен
Если их поменять местами
А, наверное, тоже скомпилируются
Только тогда будет бесполезна эта строчка
Если вы допишете
А он не скажет, что я не знаю, что такое
Где именно?
Ну вот, если мы уберем вторую
Только последнюю оставим
И мы хотим создать пустой вектор
Сейчас, ты хочешь убрать вот это?
Ну да, я хочу создать пустой вектор
Используя вот вторую
А, ну он просто попробует повторить
Он такой смотрит
Когда он делает вот этот репетицион
Мы сейчас поговорим, конечно, об этом
Он смотрит на все вот эти значения внутри
Он знает, что value это список каких-то выражений
Если их там может быть и несколько
На самом деле
То есть ты можешь несколько списков взять
И сюда запихнуть век push
А потом еще век push
Из какого-то второго списка
Например
Rast обратит внимание
Что
Ну, в общем, он просто будет повторять
Какое число Rast
И будет матчить между собой длинные этих двух вещей
Как-то так
Rast скажет не совпадающее
Он будет это делать
Но он в compile-time скажет
Что что-то выдали неправильную длину
И не могу в макросе этого
Ну что ж, вот мы и нашли варядики
Ну да, это что-то типа варядиков
Это такой костыль, знаете
Если вы хотите вас слушать про костыли
Дело в том, что
Вообще
Все вот эти правила
Macro rules
Это первая версия макросов
На данный момент
В тот момент, когда их делали
Ну, Rast еще не был 1.0
Когда их начали делать
А Macro rules были блокером для многих вещей
Почему были блокером?
Потому что было огромное число фичей
Которые еще предстоялось дизайнить
Что-то типа там варядики
Еще какую-нибудь хольеру
Принт LN, например
Хочется запихнуть
А синтаксиса в языке нормального для этого нет
Соответственно, хотелось сделать
Макросы, чтобы сделать какой-то
Плейс холдер
Чтобы какие-то фичи
Уже можно было реализовать в виде макросов
А чуть позже сделать нормально
В каком-то смысле
Macro rules это какой-то костыль
Для того, чтобы дать себе возможность
Для дизайна чуть попозже какую-то фичу
Был 1.0
Ну да, вместо этого
Это было просто откладывание стандартов
А в итоге просто не развивается
Получается
Нормально
В 2011 году стандарты вышли
Все поняли, наконец, что-то много
Откладывали
Раз в три года
Да, ну сейчас делают
Декларативные макросы 2.0
Если интересно, тоже можете погуглить, почитать
Там такой синтаксис
Пишете макро, ну вместо fn пишете макро
И там в скобочках примерно то же самое, что и здесь
Там какие-то свои правила
Гигиены, про которые мы поговорим
Все такое, ну то есть решает
Макро rules
Не знаю совсем
Наверное, не очень скоро
Просто еще много работы
Вот процедурные макросы, о котором будем говорить
Их задизайнили уже после 1.0
И задизайнили нормально, поэтому
Не, процедурные макросы
Они более сложные, чем эти
Просто такое
Найди и вставь, а там будет прям функция
Раст код
Давайте пойдем дальше
Вопрос
Почему это мы так вот
Пишем два двоеточия, потом estd, vec, vec, new
Там что-то такое сложное
Дело в том, что
Наш макрос, ну могут естественно
Использовать какие-то сторонние библиотек
В сторонних библиотеках, если вы
Например, не напишете два двоеточия
То
Макрос уже просто вставляется на место
На место кода, который его вызывает
А вдруг у человека там
Рядом лежит mod.estd, mod.vec
И внутри структура vec
И соответственно вы ее создадите
Примерно так
Двоеточие перед этим всем
Это то, что не было на лекции про модули
Означает список
Текущих импортированных крейтов
То есть
Два двоеточия, если вы пишете, это означает
Что вот сейчас вы будете
Типа
Вернулись прям настолько, что не прям в корень
Ваш текущий крейт, а вообще из него
Как-то так
Не забывайте, что
Все пути, которые вы врасти
Они относительные всегда
А если вы хотите такой абсолютный
И если вы хотите, чтобы ваш макрос переиспользовали потом
Пишите полные пути
Чтобы точно можно было везде вставить
Независимо от того, какие юзинги прописал человек
Для примера, если Диму не заимпортировали
То мы получим ошибку, конечно
Еще есть такая штука, называется крейт
Она везде всех макросов есть
Она содержит просто название
Текущего крейта
У вас есть макрос
Модюл экземпл
Внутри у вас есть макрос
В таком случае крейт, понятие на экземпл
Модюл экземпл
Как-то так
То есть просто такой паттерн
Там не абсолютный пик появится
А вот просто название
Да, это просто название
Он просто вставит текущее название
Типа того крейта, в котором ты
Макрос этот уже
Ну вставил
Так
Что же
Что же я хотел тут сказать
Сейчас
А, ну да, так
Да, если бы мне понять еще
Что я хотел этим сказать
В своем слайду
У нас просто создается структура кс
Потому что у нас два модуля
Внутри структуры кс
И в тесте используется макрос
А, ну тут смотрите
Тут есть имя nested s
Внутри
Внутри макроса nested s
Если вы вот здесь вот
Зайузуете
New s, то оно
Заработает
Так
Вот этих двух строчек не должно быть
Я понял
Это я скопировал сразу playground у себя
Когда я делал лекцию
И забыл эти две строчки удалить
Когда вы увидите экземпл тест
Вот здесь вот, то в таком случае
Это сработает
Потому что у вас nested s
Вот здесь вот и заимпортируете
В общем нужную структуру
Создадите
А если вы здесь вот new s создадите
То он попытается вызвать nested s
Которого здесь нет
Такой вот примерчик
Так
Тоже
Подзабыл что у нас тут
Ну, по сути вот
Про то, про что я говорил
То, что у нас
Вот это вот, если вы хотите repetition
За expending, то в таком случае
Используйте доллар, скобочку
Сколько раз вы хотите повторить
То есть 0 или больше, 1 или больше
Либо 0 или 1
Соответственно он будет по всем значениям
Которые внутри написаны
В нашем случае dollar value
Это список значений
Он будет его матчить
Если там будет несколько
Интересно, примерчик кстати есть
Примерчика кажется здесь нет
Так и
Проекта приходит в себя
Вшел в себя
Ну, как я сказал, если будут не одинаковые
По длине списка, то в таком случае
Раст будет навозлиться
Так, время пришло
Улучшать
Наш macros
Как Андрей уже говорил
У нас тут
Не алоцируете вектор
У нас постоянно делается push
Пушу не эффективно, когда вставится в код
Будут реалоцировать несколько раз
Нам хочется заранее это алоцировать
Сейчас будет true metaprogramming
C++ like
Вот, смотрите
Как же мы хотим это сделать
Как вы думаете
Посчитать нам
Давайте более конкретно
Длину списковой лилы
Как мы это сделаем, если догадка
Да, давай чуть конкретнее
Как будет работать macros
Как он объявлен
Реально объявить переменную после века
А дублировать
Не только push, но еще
lplus равно 1
Может создать переменную
Дело в том, что если lplus равно 1
Ну не знаю
Это не лучший способ
Она будет работать
Мы хотим использовать переменную для macros
Давайте так
Мы хотим новый macros, который умеет считать длину
Какого-то аргумента, который передали
Максимально конкретно
Мы можем сделать так, как ты сказал
Но это будет не очень красиво
Раскроется в том, что у тебя lplus 1 будет
Прямо внутри вектора
В создании вектора
Сейчас, ну там match
Есть что-то, и пустота
Возвращает 0
Когда есть что-то, возвращает 1
А как есть что-то, где люди ездят
Ну вот это
Что-то в Китае
Что там было?
Ну в общем ладно, ты мыслишь правильно
Давай мы это
Прямо на слайде выразим
Смотрите, у нас либо пустота
И мы тогда возвращаем 0
Есть какой-то head
Я забыл поменять название
Здесь используется dollar tail
Снизу в описании
Здесь нет head tail
Как вы видите head у нас
А это какой-то tail произвольной длины
Мы заменяем на 1
А macros можете рекурсивно вызывать
Да, macros умеет рекурсивно вызывать
Я думаю, как-нибудь из этого сделать
Вот как раз know that our macro is recursive
По ходу мы открыли husky
Или lewkarp, или что-то похожее
Потому что сейчас очень похоже
Да, это все только declarative macros
TT это токен 3
Это произвольная деревья токенов
Ну просто для того, чтобы наш код был максимально общим
Мы пишем произвольные деревья токенов
Вообще по факту можно expression написать
Точно так же будет работать в данном случае
Вот, ну как видите
Пишу вместо new теперь with capacity
И пишу здесь на 3 count длиной value
Как-то так
Как вы думаете, у нас есть какие-нибудь
Лимиты по рекурсии?
Ну было бы глупо, если бы не было
Потому что если это даже не обрабатывает
Тогда бы секвел целся компилятор
И у юзера было бы очень очевидно
Видеть секвел компилятора
На этапе раскрытия максов
Поэтому конечно же там есть
Лимит, называется recursion limit
Это является атрибутом
Что такое атрибут, конкретно поговорим чуть попозже
Вопрос with capacity
Он требует умолчания?
Что?
Capacity это исключительно вектора
Внутри
Создается век, у которого
Заданы capacity
Нулевое число элементов текущего
И буфер на capacity элемента
Просто статическая функция такая
Вот, чтобы
Занесло лимит
Это атрибуты
Да, это тоже на самом деле макросы
Ну мы чуть-чуть попозже это посмотрим
А, погоди, что решетка
Вот статский знак это макрос?
Да, это все макросы
Просто решетка тоже макрос
Решетка квадратной скобочки
Это все макросы
Некоторые конечно специально для компилятора
Но у них нет такого воплощения
Но тем не менее
Тоже макросы
Что-то неожиданно
Дополнительный лимит 128
Если вы попробуете список
Из 256 элементов
Засуммирует так вот
То компилятор зафейлится
То есть скажет, что
Не хватило глубины
Пытались еще раз вызвать
Recursion limit не только влияет на макросы
Он влияет в том числе на всякие другие
Compiled time операции, например, на деревы
Чтобы не были бесконечными
Все рекурсивные этапы на этапе компиляции
Связанные как-то синтезом языка
Они управляются с recursion limit
Вот, управляются
Так
Еще важная такая штука
Макросы достаточно сложная для дебага штука
Потому что чтобы словить баг в макросе
Вам нужно макрос вызвать
То есть посмотреть то, что он вставит
Конкретно
By default trust он не дает никаких
Возможностей посмотреть, что происходит
Есть такая тулзан
Звать Cargo Expand
Она позволяет
Позволяет раскрыть ваш код
В том числе, если вы вызовете Cargo Expand
И увидите Rust Prelude
Например, который не явно вставляется
Если вы вызовете
То он в том числе раскроет вам макросы
Например, такой вызов превратится вот в такой
То есть ровно то, что мы делали
Как-то так
Да, это неважно
Андрей, у нас гигиеничная макроса
Мы сейчас посмотрим на это
Это не Define
Да, ты можешь забить
Абсолютно на эти скобочки
Но если ты count на count
То все хорошо умножится
Потому что
Грубо говоря, не явные скобочки
На самом деле, то что внутри макроса
И то, что снаружи макроса живет
Немножко в параллельных вселенных
И там есть определенное правило
Как взаимодействовать
То есть гигиеничность есть такое понятие
Да, Define это очень страшно
Можно случайно сломать себе код
Просто так
Вот, ну смотрите
Я могу написать такой вот макрос
Который принимает какое-то приложение
На английском со значением 42
И даже выйдет
То есть действительно выйдет
Wow, the value is 32
32
Ну там конечно есть
Как я говорил, некоторые ограничения
Например, после expression нельзя ставить палочку
Потому что эта часть expression
Может быть, поэтому все должно быть
Определено
Конкретные правила
Во-первых, лучше поработать именно с макросами
Чтобы понять какие
Во-вторых, ну, наверное
Они прям нигде очень подробно не описаны
А хотя, наверное, есть одно место
Есть такая книжка, называется The Little Book of Macros
Если вам очень интересно, можете почитать
Она прям конкретно описывает
Как работает макроса досконально
Какие там понимают деревья токенов
Какие стримы и как оно все преобразовывается
И из этого должно быть примерно понятно
Что можно вставлять и что нет
Но я думаю, что вам это не особо понадобится
Нет, там кстати маленькая книжка
Она в несколько раз
Меньше, чем Rustbook
Но она вообще предназначена для продвинутых пользователей
Но там ничего сложного вроде и нет
Все готовы читать такие книжки
Вот, а теперь пришли к гигиене
Смотрите, у нас в СИШке
Была такая фигня, что мы могли
Написать, например, 5
Внажение на 5
Правда, здесь я, получается, написал скобочки
Нет, тут все нормально
Ну, в общем, этот ассорт зафелдится
Это очень-очень плохо
То есть у нас вместо вэлью подставится 2 плюс 3
Соответственно будет 2 плюс 3 на 5
И это 17
И 17 неравно 25
Хотя казалось бы
Нужно в скобочки, оказывается, брать вэлью
Все потому, что макросы
То есть defined, которые СИШны
Они совершенно ничего происходного не знают
Они просто работают до того
Как начинает работать компилятор
И они заменяют сходение
Вот, а вот тем временем в расти
Например, это все сработает
И почему же оно все-таки будет работать?
Ну, мы говорим вообще, что
Макросы расты гигиенично
Когда мы говорим, что
Макросы расты гигиенично
В таком случае мы имеем в виду, что мы
Здесь скобчик generally
То есть там есть некоторые исключения
Не можем никак влиять
На переменную, которая находится
Снаружи
То есть мы не можем внутри макроса
Как здесь написано, создать
Здесь чуть-чуть переехала скобочка
В принципе, это даже хорошо вместилось весь код
Ну, вот здесь мы создаем какую-то переменную foo
И представим значение x
Казалось бы, если мы сделаем let foo
Двойки, то мы внутри сделаем let foo
Ровняется 2 и должен ассорт зафэдиться
Но нет, потому что эти переменные
Друг с другом никак не связаны
В принципе, самое-самое простое способ
Об этом думать, это
То, что они живут немножко в параллельных вселенных
В принципе, так и есть
Там мы чуть-чуть попозже
Подсмотрим наспэны, такая вещь, которая позволяет
Прям точно в процентурных
Макросах учитывать
Относительно, чего будет рисовываться переменная
Это мы чуть-чуть попозже разберемся
Как-то так, но с этим примером понятно, да?
И что такое гигиеничность
Тоже примерно понятно пока
Ну, еще примеры будем, конечно
Вот, гигиеничность
Она не действует
На вещи, которые не связаны
С идентификаторами переменных
Прям что они шарят
Типы, модули
И функции, в общем
Внутри call site это называется
То место, где макрос вызвали
Именно не где он объявлен
То, что вы могли заметить, например
Нам с stdvec пришлось тем не менее
Писать полный список
Полное имя
Просто потому, что у нас макросы
На самом деле шарят тем не менее
То, что у нас заимпорчено
Внутри
Вот
В общем, все тут понятно, да?
Ну, давайте посмотрим, например
На какой-нибудь шаринг бдтика
Вот, ну, например, есть идент
Как мы смотрели
Там, среди типов
Идентификатор и у нас будет
И какой-то expression
Смотрите, мы идентификатор
И прорисовываем значение x
И как-то не странно, здесь гигиеничность
Не получается
Потому что мы передали идентификатор
В макрос я, то есть мы такое умеем тоже делать
Как-то так
Но еще есть такое понятие
Как visibility макрос
Ну, у них тоже немножко особенные
В отличии от функции
То есть, если у нас была бы функция count
Тогда бы мы ее видели тем не менее в main
Даже несмотря на то, что она позже
А здесь это уже не работает
Нам нужно, чтобы оно было объявлено
Прямо по строчкам исходного кода раньше
Чем сама функция main
Ну, собственно, вот это не будет компилироваться
Потому что у нас count объявлен позже
Более того
Вы не будете без
макроэкспорт
Макроэкспорт это тоже макрос
Который, грубо говоря, выносит ваш макрос
наверх в корневой каталог
Он вам нужен для того, чтобы
сделать ваш макрос видимым
Ну, видимым, собственно, по вашему крейту
Тоже такое выглядит
Как очень костыльное решение
Там нет никаких идентификаторов ак
Нет никакого разграничения видимости
У нас макросы работают достаточно странным образом
Им очень важно, в каком порядке их объявили
Примерно так же, как в плюсах
идентификаторов в каком порядке объявлено
имеет значение
И приходится писать макроэкспорт для того, чтобы
у нас стало видно идентификат
Ну, видите, count
Без макроэкспорта не будет видно
А с макроэкспорт будет
Примерно понятно?
Как вы могли заметить, декларативная макроса
это вещь, конечно
такая подстановочная, приятная
бывает
Ну, не без недостатков, мы тоже их обсудили
такое достаточно костыльное решение
но тем не менее
рабочее, по-моему
У нас есть процедурная макроса
Процедурная макроса это достаточно сильная вещь
Вот
И вот
И вот
И вот
И вот
У нас есть вот такой отмен
по этому поводу
В общем, процедурная макроса
это такая вещь, это раст-код
который пишет раст-код
То есть вы можете написать произвольный раст-код
который будет генерировать раст-код
Ну, мы сейчас увидим
Давайте перед тем, как перейти к процедурным макросам
посмотрим на один из процедурных макросов
Вау!
Это реакно растя
Там есть Ев
На раст-коне были люди
которые рассказывали про то, как они пишут
фронтенд на расте и в том числе был пример
как на Ев пишут
Ну, это такой крейд, который представляет
реакт на расте в WebAssembly
В плане как читать
Название крейтеска
если читать как Ев
Я не знаю, как это читать
Я фронтендом не занимаюсь
Если вам очень интересно
то там есть
толки про Ев
и есть примеры того, как
он взаимодействует даже с Javascript
и всем таким
И если посмотреть, там даже просматриваться не надо
Код практически одинаковый, как вот на Javascript
на реакте, только он на расте
И все. Ну, то есть там конечно же
это все не на макросов, там прямо раст-код
Смотри, вот это
HTML это макрос
Фигурные скобки означают тело макроса
А дальше вот это
Это означает
ставить раст-код
То есть ты внутри можешь буквально
сделать, например, 42 плюс 2
и там ставится вот эта часть 44
Это типа макрос ставить еще часть раст-код
Нет, смотри, не через декоративный
который вот там
Омерли
Это процедурная макроса, это уже произвольный раст-код
который вот этот парсит
Ты же можешь на расте написать парсию
Вот ты его написал
Короче говоря, это такая вот вещь
Можете посмотреть
Если вам интересно, можно написать на Entend на расте
Backend на расте, все на расте
В общем, раст это язык будущего, верите
Точно совместно, они такие транскриптные
Расы врумаешь
Да-да, и пишешь на расте Frontend
Так
Давайте вернемся в реальность
У нас есть всего 3 типа процедурных макросов
Первый это Function-like макрос
Они выглядят абсолютно точно так же
как декоративные макросы
Это просто вот какая-то вещь, которая вызывается
в коде, но точно так же через восклицательный знак
В скобочках на этот раз уже
больше синтексиса
Мы с этим сейчас разберемся
Эти функциональные макросы вызываются
как и декоративные, но
гораздо более сильные
и мощные
Еще есть Derive-макросы
С ними вы сталкивались с библиотечными
Например, вы можете там написать Derive-клон
Копи, а здесь можно написать
Derive-макрос для произвольного своего трейта
например
Derive делает так, он принимает
структуру Unum или Union
Там будет произвольная
токен-стрим, то есть просто последовательно с токенов
Вы ее парсите
Вы можете сделать что угодно
И то, что вы делаете в конечном итоге
это добавляете
к своему коду что-то
То есть добавляете, например
имплементацию трейта к структурке
Еще есть всякие Derive-helper
Attributes, которые позволяют
добавить, например, макросу что-то указать
Вот это нужно чуть-чуть покастомизировать
Например, если вы будете
пользоваться Serda, то там есть
SerdaSkip
HelperAttribute
который позволяет скипнуть поле
и не сервизировать его
Например
Если вам интересно, можете посмотреть, погуглить
Есть Attribute-макросы
Это как раз то, что мы там
видели, например
Hello
Если вы пишете
Hello Clipping Needles Collect
Возможно, вы пользовались им Виттер Тулс
Это тоже просто custom attribute
Называется Hello
Да, и тесты тоже
это custom attribute
Они используют для того, чтобы как-то
трансформировать объект
Возможно, стереть даже
переписать все что угодно
Если вы будете внимательно
обратить внимание, что первые и третьи макросы
первые просто стирают
то, что находится на его месте
вставляют новый код
Attribute-макрос
позволяет что-то изменить
то есть изменить там произвольным
образом, а Zerif-макрос именно что-то
дописывает
Все это такие вот три типа
макроса есть
Они пишут всегда в специальных крейтах
отдельных
То есть если вы пишете для своей библиотеки
какой-то процедурный макрос, то вы для этого
создаете какой-то внутри крейт
Внутри пишете ли проц макро равняется true
И теперь раз знает, что вы используете
процедурные макросы внутри
Внутри будут находиться процедурные макросы
Ну и он
соответственно подключает для вас
эстидичную дополнительную библиотеку
которая называется проц макро
Давайте напишем простее еще
Проц макрос
Я в main.rc
ну в lib.rc точнее написал
вот такой вот код
То есть я импортировал проц макро
Потом я прописал, что я использую
проц макро токен стрим
Все такое токен стрим сейчас будем разбираться
Make Enswer это у меня какой-то процедурный
макрос, который на свое место
вставляет вот такую вот
строчку FN Enswer
которая возвращает 42
и соответственно
возвращает его в качестве
токен стрима
Ну если вы напишете в произвольном месте
где-нибудь в другом крейте Make Enswer
то в таком случае у вас
вставится FN Enswer
у 32
на его место
Сейчас то есть в Rust есть Eval
Нет Eval, а в Rust нет
потому что это все Compile Time
В Rust не Eval
Ну то есть для того чтобы
Rust код запустить
тебе нужно именно
создать этот код и скомпилировать этот код
А в Run Time у тебя это уже не получится
сделать с помощью макросов
Там еще должен быть
какой-то текст
У меня что-то подсказывает, что он
потерялся
Да
Нужно будет это тоже чинить
В общем как вы можете заметить процедурная макрос
у нас это не гигиенично
То есть они просто вставляют
какие-то произвольные вещи
в место где они вызываются
Это означает, что они
себя ведут таким образом, будто их
OutputStream просто вставляется
в место где они
вызываются собственно
Итак, давайте разбираться
в подробностях
Есть такая штука называется TokenStream
TokenStream это последовательность
Token3 деревья в токене
TokenStream представляет вектор
Token3, а Token3 это
одна из четырех ищей
Это либо идентификатор, либо пунктуация
либо литерал, либо группа
каких-то объектов
Это какой-то TokenStream, но внутри
скобочек
Внутри TokenStream, а может быть
группа и внутри еще один TokenStream
Как-то так
Группа означает, что у вас там фигурные
скобочки, круглые либо квадратные
скобочки, внутри еще один TokenStream
А мы можем назвать какие-нибудь скобочки?
Да
Там можно посмотреть
Сейчас увидим
В общем, как вы можете
зависеть, любой input к процедурным
макросу это сбалансированная, правильно, скобочная
последовательность
Все остальное в принципе не специфицировано
Вы можете писать
все что захотите
Нормально
Вот
Теперь появляется вопрос
Какой TokenStream от этой
строчки появился? То есть
запихнул вот эту строчку
в процедурный макрос, какой будет TokenStream?
Говори вслух
Первые два это indent
потом punctuation
так, с макросом
наверное тоже indent
потом
групп
и внутри группы
литерал
пунктуация
внутри литерал
пятерка
ну то есть это значение, я так понимаю, литерала
а, ну stop five times
да, надо макросу вскрыть, поэтому я забыл
потому что five times из себя представляет
макрос, который умножение
5 на 2 плюс 3 умножает
литерал умножить, пунктуация
2 из литерала, 2 плюс и 3
вот
как-то так
выглядит вроде бы несложно, да?
как-то парсится
ну давайте посмотрим в каком-то реальном процедурном макросе
вот мы написали какой-то
просьмакро, который принимает TokenStream
возвращает TokenStream
и ходит по базе
если он встречается с
идентификатором пунктуации или литералом
то выводит, ну иначе игнорирует просто
и выводит соответственно
просто пустой TokenStream
ну мы тестируем просто
что он нам придет на вход
например, такой вот код
выйдет вот такой вот
то есть мы вызываем на шофу
и внутрь подается на вход bar
равно 123 точка запятой
соответственно, bar это идент
равно это пунктуация
123 это литерал
и точка запятой это пунктуация
как-то так
так
ну группа
это соответственно другой TokenStream
еще один TokenStream
внутри скобочка
здесь у нас foo это идентификатор
если полностью
смотреть на эту строчку
которая внутри foo
у нас получится идентификатор foo
bar это будет идентификатор
bar
ну это вот слева и справа соответственно
2 и 2
и 2 плюс 2 это группа
которая состоит из фигурных скобочек
TokenStream
где TokenStream
в себе содержит 2
плюс и 2
ну как видите
мы еще даже не до конца
дошли, но уже видим, что
в Rust
процедурные макросы принимают
произвольный TokenStream
и его как-то трудновато парсить
давайте посмотрим
например
это то
что из себя представляют
структурки
у нас здесь были
идентификатор, пунктуация, элитерал
группа
а что эти структурки из себя представляют
это вот это
элитерал такая строка
спэн
в котором мы поговорим
идентификатор тоже строка
пунктуация
если вы пока не понимаете, что такое спэн
мы чуть-чуть позже поговорим
когда побольше посмотрим на макросы
чтобы нам было понятно, зачем он нужен
пока что вы можете представить, что его нет
потом у нас есть
еще спэйсинг
что же такое спэйсинг
по слайду сверху понятно
примеры того, что являются
элитералами, идентификаторами, пунктуацией
мы видим наличие
продельного символа
но с какой стороны
да, наличие символа
пунктуация, например, спэйсинг
использование спэйсинг здесь
спэйсинг выглядит вот так
если мы вызовем FUBART
в таком случае двоеточие
первая будет пунктуация, которая
двоеточие и loan
а вторая будет двоеточие и joint
ну это будет
два отдельных токена в токен стриме
и соответственно
у двух этих двоеточий будет
идент и идент, только первый будет loan, а второй будет joint
что, показай, где первый, где второй
а чем у тебя случается loan и joint?
что-то непонятно
это для того, чтобы показать относительно друг друга
как они располагаются
что не один и один
а, это что, второй токен?
это чтобы ты знал
вот эти вот вместе
то есть, что второй токен присоединяется к предыдущему
да, что это прям часть
FUBART, например, это два двоеточия
означает, что ты хочешь
модулинг что-то достать
и тебе, наверное, хочется знать, что это часть модуля
два двоеточия этих
ты тоже хочешь знать эту информацию
с точки зрения семантики, а не просто подряд
двоеточие, двоеточие и все
конечно же, парсит Rust code
вот такой вот вообще неудобно
слово совсем
у нас есть create-sync
я надеюсь, что я ничего не пропустил тут
тут звучит пока что так, что я что-то пропустил
ладно, давайте перейдем пока что к сину
син это такой create
тоже, естественно, какой-то
сторонний Rust-crate, который принимает
на вход токен stream
ну, там есть разные функции
он огромный вообще син
предназначен для того, чтобы
парсить именно Rust-code
просто самый-самый частый use-case
derived-macros
это когда парсить именно Rust-code
и соответственно он хочется как-то упростить
себе жизнь. Вот умные люди придумали так
они сделали
create, который предназначен для того
чтобы парсить токен стримы
с условием, что токен stream это именно
Rust-code
то есть решает эту специфическую задачу
ну, давайте напишем какой-то наш
первый derived-macros
пусть мы хотим
написать derived-macros
ну, вы помните, что это такое
у нас есть какой-то wrapper вокруг int
это называется helper-attribute
и здесь я указал, что я хочу
чтобы мой дерев
деревался именно к внутреннему вот этому вот
атрибуту
к ссылке вот на этот атрибут
то есть, если бы у меня здесь
было еще 10 полей, то он бы все равно
сделал дерев как ссылку
на self-inner
как-то так
ну, давайте напишем
как видите, у нас теперь не просто
proc-macro, а proc-macro-derived
мы указываем для какого трейта
дерев и указываем какие атрибуты
мы хотим
в данном случае атрибют мы хотим дерев
чтобы назывался дополнительный
helper-attribute
вот у нас input это
parse-macro-input
то есть мы parse-им наш input
как
sin parse-macro-input
это такая специальная функция, которая предназначена для того
чтобы парсить именно Rust-код
когда нам на вход подается
токен-стрим, мы же ничего про него не знаем
но если мы предполагаем, что это Rust-код
в таком случае нам
как видите, удобно воспользоваться крейтом sin
и воспользоваться таким вот macros-ом
который за нас распарсит Rust-код
и после этого нам будет удобно
все делать
насколько удобно
например, мы дальше ожидаем
что нам input-data это именно структурка
то есть sin data-struct
если у нас
структура это действительно структура
то все хорошо, иначе мы говорим
что у нас только структурки поддерживаются
потому что у нас может быть на входе union
у нас может быть на входе enum
и в этой строчке мы проверяем
что нам действительно на вход структуры подали
потом есть named-fields
мы хотим получить сами
название полей
структуры
и как вы помните
у нас есть структуру
в которой как tuple обозначается
то есть в скобочках мы пишем просто
типа через запятую, дальше через 0.1.2
обращаемся
а есть именно с именованными полями
здесь мы ожидаем структурку с именованными полями
если это так, то
мы достаем эти поля
иначе мы говорим, что только структуры
с именованными полями
поддерживаются
понятно ли
что здесь произошло?
да, может быть например структурка
вот давай здесь
struct inwrapper в скобочках E32
как tuple
как tuple на пену с домашки
было объявлено
там имена полей нет
так
дальше дерев field
мы берем named-fields
если таба как-то не хватает
куда-то он потерялся
у нас есть named-fields
мы превращаем их в Intuiter
дальше мы фильтруем
мы проходимся по полям
и ищем именно то поле
которое у нас содержит атрибут дерев
вот такая вот очень хитрая
как видите у нас у каждого поля
есть field-atters
и за нас Син все распарсил
сказал нам где
у какого поля атрибуты
field-atters-iter
мы интервируемся по атрибутам конкретного
поля
ищем среди них дерев
если находим, то все хорошо
как-то так
если мы не нашли
то в таком случае мы скажем, что
поля с деревом нет нигде
фильтр нам возвращает
итератор на то, что
возвращает все поля
в общем фильтр возвращает
все элементы
которые подчиняются какому-то условию
в нашу условию
да, мы просто берем первые из них
берем первые, которые содержат
в себе атрибут дерев
ну и дальше мы
давайте просто отформатируем
сделаем такую
тиранду
напишем импл-опс-дереф
для нашей структурки
внутри фигурной скобочки
импл-идентифайер
название нашего структурки
в импуте
у нас дерев-файл
type-token-stream
то есть мы вставляем
тип нашего поля
который содержит
наш дерев-атрибут
и соответственно его имя тоже
на место ссылочки на салфе
что делает формат?
формат форматирует
просто строчку
вставляет на место фигурных скобочек
одинарных, как здесь
строчки
в соответствующем порядке
это означает, да
чтобы
видимо многострочные были, да?
да
соответственно мы это парсим
чтобы приобретить именно в токен-стрим
и анрэп
естественно это не учитывает большинство юзкейсов
но тем не менее уже делает дерев
для нашей структурки
для которой мы захотели
то есть оно действительно прочитает нашу структурку
оно найдет первое поле
у которого есть дерев
и напишет импл
импл, где дерев
от этого поля
как-то так
это конечно же не идеально
у нас например могут быть структуры
у которых есть дженерики
естественно с ними нужно по-особенному работать
у нас могут быть дженерики
у которых еще к тому же есть какие-то
ограничения на Т
в общем вы уже представляете
какая это боль писать процедурный макрос
на самом деле конечно формат
это не лучший способ
вернуть импл
у нас есть еще такой специальный крейд
называется quote
он предназначен для того чтобы
вот так вот красивенько просто через
решетку вставлять
примерно из нашего текущего сколпта
то есть он по сути делает то же самое
что формат, но красивый
и более того, как видите даже
у нас есть джентльмены
и у нас есть джентльмены
красивый и более того, как видите даже
минтет и слотеха
справился подсветить весь синтаксис
то есть вы действительно в IDE
будете видеть такой-то внутри quote
адекватный синтаксис и это достаточно удобно
он вам понадобится в домашке
потому что
достаточно удобен
понятно зачем нужен quote
так мы дошли
куда понять span
все это время мы как-то его игнорировали
но span это такая штука
которая нужна для того чтобы привязать
то что у нас происходит в macros
и к тому что у нас
находится на стороне вызывающего quote
есть два use case
во-первых
давайте посмотрим
на наш текущий intriper
что если нам дали два дерева
а мы хотим же только к одному делать
ссылка self на поле
в общем-то если мы
оставим macros таким какой у нас сейчас есть
то в таком случае он сделает ошибку
то есть возникнет ошибка
внутри macros
в текущем macros нет потому что он просто берет
первое поле дерев
если мы делали проверку на то
что в такое поле только одно и выдавали панику
то в таком случае мы бы
компилятор нам говорил что у нас
есть паника внутри macros
в общем-то это плохо
а мы хотим говорить пользователю что у нас macros паниковал
и что вот у тебя тут ошибка
поправь пожалуйста
в конкретном данном случае мы хотим сделать так чтобы пользователь
явно увидел что у него два дерева
давайте мы чуть-чуть поменяем наш код
вот собственно это то зачем нам нужно span
давайте сделаем примерно так
если у нас дерев fills
то мы вывели наши поля
ну до того как мы начали выбирать первое поле
мы получаем наши дерев fills
и давайте проверим что
дна действительно меньше либо равна
равна точнее единицы
если она равна единице
ну больше единицы
то в таком случае будем выдавать ошибку
как видите мы делаем так
мы во-первых пишем ошибку
что мы нашли больше либо равно
двух полей из дерев
во-вторых
мы с помощью span
то есть мы берем дерев fill
ноль span
и вот как видите quote span
это есть такой macros который позволяет нам вернуть
ну quote он же понятное дело
возвращает токен stream
на самом деле то есть error представляет в себе токен stream
когда мы пишем error extent
то мы к текущему токен стриму
который в себе представляет вот этот macros
compile error
дописываем еще один
токен стрим
и дописываем его вот с таким вот span
ну со span вот
поле вот этого вот нулевого
дерев field
и мы говорим что span
это по сути просто кусочек
исходного кода
в исходном user коде
то есть по сути мы говорим
что у нас вот здесь вот ошибка
вот в этом вот span
в этом кусочке кода пользователя
и соответственно
во втором тоже
у нас возникает два вопроса
во-первых чуть-чуть более конкретно
как span работает, во-вторых что такое compile error
и что произошло
что касается compile error
для начала скажу что
когда вы делаете quote
потом вы делаете несколько раз
error extent и возвращаете
error into
то вы пишете в качестве
вывода своего макроса несколько строчек
с compile error
так
это во-первых, во-вторых
если компилятор раста находится
где-то строчку с compile error
им приходится эту строчку компилировать
он выводит ошибку
он говорит что здесь происходит compile error
соответственно мы записали в поток пользователя
то есть в код пользователя
три строчки с compile error
и он получил свою ошибку в
правильном месте с помощью span
вот так вот
и эти макросы уже вскрылись еще раз
да, эти макросы
ну просто смотрите, раст код
как работает
как раз вот это вот я хотел сказать
как код растовский работает
он работает после того как у вас построилось абстрактное синтетическое дерево
если вы ходили на курс компиляторов
по шахтямову, вы наверное не ходили на
компилятор по шахтямову
если вдруг так происходило, то вы наверное знаете
что такое AST
ну AST на себе такие примерно вещи представляет
например там у вас
написано 2 плюс 3
как парчится 2 плюс 3 в абстрактном синтетическом дереве
у вас там получается
бинарная операция плюс
левая операнта это 2
и правая операнта это 3
у вас получается такое дерево
если у вас там еще какие-то скобчики
например 2 плюс 3
и умножить на f от x
в таком случае там получается
раскрытие что типа бинарная операция
бинарная операция 2
плюс
на 2, потом еще одна бинарная операция
левая операнта 3
ну и вы поняли как это работает
вот когда компилятор
это построил, на самом деле
именно после того как он это построил, он вызывает
макроса
он просто запоминает то, что в этом месте должен быть
другой токен 3, где макрос
после этого он вызывает макрос
и вставляет его в токен 3
то есть где он там был
в абстрактном синтетическом дереве
он просто прикручивает уже
вывод макроса
то есть он работает уже на уровне синтаксиса
и соответственно именно по той причине
что мы с самого начала попарчили
код пользователя, а потом вызываем макросы
у нас получается таким образом
что
что у нас
код как
в Define
не валится, что у нас 2 плюс 3
умноженное на 5, потому что у нас
заранее сказано, что
умножение
левая часть этого
нашего макроса, а правая
часть это пятерка, соответственно вы потом подвешиваете
и все нормально работает
какие-то такие дела
это жесть
уметь
подсказывать
конечно большая часть людей
так не делает
в каких-то самых популярных
крейтах
написаны такие вот крутые штуки
это все равно
это просто реально сложная штука
там проработать все кейсы, чтобы пользователь
получил
правильную ошибку
процедурные макросы
кстати как компилируются
раз с самого начала берет
компилирует ваш крейт
с процедурными макросами в такую динамическую библиотеку
на линуксе SO
а потом
после этого он
посылает токен стрим
в динамическую библиотеку, то есть вызывает там функцию
посылает в нее токен 3, получает свой токен 3
и вставляет в код
как-то так
если более конкретным
быть, то наверное лучше посмотреть
попросить у меня
и скину ссылку на толк
одного человека из JetBrains
который занимается
их IDE
для раста, я имею ввиду плагина
он рассказывал как раз про то, как оно компилируется
компайл-эррор
мы вот так вот сделали
таким образом, что если компайл-эррор
компилируется, в одном случае у нас ошибка
и мы как раз записали
к пользователю то, что у нас компайл-эррор
соответственно он получает свою ошибку
итак, спэны
спэны это такое
когда мы пишем в токен 3
мы конечно хоть и явно писали
строчку с компайл-тайм
компайл-эррор и внутри
код, на самом деле код конечно
это преобразует в токен 3
и в токен 3, как мы уже видели
там есть структурки, в которых есть спэны
а спэн бывает разным
он бывает кол-сайт
это означает, что
спэн работает точно так же
как если бы он
это означает, что этот
идентификатор будет рисовываться так, будто
он уже находился в пользовательском коде
то есть пользователь будет его видеть
и все такое
ну и вы будете видеть соответствующий идентификатор
который был уже в коде пользователя
потом есть
mixed-сайт, это то же самое, что в декларативных
макросах, то есть часть видим, часть не видим
в зависимости от того, какой идентификатор
есть dev-сайт
это то, что этот спэн
будет не виден со стороны
кода пользователя
и в общем-то
полезная штука иногда бывает
она только внадль
на данный момент
понятно, что такое
спэн?
мы просто
идентификатором присваиваем спэн, а спэн
говорит, как нам рисовывать
то есть как раз то, как у нас работает гигиен
в расти
что-то похоже на
чуть-чуть похоже на дальнего роста
из плюсов слуш-локейшн
но он только похож
откуда, не знаю
слуш-локейшн
это прикольный класс плюсов и плюсов
который позволяет
сохранить какую-то инфу
о каком-то месте в коде, типа
ими файлы, ими функции, ими строки
и столбец
получается
и вот эту инфу передавать нам походу
ну там у нас конечно не столбец
не строка, а у нас именно к идентификатору что-то
привешивается
там по ошибке
конфигурация
смотри, у нас прям строчечка
видишь, он показывает, типа, потому что у нас спэн начинается
в этом атрибуте, а мы как раз к атрибуту
спэн атрибуты, это приветствие
ну как бы от спэна здесь у нас
только, собственно
что с этими вертикальными гардинами
какими вертикальными, сейчас еще раз
ну вот у нас тут 3 сегмента
с вертикальными чертичками
вот это все как раз
что касается спэна
да, ну вообще
вот эта вот первая ошибка
вот эта вот уже касается спэна
вторая и третья, вот мы как раз писали, видишь
draftField 0.span
вот мы взяли спэн и указали, что здесь вот
first draftField
вот
можно, кстати, наверное, сделать
даже адекватнее
но я уже искренне не эксперт
процедурных макросов, чтобы такое делать
но, наверное, можно сделать прям как компилятор
error, ну, то есть, тоже такую же ошибку
а после этого там note, the first
то есть, именно чтобы не error, была note
и оно было нормально
а можно делать вот такие же
хитрые
и хитрую графику в консоли
когда он...
да, когда он
с borrowing объясняет, где они там
очередной раз ошибся, и такой
о, фу
тут borrow, тут borrow, хитрует
и вот иди отсюда
так, ну, как-то так
в общем, спэна
вот, такая вот штука
работает точно так же, как будто
она была объявлена именно
в коде пользователя
то есть, lightFoo равняется foo
будет затенять наш
будет foo в коде пользователя
вот
callSite это
дефолтное значение
для спэна у процедурных макросов
то есть, процедурные макросы напоминают
совершенно не гигиенично
почему код spend принимает
какой-то матч?
ну, ты же хочешь сказать
какой spend чему?
типа, ну, просто так красиво
а как ты хотел?
типа, в скобочках написать
то есть, получается, что, ну да
код spend там свой парчер вот этих матчей
да, там код spend, там
именно парчер
просто пока я
видел все эти примеры
там только одна стрельба
а сейчас, почему спэны могут быть разными?
ну да, ну там
вот этот матч, почему несколько матча?
смотри, у нас вот это три варианта
еще у нас от полей там спэн
давай покажу там
наверное про это речь
вот видишь, где спэны
они влитраловывают в идентификаторах мактуации
так
ну, мы, кстати, подходим уже к концу
нашей лекции, несмотря на то, что у нас
целых 40 минут
130 слайдов
очень быстро пошли
так, есть ли
процедурное макросе у прочих?
блин, ну крутая вещь
ну да, процедурное макросе
это круто, но писать их сложно
подумайте несколько раз про чем это делать
потому что их нужно будет поддерживать
все такое
нужно поддерживать, ну не экспортируем их
или нормально
поддерживать
так не работает
я написал, оно работает
хорошо
просто
какой-то трейд-оп
что мне лучше
создать какой-то красивый макрос
ну, словно я пишу библиотепу
для ботов
для телеграмм
и так далее
у меня есть два выбора
либо я создаю макрос
который мне создает объект ботас
с которым я уже интерактирую
либо я создаю фабрику
ну это сильно зависит от ситуации
какой у тебя бот
если у тебя фабрика ботов
ну если такой вариант есть
то скорее всего тебе лучше так и написать
чем макрос, макрос сложнее писать
ну если тебе нужна прям какая-то внутри
кастомизация сильно
например, у меня на работе
мы с помощью дирайвов
ну это понятно все плюс-плюс
но мы с помощью дирайвов объявляем
gRPC сервер, у нас там тупая подстановка
ну просто потому что gRPC сервер
нам нужно много
они достаточно у нас глупо выглядят
поэтому у нас таким образом все устроено
если тебе нужна какая-то кастомизация
например, gRPC сервер
что он возвращает
каким-то образом
что
что сохраняет
ну в общем
в широком смысле кастомизации
то возможно процедурный макрос
будет гораздо лучше
даже невозможно точно
а если у тебя боты такие достаточно одинаковые
то фабрика лучше
ну то есть выбирай всегда самый простой инструмент
который тебе подходит
так, я еще хотел сказать про серд немножко
вообще вся эта штука, все эти дирайвы
они
появились не в последнюю очередь
потому что в расте есть такая библиотека
собственно серд это такая
state of the art библиотека
она крутейшая сейчас
и
настолько крутая, что в принципе можно сказать
что это лучшее в мире решение
вы там можете с помощью дирайв макросов
очень-очень быстро кастомизировать
то как у вас
это очень удобно и очень
лаконично, многословно скажем так
то как у вас будет
децерилизоваться и децерилизоваться код
я вам очень советую посмотреть на эту библиотеку
чтобы понять
как же все-таки выглядит процедурная макрос
какая у них красота
и в общем
как-то приисполнится
и порадоваться за то, что в расте есть такая прекрасная библиотека
которая наверное сейчас самая лучшая в мире
в смысле
серилизация и децерилизация и не в последнюю очередь
потому что есть механизм процедурных макросов
который позволяет
кастомизировать такие штуки
давайте такую
небольшую буквально заминочную часть лекции
посмотрим
есть макросы в стандартной библиотеке
некоторые
во-первых нам нужно поговорить
о conditional compilation
в общем-то бывает такое
что нам нужно что-то компилировать
одним образом под юнию, с другим образом под виндос
в общем
кфг как вы уже заметили
это какой-то атрибутный макрос
вот он
смотрит в компайл тайме на наши
фичи, которые мы объявили
собственно
уникс, когда мы пишем
то мы имеем ввиду, что тарги то сравняются уникс
то что делает кфг
это по сути просто удаляет
функцию
если
не выполнять условия внутри
ну и в общем-то какой недостаток
у этого всего дела есть
у conditional compilation raster
например
если у вас
в общем если вы разрабатываете
например под линуксом
и в том числе у вас есть код под виндос
то вы не сможете найти ошибку
в коде под виндос до того как вы
скомпилируете этот код
потому что буквально макросы вырезают
кусок кода
и соответственно даже если у вас
будет синтактические ошибки
раст на вас злиться не будет
потому что он брен
я это все вырезал
а нет
синтактические ошибки
словят, а какие-то там
еще нет
которые идут уже после макросов
я сам не припомню в каком порядке
получается этот макрос
вырубает из кода
какую-то функцию
примерно как работает Define
только видишь гораздо красивее и лучше
т.е. кфг, виндос,
кфг, уникс, все красиво
два слайда одинаковых
получилось
то, что он точно делает
какие-то конфигурационные флаги
какие-то Boolean условия
на них проверяют
более того, вы можете его вызывать
не только как атрибут макрос
но и как функционал-лайк макрос
например, let my directory
у нас есть пример
если конфиг это виндос
как вы понимаете, это в компайл тайме
превратится в true либо false
соответственно здесь будет
специфичная для винды директория
и здесь вы должны гарантировать
то, что у вас обе ветки компилируются
все с ними хорошо
потому что они действительно
обе будут компилироваться
это удобно тогда, когда
нужно какие-то константы
прописать
такой кфг удобен
такие паттерны вы тоже видели в домашке
у нас кфг-тест
тест это тоже какое-то
макрос
тест это тоже какое-то
условие
во время компиляции программы
тест это атрибут, который
собственно
превращает нашу функцию в тест
добавляет там трамплин, который
выводит в конце теста
что он успешно идет
либо если тест идет слишком долго
работали больше 60 секунд
возможно в домашке увидели когда-нибудь
если у вас слишком долго
умудрялась работать программу
и кфг-тест будет его вырезать
либо добавлять модуль в данном случае
это из главы модули
нас супер означает родителей
то есть использует все из корневого модуля
если учесть, что
корневой модуль сразу же после теста
ну как вы понимаете
тесты никогда не будут
в бинарнике
в таком случае
потому что у вас тест никогда не работает
до тех пор, пока не напишете кфг-тест
у вас просто не включена нужная фича
ух ты
это я забыл
поставить обратный слэш
на это
но не подчеркиваю
не собираюсь
подчеркивать
но нижнее подчеркивание
тех пожаловаться
таким образом
очень необычным
в общем
есть такие еще макросы nth и option nth
nth
он проверяет во время компайл тайма
то, что у вас есть в environmental variables
и option nth
соответственно делает то же самое, но только если nth
он прям паникует во время компиляции
то option nth возвращает option
была ли такая опция во время компиляции
вот
ну как видите
можно pf вывести
который был во время компиляции
примерно таким образом
кстати
вот здесь вот плохо, а вот здесь вот хорошо
посмотрите на то
как оно должно быть
как-то у меня иногда
бывают проблемы
даже насправе на то, что пересматриваю слайды
все равно как-то странно
еще есть stringify
даже хотелось бы отдаленно сказать
eval, но на самом деле конечно же
совсем не eval
он просто превращает то, что внутри написано
в строчку
да, да
просто
превращает то, что ему выдали
в строчку
например, можно написать
типа аргумента
с помощью stringify
с чем это может понравиться?
просто кобычки
в данном случае
ты можешь захотеть кобычки
а так вообще stringify
может быть удобно
если тебе хочется
например, удобнее написать внутри типа аргумента
в таком случае
то есть это такая
useful вещь, когда вы уже
метапрограммированием каким-то занимаетесь
тогда stringify будет полезен
в таком примере искусственном
конечно нет
еще есть такие include string
такие include string и include bytes
как я говорил
например, ставить картиночку
там include bytes
или, например, ставить какой-то текст
словарик в программу
прям исходный текст
просто делать include string
то, что он делает
он в качестве правой части
заменяет это на здоровенную строку
которая себе представляет
то, что находится в Spanish In
во время компиляции
если файл большой
большой бинарник
нужно думать, прежде чем
стволить такие файлы
это бывает полезно
иногда бывает же, чтобы удобнее было клиенту
просто передать бинарник
без того, чтобы передавать
все папки
еще есть такие атрибуты разные
hello, warn, deny, forbid
с hello вы уже знакомы
как я уже говорил
в клипе на NeedlessCollect
можно сделать hello
в таком случае у вас разрешится
использование
в общем, разрешится этот warning
в клипе
можно всякие deprecation
ноуты сделать
то есть сказать, что эта функция
будет скоро deprecated
в скобочках
эта функция будет скоро
используется вместо это
тогда, когда человек будет компилировать свой код
он получит warning
в котором будет это написано
это бывает удобно
особенно удобно, если вы разрабатываете какие-то библиотики
это паника
это ошибка
которую раз
не может обработать
не перед каждым молоком
а после молока
он смотрит на NLPT
насколько я помню
в плюсах new делает
exception
можно в нескольких вариантах использовать
по дефолту бросает
по дефолту бросает
в расе
тоже нужно, кстати
настроить
там можно сделать так, чтобы
паника получает
unwinding
она раскручивается
можно сделать abort
если происходит паника
вместо stack unwinding происходит abort
это даже не то, что удобно
а жизненно необходимо
когда вы с новой стедей разрабатываете
и там вы панику не обрабатываете
просто программу ломаете
новой стедей это все еще зло или нет?
в каком смысле зло?
это же не зло
я просто говорил, что есть люди, которые пишут
в качестве фичи новой стедей
но новой стедей это не одитеф фича
если ты добавляешь стедей
ты добавляешь стандартную библиотеку
а если ты добавляешь новой стедей
у тебя что-то удаляется
а карга предполагает, что у тебя добавляется
только с каждой фичой
то есть отдельно получается фича карга
и отдельно вот эта фича?
новой стедей это просто какой-то макрос
который говорит, что не нужно мне в прелюд
писать стд
colt это всякие оптимизации
если вы знаете, что эта функция никогда не вызывается
то вы можете сказать компилятору
забей на эту функцию
и оптимизируйте соответствующим образом
мы еще будем смотреть
на всякие вещи, надеюсь
должна была быть всякая
целая лекция про разоптимизация
но мы не успеем
в стандартной библиотеке есть всякие
ансейв блоки, где вы пишете
что вот
есть такой вот инвариант
вот в этом бронче
есть такой инвариант
это ансейв фигня
он смотрит на нее и понимает
вот мне человек написал с блоком ансейв
что в этом бронче выполняется какой-то инвариант
значит я могу использовать это для своих оптимизаций
и соответственно
код становится еще быстрее
можно в подсказке
deprecated
must use например
как это в resalte сделано
опять постоянно забываю
как называется это в плюсах
no discard
плюсах наоборот
плюсах наоборот
ты разрешаешь не использовать
здесь тоже самое абсолютно
просто название другое
вот это другое
если ты повесишь эту ерунду
то если пользователь не воспользуется
возвращаемым значением функции
то в таком случае он возлится
потому что он скажет прямым текстом
помечена эта функция must use
используй пожалуйста значение этой функции
скорее всего это не просто так
ну и inline если там можно
inline точно так же как и в плюсах
ключевое слово
просто означает подсказку
для компилятора
не прям сделай это
ну ладно будем считать что я не разбираюсь так сильно в плюсах
и не будем говорить точно
смотрите
и при этом у нас осталось 20 пакет
ну вот мы успели
изучить что такое closures
что такое декларативная макроса, процедурная
и даже посмотрели что есть в стандартной библиотеке
по макросу
кажется это все что мы хотели изучить
на этой лекции и мы исправились
130 слайдов за это время
кажется нам 150 нужно
что хочется еще раз
ну что
есть какие-нибудь вопросы
значит никаких вопросов нет
тогда всем спасибо всем пока
