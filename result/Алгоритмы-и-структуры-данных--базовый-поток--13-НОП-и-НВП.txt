мы с вами поговорили про все я думаю вы поняли что вас ожидает поверьте бояться этого не нужно чем
больше будете бояться тем хуже будет на самом этом итоговом контесте или контроль вы просто должны
прийти и показать что-что знаете я надеюсь что-то да вы знаете вот итоговый контест всегда на
зачетной неделе зачетная неделя начинается 15 декабря во время лекции обычно но там в
зависимости от того как у нас получится с аудиториями нам нужна аудитория на 3 часа вам все сообщат вы
увидите я подозреваю что даже уже написано это у вас в расписание сессии есть у меня такое
ладно давайте успокоились и теперь начинаем говорить про наибольший общий подпоследователь
и наибольший возрастающий подпоследователь что это такое поставим задачу поймем с этим жить
первое с чем мы будем работать это наибольшая общая подпоследовательность но прежде чем к
нему перейти я напомню что у нас есть динамическое программирование есть критерии применимости
динамического программирования критерии следующие оптимальная подструктура перекрывающий под задачу
помните такое было или не помните все читают такие так вроде было но не помнят на всякий
случай оптимальность на тему того что у вас действительности решение является оптимальным
и правильным перекрывающий под задачу вы используете результат который получили еще на предыдущих
шагах вот это про критерии применимость задача наибольшей общей подпоследовательности выглядит
достаточно просто у нас есть две последовательности с 1 и с 2 это могут чисто строки все что угодно
спецсимвол и требуется найти самую длинную общую подпоследовательность что такое
подпоследовательность но подпоследовательность это тоже самое что вы взяли какую-то строчку
выкинули из неё часть символов. Вот это будет подпоследовательностью. И оставили их ровно в том же порядке.
Там не знаю, а...
Кто не знает, почему я такие буквки выбрал?
Нет среди вас биологов. А? Да. Ладно, хорошо, есть среди вас биологов.
Ну а... от СТГ, да. Должно же быть познавательной ещё.
Когда у нас есть некоторая последовательность, мы можем сказать, что АТТ это подпоследовательность.
Я могу сказать, что АТГ это подпоследовательность и так далее.
Ну как бы просто убираю некоторые букв и получаю наш подпоследователь.
Ничего страшного здесь нет. Но нужно понять, как решать такую вообще штуку.
Представим, что у меня есть строка первая какая-нибудь, не знаю.
Вот. У меня есть такая строка и есть...
Вот такая строка. Какая наибольшая подпоследовательность?
Ну, можно сказать, что это ААА. Вот это, вот это и вот это, а здесь вот эти буквы.
Согласны? То есть наибольшая общая подпоследовательность, это когда я возьму подпоследовательность отсюда и отсюда, и она будет и там и там.
Понятно? То есть мы должны выбрать такие вот символы.
Вот теорема. Теорема об оптимальной структуре, наибольшей общей подпоследовательности.
Она звучит следующим образом. Пусть у нас есть две последовательности, х и у.
Ну вот х там состоит из х1 и до хм, у состоит из у1 до ум.
Заметьте, х и у не обязательно одинаковой длины.
Вот. А z это наибольшая общая их подпоследовательность.
И нужно сказать, как выглядит z. И здесь в действительности от z мы можем сказать следующее.
Что если у нас последние х и у равны, то в этом случае они равны последнему символу z.
И тогда, если я уберу этот символ и там из х, из у, из z, то у меня zk-1 это как раз все символы без катова.
То есть у меня вот z есть, он там z1 и так далее, zk-1, а вот zk-1 это z1 и так далее zk-1.
Вот. Тогда мы говорим, что zk-1 это наибольшая общая подпоследовательность от х, а что у меня там, м-1, и у, н-1.
Вот. То есть мы должны сказать, что это вот выглядит в таком виде. Что это нам позволяет?
Как вы думаете? Видите, что мы свели задачу к предыдущему вопросу.
Когда у меня было z до k, я свел к тому, что у меня k-1 уже символ. И здесь эти последовательности уменьшил.
То есть я взял и уменьшил, а это означает вот ту самую динамику, которую я набрал.
Это происходит только в том случае, когда xm равно yn.
Когда два последних символов, x и y, они вот такие, они равны. И они равны z.
Вот. Это первое утверждение этой теоремы. Второе утверждение этой теоремы, что если не равны между собой, тогда z это то же самое,
ну если x и y не равны последние символы, тогда это то же самое, что я бы выкинул либо из x, либо из y последний символ.
Но это, я думаю, тоже понятно. Мы придем заказать.
У этого на всякий случай. Окей? Могу дальше идти?
Чё-то как-то большинство сгрустнуло.
Где минус?
Да. LCS это на всякий случай npo. Отрицательным оно быть не могло.
Окей. Поехали. Давайте доказывать с вами все, что у нас есть.
Первый случай, когда у нас равны символы xm, yn.
Первое. Заметьте, у нас тогда в этом случае мы говорим, что zkt равно ym и xm.
И zk-1 это наибольший общий подпоследователь. Мы будем разбирать эти два факта в отдельности.
Первый факт о том, что у нас zkt равно xm равно ym.
Смотрите. Мы идем от противного. Если бы у нас выполнялось, что они были неравны,
то есть вот этот последний z, который у нас есть, он бы был не равен а xm,
тогда я бы к z мог бы добавить тот самый последний символ.
Ну, давайте это на примерах показывать. Я думаю, вам так будет легче.
Доказать теорему.
А, вот это дальше будет вопрос.
Эта теорема позволяет нам сделать следующее. Давайте еще раз вернемся на нее.
Видишь, что мы уменьшаем x и y?
И z заодно.
В то же время мы можем уменьшать x и y по отдельности.
Согласен, что когда я уменьшаю x и y, я уменьшаю саму задачу, размерную задачу.
Да.
Мне нужно понять, из чего состоит z и как я могу взять и использовать это в динамике.
В динамике мне что нужно? Оптимальность и перекрывающийся подзадачи.
Перекрывающийся подзадачи здесь есть за счет того, что у нас z является nop,
ну zk-1 или z, она является nop от последовательств поменьше.
Правильно?
Оптимальность – это то, что мы используем их в результате, получим то, что нам нужно.
Да.
Еще раз, об оптимальности под структуры z.
Я говорю, что z, ну как бы хорошо.
Я говорю, что z – это наибольшая общая под последовательность x и y.
Да.
Я говорю, вот у меня есть случай xm равно yn.
Что я могу сказать о других вещах?
Могу я сказать о состоянии z в этот момент что-то?
Что?
Почему?
Вот смотри, нам нужно это по-хорошему доказать.
О том, как выглядит z.
Почему это нужно? Представь следующее – a, c, t, t, не знаю, и g, c, t, t.
Вот я нахожусь вот тут, вот буду на последнем символе.
Вот тут смотри.
Друзья, давайте это, хлопнемся.
Пожалуйста.
Очень плохо так говорить.
Ладно, а вот я нахожусь вот здесь вот.
Вот у меня первая строчка, вот вторая.
Вот это должно быть в моей наибольшей общей под последовательности.
Да?
С одной стороны.
С другой стороны.
Почему я так уверен?
Но просто если я скажу, что вот эти символы у меня есть, то согласен,
что я могу найти наибольшую общую под последовательность от вот этого кусочка
и добавить к ним букву t в конце.
Чтобы использовать ее для того, чтобы динамически это делать.
Потому что вот у меня меньшая под задачу уже.
А вот.
Еще есть вопросы?
Нет.
Значит, давайте здесь еще раз.
Мы идем от обратного.
Говорим, что пусть у меня последний символ z-каты не равен xm.
Если он не равен xm, то он не равен и ym.
Окей, тогда давайте я просто в свою z, которая у меня уже есть,
добавлю в конец еще один вот этот символ.
Он же в конце последовательности идет?
В конце.
Если я добавлю этот символ, у меня будет общая под последовательность?
Будет.
Только она стала на 1 больше.
То есть в k у меня было k элементов,
а здесь я добавил еще последний элемент, вот этот xm и yn,
и получил k плюс 1 элемент.
А значит, у меня есть противоречие с чем?
С тем, что z это наибольшая общая под последовательность.
Она не наибольшая.
Вот есть из k плюс 1 элемент.
Понятно логика?
Вот, благодаря этому мы говорим, что да,
в действительности, если последние символы равны между собой,
то мы обязаны добавлять в свое z.
Это раз.
Второе.
Мы покажем, что zk минус 1 ро равно наибольшей общей под последовательностью.
То есть я утверждаю следующее, что если я уберу последний символ z-каты,
то это то же самое, что у меня будет вот здесь вот zk минус 1,
то это не больше общей под последовательности, вот этого вот чуда.
Как это сделать?
Все достаточно просто, опять же, от противного.
Пусть это не так, тогда существует какая-то другая большая общая под последовательность,
большая, у которой длина больше, чем k минус 1 элементик.
Потому что zk минус 1, а k минус 1 элементик.
А добавим к этому w вот ту самую последнюю z-кату.
Мы же знаем, что она у нас в конце стоит.
Знаем.
Добавляем ее.
Тогда мы получаем, что в нашей общей под последовательности будет больше, чем k элементов.
А если там больше, чем k элементов, то z никогда не была наибольшей общей под последовательностью.
То есть мы просто играем тут словами от противного.
Понятно?
Важно получить вот это противоречие.
Таким образом мы понимаем, как у нас выглядит внутри z.
Пока что понимаем.
Но нам нужно понять, а что делать, если символы в конце не одинаковые?
Грубо говоря, если у нас одинаковые символы, то я могу перейти из этой строчки и сделать плюс один к количеству символов.
Согласны?
Ну вот из этого кусочка.
Правильно?
Потому что вот это будет как раз там.
xn-1.
А это ym-1.
Это yn-1.
А вот это вот здесь вот число будет как раз zk-1.
Мы это сделали благодаря вот этому вот переходу.
Осталось понять, а если символы разные, что делать?
Тогда в этом случае нам приходят вот те 2 и 3 свойства, которые были написаны в теореме.
О том, что если у нас xm не равно yn, то из того, что zk, то есть последний элемент, не равен xm, следует, что z, а наибольшая общая подпоследность xm-1y.
То есть я могу просто взять и выкинуть вот отсюда этот символ.
Вот представим, что тут у меня была бы буква а, не знаю.
То есть вот этого перехода бы уже не было.
То есть я говорю о том, что я могу взять и сказать, ну да, у меня есть вот этот символ, но я не буду рассматривать вот этот символ.
То есть я могу вот таким вот образом обрубить это все.
И вот здесь уже находить значение.
И вот из этого значения прийти сюда, и оно будет ровно таким же.
Почему я могу таким образом сделать?
Я могу это сделать только по одной причине, на самом деле.
Потому что, опять же, мы будем исходить из некоторых предположений от обратного.
То есть пусть у меня zk не равно xm.
Ну, это мы знаем по условию.
И z, то z, наибольшая общая подпоследовательность.
Пусть существует их общая подпоследовательность w, длина которой превышает z.
То есть опять же мы исходим от обратного.
Пусть существует что-то большее.
Тогда в этом случае она является наибольшей общей подпоследовательностью x и y.
Почему?
Почему если w, смотрите, w это наибольшая общая подпоследовательность от xm-1y?
Почему я говорю, что в этом случае w точно является общей подпоследовательностью x и y?
Да, потому что у x я просто забрал последний символ.
Ну, как бы, если я заберу там один последний символ, то тут я его добавлю, это точно будет общей подпоследовательностью.
А я говорю, что размерность вот этого, оно больше, чем у z.
Значит и здесь будет больше, чем у z.
А это противоречит чему?
Противоречит тому, что мы говорили, что z это наибольшая общая подпоследовательность.
Понятно?
Так, задайте вопросы.
Так мы уже и отошли от этого.
Это же второй пункт.
Вот сверху два точка и там написано как раз то, что мы писали в теореме.
Вот, теорема вот так выглядит.
В первом мы говорим, что одинаковые элементы, а во втором и третьем у нас они различные.
Да.
Да.
Потому что наибольшая имеется в виду с точки зрения количества символов.
Мне нужно противоречие получить с наибольшей общей подпоследовательностью.
z является наибольшей общей.
Если я покажу, что она является не наибольшей, а просто общей, то это будет противоречие с тем, что я говорил до этого.
Это ровно то же самое.
Оно подходит и по той, и по другой.
А как ты думаешь, что в этом случае лучше?
Лучше то, что откуда больше придет.
Ну то есть в действительности такого момента, на самом деле, вот когда xm не равно yn и xm, ну типа у нас же тут рассматривается, когда они не равны, правильно?
А ни один из этих символов, значит, не будет введен в задкат, просто так.
Вот.
В этом случае мы говорим, что нам лучше прийти оттуда, где было больше.
Потому что в этом случае z является ее на p, и с одной стороны xm-1y, а с другой стороны это xyn-1.
Я мог и так прийти, и так прийти.
То есть z является наибольшей общей подпоследовательностью.
И для того, и для того.
Мне нужно идти здесь немного в другую сторону, мне z будет неизвестно.
А если мне z будет неизвестно, мне нужно как-то из этих кусочков понять, типа, а что я, где я нахожусь сейчас.
Понятно?
Вот.
Как, вот как использовать эту теорему?
Как раз таки был вопрос, вот здесь вот, а мы этого и будем делать.
Значит, смотрите.
А что мы будем делать?
Мы заведем с вами двумерный массив.
Двумерный массив dpt ж, где будем хранить в dpt ж длину наибольшей общей подпоследовательности xyt y ж.
И заполнять z будет очень просто.
Давайте я сейчас что-нибудь сотру.
Смотри, продиктуйте мне какие-нибудь, не знаю.
А, сейчас я пойму, как тут лучше.
Вот так.
И вот так.
Продиктуйте мне какие-нибудь чиселки.
Ладно, давайте буквки.
Давайте буквками.
А?
А?
Давайте английское.
Хорошо?
Английское.
А?
Чего еще раз?
Давайте еще что.
Хорошо, ладно, если вам так надо.
Все?
Стало жить лучше?
Откуда?
Почему?
Ладно, друзья, так и быть.
Мы здесь закончим.
Вам здесь тоже нужно что-то.
Теперь русские буквы давайте.
Еще.
Вы хотите, чтобы вообще последовательности не сходились?
Я правильно понимаю?
Еще раз?
У просто поместилось.
Значит, смотрите.
Как заполнять эту таблицу?
Таблица заполняется, на самом деле, очень просто.
В начале здесь вот у меня не просто так сделаны пропуски.
Это сделано именно для того, чтобы у нас она легче заполнилась.
Мы говорим, что пока у нас символов нет, ну вот, пустая строка.
То есть это обозначение пустой той самой строки.
Какая длина наибольшей, вообще?
Ноль.
Ну, пустая строка.
Какая с ней может быть наибольшая последовательность?
Поэтому она заполняется вот так вот нулями.
А дальше, что происходит?
Если мы находим одинаковые символы, то это означает, что мы могли прийти только в одном случае.
Каком?
А вот по той самой теореме мы говорили о том, что мы могли прийти только из наибольшей строки.
По той самой теореме мы говорили о том, что мы могли прийти только из наибольшей общей подпоследовательности.
Хм-1, ун-1.
Правда?
А значит, это то же самое, что мы здесь делаем dpi-1, g-1 и сделаем плюс один, потому что символ одинаковый.
Окей?
Это понятно?
Да.
Аналогично для второго случая мы говорили, что если у нас символы не равны, то мы могли прийти, грубо говоря, либо сверху, либо слева.
То есть убрать символ либо от одной строки, либо от другой строки.
В этом случае нам нужно выбрать максимальный.
Мы же пытаемся найти наибольшую общую подпоследовательность, а структуру ее не знаем.
То есть мы отталкиваемся здесь от этого.
Таким образом у нас вот такое вот построение будет.
И если мы говорим о данном примере восхитительном, то что у нас будет происходить?
И а оно как бы не сходит.
Первый раз на самом деле с русскими буквами эту задачу решаем.
Вот, поэтому здесь максимум отсюда и отсюда это ноль.
И ис тоже самое.
Сложно, становится.
Здесь аналогично, а иф тоже, ища тоже, и твердый знак тоже.
То есть у нас как бы мы не могли ниоткуда прийти здесь.
У нас, к сожалению, нет такой буковки.
Когда сходится, да, сейчас мы дойдем до сходства.
Когда не сходится, мы смотрим вверх и влево.
А максимальный?
Потому что он нам показывает, что мы же оттуда могли прийти.
Вот, или отсюда могли прийти. Другого варианта у нас нет.
Мы специально теориям для этого доказали.
Ну, то есть я вот пришел, к примеру, вот из этой строчки, либо отсюда, либо отсюда.
Я максимум из них убираю, но там и там ноль.
По диагонали мы можем прийти только в одном случае, когда символы одинаковые.
Вот.
Смотрим на ща.
Ну, давайте я тут облегчу нам задачу.
Вот так.
Но когда щ и щ здесь будут одинаковые, это означает, что мы должны убрать символ один отсюда и один отсюда, сделать плюс один к тому, что было по диагональке.
То есть вот из этого кусочка, который я сейчас выделяю, мы должны выбрать как раз наши символы.
То есть вот здесь я делаю через плюс один, получая здесь один.
Понятно?
Это благодаря той самой теории, которую мы с вами доказали.
Ну, дальше здесь отсюда и отсюда.
Вот здесь вот единичка вот здесь получается.
Согласны?
Смотрим дальше.
А и А. А и А сходятся удивительные рядом.
Поэтому здесь аналогично, через плюс один по диагональке.
Здесь будет один.
И здесь опять А и А сходятся.
Мы идем опять же по диагонали и делаем плюс один.
После этого мы смотрим на максимумы, вот получаем такое.
А?
Интересно получается.
Здесь аналогично А и А.
Мы смотрим, приходим по диагонали, получаем здесь один.
А здесь не сходится один, а вот здесь А и А опять сходятся.
Поэтому мы приходим вот отсюда, через плюс один у нас получается два.
Дальше будет два, два, два.
Ну и У.
У, извините, у него ничего нет, поэтому это просто максимум из соседних ячеек.
Ответ лежит вот здесь.
В ДП.
Н там.
М там.
Здесь находится ответ.
Давайте сразу проговорим, как можно восстановить диагональ.
Мы смотрим, откуда мы пришли.
Либо сверху, либо слева.
Здесь числа одинаковые, нам без разницы откуда мы пришли.
Поэтому мы можем сказать, что сверху.
Но так как мы знаем, что если мы пришли либо сверху,
ну мы смотрим на символы.
Если символы различные, то мы идем либо наверх, либо налево где-либо вот здесь.
И вот здесь вот.
Ну вот.
И вот здесь вот.
то мы идем либо наверх, либо налево, где лежит это максимальное число. Но если мы встретим
одинаковые символы, то эти символы мы записываем себе в подпоследовательность. Давайте здесь
делать. Ну вот я иду в два, в два я мог попасть только отсюда, потому что сверху единичка,
слева двойка. Я слева пришел. Дальше здесь у меня символы опять различны, я иду вот сюда,
а потом я иду вот сюда. А вот здесь я уже встречаю одинаковый символ А и А. Я записываю это А,
давайте напишу это с черточкой, чтобы вы поняли, что мы получим подследовательный наоборот. Вот я
получаю А и А и иду вот сюда, в эту диагональку. Смотрю здесь, здесь опять А, С. Символы различны,
я пришел либо сверху, либо слева, а здесь только слева, то есть вот сюда иду. Смотрю здесь А и А,
значит я пришел по диагонали, а значит в этом случае я говорю, что я пишу вот это А и иду по
диагональке. Но дальше тут ноль, все грустно и получается, что у меня вот такая последовательность.
Заметьте, она наоборот сделана. Вот, поэтому ее нужно в конце всегда перевернуть. Понятно? Все
достаточно просто. Реализация его вот, здесь чуть больше ифов написано с точки зрения не максимума,
откуда мы пришли, почему? Потому что здесь реализована то самая преф, это та самая пара,
которая нам нужна будет с точки зрения встановления ответа. Это не обязательно,
вы можете делать это не таким образом. Вот здесь написано пара, вы пары использовать не можете,
я так напоминаю. С ДПР еще не существует. Можете структуру написать, все верно.
Инициализация, так, и чего?
Нельзя. Вот, я здесь написал вам псевдокод. Я напомню, что я начал писать псевдокод,
потому что ВЛ с плейдеревом и закончили, это было самое сложное. Здесь очень простое.
Вот. Но здесь что происходит? Ну как бы заполнение в начале, я думаю, вы понимаете. Дальше у меня
просто идет цикл между собой, я сравню, если одинаковая, то я иду как раз по диагонали и
делаю плюс один, иначе я смотрю, откуда пришел, сверху или слева. Все, нет никаких проблем.
Вопросы есть? Все ли понимают, что этот алгоритм работает за NM? Есть ли вопросы к этому? Или проблемы?
К сожалению, наибольшую общую подпоследовательность быстрее нельзя. Но мы переходим с вами к НВП потом,
попозже. Восстановление ответа мы с вами проговорили. Здесь просто пройтись по этим параметрам.
Наибольшая возрастающая подпоследовательность, что здесь? Это N-V-P. Дальше задача очень простая.
Здесь уже дается не несколько последователей, а одна. И нужно N-state из чисел, ну либо из чего-то,
что вы можете сравнивать, но чаще всего это чиселки. Для примера это будут именно целые числа. И вам
нужно найти такую подпоследовательность, которая будет возрастать. То есть наибольшая
общая возрастающая подпоследовательность. Все достаточно просто. Понятно, что хочется в
задачу? Всем? Хорошо. Тогда первое решение очень простое. Вот вы можете его прочитать и сказать,
понятно оно вам или нет. Давай пока сотру. Дальше мы его разберем.
Кто понял, что написано?
Понятно? Это за N квадрат работает, да. Смотрите, давайте это сделаем на примере. Продиктуйте
мне чиселки. 1, 4. Будем возрастать на время. Давайте я введу 3 для прикола. 8,
минус 9, минус 1 и 7. Ну все ладно, давайте успокоимся. Смотрите, что подразумевается в этом алгоритме.
В этом алгоритме происходит следующее. Предположим, мы с вами знаем вот здесь вот какие-то числа. Ну там,
давайте их назову x1, x2, x3, x4. Вот к этому моменту. Смотрите, как можно здесь разбивать их между
собой? Я смотрю на нынешнее число и смотрю на все числа перед ним. Если я нахожу числа меньше его,
то я буду рассуждать в одном случае. Если я их не нахожу, тогда, извините, если там не было
перед ним никаких чисел меньше, значит он не может участвовать ни в какой возрастающий подпоследок,
кроме как сам собой. Согласны? Поэтому здесь будет на самом деле единичка, к примеру. Теперь
предположим, что у нас здесь еще какой-нибудь есть x5. Вот я смотрю сюда, на эту семерку. Я опять же
пройдусь по всем предыдущим и выберу из чисел там, где у меня есть числа меньше. Это 1,
4, 3, минус 9, минус 1. Только 8 обделено. Я выбрал числа меньше. А теперь смотрите,
какой здесь интересный поворот. Согласны, что если я добавлю 7 к любой из подпоследов,
которая заканчивается на эти числа, то у меня увеличится возрастающая подпоследовательность.
Согласны? А давайте выберем наибольшую из всех возможных. То есть я вот сюда поставлю
максимум из всех чисел, которые у меня здесь есть, и сделаю плюс один, потому что я добавлю
семерку. Кроме 8, 8 больше число, поэтому я его не трогаю. Понятно, что я имею в виду?
У кого есть непонимание решения? Сейчас примерно разберем нормально с чиселками. А перед ним нет
ни одного числа меньше него. Согласен? Он не может участвовать ни в одной возрастающей
подпоследовательности. Да, это длина. Здесь мы храним длину. Вот это и есть тот самый массив dp.
А слева от иксы. Икс и – это символ, число. У меня весь этот массив – это икс. Но обратиться
к итому элементу – это x и t. Это одно число. Вот это, например. Ну, смотрите, x нулевое равно
единичке. Я утверждаю. Это массив. А x и t – это предыдущие. Это до этого момента. То есть x
большое и t – это все числа, которые есть там x1 и так далее x и t. x нулевое. Понятно? Все
числа меньше. Ну вот, меньше-то вот, что здесь есть. Давайте разбирать здесь. Смотрите, начальные
условия на самом деле простые. Первое число всегда одно. Это максимальная возрастающая
подпоследовательность из одного числа. Согласны? Теперь я смотрю дальше. Четыре. Смотрю на все
предыдущие. Вижу только единичку, правда? Но все равно вижу. А она меньше, чем четыре. Какой у
меня здесь есть вариант? Первый вариант есть, что само четыре, как возрастающий подпоследователь.
Что мы добавим эту четверку к какому-то другому числу, которая будет меньше четырех, а значит мы
увеличим это возрастающую подпоследовательность. Поэтому здесь уже будет ответ два. То есть количество
символов – два, один, четыре. Понятно? Дальше я смотрю на три. Три меньше четырех, но больше
единицы. Меньше четырех мы пропускаем. Больше единицы смотрим. Если оно больше единицы, тогда в этом
случае я могу тройку добавить к единичке и опять получить возрастающую подпоследовательность.
Один, три. Согласны? Поэтому здесь на один больше количество возрастающей подпоследовательности,
чем в единичке. Поэтому здесь опять же два. Восемь. Мы смотрим восемь. Восемь больше трех, правильно?
А я могу восьмерку добавить к этой тройке в конце и получить новую возрастающую подпоследовательность.
Значит я делаю, что здесь, к примеру, у меня три. Четыре опять меньше восьми, но я не получаю
большее число, чем три. Согласны? А значит смысл мне это вообще трогать. Поэтому здесь три. Для
единички аналогично. Тут получу вообще два. Ничего не изменится. То есть я прошелся по всем
предыдущим. Минус девять. Я смотрю оно меньше этого, меньше этого, меньше этого, меньше этого. Грустная
история. Значит оно может быть только лишь самим собой. Поэтому это единичка. Оно само может быть
только возрастающей подпоследовательностью. Для минус одного я смотрю все предыдущие только минус
девять меньше. Если минус девять меньше, то я могу к нему добавить минус единицу и я получаю
возрастающую подпоследовательность. Поэтому получаю здесь два. Ну плюс один от минус девяти.
Для семерки мы опять же смотрим на все предыдущие, а выбираем все числа меньше. Все числа меньше,
вот у меня галочка здесь и проставлены. И на самом деле вот я первое число, которое встречу,
минус один, здесь будет два. И вот я как бы добавлю сюда три. Какая возрастающая подпоследовательность,
как вы думаете, здесь будет? Все зависит от того, как вы найдете максимум на самом деле. Для того,
чтобы восстановить всю эту подпоследовательность, вам достаточно будет хранить массив предыдущих. То
есть кто является предыдущим тем самым элементом? Предыдущий индекс от этой возрастающей подпоследовательности.
Кто перед ним стоит? Ну для единички это будет минус один, для четверки это будет нулевой индекс,
для тройки это нулевой индекс, для восьмерки это будет второй индекс. Дайте я пронумеру 0, 1, 2, 3,
4, 5, 6. Для минус девяти это будет какой индекс? Минус первый, перед ним никого нет, да минус одного что?
Четвертый, то есть минус девять, которое было. А для семерки? Пятый. Ну и как бы вы просто возвращаете
эту последовательность. Каким образом? Пока предыдущий не равен минус единице, вы добавляете
этот массивчик, получаете число. Если вам надо найти размер этой наибольшей общей подпоследовательности,
то он лежит вот здесь. Согласны? Вот. Найдете максимум здесь, получите возрастающую подпоследовательность.
За сколько это работает? Почему? Ну мы сравниваем, получается у нас там будет n на n минус один
пополам. Количество сравнений. Правильно? Понятно почему? А почему это плохо? А что бывает быстрее?
Бывает логоарифм. Правильно, бывает логоарифм. Это я согласен. Вот. Но что касается реализации
вот этого решения? Реализация достаточно тоже понятна. Вы берете сначала, создаете все массивы,
потом дальше проходите по каждому из элементов и говорите, что он идет от нуля до n минус один.
Ставите единичку, потому что он может быть самостоятельным. Предыдущий минус единички,
ок, ничего страшного. А дальше вы говорите, что если вы нашли из предыдущих элементов какой-то
меньше и размеры этой наибольшей подпоследовательности больше, чем тот, который стоит у меня сейчас,
тогда я беру этот элемент. Все. Ну ровно то, что мы сейчас сделали на примере. К этому ли есть вопросы?
Вроде достаточно простой алгоритм. Главное понять суть. А это очень похоже на префиксу,
с префиксами, когда вы работали или если хоть раз встречались, давайте так. Это очень похоже.
Вы просто смотрите на все предыдущие и что-нибудь решаете от этого. Но можно ли быстрее? Это главный
будет наш вопрос. На самом деле можно. Здесь пока я стираю опять же. Вы почитайте и мы с вами
сейчас поймем, что же там происходит такого. Вот обычно на этом моменте многие из вас ломают.
Поэтому, пожалуйста, задавайте вопросы. Для предыдущей вроде понятно.
Очень забавно, что люди сверху, они еще и в наушниках сидят. Вот я ж говорю. А зачем ты приходишь?
Если ты в наушниках сидишь, ну вот настолько.
Ладно. Давайте разбираться с тем, что происходит здесь в наибольшей возрастающей подпоследовании.
Смотрите. Мы говорили, что у нас здесь в ДП хранилась максимальная длина наибольшей
возрастающей подпоследователь, оканчиваясь на этот символ. Правильно? А теперь мы в ДП и там храним
минимальное число, на которое может, я специально пишу и говорю типа по словам, может оканчиваться
наибольшая возрастающая подпоследовательность длины и все. Какое у нас максимальное значение
наибольшей возрастающей подпоследовательности? Все элементы. Поэтому в действительности вот это ДП,
оно будет принимать значение от нуля, потому что их и ноль как бы бывает, до Н включительно. Одно?
Может мы выбираем специально меньшее число из них. Меньшее число, на которое заканчивается
последовательность длины и минимальное, наименьшее. Одно? Да? Это размерность массива. Не более.
Что еще раз? Наибольшая возрастающая подпоследовательность длины и… Да?
Наибольшая возрастающая… Хорошо, возможно я здесь не совсем корректно написал. Предположим,
что у нас есть х, это наибольшая возрастающая подпоследовательность от х длины и. Просто
возрастающая подпоследовательность длины и. Давайте типа вот так. Возрастающая подпоследовательность
длины и. Так лучше? Из нашего массива х. Мы храним минимальный элемент, на который может
заканчиваться наибольшая возрастающая подпоследовательность длины и. У нас длина
здесь, понимаешь, она не максимальный. Нет. Давайте с вами разбираться с тем, что здесь происходит.
На минимальный? Если ты так рассуждаешь, то хорошо. Давайте с вами смотреть. Это все на самом деле
работает на примерах. Вот это вам придется самим написать. Кодом я, конечно, покажу, но поверьте,
здесь не то чтобы очень много поможет. Возьмем такую же последовательность. Хорошо. Один, четыре,
три, восемь. Сейчас момент. Нет, я не хочу такую. Я чуть-чуть изменю. Я добавлю один символ в конце.
Минус девять, минус один и. Давайте я сделаю здесь минус десять. Двукзначные числа? Кошмар! Ужас
просто. Смотрите, я буду пошагово заполнять массив dp и вы будете смотреть, что с ним происходит.
Первоначально массив dp в самом начале, на нулевой итерации, он равен минус бесконечный. Давайте я
вот прям под этим буду писать. Единственное, что лучше бы их чуть-чуть сдвинул. Ну ладно.
Сделаю табличку. Здесь будет номер итерации. Это все будет про массив dp. Номер итерации,
а здесь количество символов. Ноль, один, два, три, четыре. Сейчас, сколько у нас тут? Четыре, пять,
шесть, семь, восемь, восемь. Четыре, пять, шесть, семь, ну и тут восемь. Вот это массив dp. Я буду
смотреть на каждую из итераций. Ну на нулевой итерации что этот массив занят. Минус бесконечностью.
еще раз бесконечный. Да. А существует специальная библиотека с лимитами, можешь взять лимит.
Ну да, с лимитами-то можно. Но у тебя обычно в условии сказано, что не больше каких чисел.
Этого будет достаточно. Вот в начале такое у меня ДП. И тут бесконечный. Я смотрю последовательно
каждый из этих символов. На первые трассы я смотрю лишь на первое число. Какой максимальной длины
здесь возрастающей подпоследность может быть? Вот из одного элементика.
Один. Вот здесь становится единичка, здесь остается минус бесконечность, бесконечность,
бесконечность, бесконечность и так далее. Ага. Я дальше уже буду прочерк ставить.
Почему единичка встала в единичку? Я смотрю пока на первое число. Только лишь на первое. Я
иду последовательно. Я говорю, что у меня в ДПИ там хранится, еще раз, минимальное число,
на которое последовательность может заканчиваться длиной И. Вот если у меня в начале было минус
бесконечность и бесконечность, и я смотрю только на одно число, вот эту единицу, то при этой единице,
вот оно одно. Какая возрастающая подпоследность максимальная? Из единички. И длины единицы.
Так уж и сошлось в этом примере. Вы меня сами продиктовали, я только по нему иду.
Вот. Теперь я смотрю на второй итерации. Что у меня происходит на второй итерации здесь,
я добавляю новое число 4. Смотрите, я заполняю. Минус бесконечность. Здесь я могу сказать,
что на 4 будет заканчиваться. Оно не минимальное. Минимальное это единичка, поэтому я оставляю
единичку здесь, а четверку я вставляю сюда, потому что у меня есть 1 в 4. Причем заметьте,
я меняю только один символ. Число, к которому я перехожу. Вот 2 означает, что к второму пришел.
Вроде мы решили вопрос с единичкой. Нельзя. Почему? Потому что, давайте еще раз,
ДПИТ это массив, в котором вы сохраняете наименьшее число, на которое заканчивается
возрастающая подпоследовательность длины И. Если у меня есть две возрастающие подпоследовательности,
длины 1. 1 и 4. На какое число минимальное оно оканчивается? Вот у меня есть две. Какой из них меньше?
У меня есть последовательность длины 1 из единицы и четверки. Я ее и оставляю. А дальше я смотрю на 2.
Длины 2. Могу я что-то сделать или нет? Могу. Четверку если добавлю. У меня два символа всего пока так.
Оно одномерно. Я ставлю здесь номер итерации. Это номер итерации. Как меняется массив ДПП,
когда мы проходимся по всему своему массиву. Понятно? Все вопросы? Я говорю, вот это вот все.
Это финал. Смотрим на третий возможный вариант. У меня есть 1, 4 и 3. Длины 1. Все еще из единицы.
Согласны? Лучше всего. А вот длины 2. Что лучше? Троечку поставить. У меня будет 1 и 3 уже в этом
случае. Тут бесконечности. Те, где я не заполняю. Что еще раз? А я могу здесь сделать 3 элемента из 4?
Вот у меня 1, 4 и 3. Что возрастающее? Не могу. Что еще раз? Что меньше, что лучше.
Сейчас объясню, как мы будем искать, куда вставлять. Это нормально. Я хочу сейчас кое-что показать на этом
примере. Я показываю смысловую нагрузку. Это хороший вопрос, которому я скоро перейду.
Хорошо? Да. Итерация, что это такое? Я смотрю на новый символ. Я же иду последовательно по символам.
Я смотрю на новый символ и пытаюсь его куда-то впихнуть. И смотрю, типа, сделает он какие-то
обновления или нет. И где он сделает? Понятно? Вот это здесь итерация. Вот, я смотрю на 8. Смотрите,
8 в один символ может встать? Нет, но единица меньше. Тройка тоже меньше, и там смысла встать нет.
А вот из трех символов восьмерка уже встанет. Логично? Логично. Здесь опять будет бесконечности.
Дальше пятая итерация. Кто-нибудь хочет мне ее продиктовать? Шестая. Давайте сразу седьмая.
Что еще раз? Потому что у меня нету большей длины в последовательности.
Конечно. Вторая и третья итерация это вот досюда и вот досюда. Вот это первая итерация,
вот это вторая итерация, вот это третья. На шестой что? Потому что какая последовательность длины
меньше оканчивается на меньшее число? На минус 9 или на единицу? Минус 9, 3, 8. Вот здесь очень важно
вам показать следующее, что это не является той самой возрастающей под последовательностью,
которой у меня есть. В dpi хранится просто одно число, на которое заканчивается последовательность
длины и и это число на и меньшее из всех возможных. Смотрите, давайте вот на примере пятой итерации
поймем. У нас длины 1. Какие есть последовательности? Вот если до минус 9. У меня есть 1, 4, 3, 8, минус 9.
Согласны? Минимальный последний элемент. Извините. Вот у меня есть вот эти числа. Какое из них
минимальное? Вот оно и стоит. Теперь давайте смотреть длины последовательности 2. У меня может
быть 1, 4, 1, 3, 1, 8, 4, 8, 3, 8. Все. Какое из этих последних чисел меньше? Вот это 3 здесь и стоит.
Теперь давайте длины 3. Длины 3 у меня есть 1, 4, 8, 1, 3, 8. Все. Какое меньше? Ну 8. У нас другого
варианта нет. Понятно, что имеется в виду здесь dpi там? Вот. Шестой вариант. Тогда
мне продиктуйте, пожалуйста. Минус 9, минус 1, 8. Так. Правда. Дальше? Я еще вот здесь. У меня семерки
еще нет. Следующее. Когда у нас 7 появляется? Минус 9, минус 1, 7 и бесконечности. Ну и когда
минус 10 появляется? Минус 10, минус 1, 7 и бесконечности. Смотрите. Давайте с вами кое-что заметим,
очень важное здесь. Во-первых, согласны ли вы с тем, что из смысла dpi вы понимаете,
что это всегда будет возрастающий массив? Правильно? А? Не. Ну по числам, которые в нем хранятся.
Ну у вас в dpi там хранится число, на которое заканчивается it последовательно. Значит,
i-1 заканчивается на число меньше. Значит dpi-1 всегда меньше, чем dpi. Это первый нюанс.
Второй нюанс. У нас любое число, которое мы здесь с вами находили, меняло эту последовательность один раз.
Всего один. Оно вставало в какое-то место и делало это один раз. И как оно это делало? На самом
деле все очень просто оно это делало. Оно находило место там, где первое число большее него. То есть
один стало на место бесконечности, четыре стало на место бесконечности, три на место
четыре, потому что четыре больше него. Восемь стало на место бесконечности, а дальше у нас было
минус девять. Минус девять стало на единичку и так далее. Видите этот момент здесь? И оно в
действительности всегда будет обновлять только одно число. Это тоже очень легко выводится из того,
как выглядит dpi-t, потому что если оно встало в два места, то это странно, потому что такого быть не
может. Потому что оно заканчивалось, ну там и-то и житое место, к примеру. И g больше и. Значит g-то
заканчивается на число и it заканчивается на это же число. А что между ними? Что возрастающий
под последовательностью является? Понятно? То есть между одинаковыми числами у вас что-то есть,
а такого быть не может. Оно обновляется один раз, оно всегда возрастающее. Значит,
как нам найти место первого числа, которое является большим? Bin поиском. Бежать долго.
Bin поиск вам в помощь. Bin поиск найдет это место за сколько? За логарифм. Это и будет здесь ключом к
тому, что это работает за n-логин. То есть я каждое число буду вставлять в это dpi-t с помощью bin поиска.
Я вам показал, почему bin поиск можно, потому что это a возрастающая всегда,
а возрастающий массив b это потому что я меняю всего одно число и возрастание остается. Именно
поэтому минус бесконечность здесь есть. Она для bin поиска нужна. Давай еще раз.
Да. dpi-t равно минимальный dpi житый. Такой, что у меня x житый больше,
чем x итый. Здесь не совсем x. Ошибка, я согласен. Короче, переход здесь на самом деле просто найти
это место в dpi житый. Вот. Да, это у меня тоже галочка. А вот здесь еще и аито. Я что-то вообще
все напутал. Ладно. Важный момент. Для того, чтобы восстановить ответы, что нужно будет хранить?
Хранить нужно будет позицию ита, которая будет показывать просто индекс элемента,
на который здесь находится. Твоя массив x. Ну то есть я вот в поз ита буду сохранять эти индексы.
Почему? Потому что у меня вот это вот минус 10, минус 1, 7 не является возрастающей. Мне нужно
восстановить. А как мне это сделать? А очень просто. Я узнаю, какой индекс у семерки, а у семерки
узнаю, какие у нее были предыдущие элементы. И все. Как я узнаю эти предыдущие элементы? Но вот
когда я вставляю некоторое число, я знаю, что перед ним стоит элемент, который стоял точно раньше.
Согласны? Это будет тот самый преф. Вопрос.
В бесконечность. Он заменяет первый элемент больше. Это же бесконечность. Все в бесконечности.
Что вопроса?
Понял вопрос. Для этого нам нужно чуть-чуть еще написать тогда поз и ф. Давайте я напишу.
Вот при заполнении как мы их должны были получить?
Смотрите. Делается массив поз.
Сколько у меня там от 0 до 8? 8. Вот так должно быть.
И делается массив предыдущих элементов.
Раз, два, три, четыре, пять, шесть, семь, восемь. Тоже от 0 до 8. Смотрите. Я иду все так же по элементу,
с самого начала. То есть вот тут вот атеративно я здесь буду просто чиселки ставить.
Привыначально тут минус единички, тут минус единички.
Что означает поз и т?
Поз и т, оно связано с dp. Вот представьте, что у меня есть тут и т элемент. Я должен понять, где он находится в моем массивчике.
Если я говорю про последний элемент, то поз и т вот к этому, когда я получил финальный dp,
он будет следующий. Минус один, но минус бесконечности, нет его места. Минус 10, где у нас стоит? На восьмом месте.
Минус один стоит на шестом месте, а семь стоит на седьмом месте.
А дальше будет минус один, минус один, минус один, минус один, минус один.
То есть позиция это просто соответствие вот этого dp, этого числа, которое здесь, с тем, что было в иксе.
Теперь предыдущие. Предыдущие это как раз когда я вставлял, что там происходило.
Вот когда я единичку вставляю на первое место, а вот здесь, какой у него предыдущий элемент? Минус бесконечности, согласен?
А у минус бесконечности какая позиция? Минус один, правильно? Поэтому я ставлю здесь минус один.
Первый элемент вставляю четверку, четверку я вставляю на место сюда. Я смотрю на предыдущий элемент. Предыдущий элемент какую позицию имеет?
У единичка какая имеет позицию? Ноль? Согласны? Сейчас подожди, вот этот пост, он соотносится только лишь с последним.
Я понял, ты сломался. У нас есть еще, у нас очень мало времени.
Давайте я сейчас проговорю про пост, если будет еще вопрос, мы еще одну таблицу нарисуем, хорошо?
Ну я отпущу всех, кто понимает, или кто...
Здесь? Здесь, да.
Ну здесь, да.
Три, четыре, пять, шесть, семь, действительно.
Ну да, извините.
Семь, шесть, пять.
Лучше? Лучше. Хорошо.
Что касается здесь, первое, ну вот, пири, когда я вставлял, я вставлял его вот сюда.
Для него предыдущим являлась единичка. У единички какая позиция? Нулевая, правильно? Поэтому здесь будет ноль.
Дальше я вставлял три, у тройку я вставлял сюда, и предыдущий стоит что? Единичка. У единички какая позиция? Нулевая.
Нулевая.
А дальше я смотрю на следующую итерацию. Что у нас тут происходит? У меня есть третий элемент, восемь. Восемь я вставляю сюда, предыдущий какой у нас? Третий. У тройки позиция какая? Два.
Да, два.
Дальше я смотрю еще ниже. Я смотрю на минус девять. Минус девять встал сюда, у него предыдущий какой?
Минус бесконечность, это минус единица. Да, у нас вот так.
Поехали дальше. У нас есть минус один. Минус один я вставляю сюда, предыдущий у него какой?
Минус девять. Минус девять какой индекс имеет?
Да, четыре.
Какое-то число вы не вставляли. А, например, может ли быть такое, что мы какое-то число не вставили?
Вот. Поехали дальше. Единственное, что точно не вставит, когда у нас будет одинаковый число.
Семь, когда я вставляю у семерки, какой предыдущий элемент? Минус один. У минус один какая позиция?
Пятая. Ну и последний я оставляю минус десять. Минус десять я вставляю в самое начало предыдущий элемент, минус бесконечность, у него позиция минус один.
Вот я смотрю на эти позиции. Теперь смотрите, как мне понять длину максимальной подпоследовательности возрастающей?
Максимальный небесконечный индекс будет показывать нам именно это. Вот здесь вот троечка, согласны?
Здесь у меня стоит что? Семерка. У семерки я знаю что. Вот этот поз, видите? Вот он шестерка.
Я говорю, что я вывожу Си, и у шестого элемента какой предыдущий?
Четвертый, ну предыдущий пять, индекс пять. А индекс пять означает какой элемент?
Минус один. Я перехожу по этому индексу, вижу здесь четыре. Четыре. Какой элемент?
Минус девять. Индекс у какого элемента четыре? Минус девять.
Перехожу в четвертый элемент, смотрю какой у него предыдущий. Минус первый, ничего, значит нет никакого предыдущего элемента.
Вот это возрастающий подпоследствия, но наоборот. Поэтому я переворачиваю, получаю минус девять, минус один, семь.
Исходя из поз и преф. Поз показывает нам элемент, индекс этого элемента, шесть.
Шесть является последним индексом, согласен?
Дальше я иду сюда. У шестерки какой предыдущий? Шестой элемент, во-первых, это семь. У шестерки какой предыдущий индекс? Пять.
Пять имеет, ну, х пятая, это минус один. Давайте я выпишу вот так, это х.
Шестое, это х. Пятое, это х. Четвертое, и все. Соответствие идет вот согласно этому. Да.
А потом, что так или так или иначе, у меня уже один квадрат действий. Где у меня здесь один квадрат действий?
Это n. Ну а, а, это итерация, ну ладно. Это итерация. Это n.
Ну, по-моему, сюда будет очень много странных. Почему? У от н? У от н?
Это от н?
Это от н?
Нет, вы строите его параллельно, сейчас покажу.
Смотрите, что вы делаете? Да, я сейчас всех вас отпущу, все хорошо.
Понимаю, все нормально.
А у нас есть массив dp, у нас есть массив pos, у нас есть массив pref.
Смотрите, вы идете по всем числам, которые у вас есть, и бинарным поиском ищете место иксытово.
Когда вы находите это место иксытово, вы его вставляете и говорите.
Здесь я перепутал буковку и написал p. dp житое равно аитому, это раз, то есть место, куда я вставил.
Дальше вы говорите, что позиция житого, то есть позиция элемента, который я вставил в моем стандартном массиве, равна i.
Я в этом элементе нахожусь, его индексы, согласны?
А предыдущий его элемент, это тот, который стоял раньше, его индекс.
Порисуйте, потыкайтесь чуть побольше, поймете, что происходит.
Восстановление очень простое, когда у меня есть pos, все становится очень просто.
Есть ли у вас вопросы?
Хорошего всем вечера, продуктивного!
