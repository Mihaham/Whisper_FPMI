Добрый день. Мы начинаем говорить про потоки. Сегодня будет первая лекция, наверное, из трех.
Вот зачем это вообще надо? Какая мотивация? Ну, смотрите. Представьте, что вы строите
какой-нибудь трубопровод, и вам нужно передавать какой-нибудь материал из одной точки в другую,
ну или там, не знаю, перевозить какие-нибудь грузы по дорогам. Вот. И у вас есть, соответственно,
эти дороги, в случае, если вы перевозите грузы на машинках, либо у вас есть какой-нибудь,
ну, действительно, трубопровод. То есть прям трубы лежат, и вы можете пропускать по этим
трубам, там, какую-нибудь нефть или другое что-нибудь полезное. Соответственно, у каждой
трубы или у каждой дороги есть пропускная способность, сколько там единиц воды или
единиц груза в секунду она может пропустить. И ваша задача, соответственно, передать как
можно больше грузов из СВТ. Или там, максимизировать скорость передачи грузов. То есть, если вас там,
ну, мы считаем, что движение водички, оно как бы бесконечное, то есть вы так вот берете,
и оно все сразу туда перемещается. Вот вам нужно передать как можно больше в единицу времени
товаров. Вот. Ну и, например, здесь можно поступить как-нибудь так. Можно вот по этому пути пропустить
единичку потока, по этому пути пропустить двоечку потока. То есть тут будет один везде течь,
здесь будет течь два. Вот. Соответственно, у вас никакие ограничения не нарушатся, потому что,
ну, вот скажем, по этой трубе течет три из трех. У вас ограничение сверху три, а течет три.
Поэтому ничего не нарушается. Вот. Ну и кажется, что лучше нельзя, нельзя передать больше,
чем три единицы потока. Наверное, это можно как-нибудь доказать. А, сейчас, я именно выйду вот так вот.
Да, это можно доказать, потому что, например, если мы рассмотрим вот такое вот сечение нашего,
нашей сети, то она пересекает ребро веса 1 и ребро веса 2. Вот это вот такое я нарисовал,
корявое, пересекает два ребра веса 1 плюс 2. Ну и тогда понятно, что вот если у вас есть как бы
левая часть вашего графа, правая часть вашего графа, тогда понятно, что, суммарно, весь поток,
он же как-то должен перетечь слева направо. Поэтому, суммарно, ответ ограничен точно
пропускной способностью всех вот этих ребер. То есть максимум 1 плюс 2. Ну вот мы ровно три нашли.
Максимум, возможно, нашли. Вот, ну такая мотивировка. Теперь давайте к определению.
Значит, сеть — это ориентированный граф и две выделенные вершинки в нём.
Считаем, что они различные. Значит, с мы будем называть и стоком, t — стоком.
То есть это то, откуда мы передаём водичку, t — это то, куда вода стекает.
Так, виноват. Надо ещё, конечно, пропускные способности ввести.
Значит, мы тоже в определение сети вставим. У нас есть граф, две выделенные вершинки,
ещё некая функция, которая каждому ребрусу поставляет некоторое целое неотрезательное число.
Будем это называть пропускной способностью.
Вот, или по-английски capacity.
Есть граф, и на каждом ребре написано какое число, ограничение сверху на то,
сколько воды может течь в однице времени. А у каждого ребра есть какая-то capacity.
Мы считаем, что это целое неотрезательное число, потому что отрицательное capacity — это как-то
странно, что мы можем по дороге перевозить максимум только там минус два товара.
Это значит, дорога бесполезна, у нас таких не будет. Целое. На самом деле не шибко
важно. Можно было бы считать, что вещественное, но давайте для простоты считать, что все
capacity у нас целые. Если были бы вещественные, то один из алгоритмов, который мы сегодня
построим, не очень адекватно бы работал. Поэтому давайте считать, что всё целое.
Дальше нам нужен поток. Пусть есть какая-то сеть.
Тогда функция из V на V в Z называется потоком в этой сети.
Если выполняются следующие три условия. Во-первых, самое естественное условие — это что поток
текущий по каждому ребру должен не превосходить пропускной способности. Для любой пары вершин
поток между ними, то есть поток из UV не превосходит C от UV. Где C — это наша пропускная способность.
Но мы считаем, что если у нас раньше C была определена только для ребер, то
теперь мы хотим для любой пары вершин, то есть они не обязательно соединили ребро в изначальном
графе, но все равно для любой пары мы хотим определить capacity любой пары вершин.
И вот если это не ребро, то там будет просто 0, потому что если дороги нету между двумя вершинами,
то это то же самое, что если считать, что здесь есть дорога capacity 0, что мы по ней ничего
передать не можем. Вот это вот, если считать, что при отсутствии ребра capacity UV равно 0.
То есть можно сказать формально, что мы функцию T продолжаем, она у нас была определена на E,
теперь мы продолжаем на весь В квадрат и говорим, что всюду, где она раньше была
неопределена, теперь 0. Capacity в остальных местах — 0. Второе — антисимметричность свойства
формулируется так, что для любой пары вершин поток текущий по ребру UV равен минус потоку
текущему по ребру VU. Вот это уже чуть более странно, но смысл следующий. Представьте,
что у вас там сколько-то потока течет слева направо по ребру V. Тогда мы вводим обратное
ребро, вот такое вот VU, на котором будет написано что-то отрицательное. Вот если здесь написано 1,
то здесь минус 1. И эту минус 1 можно трактовать так, что если вершина U передает вершине V одну
единичку потока, то это как бы означает, что вершина V должна вершинке U одну единицу потока.
Ну там не знаю, Вася дал Пете 1 рубль, тогда Петя должен Вася 1 рубль. Здесь отдал, здесь должен.
Соответственно, они будут просто противоположными числами, написанными вот в противоположной
стороны на одном ребре. Чуть позже мы поймем, зачем нам такое свойство. И третье, свойство сохранения потока.
Сохранение потока. Для любой вершины, отличной от S и T,
мы будем требовать, что сумма всех входящих потоков равна сумме всех исходящих. Так,
как я это напишу? Сумма по всем вершинам U таким, что U-V это ребро, F-U-V равна сумма по всем вершинам W таким,
что V-W это ребро, F-V-W. Это тоже естественное требование, что если есть какая-то вершинка V,
то должно обязательно выполняться такое свойство. Сумма потоков в текающих V равна сумме потоков из
текающих из V. Левая сумма то, что входит, правая то, что выходит. И это, понятно, должно выполняться для
всех вершин, кроме S и T, потому что в S вода берется из ниоткуда, мы ее туда отдаем столько, сколько
хотим, а вся остальная двигается без задержек, то есть у нас нету каких-то накопительных пунктов
в вершинах, и вода, которая целиком поступила, должна куда-то дальше пойти. Поэтому пишем такое
равенство, чтобы у нас поток нигде в вершинках не застревал. Так, вот что такое поток. Следующее
определение это остаточная сеть. Пусть у нас есть некая сеть и поток в ней.
Тогда можем определить остаточную сеть. Это интуитивно очень простая штука. Нам нужно оставить на
каждом ребре то, сколько по нему можно максимум пропустить. Вот если мы уже сколько-то пустили,
сколько поток уже по ребру течет, то в остаточной сети на этом ребре будет написана разность того,
сколько можно и того, сколько пустили, то есть то, сколько можно добить по этому ребру.
Значит, остаточная сеть. Будем обозначать ее уже с индексом f. Здесь множество вершин,
а также s и t те же самые. Множество вершин s и t сохраняются. Мы только меняем пропускные
способности и пишем, что пропускная способность под влиянием этого потока f с индексом f на
любом ребре. Это capacity в самом начале, в исходной сети, минус f и v. То есть как раз то самое,
сколько можно пустить, минус то, сколько мы пустили. Это есть остаточная пропускная способность.
При этом важное условие, что ребра нулевой остаточной
capacity мы не проводим. Ребра с нулевой остаточной capacity не проводятся. Пример.
Вот пусть есть исходный такой граф. Давайте считать, что изначально все capacity единички,
я не буду их писать. Напишу, что capacity везде единица. Пропускная способность всех ребер – это
единица. Ну понятно, какой в этой сети был бы максимальный поток. Надо пусть единичку здесь,
единичку здесь. Лучше, понятно, ее нельзя, потому что из s можно максимировать только две единицы
потока. Один сверху, один снизу. Но представьте, что какой-нибудь глупый алгоритм пришел и сказал,
а давайте-ка мы в самом начале пропустим единицу потока вот по такому пути, по такому неоптимальному.
Тогда что у нас от графа останется? Ну вот эти вот три ребра насадятся, то есть по ним больше
ничего нельзя будет передать. И останется только как два ребра, вот это и вот это. И просто используя
их мы, конечно, поток увеличить не сможем. У нас как бы несвязанный граф станет, из s мы никогда-то
не доберемся. Но за счет существования, во-первых, обратных ребер, вот за счет антисимметричности
потока и за счет того, что мы будем строить остаточную сеть, у нас появится в графе вот такое обратное
ребро. Потому что, смотрите, если у нас раньше сверху вниз текла единичка потока с capacity 1,
давайте я нарисую это ребро, было c единица, f единица, то есть и обратное ребро с capacity 0.
Мы вспоминаем, что все ребра, как бы не присутствующие явно в графе, имеют capacity 0.
И тогда поток, текущий по этому ребру, это минус один по антисимметричности. Если сверху
вниз один, то снизу вверх это минус один. Но, значит, в остаточной сети вот это ребро будет
иметь остаточную capacity единица. 0 минус минус 1 это единица. Значит, в остаточной сети у
меня появляется такой противоположный ребро снизу вверх. Поэтому, как минимум, в остаточной сети
после пропускания вот этой единички потока, вот такой кривой, у нас точно будет вот такой вот путь.
Значит, можно по нему будет пропустить единичку потока, вот такую вот. Ну и тем самым мы найдем
поток величины 2. А по этому ребру мы как бы отменим неправильную единицу потока, потому что мы
сначала ее здесь вот так вот пустили сверху вниз, потом отменили снизу вверх. Значит, здесь на этом
ребре потока нет, и мой поток расщепляется как раз в те самые две оптимальные единицы потока. Верхняя
доля и нижняя доля. Вот и, собственно, за этим и нужна остаточная сеть, потому что без нее мы,
в общем случае, не найдем оптимальный поток. Потому что там мы сможем найти какой-то блокирующий поток
такой, что больше его нельзя будет никак расширить без добавления вот этих обратных ребер, без отмены
каких-то неправильных решений, которые мы сделали. В исходном? Да, могут.
Ну, если есть в исходном графе вот такие противоположные ребра, то тут можно как угодно рассуждать,
если, например, здесь есть капасти 1, здесь есть капасти 2, то можно, не знаю, если совсем не думать,
можно ввести обратное ребро вот к этому ребру, то есть еще одно с капасти 0, и обратное ребро вот к
этому ребру, то есть еще вот такое ребро с капасти 0. В принципе, если мы в алгоритме все равно храним все
ребра как список исходящих, то нам не важно есть там кратные или нет, потому что поэтому можно
считать, что кратненькая такая. Либо, если мы не хотим вводить ненужные ребра, то просто можно считать,
что они обратные друг к другу, и по ним обязательно текут противоположные потоки, то есть в одну струну и в
другую минусов. Вот, и так вот, к чему это было, что остаточная сеть нам помогает сравнивать такую
теорему, которую мы чуть позже докажем. Теорема Форда Фалкерсона. Она утверждает, что построенный
поток максимальный, если только если в остаточной сети нет пути из С в Т. Поток Ф в сети G максимален.
Да, справедливое замечание. Давайте сформулирую, потом определю. Извините, это я неправильно сделал,
но все же. Значит, поток максимален, если как бы величина, в общем, сколько воды вытекает из С.
Если только если в GF нет пути из С в Т. Вот, то есть для поиска максимального потока,
то есть как раз тот самый исходный вопрос, который мы решаем, сколько можно воды максимум пустить из
С в Т, сколько можно передать водичке. Так вот, максимум достигается ровно в том случае,
если в остаточной сети нет пути из С в Т. Вот как вот здесь, когда я строил, если бы я вот это вот
ребро не проводил обратное снизу вверх, то у меня как раз не было бы пути, потому что было бы
такое ребро и такое ребро и все, и собственно больше ничего нет. Но в случае, когда я провел обратное
ребро, у меня появился путь, я по нему протолкну единичку потока и уже после этого не будет пути
из С в Т, потому что все вот эти вот ребра насыщенные, останется только вот такой ребро сверху вниз,
но оно, понятно, не влияет на связанность между С в Т. Вот. Эту тюремку мы чуть позже докажем,
потому что нужно еще вспомогать на определение.
Так, ну а величина потока как раз то, что я не сформулировал.
Величина потока это просто то, сколько воды течет из старта. Вот у вас есть стартовая вершина,
вы перебираете все остальные вершинки В и суммируете то, что написано на всех этих ребрах.
Весь вытекающий поток вы суммируете. Вот. Ну и соответственно поток максимален,
если его величина максимально. Максимально возможна среди всех возможных поток. Максимизируем
по величине потока. Вот. Эта тюрема очень похожа на самом деле на тюрему Бержа, которая была в
прошлый раз, что когда мы ищем максимальное просчитание, мы можем, ну в смысле, в двудольном графе.
Ну, на самом деле Берж в произвольном работает, но тем не менее. Значит, максимальное просчитание,
пардон, произвольное просчитание максимально, если только если относительно него нету чередующих
вот этих увеличивающих путей, что можно взять ненасыщенную и ненасыщенную, и там чередуясь по
ребрам из просчитания и не из просчитания дойти из одной в другую. Тут похожая вещь, что поток
максимален, если в каком-то там соответствующем графе нет пути. Вот. Окей, чтобы это доказать,
нужно еще определение вести разреза. СТ это разрез в СТЖ. Если С маленькое лежит на С
большом, Т маленькое в Т большом, а они в дизинктом объединении дают все множество вершин В.
То есть, ну у нас есть, да, какой-то исток, есть сток. Нам нужно все множество вершин разбить на два
непересекающееся множество, так что С в левом, а Т в правом. Вот это разрез. На что? Ну просто по
сути разбиение на два множества. Величиной такого разреза С от СТ мы будем называть просто сумму
всех capacity тех ребер, которые идут из С в Т. Сумма по У из С, В из Т, Т у В. Просто все возможные
ребра, которые идут слева направо, все-все-все мы перебираем и складываем на них capacity. Это будет
величина разреза. Ну по сути, как бы, сумма пропускных способностей всех ребер, которые пересекают
наш разрез, идут слева направо. И последнее определение, величина потока через разрез.
Это то же самое, только мы будем суммировать не Ц, а Ф. Поток текущий через разрез ФСТ. Это опять
сумма по У из С, В из Т, Ф у В. То же самое, как величина разреза, только мы суммируем вот здесь
не capacity, а потоки. Сколько потока вытекает из С большого и попадает в Т большое.
Так, Лемма, величина потока через разрез, она величине потока.
Если Ф-поток, а СТ это разрез, то величина потока равна величине потока через разрез.
Да, вот это то, сколько течет из С в Т, а это то, что мы определили просто
величиной потока. Сколько водички вытекает из С маленького. Это Лемма говорит, что поток
через разрез равен настоящему потоку. Та величина потока, которую мы определили,
она не зависит от того, какой брать разрез. Они все будут одинаковы и равны вот тому,
что мы определили моду Лев. Напоминаем, моду Лев это сумма по всем вершинкам ФСВ. И оказывается,
что какой бы поток вы не взяли, величина потока через него равна величине просто потока.
На пальцах это очевидно, понятно, что если у нас есть С маленького где-то здесь, есть сколько-то
потока из него вытекающего, то чтобы этот весь поток из-за свойства сохранения, он должен
как-то в Т переместиться. У нас поток в сети не накапливается, в вершинах поток не накапливается.
Значит, все, что отсюда вытекло, должно было рано или поздно сюда перетечь,
поэтому как бы вся эта водичка должна была пересечь разрез рано или поздно. Отсюда,
в общем, такое равенство возникает. Но это так, неформально. Формально давайте попробуем написать.
Так, что такое ФСТ? Ну, во-первых, совсем очевидно, что это ФСВ минус ФСС,
потому что, ну, собственно, вот в этой сумме у меня лишние слагаемые, это те,
когда У из С и В из С, я, соответственно, их здесь просто вычту. То есть, ну, я, ну, что
тест сначала расширил до В, понимаю, что я это расширю с помощью С, и это теперь вычитаю. Вот.
Дальше, вот эта штука, на самом деле, ноль. Эта штука ноль, потому что каждое ребро мы учтем два
раза, слева направо и справа налево. Вот есть какое-то множество С большое. Я здесь перебираю все
ребра УВ, такие, что У и В лежат в С большом. Ну и, соответственно, тогда в этой сумме есть и такое
ребро, и обратное ребро. Но из-за свойства антисимметричности поток текущий по ребру равен
потоку по обратному ребру. Значит, здесь все такие подойки равны нулю. Формально, давайте я это
запишу. Значит, ФСС, это что такое? Эта сумма по У и В из С, давайте У не равно В. Сейчас, не так.
Давайте напишу У меньше, чем В. ФУВ плюс ФВУ. Плюс еще будет сумма по всем вершинкам Х из С. ФХХ. Вот так. То есть у меня есть, как бы, пары, когда совпадают,
начало и конец, я их отдельно выделю. И есть пары, где начало и конец не совпадают, тогда я их могу разбить на
пары, где первая компонента меньше второй, и, соответственно, загруппировать УВВУ. Вот. Ну эта штука, понятно, ноль по
антисимметричности, просто по антисимметричности поток по УВ, плюс поток по УВ, это ноль. Они противоположны. Вот.
И эта штука тоже ноль, опять-таки, из-за антисимметричности, потому что ФХХ равно минус ФХХ. Опять, антисимметричность
можем поменять начало и конец ребра, вынеся минус перед значком Ф. Значит, единственное число, которое такому
уровню не удовлетворяет, это ноль. Поэтому поток, как бы, текущий из вершины в саму себя, это ноль всегда. Значит, это все будет нулем.
Итак, до чего мы довели себя, что ФСТ это ФСВ просто, потому что эта штука нулевая. Дальше давайте я С большое
раздобью на два множества. Множество, состоящее из С маленького и все остальное. С без С маленького и В.
Но опять, да, по линии, у меня здесь как бы написана большая сумма, когда первая вершина отсюда, вторая отсюда.
Я могу расщепить на две суммы, когда первая вершинка равна С маленькому, когда первая вершина не равна С маленькому.
Вот. Дальше. Это просто по определению мощность потока, величина потока, сумма по всем вершинкам В, величина потока из С в.
На это в точности величина потока, которую мы определили. А эта штука, хочется сказать, что это ноль.
Хочется сказать, что это ноль. Ну а это следует из втор... из какого там? Третьего свойства из-за сохранения потока.
Потому что, смотрите, для любой вершинки У из С без С маленького, что такое сумма по всем вершинам ФУВ?
Ну вот есть какая-то вершинка, да? Мы берем и рассматриваем исходящие вот такие вот потоки по всем, всем, всем ребрам.
По всем ребрам.
Так. Момент.
Сумма по всем исходящим ребрам. Я хочу сказать, что это ноль из-за свойств сохранения потока.
Вот. Ну это можно пояснить так. Значит, смотрите, есть ребра, которые в исходном графе действительно исходили из У.
А есть ребра, которые, наоборот, входили в У. То есть давайте я их разобью на две категории.
Те, которые реально исходят из У. И те, которые на самом деле входят.
Но когда я в этой сумме их беру, я по сути их беру с противоположным знаком.
Да? Потому что ребро было скажем из В в У, а я здесь его суммирую из У в В, т.е. беру противоположное.
Значит, вот в этой сумме я могу разбить все слагаемые на две группы — те, которые исходят из У, то есть те, которые соответствуют реально ребрам, исходящим из У, и те, которые соответствуют, наоборот, в ребрам, входящим в У.
Да, еще какие-то нули, которые соответствуют как бы не ребрам. Да, еще какие-то нули, которые соответствуют не ребрам.
Значит, ну и понятно, что сумма вот таких равна сумме
вот таких, вы берете и обращаете знак у вот этих,
потому что берете противоположное ребро, поэтому сумма обратится
в ноль.
Так, как я это могу расписать?
Давайте вот эту сумму, f у v, могу разбить на три множества,
сумма по a таким, что… Сейчас, момент, у меня бывают же
еще вот такие ребра.
Сейчас, на секунду.
Не оснущается случае как раз, что если в исходном
графе могут быть противоположные ребра, то есть ребро вот такое
и вот такое.
Давайте я формально напишу в случае, если в исходном
графе не было противоположных ребер, то есть из uv и vu одновременно
быть не может.
Давайте я это напишу.
Сумма по a таким, что uva это ребро в исходном графе,
fua.
Дальше, минус сумма по b таким, что bu это ребро в исходном
графе, fbu.
Ну и сумма по всем остальным таким, что не это, не ребро,
не это, не ребро будет fuc, но это понятное дело ноль,
потому что если нет ни одного ребра, ну не ребра
uc, не ребра cu, тогда эта штука будет нулем.
В общем, я просто формально расписал, что все вершины
разбились на два множества.
Те, в которых есть ребро, те, из которых есть ребро
и те, с которыми нет ребра ни в одной из двух сторон.
Тогда здесь будет нолик, а эти две суммы будут противоположны.
То есть я здесь вынес минус, потому что поменял местами
аргументы.
А эти слагаемые как раз-таки взаимно уничтожатся, потому
что в исходном графе то, сколько втекает, равно тому,
чему втекает.
Это все будет ноль.
Вот, тут нужно, смотрите, тут я не очень аккуратно
сделал, потому что бывают ребра.
Вот если в исходном графе есть такое ребро и такое
ребро, то по сути одна вершина мне должна попасть и в то,
что есть вот такое ребро и такое ребро.
Поэтому здесь нужно более аккуратно вот эти вершинки
разбивать.
какая-то вершина будет и там, и там, но тогда тоже понятно, что там, если, в общем, просто по
линейности, что если у меня там здесь сколько-то течет, и здесь сколько-то течет, то по обратному
течет, ну, противоположное количество, они все взаимно уничтожатся. Как-то так. Вот, ну все, значит,
эта штука ноль, вот эта ноль, и мы получили, что fst это равно величине как раз потока, что и требовалось.
Вот, теперь, наконец, мы можем, а нет, сначала нужна вторая лемма, но она совсем простая. Значит,
я утверждаю, что величина любого потока не превосходит величины любого разреза.
Вопрос к вам, как доказать?
Значит, ну, первый шаг, наверное, понятен, что мы знаем, что величина потока по предыдущей
лемме, это величина потока через разрез. И вот мы хотим доказать, что эта штука не превосходит
величины разреза, то есть суммы capacity. Тут мы суммируем потоки, хотим ценить сверху через сумму capacity.
Ну, это просто следует от того, давайте допишем просто по определению. Вот эта вещь,
это сумма по U из S, V из T, F у V, а эта сумма такая же, только C у V. Ну, понятно, здесь стоит такое
неравенство, потому что мы знаем, что для любой пары у V f не больше, чем C. То есть у меня по компонентно
просто каждая слагаемая здесь не больше, чем каждая слагаемая здесь, поэтому, когда мы все складываем по
одному и тому же множеству, мы получаем, что одна сумма не больше, чем вторая. Согласны? Вот, победа, то есть
любой поток не больше, чем любой разрез. Но более того, теорема, которую мы сейчас формулируем, утверждает,
что есть поток равный разрезу, и, соответственно, этот поток тогда является максимальным, а разрез минимальным.
Так, теорема, как раз Форда Фалкерсона в полной формулировке, утверждает следующее, что если же эта сеть
а f это поток в ней, то следующие условия эквивалентны. Во-первых, f это максимальный поток. То есть величина
f максимально возможна среди всех возможных потоков. Во-вторых, в остаточной сети нет пути из С в Т,
то есть наш поток нельзя увеличить простым проталкиванием потока в остаточной сети.
И, наконец, третья, величина f равна величине какого-то разреза.
Ну, доказываем. Из нинчки в двойку. Значит, почему, если поток максимальный, то в остаточной сети нет пути?
Ну, пусть не так, пусть есть. Тогда давайте протохнем по нему нинчку потока. Наш поток увеличится, значит, сходный был не максимальный.
Я не буду записать. Еще раз, если поток максимальный, но при этом в остаточной сети есть какой-то путь из С в Т, то есть какой-то путь из С в Т в остаточной сети.
Значит, все вот эти capacity положительны. В остаточной сети мы оставляем только ребра с нинолевой capacity, с нинолевой пропускной способностью.
Значит, все эти capacity положительны. Значит, по всем этим ребрам можно опустить как минимум нинчку потока.
Вот здесь играет целочисление, что если поток целочисленный, то здесь обязательно можно опустить нинчку потока.
Значит, мы его опускаем, тем самым мы на один больше потока выпустили из стартовой вершинки, из С.
Значит, поток увеличился. Противоречие с тем, что исходный поток был максимальный. Согласны? Вот. Ачев. Дальше. Два-три.
Что если нет пути, то поток равен какому-то разрезу. Ну, для этого этот разрез надо предъявить.
Давайте скажем, что С это множество всех вершин, которые достижимы из С в остаточной сети.
В достижима из С в остаточной сети GF.
Ну и, соответственно, Т это все кроме С большого.
Почему это разрез? Ну, понятно, что в С большом лежит С маленькая, просто по определению. Да, С маленькая достижима сама из себя, конечно же.
Вот. Но Т маленькая в С большом не лежит. Вот здесь нет Т маленького, потому что если бы она там была, то был бы путь из С в Т.
Соответственно, Т достижима из С противоречия с тем, что такого пути нет.
Значит, мы точно можем сказать, что С маленькая в С большом, Т маленькая в Т большом, потому что еще раз Т недостижима из С.
Значит, это действительно разрез. Выполняются вот эти свойства, и, конечно, в объединении дизюнк нам С и Т дают все В.
И мы хотим показать, что величина этого разреза равна величине нашего потока.
Так, ну, картинка.
Значит, мы знаем, что в остаточной сети...
Ну, давайте я нарисую вообще все ребра из С большой в Т большой. Вот я рисую все ребра.
Я знаю, что в остаточной сети. И вот эти ребра отсутствуют. Все эти ребра отсутствуют в остаточной сети.
Всутствуют в остаточной сети. Почему?
Ну, потому что если бы хотя бы одно из них присутствовало, то я мог бы мое С увеличить.
Что если это достижимо, и это ребро присутствует, то это величина тоже достижима.
Значит, ни одного этого ребра нету, иначе я мог бы расширить множество достижимых.
Но раз этих ребер нет в остаточной сети, значит их остаточная capacity это ноль.
Capacity это ноль. Cf это ноль.
Пропорционная способность, остаточная всех этих ребер, это ноль.
А значит, поток по ним равен их capacity в исходном графе.
По всем этим ребрам поток равен capacity. Ну, то есть мы будем называть эти ребра насыщенными.
Эти ребра насыщены, по ним течет максимально возможный поток.
Только в этом случае все они одновременно могут не присутствовать в остаточной сети.
Значит, на всех этих ребрах поток равен capacity.
То есть сумма из s, v, st, f, u, v равно такой же сумме t, u, v.
Потому что все потоки равны всем capacity.
Ну, а это по лимме равно величине нашего потока.
Это поток через разрез, а это просто поток. Мы знаем, что это одно и то же.
Просто.
Ну, и наконец с 3 в 1, что если наш поток равен какому-то разрезу, то он почему-то максимальный.
Ну, мне кажется, самое простое здесь доказательство такое.
Смотрите, мы знаем, что любой поток не больше любого разреза.
Величина любого потока не больше величины любого разреза.
Значит, если я значение напишу на consolid Cavitation aptitude всё, то у меня что будет?
У меня будет здесь вот потоки величины всех возможных потоков.
А здесь величины всех возможных разрезов.
всех возможных разрезов. И я знаю, что эти множества
отделены, что любой поток не больше любого разреза.
И при этом как-то так оказалось, что какой-то поток равен
какому-то разрезу. Ну тогда понятно, что все потоки должны
лежать левее, чем этот, а все разрезы правее, чем
этот. Если множества отделены, но при этом имеют общий
элемент, значит они по нему пересекаются, все потоки
меньше образно, чем он, а все разрезы больше, чем
этот. Это из-за того, что все потоки, любой поток
не больше любого разреза, ну по величине. Значит точка
их пересечения это одновременно точка, когда достигается
максимальный поток и при этом минимальный разрез.
Если f равно величине какого-то потока, то f это максимальный
поток, а st это минимальный разрез. Ну то есть разрез
минимальной величины, что сумма капасти ребер минимально
возможна. То есть мы не только нашли критерии максимальности
потока, но и при этом критерии минимальности разреза. Собственно
одно и то же. Это максимальный, а это минимальный. Так,
ну вот. Ну и отсюда наконец мы можем написать алгоритм
поиска максимального потока. Алгоритм Форда Фалкерсона
для поиска максимального потока. Алгоритм собственно
следует просто из теоремы. Пока в остаточной сети
есть путь, пожалуйста, найди его и протолкни по
нему поток. Пока в gf есть путь из s в t, протолкни по
нему поток. Больше такого протолкнуть поток. Значит
я нахожу некий путь, скажем там dfs, да, у меня есть явно
граф, вот эта вот остаточная сеть gf. Я в ней производным
алгоритмом, например, dfs нахожу какой-то путь из
s в t. На всех этих ребрах написаны какие-то остаточные
капасити с f. Значит можно сделать, например, следующее.
Можно взять минимальное среди них и протолкнуть
вот ровно столько потока по этому пути. То есть,
например, если тут какие-нибудь капасити там, не знаю, 3,
5, 2, 4, 7, то я беру минимальные среди всех этих остаточных
капасити, у меня будет 2. Это минимум по всем cf на
пути. И я двойку потока пускаю по этому пути. То
есть, здесь добавляю плюс два потока, здесь плюс два,
здесь плюс два, здесь плюс два и не забываю, что поскольку
у меня есть антисимметричность, то по обратному ребру я должен
добавить минус 2. То есть, здесь минус два потока, здесь
здесь минус два, здесь минус два, здесь минус два. Пустили максимально возможное количество потока
вдоль этого пути и не забываем, что нужно еще отменить поток справа налево. И здесь я
еще подпишу, что перестрой GF. Потому что поток изменился, значит должна была измениться
какие-то ребра могли появиться из-за того, что если опустил двойку потока по этому ребру,
то у меня точно возникает обратное ребро вот такое. Я могу эту двойку потом отменить.
Значит нам нужно не забывать, что иногда появляются обратные ребра.
Так, ну в примерчике давайте вот тот самый наш, который был в самом начале,
нарисуем. Если здесь везде копасть единички, то как может работать алгоритм Форда Фалкерсона?
Ну либо он сразу находит один путь и потом на второй итерации второй путь и дальше в
остаточности ничего не находит. Либо он сначала, мы же никак не уточняем, как именно мы должны
искать увеличивающий путь. Среди всех мы можем выбрать любой. В общем, какой DFS найдет,
по такому мы и продалкиваем поток. То есть здесь мы могли бы продалкнуть единичку потока
как раз по вот этому неправильному пути. Но если мы так сделаем, то из-за того, что мы остаточную
сеть перестраиваем, у меня возникает обратное ребро. Если здесь единичка потока, то здесь минус
один, то есть остаточная копасть единица. Там было ноль, а поток минус один, поэтому остаточная
копасть здесь единица. Ну и соответственно потом он находит вот такой вот путь, проталкивает по
нему единичку и тем самым находит максимальный поток равный двойке. Вот, картинка поинтереснее.
Тоже самое, только копасите здесь. Давайте какие-нибудь большие возьмем. 10 девятый,
10 девятый, 10 девятый, 10 девятый, а здесь единица. Тогда опять, если нам повезло и алгоритм наш
находит вот эти вот два пути, сначала этот по нему пускает 10 девятый потока, потом вот этот
по нему пускает 10 девятый поток, то мы за две итерации нашли весь наш максимальный поток.
Но если вдруг нам не везет и мы делаем вот такую вот глупость и пытаемся опускать единичку потока
вдоль такого пути, то мы действительно можем пустить только единицу потока. Потому что среди
всех вот этих копасите минимум это единица. Значит все, что я могу здесь пустить это один.
Окей, значит за одну итерацию я пустил единицу потока здесь. Теперь дальше в остаточной сети
появляется опять-таки вот это обратное ребро и единственный путь из SFT это вот такой. То есть
нам нужно будет отменить здесь единицу потока. Но опять только единицу, потому что копасти
останется один. Почему? А, да, да, да, да, вы правы, можно было бы вот так. Окей, тогда не единственный,
но вот один из, еще раз, мы не специфицируем. Вот один из тех, по которому можно пустить,
это вот этот. Ну берет он, вот так пускает. Тем самым мы за две итерации пустили здесь единицу
потока и здесь единицу потока. Здесь как бы пустили и отменили. И соответственно количество
итерации может достигнуть два на десять девятый. Каждая итерация плюс единица. Суммарно в конце
будет два на десять девятый поток. Вот, поэтому даже на таком маленьком графе, там из четырех вершин,
количество итерации может быть большим. Давайте. Сейчас, ну смотрите, когда я пускаю единицу вот
такую потоку, у меня вот здесь становится поток единицы и капасти была единица. Но также у меня
всегда, не забываем, если ребро я не рисую, на нем имеется в виду капасти ноль. Но если капасти ноль,
а по этому ребру текла единица потока, то значит по обратному поток минус один из-за антисимметричности.
Если сверху минус один, то снизу вверх минус один. А значит разность этих величин это единица.
Поэтому всегда, если у меня вот здесь вот единица протекла, то немедленно появляется обратная
с капастью один. Вот, ну и собственно по нему мы как раз этот поток будем отменять. То есть мы
единицу сверху вниз пустили, потом снизу вверх пустили, тем самым как бы отменили то, что здесь
текло. Ну и так будем много-много раз итерироваться. Вот, поэтому лучше, что здесь можно написать в
терминах азимтотики. Это, ну я напишу f на e, где f это та самая собственно величина МАКС потока,
а это число Ребер. Потому что, ну как мы видим, на каждой итерации в худшем случае нам придется
проталкивать единицу потока, и если всего поток нам равен 2 на 29, то итерация может быть 2 на 29.
Вот, а это время работы по сути DFS. Нам нужно из s попасть в t, время работы можно ограничить там
числом Ребер просто. То есть здесь там формально надо писать v плюс e, можно изначально там отсечь
от графа то, что недостижимо из s, оно тогда никогда не будет достижимо, и тогда множество
вишен будет не больше множества Ребер. Основной здесь слагаемый будет e. Вот, значит это азимтотика
алгоритма Форда Фалкерсона, и она действительно достигается. То есть если мы никак не говорим,
какой путь выбирается, то в худшем случае мы будем делать ровно f итераций.
Так, это можно пофиксить с помощью алгоритма Эдманца Карпа.
Значит он звучит так. Делай все то же самое, только путь, по которому ты пускаешь поток,
всегда выбирай коротчайшим путь слоя Ребер. Делать то же, что в алгоритме Форда Фалкерсона,
только выбирать коротчайший путь, ну коротчайший путь слоя Ребер.
То есть ведем такую спецификацию, что каждый путь, который мы выбираем, это один из коротчайших
путей из СВТ, восстанчивой сети. То есть вместо ДФС мы будем пускать БФС. Чтобы найти коротчайший
путь, мы будем просто пускать БФС. И все, больше ничего не принято. То есть опять, просто пока есть
путь, мы находим коротчайшие из них и пускаем поток. И тогда утверждается, что азимтотика
здесь будет ВЕ квадрат. Где В это число вершин, а Е это число Ребер. То есть вот такая простая
модификация нам позволяет избавиться от зависимости от величины потока. Тут будет азимтотика ВЕ квадрат.
А, ну да. Собственно, опять давайте примерно рисуем вот это вот. В нашей сети вот такой,
на первом же шаге, что как бы неправильного делали форда Фалкерса? Мы брали вот такой путь и
пускали по нему денечку потока. Но в Эдманскарпе такого уже не будет, потому что этот путь имеет
длину 3 по числу Ребер, а эти пути будут иметь длину 2. Поэтому, по крайней мере, вот на этом графе у
нас не будет такой проблемы, что мы будем там 2 на 10, 9 раз пускать такой путь, потом его отменять,
пускать, отменять, пускать, отменять и так далее. Мы сразу пустим максимальный поток здесь,
максимальный поток здесь. Потому что они имеют длину 2, а вот этот промежуточный через вот это
перемычное ребро имеет длину 3, поэтому мы его никогда даже не рассмотрим. Сейчас будем доказывать,
это нетривиальный факт. Сейчас будем доказывать. Вот, то есть смотрите, корректность понятна,
алгоритма очевидна, потому что это просто модификация алгоритма Форда Фалкерса. Мы
ищем какой-то путь в восстаженной сети, пока он есть, и пускаем по нему поток. Алгоритм заканчивается,
только если в восстаженной сети нет пути, то есть поток максимальный по теореме. Корректность
здесь все понятна, если алгоритм закончится, то он нашел максимальный поток. Теперь будем доказывать
симптотику. Будем доказывать симптотику с помощью нескольких лям. Лемма первая. Пусть F и F',
два последовательных потока в алгоритме Эдманса Карпа. Да, в алгоритме Эдманса Карпа. Дальше,
пусть D от V это DIST в графе GF из S в V, а D' от V это DIST GF'SV. DIST это вот то самое
кратчайшее расстояние от вершинки S до вершинки V, например, S это исток. И мы меряем кратчайшее
расстояние в двух как бы последовательных остаточных сетях. Первое расстояние в GF,
второе в GF'. Вот как бы у меня был поток F, я прокнул путь, получился F', и вот я смотрю,
как поменялись мои остаточные сети и как поменялось в них кратчайшее расстояние от S. Так вот тогда
для любой вершины это расстояние могло только увеличиться. Что если я протокнул сколько-то
потока в остаточной сети, получилось F', то кратчайшее расстояние в новой остаточной сети
могли только увеличиться по сравнению со старым. Доказательства. Пусть не так. Пусть для какой-то
вершины вот эта штука уменьшилась. То есть пусть нашлась какая-то вершина, для которой здесь значок меньше.
Тогда давайте среди всех вершин, для которых это неравенство нарушается, возьмем ту, для
которой D' от V минимально возможно. Тогда среди всех вершин D' от V меньше D' от V выберем ту,
для которой D' от V минимально возможно. То есть у нас вот это неравенство могло выполняться для
нескольких вершин. Среди не всех возьмем ту, у которой D' минимально возможно. Если их несколько,
то возьмем любую. Так, хорошо, давайте тогда нарисуем этот самый путь, кратчайший из S в V в
остаточной сети GF'. Вот есть старт, есть какой-то кратчайший путь из S в V сети GF'. Здесь достигается
то самое D' от V минимально возможно, при котором D' от V меньше, чем D' от V. Значит первое
замечание такое, V не равно S, так как D от S равно D' под S равно 0. Вот эта вершина, которую я выбрал,
не может совпадать со стартовой, потому что для стартовой понятное дело обе эти штуки нулевые,
и соответственно это неравенство не может выполняться. Потому что кратчайшее встание от S в S это 0,
не надо проходить ни одного ребра. Значит они различны, значит я могу корректно определить
предыдущую вершину на пути. Если они различны, то корректно предназначу предпоследнюю вершину на
этом пути. Пусть U это предпоследняя вершина на кратчайшем пути из S в V сети GF'. Вот такая картинка,
вот был путь из S в V, U это предпоследняя вершина на этом пути. Давайте запишем все,
что мы знаем про вершину U. Ну во-первых, раз U это предпоследняя на кратчайшем пути, то однозначно
можем сказать, что D3 hatu плюс 1 это D3 hat v. Потому что раз она предпоследняя, то она лежит на кратчайшем
пути, поэтому кратчайший путь до нее увеличен на 1 ребро это как раз кратчайший путь до v. Из-за того,
что она лежит на кратчайшем пути. Но с другой стороны отсюда следует, что D3 hatu строго меньше
D3 hat v, а значит D3 hatu больше равно D hatu. Потому что среди всех вершин, для которых вот это не
выполнялось, мы взяли вершину с минимальным D3 hat v. Поэтому если мы рассмотрим U, для которой D3
меньше D3 hat v, значит для нее вот это неравенство должно выполняться. Вот как бы в обратную сторону
не может, потому что иначе мы вместо v должны были бы взять U, значит должно выполняться вот это.
Так вот что мы знаем про вершинку U. Теперь зададимся вопросом, откуда вообще вот это
вот ребро находится в оснащенности GF'. Откуда ребро U, GF'. Тут есть два случая. Первый случай,
если это ребро присутствовало в сети GF и собственно осталось, то есть оно было в предыдущем в предыдущей
оснащенности, и осталось после пропускания единички потока. Ну или там не единички,
а какого-то потока вдоль пути. Значит первый случай, ребро УВ было в GF и осталось в GF'.
То есть оно было и осталось, оно никуда не пропало и ниоткуда не появилось. Оно было и осталось.
Так, но если оно было раньше, тогда мы точно можем записать, что dV не больше, чем dU плюс 1.
Потому что если это ребро присутствует в GF, тогда кратчайшее расстояние dV гарантированно не
превосходит кратчайшее расстояние dU плюс 1. Ну раз есть ребро, то можем всегда дойти сначала
с dU, потом с помощью этого ребра дойти до V. Значит точно есть такое неравенство. И вот я утверждаю,
что теперь здесь где-то написано противоречие. Что если собрать все, что мы сейчас написали,
то вот это должно найти нам где-то противоречие. Ну давайте продолжать вот эту цепочку. Значит dU
не больше, чем dU плюс 1. Дальше мы знаем, что dU не больше, чем dU. Поэтому здесь можно написать
dU плюс 1. И наконец мы знаем, что dU плюс 1 это в точности dV. То есть dV не больше dV. А это
противоречие с выбором вершинки V. Мы взяли вершинку V такую, что для нее d' меньше, чем dV.
Противоречие. Согласны? Хорошо, второй случай. Возвращаемся к вопросу, откуда у V в этой
оснашенной сети. Мы понимаем, что оно не могло, раз первый случай не валиден, это ребро не могло
быть в GF. Но оно же откуда-то взяло в GF штрих. Его не было раньше, но оно появилось. Как ребро
может возникнуть в оснашенной сети? Только если по обратному ребру протокнули поток. То есть что,
второй случай. Этого ребра не было в GF, но оно появилось в GF штрих. Значит по обратному ребру
протокнули поток. Потому что если у меня было ребро VU, и я по нему проталкиваю поток, то у меня
гарантированно с положительной capacity появляется обратное ребро. Потому что здесь был какой-то
поток, здесь минус поток. Если здесь была нулевая capacity, то оснашенная capacity это плюс F, то есть
положительная величина. То есть возникнуть это ребро могло только в случае, если я проталкиваю по
обратному вот этому ребру VU поток. Хорошо, но раз я проталкиваю по такому пути поток, то из-за того,
что мой алгоритм всегда находит кратчайший путь для проталкивания потока, мы знаем, что dA2 это dA2
плюс 1. Раз Edmund Scarp проталкивает поток по кратчайшему пути, и это ребро он, собственно, задействует,
то есть проталкивает по нему поток, значит это ребро лежит на кратчайшем пути из SFT, поэтому вот
эта штука на ничку больше, чем вот эта. Ну раз это кратчайший путь, то здесь все вот эти вот d's
возвращают на единицу. Окей, ну и здесь тоже из-за этого равенства тоже можно извлечь
какое-то противоречие с тем, что мы уже написали здесь. Ну смотрите, dA2 не больше, чем d'A2.
Так, а d'A2, что мы знаем про d'A2? Значит, видимо, сначала надо написать, что это,
то противоречие, сейчас, секунду, подсмотрю.
Давайте d'A2 распишем, что d'A2 это d'V-1 получается. Мы оценили d'A2 через d'A2, потому что вот
оно там написано, а дальше d'A2 расписываем как d'V-1, потому что вот тоже слева сверху написано
вот это равенство. Значит, что мы получили? Вот это d'A2-1 больше обравно, чем d'A2-1. Значит,
d'A2 больше обравно d'A2 плюс 2. Ну это опять противоречие, потому что мы предполагаем,
что здесь неравенство в обратную сторону, d'A2 меньше, чем d'A2, а тут получили, что h больше
плюс 2. Ну все, опять противоречие с выбором вершинки V. Значит, наше исходное предположение
неверно, раз мы во всех случаях пришли к противоречию, поэтому нет ни одной вершинки,
для которой вот это неравенство бы выполнялось. Значит, действительно, для любой V d' может
только возрасти, ну не строго возрасти. Вопросы? Хорошо. Тогда вторая лемма.
Будем говорить, что ребро насыщается, если после проталкивания очередного потока вдоль пути
оно становится насыщенным, то есть у него становится f равно c. Говорим, что ребро насыщается,
если после проталкивания очередной порции потока, да, у меня же как бы много итераций,
если после проталкивания потока вдоль пути становится c равно f. То есть раньше не было,
а теперь стало. Раньше поток был меньше, а теперь стало. Ребро как бы насытилось,
мы исчерпали полностью его возможности. Вся capacity теперь как бы задействуется,
мы не можем больше по нему увеличивать поток. Так вот, лемма утверждает, что любое ребро
насыщается от v раз, максимум. Тогда любое ребро может насытиться не больше от v раз.
Где v? Это число вершин.
Так, ну почему это верно? Доказательства. Давайте рассмотрим какое-то конкретное
ребро из uv и посчитаем сколько раз оно могло насытиться. То есть что такое вообще? Как оно
может насытиться несколько раз? Ауч просто. Мы сначала могли пустить какой-то поток по нему и
это ребро насытить, соответственно в остаточной сети возникает обратное ребро. И потом, чтобы uv
опять насытилось, то есть мы его сначала как бы должны раз насытить, оно должно перестать насыщенным,
то есть мы должны сначала протолкнуть какой-то поток по обратном пути. Значит потом опять это
ребро uv появляется в остаточной сети и мы его опять насыщаем и так как можно больше раз пытаемся
сделать. Сначала насытили, оно пропало, потом чтобы его опять насытить нужно его как бы вернуть
сначала в остаточную сеть. То есть сначала нужно протолкнуть пусть по обратному ребру. Вот это самое
главное здесь наблюдение. Чтобы протолкнуть, sorry, чтобы насытить ребро uv два раза,
надо сначала протолкнуть поток по обратному ребру. Протолкнуть поток по ребру vu. То есть
между каждыми двумя последовательными насыщениями происходит хотя бы одно как бы проталкивание в
обратную сторону. Насытили, потом раз насытили в обратную сторону. Насытили, раз насытили и так
далее. Вот ну и здесь смотрите, мы же как бы если проталкиваем поток по какому-то пути, то это
обязательно всегда кратчайший путь из sft. Алгоритм Эдманс Карпа всегда находит кратчайший путь и
значит если он это ребро задействовал или это ребро задействовал, то он обязательно лежал на
кратчайшем пути. То есть сначала вот это было кратчайший, потом вот такой был кратчайший,
потом опять этот, возможно с какими-то изменениями, но опять через uv проходящий,
потом вот такой обратный через vu и так далее. Вот, ну тогда смотрите, если у меня изначально было,
что uv лежало на кратчайшем пути, то я знаю, что d от u плюс 1 это d от v. Да, раз изначально в первый
раз, когда она насытилась, у меня uv это ребро кратчайшего пути из sft, значит выполняется такое
условие на, собственно, конце этого ребра. Это когда оно в первый раз насытилось. Дальше, когда
оно раз насыщается, то есть мы проталкиваем поток по обратному ребру, вот по такому vu. У меня уже
наоборот, vu это ребро кратчайшего пути. То есть в момент, когда я раз насыщиваю моё ребро, должно
выполняться d' от v плюс 1 равно d' от u. А вот если вот это вот это d, а вот это d'. То есть когда я
его насыщал, у меня происходит d, а когда я его раз насыщу, происходит d'. d' это расстояние от старта
до вершинки. Вот, значит тут выполняется такое. Наоборот, раз это ребро кратчайшего пути, то
выполняется такое равенство. Но при этом мы знаем, что d' всегда больше 0, чем d' от v, например.
По предыдущей лейме кратчайшие расстояния до всех вершин могут только увеличиваться.
Ну да, тогда я могу написать такую цепочку. d' от u равно d' от v плюс 1,
больше равно d' от v плюс 1 равно d' от u плюс 2. То есть, смотрите, мораль какая. Перед тем, как я
смогу во второй раз насытить это ребро, у меня d' от u должно вырасти хотя бы на два по сравнению
с d' от u. Иными словами, между двумя последовательными насыщениями ребра d' от старта вершины этого
ребра, то есть d' от u, увеличивается хотя бы на два, чтобы стало d' от u. То есть, кратчайшее
расстояние до начала ребра увеличивается хотя бы на два, чтобы оно насытилось во второй раз. Ну и
так далее. Если я там посмотрю интервал времени от второго насыщения до третьего, то работает
то же самое. И значит, между вторым и третьим насыщениями у меня опять d увеличится хотя бы
на два. То есть, было d' от u, это хотя бы d' от u плюс 2. Дальше d' от u будет хотя бы d' от u плюс 2.
Ну опять, хотя бы на два выросло. Ну и так далее. Ну и понятно, что d не может расти больше, чем число
вершин. Раз у меня всего в графе v вершин, тогда d, оно всегда как бы, d долевой вершинки x не больше,
чем видимо v-1. Может, на кратчайшем пути всегда не больше, чем v-1 ребра. Нет смысла там петлять
по каким-то циклам, кратчайшее состояние всегда не больше, чем v-1. Ну и все, раз у меня вот эта
штука каждый раз увеличится хотя бы на два, но при этом ограничена сверхучислон вершин, значит,
количество насыщения это v пополам максимум. Ну там, плюс один может быть. То есть, вот f.
Давайте эту катку запишу.
Значит, чтобы насытить ребро еще раз,
d от u должно увеличиться хотя бы на два.
Но d от u всегда ограничено от v, значит, число насыщения есть от v.
То, что требовалось.
Вопросы?
Хорошо. Ну вот, мы доказали нашу вторую лему, что каждый ребро насыщается не больше, чем от v раз.
Ну и, наконец, следствие, что алгоритм Edmonds-Carp работает за v-e квадрат. Сейчас уже будет это
просто. Работает за v-e квадрат. Ну смотрите, мы знаем, что каждое ребро насыщается максимум v раз.
Ну v пополам, на самом деле, от v раз. Каждое ребро насыщается максимум v раз. Вопрос.
Сколько тогда всего суммарно может быть насыщений? Ну понятно, если всего e ребер, то суммарно
насыщений может быть v-e. Но понятно, что каждая итерация алгоритма обязательно насыщает хотя бы
одно ребро. Потому что как работает итерация алгоритма? Мы выбираем крышейший путь, выбираем
среди всех осадочных капаситей минимальную и пускаем, собственно, этот поток. Поток такой
увеличенный по этому пути. Значит, хотя бы одно ребро обязательно насытится. Раз я среди всех этих
капаситей выбрал минимальную и пустил ее, то вот то самое ребро, на котором была минимальная
капаситет, теперь насытится. Я ее добил до максимума. То есть я по этому пути пускаю максимально
возможное количество воды, то есть хотя бы одно ребро обязательно насытится. Иначе я мог бы увеличить
поток. То есть каждая итерация насыщает хотя бы одно ребро. Но раз всего насыщений максимум v-e,
то итерация максимум v-e. Значит, каждая итерация алгоритма насыщает хотя бы одно ребро.
Значит, итерации максимум от v-e. Итерации от v-e. Ну все, если итерации столько, то что
такое итерация? Это bfs по сути. Просто bfs и по этому пути надо что-то протолкнуть. Итерации столько,
время работы bfs это от e, ну вообще v плюс e, но опять повторюсь, v мы считаем что не больше,
чем e, этого можно добиться просто отрезав все, что недостижимо. Тогда e будет по порядку такой же
как v, хотя бы. Значит, вот столько итераций, каждый работает за от e, потому что это bfs,
перемножаем, получаем v-e квадрат. Ну вот теперь доказали. Нет, конечно,
ну в смысле на каких-то графах, конечно, может только работать, но зачастую это прям очень такая жирная
оценка сверху. То есть, если вы там построили какой-то граф и пустили на нем Эдман Сакарпа,
то скорее всего у вас будет что-то сильно меньше, чем вот это. То есть, да, существуют конкретные
графы, на которых такая симпотика достигается. Но на реальных, грубо говоря, графах, конечно,
будет все сильно приятнее, чем вот эта вот верхняя оценка. Потому что, ну что, что такое как бы худший
случай, да, это когда на каждой итерации ровно одно ребро насыщается. Ну если у вас, скажем там,
capacity все это, не знаю, там единички или двойки, то у вас довольно много может ребер сразу насыть
на одной итерации. Например, так вот. И, конечно, там будет симпотика сильно лучше, чем это. Так,
хорошо, давайте тогда пример с задачкой посмотрим. Пример, пример. Пример с задачкой, которая,
на первый взгляд, вообще не имеет ничего общего с потоками. Значит, смотрите, пусть есть n человек,
есть n человек. Мы их должны распределить по двум профессиям. Ну, пусть будут математики
и программисты. Значит, каждый человек должен стать либо математиком, либо программистом,
и при этом каждый в каком-то смысле не любит ни то ни то. То есть, каждый предпочитает сидеть на
диване, и он как бы, его недовольство от профессии математика это какое-то число, от профессии
программиста это какое-то другое число. То есть, в идеале он ничего не хочет, но, к сожалению,
придется. Значит, всех хотим заставить работать. Математиком или программистом.
Значит, соответственно, у каждого человека есть недовольство своей будущей профессии математика,
своей будущей профессии программиста. У Итого недовольство, а Итая быть математиком,
и Б.И.Т. быть программистом. То есть, если его на одну из этих двух профессий назначают,
то он недоволен вот на такую-то величину. Вот, и более того, у нас есть некие пары дружащих
людей. Дружба заключается в следующем. Если Итого и Житого ребят назначают на разные профессии,
то они недовольны на Ц.И.Т. и Ж.Т. То есть, они как бы хотят работать вместе. Если их разлучили,
то суммарное недовольство увеличится на какую-то величину. Для некоторых пар и Ж.Т. есть
недовольство тем, что их разъединят и назначат на разные профессии. Есть недовольство Ц.И.Ж.
если их назначат на разные профессии. Вот, и наша задача, конечно, это разбить всех ребят на
математиков-программистов так, чтобы минимизировать суммарное недовольство. Минимизировать
суммарное недовольство. Каждому назначать профессию так, чтобы суммарное недовольство
своими профессиями плюс суммарное количество вот этих вот расставаний и других было как можно
меньше. Так, вопрос у меня к вам. Смотрите, сегодня мы пытались искать максимальный поток. А здесь
нужно найти что-то минимальное. Как можно, типа, с помощью того, что мы делали, искать минимум,
а не максимум? Ну вот, капасти, к сожалению, минус один намного не очень хорошо, потому что
когда капасти будут отрицательные. Да, давайте сейчас все эти штуки больше на нуля. Что? Да,
мы на самом деле вспоминаем факт, что максимальный поток равен минимальному разрезу. И более того,
если мы нашли максимальный поток, то мы знаем минимальный разрез. По величине, по крайней мере.
Значит, вместо максимизации потока мы будем искать минимальный разрез. Вот, ну тогда сеть будет
такой. Мы вводим искусственно вспомогательные вершины С и Т, которые не соответствуют нашим людям,
а просто вспомогательные вершины С и Т. И дальше проводим следующие ребра. Значит, смотрите,
если есть два друга, которые хотят быть вместе, то мы проводим два ребра в обе стороны с капастью
С и Ж. Соответственно, если тогда мы их как бы рассечем, да, и как бы наш разрез это как раз
разбиение на два множества. С и Т. Так вот, если мы их рассечем и не будут в разных множествах,
то как раз одно из этих ребер даст нам неудовольство С и Т и Ж. Теперь для каждого чувака Х мы еще,
давайте проведем вот такое вот ребро, а Х. Тогда если оно рассекается, и соответственно Х не в С,
то он недоволен тем, что он математик. И для каждого также человека мы проведем ребро
с капастью B и Y из Y в T. Тогда если разрез пересекает это ребро, то это недовольство тем,
что он стал программистом. Хорошо, тогда смотрите, вот пусть я построил в этом графике
какой-то разрез. Какой-то разрез. На какие ребра этот разрез пересекается? Ну, во-первых,
будут какие-то такие пары, которые я пересек, то есть будут какие-то вот такие С и Т и Ж. То есть,
если я вот этих всех назначаю программистами, а этих математиками, то у меня возникает некоторое
недовольство вот этих двух людей, что они не в одной команде. Дальше есть вот такие ребра из вершины
Y какой-то в Т. То есть, если я человека отнес к первой доле, к С большому, то у меня возникло
недовольство тем, что он B и Y, то есть он программист. Давайте считаем, что вот это все ребята это
программисты, а эти математики. Тем самым, если мы человека отнесли к программистам,
недовольство общее увеличилось на B и Y. Ну, то, что нужно. И, наконец, бывают вот такие ребра,
а X. Это недовольство тем, что его назначили математиком. А это как раз множество математиков.
Тем самым, смотрите, что мы показали. Мы показали, что каждый разрез, то есть, по сути, просто каждое
разбиение наших людей на два множества математиков-программистов, каждый разрез по величине
равен вот с точностью недовольству такого разбиения. Величина разреза
СТ равна суммарному недовольству.
Если S это программисты, а T это математики. Вот, значит, если мы хотим минимизировать это
недовольство, то мы просто в этой сети находим максимальный поток. Его величина равна минимальному
разрезу по величине. И это, собственно, и есть ответ. То есть, по сути, чтобы найти ответ,
нужно просто в этой сети найти максимальный поток и вывести это как число. Удивительным
образом, эта штука, то есть максимальный поток, равен минимальному недовольству.
Ну, тогда на этом все. Спасибо.
