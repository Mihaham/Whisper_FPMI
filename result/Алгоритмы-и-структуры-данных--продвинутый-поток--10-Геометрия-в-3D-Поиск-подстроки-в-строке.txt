Пришло нам время вывести из плоскости и попробовать посмотреть на мир в трёхмерии.
Ну давайте сначала, да, можно просто для начала разомнуться. А что у нас в трёхмерии вообще есть?
Ну самое тупую, что есть, это, конечно, точка. Она же вектор. Ну как всегда. Так, спрашивается,
ну ещё на этих векторах есть. Ну что с этими векторами можно делать? Ну у векторов есть,
конечно же, его величество скалярное произведение, которое по мистическим причинам
меряется абсолютно таким же образом. Ну как таким же образом, да. То есть, на самом деле,
определение можно такое ввести в абсолютно любом пространстве, ну а потом уже сидеть и
доказывать, что это там какое-нибудь там произведение модулей на кассивус,
угла между гиметом, бла-бла-бла-бла-бла-бла. Что-то нас мало стало. Кто-то исчез? Не до жизни.
Ну, впрочем, да. Вы уже сдали экзамен по линалу, ещё раз нему апеллируем. И тогда вы знаете,
что с векторным произведением, ура, наконец-то мы можем употреблять это слово сочетание в честно,
здесь уже немножко не то. А что такое векторное произведение? Да, начнём с того, что это вектор.
Какой-то мистический вектор В, который как устроен? Ну, мы знаем, что модуль В равен чему. Ну, как
всегда, модуль В1 на модуль В2 на что? На синус. На синус, угла между ними. Так, на всякий случай,
модуль синуса напишем. При этом, понятно, В перпендикулярно В1 на В2. Да, В перпендикулярно В1 и В2.
И последствия, что В1, В2, В образуют положительную диаметрию 3. Да, что это значит? Означает это
следующих. Если у нас действительно, скажем, как бы мы видим, что действительно у нас поворот от В1
и В2 идет как бы против часовой стрелки, ну, мы всегда можем правильно там либо с этой стороны
посмотреть, либо вот с этой вот посмотреть и увидеть, что вот там. То есть, если когда мы видим,
что В2 как бы надо повернуть влево, то соответственно тогда, то есть в эту сторону,
собственно, этот вот вектор В и пойдет. Как бы физики в этом месте упребят словосочетание правила
Гуравчика. Вот, математики. Как там? Левая тройка векторов, да? Или правая? Правая. Ну да, скорее правая.
Вот, ну приятно, конечно, что тем не менее, конечно, всякие свойства линейности, естественно,
у них сохраняется. Ну и, конечно, маленькое приятное свойство мы говорим перпендикуляр.
Обычно, конечно, перпендикуляр к двум векторам, по крайней мере, направление его с точностью длины
определяется однозначно, ну, по крайней мере, может там, ну не длина, она может
быть типа отрицательной.� competently в доль какой-то прямой он будет смотреть,
определяется однозначно, но только в том случае, если эти вектора неколинеальны. А что делать,
если эти вектора колинеальны? В этом случае угол между ними либо 0, либо 180, и тогда просто
векторное произведение становится нулевым вектором. Так, ну вот, в принципе, уже разомнулись.
Что у нас есть еще? Ну, по идее есть еще. Ну, помимо точки, смешанная. Ну, вообще говоря, есть,
но да. То есть, как бы теперь нам, опять, Зелосовский вопрос, в какой момент нам понадобится именно смешанная,
как смешанная? Потому что, да, в принципе, действительно можно говорить, что если у нас есть тройка векторов,
то, действительно, у нее есть такое понятие, как смешанное произведение. Оно как-нибудь обозначается?
Через скрубоскопочки? Нет, понятно, что можно написать вот это вот все. Можно просто скрубоскопочки
и три вектора внутри, без квадрата. Так тоже пишут. Окей, спасибо. Либо В. Еще буквку В можно написать,
как объем. Ну да, мы помним, что да, это имеет смысл то, что это объем параллелепипеда, натянутого на эти три вектора,
ну, с оговорочкой, что, как всегда, ориентировано. Да, что ориентировано, что если тройка правоориентирована,
то он будет положительный, если левоориентирован, то отрицательный. Да, есть такое, да. То есть, часто
мы этим будем пользоваться на тему того, там, например, что если у нас есть плоскость, в какую сторону
действительно вектор от нее торчит. Да. Впрочем, прежде чем ввести плоскость, неплохо было бы ввести прямую.
А как ввести прямую? А что есть? Ну и какие варианты? Каноническое уравнение. Каноническое уравнение прямой
в пространстве, но это которое через три дроби, рамы, которые у нас есть.
Х минус Х ноль делится всё. А вот это, да. Это да, это ужасно. Есть векторы на уравнении, есть, например,
метрическое уравнение, есть там еще куча разных уравней. Ага. Как говорится, зачем они нужны?
Зачем нужны? Потому что ровно в этом месте, казалось бы, у нас возникает, что давайте скажем, что прямая,
это вот такая вот уже знакомая нам в плоскости штука. Ну да, это одно и то же. Ну да. Ну переписать можно
всё, что угодно, а суть одна. Да. Нет, так-то можно задавать как угодно. Да, можно задать так. А, причем там
еще какие-то оголовки, что иногда тут бывает ноль, да? Да, бывает ноль, и тогда мы считаем, что это тоже
ноль. Ну что, так-то, конечно, можно задавать, потому что так-то можно прямую задавать вообще хоть там,
дана плоскость, простите, дана точка. И прямая говорит, что надо прямая должна проходить через эту точку
и быть припетикулярна этой плоскости. Да, не говоря вообще о том, что прямую можно задавать как пересечение
двух плоскостей. В общем, ладно. Это, ну вот, как говорится, думается этого мяса у вас в домашнем задании
было на вал, я думаю. Вот, ну поэтому давайте лучше тогда более веселый вопрос. А как, собственно, задать плоскость?
Как задать плоскость? Ну, на самом деле так. Ну, в первую очередь, да, как ее задать? Можно, да, да,
или ну вот. То есть, ну по идее можно ее задать, ну, для нас, наверное, самый классический способ это, конечно,
задать ее как точку и двумя направляющими векторами, например. Ну, по идее по трем точкам можно сделать.
Да, естественно, только требуется, чтобы три вектора, два вектора были, конечно, неколлиниарны. Вот.
Ну и тогда как можно задать плоскость? Тогда плоскость можно задать действительно как P0 плюс T V1 плюс U V2, да,
T U, значит, вот такое вот. А можно как множество таких точек P, что, значит, там, что V1, V2, допустим, P0,
значит, P-P0 равно нулю. Вот. Ну, фактически, вот аналоги задания. Понимаете, мы так прямую, прямые такие вот так задавали, помните, да?
Нет, кстати, это очень удобно, потому что теперь, если у вас есть, кстати, теперь пересечь прямую плоскость, обратите внимание,
теперь вам становится достаточно легко. Ну, если прямую задать вот в таком рите, а плоскость вот в таком, то, собственно,
вот P плюс VT вот сюда подставляем, решаем линейные выравнения. Ну, собственно, ритм уже загимались.
Так, единственное смешанное произведение линейно по своим членам. Ну да, естественно. Так что да, ура, тут можно, то есть,
то есть, вот получается, действительно, красота. Хорошо. Ну вот. Так, тогда вопрос посложнее. Да, ну или аналогичным образом можно пересечь прямую и сферу.
А так абсолютно так же, потому что если C и радиус R вот у нас на атмосфере есть, то что такое сфера?
Да, то есть множество точек P таких, что скалярное произведение P минус C для себя любимого равно R квадрате.
Все, подставляем это, квадраты и уравнения. Причем там, по-моему, буковки будут едва ли не те же, чтобы были на плоскости, обретите внимание.
Вот. Очень, ну вот. То есть, вот, оказывается, у нас хорошая технология получилась. Да, с пересечением сверх, конечно, так не получится.
Так. Ну вот. Ну вот. Ну теперь вот высекает вопрос. А напомните ко мне, как пересекает две, допустим, не сильно, не душе параллельные плоскости?
Так. Ну действительно, если плоскости не параллельные, то они пересекаются по прямой.
Чтобы задать прямую, нужно задать один точка и один направление. Спрашивается, как задать направление?
Да, действительно, да. Значит, да, В1, то есть, да, если В1, В2, то вы без труда можете найти плоскости нормаль.
Так, значит, нормаль, это у нас будет просто векторное произведение буквально. Да. Можно найти так одну нормаль, можно найти вторую нормаль.
И обнаружить, что наша прямая должна быть пербендикулярна обеим нормалям, поэтому вот направляющий вектор В и пересечение, это будет векторное произведение N1, N2. Замечательно.
У меня есть какая-то вопрос. А точку как выковырять?
Интересно, есть какой-нибудь такой способ?
Да. То есть, на самом деле, да, можно взять, да, вот мы знаем, допустим, вот это направление пересечения В.
И, допустим, знаем, что вот в этой плоскости один из этих векторов В1 и В2, наверное, это этому вектору В не параллельно, правда?
Может, если, скорее всего, оба, но может не повесить, да? Вот, допустим, оказалось, что В1 не параллельно В.
Так, что же тогда можно сделать? Вот тогда заметим, что если эта плоскость выдаётся не только векторами В1, В2, но и точкой П1 какой-нибудь,
то, соответственно, чтобы найти какую-нибудь точку, пересекающую вторую плоскость, вам остаётся только сказать, что у вас есть прямая П1 плюс В1 на Т,
и эта точка должна лежать во второй плоскости, если есть плоскость А1 и А2. Но остаётся там решить уравнение, собственно, соответствующее Т подставить.
Ну вот, общая технология, думаю, понятна, да? Да, то есть действительно, да, на уровне базового пересечения плоскостей, то есть там плоскостей,
да, ещё тут по плоскости пересекать плечи. Это получается достаточно несложно. Пока мы не начинаем думать о том, что будет ещё.
Ну, нас на самом деле сейчас в 3D будет интересовать один маленький приятный вопрос. Дало ли он точку построить в оболочку?
Так, ну давайте подумаем, чем она может быть в 3D? Если не все точки нам на одной плоскости, то это будет в каком-то грани?
Да, ну опять можно сразу разобрать простой для нас случай. Что делать, если окажется, что все точки лежат по одной плоскости?
Ну, заметим, что да, тогда получается задача ведётся поиску по оболочке на плоскости. То есть вам останется только, скажем, как-нибудь эту плоскость повернуть,
чтобы вот или ввести на ней координаты какие-нибудь, чтобы вот тут был X, Y и Z, собственно, торчал в нас. Вот как-то так это обозначается, да?
Вот. Ну, это в принципе достаточно легко сделать. В общем-то, заметим, что вот эти ликтора даже не обязаны быть параллельными.
В общем-то, какой базис вы не возьмёте, а выклооболочка от этого не поменяет, ну, как последовательность точек, от этого не поменяется, правда?
Так что, в общем-то, так что можно прям взять X, Y, просто вот, как угодно.
Просто там первые попавшиеся три, ну, не лежащие на одной прямой, конечно же, то будет кайф.
Да, то есть это вот, то есть это в общем-то даже не сильно сложно будет.
Ну, возникает естественный вопрос. А что же делать, если у нас нашлись четыре точки, не лежащие в одной плоскости?
Ну, давайте.
Не, ну, понятно, вот таким образом. Хотя тоже, на самом деле, как у нас в случае пересечения полуплоскостей, на самом деле, от количества точек зависит, насколько сильно мы будем страдать.
Ну, во-первых, действительно, можно себе вообразить, что у нас получится, что на самом деле можно убедиться, что получится какой-то выпуклый многогранник.
Ну, почему он получится? Ну, на самом деле, да, в 2D это было, конечно, более понятно, да?
Но в 3D, действительно, можно тоже вместо понятия касательной прямы ввести понятия касательной плоскости, правда?
То есть там вот со всех сторон так, это вводить плоскости и вводить, ну, и проводить там эти плоскости так, чтобы они касались этого множества.
Ну, к чему это нас приведет? Ну, приведет это нас соответственно к чему, что, то есть если мы тут вот берем точки-точки-точки, да, вот мы тут живем, так, мы тут живем где-то в 3D.
Вот, допустим, мы тут живем где-то в трехмерном мире и пытаемся провести какую-нибудь плоскость.
Вот, она на нас нападает.
Тогда логично, что если эта плоскость подъезжает, подъезжает, подъезжает, то в какой-то момент она врезается в точку, правда?
Вот, то есть она действительно так врезается в точку, но и касаться она множество может быть по точке, может быть по двум точкам, а может даже по тому-то.
Ну, на самом деле, да, в том случае, когда она начинает касаться по трем, то получается, соответственно, треугольник.
Ну, это получается такая вот край будущего многокрайника.
Ну, по крайней мере, заметим, что если такая плоскость действительно нашлась, то действительно, ну, то амплитудная плоскость.
Ну, вот, единственное, конечно, оголовка, что там может оказаться несколько точек, тогда вот тут выпукло оболочки.
Ну, по крайней мере, заметим, что если такая плоскость действительно нашлась, то действительно, ну, то оказывается, что действительно весь этот треугольник заведомо границей выпукло оболочки будет.
Ну, собственно, по тем же причинам, которые у нас были в плоскости, правда?
Ну, вот. Ну, единственное, конечно, оголовка, что там может оказаться несколько точек, тогда вот тут выпукло оболочку, их действительно придется искать.
Ну, вот. Ну, давайте пока, пока для простоты будем считать, что четырех точек лежащей в одной плоскости у нас нет.
Вот.
Итак.
И тогда выясекает вопрос. Как же построить выпукло оболочку?
Ну, заметим, выпукло оболочку можно попытаться построить как вот действительно набор плоскостей, которые пересекают, ну, которые касаются множества по трем точкам.
И ведь все такие тройки можно найти за о от m в четвертый.
Каким образом?
Так, может там в телефоне у вас написано? Нет?
Это что вы вычитаете?
Можно просто все тройки прибрать.
Да. То есть, как бы самое тупое, что можно сделать, это взять все тройки точек, через каждую тройку точек провести плоскость и посмотреть.
А это случайно не касательно множества точек. Или что-то то же самое. Не верно ли?
Все по одну сторону.
Да, что все точки находятся в одном полупространстве на этот раз.
А как понять? Вот лежит ли точка, лежат ли две точки в одном полупространстве относительно плоскости задней тремя точками? Как же это понять?
Ну, как раз…
Да, совершенно верно. У нас тут уже…
Смешанное произведение.
Да. Специально для этого мы изобрели это смешанное произведение.
Потому что… Детей-то, давайте подумать, что же такое смешанное произведение на стройке векторов?
То есть, по большому счету, это мы берем… То есть, это мы берем у этих двух векторов нормаль и у этой нормали берем скалярное произведение с вот этим третьим вектором, правда?
В чем нормаль? Берем строго ориентированную правым образом.
И тогда получится, что если у нас войдет в одну полуплоскость с этим вектором, то тогда скалярное произведение будет положительным. В противном случае оно будет отрицательным.
Да, ну, помним, да, потому что те же свойства, типа острый угол больше нуля, этот угол меньше нуля, то есть это все с косимусами.
Ладно, давайте это допишу. Никуда не длится.
Да, это все никуда не делается. То есть, это все продолжает, как ни странно, работать.
Ну, хотя никак не странно, потому что, в общем, доказательство, которое мы проворачивали для двумерия, по-моему, в трехмерии прекрасно будет работать.
Логично, да? Вот. Так что-то вроде как и кайф.
Вот. Поэтому, да, с помощью смешанного произведения определять, действительно, там, в какой полуплоскости находится, без труда.
И действительно получается O от N в четвертой. То есть, прям вот перебираем тройки и, собственно, радуемся жить.
На самом деле, этот алгоритм можно даже оптимизировать.
Потому что мы тратим... Почему это в четвертой?
Потому что мы за O от N тестируем тройки на предмет того, являются ли они гранями нашей руклооболочки, да?
А вместо этого, ведь, мы могли бы сделать кое-что другое.
А именно, давайте вместо этого перебирать пару вершин и вот говорить.
И вот говорить. А скажите, пожалуйста, а вот эта пара вершин, является ли она ребров руклооболочки?
Да или нет?
Нет.
Как это понять?
То есть, нужно понять, что есть теплопространство через эту...
Да, совершенно верно.
Плоскость такая, что она отделяется точкой.
Да. То есть, действительно, давайте... То есть, мысленно можно себе это вообразить так.
Например, давайте вот посмотрим на это ребро, так сказать, сверху вниз, как будто оно нам будет глаз протыкать.
Такие-то уже магнитные поля.
Причем тут магнитные поля.
Там, типа, рисуют там крестик.
А, ну да, да, да. Да, да, да. Целка, да.
Но слава богу, это ребро конечное, поэтому мы можем глаз чуть подальше отвести.
И что же мы на этой плоскости увидим?
То есть, если мы так увидим и спроецируем эти точки на эту плоскость, то получится вот наш крестик.
И есть какие-то определенного рода точки.
Тогда можно заметить следующее, что если эти точки нас окружают прямо вот, набегают на нас так, что нельзя привести какую-то прямую так, чтобы все точки оказались с одной стороны,
то утверждается, что это ребро границей выпуклой оболочки не является.
То есть, я утверждаю, что в этом случае любая точка этого ребра, ну, кроме, может быть, вот этих вот, со самих вершин, является чем?
Ну, правильно, внутрь, строго внутренним.
Спрашивается, откуда же я возьму такую информацию?
Откуда я возьму?
А возьму я ее вот откуда?
Вот такой вопрос.
А, нет, все нормально.
Ну вот.
А как мы сейчас будем проверять, что можно привести через эту точку?
А вот мы сейчас об этом...
Мы сейчас что-то сказали, мы спроецировали на плоскость.
Да, мы спроецировали на плоскость, теперь проверяем, можно ли через вот эту точку, а это теперь точка...
А, провести прямую, которая разделяет...
Нет, которая наоборот.
Такую, что в данном случае нельзя, но нам вот идеальный случай вот такой.
То есть, можно ли провести какую-то красивую прямую такую, чтобы все точки лежат с одной стороны?
Ну, заметим, что если можно, то это будет означать, что я могу как бы перпендикулярно этой плоскости и просто прямую...
То есть, перпендикулярно этой плоскости, плоскость через эту прямую провести радостно, да, и это получится касательно.
Следовательно, это ребро будет на месте.
В чем более того, если точки будут строго там находиться, да, то тогда получится, что эту плоскость по кругу этого ребра,
можно себе воображать, можно вот так вот изобразить на маркерах, вот так вот повращать.
То есть, получится, что это действительно ребро и получается хорошо.
Да.
А если на этом ребре еще и других точек нет, а у нас такого нет, потому что у нас раз четыре точки, не какие-то точки в плоскости не лежат,
то никакие точки автоматически напрямую не лежат, тогда получится, что это еще и вершина,
потому что эту плоскость можно еще вот так вот.
Вот, да, тут нам воображения еще хватает.
Вот.
Но, с другой стороны, а что делать, если такой прямой не существует?
То есть, типа, какая бы ни была прямая, обязательно найдется...
Обязательно найдется какая-нибудь точка.
Не такая.
Чего?
Мы проводим эти вот сведущие плоскости через прямую, на которой лежат вязанные точки.
Да.
Да, то есть, ну как бы вот, то есть, вот это вот, так сказать, касательное множество, это вот касательное множество точек прямая.
Но это в проекте, на самом деле, у нас имеется в виду вот такая касательная плоскость.
Ну понятно.
Вот.
Но если такой нельзя провести, то, ну вот, тогда можно заметить следующее.
Ну, на плоскости можно сказать, что, ну вот, тогда можно найти треугольник, который внутри себя эту точку содержит.
Ну, если у нас еще и точки не на одной прямой не лежат, то как бы да.
Даже будет строго.
Вот.
Так, требуется доказать, чтобы треугольник найдется.
Нет?
Так видите.
Смотрите.
Вот.
Ну вот.
Ну, тогда что нам этот треугольник даст?
Ну, как, ну вот, действительно, что он нам даст?
Ну, как минимум, он нам даст, то есть, через эти три точки можно провести плоскость, которая, ну, такой вот, получится такой вот треугольник, который, вот, либо будет пересекать это ребро, либо его продолжение будет пересекать.
Вот, понимаете, да?
Ну, с другой стороны, нам тут даже не сильно принципиально продолжение оно будет пересекать или нет.
Давайте сразу сложный случай рассмотрим.
Вот так что будет рисоваться.
Потому что тогда теперь заметим, что если он пересекает еще и строго, вот здесь, да, то тогда можно заметить, что мы можем построить вот такого рода тетраедыр.
И это ребро будет просто целиком внутри этого тетраедыра лежать.
Ну, да, если бы это треугольник пересекал ребро, мы бы два тетраедыра построили, все было бы строго внутри.
Вот.
Да, действительно.
То есть, таким образом, получается, что мы можем пересекать этот ребро.
То есть, таким образом, мы, на самом деле, то есть, таким образом, мы вот для каждой пары рыб как минимум в принципе можем пытаться думать.
Является ли оно?
Ну, как это сделать?
Самый тупой способ, это, конечно, давайте просто, ну, с точки зрения математики самый тупой способ, это давайте построим пропендикулярную плоскость, все, все точки на крыльях.
Там перейдем в координаты x, y внутри этой плоскости и начнем там вот эти вот углы искать.
Ну, так, а цитируем по полярному углу, там убедимся, что там найдутся там, найдутся где-то там две, два последовательных векторов, между которыми угол 180, больше 180 градусов.
Или убедимся, что такого нет.
Вот, ну да, как математиков, нас это угол вытворяет.
Ну, кодик, наверное, захочется это очень сильно не, правда?
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
А теперь вот отсюда возникает естественный вопрос, да.
Справа возьмем самый большой угол.
Справа возьмем самый большой угол.
И слева возьмем самый большой угол.
И слева возьмем самый большой угол.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну вот. Ну и теперь два варианта.
Ну и теперь возникает такой важный вопрос.
Ну и теперь возникает такой важный вопрос.
Как мы сравнивали по полярному углу?
Ведь мы же не вычисляли в явном виде этот синдром, правда?
То есть, эти там не вычисляли,
а там 2 же не вызывали,
или там прочарк космисы.
или там прочарк космисы.
Тут мы пользуемся тем,
что любые две точки,
у векторов, лежащих заведомо в одной полуплоскости,
можно между собой сравнить
по тупо-верторному произведению.
То есть, если вот это на это,
соответственно, у нас больше нуля,
значит, этот вектор будет типа правее.
Ну повернуть правее, конечно.
Понял дело такое?
Понял.
Логично. Ну и с этой стороны тоже.
А вот теперь возникает вопрос.
После проекции, конечно,
на плоскость мы могли бы проделать здесь тоже самое.
Но теперь возникает вопрос.
А нельзя ли
сделать это же, на самом деле,
без каких-либо проекций?
без каких-либо проекций?
По большому счёту, давайте
себе вообразим без проекции,
как это выглядит.
Вот как вот эти вот вектора
на самом деле выглядят.
То есть, если вот отменить проекцию...
Построили плоскость,
проходящую чуть-чуть до ребра.
Ну да.
Эту плоскость, давайте мы можем назвать,
даже нарисовать как вот такой треугольчик.
Флюгерочек.
Ну мы нарисовали один.
Есть вот, соответственно, второй.
Есть там какой-нибудь вот третий.
Есть там какой-нибудь вот четвёртый ещё.
И вот возникает вопрос.
И вот, на самом деле,
можно тогда говорить следующее.
Давайте приведём действительно
плоскость вот через первый
попавшийся флюгерочек, да?
Вот опять вот тоже самое сделаем, да?
Ой, давайте я ещё марки возьму.
Вот ещё один
вот такой красивый
флюгерочек.
Пу-пу-пу-пу.
Видите, да?
Ну вот, и теперь возникает идея.
То есть, получается, видите,
букет векторов у нас превратился
в такую книжечку.
И в этой книжечке,
соответственно, надо выбрать самый правый
листочек, там самый левый
листочек и проверить, там они развернулись
не на слишком ли большой угол.
И теперь давайте думать.
Итак, вот у нас в одной
полуплоскости лежат,
допустим, два
вот таких
красивых листочка.
Как понять, кто, так сказать...
Да, вот мы считаем, что мы смотрим
с той стороны, что вот этот вектор направлен
так, это нам принципиально, да?
То есть, мы как бы вот
стоим такие параллельно
вот этому вектору, смотрим
головой туда.
Тогда у нас какая-то книжечка
правее, какая-то левее.
Вправивается. А как понять?
Вот как компьютеру объяснить, кто
правее, кто левее?
Да!
Нас снова приветствует его величество
смешанное произведение.
Ну, каким образом оно это делает?
Ну, в общем-то, элементарно.
То есть, мы берем вот этот векторочек,
вот этот и действительно замечаем,
что как бы вот этот левее
оказывается тогда и только тогда, когда
когда смешанное произведение
этого, этого и этого оказывается
больше нуля, правда?
Ну, как в этом можно убедиться?
Ну, потому что, действительно, заметим, что
смешанное произведение у
вот этих вот векторов
и, на самом деле,
вот этих вот векторов, вот этого, этого,
этого, на самом деле суть одно и то же.
Красно?
Красно?
Вот, смотрите, я утверждаю следующее,
что, допустим, если я приведу через эту точку
вот перпендикулярную плоскость, вот так
здесь, да, эти точки
на эту плоскость спроецирую, вот
рассмотрю вот эти вектора, да,
то я утверждаю, что
смешанное произведение вот этих
векторов от этого не поменяется, слова никак.
Все, не верите?
Векторов сейчас каких?
Ну, смотрите, вот у нас тут точка
P1, P2, да?
Пестируем на ребро.
И вот у нас тут точка Q1 и Q2, да?
И вот я, допустим, спроецирую,
вот у меня плоскость проходит через точку P1
и проекции,
вертикальные проекции на эту
перпендикулярную плоскость, Q1
и Q2.
Вот я утверждаю,
что у векторов P1, P2,
Q1, Q1
и P1, Q2,
а, ну давайте я это напишу уже.
Я утверждаю, что
P1, P2
на векторное
произведение P1,
Q1
и P1, Q2
это
абсолютно то же самое,
что
P1, P2
и, соответственно,
P1, Q1
и P1, Q2.
Вот что я утверждаю.
Ну, это тоже самое.
Где нет?
Тут два штриха.
Я заменил вектор на проекцию.
Ну, это тоже самое.
Да, действительно. Почему?
Ну, раз вопрос вызывает,
давайте уж убедимся.
Потому что, заметим следующее,
да?
Что у векторов P1, P2,
Q1, Q1, Q2,
давайте уж убедимся.
Потому что, заметим следующее,
да?
Что я могу сказать, что
вектор P1, Q1 штрих я могу
однозначно разложить в сумму двух векторов.
P1,
Q1 штрих
плюс
P1,
ну, плюс
давайте так.
Q1
перпендикулярно.
Параллельно.
Где мы говорим, что
U1 параллелен
вектору P1,
P2.
А P1,
U1 штрих, как мы уже сказали,
естественно, хочет быть перпендикулярно.
Ну,
то есть, я любой,
то есть, если у меня,
ну, давайте, я могу это
абстрактно даже сказать, что
допустим, у меня есть
вектор A какой-то, да?
И какой-то произвольный
вектор V.
Тогда я могу сказать, что V равно
однозначно раскладывается
в сумму V параллельно
плюс V перпендикулярно.
Где V перпендикулярно
перпендикулярно A,
а V параллельно
параллельно.
В чем я это делаю? Ровно, ровно
единственным способом, согласны?
Вот. Так вот, здесь
ровно это и произошло, да?
То есть, мы это вот так
разложили. Ну, и заметим,
что P1Q2, соответственно, тоже
раскладывается абсолютно аналогично
плюс U2.
Вот.
Вот, проверим.
Вот.
Ну, теперь замечаем следующее.
Что теперь?
Ну, вот.
Заретим, что теперь, что
если я вот сейчас вот начну вот это писать.
Вот, поехали.
P1Q2.
И тут начнется
векторное произведение P1Q1
и P1Q2.
Да?
То, как бы, я могу
это написать как P1P2
и, значит, тут я P1Q1
честно могу подставить.
P1Q1'
плюс U1
параллельно, да?
И, соответственно,
P1Q2'
плюс U2
параллельно.
Вот.
Ну, теперь, если я
это разложу, то у меня получится, значит,
смешанное произведение
P1P2, значит,
на P1Q1'
плюс, ну, не плюс, а просто
запятая, P1Q2'
плюс
еще четыре скобочки.
Ладно, три.
Вот.
Везде тут будет написан наш любимый
вектор P1P2.
Вот.
Тут будет написано,
честно говоря, мне даже в лому немножко писать
что, потому что самое главное,
что при него нужно знать,
это то, что в каждой из этих скобочек
будет хотя бы один вектор
параллельный вот этому, правда?
А это уже автоматически
значит, что, как бы,
это будет перпендикулярно, значит,
скорее всего, на произведении будет 0.
То есть, поэтому тут просто
то есть отсюда следует, что
если вы в смешанном произведении
действительно
ну вот, скажем, из одного вектора
вы читаете другой, даже умноженный
на константу, то смешанное произведение от этого никак
не меняется. В общем-то, если вы его
написали на языке матриц, то это
было бы эквивалентно просто вы читали одно из третьих
и другого, в общем-то.
Вот. Да. Еще одно
произведение, которое вы явно должны были сдавать
миллионально. Нет?
Вот.
Вот. То есть
очень приятно. Поэтому вот действительно приятно,
что мы можем так, можем проецировать,
а можем не проецировать. Потому что с точки зрения
программирования, это нам что говорит?
Это нам говорит о том, что можно было ничего
не проецировать, а можно было просто
действительно смешанное произведение
честно найти не боится.
И с помощью этого, то есть получается
у нас, как бы,
когда мы крутимся не вокруг
прямой в пространстве, то вот, соответственно,
сравнение кто там левее, кто правее
делается тоже вот,
то есть снова нам
помогает векторное произведение. Правда?
Ну, точнее оно уже не векторное, а смешанное.
Тем не менее.
Приятно, правда?
Вот.
Так вот. Таким образом получается,
что вы можете
на самом деле теперь,
то есть если
действительно, если писать brute force
грани,
да, BS это brute force,
а жрани по английски faces, соответственно.
Это, ну вот.
А если вы делаете brute force
на ребра,
то это уже
позволяет вам строить
выклополочку за приятную
кубическую ассимтуэтику.
Понимаете, да?
Вот.
Что же тогда?
Ну, вот.
Ну, возникает естественный вопрос.
Можно ли
попробовать побыстрее?
Ну, на самом деле
из этого алгоритма
за O at n в кубе
сильно напрашивается,
то есть на самом деле
из O at n в кубе
напрашивается алгоритм, ну, по сути
за O at n аж.
Как построить выклополочку
за O at n умножить
на сколько там грани в этой
выклополочке будет?
А ведь на самом деле идея
достаточно проста.
Ведь мы же в этом алгоритме
за, допустим, куб
или даже может быть
вот нот
или вот нот
там проверяли
или даже вот за четвертую проверяли
в тупую вообще все возможные грани,
правда?
А ведь на самом деле идея такая.
Вот, допустим, мы нашли одну
какую-нибудь край.
Ну, на самом деле, если у вас была задача
найти хоть одну край, на самом деле вы бы ее
нашли бы быстрее, чем золотую, правда?
Нет, аж это будет у нас
количество грани.
Ну, а симпатически количество грани
и количество ребра тоже, потому что у нас
все грани тревогуете, да?
Поэтому непринципиально.
Вот.
Ну, теперь давайте понять вопрос. Да, как найти
хотя бы, ну, давайте так,
ладно, как найти хотя бы
одну край? Ну, для этого заметим, что если
мы найдем хотя бы одно ребро,
то, в общем-то, грани мы
уже построим за линию после этого, правда?
Ну, вот, описанную выше алгоритмом, правда?
Красная?
Итак, ну, как же найти?
Да, очень просто.
Ну, во-первых, вершиной выпуклой оболочки
наверное будет самая низкая по Z точка,
правда? Ну, как всегда, если
в несколько, то там самая левая, там
бла-бла-бла, вот это все.
Ну, а теперь возникает вопрос.
Как найти ей напарник?
Как найти какую-нибудь вторую точку,
которая с ней образует ребро?
А как понимать?
Прям за квадрат, что ли, скажем?
Да.
Ну, как сказать, смотря кое-что в точку,
если вы скажете, что H это там в лучшем случае
не менее чем M, поэтому все равно N квадрат,
то можно и так.
Можно ли брать что-то типа
с минимальным
блок
плоскости,
типа с
прибытия куриатной оси?
Да, совершенно верно, совершенно верно.
Ведь, действительно, мы же можем просто
провести, так сказать, горизонтальную
плоскость, вот эту, да?
И все вот эти точки там пытаться
действительно понимать.
Вот, там что-то такое, вот
что-то типа полярного угла между
этой плоскостью и этим вектором.
Хочется, чтобы найти этот угол как можно ниже, правда?
Угол этот вычислить,
ну, придется реально вычислить,
но, правда, можно вычислять не его, а, скажем,
его синус.
Что такое синус?
Вот эта вот высота, а это, по сути, разность
Z-ок, да?
Поделить на длину ветра.
Ну и, соответственно, теперь ищем угол,
у которого этот синус поменьше.
Да, при очень большом
желании можно даже в целых числах
это сделать, потому что можно минимизировать не синус,
а синус в квадрате.
То есть, в общем-то,
не сильно страшно,
не правда.
Пока у нас красота.
Вот, хорошо.
Одно ребро нашли.
И теперь мы знаем, что если у нас есть
ребро, то, в общем-то,
вот этим вот теперь мы можем вести такое понятие
книжный анализ такой.
То есть, мы можем построить вокруг
ребра эту книжечку
и найти
собственно, эти два
и найти, так сказать, у этой книжечки обложку.
Вот это будет вот примерно так.
Пум-пум. И, соответственно,
тут внутри еще какие-то странички.
Вот, примерно так это будет.
И мы, ну вот,
если мы точно знаем, что это ребро,
то, в общем-то, две вот эти вот крайние
листа мы уже найти умеем.
Мы только что это научились делать, правда?
Ну вот.
И, соответственно, найти теперь можно самые
правые и самые левые.
Но теперь самые приятные, смотрите.
Когда мы нашли эти грани, то есть мы нашли не просто
две грани выпуклой оболочки,
но мы еще нашли четыре
новых ребра.
А теперь давайте просто применим
метод заворачивания подарков.
То есть давайте просто возьмем, скажем, вот
каждый из этих ребр.
Да, причем, смотрите, ну вот,
если мы грань еще будем вот обходить
так, что сама грань остается как бы
слева, то как бы
у каждого ребра получается есть грань,
когда мы идем в одну сторону,
и есть грань, когда мы идем в другую сторону.
Понимаете, да? То есть получается
для вот этого ребра мы, соответственно,
грань, так сказать, слева
с этой стороны уже построили.
А теперь можно попытаться для него тоже привести
книжный анализ и найти вторую грань.
Правда?
Понимаете, да?
То есть прям тоже там относительно
его найти какую-нибудь там что-нибудь еще,
соответственно,
потом, и это даст нам еще два
ребра, ну и так далее. Единственное, конечно, нам
придется для ребр хранить, а не было ли у нас
их уже раньше.
То есть как только у нас, если у нас там
искали, искали там, допустим,
вот тут еще нашли, потом у этого
ребра нашли, ну вот,
то есть мы тут нашли вот этих двух напарников,
а это у нас, оказывается, было, то тогда
выясняется, что для этого ребра мы уже
обе грани нашли. На самом деле надо
только вот от этого ребра куда-то идти.
Удобно, правда?
Вот. То есть тогда
ну вот. Ну и очевидно, что
таким образом, на самом деле, мы так аккуратненько
всю выпуклую оболочку, в общем-то,
и обойдем.
Потому что, соответственно,
потому что за каждый ОАТН шагом
обработки каждого ребра, если
оно еще не было обработано раньше,
мы получаем новую грани. Получается
красивый заворачивание
подарка за
ОАТН.
В общем-то, обратите внимание,
тоже не самым убойным
образом пишущейся
неправда ли.
Понятно, да?
А так и делаем.
Ну то есть, смотри,
для каждого ребра у нас как бы есть
его, так сказать, в одну сторону грани,
в другую сторону.
Обе эти грани, мы, честно, за ОАТН
можем найти вот этим с нижним анализом.
Ну а теперь, когда мы находим новую
грань, мы для вот этих ребер проверяем,
не встречали ли мы их раньше.
В обе стороны причем.
А, в общем, не важно.
В обе не могли, потому что
если мы встретили его в ту же сторону,
значит мы эту грани уже вычислили.
Это можно делать, ну, скажем так,
ну, тут на самом деле
можно задумываться вот о чем.
О чему может быть равно H?
Потому что от этого может зависеть
на самом деле, вот как нам эти ребра
хранить. Потому что H может быть вообще
мелочью, правда?
Ну, да.
Ну, не знаю, получается,
надо вот еще добавить
всем точку на то, как хранить ребра.
То есть если хранить ребра там в матрице,
в какой-нибудь матрице смежности,
то, конечно, будет лишнее квадрат.
Но с другой стороны, заметим, что
можно вместо N тут написать
что-нибудь типа H,
какой-нибудь плог H,
просто потому, что все ребра
можно и в сете хранить, правда?
И заметим, что это
и заметим, что эта асимптотика
в общем-то уже не испортит.
Да, то есть это, конечно, может
сильно, ну, потому что чисто теоретически,
если лог H окажется больше
чем N,
то, конечно, H лог H будет больше
чем N. То есть может ли быть так,
что лог H больше чем N?
То есть как лог H может быть
больше чем N? Если H не превосходит
чего? Ну, как минимум N квадрата
оно точно не превосходит, правда?
Ну, раз он не превосходит N квадрата,
то лог H не превосходит двух
логових логов. Так что H лог H
это несерьезная асимптотика
по сравнению с N H.
Сейчас. H не превосходит N квадрата?
Н квадратный, да? Конечно.
Ну, если H у нас количество,
скажем, ребр,
то, ребр, у нас не более H квадрата.
Это нельзя лучше оценить?
Ну, на самом деле, скажем так,
с точки зрения анализа
асимптотики нам не нужно.
Но на самом деле, да, это следующий вопрос,
которого хочется обсудить. Конечно же,
H можно оценить лучше.
Причем соображение очень тупое.
Вы же, если вы воображите
себе этот выпуклый многогранник,
то, наверное, вы
без труда поймете, что
этот многогранник является,
помимо всего прочего, планардным графом. Правда?
Почему он является планардным графом?
Ну, например, потому что, если вот...
Ну, я не умею рисовать
экзотические многогранники.
Может, кстати, какой-то местный сейчас телевизор включим?
Там, в тому шаг.
Да, он был домашним планардным графом.
Чего, нарисовать многогранники?
Приказать, что многогранник планардный граф.
А какое там самое простое решение?
На сферу?
Да, да, да.
Возьмем точку внутри.
Возьмем в ней сферу любого радиуса.
Спроекцируем все точки на эту сферу.
Ну, а потом там что-нибудь подвигает.
Либо возьмем любую точку на сфере.
Стигографическую проекцию.
Да, да, да. Можно стигографическую,
можно это. Нет, я еще люблю воображать,
что давайте вот так вот сферу еще вот так вот разведем,
так что все у нас в полную сферу убьют,
а потом уже спроекцируем.
Согласен, переэкзотика, да.
Можно тупее, но...
Как иногда случается,
как говорится, лучше иметь больше методов,
потому что не знаешь, когда каждый метод выискает.
Так, такая вот красота.
Получается у нас.
Вот. Но тогда чему?
Это раз это планардный граф.
И причем мы помним, что
у каждой вершины, причем
у нас не бывает вершин
в степени 2
или 1.
Ну, и там любая грань
там имеет хотя бы 3 ребра.
То отсюда, как мы уже и сами не однократно
доказывали, и у вас в домашнем задании
по дискрану было, да,
что h это
в любом случае от n.
Мы помним, до сегодня уже там
что-то думали на тему там 3n
что-то в этом роде.
Было дело, да?
Поэтому, в принципе,
получается, что как и в методе
в алгоритме Джанниса,
то есть в худшем случае это
n квадрат.
Хотя, на самом деле,
есть, конечно, нод.
Хотя, конечно, как всегда, если
вывку оболочка мелкая, то, в общем-то,
она наша.
Вот.
Вот такая вот красота получается.
Получается из
просто платформы геймера, да?
Ну, да.
Ну, как всегда, там просто
доказательства типа, что
то есть планарный граф у
к степени каждой вершины больше, или правда, трех
там граней на двух ребрах
не бывает, хотя это уже даже не важно, по-моему.
То есть и граф
связан. Из этого следует, что там
вычитаем, вычитаем, радуемся.
Вот.
Но, конечно, хочется побыстрее.
Ну, честно скажу, к сожалению,
все алгоритмы идеальные
на эту тему обсудить не удастся.
Вот.
Да, в идеале хотелось бы когда-нибудь.
Но пока скажу так.
Значит, идеальная...
Ну, конечно же, идеальный алгоритм
тут будет явно за mlog n.
И один из них мы сегодня
как-то с ним так
попытаемся обсудить.
Вот. Но еще
должен сказать, конечно, что
здесь, видимо, аналоги
того безобразия за mlog h
тоже есть.
Ну, я не знаю.
То есть я не знаю, как они
делят точки на h, а потом
их все оборачивают каким-то
нехзапаксным образом, но каким-то образом они это делают.
Вот.
Да, там уже этими
указателями не побегаешь, конечно.
Вот.
Но прежде
чем обсудить хоть что-нибудь за
mlog n,
мы на самом деле обсудим
то есть ну, для того, чтобы
понимать, действительно,
как у нас работает...
как у нас может работать алгоритм за mlog n,
мы попробуем обсудить
еще один алгоритм, который
формально работает за n квадрат.
Так. Еще вопросы какие-то?
Сейчас.
Ну, так мы может обсудим тогда, если
мы не гонорируем.
Окей. Хорошо.
Вот. Значит, как еще можно искать за n квадрат?
Ну, потому что
этот n квадрат подозревает, что у нас точки все заранее есть,
а ведь на самом деле
в 2D на t выпукла оболочку можно было
строить инкрементальную методу.
Что это значит?
Что значит это словосочетание, да?
А словосочетание это означает, что
допустим, мы точки добавляем по одной
и поддерживаем выпуклую оболочку в каждый момент
времени, да?
Понимаете, у нас в какой-то момент даже
из этого получалось, что вот они выпуклые
оболочку, и надо теперь добавить
какую-то точку, и надо какие-то
касательные провести, да?
Получалось, что если мы эти точки
еще и в красивом дикартовом дереве
храним, то получалось, что там едва ли не за
рифом эту точку можно туда добавлять.
Но это когда мы там
переизвратиться решили.
Вот.
Так вот. На самом деле
мы попробуем сделать, вот давайте
сейчас давайте временно
остановимся на
N квадрате.
И попробуем
с вами сделать вот что.
Значит, мы с вами попробуем.
Мы с вами
попробуем.
На самом деле применить.
Ну тоже имприментально.
Ну там солению мы как-нибудь поймем, лежит ли точка
внутреннего угольника, правда? Мы можем
озалоговить им при желании, вы помните.
А теперь предположим, что к нам
добавилась новая точка, и мы очень хотим
понять
собственно,
что же это за точка, куда она пришла.
Что же нам сделать? Сделать мы
будем следующие. Смотрите.
Давайте
приведем какую-нибудь прямую.
Ну вот.
Это у нас будет
экран.
Значит, почему
экран?
И точку,
наверное, давайте повыше нарисуем.
Значит, идея будет следующая.
Я попробую
все вот эти точки, то есть
провести лучи
провести лучи.
Так.
Пока мы в 2D живем.
Это пока 2D.
Опять маркеры
не рисуют.
Вот.
И приведем вот честно все вот эти
лучи. Да. То есть экран мы, естественно,
поставим таким образом, чтобы
именно лучи пересекали это,
а не их там дополнение в ту сторону.
Ну, как-нибудь эту прямую,
давайте уж поверим, провести можно.
Да, можно. Ну, на самом деле, самое тупое там
берем первую попавшуюся точку,
там берем какую-нибудь перпендикулярную
прямую и отдаляем ее на
достаточное расстояние.
Ну, например, так.
Вот.
Теперь что можно заметить?
Тогда, естественно, проекция,
то есть проекция этого
многоугольника, получится, естественно,
отрезок. Правда?
И более того,
почему-то возникает
жуткое подозрение, что
если вы проведете касательные
многоугольнику две, то они
укрутся в конце этого
многоугольника.
И ведь теперь идея
так, оказывается, очень простая теперь.
То есть вы теперь можете
из этих точек, просто взять
этих точек, найти, так сказать, самую верхнюю
и самую нижнюю.
Кстати, один из способов, на самом деле,
это подумать там, не привести
ли вам какую-то вертикальную прямую
или какую-то горизонтальную прямую,
вы хоть одну из них вы проведете.
Ну, там, например, что можно сделать?
Ну, там, в самом деле,
например, что можно сделать?
Ну, там самое тупое, например, что
если эта точка оказалась правее всех,
многоугольник, то вы там
проводите слева вот эту прямую.
Если она оказалась левее всех, то правее,
если ниже всех, то сверху, если выше всех,
то снизу. Если она оказалась где-то
здесь, ну,
возможно, страдаем.
Да, в скопрах, на самом деле,
нет.
А, хотя нет.
Черт, да.
Да, в данном случае пострадать вам все-таки
придется, потому что ни один из стандартных
экранов у вас обзор будет.
Можно два экрана провести,
параллельных, слева и справа.
Это, правда, достаточно
неприятно. Ну да, честно скажем,
да, легче уж было, извините, взять первую
попавшуюся точку и перпендикулярный экран
провести и отдать.
А, черт, это бы не помогло.
Да.
Ну да.
Да, можно, да.
Брать ближайшую
по, ну, типа, ближайшую сторону.
Ближайшую, как ты мог.
Не.
Ну да, брать ближайшую сторону
и экран сделаем параллельным.
Это обобщается.
Ну да, можно вообще, да.
А, ну да, можно ближайшую, да.
Можно опустить перпендикуляр,
взять ближайшую и сэкранировать туда.
Да, можно и так.
А ближайшую, а, все равно,
заливаем еще.
Да, можно и так.
То есть, экран так или иначе находится.
То есть, вот есть
такой красивый метод.
Да, просто чем метод приятен,
да, сейчас мы его попробуем обобщить в 3D.
Но в 3D просто, да,
в худшем случае работает за квадрат.
Вот.
Все, все, все, все.
А получили мы следующее.
Мы получили, мы взяли экран,
взяли проекцию. И с проекции взяли
самую нижнюю и самую верхнюю точку.
Посмотрели, откуда
эти точки взялись.
Так вот, утверждение. Все, что
вот как бы с этой стороны, от этих точек
надо удалить. А вместо этого
установить вот эту точку сюда.
А, то есть мы добавляем
новую точку и вот
ищем экран.
Вот.
А теперь, а теперь
чем приятен этот метод? А теперь вообразим в себе,
что мы все это
делаем в 3D.
И вот для этого,
пожалуй, с телевизора
все-таки включу.
Так.
Сейчас я вам покажу
как говорится, иллюстрацию
из одной англоязыкой книжечки.
Так. Которую, в принципе, можно
вполне считать на нашем учебнике.
Ну, может
не совсем всеотъемлющим, но там прям
много всего очень красивого есть.
Так.
Сейчас.
Сейчас.
Вот сюда мы пойдем.
Ну.
Не-не-не, другая.
Англоязыка, что ли.
Сейчас.
Сейчас.
Так.
Где она у нас?
Вот.
Так.
Вот так.
Вот так.
Вот так.
Вот так.
Так.
Да.
Так. Интересно.
Вот.
Так.
Ожидаем.
А.
Вот.
Вот.
Вот.
Да.
Да.
Да.
Да.
Да.
Вот.
Да.
Да.
Да.
Да.
Вот.
Вот.
Да.
Да. Вимба.
И чей?
Ну.
Ну.
Так.
Так.
Так.
Кстати, да.
Первое, что вы можете сделать, это переписать авторов.
Ну.
Ну, впрочем, я думаю, я вам, конечно,
это могу спокойно в группу кинуть.
Но вот.
Но не менее, быстро.
Искать будет тяжело.
Да.
Да.
Ну да, если я вообще скину, вы сможете
прям даже вместе со мной.
Так.
Так.
Да.
Да.
Так.
Вот.
Так. Это же мы, да?
Да.
А то я вам уже полно написал что-то.
Так.
Так.
Так.
Продолжаем.
Продолжаем.
Вот.
много чего еще есть. Причем чем приятна книжка, что да, вот видите, тут много
действительно красивых разделов, вот динейное программирование есть, может мы даже исследуем, там еще какие-то
вот вещи, там вот по идее да, всякие там, да, то есть всякие методы на тему того как определить
точка там, ну и так далее. Ну, что есть? А, ну конечно, вот на самом деле, ну конечно есть и диаграмма
Воронова вот, пожалуйста, или там, вот, преангуляция Долане, пожалуйста, вот, ну, собственно, в общем-то, мы
практически по ней шли, вот, да, кое-какая, и, конечно, кое-какая информация в оболочках есть, и вот картинка
отсюда я вам хочу показать.
Здесь 35-я стрельба.
А, ну вот. А, ну вот, в принципе, вот такая картинка на тему этой, типа, этой вашей
стереографической проекции. Ну, они себе это вот так вот, вот прям вот честный вывод вот этих формул есть.
Ну, я хочу, я вот на самом деле сейчас ее включил отчасти вот ради вот этой вот великолепной проекции.
Это называется делаем абсолютно то же самое, только вот в 3D. То есть добавляем точки по одной, пытаемся быстро там как-то определить, не лежит ли точка внутри этого вашего многогранника, соответственно.
Вот, ну, понимаете, да? Да, кстати, отдельная песня, да. Как определить, желательно, за линию лежит ли точка внутри многогранника?
Да, то же самое мы берем, фиксируем одну, стойчик.
Ну, можем для каждой грани поверить с той же стороны, что...
Ну, на самом деле, да. Да, я тут сидел, думал, как тут лучше прочислить.
Мы можем хранить все грани правильной ориентации как бы. Ну, конечно. И просто проверить, что для каждой грани...
Да, ну, и здесь оговоримся, что да, многогранник мы, скорее всего, будем хранить не просто там, то есть, скорее всего, еще ребра будем хранить в правильном порядке.
То есть, тут встретится опять нам этот вот double connected edge, вот это вот все.
А, кстати, давайте поперематываем.
Сейчас, я, по-моему, пример даже хлыкну носом, как она конкретно называется.
Да.
Бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла-бла
А, вот.
Видите, достаточно крупно.
Даблик коннектито джинс, как называется.
То есть когда все его прохранятся в правильном порядке, и у каждого ребра еще есть ссылка на напарника.
Так, ну и давайте вот.
Вот. Ну и на самом деле, вот та картинка теперь превращается в такое.
Вот. Ну действительно, да. В первую очередь давайте вернем нашу глобальную картинку с экрана.
Как нам теперь понять вообще, лежит ли точка внутри многогранника или воврем?
Ну один из способов, это действительно, попытаться попроводить все возможные грани, да.
И для каждой грани попытаться понять.
Верно ли, что точка находится с точки зрения этой грани с нужной стороны?
Это можно сделать за у от единицы, правда?
Уже надо посчитать, вот для этой грани можно посчитать смешанное произведение вот этого вектора, вот этого вектора и вот этого вектора,
так же вот этого, вот этого и там первой попавшейся другой точки.
Вот прям вот за лигию можно честно проверить. Заметим, что многогранник – это пересечение полупространств, правда?
Ну то есть вот помните, многогранник – это пересечение полупространств.
Вот давайте собственно и проверим лежит ли точка пересечения полупространств.
Другой метод, вот первый пришедший мне в голову, хоть и более громоздкий, он был бы основан на то, что давайте посчитаем
площадь этого многогранника, а потом посчитаем площадь, суммарную положительную площадь все в тетрайдам,
в тетрайдам вида вот тройка точек и вот эта точка, и получится совпадет лислума.
Остается только правда кстати маленький интересный вопрос.
Как, простите, посчитать площадь многогранника, объем многогранника?
Вот кстати как. Давайте подумаем, как это сделать, кстати?
Выберем какую-то точку внутри. Да, внутри просунируем объемы тетрайдов.
А, ну да, действительно. В случае выплона многогранника вообще без проблем.
Действительно давайте тупо возьмем точку внутри, ну там центр масс, например, или тупо одной завершины, чтобы не думать.
И посчитаем действительно объем всех тетрайдов. А как посчитать объем тетрайдов?
Смешным произведением. Ну да, и еще там забыл наш опы 9.
На 3, что ли? То есть на 3 примерно 6. Помнишь, что на константу?
Камера, переводить константу не буду. Вот. Это уже информация для ГУА.
Такая же форум, как и на концу вчера.
Вот. Вот об этом-то я и хочется подумать.
А вы действительно, как вы думаете, не удастся ли на самом деле наоборот взять какую-нибудь точку вне
и действительно как-нибудь просуммировать все эти тетрайдеры, но при этом с учетом какой-нибудь ориентации?
Интересный такой вопрос.
У нас тут жуткое ощущение, что по идее должно.
То есть вот действительно из этой картинки как-то очевидно, что если все правильно ориентировать,
то эти все треугольники пойдут с одним знаком, а эти треугольники пойдут с другим.
Кстати, это очень умно.
Кстати, на самом деле это очень удобный способ на самом деле.
Если бы это оказалось вовне, то на самом деле заметим, что никакая особость эта проекция нам даже не нужна.
Потому что мы теперь можем сказать, что давайте просто выпилим все грани, относительно которых у нас объем получается не в ту сторону.
Ну то есть давайте хранить грани так и обходы грани так, чтобы все объемы оказывались положительными.
Можем так сделать.
Получается, можем так сделать.
И тогда у нас получится, что давайте просто все грани, то есть если у нас около ребра обе грани нас не устраивают по объему относительно этой точки,
значит мы ее так жестно выпиливаем.
А если совершенно случайно, если оказалось, что, ну и понятно, что если обе грани подошли, значит ребро выпиливается.
Если обе грани подошли, значит оно живет.
А если вот ровно, а если одна половинка ребра выпилась, другая нет, значит вторая половинка ребра так жестно образует треугольник, который мы добавляем.
И на самом деле обратите внимание, никакого реального экрана строить не надо.
Да, можно было бы знаете на тему еще подумать.
Можно было бы подумать, что а давайте-ка спроецируем это все на экран, и на самом деле вот эти все касательные будут образовывать здесь выпуклую оболочку,
которую там можно найти, а на самом деле можно найти за линию.
Вот смотрите, если вы спроецируете все вот эти точки сюда, то вот эту выпуклую оболочку вы можете найти за линию.
Догадываетесь почему?
Вот точнее так, где избавиться от сортировки?
Ну, может уже нам понадобится какая-то ориентация ребра?
Да даже не важно, что ориентация, просто ребра храним, да.
Ведь заметим, что каждое вот это ребро на самом деле является проекцией какого-то ребра выпуклого на горганьку, правда?
То есть если все ребра нарисовать, тут получится какой-то жутко непланарный граф.
Но самое приятное в этом жутко непланарном графе, что количество ребер в нем линейно.
Поэтому идея такая, а давайте-ка эту оболочку будем искать заворачиванием подарка, просто от каждой вершины будем искать следующую,
самым тупым обезом, но перебирать только реально существующие ребра, а не все.
И получается это можно за линию оболичить.
Да, вот перед лекцией я думал, что я буду рассказывать это, но как показала практика, в этом же нет необходимости.
С точки зрения, конечно, быстрее не будет оболочки.
Потому что на самом деле мы и без этого могли прекрасно понять, ну вот, прекрасно мы могли с вами понять,
собственно, какие грани тут есть, а какие граней нет, мы уже с вами научились это делать, остается только выкинуть.
Единственное, только наша мечта, конечно, вот в идеале знаете как было,
и в идеале, конечно, еще неплохо было бы достаточно быстро попытаться найти действительно, что там реально надо удалять.
Ну в идеале хотелось бы, почему нам бы это хотелось?
Ну потому что заметим, что, во-первых, мы же, потому что потом удалить мы все это можем за от того, сколько этого всего там,
потому что это все связано, правда?
Поэтому, конечно, вот, и это единственная проблема.
А почему бы, вот, я не знаю, как это делать, но хотелось бы уметь это делать быстро.
Причина, вот, какая.
Потому что, смотрите, обратите внимание, в этом инкрементальном алгоритме предупреждено использовать случайную перестановку, видите, да?
Так вот.
Так вот, значит, у них, значит, пока мы, естественно, это разбирать не будем.
Вот, дописываю, дописываю.
Так вот, и есть вот такая мистическая церемония, что от ожидания, действительно, получается,
эти вот грани, которые вы вообще создадите, в принципе, тут в природе, их, оказывается, он, шесть тем, минус двадцать.
Итоги факт.
Поэтому, конечно, голубая мечта о том, чтобы находить точку, хотя бы ближайшую точку к нашей, как можно, или ближайшую в грани, как можно быстрее,
чуть помирить, было бы классно было.
Или нет?
Подходилось бы.
Подходилось бы.
Вот.
Ну, а тем не менее, вот такой вот приятный факт есть, и на самом деле, да.
То есть, на самом деле, грани он создаст немного, поэтому, если вы хоть на сколько-то быстрее там.
То есть, в принципе, да.
Вот видите, к сожалению, алгоритм нам подпишет, видите, что если точка P лежит вне С,
а, ну да, то значит удалить всех этих товарищей.
Каким образом удалить, непонятно.
Нет, хотя, ну, в смысле, если мы хотим быстрее, чем С, так-то понятно. Прибедись по грани, скажи, адекватны ли они, если нет, то...
Да, это неправда.
Ну, вот такая вот красота.
Вот.
Ну, соответственно, это все, к сожалению, все работает все еще за N квадрат, хотя, конечно, если там переспоновка случайная, то, возможно, вам там будет как-то вести.
Ну, а теперь возникает вопрос, а можно ли все-таки побыстрее это сделать, скажем, за N логами?
А вот тут я вам покажу.
Вот это не то, что я вам покажу, что я вам покажу.
О, вот это не то.
Вот не то.
Вот это я вам покажу.
А, вот это я вам покажу. О!
А теперь я вам покажу, собственно, рекламирую просто на этот раз уже статью.
Да, я вам ее тоже сейчас могу кинуть.
Кстати, новенькая статья, кстати, относительно.
Кстати, да.
Мы сейчас будем это изучать, да?
Ну, скажем так, как минимум вскользь пройдемся.
Честно говоря, последние годы у меня была традиция, что мы, конечно, долго и то вскользь обсуждаем, но на экзамен я его даже не пытаюсь выносить.
Тем не менее, мягкая куча.
Да, но мягкая куча...
Да, ну нет, подождите, мягкая куча, это понятно, алкоголь.
Полосапстрин, полосапстриком сапсикенс, это жесть.
Ой, да? Да нет, в общем-то.
Да нет, ой, Господи, что там, полосапстрин, кстати, это все это простое алкоголь.
По сказанию, не с мягкой кучей, с вот этим вот, мне кажется.
Ну, потому что чем это приятно, что в диаметре нужно это все как-то себе красиво воображать.
Все как-то очень глубоко воображать.
Честно скажу, вот моего воображения пока вот на этот алкоголитм полностью не хватает.
Хотя идея-то вроде понятна, да?
То есть, что он тут предлагает?
Ну, будет строить 3D, значит, мут-полоколочку методом, тупо разделяем власты.
Так, есть подходящий критик, интересно.
Ну, то есть, вот, в 2D это выглядело бы так, видите, да?
То есть, мы бы распилили также множество, какой-нибудь вертикальной прямой на два раза.
Давайте предполагать, без сильного ограничения в обществе, что у нас все точки там имеют разные, допустим, иксы.
Ну, кстати, этого, если нам плевать на переполнение ики, поэтому, кстати, не сильно сложно добиться, правда?
Ну, там, понятно, сделаем подходящее финное преобразование какое-нибудь, с каким-то очень перекошенным базисом.
И что у нас получится?
Ну, вот, и получится это разделяем властой, который нам позволит, скажем, строить, допустим, мы будем строить нижнюю часть рубка-лоболочки и верхнюю часть рубка-лоболочки.
И, соответственно, все, что нам останется, это, соответственно, найти вот такие вот красивые чашечки.
То есть, мы в каждой половине нашли нижнюю часть и склеили их?
Ну, практически, да, в левой половине нашли нижнюю часть, в верхней половине нашли нижнюю часть и теперь их склеили.
Ну, каким образом их склеили?
Ну, обратите внимание, остается найти какую-то, как видите, общую касачьему.
Понятно, да?
Вот. Общую, ну, какую-то общую касательную.
И причем тут очень важно, оказывается, что в этой общей касательной, значит, вот у вас есть вот вершины у и в, есть вот вершины у минус у плюс и есть вершины в минус в плюс, у которых, собственно, тут векторное произведение как-то хорошо устроено.
То есть, как автор тут пишет, у плюс у и в, значит, идут, например, в порядке против часовой стрелки, равно как и в минус в в плюс.
Видите, да?
Ну, и там всякие вот эти вот все, там в и в плюс, там вот это все.
Понимаете, да?
Вот.
Так что вот получается такая вот примерно красота.
Вот. Ну, дальше автор, значит, дальше предлагать следующее.
Значит, как это все обобщить в 3D?
Ну, тут возникает вопрос, как превратить вообще картинку 3D в что-то подобное?
Очевидно, надо ее как-то куда-то спроекцировать, правда?
Так вот, предлагается проекцировать примерно следующим образом.
Так, сейчас я вам просто форму.
Вот форму.
Видите, да?
То есть.
Ну вот.
Ну, получается примерно так.
То есть, допустим, что...
Так.
Ну, тогда, да.
Не очень так удобно, конечно, в качестве 3D не получается.
А, хоть и нет, нормально.
Вот.
Давайте себе вам резим себе так.
Вот это вот типа плоскость, да?
Вот.
То есть, допустим, вот.
Так, сейчас.
Где у нас X?
Ну да.
Ну, давайте скажем, чтобы у нас действительно правильно это было.
То есть, вообразим себе, что да.
То есть, X у нас, собственно, сюда идет.
Y идет сюда.
Z идет вдоль.
Логично, да?
Так вот.
Вот.
Ну, 네.
Ну, тогда вот возникает вопрос.
Действительно, куда это вот точка проекцируется?
Да, ну да.
Заметим, что при terrible 0 у нас все проекцируется на плоскости Z.
Да, поэтому не очень удобно.
Давайте скажем, что по IV-сам.
Ну да.
Заметим, что при C объема 0 у нас все проекцируется на плоскости Z.
Да, поэтому не очень удобно.
Давайте скажем, что от X intersection.
Да.
Ну да.
А то, да, да.
Так.
А то, да.
А то, да.
Давайте скажем, что вот у нас x, вот у нас z, вот у нас туда игрек идет, да?
О, у мамы даже правильно правая трубочка получилась, да?
Или нет?
Сейчас x направо, z наверх?
Вот x. Нет, от нас вот x налево, z пудой, игрек пудой.
Да, вроде правильно.
Ну, вроде да.
Ну, вот. Ну, то есть x игрек, z игрек, x игрек. Соответственно.
Да, вроде адекватно, да?
Да, x игрек, z.
Вот. Да, все, конечностей мне хватает.
Вот.
Теперь давайте подумаем. Значит, если вот x игрек, z, куда у меня получается проекция?
Ну, если t равно 0 вот у этой формулы, то проекция идет тупо в меня, правда?
Ну, вот.
Если же t равно, например, 1, то проекция вот так вот идет 45 градусов.
То есть практически мы через точку проводим какую-то прямую, которая эту плоскость пересекает, правда?
В чем более того, когда t движется от минус бесконечности до такой степени, от минус бесконечности до плюс бесконечности,
как мы себе это можем вообразить?
Мы себе это можем вообразить, что, то есть, на самом деле, вот эта вот проекция, она вот была прям совсем вертикальная когда-то там, да?
И вот она вот так вот идет, идет, идет и вот опускается.
И тогда у нас что происходит? У нас тут есть множество точек, у которых мы выплаболочку ищем, да?
Жалко, я тут не могу подвесить несколько точек.
Значит, мы их делим пополам.
Значит, строим тут кубик 20-тиранный и тут 35-тиранный.
Теперь, значит, эти два кубика нам надо вот такой вот пленочкой обернуть.
Значит, как мы будем оборачивать пленочку?
Ну, на самом деле, по большому счету, нам нужно привести...
То есть, по большому счету, вот такой набор касательно.
То есть, на самом деле так.
То есть, заметим следующее.
Что для каждого t, если мы это спринцируем, у нас получится какой-то выпуклый многоугольник, правда?
Ну, для каждого t, правда?
Получится выпуклый многоугольник и этот выпуклый многоугольник …
Ну, вот, у них там даже будет выпуклых многоугольников, соответственно, будут даже две какие-то чашечки.
И тогда что получится?
И тогда получается, что к ним надо привести касательное.
И, собственно, то проекции, чего это является касательное,
будет, собственно под этим вот ребром выпуклой оболочки в объединении, правда?
Так вот, дальше, собственно, методология в этом и заключается, что мы будем, значит, это T аккуратненько двигать и поддерживать, где у нас сейчас это ребро находится.
Вот. То есть, ну, как это будет происходить, да? Вот давайте себе вообразим. То есть, действительно, пока, ну вот, то есть, пока у нас действительно T, соответственно, там, как-то вот идет совсем вот высоко, да, то это нижняя проекция, это будет вот что-то вот сзади вот этих вот кубиков, соответственно, там, задняя часть как-то будет спроецирована, правда?
Ну, практически, то есть, это будет практически проекция там куда-то вверх, они там совсем, ну, там, то есть, они там будут по чуть-чуть, по чуть-чуть.
Вот. Но дальше будет, собственно, когда мы эту прямую будем, то есть, когда мы эти прямые будем поворачивать, поворачивать, поворачивать, поворачивать, что будет происходить?
То есть, некоторые грани будут, то есть, мы будем начинать какие-то грани видеть, а какие-то грани из нашего поля зрения начнут исчезать. Ну, если мы вот с этой стороны на них смотрим, правда?
То есть, с точки зрения этих грани. То есть, это будет проходить там в тот момент, когда, скажем, вот эта прямая будет параллельно какой-нибудь там вот грани из вот этих.
Помним, да, что вот эти вот штуки на самом деле соответствуют каким-то реальным ребрам и на этих ребрах какие-то грани, правда?
Вот. И дальше в итоге все сводится практически к фактически анализу событий, по большому счету.
Какие тут события могут вообще произойти? Ну, могут произойти события, что вот это соседние, ну, тут вот действительно перебираются всякие случаи.
То есть, например, могут произойти события, что какие-то вот там наборы из этих троих точек, они перестанут, перестали быть адекватными.
Ну, то есть, крутятся не в ту сторону. И в каждом из этих случаев, соответственно, нам придется, соответственно, точечку УЮВ там куда-то по-соседски убить.
В чем мистическим образом оказывается, что далеко двигать на самом деле не надо.
Дальше вот совсем начинается магия. Ну, то есть, понятно, какие тут события будут.
Но вот действительно оказывается, что вот там, соответственно, эти выпуклости там уже задумываешь, что в какой-то момент эти точки начнут там появляться и исчезать, правда?
Вот, поэтому тут. Ну, а какие тут могут появиться, да? Ну, появиться могут, что вот это ребро, соответственно, какой-то грани может там вот третья точка, называется этого ребра, куда-то когда-нибудь появится, да?
Или вот это появится. А заметим, что, в общем-то, вот это вот все нам хранит, пока, в общем-то, не сильно принципиально.
Ну, хотя бы, с другой стороны, ну, вот. Ну, потому что, по-любому, я в каждой точке буду там что-то хранить.
В результате, ну, в результате, вот, собственно, да, я сейчас... То есть, получается, перебор случаев, он тут имеет место, но, собственно, как видите, не сильно большой.
Вот видите, да? Ну, и в результате это сводится вот такого объема холи. Вот. Да, вот это практически все.
Знаете, вот, действительно, френдокстально, никаких сетов. То есть, по-моему, единственное нетривиальное тут, что может быть, это разве что сортировка.
Но, да и, да и то, и, честно говоря, я ее вижу. Вот. Вот. Да, то есть, обратите внимание.
Ну, видимо, подразумевается, что они, возможно, изначально сортировали в правильном порядке фриксу.
Поэтому, поэтому тут, поэтому он честно, видите, он тут вообще даже молодец, он сразу создает, он дает не только список соответственное число, но еще и сразу списки, в которые можно там куда-то копить пластик.
Вот такая вот неожиданность. А, хотя нет, ой, он даже еще и сортировку написал. Вот. Так что тут вот такая вот красота.
Так что вот это вот, если очень соответственно, вот, так что соответственно, если вкратце, какая тут может быть идея.
Он, как бы, честно говорит, что это не первый алгоритм за NLGN. То есть, это он, как бы, то есть, на самом деле, как построить это за NLGN, было известно еще там, хоть как-то там, в 1975 году.
Но, на самом деле, то есть, в этой статье, как бы, мы говорим, что ее смысл не в том, что мы там изобрели какую-то новую асимпторику, а в том, что мы научились это вот за адекватное количество строчек делать.
Там все там соседние алгоритмы за NLGN или NLGH они по реализации крайне будут. Вот. А тут вот, оказывается, хорошо.
Так что вот таким вот образом, оказывается, примерно вот таким образом можно это за NLGN строить.
Так, хорошо. Есть петь тут.
Статью почитать. Что-то как-то пока не особо, что-то как-то.
Статью, да, статью очень рекомендую почитать.
Что-то, как-то, честно, не очень воспринимается новым.
Ну да, так.
Не, ну понятно с вызовом. То есть, у нас есть, типа, два комочка, мы хотим обернуть клевочки.
Вот, да. Ну, честно скажу, да.
Ну, если совсем честно, то дальше я, в общем-то, лучше понимаю, собственно, не больше.
Как-то да.
Вобрать даже не буду.
Да, ну статью, конечно, сейчас я вам...
Да, ну ладно, пока, наверное, видимо, можно устроить перерыв.
Да.
Вот, и после этого перейти к чему-нибудь попроще.
Ну, сегодня мы, да, попробуем, по крайней мере, двинуться в эту сторону.
Вот, да, двинуться в эту сторону попробуем сейчас, и будем заниматься стручками.
Вот, ну возникает вопрос, да, что такое вообще строка?
Ну, в первую очередь, иметь смысл ввести понятие алфавит.
Что такое алфавит?
Это множество.
Обычно конечное множество чего-нибудь, что мы очень хотим считать буквами.
Ну, самый типичный алфавит, это, конечно, латинский алфавит.
Вот.
Ну, соответственно, там А, В и так далее, З, это, конечно.
То есть, может быть, такой, может быть, там, как вы пишете, АЗ, АЗ, вот еще можно его так.
То есть, когда ИТ, ИТ есть.
Ну, бывают еще алфавиты, которые, наоборот, из цифр состоят.
Вот нам интересны числовые строки.
Или бинарные строки, когда у нас вообще, в принципе, две цифры.
Ну, бывает еще, конечно, в некоторых областях науки используются вот такие алфавиты.
Ну, в этой области науки там начинаются руга со такими аббревиатурами, как БНК.
Вот.
Так вот.
Что такое строка?
Ну, строка – это, ну, по сути, конечная последовательность символов из алфавита.
То есть, как бы, ну, то есть, можно прям даже определение выписать, да,
что строка С длины Н над алфавитом, вот, если уж это так совсем формально писать над алфавитом,
альфа, есть последовательность, вот мы ее пишем, С1, С2, С3 и так далее.
И так далее СН, где все СИТ лежат в алфавитом 1, 2, 3.
Да, и тут сразу начинается люка.
Потому что здесь я написал определение строки в один индексации.
Альтернативная версия будет...
Ну, бывает еще в ноль индексаций.
Ну, Си плюс Пи все в ноль индексаций, но с точки зрения математики нам иногда, иногда будет удобно мыслить в этих индексациях.
Вот.
Значит, но это мы действительно будем уточнять.
Значит, если у нас есть один индексация, то, значит, можно тоже вводить, продолжать вводить определение.
Значит, пусть у нас С равно, допустим, С1, С2, СН.
Тогда, допустим, ИТ-м префиксам строки С называется строка...
Значит, называть мы ее С1ИТ, которая будет равна С1, С2, СН.
Понятно, да?
Можно вот так сделать.
Ну, соответственно, понятно.
И можно сказать, что это равно 0, 1, 2 и так далее.
Да, обратите внимание, пустая строка это нормально.
То есть бывает строка длинной 0.
Вот.
Ну и, конечно, неплохо было бы еще ввести понятие ИТ-суффикс.
Вот тут надо аккуратно, потому что в зависимости от контекста бывает, что там ИТ-м префиксам, то есть ИТ-м суффиксам вот мы будем называть...
Собственно, просто суффикс, который начинается с ИТ-го символа.
Ну тут тоже.
Нет, здесь уже проще, да?
Н и, может быть, даже Н плюс 1.
Вот.
И еще получается...
Как говорится...
Ну вот.
Под строкой...
Значит, С от L.
Значит, мы назовем...
Вот будем называть так.
С, L, С, L плюс 1, пум-пум-пум, С, N.
Вот.
Ну и здесь понятно, что...
Значит, 1 меньше либо равно L, меньше либо равно L, меньше либо равно L.
Да, то есть мы вот ведем...
То есть для подстройки вот такое удобное обозначение.
Да, иногда я буду писать через точку, иногда буду писать через запятую, но это одно и то же.
Одна и то же.
Значит, заранее предупрежу, что иногда будет очень удобно...
Очень удобно писать...
Еще полуинтервал.
Это будет у нас равно С, L, С, L плюс 1 и так далее, С, L минус 1.
Ну, понятно, теоретически, конечно, еще можно вообще тут развлекаться вот так или даже вот так, если очень хочется.
Но полуинтервал, он, конечно, еще удобен тем, что если L равно R, то тогда это получается, что подстрока пустая.
Вот. Но это пока всего лишь обозначение.
Так.
Так, вроде все, что нам потребуется.
Все, что нам потребуется.
Так, тут какие-то вопросы есть?
Нет? Все.
А то как будто я уже черный майор сказал.
Я еще познакомился с языком, о котором я буду разговаривать, но в общем-то язык для вас всегда новым быть не должен.
Разве что вот эти обозначения, они тоже отлично естественные.
Вот.
Значит, соответственно, ну, в основном весь наш курс строчек будет крутиться о задаче поиска подстрок, там, поиска подстрок текста.
Вот.
Ну и по большому счету у нас будет три уровня.
Уровень первый, значит, такой, так сказать, уровень easy.
Значит, данный...
Чего?
Уровень easy.
Дан...
Дан так называемый шаблон П.
И текст.
И текст Т.
Нам жутко интересно.
Так вот, вопрос. Существует ли действительно такой И, что П равно Т, под строка Т, от И до И плюс модуль П не включить?
Вот.
Вот таким заклинанием я могу сформулировать такую классическую задачу поиска подстроки строки.
Или даже на самом деле чаще задача формулируется даже не существует ли, в смысле, да или нет.
А часто она сформулируется в виде, что найдите все такие...
О! Кто ругается?
Так, кто ругается? Каких решений?
Хотя вот тут хороший вопрос, да.
В идеале, конечно, хочется без хэшей как-нибудь обойтись.
В идеале.
Ну, может, да.
Но, видимо, не получится.
Ну ладно, в общем, давайте как всегда.
Давайте предположим.
Знаете, так, как конкретно писать эти хэши, это надо будет еще там отдельно думать.
Ну там разные на самом деле спецэффекты возникают, но, честно говоря, возможно, лучше тогда.
Будет у нас блок занятий, или можно там какое-то занятие по хэшам, в принципе.
Или даже блок занятий, потому что там вообще нетривиальная структура есть на самом деле.
Вот. И у нас возникнет такая нота.
И тогда можно будет там в том числе обсуждать, как строить и как делать решения строчек.
Пока же можем сказать так.
Предположим, что у нас есть мистический черный ящик,
который для двух заданных строчек умеет условно называть единицы и говорить родной или нет.
Ну, точнее так.
Ну вот, если быть точнее, то черный ящик с хэшами,
он на самом деле устроен так.
Значит, ему скармливают, соответственно, какую-то строчку.
То есть инициализируют от какой-то строчки С.
Значит, он ее слушал.
Что-то там пошаманил, пошаманил, пошаманил.
Вот.
Допустим.
Ну вот, допустим.
Ну вот, допустим.
А также, ну вот, ладно, он также может, он, ладно, даже и не таился.
То есть он умеет там скушать какую-нибудь строчку С1, потом скушать там С2, С3 и так далее, бла-бла-бла.
И потом нам за от единицы неожиданно сообщать.
Не равны ли случайно?
Под строки элита и эрита у ИТ строки и под строка лжитая с лжитого пржитая в эсжитая.
Вот, в принципе, можем считать, что у нас есть вот такой мистический черный ящик.
Причем, вот эту вставку он как-то мистическим образом делает за от модуль С.
Ну то, что вы туда передадите, короче.
А вот этот запрос делает за от единиц.
Никакой амортизации, все в честном.
Единственное, что мы верим, что он не ошибается.
Да, потому что реально, когда мы говорим о хэшах, мы вынуждены запрещать, что он и тогда скотина такая может и ошибиться.
Вот. То есть, на самом деле, первый алгоритм, в общем-то, на этом основан.
Потому что, да, я, конечно, могу пока не говорить, но, как бы, вы, люди опытные, догадываетесь, что хэши обычно как устроены?
То есть, обычно они устроены так, что по каждому, по любой под строке можно вычислить мистическое число.
Про это число мы знаем, что оно, скорее всего, от нуля до какого-нибудь там 10 в девятые плюс шесть.
Или 10 в девятые плюс восемь.
Или еще у нас там было, сто семьнадцать на два двадцать третий плюс.
В общем, еще вот такое бывает, помните, да?
Ну, это классическая, вот эта пульешная, да, обсуждает свое время.
Вот. Это там всякое вот это безобразие.
То есть, какое-то мистическое число.
И про это число мы знаем следующее, что если под строки равны, то это число заведомо будет одинаковым.
То есть, одинаковым строкам одинаковое мистическое число.
Но при этом, если строки не совпадут, то, к сожалению, мистические числа тоже могут совпасть.
Ну, то есть, мы уже гарантируем, что если они не совпали, то строчки точно неравны.
Вот. Но если они совпали, то как повезет.
Ну, обычно, то есть, как, забегая вперед, можно, обычно считают,
делают такое мистическое предположение, что, ну, там, вычитается оно каким-то магическим образом, но при этом случайно.
То есть, каждому, каждой различной под строке как будто это число генерируется случайно и независимо в каком-то красивом диапазоне.
И тогда получается, что с вероятностью один, условно один делить на мод, получается разные строки могут быть признаны случайно равными.
Да. Ну ладно, чуть-чуть будем говорить, хотя, конечно, тоже надо реальный анализ включать.
Ну, ничего страшного.
Тогда, собственно, на самом деле, первый алгоритм, который тут предлагается, даже, то есть, он пока, ну, понятно,
есть, конечно, самый тупой алгоритм, который работает за, там, о от, вот, можно даже аккуратно ассердочку написать,
от модуль p умножить на модуль t минус модуль p плюс i.
Почему я тут разность пишу?
Потому что, обратите внимание, на самом деле, этот алгоритм будет работать быстро не только, когда p маленькое, но и когда p очень близко к t, правда?
Если t всего там на два символа длиннее p, то у вас, собственно, три варианта, куда эта строка может встать, и после этого, и так как,
это вы фактически изолению сравниваете без каких-то там лишних заморочек.
Вот. Поэтому тут имеет смысл написать вот такую ассинтотику, чтоб, там, оно, чтоб показывать, что вот эта штука тоже бывает мелкой.
Но, но, но, но, но, конечно же, чаще бывает, что p где-нибудь в два раза меньше t, и тогда квадрат на лицо.
Если, конечно, в тупую.
Но если у нас есть этот мистический черный ящик, ну, если у нас, смотрите, тут два варианта, либо у нас есть идеальный черный ящик, либо у нас есть черный ящик с модом, да?
Ну, потому что идеальным черным ящиком, на самом деле, то есть, можно было, то есть, так вот, идеальный, собственно, черный ящик,
на самом деле, прекрасно дал бы нам алгоритм за o от модуль p плюс модуль t.
Ну, потому что бы, а, я бы даже сказал, да, по большому счету, за o от модуль t.
Ну ладно, по модулю того, что, ну ладно, придется модуль p наверх, да, потому что вам эту строчку придется каким-то образом считать, да, да, да, да, да, да, все, да, модуль p плюс модуль t.
Ну, то есть, и модуль p, то есть, тот скажет, что, ну, p же всегда меньше t, потому что какая разница?
Ну, формально, обратите внимание, не всегда.
Чисто теоретически вам задачу могут подсунуть, является ли во, там, ну, является ли война и мир, там, под строкой слова обалдеть.
Вот. Ну, а вы за o от единицы говорите, что нет. Почему? Потому что война и мир, тупо, длиннее.
Логично, да?
Вот. Поэтому, но, ну, ради этого, вот, можно, приходится, тут, p плюс t какой-то описать.
Вот. Ну, что же, ну, вот, но это идеально.
А что делать, если у нас есть, действительно, односторонняя ошибка?
То есть, иногда некоторые разные подстроки принимаются, с вероятностью, один делить на мод за что-то одинаково.
Ну, вот.
То есть, если у нас, действительно, есть не идеальный, действительно, черный ящик с модулем mod,
то тогда возникает такой алгоритм, который называется алгоритм Рабина-карта.
Алгоритм Рабина-карта.
Что это?
Предлагает он делать следующее.
Ну, фактически, for i равно от 1 до модуль t минус модуль p плюс 1.
Ну, в общем, короче, да, начать, конечно, стоит с того, что давайте в черный ящик загрузим p и s, p и t,
ну, чтобы сравнивать, да?
Значит, он говорит...
Значит, если черный ящик говорит, что они не равны, они это p и, соответственно, t от i да и плюс p, да?
То, ну, просто можно сразу continue.
В противном случае, в чем будем делать?
В противном случае, если окажется, что p равно t от i да и плюс модуль p,
да, сравниваем на этот раз в тупую, я прямо подчеркиваю, то, ну, я не знаю, тут дальше в зависимости от постановки задачи.
Ну, как в самой простой постановке, в этом месте можно сказать риторинг трупа.
Ну, в общем, да.
Ну, и возникает вопрос, за какое симптоме это работает?
Ну, я не знаю. Тут дальше в зависимости от постановки задачи.
В самой простой постановке в этом месте можно сказать риторинг труп.
Ну и возникает вопрос, ну возникает отношение, за какой симптом это работает?
Ну в худшем случае, понятно, это работает за вон то же самое, если нам прям очень-очень-очень-очень не повезет.
Ну, если нам нужно искать все правильные ответы, то все равно задолго.
Да.
Это количество правильных ответов на П.
Ну да, но если вот да, действительно, если тут написано вместо риторинг труп, например, допустим, записать в ответ число И.
Вот да, у нас будут проблемы.
Если риторинг труп, то...
Да, то есть, но задавите, что если у нас, если риторинг труп, ну, заметим следующее, что, смотрите, заметим следующее, что каждый правильный подход у нас будет обработан за ОТ,
поэтому восьмой точке уж точно будет размер ответа умножить на модуль П, потому что мы их прям в честную проверяем, да?
А теперь давайте думать, за сколько будет проверяться каждый нечестный ответ.
Худше, то есть, каждый неправильный.
Ну, на самом деле, тут заметим, что каждый, значит, ну, давайте проверим.
Мод ожидания количества, их меньше минус С плюс один, допустим.
И дальше мод ожидания, ну, понятно, что мод ожидания будет фактически, да, мод ожидания, если не совпадает, то давайте за сколько времени в среднем узнаем, что это неправда.
Ну, заметим, что с вероятностью мод минус один делить, там, с вероятностью один делить, минус один делить на мод.
Мы тупо узнаем, что, мы тупо сразу нам уже на уровне черного ящика скажем, что все плохо, да?
Ну и плюс, конечно, еще придется сделать модуль П, поделить тоже на.
Вот.
Ну, по большому счету, да, можно сказать, что это, да, это асимптотика в среднем, еще на этот раз впервые в жизни у нас произошло в среднем с мыслям от ожидания.
Так, ну ладно, не впервые в жизни, мы тебе как-то эти реви ссылались когда.
Вот.
То есть получается О от модуль Т плюс, значит получается размер ответа на модуль П, плюс, что у нас там еще получается, ну на самом деле отсюда можно вынести модуль П на модуль Т минус модуль П плюс один, делить на мод.
Ну, то есть по большому счету, да, то есть заметим, что вот это слагаемое, если мод достаточно большой, а чаще всего мод уж как-то побольше обычно, чем длина строки, правда?
Ну, чаще мод бывает где-то около миллиарда, а модуль там П и Т порядка миллиона.
Тогда вообще получается, что в среднем, то есть у нас в среднем вообще единственное, что будет долго работать, это проверка ответа.
А если у вас ответ есть ли вхождение да или нет, то тогда это вообще все красиво, за линию работает и собственно без лишних заморочек.
Понятно?
Так что вот это вот алгоритм радино-картов.
То есть в принципе с точки зрения практики может быть вполне себе использован.
Особенно, знаете еще, особенно если еще и заметить, что на самом деле вероятность того, что он, то есть мало того, что с вероятностью один делить на мод, он отсечен.
Так еще и прикол будет в том, что скорее всего мы достаточно быстро, если строки реально не совпадают, то скорее всего мы достаточно быстро убедимся, что они реально не совпадают.
Ну, если там еще и символы какие-то более-менее рандомные.
Это вообще неправда, там конечно зависит, какие хэши брать.
Ну да, так хэши, как у нас там устроенные, то там есть подозрение, что там можно специальным образом сгенерить строчки и где-нибудь в конце подменить, чтобы совпали.
Но это так, то есть как вы говорите, что если реальная жизнь, скорее всего нам такие контртесты подкидывать, если будет только и нередко.
Поэтому в общем-то обойдемся без этого.
То есть это если вот верить в черные ящики, то можно попробовать это сделать так.
Ну это конечно если эти черные ящики делают.
Итак, то это есть черный нор.
Ну с другой стороны, вот возникает вопрос.
А можно ли эту задачу решить без черных ящиков и каких-то там вероятностей?
Ну да, здесь тоже можно по-разному.
Ну на самом деле нам будет полезно изучить эти два классических способа, действительно как это делать.
Правда в одном из них мы тоже попробуем начать с черного ящика.
Но чуть позже у нас приведет собственно к...
Потом мы этим и встанемся.
Да, вот попробуем.
Да, кстати, на всякий случай.
Кто когда-нибудь писал алгоритмах Акарасика?
Алгоритмах Акарасика.
Ну да, как вы чуть позже допомните.
Правильно говорить алгоритмах Акарасика, потому что Акарасик это макро.
Ахо по барабану все равно не склоняется.
Простите меня товарищ Альфред, но...
Прикол.
Значит, итак.
Но, значит, теперь вытекает следующая идея.
Смотрите.
Как теперь более правильно использовать черный ящик?
Как более правильно использовать черный ящик?
Ну, точнее так.
Но, по большому счету, да.
Если мы свято верим в черный ящик,
сейчас мы будем некоторое время,
прям, свято верить, что черный ящик не ошибается.
Вот.
Ну а сейчас я сделаю более ситрое
использование черного ящика.
Но от которого я потом избавлюсь.
Да, метод будет называться метод двухуказательный.
Идея такая.
Значит, я начну с того,
что я, вот, сначала попробую понять,
где, то есть, не верно ли, не верно ли,
случайно, что строка P равна пресесу строки T?
Что я буду делать?
Я буду идти, идти, идти, идти,
вот, дойду, наконец, до первого этапа.
Вот, дойду, наконец, до первого места,
где два символа не совпадут.
Вот.
Это у меня будет, соответственно, вот такой указатель.
Понятно, да?
Ну, если он дошел до конца,
то, значит, я указатель остановлю там, где принес.
Вот.
Что я сделаю дальше?
Дальше я сдвину вот этот указатель.
А вот этот указатель, ну, в методе двухуказательных,
я ж не хочу этот указатель на лево сдвинуть, правда?
И тут я счетирую.
Я воспользуюсь черным ящиком и спрошу.
Слушай, скажи, пожалуйста,
а вот это вот не префикс строки P случайно?
Просто да или нет?
Вот.
Значит, ну, заметим, что если это не префикс строки P,
то, в общем-то, начинается этого момента
искать подстроку, совпадающую с P,
уже бесполезно, правда?
Понимаете, да?
Тогда я буду ее вот сдвигать, сдвигать, сдвигать, сдвигать.
И вот наконец, ну, вот буду так двигать,
это буду проверять как префикс,
вот это и так далее.
Теперь.
И вот наконец я совершенно случайно обнаружил,
что вот, например, вот эта подстрока
является таким префиксом строки P.
Видите, да?
Вот, понимаете?
И начинается с этого момента.
И теперь думаю, так, раз префикс совпадает,
то если я хочу проверить,
если тут вхождение,
то я начинаю проверку просто уже
с синим указателем, но вот с этого места.
И честно, двигаюсь, двигаюсь,
двигаюсь, двигаюсь.
Ну, до тех пор, пока у меня тут
тут не произошел символ Z,
а вот где-нибудь вот тут оказался символ A.
Ну, или могло быть так случиться,
что я вот прям всю подстроку нашел,
прям дошел и раз.
Вот, понимаете, да?
Вот такая тесна.
Теперь все совпало даже вот так.
Ну, так вот, моменты не совпадают.
Дальше я тоже буду теперь проверять.
Вот этот префикс есть.
И дальше я буду двигать, двигать, двигать,
до тех пор, пока не наткнусь снова на префикс,
который у нас совпадает.
Вот это буду проверять, вот это,
но это все вот плохо, плохо, плохо.
Красные, зеленые местами немножко перепутал,
но неважно.
Вот, то есть получается вот с таким
читом, то есть если мы
такой вот,
то есть если мы вот умеем
проверять вернули, что вот эта строка
совпадает с префиксом каким-то образом,
то у нас получается все работает
за лиги.
Потому что у нас, ну, потому что
просто типичный метод двух указателей,
и у указателя двигаются только вправо в каждый момент времени.
Вот, прямо так.
Вот.
То есть вот у нас получается,
алгоритм работает за O от N,
но, правда, в предположении,
что мы верим в черную магию.
А теперь, ну вот,
ну наша, конечно же, цель
попробовать избавиться
от черной магии.
Как же нам избавиться от черной магии?
Как же нам избавиться
от черной магии?
Ну, во-первых, начнем со следующего.
Изначально мы бы говорили, что мы хотим
в этот черный ящик запихнуть строки
P и T, да?
Но, значит, оптимизация номер раз.
Черный ящик достаточно
запихивать, это вот важный
просто именно момент для понимания,
только строку P.
И ничего окромя.
Вот.
Понятная идея, да?
Почему?
Да, потому что, по большому счету,
когда мы,
когда мы в следующий раз
будем тут вот этим черным ящиком
проверять вот какую-то строчку,
она является суффиксом
какой-то строки, которая уже
точно является префиксом
строки P, правда?
То есть,
по большому счету,
у нас все запросы
имеют вид.
Верно ли, что под строка P
от A до R
равна?
Ну, вот
чему-то такое.
Дальнее.
Понимаете, да?
Вот.
То есть, по большому счету, так.
То есть, мы просто вот двигаемся, двигаемся,
так перемираем.
Но более того, кстати, может так
случиться, что когда мы дойдем до следующей
первой строки, которая совпадает,
может так случиться, что мы в этом месте, кстати,
и дальше пойдем. Почему?
Может так случиться, что это-то совпадает,
а следующий символ нет, правда?
Понимаете, да?
И получается, что тут
придется еще префикс найти,
дойдем до нуля, дойдем, выясним, что этот символ даже
с первым символом не совпадает,
поэтому просто и красный, и синий отправляются дальше.
Понимаете, да?
Чему нас это приводит?
По большому счету,
теперь попробуем подменить черный ящик
на другой черный ящик.
Как мы это сделаем?
Будем пользоваться тем, что уже вычислили раньше.
Да. Ну,
мы еще пока ничего не вычисляли,
но раньше черный ящик говорил,
верно ли, что вот эта подстрока
равна вот этой. Но теперь заметим,
что по большому счету у нас задача в следующем.
Дан префикс, то есть на самом деле теперь
черный ящик будет устроен по-другому.
Он будет говорить нам,
так,
дан префикс длины и.
Да?
Я хочу получить
в убывающем порядке
такую последовательность,
допустим, и1,
там вот, и1,
и2,
там, и3, и так далее,
иL-то равно нулю.
Так, что
и строго больше и1,
строго больше и2, строго больше и так далее,
строго больше иL.
И такие, что,
я хочу вот, ну, все такие и, что
п от,
вот, я так пишу,
и-и1,
и,
смотрите, я такой полуинтервал в другую сторону, да?
Верно ли,
что эта подстрока совпадает с префиксом?
Только тут не и1,
а, конечно, и,
какое-нибудь жидкое.
Ну,
смотрите,
значит, у нас чёрный ящик
не требует от нас совпадающих,
проверять, совпадают ли какие-то две подстроки,
а, по большому счёту, мы говорим так,
у нас есть префикс,
строки P, вот он.
Я хочу, по большому счёту,
найти все его суффиксы,
которые это есть,
и, ну,
я хочу,
я хочу, я хочу, я хочу,
я хочу найти все его суффиксы,
которые тоже являются префиксами.
То есть, я хочу найти
все вот такие строчки,
прям последовательностью
бывающих длин, которые совпадают
с префиксами.
Вот, очень хочу.
То есть, если, ну,
так, у вас питон был?
А, значит, можно на языке питон.
То есть, если у вас есть денератор,
который денирирует вам
вот эту последовательность,
то обратите внимание,
с помощью этого денератора
вы тоже реализуете алгоритм
за ОАП, правда?
Вот, согласны?
Вот.
Ну, теперь, значит,
как же его сгенерировать?
Ну, на самом деле, этот денератор можно не делать
денератором, а можно
переформулировать.
Ведь, заметим, на самом деле,
следующее, что в этой последовательности
каждое следующее,
каждое следующее число
фактически однозначно зависит
от предыдущего, правда?
Почему так? Ну, просто потому,
что, давайте посмотрим.
Жил был у вас префикс длины и,
и вот был вот этот вот и1
максимальный.
А вот теперь возник следующий
и2.
Ну, а
вот он возник, и2.
Ну, теперь, заметим, что этот и2, он, на самом деле,
так как вот эта подстрока совпадает с этой,
ну, в принципе, и здесь вполне себе это и2,
вполне себе с ним совпадает.
И, фактически, этот и2 — это максимальный
суффикс вот этой строки
совпадающей с префиксом, но не совпадает,
но чтобы и2 не совпадало с ней самой.
Правда?
Так, лучше же, ну, надо,
мы хотим свести к префиксу поменьше.
Ну, можно так, потом можно
эту картинку сюда сдвинуть.
И, по большому счету,
мы теперь, это нас
приводит к такому понятию,
как
ну, вот, префикс
функция. То есть, теперь мы
вводим такой массив,
как π от 1 до n,
это, ну, вот, ну, n в смысле
модуль p, конечно, это будет
называться у нас префикс
функция.
Префикс функция.
Как это будет называться?
Определение очень простое, то есть
π и t —
это будет максимальное
такое
i1, ну, просто
мог бы написать g, но вот для
консистентности с этим напишу.
То есть, максимальное i1,
что i1 меньше i,
и, соответственно,
префикс длины i1
совпадает
с подстракой длины i1
кончающейся
в этом судьбе.
Вот. То есть, по большому счету,
теперь,
то есть, давайте себе представим,
что
какой-то мистический товарищ
присылает нам по заданным, то есть,
черный ящик присылает нам вот эту функцию
с небес по факсу.
Как он у нас часто это делает?
Вот.
Тогда заметим,
что, по большому счету,
то есть, с точки зрения этой функции,
у нас получится, что i1
То есть, по большому счету,
это теперь у нас равно
π от i1,
это равно
π от i1.
Кстати, обратите внимание,
нам тут очень...
Ах, да.
π от i,
это равно
π от π от π от i.
Обратите внимание, кстати,
почему я сразу оговариваюсь,
что мы будем вводить две разные индексации.
Потому что в анализе строчек
оказывается всегда, что в некоторых случаях
удобно работать в одной, в один индексации,
а в некоторых случаях в ноль индексации
удобно работать.
Ну, скажем, какой-нибудь там вот
скажем, какой-нибудь субмасс или, по-моему, даже
z функция удобно будет работать в ноль индексации.
А вот префикс функции, она идеальная
действительно ложиться именно в один индексации.
Ну, вот в ноль индексации, наверное,
если вы это когда-нибудь писали,
вы натыкались там на всякие эти вирусы и денечки, правда?
Было дело, да?
Ну, вот.
То есть, получается, скачем, то есть
π, п, п, п, вот скачем, скачем, скачем.
Вот.
Ну, вот.
Ну, и в результате,
то есть, если нам эту префикс функцию
откуда-то присылают с небес
по факсу, то
после этого,
то есть, действительно, вы тоже все
работаете за линию. На этот раз
код будет выглядеть примерно следующим образом.
Да.
То есть, да, я специально там
немножко не так обещаю.
Ну, я, конечно, там не питаю иллюзию
на тему того, что мы никогда не сталкивались
с префикс функции.
Я даже не спрашиваю вообще,
сталкивались вы с ней или нет.
Понятно, что сталкивались.
Ну, вот, вы там
с какой-то вероятностью могли не столкнуться
с ахакараси, но
именно как-то вот не с этим.
Вот.
И получается дальше следующее.
То есть, ну, теперь
заметим, что предположим, что мы
откуда-то есть префиксунцы, в чем
только на строку P, да?
Тогда поезд под строки
выглядит следующим.
Значит, будет
тогда выглядеть
примерно следующим образом.
Вот.
Значит, смотрите, пишем
а, ну, здесь я буду.
Значит, я завинту вот этот вот
вот этот красный указатель.
Он, на самом деле,
вот красный указатель у меня будет
вот эта вот переменная у меня
будет равна, ну, допустим,
a, да? То есть, вот я буду хранить
не где этот красный указатель
начинается, а длину.
И код получается так.
Изначально a равно w.
И дальше
мы говорим
for i
равно от одного. То есть, с
синим указателем мы прибираемся
по всем символам t.
Вот. И дальше говорим,
что у нас прямо сейчас
перед началом
работы с этим символом l
на самом деле будет равно вот этой величине.
То есть, вот самый
самый длинный подстрок
я заканчиваю в этой позиции, являющий
префиксом строки P. Понятно, да?
Вот.
Ну, теперь возникает вопрос. Мы уже
понимаем. Мы уже
то есть, это самое длинное,
поэтому, как бы, очевидно, что
теперь возникает вопрос.
Можно ли эту, ну, действительно, то есть
продлить, то есть, сдвинуть синий указатель,
да или нет?
Ну, синий указатель, ну, тут у нас
всегда два варианта. Мы либо синий указатель
сдвигаем на единичку, либо
красный указатель сдвигаем,
заменяем l на пятый, правда?
Ну, вот.
Ну, в данном случае, чтобы
значит, пытаемся максимально
там, двигаемся, пока это
необходимо красный, и это звучит так.
Значит, пока
значит, l равно
модуль P.
Значит, или
оказалось, что P
от l плюс 1
не равно, соответственно,
t и тому.
То есть, пока нельзя продлить,
то есть, пока вот прям синий указатель
нельзя сдвинуть,
то мы, соответственно, пишем, что
l равно
P от l.
Вот такой вот валик.
То есть, пока нельзя сдвинуть, мы никуда
двигать не будем.
Ну, тогда после этого,
ну, вот.
Ну, вот.
Ну, в самом конце, раз вал
остановился,
то значит, пришло время этот синий указатель
сдвинуть. А раз мы синий указатель
сдвигаем, то l автоматически
вылечим.
Плюс l пишем мы.
Значит, идем дальше.
То есть, плюс-плюс l.
Ну, и, соответственно, ради чего мы все это
делаем? То есть, если
мы обнаружили неожиданно, что
l равно модуль
P, то
значит, ну, давайте.
То, соответственно, что-то мы тут делаем
на тему того, что
значит, t от
соответственно,
i минус модуль P
равно
модуль P.
Походим на вопрос.
А если...
Так, давай-давай-давай.
Ну, в общем, если у нас этот символ,
вообще даже ни с чем нельзя.
Да, совершенно верно.
Да, не успел.
Если спросить, найдите ошибку.
Ну, это действительно правильный момент.
Ведь может так случиться, что
этого не произойдет
никогда. Ведь может же так
произойти, что мы переберем все
вот эти вот префиксы,
они же суфиксы, прям до нулевого
включительно, и даже нулевой продвигки
удастся. Может же
такое быть?
Может.
И если такое будет происходить,
то мы тут, получается, у нас тут
появится функция P от нуля
и просто крик and define behavior,
потому что P от нуля мы не определили.
Что же делать?
Поэтому придется здесь
чуть-чуть поаккуратнее писать.
Первое, что придется проверить, это L
больше нуля.
И уже в скобочках
проверять.
L равно равно модуль P
или...
И плюс плюс L, конечно же,
мы в итоге делать будем только
если...
Значит, тут
знаете, можно напрямую написать
P от L плюс один
равно равно
T и T,
то плюс плюс L.
В противном. Но заметим, что
это не так может быть только в случае,
если L равно нулю и продлить дальше нельзя,
поэтому в этом случае ничего делать не надо.
Вот тут действительно можно так
написать.
Вот.
Вот, на самом деле, правильный код
вот так вот.
Понятно, да?
Понятно?
Вот. И чем приятен
этот код? Тем, что он железобетонно
работает за...
Вот сам по себе
этот код работает за O
от модуль T. В общем, даже не
P плюс T, а модуль T, обратите внимание.
Потому что два указателя эти
двигаются именно за O от P.
То есть...
То есть, смотрите, можно даже более
точные утверждения искать. Если мы один
раз откуда-то нам с небес
по факту пришлю префикс функцию
для строки P, то искать ее
под строку мы можем теперь в любом тексте
и каждый текст перебирать
за O от его длины. То есть не придется там
вот...
То есть, более того, префикс
функцию придется один раз искать.
То есть, если вот забегая
вперед мы ее научимся за O от P искать,
то несколько текстов мы обработаем
за O от P плюс суммарную длину
этих текстов, а не
суммарную длину этих текстов плюс P умножить
на количество этих текстов.
Так, это понятно, о чем я говорю, да?
Вот.
И более того, как бы и в качестве
дополнительной памяти, если нам префикс
функции там требует дополнительную память
как хранение этого массива, то обратите внимание,
то дополнительная память требуется всего лишь
от P.
Неплохо, правда?
Вот.
Остается только
мистический вопрос.
Как же
ее найти?
Ну, собственно, мы уже все и написали
более-менее.
Вот. Ну, как сказать,
ну не совсем так.
Да, это я еще
вот так не искал.
Но на самом деле обнаруживается, что
саму по себе префикс функцию
оказывается
можно найти примерно
тем же способом.
Потому что мы по факту искали как бы префикс
функцию для такого объедения
примерно.
Ну да.
Ну нет, искали-то искали, но
мы ж пользовались префикс функции
как черным ящиком.
Да, но в смысле те же самые.
Ну вот. Но оказывается, что идея
та же самая, действительно.
Что теперь как же искать вот эту вот
саму префикс функцию?
Оказывается, что она ищется так.
Вот у нас есть, допустим, строка P.
Мы будем искать эту префикс функцию честно
слева-направо. И вот, допустим, дошли до
этого символа все префикс функции
до этого момента мы знаем.
Вот.
Вот.
Да.
Ну вот.
Ну теперь давайте посмотрим.
Пусть вот это вот
и есть...
Давайте, ладно, покороче напишу.
Вот это вот
и есть P от P.
Допустим, да?
То есть мы знаем, что
эта строка совпадает
с префиксом строки P, при этом
собственно, это не строка длины
к ней, правда?
Тогда если отпилить от этой строки
один символ,
то замечаем, что
вот эта вот штука
это подстрока совпадающая
с префиксом,
ну, по значению, но не
по позиции, и заканчивающаяся
позиции именно с этой.
Что это означает?
Это означает, что по большому счёту
она лежит среди вот этой вот
весёлой последовательности, да?
Значит там
P от I-1,
P от P
от P-1,
П
от P
от P-1,
и так далее.
Среди этой последовательности
она лежит.
То есть получается, например, если бы мы искали
опять с помощью хэшей
каких-нибудь этих вот,
то мы бы сказали, что раз у нас
P от I-1 вот здесь, то заметим, что
вот этот указатель двигать
влево смысла нет, потому что
вот здесь это подстрока больше
чем вот это не будет, правда?
И после этого тогда остаётся
просто двигаем, двигаем, двигаем, пока не совпадают.
Вот можно было так двумя указателями сделать.
Но в реальности нам
это не нужно делать, потому что
нам достаточно просто у этой строки
все суффиксы, совпадающие
с префиксами, перебрать
и каждому проверить, не совпадает ли там
следующий символ Freedom, правда?
Вот понятно, о чём я говорю, да?
Честно говоря,
по вам кажется, что вы
уже не очень понимаете,
что происходит.
Ну да, в общем ладно, хорошо, что я
это рассказываю сейчас.
Потому что дальше начнётся более сложная
вещь, не там хотелось бы, чтобы
чуть-чуть менее сонная очень сильно.
Да, я понимаю, что на втором пути
это сложно.
В результате
ну тут два варианта на самом деле.
Потому что префикс функцию
теперь искать можно примерно так.
Например, один вариант там
1 всегда равно 0, тут без вариантов.
И дальше пишем
и равно 2 модуль
p.
И дальше технология говорит нам
следующее.
Она говорит там, допустим,
int j равно
p от
i.
Дальше while
j больше 0
and
p jt
p j
плюс первое, пардон, не равно
и т.е. нельзя вот это продлить.
То, соответственно, j равно
p от j.
Ну и дальше пишем, что
если
оказалось, что
p от j плюс 1
равно p и
то, соответственно, пишем
p от i равно j
плюс 1. В противном
случае
p от i равно 0.
Все.
И ровно по тем же
двум
нот двоеуказательным причинам
эта конкретно
функция работает за o
от модуль
p.
Понимаете, да?
Оно.
Отлично.
Время еще есть.
Вот.
Но на самом деле здесь, в этом коде
еще обсудить.
На самом деле этот код,
ну, как бы,
на самом деле, действительно, любой
проходящий настоящий код ревью, конечно,
сразу заметит, что
тут имеет место
определенного рода копипаста, правда?
Понимаете, да?
Да.
Вот. Просто он совсем копипаста.
То есть, по большому счету,
тут на самом деле
можно написать функцию
go.
Значит, от int, допустим,
ж, ладно, int
l, конечно, да? То есть, допустим, что
у нас и
char какой-нибудь
sh. А шо, вопрос какой?
Значит, смотрите. Да, тут сейчас
внимательно надо смотреть.
То есть, она говорит там следующее,
что вот мы идем по строте,
не важно какой, и мы
говорили, что максимальный
суффикс этой строти, совпадающий
с p, да?
Имеет длину l, допустим, да?
И мы хотим
приписать к этой строке l
новый символ
char. Вот даже
char. И мне
жутко интересно, чему
будет вот самый длинный
суффикс o этой строки равный, совпадающий
с префиксом строки p. Понятно, да?
Я буду делать функцию b. Если я напишу
эту функцию go, да?
То, в общем-то,
я могу
по большому счету здесь
написать
практически сразу l
равно
go
от... Даже вот так.
Даже зелененьким напишу.
То есть, могу написать
go
от l и t.
Все.
Видите, просто одна строчка.
И уже тут какой-то ивчик добивать себе.
Понятно, да?
Да и здесь, в общем-то,
обратите внимание,
то есть,
на самом деле, я могу
вот вместо этого всего написать...
То есть, я просто
вот это все упираю и говорю,
что
p от i
равно, на самом деле,
go
от p
от i-1
и
t.
Вот.
И где внутри
этой функции go, я пишу
там while
условия... Ну, например, могу написать while
l больше 0,
and
допустим, модуль p
равно равно a, или
что-то еще. В роли что-то еще.
p l плюс 1
равно равно ch.
Значит, l равно
p от
a.
Вот здесь мы передаем не ch,
а p и t, потому что...
Внизу.
Ничего передаем? Ну, функцию go мы
передаем p и t.
Нет, минус 1 мы... Нет, вместо ch,
вместо ch, p и t.
Не p и t, а p и t.
А, да-да-да, правильно- правильно.
p и t.
Да, p и t. Спасибо.
Вот.
Ну вот, ну и тут пишем, что
там...
То есть, допустим...
Ну вот.
Ну и, соответственно, да, если
значит, p l плюс
1 равно равно
ch, то приторм
l
плюс 1,
в противном случае
вернуть
1.
Вот.
По большому шутеру
вот у нас имеет место функция go.
То есть, видите, я
по большому... Я просто... Вот, можно посчитать,
казалось бы, что я просто избавился
от этой пасты, правда?
Но на самом деле,
то есть, хочется обратить внимание еще на один
приятный факт. Потому что
ведь заметим, что функция go действительно
зависит только от a и символа,
правда?
То есть, на самом деле,
видите, то есть, мне достаточно...
Если я иду по строке t,
или там почему-нибудь еще, мне достаточно
знать... Мне не нужно знать весь префикс,
мне нужно знать только суффикс этого
префикса, который совпадает с префиксом
максимальный, да?
Для наших целей поиска
по строку, это все, что мне нужно знать.
Потому что, оказывается, если я знаю
вот этот предыдущий префикс и новый
один символ, то я могу следующий найти.
То есть, обратите внимание, если я хочу просто
найти все подстроки
значит, p в тексте t, мне сам
текст, на самом деле, в некотором смысле,
хранить даже не надо.
По большому счету, мне
я могу просто взять эту строку
p, обработать ее,
а потом мне этот текст могут передавать
просто по одному символу кидать.
Он мне кидает символ, и я говорю
м-м-м... Куда? Второй
м-м-м... Третий
м-м-м... Четвертый
п-п-п-п-п-п-п
м-м-м...
Пятый
м-м-м... Потом...
О! Схождение собралось!
И еще так подумали.
То есть, можно прям в канал
докидывать символ, а я говорю
образовалось у меня новое схождение или нет?
Но есть маленькая подляночка.
Если мы говорим о таких каналах,
и когда нам приходит запрос, типа, припиши
к темпу новый символ, и скажи, не добавилось ли
новых схождений, да,
то у этого алгоритма будет серьезный
изъян.
Потому что новый символ
будет обрабатываться, конечно, за вот
единицы, но с
очень неприятным в этом случае словом
учетно.
Да, суммарно-то это все за
p плюс t будет работать, но
на каждом конкретном символе мы
можем зависть.
Но с этой точки зрения, на самом деле,
можно глянуть это по-другому.
Ведь заметим, что если алфавит у нас не
сильно большой,
то
в идеале
можно составить
на самом деле.
То есть, попытаться действительно
это go вместо процедуры
создать мистический
массив,
значит, допустим,
от нуля до модуль p,
и тут, допустим,
от а до z, ну или
какой у вас там алфавит, чаще всего от
а до z, правда?
То есть, ведь заметим, что мы же
теоретически можем попробовать
заранее.
То есть, теоретически можем, если у нас есть
префикс функция, да,
то мы можем, могли бы попытаться действительно
функцию go на самом деле
действительно свести
просто, то есть, вычислить заранее вот этот
массив, то есть, предпочитать все возможные
запросы, а потом на каждый этот запрос отвечать
просто за 1, правда?
Понимаете, да?
Вот очень удобно.
Вот.
Ну и на самом деле
тут уже, то есть, на самом деле
вот очень хочется посчитать эту функцию,
я ее люблю называть
автомат префикс функции.
Вот.
Ну почему автомат?
Потому что, так, ну вы же уже проходили
автомат, правда?
Ну тогда легко убедиться, что да,
это просто автомат.
Полный, детерминированный, конечный
автомат, если уж на всем полную там
технологию уводить.
Да что приятно, совсем полно, правда?
Вот.
Значит, теперь
остается только один вопрос.
Как же нам этот автомат
вычислять?
Ну, оказывается, на самом деле
просто вот этот вот код
я сейчас могу переписать, пока просто
рекульсивно, я ж могу вот этот файл делать
рекульсивно, по большому счету.
Потому что на самом деле
вот этот файл я могу написать так.
Смотрите.
Значит, я напишу так.
Если...
Ладно, давайте.
Давайте черненьким попишем.
Хорошо.
Значит, внимание.
Значит, если, говорю я,
оказалось, что
у меня есть
автомат,
у меня есть автомат,
значит,
л равно нулю.
Что я делаю?
Ну, по большому счету
возвращаю
просто ч равно
по первому.
Ни больше и ни меньше, правда?
Ну, я могу, конечно, написать там еще
этот вопросик 1, 2, 0,
но этот индуизм мы разводить не будем.
Да.
Нет, инди не киндусы люди
как писать.
Потому что они там иногда проверяют какую-то
бульевую функцию там методом.
Если это f,
f.toostring.length
меньше 5,
какая-то такая координация.
Но это, конечно, надо верить, что...
А, ну да.
Я не знаю, там на уровне шутки
или кто-то реально так разлёгся.
Но...
Но в противном случае
мы говорим,
что если оказалось,
что l меньше,
чем модуль p,
и оказалось, что p
l плюс первое
равно этому
ч,
то мы просто возвращаем
l плюс 1.
В противном случае,
что мы делаем?
Мы вызываемся
рекурсивно.
Мы вызываемся от
p от a
и еще.
То есть, по большому счету,
ну, можно так сказать,
опять, если нам
эту префикс-функцию прислали с небес по факсу,
то go
мы теперь можем насчитать просто элементарно.
Более того, ну, код пока выглядит
рекурсивно, но на самом деле
заметим, что если я...
что я могу просто бронетанком пройтись
на самом деле
от 0 до p по всем символам,
прям честно каждый новый символ за 1
запомнить, правда?
Вот.
Но фишка на самом деле
тут еще
крутая.
Потому что
на самом деле никакой рекурсии вообще не надо.
Потому что на самом деле
есть еще мистическое утверждение.
Дело в том, что, как легко догадаться,
pi t,
то есть pi plus 1,
давай так, каждая следующая pi,
ладно, лучше так,
pi t, когда i больше 1,
оно равно
оно равно
оно равно go.
Go от
pi, pi minus 1
и
pi t.
А, ой!
Откуда же я взял это, да?
А я тут недалеко
вообще никуда не ходил.
Ну вот, то есть в результате
это вам позволяет, на самом деле
вот этот вот go
насчитывать одновременно
с префикс-функцией просто.
Понимаете, да?
То есть по нот
то есть по большому счету,
то есть в результате, вот так, давайте я
где-нибудь
так, ну думаю,
вот это вот на месте.
То есть это мы все определили,
что мы радость определили,
и получается,
что, оказывается,
оказывается,
что на самом деле
подсчет этого go
и этой радости,
то есть на самом деле можно привести
так, интересно, какой тут
Google IT-махи, о котором
это пишется, значит, делается, получается так.
То есть вот предположим,
что мы хотим насчитать и go,
и префикс-функции, да?
Значит, мы теперь начинаем,
что for ч равно
a до z,
пишем go
от нуля, там,
условно, чита,
да, я тут не буду
вот это a вычитать, все равно все такое пишем, да?
Ну вот я, нет, видите, у меня
массив в паскальском смысле так изобретен,
хоть кто-нибудь на языке паскаль?
Нет, так 7-8 назад.
7-8?
Так, что я делал
7-8 назад?
Так, 22-24.
А, я же к финалу
готовился, 8 я был.
Да, я ездил в
14-му ряду, что называется,
на Чемпионат мира, на Международный город,
великий город,
Екатеринбурж.
Да.
Ну вот.
Значит, так вот, значит,
go от ч будет равно,
ну, как мы уже сказали, да,
п1
равно ч.
Ну, 0 или 1, понимаете, да?
Ну вот.
Дальше.
Ну, дальше пишем for и
равно от 1
до, соответственно, модуль p.
Теперь говорим. Ну, начнем с того,
что p от i, как мы уже сказали,
равно go от
p и минус 1.
Ну, соответственно,
p.
p мы знаем.
Понятно, да?
Вот.
Ну, а вот
теперь мы начинаем
for ч равно
а, z.
Ну и говорим,
что если оказалось, что
p это
нет, ладно, погодите, погодите,
для начала. Если оказалось,
что i все еще меньше модуль
p,
значит, если оказалось,
что i плюс 1 меньше
либо равно модуль
p
and,
значит, соответственно, end-end
p
i плюс 1 равно
равно ч
p. Чего?
Да.
Ну, то, соответственно,
go
от и ч
равно и плюс 1.
В противном случае
мы уже точно знаем, что придется
скакать в пишку, правда?
Поэтому и говорим,
что если оказалось,
а, а ничего
не оказалось.
На самом деле мы даже заморачиваться
и будем. В противном случае
go и ч просто равно
go
от p
от и.
Да, это ж и заведомо больше нуля,
поэтому тут даже лишнее не вставить не надо.
То есть либо
следующий символ совпадает, и мы
прибавляем 1, либо идем дальше.
Можно было это, если хотите совсем
короче написать, можно вообще тогда
им операторы написать.
Но я думаю, это не нужно, потому что
не очень удобно читать.
То есть на самом деле, да,
это конечно работает не за o от
e, это работает за o от модуль p
на размер алфавита, конечно.
Если у вас,
то есть, заметим, то есть вот тут важно
понимать, что если алфавит маленький,
то да, вы можете написать вот эту функцию go
и после этого, на самом деле,
обработку текста сделать так, что
новый символ обрабатывает за o от единицы
в честную, потому что у вас есть автомат.
То есть, знаете, там
бывают, на самом деле, даже в спортивном программиру,
у них встречаются задачи, в которых это бывает
полезно. То есть так, классическая
задача, например, это
например, представьте, вам
дано такое,
то есть вам дана строка p и
подвешенное дерево.
Ну подвешенное дерево,
на каждом ребре написана буква.
Нет, не
путайте сбором, пожалуйста, там одинаковые буквы,
торчащие детей, могут вполне быть.
Почему нет? И у вас
веселая задача. Найдите, пожалуйста,
все обхождения строки
p в эту дереву. Обхождения, в смысле,
возьмите путь,
имейте в виду только чтобы
вертикально. Да, только вертикально.
Вот эти вот, это там уже отдельная песня,
на самом деле, какими разделями
и центровыми надо делать,
или чем-то еще. Но если вы,
но заметим, что
это делать префикс функции, действительно,
но заметим, что именно здесь
помогает автомат.
Да, но помните,
что если автомат
не построите, то как с персистентностью.
То есть, может, так и вам
могут подсунуть тест, на котором
называется там, переход будет работать,
каждый переход будет работать долго.
Как-то была у нас классика, да?
Я буду заставить того старого фрича
открыть нас еще раз,
еще раз, еще раз.
Вот.
Ну вот.
А конкретно автомат, действительно,
это очень красиво сделает.
Впрочем, обратите внимание, работает это
только за О от модуль П на
Альфа.
То есть,
совсем для нот.
Потому что, действительно,
это так себе будет работать,
так себе будет работать, если Альфа,
если размер алфавита,
будет сопоставим с размером строки,
тогда придется
исходную версию притикс функции использовать,
потому что исходная версия притикс функции
размер алфавита не пользовала никак.
Она пользовала по факту
только одно, что мы умеем
взять два символа и сказать, они равны
или нет.
