Ну что, давайте начнём, значит сегодня мы изучаем NP полные задачи,
значит NP полных задач очень много разных, их буквально сотни тысяч,
есть такой старый учебник, ещё в 1979 году написан и в 82-м изданном в СССР,
называется по-английски Computer and Interactability, по-русски вычислительные машины и трудно решаемые
задачи, авторы Гэри и Джонсон, и там в конце учебника большой список разных NP полных,
ну и разных других задач, то есть такая большая классификация, хотя основной материал несколько
устарел, ну просто гораздо больше всего придумали, но вот эта классификация, она в общем до сих пор
актуальна, и очень многие задачи имеют как бы свой номер в этой классификации Гэри и Джонсона.
Значит мы конечно охватим только маленькую часть, некоторые самые важные задачи изучим,
вот, но ещё на самом деле хочу сказать, что в одной из групп на PMI-информатика уже много чего
изучили, да, некоторые что конструкции изучили, так что я отчасти повторюсь в плане задач, но
скажу другие сводимости, да, так что даже если вы это уже прошли, то вы увидите что-то новое,
вот, хорошо, значит давайте я напомню, что мы вообще изучили, значит у нас были эти сводимости,
да, я запишу, чтобы было в разъёме, что означает, что задача связывается с предназначением,
что означает, что существует лес, предназначение, что значит X, значит X нежит 2, тогда это
значит X нежит в B, значит соответственно если B нежит в B и A находится в B, то A тоже нежит в B,
значит это то зачем своим с приёмом, значит дальше поделение ПП на П, значит BNP полное,
если B нежит в P, и для любого A из NP верно, что A сводится в P, значит также у нас было утверждение,
значит утверждение такое, что если BNP полное, B сводится к C, и C лежит в NP, тогда C у нас тоже NP полное,
вот это утверждение, которое позволяет получить новую NP полную задачу, надо получить NP полную задачу,
нам нужно доказать, во-первых, что она лежит в NP, но как правило это часть очевидна или очень проста,
получается исключение, наверное, легко, но обычно-то легко, ну и вторая часть, что какую-то уже известную
NP полную задачу свести к нашей, то есть это в принципе такой процесс как снежный пол, да, такая репидемия,
что как только мы свели какую-то NP полную задачу, какую-то новую, эту новую можно использовать для доказательств
этого NP еще в следующих задачах. Получается такая как бы сеть соединений, ну и она начинается с того,
что мы изучили в прошлый раз, да, то есть в прошлый раз была такая точка, да, конечно, во-первых,
во-вторых, почему-то работает это из-за транзитивности, да, что любая сводится в В, а потом В сводится в С,
поэтому любая сводится в С. Так, значит любая NP у нас сводится, значит, в ТАИ-Амсад,
вот, дальше ТАИ-Амсад сводится в С, вот такой приоритет. Но это было круче нас, что у нас есть машина, вход.
Пошел с другими аргументами, первый вход, я пришли на время работая, и вопрос, можно ли добавлять второй вход,
так, чтобы машина на этих двух входах выдала единицу, ну и второй вход там ограничен от длины,
и при этом работала бы за время, которое еще задано на банарной записи, тоже как аргумент.
Но, в принципе, это тогда можно их наделивать, да, значит, можно прям напрямую считать, да, как это этап зашитого определения А,
да, я считаю, что теория Поклевина, что любой А сводится к САД.
Вот, а есть, в принципе, и наоборот, бывает, что еще промежуточные варианты сюда вставляют,
это так называют задачи сервера к САД, значит, задача выполненности для будет схемы.
Вот, ну, между акцией семестра, может, поградим про какую-то схему, вот, ну, вот, значит, а дальше САД сводится к САД.
Ну, и вот три САД, это уже задача, которую удобно сводить куда-то дальше, потому что ее четкость другого, значит, такой три САД.
Эта задача выполнена с 3КНФ, да, то есть там есть переменная, есть скобки, которые дизлются в переменах этих отрисаний,
и есть комьюнция всех этих скобок.
Соответственно, можно сводить три САД, куда-то прибудут какие-то конструкции для переменных, какие-то конструкции для скобок,
и как-то это все друг другу губятся.
Вот, значит, вот такая цепочка, да, то есть дальше мы будем начинать вот с этой вот три САД.
Хорошо.
Ну, давайте, как говорили, сначала про три задачи, которые уже друг другу хорошо сводятся.
Это было бы в семинарах, а если не было, я просто чую, вы что, пройдете, да, или это вообще там собрались, да, 5 секунд?
Да, в общем, перечислю.
Задача, значит, задача акрития.
Значит, задача акрития, это вот что по, из графа и числа, значит, таких, что в графе же есть полный подкрас, полный подкрас, и скобка.
Полный подкрас, так что называется клик.
Значит, обратите внимание, что если мы спрашиваем, равняется кликовое число к, да, то есть верно, что наибольший клик имеет размер к,
то это уже не факт, что в НТ лежит, а даже, скорее всего, не лежит.
Да, потому что, чтобы доказать, что есть клик размера к, можно просто и предъявить.
Вот, а чтобы доказать, что у меня больше клика имеет размер к, нужно еще доказать, что больше клики нет.
А это же непонятно, да, это кое-какая задача, что больше клики нету, да, что такое можно предъявить, чтобы доказать, что, там, в любом случае, уже нельзя набрать.
Непонятно, что. Но это и не действие, в самом деле.
На этой задаче ставится именно так, да, значит, можно набрать хотя бы, конечно.
Так, значит, дальше еще одна задача – независимое множество.
Значит, независимое множество – не то же самое, тут есть граф и число, но и, конечно, на нашей графике же есть независимое множество.
Независимое множество. Независимое множество и ста вершин.
То есть ста вершин, которые попали в независимые лёгкие.
И третья задача в этой серии – это вершины погрузки.
Так, лёгких скала.
Или ноут камеры, когда встречается.
Значит, это множество по-настоящему.
Значит, таких, что найдется.
Значит, существует множество вершин.
С. Нет, под множество. С под множество вершин.
Значит, такое, что в нём кадр вершин и для любого вертала из графа мы получаем, что хотя бы одна вершина лежит в этом множестве.
То есть вершинная покрытия – это набор вершин, которые покрывают серию.
Значит, можно представить такую задачу практическую, что если авиакомпания, у которой есть какие-то рейсы между аэропортами,
включается граф рейсов авиакомпании, ну, будет всё еще и что-нибудь двустороннее.
Ну, это даже не важно.
Даже если они ориентированы, то мы просто снимем ориентацию.
И дальше компания хочет сделать представительство, чтобы для каждого рейса хотя бы на одном конце было бы представительство.
Вот это и будет вершинной покрытия.
Видно отличие предыдущих двух.
Значит, клипаешь, и если нужно будет клипить побольше, то вершинной покрытия будет поменьше.
Если мы берем все вершины, то это точно вершинной покрытия.
Вопрос, насколько маленькие мы можем взять.
Ну, значит, ясно, что это всё лишь ВНП, потому что можно просто предъявить.
Да, поглядя, если грав, ЗАН и ВНП, как список ЙОГО, это пример.
Далее, как матрица смежности, то ясно, что это К будет не больше, чем число вершин, чтобы была смысленная задача.
Там можно просто предъявить такие объекты, такие наборы нужного размера и действительно легко проверить, что все эти условия выполняются.
Ну, опять же, это задача оптимизации, это всё задача оптимизации.
Но в задачах оптимизации, если нас интересует точное значение оптимума, то это сложнее, чем ВНП.
Мы можем доказать, что данное значение принимается, вот это задача из ВНП.
Именно существует покрытие такого размера.
То, что минимальное покрытие имеет такой размер, это уже более сложная задача, более сложная, чем ВНП.
Но глобально, конечно, в первый дух мы максимизируем, в третьем минимизируем.
Так, хорошо, значит, эти три, все задачи друг другу эквивалентны.
Значит, клика, так, под стрелочкой я понимаю наличие свадимости в обе стороны.
Значит, клика эквивалентна независимому множеству, а она эквивалентна вершину покрытия.
Так, значит, если это не очевидно, то на семинарах будет разобрано.
Вот, значит, поэтому смотрите, что дальше получается, исходя из вот этого утверждения,
что если мы к одной из этих задач сведем что-нибудь ВНП полное, например, 3-сад,
то все остальные тоже станут ВНП полными за счет вот этих свадимостей.
Так, ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то,
так, ну, давайте я покажу, как 3-сад свести к вершинному покрытию.
Значит, 3-сад сводится к вершинному покрытию.
Так, ну, смотрите, как вообще все подобные свадимости устроены?
Значит, там есть какие-то конструкции, которые принято назвать гаджетами.
Есть специальные гаджеты для переменных, гаджеты для скобок,
ну, и какая-то связь между ними, которая отражает структуру формулы.
Ну, и вот в данном случае получается прям очень хорошо,
граф разбивается на гаджеты для переменных и гаджеты для скобок.
Так, хорошо, пусть у нас есть, что нам вообще нужно сделать?
Нам нужно phi превратить в какой-то граф и число,
значит, граф g phi и число k phi t.
Ну, такое, что phi выполнимо тогда и только тогда,
когда существует вершинное покрытие s графа g phi t,
размера k phi t.
Что у нас есть в формуле?
В формуле у нас есть переменные и скобки.
Будем считать, что у нас есть n переменных и m скобок.
Значит, каждой, сейчас я буду рассказывать, как строится вот эта пара из графа и числа.
Значит, каждой переменной я сопоставляю просто ребро, отдельно выделенное ребро.
Значит, переменная P, но вот некоторое отдельное ребро.
Ну, и мы будем считать... Так, давайте я покрупнее нарисую, чтобы...
Я хочу сами вершины пометить.
Одна вершина будет помечена P, а второй переменная, другая вероится P.
А, вот сейчас мы умерли по нему.
Нет, нет, нет. У нас переменная в одном раз вовеке.
Часть вхождения она сама, часть ввыцает сами.
Но одной выделенной переменной мы сопоставляем одно воздействие на ребро.
Подождите, подождите, подождите.
Ну, что, что у нас есть в форме?
Дальше. Значит, скобка.
Значит, скобка имеет вид дизьюнция трех литералов.
Литералы – это переменные или отрицания переменных.
Значит, скобка имеет вид дизьюнция трех литералов.
Литералы – это переменные или отрицания переменных.
Скажем, вот там L1, или L2, или L3.
Значит, тут будет треугольник.
Значит, треугольник...
Который как раз помечен вот этими вот литералами.
Да, значит, я обращаю внимание, что это я так пишу L1, L2, L3.
А на самом деле каждая лита – это либо переменная, либо отрицание переменной.
Да, то есть вообще, так говоря, метки на треугольниках и метки на ребрах
не имеют никакого значения.
Метки на треугольниках и метки на ребрах –
это метки одной природы.
И, конечно, нужно их как-то связать друг с другом еще,
чтобы отразить структуру формулы, какие перемены входят в какие скобки.
Нет, наоборот. Разные вершины могут иметь одну и ту же метку.
Подождите, еще раз. Мы по формуле строим граф.
По формуле строим граф. Я его еще не достроил, я пока начал строить.
Во-первых, для каждой переменной мы заводим отдельное ребро.
Во-вторых, для каждой скобки мы заводим отдельный треугольник.
Вот с такими метками. Соответственно, тут
каждая метка входит в граф на один больше, чем она входит в формулу.
То есть каждая метка один раз встречается на ребре
и еще один раз для каждого вхождения в нужном треугольнике.
И теперь, наконец, как мы соединяем эти две части?
Мы просто делаем так, как мы делали,
значит, мы просто соединяем
вершины из ребер и вершины из треугольников, которые имеют одинаковые метки.
Тут очень важно, что не вообще все одинаковые метки соединяем,
а только метку из ребра со всеми такими же метками в треугольниках.
Значит, каждую вершину из ребра...
Сейчас я нарисую, как это будет выглядеть на конкретном примере.
Каждая вершина из ребра соединяется
с также помеченными вершинами
из треугольников.
Так, сейчас какой-нибудь пример придумаем,
и я вам покажу, как это выглядит.
И еще, кстати, еще нужно сказать, чему равно k.
Ну, k, на самом деле, можно просто сказать,
значит, у каждого из ребров, у каждого из ребров,
ну, k, на самом деле, можно просто сказать,
значит, k будет n плюс 2m.
А почему это так, сейчас обсудим.
Так, значит, пока я стираю,
может быть, даже непонятно вообще, почему это работает,
но я думаю, должно быть понятно, почему это пальномиально.
Да, значит, там нужно как-то синтактически разобрать формулу,
ну и дальше ясно, что у графа будет примерно такой же размер, как у формулы.
То есть тут будет сколько? 3m плюс 2n вершин у графа будет,
ну и ясно, как его строить.
В общем, видно, что это несложная задача,
вычислить, что получается.
Ну а теперь давайте разберемся, почему это работает.
Ну, давайте какой-нибудь пример,
какая-нибудь формула, например,
p или не q или r,
и, скажем, не p или не r или не s,
и, скажем, q или не r или s.
Вот, например, я взял, что 4 переменных, получается, и 3 скобки.
Так, хорошо, ну давайте посмотрим, как это будет выглядеть.
Значит, p или не p.
Так, дальше, а, слушайте, давайте я вот так вот нарисую,
чтобы меньше было пересечений.
Значит, r не r, так, и тут s не s.
Так, вот это одна часть графа, как бы отдельные ребра.
Так, теперь треугольники.
Так, вот треугольник p, не q,
так, вот треугольник p, не q, r.
Так, это у меня соединяется вот так вот,
это соединяется вот так вот,
это соединяется вот так вот.
Так, значит, дальше не p, не r, не s.
Значит, это соединяется вот так вот,
это соединяется вот так вот,
это соединяется вот так вот.
Так, и последнее осталось q, не r, и s.
Так, значит, это у меня вот сюда вот,
не r вот сюда вот, и s вот сюда вот.
Так, ну вроде еще можно углядели структуру.
В общем, вот видно, что тут как бы вот такие две части.
Значит, одна часть относится к переменам, другая часть относится к скобкам.
Так, хорошо.
Значит, теперь, смотрите, нужно в две стороны доказать.
То есть очень важно, что вот здесь вот равносильность.
Нужно одновременно показать две вещи,
что если существует выполняющий набор,
то тогда есть покрытие,
и наоборот, если есть покрытие, то есть выполняющий набор.
Вот это очень важно не забывать,
когда вы сами придумываете конструкцию,
то нужно обе вещи показывать.
Так, ну в одну сторону.
Значит, в одну сторону,
конечно, это выполнимая формула, тут очень много выполняющих наборов,
но давайте какой-нибудь один из них выберем.
Например, пусть здесь выполнено p,
значит, здесь выполнено не r,
и здесь выполнено s.
Вот, а q вообще не важно, чему равно.
Ну, чему-то равно.
Ну, например, q равно 1.
Вот, тогда что мы сделаем?
Значит, в каждом ребре мы возьмем как раз ту вершину,
которая соответствует частинам литералу.
То есть в данном случае, ну, например,
п, вот это возьмем.
Так, q единиц, я сказал, q дальше r равно 0,
то есть вот это вот.
Значит, и s равно единиц, и вот это вот.
И это как раз n вершин.
Это вот эти вот n вершин.
Значит, а теперь в треугольниках.
Значит, смотрите,
у нас из каждой вершин треугольника есть ребро, выходящее в другую часть графа.
И это ребро должно быть покрыто, как вообще все ребра.
Ну, вот, например, вот в этом треугольнике,
значит, вот это вот ребро уже покрыто с той стороны.
И тогда с этой его не обязательно покрывать.
Вот, а вот эти вот не покрыты, но мы, соответственно,
возьмем вот это и вот это.
Если форма выполнима, тогда в графе есть покрытие.
Это как построить покрытие по выполняющему набору.
Вот.
Ну, соответственно, в этих треугольниках точно так же.
Здесь вот это вот, идущее сюда,
покрыто с этой стороны.
Значит, соответственно, вот эти вот два ребра мы покрываем за счет вот этих вот двух.
Вот. Ну, и конечно, у этого тут как бы целых два покрыто.
Но смотрите, в треугольнике все равно нужно хотя бы две вершины покрыть,
чтобы покрыть те ребра, которые внутри треугольника.
Их же тоже надо покрыть.
Вот. Ну, раз уж я по...
А, тут они вообще все три даже покрыты, да?
Вот, которые здесь, значит, 1-1-0-1.
Вот. 1-1-0-1.
Вот. Значит, в этом треугольнике сразу все три получились покрыты.
Но нам все равно нужно сам треугольник покрыть.
Ну, и, например, раз уж я подчеркну вот это вот,
то мы считаем, что вот это вот ребро покрыто с этой стороны.
Ну, а вот эти вот оставшиеся две вершины нужно покрыть.
Вот. Ну, вот и получается n плюс 2m.
Получается, что n вершин в этой части покрыты,
и в каждом из m треугольников две вершины покрыты в этой части.
Поэтому n плюс 2m.
Вот. И дальше действительно все ребра покрыты.
Почему? Все ребра вот эти вот отдельные покрыты,
потому что мы один конец выбрали и им покрыли.
Все ребра в треугольнике покрыты,
потому что мы в каждом треугольнике две вершины выбрали.
Вот. А все ребра между двумя частями покрыты
ровно потому, что это выполняющий набор.
Мы так выбирали, какие две покрывать,
так, чтобы третья оставалась покрыта с другой стороны.
Ну, вот. Значит, это действительно покрытие.
Вот.
Подождите. n переменных, m скобок.
А k это размер покрытия.
Вот.
Хорошо. А теперь другую сторону.
Смотрите, на самом деле покрытия обязаны выглядеть как-то вот так вот.
Почему?
Потому что среди вот этих вот ребра должны быть покрыты,
и они вообще все отдельны друг от друга.
Поэтому хотя бы одну вершину из каждого из них нужно взять.
Дальше.
Вот.
Вот.
Ну, если мы берем одну вершину из этих n ребер
и две вершины из m треугольников,
то есть тут, n вот этих ребер,
значит, m треугольников,
значит,, тут одна вершина, тут две вершины,
тут две вершины, то у нас больше ничего не остается, у нас всего n плюс 2m вершин,
и как бы что-то типа принципа Дерехле, что хотя бы одна всюду здесь, хотя бы две всюду здесь,
и значит ровно одна всюду здесь, и ровно две всюду здесь. Ну а дальше, смотрите, если у нас ровно
одна в каждом ребре, то это сдает какой-то набор. Если выделена вершина с переменной,
то значит это примерно равна единице, если выделена вершина с отрицанием переменной,
то переменная равна нулю. То есть какой-то набор у нас есть. И он обязательно должен быть
выполняющий. Почему? Потому что в каждом треугольнике будет две вершины покрытые,
а из третьей тоже идет ребро, и это ребро тоже покрыто, значит он покрыт с другой стороны.
Но тогда, если мы считаем, что метки на покрытых вершинах истинные, то это означает, что вот
это вот P будет истинно в этой скобке. Значит скобка выполнена. И так в каждом треугольнике,
то есть в каждой скобке, то и все скобки истинны. Значит формула истинна. Вот такое рассуждение.
Так, ну что, киньте вопросы. Все понятно?
Сейчас, значит смотрите, еще раз. Чтобы покрыть вот это ребро, нам нужно выбрать одну вершину.
Чтобы покрыть треугольник, нам нужно выбрать две вершины. То есть у нас больше либо равно одной
вершины, покрытой на каждом ревре, и больше либо равно двух вершин, покрытых в каждом треугольнике.
То есть всего у нас больше либо равно, чем n плюс 2m покрыто. Но у нас ровно столько покрыто. Это
даже не столько принципа Дерехлева, сколько что мы суммируем неравенство и получаем равенство,
значит они все равенство были. Ну вот, а дальше получается, что непокрытая в треугольнике должна
соответствовать истинному литералу в скобке. Потому что покрыты как раз истинные литералы в
этой части, и раз это ребро покрыто с той стороны, значит это будет точность истинной литерал в скобке.
Нет, конечно, не каждый. Но вот там вот в том определении NP-полноты,
значит в определении сводимости, которую я стер, там же не требуется, чтобы f было сюръекцией,
и даже не требуется, чтобы она была инъекцией, она просто функция какая-то. Получается, что уже
частный случай вот с такими графами и с таким числом k, он уже настолько же сложный, насколько все NP.
То есть если, ну можно сказать так, что если мы научились решать вообще вершины покрытия,
любое, то в том числе мы его научились решать для графа такого вида, а тогда мы научились
решать 3 SAT, а тогда мы научились решать все NP. Поэтому нам все нужно, чтобы все графы получались.
Это, кстати, можно как некоторую общую теорему сформулировать, что если
частный случай, ну, кстати, в данном случае даже это тюрем не подойдет, потому что,
или я не уверен, что подойдет, потому что не очень понятно, как проверять, если у вас граф изначально
задан, да, то не очень понятно, как проверять, имеет он вообще такой вид или нет. Может и можно,
но это не тривиальная задача. Вот так, но давайте я те мнения сформулирую, значит, теорема о частном случае.
Так, значит, смотрите, пусть у вас, смотрите, если А лежит в NP,
Б лежит в П, значит, А лежит в NP, Б лежит в П, и при этом А в пересечении с Б NP полное,
значит, то тогда и само А NP полное.
Да, то есть если у нас, ну, пример, да, давайте пример, как эта теория работает,
значит, можно рассмотреть просто задачу о раскраске. Раскраска это множество пар из графа G и числа
Х, так что есть раскраска в К цветов. Значит, существует правильная раскраска вершин графа в К цветов.
Значит, это вообще раскраска. Есть три раскраска, значит, три раскраска. Вот, это просто, когда у нас есть граф,
так что существует, ну, это было у нас, значит, существует раскраска в три цвета. Вот, но, конечно,
так как написано это не совсем, как в теореме написано, но можно вместо, значит, чтобы это
подходило под теорему, нам нужно вместо G написать пару из графа G и числа 3. Значит,
если тут, значит, если тут будет, значит, граф G и число 3, значит, то как в теореме.
Да, потому что, что такое B будет? B это множество пар из графов и числа, где число равно триом. Да,
это очевидно в P будет лежать, а пересечение будет как раз три раскраска. Вот так, ну,
а почему теорема-то верна? Ну, потому что, смотрите, пусть у нас там произвольное доказательство теоремы.
Да, соответственно, получается, что если мы докажем, что три раскраска NP полна,
то тогда и просто раскраска тоже NP полна. Вот так. Ну, а как доказывается теорема? Ну,
смотрите, у нас произвольный язык X сводится вот к A пересечения с B. Да, то есть получается,
что там X мало лежит в X большом, тогда и только тогда, когда F от X лежит в пересечении A и B.
Так, хорошо, тогда можно новую, значит, новую функцию написать. Так, сейчас я докажу и сделаем
перерывчик. Значит, F штрих, другая функция, F штрих от X. Значит, это будет вот что, это будет
F от X, если F от X лежит в B. И поскольку B лежит в B, то мы это можем проверить. Вот, ну а если не лежит в B,
то, если F от X не лежит в B, то он точно лежит в пересечении, и значит, X точно не лежит,
X мало точно не лежит в X большом. Значит, нам нужно, чтобы тогда F штрих от X не лежало в A. Ну,
это неважно, мы возьмем какую-нибудь константу, которая не лежит в A. Посмотрите, поскольку,
сейчас, тут на самом деле есть какой-нибудь выраженный случай, если P равно NP и A это все вместе,
то, наверное, это будет неправда. Вот, а во всех остальных случаях это будет правда. Да,
в общем, нужно взять какой-то отдельный элемент, который не лежит на какой-то A0. Значит, если F от
X не лежит в B, значит, где A0 не лежит в A. Вот, ну и тут даже неважно, откуда мы его возьмем,
потому что это просто один элемент, и его можно как бы зашить в описании программы F штрих.
Почему это работает? Ну, потому что теперь, если X лежит в X, значит, тогда получается,
что F от X лежит в пересечении A и B, и тогда получается, в частности, что F от X лежит в B,
и тогда F штрих от X равно F от X, и то есть получается, что F штрих от X лежит в A. Вот,
это одно, а если X не лежит в X, то тогда F от X не лежит в пересечении, и тогда получается одно из двух,
либо F от X не лежит в B, либо F от X лежит в B, но не лежит в A. Значит, если он не лежит в B,
то мы получаем, что F штрих от X равно A0 и не лежит в A. А нам и нужно, чтобы F штрих от X не лежало в A.
А в этом случае получается, что F штрих от X равно F от X и так тоже не лежит в A. Не лежит в A,
потому что оно в этом предположении лежит в A. Значит, равно F от X.
Не, не, не, про пересечение у нас было в предположении. Смотрите, нет, нужно нам,
что X лежит в X большом, только когда F штрих от X лежит в A. Значит, вот это нам нужно,
а вот это нам дано изначально. То есть вот это за счет полноты пересечения.
А вот если F от X лежит в B? Если, если F от X лежит в B.
Не знаем, это мы потом вот здесь рассуждаем, что это сработает.
Вот здесь вот. Тут-то мы знаем все-таки, потому что если мы пройдем назад,
то F от X лежит в пересечении, значит в A лежит. Ну, то есть тут это как-будто из двух будет следовать.
Так, ну ладно, я почти всю перемену занял,
давай сейчас сделаем перерыв на пять минут и потом продолжим.
Так, давайте продолжим. Значит, раз я уже сказал про три-раскраску, давайте для три-раскраски я расскажу,
почему она NP полная. Вот, но я расскажу не ту конструкцию, которая у меня в книжке написана,
а другую. И там будет еще одна задача по дороге. Задача по дороге будет не связана с графами,
а связана с выполнимостью. Значит, будет вот такая цепочка. Значит, три-сад сводится к задаче нае-три-сад.
Значит, где сейчас скажу, что такое нае, а это уже будет к три-кол. Значит, нае означает not all equal,
то есть не все одинаковые. Вот, и это будет вот что такое. Это множество phi, таких что phi это 3 KnF,
и существует не просто выполняющий набор, а такой набор, что в каждой скобке есть и единица, и ноль.
Значит, существует набор значений такой, что в каждой скобке
в каждой скобке есть и истинные, и ложные предикаты. Не предикаты, в смысле, а литералы.
Вот, то есть как бы просто выполнимость из восьми вариантов семь оставляет, кроме трех нулей,
а здесь остается шесть вариантов, все варианты кроме трех нулей и трех единиц. Значит, ясно,
что это в НП лежит по той же причине, если нам даны значения, мы можем вычислить значение каждой скобке,
точнее даже не значение, а посчитать число единиц в каждой скобке и увидеть что-либо единиц, либо два,
а не ноль и не три. Вот, хорошо. Значит, теперь как это делается. Значит, конструкция здесь такая,
из каждой скобки из исходной формулы мы делаем две скобки в новой формуле.
То есть пусть фи это будет, ну какая-то там конъюнция, ц1 и так далее, ц2 и так далее ценная.
И дальше каждая цит преобразуется в пару, ну какой-нибудь там дит и еит.
То есть из каждой скобки старые, получается две скобки новых. Кстати, на самом деле в такой
постановке даже не очень важно, что у нас тут стоит конъюнция, потому что у нас более сложные условия.
Ну, можно считать так.
Кстати, такое упражнение. Почему не подходят то, что на первый взгляд кажется, что мы возьмем из
каждой скобки сделан как бы ее и противоположную. То есть если у нас там было p или q или r, то мы
добавляем еще формулу не p или не q или не r. Почему вот это вот не подойдет такое упражнение подумать.
Ну хорошо, значит как это будет выглядеть. Ну смотрите, пусть вот это было, ну не знаю,
какой-нибудь там а-и-т или б-и-т или ц-и-т. Вот была такая скобка. Значит мы преобразуем ее вот в
такую вот пару. Значит смотрите, а-и-т или б-и-т или, скажем, х-и-т и не х-и-т или ц-и-т или з-т.
Где z не и-т. Значит х-и-т свое для каждой скобки, а z одно и то же для всех. Значит х-и-т свое, то есть
своя переменная для каждого и, значит а-z общее для всех. Так, ну вот утверждается, что это вся
конструкция, надо только понять, почему она работает. Н плюс одна переменная, число скобок
удваивается. Это все означает, что сводимость полинамиальная, у нас нет какого-то там огромного
роста. Так, а, кстати, тут надо скорее M написать, чтобы совпадало с предыдущим. У нас же было
N переменных до I-M скобок.
Ну, смотрите, тут на самом деле нужно некоторый перебор сделать. Небольшой. Давайте, вот я
прямо это перепишу. Значит а-и-т или б-и-т или ц-и-т. Здесь дальше а-и-т или б-и-т или х-и-т.
Значит и тут не х-и-т или ц-и-т или z. Так, хорошо, значит дальше тут будут варианты,
7 вариантов. 0-0-1, 0-1-0, 0-1-1, значит 1-0-0, 1-0-1, значит 1-1-0, 1-1-1. Значит 7 вариантов. Так,
ну тут соответственно будет 0-0, 0-1, а, давайте прям сюда поделять, значит 0-0-1, так тут 0-1-0,
значит 0-1-1, значит 1-0-0, 1-0-1, значит 1-1-0, 4 и 1-1-1. Так, ну смотрите, я утверждаю,
что можно дополнить такие значения х-и-т и z, значит что всюду будут хотя бы 1-0. Так,
ну смотрите, на самом деле вот тут где 0-1-0-1, 1-0-1-0, тут вообще совершенно неважно,
какой будет х-и-т, уже условие в левой скобке выполнено. Вот, значит можно за счет х-и-т выполнить
условие в правой скобке, то есть тут взять 1, тут 0, тут 0, тут 1, значит тут 1, тут 0, значит тут 0,
тут 1. Вот, даже неважно, какой z, в этих четырех случаях уже все выполнено. Так, вот в этих случаях
х-и-ты однозначно указывается, она должна быть не таким, как вот эти два. Соответственно тут 1,
тут 0, значит тут 0, тут 1, тут 0, тут 1. Так, и значит в правой части видно, что в шести случаях уже
выполнено условие, и только в последнем, значит только в последнем еще нужно z. И тут видно,
почему z можно одним и тем же, потому что нужно взять 0, чтобы в последней строчке было выполнено,
ну а соответственно во всех случаях она тоже 0 получается. Почему это важно? Потому что в какой-то
другой скобке она могла быть нулем, но мы ее всюду делали нулем. Значит, смотрите, это в одну сторону,
это в одну сторону, что если в исходной форме все вот эти вот содержали хотя бы одну единицу,
то в новой каждой скобке будет содержать хотя бы одну единицу, хотя бы 1,0. Так, теперь в другую
сторону. Смотрите, если это самое общее z равно нулю, то тогда понятно, что abc не мог быть нулями,
одновременно, потому что тут будет 2 нуля, тут будет 2 нуля, а эти противоположные, и хотя бы в одной
штуке будет 3 нуля. То есть, если набор, это уже в обратную сторону, если у нас есть наe набор
с z равно нулю, то тогда, значит, не может быть, что ait равно bit равно cit равно нулю. Ну и, значит,
та дезинкция была выполнима. Понятно почему, да? Потому что как раз будет по 2 нуля в каждой,
и эти противоположные, значит, где-то должно быть 3 нуля, будет противоречие. Но вопрос, а что будет,
если есть наe набор с z равно 1? Тогда это все уже не будет работать, но есть некоторый трюк. Значит,
если есть наe набор с z равно 1, то тогда возьмем как бы его полное отрицание, то есть перевернем
значение каждой переменной. Возьмем противоположное значение всех переменных. И смотрите,
что происходит. Значит, у нас все переменные перевернулись, но если в каждой скобке были
1 и 0, то после переворота тоже в каждой скобке будут 1 и 0. То есть отрицание наe набор это тоже
наe набор. Ну и тогда мы свели этот вариант к предыдущему. То есть если есть набор с z
равно 1, то его отрицание будет набором с z равно 0. Подождите, у нас, смотрите, наe набор, значит,
не все одинаковые. Значит, есть и 0, и 1. И тогда среди отрицаний тоже есть и 0, и 1. Ну вот,
значит, эта сводимость работает. Действительно, в обе стороны. Так, ну ладно, теперь вторая
сводимость, что наe3sad сводится к три-раскраске. Довольно простая конструкция. Есть конструкция
для 3sad к три-раскраске, она посложнее. Вот, а вот эта конструкция довольно простая. Значит, смотрите,
наe3sad к три-раскраске. Ну первая идея такая, что, смотрите, раскраски, они как бы не появляются
поодиночке. Что если у вас есть одна раскраска, то можно взять любую перестановку цветов и
перекрасить соответствующим образом тоже будет правильная раскраска. Поэтому для конкретной вершины
можно считать, что у задника конкретный цвет. Если там какой-то другой, то мы перекрасим так, чтобы у этой
вершины был конкретный цвет. Так, значит, тогда мы будем считать, что есть три цвета, значит,
истинный, ложный и служебный. Так, теперь, но у нас будет, дайте себе тоже, например,
какой-нибудь формулы. Ну давайте той же самой, которая у нас была, ну или, не знаю, может, не так перепишу.
Значит, в общем, точно так же с тремя скобками, с тремя переменными. Значит, там, по-моему, так было,
значит, P или не Q или R и не Q или не R или не S и, значит, не P или Q или S. Так.
