Так, ну что ж… Так, ну что, давайте будем начинать,
соответственно.
Да, что-то… Не, что-то всё равно мало как-то.
Да, уже больше, чем было в начале, конечно, но…
Ладно.
Соответственно.
Значит, ну, чем мы сегодня будем заниматься?
Ну, возможно, заниматься будем много чем.
Вот.
Но, соответственно, как-то полное ощущение, что сегодня
или, по крайней мере, максимум в следующий раз это может
всё сойтись в какое-то единое целое.
Вот, потому что… Называется нацеливаться, или мы будем
на страшную, в скобках нет, такую структуру данных
как линкат-3.
Слышали о такой?
Давайте попробуем.
Отпадите руки.
Кто слышал о такой?
Ага, кто знает, что это такое?
О, да, логично.
Так, кто писал, говорите?
А, спасибо.
Вот.
Ну, понятно.
Ну, понятно.
Да-да-да.
Да-да-да.
Я не сам, меня заставили.
Не, ну, Хёда, ты не сам, меня заставили.
Давай по тексту.
Кира, я тебя поймаю.
Вот.
О, кто-то смотрел, наверное, да?
Так.
Вот.
Но как бы до этого идти.
Тут уже, конечно, другие писенки, конечно, в голове
появляются.
Там всякие.
Называется.
Но давайте всех этих героев драмы, собственно, по очереди
рассматривать.
Ну, конечно, первое основное.
Это у нас, конечно, будет сплей дерева.
Вот.
Как бы сбалансированное двоичное дерево поиска.
Таких у нас, естественно, не было.
Поэтому вот вам уже.
Там какое у нас?
Четвёртое или пятое?
Я уже забыл.
Да.
Дай-дай.
Вот.
Ну да, дикарь тягих у нас не было.
Вот.
Вот, видимо, возможно, придётся обсудить, но неважно.
Вот.
Но сплей дерева будет оказываться там.
Вот, казалось бы, зачем нам нужно сплей дерева?
Какими убедительными свойствами оно обладает?
Вот.
То есть, действительно, оно обладает убедительным
свойством, что все операции делаются за логарифом.
Вызывается.
Были ли у нас вообще когда-нибудь такие деревья,
чтобы все операции были за логарифом?
Есть логариф.
Да.
Продоксально, да, но аж целых три дерева.
Все как-то три дерева как-то это ухитрили сделать.
Но сплей дерева круче.
Оно умеет делать это за амортизированное логарифом.
А круче где?
Вот.
И вот, действительно, казалось бы вопрос.
Так, но-то.
Да, а в чем амортизированность круче обычности?
Так, ну ведь сплей дерева оно же...
Там знаете какой шикарный вариант у дерева?
Вот.
Знаете, какие двоичные дерева могут быть сплей деревьями?
Любые.
Да.
Ведь, действительно, что такое сплей дерева?
Значит, сбалансированное двоичное дерево поиска,
в котором, на самом деле, в котором никаких внутренних
инвариантов нет.
От слова вообще.
То есть, абсолютно, теоретически, абсолютно любое двоичное
дерево, там двоичное дерево поиска может быть сплей
деревом.
Вот.
Фишка будет заключаться, конечно, в другом.
Ну вот.
То есть, фишка сплей дерева будет заключаться в правильных
операциях.
Точнее, снова в правильных поворотах.
Вот.
Спрашивайте.
Зачем же, товарищи слейтериториян, его вообще, действительно,
придумали?
Да.
Это не по причине того, что это там первое историческое
дерево.
То есть, сначала придумали типа там амортизированное.
Потом уже думали, а можно ли сделать честное, придумали
овель?
Нет, конечно.
То есть, овель, там помню, год 62, а сплей, это, там,
помню, 80-е.
И то, дай бог.
Вот.
Ну вот.
Ну да, 80-е.
Вот.
Ну вот.
Ну зачем оно надо?
Но дело в том, что оказывается, что у сплей дерева несколько
на самом деле, как называется, байтоматизированных оценок.
Вот.
То есть, например, если открыть оригинальную статью,
слейтериторияна, собственно, и про сплей дерева, то на
самом деле, там, можно подробно причитать, что на самом деле,
как бы да, сложилась ситуация, что да, придумывается огромное
количество деревьев поиска.
Не всегда сбалансированных, но иногда там по своей нужды.
То есть, там, на самом деле, то, что мы, то есть, то, что
мы там перечисляли, там, раньше, там, бейт дерева,
там, вот это, там, овель дерева и так далее, это так, это,
ну вот.
То есть, это еще только самые видные представители.
На самом деле, там деревьев гораздо больше, они там
могут быть не всегда идеальные, но они там просто работают
какие-то под свои нужды, и у них там время работы
оценивается еще как-то дополнительно, из-под каких-то параметров.
Вот.
Ну вот.
Критизна сплей дерева заключается в том, что называется
многие из этих деревьев, там, сплей дерева начинает
мажорировать.
Ну, в том плане, что, там, говорит, что вот у нас
есть фингер дерева, там какой-то фингер дерева, допустим.
Да, так и называется, фингер 3.
Вот.
И у него там есть, там, какое-то, там, какое-то странное
время работы, там, исчисляемое какими-то, там, параметрами.
А теперь, заметим, что если вы вместо фингер 3 напишете
сплей дерева, то асимптотика будет абсолютно такой же.
Или даже лучше.
По крайней мере, также оценить можем.
Вот.
Ну, помимо фингер 3 есть еще, там, какое-то, там, называется
васипети дерево, там, какое-то.
Нет, сейчас я название придумал, естественно, да.
Вот.
Там, какое-то васипети дерево.
Оно там, оно работает за асимптотику такую-такую-такую-то.
Но, оказывается, сплей дерево тоже работает за такую
асимптотику.
Вот.
Ну и так перечисляются где-то там дерево 4, как минимум
точно.
Вот.
Можем там, может там в какой-то момент даже попробовать
открыть статью, наверное.
Вот.
У нас, раз презентация нас в какой-то момент сыграет,
даже посмотрим, что ж там за такое счастье.
И, действительно, на самом деле у сплей, ну, то есть,
у сплей дерева, действительно, то есть, мы, конечно, будем
доказывать, что мы будем доказывать, а мы будем доказывать
весьма неожиданную, вот, штуку.
Оно, кстати, поднимите руки, кто когда-нибудь сталкивался
со сплей деревом раньше.
Так.
Кто когда-нибудь писал сплей дерево.
Ага.
Логично.
Примерно те же.
Вот.
Так.
А кто доказывал асимптотику?
Чего?
А?
А, окей.
Ну вот.
Но тут возникает вопрос, какое доказательство было.
Потому что тут я вас сразу предупрежу, значит, будет
подляночка.
В презентации, там в презентации у этого сплей дерева может
быть даже доказательство.
Ну вот.
Ну оно будет не совсем правильно.
Так, ладно, нет, это я сейчас неправильно выяснил.
Доказательство будет правильным, с его помощью действительно
можно показать, что учетная стоимость всех операций
сплей дерева логарифом.
Оно не подойдет до линката?
Да.
Совершенно верно.
То есть мы используем чуть более сложные доказательства,
но зато после этого оно будет линкат.
Но мы и теорему сформулируем сильно мощнее.
Потому что в простом виде теорема говорит, да, все
операции работам, если правильно ввести потенциал,
то учетная стоимость будет от логарифма.
Да, доказательства.
Но на самом деле можно это сделать сильно хитрее.
Вот, а именно, допустим, у нас есть двоичное дерево
поиска какой-нибудь.
Так вот, идея такая, давайте в каждую вершину поместим
мистическое число w.
Там wut, wvt, там… Ну, скорее веса.
Это обычно называется веса, wa, wb и так далее.
Причем известно, что все w что-то там, все они строго
больше нуля.
Вот, у каждого элемента будет введен, соответственно,
какой-то вес.
Так вот, мы докажем, но также мы введем, что w большое
это будет сумма всех весов дерева.
Нет, это не потенциал, не путать.
Так вот, мы докажем, что учетная стоимость всех
у нас есть, равна o от логарифма w поделить на… Вот, w это.
Чего?
Значит, где и – это вершина, с которой мы работали.
В некотором смысле.
Да.
Вот.
Ну, потому что у нас все… Значит, тут оговорка такая,
что все операции обычно там устроены так, что мы там
спускаемся к какой-то вершине и параллельно что-то делаем.
Вот.
Ну вот, когда мы будем спускать… Если операция потребует
спуститься к вершине i, то оказывается, что мы сделаем
так, что учетная стоимость этой операции будет логарифм,
то есть o от логарифма отношения суммы всех весов к весу
конкретно этой вершины.
Вот.
Ну, на самом деле, да, то есть отсюда, скажем, можно
сделать вывод, что… Как бы это формулировать?
Заметим, что каждая операция… То есть, там, допустим,
там каждая операция с каждой вершиной делась какое-то
количество раз.
Вот, допустим, для простоты, что у нас эта операция была
операцией с searching, допустим, да, ну, чтобы просто было
проще вообразить.
И мы знаем, что там каждая операция, допустим, каждой
вершине мы пытались обратиться к какое-то количество раз.
Да?
Вот.
Получается, что если мы, допустим, п1 раз вызывали первую
вершину, п2 второй, п3 третью, то суммарное время работы
получается что-то типа п1 логарифом в поделить
на w1, плюс п2 логарифом в поделить на w2, плюс и так
далее плюс пn в логарифом, там соответственно w поделить
на wn, но зе. Вот, ну как тогда, где-то там что-то
какое-то слово энтропия как-то возникает с собой-собой
где-то, да? Не, ну что? Не, ну по-моему, что-то похожее,
нет? Не, ну не всегда, конечно, да, ну вот. Ну тут вот такое,
да, но фишка, знаете, в чем заключается? Фишка заключается
в том, что вы каждому элементу на самом деле вот эти w-то
можете самостоятельно ввести. Вот, то есть на самом деле
если я скажу, что w и t пусть будет равно тупо p и t, да,
и при этом, причем заявим, что сумма всех p и t-х равно
1, обратите внимание, да, то есть я как бы могу там
сантиметры спокойно переводить килограммы и наоборот, понимаете,
да? Вот, и соответственно, поэтому тут получается уже,
то есть тогда получится асимптотика, то есть заметим,
что я просто под w могу подставлять просто абсолютно
все что угодно и асимптотика будет реально такая, обратите
внимание, поэтому логариф, ну вот тут получится логариф
лог, там 1 делить на p1 плюс p2, там логарифом 1 делить
на p2, там плюс и так далее, плюс, вот. Так что вот тут
получается такая красота. Так вот это уже по-моему
и два лени словарное определение слова энтропия по-моему
уже. Вот. Ну, то есть возможно, да, еще одна причина, по
которой действительно оказывается, что сплэй-дерево интересно.
Вот. Так что вот такие вот тут у нас неожиданности
возникают. Ну вот. И так. Значит, ну давайте поймем,
что же это такое за мистическое сплэй-дерево, которое вот
без всяких инвариантов поддерживает вот такую асимптотику. Вот.
Ну, идея очень простая. Значит, идея очень простая.
Для того, чтобы реализовать соответственно такую штуку,
нам потребуется мистическая операция сплэй. Сплэй от В.
Я сказал от В, а не от W. Вот. Эта операция будет делать маленькую простую вещь.
Она будет брать вершину В. Там, допустим, где-то тут вот пум-пум-пум. Вершина В. И будет делать
серию поворотов таким образом, что В окажется корким. То есть еще одно такое интересное
свойство. Вот как бы в компьютере, как знаете, есть такое понятие кэш. Вот. Ну не будет кэш,
соответственно, да? То есть что такое кэш? Это мы говорим, что если мы использовали какую-то
область памяти, то мы ее, по крайней мере, некоторое время храним где-то близко от себя.
И тогда получится, если нам потребуется эта область памяти еще раз, то мы там глубоко в память
лезть не будем, а вместо этого прочитаем ее вот быстро. Она вот у нас типа рядом лежит. Вот,
понимаете такое, да? Вот. Вот. То есть там коррект. То есть, естественно, в роли этого стола,
на которой мы положим, будет там какая-то более маленькая область там, но пока к этой маленькой
области будет обеспечено сильно более быстрый доступ, соответственно. Но там бывают разноуровни,
то есть там кэши бывают там просто там, бывают там трехуровневые, четырехуровневые, там как угодно.
Вот. Ну это вы там уже, собственно, там предметы операционных, там всяких там архитектуры
компьютера, операционных систем, это у вас еще, вам еще предстоит такое? Или у вас это уже есть?
Ну предстоит. Ну предстоит, конечно, да. Вот. Поэтому не будем сейчас копать. Ну вот. Но отмечу,
только что вот у сплея дерева такое же свойство будет, да? То есть если мы тыкали в вершину,
то в следующий раз мы эту вершину найдем за 1, потому что она будет тупо в корне. Вот. Вот. Но идея будет
заключаться в том, что мы будем фактически все операции делать через сплей. Вот. То есть в некотором
плане, при этом, заметьте, мы просто попробуем доказать, что сплей работает за, ну там учетная
стоимость работает за вот этот вот логарифом. Посмотрим чего, да. И окажется, что просто,
ну окажется, что все остальные операции будут работать буквально за о, за тета от сплея. Ну или
там тета от сплея плюс один. Вот. Ну практически. Вот давайте это поймем. Вот предположим,
что у нас есть операция сплей, вот допустим, да. Которая магическим образом, ну вот. Которой
реальное время работы. То есть реальное время работы. Оно будет, конечно же, о от там, ну допустим,
тета от глубины вершины в текущей плюс один. Ну глубины имеется в виду глубины перед сплеем, да.
Вот. И, допустим, вот у нас реальное время будет такое, а учетное время будет немножко другим.
А именно оно будет это от вот этого логарифма w делить на w и т. Ладно, я неправ. Тут тоже плюс
один на самом деле. Да, это важная оговорка, потому что вот этот логариф может быть сколь угодно меньше
единицы. Сколь угодно меньше единицы, соответственно. Вот. Поэтому тут вот оговорка на плюс один все-таки
важна. Она нам даже некоторую жизнь будет портить, но что делать? Вот. Значит, это реальное время,
это учетное время. Предположим, что у нас есть вот такой мистический сплей. Ну, заметим,
что тогда я утверждаю, что за такое же учетное время можно реализовать как минимум сёрч.
Ну, допустим, нам пришел какой-то ключик. Ладно, Ки допустим и пришел. И мы его ищем в дереве.
Напоминаю, это двоичное дерево поиска. Тогда идея простая. Мы его честно идем-идем-идем-идем-идем
находим и потом от найденной вершины вызываем сплей. Пологично, да? Получилось время работы
прям тета от сплея. Вот. Ну или если мы там шли-шли-шли-шли-шли и вылетели в аут, то от последней
вершины тогда все равно вызываем сплей, ничего страшного. Так. Но давайте думать, что еще можно
сделать на халяву с помощью сплея. Все? Ничего себе. Нет, ну все, конечно, вот. Вот что такое все. Ну,
совсем, нет, совсем на халяву, к сожалению, не получится. Ну, потому что, допустим, какую-нибудь
операцию максимум, вот найти максимум в дереве, это мы за сплей можем сделать. Как? Ну, то есть,
тупо идем вправо-вправо-вправо-вправо, а потом от самой правой вершины вызываем сплей, да? Ну,
автоматически там понятно минимум, естественно. Но как сделать, например... Так. Какое? Ну,
вот эрейс. Как, например? Ну, корень, а потом как-то полную схитрю. А, то есть еще и мерч надо сразу, да?
Так, хорошо, как сделать мерч? Ну, спуститься там в одного, в правую вершинку засплейте, повесить.
Да, допустим, в самую правую вершинку левого спуститься, сплей от нее и повесить в ней правую.
Отлично, только возникает вопрос. А вот это вот повесить, оно адекватное учетное время имеет?
Это реальное время один, я согласен. А учетное? Вот. Да, вот, видите, маленькая проблема. Просто так
на халяву не получится, потому что для исследования нам все-таки придется исследовать потенциал какой-то.
Ну, раз есть учетное время, значит есть потенциал. Будем пользоваться методом потенциалов, да. То есть,
по-моему, редкие случаи, когда монетки вообще не помогут от слова вообще. Ну, потому что нам
придется пользоваться вещественным потенциалом. Нет, ну, то есть вы можете себе там говорить,
что там монетки типа, давайте положим туда, там, я не знаю, две монетки 75 центов, там, я не знаю,
что-то в этом роде. Нет, ну там, как это называется, вы когда-нибудь покупали по цене корень из двух
долларов. Ну вот, значит, смотрите, какой потенциал ведем. Так, ну, во-первых, как мы уже сказали,
у каждой вершины есть, соответственно, ее вес, который больше нуля, да. Значит, смотрите,
мы, я теперь веду понятие такое, я веду понятие СВ. Значит, СВ это, соответственно, такой красивый
двухместный вагон, в котором висят зеркала и, соответственно, находится по повышенный класс
обслуживания. Вот, но обычно там, но обычно там все-таки два пассажировку поживут. Вот, но в нашем СВ будет
лежать одна сумма по всем потомкам векшины В, включая ее саму. Вот, мы это вот так ведем.
Значит, вот, ну и, наконец, патент, мистический потенциал. Сумма логарифмов двоичных СВ. Что,
какой интергал? Да. Вот, да, такая красота у нас получится. Так, ну, чем потенциал приятен? Ну,
вот, ну да, конечно, конечно, в простой версии доказательства мы бы сказали, что, то есть,
в простой версии доказательства все веса были бы один. То есть, по сути, СВ это такое СЗ,
на самом деле, от В, а потенциал суммы логарифмов размеров получился бы, что он порядка Н логена.
Вот, соответственно, но у нас вот все будет хитрее. Так. Чего-чего?
Да, а ведь действительно проблема, да. Да, к сожалению, действительно. Да,
возникает такая, действительно, мелкая проблема, что, на самом деле, такой потенциал может быть и
меньше единицы. Ну, если бы все веса были единичными, например, то было бы нормально. Так.
Так, что ждет? Ну, пока проблема в том, что в текущем виде потенциал у нас, соответственно,
называется бывает не очень. Так, ну, хорошо. Так, ну, хорошо. Ладно, давайте, как-то можно
выкручиваться тогда в этой ситуации. Да, нет? Так, нет, ну, как сказать, совсем вес,
это, конечно, не очень хорошо. Ну, можно там, конечно, ввести. Что тут можно ввести?
У нас, видимо, в легкой версии сдачи вылезти был нулевой вклад. Да, ну, это нормально.
Нет, ну, как сказать, нет, ну, можно в этом смысле по аналогии, конечно, ввести,
СВ поделить на W. Нет, ну, мне бы, конечно, да, но я не знаю, мне бы, конечно, не хотелось так делать.
Ладно, поэтому мы пойдем по более простому пути и скажем все веса от единицы.
Проблема, да, потенциал меньше нуля. Вот в этом проблему.
Ладно, значит, смотрите, давайте, пусть веса у нас будет на всякий случай больше,
или, правда, единица. Так, ну, давайте тестить, что? Нет, давайте мы это потестим. Вот, давайте
посмотрим, как нам сделать мерч, например.
Нет, ну, и нет, это просто оказывается, что можно показать, что там вот учеты, там все эти времена, они вот такие, вот такие, вот такие, ля-ля-ля-ля-ля-ля-ля.
Так, ну, давайте думать, значит, за какое время, значит, да, сетч мы можем теперь, получается, реализовать тоже за, там, вот эти времена,
равна, как и максимум минимум. А теперь внимание, вопрос. А теперь давайте посмотрим, вот давайте начнем с мержа.
Спрашивается, как с помощью сплей деревьев сделать мерч?
Так, ну, давайте сейчас по порядочку, давайте, хорошо?
Так, ну, давайте по порядочку, по порядочку, по порядочку, давайте это я убираю. Значит, смотрите, то есть, действительно, идея заключается в том, что, допустим, нам надо слить два дерева, вот, да, но, правда, нет, тут, на самом деле, вопрос, который мы, кстати, в прошлый раз не обсуждали, а как сливать, вообще, деревья по явному ключу, вообще?
Мы же говорили, что у нас сплит и мерч есть только в деревьях по неявному ключу.
Да, но, на самом деле, конечно, никаких проблем слияния деревьев по явному ключу вполне себе существует, но, правда, с важной оговоркой.
Оговорка будет заключаться в том, что все ключи слева, в левом дереве, должны быть меньше всех ключей вправо, вот. То есть, прям вот, любой ключ здесь меньше, чем любой ключ здесь.
И тогда, в принципе, абсолютно те же слияния, собственно, будут работать. Значит, к чему нас это приводит?
Ну, идея, возникает такая, значит, так как у нас в сплит-земле нет никаких вариантов, в том числе, на глубину, а есть операция сплей, то заметим, что из правого дерева можно с помощью операции сплей сделать очень простое дерево, у корня которого нет у правого сына.
А слева висит все. Это, конечно, взрывает мозг, то есть, казалось бы, там сбаланс, мы говорили о сбалансированности, а потом просто корню сообщаем, так, дорогой, значит, возьми все, как-то, значит, смотри, возьми всех своих потомков левую руку, все.
Так и сиди.
Ну да, но на самом деле нет, это неправда, потому что мы ему не просто так повесили все в левую руку, потому что теперь мы говорим, а в правую руку мы теперь тебе повесим вот это вот замечательное дерево.
Вот такая вот простая вещь.
Какой сёрч? Сёрч кого?
Ну не сёрч, а скорее максимум, потому что, как бы, если мы искали не максимум, то как бы с левой справа что-то висеть обязательно будет.
Вот если мы ищем максимум, то тогда вот такая ситуация.
То есть, получается, мы работаем за сплей от этого максимума плюс от единицы.
Но, внимание, вопрос.
За какую, спрашивается АСИП точку, учетную это работает?
Если мы будем большие дерево выбирать и к нему меньше подвешивать, тогда понятно, что там у корня лог не больше чем единицы.
Но, кажется, мы не храним информацию о том, какое дерево больше.
Ну, во-первых, не факт.
Если вы просто подвешиваете больше дерева к меньшему, то у вас вполне может образоваться вот такого рода бамбуча.
Ну и что? Я на каждом шаге тут куда-то одну вершинку подвешиваю.
В смысле? Ну, это же мы сделали, это же мы кучу операции сделали.
Нет, ну, приятель, допустим, у вас такое дерево, и вы решили примержить к нему одну вершину.
Внимание, вопрос.
Что будет?
Мы найдем вот этот максимум, вот он.
За сплеем его.
Что у нас там получится?
Допустим, я вам открою страшную тайну.
Вот что-то такое получится.
И мы повесим эту вершину сюда.
Поздравляю.
Ну, операция работает завод единицы, но нам и по барабану.
Да, действительно.
Операция завод единицы.
Обратите внимание, что дерево может быть вообще не сбалансировано.
Это нормально.
Перед этим было уже плохим.
Нет, ну, если вы с нуля это все будете делать, то у вас все это и будет возникать.
Но там без вот этих промежутков, там просто вот такая будет бамбуция.
Бамбуция с сучком.
Я просто не совсем понимаю, зачем нам как-то вообще-то думывается о структуре дерева,
если мы можем просто оценивать потенциалы?
Нет, нет, просто нет.
Я как бы это исходя из того, что кто-то там говорил, что если подвешивать меньше к большему,
то там что-то автоматически что-то будет.
Нет, автоматически не будет.
То есть там просто автоматически не будет, дерево может оказаться бамбучей.
Ну а давайте смотреть.
Допустим, у нас у этого дерева был максимум с весом W.
Допустим, было тут суммарный вес W1, а тут суммарный вес W2.
Тогда, значит, смотрите, сплей у нас сработал за время θ, значит 1 плюс логарифом W1 поделить на Wt.
Логично, да?
А теперь внимание и вопрос.
За какую асимптотику сработало собственно подвешивание?
Вот это вот.
Вот за сколько оно сработало, как вы думаете?
У нас сложились, собственно, вот эти потенциалы, они в целом просто сложились,
за исключением того, что S в корне поменялось.
Обратите внимание, в потенциале, заметим, поменялся только потенциал вот этой вершины.
Другое не поменялось.
И получается, то есть реальное время от единицы стало в этой вершине сколько?
Логарифом W1 плюс W2 минус логарифом W1 получается.
Или что то же самое, это 1 плюс двоичный логарифом W1 плюс W2 поделить на W1.
Как мы можем перерывать W1, если у нас изменилась структура дерева, когда мы сделали сплей?
Когда изменилась структура дерева, мы это учитываем в оценке в учетном районе сплея.
Да, то есть учетное время работы оно не такое, оно такое плюс такое.
W1, как я понимаю, это S.
Это суммарный вес вот этого дерева левого, да?
То есть Sv от корня.
И тогда получается в итоге merge будет работать за θ от единицы, 1 плюс 1 равно 1.
И логарифом двоичной суммы весов 2 поделить на Wmax1.
В общем случае можно просто сказать, что это 1 плюс логарифум суммы их весов.
И в общем-то на этом не заморачиваться.
Например, если все веса единичные, то вот вам логан вылез.
Но правда то, что делим на логариф Wmax, это на самом деле может сослужить добрую службу.
Собственно забегая вперед в линкате и собственно сослужит нам добрую службу.
Так, ну теперь давайте что-нибудь попроще, split.
Вот, ну по сути да.
То есть как сделать split, например, так, чтобы там слева оказались все меньше либо равны
какого-то элемента ki, да?
И справа больше.
Ну идея простая, надо этот элемент ki найти и торжественно отправить в корень.
Логично, да?
А после этого просто правое дерево торжественно отпилить.
Нет, мы ж не erase делаем, мы split делаем.
Нет, erase, да, кстати тоже можно так делать.
Давайте как удалить элемент?
Значит это вывесить его в корень.
Называется, да, он такой уже становится довольный, расслабленный и тут мы его и соответственно.
Как говорится, да, но на мне же все висит, ну ничего, а у нас есть слияние, ничего страшного.
Да, такая вот действительно красота.
Ну а со split все проще, слава богу split никого не удаляет, мы просто распиливаем детей.
Мы говорим, что похроничный элемент отправляется в корень и правого ребенка мы его отпиливаем.
Вот, но заметим, что отпили, что приятно в этом потенциале, что отпиливание по дереву только уменьшает потенциал.
Логично, да?
То есть как это называется? Отпили у себя правого ребенка и получи дополнительно 100.
Что-то я себе плохо формулирую.
Ну вот и это называется, да, хочешь заработать дополнительные 100.
Просто отпили, да, просто вылези в корень и отпили себе ребенка.
Нормально.
Вот, да, это тоже получается работает за 1 плюс логарифом двоичный.
Значит W большое, поделить на W вот этого вот.
Ну я вот так неаккуратно напишу немножко, но W ключика.
Ой, что-то жужжит.
Так, сейчас спрошу прощения.
Так, давайте я не сюда.
Ай-дё.
Стоять, всё.
Ладно, так.
Ладно, разберемся.
Вот.
Значит вот сплит у нас будет работать, ну допустим вот за такую симпточку,
ещё там за какой-то минус, но это уже там непонятно какой конкретно.
Вот, потому что непонятно уже сколько мы там справа отпилим.
Вот.
Ну а теперь заметим, как теперь делать вставку.
Вот теперь.
Ну да, можно действительно сделать это за какие-нибудь аккуратный мёрзший сплит.
Вот.
Или там периодически можно...
Что ещё можно сделать?
Правда, не знаю, инстракт нельзя сделать.
Спуститься и за сплит добавленную вершину.
Ну как вам сказать.
В тот момент, когда вы подвесите лист, потенциал поменяется непонятно как.
Поэтому тут лучше.
Поэтому поаккуратнее.
Поэтому просто так на халитам сделать как обычно нельзя.
Но можно действительно...
То есть можно действительно сделать сплит и потом соответственно два мержа.
Вот.
Чего?
Ну вот.
Значит, можно действительно сделать сплит за условие лог2 w поделить на w какого-то элемента.
Но, правда, и после этого действительно сделать соответственно два мержа.
Вот.
Ну и суммарно действительно всё слопается.
Получится хорошо.
Вот.
Соответственно, что-то у нас ещё получается.
Так, так, так.
Сплит понятно.
Хотя с другой стороны, а можно ещё повеселее.
Хочется утверждать, что сплит можно делать проще.
То есть вставку можно делать проще.
Я утверждаю, что можно делать не за сплит и два мержа, а за сплит и всё.
Ну такой естественный вариант.
А давайте по сплите вставляем элемент ki.
Так, ну давайте по сплите дерева на меньше ki и больше ki.
А после этого тупо повесим эти деревья к ключику.
Ну то есть скажем, что он теперь новый корень.
Ну-ка вот как вы думаете, а такая вставка за сколько работать будет?
Потенциал у нас.
А там кажется вот с этим делением проблем мы его никак не получим.
Нет, так.
Нет, почему?
Нет, ну почему же не получим?
Мы, например, будем тупо искать там.
А, или действительно не получим.
Откуда-то там у нас достался минус.
Ну просто когда мы повесим два дерева, у нас очень странно меняется потенциал вот этой вершинки.
Так, нет, а какая разница?
Нет, давайте вот сейчас решим, похоже, значит тоже нам она пригодится.
Вот как найти в этом дереве лавербаунд?
Ну так лавербаунд-то понятно.
Мы же там просто спускаемся в любом случае до какого-то...
Ну не факт.
То есть да, в какой-то момент мы до этого лавербаунда дойдём.
Допустим, да.
Вот допустим это лавербаунд.
Для того, чтобы убедиться, что это лавербаунд, нам придётся пойти в левое под дерево, а потом идти, значит, там долго вправо-вправо-вправо до крестика.
Для того, чтобы убедиться, что это реально лавербаунд.
Окей, мы засплеимся просто от последней вершины, где мы были.
Ну да.
Но правда для того...
Так что да, лавербаунд.
Да, правда единственная проблема, что лавербаунд, конечно, не будет корнем.
Да, если очень хочется, конечно, лавербаунд можно запомнить и после сплея от этой вершины сделать сплей, собственно, от лавербаунда.
Если очень прям хочется.
В общем-то никаких проблем не будет.
А нам прям, в принципе, именно хочется, чтобы он стал корнем?
Или всё-таки хочется поддержать и симптонику, скажем так?
Ну...
Нет, ну нам пока хочется поддержать и симптонику.
Ну тут как всегда...
Ну тут это и цикла да, смотря для чего.
Да, если у нас есть...
Просто была задача найти лавербаун туда.
Мы его нашли.
Ну там корнем оказался кто-то ещё.
Ну и не важно.
Чешем мы.
Ну вот.
Но есть просто оговор, что в сплее деревья не обязательно то, что вы ищете, обязательно
станет корнем.
Так.
Ну вот.
Ну а теперь был вопрос, как посплитить по конкретному элементу.
Вот как посплитить.
Сейчас, ну...
А чем проблема сделать по нему сплей и потом...
Ну сплей и слева то, что нужно.
Ну вот.
Но проблема будет только от Даши.
А симптоника будет, к сожалению, там, если вы делаете там сплит по какому-то
там элементу В, то получится 1 плюс, значит, логарифон двоичный,
там, соответственно, W делить на W какое-то, и только потом
И только потом ещё придётся добавить двоичный логарифом W и делить его на, соответственно,
ваш этот лавербаунд.
Вот так вот.
Где мы тут учитываем этот спуск до максимума въёма по деревью лавербаунд?
Вот здесь.
Когда мы искали лавербаунд, мы дошли до этой вершины.
Вот недореального лавербаунда до этой вершины.
Мы вынуждены были от неё сделать сплей.
Он сработал вот с такой симпточкой.
Вот.
А если мы хотим реально сделать сплит прям по этому лавербаунду, допустим, да,
то нам придётся тогда от него ещё вызвать сплей, чтобы отправить его в корень.
А вот симптоника сплея, мы её просто, мы решили, что она такое говорит.
Чего она?
Мы решили, что она такое говорит, мы ничего не слышали.
Нет, мы пока просто сказали, что у нас есть магическая функция
сплей, у которой вот учётное время работы вот такое.
А мы считаем, что спуск до вершины работает за её сплей, да?
Сейчас мы считаем, что, ну мы считаем, да, что если у нас как бы
операция работала за тета спуска от корня до какой-то вершины,
то как бы да, то сплей будет, у сплея реальное время работает,
да, глубина этой вершины, да.
Потому что сплей как бы спустится и подняет.
Да, потому что сплей будет, как раз, заниматься тем,
что возьмёт эту вершину и будет от её глубины поднимать её в корень
путём каких-то поворотов.
Ну там, конечно, хитроумные повороты такие, чтобы потенциал сходился.
Вот.
Но здесь заметим, да, что если прям вот действительно копать в анализ,
то получается, конечно, вот там операции такие вот,
надо какие-то точные писать.
То есть обычно, если вы просто работаете с сплей деревом,
то самое тупое, что можно оценивать,
это, конечно, то, что, как говорится,
учётное время это просто логарифм веса, соответственно.
Вот, понимаете, да?
Ну там, может, логарифм веса,
но там, возможно, есть ещё какие-то там,
потому что, видите, это там точно оговорки,
что когда вы делаете сплит, вы его делаете за сколько-то нельзя.
Но, правда, в тупом виде это по-любому работало,
по принципу, что давайте все веса сделаем единичными,
тогда у вас всё-то будет с залогом работать.
Вот, понимаете, да?
Вот.
Соответственно.
Вот, то есть, конечно, тут вот
приходится тут вот подописывать,
да, видите, то есть по факту, да,
придётся тут искать условно,
log2 w на lever bound.
Bound.
Вот.
Хотя, ну вот,
хотя самое, ну вот,
хотя можно делать на lever bound,
хотя самое смешное, что на самом деле
если правильно уточнить, то можно эти два логарифма не писать.
На самом деле вот эту часть можно
вообще-то убить.
Знаете почему?
Потому что кто вот этот элемент?
Чего?
Нет, он не просто потомок.
Если вот lever bound это кто?
Это минимальный элемент,
который больше либо равен нас, правда?
Следовательно, вот этот элемент
это максимальный элемент, который меньше нас.
Понимаете, да?
То есть получается, когда вы
торжественно отправили его,
допустим, в корень,
то получается, что вы сделали split,
только там слева все меньше,
а справа все там больше либо равны.
Но правда, тут начнётся там маленькая
оговорка на тему того,
а что делать, если мы нашли lever bound
и слева пусто?
Но с другой стороны, тогда это уже будет
вопрос отпиливать от этого дерева
левое ребёнка или правое.
Понимаете, да?
Ну, с точки зрения симптотики,
логен, конечно, абсолютно всё равно,
то есть это всё, на самом деле,
называется глубоко копание,
непонятно в чём, на самом деле, но
ну вот,
вот такой момент, такие моменты
возникают.
Вот, ну а что делать?
С этим insert, который...
Да, да,
с чего мы начали, да, мы вернули, да,
мы начали с того, что мы предлагали делать
insert, который работает за split и всё.
Вот, но я утверждаю,
что да, ну тогда получается,
если мы научились делать split за 1
плюс там logarithm w поделить на wt,
какой-то вершины, да?
Там какой-то
1.
То теперь давайте думать.
Жило было у нас два дерева
с весами w1 и w2, да?
Вправивается.
Как поменяется
мир, если мы заведём
новую вершину с весом
wv,
объявим её корнем и повесим к ней
вот это вот, повесим вот это счастье.
У нас прибавится
вот этот logarithm.
Ну да, по большому счёту да.
То есть теперь получается 1 плюс там
logarithm двоичный, получается
там бывшее w, да?
Плюс теперь, ну получается
ну там ещё плюс один
на самом деле, да, плюс один,
но теперь у нас появляется ещё logarithm двоичный
ну вот этого всего.
Да?
Ну вот
Так, ну чего это получается?
logarithm двоичный
w бывшее
плюс wv.
Да, заметим, что на этот раз
мы его ни на кого не делим.
Видите, мы просто добавляем.
Что?
Это вот, ну это когда мы
делали сплит исходного дерева
суммарного веса w.
Вот, здесь придётся говориться,
что, скажем так, такую
вставку нам всё равно
придётся делать вот за
получается вот какую-то
такую асимтутику.
Ну вот, ну как-то
видимо,
ну видимо не очень хорошо, правда?
Нет, потенциал
нет, почему? Потенциал увеличился.
Вот на эту величину,
на этот logarithm увеличился, поэтому
в учётное время нам придётся его
в учётном времени
нам придётся его учитывать.
Вот.
Но получается немножко грустно, потому что
от того, как получается
редкие слухи, когда
от того, что мы переведём сантиметры в килограммы,
у нас оказывается с весами будут
какие-то проблемы.
Вот это как-то вообще странно.
У нас получилось не то, что мы хотели
вообще никак?
Ну, нет, но тут
это вопрос, а что мы хотели, в точке зрения вставки?
Если уж в таких террорных мыслей,
так что мы хотели вообще?
У нас
asset-корня стала как-то
Почему у нас блок 2A,
2A плюс W?
Ну, потому что у нас
добавилась новая вершина, у которой
там SV равно
WV плюс W1
плюс W2, то есть W большое.
Вот.
У нас же
уменьшились
другие SV.
Нет, так как они там
поменялись, мы уже учли в здесь.
Вот.
Но это вот если делать insert таким
образом.
Потому что если мы делали
это через, допустим, сплиты
и, соответственно, 2 мержа,
то чтобы у нас получилось.
То есть
там было бы,
ну давайте, нет, ну давайте
попробуем, что.
Так, ну сначала мы делаем split,
это делается там за вот
логарифом двоичный, опять W,
там поделить на WE,
да?
Ну вот. Но пришлось бы еще,
теперь делаем мерж, еще один плюс
там логарифом двоичный,
чего?
Так, ну и здесь получается,
во-первых, W1
плюс WV,
да, поделить на
там какой-то W, еще
какой-то, еще какой-то
житой, да?
Ну и плюс, соответственно, еще
значит 1 плюс логарифом
двоичный, там
W1 плюс WV
плюс W2
поделить на
какое-то еще Wкаты.
Ну, по большому счету, в общем-то,
не то, чтобы прям стало
сильно лучше,
вот, но, по крайней мере, сохранилась
эта приятная вещь, что, как бы, если мы
все потенциалы увеличили, там,
давно жили на 5, то, как бы,
время работы от этого не поменялось.
Что, безусловно, приятно.
Вот.
Так что вот такая, допустим,
у нас будет красота.
Вот.
Ну, опять же, как я уже сказал, то есть, если бы,
опять же, да, было бы все очень
тупо, если бы все W там
брали единичками, тогда просто
ведь везде логен и не паримся.
Вот. И можно
делать вообще как угодно.
Вот.
Но здесь вот, тут, как всегда,
надо помнить, что имеется в
виду. Так вот.
Да.
Ну, мы тут просто, но
мы тут просто сказали, что мы подняли
эту вершину, да, и просто
отпилили у нее правое дерево. Тогда,
по сути, в этом правом дереве был
лавербаунд и все больше.
Но там, конечно, может быть, немножко подменилось
определение.
Но, с другой стороны, если бы хотели, скажем,
меньше отправить влево, а больше либо
равное отправить вправо, да,
то как бы, что мы делали? Мы могли этот
лавербаунд, скажем, поднять в корень и отпилить левое дерево.
Правильно?
Ну вот. Но мы вместо этого, это просто, mixture,
то есть если у этого лавербаунда
не было левой ребенка, значит, подымаем его,
а если был, значит, мы как мы ее искали, лавербаунд?
Мы пошли влево под дерево,
шли вправо-вправо и так
элементов больше либо равных ключа не нашли.
Нашли вот этот элемент.
элемент, так давайте его поднимем и отпилим уже
правое поддверье.
То есть тут в общем-то все достаточно просто.
Так, ну а теперь начинается, но пришло время самое
интересное.
То есть все это работает в предположении, то есть
мы что, действительно сплей у нас каким-то мистическим
образом укладывается вот в такую асимптотику.
Но так ли это?
Чего?
Ну реально да, ну ладно, не за линию, а за глубину.
Поэтому как всегда, если бы доказали, что глубина
всегда логарифом, то было бы все в порядке.
Да, но редкий случай, мы уже доказали, что глубина
не всегда логарифом.
Мы прям в явном виде привели пример, когда это не так.
Но нам на этот раз придется поговорить, как же мы будем
делать сплей.
Вот собственно давайте посмотрим в сердце.
Значит как же мы будем делать сплей?
Ну значит делать будем очень просто, значит наша задача
взять вершину В и поднять ее в кой.
Ну значит как мы ее будем делать?
Ну у нас будет четыре, в смысле три случая.
Случай номер ноль.
В оказалось в коре, как мы тогда ее будем поднять
в корень?
Нужно опустить на два и поднять на два.
Мы сделаем еще круче, мы просто не будем дышать.
Ну вот, дальше начинается следующее.
Значит случай номер один.
Если оказалось, что В это не корень, но сын корня.
Если вершина В оказалась вот таким вот мажорчиком,
то собственно еще тут можно сделать.
То как бы что мы делаем, мы делаем то, что мы уже
знаем из ВЛ, как малый какой-то поворот.
Да, я бы сказал, что левый.
Но бывает правый.
Ну вот, соответственно да, здесь как бы есть случаи
А и Б, в зависимости от того, типа В это левый ребенок
корня или правый.
Ну в общем, догадываетесь, что суть симметрична.
То есть в этих двух случаях мы завершаем работу за
О от единицы.
Следующие случаи мы тоже будем разбирать за О от единицы,
но в отличие от этих они будут говорить, типа сделаем
то, что в них написано и продолжаем.
Да, и мы будем исследовать, как он поменялся.
Ну нет, сейчас я рассказываю, как работает сплей.
После этого мы будем доказывать, что сплей работает действительно
вот так.
Ну левый что?
Ну может быть и правый, если бы вывести его с другой
стороны.
Ну вот так, да.
Если бы вывесил вот так, было бы вот так, да, ну логично.
И вот теперь, что делать если В, если оказалось, что
ни В не корень, ни родитель не корень.
Ну и здесь мы делаем следующее, смотрите.
Допустим вот у нас жила была В, у нее был папа А и дедушка
Б, и этот дедушка В, возможно, на ком-то висел, хотя может
он и корень, но нас сейчас это уже не волнует.
И дальше случаи, оказывается, 2 и 3, оказываются такие.
Пусть оказалось, что папа висит с той же стороны от
дедушки, что и В от папы.
Ну то есть, например, вот В оказался левым ребенком
вершины А, а вершина А левым ребенком вершины В.
Ну они могут, ну или оба правыми симметрично.
Значит, смотрите, тут оговорка, да, потому что, ладно, потом
оговорку скажу.
Так вот, в этом случае мы пойдем дальше.
Малые, обычно повороты очень любили делать, конечно,
родителей детьми.
Мы пойдем дальше.
Мы сделаем дедушку внуком.
Соответственно.
Чего?
Чего?
По какому росту, где росту, что?
Ну типа.
Вот.
Вот такая красота.
Ну да, в принципе, да, заметим, что, то есть, для этого,
то есть, помните, да, будет технический момент.
Если вы попытаетесь сделать это с помощью двух малых
поворотов для вершины В, то вас ждет фейл.
Потому что, если вы будете делать это с помощью двух
малых поворотов для вершины В, то вас ждет фейл.
Потому что, если вы сделаете два левых поворота, то,
конечно, у вас дедушка станет вашим сыном, но не внуком.
То есть, тут будет В, а тут будет А.
То есть, вам вот, а нужно именно так.
Почему?
Ну как-то часто бывает, да, как-то часто бывает.
Потому что доказательства так сходилось, а так нет.
А иногда делают наоборот.
А иногда делают наоборот.
Делают, получается, второй случай, чтобы он изначально,
ну, чтобы он, как вы сказали, как не сходится, да?
Да.
Что папа и дедушка, сыновья, да?
Нет.
А третий случай, наоборот, делают, чтобы он так и бомбулся.
Нет.
А, ну, смотря, что вы имеете в виду.
Да.
Так, ну, давайте тогда дорисую.
Ну, давайте предположим, оказалось, что у нас обнаруживается
так.
Нет, ну почему нет?
Обычно этот второй, нет, обычно это называется
второй случай, а это называется третий случай.
Ну, по крайней мере, в порядке исследования.
Ладно, на самом деле, конечно, в науке они не называются
случай 1, случай 2, случай 3.
Они называются зиг, зиг-зиг и зигзаг.
И рассматривается так, то есть, вы делаете шаги,
вы делаете несколько шагов, пока вершина V не окажется
в корне.
И каждый шаг, он бывает один из трех вариантов.
То есть, зиг, если вы оказались сыном корня, зиг-зиг, если
у вас тут, оказывается, от дедушки к вам, значит,
линия без поворотов и зигзаг, если с поворотом.
Вот.
Ну, и спрашивает, что делать в случае зиг-зага, а вот
здесь, как раз, заморачиваться не надо, два малых поворота
и называется, да, и папа и дедушка становятся вашими
детьми.
Вот, ну, это у нас уже было.
Вот, я как раз помню то, что в некоторых интерпретациях
наоборот делают, делают во втором случае два поворота
вершины V, а в третьем случае изначально, типа, верхний
крутит, а потом нежный.
Ну, как у нас случилось в том случае.
Сейчас, погодите, погодите, нет, пойдите, если вы сделаете
здесь два поворота, то тут будет еще раз V, V, A, да?
Да, да, да.
И это, и это типа устраивает?
Да.
Мы не можем делать два поворота, вернее, в случае зиг-зага
мы не можем сделать как здесь, потому что иначе V не станет
кое-кому.
Тогда V не станет кое-кому.
Нет, ну, почему?
Чисто теоретически мы могли бы сказать, что давайте
повесим, что скажем, там, допустим.
Мы не можем сделать сначала зиг-А, и затем зиг-В, потому
что V не станет кое-кому.
В таком случае.
Нет, мы делаем изначально зиг-В.
А, ну, нет, нет, у нас, нет, основные проблемы у нас
будут то, что A и B по-любому по разные стороны от V,
на этот раз находятся.
Да.
А мы сделаем изначально зиг-А, а потом зиг-В.
И тогда у нас будет V, A, B идти.
Вы знаете, если вы сделаете сейчас зиг-А, а потом зиг-В,
по-любому дерево тебе поменяется слово вообще.
Зиг-В, зиг-В.
Ну, сделали.
Так, будет A, V, B.
Так.
Да, да.
Ну, и что?
Ну, это тоже работает, утверждается.
Если мы обе случаи свапнем, и второй будет делать
в другой способ, и третий будет делать в другой
способ.
Это же будет работать.
Да.
Ну, потому что я и так согласен.
Ну, или тебя просто не завалили, да.
Знаете, как называется?
Это решение оказалось полной неожиданностью для нас,
мы не заготовили против него тестов.
Вот, знаете, как это.
Так что не факт.
Не факт.
Впрочем, всякое бывает.
Ну, вот.
Хотя, не знаю, может, нет, может...
Нет.
Ну, ладно.
Ну, как всегда.
Давайте будет картинка, называется такая.
Я буду рассказывать вот такое, потому что вот это
сейчас железобетонно работает.
А все остальное, ну, как бы ладно.
Если вы мне на экзамене докажете, что это тоже работает,
то, пожалуйста.
Всем желательно еще и вот в этом виде красиво.
А то, знаете, вот из-за этого, потому что...
Потому что так, я сильно не удивился.
Смотрите, тут есть...
Еще можно так доказывать.
Мы доказываем, скажем, с вами вот в таком виде.
Вот если вы откроете, допустим, книжку Боберка Левина,
уже упоминавшаяся ранее,
там вот с этими весами не заморачивались.
Там потенциал был просто сумма
округленных вниз двоичных логарифмов СЗАТВ.
Вот там был вот такой потенциал.
Да, чем приятен такой потенциал?
Он целый.
Я, между прочим, проиграл.
Чего?
Я проиграл.
Я тоже проиграл.
Так, это что, это опять интеллектуальная игра, что ли?
Ну, в смысле, нет.
Ну, типа...
Ну, вот.
Ну, вот, то есть там тогда вы как-то аккуратно
докажете, что...
Ну, там, в общем, то, что вы докажете.
А вот с вот этим будет не факт.
То есть, если вы пишете splay-дерево
ради того, чтобы написать splay-дерево, то как бы...
Соответственно.
Хотя...
Ну, как бы...
Поэтому тут вот...
Ну, там нет.
Просто подлянка будет в том,
что у вас там в дразатстве тогда в этих логарифмах
что там, что там все равно единички будут вылезать,
и вам придется с ними работать.
Вот.
Значит, поехали.
Значит, теперь давайте думать.
Значит, как же у нас будет это?
Значит, соответственно, работать.
Так.
Ну, давайте...
Значит, что мы попытаемся доказать?
Так.
Ну, давайте так.
Учетное время вот этого шара.
Ну, как угодно.
От нуля, от единицы, все что угодно.
Правда?
Значит, давайте...
Значит, поехали.
Значит, что нам...
Значит, хочется доказать.
Значит, соответственно, хотим.
Значит, на самом деле мы...
Значит, все, что мы хотим показать,
это то, что мы хотим показать,
что учетная стоимость...
Стоимость каждого...
Ну, вот.
Каждого из шагов...
Значит...
Не превосходит.
Значит, смотрите чего.
Внимание.
Три на...
Значит, логарифом...
Логарифом...
Я лучше вот так напишу.
Надо было...
Мог бы отношения писать.
Логариф двоичное S, V, new.
Минус логарифом двоичное S, V, old.
Нет.
Поэтому я напишу.
Плюс.
Ну, короче, на zig шаг я еще единичку накину.
Кстати, вот та самая единица в учетном времени.
Вот, понятно, да?
То есть...
А мы и меняем как-то?
Да, вот поэтому я пишу new и old.
Потому что заметим, что S, V до шага и после шага
это две разных S, V.
Правильно?
Ну, в смысле...
S, V это понятно меняется за счет того,
что мы W представили.
А мы меняем значение в сами?
Нет, в смысле, нет.
Веса мы не меняем.
Веса фиксированы раз и навсегда.
То есть как бы вы можете...
Скажите так, вы можете считать,
что у вас изначально есть N-вершин с весами.
Вот.
И, собственно, вы там с ними что-то делаете.
То есть потом мержите их, сплитите,
то есть там и так далее.
Но веса как бы зафиксированы заранее.
Так что вот такая получается красота.
Значит, ну, во-первых, давайте сразу скажу,
что если мы сейчас это докажем,
то я утверждаю, что учетное время
тогда сплея оттуда выплывет автоматически.
Согласны?
Ну, потому что там вот тут телескопические субы
посхлопываются и в итоге у вас окажется
что-то типа 3 логарифм 2-ичное s,
так сказать, v...
Да, можно сказать v-final
минус логарифм 2-ичный s v-start.
Ну, теперь...
Ну, заметим, что...
Действительно, ну, плюс один.
Это равно 3, значит, логарифм 2-ичных w
потому что в конце-то у нас s v, как раз,
просто с w и совпадет, правда?
Ну, вот.
Но здесь можно сказать,
что a-start можно оценить снизу,
ну, потому что раз с минусом, то снизу.
Ну, вот.
То есть как логарифм 2-ичный,
собственно, этого...
там, веса вершины v.
Ну, потому что в любом s v
уж вот это вот хранится,
а хранится ли что-нибудь еще непонятно.
Хотя полезно помнить,
что на самом деле там в этим точке
можно было не w и t написать,
а s и t написать вполне себе.
Что?
Ну, вот.
Ну, потому что там у нас...
там мы, собственно,
без этой единицы не обойдемся.
Вот.
Вот.
Вот.
Так что вот осталась...
то есть вот такая вот у нас
мистическая цель.
Если мы ее достигнем,
то мы победили.
Понятно?
Вот. Хорошо.
Значит, что же у нас теперь будет?
Так.
Давайте уберем эту цель.
Ну, так.
Точнее, так.
Ну, вот эту вот оговорку уберем
и немножко попишем.
Итак, поехали.
Значит, zik-chik.
Zik-chik.
Zik-zik-zik-zik.
Так.
Ну, давайте попробуем.
Поехали.
Учетная.
Стоимость.
Zik-shaga.
Что это будет?
Вот.
Ну, очевидно,
прям по определению,
это в точности один,
плюс потенциал в конце,
минус потенциал в начале.
Правда?
Но давайте так.
Альфа, бета, гамма
мы перебирать не будем,
потому что их вклад в потенциал
не меняется от слова никак.
Слышите?
Вот.
Ну, теперь давайте
значит, тогда смотреть.
Ну, давайте так.
Нет.
Вес?
Ну...
Да.
Нет, смотрите,
у каждой вершины есть вклад.
Другой вопрос,
что вклад вершины В
будут принимать участие
веса альфы и беты.
Это да.
Это мы будем учитывать,
конечно.
Ну вот.
Но я имею в виду,
что писать сумму
прям всех,
по всем вершинам
я не буду.
Я буду писать
только сумму
непосредственно
вот этим вершинам.
И давайте еще
сделаем оговорку
для того,
чтобы сказать,
что давайте лучше
рут вынесем сюда,
вершину У все-таки.
И заметим,
что учетная стоимость
тогда в точности,
внимание,
в точности равна.
Она равна
значит,
1 плюс
значит,
чего?
С
В
после
минус
С
У
точнее,
плюс С
У
после
минус
С
В
до
минус
С
У
до
Логарифм?
Логарифм?
Какой логарифм?
Одесский.
Бээээ.
Логарифм
еще какой-то.
Господи,
кто его выдумал
вообще?
Ой,
Господи,
пиши тут теперь.
Логарифм
С
У
после
плюс
Логарифм
С
У
после
плюс
Логарифм
С
У
после
минус
Логарифм
С
У
до
минус
Логарифм
С
У
до
Вот.
Такая
красота.
Так.
Ну,
начнем
с того,
что
имеет
конечно же
место
его величества
шлеп-шлеп.
Где
он имеет
место?
Вот я
утверждаю,
что
сразу
тут
кое-что
можно...
Да,
совершенно верно.
Потому что
заметим,
что
В
после
С
У до
принимают
участие
все
вершины
дерева.
Видно,
да?
Поэтому
остается
только
минус
Логарифм
С
У
до
Так.
Ну,
тут
видимо
придется
подписать
нот
соответственно
чуть-чуть
поаккуратнее.
Так.
А,
хотя
нет.
Ничего
аккуратного
тут писать
не надо.
Потому что
теперь
заметим,
что
это
меньше
либо
равно
один
плюс
Логарифм
двоичный
значит
С
В
после
Да.
Ой,
да,
здесь вообще
думать
не надо.
Минус
Логарифм
двоичный
С
В
до.
Ну,
потому что
если я
У
заменяю
на В,
то
ну,
кстати,
обратите
внимание,
еще
один
момент,
где мы
воспользовались
тем,
чтобы все W
больше либо
равно
единицы,
кстати.
Вот.
А,
действительно,
да,
да,
да,
ладно.
А,
ну,
по сути,
да,
да.
Ну,
очень
удобно
этого
под дерево.
Что
такое
С
В
после?
Это
суммарный
вес
вот
этого
всего
дерева.
Удобно,
правда?
То есть,
просто
заменили,
подменили
вершину
В
на предка
и все.
Вот.
Но
теперь
мы заметим,
поэтому
мы тут
можем
честно
написать,
что это
меньше
либо
равно
1
плюс
3
на
логарифом
2-ичный
С
В
после
минус
логарифом
2-ичный
С
В
до.
Вот.
Так.
Ну,
по-моему,
практически
так.
Чего?
Ну,
вроде
работает.
Ну,
мы
единичку
не
убили,
но
я
вот
ради
этого
как раз вот
писал
тут,
что это
зиг.
То есть,
это
зиг,
он
мажорчик,
ему
единичку
можно.
Вот.
Ну,
вот теперь
мы
приходим
к
самому
интересному.
Ну,
зигзигу
и
зигзагу.
Потому,
что у них,
конечно,
доказательства
будут
на порядок сложнее.
Так.
Так,
ладно.
Так.
Ну,
тут,
я надеюсь,
никаких
вопросов
нету.
Вот.
Мы
сейчас
будем,
соответственно,
разбираться.
Так.
Значит,
что
у нас
туточки?
А
туточки
у нас
вот что?
Так.
Ну,
поехали
писать.
Или,
все-таки,
другую
доску
притащить,
а?
Ну,
ладно.
О,
да,
сейчас
я
подвести.
О,
вы как раз к
самому интересу.
О,
вы как раз к
самому интересу.
Ага,
зигзиг у нас
тут уже,
да.
Ой.
И
кадас.
Так.
Ну,
вот.
Ладно,
поехали.
Так.
Значит,
уважаемые
знатоки,
поехали.
Итак,
поехали
на зигзиг.
Что
говорит
нас?
Значит,
зигзиг
берет
один
плюс
логарифом
двоичной
С
В
после,
плюс
логарифом
двоичной
С
А
после,
плюс
логарифом
двоичной
С
В
после.
Что
у нас
дальше?
Минус
логарифом
двоичной
С.
Что там?
В
до,
минус
логарифом
двоичной
С
А
до,
минус
логарифом
двоичной
В
до.
Так.
Вот.
Ну,
конечно,
если бы нам
разрешалась
единичка,
ну,
конечно,
если бы нам
разрешалась
единичка,
мы
конечно
тоже могли бы там
задачку
спокойно
в тупую,
то есть это
оценивать
сверху,
как лог
два
С.
В
после,
а это
оценивать
тоже там,
снизу,
как в С.
В
до.
Но нам
нужно
скушать
единичку.
Вот.
Вправить.
Как мы будем
кушать
единичку?
Как он
нас
поприветствует?
В
после
и
В.
В.
В.
Ну,
вот.
Да.
То есть
это мы
просто
пошлеп-шлепли.
Равно.
А1
плюс
логарифом
двоичной
С.
А
после.
Плюс
логарифом
двоичной
С.
Минус
логарифом
двоичной
С.
В.
До.
Минус
логарифом
двоичной
С.
А.
До.
Вот.
Ой.
Или все-таки
зиг-зага
начать.
Чего?
Ну,
да-да-да.
Нет,
просто в
зиг-заге
мы применим
красивый хак,
а в
зиг-зиге
надо, значит,
добавить
непонятно,
что,
и после этого
делать красивый
хак.
Ну,
ладно.
Да,
начали,
так начали.
Так,
ну,
давайте,
это называется,
ну,
давайте
смотреть.
Значит,
как
мы тут
будем,
соответственно,
оценивать?
Значит,
ну,
смотрите.
Ну,
во-первых,
ликвидируем
ашку.
Ну,
как я ее
ликвидирую?
Ну,
ну,
и в после,
и в до
я ее
отправлю в
в.
Соответственно.
А,
нет.
А,
не
отправлю,
да.
А,
ну,
нет,
почему же?
Ага.
Нет,
хотя
чего,
чего,
чего,
кого?
Чего,
чего,
кого?
Так.
Ну,
да.
Так.
Значит,
ну,
ну,
давайте
смотреть.
Значит,
чем
вообще
хочется тут,
конечно,
как-то
воспользоваться?
Ну,
в идеале,
на самом деле,
хочется воспользоваться тем,
что у нас,
действительно,
есть
вершина В,
на ней весят под деревья
альфа бета,
вот.
Да,
спрашивается.
Действительно,
как же этим
воспользоваться?
Так,
ну,
давайте,
действительно,
ладно.
А,
ну,
вот,
так.
Ну,
вот.
Ну,
слава Богу,
А,
до,
мы все-таки на В
подменим.
Соответственно.
И А,
после,
тоже,
пожалуй,
подменим.
Так,
значит,
да,
значит,
В,
до,
у нас уже,
нет,
хотя,
нет,
мы ничего
пока не будем делать,
значит,
у нас есть В,
до,
у нас есть,
есть у нас В,
есть у нас В,
да,
вот.
Ну,
и,
соответственно,
значит,
как-то
превратить В,
после,
ну,
после,
так.
Так,
ладно,
давайте.
Так,
логарифом два,
значит,
С,
значит,
допустим,
В,
после,
там,
плюс,
логарифом,
двоичный,
значит,
С,
соответственно.
Ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
соответственно.
Не,
там,
соответственно.
В,
после,
минус,
соответственно,
логарифом,
двоичный,
С,
В,
до,
минус,
логарифом,
двоичный.
Так.
С,
В,
допустим,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
크то.
Не,
ну,
почему?
Если у нас была
А,
то,
то,
как бы,
если мы
её хотим
подменять,
то получится
только В.
Ну,
ночью 모습TEG500,
так,
ну,
так,
ну,
ну,
так,
так нет ну как правда скажем так это скажем так так они не в это аэсв
нет ну не совсем так смотрите потому что нет ну как я уже сказал мы после
могли заменить на в после получить два там две разности логарифм плюс один но
это нас не устраивает потому что сказать что 2 там две разности логарифм
плюс один не обязательно меньше либо равных чем три разности логарифм без
этой денечки вот поэтому придется здесь немножко по 4
какие он вот каким соответствующим образом мы это сделаем вот
мы это сделаем весьма неожиданным образом давай
а что поменялось смотри давай что поменялось а после мы заменили на в
после то есть в после ведь я а мы заменили на родителя а поэтому стало
больше а здесь мы поменяли в до а на там с минусом поменяли наоборот на
потомка а так слушайте а теперь мы сделаем неожиданный хак мы скажем что
это равно 1 плюс логарифм двоичной с в после плюс логарифм двоичной с б после
плюс логарифм двоичной с в до минус 3 логарифма двоичных с в но внезапно да
вправывается зачем я это сделал а сделал я это вот зачем
и смотрите да потому что я прибавил логарифм двоичной св до и вычел логарифм
двоичной св до тут плюс а тут три минуса
значит а теперь вспомним так ну что вы уже значит закончили первую вы уже
сдали первый экзамен по анализу поэтому вы знаете что такое выпуклое
вверх функция да великолепно и также наверно знаете что логарифм это выпуклое
вверх функция а у выпуклых вверх функций есть такое мистическое свойство лог
икс один плюс лог икс два пополам меньше либо равно чем лог икс один плюс икс два
пополам вот да как-то по-моему что-то в голове почему-то начинает такое
словосочетание как неравенство янсона да нет это не оно
можно это просто это не поможет смотрите если мы сделаем это в тупую я мог бы тут
описать что это будет один плюс две вот такие разности логарифм но верно ли что один плюс
две такие разности логарифм меньше либо равны чем три такие разности логарифм вот
эту штуку нам уже не нужна к сожалению разность логарифм это было бы верно только в одном
случае если бы разность логарифм была больше либо равна единице такой гарантии у нас нет
вот собственно как сразу вот вот вот в этом вот случае кстати с ограничение вниз логарифм
да там в этом месте там аккуратно доказывают что потенциал там то что как-то скрип квантовый
скотчок произошел потому что там доказывают что как бы допустим у всех там квантовый
скотчок не произошел у всех этих вершин потенциал там округленный вниз логарифм
там СЗшки равен К, тут К, тут К, тут К, тут К, тут К, тут К, но такого не бывает. Почему?
Потому что значит тут у нас какая-то порядка степень двойки, то есть там около два степеника вершин, тут около два степеника вершин, значит
суммарно их около два степеника плюс один вершин. Ай-яй-яй, ну там какое-то такое доказательство.
Зачем я вообще это вспомнил? Да.
Сейчас подождите, у нас самая верхняя сумма, там один плюс лог, там СВ после, вот нельзя все, что с плюсами оценить как СВ после, все, что с минусами как СВ до.
Можно. Ну его получим. Значит еще, ладно, давайте так, давайте распишу.
А типа единицы? Да, нам единицы прям принципиально надо убить. Да, да, да, потому что иначе это будет работать как бы за три разности глобального грифа плюс количество шагов, но это нам не надо, ну вот, а это плохо.
Так, ну давайте попробуем вот этим воспользоваться, вот этим читом, значит это, значит пишем, где у нас тут, меньше либо равно, значит меньше либо равно, получается один плюс логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоичный СВ после, плюс, соответственно, два логарифом двоич
соответственно, смотрите, С, значит, В после, плюс, СВ до пополам, ну, двоечку и убили, ничего страшного,
вот, вот, но теперь, да, вы уже, да, но вы уже пробили, а в чем, собственно, приятность? Приятность заключает в том, что если я эту двойку вынесу, у меня тут будет минус два, и тем самым единичку убьется, да?
А приятность в том, что почему я подгонял именно так? Потому что СВ после, плюс СВ до, они прекрасно вписываются в СВ после, правда?
Видите, я специально подгонял так, чтобы эти под деревья не пересекались.
Чего нифига? Вот поэтому нужна была вторая доска. Ладно. Так, чего, где, где не видно, чего не видно?
Ничего не видно. Не видно, как бы их сумми участвует А. Ну, почему, вот, ну, во-первых, вот А, вот А. Вот, теперь вот здесь А осталось, ну, вот, ну, потом мы сделали шлёп-шлёп, вот А, вот А.
А в самом конце её нет, потому что вот на этом шаге мы эту А убили.
Ладно, я не в принципе просил, но я уже всё понял.
Окей.
Стоп, ну, вот там же, там же С, А после всё ещё есть.
Где?
На предпоследней стреке.
Нет.
Где?
В.
Это В.
Ну, давайте я побольше нарисую.
Это В.
А потом что?
Там везде ВДО два раза.
А, это мы как раз таки А вот так оценили.
Да. Да, тут оценили А вот так, тут оценили А вот так, я прям вот по-членному так нарисовал, чтобы понятно было.
Вот.
Так, ну, давайте смотреть.
Так, вот тут я, пожалуй, перейду вот сюда куда-нибудь.
Так, это у нас что получается?
Значит, один плюс лог два С, соответственно.
Ой, а это В у меня такое, ничего себе.
В после.
С, В после.
Плюс два, значит, логарифма двоичных.
Значит, С, В после.
Плюс С, ВДО.
Минус два.
Минус три логарифма двоичных.
С, В, ДО.
Значит, ну, это получается, смотрите, вот эта штука.
Вот, заметим, что вот эта вот штука меньше либо равна С, В после.
Вся эта скобочка.
И получается, что это меньше либо равно, чем три лог двоичных С, В после.
Плюс три, точнее, минус три С, логарифма двоичных С, ВДО.
Минус один.
Все.
Ну, я должен был, конечно, еще меньше либо равно написать, чтобы этой единички не было, но это уже мелочь.
Вот.
Так, ну вот, понятно?
Ну, как вы, смотрите, логарифм вот этого среднего пятичка это логарифм суммы минус логарифм двойки.
Логарифм двойки единичка, умножаем на два, получается минус два.
Так что получается еще такой чит. Неожиданный.
Так что, да, вот с точки зрения тройки, в общем-то, видите, неплохо получилось.
Вот.
Так что получается, зиг-зиг шаг впал.
Вот.
Но я утверждаю, что зиг-заг пойдет после этого еще проще.
Ну, к сожалению, не так же, поэтому нам придется его расписать.
Но, скажем так, дополнительных плюс-минусов нам делать не придется.
Давай.
Какой из?
Ну, ну что, если мы взяли вот эти два логарифма и сказали, что это меньше либо равно, чем два логарифма среднего рифметического, это эквивалентно вот этому неравенству.
Вот.
То есть такой вот неожиданный чит.
Так, ну давайте смотреть.
Так, ну теперь давайте попробуем победить зиг-заг.
Да.
А, уже просчитали там, да?
Да.
А, это я говорю, да.
Нет, я это говорю.
Валер, может вы там уже...
Вы там, в принципе, если там сели, вы застали то же самое расписывать, может у вас там уже и сошлось.
Итак, зиг-заг.
Нас приветствует зиг-заг.
Так, ну начало я зря стер, потому что оно, в общем-то, идентичное, да?
Лог двоичный В, там С, В после.
Плюс логарифм двоичный С, значит А после.
Плюс логарифм двоичный С, В после.
Значит дальше минус логарифм двоичный С, В до.
Там плюс С, как жалко, что это нельзя промотать.
Ну вы там на видео промотаете.
Знаете, это на самом деле как презентация.
Знаете, самое короткое, что можно было сделать, это на самом деле я бы записал все то же самое на презентацию и, собственно, вам бы показывал.
Ну вот.
Ну, собственно, в какой-то момент я перестал это делать, потому что обнаружила, что как бы...
Как бы, на понимаемость, то есть это, конечно, классно отражается на скорости, но не очень хорошо на понимание, на понимабельность.
Вот.
То есть, на самом деле, дайте так преимущество.
Пока я это пишу, у вас есть дополнительные, там, 30 секунд на то, чтобы, там, называется, лучше понять, что происходит.
Вот.
Значит, смотрите.
Так.
Ну, что мы тут делаем?
Так.
Ну, теперь мы, да, правда, теперь мы смотрим в зигзаг, соответственно, да?
Снова С В после.
Так.
Ну, да.
Так.
Ну, начнем с того, что мы должны что-то убить.
В ролик чего-то, естественно, опять у нас В после и В до, да?
Да, это уже было.
Значит, логарифом двоичный С.
А после.
Плюс логарифом двоичный С В после.
Так.
Минус логарифом двоичный.
Ну, вот.
Минус логарифом двоичный С А до.
Вот.
Значит.
Ну, а сейчас все будет короче.
Потому что заметим, что А и B лежат после, лежат слева.
Там слева и справа от В.
Поэтому к ним сразу можно применить неравенство.
Это вот мистическое неравенство.
Ну, точнее, неравенство просто можно применить.
Во-первых, можно просто сказать, что это меньше либо равно,
чем один плюс два логарифа двоичных С А после.
Плюс С В после.
Пополам.
И, ну, я здесь еще с четырю.
Я еще напишу сразу.
Минус два логарифа двоичных С В до.
Значит.
Ну, вот.
Ну, очевидно, это равно.
Чему это равно?
Ну, вот.
Ну, ладно, я давайте уже покороче напишу.
Два логарифма двоичных получится.
С значит В после.
Значит.
Минус один, минус два логарифма двоичных С В до.
Ну, это соответственно меньше либо равно, чем три логарифма двоичных С В после.
Минус логарифма двоичных С В до.
То есть как бы приятное свойство логарифма, да?
То есть как-то он получает эту единическую,
скрадывает действительно вот где-то вот в красивых объединениях.
Вот.
У нас С А после плюс С В после это С В после.
Чего-чего?
У нас С А после плюс С В после равно С В после, да?
Это меньше либо равно С В после.
И еще минус.
Ну, один, минус два, вот как уже было.
Поэтому я тут минус один написал.
Но при меньше либо равно минус один я убиваю,
а С В после по-любому больше либо равно С В до.
Поэтому как бы два меньше либо равно трех.
То есть можно еще было в предыдущем доказательстве,
в зигзиге еще подумать, а этот тройбан нам вообще нужен,
или как-то можно избавиться аккуратненько.
Вот.
Но впрочем это не принципиально.
Ну вот.
Так что получается плей дерево работает.
Ну, сплей работает, ну и как следует.
А на основании вома мы все уже выделили.
То есть мы уже воспользовались нашим методом, что если
мистический сплей работает, то мы умеем все.
Вот.
Но мы как бы убедились, что ну да.
В чем он умеет делать те же самые сплиты и мержи.
Может быть даже проще, чем эти ваши АВЛи там всякие.
Поэтому можно обнаружить, что там всякие там,
то есть всякие там операции типа там массовые операции вполне себе работают.
Но правда мы в прошлый раз не успели обсудить массовые операции.
Или успели.
О.
Вот.
А все-таки спуск до вершины, да?
Где учитывается?
Чего?
Спуск до вершины, где учитывается?
Спуск до вершины?
Нет.
Мы учитываем то, что мы спустились до вершины В, да?
А потом делаем сплей, который в реальном времени работает
вот за как раз ее глубину.
Мы же спускались тоже за ее глубину.
И сплей делается за глубину.
То есть получается, что реальное время симпатически не поменялось.
Поменялось только константа, разве что.
Вот.
Но учетное время оказалось хорошим.
То есть получается мы просто в это учетное время собственно впихнули
собственно этот спуск и не тривиальную работу с ним.
Так что вот.
Получилась такая красота.
Так.
Ну что ж.
Московское время 10 часов 58 минут.
И это означает, что наконец-то.
Да.
Как это называется?
Значит пришло время.
Да.
Как это называется?
Да.
Это называется.
Прошло два часа.
Мы закончили сплей деревом.
Пришел Денис.
А это означает, что пришло время устроить перерыв.
Так.
Ну вот.
Так.
Ну вот.
Это что?
Р Fernandes.
Так.
Ну вот.
Так.
Р Fernandes.
Так.
Ну вот.
А так.
так ну вот так ну вот
видно что-нибудь
сильно поменялось да
совсем темно стало так ну давайте немножко пробежимся по кое-чему
давайте пробежимся и так значит еще раз тогда вспомним значит как бы значит у
нас все деревья которые мы изучили соответственно мы изучили четыре дерева все они являются так
называем сплит мёрч 3 но падать сервинг ведем рандомно донную суть вы понимаете то есть можно
распиливать на сплит ну соответственно да вот но заметим что если вас просто есть сплит мёрч то
в общем можно и катаю порядковую статистику при желании искать вот ну собственно но вот ну собственно
во всех деревьях это не сильно сложно будет вот вот ну совсем в принципе вот да можно даже
убедиться что код будет выглядеть вот например сплит дерево примерно вот таким образом вот видно
да вот ну то есть заметим вот чем приятно сплит дерево это то что как бы сильно то есть ничего
то есть как напоминаю никаких вариантов нет единственное конечно что память вам хранить
придется потому что по-видимому все-таки избавиться от указателя на родителя вам
все-таки не удастся вот ну а так вы храните ключик но и конечно для это если вы хотите
искать скажем катаю порядковую статистику то сайс конечно искать надо вот значит что еще у нас
есть значит сайс у нас енот но сайс есть но соответственно как и как делать собственно поиск
катого элемента если у вас есть этот сайс но в общем-то думаю стандартный код тут думаю никаких
проблем особо нет или есть вот ну тут да думаю там во всех декортиачах вы тоже неоднократно
делали вот вот ну дальше у нас так ну что у нас возникает да но ладно тут-то тут возникает всякие
там мы же говорили что у нас есть деревья по неявному ключу это прошлый раз обсуждали да вот ну давайте
так на всякий случай отметим да что как-то что там что такое дерево по неявному ключу то есть
мы отказываемся от требований что элементы от сортированной воображаем их себе как массив и
тогда с этим массивом можно делать на самом деле там всякие веселые операции например там скажем
сделаем циклический сдвиг дерева чем не на один элемент она ну ну вот но оказывается понятно как
это делать то сделаем один сплит и один мерч просто тех же двух деревьев то в другом порядке вот
соответственно можно сделать на подотрезке вот но можно одному элементу за uno му присвоить
элемент но как бы это делается там 2 сплита 2 мерца ну там зависимости от твscene там можно
скажем сумму поддерживать то есть там можно целую инфраструктуру на эту тему сделать и здесь я вот
на всякие случаи давайте поговорим потому что мало ли там иногда и ту инфраструктуру можно
очень не оптимально писать вот допустим вы хотите там скажем хранить делать сумму на подотрезке да
что нам для этого нужно но во-первых значит сразу отметим не помешают вот
такие 2 там мелкие функции вот видно да но то есть знаете там будет очень
удобно дай я хочу там узнать какая сумма улева по дерева ну желать то вот
чтобы в этой функции был рассмотрен случай когда это дерево пустое но но и
соответственно суммой вот значит но конечно вообще когда вы там были как бы
фраза play деревья вам постоянно эти деревья придется как-то пер lasciMike
от пилиḿ Absolute подвешивать куда-то так с другой стороны лета в другую
вершину поэтому для того но вот а вам нужно поддерживать сумму на подделье
правда то есть как бы что такое сумма это сумма на териам и получается тогда вам
неплохо было бы уметь sahi couper веси товарищ разр helen или как бы
размер посчитан правильно а вот корме не факт потому что бы только что к этому
у коги чуть новое подвесили поэтому для этого нужна функция recalculate вот ну и по сумме то
же самое вот так что вот примерно так это теперь выглядит желательно объединить это в единую
функцию recalculate и в общем-то хорошо вот то есть дальше там появляются уже технические всякие
функции типа там connect и disconnect которая там дисконнект говорит что вот у вас есть корень
есть допустим у него ребенок пожалуйста отпилите от него ребенок но вот я сейчас конечно не самый
оптимальный по асимптутике там по именно времени там константе код но по камере видите он рабочий
то есть есть команда disconnect которая сказала что соответствующего ребенка нету вот так но
надеюсь вас вот этот тренажный оператор слева от присваивания не пугает нет ну естественно вот
значит ну тут вот все там аккуратно какие-то случаи смотря но и конечно вызвать recalculate
обязательно так ну что еще тут надо ну тут вот да ты хит всякое такое таки делаем ну вот ну и
соответственно connect то есть куда подвесить ну тоже вот можно делать recalculate то есть ну
то есть тут такой инфраструктурный код что типа по камере железобетонно работает да то есть когда
вы пишете там большой сложный код у вас особенно поначалу будет желание чтобы код в первую очередь
заработал а там работает он за 10 логарифом филиза там за 6 логарифов это вас уже не так сильно будет
волновать главное что работает вообще но вот ну да а да везде господи при любом повороте вам
придется делать disconnect и connect там собственно придется на этом при повороте скажем вам придется
отпилить дерево бета из одного места и подвести его другому например вот ну и там эти все то есть
там этих коннектов дисконнектов будет много вот но на самом деле да если включать какой-нибудь
дикартово дерево то конечно как вы уже знаете там реализация практически идентична впрочем как
мы уже с вами знаем то на самом деле если мы включим овл там сплит и мерч в овл красночерных
деревьев то тоже никто в общем-то тоже суть останется прежней вот ну там вот что-то еще можно делать
вот ну значит давайте типичная ситуация предположим что вы хотите изменять элементы
находить сумму на отрезке вот вот но заметим что кстати изменять элемент с плей дерева в общем
вообще становится максимально приятно потому что конкретно с плей деревья обратить внимание
вы как бы просто нашли этот элемент достали его естественно в корень да и после этого вы можете
спокойно в этом корне сделать переприсваивание и пересчитать сумму удобно правда это не вот это
даже как и круче чем в этой вашей дикарте очки вы сплетите тот элемент поменять там в бюджете
обратно тут вон вообще на халяву так что зачем вам дикартовые деревья пишите с плей вам понравится
вот не надо так кто-то и прикол вы ее в корень достали поэтому там никаких проблем нет даже
откреплять не надо просто один рекалькулей ты рад вот чего туда а теперь смотрите но если у
нас есть сабсермент какой-нибудь там то есть одно самое главное что если вы хотите делать
операцию на подотрезке то конечно вам нужна инфраструктура которая позволяет вам вы сплетить
подотрезок то есть разбить дерево на три дерева средние из которых это элементы из нужного вам
подотрезка понимаете да вот то есть в общем то здесь можно прям так и написать что есть сплит
есть мер штамм и так далее но есть там всякие нот то есть как считать с помощью этого сумму да
очень просто вы сплитчиваем нужный подотрезок записываем сумму значит вмерживаем подотрезок
обратно радуемся понимаете да вот так но ладно я раскуер рамку это мы в прошлый раз обсуждали
обсуждали обсуждали обсуждали там так здесь джойн спар стейбл мы с вами уже тоже обсудили так
дерево отрезков обсудили вот да но на всякий случай показываю что на всякий случай как писать
дерево отрезков с операциями снизу то есть помните если вы изменяете только один элемент
боже вас упасти писать рекурсию потому что как бы вот как бы будет версия которая работает просто
тупо как бы в общем и пишется проще и работает быстрее ну ну и нет но тут уже на ваше усмотрение
если вы будете писать дерево пол интервалов будет еще круче но это дерево отрезков да
что я боюсь отвечать на этот вопрос как мне показывает практика если я прям скажу
что там все не будет задачи значит все что угодно произойдет мы сегодня не будет вот я его да вот
я просто прошла да да я про что-то говорил что хотелось бы действительно этой недели
но с этим на той неделе встать и я радостно и проболел ее раз на всю практически эту неделю
только там от концу недели собственно там более-менее очухался а потом как я чуть-чуть не так
захотелось ой лучше ничего не буду обещать задачки но так вот идем дальше ладно значит теперь
смотрите но теперь переходим к операциям сверху так ну вот ну как дот но операции
сверху дала в дереве отрезков так надо подробнее разбирать нет это мы по-моему не разбирали
нет смотрите вот это у нас было да но поиск вот такой суммы это было до снизу это мы
смотрели а вот сверху мы не обсуждали вот нет надо ли тут кому-то это подробнее обсуждать или
не надо хорошо вот ну вот но отметим здесь что есть вот стандартный код но тоже он я думаю вам
без сомнения известен вот чем такой код сверху приятен да ну вот примерно вот этим вот да но
тут написано какой-то текст но просто оказывается что очень удобно действительно делать присваивание
на подотреске с помощью технологии отложенных операций чем она заключается ну заключается она
в том что если вы например решили сделать присваивание на вот таком подотреске да с точки
зрения старой версии дерево отрезка вы должны вот все тут раскрашенные хоть ваше это элементы
поменять согласны ну вот нет не согласно надо поменять не только раскрашенные элементы но
еще и вот эти вот потому что они как бы тоже изменились да но нет вот те которые да но их
все равно надо поменять то есть по сути надо поменять все дерево вот но мы четыре мы говорим
так вот надо поменять вот эту вершину все я по дереву но вы так но мы же операции делаем только
сверху и тогда говорим что пока мы не пойдем ее детей в общем-то в них ничего делать не надо
потому что а все равно как бы но потому что действительно зачем но в том плане что если то
есть как бы то есть пока мы туда не пойдем в общем-то нам и по барабану что там хранится главное
что когда мы туда придем там все хорошо да то знаете это как это и сыкла пока комната пока в
комнате темно нам абсолютно все равно что самое главное что когда свет включится чтобы там было
все в порядке вот понятна логика да вот то есть поэтому мы говорим то есть это но то есть мы в
говорим по принципу что это называется надо идти в детей не надо ну значит ладно я им потом
передам когда надо будет если кто-то придет скажет я хочу увидеть детей мы говорим так
сейчас одну минуточку и быстренько передаем им вот то есть видите получается что мы вот
в эти вершины никого не идем а идем вот в эти но вот но если бы но обратить внимание знаете
тут получается очень красивая иногда ситуация то есть есть у вас такая последовая такая вот
последовательная операция получается то есть эти получается так вот какой-нибудь вот этот
элемент говорит я гордая пятерочка но вот его родитель на самом деле ты двоечка но ты пока об
этом не знаешь на них с мета удобным взглядом смотрит дедушка и говорит на самом деле вы все
единички ну вот но этого я тоже не скажу кстати более того бедная пятерочка даже не узнает что
даже никогда не узнает что она была двоечкой но потому что прежде для того чтобы пока мы до
нее дойдем обнаружится так слушай ты передал что у тебя дети двоечки нет ой спасибо и не надо
они уже единички соответственно да вот так что примерно таким вот образом это будет работать
вот нашим принцип очень простой но соответственно что здесь происходит вот но здесь обнаруживаем
да что но вот но инфраструктура здесь отметим что значит кодовые фразы здесь у нас присвоить
на подотрезке там на под дереве и конечно мистическая операция push что такое операция push это
операция который говорит так если у меня есть отложенная операция я также сто передаю ее детям
ну вот ну и конечно присваивание на подотрезке может быть там здесь у нас при снот но здесь
присваивание на подотрезке сводится к присваивании на поддельный 6 дерева отрезков правда то есть
присваивание под дерево это что как бы я пришел к вершину в и я хочу чтобы весь подотрезок
который ей за который она отвечает был переприсвоен на и вот ну здесь деревья
отрезков тут приходится тоже делать какие-то ассайдон сегментом слева и
справа ну вот но оказывается в сплее но во всяких вот с плей деревьях это
можно делать гораздо проще ну как делать это с плей деревья так ну вот ну
код будет выглядеть примерно так то есть там вот то есть любая операция будет
соответственно делать так то есть вы вы сплитчиваете нужный подотрезок
делаете на нем отложенную операцию да вы прям в корне помещаете что у тебя у
вас есть отложенные операции потом вмёрзшим то есть обратите внимание да то
есть разница от старой версии отличается только в том что когда мы
идем вниз обязательно делаем пушдал вот понятно так но ладно тут ну мы никаких
вопросов нету да то мы этого все и так уже давно знаете но здесь только вот на
всякий случай подчеркнем важный момент да что как бы что чем приятные вот это
дерево сплэй всякие сплеи что оказывается что то есть оказывается что
вы можете теперь делать реверс на подотрезке но потому что оказывается что
реверс можно свести к отложенной операции что надо чтобы делать реверс нужно
просто посвапать местами детей и сохранить информацию о том что дорогие
дети вас надо вы должны быть там вас надо потом развернуть
но на самом деле ну утверждает все что поддерживает сплит мёрзшей операции
сверху пожалуйста теперь реверс на подотрезке то есть поэтому с точки зрения
науки до аввл умеет делать все что умеет делать все остальные деревья и у него
логарифм честный так что зачем вам эти декартовые деревья ну кому нужно да не
нужны нам эти декартовые деревья пишите аввл вот но правда декартовые деревья
правда они насколько я понимаю собственно чисто из-за этого изобретались что как
бы хотелось изобрести дерево которые очень просто пишут чего
но не совсем как ну как вы знаете константа у него не очень все-таки но
тут да все да все относительно да то есть помните да что все-таки при выборе
если как бы обычно советуются декартового дерева не писать если
можно обойтись дошечкой все-таки вот а так ну вот значит всякое бывает
но если вот но это у нас было соответственно до да и так то есть на
дыру в дереве отрезков и на всяких деревьях этих вот то есть на дереве по
неявному ключу можно делать всякие операции на подотрезке вот но значит
если но вот но на самом деле сейчас мы попытаемся неожиданно усилиться
сейчас мы попытаемся сделать эти все эти ваши дрожки но не на дереве она
мастер но не на массиве она дереве вот казалось бы да вот у нас есть то есть
обычно в дереве отрезка говорят что мы хотим делать там как-то изменять
элементы там присваивать на подотрезке там прибавлять на подотрезке сумму
искать на подотрезке ну что-то подобное а теперь возникает такой вот
неожиданный момент что а теперь представим себе что у вас оказывается
не массив а дерево вот такое классическое дерево что такое дерево ну
соответственно связанных ров без циклов да логично или вы не знаете что такое
дерево нет как бы я не спрашиваю про дфс это сложно это очень сложные
технологии спрашивают кое дерево нет я имею в виду что у вас там на кроме
дискрайне и там дерево не было раз нет а
кошмар да да что такое дерево а ну вот это как вы это авл вот это вот
дерево да а вы вот это дерево да красно-керное вот это вот дерево да
да сплеем она дерево да так ну да но вот ну ладно опять же что называется да не
называется но на этот раз опять не будем прикидываться вениками действительно и
скажем что вот у нас есть абсолютно обычно какой-нибудь подвешенный дерево а
может и не подвешенные но самое главное что не обязательно двойчина то есть там
степень вершины может быть какая угодно сбалансированность тоже может
быть какая угодно и нам говорят что теперь давайте в каждой вершинке хранится
киселка абсолютно произвольная
вот и нам хочется на этом дереве дерево допустим фиксированные давайте еще
что-нибудь тут порисую и на этом дереве хочется делать всякие операции ну как
я вот какие-нибудь операции но например нам очень хочется делать операцию
но например сумма на подотрезке но что такое подотрезок в дереве не очень понятно
поэтому хочется делать сумму на пути от удовольствия
но вот такая вот логичная идея но как же это делать
действительно пути на нот а бенапа да чтобы но вот ну вот то есть да мы конечно
можем воспользоваться тем что двумя вершинами сдается путь между ними но
надо но да да преф суммы но на чем но к сожалению для этого нам придется ввести
еще одну операцию на самом деле если мы хотим но здесь как бы знаете как бы
много чего придется сделать да поэтому придется на самом деле умерить пока
аппетиты да у нас была бы мечта то есть сразу забегай вперед у нас будет мечта
сделать то есть надо искать сумму на путях присваивать на путях да прям на
путях не вот к сожалению не настолько нет мы обобщаем все-таки дерево отрезков
эти картинки поэтому пока давай поэтому умерим аппетиты да вот присваивание на
третий все что умеет дерево отрезков мы хотим уметь на путях и более того за
тот же самый логарифом да не залог квадрата за логариф а то мало ли там знаете кто-то вот
но вот не но погодите как у хлд хлд для этого придет хотя бы более разминочные задачи нам
порешать вот для этого придется просто поработать с деревом как с деревом вот
ладно там можно много чего говорить на самом деле я могу сейчас рассказывать там про центры
там центроиды всякие диаметры но я пожалуй пока не буду этого делать вот хотя нет ну как бы
когда мы будем обсуждать центроидную декомпозицию конечно мы обязательно будем это делать куда же
мы денемся вот но вообще неплохо было бы сделать так вот допустим у нас дерево повесилось ну как
всегда это у нас бывает за какой-то курить и начнем мы просто с такой простой такой разминочной
операции операция называется из parent ув это же не операция просто були в запрос спрашивается
является ли вершина у предком вершины в да совершенно верно спасибо да является ли она
родителем это как-то просто а вот является ли она предка вот но здесь возникает классическая
технология тайм им и тайм аут то есть мы введем такое понятие как значит можем вести тайм им
это у нас соответственно время входа так сказать если мы запустим ладно совсем не
прикидывайся деньками dfs вот значит у нас есть вот тайм им и соответственно давайте их тайм аут
время выхода тогда возникает такая классическая технология да ну вот то есть давайте вот
проэмулируем чему это будет равно значит то есть 0 1 2 3 значит тут соответственно 4 вот тут
соответственно 5 6 7 и тут соответственно 8 соответственно 9 10 ну как вы уже догадываетесь
тут 12 потому что тут 11 13 14 15 16 и тут 18 ну потому что тут 17 вот ну а дальше тут понятно 19 20
21 22 23 24 вот 25 26 27 28 29 30 там соответственно что там еще 31 32 34 там соответственно но тут
33 35 36 37 39 потому что тут 38 40 41 42 43 вот то есть у каждой вершины есть подотрезок тайм
им тайм аут то есть когда вы в нее входите когда вы ее выходите и возникает мистическое утверждение
то есть у предок в тогда и только тогда когда соответственно временной подотрезок у является
над отрезком отрезка от в вот то есть здесь мы пишем тайм аут от у здесь мы пишем тайм аут от
в ну и здесь соответственно пишем тайм им от в и здесь пишем тайм инот вот вот согласны
с таким утверждением вот отлично вот ну по всем такое наблюдение позволяет вам сделать предподсчет
за от и из после этого за от единицы отвечать на каждый вопрос то есть прям вот идеально но
обычно конечно отдельно эту задачу не решают естественно обычно это так то есть там насчитывается
в предподсчете для того чтобы решать что-то более сложное то есть теперь помним что определить
кто там чей предок мы теперь можем на халяву так так ну а теперь вот возникает вопрос что еще
можно было бы сделать вот ну ключи но вот ну конечно ключевое без чего мы конечно работать
с деревом не сможем а слова никак это конечно мистическая операция л ца
экзектина хотя почему лист это вопрос конечно
ну пусть лову страшно не но нет логичнее потому что как бы самый низкий а так минимальный
общепредок ну хотя вот странно дайте вот тут то вот действительно потому что как бы на русском
языке и называется наименьший общепредок почему-то пишется что это лайк сайта ассасмент
ловость ловость нет но лост до янтс да лост лост спасибо
вот значит лост коман анцеста то что это такое то есть по определению это не самая глубокая вершина
да которая является предком и вершины у и вершины логично да вот значит но от внимания вопрос
значит как же этот значит как же этого общего предка искать вот но на самом деле тут есть
конечно два способа один способ там но то есть два способа оба требуют предподсчета за н логен
но вот но один способ тогда потом илца ищет за логарифом а другой за от единицы
спрашивается зачем же нам нужны оба способа а вот оказывается нужны вот но пожалуй давайте
начнем с казалось бы менее эффективного способа т.е. менее эффективный способ подразумевает что
вы для каждой вершины насчитайте такое понятие как значит будете насчитывать такие вещи как
ап от v и l то есть это предок v на расстоянии да два степени вот понятно да понятно да два степени
вот но насчитать в общем-то более менее без труда
вот особенно если вы это считаете кстати вот в таком приятном виде ну там это уже технические
детали но обычно вот удобно так считать но на самом деле насчитать в итоге все такие апы можно
за н логен используя мистический факт что ап от v и l плюс 1 равно соответственно ап от ап от v и
вот такая мистическая формула который говорит о том что что подняться на два степень плюс
один шагов нужно подняться на два степень шагов из этой вершины подняться еще на два степень шагов
вот так вот вот значит ну допустим вы такое за н логен насчитали но пригодится нам такое да
вот но что но вот значит как же это насчитать теперь нет как же это использовать но эти тут
есть разные способы на самом деле то есть есть две принципиально разные технологии вот вот
потому что можно значит делать так предположим вот допустим вам даны вершины ув первое что вы
делаете это за соответственно от единицы понимаете они являются ли кто-нибудь из них предком кого-то
ну потому что если скажем в это предок у то надо просто вернуть ответ в и не парится правда
логично вот но теперь предположим что выяснилось что у это не предок в но тогда идея будет очень
простая значит мы будем аккуратненько вот допустим дерево у нас вот как так выглядит мы будем
пытаться аккуратненько подниматься из вершины у по максимум вот но подниматься стараться так
чтобы не стать предком в но будет это работать примерно так там for и равно там лог там какой
нибудь там и так далее 0 значит там по принципу если у значит не из анцестер там от ап от у
л запятая в то тогда мы пишем что у равно ап от у вот понятно да вот то есть тогда кажется что
после этой операции как не сложно доказать у окажется не в лца но за один шаг до лца понимаете
да то есть там в конце вам останется только вернуть родитель то есть заведем что есть
получается что вот вы за логарифом собственно сам по себе это толца нашли ну кстати поднимите
руки кто пишет толца именно так ух ты популярно спасибо да ну хотя да чаще конечно пишут обычно
чаще вместо этого конечно вершинах просто хранят глубины и просто там пытаются сначала поднимают
одну вершину до глубины другой об том тем подобно подобного рода бин поиском пытаются поднять эти
вершины на нужную высоту ну и зачем это нужно то есть технология это не бесполезная там и конечно
сейчас узнаем в кавычках нет я имею нет кстати когда я говорил по другу пишем по-другому я
имел ввиду не то что там мы там сейчас это какие-то спортом сведем эту задачу к спортсам каким-то
да то есть на самом деле есть просто другой способ искать лца с помощью двоичных подъемов
нет а но в другой технологии да но в этой технологии этого не нужно да то есть альтернативная
версия нет альтернативная версия была давайте мы ее тоже упомянем потому что тоже на самом
деле может быть интересно альтернативная версия будет звучать так что у нас будет
некая мистическая функция значит допустим go up от в и аж то есть типа поднимись из вершины
в на высоту аж вот понятно да и если у нас есть эта функция то значит лца от ув после этого работает
примерно так значит что-то такое ну во-первых если оказалось что там аж от в допустим там
меньше чем аж от в этом аж от в это допустим там swap соответственно у и вы и после этого мы
говорим что у точно глубже чем в поэтому у теперь равно go up там соответственно от у аж да ну и вот
это вот все там проверить конечно если у равно равно в это ритор ну там ритор ну ну а дальше
там дальше уже классическое for log там l равно log 0 ну и соответственно там если значит а под там
в не равно а по туэль то соответственно в равно блаблабла тому равно блаблабла но в общем но
принцип понятен короче думаю подробнее не надо или надо вот но просто хотелось обрести внимание
что вот иногда используют такую функцию но к ней мы тоже соответственно будем еще обращаться вот
значит это был go up значит зачем это вообще все нужно вот это как помогает то что заметим что
этих двоичных подъемов можно насчитывать еще что-нибудь например сумму на двоичном подъеме
вот насчитывали когда инль сумму на двоичном подъеме и максимой самое главное максимум и
минимум да то есть на самом деле с помощью двойцы то есть как бы если нам дали запрос какой тип
найти скажем там максимум на максимум на пути то как бы вы находите и лца поднимаетесь из
каждой вершины к этому илца и как раз насчитываете
максимум и там собственно суммируете, можно так и
сумму искать.
Правда, Боже у вас упаси сумму так считать.
Хотя, погодите, прежде чем перейти, вернуться к сумме,
ладно, мы сейчас все-таки попробуем поискать илца
по-другому.
С помощью метода двоичных подъемов мы делаем предподсчет
за n log n и потом на каждый запрос отвечаем за log n, логично,
да?
Но есть альтернативная версия, но она заключается
в том, что, кстати, сходство с двоичным деревом поиска.
Заметьте, что поиск таймына, он в некотором роде похож
на такой DFS в формате, как у нас он назывался, преордер,
но мы знаем, что такое преордер.
На самом деле, я заметил, что если бы вычитали только
таймин, это был бы по факту преордер, то есть сначала
вершина, потом дети.
Тайм-аут очень похож на пост-ордер, да, сначала
дети, потом вы.
А теперь мы попробуем ввести понятие in-order.
Понятие, да, мы его вводили, но для двоичного дерева.
А как мы собираемся его вводить тут?
А очень просто.
Если я лист, то, значит, пишем меня и уходим.
Если вы видите, если есть я и у меня куча детей, значит,
пишем, значит, пишем первый ребенок, значит, пишем я
первый ребенок, я второй ребенок, я третий ребенок,
я четвертый ребенок, я пошел.
Вот, то есть в результате это сейчас поможет неожиданно
свести задачу ЛЦА к поиску минимума статическом массиве
на подотрезке.
Как это?
Ну вот, ну да, мы уже, ну как бы раз у нас спортстейбл
у нас уже есть, да, а при подсчет, ну как бы при подсчет
НЛОГН нас устраивает, поэтому, значит, ну вот, ну то есть
нет, конечно же, оговоримся, что мы будем, конечно, рассматривать
идеальный, в кавычках, алгоритм, который будет делать предподсчет
за УАТН, а потом все операции за УАТ1, естественно, но,
но я думаю, мы этим не сегодня займемся.
Думаю, мы там, думаю, мы там этими всеми четырьмя русскими
и прочими товарищами будем развлекаться в следующий раз.
Вот, значит, поехали.
А, Б, ну я тут сейчас вот от балды тут какие-то названия
вершинкам напишу.
Е, Ф, Ж, Х, Е, Й, К, Л, М, Н, О, П, П, К, Так, Р, С,
Т, У, В, W, Х.
Так, ничего не пропустил.
Да, нет, не пропустил, вон даже, тут даже две буквки
нарисовал, да, даже перестарался, но, окей.
И так, ИНОРДРОПХОТ.
Знаете, как мы же, для каждой вершины будем, пишем, я, потом,
а потом, значит, запускаемся от каждого ребенка и после
каждого ребенка пишем меня.
Получается примерно следующее, значит A, B, E, K, E, R, L... Ой, опять две буквы, что-то.
L, U, L, V, W, V, X, V, L, R, E, D, E, C, M... Ой. Не, это буква O, все нормально.
Подождите, а мы когда входим в совершину, мы ее не пишем? Пишем. А я еще не написал?
Вы написали V, W, V... V, W, V, X, V, и я пошел. Да, все нормально. Давайте L, R, E, D, E, C, M. Ой, а это тоже O. Ой-ой-ой.
А, это буква Q. У нас же буква Q нет больше нигде. Значит C, M, Q, N, O, P, O, N, Q. Там, соответственно, M, C, E, B, A, G, A, F, H, G, H, I, H, F, A.
Нет, O это междометие, если что. Ну вот. Зачем мы это сделали? Сам по себе этот список ничего не дает.
Но если мы напишем глубины этих вершин...
Вот примерно так это будет выглядеть. То теперь оказывается, что с помощью этого мистического массива и поиска минимума на подотресках в нем можно искать L, C, A.
Казалось бы, каким образом? Ну вот, например, хотим мы найти L, C, A между вершиной U и вершиной V, которые у нас L и N.
Ну тогда идея такая. Давайте найдем первое вхождение массива L и первое вхождение вершины N.
Так вот, давайте на этом подотреске между ними найдем минимум.
Он находится однозначно. Это вершина E. В нескольких экземплярах он находится, правда? Мистическое утверждение E и есть L, C, A.
Но остается только это доказать, правда, в общем случае.
Но думаю, на экзамене вы докажете без труда.
Хорошо.
Ну а что, тогда лист вообще не писать что ли?
Ну и потом, а если одна вершина преток другой, ну что ж.
Ага.
Так, ага.
А, ну нормально, да. Значит, что же нам тогда предстоит дальше?
Что нам предстоит дальше?
Вот.
Ну вот, то заметим, что этот способ, конечно, с помощью разрешенной таблицы позволит вам искать L, C, A за вот единицы.
Ну вот, но это как бы просто работать будет как черный ящик, типа хотели L, C, A, вот вам L, C, A.
И без какой-то там доп информации об этом.
То есть остальной доп информации вы ковыриваете сами.
Вот.
Но с помощью, но чем так или иначе L, C, A мы уже искать научились.
И теперь с помощью L, C, A мы теперь можем делать много чего.
Ну вот, например.
Допустим, у нас фиксированное дерево, да.
И мы, иначе у нас какое-то вот фиксированное дерево.
Давайте я вот эти таймыны, таймалты я, пожалуй, ликвидирую вместе с вершинами, да.
Ой, лучше давайте легче вообще уже вот так все это сделать.
Все, значит, L, C, A научились делать.
Вот.
Ну вот.
Что, соответственно, у нас будет?
Будет у нас пример на следующий.
Вот.
Ну, допустим, у нас все в порядке.
Ну, вот.
Вот.
Вот.
Ну, допустим, у нас есть какие-то вершинки, в них какие-то чиселки, как всегда.
Так.
Ну, вот.
И, допустим, дерево фиксировано.
И нам очень-очень-очень-очень хочется искать сумму на пути оттуда V.
Вот спрашивается, как это быстро делать?
Ну да, кто-то уже ради этого побежит писать heavy light.
Но, боже, у вас вот почти это прямо бежать и делать.
Потому что в случае конкретно суммы можно даже двоичные подъемы не писать.
А вместо этого действительно для каждой вершины посчитать сумму на пути от корня до этой вершины.
Да, в дереве, правда, вам могли не задать корень, но вы можете задать корень стандартным образом, вида вот он.
То есть, или что-то то же самое, тыкнуть в произвольную вершину.
Ну а так, честно, там, ну скажем так, лада, преордер обходом, значит, насчитаем сумму.
Так, 15, тут получается 19, 17, 20, 22.
Значит, тут получается 8, 10, 15.
Тут получается 8, 10, 15, 21.
Я почему 21? 16, 17, 18.
То есть насчитали вот такую сумму, и теперь замечаем, что если мы хотим найти сумму на пути, допустим, от У до В,
то получается, что ответ это сумма здесь, плюс сумма здесь, минус дважды сумма здесь.
Был Сашечка.
Да, ну ладно, плюс само еще чиселка был Сашечки еще.
Так, это понятно, откуда я эту формулу беру, да?
Да, все тут пока понятно.
Да, поэтому я с LCI начал.
Да.
Нет, ну почему, от логарифма избавили, ну почему, да, мы могли в запросе избавиться от логарифма, да.
А почему добавляем еще сумму в самой вершине?
Мы что, два раза добавили и один раз избавили?
Ну потому что, смотри, допустим, вот ты когда здесь прибавил вот это к этому, ты как бы весь вот этот путь прибавил два раза.
То есть если два раза вычтешь этот путь, то как бы вот тогда получается путь без этой вершины.
Вот, поэтому как бы саму вершинку надо, но это мелкие технические детали.
Вот.
Значит, это сумма.
Но есть следующий уровень.
Если вам нужно искать сумму и исправить один элемент.
Что это значит?
Ну, значит сказать, что возьми вершину V и напиши туда число X.
И продолжи искать суммы на путях.
Профессор, пишем хавилайт?
Погодите.
Не надо хавилайт.
Да.
Пока хавилайт не надо.
Потому что вместо этого у нас есть...
Дерево отрезка.
Да, и приордер обход.
Ну просто в чем идея?
Просто идея заключается в том, что допустим вместо пятерки мы тут написали семерку.
Допустим вместо пятерки мы тут написали семерку.
Тогда заметим, что у нас тут ко всем суммам ее поддерева прибавилось двоечка.
То есть по большому счету теперь все, что вам нужно уметь делать, это уметь делать прибавление на поддереве.
А как делать прибавление на поддереве?
Ну вот.
То есть можно было сказать массовые операции прям тут.
Делаем тут отложенную операцию, если пойдем ниже.
Протолкнем плюс два.
Нет, но у нас же в нашем обходе...
Да, но совершенно верно.
Если мы сделаем вот этот вот мистический приордер обход.
И перенумируем вершины в соответствии с ним.
То окажется, что все вершины поддерева представляют собой подотрезок.
И тогда это прибавление можно просто делать в дереве отрезков.
Да.
Это тоже такая классическая идея.
Ну здесь я на всякий случай проговариваю, потому что вот тут...
Там понятно, что в целом вы наверно это знаете, но как бы там кто-то о каких-то мелочах мог не задумываться.
Поэтому тут вот проговаривать важно.
Вот.
То есть получается сумму и изменение одного элемента можно вполне себе делать просто с помощью правильной перенумерации вершин и дерево отрезков.
Вот.
Нет, сумму ищем также.
Ну как бы сумма...
Это сумма на префиксе в UBI, плюс сумма на префиксе V, минус там дважды сумма на LCA.
Но не на префиксе, а на пути.
Вот.
То есть ищем абсолютно так же.
Правда, теперь уже это не завод единицы, а реально уже логарифм начинает работать, к сожалению.
Но ничего страшного.
Ладно, что делать?
Мы можем сделать диджоин спорт стейбл, нет?
Чего?
Чем нам поможет диджоин спорт стейбл?
Видимо ничем, но мы сможем складывать завод единицы.
А нет.
Да, но замечаю, что вот эти вот технологии конечно для ограниченного числа операции работают.
Потому что если я вас попросил еще и делать присваивание там на пути, тут ваше полномочие скорее всего уже все.
Вот.
Соответственно.
Вот, более того, если я даже просто попрошу вас искать максимум на пути.
Ну ладно, вы еще где-то выкрутитесь, потому что слава богу у вас есть двоичные подъемы, на которых вы можете и максимум насчитывать, да?
Но эти двоичные подъемы торжественно отправятся в трубу, как только вам к этому максимуму потребуют делать присваивание.
Ну логично, да?
Потому что как бы изменение вершины влекет за собой изменение огромного количества двоичных подъемов, просто всех двоичных подъемов, которые через вершину проходят, а их много бывает.
Поэтому нужна, конечно, какая-то более продвинутая структура данных, если мы хотим прям сделать все то же самое, что в дереве отрезков, но на дереве.
Ну вот, только не на массиве, а на путях.
И нам потребуется, конечно, ее величество Heavy Light Decomposition.
Вот. Нет. Неправильно.
Значит, Decomposition.
Decomposition Defease.
Вот. Heavy, соответственно.
Light.
Вот.
Вот. Красно-синяя, что-то там.
Значит.
Логика оказывается очень простой.
Значит, ну вот.
Идея будет заключаться в том...
Ну, как бы слово Decomposition подразумевает, что мы будем, значит, дерево декомпозировать на что-то.
Ну вот, что-то это будет в том, что дерево будет декомпозировать на что-то.
Ну вот. Что-то это будут у нас пути.
Ну что же, ну вот. Ну что же это за пути?
Ну вот. Ну и сделаем вот как.
Значит, естественно, всегда у практических любого дерева есть такое понятие, как размер под дерево, правда?
Более известный среди мирного населения, как СЗВ, правда?
Вот.
Ну давайте уж. Я думаю, многие из вас используют.
Так.
Ну как, кто хоть раз в жизни писал как бы именно СЗВ?
Я имею в виду, не использовал какой-нибудь синоним.
Типа size of W, size of 3, я не знаю.
Окей, молодцы.
Да, логично.
Ну да, СЗВ.
Ну да, да, да.
И еще метод потом. Get sub 3 size const.
О, я, я, я.
Вот. СЗВ.
Что будет тут?
Ну тут.
Значит, тут СЗВ все понятно.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
А вот теперь пришло время вести определение.
То есть пусть.
Значит, УВ ребро дерева.
И У родитель.
Так, да.
Значит, ребро УВ тяжелое.
Под капсом, в смысле.
Тяжелое, да.
Хотя на эту тему могло быть тут это красное, там металлическое,
или это кирпичное, там я не знаю.
Значит, если.
СЗВ больше либо равно половины всего СЗВ.
То есть на вершине В висит как минимум половина всего под дерево.
Ну вот. И.
Соответственно, легкое.
Иначе.
Ну вот.
Иначе.
Вот.
Вот такая, вот красота.
Вот.
Но сразу возникает мистическое утверждение.
Любой вершине В.
В вершине У.
Инцидентно.
Не более одного тяжелого ребра.
Вот.
Вот такой красивый утверждение.
Основная его красота, что это чистейшая брехня.
Правильно.
Конечно.
Верным оно станет, если я допишу здесь не более одного тяжелого ребра, ведущего в ребёнка У.
Потому что так-то в общем-то у родителя может и тяжелое ребро вести, почему бы и нет.
Нормальная ситуация.
Вот.
Ну здесь-то в таком виде, конечно, доказательство очень простое.
Ну действительно, что если у вас есть два, так сказать, тяжёлых ребёнка, то тогда получится, что в них содержится не менее чем всё под дерево вершины В.
А это неправда, потому что сама вершина В в них не содержится.
Логично, да?
Ну как вы же догадываетесь, сама вершина В в СЗВ обязательно входит.
Вот.
Ну теперь давайте попробуем нарисовать, какие тут ребра тяжёлые, а какие лёгкие.
Так.
Тут 6.
Тут 7.
Ну да, значит получается вот это.
Ну здесь без вариантов.
Ну и тут без вариантов.
Да, не самое показательное дерево получилось, конечно.
Вот.
Вот.
Ну, заметим теперь, что здесь.
Ну вот, можно теперь заметить, что, на самом деле, что такое хэви-лайд-декомпозиция?
Это представление дерева в виде, то есть множество вершин, в виде набора тяжёлых путей.
То есть заметим, что вершины можно однозначно разбить на тяжёлые пути.
Да, каждая вершина будет лежать в своём пути.
Ну да, если вершине вообще не инцидентны тяжёлые ребра, значит она находится на тяжёлом пути.
Вот.
Понимаете, да?
Ну и идея будет заключаться в том, что на каждом из этих путей мы будем на это сохранить реальное дерево отрезков.
Вот.
Понятен принцип, да?
Будем сохранять реальное дерево отрезков на каждом из этих путей.
Вот.
Понятен принцип, да?
Будем хранить абсолютно реальное дерево отрезков.
То есть если там придёт...
То есть, допустим, вот мы хотим сейчас реально дерево отрезков.
То есть, типа, хотим искать сумму на пути и изменять там один элемент, например.
Ну пока для разминочки один элемент.
То есть, чтоб поменять один элемент, поменяем его вот просто в соответствующем дереве.
А как искать теперь сумму?
Ну или там минимум, или что вы там ищете.
Идея будет следующей.
Вот жили были вершины Уйве.
И был у них мистический ЛЦА.
Тогда, чтоб найти сумму, нужно найти сумму вот на этом пути и найти сумму на этом пути.
Логично, правда?
Логично.
Так, ну теперь начинаем думать.
Вершина У находится на каком-то пути.
И он в тяжёлом пути.
И он где-то, наверное, вот тут заканчивается, правда?
Ну тогда давайте на этом пути, прямо из дерева отрезков, выковырием сумму.
И пройдём дальше.
Так, приходит вот эта вершина.
У неё тоже есть какой-то путь.
Путь, который тоже куда-то высоко идёт.
Вот.
Ну и наконец, кончится это в итоге тем, что мы в какой-то момент до этой ЛЦАшки дойдём.
И у нас тут будет вот найденный путь.
И вот мы путь отут до ЛЦА нашли.
Понимаете, да?
За какую симпточку мы это сделали?
Не совсем.
Не совсем.
Мы это сделали за логарифом N умножить на количество вот этих вот ребер.
Это-то да, но мы работали не за количество красных.
Видите, мы же красные разбили на подотрески, и каждый из них обработали за логарифом.
Ну да, но я имел в виду, что количество красных – это же самое, что количество синего.
Количество красных чего?
Красных ребер? Нет.
Красных путей на нашем пути.
Ну, количество красных путей, ну да.
Ну там плюс один.
Да. Ну, кстати, да.
На самом деле, кстати, да.
Это я тут так нарисовал, но давайте, в принципе, вот такая ситуация вполне возможна.
Ну правда, мы это тоже рассматриваем, как типа подотрезы глины 1.
Вот, то есть тут получится вот так, как-то тут получится вот так, тут тоже получится вот так, и еще получится вот так.
А что именно мы имеем в виду, когда говорим о своем дереве отрезков на тяжелом пути?
Буквально. Каждый тяжелый путь мы рассматриваем как массив вершин.
То есть у нас несколько деревьев отрезков?
Да. У нас, да, несколько деревьев отрезков.
Да. Несколько деревьев отрезков.
А, сейчас. Почему мы операцию дарим отрезкам, отрезками ценили крошлого N?
Потому что в каждой, потому что N это общий число вершин в дереве.
И длина каждого массива не более, чем N получается.
Ничего лучше сделать не может, да?
Ну, принципиально лучше не получится, потому что там получится куча рас, покоя, низы, но как бы не поможет.
Можно вопрос? Мы уможем N на количестве синих?
Синих ребер, которые мы встретили на пути.
Ну, пусть так, ну, не ребер.
Ну, могу плюс один написать, хорошо?
Давайте я плюс один напишу, если вас это смущает.
Да, плюс один, да.
Давайте плюс один, да.
Ну, потому что мы с ДОшкой пользуемся за логарифмы, а количество таких штучек, где мы воспользуемся с ДОшкой, как раз равно.
Ну, да. Вот. Поэтому теперь мы искали самый интересный вопрос.
Какой самый интересный вопрос?
Да, сколько легких ребер может быть на пути?
Не больше, чем логарифмы, а что-то раз-два раза.
Да, мистическое синее утверждение.
Для любой вершины В на пути от В до корня не более, чем двоичный логарифм N легких ребер.
Так, ну, тут тоже, видимо, простенько. Думаю, даже...
Так, тут надо объяснять почему.
Нет, тоже все понятно. Ой, Господи, да.
В общем, так, можно было сразу к сублимации суперэго переводить, да.
Ну, что делать?
Ну, да. Нет, ну, знаете, как бы...
К сожалению, в данном случае это надо прогреть, чтобы мы с вами хоть на одном языке говорили,
потому что выяснится потом, что как бы там...
Для вас ХЛД, это же какая-то другая аббревиатура, и вы там доказываете что-то по-другому.
Там всякое бывает.
Ну, в принципе, да. Почему тут легких ребер действительно не больше, чем логарифм?
Потому что понятно, что когда идем от вершины В до корня,
каждый раз, когда проходим по легкому ребру, size увеличивается хотя бы в два раза,
а когда проходим по тяжелому, size просто увеличивается.
Да, это важно подчеркнуть.
Да, поэтому не более, чем логарифм.
Ну, и отсюда получается, что в таком тупом виде, значит, это уже можно оценивать как лог квадрат.
Понимаете, да?
Вот.
Ну, заметим, что в таком виде, да, это, конечно, хуже, чем логарифм,
но зато за этот лог квадрат можно делать буквально все, что делало деревоотресков.
Правда? То есть там присваивание теперь на отрезке,
называется прибавление на отрезке.
Без проблем, правда?
Или нет?
Не совсем.
Нет, ну все, что умело именно деревоотреск.
Нет, на Нарейк Божий упаси.
На Нарейк Примутейшн на подотреске тут никто не претендует.
Так, ну и теперь, возможно, начинается самое интересное.
А можно ли бы это было допилить до логарифма все-таки?
Вот.
Да.
Но, оказывается, да, вполне можно.
Главное просто на...
То есть главное просто действительно оказывается на тяжелом пути, да, делать...
Мы сделаем на каждом тяжелом пути модификацию деревоотресков.
Вот.
То есть мы сделаем что-то типа дерево поиска по неявному ключу,
но весьма читерским образом будем делить массив на две части.
Как же мы это будем делать?
Делать мы будем так.
Значит, вот у нас есть красный путь.
Смотрите, на каждом...
Ну вот.
Вот есть у нас этот красный путь.
На каждой из вершин висит какое-то дерево.
Понятно, да?
Так вот.
Давайте последовать.
Значит, у каждого из них объявим его размер, как С1, С2, С3 и так далее.
Значит, С, допустим, Л.
Значит, внимание, вес каждого поддерева сама вершина входит, да,
но очевидно то, что висит на красном ребре не входит.
Понятно, да?
Сейчас еще раз.
То есть на каждой вершине...
На каждой вершине.
То есть мы говорим, что у нас есть тяжелый путь.
На каждой вершине помимо красного пути висит еще что-то на легких ребрах, правда?
Так вот.
Я для каждой вершины определяю вот С от нее.
То есть сколько вершин, так сказать, на ней висит, не считая, вот, без учета тяжелого поддерева.
Ну, если оно есть.
Вот для этой вершины как бы это СЛ совпадает с СЗ-шкой.
То есть СЗ-В-СЗ...
От тяжелого ребенка, да.
Если таковой есть.
Вот для этой вершины у нее тяжелого ребенка нет, поэтому мы ее выпиливаем.
Поэтому, то есть у нее СЛ совпадает с СЗ.
Понятно, да?
Значит, надо из этого массива сделать двоичное дерево поиска.
Ну, если мы сделаем двоичное дерево поиска, то там все операции сверху мы будем делать прям, как и раньше делали.
Как же мы это будем делать?
А делать будем так.
Мы найдем мистическую позицию И.
Такую, что С1 плюс...
Давайте, вот, пусть у нас С.
Это будет просто сумма...
Просто всех С.
Ну, как легко убедиться, кстати, она торжественно равно.
На самом деле, если это В1, то это тупо СЗ от В1 в первозданном виде.
Понимаете, да?
Так вот.
Не совсем она же...
В нашей постановке путь этот может закончиться...
А, да.
Не, в данном случае, да.
Так вот.
Ну, не важно.
Давайте я это назову просто С.
То есть это я так в скобочках помечу, потому что...
Значит, идея такая.
Я найду такое И.
Ну, вот.
И вот.
И вот.
Я найду такое И.
Что С1 плюс С2 плюс и так далее.
Плюс С и минус первое.
Строго меньше, чем С пополам.
Но С пополам меньше либо равен С1 плюс С2 плюс и так далее.
Плюс С и.
Ну, вот, короче, я буду идти слева направо.
Набирать сумму прям.
Суммировать, суммировать, суммировать.
И вот эту половину всей суммы я останавливаюсь.
То есть вот я выберу такое И.
Так вот.
Я объявлю, что теперь И у меня объявляется корнем дерева по неявному ключу.
То есть тут у меня типа подотрезок от 1 до И минус 1.
Тут подотрезок от И плюс 1 до L.
Ну и дальше.
На каждом из этих подотресков я начинаю строить сумму абсолютно таким же образом.
То есть считаю сумму всех вот эсок на подотреске.
Потом иду слева направо.
Насчитываю префиксную сумму.
Как только она набирает сумму пополам, то я объявляю эту вершину.
Там корнем нового поддерева.
Вот. Понятен принцип?
Да нет, наверное.
Наверное, да.
Вот.
Вот.
И вот к чему у нас это приводит.
То есть получается вот такое дерево.
Ну заметим, что глубина каждого поддерева.
Какова?
Логарифм.
Логарифм чего?
Нашего исходного дерева.
Ну не совсем.
Глубина каждого дерева, она не превосходит логарифма вот этой эски.
Понимаете, да?
Именно у каждого дерева эска своя и нам сейчас это будет важно.
Ну то есть с одной стороны заметим, что в каждом...
Ну вот.
То есть в принципе деревья получаются не более чем логарины.
Это в принципе нормально.
Но теперь заметим следующее.
Что в подавляющем...
Теперь мы будем делать аккуратно.
Заметим, что в подавляющем большинстве случаев, кроме, может быть, одного, да?
Нам требуется найти сумму на префиксе, правда?
Понимаете, да?
И на самом деле, когда мы делаем вот сумму на пути, нам нужно найти такую цепочку сумм на префиксе.
Ну вот эту операцию мы выкинем, потому что эта операция уже за логан как-нибудь сработает, правда?
Вот, но это уже как-нибудь там...
Уже без труда можно доказать, что мы действительно за логан в таком дереве можем найти сумму на любом подотреске.
Вот.
Ну а что же делать с вот этими префиксами?
Ну заметим, как у нас работает сумма на префиксе вообще в дереве...
В чем-то подобном типа деревоотресков.
Она работает так.
Итак, вы идете в корень и говорите, так, если этот корень в нужный вам префикс не входит, то вы как бы идете в левое поддерево, да?
Ну а в противном случае вы говорите, так, значит, берем сумму тут, прибавляем эту вершину и идем в правое поддерево, ищем там сумму на оставшемся префиксе, правда?
То есть получается вот такой лестничный спуск, да?
Да, аккуратный за логарифом.
Ну, кстати, вот помните эту классическую задачу, как найти там катую единичку на подотреске в деревеотресках?
Так, ну погибите руки, кто знает, о чем базар?
Ага. Так, ну окей.
Ладно, всегда, значит, все, кто не сидят глубоко в компьютере, знают, окей.
Вот.
Да, за логария, ну вот.
Ну да, дан массив из нулей единиц.
Надо поддерживать две операции.
Первая, поменять какую-нибудь цифрку, там нолик на единичку, единичку на нолик.
И второй тип запроса, это подотрезок от числа к, найдите в нем катую единичку.
Такая классическая задача.
То есть там классическая задача на вот такого рода как спуск.
То есть пример того, как делать бинпоиск в деревеотресках за логарифом, а не за лог квадрат.
Вот.
Ну вот такая вот, такой вот аккуратный спуск, аккуратный спуск, собственно, ждет вас здесь.
Но теперь я утверждаю, то есть, конечно, да, с одной стороны, в каждом дереве этот спуск будет работать как бы за логарифом,
поэтому суммарно может быть лог квадрат.
Но теперь я утверждаю мистический факт.
Суммарно, на самом деле, вы спускаться будете здесь от логарифа раз.
Почему так?
А, в общем-то, вот почему.
Смотрите.
Вот, допустим, у вас такая вот цепочка путей.
Все диоды между собой.
Там вот этими вот легкими ребрами.
Итак, поехали.
Значит, смотрите.
Давайте говорить так.
Мы будем идти сверху вниз.
У нас сейчас есть вот этот путь, на котором суммарно висит, ну, допустим, m вершин.
Вот на этой вершине суммарно m висит.
Я сейчас буду просто вершины, которые мне типа не нужны, я буду типа отпиливать.
Вот, понятно, да?
Как я это буду делать?
Я буду говорить так.
Я хочу найти сумму вот на этом префексе.
Так, где центр этого пути?
Так, он находится где-то здесь.
Ну, допустим, здесь.
Так, он, значит, на нашем, на вот этом пути не лежит, поэтому его и правое под дерево мы выкидываем из рассмотрения.
Вот, понятно, да?
Но заметим, что мы выкинули из рассмотрения, как минимум, m пополам вершин.
Ну, эту-то мы тоже выкинули, потому что.
Ну, там же у нас могло быть, где мы писали это равенство.
Да.
Ну.
Ну.
А там же у нас могло быть s1, s1 будет равно, надо будет с не единички, а потом это.
Нет, смотрите, дело.
Ну и что?
Нет, дело, фишка в том, что мы сам этот корень тоже выкидываем из рассмотрения.
А можно тебе повторить, что мы еще раз делаем с рассмотрения?
Мы его мысленно выкидываем из рассмотрения.
Это когда мы поднимаемся из левого под деревом?
Нет, мы не поднимаемся ни из каких под деревьев, мы только спускаемся.
Ну, в плане.
То есть мы как бы говорим, что мы ищем сумму на этом пути, да?
Такие на этом префексе.
Так, смотрим центр этого дерева, он допустим оказался здесь.
На префексе до развилки, да?
Да. Допустим, он корень оказался после развилки, значит его и то, что дальше мы типа не рассматриваем дальше.
То есть спускаемся в левое под дерево и выкидываем из рассмотрения тем самым все, что висит вот здесь и здесь, да?
А это как минимум мем пополам, да?
Следующий раунд.
Так, у левого под дерево корень, допустим, оказался до развилки.
Тогда мы выкидываем из рассмотрения ее и то, что находится до этого.
Почему? Потому что мы просто тут за вот единицы берем сумму и добавляем к ответу, правда?
Понимаете, да?
Но тогда это тоже нам превращает уже, тут было м пополам, тут теперь уже осталось м на 4, ну и так далее.
То есть каждый спуск по этому дереву уменьшает м в два раза, правда?
Ну вот, значит делаем, бомбим, бомбим, бомбим, бомбим и вот наконец мы пришли вот в эту вершину.
Почему то, что мы сверху откинули это м на 4?
Потому что мы это сделали после того, как откинули это.
Так, ну мы ее откинули, у нас исчезла м, ну как минимум он пополам, я согласен.
Но теперь у нас остался вот этот подотрезок, на котором не более чем м пополам вершин.
Вот.
Да, и сам корень этот тоже откидываем.
Да, но у нас же нет гарантии, что на одним м на 4 вершин.
Есть. Мы же дальнейшее дерево также строили.
Там-то корень мы тоже выбираем по тому же принципу.
Сейчас, я не понимаю, ну то есть почему не могло произойти так, что мы выбрали корень так, что у нас слева, опять же, глубина, слева одна вершина, а справа s-1, например.
Так мы же считаем не количество вершин.
Мы считаем не количество вершин на пути, мы считаем количество вершин, которые висят на этих путях.
И мы выбираем центр так, чтобы как бы здесь висело меньше половины, и здесь висело меньше половины.
Но меньше ли бы равно.
А потом, когда мы берём вот этот подотрезок, мы тоже считаем сумму уже для него, и тут его делим напополам так, чтобы тут висело меньше половины и тут меньше половины.
села меньше половины, тут меньше половины. Это уже половина от того, что тут, а нет половины от глобального.
Честно, да, но почему не может быть так, что, так я сказал, что у нас одна вершина, а есть мы сюда.
И что? Такое может быть. В чем проблема?
Проблема в том, что мы отсечем вот, например, вот эту одну вершину и пойдем дальше в правую, ну, к этому можно сказать.
Да, но, значит, на этой вершине висело там очень много вершин, половина.
Я правильно понимаю, что мы строим типа дерева отрезков просто моего типа?
Ну, скорее дерево по неявному ключу мы строим, потому что у нас корень есть, который мы отдельно рассматриваем.
Ну, в смысле, типа в 12 палку мы берем пополам, типа перетягиваем?
Ну, типа.
Ну, пополам, если считать, что все взвешены.
Ну, типа.
Сейчас я, ну, не знаю. Я все равно не понял, ну, то есть.
Ну хорошо, вот мы поделили так, что у нас, с ЛЕВО, меньше чем СПОПОЛАМ, а СПРОВО БОЛЬШЕ, чем СПОПОЛАМ. Давайgentle.
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
une
Ну вот, то есть идея такая, что у нас есть количество актуальных вершин, то есть изначально у нас актуальными являются все вершины, все потомки вот этой вершины.
Вот не только вот эти вот пути, а просто вообще все-все-все потомки, то есть там все, что тут вот-вот-вот висит, все вот-вот-вот висит и так далее, вот это все, все актуальные, да?
Но на каждом шаге внутри красного дерева мы как бы там, как бы, так сказать, какую-то из псевдополовин делаем не актуальной.
То есть как бы вот, если корень в эту сторону, значит вот эти вершины будут не актуальны. И количество актуальных вершин у нас как бы падает в два раза.
Нет, не дерево отрезков, а вот эту структуру.
То, что на каждом шаге мы отпиливаем половину интересных вершин, то есть актуальных вершин, это делается ровно со счет того, что мы заменили на тяжелом пути дерево отрезков на вот эту структуру.
Ну мы заменили дерево отрезков на бинарное дерево.
Мы, когда мы начали проходить, у нас все наше под дерево было важно, да?
Чего?
Ну, потому что в ДО ты просто поделишь этот список вершин пополам, и плевать, что тут висит там 100500 вершин, а тут мало.
То есть фишка будет в том, что ты будешь выделять корень и делить на отрезки таким образом, что количество висящих тут будет делиться пополам.
Ну, может быть так, что на одной вершине очень много висит, но поэтому мы ее в корень выносим. То есть тогда, когда идем что влево, что вправо, все равно там в два раза меньше.
При каждом переходе по ребру в любом из наших деревьев у нас суммарное количество рассматриваемых в будущем вершин уменьшается в два раза.
Но не совсем, когда вы переходите по легкому ребру.
Я имею в виду, я имею в виду, пройдем прямо в том дереве, в том дереве, в котором мы построили новую структуру.
Ну, типа да. То есть мы там вводим понятие, можно ввести там понятие еще какой-нибудь актуальной вершины, и собственно обнаружит, что…
При спуске по вашему ребру оно уменьшается в два раза.
Ну, типа того, да.
Вот. Понятно?
Слушайте, а кто-нибудь когда-нибудь это писал, кстати?
Не, ну почему шок? Нет, ну штука, в общем-то, известная, тоже во всех там тенькофах это вроде рассказывают, насколько я знаю.
Еще нет?
Ну, это просто лично Филипп Грибов сказал, на самом деле.
Кстати, это Филипп Грибов.
С нами он решил, и Филипп Грибов, и я.
Да?
Он мне не решил.
А, и?
Наших психи играл.
А, да. Сейчас. Хотя не вот что он мне сказал, вот это или… Нет, Level Ancestor Quarries я в статьях читал, нет.
Вопрос, а как у нас в итоге суммарно получается?
Он суммарно хорошо получается.
Значит, ну еще раз.
Так, ладно. Сейчас я, кажется, придумал, как это… Ооо.
О.
А Стас уже за едой пока сгонял, да?
Ну, хорошо. Так, ну ладно, Стас, как раз вовремя пришел, конечно, да.
Какой перерыв?
Нет, там, знаете, там такой хренометраж, что если честно, есть просто большое желание пораньше закончить уже.
У нас теперь две пары по полторы пары.
Ну, две пары по полторы пары.
Ну, да.
Да, удобно считать так.
Нет, я предпочитаю считать, что у нас с вами есть, как бы, четыре с половиной часа, которые мы там можем с вами полезно использовать.
Да, ну как бы.
Так без любви, без любви.
А, ну вот.
Нет, нет, нет.
Нет, нет.
Я читал УЗУ, нравится.
Ну вот, значит, смотрите.
Идея теперь будет такая.
Значит, вот этот красный путь.
Значит, смотрите, дело в том, что это так.
Значит, у вас есть этот красный путь.
Красный путь.
Значит, он на самом деле является собой, то есть мы из него построили вот это мистическое дерево, да.
Там не шибко сбалансированное так вот по этому параметру, но ладно, допустим, вот так так нарисуем.
Вот.
То есть на каждом из них есть, висит что-то синее.
Вот.
Вот.
Сейчас максимально наглядно будет.
Значит, смотрите.
Что получается?
Значит, идея такая.
Значит, на самом деле, когда мы ищем сумму на префиксе, мы как бы делаем какой-то аккуратный спуск до какой-то веревки.
Значит, на самом деле, когда мы ищем сумму на префиксе, мы как бы делаем какой-то аккуратный спуск до какой-то вершины.
Понимаете, да?
Так вот, давайте будем говорить, что на самом деле теперь будем говорить, что у нас как бы актуальные вершины, это те вершины, которые вот в таком смысле висят, то есть еще висят на той вершине, которую мы рассматриваем.
То есть изначально у нас актуальны все вот эти вершины.
Потом мы, например, решили идти влево.
Теперь актуальными становятся только вот эти вершины.
Но фишка в том, что мы как бы, то есть коринг мы выбирали так, что вот этих вершин как минимум там их всего, как минимум половина от всего, и вот этих вот вершин как минимум половина от всего, правда?
Правда, что это тот же алгоритм?
Абсолютно тот же.
Просто я его сейчас по-другому рассказываю.
То есть просто так нагляднее.
Вот, значит, смотрите.
Значит, получается, что вот сейчас вот этих вот вершин как минимум в два раза меньше, чем всего вот этого, правда?
Понимаете, да?
Потом мы за вот единицу переходим сюда.
И получается, что здесь количество актуальных вершин уменьшилось еще в два раза.
Потом мы перешли сюда и уменьшилось еще в два раза.
Понимаете, да?
Потом мы здесь уже из этой вершины перешли по легкому ребру.
Вот в этом вот глобальном поддереве, да?
И на этом поддереве обнаружился еще один путь.
Вот, понимаете, да?
Ну, как бы, который идентичен вот примерно вот такому.
Вот, понимаете, да?
Но здесь тоже мы теперь идем, допустим, влево.
И у нас опять количество, то есть актуальные вершины.
Это вот теперь у нас все то, что вот типа висит вот здесь, да?
То есть это является частью того, что висело вот на этой вершине, да?
Теперь поменяли, поменяли, вот поменяли.
То есть тут вот висит.
Теперь вот опять, то есть каждый раз, когда мы идем по вот этому красному дереву влево или вправо,
неважно, допустим, идем сюда-сюда, то на каждом шаре количество актуальных вершин все равно уменьшается в два раза.
Видите, да?
Но здесь мы тоже, допустим, пришли куда-нибудь вот сюда, пошли тут сюда и повторили операцию.
То есть получается, видите, мы делаем какие-то шаги внутри красных этих деревьев и по легким ребрам.
Но получается количество шагов вот этих вот в красном дереве, их не более, чем логарифом,
потому что на каждом шаге количество актуальных вершин уменьшается в два раза.
Ну а количество, ну вот, для просинья ребра мы так сказать не можем, но мы знаем, что их в принципе логарифом.
Поэтому отсюда получается, что вот в таком виде мы умеем писать heavy light за логарифом.
И на самом деле получается с точки зрения задач деревоотресков нам без разницы дерево, это как бы на массиве мы пишем или на дереве.
Все работает за логарифом.
Вот кажется, здесь куда более пижальная константа.
Да, с большей.
А это для минимума максимума?
А какая разница?
А какая разница?
Это нормально, как бы мы на этом дереве можем спокойно делать абсолютно все те же самые присваивания на подотреске,
потому что делаются они тоже на наборе префиксов там, наборе префиксов тут, наборе префиксов тут и там одной какой-то там вот этой штуки.
То есть это тоже самое можно делать, что из этого квадрата?
Ну да.
То есть просто нет, мы же деревоотресков заменили на вот эту структуру, на которой все отложенные операции также делаются.
Прям вот, прям вот идентичненько.
Так.
Так, сколько у нас времени-то вообще осталось?
В смысле меньше часа?
Ну меньше часа это вообще называется 40 минут, с учетом того, что мы не делали второго перерыва.
Ладно.
Значит тогда вынужден констатировать, что лент-кат придется собирать в следующий раз?
Чего нет?
Очень хочется сейчас?
Нет, я могу это организовать, но я боюсь как бы нас просто остановит лично мещерин.
Ну там прилично, но я бы за 40 минут мы как бы это не обсудим.
Нет, ну можем, но зачем на это тратить время?
Нет, ребят, все гораздо проще.
Нет, у меня для вас еще одна красивая задача, действительно.
Нет, правда это уже не... Да.
Да.
То есть просто есть еще одна такая красивая задача.
Ну как бы да, видимо в следующий раз у нас будет наверное много...
Да, вот сегодня у нас было видимо не очень интересная такая лекция получилась.
Вот.
Ну половина ее, я как бы повторял то, что понятно, что вы там и так давно знаете.
Вот.
Ну в следующий раз видимо нам придется просматривать во-первых лент-кат.
Ну вот.
Ну и во-вторых конечно же видимо метод четырех русских.
Там в куче его проявлений.
Ну и видимо в конце видимо...
Да, ну видимо в конце повернем еще центроиде композиционом, но это уже халява будет.
Вот.
Ладно, а пока у меня для вас есть такая замечательная, красивая еще одна задача,
которая всегда в тему очень хорошо ложится.
Вот.
Называется она Level Ancestor Queries.
Level Ancestor.
Ancestor Queries.
Ancestor Queries.
Ancestor Queries.
Ancestor Queries.
Вау!
А, в смысле предподсчет?
Пока нет.
Нет, в следующий раз у нас будет метод четырех русских, потом там она будет за ОАТ.
Но как бы да, метод четырех русских тут будет решать прям все.
То есть знаете как это, как там вот...
Потому что знаете, вот вы знаете...
Потому что знаете, вот вы...
Ну как вы знаете, вот у меня есть научный руководитель.
Ну вот, так вот лучше так, что на самом деле хорошее занятие,
на самом деле должно быть всегда посвящено ровно одной идее.
То есть какой-то одной идее, и надо ее рассматривать вот со всех ее, от всех возможных сторон.
Вот.
В общем, не очень хорошо я считаю занятия с этой точки зрения, конечно, да.
Вот.
Ну вот.
Ну вот.
Ну вот, в следующий раз мы как бы возможно приблизимся.
То есть у нас будет в следующий раз метод четырех русских там, но как бы...
Возможно сразу и везде.
Две идеи, да?
Нет, у метода четырех русских одна идея.
Но она будет применена как минимум в задаче про РМКУ.
Как минимум в задаче про ЛЦА.
И это, кстати, будут даже две, два разных четырех русских.
Ну потому что как бы, как бы есть классический алгоритм парок Колтон Бендера, да.
Который там РМКУ сведет к ЛЦА, потом ЛЦА к РМКУ плюс-минус один, а дальше четыре русских поехали.
Вот.
А есть на самом деле версия, как РМКУ сводить просто напрямую без сведения к ЛЦА.
Вот.
Но это такая более, такая более сложная версия там, весело будет.
Вот.
И конечно есть четыре русских еще вот в этой задаче.
Но тут, да, но тут мясо будет то еще, да.
Нет, хотя нет, знаете, это, нет, там.
Нет, знаете, настоящее мясо это Atomic Hip на самом деле.
Вот, знаете.
Ой, у нас будет Atomic Hip.
Ой.
Чего?
Нет.
Знаете, я целенаправленно его не пропустил, вот по какой причине.
Значит, дело в том, что это как бы алгоритм не произвольный, это вот алгоритм именно вот на целочисленный.
То есть как мы уже говорили, да, вот, помните, вот когда-то, мы когда-то в прошлом семестре осматривали техпатрик-сорт, помните?
Да.
То есть там мы прям в явном виде пользовались тем, что у нас память выглядит вот так, то есть как бы W-битные числа, да,
мы с ними там умеем что-то делать за О от единицы.
И вот давайте на них, там, сделаем сортировку.
Вот выяснилось, что мы, оказывается, умеем это делать за прикольную асимптотику еще более прикольным образом, да.
Вот.
На самом деле там в эту сторону может там целый класс алгоритмов забабахивать.
То есть пользуясь тем, что вот мы работаем именно с такими числами.
Вот.
Кстати, дерево он МД Босса, кстати, из той же категории.
Вот мы его тоже, кстати, пропустили в кавычках.
Хотя, на самом деле, мы его целенаправленно оставлял.
Вот.
И вот поэтому, я думаю, что у нас в этом видео было очень интересно.
У нас будет просто широкий, там, собственно, широкий класс алгоритмов в эту сторону,
который у нас, возможно, уменьшает атомик хип.
Нет, если повезет, его уменьшает алгоритм торопа, конечно.
Но тут как повезет.
Потому что алгоритм торопа, это вот, действительно, настоящее мясо.
Потому что если мы, просто, если обладеем вот это, то как бы это прям все.
Мы вообще богами будем.
Алгоритм на нас 3,7, да.
3.
Что ACPC?
Нет, что ACPC?
Нет, богами ACPC мы, к сожалению, от изучения этого алгоритма не станем.
Ну, потому что так, как бы, в общем, мы, ну, мы, ну, мы, ну, мы, ну, мы, ну, мы.
Да, да.
Вот.
Вот.
Делаем, да.
Вот.
но потому что как всегда это будет алгоритм до корридиона он использует
атомик хипа томик хип начинает нормально работать если n больше чем два
в степени там 53 и в степени 12 нет там реально какая-то такая башенка стоит
цифру вообще не помню сейчас но вот
давай да нет вот это вот это красно у красного дерева ребра конечно же не
совпадают с ребрами исходного как минимум потому что как бы исходно на
этих красных ребрах это просто путь был но не совсем ну да ну типа хорошо потому
что мы сделали преобразование так что как бы когда вы спускаетесь по красному
ребру количество вершин и висящих вершин как бы тоже уменьшается в два
раза правда как бы для синих это видимо перестало так это возможно так
работать ну да для себя так хотя кстати ну да как бы да для синих как бы так
перестало работать да но синих тоже алгоритм да за счет этого мы победили то
есть как бы у нас две красные стали как бы хорошие а синие могли стать плохими
но синих осталось мало вот вот ну то есть тут вот да философский крыша
просто с какой точки зрения на это смотреть чтобы действительно всё стало
понятному чем мне легче вот действительно смотреть что вот есть вот такой красный
путь и мы как бы отпиливаем там типа вот эту часть потом вот эту часть потом вот
эту часть подлите у себя пилен так что вот останется только это нет легко так
воспринимать но тут видимо корейца на вкус и цвет фломастер и разный как
всегда да
А теперь задача levelAncestorQuest.
Пока в простой версии.
На самом деле задача простая.
Дано дерево.
И надо делать только один запрос.
Тот самый goUp от v и h.
Подымитесь из вершины v на высоту h, пожалуйста.
С помощью двоичных подъемов мы умеем делать предподсчет за m log n.
И сам подъем можем делать за логарифу.
Вот, согласны?
Так вот, наша цель, пока я не мирюсь сегодня, предподсчет сделать все еще за m log n.
Но этот подъем делать все-таки за 1.
Вот такая у нас мечта.
Вот, понятно?
Тут сейчас веселее будет.
Нам для этого придется обсудить еще парочку декомпозиций.
Нет, это мы как раз успеем.
Нет, сейчас будет очень просто.
Давайте, просто если вы меня сейчас отвлекать особенно не будете, то мы сейчас успеем.
Значит, смотрите.
Вот у нас была хавиллай декомпозиция.
Забудьте.
Это называется...
Да, ну, во CPC жизни она как раз пригодится.
Но слющайте другую декомпозицию.
Longest pass decomposition.
Значит, смотрите.
О, ладно, я ее красеньким буду рисовать.
Longest pass decomposition.
Или...
Да, почему-то она называется longest pass, хотя правильно назвать, наверное, longest depth decomposition.
Значит, она говорит так.
Я хочу...
У меня есть подвешенное дерево, как всегда.
Смотрите, я у каждой вершины, у каждой вершины, у которой есть дети, хочу выбрать одно ребро в ребенка и сказать, что оно крутое.
То есть, заметил, что я таким образом декомпозирую дерево на хорошие пути, правда?
Остается только вопрос, по какому принципу выбирать...
Ну, по какому принципу, собственно, выбирать хорошесть.
Вот, кстати, могла быть версия, давайте хорошим...
Я выберу ребро, если оно ведет самое тяжелое под дерево.
Ну, плевать оно там, половина или нет.
Что значит тяжелая в нашей текущей декомпозиции?
А что она означает в текущей декомпозиции, я не сказал.
Я говорю, что просто в heavy...
Есть просто такая интересная версия heavy light, а, кстати, кто-то ее так пишет, что...
Вот мы сейчас говорили, что тяжелое ребро, это прямо если там обязательно половина, да?
А теперь идея такая, а давайте скажем, что просто давайте из каждой вершины будем вести ребро самого тяжелого ребенка.
То есть, тогда это будет такая, это будет heavy light, у которого некоторые пути сконкатинированы еще.
То есть, это уменьшает количество путей и, вроде как, дает какую-то оптимизацию.
Дает оптимизацию хотя бы в написании, потому что как-то она приятнее по...
Ну, например...
Чего?
Да, если писать там же можно перепорядочить...
Нет, погодите, life hacks перепорядочили таким образом, что когда в каждом пути вершины идут от A до B, он работает в любой декомпозиции вообще.
Вы главное просто построите там какие ребра хорошие, а какие плохие.
Ну, это пожалуйста, да.
Но, правда, не знаю, мне все равно ощущение, что если писать дерево отрезков все-таки честное, то есть на столько сколько там надо, то это может быстрее работать.
Потому что так вы будете в едином дерево отрезке полюбачку за логорифом работать.
А, в смысле, если это пучак строить?
Ну да.
Да, конечно, это будет быстрее работать. В смысле еще?
Тут вопрос только в приятности написания.
Ну да.
Так вот.
Значит, в long-response decomposition принцип построения принципиально другой.
Мы ведем ребро в самое глубокое под дерево.
То есть меня интересует.
Так, дорогие дети, а насколько глубоко я вас могу пойти?
Так, что-то плохо сказал, да?
Ну вот.
Ну типа да. Дорогие дети, на вас висят какие-то листы.
Да, лист находится где-то глубоко.
Вот, давайте в самое глубокое и отправимся.
Ну и здесь у нас боевая ничья, потому что здесь...
Ну давай, нет, ну тут вот насчитать можно так.
То есть это вот 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0.
Так, 0, 0, 0, там 1, 2, 3, 4, 5, 0.
А, прикольно, тут все-таки глубже.
Ну, значит, логика очень простая теперь.
То есть я насчитал для каждой вершины максимальный путь до своего потопка.
Так вот, ну и рисовать я буду очень просто.
Из каждой вершины я буду выбирать ребенка, у которого эта чиселка побольше.
То есть вот примерно вот так.
Вот, например, это будет...
Ну если есть боевая ничья, то как бы пишем, выбираем любого.
Вот, ну и здесь вот так получается там, допустим.
Ну вот.
Вот.
А, ну и вот так.
И это называется long-dispase decomposition.
Чем приятен этот long-dispase decomposition?
Он приятен тем, что его можно построить за линию.
Вот.
Ну, можно построить за линию и, в принципе, ровно теми же способами искать сумму на отрезке.
Остается нам только самое интересное.
Если я иду от какой-нибудь вершины до корня, сколько различных путей я встречу?
Ну и что то же самое, сколько некрасных ребер я встречу?
Ну да.
То есть оказывается, что количество вот этих вот некрасных ребер, их оказывается не более чем.
То есть на пути от вершины до корня.
Черных ребер не более чем...
Ну сколько там?
Ладно, напишу так.
Корень из 2n.
Почему именно из 2n?
А вот почему.
Смотрите.
Нет, ну смотрите.
Дело в том, что когда вы пройдете по черному ребру, если у вас тут было написано число x, то тут будет написано число хотя бы x плюс 1.
Правильно?
Это смешной факт, да?
Нет, это не смешной факт.
Сейчас смотрите.
Но фишка такая.
Заметим, что раз тут написано хотя бы x плюс 1, это значит, что тут можно ответвиться, пойти в другое место ответвиться и пойти на прям глубину x плюс 1.
Логично, да?
Вот.
Значит тут мы еще тут прогулялись.
Значит и опять черный ребер.
Значит тут у нас получается больше либо равно, чем x плюс 2.
И это значит, это дает нам еще x плюс 2 вершины.
Ну и так далее.
То есть получается, если мы встретили k таких ребер, то тогда получается, у нас вот эти глубины, получается, бывают хотя бы, то мы встретим числа, получается, какие.
Ну мы встретим хотя бы 0.
То есть числа, значит, больше либо равно 1, больше либо равно 2 и так далее, больше либо равно k в конце.
И это будет соответствует тому, что у нас реально есть, получается, независимая хотя бы одна вершина здесь, хотя бы две вершины, ну потому что считая исходную здесь, хотя бы 3 тут и так далее, хотя бы k плюс 1.
Но тогда получается n вынуждено быть больше либо равно, чем 1 плюс 2 плюс и так далее, плюс k плюс 1.
Это равно там k плюс 1 на k плюс 2 пополам.
Ну вот.
Ну отсюда собственно и следует, что k меньше либо равно, ну я тогда простоты напишу, корень из 2n.
Могу еще минус 1 написать, но не хочу.
Вот.
Ну вот такая стандартная корневушная логика.
Ну вот.
Ну в принципе уже неплохо.
Зато предподсчет за линию.
Да, операция теперь за корень, но зато и это за линию.
Ничего страшного.
Вот, понятно, да?
Как теперь задачка?
Как превратить?
Значит, как теперь превратить?
Значит, теперь задача следующая.
Мы получили n предподсчета и корень из n на запрос.
Как теперь хочется сохранить n, но сделать так, чтобы теперь запросы делались все-таки за логарифом?
Это слючайте другую декомпозицию.
Опять?
Нет, не опять.
Потому что на этот раз эта декомпозиция не будет декомпозицией.
Но называется она декомпозиция.
Предыдущая декомпозиция строилась за n, но запросы за 2 корень.
За корень, да.
А теперь вас приветствует лестничная декомпозиция.
Значит, она нам говорит следующее.
Так, у нас тут есть какие-то пути, да?
Вот давайте я тут даже для красоты еще тут нарисую кое-что красивое.
Вот, значит, смотрите.
Значит, идея теперь такая.
Я же могу за линию вот эту декомпозицию построить, да?
А давайте я тебе потрачу времени.
Слушайте, это же симптомика.
Я же могу потратить времени n.
Могу хранить в декомпозиции не n вершин, а 2n.
Могу?
Могу.
И я это сделаю.
Знаете как?
Я возьму путь, и к каждому пути еще добавлю сверху столько же вершин.
То есть если у меня, например, путь длины 2, например, да,
то я добавлю к нему еще две вершины сверху.
Ну вот, если путь 1, 2, 3, 4, 5, то я добавлю еще 5 вершин сверху.
Ну или сколько там получится, если я там случайно до корня дойду.
Это модификация long и start.
Да, по факту да.
То есть заметим, что это, формально говоря, это не черта, не декомпозиция,
потому что одна вершина может оказаться, собственно, в сколько угодно там путей,
может через нее проходить, короче.
Вот.
Но так все равно.
Но это все равно линия.
Понимаете, да?
То есть все равно можно построить за линию.
Но заметим, что теперь подыматься от вершины до корня,
ну, то есть нам обычно нужно разбить путь от вершины до корня
на какое-то количество путей, каждый из которых является подотреском чего-то в ледер декомпозиции, правда?
И чит очень простой.
То, что идея такая.
Вот жила была вершина, и у нее это максимальная глубина потомка х, да?
Тогда у меня идея такая.
Я, значит, от этой вершины иду, естественно, до конца красного пути, то есть лонгест паса, да?
Понимаете, да?
А потом, после этого, я иду еще в этом довеске, который в ледере возник.
Понимаете, да?
Да.
Вот.
Но он не весь, можно сказать, какой его префикс, например, да?
Ну, так понятно, что это ж тоже как бы префикс ледера, правда?
Да.
Вот.
Это супикс.
Ну, префикс мы же сверху вниз считаем, поэтому префикс.
Но могло же быть такое, что нам надо еще дальше пройти?
Могло быть.
Могло быть, но...
А могло быть, что оно и не пошло?
Нет, смотрите, могло быть.
Ну вот.
И здесь мы тоже тогда обнаруживаем, что тут какой-то красный путь.
Может быть, кстати, даже как-то вот так идущий, кстати.
Но ничего страшного.
Мы идем по огрызку этого красного пути.
Ну вот.
И продолжаем по его же, по сгенерированному им же зелененькому.
Да.
Так можно идти, может быть, идти много-много раз.
Но я утверждаю, что много-много – это логорифом.
И причина очень проста.
Дело в том, что если максимальная глубина вот этой вершины x,
то максимальная глубина вот этой вершины, очевидно, больше либо равна x.
Правда?
Вот.
Но я вам даже больше скажу.
Максимальная глубина вот этой вершины больше либо равна, чем 2x.
Ну потому что, если я из этой могу пойти на глубину x,
то я из этой могу пойти на глубину там…
Ну потому что, смотрите.
Потому что, заметим следующее, что длина вот этой части,
она, очевидно, больше, ну вот, она больше либо равна x.
Почему?
Потому что, заметим, что если у вершины глубина x,
это означает, что у нее вот этот красный путь
идет прям куда-то до листа, и у него тут прям вот длина реальной x.
А что мы поддерживаем в этих красных путях?
Ничего не поддерживаем.
А, ну поддерживаем.
Ну то же самое, что это там всякие суммы на подотреске.
Дерево отрезков строим, вот это все.
Тогда у нас за прошлый день в позиции были закоординированные логотипы.
А, ну в этом смысле да. Хорошо.
А, ну с другой стороны, нет, можно было так,
но с другой стороны, с точки зрения этой задачи,
на самом деле нам достаточно было хранить только массив точек,
и, в общем-то, все завод единицы там было бы.
Нет, зачем?
Нет, мы сейчас, например, мы решаем задачу level necessities queries вообще, да?
То есть, в которой все, что нам надо, это дана вершина, я хочу подняться.
Но если я могу подняться в рамках одному пути, я это делаю завод единицы.
Тупо храню все вершины в массиве.
И для каждой вершины храню, где она в этом массиве конкретно находится.
В общем-то, все.
В общем-то, все.
То есть, если я нахожусь там в 179-й клетке и хочу подняться на 57.
Так, ну, наверное, мне надо в этом массиве подняться,
пойти в клетку номер 122. Все.
Вот.
Но тогда, если тут х, то тут, соответственно,
то есть мы, когда поднимаемся по ladder decomposition,
мы просто поднимаемся уже сразу за один шаг на высоту хотя бы 2х.
Ну, кто 63? Еще раз.
Потому что этот путь, красный, в начало которого мы поднялись,
он длины как минимум х, правда?
Значит, мы к нему пририсовали еще х вершин зеленых.
Получается, вот тебе глубина 2х.
Вот.
Ну вот, теперь берем этот путь и, значит, повторяем операцию.
А вот тут уже хотя бы 2х есть, поэтому там мы тоже на 2х поднимемся.
Получается логарифом.
Вот, понятна логика, да?
Так, и, наконец, финалочка теперь.
Нет, стало богу, больше декомпозиционов не будет.
Бинапу из листьев делать?
Чего?
Бинапу из листьев посчитать?
Нет. Нет, бинапу из листьев мы будем считать,
когда у нас будет метр четырех русских.
А пока, если мы просто хотим достичь 7.nlog n1,
значит, мы сделаем для дерева две вещи.
Во-первых, мы насчитаем ladder decomposition,
а во-вторых, мы насчитаем бинарные подъемы.
Но пока для простоты все.
Вот, понятно, да?
Так, и тогда идея будет очень простая.
Жила была вершина В, мы хотим из нее подняться на высоту H.
Так вот, давайте, допустим, если это H, а давайте поднимемся...
Смотрите, чего?
Где я запутался?
Нет, там запутался, окей.
Ну вот, значит, давайте поднимемся на максимальную степень двойки из вершины В,
которая не превосходит H.
Ну, мы можем заранее для всех чисел от одного до N такую степень предпочитать.
В общем-то, в спортсах вы обычно этим занимаетесь, правда?
H это высота, на которую мы хотим...
Да.
А мы возьмем максимальную степень двойки, которую не превосходит.
Почему там больше либо равно х плюс один?
Ну, потому что у нас есть х,
там больше либо равно х плюс один.
Ну, потому что подняли...
Одному либо перешли, да?
Ну, если по одному, то будет х плюс один.
Хотя бы х плюс один.
Если по двум, то х плюс два.
Нет, ну, могло так случиться, что уже здесь прямо заканчивается красный путь,
но здесь все равно будет 2х.
То есть, по факту, да.
По факту, да, мы этим...
Достаточно вот так написать.
Потому что зеленая штука увеличит наш путь.
Ну, да.
То есть, если у нас тут глубина х, то зеленая штука должна на х увеличивать.
Но на самом деле мы дойдем сюда,
тут глубина будет еще больше, поэтому она увеличит еще на больше.
Вот так.
Там будет вершина, которая обозначена х, да?
А после нее идет синяя ребра, да?
На черная ребра.
Это не тот же путь, да?
А, где? Вот здесь?
Нет, в нижней вершине х.
Здесь? Ну, почему нет?
Это вполне красная, все нормально.
Ну, ее родитель черная ребра.
Ну, почему? Ну, может черная, но вообще может и красная, как повезет.
Мы для каждого пути считаем.
Вы такую зеленую штуку доехали для каждого красного пути.
Да.
Но мы как бы поднимаемся в начало этого пути.
В середину пути начали зеленую штуку вести.
Ну, потому что зеленый...
Потому что по факту зеленый путь, он покрывает как бы формально все.
Вот такое он на самом деле.
То есть, он как бы наш путь и еще столько же сверху.
Вот, понятно, да?
Да, да, да.
Так вот.
Теперь.
Значит, возвращаемся.
Значит, с помощью двойечных подъемов мы за от единицы можем подняться на высоту хотя бы половину h.
Согласны?
Вот.
Ну, просто степень двойки правильную возьмем.
Там мы заранее предпочитаем для всех чисел от 1 до n.
Но теперь идея такая.
Теперь нам надо подняться на высоту вот эту вот.
Вот у нас тут осталось вот это вот допустим h'.
Понимаете, да?
Надо на нее из этой вершины подняться.
Но теперь заметим, что длина вот этого пути она больше.
Даже можно сказать строго больше, чем h'.
Но тогда это означает, что у этого поддерева этой вершины глубина хотя бы h'.
И это означает, что с помощью ladder decomposition мы из нее поднимемся тупо за от единицы.
Все.
Значит, еще раз.
Значит, фишка.
Насчитаем ladder decomposition, насчитаем двоичные подъемы.
Теперь надо подняться из вершины v на высоту h.
За от единицы мы поднимаемся на максимальную степень двойки, не происходящую h.
Теперь мы получили новую вершину v', из которой надо подняться на высоту h'.
И h' строго меньше, чем 2 в степени l.
Но теперь утверждение.
Из этой вершины на эту высоту я могу подняться за от единицы в ladder decomposition.
Потому что глубина пути уже...
Да, потому что глубина этой вершины, ну глубина красного пути у нее, он конечно не обязательно сюда идет, может куда угодно, но глубина его хотя бы вот эти 2 в степени l уж точно будет.
То есть хотя бы h'.
То есть минимум h3.
Все.
И получается вот такая вот красивая штука, что получается теперь...
Да, предподсчет все еще n log n.
На самом деле все еще n log n, но за от единицы.
Но на самом деле отметим, что если у вас в дереве листьев не сильно много, то это может легко стать и o от n и o от единицы.
Ну потому что, да, то есть первая идея, которая там возникает, то что давайте считать двоичные подъемы, там скажем, не для всех вершин, а только для листьев.
Ну как считать для листьев, только для листьев двоичные подъемы, не пересчитывая для остальных.
Очень просто, давайте скажем запустим, прости господи, DFS.
И каждый раз, когда вершина появляется, мы ее добавляем в стек, когда выходим в DFS, мы ее из стека удаляем.
Тогда, когда мы приходим в лист, то у нас прям полный путь у нас в стеке хранится, и в принципе мы там подняться на 1, 2, 4, 8 и так далее можем без труда, правда?
Ну вот, поэтому там возникает такая идея, там первая идея будет, что вот таким тупым, то есть там, но идея будет такая, что зачем нам подниматься из произвольной вершины на высоту h?
А давайте вместо этого из вершины v спустимся до какого-нибудь ее листа в поддереве и с греблом подниматься на большую высоту.
Ну для каждой вершины просто сохраним какой-нибудь лист у нее в поддереве.
Ну мы просто когда, в предподсчете мы DFS запустили, и для каждого, когда мы пришли в лист, у нас как бы есть как бы векторы с всего пути откормлены до нее.
Ну вот, ну и все.
Это уже без учета того, что у нас вообще-то там всякие лонгест-пессы вот эти есть, а нет, они не помогут все равно.
Ну то есть с помощью, на самом деле с помощью ladder decomposition, а кстати из любой вершины, можно спокойно за логарифом насчитать все ее LCA, вот ровно этим же способом.
Нет, потому что нет, это будет не за n log n, это будет log n умножить на количество листов.
Поэтому если листов меньше чем, не больше чем n поделить на log n, то это уже чемпионский алгоритм.
А вот если листов чуть больше, тогда...
Но об этом мы поговорим в следующий раз.
Пока да.
Но как бы я так проанонсировал, куда можно думать и куда применять метод четырех русских, чтобы тут все-таки стало OADN.
Но об этом веселом мясе мы поговорим в следующий раз.
Ну а сейчас пожалуй на сегодня все.
