Тема сегодняшнего занятия это файловые системы, которые могут быть реализованы как модуль ядра, так и в польском пространстве.
Давайте вспомним, что такое ядро. Ядро это такая программка, самая обычная программка, которая загружается бутлодером.
Бутлодер передает ей управление. При этом процессор находится в привилегированном режиме.
Можно вытворять все что угодно. Это вы все знаете с прошлого семестра.
Ядра можно классифицировать по тому, насколько они могут дробиться на разные части.
Классические монолитные ядра это такие ядра, которые занимают непрерывное пространство в памяти и реализуют практически всю свою функциональность.
Работает естественно все в адресном пространстве ядра с повышенными привилегиями процесса.
Бывает противоположная ситуация. Это микроядра, когда ядро это какая-то очень маленькая программа.
Единственная задача которой это координация между собой различных подсистем.
Разные подсистемы в свою очередь работают в польском пространстве. Это надежнее.
Если у вас что-то сломается, то можно будет перезапустить. Все ядро при этом у вас не сломается.
Более современный подход это все-таки использовать что-то гибридное.
В чем недостаток микроядерной архитектуры?
У вас очень большой оверхед на взаимодействии между собой отдельных подсистем ядра.
Это естественно приводит к снижению производительности.
Поэтому в большинстве современных систем Linux, MacOS, VDA все ядра это так называемые гибридные ядра.
Есть основная часть программы, которая запускается всегда работать в адресном пространстве процесса.
Она расширяется с помощью загружаемых модулей, которые в том числе могут быть выгружены, если они не используются.
Такие модули называются модуль ядра. В Windows еще называются драйверы.
О том, где находится ядро, что он из себя представляет.
В любой Linux-системе есть в корне каталог BOOT.
Что в этом каталоге интересного, полезного содержится?
Давайте посмотрим, что тут интересного у нас есть.
Синий цвет ужасный.
Ладно, тогда просто ls.
Что у нас есть? Во-первых, у вас в системе может быть несколько ядер.
Совершенно не обязательно все ядра у вас используются.
Обычно загружается какое-то одно ядро с помощью команды uname-a либо uname-r.
Можно узнать точную версию, какое ядро сейчас в данный момент запущено.
С каждым ядром у нас связаны некоторые файлы.
Во-первых, файл под названием vmlinux-version,
который получается с помощью uname-r.
Что это такое?
Почему linux, а не linux?
Казалось бы, система linux называется в названии буква z конце.
Буква z конце означает, что файл зажат с помощью zlib-компрессии
просто для того, чтобы быстрее загружался буклудр.
Загрузчик загружает наш файл и распаковывает его уже в память.
Что из себя представляет этот файл vmlinux?
Это самый обычный исполняемый файл.
Как вы думаете, в каком формате?
Elf, exe, что-то бинарное, просто две структуры.
Логично предположить, что это Elf-файл, как и принято в Unix-системах.
Но на самом деле нет.
В большинстве новых Unix-систем это файл, который начинается со строчек m, z.
Встречали такое в бинарных файлах?
Это признак того, что файл является обычным portable-exe-table файлом
от компании Microsoft.
Такой формат.
Удивительно, да?
Почему так сделано?
Потому что в современных системах используется загрузчик EFI,
Extensible Farmware Interface.
В чем особенность загрузчика?
В том, что он позволяет некоторые свои части хранить не на диске,
а в железе, то есть на замену классическому биосу.
При разработке этого стандарта какое-то участие принимала компания Microsoft.
Было стандартизировано, что исполняемый модуль, который может запускать загрузчик EFI,
это исполняемые файлы, которые понимаются системой Windows.
На самом деле, для загрузчика, например, Grab это не имеет никакого значения,
потому что при загрузке загружается некоторый файл бинарный,
размещается где-то в памяти,
затем ищется некоторая магическая последовательность в стиле файла.
Это последовательность, сразу после которой находится точка входа.
То есть никакие заголовки и ядра нам совершенно не интересны.
Поэтому не важно Elf-файл либо PartTable, Executate.
Что еще тут интересного есть?
Есть файл под названием config.
Есть еще файлы без номеров версии.
Это просто символические ссылки на текущую используемую версию.
Итак, config – это текстовый файл огромный.
Фактически то, с какими опциями ядро было скомпилировано.
Что еще интересного?
Файл initrd – это бинарный файл, поэтому отображать его не буду в терминале.
Это начальный образ системы.
То есть когда у вас запускается ядро, ему нужна некоторая файловая система,
чтобы забудь страйпить.
Какие-то самые базовые модули ядра, возможно конфиги.
И образ такой файловой системы хранится в файле initrd.img.
Он является корнем файловой системы до того, как ядро не найдет все диски
и не примет решения о том, какая файловая система у нас потом станет корнем.
Еще есть файл system.map – это обычный текстовый файл.
В разных дистрибутивах, опять же, может быть, разная реализация.
В случае с debian, просто отсылка, что можно поставить дополнительный пакет
размером 700 мегабайт, в котором будет требована информация.
System map – это по сути отображение таблицы символов ядра.
В ядре есть какие-то функции, в том числе публично доступные.
У публично доступных функций есть определенные адреса.
И информация об этом хранится в текстом файле system.map.
Для чего он нужен? Обычно только для дебага
либо для детального отображения в лог-файлах.
Есть еще подкаталог EFI и Grab. Они относятся к загрузчикам.
Помимо самого ядра есть еще отдельные модули.
От модулей это уже ELF-файлы.
Обычные библиотечки, ну, точнее, почти обычные библиотечки, немножко отличаются.
Которые обычно находятся в каталогах slashlib-modules.
Там есть куча подкаталогов, то есть все модули ядра, они имеют какую-то иерархию, структуру,
разложенные по разным подсистемам.
И вот эти модули ядра загружаются уже после того, как система загружена.
И что это за модули, когда они загружаются?
Они могут быть загружены либо вручную, либо самим ядром
после выполнения операции опроса оборудования.
То есть у нас есть какой-то дистрибутив, есть какая-то система,
которая может быть установлена на самом разном железе.
Неважно какая у вас видеокарта, неважно какой у вас чипсет.
Если он позволяет запустить Linux, то при необходимости у вас могут для разных компонентов
загружаться отдельные модули.
И это обычно происходит при загрузке системы.
Но в том числе у вас какие-то модули системы могут быть загружены вручную.
Например, модули, которые никак не связаны с железом.
В частности, у вас могут быть какие-то дополнительные файловые системы
или какие-то дополнительные модули безопасности.
При этом модулей могут быть какие-то зависимости.
Давайте, например, посмотрим.
Смотреть можно все командой по названию lsmod.
Права рута для этого не требуется.
Что интересно, он отображает.
Во-первых, список всех загруженных модулей.
У каждого модуля может быть какой-то размер.
Usage – это количество использования модулей какими-то другими.
И дальше причисляются, какие модули используют что-то одно.
Например, есть модуль с большим количеством зависимости под названием snd.
Это базовая поддержка звука вообще в принципе.
От него зависят модули snd, hd, codec, cd, hd, intel.
Это подсистема, которая относится к стандарту intel и hd high definition audio.
Практически большинство современных звуковых карт работают через codec intel high definition.
Есть какие-то файловые системы, например, x4,
которые в свою очередь зависят от каких-то других модулей,
например, вычисления контроля не суммы CRC16.
Можно с помощью команды insmod – не очень хорошо – modprobe
загрузить еще какой-нибудь модуль,
например, поддержку файлосистемы btrfs.
modprobe не найден, на самом деле не найден, потому что он находится в каталоге sbin
и требует права рута.
Что произошло, я не нажал моду «минус»,
поэтому переменная паса у меня не поменялась.
Теперь появилась btrfs.
Так, загружена файлосистема btrfs теперь.
Можно вгребнуть, где он находится.
Вот, модуль действительно загружен.
Если он нам не нужен, то мы можем сделать операцию rmmod,
которая выгружает определенный модуль,
но, кстати, совершенно не обязательно rmmod может какой-то модуль выгрузить.
Например, что хорошего или плохого произойдет,
если я попробую выгрузить модуль x4,
который является файлосистемой в данном случае моей машины для корневой файлосистемы.
Получаем ошибку.
Модуль x4 у нас используется, ничего хорошего здесь не произойдет.
Точнее, есть опция «минус f», которая заставляет
все-таки принудительно выгрузить какой-то модуль.
Если я наберу rmmod –f x4,
но мне придется перезагружать систему,
она станет, скажем так, не очень корректно работающей.
И даже в Help написано, что это опасно.
Можно сделать свои модули.
Что такое свой модуль?
Это просто обычный KO-файл,
который получается в компиляции из каких-то исходников.
Исходники можно писать обычно на языке C,
хотя сейчас можно уже и на Rust писать,
хотя это страшный язык.
Что такое модуль-ядра?
Это модуль, который реализует минимум две функции.
Одна из них называется init-модуль,
выполняется при его загрузке.
И clean-модуль, но, естественно, это при выгрузке модул.
Давайте сделаем простой модуль-ядра и его загрузим.
Итак, самый простой модуль-ядра выглядит в следующем образом.
У нас есть две функции.
Одна init, другая clean-up,
которые могут что-то делать, например, что-то выводить.
Обратите внимание, никакого принфа, никакого путса,
никакой работы с файлами.
Для модули-ядра про стандартную IC-библиотеку можно забыть в принципе.
Ее нет.
И вообще говоря, ядро не обязано зависеть ни от каких библиотек.
Поэтому используется только внутренний API,
внутренние функции ядра.
Для компиляции этого безобразия я сделал отдельный подкаталог,
в котором все те же самые файлы являются просто символическими ссылками на уровень выше,
потому что при сборке сейчас будет генерироваться огромное количество бусера.
А как это все собрать?
Собирается нетривиальным образом.
А именно, для сборки модуля-ядра нам требуются исходники-ядра
либо даже не обязательно исходники.
Так называемый пакет для разработки ядра,
заголовочные файлы плюс необходимый makefile.
Если вы когда-нибудь вставили какие-нибудь праприетарные драйвера,
например видеокарту Nvidia,
либо если у вас система устанавливается в виртуалку, в виртуалбокс, либо параллелс,
то скорее всего для установки вам требовались как раз заголовочные файлы ядра,
которые находятся тоже в либ модуле,
но содержат дополнительно makefile и заголовочные файлы.
Поэтому команда make, которая выполняет инструкции из makefile
где-то в потрохах ядра,
может собрать дополнительные модули.
Обратите внимание на огромное количество мусора,
которое у нас теперь появилось.
И вот файл, который называется hello.co,
как раз является вновь созданным модулем.
Напомню, что этот модуль должен нам просто говорить о том,
что он загружен либо выгружен.
Так, ладно, команда modprop нам ничего не найдет,
потому что наш модуль не лежит где-то в стандартном месте,
но мы можем и воспользоваться командой insmod,
которая в отличие от modprop принимает имя файла, а не имя модуля.
И если modprop загружает модули со всеми их зависимостими,
то insmod выполняет только загрузку файла,
либо ругается, если ваш модуль зависит еще от какого-то файла.
Вот, insmod hello.co.
А, я его уже загружал.
Все, модуль загружен, он что-то при этом даже сделал.
А как понять, что он что-то сделал?
Куда у нас что-то вывелось?
Вывелось в лог ядра.
Замечательная команда поможет вам,
если вы не понимаете, что с вашей системой происходит,
называется debugging messages.
Дебаггин messages тут говорит,
что у меня огромное количество сетевого взаимодействия по сетевой плате.
Firewall тут что-то вытворяет.
Ну и самое главное в самом конце.
Это предыдущие то, что я набрал remod,
и insmod привел к тому, что вывела строчка,
привет, нового модуля.
Так, что еще принципиального есть в модулях?
Обязательно внимание, что в тексте модуля есть какой-то macros модуль-лиценз.
Там еще написано что-то про JTL.
Давайте мы этот заголовок уберем.
Что делает macros?
Он просто создает новую секцию,
переменную с текстом JPL.
Давайте сделаем не JPL,
а migrate to use only in Russia.
Так, все. Никакие буржуи теперь не имеют права
использовать мой великий модуль.
Перекомпилируем.
Ремод.
Загружаем заново.
Все хорошо, все замечательно.
Модуль честно загрузился.
Если он реализует функциональность,
то эта функциональность становится доступной.
Но при этом система считается компрометированной
и ненадежной.
Как об этом узнать?
Как об этом узнать?
Есть Proc sys kernel taint,
который содержит какое-то число.
Число представляет собой битовую маску,
хоть отображается в дистичном виде,
где каждый бит отвечает за причину того,
почему наше ядро стало ненадежным,
потенциально компрометированным.
Проверяя значение этого файла,
этот файл доступен на чтении,
в том числе и обычному пользователю,
не обязательно руту.
Можно принять решение о том,
можно ли запускать на данной машине,
на этом конкретном ядре, что-то,
что содержит, например, государственную тайну
или какой-нибудь интеллект.
В данном случае я бы не стал,
потому что значение не ноль.
И значит, что потенциально мое ядро
может вытворять что-то плохое.
Почему мое ядро может выполнить что-то плохое?
Одна из причин связана с тем,
что я загрузил какой-то странный модуль,
лицензия которого не позволяет
и причин. Могут быть самые разные причины.
В частности, например,
если мы модуль загрузили
из какого-то непонятного источника,
то есть в обычных линейных дистрибутивах
есть стандартные каталоги,
где у вас лежат все модуль.
Если вы загружаете модуль
вне дерева этого каталога,
то, наверное, ему не стоит доверять.
Кроме того, ядро может быть считаться скомпрометированным
не только из-за какого-то модуля,
но в том числе, если возникла какая-то ошибочная ситуация,
в том числе из модуля ядра,
который уходит в штатную поставку.
Ядро при этом может не обязательно грохнуться,
но если возник какой-то инцидент,
то ядро, тем не менее, потенциально считается уже уязвимым.
Опять же, операция форсирования выгрузки
какого-то модуля,
RMod с опцией "-f",
даже если не приведет к падению вашей системы,
все равно приводит ядро
в какое-то не совсем корректное состояние
и потенциально уязвимо.
В модулях можно еще добавлять какие-то параметры
для чего это бывает полезно.
Бывает полезно, если вам нужно
в зависимости от разного типа железа
выполнять какую-то тонкую настройку.
Обычно это используется, например,
для модулей Wi-Fi,
которые могут быть,
может быть, один модуль
на много разных сетевых плат
с разными,
с одинаковым семейством чипов
одного производителя,
но при этом отличаться
каким-нибудь тонким настройкам, например, регион,
в который эта Wi-Fi-плата используется,
либо включить, выключить какие-то
дополнительные опции, например, энергосбережение.
В некоторых ноутбуках, если у вас Wi-Fi
с этим настройками, Wi-Fi начинает работать.
Ну и что делает какой-нибудь модуль,
когда вы его загрузили?
После того, как вы загрузили какой-то модуль,
он реализует какие-то функции,
и эти функции становятся доступны для использования
либо другими модулями, либо напрямую.
Но напрямую обычно для модуля это редко используется,
а в большинстве модулей это реализовать
какой-то программный интерфейс.
Посмотреть на список всех
доступных символов текущего ядра
можно с помощью AllSims.
Вот у нас огромное количество символов.
Что здесь полезного есть?
Ух, я давно не перезагружал систему,
когда у нас была лекция по BPF?
Да, в общем, с тех пор я компьютер не перезагружал,
у меня до сих пор валяются какие-то родименты
сгенерированных BPF программ.
Что полезного здесь можно увидеть?
Можно гребнуть что-то, что начинается
с двух подчеркиваний имени и архитектуры.
В данном случае это ARM64.
Дальше префикс sys подчеркивания.
Вот такие названия вам ни о чем не говорят.
sys-accept, sys-list,
sys-link, sys-encoder, sys-pipe.
Это все реализации
отдельных системных звуков.
Причем в старых ядрах Linux
они просто начинались с префикса sys подчеркивания.
В более современных они еще имеют
такое страшное название с префиксом
в настоящем из названия архитектуры.
Даже реализация системных вызовов
это самые обычные функции.
Если вы пишете модуль, который должен делать
какие-то системные вызовы, то не обязательно
выполнять инструкцию системных вызовов,
можно просто дергать определенные инструкции.
Здесь есть определенные тонкости, что разные
системные вызовы могут подразумевать копирование
поэтому из ядра такие функции
все-таки опасны.
Что вы можете использовать, если вдруг захочете
написать свой модуль ядра?
Забудьте опять же про стандартную сеть библиотеку.
Есть API ядра,
который имеет свойство
периодически меняться, но плюс-минус
Там есть самые стандартные наборы
всех возможных функций,
базовая операция над строками,
всякие конвертации строк.
Что касается памяти, то здесь надо понимать, что у ядра
нет такого понятия как куча.
У ядра есть только стэк,
для каждого процесса тоже существует свой отдельный
стэк в адресном пространстве ядра.
Если вы хотите выделять какую-то память в физическую,
то приходится использовать более низко уровень инструменты,
которые называются K-malloc, K-free.
Но это все-таки не куча в том понимании,
как вы привыкли для стандартной сеть библиотеки.
Когда вы работаете с памятью,
то всегда надо помнить о том,
что память у вас в общих случаях делится
на два непресекающихся участка.
Память у ядра с которой вы работаете напрямую,
и память у пользователей,
в которой ядро может залезть.
Но делать надо это очень аккуратно.
Системные вызовы.
Это у нас какие-то функции.
Этим функциям соответствуют
определенные номера, которые вы вызываете
через инструкцию C-center,
либо инструкцию Syscall,
либо если ARM SVC,
что еще можно использовать?
Под XSense можно использовать инструкцию INT,
старую классическую.
Что происходит, когда вы выполняете
инструкцию процессора для выполнения системного вызова?
Просматривается таблица функций,
самая обычная таблица функций,
где в таблице по номерам
определенным индексом соответствуют
указатели на нужные функции ядра,
и вызываются дальше уже эти функции.
Если у нас эта таблица как-то публично доступна,
то какой-нибудь модуль может взять
и что-нибудь перезаписать.
Например, захотите сделать свою реализацию
системного вызова, который открывает какой-нибудь файл.
Эта нужная реализация вам может
проверять, что файл является файлом с паролем,
при необходимости может сливать еще куда-нибудь
информацию.
В общем, достаточно опасная возможность,
если вы можете менять что-то в таблице символов.
И в современных версиях ядра
эту штуку можно отключить.
То есть сделать так, чтобы таблица
на нужных вызовах была недоступна в том числе
из модуля ядра. В данном случае вы просто не сможете
скомпилировать те модули ядра, которые
полагаются на ее использование.
Это обычно массив C-SkullTable.
В современных версиях ядра Linux есть функция,
которая ищет
нужные функции по номерам.
Называется keyAllSimsLookUpName.
Вот в дебе они есть.
На самом деле не в каждой
бестрибутиве это может быть.
Это опция компиляции ядра.
В OpenSUSE такого вы точно не найдете.
Там просто не пользуются такими штуками.
Это просто повышение безопасности.
Зачем вам нужно менять
таблицу ядра?
Зачем вам нужно
подменять какие-то системные вызовы?
Наверное, это опасно. Так делать нехорошо.
Для чего нужны разные модули ядра?
Во-первых, это могут быть
драйверами, которые обслуживают
конкретные устройства.
В поставке ядра Linux есть модули,
90% всего железа,
в том числе такого железа,
который вы уже никогда не найдете.
Большая проблема в плане ядра Linux.
Если нужно что-то кардионально
менять в ядре, в базовой части,
то очень часто всякие
legacy модули
это самое сложное, что приходится портировать.
Хотя периодически проводится чистка.
Кроме устройств, есть еще
другие подсистемы, в частности,
различные файловые системы.
Файловые системы бывают разных типов,
которые разрабатывались с прицелом под разные цели,
под разные операционные системы.
В Linux родной файловой системой
является семейство X2, 3, 4 и так далее.
X2, X3, X4 это просто разные версии
одной и той же файловой системы.
Более современные модули, например,
X4, они поддерживают обратную совместимость
с более ранними.
Поскольку эта файловая система является родной для Linux,
то это единственное исключение, что не является модулем.
X4 обычно вкомпилирован
прямо в само ядро системы.
Когда вы загружаете ядро,
скармливаете ему начальный образ,
начальный образ тоже находится
это просто файл X4,
но только загруженная загрузчиком.
При этом вы можете дополнительно подгружать
еще какие-то файловые системы,
например, XFS, BTRFS, которые я напрямую
с мощью Modprobe подгрузил.
Бывают разные файловые системы.
Во-первых, нам могут понадобиться разные файловые системы,
если вы хотите получить
какую-то дополнительную функциональность
даже в рамках Linux-системы.
Например, BTRFS в некоторых дистрибутивах
ее включают по умолчанию, хотя
она пока еще не считается достаточно стабильной,
позволяет, например, делать версионирование.
Система, которая изначально была разработана
компанией Silicon Graphics еще в бородатые годы прошлого века,
очень хорошо работала эффективно
с файловыми большого размера.
Затем последствия файловой системы были опубликованы
под лицензию DGPL, поэтому включена в состав Linux.
Тоже часто можно встретить ее и использовать.
Ну и кроме родных для Unix-систем,
которые поддерживают
все необходимые атрибуты, то есть iNode,
Unix атрибуты файлов,
бывают еще неродные файловые системы,
например, файловые системы,
которые пришли к нам из системы Windows,
для чего они могут быть полезны?
Наверное, для того, чтобы можно было обращаться к другим разделам,
если у вас параллельно стоит Windows и Linux на одной машине,
либо если вы втыкаете флешку
на машине, которая не предназначена для использования Linux.
Для этого используются отдельные модули ядра,
в частности, модуль для FAT,
модуль для NTFS,
который самый распространенный файл системы под Windows.
На самом деле, то, что входит в поставку Linux,
вот именно название NTFS, это на самом деле очень устаревший модуль,
который позволяет монтировать файлы системы
только на 4.
Используется более современный модуль,
который реализован немножко по-другому.
В чем недостаток
все-таки файловых систем,
которые не являются родными для Linux?
Вы можете потерять
часть метаинформации.
Например, если у вас файл система FAT,
которая исходно была разработана для DOS,
а потом адаптирована для Windows,
там появилась поддержка для других имен.
Казалось бы, файловая система и файловая система.
Что в ней плохого?
Плохого то, что там не сохраняются атрибуты файлов.
То есть вы никогда не узнаете настоящие права
чтения, запись, выполнения.
И кроме того, там вы не сможете сохранить информацию
о том, кто является владельцем файлов.
Так и того, что файловая система не была предназначена для UNIX.
Что?
Про журнал.
В NTFS есть журнал,
но NTFS тоже не родная файловая система,
хотя там есть такое понятие,
как Access Control Rights в Windows,
но это все-таки не UNIX-овые права,
и информация про UNIX-овые атрибуты все-таки будет потеряна.
Кроме файловых систем, которые предназначены
для дисков, есть еще сетевые файловые системы.
В ядре реализована только поддержка
классической UNIX-овой файлы системы NFS,
достаточно быстро работающей.
Когда-то давно в состав ядра Linux еще входила
поддержка сети Microsoft Windows,
но уже это выпилено,
видимо, по соображению безопасности.
По крайней мере, в современных версиях ядра
это трудно найти.
И бывают еще виртуальные файловые системы,
которые не связаны вообще ни с какими ресурсами
и предназначены для того, чтобы создавать
свою структуру по мере обращения
из каких-то динамических данных.
Например, файл-стем Procfs,
который я вам много раз уже показывал,
который содержит информацию о процессе.
Или файл-стема tmp-afs,
это просто хранилище в памяти,
которое исчезает после того, как файл-стему
отмонтируете, то есть какая-то помойка временных файлов.
Еще есть интересная файл-стема,
которая называется overlay-fs,
которая позволяет создавать файловую систему
из разных частей просто наложением одного
Операция подключения какой-то файловой системы
называется монтирование.
Есть команда mount.
Если запустить ее без параметров,
в Linux вы получаете огромный список,
где каждая строчка — это отдельная файл-стема.
Если вы тоже самое запустите под BSD-систему
или под Mac, этот список будет короче.
Без параметров вы команду mount
может вызвать в том числе из-под обычного пользы,
не обязательно быть root,
она отображает на отдельной строчке тип файловой системы,
какой части нашей реальной виртуальной файловой системы.
Например, в slash-sys подключена эта файловая система,
и для некоторых файловых систем,
которые связаны с диском,
могут быть определены конкретные устройства.
Конкретные устройства — это либо
что-то в подкаталоге dev,
либо уникальные идентификаторы,
которые определяются на основании разбиения дисков.
Ну и какие-то опции, с которыми файловая система подключена.
Mount с параметрами позволяет
подмонтировать новую операционную систему,
новую файловую систему,
но, естественно, для этого уже требуется
либо повышение привилегий,
если вы хотите, чтобы содержимый файловая система
была доступна всем,
либо использовать механизм Linux namespaces,
предварительно сделать новый namespace
для точек монтирования,
и в данном случае у вас видимость файловой системы
будет только для того процесса,
который находится в этом пространстве,
но и его дочерних процессов.
По граммам монтирования
у вас к файловой системе присваивается
некоторое число 300-убитное,
которое на самом деле стоит из двух частей.
Major – это уникальный идентификатор
вашей файловой системы,
то есть это тип файловой системы,
и Minor – это порядковый номер файловой системы,
который у вас был подмонтирован.
Помните, как однозначно определяется
какой-то файл в нашей виртуальной файловой системе.
Это пара чисел.
Номер устройства,
тот, который разбивается на две части,
из 24-убит и 8-бит.
Второе число – это порядковый номер файлов
в пределах одной файловой системы.
У вас может быть какой-то физический диск,
это уникальная уникальная файловая система,
что хранится в этой файловой системе.
Там хранятся так называемые айноды,
уникальные целые числа.
Например, если у меня есть какой-то файл,
этот айнод можно узнать в выводе команды start.
Он является уникальным для каждого из файлов
в пределах одной физической файловой системы.
На него, естественно, может быть много ссылок.
Символические ссылки – это просто новые.
Это файлы специального типа,
которые являются…
В данном случае это символическая ссылка.
Можно сделать еще
жесткие ссылки.
Теперь айнод у нас сохранился.
Что?
Тут разницы никакой.
Hello2 тот же самый айнод имеет.
Жесткие ссылки – это по сути файлы,
которые имеют одинаковый айнод,
то есть имеют одинаковые содержимые,
одинаковые атрибуты, но просто дополнительное
имя в каком-то из каталогов.
Что будет, если я отключу этот диск
в другой компьютер?
Айнод у меня сохранится.
Но может потом не совпадать
вот это число, номер устройства.
Почему? Потому что
моя файловая система может быть
подключена как минимум не первой.
И вот пара чисел device и айнод
достаточно, чтобы найти любой
произвольный файл и не обязательно знать его.
Так, ну и файлы систем OverlayFS.
Что это такое?
Это штука, которая состоит из
частей, которая называется нижняя часть.
Это одна либо несколько,
один либо несколько каталогов,
которые определяют нашу файлосистему,
и при этом они не будут модифицированы.
И так называемый верхний слой –
это некоторый каталог,
который будет сохранять изменения,
которые вы внесли после изменения.
Плюс есть еще понятие рабочего каталога.
Это что-то временное, что используется
потрохами OverlayFS.
Тут проще показать на практике, зачем это
бывает нужно и как это использовать.
Так что словами рассказывать мне очень интересно.
Это контейнер.
И что в этом контейнере может быть?
Во-первых, у вас контейнеров может быть много,
и они могут наследовать одну и ту же систему.
Так, слово Docker вам должно быть знакомым.
Правильно? Что такое Docker?
Стрессоконтейнеризация.
Ладно, если вы писали Docker файлы,
вы импортировали первые строчки Docker файла,
писали, какую систему вы хотите наследовать.
Давайте сделаем имитацию Docker контейнеров
простой, не используя при этом Docker.
Для начала нам что нужно?
Нам нужен какой-то образ системы,
какой-нибудь минималистичный.
Как его получить?
Самый простой способ – заходим на сайт
скачиваем, распаковываем.
Ну, не самый интересный.
Можно еще сделать...
Есть такая команда DebutStrap.
Кстати, не обязательно слово Debian.
Есть Ubuntu,
и, кстати, в RPM-дистрибутивах тоже есть эта команда.
Просто она умеет
скачивать и распаковывать образы
только для Debian-подобных систем.
У Ubuntu либо SunDebian,
либо еще какие-то директики.
Единственное – недостаток от команды требует права root.
Но это требуется один раз.
Что?
Почему ему требуется DebutStrap?
Он создает правильные атрибуты файлов,
которые в том числе
принадлежат пользователю root.
Потому что вы в теории можете...
Там есть честная система,
в которой вы можете сделать root
без всяких...
И там будут все те же самые права,
тот же владелец root, а чтобы сделать владельцем
пользователю root, нужно права root.
Так позволяет делать образ AltLinux.
Не AltLinux, а AlpineLinux.
В AlpineLinux он все-таки достаточно ограниченный.
Там достаточно урезная система.
Как этой штукой пользоваться?
Первый аргумент – это
название дистрибутива. Второй – это
целевой каталог, куда нужно сделать новый образ.
Но еще желательно указывать зеркало,
чтобы оно устанавливалось быстрее.
FocalFos – последнее кодовое имя
Ubuntu LTS 2004.
А сейчас что там новое?
Это которое недавно вышло, да?
Не последнее, а предпоследнее.
Каталог куда установить?
Чтобы не тратить много времени на скачки,
я это запускаю на удаленном сервере,
который находится...
Селедтел.ру
Реклама не явная.
Вот он достаточно быстро скачает все файлы,
установит локальную систему в каталог.
В этом каталоге будет отдельная система,
но достаточно бесполезно.
Точнее, ей пользоваться можно.
Можно даже настроить APT,
сделать чрут.
Но зачем мы это делаем?
Пока оно ставится, тут же рядом.
Сделаем какое-нибудь приложение,
которое может иметь под каталоги
SRC с исходниками
и стандартный по иерархии USR BIM.
Приложение будет
очень полезным.
Называется Hello.
И делать очень важную вещь.
Что важное нужно сказать?
Привет, мир!
Кто сказал привет, мир?
Кто сказал привет, мир?
Компилируем поставку
нашего великого приложения.
Возможно, складываем какие-то ресурсы.
Вот у нас есть какая-то программа.
Если мы хотим эту программу запустить
с помощью контейнера,
запихать в какой-то образ,
запаковать,
и получаем что-то тяжелое.
Если у нас много программ,
которые наследуют один и тот же образ,
что мы можем сделать?
Что сделать?
Один образ – куча программ,
но не всегда это бывает осмысленно.
Программа должна быть только программой
и не лезть никуда лишним.
Давайте сделаем контейнер.
Иерархия каталогов USR BIM
должна накладываться на базовую систему.
И потом мы этот контейнер
можем запускать
после того, как мы завершили работу.
Причем запустить мы можем в нескольких экземплярах.
Логично, могут нескольких пользователей
запустить несколько экземпляров
из этого же контейнера.
Естественно, они должны находиться
в своем экземпляре и не мешать друг другу.
Давайте законтейнеризируем запуск этой штуки.
Что нам для этого понадобится?
В приложении у нас могут быть
какие-то данные, связанные с конкретным запуском.
Пусть будут в каталоге дейта.
Еще файлы стимуврилы FFS
требует временный каталог
для своих внутренних файлов.
В результате мы получим
новую корневую файловую систему
наложением нашего базу.
Поверх этого каталога есть
каталог с реализацией нашего приложения.
Теперь мы сделали новый каталог.
Что мы теперь можем сделать?
Мы теперь можем написать
такую огромную команду.
Команда будет длинная.
Маунд, дальше минус T.
По умолчанию
нужно указывать.
Маунд, если вы указываете
только один параметр,
то он смотрит файл ETC fstab
и ищет соответствие ETC fstab.
Можно указывать либо
mountpoint либо конкретное устройство.
Если указывать не меньше
двух аргументов, то это будет новая
точка монтировки.
Опция минус T означает указать тип
файловой системы.
Маунд, минус T.
Тип файл системы Overlay.
Устройство, которое мы хотим
подмонтировать.
В данном случае оно совпадает с именем
файловой системы.
Дальше начинается интересное.
Через опцию минус O
можно указать дополнительные
опции.
Для файловой системы указывается,
в какой кодировке работает,
какие права по умолчанию,
можно ли журналировать.
Нижний уровень, второй каталог, верхний
уровень и третий это каталог для временных
файлов.
LoverDir.
Это базовая система.
LoverDir может быть несколько разделят
с темом двоеточия.
Базовая система, поверх которой наложено приложение.
UpperDir.
Нашего контейнера, где будут храниться
пользовательские данные.
WorkDir.
Это временный каталог.
Там будет страшное содержимое.
Обязательные параметры для mount.
Это точка монтирования.
Я его создал в каталоге.
Получаем бабах.
Только пользователь root имеет право
что-то монтировать.
Не очень хорошо,
потому что вы же контейнеры,
даже docker-контейнеры запускаете из-под обычного.
Рута вам обычно не требуется.
Даже группа docker не очень то обязательна.
Docker просто
проектировали как попало.
Отдельная группа
тоже не требуется.
Я понимаю, почему docker требует отдельной группы.
Там все группы требуют создательную запись.
Мы можем либо ставить root,
но это не очень хорошее решение.
Зачем быть root, чтобы запустить контейнер,
который может быть небезопасным.
Нужно сделать систему так, чтобы она никому не мешала.
И чтобы она никому не была доступна,
кроме нашего конкретного процесса,
его вечерних процессов.
Как это сделать? Linux namespaces.
Помните конец прошлого семестра?
Команда unshare.
Надо контрольную провести весь год.
Не за этот семестр, не за этот год.
Так.
Что?
Нет, это слишком халявно было.
Unshare –rm.
–r означает стать фейковым
пользователем root.
–m – отключить пространство
mount.point.
Помолчаю, unshare запускает bash.
Обратите внимание, что имя пользователя
меня поменялось, стало root.
Я могу сделать какой-то файл.
Он создался.
В каталоге контейнер.
А кто является его владельцем?
Его владельцем является обычный пользователь,
потому что когда вы делаете unshare
пользователя root, то у вас просто
происходит отображение с двиг
user.id
на определенный констант.
И ноль отображается на файлы обычного пользователя.
Теперь я вас проведу
вот это вот безобразие.
Вау.
Вот оно подмонтировалось.
Что у нас содержится в new root?
У меня теперь содержится
иерархия каталогов стандартной в Linux системы.
А из другого процесса я уже не вижу
этого содержения.
Этот каталог остается пустым, почему?
Потому что для того, чтобы подмонтировать
файл системы, мне пришлось сделать новое изолированное
изображение.
Команда mount мне честно показывает, что в конце
действительно подмонтирована эта файла система.
Из другого процесса на той же машине mount
при этом ничего не знает.
Ну и теперь я могу
сменить
каталог.
Я нахожусь в корне.
Вот команда hello.
Она работает.
Никаких прав root здесь не потребовалось.
Сейчас мы смоделировали некоторые контейнеры.
Что у нас при этом болтается
в new root?
Вот у нас есть
new root,
есть еще каталог дейта,
который является верхним слоем
нашей объединенной файловой системы.
Давайте создадим
в корне файл hello.txt.
Вот он есть.
Что произойдет, когда я отмонтирую
эту файловую систему или просто закрою эту вкладку,
и потом воспроизведу это заново.
У меня данные потеряются или не потеряются?
Вот самый верхний каталог.
Он нужен для того, чтобы сохранять изменения,
которые получены в нашей объединенной файловой системе.
Права на владельцам
является пользователь sui-1000,
тот самый пользователь, который изначально
выполнил команду unsure.
Если я что-нибудь натворю,
я как бы пользователь root.
Что будет, если я что-то натворю в системе?
Например,
удалю, что-нибудь ненужное есть.
Перл мне нафиг не нужен.
Вот, кстати, недостаток
для bootstrap.
Такого штуку не позволит сделать.
Ладно, давайте что-нибудь другое сделаем.
Здесь уит как раз владельцем
является пользователем.
Зато есть владелец
на команду hello
sr bin hello
Вообще никак.
В чем еще можно натворить?
Удалить не смогу,
зато я смогу модифицировать.
Я не могу удалить,
потому что в исходном файле
каталог usr bin
обладает правами только на чтении
и владельцем его root.
Нет, там просто уисходный.
Нет, это фейковый root.
Давайте
смысл root
то, что мы смогли сделать mount.
Давайте сделаем непри... ой.
Кнопочки вверх-вниз
vi не работают.
Это vi, это не vim.
Да, vdkl, но в помощь.
Главное, вручки не работают.
Давайте мы вставим
что-нибудь в место привет-мир.
Напишем...
Сделано просто пустым.
Сойдет.
Мы поменяли файл hello sr.
Что у нас произошло
перед исходным файлом hello sr,
который находится, например,
в нашем приложении.
Нет, рестолировать можем.
Смотрите, в исходном application
ничего не поменялось.
А где у нас сохранились изменения
Все эти изменения
попали...
Сейчас покажу.
Теперь заходим в наш контейнер
new root.
Тоже, как мы создаем новые файлы
new root.
Вот файл hello.txt, который мы создали.
Точно так же мы можем
инсталлировать что-то.
Это верхний слой,
он сохраняет все изменения.
Если вы что-то вставите
внутри вашего контейнера,
то оно в каталоге с данными сохранится.
А что мешает?
У нас появился
подкаталог src
который содержит файл hello.txt
и он содержит
новое содержимое нашего файла.
А если мы его вообще грохнем,
что у нас произойдет?
У нас появляется
файл hello.txt
который вы не можете посмотреть.
Выдает какую-то странную ошибку.
Это просто
файл специального типа,
который является признаком того,
что данный файл был просто удален
из исходной нежележащей
файловой системы.
То есть наложение потом повторное
из изготовления файловой системы.
Да и это поверх каких-то каталогов
с нижней файловой системой,
с базовой системой, плюс наш каталог.
Опять нам вернет исходное состояние
вот эту файловую систему, которую мы и получили.
Докер через OverlayFS работает.
Более того, OverlayFS появилась
благодаря докеру,
особенность файловой системы OverlayFS.
Она реализована как модуль ядра.
Точно так же, как все остальные файловые системы.
На самом деле можно еще делать
файловые системы не обязательно в ядре.
Можно делать обычные программы, в том числе
писать на питоне,
которые будут реализовывать функциональность
файловой системы и вытворять все, что угодно.
Как это происходит?
Есть подсистема Fuse,
которая как File System, User Space,
работает следующим образом.
Есть модуль ядра, который называется тоже Fuse.
Он предназначен для создания
произвольных файловых систем.
При загрузке модуля Fuse у вас появляется
специальный символный файл
FSDF slash Fuse,
который вы можете открыть, получить файловый дискриптор
и дальше с этим файловым дискриптором
взаимодействовать как с обычным socket.
Что при этом вы будете читать из socket?
Вы при этом будете читать из socket какие-то команды,
которые посылает вам ядро.
А что за команда, которые ядро может вам посылать?
Например, какой-то пользовательский процесс
или файл, который находится в вашей файловой системе Fuse.
В данном случае запрос будет
переадресован как к кому-то процессу,
который обслуживает данную точку монтировки.
В ответ ваша программа
должна отправить
какое-то содержимое,
либо содержимое файла, либо метаданные файлы,
либо какую-то ошибку.
Таким образом, вы можете реализовывать
произвольные файловые системы,
которые могут вытворять все, что угодно,
поскольку обычные программы,
которые могут использовать любые совершенно библиотеки,
не запихивают все ядро.
Задача ядра в данном случае
это только перенаправлять какие-то запросы
от других программ к вашей файловой системе.
Как я сказал,
эта штука может быть сделана
не обязательно на си, не обязательно на плюсах,
как вообще реализуется взаимодействие с Fuse.
Есть библиотека LeapFuse,
на семинарах 29-й группы у нас уже вчера был семинар.
Вы это потрогали, другие группы еще успеете.
Как раз будете делать реализацию своих файловых систем
на базе Fuse.
Нужно реализовать определенные функции,
которые соответствуют отдельным функциям
файловым системе.
Аналог функции stat,
аналог функции read, аналог функции open.
По сути, не все из них являются сисковыми.
ReadGear, например, это не сисковый.
Реализовать функциональность того,
что выполняется системными вызовами
и дальше просто прослушивать какой-то socket
при необходимости обрабатывать,
вызывать нужные обработчики.
Но эта часть реализована как раз в библиотеке LeapFuse,
для которой есть оболочки, в том числе и на Python.
Последняя демонстрашка на сегодня
это
программа на Python,
которая реализует временную файловую систему
в памяти.
Пример не мой.
Взят из списка экзамплов
в библиотеке Fuse Python.
На Python это делается
в виде класса,
в котором реализуются какие-то методы,
очень сильно похожие
на команды либо системные вызовы.
Единственное отличие, вместо stat
Fuse использует getUpper.
Чаун, чмод,
create, знакомые названия.
mkdir,
open, read, readdir.
Примерно все то же самое.
Реализуйте какую-то функциональность.
Самая интересная функция main,
просто вызываете что-то штатное.
137 строк на Python,
полноценная реализация временной файловой системы.
На плюсах, кстати, не сильно.
Больше, конечно, но не сильно.
Запускаем
все это безобразие.
Обязательный аргумент
точка монтирования.
Там получаем какую-то ошибку,
потому что сразу после монтирования
какая-то зараза полезла.
Подозреваю, что у меня там запущен десктоп с XFCE,
полез по всяким нехорошим файлам.
Тем не менее, оно работает.
Что теперь я могу сделать?
Нехорошо быть root.
Зашли в mount.
Создадим какой-нибудь файл.
Можем очереду сделать,
только как только я останулю этот процесс,
то про все данные можно будет забыть.
Вот создан какой-то файл.
Он доступен.
В логе пишется, что действительно был создан файл.
Потом прочитали каталог.
Затем еще раскрыли файл, прочитали.
В общем, какие-то действия происходят.
Я теперь нажимаю CTRL-C,
останавливаю этот сервис.
Какая-то ошибка.
В общем, все.
Файл системы у меня больше не доступны.
В самом деле, она не сразу была полностью отмонтирована.
Просто по той причине,
что данный каталог
был задействован как текущий,
но отмонтирование произошло немножко позже,
потому что нельзя
полностью отмонтировать то,
что используется.
Теперь еще раз OS Mountain Point.
Все пусто, потому что была временная файловая система.
Поскольку это язык программирования Python,
что вы можете вытворять?
На Python вы можете вытворять очень много всего.
Например, будет залазить в интернет,
дергать какие-нибудь API,
каких-нибудь сторонних сервисов.
Так, например, может быть,
файл системы, которая скачивает что-нибудь из YouTube,
может сделать отображение почты.
Возможности ограничивается только вашей фантазией.
И что вообще сделано
с использованием Fuse?
Во-первых, доступ
к сети Microsoft Windows.
Windows использует свою сеть Microsoft Windows.
Это не FTP, не NFS.
Это протокол SMB.
Когда-то в ядре Linux,
может быть, сейчас в ядре есть,
просто все дистрибутивы ее включают,
была поддержка файла системы SMB.
Из ядра в какой-то момент
эту штуку выкинули,
но есть возможность использовать
функциональность SMB
используя под систему Fuse,
поскольку в данном случае,
даже если что-то не очень корректно работающее у вас будет,
то оно не скомпрометируется системе.
Файл системы TFS.
Есть два разных вера реализации
этой файловой системы под Linux.
Старый модуль NTFS, который содержится в ядре
только для чтения,
и NTFS 3G, который позволяет в том числе делать запись,
но, опять же, он разрезан через Fuse.
UnionFS похожий на overlayFS,
но и самая распространенная штука
на базе Fuse, файл системы SSHFS,
который позволяет монтировать
содержимые удаленные машины
используя обычный протокол SSH.
Как это вообще возможно сделать?
Что вы можете сделать с помощью команды SSH?
На удаленном сервере.
Например, SSH localhost.
Я просто лагонюсь.
А еще SSH позволяет указать
Можно ли мы создать какой-то файл
используя команду SSH?
Как это сделать?
Поскольку я использую localhost,
то файл действительно был создан.
Как отправить содержимое?
Файл на удаленном сервере.
Вместо touch, наверное, можно записать.
Романда cat.
Конкатинация.
По умолчанию наберет содержимое
из стандартного потока вывода.
Перенаправим вот так вот файл.
Допустим, у меня есть содержимое
питонского файла.
Содержание этого питонского файла
будет записано в New File Text.
Как работает такая команда, понятно.
На локальной машине я выполняю команду cat.
Которая на стандартный поток вывода.
Выводит содержимое файла по байтам.
Затем это содержимое перенаправляется
в команде ssh, которая на удаленном машине
запускает команду cat,
которая записывает что-то из стандартного
потока ввода в какой-то файл.
Что мы еще можем вытворять с помощью
новой каталоги, изменить атрибуты,
выполнять команду ls,
удалять файлы, получать их содержимое.
На самом деле достаточно всего лишь одного
подключения к серверу,
достаточно всего одного открытого порта по ssh.
Достаточно безопасно, поскольку у нас
шифрование здесь принудительно используется.
Но набирать каждый раз такие команды
наверное не очень удобно.
Что можно сделать?
Можно один раз подмонтировать файловую систему.
Это делается с помощью sshfs,
которая использует протокол ssh
для подключения куда-либо
и отображает содержимое удаленного сервера
на локальной машине в каком-то из каталогов.
На этом все.
Парагон недавно сделал
пенсорсную новую реализацию,
и я подумал,
что это один из вариантов.
Есть ли у вас вопросы?
Что используют?
В Windows Subsystem for Linux
там есть внутреннее хранилище
в Windows, там просто образ.
На счет 11 Windows не знаю,
я ее не трогал.
В 10 это был просто образ.
