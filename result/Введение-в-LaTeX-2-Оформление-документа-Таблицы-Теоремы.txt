Так, всем привет. Начинаем второе занятие курса. Второе в основном всеми, кто будет смотреть это в записи.
Но тем не менее, в прошлый раз остались некоторые вопросы, которые были вновь не отвечены или отвечены не очень корректно,
и хочется сначала это закладить, потом уже двигаться по темам.
Во-первых, я завекался, что есть такая вещь как макросы, которые конечно психичны для каждого редактора в техе в отдельности,
но по крайней мере в ВСКоде есть вот такая штука. Если пройти в специальные настройки,
которые здесь указаны Preference Scaber Shortcuts и там перейти в специальный файлик, который содержит всякие пользовательские конфиги,
то у него можно прям писать код своих новых команд, вернее реакции на нажатие клавиш, которые вот так вот вид имеют.
Это словарь, вида, какие-то аргументы, какие-то значения.
И вот как видим, в текущей команде я говорю, что хочется на нажатие клавиш CMD SHIFT 9, ну или CTRL SHIFT 9, если вы пишете на винде,
применять загадочную команду INSERT SNIPPED, ну и далее указывается сам SNIPPED, который будет вставляться.
И значит, например, следующее. Вот выделенный текст, который буквально выделен в редакторе, нужно взять,
обернуть с кубочки LEFT-RIGHT, бэкслэши экранированные, поэтому их тут два. В итоговом тексте их будет по одному.
И далее поставить курсор на позицию $0. Можно проверить, как это выглядит на практике.
Я буквально опишу какой-то текст, выделяю его, делаю CMD SHIFT 9 и получаю именно то, о чем написал.
На всякий случай визуально покажу, где есть этот настройка. Каждый раз я не смог его найти, видимо, это не очень тривиально.
Да, preferences, keyboard shortcuts. И далее такая кнопочка, открывающая специальный файл.
Тут у меня еще парочка команд. Они специфичны скорее для того, что я пишу именно в VSCode.
В TechStudio нажатие CTRL B и CTRL I применяют и используют команду дежурного или курсивного текста,
ко всему выделенному тексту. Здесь такого, к сожалению, нет, потому что CTRL B и CTRL U чем-то занято,
и приходится писать свое на CTRL B и CTRL SHIFT I. Тоже можно проверить, что это действительно работает.
Ну и в общем, таких штук можно придумать массу. Мы, скажем, видели разные виды скобочек, всякие там квадратные, фигурные,
которые тоже хочется иногда делать разноразмерными, как прямо в этом примере с обычными скобками.
Ну и можно придумать такие же команды, сделать их и дальше пользоваться. Я здесь составил такой самый минимум,
чтобы гладни разбегались. Очень удобная штука, в дальнейшем она может сильно разрастаться.
Стоит пользоваться, если пишете в S-коде. С этим разобрались.
Да, видно, что было в S-код, когда я в него переключился.
Да, в S-код было видно.
Огонь. Значит, тогда дальше можно по этому поводу не переживать.
И второй был вопрос, который решить не получилось, как использовать всякие кириллические, ну и другие
юникодные символы в математике. У меня все падало при попытках хоть что-то сделать.
Разгадка следующая. Во-первых, для того, чтобы использовать какие угодно символы в математике,
есть пакет MathText. Мы в прошлый раз не смогли его правильно набрать, поэтому ничего не заработало.
Но вот прямо сейчас прям будем. Я могу его проставить.
Ну и гипотеза такая, что если я напишу какую-то формулу, в которой будут русские буквы, то она хотя бы скомпилируется.
Ага. Она при этом все еще не ускоритовала символы.
И это, видимо, потому что MathText нужно применять до указания всех символов.
И это, видимо, потому что MathText нужно применять до указания всех кодировок.
Да, у меня уже была эта строчка закомментирована, и, видимо, стоит ее раскомментировать.
Огонь. Это работает.
Мне такой вариант вообще не очень нравится, потому что есть подозрение, что этот пакет может чем-то контактовать.
Вот даже его расположение после пакетов с кодировками уже все попортило.
Поэтому я предлагаю забыть про его существование.
И также вторым способом, который я предлагаю, есть такая штука команда Text.
В прошлый раз я пытался тоже ее набрать, но, как оказалось, она приезжает не сама по себе, а в пакете IMS Math.
Если его подключить, то все должно заработать.
В прошлый раз мы писали документ буквально с нуля, там не было ни такой прямбулы, никаких пакетов, поэтому кто мог подумать, у нас ничего не получилось.
Видимо, в случае с командой Text нужно оказать прям таки аргумент в скобочках.
Не знаю, почему для нее правда отличается от всего остального, но почему бы нет.
Огонь. Все заработало.
Возможно, проблема в том, что после команды Text он начинает партий все далее происходящее, как какие-то юникодные строки, которые бывают разной длины.
И поэтому ему уже хочется видеть прям фигурную скобку, чтобы было от чего отталкиваться.
Но тут же я не верю, что у него конкретная проблема, но главное, что так оно работает.
И хорошо.
Дальше.
Более-менее к тому, что я собирался сегодня говорить.
Презентация зависла.
Поговорим по оформлению документа.
Это, в частности, покрывает некоторые вопросы, которые тоже задавали в прошлый раз, которые стоят осветить, как делать всякие оступы по горизонтали и по вертикали.
Это бывает в полезном оформлении, например, титульника, в котором много разных оступов и довольно мало текста, и хочется разместить его именно там, где хочется, а не где получится.
Есть такие команды, как HSPACE и VSPACE, которые неожиданно лепят в тексте.
Как указываются длины, мы еще поговорим.
Есть разные единицы измерения.
В частности, из того, что часто может пригождаться, это, например, пяти, ну, то есть, point.
Буквально в точках или в пикселях замеряется расстояние.
Если я тут какой-то текст напишу, еще какой-то текст, то по умолчанию, как мы помним, любое количество расстояния в тексте, это может быть очень много.
Если хочется чего-то большего, то придется использовать какую-то команду.
Тут неважно, может вообще не быть стихотступов, если я ее применил.
На всякий случай.
Проверим, заработает ли так. Если не заработает, то поставим еще один пробел.
Да, почему не сработало, потому что по умолчанию команда vspace, которая делает вертикальный пробел, она на самом деле действует по окончании текущей строки.
А текущая строка, несмотря на то, что, казалось бы, есть переход на новые строчки, они все одинарные, и поэтому переобразуются в пробелы при компиляции.
И поэтому ничего не получается.
Поэтому, да, для безопасности, видимо, лучше всегда оборачивать такие штучки в Enter, чтобы точно ничего не поломалось.
Есть такая вещь.
Есть также горизонтальный пробел.
Если мы будем использовать этот пробел, то мы будем использовать этот пробел.
Если мы будем использовать этот пробел, то мы будем использовать этот пробел.
Если мы будем использовать этот пробел, то мы будем использовать этот пробел.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
Как мы уже видели такую идеологию, что звездочка меняет поведение команды на не очень сильно.
Как мы уже видели такую идеологию, что звездочка меняет поведение команды на не очень сильно.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
И есть еще также их версии со звездочками.
Если звездочка меняет поведение команды на не очень сильно.
Если звездочка меняет поведение команды на не очень сильно.
Здесь идея такая, что если обычный ажспейс начнется где-то близ к концу строки.
Здесь идея такая, что если обычный ажспейс начнется где-то близ к концу строки.
И то расстояние, которое мы ему подали на вход, не умещается целиком до конца строки.
И то расстояние, которое мы ему подали на вход, не умещается целиком до конца строки.
И то расстояние, который мы ему подали на вход, не умещается целиком до конца строки.
То оно просто обрежется.
То оно просто обрежется.
Если же мы используем ажспейс со звездочкой, то это расстояние, сколько влезет, будет размещено в конце этой строки.
Если же мы используем ажспейс со звездочкой, то это расстояние, сколько влезет, будет размещено в конце этой строки.
Если же мы используем ажспейс со звездочкой, то это расстояние, сколько влезет, будет размещено в конце этой строки.
Если же мы используем ажспейс со звездочкой, то это расстояние, сколько влезет, будет размещено в конце этой строки.
А что останется уже в начале следующей.
А что останется уже в начале следующей.
И это еще больше экзотика, чем просто ажспейс.
Но, наверное, стоит упомянуть, что такая разница в поведении есть.
Но, наверное, стоит упомянуть, что такая разница в поведении есть.
Хотя бы потому, что возникает вопрос, зачем вы вообще придумали две разные команды, которые делают вроде как одно и то же.
Хотя бы потому, что возникает вопрос, зачем вы вообще придумали две разные команды, которые делают вроде как одно и то же.
Хотя бы потому, что возникает вопрос, зачем вы вообще придумали две разные команды, которые делают вроде как одно и то же.
Хотя бы потому, что возникает вопрос, зачем вы вообще придумали две разные команды, которые делают вроде как одно и то же.
Но на самом деле поведение иногда отличается.
Но на самом деле поведение иногда отличается.
Но на самом деле поведение иногда отличается.
Есть также команды Achille и V-Fill.
Они очень полезны, на самом деле бывают при оформлении того же самого титульника.
Они очень полезны, на самом деле бывают при оформлении того же самого титульника.
Если хочется написать что-то вверху, какой-нибудь заголовок.
Если хочется написать что-то вверху, какой-нибудь заголовок.
И что-нибудь внизу в странице.
И что-нибудь внизу в странице.
Ну, например, дата.
Ну, потом поговорим, как грамотно задавать заголовки даты.
И вот хочется, чтобы это было прямо верхней страницы.
И вот хочется, чтобы это было прямо верхней страницы.
А вот чтобы оно прямо само считалось и располагало где следует.
А вот чтобы оно прямо само считалось и располагало где следует.
Это весь команды V-Fill.
Она буквально замощает всё пространство по вертикали, которое сможет.
Она буквально замощает всё пространство по вертикали, которое сможет.
Прямо в ходной странице.
И да, ожидаемый эффект.
Мы получили заголовок в самом верху.
Ну, то, что ещё выше это поля, мы ещё поговорим про это настройку.
Ну, то, что ещё выше это поля, мы ещё поговорим про это настройку.
И вот в самом низу дата.
Вот.
Есть также команда Achille.
Она делает то же самое, но по коризонтали.
Проверить ещё раз не будем.
Понятно, что эффект будет примерно таким же.
Да, переход на новую строку.
Есть много разных способов.
Про это даже как-то мы говорили в чате.
Про это даже как-то мы говорили в чате.
Ну, вот вообще говоря,
Сначала перечислю все команды.
Есть просто команда Park.
Которая делает примерно то же самое, что и 2 Enter подряд.
Которая делает примерно то же самое, что и 2 Enter подряд.
Они просто задают новый абзац.
Есть команды
Двойной Backslash и New Line.
Которые с некоторыми там
внутренними техническими трудностями
делают примерно то же самое.
Но как раз эти технические трудности, которые нам лучше не вдаваться,
их не стоит использовать.
И уж тем более не стоит использовать много подряд.
Так получается, что их эффекты друг другу пересекаются и конфликтуют.
Это может создать проблемы.
Если вам хочется сделать много оступов по вертикали,
используйте, скажем, V-Space.
Ну, или несколько команд Park,
если вам очень хочется делать ещё команды Park.
Но я с вами рекомендую пользоваться везде командами
V-Space и F-Space.
Это намного читаемее, как мне кажется.
И не требует большого дублирования кода.
Которое возникало бы, если бы делали
много оступов подряд,
используя одну и ту же команду.
Ну, есть также команды Line, LineBreak, PageBreak.
Они
сильно...
просто насильственно переключают
страницу стекущую на новую
или строчку стекущую на новую.
Тоже есть некая техническая разница между NewPage и PageBreak.
Вот я тут написал, он не наше сформатирование.
Ну это то же словом, долгости, которые нас не очень интересуют.
Глобально NewPage, наверное, немножко безопаснее,
но в целом большую разницу я бы между ним не выделал.
И да, еще одно важное замечание.
Был вопрос в прошлый раз, как быть, если...
Вот, посмотрим на такой эффект.
Попробуем начать какую-то секцию.
Которые будут...
Ну какие-то два абзац.
Пока не очень важно какие.
Но вот мы замечаем, что первый абзац
он начинается несколько раз на строке.
Это американская типографская традиция.
У нас так не принято, хочется с этим бороться.
Для этого есть специальный пакет InDentFirst,
который буквально это и делает.
Он делает так, чтобы первый абзац
как бы не был наше сформатирование.
Так, чтобы первый абзац каждого раздела
он тоже отступался.
То есть, связался перед ним InDent.
Тоже.
Тоже позволение ставлю.
И проверю, что это работает.
Но вряд ли что-то изменилось в прошлый раз, как я это запускал.
Да, действительно, теперь у нас
наше традиционное сформатирование,
красные строки и все хорошо.
Это точно.
Одна из команд с той категории,
где ты оставляешь преамбль
и больше никогда не переиспользуешь.
Вернее, не перенабираешь.
Переиспользуешь ты ее постоянно,
но она все время там и остается.
Поэтому, скажем, я сходы,
наверное, в прошлый раз бы ее и не вспомнил.
Я помню только примерно, как она называется.
Вот такой синтаксис.
Идем дальше.
В прошлый раз мы начали говорить
про то, как делать всякие разделы и подразделы.
Их на самом деле сильно больше,
чем то, что мы видели в прошлый раз.
Есть еще подсекции и всяких подсекций.
Есть еще part, chapters,
paragraph и subparagraph.
Вообще говоря, неполный набор
есть в любом документе.
Да, напомню, что когда мы только создавали документы,
мы указывали в документ-класс.
И вот я сказал, что нам пригодится скорее всего
только артикл, и нам хватит ее официальности.
Но вот в частности,
разные документ-классы определяют
то, какой набор разных
именования разделов
можно в этом документе использовать.
Есть люди вроде book,
которые имеют больше опций
в предположении, что там будет куда более глубокая структура,
которую нужно будет
тезинклассифицировать, и потребуется
все эти наименования сразу.
Есть еще некие различия,
но пока их не будем упоминать.
Но главное, что есть такие названия,
и в артикле, из того, что я тестил
из этого списка,
не работает только chapter.
Все остальное в принципе работает.
Другое дело, что paragraph, скорее всего, практически незаметен.
Можно попробовать.
Да, он
даже не делает переход
на новую строку. Считается, что это буквально
заголовок текущего облаца, что-то в этом духе.
Ну что ж, такая экзотика, я ей довольно
редко пользуюсь. Мне, как правило, хватает
секций и подсекций,
но в худшем случае над ними можно навесить парты,
которые, слава богу, есть
в случае артиклей.
Вот.
Ну и стоит также упомянуть, что вообще-то
к секции можно приписывать также более короткое
наименование. Для чего оно нужно?
Короткое наименование пойдет, например,
в содержание,
table of contents, до которого мы скоро дойдем.
Ну то есть,
это такое техническое наименование,
которое будет применяться где-то,
где длина не умещается. Примерно такая идея.
Да, и вот к слову table of contents
о том, какие вообще будут автогенерируемые разделы,
их несколько, как ни странно.
Во-первых, есть точка моих title,
которого наверняка, ну не прямо ее,
а эффект ее использования, сейчас видите
в статях,
делается на следующее. Оно берет значение
переменных автора
заголовка и даты, в которых
ну, давайте попробуем без них запустить, скорее
всего ничего не получится. Но вот если их задать,
то оно их грамотно отрисует. Пробуем
сначала без них.
Даже не нужны скобочки.
Потому что команды аргументов не имеет.
И да, все попадало.
Смотрим почему.
Да, ну буквально то, что я говорю.
Он не умеет правильно
функционировать, если мы ему не задали
ни заголовка, ни автора.
Кстати, на дату он не жалуется.
Видимо, даты это вещь опциональная.
Ну, положим, что мы все можем отцедать,
мне очень трудно.
16 октября.
Разумеется, формат задания свободный.
Это просто три строки, которые ничего, ну,
никакой особой темантики не имеют. Он просто отрисует их
в нужном формате. Если бы тут была не дата,
а любой другой текст, это не вызвал бы проблемы.
Ну, попробуем так.
И да, оно
грамотно отрисует
сначала чуть большего размера
заголовок, потом чуть меньшего размера автора
и такого же размера дата.
Вот я почти уверен, что вы подобную
роду штуки видели где-то в каких-то статях.
Переболят такие экзотичные вещи.
Во-первых, TableFont, который я
упоминал, это команда,
которая берет всю информацию,
которую мы задавали всякими
секциями, подсекциями и прочим,
и указывает на дельной странице,
где искать, какую из секций.
Посмотрим действия.
Кстати, чтобы сымитировать переход
в новую страницу, я буду вылечить
пользоваться NewPage, потому что я не очень хочу
генерировать целую страницу текста.
Гипотеза такая, что
он не сгенерирует
заголовки первого-второго раздела
на нужных страницах,
а во-вторых, он на первые страницы
делает отдельную штучку,
которая имеет формление заголовок
содержания, и дальше все разделы подряд
и страницы, которых надо искать.
Да, действительно оно сработало.
Другое дело, что пока что эти ссылки
не окликабельны, это хочется
исправить, мы исправим это чуть-чуть погодя.
Но уж по крайней мере нам дает
это числовое значение, куда идти,
а именно страницу номер два
и двое страниц.
И мы можем сделать это,
если мы не будем искать,
то мы будем искать,
а если мы не будем искать,
то мы будем искать,
то мы будем искать,
а именно страницу номер два
и спустим теперь в раздел.
Это тоже вы увидели наверняка в любой работе,
которая написана на техне.
Да, есть более экзотичные
аналоги этой команды
list of figures, list of tables.
Мы пока не говорили ни о том, ни о другом,
но в общем есть некие инструменты,
позволяющие в отдельный списочек
загонять все изображения,
которые есть в вашей сайте
и все таблицы, которые в ней есть.
Потом, с помощью этой команды
генерить некий аналог содержания,
который указывает ссылочки
только на эти специальные объекты.
Да, есть также команда appendix,
она сама по себе
ничего не делает,
но она несколько меняет поведение
команды видосекция, подсекция и прочее.
Она немножко
меняет способ номерации.
А именно,
если мы по умолчанию ничего не трогали,
у нас секции номировались
обычными арабскими числами,
то если мы хотим, чтобы дальше
начинался аппендикс,
ну то есть предложение, как еще говорят,
то утверждается,
что номерация станет не арабской,
какой-то другой.
И действительно,
номерация стала вообще латиевскими буквами.
Это все регулируется, это можно настраивать,
но это лучше погуглить как,
конечно же, вещь. Кажется, что
обычно такого разделения
числа в обычном содержании
и на буквы в предложениях
его обычно хватает.
Уж по крайней мере как содержание управлять
не касательно аппендикса мы еще поговорим,
но это тоже будет не в этот раз.
Да, еще один важный комментарий,
который мне наверное стоило оставить,
что вот команды вида
new page,
они
работают не сиюминутно.
Они
ищут ближайшее подходящее
место, в котором они в состоянии сделать
новую строчку, новую страницу,
и тут довольно трудно сделать
что-то более серьезное, тех он довольно
самостоятельный и сам вычитывает
многие штуки, которые касаются верстки,
и мы можем вам только подсказать,
где конкретно мы хотим сделать
переход,
могут быть такие ситуации, в которых не с
первого раза получится правильно это указать.
Это к сожалению так,
это тоже можно настраивать,
но это такие довольно продвинутые, довольно
узко специализированные вещи,
я думаю, что я оставлю это совсем на потом,
но вообще говорится быть аккуратным,
то есть нельзя быть уверенным, что
как только вы применили
команду new page или page break,
она сделает прямо то, что вам нужно,
а не что-то немножечко другое.
Лучше всегда комплиировать, смотреть, что получится.
Есть некая вероятность, что вам придется
написать не так, как вы ожидали,
а как-то по-другому, чтобы это заработало правильно.
Ну и последнее, наверное,
что касается документов в целом, это пакет
Geometry, это то, что мы говорили о полях,
как задавать правильно поля сверху,
снизу, с левого справа.
Есть такой пакет, который делает довольно
удобный интерфейс,
примерно такой
интерфейс. Мы делаем use package
geometry, а потом применяем такого
виду команды. Просто geometry
и конкретная переменная,
соответственно, отступы там сверху, топ, снизу,
ботом, слева, лево, справа, райт
и их какие-то размеры физические.
И вот одно на этом же слайде про
единицы измерения, которые я уже упоминал.
Вот те,
которые вам часто могут пригождаться,
они примерно такие. Есть такие
компьютерная природа, единицы.
pt – это буквально
точка, пиксель, x – это
как сказано, высота буквы x,
именно таким шрифтом, а m – это
ширина буквы m, именно таким шрифтом.
Конечно, мы видели его в прошлый раз,
и тогда еще не мы не поняли, для чего
он нужен, но, например, для этого.
Ну, это моноширидная
стандаршрифта.
И также поддерживаются чисто физические
единицы измерения, миллиметров, сантиметра
и даже дюйма, inches.
Поскольку у нас все документы, как правило,
имеют форматы A5 или A4, у них вполне
понятные геометрические размеры,
из них имеет смысл все привычные нам
единицы измерения.
В частности, для полей
так даже как считаемые
получается, если их указывать именно в
2 миллиметрах, а не в чем-то типа x.
Предлагаю попробовать
это тоже в действии.
Ну, как всегда,
usePackage
в геометре
и то, что я скопировал.
Каждое поведение такое, что он даст
правильные размеры полей. Наверное, чтобы было заметно,
стоит, например, указать на контрасте,
что будут очень большие поля снизу
и очень маленькие сверху, чтобы заметить, что хоть
что-то изменилось.
Ну, действительно, как видим,
текст начинается практически
у начала страницы, а заканчивается
далеко не в конце, имеется
счастный уступ, потому что мы вот так
указали. Это все регулируется,
есть какие-то стендарты, наверняка им можно
пользоваться.
И есть еще парочку параметров,
которые стоят в минуточку.
Во-первых, параметр lineSpread
он регулирует
коэффициент
межзрочного интервала.
По умолчанию строчки между собой довольно тесно
расположены.
Нагенерю парочку,
чтобы было наглядно.
Вот.
Ожидаемо, что сейчас они просто
построятся прямо друг под другом,
с довольно малыми межними расстояниями,
и вообще говоря, для обычного текста это нормально.
Это никакой проблемы не вызовет.
Но если получается так, что у нас
в строках довольно много вложенной математики,
ну, вот окружений, которые пишутся в долларах,
именно внутристрочных,
то они могут
или распирать строку
по высоте,
и вот скажем, если
во второй строке напишу что-то, скажем,
подробью,
которая будет еще, это у нас
главный букв, например, что-то довольно крупное.
Окей, нужно еще крупнее, например,
А в степени А.
Не получается поломать.
В общем, утверждение такое, что
если прям очень громоздкие формулы писать
посреди строк, то есть
некий риск, кстати,
не знаю, как точно можно сделать,
это способ, который мы еще не говорили,
но придется им воспользоваться, иначе ничего не получится.
Например, поставить сумму
с индексами,
которые будут
прям сверху и снизу.
Да, получилось.
Вот если есть некая очень толстая по высоте формула,
она возьмет
увеличит высоту всей строки,
а форматирование текста поплывет,
будет не очень симпатично,
с этим хочется бороться.
Первый способ бороться, это, конечно, не писать такие формулы,
но если никуда не деться, нужно делать лайн спред
более разумным.
Обычно подходит что-то вроде 1.4, 1.5,
ровно 1.4.
Если это не сработает,
то я сделаю еще один комментарий,
но вроде сработать должно.
Окей, нет, дело в том, что
шрифт обновляется не прям сразу,
нужно сделать такую команду, как
он буквально
обновляет состояние шрифта.
Это сделает то, что нужно,
теперь все наши строки
на одинаковом расстоянии,
расстояние чуть меньше,
не достаточно, все, что мы видели,
выпирающиеся от этого дроп, которое
сильно заставляет эту строчку от других отстоять,
но вот
стоит подгонять непосредственно для вашей задачи.
Хватит ли вам такого расстояния,
или нужно побольше, это все регулируемая вещь.
Еще,
советую обмянуть такие штуки, как
ParIndent и ParSkip.
Ну, во-первых, такой интерфейс,
команда setLength буквально задает некие
физические размеры по объектам,
которые есть на странице. В данном случае,
ParIndent – это отступ
первой строки параграфа,
буквально красная строка,
а ParSkip – это расстояние между параграфами.
Ну, параграфы – это точно то, что абзац.
Тоже штука
регулируемая, можно делать побольше,
есть тоже какие-то стандарты, их можно
использовать ими, но, в общем,
на глаз тоже подбирается неплохо.
Главное, что это вообще существует,
и этим можно пользоваться.
И последнее,
вот на этот раз точно последнее, что касается
о сформлении страницы – это Calentitula.
Calentitula – это такая штука, которая пишет
текст сверху всей страницы,
снизу всей страницы, а вот примерно там же,
где
номер страницы и
такие объекты.
Ну, опять же, вы наверняка видели, что
в каждой книге в верху страницы написано
название книги, там автор
или, может быть, какие-то еще побольше информации,
и только потом весь основной текст, и так на каждой странице.
Это все Calentitula, это тоже все легко
регулируется.
Следующим образом, ну, например, с помощью пакета,
который я тут указал, TitlePS,
наверняка есть
другие, для тех, которые это вообще типично,
что одна и та же дача может торчаться очень разными способами,
они все более или менее эквивалентны,
но вот я предлагаю такое, которое
точно сработает и которое
проверили. Интерфейс
следующий,
вводится такое понятие,
как стиль страницы,
new page style, задаю новый,
и далее два аргумента, это
команды, собственно, название стиля, который дальше будет
использоваться, и вот содержимое. Содержимое
задается так, задается
set head, set foot,
это задание
верхнего и нижнего Calentitula, то есть
header и footer, и далее три аргумента,
левые, центральные, правые, собственно,
надписи, для различия
от 1 до 2.
Ну, а head rule, foot rule,
это толщина линии
отделяющих кадра от текста
и, соответственно, текста
от футера. Можно делать это
побольше, просто чтобы было заметно, разумеется, не
рекомендуется делать так в реальной жизни.
И теперь, когда у нас есть page style,
мы можем его использовать, например,
используем его
в нашем документе.
Да, ожидаемый эффект, мы получили,
что...
Ну, во-первых, Calentitula пока плохо видно,
потому что мы забыли отрубить
довольно плохо настроенные поля.
Я верну в какое-то более разумное
положение, скажем такое.
Да, есть Calentitula,
есть тексты
и слева, и по центру, и справа, отделенные
нужной толщиной линией,
и то же самое снизу.
Здорово, мы справились.
И, как правило, снизу по центру указывается
номер текущей страницы.
Пока что предлагаю как мантеру использовать
команду cepage.
Вот утверждается, что она всегда протягивает номер
текущей страницы. О том, что это,
почему это работает, мы поговорим, когда будем
говорить про счетчики, это будет не сегодня,
но пока так.
И ура,
теперь у нас есть номер страницы. Понятно, что
будет вторая страница, ну то есть следующая по счету.
Номер будет другой, как раз такой, какой
нужно.
И да, стоит упомянуть,
что штуки вроде patchstyle, это модификаторы,
они работают пока
несказанно обратно, пока мы его
явно не отключим, пока не кончится блок
и пока не будет включен другой модификатор.
Если хочется модифицировать только
текущую страницу,
например, это верно бывает для
случаев, когда вы делаете титульник,
которым не нужны титулы,
на котором нужен был голый без всего.
Используется команда не patchstyle,
а thispatchstyle. Она работает
до конца текущей страницы, а не до конца,
не до конца пока может.
Вот.
И штука осталась
в этой части рассказа,
наверное, случайно, следует принести
следующую часть. Ну, в общем, есть такой
пакет sol, который просто позволяет
некоторые модификаторы начертания, которые мы уже
начали писать.
Ну, или как-то иногда упрощает нам жизнь
следующим образом.
Она добавляет команды sol, caps,
ol и st.
Sol это буквально
следующая команда. Она берет текст
и печатает его, но через пробел
между каждой буквой.
Команда caps применяет модификатор
капитального начертания. Ну, и в прошлый раз
вы видели. Команда ol
это то же самое, что underline,
это неквалентная вещь. Она просто подчеркивает весь
текст, который является реагументом.
Команда st это штучка,
которая перечеркивает весь текст.
Вот такое мне пока не перерождалось, но
оно существует.
Ура. Следующий больший раздел,
который стоит хотя бы упомянуть сегодня.
Как вставлять всякие
изображения и всякие таблицы
в тех.
Ну, пример прямо сразу синтеза.
Он сначала может быть немножко
устрашающим, я его совет подробно
разобрать.
Я скопирую его
и применю только для того, чтобы
убедиться, что он работает. Ну, вернее,
чтобы вы убедились, что он работает.
А далее мы вернемся на слайды и просто
поговорим, что происходит и почему
он не так. Да, действительно,
что-то загенерировалось, давайте обсуждать.
Итак,
интерфейс у таблицы такой. Во-первых,
таблица это окружение.
Так же, как мы видели в прошлый раз, скажем,
окружение Center.
Естественно, она открывается-закрывается,
и на End.
Далее
идет
некая специальная
вида строка, которая регулирует форматирование
таблицы.
Читать ее нужно так.
Каждая буковка C,
R или L
это отдельный столбец.
Эта буковка обозначает, как будет
выравниваться текст в рамках столбца.
C по центру, R к правому краю,
L к левому краю. Есть еще
варианты настройки.
Я их уполню, наверное, в следующий раз.
Пока вот так.
Это тоже будут какие-то буковки,
возможно, с каким-то еще дополнительным аргументом.
Еще поговорим.
Некоторое количество прямых слеша между ними
регулирует буквально
сколько будет вертикальных черт
отделять данный столбец с следующего.
Как видим, тут действительно 4 столбца.
Первые два оравниваются по центру.
Третий по правому краю,
четвертый по левому краю.
И между ними ровно такое количество черточек,
какое мы указали. Причем как между ними,
так и там
самого левого краю, самого правого краю таблицы.
Тут тоже можно регулировать.
А интерфейс самой таблицы, например, следующий.
В рамках одной строки
элементы разных столбцов
отделяются амперсантами.
Потому что раз я упоминал, что амперсант
это спецсимвол, он в первый раз пригодился
в такой ситуации.
Ну и буквально такая запись,
что вот контент всей строки,
отделенная амперсантами,
где нужно, записывается подряд.
А чтобы строка кончилась, используется
бутыляной бэкслэш.
Это тот же самый бэкслэш, который делает переход
на новую строку.
И вот в частности, поэтому его не рекомендуется
пользоваться самого к себе,
потому что у него сейчас такое специальное изношение.
И не только такое. Он много где перегружен
на немножко другую семантику.
Мы еще раз на окружении увидим.
И в общем лучше его применять только там,
где его ожидают.
Ну и далее тут еще есть такая штука,
команда ашлайн, которая просто рисует
гаранитальную черту между данными двумя строками.
Их может быть тоже несколько подряд.
Давайте проверим,
что это действительно верно.
Вот ожидаемо, что дальше
у нас будет три черты вместо одной.
Что характерно, между ними
нет черты
вертикально.
Возможно, это можно как-то настроить
и я никогда не пытался.
Наверняка все гуглится.
Более того, можно делать
черту, которая отделяет
не все целцы друг от друга, а скажем,
только второй и третий.
А между первым и четвертым она просто не рисуется.
Это будет команда стилайн.
У нее есть такого вида
специального аргумента. Через
дефис пишут номера целца, с которого начать,
и на котором закончить. Нумерация соединиться.
И все включительно. В каждом месте скажу
2 по 3,
то увидим, что будет.
Будет следующее.
Первый столбец оказался без черты,
последний тоже,
а вот второй и третий действительно отделены друг от друга.
Это бывает полезно. В некоторых таблицах
бывает, что не все клетки
нужно друг от друга отделять.
Там есть еще некоторые вещи, вроде
многостройщих и многостолбцовых
ячеек,
но в предыдущем тоже поговорим потом.
Базовый интерфейс такой.
И про изображение.
Тоже пока очень коротко.
Вот буквально есть такая команда include-graphics.
То, что она делает, она вставляет картинку,
лежащую по данному пути.
Тут предложим пример.
Аргументов include-graphics
довольно много. Обязательно их всего один.
Это будет до картинки. Причем
как с указанием расширения
.png, .tpg,
так и без него. Он все равно разберется.
Возможно, будет проблема, если
у вас есть несколько файлов, которых одинаковые
разное расширение, тогда он, наверное, может поругаться.
Но глобально может не указывать.
Скорее всего, у вас не будет такой ситуации.
И есть обстоятельный аргумент,
который пишется
весь набор модификаторов стиля,
который вам хочется указать. В данном случае
я указываю только модификатор width.
Всякие разные нужно гуглить.
Они похожи на HTML.
Но то, что вам часто будет приглажаться,
скорее всего, это модификатор ширины
или ему эквалютно модификатор высоты,
что удобнее задать.
И в качестве аргумента он
принимает либо
число с единственными измерениями,
как те, которые мы видели раньше,
или в сметрах миллиметрах,
или в пойнтах, или в
X или в M. По-разному можно.
Еще один вариант
это вот такого специального вида
строка. Это переменная
textWidth, в которой хранится
ширина строки
данного элемента
текста. Причем если мы находимся, скажем,
в рамках таблички в одном столце,
то берется именно ширина этого столца.
То есть какую ширину занимала бы
строка текста в самом маленьком
блоке, содержащем текущий элемент.
Примерно такая идея.
Ну и перед ней можно код числовой коэффициент.
В данном случае 0.25, и поэтому получится
кодик на четверть строки.
Стоит также отметить,
что вот такие вот
и таблички, и картинки
стоят обычно в завершении
что-нибудь еще, поскольку
по умолчанию они размещаются
вот прям в ближайшую строку,
к которой они могут уместиться.
Довольно тесно, не очень хорошо выглядит.
Лучше отформатировать, например, по центру,
в муче окружения Center.
Или вообще заворачивать в окружении
Figure или Table.
Потом что это, мы поговорим попозже.
Но это как раз те самые объекты,
которые подтягиваются в List of Figures,
List of Tables. Это, в общем, способ некий
более высокороднего взаимодействовать
со всеми картинками, со всеми
табличками и чуть
точнее настраивать,
как с этими объектами
работать тексту в том плане, что
обтекать их как-то, или оставлять
на своей строке и не трогать.
Это все настраиваемое, при этом будем потом
говорить не сегодня.
Но, опять же, базовый интерфейс, который
стоит знать, он вот такой.
Да, были ли какие-то вопросы
по в третьей части?
Здесь он автоматически
сам решил, что хочет слева
рисунок поставить, да?
Ну, я бы сказал даже не так. По умолчанию
поведение такое, что он всегда рисует слева.
Я бы сказал, что у него в приоритете
как можно левее и как можно выше
разместить текущий объект.
Вот.
Ну, и если он не помещался бы там, то он
бы выкинул его куда-нибудь вообще,
куда-то хотел бы, и...
Если бы он не помечался, скажем, по ширине,
то он бы выкинул его куда-нибудь вообще, куда-то хотел бы, и...
Если бы он не помечался, скажем, по ширине,
блин, у меня с собой нет картинки,
которую можно вставить. Ладно, скажу тогда на словах.
Если бы он не помечался
по ширине, то он бы просто вышел за пределы страницы.
Ну, то есть сколько влезло бы, smooth будет дометвosely
дорисовалось, дальше была критика будет Hawaii
за пределы страницы.
Если бы по высоте, он бы translitşt
новую страницу чтобы хотя бы на нее уместиться.
Если бы там места не хватило,
то он бы влез из за пределы страницы тоже.
liked Palm by HiChan
но такого лучше вообще не допускать
и всегда регулировать это параметрами
высоты или там ширины, ну вот WITS или Festa-Height.
Ну, все вроде понятно.
Здорово, значит, двигаемся дальше.
Второе важное, что стоит сегодня обсудить, это создание команд.
Всякие юскейсы.
Ну, их довольно много, мы сегодня увидим только самые простые.
Да, что такое команда? Мы уже видели всякие разные.
Команда – это, ну, некий набор символов после бэкслэша,
который имеет какое-то свое поведение, ну, вот, который говорит компилятору
нарисовать что-то особое.
Можно задавать свои, интерфейс такой.
Специальная команда, для этого есть NewCommand,
которая в качестве аргументов принимает следующее.
Принимает название команды, ну, то есть,
на какой набор символов теху нужно триггериться,
что вот, ага, это команда.
Начинается слово, что у нас бэкслэша, разумеется.
Дальше, аргумент опциональный – это количество аргументов.
Их может вообще не быть у этой команды.
В таком случае просто опускается, ну, этого часть.
Ну, поскольку это скобки квадратные, видно, что это аргумент опциональный.
Его может и не быть.
Но если они есть, то они указываются именно после названия команды.
Следующий аргумент, который тоже обязательный – второй из двух.
Это непосредственно текст команды, то есть, буквально,
что будет подставлено вместо названия команды.
Вот такой жизненный пример.
Часто бывает полезно рисовать частные предводные, например,
и делать это, ну, например, вот так.
Я, опять же, скопирую этот текст, чтобы не набирать его заново,
чтобы проверить, что это работает.
А здесь попробуем прочитать, что происходит.
Я говорю, что вот хочу сделать команду derivative,
ну, слово derivative, которое будет принимать два аргумента.
И дело следующее.
Дело следующее.
Рисовать фрег, дробь, который будет в числителе значетчик partial,
ну, который рисует вот этот вот перевернутый шестерку
и частный предводный.
И далее первый аргумент.
Обращение к аргументу происходит через хэштег.
А в знаменателе будет тоже значетчик partial,
и второй аргумент тоже через хэштег.
Ну, и проверим, что действительно работает.
Тут мы, как видим, хочется, чтобы у нас отрисовалась
один раз частный предводной f по х,
один раз по у.
Так, так, все попало.
Подозреваю, что он не знает шестерку madbb.
И поэтому предлагаю пока на это забить,
просто сделать r.
За шестеркой мы еще придем.
Да.
Ну, глобально это пока что для того, что мы написали, точно работает.
Мы нарисовали частную производную, она нарисовалась так, как мы хотели.
И при этом нам и пришлось набирать каждый раз заново
фраг, потом на два раза partial,
и еще отдельно x и y в нужных местах.
Так, кажется, как-то удобнее.
Ну, и для многого, при использовании моего кода,
стоит заводить команды,
и потом где-то пользоваться только ими.
Может быть, это как-то понижает читаемость,
ну, локально,
для читателей, которые не знают, что это за команда такая.
Но для вас это точно будет удобнее.
Вам не придется каждый раз писать много одного и того же,
и довольно унывально.
Вторая команда, которую я привел,
сделала бы нам символ r,
но красивый,
как вновь, чтобы сейчас насчистил,
специального шрифта.
Но вот конкретно у меня упало, потому что,
опять же, голый пример, которым мало чего заинклужено,
и в частности, нет пакета, который подключает шрифты из математики,
и мы еще дойдем до того, как подключать,
поэтому пока предлагаю просто это опустить.
Хотя, наверное, я смогу вспомнить сам,
как этот пакет выглядит,
или угадать.
Кажется, что MS-Font что-то такое.
Да, наверное, MS-Font.
Давайте попробуем
вернуть на место команду backslash r,
у которой, да, нет аргумента, количество аргументов,
потому что она на вход ничего не принимает,
и дальше только сам текст команды,
буквально символ r, которым применяется команда msvb.
Напоминаю, что если аргумент односимволный,
того не нужно заворачивать скобки.
Вот тех сам разберется, что вот это именно один символ-аргумент,
и больше никаких.
И ожидаемо, что если мы теперь поставим здесь backslash r,
это будет уже команда,
и она нарисует нам симпатичную букву r.
Да, это работает.
В целом, почти любая теховая работа
начинается с того, что есть некоторые количества аргументов,
которые говорят симпатичная буква c,
она уже, наверное, чем-то занята,
скажем, cn,
потом симпатичная буква n,
числа натуральные писать,
симпатичная буква z.
Это типичные вещи.
Есть еще другие же ститы в математике,
которые тоже часто пригождаются,
мы про них еще поговорим.
В общем, это очень удобно,
потому что это потом впредь экономит себе аж 8 символов,
которые надо было бы набирать иначе.
Вся команда еще и пробил довольно много.
Здорово.
Понятно ли еще, что произошло?
Ну, я так понимаю, что
когда мы сдаем свои команды,
нужно быть внимательным, чтобы
то же имя, что уже существует, не используется.
Да, это очень хорошее наблюдение.
Действительно, если мы попробуем сдать
команду, которая уже занята,
какие мы знаем команды, которые точно заняты?
Например, вот текст bf,
команда, которая уже занята,
попробуем ее переопределить.
Скорее всего, он поругается
и вообще упадет на спирту.
Да, это надо убрать,
потому что нет почт такой команды.
Да, он говорит already defined,
в общем, я так не могу.
Для этого есть такой обход,
не new command, а renew command.
Он говорит, вот теперь мы переопределяем команду,
она теперь делает другое.
Кажется, у меня при этом будет прям следующий слайд.
Да, действительно.
Тут немножко другой use case.
Вот мы в прошлый раз заметили,
что некоторые греческие буквы
плохо отрисовываются по умолчанию.
Вернее, не плохо, они отрисовываются правильно,
но по правильной точке зрения традиции
американской типографии,
они наши, нам не привычно.
И вообще-то нам хочется навсегда отказаться
от той традиции и пользоваться нашей,
потому что скорее всего нам прямая буква phi
нигде особо не пригодится.
Сейчас, секундочку.
Во-первых, я сначала
снова нарисовываю эту букву,
чтобы было на что смотреть.
Epsilon.
Ну и кажется, я еще капу приводил.
Сейчас мы увидим, что по умолчанию
они довольно плохи,
по крайней мере для русскоязычного читателя.
Да.
Какая-то прямая phi,
какая-то прямая epsilon,
какая-то вообще непонятная капла.
Есть для этого обход, можно просто сказать,
var phi, var epsilon, var kappa.
Локально это, конечно, решает нашу проблему.
Сейчас мы это увидим.
Не понял.
Что-то она не знает.
Тоже нужно же какой-то IMS что-то включать.
Ладно.
Капу пока не будем.
Видимо, она тоже приезжает с каким-то пакетом от IMS.
Я в прошлый раз запомнил, что их довольно много.
Хотя опять-таки я могу просто угадать,
какое-то мне куда идет.
Наверное, IMSSync должен сработать.
Это не что-то новое.
Это в прошлый раз было,
что вот есть некий набор пакетов от IMS,
которые можно всегда подключать.
Они ничего не попортят.
Но поскольку это голый пример,
я каждый раз забываю, что он голый
и что-то чего-то не хватает.
Огонь сработало.
Вот.
Локально мы решили проблему.
Мы смогли отрисовать символы так, как мы хотели,
используя команду начинающего существования.
Глобально проблема осталась,
потому что у нас все еще очень длинные названия
на обычной ECAP порисовали вот такие штуки,
а не те, которые мы видели раньше.
Но наш выход – это RenewCommand.
Мы говорим, что вот теперь команда phi
делает то, что раньше делала команда var phi.
Напинаю интерфейс.
Сначала название команды,
которую мы переопределяем,
потом то, что она делает.
Вот.
Ну, и то же самое с AppSoul на MacApp.
Можно сделать, скажем, Apps,
но тогда уже это, наверное, будет NewCommand,
потому что, скорее всего,
команды ее раньше не было.
А если мы говорим про переопределение
и хотим прям точно попасть,
то мы пишем AppSoul.
И проверим, что это действительно сработает.
Да, ожидаемый сейчас результат,
что ничего не изменится.
Вот мы убрали вары,
но при этом все еще будет все рисоваться так,
как если бы это было с варами.
И да, действительно, это сработало.
Вот.
Ну, действительно,
еще полезное такое предупреждение.
Можно случайно переопределить
что-то важное.
И это, конечно, будет верно
только в рамках вашего документа,
причем только вот,
начиная с вашего момента переопределения
и до конца документа.
Если вы эту строчку уберете
и перекапеллируете заново,
то все починится.
Но глобально, ваш документ,
это может на время одной компрессии попортить.
Если вы не уверены,
что вы не попортите ничего
переопределением команды,
а иначе вот не стоит.
Иначе лучше придумать новое название.
Скажем, для Epsilon, мне кажется,
очень даже годится команда EPS.
В чем бы нет.
Проверишь, что это работает?
Ну, хотя, разумеется, должно.
Не вижу препятствий.
Ну, действительно,
Epsilon теперь рисуется с командой EPS.
Можешь сделать так.
Тут дело вкуса, никакой разницы.
Да.
Про команды более-менее все.
Понятно ли еще сейчас?
Ну, вроде понятно, да.
Огонь.
Тогда небольшая настройочка
на тем, что мы только что обсуждали.
Помимо команд, есть такая штука оператора.
Это такая вещь в себе,
чисто из математики пришедшая,
ну, вернее, из математической режимовтики.
Вот мы видели в прошлый раз,
что есть штучки, скажем, как
SinusX,
и что то, что пишется перед X,
вот это вот Sinus, называется оператором.
Эффект, в рамках теха, у него такой.
Он пишет такой эффект,
что он пишет Sinus,
ну или какой-то другой текст,
не курсивом, как обычно в математике,
а прямым шрифтом,
и еще грамотно расставляет пробел
между собственным названием команды и аргументом.
Очень часто бывает нужно,
особенно в алгебре,
задавать свои операторы,
интерфейс у этого такой.
Буквально DeclareMathOperator.
Объявите свой оператор в математике.
У него два аргумента.
Так же, как и с NewCommand,
аргументы прямо в таком же порядке.
Как мы хотим потом к ней обращаться,
а потом тот текст,
который будет написан в оператор.
В данном случае, я хочу скажем,
операторы ядра и образа,
ну поскольку они были в представстве в примере.
Но вот я опасаюсь,
что просто BackslashIm
уже занято под команду
им как мнимая часть комплексного числа.
Это рисует некий спецсимвол,
и в общем, не стоит рисковать.
Как-то вот я не умею делать,
чтобы это было одновременно
и переопределение еще и оператор,
чтобы все работало,
будем делать вот так.
Команда немножко длиннее,
но это ничего страшного.
И вот утверждается,
что нам это даст команды вида Kerr и Im,
которые будут операторами
и будут грамотно отрисовываться.
Опять же скопирую код,
проверю, что все заработает.
Ну действительно все так.
Да, у нас снова плохая буква phi,
потому что я убрал ее переопределение,
главное, что это получилось сделать.
Тоже небольшая настройка.
Как я уже упоминал,
звездочка немножко меняет поведение
некоторых команд.
Тут тоже верно.
Здесь она означает следующее.
По умолчанию, для оператора
верхние и нижние индексы
это верхние и нижние индексы.
Сейчас я сделаю некорректную
отсутствия математики запись,
что значит.
Допустим, у размерности есть
какой-то индекс сверху А,
и какой-то индекс снизу Б.
Для обычного оператора они отрисуются
просто как индексы.
Но бывают операторы, для которых нужно,
чтобы это были прям верхние и нижние пределы.
В чем разница?
Текст рисуется не сбоку от символа,
а прямо под ним и над ним соответственно.
Если я здесь добавлю звездочку,
то...
Сейчас, неправда.
Для Дима это не получится сделать,
потому что это оператор,
который работал с коробки,
он уже был определен для нас.
Я хочу свой определить, давайте
про им говорим.
Сначала был просто им с индексами,
а вот теперь я хочу, чтобы это
были для него пределы сверху и снизу.
Я ставлю звезду, и утверждаю,
что все заработает.
А, тут еще нужна одна оговорка.
Сейчас я в режиме математики
внутри строки.
Внутри строки, что пределы,
что индексы эквивалентны.
Внутри строчная формула,
которая там текст,
потом еще какой-то текст,
и вот оно все рисуется в одну строку
и не парится.
Чтобы эти индексы,
переходящие в пределы,
имели эффект, нужно, чтобы формула
была выключной.
То есть, завернутой в экранированные
квадратные скобки.
Мы это просто раз обсуждали,
что они немножко меняют поведение
в математике.
В частности, вот такой есть эффект.
И теперь у оператора им
есть верх и нижний пределы.
Что бы они не значили,
не очень важно.
Из жизненных примеров, например,
всякие арг-максы, арг-мины
требуют подписи сверху снизу.
Или просто максимум минимум.
Но максимум минимум наверняка
уже есть в стихе.
Я даже в этом прям уверен.
Они точно есть в стихе.
А вот арг-максов, например, нет.
Нужно создавать слой.
Делается это вот так.
Это буду нужно, наверное, раз в жизни.
Но, в общем, можно делать
через свои бинарные операции.
Ну, тут такая же история,
как с операторами,
что вся райтница именно в расположении
пробелов грамотно.
Нужно, чтобы бинарная операция
размещала пробел и перед собой,
и после себя, и чтобы это хорошо
выглядело.
Ну, тут такой пример.
Как это делается?
Снова не комманд.
Обычно не комманд.
Это текст, который будет внутри написан.
В данном случае внутри написанный текст,
это просто процент.
Он экранирован, поскольку
обычный процент в стихе,
он, кажется, в комментарии делает.
Что-то я уже мог перепутать.
Да, в комментарии.
Ну и, разумеется, мы хотим, чтобы
процент, а не начало комментария,
поэтому его экранируем.
Ну и вот уж не буду копировать
такой результат.
Это теоретически может пригодиться,
если в какой-то алгебре занимаетесь.
Я думаю, что про кастомную команду все.
Да, и сейчас разумно спросить,
было ли понятно от этого часть
про операторы и про операции?
Ну, вроде понятно,
но не понятно, когда это прямо
использовать.
Ну, я думаю, что вы в это
прямо уверуете, когда у вас
на всякие операторы будут на алгебре
возникать в больших количествах.
Ну, если вопросов других,
кстати, не того,
где это применять,
а как это реализовывать, нет,
то в общем здорово.
Тут довольно простой интерфейс,
тем более, что есть слайды,
их потом скину, конечно,
можно будет смотреть, пользоваться,
так что выйти, двигаться дальше.
Немножко поговорим про окружение.
Важная вещь, которую
ссылок мы нашли в прошлый раз,
что есть такая штука,
номированные, маркированные списки.
Ну, они делают буквально то,
как они называются.
Есть окружение itemize,
оно делает маркированный список.
Есть окружение enumerate,
оно делает номерованный список.
Каждый элемент списка
начинается с команды item.
Ну, с большим разумеется.
Я могу это скопировать,
проверить, что это
отрисуется так же, как презентация,
но как бы разумеется, должно.
Ну, действительно, мы получили
какой-то список, у которого есть маркеры,
и какой список, у которого есть номера.
Возникает закономерный вопрос,
можно ли сделать маркеры другими?
Можно. Для этого есть у команды item
аргумент опциональный,
то есть в квадратной скобочке заворачиваемый,
в которой пишется далее что-то,
что вы хотите видеть в качестве маркера.
Например, я хочу видеть в качестве маркера
по какой-то причине значок плюс.
Вот тут.
Оставляю там плюс.
И вот теперь у нас вместо точки
это можно заменить глобально
для всего документа,
чтобы прям значение по умолчанию
у item было не вот этими вот точечками,
а какой-то другой символ.
Я про это потом поговорю,
видимо, в рециде, когда будем про счетчики говорить,
тоже не сегодня.
Ну, в общем, такая опция тоже бывает.
Но локально для чего может быть нужно
менять именно в конкретном списке
символы маркеров?
Скажем, вы пишете какое-то доказательство,
скажем, у нас есть какая-то
теорема в прошлом раз,
есть какая-то теорема,
и там есть какое-то утверждение вида,
что там a, a
эквивалентно b.
Ну да, лест-райтера у команды
рисует двустороннюю стрелочку.
И вот когда вы хотите доказывать такую теорему,
вы обычно доказываете сначала в одну сторону,
а потом в другую.
И для этого удобно делать
маркированный список, у которого
в качестве маркеров используется
стрелочка в одну сторону
и в другую сторону.
На всякий случай я их заверну в доллары,
поскольку это вообще говорят символы математики,
и без них они могут просто не скомпелироваться,
сказать, хочу математическое окружение.
Чтобы точно такого не было,
страхуемся.
Лест-райтеру
и то же самое райтеру.
Смотрим, что будет.
Ну, ура,
заменилась на
стрелочки влево, стрелочки вправо.
Мне кажется, у меня даже была эта презентация.
Да, действительно.
Буквально такой же use case.
Если мы хотим доказывать теорему обе стороны,
мы скорее всего сделаем так.
Это очень удобно.
Еще для доказательств типично,
что в правом нижнем уголке доказательства
пишется какой-то значок,
указывающий на его завершение,
скажем, пустой квадратик или
нарисованный квадратик.
Ну, касательно списков,
вот такая история.
Нумерации тоже ее можно сильно регулировать.
Можно сделать так, чтобы она была
не арабской,
а тоже или римской,
или плотненскими буквами,
или как угодно еще.
И более того, если мы делаем вложенные списки,
скажем, enumerate, а внутри него
в качестве одного из идомов
еще один enumerate вложенный,
то вот тогда нумерация в вложенном списке
будет уже другой.
В данном случае будут плотненские буквы.
То есть чтобы тут были, скажем,
римские цифры вместо этого
и чтобы оно было не в скобочках,
как-то через девиз или еще по-другому.
Тоже про это будем потом говорить.
Но в эскавровании в интерфейс
опять же вот такое.
Есть окружение enumerate,
есть команда item,
которая вытеряет отдельные элементы этого окружения.
О, про вложенные тут, конечно, тоже было, да?
Нет, про вложенные не было.
Ну ладно.
Странно, заголовок в вложенные списки,
а про вложенные списки тут нет.
Просто нет примера.
Ну и ладно, пример мы уже привыкли,
так что ничего страшного.
Да, и еще что касается окружений
и что не очень сложно,
как делать свои теоремы.
В прошлый раз я показал буквально пример кода
и просто сказал, что она работает вот так.
Сейчас я предлагаю немножко подробнее
по этому делу пройтись.
Помню.
Есть пакет ams-cm,
ну, особо theorem.
Он позволяет такой интерфейс,
он позволяет сделать свои теоремы
и сначала говорится,
какой далее будет использоваться стиль теоремы.
Это опять же штучка-модификатор,
как, если помните, из сегодняшнего раза,
page-style,
который действует, пока его не переобредит
на что-нибудь другое.
И вот он говорит, что все теоремы,
которые будут дальше объявлены,
вот они будут именно в таком стиле plain.
В стиле plain он получается,
вот этот вот текст теоремы номер такой-то
делает жирным,
а сам текст теоремы просто обычный.
Это скорее полезно,
не только для теоремы,
скажем, я использую для определений
или для замечаний чего-нибудь такого,
но для примера они очень важны.
Пусть будет так.
И сами команды объявления теоремы
выглядят следующим образом.
Эта команда не в theorem,
команда, напомню, без звезды,
делает нумерованные теоремы,
причем нумерация для каждой категории теорем,
ну, то есть для каждого ключевого слова,
которое мы тут напишем,
она будет своей.
Более того, эту нумерацию можно управлять.
Можно сказать, чтобы она
нумеровалась вслед за текущей секцией.
Это делается не за этим аргументом,
который пишется после обязательных.
Если вот я здесь укажу
в качестве этого аргумента section,
я скажу следующее.
Теперь все теоремы категории theorem
номируются так.
Берет номер текущей секции,
потом точка, а уже потом
будет какая-то единица.
Давайте пример кончик приведу.
Пусть есть у нас секция первая.
Есть какая-то теорема.
И еще одна.
Я утверждаю, что это будет теорема 1.1 и теорема 1.2.
Ну, действительно так.
Кстати, я немножко набрал
стиль plane.
Он делает текст самой теоремы крусивно.
Вот.
Ну, опять же, все стили куглиться.
Их-то довольно мало.
По-моему, всего три.
По умолчанию можно делать свои,
но мы это будем позже делать явно не сейчас.
Это не очень просто.
Вот.
Ну и также можно сказать, что
можно унаследовать нумерацию
одной теоремы, одной категории теоремы
за другую категорию теоремы.
Вот скажем, как здесь.
Перед следствием
номируется уже после теоремы.
То есть берется номер текущей теоремы,
даже если он многочительный,
там 1.1, например.
Вот он берется целиком.
И вот уже в рамках него,
через еще одну точку,
номируются объекты категории как короллари.
Тут, наверное, есть пример,
как это будет выглядеть.
Да.
Давайте посмотрим.
Вот я говорю, беги на теорем,
пишу какую-то теорему,
сейчас пока не очень важно,
еще обсудим.
Но главное, что потом я пишу
еще одну теорему ножей категории короллари,
и вот ее нумерация будет такой.
Она возьмет номер текущей теоремы,
и дальше насчет съединиться.
Если там будет еще одно следствие,
будет следствие 1.2.2.
Ну и далее понятно.
Вот.
Да, теперь про доказательства.
Есть такая встроенная теорема,
которая по умолчанию работает
и уже объявлена,
для теоремы из категории proof.
Как раз-таки в конце
всего блока текста пишется,
сейчас сделаю, чтобы это было видно,
квадратный значечек,
ну, типа конец теоремы,
конец доказательств теоремы.
Можно управлять, каким он будет,
переопределяя его,
про переопределение таких вещей
мы будем говорить примерно тогда же,
когда про переопределение маркеров
но вот глобальное отличие такое,
что он сам догадается
разместить в нужном месте
значечек конца доказательства.
То есть, если строк будет много,
так бывает,
и это как раз тоже более типично,
я нагенерю просто какие-то строки,
вот он в конце последней
в нужном месте разместит этот квадратик.
Более того, если последней строкой будет,
ну скажем, какая-то формула,
совершенно неважно, что там будет написано,
поведение изначально будет не очень хорошее.
Он разместит квадратик на
новой текстовой строке.
То есть, он увидит, что последнее,
что происходит в теореме,
не текстовая строка,
он создает слою, пишет на ней.
Это можно обойти, указав в конкретном месте
команду get here.
get – это QED,
сокращение как раз для этого значечка.
Ну, как 4D по-русски,
QED, конечно, как-то переводится в латыни,
сейчас не буду текстово шифровать,
в общем, дело-то на следующее.
Оно говорит, вот пишет квадратик
прямо на этой строке, где я тебе указал.
Не прямо в текущем месте,
но в конце текущей строки.
Это получается как-то покомпактнее,
и мне кажется, лучше, если у вас
доказательство кончается формулой,
или скажем, каким-то маркированным списком,
который тоже до и после себя оставляет
некоторые пробелы,
чтобы не было проблем, лучше делать уже
внутри них get here.
Более того, если я сделаю его даже
на этой теореме, на какой-то строке,
то он ее нарисует там,
ну, некуда деваться,
где сказали, там и нарисуют.
Но это, конечно, не понятно, зачем нужно.
Казалось бы, доказательство нужно сначала
закончить, потом же квадратик рисовать.
Да, про окружение,
ну, по крайней мере, на сегодня тоже все.
Давайте сама спрошу,
было ли понятно.
Там всем было понятно.
Я очень рад, что так.
Ну, и
последнее на сегодня, что стоит обсудить,
это еще немножко побольше проходов было,
чем в прошлый раз.
Во-первых, теки и шрифты.
Мы в прошлый раз говорили про шрифты вне математики.
Но три математики, они глобально,
по крайней мере, те, что простенькие, похожи
и даже пишутся похожими, как я.
То есть, в том числе,
те, что простенькие, похожи
и даже пишутся похожими кавандали.
Скажем, мы видели,
мы точно видели textBF,
мы точно видели textRM
и точно видели textSF.
В математике это делается mathBF,
mathSRM, mathSF.
Еще есть mathBB.
Мы его видели, когда рисовали значок на чисел.
И есть маскал.
Это типа каллиграфические символы.
Когда говорят, там,
какой-нибудь п красивое или красивое,
имеется в виду обычно
маскал.
Либо со шрифтом mathFrag,
но это такой готический шрифт.
В общем, их довольно много,
я тут не все упасал, только парочку примеров.
Они гуглится,
и у всех интервейс одинаковый.
Вот какая-то команда, и дальше,
то, что является ее аргументом,
заворачивается в такой-то шрифт.
Какие бывают use-кейсы?
mathBB нужно на фиг их в множество чисел.
mathBF просто жирная шрифта,
ему обычно всякие векторы матовцы выделяют.
mathRM — это текст,
с шрифт-засечками из обычного текста,
им же рисуются всякие операторы.
Если помните, в прошлый раз мы говорили,
как писать синус разными способами,
и там у нас был синус,
как разовят шрифт mathRM.
Он бывает нужен сам по себе,
и вне операторов.
Пишется вот так.
Есть шрифт без засечек mathSF,
ну, скажем, там,
стандартные символы для мотождания дисперсии
пишутся таким шрифтом,
еще в 30.
Маскал тоже бывает нужен.
Какие нужны.
Можно даже, кажется, делать свои.
Ну, парочку я перечислил,
уж хотя бы так.
Да, опять же, как я уже говорил,
если у нас там mathBBR
очень много переиспользуется,
мы хотим не каждый раз написать,
а завернуть в команду в отдельную,
но мы это уже делать научились.
Мы уже научились делать new command,
backflashr и все такое.
Вот.
И подробнее про пределы.
Это что-то, что сегодня тоже уже было,
случайная вмешка в другой момент.
Человек просто копирует текст,
посмотрю, что будет, и прокомментирует.
Ага.
Как видим, у нас есть
похожего вида выражения,
которые начинаются с sum
и далее к какой-то верхней и нижней индексы,
но пишутся они по-разному.
Они пишутся просто как индексы,
а потом как пределы.
Более того,
когда я точно такую же строку
пишу не как формулу внутри строки в долларах,
а как формула выключенного
в квадратноскопах,
они уже оба оказываются пределами вообще,
и индексов уже каких-то вообще нет.
Сейчас разберемся.
Стоимость на следующий.
По умолчанию вообще никакие способы
сформулировать.
Если у нас есть какой-то оператор,
который был по умолчанию
определен со звездочкой,
то есть для него по умолчанию
индексы верхней и нижней являются пределами,
даже для него в рамках формулы внутри строки
эти индексы в пределы переходить не будут,
будут оставаться индексами.
Если мы хотим это поведение изменить,
мы явно указываем команду limits
сразу после этого оператора,
чтобы даже внутри строки
индексы переходили в пределы.
Делать так вообще говоря не рекомендуется,
потому что это как раз портит все форматирование,
делают строчку очень большой высоты,
у нас расползают строки друг от друга,
внутри текста это не очень хорошо,
но если вдруг вам очень захотелось
и выхода вы другого не видите,
то делается это так с помощью команды limits.
Более того, я подозреваю,
команда limits позволяет пришить индексы
в качестве пределов вообще к любому оператору,
который даже по умолчанию предела не поддерживает,
например, к оператору sinus.
Оператору sinus явно индексы принимают
именно как индексы, а не как пределы,
но вот если я ему с limits,
а нет, не сработало,
но на самом деле слава богу.
Значит, утверждение теперь такое,
limits позволяет менять поведение только у операторов,
которые были по умолчанию с индексами переходящих в пределы,
то есть операторами подзвёдочкой.
Ни для чего другого эта команда не нужна.
И если вы хотите следовать какие-то рекомендации,
как писать не очень страшный текст,
лучше вообще никогда его не использовать,
но если вы хотите следовать какие-то рекомендации,
то лучше вообще никогда его не использовать,
но если вы хотите следовать какие-то рекомендации,
то лучше вообще никогда его не использовать,
потому что если вы его используете,
значит вы где-то внутри статьи хотите сделать очень высокую формулу
и лучше так не делать.
Вот.
Ну и то, что мы уже видели,
когда что-то делали суммами,
когда мне хотелось просто перевести пример,
есть операторы, у которых индексы переходят в пределы,
и по умолчанию формулы на новой строке,
в обычных, они, собственно, переходят в пределы,
так как мы бы и ожидали.
Но при этом, если это будет опять же оператор синуса,
то ничего не произойдет.
Они все еще будут верхними и нижними индексами, не пределами.
Вот.
То есть зависит это в первую очередь от того,
какой у нас оператор, со звездочкой или без.
И даже если мы хотим поведение поменять
с помощью команды limits,
у нас ничего не получится, если вначале этот оператор так не умел.
Если мы хотим, чтобы он так научился,
придется делать как-то ринью комод, как-то переопределять,
и в общем, что-то довольно сложно,
в общем, никогда не писать.
Вот. Это обсудили.
Ну и да, есть команда prod.
Вот есть команда sum, которая рисует большую сигму для суммирования,
а есть команда prod, которая рисует большую букву p для произведений,
ну а слово product.
Да, еще есть лекарственная стрелочка с надписями.
Ну, тоже бывает нужна всякая алгебра.
И есть два интерфейса.
Ну, просто два разных способа это делать,
в зависимости от того, как вам больше нравится.
Если вы хотите, чтобы ваша стрелочка была обычного размера
и просто как-то подписывалась,
то вы просто берете и пишете верх-нижний, нижний индекс.
Стрелочка это не оператор.
Вернее так, уж точно не оператор с оведочкой.
Поэтому для нее это будут просто верхние-нижние индексы,
а не прям текст сверху и прям снизу.
Если мы хотим, чтобы был текст сверху или снизу,
это уже будут не обычные стрелочки, а стрелочки,
которые начинаются буквы x.
Вот.
Ну вот, можно просто сравнить две строки.
сравнить две строки, они отличаются примерно только этим. Ну ладно, еще тем, что на самом деле вот у этой команды
собственно текст сверху и снизу является уже не индексами вообще, а специальными аргументами, причем что
характерно аргумент подпись снизу обязательной фигурной скобки, а подпись вверху не обязательной
квадратной скобки. Ну видимо это сделали так просто чтобы можно было друг от друга отличить,
не знаю как это еще объяснить. Ну вот так это работает, ничего сложного. И да, тут еще один
комментарий, который я уже говорил, лучше так вообще говоря не делать. Лимит лучше не использовать,
стрелочки которые пишут текст над собой тоже лучше не использовать, ну по крайней мере если делать
внутри строки, потому что это просто расползает строку в высоту, это не очень красиво. Далее,
ну всякие есть модификаторы начертания, которые рисуют над символом что-то. Точку типа там,
производная по времени, там две точки, есть мастеринг, ну как может быть уже там какие-то проколы
и окрестности, вот там это возникает. Просто всякие модификаторы, которые к текущему символу
прорисовывают что-то. Тут такая сладочка, как это можно по-разному делать, какой это имеет эффект.
И есть вот такой комментарий, что есть просто хед, а есть y-хед, в чем разница? Просто хед рисует
крышечку фиксированного размера над текстом любого размера. Да, здесь я как бы не указываю
фигурные скобки, но они всегда есть. Это всегда символ a является аргументом предыдущей команды,
будь то мастеринг, хед, ну и так далее. А вот если я хочу чтобы у меня большим текстом была
большая крышечка, то я использую y-thed соответственно, чтобы она растянулась на тот размер, который мне
потребуется. Тут я обновить забыл, тут должна быть конечно длинная тильда, то есть есть такие же
аналоги, y-thed, длинная тильда, есть команда bar, которая делает фиксированного размера черточку,
есть overline, которая подчеркивает сверху весь текст. Ну так же как underline, такая же логика. И есть
также overwrite arrow, которая рисует прям большую стрелочку над текстом. Что характерно, как видим,
overwrite arrow сделала последнюю строку больше по высоте, она как-то от других отползла. Это как бы
намекает, что overwrite arrow тоже не стоит использовать внутри строки, а только формулах, которые на своей
строке, иначе высота у вас тоже попалдит. Ну и опять же это все будет в флайдах, можно будет
пользоваться, все такое. Да, и тут еще, ну уже так, в заключение есть всякие эквиваленты окружения
из экранированных квадратных скобок для математики, которые немножко по-разному себя ведут,
если у нас возникает необходимость писать много строк в математике подряд. Вот тут я перечисляю много
разных, ну дальше попробуем просто их действия. В-первых, есть окружение begin and equation. Это полный
эквивалент квадратных скобок. То есть то, что внутри этого уже считается математикой,
никакие доллары, никакие другие идентификаторы этого не нужны, оно уже математик. Но вот такая
незадача, теперь эти формулы стали нумероваться. Equation – это нумерованное окружение. Про то,
как с этой нумерацией работать, как к ней ссылаться и все такое, мы еще поговорим, потому что точно не
сегодня. Если мы хотим, чтобы ее не было, я как-то чаще как раз так и делаю. Я делаю окружение с
звездочкой. Как всегда, звездочка немножко меняет поведение. В данном случае она все, что она меняет,
убирает нумерацию. Далее есть многосрочное окружение, которое уже больше отличается от equation.
Например, align. Если мы пишем что-то на одной строке, скорее всего, мы ранницы не заметим.
Давайте проверим. Да, ранницы мы не заметили, за тем исключением, что нумерация снова появилась,
потому что нет звездочки. Что делает align? Он берет, если мы пишем несколько строк,
пишем их снова через двойные бэкслэши, как в таблицах. Снова еще один случай, когда двойной
бэкслэш имеет какое-то перегруженное значение. В данном случае такое. Допустим, три раза подряд
напишем одну и ту же строчку. align возьмет их все и выровняет, кажется, по левому краю. Давайте
проверить. По умолчанию он равняется иформам по правому краю. Если мы хотим этим управлять,
есть такая штука снова амперсанды, здесь имеют немножко другое значение. Здесь амперсанд говорит,
вот равнять будем по этому символу. То есть там, где я поставлю амперсанд, он выровняет все амперсанды
по одной вертикальной прямой, а весь текст отрисует так, чтобы это выравнивание сохранилось.
В данном случае амперсанды у меня предшествуют символом равно и равно на строках верхний и нижний
и символу B посередине. Как видим, немножко сбонтовался, немножко он влево сдвинул. Но
в всяком случае, как видим, он сильно приблизился к тому, чтобы выровнять буквально по одной
вертикальной прямой. И что-то сходу не соображу, в чем разница, почему он сдвинул B еще немножко левее.
Ну ладно, это не очень важно. Более часто кейс выравнивать все-таки не по каким-то обычным
символам текста, а по каким-то операторам, скажем, плюс или равно, в таком случае точно будет
корректно работать. Ура, прям видим ровненькая вертикальная прямая, на ней находятся равно,
плюс и равно, потому что мы их выделили амперсандами. И да, нумерация, в случае
алайна, действует в поединке для каждой строки. Если мы хотим ее убрать, мы делаем вот так.
Как сделать нумерацию только для одной строки? Я сейчас как-то подзабыл, никогда этим не
пользовался. Я еще раз этим вопросом займусь и расскажу, если вам это потребуется. Есть похожее
на него окружение, тут я его даже не указал, gather, оно делает то же самое, что align, только равняет
по умолчанию не по правому краю, а по середине. Вот мне чаще им приходится пользоваться как-то
посимпатичнее по правому краю, но вот здесь уже управление амперсандами не работает. Gather,
он только по центру и больше никак. Есть также окружение mouthline, это для одной длинной формулы,
которая пишет несколько строк. Допустим, у вас там a, plus b, plus c, plus и так далее,
то dots будем писать корректно. И вот хочется продолжить на новой строке, и продолжаем.
Допустим dots, plus, d, plus e, plus f, plus dots. Допустим plus, z, последний буквал фрита, равно 0.
Что делает mouthline? Он сделает так, чтобы середины всех строк, у меня всего три строки, чтобы середины
всех строк находились на одной диагонали из левого верхнего угла формулы, вправо и нижний.
Давайте посмотрим. Да, тут формула просто не очень длинная, не очень длинные кусочки, но что она
сделала? По одной диагонали, как я сказал, выровняла центр всех строк. Это было полезнее и осмысленнее,
будь у меня прям выколотка на целую строку, и здесь, и здесь, и здесь, тогда будет выглядеть очень
симпатично, и тогда очень рекомендуется пользоваться этим окрушением. Ну и снова
про нумерацию. Если звезды не будет, нумерация появится, причем на этот раз уже одна на всю формула,
поскольку это единая формула, но то это и mouthline. Ну еще есть aligned, это его эквивалент, но не так,
aligned это эквивалент окружения aligned, но он используется внутри какой-то другой формулы.
Скажем, нам здесь потребовалось внутри еще сделать ну какое-то подокружение, чтобы зачем-то написать
вот две строки рядышком что-то, тогда мы сделали бы begin aligned и end aligned. То есть разница в том,
что по умолчанию внутри aligned не включается математика сама по себе. Можешь, конечно,
так подсвечиваться, но просто не скомплируется. Для использования вовне нужно делать align,
aligned для использования внутри чего-то еще. Еще есть штучка cases, она нужна для указания
f от x равно и далее разные случаи. Давайте тоже нарисую, почему бы нет. Есть такое окружение cases,
оно тоже уже как aligned живет только внутри другой математики. Допустим, f равно, тут скажем 1,
допустим, если x равно 0, снова новая строка, 0, если x не равно 0. Да, ne это not equal. Посмотрим,
что получится. Ну вот, окружение cases сделало нам фигурную скобочку и разместило строки друг на другу.
Больше ни для чего эта штука не нужна. Но вообще-то грамотнее, если мы хотим записывать условия,
то есть 1 в случае таком-то, если x равно 0, 0 в случае таком-то, если x не равно 0,
условия лучше поставить просто амперсанда. Это просто немножко поменяет правила размещения.
В общем, они будут равняться немножко иначе. Будет некий пробел, причем правильного расстояния,
если у нас будет какое-то длинное выражение, то он сделает так, чтобы они были на одном расстоянии,
вот эти вот два условия. В общем принято делать так. Это специальное окружение,
которое для такого предназначено. Им рекомендуется пользоваться, все такое. И кажется,
что на сегодня я все рассказал, что хотел. Да, действительно. Но на всякий случай,
есть ли вопросы по последней части? Тут вроде бы все прозрачно, просто нужно посмотреть слайды
и попользоваться. Так, я так понял. Все кроме aligned и cases, они автоматически включают
внутри себя математический режим? Да, все так. А вот эти две надо использовать внутри математической?
Да. Ну для cases это прямо очевидно, поскольку это нужно для записи какого-то кусочка формулы,
вида что-то равно чему-то в разных случаях. И у тебя не получится это сделать, если ты уже не
был в математике до этого. Поэтому cases по умолчанию считается уже в ложную математику. Для aligned,
ну просто нужен был какой-то эквивалент aligned, но который при этом можно делать в ложную.
Aligned в ложную быть не умеет, потому что скажет, я включаю математику, она уже включена,
как такое может быть. И не скомплируется просто. Понятно. Ну, здорово. Тогда думаю,
что на сегодня можно заканчивать. Спасибо за присутствие. Буду всех ждать в следующий раз.
