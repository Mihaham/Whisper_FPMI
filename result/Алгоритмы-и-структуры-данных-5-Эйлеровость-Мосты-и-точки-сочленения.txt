Я продолжаю говорить про DFS-like алгоритмы. Начнем с
эйлеровых циклов и путей. Эйлеровые циклы и пути.
Самое определение. Эйлеров цикл — это просто цикл, который проходит по всем ребрам графа ровно один раз.
Эйлеров цикл — это цикл, проходящий по всем ребрам графа ровно один раз.
То есть какая-нибудь картинка такая, пусть, например, будет.
Что-нибудь такое. Если это, например, стартовая вершина, можно вот так обойти все ребра графа,
вернуться туда же, откуда начали, получить цикл. Мы заканчиваемся там же, где начали.
И при этом каждый реброр ровно один раз в нашем цикле поучаствовал.
Аналогичное определение эйлеров-путь. То же самое, только это путь, проходящий по всем
ребрам ровно один раз. Не буду писать, скажу, что эйлеров-путь аналогичен.
И есть очень простой критерий существования эйлеров-пути, эйлеров цикла. Мы его сейчас докажем
и предъявим конструктивный алгоритм нахождения эйлерового цикла, что в ориентированном,
что в неориентированном графе. Здесь мне надо предварительно сказать пару слов,
которые наверняка вы знаете, но на всякий случай для формальности ввиду.
Это степень вершины. Это просто количество ребр, которые из нее торчат.
В случае ориентированного графа, это суммарное количество —
сколько ребер входит, сколько выходит. В случае неориентированного графа —
это просто н horizont на этой вершине, сколько ребер содержит ее как один из своих концов.
То есть формально давайте для ориентированного случая напишу,
например, степень вершины v это просто количество таких e, маленьких из e большого,
что v... ну я все равно так напишу, v принадлежит e.
Потому что e это у меня пара упорядоченная или неупорядоченная,
в случае ориентированного графа упорядоченная.
Ну вот, соответственно, в скольких парах v участвует как один из элементов пары?
То есть буквально где она участвует?
То есть она может участвовать как вторым элементом пары,
то есть когда в нее идет ребро, или первым, когда из нее выходит ребро.
Суммарное количество ребр это степень,
ну а если я живу в ориентированном случае,
и мне хочется посчитать суммарное количество входящих и исходящих,
то это называется, соответственно, входная и исходная степень, исходящая степень.
Я это буду обозначать in degree это входная степень,
и out degree это исходящая степень.
Сколько ребр входит в вершину, сколько ребр выходит из вершины.
Ну, наверное, значит в какой-то степени вершина, да?
Вот, хорошо.
Ну и теорема.
Давайте я сформулирую две штуки отдельно для ориентированного, для неориентированного случая.
Теорема первая.
Эйлеровость в неориентированных графах.
Тоже наверняка где-то слышали.
Я утверждаю следующее.
Во-первых, ну, начало, пусть же это неориентированный граф,
тогда в нем есть эйлеров цикл.
Если только, если верно, следующее.
Ну, почти, да.
Граф G после удаления изолированных вершин становится связным,
и степень каждой вершины четна.
Граф G после удаления изолированных вершин
становится связным,
и для любого V степень V четна.
Ну, потому что нам связанность нужна.
Если граф не связан, то там эйлерово... эйлерово цикла нет.
Еще раз, если у вас граф...
Смотрите, вам надо добавить требования связности,
потому что без связанности, например, если у вас просто там два цикла,
то понятно, тут нет эйлерово цикла в таком графе.
Поэтому связанность вам нужна в каком-то виде.
Ну, а если вы требуете связанности, и у вас есть изолированные вершины,
то это тоже некорректные условия, потому что если у вас есть цикл изолированных вершин,
то это граф эйлеров, потому что вот, пожалуйста, эйлеров цикл, который все проходит.
Поэтому единственное замкнутое требование на граф для наличия эйлерово цикла вот такое,
что можно выкинуть изолированные вершины изолированными,
как раз те, у которых вообще нет ребер, у которых степень нулевая.
Вот мы их все удаляем, понятное дело, потому что они не влияют на эйлеровость,
их не надо обходить вообще, они как бы для графа несущественны.
Дальше понятно, что граф должен получиться связанным,
потому что иначе, если есть две какие-то компоненты, одна другая,
мы не сможем одним циклом их все обойти.
Ну и в чётной степени понятно более-менее, потому что если у нас есть цикл,
то мы в каждую вершину зашли и вышли, возможно несколько раз,
то есть возможно там мы можем как-то петлять, не знаю, вот что-нибудь такое может быть.
Но тем не менее мы в эту вершину вышли, зашли, вышли, зашли.
Поэтому суммарное количество посещений вершины будет чётное, значит степень должна быть чётная.
Вот, значит это для случая цикла, для случая пути,
ну верно всё то же самое, только возможно для каких-то двух вершин степень нечётная.
Значит уже есть эллеров путь, если только если.
Ну выполняется всё вот это вот, давайте я это просто скопирую.
И у всех вершин, кроме быть может двух, степень чётный.
У всех вершин, кроме быть может двух, степень чётный.
Ну это как раз соответствует какой-то вот такой картинке, давайте нарисую.
Знаете, какой-то старт и финиш, то есть начало и конец эллерово пути.
Такой, что суммарно он покрывает все ребографы по одному разу.
Ну и тогда понятно, что здесь у всех промежуточных степень чётная,
потому что мы зашли, вышли в вершину, возможно несколько раз, но суммарно, понятно,
чётное количество раз как бы сквозь неё прошли.
Ну это верно для всех вершин, кроме вот этих двух, кроме СТ.
Соответственно путь есть, если, ну либо вообще в идеальном мире, если есть цикл,
потому что понятно, если есть цикл, то есть и путь, цикл в частном случае пути.
Ну либо же содержательно, цикла нет, а путь есть, тогда это какая-то такая картинка,
что есть две вершины нечётной степени, а все остальные чётные.
Похоже на правду? Ещё раз? Одной вершины нечётной степени быть не может,
по алеме рукопожатиях у нас сумма всех степеней чётная обязательно,
значит если есть одна нечётная, то есть обязательно дополнительная вторая,
поэтому если есть одна, то есть другая.
Вот, ну и очень похожая теорема для эйлеровости в ориентированных графах.
Ещё раз? Ещё раз?
Должен, почему же? То же самое, то же самое требование,
значит мне надо проходить по всем ребрам ровно по одному разу.
В смысле, если просто цикл, ну цикл это частный случай пути, это же путь, правильно?
Путь это по сути вершина такая, что любые два седа соедены ребром,
поэтому цикл частный случай пути.
Вот, ну значит здесь опять пусть же это уже ориентированный граф в этот раз,
значит тогда в нём есть эйлеров цикл,
если и только если, ну опять, после удаления всех изолированных вершин,
то есть вершин степени ноль, граф становится сильно связным,
я не могу говорить про ориентированный граф, слово просто связанный,
потому что связность в ориентированном случае это что-то странное,
мы определялись в прошлый раз в сильную связность, вот ровно оно,
и плюс у каждой вершины должна быть входящая степень равна исходящей,
то есть сколько раз вершины зашли, столько раз и вышли, это критерий эйлерового цикла.
Значит, граф G, после удаления всех изолированных вершин становится сильно связным,
ну то есть между любой парой вершин есть путь в обе стороны,
да, и при этом для любой вершины V входящая степень равна исходящей,
потому что если у меня есть цикл, и я в какую-то вершину много раз захожу,
то количество входов должно быть равно количеству выходов,
потому что у меня, грубо говоря, нет конца, нет начала у цикла,
если я зашел, то я должен смочь выйти, если я опять посетил,
то я опять дальше могу пойти вдоль какого-то нового ребра.
Ну и случай пути, собственно, аналогичен, либо верно все то же самое,
либо вот какая-то такая же картинка, только в этом случае уже требования на S это немножко другие,
на S должно быть требование такое, что у него исходящих на 1 больше, чем входящих,
а у T, наоборот, входящих на 1 больше, чем исходящих.
Ну давайте я не буду полностью формулировать про путь аналогично,
только вот в случае, когда реально путь, а не цикл,
на S и T немножко другие условия, но могут быть две вершины, могут быть вершины S и T,
такие, что у S исходящая степень на 1 побольше, чем входящая,
а у T, наоборот, исходящая на 1 меньше, чем входящая.
Ну тоже, значит, картинка такая же, если у вас представьте та же картинка,
только она теперь ориентированная, у вас все ребра ориентированные,
тогда у вас понятно, что для всех промежуточных вышин на 5 вы сколько раз зашли, столько раз и вышли,
а для S вы вышли на 1 раз больше, чем зашли, потому что вы оттуда начинаете, вы в нее не входите, но выходите,
соответственно, на 1 раз больше вы из нее вышли, и в T, наоборот, вы входите на 1 раз больше, чем выходите.
Ну вот. Да.
Нет, все то же самое, вот это копируется точно так же.
Да, справедливо, справедливо, справедливо, справедливо, вы правы, конечно.
Ой, да, надо это латать, конечно.
Ну конечно, да, конечно, конечно.
Так, ну вообще в оригинальной постановке вот здесь вместо сильной связанности пишется слабая связанность.
Слабая связанность, когда вы игнорируете ориентацию ребер, ну типа стираете стрелочки на ребрах
и говорите, что он должен быть связан после удаления ориентации.
Ну давайте здесь тогда это пропишу. Здесь это неважно, потому что в цикл там все равно есть пути во все стороны,
потому что все в одном цикле лежит.
И здесь давайте это пропишем, что вот в этом случае, видимо, если есть одна такая вершина,
то из С должно быть все достижимо, можно так сказать.
В этом случае из С должно быть достижимо все.
В этом случае из С должно быть достижимо все.
Ну, так можно сделать.
Давайте потихоньку доказывать.
Ну смотрите, вот первую я оставлю, она доказывается абсолютно аналогичной на второму.
Давайте для ориентированного случая докажем только.
И давайте сразу сведем пункт В к пункту А.
Как можно свести поиск пути к поиску цикла?
Прикумать еще далеко, да, еще соединить вот эти две вершины.
Да, да, да, да, да.
Потому что вот если у меня есть вот эти две вершины, где должен начинаться и кончаться путь,
то давайте мы проведем ребро из одной в другую, и тогда мне нужно будет найти уже цикл.
То есть если у меня граф какой-то вот такой, я понимаю, что начало здесь, а конец здесь,
ну, в случае ориентированного графа,
тогда я могу просто добавить одно вот такое ребро из ТВС.
Тогда у меня все вот эти вот равенства превратятся в обычные, когда in degree равно out degree,
входная равна исходящей, и достаточно найти цикл.
Ну и понятно, если я его здесь найду, то просто удаление этого ребра мне даст путь из СВТ.
То есть любой какой-то здесь был путь, я его дозамыкаю ребром до цикла,
и потом, если я в этом графе нашел цикл, то после удаления ребра я получаю как раз путь из СВТ.
Ну вот, в этом смысле как бы путь не сложнее, чем цикл,
поэтому давайте жить в парадигме, что я ищу циклы леверов.
Окей?
Вот, хорошо, теперь я доказываю пункт А.
Ну, в одну сторону я уже проговорил, что слева-направо более-менее очевидно,
потому что если есть error of cycle, то у всех содержательных решин входная степень равна исходной исходящей.
То есть если есть какой-то граф, то сколько раз зашли, столько раз вышли.
Вот, интересно, в обратную сторону.
И в обратную сторону мы предъявим просто алгоритм, который находит error of cycle.
Предъявим алгоритм.
То есть я считаю, что граф вот такой,
он хороший, после удаления из СВТ сильно связан,
и любой вершины исходящей равна входящей.
Как тогда найти error of cycle?
Ну, давайте сделаем следующее.
Давайте запустим такой тупой DFS без запоминания вершин.
То есть давайте просто запустим какой-то обход графа, который идет по ребрам.
Ну, понятно, ребра нам нельзя переиспользовать,
поэтому как бы по ребрам он идет только один раз,
но он не запоминает вот эти вот метки посещенности вершин.
Если он когда-то видит ребро в вершину, даже в которой он когда-то бывал,
то он все равно идет вдоль этого ребра.
То есть, ну, такой давайте напишу, в кавычках DFS без запоминания.
Потому что у меня DFS всегда был такой, что я дохожу до вершины
и не иду туда, где я уже был.
То есть я не иду в небелые вершины в DFS.
Ну, типа того, да.
То есть я просто не говорю, что у меня есть какие-то цвета,
и просто вижу новое ребро, иду вдоль него, запускаюсь рекурсивно вот в этой новой вершинке.
То есть, ну, там, не знаю, какая-нибудь процедурка у меня есть.
Ailer, какой-нибудь error of cycle от вершины В.
Значит, что он делает?
Это функция рекурсивная.
Находит произвольное неиспользованное еще ребро из вершинки В,
то есть ребро, которое мы еще не обошли.
И запускается рекурсивно вот от этого конца этого ребра.
То есть, просто находит первое неиспользованное ребро и идет сюда.
Запускается отсюда рекурсивно.
Ну и так делает, пока есть неиспользованный ребро.
Так, давайте я какое-то подобие кода напишу.
Значит, у меня есть код.
Так, давайте я какое-то подобие кода напишу.
Ну, во-первых, я, видимо, скажу, что у меня в каждой вершине есть некий счетчик,
который указывает на первое неиспользованное ребро.
То есть, ну, понятно, у меня из этой вершины все исходящие ребра пронумерованы как-то,
ну, потому что они лежат в каком-то там списке, в каком-то массиве.
Значит, они пронумерованы.
Давайте хранить просто номер первого неиспользованного.
Пусть ptr от v.
ptr от v – это номер первого неиспользованного ребра в g от v.
То есть, в списке исходящих ребер из вершинки v.
Ну и тогда вот эта процедура поиска лидерного цикла.
Так, давайте я еще вот здесь вот передам вторым параметрам.
Я добавлю сюда parent edge.
Давайте так его назову.
То есть parent edge.
То есть это ребро, по которому мы вошли в эту вершинку.
То есть я зашел в вершину v с помощью какого-то ребра вот эта вот parent edge.
parent edge.
Вот.
Значит, тогда эта процедура делает следующее.
Пока ptr от v не равен к концу этого списка, то есть пока есть неиспользованные ребра,
идем вдоль ребра с номером ptr от v.
То есть пока ptr от v не равно…
Ну давайте напишу out degree от v.
То есть не равно количеству исходящих ребер.
Я просто получаю вот это вот очередное ребро.
Значит, пусть e это ребро вот с этим вот номером в списке g от v.
Давайте же g vt от ptr от v.
То есть я получил очередное ребро, исходящее из вершинки v.
И просто иду вдоль него.
Предварительно сдвину в счетчик, потому что вот я взял очередное неиспользованное ребро.
Мне нужно увеличить счетчик на единичку, потому что все, я теперь его использую.
Запускаю рекурсивно от конца этого ребра.
То есть увеличиваю счетчик на 1.
Вот.
И просто рекурсивно, не думая, запускаюсь от конца этого ребра.
Ну, давайте напишу e.to, давайте напишу e.second и e.
То есть я запускаюсь от конца этого ребра, зная, что я пришел в него с помощью вот этого ребра.
Это while.
И все, в конце, когда я обошел все исходящие ребра, когда я просмотрел все исходящие ребра,
от всех запустился рекурсивно, я просто...
Давайте в какой-нибудь список добавлю вот это вот ребро parentage.
Давайте какой-нибудь order, pushback, ребро, с помощью которого я зашел в вершинку v.
Пример, как это работает.
Вот такой граф нарисую.
Вот что-то такое.
Давайте предположим, что изначально наша процедура, наш вот этот вот обход рекурсивный запустился отсюда.
Что он делает?
Он просто берет первое попавшееся неиспользованное ребро, идет вдоль него и пытается этот путь как-то продолжить.
Ну, вот, например, давайте предположим, что этот обход как-то вот так вот проходил.
Он пошел сюда, сюда, потом здесь у него был выбор, ну, например, он пошел сюда, потом сюда.
Когда-то он еще раз запустился, наша функция error сначала запустилась отсюда, отсюда, отсюда, потом прошла сюда.
И еще раз запустилась вот отсюда.
В этот момент я понимаю, что я обошел все исходящие ребра из данной вершины.
Все ребра, которые были, я уже обошел, у меня ptr от v равен количеству исходящих ребр.
То есть у меня больше нету неиспользованных исходящих.
Тогда я говорю, окей, значит, я обошел все, что можно.
Я откатываюсь в рекурсии на шаг назад, то есть у меня эта рекурсия завершается, я возвращаюсь вот сюда вот.
И в список order добавляю вот это вот ребро.
И это ребро будет последним ребром error-го цикла, который я нахожу.
То есть я нашел вот это ребро.
Дальше здесь то же самое, я поднялся в рекурсии сюда.
Отсюда все исходящие ребра уже перебраны.
Поэтому рекурсия завершается, и в order добавляется вот это вот ребро.
Теперь моя рекурсия поднимается до вот этого вот запуска.
Я прошел сюда, здесь все обошел.
Теперь у меня есть возможность идти дальше, но только вот сюда вот.
Например, пусть этот обход пошел вот так вот, вот так вот, вот так вот опять.
Тогда опять мы рекурсивно пришли сюда.
Видим, что в этой вершине уже больше нет ни одного исходящего ребра.
Поэтому я просто в список order добавляю последнее вот это вот ребро.
Потом откатываюсь сюда, откатываюсь сюда.
Ну и здесь то же самое.
У меня здесь aler пытается найти вот этот путь, то есть находит этот путь.
И затем рекурсия разворачивается, и эти ребра добавляются в order в обратном порядке.
То есть вот это, вот это, вот это.
Потом отсюда опять же все ребра уже перебрали.
Но ребро, с которым я прошел сюда, было вот это вот.
Потом я откачусь вот до сюда, откачусь вот до сюда.
Получается, что у меня в список order добавляются, ну как бы в противоположном порядке,
как раз ребра вот этого вот alero цикла.
То есть если я в конце, значит в самом конце я делаю реверс всего вектора order,
тогда в нем будет лежать список ребер на alero цикле.
Вот, сейчас докажу.
Понятно, как работает?
Ну хорошо, значит давайте.
Да.
Это скорее список смежности, как обычно gout v, это список как бы всех ребер,
исходящих из вершины.
А, ну я имею в виду, что gout v это список ребер, исходящих из вершины.
Вот у меня есть вершинка v, вот у меня есть исходящие ребра из нее.
Пусть все они лежат в неком списке gout v.
Что такое ребро? Ребро это по факту, ну там, какая-то структурка, не знаю.
Откуда, куда и номер ребра.
Или там какие-то еще характеристики, если надо.
Вот. Ну second, в смысле, куда оно ведет.
Могу написать точка to, то есть то, куда ведет ребро.
Значит, по факту я просто беру очередное ребро, e.
У него есть начало, есть конец, вот конец это там, точка second.
Ну а само ребро это ребро e.
Нормально?
Да, да, да, да. А точка second это конец ребра.
Да. Я каждый раз, когда прохожу очередное, я его увеличиваю.
Ну вот, значит, почему это будет реально eiler's?
Почему в конце, если я разверну order, почему это будет у меня eiler's cycle?
Ну, смотрите, давайте поймем какое вообще ребро самым первым добавится в order.
То есть как у меня работает алгоритм, он что-то там ходит ходит по графу.
И когда-то, вот в первый момент времени, дошел до вершины,
у которой все исходящее уже были просмотрены.
То есть он ходил, ходил, ходил... возможно запускался много раз в одной из вершины.
И когда-то дошел до такой вершины, у которой все исходящее уже были просмотрены.
То есть я от них от всех запустился как-то рекурсивно.
Вот я утверждаю, что эта вершина обязательно будет вот эта вот из которой я начал.
То есть если я изначально запускаю какой-то вот айлер от вершинки s,
то первое добавленное в ордер ребро будет обязательно ребро ведущее в s.
Ну почему? Потому что как у меня устроен алгоритм?
Вот я встал в s и как-то иду просто по ребрам вдоль какого-то пути.
Возможно там зацикливаюсь, запускаясь многократно от вот этих вот вершин.
Вот, но понятно, что я всегда могу продолжить путь,
коль скоро у меня выполняется вот это вот требование,
что входная степень равна исходящей.
Значит, если я пришел в вершину с помощью какого-то ребра,
то у меня обязательно есть еще какое-то неиспользованное исходящее,
потому что когда я попадаю в вершинку, значит я нашел какое-то входящее,
значит есть обязательно к ней в пару какое-то исходящее ребро.
И получается из всех вот этих вершин, я если пришел, то я обязательно смогу выйти.
Единственная вершина, для которой это неверно, это s,
потому что я начал с того, что откусил у нее одно исходящее ребро.
Значит, когда-то, возможно, я могу сюда вернуться и дальше не смогу продолжить этот путь,
потому что у меня уже вот сейчас уравнялось количество найденных входных и исходных.
А, да, для всех остальных я всегда смогу продолжить путь.
Значит, вершина, на которую я закончусь,
точнее впервые напечатаю какое-то ребро, добавлю какое-то ребро в ордер,
это обязательно вершинка s.
Вот я обязательно найду в конце какое-то ребро, ведущее в s.
Давайте запишем это, что первое добавленное в ордер ребро,
это обязательно ребро в s.
Так, хорошо.
Еще надо заметить, что таким образом мы точно уж пощетим все ребра.
Потому что по факту это какой-то тупой DFS, который обходит все, что можно.
Можно, ну как бы понятно, что если что-то достижимо, то наш алгоритм точно эту вершинку найдет.
Ну и значит там просмотрит все исходящие из нее ребра.
Поэтому в этом вот ордере точно будут все ребра,
в ордере будут точно все ребра, значит вопрос в каком порядке они там будут.
Более того, в итоге ордер содержит все ребра.
Ну и надо доказать, что они там в правильном порядке лежат.
То есть до этого, до реверса, там реально какой-то путь в обратном порядке написан.
Сначала последнее ребро, потом предпоследнее, вот это, вот это и так далее.
Ну, доказывается более-менее так же, как мы понимали, что последнее ребро обязательно ребро в S.
Вот пусть мы поняли, что в ордер я в каком-то порядке добавляю какой-то вот такой вот путь,
ну там какой-то конец эйлерового цикла, то есть ну там что-нибудь такое, например.
Вот как-то я вот так вот их в обратном порядке добавлял.
Тогда если этот путь, что-то вот такое начинающееся не в S, то есть в какой-то еще вершинке T,
тогда, ну то есть, что это значит?
Значит, что я когда-то запустился эйлером от T,
прошел вдоль этого ребра, там как-то позапускался,
и все, для всех этих вершин уже просмотрел все исходящие ребра, и значит эти ребра добавил.
Теперь дальше что я могу делать, как у меня дальше работает эйлер от T?
То есть он вот по этой веточке запустился, там обошел все, что можно.
Дальше, возможно, он пойдет сам по каким-то другим веточкам, и что-то обойдет.
Ну, тогда понятно опять же, что первая вершина, которую он найдет без исходящих ребр, это может быть только T.
Ну, потому что, что значит, как работает эйлер от T?
То есть он сходил туда, там уже все посетил.
Дальше он, ну опять, возможно, ходит какие-то ребра, ходит по каким-то путям, возвращается в T.
Куда-то еще пошел, опять вернулся в T, ну и так далее.
И, как обычно, поскольку у меня все степени, исходящая степень у всех одинаковая,
то, значит, я обязательно смогу продолжить свой путь,
ну, кроме, возможно, случаев, когда я нахожусь в T.
Потому что сейчас у меня у всех вершин уравнен баланс между входящей и сходящей степенью.
Вот, значит, если в order лежит в развернутой порядке путь от T до S,
то, значит, очередной вызов эйлер от T,
ну, точнее, не так, да, то следующее добавленное ребром может быть только ребром в T.
Потому что я обошел что-то, да, вот у всех вот этих вот вершин, которые я уже просмотрел,
от них эйлер завершился и какие-то ребра намчат.
Значит, у всех этих вершин уже просмотрены все ребра, все исходящие ребра точно просмотрены.
Возможно, у T не все просмотрены, но если я нахожу какое-то новое непросмотренное ребро из T,
то я запускаюсь и обязательно вернусь в T, потому что у всех вершин вот этих вот,
ну, сюда я попасть не могу.
Сейчас, секунду, почему я сюда не могу попасть?
Нет, я могу туда попасть, это я не правда говорю, конечно.
Вот, не, все, сори.
Значит, на самом деле я что сказал?
Я для всех вершин, даже вот для этих, я изменил входную и исходящую степень на одну и ту же величину.
То есть вот здесь вот я учел по одному ребру,
здесь для этого вершинка я учел два входящих и два исходящих, ну и так далее.
То есть у меня нарушено неравенство между входящей и исходящей только для T сейчас.
Ну вот, значит, я вернуться, как бы я завершиться могу только в ней опять.
Поэтому следующее ребро, которое я добавляю в ордера, оно будет какое-то ребро в T.
Как-то так.
Ну, смотрите, для S оно нарушено, но можно сказать, что мы в S больше никогда не зайдем,
потому что, ну, до S я просто не могу больше добраться,
потому что если я напечатал вот это ребро, значит, я из S исчерпал все исходящие ребра,
а значит, я исчерпал все входящие тоже.
Поэтому больше я в S не попаду.
Значит, только для T эта проблема.
Ну, то есть только T может напечататься.
Ну вот.
Что-то понятно?
Хорошо.
Ну, вот тут как бы тут очень простой алгоритм,
но если задуматься, непонятно, почему он работает,
но я вроде попробовал объяснить.
Вот, все.
Ну, понятно, что эта штука работает за линейное время.
Симптотика алгоритма, конечно, N плюс M,
потому что, ну, понятно, каждое ребро один раз просматривается.
Даже можно сказать просто O от M,
потому что в случае Эйдерова цикла мне нужна связанность,
ну, там, сильная связанность или просто связанность в случае обычного графа.
Если граф связан, то там ребер хотя бы столько, сколько вершин,
ну, возможно, минус одно.
Короче, это можно опустить.
Ну, неважно, поскольку я все равно завожу там какой-то список,
для каждой вершины список исходящих ребер,
то N в каком-то виде присутствует.
Пусть она будет.
Вот.
Ну, все.
Туда еще раз проговорю на всякий случай.
Вот такая процедура, которая просто находит первое
попавшееся неиспользованное ребро, идет вдоль него,
запускается рекурсивно от конца этого ребра.
И дальше, если все ребра уже исчерпаны,
если все исходящие ребра были просмотрены,
то я просто в некий списочек добавляю ребро,
с помощью которого дошел до этой вершинки V.
То есть то, с помощью которого я дошел до сюда в очередном рекурсивном запуске.
И дальше в конце просто запускаю реверс от ордера,
тогда в этом порядке уже будет корректный путь из SLS.
Да.
Счетчик PTR?
Ну да, чтобы не просматривать кучу раз список JOTV,
я просто храню список на первое.
Что значит наш родитель?
Да, список исходящих ребер.
Хотим, хотим.
Вы, видимо, вот про такой случай.
Я, честно, запускаюсь оттуда, все нормально.
Давайте какую-нибудь картинку тоже нарисую.
Там и здесь что-нибудь.
Как я могу, например, обойти?
Я могу обойти вот этот треугольничек,
напечатать это ребро, добавить его в ордер.
Дальше отсюда тоже запускаюсь эйдером.
Я иду сюда и сюда. Ну окей.
Пусть я, например, схожу вот так вот.
То есть я спустился по какому-то ребру,
и дальше по ребру родителя.
Ну ничего страшного, я нашел очередную часть цикла,
я его разворачиваю, запускаюсь эйдером отсюда.
Он находит этот треугольник,
и все, будет у меня вот такой корректный эйдеров цикл.
То есть то, что я поднимаюсь в родителя,
то есть я здесь, в общем-то, нигде не использую,
что я не хожу по противоположному ребру.
Это ничего страшного.
Смотрите, я говорю следующее.
Мне нужно просто понять,
что в ордере лежит.
Вот я утверждаю, что в конце, после реверса,
в ордере лежит эйдеров цикл.
То есть писок ребер, который начинается заканчиваться
в одной вершине, и любые два седних ребра,
смежные, инцидентные,
то есть они образуют путь какой-то.
Ну я начинаю с следующего.
Я говорю, что понятно, что первое добавленное
в ордер ребро это какое-то ребро в S,
а дальше говорю, вот пусть у меня в какое-то момент времени
в ордере лежит вот такой путь.
Путь заканчивающийся в S.
В самом начале путь из одного ребра,
но дальше по мере
продолжения алгоритма там будет какой-то путь.
Путь будет из T в S,
но в ордере он будет вжать
в обратном порядке.
То есть в ордере сначала вот это ребро,
потом вот это, потом вот это,
вот это, вот это, вот это.
Нет, нет, нет.
Элер как бы из внешнего, из мейна
я запускаю только элер от S.
Вот.
Дальше. Я понимаю, что первое добавленное в ордер
ребро это вот это, ну какое-то ребро в S.
Скажем, вот это.
Давайте посмотрим
второе добавленное ребро.
Пусть будет вот это, третье вот это,
четвертое и так далее.
Вот пусть там последнее, которое я знаю,
ребро добавленное в ордер,
это вот это вот ребро.
Тогда я утверждаю, что следующее добавленное ребро
обязательно ребро ведущее в T.
Вот это я тут как-то на пальцах объяснил.
Тогда, если я это доказал,
то получается, что конец ордера,
точнее начало ордера,
это всегда какой-то путь.
То есть у меня первое ребро вот это,
второе вот это, третье вот это и так далее.
Ну значит, раз это все в конце путь
и обойдут все ребра, то я нашел как бы путь
из S в S по всем ребрам.
А вот я его здесь передаю.
Когда я иду в вершину,
я говорю, с помощью какого ребра
я в него пришел просто.
Ну какая-то пометочка, что
ну ниоткуда не пришел, не печатай его.
Так, еще может вопрос?
Ну по тем же причинам, что вот здесь,
вот я изначально запускаюсь
лиром от S.
Как он ходит?
Он как-то идет по какому-то пути,
что-то делает.
И он всегда может пойти,
если он пришел куда-то,
он всегда может выйти,
потому что входная равна исходящей.
Если я в вершину пришел, то обязательно смогу выйти.
Это верно для всех вершин, кроме S.
Потому что у S я изначально
использовал одно исходящее,
но ни одного входящего.
И все промежуточные, во все остальные вершины,
если я вошел, то могу выйти.
Единственные вершины, которые я не могу выйти,
это только S.
Потому что я в самом начале использовал одно исходящее,
и теперь нашел еще одно входящее.
Первый момент времени,
когда у меня исчерпались все исходящие,
может наступить только вершинка S.
Значит первое добавленное в орды ребро
это какое-то вот такое ребро.
На самом деле,
здесь
мне достаточно того,
что из S все достижимо.
Это мне нужно для того, чтобы сказать,
что в ордере будут содержаться все ребра.
Поскольку я говорю про цикл,
я S могу,
волен выбрать любой вершиной,
я сказал, что S произвольная вершина.
Если он сильно связан,
то из любой все достижимо.
Так,
ну что,
давай тогда перерыв сделаем,
и потом продолжим.
Так, давайте продолжать.
Теперь давайте поговорим
про DFS в неориентированных графах.
Вот.
Значит,
ну,
давайте вспомним,
как работает DFS в ориентированном графе.
Можно было бы в принципе его переложить
на DFS в неориентированном,
но если я просто каждое ребро
УВ воспринимаю как пара ребер
УВ ВУ.
И вот,
вот,
вот,
вот,
пара ребер УВ ВУ.
Если я просто вот так вот добавлю
по два ребра
на каждое неориентированное,
то можно было бы просто запускать обычный DFS
на ориентированном графе.
Но можно его чуть-чуть подсекономить,
избавившись
от цветов.
Потому что, если вы помните,
у нас в случае ориентированного графа
я заводил три цвета вершин.
Значит, первый это белый,
когда я его вообще еще не видел.
Второй, когда он на стеке рекурсии.
И третий черный, когда мы его уже полностью обработали
и заходить туда больше вообще нет смысла.
Вот, в случае
неориентированного графа
я утверждаю, что серый цвет
никого смысла не имеет.
То есть нет смысла хранить серость вершины.
Но вообще, зачем нам надо было,
когда у нас возникало,
зачем нам надо было серые вершины вообще хранить?
Да, серость нам нужна,
если черность отличается только в том случае,
если я хочу определить,
есть ли в графе цикл,
то в ориентированном графе
мне нужно проверять, что есть ребро в серую.
Если есть ребро в серую вершинку,
то есть цикл.
В случае неориентированного графа
я утверждаю, 못 забить и сказать,
что серые и черные вanto одно и то же.
неориентированном случае, можно не делать разницы между серыми и черными.
Между серыми и черными. Вот, ну почему? Потому что раньше у меня ребро в черную
еще не означало цикла. Что такое ребро в черную? Это, например, вот такая картинка.
Вот если сначала, если у меня ДФС обошел сначала этот путь, потом здесь все обошел,
покрасил эту вершинку в черный, и потом нашел только это ребро, то я вижу ребро в черную,
и в принципе это не цикл. Потому что, ну как бы, это не цикл, понятное дело. А, соответственно,
ребро в серую, это когда, наоборот, я вот так вот прошел, и у меня появляется ребро куда-то наверх.
То есть, грубо говоря, черная, это когда ребро куда-то вниз, где я уже был, а серая, ребро в серую
вершинку, это ребро наверх, где я в процессе обхода, где я еще вот на стеке рекурса, она лежит.
Вот, ну понятно, что в случае неориентированного графа эти два случая никак не отличаются.
Если я буду игнорировать ориентацию ребер, то ребро в серую тоже означает не цикл. Ну просто,
как бы, который я нашел сверху вниз, а не снизу вверх. Вот, поэтому можно просто забить на серый
цвет и красить просто все в белый и черный. Ну или другими словами, использован, не использован.
Значит, тогда можно просто вместо цветов хранить булевский флаг. Вместо цветов можно хранить
булевский какой-нибудь юст. Вот В. Ну были ли мы в вершине когда-то или нет. Были ли мы В. Вот.
Ну и все. То есть, как бы, просто можно вырезать цвета и хранить юзды вместо цветов. Тогда
все равно каждое ребро ведущее в посещенную вершину будет циклом. Вот. Ну и вообще в неориентированном
случае можно рассмотреть как бы типы ребер. Типы ребер. Значит, как у меня работает DFS? Он
начинается из какой-то старта вершинки S и что-то там обходит. Он как бы рассматривает все ребра и
идет вдоль ребра, если вершина еще не посещена. Ну тогда я утверждаю, что, как бы, вот давайте те
ребра вдоль которых идет DFS я нарисую со стрелочкой. Тогда у меня какая-то вот такая картинка будет.
Вот. Значит, ребра со стрелочками это те, которые, как бы, вдоль которых я прошел в DFS. Они образуют
так называемое дерево обхода DFS. Ну понятно, потому что есть как бы общий корень и дальше от него все
как бы все идет вниз. Вот. И дальше я утверждаю, что, в общем, как еще могут быть устроены ребра
этого графа. Это либо вот эти вот древесные ребра, которые я обошел в DFS, либо могут быть еще так
называемые обратные ребра. Обратные ребра могут вести из потомков предка в этом дереве. Вот. Ну понятно,
могут быть такие ребра. Самое главное, что я здесь утверждаю, это то, что не может быть ребер между
разными по деревьям. То есть вот какой-нибудь такой картинки, например, и вот здесь вот ребро. Вот
такого не бывает. Ну потому что, если у меня есть ребро между разными по деревьями, то, ну извините,
когда у меня, скажем, DFS был вот здесь вот, он же должен был это ребро просмотреть. Поэтому тогда
эта вершина должна быть не вот в том пути, а вообще как бы вот здесь вот она должна быть подвешена.
То есть она должна идти куда-то здесь вниз. Поэтому как бы ребра между разными по деревьями в нашем
графе быть не могут. Потому что иначе я просто это бы рассмотрел в процессе обхода вот этого DFS.
Значит, единственные ребра, не являющиеся древесными, то есть те, по которым не ходил DFS,
могут быть только вот эти вот обратные между потомком и предком. То есть как бы снизу вверх
в дереве. Не там как бы, не из разных по деревьям вершины соединённые, а только как бы снизу вверх,
ну или сверху вниз. На одном пути из корня. Вот. Ну давайте скажу, что вот это вот древесные
ребра, да? Древесные ребра. А вот эти вот пунктирные, это обратные ребра.
Брат это кто?
Ещё раз.
Вот такое? Ну то же самое.
Если DFS сначала зашёл сюда, то перед выходом он должен был упустить вот эту. Значит,
это ребро он тоже должен был бы просмотреть, и эта вершина была бы подвешена куда-то сюда. То же самое.
Вот. Поэтому, когда у меня граф не ориентированный, у меня ребер на самом деле всего два типа. Это
древесные ребра, по которым проходит DFS и обратные как бы ведущие снизу вверх вот в этом вот дереве.
Вот. То есть ключевой момент, что таких перекрёстных ребер между разными по деревьям не бывает.
Вот. Хорошо. Давайте это отметили. Следующее, что мы хотим сделать, это, значит, следующее
определение. Пусть G не ориентированный граф, тогда ребро E называется мостом,
если количество компонент связанности в графе без этого ребра E, то есть после удаления ребра E,
количество компонент связанности строго больше, чем в исходном графе. То есть это такое ребро,
удаление которого увеличивает несвязанность, увеличивает количество компонент связанности.
Ну, простой пример. Какой-нибудь вот такой вот. Если у меня есть вот такой граф, то удаление вот
это вот перемычки между треугольниками, понятное дело, если у меня была изначально одна компонента
связанности, теперь станет две. Вот одна, вторая. Вот. Ну и родственное определение,
это точка сочленения, это, наоборот, такая вершина удаления, которая увеличивает количество
компонент связанности. В называется точкой сочленения, если, ну то же самое, в G-V,
то есть после удаления вершины V, число компонент связанности больше, чем в G. Ну и,
естественно, удаление вершины подразумевается вместе с удалением всех ребер, которые в нее
торчали. То есть когда удаляю вершину, конечно, я удаляю также все ребра, которые ей были инциденты.
Например, если два вот таких вот зацепленных уже по вершине треугольника, то вот эта вот вершина
является точкой сочленения, потому что после удаления ее и всех инцидентных ей ребер у меня
остаются две компоненты связанности, вот эта и вот эта. Значит более того, бывают ситуации,
когда точка сочленения, точнее удаление точка сочленения оставляет не две компоненты связанности,
а много. Например, просто если у вас много таких треугольников зацеплено, то удаление одной
вершины делает вам сразу много компонент связанности. В отличие от мостов, потому что если вы
удаляете мост, то более-менее интуитивно понятно, что максимум две компоненты связанности
получится, а в случае удаления вершины может быть сколько угодно. Ну зачем это может быть нужно?
Ну в каком-то смысле вот эти вот мосты и точка сочленения показывают вам уязвимости в вашем
графе. То есть если у вас там какая-нибудь коммуникационная сеть, где вершинки такие там
компьютеры, а ребра это каналы общения между ними, между какими компьютерами есть общение,
тогда вот если есть какой-то мост и внезапно он каким-то образом ломается, тогда у вас вообще
вся сеть становится не связана, вы не можете с одного компьютера придать информацию на другой. То
же самое с точкой сочленения. Если есть какие-то вот такие вот компьютеры, которые завязаны на
несколько вот таких компонент, которые без них были бы не связаны, тогда вам нужно ну вот прям
хоть и деться, но поддерживать работоспособность этого компьютера, чтобы можно было передавать как-то
информацию с одному на другой. То есть скажем отсюда до сюда, любой путь проходит через эту вершинку,
поэтому вам нужно, чтобы она всегда работала. Ну вот. Соответственно задача состоит в том,
чтобы в неориентированном графе найти все, скажем, мосты и точки сочленения. Ну давайте искать.
Значит, для этого сначала я заведу следующую функцию на моем вот этом дереве обхода.
Вот здесь есть дерево обхода DFS. Вот. Давайте я введу следующую функцию.
Ретюрн от V, для каждой вершины V, показывает следующее. Как высоко я могу прыгнуть из-под дерева
вершины V наверх, используя ровно одно обратное ребро. То есть вот представьте, я нахожусь в V,
я могу спуститься куда-то вниз под ревестным ребром, куда-то могу спуститься вниз. И дальше
я могу использовать одно обратное ребро. То есть могу как-то прыгнуть куда-то вот наверх. Могу,
например, прыгнуть сюда, отсюда могу, например, прыгнуть сюда. Ну и так далее. Вот есть какие-то
такие обратные ребра, которые торчат из этого по дереву куда-то вот наверх. И я хочу понять,
какой максимальной высоты я могу получить. То есть насколько высоко я могу прыгнуть,
используя одно такое ребро. Вот. Формально это следующее. Давайте напишу формально. Это минимум из.
Ну, во-первых, может таких обратных ребер из этого по дереву вообще не быть. Тогда давайте
просто напишем здесь T и нот В. Ну, время входа в вершинку В. Я буду хранить не вершину, а время
входа в нее скорее. Вот. Значит, в случае, когда нету интересных ребер наверх, я просто храню
время входа в вершинку В. А дальше, ну вот я могу перебрать все вот эти вот обратные ребра,
ведущие снизу вверх. Дальше будет минимум по. Давайте переберем обратные ребра. Скажем,
пусть оно ведет из W куда-то в U. Тогда я возьму T и нот U. И мне нужен этот минимум взять по всем
таким обратным ребрам WU, что W в по дереве В. То есть минимум по всем обратным ребрам WU такое,
что W в по дереве В. Что? Чуть позже, чуть позже покажу. Покажу, что давайте ведем вот эту штуку.
То есть еще раз, насколько высоко я могу прыгнуть из всего этого по дереву по одному обратному ребру.
Почему минимум? Ну, еще раз. Ред показывает не номер вершины, куда я могу прыгнуть,
а скорее время входа в вершину. Но тогда понятно, что чем выше я поднимаюсь в дереве,
тем меньше у меня время входа. Потому что я вхожу как раз, у меня DFS идет сверху вниз по
этому дереву. Чем ниже, тем больше время входа в вершинку. Соответственно, чем выше, тем меньше.
Я хочу минимальное время входа. Среди всех вершин, куда я могу прыгнуть, хочу понять
минимальное время входа. Определение понятно? Да, вот все, что в по дереве, из любой могу
прыгнуть наверх. Главное, что в по дереве было. Теперь, если эту функцию ввел, чуть позже я покажу,
как ее находить. Давайте сначала поймем, зачем это надо. Утверждение. Ребро у В. Мост,
если и только если, во-первых, оно древесное, во-вторых, ред от В равно тын от В. То есть
картинка. Вот у меня есть какое-то ребро у В. Что вот это условие означает? Это значит,
что из всего вот этого поддерева я не могу прыгнуть выше, чем В. То есть у меня, ну по
умолчанию, ред от В просто тын от В, возможно меньше, если я могу прыгнуть выше. Но если равенство,
значит я вот отсюда не могу, у меня нет ни одного вот такого ребра наверх. То есть выше, чем В,
я прыгнуть не могу. То есть есть какие-то такие ребра, возможно, но выше ребер нет. Тогда понятно
дело, что если я это ребро удаляю, то у меня вообще пропадает связанность между вот этой компонентой
и у, например. Я никак не могу вот отсюда выбраться за пределы... Ну как бы, я не могу до у, например,
дойти. Потому что таких ребер просто нет. То есть вот таких обратных ребер нету, потому что у меня
ред от В равно тын от В, а вот таких перекрестных, то есть куда-то в другие поддеревья, их тоже нет,
потому что граф не ориентирован. Нет у меня таких ребер в другие поддеревья. И получается,
что у меня вот это вот отдельное, после удаления у В, это будет отдельная компонента связанности,
из которой я до у никак не дойду. Да, это более-менее как бы в обе стороны было доказательств. Давайте
я чуть аккуратнее докажу. Значит слева направо, пусть ребро мост. Почему оно древесное? Ну понятно,
не древесное ребро мостом быть не может, потому что если я удалю любое не древесное,
то у меня граф останется связанным под древесным ребром. Значит у В, давайте так, если у В не
древесное, то его удаление не влияет на связанность. Потому что, ну как бы у меня связанность по факту
обеспечивается только древесными ребрами сверху вниз, а все обратные можно спокойно удалять,
связанность от этого не нарушится. Во-первых, оно тогда обязательно должно быть древесным,
чтобы быть мостом. Ну и, да, если, например, вот это вот неверно, то есть ряд вот В меньше,
чем ты на В, ну тогда это значит, что даже если у меня есть такое древесное ребро у В,
и это неравенство выполняется. Значит из этого поддельного я могу прыгнуть куда-то выше,
чем В. Значит, если я это ребро удалю, то связанность сохранится, потому что я отсюда,
то есть из В могу дойти вниз до этого ребра, дальше прыгнуть по обратному куда-то сюда,
и дальше, если что, спуститься до вершинки У. Я удаляю только у В, поэтому связанность у меня
сохраняется. За счет вот этого вот обратного ребра, которое меня выводит куда-то наверх,
я смогу обратно соединить В и У. Понятно? Вот, ну обратно, значит, если все это верно,
то понятное дело, что удаление у В делает несвязанным у и В. Удаление у В делает у и В несвязанными.
Значит, у нас есть критерии моста в терминах вот этой функции return. Ну теперь давайте критерий
на точку сочленения. Значит, В это точка сочленения, если и только если. Значит, первое,
первый случай, В это корень, да, то есть внешний ДФС запустился вот в вершинке В,
В корень вот этого дерева обхода. И при этом у В, точнее из В исходят хотя бы два древесных ребра.
Либо же второй случай, когда он не корень, то есть у меня один из двух случаев выполняется,
В не корень, и существует древесное ребро В2 такое, что return от 2 больше равно 3 от В.
Так, давайте с первого пункта начну. Что происходит в случае, когда В это корень, да, то есть когда
корень дерева может быть точкой сочленения. Вот у меня есть какой-то корень дерева В, я что-то там
обхожу с помощью ДФС. Вот я утверждаю, что тогда В это точка сочленения, если и только если мне
нужно было пойти хотя бы два раза вдоль каких-то ребер из В. Ну понятно, если я пошел всего лишь
вдоль одного ребра, то значит я взял просто первое попавшееся ребро, запустился ДФС отсюда и обошел
вообще весь граф. Ну тогда понятно, что В не влияет на связанность, ее можно было бы удалить, и все,
что остается, осталось бы связано. Ну а наоборот, если есть хотя бы два исходящих ребра, что это
значит? Почему из корня может быть два исходящих ребра древесных? Значит, я сюда пошел, что-то обошел,
но не все. Мне пришлось вот эту рекурсию всю завершить, подняться сюда и взять еще одно ребро.
Но это просто значит, что вот эта, скажем, вершина недостижима вот отсюда, потому что
будь она достижима, я бы ее нашел в этом поддере, был бы путь. Значит, если есть хотя бы два ребра,
значит вот эти вот компоненты после удаления В останутся не связаны. Понятно? Вот. Значит,
корня. Простой случай. Теперь пусть В не корень. Пусть В не корень. Ну давайте разберем два случая.
Существует такое ребро или не существует? Пусть такое ребро существует. Что это значит? Поскольку
В не корень, то у него есть обязательно родитель. Вот в дереве обхода ДФС обязательно есть у него
какой-то родитель. То есть есть древесное ребро ПВ. Давайте скажем, что пусть такое ребро есть.
То есть пусть существует такое ребро из В вту, что return отту больше бравно, чем ты нот В.
Ну что это значит? Это значит, что из всего вот этого вот поддерева нельзя прыгнуть выше,
чем В. Возможно вот есть такое обратное ребро, но выше нету. Тогда понятно, что если вы В удалите,
то у вас П и Т станут не связанными. Потому что из всего вот этого поддерева единственное,
что вы могли сделать, это прыгнуть В, но теперь В не существует, поэтому это ребро удалено. И
значит это будет отдельная компонента связанности. Вы из нее никуда в другое место пойти не сможете.
То есть если такая есть, то П и Т будут не связаны. П и Т не связаны после удаления В.
Ну а в обратную сторону, если это неверно и, наоборот, для любого сына В не нравится
выполняться в обратную сторону, скажем вот пусть есть один ребенок, другой ребенок,
третий ребенок, пусть для них, для всех не нравится в обратную сторону.
То есть скажем у1, у2, у3 и пусть return для каждого из них строго меньше, чем ты нот В.
Это значит, что из каждого вот этого поддерева есть ребро куда-то выше, чем В. Ну то есть в П или
еще даже куда-то выше. То есть отсюда скажем есть такое обратное ребро, отсюда куда-нибудь туда
еще выше, отсюда куда-нибудь туда еще выше и так далее. Из каждого поддерева есть обратное
ребро в П или еще выше. Ну тогда понятно, что В не влияет на связанность. Вы ее можете удалить,
да, и за счет как раз вот этих обратных ребер из каждого из поддерев можете подняться наверх,
значит всех связать в одну компонент. Норм? Ну вот, значит тогда доказали вроде.
Получается, что для того, чтобы найти мосты и точка сочленения нам достаточно вот эту функцию
эффективно посчитать, потому что дальше написано тривиально проверяемое условие на точке сочленения
и на мосты. Значит как вот это искать? Ну, ищется на самом деле очень простой динамикой. Потому что
смотрите, вот давайте посмотрим наше дерево, дерево обхода. Ну какая база динамики? Понятно,
если у вас вершинка В это лист этого дерева, то есть вершина, из которой больше ничего не исходит,
никаких древесных ребер не исходит, то return от В считается очень просто. Return от В, это нужно
просто просмотреть вообще все ребра, которые из нее есть, ну и найти из них самое высокое. Если
здесь есть несколько обратных ребер, надо просто найти из них самое высокое, самое высокое ребро из В.
Потому что в случае, когда В это лист, у него нет под дерево, у нас как бы ниже идти некуда,
можно только отсюда куда-то прыгать наверх. Ну а дальше, если я для всех скажем, вот пусть
для этих листов я все посчитал, как для этой вершинки посчитать? То есть если какая-то вершинка
теперь пусть будет опять тоже В, для всех ее детей я return посчитал. То есть для всех вот этих вот штук
я знаю red. Как найти red от В? Да просто минимум вроде. Я же храню как бы самую высокую вершину,
ну просто как бы я либо отсюда, я либо из В куда-то прыгаю наверх, либо из одного из этих под деревьев
куда-то тоже прыгаю. Поэтому мне нужно просто взять минимум из вот этих вот return и опять-таки
минимум по всем обратным ребрам ведущим из В. В этом случае это либо по обратному ребру из В,
либо return от одного из сыновей, либо минимум из return от U, давайте return от
U по всем вот этим вот древесным ребрам. Таким, что V запитает U это древесное ребро.
Потому что либо я сразу из В прыгаю куда-то наверх, либо я сначала спускать в одно из под
деревьев. Ну либо сюда, либо сюда, либо сюда. Вот я куда-то спустился и оттуда прыгаю наверх.
Для каждого из них я уже знаю return, знаю red и надо просто взять минимальный из них. То есть как
высоко я могу прыгнуть. Ну и все. Получается, что вот эту штуку, вот этот red можно насчитывать даже
сразу вот в процессе DFS. Если я просто пишу DFS, то сразу же я могу насчитывать red. Потому что
что такое листья? Понятно, листья это как бы вершины, из которых DFS дальше никуда не идет. Если
V такая, то return надо просто перебрать все обратные ребра и посчитать, вот, проставить здесь значение red
от V. Если у меня DFS вот всех под деревьев завершился и я знаю корректные return для них, то return от V
считается, опять же, по такой же форме, прям внутри DFS. То есть нам не нужно писать вспомогательную
функцию. Ну как бы можно при желании, но эти return можно в принципе насчитать и прям внутри DFS.
Чтобы еще раз не обходить граф, можно все эти штуки насчитать прям внутри DFS. Ну вот. Нормально?
Хорошо. Так, ну тогда давайте еще чуть-чуть дальше посмотрим. Дальше можно говорить так же,
как у нас было про сильную связность, можно вести двусвязность. Определение вершины
U и V называются реберно-двусвязными, если между ними существует два реберно-непересекающихся пути.
То есть пути могут пересекаться по вершинам, но главное, чтобы по ребрам не пересекались.
Да. То есть может быть какой-то такой путь и какой-нибудь вот такой путь. То есть им можно
пересекаться по вершинам, но главное, чтобы по ребрам не было. Тогда такие вершины, если есть
такие два пути, вершины называются реберно-двусвязными. Утверждение. Реберно-двусвязанность
это отношение к эволентности на вершинах. Ну не совсем. Почему, очевидно?
Да. А транзитивность? Что? Транзитивность вот похитрее, надо немножко повозиться. Вот надо
аккуратно сказать какие. Ну да, значит, начало простое. Давайте я так и напишу,
что рефлексивность и симметричность, они очевидны. Ну почему вершина сама с собой
реберно-двусвязана? Потому что можно стоять на месте, это тривиальный путь, и второй путь тоже
стоять на месте просто. Это два пути, они не пересекаются по ребрам, поэтому любая вершина сама
с собой двусвязана. Почему симметрична? Ну понятно, если есть два пути из УВ, то есть два пути из ВВ,
потому что граф неориентированный. Теперь транзитивность. Вот пусть мне известно,
что между У и В есть два пути реберно-непересекающихся, и между В и ВВ есть какие-то два пути реберно-непересекающихся.
Проблема в том, что путь, скажем, от В до ВВ и от В до У могут очень сильно пересекаться. Они
пришли как бы из разных условий, и они могут вот как бы вот, давайте получу картинку, нарисую,
может быть что-то вот такое, например, в таком стиле. Поэтому просто склеить их не получится,
нельзя просто сказать, давайте от У дойдем до В, от В до ВВ, склеив там какие-то два пути, и от У до В
и от В до ВВ по другому пути. Ну можно, да, вот надо сказать как. Ну для этого действительно давайте
просто посмотрим вот этот вот цикл. Пусть С это реберно-простой цикл, то есть без повторов ребер,
на У и В. То есть это вот те ребра, которые обеспечивают два непересекающихся пути из У в. Это
какой-то цикл. Возможно он с самопересечениями, но неважно, это просто какой-то цикл. И дальше
давайте посмотрим два пути. Вот пусть у меня есть путь П1 из ВВ до В, есть путь П2, тоже из ВВ до В.
У меня есть два таких реберно-непересекающихся пути. Тогда давайте просто возьмем вот на этом
вот пути П1 и на пути П2 самые первые вершины, попадающие в цикл С. Пусть Х1, Х2 это первые вершины
путей П1, П2, лежащие на цикле С. В этой картинке вот это и вот это. Возможно сам путь многократно
пересекается с циклом. Давайте рассмотрим первые пересечения. Тогда какая у меня картинка? У меня
есть реберно-простой цикл между У и В, на котором еще выделены какие-то две вершинки Х1, Х2. Возможно
одинаковые, возможно разные. Давайте вот так нарисую Х1, Х2. Что я знаю? Я знаю, что если я нарисую пути
от Х1 до В и от Х2 до В, то они, во-первых, между собой не пересекаются по ребрам, потому что это
были куски путей между В и В. И более того, они не пересекаются с циклом вообще, потому что это были
первые вершины на путях, попавшие в цикл. То есть вот эти куски я могу смело добавлять в ответ. Они
и между собой не пересекаются, и с циклом тоже не пересекаются. Ну а дальше нужно просто аккуратно
на этом цикле выбрать два пути. Ну скажем вот, на этой картинке можно взять вот так, от У до Х1
и по тому пути, и от У до Х2 и по вот этому пути. Тогда я обеспечивал как раз два не пересекающихся
пути от У до В. Ну и здесь нужно перебирать в случае, как именно расположены Х1, Х2 на цикле,
потому что, например, если они расположены ну как-нибудь вот так вот, то мне, ну по сути,
то же самое. Но только у меня вот этот путь будет как бы подлиннее. И дальше опять они доходят до В.
Вот. Ну это неважно. Главное, что у меня на этом цикле есть какие-то две вершинки. Понятно,
что я могу от У нарисовать два не пересекающихся пути до них, до Х1 и до Х2, и дальше эти пути
продолжить до пути до В. Тогда вот это все будет два реберно-не пересекающихся пути. Понятно? Ну вот.
Значит это действительно свойство отношения эквивалентности. Значит по нему можно выделять
компоненты как бы реберно-дву связанности. Вот. Ну, давайте утверждение тогда, наверное.
Как выделить вот эти компоненты? То есть я говорю, что, окей, это отношение-дву связанности,
отношение-эквалентности. Значит все вершины распадаются на какие-то компоненты дву связанности.
Вот как их искать? Я утверждаю следующее. Что если из G удалить все мосты, то компоненты
связанности в новом графе совпадают с компонентами реберно-дву связанности исходного графа.
Вот. То есть чтобы выделить компоненты реберно-дву связанности, достаточно удалить мосты и посмотреть на
компоненты связанности уже. Просто связанности. Ну пример какой-нибудь давайте нарисуем. Вот
что-нибудь такое. Такой граф. Понятно, здесь два моста и вот эти два ребра. Вроде видно,
что все остальные лежат на каких-то циклах, поэтому они точно не мосты. Вот это вот мост и вот это
мост. Если я их удалю, у меня получатся три компонента связанности. Одна вот эта, другая вот
эта, третья вот эта. Ну и можно показать, что внутри вот этих вот компонент связанности все вершины
попарно реберно-дву связаны. Вот. Ну соответственно тогда у меня вот, если мне почему-то хочется
выделить компоненты реберно-дву связанности на нашем графе, я могу просто удалить все мосты и
все что останется компонентами связанности будет компонентами дву связанности. Ну почему это так?
Почему это так? Ну понятно, что если между двумя вершинами есть пути в две стороны, то удаление
мостов эти два пути сохранит. Значит, если у и в реберно-дву связаны, то удаление мостов, удаление
всех мостов не повлияет вот на эти два пути. Не повлияет на пути между ними. Ну потому что,
если они были дву связаны, то понятно дело, что ни одно из этих реберов вот на этих путях не может
быть мостом. Потому что если ребро не может быть мостом, то это в цикле. Потому что удаление
ребра оставляет понятное дело связанность между его концами, потому что есть вот такой длинный
путь от сюда до сюда. Поэтому ребра на этих путях точно не мосты, значит если удалю мосты,
эти пути сохранятся. И у меня вершины останутся точно в одной компоненте связанности. Вот. Ну и
обратно надо показать, что, значит обратно, почему если вот в этом графе какие-то две вершины попали
в одну компоненту связанности, то они двусвязаны. Ну для этого давайте посмотрим на какое-нибудь
ребро древесное, да, значит пусть оно не мост, пусть УВ не мост. Тогда почему У и В двусвязаны?
Вопрос к вам. Вот пусть УВ это древесное ребро графа, но при этом не мост. Тогда
я отжаю, обязательно У и В двусвязаны. Почему? Не совсем. Сейчас, сейчас. Ну а вдруг какой-то
другой путь там из ВВ содержит мост. Но возможно по-разному, возможно для разных пути разные
ребра получаются. Да, да. Да, но почему, если я удалю все мосты,
то у меня сохранится связанность. Тут, смотрите, тут можно рассуждать даже вот, вот это можно
сказать без удаления мостов. Смотрите, вот пусть у меня есть ребро УВ, не являющийся мостом. Тогда
почему У и В двусвязаны? Ну потому что, что значит оно не мост? В терминах ред, это значит,
что ред вот В меньше либо равно 3 на ту. Значит, что из этого поддерева можно прыгнуть с помощью
обратного ребра куда-то наверх. Ну тогда понятно, почему они двусвязаны. У вас есть вот один такой
путь, есть другой вот такой путь. Потому что из В можно куда-то спуститься так, чтобы потом по
обратному ребру прыгнуть куда-то выше, чем У и дальше до У спуститься. Значит, они точно двусвязаны,
есть два пути. Вот есть один такой и другой такой, через вот то самое обратное ребро,
которое существует, потому что УВ не мост. Ну и все, а значит получается, что если я сохраняю только
древесные не мосты, то у меня соединены могут быть только те вершины, которые двусвязаны.
Ну значит, вот все, что останется здесь в компонентной связанности после удаления мостов,
они внутри будут по парам двусвязаны, ну потому что любые соседи двусвязаны, и по транзитивности
получается любые две вершины двусвязаны внутри одной компоненты. Вот, вроде доказали. Вопросы?
Ну если нет, тогда да. Да, ну не строгие, потому что условие моста, это когда рецепт В равно ТИ на ТВ,
а раз оно не равно, значит, он куда-то выше, чем В, значит, меньше либо равно ТИ на ТУ.
Ну да, спасибо, закончили, если что, вопрос подадите, уточним.
