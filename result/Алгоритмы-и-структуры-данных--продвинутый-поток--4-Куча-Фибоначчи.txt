Ну тогда значит, ну вот, да, ну тогда нас приветствует такая действительно важная,
действительно называется тема, особенно в спортивном программировании, как куча фибоначи.
Вот, вот. Не, леватское другое. Да, да, да, если вспомнить краткое содержание предыдущей серии,
то действительно у нас было, да, то есть в прошлый раз у нас было огромное количество куч,
вот, соответственно, потому что, соответственно, там была обычная куча коричная, что там биномиальная,
леватская касая, если я ничего не забыл, но отдельное, да, отдельное внимание мы уделяли тому,
что там пытались реализовать кучу на так называемый поинтермашин, то есть представили себе,
что у нас массивов, массивов нету и векторов, тем более, соответственно, то есть все на самом
деле так висит на указателях. Вот, но единая нот, единственная нот, и обнаружили, что, в общем-то,
эффективность ни одной из куч, в общем, от этого сильно не страдает, вот, но единственное только
ограничение, что мы, кажется, так и не смогли остаться за нами должок, мы не смогли удалять
из произвольного места в леватской куче, точнее, левосторонней, вот, да, ну, вкосой за счет
амортизации в леватской, там, как бы, жесткие требования, так мы не смогли, но, на самом деле,
чуть позже мы вернемся к этому вопросу, на самом деле, там, несложно было, вот, то есть, на самом
деле, счастье было близко, вот, но куча фибоначи, да, ну, жалко, да, про Олимпиадект, конечно,
шутка, на самом деле, была, вот, и, ну, вот, соответственно, да, да, про кучу фибоначи,
обычном, там, можно говорить что-то в духе, да, сегодня мы изучим кучу фибоначи, это очень важная
теоретическая структура, на которой основано множество алгоритмов, она почти никогда не
используется на практике, сегодня вы узнаете почему, вот, примерно, так это как-то надо начинать,
вот, структура действительно требуется, потому что, по крайней мере, чисто в теории она применение
имеет, потому что, ну, как минимум, потому что, какие у нас сегодня ставки, да, на что сегодня ставим,
да, ну, во-первых, говорим, что структура, сразу скажем, амортизационная, сейчас мы тут опять
будем этим учетным анализом заниматься, но, если мы в него поверим, то получится примерно следующее,
значит, итак, какие мы хотим делать операции, ну, как всегда, что такое куча, куча это, это тоже,
куда вы пытаетесь вставлять элемент, значит, там, получать минимум, извлекать минимум,
соответственно, но основной для кучи, так, но у нас кучи сливаемые, например, напоминаю,
поэтому, вот, пишем melt и, ну, вот, то есть, обязательно melt, но, конечно, значит, но, конечно,
важной для нас будет функция decrease key и его величество delete по итературу, конечно,
ну, вообще говоря, да, но не только, там, как бы itx, конечно, вот, да, melt, ну, тут страшно сказать,
конечно, нет, он уменьшает до икса, но гарантируется, что именно уменьшает, так вот,
ставка, значит, ставка у нас будет такая, значит, ну, соответственно, мы уже убеждались, да,
то есть, значит, куча фибоначи, соответственно, учетная, то есть, асимптотики учетные, ну,
мы уже говорили, что, то есть, ну, цель у нас какая, потому что если брать какую-нибудь классические
кучи, да, там всякие, там, левацкие косы и так далее, то практически все операции работали за
логорифом, ну, а некоторые особо отличившиеся мы даже пока не научились делать с логорифом,
вот, но с другой стороны, оказывалось, что, в общем-то, с помощью учетности можно некоторые
операции спокойно делать за 1, ну, гетмин, конечно, там всегда делается за 1, в общем-то,
обычно это не проблема, но, например, мы помним, что в обычной куче, если брать самую-самую
обычную двоичную кучу, вот, самую-самую-самую обычную-обычную-обычную, то оказывалось,
что экстракт Мин там работает за от единицы. Почему он работает за от единицы? Ну, потому что,
если мы говорим учетно, то мы, как бы, говорим, то есть, условно говорим, давайте тот логорифом,
который мы тратим на экстракт Мин, на самом деле мы будем относить в инсорт, то есть, с точки
зрения учетности, в учетности мы скажем, давайте каждый инсорт будет не работать не за логорифом,
а за два логорифма, будем считать, что он работает за два логорифма, ну, там, типа,
один логорифм на реальную работу, другой логорифм на монетке, ну, вот, и потом, соответственно,
экстракт Мин будет работать за, даже не за единицу, а за ноль. Вот, и получалось,
тут логорифм, тут единица, там, и так далее, в общем, радость. То есть, какие-то, то есть,
вы, как бы, помните, да, вот, там, вот, вот это, вот, все, там, рукомахание, на самом деле, но здесь
мы, на самом деле, себе потребуем, тут будет все чуть посильнее, потому что на этот раз вставлять
мы будем за вот единицы, а удалять за логорифм. Ну, добиться того, чтобы удалить, все делать за
вот единицы мы не можем, потому что у нас куча предельно честная, если мы умеем все делать
быстрее, чем за логорифм, то мы бы и сортировали бы быстрее, чем за НЛоган, что невозможно. Да,
поэтому, как бы, где-то логорифм да выплывет, тут уж без вариантов. Ну, вот, так вот, но здесь
мы будем делать за вот единицы все. Вот, и дилет. Что касается декриски. Ну, обычно декриски,
конечно, мы делаем, делали раньше очень просто, да, то есть, как делать декриски? Ну, просто
удаляем элемент, а потом вставляем его в уменьшенную версию, да. И, в общем, обнаружилось, что в такой
версии можно делать не только декриски, но и инкриски, в общем-то, без проблем. Но тут будет
сейчас важно нам, что это будет именно декрис, потому что мы поставим на то, что конкретно декриски,
то есть, если вы хотите уменьшить элемент, но не удалить его, то это будет работать за О от единицы.
Что? Где? Да. Нет, это он к дилету отношения имеет. Ладно, давайте я вот так вот таблицу нарисую.
Ну, вот. Ну, это нормально.
Вот это нам будет, вот это нам будет давать, что именно уменьшать мы будем за О от единицы,
а не за логариф, как бы, как у нас бывало раньше. То есть, раньше мы этим занимались за логарифом,
там сводя к дилету. Ага. Причем, да, главное в чем? Потому что, как минимум, мы уже в прошлый раз
поминали алгоритм dx, правда? И вот оказывается... А вот причем. Потому что за сколько у нас
работает алгоритм dx, да? Вот мы вспоминали. Классический алгоритм dx работает за v квадрат.
Ну ладно, v квадрат плюс е, формально говоря. Ну, вдруг там кратные ребра, там вот это все безобразие.
Вот. Это называется обычный dx. Можно и списать dx, там, dx с какой-нибудь кучей. Ну, либо обычной
кучей, либо там деревом отрезков, либо с сетом, в общем, там. Ну, что мы в прошлый раз обсуждали.
Получалось, е лог в. И вот мы думали, какую из этих версий писать. Вот. Ну, вот, то есть,
действительно, сильно зависит от е. Потому что если е там, допустим, порядка v или порядка
v лог в, что-то такое, то это, конечно, лучше. Но если е там, граф полный порядка v квадрат,
то оказывается, что вот это оказывается значительно лучше. Так. Ну, с другой стороны,
что у нас тогда было? С другой стороны, в прошлый раз мы как бы обсуждали, а что делать,
если у нас есть коичная куча? Ну вот. А вот и нет. А вот и нет. На самом деле, если очень внимательно
посмотреть, то оказывалось, что конкретно в dx-3 еще cam можно было выбирать более как-то интересно.
Почему? Потому что давайте вспомним. Вот давайте, я уж тогда, раз уж у нас тут есть табличка,
давайте вспомним про коичную кучу. Вот давайте вспоминать. Инсерт в ней работает за сколько?
За o от лог по основанию kn. Get min, o от единичный. Экстракт min у нас за сколько работал там?
o от k. Так, melt. Ну ладно, в данном вопросе не заморачиваемся. И теперь самое интересное.
Ну вот decrease key у нас за сколько работает? Вот именно за o от лог, потому что помните,
в коичной куче сифтап работает в k раз быстрее сифтдауна. Ну потому что когда вы
пропенсовываете вниз, то есть вам придется там перебирать k детей, выбирать из них минимум.
Нет, мы его там подвешиваем на место самого последнего листа и делаем из него сифтап.
Вот. Так вот. Но это чем киски нам помогает? Он нам помогает тем, что в каком-то алгоритмом dx-3,
вот давайте откуда тут берется. То есть вот в алгоритме dx-3 на самом деле какие операции
выполняются? Ну то есть если нам нужно искать минимумы, то фактически у нас допустим там
n инсертов, можно сказать. Значит тоже n, в смысле v, v экстракт минов. И что еще? И e decrease key.
То есть в общем-то если у всех операции симптотики одинаковые, то на самом деле проблема в тихой
киске. То есть мы говорим, что если у нас все операции работают, скажем, с алгоритмом, то получается,
что действительно у нас вот e логовая и вылезает. Вот. С другой стороны, вот теперь в обычном dx-3,
например, оказывается, что инсерты нод, что допустим экстракт мины работают за o от v и
тут выплывает v квадрат, но зато каждый d киски работает за o от единицы. Поэтому вот тут v квадрат
плюс e и при большом e это может оказаться даже хорошо. Вот. Ну чем нам помогает нод? Ну у нас
оказывалось, что если мы возьмем коичную кучу, да, вот давайте посмотрим, коичная куча, то оказывалось,
что она работает за, что здесь допустим, ну инсерты экстракт мины они работают за вот vk лог k. У нас
оказывалось vk лог kn и плюс decrease key, decrease key у нас оказывалось e лог kn. Ну и мы в принципе
внимательно пытались смотреть, пытаясь выбрать, а какое минимальное k вообще, то есть какое k надо
подобрать, чтобы вот это вот оказалось асимпатически поменьше. Но оказалось, что k там должно быть примерно
e поделить на v, то есть соответственно, то есть вот здесь оказывалось, что имеет смысл не между
двумя и тремя описать, а именно, называется e делить на v. Ну то есть это тоже может оказаться между
двумя и тремя, конечно. То есть это означает, что действительно, если там e действительно порядка
там 2v или 3v, то да, действительно выгодно брать просто обычную кучу и не заморачиваться. Вот,
но на самом деле, если e побольше, то можно брать и коичную кучу и тогда асимптотика оказывалась
там o от e на лог с основанием e делить на v. Вот такая мистическая симптотика была, напоминаю.
Вот, поэтому тут оказывалось, что за счет того, что у нас, оказывается,
экстракт Мин работает жирнее, чем дикрийский, оказывалось, что действительно k имеет смысл брать
больше, чем 2-3. Вот, помните, да? Помните? Так вот. Но, конечно, вот это e на лог,
вот это вот. Ну, тут можно, конечно, думать, да, что если e равно v квадрат, то это получается
действительно o от e. Если e там действительно небольшое, это тоже e логовое, ну и там вот так
далее. Но теперь давайте смотреть. А в куче фибоначи тогда что? Вот если брать в куче фибоначи,
то здесь мы обнаружим еще круче. То есть здесь у нас получается инсертов v экстракт Минов,
то есть пишем тут v лог v. Это вот на экстракт Мин и все. А дикрийский работает за единицу,
обратите внимание, и получается plus e. Вот. То есть здесь вообще совсем очевидно, что вот эта
асимптотика прям жестко обыгрывает и вот эту асимптотику, и вот эту асимптотику. Ну,
если, ладно, ну, то есть, ну, по крайней мере, она явно не хуже. Вот. То есть получается вот,
то есть на самом деле, да, если не надо выбирать, нужно просто писать d экстру с кучей фибоначи.
Не, ну, тем более в некоторых компиляторах ГЦЦ она, кстати, реализована. Да, мало кто знает,
но вот. Но кто-то ее там где-то видел. Да. Так что вот. Ну, правда, опять же, да, на практике,
как я уже сказал, ее особо не пишут, потому что константа, конечно, жирная. Но что делать?
Ну, вот, тем не менее, теоретически асимптотические действительно структуры данных
работают хорошо. Собственно, мы с ней будем очень активно встречаться, потому что вот мы,
вот она, вот d экстра у нас за e плюс v лог v. Ну, вот. Ну, там, в Астовных деревьях, ну, можно,
как минимум, алгоритм примок, очевидно, реализовать ровно и тем же самым методом. Но, на самом деле,
у нас будут и более. Там и еще более какие-то крутые, может быть, более крутые асимптотики еще.
Вот. То есть там какие-то красивые будут вообще красивые асимптотики. Если e больше чем v лог
лог v, то тогда алгоритм будет работать за e. Вот. То есть это вот. Это так тоже на правах анонса,
что у нас там будет. Вот. Так что вот вещь, на самом деле, замечательная. Так что, собственно,
остается только выяснить, откуда же эти все асимптотики берутся. Вот. Ну, собственно,
пришло время, собственно, приступить к непосредственно структуре. Чего? Чего? Кого? Где? Не слышу?
Ладно. Значит, смотрите. Значит, ну, начнем мы вот с чего. Значит, давайте попробуем. Первое,
что мы сделаем, это попытаемся пока временно обойтись без декриски и дилет. То есть, видите,
наша цель делать все за o от единицы, только экстракт-мин сделать за алгоритм. И мы прям
будем к этому идти. Работать это будет примерно следующим образом. Значит, смотрите. То есть
действительно начинается все очень просто. Все элементы добавляются в двусвязанный список.
То есть пока у вас идут только инсорты, инсорты, инсорты. В результате куча, так сказать,
выглядит вот таким вот нехитрым образом. Да, элементы просто расположены в том порядке,
в котором они расположены. И тут, в общем-то, никакой мистики нет. То есть просто еще там три. Ну вот и
так далее. Вот. То есть пока не произошло ни одного экстракт-мина, куча выглядит практически так.
Ну ладно, она не совсем так выглядит. Она на самом деле выглядит. То есть в ней еще есть указательное
минимум, который мы поддерживаем. То есть его достаточно легко поддерживать. То есть если я
сейчас вот теперь добавлю какой-нибудь элемент типа 4, то он не поменяется. Но если я сейчас push
back ну 1, то ну ничего страшного. Значит, этот указатель теперь будет указывать сюда. Видите, да?
Ну хотя это указатель, конечно. Вот. Нет, ну скажем так, указатель просто указывает на область
памяти, а итератор он там указывает с конкретными требованиями. Скорее так. Я бы пока не так сказал.
Ну собственно сейчас нам не принципиально. То есть более того заметим, что пока у нас не будет
экстракт-мина, в общем-то куча больше ничего делать не будет. Буквально. Вот пока нет экстракт-мина.
Не, ну действительно, а что? То есть, то есть действительно, вот предположим, что у вас есть
задача. Да, структура данных и в ней нужно делать две операции. Первая добавь элемент,
Б скажи кто там у тебя минимум. То есть заметим, что тут в этом случае структура данных, в общем-то,
тут еще и делает жирнее, чем могла бы. Ну потому что если у вас гарантируется, что никогда удалений
не будет, то вообще никогда, то в общем-то, что тут думать-то вообще. Давайте просто хранить минимум,
от единицы памяти и все. Ну в общем-то, видим, что эта структура данных пока больше ничего не
делает. Более того, без экстракт-минов слияние за от единицы тоже делается без труда, правда?
Ну потому что если у вас есть два списка, надо их объединить. Так, как же объединить два списка?
Но, как говорила там одно мое поколение студентов, берем и объединяем. Все,
прям конкатинируем в тупую. Ну понятно, я думаю, нет, нужны говорить, что тут понятно,
что есть указатели на begin и end, естественно. Так что, в общем-то, там на два списка всегда
такое есть, поэтому там, собственно, скантачить два списка и выбрать кто из их двух минимум,
общий минимум. Думаю, проблем не будет. Вот, и все будет реально работать за от единиц. Вот,
но как только появится экстракт-мин, вот тут это называется, как говорится, бугагашечки зашевелились.
Да, знаете, как это бывает, когда к вам приедут с проверкой, вот тогда,
потому что, действительно, тут возникнет проблема, что, ладно, если потребует экстракт-мин,
то возникнет маленькая проблема. Ой, это ж надо минимум пересчитывать, да? Что ж делать? Вот,
но тут, на самом деле, да, алгоритм будет бегать действительно по всем этим элементам за линию,
но будет не просто бегать, а фактически строить из них, но по факту будет строить просто
биномиальные деревья. То есть, смотрите, как это будет. Ну вот, то есть, что он вот буквально будет
делать? Значит, он будет говорить, то есть, в данном случае он скажет, что так, значит,
все вот эти одинарные элементы, все эти одинарные элементы, это что такое у меня? Это биномиальные
деревья ранга ноль, правда? Вот, ну, логично, да? Вот, поэтому давайте из них делать что-нибудь
более красивое. Так, вот, например, вот поехали, сейчас поэтому прям список полностью расформироваем
и формируем новый. Значит, работаем так. Вот у меня есть пятачок. Так, круто, у меня теперь есть
дерево ранга ноль. Так, а теперь появилась двоечка. Это тоже дерево ранга ноль. Нам это не
нравится, потому что нам не должно быть двух биномиальных деревьев ранга ноль. Ну, просто как-то вот
возникает сразу интуитивное ощущение, что если у нас есть два дерева одинакового ранга, то,
наверное, надо из них сделать что-то, ну, что-то большего ранга. Ну, мы понимаем, что двойка меньше
пятерки, вешаем эту пятерку куда-нибудь вот сюда, и у нас появляется новое дерево ранга один.
Красиво, правда? Вот, что будет дальше? Будет восьмерочка. Что мы будем делать? Так, ну, а что
дерево ты ноль? А у нас нет пока дерева нулевого ранга, так что нас это устраивает. Вот, понятно,
да? И теперь, а дальше появляется стройбан. Так, два дерева ты ноль. Так, ладно, надо объединять.
Тройка больше восьмерки, вешаем сюда. И вот у нас появилось дерево ты один, и ой, а у нас дерево
размера один, то есть ранга один уже есть. Что же делать? Конечно. И у нас появляется,
добрый день, вот, и у нас появляется вот такая красота, дерево Т2. Ну, ладно, можно, наверное,
сократить себе тут немножко работу и сразу сказать, что, в общем-то, по факту, да, в какой-то
момент, ну, вот, ну, то есть, думаю, если вы так дальше проимулировать, то уже не сложно видеть,
что по факту у вас тут на самом деле будет дерево Т3, у которого тут будет 3, 5, и тут от него будет
еще 6-7 висеть, и еще четвертика, конечно. Да, пока не будет, пока сейчас не начнутся не тривиальные
всякие дилиты и дикоискии, так и будет. Это будет просто практически честно биномиальная куча,
только ленивая. Вот. Так вот, что мы теперь делаем? Значит, вот мы теперь говорим, что у нас это будет
вот так. И последнее, что мы делаем, это, значит, во-первых, объединяем корни этих деревьев в
двусвязный список. Вот. То есть при удалении вот получилось вот что-то такое. А, и последнее,
конечно, что в конце вы обязательно должны найти, кто тут минимум. Погодите, доживем сейчас до экстракт
мина. Вот. То есть смотрите, какая ситуация. То есть мы будем говорить, то есть мы будем считать,
значит, мы будем считать, что у нас, ну, по крайней мере, вот до этого момента будем считать, что у нас
куча фибоначчи. Это просто набор биномиальных деревьев. Причем с очень интересным инвариантом.
Мы вообще, в общем случае, мы не гарантируем, что эти биномиальные деревья обязательно попарно
различных рангов, но мы будем гарантировать, что после каждого экстракт мина ранги будут попарно
различны. После каждого экстракт мина ранги попарно различны деревьев, висящих в этом списке.
Значит, да, как бы, давайте пришло время, значит, смотрите, пришло время немножко модифицировать то,
что у нас происходит. Потому что, да, теперь у нас, конечно, не обязательно список, хотя, как бы,
когда у нас будет инсорт, у нас тут мы снова будем считать, пушбэкать всякие элементы. То есть
теперь мы будем говорить следующее. Значит, мы будем говорить, что куча фибоначчи, значит,
вот в новой версии мы теперь будем говорить, что куча фибоначчи это, значит, двусвязный список
некоторых элементов, двусвязный список некоторых элементов, на каждом из которых висит корректное
биномиальное дерево. Там T и P, причем ранги могут быть расположены более-менее произвольно,
ранги, они могут вообще совпадать, не совпадает, там все что угодно может быть, поэтому я вот так
подпишу. Вот, значит, вот так выглядит куча, вот так выглядит куча. T и 5, там T и 6, там T и 7.
Да, то есть цель будет следующая. Значит, смотрите. Да, и, конечно, еще вот этот вот указатель на
минимум. Вот. Ну вот, то есть гарантируется, то есть гарантируется штука после экстрактмина.
Даже, знаете, я даже немножко по-другому это сформулирую, то есть можно, то есть примерно так
скажу. То есть, смотрите, вот давайте я даже примерную реализацию сейчас напишу, но это не
реализация, это скорее так. Значит, insert, то есть push backнуть, собственно, дерево T0 от вот этого
X элемента в список корней, так и список деревьев. Ну и, конечно, не забыть обновить вот этот вот
указатель на минимум. Вот. Значит, детмин, ну детмин, понятно, я тут можно даже сразу красненьким писать.
Что делает детмин? Ну вот, возвращает, в общем, вот этот вот элемент, который по этому указателю
находится. Да, я забыл в явном видео упомянуть, естественно, у этих деревьев будет выполняться
свойство кучи, что каждый элемент меньше либо равен своих детей. Я забыл в явном видео упомянуть,
ну вот. Так, ну что еще можно сделать? Melt, но тоже объединяем два списка деревьев.
Вот. Вот такая красота сейчас будет. А, ну какая красота. Ну вот, до этого момента вообще кайф,
в общем-то, ни о чем заморачиваться не надо, все работает за 1 железобетон, правда? Ну, то есть,
действительно, эти операции буквально работают, как я сказал, за 1. Нет, нет, нет, значит, сейчас мы
будем формулировать формально. И наконец, ну не наконец, и теперь его величество, экстракт мин.
Экстракт мин. Что-что? За 1. Два двусвязных списка. Да, это не вектор, а списк. Вот это важно,
что это двусвязный списк. Почему это важно? Потому что экстракт мин будет делать следующее.
Значит, удалить, значит, мы делаем так, удаляем вот этот вот то, что находится по указателю
экстракт мин. Значит, добавляем, добавляем в, собственно, список деревьев.
Собственно, этих оставшихся, этих бедных несчастных сироток. Вот. Вот, ну понятно, да,
что когда вот тут удаляется, тут у него были дети какие-то, да? Так вот, мы этим детям говорим,
так, дорогие дети, а теперь вы, собственно, будете в этом списке находиться. То есть сам этот элемент,
естественно, из списка удаляется, а вот эти вот его сколько тут детей? Раз, два, три. Допустим,
все эти дети торжественно отправляются в этот список. То есть теперь как бы тут тоже будет
еще вот все эти, вот этот вот список. Вот, понятно, да? Так вот, добавляем детей, а затем выполняем
мистическую функцию, для которой мы введем даже новый маркер, функцию consolidate. Так, видно?
Вот. Значит, что будет делать функция consolidate? Функция consolidate будет как раз заниматься тем,
действительно, да, что удалять в некотором смысле повторы. Она будет, ну пока мы говорим о
биномиальных деревьев, она будет следить за тем, ну скажем так, формальная цель, которая будет у нас
обобщиться на всю кучу фибоначей, будет заключаться в том, чтобы у всех вершин, вот корневых вершин,
была разная степень. Ну, в случае биномиальных деревьев это будет звучать так, что да, наша цель
добиться того, чтобы все деревья были попарно различных рангов. Вот. Итак, поехали. Как же будет
работать consolidate? Господи. Нет, все-таки, наверное надо. Нет, ну да, все-таки как-то. Ну ладно,
давайте попробуем. Итак. Итак, как? Нет, вот это достаточно хорошо видно, если я сейчас этим писать
начну. Хорошо. Итак, красивая функция consolidate. Значит, как я уже сказал, цель, как говорится,
чтобы степени корней в соответственно нашем списке были попарно различны.
Вот. Вот, соответственно. Как же она это делает?
Ну, делает она это, в общем-то, предельно просто. Значит, ну вот, значит, делает она это так.
Значит, значит, работа у нее такая. Заведем массив
3 из от 0 до D от N. Ну вот, указателей на деревьях.
Вот. Заведем такой массив. Указателей на деревьях. Вот. Ну, логично как бы задать вопрос, а что такое D от N вообще, да? Или все знают, что это такое?
Ну, давайте так, аккуратно скажем. Здесь, ну давайте так, начнем с того, что здесь N это количество элементов в куче.
Ну вот. А D максимально возможная степень вершин. Да. Ну, я буду писать степень. Ну, потому что в биномиальных деревьях ранг дерева и степень корней,
это одно и то же. Ну, забирая вперед, да, когда у нас будут появляться, когда мы будем делать декриски и диллит. Там будет такая неожиданная, но там будет такая неожиданная технология,
которая нам там весь анализ это перешамарит. То есть, вот эти реализации останутся теми же. Вот. Вот. Ну, то есть, смотрите, мистика будет такая, что мы опишем алгоритм, а потом по этому алгоритму докажем, что D от N не превосходит какой-нибудь логарифма.
Ну, такая будет схема. Ну, сейчас ты его док... Ну, вот. Так вот, заведем массив. Ну, вот. Собственно, ну, понятно, да, вот давайте это. Так честно и напишем, на всякий случай. Изначально трииз равен, ну, так и равен, соответственно, крестик, крестик, крестик.
Не, ладно, не будем крестики писать. Давайте напишем нолики. Нул ПТР, нул ПТР, нул ПТР. Вот. Так что вот такая красота получается. Ну, пока еще не получается.
Ну, вот. Далее, соответственно, пишем так. Значит, перебираем, соответственно, дерево T в нашем мистическом бывшем списке. Вот, понятно, да?
Значит, дальше говорим так. Ну, пишем, допустим, допустим, какой бы переменная позначить. Ну, допустим, Deg равен, допустим, Degree от T. Ну, сколько степень там у нее, да?
Вот, понятно, да? Ну, и дальше мы теперь должны это дерево в T добавить. Как вы уже догадываетесь, я очень хочу положить это дерево T в ячейку с номером Deg, правда?
Что? Вот. А, ну, в принципе, наверное, вы уже пробили, в общем-то, и что будет дальше.
Ну, если там есть что, то мы сливаем их. Ну, конечно, конечно. Это да, вот, совсем скучно. Денис уже вообще спит там. Собственно, да, неинтересно.
Вот. Вот, значит, далее. И далее, получается, пишем, while. Значит, теперь, while, значит, в показ, значит, там не пусто.
В 3 из Deg, то мы теперь говорим следующее, что наше T теперь равно Unite, значит, Unite от себя любимого и того, что там в 300 Deg написано.
Вот. Значит, теперь, плюс Deg мы теперь увеличим. А, нет, не увеличиваем пока. Значит, теперь объявляем, что это тут 3 от Deg у нас будет равно теперь 0 Pt.
И, конечно, не забываем, плюс-плюс Deg. Вот.
Все, на этом фор заканчивается.
Так, ну давайте вот тут. Так, теперь давайте вот тут еще, вот тут вот продолжим, да.
Надо еще в конце. Да, поэтому я и, ну вот, да, нужно еще в конце что-то сделать, поэтому я и переношу сюда стрелочку. Да, мы еще не дописали код, конечно.
Потому что как минимум. А, да, фор на этом не закончился. А, даже фор на этом не закончился. Да, то есть у нас тут.
Значит, фор на этом не закончился, потому что мы, конечно, должны теперь написать, что 3 из Deg теперь равен этому мистическому новому T.
И вот на этом фор действительно закончился.
Ага, и то, правда, да, правильно, правильно, правильно, да. Вот, конечно, конечно, да.
И, наконец, что теперь надо в конце сделать?
Да, составить нот, но я так напишу, составить из деревьев, из, ладно, аккуратно напишу, не пустых деревьев.
В 3 из Deg, соответственно, новый список.
Попутно не забыть, конечно, насчитать вот этот вот наш любимый красный указатель.
Вот такой вот у нас будет красивый Consolidate.
Слушайте, а камера эту доску видит вообще?
Кстати, о птичках-то.
Что?
Ну, вроде его включали. Я надеюсь. Ну, если нет, то можно остаться, как всегда, надеяться, что мой голос был.
Я ее вывернул, а вы ее назад поставили.
Ну, вот, да. Вот, стало лучше видно, да.
Этот Consolidate выполняем после экстрактмина?
Во время экстрактмина.
Ну, в смысле, да. Ну, в смысле, как только мы этот минимум, собственно, вытащили.
Да, как только, смотрите, минимум, не совсем, минимум вытащили, значит, детей, значит, детей тоже в корневой список прицепили.
И вот после этого мы объявляем Consolidate.
Вот такое. Вот такое вот красота.
Вот такая у нас технология.
Вот. И теперь, ну, теперь вот остается только чуть-чуть поанализировать.
За какую осимпточку, действительно, это все операции работают?
Ну, если брать честно, там по-честному, то Consolidate может вполне себе работать за линию, правда?
Ну, как мы уже показали, в самом-самый первый экстрактмин, собственно, ровно за эту линию и работает.
Да, но теперь давайте думать про учетную скорость, да.
Вот. Ну, действительно, то есть самый-самый первый экстрактмин можно было вообще сказать, что он за у от единицы работает,
потому что если он работает за у от n, значит, перед этим было n инсертов.
Так что можно было сказать, что он вообще за у от единицы работает.
Вот. Давайте к этому вопросу, как же это анализировать?
Ну, самый тупой способ, давайте вот как минимум вот это вот я сотру.
Я думаю, вот это нам не надо.
Нет.
Да, но в Consolidate мы как раз добивались того, чтобы их не было,
потому что когда мы объединили два дерева в степени deck, то у нас получилось одно новое дерево в степени deck плюс один.
Ну, смотрите, мы говорим, у нас есть дерево в степени deck, мы его хотим добавить в массив tris.
Вот.
Значит, что мы говорим?
Значит, да, мы его очень хотим туда добавить, и поэтому мы теперь говорим,
так вот, желобнот, хотим положить в tris, так, но если оно там есть, уже там другое, уже есть какое-то дерево в той же степени,
что мы делаем?
Мы берем наше дерево и это дерево, и делаем из них дерево в степени deck плюс один.
А, ну вот, а в этом месте массива мы пишем, что все, там больше ничего нет.
Ну, может оказаться, что этой новой степени тоже там дерево есть, но ничего страшного, мы их тоже объединяем.
Объединяем, объединяем до тех пор, пока, собственно, у нас там не появится дерево, в степени которого у нас в массиве 3 нет,
в массиве 3 нет.
Ну и в конце чем мы занимаемся? В конце мы это дерево, собственно, в эту пустую ячейку и кладем.
Вот такая вот у нас красота получается.
Понятно?
Вот, ну теперь давайте попытаемся анализировать это.
Ну, во-первых, анализировать, что тут предлагается методом потенциалов.
И потенциал, вот угадайте, к чему равен потенциал.
Да, количество просто деревьев в списке.
Вот.
Давайте, ну вот.
Так.
Ну вот.
Вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Так.
То есть это будет равно, ну да, нот.
Ну вот.
Ну ладно, пока я так и напишу, количество деревьев.
Пока не научились.
Нет, мы, скажем так, мы все добавляем постепенно.
То есть пока мы не научились дилит и дикриски, но мы пытаемся доказать, что без дилита и дикриски это все сейчас прекрасно работает.
Значит, количество деревьев в списке.
Мы будем это называть, вот эту штуку мы будем называть T от H.
Ну H от слова hip.
Ладно, вот можно даже написать T от hip.
Вот, вот такое T.
Ну хотя нет, T у нас буковка.
Ладно, давайте cold T.
Вот так.
Нет, нет, нет.
Размер 3, это фиксированный массив, обратите внимание, нет.
У него размер D от N плюс 1.
Вот.
Вот cold T от hip.
Ну вот, так что можно сказать размер вот этого вот листа списка деревьев.
Ну давайте посмотрим, что происходит относительно этого листа, относительно этого потенциала.
Значит, инсорт.
Ну, как там меняется потенциал?
Потенциал phi превращается в потенциал phi плюс 1, правда?
Потому что когда вы добавили одну новую вершинку, то у вас количество деревьев увеличилось на 1.
Поэтому получается учетная стоимость.
Получается какая у нас?
Стоимость, цифра, цифра, цифра, цифра.
у вас количество деревьев увеличилось на 1, правда?
Поэтому получается учетная стоимость, получается какая
у нас?
Значит реальная стоимость единица плюс то, что в конце,
минус то, что в начале, правда?
Это равно 2, то есть у от единиц, то есть отлично,
все еще работается, вот единица, согласны?
Чего обозначим, кого обозначим, что каким транслитом написали?
Это как строка, да, кол это кол, кол от русского слова
Структуру данных надо назвать КУЦХА
О господи, все?
Не получается, типа транслитом
Господи, КУЦХА, господи
Не, ну можно было им писать СНТТ, конечно, да, да
Ладно
Так, ну в гетмине, давайте пишем дальше, гетмин
Но здесь не интересно, 1 плюс ФИ минус ФИ равно единицы
Структура вообще не меняется, потенциал не меняется
Работает единица, не интересно
Так, МЭЛТ, внимание, господа
Внимание, МЭЛТ
Ну шо он делает?
Значит МЭЛТ делается за единицу
Но теперь смотрите
Значит потенциал итоговой кучи он равен ФИ от H1 плюс ФИ от H2
А тут минус ФИ от H1 минус ФИ от H2
Ну потому что от того, что мы что-то там объединили
Количество, ну потому что если у нас есть несколько куч
Ну вот, то есть если у нас есть несколько куч, то их потенциал, понятно, это сумма потенциала всех куч
То есть если у нас есть система куч, то общий потенциал это общее число деревьев во всех списках
Ну очевидно, что от того, что мы два списка взяли и объединили в один, количество деревьев в них от этого не поменялось, правда?
И сами деревья не поменялись
Поэтому это тоже от единицы
Вот так
Ну а теперь уважаемые знатоки, за сколько работает экстракт мин
Вот скажите мне реальную асимптотику
Да, ну да, можно начать с того, что Colt, конечно
Плюс, плюс чего?
Количество, да, но заметим, что
Да, давайте по чуть-чуть идти
Во-первых, до консолидейта у нас Colt прибавляется еще какая-то степень вершины
Ну то есть давайте оценивать ее сверху как D10
Ну степень не происходит D10
Ну а теперь заметим
То есть мы пробегаемся, но правда возникает маленькая проблема
Маленькая проблема заключается в том, что каждое дерево мы не за от единицы обрабатываем
А мы каждое дерево обрабатываем за, в общем, худшем случае D10, правда?
Да, но с другой стороны тут тоже, тут можно заметить маленькую приятную факту, что
Ну там можно сказать, что с точки зрения учетной стоимости, вот этот вот Unite работает за учетную стоимость 0
Ну ладно, вот это все работает за учетную стоимость 0, почему?
Потому что он делается это все за от единицы и потенциал уменьшается на единицу
Итого получается учетная стоимость 0
То есть действие как бы было, но как бы время работы 0
Потому что, смотрите, было у вас какое-то количество деревьев глобально, да?
Мы тут взяли, объединили два из них, вот это вот проделали, да?
Вы это сделали за от единицы
Но потенциалу, но количество деревьев в результате у вас стало суммарно на единичку меньше
Поэтому учетная стоимость конкретной этой операции 0
Ну вот, мы чуть позже будем работать такой терминологией
Пока, конечно, можно обойтись более простым образом
Можно сказать, что да, мы будем работать за такое количество деревьев плюс Unite
Но количество Unite не может превосходить количество деревьев, правда?
что да, мы будем работать за такое количество деревьев
плюс количество юнайтов, но количество юнайтов не
может превосходить количество деревьев, правда?
Поэтому отсюда мы уже можем сделать вывод, что в общем
реальное время работы будет вот такое, правда?
Вот, понятно, да?
Понятно?
Вот.
Та переча.
А теперь давайте посмотрим, как изменился потенциал.
Ну, что приятно?
Приятно то, что в самом-самом-самом конце потенциал стал
не более чем D от N плюс 1, согласны?
Что?
Ну, D от N это максимальная степень вершины, она может
быть от 0, поэтому D от N плюс 1.
Вот, минус, но минус, соответственно, пишем colT at h, то, что было
раньше.
Изначально он был colT at h, а в конце стал D N плюс 1.
Сейчас мы не можем оценивать как уменьшение потенциала
на 1, потому что вот мы сейчас второй раз уже вычли потенциал,
но мы можем оценить юнайт как действительно количество
деревьев.
Ну, нет, давайте, нет, ну да-да-да, это не совсем то,
но мы сказали, что да, да, это да, consolidate, да, мы
посчитали, о, давайте я даже правильно напишу.
Знаете, что я напишу?
Нет, у себя не стирайте, я просто напишу это другим
цветом.
colT at h плюс D от N, реальное время.
Я это опишу зеленым, чтобы подчеркнуть, что это consolidate
по факту.
Ну, то есть понятно, что там без consolidate тоже есть
в экстракт мини, да, вот это удаляем, там записываем,
но это все за вот те самые D от N прекрасно делается,
правда?
Да, но смотрите, но дело в том, что количество итерации
цикла while – это количество юнайтов, которые вы делаете,
правда?
Вот.
А количество юнайтов у нас не более, чем вот столько,
потому что как бы, ну вот, если у нас было изначально
столько деревьев, то как бы не более, чем через столько
минус один юнайтов, у нас вообще деревья объединятся
в одно.
Вот.
Вот, ну и тут, соответственно, D от N плюс 1, да, потенциал
в конце, минус потенциал в начале, ну и что мы тут
видим?
Ну, как вы уже догадываетесь, наша классическая шлеп-шлеп,
и это равно O от D от N, то есть короче говоря, то есть
видим, что просто если нам еще и теперь фантастически
повезет и степень вершины не может оказаться слишком
большой, то в принципе вот уже победа.
Вот нам бы хотелось, чтобы D от N оказалось от логарифма.
Спрашивается, а, да, почему это так, я пока оставлю анализ
так, сейчас он будет сложнее, но пока мы действительно
можем по индукции, да, ну не по индукции, а по факту
честно убедиться в том, что да, прямо сейчас у нас
все деревья это честные биномиальные деревья, а это
означает, что, ну вот, то действительно утверждение
будет такое, то есть утверждение в дереве T с degree от, так сказать,
ну даже degree от T равном k, ровно, ну в данном случае
ровно 2 в степени k вершин, ну и отсюда автоматически
следует, что D от N это O от логарифма N, так что вот
такой вот, так что получается вот такой вот промежуточной
победы мы и достигли, да, то есть, конечно, пока никаких
этих ваших degree с KF, конечно, боже упаси, но вот досюда
мы справились и, в общем-то, даже, да, вопреди стереотипа
того кучи фибоначи не сильно пострадали. Вот, красиво,
правда? Так, ну что, есть ли тут какие-то вопросы?
Дело вот в этой мистической строчка. Мы же не просто
удаляем минимум, а оставшихся его детей мы тоже добавляем
в корневой список, поэтому в этом месте длина этого
списка в этом месте на D от N увеличивается, ну не более
чем на D от N, конечно. То есть, да, это все верхние оценки.
Так, то что, есть ли тут еще какие-то вопросы? Нету.
Потому что, ну, например, по индукции, базы индукции,
когда вы создаете новые деревья из одного элемента,
в нем ровно два в степени ноль элементов, то есть один,
это он есть. Вот, и степень в него реально ноль. А дальше
по индукции просто что, если для деревьев это все сделано,
то есть там. Вот. Так что, красота. Вот. Ну как же в
это все впишется действительно всякие длинные дикарески.
Так. Ну, не знаю, в принципе, по времени кажется, что
можно в этом месте и перерыв сделать. Итак, господа, и
так, попробуем продолжить.
Ладно. Так. Так вот. Значит, то теперь давайте думать,
как же можно вообще удалять? Ну, на самом деле давайте
вспомним. А как вы пытались удалять элемент из рандомного
места в косой куче? Ну вот. Какие детей? Вот. Вот, допустим,
мы там взяли. Итак, давайте вспоминать. Значит, внимание,
да. Сейчас у нас так немножко воспоминаний, прежде всего.
И у нас идеи на тему удаления уже были. Вот. Нас возникали
идеи, что если вы хотите удалить элемент, вы его
просто берете и удаляете. А если на нем висят два каких-нибудь
дерева, то вы так жественно объединяете эти деревья.
То есть, во-первых, вызываете мэлт от них, а от результата
у результата делаете мэлт с тем, что осталось. Ну,
потому что у нас тут, потому что в реальности тут вот
такое дерево было, правда? То есть, просто мы брали
и не заморачивались. Почему не заморачивались? Ну,
потому что выяснялось, что по некоторым потенциальным
причинам оказывалось, что у нас все в порядке. Чему
у нас там был равен потенциал, кстати? Количество права
тяжелых. А когда у нас вершина называется права тяжелой?
Ну да, мы там говорили просто про размер. Да, то есть, мы
говорили от того, что если выпилить вот эту вершину,
то права тяжелыми могут новыми права тяжелыми
стать только вершины на этом пути. А мы знаем, что
на любом пути у нас количество права тяжелых вершин. Хотя
нет, неверно, что прямо на любом пути количество
права тяжелых вершин у вас обязательно логариф.
Но верно то, что в результате удаления могло стать право
тяжелыми не более чем логарифом вершин. Ну, суть была в том,
что если какая-то вершина тут стала право тяжелой,
это означает, что из левого поддерева тут произошло
удаление, и как следствие, когда вы тут двигаетесь,
размер поддерева увеличивается хотя бы в два раза, поэтому
логариф. Поэтому там оказывалось потенциалом так. Вот, но
действительно, если мы хотим это делать не в косой куче,
а в левацкой, то у нас возникают маленькие проблемы. Потому
что в левацкой куче, во-первых, требуется очень жесткий
вариант, что там все ранги правильно посчитаны, и не
говоря уже о том, что у каждой вершины ранг лево поддерева
больше либо равен ранг правого поддерева. В такой технологии
вам ничего не остается, кроме как честно пересчитывать,
идти до корня и честно пересчитывать ранги, ну и там свапаться
в случае чего. Поэтому мы говорили, что это работа
за линию. Но как, на самом деле, мне еще раз огромное
подсказание, действительно, на самом деле никакой страшной
линии тут нет. Но на самом деле основная идея оптимизации
говорит такой, если вы дошли до какой-то вершины, вот
шли вышли, тут шли до вершины, и обнаружили, что вот в этой
вершине ранг не поменялся, то можно заметить, что и
в этих последующих вершинах он тоже не поменяется, поэтому
дальше можно не идти, правда? А как минимум, потому что
ранг, что такое ранг? Ранг это максимум из рангов детей
плюс один. Все. Поэтому если тут вот что-то удалилось
и вы тут в какой-то вершине ранга от этого не поменялся,
ну значит его предкость тоже он не поменяет. В большом
случае эта линия амортизирована, это хорошо. Нет, тут круче.
Эта структура не амортизирована, и окажется, что действительно
оказывается, до этого момента, когда ранг не поменяется,
вы будете делать не более, чем лагерей функционеров.
Казалось бы, а идея очень проста. Потому что если,
смотрите, вот допустим, у этой вершины меняется,
вот когда вы удалили вот это дерево, и у этой вершины
поменялся ранг, чему он равен? Кстати, да не максимум,
а минимум, я преднаграбился. Но заметим, что если ранг
тут поменялся, то он стал равен 1, правда? Если у этой
вершины ранг поменялся, то он стал равен 2, потому
что если тут было меньше, то тут и раньше было меньше.
И дальше тоже ранг будет 3, 4, то есть во всех вот этих
вот, ну вот, если ранг меняется, то он как бы увеличивается
на 1, а мы помним, что ранг не более, чем лагерей. То
есть, на самом деле, вот конкретно, вот во всех этих
лестниках тоже оказывается, что такое удаление прекрасно
работает с алгорифом. Единственное только для этого удаления
вам придется, конечно, предков хранить, что не очень приятно,
но, как говорится, новый функционал, новые требования.
Вот. Да? Да, да. Нет, если он изменился, то он стал
ровно 1, потому что у этого под дерево ранг 0, потому
что оно пустое. Обязанно. Мы ж только что дерево
полностью удалили. А, ну я сейчас подразумевал, что
мы детей слили, а потом слили с результатом. Нет,
потом, нет, смотрите, первое, что я сделал, я сказал, давайте
выпилим просто все это под дерево. Ну выпилим в смысле,
потому что в реальности мы удаляем этот элемент,
сливаем эти деревья, а потом с результатом сольем
это мы по-любому за алгорифом делаем. Вот. Поэтому в этом
случае тогда тут будет прям жестко 0, 1, 2, 3, пока не поменяется.
Так что все в порядке на этот раз. То есть, может быть,
было бы точно какие-то оценки какие-то, если бы вы решили
слить эти два дерева и повесить их прямо сюда, если хотите,
но это уже на вкус и цвет, на самом деле. Как говорится,
на вкус и цвет у нас есть 10 фломастеров, не считая
местных, да. Попробуем из них что-нибудь еще сделать.
Ну потому что ранг любой вершины ливатской крути
не может превосходить алгорифма. Нет, это конечно же не значит,
что вот этот путь, весь путь до корня обязательно
меньше алгорифма, потому что совпадающие ранги тут
вполне могут быть. Ну потому что вы тут идете, идете,
а в какой-то момент вы приходите в вершину, что у вас тут
набежал ранг там 7, но оказалось, что у него там в соседнем
поддереве на самом деле был ранг 3. Поэтому тогда
вы тут пишете, что ранг 4, но тогда вы как бы скорее
всего говорите, что ранг особо и не поменялся.
Хотя нет, есть кое-что не так. Нет. Я говорил следующее.
Я говорил следующее. Когда вы выпиливаете под дерево,
вы хотите пробежаться по вершинам и пытаться изменить
их ранги. Но очевидно, что только в этих вершинах
ранги могли измениться. И вы их честно пересчитываете.
Да, пожалуй, вы правы. На самом деле неверное утверждение,
что они тут будут обязательно 0, 1, 2. Ну тут-то точно 1 будет,
но в будущем там могло быть по-другому. Тут стало 1,
то есть тут стало не менее чем 1, тут стало не менее
чем 2. Ну если уж уменьшилось, правда?
Если там стало меньше чем 2, то там просто ранг не
поменялся. Ну да. Ну да, но там вот так,
смотрите. То есть мы говорим, что если ранг уменьшился,
то он уменьшился благодаря этому дереву. И поэтому он
стал видимо по индукции аккуратно пишем 0, 1, 2, 3 и так далее.
Потому что если тут стало 2, то тут тогда либо ранг 3,
либо то, что было раньше. Но то, что было раньше из-за
соседнего дерева. Ну тут возникает вопрос в соседнем
поддереве больше чем 2 или нет. Вот. Но как бы вы идете,
идете, идете, но в какой-то момент натыкаетесь на вершину,
в которой вы хотите написать ранг 5, допустим, но выясняется,
что тут есть поддерево ранга 2. И тогда у нее как был раньше
ранг 3, так очевидно и останется. Потому что здесь ранг 4,
а был еще больше. Ну или такой же в худшем случае. И тогда мы говорим,
так в этой вершине ранг не поменялся, но тогда как следствие вот во всех вот этих вот ее предков
тоже ранг не поменялся. И мы на этом останавливаемся.
Нет, почему вот этих вот вершин, которые мы изменили ранг? Ну потому что ранги последовательно
увеличиваются. А ранг любой вершины не может превосходить логарифма. Ну потому что, напоминаю,
что такое ранг в вершине в этом месте, это ближе, это если вы будете, какое минимальное количество
шагов вниз вы из этой вершины должны сделать, чтобы достичь крестика. А там очевидно, что если
ранг хотя бы ката, то значит у вас там на катом уровне просто есть два степени кредитшина в подделье.
Поэтому логарифм. Вот. Это был левтист хип. Чего? Что, не слышал? Ну вот. Значит шоу дальше.
Смотрим на это шоу дальше. Вот. Ну а теперь возникает вопрос, а что же делать, если мы
хотим удалять из кучи фибонач? Ну, на этот раз, внимание, на самом деле ключевой функции,
который у нас будет, на этот раз будет дикрийский. Потому что, знаете, в этом месте я вот даже
просто сразу напишу. Смотрите. То есть если я хочу delete сделать, то есть delete от it, я буду
делать просто. Значит я скажу, во-первых, дикрийский. Значит от, соответственно, it и минус бесконечности.
Ну и после этого, конечно,
экстракт мин. Экстракт мин надо было красным, конечно, писать. Вот. То есть, в общем-то,
они такие взаимозаменяемые, оказывается. То есть можно дикрийский делать через delete,
можно delete делать. Но мы сейчас, конечно, будем delete делать через дикрийский. Ну, в общем-то,
для такой реализации дилита нам дикрийский от единицы даже не обязательно. То есть если мы
умеем дикрийский сделать за логорифом, то, в общем-то, без проблем. А ведь обратите внимание,
кстати, что интересно. На самом деле, если вас устраивает, что дикрийский за логорифом,
то, в общем-то, вот эту кучу модифицировать очень просто. Потому что фактически вам
даст все, что вам нужно. Для дикрийский это просто выполнить севтат, по факту. Ведь глубина-то каждого
дерева не превосходит логориф. Обратите внимание. Да, но мы очень хотим за единицу. Да, вот ровно
ради того, чтобы это была единица, на самом деле сейчас тут начнется основное мясо. Ну ладно,
не совсем мясо, конечно. Но сейчас тут начнется мясо. Мы тут, конечно, в анализе сейчас тут копаться
начнем. Вот чего. Ну вот. Потому что сейчас вы увидите, почему я как-то, потому что как бы сейчас
биномиальные деревья перестанут быть биномиальными. Значит, мистицизм будет такой.
Значит, во-первых, мы вводим такое понятие, как метка. Значит, внимание, у нас теперь будет
понять такое понятие, как вот я на это синеньким напишу. Так, синеньким я напишу или может мне
еще какой маркер достать. Вводим понятие марк от В. Значит, марк от вершины В, ну или там от И,
например. Она бывает, то есть вершина, знаете так, то есть бывает true, а бывает false. То есть знаете,
вершина бывает помечена капсом или не помечена. Вот. В общем, у остального реализация не поменяется
от слова никак. Вот. Понятно, да? Что? Реализация всех вот этих функций не поменяется. Да,
я ее специально вот так писал. А теперь. Значит, что будет вообще символизировать эта пометка?
Значит, она будет работать так. Смотрите, если вы неожиданно решили взять вот какую-то вершину и ее
удалить. Ну ладно. Значит, как мы будем делать дикриски? Значит, дикриски будут делаться очень
просто. Значит, мы будем брать это под дерево, отпиливать ее. Ну там, соответственно, вот тут
будет вот этот путь какой-то. Мы ее будем отпиливать. Вот тут есть глава. Ну вот. И
такжественно добавлять ее в наш список деревьев. Вот. То есть бабаха и вот сюда. Ну ладно-ладно,
это, конечно, не обязательно. Мы не обязательно из крайнего дерева удаляем. Вот. А вот теперь мы
ее вот сюда. Торжественно вот это дерево тоже сюда вешаем. Вот. Пусть вот эта вот вершина,
у которой значение мы хотим уменьшить. Так вот, мы сделаем так. Мы возьмем все ее под дерево и
повесим в корневой список. Ведь если, смотрите, если вы хотите уменьшить вершину из корневого
списка, то, в общем-то, уменьшить ее значение произвольным образом мы можем без труда. Правда?
То есть, ну единственное, что нам надо не забыть пересчитать наш любимый красный указатель. Вот.
Вот. Для красный указатель. Так. Ну ладно. Вот. Значит, что-то к чему тогда это приводит. Но,
правда, но как бы если вы хотите, да, действительно, если нам дикриски вызываются
только от корней деревьев, так случайно получается, то все мы делаем без труда. Но если вершина оказалась
внизу, ну тут тоже могут быть лайфхаки. То есть, есть как бы неосимпатическая оптимизация в духе,
что если вы ее уменьшили, она все еще больше своего родителя, то, а что тогда вообще заморачиваться?
То есть, ну уменьшилось и уменьшилось, ничего не поменялось. Но теперь, чего? Ну вот. Но теперь
значит, смотрите, теперь фишка следующая. Как это будет теперь работать? Но если вы все-таки
отпилили это дерево от родителя, то что делает родитель? Он выражает озабоченность. Вот. Вот
фактически эта пометка означает, что как бы у него отцепили ребенка, и он сильно озабочен этим
вопросом. А если у него много отцепили? Вот. Так вот. Но это нет. Пометка означает, что вы отцепили
первого. Значит, одного. Если в какой-то момент выяснилось, что вы тут попытались отцепить второго
ребенка, ну как подцепили? Отцепили. То вы заявляете следующее. Тогда, значит, вы делаете так. Вы
этого корня вы тоже такжественно отправляете. Ну, если попытались, ну ладно, не попытались,
а реально отпилили. То вы, значит, снимаете эту пометку. То есть, вы говорите, ладно,
ты успокойся, все в порядке. В общем, ты теперь тоже корень. И пометку снимаем. То есть, видите,
то есть мы не только это дерево вешаем, и не только второе дерево вешаем, но и сам этот элемент.
Сам этот элемент, ну у него же там какие-то там, сколько-то там минус два детей осталось,
вот пока я пока их не отпилили, собственно, вот вешаем. Да, важный, конечно, еще момент,
что те, кто в корневом списке озабоченности не выражают. То есть, им все хорошо, им там,
значит, им уже настолько хорошо, что от них можно детей отпиливать пачками. Вот. Да, но этого
родителя, но при этом мы родителя отправляем тоже в корень. Это важно. Да, а его родителя помечаем.
Во-во-во-во. Совершенно верно. То есть, поэтому эта функция называется каскадинг-кат. Вот.
так же соответственно значит в результате так так где бы мне это написать нет мы отрицаем того
ребенка который был вот этой вершины которую мы уменьшить хотим абсолютно любой нам по барабану
то есть я даже больше скажу очень удобно чтобы это было делать на самом деле детей реально
хранить тоже в двух связанном списке вот да ну естественно да мы как говорится да мы также
с тобой прощаемся с инвариантом о том что у нас все деревья это честные биномиальные естественно
вот так и в результате шоу начинает да то есть все где все вершины отправленные в корни их
пометка автоматически снимается нет честно биномиальные это в смысле что ну вот ну по эти
биномиальные дерево это там диранга к это дерево биномиальный дерево ранга к-1 которому
подвесили новый ребенок вот вот то есть вот это красота а не не надо обратите внимание вот
именно поэтому я в консоли дайте сразу вот заранее написал что цель степени корней в списке
попарда различной степени обратите внимание то есть мы ориентируемся только на степени
но строго не строго да мы следим так мы сливаем два дерева если так у тебя пятеро детей у меня
пятеро детей так давай сольем круто как это называется да я один батя сказал слушай наверное
слушай я понимаю тебе тебе тяжело когда вот пятеро детей давай ты будешь моим шестым ребенком
во как говорится да теперь у меня есть пятеро детей еще пятеро влуков да вот но вот и они еще
дерутся за это право вот так вот значит поехали значит в результате в результате работает это
примерно так значит внимание и так внимание дикрийский да попробуем этот дикрийский сюда
каким-то образом запихать так значит допустим чего ну тогда жалко потому что так этот анализ
стирать не хочется ну давайте да пожалуй мя так ну ладно ладно потом перепишем этот весь анализ
ну ладно это тоже полезно будет не хочу ну и да ну скажем так вот так с тем же успехом но я не
вот так вот показывать туда-сюда это все равно неудобно хочет как бы как бы смысл как раз в том
чтобы все как бы было это лицо вот ну да так так с этим точками да мы ее помним да
нет зачем не но все можно но ладно давайте так анализ мы потом все равно перепишем
тем более как вы догадываетесь потенциал по-любому поменяется вот
так нет вот это стирать не да это наверное стирать не надо нет это стирать не буду
потому что пока это иллюстрация к этому и так поехали значит дикрийский на все теперь мы значит
внимание дикрийский поехали значит вас приветствует итератор который вы удаляете
и соответственно ну вот ну давайте так ну я может быть сейчас не самым прям четким образом
это напишу но давайте но хотя бы железобетонно надежным значит пишем сразу значит если совершенно
случайно оказалось что значит если и корень значит корень дерево в списке
ой хотя что это еще тут-то нормально можно писать корень дерева в списке
то ну что нам тогда надо сделать it value там равно соответственно x ну естественно написать там
какой-нибудь комментарий if x значит и значит x меньше разыменовано указатель а то этот указатель
равен it но и собственно также но и остается только торжественно выбросится отсюда вот
но полады первой и флагича правда то есть просто если мы уже в корне то не заморачиваемся
зачем
а это неважно кстати красный указатель вполне мог уже указывать на этот элемент но
тогда он просто не поменялся и ничего страшного вот та переча но вот
хотя
вот ну по идее дальше надо было написать какой-нибудь вайлик да то есть типа пишем
там какой-нибудь родитель какой-нибудь от итератора да но то есть такие так вывешиваем это вывешиваем
этого ребеночка но нет нет все правильно делаем значит теперь так но вот но дальше значит делаем
примерно следующее значит тут теперь пишем it давайте так напишем значит но раз у нас все теперь
надо точно вырезать то значит теперь остается только действительно писать значит it равно
значит я так напишу так называемый каскадинг кат вот вот
это вот но эта функция обычно называется каскадинг кат
то есть пусть она возвращает итератор на кто кем он в итоге стал ну и все что вам остается
да то есть на самом деле
да нет ну и пересчитать вот это так шатайте я прошу прощения конечно смотрите там у себя
пожалуйста вот но на самом деле полный код может вообще выглядеть вот так значит it равно каскадинг
кат от it вот и все и тут ритул можно убрать да потому что до самом деле вот то есть
мы все сведем к ключевой функции каскадинг кат вот понятно да а в аэл в каскадинг кате
потому что каскадинг кат цель каскадинг ката будет ровно в этом каскадинг кат будет
брать вершину отправлять ее в корневой список а также помещать родителя или если выяснится что
родитель уже помещен то вызывать рекурсивно каскадинг кат от него то есть работать это будет
вот я прям вот здесь и напишу значит внимание такая вот ума так только он действительно что-то
возвращать должен но мы сейчас будем возвращать каскадинг
но условно не но видите как бы нам очень хочется хотя нет по большому счету знаете тут еще в чем
прикол а да вот этот и знаете почему можно не писать пуши итератор у нас устроен так что он
всегда указывает на вершину независимости от того является она корнем или нет дата такой прикол
так что можно так не заморачивать так вот каскадинг кат от этого мистического ита звучит так
сейчас не не не не аппе то не я думал об этом но вот из-за того что мы этот и твэлью должны на
икс поменять придется то есть лишний апдейт придется нет я согласен с тем что там как бы
мы тут будем что-то делать но как бы переписать все равно хотя да можно было написать и твэлью
каскадинка да это правда да Abddon давайте так и напишем чтоб код короче был в каскадинк
сейчас отправите кучу вершин и у этих вершин но в принципе да ну ладно давайте так да ну единственное
но это все равно придется обновить в общем усмотреть мы воюем за доску которая нам потом еще
симпатику анализировать а там чуть побольше потребуется я вам так заранее предупрежду вот
на самом деле да все да теперь поехали каскадинка писать что не на этот раз нет
так хотя нет да три строчки мы как бы все равно от этого не сэкономим тут конечно большой соблазн
написать что если это родитель то есть если это уже корень то просто сразу до свидания черт
зря мы это сделали ну потому что первое что хочется тут написать сказать что если это уже
корень то ничего делать не надо да хорошо только тогда только тогда в этом случае а минимум кто
пересчитывать будет откатывайте назад
да
так не не не мы договорились что нет мы другой сидит у нас так всегда что и
тратор всегда указывает на одну и ту же вершину вне зависимости от того кто она
в куче то есть помните да смотрите основная идея тут заключается в
следующем что как бы любая наша структура данных в этой любая куча всякой там где на
самом деле вершины сами не меняются меняются только указатели которыми они друг
другу указывают это будет верно и в кучах это будет верно во всех ваших этих вот по
факту в дикартях когда вы пишете дикартячку ровно это и происходит вот вершины не меняются
вас меняется только что кто кто кто на кого указывает по большому счету но сама вершина
от этого физически в памяти находят там своего положения не меняет то есть да то есть
конечно интуитивно давит а вы вешайте переподвешивать и так далее но по факту
реально вы просто стрелочки там просто перерисовываете как бы да вы говорите что вот
этот дом указывает вон на тот дом ладно теперь вон тот дом будет указывать вон на тот дом но
физически дома от этого не делись никуда то есть они мы хотят вы этот дом вот над тем домом не
повесили или тот дом там не знаю куда-то там вот это вот не спустили так ну да да можно себе это
и так воображать да ну да действительно можно за да обнаружилось что действительно обновлять
можно только в самом конце действительно поэтому говорим что если оказалось что x действительно
меньше чем звездочка этот красный указатель то тогда пишем что это равно все да все вернули
вернули такое давайте так будет ось нет не будем так писать вот так вот вот и теперь начинаем
каскадинка значит поехали первое что нужно сделать но первых если это корень то вообще ничего не
надо делать правда поэтому так и пишем если совершенно случайно как говорится ид в корневом
списке а как проверить лежит ли ид в корневом списке ну да то есть если ради есть ли у этого
и то нет родителя то мы такжественно выбрасываемся с криком ура потому что больше ничего делать не
надо то переча то то переча что будет дальше но дальше мы теперь говорим вот но во-первых давайте
скажем что вот у нас теперь есть мистический п п равно и ты parent значит соответственно да во
первых конечно значит дальше пишем поместить ид в корневой список обязательно но п мы сохраняем
поместить ид в корневой список прям вот и самое важное не забыть что сделать ид
mark равно false что что parent а это мы будем считать в поместить ид корневой список это как бы внутри
зашита но главное пометку снять не но просто так так по этой локе давайте это тогда уже надо
прям полную реализацию писать там нет в принципе можно заборочиться но нет смысла но как бы если
очень хочется посмотреть на подобного рода реализацию то в принципе вы можете кстати
открыть ее в кормине да в канут там можно в кормине или если хотите у меня кстати презентация
на эту тему тоже есть но не знаю вот так но так почему-то мне больше нравится не знаю почему
вот значит марка до фолс а теперь а теперь важный момент значит если п еще не помечен
то значит пишем
а в противном случае что мы делаем а в противном случае мы торжественно вызываем
каскадин как вот ладно тут еще у нас правда есть маленькая ошибочка вот ошибочка правда
заключается в том что придется вот здесь все-таки пометку на всякий случай снять ну не на всякий
случай а просто может так случиться чтобы пометили эту вершину и то есть как вот пометили
эту вершину она могла оказаться кофе то есть тогда либо здесь это проверять либо вот как
я сейчас делаю вот здесь значит так и написать и соответственно мак чтобы уж точно было равно
нет ну потому что пока мы говорили что просто ой это корень выбрасываемся и тогда могло
случиться так что вот этот родитель вот как бы вы делали каскадинка этот вершину который
родитель корень и тогда мы этот корень как бы да вы правы вы правы дайте это просто не поможет
а степень вершины мы обновляем ну например вот вот вот в этой вот строчки ну да ну можете
считать что в каждой вершине п хранится там в явном виде сколько у нее степень и когда вот тут
происходит какое-то выпиливание то там минус один да согласен да здесь нет ну искать его не надо
потому что у нас и так уже есть и и можно считать что как бы у каждого и ты еще есть там указатели
налево и правого моего там брата но как бы и находится в двухсвязном списке детей вот этого вот
сейчас кажется что эти деревья хренятся снизу вверх вверх вниз по моему вообще
что-то да сейчас анализ будет сильно сложнее да но скажем так мы убедились в том что этот
код перед этим когда он тут было просто по маха в нутру как бы в этом месте бы каскадинка
остановился и мы никак не проверяли что п корень а мы договорились считать что мы заявляем что все
корни не помещены что помещены могут быть только не корни ну ну ну скорее для удобства нет ну как
сказать мы сейчас проведем анализ как бы и если вы можете сформулировать четкий вариант который
позволит этого не делать то пожалуйста да скорее всего там можно но это просто будет чуть-чуть
более мутно получится то есть легче уж так написать что п не корень вот вот собственно и
все реализация куча да но теперь мы замечаем конечно что да ну в общем заведом что действительно
нам стало чуть сложнее потому что конечно же называется заявлять о том что деревья у нас бин
якобы биномиальные якобы ну как-то перебор правда и получит но нет мы трезвое самое главное
требование по большому счету для нас это то что степень вершин от логарифма в данном
случае как бы но раньше это базировалось степень вершин логарифм базировалось на том что тут как
бы в дереве степень и степь со степенью корня кантом два степени к вершин теперь это откровенно не
так просто на первом же выпиливание но заметим что но вот но и более того конечно мы можем
заметить что каскадин кат у нас конечно называется зараза может долго работать но правда при этом
у нас есть некие мистические пометки пометки но с другой стороны заметим а сколько у нас каскадин
ката вообще будет выполняться ну то есть сколько раз они будут вызываться рекурсивно ведь по
большому счету можно на самом деле а ведь зачем мы делали эту пометку то есть эту пометку можно
использовать в амортизационном анализе каким образом но можно сказать так давайте будем говорить
что как только мы пометили какую-то вершину мы положили ей монетку которой она будет оплачивать
свой будущий какой-то рекурсивный каскадин кат вот можно себе такое вообразить отлично да
такое себе вообразить действительно вполне можно и хорошо вот но тогда получается что когда вы
запускаете каскадин ката какой-то вершины ну первый каскадин как вы там честно за единицу
делаете а последующие а последующие вот эти рекурсивные вызовы они делаются за можно сказать
они делаются за время 0 почему они делаются за время 0 да потому что каждый каскадин кат он
делает каждый конкретно это это действие тупо оплачивается своей монеткой понимаете да
да но ведь пометите вы только один раз в самом конце когда помечаем вершину заметим что одна
серия каскадин катов она пометит но вот она сколько но вот она пометит ровно одну вершину ладно
не ровно не более одной вершины в конце ведь я потому что цепочка цепочка обрывается как
только какая-то вершина помечена или да или кое-но а если она еще и корень оказался мы еще и не
и получается интуитивно что этот каскадин кат реально за вот учетно можно подогнать так
специальные монетки для него ввести чтобы он работал за вот единицы да вот ровно это мы
сделали то есть по большому счету знаете на уровне так это на уровне решения существует мы
можем так и сказать что для incarn специально для каскадинights мы выводим вот эти монетки да
специально для каскадин ката это можно вести эти монетки сказать что каскадинках работает
там учетно за вот единицы в чем учета со своими монетками которые никак не пересекаются с
потенциалом и остальными и тогда получается все остальные операции у нас работают дихирarest
получается работать за от единицы потому что он ну потому что он кроме каскадинка там он
делает от единицы операции буквально вот и получается все остальные операции ничего не
поменялось вот так что потенциал ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай ай
ай ай ай ай ай ай ай ай ай ай ай ай ай ай
тут было написано экстракт мин это от д от н а д от н мы заявляли что логарифом то есть
это утверждение о том что это д от н все еще верно но но правда с потенциалом тут придется
пошаманить ведь каждая увеличить то есть он увеличивает потенциал то есть получается
учетная стоимость относительно потенциала каскадин ката то есть там с монетками может у от единицы
но зато потенциал увеличится поэтому учетная стоимость а кажется вот единицы плюс сколько
сделали но а мартизировано да но тут вот начинается вот эта магия что такое амортизированное
изменение потенциала да да да именно ну то есть да то есть метод который для
в домашних заданиях наверно не нов было уже то есть давайте скажем что у нас есть
красные монетки у нас есть синие монетки ладно нет у нас есть синие монетки для пометок и
черные монетки для корней тогда но вот ну потому что давайте вот то есть можно вот так на уровне
думания метод бухгалтерского учета мог бы звучать так давайте на каждый корень вот это вот в списке
корней класть черную монетку черная монетка нам потребуется для каскадин ката
так вот для консолидейта понятно да то есть ну фактически наш потенциал ровно
этим и занимался правда вот теперь да есть черные монетки и у нас есть синие
монетки синие монетки теперь мы будем класть на пометки но теперь как будет
работать каскадин кат с точки зрения монеток то есть каскадин кат то есть
каждое перекладывание в корень с одной стороны но правда проблема такая что мы
потратим эту синюю монетку на каскадин кат да но при этом но при этом заметим
что нам потребуется новая мы должны было нам потребуется новая черная
монетка ну ка синие монетки ну синюю ну синие монетка это как бы она
символизирует что вершина помечена то есть но вот и синюю монетку мы тратим на
то чтобы вот переложить ее в корень ну для того чтобы это было за стоимость
но при этом как бы нам придется потратить черную монетку потому что это новый корень
поэтому получается неожиданный чит да как-то а давайте пусть монетка будет весь пусть
синие монетка то есть пусть пометка стоит две синие монетки и тогда с этим двумя
монетками мы делаем так одну синюю монетку мы тратим на то чтобы переложить вершину в корень
а другую синюю монетку мы перекрашиваем в черный цвет вот
да вот примерно смотрите в таких терминах можно на самом деле вот просто вот думать
ну и что о чем вы нет ну вот получается так вот придумалось но если вы хотите написать это
красиво и формально то конечно то на самом деле сейчас вот напишу что но то есть это вот
мы попытались на уровне монеток действительно как это вот упихать и идея получается такая
смотрите и теперь то есть теперь то есть на самом деле более формально звучит есть
я сейчас абсолютно то же самое сформулирую на языке потенциала
да это непонятно но смотрите мы сейчас значит мы с фороллером так я утверждаю что это шаманство
с монетками нам сейчас помогло добиться того что все операции за от единицы кроме экстрактмена
и длита которые все еще работают за от детен да нам потом придется доказывать заново что
да это равно лога лога потому что конечно это уже не работает но через да это мы мыслить продолжим
мы кладем синюю монетку на вершину которую мы пометили и кладем и не две не одну синюю
монетку сразу две вот ну вот черные монетки нет для консолидей так черные монетки может
быть даже правильных назвать зелеными монетками нет лучше черный но это другой вопрос но по факту
да но я бы сказал то с конкретно для консолидейта который вызывает стоковый экстрактмена
да вообще да на самом деле не без но это да но у нас тут че че ли потенциал
работал только нам одно число ввели а это пожалуйста да да а можно даже не сумму а сумму
с коэффициентами как мы сейчас и сделаем да
вот то есть вот потенциал мы так и определим две синие для того чтобы одной синей монеткой
оплатить само перекладывание в корень а другую синюю монетку перекрасить черный цвет и сказать
что вот это черная монетка на сам корень пометку пометку убирать да
просто нет мы как бы две монетки мы при пометке снятия пометки снимаем просто одну монетку мы
тратим а другую перекрашиваем черный цвет а действительно но вообще да но дочерск
смотрите так что ты тебе сказать можно все что угодно да но в таких методах когда вы да пока
вы начинаете объяснять кому-то еще возникает что как бы у кого-то в голове там принципиально
другая картинка поэтому можно запутаться поэтому да тут конечно бывает желательно написать
максимально надежный потенциал вот давайте пишем просто пишем ни никаких монеток нет а есть
просто количество корней в списке то есть вот смотрите мы это будем называть так мы это будем
называть colt от аж плюс два на colm от аж вот ну для краткости понятно да вот то есть как бы
количество деревьев плюс два на количество помещенной флеши значит и теперь объявляем
начну по значит поехали заново анализировать поехали это все заново анализировать так но
давайте смотреть как-то будет меняться значит анализ значит как работает инсорт но время
работы инсорта да честное время работы от единицы значит ну как потом вот как потом
но потенциал тут все то же самое да потому что значит я так напишу плюс colt плюс один плюс там
плюс два на colm да но колая но вот поэтому минус colt минус соответственно два colm потому
что количество помещенных вершин не поменялся там шлёп шлёп шлёп шлёп ну и короче вот единицы
мы сейчас проанализировали учетную стоимость инсорта вот я отражаю что она от единицы потому
что реальное время работы от единицы значит если перед инсортом у нас было количество корней
списки было colt а количество помещенных colm то тогда потенциал после операции стал colt
плюс один плюс два colm а до он был colt плюс два colm то есть поэтому побыть читали получается
в общем короче это реальное время работы до учетного времени работы должно обязательно
фигурировать реальные то есть помните учетная это реальная плюс разность потенциалов вот так
что получилась такая красота то есть то есть это тот случай когда опять реальное учетное
время работы больше реального потому что мы как бы говоря потому что мы еще новую монетку
условно кладем черную далее ну где тмин но здесь просто один плюс фи минус фи равно от единиц я
даже не буду писать colt colm просто потому что ни colt ни colm не меняет вот ну и конечно значит
meld но здесь мы тоже пишем один плюс фе один плюс фи два минус фе один минус фи два равно от единиц
но потому что как видим потенциал потенциал от этого не поменялся да то есть если мы как бы ищем
есть у нас несколько кучи моих потенциал говорим как сумму потенциала всех куч то от того что мы
там два списка объединили в один и количество корней не количество помеченных решений поменялось
очень пока митя то есть пока вот я вот очень жаль что это стер потому что пока текст не
поменялся практически никак так да и в общем-то и в экстракт мини он сейчас не сильно поменяется
значит давайте смотрим экстракт мин
чего-чего-чего-чего да но но этот нюанс ровно из-за этого нюанса я в будущем и
писал тут что реальное время работы будет равно colt плюс d от м да тут ничего не поменялось
экстракт мин также и работает colt плюс д от н но это реальное время работы вот ну заметим что
но вот дальше замечаем что значит потенциал в конце он уже не превосходит д от чего там
д от н плюс один по камере colt не превосходит но и придется написать плюс 2 colm но заметим что
в процессе консолидейта мы никакие вершины не помечаем и пометки не снимаем правда потому
что мы только сколько с корнями орудиям вот но и придется написать в конце минус минус colt
конечно и минус 2 colm то есть по большому счету можно вообще считать что есть черный потенциал и
синий потенциал и как бы общий потенциал это их сумма а потому что тут 2 colm мы в определении
потенциала себе прописали 2 colm зачем конкретно мы это сделали вот это вот когда мы сейчас начнем
анализировать каскадин как мы это поймем что что юнайт да он работает завод единиц конечно
ну а подвесить одну вершину к другому вы дольше делаете
но parent там еще в список детей добавить но это все золотые единицы делает так вот да ну
здесь понятно как мы уже говорили тут шлёп шлёп тут шлёп шлёп и это равно от д от н то есть
обратите внимание давите оценка на д от осталось осталось другой вопрос что д от уже теперь не
но чем не менее так то переча а
д от этот максимальная степень вершины который у нас только может встретиться в куче размера
да так и теперь начинает самое интересное ну заметил что д лиц анализировать ну как бы
надо про анализировать и криски дилит после этого пойдет сам правда теперь внимание декриски
значит внимание декриски ну самый самый надежный способ будет выглядеть так предположим что мы
в результате декриски добавили ка новых корней называется пусть у нас действительно обнаружилось
там пусть у нас стало ка новых корней ка может быть вполне все равно нулю
вот совсем доказательства может звучать так тогда время работы тогда какое у нас время
работы время работы но можно его оценить как к плюс один согласны ну реальное время работы
согласны но мы там за 1 там вот это пересчитываем или там пометки какие-то там еще в самом конце
ставим пометку да значит теперь какой у нас будет потенциал в конце потенциал в конце но если он
изначально деревьев было колте то в конце их стало колте плюс ка да а как насчет помеченных вершин
мы заметим что если мы сделали ка новых вершин то то тогда получается тогда получается мы
сколько-то пометок поснимали согласны получается придется писать что-то типа плюс 2 на значит
сколько пометки значит кол м минус ка минус 1 и плюс еще одна пометка в конце да но и мы же да но
давайте я тут напишу меньше либо равно чтобы было понятно что мы это все сверху оцениваем да
потому что вот эту самая почему потому что самую первую вершину которую мы отпиливаем
она могла быть вполне не помечено вот поэтому тут камень усадить так ну и соответственно да вы
читаем то что было раньше минус кол те минус 2 но кол им ну и тогда получается шлеп шлеп
а вот теперь внимательно смотрите значит шлеп шлеп шлеп шлеп и теперь что получается это
получается равно смотрите два черненьким у нас получилось два ка плюс один 2 ка плюс один и
теперь минус два на ка минус один плюс два вот теперь выплывает зачем мы эту двойку вообще ввели
у нас два раза ка возникла одно в реальном времени работы а другое увеличение потенциала
поэтому чтобы чисто анализировать давайте вот поэтому мы тут две синие монетки кладем то есть
одна синие монетка как бы оплачивает потенциал тем самым просто синие монетка переходит в
разряд черных то есть мы перекрашиваем синие в черное вот соответственно вот но зачем вот и
тогда но тогда у нас все в порядке тогда получается у нас ка тут тоже шлеп шлеп соответственно и
тогда получается что это равно в итоге 5 но это соответственно что-то тоже сопротивляться о от
единиц до жирных таких до жирно пятачковых но от единиц
если игнорирует то что у нас вот это все что мы посчитали за вот единицы тоже работает
константы ну че ну чипто но вот ну просто наш наш и красивый каскадин как он не то чтобы
там за прям честную единицу там тоже константы ну ну как она не ну как сказать он нет там
константы не может быть хорошей потому что это единицы нечестная по-любому а это не важно
но да да можно было вайлом это написать но суть одна потому что смотрите вы же не смотрите откуда
у вас взялось вот этих вот ка новых корней первый корень это та вершина которую вы решаете
хотели уменьшить правда а каждая следующая добраю да как говорится заходи у нас мы тут
собственно ничего не стирали для тебя вот наслаждайся вот так вот значит что у нас
получается а получается следующее что просто каждая следующая вершина она из-за чего она
вообще оказывалась корнем из-за того что она была помещена и от нее отпилили второго ребенка
понимаете да вот значит у нее отпилили второго вот и поэтому и эта пометка тогда снималась
автоматически вот это вот строчка нам собственно делает радость поэтому значит не менее чем ка
минус одна монетка снята была точнее пометка ну и монеток соответственно в два на столько вот
ну и в самом конце там самое там следующее первая которая не была перенесена в корень она могла
быть помещена а могла быть и нет если она тоже корень всякое могло быть вот так что таким образом
мы убеждаемся что декрески действительно работает за вот единиц ну и пока можем теперь
торжественно сказать что мы на текущий момент уже на самом деле торжественно доказали что
экстракт мин и как ну и автоматически delete работают за о от д от вот это мы теперь точно
доказали тоже доказали но скажем так пойти это одно и то же просто как бы вот гагарский
учет метод потенциалов это как бы сути просто слова разные суть одна просто здесь как бы
как бы метод потенциалов это когда я просто в явном виде прописываю сколько у меня в каждом
времени в кошельке должно находиться вот все так есть ли до этого момента вопросы
если до этого момента вопрос так ну у нас остаются 10 минут якобы да ладно по факту
посмотрим сколько у нас там реально будет и теперь начинается самое интересное
самое интересное что ж такое д от а то балли может это это корень
ну да нет доказать что д от н равно от н несложно да но тут вот надо следить
действительно что же такое д от н но тут на самом деле да подсказка конечно как-то в какую
сторону теперь что тут в какую сторону может находиться конечно может подсказать почему
это куча изобретенная робертом эндре тарья нам носит фамилию принципиально другого человека
вот казалось бы да не фиба на киши изобрел правда что в 16 веке алгоритмы не изобретали
пока не такие да ну и что это сфена это как бы штука которую реально очень удобно с
палочкой на глиняной табличке делать нет ну как сказать да да да прям это прям можно себе
это нужно изобрести а что это должно быть заведомство чтобы им к нему приходили в
окошечко и добавьте вот такой элемент а потом дайте мне самый маленький а потом
так возьмите эти два ведомства и объединить и потом заходят и там вот на стенах размешанного
да да да да причем стипичный особенно особенно его амортизированность да то есть
просто пока он добавляют там кидаем в кучу только ладно где-то храним где-то минимум а когда
вас требует минимум там это министерство начинает работать так вот ладно все давайте
шутки в сторону так давайте это шутки в сторону потому что это сейчас это как бы меньше будем
привлекаться раньше пойдем на обед тот принцип простой так вот значит смотрите к сожалению мы
потеряли действительно мечту о том что каждое дерево это реально честное биномиальное дерево
вот но значит утверждение теперь такое заметим теперь следующее что но первых заметим что как бы
у каждой корневой вершины понятно было какая-то относительно исходная степень да ну чей так
жила была вершина когда она была корнем нам было начать сколько у нее детей этих детей там как мы
уже говорили могли от пили отпиливать от нее пачками и не заморачиваться ну там когда-то
отпиливать но вот но кто в какой-то момент наступил какой-то консолидейт когда она
наконец сама ребеночком стала после этого заметим у нее могут отпилить не более чем одного ребенка
потому что как только у нее отпилят страну потому что значит то есть она уже как бы начала помните
она стала это она уже вырезала забоченность но вот а если отпилить уже второго ребенка то она
начинает вопить и собственно ее переносят в корень и она успокаивается помним да значит в
результате то есть но получается что пока вершина значит между моментами когда я когда она перестала
быть корнем и до этого момента когда она стала так что выпиливается от нее не более чем один
она успокаивается да но когда мы ее подвешиваем мы считаем что ее детей не отпиливали потом
могли но как бы в тот момент когда подвешиваем считаем что не отпиливали когда-то там отпиливали
но это была там в другой жизни то есть как бы и да то есть там можно считать да что это так
лучше так лучше это не считать что если она не корень нет если вершина сам нет если вершина
сама корень и туда могли отпилить и 2 и 3 5 и 10 утверждение так утверждение такое если вершина
не корень то с тех пор как она перестала быть корнем а ведь любая вершина изначально было корнем
да так вот если вершины не в не корень то с тех пор как она последний раз перестала быть
корнем от нее отпилили не более чем одного ребенка что это истинное утверждение подтверждающиеся
пометками потому что мы пометки ровно за этим выводить с пометка означает что вершины с тех
пор отпилили одного ребенка нет как только не отпиливают второго ребенка она такжественно
становится корнем мы смотрим последний раз когда до после того момент когда на последний раз была
корнем то есть как только не отпиливать второго ребенка она тут же становится корнем так вот то
есть получается что в общем-то если тут есть какое-то большое дерево то оно в общем-то если
прорежу но то относительно не сильно по крайней мере по степеням но вот и на самом деле ключевое
утверждение здесь звучит так значит утверждение сдаст пусть значит в вершина в куче фибоначи
пусть в вершина в куче фибоначи то есть мы рассматриваем какой-то момент времени понятно
да то есть рассмотрим какой-то момент времени вот то есть вот мы не взяли вот была у нас пустая
куча или набор пустых пусть мы сделали с ними несколько там мистических операций и после
пусть у нас вершина в куче фибоначи абсолютно все равно где она находится значит пусть в этой
вершина в куче фибоначи а в 1 в 2 там в 3 и так далее в к ее дети ну то есть соответственно понятно
как равно естественно дегрит вы причем что важно дегрит от v1 меньше либо равно дегрит от v2 меньше
либо равно дегрит от v3 меньше либо равно помпом помпом меньше либо равно дегрит от vk то есть
давайте мы запишем выпишем детей вправо в порядке отсортированном по степеням понятно да тогда
утверждаю неожиданно я дегри от любого вы этого больше либо равно
но чем как вы думаете что ну я даже дайте возьму на себя смелость написать следующее
ну вообще ну вот нет клада нет дегрит тут не надо писать
по чем я утверждаю что это больше либо равно собственно к твой какой к и минус
минус что ну вообще говоря ну допустим но вообще говоря там формулирует утверждение что и минус два
ну вот ну ладно давайте а если я напишу не минус два а даже скорее всего да правда ли это
будет даже и минус один вот минус один минус мак от в
хотя нет так ладно что-то это вот ладно вот это точно верно утверждение отдельный
вопрос как мы его сейчас будем доказывать вот так вот значит но
значит если мы поверим в это утверждение давайте с этого начнем чем оно нам поможет
я только давайте чего начнем что мы поверим в это утверждение всего доказательства
да просто верить до этого вполне достаточно тогда мы можем потом не доказать но ладно
давайте давайте попробуем его доказать доказывать естественно будем по индукции
по там деятельности которые мы будем пытаться делать вот ну во первых значит что может а действительно
давайте подумаем что может вообще происходить с вершиной но вообще как у нас вообще иногда
меняется структура дерева ну во первых вершине может кто-то подвесится новый ребеночек а может
так жественно исчезнуть правда но заметим что ну самое простое это когда подвешивать то есть
если жила была вершины инвариант тут ну там жила была вершина инвариант тут выполнен да но
смотрите если у нее тут была степень к и тут к ней еще подвесили вот это было к а тут повесили
каплю сперва но раз ее тут подвесили то тут тоже степень автоматически к согласны
получается что она вот сортирован но вот а степени здесь заведомо меньше правда или нет
а ну ладно на самом деле не да ну хотя нет на самом деле не факт то есть в общем-то у
нас у нас и нет исходной инвариантов на тему того что у любой вершины у детей степень меньше
чем у нас вот кстати действительно есть такой вариант нет конечно нет потому что просто мы
могли сейчас повесить а потом вот этих вот особенно искорней этих детей просто удалять
пачками да поэтому да такого инварианта нет но теперь мы но вот что у нас оказалось оказалось
что у нас тут мы значит у нас но есть они были инвариант то есть было сортировано по и минус
два но выяснилось что мы тут вставили чисел к выскакивает вопрос если этот кав ставить
вот сортированный список будет ли вот эта штука выполняться мы добавили нового ребенку у
которого степень ка а до этого детей тоже ка было это мы рассматриваем случай когда мы два
дерева вот консолидейте объединили помните когда мы их объединяли мы объединили два
дерева с одинаковой степенью вот ну теперь да тут два варианта значит самый простой случай
если оказалось что степень этой вершины оказалась максимальной тогда вообще ничего
не происходит потому что она вот сортированную списке оказалось ка плюс первой и у нее степень
тут ка все в порядке понимаете да вот но с другой стороны заметим что если она оказалась
под сортированной списке ни каплю сперва катой каме ну сперва и так далее то инвариант все
равно выполнен лично для нее но проблема могла быть конечно в том что тут возникли еще какие-то
вершины у которых неожиданно порядковый номер увеличился поэтому инвариант должен был усилиться
на единичку правда но с другой стороны заметим что у всех вершин у которых как бы это ассоциируем
позицию 8 списке усилилась на единичку у них получается степень должна была быть как минимум ка
правда вот но тогда уже но вот но ка соответственно так как у нас позиции все от одного до ка плюс один то
тогда ка больше либо равно чем ка минус один следовательно при объединении инвариант очевидно
выполнен очевидно выполнен потому что мы еще не все случаи рассмотрели нет смотрите тут как бы
до самого но то есть да можно было написать и минус один и если бы у нас не было вот этого
дикой эскиз этими каскадин безобразиями то и минус один была бы даже точной оценкой
потому что это были бы мы на мяльные деревья но увы у нас еще как бы степень вершины могла
измениться от того что у них что-то выпилили помните да вот но теперь но вот но вот но
теперь возникает следующее значит откуда тут берется и минус два то есть тут фишка загород
то есть фишка тут говорит следующее то есть тут действительно жила была вершина и когда у
этой вершины непосредственно но тут какие проблемы вообще есть ну а первых для самой
если у вершины отпилили ребеночка то просто у некоторых ее вершин просто ослабился этот
этот ослабилось это условие то есть степень вершин там не поменялась я просто условия
ослабилась понятно чем я говорю да то есть основная проблема возникает в другом основная
проблема возникает что этой вершины тоже есть родитель вообще-то вот и у этого родителя
обнаружилось что у одной из этих вершин отпилен но получается степень уменьшилась на единичку
и вот это уже конечно ничего не гарантирует
что вот желаю была вершина у ребенка который степень уменьшилась на 1
но даже не марка тв а наверное правильнее написать наверное
да скорее вот давайте вот так напишем правда давайте тогда давайте перепродумаю
здесь вот вот это вот тут у нас ничего не упало от этого ну ладно не но если вершины
степенька то там у нее ну скажем так когда вы эту вершину помещу вы помещаете она как бы она
не помещена но неважно потому что как бы давайте еще раз это рассуждение вот пусть мы сюда добавили
если она так в конце списка и осталось то она в списке ка плюс первая и соответственно ее
дегрид должно быть больше либо равно ка и это правда второе утверждение но вот если она все-таки
подвинула списке то для нее условия только лучше стало но вот для эти но у этих вершин как бы
и требование увеличилось на единичку но с другой стороны так как у этих вершин степень тоже ка или
более вот топлою но а их позиция стала не более чем ка плюс один то утверждение верну так отлично и
минус один минус мак сработала значит теперь когда вы что-то выпиливаете но когда вы просто
отпилили то у этой вершины все в порядке да просто для некоторых векшин для некоторых тут детей у
нее ослабилось условия для остальных не поменялась вот так что теперь самое интересное вот для этой
вершины что произошло сейчас да то есть у него с одной стороны
ну да тут тот и проблема что
но да то есть смотрите то есть ну то есть смотрите да сейчас давайте посмотрим да для этой вершины
действительно заметим что что у нее произошло до степени уменьшилась на один но и пометка у
нее появилось да то есть это по от пометку у нее появилось поэтому это неравенство для
конкретно да но скажем так от того что конкретно у нее поменяется и никаких страданий не будет
потому что просто вот эта часть неравенства уменьшится потому что если были точно
да ну тут ну да ну вот то есть да ну да то есть действительно если это вершина вы и да да
то но вот то есть действительно она упала то есть допустим жила была вершина она была номер и то
есть вот это 1 2 и так далее и об том бабаха до неожиданно превратилась в 1 2 жи то есть где-то
тут было 1 2 и тут неожиданно жи она стала вот она же бывшая и тогда получается что вот эти
вот товарищи от жи до и минус 1 такжественно теперь получили номера от жи плюс 1 до и вот
казалось бы для них это то есть казалось бы у них степень то есть действительно степень у них от
этого не поменялась а вот эта штука увеличилась ровно на 1 правда но с другой стороны заметим
следующее что степень у этой вершины у этой вершины она так или иначе больше либо равна чем
и минус минус 2 правда потому что перед этим была именно не менее чем и минус 1 и только что
стало и минус 2 и за это счет этого она провалилась да получается значит получается что у этих раз
они прошли значит тут степень больше ли правда чем и минус 1 и это нас устраивает даже для этой
и плевать на пометки так что да вроде выкрутились ну да можно даже точнее сказать что да тут надо
нас писать равенство но нам это не принципиально так короче то что каждое утверждение вроде
поверили или вычет забыли нет погодите нет я говорю про вот это вот утверждение так так больше
у нас ничего не происходит либо отпиливание либо ну да если отпилили второго ребенка то вершина
тоже вылетает в трубу это нам не интересно да мы доказали что да вот это минус марк
там минус 2 нет почему и минус 1 нет это правда потому что вот так
потому что для джиты вершины допустим она не она не была помещена но она забустилась еще какая
вот это она была только что помещена на нет я имею ввиду джиты до этого она не была помещена
да но она да но не степень то по любому как минимум и минус 1 как мы уже выяснили потому
что на степень нашей вершины ровно именно там больше либо равно чем и минус 2 конечно но не
строго больше больше либо но а больше либо равно но так как есть у нас так как у нас но тут
строго тут строго больше потому что мы как бы если бы они были равны то она бы просто сюда не
проваливалась то есть мы как бы пузырёчком ее туда проталкивали вот та переча ладно если мы теперь
берем в это утверждение то тогда я утверждаю следующее давайте я вот это сотру и теперь
чего спросить да ну смотри значит еще раз значит жила была жила была вершина номер и да вот вот и
мы ее только что отпилили ребенка как следствие ее пометили ее степень стала равна ровно и минус
два а была только что и минус один поэтому вот сортированном списке она могла неожиданно
провалиться на житую позицию вот вот допустим это теперь она вот это была вершина в вот
вершина в вот теперь вот это она ну для нее то условия по-любому выполнена вот а вот эти все
вершины же и плюс один же и помпом и минус один бывшие вот так вот потому что ладно не минус два
больше либо равно чем и минус два хорошо по инварианту вот этого потому что перед того тем
как у него отпилили ребенка она была больше либо равна чем и минус один стало следует
больше либо равно чем и минус два но так как мы ее просеивали пузыречком то тогда получается
что вот этих вот вершин степень строго больше следовательно она больше либо равна чем и минус
один тут больше либо равна чем и минус один я ну и и минус два плюс один ровно и минус один
потому что строй степень должна быть у этих решин строго больше чтобы эта вершина прям
ниже их просеялась нет мы только что ее помечили непосредственно смотрите была
перед пометкой марка не было и оценка была и минус 1 а теперь мы пометили и удалили оценка
стало и минус два но если было не менее чем и минус один вы выпили одного ребенка значит
осталось не менее чем и минус два вот вот и все а тот стало везде и минус один
а если мы взяли эту вершину и скажем так ее обогнали не могли обогнать вершины которые
имели степень больше она и минус два то есть с упадающейся степенью в но вот так
