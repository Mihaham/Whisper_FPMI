Всем доброго дня, мы с вами продолжаем курс по технологиям программирования, и сегодня у нас не
заработал проектор, да, то есть как говорится, мы тут про софт, но hardware нам тоже важен,
поэтому я сегодня буду рассказывать все на доске, посмотрим как это пойдет, но в целом все тезисы
есть в презентациях, давайте вспомним, на чем мы с вами остановились в прошлый раз, что мы с вами
успели пройти в прошлый раз, да, мы с вами ввели четыре аббревиатура, значит первое это solid,
какие еще были аббревиатура, да, значит давайте я их расположу в порядке снизу вверх,
значит первое у нас идет ягни, нам этого не надо, после этого идет кис, мы стараемся все содержать
как можно проще, дальше у нас do not repeat yourself и после этого у нас только идет solid и применение
паттернов проектирования, то есть именно в таком порядке нам важно именно использовать эти принципы,
то есть сначала выкидываем все лишнее, особенно когда мы говорим это про техническое задание какое-нибудь,
вот вы составляете техническое задание и думаете так, что именно сделать, и вы такие думаете-думаете-думаете,
а потом говорят, типа вы не прописываете чего-то, чего вы не будете делать и потом вам прилетает,
так сказать, требование, а почему вы не сделали того, что мы хотели, хотя по факту вы не
регламентировали то, что вы этого не делаете, в общем здесь у нас указываются как раз принципы,
значит это параллельно презентации, и на самом деле мы с вами начали рассматривать первые паттерны,
мы с вами рассмотрели один паттерн, кто помнит какой, да, мы посмотрели с вами фабричный метод,
это пример порождающего паттерна, к сожалению, сегодня у меня будет уходить некоторое время на
стирание с доски, давайте как раз вспомним к какому типу паттернов этот паттерн относится,
это порождающий паттерн, это структурный паттерн или это, да, это порождающий паттерн,
вот, и как раз мы сказали, что он полезен для создания объектов, для того, чтобы у нас не
нарушался принцип open-closed, и сейчас мы с вами посмотрим еще один пример, собственно мы
смотрели пример с буквой о, и сейчас мы с вами закроем так называемый технический долг и
рассмотрим пример с буквой D, это dependency inversion, давайте вспомним, что это, что это за
принцип-то такой, вкратце мы его можем нарисовать таким образом, что у нас с вами есть некоторый
прямоугольник, то есть у нас есть два класса, которые зависят каким-то образом от третьего класса,
да, то есть у нас есть класс B и C, и мы сказали, что у нас с вами детали не должны зависеть от
абстракции, то есть что мы с вами сделали, мы с вами сказали, что у нас здесь будет два интерфейса,
интерфейс E, интерфейс F, собственно, вот этот вот метод будет реализовывать два
интерфейса, а значит B и C будут использовать эти интерфейсы, вот, то есть картинка у нас
будет выглядеть вот таким образом, тем самым мы с вами можем успешно адаптировать наш код,
и вот каким образом реализовывается этот паттерн, этот метод на самом деле, он зачастую использует
так называемые обертки, они же являются адаптерами, то есть наша цель сейчас
посмотреть в чем заключается паттерн-адаптер, так, значит мы с вами рассматриваем паттерн-адаптер,
как раз мы вчера с вами опубликовали первое проектное задание, и вы начали спрашивать,
какие библиотеки можно использовать, какие библиотеки нельзя использовать, было такое,
начали уже спрашивать, вот, и оказывается, что некоторые библиотеки ну прямо реально монструозные,
кто-то у меня спросил, можно ли использовать unity, но мы с вами понимаем, что unity это такой вот
комбайнер, который не очень целесообразно использовать для написания всяких игр,
ну, точнее для игр удобно писать, но если мы хотим проецировать какую-то более крупную систему,
то, соответственно, там ее каким-то образом наследовать, то это будет не очень хорошо,
поэтому наша цель посмотреть, а можем ли мы использовать какую-то другую совместимость для
того, чтобы мы могли с вами работать с библиотекой, значит, смотрите, важный момент, который заключается
здесь, вот представьте, вы написали некоторую функцию, которая там, не знаю, вычисляет какие-то
величины, грубо говоря, функцию для вычисления математики, либо для конвертации типов, вы при
этом зависите от какой-то конкретной библиотеки, то есть вы сказали, что у вас есть класс А, значит,
он использует какой-то класс В в том плане, что он вызывает функцию x, y, с какими-то параметрами x, y,
и что у нас с вами выходит, представьте себе, что разработчики библиотеки В, а это какая-то
сторонняя система, допустим, меняет сигнатуру функции, что означает, меняет сигнатуру, то есть
меняет параметр, с которыми она вызывается и меняет то, что она возвращает, соответственно,
в чем возникает проблема в данной картинке? Да, мы уже вызываемся к несуществующей библиотеке,
у нас, возможно, даже сигнатура функции совпадать не будет, ладно, если мы это обнаружим на стадии
компиляции нашего проекта, но если мы с вами обнаружим это на стадии рантайма, стадии исполнения
проекта, это будет намного опаснее, потому что те же самые динамические библиотеки, такие как
Python и другие вещи, либо если мы работаем с вами с динамическими библиотеками, у нас может
случиться такое, что опа, мы подключаем библиотеку, вроде даже линковка произошла, а на время запуска
проекта у нас говорится, что такой библиотеки нет, все, у нас все не работает, или у вас,
допустим, версия библиотеки обновилась, а обратной совместимости нет. Что такое обратная
совместимость? Это вы, когда, образно говоря, берете какой-нибудь код, который написан на версии Python
3.6 и пытаетесь запустить на версии Python 3.7. Что означает концепция, которая стоит здесь? Здесь
мне, наверное, нужно рассказать про такую вещь, как семантик вершининг. Что такое семантик вершининг?
Это специальный способ нумерации версии нашего продукта, который состоит из трех составных
пунктов обычно. Значит, здесь указываются точки. У нас с вами есть так называемая мажорная версия,
у нас с вами есть минорная версия и есть патч-версия. Давайте проведем мысленный
эксперимент. У кого ноутбук с собой? У всех ноутбук. Давайте попробуем в командной строке написать
Python минус V. По-моему, такая команда. Сейчас я проверю у себя локально. Скажите, какая версия
Python у вас используется? Python минус V. Я проверил. У кого что написано? 3.11.7. У кого еще что?
Давайте свой компьютер назову. 3.11.6. Что еще? Давайте зайду на свой домашний компьютер, тоже там сделаю.
На моем домашнем компьютере 3.10.10. Кто-то еще хочет назвать версию? Ладно. Представьте,
что есть какой-то компьютер, который давно не включался. Лет так 5.7. Тогда у него будет версия
допустим 2.7.13. То есть будет вторая версия Python. Что означают вот эти разные версии? Мы видим,
что где-то у нас отличаются первые цифры, где-то отличаются уже вторые числа, где-то третья. У нас
есть большое количество примеров. Смотрите, когда мы меняем мажорную версию, это означает,
что код, который запускается на более новой версии, может не запуститься на старой версии. Это
ломает обратную совместимость. То есть мы с вами понимаем, что код, который запускается на версии
Python 3, не запустится на версии Python 2. Классический пример. В Python 3 что такое print? Функция. А в Python 2
print это была команда. То есть она писалась без круглосковок. Вот. То есть видите, уже есть обратная
совместимость, и код на Python 3 без некоторых учрених не запустится на Python 2. То есть когда мы
меняем мажорную версию, то зачастую мы ломаем обратную совместимость. Вот. Если у нас есть
минорная версия, меняется минорная версия, то мы меняем какую-то функциональность. Возможно,
добавляем новую функциональность, но при этом сохраняем обратную совместимость. То есть код,
который написан на Python 3.11.7, будет запускаться на версии Python 3.10.10. Точнее, наоборот, код,
который написан на версии Python 3.10.10, будет запускаться на Python 3.11.7. Вот. А вот эта вот
штука, она меня, если мы идем в патч-версию, это означает, что мы вносим небольшие правки,
которые по факту устраняют какие-то проблемы. То есть мы исправляем какие-то баги, не меняя
основной функциональности нашей системы. Так. Теперь смотрите. Представим себе в этом примере,
что у нас Python 3.10.10 решил внести новую функциональность, и у нас по факту меняется
сигнатура некоторых функций. То есть мы не правим баги, меняется сигнатура некоторых функций. Как вы
думаете, какая следующая версия за ней будет? Есть мысли? Обратная совместимость сохраняется.
3.11.0. То есть новая версия у нас стирает новый, старый указатель. То есть когда мы переходим
в версии 3.10.10, то мы переходим на версию 3.11.0. Если мы не меняем обратную совместимость,
если мы сохраняем обратную совместимость, но при этом у нас какой-то patch fix, то мы идем в
версию 3.10.11. Вот. А если мы меняем мажорную версию, то тогда мы переходим в 4.0.0. Версия
Python 4.0.0. Ну, наверное, это произойдет тогда, когда в Python ведут типизацию. Причем какой-нибудь
строгой типизацию. А об этом разговоры ведутся. Но, как ни странно, какие-то вот фундаментальные
версии продуктов, если мы с вами говорим, они зачастую не получают так или иначе четвертую
версию. Как-то сложилось. Вы, наверное, знаете, есть такая игра Half-Life. Слышали? Все ожидают
там третью версию Half-Life, а ее все еще нет. Вот так же и здесь. В Python 3 до сих пор, наверное,
четвертую версию Python не дождутся. Если мы с вами говорим про такой инструмент, который мы будем
с вами разбирать под названием CMake. Это система сборки для проектов на C++. Там тоже нет четвертой
версии. Там 3.28. Что-то. Какие из проектов еще? Есть оболочка для рабочего стола GNOME. Там,
как ни странно, тоже четвертой версии не дождались. И решили сделать следующую. Поскольку у нас
ядро системы достаточно сильно устоялось, то мы меняем нумерацию нашей версии и просто отбрасываем
то, что у нас происходит в мажорной версии. То есть в какой-то момент времени может случиться такое,
что с библиотекой у вас была версия, допустим, 3.12.1, 3.13.2, 3.14. И так далее. Потом понимаем,
что проект устоялся. Мы откидываем эту мажорную версию. У нас версия GNOME теперь 14, 15, 16, 17,
18, 19, 20 и так далее. То есть такое тоже вполне может быть. И это касается, допустим, джавы.
Языка программирования джавы, в которой мы говорим, что у нас существует обратная совместимость
полностью. И это там гарантируется самим языком программирования. Поэтому до версии,
допустим, 1.7 была версия 1.8, а дальше отбросили единичку и начали называть версии джавы,
9, 10, 11 и так далее. В каких-то продуктах, если мы говорим про версионность цикла, то они
нумируются именно даты выпуска. Давайте попробуем привести примеры того, какие продукты
нумируются именно версии выпуска. C++ мы про стандарт больше говорим. Да, стандарт C++ нумируется
годом. Еще? Да, Windows сейчас, если посмотреть версии сборки, там 22х, 22х. Я честно забываю,
по-моему, 22х и что-то там. Еще? Вы не поверите, я буду вангой, если я скажу, что через два месяца
выйдет Ubuntu 24.04. Давайте подумаем. 24-й год, апрель. То есть новая версия Ubuntu выходит раз
в полгода. Вот. То есть тоже есть такие нумерации. Так вот, ладно. Это у нас был разговор вообще про
баторный адаптер, но мы вышли на версионирование нашего продукта. Тоже крайне полезная вещь для
прежней разработки, чтобы вы понимали, каким образом вы можете нумировать ваши версии продукта.
Если у вас есть проект какой-то, то у вас получится интересная нумерация, скорее всего. Версии до
первой, в semantic versioning есть важная особенность, что версии до первой обычно меняют только
минорную версию, мажорную не меняют. То есть у вас получится так, что по факту в итерациях
проекта вашего у вас будет версия 0.1, 0.2, 0.3 и, собственно, к концу семестра у вас появится версия
1.0. Да. То есть вы можете прямо использовать версионирование. Причем, если мы говорим про
версионирование, на семинарах гид все прошли? Вот. Мы можем эти версии привязывать при помощи
именованных коммитов. То есть эти коммиты называются теги. То есть вместо команды
git-commit, которая двигает ветку, вы можете указать команду git-tech и у вас появится указатель на
commit. Допустим, вы можете сказать git-tech там, не знаю, 3.10.10. И у вас появится commit с версией
3.10.10. Тогда другие разработчики легко могут понять, что вот вам нужно перейти на конкретную
эту версию, чтобы ее, допустим, скачать, склонировать, собрать и так далее. Так, это понятно. Хорошо,
мы тут заговорились про адаптер. Давайте теперь я покажу, собственно, каким образом
реализовывается адаптер. Собственно, цель адаптера будет состоять в том, чтобы отвязаться от прямой
зависимости через как раз механизм dependency inversion. То есть нам нужно, допустим, принять
какой-то файл. Представьте, мы принимаем какой-то архивный файл. Он в формате zip. А нам
нужно, допустим, не знаю, прислать картинку. Тогда что мы можем под капотом сделать? Мы можем с вами
разархивировать эту картинку, разархивировать архив и вытащить из него картинку. Это будет
делаться под капотом. Собственно, теперь давайте я нарисую диаграмму, которая позволит это нам
сделать. Значит, смотрите, представим себе, что у нас есть A. Это определенный клиент.
И он хочет использовать некоторую функцию B. Так, это у нас класс A. И вот у нас есть код функции,
которую мы хотим вызвать. Тогда мы делаем следующее. Мы говорим, окей, давайте мы здесь создадим этот
метод под названием adapter. Здесь у нас будет, давайте назовем его service method. А у адаптера будет
сам метод. Это у нас будет интерфейс. Адаптер-интерфейс. Вот. И у него, напомню, что у интерфейсов у нас
есть только методы. И они являются публичными. Тогда наш адаптер, который будет сделать, он будет
делать следующее. У него будет своя собственная реализация метода, которая будет вызывать этот
метод. То есть класс A будет хранить в себе реализацию вот этого интерфейса. То есть ссылку на вот этот
объект, на экземпляр этого интерфейса. Тогда смотрите, в чем удобство. Представьте себе,
что у нас была версия продукта, там не знаю, B, была версия там 3.4, а мы переходим на версию
продукта V4.0. То есть смотрите, у нас вместо B появляется B'. Что нам нужно сделать с этой
картинкой, чтобы все работало? Да, смотрите, нам нужно будет переписать только адаптер. И адаптер
можно будет легко заменить. Допустим, это будет плюс, допустим, метод V4, если у нас не сохраняется
обратная совместимость. А внутри, на самом деле, тут мы можем делать все что угодно. Допустим,
мы можем даже взять вот этот вот метод, который у нас есть, там вызвать его, а дальше сконвертировать
результаты в четвертую версию. Все, то есть смотрите, чем это удобно? Мы хотим использовать
какой-нибудь внешний интерфейс, внешние функции, и мы можем с вами их как раз вполне легко использовать.
Вот, давайте подумаем, в чем плюс и минус этих подходов. Да, если что-то менять, то нам нужно
менять именно в одном месте. Да, минус и плодим кучу классов. Ну, здесь мы говорим следующее,
что мы, в принципе, работаем в парадигме ООП, и наша цель именно качество нашего продукта,
именно, так сказать, выполнение нашего кода в визуальной архитектуре, чтобы это все было и успешно
работало. То есть большое количество классов, в принципе, не проблема, если мы эти классы грамотно
организуем. И здесь есть, опять же, практики написания кода, которые заключаются в следующем,
чтобы визуально видеть наш проект, недостаточно его писать в одном файле. А, допустим, у вас есть
какой-то класс, вы берете, допустим, и создаете, образно говоря, следующее. Вы делаете следующую
вещь. Вот у вас есть, допустим, какой-нибудь класс, типа, бейс-класс, ну и, допустим, у него там
наследники, какие там, сквер, триангл, серкал и так далее. Ну, понятно, что это нарушает принцип
замены баррелизков, но что мы с вами можем сделать? Мы с вами можем сделать следующее, что вместо того,
чтобы эти классы написать в одном файле, написать для него каждый файл, допустим, точка cpp. А вот это
вот все вынести в директорию под названием shapes. То есть у нас получается вот такая структура пакетов,
с которой мы с вами легко можем работать. Да, поэтому, если вы будете оформлять свои проекты,
то, пожалуйста, делайте вот таким образом. Если мы говорим про cpp-шные проекты, то там
бывает еще одно разделение, что у нас в папке src хранятся cpp-шные файлы, а папке include у нас
хранится хедера. То есть это прям можно разводить, и не бойтесь о том, что проект у вас не скомпилируется,
допустим, для этого как раз есть системы сборки, которые будут подсказывать, где ваша директория,
где ваш файл находится. Как раз один из следующих семинаров будет посвящен как раз Semeiko. Так,
давайте я остановлюсь и спрошу, есть ли у вас вопросы по этой вещи. Да, вопросы крайне желательно
задавать. Да, про все что угодно на самом деле, любые обертки. Собственно, иногда это называют еще
в рапперам, но здесь именно мы говорим про то, что он называется, паттерн называется адаптер.
Смотрите, значит, почему здесь интерфейс. Мы, смотрите, отвязываемся от конкретной
реализации, то есть как бы наша суть будет состоять в том, что у нас метод, который здесь есть,
он просто должен вызвать какой-то, так сказать, как бы сказать, а почему мы именно напрямую не
вызываем их. Смотрите, это будет связано с кодом, который будет написан. Давайте попробуем написать
код. У вас просто может быть такое, что оно даже не скомпилируется, то есть у нас что получается,
допустим, мы создаем с вами аинтерфейс. Что у нас получается? Аинтерфейс, как называть,
давайте AD назовем его. Да, тут я пишу вот так вот. U-адаптер, то есть здесь именно особенности
op играют. Допустим, a.ad, ad. Опять же, тут нужно сеттеры. Ну и дальше мы вызываем a.metod. То есть на
этапе компиляции у нас это будет работать. А теперь представьте себе, что, допустим, у нас,
когда есть интерфейс, мы можем, допустим, поверх него поставить какой-нибудь абстрактный класс и
сделать свое собственное дерево наследования. И тогда нам это позволит сделать. Мы просто должны
заменить дочерний класс. Более того, мы можем, допустим, типизацию сделать. В зависимости от того,
какой аргумент нам принимается, мы, собственно, переопределяем этот дочерний класс. То есть по
факту, что у нас происходит? Когда нам нужно перейти на новый класс, нам нужно поменять здесь в
одном месте вызов этого кода. Либо, допустим, сказать, что нам нужно провести какое-нибудь
тестирование, проверить быстродействия разных версий API, программируем интерфейс. То есть вот
эта версия и вот эта версия. Мы меняем здесь вызов кода и по факту мы скрываем все детали
реализации, которые у нас происходят под капотом. То есть минимальные изменения кода – это как раз
главное свойство, про которое мы с вами должны говорить. Это свойство называется поддерживаемость
продукта. То есть чем более поддерживаемый продукт, тем просто нам с ним приятнее работать. Так, я
ответил на вопрос? Хорошо. Так. Адаптер, да. Адаптер – это структурный паттерн. Так, хорошо.
Значит, мы с вами рассмотрели пример dependency version. И давайте рассмотрим первый антипаттерн,
который есть с нарушением этой структуры. Значит, смотрите, что мы с вами поняли. Мы с
вами поняли в солиде, мы закрыли с вами букву D, мы с вами закрыли букву O. Какие буквы мы с
вами еще не закрыли? Мы не закрыли с вами буквы S, L и I. Значит, про interface segregation мы с вами по
факту показали тоже примеры использования его. Ну и про солид немного тоже поговорили. Теперь
осталось поговорить про S. И здесь получается так, что вместо того, чтобы привести паттерн,
мы будем с вами приводить антипаттерн, то есть того, как не надо делать. И этот паттерн,
если мы говорим русифицированно, это божественный объект. В англоязычной литературе это GodObject.
То есть у нас есть класс, который пытается максимально сильно вобрать в себя всю
функциональность. Вот. Как идентифицировать такие классы? Значит, первый класс, который здесь есть,
это если у вас класс называется системы, наверное, что-то с вашей системой не так. Почему? Потому что
в систему можно впихнуть все что угодно. И это превращается в GodObject. Потом мы с вами еще
приводили пример под названием... Так. Какой еще у нас был пример? Университет, допустим. То есть
это все объемлющие объекты из нашей предметной области. То есть такие лучше исчленять. Вот.
И еще есть один паттерн, который, в принципе, практически иногда называют антипаттерном. Это
паттерн-одиночка. Сингл тон называется. На семинарах прямо посмотрите его реализацию. Суть этого
паттерна состоит в следующем. Чтобы хранить объект всегда в единственном экземпляре. То есть цель
состоит в том, чтобы создать объект таким образом, чтобы он у вас хранился в одном экземпляре.
Да, нельзя было создать еще один объект того же типа. А, вам на плюсах говорили про сингл?
А, вам даже реализацию на плюсах показали? Хорошо. Ничего себе. Обалдеть. Вот. И, значит,
есть такая тенденция. Вот у вас система 1, университет 1. Поэтому, если вы неправильно
реализуете сингл тон, то он легко может превратиться в got object. Вот. Про это тоже
нужно понимать. Опять же, давайте я тогда перечислю все паттерны. Еще один паттерн,
который может быть стать тоже got object. Это паттерн под названием фасад. Собственно,
это то, каким образом работают так называемые программируемые интерфейсы. API, application
programming interface. Вот пример. Классически. Заходите вы на строительство Яндекса. Ну,
на любого сайта. Ну, давайте говорим Яру. И дальше у вас в вашем сайте летит огромное
количество всяких загружается частей страниц. На самом деле у вас там загружается сервис погоды,
сервис почты, сервис поиска и так далее. Это все делается параллельно, но это делается через
одну общую точку. Зачастую. Это именно через API. То есть у вас скорее всего, когда вы посмотрите
на сайт, у вас там будет slash API slash что-то там. Вот. То есть у вас все запросы летят сначала в одно
место. А дальше вы эти запросы распределяете по другим тоже так называемым фасадам. То есть у вас
по факту... Вот классический пример, чтобы вы понимали. Вот вы заходите в какой-нибудь фистех,
образно говоря. Вот. Представьте только, что фистех был бы не вот такой вот, этот, не открытым
университетом, а собственно вы проходили бы все через одну точку. Через один пропускной пункт. Вот.
Вы заходите в один пропускной пункт, а дальше проходите по разным корпусам. Собственно у вас
получается фасад. Это общая точка, в которой вы ходите. А дальше внутри фасада могут быть разные
подфасада на каждую из компонент. Вот. И как раз тем самым вы можете, допустим, у вас API, допустим,
slash потом music, вы идете в Яндекс.Музыку. Там slash maps, вы идете в Яндекс.Карт. То есть ваш запрос
переадресуется. Понятно, что если вы не делаете этой переадресации, то у вас по факту будет именно
такой объект, типа, всеобъемлющий. И это не очень хорошо делать. То есть если мы делаем вот такие
обертки, то мы делаем их через фасад. Более того, тут есть еще один паттерн. Я не знаю, наверное,
мы про него чуть попозже поговорим. Который позволит, собственно, ограничивать доступ. Вот. Важно,
что? Вот. Почему это фасад? Фасад это что такое? Вот давайте попробуем форулировать. Что такое фасад?
Лицо здания. Вы можете зайти в прекрасное здание. Оно внешне кажется красивым. Заходите внутрь,
а там непонятно что. Вот. То есть мы как бы скрываем все, что находится под забором. Точнее,
за забором. Вот. То есть, опять же, СРП мы с вами тоже разобрали. Да. Так и надо делать. Это нормально.
Как раз мы говорим с вами про кохиженный каплинг. Так, хорошо. Я не знаю, как дальше мы поступать
с вами будем. Потому что следующий блок, который я планировал рассказать, это блок про UML, про Unified
Modeling Language. Но там именно надо смотреть на диаграммы в большом количестве. Поскольку у нас презентации
нет, то, к сожалению, наверное, мы этот пункт с вами пропустим. Я надеюсь, в следующий раз мы с вами его
разберем. То есть тут как именно выделять классы, какие диаграммы есть и так далее. Но я думаю, будет
более целесообразно рассказать про это, когда вы просмотрите идеи ваших проектов. Вот. И дальше мы
это применим. Поэтому давайте я с вами сегодня обслуживаю еще один аспект. Мы с вами начнем
говорить про методологию разработки программного обеспечения. Это то, каким образом мы с вами будем
разрабатывать проект. То есть это не про то, что мы сели, начали писать код и ничего не думали. А это
про координацию процессов, которые у нас есть в наших металлогиях разработки. Что включает
в себя методологии разработки ПО? Это подход к организации работы. И здесь нам нужно сказать,
из каких стадий состоит методология разработки ПО? Вообще, из каких стадий состоит разработка
проекта? Любого. Первая стадия — это проектирование. Собственно, первую часть,
которую мы с вами занимались на курсе — это про проектирование нашей системы. То есть на
этой стадии нам нужно будет выработать архитектуру нашего проекта, оценить риски, то есть каким
образом, что у нас может пойти не так и какие ресурсы нам нужны. Второе — это разработка.
Это, собственно, мы с вами код пишем. Третье — это тестирование. То есть мы с
вами пытаемся максимально четко поддержать именно тестирование этого кода. То есть,
как ни странно, не поверите, вот первую часть мы с вами уже разбирали. Про третью мы будем
детально говорить про тестирование с вами и на лекциях, и на семинарах. Четвертое — это внедрение.
И отчасти мы эту тему тоже затронем ближе к техническим заданиям в конце. И пятая вещь,
про которую мы с вами, может быть, тоже чуть-чуть затронем — это сопровождение.
Вот. Про разработку, про качественную разработку мы больше будем говорить с вами в концепциях
инструментов, которые мы можем использовать для разработки, и касательно вот паттернов
проектирования, которые нам позволят минимально сократить наш код, минимально сократить изменение
нашего кода. Вот. Давайте теперь построим по временной шкале и поймем, если у нас есть какая-то
итерация нашего цикла, то, собственно, каким образом осуществляется распределение этих стадий по
проекту. Значит, они идут подряд, но, как вы думаете, они как бы идут независимо друг друга,
или совместно? Конечно, совместно. То есть, смотрите, изначально мы большую часть времени тратим на
планирование, то есть это же так один, на проектирование. Дальше мы переходим постепенно
к разработке. Два. Третье — тестируем. То есть, видите, у нас даже некоторые части могут пересекаться
между собой. Четыре. И, допустим, пятое. То есть, видите, у нас получаются такие холмы типа колоколов,
и вот у нас получается вот таким образом идет наш проект. Преимущественно. А зависит от проекта,
то есть, возможно, что вам проект это какой-нибудь... Смотрите, значит, тут
бывают разные типы проектов. Опять же, если мы говорим про около научную среду,
либо про среду производства. Если мы говорим про научную среду, то в ней выделяем следующие
части. Значит, первое — это научные исследования, они называются NE. И как раз, значит, я тут немного
скажу, что ближе к концу бакалавриата вы будете этим заниматься. Вам же надо диплом защищать. Вот.
Вот вы будете заниматься научным исследованием. Дальше, значит, стадия... И тогда у нас на стадии
сопровождения уходит очень мало времени. Нам нужно просто показать стенд, представить его и сказать,
вот, смотрите. Типа, мы провели работу, написали вот такие-то отчеты. Собственно,
люди могут воспользоваться результатами этого отчета, и тогда оно никуда не внедряется,
практически. Вторая стадия — это не окр. Значит, если мы говорим про иностранную литературу,
то, как ни странно, не окр расшифров... Это у нас, давайте расскажу. Научные исследования и опытно
конструкторские работы. Вот. А то в иностранной литературе, в иностранных вещах это называют
модным словом R&D. Research and development. Собственно, здесь у нас идет research. Здесь у нас идет не
окр. И дальше у нас, собственно, промышленная разработка, промышленный проект, который мы с
вами внедряем. То есть обычное ПО. Вот. И как раз в стадии не окр понятно, что у нас идет внедрение,
и, собственно, продукт тоже в какой-то степени поддерживается. Но опять же, аккуратнее с поддержкой,
потому что у нас, если мы просмотрим про какую-то стандартную версию ПО, то вот, допустим,
там у нас осталось на этой доске убунта? О, осталось. Значит, здесь вот эта вот версия убунта,
она будет иметь статус LTS. Long term support. То есть цикл с долгой поддержкой. Это означает,
что обновление на эту операционную систему, то есть сопровождение, будет идти в течение пяти лет.
То есть все баги, все проблемы безопасности будут поддерживаться в течение пяти лет.
В отличие от версии убунта 2310, которая не имеет статус LTS и у нее время поддержки два года.
То есть в зависимости от версии у нас может быть разная продолжительность цикла поддержки
нашего продукта сопровождения. Да, все то же самое. Нет, ну понятно, что каждый продукт обеспечивает
свой цикл поддержки. Более того, этот цикл поддержки может быть спокойно продлен. Вот если мы говорим
про тот же самый Python 2, они прекратили поддержку всего этого в 2020 году, хотя изначально они
целили, что они закрывают поддержку в 2018 году. Просто переход на новую версию, он бы затратил
намного больше проблем, чем вот имеется сейчас. То есть если бы все резко перешли на Python 3,
то это бы ничего не мешало. Более того, бывают такие кейсы, что разработчики специально внедряют
такую фишку, что пожалуйста не используйте этот способ, он больше устарел. Типа он пишет,
что этот метод deprecated, пожалуйста перейдите на новую версию. И был такой веселый момент,
значит есть такой пакетный менеджер, он называется Poetry. Возможно кто-то сталкивался с ним, это
пакетный менеджер, который работает параллельно pip в Python. И в общем у них была одна функция,
которая считалась явно deprecated, и чтобы люди перестали этой пункции пользоваться, они сделали
хитрую вещь. Они с вероятностью 5 процентов сделали следующее, что вы запускаете сборку,
вы запускаете установку зависимости, у вас вероятности 5 процентов это не проходит.
Ну чтобы было не явно, типа ладно перезапустим, сработает.
Ну да, потому что эта функция была устаревшая, переходить на новую.
Да, я говорю, что это стандартный этот, стандартный воркфлоу, стандартный рабочий процесс,
конечно же он может идти не так. И как раз вы упоминаете про методологию, ну вообще про
концепцию Test Dream and Development, когда сначала пишется тест, а потом пишется код. Более того,
вы на самом деле затронули интересную методологию, мы будем ее рассматривать,
это методология под названием V-модель, в которой выход теста, который написан на каждой стадии,
является предварением стадии разработки. Хорошо, так, вот значит это стадия методологии,
произвольная методология разработки, которая у нас могут быть. Так, это понятно? Хорошо,
давайте поймем, что же влияет на выбор методологии, что может влиять, давайте ваши мысли.
Да, спецификация проекта, еще, ну бюджет, да, строки, да. Для кого мы пишем, кстати? Еще.
Да, какого качества и какие сертификаты у нас качества должны быть, потому что проект обычно
должен быть сертифицирован, продукт. Масштаб проекта, да. Знаете, вы еще, наверное, не сталкивались,
но в текущих реалиях есть такая особенность, вы читаете любой продукт и вот про стадию внедрения
в производство. Значит, давайте опрос, у кого какая операционная система, вот именно операционные
системы. Ну, называйте. Windows и Arch Linux. Windows, Arch Linux, так, еще. Windows, Mac OS, да. Windows Ubuntu, хорошо.
Arch Gintu, хорошо. Так, у меня Mac Linux Mint, допустим, Windows есть. Так, а теперь вопрос,
кто это назвал следующие операционные системы? RedOS, Alt Linux. У кого Alt Linux стоит?
Или, допустим, дай еще похлеще, Astro Linux. А вот вы сейчас читаете какие-нибудь внедрения
в крупных компаниях, в наших, и говорят, вам нужно внедрять ваш продукт под Astro Linux. Вот
что делаете, то и делаете. Как хотите, так и выкручиваетесь. Вот, типа местная отечественная
разработка. Вот, и приходится выяснять, а как же работает это Astro Linux и лицензию на нее купить
ну, далеко не везде можно. Я, по крайней мере, не сталкивался с онлайн-дистрибьюторами их, но вот
как бы в крупных компаниях в нашей территории, да, которые именно больше в государственном
корпоративном секторе работают, вот там именно внедрение. А если, конечно, вы пойдете в какой-нибудь
зеленый банк, то там тоже есть своя собственная операционная система работать. Вот, то есть,
на самом деле, выбор металлогии может влиять много. В-первых, особенности этого проекта. Количество
людей в проекте тоже сильно зависит. То есть, у нас могут быть сроки, бюджет, вариант поставки,
вариант внедрения и качество этого всего. Дополнительно у нас может быть особенность команды. То
есть, команда, из каких специалистов собрана, грубо говоря, это, возможно, какой-то стартап,
которому нужно быстро-быстро показать какой-то прототип, а может быть еще и особенность
заказчика. То есть, есть человек, ну или, грубо говоря, компания, которая заинтересована в этом
проекте и это, собственно, заказчик. И он тоже может внедрять какие-то дополнительные требования.
Допустим, может быть такая вещь, что, грубо говоря, практически каждая строчка кода должна быть
задокументирована. И с таким тоже можно сталкиваться. Или вам, допустим, нужно предоставить
документацию к проекте вот в таком-то формате файлов. Поэтому про документацию тоже важно
следовать. Значит, теперь давайте поймем. Это что касается именно выбора методологии. Если мы с
вами говорим про внешние факторы, то какие внешние факторы могут повлиять на нашу методологию?
Вот давайте начнем с следующей вещи. Это так называемые форс-мажорные обстоятельства. То есть,
что может относиться к форс-мажорным обстоятельствам? Значит, обычно они прописываются в договоре,
который вы заключаете. То есть, у вас есть договор и в связи с форс-мажорными обстоятельствами
мы можем с вами приостановить работу над нашим проектом. Ну, собственно, или поменять что-то. Вот
давайте подумаем, какие форс-мажорные обстоятельства могут случиться. Это не форс-мажор. Обычно это
нарушение договоренности заказчиком называется. Да, заказчик обанкротился. Да, интернет упал.
Да, вполне возможно, как бы это печально не было. Серв разгорел, но не по нашей причине. Громко
говоря, электричество долбануло вне, конечно же, мы за это не отвечаем. Но для этого нужно предусмотреть
внешние бэкапы данных, чтобы понятно, чтобы данные у нас не утерялись. Еще. Ну, опять же,
давайте наводнение, собственно, там что, цунами, ураганы и так далее. Это тоже обычные
форс-мажорные обстоятельства. Ну, и дополнительные форс-мажорные обстоятельства тоже могут быть
прописаны. Соответственно, если у вас случается форс-мажорное обстоятельство, то понятно,
что продолжительство проекта может быть увеличенным. Значит, сразу говорю, что такое проект. Вот это важно.
А проект – это некоторое мероприятие по созданию нового продукта. И вот смотрите, важная особенность,
что у проекта всегда есть срок начала и срок его конца. То есть, я обращу внимание, что у него
есть срок конца. Это не ремонт, который, как известно, нельзя закончить, его можно только
приостановить. То есть, обычно говорят сроки окончания проекта. Опять же, эти сроки могут
сдвигаться, но желательно так не делать. Более того, некоторые методологии, которые мы с вами
будем рассматривать, вы можете заключать контракт таким образом, что типа сроки проекта могут
быть даже пересмотрены не в дальнюю сторону на увеличение, но и на уменьшение сроков. Ну понятно,
тогда все будут довольны. Представьте себе, вы заказчику проекта даете на готовые продукты,
даете на три месяца раньше. Он, конечно, будет рад и, скорее всего, с вами заключит новый договор.
Так, дальше. Значит, внешние факторы – это государственные органы и распоряжение. Это
такой тонкий момент, с которым нужно все-таки считаться. Допустим, из таких распоряжений в
нашей стране – это закон о хранении персональных данных. Федеральный закон номер 152. Опять же,
если вы хотите пользоваться каким-то сервером или каким-то оборудованием, то желательно использовать
именно данные в связи с этим законом. Там есть четыре уровня защиты, которые подозревают общие
данные, персональные данные, персональные данные, которые касаются медицинских характеристик
этого человека. Поэтому, если мы говорим с вами про обычные данные, которые хранятся, то это хорошо.
Допустим, есть биомедицинские данные. Какие-то ваши антропараметрические характеристики, состав крови,
вот это вот все. Это должно находиться на другом уровне защиты. Или, допустим, у вас есть государственное
распоряжение, что у вас шифрование должно проходить по российским сертификатам, образно говоря. То есть,
вы защищаете свое соединение, защита вашего соединения должна проходить по специальному
протоколу. То есть, такое вполне тоже возможно. Вот. И если мы говорим про распоряжение, они могут
быть следующие. Они могут быть регламентирующие, то есть, описывают порядок того, что необходимо
делать. Они бывают запрещающими. То есть, вам запрещено, допустим, распространять данные. И если
вы какие-то данные отдаете, то они должны быть в обезличенном виде. То есть, вы выдаете данные,
и грубо говоря, к примеру, Вася Петров получил отл-10 за курс технологии программирования,
сдав задание вот это на два балла, вот это на три балла, там, грубо говоря, вот это на 100-500 баллов.
Это, собственно, строчка о том, как Вася Петров сдавал курс технологии программирования. Понятно,
что если мы даем данные, допустим, куда-нибудь, статистически, то понятно, что вот этого Вася
Петрова нужно исключить из этой таблицы. Просто вот, товарищи, вот статистика. Смотрите,
собственно, каким образом этот человек сдавал это все дело. И последнее, это сертификация. То есть,
это важно. И в нашей концепции, если мы говорим с вами про качество ПОО, то нам нужно соответствовать,
так сказать, сертификату, так сказать, стандарту о сертификации. Обычно, если мы говорим про
сертификацию, то это качество кода. Значит, здесь есть две спецификации, которые мы с вами будем
смотреть. Наверное, не сегодня. Я пока что закину удочку. Это два стандарта. Значит, это ИСО. ИСО
это Международный центр сертификации. И у него есть два стандарта по качеству программного
продукта. Вторая версия, это ИСО 9126. Она говорит о том, что, собственно, из каких компонент состоит
качество ПОО. И есть более новая версия стандарта, ИСО 2510, которая пришла на замену ИСО 9126.
Значит, в данной концепции 9126 было 6 составных характеристик, 6 частей. Здесь у нас получается
с вами 8 составных частей. То есть, некоторые две части, которые были здесь, они разделились и у нас
получилось всего 8 частей. Одно из них, про которое мы с вами поговорили, это поддерживаемость кода.
Это так называемое мейнтеннабилити. Там есть еще и другие. То есть, мы больше, когда мы говорим про
проектирование, наша цель именно говорить еще и про качество нашего кода, про его поддерживаемость.
Так, хорошо. Еще один внешний фактор, это действия конкурентов.
Собственно, давайте подумаем, какие действия конкурентов могут быть?
Ну, кибератаки, да, могут быть.
Переманивание конкурентов.
Ну, это, собственно, те же самые. Смотрите, значит, они бывают такие. Первое, это экономические.
Ну, то есть, это какие-то вещи. Допустим, представьте себе, что ваши конкуренты начинают скупать,
образно говоря, там не то что сотрудников, а покупать какие-нибудь объекты недвижимости.
Либо закупают огромное количество серверов. Понятно, что у них теперь вычислительных
мощностей становится намного больше. Второе, действия конкурентов, это управленческие.
И вот сейчас, как раз, если мы говорим про управленческие проекты, то бывают такие скандалы.
Я не знаю, слышали про такую компанию OpenAI? Да, и вот как раз там недавно был управленческий
скандал, когда глава компании SEO Altman сказали, типа, ты молодец, ты, конечно, сделал чат ГПТ,
но ты делаешь его коммерческим. Пожалуйста, идите вот, делайте свои коммерческие проекты.
Ну, в итоге это выросло в достаточно крупный скандал и вернули, собственно, его на роль SEO,
это Chief Executive Officer. То есть, в нашем русском языке, я бы так сказал, это перевод генеральный директор
компании. Вот, его вернули, собственно, был скандал, ну, благо, оно не повлияло на репутацию. А
управленческие действия, они влияют на конкуренцию, допустим. Либо, экономически, образно говоря,
действия конкурентов, это, допустим, ваш конкурент начал выделять финансы на, вот, на неокр,
так сказать, на раздел R&D, то есть, на исследование, для того, чтобы, допустим, улучшить новые продукты.
Как говорится, на хайпе, там, ввести поддержку искусственного интеллекта в ваши продукты.
Этим сейчас, кстати, большое количество компаний занимается. И есть содержательные действия
конкурентов, то есть, это то, что они внедряют именно в свой собственный продукт. То есть,
у вас появилась какая-то новая функциональность в продукте, и сразу что делают остальные конкуренты?
Да, сразу пытаются их внедрить к себе как можно быстрее, чтобы просто не потерять темп. Вот, то
есть, эти внешние факторы как раз могут влиять. И более того, есть очень важно, что, как ни странно,
экономические действия конкурентов могут влиять с этими, с теми государственными органами и распоряжениями,
которые у нас есть. Возможно, вы знаете, что если у вас есть какое-то разное количество компаний,
вот вы крупная компания, образно говоря, тот же самый зеленый банк, и вы хотите купить компанию
поменьше, образно говоря. Я не знаю, какие у нас есть эти сервисы доставки еды? Самокат, кстати,
по-моему, я не помню, самокат чей, по-моему, самокат, кстати, под часть Сбера. Да-да-да. Ну вот,
представьте себе, вы все делаете, а дальше зеленый банк хочет купить еще один систему доставки. Денег
много, почему бы не сделать? Так вот, есть такая замечательная служба, называется федеральная
антимонопольная служба. И, собственно, все крупные сделки, которые идут по слиянию поглощения,
проходят через федеральную антимонопольную службу для того, чтобы не было вот таких вот больших
конфликтов. Например, из таких классических примеров, вы знаете, что там, допустим,
в продуктовых магазинах пятерочек, образно говоря, либо шестерочек не может быть больше, чем 25% от
всех магазинов в городе. То есть, это именно регламентированно вот этим вот фактором,
что вы не можете покупать вот больше, чем такое количество магазинов.
Ну, понятно, что есть ограничения при определенном наличии. Ну, и странно,
если в городе у нас будет один продуктовый магазин.
Для этого открываем определение города. Город – это населенный пункт, по-моему,
населением не менее чем 12 тысяч человек, там имеющие вот такие вот свойства. Понятно,
что интересно, если у нас один продуктовый магазин на 12 тысяч человек. Ну, тогда по одному каждого.
Ну, это да. Ну, тогда, ну, это, всегда есть частники, которые могут открыть небольшой
магазинчик и начать торговать. О, рога и копыта, так сказать. Так. Да, да, да. Вот, допустим,
кстати, пример есть в городе на Долгопрудном. Далеко ходить не надо. Хорошо, давайте тогда,
если вот это понятно, мы начнем с вами разбирать методологи разработки, которые существуют.
Значит, давайте я буду их рисовать. Первая методология разработки, которая появилась
в самом начале, она называется водопадный или waterfall. Она подходит для очень маленьких проектов,
в которых вы знаете, когда у вас есть четкое начало, четкий конец и четкие графики,
и вы представляете прекрасно, что и как каждая часть этого проекта состоит. Давайте приведем
пример. Вам когда сдавать следующее задание по Мотону? Ну, ладно, короче, когда-то надо. Вы
понимаете, что вот у вас есть некоторый набор задач, которым надо решить. Более того, вам
рассказали, по какому алгоритму решать эти задачи? Не, в большей части. Ну, какие типичные
задачи? Ну, какие способы существуют для решения задач. Соответственно, у вас заранее есть четко
регламентированные строки, в которых вы можете это сделать. И тогда эти стадии располагаются
именно по водопаду. Проектирование, после этого разработка, после этого тестирование,
внедрение, поддержка. Вот, то есть видно водопад. Движемся сверху вниз. Давайте поймем, в чем
возникает проблема в водопадной модели. Ну, смотрите, давайте поймем, что если мы на стадии
тестирования внезапно поймем, что у нас что-то идет не так, то все заново. То есть у нас проект
останавливается, у нас возникают большие проблемы, и там нам надо будет платить либо неустойку,
либо договариваться с заказчиком о том, что что-то идет не так. В нашем случае это будет
преподаватель по мотану, который говорит, а можно, пожалуйста, нам дедлайн на неделю продлить. То есть
вот у нас типичная проблема, которая здесь возникает. Так, давайте я сейчас следующую вещь открою.
Значит, следующая методология, которая умеет это расширять, это, допустим, мы с вами можем понять,
что на стадии тестирования у нас что-то может пойти не так, и мы можем делать отвилку на стадию
проектирования. То есть, в принципе, делать некоторые откаты. В принципе, такое тоже возможно. Так,
давайте вопрос. Я пока, к сожалению, посмотрю, что у меня в презентации по этим штукам нарисовано,
потому что, к сожалению, в презентацию это уже, так сказать, я забегаю на следующую лекцию. Так,
есть ли вопросы по водопадной модели?
У нас как раз здесь возникает проблема долгостроев. То есть, если у нас какая-то
концепция пошла не так, то, к сожалению, дальше мы ничего сделать не можем.
Значит, теперь давайте как раз поговорим про следующую модель. А это как раз V-модель.
Смотрите, значит, здесь важно понять, каким образом вообще происходит проектирование продукта,
из каких стадий она состоит. Сейчас вы поймете, почему это V-модель. Значит, первая стадия – это
бизнес-анализ. То есть, вы смотрите на так называемые требования со стороны бизнеса. То есть,
что это означает? Это означает, что ваш продукт, допустим, должен… Вы нажимаете на кнопочку,
у вас производится какой-то заказ, дальше заказ через какое-то время доставляется, и все замечательно.
Клиент доволен, деньги к нему идут. Вот это как раз бизнес-требование, чтобы, грубо говоря,
ваш продукт позволял, так сказать, осуществлять онлайн-заказы. Дальше мы спускаемся на следующий
уровень – это системный анализ. То есть, вы анализируете уже требования чуть детальнее,
у вас возникают так называемые функциональные требования к системе и не функциональные
требования к системе. Функциональные требования к системе – это требования,
которые вы говорите, окей, значит, у вас система должна по нажатию кнопки выполнять
определенные действия. Раз, прописывайте, раз, два, три, четыре, пять. Или, допустим,
система должна работать в течение там девяносто девяти процентов времени. То есть, это уже не
функциональное требование. Или, допустим, у вас должен быть английский язык, поддержка английского
языка и локализация. Что еще может быть, это версия для слабовидящих. Особенно, когда вы
регламентируете вот такие вещи. То есть, если это как раз системный анализ, то есть, он не с точки
зрения бизнеса, он уже чуть ниже спускается. Дальше у нас мы спускаемся с вами на такую вещь,
про которую мы с вами уже говорили. Это архитектура. То есть, это то, как взаимодействуют
составные части вашего проекта. И самый более низкий уровень – это проектирование модулей.
Иногда это объединяется в стадии разработки. Мы видим с вами, что в этой модели по факту
проектирования разложено на несколько составных частей. А теперь мы с вами параллельно с этой штукой
говорим следующее. Прежде чем мы после выхода каждой стадии, мы с вами создаем требования для
верификации того, что вот у нас эти требования выполнены. И здесь возникает пирамида тестирования,
которые мы далее будем детали разбирать. Первое, что у нас возникает – это модульное тестирование.
Его еще иногда называют unit-тестирование. То есть, вы проверяете функциональность каждого
модуля, который у вас есть в системе. Дальше у нас возникает интеграционное тестирование.
Интеграционное. То есть, вы проверяете взаимодействие между несколькими компонентами в системе.
Дальше идет системное тестирование. То есть, вы тестируете систему. Вы, так сказать,
около вакуумных условиях. То есть, вы запускаете вашу систему в сферическом коне в вакууме и
проверяете, насколько хорошо она работает. И последняя часть – это приемочное тестирование.
Или, как говорят в жаргонном языке, это приемка. То есть, по факту вы говорите,
у нас запускало все на локальном компьютере, все замечательно, все зашибись. А теперь вам
надо это запустить как раз на той Astra Linux, которую мы с вами перечислили с ограниченными ресурсами.
Вперед. Или у вас вы писали код под убунтой, вам надо запустить это на Windows. Или там, допустим,
режим пиковой производительности. То есть, мы пишем в функциональных требованиях, что наша
система должна выдерживать нагрузку до 10 000 человек. Что делать, если 10 000 человек придет?
Ну, можно молиться. Что еще можно делать?
Да, нам нужен какой-то запас прочности. А теперь представьте, что мы систему разрабатываем без
этого запаса прочности. Да, все ляжет. Ну, собственно, примеры я уже много приводил,
когда система может лечь. Так вот, смотрите, в итоге получается так, что перед самой разработкой
мы с вами заранее определяем процедуру тестирования каждой из составных частей. И обычно внизу
разработка идет. То есть, что у нас получается? В этой картинке, если мы переставляем все это дело,
то у нас по факту... Смотрите, какие стадии между собой меняются здесь. Да, смотрите, первую очередь
у нас меняется между собой разработка и тестирование. И отчасти, на самом деле, стадия внедрения,
потому что тесты, в принципе, для внедрения у нас уже готовы. Мы делаем трюк и меняем их местами.
Значит, в каких местах это применяется? На самом деле, это применяется в тех местах, когда есть
строгая приемка. То есть, вам прямо жестко, на уровне того, что если у вас что-то не выполнится,
допустим, ракетостроение какое-нибудь, космическая отрасль, то понятно, к чему это может привести.
Это может привести к большим печальным последствиям. Примеры с компанией Boeing это показывает нам. То есть,
вы заранее должны прописать те процедуры, по которым вы будете тестировать ваши самолеты.
Это что касается именно V-модели. Значит, про вот эти виды тестирования мы с вами еще будем говорить.
Так, понятно это или нет. И последняя методология, которую мы сегодня с вами успеем рассмотреть,
это спиральная методология. Значит, она очень хорошо подходит на, как ни странно, ни стадии
проектирования. Она хорошо подходит, когда вы начинаете договариваться с кем-то о создании
проекта. То есть, прежде чем вы начинаете саму разработку. Потому что проект, как мы с вами сказали,
прежде чем начать проект, нам нужно оговориться о его сроках, о начале и его завершении.
То есть, там мы начинаем раскручивать спираль. Сейчас я вспомню, из каких блоков он состоит.
Господи. Так, здесь у нас стадия разработки. Здесь у нас риски. Здесь у нас это проектируется,
это у нас получается планирование. И это у нас с вами называется это определение задач,
которое нам нужно сделать. То есть, мы будем сейчас по спирали раскручивать эту всю концепцию. То есть,
начинается мы с вами определяем задачи, оцениваем риски, разрабатываем часть, планируем следующую
итерацию. У нас возникает вот такая вот спираль, которая внедряется дальше. Теперь смотрите,
как раз вот то, что у нас по водопадной модели идет, оно находится на вот этих стадиях. То есть,
здесь у нас как раз раз, два, три, четыре, пять. То есть, это основной аспект. Но при этом они
разделяются между собой. То есть, изначально, допустим, нам нужно определить сроки нашего
проекта. То есть, здесь мы создаем концепцию. То есть, как наш продукт геотически будет выглядеть.
Дальше вы разрабатываете такой, понятие как жизненный цикл. То есть, сколько ваш продукт проживет
и вообще он будет релевантным. Оцениваете риск и в конце первой стадии спирали вы получаете
некоторый прототип. Вот. Дальше вы тестируете этот прототип. То есть, идете разработку этого
прототипа. То есть, у вас получается разработка. Потом, собственно, у вас вот здесь вот получается
следующее. Вы по факту моделируете то, что у вас происходит. То есть, смотрите изначально, что у вас
есть. Вот, если вы разрабатываете какой-нибудь автомобиль, да, что вам проще... О, давайте поезд. Вот,
поезд это хороший пример. Вот, что вам нужно... Представьте себе, что у вас поехал поезд по
электричке. Да, он поехал, все замечательно. Вагон этого поезда. Что нам нужно сначала сделать? Нам
нужно сначала сделать маленький эскиз этого вагона. Да, посмотреть, как он выходит. Потом, значит,
сделать копию этого вагона шире. Представить его на выставке. То есть, расширить нашу модель. И
только потом, собственно, сделать этот вагон. И прогнать его на приемочных тестах. То есть,
проверить, грубо говоря, выдерживает ли он нагрузку, выдерживает ли он резкое торможение и
так далее. Но это можно сделать не с большим вагоном, а с маленьким прототипом вагона. Потому что,
если мы опустим большой вагон и случайно он не выдержит теста, то это катастрофически для людей.
И так вот, после каждой итерации этого цикла мы сужаем риски нашего проекта. То есть, у нас
сначала, если мы говорим, что 1х это скорость разработки нашего проекта, ну, ожидаемая,
то после первой итерации у вас скорость, типа, диапазон рамок окончания проекта будет
от 1 4х, ну, приблизительно, это статистические выводы, до 4х. Потом, после следующей итерации,
вы его сужаете. То есть, у вас получается, смотрите, нелинейная шкала здесь, а экспоненциальная. То есть,
допустим, вы указываете, понимаете, что здесь полу х на 2х. И тем самым вы после каждой стадии
прохождения спирали все-таки понимаете, сколько времени, в более уточненном варианте,
вас занимает разработка этого проекта. Так, понятен ли цикл? То есть, это именно
большая часть договоренностей, прототипов, выяснений вот этих всех сценариев. Так, хорошо,
значит, мы с вами сегодня немножко перестроились. Поговорили сегодня про семантическое
версионирование. Добили паттерны и антипаторны первые и начали говорить про методологию
разработки. Я надеюсь, в следующий раз с проектором будет лучше и мы с вами будем говорить про UML.
Спасибо.
