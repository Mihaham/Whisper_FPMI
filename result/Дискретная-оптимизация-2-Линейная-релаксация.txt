Мы можем с вами начать про дискретную оптимизацию говорить. По-моему, в прошлый раз мы с вами ничего
вообще не успели начать. Мы только поговорили про задачи, которые есть. Сказали, что они трудные,
что к ним нужны разные подходы. И мы с вами будем некоторые подходы в приложении к
некоторым из этих задач рассматривать. Сегодня мы начнем с задачи, с которой и Генрих начинает
на курсере. Начнем с задачи о рюкзаке. Мы задачу о рюкзаке посмотрим с точки зрения двух вещей.
Сегодня мы рюкзак посмотрим с точки зрения линейной релаксации. Такие страшные слова,
линейная релаксация. Но с другой стороны, слово релаксация не страшное. Это значит,
что делать ничего не надо. Релаксируйся и все. Так что мы с этой точки зрения посмотрим,
а потом чуть позже, когда мы будем рассматривать полностью полинамиальные приближающие схемы,
то мы еще раз вернемся к задаче о рюкзаке и посмотрим, что можно взять алгоритм динамического
программирования для рюкзака, там покруглять кое-что и у нас получится полинамиальный алгоритм,
но приближенный. В прошлый раз я, по-моему, уже сказал, что тот рюкзак, который мы с вами
рассматриваем с чистым динамическим программированием в курсе алгоритмов,
это получается алгоритм не в точности полинамиальный, а псевдополинамиальный.
Но об этом всем попозже. Сейчас мы с вами начнем с задачи о рюкзаке и линейной релаксации в
приложении «Задача о рюкзаке». Давайте я начну даже с еще более отдаленной вещи,
с линейного программирования. А вы знаете, что такое линейное программирование? Слушайте,
а как линейное программирование применяется в теормехе? Ничего себе, я думал, что теормех,
он про что-то нелинейное, про что-то сильно нелинейное. Я вообще, на самом деле, я чужой
среди своих и свой среди чужих, потому что я сам заканчивал в МК МГУ. У меня физики практически,
но она была, но такая рудиментарная достаточно. Я думаю, что если взять среднестатистическую
физтеху, то я знаю примерно одну десятую в физике того, что знает среднестатистический физтех,
но мне казалось, что в теормехе нет линейных практических вещей, а они, оказывается, есть.
Ну это же паспорт, правильно? А я как сотрудник же могу купить такую обложку? Нет, в каком-то
смысле я честный физтех, потому что я закончил ВМК, потом я аспирантуру закончил на ВМК,
потом я поработал на ВМК, а потом я ушел на физтех в 2012 году и так и не возвращался на ВМК.
Вот, так что вам все равно должно быть приятно, наверное. Так вот, линейное
программирование. Линейное программирование никакого отношения не имеет к написанию кода,
к software engineering. Линейное программирование – это задача линейной функции или максимизации
линейной функции. А вы знаете, что такое линейная функция? Это выражение, являющейся суммой
переменных, со какими-то константными коэффициентами. Ну вот давайте мы эти
константные коэффициенты обозначим c1, cn, переменные сами обозначим x, и вот необходимость
найти максимум или минимум такого выражения – это и есть задача линейного программирования.
Ну естественно, нужно как-то ограничить область, в которой эти переменные могут меняться,
и вот линейное программирование у нас только в том случае, если эта область задана тоже чисто
линейными ограничениями. У нас могут быть линейные ограничения типа равенства, то есть просто
системы линейных уравнений, но вот в той форме, которую мы будем с вами рассматривать,
у нас ограничения будут в форме неравенств. Вообще, можно записать произвольную систему
неравенств в виде неравенств вида меньше или равно. Вот мы так, наверное, и сделаем. Значит,
первое неравенство меньше или равно, значит, какой-то констант, да, линейная функция от
переменных меньше или равно какой-то константе и так далее. Ну, МТ неравенство АМНХН меньше или равно
какой-то константе БМ. Вот что такое задача линейного программирования. Давайте я чуть-чуть про
геометрию этой задачи скажу. Мы совсем практически не будем затрагивать способы решения вот таких
задач линейного программирования. Нам для нашего курса важно будет как можно скорее связать эту
задачу, которая вроде бы из такого, но из мотана какого-то там, мотан, линал, да, вот дискретной
оптимизации вроде не пахнет. Вот, но мы это очень быстро свяжем с задачами дискретной оптимизации.
Сейчас увидим как. Так вот, вот такая задачка, значит, как ее можно трактовать. Ну, например,
если бы это была задача от двух переменных, было бы у нас неравенство тогда А1,1 Х1 плюс А1,2 Х2 меньше
или равно B1. Вот такое неравенство. Как бы мы могли с вами его геометрически представить? Вот если
нарисовать такую дикартовую плоскость Х1 Х2, то, значит, как можно представить себе область
значений Х1 и Х2, которые удовлетворяют такому неравенству? Ну, это вроде полуплоскость, да,
такая. Вот. Да, значит, мы просто берем, значит, одну из полуплоскостей, на которой вот такая прямая
с равенством делит нашу плоскость. Значит, так что на самом деле такое неравенство, оно задает нам
полуплоскость. Если у нас система неравенства, то понятно, что мы пересекаем просто несколько
полуплоскостей, и у нас получается, ну, что-нибудь, например, какой-нибудь такой четырехугольник. В общем
случае у нас получается, если много переменных, у нас многомерное пространство, но все равно
получается не многоугольник, а многогранник. На самом деле многогранник получается, если это
ограниченная область, картинка же может быть и какой-нибудь такой. Мы хотим находиться ниже
вот такой прямой, например, левее вот такой прямой и левее вот такой прямой. Это не ограниченная область,
туда можно уходить сколько угодно далеко. Такие штуки называются политопы, но многогранник это
ограниченный политоп, по сути. Я не хочу, чтобы вы это запоминали вообще, то есть многогранники,
политопы. Просто я хочу на самом деле объяснить, что задачка линейного программирования, вот это,
она, поскольку у нее такая геометрическая интерпретация, очень хорошая, то она считается
достаточно простой в решении. Например, есть симплекс-метод для этой задачи, подназываемый,
который берет и ищет решение вот этой вот задачки не на всем вот этом бесконечном множестве
возможных вариантов, а только перебирая крайние точки вот этой вот области. Почему? Потому что
максимизация вот такой вот функции, ну давайте я опять-таки для двух переменных покажу, значит,
вот у нас есть система неравенств, а вот, допустим, мы максимизируем теперь функцию, ну скажем x1
плюс 2x2. Вот как нам максимизировать такую штуку? Это значит, нам нужно взять вектор коэффициентов
1 запятая 2, вот такой вот вектор, и максимально в направлении этого вектора двигаться, оставаясь
внутри вот этой области. То есть можно считать, что вот вектор коэффициентов, ведь сама эта
функция, это скалярное произведение вот такого вектора, на вектор x1 и x2. Значит, она тем больше,
чем дальше мы способны уйти вот в этом направлении. Вот, ну как бы если формально не очень понятно,
почему именно так, то не беда на самом деле тоже. Вот здесь про геометрию разговор. Вот представьте,
что это направление ветра, ну и в общем случае тоже вот вектор коэффициентов c1 и так далее,
cн это такое направление ветра. И вот куда ветер дует, там хорошо. И нам нужно подбросить перышко
внутрь вот этой области, и куда эта перышко улетит под действием ветра, значит там и самая
лучшая точка, там самый лучший набор x1, xn. Ну или можно считать, что гравитация в этом направлении
действует, и вот мы кидаем шарик такой, и куда он скатывается по действиям такой гравитации,
там и хорошо. Естественно, что можно так придумать вектор вот этой гравитации условно,
что нам будет хорошо прям на всем отрезке на таком, например. Ну понятно, если мы
перпендикулярно направим наш вектор коэффициентов c к этому отрезку, то будет хорошо много где. Но
всегда найдется какая-то крайняя точка, одна из угловых точек, в которой нам гарантировано будет
хорошо. И вот simplex-метод, про который мы ничего не будем с вами пока говорить, это алгоритм,
который как-то умудряется перебирать хорошо вот эти вот крайние точки, так что только из них мы
выбираем оптимальное решение. Да, я еще напоминаю, не напоминаю, наверное говорю, вот наверное эта
новость. Значит, что мы с вами будем рассматривать такую терминологию. В любой задачи оптимизации,
в том числе в дискретной оптимизации, и, пожалуй, особенно в дискретной оптимизации, у нас будет два
понятия с вами. У нас будет понятие feasible solution, допустимое решение, и optimal solution. То есть
оптимальное решение самое лучшее. Ну а почему так? Обычно, я думаю, что мы привыкли с вами часто,
что решением задачи называется все-таки нечто, что удовлетворяет всем всем всем требованиям. Вот
если нас просят найти максимальное значение вот такой вот штуки, да, это значит решить вот эту
задачу, это все-таки предъявить действительно наиболее оптимальный, значит, набор иксов. Но задачи
дискретной оптимизации настолько сложные, что часто найти оптимальное решение, это вообще без
шансов. И поэтому мы ищем решение, которое в первую очередь главное, чтобы оно хотя бы удовлетворяло всем
вот этим жестким ограничением. Но, как правило, уже из, значит, всех решений мы выбираем наиболее
близкое по возможности к оптимальному, но оптимальное мы не знаем почти никогда. И поэтому вот чтобы
не говорить, что у нас типа есть решение задачи, а мы какими-то нерешениями к нему подходим,
вместо этого мы говорим, у нас есть оптимальные решения задачи, которые мы не знаем, но хотим
к нему приблизиться. Ну мы строим какие-то, может, неоптимальные решения, но главное, что они
допустимые. Вот допустимость означает удовлетворение всех вот этих вот ограничений, ну какая бы ни
была здесь система линейных, нелинейных ограничений, просто всех жестких ограничений. Ну так вот,
значит, я забыл уже о чем я говорил в применении к этой штуке. Вот допустимое решение вот здесь,
вот это любая точка просто внутри вот этой вот области получается. Оптимальные решения можно
искать только среди вот этих вот угловых. Задача линейного программирования вот такая. Если
предполагается, что переменные это произвольные действительные числа, то есть кроме вот этих
линейных неравенств никаких ограничений больше нет, то тогда эта задача, можете быть уверены,
что она отлично решается и на практике, и в теории. На практике есть симплекс метод, есть алгоритмы
внутренней точки, которые хорошо работают в теории, есть просто алгоритмы внутренней точки,
которые хорошо работают. Вот нам с вами надо про эту задачу знать вот что. Что вот эта вот задача,
вот эта вот задача, она решается за полинамиальное время, решается за полинамиальное время.
Но я думаю, что у вас было уже определение NP, значит у вас было определение P, и вы понимаете,
что вот есть такое важное деление в computer science между полинамиальным временем и
неполинамиальным временем. И вот задачи такие эффективно разрешимые, считаются это те,
которые за полинамиальное время можно найти оптимальные именно решения. Решается за
полинамиальное время на любых входных данных, причем ответом задачи оптимизации вообще может
быть один из трех. Какие три ответа? Бывают задачки вот такие хорошие, в которых область не пустая,
вот всем этим ограничениям можно одновременно удовлетворить, получается какая действительно
хорошая область, и мы в ней можем найти действительно некое конечное максимальное значение
какой-то функции. Такие задачи называются ограниченными и разрешимыми.
Easeable и bounded, то есть можно удовлетворить системе ограничений, и значит оптимальное значение
функции ограничено, это какая-то все-таки константа, какое-то конкретное число. Бывают задачки,
в которых, вот как там я приводил пример, область бесконечная, и внутри этой области можно
бесконечно далеко уходить в направлении ветра, который дует сообразно нашим коэффициентом c1cn,
и тогда задача называется feasible unbounded, ну или по-русски не ограниченная. Вот, область задачей
feasible. Это задачки, в которых, например, нам бы сказали, ну я думаю, что вы понимаете, да, вот что
какая-нибудь такая задача, вот с такими вот требованиями, она вообще здесь нету ни одного,
ни одной комбинации иксов, который удовлетворил бы всем ограничениям одновременно, ну вот, и здесь
что-то такое получается не очень. Хотя нет, в этой задачке, наверное, да, вот все истребки бы
смотрели в разные стороны, да, вот тогда, наверное, было бы плохо точно. Ну ладно, на самом деле,
те задачки, которые мы с вами линейного программирования будем рассматривать, исходя из
практических задач, они все будут feasible и bounded. То есть вот мы всегда будем оставаться более-менее
здесь, а это просто полезно знать как терминологию, ну потому что если вы будете, например, запускать
какие-то сторонние solvers или как-то экспериментировать со своими ограничениями, то запросто можно вляпаться
в какую-нибудь infeasible задачку. Вот мы с вами позже поговорим про введение дополнительных ограничений,
вот такие всякие трюки для ускорения поиска решений, и вот в ходе экспериментов просто solver
вам что-то такое может выдать, чтобы мы знали термин. Так, ну вот, помимо того, что эта задача
решается в теории за полимеральное время, она на практике тоже очень эффективна. А что я
подразумеваю под очень эффективным решением на практике? Это означает, что вот такую вот задачку,
ну solver современный решает на обычном компьютере для нескольких десятков тысяч ограничений и
нескольких сотен переменных решает на секунд за 10-15. То есть, ну это нормально, вот это как
много чего можно понарешать, да, когда у вас так быстро все работает. То есть на практике я скажу
так, ну порядка 10 в третий, 10 в третий по порядку, 10 в четвертый неравенств, ограничений, и тоже
порядка там 10 во второй, 10 в третьей переменных, у нас время обчета, ну как правило меньше одной минуты.
Нас это вполне вполне устраивает. Теперь, дальше, это хорошие новости. Плохие новости
состоят вот в чем, в том, что если мы с вами оставляем вот все те же самые требования,
решаем ту же самую задачу, только вместо действительных переменных мы рассматриваем
только целочисленные значения переменных, то тогда здесь все плохо и эта задача оказывается
NP трудной. Значит, вот такой вариант задачки линейного программирования называется целочисленное
линейное программирование. Есть задачки смешанного целочисленного линейного программирования,
когда часть переменных обязательно целая, а часть переменных произвольная, действительная.
Фактически, что происходит, если мы требуем целочисленность переменных, но это значит,
что мы внутри вот этой вот области ищем только точки с целочисленными координатами. Давайте
посмотрим, почему вообще задача может стать сложной. Сейчас еще чуть-чуть нам нужно потерпеть,
потому что мы совсем скоро с вами возьмем пару задач даже дискретной оптимизации и посмотрим,
как они ставятся на вот таком языке. Сейчас я еще чуть-чуть поболтаю насчет вот этого всего.
Значит, почему, казалось бы, такая замена, вот все оставили, только вместо R написали Z? Почему
эта замена превращает такую естественную легкую задачу в очень трудную? А дело в том,
что очень сложно предугадать по форме нашей области, какие именно целочисленные точки даже
в нее попадут, просто элементарно. Вот представьте себе, значит, целочисленную задачу. Это значит,
мы вместо всех возможных точек плоскости рассматриваем только вот такую сетку,
точек с целочисленными координатами. Дальше представьте, что у нас какие-нибудь такие неравенства.
Сейчас я попробую это сделать. Ну, в общем, у меня примерно получилось. Представьте,
такой треугольничит. Давайте даже представим, что он промазывает мимо вот этой вот точки. Вот
какой-то он такой. Какая точка, если у нас вектор ветра дует вот в эту сторону, то есть мы,
например, максимизируем функцию минус x1, минус x2 или минимизируем функцию такую. Допустим,
что задача какая-то такая. Это значит, что мы должны сдвинуться максимально против ветра 1,
вот. Скорее всего, у нас в обычной задаче линейного программирования вот эта вот точка будет
оптимальна. Но в вот эту вот область, ближайшая точка, которая попадает вообще целочисленная,
она находится как далеко. То есть, например, не работает такая идея, очень естественная. Давайте
решим вот эту вот задачку, да, и потом просто округлим как-то значение переменных. Она не работает.
Ближайшая точка к вот этой целочисленной, это вот эта, ну или вот одна из этих. Вот эту точку никак
не назовешь округленной точкой, близкой к этой. И вот из-за такой ерунды теряется многое в
геометрии задачки, и задача становится очень трудной для решения. Такс, ну хорошо. Тем не менее,
вот этот водораздел, он очень эффективно используется нами, мы сейчас его прямо начнем
использовать в дискретной оптимизации. Почему? Потому что это очень уникальный, на самом деле,
случай такой, что есть некая очень широкая задача линейного программирования, и не менее
широкая задача по возможностям целочисленного программирования. Одна из которых очень легкая,
другая очень трудная, а отличаются они все-таки всего лишь одним условием, вот этим. И иногда,
ну вот в этом патологическом случае с округлением как-то вообще мне не катит, но иногда мы,
действительно, можем как-то округлить решение, это не всегда далеко, ну такой процесс естественного
округления к ближайшему целому, но мы можем что-то сделать с решением одной задачи, чтобы попытаться
получить решение другой задачи. Вот давайте мы это и научимся делать в паре задач дискретной оптимизации.
И давайте начнем с задачи о рюкзаке как раз. А знаете, вы знаете, почему название появилось? Может
не знаете? Линейное программирование. Как же это связано с программированием? Значит это связано
скорее со старым пониманием слова программа, ну или с общечеловеческим. Вот для нас программа
это какой-то текст для компилятора какого-нибудь, а для обычных людей программа это там программка в
театре, там телевизионная программа, ну не в газете уже, на сайте, там афиша какая-то. То есть это некий
план, план того, что будет. Вот здесь слово программирование надо воспринимать именно как
планирование. А почему здесь именно линейное планирование? Да потому что сама вся вот эта
задача, она возникла в свое время вовсе не из компьютерсайенс и не из попытки решать задачи
дискретной оптимизации, а скорее из экономических задач, планирования ресурсов. Вот например у вас
фабрика производит разные товары из каких-то видов сырья. И у вас есть ограничения, у вас есть
B1 тонн такого-то сырья, B2 тонн какого-то сырья и так дальше. А ваша фабрика производит N видов
товаров. И вы знаете, что на товар X1 на одну порцию этого товара, продукта, да, у вас тратится вот
столько вида, вот столько килограмм первого сырья, вот столько-то килограмм второго сырья и так
далее. И спланировать как именно распределить ваши производственные мощности между разными видами
продуктов, которые вы производите, так чтобы вам хватило сырья на каждый, да, на производство всех
этих видов. И при этом максимизировать, например, прибыль. Да, вот если C это то, за сколько вы
можете продать соответствующие виды продукта, вот ваша прибыль, то это вот задача планирования,
да, производственных, планирование производства. И первые такие важные практические применения
были именно здесь, на этом фронте. Так, ну вот про название тоже сказал. Теперь можно рюкзак
наконец вести, да. Задача о рюкзаке. Задача о рюкзаке, значит, мы будем рассматривать
0.1 рюкзак, хотя можно и говорить о более общей задаче. Есть предметы, предметы. У этих предметов
есть стоимости или ценности. Давайте мы эти стоимости обозначим P1Pn. Это слово price, да,
ну можно value называть. Ладно, стоимости. Какие-то положительные числа. Есть веса у этих предметов?
Веса, ну пусть будет W1, weight 1 и weight n. Тоже положительные числа. Ну и кроме того,
есть максимальный допустимый вес, который можно запихнуть в рюкзак. Наша задача нагрузить рюкзак
предметами так, чтобы максимизировать общую ценность предметов, которые в нём лежат. Значит,
давайте мы эту задачу поставим как задачу дискретной оптимизации. Задача дискретной
оптимизации нам нужно понять, что мы по сути ищем. Мы ищем подмножество предметов. Комбинаторная
оптимизация это значит, что то, что мы ищем, является каким-то комбинаторным объектом, каким-то
выборкой, подмножеством, вот чем-то таким, дискретной конфигурацией какой-то. Соответственно,
мы ищем такое подмножество предметов s, но можно считать, что это подмножество индексов от 1 до n.
Вот такое, что тумарный вес предметов, попадающих в это подмножество, не превосходит максимально
допустимого веса, и при этом мы максимизируем, максимизируем тумарную стоимость предметов,
попадающих в наше множество. Тумарную стоимость предметов, попадающих во множество. Вопрос,
ну да, пока еще рано ставить вопрос. Давайте мы эту задачку поставим как задачу программирования
линейного. Вот, но как задачу целочисленного линейного программирования. Я и вот это вот уже
стираю, эту чисто терминологическую часть доски. И здесь я, пожалуй, заголовок дам такой. Рюкзачная
целочисленная линейная программа. ILP это стандартное сокращение Integer Linear Programming,
как вот процесс решения или наука о решении таких программ, или Integer Linear Programming.
А мы легко можем с вами обычно поставить вот такую задачу, как задачу линейного программирования.
Почему? Потому что мы видим, что максимизируется какая-то сумма. Но это правда сумма не каких-то
переменных с константными коэффициентами, а это сумма по какому-то под множеству меняющемуся,
которую нам надо еще найти. Ну ладно, с этим разберемся. И неравенство здесь тоже в общем
линейное, ну какое-то почти линейное. Суммируются константы. У нас, правда, переменных здесь никаких
нету. Вот, но переменность наша этой суммы в том, что мы по какому-то изменяемому, подбираемому
нами под множество суммируем. Но переход от множеств неизвестных нам, которые нам надо найти,
к каким-то переменным, он осуществляется обычно введением, знаете, такого индикаторного вектора
множества. А у вас тервер же был? А нет, у вас не было тервера. Значит, любому множеству, а вы знаете,
что количество под множество любого конечного множества, это два в степени мощность. Ну вот,
вот как мы это обычно доказываем, мы говорим, давайте сопоставим под множеством их индикаторные
векторы из нулей единиц, поставив напротив каждого элемента 0, если он не входит, и единичка,
если он входит в под множество. И тогда, значит, векторов у нас два в степени n, и, значит,
самих под множество тоже два в степени n. Вот ровно эту идею индикаторных векторов мы используем
для того, чтобы задачу о выборе под множество закодировать как задачу о выборе его индикаторного
вектора. Значит, мы вводим в переменные x1 и так далее xn. Переменная, которая, вот когда мы ставим
какую-то содержательную задачу на языке линейного программирования, может, нелинейного
программирования. Мы вводим переменные, которые отвечают нашему выбору основному. Вот здесь мы
выбираем множество. Это значит, если мы выбор множества кодируем выбором каких-то переменных,
эти переменные будут называться у нас такими выбранными переменными. Decision variables по-английски.
Decision variables. Переменные, которые кодируют наш выбор. Соответственно, мы хотим, чтобы
вот этот телеком набор отвечал нашему множеству s. Ну, то есть, по смыслу, смысл у нас такой,
у этих переменных x it равняется единице, если it объект мы кладем в рюкзак и нулю иначе.
Вот это смысл этих перемен. В терминах этих переменных мы можем теперь записать
и целевую функцию, и наше ограничение. То, что мы максимизируем, называется или минимизируем,
называется всегда целевой функцией. По-английски это будет objective function.
Ну, это и в общей теории выпуклые оптимизаторы тоже называется целевой функцией, поэтому это
полезно запомнить. У вас же будет еще курс выпуклой оптимизации. Целевая функция,
значит, это сумма получается, и нам бы вот с вами теперь записать это как просто сумму
переменных с константными коэффициентами. Давайте мы запишем, я даже избавлюсь на всякий случай
пока от знака суммирования. Вот, как можно это записать? w1 на x1 плюс w2 на x2 плюс и так далее,
плюс wn на xn. Ведь действительно, да, здесь вот в эту сумму, когда мы x заполняем нулями и
единицами, по факту войдут только те w, в которых соответствующие переменные выставлены в единицу,
то есть w только тех предметов, которые попадают в рюкзак. Но теперь, вот когда я это объяснил,
я могу, наверное, это все переписать, написав уже взрослую сумму. Значит, взрослая сумма у нас такая,
получается, по i от единицы до n w i t на x i. Я обращаю ваше внимание на вот какой факт. Выглядит очень
похоже. И тут оператор суммирования, и там оператор суммирования. Но вот это вот условие не
является условием, которое можно напрямую подать в solver для задач линейного программирования,
потому что здесь сумма выполняется по какому-то переменному множеству. Вот, это не является какой-то
линейной функцией, вот какой-то переменной. Здесь непонятно пока, что переменная, кроме s. Нет
у нас в линейном программировании множество как переменной. А здесь уже сумма с константным
числом слагаемых, потому что пределы суммирования не зависят от самих переменных. Мы не говорим,
что если переменная какая-то равна единичке, то мы здесь берем какое-то число слагаемых, а если
нулю, то секо это число слагаемых. Мы говорим, что просто по факту те переменные, которые равны нулю,
для них соответствующие слагаемые обнуляются. Но все равно эти слагаемые можно формально считать,
что они в сумму по-прежнему входят. Число слагаемых в сумме формально, оно никак не зависит от того,
какие именно значения у наших переменных. И коэффициенты теперь перед этими переменными,
при каждой переменной, своя четко определенная константа есть. Вот теперь это условие, оно уже
чисто линейное по всем нашим decision variables, по всем нашим переменным. А у нас здесь ничего,
кроме decision variables и не будет. Это да, что мы с вами уже будем вводить какие-то еще вспомогательные
переменные, еще Бог знает что. Пока у нас все переменные, задачи которые будут, это вот они.
Так, теперь наше ограничение constraint. Я надеюсь просто еще на то, что я вот вас помучаю так английским
языком немножко сейчас и дальше по ходу курса. Но зато те из вас, кто одновременно дополнительно
на курсере что-то берут, вот сразу как-то вам будет чуть попроще. И гент Энрика смотри, например.
Так, а кто мне может подсказать теперь как ограничение записать?
Тоже хочется вот такого суммы с константным часовом слагаем.
Ой, пэшки, да, здесь же пэшки, точно. А то теперь дубльбэшки, да? Да, спасибо. Но так
всегда, если бы, представляете, если бы я читал лекции пустой аудитории, что бы я тогда наговорил,
я бы никто не поправил. Вот, это наше ограничение constraint. Чудесно, вот теперь все линейное. У нас
есть, видите, из всего множества неравенств только одно неравенство есть. Но теперь переменные вот
никакому солверу задачи линейного программирования и даже целочисленного линейного
программирования не подашь на вход вот эту информацию содержательную, что на самом деле
вы знаете, господин солвер, вот эти переменные x, они равны мне нулю или единице в зависимости от
того, кладу ли я предмет в рюкзак или нет. Это вообще такое непонятно, да. Вот, мы должны как-то
просто закодировать, что это булевские переменные, что они должны принимать только два значения,
0 или 1. И это, по счастью, можно сделать с помощью линейных неравенств. Каким образом? Мы говорим,
что для каждого и от единицы до n, переменная x, и меняется в пределах от нуля до единицы. Ну,
и при этом все переменные у нас целочисленные. О, смотрите, получилось, что вот это вот условие,
и оно абсолютно стандартное для многих кодирований, значит, задачей скрипной оптимизации, оно нам
говорит, что переменные только булевые. Дальше мы подаем, вот мы можем подать вот такую вот линейную
программу, целочисленную линейную программу, в какой-нибудь солвер, он нам выдаст набор
переменных ноликов и единичек, набор значений переменных, и мы имеем взаимнооднозначное
соответствие теперь между тем, что выдал солвер, и какой-то комбинаторной конфигурации, вот неким
множеством s. И просто по построению этой задачи получится, что множество s, вот которое
проистекает из таких значений переменных, у нас будет оптимальным решением задачи о рюкзаке. Но задача
целочисленного линейного программирования, она НП трудная, и есть солверы для задач CLP. Ну,
Гуроби, вот то, что я перечислял, наверное, в прошлый раз, там Гуроби, CPLEX, CoinBC, GLPK, Google
WarTools, то есть, короче, и много этих солверов. Но мы не можем ни на что... Ну, они не могут нам
ничего гарантировать. Они не могут гарантировать, что эту задачу они решат вот так же круто, там,
со столькими ограничениями, столькими переменными, там, меньше, чем за минуту. Вы можете загнать
в солвер там всего лишь сотню ограничений, сотню переменных, и он там и за два часа ничего не
выдаст. Ну, то есть, он оптимальное решение не найдется два часа. Все зависит от задачки. Ну, нет,
это я, конечно, махнулся, два часа найдет при сотне ограничений, при сотне переменных,
но он найдет. Вот. Но, тем не менее, ничего гарантировать нам, вообще говоря, формально никто не
может. Вот. Так вот, мы теперь дальше что делаем? Мы поставили с вами задачу о рюкзаке. Такую
диаграмму сейчас напишу. Мы поставили с вами задачу о рюкзаке, как задачу целочисленного
линейного программирования. А дальше мы говорим, а мы не будем искать ключи там, где мы их потеряли,
мы будем искать там, где их проще искать. И проще решать не задачу целочисленного линейного
программирования, а обычную задачу линейного программирования. То есть, дальше мы с вами перейдем
от задачи CLP к задачи LP. Как это делается? А мы просто забываем про единственное ограничение,
которое отличает эти две задачи. Легкую и трудную. Мы говорим, а теперь у нас переменные, это
правпроизвольные действительные числа, меняющиеся в отрезке от 0 до единицы. И посмотрим, как это
позволит нам задачку решить. Но не точно, а приближенно. Этот процесс я, наверное, не буду сильно
долго комментировать, за исключением того, что... Давайте немножко напишу. Вот, собственно, вот этот
этап, он, конечно, творческий, но какие-то стандартные подходы здесь есть. Вот, как, например,
замена множества его характеристическим векторам. Вот этот этап, он совсем не творческий, он просто
состоит в том, что мы тупо отбрасываем ограничение целочисленности. И всё. Вот. И вот эта вот линейная
программа, обращаю ваше внимание на новый термин, очередной на сегодня. Вот такая линейная программа,
которая возникла из целочисленной линейной программы, которая кодирует однозначно исходную
задачу. Она называется линейной релаксацией исходной задачи. То есть, вот если мы с вами возьмём
теперь здесь вместо буквы Z, напишем R, то то, что здесь на доске написано, вот ниже вот этой вот
линии, пожалуй, да, то, что написано ниже этой линии с буквой R, это будет называться линейной
релаксацией. Ей задача о рюкзаке. Я это подпишу. Линейная релаксация.
Линейная релаксация. Почему называется, ну, линейная, я не буду комментировать. Почему называется
релаксацией? Ну, relax, да, вот это математически вполне термин. Relax constraints. Мы ослабляем
наши ограничения. В принципе, вот любой момент, когда вы взяли какие-то ограничения в задачи и
что-то с ними сделали, отбросили целиком, как в случае целочисленности, или заменили, ну,
например, W на 2W, да, то есть, позволили рюкзаку быть вдвое более вместительным. Этого, получается,
ослабили ваши ограничения. Вы многие рюкзаки, которые для вас были недостижимы, вы сделали
достижимыми. Вот это все называется релаксацией. Любое снятие целиком, либо ослабление ограничений.
Что мы можем сказать, значит, вот что справедливо для линейной релаксации? Когда вы отбрасываете
какое-то условие, как можно это нарисовать, концептуально себе представить? Вот помните,
да, помните, мы рисовали многоугольник для задачи линейного программирования. Вот в оптимизации
вообще тоже любят рисовать такие облачка, вот и называть их областью допустимых решений.
Вот представьте, что вы, вот в этой луже, в этом облачке в нем плавают всевозможные наборы
переменных, которые удовлетворяют всем вашим ключевым ограничениям. Ну, у нас есть единственное
ключевое ограничения, хотя, нет, не единственное — вот еще вот эти неравенства, это же тоже ключевые
ограничения. Представьте, что здесь плавают всевозможные допустимые наборы переменных,
значений переменных. Что происходит, когда вы ослабили какие-то ограничения? Это значит,
что вы к этим наборам, которые были допустимые, добавили еще кучу допустимых наборов. У вас все
нецелочисленные наборы тоже стали допустимыми. Вот гораздо шире стало множество допустимых
решений. Вопрос, а как тогда минимальное значение вот этой вот функции у нас изменилось? Если мы
сняли какие-то ограничения и тем самым расширили множество допустимых вариантов. Оно могло не
измениться, но если оно как-то изменилось, то оно точно уменьшилось. Правда? Если мы
минимизируем... О, виноват. Мы чего здесь делаем? Максимизируем, наверное. Если мы
максимизируем стоимость рюкзака и мы теперь сильно расширили область допустимых рюкзаков,
то мы можем какие-то новые рюкзаки для себя открыть, которые раньше для нас были запрещены
недопустимыми. Так что мы по-прежнему, естественно, у нас есть допустимые решения исходной задачи,
оно по-прежнему никуда не исчезло, но могут появиться какие-то новые решения, которые еще круче.
И это используется тоже. Это одна из ключевых вещей, которые мы на самом деле используем вот во всей
этой науке, маленькой науке про линейную релаксацию. Так, чудесно. Я здесь еще стрелку в обе стороны
вис. Что мы будем делать дальше? Дальше мы посмотрим, а как выглядит оптимальное решение вот этой вот
задачки линейной релаксации. Причем не всегда нам даже нужно запускать solver для задач линейного
программирования, чтобы это понять. В задаче о рюкзаке она чем хороша в качестве первой
задачи в любом курсе? Тем, что в задаче о рюкзаке мы сами можем с вами угадать, как будет выглядеть
оптимальное решение. Ведь снятие этого ограничения фактически означает, что мы можем дробить теперь
наши предметы. Вот Гент Энрик, он сам Бильгейтс, и он облекает такую форму. Представьте, что вы в
рюкзак напихиваете шоколадки, плитки шоколада. И вот когда вы снимаете это ограничение, вам
разрешается дробить плитку шоколада, отламывать от нее кусочек и класть в рюкзак. Не всю плитку,
а только часть. Но мне нравится другая аналогия, которую я придумал в прошлом году. Она про духи,
ну и про спиртные напитки. Представьте, что рюкзак и то и то спиртосодержащий, но духи как-то
более приличны, наверное. Представьте, что рюкзак превратился в бочку в местимости W, и вы теперь не
кладете туда предметы дискретные, а наливаете туда жидкости. И у вас есть флакончики жидкостями.
Значит, вместимость каждого флакончика это W, миллилитров духов, а вот это стоимость
целиком флакончиков. Получается, что у вас есть возможность отливать целиком бутылочку,
целиком или вообще ее не наливать, ничего, или что угодно промежуточное. Вопрос, как вы тогда
бы сделали вашу бочку с духами максимально, но если считать, что при слиянии ароматов стоимость
тоже суммируется просто, что не факт, то как взять и набрать наиболее дорогостоящую бочку?
Да, берем духи, в первую очередь наливаем самые дорогие в расчете на 1 миллилитр. Давайте мы
вот эту и используем, такую интуицию. Оказывается, нам очевидно, как выглядит
оптимальное решение в релаксированной задаче. Мы в первую очередь берем и кладем в рюкзак,
покуда он не заполнился до краев, кладем в рюкзак, наливаем в бочку духи, имеющие максимально
удельную ценность. А удельная ценность, это вот там P i t поделить на W i t, стоимость 1 миллилитра.
Так, чудесно, но вот сейчас мы этим как раз и будем заниматься. Давайте мы представим,
предположим, для определенности, чтобы упростить обозначение и не говорить, что давайте переупорядочим
наши предметы, так и сяк. Давайте, скажем, без ограничений общности будем считать, это математики
обожают это делать. Без ограничений общности будем считать, что наши предметы в рюкзаке уже
занумерованы, так что они идут по убыванию удельной стоимости. Считаем, что нумерация такая,
что P i на W i. И здесь я еще, чтобы не плодить в сущности, предположу, что удельные стоимости
все чуть-чуть отличаются, что вот здесь точных равенств нигде нет. P 1 на W 1 больше или равно,
чем P 2 на W 2, виноват. Строго больше, чем P 3 на W 3, ну и так далее. Строго больше, чем P n на W n.
Зачем вот это мне нужно? Ну, это не обязательно совершенно, так на всякий пожарный, что называется.
Если у двух духов одинаковые удельные стоимости, то у нас сильно возрастает множество формальных
оптимальных решений. Это как раз тот случай, когда два флакончика духов содержат абсолютно
одинаковые по стоимости духи, и тогда вы можете чуть-чуть из одного флакончика отличить чуть-чуть
из другого. Чтобы вот этой ерунды не было, чтобы вы доливали флакончик до краев, покуда бочка
вообще не заполнилась целиком, вот я, пожалуй, потребую здесь строгие неравенства. Но никакого,
по факту, существенного ограничения не дает. Просто для анализа чуть проще. Да, и понятно,
что пока бочка не заполнится совсем-совсем целиком, мы в нее продолжаем что-то наливать,
разумеется. Так вот, если мы работаем в таком предположении, то тогда как выглядит оптимальное
решение нашей задачи. Оптимальное решение линейной релаксации. Значит, мы наливаем, наливаем,
наливаем, наливаем флаконы в бочку. Причем, покуда бочка еще не заполнилась до краев,
мы целиком выливаем флакончики с духами в порядке уменьшения стоимости. И только может
быть один какой-то флакончик, вот покуда мы его наливали, у нас бочка все абсолютно заполнилась,
и мы этот флакончик не долили, но тогда мы ни один из оставшихся флакончиков уже даже не откроем.
Все, бочка налита до краев. Что это означает в терминах набора значений переменных? Оптимальное
решение задачки обычно обозначается так. Мы вот берем все те же самые буквы для переменных,
и над ними ставим звездочку. Так что обозначение здесь будет такое. Оптимальный набор значений
переменных это x1 со звездочкой и так далее xn со звездочкой. Вот как он получается у нас выглядит
в нашей задачке. До какого-то момента у нас идут единички, потом вот может быть один флакончик,
максимум один. Он вот не весь влез, он между нулем и единицей, но если уж он не влез, то все
оставшиеся флакончики точно нули. То есть можно сказать, что у нас решение такое здесь получается.
До какого-то катего флакончика, ну давайте до k-1 считать, у нас единица. Вот катый флакончик,
если он такой вообще есть с звездочкой, он у нас между нулем и единицей, давайте я это так и
запишу. От нуля до единицы. И значит, если этот флакончик не влез, то с k-1 и до самого-самого
последнего у нас точно все нули. Вот мораль. Какая здесь мораль? Иногда оптимальное решение задачи
линейного программирования, не целочисленного, не надо даже искать с помощью солвера. Мы можем
просто интуитивно понять, угадать какое оно должно быть. Но, к сожалению, помимо задачи рюкзаки,
не так уж много задач, прям вот совсем все хорошо угадывается. Смотрите-ка, а нам практически
повезло, потому что мы сняли целочисленные ограничения на все переменные, решили задачу
линейного программирования, а по факту оказалось, что только одна переменная у нас в каком-то
непонятном статусе. Давайте мы по максимуму попытаемся использовать вот эту вот информацию,
которую нам выдал солвер или мы сами. Давайте те переменные, которые здесь целочисленные,
итак мы и возьмем. То есть фактически мы в рюкзак положим те предметы, которые в рюкзак заведомо
влезают, вплоть до К-1. Чего с катом предметом делать, если не вмещается в рюкзак? Можно
так посмотреть среди оставшихся, просто какие еще влезают в рюкзак, взять предметы просто дальше
по убыванию их удельной стоимости и покуда там влезают. Пройтись до самого конца, честно остановиться.
Вот так что у нас есть первая такая стратегия. Да, первая стратегия. Ух, наверное тут столько места
здесь хватит. Стратегия один, ивристика один. Ивристика один. Ивристика, я напоминаю, это какая-то
разумная, интуитивная, как правило, стратегия решения задачи, которая не претендует вообще по
умолчанию на оптимальность. Просто вот кажется, что неплохим должен быть рюкзак, который построен
вот так. Берем предметы в порядке убывания удельной стоимости. Берем предметы по убыванию
вот этих вот величин. P i t поделить на W i. Так, чудесно. Какая стоимость рюкзака у нас получается?
Значит, стоимость рюкзака. Ну, давайте ее обозначим P i. Ну, поскольку при такой стратегии мы знаем,
что у нас заведомо вот эти вот предметы, первые k-1, точно влезают в рюкзак, они точно там окажутся,
стоимость рюкзака у нас получается не меньше, чем P i, плюс и так далее, плюс P t-1. Ну, какие
из оставшихся влезут, мы не знаем, может, ни один не влезет, а может, еще какие-то влезут. А вот это
ровно то, что мы сделали, да, то есть мы фактически берем предметы вот, ну, по счету, если предполагать,
что мы в этих обозначениях, да, то берем просто по возрастанию индекса. Вот, значит, окей,
насколько хорошо работает эта стратегия, давайте посмотрим. Я, да, здесь придется мне стирать.
Ну, не всегда она хорошо работает, потому что можно привести пример, когда вот это вот,
вот предмет X с катой, он как раз, который не целиком влез, и который мы в итоге и не
сможем положить, если возьмем первый k-1 предмет, когда его-то как раз и следовало положить в рюкзак.
Такой пример плохой для вот этой вристики 1. Ну, допустим, стоимость первого предмета равняется 2,
вес первого предмета равняется единичке. Вот, ну, а второй предмет, я не буду заморачиваться с тем,
что много предметов здесь напридумывать. Стоимость второго предмета равна 1,5 W, ну,
а вес второго предмета равен W. Ну, я думаю, вы понимаете, да, в чем теперь подвох, что вот у этого
предмета удельная стоимость большая, 2 против 1,5, но у этого предмета абсолютная стоимость очень
большая. И очень жалко, что мы вот начав с этого предмета, заполним в рюкзаке маленькую-маленькую,
да, вот такую полосочку, и этот предмет уже не войдет, потому что ему весь рюкзак необходим.
Вот, то есть получается, что оптимальная стоимость рюкзака 1,5 W была бы, а она у нас получится
оптимальной стоимость всего лишь 2. Ну и никакой хорошей оценки, да, мы, значит, не можем дать на вот
эту ивристику 1. Ну, например, мы не можем сказать, что построенный по этой ивристики рюкзак всегда
по стоимости не хуже, чем, например, половина от оптимума, да, вот оптимально можно было бы на
миллион долларов предметов туда набрать, а мы на 500 тысяч долларов хотя бы предметов туда набрали.
Ну, что делать? Если все ломается на катом предмете, да, вот как у нас здесь, то все ломается,
как вот из примера видно, потому что у него абсолютная стоимость очень большая, и как можно
тогда придумать еще какую-то альтернативную стратегию, которая бы вот этим предметом не
давала пропасть с очень большой абсолютной стоимостью, несотносительной. Чем будем делать?
Ну да, в общем-то ничего, ничего так особо не приходит в голову, если про простое что-то нужно
выдумать. Давайте в первую очередь будем класть в рюкзак предметы с максимальной абсолютной
стоимостью. Вот какие из них влезут, такие влезут. Да, берем предметы по убыванию пейтового просто,
берем убывание просто величин пейта. Абсолютных стоимости. Стоимость рюкзака какая у нас
получается? Построенного по второй стратегии, B2, не меньше чем, ну формально говоря, не меньше
чем стоимость хотя бы одного предмета, самого большого. Да, мы здесь будем предполагать, чтобы
вот исключить какие-то лишние разговоры, что все предметы, которые нам поданы на вход задачи,
они в рюкзак по отдельности все-таки влезают, потому что нет никакого смысла рассматривать
предметы, у которых W маленькое больше, чем вот это W большое, рюкзачное. Да, значит, мы будем
предполагать вот это и еще мы будем предполагать, что максимум W маленьких W не превосходит W
большого. Но это такое естественное предположение, вы скорее всего сразу будете предметы, конечно,
отфильтровывать по этому признаку. Первое, что мы делаем. Тогда стоимость B2 вот такого рюкзака у
нас будет не меньше, чем стоимость, ну хотя бы одного предмета, самого-самого большого по стоимости.
Максимум по I от единицы до N по I. И это заведомо не хуже, чем стоимость одного единственного
катового предмета, правда? Потому что, ну если кат и предмет сам по себе максимальный по стоимости,
то окей. Если не максимальный, то значит, второй рюкзак он еще чуточку лучше. Ну а на практике он
скорее всего сильно лучше, чем стоимость одного единственного какого-то предмета, пусть даже
самого большого. Так, и с этим примером мы тогда боремся вот с помощью второй стратегии. Ну легко
придумать пример обратный, когда вторая стратегия плохо работает, а первая стратегия работает лучше.
Давайте теперь посмотрим, а как эти две стратегии комбинируются. Как эти две стратегии комбинируются.
И для этого мы как раз помним про вот эту вот картинку, которую я рисовал, с уменьшенным множеством
возможностей нашей и с увеличенным множеством возможностей. Когда мы релаксируем задачу и
снимаем ограничения, мы расширяем множество допустимых решений. И мы целевую функцию,
то есть стоимость рюкзака или бочки, мы ее можем сделать еще больше, еще больше.
Вопрос, а как выразить через вот эти вот переменные х1 со звездочкой и так далее,
х1 со звездочкой и значение целевой функции. Да, вот собственно мы знаем, что такое целевая
функция. Да, это сумма по всем и в этой единице до n. И что такое оптимальное решение задачки
линейной релаксации? Это как раз и есть вот эти вот х со звездочками, которые доставляют максимальное
значение вот этой вот функции. То есть при подстановке вот этих вот звездочек этих значений
сюда, мы получаем максимально возможное значение, которое вообще может быть у такой функции. И оно
заведомо не меньше, чем оптимальное значение целевой функции в задаче CLP. Мы к задаче LP,
для которой рассматривается оптимальное решение, мы как раз перешли, сняв ограничения,
релаксировавшись. Значит, увеличив право-налево, если считать, увеличив значение, оптимальное
значение целевой функции. Значит, здесь мы можем смело подставить оптимальное значение целевой
функции в задаче CLP. Целочисленное линейное программирование. Это вот то, что мы с вами
писали здесь в терминах вот этих переменных. И здесь у нас было условие. Каждый х это целое число.
ILP. Integer Linear Programming. Guys. CLP это по-русски, а ILP это по-английски.
Оптимальное значение, оптимальное значение целевой функции в задаче CLP.
Есть два варианта, что может произойти со мной с вами под конец курса. Либо я вас абсолютно
достану переходом с английского на русский обратно, либо вы немножко выучите терминологию
дискретной оптимизации на обоих языках. Вот, но я надеюсь, что второе. Так вот, оптимальное значение
целевой функции в задаче CLP. А что вот это такое? Поскольку задача CLP кодирует один в один задачу
о рюкзаке, мы же по смыслу, помните, вводили переменные х как раз таким образом, чтобы набору
значений х булевских, которые только нолики или единицы, однозначно отвечало какое-то наполнение
рюкзака. То есть вот это я не зря здесь стрелку ставлю в обе стороны. Когда мы берем целочисленную
линейную программу для исходной комбинаторной задачи, эта программа, она однозначно кодирует вот
любой ее набор значений переменных выбора, decision variables вот этих, он однозначно абсолютно
отвечает некоторые комбинаторные конфигурации, которые мы здесь как раз ищем. В том числе,
оптимальный набор х, который доставляет максимальное значение функции в задаче CLP,
он кодирует нам оптимальный рюкзак, оптимальное наполнение рюкзака и соответственно,
оптимальное значение целевой функции, то есть значение как раз вот этой суммы на этом оптимальном
наборе, это и есть максимально достижимая стоимость рюкзака. Вот это один в один. А вот этот
переход, он у нас с потерями логическими как раз, но тем не менее с некоторым неравенством.
Но вот что я хочу дальше сказать, что вот это неравенство, оно возникает из вот такого перехода,
не только в задаче о рюкзаке, абсолютно любой переход от задачи CLP к задачи LP, он сопряжен
вот с таким вот неравенством, если исходная задача была задачей максимизации и с неравенством
в обратную сторону если исходная задача была задачей минимизации. А дальше, я что могу написать?
Дальше могу написать равенство, поскольку здесь у нас переход 1 в 1, но здесь я могу написать равно
стоимости оптимального рюкзака или оптимальной стоимости рюкзака, оптимальная стоимость рюкзака.
Ну, я думаю, что вы это себе уже отметили, здесь можно поставить оптимальную стоимость рюкзака,
я напишу сокращение. Это просто оптим. По-английски, от слова оптимум. Но дело в том,
что в статьях по дискретной оптимизации это уже абсолютно стандартное обозначение,
которое даже, скорее всего, никто объяснять не будет отдельно. Что оптимальное решение и
или соответствующее оптимальное значение целевой функции обозначается просто словом
сокращением опт. Это максимально достижимая стоимость рюкзака. Задача о рюкзаке для нас
в данном случае. Так, скажите, пожалуйста, теперь, да, мы знаем здесь в этой сумме некоторые,
да как не некоторые, мы все слагаемые знаем, потому что мы знаем, как выглядит оптимальное
решение. Чему равна эта сумма? Она у нас равна. Давайте подставим сюда все, что мы знаем про наши
переменные. Значит, переменные с первой по камену с первого у нас равны единичке. Переменная х
катая, она от нуля до единицы. Вот, но я так и напишу, плюс п катая на что-то такое непонятное пока,
от нуля до единицы. А дальше что будет стоять? Дальше нули, да, потому что мы знаем, что остальные
переменные все равно нулю. Вот, но хорошо. Можем мы так теперь перейти по неравенству. Если выполнено
такое равенство, давайте мы вот эту вот переменную округлим мысленно к единичке. То есть дольем в бочку
флакончик, который на самом деле в нее не влезает. Но мы вот так еще сверху горкой дольем духов. Если
представить, что на бочке может сверху образоваться горка, да, вот здесь я могу поставить теперь
неравенство видом меньше или равно заменив вот эту вот непонятность, которая от нуля до единицы,
просто на единичку, долив вот этот вот на самом деле не влезающий флакончик духов.
О, чудесно. И теперь вот эта штука меньше или равна, чем, чтобы здесь такое записать,
зависящее только уже от наших вот этих евреистических результатов P1 и P2.
P1 плюс P2, да. P1 плюс P2. Чудесно. Так, теперь у нас есть получается две еврестики, два рюкзака,
допустимых. А тем, что P1 у нас вот только до K-1 предмета влезают в рюкзак гарантированно,
а K-1 не влезает. А P2 в стратегии мы заведомо положим как минимум один предмет,
который по стоимости как минимум не хуже, чем P-K-1. Ну, очевидно, что любой отдельный вес не
превосходит максимум, не вес, а стоимость не превосходит максимум стоимости по всем И,
да, поэтому P-K-1 не превосходит, конечно, вот такого максимума. На самом деле стратегия P2,
скорее всего, сильно лучше. Вряд ли в реальных входах в задачу рюкзаки у нас только один
предмет влезет и больше ничего не влезет. Скорее всего, обе эти стратегии, ну не P1,
а вот стратегия P2, она сработает намного лучше, чем вот эта вот штука. И мы теперь знаем,
что суммарная стоимость двух рюкзаков не меньше, чем стоимость оптимального рюкзака. Что тогда мы
можем гарантировать, если возьмем из этих двух ивристик лучшую по факту? Половинка, да, хотя бы.
Вот, следовательно, то есть из вот этой вот цепочки неравенств следует, то лучшая из ивристик P1,
P2, лучшая из ивристик 1 и 2, дает рюкзак по стоимости не меньше, чем половинка от опт.
Половинка от опт. Потому что мы выяснили, что суммарная стоимость двух рюкзаков не меньше,
чем опт целиком. Значит, лучшая из них, максимально из этих двух чисел, точно не меньше половины.
Скорее всего, сильно больше. Вопрос, а может быть какая-нибудь из этих чиселок P1 и P2 больше опта?
Не может, потому что по определению опт это и есть. Там самая максимально достижимая стоимость
рюкзака допустимого, в который все влезает. А мы эти ивристики построили так, что они дают нам
допустимые решения, то есть не переполненные рюкзаки. Вот, значит, какие выводы можно сделать из этого всего?
Мы использовали вот этот вот LP и рюкзак. Использовали на самом деле по-разному. Значит,
во-первых, решение задачи линейного программирования оптимальное позволило нам сформировать некое
эвристическое решение задачи вот этой исходной. То есть, с одной стороны, мы имеем какое-то
приближенное решение для задачи о рюкзаке исходной. А с другой стороны, некие знания
про линейную релаксацию позволяют нам еще кое-как оценивать оптимум исходной задачи. Каким
образом? Вот когда мы с вами выписали вот это вот неравенство, во-первых, вот это неравенство,
возникшее из вот этого перехода, и дальше выписали вот это вот неравенство, мы с вами знаем, что, ага,
мы не знаем в точности стоимость оптимального рюкзака. Это трудная комбинаторная задача. Но мы
умеем очень неплохо оценить стоимость оптимального рюкзака сверху. Мы знаем, что опт не больше,
чем вот сумма таких пэшек. Так что мы с другой стороны, умеем еще с помощью вот этого вот задачи
линейного программирования, вот этой штуки, оценивать. Оцениваем. Баунд. Оценивать.
Получаем некие оценки. Баунд для исходной задачи, которые позволяют нам, видите, в итоге сравниться,
насколько полученное нам евристическое решение близко к настоящему оптимуму.
Вот. Но давайте я это все вытащу. Теперь все наши достижения.
Первый. Начленина и релаксация. Во-первых, дает некую евристику часто, евристику для исходной задачи,
для комбинаторной задачи. Во-вторых, линейная релаксация позволяет оценить оптимальное значение
функции целевой восходной задачи. Позволяет оценить оптимум комбинаторной задачи.
Третье. Что еще полезное мы с вами выяснили. Не всегда оптимальное решение задачи линейного
программирования надо получать с помощью солдера. Иногда просто уже вот тот факт,
что мы задумались, а как бы выглядело это решение, если бы нам позволялось предметы
раскалывать или вместо предметов были бы духи. Это уже полезная точка зрения на исходную задачу.
Значит, иногда оптимальное решение линейной релаксации можно просто угадать,
не решая эту задачу. Следующее. Это пример, показывающий наглядно, что в сложных задачах
может сработать такой подход. Иногда только он на самом деле и работает по-настоящему. Нету
одного алгоритма на все случаи жизни. Решение задачки. Вот мы привыкли, привыкаем в курсе
алгоритмов, например, таком вводном, что есть жестко поставленные задачи о кратчайшем пути.
Есть один единственный верный алгоритм. Там этот алгоритм Дэйкстр. Ну, условно. Или там есть
сортировка массива. Есть вот сортировка только слияния. Ну или что-то другое. В общем, есть
точное решение задачи, которое можно получить с помощью вот одного алгоритма. Вот мы его и учим.
И на практике ищем самый крутой алгоритм, самый быстрый, только его кодируем. Все,
остальные алгоритмы нам просто не нужны. На практике в дискретной оптимизации оказывается,
что обычно нам как раз полезно закодировать несколько разных иллюстических подходов для
решения задачи и выбрать тот, который на конкретных входных данных сработает наилучшим образом по факту.
То есть заранее это очень часто предстоять невозможно. Какая иллюстика кажется лучше.
Только по факту запуска. Не боимся реализовывать сразу много иллюстики. Выбирать из них
ту, которая сработает лучше на конкретных входных данных. Часто нет. Часто для задач
комбинаторная оптимизация. Комбинаторная оптимизация полезна. Не то, что нужно,
да, полезно реализовать несколько подходов и выбрать лучшие уже по факту запуска. Полезно
иметь несколько подходов, несколько иллюстиков и выбирать лучшие по факту запуска. Но если еще
чего вспомню, вот, что можно отсюда выводить, то, наверное, скажу. Но вот ко второй иллюстики мы
пришли каким образом. Мы посмотрели, а что, как может сработать неудачно первая иллюстика. Это,
наверное, все-таки будет пятым таким takeaway. Придумывать иллюстики для задач можно,
специфически подбирая примеры, на которых старые иллюстики работают плохо, доказуемо плохо. То
есть придумывание примеров трудных для имеющихся иллюстик может навести вас на мысль о какой должна
быть альтернативная иллюстика. Придумываем, просто напишу, придумываем примеры трудные для иллюстики.
Ну плохие, трудные, неудачные, на которых имеющиеся иллюстики работают плохо. Просто
думание над такими примерами позволяет нам прокачать интуицию и придумать какие-то
иллюстики альтернативные. Трудные для имеющихся иллюстик. Ну это все, наверное, что из этой задачки
можно выводить, из нашего решения. Сейчас мы с вами, нет, сейчас мы с вами сначала, я поотвечаю,
я только уже поотвечаю на вопрос, потому что осталось три минуты. Ну или, может быть,
у вас есть чего добавить. Если вам на практике встречалась когда-нибудь, может вы сами кодили
уже, вот ситуация, когда не работает подход с одним единственным, таким святым гралем,
единственным алгоритмом, который, если он у вас будет, можно все остальные выкинуть. Бывало такое?
Нет? Пока нет. Ну это хорошо, это значит, мы с вами рассматриваем что-то для вас новое. Значит,
когда вы будете рассмотреть курс Гентенрика, да, внимание, задача о рюкзаке, это задача,
с которой начинаются сразу два курса на курсере. С одной стороны курс Клер Матье, с другой стороны
курс Гентенрика. Поэтому то, что мы с вами сегодня рассмотрели, я надеюсь, позволит вам хотя бы
первые две лекции посмотреть по курсам вот этим двум, approximation algorithm с Матье и discrete
optimization с Гентенрика. Если вы не боитесь совсем-совсем английского языка, а я не вижу смысла его
бояться, потому что рано или поздно он нам встретится, то я вам советую в этих двух курсах
посмотреть первые две лекции, а вдруг вам понравится и вы возьмете те курсы вместо нашего, ну или в
дополнение к нашему, что еще лучше. Поэтому дерзайте, я надеюсь, что вы что-то новое в тех лекциях для
себя вынести тоже под рюкзак. Все тогда на сегодня, всем счастливого!
