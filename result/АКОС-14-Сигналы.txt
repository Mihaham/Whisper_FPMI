Так, ладно, всем привет. Поздравляю с началом семестра и с тем, что я наконец-то могу видеть
вас вживьем, а не только показывать себя в пустой аудитории. В прошлый раз мы начали
большую тему про межпроцессное взаимодействие, и собственно это будет половина семестра. В прошлый
раз мы рассмотрели один из простых способов взаимодействия между процессами по названиям
каналы. Сегодня будет еще один из способов, который называется сигнал. Итак, давайте я напомню о том,
что такое процессы в очередной раз. Процесс это такая штуковина, которая выполняется изолированно
и выполняет какую-то программу, у которой обычно есть начало и есть конец. То есть у нас программа
в какой-то момент времени может завершиться, хотя совершенно не обязательно. Например,
завершается функция main, которая обычно возвращает int, либо заканчивается немножко раньше, чем
закончится функция main, если вы вызовете функцию exit, либо системный вызов exit, который вызывается
из функции exit. И тем самым ваш процесс завершится и вернет какой-то целочисленный код возврата
размером 1 байт. Затем родительский процесс может вызвать weight pit либо weight для того,
чтобы получить 32-битное число, большое число, которое содержит причину завершения процесса,
и в том числе извлечь этот байт с кодом возврата. Но на самом деле процессы могут завершаться не
только добровольно, но и по каким-то другим причинам. Например, процесс может получить
так называемый сигнал в одной из нескольких причин. Самый простой способ послать процессу сигнал
это набрать в терминале команду kill либо kill all. Команда kill требует явного указания процесса ID,
kill all в качестве аргумента принимает название исполняемого файла и прибивает все экземпляры этого
исполняемого файла. И тем самым вы просто завершаете работу процесса, не дождавшись,
пока он честно дойдет до функции exit, либо до конца функции my. Если вы программу запускаете из
терминала, вы можете нажать CTRL-C, вы можете просто закрыть вкладку терминала, либо банально ваша
программа может получить какую-то ошибку, segmentation fault, еще что-нибудь. Да, ну еще можно просто выключить
компьютер. И в какой момент времени у нас приходят все эти события? Ну, очевидно, в те моменты времени,
про которые процесс совершенно ничего не знает, это просто какой-то рандом с точки зрения выполнения
программы. Но по-хорошему процесс должен иметь возможность как-то эти ситуации обрабатывать.
Например, если у вас есть какие-то критичные данные, которые нельзя потерять, то, естественно,
при получении сигнала нужно сначала эти данные сохранить, а потом завершить свою работу. В чем
еще особенность завершения работы процесса с помощью сигнала? В этом случае у нас становится
неопределенным код возврата, и когда вы с помощью weight либо weight pit читаете это состояние, то эту
ситуацию нужно обрабатывать отдельно, то есть проверять, что программа действительно завершилась
кодом возврата, тогда вы код возврата можете извлечь. Либо другая ситуация, если программа
завершилась с помощью сигнала, и в этом случае вы можете узнать, а по какой именно причине, то есть
из-за какого сигнала ваш процесс был завершен? Из-за чего могут возникать сигналы? Сигналы
могут посылаться процессу либо другим процессом, либо ядром, ну и процессы сами себе тоже могут
посылать сигнал. Какие ошибки могут быть? Самая частая ошибка, которую вы, наверное, встречали,
это нарушение сегментации. Обычно возникает, если вы пытаетесь обратиться к какому-то области памяти,
которая не отображается на виртуальное адресное пространство, либо вы пытаетесь сделать что-то с
памятью, не имея на это достаточных прав. Например, какой-то участок у вас отображается как память
только для чтения, а вы пытаетесь что-то туда записать. Либо на современных системах вы
пытаетесь выполнить код из участка памяти, для которого не предоставлен флаг исполняемый. Кроме того,
в прошлый раз мы еще рассмотрели каналы, и у каналов есть одна особенность, что когда вы хотите
что-то прочитать из каналов, с которым не связана никакая записывающая сторона, то системный
изофрит просто блокируется, можете наступить на дедлог. А если вы пытаетесь записать что-то в
канал, который никто не читает, тогда вы получаете ошибку. Broken pipe это тоже сигнал,
который вам посылает ядро операционной системы. Ну и разные исключения процессора тоже могут
всплывать в виде сигналов. Например, неверная инструкция, когда такой сигнал возникает. Например,
когда вы пытаетесь на каком-нибудь старом процессоре выполнять код, который не поддерживается.
Берем например интеловский процессор десятилетней давности, пытаемся на нем выполнить что-то в
x2, все приплыли. Ну и другие исключения процессора, например, деление на 0. Процесс тоже сам себе может
посылать сигналы. Обычно это редкая история, и нужно для того, чтобы сломать наш процесс
принудительно. Вставить, например, какую-нибудь конструкцию Assert, либо abort, функция есть такая.
Для чего это бывает нужно? Проверка каких-то условий. И если у вас код обычно скомпилирован в дебаг
режиме, а не в релиз, то лучше уж пусть процесс грохнется, чтобы можно было исследовать его
состояние, чем он будет выполнять что-то неправильное. Может быть какой-то другой
процесс, который посылает вам сигнал, и если другой процесс может отправлять вам сигнал,
то, наверное, этот способ можно в том числе использовать как способ межпроцессного взаимодействия.
Что такое сигнал? Сигнал это какое-то асинхронное событие. Асинхронное это значит,
что оно прилетает в любой произвольный момент времени. И что можно делать при получении сигнала?
Есть стандартные реакции на разные сигналы. Например, сигнал можно просто проигнорировать.
Пример такой ситуации, это когда вы запускаете какой-то дочерний процесс, затем этот дочерний
процесс завершает свою работу, и при этом ядро посылает вам сигнал о том, что ваш дочерний
процесс завершился. Понятно, что лишний раз завершать свою работу, грохаться на каждый
завершенный дочерний процесс, это очень странно. Поэтому действия по умолчанию для таких ситуаций,
это просто игнорировать такие сигналы. Хотя эту ситуацию можно в том числе обработать. Большинство
сигналов стандартных приводят к немедленному завершению работы процесса. Классический пример
это команда kill, которая по умолчанию отправляет сигнал SIGTERM. Этот сигнал, конечно, может быть
перехвачен, но тем не менее действие по умолчанию это завершить свою работу. И есть сигналы,
которые просто меняют состояние процесса. Состояние процесса бывает выполняется,
приостановлен, поставлен на паузу и так далее. И это бывает удобно, например, если вы запускаете
какой-то процесс из-под отладчика, и в этом случае нажатие кнопочек выполнить следующую строку,
продолжить выполнение и так далее, они как раз управляются с помощью сигналов. То есть есть некоторые
действия по умолчанию, и вы можете запрограммировать какие-то произвольные действия на большинство
сигналов, но не на все. Итак, есть некоторые стандартные сигналы. Некоторые из них отправляются
ядром. Это, например, SIGHUB, SIGIL, но вообще можно любой абсолютно сигнал отправить с помощью команды
KILL. К чему приводят разные сигналы и из-за чего они возникают? Самый распространенный сигнал,
который вы можете посылать, это нажатие клавиш Ctrl-C. Посылает сигнал с номером 2,
он же SIGINT, который по умолчанию приводит к завершению процесса. Код возврата,
при этом, естественно, не определен. Кроме того, процесс может завершаться по другим причинам.
Например, если вы закрываете вкладку терминала, то у вас пропадают стандартные потоки ввода и
вывода SD-IN и SD-OUT, и процесс при этом получает сигнал SIGHUB. Это совершенно другой сигнал,
другая причина завершения работы. Если у вас возникает неверная инструкция либо деление на ноль,
то тоже ядро отправляет сигнал, который, в отличие от простого завершения, может еще
при этом приводить к созданию дампа памяти, ну или процесс может сам себя прибить. Давайте
посмотрим, как можно поубивать процесс разными способами. Для этого нам нужен процесс,
который, например, ничего не делает. Вот простая программа, которая не делает ничего и при этом
старается не мешать другим процессам. Еще один возможный вариант описания такой программы
SHED-YIELD поменять на какой-нибудь SLEEP. В этом случае вы будете меньше расходовать аккумулятор ноутбука,
но при этом SHED-YIELD точно так же, как и SLEEP, не мешает выполнению других процессов. Запустим
нашу программу, ну и теперь предложите способы ее прибить, учитывая, что она сама никогда не
завершает свою работу. Как это можно сделать? Самые разные, да. Ну, очевидно, CTRL-C. Нажали,
что сделать в нашей программе. Она получилась сигнал SIGINT, мы ее прибили. Так, ладно, следующий
способ. Да, банально закрыть вкладку. Все, программа завершилась. Так, еще способы. Я могу, да,
открыть другую вкладку, набрать команду ps, найти наш процесс и, зная его процесс ID,
набрать команду kill и наш процесс был завершен. То же самое я могу назвать набрать команду kill all,
если мне лень искать наш процесс. На самом деле это опасный способ. Вдруг у вас есть еще какой-нибудь
процесс с таким же исполняемым файлом, будут прибиты все. Так, ну и еще один способ, это нажать
сочетание клавиш CTRL-SLASH, слэш вот такой. В этом случае программа тоже завершит свою работу,
но в отличие от CTRL-C, она еще получает сообщение к виду, и что-то у нас тут делается, пока не делается,
но сейчас будем добиваться, чтобы оно сделалось. А именно, чем отличается принципиально сигнал
CGBRT, который завершает свою работу процесса с некоторым core dump от обычного завершения,
например, по CTRL-C. Есть такое понятие, как core dump. Это просто образ памяти, один в один,
что у нас хранится в памяти процесса, который может быть сохранен на диск для того,
чтобы дальше можно было это исследовать обычным отладщиком ГДБ. Естественно, для этого у вашей
программы должна быть отладочная информация, иначе этот core dump будет совершенно
бессмысленным. И что обычно происходит с core dump? В большинстве линукс-дистрибутивов эти core
dump просто либо игнорируются, либо могут быть переданы разработчику, то есть возникает окошко
о том, что программа завершила свою работу некорректно, сообщите разработчику о том,
что пошло не так. И что у вас происходит в этот момент? В этот момент просто отправляется core dump.
Хотя, на самом деле, не всегда core dump могут быть полезны, некоторые из них могут требовать
отдельной отладочной информации, но разработчики уже с этим самим разберутся. И как понять,
что у вас происходит с core dump? Нужно посмотреть переменную kernel-core-pattern. Это специальная
системная переменная, настройка ядра, которая проверяется либо стенлозом sysctl, либо командой
sysctl. Sysctl с опцией "-a", отображает все переменные нашего ядра, ну и можно поставить либо найти
вот такую переменную kernel-core-pattern, которая определяет шаблон. Да, тут много всяких еще
других названий, которые недоступны, но вот kernel-core-pattern — это некоторый шаблон имени файла,
который может содержать, в том числе, например, process ID, полный путь программы и так далее через
процентики. То есть это некоторый шаблон, который определяет имя файла для создания core dump.
Если этот шаблон начинается с вертикальной черты в некоторых дистрибутивах, например,
Fedora или OpenSUSE, это именно так и сделано, то core dump просто направляется некоторому сервису,
который обрабатывает эти core dump, и в зависимости от того, что это за dump, уже выполняет какие-то
дополнительные действия. Либо игнорирует, либо предлагает отправить разработчику. Итак,
должен по идее создаться файл под названием core, если я нажму ctrl-slash, либо запущу какой-то
процесс, который делает, например, вот такую штуку. Если программа где-то вызывает функцию abort,
которая сама в себе, саму процессу посылает сигнал cgbrt, то у нас дополнительно создается core dump.
Давайте я запущу, например, скомпилирую эту программу с отладочной информацией, то есть
с опцией "-g". Теперь, что ожидается, когда я запущу эту программу? Естественно, она грохнется,
и ожидается, что будет создан файл под названием core, но файл почему-то не создался. Это связано с
тем, что есть еще ограничение на максимально возможный размер core файла. В некоторых дистрибутивов
по умолчанию он равен нулю, но это ограничение не является жестким, и можно указать какой-нибудь
не нулевой размер в блоках. Блок — это одна страница памяти. Все, вот я поменял этот лимит.
Теперь я могу еще раз запустить какую-то программу. Все, у нас процесс грохнулся по сигналу cgbrt. При этом
у нас создался dump-хедра, вот появился файл под названием core. Что теперь с этим файлом я могу
сделать? Теперь я могу набрать команду gdb, дальше название исполняемого файла, и еще я могу добавить
в качестве аргумента имя core файла, который у меня раньше получился. Причем это можно сделать
не обязательно на том же самом компьютере, это можно сделать на другом компьютере, главное перекинуть core
файл. Теперь можно посмотреть на backtrace вызова, и вот мы видим, что наша программа грохнулась,
потому что где-то из стандартной сибиблиотеки мы вызвали какую-то функцию gi-race, чего-то там из
функции ji-abort, которая в свою очередь была вызвана из функции main в пятой строчке до abort.c. И таким
образом можно уже после того, как программа грохнулась, разбираться в причинах, а что же у нас пошло не так.
Так, что у нас еще есть с сигналами? На самом деле это не темно-коричневый цвет, это красный цвет. Есть
некоторые сигналы, которые являются очень жесткими, сейчас мы про это отдельно поговорим,
так давайте придемся по всем остальным сигналам. Некоторые сигналы, которые могут генерироваться
ядром, это нарушение сегментации, broken pipe, ну и кроме того есть стандартный сигнал,
который посылается по умолчанию командой kill. На самом деле команде kill можно передавать все эти
имена и посылать не только сектерам по умолчанию, но и все остальное. Есть еще ситуация, когда процесс
приходит в режим паузы до тех пор, пока вы не продолжите выполнение процесса. Из-за чего это
может происходить? Наверное, встречались иногда с такой ситуацией, что, особенно когда только
переходите на UNIX-систему после Windows, что вместо, например, CTRL-D для завершения потока ввода вы
нажимаете CTRL-Z. Или иногда случайно промахиваетесь, нажимаете CTRL-Z, когда пытаетесь там сделать какую-нибудь
отмену undo в консольном приложении, забывая, что это у вас консоль, и получать вот такую картину,
что процесс какой-то suspended. Что делать дальше? Как теперь вернуть все обратно? И что вообще у нас
произошло? Произошло следующее. Вот наш процесс ГДБ, который находится в состоянии T. Что буква T
означает в плане состояния? Значит, процесс остановлен с помощью сигнала six-stop. То есть нажать
и клавиш CTRL-Z, посылает текущему процессу сигнал six-stop, процесс просто останавливается,
переходит в режим паузы. Как вернуть все как было? Есть такая замечательная команда foreground,
то есть не нужно паниковать, перезапускать заново. Команда foreground, которая посылает нашему процессу
сигнал six-continue. Все, теперь процесс выполняется дальше. Экран, правда, не перерасовался по понятным
причинам, но тем не менее процесс живой, процесс работает. И просто команда foreground посылает сигнал
six-continue, который меняет состояние. Два сигнала sig-child, sig-argand, они по умолчанию у нас
игнорируются, то есть не волняются никаких действий, если вы их не переопределите. И что значит
переопределить какие-то действия для процесса? Это значит, что вы можете навешать на большинство
сигналов какие-то произвольные кастомные обработчики, функции, которые будут выполняться вместо действий
по умолчанию, но это невозможно сделать для сигнала six-stop, то есть нажатие клавиш CTRL-Z,
ну никак. Только если перехватывать клавиатуру и блокировать сочетание клавиш CTRL-Z. Есть еще
жесткий сигнал six-kill, вот его тоже никак нельзя перехватить. Ну и что значит перехват обработки
сигналов? Есть два способа, как перехватить обработчик сигнала. Один старый, другой по новее.
Старый он выглядит немножко попроще, это системный вызов сигнал, где в качестве первого аргумента
вы передаете номер сигнала. Совершенно не обязательно помнить номера сигналов,
но за исключением сигнала с номером 9. Сигнал с номером 9 это kill, это надо запомнить. Все остальные
номера, в принципе, они представлены разными константами из того же файла signal h. То есть
первый аргумент это номер сигнала, а второй аргумент это указатель на функцию с очень
простой сигнатурой, которая будет выполняться вместо дефолтного обработчика. И тут уже возникают
первые подставы, связанные с портируемостью такого кода, хотя бы по той причине, что вроде как
похожие сигнатуры у системного вызова сигнала, но используются немножко разные названия объявления
из оголочных файлов. В линукс называется сиг-хэндлер подчеркивания t, а во FreeBSD и macOS
называется сиг подчеркивания t. Но вроде как с этим жить можно, не сильно нам это пока мешает. И как
можно взять и перехватить обработчик для нажатии ctrl-c. Делается достаточно просто.
Итак, если я вызываю вот этот вот системный вызов сигнал, в качестве первого аргумента
указываю целочисленную константу, связанную с номером сигнала. Второй аргумент это указатель
на функцию, которая будет выполняться, то каждый раз вместо того, чтобы выполнять действия по
умолчанию, у вас будет выполняться какая-то функция. Давайте мы эту программу запустим. Здесь я
зарегистрировал обработку на два сигнала, то есть у меня нет никакой реакции на ctrl-c. Я нажимаю
ctrl-c, вместо того, чтобы завершить свою работу, мы получаем, что пойман сигнал с номером 2. И
то же самое, если я пишу kill all, как там процесс назывался, handle, sig. Трудно. Если я пишу kill,
процесс такой-то, он тоже не прибивается, потому что сиг терм, мы тоже перехват. Как этот процесс
можно прибить? Предложите хотя бы два способа. ctrl-d не спасет, потому что я ничего не читаю.
Закрыть терминал. Ладно. Во-первых, я могу написать kill-9 либо kill-kill. Сигнал sig kill
перехватить невозможно в принципе, и поэтому с помощью этого сигнала можно прибить абсолютно
любой процесс. Второй способ, если не получается, но опять же, внимательно смотрим на код. Я
перехватываю sig int, sig term, а, например, sig quit, ctrl-slash я не перехватываю, поэтому могу использовать
сигнал для того, чтобы завершить его работу. Так, почему такой способ плохой с использованием
системного вызова сигнала? На счет партируемости есть тут две разные проблемы. Во-первых,
в заключенных файлах там какая-то ничь написана в разных операционных системах. Во-вторых,
сигналы по-разному работают на разных операционных системах. Точнее, есть два огромных класса
операционных систем. Это классическая AT&T System 5 Unix, от которой потом, не то что отпочковались,
скорее ее лицензировали и доработали под себя компании Sun Microsystems и IBM. Это операционные
системы Solaris и IBM AX. Сейчас уже компании Sun Microsystems не существует, вместо нее есть Oracle,
Solaris называется теперь Open Solaris, и просто Solaris тоже жив. В общем, на самом деле таких
систем было когда-то много, они уже все повымерли, вот, кроме двух. И была альтернативная ветка
развития Unix-систем в 80-е годы, которая называлась BSD Unix. Следуя заветам BSD Unix,
сигналы реализовали в системах всех BSD подобных, то есть Free BSD, Open BSD, Net BSD, в Linux и в macOS.
В чем разница? Вот когда вы компилируете код с указанием явно какого-то стандарта,
если вы указываете стандарт C++17, C11, C99 и так далее, то компилятор строго следует именно
стандарту языка и стандарт еще некоторым старым Unix-овым стандартом. А если вы пишете еще
слово GNU вместо C11, либо GNU++ вместо C++17, например, то у вас дополнительно доопределяются
некоторые macros, это BSD Source, GNU Source. В последних версиях в Gleap C macros BSD Source стал
не приклеить и вместо него другое название, но суть это не меняет. То есть у вас немножко
меняется поведение. Что происходит, когда вы пишете GNU вместо языка программирования?
Во-первых, у вас становятся доступны некоторые нестандартные расширения языка программирования.
Кто помнит такие нестандартные расширения полезные? Нет, boost совершенно ни при чем. Это
отдельная библиотека. Нестандартные расширения имеются в виду, например, встроенные функции для
проверки целочисленного переполнения. В прошлом семестре вы это использовали. Ну и плюсы считаются
определенными вот эти macros. И на что это влияет? Давайте мы перекомпилируем нашу программку,
очень простую, которая просто регистрирует два обработчика с разными опциями компиляции.
Итак, скомпилируем. Бинарник в стиле System V, строго следуя стандарту,
не дописывая никаких новых макроопределений. И скомпилируем тоже самое, но с гнушными расширениями.
Так, сначала посмотрим... Ой, блин, я же перезаписал, да, спасибо. Так,
вместо System V пусть будет BSD Style. Давайте посмотрим на стандартный BSD Style,
но то поведение, которое мы сейчас и ожидаем. Ничего сверхъестественного. А теперь запустим
System Fire Style, нажимаем CTRL-C. Все честно, да, получили сигнал, не завершились. Нажимаем CTRL-C
еще раз. Бабах! Просто из-за того, что я указал другой флаг компиляции. Так, из-за чего это
происходит? Потому что обработка сигналов по-разному происходила уже в 80-е годы в разных UNIX-системах.
В System Fire у нас после обработки нестандартного хендлера происходил сброс на хендлер по
умолчанию. Поэтому первый раз у нас появилось сообщение, что получен сигнал с таким-то номером,
при повторном нажатии CTRL-C, поскольку у нас все сбросилось на дефолтное поведение, произошел
дефолтный обработчик сигнала, то есть процесс завершил свою работу. Еще сигналы System Fire
могут вызываться рекурсивно. То есть в тот момент, когда у вас выполняется какой-то обработчик сигнала
и приходит еще один сигнал, то у вас рекурсивно начинает выполняться, не завершив вполне предыдущего.
В общем, достаточно опасная штука, поскольку вашему процессу могут посылать огромное количество
сигналов, чтобы его забомбить. В BSD-системах, ну и тем, которые следуют этому соглашению, в том
числе Linux, по умолчанию подразумевается, что если у вас уже обработчик сигнала, то он гарантированно
завершится, а потом, может быть, если пришел сигнал, то будет выполнен повторно. Ну и есть еще очень
важное с точки зрения удобства использования отличия, если ваш процесс выполняет какие-то
блокирующие системные вызовы, например, read, write, то эти системные вызовы у вас завершатся,
вернут минус один и код ошибки пропишут E-inter, то есть у вас стемный вызов был прерван каким-то
сигналом. В случае с BSD-стайлом все эти системные вызовы автоматически перезапускаются и нет
необходимости проверять на код ошибки E-inter и выполнять какие-то повторные действия, что достаточно
удобно. Есть два разных способа обработки сигналов и более современный способ, который позволяет
все это детально указывать, а не надеяться на какое-то поведение определенной операционной системы,
заключается в том, что вы не используете системный вызов сигнал, который на самом деле в современных
реализациях вовсе не является системным вызовом. Используйте системный вызов под названием
segaction. Чем этот способ плох? Тем, что приходится писать больше букв. То есть кроме номера сигнала вам
нужно еще указать структуру segaction, в которой вы пропишете детально поведение обработки вашего
обработчика сигнал. Как это выглядит на практике? На практике это выглядит тем, что у вас объявляется
некоторая структура segaction, в которой вы прописываете указатель на хендлер, прописываете какие-то
дополнительные флаги SAFLAGS, которые указывают точное поведение вашего процесса.
Давайте более подробно посмотрим на некоторые флаги. Если указать флаг SAResetHand. Да, флаги
это обычные значения, которые через операцию по разрядово или можно объединять. Вот если указать
дополнительно флаг ResetHand, то будет поведение в стиле System5. После обработки вашей функции поведение
будет сброшено на поведение по умолчанию. Если указать флаг NODEFER, то опять же вы получите
поведение System5 системы, и при получении сигнала в тот момент, пока вы выполняете уже какой-то
обработчик, он вас будет рекурсирно вызываться. По умолчанию этого не происходит в стиле BSD.
И важный еще флаг, но правда этот флаг надо явным образом всегда указывать. Если вы не укажете его,
то будет поведение в стиле System5, системные вызовы у вас не будут перезапускаться. Если вы
этот флаг укажете, то системные вызовы будут перезапускаться вместо того, чтобы возвращать
код ошибки. Работать это будет примерно то же самое, но зато такой код является более портируемым,
и плюс вы можете вызывать не просто какие-то простые обработчики, которые могут работать только с
номером сигнала, но и получать некоторую дополнительную информацию используя обработчик
с тремя аргументами, а не с одним. Давайте мы чуть более подробно рассмотрим эту программу.
Итак, у нас есть два разных варианта обработчика сигнала. Точно такой же, как в прошлый раз,
функция, которая просто выводит номер сигнала и ничего не делает. Такой обработчик с одним
аргументом у нас связан с сигналом segue, то есть нажатием клавиш Ctrl-C. Второй обработчик уже
функция с тремя аргументами. Первый аргумент точно также принимает номер сигнала. Второй
аргумент содержит уже информацию о сигнале, в том числе информацию о том, а кто этот сигнал
нам прислал. Третий аргумент, контекст, обычно редко используется. Там можно передавать что-то
произвольное. Так, и для того, чтобы зарегистрировать функцию с тремя аргументами вместо одного,
ну понятно, что обработчик сигнала должен понимать, какую из функций нам нужно использовать.
Для этого используется во флагах дополнительный флаг sasiginfo, чтобы указать, что нужно использовать
другую функцию. Так, навешиваем это на сигнал сектер. Ну и что мы теперь можем наблюдать
при получении сигналов. Если я нажимаю Ctrl-C, ну получаем просто сигнал с номером 2. Если я теперь
найду наш процесс и отправлю сигнал сектерм вместо секинт, то вызываются функции с тремя аргументами,
которые в том числе позволяют выяснить, а кто же нам этот сигнал отправил. То есть,
процесс ID 37039, давайте проверим, правильнее это или нет. Специально окружение, перемена окружения
в баш 2 доллара указывает на номер текущего процесса. Ну и вот процесс баш нам отправил
некоторый сигнал, который мы поймали. Кстати, 37039, так и здесь тоже 37039. Это означает,
что, что можно сказать про команду kill. Это означает, что использовался встроенный вариант
команды kill, а в оси не внешняя программа. Если я наберу полным путем 3, 2, 7, то процесс уже другой.
Почему это произошло понятно или нужно пояснить? Так, тишина. Так, в чем разница между командой
kill и вызовом программы usr bin kill? В некоторых оболочках, например, bash, zsh, некоторые из
стандартных команд реализованы как встроенные функции, а вовсе не запуск внешних программ. Просто
по соображению производительности. Поэтому, когда я пишу команду kill, то используется внутренняя
встроенная функция оболочки. Здесь у меня по-моему zsh. Врать не буду. Да, это zsh. Используется встроенная
функция, поэтому процесс id отправителя сигнала, он совпадает с процесс id этой оболочки. Когда я
запускаю внешнюю программу kill, то создается новый процесс, который выполняет эту программу,
и соответственно процесс, получивший сигнал, он будет иметь уже другой процесс id.
Так, поскольку cgaction требует написания большого количества букв, что мало того, что затратнее по
времени, так еще и делает код менее читабельным. Иногда все-таки хочется использовать более простой
вариант. Это функцию сигнал, которая в реализациях Linux и в macOS является именно функцией,
а не системным вызовом. Есть два единственных случая, когда это можно делать безопасно и когда
это делать осмысленно. Вот есть два константных специальных значения. Это значение 1 и значение 0,
которое можно указывать вместо функции обработчика. Это константа, что сигналы нужно игнорировать,
и константа, что нужно сбросить на дефолтное поведение. И в данном случае, если вы сбрасываете
поведение на дефолтное, то понятно, что никакой обработчик вам не нужен, никакие параметры вам
не нужны. Если сигналы игнорируете, то то же самое. Вам совершенно не важно, как сигналы
обрабатываются. Вы их просто игнорируете. Вчера, кстати, у меня был семинар в 29-й группе. Там был
вопрос, действительно ли осмысленно делать это для SIGIGN. Я это проверил. Действительно
осмысленно, потому что игнорирование сигнала подразумевает, что не будет вызван обработчик,
который сбрасывает на дефолтный обработчик. И поведение в этом случае вполне осмысленное.
Как же эта функция реализована? В фидерфайле проверяется наличие флага default source,
bsd source, либо gnusource. Если они проставлены, то подставляется вызов cgaction с одними
параметрами. Если нет, то вызов с другими параметрами. Имитируется поведение либо
системфай в стиле, либо bsd в стиле. Что может делать наш обработчик сигнала и что нужно при
этом учитывать? Самое главное, о чем нельзя забывать. Сигнал может прилетать в совершенно
рандомный момент времени. И программа может выполнять что-то очень важное, что-то очень критичное.
Что в этот момент происходит? Вам приходит сигнал, переходит управление к обработчику сигнала. А что
у вас будет происходить с основной программой? У вас есть уже какой-то стэк с данными. На самом
деле у вас будет в том же самом стэке все и выполняться. На самом деле можно указать
какой-нибудь альтернативный стэк для обработчиков сигналов. Обычно это используется при реализации
высокоуровневых языков программирования типа Python либо Java. Ну и при этом для современных
процессоров есть еще гарантия по соглашениям вызовов, что есть гарантировано 128 байт на стэке,
которые заведомо никак не будут затронуты обработчиком сигналов. То есть обработчик сигналов
у нас всегда начинается от текущего стэка, но на 128 байт ниже. И еще одним очень важным
ограничением, поскольку у нас обработчик сигналов выполняется в том же самом потоке,
что и основная программа, на самом деле для многопоточной программы в рандомном потоке,
но здесь нужно обязательно использовать только ограниченный набор функций, который называется
AsyncSignalSafe. Как это переводится на русский язык? Я даже не знаю. Итак, что такое безопасность
точки асинхронного использования сигналов? Седьмой раздел MAN. Signal Safety. Перед тем,
как отправлять свои задачи, перед тем, как идти на защиту, перед тем, как идти на контрольную,
читать обязательно. Итак, у нас в функции все делятся на несколько больших классов. Во-первых,
это функции, про которые ничего сказать не можно, потому что они являются просто функциями и никак
не влияют на внешнее окружение. Пример такой функции, например, AscentPrint, StrLen, то есть функции,
которые принимают аргументы и возвращают что-нибудь, при этом ничего никак не затрагивает. Такие
функции можно смело использовать в обработчиках сигнала, потому что ни на что не влияют. И есть
функции, которые влияют на глобальное поведение. Например, если вы как-то модифицируете стандартный
поток вывода, какие-нибудь функции Print, Puts, Putschar, и так далее. И здесь бывают всякие разные
подставы из-за того, что эти функции теоретически могут быть вызваны из разных потоков, ну или в
разные моменты времени, из разных участков кода. Есть функции, для которых не гарантируется
безопасность. Это, например, класс функций, который заканчивается на подчеркивание Unlocked,
которые напрямую взаимодействуют с буфером, работают очень быстро, в отличие от аналогов
без подчеркивания Unlocked. Но при этом нет никаких гарантий, что у вас будет с результатом, если вы,
например, запускаете это в разных потоках. Есть функции, которые являются безопасными с точки
зрения многопоточности, то есть могут быть одновременно параллельно выполняться, и гарантируется,
что будет одинаковый результат. Большинство стандартных функций C для операции водовывода,
они как раз являются MTSafe. Все эти флаги MTSafe, ISafe обычно прописаны в манах для каждых из
функций. Но при этом класс функций MTSafe не является тем же классом, что AsyncSignalFave.
Рассмотрим банальный пример. Вы пытаетесь записать что-то в стандартный поток вывода из основной
программы. В этот момент вы получаете сигнал, который тоже пытается что-то записать на стандартный
поток вывода. Но при этом вы уже вызвали, например, функцию PutChar. Функция PutChar захватила барьер
для того, чтобы предотвратить повреждение данных из другого потока, и поэтому в обработке сигнала
вы тоже останавливаетесь на этом барьере и ждете, пока его кто-то освободит. Что у нас будет происходить,
поскольку учитывая, что у нас основной код не будет выполняться дальше, пока не завершится
обработчик сигнала. Будет deadlock. Поэтому использование большинства функций, которые модифицируют
глобальное состояние из-за обработчиков сигнала запрещено по этой причине. Но зато вы можете смело
использовать системные вызовы, например, системы UsofWrite, которые ничего вам блокировать не будут.
Ну и какие общие паттерны к написанию обработчиков сигнала? Во-первых, если вы можете писать
код с использованием только очень ограниченного количества функций, то понятно, что здесь вам
проще поставить какой-то флаг, зафиксировать сам факт того, что сигнал пришел, и дальше уже этот факт
где-нибудь спокойно обработать. И в теории ваши сигналы могут выполняться очень долго, но так
делать нехорошо, потому что вы блокируете вполне основной программы, и в основной программе у вас
могут быть какие-то критические по времени секции. Например, к вам выявляетесь сервером,
к вам подключился клиент, и вы получаете сигнал, уведомление о том, что нужно что-то сделать,
занимаетесь долго обработкой сигнала. Что будет с клиентом? Клиент не дождется ответа,
по тайм-ауту завершится, так делать нехорошо. Поэтому обычно хорошей практикой является,
что вы максимально быстро обрабатываете сигнал, а содержательную часть по обработке,
то есть вы просто фиксируете факт, что сигнал пришел, а содержательную часть выполняете только уже из
основного кода, когда вам это становится удобно. Что значит проставить какой-то флаг? Это значит,
что у вас есть какая-то переменная либо в глобальной области видимости, либо где-нибудь в аргументах,
в контексте, и какого типа это может быть переменная, чтобы можно было ее безопасно,
гарантированно использовать, поскольку у вас код может выполняться в произвольный момент времени,
когда вы уже начали обращаться к значению. На самом деле, таких типов данных не очень много,
и в стандарте Posix предусмотрено название sigatomic-t. Это тип данных, для которого гарантируется,
что его значение будет всегда консистентным в любой момент времени. То есть не может быть
ситуации, что вы начали модифицировать значение переменной в основном коде, прилетел сигнал и
что-то там повредил. Для большинства современных систем это просто обычный type-def на int, но для
каких-нибудь экзотических встраиваемых применений это может быть тип данных более мелкого размера.
И второй момент, про который не нужно забывать при реализации обработчиков сигнала, то,
что компилятор может посчитать в некоторых ситуациях, что ваш код является бессмысленным,
потому что присылаете значение переменной, нигде не используете. Как с этим бороться? Есть
ключевое слово volatile на имя переменной, которое запрещает компилятору делать какие-то предположения
о том, что эта переменная не нужна, даже если он не видит всей картины в целом. Таким образом,
как может выглядеть правильная обработка сигналов? Правильная обработка сигналов может выглядеть
следующим образом. У вас есть обработчик, который единственное, что делает, это запоминает факт
прихода сигнала. Уже в основной программе вы можете проверять факт наличия этого сигнала и,
в зависимости от того, какой сигнал вы получили либо не получили, выполнять какую-то логику в тот
момент, когда вам это действительно удобно. Где на практике используется обработка сигналов?
Есть стандартные сигналы SIGTERM, но иногда еще обрабатывает сигнал SIGINT. Что можно на них
навешать? Если вы обрабатываете сигнал SIGTERM, то вы должны сохранить текущие данные, чтобы их не
потерять. Если у вас есть общение с каким-то клиентом, то сказать клиенту до свидания,
вежливо попрощаться, перестать принимать остальных клиентов. Многие серверные применения
еще ведут лог-файлы для того, чтобы как-то протоколировать ход своей нормальной либо
ненормальной работы. Естественно, нужно сделать запись в лог и уже только после этого корректно
завершить работу с помощью обычного системного вызова EXIT. Есть еще сигнал SIGHUB, который
означает... Исторически он предназначался в собственном названии SIGHUB, откуда взялось
исторически. Это был разрыв с терминалом, когда компьютеры были большой мейнфреймами, которые
цеплялись с отдельными терминалами. Сейчас это не очень осмысленно, но бывает полезно в той ситуации,
когда вам нужно как-то просигналить процессу, у которого нет пользовательского интерфейса,
он работает фоном. Сейчас фактически формальное такое негласное соглашение, что этот сигнал
используется как указание перечитать свои настройки из конфиг-файлов. SIGCHILD приходит,
если вы запускаете какие-то дочерние процессы, что будет, если вы очень долго работаете и при
этом не вызываете weight pit. У вас накапливаются процессы зомби. Если вы запускаете процессы,
нужно периодически чистить завершенные, и по приходу сигнала SIGCHILD вы можете синхронным
образом просто читать код возврата для того, чтобы эти зомби истреблять. Если вы хотите писать
надежный код, который будет работать 24 на 7, то по-хорошему надо еще обрабатывать все остальные
ошибочные ситуации. Как минимум их надо протоколировать куда-нибудь в log file, что эти
ошибки возникли при каких-то обстоятельствах. Иногда можно, конечно, попробовать восстановить
состояние процесса, ну или хотя бы аккуратно себя перезапустить. Что у нас происходит на низком
уровне при доставке сигналов и какие с этим связаны ограничения. Есть такое понятие как
маска сигналов, ожидающих доставки. То есть у нас есть некоторый набор стандартных сигналов,
их не так много, и можно представить все это множество в виде обычного целого числа,
где отдельные биты отвечают за отдельный сигнал. И когда какой-то процесс отправляет нам
некоторый сигнал, он просто проставляет единичку в эту маску сигналов, ожидающих доставки. Что будет,
если у нас одновременно два каких-то процесса успели отправить сигнал другому процессу,
а этот процесс не успел их обработать. Честно, была проставлена единичка, сколько раз будет
обработчик сигнала обработан? Ровно один раз. Поэтому сигналы не очень хорошо подходят для такого
межпроцессного взаимодействия через системный вызов kill, они предназначены для уведомлений.
Такой атрибут как маска сигналов, ожидающих доставки, он является атрибутом процесса,
который при этом не наследуется при создании нового дочернего процесса через системный
вызов fork. Что логично, если бы этот атрибут наследовался, тогда отправив сигнал к какому-то
процессу, то почему этот сигнал мог бы прийти в новосознанную дочерню, что не очень логично.
Так, ну и как у нас происходит обработка сигналов и почему у нас вся обработка происходит в том же
самом контексте, что и основная программа. Допустим, вы хотите отправить кому-то сигнал,
вы просто выполняете системный вызов kill. Да, есть команда kill, есть системный вызов,
который тоже называется kill. Он просто, как и команда kill, посылает сигнал определенному процессу.
Kill не блокируется до выполнения сигналов, вы просто поставили флаг и продолжаете выполнять
дальше. Что происходит с процессом, которому вы этот kill отправили? Этот процесс тоже ничего про
kill не знает. Он честно продолжает выполнение, пока не израсходит свой квант времени,
который отведен вам планировщикам заданий. Потом уже в следующий раз при выборе этого
процесса планировщикам заданий сначала проверяется маска сигналов, ожидающих доставки.
Если есть какие-то сигналы, то сначала выполняются обработчики сигналов, а после этого процесс
переходит в самое обычное выполнение, с того места, где он был прерыв. И есть еще одна маска,
которая называется просто signals mask. Да, насчет терминологии. Очень часто встречается англоязычная
терминология signal mask. Signal mask это то, что я сейчас вам расскажу, а предыдущая штука,
это называется pending mask. Можно навешивать некоторые фильтры для того, чтобы запрещать
определенные сигналы. И вот эта штука называется как раз маска сигналов, просто некоторая дополнительная
маска из 0 единичек, которая либо разрешает обработку сигналов, либо запрещает. Что будет
происходить, если сигнал у вас запрещен на уровне маски сигналов, но он все-таки пришел. У вас
просто остается храниться единичка либо 0, которая просто не пропускается через эту маску. И в какой
момент вы этот сигнал сможете обработать? Только в тот момент, когда вы поменяете маску сигналов,
перестанете фильтровать этот сигнал, и в этот случай все отложенные сигналы до вас дойдут.
Вот маска сигналов обычная, вместо, в отличие от маски pending сигнала, с которой маска сигналов
ожидающей доставки, она как раз наследуется дочерними процессами, если вы вызываете форк.
Естественно, тут есть два ограничения. Сигнал isekill и isekstop вы не можете никак обработать,
и то же самое вы никак не можете наложить маску сигналов на эти два обязательных
неблокируемых сигнала. Для чего эта маска может быть использована? Например, если вы хотите явным
образом ждать какие-то определенные сигналы, либо вы выполняете какую-то критическую секцию
вашей программы и хотите напрочь забыть про обработку сигналов на какое-то время,
тогда вы можете устанавливать маску сигналов либо для всего процесса целиком,
либо только для текущего потока. Я, конечно, много раз сейчас употребляю слово поток,
многопоточность, мы пока это еще не проходили, но, я думаю, интуитивно вы понимаете, что это такое.
То есть у вас в рамках одного процесса может быть несколько задач, которые выполняются параллельно.
На самом деле, системный вызов, который предназначен был исходно для установки
маски сигналов для текущего процесса, делает это только для текущего потока. Но в Linux есть
еще отдельная функция, которая предназначена только для текущего потока. Она еще аккуратно
обрабатывает ситуацию с двумя специальными сигналами. Про спецсигнал я чуть позже скажу.
И есть еще очень интересный системный вызов, про который в документации написано, что он
временно меняет маску сигналов на какую-то новую, ждет сигнал, а потом возвращает все обратно. Такое
очень сложное описание на самом деле означает просто, что вы передаете какое-то множество сигналов,
которые вам интересны, и процесс приостанавливается до тех пор, пока вы не получите один из сигналов
этого множества. Не более того, не надо пугаться того, что написано в мане. Ну и дубль слайда,
на самом деле маска она размер 64 бита, сигналов не так много. Как можно дождаться, приходит какой-то
сигнал. Ну вот этот сексаспинг как раз и можете использовать, скормить ему множество сигналов,
которые вам интересны, и процесс приостанавливается до тех пор, пока вам не
придет один из сигналов из этого множества. Либо системный вызов пауза, который ждет,
пока не придет какой-нибудь, неважно какой, любой сигнал, который вы можете обработать.
Но естественно при этом у вас должны быть навешаны обработчики сигналов, иначе у вас
процесс просто завершится, и код после паузы не будет иметь никакого смысла. То есть сигналы
можно использовать в качестве некоторого способа синхронного водовывода, если вы их явным
образом дождаетесь. И для этих целей в линукс даже сделали специальную конструкцию сигнала fd,
это штуковина, которая позволяет читать объекты под названием пришедший сигнал. Что это означает?
Это означает, что вы создаете какой-то файловый дискриптор, связываете файл дискриптора с
определенным множеством сигналов, которые вам интересно, и дальше используете обычный
системный вызов read, читая из этого файла дискриптора, и получаете на каждое чтение
информацию о вновь пришедшем сигнале, либо ожидания, пока не придет какой-нибудь сигнал из
этого списка. Использовать такую штуку достаточно опасно, потому что эта штука не портируема,
существует только в линукс. Про FreeBSD, про macOS можно забыть. Можно ли все-таки сигналы
использовать как способ межпроцессного взаимодействия? Есть некоторые стандартные
сигналы, которые называются стандарты POSIX. Это те самые, про которые я вам рассказывал,
связанные с определенными событиями. Там есть два сигнала, на которые не навешано никаких два
специальных, нет никаких двух специальных значений, это сигнал CGU-SR1, CGU-SR2, некоторый резерв,
но тем не менее вы можете только использовать номер сигнала в качестве полезной информации,
не более того. И плюс, как я уже сказал, у сигналов есть одна серьезная подстава, связанная с тем,
что если два процесса одновременно вам отправят один и тот же сигнал, то с высокой степью
вероятности, хотя нет, не очень высокой, потому что такая ситуация, конечно, не очень вероятна,
но тем не менее возможна ситуация, когда вы получите только один сигнал, а не все те,
которые вам были отправлены. Поэтому способ очень ненадежный, и есть некоторое расширение стандарта
POSIX, под названием POSIX Real Time Extensions, который дополняет систему еще дополнительными сигналами с
важным свойством. Во-первых, эти сигналы не теряются, если несколько процессов одновременно
вам их отправляют, а складываются в очередь, которые обрабатываются последовательно ровно в том порядке,
как эти сигналы были отправлены. Это сигналы с номерами, которые начинаются от 32 и заканчиваются
на номере 63. Всего 64 сигнала в современных UNIX-системах. Но при этом нужно их отправлять специальным
образом. То есть есть система вызов Kill, которая отправляет сигнал обычным образом. То есть тут
действует то же самое ограничение, что он просто проставляет бит в маску сигналов, ожидающих доставки.
Если два процесса одновременно делают Kill, то вы сможете зафиксировать только один факт.
И есть еще функция SecQ, это именно функция не системный вызов, которая, точнее во FreeBSD,
это системный вызов в Linux, это функция, которая позволяет как раз отправить сигнал,
но не произвольный сигнал, а только сигнал с номером не менее чем 32, произвольному
процессу таким образом, чтобы он положился в очередь. И при этом вы можете еще дополнительно
отправить полезную информацию, а не только номер сигнала, произвольное число по размеру,
не превышающее размер указателей. Чем этот способ плох? Он все-таки не совсем стандартный,
например в macOS он не реализован. Как можно использовать сигналы в рамках нашей огромной
большой задачи межпроцессное взаимодействие? У сигналов есть куча ограничений, поэтому фактически
единственный способ как их можно использовать корректным образом, это только для уведомления
процесса о чем-нибудь. То есть полезную информацию передавать вы не можете, вы максимум можете
передать номер сигнала. Ну хорошо, у вас есть сигналы реального времени на некоторых системах,
но опять же вы не будете передавать последовательно огромное количество чисел по одному числу за один
раз, потому что это очень дорого. Но если у вас, например, используются сигналы совместно с каким-нибудь
другим механизмом, например ма, разделяемая память, то вот эта комбинация становится уже удобной,
потому что вы можете большие куски данных хранить где-то в общей памяти, доступной сразу
межпроцессом. Возникает естественная проблема синхронизации, нужно как-то уведомлять процессы о том,
что данные готовы. Вот для этих целей сигналы вполне себе можно использовать. На этом у меня все,
да, сервер Рудали сегодня упал, поэтому по старинке тут всего лишь котик,
который означает, что лекция закончилась. Есть ли у вас вопросы?
А если, например, сигналы, которые в очередь складываются, если пошла обработка такого сигнала
и другой пришел, то он сложится в очередь? Да, если это именно сигнал realtime,
который оправлен не через skill, а через secq, тогда да, он просто сложится в очередь и потом будет
обработан. То есть их доставка гарантируется? Их доставка гарантируется. Обычных нет. Более того,
даже сигналы реальных времени не гарантируется доставкой, если вы используете обычный системный
вызов skill. То есть тут надо использовать другую функцию. В macOS просто не используется сигналы
реального времени, там используются другие способы межпроцессного взаимодействия.
Но обычные сигналы есть в любой UNIX-системе. Да, в Windows сигналов нет. Это именно UNIX-штуки.
Еще вопросы? Ну ладно, если вопросов нет, тогда лекция закончилась и вы свободны.
