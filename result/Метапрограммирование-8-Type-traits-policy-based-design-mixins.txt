сегодня мы наконец-то поговорим про дизайн, про чем мы уже упоминали многие вещи, такие дизайн
уровня скорее чем инструментария, но тем не менее сегодняшние темы считаются такой основой более
менее дизайном шаблонов. первым пунктом программу будет следующий код, я думаю ни у кого шока не
вызывает, в принципе это стд попе, только написанное руками. представим, что сейчас у нас стд нет, а также
представим, что мы такие совсем глупые программисты синтаксис плюсов выучили, но стандартную библиотеку
вообще не знаю. ну и вот мы как бы написали свой копия, который раньше итераторов от first до last
вписывает в result и тут выяснилось, что на нашей платформе есть магическая операция bitblast или как
хотите называйте memcopy, которая чиселки умеет копировать гораздо быстрее, чем вот так вот проходясь
циклом. компилятор соответственно мы предполагаем, что глупый, сам не догадается, поэтому нам
надо ему помочь. мы хотим заоптимизировать копии, чтобы если у нас тип лежащий в итераторе, типа
int, чтобы у нас использовалась некая другая функция. ну и если мы все-таки совсем глупые программисты,
то мы вот что-то такое напишем. если int будем использовать волшебный bitblast, иначе цикл как раньше.
ну это можно также на специализациях сделать или перегрузках и прочие-прочие фентифлюшки. но
поинт не в этом. поинт в том, что ну окей, для int это работает, но наверное был же это тоже как
бы типа int. для него тоже наверняка нам нужно использовать эту операцию. и еще для многих типов.
и если их вот так вот все выписывать здесь, то получается крайне некрасиво и неприятно.
какие у вас есть идеи, как избавиться от этой проблемы, вот представляя, что стандартной библиотеки нет.
вроде нам в какой-то момент придется зафиксировать набор типов, которые применимы super speed
bitblast. поэтому нам все равно вот этот список, этот cms, как бы его не убрать идеально. то есть
его можно как-то абстрагировать. да, это правильно, что его идеально не убрать. его не надо идеально
выбирать. но нам нужно его абстрагировать, чтобы нам не приходилось сюда вот вписывать вот эти
вот типы. сделать концепт там или констекс ворбул готовый там, супер спид и плайбл. и соответственно
как мы будем кастомизировать тогда такую штуку? сделать специализацию копии для вот этого?
да, ровно так. более олдовая вещь это сделать класс, внутри которого есть констекс ворбул,
потому что раньше нельзя было специализировать переменные. но суть та же. и что мы по сути сделали?
мы применили технику, которая решает 99 процентов программистских задач, добавление индирекции. то
есть мы не напрямую получаем доступ к данным или какое-то решение принимаем, или действие совершаем,
а через что-то. указатель можно считать индирекцией. вот эту штуку можно считать индирекцией. вот и такие
индирекции, которые используются для принятия решений, основываясь на типах, их называют трейдами.
соответственно код в итоге будет выглядеть вот так, а пользователь в свою очередь может для
произвольного своего типа, если он уверен, что битбласт поддерживает этот тип, сделать специализацию.
вот собственно так, как Александровский определяет, что такое type трейд, это дополнительный уровень
индирекции, выносящий принятие решений из текущего контекста. ну как обычно у нас бывает,
все эти определения плавающие, и что только в этом мире не называют трейдами. так что да,
но тут возникает куча вопросов. вот мы приняли итераторы и решили битбластить, потому что под ними
лежат менты. а последовательный или вообще контейнер, в котором они лежат? вдруг это мапчик,
где хитрое красно-черное дерево, какой тогда битбласт? еще проблема. вдруг у нас разыменование
итератора работает очень по-хитрому, оно не просто возвращает ссылку или указатель на тип,
а какой-то врапер. даже в стандарте есть некоторые враперы над ссылками, которые иногда используются,
ну и здесь тоже. вероятно, есть шанс, что итератор такой хитрый, что он возвращает прокси. а кто знает
итераторы стандартной библиотеки, которые такие прокси возвращают? вектор bool. да, вектор bool. он вместо
того, чтобы возвращать ссылку на bool, возвращает прокси, потому что внутри bool хранятся не как
массив boolof, а как массив int, каждый битик, в котором обозначает bool. ну и какая может быть ссылка
на один бит? ну такая проблема теоретически может быть, и вот код, который здесь у нас был,
он сломается, конечно. мы разыменуем first, берем деколта, там будет какая-то прокси, что-то там. более
того, вдруг у first-to-result разные типы внутри лежат, и мы как бы хотим, чтобы у нас неявное
преобразование происходило. ладно, буду отметывать. в тот момент, когда мы делаем звездочку result,
равнозначность .first, может быть преобразование. тоже проблема. более того, вот эти три проблемы,
они еще понятны, совсем удочка так на будущее. вдруг у нас еще какие-то есть оптимайзы этого
алгоритма, какие-то хитрые способы его сделать более быстро для других типов, для других
других итераторов, для которых тоже придется добавлять новые ифы. ну первые три проблемы
решаются легко, и стандартная библиотека для всего этого имеет соответствующие трейты. да,
помимо трейтов для типов конкретных или для конкретных алгоритмов, бывают трейты для каких-то
общих концепций. вот в стандартной библиотеке есть концепция итератора, и для них есть трейты.
соответственно, у трейта итератора можно спросить последовательные ли это итераторы, то есть
последовательные в памяти лежат объекты, на которые мы указываем. а также можно спросить,
какой тип на самом деле лежит под этим итератором. ну и одинаковые ли значения, соответственно,
через value-type можно узнать. вот, а про то, как справиться с новыми ифами, которые придется
дописывать, это пока непонятно. ну тут может возникнуть идея, о чем нам эти трейты, мы же можем
просто сказать, что пусть каждый итератор, он будет удовлетворять концепт. просто такой концепт есть,
если что. концепт требует, чтобы у него был bool contiguous, чтобы мы могли прямо у типа
спрашивать через статическую переменную в нем, и некоторые type-def или using на value-type. вот
почему это нехорошо? в каком случае это сломается, и почему так не сделано в стандартной библиотеке?
да, сырые указатели тоже считаются итераторами. ну и проблема на самом деле более общая, если у
нас есть сторонняя библиотека, и мы хотим ее подружить с нашим кодом. вот с таким концептом мы
никак не подружим эту библиотеку. нам придется модифицировать то, что... как бы придется
модифицировать класс итератора, добавляя туда все, что мы потребовали в концепте. а вот трейты мы
можем специализировать на конкретные итераторы. даже если итератор лежит в какой-то библиотеке,
нам не доступны. это чем-то напоминает ситуацию с тыганволком с прошлой пары. да, здесь есть
некоторая тонкая связь между тыганволком и трейтами, но я ее не смог прочувствовать. ну и
конечно литературы никакой на эту тему нет. но что-то есть такое общее, видимо общие принципы
дизайна, что хотим расширяемость, ну и прочие вещи, которые на ДП рассказывают на лекциях.
вот, соответственно, да. трейты в стд, итератор трейты. справа, соответственно, две картинки,
что вот есть класс итератора, структура с одним шаблонным параметром, где объявлена куча member
типов. их там побольше, чем мы просто сказали value type. там дополнительно есть difference type,
который говорит разность двух итераторов, чем она является. обычно это size t или какой-нибудь
это патердифтэ скорее. но теоретически это может быть кастомизировано, если вдруг у нас
итераторы на какие-то очень маленькие структурки, маленькие контейнеры, где не больше 255 элементов,
наверное, там одним чариком можно обойтись. соответственно, стандарт позволяет заоптимизировать
в этом месте, но я не встречал года, которые пользуются этой фичей. соответственно, есть и
pointer и reference type. это как раз к вектору углов. скорее всего, референс для итератора по вектору
углов говорит, что здесь референс это не просто ссылка, а вот этот хитрый врайпер. и
есть итератор категории, который говорит, что в целом имеет итератор. ну, я думаю,
все это вы уже видели когда-то давно, но с 20 стандартом все немного поменялось. теперь
есть концепты вместо вот этих просто словесных описаний того, что такое forward итератор,
что такое random access итератор. есть концептики, в которых прямо в коде описано, что это такое,
какие требования предоставляются. то есть у нас есть и концепты, как я показывал только что,
и трейты. они дружат вместе. если мы посмотрим на концепт input итератора снизу, то он определяется
через input-output итератор. input-output совсем простая штука. говорят, что можно разыминовать,
и говорят, что можно прибавлять. ну, не будем уже здесь отвлекли incrementable. понятно, что там
какой-то итератор плюс-плюс. дальше в input итераторе, ну, indirectly readable какой-то,
неважно-неважно, итератор концепт. здесь самое интересное. то есть это, заметьте,
не какой-то типо, просто некоторая штука, которая затем описана словами. вот итератор концепт,
это exposition only alias template. и дальше написано, как он получается. и тут вот сложные алгорели
получается. иter-traits это либо и если нет специализации у iter-traits, то есть вот есть
iter-traits с большими буквами, а есть iter-traits, который шаблоны стандарта, который можно
специализировать пользователем. вот если пользователь его не специализировал, то в качестве
iter-traits мы берем сам тип итератора, иначе вот этот iter-traits специализацию. дальше еще один
слой индирекции. в этом iter-traits мы пытаемся взять тип итератор подчеркивания концепт и вот его
использовать. дальше если есть итератор в категории, то как бы это используется. ну в общем,
правила сложные, давайте не будем их переводить на русский на лету. но в итоге зачем они используются?
проверяют, что iter-concept наследуется от input итератора. то есть идея в чем? по умолчанию
итератор не будет считаться ни input, ни random access, ни каким другим из всех вот этих вот перечисленных.
чтобы попасть в этот концепт, нужно самому сказать, да, я хочу, чтобы я удовлетворял этому концепту.
и благодаря всем этим сложным правилам есть миллион способов, как подписаться на это.
самый простой отнаследует наш класс от input иter-traitor tag. вот этот input иter-traitor tag,
это пустая структурка, ничего в ней нет, ну как обычно теги и работают. просто помечает этот
класс как input иter-traitor. можно в итератор trades, вот этот вот итератор tag поместить в итератор
category. можно еще там хитрым образом указать. ну и все это нужно ровно за тем, чтобы любую библиотеку,
какой бы она злой, плохой, не дружащейся стандартом не была, можно было вкрутить в этот механизм,
в эти trades, указать все необходимые свойства для принятия решений в стандартных алгоритмах и
использовать эти итераторы в стандартных алгоритмах. вот есть pointer trades, вот это уже изотерика
пошла, это то, что обычно никто не знает и не использует. это trades для различных умных указателей,
типа unicpointer, просто звездочки sharepointer. соответственно тут говорят, какой element type,
какой difference type, а также есть шаблон, чтобы заребиндить этот умный указатель с одного типа
на другой. ну почему это нужно? потому что у умных указателей бывает много шаблонных аргументов.
у unicpointer какой второй шаблонный аргумент? делитер. хочется общий механизм, чтобы заменить то,
на что указывает умный указатель. можно как-то это теоретически подкострелять,
но вдруг там вторым шаблонным аргументом указывается тип, который надо использовать в какой-то
билетике. ну вдруг. поэтому вот такой механизм предоставляется. если вам когда-то на первых
курсах тосфистеха затирали про ребинд в локаторах, и было абсолютно непонятно, зачем он нужен. вот я
пришел к выводу, что за тем же, хотя и не увидят. это штука жуткая. вот, ну ладно, chartrace, штука,
которая говорит про разные типы букв или символов, какими свойствами они обладают. ну и вот
эту штуку, кажется, в 23 стандарте будут перепиливать, потому что подъезжает поддержка utf-8. вот если вы
когда-то пытались работать с кодировками в плюсах, вы узнаете какая-то боль со всеми этими v-chart-t,
просто char, там есть еще всякие char32, разные кодировки туда-сюда, сложно, непонятно. ну и вот
стандартные алгоритмы со строками работающие, они вот этот chartrace используют, чтобы некоторые вещи
понять. но пока что многие вещи все еще плохо кастомизируются, так что есть-есть. ну и наконец
локатор трейдс есть, но он совсем скучный. там примерно то же самое, что и в pointer-trade. но такие
трейды вы можете встретить очень много где. мне кажется, в любой и хоть сколько-то крупной библиотеке
плюсовые найдутся такие вот трейды. так вот, это тоже как бы трейды, это точки кастомизации для
свойств тимошей в первую очередь. они хорошо дружат с концептами, вот никто не заставляет использовать
либо одно либо другое, обычных вместе хорошо делать. но тут важно разграничать, что трейды все-таки не
используются для того, чтобы определять поведение в зависимости от типа. вот у нас был тегенболк,
который я надеюсь кто-то понял. вот он был про поведение, а здесь исключительно вот какие-то
свойства. описать и принять решение на основании их в ваших алгоритмах. как-то так. вернемся к этому коду
и что я хотел сказать? хотел сказать, кажется, про ифы новых. про то, что у нас может быть много
разных ифов, хочется как-то это единообразно кастомизировать. да, вообще вся идея полиморфизма,
она обычно начинается с того, что, а вот пусть у нас есть много разных классов или там, как лучше
сказать, да, есть много разных типов и для них нужно разное поведение. мы можем наплодить много
ифов, сделать switch или еще что-нибудь такое, но это будет не расширяемо, нам нужно модифицировать
код неудобно. дальше говорят, вот виртуальные вызовы здорово, но у нас тут все статическое, так что
тоже какое-то решение хочется. конечно, мы уже миллион видели, но вот они такие более техничные,
если там какой-то статический полиморфизм просто прикрутить. хочется что-то более архитектурно
общего, как такие проблемы решать. рассмотрим более сложный алгоритм, чтобы понять, насколько
велика проблема. распределенная сортировка на нескольких потоках или еще чем-то таком. грубо
говоря, параллельно сортируем по порядку некоторый набор значений, а дальше сразу начинается миллион
вопросов, а вот какой набор значений, что это за контейнер, что значит параллельно, то есть на чем мы
запускаем на трэдах, а мы их сами запускаем, новые создаем или чужие используем, а промежуточные
результаты, которые нам неизбежно понадобятся, где их хранить, где память выделять, и хотя бы вообще
что такое порядок на тех типах, которые нам дали. есть такой антагональный набор вопросов про то,
как конкретно этот алгоритм должен работать, и хочется их кастомизировать, и вот инструмент,
который мы будем использовать для этой кастомизации, он должен обладать некоторыми
свойствами. во-первых, эта кастомизация должна быть открытой, чтобы пользователь мог прийти и
свою новую кастомизацию дописать, не модифицируя наш код. во-вторых, должна быть артагональность
этих измерений, по которым мы кастомизируем. не хочется, чтобы один контейнер работал с
вот этими тремя экзекьюторами и только этим локатором, другой только с тем, да, хочется
незаместимости, чтобы любое как угодно устанавливаешь, и все работало, и не приходилось думать, а можно ли
эксплуировать это с этим. и наконец, хочется комбинаторного взрыва избежать, потому что теоретически мы
можем взять и просто для всех комбинаций, которые потенциально нужны в коде, написать по отдельной
специализации нашего алгоритма. но это жесть, да, как только добавляется новый локатор, количество
специализации удовлетворится. мы так не хотим. да, но у нас же был для этого инструмент. из OP такой
паттерн проектирования. кто догадается, о чем речь. это поведенческий паттерн. стратегия.
да, вот как-то так она выглядит. мы в нашем контексте, то бишь в нашем алгоритме заводим
указатели на стратегии, указывающие по интерфейсу, и стратегии соответственно относятся к одной
кастомизации какой-то. то есть в предыдущем примере была бы стратегия запуска, стратегия
локации, стратегия сравнивания и так далее. и этот интерфейс стратегии, он какой-то один, а может
несколько методов предоставляет, и пользователь может наследовать интерфейс и уже конкретные
реализации поставить. вот, простое понятное решение, на джеве все так пишут. но так как у нас
метапробовый плюс C, мы не хотим runtime-полиморфизм, а он почти во всех случаях, да и не нужен толком,
только замедляется зазря. мы хотим статический полиморфизм. соответственно, мы погнали заменять
OP, наш облог. стратегия выполнения сальто, это будет концепт вместо интерфейса. мы требуем,
чтобы у типа T, являющимся somersault strategy был метод статический somersault каких-то данных,
а наш контекст или алгоритм принимает шаблонный параметр этой somersault strategy и в своем алгоритме
используют этот шаблонный параметр. вроде, просто вроде понятно, но можно лучше, можно сделать вот так.
казалось бы, мы ничего не поменяли, следите за руками. раньше мы просто strategy2.2.sommersault
использовали и somersault был статическим. а теперь мы отнаследовались. а, я забыл исправить. теперь мы
отнаследовались и просто запускаем somersault, который должен быть объявлен в родительской
class strategy. он уже может быть на самом деле не статический. давайте это сделаем, чтобы
чтобы не смущать. вот так вот имеется ввиду. и это нам на самом деле приятные плюшки привнесет,
которые мы увидим чуть позже. и вот такие статические стратегии, их собственно называют
policy. это вот тот самый policy based design, который уже неоднократно упоминался. надо перейти к более
сложному примеру, зато такому кандому и традиционному, прямо из Александраевска. в качестве нашего
будет некий widget manager. у него будет необходимость создавать виджеты. почему-то, не задаёмся вопрос
не почему. соответственно, ему нужна стратегия создания виджетов. creation policy. но так как создавать
виджеты, создавать какие-либо другие классы, это вроде как примерно одинаковые идеи,
почему бы не сделать просто общие шаблоны. pop new creator, prototype creator. pop new просто в методе create
вызывает оператор new. в Александраевску ещё указывается malloc creator, который с помощью malloc
выделяет. а prototype creator, соответственно, хранит в себе какой-то прототип и вызывает у него метод
clone. вполне адекватные стратегии или политики создания объектов. а пользователь в свою очередь,
когда делает widget manager, выбирает, что он хочет, какую политику. и вот внизу пример pop new creator
в policy было выбрано. почему может понадобиться прототип? тут легко привязывать. да, скажем,
что у нас есть стиле виджетов. и вот виджет с дефолтным стилем — это прототип, клонируя
который, стиль сохраняется. и соответственно, наш виджет менеджер, засунув prototype creator с
этим конкретным прототипом, стилизованным, мы автоматом будем все виджеты получать стилизованными.
здорово. а не здорово вот что. виджет менеджер уже знает, что он собирается эту стратегию или эту
политику применять только к виджетам и создавать только виджеты. так почему же мы от пользователя
требуем указывать вот этот класс виджет при инстанциации виджет менеджер? неудобно. но мы это
конечно можем исправить. да, мы можем шаблонные аргументы использовать и вот это уже прям полностью
политика по Александровскому. некоторый шаблонный шаблонный параметр, от которого мы наследуемся и
который кастомизирует наше поведение. их может быть много. и даже наследоваться мы в принципе можем
с несколькими, от нескольких инстанциаций, да, то есть creation policy и для виджета и для еще чего-то. но
тут нужно быть осторожными с методами, которые внутри вот этой creation policy содержатся. они будут
по имени конфликтовать. соответственно нам придется уточнять, какой метод create мы сейчас используем.
ну, это деталь. ну, раз уж так сделали, возникает желание концепт написать, что есть некоторая creation
policy. она там должна удовлетворять некоторым требованиям вроде иметь метод create. но загвоздка
тут в двух вещах. первое это концепт на шаблон. то есть не на класс или тип, а на шаблон. template
штука. соответственно, тот синтаксис, который здесь использовал, он на самом деле не работает. мы
сталкиваемся с этим вроде. ну, так вышло. не включили пока. надеюсь, когда-нибудь включат. то есть
в виджет менеджере сейчас нужно писать template++ creation policy от creation policy. в явные requires
и вторая загвоздка вот в чем. а как мы в этом концепте проверим, что у t есть метод? это же шаблон. а у шаблона
может быть много специализаций. что это вообще значит? проверить, что у шаблона есть метод.
вот хотелось бы написать так, t, t, taste create, но t шаблон. это не тип.
первое, что мне, когда я с этой проблемой столкнулся, к голове пришло, это использовать какой-то такой
класс пустышку и через него проверять. но это ломается. это очень быстро ломается, потому что для того
конкретного класса, который мы будем использовать в виджет менеджере, у конкретной политики может
быть специализация. Более того, эта политика может работать только для классов,
конкретному концепту, и этот концепт заранее мы узнать не сможем. До этого пока не дошли,
но вот проблема, я думаю, ясна. Вроде как очень естественно сюда приклести концепты,
но так просто не получается. Да, вернемся к прототипу.
Прототип-крейтер должен в себе хранить объект какой-то, прототип. Откуда мы его возьмем?
Вот когда метод create запускается у прототип-крейтера, откуда он взял этот прототип?
Ну, я думаю, вы уже догадались, что секретов тащим-то тут нет. Просто в prototype-крейтере
можно хранить указатель на этот самый прототип. А так как мы от политик наследуемся, нам ничто не
мешает состояние хранить в этих политиках. Оно как бы подмешается в наш класс. А дальше
политики могут объявить некоторые методы getPrototype, setPrototype, либо конструктор,
что чуть более неудобно в каких-то ситуациях, но неважно. И когда мы инстанцируем widget-менеджер,
эти функции getPrototype или даже create, на самом деле извне можно будет вызывать и кастомизировать.
Да, но вот здесь сразу возникает желание навесить концепт, как обычно. У нашего класса T должен
быть метод clone, возвращающий нам копию. Соответственно, нужно навесить концепт,
что у T есть метод clone по-хорошему. Но тогда вот как раз сломается этот трюк с виднесом.
Мы заранее не можем знать, какие концепты требует конкретная политика для того, чтобы ее можно было
использовать. В общем, сплошные проблемы, поэтому единственное более-менее адекватное решение,
как мне кажется, вот так выглядит. Добавить конкретный класс, с которым мы собираемся инстанцировать и
проверять, что все нормально именно с этим классом. Если постараться, можно даже позволить проверку с
несколькими классами. То есть целый пак принимать, и вот если мы хотим creation policy использовать не
только для виджетов, а еще для чего-то, автоматом, концептом смотреть, что и виджеты нормально
инстанцируются, есть метод create, какие-нибудь button-виджеты, еще-еще-еще.
Да, давайте на этом моменте немного остановимся и посмотрим на время, ну более-менее пока.
Нет ни у кого каких вопросов, пока что все понятно, отлично.
Да, ну тут есть альтернативный подход, в каком-то смысле он менее удобный, в каком-то более, когда-как.
Можно делать шаблоном не саму политику, а метод create. Ну и тут уж надо поработать со всем этим в
конкретном кейсе, чтобы понять, подходит ли такой подход или лучше шаблоном весь класс делать.
Если у нас несколько методов в политике, то наверное все-таки весь класс шаблонным более
удобно, чем каждый метод отдельно шаблонизировать. Дальше есть такой тонкий момент, совсем тонкий
момент, это уже вот совсем красоту навести. Код. Мы сделали конкретный виджет менеджер с конкретной
политикой, создали и так вышло, что нам пришлось куда-то по ссылке или по указателю передать
политику, которая содержалась в этом менеджере. Ну здесь тривиальный пример, да, просто взяли
указатель в ЭМИС, кастили к криэйтору. Ну может быть более сложное что-то, где уже это не отловить,
а потом удалили эту политику по указателю. И это полная фигня, вот вообще непонятно что.
Конечно в адекватной ситуации, в адекватном ходе и в здравом уме никто такого делать не будет,
слишком как-то завуалированно, но это можно запретить, обезопасив себя. Как это запретить?
Перегрузить билеты к спрессу? Сейчас секундочку, вопрос еще.
Ну как бы представим, что мы используем много-много ООП в своем коде, и увлекшийся ООП так вышло,
что мы скастили виджет менеджер к прототайп криэйтору, звездочка, и забыли, что это вообще был виджет менеджер,
ну как к интерфейсу, в ООП такое часто бывает. А потом, но это все попало в юнит ПТР или что-нибудь такое,
и пыталось удалиться по указателю на родителя, на политику. Такое теоретически могло произойти,
и конечно это УБ, почему? Потому что у нас не виртуальный деструктор, и мы не хотим сюда добавлять
какие-то виртуальные деструкторы и динамические полиморфизмы. Вот, в этом проблема. Так, кто что в зуме говорил?
Как это исправить? Я говорил про перегрузку оператора delete и поместить ее как deleted,
но ты уже сказал, в случае при котором, видимо, это не работает. Я услышал про перегрузку оператора delete,
нет, проще, пожалуйста. А второй вариант какой был? Плохо слышно? Андрей, какой второй вариант был?
Я ничего второго не говорил, я просказал, так я, кажется, сломал мою идею. А, окей, да нет, все проще.
Любые методы, они бывают публичные, приватные и защищенные. Что значит?
Так, прошу прощения, надо вырубить эти обещания, а то надоело. Всем кресту на пжнстар.
Так вот, что значит приватный, приватный метод в классе? Можно только из класса выпускать. Публичный
можно отовсюду. А приватный? Ну, protected, да, protected. Да, из себя и из наследников,
но это ровно то, что нам нужно. Если мы сделаем деструктор в политике protected, то вот такой код
будет не комплинироваться, да, потому что мы не можем извне вызвать этот деструктор.
Но при этом в самом widget manager все будет нормально, потому что в наследнике
мы можем деструктор запустить, да. Но вот в приватном деструктор делать смысла нету. Такое
бывает нужно очень-очень редко. Синдалтоны можно так делать, да, еще какие-нибудь совсем
эзотерически извращенные вещи, но это все странно. А вот protected деструктор, это, мне кажется,
идея очень здравая, когда мы не хотим, мы хотим обезопасить себя от того, чтобы какие-то наши
шаблонные кусочки компоненты, которые отнаследованы публично, нельзя было к ним
скастить случайно и куда-то унести. То есть, в принципе, везде, где мы такие трюки делаем с
наследованием от чего-то и не хотим каститься, наследование обязано быть публично. Вот protected
деструктор, мне кажется, хорошо бы дописывать. Да, здесь есть еще плюшка. Посмотрим на этот
код. В WidgetManager добавили метод SwitchPrototype, который берет из CreationPolicy, тестает прототип из
произвольной CreationPolicy. CreationPolicy шаблонный шаблон. Может быть, и не Prototype Creator,
а PopNewCreator. Так вот, мы его достаем, то есть кастим себя к нему, удаляем старый прототип и
устанавливаем новый прототип. Ну, конечно, это код плохой, некрасиво, delete и new, надо Unique,
но книга писалась давно, допустим. Почему это будет работать? В чем трюк?
Почему, если мы подставим WidgetManager PopNewCreator, то все будет работать?
Мы же всю вторую задачу этот факт исследовали. Шаблонные инстанциируются лениво. Те их члены,
которые вы не попросите использовать в рамках конкретной инстанциации, не будут впилены в
эту инстанциацию. Соответственно, если вы инстанцируете WidgetManager с PopNewCreator и не будете
вызывать SwitchPrototype, то этот метод не будет туда вписан, в эту инстанциацию, и все будет работать.
А если вы уже знаете, что у вас WidgetManager с прототипом сидит, работает, то да, вы можете этот SwitchPrototype
спокойно вызвать и все скомпилировать. Таким образом, поведение WidgetManager можно очень круто
расширять в зависимости от того, какие у вас политики. То есть в зависимости от конкретных политик
можно добавлять новые функционалы. И, ну, в современных плюсах мы, конечно, можем дописать
следующие Requires и явно выписать требования, чтобы политика была такой-то или даже удовлетворяла
какому-то свойству. То есть расширяемости предела нет. Хочется решить следующую прикольную задачу.
Сделать UniquePointer, но с политиками. Политики будет две. Первая это политика многопоточности. Что
происходит, если вот конкретно эту одну переменную типа UniquePointer из нескольких потоков модифицируют?
А также политика разыменования, которая будет говорить, что происходит при разыменовании этого
указателя. Есть ли ассерт на то, что он не NullPtr? Полне полезная политика. В дебагсборке можно
впилить ее и таким образом получить везде проверку, что у вас не NullPtr, а если NullPtr,
получить ассерт со stacktrace и прочими пределами, вместо ошибки сегментации или чего-то такого.
Вот, это хочется покодить, но для начала, я думаю, стоит сделать перерыв, чтобы у вас немножко переварилось.
Итак, мы остановились на том, что хотим написать UniquePointer. У него должна быть
политика, кастомизирующая многопоточность и политика, кастомизирующая безопасность или опасность
разыменования. И дальше мы немного подумаем о кастах. Соответственно, давайте сделаем
CodeShare. Я надеюсь, кто-нибудь сейчас покодит.
Итак, давайте, я знаю, кто-нибудь точно хочет написать код. На всяких паблик правил мы сейчас забьем.
Ну, нам единственное, что интересно, это политики. Кто готов написать?
Ну, я сейчас попробую, если у меня не начнет скачиваться.
Ну, пока мы впишем очевидные вещи.
Так сделаем.
А, ну да. Тут, конечно, мало всего написать.
Ну что, у кого-нибудь скачалось, подключилось?
Никто не присоединился, кто-нибудь?
Да, кинул я в чат в этом зуме. Если так сложно, могу вкинуть в телеграмму.
Нет, ладно, не хочу открывать телеграмму. Там что-то понаписали.
Ну что, ни у кого не хочет открываться?
О, что я творю?
Скелет есть. Надо добавить политики.
Давайте даже все сократим. О, я опять не соблюдаю код-стайл.
Как-то так. О чем будет первая политика многопоточности?
Она будет о том, как хранится вот эта-то звездочка и о том, как с ней работать.
А мы пока никак не работаем. Нам кажется, нужен оператор-звездочка.
Да, ну оператор-стрелочка не будем делать.
Так вот, здесь должно быть что-то.
Узовем это мт-полис. Можете строить мт-полис.
И вот в зависимости от этой мт-полис у нас что должно происходить?
Просто указатель должен заменяться на одномик-указатель.
Все операции присвоения и забирания на атомарной аналоге.
Это первый вариант политики. Другой вариант политики это Mutex.
Добавить. Ну, наверное, это не очень хорошо.
Mutex не муваются, и у нас ничего не выйдет. Поэтому давайте через атомик.
Как минимум один человек у нас уже присоединился. Андрей, давай. Дерзай.
Еще раз, полиси многопоточности надо осознать.
Еще раз, это полиси ухранения указателя?
Да, ухранение и доступ к нему.
То есть он хранится как обычный указатель и используются обычные операции доступа.
Или он хранится как атомик и используется атомарная операция.
Еще попробуем.
Возможно, стоит начать с того, чтобы написать политику многопоточную, а потом подбить обычную политику.
А ты хочешь с Mutex?
Он, хотя ладно, да, вспоминая задачу скукса конкарнси, наверное, не стоит.
Да нет, просто Mutex и не муваются. Мы, наверное, хотим отнаследоваться от этой политики.
Я здесь написал класс, но, возможно, тебе шаблон будет удобнее.
Ну и да, у нас тогда UniquePunter не будет муваться, что плохо.
Да, это плохо.
Поэтому я говорю, просто атомик, это уже будет окей опыт, понимание, как оно работает.
Впрочем, атомики тоже не муваются, но мы все равно с этим справимся.
Да и с Mutex тоже можно, на самом деле.
Но у нас не на конкарнсе задача, так что давай как проще.
Атомик, по-моему, проще.
Только давай назовем это AtomicPunterPort.
У нас появляется GetRef.
Мы пока посмотрим, где GetRef будет.
GetRef как минимум вот здесь.
Возможно, еще здесь.
Возможно, тут.
Ну да, но...
Ну, так можно.
Но я бы сказал, что это не очень хорошая идея.
На что стоит обратить внимание, если у нас...
Блин, ну уже на конкарнсе получается задача, к сожалению.
Но вы все конкарнсе проходили и все это знаете, так что нормально.
Я надеюсь, если я хорошо сделаю свою работу.
Когда у нас оператор присваивания происходит, нам что нужно сделать?
Стащить у Адар его указатель.
А там Адар.
Это первое.
А второе, это когда мы удаляем наш pointer.
Вот нам нужно его не просто удалить, а как бы стащить и удалить.
Потому что если мы загрузим, удалим, а потом поменяем, то между вот этими двумя операциями
может кто-то втиснуться.
Приемшем, так сказать.
Ну и все сломается.
Поэтому здесь тоже, на самом деле, хочется exchange.
Чтобы мы разом атомарно заменили на новый pointer, загрузили, удалили.
А потом вот это произошло.
Конечно, все сломаться все равно может.
Мне начинает казаться, что это плохая идея, писать это на атомике.
Вконтакте никогда про спину не было?
Никогда, да.
Просто упражнение выбрать какой-то минимальный набор операций, которые мы хотим.
И только их вынести в политику.
Вот это огромное многообразие операций.
Мне кажется, перебор.
Ой, не так.
Вот здесь тоже.
Следовательно кажется, что фактически единственная операция,
которая нам нужна, это exchange с нашим хранилищем.
Ну, еще загрузка.
Я не знаю, откроется ли у меня сейчас по контролю.
Не открывается.
Ну ладно.
Пока Андрей пишет.
Давайте.
Оператор дилит.
Где же оно?
Нул пробел pointer.
То есть, смотрите, поведение неопределено, если только не указатель это нул pointer или pointer,
перед этим выделенный с помощью оператора new.
Если pointer это no pointer, the allocation function do nothing.
Да, можно не ставить лишние.
За вас их уже поставили в библиотеку.
Так, получается, функции такие.
Вот этот using можно не писать, потому что у нас публичное наследование.
Предоставлять пользователю эти операции мы не хотим.
Вот этот using, он позволяет тем, кто использует наш уник ptr, получать доступ к вот этим вот функциям getptr, exchangeptr.
А, тебе это нужно, чтобы вот так работали.
Да, закономерно.
Мне казалось, что оно должно работать и без этого.
Ну ладно, если так, то всяко.
А, ну конечно, оно не работает вот так. Мы же об этом говорили.
Да, вопрос. Почему, если вот эту строчку убрать, оно не компилируется?
Вот это мы делаем, и нам говорят, а я и не знаю, не могу найти.
Как бы все связано.
Вот это гадость.
Это dependent base.
А вот это не dependent expression.
Поэтому при двухвазном локапе у нас при парсинге шаблона пытается найти имя для вот этого exchangeptr.
И не находит. Потому что в dependent base ходить нельзя.
А вот если мы эту штуку тоже сделаем dependent, то она должна работать.
Ну что значит нет? Ну в смысле?
Вот, все нормально.
Вот, соответственно, мы можем сделать вот так и не делать этот using.
А можем не делать.
И соответственно, здесь можно сделать вот так.
Вот. Внезапно понимание двухвазного локапа все-таки в жизни бывает нужно.
Вот. Ну как-то так. То есть интерфейс политики получился минимальный.
Тут ничего сложного.
Я не скажу, что вот так нужно писать uniqueptr, потому что вот здесь мы получим взрыв, если у нас конкурируют два присвоения лабешета.
Проблема, в общем, сплошная.
Вообще странно, что такое конкурируют два присвоения?
Если у нас два присвоения конкурируют, то это можно дописать, чтобы оно работало.
Даже более-менее локфри, но давайте не будем.
Ну, смотри, два оператора присвоения запустились на разных потоках.
Оба удалили. Только одному удалось. С этим все хорошо.
А потом оба у двух других агеров забрали их pointer и попытались вшибнуть вот сюда.
И как бы это...
Все плохо. Да, еще вот здесь тоже нужно наш Exchange использовать.
Как-то так.
Ну, да.
О, да нет, это можно добить.
Кажется, вот так это будет работать.
Даже вот так можно сделать. Написали локфри на коленке.
То есть что вот эта строчка значит? Мы поменяли у другого на nullptr его указатель.
И сейчас вот этот указатель, который у другого был, он у нас в воздухе находится.
А дальше мы присваиваем его себе, а свой старый удаляем.
И если две вот таких операции присвоения себе конкурируют, то та из них, что произошла позже,
она удалит то, что та, которая раньше присвоила, и все будет чики-пуки.
Ну, то есть ладно, это все concurrency, но point в том, что вот как-то так можно писать политики.
Давайте даже чуть сократим код, чтобы было больше места на экране.
Окей.
Так, что?
Все хорошо. Следующая политика, которую мы хотим, это политика разыминования.
А что это значит? Это значит, что вот здесь вот мы хотим делать вот так, делать некоторый check.
А как check работает? Определяет вот это вот как раз политика.
Что там может быть? Там может быть assert, там может быть исключение, там может быть свой кастомный классный пользовательский механизм assert.
Такие, если вы не знали, есть почти в каждом проекте.
Особенно во всяких игровых движках очень любят писать свои хитрые системы assertion,
обмазанные репортами на сервер, сборкой дампов, прочим-прочим.
Вот. Посмотрим, что Андрей напишет. Ну, кажется, тут очевидно, что написать.
Если есть check, надо делать check.
Заметим, что вот даже сейчас, когда мы вот этот check не реализовали, нам красным не подсвечивает слайд.
Почему? Почему вот такую штуку он подсвечивал красным, а вот такую не подсвечивает?
Ну, вернее, вот тут было без this, он подсвечивал красным, а вот здесь не подсвечивает.
Да, что MyPTR? Зависимый. Да, MyPTR, он зависит от...
Вот он определен как тип возвращаемый из стрелка GetPTR, его тип, скорее всего...
А непонятно, какой на самом деле. В общем, зависимый, 100%.
В таких случаях, мне кажется, двухфазный лукап тоже сдается, даже несмотря...
Что там дальше в цепочке? Определение?
Ну, что сеосерты мне нравятся?
В ассертах нельзя писать сообщения, это же сишная ассерта.
Вот, ну как-то так. Соответственно, вновь сократим код, чтобы было весь видно.
На демонстрации мы можем сделать ExceptionInDirectionPolicy и сюда написать...
Сив не ПТР.
Как джайв?
Класс. Да, Андрей, ты не слушал. Здесь можно не писать this, потому что MyPTR уже зависимый.
Это вот здесь нам необходимо было написать this, потому что NoPTR независимое выражение, а значит и весь вызов функций независимых.
Более того, вот здесь, мне кажется, this не обязательно писать. Да, Витя? Да.
Потому что Adr зависимый. Его тип это injectedName класса, а injectedName зависимый.
То есть этот стрелочка нужен фактически только вот здесь и вот здесь.
Окей, а теперь внимание, вопрос.
Если мы хотим написать... Вот самый важный point, собственно, сейчас идет.
Если мы хотим написать... Давайте вот это скопируем.
Сделаем вот так.
Это уберем.
Цифра два.
UniquePointer от UniquePointer.
AdrPolicy2, DirectionPolicy2.
Вот так.
Вопрос. Всегда ли этот каст должен срабатывать? Казалось бы.
Наверное, нам хочется уметь кастить.
Про MTPolicy это вопрос, конечно, отдельный, над которым надо подумать.
Но с IndirectionPolicy нам бы точно хотелось его менять.
Взяли и запихнули в другой pointer с другим IndirectionPolicy.
Ну, оператор был, можно написать.
Вопрос в следующем.
Вот если мы кастим CheckedPointer к Unchecked, то есть тот, у которого мастер-то кидается,
кастим, который unsafe.
Это, наверное, всегда должен работать.
Нам не важно.
Но как бы обратная операция, она, возможно, работать не должна.
То бишь, что это значит?
Если у вот этого pointer-а политика unsafe, а у нас safe, мы такой каст хотим запретить.
Предположим, это обозначено у бизнес-требования.
Конечно, тут тоже можно рассуждать, хотим или не хотим.
Вот хотим.
Давайте придумаем, как это сделать.
То есть еще раз запишем.
Если IndirectionPolicy2 у нас unsafe,
а IndirectionPolicySafe запретить.
Как сделать?
Тут есть простой вариант.
Нет, мы вообще хотим запретить инстанциацию вот этого, вот этого.
Чтобы казалось, что нет в текущей инстанциации UncheckedPointer с IndirectionPolicySafe
вот такого оператора для IndirectionPolicy2 unsafe.
Да, мы это можем сделать просто через реклапс в наших современных плюсах.
Ну да, но в старых плюсах это делалось по-другому.
Есть смешной трюк.
Который как бы даже лучше будет работать, чем вот эти вот requires.
Но почему опять requires плохо на самом деле?
Ну тут можно написать длинное логическое выражение.
Ну что, мне точно в CompileTime только будет работать.
Мы хотим не в рентайме, мы хотим именно в CompileTime, как будто requires выпилили.
Но вот если вот здесь руками вписать вот это сравнение, что это равно это, это равно это,
это будет плохо, потому что пользователь как бы нашей библиотеки, он может свой...
Трейты что ли?
Можно трейты, а можно проще.
Мы можем сказать, что собственно сами наши политики являются для себя трейтами.
Вряд ли возникнет такая ситуация, что какая-то совсем сторонняя библиотека
предоставляет политику, но при этом она не удовлетворяет каким-то дополнительным
нашим требованием, например, иметь констэкспорт булл какой-то.
То есть вот такие требования, что у каждой политики indirection должен быть булл
или какой-то юзинг или еще что-то, это нормально.
Мы и так уже требуем, чтобы были какие-то методы.
И дополнительно накручивать трейты нужды нет.
Это не даст нам дополнительной расширенности по сравнению с тем, что есть.
Соответственно нам как-то нужно спросить эти политики indirection, умеют ли они каститься друг к другу.
Давайте ровно так это и запишем.
Мы скажем...
Так, что мы еще раз таким?
Мы хотим, чтобы unsafe кастился ко всем...
Нет, наоборот.
Чтобы все safe кастились к unsafe.
То бишь, мы можем сделать оператор unsafe indirection policy.
Причем хочется его, что ты рекомендуешь.
А мы пометим explicit false.
А, я оператор...
Вот ClangD странно работает.
Я явно написал explicit false, он все равно советует implicit.
Ладно, так вот.
Сделали так, чтобы assert кастился к unsafe.
А теперь вот здесь...
Вот в этом вот операторе.
Можем написать следующее.
Да?
Кажется, вот так все-таки надо.
Вот.
То есть мы прям взяли из кастинга.
Вернее, явно потребовали, чтобы наш indirection policy конструировался от indirection policy другого.
Точно так же мы можем потребовать для mt-policy на самом деле.
Коди, а зачем ты написал explicit false?
Чего?
А зачем ты написал explicit false к оператору?
Кажется, оно вот в таком случае не сможет, если я напишу просто explicit.
Возможно, сможет.
Сейчас, погоди-ка.
Запустим и потестим, так сказать.
Да, это будет pointer на int.
Это будет unsafe indirection policy.
Что у тебя не так?
Здесь все-таки explicit.
Напишем.
Таки почему?
Все нормально.
Странно, почему оно через равно не делается.
Ну ладно.
И сделаем...
Вот ты конструктор explicit объявил.
Я только сейчас это сделал.
Ну ладно.
Search.
И попытаемся сконструировать P2 от std move P1.
Скомпилируется ли это?
Не скомпилируется.
Вопрос скомпилируется ли наоборот?
Вот так, а здесь…
Тоже не скомпилируется.
Рома, там был прикол, ты написал в пигурной искусстве?
И что там?
Рома, там прикол был, ты написал фигурные скобки, а так как это в полисе было агрегатом,
то это он как агрегат в индициализации пытался сделать. В индициализации с плюс,
мое любимое занятие. Я, если честно, всегда просто иду по порядку от фигурных круглым скобкам,
и чем первая срабатывала, то использовала. Да, а что ему не нравится? Мне кажется,
все-таки нам нужно убрать вот этот explicit. Да?
Кажется, я фигню написал, да? Подожди, да, полную фигню написал. Здесь мы такую же мт-полисе
просим. Полисе проблема. А, да, подожди, да, полисе последний идет. Я перестал,
потому что interaction нужнее будет. Чуть из сада и долька.
Ну, тут, конечно, большой вопрос, как это написать. Ну ладно, нас интересует не это.
Чек валидите. Ага, я был неправ, оно не считается зависимо. Странно. Ну, мы, конечно, можем сделать так,
чтобы оно считалось зависимо. Странно, странно, странно. Ну ладно. Окей, так компилируется.
Пробуем наоборот. Там просто оно было зависимо в имени, оно зависело от параметра шаблона,
а не от базы в каком-то виде. Наверное, поэтому, в общем, он не зависит от шаблонного класса или его базы,
поэтому он сразу пытался его как-то сделать. Но это не точно. Ну вот, мы добились успеха.
Погоди, кажется, там меня что-то сломал. Ты ничего не ломал, это я сейчас сломал в мейне,
сейчас я пытаюсь скастить к ascertained direction, и оно не кастится. А если поставить наоборот и
безопасно кастить к небезопасному, оно скастится. Ну и, конечно, мы можем пойти и сделать это не вот
такими хаками теперь, как в старых добрых плюсах 98, ну и в один стор и вообще давно, а сделать
вот такую фигню. Да, только нам придется это дописать где? Кажется, что вот здесь.
Да, а на томик иникполисе все равно надо нецелизовывать.
Так, все, теперь нету хаков.
Все еще работает. Да, и нам написали, что неудовлетворен constraint. Соответственно,
люди, которые пишут политики, какие-то новые свои, они могут вот так помечать их, что их можно
кастить к той или другой политике, и таким образом можно обеспечить кастомизацию кастов,
классов с разными хитрыми политиками. Так, окей, на этом упражнение заканчивается,
я надеюсь, мы что-то полезное вынесли, и мы возвращаемся к презентации. Возвращаемся мы к
ПБД в дикой природе. ПБД – сокращение policy based design, то есть дизайн-библиотека на основе
политика. Одно из них, те из вас, кто в детстве увлекался олимпудками, должны знать вот это вот.
Кому-нибудь говорит, да, вот такой хак, о котором очень немногие знали, он очень сильно помогает
писать всякие код форсусы, олимпиады и прочее. Это такое расширение стандартной библиотеки плюсов
от ГЦЦ, в котором есть куча разных деревьев и других крутых структур данных с очень сильной
кастомизацией, то есть там красно-черный, сплайн деревьев и прочие. Оно все есть, и оно
кастомизируется очень хорошо, как раз за счет политика. То есть давайте, так, наверное лучше я сделаю вот так.
Вот, конфигурация стинг-контейнеров, то есть контейнеры в ПБДС параметризуются политиками.
В принципе, в Эстейле тоже есть политики, например, локат, как и здесь, но тут их больше. Вот
некоторая политика хэширования, некоторый предикат. Еще какая-то политика хэширования хэшей, видимо.
Политика увеличения размера хэштаблицы. Я думаю, многие из вас слышали, что несмотря на то, что
стандартные контейнеры обычно при заполнении наполовину удваивают свой размер. Ну, в смысле вектор,
когда полностью заполнен, удваивает размер. Хэштаблица на какой-то половине берет и удваивает. Вот это вроде как
не во всех случаях оптимально, и под разные задачи вот этот коэффициент, когда мы расширяем контейнеры,
можно подкручивать, таким образом выжимать производительность. Вот здесь все это реализовываю.
Соответственно, Traits, конечно, у них тут тоже есть стандартная библиотека все-таки.
Да, стратегия политика сравнивания. И вот еще один интересный тип политик, это, собственно,
просто пэй. Когда какая-то структура может быть реализована конечным числом способов,
ну, там какая-нибудь стд-мап или стд-сайт, там вариантов не очень много. Красно-черное дерево,
сплайн дерево, какой-нибудь овель, но так никто не пишет. Ты хотел сказать сплей? Сплей, да, сплей.
В общем, да, их там по пальцам можно пересчитать, эти деревья, которые подходят под требования
стандарта. Поэтому там просто есть тэг, которым выбирают, а какое дерево использовать. Если мы
сейчас вверх поднимемся и посмотрим на деревянные структуры, то вот, собственно, тут тоже некоторые
политики сравнения, и вот тэг. Тэги есть вот всего три, rb, splay и ov. Я не знаю, что это, кстати.
Ордер 2. Да, дальше есть какие-то хитрые политики для поддержания вариантов дерева. Это вот какая-то
дополнительная кастомизация, которую некоторые олимпиадные волшебники умеют использовать,
но мне не сложилось, я не научился. Но, говорят, с помощью этих вещей можно просто в пух и прах
рвать многие задачи. Я абсолютно не знаю алгоритмов. Там есть самая популярная политика, это порядковая
статистика. Да, вот порядковую статистику, через вот эту вот штучку, ее можно сюда вставить и
научиться легко считать порядковой статистики во многих деревьях. Собственно, они даже об этом
здесь пишут, по-моему. Да, естественно, для порядковых статистик нужна некоторая методата в рамках
вершинок и еще что-то там. Эту методату нужно обновлять как вариант поддержки. Вот они все это
позволяют делать. Так что вот, как бы в ГЦЦ стандартная библиотека реализована через полисы
из дизайна. Ну, собственно, локаторы во всех структурах стандартной библиотеки – это политики.
А дальше есть смешная библиотечка, которую мне на Reddit посоветовали, и я просто в шоке от нее.
Эта библиотечка содержит вообще все, что нам в этой жизни интересно. Там и динамические поливарфизмы,
там руками написаны, там и трейты, там и политики, там еще куча всего интересного. Но сейчас только
про политики. Вот эта библиотечка – она про систему эвентов. Здесь некоторые классы
Эвент-диспатчера, им можно добавлять лиснеры на некоторые эвенты, а дальше говорить – произошел
эвент с вот таким пейлоудом. И оно всех лиснеров оповестит, что вот эвент произошел, а ты его ждал.
Но понт в том, что здесь миллион кастомизаций есть. В частности, вот этот эвент-диспатчер принимает
на вход политики эвентов. И первое, что в этих политиках кастомизируется – это то, на основании
чего идет диспетчеризация эвентов. То есть, как бы, эвенты – это произвольные титы здесь. Вот мы
прям маэвент определили. И вопрос – как хранить эти эвенты? Как понимать, к какому лиснеру какой
эвент прилетает? И в этой политике прописано, что есть некоторый Инт, с помощью которого
идентифицируются и диспетчеризуются эти эвенты. И в данном случае он получается через E.type. Дальше
лиснеры говорят, какой идентификатор они слушают, а в диспатче мы просто кладем
эвент. И дальше сам механизм диспатчера по вот этому вот Инту.type через политику
проходит и понимает, какие колбэки вызывать. Но там еще не все, конечно. Там политик очень много.
Политика многопоточность есть. Давайте по порядку. Есть некоторая функция, которую в политике можно
положить, которая контролирует, можно ли продолжать диспетчеризацию. Видимо, речь о том, что в списке
колбэков можно остановиться на каком-то из них и сказать «все, дальше не иду», то есть как бы
отменить события. Такие системы колбэков тоже бывают. Есть миксины, просто типы, которые используются
для колбэков. По умолчанию STD-фанкшн можете кастомизировать. Политика трейдинга. Какой тип использовать как
мютекс, какой тип использовать как атомик, какой как кондвар. Если вы хорошо помните курс конкарнси и
помните, что есть такое понятие, как асинхронный мютекс для файберов, то становится понятно, зачем
такая кастомизация нужна. Казалось бы, есть STD-мютекс, что еще нужно? Максимум спинлог. А вот как бы
нет. Если у вас какая-нибудь система на крутинах, файберах или прочих интересных вещах, особенно
праприетарных, то у вас, скорее всего, есть какой-то свой кастомный и синхронный мютекс, который сюда
можно указать. Ну и своя кастомная и синхронная кондвар. Наверное, стоит на этом остановиться,
потому что к этой штуке мы еще вернемся. Она уж очень-очень интересная и очень сладенькая.
Еще одна библиотека, которую нашел некоторая библиотека для парсинга JSON.
Вот здесь некоторые политики парсера. И вот опять эти checked and checked.
Типа проверять валидный или JSON. Валидация JSON операция не быстрая. Если мы уверены,
что у нас JSON нормальный, то есть если мы, например, какие-то конфиги к игре сделали,
и при дебаге эти конфиги могут быть битые, кто-то их редачит, меняет, что-то делает,
нам хочется чекать все-таки валидность, если что, кидать нормальную ошибку, а не крашиться. А вот
как только мы игру доделали и все запекли, и эти конфиги вшили в экзешник, эти чеки можно отключить,
все. Конфиги парсятся, все хорошо. Зачем тратить время на эти чеки? Берем, меняем политику,
типа if-release, if-deaf-and-debug, политика такая, иначе сякая. Вот, соответственно, тут какие-то
политики, пропуска, комментариев, еще что-то такое. В общем, это много где внезапно так
смотришь, смотришь, и внезапно приходит в голову, что да, здесь можно сделать вот на этот
вопрос политика, не просто костылять if-re, а структурировано сделать. Вот, ну давайте
к последнему пункту программы, это уже вандерборд, а не Александреско теперь, или стоит перерыв
сделать раз в час. Мне кажется, это хорошая идея. Пятиминутный перерыв, отдохнуть голосом и телом.
Так, а вот так. Значит, да, тогда пять минут, семь десять, девятнадцать десять, возвращаемся.
Значит, точка и полигон, который, ну, вектор точек, ну понятно. Ну, без контекста непонятно,
к чему это все относится. Давайте считать, что мы пишем такое приложение для инженеров,
которые эти точки рисуют, какие-то чертежи, графики, вот что-то вот такое из этого плана.
Так проще замотивировать то, что дальше будет происходить. И как инженером нам может понадобиться
расширять некоторым образом вот этот функционал точек. То есть, вероятно, хочется иметь возможность
точкам добавить какие-нибудь метки или цвет, или еще что-нибудь такое. И вот сейчас вот эта пара
классов, она вообще никак не расширяется. Кроме как саму точку внести новые поля, мы ничего не
можем сделать. Отнаследоваться от точки, ну, отнаследовались и к чему. А вектор-то хранить
поинты, а не наследников. И ООП использовать тоже невероятно, потому что чертеж может содержать
миллионы этих точек со всеми этими indirection мы просто офигеем все это отрисовывать и хранить.
Плохо. Конечно, шаблоды спасают. Шаблонизировали — отлично. Теперь мы можем отнаследоваться и
добавить некоторые лейблы. Вот проблема. Тут опять нужно смотреть, что point пишем мы, а labeled point
пишет какой-то пользователь нашей библиотеки. И вот если мы в point решим поменять конструкторы как-то.
Ну, вот так вышло просто, что теперь конструктор не просто double off, но еще какого-то була,
который определяет абсолютные координаты или относительные там курсоры или еще что-нибудь
такого. Ну, мало ли чего может быть. Окей, добавили новый булл в конструктор point от двух даблов.
Теперь нужно сходить в label point и обновить там конструктор. Если у нас более сложная система
и таких расширений точек много, то это просто беда. Нам придется сходить по всей кодбазе
и обновлять эти конструкторы. Неудобно. Надо как-то сделать, чтобы можно было добавлять какие-то
новые данные и операции с ними, при этом не страдая, когда базовый класс поменяется,
когда точка как-то изменится сама по себе. Как это можно сделать? Тут на мысли должно наткнуть
следующее. Вот если у point мы конструктор меняем, то придется все менять. У родителя поменяли,
в детях приходится менять. Вот если мы у ребенка поменяем конструктор, у родителя конструктора
менять не надо. Родители ничего не знают про своих детей. Может как-то можно сделать,
чтобы label point был родителем point, а не ребенком. Но ровно так мы и сделаем. Называется эта
технология mixin. От слова подмешивать. То есть мы подмешиваем некоторые набор данных и функционала,
вот last point compile time. Это могут быть лейблы, это могут быть цвета, еще что угодно. Их может быть
сколько угодно. И пример mixin это вот просто label структурка ничего необычного. И после этого
появляется публичное поле label. Техника вроде как очень простая, такая прикольная. Но вот где
ее использовать? Этот вопрос конечно очень большой. Я бы не советовал ее тыкать не подумав 10 раз,
даже не дважды, а 10 раз. В чем фундаментальное отличие от policy?
Policy обычно это политика делания чего-то. То есть point в том, что тебе внутри класса нужно уметь
делать что-то. Нужна какая-то стратегия или политика того, как это делать. Policy это вот про это.
А mixin это просто про то, чтобы расширить функционал. Накидать еще полей, накидать еще методов.
Вот только про это. Policy это про настройку какой-то generic вещи, а mixin это про внедрение
абсолютно новой течи. То есть тут в принципе и trade, и policy, и mixin очень похожи, но нужно
чувствовать вот эту тонкую грань, что трейты это в первую очередь про выбор, про свойство,
описание. Policy это в первую очередь про то, как делать какое-то действие. Вот статически в
compile-time кастомизировать то, как делается какое-то действие. А mixin это про произвольным
образом расширить класс, но при этом не страдает проблем с наследованием. Потому что если у нас много
измерений, по которым можно кастомизировать, label, цвет, форма, звездочки, точки или квадратика,
это независимые измерения. Если мы будем наследование делать, то получим комбинаторный
взрыв и умрем. Придется делать бриджи, выносить вот эти вот указатели, indirection, ну как на TP делали,
медленно, неудобно. Шаблоны абсолютно бесплатно позволяют это сделать с mixin. И mixins бывают
с rtp-шными, никто не мешает. Это позволит больше информации иметь в самом mixin о том, куда его
подмешивают. Мало ли, что он хочет делать с этой информацией. Клоун был в каком-то смысле,
ну, помните, мы писали для прототипа через с rtp штуку. Это тоже в каком-то смысле можно как mixin
понимать, скорее всего. Наверное, ничто не мешает, если у нас произвольный класс, который умеет mixin
делать, туда закинуть mixin прототипа. Да, но более подробных примеров не будет.
Еще один трюк, который шокирует просто. Что можно сделать с mixin? Следите за руками.
Base – некий класс с операцией foo. И у него есть mixins. Derived наследует base, и mixins просто
прокидывают. И у него тоже есть foo. Теперь есть два mixins. Node-virtual ничего не делает. И mixin-virtual,
который объявляет void foo как виртуальную функцию. И теперь в инстанциациях derived, в зависимости от того,
какой mixin мы положили, virtual или non-virtual, функция foo будет либо виртуальной, либо не виртуальной.
То есть такая conditional виртуальность. Как вот noexcept есть conditional, вот была. Explicit есть
conditional. Вот virtual ключевого слова conditional нет, но мы его можем устроить таким образом. Я не
уверен, насколько это полезно на практике, но тот факт, что так можно, это мне кажется очень здорово.
Да, и, собственно, основным примером, где эти mixins юзаются и объюзятся, опять же, вот этот
event-cpp. Это какая-то дикая библиотека, потому что я на нее наткнулся, и она покрывает весь материал
сегодняшней лекции. Это прям очень здорово. Еще и предыдущие некоторые захватывают. Они здесь
рассказывают следующее, что вот у нас есть event-dispatcher и есть event-dispatcher-base. И то и другое
шаблоны. Там все обмазано этими шаблонами, политиками. Но пункт в том, что если мы откроем список того,
что можно в политике засунуть, то тут, помимо всего, есть вот такая политика mixins. В отличие
от нас, когда мы вот несколько разных политик делали разными классами, они все свои политики
по разным вопросам засовывают в одну структурку или класс policies. И вот среди этих политик есть
политика mixins. Mixins тоже как политику можно понимать. И это type list внезапно, тоже тема
покрывается. Но type list необычный. Давайте, наверное, все-таки откроем. Вот, mixing list это необычный
type list, а template list. То есть там хранятся не типа шаблоны. Mixins, CRTP-шные, это удобно.
Но пункт даже не в том, что они CRTP-шные, эти mixins. Пункт в том, как они эти mixins подмешивают. Они
их не коризонтально наследуют, то есть не event-dispatcher наследует все mixins. Это такая скатер-ерархия,
которая у нас была, когда factory делали. Они делают линейную иерархию. Внимание, еще и тема генерации
иерархии покрывается. Они используют то, что у mixins есть шаблонный параметр. Вернее, не так. Они
требуют от mixins, чтобы он наследовался от своего шаблонного параметра. И за счет этого генерируют
иерархию, где самый ребенок это event-dispatcher, его наследник это первый mixin, его наследник
второй mixin и так далее до event-dispatcher-base. Вот так вот. Соответственно получается просто муть.
Вот то, как должен mixin выглядеть. И в итоге это позволяет вообще все что угодно делать. Если
в dispatcher-base есть некоторые виртуальные функции, в mixin мы их можем перегрузить. Если там какие-то
невиртуальные штуки или какие-то поля даже, мы их можем зашедовать. Это просто магия. Правда,
кажется, они здесь особо не приводят примеров адекватного использования mixins. Но зато...
А, нет. Вот, mixin-фильтры есть некоторые. По-моему, это единственный mixin,
который у них по умолчанию включен. Только я так не разобрался, что он делает, правда. Mixin-фильтр.
Вот, у них есть еще некоторая возможность по цепочке mixin принимать какие-то решения
при диспетчеризации. А также фильтровать ивенты и говорить, что вот этим колбэком они не подходят.
То есть, насколько я понимаю, они позволяют вообще любую систему диспетчеризации рандаймовой
сконфигурировать на шаблонах. Да, вот то, что мы раньше смотрели, там тупо понимали какой колбэк.
Но вроде как тут можно вообще что угодно придумать. Любые фильтры, любой выбор. И
почитать код этой библиотеки я рекомендую. Я начал, но все, дочитать не успел. Но то,
что я успел, уже как бы вызывает уважение к человеку, который это написал. Уж очень классно.
Вот, на этом, кажется, все. Если у кого-то есть какие-то вопросы, давайте их обсудим.
В первую очередь, по домашку. По третьей домашке подошел Deadline. Ее решила мало человек.
Явно какие-то трудности. Возможно, вам нужна помощь. Мы можем это обсудить.
Или у вас просто не было времени. Или уже все из зума убежали и не слушают.
Нет, ну окей, тут есть всего два человека, которые не решили. Но, видимо,
что это такое? Почему люди левают? Это было Citro, ладно. Я не знаю,
если вообще смысл тогда разбор в домашке делать. Под запися его не хочу делать. Запися все-таки
на YouTube. А если никого нету, ну вернее, из тех, кто есть, почти все решили, то какой смысл?
А вот один из вас не решил, я забыл, кто. Ты не решил, потому что не успел или? То есть,
пока еще не пытался даже. Не потому что сложно, непонятно. А, третье легче, чем второе гораздо.
Да, это я в чатике вроде уже писал, а может и не писал. По третьей домашке куда проще второй.
Внезапно. За второй я, наверное, приниму баллы. Все-таки я никак не могу решиться делать это или нет.
Но посмотрим. А еще хочу с таким вопросом обратиться к тем, кто еще остался. А не хотели
ли бы вы поделать докладики и порассказать что-нибудь прикольное? А, например, есть Густ Хана. Это такая
библиотека, которая проповедует очень хитрую идеологию того, как нужно заниматься метапрограммированием.
Они... Ну ладно, даже в двух словах это не рассказать. В общем, это целый такой отдельный стиль того,
как писать метакод и метафункции, любые там подчисления со списком типов и прочими вещами.
Было бы интересно, если бы кто-нибудь про это готовил доклад, рассказал. За это, конечно,
уже будут баллы. Вот. Можно еще какие-то темы придумать. Вот если у вас есть желание что-нибудь
разводить и поднять за это баллов, возможно, упущенных на домашко, то такая возможность есть.
А когда угодно. Ну, то есть, доклад не должно быть три часа, как я тут вещаю. Это должно быть
что-нибудь типа полчасика рассказать. Вот. У нас просто осталось еще материала на лекции три. Я вот
не знаю. Даже меньше, наверное. Две-три, наверное. Ну, моя оценка может быть неправильной, может
оказаться, что на самом деле больше. А может и меньше. Соответственно, есть возможность какие-то
вещи на самом деле даже скипануть. Какие-то вещи скипануть не получится, потому что домашки. В общем,
доклады впихнутся явно. То есть, в любой момент пишете там на выходных, что-то мне вдохновение
пришло, хочу доклад, такая-то тема. Мы обсуждаем в следующий семинар, занятия, вы что-нибудь рассказываете
классное. Я, наверное, накидаю в чат темы, по которым я считаю было бы интересно подготовить и рассказать.
Вот. Ну, один человек желающий есть. Надеюсь, еще кто-нибудь появится. Вот. На этом, видимо, все. Не
будем досиживать эти три часа. Все хотят есть, спать и отдыхать. Так что, да. Всем спасибо, всем пока.
