ПРОДОЛЖЕНИЕ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙСКОЙ ПОЛИЦЕЙС
ПОЛИЦЕЙС обор trata
Так, пусть у нас есть строка какая-то.
Давайте я ее знаменирую.
Которая заканчивается на доллар.
Вот, ну как мы в SUFMAS дописываем решетку в конце, здесь традиционно
дописываем доллар, но опять неважно, тут даже неважно,
что этот символ меньше всех символов алфавита, просто
какой-то отдельный, особенно выделенный символ, который
не встречается больше нигде в строке.
Ну и давайте я для удобства обозначу через S с верхним
индексом и ты суффикс, то есть это строка начинающаяся
с SE до конца.
Вот, значит и суффиксное дерево, такая структура
данных, которая по сути представляет из себя бор,
на всех суффиксах строки S, определение, ну такое не
очень формальное, давайте в кавычках возьму, суффдерева
строки S это сжатый бор тех Е у суффиксов, то есть строк
S с верхним индексом 0, 1 и так далее, N-1, вот есть все
суффиксы, мы их как бы складываем в бор и в каком-то смысле
делаем его сжатым.
Значит, что такое сжатый бор, это когда мы удаляем
проходные вершинки, то есть смотрите, если мы просто
построим этот бор на всех вот этих вот словах, то в
худшем случае у нас будет вот такая вот большая штука,
то есть грубо говоря, если все буквы в слове различные,
то все суффиксы начинаются на разные буквы и тогда
все будет выглядеть вот так, где каждая вот такая дуга
это суффикс, соответственно здесь куча вершин, куча
ребер.
А сжатый бор, это когда мы сжимаем вот такие вот длинные
отрезки без витвлений, длинные вот такие вот, как бы
сказал Андрей Михайлович, сардельки, такие длинные
сардельки мы сжимаем просто в одно ребро, то есть говорим,
что вот это все одно ребро и на нем написано не по
одной букве много раз, а здесь написано какая-то
сразу под строка, какая-то сразу под строка.
Давайте какой-нибудь пример нарисуем.
Для строки, ну такой, например, давайте построим для него
суффиксное дерево.
Ну, чего будет, Дина А, дальше, Дина А, Дина А, Дина А,
Дина А.
Проверяемся.
Ну и доллар нарисовать из корня.
Значит, вроде фотософикса есть, доллар есть, б-доллар,
вот он, а-б-доллар, вот, а-а-б-доллар, п-а-а-б-доллар, а-б-а-б-доллар,
все есть.
Вот, и причем здесь я прям смело на ребрах пишу
некие подстроки, да, не один символ, а несколько символов
подряд.
Ну, собственно, в этом и есть сжатость нашего убора,
что на ребре мы можем писать не один символ, а несколько
подряд.
Вот, то есть, ну давайте я что-нибудь напишу, да, что...
Какой-то марафин надо навести все-таки.
Что такое сжатый бор на ребрах?
Могут быть написаны строки.
А не только символы.
Ну, и раньше еще в боре было условие, что из вершинки
не может быть несколько разных ребер по одной и
той же букве, да, то есть, если в боре запрещалось что-то
вот такое вот иметь, нельзя.
То теперь при сжатии условие будет очень похожим, но
только там будет смотреться не на раме ребра, а на первую
букву ребер.
То есть, теперь нельзя...
Не знаю, там, ц...
То есть, раньше мы говорили, что у нас должны быть обязательно
все различные исходящие стрелочки, а теперь различия
мы смотрим по первым буквам.
Да, у всех исходящих ребер не должны быть одинаковые
первые буквы, ну, потому что если у них одинаковые
первые буквы, то их надо было бы вот так склеить,
вот эти ребра надо было склеить, по крайней мере,
по одному первому символу, и картинка была бы какая-то
вот такая, да, что здесь С, а здесь вот эти вот кусочки.
Вот.
Ну, а соответственно говорить, что эти строки различные
мы как бы не можем, потому что они могут где-то совпадать,
да, например, может быть там АВ и БВ, вот такие вполне
ребра могут быть.
То есть, если действительно здесь в исходном боре было
А вниз и В вниз, а здесь просто БВ, то тогда это просто
сжимается вот в подстрочку АВ и подстрочку БВ.
А, то есть...
Еще раз?
Ну, БВ, да, конечно, тоже.
Ну, АВ, то есть еще раз, да, если у нас есть, скажем,
какие-то вот...
Ну, вот такую картинку, такая картинка, конечно, сжимается
вот в такую.
Окей?
А, да, да, справедливые замечания, потому что здесь
такого как будто нет. Да, конечно, так может быть.
Давайте я какой-нибудь еще пример нарисую.
Да, я вас понял.
Да, нет, тут такого действительно нету.
Сейчас придумаю.
Ну, да, например, вот такое.
Если я напишу такую строчку, то здесь после А всегда идет
Б, поэтому из корня будет ребро АВ.
И это нормально.
Да, все остальное как-то там выглядит.
Ну, давайте я уже нарисую.
Да.
Ребра, на которых написаны много букв, могут быть не
только ведущими в листья, но и какие-то там посреди
дерева тоже.
Так, вопросы есть?
Ну, и, соответственно, так же как в обычном боре,
я буду называть терминальными те вершины, которые отвечают
каким-то из вот этих вот словарных слов, да, то есть мы
строим Бор по сути, по вот этому набору строк.
Вершины, отвечающие концам этих строк, будут терминальными.
Давайте подпишем, что вот эти вот слова отвечают
терминальным вершинам.
Терминальным вершинам.
Так, окей.
Вот, значит, еще вопрос у меня такой к вам.
Вот, смотрите, если я буду прям таким явным образом
хранить Бор и на всех ребрах писать прям вот, ну, строчку,
набор символов, то сколько памяти будет занимать такая
структура, если сходно в строке было N символов?
Нет?
N квадрат, да, потому что здесь каждый символ, ну, не
так, да, здесь суммарная длина всех вот этих вот строк,
которые написаны в дереве, равна суммарной длине всех
суффиксов.
В худшем случае, окей, может быть.
В худшем случае может быть такое, что если все символы
строки различны, то у меня получается вот такой вот
Бор сжатый, и если на каждом, если на каждой вот этой
сардельке написан суффикс, да, то суммарная длина всего,
что написано, это квадрат, потому что там будет сумма
длин, один плюс два плюс так далее, плюс N, на это
по прям квадрат.
Поэтому писать явным образом здесь вот прям строки на
ребрах, это не очень выгодно.
Вместо этого мы будем хранить на самом деле просто два
индекса, каждое ребро у нас будет представлено в виде
двух индексов LR, ну, как знак того, что строка написанная
здесь, это просто подстрока исходной строки с LT позиции
по R2, вот и все.
Потому что понятно, что поскольку я работаю на одной
строке, закидываю сюда все возможные суффиксы, ну,
значит, здесь там какие-то префиксы, какие-то куски
суффиксов, то есть это все в любом случае подстроки
исходной строки.
Я читаю несколько символов подряд, это обязательно
подстрока исходной строки.
Поэтому вместо хранения прям явно строки на ребрах
нашего сжатого бора я буду хранить два индекса, начало
и конец.
То есть вот, например, здесь вместо AB$ я буду хранить
два числа, два 4, да, потому что это 0, 1, 2, 3, 4.
Вместо этого формально я буду хранить пару 2,4, ну,
два индекса, левый и правый.
И тогда уже можно будет надеяться, что размер этой
штуки будет линейен, по крайней мере, в этом худшем
случае размер точно линейен, потому что здесь, ну, там
n плюс одна вершина, видимо, n, n ребер, и каждое ребро
это просто хранение двух чисел.
Тогда уже, по крайней мере, в этом случае память линейна,
и можно надеяться, что алгоритм тоже может быть линейным.
Ну, давайте докажем, что если мы храним ребра именно
так, как под строки, началом и концом, то память действительно
будет линейная.
Значит, если длина s равна n, то в суфигном дереве строки
s будет вершин и вот n ребер.
Ну, соответственно, если там линейное число вершин
и ребер, на каждом ребре написаны по два числа,
значит, суммарная память здесь тоже будет линейная.
Ну, доказательства тривиально.
В качестве доказательства мы давайте предъявим алгоритм
по строению суф-дерево за... вот он в квадрате.
Алгоритм по строению суф-дерево за т т т квадрат.
Так, алгоритм будет такой, давайте мы будем добавлять
вбор по одному суффиксу в порядке убывания.
Добавлять суффикс в порядке убывания длины.
Будем это делать так.
Сначала у нас есть корень, мы добавляем суффикс s нулевой,
то есть всю строку, как одно длинное ребро, и на этом
на этом ребре пишем под строку с 0 по n-1.
Напоминаю, что саму строку мы не пишем, мы пишем только
два индекса, начало, конец.
Дальше мне нужно просчитать s1.
Ну, смотрите, s1 и s0 могут иметь некий общий префикс,
могут иметь несколько общих первых символов.
Тогда давайте их найдем столько, сколько нужно,
сколько у них совпадает первых символов,
а дальше нужно будет отвитвиться.
То есть вот здесь будет какая-то такая точка,
что первые вот эти символы равны us0 и us1,
а дальше начинается какое-то различие,
и мне придется отвитвиться и написать здесь s1.
Причем это будет всегда происходить,
мне всегда нужно будет отвитвиться,
потому что все наши суффиксы заканчиваются на доллар,
а значит, мне всегда придется,
ну, то есть когда я вот так буду делать
итеративно по всем суффиксам,
я всегда буду до какого-то момента читать общие символы,
а потом мне придется отвитвиться,
как минимум потому, что у меня встречается доллар
на позиции раньше, чем все предыдущие.
Потому что я перебираю в порядке выбывания длины,
доллар будет на более ранней позиции,
мне придется отвитвиться.
Ну, То есть алгоритм такой,
перебираем вот так вот суффиксы в порядке s0, s1, и так далее.
Читаем в боре столько, сколько можно
префикса текущего суффикса.
Например, там s2 может выглядеть как-то вот так
вот тут вот общая, тут вот общая,
а потом придется Serv trying, ну, и так далее.
суффикс обрабатывается за линейное время, потому что мне нужно сначала найти общий
префикс, который есть в боре, ну то есть просто наибольший префикс текущей строки,
которая есть в боре. Потом, когда уже нельзя дальше читать, нужно просто создать новое ребро,
написать, что здесь там какой-то остаток нашего суффикса лежит. Ну и собственно все,
мы закончили обработку строки. То есть мы просто создаем одно ребро. Мы должны расщепить, расщепить
ребро, поставить здесь вершину, соответственно сказать, что здесь отдельное ребро, здесь
отдельное ребро, ну и еще одно ребро добавить, чтобы выделить конец новой строки. То есть в
худшем случае мне придется одно ребро расщепить, добавить одно ребро и еще добавить ребро с вершиной.
Поэтому каждое добавление суффикса, каждое добавление этой строки в наш сжатый бор,
ну там увеличивает число вершины ребер максимум на два видимо. Добавление каждой строки
увеличивает число вершины ребер не больше чем на два.
Ну конечно, да, если есть вершина, я стою здесь, мне нужно прочитать там какое-то слово, ну да,
то есть продолжить чтение какой-то там строки. Я смотрю какие-то первые символы, выбираю тот,
который совпадает с тем, что мне нужно прочитать и иду вниз, собственно, по этому ребру.
Вот, ну а раз каждый из суффиксов добавляет максимум две вершины, два ребра, значит сумма
армии там максимум 2n вершины ребер, значит линия, что и требовалось. Это классно?
Так, что дальше? Заказали. Следующее, что нам нужно, это ввести понятие сувсылки. Ну, нет,
давайте сначала поймем какие вообще бывают позиции в дереве, потом введем сувсылку,
значит позиции в дереве. Смотрите, мы поняли, что вот у нас есть некий сжатый бор, и каждая
позиция, там каждая вершина, по крайней мере, точно отвечает некоторые под строке. Но более того,
в процессе чтения каких-то строк, начиная из корня, мы можем в момент времени находиться где-то
посреди ребра. Да, вот, например, если я в этом боре прочитаю АА, то я закончу где-то вот здесь,
и это не вершина, а просто какая-то позиция внутри ребра. Я не выделяю это как отдельную вершину,
это просто позиция посреди ребра. Соответственно все позиции в дереве бьются на два типа. Во-первых,
это просто вершины обычные, которые хранятся там как отдельные струк нод, из которых есть куча
переходов. С ними все понятно, понятно как хранить. Но также есть позиции посреди ребра. Позиции,
позиции внутри ребра, я так не пишу. И мы их будем в памяти, ну как бы, в реализации,
сохраняя следующим образом. Значит, если есть ребро, на котором мы стоим, где-то вот здесь вот,
где-то на какой-то его внутренней позиции, отличное вот начало и конца, потому что начало
конца вершины, то тогда мы будем хранить. Это вот это вот первая вершина П в ребре, то есть то,
откуда мы начинаем. Во-вторых, это первый символ А на этом ребре, потому что, как мы знаем,
из вершины П все исходящие ребра имеют различные первые символы. Значит, чтобы как бы детерминировано
выбрать именно это из тех исходящих из П, достаточно знать только первый символ. Не нужно знать всю
подстроку, нужно знать только символ А. Ну и последнее, это то, сколько символов прочитано
от начала строки. Ну как бы предок, да. Дальше А это первый символ на ребре, первый символ,
ну и КАТА сколько символов прочитано.
Сколько символов прочитано.
Теперь дальше.
Определение суффиксная ссылка. Значит, ну смотрите, мы поняли, что позиции в дереве это либо вершины,
либо какие-то точки внутри ребра, и для каждой такой позиции можем определить суффиксную ссылку.
Пусть В это позиция в дереве. Как обычно, мы все позиции можем отраждествить с строками,
которые ведут из корня в эту позицию. То есть как так же, как у нас было в Боре, я буду перемешивать
вот В временно, и позиция в дереве, и строка, которая ведет в эту позицию. То есть сколько
есть тривиальная биекция между позициями и строками, которые ведут в эти позиции из корня,
то я буду одной буквой это как бы обозначать то и то, и позицию, и саму строку. Так вот В позиция
в дереве, то есть что-нибудь вот такое, например, да, какая-нибудь там позиция внутри ребра. И в то
же время вот эта вот вся строка от корня до нее. Суффиксная ссылка это, как обычно, максимальный
собственный суффикс строки В, который можно прочитать в Боре. Суффиксная ссылка линк от В,
это, ну, допишем формально указатель на позицию, отвечающую максимальному собственному суффиксу В,
который есть в Боре. Есть в Боре, то есть можно прочитать, начиная с корня, и закончить все в какой-то
позиции дерева. Теперь у меня такой вопрос к вам. Вот смотрите, пусть В это какая-то позиция в дереве,
соответственно, на некоторой строке. Некоторой подстроке исходной строки С. И мне нужно что? Мне
нужно взять в этой строке максимальный собственный суффикс, который можно прочитать из корня. То есть
суффикс максимальный по длине, но при этом отличный от самой строки В. Скажите, пожалуйста, что это за
суффикс? Какая у него длина по сравнению с В? Длина какая тогда? Да, на один меньше. Да,
действительно, все позиции в дереве это префикс суффикса, то есть на самом деле просто подстрока.
А нет, сейчас. Ну да, потому что это одно и то же. Но главное, что раз у нас в Боре, по сути,
представлены все суффиксы, то есть все префиксы всех суффиксов, то есть просто все подстроки,
то значит, если я откушу всего лишь один фимал в начале строки В, то это тоже будет подстрока
исходной строки С, а значит, ровно это и будет суффикс. Потому что среди всех собственных суффиксов
это максималь, и он точно есть в Боре, потому что это меньше подстрока той же самой строки С.
Раз В это подстрока, то и как бы меньше ее подстрока тоже подстрока С. Замечание, что линк от В всегда
получается из В отбрасыванием первого символа. Вот такое соображение, что ссылка здесь,
когда мы строим сух дерева на одной строке, это всегда отбрасывание одного символа. Не как было
у нас в алгоритмах карасик, что это просто какой-то максимальный собственный суффикс. Здесь
вот он ровно конкретно определен, это всегда отбрасывание всего одного символа.
Отвержение. Ссылка вершины, вершина.
В том смысле, что сувсылка у нас формально определена не только для вершин, но и для позиций в дереве,
и казалось бы совсем не обязательно. Сувсылка вершины это обязательно вершина, потому что сувсылка
вершины это просто некая позиция в дереве, которая вполне возможно может быть в позиции
внутри ребра. Но это утверждение, если мы его докажем, скажет нам, что сувсылка вершины, да именно вершина,
да не где-то позиция внутри ребра, а именно вершина. Ну доказательство будет следующим. Вообще,
что только вершины в нашем дереве? Это либо листья, то есть те как бы точки, ниже которых
никуда нельзя пойти, либо это точки, в которых возникает битвление, то есть есть как минимум
два нисходящих ребра. Вершины все это либо листья, то есть точки, ниже которых вообще ничего нет,
либо это вершины битвления. То есть те позиции в дереве, ниже которых есть по крайней мере два
варианта куда пойти. Ну потому что иначе, если есть ровно один вариант, да если есть какая-то
точка, ниже которой есть всего один вариант куда пойти, то значит на самом деле эта вершина
проходная и можно было бы ее стянуть и сказать, что все вот это одно ребро без вот этой вершины.
Ну окей, для формальности надо еще сказать, что есть корень иногда, да, корень на случай,
если у нас ну как бы просто вот такое вот дерево. А вот корень, вот конец. Ну то есть это редко
бывает, но иногда бывает. Да потому что еще раз иначе, если вершина не корень, у нее ровно потомок,
то значит у нее есть родитель и можно было бы стянуть это ребро в одно и эта вершинка бы не
была вершиной. Ну собственно нет никаких причин эту вершину в нашем вот сжатии не стянуть,
она проходная, у нее сходящая и сходящая степень 1, мы ее стягиваем в одно длинное
ребро и удаляем эту точку как вершину. Согласны? Вот.
Давайте все-таки удалю корень, потому что корень никогда не может быть вершиной, потому что у него
хотя бы из него есть хотя бы два разных исходящих символа, потому что есть всегда хотя бы один символ
строки, есть всегда хотя бы хотя бы доллар, поэтому корень попадает вот сюда, это всегда вершина
ветвления, мы ее как отдельную сущность удаляем. Ну вот, значит надо разобраться с листьями в первую
очередь. Это ровно то, что соответствует суффиксам, то есть если я прочитаю слово ведущее из корни в
некоторые лист, то я обязательно получу суффикс и наоборот, если я прочитал суффикс, то обязательно
попаду в лист. Это обеспечивается за счет доллара, именно за счет доллара, потому что ну что такое
какая-то такая точка, ниже которой пойти нельзя. Ну какой тогда был написан здесь последний символ,
если тут написан не доллар, если последний символ на пути до листа не доллар, то ее точно можно
продлить, да, потому что наша строка это что-то там что-то что-то что-то в конце доллар, значит если я
здесь прочитал строчку без доллара, то ее гарантированно можно продолжить, ну как минимум долларом всегда,
то есть там возможно что-то надо сначала прочитать, потом будет доллар, поэтому если у нас есть лист,
то по суффиксу можно продлить. Иначе можно нашу нашу штучку продлить. А раз последний символ на пути это
доллар, то значит это суффикс. Следовательно любой путь от корни до листа это суффикс. Ну и наоборот,
если я прочитаю некоторый суффикс начиная из корня, то есть тут я взял лист и показал, чтобы пришли в
суффикс, теперь пусть наоборот, я прочитал суффикс, тогда раз это суффикс, то я обязательно прочитал доллар в
конце. И тогда это гарантированно лист, потому что дальше доллара идти нельзя. А значит наоборот,
каждому суффиксу соответствует лист. Поэтому между ними есть тривиальная объекция, все листы
соответствуют ровно суффиксам, и у них как раз таки все с суффислками очень просто. Потому что
если мы рассмотрим позиции, отвечающие всем нашим суффиксам S0, S1, S2 и так далее, Sn-1, то они
должны друг на дружку ссылатся. Как суффислки? Потому что это лист. Дальше, что такое суффсылка
от этого листа? Это отборосленное первого символа, то есть просто вот эта эта вот вершинка. А это тоже
лист. Суффсылка S1-то будет S2, потому что отборосленное первого символа и из S1 получается С2. Значит
FDA идёт в лист. Ну и так далее. У нас будет вот такая вот последовательность.ซс- ссылок. То
есть лист, они sends друг на дружку ссылаются в терминах суффсылки. Суффсылка от суффиксов. Это
это чуть меньший суффикс длины на один меньше.
Поэтому сувсылка листа это всегда либо лист, либо
вот здесь в последнем эпизоде будет ссылка из s-n-1 в корень,
потому что это строка, которая равна просто доллару,
и сувсылка от этой штуки это просто пустая строка,
то есть корень.
Да, поэтому цепочка взять из сувсылки от самого длинного
листа, от самого длинного суффикса, это по всем листьям
и потом попадание в корень.
Если я прочитал некий суффикс, начиная с корня, то я обязательно
в конце прочитал доллар, потому что все суффиксы
у меня кончаются на доллар, значит ниже отсюда я никуда
пойти не могу, потому что нет ни одного, если я уже
прочитал доллар, то ниже него ничего читать нельзя,
значит это лист.
Мы доказали, что сувсылка листьев это всегда либо
листья, либо корень.
Теперь осталось разбираться с вершинами ветвления,
почему сувсылка вот такой вершины, это тоже вершина.
Пусть есть вершина ветвления.
Что это значит?
Это значит, что мы как-то из корня читали некую строчку
альфа, попали в вершину, а дальше из нее есть ветвление,
ну как минимум, скажем, можно прочитать а и дальше
что-то еще, а можно прочитать b и что-то еще, где а и b какие-то
два разных символов.
То есть вот была такая вершина ветвления.
Что это значит в терминах нашей строки?
Это означает, что в нашу исходную строчку с входит
как под строки как минимум две следующие подстроки,
альфа а и альфа б, ну потому что их можно просто прочитать
из корня, а все что можно прочитать из корня это в
подстроке нашей строки.
Вот есть такие строки в нашей строке.
Дальше, чтобы взять всу всылку вершины вот этой вот альфа,
чтобы взять всу всылку от этой точки, мне нужно
отбросить первый символ из альфа и понять, какая
будет позиция в дереве.
Ну давайте я отброшу и скажу, что это какая-то бета,
вот эта вот бета, вот эта бета соответственно и вот
эта бета.
Ну тогда извините, бета а и бета б тем более будут
под строками нашей исходной строки, а значит после бета
есть ветвление, значит бета это вершина.
Ну то есть еще раз, если альфа это вершина, то альфа
а и альфа б это под строки с, под строки с, ну я имею
в виду вершины ветвления здесь, потом если бета это
линк от альфа, то есть ее всылка, то есть строка
получающейся отбрасыванием одного символа, то тогда
тем более бета а и бета б это тоже под строки с,
под строки с, ну потому что я отбросил один символ
из начала этих строк, это конечно под строки остались.
Ну значит бета это опять вершина ветвления, бета
это вершина ветвления, потому что после нее есть два
разных как бы продолжения, можно читать а, можно читать
поэтому если я б, то как ты прочитал из корня, то
гарантированно здесь есть вот развилка, влево скажем
можно читать а и что-то еще, а вправо б и что-то еще,
возможно появляются еще какие-то новые ребра, которых
там не было, но главное по крайней мере два ветвления
здесь есть, поэтому это точно вершина, она не сжалась,
она не проходная и это будет как бы ну вот точка в нашем
дереве, вершина, вот, поэтому вершина ветвления это вершина
ветвления, ну то есть вершина, окей, да, ну окей, давайте
тогда теперь будем считать, будем считать, что если в
дереве есть вершина, то мы знаем у нее ссылку, если
дереве, есть вершина В, нам известна линка В, мы будем
вместить с каждой вершиной хранить ее сувсылку, теперь
если мы знаем, где находится сувсылка для любой вершины
В, то давайте научимся находить сувсылку для любой позиции
в дереве, то есть скажем сувсылки вершин мы храним, нам тогда
еще нужно вместить сувсылку, ну находить сувсылки для
позиций на ребре, а вот у меня позиция где-то на
ребре, напоминаю, задаваемая тремя параметрами P, A и K, мне
нужно для вот этой вот позиции найти сувсылку, ну давайте
я это назову процедура GetLink, GetLink, ну так я назову это
поз, позиция где-то на ребре, я хочу найти сувсылку, ну
здесь ничего хитрого нет, в случае если P это не корень,
то нужно просто взять сувсылку для P, а дальше прочитать
те же самые K символы, значит случай 1, P не корень, тогда
картинка будет такая, вот есть некий путь до P, потом
есть длинное вот такое вибро, мы прочитали на нем K символов,
тогда чтобы взять сувсылку для этой позиции, давайте
я не буду выделять жирный, точку просто поставлю,
значит чтобы найти сувсылку для этой позиции мне нужно
взять всю вот эту длинную строчку и отбросить первый
символ, но это то же самое, что отбросить первый символ
вот этой строки от корня до P, а потом вот эти K символов
прочитать, потому что все равно мне нужно отсюда
отбросить один символ, это то же самое, что если я
его отброшу сначала, прочитаю вот это, как сувсылку P, и
потом дочитаю вот эти K символы, то есть в таком
случае, если P не корень, я нахожу вершину, которая
у меня уже известна, link от P, раз P это вершина, то
link от P тоже вершина, которая у меня хранится где-то, вот
я считаю, что я ее где-то сохранил, я знаю link от P,
дальше мне нужно вот эти K символов прочитать, дальше
мне нужно вот эти K символов как-то прочитать, ну и давайте
я здесь это так и сделаю, как-то эти K символов читаю,
но здесь может быть проблема в том, что даже если раньше
эти K символы лежали все целиком на одном ребре,
то здесь они уже могут начать витвиться, и эти K символы
возможно лежат не на одном ребре, а на нескольких, то
есть мне нужно сначала там wtькому б ор едно ребро,
второе, третье, четвертое и так далее. И вот где-то в конце я где-то закончусь.
То есть даже если раньше ко символов были как бы под строкой одного ребра, то при
переходе к су-всылке вполне возможно, что это ребро как-то расщепляется. Ну потому что вот я
там рисовал, что когда я перехожу к су-всылке, у меня могут возникать новые витвления. Значит,
это ребро могло как-то там очень сильно под расщепиться, и для чтения этих ко символов мне
возможно придется пройти много ребер. Ну что поделать, так и сделаем. Вот читаем эти ко символов,
столько сколько нужно, пока не попадем в ту самую позицию, которая отвечает су-всылке для вот этой
позиции поз. Поз – это линк от поз. Значит, в этом случае мы просто смотрим линк от П и читаем те же
самые ко символов. Читаем те же ко символов. Скажите, пожалуйста, какое будет время работы
вот этой процедуры чтения вот этих ко символов? Вот чего? Ну вот как можно точнее. Понятно, что это
от n, потому что в принципе… Ну давай считаем, что у нас алфавит константный, размер. Ну там 26
символов. Можно лучше. Ну еще раз. Сигма к, если сигма констант, то просто к. Логарифм не умею.
А, логарифм, я понял. Да, ну еще раз. Если сигма констант, то сигма и логарифм сигма – это все единица.
Ну тут на самом деле не закам. Здесь быстрее, чем закам на самом деле. Потому что вот это чтение,
ну то есть понятно, что к – это верхнее ограничение, но на самом деле время работы вот этой процедуры,
этого куска процедуры, оно пропорционально просто числу ребер, который я прохожу. Почему, да,
почему не нужно каждый символ по отдельности читать? Ну, не знаю, давайте… Здесь было написано какая-то
подстрока, скажем, с L по R, и здесь я читаю первый k символов. Тогда как просчитать те же k символов
вот здесь? Смотрите, я знаю символ SLT. Соответственно, из этой вершины я нахожу ребро, которое начинается
на то же самое SLT. Вот оно, да, у меня нарисовано. Тогда я точно могу сказать, что если длина этого
ребра меньше, чем k, то я могу не читать все символы по одному вот здесь вот и вот здесь вот синхронно,
а сразу перепрыгнуть вот сюда и вот сюда, конец этого ребра. Да, ну потому что если как бы здесь
строка начинается на SL, она однозначно так определена, да, вот это вот все, и здесь тоже строка,
которая начинается на SL, как-то вот так вот идет, то понятно, что символы следующие за SL там будут
одинаковы. Нет смысла их перепроверять, потому что, как бы, если есть такой путь, то есть и такой путь,
а раз нет лицеления, значит, ну просто однозначно у нас все определено. Если тут первые символы
совпадают, то значит и вот это вот все тоже совпадает. Поэтому нет смысла все вот эти символы по одному
перебирать. Достаточно посмотреть только на первый. Если они совпадают и длина этого меньше, чем мне
нужно пропрыгать, то я просто сразу телепортируюсь в конец ребра. Я не перебираю по одному символу,
а сразу туда перемещаюсь. Дальше. Я стою здесь и вот здесь. Опять знаю, какой мне нужно перешать
следующий символ, нахожу его среди исходящих ребер и сразу перемещаюсь в конец ребра и здесь
тоже делаю какой-то прыжок. Ну и в конце, когда я нахожу ребро, длина которого больше, чем мне
нужно, а остаток вот К, то я просто перемещаюсь там, делаю плюс К и здесь вот встаю в позицию посреди
ребра. То есть тогда на самом деле время работы этой процедуры, время работы, есть О от числа
просмотренных ребер. Число просмотренных, просмотренных ребер. Давайте, давайте картинку нарисую.
Итак, мне нужно отсюда прочитать вот эти К символы. Для этого я смотрю на первый символ здесь. Я знаю,
что это, это какой-то символ нашей строки. Отсюда я нахожу исходящий ребро, начинающийся на тот же
символ. Ну скажем, вот оно какое-то такое. Если его длина меньше либо равнока, то я сразу
телепортируюсь в конец этого ребра здесь, а здесь я телепортируюсь, ну собственно, на длину этого ребра.
Еще раз. Ну конечно, да, конечно. Если вот это вот, это под строка, то есть это путь в боре,
значит это под строка, тогда когда я отбрасываю первый символ, то это конечно тоже будет под строка,
она читается в боре. И более того, если первые символы здесь совпадают, и здесь нет выцеления,
значит здесь просто единственное возможное продолжение, которое совпадает с тем, что тут
написано. Поэтому эти символы можно даже не проверять. Вот, ну и тогда все. Я просто прочитал
целом это ребро за один шаг, и указатель отсюда переместил вот сюда. Теперь я нахожусь в этой
вершинке, вижу некую следующую букву, которую нужно прочитать, нахожу ребро, начинающийся на ту
же самую букву, читаю его целиком это ребро, ну и соответственно телепортируюсь в какую-то позицию
на вот этом исходном ребре. Тогда время работает, просто то, сколько ребер я прошел.
Ну, а второй случай, когда p это корень, тут собственно все,
когда ситуация такая, есть корень, есть некое вот такое ребро, я читаю на нем по символов,
нахожусь где-то вот здесь, мне нужно взять всю всылку от этой позиции. Ну, то же самое,
только мне нужно теперь читать не вот эту строчку, а вот эту строчку. А поскольку я не
могу взять всю всылку от корня, то нужно просто отбросить первый символ и прочитать
вот такую строчку из корня. Прочитать эту строчку из корня. А читать строку из вершины мы уже умеем.
Вот у нас была процедура, мы стоим в вершине, мне нужно прочитать некую подстрочку. Опять нахожу
первый символ, иду на длину ребра, потом
телепортируюсь сюда, читаю следующий
ребро целиком, ну и в общем точно так же
будет, да, мы несколько ребра прочитали и
где-то там опять встали посреди ребра.
Вот, опять-таки время работы здесь будет
пропорциональностью ребра, которое я
прошел, потому что каждое ребро обрабатывается
за вот единицы. Ну не буду переписывать,
ассоциативная дотика такая же.
Так, ну и теперь вроде у нас все готово к
тому, чтобы написать алгоритм Мукунина.
Устроение сувдерева
за линейное время.
Уконин, Ук-Конин, то ли швед, то ли норвежец, что-то такое.
Не совсем, не совсем, это у нас будет
внутри алгоритма, мы поймем, как это сделаем.
Так, значит последняя теоретическая
вставка следующая. Давайте рассмотрим вот,
пусть у меня построено сувдерев в какой-то
момент, в какой-то момент нашего, не так, не так, не так.
Как работал Ритм Уконина? Он будет нашу строчку
расширять по одному символу, право, и как бы
для каждого префикса индуктивно строить
текущую версию сувдерева. То есть для
этой штуки построил сувдерева, молодец,
потом взял следующий символ, перестроил
сувдерева, получился сувдерева для большей строки и так далее.
То есть он наращивает по одному символу
нашу строчку и меняется в дерево.
То есть ЭД-С, который запускается при
прочтении каждого нового символа, ЭД-С.
Прочитали символ, запустили ЭД с этим символом.
Так вот, давайте посмотрим на
нашу строчку в какой-то момент, когда я
прочитал, скажем, символы С0 по СИ и
построил для них сувдерева, а дальше
приходит символ С.
Тогда я утверждаю, что все позиции,
отвечающие суффиксом, сейчас, да, все
позиции, отвечающие суффиксом сувдерева
в этот момент времени, то есть до того, как я его
начал перестраивать, бьются на три
категории. Значит, во-первых, это позиции,
которые являются листьями. Будет первая
категория листья. То есть такие позиции в
дереве, которые одновременно листья и
суффиксы вот этой вот строки с С0 по СИ.
Дальше будет вторая категория позиций.
Это не листья, из которых нет перехода
по С. Не листья без перехода по С, без
перехода по С. Ну и третья категория, это не
листья, из которых есть переход по С.
Не листья с переходом по С. То есть, если у меня
построено корректное суффиксное дерево
для вот такой строки,
в позициях пока.
Нет, именно вот для этого построено малого.
Если у меня есть построенное
сувдерево в этот момент времени,
пока я не знаю, что происходило дальше,
я предположу, что корректное сувдерево
для вот этой штуки.
Так вот здесь когда я рассматриваю
все позиции, отвечающие всем суффиксам
этой текущей версии моей строки,
то есть все вот этиią
строки, все суффиксы здесь,
эти позиции бьются на три категории.
1 и третья позиции листья дальше позиции не листья без новой символу c и не листья с переходом по c
причем эти позиции именно вот в таком вот порядке убывания длины расположены то есть в первой категории находится несколько самых длинных суффиксов
то есть скажем вся строка соснули по s и ее там ну вот это и несколько суффиксов
дальше подряд идут несколько не листьев без перехода по ц
опять в порядке убывания длины несколько подряд и
потом в конце самые несколько коротких суффиксов это не листья с переходом по ц
опять подряд несколько самых коротких значит почему подряд почему все идут в порядке убывания длины
ну последующую причине значит рассмотрим рассмотрим
самый короткий
отвечаешь листу отвечаешь листу вот в этом дереве
тогда те более длинные тоже точно листы
потому что если есть какой-то более длинный суффикс с ветвлением
да ну или вообще просто с прочтением чего-то вниз то тогда это же самое можно было прочитать вот здесь это соответственно было бы не лист
потому что еще раз если это более длинная строка то есть окей давайте вот скажем это некий суффикс там с
житая
вот такой суффикс сж если есть некий больший суффикс с
мт
вот такой
внизу куда можно что-то прочитать то есть не являешься листом то есть справа от см есть там ко election well x который можно прочитать
и тогда его же можно было candle сж на потому что neuver
расширение влево строки sg значит тот же сам из можно было были Calm мнеbridge это не могло быть суффикс с Morgan
если это лист то здесь ничего не может быть иначе здесь staring можно было прочитать
тем самым если я взял самый короткий суффикс отвечающую листу то все более длинные тоже листье
Тогда все более длинные суффиксы тоже отвечают
листьям.
Окей?
Поэтому первая категория это точно несколько самых
длинных суффиксов.
Начиная с самого короткого, а потом все больше длинных.
Несколько последних – это обязательно листья.
Первая категория.
Значит, третья категория возьмем.
Возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем, возьмем,
возьмем, возьмем, возьмем, возьмем, возьмем,
Ну он автоматически будет не лист, поскольку из него
есть переход по С, но давайте это все равно напишу, отвечающий
не листу, из которого есть переход по С, из которого
есть переход по С. Вот это какой-то суффикс, ну точнее,
вот это какая-то позиция в дереве такая, что внизу
есть буква в КС, то есть можно из этой позиции непосредственно
прочитать буквы С. Тогда, если это СГ, то любой другой
более короткий суффикс СТ, конечно, тоже продолжается
буквой С, потому что если после СГ можно было прочитать
С, то после любого более короткого суффикса СТ тоже
можно подавно прочитать С. Значит все более короткие
суффиксы тоже имеют продолжение буквой С. Значит все более
короткие вновь не листья, из которых есть переход
по С. Тогда все более короткие суффиксы, такие же я напишу,
такие же, то есть это вновь не листья, из которых есть
переход по С. Значит третья категория это именно что
несколько самых коротких по длине суффиксов подряд
идущих. То есть если вот это, то что у меня там было
написано СГ, длинные из третьей категории, то все
более короткие тоже из третьей категории. Смотрите,
это суффикс вот в этот момент времени. Когда я дойду
до Саиды и пишу доллар, это будет лист, но пока у
меня здесь бывает фитствление, пока я не доллар, то у нас
не работает, что суффикс это лист обязательно. Ну и
так, что у нас получилось? У нас получилось, что несколько
самых длинных суффиксов отвечают листьям, несколько
самых коротких отвечают не листьям с переходом
по С, но значит все, что между ними, опять некий
отрезок внутри, это не это и не это, то есть не листья
без перехода по С. Все разбилось на три категории в порядке
убывания длины. На каждой категории это отрезок суффиксов.
Что может быть? Да, грубо говоря, может быть что-то
вот такое, вы имеете в виду, что есть позиция третьей
категории и внизу она же первой категории. Да, может
быть, вот эта картинка, она не очень информативная,
тут я как бы все вот так вот растащил, то есть я считаю,
что вот эта-то отдельно первая, а эту я отдельно перерисовал
как третью. То есть это не совсем суфф-дерево, а вот
именно, что я все... Ну короче, правильное замечание, да,
но тут я нарисовал именно, что я разнес все суффиксы
по отдельным как бы веточкам и разложил их по категориям.
Но главное, тут не столько картинка важна, сколько
вот этого понимания, что несколько самых длинных
листьев, несколько самых коротких не листьев с переходом,
а все остальное это вот без перехода. Картинка
там весьма условная. Так, что мы сделали? Построение
суфф-дерева. А, ну да. Хорошо, мы поняли, что если суфф-дерево
выглядит как-то так, то все развелось на три категории.
Дальше, что происходит с суфф-деревом, когда добавляется
новый символ c? Как оно должно поменяться? Ну, по сути,
да, у меня вот здесь вот были как бы нарисованы позиции
всех суффиксов. Вот эти все точки – это позиции всех
суффиксов в нашем текущем суфф-дереве. Когда я дописываю
к нашей строке символ c, то по сути все, что мне нужно
сделать – это ко всем нашим суффиксам дописать символ
c. Потому что вот все суффиксы автоматически продлились
буковкой c. Плюс еще появился суффикс пустая строка.
Потому что если здесь была пустая строка, то нам продлилось
символ c, стало опять суффикс. Ну, еще появился суффикс
пустой, отвечающий корнем. То есть, по сути, чтобы добавить
новый символ к уже имеющемуся суфф-дереву, мне нужно просто
все суффиксы как бы спустить вниз по букве c. Потому что
они просто расширились с буквой c. Нужно каждый
суффикс преобразовать в то же самое, только спустить
суффикс вниз по букве c. В этом смысле давайте напишу,
что нам нужно спустить из всех суффиксов терминальность
вниз по букве c. Такое корявое предложение, которое подразумевает
все, что было раньше суффиксом, то есть как бы было помещено
терминальные позиции в дереве, сейчас перестает быть
суффиксом и нужно как бы вот эту терминальность,
которая здесь была написана, вот здесь было написано
терм, то есть это суффикс, терминальная позиция. Мне
нужно эту терминальность обменить и спустить ее
вниз по букве c. И теперь помещу вот эта терминальная
позиция. Она отвечает суффиксу. Потому что это уже не суффикс,
только после расширения на c это будет суффикс. Ну,
то есть это как бы что по сути происходит. На самом
деле в самом алгоритме мы терминальности поддерживать
не будем, потому что они будут не нужны по дороге,
а в конце их восстановить будет очень просто, мы еще
до этого дойдем. В алгоритме не храним лаги терминальности.
То есть вот это вот терм мы нигде не будем помечать,
мы его проставим в самом конце. Но по сути ровно это
нам нужно сделать, что все вершины, которые раньше,
все позиции, которые раньше отвечали суффиксом, нужно
вниз спустить как бы на c. Вот. С первой категорией
это делать в прочь простого. Первая категория это листья,
вершины точкой помеченные. И мне нужно как бы отменить
их терминальность, нарисовать вниз переход по c и терминальность
перенести как бы вот сюда. Вот. Ну а с учетом того, что
это был лист, то эта вершина будет проходная и по сути
мне нужно будет просто продлить длину этого рябра. На один
вниз. И скажешь, что теперь вот это будет конец нашего
рябра. Более того, эта же самая процедура будет
происходить на всех последующих итерациях. Потому что когда
я буду дальше дописывать мою строчку новыми и новыми
символами, у меня будет происходить то же самое.
Вот есть вершина, она лист, и мне нужно будет ее вниз
все время продлевать на новые буквы. Там d, e, f и так далее.
И все время, если раньше это было листом, то он теперь
тоже будет оставаться листом. Просто потому что я
пририсовал к листу, и оно остается всегда листом,
я соответственно предыдущую вершину сжимаю как проходную.
Поэтому, если вершина в какой-то момент попала в первую
категорию, то ее дальнейшая судьба тривиальна. Она
всегда вот так вот будет по одной продлеваться вниз
и все время сжиматься как проходная. Поэтому вместо
того, чтобы делать это по одному разу, каждый раз
для каждого нового символа, я сразу, как только вершина
стала листом, как только v стала листом, я сразу ее
продлю прямо до конца стрельбы, прямо до доллара. Посмотрю
в будущем, скажем, вот здесь, в какой-то момент времени
v стала листом. Тогда я понимаю, что все, что будет дальше
вплоть до доллара, будет просто спускать терминальность
на 1 вниз по одному ребру. И чтобы это не делать для
каждого символа отдельно, я сразу все вот это дорисую
вплоть до доллара, удалю эту вершину как проходную
и скажу, что вот, пожалуйста, я сразу на будущее все
сделал. Сразу вот этот v перенес вот сюда. Так, теперь
надо какие-то слова написать. Если v в какой-то момент
листом, она всегда будет листом, потому что она будет
спускаться вниз и предыдущее сжиматься как проходная.
Вместо того, чтобы добавлять по одному символу на каждой
итерации, мы сразу допишем все до конца строки. Поэтому
при создании листа, сразу дописываем весь насадок
строки. То есть, если когда-то создался листик, то я сразу
говорю, что на этом ребре написано не там все до
символа c, а все до символа доллара, прямо до конца
строки. Потому что всегда все равно это все равно будет
просто вниз падать и вместо этого я могу сразу написать,
что здесь все до доллара написано на этом ребре.
То есть, с листами ситуация более-менее простая. Каждый
раз, когда заводится лист, я сразу говорю, что ребро
ведущее в него, оно на самом деле содержит все символы,
начиная с того символа, который я тут прочитал,
прямо до конца строки, до доллара. Все, что написано
до доллара, это все введет в эту вершинку v.
Вот, с первой категории разобрались. Теперь вторая,
самая сложная, вторая категория вершин. Напоминаю, это те
не листья, из которых нет перехода по c. То есть, это
либо какие-то вершинки без перехода по c, либо позиции
внутри ребра внизу, где c написано. Но, вспоминаем,
что мне нужно сделать. Мне нужно при переходе, при обработке
нового символа c, мне нужно этот c добавить явным образом.
У меня появляется переход по боке c, я должен его как-то
нарисовать. Но в случае вершины все просто, мне нужно просто
добавить новое ребро c. А в случае, если мы находились
посреди ребра, где-то внутри ребра, то мне нужно это ребро
предыдущий расщепить, сказать, что это отдельное ребро,
это отдельное ребро, и создать ребро по боку c здесь. Ну,
как ни крути, да, мне нужно создать переход по c вот
прям здесь, вот здесь или вот здесь. Но я его создаю,
как могу. В этом случае, правда, придется расщепить
ребро. Если v-позиция внутри ребра, то это ребро придется
расщепить. Правильно. Да, и как только мы вот так вот
сделали, да, нарисовали переход по боке c, нарисовали
переход по боке c, эта вершина становится сейчас листом.
А мы знаем, что мы делаем с листьями. Как только у
нас появился лист, я сразу здесь вместо символа c пишу
сразу всю подстрочку от c до конца строки прям до
доллара. Вот по вот этим соображениям. Появился
лист, который, да, вот здесь написан символ c. Но тогда
мы знаем, какое его дальнейшее поведение. Он как бы сразу
попадает в первую категорию, потому что это становится
листом, и дальше он будет вот так вот по одному символу
вниз-нис-нис расти по всему оставшемуся концу строки
s. Поэтому здесь сразу я пишу не просто от c, а подстрочку
символа c до символа доллар. То есть вот все прям вот отсюда
до конца строки. То есть я знаю там, скажу, что это
и плюс один, а здесь минус один. Тогда я пишу на этой вот
строке пару и плюс один, запятая n минус один. Ну короче,
от текущего символа до конца строки. Ну вот, например,
вот у нас было ребро, я расщепил, вот она вид вершины выявления.
То есть в этом случае мы сделали так. В случае, когда
надо было расщеплять, то же самое. У меня появился
новый исходящий, как бы, сарделька по букве c. Опять это стало
листом, с листьями мы знаем, что происходит, поэтому
вместо того, чтобы написать здесь просто от c, я пишу
здесь всю подстрочку с c до доллара, прямо до конца
строки. И теперь это как бы вот этот кусок отвечает
листу, который я уже полностью обработал и больше к нему
можно не возвращаться. То есть все вершины, все позиции
второй категории нам должны как бы завести новое вот
такое исходящее ребро по символу c, а значит сразу
от c до доллара всю такую подстрочку из них надо будет
уметь читать. Ну и так мне нужно проделать со всеми
вершинами второй категории. Это нужно проделать со
всеми позициями второй категории. Еще раз? Ну не
все, а вот которые суффиксами являлись. Ну вот, вот эти
вот позиции, да, которые не в первый, не в третий,
все тут обрабатываем. Да, ну в частности, конечно,
они бывают посреди ребра. Еще раз? Да, да, ну как бы
ну, бывает такое, да, скажем, если у вас там не знаю, все
символы были одинаковые, а потом пришел символ c,
то скорее всего ровно так и будет. Вам нужно будет
кучу раз отщепиться по c, да, то есть у вас была длинная
такая ветка, вы дальше здесь везде отщепляетесь
по c, скорее всего так и будет. Вот, нужно сказать,
это как перебирать все вот эти вот позиции, как перебирать
все позиции второй категории. Ну, можно сделать так, давайте
мы заведем cur как указатель на самую длинную нелистовую
позицию суффикса, тогда все позиции второй категории
получаются с помощью getlink, потому что это некий суффикс,
а это некие его более короткие суффиксы, да, то есть мы
будем отбрасывать по одному символу от вот этого cur,
до тех пор мы не попадем в позицию, то есть я просто
беру от cur и getlink, до тех пор, пока не попаду в третью
категорию. Значит, чтобы их перебрать, храним cur-
суффикс не отвечающий листу, не отвечающий листу. Далее,
пока из cur нет переход по c, я делаю вот такое преобразование,
то есть явным образом создаю ребро от c до доллара и беру
getlink от cur, потому что getlink отбрасывает по одному символу
каждый раз, я так делаю, да, пока не появится переход
по c из текущей позиции. Пока не появится переход
по c, то есть пока мы не попадем в третью категорию. Вот это
что мы делаем со второй категорией, а с третьей,
тут смотрите, что нужно сделать, у меня была третья
категория, это были позиции, из которых вниз и так был
переход по c, тогда на самом деле я и что мы сделали,
и мы cur вот этим вот, мы все, мы прошли всю целиком
вторую категорию, и все их как бы в листья превратили,
потому что вот у меня была позиция cur где-то вот здесь
например, а мне нужно было спустить терминальность
из нее вниз, и она спускается вот сюда, я завожу ребро,
делаю это листом, и говорю, что если раньше это было
суффиксом, то теперь это суффикс, и вместо cur я беру
getlink от cur, то есть по сути все вот эти вот шаги мне
уничтожают целиком вторую категорию, то есть все,
что раньше было второй категорией на предыдущем шаге, целиком
сливается в первую, потому что они все сразу становятся
листьями, значит cur в итоге, после этого всего cur будет
показывать вот сюда, на самый длинный суффикс, из
которого есть переход по c, ну и тогда, чтобы перейти
к следующему шагу, я просто должен эту самую терминальность
спустить здесь вниз по букве c, давайте я это нарисую.
То есть первой из второй категории мы разобрались,
дальше в третьей категории у нас после вот этого вайла,
после этого пока, и мне нужно здесь опять-таки из них
всех провести переход по c, ну причем из них и всех
он и так уже есть, мне нужно просто спуститься по нему,
тогда давайте я просто cur по символу c, то есть прочитаю
его из этой позиции, я из него могу однозначно прочитать
символ c, и на этом закончусь, потому что что мне нужно
от cur, мне нужно чтобы cur указывал на максимальный
не лист, максимальный суффикс не лист, ну все
большие суффиксы мы уже обработали, они стали листьями,
а это после прощения c, так, хочу сказать не будет
листом, ну да, но не будет листом, потому что в этот
момент времени все листья сейчас они уже заканчиваются
на доллар, поэтому прощение символа c меня точно в лист
не переведет, поэтому когда я здесь просто спускаю вот
это вот cur по букве c, я попадаю опять вне лист, самый длинный
суффикс, который не является листом, и для следующей
итерации, когда я здесь буду читать уже следующий
символ там d какой-то, у меня cur будет как раз указывать
туда куда нужно.
Третью категорию я вообще максимально лениво обрабатываю,
я здесь не спускаю все вот эти вот указатели вниз по
букве c, я спускаю вниз только первый из них, а все остальные
будут являться его с уксылками, то есть это будет getlink, это
дважды getlink, это трижды и так далее, то есть их я
как бы вообще не храню, я храню просто cur, вот он,
один он спустился вниз по букве c, все, а все остальные
автоматически как бы пересчитались, потому что все остальное
это многократный getlink от этой позиции, вот это
getlink от cur, это getlink от getlink от cur и так далее,
а поэтому все вот эти вот автоматически уже не спустились,
как только я cur вниз снес по букве c.
Итого алгоритм.
Ну, значит, база такая, когда у меня ничего не прочитано,
у меня есть только корень и cur равен корню.
Это когда я прочитал ноль символов.
Процедура добавления символа c в конец нашей текущей
прочитанной строке, add c.
Значит, что мы должны сделать?
Мы запоминаем, что cur, cur это у меня всегда указатель
на самый длинный ниней лист.
Ну, как бы корень я не считаю листом, это отдельная вершина,
которая даже если лист, мы как бы в листе не причисляем.
Значит, вот у меня есть cur, я должен пока из cur нет перехода
по c, явно его завести, завести переход по c, взять getlink,
ну и так прыгать, пока не появится переход по c.
Давайте это сделаем.
Я добавил, сейчас, одну секунду, вот тут немножко хитро
надо сделать.
Давайте напишу так, пока cur не равно root и c, нет перехода
по c.
Ну, если нужно расщепить ребро, если нужно расщепляем
ребро, создаем переход по отрезку c до конца строки,
ну и cur поднимаемся с помощью совсылки, cur равно getlink
от cur.
Так, while кончился, дальше в конце while мы либо пришли
в корень, из которого нет перехода по c, либо перешли
в нормальную вершину, из которой есть переход
по c.
Ну да, если из cur есть переход по c, тогда нужно просто
по нему перейти, как здесь написано, cur равно, где оно
у меня было, вот оно, go, cur, c, go, cur, c, это тот случай,
когда у нас была третья категория, я в нее попал
и мне нужно просто сделать спуск в ней.
Иначе, когда я прошел все дерево, я брал совсылки
кучу раз, брал-брал-брал совсылки и я не дошел до
вершины, из которой был бы переход по c, то есть третья
категория была пустая, мы дошли до самого корня
и даже из корня нет перехода по c.
В этом случае мне нужно просто создать переход
по c из корня, создать переход по, ну не по c, как обычно,
по отрезку с c до доллара, а из cur, который в этом
момент равен корню, и все, cur оставить корнем, весь
алгоритм.
Давайте пару слов про корректность, мы много здесь проговорили.
Значит, cur, напоминаю, это всегда должен быть указатель
на позицию максимальной высотой листа, в начале
это верно, корень мы листом не считаем, дальше, пока
нет перехода по c, создаем, соответственно, вот сразу
появляется лист, вот это вот то, что мы заводим,
сразу идет в лист, а дальше, cur, мне нужно подняться по
совсылке, взять следующий по длине суффикс.
Это происходит до одного из двух исходов, либо я
попал в третью категорию, и тогда в ней просто нужно
спуститься вниз, и как бы это будет наша текущая
cur, это будет самый длинный с ней лист, потому что все
вот это вот листья, а это спустилось в ней лист.
Или даже я всю вторую категорию целиком прошел, третьей
не было, я попал в корень, то есть иначе, вот если
if не сработал, то значит, я дошел на корня, и даже
из корня не было перехода по c, тогда нужно его просто
создать, а cur оставить в качестве корня.
Давайте здесь допишу, что cur остается корнем, cur равно
root остается, то есть он после вала стал корнем,
и он не меняется с этой вот этой штуки, потому что
я завел переход по длинному ребру до конца строки,
и при этом кур поменялся, у меня все позиции теперь
листья, у меня куча листьев, и есть листья, это корень,
и вот мне нужно оставить, что cur это корень.
Ну вот же картинка, смотрите, cur вполне была какая-то
позиция на ребре, вот она здесь была, необязательно
лист, да-да, не лист обязательно, здесь я его расщепляю.
Ну давайте быстро переобсудим асимптотику, почему это будет
линейное время от n, если считать алфавит константным,
если считать, что алфавит константным, если алфавит
не константно, то те же самые, что и в Боре у нас
могут быть, то есть мы можем либо в каждой вершине явно
хранить сигмы переходов, для каждой буквы хранить
есть такой переход или нет, и если да, куда оно ведет,
тогда будет n умножить на сигма памяти и столько
же времени, либо можем хранить в качестве мапы, в каждой
вершине хранить для каждой буквы есть такой переход
или нет, ну то есть хранить в мапе, в двойственном дереве
поиска все ребра упорядоченные по первой поиске, тогда будет
сигма, если мы можем мапу памяти, потому что ребер линейное
количество, ну вот давайте считать, что сигма константа
и все переходы можно ведет за единицу, находясь в вершине
я могу спуститься по ребру за единицу, значит тут есть
две проблемы, сложных моментов, во-первых, не понятно насколько
суммарно будет вайлов, потому что каждая обработка символа
это много вайлов, может быть много итераций кло-вайлов,
плюс это вот эта магическая гетлинг, которая тоже не
понятно сколько работает, мы знаем, что его время работает
по распространению числу пройденных ребер, а сколько
он проходит, фиг знает, ну во-первых, вайлов будет
не много, во-первых, итераций кло-вайлов,
так как каждая его успешная итерация заводит по крайней
мере один лист, нам это может каждый успешный вайл создает
ребро из ц по доллару, то есть создает лист, а листьев
мы знаем всего ровно столько сколько суффиксов, поэтому
суммарная успешная вайла будет не больше, чем число
суффиксов, так как каждая его итерация создает лист,
так как в конце листья это суффикс и наоборот, значит
вайлов на каждом конкретном этапе, на каждом конкретном
шейх может быть много, но суммарно их будет линейное
количество, потому что каждая успешная итерация это добавление
листа, вторая проблема с гетлинг, что происходит,
когда я много раз вешаю гетлинг, напомним, как у нас работает
гетлинг, был некий путь до вершинки п, было длинное
ребро, на котором мы пришли к символов, мы взяли линк
от к символов, и потом читаем вот эти к символов как-то
возможно используя несколько ребер, здесь для анализа
давайте я определю вину позиции, это число ребер на
пути позиции поз, именно ребер, сколько ребер мы
задействовали, чтобы попасть в позицию поз, так вот что
происходит с этой глубиной, когда я навешиваю гетлинг
на кур, давайте посмотрим, пусть здесь у меня был какой-то
кур, что происходит с глубиной, когда я навешиваю гетлинг,
ну во-первых сначала я перенесся в начало ребра, то есть уменьшил
глубину на один, потому что вот это ребро перестало
учиться, я сначала уменьшил глубину на один, первый
шаг, когда я от кура поднимаюсь к родителю, изменение глубины
это в точности минус один, дальше я от п беру левый
от п, что происходит с глубиной, вот я утверждаю, что на этом
этапе, когда я от п перехожу к суфсыл, я утверждаю, что
здесь изменение глубины больше либо равно чем минус
один, чуть позже я это покажу, ну и третье, каждый спуск вниз,
если я здесь делал м спусков вниз, то у меня увеличилось
на м, потому что я прошел м ребер, если прошли м ребер,
прошли м ребер, то дельта депс равно м, больше либо
равно чем минус один, сейчас мы это докажем, ну там 0,
1, 2 может быть, ну минус 2 уже не может, значит если
я это докажу, то есть а понятно, потому что я просто перестал
учиться, ве понятно, потому что ну сколько ребер прошли
настолько глубина увеличилась, если мы докажем ве, то тогда
понятно, что суммарное изменение может быть не больше чем
от м, потому что вот эта штука уменьшает на единицу,
это если уменьшает точность на единицу, а это вообще
А мы помним, что время работы этого генетика, это от м,
на я специально спрашивал, за сколько это работает,
за то, за сколько ребер мы здесь спустились вниз,
за от м, поэтому, поскольку суммарная глубина не может
быть больше чем n, да, у меня всего n вершин в дереве,
ну от n вершин в дереве, глубина никогда не может быть больше
чем n, от n, поэтому раз здесь, на каждом шаге, у меня глубина
уменьшилась максимум на 2 и потом увеличилась на
m, суммарно этих увеличений будет тоже от n, а ну раз
она ограничена с n, она уменьшается всего максимум на 2 на каждом
шаге, то суммарное увеличение будет от n, поэтому сумма
этих м будет тоже от n, то есть, чтобы все это завершить
мне нужно сказать только пункт b, значит он доказывается
так, вот у меня есть p, вот у меня есть линк от p, что
такое depth от p, это по сути число вершин на этом пути,
дальше, давайте возьмем ссылки от всех этих линк на
этом пути, я утверждаю, что они обязательно будут
на этом пути лежать, ну просто потому что все они отличаются
от отбрасывания вот этого первого символа, значит
если я знаю что, если ссылка
это, то вот это, то есть отбрасывание при derived
здесь,
актически часть бы a будет у меня в этом пути,
ну если здесь будет V-ли spir, то они тоже будут, мы это
с вами доказывали, что если у меня есть вершина, я взял
ее backs fine, то это будет
то все это тоже вершина.
здесь будет отвечать вершине поэтому число ребер на этом пути будет такой же
как здесь кроме возможно когда сух ссылка отсюда ведет вот сюда тогда у вас
только в этом случае у вас может уменьшиться на один число вершин на
этом пути именно отсюда возникает дельта депс больше ночи минус один то есть ну
в идеальном случае в самом простом будет просто биекция между вершинами и сух ссылками
вот такой да вот здесь будут вершины здесь будут их сух ссылки в худшем случае у меня будет ну не
совсем биекция вот такое будет здесь вершины а здесь их сух ссылки только корень как бы я не
учил меня будет на один меньше глубина вот здесь поэтому дельта депс может быть больше возможно
если еще кто-то фиг его знает вполне возможно но больше ночи минус 1 если есть отличие то не
больше чем на 1 все спасибо
