Добрый день, рад вас приветствовать на курсе алгоритмы модели вычислений.
К сожалению, я вынужден начинать его онлайн, но я надеюсь, что уже в следующий раз будет точная лекция.
Сегодня я буду использовать доску.
Можно к ней подключаться по этой ссылке.
Сегодня я сделаю такую вводную лекцию. Я сначала вкратце расскажу о чем вообще курс, как он будет устроен,
что мы будем изучать, какие нас вопросы будут интересовать, а потом расскажу некоторые вводные вещи.
Дать я представлюсь. Меня зовут Даниил Владимирович Мусатов.
Я работаю на кафе 30-летней математики с Андреем Михайловичем Рыгородским уже много лет.
Этот курс я читаю в третий год, но до этого я читал похожий курс на фифте под названием сложности вычислений,
но продолжаю его читать. Он не совсем такой же, акценты немного другие, но в целом похожий.
Если нужны будут координаты для связи, есть email.com, также можно писать в Telegram тем же именем.
Еще у нас в Telegram есть каналы и чат, они остались с позапрошлого года.
Соответственно, можно их использовать.
Вот такой вот, давайте я его сюда в чат пошлю.
Вот этот канал и также есть чат.
Соответственно, важные новости будут появляться в этом канале.
В чате можно задать вопрос. Все из канала дублируется в чат.
Еще важные вещи, как устроена отчетность по курсу.
Глобально она так устроена. Отчетность, что это дифференцированный зачет.
Соответственно, состоит из двух контрольных работ.
Три оценки, контрольная 1, контрольная 2 и работа в семестре.
Работа в семестре это на усмотрение семинариста.
Могут быть какие-то маленькие контрольные на 20 минут на семинаре.
Могут быть какие-то домашки. Может быть просто работа на семинарах.
Это все на усмотрение семинариста.
Оценки за три работы складываются, усредняются. Это будет итоговая оценка.
Но там есть некоторые детали. Это не прям совсем так происходит.
Точные правила я думаю выложим. Вроде их уже написали.
Вот уже и есть этот файл.
Важно их составлять в работе в семестре.
Какой-то зачет по теории.
Детали будут записаны в этом канале.
Теперь давайте по сути.
Если какие-то вопросы останутся после текста, тогда вы их зададите.
Какой план курса? Что мы вообще изучаем?
Основной вопрос. Какие алгоритмические задачи решаются эффективно?
Если эффективно, то как, а если нет, то почему?
Если решаются то как, а если нет, то почему?
В этой лекции вы в канал выложите?
Да, я еще сделаю папку, где будут все материалы лежать.
Появятся какие-то материалы.
У нас будет большой файл со всякой программой, задачами и так далее.
Если по ходу дела что-то будет появляться, то оно будет выкладываться.
Это основной вопрос.
Дальше конкретные темы.
Основные части курса.
Первый это вопрос о равенстве P и NP.
Это фундаментальный вопрос.
Более того, этот вопрос входит в список из семи задач тысячелетия, за которые дается премия в миллион долларов.
Ему в прошлом году исполнилось полвека его фактической постановки.
Соответственно, он пока не решен.
Если кратко, то класс P это задачи, которые быстро решаются, а NP это задачи, которые, может быть, быстрее не решаются.
Но если на них ответ положительный, то тогда это можно быстро доказать и проверить.
Вопрос о равенстве.
Есть у него такое название «проблема перебора».
Универсальным образом сократить полный перебор.
Если задача решается полным перебором, то можно ли ее как-то иначе решить.
Вторая тема — это другие сложностные классы.
Это связанная логарифмическая память, вероятностные вычисления, логические схемы.
Глобально этот вопрос, какие задачи решаются эффективно, какие нет, наука отвечает большой классификацией.
Наука очень любит что-то классифицировать.
В частности, сложность вычисления классифицирует алгоритмические задачи.
Она их раскладывает по полочкам, которые называются сложностными классами,
которые определяются необходимыми ресурсами, которые нужны для решения той или иной задачи.
Это пример таких классов.
Есть целый зоопарк, несколько сотен.
С несколькими из них мы познакомимся.
Вторая часть курса — это хорошая сторона сложных задач.
Использование в криптографии и других подобных вещах.
Криптография — это основная вещь, где нужны сложные задачи.
Есть еще несколько вещей, связанных с вероятностью.
Выясним, что задача трудно решаемая.
Как это хорошо или плохо?
С одной стороны, это плохо, если задача нужна.
Если нам нужно найти хороший рецепт чего-нибудь, хороший производственный план,
хорошую транспортную сеть и так далее, то если у нас не получается этого найти,
то это вообще не очень хорошо.
Особенно если на самом деле решение есть, а мы его не можем найти,
и из-за этого действуем неэффективно.
И тогда плохо, что задача не решается.
С другой стороны, если это задача взлома шифра, а шифр как раз наш,
то это наоборот как раз хорошо, что она не решается.
И на базе сложных задач можно как раз построить криптографические протоколы
или какие-то хорошие генераторы и так далее.
Ну и дальше еще есть четвертая часть.
Это, наоборот, внутри П.
Я назову так, избранные полинамиальные алгоритмы.
Посмотрим уже в конце семестра, сколько останется.
Может быть, что-то на семинары уйдет.
Некоторые алгоритмы классические.
Мы изучим какие-то алгоритмы на графах или быстрое преобразование в фурье.
В общем, про это поговорим.
Первые две части побольше, наверное, по пять лекций будут.
А третья и четвертая примерно по две лекции.
Ну и дальше.
Ну и дальше.
Ну и дальше.
Ну и дальше.
По две лекции.
Ну и в принципе в конце курса возможны вариации.
Так.
Можете кинуть вопросы.
Официальные лекции будут только в трансляции.
Не, вообще лекция планируется в аудитории. Я просто немножко болею.
И надеюсь, что в следующий раз будет в аудитории.
Но там не по идее записываться будут.
Хорошо. Здравствуйте.
Да, спасибо.
А будет интерзапись или анонимация?
Я не знаю, как это будет устроено.
Там это немного зависит от доступной техники и так далее.
Викторий ФПМИ планирует записывать только матан в этом семестре на нашем протоке.
Да?
Да.
Ну ладно. Изучим вопрос.
А, вон литература еще точно.
Забыл.
Мой вопрос.
Лекции прошлого года будут сильно отличаться от существующих, которые вы будете сейчас читать.
Просто если не будут описываться, то мы бы их посмотрели тоже, если бы там пропустили.
Да, по первым двум частям, наверное, не сильно будут отличаться.
А там в конце посмотрим.
А их всего?
Частей всего?
По первой части примерно 10 лекций.
Вот они вряд ли будут сильно отличаться.
А в конце там может быть какая-то...
Про четвертую мы в прошлый раз почти не успели поговорить.
Еще 2-3 февраля пропадет.
В мае, правда, не будет ничего пропадать.
У нас, видимо, 14 будет лекций.
Да, литература.
Правильный вопрос.
Литературы вообще довольно много, разные.
Есть действительно черные к моей книжке.
Не знаю, может быть, она и будет как-то улучшаться.
Но вообще последний год я там почти ничего не делал.
Но с другой стороны, у меня накопилось некоторое количество материала,
которое я, может быть, включу прямо в текст.
Вот.
Но, правда, эта книга гораздо больше включает.
В принципе, она включает содержание примерно 3 курсов,
3 курсов, которые я читаю на 50 и на нашей кафедре.
Вот.
Так что это заведомо почти для всего хватит.
Но есть и другие книги, которые мне очень нравятся.
Они в основном на английском языке.
Мне очень нравится книжка Сипсера под названием
Reduction to the Theory of Computation.
Там нужна в основном часть третья.
В первой части теория формальных языков.
Там различные автоматы, контекст свободной грамматики.
Во второй части там классическую теорию числимости, машины тюринга,
числимые функции, разрешимые множество, проблемы остановки и так далее.
А в третьей части довольно сжато и кратко написаны основы сложительных отчислений.
Но там, по-моему, не все есть логнической памяти.
Не, наверное, есть, но может быть кратко.
Но книжка написана довольно доходчиво.
И что мне особенно нравится в каждой теореме,
там есть отдельно идеи доказательства и саму доказательство.
Там это разделено и действительно позволяет сначала ухватить основную идею,
а потом понять, как эта идея формально реализуется.
Дальше есть две книги, которые примерно одновременно вышли,
примерно одинаково называются.
Есть одна книжка Aurora Barak, называется Computational Complexity and Modern Approach.
Другая книжка Галдрайха.
Она тоже называется Computational Complexity.
A Conceptual Perspective.
И они такие довольно фундаментальные, всеобъемлющие.
Они годятся не как первый учебник, а как руководство для более глубокого изучения.
Они довольно похожи по набору тем, но разные по стилю изложения.
У Галдрайха все довольно занудно, но с другой стороны кому-то может так понравиться, что все формально.
И с другой стороны, оправдывая название Conceptual Perspective,
он все выстраивает в некоторую стройную картину, концептуальную перспективу, как это все друг другу связано.
Есть в принципе у Галдрайха и более кратенькая книжка.
Я тоже напишу.
Галдрайха.
Более узкая. P&P & NP Completeness.
Вот такая вот книжечка.
Тут, как вы видите, в качестве иллюстрации сложные задачи.
Здесь какие-то пятнашки.
Вторая книжка выглядит вот так.
Здесь как раз видны вот эти всякие классы.
Вот они P&P, там Q&P.
В основном мы вот эту часть будем изучать, она и вот эту еще.
А вот эту над водой.
Мы из этой книжки не будем изучать.
Извините, пожалуйста, вы показываете сейчас что-то, кроме айдро?
Нет, я показываю в камеру.
Понял.
Да, я показываю в камеру.
На экран я, наверное, не смогу, но вы можете погуглить и найти картинку.
Еще одна очень красивая книжка есть.
Это авторы Мурри Мертонс.
Nature of Computation.
Эта книжка очень толстая.
На тысячу страниц.
Там действительно много всего написано.
Дополнительные темы.
Что мне нравится, там много иллюстраций.
Откуда-то из других смежных дисциплин.
Типа из инженерии, из истории и так далее.
Из истории техники в основном.
Есть отдельные конспекты на русском языке.
В общем, вы тоже можете их искать.
Там есть книжка Крупского, Мертонс.
Ну ладно.
На этом, наверное, по литературе достаточно.
В общем, тут источников довольно много.
Конечно, они по темам...
А, но есть еще классическая книга по Демитрию.
Уже почти тридцать лет недавно.
А, есть еще более классическая книга.
Вот ее, наверное, все-таки помину.
Она переведена на русский.
Значит, Гэри и Джонсон.
Вычислительные машины.
И трудно решаемая задача.
Демитрию давай тоже упомяну.
Это вопрос компьютерского комплекса, кажется.
Что-то книжка Гэри и Джонсона хороша тем, что там есть большой-большой список НП полных задач.
То есть она не очень большая.
Там примерно триста страниц.
Написано в 1979 году.
Она гораздо ближе ко времени начала всей этой науки, чем к нашему времени.
С теоретической точки зрения она, в общем-то, устарела.
Ну, как устарела, да?
Те вещи, которые там написаны, они остаются актуальными.
Просто гораздо больше нового появилось с тех пор.
А вот список НП полных задач вполне актуален.
И можно с ним прям работать.
Ну, хорошо.
Теперь, наверное, можно двигаться дальше.
Сегодня я хочу поговорить про суть проблемы PNP.
Формальное определение.
Значит, суть проблемы PNP.
Да, значит, формальное определение и формальное рассмотрение оставить на следующий раз.
Значит, суть проблемы Ryanst PNP.
Так, смотрите, если коротко.
Во-первых, нужно понимать, что речь идет о задачах распознавания.
То есть задачах с бинарным ответом.
Да или нет?
Можно считать, что ставится задача понять, принадлежит ли входное слово X
к некоторому заданному языку.
Ну, языку, то есть просто множество.
Тут так исторически сложилось, что в начале этой науки изучалось много приложений к лингвистике.
И вообще в 50-е годы очень оптимистично смотрели на машинный перевод и машинное общение.
И вообще искусственный интеллект.
Думали, что умные люди соберутся, посидят пару месяцев и напишут искусственный интеллект полномасштабный.
Реально в 50-е годы было такое летнее мероприятие, где бы прям так и стало.
И думали, что не, ну ладно, может быть мы искусственный интеллект не создадим, но уж переводчик-то мы сделаем.
Но в результате только сейчас, через много десятилетий, до какого-то приемлемого уровня автоматический перевод наконец дошел.
Соответственно, вот с того времени ставятся задачи, ну в смысле используется термин язык, термин слова.
А в принципе под этим словом можно понимать все что угодно.
Это может быть описание, может быть просто число, записанное цифрами.
Это может быть какой-то более сложный объект типа матрицы или многочлены.
Это может быть граф.
Это может быть какая-то, в общем любая структура может быть скодирована словом.
И соответственно про эту структуру нам нужно понять, обладает ли она некоторым свойством, что мы выражаем тем, что принадлежит ли она задному языку.
Вот, хорошо.
Вот, ну соответственно, извините.
Значит есть n.
Значит это, как говорят, размерность или размер задачи.
Ну, как правило, это просто длина входа.
Как правило, длина входа просто в символах.
Ну или в битах.
То есть если у нас какой-то непинарный алфавит, то можно закодировать и в бинарном алфавите.
Длина умножится на логарифм размера алфавита.
Вообще какие-то такие простые вещи.
Вот, соответственно дальше p.
Это класс задач распознавания, которые можно решить за время пленом от m.
Да, то есть в принципе x может быть какой угодно и размером может быть какой угодно.
Но соответственно нужно, чтобы время росло как размер в какой-то степени.
Ну и еще может быть какую-то константу.
То есть меньше, чем c на n степени d.
Для каких-то констант c и d.
Ну и соответственно считается, что p это класс задач, решаемых эффективно.
Ну и вообще такое утверждение можно оспорить.
Причем с двух сторон.
С одной стороны мог быть задач fp, которая на самом деле сложная.
Потому что здесь любые константы c и d.
Если у нас будет d равно ну даже 10, то тогда уже для довольно маленьких n это уже будет очень много.
Два в десятые это тысяча.
Четыре в десятые это уже миллион.
Восемьдесятый это миллиард.
А уже там скажем сто в десятый.
И это уже такая величина, которая в общем...
Ну сто в десятые это сейчас где-то на грани.
На грани того, что теоретически можно сделать.
Уже там пятьсот в десятые это уже заведомо недостижимо.
А если d уже будет само по себе сто, тогда уже десять сотой степени это уже страническая величина.
И такое число операций сделать заведомо никогда не получится.
И вот эта константа c тут в принципе тоже произвольная.
Может быть даже d какой-то маленький квадрат.
Ну зато c какие-нибудь там квадрильоны.
И все равно получается, что нам нужно огромное число операций.
Это с одной стороны возражение.
С другой стороны возражение есть такое, что известен симплекс метод решения задач линейного программирования.
У вас видимо не было еще.
Это максимизация линейной функции при условии линейных неравенств.
Соответственно симплекс метод теоретически работает больше.
На некоторых входах дать я вот это еще уточню на любом входе.
На любом входе можно решить.
Симплекс метод на некоторых входах экспедиционно долго, но в среднем как правило он работает очень быстро.
Реально для тех же задач есть другие алгоритмы, которые как раз формально лежат в классе p.
Точнее в классе p лежит задача, то есть задача линейного программирования лежит в p.
Но тем не менее решается она не теми полиномиальными алгоритмами, которые для нее известны,
а симплекс методом, который теоретически работает.
Соответственно это определение ловит не очень хорошо с другой стороны.
Но тем не менее оно достаточно общепринято.
Большинство задач лежащих в p решаются эффективно и на практике.
А даже если на практике задача не решается пока что, то бывает так, что придумывают новые алгоритмы, которые практически работают лучше.
Или может быть так, что они решаются в другом смысле, точно так же как с линейным программированием.
Есть полиномиальные методы, которые на практике работают плохо, есть симплекс метод, которые на практике работают хорошо.
Есть также еще известная задача проверки простоты.
Теоретически решаются с алгоритмом трех индейцев, Нагровала, Каяла и Саксена.
И тоже там как раз шестая степень полинома.
Кстати, когда я говорю о проверке простоты, то это N это не само число, а его логарифм.
Потому что число знаков, которым записывается число, это логарифм от самого числа.
Но соответственно для задач проверки простоты теоретически есть алгоритм трех индейцев, которые работают в полиномиальное время.
Но на практике обычно используются вариации алгоритма, которые мы тоже будем изучать.
Так, хорошо, это все было P, теперь N, P.
Да, P от слова полиномиал.
А N, P, может быть это нот-полиномиал, но на самом деле это нондетерминистик.
Ну и может быть в следующий раз я расскажу, откуда взялся этот нондетерминистик.
А пока я расскажу другое определение.
Здесь определение такое, если ответ положительный, то для этого факта есть сертификат полиномиальной длины.
Корректность которого можно проверить за полиномиальное время.
То есть, получается, есть отдельно некоторые вот такой VATXS.
Значит, здесь X это вход, а S это сертификат.
И соответственно VATXS проверяет корректность S.
То есть верно лишь, что S действительно подтверждает, что X обладает задним свойством.
В чем можно сказать так, что X лежит в A, тогда и только тогда, когда существует S такое, что VATXS равно 1.
Ну и сразу получается переборный алгоритм для NP.
Значит, переборный алгоритм для NP это перебрать все возможные S.
Ну какой-то вот задний полиномиальный длинный.
Значит, известный полиномиальный длинный.
Ну и соответственно, суть, значит, задача P равно NP.
Это есть ли универсальный способ сократить этот перебор до некоторого полиномиального алгоритма.
Ну вот никто не знает.
Давайте я покажу пару примеров.
Пример. Раскраска графа.
Значит, классическая задача.
Известна также проблема четырехкрасок, что любую карту на плоскости можно раскрасить в четыре цвета.
Также есть задача о хроматическом числе плоскости.
В какое минимальное число цветов можно раскрасить плоскость так, чтобы любые две точки настояний один были разного цвета.
И эта задача пока не решена, но получена нижняя оценка 5.
Опять же, не так давно, примерно пять лет назад.
Но мы пока не будем касаться вот таких открытых проблем.
Определим так.
Пусть дан граф, который состоит из множества вершин, множество ребер.
Здесь w это множество вершин, e это множество ребер.
То есть пар вершин.
Вопрос, существует ли правильная раскраска вершин в к цветов.
Формально, что это за раскраска?
Это такой простой математический объект.
Это функция c из множества вершин в множество одного дока.
Такая, что если у нас есть ребро любого u, v, верно, что раскраска u не равна раскраске v.
Ну и оказывается, для разных k статус этой задачи разный.
Но сначала есть тривиальный случай.
Тривиальный случай, когда k равно 1.
Можно ли вершины графора покрасить в один цвет?
Но это более очевидно, что если нет ни одного ребра, то можно.
А если хотя бы одно есть, то нельзя.
Если есть хотя бы одно ребро, то нельзя.
А если граф пустой, то можно.
Дальше есть простой случай.
k равно 2.
Тут, конечно, можно было бы устроить перебор.
Можно устроить перебор, рассмотрев все два в степени n вариантов.
Тут я имею в виду, что в графе n вершин.
На самом деле этого делать не нужно.
Однако этого делать не нужно, и работает жатный алгоритм.
Я думаю, что многие понимают, но давайте я нарисую, как он работает.
Пусть у нас есть...
Пусть у нас есть, например, вот такой граф.
Давай его можно раскрасить.
Вот этот красим в красный цвет.
Например, дальше всех его соседей в синий цвет.
Дальше всех соседей соседей в красный цвет.
Дальше всех соседей соседей в синий.
Ну и так далее. Пока все не закончится.
Ну а когда все закончится?
Ну, когда мы покрасим компоненту связности.
Или может все закончится, когда мы придем в противоречию.
Например, если у нас еще есть вот здесь вот две вершины, и они еще друг другу соединены.
То дальше по этому правилу мы должны покрасить вот это вот в красный цвет, и вот это тоже в красный цвет.
Но после этого получилось, что у нас две соседей вершины соединены ребром.
Нет противоречия.
Если получилось в противоречию, значит есть нечетный цикл.
То есть как работает жадный алгоритм.
Значит, красим первую вершину в красный цвет.
Всех ее соседей в синий.
То дальше всех соседей в красный и так далее.
В итоге либо будет покрашена компонента связности,
и тогда нужно продолжать красить, когда аналогично красим остальные.
Ну, либо в какой-то момент вообще все закончится,
либо в какой-то момент появится противоречие.
Вот, говорите, появятся две соседние вершины, покрашенные одинаково.
Вот, дальше тогда получится.
Значит, тогда в графе есть нечетный цикл.
Соответственно, тогда он не может быть покрашен на два цвета.
В данном случае нечетный цикл из трех вершин, треугольника.
Ну, дальше получается, что в любом случае мы каждую вершину красим максимум один раз,
и любое ребро анализируем максимум один раз.
В ходе алгоритма к каждому ребру происходит не более одного обращения,
поэтому алгоритм полиномиальный.
Ну вот, получается, что не нужно перебирать, а нужно вот так вот жатно красить, и это быстро сработает.
Вот, так же есть сложный случай.
Значит, сложный случай.
k равно 3.
Ну а, соответственно, следующие будут еще более сложными.
Так, значит, тогда тут уже жадный алгоритм не будет работать.
Почему? Если у новой вершины все соседи одного цвета, то для нее есть два варианта.
Вот, и из них не понятно, какое предпочесть.
Значит, выбор одного из них может повлиять на возможность завершить раскраску через много шагов.
Вот, если бы был просто выбор из двух вариантов, это было бы еще не страшно.
Но плохо то, что подобные выборы еще и вложены в друг друга.
А что такое жадный алгоритм?
Не, ну вообще жадный имеет в виду следующее.
Это общий термин, что мы рассматриваем какие-то объекты по очереди, и каждому следующему даем что-то подходящее и более-менее не думаем о будущем.
Вот здесь это не будет работать.
То есть если мы как бы играем, берем и красим по очереди во что получится.
Ну вот, если мы берем и красим по очереди во что получится, то тогда у нас может быть так, что есть два варианта раскраски.
И один вариант через много шагов приведет ко другому.
А если мы попробуем один, а у нас новый выбор из двух, потом мы там выбрали, у нас новый выбор из двух и так далее.
Если у нас возникает для каждой десятой вершины, то в итоге получится два в степени n на 10 вариантов, которые все равно нужно перебирать.
То есть такой вот наивно-жадно алгоритм точно не работает.
Но на самом деле никакого другого алгоритма тоже неизвестно.
Никакого другого алгоритма тоже неизвестно.
Ну а если k больше трех, то то же самое. Все еще хуже получится.
А если k больше трех является?
Нет, в NP это является.
То есть перебор там все равно решается.
Значит, в NP задача лежит при любом ка.
Перебор работает, или можно сказать так.
Ну например, если решать перебором, то его можно отнести классом.
Ну не совсем так на самом деле.
Это именно если такой перебор, что достаточно одного корректного варианта.
Мог бы и более сложно, значит, который тоже перебором решается.
То есть если раскраска дана, то ее правильность можно проверить.
И это как раз то, что у нас вот здесь.
S это раскраска. Ой, только я тут неправильно написал.
Вот, кстати, возвращаясь к этому определению, не совсем понятно, что такое сертификат.
А что угодно. Это просто любая строка, которая как-то интерпретируется.
В случае с раскраской сертификат – это сама раскраска.
Ну, то есть как таблица функций.
Вессон, соответственно, проверяет вот эту.
То есть соседние ребра покрашены в разные цвета.
Ну и более-менее ясно, что такая проверка – это довольно простая полиномиальная вещь.
Вы говорили, для четырех цветов существует раскраска карты.
Это именно карта.
Карта – это планарный граф.
И дальше смотрите, как я здесь нарисовал на плоскости, здесь у меня ребра не пересекаются.
Соответственно, любой планарный граф можно раскрасить в четыре цвета.
И более того, планарность на самом деле можно проверить за полиномиальное время.
Это не так просто, но там есть некоторые алгоритмы.
Тем не менее, это не опровергает, потому что мы можем проверить планарность.
Если граф планарен, то мы скажем, что граф красится в четыре цвета.
Но может быть, граф не планарный, а все равно красится.
Поэтому, соответственно, если мы выясним, что граф не планарен, то не знаешь, что он не красится.
Так что нет, тут никакого противоречия нет.
Еще есть из теории графов классическая картинка.
Давайте я ее нарисую.
Но я думаю, что вы ее знаете.
Она как бы картинка такая.
Вот так вот.
Дальше вот так вот.
Вот так вот.
Примерно я так нарисовал.
Это кюнисберские мосты.
Такая вот картинка.
Это приблизительное изображение Средневековой Кюнисберга.
Это было четыре части города, две части на двух берегах реки и два острова.
И между ними были вот так вот устроены мосты.
Задача была такая, что устроить прогулку по городу, пройдя ровно один раз по каждому мосту.
Ну и вот Эйлер про эту задачу думал и фактически в результате создал теорию графов.
Он сказал, что нельзя так сделать, потому что здесь вот четыре части и с каждой нечетное число мостов.
Отсюда три, отсюда три, отсюда три и отсюда пять.
А когда происходит прогулка, тогда мы заходим, выходим, выходим, выходим.
И каждый раз у нас с парами встречаются эти самые мосты, кроме начала и конца пути.
Из начала пути мы только выходим, в конец пути только приходим.
Ну а здесь у нас не ноль и не два участка, из которых нечетный число мостов, а четыре.
Поэтому тут не может быть такого маршрута.
Это задача Эйлер в пути.
Можно ли пройти по графу?
Посетив ровно один раз каждое ребро.
Вот, ну есть критерии Эйлера.
Есть такой путь.
Есть Эйлеров путь из S в T.
Тогда и только тогда, когда верно две вещи.
Во-первых, граф связан.
То есть какой-то путь есть до любой вершины.
Ну или, по крайней мере, можно разрешать или запрещать еще отдельно изолированная вершина.
Изолированная вершина ни одного ребра не дает, поэтому с одной стороны ее посетить нельзя,
но с другой стороны можно и не требовать.
Такую оговорку сделаем, возможно, за исключением изолированных вершин.
Ну а второе, то есть число ребер, которые входят в вершину,
в степени S и T нечетная, в степени остальных вершин четная.
Но если речь идет не о пути, а о цикле, тогда, соответственно, у всех вершин должна быть четная степень,
потому что цикл приходит туда же, откуда начал, и тогда, соответственно, там тоже будет четная степень.
Один раз вышли, один раз пришли, и, может быть, несколько раз пришли и ушли.
Хорошо, соответственно, обе части критерия могут быть проверены за полномерное время.
Но степень – это вообще довольно простая вещь.
Просто идем по списку ребер и считаем, сколько раз у нас встретилась вершина.
Связанность немножко более сложная, но она примерно похожим образом тоже такой.
Раскраской делается или поиском в глубину, в общем, много есть разных способов.
Так, а еще и задача о гамильтоновом пути.
Или есть вход на задачу Кумиева и Ажора.
Задача о гамильтоновом пути.
Значит, или задача Кумиева и Ажора.
Значит, можно ли пройти по графу, посетив ровно один раз каждую вершину.
Задача Кумиева и Ажора обычно там еще на каждом ребре есть расстояние.
Нужно не просто посетить каждую вершину, а еще и затратить суммарное меньшее расстояние.
Задача Кумиева и Ажора.
Нужно проехать суммарно.
В общем, ребра взвешены, и нужно проехать суммарно как можно меньше расстояния.
Но в принципе, когда я говорю, как можно меньше расстояния, это не совсем вопрос да или нет.
Можно ее превратить в вопрос да или нет, поставив его так.
А можно ли проехать меньше, чем данный порог?
На первый взгляд изменение небольшое.
Однако подобных простых критериев неизвестно.
Ну и как и быстрых алгоритмов проверки гамильтоновости.
Правда, конкретно задача Кумиева и Ажора на практике решается довольно хорошо.
В теории она решается сложно, но есть довольно много таких евристических методов, которые неплохо работают.
Но при этом задача лежит в НП.
Если гамильтонов путь задан, то можно проверить, что он гамильтонов.
В данном случае получается, что х это граф, ну и, возможно, начальная конечная вершина.
То есть перестановка В проверяет гамильтоновость.
Ну и, возможно, начальная конечная вершина.
Х граф, С путь. То есть перестановка В проверяет гамильтоновость.
Ну и оказывается, что подобное небольшое изменение очень часто меняет статус.
Еще один пример приведу. Проверка числа на простоту.
Это задача ИСП. Однако так просто я это уже не смогу объяснить.
Это алгоритм Гравала Каяла-Соксене.
А при этом поиск делителя это уже задача из НП.
Проверка на простоту и то же самое, что проверка на составность, то есть проверка на наличие делителя.
А проверка на наличие малого делителя это уже неизвестно как решать.
Значит быстрого алгоритма неизвестно. Впрочем известен быстрый квантовый алгоритм.
Есть такая модель вычислений квантовые алгоритмы или квантовый компьютер, который как раз умеет раскладывать числа простым множителем.
Его не умеет классический алгоритм.
И на самом деле это ровно то место, где неизвестно МП полноты.
Проверка на наличие малого делителя имеется в виду поиск наименьшего?
Ну смотрите, поиск наименьшего это задача поиска.
Если задача да или нет, то пусть у нас есть число N, есть какой-то порог там T.
И спрашивается, есть ли делитель меньше чем T, но больше чем 1.
И тут поленом будет браться от N, а не от PN.
Нет, а поленом от логорифмов.
Поленом от длины записи, то есть от отбитой длины, то есть от логорифма N.
По пути будет зависеть полиномиально от размера графа в предыдущей задаче по комбинатурному пути?
Сейчас, кто будет зависеть полиномиально?
Количество путей.
В том-то и дело. Если бы их было всего полиномиальное число, их можно было бы перебрать.
Но если там совсем тривиальный оценка, то их будет N-факториал.
Любая перестановка может быть путем.
Если немножко более поумного, то N-факториал даже больше, чем экспонента н в степени N.
Если немножко более умно перебирать, то можно сделать константа в степени N.
Но это экспоненты в любом случае.
Многие задачи...
В любом случае задача из NP.
Я закончу.
Это задача из NP.
Потому что если делитель дан, то можно проверить, что это делитель.
Многие задачи из NP являются самыми сложными.
NP-полными.
Это означает, что все остальные к ним сводятся.
Научившись решать одну NP-полную задачу,
можно решить и все остальные задачи из NP.
Что в точности означает сводимость, мы будем говорить в следующий раз.
Но сама суть очень важна.
Многие из NP-полных задач важны для практики.
Многие ученые пытались, а также не ученые, а любители придумать эффективный алгоритм.
Их решение, однако, ничего не получилось.
За эти 50 лет, которые прошли, и еще несколько лет до этого,
при этом есть такой эффект стеклянного забора.
Во-первых, почти все задачи либо лежат в P, либо NP-полны.
Впрочем, поиск малого делителя – это одно из немногих исключений.
Разложение на множители это называется.
Это одно из немногих исключений.
Непонятно, откуда он возникает.
Небольшое изменение условия может перевести задачу из одного класса в другой.
Это два примера, которые мы видели выше.
Замена двойки на тройку изменила из P на NP-полное.
И замена ребра на общечение всех вершин тоже изменила из P на NP-полное.
Но наличие этого стеклянного забора – это, мне кажется, самый сильный аргумент в пользу того, что P не равно NP.
Если бы было, что P равно NP, то тогда все задачи были бы сразу и в P, и NP-полное.
Все задачи из NP.
Кроме двух исключений, это задача, где всегда ответа, и задача, где всегда ответа нет.
Давайте я эту оговорку сюда все-таки вставлю, кроме пустого множества.
И наоборот, все возможные слова из 0 единицы.
Получается, что мы видим совершенно не такую картину, а что есть отдельно.
Это серьезный доус в пользу того, что на самом деле они не равны.
Но, конечно, это не доказательство.
Это не доказательство, а доказательство – это открытый вопрос.
Оказывается, что за 50 с небольшим лет, которые прошли, за прошедшие полвека задача равны ли P и NP?
NP не была решена.
Однако были найдены препятствия к ее решению.
То есть выяснилось, что целый ряд методов решения заведомо не сработают.
Несмотря на то, что задача не решена, некоторый прогресс был, но прогресс от итоговой точки, можно сказать, мы еще дальше находимся, чем 50 лет назад.
Теперь мы гораздо лучше знаем, как это не нужно доказывать.
Я не смогу подробно рассказать про эти препятствия.
Но идея такая, что доказательство, которое работает, не должно подпасть под некоторые ряд условий.
Соответственно, из-за того, что за задачу дают миллион долларов, многие непрофессионалы начинают ей заниматься.
Им кажется, что они нашли доказательства иногда в ту сторону, иногда в другую сторону.
Есть и экзотический вариант, что это утверждение, которое не зависит от остальных аксиомов.
Иногда и его заявляют.
Но тем не менее, особенно в случае, когда доказано, что они не равны, требуется объяснить, почему доказательство не подпадает ни под один из методов, которые заведомо не сработают.
И как правило, 90% попыток в этом месте отсеиваются.
Оставшиеся 10% иногда занимают научное сообщество на некоторое время, но они довольно быстро находят ошибку.
Пока что регулярно бывает, что очередной любитель или профессионал заявляет, что доказал, что П равно НП или что П не равно НП, вывешивает доказательства,
но потом энтузиасты находят ошибку, и после этого все возвращается на круги свои.
Соответственно, про то, в чем заключаются эти препятствия, я не знаю, может быть, в какой-то момент сделаем еще разговор.
Но ближайшие наши планы – это изучить теорию НП-полноты, доказать в частности, что выше указаны две задачи НП-полные про раскраску и про Демельтонов путь.
Ну и изучить ряд других НП-полных задач. Это на 2-3 лекции следующий наш план.
Я надеюсь, что в следующий раз я смогу приехать, но гарантировать не могу.
В любом случае, спасибо за внимание. Если остались какие-то вопросы, то задавайте. А так, в принципе, время даже закончилось.
А длина проверки правильности сертификата должна быть полиномиальная от длины сертификата или от длины входа?
О, это хороший вопрос. Значит, на самом деле, как я тут написал, это неважно.
Потому что здесь написано, что и сам сертификат по полиномиальной длины, а тогда полином от полином – это полином.
Но в принципе, можно вот эту оговорку не делать, но тогда говорить, что он полиномиален длиной Х обязательно.
То есть проверка совершается полиномиальной длиной от Х, да?
Да, но если сертификат сам полиномиальный длины, то тогда полином от Х и полином от С – это одно и то же. Хотя сами полиномы могут быть разные.
Да, понял, спасибо.
