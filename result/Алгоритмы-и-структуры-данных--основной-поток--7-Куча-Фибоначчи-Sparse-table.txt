Всем добрый вечер. Давайте начинать. Продолжаем разговор про кучи. Давайте красненько напомним,
что было в прошлый раз. В прошлый раз мы говорили про, в частности, говорили про биномиальную кучу.
Это куча, которая, в отличие от бинарной, позволяет нам еще быстро их сливать. Если есть две
корректные биномиальные кучи, мы хотели бы научиться объединять элементы, которые лежат хотя бы в одном
из них, в одну большую кучу. То есть два множества объединить в одно. Два мультимножества точно.
Теперь давайте научимся делать все то же самое, только быстрее, с помощью фибоначевой кучи.
Фибоначи его куча. Она же куча фибоначи. Как хотите, так и называйте. Сразу дисклеймер,
что она умеет делать и за какие симптотики. Инсерт. Она умеет делать за чистую единицу.
Гетмин, как обычно, тоже за чистую единицу. Мёрдж, внезапно, тоже за единицу. Декриски
за амортизированную единицу. Она же учетная. Это то, что было в прошлый раз,
про амортизированную стоимость в этом самом смысле. Со звездочки, то есть учетная стоимость
равна единице. Напоминаю кратко, что это значит, что на самом деле выполнение каждого конкретного
декриски может быть довольно долгим по времени, но если вы будете считать, что это работает за единицу,
сложите верхние оценки на все вот эти вот функции, то это будет верхняя оценка на реальное время работы.
То есть каждое конкретное возможно работать дольше, но суммарно, как если бы здесь была единица.
Так, ну и последний экстракт-мин остался. Экстракт-мин работает за сколько бы вы думали.
Могу ли я здесь написать единицу, например? Единица здесь очень вряд ли, потому что мы
доказывали простой факт, что если у нас в куче и инсерт, и экстракт-мин работают за единицу,
то мы умеем сортировать за отен. Чего мы, скорее всего, не умеем на самом деле. Точнее, мы точно не
умеем, коль скоро куча на сравнениях. Вопрос какой-то? Да, значит здесь будет амортизированный логарифм.
Единицы, к сожалению, не получится, но ас логарифмом получится. Вот смотрите, ну ничего,
довольно хорошо по сравнению со всем, что было раньше. По крайней мере дикризки точно быстрее.
Дикризки точно быстрее, потому что раньше мы умели только с помощью сифтапа это делать,
что в бинарный, что в биномиальный. Для дикриза мне нужно было от вершинки дойти вверх до корня,
возможно, в худшем случае, все их там просвопать. Ну а фибоначи умеют за единицу в среднем,
точнее учетно, амортизированно. Так, хорошо, ну давайте приступим. Во многом структура будет
похожа на биномиальное дерево, на биномиальную кучу. Также у нас куча будет представляться набором
нескольких деревьев. Куча — это набор деревьев. Ну как обычно, деревья будут удовлетворять
требованию кучи, чтобы корень всегда лежал в корне, пардон, минимум всегда лежал в корне,
что-то я загораю сегодня. Минимум дерева всегда лежит в корне, ну и корни всех деревьев соединены
в список двусвязной. На корне деревьев. Деревьев в двусвязном списке. Вот, дальше давайте я скажу,
что рангом вершины я буду называть количество ее детей. Ранг вершины — это количество ее детей.
Ну, например, в биномиальной куче ровно это под рангом и подразумевалось. Если вспомнить,
что такое биномиальное дерево ранга K, то это вершина, которой сначала подвешено дерево ранга
0, потом 1, потом 2, потом 3 и так далее, вплоть до K-1. Мы доказывали, что биномиальное дерево
ровно такую структуру имеет, значит, если ранг K, то ровно K детей. У нас так это и было
для биномиальных деревьев, вот мы это сейчас сохраняем. Только теперь у меня деревья уже будут
совсем не обязательно биномиальные, потому что биномиальные деревья — они обязательно фиксированы
структуры. Вот там я описывал, что чтобы получить дерево ранга K-1, нужно взять два
дерева меньшего ранга, фиксированные структуры, их объединить тоже фиксированным образом,
что меньше к большему, наоборот, больший ключ к меньшему, больший корень к меньшему подвесить,
получится биномиальное дерево следующего ранга. А здесь мы хотим избавиться от того,
что у нас такая жесткая структура деревьев, мы позволим себе, чтобы они были довольно
разнообразны, что у них структура всякая разная может быть. Так, ну хорошо, ранг вершины
количества детей, давайте в каждой вершине будем хранить это количество детей. Как у меня будет
характеризоваться вершина? Мне у вершины нужно знать, давайте я проговорю все, что мне нужно знать
для вершины. Это, во-первых, указатель на родителя, если это не корневая вершина дерева, то мне
нужна ссылка на родителя, указатель на родителя, кто является вот предком этой вершины. А дальше
вот вершина может быть много детей, ну а так же, как и в биномиальной куче, может быть много детей. Но давайте
я буду хранить всех детей в виде списка, я не буду их хранить как массив или там как вектор указателей
на детей, а скорее я все их свяжу списком двусвязным и буду из этой вершины хранить на указатель
самый левый, самый правый. Давайте пунктируем, указатель на самого левого сына и указатель на
самого правого сына. Соответственно, если эта вершина также не является корнем, если у нее есть
родитель, то у нее определенная ссылка на левого брата и на правого брата. То есть теперь у меня
вот вершины, являющиеся детьми одной и той же вершины, то есть на самом деле у меня вот такие есть
ребра в моем дереве, но я эти ребра, ну я не создаю таких связей, я не говорю, что это ссылается сюда,
сюда, сюда, сюда, сюда, я говорю, что она просто ссылается на самый левый, самую правую. Чем мне это
может быть полезно, например? Например, тем, что я умею теперь удалять заод единицы, если мне
нужно, я вот эту вот вершину могу отсюда вырезать заод единицы, потому что из списка мы удалять
умеем. Если мы знаем эту вершину, мы знаем соседа справа, соседа слева, эту высекаем, вырезаем отсюда,
ну и здесь стрелочки перенаправляем. Поскольку удалять из списка я умею за единицу, то вот
мне такая конструкция, такая реализация вершины мне позволит ровно это делать. Удалять из списка,
из произвольного места списка за единицу. Ну вот, у нее есть какие-то дети, я их вырежу,
то есть вот эта вершина является корнем какого-то поддерева. Что я буду на самом деле делать,
это я буду выносить вот это поддерево в список корней, обрубаю все связи, то есть я вот это
полностью вырезаю и переношу все это дерево вот сюда в список корней. Ну и здесь, раз у меня были
ссылки на левый и на правого детей, они у меня здесь сохраняются. То есть я все что сделаю,
это высек полностью поддерева этой вершины из большого списка. Ну примерно что-то такое я
буду делать. Так, еще давайте пропишем, что мне нужно будет хранить int deg, это степень, она же
ранг вершины. И еще я ввожу буллевский флаг, ну я его называю mark. Это буллевский флаг,
правда ли, что у вершины высекался хотя бы один из детей? То есть это просто 0 или 1, true или false.
Правда ли, что у вершины вырезался один из сыновей? Давайте.
Это неверное утверждение. Ну окей, встроенные вы имеете в виду какие-то? Ну не знаю, не эксперт,
но по умолчанию в списке нет операции найти размер. Ну в конце концов почему бы не хранить,
ну если она и так есть, ну ничего страшного, мы не проиграем, если будем хранить в любом случае.
Корни в списке и множество детей каждой вершины тоже в двухвязанном списке, чтобы я мог удалять
любого сына. Ну чуть позже поймем, когда начнем удалять, мы поймем зачем это нужно. Значит еще раз,
у вершины я храню количество детей и флаг того, удалялся ли у нее хоть кто-то. То есть вот теперь,
если я разрешаю себе вырезать каких-то детей и выносить их в список корней, то, возможно,
мне придется как-то помечать. Я когда вот это выношу, вот это вот по дереву буду вырезать в список
корней и выносить, я у этой вершинки буду помечать марк и буду помечать ее звездочкой, чтобы
отображать, что на ней лежит марк, я говорю, что в ней звездочка стоит. Ну давайте теперь попробуем
какие-то операции реализовать. Ну как сделать инсерт, например, икса за единицу. Ну так же,
как в биноменальной куче, только не будем запускать процедуру мерч. Да, давайте просто,
вот у меня есть список корней деревьев, вот как-то там они друг на друга ссылаются, мне нужно добавить
икс. Давайте я создам новое тривиальное дерево, состоящее только из этого икса. Ну и вот так вот
прокину ссылочку, что предыдущий последний корень ссылается на этот икс, ну и он обратно
на него ссылается. Если список высвязан, то мне нужно две стрелки прокинуть. Ну тривиально,
завожу новое дерево, то есть это новое дерево, и просто забрасываю в конец списка, надо добавлять
в конец списка, мы умеем. Вот, честная единица. Так, get mean. Записываем в конец список корней,
да, корней. Вот у меня есть список корней, к нему в конец я добавляю новое дерево. Отлично, на самом
деле так и будет, и это нормально. Если мы просто сделаем много раз инсерт, у меня все вытянется в
одну большую цепочку, но потом, когда мне захочется, я начну это причёсывать, и у меня структура станет
покрасивее. Но в худшем случае, да, она может спокойно выражаться в цепочку. Если много инсертов
сделали, то так и будет, и нам это пока нормально. Значит, get mean. Ну, с get mean мы тоже прорабатывали,
что если просто хранить указатель на минимальный корень, то за единицу мы сможем находить ответ.
А тоже за единицу, если хранить указатель на минимальный корень. Вот. Хорошо, давайте теперь
зафиксируем себе, что нужно не только выполнить операцию, но и сохранить вот этот указатель. То
есть у меня помимо всех этих деревьев есть еще один конкретный указатель, показывающий в один
из корней, да, в минимальный корень. Поэтому дальше во всех операциях, которые я буду делать,
нужно не забывать этот указатель всегда обновлять. В частности, вот здесь надо вернуться и понять,
как здесь меняется указатель на минимум. Тут, благо, несложно. Если мы знали, где вот здесь находился
минимум, скажем, где-то вот здесь, я добавляю новое дерево, как понять, где минимум. Ну понятно,
либо здесь, либо здесь. Надо просто два числа сравнить, если нужно указатель перенаправить.
Если х меньше, чем это, то нужно указатель перенаправить. Понятно? Вот. Хорошо. Ну тем не менее,
вот за указателем теперь будем следить. Так, что дальше? Merge тоже за единицу очень просто
реализуется. Давайте. Где лежит минимальный элемент дерева? Ну вот есть дерево,
где его минимальный элемент? Всегда в корне, потому что требование куча. Значит,
достаточно среди корней выбирать минимум. Так, как сделать Merge за единицу? Ну не дерево,
а два списка слить. Ну вот представьте, у меня есть одна куча, в которой есть такой-то список
деревьев, другая куча, в которой такой-то список деревьев. В конец одной добавляем,
начало другое. Все правильно. Мы берём конец первого списка, прокидываем ссылочку на
начало второго, и отсюда прокидываем ссылочку на connection до конца первого. Ну из-за одной
не забываем пересчитать указатель на начало и на конец. Об единение списков тоже работает за
единицу. Просто начало первого соединяем с концу второго. И этот указатель на минимум
тоже тривиально подсчитывается. Если мы знали указатель на минимум здесь и указатель на
минимум здесь, то нужно взять кто из них меньше, и переставить один общий указатель,
указатель, что в этой объединенной куче у меня минимум либо
здесь, либо здесь.
Опять-таки сравниваю, кто из корней меньше, и перенаправляю
указатель.
Так, хорошо.
Давайте с экстрактом посмотрим, что происходит.
Мне нужно найти минимальное число и удалить его из кучи.
Но первый шаг уже есть, у меня всегда хранится указатель
на минимум.
Например, вот здесь вот минимальный элемент.
Поступим так же, как в биномиальной куче.
Давайте мы всех детей вот этого корня вырежем, склеим
в одну новую кучу и объединим две кучи.
Значит, вот давайте, у меня здесь были какие-то поддеревья,
там первое, второе, третье.
Вот здесь много всяких поддеревьев, ну точнее, детей корня.
Вот такое дерево у меня здесь было.
Давайте я их все вырежу.
Поскольку они у меня и так уже прошиты в список двусвязный,
вот здесь они друг на друга ссылают в том порядке, в котором
они идут здесь.
То есть здесь есть и так уже список, я этот список
объявляю списком для новой кучи, говорю, что вот это
вот куча номер два, а вот все, что здесь осталось,
это куча номер один.
Но надо не забыть еще вот здесь вот указатель перепрокинуть,
чтобы соседние от минимального корня друг на друга ссылались.
То есть я буквально удаляю этот элемент из списка,
получается список деревьев всех, кроме этого, и новый
список – это список всех детей удаляемой вершины.
Есть два списка, и дальше я их мержу, мердж списков.
Согласны?
Да.
Они указатели на первый корень или на последний корень?
Ну конечно, в списке мы обязаны, если у меня есть структура
данных список, у меня есть указатель на начало, на
конец.
Это всегда есть, да.
Получается, минимум на 1.
Вот.
Да, отлично.
Если бы я на этом закончил, у меня бы это работало за
1, потому что, ну что я сделал, у меня это и так уже в списке,
это все в списке, я удалил за 1, склеил два списка за
1, но мне нужно хранить указатель, иначе у меня гитмин не за
1 будет работать.
И вот теперь-то я начну заниматься тем, чтобы мою
кучу как-то привести в нормальный вид, потому что пока что
в худшем случае это был просто список из элементов,
по одному элементу в дереве.
И вот здесь, поскольку мне нужно обновить указатель
на минимум, мне очень и очень, ну по крайней мере, по этим
вершинам всем придется пройти, потому что я не знаю, где
минимум, возможно где-то здесь, или где-то здесь,
мне придется сейчас по ним проходить.
И вот давайте в этот момент я вызову процедуру, которая
кажется классичкой, называется consolidate, но это неважно.
Это, собственно, причёсывание кучи.
Вот теперь, когда я объединил список всех этих деревьев
в один большой список, в одну большую кучу, вот теперь
давайте я его сначала причешу, ну а потом и указатель на
минимум тоже найду.
Да, это значит, причёсывание кучи.
Вот, то есть, давайте.
Причём нам причёсывать кучу, мы же когда мержим, пока
мы мержим, можем обновлять этот указатель.
Нет, смотрите, мерж мы делаем за единицу, в мерже мне нужно
указатель на начало здесь, на конец здесь и на конец
здесь, я просто это подвешиваю сюда и объявляю это концом,
это всё за единицу работает.
В мерже я не прохожу всех этих вершин и всех вот этих
корней, поэтому я не узнаю указатель на минимум, а
мне нужно его хранить.
А я его здесь не прохожу, мерж не проходит по всем
корням, а мне в каком-то смысле нужно это сделать.
Поэтому, чтобы найти указатель на минимум, я вызываю процедуру
причёсывания.
Значит, как это работает?
Работает по существу так же, как мерж биномиальный.
Я буду склеивать деревья одинакового ранга в одно
дерево ранга на один побольше.
Если у меня есть два дерева ранга К, то я сравниваю значение
их корней и к тому дереву, в котором значение в корне
меньше, подвешиваю другое.
Ну, так же, как было в биномиальной куче.
Если есть два дерева одинакового ранга, в данном случае рангом,
напоминаю, является степень вершины, а не то, что было
раньше.
Вот если есть два дерева одинакового ранга, я их
сливаю в одно большое дерево, соответственно, ранга уже
К плюс один.
Потому что если у этого был ранг К, то при подвешивании
новой получается здесь ранг К плюс один.
Увеличивает число детей, поэтому ранг увеличивается.
Ну, поэтому давайте сделаем следующее.
Ранг корня, да, да, да.
Так, значит, консолидейт.
Смотри, давайте веду такое обозначение.
Пусть d большое от n, это максимально возможный ранг
в куче на n элементах.
Вот.
Значит, позднее мы поймем, почему это не очень большая
величина.
Позднее мы докажем, что d на самом деле это от логарифма.
Вот, пока давайте просто вот zd обозначим максимально
возможную степень корня какого-либо дерева в кучу.
Да, то есть максимально возможный ранг.
Вот.
Тогда как работает консолидейт?
Значит, мы заводим массив вот такой, где будем хранить,
каких рангов у меня уже есть куча.
Ну, давайте пример какой-нибудь сделаю.
Вот представьте, что у меня было какое-нибудь такое
дерево.
Так, давайте я что-нибудь нарисую.
Это было дерево ранга 0, затем дерево ранга 1, дерево
ранга 0, дерево ранга 3, дерево ранга 1, дерево ранга 2.
Вот представьте, что у меня был такой список корней.
Здесь указаны ранги, корней.
Давайте по этому списку пройдем и будем их сохранять
вот в этом массиве размера d от n.
Ну, например, вижу дерево ранга 0.
Давайте я как-нибудь назову a.
Смотрю в мой списочек.
Давайте я его как-нибудь в общем список.
Занумирую его.
И так далее.
У меня пока что в списке не дерево ранга 0.
Если бы оно было, мне бы пришлось их объединять.
Но пока что их нет, я просто сюда кладу дерево a.
Дальше вижу дерево ранга 1.
Окей, у меня дерево ранга 1 пока что еще не было,
я его записываю в мой списочек.
Дальше вижу дерево ранга 0.
у меня в массиве сохранена ссылка на вот это вот дерево А.
То есть я не все дерево копирую, а только указатель на корень,
чтобы понимать, откуда это дерево начинается.
Теперь вижу, пришло дерево того же ранга, что уже было.
Значит, мне их нужно склеить.
Но я знаю, где оно было. Что это за дерево? Это дерево А.
Теперь я сравниваю, у кого у А или у С корень меньше,
назначение в корне меньше, и подвешиваю правильным образом.
То есть у меня было дерево А какое-то вот такое,
дерево Б какое-то вот такое,
но раз у них ранг 0, то детей у них нет.
Я просто сравню в них значения и провожу такое ребро.
Что это значит? Это значит, что я в список детей А добавляю справа С.
Надо добавить список, я умею.
Ну и становится дерево ранга 1.
Отсюда оно стирается, и вот здесь вот я как бы сюда еще хочу добавить дерево,
вот это вот новое А в объединение с С.
Но дерево ранга 1 у меня уже опять есть,
поэтому мне их придется склеить.
Мне нельзя иметь деревья одинаковых рангов.
Мне нужно теперь склеить вот это вот и Б.
Ну я умею склеивать деревья, я смотрю на корень здесь и на корень здесь,
смотрю кто из них меньше.
И склеиваю в правильном порядке.
У меня было одно дерево, у меня было другое дерево.
Я смотрю где корень меньше, например вот здесь вот в Б-шке был корень меньше,
провожу такое ребро.
Ну опять же провести ребро значит добавить элемент в список,
добавить вот эту вершину в список детей этой вершины.
Дерево Ранга 2.
Здесь я указательность 제�еляю, и говорю, что все это не одно большое,
Дерево Ранга 2.
На него я ссылаюсь.
Это Дерево Ранга 2.
Иду дальше по сп Goku.
Я объединил Дерево Ранга 2, не было и его сюда записал.
Иду дальше, вижу Дерево Ранга 3.
Его не было, провожу указательный на него.
Дерево Ранга 1 у нас сейчас не в списке, в массиве у нас錯.
Я провожу указательный на него.
Теперь двойка пришла.
Но объединяю вот эту двойку с той, которая у меня в памяти лежит.
Опять есть одно дерево, есть другое. Я знаю, к чему надо подвесить.
Они превращаются в дерево ранга 3. Но поскольку тройка у меня уже опять есть,
у меня есть два дерева одинакового ранга, я их склеиваю и получаю дерево ранга 4.
Конец. На этом мы прошли весь список и добились того, что в массиве вот этих вот чисел,
точнее массиве этих указателей, нет двух деревьев одинакового ранга.
Понятно? Ну отлично. И сделали мы это за количество корней плюс детен.
Давайте напишем, что время работы это количество корней плюс детен.
Количество корней, потому что я прохожусь по всему этому списку,
и возможно еще какие-то из них объединяю.
Суммарное количество объединений, понятно, будет не больше, чем количество корней в этом списке,
потому что каждое объединение уменьшает количество корней на один.
Значит, объединений будет максимум столько, сколько корней, ну и плюс дн для того, чтобы этот массив создать.
Напоминаю, д это какая-то верхняя граница на ранг дерева в куче с n элементами,
и значит мне в этом массиве нет смысла рассматривать ячейки с номерами больше, чем d от n.
У меня просто ни при каких обстоятельствах, то есть d это такая граница какая-то вселенская от n зависящая,
что если у меня в куче всего n элементов, то мне не нужны ячейки с номерами больше, чем d.
Поэтому мне достаточно только такого массива.
Извините, мы когда мы идем по списку корней, мы строим датплот.
Да.
А если мы встретили в какой-то момент вершину, которая меньше остается?
Ну, как вот здесь было, смотрите, здесь все было нормально.
Вот, например, в этот момент у меня была здесь тройка, потом я видел единицу, ничего страшного,
просто я сохраняю на нее указатель.
Но потом мы должны будем снова идти и мерчить.
Но если будет еще единица, то я их, конечно, склеиваю, да.
Массив как раз тем и хорош, что он поддерживает указатели на те деревья,
рамки которых у вас есть.
Ну, там просто какие-то рамки есть.
Если пришло новое число, и его рамка не было, то вы просто вставляете,
а если не было, то объединяете до тех пор, пока все коллизии не разрешатся.
Например, если бы вот у вас сейчас, смотрите, у вас есть 3 и есть 4.
Да, я просто думаю, что это не линия, то есть мы делаем какие-то повторения.
Да, да, то есть каждый конкретный корень обрабатывается за несколько операций.
Но суммарно это работает за столько, сколько всего было объединений,
а всего объединений не больше, чем количество корней.
Значит, время работы по-прежнему такое.
Супер.
Какой будет рамк дерева, выучившийся в результате заменения
был деревьев с одним и тем же рамкой?
На один побольше.
Потому что вот картинка, смотрите, если у вас было дерево рамка K
и дерево рамка K, что такое рамк?
Вспоминаете, это количество детей у корня.
Но если здесь было K детей, вы подвесили к нему одного нового,
стал очевидно рамк K плюс 1.
Поэтому когда два дерева одного рамка сливаются,
и вы только одного рамка деревя сливаете,
то получается дерево рамка донит побольше.
Так, ну хорошо.
Значит, смотрите, мы консолидейт сделали,
мы причесали нашу кучу, добились того,
что все рамки попарно различны.
И заодно, смотрите, мы по всем корням прошлись.
Мы прошлись по вообще всем корням в нашем списке корней.
Значит, в частности, указательный минимальный корень
уж как-нибудь мы сделаем.
Мы когда вот это вот все объединяем,
мы, конечно же, мы можем просто знать,
какой из этих корней минимальный.
Мы так или иначе по ним по всем проходимся.
Если увидим корень, значение которого меньше,
чем все, что мы видели раньше,
то на него вводим указатель.
Ну и так, в общем, по всем пройдя, мы знаем минимум.
Просто минимум в массиве за линейное время от его размера.
Так, хорошо.
Ну, теперь переходим к дикриске.
Собственно, то, где самая сложность основная и зарыта.
Так, давайте вернемся к маркам.
Напоминаю, в вершине у меня есть ранг и марк.
Буллевский флаг удалялся ли у нее кто-то из детей.
Пока что мы этим не пользовались.
Пока что мы вообще детей пока что нигде не удаляли.
Мы только сливали.
Пока что все, что мы делали с деревьями,
это подвешиваем дерево одного ранга к дереву того же ранга.
Ка-ка.
Окей.
Давайте договоримся, что будет у меня с марками происходить.
Первое, что я говорю, это у корней деревьев.
Деревьев.
Деревьев.
Марк всегда false.
То есть у корня можно вырезать сколько угодно детей.
И мы не заботимся о том, сколько детей у корня вырезано.
То есть мы их можем спокойно удалять.
Мы эту марку для корня не обновляем.
То есть даже если у вас была вот такая картинка,
здесь было много каких-то детей под деревьев.
И вы там скажем сначала первый из них вырезали,
перенесли список корней второго вырезали,
третьего вырезали.
Все равно марк здесь будет false.
В корне всегда марк false.
Ну а второй, соответственно, напоминаю,
как вообще выставляется марк равно true.
Выставляем марк равно true.
В случае, если вершина это не корень,
и у нее вырезается какой-то из детей.
Не корень.
У нее вырезается один из детей.
Так, ну и все.
Теперь, значит, как мы будем делать дикриски тогда?
Как делать дикриски?
Значит, да.
Деревни в корне тоже есть везде.
Конечно.
Почему у нас марк всегда на false,
если марки выключаются?
Ну вот для корней по-особенному работают.
Для корней я специально отдельным пунктом выношу.
У корней марк всегда false,
а у остальных вершин марк это что-то содержательное.
Марк это указатель того,
удаляли ли сыновей у вершины.
Но для корней мы эти марки не помечаем.
Вот в корнях всегда false.
Итак, значит, как работают дикриски?
Напоминаю, что в дикриски мы подразумеваем,
что нам дается указатель на ту вершину,
которую надо уменьшить,
на то значение, которое надо сделать поменьше.
То есть вот представьте,
было какое-то большое дерево.
Меня тыкнули носом в какой-то элемент,
сказали, сделай его поменьше.
Ну и проблема может быть в том,
что, возможно, нарушилось неравенство с отцом,
с родителем.
Что если я это сделал поменьше,
то, возможно, здесь значение стало меньше,
чем в родителе.
Это противоречит требованию кучи,
и нам надо срочно это исправлять.
Так вот, я не буду сифтапать.
Я просто этого сына вырежу
и добавлю в список корней.
Я не буду исправлять неравенство.
Я просто возьму, удалю эту вершину
из списка детей родителя.
Благо, я умею списку удалять за единицу.
И все это дерево целиком вынесу в список корней.
Все, что здесь было, давайте назову это А.
Я его сюда в список корней добавил.
Благо, у меня все корни прошиты в список.
Я в список могу еще один элемент добавить.
Разрываю эту связь,
удаляю этот элемент из списка родителя.
И тем самым я починил
потенциально нарушившееся неравенство.
Согласны же?
Все, что могло нарушиться, это вот это неравенство.
Если я это число уменьшил,
то у меня могло нарушиться неравенство на этом ребре.
Вот я его тогда вырежу,
чтобы этого ребра не существовало,
чтобы не было требований на этом ребре никакого.
Просто добавлю список корней.
Вот.
— Не надо консоли дейт делать просто?
— Пока нет.
Нет, в дикориске консоли дейт мы не делаем.
Тут есть другая проблема.
Да, нужно разобраться с марками
и особенно понять, что делать,
а если у родителя уже было маркер внутри.
Еще раз?
Ну, в экстракт-мин надо иметь марки
в том смысле, что если вершина стала корнем,
то у него марк снимается, это правда.
Но это как бы автоматически в каком-то смысле предусмотрено.
Потому что если вершина стала корнем,
то у него марк автоматически снилось.
— Можно посчитать минимальное?
— Да, но это легко сделать,
потому что у меня, ну как бы,
за D от N я просто по этому списку.
Значит, еще раз, смотрите,
вот здесь дикорисский яйт в вершине уменьшил,
если произошла проблема,
я вынес его в список корней.
Что дальше делать?
Какая проблема осталась?
— Наверное, будем опять консоли дейт делать?
— Не, консоли дейт не буду.
Консоли дейт долго у меня работает.
Консоли дейт работает за D от N,
а D от N у меня логарифмическая.
А я хочу здесь единицу получить.
Ранку вершины храним, конечно, да.
Да, справедливо,
надо в эту вершину уменьшить ранг, это правда.
Уменьшили, да.
У корней A здесь делать марк равно false,
тоже верно, да.
Потому что в корнях у нас марк всегда будет false.
Справедливо, да.
Давайте еще,
я минимум чуть попозже себе запишу,
но что еще нужно сделать?
Надо разобраться с тем,
что если вот эта вершина уже была марк равно true,
то есть у нее уже когда-то раньше
один из детей удалился,
вырезался и добавился в список корней,
и в ней стояла марк равно true,
тогда я делаю как бы что-то незаконное.
Я не разрешал себе никогда удалять двух сыновей.
Если это не корень,
я двух детей удалить не могу.
У кого я могу удалять два,
двух детей более?
У корня.
Давайте эту вершину делаем корнем.
Давайте все оставшееся ее под дерево,
вот все, что здесь есть, так или иначе,
давайте это опять вынесу в список корней.
Да, и это, и если здесь была марк true,
и это тоже выношу.
Более того, я теперь вырезал эту вершину,
и если у ее родителя тоже было марк равно true,
то мне придется и под дерево
этой вершины тоже вынести
и добавить список корней.
Итак, дикриски работают следующим образом.
Мы уменьшаем значение в вершине,
которое мне сказали,
и дальше, пока у родителя этой вершины марк было равно true,
я вырезаю его, выношу список корней,
и делаю то же самое с родителем.
То есть пока в родителе
было марк равно true,
мне придется, поскольку я хочу вырезать его сына,
то мне придется эту вершину тоже вырезать.
Я ее вырезаю и заношу список корней.
Ну и так поднимаюсь,
пока все марки были true.
Здесь марк true выношу и снимаю ее,
потому что в корне марк всегда false.
Ну и так далее, поднимаюсь, поднимаюсь.
В конце концов я либо дойду до корня,
у которого можно спокойно удалять все, что хотите,
либо я дойду до некорневой вершины,
где было марк равно false,
и там я ей представляю марк равно true.
Еще раз?
Ну вот правило такое.
Я говорю, что марк, это флаг,
удалили мы сына или нет.
Чтобы у меня все было хорошо с этим точкой,
я запрещаю себя удалять
больше одного сына.
Потому что если вы позволите удалять
всех сыновей, например...
Так, что будет?
Дайте я подумаю секунду.
Почему?
Ну короче, я сходу сказать не могу,
но упражнение, что
понять, что происходит, если мы можем удалять
любое число детей.
Сейчас, одну секунду.
Сейчас все сделаем, да.
Но с минимумом как раз нет проблемы.
Любое число детей.
Так, у вас вопрос еще был?
У вас было сейчас...
Сейчас, сейчас.
А можно было в небольшом примере
понять, что происходит?
Ну давайте попробуем чуть-чуть нарисовать.
Так, я слушаю вас тогда пока.
Там деревья...
Нет.
Уже любые. В момент, когда я
ввожу вот эту процедуру вырезания,
у меня дерево теряет свою структуру,
и оно уже не обязательно биномиальное.
Изначально они биномиальные?
Изначально, да. Пока вы не вызвали дикарески,
но если не было ни одного дикарески,
то у вас все биномиальные.
Но в момент, когда происходит дикарес,
у вас уже какое-то вырезание.
Ну она в любом случае нарушается.
Она, конечно, нарушится.
Вопрос привести в последовательство операции
такую, что у вас вырождается
в какую-нибудь асимботику линейную.
Структура в любом случае нарушается.
Вопрос, насколько плохо.
Вот я утверждаю, что в такой реализации
она испортится, но все равно
логарифмическая асимботика будет на экстракт.
Так, пример.
Давайте кого-нибудь быстренького.
Вот представьте, у вас был такой дерево.
Это корень, root я его назову.
В нем марк было false в частности.
Тут были какие-то дети, я их не рисую.
Есть какие-то еще посторонние ветки.
Здесь есть какие-то ветки все, я их не рисую.
Вот здесь пришел дикарески.
Вот этот х, который надо было дикаризнуть.
Но я уменьшаю его значение
и хочу вырезать все его по дереву,
то есть все корни.
Я вот это выношу сюда.
Вот этот х выношу сюда.
В какой-то момент тут может быть true,
в какой-то момент может быть false.
Я рассматриваю, в какой-то момент времени
могло быть так.
Смотрите, у этой вершины уже и так
было true равно false, я у нее уже и так
что-то вырезал. Вырезай нового.
Но я такого не хочу себе позволять.
Единственная вершина, у которой я хочу
себе удалять больше, чем одну вершину,
больше, чем одного сына, это корень.
Поэтому я беру все, что осталось
от этой вершины, все, что здесь осталось,
выношу этот список корней сюда.
Вот это вот добавляю сюда.
Ну и снимаю марк. Здесь было true,
здесь станет false.
Теперь у родителя этой вершины
та же самая проблема. У него был марк
равно true, то есть кого-то из детей
я когда-то раньше уже удалил.
И теперь удаляю еще одного.
Значит, надо опять это все
вынести вот сюда. Опять скажешь,
что все, что здесь осталось,
это новое дерево.
И снять здесь марку, поставить,
что здесь марка false.
Теперь у родителя марка была false,
я просто спокойно ставлю здесь true
и завершаю выполнение, потому что
раньше у нее никто не удалялся, а теперь
удалился один сын. Все, вот здесь
помещаю true и побеждаю. На этом дикарески
заканчиваются.
Так, ну вот.
Да.
Из N деревьев ранга ноль.
Ну да.
У меня здесь учетная стоимость.
Со симдотикой я еще разберусь пока.
Я, в смысле, позже разберусь.
Итак,
я делаю ровно вот это.
Теперь давайте разбираться со временем
работы, за сколько все будет работать.
Я не буду повторять. Я вырезаю все
вот эти вершины, у которых марка была true.
Везде, где бывает проблема
с тем, что я удалил уже сына,
я вырезаю вот это и заношу в общий список.
Здесь была true, вынес. Здесь была true, вынес.
Все вот эти, где были проблемы, я вынес.
Итак,
давайте анализировать асимптотику.
Поскольку у меня
учетная асимптотика вот здесь,
что в дикареске, что в экстракте,
я методом монеток опять воспользуюсь.
Давайте скажу следующее,
что на каждом корне
лежит по монетке.
А на каждой вершине
с марка внутри лежит по две монетки.
Давайте сделаем так.
Ну, теперь давайте
с точки зрения вот этого вот
бюджета нашего
проанализируем, за сколько работает консолидейт.
То есть, на самом деле, где у нас
связывается консолидейт? Консолидейт только внутри
экстракт-мина есть.
За сколько работает консолидейт?
Ну, смотрите, вот пусть здесь, везде
на всех корнях лежали монетки.
Что я делаю?
Я прохожусь по всем этим корням
и как их там сливаю?
Я прохожусь по всем этим корням
и как их там сливаю?
Но смотрите, что мне нужно оставить?
Мне нужно, чтобы вот на этих результирующих корнях
были, на этих результирующих деревьев
в корнях тоже было по монетке.
Но как раз тогда
мне хватает монет на то, чтобы провести
все вот эти вот ребра. Потому что, если у меня есть два дерева,
в корнях,
в которых есть монеты,
я провожу ребро,
делаю это за единицу,
за одно действие, и снимаю
монету с того дерева, который
я подвесил. А на меньшем дереве,
то есть на том, где корень был
меньше, я монету оставляю.
То есть у меня было две монеты, я одной из них
расплатился за эту операцию,
и оставил монету в корне получившегося
дерева. То есть я монетой
расплатился за подвешивание.
Поэтому вот это вот все, количество корней,
работает
в каком-то смысле за ноль.
То есть я
переподвешивание выполняю за те монеты, которые
у меня уже есть. Если у меня раньше на всех
корнях были монетки, то теперь
все вот эти подвешивания работают как бы за ноль.
Учетная стоимость, реальное время,
минус число снятох монеток, это будет ноль.
Но поэтому это учетно будет ноль,
и остается dead end.
Поэтому
учетное время консолидейта это
dead end.
Теперь давайте вернемся, проанализируем
простые функции.
Значит, что с инсертом? За сколько
работает инсерт? Вспоминаем инсерт. Это что такое?
У меня был один список, я добавляю
новое дерево из одной вершины и склеиваю
два списка в один.
Что я при этом сделал? Я в частности добавляю
монету на новый корень. То есть я
добавил новый х, оно стало
корнем, значит я потратил одну монету
в этот момент. Ну и сделал там
типа два действия. Прокинул одну ссылку,
прокинул другую ссылку.
Это единица.
Как чистая, так и учетная. То есть я сделал
единицы действий, и с точки зрения
монеток я положил всего одну монетку, поэтому
это тоже законно. Здесь остается единица.
С гитмином, ну гитмин у меня всегда хранится
указатель, здесь вообще ничего не происходит, я просто увожу ответ.
Чистые единицы.
Merge, это просто соединить два списка, это там
тоже два действия.
Без монеток здесь все честно за чистую единицу.
Значит, экстракт мина, мы поняли, что
экстракт мин работает на самом деле за
у звездочку D.
Чуть позже докажем,
в конце докажем, почему D это логарифм.
Ну теперь декрестки.
Декрестки тоже все хорошо за счет
вот этих монеток, которые у меня
на вершинах с маркером
нутру лежат.
Ну вот представьте, смотрите,
за сколько я вот это все делал на этой картинке.
Я вырезаю вот этого чувака, вот этого и вот этого.
Что я делаю в этот момент?
Смотрите, вырезать вершину по факту,
если честно вырезать вершину, добавить список
корней, это от единицы.
Потому что мне нужно удалить ее из списка
детей и родителей, а из списка я умею
за единицу удалять.
Ну и плюс нужно добавить вот это все дерево
в конец общего списка корней.
Это тоже за единицу делается.
Поэтому здесь как бы единица действий,
но еще мне нужно еще монетку сюда положить.
Три действия. Вырезали отсюда,
добавили сюда, положили монетку.
Три действия пока что.
Далее мы поднимаемся в родителя в родителя
многократно, пока здесь стоит маркер нутру.
Но здесь есть по две монетки.
А мне нужно всего лишь взять
и вырезать вот этого дерева и вставить сюда.
Я вырезаю за счет той монетки,
которая тут есть,
вставляю сюда и оставляю на нем
одну монетку. То есть у меня за счет того,
что здесь есть две монеты, я могу вынести,
вырезать все это по дереву и вставить сюда.
И оставить на корне
одну монету. Как бы за бесплатно.
Потому что я делаю какое-то действие
и оплачиваю его той монетой,
которой у меня уже есть.
Ну и так далее. По всем этим вершинам прохожу.
За счет того, что здесь достаточно много денег,
то есть есть две монеты, то я одну из них
стараюсь вырезать и положить сюда,
и вторую остается,
потому что это корень.
В конце мне нужно в худшем случае
у этой вершины, которая была родителем
с маркером нутру, выставить true,
значит мне нужно еще сюда две монеты
положить.
Но это еще плюс два ко времени работы.
Получается, что все это работает за
единицу.
Потому что вот эти все промежуточные
операции работали как бы за ноль,
потому что я вырезаю за счет той
монеты, которая здесь лежит.
Здесь там я сделал сколько-то действий,
положил монетку на этот корень.
И здесь положил две монетки, но это все суммарно вот единицы.
Напоминаю, что как у меня
вообще учетная стоимость работает.
Это реальное время, плюс
сколько монеток я положил, минус сколько я снял.
Ну вот здесь как раз вот время
и W очень хорошо
сокращаются, потому что все вот эти вот
промежуточные вершины, которые я вырезаю,
добавляю в список, ну я за них расплачиваюсь
монетками. И вот это вот T-W как раз сокращаются.
Получается, здесь опять-таки вот
единица учетная.
Считается, что мы
вырезаем
какое-то
дерево,
не другую кучу. Здесь вставляем
список за одно действие. Да, да, да.
Ну иначе надо было сказать,
что здесь три монетки. Ну ничего бы не
сломалось. Да, все то же самое, конечно.
Но я считаю, что это одно действие.
Так, есть вопросы?
Ну вот, значит мы вроде бы честно
доказали, что здесь учетная единичка, осталось понять,
что такое D от N.
Так, тогда вот это можно стереть.
Давайте обращу задачу.
Смотрите, D от N – это
максимальный возможный ранг корня,
если всего в куче N вершин.
Давайте решу обратную задачу.
По рангу найду
минимально возможное количество вершин.
Значит, пусть
S от K
это
D от N.
Ну вот,
вот так вот.
Ну вот,
S от K – это
минимальное число
вершин
в дереве,
пардон,
извините, минимальный ранг,
минимальный ранг,
минимальный ранг
корня дерева,
в котором лежит хотя бы K вершин.
Так,
что я делаю? Я то же самое
написал, извините. У меня D от N
было как раз ограничение на ранг.
Извините, пожалуйста,
вершины, все правильно было.
Вот так сделаю, да,
извините, вот так нормально.
То есть, еще раз, я зафиксировал ранг корня,
хочу посчитать, какое минимальное количество вершин
в нем может быть. Вот так.
Ну, например,
что такое S от нуля?
Вершина одна, да, это единица,
потому что если ранг ноль, значит, у меня есть
корень дерева, у которого ноль детей.
Понятно, что здесь всего одна вершина.
Дальше, S от
единицы.
Это что значит? Есть корень, у него есть
по крайней мере один сын,
ну и, наверное, можно ожидать, что здесь у него ноль детей.
Тут будет двойка.
Это будет корректное
дерево.
Значит, дальше давайте смотреть.
Давайте представим
себе вершину, у которой сейчас
ранг K.
Пусть это будет вершина V.
Что значит, что у нее сейчас ранг K?
Это значит, что у нее есть K детей.
У ноль,
у один,
и так далее у K минус один.
Значит, давайте я упорядочу
эти вершины
в порядке возрастания
времени добавления,
в порядке возрастания времени подвешивания
к V.
Значит, у И упорядочены
в порядке
подвешивания к V.
Потому что
откуда появляются эти ребра?
Ребра появляются только в момент
подвешивания одного дерева ранга K
к другому дереву ранга K.
Только в этот момент у меня появляются такие ребра.
Ну, давайте рассмотрим те моменты,
в которые это дерево подвесилось сюда,
потом это, потом это и так далее, вплоть до последнего.
И упорядочу их слева направо,
что это подвесилось самым первым, это вторым, это третьим и так далее.
Вот.
Смотрите,
в момент подвешивания
я утверждаю, что вершина УИ
имела ранг хотя бы И.
Вершина УИ
имела ранг
хотя бы И.
Почему?
Скажите, пожалуйста.
Ну да.
Потому что что значит...
Смотрите, мы
подливали сначала это сюда,
потом это сюда, потом это сюда и так далее.
Возможно, в промежутке мы еще
что-то туда подливали.
Возможно, они просто потом вырезались.
Но, смотрите, если это
была подвешена сюда einer
была подвешена сюда после этой,
значит в момент подвешивания здесь был ранг хотя бы один.
Потому что здесьDB ранг хотя бы один.
У нее был один сын уже.
И значит, здесь тоже ранг хотя бы один,
потому что мы сливаем только деревья
одинакового ранга.
Затем У2, она добавилась в момент,
когда и эта и эта была.
Значит, здесь ранг хотя бы два,
значит и здесь ранг хотя бы два,
потому что я объединяю только деревья одинакого ранга.
И так далее.
Согласны? А какой у них ранг теперь, скажите, пожалуйста? Не меньше, чем и минус один,
потому что ранг может уменьшиться максимум на единицу из-за нашего свойства с марками.
Вот здесь играет роль, что я не позволяю себе очень сильно уменьшать степень вершины,
только максимум на единицу. А теперь ранг вершины у и хотя бы и минус один,
потому что ранг мог уменьшиться только на единицу за счет выражения какого-то из детей.
Двух и более детей я удалить не могу. Понятно? Это самый главный момент,
почему у нас получается такая симпатика, что у каждой из них, это уже не корни дерева,
удалить из них я могу максимум только одного сына. Если удаляю двух и более,
то я тогда обязан был бы это вынести в список корней, и это уже не могли бы быть детьми В.
А если они еще дети, то у них удалился максимум один Ц, значит ранг хотя бы и минус один.
Вот, ну значит картинка такая. Здесь ранг К, здесь ранг 0, хотя бы 0, здесь ранг хотя бы 0,
здесь ранг хотя бы 1 и так далее, здесь ранг хотя бы К-2. То есть это 0, это 1-1, тоже 0. Тут будет 2-1-1 и так далее К-2.
То есть теперь если у меня корень имеет ранг К, то здесь эти товарищи рангов хотя бы 0,0,1,2,3 и так далее К-1.
Получается, что sk, заведомо, больше либо равно, чем 1, давайте я напишу 2, вот эти вот я учту отдельно,
а дальше сумма i от 0 до k-2, s и t.
Потому что если здесь rank хотя бы i, вот этих всех товарищей rank хотя бы будет i,
ну значит в них минимальней, что вершины тесы.
Ну все, отчет сфибоначи.
Да.
Еще раз?
Почему здесь не один?
Потому что вот это вот, потому что i-1 хотя бы.
Потому что здесь rank k-1, здесь rank хотя бы k-1, после удаления хотя бы k-2.
Потому что мы одного сына могли удалить.
Ну, давайте напишу, ну вот галочки, вот этот и этот, все остальные суммы вошли.
Значит давайте напишу первые несколько значений, s0, s1 мы посчитали, давайте s2 напишу, что такое s2.
Это 2 плюс s0, это 3.
s3, это 2 плюс s0, s1.
Это 5.
Ну да, давайте напишем просто здесь равенство честное, потому что такое могло произойти.
Да, это правда.
Ну или там, если бы я написал большое равно, то было больше 0 чем 5.
Это не особо важно.
Давайте я оставлю все-таки большее равно.
Окей, тогда здесь просто будет большее равно, но это не на что не повлияет.
Ну и так далее, если я посчитаю, s4 получится, что бы вы думали, 8.
Если бы мы посчитали, s5 будет больше 0, 13.
Ну и так далее, в точности чисто фибоначи.
Вот.
Ну здесь 0, вы согласны, что здесь степень 0?
А здесь была 1, а стало 0.
Ну вот и два нуля.
Так, значит почему это действительно фибоначи?
Ну это может по индукции доказать.
Почему действительно чисто фибоначи?
Напомню или определю для тех, кто внезапно не знает.
Значит, что такое чисто фибоначи?
Это такая последовательность, что f от 0 это 0.
Так, у меня здесь будет не совсем они, ну ладно.
Значит, f от 1 это 1, а fn это сумма двух предыдущих.
Вот.
Такая последовательность.
Ну давайте докажем по индукции, что s от k, это f, видимо, k плюс 1.
Больше собравну.
Больше собравну, да.
Вот, ну потому что с от k, с от k, с от k, с от k,
с от k, с от k, с от k, с от k, с от k.
Вот, ну база очевидна.
k равно 0, k равно 1 выполняется,
потому что 1 фибоначи это 1, а 2 это 2.
На базе очевидно.
Ну переход.
Давайте считать, что для с, для всех меньших это верно.
Давайте запишем вот это вот неравенство для sk.
sk это хотя бы 2 плюс сумма,
и от 0 до k минус 2.
s и t.
Каждое с и мы оцениваем снизу как f и плюс первое.
Получаем 2 плюс,
давайте так напишу, f1 плюс f2,
плюс так далее, плюс fk минус 1.
Так, или не хочу я так сделать.
Давайте по-другому.
Чуть покороче просто сделаем.
Я вот так это напишу.
Это равно просто на 1,
sk минус 1,
плюс sk минус 2.
Вот так.
Почему?
Потому что, смотрите, в этой сумме я отщепляю
все кроме последнего слагаемого.
Последнее слагаемое ушло сюда.
Тут осталось 2 плюс сумма,
и от 0 до k минус 3, s и t.
Но 2 плюс сумма от 0 до k минус 3, s и t,
это оценка на sk минус 1.
Вот просто вот эта вот штука.
Давайте напишу, что это 2 плюс
сумма
s и t.
То есть я все слагаемые кроме последнего
вынес сюда, а последнее
оставил отдельно.
Ну и все, если мы знаем, что это чисто
Fibonacci, то это fk просто.
Точнее не так, что давайте все-таки
равенство буду доказывать.
И если мы будем доказывать,
что это чисто Fibonacci,
то это fk просто.
Я все-таки равенство буду доказывать,
и здесь тоже равенство считать, мне так удобно.
Sorry.
Это неважно все.
Ну и там тоже равно.
Не сломаемся.
Вот.
Все такое sk минус 1.
Это fk,
sk минус 2, это fk минус 1.
Ну вот, эта сумма уже есть как раз
число Fibonacci.
Вот.
Ну все.
Так, нам осталось понять,
как быстро растучится чисто Fibonacci.
По экспоненте, да.
Значит, есть какая-то формула.
Что я начал Fibonacci?
Ну давайте я напишу формулу.
Да.
Ну, неважно.
Тут и так написано экспоненты.
Это не обязательно доказывать.
В общем,
можно доказать эту формулу.
Я бы сказал, что доказать такую формулу проще,
потому что здесь написано явное выражение.
Это легко по индукции доказать.
Что если вы выражаете fn плюс 2
через fn плюс 1, fn и fn,
то как раз эти суммы складываете,
получается то, что нужно для n плюс 2.
А здесь по индукции вообще доказывать нечего.
Ну и все.
Смотрите, минус phi в степени минус n.
Это что-то экспоненциально убывающее,
потому что здесь минус n.
Остается главное слагаемое phi в степени n.
Поэтому с точки зрения тетты,
давайте напишу, что это тетта от phi в степени n.
Где phi – это какое-то число больше единицы.
Значит, это растет экспоненциально быстро.
Значит, и наша s тоже растет экспоненциально быстро.
И мы на самом деле получили все, что хотели.
Смотрите, мы при фиксированной степени корня k
показали, что тогда вершин хотя бы phi в степени k.
Ну, с точки зрения,
с точности до мультипликильной константы.
Значит, наоборот,
если у нас всего n вершин,
то степень не больше чем логарифм по основанию phi.
Значит, из этого всего следует
из этого всего следует
из этого всего следует
Значит, из этого всего следует,
что d от n
имеет порядок
логарифм по основанию phi от n.
Ну, основание можно не писать,
но я уточняю,
что если у меня s растет как экспонент
от phi, то есть phi в степени n,
то логарифм у меня как бы обратная функция
будет логарифм по основанию phi.
Вот так вот.
Так, вопросы есть?
Так, вопросы есть?
Так, вопросы есть?
Вот написано.
Значит, если не верите,
можете загуглить через Фибоначчо,
это, конечно, называется формула Бене.
Можете руками пробовать доказать,
тогда поймете, почему это верно.
Это совсем просто по индукции доказывается.
Так, еще вопросы?
По формуле.
По формуле.
Каравну 2 подставляете,
получаете то, что надо.
Да.
Да, конечно.
На самом деле
вот эти стартовые значения,
то есть чисто Фибоначчо определяются
в значении вот так.
Если вы здесь поставите любые другие числа,
ну, положительные, хотя об одной из которых,
скажу так,
если вот здесь не нули, короче,
то оно в любом случае экспенсионально быстро растет.
Поэтому стартовое значение,
хоть там у меня было стояло там 100, 200,
хоть, не знаю, 0, 1, или 1, 0, это неважно.
Главное, чтобы не нули там стояли,
тогда оно в любом случае экспенсионально быстро растет.
Так.
Откуда у нас еще раз получается оценка
Фибоначчо?
Ну, потому что надо вспомнить, что такое С.
С это минимальная, вот у вас было
дерево ранга К.
В нем тогда примерно Фи в степени
К вершин. Очень грубо, в нем Фи в степени
К вершин.
Теперь что такое было Д?
Д это, наоборот, степень, максимально возможная
степень, если у вас в дереве
Н вершин.
Ну, вот это возьмите за Н,
тогда К
это логарифм от Н по основанию
Фи. То есть, если вы знаете,
то здесь мы по рангу считали количество
вершин, а если делать наоборот,
по человеку вершин считать ранг, ну нужно делать логарифм
наоборот, обратная функция просто.
Вот, такие дела.
Так, ну что?
Давайте тогда пойдем дальше.
Ну, два слова. Это в целом
очень круто с точки зрения теории,
что у нас все операции кроме экстракта
за единицу работают, возможно, за учетную.
Это круто, но
на практике, чтобы все это сыграло,
чтобы это работало быстрее, чем
та же бинарная или биномиальная, нужны
очень большие объемы данных, миллиарды,
грубо говоря, потому что здесь большая константа,
все вот эти вырезания, хранение списков.
Из-за того, что у нас в списке
мы очень сильно скачем по памяти.
Короче, это все с точки зрения константа очень не оптимально.
Ну и плюс здесь
учетная стоимость, а не обычная, нормальная,
честная.
Поэтому это, повторю, работает
только на очень больших объемах данных.
Скорее всего, на каких-то таких более-менее
человеческих задачах это не почувствуется.
Может быть даже будет хуже.
Но теоретически
очень даже.
Ну нет, конечно.
В смысле, конечно, бывают задачи, где
реально большие объемы данных. Я про то, что
это редко возникает в каких-то
скажем так.
В общем случае, скорее всего,
у вас не будет таких объемов данных.
Но если вы специально
занимаетесь
большими графами, большими структурами,
там весь интернет хотите
анализировать,
всех пользователей какой-нибудь социальной сети,
тогда, пожалуйста, это актуально.
Но если у вас магазины в городе,
то это не актуально.
Просто от масштаба зависит.
Так, хорошо.
Я расскажу
быстренько еще одну структуру.
Спарстейбл называется.
Все, уже кучу проехали.
Давайте быстро в спарстейбл.
Задача, которую мы хотим научиться решать.
Следующая.
Пусть у нас есть массив,
который меняться не будет.
И у нас поступает к нему запрос
одного следующего типа.
Нужно по числам L и R
найти минимум на отрезке с L по R.
То есть нужно найти минимум
среди элементов aL и так далее aR.
Минимум на подотреске.
Все, и больше других запросов нет.
Только минимум на отрезке.
Мы научимся
отвечать на такие запросы
за 1.
Идея следующая.
Давайте мы предпочитаем ответы
на всех отрезках, длина которых
от степень двойки.
1, 2, 4, 8 и так далее.
Первый шаг.
Найдем ответы
для всех отрезков
длины.
Давайте так напишу.
1, 2, 4, 8, 16 и так далее.
Для всех степеней двойки
найду все ответы.
Это не очень страшно,
потому что сколько здесь разных
степеней двоек?
Примерно логарифам.
Понятно, у меня нет подотресков длины
больше, чем 2 в степени логарифам.
Поэтому здесь примерно
логарифмическое количество длин.
Дальше, для каждой длины,
что логарифм длин,
то у меня всего примерно n логн подотресков,
потому что отрезков фиксированной длины
их максимум n.
И для каждого из них
это посильная задача
посчитать ответ на всех таких отрезков.
Как это можно делать?
Например, можно идти
очередью фиксированной длины
и хранить минимум в окошке.
Давайте зафиксируем число 8.
Я рассматриваю первые 8 элементов,
добавил их в очередь и знаю минимум.
Затем мне нужно на 1 вправо расшириться
и на 1 слева сократиться.
То есть по факту мне нужно
один элемент в конец учителей добавить
и один из начала удалить.
И при этом узнать опять минимум.
Но минимум в очередь я хранить умею.
И так я линейным проходом,
просто вот этим окошком,
скользящим окном я дойду до конца,
на каждом отрезке посчитаю минимум.
Если что, можно так посчитать минимум.
А дальше,
если у меня есть ответ на всех отрезках
длины степень двойки,
то как найти ответ на запрос с l по r?
Давайте я найду такую максимальную степень двойки,
которая сюда умещается.
Давайте найдем максимальное k,
такое, что 2 вкатый
меньше либо равно, чем длина этого отрезка.
r минус l плюс 1.
И приложим 2 отрезка такой длины
слева и справа.
То есть вот здесь вот приложу отрезок длины 2 в степень k,
а здесь приложу отрезок длины 2 в степень k.
Я утверждаю, что они обязательно пересекутся,
потому что если бы они не пересекались,
картинка была какая-то вот такая,
тогда если бы я степенью двойки
увеличил на единицу,
то есть этот отрезок расширил бы вдвое,
он бы все еще помещался в этот отрезок.
Поэтому не пересекаться они не могут,
иначе k можно было бы увеличить.
Ну а раз они пересекаются, то значит они суммарно покрывают весь отрезок.
И если я узнаю минимум
на левой половине
и на правой половине,
то минимум из них
будет минимум на отрезке.
Причем мне даже не страшно,
что они пересекаются по какому-то куску,
потому что если я беру минимум
от того, что у меня некоторые числа в минимуме
учтутся дважды,
от этого минимум, конечно, не изменится.
Я просто беру минимум здесь,
выбираю из них минимальное значение и побеждаю.
Концепция такая.
Ну потому что если я k
как-то найду за единицу,
то дальше мне нужно просто взять
минимум из двух чисел,
а на этих-то отрезках у меня ответы уже посчитаны.
Это степень двойки,
на них у меня ответы уже где-то лежат,
я просто достаю эти числа из массива,
который где-то посчитан,
нахожу из них минимум.
Это обращение к памяти и минимум из двух чисел.
Попробуем.
Да, ну первый шаг я не говорил,
за сколько работает,
ну по крайней мере не писал.
Первый шаг будет работать за n-логен, да.
Ну ничего страшного, зато вот это за единицу.
Так, ну хорошо, давайте это
как-нибудь что-нибудь напишем, смотрите.
Давайте первый шаг сначала сделаем.
Давайте посчитаем ответы
для всех отрезков длины степень двойки.
Я не буду делать вот эту вот штуку с окном,
это потенциально можно сделать,
но это не быстро. Давайте я совсем просто это сделаю.
Давайте как-нибудь обозначим,
что пусть
sparse
sparse
sparse
sparse
it
it, нет, не так.
ну k пусть будет, ладно,
kt it
это минимум
на отрезка длины 2 степенька,
который начинается в точке i.
То есть это вот
к точке i я прикладываю отрезок
длины 2 степенька, и вот здесь вот считаю
минимум.
Вот на таком отрезке длины 2 степенька.
Формально это просто минимум
из
ну я вот так напишу,
j от i
до i плюс 2 вкатой
минус 1, а jt.
Потому что если начало
у меня это точка i,
длина 2 вкатой, то конец это
i плюс 2 вкатой минус 1.
Если я на отрезках живу, я живу на отрезках сегодня.
Да.
sparse k и
с двумя параметрами k и i.
Это следующее, это минимум
отрезка длины 2 в степени k,
то есть k это то, в какой степени я беру 2,
с началом в точке i.
То есть вот есть у меня
мой большой массив, я фиксирую
начало точку i, фиксирую конец на расстоянии
2 вкатой от него,
ну и считаю минимум на этом, вот в этом окне.
Минимум всех чисел
вот с этого, с этого по вот это.
Ну там i плюс 2 вкатой
минус 1 у него номер будет.
Да, сейчас, одну секунду,
давайте я скажу, что если я внезапно вылезаю
за пределы массива, то
ну я просто считаю минимум среди тех элементов,
которые есть. То есть вот здесь, если я внезапно
переваливаю за n, то
ну я их просто не рассматриваю.
Да.
Как мы выстроим этот вкат,
который у нас есть?
Вы торопитесь, я еще первый этаж шаг не раскал,
вы уже во второй идете. Давайте сначала, давайте по порядку.
Давайте я это сделаю.
Так, ну давайте посчитаем.
Смотрите, давайте я это буду насчитывать
в порядке возрастания k.
Давайте сначала это сделаем для k равно 0.
Чему равно sparse
нулевое i,
для любого i?
i,
потому что что это такое?
Это минимум на отрезке длины 2
в степени 0, то есть на отрезке длины 1
из одного элемента, который начинается в точке i.
Но это только i.
Там одно число, минимум из него, это оно само.
Так, теперь давайте
будем делать переход
k, k плюс 1.
Давайте я буду считать, что у меня все sparse
с фиксированным индексом 1
посчитаны, сделаю переход к следующему.
Формально у меня будет такой цикл.
k от 0 до, там скажем,
логарифмы.
Я считаю, что все sparse
с первым индексом k посчитаны, хочу посчитать
sparse k плюс 1.
Так, картинка.
Давайте сразу фор
еще один по i я сделаю.
От 1 до n.
Вот здесь я хочу посчитать sparse
k плюс 1i.
Что такое sparse k плюс 1i?
Значит я беру элемент с номером i,
рисую от него
окошко длины 2 в степени k плюс 1.
Вот здесь я хочу посчитать sparse k
плюс 1i.
Что такое sparse k плюс 1i?
Значит я беру элемент с номером i,
окошко длины 2 в степени k плюс 1
и считаю минимум
среди всех этих элементов.
Но у меня
уже посчитаны минимумы на всех отрезках
меньшей длины. На всех отрезках
степени 2 меньше длины.
Тогда я просто могу
этот большой отрезок поделить пополам.
Здесь длины будут как раз по 2 в катой.
И минимумы на них я уже знаю.
Потому что это sparse
с катого слоя.
Я знаю минимум здесь и минимум здесь.
Я выбираю из них минимальное число
и кладу в sparse k плюс 1i.
Поэтому здесь
можно написать так. Давайте напишем,
что j это минимум из
n и
i плюс 2 в катой.
Потому что если здесь
индекс i, то здесь индекс.
Вот этот первый, начальный индекс
второго блока.
Ну какая разница? Можно от 0.
У меня просто массив от 1.
Если вам приятнее от 0,
то сделайте в 0 индексация.
Неважно.
Если у меня здесь начинается
в точке i, то здесь по идее начинается в точке
i плюс 2 в катой. Но если внезапно
оно вылезает за n, то нужно еще обрубиться
и сказать, что оно n.
Здесь написано i плюс 2 в катой.
И тогда
sparse
k плюс 1i
это просто
минимум из
вот этого блока
и вот этого.
Это sparse cataite, это sparse cataigite.
Ну вот здесь это
и напишем.
Минимум из sparse cataite
sparse
cataigite.
Все.
Первый шаг какой-то уже сделан.
Еще раз.
Я иду в порядке возрастания k.
Вот у меня k перебивается от 0 до логарифма в порядке
возрастания.
Я считаю, что на всех отрезках длины 2 в катой
ответ уже посчитан.
Теперь я хочу посчитать ответ
на отрезки длины 2 в степени k плюс 1.
Это делается очень просто.
Я разбиваю мой большой отрезок
на два равных длины 2 в катой
с левой справа.
И поскольку на них ответ уже посчитан,
это 2 в катой,
на них минимум уже известно.
Это sparse cataite, sparse cataigite.
То мне нужно просто взять минимум отсюда,
и взять из них минимальное.
Ровно это я и делаю.
Я нахожу позицию,
где находится начало второго отрезка,
то есть левая половина начинается в точке i,
правая начинается в точке i плюс 2 в катой.
Я беру из них sparse,
которые уже посчитаны,
выбираю минимальное значение,
и возвращаю в качестве ответа.
Согласны?
Ну и видно тогда, что это работает за n log n.
Потому что здесь у меня цикл логарифмический,
здесь линейный,
а дальше там вот единица внутри.
Поэтому смарная n log n.
Единственное, давайте вот эту 2 в катой
еще как-то напишем.
К сожалению, мы в языке проигрываем,
не можем писать 2 в катой.
Можно писать вот так.
1 меньше меньше k.
Это будет считаться как 2 в степеника.
Что это такое?
Это битовый сдвиг.
Представьте, вы написали единицу,
представьте регистр,
32 или 64 битика,
как хранится единица?
Это 0,0,0,0 и в конце единица.
Теперь представьте, что вы это сдвигаете влево.
Вот у вас было 0,0,0,0,0,0,0,1.
Вы сдвинули это влево.
Причем здесь у вас граница регистра.
Понятно, что тогда единица станет как раз на катое место.
Ну и по умолчанию, при сдвиге считается,
что все, что было правее, станет нулями.
По умолчанию заполняется нулями.
Ну и слева все останутся нули.
Поэтому как раз в дуэйчной системе
счастливения это сдвиг единицы с нулевой позиции
на катую.
Это как раз 2 в катой.
Поэтому если писать 1 меньше меньше k,
то это будет то, что нужно.
Ровно 2 в катой.
Так, хорошо.
Ну все, первым шагом разобрались.
Теперь давайте второй.
Тут проблема только одна.
Как найти вот это максимальное k,
не превосходящие длины отрезка?
Потому что все остальное это просто
обращение к спарсу.
Мы знаем k, мы знаем начало здесь,
мы знаем начало здесь, ну как-нибудь высчитаем.
Это r-2 в катой плюс 1.
Вот эта вот точка.
Начало этой вот половины.
Как-нибудь посчитаем.
Ну дальше спарс вот отсюда берем, спарс вот отсюда.
И минимум из них это ответ.
Поэтому тут проблем нет. Самое сложное
в каком-то смысле это вот эта вот штука.
Так, хорошо.
Ну вообще говоря,
в плюсах
на некоторых компиляторах
есть какие-то встроенные функции,
которые вам позволяют находить вот такое.
Без лишнего кода.
Это что-то типа там builtint,
ktl, ktlz,
что-то вот такое вот.
Потому что по факту, что такое вот это вот число.
Смотрите, давайте я как-нибудь обозначу,
что пусть t это r-l плюс 1.
Давайте t напишем
в двоечном системе числения опять.
Ну там она это сначала кучу нулей,
потом что-то вот такое, например.
Вот что это тут tele.
Тогда что по факту такое
максимальная степень двойки,
не превосходящая t?
Ну это вот самая левая единица.
Это вот эта вот единица, а дальше все нулями.
Потому что что такое
Потому что что такое максимальная степень двойки, не происходящая t?
Здесь единицу ставить нельзя, потому что было бы больше.
Если вы поставите здесь единицу, а здесь все нулями,
то это как раз степень двойки, не происходящая t.
Чтобы найти максимальное k, вам достаточно просто в числе найти самую левую единицу.
В некоторых эмпиляторах это и так уже есть.
Если вам интересно внутренними функциями воспользоваться, которые уже есть,
то погуглите, что это самая, получается, позиция самой старшей единицы.
Позиция старшего бита.
Потому что если я знаю, что эта единица стоит на седьмом месте,
то значит k равно 7.
Ну хорошо, давайте считать, что у нас там нет такого в компиляторе,
давайте это руками считаем.
Давайте мы просто заведем какой-нибудь массив,
пауэр я его назову.
Значит пусть пауэр от t это то самое максимальное k,
что 2 в ката не превосходит t.
Давайте просто все это предпосчитаем.
Поэтому можно взять логарифм и целую часть вниз.
Можно.
Ну на ваш страх и риск, скажем так.
Потому что логарифм, это функция уже не целый число, это дабл.
Там куда он округлится, бог его знает.
Можно, но не совсем безопасно, скажу так.
Побитовый сдвиг влево, сдвиг на 2.
Практически оставляем на 3 ничего.
Не понял, побитовый сдвиг...
Чего?
У нас есть тест.
Да.
Побитовый сдвигает.
Влево на 1?
Ну окей, у вас будет вот такое число.
Зачем?
Не-не-не.
Сдвигается то, что...
Вы вот это сдвинули, это все сохранилось,
и только та часть, которая не было.
Вам же нужно вот эти последние биты как-то заполнить.
Только те, которых не было, заполняются нулями.
Вот.
Давайте предпосчитаем просто.
Смотрите, у меня вот эта вот t, это длина отрезка.
Вот эта вот t, это длина отрезка.
С l по r.
Но разных длин у меня всего n.
1, 2 и так далее n.
Давайте для всех предпосчитаем и победим.
Вот.
Ну начало какое?
Если t единица,
то k это ноль.
Максимальная степень двойки, не предпочитающая единица,
это нулевая степень двойки.
Вот.
Ну а дальше давайте идти в цикле
по t от 2 до n
и считать, какой будет правильная pv от t.
Значит, t от 2 до n.
Вот.
Чему равно pv от t, вопрос.
Здесь я хочу посчитать, чему равно pv от t.
Вот.
Ну можно сделать опять таки многими способами.
Вопрос, а когда pv от t отличается
от pv от t-1?
Когда мы пришли
к очередной степени двойки.
То есть почти всегда у меня работала бы такая штука.
Давайте ее прямо сразу напишу.
pvt это pvt-1.
Потому что, если у меня
при переходе от t-1 к t
я не перешел за новую степень двойки,
у меня не поменялся старший бит,
вот эта единица была как была, здесь так и осталась,
то у меня k осталось таким же, как было.
Поэтому мне почти всегда можно просто взять предыдущий ответ.
Единственный случай, когда она увеличится
на единицу, это когда t это новая степень двойки.
Значит, я здесь должен написать следующее.
Если t это степень двойки,
то вот это вот надо увеличить на единицу.
Значит, как проверить, что t это степень двойки?
Ну давайте я напишу универсальный рецепт,
значит, потом мы его разберем.
Вот.
Давайте перепишу, криво как-то вышло.
Восхищательный знак,
и здесь конъюнкция t и t-1.
Побитывая i,
t и t-1.
Вот.
Ну давайте поймем, почему это работает.
Давайте, например, степень двойки.
Представьте, что t это степень двойки.
Пусть t это степень двойки,
значит, его битовая запись это 1
и куча нулей справа.
Ну, старшие нули тоже есть.
Что такое t-1 тогда?
Это, наоборот,
куча единиц вот здесь.
t-1, это когда у вас
старшая единица зануляется,
а здесь будет куча единиц.
Но если вы их побитого сандите,
то есть возьмете побитовое i,
у вас побитовое i будет нулем.
Здесь нули, здесь 1 нуль,
это 0, здесь тоже 0 будет побитовое i.
Как раз восхищательный знак проверит,
что это 0.
Ну или можно было написать вот это вот равно 0,
что вот это побитовое i равно 0.
То есть если t это степень двойки,
t равно 0.
Но если t это не степень двойки,
значит у нее есть хотя бы две единицы
в двоичной записи.
Вот здесь единица и здесь единица.
Когда вы вычтите,
у вас, по крайней мере,
старшая останется на месте.
То есть вы вычитаете единичку,
у вас вот здесь что-то уменьшится,
возможно эта единица превратится в 0,
но старшая останется на месте.
И значит в их конъюнкции эта старшая единица
превратится в 0.
И будет неверно,
что у них эта штука 0.
То есть здесь их конъюнкция
будет не нулем.
А я увеличу на единицу
только в случае нуля.
Ну и все, и дальше я вот здесь вот в этом втором
при ответе на запрос
я считаю k как pv от t,
ну и беру с парсу двух штук.
Все, спасибо.
