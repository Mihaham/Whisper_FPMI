Короче говоря, мы с Алиной, Алина идёт сюда, Алина показывает, короче, вот мы показываемся вам,
вот я София Молончук, вот Алина Кузнецова, и мы, короче, будем вам расшаривать алгоритмчики.
Короче говоря, у вас будет контрольная, контрольная 2 по час 20, как это уже говорил Александр Александрович,
час 20, перерыв и час 20, если меня не изменяет память. Согласуется? Согласуется.
Сначала будут задачи вроде как попроще, потом задачи вроде как посложнее, формат OpenBook,
то есть можно пользоваться любыми бумажными материалами, передавать нельзя, соседам пользоваться нельзя,
электронным пользоваться нельзя, вот. И короче говоря, вот такая тема.
Мой совет, пойдите в библиотеку, возьмите бумажного кормона, бумажных кормонов расхватывают просто
впереди паровоза, то есть за 3 дня до контрольной бумажных кормонов вряд ли найдёте.
Он помогал, мне он помогал. Хорошо.
Собственно говоря, бумажные кормоны. Это ваш лучший друг на контрольной по алгоритмам.
Конспектики, всякое такое, вот. Значит, какие мы темы, все темы дографов не включительно будут в контрольной,
то есть это асимптотики, это мастер теорема, это оценки нижние, это всякие такие вычислительные штучки
для Euclid и быстроразведения в степень, вот, RSA будет, быстропродолжение Fourier будет, вот такие вот штуки.
Собственно, мы сейчас их и расскажем. Я, потом Алина, потом я, потом Алина, да.
Ну да, короче, начнёт Sonya. Да. Отлично. Собственно, про асимптотики. Что мы помним про асимптотики?
Мы помним, что есть у от f от n, у от j от n будет вот так. f от n равно u от j от n, если существует константа больше 0.
Значит, что оценивается сверху, что для любого, значит, существует константа больше 0, такая, что существует n большое,
такая, что для любого n маленького больше, либо равного n большого f от n меньше, либо равен константа на j от f.
Вот. А это оценка сверху, то есть растёт не быстрее, чем эта оценка снизу растёт немедленнее, чем если существует константа больше 0,
такая, что существует n такое, что для любого n больше, либо равного, чем n большое f от n больше, либо равно, чем cj от n.
Вот. Ну и наконец, θ. θ от j от n, если от j от n и ω от j от n.
Вот. Про то, как с полиномами эта вся штука работает.
Помним, что полином является большим от своей самой старшей степени, что любой полином съедает любой логарифм.
Мы помним. Вот. То есть как бы важная такая штука для любого epsilon больше 0, логарифм n, это ограничивается сверху n в степени epsilon.
Вот. Собственно, поэтому если у нас что-то там плюс логарифм, то логарифм съедается.
Если у нас, допустим, какой-то многочлен, то все степени, кроме старшей, опять-таки съедаются.
Вот. Мы можем так оценивать. Да. Ну, это как бы такие базовые основные штуки.
Дальше. Важно помнить, что ω, ω и θ – это не то же самое, что мотоновские о малое, собственно, и эквалентность.
Вот. Ну, как мы помним, что в о малом в мотоне там предел, а в о большом тут существует константа.
То есть, например, как мы говорим, что мы говорим, что n – это о большое от n, но неверно, что n – это о малое от n.
Вот. В этом суть разницы, что здесь существует константа, а там чисто предел.
Вот. Это как-то такой тоже поинт достаточно важный.
Дальше. Какие у нас есть способы оценки, асинтетической оценки разных функций?
Ну, собственно, непосредственно по определению проверять, подбирать константы сверху-снизу.
Собственно, смотреть на многочлен, то во многочлене убивать нужные, соответственно, степень, которая меньше, чем старшая.
Если у нас функция рекурсивная, то есть вызывает сама себя.
Вот. Как, например, ну, та же сортировка там, сортировка с лиянием.
Отсортируйте первую половину, отсортируйте вторую половину, сливайте.
Вот. И прочее. То есть, грубо говоря, t от n – это несколько раз, t от n – это, собственно, время работы.
Несколько раз вызывает саму себя от какой-то части, плюс еще какая-то функция.
Как это можно оценивать?
Допустим, мы знаем, что при малых n, то есть, ну, что, например, там меньше чего-то там, у нас ограниченно сверху константы.
Как у вас была в классной домашней, не помню, работе задачке там, помните с циклом Print Hello World?
Если n меньше 2020, то от 1 до n печатать.
Вот заметим, что констант n достаточно маленький, то есть, меньше чем 2020.
И дальше, несмотря на то, что мы там, ну, как бы, линейно зависит от n, то есть, n раз печатать.
Но все равно мы говорим, что это не больше, чем 2020. То есть, оно ограничено сверху константы.
Значит, мы имеем право оценивать это через дерево рекурсии и через основную теорему рекурсии, мастер-теорему.
Но мастер-теорема работает не всегда.
А вообще, одна тема дерева. Вот, собственно, вот здесь было t от n, вот здесь h штук, t от n бетов.
Если верхняя, нижняя оценка на асинхетическом уровне, то как бы можно пренебречь.
Там, если вот здесь будет округление вниз, округление вверх.
Вот, из-за того, что константы, они как бы, константы, вот.
А как это делается, как помним, находим глубину, вот.
Глубина, то есть, соответственно, вот эта n маленькая.
Ну, грубо говоря, можно сказать даже до единицы, если мы ведем речь о чем-то асинхетическом.
Ну, мы говорим, что там n на b в степени глубины должно быть там больше единицы.
Вот, соответственно, больше либо равно.
Но при этом n на b в h плюс первой уже будет меньше единицы.
Ну, здесь можно не единицу, а ту самую маленькую константу,
начиная с которой n мало и алгоритм работает за константы.
Вот так оцениваем глубину.
И как помним, что вот это f от n, то есть вот здесь выполняется f от n операции.
Вот здесь в каждой ячейке будет выполняться f от n на b операции и так далее.
Тогда наша оценка, это будет сумма от 0 до глубины.
Собственно, a в итой f от n поделить на b в итой.
Вот это то, что внутри дерева.
А потом мы досчитываем сколько у нас будет листьев в дереве.
Вот, то есть a в степени h будет листьев.
И, соответственно, в каждом листе константа.
Вот, как известно, константа операции, когда дерево уже перестает разветвляться дальше.
Ну и, собственно, когда мы смотрим, что происходит в листьях,
то мы возьмем a в h умножим на константу в листьях.
Дальше мы это все сложим.
То есть может быть достаточно очень-очень сильно разветвляться.
Допустим, может дерево и быстро.
И тогда эти константы из листьев за счет количества листьев заберут на себя основную массу работы.
А может, наоборот, дерево быть каким-нибудь графом путем, каким-нибудь получится оно.
И тогда в течение самих этих разделений вызывает t от n пополам плюс там еще что-нибудь.
Например, тогда внутри самого дерева наберется намного больше операций, чем в листьях.
Но складывать мы должны посчитать то, посчитать второе и сложить.
Это оценка через дерево лькуси.
Если оценка через мастер-теорему, мастер-теорема, как мы правильно можем вспомнить,
мы можем вспомнить t от n, a t от n на b плюс f от n.
Обозначаем d логонифом по основанию b от a и три случая.
Первый, если f от n, то есть если существует epsilon больше нуля, f от n это o большое от n в степени d минус epsilon,
то есть, грубо говоря, для своего внимания f от n маленькое.
Следовательно, тогда t от n это o от n в степени d.
Второй случай, если f от n это θ от n в степени d,
тогда t от n это θ от n в степени d логон, кто писать не умеет, я писать не умею.
Ну и наконец третья часть, это когда f от n большое, существует epsilon больше нуля,
такое, что f от n оценивается снизу как n в степени d плюс epsilon, тогда t от n это θ от f от n.
Но здесь, кроме прочего, должно быть еще такое, что существует константа из помежутка от нуля до единицы такая,
что a f от n на b должно быть меньше, чем c f от n. Здесь условие 2.
Вот, мастер-теорему помним, дерево-рекурсии помним, определение вот эти про асимпотики помним.
Соответственно, дальше, что мы сделаем? Сейчас мы посмотрим на пару задачек на мастер-теорему на три случая
и на задачку еще достаточно такую интересную тему. Была задачка год назад на контрольной.
Вот была задачка. Рекурендтные соотношения часто решают методом постановки.
Для разрешения t от n равно 2t от n пополам плюс cn.
Можно подставить d лог d, dn лог d, dn лог n и подобрать d так, чтобы доказать индуктивный переход.
То есть, предполагаем, что t от n это dn лог n.
По мастер-теореме, если прикинуть, то здесь d маленькая из мастер-теоремы это единичка.
Собственно, f это t от f первой и, соответственно, по идее должно вот такое получиться.
Дальше они просто подбирают константу. То есть, асимпотика предполагается, константа подбирается
и таким образом доказываем, что это действительно рабочая схема.
Ну, что дальше? А дальше вот мы говорим о задаче.
Так, что-то вылетело. Я про константы проверить надо, чтобы они правильнее были.
t от n равно, значит, соответственно, 2t от n пополам и плюс единица.
Легко получить, что t от n это t от n. Логично?
Если посмотреть опять-таки на мастер-теорему, то d маленькая из мастер-теоремы единица,
f от n это у малое от, ну, даже если epsilon равен единице, то тогда будет,
существует epsilon равный единице такой, что f от n, то есть единица, это o большое от n в степени 1-1,
то есть от n в нулевой, то есть от единицы. Соответственно, t от n должно быть t от n.
Дальше. Если подставить t от n пополам равное dn пополам, то получим, ну, что мы получим?
Мы получим ничего хорошего. t от n равно 2 на dn пополам плюс 1.
А с одной стороны должно быть dn плюс 1, а с другой стороны тогда t должно быть dn.
Логично? Противоречие? Казалось бы.
Вот. Если мы, если, это нам такое дается в условии, если мы подставим вот такое, то что тогда будет?
Вот это будет так. Да? Да. Под знак равенства подставляем ту же самую тему.
Получается, двойка на двойка сокращается. Вот. Ну, бред же. Бред.
Соответственно, нам нужно найти ошибку. Вот.
Как-то исправить и решить рекурсионное соотношение методом подстановки.
Вот. Ну, а что мы знаем? А мы знаем, что не обязательно, если f от n это t от n, то это просто какая-то константа умноженная на n.
Нет. Мы хотим, допустим, я хочу подставить dn плюс константа.
Логично? Могу так сделать? Могу так сделать.
Ну, тогда что происходит? Тогда происходит dn плюс константа.
Это 2 на dn плюс константа. И еще плюс 1.
Тогда... Что? Да, dn пополам. Спасибо.
Тогда dn плюс константа. Это, собственно говоря, dn плюс 2 константы плюс 1.
Ну, dn с dn сокращается. Константа с константой... Соответственно, константа должна быть равна минус 1.
Окей. Константу мы нашли. Но все ли так просто?
А вот я хочу сказать... Что я хочу сказать?
Я хочу, чтобы наша функция, как известно, она бьет из n в r плюс, в строго положительные числа.
Помним такое? Функции, которые мы работаем в курсе алгоритма. Они бьют именно в r плюс.
Ну, соответственно, значит что? t от единицы больше нуля. Логично? Логично.
Ну, соответственно, d минус 1 больше нуля. d больше единицы.
Ну, соответственно, даже такая функция t от n равна 2n минус 1. Подходит.
Мы можем подставить ее рекуррентное соотношение, получить соответственно верное равенство
и таким образом показать, что вот это заведомо t от единицы, t от n, и значит наша функция является t от n.
Логично? Всем логично? Отлично.
Так, хорошо. С такой темой, как рекуррентное соотношение постановкой и с двумя важными фактами,
что просто так об и что мы поставлять не можем, то есть t от функции,
не обязательно константа, умноженная на функцию, и что функция бьет в r плюс.
Это важно помнить. Мы, собственно, мы это помним.
Ну, дальше что? Дальше давайте мастер-теорему.
Ну, я хочу допустим, я не знаю, 16t от n поделить на 4 плюс 3n квадрат плюс 1.
Вот. Похоже на соотношение из мастер-теоремы? Да, похоже.
Соответственно, что a равно 16, b равно 4, d равно 4 от 16.
Это будет соответственно 2.
Собственно, f от n это 3n квадрат плюс 1.
Это t от n квадрат, это t от n с этими d. Логично?
Логично. Значит, в какой случае мастер-теоремы применяем?
Второй. Соответственно, t от n. Согласно второму случаю мастер-теоремы.
Оно будет равно t от n квадрат лог n. Логично?
Хорошо. Дальше? Ну, дальше проверим, допустим, первый случай.
Ну, что у нас на первый случай?
Я хочу сказать, что t от n будет, ну, так, нам надо, чтобы d было достаточно большим.
Ну, окей, 125t от n на 25 плюс n квадрат лог n. Вот так.
Соответственно, что a равно 125, b равно 5.
b равно 5, d равно, соответственно, логарифм по основанию 5 от 125.
Это будет 3. f от n. Это n квадрат лог n. Это o большое.
Ну, оценим, как n два с половиной. Это верно? Это верно.
Потому что лог n оценивается сверху любой степенью n.
Ну, вот и все. Соответственно, существует epsilon, равный, ну, даже 0,5.
Логично? Логично. Вот. Ну, таким образом, согласно первому случаю мастер-тиоремы,
t от n будет t от n. Логично? Логично.
И, наконец, последний случай. Значит,
последний случай t от n. Это, ну, пускай 5t от n на 25, вот, плюс n.
Что? Тогда я говорю a равно 5, b равно 25. Видно?
d равно логарифм по основанию 25 от 5. Это 1 вторая.
Соответственно, f от n. Это n. Это ω от n в степени 0,75.
Существует epsilon, равный 0,25. Вполне себе? Вполне себе.
И при этом, ну, существует, существует константа, чему равная.
Давайте a, f от n, b. Соответственно, это будет 5 умножить на n, 25.
Это n пятых. Ну, меньше, чем n на, ну, пускай 4. Вот.
А равно 1 четвертая на n. Ну, константа равная 1 четвертой.
Вот. Соответственно, по третьему случае мастер теоремы t от n. Это θ от n.
Логично. Вот. Если у нас вдруг, например, не будет выполняться вот это свойство,
например, тут будет какой-нибудь логарифм гулять или вроде того,
то тогда мы будем просто мучаться суммировать дерево рекурсии.
То есть распишем дерево рекурсии, посчитаем его высоту,
поскладываем вот эту сумму, посчитаем количество листов,
поскладываем сумму в листах, собственно, константы.
И, собственно, сложив их, найдем вот это асимптотику.
Вот. Ну, собственно говоря, базовое понимание того, как это происходит,
везде. Вот. Это применяется. Как асимптотику считать?
Всем понятно, осознаваемо, легко, халяво. Все решат? Все решат. Все решат?
Отлично. Так. Очередь. Что? С постановкой? Ну, давайте сейчас. Почему что?
Ну так потому, что я задаю, что t от n пополам. Ну, что? Ну, t от n пополам.
Ну, что это такое, грубо говоря? t от n пополам я хочу сказать.
Это ведь тоже самое буквально. Вот такая запись. Логично?
Где? Нет, это вот здесь как бы описывалось, что вот существует такая тема,
что вот тут есть такая рекуррента. Допустим, ну как?
Здесь описывается метод постановки как факт, что вот есть такая рекуррента.
Мы можем придумать какую-то функцию, вот такую, подставить ее сюда, порешать,
показать, что это правильно, точно и работает, и получить, собственно говоря, нужную нам доказательств.
Вот эта функция при постановке сюда даст верное равенство.
Соответственно, значит, наша t от n имеет асимптотику вот такую.
А здесь что произошло? Ну, вот я говорю, человек, который это делал гипотетически,
говорит, что я хочу задать вот такую функцию.
Ну, это ведь тоже самое, что вот эта запись. Логично?
Кажется, нет. Нет? Почему нет?
Нет, это вот одна и та же d. Вот эта запись и вот эта запись, они же идентичны?
Нет, другая d. Это одно, это из объяснения, а это просто так само по себе.
Новая задача пошла. Вам дана новая рекуррента.
И вы в этой новой рекурренте пытаетесь что-то сделать.
Ваш гипотетический человек говорит, я хочу решать ее вот так.
Я задал вот такую функцию. Логично, что это вот тоже самое?
Ну, собственно говоря, потом этот гипотетический человек подставляет.
Сюда будет функцию, в левую часть это получается dn, в правую часть, собственно,
в правую часть рекуррента он подставляет вместо t эту же функцию.
Получается dn плюс константа. И он такой, что делать?
Ну, и такой не получилось. Как-то плохой у вас метод.
А мы ему говорим, что нет, метод наш неплохой, просто ты функцию выбрал неправильную.
А мы выберем правильную. Вот она наша правильная функция.
Не будем ограничиваться просто dn, добавим еще к ней константу.
И дальше, собственно, эту константу, с этой константой будем гонять наш.
Ну да, мы по мастер-теореме, мы-то по мастер-теореме, но человек интуитивно.
В голове какая-то у него интуитивная мастер-теорема, но он ее, допустим, не помнит, доказать не может.
То есть вот он, как у меня было в начале введение курса алгоритмов, например,
что вот есть мастер-теорема, а как там все точно доказать, это надо было вспомнить,
открыть и обновить у себя в памяти эту надпись, что вот все такие соотношения.
Но как бы при беглом взгляде на вот это, я бы сказала, n log n.
При беглом взгляде на вот это, я бы сказала, n.
Ну или там по дереву расписал, но в своем решении, в правильности своего дерева он не уверен.
Откуда-то у него из головы вот эта оценка, скорее всего оно там тета от чего-то.
И дальше он берет какую-то функцию из класса тета от чего-то.
То есть здесь удалось без каких-либо добавочных константов работать, допустим, им, а здесь нет.
Как мы все помним, важный факт, что о, омега и тета – это класс, класс и функция, то есть это множество.
И нельзя ни в коем случае написать, что омега от n, например, равно n. Нет.
Знак равен, то есть только функция равна, собственно, классу.
То есть это как бы такая договоренность, неформальная, что на самом деле надо написать, например, вот так.
n принадлежит омега от n.
Но мы не хотим везде писать, принадлежит, поэтому мы пишем равно. Переставить местами нельзя.
Логично?
Если ты не хочешь оценивать тету, а хочешь оценивать о или омегу?
Ну, это не совсем так, типа, да, это так не можно, да.
Нет. Если ты хочешь оценить тету через вот такое веселье, то ты должен тогда и сверху, и снизу, и константы по подбирать.
Но на самом деле все проще через мастера решать и через яреварь рекурсий в худшем случае.
Вот.
Где?
Ну, мы говорим, что t от n вот такое годится для нашей рекурренты.
Вот. Ну, а рекуррент она однозначно задает, собственно, нашу функцию.
Собственно, вот мы ее нашли. Да?
Да, они только деревом. Для них мастертирами, к сожалению, нет.
Оценка снизу, оценка сверху, в случае чего-то по длинному, по длинной ветке, по короткой ветке, можете прикинуть.
Вот. Если совпадет, повезет. Если не совпадет, придется дальше мучаться.
Вот. Хорошо. Дальше. Понятно все про рекурренты?
Вот. На эти деревья там одна задача была. В Домашке одна задача классная, так что я очень сильно сомневаюсь.
Теперь Алина расскажет. Про что Алина расскажет?
Я скажу про всякие твои задачи, где нужно придумать алгоритмы, там где сортировки.
Такие видели в Домашках. На них аж много листочек.
Я что будет в контрольной не знаю совсем, но там же есть вторая часть, в которой задачи не простые, как в первой.
И там обычно нужно придумать какой-то алгоритм, и он как-то не связан с какой-то конкретной темой.
Либо там нужно воспользоваться какими-то известными алгоритмами.
Несколько раз применить и доказать корректность того, что мы это последовательно применяем и получаем то, что нужно.
Сейчас я разберу две такие задачи из прошлой контрольной.
Когда ты видела еще задачи из контрольных годов ранее, и там они тоже были, это очень логично.
Просто придумай тебе алгоритмы чего-нибудь.
Первая задача. На вход подается массив из 2n чисел.
Построить алгоритм, который разбивает эти 2n чисел на пары так, что максимальная сумма чисел в парах минимальна.
Есть такой алгоритм, такой массив, в нем 2n чисел.
Нам нужно эти 2n чисел разбить на пары.
Как бы на пары какие-то А1, 1, а вот на И, это каждая пара такая.
Такая, что вот такая сумма, вот такое число минимально по всем И.
И у нас, соответственно, от 1 до n, сколько у нас пар.
И что, собственно, можно здесь делать?
Можно воспользоваться уже тем, чем вы пользовались, это сортировки.
Можно отсортировать как угодно эти числа.
Допустим, можно указать, чем вы сортируете, например, слиянием.
И отсортируем этот массив.
Вот, у нас теперь он отсортированный, и отсортированную его версию мы назовем b1, b2 и b2n.
Вот. Что?
Условие такое, что у нас есть массив, в нем 2n чисел.
Ну, теперь четное число.
И нам нужно разбить на пары, ну, то есть на выходе должны быть пары.
Н пар таких, что максимальная сумма в паре минимальна.
Вы поняли условия?
Короче, я постараюсь формально записать условия.
Смотрите, у нас есть массив, и мы разбиваем на пары.
Обрабатывайте условия.
Короче, мы разбиваем на пары.
Вот пара 1, вот пара 2.
Допустим, нижний индекс – это номер пары, верхний индекс – это номер числа в паре.
И так далее.
И здесь будет an1, an2.
Вот это выход.
И что нам нужно от выхода?
Чтобы максимальная по i от 1 до n, вот такого числа, было минимально.
Стало ли так понятнее, если записала это формально?
Ну да, наверное.
Ну, то есть я верю, что если иметь условия перед глазами, то это будет совсем понятно.
Но вот требование такое от выхода.
И, собственно, мы делаем простую штуку.
Мы сортируем массив.
Ну, это логичное действие с массивом.
А дальше мы разбиваем по парам вот так.
Вот раз пара, два пара.
То есть мы разбиваем на пары b и t.
И b2n-i плюс 1.
Ну, это как раз можно проверить.
Иr1 и 2n.
Ну да, понятно, что мы вот так соединяем.
Это, на самом деле, логично.
Мы берем, чтобы в паре было самое маленькое и самое большое.
Потом второе по маленькости и второе по величине.
Вот.
Ну так, чтобы у нас примерно было сбалансировано.
То есть интуитивно понятно, что происходит?
Ну, то есть какую-то логичную штуку сделали.
Хорошо.
Действие простое.
Мы взяли, отсортировали и потом разбили вот так на пары.
На контрольной, как и в домашних и в любых задачах, нужно еще доказать корректность и оценить симпатику.
Но симпатику здесь проще.
Давайте с нее начнем.
Что сортировка это n log n.
Хорошо.
Первое действие у нас от n log n.
На самом деле, формально здесь 2n, 2n, 2log n.
Но это ничего не меняет.
Второе действие мы берем, разбиваем на пары.
Ну, это что?
Мы просто расходимся по массиву.
Это o от n.
Ну, значит, это поменьше.
Их сумма это o от n log n.
То есть подробно, конечно, можно не расписывать, как считается асимпточка.
Но вот два таких простых действия.
Значит, асимпточка всего алгоритма n log n.
Весь прикол задачи в корректности, кажется.
Нет, весь прикол, наверное, придумать.
Но самое сложное здесь это доказать корректность.
Что мы делаем?
Ну, ее можно доказать от противного.
То есть у нас есть какой-то набор, который мы получили.
Вот таких пар такого вида.
И мы утверждаем, что он подходящий.
Максимум таких сумм он минимален.
Ну, можно предположить, что он не минимален.
И представить другое развиение.
Допустим, у нас сумма максимальна в какой-то паре.
На самом деле здесь делается индуктивно.
Смотрите, если у нас n равно единице, то у нас всего одна пара.
Ничего интересного в этом случае не происходит.
Если n равно 2, то что мы говорим?
Что у нас есть 1, a2, a3, a4.
И на самом деле можно просто руками посмотреть, что они уже отсортированы.
И мы смотрим, что если у нас как-то по-другому,
это означает, что либо a1, a2 пара есть.
Либо вот эта пара и вот эта.
Либо вот эта пара и вот эта.
Здесь легко показать, что у нас вот эти два числа меньше.
Каждый из них вот этих двух.
И у нас максимальная пара будет a3 плюс a4.
Но наш алгоритм бы выдал a1.
Но это явно больше, чем a1 плюс a4.
И больше, чем a2 плюс a3.
Правда?
У нас эти просто самые большие числа.
Значит, вот такое разбиение точно не подходит.
Это первый случай.
А второй, что мы разбили вот так на пары.
То есть у нас вот так.
У нас есть сумма 1 плюс a3 и a2 плюс a4.
Но у нас a2 плюс a4 явно больше и равно, чем a2 плюс a3.
А это больше или равно, чем a4?
Нет, а сейчас.
Я, кажется, сама запуталась.
1 плюс...
Меньше ли, должно быть в другую сторону.
Чем a1?
Сейчас.
Какая-то путаница вышла.
Сек.
Там у нас, когда мы так разбиваем.
Сейчас.
На самом деле, мы здесь оценивали одной вот такой суммой.
А на нас было, мы знали, что она максимально.
А там?
Что?
Вот здесь?
Слева?
Нет, смотри.
Здесь мы что хотим показать?
Что наше вот такое разбиение, оно действительно оптимально.
Да, действительно, она больше, чем a2.
Да, спасибо.
У нас есть какая-нибудь тряпка?
Этого действительно достаточно, потому что она одна.
О, кофе, конечно.
Сейчас.
Она станет чуть.
А воды тут нет?
Вода есть.
Чуть-чуть сейчас.
Ну да, и у нас вот это и больше или равно, чем a1 плюс a4.
Ну это, допустим, была база.
А что мы делаем по индукции?
У нас есть теперь вот такой отсортированный массив.
A2n-1, a2n.
И мы предполагаем, что у нас для n верно.
Соответственно, если мы уберем вот эти два элемента, то у нас внутри отсортированный массив выдаст то, что нужно.
Значит, теперь, когда мы запустили наш алгоритм для вот всего массива, то у нас вдруг что-то поменялось.
Если что-то поменялось, это означает, что у нас минимальный или максимальный элемент в паре не друг с другом.
Это понятно, ведь?
Ну вот этот переход.
Хорошо, у нас предположим, вот это минимальный элемент, вот этот максимальный.
Допустим, они в паре с каким-то a, а максимальный с каким-то b.
Ну тогда у нас на самом деле повторяются те же самые рассуждения.
Пусть у нас вот это число максимальное от суммы это m.
Теперь мы сравниваем. То есть мы знаем, что любые суммы вот здесь, то есть любые суммы вот в этом отсортированном массиве пар, они меньше или равны, чем m.
Ну, что мы сделаем? Мы поменяем теперь вот такие пары на пару min-max и ab, как мы и хотели изначально.
И тогда, что мы скажем? Что у нас min-plus-a меньше или равен, чем m.
Ну, потому что мы как раз m-такое взяли в нашем разбиении.
И max-plus-b тоже меньше или равен, чем m.
Теперь мы, теперь в нашем теперь будет, сейчас min-plus-max будет меньше, чем вот это.
И тоже меньше, равен, чем m.
А a-plus-b будет меньше и равно, чем max-plus-b. Тоже меньше и равен, чем m.
Значит, то, как мы разбили, это как минимум не хуже.
Поэтому если мы вдруг, если у нас есть какое-то альтернативное разбиение, то хорошо.
Но наш алгоритм находит то, которое не хуже любого хорошего.
Понятно суть? То есть, общая концепция такая. Мы взяли какое-то другое разбиение.
Абсолютно любое мы можем взять.
И потом показываем, что то, которое приводит наш алгоритм, оно не хуже.
И этого достаточно сказать, что оно оптимальное.
Потому что если есть что-то получше, то мы снова можем сказать, что оно не хуже.
Я там в середине запуталась. Вы не потерялись по дороге?
С какого момента? С начала? Хорошо, давай вообще в чертах.
Сейчас я точно не запутаюсь, смотри.
Ну, алгоритм понятен, как действует. Хорошо, теперь про корректность.
Мы доказываем по индукции.
То есть, для n равно 1 мы рассматривать не будем, там всего одна пара.
Для n равно 2 мы рассмотрели, наш алгоритм приводит пары a1, a4, a2, a3.
Мы теперь рассматриваем, вдруг у нас есть разбиения получше.
Какие будут тут есть разбиения?
Ну, их типа конечное число это a1, a2, a4.
Или a1, a2, a3, a4.
Ну, вот второе, оно не подходит, очевидно, почему.
Потому что у нас a3, a4 – это самые большие элементы.
И они будут явно больше, чем a1, a4 и a2, a3.
Это мы отбросили сразу.
Теперь у нас, возможно, случай a1 плюс a3 и a2 плюс a4.
Но a2 плюс a4 больше, чем a2 плюс a3.
Ну, понятно, почему, потому что a3 меньше, чем a4.
И a1 на 3, ну, собственно, a2, a4 больше, чем a1 на 3.
Соответственно, эти оба варианта, ну, не лучше точно.
Потому что здесь нестрогие неравенства, они могут быть такими же.
Хорошо, для базы мы доказали.
Шаг какой?
Мы отсортировали массив, потом здесь взяли…
Ну, а потом в центр мы умеем отсортировать.
То есть наша сортировка плюс последующий выбор пар, короче, наш алгоритм.
Он на вот этих элементах действительно сделает оптимальный выбор пар.
Теперь его запустим на всем алгоритме.
Добавим вот эти два элемента.
Что у нас может измениться?
Что что-то станет вот этими элементами, крайними.
И у нас станут пары…
Это мы назвали минимум, это максимум для наглядности.
И что у нас может быть?
Что они стоят не в паре друг с другом.
Они стоят не в паре друг с другом.
Это значит, что у нас минимум стоит с a, а максимум с b.
С каким-то b.
Ну, вот этот a — это не максимум, а b — не минимум.
И что мы показываем?
Что у нас пусть m — это вот то максимальная сумма в паре, то записанное число.
И что тогда?
Тогда у нас m меньше равен чем минимум плюс a,
потому что это по определению у нас любая сумма в нашем разбе меньше равна чем m.
И то же самое — максимум плюс b меньше равна чем m.
А теперь мы делаем оценку.
Мы поменяем вот в этих парах…
Поставим минимум с максимум в пару и a с b.
Тогда у нас мин плюс максимум меньше чем максимум плюс b,
потому что b не больше чем минимум.
Не меньше.
А a плюс b меньше чем максимум плюс b,
потому что b не больше чем максимум.
И, значит, у нас транзитивность — вот такие оценки.
Значит, у нас вот наше разбиение, которое мы теперь получили,
поменяв вот в этих парах элементы местами,
оно стало не хуже, потому что вот эта максимальная сумма,
она как минимум не изменилась.
Может быть, она стала лучше, но мы этого не знаем.
И общая идея такая, что если у нас есть решение получше,
то мы можем сказать, что и наше решение не уступает вот этому лучшему решению.
Значит, у нас оптимальный алгоритм.
Вроде разобрались, да?
Да, Вить?
Да.
Мы переходим от n-1n.
У нас есть вот этот массив.
Мы обрезаем массив, убираем первый и последний элемент.
И на нем алгоритм будет...
У нас алгоритм сортирует, и у нас сортировка не изменится от этого.
И мы знаем, что если мы отсортировали массив,
и вот на элементах, кроме крайних,
мы предположили, что действительно наш алгоритм выдаёт оптимальное разбиение на пары.
А потом добавили крайние элементы.
И показываем, что если у нас...
Мы не добавляем элементы, мы сортируем, а потом рассматриваем средний под массив.
Просто если мы...
Ну да, мы сначала сортируем, потом бросим элементы.
Мы разбиваем на пары и говорим, что такое разбиение оптимально.
А потом смотрим, какое может быть другое разбиение, если мы добавим крайние элементы.
Вот.
Да.
На самом деле...
Он, может быть, существует.
Может быть.
На самом деле, когда мы...
То есть нигде в задачах не просят доказать, что ваш алгоритм работает быстрее всех остальных алгоритмов.
То есть...
Она работает дольше.
Понимаешь, просто контрольный рубцов работает так, что там не сказано,
чаще всего не сказано, за какое время ты должен решить задачу,
ну, за какое время должен работать алгоритм.
Но если он работает недостаточно быстро, по мнению автора задачи,
то это будет минус балл.
То есть, возможно, существует, но ни мы, ни автор задачи об этом не знают.
Да. То есть, бывает такое, что ты придумал алгоритм, но есть быстрее,
и ты просто не думал, что это будет не полный балл.
Да.
Короче, тема с алгоритмами и скоростью.
Иногда бывает такой прикол, что, например, кто-нибудь очень крутой придумал задачу
и говорит, а вот у нее есть там решение за линию.
Но это решение за линию настолько замудренное и страшное, что рубцов говорит,
нет, я готов оценивать полным баллом решение за n log n.
То есть, грубо говоря, как?
Какие у вас есть базовые? То есть, у вас есть сортировка, у вас есть сортировки там какие-то с приколами,
если речь идет о ни каком-нибудь рандомной сортировке с сравнениями,
а просто о сортировке с приколами под счетом, еще чем-нибудь,
который работает быстрее, чем n log n, но использует свойство сортируемого.
Ну и, собственно, тогда это может обводить шутка быстрее.
Ну так, в принципе, если не видно, если практически не видно линейного алгоритма
через какие-то порядковые статистики или хитрые сортировки, то, скорее всего, там будет он лукор.
Чисто как на эмпирическим путем посмотрено, что едва ли алгоритм
затребуется где-то быстрее, чем n log n, но если там не очевидная линия
через какие-нибудь те же порядковые статистики.
Да, иногда бывает, если слишком уж страшное решение какое-то быстрое,
то может быть, что по мнению автора оно решается за линию,
по мнению Александра Александровича, оно решается за n log n,
типа на уровне студентов, без использования каких-нибудь замудренных структур
или еще ничего не будет, и n log n канает.
Ну да. Я хотела забыть...
Ну, наверное, если ты напишешь о...
Короче, изначально вроде предполагается, что мы оптимизируем по времени,
но бывает, где в задачах оговорено, что а теперь построите так, чтобы память
занимала не больше алгоритма, или что-нибудь такое.
То есть если нет ограничений на память, как бы прописанных задач,
то можно сказать, что да.
В целом, да.
Если не прописано отдельное ограничение, что память такая-то, такая-то,
не больше чем, то у вас не ограничено это.
Ну или если написано не словами, что... Можно написать словами,
типа построить онлайн алгоритм.
То есть он тоже накладывает ограничения по памяти, что мы ничего не запоминаем.
Ну, там, констант запоминаем, в смысле, не запоминаем массиве.
Еще одна задача как раз немножко с ловушкой,
потому что решение, которое первое приходит на ум, оно неправильное.
Ну вот оно мне пришло, к сожалению, на контрольный.
Короче, звучит она так.
Есть массив A, в котором n элементов, опять массив,
и элемент называется пиком, если... Вот я сейчас запишу условия, чтобы это не озвучивать.
Вот it элемент – это пик.
Если A it больше или равно, чем A i плюс первое,
и больше равно, чем A i минус первое.
Это для всех i, то есть у нас есть массив A1, An.
Это для всех, от 2 до n минус 1.
А для крайних элементов такое.
Вот этот элемент тоже может быть пиком, если он больше или равен, чем A2.
А An является пиком, если он больше или равно, чем An минус 1.
Ну такие логичные штуки, если мы нарисуем, типа у нас n,
а вот это An, то это какой-то максимум функции.
Вот, функция дисклет. Ну ладно.
И просятся найти, просят построить алгоритм, который находит пик массива.
Первое, что приходит на ум, нужно просто найти максимум функции.
Это делается, очевидно, за o от n.
Но нас просят пик просто, такое удовлетворяющее неравенство.
И такое, спойлер, можно построить за n лог n.
Ой, просто лог n.
Какой здесь алгоритм?
Ну, для начала мы проверяем крайние точки.
Если они нас удовлетворяют нашим условиям, то мы нашли пик за o от 1 вообще хорошо.
Типа, проверка a от 1 и a от n минус 1.
От n.
А ведь условия понятны, да?
Да, любой.
Любой. Их может быть сколько-то.
Может быть, n пополам. Нам нужен какой-нибудь.
Но понятно, почему он обязательно есть.
Хорошо.
Проверяем крайние элементы.
Если они не пики, то приходим дальше.
А дальше мы что делаем?
Мы заводим перемены для правой и левой.
У нас есть вот массив.
У нас есть указатели. Изначально левый указывает сюда, а правый сюда.
Изначально вот мы такое пишем.
Это a от n, а left это a от 1.
И мы потом смотрим в середину.
Дальше мы смотрим, как мы заводим m равное l плюс r пополам.
Ну, какое-то округление.
И что мы смотрим? Мы проверяем, является ли амт пиком.
Если да, то вообще хорошо, мы нашли.
Если нет, то какие возможны тут случаи?
Если у нас амт меньше, значит одно из тех условий не выполняется.
Ну, у нас не крайние элементы, мы уже проверили.
Значит, мы проверяем вот эти верхние два.
Значит, у нас какое-то из условий не выполняется.
Значит, амт, первый случай, амт меньше, чем ам плюс 1.
Тогда мы что делаем? Мы говорим, что у нас сейчас, если у нас меньше следующего,
то мы говорим, что у нас левый теперь равен ам, то есть подвинули указатель.
Если у нас амт оказалось меньше, чем ам минус 1, то у нас правая граница двигается в амт.
Ну и так сужаем. Пока у нас это мы делаем, пока там допустим, r минус l.
В авторском решении больше 5, больше равно 5.
Ну, в общем, здесь может быть, мне кажется, любая константа до 3.
Ну да, нам достаточно проверить. Мы можем брать, когда 3 центры и проверять то же самое.
Вот. Это покажется более интуитивным, и это плюс-минус два шага, поэтому не очень важно.
А теперь вопрос, почему это работает.
Ну, здесь важно заметить, то есть ту картинку я не хотела оставить, потому что, мне кажется, очень логично.
То есть когда мы начинаем, вот у нас с нулевой, вот n элемент первый, то у нас вот как-то так следующие элементы идут себя.
То есть у нас здесь возрастает, а здесь убывает.
Теперь, когда мы, допустим, мы подвинули в случае а, левую границу, это что значит?
У нас вот есть m и m плюс 1, и у нас вот это больше.
Значит у нас снова, не здесь, наверное, где-то, а вот снова возрастает, а здесь убывает.
Если вот эту границу подвинули, то у нас вот это больше, чем вот это, значит у нас вот здесь возрастает, а здесь убывает.
То есть у нас сохраняется такое свойство левая и правая граница.
Что это может говорить нам о Василье?
Что у нас, на самом деле, это показывает, что у нас вообще есть пик.
То есть если у нас где-то убывает, ну где-то возрастает, а где-то убывает потом, то у нас, кажется ли это очевидно?
То есть, на самом деле, даже Рубцов в критериях казалось это очевидным.
Но вам понятно, почему у нас, если где-то, ну то есть в начале массива возрастает, потом убывает, то где-то между ними есть пик.
Ну хорошо.
Ну тогда, и он не на концах, потому что у нас концы, очевидно, уже не могут, они не подходят, значит где-то между.
То есть мы можем здесь итеративно идти типа вот этот, если есть что-то побольше, то мы будем также возвращаться, но мы не сможем это делать все время, потому что у нас самое левое вершинное пик.
Ну хорошо, то есть мы на каждом шаге двигаем границы так, что у нас пик где-то между этими границами, не включая эти границы.
И в конечном счете мы, ну и в конечном счете у нас каждый раз ответы поиска уменьшаются, значит пик мы найдем.
То есть когда у нас R-L стало меньше или равно пяти, ну или какой-то констант, меньше или равно какой-то константы, то мы просто можем перебрать константу этих элементов массива и проверить, является ли оно пиком.
И понятно, теперь просим точку. Как я сказала, она работает от log n, но это понятно, мы здесь берем средний элемент, это работает как bin поиск.
То есть грубо говоря, это просто модификация bin поиска. То есть если в первой задаче нам нужно было готовым алгоритму воспользоваться, потом как-то хитро доказать его корректность, то здесь нам нужно было известный нам алгоритм модифицировать.
Ну а корректность, она даже представитель задачи кажется интуитивно понятной, просто важно было описать правильно и придумать этот алгоритм.
Вот. Соня, о чем у нас там по времени? Про статистику что-нибудь расскажите?
У нас уже немало.
Ладно. Что еще? Из таких тем, которые, не знаю, bin поиск и сортировки, они кажется достаточно понятными, чтобы модифицировать.
Я подумала, что не такими очевидными, кажется, к порядковой статистике. Наверное, надо помнить, что это такое, ну в смысле, как оно ищется.
Ну то есть к порядковой статистике, это вот если у нас есть какая-то массива, то если массив отсортировать, то это к порядковой статистике, это значение того элемента, который будет стоять на катом месте.
Да, хорошее уточнение, возрастание отсортировать.
Оно ищется, то есть чтобы строить модификацию этого, наверное, нужно помнить, как оно работает, как ищется к порядковая статистика.
Ну там есть какой-то быстрый вариант, но он основывается на базу, что он делает. У нас есть же, быстрая сортировка. Все помните, как работает быстрый сортировка?
У нас же там есть, вот у нас массив, и мы выбираем какой-то элемент, катый.
И дальше сортируем, вот, не знаю, от одного, короче, мы сортируем все элементы, которые меньше окатыва и которые больше окатыва.
И здесь мы делаем то же самое. Мы берем какой-то элемент, сортируем и получаем, мы, допустим, мы выделили два под массива.
Как бы записать?
Мы выделили два под массива, а дальше мы смотрим, и у нас где-то здесь есть опуск.
И дальше мы смотрим, если у нас вот индекс вот этого элемента равен k, q равно k, то вот мы нашли катый порядковую статистику.
Если у нас q оказалось больше, чем k, то это, ну, мы же помним, что при сортировке у нас вот эти будут сортироваться, но в отсортированном массиве, а q будет стоять здесь.
Ну, значит, если у нас q больше, чем k, то мы ищем вот в левом под массиве.
А если q меньше, чем k, то мы ищем вот здесь. Понятно, что происходит, да?
Это вот как работает статистика. Она работает за, есть ее быстрая модификация, и она работает за odd n.
Это быстрее сортировки, поэтому, когда просят построить эффективный алгоритм чего-нибудь, и там нам не нужны все элементы, там все пара элементов,
а нужно только какой-то один конкретный, то нужно подумать о том, а можно ли построить это быстрее, чем за n log n?
Потому что n log n нам даст положение всех элементов друг относительно друга, а нам здесь нужен один. Возможно, мы сделаем лишнюю работу.
Я не нашла и не придумала задачу, где нужно модифицировать алгоритм кат и порядковой статистики, чтобы это еще было адекватной сложностью,
но на прошлой контрольной была задача, где нужно было его применить. Задача звучала так.
На Олимпиаде по знанию алгоритмов сортировок было n участников. Известно, что некоторые балл t набрало больше, чем n делить на 5 участников.
И нужно предложить эффективный алгоритм, который находит такой балл. Если подходящих t несколько, то можно увести любой.
Ну и t – это целое неотрицательное число. Верхних ограничений нет. То есть верхних ограничений нет для людей, которые хотят использовать сортировок по подсчетам,
потому что здесь у нас сложность o от n. Сортировки по подсчетам тоже o от n. Вроде формальные условия выполнены, но вот уточнили, что им пользоваться нельзя.
У нас было n участников, и у нас понятного условия. У нас n участников, и каждый из них набрал какое-то количество баллов.
То есть у нас t1, t2, tn – это результаты участников. И вот таких t, то есть у нас множество t – это такие t и t, что t и t равно t.
И вот таких t, n пополам. Ой, n на 5. Понятно, что тут большая задача? Первый шаг – это понять условия. Она понятна, да? Хорошо.
Что тут можно сказать про… Ну, нужно как-то воспользоваться катой, порядковой статистикой. Ну, у нас есть логичный вариант пооспользоваться n на 5 порядковой статистикой.
Зачем это может быть нужно? Ну, смотрите, если у нас какое-то конкретное количество баллов t набрало, хотя бы, ну, то есть n на 5 участников, то это значит…
Ну, запишем, отметим, вот у нас на прямой результаты. У нас где-то есть t1, там t3, t4, tn. Вот. И еще что-то там есть.
И вот у нас, очевидно, здесь есть t5, не знаю, t сколько-нибудь. Вот в этом числе. Значит, если мы отсортируем, а если у нас отсортировано, то у нас они будут идти друг за другом.
И у нас какие-то… И мы можем посчитать… И у нас, смотрите, если мы разобьем множество всех результатов на пять одинаковых частей, то у нас вот какую-то часть…
У нас есть отрезок длиной n на 5, потому что, ну, у нас есть ответные. Каждое, не знаю, каждое черточка – это какой-то участник.
И у нас, если мы разобьем вот так этот отрезок результатов от минимального до максимального, там от нуля до максимального балла, то у нас будет отрезок длиной n на 5.
Это значит, что он какую-то порядковую статистику покроет. То есть, если мы разобьем на пять одинаковых отрезков, если мы разобьем на пять отрезков результаты участников,
а у нас вот какой-то конкретный бал набрали n на 5 участников, то это, в принципе, рехле. У нас вот этот отрезок, человек, который получил t баллов, он покроет один из таких штрихов.
Это n на 5, это 2n на 5 и так далее, и n. Понятно, что происходит?
Вот, супер. Значит, мы посчитаем n на 5 порядковую статистику, 2n на 5 порядковую статистику и так далее, n. Мы посчитаем такие всего пять – это константы. У нас совсем точка не изменится.
А дальше мы должны их сравнить. Мы дальше должны просто пройтись по массиву и посчитать, сколько у нас элементов равны каждой из порядковой статистик.
Мы заведем такой массив. И в каждой из них будем записывать, сколько элементов равно n на 5 порядковой статистики, сколько 2n на 5 порядковой статистики и так далее.
И в конце мы найдем какое-то, то есть мы показали, что у нас какой-то порядковой статистики будет равно n на 5.
n на 5 – это количество человек, которые получили такое количество баллов. А теперь мы просто пытаемся найти, какую именно порядковую статистику, вот, какая именно порядковая статистика – это t. Понятно?
Есть еще альтернативный вариант. Мы ищем не n на 5, а n на 10. Зачем?
То есть мы разобьем на 10, а дальше просто говорим, что если у нас есть отрезок длины n на 5, то он покроет две порядковые статистики. Правда?
В общем, бред, да?
Покроет две порядковые статистики, и мы посчитаем таких 10 штук, и какие-то две будут равные.
Ну, собственно, мы просто их попарно сравним. Это тоже константы в вычислении. И найдем. И те, которые равны – это и есть, собственно, наш балл t.
То есть понятно, что произошло, да? Ну, просто киваете.
То есть здесь нужно было понять, какую просто порядковую статистику считать, но никакой оригинальный алгоритм не нужно было изменять.
Вот. Ну, да, асимптотика здесь оценивается очевидно, что мы пять раз посчитали какую порядковую статистику, и потом константа…
То есть либо мы прошлись по массиву, это от n, либо мы сделали константное количество сравнений. Это тоже не изменило асимптотику.
Собственно, будем смотреть на протоколы РСА, а перед этим на штуки про такие алгоритмы, которые используются для расчетов.
Ну, помним про алгоритм Евклида расширенный и про быстрое возведение в степень. Как работает быстрое возведение в степень?
То есть мы хотим… Ну, понятно, возведение в степень – трудоемкая тема, умножение само по себе не особо вкусно.
Возведение в степень – это еще и многоумножение, это еще более мерзкая тема.
Ну, хотим возвести в степень как можно быстрее, и помним, что хотим возвести в нечетную степень число.
Вот я хочу возвести число b в степень n. Если n нечетная, тогда это будет что?
b в степени n-1 пополам в квадрате умножить на b. Логично, логично.
Если это нечетная, то тогда это будет b в степени n пополам в квадрате. Логично, логично.
Уже уменьшаем. Тут n пополам умножение убрали, там еще n на 4 уберем, и так далее, и так далее.
Собственно говоря, мы не хотим морочить себе голову с умножениями в количестве n штук,
но вот так достаточно логарифм n умножений будет и произвести.
Еще лучше, если это делается по какому-то модулю.
Например, вообще в компьютере всегда это делается по какому-то модулю,
но тот же 32-битный INT это по модулю 2,32 будет считаться.
Ну а если мы хотим работать по какому-то модулю поменьше,
как, например, в том же протоколе RSA, который будем сейчас смотреть.
То есть там по модулю 13, по модулю 20, по модуле там еще кому-нибудь.
Окей, я хочу возвести 3 в 21, по модулю 13.
Тут совсем просто будет.
Ну что я хочу сделать?
Ну как? Все просто. 3 в 21, то же самое, что 3 на 3 в 10 в квадрате.
Это то же самое, что 3 на 3 в 5 в квадрате в квадрате.
3 на, скобка, скобка, 3 в квадрате, в квадрате на 3, в квадрате, в квадрате.
По модулю 13, если смотреть, это, соответственно, 3 на, скобка, скобка.
Получится 9, 9 это что по модулю 13?
Вот это 9, 9 это что по модуле 13, ты минус 4.
Минус 4 в квадрате на 3, квадрат, квадрат.
Это то же самое, что 3 на, минус 4.
Это тоже что, минус 4 в квадрате, тоже что 4 в квадрате.
16, 16 по модулю 13, это 3.
Собственно, 3 на 3 в квадрате, в квадрате.
Это что? Тройка остается, как была.
3 на 3, 9, 9 это минус 4, минус 4, квадрат, квадрат.
Это то же самое, что 3 на, что?
3, короче, в квадрат, 3 квадрат, 3 на минус 4, минус 12, вот.
Логично, логично. Быстро, быстро.
Вот. Собственно, быстрее, чем могло бы быть.
Да и плюс мы не делаем каждый раз, не зяним за собой большое, большое число.
Вот. Долго.
Собственно, быстро разденемся опять дальше.
Алгоритм Евклида.
Как известно, алгоритм Евклида из школы, это поиск наибольшего общего делителя.
Если у нас наибольший общий делитель двух чисел, то мы из большего вычтем меньшее.
Потом из того, что получилось, насчет это меньшее число и разность.
Из того, что из них больше, вычтем то из них, что меньше, и так далее,
до тех пор, пока либо не наступит наибольший общий делитель, вот.
То есть либо до тех пор, пока эти два числа не станут равны,
либо до тех пор, пока там единицы не вылезет где-то.
Вот. Алгоритм Евклида расширенный.
Ну, в чем его расширенность?
В том, что Диафантово – уравнение.
Это уравнение в целых числах Лида.
Ах плюс Би век равно С.
Оно имеет решение или не одного, или бесконечно много.
Вот.
Ну, собственно, когда не одного, когда бесконечно много,
когда К работает расширенный алгоритм Евклида, расширенный алгоритм Евклида,
я хочу найти наибольший общий делитель этих вот А, Б и С.
Почему? Если вдруг А и Б делятся на то, на что С не делится,
то мы никак не получим никакого решения.
Потому что правая часть будет кратно, скажем, К, а левая часть не будет кратно К.
И мы уже никак не сможем, домножая ни на что, ничего изменить.
Просто тут вылезли козыскотка, а тут нам выносить нечего.
Вот. Находим наибольший общий делитель.
Второе. Делим наибольший общий делитель.
Или нет корней сразу.
Дальше расширенный алгоритм. То есть мы записываем х, у,
но пусть будет а штрих, пусть будет b штрих, пусть будет c штрих.
Х, у, а штрих, х, плюс b штрих, у, а штрих и b штрих.
Наибольший общий делитель – это единица.
Логично, логично. Поделили, все посокращали, все поубивалось.
Вот так, вот так, вот так и вот так.
Соответственно, здесь будет а штрих, здесь будет b штрих.
Дальше. Проводим итерации, как у обычного алгоритма Евклида.
Поиска собственного наибольшего общего делителя.
Как? Из большего вычитаем меньше, мы вычитаем не об и как, а построчно.
То есть вот я вычела из а штриха b штрих.
Это значит, что я здесь, например, запишу 1 минус 1, а штрих минус b штрих и так далее.
То есть я провожу обычный алгоритм Евклида с правой частью,
а левую часть при этом построчно за ней тяну.
В конечном итоге будет х ноль штрих, у ноль штрих, единица.
Если корни есть, хоть какие-то. Вот.
Х ноль штрих, у ноль штрих, единица.
Дальше. Х ноль это c штрих, х ноль штрих.
У ноль это c штрих, у ноль штрих.
Это частное решение.
Почему частное решение? Ну, все просто, типа, да можешь ли обещаешься на c?
Вот и все. На 1 c штрих. Окей.
А дальше осталось найти общее решение.
А что такое общее решение?
Мы говорим, что a штрих х плюс b штрих у равен c штрих.
Тогда х это х ноль плюс b штрих на целое число,
у это у ноль минус a штрих на целое число.
Почему? А очень просто.
А потому что, если мы поставим сюда, то здесь будет h штрих b штрих k,
здесь будет минус h штрих b штрих k,
и остается то, что было часто в решении у нас.
Логично.
Доказательство того, почему это все решение дает, там побольше будет.
Я вам голову морочить, и он на быстром таком расшарчике не буду.
Ну, собственно, причем здесь важно.
Прямо вот ультраважно. Прямо вот 3 отрицательных знака.
Вот а штрих b штрих равен единице.
Иначе мы потеряем решение. Целую пачку решений потеряем.
Именно вот этих вот общих.
Дальше.
Что происходит дальше?
Это зачем? Решим давать какое-нибудь диафантовое уравнение.
Какое-нибудь...
Многие крутили какое-нибудь.
Давайте 31.
Нет, 31 плохо. 32.
32х плюс 18у равно 2.
Окей.
Собственно, первое алгоритм не вклеено.
32, 18.
Бьет во что? Ну, 32-18 будет...
Это будет 18, 16.
18, 2.
И так далее. 4, 2, 2, 2.
Вот выиграли. Вот он наибольший общий делитель.
12, 2, 16, 2, 14, 2, там 12, 2, 10, 2, 8, 2, 6, 2, 4, 2, 2, 2.
Совпали? Прекрасно.
Наибольший общий делитель.
Нод равен 2.
Двократно.
И решение 10.
Если бы здесь было, например, 3, то решений бы не было.
То есть вот здесь нод равен был бы 2,
а правая часть на 2 бы не делилась.
Все, до свидания. Решений нет.
Итак, двократно.
Следственно, второй этап.
Мы сократим на нод все.
16х плюс 9у равен 1.
А дальше что?
А дальше все просто.
Значит, х, у, 16х плюс 9у.
1, 0, еще 16.
0, 1, еще 9.
16-9, 7.
Значит, 1, минус 1, 7.
Вычитаем опять из этой строки эту строку.
То есть что будет?
Минус 1, 2, 2.
Дальше что? Вычитаем.
Из этой строки эту три раза.
Можно сразу, можно не тащить за собой.
А там 7, минус 3, 2.
Окей, ладно.
1, минус 3, минус 1.
То есть плюс 3, это будет тут 4.
Значит, минус 1, минус 3, 2.
Это будет минус 7.
Вот 1.
Ну вот и все.
Частное решение.
Х0 равно.
Значит, здесь домножать не на что не надо.
Если бы, например, 4 написано,
здесь была бы 2.
И мы бы домножали на 2.
Но тут 4 не написано.
Написано 2.
Вот.
Тогда х0 равен, получается, 4.
y0 равен, получается, минус 7.
Окей, осталось найти общее.
Общее, вспоминаем формулу.
х равен х0 плюс 9k.
y равен y0 минус 16k.
Вот так.
Все, все.
На том и порешили.
Дальше.
Как эти две вещи сконетчены
с достаточно важной темой
криптографический протокол RSA.
Вот.
Как эта тема работает.
RSA.
Вот тут сидит Алиса.
Вот тут сидит Боб.
Вот.
Алиса хочет написать сообщение Бобу.
Вот тут сидит Ева.
И пытается это все подслушать.
Вот.
И мы хотим, собственно, чтобы Ева не поняла
о том, что Алиса говорит Бобу.
Вот.
Пусть Боб улыбается.
Да, пусть Боб улыбается.
Ладно, вот Алиса что-то пишет Бобу.
Какое-то сообщение.
Понятно, что если Ева тут сидит и смотрит,
слушает, то если сообщение не зашифровано,
то она его прочитает десять раз,
пойдет растрепит все, что Алиса рассказывает Бобу.
Ну ладно.
Алиса хочет, чтобы Ева это не прочитала.
Окей.
Она берет число N,
которое равно произведению двух простых чисел.
Простые.
Некоторые так обозначают,
потому что это, на самом деле,
достаточно конфликтная буква.
Blackboard как R, как C.
Некоторые так обозначают простые числа,
так что не пугайтесь.
Вот.
Почему?
Если N большое,
прям какое-то десятизначное,
то разложите его на два простых множителя,
которые сами тоже там немаленькие.
То есть не дважды там 1, 2, 3, 4, 5,
а там какой-нибудь 330 там что-нибудь,
умноженное на 1500 там еще что-нибудь.
Как бы, имея только произведение их,
Ева не умеет, значит,
эффективно раскладывать это все на множители
и эффективно находить по ику.
Зачем ей эффективно находить по ику?
Есть такая тема,
как Фиатен, функция Эйлера.
Это у вас на воидке?
Это у вас на воидке.
В общем, Фиатен, функция Эйлера,
это количество чисел,
меньших N и взаимно простых с ним.
От простого числа
Фиатен равна N-1,
от произведения нескольких простых чисел
она будет равна
T-1Q-1.
Вот.
Если мы будем знать Фиатен,
вот.
Если мы будем знать Фиатен,
то посчитаем все эти зашифровки
и расшифровки RSA.
Если мы не знаем Фиатен,
тогда мы это не посчитаем.
А чтобы знать Фиатен, нам надо знать
разложение на простые множители.
Разлагать на простые множители,
N по полную задачу решать,
если там числа достаточно большие,
вот это вот не умеет Ева.
Окей, ладно.
Как, в принципе, эта тема работает?
Мы берем,
значит, мы берем число,
у меня M.
Есть публичный ключ,
есть приватный ключ, вот.
Соответственно,
у нас есть ключ,
вот у меня цифры.
Вот.
Есть вот это число Е.
Вот. Е и N.
Это открытый ключ Алисы.
Алиса хочет зашифровать им.
Естественно, вот у нее текст M,
который она хочет передать Бобу.
Она хочет.
Значит,
этот текст
зашифровать
с использованием
M ключа.
Соответственно, она берет сообщение M,
возводит в степень D,
считает ее по модулю
N и передает.
В это вот будет
зашифрованное сообщение.
Вот. Она передает
это Бобу. Дальше.
Что умеет Боб?
Он принимает эту штуку.
Значит,
вот это вот сообщение зашифровано.
Принимает Боб.
Значит, закрытый ключ.
Вот такой.
Берет.
Как считается D?
Сейчас разберемся.
Теперь он возводит C
в степени D.
Это будет мод
N.
И получает, собственно,
эту самую,
собственно, сообщение.
Почему? Потому что мы
число D и E подбираем так.
Вот. Мы хотим, чтобы
C D,
то же самое, что M в степени E
в степени D
было сравнимо с M
по модулю, собственно, N.
Ну, вот.
Сейчас на E мы должны найти D.
Мы должны уметь шифровать
и уметь расшифровывать.
Вот.
Будет еще цифровая подпись.
Для цифровой подписи нам понадобится уже,
значит, phi.
Ладно.
Допустим, мы знаем
число N.
Вот. Мы знаем число N.
Оно, ну, пускай, будет...
Как у него пример? Сейчас разберем.
Пожалуй, я пример с Евфридом сотру.
И будем разбирать.
Да?
Ну,
вы смотрите, D от...
E это ключ...
E это ключ
Алисы.
Вот. D это ключ Боба. Он генерируется
так, чтобы
они могли обмениваться,
чтобы вот Боб возводил
в свою степень D полученные
сообщения
и получал
да.
Открытый ключ Алисы.
Вообще-то...
Ну, как?
Смотрите.
Алисы возводит в понятную...
В открытую...
Ну, N общий.
На них, на двоих.
Вот.
Да.
Да.
И N, оно общее, как бы, на двоих.
Да.
Значит...
N оно у обоих.
Вот. N это число.
Оно равно P умножить на Q,
где P и Q простые.
Вот. А E и D они
это, собственно, ключи.
Вот.
Значит,
как это все работает?
Собственно,
у нас есть ключи.
У нас есть, значит,
число N.
Оно есть.
Дальше.
Мы ищем
Fiat N.
Вот.
Ну, пусть у нас будет там N равно.
Окей.
16 на 31.
Хочу.
Хочу такое.
Fiat N тогда будет 16 на 30.
Вот.
Это первое.
Первое задается число. Второе задается, значит,
находится его функция Эйлера.
Дальше.
Мы берем
число. Число E.
Которое открыто, открывается
открытым ключом. Вот.
Какое это выбирается?
Взаимно простое с Fiat N.
Ну.
17.
Или 14.
Давайте
19.
Да, 14 невзаимно.
Просто это плохо.
Тут 2 есть, и тут 2 будут. Вот.
19. Вот 19 точно или просто.
Дальше.
Мы, что мы хотим?
Значит, дальше что мы хотим?
Чтобы
D на E
было сравнимо с единицей
по модулю
Fiat N.
Вот такое мы хотим.
Как мы это можем считать?
Вот.
Ева не посчитает, потому что Ева не знает
Fiat N. Вот.
Как мы это можем посчитать?
Мы можем взять
и решить.
Что решить? На фантовое уравнение решить.
Логично. Что такое D E сравнилось
с единицей по модуле Fiat N?
Это значит, что
D
умножить на E
плюс
соответственно
какая-то константа, умноженная на Fiat N
равно единице.
Логично.
Вот. Минус константа
на самом деле.
Но плюс, минус там не важно.
Чисто для полного понимания.
Fiat N плюс 1 – это D на E.
Вот.
Ну, собственно говоря, что? E мы знаем,
Fiat N мы знаем, единицу мы знаем.
Соответственно, в нашем случае я хочу найти D.
Я подставляю сюда
значит
19D
минус
16 на 30 сколько будет?
На 480.
480.
Это умножить на K.
Это равно единице.
Дальше.
Мы умеем решать диафантовое уравнение.
Мы находим
вот отсюда.
Будем решать
или не будем время тратить.
Вот. Решать диафантовое уравнение
мы умеем. Находим нот
19, 480 – это будет
единица. Находим
значит
числа,
Y соответствующий.
Находим общее решение.
То есть на D
вот нужное нам
выбираем. Ну,
чтобы оно не было слишком огромным,
ну, их там, понятно, бесконечно много будет.
Ну, вот E у нас фиксированное.
Значит,
вот E фиксированное, оно меньше,
меньше, чем Fiat N.
Ну, то есть на D тоже должен быть меньше,
чем Fiat N, но остаток, по-моему, для Fiat N какой-то.
Вот. Из всего этого бесконечного
множества пар D и K
мы выберем там какой-то D,
которое достаточно мало, чтобы не трепать нам нервы.
Вот так, зная Fiat N, мы можем,
зная открытый ключ Алисы,
найти
приватный ключ Боба.
Вот. Дальше.
Дальше.
Вот эта штука.
E и N видны всем.
D
Да, Алисы
передают...
Да, я забыла,
да, я забыла, что
моего ключ. Ну, да, короче,
в общем,
Алисы шифруют ключом E
сообщение,
передаваемое Бобу.
Вот.
А Боб расшифровывает своим приватным ключом D
сообщение, передаваемое себе.
Да.
Ключа D Алиса не знает.
Алиса знает E.
Ну, да.
Алиса знает E.
Да, ключ Боба.
Да, все знают E.
Кто угодно может написать
Бобу и Алиса и...
Да, все знают E
и все знают N.
Да, никто не знает D,
потому что никто не может
разложить N на множители.
Никто не может разложить N
на множители.
Никто не может посчитать fiat N.
Никто не может
таким образом высчитать,
составить вот это диаф converging, никто не может.
И, соответственно,
никто не может насчитать D.
Да.
Вот. Ничего, да.
Все упирается, да,
в то, что вот они не могут разложить
Если найти достаточно эффективный алгоритм, который будет быстро раскладывать намножители большие числа,
то вы получите миллион долларов и разлом алгоритма RSA просто на патче.
Ну, значит, ты уже не ЕВА. Если ты ЕВА, то ты не придешь к Бобу и не попросишь.
Ну или Боб доверчивый дурачок.
А доверчивые дурачки как-то не будут пользоваться криптографическими алгоритмами.
Ну да ладно, вот. Собственно, как D находится, это понятно.
Ну теперь я хочу отправить сообщение.
Вот, я Алиса, я знаю пару EN, я знаю, что EN это 19 и 500 там с чем-то.
Там, короче, 17 на 31 пусть будет, как будет.
Вот. И я хочу отправить сообщение, ну, например, 5.
Хочу отправить сообщение 5 Бобу.
А вот. Ну ок. Я говорю, что я делаю шифротекст.
Как я делаю шифротекст? Я беру и возвожу 5 в степень 19 по модулю.
Давайте все-таки умножим и сейчас чиселки посчитаем.
Да, 17 на 31. 527.
Ок. Я говорю, что 5 в 19.
А вот тут быстро возведение в степень пошло.
Я не хочу считать миллиард лет. Это 5 в 19.
5 на 5 в 18.
5 на 5 в 9.
Можно сейчас сразу это все...
5 в 9 в квадрате. 5 на 5 в 9 в квадрате.
Это 5 на 5.
Так. 5 в квадрате.
5 в 4.
5 в 8.
5 в 9.
В 18. Вот так.
Логично? Логично.
Ну это что? Внешняя пятерка пока так пусть остается.
5 в квадрате. Это 25.
Раз, два, две скобки.
25 в квадрате.
В квадрате. На 5.
Все это в квадрате. Дальше.
Что будет?
25 в квадрате это 625.
625 минус 527.
Это 98.
Дальше говоря.
5.
98 в квадрате.
На 5.
И в квадрате.
Что такое 98 в квадрате?
98 в квадрате.
9000 с копейками.
527 0.
Еще опять 270.
Да.
Вот 5.
Да.
Вот.
Это 185 на
118 на 5.
В квадрате.
118 на 5.
Это 65 на 63 в квадрате.
Это что такое 63 в квадрате?
Вот.
Это 280 на 5.
Теперь это получается что?
Вот.
346.
Я отправляю 346
в Бобу.
Значит.
И собственно Боб
может возвести это обратно
в степень какую мы найдем.
Вот здесь насчитаем.
Когда мы решим вот эту штуку
мы найдем число D,
которое соответствует Бобу.
Возведем его в степень обратно.
И получим
нужное нам значение.
Почему эта штука работает?
Потому что ED это единица
к модулю phi от n.
Как известно, если мы возводим какое-то число
в степень phi от
числа
phi от n так к модулю n они совпадут.
Помним мы завоидка.
Если
вот ну
a в степени phi от n
сравнимо с единицей
по модулу n.
Помним мы завоидка.
Вот. Хорошо.
Вот наш RSA.
То есть если мы говорим я хочу отправить
сообщение такое,
то я зная вот открытый ключ
шифрую открытым ключом.
То есть возвожу в степень
открытого ключа по модулю числа.
Возвал быстрого зрения в степень.
Если говорят найдите приватный ключ,
то я составляю
диафантовое уравнение,
нахожу приватный ключ.
Если мне говорят расшифруйте,
то я беру этот шифротекст,
возвожу его в степень приватного ключа.
Логично?
Логично.
Осталась электронная подпись.
Вот.
Но что такое электронная подпись?
Это как под документами подпись.
Но тогда мы получается будем
отправлять.
Вот.
У нас есть у каждого
у каждого челика по алгоритмам
считается эта подпись, и мы будем отправлять
открытое сообщение
с открытой подписью.
Если я, например, хочу
отправить Александру Александровичу
письмо, я решила там
ваше задание по диплому.
И подпись Соня.
Эта подпись Соня, она будет не просто такая,
которую может каждый кто угодно написать.
Я там ее напишу. Но текст, что я там решила
ваше задание по диплому, будет там прямо так
текстово написано. Вот.
А если я не хочу, чтобы кто-то там
третью увидел, что именно
я ему говорю, если я ему
контрольную передаю, например,
то я должна буду потом ее опять засустровать.
То есть вот эту пару.
И сообщение, и электронные
подписи я буду рассматривать
как какое-то число.
Пусть будет М большое.
Опять прогонять его через
РСА. Вот. Через вон тот.
Передавать уже шифротекст
от вот этого вот.
И потом, допустим, Александр
Александрович будет расшифровывать это.
Видеть в нем какой-то текст.
И подпись. Вот.
Там, например, там
я захочу, там, вот, если на подпись
10 бит или там 20 бит.
А на сообщение там
300 бит. И первые 300 бит
после расшифровки будут знать
что это сообщение. Оставшаяся подпись
сможет сверить там подпись
полученную после расшифровки
подписью, которую он знает.
И текст, собственно, дальше прочитать.
Вот. Как строится
электронная подпись С.
Вот.
Значит, у нас есть
значит, наши ключи,
все дела.
Как строится
подпись.
У Алисы есть секретный ключ.
Вот.
И она этим секретным ключом
находит цифровую подпись
равную чему.
Значит, сообщение, которое она
хочет отправить в степени
своего секретного ключа
модулю N.
Вот.
Вот.
Ну, собственно, подпись мы знаем,
что это подпись и не обы что.
Вот. И, соответственно,
передаем эту пару
N. Да.
То есть вот я...
Да. Вот это Алиса.
Да. N Алиса. Вот. Вот.
Вот N, которая генерирует
подпись.
И N, которая передает сообщение.
Это две разных N. То есть сначала мы применяем
протокол для генерации электронной подписи.
Я хочу передать 5.
У меня секретный ключ.
Там, я не знаю,
11.
Ну, давайте 11.
У меня секретный ключ 11.
Я хочу передать сообщение.
Ключ 11.
Я хочу передать 5.
Тогда моя подпись будет 5 в 11.
По модулю там вот этого будет.
Там 5 в 7.
Да.
Вот. Да, подпись.
Ну, и как найти эту подпись?
Опять-таки быстрым возведением.
Вот.
Ну, а дальше
подлинности подписи.
Вот.
Вот это никто не знает.
Да, никто не знает. В алгоритме проверки
подлинности подписи. Вот это пара M S.
Каким-то образом, да, Боба?
У Боба есть
E N, то есть
Алисы на N и Алисы на открытый ключ.
Давайте вот здесь метим N A.
N Алисы, N Алисы.
Вот. Алисы на открытый ключ есть.
И N, который есть.
И, соответственно, пытается
он...
Вот есть
сообщение подписанное. Вот у него есть пара M S.
Он располагает
вот таким.
Он располагает ключом.
Открытым Алисыным.
Он пытается возвести подпись
в степень E.
Это то же самое, что
M в степени D.
В степени E.
Это то же самое, что M.
Логично?
Логично.
Соответственно, он должен...
Вот эта штука M S.
Вот эта штука M S.
По идее,
если подпись подлинна,
то есть если подписалась реально Алиса,
то тогда они должны
вот эта M и M S совпасть.
Если подписалась реально Алиса, раз,
и если никто по дороге не испортил
сообщение, два, вот.
Соответственно,
это штука
передается.
Она может, да, передаваться
в голом виде M S.
Но если мы хотим передать секретно,
то мы сначала подпишем.
То есть у нас будет N Алисы.
Мы подпишем при помощи N Алисы
сообщение
к подписью Алисы.
Потом мы возьмем другое N,
N Боба.
Зашифруем вот эту пару.
В этой паре поставим соответствие
Вот это число зашифруем
другим N, N Боба.
Потом Боб расшифрует
его своей D,
своей N, своей D
и получит этот M.
Потом он, зная, что, допустим,
там первые биты это одно,
последние биты это другое,
где проходит граница между сообщением
и подписью, отсечет сообщение
от подписи, потом он возьмет эту
подпись, возведет ее в степень
Алисыного E и проверит.
Совпадает то M, которое к нему пришло
с подписью и тем
M, которое должно было, или нет?
Все ли понятно про RSA,
про подпись?
Смотри,
все будут, да,
N знать все будут, но
никто не умеет его на множители
раскладывать, поэтому никто не может
посчитать phi.
Поэтому зная E и зная N,
никто не может найти D.
Соответственно,
у Алисы,
еще раз проходит, у нас есть,
чем мы суммарно в итоге
располагаем? Мы располагаем,
у Алисы есть
свое N, свое E,
давайте вернемся к тем
нарисованным классам.
У Алисы есть
N Алисы,
E Алисы,
оно всем видно,
и Бобу, и Алисе, и Еле.
Здесь есть N Боба, и E Боба.
Хорошо,
их тоже всем видно.
Вот здесь у Алисы есть N Алисы,
и D Алисы,
вот здесь у Боба
есть N Боба,
и D Боба.
И никто не знает.
Алиса хочет передать
сообщение M,
она возводит сообщение
M в степень
вот этого вот E,
сообщение M,
шифротекст,
это будет M в степени
E
Боба
по модулю N
Боба.
И вот этот шифротекст передается
от Алисы к Бобу.
Дальше, если Алиса
хочет подписать,
соответственно
отпись будет
сообщение
в степень D Алисы
по модулю N Алисы.
Да.
Вот.
Ну, N Боба
лежит у Боба.
Вот это разложение
на P и Q знает только Боб.
Алисе видно N,
Еве видно N,
еще как-нибудь там Майклу, Джону
и прочим видно N и E.
А P Боба и Q Боба
знают только Боб.
Ну и да.
Если Алиса хочет сказать, что подписаны,
то она сначала шифрует.
Сначала подписывает своим ключом.
Потом
полученную штуку перегоняет
как-то в число.
Вот.
Например, там подпись занимает
там 10 бит.
А сообщение занимает
20 бит.
Соответственно, получится число длиной
в 30 бит.
И вот это как число будем рассматривать.
Это число будем шифровать
ключом N Боба
и E Боба.
Возводить вот этот M-ка будет
состоять из пары перегнанных
в какое-то число.
Возводится в степень.
Дальше Боб
принимает полученную тему.
Возводит ее в степень своего D,
которая знает только он сам.
Получает какое-то опять-таки
30-битное число.
И в этом 30-битном числе
проходит граница между сообщением и подписи.
На первые 20 бит смотрит
как на сообщение.
На последние 10 бит смотрит
как на подпись.
Дальше он проверяет
подлинность подписи
путем возведения подписи.
То есть последних, грубо говоря, 10 бит.
В степень E своего.
E Алисонова.
Если сошлось,
то есть если сообщение,
то есть если последние,
допустим, 10 бит,
возведенные в степень E Алисы
дадут то,
что совпало с первыми 20 битами,
то значит все OK.
То есть E Алиса отправила сообщение,
подписала его подписью,
подписала же действительно она,
и сообщение не поменяли.
Собственно,
если где-то там по дороге поломалось сообщение,
или если где-то
или если подписала не Алиса,
то есть тогда будет ошибка.
Или если и то и то.
Буквально там настолько редко
может встретиться случай,
что они и подпись,
что вот, допустим, абстрактная E,
и подпись так хорошо поломала,
и сообщение так хорошо поломало,
что оно сошлось.
В принципе, может быть, технически,
что первый кусок превратился
в какой-то M штрих,
а подпись, возведенная в степень,
превратилась в какое-то другое число,
и если мы возведем
полученную подпись в нужную степень,
то эти двое сойдутся.
Это настолько редкий случай,
что им можно пренебреть.
Все понятно про E Алиса?
Если есть вопросы,
в каком месте они есть,
говорите их в ж.
Да.
Да.
Нет, смотри, E это открытая ключ.
А D закрытая?
Д закрытая.
Вот.
Вопросики, не вопросики.
E, смотри.
D мы решаем диафантовое уравнение,
то есть наш компьютер.
У меня у Алиса есть компьютер.
Он знает мое N,
разложение его на множители,
он знает мое D,
и он решает вот это вот диафантовое уравнение.
Но если мы сами как люди будем решать
диафантовое уравнение,
то мы накопаем там бесконечно много решений,
и все, кроме одного, будут бредовые.
Почему будут бредовые?
Потому что они будут или отрицательные,
большие, то есть больше, чем Fiat N.
А поскольку нам удобно работать
среди остатков,
то мы просто выберем тот из D,
который является остатком.
Вот, от нуля до Fiat N.
Вопросики?
Алиса, сколько времени?
У тебя вероятность?
Что?
И фурежечка.
Вопрос?
Какой?
Думаешь, я помню эту задачу?
Основание ТНК?
А, ну да.
Мы поражевали,
что в принципе было возможным
какое-то прощение по себе.
То есть, если оно реально
по определению неправильно,
тогда нет, надо его рассматривать.
Давай?
Алиня.
Про вероятность, наверное,
надо сначала напомнить.
Если не определение,
то хотя бы основные формулы.
Давай, чтобы не тереть время.
Что такое вероятность?
От ожидания?
Что такое независимые события?
Все помнят, да?
Это достаточно интуитивно понятные вещи.
Но формулы какие-то основные,
которые стоит пользоваться,
наверное, нужно помнить.
Вот у нас есть формула Байса.
Вероятность события A при условии B.
Вероятность события A.
Вероятность события B при условии A.
Вероятность B.
Мы здесь все приводим без доказательств, конечно.
Что у нас еще там?
Есть формула полной вероятности.
То есть, у нас есть
вероятность на пространство У.
И у нас есть дизъюнтные объединения
на какие-то события.
Здесь важно, что они дизъюнтные.
Сумма вероятностей.
Вероятность.
Понятно, что сумма.
Сейчас.
Ну да.
Вероятность A это
сумма
как равна
вероятности A при условии B.
Вероятность B.
Так.
Чтобы пока далеко не ходить,
вот у нас есть две формулы.
Когда у нас речь заходит об условной вероятности,
то это у нас
в первую очередь про них,
скорее всего.
Давайте для напоминания
простую задачу.
Мне кажется, что это вполне в стиле
того, что у вас было.
Короче, у нас работает
в издании два журналиста X и Y.
И они по очереди пишут статьи.
X и Y.
И иногда допускают фактические ошибки.
Они допускают
что-то подозрительно часто.
То есть в условии, скажем,
что журналист X допускает
фактические ошибки
в 25% статей.
То есть ошибки.
Это одна четвертая
вероятность допустить ошибку.
А Y вообще одна вторая.
Жесть.
Фактические ошибки.
Это супер.
Они, конечно, так и работают
в нашем мире.
И журналист X
пишет в два раза больше статей.
То есть вероятность того,
что статья написана журналистом X
в два раза больше,
чем журналистом Y.
Как бы этого знать, что это
две третьих?
Два раза две третьих.
У нас сейчас кто больше кого?
Два раза больше, чем Y.
Две третьи.
Одна треть.
Первый вопрос такой, что нужно найти
вероятность вообще ошибки.
То есть мы читаем статью.
Какова вероятность, что там есть ошибка?
Что?
Да, правда, правда.
Ну, какой формы, наверное, здесь нужно пользоваться?
Тут у нас выбор небольшой.
Нужно найти вероятность
какого-то события.
Ошибка.
Ну да, полной вероятности.
Вероятность ошибки это,
что у нас вероятность
ошибки,
если она совершена
журналистом X на вероятность того,
что статья написана журналистом Y.
Плюс вероятность ошибки,
если написана журналистом Y
на вероятность того,
что
статья написана журналистом Y.
Ну, мы все эти вероятности сдаем.
Это одна четвертая
на две третьих.
Плюс
одна вторая на одну треть.
Ох, это нужно еще.
Ну, получается...
Нет, что я делаю?
Одна вторая
на одну треть, да?
Ну, это две...
Одна треть. Что?
Спасибо.
С этим я уже не справилась.
Ну, хорошо, мы посчитали вероятность ошибки
одна треть, а теперь вопрос
какого вероятность, что статью
писал...
То есть мы с ситуацией
мы обнаружили ошибку, и мы хотим
понять, с какой вероятностью эту статью написал
журналист X.
То есть
у нас нужно найти такую вероятность,
что у нас статью писал
X при условии, что у нас
есть ошибка.
Здесь вторая формула
нужна.
Что мы ему запишем?
Вероятность того,
что вообще статью писал X,
или вероятность того, что у нас есть ошибка.
Заметим, что если у нас
не было первого пункта до этого действия,
нам бы пришлось додуматься
самим.
И вероятность того,
что
вероятность ошибки,
если статью писал
журналист X. Вот это у нас из условия,
а это мы только что посчитали.
Ну, это, собственно, статья
две третьих
умножить на три,
и на вероятность ошибки
что писал их.
Это
одна вторая.
Ну, что, собственно, кажется, логичным,
что у нас X пишет
в два раза больше статей,
но допускает в два раза меньше ошибок.
На самом деле,
все задачи на условной вероятности,
это нужно что-нибудь,
то есть записать эти формулы и понять,
что у нас какие вероятности даны.
Скорее всего,
что-нибудь через другое можно будет
вот
что у нас есть
еще из формул вероятности,
чуть менее очевидного,
это я пока стирать не буду.
Что? Есть мотожидание.
Но я сейчас до мотожидания
чуть попозже иду, я хочу сейчас...
Хотя, нет, ладно, давайте с мотожиданием.
Ну, что такое мотожидание
все помнят.
Формула, которая связана
еще с мотожиданием, это неравенство
Маркова, то есть если
вероятность того, что у нас
больше или равно какого-то альфа,
это меньше или равно,
что равно E
мотожидание F
делить на альфу.
Помните такое, да?
А физический смысл понятен,
что это...
Понятно, что если у нас
мотожидание
больше, чем альфа,
то у нас это
тривиальное неравенство,
потому что у нас
вероятность всегда меньше
или равна единице, а если альфа
больше, чем мотожидание,
то чем больше альфы,
то чем у нас меньше оценка сверху,
это означает, что у нас величина
вряд ли сильно больше, чем
мотожидание.
Вот такой некоторый
физический смысл происходящего.
Задачка,
которая связана с алгоритмом,
не знаю, у вас была или нет,
но она кажется
очень содержательной,
что пусть у нас есть какой-то алгоритм
и у него есть какая-то асимптотика.
В общем, у нас есть какая-то асимптотика,
пусть от n².
У нас есть алгоритм А
и у него есть асимптотика
от n²,
но не всегда.
Это мотожидание такое.
Но мы хотим,
чтобы он работал
за от n²
всегда,
с какой-то константой может быть,
но в целом нам хочется, чтобы
асимптотика была такая,
но мы готовы пожертвовать
качеством работы алгоритма,
и мы готовы, чтобы
в таком проценте случаев
он выдавал неправильный результат.
Можем ли мы такого добиться?
Вообще доказывать,
что мы такого добиться не можем,
наверное, было очень сложно,
поэтому проще привести такой алгоритм,
потому что в данном случае можно.
Что будет делать такой алгоритм,
который мы хотим?
Вот пусть у нас
время работы t
это случайная величина,
какая-то у нас же есть
мотожидание оно такое,
и это случайная величина f,
и мотожидание это
t,
это какое-то t.
И мы запустим
на каком-то входе конкретно
этого алгоритма,
и этот алгоритм будет
делать следующее.
Он будет запускать алгоритм a
и ждать, пока пройдет время.
Сейчас я могу запутаться в количестве нулей.
10 тысяч, да?
Вот такое время.
Ну, константа не изменится.
То есть, конечно, она большая,
но в целом все точку не изменится.
Мы подождем, пока пройдет столько времени.
Если у нас алгоритм завершился,
то здорово, он выдал какой-то ответ,
он сработал правильно,
он же правильный алгоритм на работе исходный.
А если не завершился,
то мы от балды
что-нибудь выдадем.
Он, скорее всего,
выдаст что-то неправильное.
А теперь нам
что нам теперь нужно сказать?
Вот такой алгоритм h' подходит.
Для этого нам нужно показать вот что.
Смотрите, у нас есть
f. Это t.
А теперь мы хотим оценить вероятность того,
что у нас будет неправильный результат.
Когда у нас будет неправильный результат?
Когда алгоритм будет работать
больше, чем вот столько?
Потому что мы выдадем что-то от балды,
и, скорее всего, он будет не правильным.
И мы хотим оценить вероятность того,
что алгоритм работает более, чем вот такое время.
Вот это у нас будет альфа. Альфа, которая здесь. Больше она, чем мы воспользуемся этой оценкой.
f – это t. Делить на t – это, собственно, процент.
То есть вероятность того, что у нас… А это есть вероятность того, что у нас алгоритм работает неправильно.
И она меньше вот такого маленького процента случаев.
Нет, это именно неправильно. То есть смотри, у нас как раз весь прикол в том, что мы можем…
Если у нас есть алгоритм, в котором иногда мы жертвуем временем работы,
то можем перейти к алгоритму, в котором мы иногда жертвуем качеством работы.
То есть смотри, здесь уже у нас… Что этот делает алгоритм?
Когда мы достигаем такого числа шагов, что в целом тоже от n, то он выдаёт случайное значение.
И на мы находим вероятность того, что он выдаёт случайное значение.
То есть вероятность того, что он выдаст что-то неправильное.
Он закончил свою работу в очень определённый срок.
Просто он выдал что-то другое. Не то, что выдал бы нормальный алгоритм.
Вот такое применение вероятности в алгоритмах.
Но в целом, наверное, будет что-то простое про вероятность и про мотожидание.
Не знаю, у нас очень много времени уже ушло.
Уберите какую-нибудь задачку нам от ожидания? Чего не посчитать?
Что? Я вижу только один… Я увидела только одну реакцию, и это было «нет».
Можно чуть больше ответов.
Фурьешечку? Хорошо.
Ну, фурьешечку, не знаю, что там можно, кроме как посчитать.
Но, наверное, нужно напомнить, как работает алгоритм «Фурье».
Сразу на примере, хорошо.
Вот пример какой-нибудь… Пример многочленов, да, произвели?
X плюс 1.
Так вы хотите пойти спать или нет, я не поняла, как сами себя противоречите.
Вот это у нас A, а вот это B.
Да.
Такая инсайд.
А мотожидание? Мотожидание количества коэффициентов.
Ноль-ноль-ноль.
Бинормально, так ведь не «матан».
Я думала, что все нормально будет, но по идее…
Так, все понимают, что посчитать «Фурье» на возник, а не «ЦН», это точно сложно сделать за час 20,
если возить еще и другие задачи, причем на полусимметра задачи.
Очень долго.
Смотри, как ты его делаешь.
Смотри, у тебя там числа какие-нибудь N-битные, и ты хочешь там их перемножать,
и ты записываешь их, собственно, там многочленов, то есть X, там X равно 10 поставишь потом,
перемножишь их, как многочлены, короче, эти два числа, ну, в общем, и все сделать.
Короче, его не бойтесь.
Постарается, на примере, да, я постараюсь не запутать сама.
Ну, у нас мы запишем векторы этих коэффициентов, получается 1, 1, 0, 1, 0, 1.
Вот, дальше мы подберем омегу, омега, ну, у нас здесь степень не выше второй,
но нам нужно, ну, то есть, у нас длина каждого три, и значит, что у нас N должно быть больше
или равно чем, D равно 3, побольше или равно 7, ну, на N-степень двойки, значит, берем 8.
Вот, мы берем омегу такую, что омега восьмой, короче, восьмую степень из единиц.
Ну, собственно, считаем.
Нам нужно посчитать сначала от A, потом от B, ну, давайте от A посчитаем, что у нас от A и омега.
Мы разделим на A0, это что? Это 1.
Сейчас, 4, да, хорошо, это на самом деле имеет смысл, давайте будет четвертый.
На самом деле это не так уж важно, потому что когда мы заметим, что у нас константа, мы можем сразу выдать,
то есть, мы в какой-то момент заметим, что у нас здесь константа, и у нас мы сразу сможем выдавать ответ.
То есть, мы же не машины, мы можем перестать рекурсивно вызывать.
Но вообще, да, ты прав.
Хорошо, и 1, это тоже 1. Вот, так как мы будем вызывать Fourier сразу от, ну, и от этого, и от этого,
они у нас одинаковые, то можем только один раз посчитать.
Что дальше мы считаем? Мы считаем от A0 и омега в квадрате.
Ну, у нас снова здесь, ну, снова будет здесь 1, а здесь будет 0.
A0 это, пусть будет 0, 0, это 1, а A0, 1, это ну, 0.
Омега в квадрате, ну, и так далее. На самом деле здесь у нас, так как константы, то мы можем дойти до
что-то там, от 1, это будет здесь 1, когда мы будем вызывать, вот от этого у нас будет 1.
Хорошо, давайте, я просто хочу опустить часть шагов, чтобы...
Ну, смотрите, мы же Fourier запускаем рекурсивно, да?
Так, хорошо, давайте уточним, одинаково ли мы быстрое преобразование.
Мне казалось, что одинаковое, но у нас, что мы делаем? Мы берем Fourier-преобразование от...
Мы разделяем на два таких многочлена, правильно?
Ну, у нас при нечетных и нечетных степенях.
Дальше мы вызываем Fourier-преобразование от вот этого многочлена и омега-квадрат, и вот этого многочлена и омега-квадрат.
Проверяем, равно ли то, ну, вот омега, равна ли она единице.
Ну, вот здесь она пока не равна, здесь омега равна корню, ну, это получается минус единица.
На самом деле это и будет.
Вот здесь она равна минус единице, и мы снова разделяем а0 на два многочлена.
И вызываем от каждого из них снова.
Что?
Потому что а0 это 1, и у нас здесь нет х вообще.
Хорошо, мы вызываем теперь от вот этого.
А0, 0 и омега в квадрате, а здесь у нас минус 1, значит 1.
Ну, мы уже достигли вот это наше условие остановки, это единица, мы возвращаем единицу, значит.
Дальше нам нужно посчитать а0, это что?
Это а0, 0, плюс омега, ну, от какого-то омега, то есть нам нужно посчитать от минус 1 и 1.
От омега и плюс омега на а0, 1.
Я вот расписываю, почему это 1, потому что у нас коэффициенты.
Ну, смотри, у нас это коэффициенты при четных степенях, это при нечетных.
Ну, у нас был многочлен, просто у нас здесь степень вообще 1.
И у нас что? У нас вот этот многочлен это а, это а0, плюс х на а1, правда?
Ну, вот подставляем сюда эти два, действительно оно.
Вот здесь, сюда мы, вот мы сейчас вот это, ну, рекурсивно вызвали от вот этого.
Это у нас, ну, типа многочлен константа.
Да, ну, то есть мы взяли многочлен а0 и снова берем от него а0 и а1.
Поэтому такие индексы.
Вот, но это у нас константы, поэтому при нечетных степенях у нас ну, 0.
Вот здесь я расписываю, что мы должны дать на выход, на выходе из этого алгоритма.
Вот, мы вот это считать, смотрите, мы вот это считать не будем.
То есть мы не будем вызывать а0,1, потому что у нас, ну, коэффициент все равно будет 0.
Вот, нам неважно, чему он равен.
Поэтому измеряется и получается а0 от минус 1.
Ну, почему минус 1?
Потому что у нас вот это омега штрих, мы должны получить от омеги штрих и от омеги в квадрате.
Ну, от 1 потом омега штрих, она же омега в квадрате, потому что стыклично.
Вот, это минус 1, а это 1.
Поэтому должны дойти от минус 1 и 1.
Правда?
Что?
Мы должны вернуть, ну, что делает быстрое преобразование в фурье?
Оно находит значение многочлена в n точках, которые являются корнями из единицы.
Корнями из единицы вот такой степени, то есть у нас же вот как-то они распределены равномерно.
И здесь у нас корень дан вот такой.
Вот у нас всего две степени.
Это вот та омега, которую мы подали, и омега в квадрате.
Это будет собственно уже единица.
Ну и все, мы пришли в единицу.
Вот, если изначально мы вызвали алгоритм от четвертой степени единицы, это и.
И поэтому мы должны найти значение исходного многочлена от i, от минус 1, от минус i и от единицы.
Но мы вызываем рекурсивно от, типа, степени поменьше.
Вот, мы нашли от степени поменьше, это минус 1, 1.
Вот, мы, значит, должны найти а0 от минус единицы и а0 от единицы.
Так, ну, мы здесь, мы а0, 0 от единицы вызвали.
Это единица просто потому что, ну, когда у нас омега равна единице, мы сразу говорим ответ.
То есть мы считаем лоб.
Это единица, значит, равно единицы.
Так, это случай разобрали.
Дальше а0, 0 от минус единицы.
Фух, ну, что мы здесь делаем?
Мы здесь вызываем, а, от омега в квадрате.
Почему я никто не поправил?
От омега в квадрате.
А омега в квадрате это у нас всегда единица.
Поэтому один раз посчитали и хватит с нас.
У нас же в чем прикол в том, что мы повышаем каждый раз степень, пока не дойдем до единицы.
Ну, от омега в квадрате это единица, мы уже посчитали это равно единицы.
Хорошо.
Я могу стереть это, чтобы здесь написать шаг.
Смотрите, мы посчитали для а0.
Теперь нам нужно посчитать для а1.
Но смотрите, у нас а1 и а0, они как многочлены равны.
Да, то есть нам не нужно считать второй раз, мы можем воспользоваться теми же самыми результатами.
Ну, а что нам нужно в итоге посчитать?
Вот здесь под чертой будет то, что нам должен дать наш исходный вызов в пулье преобразования.
Он должен дать, вот здесь показаны, я показала уже, корни из единиц в четвертой степени.
Это 1, минус 1 и минус и.
И нам нужно найти а от 1, а от 1, а от минус 1.
А от 1, а от и, и а от минус и.
Что это равно?
Ну вот, у нас записано многочлен, разложенный.
И значит, а0 от 1 в квадрате, это 1, плюс 1 умножить на а1 в квадрате.
А1 от 1 в квадрате это 1.
Но мы уже посчитали, а0 от 1 это 1, и вот это тоже 1, значит 2.
Аналогичными рассуждениями, потому что минус 1 в квадрате это тоже 1, у нас здесь тоже 2.
Не 2, потому что, смотрите, у нас а0 от 1, потому что минус 1 в квадрате, минус 1 умножить на а1 снова от 1.
Это 0.
Что здесь?
Это а0 от минус 1, ну и в квадрате, плюс и на а1 от минус 1.
И то, и другое единица, значит это 1 плюс и.
Здесь 1 минус и аналогично.
Достаточно хорошо видно, да?
1 минус и.
Хорошо, мы посчитали, и вот у нас первый ответ.
То есть первый ответ, это у нас последователь значений, собственно, 2, 0, нет, 2.
У нас по кругу так циклично, значит здесь будет и это 1 плюс и, 0, 1 минус и.
Один многочлен посчитали.
Ну смотри, у нас то версие, которое я знаю, это 1 омега, омега в квадрате и так далее, да, омега в n минус 1.
Такой порядок, а он выглядит типа вот так.
Начинается единица, обход по кругу этих корней.
Фух, мы посчитали многочлен а, теперь осталось то же самое с многочленом b.
Ну вот мы вызываем от b и того же самого омега.
Мы разделяем на b0.
Это что?
Это 1 плюс, плюс х.
Понятно почему, да?
Если мы умножим...
Нет, ну что мы умножить не будем?
Мы когда вызываем от х квадрата, это как раз получается х квадрат плюс 1.
А b1 это 0. Нечетных степеней у нас там нет.
Ну вот у нас хотя бы на одну функцию считать меньше, но что мы теперь делаем?
Мы разделяем от b0 и омега в квадрате.
Омега в квадрате это минус 1.
У нас здесь удобно.
Мы снова разделяем на два многочлена b00 и b01.
У нас такой многочлен здесь.
Это наш предыдущий многочлен.
Смотрите как удобно.
Это 1,1.
Так.
Вот такая штука.
Ну смотри, что мы хотим?
Чтобы у нас наш исходный многочлен b был представимый b0 от х.
Это b0 от х квадрат плюс х на b1 от х квадрат.
То есть у нас и то и другое от х квадрат, но одно сдвигается на х, чтобы были нечетные степени.
А теперь смотрим, если мы сюда подставляем х квадрат вместо х.
Допустим здесь другая переменная t.
Если мы вместо t подставляем х квадрат, то как раз получаем наш исходный многочлен.
Ну а здесь ноль.
Неважно что мы получаем, но все равно на ноль умножается.
Вот.
Соответственно b00 и b01 мы нашли.
У нас здесь минус 1, значит вызываем еще раз.
Но они у нас как в прошлом примере равны.
Поэтому мы можем не вызывать это и другое, но один раз что-нибудь посчитать.
Я даже так и напишу b00 от ω в квадрате это единица.
Это тот же набор, что b01 от единиц.
Просто потому что наши многочлены равны.
Но когда у нас единица, мы говорим в лоб ответ.
Это единица.
Хорошо.
Тогда b0.
Здесь мы у нас единица, значит мы должны искать от единиц и минус единицы.
Потому что два корня вот эти.
b от единицы это равно.
Давайте распишу b00 от единиц.
Плюс b01 от единиц.
И то и другое.
Значит это два.
b0 от минус единицы.
То же самое, потому что минус единиц в квадрате это один.
Только здесь минус один это ноль.
Как в предыдущем случае.
Шаг, в который мы попали в рекурсии мы посчитали.
Теперь возвращаемся к b.
Что нам здесь нужно считать?
b1 мы договорились не считать, потому что зачем?
Мы должны здесь посчитать b от 1, b от и, b от минус 1 и b от минус и.
Так b от единицы это b0 от единицы.
Сейчас.
Мне кажется, что мы что-то не досчитали.
А нет, у нас же вот этот алгоритм выдал b0 от единицы и b0 от минус единицы.
Мы запомним, что я сейчас затру, чтобы удобнее было.
И у нас результат такой.
b0 от единицы это 2, а b0 от минус единицы это ноль.
Это вот результат рекурсивного вызова.
Значит b0 от единицы плюс 1 от b, не важно что там ноль, это 2.
А здесь b0 и в квадрате это минус 1, значит это равно b0 от минус одного, ноль.
Минус 1 в квадрате это 1, значит нам здесь нужно b0 от единицы, это 2.
b0 от минус и в квадрате это b0 от минус одного.
Это снова ноль.
Значит выход у нас быстрого преобразования в фурье от b это 2, 0, 2, 0.
Успеваете? Не потеряли еще связь с моими вычислениями.
Пока что нам глобально что нужно делать?
Нам нужно посчитать значение a в точках вот этих корней единицы, потом значение b в этих точках.
Сейчас мы это перемножим.
А потом быстрое преобразование в фурье, только обратное.
Мы посчитали, получили два ответа.
Теперь нужно найти значение c, значение, собственно, многочлены нашего, который будет на выходе в этих точках.
Собственно, c, вектор будет таким.
2 на 2, 4.
Если есть какое-то число x0, если мы хотим найти c от x0, это просто произведение b от x0 на a от x0.
А вот это у нас точки, это единица, там вот это и, вот это минус единица, и тот вектор аналогичный.
Если у нас есть вот эти векторы, мы их просто отчленно перемножаем.
То есть первый элемент с первым и так далее. Понятно почему, да?
Потому что нам нужно в каждой точке произведение значения в этих точках.
Поэтому мы берем вот здесь первый элемент 2, там первый элемент тоже 2, 4.
Тут первый элемент 0, там и не важно что, там третий элемент 0, здесь 2, 0.
У нас все нули просто, кроме первого элемента. Очень удобно.
Потому что у нас быстрое преобразование в Fourier как работает, что у нас если есть вот вектор коэффициентов,
это что? Это 1 делить на n, быстрое преобразование в Fourier от c и от вот этого.
То есть если мы преобразовывали с помощью какого-то порни из единицы омега, то здесь омега минус 1 сопряженный.
Смотрите, у нас здесь омега был, если у нас давайте, чтобы не считать какое-то конкретное значение,
у нас же четвертой степени, у нас корень четвертой степени это был i.
Если ему сопряженный, это минус i. Что это значит?
Это значит, что мы сейчас вызовем вот такое, только сюда будем вставить не i, а минус i.
Ну а потом просто все значение поделим на 4. В нашем случае запишем 4.
А здесь запишем минус i. А сюда c подставляется как?
У нас же какой-то вектор дается на вход, и если там мы подставляли вектор коэффициентов, то здесь мы подставляем вектор значений.
Ну давайте на этой все равно больше одной доски понадобится, поэтому давайте вот здесь и начнем.
c от минус i. Делаем все тоже самое, как будто у нас там есть многочлен.
Мы записываем c0. Это у нас при нулевой степени.
Значит это 4, а c1 это 0. Очень хорошо.
Мы сразу здесь запишем c от… Мы как будто…
Да-да, то есть на самом деле там… Нужно говорить скорее не в терминах многочлена, а вектора, но просто с многочленами понятнее мы куда-то что-то подставляем.
А здесь приходится с вектором, но как будто у нас есть многочлен. Да, действительно так выглядит.
Здесь мы хотим посчитать от единицы, c от… На самом деле от минус i, потому что я где-то здесь записала, у нас порядок.
То есть здесь важно не запутаться, наверное, это действительно важный момент, чтобы обратить на него внимание.
Здесь мы берем омега, какой-то корень, и вот здесь мы брали первый корень в таком обходе.
Потом его квадрат, это минус 1, потом третью степень, и ну и все, третья степень это была как раз сам минус 1.
А здесь мы берем сопряженное, мы пошли в другую сторону, и поэтому у нас сначала берем минус i.
Мы в таком порядке будем, у нас минус i, потом минус i в квадрате, это минус 1, да, и i.
Вот, но для начала мы вызовем рекурсивно от c0, c0 и омега в квадрате это минус 1.
Хорошо, c0,0 это все еще 4 и c0,1 это 0, потому что у нас константа просто.
И мы хотим посчитать c0,0 в точке минус 1, с точки 1 и минус 1.
0,1, минус 1. Чем это равно?
Ну, мы вызываем от c0,0 и 1, потому что минус 1 в квадрате это 1.
Здесь мы видим 1 и сразу говорим, чему у нас равен этот многочлен в точке 1.
В точке 1 у нас вообще от x не зависит, поэтому здесь равно 4.
Вот это в точке 1 равно 4. Здесь мы что записываем?
c0,0 от 1, плюс, конечно, 1 умножить на c0,1, это 0.
Вот это равно 4.
И это равно тоже 4, потому что здесь мы тоже вызываем c0,0 от 1,
минус 1 в квадрате. Это тоже 4.
Хорошо, теперь мы возвращаемся на шаг назад.
И здесь записываем, что у нас c0 от 1, плюс 1 на c1.
Ну, не важно, c1 равно 0, это будет вот это 0, а вот это 4.
Хорошо, но мы дальше вот это писать не будем.
И минусы в квадрате это минус 1.
Значит, мы смотрим, чему равен c0 от минус 1.
Это тоже 4. У нас просто будет все 4, потому что у нас либо c0 от 1, либо c0 от минус 1 будет.
Красота. Что? В смысле, закрой.
Вообще-то нет. Смотри, у нас же это будут...
Смотри, мы сейчас то, что вернем, вот это сейчас мы возвращаем.
Это на самом деле, мы сейчас вернем вектор 4,4,4,4.
Это значит, что произведение будет...
Сейчас, подожди.
И еще на 1,4. Это 1,1,1,1.
А, да, да, все хорошо. Ну, да.
Ну, сократим потом. Так-то здесь сокращать не надо, потому что это коэффициенты у нас.
Многочлен получится другой.
Ну, да, все хорошо. У нас получился многочлен.
x кубе плюс x в квадрате плюс x плюс 1.
Фух, сошлось реальностью.
Так, что-то смог не потеряться по дороге?
Сейчас.
Я прошу прощения, здесь, на самом деле, банальная путаница в индексах.
На самом деле, сейчас, если я могу где-нибудь записать коротко, что произошло,
без выкладок, потому что здесь я записывала так и считала, что мы...
То есть, наверное, можно повторить в плане, что мы делаем.
Да, понятно, что без подсчета. Подсчет был, чтобы понять, что мы не лажу делаем.
У нас есть два многочлена, и мы вызываем этот алгоритм от A.
Мы выбрали такой аметр, что это I.
Потом, когда мы это считали, мы разложили на A0.
Первый пункт. Мы разложили на A0, и это у нас было 1, и A1 равно 1.
Дальше мы посчитали, мы вызвали этот же алгоритм от A0 и в квадрате, минус 1.
На самом деле, и одновременно с этим мы посчитали...
Вообще-то, по алгоритму должны сначала от этого, а потом от этого.
Но у нас они равны. Мы один раз посчитали.
Что-то там, чтобы это посчитать, мы вызвали рекурсивно.
Мы разложили A0 на A00 и A01.
A00 от минус 1 в квадрате это 1.
Здесь мы сразу вышли, потому что, когда мы видим, что ω равно 1, мы сразу говорим ответ.
От A01 равно 0 мы не вызывали, потому что зачем у нас все равно константный 0?
Нам нужно понять значение функций в каких-то точках, а мы заранее знаем значение этой функции в каких-то точках.
На самом деле, от константы мы тоже можем не вызывать теоретически.
Но у нас тут почти сразу всегда получается констант, поэтому ладно.
Мы получили значение вот это. Что мы получили?
Получили A0 от минус такой вектор.
Я буду записывать вектор, чтобы не путать порядок.
Сейчас мы понятно, что делаем. Мы ищем значения в точках.
А когда мы делаем обратное преобразование в Fourier, то мы делаем тоже как с многочленами, как будто там коэффициенты.
Но на самом деле мы оперируем со значениями, поэтому если мы там попутаем порядок, то у нас потом какой-то другой многочлен получится.
Это не есть хорошо.
Мы получили A0 от единицы и A0 от минус единицы.
Мы это получили, и теперь мы подставили сюда.
И здесь на выходе получили A0 от единицы.
Потом от самого корня, который мы вызывали.
Потом от i в квадрате это минус 1.
И от i в кубе это минус i.
Получили такой вектор. Я не буду записывать то же самое.
Потом мы сделали то же самое для многочлена B.
Здесь то же самое.
Мы посчитали вот такие векторы.
Это был первый шаг, вот это второй шаг.
А на третьем мы просто их перемножили.
Я не знаю, как это перенажают.
С от 1, с от i, с от минус 1, с от минус i.
Вот этот вектор мы перемножили.
Я не хочу все переписывать, но вот такой же для A умножить на для B.
Ну, как лентскалярное произведение.
Это был третий шаг.
Общая идея такова, что мы сначала считаем...
Многочлен можно задавать в двух видах.
Либо мы коэффициенты задаем, либо значения в точках.
То есть если у нас степень D, то нам нужно D плюс одна точка или больше.
Дело в том, что мы переводим в другой вид.
В вид, который по точкам задаем.
А в нем считать многочлен просто.
Мы просто перемножили значения в этих точках.
Потом нам нужно обратно привычный человеку вид.
Поэтому вот мы здесь перемножили, а теперь нам нужно обратное преобразование.
Оно выглядит так, что мы вызываем 1 на n, на c от...
Омега с чертой, сопряженная, короче говоря.
В нашем случае это 1 четвертая на c.
А здесь омега с чертой у нас была минус i.
Для него мы повторяли все то же самое.
Важно, что здесь другой порядок был.
То есть я здесь запишу, что выход был...
В каком порядке должен записываться выход?
Это c от единицы, ну типа нулевая степень.
Вот мы начинаем нулевая степень, потом первая, потом вторая, потом и нулевая.
c от минус i, c от минус единицы и c от i.
Все, мы получили.
Это по своей сути нам же нужно было произведение многочленов.
Это c0, c1, c2 и c3.
Все.
Ой, я что-то зацепила.
Ну, вот такие шаги.
Сейчас, если я в выкладке опустила это сало, более читабельно понятно воспроизведение такое.
Главное не обчитаться, но вот на каких-то примерах степень меньше трех вполне себе.
Норм?
Что, Саня, еще будешь что-нибудь рассказывать?
Я не знаю, мне кажется, уже никто не способен.
23.
Мне в Москву ехать.
Ужас.
Красота.
А теперь непонятно, как ключ сдавать.
В смысле?
Охранник, охранник, все?
