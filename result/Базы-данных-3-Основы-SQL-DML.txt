Ребята, у нас третья лекция в курсе. Сегодня разберем основы Data Manipulation Language, основы
четырех базовых команд SQL для того, чтобы работать с данными в базе. И самую главную,
наверное, команду посылающую запрос, команду Select довольно большой объем получается. Боюсь,
что мы не успеем дойти до темы с подзапросами, но по крайней мере сегодня мы должны DML в общем
виде весь закрыть. Постараемся это сегодня успеть. Хорошо, Data Manipulation Language под множество
языка SQL. Схема общая приведена. Мы левую часть этой схемы, левую часть этого дерева,
два левых узла разобрали на предыдущей лекции в общих чертах. Сегодня разбираем второе слева
часть. Пройдемся по всем перечисленным командам. Таким образом у нас в принципе будет,
по крайней мере с точки зрения лекции, я понимаю, что у некоторых и на семинарах уже это случилось,
будет общее представление о том, как создавать, наполнять базу. Вот на уровне команд SQL по
проектированию у нас планируется следующая лекция, наверное будет. И там мы уже разберем
чуть более подробно, как в общих чертах формировать схему базы данных в таком логическом смысле и как
проектировать по возможности без потерь. Сегодня инсертилика длится соответственно у нас. Команда,
что читать, опять же здесь никаких откровений я для вас не сделаю. Это в общем-то в первую и в
основную очередь это документация. Не забывайте про книжки с предыдущей лекцией. Это книжки,
опять же, они находятся на сайте Postgres Pro, Postgres Professional компании. Довольно доходчивые,
хорошие вещи в плане, во всяком случае, практическом. Очень удобные, чтобы там что-то
быстро подчеркнуть. Опять же отсылаю вас к ним, рекомендую, всячески. Тем более это все бесплатно,
и опять же официально без нарушения всяческих авторских прав. Ну и также гуглим, не стесняемся.
Давайте рассмотрим, соответственно начнем с команды insert. У нас здесь будет в таком порядке
insert, update, delete и в самом конце, в самой большей части мы посвятим селекту. Базовый синтакс
приведен. Опять же, напоминаю, что в тех доках гораздо более полное описание синтаксиса,
он гораздо более богатый, больше гораздо нюансов, но на данном этапе в принципе основное приведено
на слайде. Это insert into, имя таблицы дальше, можно также специфицировать имя столбства,
можно не специфицировать, и опять же дальше дополнительные всяческие варианты. Ну как
дополнительные? Insert into у вас все равно должно быть после имени таблицы какие-то значения,
которые вы вставляете, либо по умолчанию, либо какие-то конкретные. Также можно в конце вывести
результат того, что вы вставили таблицу для того, чтобы с этим работать, если вы insert
используете в своей какой-то функции, например, или в каком-то процессе исполнения команд,
когда смысл дополнительного селекта в дополнительном селекте не будет. Проще вывести
через returning и получить по крайней мере все, что вы вставили по умолчанию, либо там обвесить
какими-то псевдонимами, какую-то спецификацию указать для того, чтобы вывести конкретные столбцы.
Элементы синтаксиса. Имя таблицы – это имя существующей таблицы или, возможно, дополненные
схемы. То есть когда у нас будет вначале иметь схемы, точка, имя таблицы. Что такое схема?
Схема – это, если говорить с такой логической точки зрения, схема, опять же, это схема СУБД,
то есть это не схема данных при проектировании базы данных, это схема СУБД. Это, по сути дела,
пространство имен. Вы можете в своей базе данных создать схему, которая будет у вас позволять две
таблицы именовать одинаково, при условии, что они к разным схемам относятся. Имя столбца – понятно,
что может быть дополненным именем вложенного поля или индексом в массиве. То есть если у вас
есть какие-то более сложные конструкции, чем таблица со столбцами, можно также выражение
использовать как в указании значений, так и в принципе, это уже потом, в именовании столбцов
можно использовать выражение в селекте в частности, мы это посмотрим. Можно использовать запрос
оператор селект, который выдаст строки для добавления в таблицу, выражение результата.
Что после ретернинга появляется? Это то, что будет вычисляться. По сути дела, это та же самая
таблица, но не вся целиком, которая у нас получится в результате, а только те столбцы,
которые у нас вставлены. Мы можем ограничить результат, получающийся после ретернинга,
за счет того, чтобы укажем какое-то конкретное количество столбцов и можем как-то их
переименовать, как там заблагорассудится, соответственно. А что важно, наверное, понимать,
это имена столбцов можно располагать в произвольном порядке, если мы их явно указываем. Если у нас
есть столбцы со значениями по умолчанию, то есть когда мы создали и повесили ограничение
default value, то у нас, соответственно, можно эти столбцы не заполнять, но если мы перечислили
при команде insert имя столбцов, в том числе для которых установлены default значения,
мы все равно должны будем явным образом указать, какие значения мы вставляем в эти столбцы,
даже если не смотря на то, что у нас есть default. Мы, правда, можем маркером default при вставке
указать нашей системе управления базой данных, чтобы алгоритмы взяли значения, процедуры,
по сути дела не алгоритмы, все-таки процедуры взяли значения из логики, которую мы заложили на
этапе create. Сейчас я все это покажу на примерах. Если указать список столбцов, но привести во
вставке не все значения, то вставка будет происходить последовательно во все ячейки строки, в связи с чем
система выдаст ошибку либо из-за несовпадений типа данных, либо из-за недостаточности добавляемых
в строку данных. То есть, если мы не указываем после имени таблицы в скобках имена столбцов,
мы должны все значения явно представить, даже если будут это будут default, и default-ные маркеры
все равно должны явно представить в списке значений, которые вставляем в строку.
По какому принципу? Вопрос в чате. По какому принципу упорядовываются строки в результате
запроса пересечения? Ответ такой. С точки зрения релизационной модели у нас нет никакого условия
на упорядочивание строк. У вас от времени, когда вы сделаете этот запрос, грубо говоря,
может разниться число строк. Другое дело, что при конкретной реализации подлежащие
механизмы они могут соблюдать порядок, но стандарту не накладывает на это никаких ограничений,
поэтому на это не стоит закладываться. Если вы хотите определить порядок, то есть просто способ
в запросе селект сортировки. Способ сортировки мы до этого дойдем попозже. Примеры инсерт
приведены на рисунке, если мы просто создаем create table. Вот мы создали таблицу пустую,
мы поставили запрос селект, у нас выводится заголовок нашего отношения со списком атрибутов,
таблица у нас пустая. Давайте добавим значения. Вот мы добавляем ряд значений, шаги с первого
по пятый в левой части слайда описаны, приведены вернее, и в правой части у нас, соответственно,
полный результат. На что здесь можно обратить внимание? Во-первых, смотрите. Перевернем слайд
обратно. У нас таблица четырьмя полями. На первое поле ограничений сериал и праймеры key,
на второе поле у нас явное ограничение default. По дефолту у нас unknown заносится, по дефолту
в столбе с h будет значение 18, по дефолту в столбе с email будет значение, соответственно,
default email. Почему это важно? Вот давайте смотреть. В первом шаге, в первом этапе мы заносим явно
только в столбе с name только одно значение John. Вот у нас первая строка. Что мы видим? ID у нас,
соответственно, автоинкрементация происходит с единички, начиная. Вот единичка в поле ID,
в столбце ID, в столбце name, соответственно, занесенное имя в столбце h, в столбцах h и email у
нас дефолтное значение. Мы здесь явно указали столбец, повторюсь, явно указали значение для
столбца. Остальное заносится по дефолту. Второй шаг тоже самое. Единственное, мы маркером default,
видите, в конце заносим, говорим нашей базе, чтобы в столбце h у нас было дефолтное значение. И вот оно
тоже появляется 18. В третьем шаге, обратите внимание, мы можем все столбцы дефолтные,
все столбцы заполнить дефолтными значениями. Вот таким коротким запросом, если это позволяет
схема нашего отношения, то как мы его задали, соответственно, у нас в столбце 3 все дефолтные
значения. А что еще? На четвертом шаге мы здесь добавляем не одно значение, как мы делали раньше,
не в одну строку значения, как в первом, во втором или даже в третьем шаге. На четвертом шаге мы
добавляем несколько строк. Три строки с разными комбинациями того, что заносится. На четвертом шаге,
соответственно, обратите внимание, мы в столбец возраст, причем мы его указываем первым после
values. Почему? Потому что мы его указали первым в перечислении столбцов, когда определяли таблицу,
куда мы добавляем строку. Мы определили таблицу, определили конкретные столбцы, которые мы
добавляем значения, определили их порядок, по сути, перечисляя его в скобках. И мы также,
после предложения в values, должны этот порядок соблюсти. Соответственно, хотя у нас в нашем
отношении, в нашей таблице age идет после name, столбец age после name, мы тем не менее в обставке
вставляем сначала в age, потом в числовое значение, потом в name строковое значение. Причем
числовое значение мы еще и вставляем путем почисления выражения. Хорошо, ну и вот результат,
соответственно, на экране вы видите. Далее добавим в нашу таблицу новые значения и сделаем также
операцию returning. Посмотрим, что нам выдаст наша база данных. Соответственно, на первом шаге мы
добавляем очередную дефолтную строку и, собственно, мы ее и выводим.
На втором шаге мы добавляем три дефолтных строки и, как вы видите, соответственно, как было сказано
ранее, три дефолтных строки подряд выводятся. То есть, повторюсь, returning у нас выдают не всю
таблицу, только то, что мы ввели. Ну, соответственно, полностью то, что мы ввели. Если ввели явно только
часть из тех значений, которые мы, только часть значений для строки, то есть только в некоторые
столбцы, у нас все равно по returning будет выдача полной строки со всеми значениями по каждому
атрибуту. Просто какие-то будут, ну, понятно, по дефолту добавлены. Можно использовать команду
select для вставки в insert. Мы здесь, по сути дела, можем скопировать из одной таблицы какие-то данные
в нашу таблицу, из какой-то таблицы внешне. Ну, скажем, таблицу, в которую мы копируем, пусть будет
эта итоговая таблица. Вот в итоговую таблицу мы скопируем из какой-то внешней таблицы по select
значения, но у нас, конечно, условие должно быть такое, что мы должны добавлять только значения,
которые соответствуют атрибутам отношения. Если у нас не будет соответствия, то как результат
система выдаст ошибку, ничего добавить не получится. Можно также копировать целиком таблицы таким образом
из одной в другую, то есть не просто по какому-то условию, как в предыдущем примере, когда у нас было
условие aware после команды select, в команде select. Можем скопировать полностью все, ну, опять же,
при условии соответствия отношений. Вопрос в чате returning возвращает то, что вы только что вставили.
Да. Во-первых, returning – это не отдельная команда, это то предложение, которое записывается в
рамках команды insert, и если у вас после insert будет какое-то количество операций над базой данных,
то, во-первых, в returning просто не запустите в отрыве от insert, и, во-вторых, когда запустите
returning внутри нового insert, у вас только новые значения вставятся. Хорошо. Update – довольно тоже
понятная, наверное, простая команда. Ну, как бы да, update, то есть мы обновляем какое-то поле или поля
в базе данных по некой логике, которую мы соответственно сами прописываем. Базовый синтакс
исправеден, опять же, в документации он полнее, хотя не намного, здесь уже простота команды
ограничивает возможности для вариантов ее использования. На что обратить внимание, что может быть вложенный
селект под запрос селектов, выдающий столько выходных столбцов, сколько перечислено в предшествующем
его списке столбцов. Это определение, по сути дела. То есть у нас здесь вот update имя таблицы, звездочка,
то есть мы можем все поля. Окей, звездочка опустим пока. Сет имя столбца у нас может быть вложенный
селект запрос. И что это такое? Это под запрос селектов, выдающий столько выходных столбцов,
сколько перечислено в предшествующем ему списке столбцов в скобках. То есть селект, потом список
столбцов, столько он и выдаст. При выполнении этого под запроса должно быть получена максимум одна
строка. Если он выдаёт одну строку значения столбцов, в нем присваивается целевым столбцам,
если же он не возвращается в руку, то целевым столбцам присваивается нал. Этот подзапрос
может обращаться к предыдущим значениям текущей изменяемой строки в таблице. Ребята,
вот это определение вложенного селекта, селект запроса, то есть оно релевантно не только для
update команд, оно относится ко всем в принципе командам, которые могут использовать под запрос,
то есть вложенные селект запросы. Поэтому имейте в виду, что это, повторюсь, общее место,
не только когда это относится. Элемент from табличное выражение позволяющий обращаться в
условия where, то есть это определение того, что у нас на предыдущем слайде показано. Я думаю,
довольно здесь всё понятно, в крайнем случае можете обратиться к документации. Давайте
посмотрим просто на примере, как это выглядит, чтобы было нагляднее. Вот у нас две таблицы,
два отношения наших, вернее одно отношение, прошу прощения, и как оно изменится. Вот мы в нашу
таблицу, которую мы сформировали на предыдущих наших шагах, когда выполнили команду insert,
мы в неё вносим изменения, обновляем атрибут edge для записи, для кортежа, в котором
атрибут id равен единичке. Вот соответственно у нас это, по сути, первая строка получается,
поскольку id у нас заполняется за счет типа данных сериал. И вот дефолтный возраст 18
поменялся, возраст по умолчанию, на возраст 25, как у нас, собственно говоря, и в запросе это
фигурирует. Что мы еще можем делать интересного? Мы можем, поскольку здесь принцип именования
строк, именование, прошу прощения, атрибутов такой же, как и было в команде insert, мы можем
произвольным образом указать необходимые нам поля и дальше внести корректные значения,
соответствующего типа значения, в эти самые поля, как приведено на рисунке. Опять же, мы можем
менять ни одну ячейку в таблице, ни значение одного атрибута, можем поменять часть нашего
кортежа, часть нашей строки, так как посчитаем нужным. В данном случае изменен порядок следования
столбцов, но за счет того, что корректные типа данных вносятся в соответствующие столбцы,
мы получаем результат, как показано на экране. Опять же, ORID 8 и логическое ограничение у нас
стоит. Ребят, выключите, пожалуйста, микрофон. Мы его соблюли, несли в восьмую строку изменение.
Дальше у нас пример сложного селект-запроса или еще же так называемого подзапроса. В данном
случае мы довольно сложно сформулировали этот подзапрос, но давайте разберемся. На самом деле,
он довольно простой. Здесь опять же, мы немножко забегаем вперед, селект у нас будет буквально
через одну команду, но запрос простой, я думаю, не вызовет никаких проблем. Мы здесь в селекте из
нашей example table берем по условию, чтобы ID был равен 4, берем значение возраста, имени и
email. И для возраста мы еще и добавляем тройку. То есть у нас результат подзапроса будет строка 4,
это Alice 25 лет и почта. Но поскольку возраст плюс 3 года, то будет Alice 28 лет и почта для Alice.
Соответственно, мы дальше вносим изменения уже по условию внешнему для того, чтобы найти строку,
куда мы вносим изменения. Вносим изменения в виде полученных из подзапроса данных,
изменяем те поля, те столбцы, которые у нас после команды set, после предложения set указаны. И вот они
соответственно изменились. Это все на слайдах будет возможно скопировать, вставить, сможете
прогнать все это у себя. Но я думаю, правда, уже часть из вас пробовала, трогала руками. Но тем
не менее, может быть, для кого-то кому-то еще захочется поиграться, поэтому, пожалуйста,
копируйте, вставляйте, пробуйте работать с текстом данной лекции. Так, update примеры еще. Какие
примеры? Это с from where. Мы в данном случае изменяем имя контакта в таблице счетов. Что здесь важно?
Важно то, что в отличие от предыдущих примеров, мы берем данные из другой таблицы, и соответственно
у нас в таблице accounts будут внесены данные из таблицы employees по соответствию указанному после
предложения where, и будут внесены данные, соответствующие условию после команды set,
после предложения set. То есть сначала у нас будет from employees, где employees.id соответствует
accounts salesperson. Мы находим все соответствия вот в этом фрагменте, и по этим соответствиям в
таблице accounts меняем поля contact firstname на firstname. Соответственно, contact firstname
подразумевается, что это таблица accounts, firstname подразумевается, что это таблица employees.
Опять же, можно было бы вот такую нотацию использовать с точкой таблицы, точкой и имя атрибута.
Ok. Delete. Базовый синтаксис. Тоже здесь простая команда, простой базовый синтаксис приведен на
экране. Можем указать либо что-то конкретное, удалить конкретный фрагмент, можем удалить какое-то
количество строк. Можем удалить всю таблицу целиком, но это будет построчное удаление.
Удаление не быстрое и не эффективное, в общем случае. Примеры. Опять же, вот можно
использовать returning. Работает он также как с insert, и выдаёт returning у нас соответственно
то, что было удалено. Вот справа на слайде показано, как изменяется таблица. То есть
исходное отношение сверху, результирующее снизу. В результирующем у нас отсутствует 11 строка,
то есть строка, в которой id был равен 11, и мы её получили по результатам удаления.
Чем отличается delete, truncate и drop? Как вы помните из прошлой лекции,
должны по крайней мере помнить, и уж точно должны знать из семинарских занятий, кто до этого успел
дойти. Все две последние команды у нас занимаются также удалением данных, как и вновь изученная
знамя команды delete. Ну и занимаются они удалением данных по-разному. Delete осуществляет
посрочное удаление строк, truncate удаляет все строки в таблице разом, а drop удаляет всю таблицу
целиком. Соответственно, если вы хотите оставить отношение на удалить все строки, используйте
truncate, это гораздо быстрее, гораздо гораздо быстрее. Хотите удалить всю таблицу, используйте drop,
здесь все очевидно, наверное, понятно из слайда напрямую из прошлой лекции. А что еще? По delete
можно устанавливать определенные условия, а не удалять все целиком. Truncate и drop этого не
позволяют. Delete можно откатить, но как откатить? Это не значит, что откатить после завершения
транзакции. В процессе транзакции можно сделать там либо точки остановы, либо в случае неудачи
можно взять и откатить truncate, если у вас неудача произошла на этапе выполнения другой команды,
то есть у вас какая-то функция, например, идет, выполняется, и у вас возникла проблема,
все упало почему-то, но truncate уже был реализован, так вот здесь уже, или drop опять же, также это
работает. Здесь, к сожалению, ничего откатить уже не получится, delete получится до команды commit,
если она явно прописана, либо до завершения выполнения команды или функции, потому что по
умолчанию у нас завершение выполнения команды или функции результируется commit системным,
внутри системным, можно delete откатить. Также, что еще важно отметить, у нас delete физически не
удаляет все еще данные, хотя и откатить rollback их уже может быть проблематично, ну там есть еще
как бы варианты, да, помимо собственно команды rollback, который мы поговорим с вами позже, а truncate
и drop, наоборот, удаляют полностью, безвозвратно, и для того, чтобы после delete действительно
освободить дисковое пространство, нужно будет выполнять команду vacuum, если не удалить стройки
физически, ну они соответственно так вот копиться и будут, пока у вас какие-то системные утилиты,
может быть, не запустят vacuum, или пока не будет сообщения о переполнении физической памяти на
устройстве. Так, хорошо. Команда select, основной предмет нашего сегодняшнего разговора, пожалуй,
основная, наверное, рабочая команда, с которой работают все, потому что позволяет, понятно,
позволяет достать из базы какие-то данные с помощью select, то есть, возможно, это, конечно,
будет там неявный select, не прямой, там будет select внутри какой-то, может быть, процедуры,
но, тем не менее, select у вас будет запускаться практически, наверное, в любом случае, в любом,
кажется, да, вот так, на первый взгляд, чтобы получить какие-то, ну да, можно здесь поговорить
о том, что returning у нас еще возвращает данные, но это такие данные, наверное,
не представляющие особого значения, потому что мы либо знаем, что мы вставляем, либо знаем,
что мы удаляем или обновляем, ну, скорее всего, знаем. Так, а базовый, базовый синтаксис приведен
на экране, так, а на секундочку, да, базовый синтаксис приведен на экране, вот самый верхний
уровень, невый способ описания, это первый bullet, то есть, у нас есть select, потом идет список
выборки некой, некий, после этого предложение from, потом табличные выражения и потом, может быть,
определение сортировки, но, как вы видите, в квадратных скобках у нас только определение
сортировки, from и табличные выражения не занесены в квадратные скобки, но на самом деле, на самом
деле, select можно использовать для вычисления, для выдачи, вернее, выражений, которые у нас будут
исполняться, будут стоять на месте списка выборки, будут исполняться на месте, что называется, и select
просто выдается в виде скалярного результата, скаляра одной ячейки, то есть, одной строки с
одним столбцом, некой таблице результирующей. Ну окей, синтаксис чуть более подробный приведен во втором
bullet, опять же, это далеко не полный синтаксис, по команде select документация, большая объемная
статья, сама команда имеет огромное количество дополнительных предложений, всевозможных
усложняющих возможностей запроса, семантические, расширяющие возможности запроса. Ну пока давайте
посмотрим на базовые элементы, то есть, вот что такое список выборки, это первая фигурная скобка,
по сути дела это у нас некое, это у нас перечисление наших, перечисление интересующих нас столбцов,
в общем случае. Это может быть в принципе, конечно, некое выражение, причем выражение, которое имеет,
выдаёт результат на месте, то есть, это может быть сложение или какая-нибудь логическая проверка,
и мы можем использовать select так, опять же, повторюсь, без части, которая идет, начиная с from и далее,
но в общем случае это будут столбцы, перечисление каких-то столбцов, потом у нас будет from с from
элементом, который тоже, кстати, в поле в табличное выражение, здесь немножко не точно, я обозначил
фигурную скобку, в табличное выражение, соответственно, у нас войдет элемент from,
where условия, group by элемент группировки и having условия тоже. Дальше у нас могут быть варианты
с объединением, пересечением или исключением, с некой другой выборкой, то есть, по сути дела,
мы можем на самом деле, таким образом, вот за счет этих трех команд union, intersect и accept,
ну, в общем-то понятно, наверное, теоретика множественные операции, мы можем результаты
двух селект-запросов пересечь, объединить или вычесть один из другого. Также мы можем,
соответственно, определить порядок следования через команду order by и дополнительное выражение и,
наконец, мы можем задать либо предельное количество срок, которое мы получим в результате
запроса, либо мы можем также задать или и то и другое вместе, либо это значение или, но в таком
логическом или и то и другое вместе мы можем задавать, конечно же. Также, наконец, мы можем
через команду offset задать смещение для начала выдачи наших результатов. Окей, поехали посмотрим
поподробнее на каждую, на каждый из перечисленных элементов. Селект элемента синтакса со список
выборки. Что здесь важно иметь в виду? Селект возвращает набор, состоящий, по крайней мере,
из одного значения, и для простоты на данном этапе можно считать, что селект всегда возвращает
таблицу, которая есть, по крайней мере, одна строка с, по крайней мере, одной ячейкой. В
последнем случае также говорят, что селект возвращает скалярное значение. Скалярное значение
это можно сразу запомнить, это понадобится нам для подзапросов, потому что там в зависимости от
того, какой тип возвращаемого результата подзапрос нам выдает, будет изменяться порядок обработки
подзапроса. Причем изменяться может быть даже не очень очевидно с точки зрения синтаксиса,
а вот семантически различия будут существенные. Список выборки задает столбцы, которые появляются
в результирующем отношении. Допустимо также задать операцию над каждым значением столбца.
Синтаксис ссылок на столбцы вариативен. Соответственно, задать операцию над каждым
значением столбца мы это уже, в общем-то, с вами увидели еще на этапе команда Update,
когда на нее смотрели. Поэтому мы можем в селекте, соответственно, какие-то, например,
аэропедические операции совершать со столбцом, и у нас будет везде все прибавляться в рамках этого
столбца, к значениям в каждой ячейке. Селект элемента синтаксиса, опять же, список выборки
продолжения. Можно также задавать в списке выборки псевдонимы для столбцов результирующей
таблицы. Обычно это делается, это можно сделать явно через команду S, предложение S, соответственно,
как на экране показано. Можно сделать это не явно, просто указав после имени столбца некое
сокращение через пробел, но это не всегда может быть удобно, по понятным причинам. Лучше явное,
лучше неявного, хотя с другой стороны неявное короче. Поэтому здесь соотносить надо, наверное,
с этим. Что быстрее, что проще, опять же, для каких-то критических запросов, очевидно,
там важнее явно все прописать, чтобы понимать, где там потенциально может быть ошибка на уровне
таком, что здесь семантическом, наверное, даже. Ну ладно, не важно. В общем, лучше явно прописать,
где что подразумевается под тем или иным сокращением. Также у нас S позволяет, предложение S позволяет
использовать в качестве псевдонима ключевые слова, так же, как и, например, заключение псевдонима
в кавычке, но здесь для чего это когда нужно. Вот, например, у нас в селекте здесь, в приведенном
примере, использовано в качестве псевдонима сам. Сам это также у нас, как вы, возможно, уже знаете,
имя агрегатной или агрегирующей функции. Соответственно, чтобы лишний раз у нас система
не выдавала нам синтаксическую ошибку, либо кавычки, либо явное обозначение псевдонима.
Аналогичное правило действует также для таблиц, перечисляемых после предложения from. Это немножко
тоже забегая вперед. Вот в этом элементе элементы from. Но есть некоторые особенности. Псевдоним
становится новым именем таблиц в рамках текущего запроса, то есть после назначения псевдонима после
предложения from использовать исходное имя таблица в другом месте нельзя. Бывает явно необходимо
использовать псевдонимы после предложения from, когда мы соединяем таблицу саму с собой.
Бывает это нужно, например, для запросов, которые у нас по данным складированным в виде таблиц в
нашей базе данных проходятся как по графам. Ну и сами эти данные представляют на самом деле некие
структурированные определенным образом данные, представимые в виде графа в иной какой-то
системе представления. Но позгресс, вернее, революционная база данных у нас позволяет только
в табличке хранить, как мы знаем. Так, элементы синтаксиза опять же мы продолжаем. Да, здесь так
сухая теория, но, наверное, какие-то ключевые моменты приведены на слайдах, и я поэтому их все
равно считаю необходимо зачитать для того, чтобы вы понимали вообще на что ориентироваться,
и в том числе ориентироваться в квизе. Так что потерпите, будут еще картинки и вопросы в аудиторию.
А хорошо, результат вычисления табличного выражения это другая таблица, которая также может
состоять всего из одной ячейки скаляра. То есть не только под запрос может быть скалярным,
у нас весь запрос, наш селект может быть результатом, результат выдавать скалярный. Ну ладно,
это такое может быть излишне терминологическое уточнение. Табличное выражение можно опустить
и использовать селект для возврата результата вычисления выражения. То есть мы можем, как я
уже говорил, вот селект использовать для выдачи каких-то, ну, как написано в документации,
если вы откроете на Postgres Professional, селект можно использовать как калькулятор. Это, наверное,
такое немножко вольное описание. По сути дела селект у нас сам по себе возвращает таблицу,
а вычисления происходят в рамках, конечно, селект запроса. Но не сам селект запрос у нас работает
как калькулятор. Конечно, во всяком случае по стандарту это немножко не про селект.
Ну вот, можно выдать числовое значение какое-то, вот триумф нужно четыре,
можно выдать значение логической проверки. То есть, в принципе, операции над поддерживаемыми
типами можно совершать, и вот у вас будет скалярное выражение в качестве результата.
Что еще? Предложение From у нас образует таблицу из одной или нескольких ссылок на таблице,
разделенных запятыми. То есть, во From мы можем просто перечислить таблицы, и тогда у нас,
ну, по сути, будет декартовое произведение этих таблиц. И, наверное, так делать не стоит,
в общем случае. А табличные ссылки, вот table and в примере, может быть, имя таблицы,
возможно, с именем схемы производная таблица, как, например, полученная в результате под запрос,
соединение таблиц или сложная комбинация этих вариантов. То есть, может быть, после From в
скобочках селект стоять и дальше будет какой-то вложенный запрос. Может быть, после From table
1 join table 2, и там уже в зависимости от вариантов соединения используется либо условия,
либо отсутствие условия. Об этом чуть-чуть попозже. А если в предложении From перечисляются она,
ну или третий под bullet, сложная комбинация этих вариантов, то есть мы можем там после From писать
table 1 join, потом какой-то селект под запрос, потом он заканчивается, закрывается круглая скобка,
и у нас будет еще и условие какое-то логическое на это соединение сложное. А если в предложении
From перечисляются несколько ссылок, для них применяется перекрестное соединение в виде
результаты декартового произведения отношений. Ну вот то, о чем я, собственно, сказал, просто
перечисление таблиц, это по оболчанию декартового произведения, то есть сцепка каждой строки одной
таблицы с каждой строкой другой таблицы. Давайте рассмотрим соединение поподробнее. Что это такое?
Ну, что это такое, это, наверное, понятно. В принципе, такой тоже аналог теоретика множественных
операций в религационной алгебре. Дальше у нас там будут геограммы с кругами Эйлера такая,
ну, общая тоже, опять же, визуально отсылающая нас к курсам мат-логики и теории множеств.
Так что здесь, наверное, все достаточно на каком-то таком интуитивном уровне понятно,
но надо рассмотреть специфику применительно корреляционной нашей алгебре. И базовый синтакс
соединения таблиц выглядит следующим образом. Таблица 1 – тип соединения, таблица 2 – условия
соединения. При этом у нас соединение любых типов, то есть inner join, left outer join и так далее,
могут вкладываться друг в друга или объединяться. То есть t1 и t2 в примере могут быть результатами,
сами по себе могут быть результатами соединения. У нас ограничений на количество вот этих вот
соединений нет, они могут быть у нас каскадными, но нет как бы с точки зрения абстрактного какого-то
принципа ограничивающего нас. Конечно, реализация имеет свои ограничения всегда.
Тип соединений в Postgres приведен на слайде, опять же, внизу. Это, во-первых, cross-join – перекрестное
соединение, то есть просто-напросто декартовое произведение отношений и соединение с сопоставлением
строк. Их в Postgres 4 вида – inner join, left outer join, right outer join и full outer join. При этом у нас
outer можно опустить, и по умолчанию Postgres нас вполне себе поймёт. И inner, да, конечно же.
По умолчанию подразумевается вот внутреннее соединение при указании left, right и full. То есть
когда он просто join пишет, подразумевается inner при указании left, right, full – внешнее соединение.
Условия соединения в предложении указываются в предложении on или using, либо неявно задаётся
ключевым словом natural. Это условие определяет, какие строки двух исходных таблиц считаются
соответствующими друг другу. Что имеется в виду? Смотрите, у нас может быть предложение on и
какое-то логическое условие. Мы таблицу 1 соединяем с таблицей 2, он, и дальше там ID,
таблица 1 ID равно таблице 2 ID. Мы можем использовать using, если у нас есть набор атрибутов одноимённых.
И в таком случае, используя using, мы подразумеваем, что у нас, и перечисляя столбцы, по которым мы будем
производить соединение, мы подразумеваем, что у нас соединение будет по условию эквивалентности,
то есть равенства. По сути дела, это значит, что в этом примере using у нас будет равен on T1 ID,
T2 ID, то, о чём я сказал очень ранее. А natural – это наиболее общий вариант из всех трёх,
потому что он позволяет скрыть лишнее, возможно, но он, соответственно, менее явный.
Natural подразумевает, что у нас по всем совпадающим атрибутам отношений происходит соединение по
эквивалентности значения атрибутов. То есть, подразумевается, что мы используем по всем
одноимённым столбцам условия эквивалентности, условия равенства значений. Элементы синтаксиса,
соединение таблицы join. Вот 4 вида соединения приведены в символической записи, в такой более
нагладной. Почему здесь нет внешнего соединения, перекрёстного соединения? Потому что, на самом деле,
у нас получается при перекрёстном соединении не full join, не полное соединение, а нечто другое.
Нечто другое, и на это мы сейчас чуть подробнее посмотрим. Хотя, в принципе, я уже говорил,
до декартового произведения, и мы это обсуждали с вами на первой лекции, это сцепка каждой строки
одной таблицы с каждой строкой другой таблицы. При внешнем соединении полном у нас происходит не
сцепка каждой строки с каждой строкой, а сцепка всех строк, независимо от того, есть ли соответствующий
значение в одной таблице для другой таблицы или нет. И вот отсутствие соответствия у нас будет
заполняться нашим маркером null, и соответственно, в таблице это будет null-ами обозначено.
Так, хорошо, cross-join давайте рассмотрим на примере. Вот у нас две небольших таблички,
соответственно, у нас в одной три кортежа, в другой две. Два кортежа, мы их полностью соединяем
путем декартового произведения, получаем результирующую таблицу из шести строчек,
то есть каждая строка первой таблицы с каждой строкой второй. Ну здесь, в общем, все наглядно,
понятно, очевидно. Вот опять же, эквивалентность cross-join запроса у нас следующая. Мы
можем для cross-join запроса, вместо cross-join запроса записать from employees inner-join departments
on true. То есть мы соединяем путем внутреннего соединения две таблицы, но у нас нет никакого
осмысленного какого-то условия. Мы, по сути дела, здесь пишем тавтологию, условия тавтологии,
и у нас происходит то же самое декартовое произведение, перекрестное соединение путем
декартового произведения. Так, это у нас в копилку того, что у нас SQL-язык, он семантически
избыточен. Это в какой-то степени может быть хорошо, потому что довольно гибкие требования
к пользователям баз данных предъявляются в какой-то степени плохо, потому что не
всегда понятно, как лучше и оптимальнее построить запрос, не зная какие-то поднагодные структуры,
подлежащие структуры. Хорошо, а внутреннее соединение inner-join, что у нас происходит? Во-первых,
вот после перекрестного соединения у нас вот эти все inner-join и три типа outer-join, outer-join
соединений, они подразумевают условия какие-то, явно заданные. Это вот первое явное отличие от
cross-join. И здесь вот первый пример inner-join, мы видим это условие опять же, оно здесь уже такое более
или менее понятное. Здесь мы пытаемся по ID полю соединить две таблицы, мы пытаемся получить
всех работников, которые у нас работают в каких-то конкретных департаментах. Вот по сути дела мы
здесь это и получили, соединили две таблицы, у нас все работники работают во всех возможных
департаментах, поэтому у нас здесь нет каких-то вот уменьшений, что ли, поли, у нас получается
сцепка по первой таблице. По первой таблице, по всем ее строкам, со всеми возможными значениями
второй таблицы, повторюсь потому что у нас здесь нет разночтений, нет отсутствующих, нет значений в
таблице департаментов, нет значений в таблице департаментов, которые бы отсутствовали в таблице
работников, и наоборот, наоборот вернее неверно в наш стаблиц департаментов вообще нет ссылок
работников, да, прошу прощения. Так, хорошо. Смотрите, а теперь что у нас произойдет, если мы
захотим получить всех работников, которые у нас работают в первом департаменте? Можно ли
сделать вот такой запрос? Можно ли сделать вот такой запрос или нет? Что он нам выдаст? Казалось
бы, вроде бы мы пытаемся по department ID равным единице получить результат, где бы у нас только
Джон Доу и Элис Джонсон фигурировали бы в результирующей таблице. Но на самом деле здесь
есть определенная проблема, потому что действительно у нас Джон Доу и Элис Джонсон фигурируют в
результирующей таблице, но они фигурируют в задвоенном варианте. Почему так произошло? Потому
что мы на самом деле никакого ограничения на цепку со второй таблицей не задали. Мы задали
ограничения для первой таблицы, мы выдали только значения, выбрали из нее только значения,
которые соответствуют департаменту 1, это инжиниринг, и соединили дальше все эти значения
со всеми сроками таблицы 2. Как нам нужно было записать запрос? А вот так. Нужно было сохранить
изначальные условия по соответствию ID департамента и добавить еще условия, что нам нужно в результирующей
таблице получить только те записи, где у нас работники работают в департаменте 1.
Что дальше? Дальше у нас left join. Left join – это внешнее соединение слева. Что это значит?
Значит, что мы берем две таблицы. В данном случае это наши изначальные таблицы, но немножко
расширенные. Мы добавили две строки в таблицу работников и одну строку в таблицу департаментов.
Теперь у нас есть несоответствие. У нас есть работник номер 5, Дэвид Вилсон, который у нас не
работает ни в одном из перечисленных департаментов, а с другой стороны департамент есть маркетинга,
который не содержит в себе сотрудников, в котором нет сотрудников перечисленных в таблице employees.
Таким образом, что происходит здесь? Мы берем путем внешнего соединения слева,
соединяем две таблицы работников и департамента по ID департамента. У нас получается,
что для Дэвида Вилсона не будет корреспонтирующего значения, как Postgres с этим справится,
ну или вернее стандарт SQL с этим справится. На самом деле, выделенные две ячейки – это не пустые
ячейки, это ячейки, в которых будет значение NALT. Что произошло? У нас, поскольку для нашей
левой таблицы не хватило для соединения подходящих значений, мы все равно взяли всю полностью левую
таблицу целиком, и для недостающего значения справа и справой таблицы мы приписали в строку
левой таблицы два значения NALT. Таким образом, у нас отработал LEFT JOIN и RIGHT JOIN будет работать
аналогичным образом, но уже для правой таблицы. Соответственно, у нас здесь для департамента
маркетинга будет значение NALT. Как это будет выглядеть? Все сотрудники, которые у нас работают
в перечисленных департаментах, появятся в результирующей таблице. У нас для маркетинга
не будет никакого значения по сотрудникам, там будут выделенных ячейок значения NALT,
а один сотрудник Дэвид Вилсон не будет выбран из исходной таблицы. Возвращаясь к этой общей
схеме, теоретико-множественной, у нас таблица здесь работников. Прошу прощения, здесь, конечно,
должна быть перевернутая схема. При выкладывании я это поправлю, но здесь, соответственно,
должен быть вот этот кружочек закрашен, этот кружочек должен быть не закрашен в части за
пределами пересечения. Соответственно, вот здесь у нас, ну, например, LFJoin таблица с
сотрудниками, здесь таблица с департаментами, и вот мы захватили всех сотрудников, и в том числе
часть департаментов, которые у нас с сотрудниками соотносятся. Часть сотрудников, которые с
департаментами не соотносятся, получила значение NALT. Понятно, на схеме это выглядит немножко не так,
если воспроизводить схему по примеру того, что приведено ниже, наложение кругов должно
быть сильно больше. И наоборот, область не захлёстнутая, не за пределами перекреста,
перекрещивание должно быть меньше. Это уже так, в частности, детали. Пример приведен без
соблюдения реальных масштабов, скажем так. Давайте посмотрим на последний вариант соединения,
это full outer join, полное внешнее соединение, и что у нас получится. По сути дела, это будет комбинация
двух предыдущих вариантов. Когда мы взяли все значения из всех таблиц, мы их, в отличие от
декартового произведения, не соединяли посрочно, не конкатенировали строка за строкой,
соединяли только по вот этому логическому условию, а то, что в это условие не попало,
мы взяли и слева, и справа, и дополнили соответствующие строки значениями Null. Повторюсь,
это значения Null, вот эти вот выделенные, залитые строки, они не пустые, в них значение Null.
Хорошо, давайте пойдём дальше. Что у нас теперь? Это выражение where, это выражение, которое
позволяет нам задать условия ограничения в выборке, и здесь все условия ограничения – это любое
выражение значения, выдающее результат типа boolean, то есть любое выражение, которое даёт нам
true или false, допустимо в значение where. Опять же, вспоминаем троичную тернарную логику, что там у нас,
в SQL у нас три значения, напоминаю, что для where должно быть строго истинное значение,
у нас значение not false, то есть true и unknown не подходят, если у нас будет unknown, строка не
будет выбрана. А для unknown, соответственно, нужно использовать специальные предикаты,
мы в общих чертах о них говорили в прошлый раз. А стоящие элементы синтаксиса, табличное выражение
group by и having, то есть, напоминаю, табличное выражение – это всё то, что идёт после for,
мы разобрали с вами после for, как мы можем задавать исходные отношения, из которых мы возьмём
данные, мы можем их задавать перечислением, и будет у нас до картого произведения, можем
использовать соединение в явной форме. Потом мы увидели, что у нас есть дополнительные логические
условия после предложения where только что, а ещё у нас есть дополнительные команды, дополнительные
операторы – это group by и having. Что это такое? Это любопытная штука, на самом деле, на базовом
уровне это простая вещь, она сложно становится в комплексных запросах, но базово получается,
что за счёт group by мы можем по какому-то столбцу сгруппировать значения так, что у нас по какому-то
столбцу одинаковые строки схлопнутся, они будут как бы одной строкой. А дальше там на слайдах мы
это ещё посмотрим чуть подробнее, но смысл вот такой – group by схлопывает у нас одинаковые
значения. Having позволяет эти одинаковые значения отсортировать уже после предшествующей
сортировки where. Ну не сортировки, а выборки. Позволяет выбрать дополнительно where, позволяет
выбрать после исполнения команды from и следующих за ним выражений, а having позволяет выбрать
после исполнения команды group by. Дополнительная информация на слайде. Что ещё можно сказать в слух?
Это упоминание агрегатных функций, что если они используются, то учисляются по всем строкам,
составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы уже, а по
умолчанию агрегатные функции будут выдавать значение для всей таблицы целиком, если мы
используем здесь группировки. Что ещё? Это вот предложение group by собирает в одну строку
все выбранные строки, выдающие одинаковые значения для выражения группировки. В качестве выражения
внутри элемента группировки может выступать имя входного столбца, либо имя или порядковый номер
выходного столбца. Это уже более сложные нюансы для подзапросов каких-то, либо произвольное
значение, вычисляемое по значениям входных столбцов. Хорошо. Если у нас в запросе присутствует
предложение group by или какая-либо агрегатная функция, выражения в списке select по общему
правилу не могут обращаться к негруппируемым столбцам, так как иначе в негруппируемом столбце
нужно было бы вернуть более одного возможного значения. Ну то есть понятно, если у нас group
by есть и мы в group by указываем какой-то столбец, то мы уже в select не можем выбрать другой столбец,
потому что у нас для другого столбца значение будет неопределено. У нас уже схлопнута по
отдельным атрибутам наша строки нашей таблицы, а по другим атрибутам те же строки они не
схлопнуты. И как работать в select в такой ситуации стандарт не определяет. Поэтому
мы должны явно обозначить, что мы хотим выбрать после использования group by. У нас в select список
выборки должен совпадать в этом отношении с элементом группирования. Также можно отфильтровать,
да, мы это уже проговорили с вами. Давайте посмотрим на примере, чтобы было попонятнее. Вот мы здесь
группируем по департаменту. У нас новая таблица new employees. Мы группируем по департаменту и по
жалованию по заработной плате. Что у нас получится? Вот что у нас получается. Вот по департаменту мы
сгруппировали. Смотрите, здесь получились кадры маркетинг финанса IT и вот они выделены. Каждый
департамент выделен своей заливкой в исходной таблице. И по жалованию по зарплате мы тоже
сгруппировали. И у нас получилось 50, 60, 70. И тоже здесь группы с повторяющимися значениями выделены
каждой своей заливкой. Ну как бы базово все, наверное, довольно понятно. А что будет, если мы
сделаем один шаг вперед, один шаг дальше? Если мы хотим сгруппировать по двум столбцам. Ну,
во-первых, сразу скажу, что в таком случае у нас не будет влиять на результат порядок группировки.
То есть мы можем department salary, group by department salary, можем group by salary department,
сформулировать селек запрос. Это неважно. Смысл в том, что у нас в нашей группе должны
быть повторяющиеся значения. Какой у нас будет результат? Результат будет следующий. Смотрите,
что получилось. У нас была исходная таблица 10 значений, результирующая таблица 7 значений,
7 строк. Что удалось сгруппировать? У нас здесь три IT-департамента, здесь у нас только два IT-департамента.
Что случилось? У нас по IT-департаменту есть два специалиста с одинаковой зарплатой. Вот это и
вот эта строка. Даже более того, вот два вот этих значения, вот здесь и вот здесь, они схлопнулись.
Вот они стали одним значением. Вот это значение у нас не может ни с чем схлопнуться. Оно уникальное,
поэтому оно попало в отдельную строку. Для маркетинга то же самое. Здесь схлопнулись у нас
значения 60 тысяч маркетинг. 60 тысяч маркетинг в одно. Маркетинг 50 тысяч. Оно осталось,
потому что ни с чем не схлопнулось. Получается еще с кадрами. С кадрами склопнулись два значения в одно.
И вот соответственно три склопывания. Три строки у нас три раза совместились,
соединились, сгруппировались по две строки. Из шести строк стало три. Вот из десяти начальных
строк стало отношение с семью результирующими. Давайте еще немножко усложним, попробуем посмотреть,
что получится с Хевинг. Хевинг сэлори больше 60 тысяч. Мы из предыдущей таблицы оставили у нас
в результирующем отношении только две записи, где у нас больше 60 тысяч рублей получает некто,
кто-то в IT-департаменте или финансе. Это не очень осмысленный запрос, но механику того,
как работает групп-бай по нескольким столбцам и как работает Хевинг, в принципе он показывает.
Одну секунду, вопрос в чате. Вопрос, если убрать групп-бай, то с точки зрения релиционной алгебры
не получится ли тот же самый результат? Если убрать групп-бай, то мы здесь
получим не вот эту табличку, а получим целиком, давайте попробуем на пальцах,
from new employees, то есть мы берем всю таблицу, берем оттуда department salary. Вы знаете,
может быть, что в этом конкретном примере кажется, что возможно так и получится. Это опять же с точки
зрения релиционной алгебры, потому что когда мы выполним вот этот вот запрос без групп-бай,
то есть select department salary, department salary from new employees, у нас не будет автоматического совмещения
повторяющихся результатов. У нас будет просто вот этот столбец и еще вот этот столбец целиком,
без исключения. Для исключения нам нужно будет задать условия, например, нам нужно будет там
distinct поставить, select distinct department salary, тогда скорее всего, наверное, получится такой же
результат. Кажется, что здесь, ну не кажется, здесь больше совпадающих значений нет, по идее должен
получиться такой же результат. Спасибо за вопрос, но повторюсь, в алгебре, в чистой алгебре получилось,
в базе данных автоматического совмещения идентичных значений не произойдет, просто выдаст запрос
полных два столбца со всеми десятью значениями, пускай они будут повторяющиеся.
Хорошо. Сортировка. С сортировкой все очень просто, ребят, здесь даже не будет сейчас
примера, потому что просто. Здесь сказать можно, пожалуй, что у нас выражение сортировки может
быть любое значение допустимое в списке выборки запроса. Когда указывается несколько выражений,
последующие значения позволяют сортировать строки, в которых совпали все предыдущие значения,
и каждое выражение можно дополнить ключевыми словами ask или desk, которые выбирают сортировку,
соответственно, по возрастанию или убыванию. По умолчанию принят порядок по возрастанию. То
есть мы можем в order by несколько условий задать, и условия будут работать, как указано. Последующие
значения сортируют строки, в которых совпали все предыдущие значения. По умолчанию, опять же,
у нас порядок по возрастанию, и мы можем также задать порядок работы с налами. То есть по умолчанию
у нас всегда считаются налы больше любых других значений. То есть подразумевается, что null first
для порядка desk и null last в противном случае. Но мы можем задать, соответственно, произвольно,
явным предложением null first или null last. Хорошо, давайте теперь поговорим, наконец-то, о порядке
выполнения запросов. Смотрите, у нас в чем проблема? SQL — язык декларативный. Мы не говорим,
как мы делаем, мы говорим, что мы хотим получить. SQL — язык, как мы уже с вами говорили,
семантически избыточный. У нас есть много вариантов получить те данные, которые мы хотим,
сформировав несколько семантических икновалентных, то синтаксических и различающихся между собой
конструкций. И хотя, как вы помните, из первой лекции разработчики пытались снизить порог входа
для SQL, но на самом деле запрос SQL нетривиальный. Я думаю, часть из вас на семинарах уже явно
успели в этом убедиться, особенно кто нашел под запросов. Они не тривиальные. На естественном
языке звучат просто, что мы хотим получить из базных данных. На SQL языке запрос будет не
столь очевидным, как хотелось бы. Процесс или команда получения данных из базных данных
называется запросом. В SQL запрос оформулируется с помощью команды Select. Это такая цитата
из официальной документации. Разберемся, как работает Select-запрос. Смотрите, хотя мы пишем
сначала как Select, From, Where, GroupBy, Having, OrderBy, Limit и Offset. Но на самом деле у нас выполняется
все иначе. Сначала у нас From и Join отрабатывает, потом Where, потом GroupBy, потом Having,
потом только Select, и дальше OrderBy и Limit или Offset. Что происходит? Сначала у нас в любом случае
из таблицы 1 с таблицы 2 происходит соединение. Причем Декартова в данном случае у нас показывает
соединение на этапе, а потом только у нас происходит выборка по соответствию значения columnA, columnA,
в т1 таблица и т2 по columnA соответствию. Дальше дополнительное ограничение какое-то логическое у
нас еще больше отфильтровывает таблицу, еще больше уменьшает результирующую выборку. Дальше мы можем
сгруппировать каким-то образом наш отношение, получившееся к этому моменту. И вот видите,
здесь показано визуально схлопывание по одному из атрибутов, схлопывание нескольких строк. И уже
вот это отношение мы также можем дополнительно каким-то логическим условиям ограничить. И только
потом у нас появится Select, будет отрабатывать Select запрос сам непосредственно. Он уже из
вот этого множество выберет те значения, те атрибуты, значения которых нас интересует.
И дальше дополнительно мы уже можем отсортировать или задать какой-то лимит или сдвиг на выдаваемый
результат. Пример работы запроса Select. Мы хотим знать название только двух городов, кроме Сан-Брунов,
в которых проживает два и более жителей. Мы также хотим получить результат упорядоченный по
алфавиту. Вот у нас такая мини схема наших отношений. Вот собственно два отношения представлены.
Есть какое-то количество горожан и три города. Так вот у нас два отношения. Вот как наполнены
эти отношения данными. Дальше что мы делаем? Вот у нас запрос. Вот у нас два отношения. Смотрим.
Сначала отрабатывает From Citizen, Joint City. Вот у нас полное декартовое произведение между Citizen
между горожанами и городами. У нас здесь было на предыдущем слайде 9 горожан и три города. И вот
здесь вот у нас, если вы посчитаете, 27 столбцов. То есть 9 на 3 у нас полное декартовое произведение,
27, прошу прощения, строк. Полная сцепка каждой строки с каждой строкой из двух таблиц. Дальше у нас
отрабатывает условие логическое на соединение. По CityID у нас происходит соединение. И здесь по равенству
CityID вот соответственно остается всего опять же 9 человек, как и было изначально в отношении
горожан. Дальше мы дополнительные условия накладываем на наши результирующие отношения. Говорим,
что нас не интересуют жители города Сан-Бруно, и вот они у нас исключены. И дальше мы группируем
наше результирующее отношение по значению CityName, по имени города. Обратите внимание визуально,
как это обозначено. Вот явно здесь обозначено, что строки схлопнуты. Таким образом у нас как бы и
таким образом вот это и нужно себе представлять для удобства. Слопывание строк как объединение
ячеек просто-напросто в таблице. Потом мы отфильтровываем по HeavenCount больше или равно
двум. То есть там, где у нас больше чем две строки, подразумевается, что каждая строка это отдельный
горожанин. У нас здесь везде больше двух строк, поэтому оба для обоих городов у нас остается
неизменным количеством записей о горожанах. Дальше мы наконец отрабатываем наш Select
Statement, Select предложение и выводим имена названия городов, которые соответствуют нашему запросу,
и дальше уже мы их сортируем и ограничиваем. Лимит два ставим, но здесь опять же только два
города, поэтому произошла только сортировка без ограничения списка выдачи. Таким образом,
ребята, мы с вами разобрали основные моменты, связанные с Data Manipulation Language, с языком
манипулирования данными под множеством языка SQL. Посмотрели на основные особенности Select
запроса, на типы соединений, на то, как отрабатывает Select запрос. Посмотрели на остальные операторы DML,
это Insert, Update и Delete. В следующей лекции у нас будут агрегирующие функции под запросы обязательно,
и мы постараемся с вами разобрать основу проектирования баз данных. Таким образом,
вы после следующей лекции будете во всеоружии, я надеюсь, для начала подготовки курсового проекта.
