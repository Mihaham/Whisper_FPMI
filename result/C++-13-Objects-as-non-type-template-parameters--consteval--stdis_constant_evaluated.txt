Ну начнем мы с чего-то достаточно безобидного. В прошлый раз мы, кажется, пообсуждали,
что можно делать в Compile Time, начиная с C++20. Давайте в этот раз мы поговорим вот о чем.
Пункт 16.2 я назову objects as non-type template parameters.
Ну вы уже поняли по названию, что это такое. Начиная с C++20 параметрами шаблонов могут быть
объекты классов. Ну почему бы и нет, ведь мы же уже научились все это создавать в Compile Time,
строки создавать в Compile Time, векторы создавать в Compile Time, мы объекты умеем создать в Compile Time,
конструкторы, деструкторы, constexpr делать, new вызывать в конце концов в Compile Time мы умеем.
Вот так почему бы тогда не сделать следующий логичный шаг и не разрешить параметрам шаблонов
быть объектами классов. Вот. Ну я здесь, наверное, даже не буду сам код писать,
а просто покажу пример из книжки. Вот есть такая книжка C++20 complete guide. Она, впрочем,
бесплатно не скачивается, и нужно иметь еще нероссийскую карточку, чтобы ее оплатить,
даже если вы хотите. Но, тем не менее, примеры из нее вот я вам сейчас покажу. Вот пример того,
как мы можем использовать, например, какой-то объект как параметр шаблона. Смотрите,
что здесь происходит. У меня есть функция addText, которая принимает число, а в качестве шаблонного
параметра она принимает объект. Вот. У меня есть структура, которая содержит... структура,
которая содержит... не, пока это еще нормально, это еще не так страшно. Структура,
которая содержит double. Вот. И поскольку я объект этой структуры передаю в... создаю
как constexpr, я могу его использовать как шаблонный параметр функции. Ну вы поняли, да? Ну то есть это
некоторое... до этого вас должно было такое возмущать. У вас должна была возникать мысль,
что так же нельзя, это же не скомпилируется. Ну вот, начиная с C++20, это должно компилироваться. То есть
мы спокойненько constexpr объекты как шаблонные параметры отдаем параметр шаблона. Нормально.
Можно даже вот так. Да-да, даблы тоже можно делать. Во-первых, начиная с C++20 можно делать
шаблонными параметрами не только целочисленной величины, но и даблы и все прочее. С каким округлением?
Я все еще не понимаю вопроса, а что с ним работать-то? Она будет как обычно, ну а что? Что такое?
Если мы передадим в tracks 3 и передадим 1 плюс 2, ну или что-то 0.3 или 0.1 плюс 0.2, это же будут разные tracks.
Ну, я думаю, да. Это твои проблемы просто. Вот, и даже я могу вот здесь undervalue написать,
то есть я написал некоторые expression здесь внутри шаблонных внутриугловых скобок,
который ну просто в compile-time-е вычислился. Поскольку конструктор text у меня тоже constexpr,
я могу в compile-time-е вычислить такой expression и отдать его как шаблонный параметр туда. Вот,
следующий пример. Это, да, ну во-первых, теперь приходит в голову следующая идея. Окей,
мы поняли, что шаблонными параметрами могут быть, может быть, уже много чего.
Давайте делать шаблонные стримги, шаблонные виктороны.
Не-не, другая идея, более радикальная. А нельзя ли сделать шаблонным параметром?
Шаблонным. Это мы еще до 7 плюс 11 умели.
Нельзя ли заставить компилятор сам отгадать, что мы передали в шаблонный параметр?
Типа авто. Конечно. Ну, ведь у нас шаблонным
параметром теперь, как и параметром функций, могут быть int, double, char и все что угодно,
объекты. Давайте разрешим шаблонным параметром делать авто, и пусть компилятор сам отгадывает,
что стало шаблонным параметром. Так тоже можно делать, начиная си плюс плюс 20. Вот,
мы прекрасным образом, значит, это пишем. Вот, но надо здесь сказать, что когда мы пишем авто в
шаблонном параметре, подразумевается, что это должен быть именно объект. Ну, это должен быть
переменная. То есть, если мы отдадим typeName, шаблонный параметр, то мы не сможем... ну,
авто не выведется. Логично. Да, ну давайте, вот давайте этот пример я разберу. Так,
для начала надо понять, у нас вообще этот код компилируется с прошлого раза или нет.
Да, это хороший вопрос. Сейчас, у нас тут, значит, какие-то были артефакты с прошлого раза,
я уже забыл, что мы тут. Ну, короче, я просто вот эту удалю и эту тоже удалю. Теперь я ни от
чего не вызываюсь, я должен компилироваться. Отлично. Вот, ну давайте, я попробую завести
какой-нибудь шаблон с шаблонным параметром авто. AfterX. Вот. StructTest. А constexpr-seout есть?
constexpr-seout бессмысленный, потому что ты не можешь в compile-time его выводить. Ты уже задавал,
кажется, этот вопрос. Что? Ну, кто-то в прошлый раз задавал вопрос. constexpr-seout нет, нету constexpr.
Ну, в смысле, оператор вывода не constexpr, потому что это уже, ну, вопрос, что бессмысленно,
а что бессмысленно, конечно, уже такой немного философский. Кто-то может сказать, что пять лет
назад, что и new в compile-time дело бессмысленно, но, в общем, пока мы считаем, что нет. Вывод
seout в compile-time делать нельзя. Так, ну, я не знаю, давайте там вот напишем value. Вот, и какое-нибудь
там сделаем. Ну, не знаю. Ну, хотя бы просто так напишем. То есть вот давайте я, например, скажу,
что у меня будет тест с шаблонным параметром 5 и тест с шаблонным параметром 2.07. Вот, и,
так не работает. Ай, да, я ерунду написал. Ну, давайте тогда какой бы пример здесь
сделать, какой надо сделать пример. декл-тайп от X. Да, декл-тайп от X, почему бы и нет. Замечательно.
Компилируем. Работает. Ничего не выводит. Вот, ну, я могу попробовать написать здесь
какой-нибудь статик ассерт, что это is-same, is-same-v, а, ой, Господи, декл-тайп. Так, нет, плохо.
Что же мне написать-то? Ладно, я не придумал, что здесь написать, но, в общем, ничего не буду.
Где? Ну, можно, а зачем? Ну, от этого, по идее, ничего не поменяется. Ну, смысл в том, что я объект
создал, Господи, в ран-тайме, просто авто все равно в компилтайме подставилось. В каком компиляторе?
Вот, видите, а g++11 ты уже поддерживаешь. Ну, вот здесь еще один пример от Николая Джасатиса,
который показывает это на примере использования строк. А, я понял, Silaim подчеркивает, но он уже
справляется. Примере использования строк. Ну, давайте посмотрим, что здесь происходит. Во, здесь
есть темплейт с шаблонным параметром prefix. Logger. Что делает Logger? Он берет message, он, короче,
логирует все сообщения, но каждый из них предваряет некоторым префиксам. Отличный класс. И этот префикс
это шаблонный параметр, который авто. Вот. И вот, я говорю, Logger с шаблонным параметром вот таким.
Сделай Log. А str это класс, который в себе содержит массив чаров и умеет конструироваться от массива
чаров. Да, можно было бы и str. То есть, можно было бы сюда передать объект. То есть, я мог бы здесь
написать constexpr, там, str, s равно чему-то, и отдать ее в Logger. И получился бы Logger, который... два
разных Logger. Один от такого класса, другой от str. Ну, думаю, тоже можно. Я, правда, не знаю,
как это бы работало. Ну, указатели тоже можно делать с шаблонными параметрами, начиная с
20. Ну, кажется, да. Кажется, это должно работать. Вот. Ну, давайте проверим просто. Я сейчас просто
этот код скопипащу. Не знаю, давайте nttp objects. Ну, я хочу попробовать обычную строку,
сишную, отдать туда как шаблонный параметр. Logger, abcd, Logger2. Вот. Ну, давайте проверим,
что это компилируется. Значит, nttp objects. Нет, const char звездочкой не может почему-то. Вот.
Строковые литералы, значит, он все-таки не разрешает. Но str string он, по идее,
должен разрешить. Правда str string, как мы знаем, он меня не поддерживает, g plus 11, как const export,
поэтому он не разрешит вместо str. Но вот это вполне разрешило. Вот. Ну, и совсем бронебойный
пример. Вот. Прежде чем вам показать совсем бронебойный пример, надо вспомнить про то,
что такое constant expressions. Помните, я вам показывал список того, чем не могут быть constant
expressions. Так, сейчас давайте я все-таки откроюсь периференс один раз. Чего? Не-не, recurrent template
pattern это другом. У меня есть вот такое вот, значит, constant expressions. И здесь был такой
замечательный пункт, что до C++17, ну, вот это список того, что не является core constant expressions.
То есть, что не может быть, что не может использована в const export контексте. И тут написано лямда
expression до C++17. Кто-то в прошлый раз спрашивал, можно ли лямду делать const export. Начиная с C++17
можно. То есть, лямду можно трактовать как const, ну, как compile time, ну, короче, как
constant expression. То есть, можно инициализировать объект лямбы, лямды в compile time. Можно писать
const export auto f равно некоторой лямбда. И лямда, корректный constant expression, он вполне себе в
compile time инициализируется. Вот. Отсюда интересное следствие. Начиная с C++20, ну, там есть еще
некоторые ограничения. Не вообще все объекты могут быть параметрами шаблона. Там есть список того,
какие должны удовлетворять свойствами, а не чтобы были. Вот, кстати, можно попробовать вот здесь
вот спросить structural type site in cpp-reference.com. Нет, он не понимает, что это такое. Ладно,
давайте так спросим. Да. Значит... Начиная с C++20, здесь где-то должно быть написано...
Не написано. Короче, я не помню, на какой именно страничке это написано.
template non-type arguments. Начиная с C++17. Не знаю, почему здесь на этой странице не написано.
Ладно, бог с ним. Ну, короче, есть некоторый набор ограничений, каким не может быть этот объект.
Но, в общем, лямда удовлетворяет этим ограничениям. Я к чему? Я к тому, что объект лямды, сам в себе
объект лямды, может быть аргументом шаблона. Не тип, а объект. И lambda expression может выступать
в роли шаблонного параметра. Ну, короче, что просто тут тянуть? Вот вам пример. То есть,
смотрите, что... А, да, во-первых, здесь еще один интересный момент. Я могу не просто авто писать,
а концепт в шаблоне писать. Авто. Напоминаю, просто авто это означает, что сам догадайся,
какой тип я передал. Но также мы с вами в прошлый раз обсуждали концепты, и я говорил, что можно
в шаблонах писать, шаблонными параметрами делать концепты. Вот нужно понимать разницу между
просто авто как параметром шаблона, stdinvokable как параметр шаблона и stdinvokable авто как
параметр шаблона. Все ли понимают это? Три разных вещи. stdinvokable без авто означало бы, что параметром
шаблона является некий тип, который обязан удовлетворять концепту stdinvokable. Авто означает,
что параметром шаблона является некий объект без каких-либо ограничений, ну кроме тех, что
стандартом наложены. А stdinvokable авто означает, что параметром шаблона является объект, тип
которого удовлетворяет концепту stdinvokable. И вот мы в качестве параметра шаблона передаем объект,
объект лямбда. Причем здесь очень интересно, что, вот это кстати я сам до конца не понимаю,
это очень интересно, что здесь констэкспорт не написано. Ну видимо он констэкспорт. Кажется,
там есть какое-то правило в стандарте, что лямбды являются констэкспорами по умолчанию, начиная с
какой-то версии. Если я даже не написал авто, да вот здесь вот почему-то не написано констэкспорт,
тем не менее оно компилируется. Почему вообще можем верить, что лямбда это констэкспорт?
Я не знаю, почему это работает. Согласно какому-то пункту стандарта, так можно.
Вот. Ну, короче, я могу эту штуку сюда вставить и проверить, что она тоже компилируется.
Только мне мейн придется, правда, заменить. Ну, ничего страшного.
Все, компилируется, и видите, даже выводят числа нужные.
Так, я тут что-то намутан, конечно. Да.
Да. Ладно, давайте я это просто удалю.
Вот так. Нормально?
Вот. Я мог бы, я думаю, передать в качестве шаблонного аргумента лямбду просто безпеременной.
Вот это я, скорее всего, мог бы сделать вообще без проблем. То есть я могу здесь сказать return 0.35 и нормально.
То есть я передал в шаблон лямбда expression. Все, компилируется.
Получается, можно написать все четыре дискобыча подряд. Ну, почти подряд.
Вот, на самом деле этот, на самом деле C++20, вот Николай Джасатис, который является одним из членов комитета и который как раз написал большую книжку про C++20 и все его возможности,
он там в предисловии говорит, что, возможно, даже не в предисловии, а в аннотации, что C++20, он огромный и, возможно, он изменит то, как мы пишем код на C++ еще сильнее, чем C++11.
Просто пока еще очень мало кто в мире знает все его возможности.
То есть, на самом деле, они дофига чего добавили. И вот то, что я вам сейчас показываю, это такое вот, ну, это вещи, которые мало где используются, но вот, скорее всего, в ближайшие 5 лет люди будут активно их изучать везде, во всех компаниях и начинать внедрять.
И прям, вероятно, код на плюсах, который будет писаться где-либо через 5 лет, человек, который учился 5 лет назад, уже не узнает, что происходит.
C++20 это действительно очень большой...
То есть, это мы сейчас учимся 5 лет назад?
Не-не, 5 лет по сравнению с вами. Вы-то уже, видите, вы-то уже ознакомились, вы хотя бы будете понимать, что это здесь написано, вот, но...
Почему это принципиально меняется?
Вот непонятно, да?
Почему?
Почему?
Понятно, что такое std move, std, все на свете, и т.д.
А здесь...
Ну, во-первых, сами по себе концепты очень много добавляют, ну...
Это просто какие-то ограничения?
Концепты, это новый элемент синтаксиса, который просто...
С помощью которых можно переосмыслить многие части стандарта и написать их лучше.
Ну, там, написать многие части стандарта библиотеки лучше, чем они ранее были написаны.
Вот, просто мы еще пока не...
Не-не-не смотрели на все вот эти вот части.
Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
Не-не-не смотрели на все вот эти вот части с новой точки зрения.
Вот если мы, зная концепты, снова проанализировали все, что мы ранее писали,
и везде подумали, какой бы концепт добавить,
то, возможно, код бы сильно видоизменился.
То есть представьте просто, что всякий раз, когда вы добавляете шаблонный параметр,
вы не просто type name пишете, а концепт пишете.
Или вы добавляете шаблонный параметр, вы помните, что он может быть и объектом.
И вы, например, некоторые вещи, которые и так можно в compile-time заранее предугадать,
делаете просто объектами, которые являются шаблонными параметрами.
Представьте, что вы лямды можете делать шаблонными параметрами.
Ну, короче, это открывает большую свободу и может видоизменить логику кода сильно.
Ладно, с объектами, шаблонными параметрами.
Не, ну, подожди, Илья, вот у нас, например, раньше были constexpr функции,
которые мы в compile-time равно также могли передавать аргументы.
Только теперь мы аргументы пишем не в круглых скобочках, а в углу.
Ну а какая разница?
Слушай, ну, ты говоришь, по сути, ну...
Ну, я не знаю, непонятно, о чем спор.
Я утверждаю, что просто синтоксически сильно много чего стало по-другому можно делать.
И, возможно, это стало удобнее.
И, возможно, код через пять лет будет выглядеть иначе принципиально, чем он выглядел там пять лет назад.
Просто некоторые идеи, как можно выражать мысли в коде, они вот...
Ты, как бы, и до 7++11 функционально ничего не добавилось.
У тебя и до 7++11 из-за шаблонового метапрограммирования был полон по тюрингу.
До прихода constexpr ты мог также говорить, ну, что добавилось со шаблонов constexpr?
Я же и раньше мог шаблонную рекурсию делать, и как бы все бы тоже самое было.
Мог-то ты мог, но просто синтоксис был уродский.
Вот, то же самое здесь. Вот, например, у тебя были концепты, а раньше был enable их.
Ты и раньше мог все то же самое делать, просто уродским синтоксисом.
А вот это что красивее?
Да.
Не, ну концепты точно красивее.
Помни проверку на простопу, которую приходилось писать в матриксе?
И пойми, что сейчас это буквально одна трансляция.
Что?
Кстати, да.
Ну, ты можешь, вообще ты можешь просто делать, как будто даже концепт просто, чтобы просто принимать простое число каким-то.
Да.
Да.
Конечно.
Ты можешь буквально сделать концепт, принимающий только простое число.
О, как это сделать?
Ну, ты же делал как-то.
Ну, у тебя была эта функция...
Не, ну, тебе надо там не концепт, концепт это все-таки ограничение на тип.
Ну, вот именно концепт.
Да.
Тебе нужно скорее написать какой-нибудь requires там будет, а не концепт просто.
Концепт, да.
С этим мы в прошлый раз не разобрались, как писать requires, не в контексте.
По-моему, разобрались.
Не в контексте шаблонного типа...
А, это да?
Да.
Ну, например, в mining мы не смогли написать.
Ну, потому что у нас шаблона не было никакого.
Так не в контексте шаблона и нельзя, да.
Не в контексте шаблона будет CE просто.
Ну, он...
Ну, в контексте шаблона...
В контексте...
Ну, просто requires оценивается в момент...
Вычисляется в момент, когда делает шаблонная подстановка.
И в зависимости от того, корректная она или нет, он либо CE кидает, либо не кидает.
Ну, в смысле, либо true, либо false возвращает.
А если requires это в...
В сигнатуре функции, да, то он либо включает ее, либо включает.
Ну ладно, короче, можно долго языком болтать.
Все понятно, что много чего теперь можно писать по-другому.
Вот.
Кто будет на плюсах писать после того, как этот курс закончится.
Вот.
Вы знаете, что можно и так тоже.
Вот, живите с этим.
Думайте, как это использовать.
А еще пара вещей тоже про C++20.
А следующая вещь, которую я хочу рассказать, это...
Еще одно важное, на мой взгляд, слово называется const-eval.
И давайте это будет пункт 16.3.
const-eval и std isConstantEvaluated.
Evaluated.
До C++20 у нас было, по сути, только одно слово, которое обозначало, что функция или переменная должна быть...
Вычислена проинтересированный этап компиляции.
constexpr.
Вот.
Но, как вы помните, constexpr применительно к функции означает, что она может быть вычислена как в компайлтайме, так и в рантайме.
Зависит от того, в каком контексте она вызвана.
Вот.
Спустя некоторое время может возникнуть естественное желание для некоторых функций запретить, чтобы они могли вызываться в рантайме.
То есть, вы хотите написать функцию, которую хотите вызывать только в компайлтайме, и не позволять ее вызывать не из компайлтайма контекста.
Из правил.
Ну, какую угодно.
Вот.
constexpr это не то.
constexpr позволяет вам себя вызывать из не компайлтайма контекста.
Таким образом, вы не проверите, что любое использование этой функции делается только в компайлтайме.
В C++20 появилось новое ключевое слово, которое позволяет вам делать именно это, называется consteval.
У меня, скорее всего, он тоже не подсветит его, к сожалению.
О, у вас тынит еще какой-то есть.
Еще есть consteнит, о нем я расскажу в следующем пункте.
Сначала...
consteval это питоновский вал завезли?
consteval.
Ну, давайте, блин, зря я, наверное, этот...
Зря я новый файл создал.
Я лучше вернусь вот к этому файлу.
Здесь у нас есть функция constexpr.
У нас есть несколько constexpr функций, да.
Давайте я...
какие-то из них назову consteval функциями.
Например...
Ну, например, вот эту функцию я сейчас consteval объявлю.
К сожалению, я не успел наладить, чтобы у меня подсветка была для C++20, но это тоже ключевое слово.
Оно тоже как и constexpr зелененьким, по идее, должно быть подсвечено.
Только с функцией.
Да, consteval для переменных, насколько я знаю, не применим.
Функция, которая объявлена как consteval, это так называемое, есть такой термин immediate function.
Функция немедленная.
Ну вот, immediate.
Please proceed to the gate immediately.
Ну вот.
Если я попробую...
эту функцию вызвать в обычном...
в рантайме.
std seout isPrime от, не знаю, 11.
Часто будет ошибка компиляции.
Потому что я не должен вызывать...
Нет, это не ошибка компиляции, почему?
Может быть, потому что мой...
компилятор не поддерживает это.
А почему он тогда consteval распознал?
У меня тоже скомпилировался.
Любопытно.
Что, я неправильно понимаю, как работать consteval?
Хорошо, давайте...
Давайте откроем.
Может есть какой-нибудь более правильный пример.
Я, наверное, что-то забыл.
А, ну...
Значит...
Вот сейчас это точно должно упасть.
Я...
сделаю что-нибудь такое, а потом проверю ifPrime от n.
Да, вот это уже падает.
Ну, я могу даже seout не делать.
Я просто сказать intn равно...
Нет, это понятно.
Почему он с seout работал от единицы?
От 11.
От 11.
Да.
Значит...
Пример был неправильный, вот правильный пример.
Если я ifPrime вызываю от conste,
то он...
Ну, как бы...
ifPrime это функция, которая может вычисляться только на этапе компиляции.
И...
контекст, которым она используется...
Ну, не контекст, которым она используется, значит, а вот...
Любое ее использование...
должно...
должно приводить к учтениям на этапе компиляции.
Если я вызываю ее от константы, от 11,
то он просто...
вот это вычтение isPrime от 11
в compile-time делает и в compile-time подставляет результат.
Вот, то есть...
Смотрите, как это работает.
Получается, я...
даже не обязательно в compile-time-контексте ее должен вызывать.
В каком бы контексте я ее не вызвал,
компилятор будет пытаться делать вычтение на этапе компиляции.
Но если я ее вызвал от чего-то,
что само не является constant expression,
то вот это будет CE.
Потому что он как бы видит,
что isPrime от N должен вычислить в compile-time,
но N не constant expression,
поэтому от него нельзя в compile-time вычисляться.
Вот, поэтому это падает.
Вот, еще есть такой интересный...
пример.
Ну, на самом деле, довольно полезно, на мой взгляд,
потому что, получается, вы можете гарантировать себе,
что некоторые вещи вы всегда в compile-time будете вычислять.
И есть такой достаточно интересный...
А, ну вот, пример с...
пример с...
с CVPerference,
factorial,
CE.
Вот.
И еще одно интересное, на мой взгляд, нововведение,
о котором хочется рассказать,
это вот такая вот функция из constant evaluated.
Это встроенная в компилятор функция, начиная с C++20.
Раньше она была compiling intrinsic,
то есть в C++17 можно было писать двойное подчеркивание
и какое-то там заклинание,
ну, как раньше, может, для некоторых вещей было.
Сейчас это является частью стандарта.
Это проверка того,
вы сейчас в compile-time вычисляетесь или нет.
Опа.
Опа.
Что? А, стоп.
То есть эта функция возвращает true тогда и только тогда,
когда вы сейчас вычисляете ее в compile-time.
А вот это уже полезно.
И эта функция реализована компилятором,
то есть ее реализовать самим нельзя, конечно.
А вот это уже полезно.
Она реализована как-то внутри компилятора.
Типа, как лонгер?
Нет, хуже.
Ну, компилятор просто обязан эту функцию
ее оценить в true,
если он сейчас делает вычисление в момент компиляции
и оценить ее вызов в false,
если это вычисление...
Место, где он ее встретил,
является вычислением не на этапе компиляции.
Вот это мне кажется.
Вот это тоже полезно.
В STD, а не просто какое-то ключевое слово.
Не знаю.
А лонгер разве не в STD лежит?
Нет, ну, существует много функций,
которые вы не можете реализовать сами.
Раньше это было compiler-intrinsic, я говорю.
То есть это раньше можно было написать, значит,
с двумя подчеркивания, что-то там.
А сейчас это часть стандарта стала.
Вот.
Давайте покажу вам пример.
Ну, скажем.
Я хочу написать возведение в степень.
Число double в целую степень возвести.
Смотрите, что я могу делать.
Ну, классический пример.
Если я сейчас в compile-time,
то я пишу руками.
А иначе вызываю STD пол
от каких-то двух вещей.
Ну, то есть у меня могут быть какие-то функции,
которые не constexpr.
Или какие-то алгоритмы сложные, например.
Ну, первый пример.
У меня функция, которая не constexpr, STD пол.
Она не constexpr, насколько я помню.
Пока еще.
Счастье, хоть что-то не constexpr.
Да.
И ее я не могу в compile-time вызвать.
Поэтому, если я пытаюсь там делать какую-то обертку
над возведением...
Если мне где-то нужно в каком-то своем коде обратиться
к функции возведения в степень,
я, конечно, понимаю, что STD пол, наверное,
это делает эффективно.
Или там STD, не знаю, сим, какое-нибудь вычление,
какое-нибудь математическое синусо.
Оно, наверное, это дело хорошо, эффективно, быстро,
но не constexpr.
А я не знаю, я в compile-time сейчас нахожусь
или нет.
Вот я в constexpr функции
могу не знать, я в compile-time
или нет нахожусь сейчас.
Я могу написать такое, если
я в compile-time,
то я
ручками вычисляю, а иначе вызываю
функцию, которая в compile-time бы у меня
кинула CE.
Сейчас, а если я напишу
и в constexpr, это другое немножко будет?
Вот.
Популярная
заблуждение, я сам эту ошибку
делал пару раз,
прежде чем запомнил.
Значит, из constant evaluated
есть классическая
наивная мысль,
которая неверная.
Почему не и в constexpr, ведь казалось бы,
мы в compile-time должны проверять.
Ну типа понятно, что там два варианта.
Вот, на самом деле, если я пишу и в constexpr
и пишу STD из constant evaluated
под и в constexpr, то это
нигда true.
Потому что то, что вы под и в constexpr
загнали,
обязано быть вычислено на этапе компиляции.
А значит,
если вы под и в constexpr спросите
из constant evaluated, вы получите
true, независимо то, в каком контексте вы находитесь.
Ладно, можно было
генерировать две разные функции,
в зависимости от, но да.
Поэтому constexpr
функции, где а смысл
использовать из constant evaluated?
В constexpr функции под
обычным if, не под и в constexpr,
а под обычным if.
Тогда, если вы сейчас вычисляете
эту функцию, находясь в compile-time,
вы получите true
и пойдете сюда,
а это все не будет...
Ой, наоборот, вы получите true и пойдете сюда,
это не будет вызовано,
и тем самым вы не получите CE.
Вы не дойдете до вызова не constexpr
функции в compile-time
контексте.
Да, ну, по сути, да,
вы в compile-time
не дойдете
до этой строки, и поэтому
это не будет CE. То есть у вас
в constexpr функции есть вызов,
не constexpr функции, но вы
до него не добираетесь, поэтому это не CE.
Повод это не constexpr функция?
Повод это не constexpr, это статичная функция.
Если бы я записал
то, что под
вычисляется
в compile-time, и там написал
что-то с const eval.
Вот.
Он бы, когда
уже скомбилировал код,
он бы все равно увидел этот
const eval. Сейчас, я не понимаю, const eval
ты где хочешь? Внутри части, которая
в compile-time вычисляется.
const eval, то как функция применима?
Ну, там вызываю какую-то const eval функцию.
Тогда, когда я скомбилировал
код,
там уже не runtime
проверка, и он смотрит, что
я эту функцию вызываю.
Когда ты скомпилировал этот код,
вместо вызова const eval функции, должна быть
некоторая константа.
В runtime не бывает вызова в const eval функции.
Если ты скомпилировал
код, в котором был вызов в const eval функции,
то, когда компиляция закончилась,
на месте этого вызова, некоторая константа должна стоять.
В этом смысл const eval.
Там я внутри написал
const eval expr от x.
Внутри чего?
Внутри вот этого? Да, внутри вот этого блока,
который на этапе компиляции вычисляется.
Давай я просто копипащу
этот код, и мы
проделаем то, что ты предлагаешь.
Так, вот у меня есть такая функция.
И что ты предлагаешь делать?
Я хочу внутрь compile time
части засунуть
вызов какой-то const eval функции
от параметра,
который
может быть
runtime-овским.
Вот simf.
Сейчас я проверю, что это так компилируется.
Ты хочешь вот здесь
написать что-то?
Не здесь. А где?
Внутри ifr. Хорошо.
Что ты хочешь написать?
Например, написать bool flag
из prime от x,
которая const eval у нас.
Из prime от x.
Она же const eval у нас?
Из prime у нас const eval, да.
И ты спрашиваешь, что будет,
если ты вызовешься в runtime-е?
Я могу вызваться ее
и в runtime, и в compile time.
В compile time все будет нормально.
Нет, ты не можешь вызваться в runtime.
А в runtime-е как раз вопрос
типа, что...
Если ты
находишься в compile time,
если ты находишься в runtime-е,
то ты не попадешь в эту ветку ifr.
Да, но она же все равно скомпилирует эту часть кода
и увидит, что я вызываю вот эту const eval функцию.
Скорее всего, нет.
Если находишься
в runtime-е,
то ты...
Да, хороший вопрос. Не знаю.
Давайте проверим.
Да, ты прав.
Так нельзя.
Вот ее уже придется по const eval занести.
Как бы.
Ну, вопрос.
Вопрос был такой.
Я вот в этой функции...
Вот я вот здесь решил вызвать
const eval функцию.
Под ifr,
что я из const eval.
От x.
Где x, это не
const expression, вообще говоря.
Ну да, это ce.
Потому что
я не могу скомпилировать этот код
if у меня не const export.
if обычный.
Не важно, что я из const eval.
Важно, что я здесь пытаюсь вызвать
const eval функцию
от неконстанты.
Что я пытаюсь вызвать
const eval функцию
от неконстант экспрешена.
Под ifr, который сам
не const export. Вот если бы ifr был const export,
то было бы нормально. Я бы не пытался
это компилировать, но тогда
if const eval это всегда бы оценивалось в true,
и я бы сюда никогда не попадал.
А если вот эту штуку вы
обратите в if const export
от if const eval.
А у меня все равно не работает, кажется.
if const export от std.
Можно просто от true тогда уже.
Так, кстати, это очень
Но у меня все равно полномородается.
Не, не.
В чем проблема?
Кажется, что
Кажется, что if const export
от true
Ну, я думаю, что
это не должно помочь, это было бы странно.
А вот тогда непонятно, как использовать вообще.
Да, это
Мы же много CE
тогда очень будем ловить.
Нет, в плане просто мы не сможем использовать
вот это вот.
Да, это тоже не помогает.
Мы знаем, что мы находимся
на этом кюфлятце, но не можем выслезать
const eval в функции.
Ну да, вот так вот.
Вот это уже
просто странно. Как это чинить?
И как оно предполагается,
что должно работать в целом?
В смысле компилятор считает, что
теоретически мы можем зайти в эту ветку
внутри
runtime, да?
Вопрос в том, что компилятор
делает раньше. Проверку того, что
здесь делается
вызов const eval функции от
нужного выражения, или
от запрещенного выражения,
или проверку, или if const export
обрабатывает.
Нет, подождите.
Кажется, что неважно даже, в каком
порядке это делает, важно, что
для него означает вызов const eval функции.
Он просто...
Вот если бы я так написал...
Сейчас. Господи.
Я ерунду какую-то написал, конечно.
Вот так это по идее с компиль
все равно не... То есть даже
так.
Как раз так не должно теперь.
Ну, просто вопрос в том, насколько
рано он обрабатывает const expry.
А типа, что раньше const expry
или проверка? Что он раньше
делает const expr проверку и
убирает, как бы, код одной из
веток EFA, или вот это вот
проверяет, что здесь const eval. Похоже,
что он... Даже если я const expr
сделаю вот здесь,
это не спасет.
Слушайте, не знаю, это запутанная история. Короче,
надо подумать.
И в const expr,
и здесь, по идее,
должно быть всегда false. То есть я, по сути,
написал ему, не компилируй это.
Вот.
И он все равно
выдал CE, все равно
скомпилировал это.
То есть это означает, что проверку того, что
const eval функция делается, вызывается
от правильного выражения
до того,
как выключает
одну из детей const exp... и в const expry.
Ну, очевидно, довольно часто нужно
пользоваться какими-то...
Но, я вам скажу так,
в C++23 появится и в const eval.
Так они вот все, они думают,
как я.
Да, я думаю, что...
Вот так это можно будет реализовать
в C++23.
Этого же не будет на экзазе.
Этого нет.
Нет, не будет.
Как работает const eval?
Реализуйте.
Я не знаю, в общем,
это упражнение
на самостоятельное изучение.
Я не знаю,
это упражнение
на самостоятельное изучение.
Я не знаю,
это упражнение
на самостоятельное изучение.
Хватит с меня этого.
Давайте дальше.
Короче, вы поняли, что есть const eval
и есть функция
из const eval edit,
но с их использованием есть вопросики.
Последнее, о чем я расскажу,
это const init. Последнее, о чем я расскажу
в теме const expry и прочего.
Илья, можно ли делать перегрузки
по const eval?
Это как, в смысле?
Ну, без этого, но без этих приколов.
Ну, то есть, явно написали...
То есть, одна версия const eval, другая нет?
Я думаю, нет.
Но вряд ли это часть сигнатуры.
Перегрузку уже можно делать, если это часть сигнатуры.
То есть, ты говоришь,
то, что мы хотели сделать,
адекватно сделать невозможно.
До C++23.
А что именно мы хотели сделать?
Из const expry функции вызывать const eval?
Есть какая-то реализованная нами
const eval функция pow,
которая вызывается, если наша не доступна.
Ну, чтобы ветвление было...
И мы ее хотим просто вызывать.
Чтобы ветвление было на этапе компиляции,
а не на...
в runtime.
Ну, то есть, чтобы у нас не if
решала какая версия,
чтобы связывалась сразу с нужной версией.
То есть, короче, просто весь этот код, который мы написали,
вынести в отдельную функцию.
И вызывать либо runtime, либо нашу.
Ну, в общем, может быть,
способ сделать это есть, но я не знаю.
Вот так.
Из const expry функции вызывать const eval?
Ну, видимо...
Видимо, да. Видимо, вот, нельзя.
Может быть, как-то можно, но я не знаю.
Последний это const init.
Чтобы рассказать, что такое const init,
мне придется вам
сначала рассказать
о том,
о чем, возможно, стоило бы рассказать
даже в первом семестре.
У нас, короче, такая есть тема,
еще одна тонкая,
которую мы как-то всегда в стороне оставляем.
Сейчас, момент.
Никто ничего не написал.
Важно.
Вопрос
в том,
как происходит
инициализация
глобальных истетических переменных.
Вот, чтобы понять,
что такое const init,
надо понять,
что еще нам
дает const expry,
помимо того, что он обязывает
правую часть быть
const expry.
Ну, вот, когда мы пишем const expry,
это какая-то переменная.
А что это означает,
помимо того, что
справа должно быть const expry?
И это, на самом деле, означает нечто большее.
Это означает,
что у переменной...
Сейчас я вам открою статью одну,
только я для этого
проверю, что...
Нет, это не та статья.
Где тут у меня была открыта статья?
У меня тут много чего открыто,
все не то, что надо.
У меня все почему-то не дают вызвать
из const evaluator
из const expry.
Я нашел.
Вот оно.
Значит, вот есть такая статья хорошая.
Я вам ее, наверное, скину.
А про то,
как вообще происходит инициализация статических
и глобальных переменных.
На самом деле есть
инициализация,
как и много еще в этом мире,
бывает статической и динамической.
Как вы, наверное, догадываетесь,
что статическая инициализация так,
которая на этапе компиляции происходит,
а динамическая так, которая в рантайме происходит.
Вот, например, написали вы
объявили вы какую-то глобальную переменную.
Вы написали, например,
std string s равно
и что-то справа.
Вот вопрос.
На этапе чего
будет инициализирована эта переменная?
На этапе компиляции
или в рантайме?
Наверное, в рантайме.
А справа у вас какое-то выражение,
где надо создать string.
Да, кажется, что это должно быть
сделано в рантайме, потому что
иначе это бы означало,
что компилятору в compile-time
нужно создать объект string
и
его
чем-то пронициализировать, куда-то положить.
Но это со string
ладно, со string понятно.
Пример написали. У меня есть там
static
А вот, кстати,
давайте я вам как раз такой
примеры покажу. Вот, смотрите.
Да, это будет пункт
16.4
static
and dynamic
initialization
const init
16.3
это был const eval
и из const evaluate
Вот, у меня
давайте я верну const eval
на const export, здесь обратно верну
const export был из prime
И напишу следующую вещь
Я все удалю
Я напишу
a
bool
b
равно is prime
от
ну, 37
Я хочу понять
Вот эта функция is prime
Вот если я так напишу
bool b равно is prime от 37
Где будет инициализировано?
В какой момент будет вычислено is prime от 37?
В compile-time или в run-time?
Как мне это понять?
Теперь я уже знаю как
Нет, я не могу
спросить
Значит
Ну, seeout из const eval
это, конечно, довольно странно
Ну, вы можете разное значение вернуть
а потом b вывести
В смысле, просто чтобы функция вернула
Так нельзя seeout делать
на этапе
В смысле, return сделать
Ладно, давайте я напишу другую
const export функцию is prime
Почему плохо делать seeout, а вот затем?
Вот, такая функция
где я напишу
if std is
constant
evaluated
то return
true, а иначе false
Господи
Да, вопрос
Это что вы сейчас написали?
Я не уверен, что
Ну, да
У меня просто искажение
потому что я думаю об if const export
и if const export нельзя писать так
Вы же понимаете, что
если писать if const export, то там нельзя
его в тернарный оператор превратить
Я просто мыслю
if в compile-time, поэтому так пишу
Наверное, здесь можно написать просто так
А нельзя написать b равно
std is constant evaluated?
Ну, зачем мы об этом
сделали?
Да, ну, изначально, потому что я хотел проверить
Наверное, да
Наверное, можно и так
Наверное, если мы не исправим делаем, то можно и так
написать
Вот, давайте
теперь выведем b
И это мы можем сделать
То есть, вопрос в том, b
пронициализирована была в compile-time или в run-time?
Ну, кажется, понятно, что сейчас она будет
пронициализирована
в compile-time
Она вообще не проницает в compile-time
Она ничего не вывела?
Или что?
Вывела единицу
Вот, возможно, поэтому
все-таки мне надо было функцию вызывать
Потому что if constant evaluated
возможно, это как раз
штука, которая всегда на этапе компиляции
вычисляется
В смысле, ее истинность или ложность
определяется на этапе компиляции
Я вызвал const export функцию,
которая обертана в if constant evaluated
Получил то же самое?
Да
Можете, конечно, как-нибудь еще
пооборачиваться
Если не const export
Ну, все, на этапе компиляции
Хорошо, давайте
попробуем по-другому
Давайте я попробую сделать статическую
статический bool b
Да, то же самое
Подожди, Илья, вот если
мне написать cout if constant evaluated
то оно выйдет 0
Да
Ну это логично
Потому что cout может происходить
только в runtime
Нет, ну и до этого у нас был пример
когда мы делали cout какой-то
какой-то он сдавал штуки
и оно корректно работало, потому что
он в compile-time уже считал значение
а в runtime уже просто
выводил значение
Ну, ребят, вы понимаете
из
он, грубо говоря
проверяет, типа statement
выполняется в такой момент
Так в чем проблема выполнить statement раньше?
Потому что
он всегда выполняет в compile-time
Подожди, Никита, если из constant evaluated
всегда будет выполняться
в compile-time, то он просто вместо него
везде и нет
Это бессмысленно
Да, это странно, потому что мне казалось, что
для
не константных
не constexpr
даже не константных переменных
это должно происходить в runtime
Возможно, дело в том, что я тип неправильный
Возможно, если бы я сделал string
Ну, если бы я хотя бы double сделал
Давайте попробую сделать double
Вот, я сейчас сверну double отсюда
Возможно, double не так сработает
Потому что, возможно, целочисленный он
Господи
Наоборот, здесь 1.0, а здесь 0.0
Если сейчас будет 1, то я не знаю
Ладно, я не знаю
Ну хорошо, для string уж точно
это не должно работать
Давайте string проверим
Ну, история
в чем, в чем, что я пытался показать
Я посмотрел, что он
не работает
В чем, в чем, что я пытался показать
Я пытался сказать, что
у меня есть иногда
бывает иногда проблема
Ну, по крайней мере, я думал, что у меня бывает проблема, а как будто бы ее нет
Проблема в том, что
когда вы инициализируете некоторую
статическую переменную
в
и не делаете ее константой
и вы ее инициализируете каким-то
выражением
которое, например, содержит вызов
функции, то вот это выражение
оно в рандайме вычисляется
особенно если оно
не констант экспрешу
не констант экспрешу
да
да
и
да, что-то у меня не удался пример
вообще
грустно, да
ну, значит, надо признать, что я не знаю, как работает константинит
просто и все, я закончу
а нам тоже можно?
да, вам тоже можно, конечно
можно, конечно
не, я не буду вас спрашивать то, что я сам не понял, это очевидно
ну, мало ли
на некоторых предметах, пожалуйста
не, не, я так не делаю
вопрос на уровне 11
объясните, как оно работает
а
ну, может
значит
давайте я вам расскажу, как я это понимаю
возможно, мое понимание неправильное
и
вы можете
потом мне рассказать, как вы это
поняли сами, если
более правильно поймете
проблема в том, что когда вы инициализируете
глобальные или статические
переменные
у вас
вычтение их значений
может происходить
в рантайме
а, ну вот, скажем
вот такой пример
это правда пример актуальный до
C++20
потому что сейчас C++20
и конструктор SdString
тоже стал constexpr
но вот представьте, что у вас есть какая-то глобальная константа
возможно, это все в C++20
просто само стало constexpr и все
и проблема исчезла
короче, не знаю
ну, до C++20
была такая проблема, что
если я хочу, например, строку глобальную
инициализировать каким-то значением
то
вычтение этого значения в рантайме
происходит
и вместо того, чтобы зашиться
в динарник
вычтенная компиляция значения
в начале рантайма, перед main
вычисляется это значение
вот
и
мы могли бы написать
constexpr
и тем самым заставить
компилятор
гарантировать нам, что он это инициализирует в compile-time
что нам говорит слово constexpr
перед глобальной переменной
локальной, да, хотя бы, переменной
оно нам говорит, что мы
гарантируем, что
справа стоит constexpr
и что значение этой перемены будет вычислено
в compile-time, что в рантайме
не будет тратиться время на вычтение
того, что справа
вот
у constexpr, правда, есть один недостаток
он обязывает перемену быть
само у const
смысл слова constexpr
в том, чтобы
у нас была такая как constexpr, только без const
короче, const
и need, это constexpr минус const
если совсем короткая формула
а
что такое constexpr
это штука, которая одновременно говорит вам
что выражение справа является
константом выражением
и обязана быть вычислено
в compile-time
в то же время оно делает вашу переменную
константой
и это не всегда удобно, иногда вы хотите, чтобы
даже переменная гарантировала, что она
пронициализируется на этапе компиляции
но при этом сама не была константой, чтобы
ее менять могли
чтобы значение выражения вычислилось в compile-time
и в бинарнике
изначально хранилось значение этой
вычисленное значение
этой переменной, но при этом
ее менять можно было, то есть она
не была константой, вот это вам позволяет
сделать слово const и need
а это обязательно для глобальных
это обязательно для глобальных и статических
что именно?
ну для просто локальных переменных
нельзя так делать?
можно и для локальных, да
вот я к сожалению
не могу воспроизвести, почему-то все в compile-time
инициализируется
и я что-то как-то не знаю
он вас боится?
может он просто еще и компилятор вложает
это тоже возможно, но мне кажется
нет
а в каком случае мы можем
сделать глобальных переменных?
Илья, у тебя есть примеры
когда тебе
а можно синтаксис хотя бы?
как это называть?
нет, у меня к сожалению нет рабочего примера
поэтому я не знаю, что вам показать здесь
могу только слова сказать
просто синтаксис, напишите const и need
я пишу точно так же
const и need, как const export, только const и need
у меня вообще не подсветит
я думал const и need этот набор
const и need std string
не знаю, str равно
std string
равно, я не знаю, abc
вот, эта штука делает
мою строку
она обязывает правую часть быть
константным выражением, но при этом сама строка
константной не становится
вот
ха-ха-ха, нет
я дурак, я неправильно сказал
const и need мне не надо локальных перемен
ну значит я совсем не знаю, что такое const и need
забьем на это
до этого я и не тоже
собирался туда добавлять
вот, это я вам просто рассказываю фичи
которые недавно появились, но я в них еще сам не до конца
разобрался
но через 5 лет все изменится
конечно, и это обязательно будет
const и need, end, sin, end
мне кажется
больше я вам ничего не хочу
рассказать про вот это, про const export
вот
сейчас мы с вами
может быть сейчас уместно сделать перерыв
у нас как раз почти пара закончилась
вот, а на второй части
мы наконец-то с вами
начнется часть 18
это пока не была часть 18+,
это была нормальная еще часть
это были достаточно полезные
фичи
вот, сейчас на второй паре
начнется часть 18+, и
мы с вами напишем мета-контейнер
ну, точнее мы напишем
прототип мета-контейнера
typelist
вот
а сам его целиком
вы напишете, возможно
дома
вы заставляете нас заниматься 18+, вещами
конечно
короче, вы поняли, что
все мы пока плохо
знаем C++20, включая меня
тем не менее, мы сейчас
попробуем
написать нечто
нечто 18+.
давайте
для начала я вам покажу одну
забавную штуку, которую
я еще давным-давно
на лекциях показывал
еще до того, как
вышел C++20
чтобы вы
немножко морально подготовились
смотрите
что нам
позволяет делать шаблонные метапрограмми...
ну, мы до этого с вами
занимались
шаблонным метапрограммировать
C++ только что смог это
сделать
вот почему-то у нас
на trunk GCC
не получалось
GCC 12
и может
12.2 работает
от ранга ты сейчас 13.1 кажется
возможно они что-то сломали
возможно
возможно на 12 работает
а на 13 снова нет
12.2 у меня все еще не работает
так, давайте
я покажу то, что собирался
короче
теперь мы с вами
что такое constexpr
и это открывает нам
больше возможностей для
развлечений
для разного метапрограммирования
вот, и то, что я вам сейчас покажу
это
вещь, которая
еще
в C++14 работала
это
метафункция
для определения того
сколько полей в структуре
чего?
как пункт называется
как пункт называется
давайте
16.5
только что-нибудь смешное
1 C++
5 stretch functions
ну
давайте я
это назову
сейчас я придумаю как это назвать
да, давайте так
и назову
сейчас я вам расскажу, что такое reflection
кто из вас пишет на джабе?
ваша задача
я когда-то писал
значит
reflection это на самом деле еще
такая общепрограммистский термин
как лямбда функции
возможно, как шаблоны
reflection это такая
штука, которой на самом деле SuperFuse до сих пор отсутствует
это возможность из кода
задавать вопросы о нем
в джабе это есть
например, вы можете спросить
правда ли я сейчас
нахожусь в
методе
который называется так-то
или правда ли там
этот класс обладает полем, который называется так
правда ли у этого класса
в котором я сейчас
столько-то полей
вот это то, что называется reflection
в джабе это есть
поддержка в языке
в C++ пока этого нет
и там все время идут разговоры о том, чтобы такую поддержку
добавить вот-вот
то ли в 23-х, то ли в 26-х
это было еще разничественное усилие
тем не менее, я вам сейчас покажу
великолепнейшее изобретение
штаб-авторства этого кода
придумал это
человек, которого зовут Антон Полухин
он является
членом
комитета к санкционизации от России
и придумал это еще много лет назад
в общем, это пример того
как с помощью шамлона программирования
можно реализовывать уже сейчас
уже тогда можно было
некоторые
рефлексивные штуки, например
узнать сколько полей в структуре
вот смотрите, вот у меня есть структура
давайте
у меня будет структура S, в которой
два поля
и будет структура SS
в которой
в которой будет три поля
я сейчас проверю, что у первой структуры
два поля, а у второй три
как мне этим пользоваться
ну, мне надо
вызвать
STDCOUT
Detect
ну, на самом деле это в Conspect Store
можно сделать
давайте я STDCOUT
сделаю
DetectFieldScout
с шаблонным параметром A
тут еще есть некоторые шаблонные параметры
которые
которые
передать количество полей
кажется
могут мне
я могу вот так сделать
чтобы мы индексикум
отставили
вот
и это должно быть равно
сейчас я объясню, что такое индексиканс
я просто пока пример показываю
да
что?
да
надо в
sizeT записать результат
так, мне очень удобно эта функция устроена
ну, хорошо
а, виноват
с шаблонным параметром
мне же не нужно передавать это
я же могу передать просто вот сюда
индексиканс отстав
все, так, давайте проверим
и STDCOUTX
что?
он посудеет?
как еще так сделать?
ну, давайте проверим
так, DetectFieldScout
на самом деле
не важно какой
DetectFieldScout
а
нужно include
ну, хотя бы у стрима будет нормально
и, видимо, еще include
какой-нибудь
type traits
кажется, понадобится CSTDD
чтобы CSTDD был
making the sequence is not a number of STD
хорошо
making the sequence
это штука, которая объявлена
в утилите
что такое
индексиканс?
это такой класс, который представляет
всякую таймпоследовательность чисел
индексиканс
это просто класс, у которого
шаблонные аргументы
ладно, давайте я вам покажу
его
что такое индексиканс?
это
класс, у которого
просто есть
переменное число
шаблонных аргументов
интов
но есть шаблонный класс integer sequence
который первый шаблонный параметр
имеет t, а дальше
значит
переменное количество
типа в t
как
числовые шаблонные параметры
у него есть специализация для int
которая называется
индексиканс
индексиканс это пустой
класс, у него просто пустое тело
в котором
у него есть параметр size, который
возвращает сайзов
количество этих чисел в последовательности
класс тривиальный
просто это compile-time
понятно?
вот, и есть
функция makeIndexSequence
которая просто генерирует по
числу n последовательность
0, 1, 2 и т.д. и минус 1
вот
что я здесь делаю
я вот говорю
вызываю на тегфилдс каунт
с шаблонным параметром
умываю структура
от x запятая std makeIndexSequence
от 100, давайте проверим еще раз
так
а, ну потому что мы с имп пытаемся передать
туда посылки, а сайз ты ожидает
а, да, нужно сайз ты
хорошо, давайте еще раз проверим
ого
ну вот здесь
сайз ты не делал
почему ты 98?
что?
почему
почему на 98 микс
тихо?
мне кажется, что у нас
нет тут
перегрузки
мне кажется, нам не хватает
окончания шаблонной рекурсии
потому что то, что здесь происходит, это просто
бесконечная шаблонная рекурсия
давайте я попробую объяснить, как это работает
сейчас мы
вспомним, как это работает
ну или поймем заново, кто это в первый раз видит
и поймем, чего не хватает, чтобы это правильно работало
что называется функция detectFieldScout
которая первым аргументом принимает x, а вторым
аргументом принимает makeIndexSequence
makeIndexSequence это значит
std makeIndexSequence от навора чисел
вопрос
в какую функцию мы попадаем? в первую или во вторую?
в первом делу
ну, дело в том, что
одна из них более предпочтительна, другая менее предпочтительна
какая более предпочтительна?
первая
а
какая из них более предпочтительна?
ну в первой
у нас уже ясно первая база
а вторая
значит
предпочтительна первая
makeIndexSequence делает от 1 до 100
от 0 до 99
от 0 до 98
откуда мы число 100 вообще взяли?
от балды
сейчас
я расскажу, как это работает
это видимо максимально коллибситва
ну, я просто написал 100
я считаю, что
больше 100 балет точно не будет, поэтому
написал 100
в любом случае можно пихнуть туда
sizeOfA
можно побольше написать
послушайте, пожалуйста,
как это работает
DetectFieldsCount
вот эта версия предпочтительней
потому что
она более частная, чем эта
почему она более частная версия, чем эта?
потому что
это принимает Т
и какие угодно шумовые аргументы
а это принимает Т, число
и какие угодно шумовые аргументы
первая версия более частная, чем вторая
значит, мы идем в нее, и тут срабатывает стена E
каким образом оно срабатывает?
оно
это функция
она constexpr
и тип этот
это дегалтайк вот такого экспрешена
что такое убик?
а, я не написал, что такое убик конструктор
все понятно
я не написал
нет, не написал, что такое убик конструктор
нет, не написал, что такое убик конструктор
а
скрипастил код не целиком
ну, давайте напишем
template, typename, T
значит
что мне нужно?
ну, я просто напишу using
убик конструктор
это будет штука, которая
просто
создает template sizeT
и sizeTindex
using
конструктор
равно
убик
что значит убик?
убик, а слово убик пишется
вездесущий
все влащающий
убик, сейчас давайте поймем,
чему здесь надо сделать
по-моему, вот так надо сделать
а, нет, просто вот так
давайте еще раз
да, смотрите
пока не компилируется, но сейчас мы это исправим
что здесь написано?
здесь я пытаюсь под деплтайпом создать
T от вот таких аргументов
вот это агрегатная инициализация
я делаю агрегатную инициализацию T
от
некоторого набора
аргументов
убик это штука, которая умеет
каститься к любому вообще типу
это такая структура
ну, вот такое название
если я даю Антону Полухину, значит убик
вездесущий
штука, которая определенна для произвольного
T каста к темперсанду
что здесь написано дальше?
дальше я написал шаблонный
класс
шаблонный юзинг убик конструктор
который для всех
для любого индекса это просто убик
без каких-либо параметров
теперь я
вот здесь вот создаю
такую распаковку
я говорю
T создаю я
от набора убик конструктора
и ноль без параметров
запитаю убик конструктор
от и без параметров многоточия
то есть я как бы создаю
много штук
убик
вот столько сколько их было в пакете
и вызываю агрегатную инициализацию
T от этого
убик это тип, у которого есть каст к любому типу
это значит
что какие бы ни были
типы полей T, если T это структура
допускающая агрегатную инициализацию
если я угадал число полей, то это
корректная инициализация
но я вызвался make integer sequence
от 100
и это означает
что здесь я попытался инициализировать T
сотней таких штук
убик конструктор, каждый из которых кастится к любому типу
но это как бы
некорректная инициализация
потому что
полей я пытаюсь инициализировать больше
чем их там есть на самом деле
поэтому по SFINAE вот эта версия
отваливается и я иду в менее
предпочтительную версию
что делает менее предпочтительная версия
она делает
все то же самое, просто
make index sequence передает от меньшего числа
аргументов
соответственно, впервые
в момент, когда я передам правильное
число полей
вот эта штука
наконец-то будет
корректным выражением, потому что я здесь
пронициализирую T ровно от такого количества
штуковин как можно
это получается
количество полей в T
как будто количество
полей конструктора
нет, это агрегатная инициализация
я инициализирую
каждое поле чем-то
а если в структурке у нас
первые точки написаны private
или какие-то кастомные конструкторы
то кажется у нас уже не работает
это правда, это работает только для структур
напускающих агрегатную инициализацию
я сделал
конечно
многообещающее заявление
но это не совсем так
это работает только для структуры
напускающих агрегатную инициализацию
давайте поймем почему это не работает
вот это
а
returning to non-void
returning to non-void
а
а вот и не умеет код упасть
а сейчас
ну видите
а мы написали стрелочку decal type ot
да, я написал стрелочку decal type ot
давайте я здесь добавлю
запятая void
запятая
throw 1
что?
ну throw type void
все
подождите
ну я должен был
ну как, comma 3
я должен после запятой написать выражение
того типа, который я хочу чтобы был возвращен
void круглые скобки, нельзя там
void нельзя конструировать
это не отчего
throw это выражение
типа которого void
если вы напишете decal type от throw 1
звездочка, то у вас будет вот звездочка
а почему не просто
вот давайте проверим, что
выбилось 2
вот это не плохо, сейчас было
о, все, два поля
а кстати, бить сайзов
чего-чего?
а бить сайзов же даже в общем случае не работает
сайзов?
в качестве вот вместо
ну да, там могут быть какие-нибудь полезные
на 8
в смысле
сколько угодно блогов болеете
пустых структур
плаков и микодрес
ну да
вот, а теперь 3, понятно?
мы научились определять количество полезных структур
ну может отсутствие
адреса, отсутствие наследования
вот
ну как, нормально?
а кстати, как это работает с наследованием?
никак
значит, это работает для тех
и только тех структур, которые допускают вреда к вентилизации
все
какие структуры я допускаю, мы обсуждали в 1-м месяце в октябре
ну, это
все, давайте закончим на этом
значит, это пример того
какие прикольные штуки можно делать
с помощью, значит
SFINAE с использованием
constexpr и
метапродагмических штуков
кстати, как будто бы
constexpr здесь и не нужно
но тот факт, что
это constexpr позволяет нам
ну, результат этой функции используется
в constexpr функция, правда же
если я хочу в compile-time понять
сколько у меня полезных структур
в зависимости от того, что я что-то сделал
ну представьте, я и пишу в constexpr функцию
в которой делаю вот это
и дальше if
в зависимости от того, чему равно x
что-то продолжается
на самом деле, это что-то круче будет, если сделать
что-то, которое перебирает вот этот вот
типа
сколько мы
каковый размер у нас interger sequence, пока у нас ответ
не окажется меньше, чем поданный размер
ну, да, наверное, можно
вот, ладно
давайте, наконец, напишем tightlist
Илья, какая ситуация
это вообще может определиться?
вопрос снимается
не снимается и снимается
ну, я не знаю
ну, может
вот приходишь ты на
собеседование, тебе скажут
что у нас есть структура
ты говоришь
сейчас напишу
так
тебе вдруг
собеседование
тебе говорят
я тебе не пустил
напоследок
мы с вами
позанимаемся так называемым
value-based metaprogramming
ну, по сути, предыдущее, что
я вам показал, это уже и было, но
что такое
value-based metaprogramming
это когда мы делаем
метапрограммирование не за счет шаблонной рекурсии
а за счет использования консистенции функций
вот
до того, как
мы изучили консистенцию функций
мы могли бы с вами делать шаблонное метапрограммирование
ну
мы могли бы, типа, сказать, что у нас есть
структура
type-list
у которой переменная числа шаблонных аргументов
и она в себе содержит
голову и еще
type-list отменьшила числа шаблонных аргументов
вот
делать с помощью шаблонной рекурсии
подобные штуки, то есть
метаконтейнеры, хранящие типы
и это довольно неудобно
и главное это неэффективно, потому что
компилятору генерировать
много типов
и вообще разворачивать шаблонную рекурсию
это медленно
быстрее ему создавать
объекты типов
которые
сами по себе
типы это пустые структуры
ну вот я вам сейчас
давайте я покажу вам
type-list
как он был
написан
нет, тоже плохой type-list
в смысле
тоже хороший type-list
а плохой type-list
у меня был написан
ладно, я забыл, он был написан
не могу вам его показывать
а можно код там пролистать один раз
я вам сразу покажу хороший type-list
нет, то что там было написано я сейчас задно напишу
вот
я вам просто покажу
не буду показывать плохой type-list, сразу покажу хороший
то есть смотрите еще раз, идея в чем
я хочу написать мне
класс, который будет основан
на шаблонной рекурсии
а я хочу написать
такой вот класс
у которого будет на самом деле пустое тело
и пользоваться мы им будем так
мы будем просто
объекты этого класса создавать
по умолчанию
ну
например давайте напишем
функцию size для такого
type-листа
и мы будем писать функции для него
как внешние функции
то есть вот я пишу
template, например
type-name многоточие types
а
constexpr
size
size
от type-list
от types
многоточие
и я возвращаю
size of
многоточие
от types
вот
соответственно в main я могу делать
разные статикасерты, например какие
я могу сказать
статикасерп
size
от type-list
int
double char
по умолчанию
равно равно 3
то есть
моя семантика будет такой
я не буду делать шаблонную рекурсию
я буду использовать
constexpr функции
что-то говорить про вот этот пакет типов
но не буду создавать вот это вот
голову, хвост
откусывать там что-то
вот это мне не нравится
сейчас мы оптимизируем фактически
время
да
я именно на этом занимаюсь
я утверждаю, что это будет гораздо быстрее
чем делать
через шаблонную рекурсию
так сказать
оптимизируем
мы хотим написать метаконтейнер
как вектор
только для типов
у нас есть последовательность типов
что такое type-list
это такая сущность, которая хранит
последовательность типов
в эту последовательность типов
мы хотим уметь делать
что мы с вектором умеем делать
и чуть больше
например pushback, popback, pushfront, popfront
pushback по индексу
какой тип на таком-то месте
reverse
sort
find
filter, sort
stable sort
и так далее
я вам сегодня покажу sort
кстати
все эти
апокемы наши сегодняшние
здесь будет quick sort
для набора типов
вопрос
как вы сравниваете
так тихо
это мы пока вопросы
и вопроса ставим
типа можно по-разному сравнить
например у кого сайзеров больше
можно
по-разному
давайте начнем
с чего-нибудь простого
давайте напишем
самое простое, что можно написать для такого
метаконтейнера
popfront и pushfront
ну сайзер написали
давайте напишем popfront и pushfront
а
я хочу чтобы у меня была функция
popfront
которая работает так
вот например если я
сделаю popfront
от
чтобы в compile-time
проверять корректность
я хочу проверить, что popfront от
такого type-листа
это
вот такой type-лист
мне надо сначала написать
оператор равно для type-листов
сейчас
у нас сайз
точно правильно
написан
я проверил, я это скомпинировал
и скомпинировал
а что
не понятно
как он складывается
сайтов многоточия это
оператор
он проверяет количество типов в пакете
смотрите
мне хочется сначала
заиметь оператор равно равно для type-листов
он будет просто
вдавать true
если типы type-листов совпадают
и false иначе
конечно
constexpr был оператор равно равно
для двух type-листов
как мне написать равно равно для type-листов
кто понимает
что здесь надо написать
нет
здесь надо написать return false
а еще надо сделать вот такую перегрузку
это уже скатывается
как обычно
в смысле скатывается
я не делаю шаблонную рекурсию
идея как раз
то что ты сказал
это как раз плохое метапрограммирование
я вынужден был бы делать шаблонную рекурсию
я не хочу делать шаблонную рекурсию
я хочу чтобы вот
все в одну строчку работало
а у нас же кажется
точно так что сработает там
условный
я не хочу заставлять
вот этот оператор равно равно
работает за линейное время
если бы я делал шаблонную рекурсию
откусывая по куску
это бы работало за квадрат
потому что комператору по ходу дела
пришлось бы создать n type-листов
для каждого с откушенным типом
можно же
такую же штуку сделать
но только сделав
проверить что одинаковый сайз
и дальше false expression
из сейм
из сейм
из сейм
а если
разные сайзы
то у тебя false expression как сработает
я сказал сначала
size of
size of разный
и turn false
а иначе
иначе false expression
и сейм
а как ты параллельно
выжим
не очень понятно
а если у них
ну короче я не знаю
наверное можно
но я убеждаю что так тоже
вот я
теперь еще напишу оператор не равно
который будет просто отрицать
равность
а его компилятор за нас не напишет?
размечтался
тут мне надо будет все таки
вот так сделать
ну вот
я хочу
когда я умею сравнивать
тайплисты на равенство
то есть я говорю что один тайплист как равен другому
если
и только если
у них последовательности типов совпадают
m
теперь я могу
захотеть
написать поп-фронт
что такое поп-фронт
если я из тайплиста один дабл чар
то должен получиться тайплист дабл чар
поп-фронт
ну и push-фронт
push-фронт
это что если я
к тайплисту дабл чар сделаю
push-фронт
получится тайплист int-дабл чар
push-фронт только еще нужно сказать
какой тип
так давайте с push-фронт потом разберемся
как мы типом будем указывать
сначала поп-фронт
как написать поп-фронт кто понимает
во-первых специализация пистолы
что надо написать
мы хотим делать
head tail
понимать тайплист head tail
да нам здесь потребуется
head tail
это правда
constexpr auto я не хочу повторять
тип того что вернется
constexpr auto
поп-фронт от
тайплист head
tail
многоточие
что мне надо вернуть
не надо вернуть до
tail
многоточие
да очень просто
вот так реализовывается
да
так реализовывается
я думаю что последний знач проще
я не знаю
вам надо будет вверх что-то написать
проще чем дэк
дэк
а дальше давайте
push-фронт как будет выглядеть
как будет выглядеть push-фронт
или я
а если пустой
ну сами разберитесь с этим случаем
я не буду
ну тип
поставьте кассет пол
тут все идеи что мы хотим
да
поскольку
это все бессмысленно в рентайме
то логично что мы хотим
ци
поп-фронт от пустого нам даст ци
да потому что у нас нет специфика
у нас нет хэда
возможно мы хотим ци с более смысленным сообщением
возможно
у нас специализация перегрузки этой функции
которая ставит кассет фолс и текст
которая ставит кассет какой-нибудь
я не знаю
хорошо как push-фронт теперь работает
ну push-фронт мы должны добавить еще
один шамлонный аргумент
ну понимаешь
я понимаю
видишь он мне тоже не нравится
да
да здесь уже хэда тейл кажется
не нужен
ну только его не хэд
надо называть
здесь просто т
а здесь тайпс
мы получаем тайплист от типов
и возвращаем тайплист
от т и от тех самых типов
как нам пользоваться push-фронтом
мы пишем push-фронт
с каким-то шамлоном
параметром
логично
от тайплиста
и получаем тайплист
от вот этих трех типов
правильно
запускать бессмысленно
идем дальше
что мы еще хотим написать
pop-back push-back
давайте pop-back и push-back я оставлю
на самостоятельное упражнение
одну из них
написать легко
а второе нелегко
вот pop-back написать
да push-back написать легко
а pop-back пока непонятно написать
да вроде что
потому что
в чем проблема написать pop-back
потому что
по pop-back мне придется
принять тайплист от тайпс многоточия
запятая т
чтобы потом откусить его с конца
но так у типов не работает
я не могу после пакета через запятую
еще т написать
он не выведет тогда пакет
т запятая тайпс он может вывести
а вот тайпс многоточие
он не выведет
а какой оператор равно передал?
реверс
у нас пока нет реверс
как вы оператор равно передали?
это не очень легко
оператор равно я не передавал
пакет
я не
где это здесь видишь?
два пакета
да он однозначно понимает
что является собой каждый из пакетов
потому что первый пакет
который в первом тайплисте
второй пакет в том списке
таким образом он понимает
чем является каждый из этих пакетов
ему не приходится
брать пакет
и в конце
из пакета выкусывать с конца тип
он понимает что у него первый пакет
и второй пакет
так дедакшн сделал сначала
тут все что он делает это тайп дедакшн
называется процесс догадывания
какие именно типы верены
о чем проблема сделать реверс
у нас есть поп фронт и push back
значит мы можем сделать реверс
да можем сделать реверс
но эффективно сделать надо
можно как нибудь разделяйкой
поп фронт
push pop фронт
push back сделать
пока он не опустит
сколько это будет времени работать?
если разделяйкой
и реверс сделать
тебе придется создать
кучу тейп листов
для всех последних листов
я умею создавать кучу тейп листов
и за квадрат делать сразу
поп фронт и push back
так господа
давайте напишем что нибудь еще
я буду идти
в том порядке в котором
в итоге push back и pop back
за линию?
да
он так и будет работать
pop back
ну push back мы и так можем
за линию сделать
а pop back
ну за квадрат
это очевидно
вообще звучит как будто
pop back проще сделать через рейс
по индексу и все
по дурацки
за квадрат
мне кажется что
push back у нас
все равно будет за квадрат в итоге
а в стандаче его нет
тейп листа
в эсстрель нет
какая жалость
есть густия правда
подождите
так давайте дальше
пока давайте дальше
это значит отклоняемся от курса
давайте в прочей некого идут
нет, сначала мы напишем
идея для квадрата C++
звучать густой
сейчас я скажу что мы сначала напишем
сначала мы напишем find
по значению
по типу то бишь
сначала мы напишем такое
я хочу
в тейп листе за линию
уметь проверять присутствует
на самом деле
это достаточно полезная штука
вот вы спрашивали
где это надо
вот я лично с этим
сталкивался в продакшене
у вас есть последовательность типов
есть ли в ней такой то
но хочется это сделать не через шамлонную
рекурсию, понятно что это можно сделать
шамлонной рекурсией
хочется это сделать не создавая
промежуточных
квадрат типов
можно это сделать и не за квадрат
да, можно это сделать
fold expression
давайте попробуем
я пишу
я хочу проверить есть ли
в списке типов данный тип
например я пишу
static assert
find
даже не так
я хочу индекс его вывести
я хочу не просто узнать где он
а назвать его индекс
либо если его нет, то
find
от int
type list
от int double char
равно 0
find double int double char
равно
1
find char double char
равно 0
и find
и find
и давайте да
find
find
void
type list
double char
теперь он точно
вот, хотим чтобы это за линию
работало, а не за квадрат, как если
мы делали через шамлонную рекурсию, как же
этого добиться
это чуть менее, просто проверить
наличие это тривиально
а проверить наличие как?
и same
и same fold expression
а можно какой-нибудь хитрый
и same fold expression
давайте пинплоиском проверять наличие
а мы можем сделать какой-нибудь
пинплоиск как зализать?
откуда?
проверяем что есть в квасте длины половины
потом разделяемся
а нет, стоп
это за линию суммары
звучит конечно круто, но как
ну как половину найти
да, как найти половину
это отличный вопрос, как найти середину
ты пил в рандомный элемент
вероятно
а как пил в рандомный элемент, у нас пока нет обращения
а есть констэкспор
рандомный
нет
скорее интересно, есть ли констэкспор
какой-нибудь минимум
можем ли мы какой-нибудь хитрый
fold expression с логикой
написать
так, смотрите, нам надо создать
мы хотим сделать
некоторые fold expression, это правда
который бы
работал просто и притерми
для каждого элемента
нет, который бы просто для каждого элемента
хорошо, если бы нам надо было
просто проверить есть ли идти
ну мы бы просто сказали
isSameV по всем t
сделали бы fold expression и его сделали
сейчас, я не умею это сделать
так, мы хотим
длинное выражение
плюс isSameV умножить на 10
плюс isSameV умножить на 10
типа так, количество нулей в числе
это есть на наш индекс
но
здесь небольшая проблема
я не буду
говорить, что это немножечко
странная идея, потому что все идеи
будут странные
есть просто проблема, что мы не можем достаточно
большие typelist это можно поддерживать
да, проблема в том, что
довольно быстро
довольно быстро typelist
во-первых, почему на 10?
на 2?
да, частичная система
счастления
потому что так мы всегда
так ты поймешь, на каком месте он стоял
можно так?
так нам нужно понять, на каком месте он стоял
смотрите, что
я что предлагаю
смотрите, какая идея, давайте попробуем
завести
что мы можем в концентрации сделать?
вот такой вопрос
смотрите, мы можем, разворачивая
вот этот folder expression, вот что делать
у нас будет какой-то булливый флаг
и мы
ну просто если мы встретим
true, то мы этот флаг переключим
каждый раз мы будем на этот флаг домножать
то есть мы будем прибавлять
и умноженное на флаг, и в какой-то момент
флаг станет нулем
и умноженное на
флаг это плохо
нет
ну в смысле
мы же можем вот с запятой несколько штук написать
типа одна штука будет
да, ладно, давайте я
вам напишу просто, что
предлагается сделать
мы можем, давайте я вам скажу
одно слово, массивы, мы можем
заводить массивы
о господи
давайте заведем массив
который
который будет устроен так
вот
значит это будет массив размера
сайза от многоточия types
ну а теперь
надо просто пройти
по массиву и найти в нем
первая true
прекрасно
а это же мы можем уже
просто
не первая true
можно просто
фориком написать
ну можно просто фориком написать
ну на самом деле, начиная с
SuperTools 20, у нас есть STD
да
то есть получается таким образом
мы можем в массив запихать любую функцию
от этих типов и уже работать
с результатом этой функции
нет, это шикарно вообще
минус B очередь
так
мне нужно сказать
return
вот это
да, все будет работать
вот, что вернет STD
если там не было true
ну он вернет кажется
конец
мы разный сетератор
таким образом получим
у нас есть проблема в том, что это вроде как
тип будет не с ICT конечно
ну да это остановить надо
проверим
нет, все работает
давайте я на следующий случай
проверю, что если я здесь что-нибудь
поменяю, то не будет работать
а то вдруг я что-нибудь неправильно
не, вот статик
так что именно так как мы хотим
это и работает
отлично
следующее
что я хочу научиться делать
давайте научимся
делать алгоритмы
с предикатами
find if
смотрите
я могу искать не тип
а какое-то свойство
например
у меня будет
такая штука
ну нужно передать
лямбу как параметр
не-не-не
это шаблон надо передать
вот, смотрите
я говорю
хочу уметь искать
в наборе типов
по свойству типа
у меня есть метафункция из pointer
которая говорит мне что-то про тип
и я хочу
чтобы в списке типов она находила
первый тип, являющийся pointer
видимо мы хотим просто сделать
буквально
добавить туда что
мы хотим туда
template еще раз принять
шаблонный параметр
что нам надо тогда сделать
что принять надо
объект этой функции
нет, неправильно
как мы в этот объект функции передадим тип
нет, мы хотим сделать именно метафункцию
то есть шаблон
мы хотим передать в качестве шаблонного параметра метафункцию
ну и шаблон
что мы должны написать
template
template
type name
type name
что
стоп
что
что вас удивляет, в первом семестре мы проходили вообще
в первом семестре
по-моему мы говорили
тогда не было нифига понятно
что сейчас нифига не понятно
по-моему только с 17 плюсов
шаблонные аргументы
являющиеся шаблонами были еще до 7 плюс плюс 11
именно с type name
там же до 17
мы обязаны были писать вот здесь класс
а в чем это?
ну вот такой вот костынь
а вообще
существует ли сейчас
где-то разница
между тем чтобы написать type name и класс
шаблонных type name и класс эквивалентны полностью
так
мы передаем в качестве шаблонного параметра
шаблон
почему шаблон?
потому что
изпойнтер это шаблон
быть пойнтером
это шаблонный
класс
стд изпойнтер это шаблонная структура
у которой
шаблонным аргумент является
вот
значит
я могу передать в качестве шаблонного
аргумента шаблон
и
что я теперь должен проверить?
я должен вот здесь
но я должен то же самое сделать
просто вместо и same way написать что?
f
f от
f с шаблонным параметром
types
вточие
вл
и многоточие
правда?
таким образом
я получу true
когда тип из пакета соответственно
был пойнтером
а вот в каком случае
вообще нам может быть интересно
какие такие штуки
вы хотите опять спросить
где это применяется?
я не понимаю
я запишу
я запишу
я баню вопрос
где это применяется
до конца
я чувствую
нет, если это густее
можно через час
я тебе еще и победу
окей, давайте теперь напишем
обращение по индексу
какой смысл несется в фразе
я хочу
получать
каким образом мы хотим его получать?
да, это отличный вопрос
что значит получить тип?
да
у меня будет функция
давайте я назову ее
get
которая будет по индексу
например 1 от type list
type list
int double
char
мне возвращать
что?
вот что такое
может быть это
должен быть using
а может быть этот get
должен быть using
что должен возвращать get?
если мы продолжаем
такой же темантикой
как я пользоваться
что?
у нас на самом деле уже есть
как называется?
type identity
type identity
уже есть класс
который представляет собой
одиночный тип
это type identity
от double
нет
я просто сейчас
напишу оператор равно
для type identity
я, кстати, не уверен
может быть их и можно сравнивать
давайте проверим
но сначала
на get написать
я думаю, что
оператор равно
для них не определен
а
ну get не определен
давайте сначала get
с оператором равно
все понятно
я хочу
написать get
за линию
без шансов
без шансов
без шансов
без шаблонной кути
get
задний
да
все так
можем
создать объект
type identity, кажется можем?
да
Возьмем type-list из объектов type-addentive и возьмем у него id.idx
type-list делать не из объектов, а из типов
Кстати, а блин, нет
У меня здесь будет первым шаблонным аргументом size-t
и возвращаться будет std type-auto
Будет get и type-list от типов
Здесь нам вернут нечто
А почему тюркс массивно сработает?
Потому что мы его сейчас реализовываем
Как? Ну что написать надо?
Ну то же самое, что...
Что значит то же самое? Bool, B, квадратная сеть
Ну что дальше?
А, сейчас
Ну один
Сейчас
Ну понятно, что мы можем сделать get путем шаблонной рекурсии
Нам нужен какой-то type-list, который будет содержать в себе
Так, ладно
А мы можем?
Сейчас у нас же был какой-то std condition
Мы знаем, что у нас два степеней
плюс два степеней минус один, плюс два степеней минус два и так далее
это два степеней плюс один
Сейчас Илья не знает, как сделать
У нас же был этот std conditional
если начали true
и сделать full expression std conditional от index минус минус
и там times by times
Сейчас, аж стол
А какой буль ты в него передашь?
И индекс минус минус, когда он отойдет до нуля
В смысле, больше ли он нуля?
Ну, я не верю, что
Во-первых, это какой-то вложенный
Смотри full expression, ты можешь только для операторов сделать
Да
Вань, там проблема
Ты можешь только для операторов делать full expression
и непонятно, какой оператор ты делаешь
Там проблема еще хуже
Непонятно, куда идти, если он false
Сейчас, а мы не можем сделать какую-нибудь дурацкую вещь
типа через оператор запятую
сделать full expression на оператор запятую
а внутри сделать типа ternarник
на is потом
А, у нас индекса опять нет
Лука, ты точно не предлагаешь, что это станет таланец?
Может быть, после мною что-нибудь?
Ну да
Нет, сейчас
Я не знаю даже, как
Как это написать?
Как подвести к этой мысли
Скажи первое
Я не знаю, как это можно придумать
Плохой начало
Такая себе новость, на самом деле
Давайте я попробую воспроизвести то, что я знаю
Но как это можно было придумать, я не знаю
Значит, мне, наверное, потребуется
Сейчас
Расскажу
Мне, наверное, потребуется
template.typeName
template.sizeToIndex
Вот
И это будет такая штука
constexpr, естественно
В которой будет
О, сейчас
И я могу последнюю идею?
Мы можем создать какой-нибудь тип
У которого будет шаблонный sizeT и другой тип
Сейчас, мне надо посмотреть
И создать метафункцию
Сейчас еще раз шаблонный тип
В чем идее хочется получить массив типов?
Короче, хочется сделать индексированный
Хочется наши типы прииндексировать
Можно сделать параллельную распаковку
двух пакетов индексов и типов
И дальше как бы пройтись по этой штуке
И вернуть тот тип, который соответствует
индексу, номер которого, равен тому, который мы ищем
Да, это рабочая идея
Да, это рабочая идея
Да, это рабочая идея
Да
Да, это рабочая идея
И так получится, но я хочу показать
Совершенно бодибонную идею
Сможешь потом показать эту идею?
Потому что я не понял
Сейчас
Я сейчас
Открою тот файл, который я хочу показывать
Сколько домов с проявленными работами?
Сколько домов с проявленными работами?
В общем так, давайте я могу написать
Идею, которая
Которую
Не знаю, в чем это прокомментировать
У меня будет переменное число шаблонных аргументов
Но принимательно будет
sqd.index.sequence
Я вам не просто так показывал
Я вам не просто так показывал
sqd.index.sequence
Вот
Ой, ой, ой, ой
Что?
Тимплей
Тимплей type name
Мне нужна специализация
Которая не определена
Которую я не буду использовать
В смысле я хочу в github передавать
index.sequence
А зачем нам?
Вот эта пустая
Непонятно, зачем первая?
Потому что это специализация класса
Я не могу специализировать шаблон, пока не объявил общую версию
Я не могу специализировать шаблон, пока не объявил общую версию
Вот, и тут будет у меня такая функция
Которая будет называться darmi
Она будет шаблонной
Она будет шаблонной
Шаблонным параметром t
И возвращать она будет
Три
Ну, не совсем
Ну, короче, я сейчас
Я в свое время, конечно, об этом подумал
Но у меня сейчас вопрос возник
А почему мы все это как функции пишем
А не как методы класса
Я говорил в самом начале
Потому что я хочу, чтобы это было в LBase
А в смысле методы класса?
Ты хочешь, чтобы это были, типа, что?
Методы, чтобы мы писали
TypeList от types.
.finds, .get
Нет, не очень понятно
Может, это просто идеально
Ну, тебе бы приходилось писать
Ну, не точку, а 2.2.2
Чтобы легко создавать
Вот
Ну, кажется, небольшая разница между статическими
.finds
Ну, наверное, можно было бы это методами
Ну, кажется, небольшая разница между статическими методами класса и просто функциями
Ну, просто чтобы это не валялось глобально в namespace
Создай свой namespace
И каждый раз к нему обращаться, когда это получается работать
Не нравится, как вы быстро решаете все проблемы
Так, короче, сейчас я делаю смертельный номер
Это будет, пожалуй, последний смертельный номер
Смотрите, что я сейчас напишу
Успешный смертельный номер, да?
Я надеюсь
Успешный в плане смертельности?
Может, Федю позвать, типа, чтобы он как каскадер
Как тестировщик скорее
Стоп, что происходит?
Так
Чего?
Дальше
Что это такое?
Зато быстро
Зато смертельно
Зато надежно
Я хочу вернуть отсюда typeIdentity
С шаблонным параметром
DecalType
С шаблонным параметром DecalType
А если вас попросить не изучать, объясни, как это работает
На экзамене?
Меня попросить? В смысле, я вам сейчас попробую это объяснить
А на экзамене я уже вас буду сказать
Мы на экзамене тоже тебя попробуем
GetImpal
С шаблонным параметром
std makeIndexSequence
от index
Минус один, наверное
Сейчас
Нет, от index
GetImpal от std makeIndexSequence
от index
От чего?
Чего?
Куда?
От Decal
И сюда мне надо передать
Types многоточие
На lttr
Вот как-то так
Что?
Как-то отопать или запустить?
Подожди, подожди, подожди
Давайте я вам сейчас объясню идею, а потом мы будем отсыпускать
А потом мы это одебажить будем, скорее всего
Ну да, скорее всего я написал что-то неправильно
Например, почему далее двоеточие, если оно не статическое?
А, ну значит нужно статик
Ну сначала хотя бы вообще понять, что происходит
Да, я сейчас попробую объяснить
Смотрите, у меня есть
У меня есть в крайнем случае рабочая версия на стене вкладки
У меня есть, ну я просто хотел вас произвести по памяти
И вот рассказать, как это происходит, если в чем мы введем
У меня есть функция Dummy
которая принимает
Она принимает
Она принимает
некоторое количество параметров
типа void-звездочка
и дальше тип t-звездочка
Смотрите, что такое Dummy?
Это функция, у которой переменны аргументы
обычных аргументов
Причем первые несколько аргументов у нее void-звездочки
А на каком-то месте у нее аргумент t-звездочка
После этого что угодно
Так, сейчас
Чего?
Что здесь происходит? Только здесь многоточие надо
Вот здесь вот надо многоточие, его я забыл точно
Здесь два многоточия
Индисис, это для того как раз чтобы распаковать
У меня индисис
Это пакет чисел
Мне кажется, или мы полчаса назад обсуждали, что после многоточия
Мы не можем написать запятая t
А здесь мы пишем запятая t-звездочка
Это другой пакет
Я не понимаю, да
Здесь индисис конкретный
Потому что он выводит
Чему равен пакет индисис в момент, когда
делает шаблонную постановку в класс
Он заменяет каждый индекс на void-звездочку
И этот индекс превращается в void-звездочку
Смысл этой функции в том, что в ней ровно size of indices
Раз аргумент void-звездочка принимается
И на n-ом месте t-звездочка
Хорошо, и зачем?
А потому что моя функция get
Она возвращает такой тип, какой был бы
Если бы мы вызвали эту функцию
С пакетом makeIndexSequence от индекс
Где в этом пакете ровно столько
Аргументов, в каком месте нас спросили
Какой тип стоит
Эта функция возвращает t, где t
Это тип указателя
Стоящего на n-ом месте
Еще раз, вот я вызвался
Допустим, мне сказали size of indices 3
Я вызвал getImpl
MakeIndexSequence от 3, 0, 1, 2
То есть здесь indices стали
0, 1, 2
И функция dummy превратилась в такую функцию
У нее сигнатура void-звездочка void-звездочка void-звездочка
t-звездочка многоточие
Она три раза принимает void-звездочку
А t там что еще?
И на третьем месте у нее аргумент t-звездочка
Таким образом, когда я вызываюсь
Когда я делаю getImpl от вот такой makeIndexSequence
Здесь индексы забыли
У нас индексы нигде не используют
Я так понимаю, не даем ни в каком виде
Я просто не понимаю
А почему у нас нет функции, которые возвращают n?
Так, вы поняли идею
Кто понял идею?
Я почти понял идею
Идея в том, что я за счет того
Что у меня ровно n индексов
С помощью вот этой консью
Обеспечил себе n раз свой звездочку здесь
И на n месте t звездочку
Таким образом, возвращаемый тип этой штуки
Будет такой, какой стоял на третьем месте
В списке типов
А зачем мне будет звездочку до этого?
Чтобы ты мог скастовать к ней
Я вызываю от type звездочка
Из продублированного n раз
Ну, PTR это нечто
Я мог бы здесь написать decalval
Но только это не работало, потому что decalval я не могу вызывать
Мне нужно вызвать какие-то фейковые параметры
Типа type звездочку
Тип звездочки
Стащится все предыдущие
А вот здесь будет шаблонный аргумент
В точности такой, какой тип стоял
На n катом месте
И он именно и будет возвращаемым типом
И я верну type identity вот с таким типом
Который и был на n месте
Я скину это
Все вообще ничего
Так вы даже посмотрели подсказку
Ваня, я случаю сейчас
У тебя есть вопросы какие-то?
Я даже синтоксически это не понимаю
Просто местами
Я не понимаю откуда у нас в Даме ваше дедакшн
Появился
Откуда мы все его знаем
Здесь написано какие-то комментарии
Вот
Это не считая то, что я не очень понимаю
Какая-то функция должна быть реализована
Type list best
Я не помню уже, чей это type list
Или это пащенный мой type list
Вот хорошая реализация
Мы можем проверить сейчас
Давайте я попробую это скомпилировать
Type list
Как у меня фаза называется?
Тут конечно много чего
Не сработало
А чего не сработало?
Давайте для начала посмотрим
Давайте вообще закомментируем вот это
Посмотрим компилируется ли
Что
Я прекрасно понимаю компилятор
Потому что у меня не подключено
У меня не подключено утилити
Зачем утилити?
Дальше
Type well и mismatch
Кто понимает почему type well и mismatch
Какой type well и mismatch
Некравильный шаблонный аргумент
Потому что здесь должно быть type name t
Я специализирую шаблон не с тем набором шаблонных аргументов
С которым был основной шаблон
Чего?
Я в github передаю один тип
Так нельзя
Шаблон должен быть произвольного типа
А специализация конкретного типа
Нет, я что-то не понял
Нет аргументов для declval
Которые зависят на template параметр
Поэтому declaration declval must be available
Type traits
Наверное еще надо подключить
В крайнем случае я сделаю каст
В крайнем случае можно подключить пиццы
Ладно, давайте я не буду declval здесь использовать
А буду использовать просто каст про звездочки
Не можно просто
Я кладу звездочки, кащу на lptr
Внимание, плохой каст
Стоп, что это же аргумент
Мы так больше раз не можем
Это же объявление функции
Я под decltype все загоняю
Илья, а в чем была проблема declval?
Я не знаю, я не стал разбираться
Expected primary expression
Getimple
Значит у меня закончился getimple
Getimple от std
Makeindex.sequence от index
И это у меня getimple структура такая
2.2.darmie
Вот в таких аргументах
А, потому что непонятно что это type 11
Надо использовать std type 11
Все еще expect primary expression
Так, давайте
Я вот это пытаюсь сейчас проверить
А, меня decltype не закрыли
А, все, понятно, меня decltype не закрыли
Так, что дальше
Find was not declared in bespoke
Почему?
Я же определял файл
А мы его изменили
А я вообще удалил файл, что ли?
Жесть, зачем я так сделал?
Ну ладно
А здесь find was not declared
А зачем удалил файл?
О, все
А можно вы все-таки получите
И давайте проверим, что это работает, конечно
Давайте напишем
оператор равно для typeIdentity
typeNameT, typeNameU
Научусь сравнить typeIdentity
constexpr
bool оператора равно равно
от std typeIdentity
std typeIdentity
std typeIdentity
typeIdentityU
return false
и специализацию
которая возвращает true
У нее будет всего один тип
шаблонный
она принимает typeIdentity
от выхода одинаковых типов
и возвращает true
Давайте проверим, что это компилируется
Теперь я хочу проверить, что...
А, все, это компилируется
Подождите, а как-то раньше компилировалось, что это обычный
Мало закаменичный
Кто закаменичный был?
А, все, так работает получается
Давайте проверю, что это int
Тогда должен упасть
Ну или что это char
Падает
Точно на первом элементе double стоит
Точно будет не работать для кратера равно для typeIdentity
Давайте это я не буду проверять
Может и будет, но я не хочу проверять
Ну что ж, работает, я вас не обманул
Почему это работает за линию, а не за квадрат?
Да потому что makeIndexSequence и indexSequence
Это компайлы рентринские
Они разворачиваются в последовательных чисел
И при этом не генерируются промежуточные
Не делается шаблонной рекурсией
Конечно же makeIndexSequence можно писать самому
Это упражнение на оценку по 5
Но у вас оно получится шаблонной рекурсией
Нет, в смысле makeIndexSequence шаблонной рекурсией написать
Просто надо откусывать по одному
Там будет indexSequence меньше
Но в компайле оно встроено без шаблонной рекурсии
И это работает за линию
Когда у нас есть get, чего мы можем добиться?
Мы можем легко написать reverse
Реверс будет за квадрат
У нас будет reverse без шаблонной рекурсии
Но за квадрат
Реверс как написать?
Просто get по индексу
Вот
Что мы теперь можем сделать?
Ваши задачи TypeList
Будет написать не только это
А еще много разного
Например, разные алгоритмы из ASTL
Перенесенные на TypeList
Какие алгоритмы можно перенести на TypeList?
Count
AllOfAnyOf
ForEach
Отличный алгоритм
У вас есть метафункция
И вы применяете ее к каждому элементу TypeList
Например, forEach is the addPointer от TypeList
Вы получаете TypeList, который на каждый тип навешан Pointer
Снимайте ссылку с каждого элемента TypeList
Я еще подумаю
Какие из этих алгоритмов я вам попрошу
Генереи
Нужно создать TypeList с N раз повторяющимся типом
Но тоже без шаблонной рекурсии
Вот, кстати, почему нет
Есть последовательность секвенсов
Но нет последовательности
Н подряд водозвездочек
Где?
Если бы была функция, как MaxQ,
которая делает N подряд водозвездочек
Это вот она и есть
Generate
В плане, можно ее использовать вместо MakeIndex
И кастить к водозвездочке
Сразу и делать последовательность из N подряд водозвездочек
Она делает не последовательность N подряд водозвездочек,
а TypeList, который содержит N водозвездочек подряд
Что такое последовательность?
Вот она и есть
MakeSequence
Она содержит подряд чисел
Она содержит тип
Тип, в шамоновых параметрах которого последовательность чисел
Да
И мы потом кастуем каждый из этих чисел к водозвездочке
Не кастуем мы к водозвездочке
Мы вызываем вот такую штуку
Индис используется только для того, чтобы пакет остаковывать
А водозвездочка мы за счет комнаты их получаем
Ну короче, Дин, подумай над этим еще
Так, напоследок я вам покажу
Вершину инженерной мысли
А именно, сортировку TypeList
Покажи, пожалуйста, код моего
Какого? Моего? Моего?
Вот
Почему у нас с первым индексом чар?
Это как раз я проверил, что он падает
А, падает, что он не компинируется
Если здесь 2,50, то что?
Итак, вершина инженерной мысли
QuickSort для TypeList
QuickSort для TypeList
Ну я ее не буду писать, я вам покажу ее просто
Если бы я начал ее писать, то было бы удобно
За сколько ZLG?
Значит, QuickSort для TypeList, к сожалению, работает не ZLG, а скорее ZL2
Ну, потому что
Ну, потому что пузырек бы работал за куб
Ну, в смысле, у вас обращение по индексу за линию работает
Как вы сделаете за ZLG что-либо?
Зачем все это работает за квадрат?
Давайте сначала поймем, что вообще такое
Что вообще идея на такое сортировка TypeList
Что такое, например, компаратор для типа
Ну, как мы уже видели
Компаратор это просто
Это просто метафункция
Которая
Ну, вот для примера здесь у меня делается
Сортировка для вот такой структуры
Для краткости
Shorter Than Rising Integral
То есть у меня есть структура и маленькая
Которая принимает шаблоны параметров и большое
Вот, и для двух этих структур определен компаратор
Ну, выше определяя его общая версия
Тут по старинке написано Class
Я могу везде забыть TypeName
Это метафункция, которая для двух типов отвечает
Какой меньше
Ну, например, можно сравнивать типа
Какой сайзов какого меньше
Вот эти структурки сравниваются так
Меньше из них та, у которой число в шаблонном параметре меньше
Понятно?
Ну, и вот мы проверяем, что sort
Вот в такой последовательности
Этот type list вот такой
Ваша задача будет написать stable sort
Ну, то есть множество
Ну, так вот тут написано
В вашем случае параметром sort
Будет являться type list, а не последовательность
Здесь параметром sort является сама последовательность типов
Давайте попробуем понять, что делает sort
Где у нас определен sort?
Sort это просто тип
Который имеет метод result
У quick sort
Вот от этих типов
Осталось понять, что такое quick sort
Что такое quick sort?
Неспециализированный шаблон
Это просто type list
Вот тех аргументов, которые передали
Он называется, видимо, когда мы от пустого
Когда мы не от пустого
То есть когда у нас есть какой-то тип и еще пакет типов
То что такое quick sort?
Это просто partition и trivial join
Что такое join, кстати?
Join это просто
Вот у нас есть оператор плюс для двух type lists
Он берет type list и другой type list
И создает вот такой type list
Ну, конкатинация type lists делается trivial
Что делается не trivial?
Что такое join?
Вот здесь написано, что такое join
Это мы отсортировали левую половинку
Что такое join?
У нас есть partition, который берет тип pivot
Левый набор типов и правый набор типов
И partition вызывается от pivot
И двух type lists
Что такое join?
Это мы сделали конкатинацию левого набора типов и пивота
Значит, самое главное понять
Что вот здесь написано
Здесь написаны какие-то операторы присваивания
У меня здесь написан fold expression
С оператором присваивания
Помните ли вы, как это работает?
Fold expression
У которого есть пакет
А здесь многоточие
А здесь многоточие
И слева еще инициализатор
И вот на этом заканчивается fold expression
То есть он берет type identity
По всем типам, которые мы передали
Quick sort от всех типов
И делает присваивание
По очереди
Partition одного type identity
Другого type identity
Вот partition присваивается сначала один type identity
Потом следующий, потом следующий и так далее
Что делает оператор присваивания
У которого левый аргумент partition
А правый аргумент type identity
А вот что он делает
Тут написано requires
Если
Тот тип, который нам передали
Аргументом меньше, чем наш
То мы попадаем в эту версию, а иначе в эту
Значит, если нам делает присваивание
Вот у нас есть partition, это штука
Которая уже себе какие-то типы выбрала
Значит, мы
Если нам сейчас присваивает какой-то новый тип
У нас при этом есть левая половина
Левый пакет типов и правый пакет типов
Если нашему классу partition присваивают тип
Который меньше, чем наш pivot
То наш тип это partition
У которого все еще тот же pivot
Но в левой половине дописан этот тип
А если наоборот
То у нас partition, у которого в правой половине дописан
Типа в левой половине ничего не дописан
Стоп, а как мы смогли создать
Пакетист от IOS 3.0
Нет, это ты
Это ты распаковываешь пакеты
Распаковывать мы можем пакет всегда
То есть у тебя IOS уже на этот момент
Однозначно
Ты его просто взял и распаковывал
Ну вот, соответственно, я взял
Для всех этих pivot'ов
Для всех типов сделал
По сути мы просто по очередной все элементы добавили
Вот просто partition
Ну partition
Да, то есть я сделал...
Сейчас
Ну то есть мы взяли partition
Состоящий из pivot'а
И эта штука сначала первый тип
Да, по сути здесь делается
То, что называется процедура partition
Я как бы взял pivot
Вот этот тип
Это просто такой type list
Это некоторая штука partition
У которой слева некоторые набор типов
И вот и справа некоторые набор типов
Я взял, вот каждое это присваивание
Это я либо в type list слева от pivot'а доплагываю тип
Либо в type list справа от pivot'а доплагываю тип
И после этого я делаю join
Я делаю sort левой половины
Конкатинирую с pivot и конкатинирую с sort правой половины
Вот это вот один проход
Который раскидывает кто меньше, кто больше
Вот это рекурсивный вызов
Теперь мы делаем рекурсивный sort для левой половины, sort для правой половины и конкатинируем
Почему это работает не за линией?
Ну вот сам процедура partition
Ну короче до вызова рекурсии
Потому что на каждом присваивании
Мне приходится создавать type list
Под все большего и большего числа аргументов
Это вот за квадрат получается
То есть мне приходится делать логарифм рекурсивных вызовов
Но каждый вызов работает за квадрат
А почему логарифм? Мы вообще pivot берем первый элемент
Тут в худшем случае может быть
Ну понятно, что я мог бы сгенерировать рандомное число
Нет этого элемента
А как бы ты сгенерировал рандомное число?
Я бы написал constexpr функцию
Которая делает линиейный конкурентный генератор
Или mt19937, какой хочешь
Конечно очень некрасиво, что нам пришлось перегрузить
Оператор равно, потому что он тут вообще делает не то что
Ну как бы он
Но он делает как бы докладывание в
Какая разница?
В каком месте, когда вы видите
Оператора равно, можете предположить такое поведение?
Мне кажется никто не может
Действительно лучше было бы перегрузить
Но разницы-то никакой фактически
Вопросы есть?
А так с видом сдвигов будет понятно
Какого черта здесь происходит
Я думаю, что это разница
Значит у вас будет задание написать
Merge sort
А не click sort, то есть stable sort
И я подумал, может еще что-нибудь делать
Может нам условия все-таки уже выложить?
Я по тобой не выкладываю
Там как бы меньше месяца осталось
Почему?
Ну так, ну что
Видимо
Видимо
Видимо на этом все
Но не совсем
Я так и не успел вам показать
Одну вещь, которую я еще хотел показать
Да, короче
Ну я и в прошлом году не успел
И в этом году не успел, ну и ладно
Ну давайте я вам просто скажу
Я вам просто скажу
Вы все
Финальный аккорд
Совсем финальный
Уже не относящийся к теме type-листов
В общем C++11
Была такая интересная вещь
Вот есть такая статья
Которая называется Non-Constant Expressions
Это замечательный заголовок
Просто типа
Весь цепочный слабом предложение
Это как вы можете заметить с веб-архива
Потому что по-моему этой статьи на сайте уже нет
Тем не менее там был когда-то русский перевод
История в чем?
Я вот все мечтаю, чтобы когда-то у нас хватило времени
Но видимо не в этом году
История в чем?
Ну вот в общем вопрос
Загадка
Правда ли, что нельзя так написать некоторую функцию f
Чтобы вот это скомпилировалось?
Ну наверное не правда
Мне казалось бы
Что когда мы говорим constexpr i и вызываем f без параметров
У нас не должно быть возможности
Сделать так, что при втором вызове f без параметров
Выдаст другое число
constexpr и глобальная переменная
constexpr переменные они const
Их нельзя менять
А f-то может меняться у себя?
Ну f зависит от какой-нибудь глобальной переменной
Какой? Которая constexpr?
Не может constexpr функция зависеть
А не constexpr функция
constexpr только
Какой-нибудь mutable static
Поле constexpr класса и нормально
О кстати мы не можем
constexpr функцию там не знаю
Илья
Какой-нибудь static mutable
Поле у класса
Который мы как constexpr глобальную переменную взяли
И в их обращаться туда и все
Я думаю ты не можешь mutable писать
Нет кажется у нас может быть еще какой-нибудь прикол
Как constexpr с указателями работает?
Ну const же обычно
Навешивается на указания справа
Короткая история в том что
По задумке так нельзя делать
Должно было по идее
Все то что умеет constexpr функция
Оно не дает вам возможности менять глобальное состояние
Если f сама не зависит от чего
Тем не менее было обнаружено
Что существует hack
Это не static, не mutable
Все продумано нормально
Вы в constexpr функции можете менять только constexpr
Но они сами const
А hack в стандарте нашли дыру
Которая позволяет сделать компилируемую
И эта дыра она
Основывается на том
Объявления friend методов
Имеют некоторые побочные эффекты
Стоп снято
Если вкратце то
Существует некоторый способ
Заставить компилятор поменять
Глобальное состояние компилятора
И тем самым завести constexpr счетчик
Который позволяет узнавать компилятор
На какой стадии
Существует способ hack
Компилятор так
Чтобы иметь внутреннее состояние счетчик
Который по мере компиляции вы увеличиваете
Когда вам надо
Некоторый глобальный счетчик
В стандарте есть дыра
Которая позволяет это сделать
И работает она за счет того
Что объявление friend функции имеет побочный эффект
С помощью объявления friend
Хитрым образом в некоторых местах
Можно добиться того
Что вы узнаете
Некоторый глобальный стейт компилятора
Сейчас чуть подробнее
А может ссылку на статью?
Мы не торопимся
Нет, мы торопимся, потому что время закупились
В смысле?
Я скину вам эту статью
Здесь есть некоторая структура
Я не в состоянии сейчас вам рассказать
Как это работает, потому что я не
Подготовился до такой степени
Чтобы рассказать
Нужно еще сидеть и залипать
Здесь есть некоторая магия
Которая основывается на том
Что friend функции обладают некоторыми побочными эффектами
Когда вы их объявляете
Так называемый writer
Он объявляет friend функцию
Он как-то влияет
На глобальное состояние компилятора
У вас еще dependant writer
Который наследуется от writer
И тем самым вы...
Это какой-то огромный хак
Да, это огромный хак
Но его последствия довольно интересные
Вы можете рассказать
Господи
Compile time counter
Мы что здесь...
По сути таким образом мы можем там допустим
Compile time полноценно сделать
M3997
То есть мы по сути таким образом
Мы можем написать какую-то функцию next
Которая в compile time меняет
На глобальный состояние
И мы столько раз уже вызвали функцию next
Компилятору
Мы можем написать функцию next
Которая в compile time
Меняет на глобальный состояние
И мы столько раз уже вызвали
По задумке так не должно было быть
Потому что вы не можете
В compile time иметь глобальные переменные
Которые неконстантные
Но за счет этого хака можете
И тем самым...
Можно вопрос
У меня есть ощущение, что есть
Составитель стандарта
Составители стандарта не представляют правила
А все остальные пытаются их надурить
Примерно так и есть
Ты только сейчас это понял
Но в плане тебя пытаются в чем-то ограничить
Я не понимаю, почему мы играем против
Составителей стандарта, если мы вместе хотим
Создать хороший язык с их дискуссией
Мы не против
У нас не противоположные цели
Одинаковые
Эта штука называется stateful metaprogramming
Это метапрограммирование
В котором у вас присутствует
Глобальный стейт
В стадии компиляции
И вы можете на него влиять
Здесь есть
Такой дисклеймер
Core Working Group of 3D21
Is trying its best to make the technique
describing this and previous post informed
Когда комитет узнал, что
Составитель стандарта не представляет правила
Когда комитет узнал, что так можно
Они сказали, что это полный ужас
И мы постараемся как-то исправить стандарт
Это примерно как я, который вам говорит
Я исправлю тесты
Они сказали, что они постараются
trying its best to make the technique
Но этот пост он от 2015 года
И с тех пор стандарты
Все еще позволяет
Просто автор пропал типа
И удалили статьи
А так вот как они решили проблему
В комитете шли какие-то дискуссии
Стоит ли оставлять такую дыру
В стандарте, который позволяет это делать или нет
Видимо решили, что нужно
Золотать, но пока не золотать
Скорее всего они сказали, что надо золотать
А сейчас думают
Как это полноценный фичой ввести
Я не следил
Возможно это замороженная штука
И она так и существует
Можно и можно
Кто хочет, тот использует
Можно просто сделать эту штуку бесполезной
Почему мы в комитете смотрим
Как кто хочет нас
Ограничить функционально
Потому что ты со стороны пользы
Часто не ожидаешь, что вызов
Будет менять глобальные штыки
Это случайно не произойдет
Если не весь код пишешь
Если случайно взять библиотепу
Ты в какой-то момент получаешь
Очень большое удивление
Мы как и в прошлом году не успели
Досконально разобрать эту штуку
Ну и бог с ним
У нас в прошлом году был на экзамене
Один человек, который заботал вот это
На аутол 10
На аутол 10 нам что бы это рассказать
Нет, не обязательно, это был вопрос по выбору
Он сказал, я готов это рассказать
Если кто-нибудь из вас готов заботать вот эти три статьи
И объяснить, что здесь происходит
Возможно
Мы вам добавим бонус
Почему три
Человек рассказывает сначала как идею
В следующей статье он рассказывает
Как это можно превратить в Compile Time счетчик
А в следующей статье как это можно сделать Compile Time контейнером
С глобальным стейтом
А потом как сделать коктейль молота
Вот у него здесь есть
Это после коктейля молота
Что-то более опасное
Видите, что здесь происходит
У него есть некоторый
Метаконтейнер
Который он докладывает
Потом по индексу 0 присваивает
То есть у него есть контейнер
Который в Compile Time изменяемый
Как бы
Нет
Мы каждый раз создаем новый объект
Новый тип
А тут у него есть
Некоторый металист
Который туда делает
И после этого у него
Какой-то глобальный стейт меняется
Наоборот
Мы же этого и хотим
Ну
То есть нужно будет реализовать вот это
Нет, вам не нужно будет реализовывать это
Потому что мы не успели разобрать свою технику
Поэтому, к сожалению, задачу Type List я в этом году это снова не включу
Когда-нибудь
Помянем тех, кто будет первым или будет очень жалко
Господа, на этом наш курс торжественно завершен
Всем спасибо
Спасибо
