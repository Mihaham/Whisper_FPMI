Так, товарищи, ну что, продолжаем нашу деятельность, да?
Матрица Адамара.
А?
Да, да, было такое, Матрица Адамара, но мы не закончили
некое доказательство, тут надо вот вернуться как-то
к пониманию того, на чем мы остановились в прошлый
раз.
Там же не просто Матрица Адамара, а Матрица Адамара
в применении к некоторой задаче о раскраске.
Я очень не хочу напоминать все определения, конечно,
то есть я предполагаю, что вы их как бы помните, да?
Или я зря это предполагаю?
Ну я зря это предполагаю, я знаю, я человек вполне
реалистичный.
Вот.
Я, конечно, очень люблю мотивировать, да, но я прекрасно все понимаю.
Там многоматно одноименных определений.
Это дело даже не в этом, но они все-таки такие, не
очень простые.
То есть, что мы утверждали, теоремат, какую мы доказываем,
в чем состоит, то существует такая совокупность, состоящая
из множеств М1 и так далее МН?
Все по-другому обозначали, да?
А, ну да, я написал там N, пусть S равно N, но можно
я недословно буду воспроизводить теорему, вы же ее можете
не записывать.
Я сейчас просто напоминаю, чтобы вы как-то включились.
Вы вот это можете не записывать, чтобы не запутаться в разных
формулировках.
Но если я хочу неформально читать, а так, чтобы вы понимали
в процессе, то мне кажется, это не страшно совершенно.
Такая, что диск, то есть уклонение этой совокупности
больше либо равняется корень из N на 2, но я опять
забыл сказать, но я так и писал, кстати, в прошлый
раз, коль скоро N в порядок матрицы Адамара.
Что-то длинное какое-то у меня получилось, давайте
я вот так вот сделаю, у меня будет кусок доски.
Уклонение M больше либо равняется корень из N пополам, коль
скоро N, это порядок матрицы Адамара.
Вот, и мы в принципе некоторую конструкцию осуществили,
а именно мы взяли матрицу H, это матрица Адамара в
нормальной форме, вы лучше не записывайте, а слушайте
и смотрите, чем заканчивалась прошлая лекция, так будет
понятнее.
Мы взяли матрицу H, это матрица Адамара в нормальной
форме, к ней прибавили матрицу G, которая состояла из сплошных
единиц, такая суперединичная матрица, и разделили пополам.
У нас получилась какая-то матрица размера N на N, у которой
все элементы, ну не важно как их обозначить, АИТ,
ЖИТ, АИТ, ЖИТ, принадлежат 0,1.
И вот я успел сказать, по-моему, в конце, что трочки этой
и будут формировать множество m1, m2, m3, и будут формировать
множество m1, m2, m3, и т.д.
Так, друзья, а все остальные помнишь, что я на этом совершил?
Как строчки формируют?
Значит, первая строчка состоит из сплошных единиц,
то есть множество m1 – это множество 1, 2, и т.д. N.
Вторая строчка состоит из половины единиц, половины
нулей, но это будет множество, соответственно, m2, которое
состоит из чисел, отвечающих номерам единичных позиций.
Ну и так далее.
Вот будет такие N множество, первая жирная прям все
заполняет, а остальные – пополовинки.
Сейчас я понятно изъясняюсь?
Вот, ну вот теперь это надо как-то доказать.
Давайте… Ну что доказать?
Доказать, что это совокупность и уклонение такое.
Ну давайте сначала… Да, что надо для этого доказать?
Не сначала, вот что надо доказать?
Я утверждаю, что фактически надо доказать, что для любого
вектора V координатами v1 и т.д. vN и принадлежащего
0, 1, а плюс 1 и минус 1 в N степени… Я сейчас напишу,
а потом буду пояснять.
Вы с кодом можете не понять, а можете понять.
Фактически надо доказать, что для любого вектора
из плюс-минус единиц h плюс g пополам, вот такая матрица,
умноженная на этот вектор… Ну, наверное, если уж совсем
стараться писать, как алгебраисты делают транспонированный,
я не знаю, насколько вас формализовано это учат.
Я бы, честно, t не писал, но вы, наверное, хотите.
Ну имеется в виду, что, конечно, я умножаю на столбец
справа, значит, что вот это вот вектор получится…
Да, это же получится вектор, правильно?
Ум вектора вот такого вот есть координата, модуль
которой, абсолютная величина которой не меньше, чем корень
из N пополам.
Я утверждаю, что это в точности то, что нам теперь алгебраически
нужно доказать.
Если мы эту матрицу умножим на любой вектор из плюс-минус
единиц, то у полученного вектора найдется координата,
абсолютная величина которой не меньше, чем корень из
N пополам.
Так, ну давайте попробуем понять, почему это так.
Ну смотрите, вот здесь по строчкам, как я уже несколько
раз повторил, написаны фактически вот эти множества,
просто по своему определению.
Да, теперь вот вы берете и строчку этой матрицы, то
есть какое-то множество, умножаете на вектор из
плюс-минус единиц, что у вас происходит?
У вас на единичке, которые стоят на позициях с номерами
из множества, умножаются как раз плюс и минус единицы,
то есть цвета.
Помните, что цвет это плюс или минус единицы, там
нули умножаются, не важно, что они умножаются, мы
фактически красим вот это множество плюс-минус единичные
цвета.
Вектор В это наша раскраска, для любого вектора В это
и значит для любой раскраски плюс-минус единичные цвета.
То есть вектор В состоит из цветов элементов 1 и так
далее n.
И вот мы говорим, для любого набора этих цветов, если
мы на эти цвета поумножаем единички из множества, то
где-нибудь на одной из координатных позиций получится не меньше,
чем столько.
То есть как ни красть, а какое-то множество будет
выпадать из хорошего дискрепанса.
Будет получать большое уклонение.
Не знаю, можно это воспринять?
Руки поднимите, пожалуйста, те, кто честно воспринял.
Но это хорошо.
Потому что сейчас можно действовать чисто алгебраически,
уже все, у нас комбинаторная задача практически исчезла.
Теперь надо просто это проверять.
Ну совсем легко разобраться с h, умноженным на v.
Вот давайте начнем с этого, на v транспонент.
Потом добавим g, поделим пополам в самом конце.
Значит h, умноженное на v, давайте просто обозначим
координаты этого вектора l1 и ln.
Просто обозначим так эти координаты.
Наша цель доказать, что для какого-то e модуль l и т.
не меньше, чем корень и зан пополам.
Знаете, что мы сделаем?
Ну давайте здесь все-таки, мы hv, колярно умножим на
hv.
Ну то есть рассмотрим с колярный квадрат этого
вектора.
Колярный квадрат этого вектора.
Ну конечно так.
Сейчас друзья, вариантов нет по-моему, если мы обозначили
координаты этого вектора так, то сколярный квадрат
этого вектора вы внесли в новом сколярном произведении.
Это сумма квадратов, этих координат.
С другой стороны, давайте я возьму нашу матрицу h и
ее векторы столбцы обозначу ну как-нибудь вот так.
h1, hn, ну пусть транспонированные, неважно, но в общем это векторы
столбцы.
Это их обозначу… правда, да, сказав, что это векторы
столбцы.
Ну хорошо, не буду писать, мне тоже кажется, что может.
Вот, давайте так действительно оставим, как в терминах
этих векторов столбцов написать сколярное произведение.
Ну очень просто, это v1, h1, плюс и так далее, плюс vn, hn.
Так, v1, vn – это координаты вектора v, ну как умножают
матрицу, где сколярное произведение, а-а-а, я понял, да-да-да, это
я не дописал, виноват.
Да, конечно, конечно, это я просто написал, что такое
h умножить на v транспонированное.
h умножить на v транспонированное в терминах обозначений
для столбцов матрицы h такое.
Сейчас, что-то не успеваете спросить, лучше у меня.
Не, нормально всё.
Ну-ну-ну, но видите, полезно же, всё полезно.
Так, слушайте, ну сколярное произведение, конечно,
линейно.
У нас получится v1 квадрат h1 на h1, что так далее, плюс
vn квадрат hn на hn, и плюс сумма по i неравным j, v i t, v j t на h i t,
здесь i t, h j t, и вот здесь, ну уж я не знаю, катарсис
или не катарсис, но суть происходящего, это всё нули.
По определению матрицы Адамара, вот это всё ноль.
Конечно, и неравно j, значит, h i t на h i t сколярно даёт ноль.
Сама на себя, это не строчка, это столбец, да, сам на
себя столбец даёт n, здесь тоже n, вектор с плюс-минус
единицу, умноженный сам на себя, размерность n, конечно,
даёт в сколярном произведении, в сколярном квадрате, даёт
n.
Итого мы получаем v1 в квадрате, vn в квадрате, это единицы,
конечно же, это 1, это 1, итого мы получаем n квадрат,
а с другой стороны это сумма квадратов элитых, ну значит,
какое-то элите в квадрате не меньше, чем n, а значит,
какое-то элите не меньше, чем корень z, следовательно,
существует, существует, и такое, что элите по модулю
не меньше, чем корень z.
О, а?
Да.
Да.
Да.
Да, остальные с плюс-минус 1 за половиной там, да.
А неважно, где вот здесь используется, чтобы…
Что?
Где вот здесь?
Нет, смотрите, у нас строчка какая-то из плюс-минус
где-то минус единицы, где-то плюс, но они все время умножаются
вот так, она же сама на себя умножается, то есть везде
получаются единицы, неважно, сколько там минус единиц
в этой строчке, важно, что она есть плюс-минус единиц.
В этом месте неважно, что она в нормальной форме,
мы этим еще воспользуемся, но не сейчас, здесь все получилось.
То есть в принципе уже вся суть понятна, если мы там
не гонимся за какой-то мелочью, но корень z пополам
получился, надо как-то zhi побороться.
То есть, друзья, вы понимаете, что h пополам, вот именно
h пополам умноженное на… вот h пополам умноженное на v,
все, она уже обладает вот этим свойством, все замечательно.
Надо zhi еще как-то разобраться.
Да, надо, чтобы zhi это свойство не испортило, да.
Ну, сходу ясно, что сильно не испортит, но сейчас докажем,
что вообще не испортит.
Так, что такое h плюс zhi на v транспонируем?
Ну, это, конечно, l1, а плюс что?
Но тут единицы сплошные умножаются на v1 и так далее vn.
Вот тут единицы, а тут v1 vn.
Правда ли, что получится просто сумма v1?
Ну, давайте я так и напишу.
Сумма p i от единицы до n v1, l2 тоже будет сумма p i от единицы
до n v1 и так далее, ln плюс сумма p i от единицы до n v1.
Так, сейчас, друзья, есть какой-нибудь вопрос по этому?
Понятно?
Так, ну, для краткости обозначим эту сумму буквкой лямбда.
Просто обозначим.
И, кстати, заметим, что лямбда это четное число.
Все ли понимают, что лямбда это четное число?
Это сумма плюс-минус единицы в векторе, у которого четное число координат.
Очевидно, что это четное число.
Давайте я это где-нибудь здесь напишу, это пригодится.
Лямбда четная.
Так, ну и, наверное, сейчас будем снова смотреть квадрат, скалярный квадрат.
Так, берем скалярный квадрат, я уже так напишу.
Снова берем скалярный квадрат.
Так, у нас получается l1 в квадрате плюс и так далее плюс ln в квадрате.
Плюс два лямбда один на сумму по i от единицы до n литых.
И плюс лямбда квадрат на n.
Правильно?
Скалярный квадрат вот этого нового вектора.
Это надо в квадрат возвести каждую штуковину.
Ну как раз будет l i t в квадрате плюс два лямбда l i t плюс лямбда квадрат.
Ну складываем, слагаем их, получаем так.
Так, здесь мы кое-что знаем.
Вот это вот мы уже считали.
Получается n в квадрате плюс два лямбда на сумму l i t.
И плюс лямбда квадрат на n.
Давайте найдем сумму l i t.
Вот сейчас мы воспользуемся нормальностью формы матрицы.
Для нахождения суммы l i t.
Сумма по i от единицы до n l i t.
Здесь удобно вернуться вот на нить.
Сумма по i от единицы до n l i t.
Здесь удобно вернуться вот, наверное, сюда к определению l i t.
И сказать, что давайте еще вот так вот напишем.
h i t ж i t это будет обозначение для элемента матрицы Адамара.
То есть у нас было обозначение для столбца матрицы Адамара.
Со стрелочкой, с одним индексом.
А с двумя индексами это просто элемент матрицы Адамара.
Вот что значит сложить l i t?
Если мы знаем элементы матрицы Адамара.
Что такое l 1?
Это мы берем, складываем по столбцам пожи.
h i t ж i t умножить на v ж i t, соответственно.
То есть я хочу сказать, что когда мы еще потом все эти l i t складываем,
то, наверное, получается вот так.
Сумма по i от 1 до n.
Сумма по ж от 1 до n.
h i t ж i t на v ж i t.
Вот это вот внутреннее суммирование это l i t.
Вот мы складываем l i t и по i от 1 до n.
Вроде просто.
Так, а теперь мы еще переставим тут, наверное, какие-то порядки суммирования.
И вот так напишем.
Сумма пожи от 1 до n v ж i t умножена на сумму по i от 1 до n h i t ж i t.
И вот тут возникает нормальность формы.
Потому что сумма по i от 1 до n h i t ж i t это сумма элементов внутри столбца матрицы Адамара.
Это n в начале, а дальше сплошные нули.
Правильно, за счет нормальности формы.
То есть это плюс-минус n.
Мы не знаем, чему равно v1, который умножается на n.
То ли плюс, то ли минус единица.
Но вот как-то так, в зависимости от v1.
Плюс-минус n, а потом уже ж равного двойки здесь стоят нули.
Поэтому больше ничего прибавлять не нужно.
Итого у нас вот тут получается n квадрат плюс-минус 2 лямбда n плюс лямбда квадрат на n.
Вот какая квадратичная форма.
Такая парабола и по n и по лямбда.
Так, ну по лямбда это парабола.
Точно такая, да?
Я, понятно, собираюсь.
Вы понимаете, нам хочется это оценить снизу.
Или забыли, что нам хочется это оценить снизу.
Но раз парабола такая, надо смотреть, где у нее минимум достигается, чтобы оценить снизу.
Ну да, конечно.
Ну как?
Где эта вершинка?
То есть это что?
Это минус b поделить на 2a, да?
Я не знаю, вас так учили или нет.
Может, я повторяю какие-то мантры, которые вам не знакомы.
Ну, производная, да?
Где производная равняется нулю?
Когда многочлен записывается в виде ax квадрат плюс bx плюс c,
то там получается минус b поделить на 2a.
В плохих школах учат просто запоминать, что это в точке минус b поделить на 2a.
В математических школах люди, конечно, понимают, откуда это берется, и не запоминают мантры.
А в плохих прямо так и учат.
Минус b на 2a, минус b на 2a, не дай бог забыть.
Вот.
Ну, короче, здесь надо минус...
Давайте я лямбда мин возьму много болтовней.
Это минус плюс, ой, минус плюс.
Ну, потому что минус b поделить на 2a.
Так, это минус плюс 2n поделить на 2n.
То есть внимание, это минус плюс 1.
Смотрите сюда.
Ну, то есть те реальные лямбды, которые есть в нашем распоряжении, которые у нас возникают,
они глобально минимизировать, конечно, эту параболу не могут.
Но, то есть, если здесь ожидается минус 1, то наши кандидаты – это минус 2 и 0.
А если здесь ожидается плюс 1, то наши кандидаты – это 0 и 2.
Я быстро говорю или понятно?
Не очень?
А?
На минимизацию.
Лямбда мин.
Хорошо, я еще раз повторю.
Смотрите.
Вы согласны, да, с тем, что вот эта парабола по лямбда минимизируется в точках минус или плюс 1
в зависимости от того, v1 равнялась плюс или минус единице.
Если v1 было плюс 1, то точка, в которой достигается минимум, будет со знаком минус,
если там был минус, то будет плюс.
Но у нас лямбда – обязательно четное число.
Поэтому ни минус единицы, ни плюс единицы у нас, в принципе, возникнуть не может.
И тогда я говорю так.
Вот если v1 равняется плюс единицы,
тогда те точки лямбда, которые реально минимизируют в нашем случае эту параболу,
это не минус 1, а ноль или два.
А если v1 равняется единице, то лямбда мин, в нашем случае,
но лямбда минимальная, четная, если хотите, можете прерисовать,
это будет не минус 1, а ноль и два.
Вот они минимизируют.
А если v1 равно минус единицы,
кандидат на минимизацию этой функции, просто так я выразился,
то получится лямбда мин, реальный равняется,
но вокруг плюс единички надо прыгнуть.
А, наоборот, что ли?
Уд, ноль и минус два, а здесь ноль и два.
Ну и еще раз, если v1 равно единице, то реальный лямбда мин это минус 1.
Минус 1 не бывает, ближайший четный это ноль и минус два.
А тут плюс один, но ближайший четный это ноль и два.
Парабол, монотонная функция, но ясно, что там все симметрично к тому же.
Сейчас я понятно сказал или нет?
Раскокнулись, да?
Ну я, может быть, произнес какие-то страшные слова, ну извините,
но сейчас я все подробно написал.
Раскокнулись, да? Нормально?
Не, ну все, давайте подставлять.
То есть, если v1 равно единице, то у нас здесь стоит минус.
Сейчас, минус или плюс? Плюс, да?
То у нас получается, давайте где-нибудь, все-таки побольше места надо.
Слушайте, я думаю, что все очевидно. Я и раньше думал, что все очевидно.
Но когда я вот эти слова произнес, народ кокнулся.
Поэтому я решил подставлять. Может зря.
Вы правильно все говорите?
Друзья, ну если все очевидно уже теперь, то и слава Богу.
Просто я хотел сказать прямо тупо совершенно,
но возьмите там v1 равно единице, тогда будет плюс.
Подставьте туда 0 или минус 2 вместо лямбда,
и в обоих случаях очевидно получится n квадрат.
Ну вот, можно так сказать.
В любом случае 0 подставить и радоваться, потому что все симметрично.
Правильно, да.
В обоих случаях минус 2 симметрично нулю,
2 симметрично нулю х,
минус 2 симметрично нулю,
2 симметрично нулю,
подставили сюда 0, получили n квадрат.
Ну то есть это больше либо равно n в квадрате по-любому.
И мы возвращаемся к старому рассуждению.
Отсюда, конечно, следует, что существует и такое,
что уже иt плюс лямбда
больше либо равняется корень из n.
Ну а дальше все делим пополам и получаем результат теоремы.
Это мы с h плюс 4 разобрались,
а нас интересует пополам.
Ну пополам будет корень из n пополам.
Нормально, ничего не нужно повторить, всем все понятно.
Я не хочу занудствовать, я хочу, чтобы было интересно
в темпе, но если вдруг непонятно,
я с удовольствием объясню.
Так.
Теперь про кодирование.
Очень так поверхностно, но все-таки кое-что расскажу.
Так, чуть-чуть про теорию кодирования
и где здесь матрица Адамара.
Ну, друзья, смотрите, я, конечно, в этом месте обожаю
рассказывать такую анекдотическую, конечно, формулировку задачи.
Не анекдот ни в коем случае, но веселую формулировку
я не буду рассказывать.
Я хочу рассказать, конечно, очень, но веселую формулировку
в духе того, как я рассказывал про пьяниц,
которые взвешивают водку там и еще чего-то.
Вот здесь тоже есть интерпретация с пьяницами.
И некоторые из вас наверняка слышали.
Потому что я очень люблю это рассказывать,
и школьникам, конечно, тоже рассказываю.
Значит, смотрите, я не буду писать на доске,
и вы можете не писать, но если осознаете связь,
я не сняюсь это на камеру снять.
Это снято столько раз и лежит в интернете в таком количестве,
что мне уже стесняться нелепо.
Значит, история такая, есть N пьяниц.
N пьяниц.
Могу написать пьяниц.
Так, и каждый вечер они соображают на троих.
Знаете, что пьяницы иногда соображают на троих.
Ровно на троих.
Каждый вечер они идут в кабак втроем.
Какие-то трое из вот этих N напиваются
и бьют друг другу морду.
Результатом служит тот факт,
что никакие двое из этих бывших друзей
больше в кабак вместе не пойдут.
Но у каждого душа алчат,
поэтому в принципе каждый пойти может.
Главное, чтобы не с тем, с кем уже подрался.
И так каждый вечер.
Спрашивается, как долго может продолжаться это безобразие.
Не забывайте, что пьяниц N.
То есть, как можно организовать им
такие визиты ежевечерние,
чтобы вечеров было как можно больше?
Ну и все.
Представьте себе, что N равно 9,
чтобы было понятно.
В первый день можно отправить туда 1, 2, 3.
Потом во второй день можно отправить 4, 5, 6.
Видите, они вообще не пересекаются.
Все хорошо. Новая партия свежая поступила.
Потом 7, 8, 9.
Но на этом процесс не останавливается,
потому что каждый побитый может пойти в кабак,
лишь бы не с другим, кому он бил морду.
Может пойти с 3, но вполне может пойти с 4.
И тогда у нас четвертый вечер
составляют товарищи с номерами 1, 4, 7.
Надеюсь, вы понимаете, как действовать дальше.
Видно, что этот процесс, вообще говоря, потенциально долгий.
И может быть зависит от того,
как именно мы строим последовательно эти тройки.
Но здесь мы их взяли не пересекающиеся.
А может, надо было их сразу как-то пересекать.
Я понимаю, что задача комбинаторна.
Звучит следующим образом.
Просто найти максимальное количество трех-элементных
под множество n-элементного множества,
при условии, что каждые два из них пересекаются
не больше, чем по одному элементу.
Это я могу написать явно.
Максимальное число
трех-элементных
под множество
n-элементного множества
любые или каждые два из которых,
наверное, лучше каждые два из которых,
имеют не больше одного общего элемента.
Я утверждаю, что эта задача
является задачей о кодах исправляющих ошибки.
Стандартный каламбур, что это задача
не теории кодирования от пьянства,
а именно про коды исправляющие ошибки.
Ну давайте про коды исправляющие ошибки.
Вот у нас есть
источник,
а есть приемник.
А вот эта стрелочка это канал связи,
по которому передаются сообщения.
Там есть масса разных вариантов того,
что может случиться на канале,
но давайте считать так.
Сообщение состоит из слов.
Ну, фактически слов, например, русского языка,
закодирован. То есть было слово мама,
например, а мы его закодировали,
видите, что-нибудь вот такого.
Всего N позиций,
три из них единичные, остальные нулевые,
ну, например. Ну, так вот захотелось.
Было слово папа,
мы его закодировали вот так.
Дальше все нули,
и так тоже N.
Ну и так далее.
Так, друзья, я понятно и изъясняюсь.
Сейчас объясню.
Да-да-да, на самом деле вопросы правильные,
я сейчас собираюсь все сказать.
Когда? Значит, у нас есть словарь
из слов, которые мы хотим научиться передавать
по этому каналу. Мама, папа там,
кто хотите.
Нам, конечно, хочется, чтобы этот словарь был в итоге
побогаче.
Мы каждому слову сопоставляем последовательность
из нулей единиц, но вот в рамках этого примера мы считаем,
что единиц три, а всего позиция N штук,
где N подлежит подбору. N мы вольны выбирать так,
как нам захочется. А единиц всегда будет три.
Заранее всем вообще людям на планете,
кто желает об этом быть в курсе,
известны и вот эти слова,
и соответствующие кодовые слова.
Всем все известно, это не шифрование.
То есть мы не пытаемся скрыть информацию
от какого-нибудь злонравного товарища, который собирается
до нее добраться. Мы передаем совершенно открытую
информацию по каналу связи, и мы просто хотим,
чтобы при наличии шумов на этом канале
тот товарищ, который сидит на приемнике,
смог восстановить информацию.
Если кто-то еще проникнет к этому источнику,
ну, к этому каналу связи, ну, пожалуйста, пусть он тоже
восстановит информацию. Нам не жалко.
Вот именно это называется кодами, исправляющими ошибки,
то есть шумы на канале, а не какое-то шифрование,
то не догадался, враг не догадался.
Вот, значит,
вопрос такой. Представим себе,
что мы передаем слово «мама»,
передаем слово «папа», не важно какое слово,
в общем, нашу последность из нуле единиц.
И мы знаем откуда-то заранее,
что канал может исказить не более одного символа
в каждом из передаваемых слов.
То есть если мы передавали «мама»,
лишь один нолик может превратиться в единицу,
или лишь одна единица может превратиться в ноль.
Если ноль превратился в единицу,
все, уже никакая единица в ноль не превратится.
Мы знаем, что только одна ошибка.
И ошибка это состоит в замене единицы на ноль
или замене нуля на единицу,
то есть превращение знаков в противоположные,
в два, так скажем.
Ну такой очень хороший канал.
Всего одну ошибку допускает на каждом слове.
А может быть и не одно.
Вот смотрите, если бы мы передавали изначальная «мама»
и изначальная «папа» каким-то образом,
не нолики и единички, а сами вот эти буквы русского алфавита,
то даже при одной ошибке
мы могли бы не суметь восстановить информацию.
Потому что «мама» может превратиться в «мапу»,
и «папа» может превратиться в «мапу».
У «мамы» для этого должна вот эта буква исказиться, превратиться в «п»,
а у «папы» наоборот вот эта.
И все, получил приемник «мапу», даже при одной ошибке
он знать не знает, это «мама» или «папа».
Я понятно изъясняюсь?
А вот если мы передаем две таких последовательности,
как я нарисовал, то, по-моему, очевидно, что все хорошо.
Очевидно, что все хорошо.
Нет.
Тут же пересечение только по одному вот этому элементу.
Мы не можем так исказить,
делая только одно искажение тут и одно искажение тут,
чтобы слова склеились в «мапу», условно.
Не можем?
Или считается, что можем?
Но не можем, конечно.
Если я геометрически нарисую максимально наглядно,
тогда будет совсем понятно.
Слушайте, ну, по-моему, вообще понятно, какая связь между пьяницами
и вот этой задачей про построение кодов, исправляющих ошибки.
Почему не случилось искажения?
Ой, слепание.
Почему они не слиплись?
Потому что пересечение вот этих троек позиций
всего лишь по одному элементу.
Вот если бы они пересекались по двум элементам вот так,
0, 1, 1, дальше все нули,
а «папа» был бы вот таким,
это «мама» и «папа»,
то прекрасно, здесь ноль превращается в единицу,
здесь ноль превращается в единицу, все одно и то же.
То есть такие слова в качестве кодовых брать нелепо,
потому что они впадают в ту же дурь,
в которой находились исходные слова «мама».
А если взять вот такие кодовые слова, то уже хорошо,
потому что они достаточно далеко в каком-то смысле
отстоят друг от друга.
Это прямо правильная терминология,
сейчас я ее буду писать.
Ну то есть какая возникает задача?
Нам же хочется передавать как можно более разумные сообщения,
как можно больше словарь заранее зафиксировать.
Ну вот ровно вот это,
максимизации количества троек,
которые попарно пересекаются не больше, чем по одному элементу.
Да, при том, что мы примкнули, конечно, именно к такому способу,
поэтому я сейчас это вложу в более общий контекст,
но сначала нарисую картинку.
Конечно, кодировать можно по-разному,
я говорю, что это прямо самая вершинка айсберга,
но с этого начинается теория кодирования в каком-то смысле.
А дальше там масса, конечно, есть разных методов,
идей, подходов, задач и так далее.
Значит, картинку я хотел нарисовать вот такую.
Я могу взять вот это слово «мама», например,
и интерпретировать его как точку в инмерном пространстве,
ну или даже просто как такую точку,
в абстрактном таком пространстве, елки-палки,
картинку не дали нарисовать.
Ну чего, устраиваем перерыв?
А то я долго может ее рисовать буду.
Давайте перерыв устроим, потом будет картинка.
Так, друзья, давайте продолжать. Все.
Смотрите, я собирался нарисовать шарики.
Шарики нарисовать.
Ну, серьезно, смотрите, вот слово «мама»,
это нарисовано такой последовательностью из нулей единиц.
Давайте введем вообще на словах такое расстояние.
Называется «расстояние Хэйминга».
Кого? Нет, ну бывает Элевенштейна.
Да, я хочу Хэйминга.
Там их много разных бывает.
Не, ну на 0.1 это одно и то же, конечно,
а в общем случае это разные вещи.
Расстояние Хэйминга – это очень простая вещь.
Между двумя последовательностями из нулей единиц
расстояние Хэйминга – это просто количество
несовпадающих координат.
Количество несовпадающих координат.
Ну, то есть вот между нашей нынешней мамой
и нынешним папой, закодированными от пьянств,
расстояние Хэйминга составляет раз, два, три, четыре.
Так, друзья, понятно говорю?
Но это фактически эвклидовое расстояние,
просто возведенное в квадрат.
Можно так сказать.
Знаете, что такое эвклидовое расстояние в отмерном пространстве?
Ну, вот квадрат, его это Хэйминговое расстояние
для 0.1 и 0.1.
Для 0.1 векторов все очень просто.
Ну так вот, я могу нарисовать такой шарик.
Что такое шарик?
Это множество тех кодовых последовательностей,
тех слов из нулей единиц,
которые в Хэйминговой метрике,
по Хэйминговому расстоянию,
отстоят от этого центра не больше, чем на какую-то величину.
Вот здесь вот D.
Радиус этого шара,
это максимальное расстояние Хэйминга
от вот этого центра.
Слушайте, очень простой вопрос.
А сколько слов вот в этом шаре?
Это же шар комбинаторный.
Он определен на последовательностях из нулей единиц.
В нем конечное множество точек.
То есть, это условная картинка с шаром.
Конечно, да. То есть, суммарно, здесь просто вот столько точек.
C и Z по нулю и так далее.
C и Z по D. C и Z по D лежат уже на границе,
на сфере, которая как бы условно ограничивает этот шар.
Есть у нас слово папа.
Если мы вот здесь вот его нарисуем.
1, 1, 0, 0.
1 дальше все нули.
И тоже нарисуем такой шарик.
Ну вот если это D, к чему равняется?
Если это D равняется единице,
количество ошибок,
и здесь тоже D равняется единице,
то эти шарики просто не пересекаются.
Ну или по-другому можно сказать, что
расстояние между этими кодовыми словами не меньше 2.
И только тогда, когда шарики не пересекаются,
им можно исправить одну ошибку, соответственно.
Больше двух строго.
Иначе они границами пересекутся.
Больше двух строго.
Оговорился, виноват.
Ну то есть, такая вот задача получается.
В этих терминах знаете, как в коробку упаковывают апельсины.
Вот здесь тоже надо
так упаковать эти шары, чтобы они не пересекались,
но поплотнее упаковывали все множество 0,1 в n-ной степени.
Ну или C и Zn по 3, если мы только 3 единицы допускаем.
Такая типичная задача теории кодирования,
это задача упаковки таких вот
комбинаторных шаров заданного радиуса
в хеммингово пространство, то есть в 0,1
дискретное множество в n-ной степени,
в булиф клуб там по-другому, как угодно.
Вот в этой 0,1 в n-ной степени запихать
как можно больше шаров данного радиуса,
так чтобы они попарно не пересекались.
Тогда центры могут служить кодовыми словами,
и вы, соответственно, большой исходный словарь сумеете докодировать.
Так, я понятно объяснил.
Успели записать? Все нормально записывается?
Достаточно информации на доске,
чтобы это все тебе зафиксировать?
Ну хорошо. Ну давайте теперь
общее определение дадим некоторое, чтобы увязать это
одним из возможных вариантов с матрицами Адамара.
Это не единственная, конечно, увязка, там их масса,
но вот одну из них я сейчас расскажу.
Давайте вот так вот обозначим n, m, d код.
Это код, которым m слов,
в каждом слове n нулей и единиц.
Тут мы никак не фиксируем количество единиц как раз,
то есть не увязываемся стройками пьяниц,
может быть, сколько угодно, но суммарно n,
длина каждого вектора, которое означает слово,
это n нулей и единиц,
и d это минимальное
хемминговое расстояние между словами.
Ну то есть такой код может исправить
кто-то типа не более, чем d пополам минус одну ошибку.
Значит, n, m, d код – это любой набор
векторов из нулей и единиц,
в каждом векторе n нулей или единиц,
всего векторов должно быть m штук,
и d – это минимальное хемминговое расстояние между векторами.
Да, здесь количество единиц не фиксируем.
Можно его дополнительно зафиксировать, но мне сейчас это не потребуется.
Ну то было просто для затравки, чтобы было понятно,
в чем задача состоит, но можно сразу вот про это говорить.
Так, понятно, что такой код, если он существует
при данных параметрах, то он исправляет не больше, чем d пополам без единицы ошибок.
Вот мы специально это все рисовали.
Если расстояние не меньше, чем d, значит, радиусы вот этих вот шаров,
если они не пересекаются, должны не превосходить d пополам без единицы.
Если они равны d пополам, тогда они, как вот я оговорился,
они все-таки коснутся границами.
Ну, не больше, чем d пополам минус один ошибок мы исправим.
Да, d может быть нечетным, но я держал в голове,
что пусть d четный, я согласен.
Да, если более аккуратно говорить, то так.
Но смысл понятен.
То есть, если мы зафиксировали n и d, то, конечно, задача состоит в максимизации величины m.
Если n и d зафиксированы, то нас интересует n-md код из как можно большим m.
Если зафиксировано только d, то мы можем, например, выбирать такие n, которые нам удобны,
чтобы при этих удобных n максимизировать, соответственно, m.
Но в конечном счете нас интересует, как можно больше кодовых слов научиться передавать,
исправляя, соответственно, вот это количество ошибок.
Значит, в теории кодирования есть огромное количество верхних оценок для вот этого m в зависимости от n и d.
Есть граница Хэминга, там есть граница Лайца-Басалыга.
Не буду я сейчас в это вообще вдаваться, это огромная наука, я вам ее сейчас не рассказываю.
Я немножко ее рассказываю, чтобы привязать к матрице Мадамара как к абсолютно классическим объектам.
Так вот, есть такая граница Плоткина. Одна из.
Сейчас я ее объясню. Она очень проста.
Верхняя граница для величины m при заданных n и d.
Говорится так, пусть...
2d больше чем n. То есть мы хотим исправить вообще очень много ошибок.
2d больше чем n. Представляете? Изрядное количество ошибок.
Пусть 2d больше чем n.
Тогда, естественно, мы слишком много слов не сможем передать.
Вот утверждается, что m не превосходит целой части от 2d на 2d-n.
Но это мало, да. Ну понятно, мы хотим исправить безумно много ошибок.
Вот если их безумно много, тогда можно сказать такую простую границу. Сейчас я ее докажу.
Доказательства.
Ну, давайте пусть a1 и так далее, a с индексом m, это какие-то кодовые слова.
Ну, то есть последовательности из нулей и единиц.
Кодовые слова, то есть последовательности из нулей и единиц длины n.
Ну, которые исправляют d ошибок. Ну, не d, понятно.
Которые соответствуют нашему nmd-коду. Ну, короче, пусть это nmd-код.
Давайте нарисуем такую матрицу опять. Ну, это не матрица Адамара будет, просто нарисуем пока такую матрицу.
Вот так a1, a2, am. По строчкам расположим вот эти кодовые слова, расположим по строчкам матрицы.
То есть это будет матрица размера n на m. У нее m-строчек и n столбцов.
В каждом кодовом слове n символов. Такая матрица из нулей и единиц.
Давайте организуем очень простой двойной счет.
А именно просуммируем по всем, вот так вот, i меньше, чем j, меньше, чем, не n, конечно, а m.
И по всем k от единицы до n, индикаторы того, что аит kt, да, правильно, не равняется а житому k тому.
Ну, я, наверное, не сказал. Давайте считать, что элементы этой матрицы, в свою очередь, обозначаются как аиты и житы, конечно.
Матрица, составленная из строчек, которые являются кодовыми словами, имеет элементы аит и житы, и меняется от единицы до м, а жи меняется от единицы до н.
Да, так вот. Вроде правильно.
Да, просто рассматриваем. Ну, оно очень понятно, для чего рассматривать. Сейчас мы поймем.
Просто пока вот принимаете, да, ой, какой ужас на нас спустился с неба. Двойная сумма. Просто рассматриваем такое выражение.
Все очень и очень просто. Значит, во-первых, не все могут понимать вот это обозначение.
Что такое индикатор чего-то, написанного в фигурных скобках?
Ну, я, как всегда, перепутал порядок, как пишут в алгебре. Ну, извините. Я просто перепутал.
Так, теперь все-таки смотрим сюда. Что такое индикатор? Это единица, если выполнена, и ноль, если не выполнена.
Вот в такой записи совершенно верно. Это сумма всех попарных расстояний, просто между этими кодовыми словами.
Потому что если мы зафиксировали И и Ж во внешнем суммировании, это значит мы зафиксировали кодовое слово аитое и кодовое слово ожитое.
И когда мы суммируем пока от единицы до н вот эти не совпадения, мы просто считаем хемминговое расстояние между этими словами.
Вот это вот все. Это хемминговое расстояние между словом аитое и словом ожитое. Понятно?
Вот это хемминговое расстояние от аитое там до ожитое.
Ну, у нас оно по условию не меньше, чем D. Хемминговое расстояние не меньше, чем D, потому что D это минимальное расстояние в коде.
Значит, мы получаем не меньше, чем m на m-1 пополам на D. Вроде получаем.
Ну, каждая внутренняя сумма не меньше, чем D, потому что это хемминговое расстояние.
А складывается C из m по два величины, но это m на m-1 пополам. Каждая не меньше, чем D.
Ну, теперь давайте переставим порядки суммирования. Пойдем справа налево. Шарик-то сотрем.
Наоборот напишем. Сумма пока от 1 до m. То есть сначала будем фиксировать столбец, а потом уже будем суммировать по строчкам.
И меньше, чем j меньше, чем m, а нет индикаторов того, что аитое катае не равно ожитому катому.
Так, то есть вот мы еще раз эту матрицу нарисуем. Мы фиксируем катый столбец. Вот там какие-то нолики, единички, единички нолики.
Вот мы зафиксировали катый столбец. Дорогие друзья, мы знаем сколько в нем единиц, а сколько нулей? Вопрос на засыпку.
Нет, конечно. Мы знаем сколько единиц в строчке, может быть, и то не знаем, потому что мало ли, мы же не писали равновесный код, как в задачке про тройки.
Мы ничего не знаем. Мы не знаем ни сколько единиц в строчке, ни сколько единиц в столбце.
Весело. Ну хорошо, давайте обозначим буквы x число единиц в столбце.
А как вам это?
Нет, ну вы можете сказать x катае, потому что x не одинаковый для всех, конечно. Но я зафиксировал k, давайте считать, и x это число единиц вот именно в этом катом столбце.
Ну чему равна тогда вот эта вот внутренняя сумма?
Гениально, да. Вот эта внутренняя сумма равняется x на m минус x, правильно, совершенно.
Но это сколько есть пар? 0,1.
Не совпадающих элементов. x на m минус x.
Опять пользуемся сакральным знанием, который мы сегодня применяли, что минимум парабола достигается в точке минус b поделить на 2a, или там, где производная равна нулю.
Ну короче, очевидно, что это больше либо равняется m квадрата на 4, минимум достигается, когда x равно m пополам. Это абсолютно очевидно.
Ой, да. Почему минимум-то? Максимум, да, она с минусом, все, глупости опять сказал.
Да, конечно, у нее вот так теперь, вот так теперь все направлено, да.
Минус x квадрат меньше либо равняется, конечно, m в квадрате на 4, извините.
Зарапортовал. Так радовался, так радовался, что зарапортовался.
Ну меньше либо равняется. Смотрите, какая прекрасная оценка. Она от k не зависит, а от x не зависит.
Чудное дело, получаем не больше, чем n раз m квадрат на 4. Все, у нас все готово.
Значит, мы получили, что m на m минус 1, на m минус 1, куда пишешь 2?
Диверсия какая-то просто. На d меньше либо равно, да, n на m в квадрате на 4.
Так, шлеп, шлеп. Что-то такое получилось-то.
Ну ладно, неприятно. На m надо как-то выразить. А, еще можно сделать один шлеп.
Так, ну ладно. Значит, у нас получается 2 m минус 1 на d меньше либо равняется n на m.
Следите внимательно, я что-то иногда лажаю. Но вроде правильно.
Ну что, надо m вынести за скобку теперь как-нибудь.
М...
В какой стороны его лучше написать? Наверное, вот с этой, да?
Во-во-во, да, я хочу 2d написать, да. 2d минус n, правильно?
Да, m на 2d минус n меньше либо равняется 2d.
Опа! И вот, по-моему, все получилось.
m не превосходит 2d поделить на 2d минус n, потому что 2d больше чем n и делить можно.
Ну, целая часть, потому что m это целое число.
Успех, да. Не налажал.
Так.
Вот.
Теперь смотрите.
Ну, хорошо бы понять, это вообще граница идиотская.
Вот она так просто получена двойным суммированием.
Или не идиотская?
Она совсем не идиотская, потому что берем матрицу Адамара.
В нормальной форме.
Ну, матрица Адамара, да. В нормальной форме.
Не буду писать аж, это известно, что в нормальной.
Так, отбрасываем левый столбец.
Который из сплошных единиц.
n на n, конечно, да. Ну а какого еще n?
При котором знаем, что она существует, или верим, что существует, как хотите.
Ну, понятно, n на n.
Отбрасываем левый столбец.
Отбрасываем левый столбец.
Потом заменяем все минус единицы на нули.
Просто заменяем.
Ну, как можно вот так?
Прибавить матрицу из сплошных единиц, разделить пополам.
Заменяем все минус один на ноль.
И рассматриваем код из строчек полученной матрицы.
Вот какой это код.
Какими параметры?
Ну, n-1 первый параметр, потому что мы отбросили левый столбец.
Значит, длина каждой строчки теперь n-1.
Так, кодовых слов. n штук.
Осталось понять, какое минимальное расстояние между словами.
n пополам, правильно.
Ну, я могу нарисовать, конечно.
Там есть единицы, есть минус единицы.
А дальше они вот так как-то пересекаются.
Но у них общих вот этих n на 4 и вот этих n на 4.
Ну, значит, n пополам.
А можно было сказать, что сверху единицы расстояния все одинаковые,
потому что скалярное произведение и скалярный квадрат одинаковые.
Все же знают формулу, которая как теорема косинусов.
Модуль х-у в квадрате это х на х плюс у на у минус 2ху.
Ну все, значит, если скалярный квадрат n-1 фиксирован,
скалярное произведение фиксировано, там минус единицы, ну все.
Ну, повлиял он на то, что левый столбец из единиц был,
поэтому как было минус единиц, а расстояние осталось, да.
Да, расстояние осталось тем же.
Именно расстояние скалярное произведение изменилось,
а расстояние осталось тем же.
Ну, в общем, n пополам здесь.
Ну, то есть, если мы сейчас подставим вот в эту оценку,
в которую у нас возникло эти параметры,
как мы их подставим, значит, то такое d,
d это у нас n пополам, m это у нас n,
а n виноват, это у нас n-1.
Ну, что я могу сделать, я хочу вот сюда подставить.
2d, соответственно, это n, это 2d,
2d-n это n, минус, но не n, а n-1.
Ха-ха, получилось, ха-ха, получилось n.
Вакурат m. То есть, коды, которые естественным образом
получаются из матрицы Адамара, вот как я сейчас описал,
они оптимальны с точки зрения границы Плоткина, они её достигают.
Мы подставили вот в эту дробь параметры, которые у матрицы Адамара получились.
n заменилось на n-1, потому что такова размерность сейчас,
d это n пополам, но вот подставили и получили вакурат n.
То самое, которое у нас здесь получилось, если матрица Адамара существует.
То есть, существование матрицы Адамара эквивалентно достижимости границы Плоткина при данном n.
Опять я сказал что-то лишнее.
Вылетела птичка, всё записано, да.
Эквивалентность, конечно, не очевидна.
Но и существование следует, по крайней мере.
Да, да, что-то я тороплюсь иногда, извините.
Не, ну, конечно, не эквивалентно, да.
То есть, это может и эквивалентно, но это уже надо доказывать.
Это теперь с меня спросят.
Да, задача с тремя звёздочками.
И с одной решёточкой.
Да, да.
Первый человек на пистехе, получивший 11 баллов на экзамен.
Так, ну что, у меня ещё есть время.
Ещё время, значит, с матрицами Адамара я считаю, что мы на этом покончим.
Тема неисчерпаемая, как и все, которые я рассказываю.
Но я стараюсь довести до какого-то такого состояния, когда хоть понятно зачем, как это работает.
Но дальше это надо разбираться глубже.
Это понятно.
Короче, я хочу сейчас перейти к теме, которая тоже очень важна и которую многие встречали.
Это то, что называется первообразные корни и индексы.
Это следующая естественная тема из теории чисел.
Она ещё и в том смысле очень естественна.
Вот мы только что говорили про кодирование, а она в каком смысле про шифрование.
Первообразные корни и индексы.
Так, ну времени у меня не так много, поэтому давайте я попробую начать какие-то общие определения.
А там посмотрим, что я сегодня успею.
Так, смотрите, вот пусть есть какое-то натуральное число m.
Есть какое-то натуральное число m.
А есть какое-нибудь число a такое, что a и m взаимно простые.
Есть какое-то число a из приведённой системы вычетов по модулю m.
Из приведённой системы вычетов.
Понятное дело, что если a возвести в степень phi от m, то по модулю m получится единица.
Это теорема Эйлер.
Это все знают.
Но, вообще говоря, вы, наверное, знаете, что бывают и меньшие, чем phi от m числа,
такие, что a, возведённая в степень этих чисел, даёт тоже единицу по модулю m.
Такое бывает.
Например, если a равно 1.
Мне очень нравится этот конструктив.
Друзья, понятно, да? Такое бывает. Наверняка у вас примеры уже были.
В общем, давайте обозначим дельта.
Минимальное число.
Ну, естественно, больше либо равные единицы такое, что a в степени...
Хрень нарисовал.
...а в степени дельта сравнимо с единицей по модулю m.
Ну, дельта – это дельта а та, конечно. Дельта зависит от а.
Да?
Да, это называется по-разному.
Значит, в алгебре это действительно называется порядком элемента a в группе.
Ну, или там... Понятно, значит, дельта называется порядок.
Элемента a.
А теоретико-числовики обычно говорят показатель a по модулю m.
Ну, то же самое.
Синонимичный термин.
Показатель a по модулю m.
Ну, это действительно порядок.
В мультипликативной группе нашего кольца, которая образована числами взаимно простыми с вот этим m.
Так, ну, есть очевидное утверждение.
Вот уж точно упражнение без всякой звездочки, но могу доказать.
Давайте даже докажу, хотя оно абсолютно тривиальное.
Дельта является делителем числа phi от m.
У любого числа a, его показатель или порядок, это делитель phi от m.
Ну, если это не так, то есть phi от m равняется delta там какой-нибудь k плюс r,
то, конечно, a в степени delta k плюс r сравнимо с a в степени r,
потому что a в степени delta сравнимо с единицей, ну, значит, это будет a в степени r,
ну а r меньше чем delta, потому что это остаток отделения.
Ну и получается хрень.
Потому что вот это, это a в степени phi от m, это сравнимо с единицей по теориями Эйлера,
получается, что а в r тоже сравнимо с единицей, и вот это хрень.
Так быть не может, потому что r меньше чем delta, где delta минимум.
В общем, это стандартное, очень простое рассуждение.
Дельта, конечно, является делителем числа Фиатэм.
Вот, ну давайте назовем А первообразным корнем.
Вот теоретика числовики ставит именно так, ударение
всегда, то есть не первообразно, а именно первообразно.
Хотя, в принципе, люди уже по-разному говорят.
Первообразный корень по модулю М тогда и только тогда,
когда дельта от А таки равняется Фиатэм.
Ну, почему такой корень хорош чисто математически?
Наверное, понятно, если такое число вообще существует,
это интересный вопрос, самый главный вопрос, существует
ли оно, но если оно такое существует, то оно порождает
все элементы приведенной системы вычетов, своими
возведениями в степени.
Ну, приведенная система вычетов, да, это по сути
мультипликативная группа просто этого кольца АЗМ.
Полная система вычетов, ага, ну ничего-ничего, да,
приведенную, конечно, порождает, потому что нам, конечно,
все время важно соблюдение вот этого условия, иначе
ничего не получится.
Ну, просто, если мы рассмотрим числа, там, единица А, А квадрат
степени Фиатэм, давайте без единиц, потому что А в степени
Фиатэм, это снова единица, если мы такие числа рассмотрим,
то это все разные числа по модулю М.
Это понятно почему?
Ну, это тоже верно, да, но я не знаю, мне показалось
полезнее понять, что вот это все разные числа, а значит
их Фиатэм, они разные, они все взаимно просты с М,
то есть они действительно порождают приведенную
систему вычетов.
Так, друзья, то, что разные сами докажут, это очевидно.
Вот, то есть это такой порождающий элемент, опять же, математически
кажется замечательным следующий факт, раз они
порождают все числа взаимно просты с М, значит, можно,
внимание, товарищи, вот это уже ключевой момент,
значит, можно определить в некотором смысле логорифом
по основанию такого А от любого числа из приведенной
системы вычетов.
Правда же, да?
Ну так, логорифом по основанию А от какого-то, какую там
букву использовать Б, Б имеется в виду взаимно
просто с М, то есть из приведенной системы вычетов, это и есть
как раз та степень И, нет, это и есть такое И, то А в
степени И сравнимо с Б по модулю М.
Про логорифмировать можно.
Тоже непонятно, а зачем, для чего, вот вообще ничего
непонятно.
Да, чтобы интересно было, красиво, можно построить
такой вот анализ на конечных полях, если М, например,
это простое число, тогда у нас получается не кольцо,
а поле, там возникает красивый анализ.
Это бы все, может быть, даже и хрень, но это, знаете,
как я все время пропагандирую, что не потому математика
прекрасна, что у нее есть приложение, а потому у нее
есть приложение, что прекрасно.
Вот это прекрасно.
И это оказалось очень прикладной вещью, как некоторые из вас
наверняка знают.
Вот это как раз основа для шифрования.
Почему?
Потому что выяснилось в какой-то момент, что операция
нахождения вот этого логарифма, это что-то ужасное.
В том смысле, что уже десятилетиями никто не может придумать
полинамиальный по сложности алгоритм.
Одна из труднейших проблем современной дискретной
математики и криптографии.
Как найти такой логарифм?
Ну, давайте я вообще-то его переобозначу, все-таки
принято писать не логарифм, а инд, называется это индекс
в теории чисел, хотя действительно в криптографии слова индекс
не употребляют, а говорят дискретный логарифм, дискретное
логарифмирование.
Ну, это просто постулат такой, никто не может придумать.
Я знал нескольких людей, причем очень серьезных,
неферматистов, которые заявляли, что они знают
алгоритм, но никому не скажут, потому что там их типа убьют.
Ну, вы знаете, хорошие математики тоже иногда сходят с ума,
поэтому я не исключаю, что они были просто сумасшедшими
уже на тот момент, но они были хорошими математиками,
известными.
Может быть, действительно, кто-то там им платил за это,
я ничего не знаю.
Я не видел, конечно, ни одного алгоритма, который
бы дискретно логарифмировал за полином.
Так, теперь вопрос, товарищи, поднимите, пожалуйста, руки,
кто понимает, что я имею в виду, когда говорю за полином.
Хорошо, это круто.
А теперь скажите мне, вот в данном случае, если
вам дано число А и дано число Б, вернее, дано число А,
что значит за полином?
Совершенно верно, именно за какую-то степень обычного
логарифма числа А, ну, двоичного, например.
Ой, М, конечно, да, М, М, М, не А, конечно, М.
По какому модулю мы работаем?
Так, вы понимаете, да, что сложность числа – это
всё-таки количество цифр в нём, то есть логарифм
дистичный.
Поэтому, если мы хотим полином, то полином должен быть именно
от дистичного логарифма.
Я надеюсь, что когда все поднимали руки, имели в виду
именно это.
Ну, полином – это как-то многочлен какой-то степени.
Конечно, опять, с практической точки зрения, если многочлен
имеет 25-ую степень, то, наверное, это не очень хорошо.
Но, тем не менее, математики, вот они так разделяют – полином
не полино.
Но в бесконечной перспективе очень даже, но пока до компьютера
не считают даже до 10% нормально, ну, как-то вот, да, пока не
повезло.
Вот.
К сожалению, через одну минуту прозвенит звонок,
поэтому рассказать вам, во-первых, как это действительно
используется в шифровании для тех, кто не знает, а
многие не знают, я уверен, я сегодня не успеваю.
Хотя это 5 минут буквально, но не успел.
Вот.
Ну и кроме того, мы, конечно, будем доказывать, что такие
первообразные корни на самом деле существуют.
Например, они существуют по простому модулю, по модулю
степени любого простого числа, кроме 2-ки любого
нечетного простого числа.
Там по модулю 2-ки, 4-ки, ну, а начиная с 8-ки уже их
нет.
Вот это мы все аккуратно докажем и про шифрование
я расскажу.
Ну это, видимо, в следующий раз все.
