то пока я сразу предупреждаю значит то что мы сегодня будем изучать так это будет сложная
структура да я всегда так говорю потом она как с халявой но это реально сложно вот поэтому
если вы хотите чтобы на слово оказалось халявой от вас потребуется максимальная мобилизация вот
то есть да потому что скажем так знаете как был петр митричев до алгоритмы в реальной жизни они
но они другие вот совсем другие вот сегодня будет совсем другой алгоритм то есть поэтому
олимпиадах не знаю где вам может такое пригодится но у нас курс алгоритмов они курс олимпиадного
программирование все-таки поэтому скажем так это ну скажем так используется правда
видимо правда возможно в теории хотя какое-то практическое применение эта структура иметь
может на самом деле и весьма неожидан нет ну что такое может быть ну как сказать минус
с помощью искать можно код в общем-то тоже если разобраться не сильно сложный вот ну если там
во всех деталях разобраться конечно вот вот ноха но с другой стороны сразу предупреждаю разрыв
шаблона начинается прям вот с самого начала просто на уровне просто определение вообще задание
интерфейса типа что она вообще что эта структура вообще делает вот собственно
да чтобы было максимально понятнее сегодня вот принес 8 маркеров они четыре то есть надеюсь что
8 цветов нам поможет так и так значит внимание значит наша структура данных называется мягкая
куча вот ну скажет мне неизвестен официальный перевод на русский язык поэтому приходится
говорить так вот официально английское название вот такое ну вот ну как бы вот софт понятно
мягкий ну собственно микрософт вот поэтому то же самое там и так далее вот и так что же делает
это куча вот ну как следует из названия она хранит себе какие-то элементы
хранит себе какие-то элементы и делает следующие операции
ну во первых вставка ну логично да что она еще должна делать ну естественно get mean
но что еще более важно экстракт mean вот так к сожалению мы обойдем тебе без диски ски
ну слету непонятно хотя может мы с вами придумаем как это всегда и
бывает возможно как можно как надо подумать вполне вероятно что мы как в кучу по ночи
выкрутимся вот хотя вот вот хотя скажу так официально интерпретация этого не требует вот
значит что у нас еще есть у нас есть мэлт да это куча сливаемая ну собственно как и все
хоть насколько приличные куча в нашем курсе вот и и и и а в общем-то и все а чем не хватает
действительно рейс но вот как бы декрески и с рейсом у нас напряг так что вы ну-ка давайте
клея как это да как бы сегодня настолько сложная структура данных что я буду подглядывать иногда
вот и так значит вот такой вот у нас интерфейс но
но хотя но хотя в прочем посмотрим что там нам предлагается делать мы мы попробуем сделать так
и так как же нам это сделать но тут вопрос конечно никак как реализовать как хотя бы
что-то подобное это у нас в общем-то дело известное правда вот хотя хотя самое смешное что да ладно
декрески к ну ладно там ну да декрески конечно будет проблемно сделать ладно пожалуй давайте
дилит мы пожалуй сделаем потому что на самом деле не так-то сложно это и будет сейчас вы
увидите неожиданно почему вот там просто сейчас смешного будет значит смотреть но фишка какая же
как это делать но у нас конечно уже было на прошлом уже на прошлом занятии как минимум три кучи если
не больше которая все это прекрасно делали за разного рода крутости асимптотику то есть были у
нас честные кучи которые это делали были у нас амортизированные кучи ну конечно была ее величество
кучи фибоначии которая делала все кроме удалений за единицу а удаление за логариф мы помним что
да это у нас было круто вот круче конечно было бы если куча была еще и не амортизированная но
здесь просто скажем что по идее существует на самом деле и не амортизированной версии кучи
с такой асимптотикой то есть все вот все делается честно но там первой кучи была где-то в 90-х
годах куча продала акасаки исторически первой такой кучи но в 2012 году вышла статья видимо
тарьяна и там неизвестного мне товарища скорее всего его ученика с названием строгая куча
фибоначии то есть видимо в 2020 году они все-таки допилили но в принципе статью можно найти и
подсчитать вот но значит сейчас мы будем делать значит поставим себе более высокую цель значит
у нас структура данных софт хип принимает константу эпсилон значит эпсилон у нас будет от нуля не
включить на до одной второй включить да так у нас да в шаблонах у нас крыша даблы не принято
ставить но мы будем вот внимание значит что же это за эпсилон их фишка будет весьма неожиданный
все операции будут работать за от единицы амортизировано кроме им сорта
нет логарифом дворечный один но просто логарифом один делить на эпсилон по сути
да но у нас репсел меньше единицы поэтому шута но обычно но то обычно чаще пишут все-таки так и
мы будем этого придерживать то есть это будет то самая какая-то тактика вот но возникает вопрос
да то есть да это выглядит как мы зафиксируем эпсилон сейчас будет зафиксируем эпсилон и
забабахаем кучу которая будет работать вот так ну например мы можем забабахать кучу но можем
взять маленький эпсилон например 1 делить на н тогда получится инстинкт логарифом а все остальное
за от единицы были ли у нас кучи которые умеют такое ну ну как сказать если выкинуть мэлт то
были потому что мы выяснили что там если выкинуть мэлт то даже обычная куча на самом деле работает
с логарифом инсерта и все остальное за от единицы просто надо делать правильную амортизацию но
реализация менять не надо да то есть если этот то есть как это получается на уровне такого мозга
интеллектуального чита но вот они на еще там реальной какой-то эффективности то есть тут
уже реально какой-то там перегладываем куча каких-то попахивает вот но правда с мэлтом конечно
сложнее нет декрески за единицу то ты прикол да крутизна кучи фибоначи основная в том что
у нас декрески за от единицы работает вот так она вот мы больше ради этого пришлось там кучи
фибоначи реально переделывать вот в этом и фишка вот в принципе можно сказать что и кучи фибоначи
обладала бы такой симпатикой септу сказала стоял лог двоичный n правда а а фишка такая
смотрите идея нет а значит кучи фибоначи давайте напомним давайте вот напомним так была у нас
такая красивая фиолетовая куча ой ой а тут видно что начинается картинка картинка называется только
открыл маркер они уже не пишут замечательно хотя нет он черный классный ладно так вот вот он вот он
цвет моей мечты вот он да вот значит давайте напомним официально 7 точка кучи фибоначи говорит
так мы все делаем за единицу кроме удалений которые мы делаем за логарифом вот но там есть какие-то
потенциалы которые позволяют вот оставлять стоимость вот такую но на самом деле идея такая
сверху этого потенциала можно еще навесить такой потенциал чтобы в инсорте был логарифом а экстракт
мины дилит были единиц так это сделать да то есть да технология уже мы прошлый раз а по прекрасно
пробировали то есть помимо вот у нас там были какие-то там монетки вот эти да то есть это был
там какой-то потенциал да то есть типа там на каждое дерево кладем монетку и там на каждую
помеченную мершину кладем по две монетки было да ну там были какие-то там их монетки так вот
давайте введем еще монеток то есть давайте на каждый элемент будем класть логарифом n рыжих
монеток ну где рыжий этот цвет который не встречался у монеток раньше вот то есть получается
инсор получится за логарифом да но при этом до 4 экстракт мины дилит мы будем просто оплачивать
вот этими монетками и получится кайф то есть принципе то есть так вот то есть как вы понимаете
сам по себе все кроме инсорта там все кроме инсорта заединито это само по себе не достижение
но имеется в виду следующее мы нет мы когда анализируем на самом деле то есть это все уже
при анализе проходит то есть мы говорим что у нас там есть куча с которой мы там с нуля сделали
несколько последовательных операций даже системой куча да если мы знаем что суммарно в ней элементов
было не более чем n то есть не более чем он элементов принципе добавлялась то а симптотики все
вот такие потому что мы можем загим числом условия еще раз пробежаться по там всем выполненным
действием и собственно оплачивать их вот этими монетками вот кстати до это логика будет применяться
и здесь то есть нам по большому счету нужно будет показать что все операции то есть по сам но то
есть по большому счету будет сделано так что если у нас в кучи суммарно было вставлено вот столько
там как-то n n элементов то все операции суммарно вообще с кучами были выполнены за n лог 1 дилит на
epsilon плюс ну количество вызова вот этих операций вот такая с целью нас будет вот такая но то есть
идей на амортизационный анализ в общем-то именно в этом и состоит вот понятно и деда
вот нет проблема в том что есть такой вопрос действительно нет я не в смысле ругаюсь
плохой вопрос вопрос прям суто выше действительно то есть проблема то есть я просто как раз предыдущего
проблема не в том что у нас все за единицу а тут инсад это само по себе уже не новость для нас но
проблема действительно в том что я все можно ставить и побольше например одну ладно страшно
вторую третью и тогда кажется что мы все умеем делать за вот единица а с точностью
что такое точность но вот но на самом деле да но то есть конечно понятно что нет самое
смешное что нет мы не собираемся хранить какие-то даблы в которых хотим угроблять точность хотя
возможно идти оттуда и бралась забираю вперед мы хотим хранить какие-то камешки ну как всегда
мы кладем камешки достаем минимумы дам про камешки мы только умеем взять два камешки
сказать кто из них меньше капсу вот вот ну-ка и ноутрич на укул так же такое невозможно но
мягкая куча с этим и не спорит она заявляет следующее что не не я не гарантирую что вам
когда будет вам гетмины экстракт мин то вам достанут именно экстракт мин но но да более
того она может вообще никогда не угадать ну кроме случая когда она вы прям последний элемент
достанете но когда вы достает последний элемент он понятно минимальный да там больше никого нет
значит внимание внимание значит смотрите значит но здесь здесь на самом деле соблюдано но куча
достаточно хорошая в определенном смысле оптимальная но вот но она требует значит соблюдать
следующий вариант смотрите дело в том значит у нас есть вот элементы элемент мы будем
называть ки ну ключик вот так вот внимание вот сейчас максимально внимательно смотрите
у каждого элемента будет псевдоним
да официальное название сите и почему-то да вот он будет больше либо равен ключа
всегда то есть у каждого элемента ну то есть у каждого элемента на самом деле есть вот псевдоним
вот то и значит вот я как вот я как раз это объясняю так что не волнуйтесь как бы да
так как бы не волнуйтесь просто из той мысли которые хотел сказать я сказал только первое
предложение а мысль длинная что нередко у меня наблюдается ну в общем вы я думаю если вы
ходите на лекции то ну вообще в принципе на лекции ходите же иногда да вот то как бы вы можете
заметить что у лекторов часто это встречается ну потому что да тут вот как бы уже вы поступили
на фистех тут соответственно как бы это подозревает что вы готовы собственно понимать более продвинутые
мысли чем в три слова логично правда ну ну вообще говоря подразумевается что 10 если честно так
вот так вот значит смотрите значит мысль такая смотрите значит куча значит куча хранит в себе
значит эти ключи и каждому ключу присваивает псевдоним вот ну какой-то псевдоним с который
ей удобно работать гарантируется что для каждого элемента его псевдоним не меньше чем его реальное
значение по факту на самом деле псевдоним это тоже ключ но просто возможно какой-то другой кстати
чего бывает более того чаще всего ключ и псевдоним будут совпадать да ой такое бывает более того
такой часто будет ровно за счет этого у нас и крутая симптутика достигается вот там более
того там за агим псевдонимом они там целыми автобусами ехать будут на самом деле вот так
вот но пока на уровне инварианта у каждого значит значит у каждого этого товарища значит
значит все такое и теперь верен инвариант вот сейчас максимально вот сейчас надо
понимать прям максимально буквально потому что вот шаг влево шаг вправо это не про и будет
неправда значит будет такой инвариант значит если в кучу или енот или ее точнее и или в ее
но от позже слитые части было с магно было добавлено
но добавлено в смысле инсерта именно инсерта это важно
там суммарно n элементов
будет ров и он элементов то
но вот то в текущий момент времени
в куче не более чем
epsilon n ну давайте так и введем но официально видимо по-русски это называть испорченных
элементов хотя после английской статью очень хочется звать по коррапчинах но потому что
английский термин коррапт вот поэтому как бы поэтому я иногда видимо будет по коррапчины
но тот самый главный вопрос что это значит но как уже как вы уже наверное догадались
элемент называется испорченным если его псевдоним с ним не совпадает то есть условно говоря то есть
мы пишем что там и там меньше этого сети это значит испорченный давайте так и напишем испорченный
то есть коррапт это типа корумпированный так а вот такие элементы официального названия даже
не имею ну то есть это просто нормально и честные обыватели ну посмотрим но честными
хорошими как это честные хорошие красивые умные и самые самые самые самые вот так в
кавычках я конечно пишу но и так далее вот так теперь давайте вот внимательно посмотрим да вот
еще что да то есть обратите внимание то есть тут очень легко ошибиться да потому что вам может
показаться что там гарантируется что в каждый момент времени в куче то есть там допустим если
epsilon 1 5 то есть вам может показаться что там вариант говорит о том что в каждый момент времени в
куче по коррапче на не более пятой части элемент так вот нет это не так то есть ну потому что в
будущем то мы можем добавлять чем проблема ну нет ну можно сказать и так то так неудобно
мысли мне кажется почему потому что мы тот и прикол что мы же в будущем будем что-то добавлять
добавлять удалять что-то делать там могли быть совершенно верно да и вот это я хочу обратить
внимание спасибо именно именно потому что обретите то есть например пусть epsilon 1 5 допустим вы
добавили то есть это лишь означает то есть если epsilon 1 5 то есть если вы добавили туда 100 500
элементов то это означает что гарантируется что пока вы не добавите 100 501 по крайней мере
гарантируется что в каждый момент времени у вас в куче не более чем 100 500 поделить на 5
испорченных элементов да именно да вот именно такая подлянка то есть в карте в принципе
самой внутри самой кучи если было добавлено сильно больше элементов по коррапчиной могут
быть хоть все вот куча в этом смысле вообще удобно работать конечно все коррапчины так давайте
выдавать все подряд потому что куча до куча официально объявляет я даже это здесь напишу
то где-то мим и экстракт мим реально куча будет выдавать по сетею то есть она присвоит то есть
она присвоит какой-то псевдогим более того гарантируется лишь что псевдоним она присвоит
один раз и навсегда ответ нет псевдоним может в процессе ну то есть и так изначально когда
она его примет она будет называть элемент по имени ну то есть забирай вперед скажи но потом
она будет присваить ему все больше и больше псевдонима вот и можно да изначально элемент
может романтично думать что просто она будет больше поэтому будет называть его более красивыми
именами ну вы типа там вася василий василий петрович там вот это все но по факту там будет
работать немножко по-другому нет она и будет хотите сбавиться она просто нет она просто говорит так
значит так ты вася а ты петь а нам так значит идите к садитесь к автобус и теперь вы все будете
так кто из вас меньше петь а значит в оба там так кто из вас больше петь а так в оба будете петь
автозак такой будет условно вот более того к ним теоретически может присоединиться коля и он
тогда тоже будет петь а да более того в какой-то момент обнаружено что есть вася петь а коля но
вот а подъехал еще один какой-нибудь автобус сережей витей значит мы за от единицы сумеем
объединить эти два автобуса ну или кто там больше да может быть сережа я не знаю вот то есть вот
оказывается но вот очень удобно но как вы уже поняли автобус будет реализован как как
двухсвязанный список но для того чтобы там два автобуса объединять за вот единиц
вот казалось бы зачем все это надо вот зачем эти автобусы дизельно то есть зачем это
действительно надо ну то есть это позволит кош работать быстрее но возникнет вопрос а какой
глубокий смысл в этом сём нет нет нет но смысл такой на самом деле да то есть конечно все но то
есть крейша автобусы будут объединяться что будет очень удобно да то есть зато сказано так как
достать экстракт мино то есть как достать минимально очень просто мы берем автобус с
минимальным сетам с минимальным псевдонимом и просто выводим оттуда одного человека
но если это ну как бы понятно если но то есть если где-то минуту просто его показа просто
его демонстрируем вот что да но а если его но а если экстракт мим то соответственно его
отпускаем вот то есть в общем тогда если вам дальше выдадут экстракт мим то в общем-то
достаем из того же автобуса еще человека и так пока не там не закончится да но с нашей точки
зрения они все уже на одно лицо вот поэтому тут получается так вот значит соответственно
вот то есть вот такая вот дичь и так красота получается
вот так что же у нас тогда получается но то есть как бы да давайте сначала подумаю как это
вообще нам поможет хоть где-нибудь то есть зачем нужна это вообще страшная технология с автобусами
но вот нет упростить тогда но тут возникает вопрос нужно и про да это позволит там упросить
жизнь по оси в точке но как бы какой-то смысл нам даст потому что так-то теоретически можно
было упростить себе жизнь уже полюбившись методом ну вот но вот но на самом деле но вот но
оказывается что если внимательно как бы работать с этим вариантом то какой-то смысл это нам даст
потому что но потому что нет потому что на самом деле там идея может быть на самом деле достаточно
ростая все нот и то есть там и там идея может быть достаточная пр Feldman первая идея которая
может возникнуть это ну там вот вот классический нод то есть ты там какая-то про простая такая
вещь на идей но то есть надо хочется например там допустим добавите ли это есть там дано
эн элементов вам нужно но там допустим вас на insan студентов вам нужно номинировать кого-то
стипендию кого-нибудь, ну вы думаете кого? Ну ладно, ну вот, конечно, в идеале, конечно,
хочется самого лучшего, но самого лучшего, это прям вот, прям надо действительно, там совсем
всех там прям по пунктикам сравнивать, это сложно, поэтому ладно, нам пойдет, ну давайте возьмем
кого-нибудь топ-10 процентов, просто кого-нибудь из топ-10 процентов. Если у вас есть вот такой аппарат,
то это сделать очень легко. Берем epsilon равно, там, к чему-нибудь, к чему оно там равно, 1 десятая,
и добавим туда всех товарищей. Вот, понятно, да? Ну потом будем считать, что у него ключ чем
меньше, тем лучше. Ну сейчас дойдем. Вот, давайте добавили все элементы, а после этого взяли и
достали какой-то элемент, первый попавшийся. Я утверждаю, что этот элемент попадает в топ-10
процентов, если epsilon равно 1 десятая. Так, вот давайте подумаем, вот попробуем понять,
почему это логично или нелогично.
Положим противно, тогда у нас в автобусе есть размер автобуса из порченных элементов.
Нету, ну, во-первых, автобусов несколько, во-вторых, давайте их все-таки списка называть. Вот. А так что-то
я прошу, у кого-то там мало ли какие-то ассоциации, кто-то возникнуть просто. Вот. Так вот. Так,
ну, во-вторых, списков несколько, на всякий случай. Вот. Так, и чего?
Пусть мы получили из не только 10. Так. Но у нас из порченных элементов не больше, чем это, на 10.
Значит, все остальные честно упорядочены по ключу. Вот. Значит, среди не из порченных элементов у нас
будет элемент, который не позже, чем тут есть. То есть гарантируется то, что между списками корректно.
Что корректно? Ну, гарантируется, что мы достанем элемент, у которого псевдоним среди всех минималем.
Это все, это все, что гарантируется. Это вообще все, что гарантируется.
Нет, псевдоним уже совпадает с какими-то другими ключами. Ну, могут, ну да. И что?
Нет, ну, то есть, да, мы показали, что среди не из порченных у нас есть. Давайте рассмотрим минимальный не из порченных элемент, он точно не в топ-10.
Так, минимальный. Не из порченных. Так, ну, минимальный из не из порченных, ну, да, в топ-10. Там, ну, в топ-10, да.
Ровно на конце топ-10. Он не больше еще на конце топ-10 находится. Да. А мы достанем либо его, либо элемент с меньшим псевдонимом. Да.
Но если мы достанем элемент с меньшим псевдонимом, то он меньше чем минимум. Да, да, да. Так, ну, вот, ну, давайте попробую еще раз.
Попробую сказать то же самое, может быть, чуть-чуть другими словами. Да, хотя идея абсолютно верная.
Действительно. То есть, давайте подумать, то есть, фишка на самом деле такая.
Итак, предположим, что мы достали действительно какой-то, то есть, какой-то элемент.
Допустим, у нас вот этот вот какой-нибудь кеймин вот такой оказался. Теперь внимание, вопрос.
Нас интересует, сколько элементов может быть меньше его?
Ну, вот, ну, хочется сказать сколько. Ну, давайте подумаем сначала, а сколько элементов может быть больше его?
Ну, опять же, утверждается, можно гарантировать следующее, что когда мы просто достали из кучи элемент, то утверждается, что все неиспорченные элементы заведомо больше его.
Почему? Ну, потому что этот элемент меньше либо равен, я не знаю, испорченный он или нет.
Но я знаю, что он меньше либо равен своего вот этого сикея, который реально минимальный, да.
То есть, получается, давайте вот сейчас это вот внимательно надо просто вот, я лучше там три раза повторю.
Значит, сикей мим.
Тут у нас это меньше либо равно сикей.
Просто, ну, вот, равно кей. Вот, допустим, то есть, если мы берем какой-нибудь другу там неиспорченный элемент.
То мы гарантируем, то по вот этой вот цепочке неравенств мы гарантируем, что вот этот элемент точно не хуже, даже, если он испорченный.
То есть, это в принципе означает следующее, что так как у нас, но теперь замечаем, что так как у нас неиспорченных элементов не менее чем 1 минус эпсилон на n,
ну, то есть, в нашем случае 90 процентов, ну, там точнее 90, там, 9 десятых n, то тогда отсюда получается, то есть, что этот элемент, то есть, слева, справа от этого элемента находится там 9 десятых элементов.
Это означает, что слева находится не более чем 1 десятая.
Да, мы просто добавили пока n элемент, да.
Вот.
Хотя, ну, в принципе сейчас мы посмотрим, что будет, когда, если мы будем доставать там второй, третий и так далее, но общая суть действительно такая, то есть, получается, как минимум, на вот такую халяву мы можем найти элементы с топ-10 процентов.
То есть, есть уже аппарат такой есть, просто все добавили, один достали, возрадовались и все сделали, кстати, за линию.
Понимаете, да?
Понимаете?
Вот.
Вот.
Но попробуем усилить, вот правильно действительно упоминался partition.
А теперь вот давайте подумайте, ну-ка давайте я вам даже дам пару минут на подумать.
Смотрите, вот у нас есть, там, действительно у нас бывает задача.
Вот, то есть, у нас была задача посортировать числа.
И в ней был метод решения qsort.
Ну-ка, помните, как он работал.
Да, он там выбирался какой-то pivot и, соответственно, там массив пилился на две части, да?
Ну или, например, если вы ищете какую-нибудь катовую порядку и статистику, тоже выбирался pivot и мы шли в нужную часть.
И мы отмечали, что мы выигрываем, если на каждом шаге все элементы делятся на две части, на две равные части.
Но также мы отмечали, что если они делятся на почти равные части, причем почти, так достаточно растяжимо, на самом деле, да, то есть, там, например, если они отличаются заведомо не более чем два к одному, там, или три к одному, то есть, константа какая-то, то все равно все будет работать за линию, правда?
Ну а сортировка там за n log.
А теперь внимание, вопрос.
Как можно с помощью, как можно выполнить такой partition?
То есть, как можно поделить массив за линию теперь с помощью, как можно поделить массив за линию?
Еще такой штуки на две, ну там, в этом, в указанном выше смысле, примерно равные части.
Так, и что даст это?
Вот, допустим, возьмем epsilon на вторая, что дальше?
Так.
Первый элемент, который мы рассадим, будет точно в первой части.
Так, он будет где-то, заведомо, да, первый элемент может быть где-то, будет где-то в первой половине, да, это мы уже выяснили, да.
Но как бы, насколько в первой части?
Ну в первой половине, да, но как бы, близко к середине или далеко?
Вот, проблема.
Да, такая проблема действительно есть.
И что нам это даст?
А вот, кстати, давайте подумаем, хорошо, про первое мы что-то гарантируем, а что будет, если мы достанем второй элемент?
Ну да.
Так, да.
Чего?
И что?
Да ладно, но в идеале, так, заметим, что куча не запрещала себе работать правильно.
Поэтому если вы просто достали 10 минимумов и взяли их медиану, то ну поздравляю, вы достали пятый элемент.
И что?
То есть это, конечно, если вы Bruce Willis, это, наверно, круто, но если вы просто достали 10 минимумов и взяли их медиану, то ну поздравляю, вы достали пятый элемент.
То есть это, наверно, круто, но как бы для наших целей это не работает.
Если поставить их сам на четвертый, и...
Так.
Первый раз берем элемент, который находится среди первых четверти. Второй раз берем элемент, который находится среди первых четверти плюс один.
Так.
И у нас, вроде, все элементы будут среди первых половины.
Первые как прям вообще все?
Нет, первые...
Так.
И?
И че...
Да, первые четверти, да.
Так.
Ну и нам хватит, мы же отсчитывали...
А что хватит?
Мы разбили на 3 к 1.
Мы разбили первые четверти элементов, которые находятся в первой половине массива.
Не поймете, зачем, правда, да?
Так.
Все оставшиеся, обратите.
И что нам это даст?
Мы разбили массив на 3 к 1.
Пока мы еще не... Пока мы еще ничего не разбили.
Первые четверти находятся в первой половине до максимума.
А, во.
Да, да, да.
Право.
То есть, ну вот правильно.
Нет, просто идея действительно такая.
Вот предлагается давайте вот такая.
Давайте пусть у нас epsilon равно 1 четверть.
И мы достанем из кучи n поделить на 4 элементов.
Потому что как же было правильно сказано?
Первый элемент, он находится...
Он, ну как порядковая статистика, не более чем n поделить на четвертый, правда?
Вот.
То есть, когда второй, который мы достали,
он, как порядковая статистика, не более чем
n поделить на 4 плюс 1.
А причина такая же, потому что, смотрите.
Почему первый не более, чем n поделить на 4?
Потому что мы знаем, что...
Вот.
Потому что мы знаем, что у нас в куче есть
не менее, чем 3 четверти n неиспорченных элементов.
И все эти элементы, больше ли бы равли нас.
Значит, мы не более, чем n поделить на четвертый.
Ну может быть, не более, чем n поделить на 4 плюс 1?
Но каждый раз, когда мы достаем элемент, как бы у нас есть ограничение сверху на количество
испорченных, значит ограничение снизу на количество не испорченных уменьшается на 1.
То есть поэтому получается, что следующий элемент, если предыдущий был n поделить до 4 плюс 1,
то не позже, чем n поделить до 4 плюс 1, то этот будет не более, чем n поделить до 4 плюс 2,
этот n поделить до 4 плюс 3 и так далее. То есть вот такая логика. Если мы так достанем n поделить
то получится n поделить на 2. То есть это означает, что мы достали n поделить до 4 элементов из кучи,
и мы гарантируем, что они все в отсортированном порядке находились бы в первой половине. А теперь
эта идея такая, давайте рассмотрим эти n поделить до 4 элемента и найдем из них честный максимум.
То есть мы не тротуарь последний, который куча сказала, куча нам там гонит на пропалу,
и мы это знаем. Но мы же можем просто из всех этих элементов пробежаться по ним и выбрать честный
максимум, правда? К чему это нас приводит? Не умирайте. Вот, то есть это означает маленькая
прятная вещь, что этот элемент с одной стороны лежит в первой половине, с другой стороны не в
первой четверти. Ну ладно, он может лежать, он может быть n поделить на 4. То есть мы попали в
элемент, который как катая порядковая статистика, то есть там катая порядковая статистика, где k от n
поделить на 4 до n поделить на 2. То есть в принципе все, берем этот элемент, объявляем его пивотом,
и тогда получается, что у нас на каждом шаге от массива будет отпиливаться не менее чем четверть.
Так что вот такая вот неожиданная идея. Более того, на самом деле в оригинале предлагается
брать константовый опсил не 1 делить на 4, а n поделить на 3. И тогда вот таким образом вы
гарантируете, что у вас элемент попадет условно в среднюю треть, и отпиливаться будет уже не одна
четверть, а одна треть. Вот. Ну для того, чтобы вот как у нас катая порядковая статистика
ищется. Берем пивот, первый какой-то каким-то образом за линию выбранный пивот, и пилим массив
на две части. Кто меньше, кто мы и кто больше. И в зависимости от того, сколько элементов оказалось,
мы там в нужном под массиве что-то еще рекурсивно. Но оказывалось, что если мы пивот будем находить,
что массив делится примерно пополам, то будет хорошо. Да, но это нас тоже устраивает,
потому что массив уменьшается хотя бы там в четыре третьих раза. Это означает, что как бы у нас
будет выполнено, то есть получается он работает, первая итерация работает за n, вторая за три четверти,
следующая за три четверти в продрати и так далее. Если это просуммировать, получится линия.
Зачем мы все это делаем? На самом деле мы делаем это для развилочки, чтобы понять
действительно лучше, что куча может. То есть да, у нас, конечно, есть более простая алгоритма,
действительно, как это делать, не вводящий какие-то мозговзрывательные структуры данных,
но тем не менее. Если у вас черный ящик есть, то воспользоваться им очень просто. Более того,
на самом деле мы даже можем попробовать пойти дальше, потому что эта структура на самом деле
о чем? Она на самом деле вот действительно, она о приблизительности. То есть смысл в том,
что чем более точно вы хотите что-то сделать, тем больше итерации вам нужно поделить. Вот
погибите руки. Кто когда-нибудь писал бинарный поиск по ответу? Логично. А бинпоиск по ответу,
где ответ? Добловый. Какая неожиданность. Вот смотрите, вы тогда можете заметить,
что чем больше вам нужна точность ответа, тем больше вам нужно сделать итерации бинарного поиска.
То есть если вам до третьего знака, то там одно дело. Если там до седьмого, то значит еще
там больше итерации надо. Ну как полемиально? Формально в 8-м точке там будет на самом деле
количество итерации. Это там вот тот самый логарифм 1 делить на эпсилон по факту. Но в некотором смысле
да. Правда во входных данных вам еще дан эпсилон и вы должны тоже его учесть. Тогда правда будет
логарифм что-то типа там там max c поделить на эпсилон, но это уже там. Ну max ответ поделить
на эпсилон обычно, но суть такая. Нет, ну эпсилон, ну это уж другое. Ну вот. И так. То есть так на самом
деле получается и здесь. То есть куча позволяет вам сказать, если вам не нужен идеальный максимум,
а нужно что-нибудь типа там это топ один процент, то куча сделает чуть меньше действий. Да,
там ответ чуть-чуть неправильный, но как бы чуть-чуть регулируется. Но чем более, но как бы тут вы
подкручиваете вот это вот как-то. Там вот это колесико вот это вот. И соответственно, чем более
расплывчатым становится чуть-чуть, тем более быстро она вам тычит. То есть в идеале совсем,
когда эпсилон бывает, иногда бывает нас там, но вот эпсилон мы пишем одна-вторая. Но совсем вот
когда эпсилон одна-вторая то есть это что означает? То есть у вас там половина элементов может быть
попорчена. Вот, в принципе да. То есть, к сожалению, если бы, то есть, если бы эпсилон был совсем,
то есть если бы эпсилон был совсем один допустим, то тогда получается, что структура работала бы
вообще за ноль, но при этом испорченными могут быть все. То есть тогда куча, тогда
по сути просто куча будет может там работать просто как очередь. Или просто
приоритетная очередь с роддомным приоритетом. То есть она может там, ну это
если Эпчел совсем равно один, когда Эпчел равно одна вторая, конечно такого нет.
Почему? Потому что мы все-таки должны гарантировать, что первый элемент все-таки
где-то из первой половины. Ну то есть это мы гарантируем, что если мы таким
образом выбираем лучшего, значит он не хуже, чем середнячок. Но тоже в принципе
неплохо, на самом деле во многих случаях. Вот. Гарантия по крайней мере какая-то
дается. Так что вот такая вот красота. Вот. Ну то есть поэтому тут вот настроечка.
Вот. Поэтому в принципе эта структура действует о том, чтобы делать какие-то
неправильные ответы, но почти правильные. Но иногда этого может и хватать. Вот.
Потому что, как бы напомним, вообще для чего эту кучу создавали, зачем-то
страдали в конце 2000 году. Ну ладно, ее там наверное чуть раньше
создали, но те минуты. Значит зачем это создавали? Ну как бы в идеале, как мы уже
сказали, то есть у нее основное ее достижение это уметь строить минус
100. Значить точек везде на обратную функцию О'Кирмана. Да с помощью вот этого, да.
В чем там отдельная песня как? Может быть мы когда-нибудь до нее даже доберемся.
Нет, он абсолютно точный. Другой вопрос, куда куча дает не совсем точные
данные, но видимо там как-то прореживать ребра это позволяет. Вот. То есть там
отдельная песня как это используется, там это все, но вот. Так что соответственно?
Так, тихо, тихо, тихо. Так что там за полтология пошла? Вот. То есть на самом деле
следующая вещь могла быть такая. Как бы давайте, то есть можно, то есть на самом деле еще
предлагается рассмотреть чуть более сложные алгоритмы. Например около сортировка.
Но нет, near sort. Вот. Вот near sort. Нет, то не в смысле сортировка это такого парня,
который л поймал, конечно, да. Вот. А вот near sort. Вот. Что она значит? Нет, это, ну вот.
Он говорит так, а что такое сортировать? Так, то от сортировать, а ну чтобы элементы шли порядка,
а типа чтобы инвекции не было, да? Тогда я предлагаю около сортировку. Давайте скажем,
что я гарантирую, что у меня инвекций будет немного. Ну не более чем, но, например,
нет, просто epsilon squared. Вот давайте думать, а как это сделать? Да, запихнем все элементы в кучу,
достанем их, и что мы тогда можем гарантировать? Да, мы гарантируем, тогда про каждый элемент мы
гарантируем, про каждый достанный элемент мы гарантируем, что справа от нее, что в куче меньше
его осталось не более чем, сколько, epsilon n. Как мы внезапно убедились, да? То есть вариант можно
переформулировать так. Когда вы достаете элемент, какой-нибудь в куче оказалось меньше его не более
чем epsilon n. Ну то есть это не вариант, конечно, боже упаси, но соответственно. Но тогда получается,
что каждый элемент дается элементами справа не более чем epsilon n инверсией, а их всего n
получается радость. Ну, а теперь баги. На самом деле вам в качестве упражнения может дать задачу.
Дан массив? Нет, вот задача. Дан массив. Гарантируется, что в нем не более чем n инверсий.
Отсортировать массив за o от n. Нет, по факту да. Самое смешное, что вставками в том виде,
в котором мы описывали, то есть мы идем слева направо и пытаемся справа налево просвапивать,
то да, это будет работать за линию. Да, потому что помним, мы работаем за о от n плюс число инверсий.
Потому что свапов мы делаем ровно столько, сколько инверсий. То есть там фактически это
можно интерпретировать так, что если есть два соседних элемента такие, что левый больше правого,
давайте их посвапаем. То есть в принципе, если у нас осталось не более чем n инверсии,
то как бы мы за линию все сделаем хорошо. На самом деле мы можем не остановиться и на этом,
потому что если мы сейчас придумаем более нетривиальный алгоритм, то окажется следующая вещь.
Тут мы просто говорим, что инверсии не более чем epsilon квадрат, а можно потребовать более
продвинутую вещь. Можно потребовать, чтобы для любого элемента x расстояние до от получившейся
позиции x до правильной, позиции x до правильной, не более чем epsilon n. Нет, у нас задача была
напарник. У нас в домашнем задании была задачка, которую можно формулировать так. Допустим,
нам уже дано, что расстояние от каждой вершины до правильной позиции не более чем epsilon n. Ну-ка
давайте, за какую симпточку можно отсортировать? Да, как выяснилось, в том домашнем задании это
было бы там n логарифом двоичный epsilon n. Ну там было число k, ну вот вы там,
собственно, доказали, что идеальная симпточка это n лог k. А ну-ка, кто решил эту задачу, кстати?
Ух ты, классно, простая задача. Ну вот, молодцы. Значит, смотрите, ну а теперь идея такая-то,
как довести массив до такого состояния? Ну утверждается, что да, что Куча может нам в
этом помочь и дать нам асимптотику n логарифом двоичный 1 делить на epsilon, но заметим, что если
мы сложим вот это и это, то мы, в общем-то, n лог n и получим. Нет, ну понятно, ну лучше n лог n мы,
идеальную сортировку точную мы лучше, чем за n лог n, и не сделаем. Но просто фишка в том,
что мы теперь разбили ее на две части, и каждую из этих частей, видимо, умеем делать оптимально.
Ну потому что про это вы уже доказали, что это оптимально, ну а про это, соответственно, отсюда.
Следует, что, как бы, вот можно сделать вот за столько, но быстрее нельзя. Ну да, ну как вычислить,
ну не вычислить, но как бы, если мы сумеем вот эту часть делать быстрее, чем за вот столько,
то вот это плюс это будет быстрее, чем за n лог n противоречия. Формально вот. Да, вот.
Но остался только вопрос, как мы это будем делать. Ну тут, к сожалению, как мы уже поняли,
просто пихнуть все элементы, а потом достать не получится. Ну потому что, ну если просто подоставать,
то, ну там просто подоставать, то как бы каждый конкретно, то есть, на самом деле,
проблема такая, что каждый элемент, он как бы не сильно правее правильной позиции, там может быть,
ну там вот ошибка будет такая, в одну сторону. То есть, условно говоря, там больше элементы,
сейчас как бы это сказать-то. Ну, короче говоря, минимум, то есть, на самом деле,
минимальный элемент может отказаться практически в конце массива. Ну может же быть так,
что вы там, допустим, при epsilon будете доставать, там вот при epsilon равном, там какого-нибудь там
n-птичка, здесь будете доставать, там этот n-птичка, там давайте, а нет, лучше по-другому, давайте так вот.
Пусть у вас epsilon равно, допустим, нет, то ладно, лучше в терминах этих. У нас просто ошибка едет на 1 каждый раз.
Ну по сути, да. То есть, как бы вы, то есть, допустим, если epsilon n у вас, допустим, epsilon n равно, допустим, 57,
оказалось, да, то что это означает? Это значит, что вы на первой трассе можете достать 58 элемент, потом 59,
потом 60 и так далее, а потом в самом конце неожиданно останутся элементы с первого по 57. То есть, более
того, они как-то моментом будут уже совсем все попорчены, поэтому они в принципе могут уже быть
даже пошафлены, минимальный элемент может вообще в конце прийти. Вот, то есть, может быть такое,
по крайней мере, вариант не запрещает. Вот, то есть, поэтому, то есть, получается, что, то есть,
с другой стороны, да, мы гарантируем, что там каждый элемент, видимо, там сильно левее своей
правильной позиции не окажется. Вот, то есть, потому что мы знаем, что элементов, то есть,
элементов, меньших его, оказывается, сейчас в куче осталось немного. То есть, это означает,
что он там левее своей позиции, там на, больше чем на epsilon n не окажется. Но у нас две стороны.
А может это сдвинуть, короче, записать, в какую позицию мы хотим записать, но сдвинуть это,
понятное дело, на epsilon n по полам влево и запустить поэтому с консортом каким-нибудь. С консортом чего?
Нет, ну, короче, мы же можем как-то сортировать числа быстрее, чем за n чисел? Нет. Нет, жаль.
Это камешки, это те самые камешки, да. А что позиции? Мы ж заранее не знаем, какие позиции правильные.
Нет, если на каждом, нет, знаете, очень легко сортировать камешки, если на каждом
камешке написано, куда он при сортировке должен стать, знаете. Я больше скажу, куча для этого не
нужна никакая. Нет, ну, по приколу-то может и можно. Ну, знаете, да, сортировка с подсказкой, да.
Да, да, да, знаете, это что-то типа, да. Ну да, как это да, это называется вода. Вот вам вопрос,
вот вам 4 варианта ответа. Я беру, можно подсказку? Конечно. Ну, это как-то так будет, видимо, да.
Вот. Итак, значит, что сейчас будет предлагаться? Сейчас будет предлагаться такой тоже неожиданный
достаточно алгоритм, но нет. Скажем так, он, конечно, вам честно это предложит. То есть предложит,
но предложит в том плане, что да, мы засунем все элементы в кучу с параметром epsilon, ну или подумаем
там каким, может быть, там плюс-минус. Вот. И после этого их все выпишем. Понятно, да? Что нам это даст?
Вот давайте, выписали элементы, они нам даны вот в эти порядки. А теперь фишка такая, мы их будем
не просто выписывать. Дело в том, что как мы убьемся позже, у нас мы про каждый элемент, да,
то есть каждый элемент мог быть испорчен, но мы можем записать когда. То есть когда его конкретно,
собственно, так сказать, объявили испорченным. Вот. То есть куча в принципе может это честно
записать. Ну, скорее наоборот. Стали, да, то есть это когда он стал тем самым китайцем,
которого официально стали на одно лицо путать. Вот. Значит, да. То есть как бы позже убедимся,
в принципе, эта куча умеет. Ну да, идея очень простая, просто на самом деле, как бы более все
элементы у нас сидят в этих листах. И на самом деле пока лист находится, ну там скорее всего так,
изначально лист находится просто в листе из себя любимого и как бы все с ним общаются по его
имени и отчеству. Но, ну вот, то есть проблемы начинаются только как только там этот автобус
объединяется с каким-то другим листом. В этот момент тогда как бы испорчены все кроме одного,
но там уже для простоты можно считать, что испорчены все. Потому что так как мы минимум,
так как мы элементы можем достать, вот, кстати, обратите внимание, так как у нас
элементы хранятся в автобусах, в листах, то, кстати, вот доставать элемент по итератору на самом
деле очень просто. То есть это может просто привести к тому, что мы тут попытались достать
минимум из какого-то листа, а он опа, пустой, там все уже это убежали. Вот, ну в этом случае мы
говорим, ладно, так убираем этот автобус, достаем еще. И так пока, ну где-то у нас элементы были,
поэтому там удалять, на самом деле, да, мы оставим. Вот, да, то есть не путать с дикриски им, пожалуйста.
То есть мы как бы не можем сказать там человеку лучше, потому что там, ну, то есть так, дикриски,
хотя дикриски сделать можно, ладно. Ну, давайте, ладно, на всякий случай в кавычках напишу,
потому что это небезопасная операция, конечно, вот, но хотя, то есть в принципе, то есть она там
в потенциал тоже нам кое-что испортит, поэтому там, поэтому, может, лучше на всякий случай,
давайте мы ее не будем говорить, вот. Хотя, ничего, нет, понимаете, нет, то есть теоретически можно
сказать, если элемент уже находится в автобусе, в котором находится еще кто-то кроме него, то в
принципе, да, его можно уже сделать дикриски, в общем-то, ничего не поменяется. Да, но проблема,
но если он максимальный, а он, в общем-то, тоже, кстати, с точки зрения анализа будет считаться
испорченным, на самом деле, я вам забираю вперед скажу, поэтому проблема будет только в том,
что если этот элемент на самом деле еще не попорчен. Чего? Ну, тогда, понимаете,
но эти автобусы тоже в какой-то структуре сранятся, вот чем проблема, и тогда, и это там то,
что он стал меньше, может, ты там, можешь привести каким-то нетривиальным сфтапом, и это, и это не
очень хорошо. Чего? Какую? Ну, это будет другая структура. Нет, просто это будет другой структуре.
Нет, понятно, что дикриски можно сделать за, там, выпили этот элемент и вставь его под новым
именем, конечно, но тогда это как бы будет не завод единица, а завод вот этой варианте будет,
получается, если вставлен, там, получается, дикриски тоже нужно считать вставкой. Вот,
поэтому тут вот с этим аккурат, то есть в конце мы можем подумать на тему того, нельзя ли сделать
дикриски. Так, тихо, тихо, тихо. Нет, там вообще другая технология и даже другая обратная функция
термана. Тем более, да, Torub работает на числах, то есть там, напоминаю, мы ищем кратчайшее
расстояние, только когда веса А не отрицательные, В вкладываются в битность вашего компилятора,
но других ограничений нет, тогда мы гарантируем, что мы все найдем за В плюс Е. Да, в общем,
где битность может быть там какая-то в каждое время и ограниченной, но сколь угодно большой.
Вот, но об этом мы там, о таких вещах мы будем еще отдельно разговаривать, так сейчас мы говорим
о камешках. Значит, камешка предлагается делать так, значит, внимание, сейчас вот такая первая
нетривиальность будет, смотрите. Давайте попилим, то есть попилим эти вот блоки элементов, то есть
элементы попилим на блоки. В каждом блоке будет два Эпсилон-Н элементов. Да, да, мы все еще,
мы решаем задачу Нирсорда. Значит, в каждом блоке будет, допустим, два Эпсилон-Н элементов,
допустим, округленных век. Вот, без особого, ну там так, да, можно, видимо, без особого
ограничения обществе там считать, что во всех блоках ровно столько элементов. Вот. И возникаю,
ну вот, значит, что с ними теперь хочется делать? Вот. Значит, хочется с ними делать вот что. Так
как их два Эпсилон-Н, то заметим, что в момент начала работы с каждым блоком, то есть откуда эти
последствия элементов бралась, мы их пихнули, еще раз напомню, да, мы все элементы наши Н,
этих элементов, которые мы хотим типа сортировать, значит, мы их пихнули в кучу,
просто Эпсилон-Н элементов, а потом достали и выписали. То есть такой софт-хипсорт опять
выполнили, да. Вот. Но про каждый элемент мы знали, когда он испортился. Понятно, да? Так вот,
нам интересное следующее. Заметим, что вот в момент начала обработки, скажем, вот этого блока,
да, то есть как минимум Эпсилон-Н элементов были не испорчены, правда? То есть какие-то элементы
так и не испортились, то есть может быть кто-то под своим именем, собственно, всю эту систему
прошел. Вот. То есть как-то вот. А кто-то наоборот. А кто-то когда-то испортился в процессе. А кто-то
уже был испорчен на этот момент. Но таких испорченных не более, чем Эпсилон-Н, значит,
не менее, чем Эпсилон-Н. Тех, кто испортился, если испортился, то уже где-то здесь. Так вот.
Если мы про каждый элемент храним, когда он испортился, то тогда идея такая. Давайте возьмем все
элементы, которые испортились именно внутри блока. На каждый из блоков. Я в каждом блоке такое делаю.
То есть вот я рассматриваю, то есть вот эти элементы у меня будут не испорчены,
не испорченные на момент начала блока. Нет. Когда вы вставляем элементы, он изначально может
быть даже не испорчен. Но когда он там портится, это Куча сама решает, когда его испортится. Нет.
Куча, смотрите. Куча, правда, гарантирует один вариант. Она гарантирует, что псевдоним элемента
никогда не уменьшается. То есть как бы неожиданно. То есть условно говоря, если она уже там внутри
себя для своих целей отобрала у элемента доброе имя, то она ему уже не вернет. Вот. Ну вот. Такая вот
злая Куча. Чего? Злая Куча? Нет, она не злая, она мягкая. Нет, на самом деле просто не надо ее как бы
воспринимать как злу. Нет, она просто, она просто немножко вставшая, понимаете. То есть поверьте,
если у вас будет 100 тысяч детей, давайте. Слушайте, проверьте, знаете, на самом деле
уставшие родители в какой-то момент уже там действительно могут уже действительно путать
даже двоих детей. А если это еще и близнецы, то в адекватном состоянии нет, но уже когда общая
усталость на эти проблемы такая действительно все-таки есть. Так сейчас, тихо, тихо, тихо. Какой вопрос?
Почему удаляли? Ну смотрите, имеется в виду на момент начала блока. Потому что мы знаем,
что если мы добавили в кучу элементов когда-то, то в каждый момент времени в куче находится не
более чем epsilon n испорченных блоков. Ну вот твой элемент. Рассмотрим вот этот момент времени.
В этот момент времени было не более чем epsilon n элементов, которые были испорчены. Но вот в
этом блоке среди вот этих элементов их всего два epsilon n. Значит как минимум epsilon n элементов
на этот момент были не испорчены. То есть давайте на момент начала блока я вот тут стрелочку нарисую.
Так вот. Ну допустим, я идентифицировал там про каждый элемент, что они там были
испорчены на этот момент или нет. Так вот, идея такая. Значит, идея такая. Внимание. Давайте-ка
среди этих элементов найдем x итой. Ну где вот у меня вот это первый блок, это второй блок и
так далее, это будет итой блок. И после вот это вот будет x итой. Ой, так, что я все пишу одним
цветом, когда у меня куча маркеров. Вот. Давайте, о. Да. Вот. Вот, значит смотрите, вот x иt. То есть
что это такое? То есть это минимальный в блоке вот этот вот обведенный элемент. Ну минимальный
в смысле по реальному ключу. Естественно, а не по псевдониму. Понятно, да? Да, нет, нет, нет. Смотрите.
Ну смотрите, заметим, что я из каждого блока могу такой достать. Вот будет у меня такой x1,
тут у меня будет x2, тут у меня будет еще что-то и так далее. Ну начнем с простого утверждения.
Ну на самом деле утверждение такое. x1 меньше x2, меньше x3, меньше и так далее, меньше xl. Ну пусть у
меня l это количество блоков. Ну давайте еще для простоты считать, что все элементы попарно
различны. Вот. Вот такая радость. Вот. Чему это нас приводит? Почему это так? Давайте,
вот простой вопрос. Почему это так? Не обязательно, потому что этот элемент может быть здесь,
а может быть и здесь. Нет, ну не совсем так. Минимальный элемент, да, хорошо, вначале не были
покорапчены все, но мы же выбираем минимальный не вообще, а выбираем минимальный из вот тех,
чтобы кого достали вот на первом шаге. То есть из них минимально может оказаться кто угодно буквально.
Ну можно, ну вот. Ну и что? Ну может он, когда его сначала покорапчили, потом достали,
такое тоже могло быть. Нет, мы выбираем элемент, который был в первом блоке,
выбираем элемент, который не покорапчен вот в этот момент времени. Но в тот момент,
когда его доставали, он уже вполне мог быть покорапчен. Да, вот это важно. Ну нет, нет,
они, ну когда мы уже достали их, мы уже не покораптите. Но идея такая, но скажем так,
когда вы достаёте элемент, он может быть покорапчен. Да, мы, нет, ну как сказать,
нет, он сформулирует так, мы можем настроить кучу так, что она вам скажет ещё под каким
псевдонимом проходил этот элемент, конечно, да. Вот, соответственно, то есть это да, она очень
добрая куча, она будет вам сообщать не только её текущий псевдоним, но можете ещё сказать,
когда мы, когда вообще отличный от неё псевдоним вообще у неё появился. То есть в этом смысле куча,
в этом смысле куча вполне добрая. Это, конечно, парадоксально, да, то есть она как бы в какой-то
момент начинает путать детей, но точно помнит, в какой-то момент она начала это делать. Вот, вот.
Вот, то есть получается вот такая радость. Ну так почему же они ассортированы, давайте
внимательно ещё раз поймём. Так. Почему все? От этого пытаемся доказать.
Раз он был неспрощен на начало блока, то... То? У нас было, у нас были все оставшиеся,
которые точно лучше, ну то есть вот правый конец блока точно больше, а то, что мы какие-то штуки
экстрактные, это не сильно повлияет. Ну, то есть мы до хитого начало блока экстрактные какие-то штуки,
и то, что они не сильно на оценку повлияют. Нет, тут не оценка, тут пока простое утверждение.
Ну да, на самом деле, действительно, то есть идея в том, что рассмотрим вот этот элемент,
начало этого блока. Утверждение, значит хитый был не испорчен на этот момент, да? Из этого следует
маленькая простая вещь. Все вот эти элементы, они меньше, чем х. Утверждение, все элементы из первых
именно... Нет, вот это утверждение? А так, на самом деле, более продвинутые, на самом деле, да. То есть
продвинутая версия утверждения, так сказать, утверждение продвинутая, так сказать, для продвинутых,
для продвинутого потока, да? Не, не то, что да. Да, в основном потоки это утверждение почему-то пропускают.
А, ну ладно, к чему их оттаить, там пропускают всю структуру целиком. Вот, вот. Вот, значит утверждение
продвинутые. Ну вот, все, значит, для любого и, верно, что х и больше любого элемента из первых
и минус одного блока. Вот такое утверждение. Да, да, идея такая, что, заметьте, что пока
элемент не попортится, все элементы, которые достаются из кучи, заведомо меньше его.
Потому что они его меньше, как минимум, по псевдониму, совпадающую с ним, а значит, и
реально они меньше. То есть они там могут быть в рандомном порядке, но они точно как бы меньше.
Вот. То есть вот такая вот неожиданная красота. Потому что х и Т на момент начала блока не
покорапчен. Мы так его определили. Да, вот эти все элементы обведены, это не испочено на момент
начала блока. А х это это минимальный обведенный вот этот элемент. Да, то есть вообще верно, то есть
вообще такое, то есть важное свойство кучи. Пока элемент не покорапчен, все элементы,
которые достаются из кучи, меньше его. Вот когда он становится покорапчен, там могут быть проблемы.
Но он может быть покорапчен, пока мы достаем вот эти элементы, вот этот элемент вполне мог
покораптиться. Ну, может быть, покорапчен и потом. Нет, может, нет, после блока его
уже в куче нету, но может быть он может его под своим честным именем и достали. Такое тоже могло
быть, но могло и не быть, поэтому мы не заморачиваемся. Ну, в какой-то момент будем. Нет, сначала начнем
с простого, что у нас х и Т сам по себе больше, чем все вот эти элементы. Да, по факту, да,
можно даже более сложно это, но, по крайней мере, в такое утверждение поверили. А исходя из этого,
мы уже в принципе следует вот эта штука. Нет, ну, на самом деле для сортировки за нужную нам симптомику
этого уже хватает. Почему? Потому что мы нашли, потому что мы таким образом, обратите внимание,
нашли под последовательность длины l, причем l равно, обратите внимание, чему? n поделить на
2n епсилон, то есть равно 1 делить на епсилон. Ну, на 2 епсилон, прошу прощения. Вот, то есть в принципе
это уже, но это уже это не победа, но почти победа, то есть близко к победе. Почему? Потому что мы
нашли такой под последовательность. В принципе, мы теперь можем сделать так. А давайте для каждого
элемента, оставшегося из остальных элементов, просто бинпоиском определим, между какими они
должны встать. А симпточка как раз вот та, что нам надо. Но правда, гарантирует ли это, что они встанут на нужные
позиции? Ну, там на достаточно адекватные позиции? Ну, конечно же, еще нет. Потому что само по себе,
конечно, теоретически может оказаться, что между вторым и третьим, на самом деле,
должно быть напихан прям половина массива. Ну, или по крайней мере из того, что мы сказали ранее,
совсем напрямую, это не следует. Ну, а есть подозрение, что вряд ли между x2 и x3 в реальном
массиве будет напихано прям очень много элементов. Есть у нас почему-то такое подозрение. А давайте
подумаем, почему. Вот давайте, что нам нужно, что нам не хватает вообще. Ну да, реальная позиция x2,
ну давайте думать. То есть, как вы смотрите, да, давайте подумаем. Нет, ну как, ну внутри блока,
ну тут, конечно, непонятно, но давайте подумаем вообще. Но нет, давайте подумаем вот о чем. Хорошо.
Ну давайте подумаем. Давайте попробуем для каждого x2 действительно оценить,
сколько элементов меньше его там точно и сколько элементов больше его точно. Давайте попробуем
сделать. Я сейчас просто тут сотру немножко. Вот. А, уже пробили? Так, ну давайте поправим. Ну
давайте сравним выводы. И так, значит, действительно, то есть рассмотрим вот этот вот блок, в котором есть
вот этот элемент x2 и не буду я его сейчас вот, да. Смотрите, все вот эти элементы, они заведомо меньше
x2, правда? Почему? То есть, ну вот, ну понятно, да, мы уже убедили, что они все меньше. Их сколько? Их 2
епсилон n на и минус 1. Ну хорошо. Вот. Неплохо, да? Вот. То есть, все эти элементы меньше. То есть, получается,
то есть, то есть, получается слева от него, то есть, получается слева от этого элемента, да? Ну то есть,
нас интересует что? Сколько, мы думаем, сколько инверсии этот элемент вообще сейчас нам создает?
Вот сколько существует инверсий с участием этого элемента? Ну нет, не совсем. Вот есть вот эти
элементы. Вот эти элементы с ним инверсию могут создавать от слова вполне, да? Вот же, я бы так
сказал. Все вот это, на самом деле, дает не более чем 2 епсилон n инверсий. Ну это другой вопрос.
Оценить сверху так можно. А теперь заметим, сколько инверсии этот элемент создается вот этими
элементами? Ну вот. На самом деле, я знаю. Так, давайте внимательно думать. Ну давайте так. Вот в
этот момент, ну, в этот момент есть сколько-то непокоррапченных элементов, да? То есть они,
но заметим, что все элементы, которые в этот момент не покоррапчены, заведомо больше нас,
правда? Но так, то есть, получается, то есть, в этот момент времени только покоррапченные элементы
могут случайно оказаться меньше, чем х. Да? Нет, вообще справа. Вот начиная с этого момента. Вы
плюс первым и далее в блоках. Там все эти, то есть только те, которые вот в этот момент покоррапчены,
могут оказаться меньше его. Но их у нас всего, таких покоррапченных, не более чем епсилон n,
да? То есть, получается, тут тоже не более чем епсилон n инверсий. То есть, на самом деле,
можно сказать, вот тут не более чем епсилон n инверсий, и в этом блоке не более чем два
епсилон n инверсий, и они, в принципе, могут даже пересекаться. Что-что? Ну там, ну, не важно,
на самом деле. То есть, ну, можно так уточнять, но это уточнение уже асимпатического смысла не даст.
Потому что, смотрите, если мы гарантируем, что рядом, что каждый элемент, то есть, у вас с
каждым элементом связаны не более чем, получается, 3 епсилон n инверсий. Вот с каждым из этих, да?
Что это означает? Ну, это означает маленькую приятную вещь. Это означает, что каждый из этих
элементов уже отстоит от своей позиции не более чем на епсилон n. Ну ладно, на 3 епсилон n, хорошо,
я наврал. Вот, то есть, получается, мы научились находить под массив размера вот 1 делить на 2
епсилон, так что каждый из этих элементов отстоит от правильной позиции не более чем на 3 епсилон n.
То есть, в принципе, означает это, то есть, это что означает? По факту это означает следующее,
что между каждым из этих элементов, если вы bin поиском будете вставлять, будет этих элементов не более
чем 6 епсилон n, вот, элементов между ними. То есть, в принципе, это означает, что если вы проделаете
этот алгоритм, будет гарантироваться, что каждый элемент отстоит от своей правильной позиции не
более чем на, получается, даже не 6 епсилон n, а 6 епсилон n. Понимаете, да? Вот, а как сделать,
превратить 6 епсилон n в епсилон n? Да, просто сказать, что куча, да, то есть, давайте сделаем
кучу не на тот епсилон, а на епсилон поделить на 6, и в общем-то все. Вот, то есть, это стандартная
анализовская, да? Ну, знаете, как бы, я помню на лекции, вот у нас лектор была такая, вот она,
то есть, действительно, там теория, то есть, там теория, что докажут, что это стремится куда-то
или что-то еще, и там говорят, пусть, ну вот, и там пусть дельта равно, и дальше заподробительная
формула. Тогда там все, все схлопывается, схлопывается, схлопывается, у вас в конце получается не более чем
епсилон. То есть, все, да, то есть, как бы, на уровне изучения доказательства хорошо, но как бы
возникает вопрос, а как это доказательство изобрести? Но когда вы изобретаете, у вас часто получается,
что давайте возьмем вот такое дельта, пошаманим, пошаманим, докажем, что у вас все меньше,
либо равно не епсилон, а 5 епсилон, но вас это устраивает. Вот, потому что там подгоним,
значит, дельта в 5 раз меньше, ну или там во сколько-то нам надо, и скажем, что мы победили.
Да, уменьшим по епсилон просто в куче изначально. Просто утверждение такое,
то есть, давайте все это проделаем не для того епсилон, который нам изначально дали,
а в 6 раз меньше. Вот, и тогда, и тогда мы просто вот погарантируем. Вот, то есть, на самом деле,
можно еще попытаться подумать, что вот эту вот фазу до упихивания элементов куда надо,
на самом деле, там автор умеет делать за линию даже. Вот не бинпоисками вот этими, а за линию.
Вот, ну там чисто за счет того, что можно еще про каждый, ну там можно доказать, что там,
видимо, там что-то типа, то есть, суммарно, то есть, там видимо, ну там просто идея возникает
примерно следующая. Смотрите, то есть, давайте, то есть, давайте, то есть, у нас изначальные
элементы вот как-то расположены, да, вот как-то, да, и теперь возникает вопрос. Давайте рассматривать
у каждого элемента, сколько он создает инверсии именно с вот этими иксами, да, и будем говорить,
что вот если вот, возьмем вот этот элемент и говорим, так, если он создает инверсию с этим иксом,
значит, переместим его в этот элемент и посмотрим на там инверсию с этим, если так вот, будем
двигать и так далее. То есть, будем тогда их вставлять не за логарифом один делит на епсилон бен
поиском, да, а вот прям честными вот этими вставками вот за уменьшение количества инверсий, да, вот,
и тогда окажется, ну окажется, что суммарно этих инверсий, там получается, что-то едва ли не линия,
вот именно вот с ними получается инверсия линия, ну потому что там расстояние, ну потому что, ну там
вот по каким-то причинам происходит, можете там почитать отдельно, то есть, принципиального смысла
это особо не имеет, но вот как бы идея такая. Так что вот таким образом получается, можно делать
около сортировку. Вот, то есть, это вот, но это мы на самом деле, то есть, основная цель этого была,
видимо, просто понять основные свойства кучи, понять, о чем она вообще, чтобы потом смотреть,
как ее строить. То есть, конечно, основная цель и, возможно, даже едва ли не единственная
на текущий момент это, что вот мы именно 100 умеем так круто строить. Вот, но, впрочем,
могут быть какие-то другие, наверное, применения. Я не как, я просто сказал, что как-то это в статье
доказано. Я конкретно этого не доказывал. То есть, нам для наших целей достаточно только показать,
что расстояние между вот этими, каждым из этих элементов не происходит с 6 εn. Ну и еще там,
что там, слева от этого не более, чем с 6 εn, справа от этого не более, чем с 6 εn, вот это.
Нет, мы доказали. Просто каким методом? Мы же как бы добиваем в конце это просто бинпольском,
да, то есть, мы там для каждого элемента просто бинпольском ищем, куда его надо вставлять. Вот,
это мы доказали. А то, что там инверсия линию, мы не доказывали. В нашем случае нет. Нет,
а зачем? У нас и так получился алгоритм за n лока 1 делить на ε. Ну, то есть, было бы круче,
конечно, если мы каждую фазу, кроме кучи, делали за отn, конечно, но настолько мы упсиваться не
будем. Нет, это было уже совсем раньше. Нет, добиться, чтобы инверсии было не более,
чем ε2, это было совсем просто, мы это обсуждали, да, то есть, это с самого начала. Так можно ничего
не делать, да. У нас, в общем-то, и сейчас инверсии может быть ε2, ну или там порядка такого,
но как бы нам это не надо. Нам надо, чтобы каждый элемент от своей правильной позиции находился не
более, чем на εn влево или вправо. А определение около сортировки такое,
каждый элемент находится не более, чем εn, а своей правильной позиции.
А что до этого? Нет. Да, то есть, мы просто усилили требования, по сути. Ну да. Ну,
гирсор два хард или медиум. Так, ну ладно, если еще тут какие-то вопросы, прежде чем мы перейдем
собственно к тому, а как она там вообще внутри устроена. Так, ну ладно, если вопросов нет,
тогда перерыв. Смотрите, да, ну, к сожалению, тут действительно во время перерыва мы обнаружили,
конечно, некоторые уточнения. То есть, к сожалению, да, то, что расстояние между ними
6 εn на основании чистой инверсии мы утверждать не можем. Да. Ну, то есть, мы сделали вывод такой,
что суммарное число инверсии у х этого х плюс первого товарища это 6 εn. Но на самом деле из
этого расстояния не следует, что расстояние между ними реально будет именно 6 εn. То есть,
потому что, ну вот, то есть, потому что расстояние это не особо отношение имеет. Ну, потому что тот,
чего? А, пожалуйста, конечно. Вот, даже хорошо будет. Вот, то есть, на самом деле правильное
рассуждение выглядит так. Рассмотрим элементы х и х и плюс первое. То есть, заметим, что мы с ними
сделали вот какое-то 6 εn инверсии, то есть, подвигали их куда-то, да, и они оказались вот в этом
массиве. Но в этом массиве они оказались не на одной позиции, не на одном месте, а в соседних
блоках. Это означает, что расстояние между ними не более чем 4 εn, правда? Ну, потому что они
находятся, ну, вот в текущем массиве каждый эти элементы находятся в соседних блоках. Значит,
расстояние 4 εn, да. Но при этом каждый из них находится не более чем на 3 εn позициях от
своей правильной. Тогда получается суммарно отсюда, надо вывести, что тут не 6 εn, а все-таки 10.
Вот. Так что маленькое уточнение. То есть, идея, глобально ни на что не повлияло, но вот,
но на константу, конечно, повлияло, да. То есть, оговорочка есть. Вот такая вот радость. Такая
радость. Вот. Ну вот, теперь пришло время думать о том, как же мы это будем реализовывать. И почему
это будет за адекватная симптомика? Каким образом? Так. Ну для этого нам придется еще раз вспомнить
вот эту эпическую реализацию биномиальной кучи без массивов. То есть, я помню, как я помню там.
да, вот сейчас мы это будем, сейчас мы в этом просто будем жить
сейчас мы в этом будем жить, сейчас мы в этом будем жить, сейчас мы в этом будем жить
Шала лесною стороной. Увязался черт за мной. Холю моя мухи. Холю чертовщина.
Вот. Повернула я домой снова. Черт идет за мной. Прямо на плешь ему. И послала к лешему.
Вот. Ой. Какой безобразик. Что оно не стирается? Ну как сказать? Не, ну не-не-не, скорее всего тут будет по схеме Мещерина все-таки.
Ну все-таки оно. Вот. То есть как-нибудь, да. Ну честно скажем. Ну честно скажем, да, Мещерин все-таки был значительно лучше.
Он-то как был компактнее, там это просто да. А поможет? Ну давай попробуем. Так.
Это что за трюк? Это что за трюк?
Ничего себе. Ну-ка.
Ага. Не-не, ну давайте сейчас начнем этой шутки, да, как удалить Мещерина с помощью спирта. Ну это как-то не надо так шутить, да.
Не, ну зачем мне? Не, Мещерина свистеха удалить не надо.
Хендекс это куча. А какая?
Ну нормально. Ну как Пуфа в конце. Ладно. В общем будем постепенно ликвидировать это все. Значит метод поняли, но это можно делать как бы и по.
Не, ну не совсем нет. Лучше не амортизировано, а как вот в очереди на шести стэках по ходу. Аккуратненько делать.
Так вот. Итак, давайте вспоминать. Ну начало на самом деле будет бимемиальная куча. То есть по факту при достаточно маленьком эпсилон.
То есть это просто будет немножко модифицированная бимемиальная куча. Не более того. Ну ладно, чуть более.
Ну а тут вот С весьма неожиданная вещь. То есть идея будет такая.
Что такое достаточно маленький эпсилон? Достаточно маленький эпсилон это когда у нас количество инверсий.
То есть это когда у нас количество испорченных элементов ноль.
Вот. В этом случае тогда у нас элемент вообще не будет отличаться от своей неиспорченной версии.
Мы по сути будем в нем жить. Значит это под своим именем будет до конца жить.
Но как мы это будем делать? Но давайте вспомним. Что вот если у меня есть бимемиальное дерево порядка 3.
Вот какой-нибудь вот такое. Вот давайте вот так вот его нарисую.
Ну например так. Так стоп погодите это. Да это не бимемиальное дерево.
А что? Что мне нужно отпилить, чтобы дерево было бимемиальным?
Да давайте отпилим 9. Ну можно 13, но я отпилю 15 так красивше.
Вот. Это бимемиальное дерево порядка какого? Да, разумеется 3. Помните, да?
Так вот. Мы сейчас схитрим. Значит мы напоминаем. Так давайте сейчас я возьму два маркера и буду ими что-нибудь рисовать.
Вот. Потому что смотрите у нас будет такая цепочка. Так как у пятерочки трое детей, то пятерочка будет жить в четверном экземпляре.
Вот. Это такая пятерочка. Вот. Почему именно столько?
Ну потому что он будет для себя, значит один элемент будет жить для себя любимого, а каждый из остальных будет жить для своего ребенка.
Вот.
Х это значит тут ничего нет. Ну да, к сожалению я умею быстро рисовать фигу, поэтому нарисую вот так.
Вот. Ну короче. Вот. Так. Здесь у нас будет висеть уже ребенок более продвинутый.
Вот. Так нет, неправильно. Вот он будет висеть. Вот.
Вот.
Так. А, ну да, правильно.
Вот. То есть вот это вот технология. Так. И, конечно, его величество. Вот. Так. Это называется. Это у нас называется старший сын.
А почему шесть раздувалось?
А потому что у шестерочки один ребенок. Поэтому у нее как бы есть как бы два, две инкарнации. Просто я как свободный человек и как, собственно, родитель вот этого восьмерочка.
Вот.
Так. Значит тут у нас девяточка, тут у нас. Так, ладно, давайте я эту восьмерочку сотру все-таки, потому что, я думаю, ее уже все запомнили. Ну или записали.
Так что давайте вот так сделаем. Чтоб совсем красиво было. Давайте эту мы уберем.
Вот.
Так, смотрите. То есть вот тут такое дерево. Значит так. Значит тут важный момент. Девяточку мы будем рисовать. Вот.
Да, что ж такое? Что мне все время хочется так низко идти? На самом деле надо вот так идти. Вот девяточка. У девяточки двое детей.
Поэтому рисуем девяточку, рисуем девяточку. А, ну в принципе все. Да, рисуем пустоту.
Вот. Тут у нас.
Вот. Тут у нас.
Вот у нас.
Во.
И наконец.
Ага.
Вот такая вот. Вот такая вот. Красота. Понятно, да? Понятно, да.
Вот. То есть помню. Такая депритация дает возможность, конечно, делать всякие удобные вещи.
То есть, ну как минимум, заметим, что тут у нас есть два практически указателя. Есть указатель next.
И есть указатель child у каждой вершины.
Вот.
Так.
Давайте возьмем какой-нибудь красивый цвет. Например, вот кого мы сегодня использовали. Коричневый.
Вот.
И введем теперь понятие rank.
Не, коричневый плохо.
Давайте синий.
Давайте синий. У нас будет rank.
Ну, принцип очень простой.
То есть, если вершина у нас rank какого-то. Например, у нас какого-то rank. То есть, у нее столько детей.
То значит, мы по next у нее rank plus 1 реинкарнации.
Где? Значит, по next мы идем. Значит, это вот просто ее реинкарнации.
И от каждого отходит child. Это, собственно, ребенок. Там ребенок rank 2, rank 1 и rank 0.
Ну, каждая построена рекурсивно.
Вот.
То есть, вот тут rank у нас два. И вот тут, кстати, тоже два.
И тут у нас один. И тут один.
И тут rank везде.
Ну, допустим, 0.
Сейчас. Кто исходит, чего исходит?
Нет, это я нарисовал изначальное дерево.
Просто как оно выглядело в привычном нам виде.
Вот. У нас же оно будет выглядеть вот так.
То есть, мы заметим, что...
Вот. То есть, вот, да.
То есть, здесь, соответственно, тоже rank. Я давайте вот нарисую.
Тут один. Один. И тут 0.
Мы будем так хранить бенемиальные деревья.
А, бенемиальные деревья. Хорошо.
Да. Конкретно бенемиальные деревья. То есть, мы...
То есть, как я уже сказал. То есть, мы будем строить кучу на базе бенемиальный.
Вот. Ну, а с веселыми уголами.
Ну, а я... Нет. Нижнего слоя не существует.
Я его рисую просто, чтобы показать, что указатели child and next из этих вершин указывают в 0.
Ну, в пустоту. В 0. В 0 ptr.
Ну, нет.
Здесь нет понятия левое и правое под дерево.
Ну, на рисунке это так рисую? Да. Но как бы...
Да так, да. Child левое, next правое. Да, хорошо.
Но я могу это везде подписать.
Ну, в принципе, можно и так, но так, на самом деле, более точно.
Потому что, знаете, мы уже обсуждали, что тут, на самом деле, можно неожиданно красиво в этом случае делать сифтапы.
И нам это будет пригождаться. Допустим, мы решили уменьшить элемент.
Ну, так, в реальности мы делать не будем.
Но, допустим, мы решили уменьшить элемент, и вот этот стал 4.
Да?
Тогда у нас возникла проблема. Элемент меньше своего родителя, да?
Тогда идея такая.
А давайте-ка вот эти элементы указателей просто тупо посвапаем.
То есть, условно говоря, next теперь будет указывать вот сюда.
А child будет указывать вот сюда.
Да?
И пробежим теперь вверх и скажем, что теперь, так как этот элемент меньше, то он теперь тут дублируется.
Нет, я дикий.
Нет, так как должно быть.
То есть, мы можем получается child the next, в принципе, посвапать.
То есть, у нас такая интерпретация.
Это, типа, не на нас висят трое детей, а, как бы, фактически, не на нас.
То есть, у меня есть такой двойник, который отвечает за всех детей, кроме старшего.
Ну, да.
Ну, не совсем так.
На самом деле...
Нет, там суть следующая, да.
Потому что мы тут шли-шли-шли и меняли, а потом, как-то, как-то...
Ну, не совсем так.
На самом деле...
Нет, там суть следующая.
Да, потому что мы тут шли-шли-шли и меняли, а потом, если мы оказались левым ребенком, то есть, вот этим next, child,
то может оказаться, что этот элемент родился меньше, и тогда вот эти уже деревья тоже надо посвапать.
Вот.
Ну, как-то, то есть, свапать не надо, надо остановиться, но в целом так.
Вот, понятно?
Вот.
Правда... Нет, в принципе, я забираю вперед, да, заметим, что...
Но, правда, смотрите, в чем отличие будет от Ben-Mehler деревья в будущем?
Да, потому что... Да, что приятно?
Ранг у нас не бывает больше логарифма, поэтому такой дикрифт и работает за логарифм, да?
Но тут будет какая-то вопрос, какой вариант?
Потому что сейчас мы видим, что у каждой, то есть, у нас есть, у каждой вершины есть какой-то ранг,
и у нее child и next указывают на вершины ранга на единичку меньше.
Да?
Вот.
Значит, в будущем, значит, смотрите, у нас будет два мистических вообще,
то есть, мистических варианты, которые будут активно поддерживаться.
Первый. Если в вершине была создана вершина, ей присвоен ранг,
то он не меняется никогда.
То есть, как бы все там, типа, дворянин остается дворянином всегда.
Даже если от него разбежались дети.
То есть, как бы он может перестать, он может расстаться со званием даренства только вместе с жизнью.
Вот, кстати, а ну-ка, кстати, скажите, а каким образом вершина может вообще стать дворянином 57-го ранга?
Ну да, то есть, способ только один.
Если мы решили объединить два дерева ранга 56, то как это в данном, в таком интерпретации делается?
Мы создаем вершину ранга 57 и подвешиваем там эти два дерева к ней кого-то на child, кого-то на next.
Кого на child, кого на next, ну, естественно, на next того, у кого меньше корень.
Нет, в смысле поменять. Нет, ну вот.
Ну, конечно, в саму вершину надо писать вот этот ключ равный вот этому. Да.
В смысле, у каждой вершины определен ранг.
И эти, ну вот, сами эти вершины потом не обязаны быть навеки прицеплены именно к этому дереву.
Почему непонятно? Ну, по сути, в исходном бенмяльном дереве это как бы тот же самый ранг дерева, что...
Нет, в бенмяльном дереве есть понятие ранг, здрасте.
Он совпадает со степенью корня, например.
Ранги не превратились ни во что.
У них ключи поменялись, но ранги – это святое.
Нет, потому что заметим, что мы тут подвесили два одинаковых точки зрения рангов дерева, на самом деле.
То есть, заметьте, что child и next, и в будущем, кстати, вот.
Ну, то есть, по сути, по крайней мере, изначально висят одинаковые абсолютно деревья.
То есть, там корни, у которых имеют одинаковый ранг.
В нашем случае мы видим, он даже на единичку меньше.
В идеальном мире это действительно так.
Но у нас куча мягкая.
Вот. Но мягкость, вот эти, к сожалению.
В общем, короче говоря, иногда детей будет меньше.
Но, в общем, в общем, мы видим, что в этой культуре, в этой культуре,
в общем, короче говоря, иногда детей будет меньше.
Да, мы будем, то есть, иногда детей, значит, приходится ликвидировать.
Вот. Но там просто какая суть?
Нет, нет, там, нет, на самом деле, ладно, там, да, кажется, что, то есть, скажем так,
может так случиться, что у вершины ранга 57 детей будет не 57, а меньше в итоге.
То есть, сначала было 57, возможно, когда-то, теоретически.
Но, в принципе, потом их стало меньше.
Но, идейно, но это, на самом деле, не подобно.
На самом деле, детей никто особо не убивает.
Нет, там проблема другая.
Скорее всего, чаще всего, детей будут, там, не детей будут убивать, а на самом деле,
пал родитель.
Ну, что мы делаем в обычной беременной куче, когда у нас погиб родитель?
Мы...
Нет, тогда мы объявляем, что так, дорогие дети, вы теперь, в общем, становитесь
самостоятельными, взрослыми людьми.
Ну, кто-то быстро с кем-то сливается, в принципе, да, ну вот.
Ну вот.
Ну вот.
Да, но это уже другая история.
Так вот.
Нет, друг с другом не сливаются, боже упадет.
Не, ну да, то есть, понятно, да, что они там...
Да, то есть, сами с собой они с лётой услится не могут,
потому что они все попали на различных рамках, но потом всё может быть, да.
Вот, такое может быть, да.
Вот.
Но здесь мы, значит, у нас куча будет мягче.
То есть, она не будет так радикально говорить, там, типа, вот это всё, знаете.
Понятно, что, знаете, если мы хотим, то есть, как бы, есть, конечно, идея,
вот что делать, если мы хотим закрыть там, я не знаю, свиноферму, да.
То есть, что мы должны сделать? Открыть клетки и сказать, свинья, аллилуйя, вы свободны?
Ну, как бы, будет, наверное, не очень.
Так вот, тут как-то надо поаккуратнее.
То есть, если с родителем произошло какое-то несчастье,
ну, там, экстракт-мин какой-нибудь, да,
то есть, его наконец, там его достали,
и он, собственно, там улетел в мир иной за пределы чёрного ящика.
Вот.
Да, вот.
Так что, соответственно, то получается, ну, вот то, как бы возить к вопросу,
что делать с детьми? У нас будет мистическая функция,
которая попытается, может быть, там, ценой жизни какого-нибудь ребёнка,
на самом деле, ну, точнее так, не жизни ребёнка,
а просто сказать, что, слушай, а давай ты, может, будешь не ребёнок,
а давай мы тебя повысим в статусе.
То есть, у нас самый главный вариант, то что ранди растут.
Ну, варианты такие. Во-первых, у каждой вершины ранди не меняется,
хотя вершина может быть ликвидирована.
И самое главное, что у Илчайлда и у Некста одинаковый ранд, причём строго меньший.
Ну, не обязательно меньше, но строго меньше.
Да.
То есть, там обнаружится, ну, работать это будет примерно так.
Значит, первая версия звучит так.
То есть, у нас будет мистическая операция сифт.
Да, вот она будет так называться, сифт.
Давайте,
каким-нибудь хорошим...
Ладно, будет такая чернорабочая операция сифт,
которая будет говорить, вот она говорит, корень потерял себя,
то есть, корень, больше не корень, не корень,
то есть, корень, больше не корень, его уже не существует.
Мне нужен кто-нибудь, кто его заместит.
Как мы это будем делать?
Ну, делать будет так, мысленно, значит, операция сифт будет работать за от,
ну, там, в каком-то смысле длины Некста.
И мысленно она говорит так, вот, допустим, ну, давайте вот этот свап,
допустим, у нас не было этого свапа, то есть шестерочки на месте, все в порядке.
Нет, путь вправо, путь понек, что это инкарнация одного и того же всегда.
Нет, это остается.
Просто детей может быть.
Просто у вершины ранга 57, ранга детей может быть меньше.
56, 55, 48.
Вот.
Поэтому мы попытаемся все-таки сказать, что, ладно, давайте кто-нибудь просто,
то есть, допустим, старший Будемброк умер, значит,
кто-то из детей просто возьмет на себя продолжать его бизнес.
Соответственно.
Вот.
Так что, соответственно.
Но теперь выясняется, как это будет делаться.
Очень просто.
Сифт будет говорить так, так, я хочу, чтобы здесь появился какой-нибудь достойный человек.
Кто?
Так.
Значит, да, ну, по идее логично предположить, что у меня есть ребенок, да.
Ну, наверное, у меня там еще кто-то есть, да, по Нексту, да.
То есть давайте лучше больших детей, у него и так уже большая ответственность,
давайте еще повышать ответственность совсем так, что не хочется,
пока не меря слету.
Поэтому давайте-ка пойдем в Некст и из Некста попробуем кого-то выковырить.
А сифт что делает?
Он, ну, он пытается, значит, перешаманить как-то дерево.
Нет, а что мы требуем?
Что он поднимает на вход?
Вот я это объясняю.
Это нельзя сказать в двух словах, что он получает на вход вот это, делает вот это.
К сожалению, не то.
Да, ребята, у нас новый уровень сложности, да.
Где такие простые ответы, простых ответов нет.
Вот.
То есть это такая вот мистическая функция, которая чуть-чуть перестраивает дерево.
И делает она так.
Она пытается на этот корень найти кого-то из Некста.
Но как она это делает?
Ну, вызывается рекурсивно.
Поэтому думает, так, я тоже кого-то там, кого-то хочется выковырить, пойду я тоже в Некст.
Но это тоже отправляется в Некст.
И говорит, то есть у нас такой рекурсивный стэк получился, да.
А говорит, так, значит, меня больше нету, значит, меня, значит, так, надо кого-то еще, ой, а у меня ребенка нету.
У меня нет детей.
И меня больше нет.
Ничего больше не существует.
Ну, что мне остается?
Так, как бы, мне в принципе остается только застрелиться.
Но у этого товарища, у Некста и Чайда должен быть одинаковый ранг.
То есть как бы должно быть либо два нула, либо две вершины одинакового ранга.
Поэтому что нам остается?
Мы говорим так.
Так, короче, я плюс бесконечность, то есть на мне ничего не бесит.
Все, до свидания.
Я пошел.
Так, и возвращает и будет.
Так, он там пошаманился, говорит, так, отличность, я по идее теперь плюс бесконечность, да.
Но плюс бесконечность больше семи, да.
Что ж делать?
О, а давайте посмапаем деревья.
Вот.
А то и значит, прям буквально посмапаем Чайда и Некст.
И теперь, по сути, тут будет семерка, а тут будет плюс бесконечность.
То есть у меня получилось такое дерево плюс бесконечность.
Видите, да?
Чего?
Чего оно?
Ну, нет, ну как сказать, он нам нужен вот для чего.
Потому что, смотрите, у нас тут есть нолик, да.
Но надо, чтобы вот этой вершины был и Некст и Чайд.
Поэтому просто так мы, конечно, то есть у нас есть, конечно, мечта когда-нибудь этого ребенка выпилить.
Но это пока будет такой эффективный ребенок.
То есть он типа живет, он же потерял смысл жизни, но еще пока живет.
Чисто с целью какой-то амортизации.
Ну, там условно, я не знаю, места на кладбище не хватает, там вот это все.
Но как бы плюс бесконечность, ладно, плюс бесконечность, это явно не приоритет.
Поэтому, значит, тут мы пишем себе 7 и возвращаем.
О, смотрите, говорим, мы нашли тут 7.
А он говорит, так, круто.
Так, у нас ребенок 7, а у меня тут ребенок 6.
Наверное, 6 круче семи, да?
Поэтому делаем свап.
Так, делаем свап.
Так, а что не так?
Ну, помодлю того, что это вообще за безобразие такое.
Соответственно, вот.
Мы вот этой вершине присвоили плюс бесконечность, потому что мы сказали, что из нее корень исчез, а больше у нее ничего нет.
То есть плюс бесконечность, это будет означать в будущем, забирая вперед, и все еще.
То есть плюс бесконечность, это будет означать в будущем, забирая вперед.
Я скажу так, что если у какой-то вершины обнаружилось, что у нее 2 плюс бесконечности…
Значит, и там...
То есть можно сказать так.
То есть если у какой-то вершины обнаружилось, что у нее ребенок, допустим,
вот сейчас как бы это сказать.
А нет, слушайте, я поторопился, извините.
Потому что с плюс бесконечностями на самом деле разговор покруче сейчас будет.
Знаете, какой? Спокойно.
Давайте пока я все это верну.
То есть пока бы, да, временный такой плюс бесконечность есть.
Вот. Но тут я неожиданно замечаю.
А я все чаще замечаю, что у меня тут ребенка нет.
Тогда когда я тут запил себе семерочку, мне подумалось.
Мне подумалось, а зачем эта инкарнация семерочки существует?
Кажется, что эта инкарнация семерочки, или какая-то из этих, она явно лишняя.
Потому что каждая существует для того, чтобы был ребенок. Если ребенка нет, то у меня вот такой бесконечный ребенок.
И тогда я делаю неожиданно.
А вот этот говорит, знаешь, что? Ты, инкарнация лишняя, а давай-ка ты и пошел.
То есть идея заключается в следующем. То есть я как бы удаляю вот эту вершину.
Да, но я уже знаю, у меня будет вариант, что плюс бесконечность это такая эффективная вершина.
Смотрите там Child and Next по-любому.
Ну формально говоря, это не существует.
Да, ну а неформально, ну вы поняли.
Сейчас, подождите, подождите, не волнуйтесь, сейчас этого мы тоже убьем, не волнуйтесь.
Прежде чем мы его убьем, как бы смотрите, у него есть дети.
В общем случае, когда мы будем это делать, я забираю вам вперед, сразу предупрежу.
Может произойти такая ситуация, что жил-был ребенок ранга 57. То есть там вершина какая-то ранга 57.
И обнаружила она неожиданно в результате подобного рода свапа.
Ну вот, что у нее тут плюс бесконечность. Ранга какого-нибудь там, я не знаю, 48.
Вот, и тут у нее соответственно, потому что, и тут у нее соответственно, это вот это у нее Child, ну после свапа.
И тут видимо Next, тоже скорее всего какой-то веселый.
Понимаете, да?
Тоже какой-то Next. Ну вот, и он там тоже какая-то веселая такая же вершина. На тему 48.
Но заметим, что чем это отличается от этой ситуации? Отличается тем, что тут еще какие-то под деревьями висят.
Вот тут висит какое-то реально нетривиальное дерево, тут висит какое-то нетривиальное дерево.
Ну может такое теоретически быть.
Так вот, идея будет такая. Мы заявляем, то есть Shift будет заявлять так.
Значит, смотрите, этого мы убиваем, этого мы убиваем.
А Child и Next, на Child и Next мы подвешиваем вот эти вот под деревьями.
Вот такая вот красивая идея.
То есть у нас произошло 4 операции?
Ну то есть мы обнаружили, что если у меня ребенок бесконечность, то соответственно, что я делаю?
Ну там так, если у меня ребенок бесконечность, то я его типа удаляю.
Ну вот, я его удаляю, удаляю следующую реинкарнацию меня, и как бы сам на себя беру вот эти под деревья, которые там на этой реконации висели.
Но Shift начинает этот процесс прямо в скорне.
Так сказать, рекурсивно.
Нет, погоди, сейчас. Вот сейчас я сказал, как это в общем случае выглядит.
Значит, сейчас я, нет, мы с корнем шли-шли, но нет.
Мы по сути кладем плюс бесконечность и все эти коррелации с плюс бесконечностью и пытаемся восстановить.
Да.
Вот, ну то есть смотрите, вот этого мы, значит, Shift у нас убил, значит это, и к этим мулам подвесил вот этих товарищей.
То есть получился такой ранг один, но детей нет.
Ну вот такое бывает, понимаете, да?
Сейчас. Он уже остановился.
Потому что мы идем теперь рекурсивно сюда.
И возвращаемся из рекурсии сюда.
Но теперь мы неожиданно видим, что у нас опять Next оказался больше Child.
Не порядок, говорим мы, и свапаем детей.
Я их даже прям сейчас честно посвапаю.
Там было 6, 6, 8, я запомнил, а там 7.
То есть вот тут 6, 6, 8, а тут 7 и пустота.
Да, то есть мы их посвапали.
То есть теперь у нас вот так, вот так вот, вот так вот и вот так вот.
Вот так вот, вот так вот, вот так вот, вот так могу, вот так вот, вот так вот, вот так могу.
И конечно их величство ранги.
Вот. И сюда записываем шестерочку.
Вот.
Ой, не то.
Вот. Тут один, и тут один.
Тут ноль, и тут ноль.
Вот. Вот такая красота.
Но, слава богу, на этом уровне никаких проблем не возникает,
потому что next меньше child, а просто копируем из next и радуемся жизни.
То есть, смотрите, что произошло?
То есть, вот таким образом мы, получается, ликвидировали,
так сказать, некоторого, то есть, некого тут минимального ребеночка.
Понимаете, да?
То есть, мы так, да, тут поликвидировали немножко ребеночка,
и за счет этого вот тут модифицировали немножко дерева.
То есть, как бы, да, оно перестало быть теперь идеальным биномиальным деревом, конечно.
Вот. Но, что поделать?
Ну вот. Но, по крайней мере, сохранился вариант,
что у каждой вершины child и next оказывают на вершины меньшего и одинакового ранга.
Понимаете, да?
То есть, вот как бы, мы положили бесконечность,
мы идем вверх, у нас какой-то минимальный ребенок,
мы удаляем такой процедуры, и дальше у нас просто обычность истап.
И нет, но это, ну...
То есть, после того, как плюс бесконечность исчез, у нас остается обычность?
Ну, в каком-то смысле, в каком-то смысле, да,
только с удалением лишних плюс бесконечности, а так да.
У нас больше нет плюс бесконечности у меня удаления.
Но это другой вопрос.
То есть, мы один раз удаляем под дерево...
Ну, это... Ну, типа да.
И после этого у нас идет обычность.
Ну да. Ну, где-то удалять.
Но на самом деле, мы можем поудалять не один.
А как мы можем поудалять не один?
А вот давайте сейчас еще поэмулируем, как сифты будут работать дальше.
Вот, допустим, я еще вызвал операцию сифт, потому что шестерка теперь вышла.
Что будет дальше? Смотрите.
Сейчас я вам это поэмулирую.
Значит, опять же, так, шестерки больше нет,
мы отправляемся в next.
Шестерки больше нет, мы отправляемся в next.
Так.
Ну, эта вершина так и говорит, что там...
Все, я плюс бесконечность, меня взятки гладки.
Так, мы говорим, так, у меня есть два ребенка.
Так, у меня есть next плюс бесконечность, ребенок 8, ребенок меньше.
Значит, давайте свапать.
То есть, наверное, вертикальная восьмерка все-таки лучше горизонтальней.
Вот.
Так.
Значит, пишем.
Что это восьмерка?
Так, сразу замечаем, что...
Так, ладно, так...
Значит, на мне висит ребенок, но его по факту нет,
так давайте его лучше быстренько утилизируем.
То есть, как всегда, давайте моего.
Ну, да, вот это первая плюс бесконечность, видимо, и исчезнет.
А.
Чего-чего-чего?
Ну, 8 не лежит, сейчас 8 как бы с семеркой посвапается, правда.
Но эта бесконечность, да.
Вот хороший вопрос.
Ну, вот, ну, видимо...
Нет, ну, суть, видимо, будет...
Ну, вот.
Ну, вот, ну, сейчас, значит, будем...
Но на самом деле конкретно в идеальном случае, видимо, никогда.
Правда, тем более, что есть оговорчик.
Мы так до конца высасывать из дерева все соки не будем.
Потому что нам же хочется достичь,
чтобы у нас там какая-то амортизация крутая была, да.
Поэтому у нас...
Ну, вот, то есть там с точки зрения этой амортизации мы будем делать так.
Потому что понятно, что там, видимо, дети каким-то образом будут отпиливаться.
Потому что если бы тут была не 8, а, скажем, какая-нибудь там, я не знаю, десяточка, да,
то в какой-то момент обнаружилось, что вот это дерево,
то есть это мелкое дерево ушло бы туда,
и мы бы уже начали из того дерева соки высасывать, да.
Но, то есть получается, этот сифт работает за сколько?
За логарифом.
Понимаете, да?
Нет, ну, в принципе, у нас такая опция есть.
То есть на самом деле можно высасывать до конца,
потому что амортизация...
То есть какая у нас цель амортизации тогда получится?
Цель амортизации у нас получится,
чтобы у нас был, значит, инцерс за логарифом, все остальное за единицы, да.
Но, в принципе, если у нас сифт будет делаться только непосредственно в случае экстракт-мино,
то, в общем-то, получается, что там уж...
там каждый сифт такой делается за сколько?
За логарифом, правда?
Поэтому никаких проблем нет.
Вот, понятно?
То есть вот такая вот радость.
То есть мы аккуратно спускались, аккуратно радовались.
Вот.
То есть, в принципе, в данном случае проблем нет, правда?
Ну, вот.
Но с параллельом так.
На самом деле ранги-то мы не меняем,
но утверждение остается.
Утверждение остается.
Ну, давайте так.
Давайте у каждой вершины будем ставить в соответствие
элементы, которые были когда-то у нее в поддереве,
у нее или у ее потопков.
Ну, то есть давайте так.
Будем считать, что на самом деле там души умерших,
они на самом деле не уходят никуда,
а как бы они идейно с нами.
Вот, вы образили себе такое, да?
Ключай лишний экземпляр?
Чего?
Лишний экземпляр это наша техническая работа, да?
То есть это мы себе вообразили,
что как бы там у меня есть там,
то есть у меня там есть трое детей.
Петя, Вася и Элена, допустим.
То есть понятно.
Поэтому как родители меня получается,
то есть я как родитель Пети,
я должен быть жестким, ремня давать и так далее.
Есть Вася.
Ему ремня не надо,
есть Лена, ее нужно просто очень сильно любить.
И есть я просто обычный человек.
Да, но это работа именно с детьми.
Понятно, там про жену мы сейчас не разговариваем,
естественно, но тут, к сожалению,
такая проблема, что родитель один тут всегда.
Так что поэтому не надо это
совсем в ускоренной жизни применять.
Но соответственно...
Нет.
Нет.
На самом деле, смотрите, у нас двоичное дерево,
на нижнем уровне которого в идеале,
по крайней мере, находится в точности все элементы.
Поэтому как бы их тут суммарно,
вершины, да, не более чем в два раза больше.
Вот.
Значит, смотрите.
Вот.
То есть у меня получается такой детей,
но я мысленно всегда буду
помнить, что у меня трое детей,
более то у них у меня там еще внуки какие-то есть,
и так далее.
То есть ментально как бы да.
То есть более того, они иногда умирают,
но я все равно о них помню.
То есть когда...
Ну, по сути, да.
То есть можно себе такое
вообразить, да.
Ну, вот.
Ну, по сути так.
Официально можно сказать так.
Давайте для каждой вершины объявим количество соответствующих ей элементов.
Ну, точнее так.
Ну, да.
То есть, так сказать,
то есть у каждого элемента есть, так сказать,
родители.
Вот реальные родители, вот этот реальный родитель,
вот этот реальный родитель, да.
Видите, да?
Вот, по факту.
То есть давайте для
каждого элемента будем хранить как-то потомки.
Правда, заметим, что когда child and next свапаются,
то, конечно, у этой вершины
понятие реальные потомки
немножко...
То есть может немножко поменяться.
Но хотя если себя считать тоже своим потомком,
то он меняется, правда?
Ну, потому что потомками
остаются только вот листы или те,
кто был когда-то листами.
А это по одной, что это просто все,
которые когда-либо в процессе были потомками?
Или что-то более...
Нет, ну...
Нет, ну типа того, на самом деле, да.
И тогда два в степени, да?
Ну тогда... Нет, тогда просто
появится, что если правильно это определить,
то идея в том, что как бы у каждой вершины есть
свое вот фамильное древо размера 2 в степеника.
То есть я как бы
получается вот эта вершина,
кто бы... Скажи так, вот эта вершина
именно вершина, а не ключ, который в ней
находится, да? Ну, то есть это
условно, это что? Ну, вот, то есть
когда семью возглавляют там разные товарищи,
но как бы в этой семье
находится, получается, два в степени
как элемент?
Кто-то из которых когда-то
умер.
Вот, то есть получается, что вот этих вот
соответствующих их ровно. То есть как
это определяется? Очень просто.
Изначально, когда стоит вершина
ранга 0, ей соответствует
только один элемент, да?
То есть создается только семья, в которой один элемент.
Но теперь, если у нас есть две семьи
ранга, допустим, два,
то когда они объединяются, то есть
каждый из них соответствует четыре элемента,
по индукции, то тогда
создается вот эта вершина,
и она символизирует, что
на самом деле у нас теперь есть одна семья ранга 3,
которой соответствует 8 элементов.
Четыре отсюда и четыре отсюда.
То есть да, тут кто-то умер,
но мы всех помним, их четверо.
Понятно, да?
Вот.
То есть получается, каждый вершине
идеально
такой соответствует.
Но при этом, что приятно,
заметим, что
отсюда автоматически
следует, что если вот каждый вершине
такой соответствует, то отсюда автоматически
следует, что ранг каждой вершины не может
быть больше логорифма.
Но это соответствует тому, что в обычной
бинмельной куче просто
фактически мы так красиво
значит, там на каком-то семейном языке обсудили, что на самом деле
ранг бенемиального дерева в обычной бенемиальной куче бывает не больше логарифма. Почему? Потому что в бенемиальном дереве ранга K
ровно два степени conversion.
То есть это как бы просто, практически так, это бенемиальное дерево, в котором вы структурно что-то выпилили и
детей как-то посвапали, понимаете, да?
Вот, то есть разве что так.
Поэтому в принципе это уже, если у нас был бы только экстракт-мин, то как бы за логарифм работало, да?
Правда есть маленькая оговорка, да. Слияние у нас, к сожалению, пока работает не за О от единицы, а за О от логарифм, правда?
Ну экстракт-мин мы уже поняли, что мы уже можем сказать, что экстракт-мин работает за
единицу или даже за ноль, потому что в каждой, если инсорт работает за логарифм,
так давайте просто класть туда логарифм, монетка не парится, да?
Вот, нет, как мы, ну как, делаем?
Нет, как мы его делаем? А очень просто, давайте вспоминать, как у нас бенемиальная куча. Что такое бенемиальная куча работает? Это
двусвязный список
деревьев по паре различных рангов, да?
Чего?
Нет, ну на самом деле мэлт будет почти буквально такой же.
То есть когда он будет, правда, ходить и сливать два списка от сортированных по рангам, да, что будет происходить?
То есть он там будет идти, если видит два дерева, он попытается их объединить в одно, да?
Ну и там, ну цепочек понятно.
Вот, то есть это работает за логарифм, потому что у нас все там, он работает за длин списков,
а длин списков, ну там, плюс количество объединений деревьев. Объединение деревьев у нас суммарно не более, чем n.
Ну потому что у нас всего изначально n семей, да?
Ну теоретически, да?
Вот, там соответственно, поэтому это не очень, поэтому суммарно это не очень интересно.
Но это длинный список логарифм, понимаете, да?
Вот, понимаете?
Да, но можно сделать мелкую оговорку.
То есть по сути это такая прикольная, сейчас я вот могу забабахать, прикольную оптимизацию биномиальной кучи.
Оптимизация называется храним минимум на суффиксе.
Ну потому что, заметим, ну да, но смотрите, просто дело в том, что как будет устроена куча биномиальная, а в будущем и мягкая.
Сейчас начнём, я просто сейчас это нарисую. То есть это я нарисовал, как устроено биномиальное дерево.
Это биномиальное дерево ранга 3. Вот в процессе оно может быть устроено так.
То есть мы будем стараться расформировывать его как можно позже.
Ну то есть теоретически мы видим, можем его не расформировывать никогда?
Такое могло бы быть, но у нас будет такая мягкая аккуратность.
Будем говорить так, что если мы поняли, что вершина ранга 57 уже детей меньше чем 57 пополам, то, наверное, с этим родителем что-то не то.
Но там это не оптимизация, это другое. То есть я просто забираю вперёд, предупреждаю, что там будет у нас эффект какой-то, что если у вершины ранга какого-то там К оказалось детей уже К пополам или менее, то мы как бы эту вершину всё-таки расформировали.
Нет, не под дерево, а количество детей.
Да, количество детей, количество потомков, это разные вещи. То есть длину Next имею в виду.
Нет, вы не путаете слияние двух деревьев одинакового ранга и двух куч, каждый из которых состоит из лого.
Нет.
Нет, ну как сказать, понимаете, там фишка будет в том, что, ну непонятно как делать, потому что когда вы делаете инстинкт, то есть создаете новый элемент, как вы это делаете, вы создаете, вы делаете из него дерево ранга 0, из себя любимого.
И куда-то его в этот список вставляете. Объединить дерево ранга 0 с деревом ранга 57 вы не можете, вы просто так не можете.
Не, нельзя. Там вот, там именно важная фишка, что ранг 57 он как бы не с потолка свалился.
Значит, у меня была большая семья, там на 2 степени 57 человек.
Вот, ну или светлых образов их, конечно, да, но вот.
Вот.
Поэтому вот, да, то есть одно дело, что у нас происходит в одной конкретной дереве, а другое дело, когда у нас есть клан.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
куча, выглядит будет так. То есть у него будет даже не двусвязанный, а односвязанный список.
Ну, какой-то вот такой. Значит, в каждом, значит, в каждом из которых...
Ой, да, да, да, я эту штуку забыл. Да, извините, извините, извините.
Так, смотрите, работает будет так. Во-первых, значит, каждая из этих штук будет, значит,
ссылаться на какое-то дерево. Вот оно. Вот, вот как-то так. И это дерево, да.
Нет, этим я хочу символизировать, что ранги этих вершин строго возрастают. То есть, да, размеры
деревьев, конечно, не обязаны быть такими, но тут, допустим, ранг R0, тут ранг R1, тут ранг R2,
там и так далее. И мы гарантируем, что R0 меньше R1, меньше R2, меньше и так далее. Вот. То есть,
в принципе, можно так хранить бенмельную кучу. Ну, типа того, да. Где? Это RL. Это буква L. Нет,
в смысле, вот это L. Это один. Разные. Это разные вещи. Ну, хорошо, хорошо. Вот. Только не надо
говорить, что это E. Так. Ну, вот.
Ну, вот. Так что вот такая радость. Итак, R0 меньше, R1 меньше, R2 и так далее. В общем,
да будет счастье. Вот. Значит, теперь. Но как бы это, ну, видите, чтобы тут не просто деревья храним,
а именно вот, видите, храним такое. Эта штука, кстати, называется head. То есть, там, знаете,
будет такой стракт head. Ну, я вам, да. Чисто теоретически, я мог вам просто кидать ссылку
на статью, и мы могли соследить прямо. То есть, знаете, там в этой статье есть такая приятность,
там написан код. Нет, я просто, знаете, я вот боюсь его вам посылать, потому что сейчас
он начнет читать, и меня перестанете слушать, и тогда все перепутается. Поэтому давайте вот просто
как бы воображайте меня. То есть, нет, теоретически у меня была мысль выводить статью на экран,
на самом деле. Почему с архива? Нет, там... Ну ладно, я вам открою страшную тайну. Эта статья
прекрасно скачивается просто с википедии. Нет, ну почему архив? Нет, почему? Ну, во-первых,
уже не архив, потому что это уже официально опубликованная в журнале статья. Еще в лохматом
двухтысячном. Или даже там в девяносто восьмом, я не помню. Ну, по факту, да. То есть, вы там можете
сейчас просто открыть статью википедии английской, естественно, да, по софтхип. Значит, просто первая,
и практически первая ссылка вот автора там Бернард Чизель. И, собственно, она просто берет там
и скачивается. Даже на скайфа платить не надо. Ну, плох он тем, что вы будете читать архив и не
будете читать журнал. Журнал от этого не дополучит денег. Вот. Нет, а что, ты нашел статью Чизеля про
софтхип на архиве? Скорее всего, нет, потому что, ну, я не уверен, что в этом девяносто восьмом этот
архив реально существовал. То есть, не могу этого гарантировать. Может быть, я не проверял. Может,
может на архиве. Если она на архиве есть, то, скорее всего, она не хуже ничем. Хотя нет, кое-чем она
хуже. За то, что эта статья идеально правильная, вообще адекватная, автор не несет никакой
ответственности. Потому что это, по сути, это почти эквивалентно тому, что оно там висит, то есть,
висит какой-то блок. Вот. То есть, по большому счету, не более того. То есть, как бы опубликовано в
журнале, это означает, что журнал подсчитал эту статью, признал, что она, а, адекватная,
б, интересная. Ну вот. И это напечатал. Еще и поработал, напечатал, там с автором поработал,
чтобы это еще красивше стало, там и так далее. Как бы архив, это означает, я просто вот могу сейчас
это там, то есть написать статью. Вот там воспитание детей. И там написать одну цифру.
Я самые лучшие дети в мире. Все. И опубликовать. Все. То есть, как бы в официальном журнале такое
не опубликуют. Не потому что это неправда, а потому что, ну, как бы там нужно, то есть, видимо,
я там должен еще как-то хотя бы на пяти страницах доказать почему. Вот. Ну и тем более, что, честно
скажем, в мировой практике эта мысль новой, ну, не является. В общем-то, многие специалисты, в общем-то,
это и так прекрасно знают, на самом деле. Конечно. Вот. Ну вот, соответственно. Но, ну, как бы
новой мыслью это не является, поэтому опубликовать в официальном журнале никто не будет. Вот. То есть,
там, соответственно. Вот. Поэтому, вот. Но вывесить это в архиве я могу. Таки понятно, зачем я это
сделаю, но как бы я могу. То есть, обычно вывешивают для того, чтобы, как бы, то есть, какой-то приприим
статьи вывешивается для того, чтобы зафиксировать, что результат за мной. Что у меня вот был этот
результат, чтобы, чтобы потом просто, если обнаружить то, что там параллельно со мной какой-нибудь
автор, там, допустим, называется, работал тоже самый, пришел к похожим выводам. Такое тоже. Ну, такая
коллизия бывает. Чтоб тогда было, что на самом деле, да, каждый из нас это независимо придумал. Ну, или
там, или наоборот, там, доказывать, что там автор у меня там что-нибудь сплагиатил и так далее. То есть,
потому что, а кто-нибудь придет, так скажет, так я, вот у меня идея такая уже была. Господи, я ее
придумал, нет, мы ее придумали, вот, абсолютно независимый индигектор. Это неправда. Она была на
архиве пять лет назад. Так что извиняйте, но тот товарищ был первый. Вот. Ну, там, для, для таких
вещей это, в общем, делается, но отчасти еще для того, чтобы там уже первые идеи вбухать. Ну, не важно.
Вот. Так что, ну, короче говоря, в сухом остатке, если вы там софтип что-нибудь найдете про, на архиве,
может даже что-то интересное будет. Хотя мне кажется, хотя часто бывает, что самое интересное,
что вы там найдете, это ссылки на предыдущие статьи, которые заведомо адекватно. Вот. Хотя
отдельная песня, кстати, какие журналы надо читать, чтобы быть в курсе алгоритмов, на самом деле.
Вот. Не, Код Форсес это не то. Код Форсес это все-таки про конкретно спортивное
программирование. Это все-таки там, скажем так, это наша конкретно-локальная КГКшечка. Это там
фактически. Вот. Все-таки алгоритмы, они все-таки пошире будут. Хоть, конечно, там многие идеи,
в том числе и современные, в олимпиадную задачу конвертированную быть могут. Вот. Так, ну,
чего вы там нашли? А, или вы там просто переписываете, сидите. Так. Не надо этого делать,
потому что тут легко выпасть и потом вообще не попасть уже никуда. То есть, знаете, то есть,
вы в обычной речке, вы там вышли чуть-чуть из лодки, а лодка уже уплыла. Так вот, а это неагарский
водопад. То есть, все, если вы тут вышли, решили войти, то тут вы поняли, что, то есть, в общем-то,
вся остальная группа уже давно там это летит на вертолете, на веревочке вот этой вот. Вот.
Так, вернемся к делу. Так, стоп. Значит, ребят, все. Так, стоп юмор, стоп болтовня. Значит,
смотрите. Итак, у нас, значит, есть цепочка хедов. Значит, каждый хед, то есть, это такой вот,
так сказать, отдельный головной офис семьи. Ну, там, естественно, и сынка на корень. Ну, понятно,
семья висит на конкретном корень. Значит, есть, ну, понятно, в хеде и ссылка на корень. Значит,
указатель на следующий. Ну, гарантируется, что тут ранги соответствующие. Ну, в принципе,
эти ранги можно даже тут хранить. То есть, часто тут хранят, знаете, что хранят? То есть, можно
себе вообразить, что мы тут будем хранить, допустим, ранг. Вот. То есть, мы будем хранить ранг, будем
хранить вот этот вот сикей. То есть, сикей это будет ключик в корне. Ну, понятно, что на минимум
будут претендовать только корни, правда? Ну, как мы обычно ищем минимум? Прибираемся по корням,
выбираемся корней минимум, да? А часто мы еще даже храним указатель на минимум для того,
чтобы гетмин делать за 1. Так вот, для того, чтобы этот гетмин, чтобы этот минимум находить
реально за 1, мы будем хранить неожиданную штуку. Называется она суффикс мин. В прямом. Это
указатель на хед. То есть, указатель на минимум. Скажем так, это указатель на минимум. Ну, тут можно
по-разному делать. По-моему, автор, как ни странно, делает указатель на минимум среди всех хедов,
которые находятся строго позже меня. То есть, вот, например, если глобальный минимум находится
где-то здесь, то указатели выглядят, скорее всего, вот так. Вот. Этот указывает, видимо, на этот,
а этот указывает в аут. Потому что я не включаю себя. Да, ну, здесь, как же сказал, то есть,
на самом деле, только техническими деталями будут отличаться конкретные версии, но вот автор
предложил так. Вот. То есть, как бы, давайте слушать автора. Вот, как бы, видимо, да. Как-то говорит,
да, типа он крутой, у него это вот, да, видите, как пишут. Да, меня надо слушать, я крутой, у меня
желтый пояс на топ-кодике, да. Да, у меня красный, я поёжился, да. Вот. Ну, не важно. Вот. То есть,
вот такая вот штука, так мы её будем хранить. Зачем нам это, значит, этот суффикс Мин оказывается
сейчас нам позволит сделать мэлт за амортизированных от единицы. Ну, смотрите, как мы делаем мэлт? Мэлт мы делаем
в виде, как бы, двух списков хэдов, правда? Да, мы их делаем мёрч. Вам может показаться, что, как бы,
для этого нужно двумя указателями пройти по каждому из этих списков целиком, правда? Ну,
рот прикрывают всё-таки, когда издеваете, не делайте так, пожалуйста. Вот. То есть, вам может показаться,
что для этого нужно пройтись по всему списку. Но часто, на самом деле, это не так. Потому что,
по факту, то есть реальная жизнь оказывается несколько проще. Да, и такое бывает. Чего?
Нет, не в этом дело. Дело в том, что, на самом деле, допустим, у вас, ну, допустим, у вас там, допустим,
куча имени там Маши Васнецовой. То есть, в ней есть четыре ранга. Первый, второй, третий и двадцать седьмой.
Вот. Ну, как билеты, которые она учила, соответственно. Вот. И вы хотите их слить. И хотите вы их слить,
вот. А давайте я так напишу. Вот с рангами, ранги. Вот. А, у меня полочка есть. Вот. Не, вот.
Значит, смотрите. То есть, допустим, я сливаю ранги. Первый, второй, третий и двадцать седьмой. Это у меня в одной
куче, а во второй куче у меня один, ну, я не знаю, два, ну, я не знаю, четыре. И все, допустим, да?
Тогда, ладно, и нолик еще. Значит, как я буду сливать? У меня есть ноль. Потом объединяю вот этих вот, у меня
получается там двоечка. Значит, объединяю вот этих. Значит, у меня тут лишнее двоечку сносим, но, значит,
объединяем. Выходит в перенос троечка. Три плюс три. Это, значит, объединяем получается четверочка.
Четыре плюс четыре. Объединяем. Пятерочка. Ее выносим. А теперь заметим, что, в общем-то, у нас
получилось ноль два пять. А что мы должны сделать дальше? Ну, при идеальном слиянии мы теперь по
этому списку должны пойти до конца. Вот, допустим, тут прям вот 57, 179, 2007. Ну, если она там. Да, не то,
чтобы такие рамки будут в реальной жизни существовать, но все-таки, да? Вот. И так далее. Ну, короче,
вот тут длинная цепочка. То есть, формально при слиянии мы должны были что сказать? Мы должны были
сказать, что давайте пробежимся по этому элементу и эти элементы честно в этот список внесем, да? А
теперь заметим маленькую приятную вещь. Заметим, что мы этого делать не обязаны. Если мы хеды храним
в односвязанном списке вот таком, да, даже если в двухсвязанном, то как бы, да, были вот у меня такие вот там
ссылочки. Что у нас там было? Там ссылочки. Там ссылочки. Вот такие ссылочки были, да? Да, и у нас
тут вот эти стрелочки там поубивались, поубивались, поубивались, да? И тут у меня были стрелочки,
которые тоже там поубивались, поубивались. Вот это стрелочка, вот это. А теперь заметим, что мы
можем вместо того, чтобы там копировать этот список, мы можем отсюда просто отправить стрелочку и
все. И больше ничего не надо. Удобно, правда? И к чему это нас приводит? То есть, как бы мы,
а симточка, конечно, все еще логарифом, да? Но, обратите внимание, логарифом не всех элементов,
которые тут есть. А по сути, нот, а по сути, да, логарифом минимума, потому что мы, по сути,
все сделали за от, можно сказать, от пяти вот этого минимального ранга. Ну ладно, поправка. На самом
деле, формально мы сделали все от логарифом минимума плюс количество слиянием, что тут могла
быть цепочка 5, 6, 7, 8, 9, 10, и нам бы пришлось эти слияния, конечно, делать, да? Вот, но заметим,
что объединение двух деревьев это можно сделать так, чтобы это была учетная стоимость 0. Ну,
потому что, когда вы создаете, скажем, вершинку, то есть, когда вы создаете дерево новое, да,
ну а когда вы создаете новое дерево, вы это, фактически, в инсорте. Ну можно там, ну,
пог dug для начала, можете его обвинить. Вы создаете новое дерево, да, то вы просто
на каждое дерево кладете монетку, там, отдельную серобурмалиновую монетку, вот, и тогда просто,
когда вам приходит время объединить два дерева одинакового ранга, то у вас на это есть две
монетки. Вы объединяете дерево, оплачиваете одну из монеток, а вторую на это новое дерево кладете.
То есть таким образом, получается, вы это сделали за бесплатно. В общем, знаете, что, дайте еще одна
проблема статьи, знаете, какая? То есть как бы вы можете быть готовы, что если вы там открывали
кормонов кучу фибоначи, то там, конечно, таких понятий не будет. Там сделали за бесплатно, вот это
все. То есть там все будет описано там более-менее формально. То есть там потенциал, учетная стоимость,
там все дела. Так вот, а когда откроете вот статью Чезеля, он будет говорить практически буквально
на том языке, на котором я сейчас с вами разговариваю. Вот, да. Ну, понятно, по-английски, естественно,
но как бы идейно-мыслительно, то есть там расписывать, то есть подобного рода штуки он там
расписывать формально не будет. То есть как бы вы говорите, ну, вот это вот понятно, то есть поэтому
остаются только вот там два нетривиальных монет. Нет, ну просто смотри, просто в какой-то момент у
тебя один список закончится, да, а второго будет там вот второй типа встал вот здесь, да. Тогда все,
что тебе останется, то есть на самом деле сюда тебе ходить не надо будет, а просто прицепить вот
этот список к этому и все. Более того, если вы минимум, кстати, поддерживаете вот таким образом
через суффиксмин, то тогда вам останется только прогуляться по этому списку и пересчитать суффиксмин,
а на этом списке суффиксмин не поменялся. Вот. Просто в чем фишка? Так вот, просто я утверждаю,
что подобного рода MLD оказывается, значит, будут сливаться за учетную стоимость от единицы.
Где у нас это было? Вот, потому что тут, да, потому что, да, вот это называется, да, почему у вас
пятой задачей возникла именно эта рекуррента про логарифа минимума, да. Помните такую задачу из
ДЗ? А кто ее решил? О, молодцы. Вот. Да, то есть там вот оказывалось, что, предположим, что вы какие-то два
множества распиливаете на две части, с каждым из них как-то рекурсивно работаете, а потом объединяете
два множества за логарифу минимума. Оказывалось, что суммарно все объединения делаются за УАТН. Ну и
видимо, вот вам, собственно, удалось это доказать. Даже оказалось вроде не сильно сложно. Ну вот,
хотя оно тут не тривиально могло быть. То есть там надо было это делать. Ну вот. Но, на самом деле, вот идея,
на самом деле, здесь именно в этом. То есть, к сожалению, автор не доказывал, почему лог минимум там,
это, почему эта рекуррента работает за линию. Он в этом все сказал, ну там, значит, такая рекуррента
в этой статье, почитайте там что-то написанное по этому поводу. Вот буквально таким в таком стиле
отмахнулся, действительно. Если бы так это он. Нет, он, к сожалению, оценка была, что вот там такая
рекуррента, то есть рассматривалась в литературе, смотри, например, вот эту статью. Но он не сказал,
какую конкретно Лему в этой статье смотреть. Но, по-моему, там я не нашел там точного доказательства,
почему это там линия типа. Ну вот, но не важно. Но для нас-то не важно, ладно, подобного рода
мелочи мы как люди как бы умные образованные, собственно, сами допилили спокойно. Вот. Так, а в чем
проблема? Вот при слиянии мы его поддерживаем просто. То есть мы вот сделали вот это слияние,
да, прицепили в конец. То есть здесь суффикс мины определены правильно, да? На, ну, минимальный
корень среди всех, кто находится дальше. То есть, по сути, типа пробежимся по всем вот хедам,
которые дальше, рассмотрим их корни, выберем минимальный. Вот. Так что вот такая красивая,
амортизация получается. То есть вот фишка здесь заключается в том, что, когда вы объединяете две
кучи, да, то есть можно тоже говорить, что для как бы у каждого дерева есть вот моя виртуальная семья,
да, и у каждой кучи, можно сказать, есть виртуальная семья как объединение моих всех виртуальных
семей, понимаете, да? Ну, такой клан, да. Когда мы объединяем два клана, да, то есть в каждом из них
есть какие-то там получается тут сколько-то элементов в клане, тут сколько-то элементов
в клане, мы их объединили. И тогда оказалось, что объединение этих кланов, получается,
происходит за логарифум минимума размеров этих кланов. Ну, потому что, как бы, если у вас в клане
всего х человек, то у вас рамки не превосходят логарифум х, как мы поняли. Да, естественно,
мы говорим о виртуальных семьях. Так, что опять за шум все время? Ну, за максимум, да.
Тогда мы... Ну, тут и не монетки, тут, на самом деле, просто скорее рекуррента так красиво сошлась. То
есть, как бы, виртуальные семьи сливаются за линию. Вот так это называется. Точнее, виртуальный
клад. Так получается. Вот. Правда, есть, конечно, одна маленькая говоречка, которая жизнь портит,
как мы в будущем убедимся. Но вот тоже, ладно, вот поняли, куча устроена так, и мэл, вот оказывается,
можно делать за линию. Но, правда, если бы не одно «но». То есть, давайте, давайте делать ставки.
Как мы делаем инсорт? Ну, инсорт, да, как всегда, мы создаем кучу на один элемент. То есть, как бы,
то есть, я создаю один элемент, выговорю, что она семья из одного элемента, а потом создаем клан
из одной семьи из одного элемента. И говорим, да, ну вот. И после этого объявляем, ладно, а давай-ка
мы тебя с основным кланом и сольем. Вот. Ну, знаете, то есть, типичная ситуация, то есть, там,
это подписание, то есть, это договор между, там, ООО, Яндекс, там, в лице, там, бла-бла-бла, там,
и, там, ну вот, и там, там, Пупкина Василия Ивановича. Там, о том, что он, значит, там, становится
частью компании, там, ну и так далее. Там, становится разработчиком то, что он разработает,
там, становится частью компании Яндекса, частью компании Яндекса становится то, что он
разработает, то, что, то, что разработает становится частью, именно частью компании Яндекса,
никого, кроме, ну и так далее. Вот. Ну, будете работать в Яндексе, это, вот, будете подписывать
документы такого рода. Вот. Вот. Не боюсь сейчас на этом останавливаться. Вот. И так, значит, так,
так, тихо. Значит, смотрите, с инсортом разобрались. Да? То есть, инсорт простой. С Мелдом тоже. Ну,
с Мелдом разобрались, а потом и с инсортом. Что? Инсорт. Ну, получается, ну, он работает,
значит, он работает, получается, за логорифом. Почему? Потому что в таком виде кажется,
он работает за единицу, но все-таки вынуждены положить логорифом монеток на его будущее удаление.
Вот. Ну, вот. То есть, тупая версия удаления, на самом деле, могла бы звучать так. То есть,
тупая версия удаления могла бы звучать так. Значит, идем, соответственно, в вершинку. Да? То есть,
ну, то есть, находим, ну, мы за вот единицу находим, кого надо удалять, да? И делаем из этой
штуки сифт. Да? В принципе, ну, вот. Единственное, что после этого надо сделать, это мы должны
теперь приближаться по всем предыдущим хедам и пересчитать суффикс Мин, потому что он явно
поменялся. Да? Нет. Нет. Мы вызываем сифт, помните? Ну, давайте так. В идеале, ну, у вас какие
проблемы были, да? У нас были проблемы, что, как бы, в исходной бенмельной куче мы бы просто
выпилили весь этот некстовый путь, и все из детей создали бы новую кучу и ее мыслили, да? Ну, вот.
Да, теперь у нас есть сифт, который за отр2 работает, да. Ну, то есть, можно было и так, и так, и так, и так
работало бы за логарифом. Правда... Нет, какое логарифом? Объединение деревьев или чего? Ну, нет,
почему? Нет, ну, как бы, нет, почему? Как бы, объединение деревьев у нас, как мы помним,
логарифом амортизированное, потому что мы на каждом дереве храним монетку. Другой вопрос, что, когда вы
тут удаляете, вы, как бы, получается, на каждого из детей должны положить монетку для будущего слияния.
Ну, раз вы это все равно... Ну, раз мы это... Ну, то есть, тогда вопрос, как бы, откуда эти монетки
брать, потому что мы этот логарифом как-то хотели амортизировать, да? Но амортизируем мы его очень
просто. То есть, как бы, этот логарифом берется так, то есть, у каждой вершины есть логарифом монеток,
которые ему с рождения дают на черный день, ну, на похороны. Ну, буквально, да, то есть, когда тебе
придет время уходить в мир иной, вот логарифом, чтобы тебя похоронили, а с детьми разобрались. Ну,
не в смысле, а вот... Ну, а в смысле, цивилизованно разобрались. Вот, то есть, какие варианты есть?
Один вариант, давайте не будем заморачиваться ни с каким сифтом вообще, да? То есть, вместо этого
пробежимся тут честно по дереву, значит, там всех этих детей выпишем и тут мерзь сделаем. То есть,
заметим, что на размер виртуального клана это никак не меняется, поэтому потенциальным MLD остаются
делаться за от единицы. Чего? Ну, то есть, ну, смотрите, я рассматриваю разные варианты. То есть,
предположим, что мы делаем как тупо в бенмяальной куче, никаких сифтов нету, просто удалилась вершина,
возьми всех детей, создаешь бенмяальную кучу и в MLD вот в это все. Я говорю, что да, это сработает
за логарифом, а вот это амортизационный анализ MLD в целом это не испортит. Ну, потому что есть MLD,
которые мы часто вызываем, то есть, возьми два разных клана и слей, а тут у нас как бы это просто
как бы наша внутриклановая там техническая работа, да? То есть, мы там внутри для себя какой-то там
маленький технический кланик создали и быстренько влили его в нас обратно. Но это чисто внутри
наша там какие-то там бумажки и перебумажки. Нет, погодите, погодите, кто сказал, ну вот.
Ну давай, нет, можно так сказать, но правда нет, логарифом времени даже, ну вот, но там,
нет, подождите, давайте так сифтом сейчас отдельно разберемся. Пока говорим, что просто у нас нет сифта,
есть проход за логарифом, ну, то есть, за R2, да? То есть, мы удаляем вершину ранга R2 за от R2.
Ну плюс там объединение деревьев, конечно, то есть, мало ли, может, у вас там это объединение,
они скушают этот хет и еще дальше пойдут, такое может быть. Но объединение деревьев у нас суммарно
не более чем N, там в итоге будет, значит, удаление у нас там сколько получается, ну вот. Ну то есть,
здесь у нас получается детей не более чем R2, то есть, не более логарифом, но еще, конечно, для всех
вот этих, кто там справа слева будет, еще придется суффиксумин посчитать, но их тоже от R2.
Да, есть вот именно так, точнее не скажешь, да, да, очень эзотерически-экзотическая, да,
нет, эзотерически-экзотическая, вот так, повернутая какая-то.
Ну типа того, да, то есть, мы там просто сделали какую-то красивую технику, которая позволила
делать за 1, да, что, какой вопрос? Нет, ну суффиксмин это вообще указатель, он как бы не заедит,
но потому что, смотри, ты слева, когда ты, ну потому что, когда ты сливал вот эту гучу без этого хеда вот
с этим вот, да, у тебя два варианта, либо оно закончилось где-то до этого момента и тогда все
это произошло за R2, либо у тебя оно вообще все схлопнулось за то же самое R2 в одно дерево,
единственное, что могло быть, у нас тут появилось, то есть на этом месте появилось дерево R2,
дальше оно не пошло, потому что там дальше больше ранги.
Нет, ну оптимизируем, напомню, что мы там что-то про Epsilon находили приблизительно.
Но, к сожалению, нет, но фишка такая, нет, сейчас мы как бы победили только в том, что фактически мы
научились реализовывать бинвейльную кучу так, что у нее за insert работает за логическим, а все,
включая melt за единицу. Так вот, а это следующий вопрос.
Ещё раз, как мы делаем, как экстракт Мин делать? Мы нашли заод единицы вершину,
которую мы хотим удалить. Значит, тупая бинвейльная куча. Удалим вот весь этот список next,
вот из детей составим бинвейльную кучу и сольём с нашей.
Да, но это логарифом, но это амортизированный логарифом, вот почему. Потому что на каждую
манеру, напоминаю, в insert, когда мы делаем insert, за счет чего у нас insert за логарифом работает?
Он работает, потому что как бы insert сводится к melt, melt работает за единицу.
Я бы даже не копию, а когда создаем новый элемент. Ну даже не эринкарнация просто.
Нет, их-то да, но их-то всё равно логарифом столько же, сколько детей. То есть, по большому счёту,
да, можно в принципе сказать, что давайте на каждую вершину класть монетку, типа на её удаление.
Потому что мы как бы, но лучше класть логарифом, потому что, забирая вперёд,
монеток тут может быть в этом списке. Помните, у нас же бывает ситуация, когда каких-то детей нету.
Нет, почему логарифом на похороны, откуда логарифом на слияние? Нет,
это слияние. Нет, смотрите, давайте так. При каждом insert логарифом на слияние,
на похороны. На слияние на каждом дереве хранится одна монетка. То есть, когда вы создаёте дерево,
ну хорошо, да, вы insert, вы даёте монетку ещё на потенциальное слияние. Ну потому что вы из-за этой
вершинки ещё дерево создаёте их. Лог, чтобы её удалить, лог чёрных монеток, чтобы удалить там,
допустим, и одна серобурмалиновая на её слияние на дереве.
Мы же meld делаем за минимум из логарифма, значит ещё логарифм не уложить.
Что? Мы же делаем meld за минимум из логарифма.
Да. Одну монетку, а не логарифм.
Нет, сейчас. Да, серобурмалиновая – другая монета.
Ну да. Нет, кстати, нет, смотрите, кстати о логарифме монеток. Кстати о логарифме монеток.
На самом деле с помощью этих монеток на самом деле можно показать ещё один красивый способ, почему эта сумма будет за линию работать.
Идея такая, давайте, допустим, у нас есть вот этот список хедов, и последний ранг равен, допустим, у него 179.
Ну для разнообразия, да. Тогда идея такая, давайте я буду считать, что на каждом таком списке лежит 180 синих монеток.
Да, ну типа от 0 до 179. Вот. Что-что?
Ну на каждом именно списке.
Да, просто фишка следующая, что если заметим, что если у одного лежит там 180 монет, а другого 50, то фактически мы делаем за 50 плюс слияние каких-то хедов уже 70.
Плюс там слияние каких-то хедов уже серобурмолиновыми монетками. То есть мы за от 50 как бы сделаем слияние на префексе, да.
А потом, может быть, там ещё нам придётся что-то там допиливать, хотя по-моему даже не придётся, но при экстракт-мини точно не придётся.
А хотя нет, при обычном МЛТ, конечно, может придётся. То есть получается мы как бы синие монетки вот от этого меньшего списка потратили на то, чтобы их слить до вот до 50.
А чтобы делать дальше нам потребуется только серобурмолиновые монетки.
Ну серобурмолиновые монеты берутся просто как только вы создаёте одно дерево, вы кладёте на него серобурмолиновую монетку.
Да, но дело в том, что создаётся новое дерево у вас только, ну как у вас деревья происходят, у вас либо дерево создаётся в инсекте ранга 0,
и тогда в этот момент вы кладёте одну монетку, либо у вас два дерева объединяются в одно, но там вы монеток не кладёте, там вы две монетки превращаете в одну.
То есть за счёт этого вы их как бы и бесплатно объединили деревья.
Откуда синие монетки берутся?
Вот, а синие монетки берутся, ну вот.
Так, а теперь да, вопрос от Рыда. А теперь вот давайте к этому вопросу, откуда берутся синие монетки?
Почему-то интересно сказать, что в обычной бинемиальной куче у нас insert и melt работают за единицей.
Потому что мы работаем не за минимумами.
Так, сейчас, чего ещё? Нет, а синие монетки, нет, ну синие монетки могут браться вот откуда.
Ну во-первых, можно как бы при создании списка, мы ещё одну, в инсекте мы ещё одну синию монетку создаём для того, чтобы создать список вот этот, да?
Из одного дерева, да?
А теперь идея такая, заметим, что, ну вот, то есть когда мы сливаем большой список на 180 монеток и маленький на 50, да?
Но заметим, что ранг большого списка итогов у вас станет максимум 181, правда?
Но вот, но у вас тут было 50 монеток, которые как бы потерялись, да?
Ну так давайте мы потратим не 50 монеток, а 49.
А эту 50 монетку положим сюда. Всё.
Ну или просто каждый мэлд будет вам давать одну дополнительную монетку, тоже не проблема.
То есть получается суммарно синих монеток или нет, значит получается суммарно мы победили.
Ну на самом деле, нет, ну не совсем так, понимаете, здесь очень важный момент, что мы добились того, что мы сливаем за от минимум из максимального ранга.
Это важно. То есть если бы делали в тупую, этого бы не работало.
Инсет? Нет, ну нет, не совсем, нам нужно амортизировать будущее удаление, поэтому логарифом мы кладём.
В бенмяльной куче?
Ну если, сейчас.
Инсет за единицу, а всё остальное за логариф.
Ну нет, давайте подумаем. Вообще по хорошему краю получается, что таким образом, да, можно и бенмяльную кучу реализовать, как будто так, что давайте инсет делается за единицу, мэлды за единицу.
Нет, мэлды за логариф, потому что мэлды, вы же сказали, что мы не за логариф.
Нет, а допустим мы в бенмяльной куче деревья храним вот так, да?
А, хорошо. Вот так?
Ну тем более, что мы сейчас обычную бенмяльную кучу обсуждаем, да?
А это даже не важно, просто это обычная бенмяльная деревья, да, просто у нас из каждого дерева хранится ссылка на кто там минимум дальше.
Вот, тогда получается мы эти слияния, честно, делаем за от минимума, да?
И получается, да, то есть в инсекте получается, допустим, мы в инсекте, то есть инсектор работает пока за логарифом только за счёт одного, за счёт того, что мы кладём логарифом монеток на чёрный день.
А теперь давайте мы не будем класть логарифом монеток на чёрный день.
Тогда это будет означать просто, что само по себе удаление будет работать за логарифом.
И всё. То есть мы просто это удаление не будет трогать вообще никаких монеток.
Ну там, ладно, серо-бурмалиновые, конечно, потрогаются, особенно те, которые тут дальше пойдут, да?
То есть при слиянии двух деревьев серо-бурмалиновые трогаем.
Но сами по себе синие монетки мы не трогаем.
То есть может быть только даём одну, если там ранг увеличился случайно.
Хотя при экстракт-мини, естественно, этого не происходит.
Мы этим, конечно, пользовались, чтобы сделать слияние за лог минимума, а не просто всё.
Нам же надо, просто фишка в том, что нам надо минимум быстро находить, пересчитывать.
Мы им пользовались, что когда вы тут просто находите начало, потом подцепляете куску, то вам пересчитывать надо только здесь минимум.
А здесь пересчитывать не надо.
Так что мы им очень активно пользовались.
Вот. Понятно?
Сколько у нас времени-то?
Чего?
Вот. Нет, сифт нужен для того, чтобы это был софт-хип, а не просто экзотический бенвейльный хип.
Чего ещё раз?
Да, пока я рассказывал, как это сделать без сифта, и получился, в принципе, эффект едва ли не как у кучи фибоначи.
Хотя нет, вру.
Мы здесь пока не научились делать дикриски за единицу.
Пока мы можем здесь делать дикриски, то чисто за логарифом.
Но поэтому, видимо, по этой причине дикриски и софт-хипе никто не требует.
То есть обратите внимание, сифт мы пока не делаем, мы просто чуть-чуть поигрались.
Вот. То есть дальше план будет такой.
То есть мы этот сифт начнём делать, и будем думать, как его делать так, чтобы действительно асимптотику не испортить.
Но сифт говорит, что он пытается на самом деле вот эти деревья выпилить просто своими силами.
Нет, он там прогуливается, пытается рекурсивно из Next выковырить какого-то ребёнка.
Ну, либо там.
Ну, там какая-то одна плюс бесконечная где-то там внизу, видимо, удаляется.
То есть какая-то там удаляется, видимо, хотя бы один ребёнок хоть где-нибудь да исчезнет.
Ну, вот.
И вот там поднимается, и там ещё какие-то свопочки.
Но это делается тоже от высоты.
В принципе, на самом деле можно заметить, что сифт работает с залогарифом,
поэтому, в принципе, если экстракт-мин делать сифтом, то можно прям этот сифт, возможно, выковыривать,
пока это дерево не исчезнет от слова «вообще».
Ну, вот.
И это тоже будет работать.
То есть это приведёт к тому, что у вас лишних мэлдов не будет.
То есть просто в какой-то момент вы поймёте, что этой вершины будет, что этого дерева, эта семья разрушилась целиком,
просто уничтожили всех.
И всё, что вам останется, это просто выпилить этот элемент из, соответственно, списка и тут пересчитать суффикс-мин.
Но это тоже делается как бы за уничтожение всех мэлдов.
Ну, вот.
Хотя, конечно, хотя тут, может быть, поточнее придётся подоказывать амортизацию, но суть, в общем, такая.
Но хотя, если нам достаточно, что это мы делаем с залогарифом, то у нас это устраивает.
Но мы это хотим делать за единицу.
То есть, ну вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
То есть, ну вот.
Ну, поэтому там могут быть разные читы.
Нет.
Ну, на самом деле, я могу сразу сказать, действительно, какой чит мы тут будем применять.
Но просто кажется, что с времени предыдущего перерыва полтора часа уже прошло.
Поэтому, я думаю, как бы неплохо бы, наверное, выдохнуть.
Честно скажу.
Ну, как, в общем-то, и планировалось, скорее всего, за сегодня мы, в общем-то, скорее всего, это не закончим.
Ну, там, да.
Но там, ну, собственно, это и нормально.
Обычно там было бы у нас четыре пары.
Мы бы, наверное, там за, как бы, четыре пары справились.
Вот.
Но у нас, к сожалению, только три.
Поэтому в следующий раз придется, как бы, так сказать, после некоторого перерыва сделать еще один наскор.
Вот.
Ну, ничего страшного.
Итак.
Значит, мы уже с вами обсудили, как делать честную пенмельную кучу без всяких сифтов.
Так, чтобы у вас было delete за логарифом, все остальное за единицу.
Или, что то же самое, insert за логарифом, а все остальное за единицу.
Ну, ключевое достижение мы научились meld за единицу делать.
Нет, дикриски, да, мы выкинули из рассмотрения, что дикриски мы ничего не научились.
Да, то есть, как бы, мы не сделали кучу фибоначи бессмысленной.
То есть, как бы, да, если бы выяснилось, что пенмельная куча тоже умеет, там, дикриски делать подобными технологиями за единицу,
наверное, может, кучу фибоначи бы даже не изобретали.
Вот.
Так вот.
Но, значит, какая у нас возникает идея?
Идея возникает в том, что очень хочется, конечно, лишние деревья не создавать.
То есть, все время там паниковать, что-то там детей сливать как-то не хочется.
Поэтому идея такая.
Давайте сделаем shift.
Давайте сделаем shift.
Что у нас сделал shift?
Но давайте вспомним.
Когда-то очень, знаете, давным-давно, там пару назад.
Хотя вот иногда действительно, знаете, вот ощущение бывает, что там давно было.
На всякий случай, кстати, в субботу случайно набегающий город Питер никто не ездил.
Нет, ну я так, на всякий случай, я же помню, что кто-то из вас из Питера.
Мало ли.
Может, вы там съездили это, походить 30 километров под дождем, я не знаю.
Нет, я вот просто...
Нет, ну да, я вот просто съездил.
И там вот действительно под конец маршрута оказалось, что то, что было в начале, это было прям в прошлой жизни.
Хотя казалось бы, это было просто в тот же день, просто 8 часов назад.
Но это ладно.
Значит, что делал shift?
Давайте вспомним.
Shift говорит нам, что мы не хотим разрушать прямо дерево от того, что там с одним ребеночком что-то не то.
То есть мы просто говорим, что ладно, ребеночек пошел, ну ладно, семья осталась, давайте просто сделаем...
То есть выковываем его откуда-то снизу.
Ну там выковаем, посвапаем чуть-чуть и так далее.
То есть, как вы помните, все будет в идеальном shift заключаться...
То есть мы просто прогуляемся по этому списку и там лишнюю плюс бесконечность удалим.
Просто не более того, правда?
Но правда это приводит к тому, что количество детей может и уменьшиться.
А может и увеличиться.
Вот. Ну почему оно может увеличиться?
Ну потому что, помните, у нас уже был такой прецедент, что у нас тут висело маленькое дерево, тут висело большое дерево.
То есть когда тут типа реально, то есть ранг 3, но реальных детей нет.
То есть могло быть так, что тут ранг 3, детей нет, или почти нет, а тут ранг 3, но дерево адекватное.
И в какой-то момент может случиться так, что они таки посвапаются, и тогда окажется, что как бы в головном next оказывается детей все еще много.
Понимаете, да?
То есть вот там вот это достаточно рандомно как-то происходит.
Вот. Но теперь просто идея оказывается в следующем.
То есть будет предложено сделать такой пограничный вариант.
То есть можно делать shift до бесконечности на самом деле, да?
Потому что shift тоже работает за тот же логарифом, поэтому в принципе экстракт-мин можно с помощью его тупо и делать, правда?
То есть давайте теперь другая реализация бенмяльной кучи.
Не как мы раньше делали вот этот вот сразу распил и мерч, да?
Там распил все ми и мерч, да?
Вот. А как бы shift до тех пор, пока дерево не опустеет.
То есть максимум, что может произойти, это вот там все дерево убилось от слова совсем, значит мы тут убили хет и пересчитали суффикс ми.
Ну суффикс ми мы по-любому пересчитываем, да?
А что значит пока дерево опустеет, там же один ми нет?
Да, но просто, смотрите, допустим, но просто может так случиться, что, ну обычно что вы делаете?
Вы удалили один элемент, сделали тут shift и пересчитали минимум вот на этом голове ходов, да?
Но могло так случиться, что вы из этого дерева удалили элемент и выяснилось, что это был последний элемент этого дерева.
То есть если shift бесконтрольно так делать, могло так получиться.
Но это как бы нам ничего не меняет.
То есть нам по-любому придется пробираться по этим ходам и мы будем пересчитывать суффикс ми.
Разница будет только в том, что мы вот это убьем.
Просто этого хода больше не существует.
То есть ни на какие монетки это не повлияет.
Даже я бы сказал, у нас наоборот одна серобурмалиновая монетка там вышила даже.
Поэтому ничего страшного.
Понятно?
Вот.
Ой, что там за шум?
Ой, а можете дверь на это раз закрыть?
Вот.
Вот, спасибо огромное.
Так что вот такая радость.
Ну вот, то есть получается с shift-ами тоже жить вполне себе можно.
То есть видите, на самом деле играться с этой структурой можно так делать, можно так делать, можно это делать десятью способами.
Вот.
Более того, но автор предлагает рассмотреть пограничный случай.
То есть такой, весьма неожиданный.
Он говорит, так, если у вас детей, значит у вас должно быть, чтобы в корневом списке у вас детей, там было сколько?
То есть детей у вас было хотя бы R пополам.
То есть если вы сделали shift и выяснилось, что количество детей у этой R2 меньше, чем R2 пополам, то ровно в этот момент мы останавливаем shift и говорим, так все, семьи не существует, давайте оставшихся детей отправляем в ХД.
Только для корневого списка.
Чего?
Только для корневого списка.
Ну, по сути, да.
То есть там мы фактически так делаем shift, а потом за ту же 7 точку, едва ли не просто за этот проход, когда мы тут прогуливались, мы узнавали, сколько там у этой вершины было детей.
И мы такжественно заявляем, что, слухайте, говорим мы, так, если у нас детей, как бы выяснилось, что их R2 пополам,
то, то есть там R2 пополам или меньше, то знаете, что давайте-ка мы все распилим и все это сделаем.
То есть мы все распилим и из оставшихся половины детей создадим ХД и, собственно, их сюда вмерчим по старой технологии.
Вот. То есть вот такая вот неожиданная идея тут у нас проскочила.
Ну да.
Вот.
То есть вот такая вот, то есть прям вот практически совсем в тупую.
Вот.
То есть вот нот.
То есть вот нот.
Вот. Ну, идея, по крайней мере, такая, смотрите.
Ну, идея могла быть такая.
Что, давай нот. То есть можно говорить так.
Что...
Нет, ну, давайте так.
Смотрите, давайте каждый раз, когда у вершины...
Ну, то есть формулируем так, что прежде чем мы сделаем...
Ну, там вот идея была такая, что прежде чем мы сделаем удаление...
То есть, получается, прежде чем мы расформируем это дерево, получается, как минимум половина деревьев должна убиться. Правда?
Ну, как бы, идея, по крайней мере, вот на уровне идеи говорится так, что как бы, давайте там, допустим, с каждым удалением дерева еще там, изобретаем еще какие-нибудь две желтые монетки.
И тогда, к тому моменту, когда у нас происходит удаление, получается, у нас там R2 желтых монеток накапливается, за которые мы можем уже, в принципе, деревья вмерчить.
Вот.
И получается, что все работает где-то за O от сифта.
Ну, типа того, да. То есть, более того, можно говорить даже так. То есть, более точно анализ говорит так.
То есть, к сожалению, у нас есть такой маленький технический момент, что в процессе сифта, в принципе, вот эта длина списка некстов может сильно меняться.
Почему как уменьшаться, так и увеличиваться, помните, да? Потому что мы тут свапы.
То есть, там мы свапы какие-то делаем, поэтому, на самом деле, то есть, какие-то переподсчеты, значит, придется делать как-то аккуратно.
Вот. Но тем не менее.
То есть, тем не менее, тут лежит, что вот такие сифты мы делаем.
Вот.
Но тем не менее, я утверждаю, что при такой реализации у нас никакие симпатики не порушатся.
Ну, в принципе, да. То есть, можно сказать, что, да, то есть, да, по большому счету, в общем-то, анализ от этого сильно не поменялся.
То есть, идейно, в общем-то, то же самое. То есть, можно, получается, и сифт делать.
То есть, по сути, мы же доказывались, что если бы сразу распиливали детей, то было бы тоже все адекватно сразу за 1, да?
Ну, вот. Но, на самом деле, если перед этим максимально подробно там стараться делать сифт, то вроде тоже ничего страшного.
Если мы только делаем сифт, то тоже все в порядке.
Вот. То есть, то просто каждое, потому что мы говорили, что нас устраивает логариф, и мы честно этот логариф им тратим.
Вот. Понятно, да?
Вот. Ну, тут приходит нам время, на самом деле, разобраться, как говорится, в чем же, а где же нужна мягкость?
Вот. Так вот. Ну, вот. Где же у нас возникает мягкость? А мягкость возникает вот где.
Дело в том, что сифт у нас это будет очень-очень-очень хитрая функция.
Ну, то есть, не очень хитрая. Сама по себе она будет работать буквально так же.
Потому что, что у нас делает, по большому счету, сифт от вершины В? Вот давайте вообразим себе код.
Ну, вот. Ну, по большому счету, она делает следующее. Давайте вот сейчас вот вообразим себе код.
Она говорит, что, значит, если оказалось, что там В, значит, next, значит, это null PTR, да, то что мы делаем?
То мы объявляем В там с k равно плюс бесконечности и return, короче, да?
Вот. Что мы делаем в ином случае?
Ну, мы делаем в ином случае. В ином случае мы делаем маленькую простую вещь.
То есть, мы запускаем сифт от where next.
Next. Вот. То есть, сифт от where.next.
Значит, если оказалось, что where, значит, ck, то есть, where next, ck оказался больше, чем where child ck,
то, значит, мы просто swap. Делаем swap. Where next и where child.
Понятно, да? Понятно, да?
В это next такой я написал.
Вот. Да, оказался больше, значит, swap-аем детей.
Ну swap-аемся child and next.
Ну, а теперь мы что делаем?
Значит, теперь мы говорим, что там, допустим, where next, ck равно where next ck.
Вот. Ну, давайте сделаем оговорку на всякий случай, который сейчас не нужна, но в будущем пригодится.
Увидите, почему.
Where next – это именно инкарнация той же самой грошили или это именно следующее ребенок?
Ну, next – это инкарнация. Child – ребенок. Next – следующая инкарнация.
Вот. Та переча.
Ну, теперь придется сделать оговорку, что если оказалось, что where ck равно плюс бесконечности,
то тогда мы просто честно делаем там delete, там удалить ребенка, удалить инкарнацию.
Хотя, да, по большому счету в этом даже нет смысла.
Да, на самом деле, да, это лишняя операция.
Ну, просто, нет, мне имелось в виду на всякий случай следующее, что если у меня оказалось, что у меня и child and next бесконечности,
значит их надо удалить и меня плюс бесконечности поставить.
Вот. Но на самом деле это то же самое, как просто сказать, что если выяснилось, что у меня ребеночек немножко бесконечный,
то давайте его выпилим.
Ну, то есть так и написать, ноде звездочка l равно where next child, значит ноде звездочка r равно where next next.
Значит, теперь пишем delete, значит where child, delete where next.
То есть delete именно в сишном смысле, естественно, да?
Ну, да. А deletes нету в сях, да? Ну ладно.
Ну в C++ смысле, хорошо. Но в C++ до каких-то там экзотических стадактов, там в самом простом, самом олдскульном, в котором есть.
Ну и дальше пишем where child равно l и там where next равно r. То есть вот так я удалил ребенка.
Здесь where next ck, да? Вот это where next ck. Так вот, вот такая красота у меня получилась.
А, ну и в идеале как бы вообще это было бы все. То есть тут закрываем и в общем-то на этом все.
Чего?
Ну да, там, да. Нет, ну это так касательно, потому что, смотрите, на самом деле просто идея будет такая.
Вот так вот, просто так это у нас получилась вот такая реализация. Так давайте я тут сотру немножко.
Так, вот это я уберу. Я думаю, это мы себе уже в голове вообразили. Да, то есть как-то, да, если на стене висит ружье, оно должно бы обахнуть.
Мы уже там всю стенку завесили оружием, конечно. Теперь ждем, когда это все рванет.
Сейчас увидите. Сейчас будет вот, сейчас будет основная магия.
Сейчас начинаем вспоминать, да, причем тут эти все там автобусы там какие-то со списками, да? Или списки с автобусов? Нет, наоборот, автобусы со списками, да.
Ой, вообще это новые автобусы, которые объединяются за вот единицу.
Ладно, это не автобусы, а поезда все-таки какие-то, да? Ну трамваи такие, да?
Да, давай электропусы объединяются за единицу? Да ладно. Нет, поезда, если я могу, образите.
Болтать механик.
Болтать механик.
Болтать механик.
Болтать механик.
Здесь девушки не будут, здесь все болтают.
Ну, как бы, ну не знаю, ну как сказать, да, софт хиппет, да, как всегда, софт хиппет пытается ее захватить.
Так вот, смотрите, так вот, в чем мы попытаемся сделать амортизацию.
Так вот, фишка теперь сделается весьма неожиданной.
Так, сейчас я просто достаю, теперь значит у нас возникает мистическое, жалко не ярко-зеленое, но красивое условие.
Так, где мои все маркеры? А вот они.
О, сейчас будет новое фиолетовое условие. У нас фиолетового же вроде не было еще.
Да и... Нет, просто что-то было, да. А мы пока все красным пишем, да.
Ну ладно. Так вот, софт хиппо... А, ну вот теперь новое рыжее условие.
Так вот, идея будет заключаться весьма... Значит, смотрите, в чем.
Значит, мы тут действительно посвапали детей, что-то там вот еще сделали.
Значит, ребенка скопировали. А теперь пишем так.
В этом месте.
Что ж там?
Да, да, после вот этой строчки, допустим, да.
Да, да, после вот этой строчки, допустим, да.
Вот. Ну, может потом мы ее переставим, как всегда, да.
То есть, как всегда, я говорю на уровне идеи, потом мы как бы докрутим, да.
И тут будет написано мистическое... Значит, если выполнено мистическое условие...
Совершенно мистическое какое-то условие.
То сейчас будет большая наглость.
Значит, с моей стороны.
То мы снова выполним сифт.
И более того, да, прям вот с копипастем на самом деле весь вот этот блок.
Понятно, да?
Ну, типа вот, да.
Ну, не совсем... Ну, go to тут не совсем верно.
А, ну, в принципе, более того, можно на самом деле даже обнаглеть.
Вот.
Ладно, правильно на самом деле сделать так. Давайте стрелочку вставим даже не сюда.
Да, погодите, раньше времени записывать. Да, тут, знаете.
Вот.
По большому счету, да, на самом деле можно и go to вставить.
Но go to с оговоркой, потому что не надо это делать до бесконечности.
Это надо сделать только один раз.
То есть, если выполнено мистическое... Вот здесь.
Вот.
Значит, да, нет, в эфи, в конце l за вот этого.
Вот здесь вот это сделали, ребенку удалили там, если что, да.
А потом неожиданно заявляем.
Вот.
Ну, вот, а потом неожиданно. То есть, если неожиданно выполнить мистико-condition, то...
Ну, вот, точнее так, end-end.
Ну, вот, мы, ну, вот...
Мы сделали, сделали только один shift.
Ну, в копии, да. Ну, хорошего я должен сейчас вот...
То есть, если вот сделали только один shift, то go to...
...один.
Куда один? А вот здесь. Вот.
Вот, вот, меточку вот здесь поставим.
Да, ну, это я так, давайте для удобства.
Конечно, да, как вы все прекрасно знаете, в языке C++,
нет оператора go to.
Значит, как говорил мой учитель программирования,
оператора go to в C++ нет.
Совсем нет.
Вот, это подвержает стандарт.
Если ваша программа с оператором go to компилится, это ошибка компилятора.
Все.
Ну, вот.
Ну, вот.
Ну, хорошо, может быть, даже если стандарте, это ошибка стандарта.
Нормальные люди, адекватные головой, оператор go to не используют.
Но на самом деле, то есть, это недалеко от...
То есть, это практически...
То есть, в современных практиках использовать go to не принято.
Потому что go to очень сильно усложняет, как бы, 4 кг.
Ну, вот.
В современных практиках использовать go to не принято.
Потому что go to очень сильно усложняет, как бы, чтение кода.
То есть, там есть только очень редкие какие-то отдельные примеры,
когда go to помогает.
Но в целом, оператор go to, на самом деле, там в рандомных...
Обычно там все код-стайлы используют, просто прямо запрещают.
Потому что дебагать невозможно.
Вот.
Потому что там из всех этих скобочек неожиданно выскакивает в рандомные места.
Нет, фу-фу-фу, такое.
Поэтому там...
Ну вот, не надо это делать.
Как-то вот, не надо этого делать.
Давайте, ну вот.
Но на самом деле, да, этот код, это еще такой приблизительный код, на самом деле.
Потому что, смотрите, то есть, мы вообще делаем наглую вещь.
То есть, мы на самом деле, да, пытаемся...
То есть, мы, как бы, обычно делали сив для того, что у нас в корне...
Мы объявляем, что у нас в корне элемента, на самом деле, не существует.
Поэтому мы там, собственно, из-под деревьев пытаемся что-то выковырить.
Да, нет, наверное.
Да, нет, наверное, вот.
Вот.
Но в чем, собственно, фишечка здесь?
Фишечка здесь...
Но, казалось бы, если мы вызываем второй сив,
то мы, казалось бы, удаляем еще один элемент.
Правда?
То есть, более того, просто если какое-то условие выполнено,
а это такой тупой достаточно...
А это такое простое условие какое-то.
Я там забираю вперед, скажу, что там будет написано что-то типа,
если ранг достаточно большой,
ну там, больше какого-то, там, Эр, да?
И этот ранг, там, 200, да?
То есть, либо он нечетен,
либо он четен, но следующий ребенок имеет ранг не я и минус один.
Тогда вот второй сив вызываем.
То есть, там не вызываем, только если я четный,
и у меня ребенок имеет ранг на единицу, то тогда ладно, тогда нет.
Но тут как бы важно понять, а что мы, собственно...
То есть, куда деваются элементы.
То есть, мы что теперь, не один элемент удаляем, а два,
и только это в одном сивте, а так как у них тут целая рекурсия получается,
то, может, мы там вообще поуничтожаем прям кучу всего.
Прям все.
Как это?
Подари мне полон.
Так.
Платок.
Вот.
Только так вот.
А вот теперь начинаем вспоминать про списки.
Вот.
Вот.
Так вот, на самом деле...
Нет, он может исчез.
Пришел его с меч.
Он, может быть, даже увеличился.
Да, потому что, видите, вот в этом месте этот элемент убили, да.
Да, ну, как раму восьмого, помните, да?
Вот.
Ну, не важно.
Ну, послушайте, там это...
Какого-нибудь там из Таиланда, из Курсавода, там девушка такая есть,
которая...
Раму восьмого здесь убили.
Да, ну, я ж вам рассказывал, по-моему, уже.
Нет.
Нет?
Вот, да.
Вот, да.
Немного и вот в прошлом году Барак Обама был здесь.
Но он не похож на Тайса, потому что он черный.
Да, он черный.
Вот.
Ну, да, но там еще больше шедевр есть.
Ладно, не будем сейчас это там...
То есть, там девушка замечательная, конечно, поэтому вот.
Просто шедевр.
Так вот.
Но, к сожалению, про софт-хипа она вам вряд ли расскажет.
Вот.
Так вот.
Вот.
Куда денется этот лишний элемент?
Но на самом деле убьется не элемент.
Убьется псевдоним.
А теперь вспоминаем.
Где?
Не, а теперь давным-давно.
Понимаете?
Нет, мы сейчас как бы говорили о куче предположений,
что каких псевдонимов нет.
Что элемент там в нескольких реинкарнациях как-то хранится.
А теперь пришло время признать, что на самом деле в самой куче
псевдонимы.
Где же находятся элементы?
Ну, элементы...
Шо?
Уууууууууу...
Уууууууууууу...
Ууууууууууууу...
Уууууууууууууууууууууу...
Уууууууу...
Ладно.
Значит, смотрите.
ой ладно может зря я пока стираю но давайте уже сотру может тут глядишь и это поубивается не
так а сушить икон не ну экономика это сопротивляется до последнего конечно да
ой может ее пыщ пыщнуть а так давай не шли ну шлёп шлёпать к сожалению не поможет так нет ее тут
ну как бы ну вот ну шлёп шлёпнул и чего я и могу даже позачеркивать но это как бы
ведь само по себе поэтому давайте попробуем и чуть-чуть пыщ пыщнуть может поможет пыщ пыщ вот
ладно у нас пока еще есть другая доска значит смотрите а теперь как будет устроена настоящая
мягкая куча значит фишка тогда то есть деревья будут те же то есть ну то же самое будут те же
ходы те же суфиксные суфикс мины и те же самые вот эти вот деревья все еще будет вариант что
ранги чайлда и некста будут одинаковые и строго меньше нашего но все остальное работает по тем
же принципам вот то есть там деревья деревья но но давайте так я нарисую вот тут есть цепочка
вот next next next и и кто висят какие-то дети но такие ну как всегда да вот ну как бы да ну
нормально да как-то вот дети да дети вот так вот висят нашу такую ну в хорошем смысле слова
конечно не там ну как бы да как бы да вы да вы папа на вас висят дети и это хорошо но вот это
хорошо вот вот значит тот висят вот давайте ладно мы давайте побольше детей висит вот
вот много детей это хорошо вот и так смотрите значит теперь идея такая все то же самое но маленькая
фишка не случайно то что мы тут хранили называется сикей да тут в каждой вершине хранится какой-то
сикей да вот это вот сикей и тут хранится сикей да более того для всех вот всего
этого next ва пути естественно этот сикей одинаковый вот а теперь
вот может может все-таки фиолетовая но не просто рыжий с красным так себе контактируя
когда контрастировать будет просто вот хотя я не знаю мы вот их так так где мы в этой куче мы
использовали черный цвет по моему да в ходах так фиолетовый мы где использовали
ну вот фиолетовый вот давайте вот фиолетовый нет синий где-то мы а синим оранги рисуем
эх ладно значит смотрите фишка такая внимание так вот дело в том что это сикей это псевдоним
у одного или у нескольких элементов от нуля до сколько угодно все эти элементы будут храниться
в мистическом списке но я предпочитаю ки-лист но как бы можете так называть но можно звать там
кей бас там можно еще что-нибудь вот это список стд лист да и в этот кей лист у всех есть доступ
то есть значит а в кей листе кей листе находятся ну то есть там находятся вот эти вот элементы
у которых псевдоним равен сикей вот помните я говорил о том что мы элементы храним в автобусе
списках вот и у каждой список как бы воспринимается как с единым сикей вот пришло время рассказать
вот вот так это устроено да лучше это каждый автобус говорит плохо потому что два автобуса
нельзя объединиться вот единица а вот трамвай пожалуйста оно должно потом ехать понимаете
ну с ковты проедет мне ну знаете да да да ну амортизируем не но это не то
нету да потом два таких ехавших автобуса должны как-то друг друга въехать на нужной
скорости так тихо тихо все так тихо не расслабляемся значит кей лист значит
идея такая то есть вот они так все хранятся вот значит на самом деле если от вас вот то есть
они то может быть про много элементов на самом деле гарантируется ну нет на самом деле ну как
сказать не более чем в куче реально понятно то есть на самом деле идея такая то есть на самом
деле все элементы хранятся не в куче красивой куче а вот в этих вот кей листах но которых
еще не достали реально зачем мы это так храним для того чтобы нам чуть-чуть сжимать то есть у
нас будет какая-то чуть более сжатая версия дерева за счет того что просто в кей листах
будет не по одному элементу на лист а побольше в идеальном мире у каждой вершины был бы просто
лист состоящий с одного элемента из себя любимого лес конечно но все еще лес те же ранги более
того там у хэдов там ранги строго возрастают это все на месте это все на месте и у нас получается
кей лист но такие листы такие но просто я тут нарисовал что их много но значит почему именно
лист потому что мы два листа за 1 объединять умеем логично да нам абсолютно не важно в
каком порядке на пиха на элементы в кей лист в реальности то есть получается вот этот вот
экстракт мин будет работать очень просто он говорит так найдем хэд в которой нас приведет
суффикс мин да то есть хэд с корневым у которого секей в корне минимален да и он говорит так и
идем кей лист и берем первый попавшийся элемент достаем его и удаляем да ну хотите сначала
хотите с конца на ваше усмотрение не важно а это указатель типа все реинкарнации у всех
реинкарнации секе есть указатель на этот лист но чтобы не копировать то есть секей скопировать
можно или там ссылку на него потому что но знаете там вот но это вообще вообще отдельная песня такая
еще есть что если секей жирный то его не хочется копировать мы же не знаем как у него типа да нам
это пригодится ну потому что когда мы будем тут свапать вот этих вот детей нам как бы здесь
придется этот кей лист перевесить поэтому удобнее будет на самом деле чтобы тут была ссылка на кей
лист чтобы ее сюда скопировать и чтобы в корне и в корень она пропихалась это я так на будущее
нет они указывают на стд листов внутри но я это воспринимаю так они это указывают вот так они
указывают на такую структуру внутри которой есть лист вот так то есть принципе это может быть
хотя нет вектор не может быть что два вектора за вот единицу не объединить и да поэтому увы это
лист вот поэтому там ну да нет там есть такие операции да но там отдельная песня там не все
операции работают так как хотелось бы опытным олимпиадникам то есть какие там подлянки есть
поэтому это надо поэтому нужно очень внимательно читать как векторе то есть векторе тоже бы
хотелось бы там вот это мы сделали там сто сто пятьсот по бэков и память уменьшилась на сто
пятьсот но как вы помните это не так совсем даже не так то есть там вот поэтому там со стд листом
в этом смысле тоже надо смотреть там есть подлянки но объединить листы там вполне можно в лучшем
случае напишите сами то есть я так думаю не не самое страшное для вас задача написать лист
правда с операциями объединить два листа там я не знаю достать оттуда элемент какой-нибудь там
добавить элемент не проблема правда то есть я думаю там вы можете там ставить на скорость
я напишу его за 15 минут а я за 10 как это я за 15 а я за 15 но и можно будет пользоваться на
практике там но нет потому что реально реально так потому что там скажем вот особенно то есть
ну думаю уже там начали проходить какие-то ревьюшки на c++ и да ну начнете значит когда-нибудь но в
худшем случае знаете самое то есть на нашем курсе видимо таких ревью будет если будет то штучно
но как бы идеальные ревью конечно в моей истории знаете где было вот в шаге то есть кстати придают
скорее всего в шаге у вас будет там курс алгоритмов структур данных обязательно и вы его скипнуть
не сможете но вот но и и будет и будет причина по которой это имеет смысл то есть понятно может
быть новых алгоритмов вам там не расскажут хотя про понятие продвинутый поток там тоже есть но
фишка будет том что вас там заставят кодить и какие задачи сдавать так вот ревью и там вас заставит
их писать реально как их пишут промышленном программируй вот то есть реально прям вот как
промышленный программируй так вот там просто при то есть там принцип кодирования отличается то
есть это не не вот это написать быстренько там был там лапшу сдать ее там в тестирую систему получить
ок и забыть о ней навсегда то есть ваша задача будет каждую часть писать так чтобы ее можно было
переиспользовать но основная идея такая но там опять избавляться от копипа ну чтобы можно было
править как бы и чтобы там не в двух местах а вторых чтобы еще можно было ее переиспользовать то
есть например если вам там потребовались там компоненты сильной связности какие найти да
например то вам придется взять и написать эти компоненты сильной связности то есть причем
написать прям едва ли не класс который там будет считать компоненты сильной связности предоставить
какой-то адекватный доступ и так далее то есть да возможно то есть половина этого функционала
которую вы там реализуете видимо самой задачи вам даже не пригодится но реализовать потребуется
адекватно пользователь то есть как бы да то есть вы как бы с точки зрения задачи вы как бы сделали
лишнюю работу но с точки зрения глобальной в этом под там то есть глобально с точки зрения создания
какой-нибудь хорошей библиотеки на самом деле вы себе там работу к ажи сделали прям вот вот такая
идея будет так но это так немножко по анонсировал так немножко рассказал собственно как вообще
Вообще, на самом деле пишется код в реальной жизни, то есть отличный от олимпиад.
Так, ребят, ау.
Значит, смотрите. Теперь давайте смотреть.
Как будет... Ну вот.
Ну, кейлист. То есть, в принципе, если вы просто из корня достали элементы с кейлиста,
в общем-то, больше ничего делать не надо.
Проблема начинается только если вы пришли в этот минимум, пошли в лист, а он пустой.
Вот тогда нужен сифт.
Ну, потому что пока у вас тут 10 элементов, значит, в ближайшие 10 раз обращение к достанию элементов оттуда,
в общем-то, сифтов вызывать не будут.
Ну, потому что, ну, достали и достали.
Ну, достали и достали.
Ну, достали и достали.
Да, вот это и оно, что если есть что доставать, то достаем и не паримся.
Секеи от этого не меняется.
Смотрите.
И вот, наконец, в какой-то момент обнаружилось, что вы хотели достать минимум, а он пустой.
Что делать?
Значит, тогда вы делаете так.
Вы запускаете сифт.
Ну, во-первых, начнем с того, что вы как бы...
То есть, как бы ликвидируете этот лист?
Ну, там надо его аккуратно ликвидировать.
Там, может быть, лучше нот.
То есть, по большому счету, вы когда сейчас в рекурсии будете пробирать,
первое, что вы будете предполагать, что эти указатели больше не валидны.
То есть, там удалять лист будет небезопасно, потому что вы с одного указателя удалите,
а с остальных тогда удаление приведет к какому-то коррапту.
Вот.
К сожалению, это не будет коррапт, не элементы внутри, а памяти.
Вот.
Поэтому вы можете там просто отправить этот лист, сказать, что там...
То есть, можете сразу удалить лист, а в сифте, на самом деле, этим удалением не заниматься.
То есть, просто говорить, что если мне пришел сифт от вершины, то я считаю, что этот указатель не валиден,
и этот лист уже удален, нам он не интересен.
Понятно, да?
Вот.
Так, если у нас key list стал пустым, то мы вызываем сифт.
Точнее так, мы удаляем этот лист пустой, он нам не нужен, да?
Да, это, кстати, важный момент, действительно.
Значит, вот мы удаляем этот лист и запускаем сифт.
Что делает сифт?
Ну, сифт делает, как всегда, запускает сифт от next.
Да?
Где он там ищет?
То есть, задача его...
Но задача его сделать так, чтобы тут, когда мы возвращаемся, вот, допустим, вызвали отсюда сифт,
надо, чтобы тут было корректное поддерево, и в нем тоже, если это не плюс бесконечность,
то тут какой-то лист тоже был.
Ну, понятно, из плюс бесконечности ни в какой лист мы не показываем,
но какой-то лист тут оказаться должен.
Понятно, да?
Вот.
То есть, происходить это будет примерно следующим образом.
То есть, ну, я так первую итерацию скажу.
Вот, когда мы сюда придем и обнаружим, что детей нет, тогда что мы сделаем?
Мы говорим, что, значит, понятно, что тут секея нет, тут мы рисуем плюс бесконечность,
тут мы рисуем плюс бесконечность, этого указателя нет, а есть указатель на пустоту,
потому что, ну...
То есть, помните, разницу между понятиями пустой лист и пустота, да?
Вот.
Тогда что мы здесь делаем?
Мы замечаем, что здесь висит какое-то дерево, да?
То есть, более того, у этого дерева есть тоже правый путь, на самом деле,
у этого правого пути тоже есть указатель на какой-то лист, да?
Тоже на какой-то вот автобусик, да?
Вот.
Нет, конечно, другой автобус.
Потому что этот автобус был как бы у тех элементов, у кого вот этот секей псевдоним,
а этот автобус у тех, у кого вот этот секей псевдоним.
И теперь фишка, смотрите, в чем.
Мы теперь можем посвапать элементы местами, да?
То есть, вот давайте я сейчас вот...
Ну ладно, эти указатели мы все равно убили, список убили, поэтому...
Вот.
Поэтому тут теперь оказывается, что все, что нам нужно теперь повесить.
Вот.
Вот так.
Вот.
Ну, повесить, и, видимо, секей, то есть ключик передается отсюда, типа, да?
Ну, теперь, раз ключик передается отсюда, то есть давайте назовем его просто С, да?
Тут он С, тут он С, тут он С, и тут он, соответственно, С,
но передается теперь не только этот минимальный ключик,
но и указатель на лист тоже теперь берется отсюда.
Но это тоже, ну вот, но это, в общем-то, тоже не сильно сложно, да?
Потому что, в общем-то, только, да.
Ну, то есть, нет, это мы отсюда там удалим, и то...
Ну да, то есть, в принципе, да, удалить мы его, конечно, должны,
то есть, когда тут будет плюс бесконечность, но мы его сейчас и удалим, значит, один...
Да, но просто значит, один из этих указателей исчезнет, ничего страшного.
Чего?
Нет, на один и тот же пустой список они указывать не будут.
Ну, нет, а сейчас нас не волнует.
Нет, там будет просто идея такая, мы вызвали сифт, обращаемся в список,
если он все еще пустой, еще сифт, и еще.
То есть там кажется, что мы ничего не делаем, но на самом деле мы удалили как минимум один список.
Поэтому как бы...
Поэтому как бы что-то произошло.
Нет, это был, ну, это псевдоним всего этого листа.
Но он единый, да.
Да, но это означает, что просто уменьшивая из этих элементов появилась новая реинкарнация.
Нет, нет, нет.
Где лежит одна вершина?
Нет, sec это не значение, это псевдоним.
У нас же всего этого пути лист список, для него будет просто список одной вершины.
Не обязательно, может и не...
Изначально.
Изначально, да.
То есть как бы это один элемент, и мы его размножим.
Нет, мы его не размножали, это один и тот же список, видите, ссылки стоят, и тут на один и тот же список.
Я не копирую его, обратите внимание.
А что есть и тот список, который вот при чём тоже будет?
Нам же придётся так, да.
Список?
Да, но тогда просто каждый сифт будет удалять как минимум один список.
Поэтому как бы амортизировано получится в будущем хорошо.
У нас же была проверка, что мы и сифт делаем более того раза.
Возможно она тут больше.
Нет, ура, это раньше сифт.
Потом я скажу, когда мы будем делать сифт второй раз, я расскажу, что мы будем делать.
Пока же так.
То есть если мы не делаем сифт второй раз, то как бы вот это примерно по такой технологии работает.
То есть мы к этому листу мы будем цеплять, видимо, некоторое время.
То есть там мы будем пробрасывать С сюда и рисовать ссылки.
Потом выяснится, что мы хотим пробросить сюда С, но тут выяснилось, что-то меньше.
Поэтому мы этих детей посвапаем.
То есть как бы эти ссылки на этот лист останутся, но как бы в некстовый путь пойдёт уже другой лист отсюда.
Понимаете, да?
Так что вот такая технология была бы, если бы у нас сифт был без развилок.
Ну так сказать, развилка это плохое слово, тут оно другие ассоциации вызывает.
Но если бы сифт вызывался каждый раз только один раз, то есть это нормальный такой сифт, который один раз проходит по этой цепочке и всё делает, то как бы никаких проблем вроде как не было бы.
У нас есть mystical condition, проблемы с mystical condition.
Да нет, погодите, это другой вопрос.
Нет, mystical condition, он будет задавать там вопросы, почему там количество покорапченных элементов будет плохое.
А в чём это у нас здесь проблема?
Пока здесь проблем никаких.
То есть просто если мы не будем делать сифт с mystical condition, то в принципе просто в каждом этом списке будет не более одного элемента.
А в реальности, скорее всего, там вообще будет, то есть пустой список будет только в корневых элементах.
А нет, это неправда.
Он просто нам обеспечит такое немножко отложенное удаление.
Без mystical condition на самом деле у нас каждый сифт, он каждый раз будет делать эту операцию.
Потому что он далит список, там был один элемент, не более одного элемента.
Но он стал пустой.
То есть пока что без mystical condition...
Ну нет, mystical condition тут ни при чём.
Без mystical condition это просто...
Ну совсем тупая реализация была бы, если бы вы сказали, что мы удаляем элементы из списка.
Если в этот момент список стал пустым, давайте сразу сифт делать.
Мы сказали немножко по-другому.
Сказали, что так, в списке есть элемент, давай ему сюда и всё.
А потом так, давай элемент.
Ой, список пустой, вот тогда делай сифт.
Да, совершенно верно.
Совершенно верно.
Без mystical condition такого случая не наступило.
То есть разница пока в том, что у нас просто есть элемент...
То есть сам элемент сидит в автобусе, а мы разговариваем с его, так сказать, даже не псевдонимом, а аватаром.
По большому счёту.
Но теперь просто фишка будет в том, что для оптимизации на самом деле у нас под аватар будет коллективным творчеством.
Вот, вот ассоциация.
Аватар и коллективное творчество, а то автозаки какие-то.
Вот нормальная ассоциация.
Идея теперь будет такая.
Казалось бы, что мы теперь делаем?
Ещё раз мы делаем.
Сифт предполагает, что я пришёл в вершину, и у меня на самом деле листа больше нет.
Она так не интересует.
Это типа я пришёл.
То есть я там откуда-то сверху пришёл.
Теперь я говорю, так.
У меня есть child, у меня есть next.
Ну а что ж в простых случаях?
Если на самом деле child и next у меня тупо нет, то что я делаю?
Ну а то я как бы, если их тупо нет, то как бы я тогда себе рисую плюс бесконечности, а этот указатель значения не имеет.
Логично, да?
Ещё там возникнет случай, надо внимательно смотреть возникнет ли, но по мнению автора возникнет.
Что если оказалось, если у меня оказалось, что у меня оба ребёнка бесконечности и бесконечность, то тогда я их должен убить.
Ну, возможно с mystical condition это нарушится.
Хотя у меня самого ощущения, что нет, но как бы...
Ну а как?
Нет, там просто, там знаете как аккуратно может быть?
Вы только что, значит, сделали shift и привело к тому, что child стал бесконечности, да?
Там дальше два варианта. Вы можете этот child удалить прямо сейчас и потом уже сделать, проверить mystical condition.
А можете сначала сделать mystical condition, вот, а потом уже смотреть, не получилось ли у вас плюс бесконечность.
Так же у нас на mystical condition нет?
Нет, там, значит, там просто condition.
Там if condition go to one.
Да, go to там есть, да.
А также, ну, как только у вас, ну, как бы...
Вот, мы сделали extract min, мы удалили вершину.
Да, возможности кей поменялся.
Нет, мы просто бежим от начала списка до этого дерева и обдавляем suffix min.
А, это работает.
Значит, это работает, но как бы так, скажем так, если мы следим за тем, что у нас тут есть хотя бы половина ранга,
то в общем-то тогда у нас до нас было типа не более чем ранг деревьев и это просто вписывается сюда.
То есть асимпатически погоды вообще не делает.
Да.
Ну, идея, по крайней мере, такая.
Вот.
То есть shift у вас по-любому делается как минимум за вот половину вот этого вот, да.
То есть если вы тут проделали вот этот вот shift с сжатиями и неожиданно поняли, что у вас детей чего-то маловато стало, да.
То есть, ну, да, даже их возможно их даже много после свапов, но как бы если у вас глубина рекурсии оказалась меньше, чем пополам,
то даже если там ноут, то имеет смысл тогда дерево может быть и расформировать,
потому что у вас тут в этом дереве значит слишком много под деревьев уже просто там полностью цирюкнулось.
Вот.
Ну, вот, поэтому вот, соответственно, но вот.
А если у вас тут как бы детей этот список имел длину как минимум ранг пополам, то как бы получается это от ранга,
то есть омега от ранга пополам или операции вы сделали, то же самое, что омега от ранга.
Омега от ранга. Следовательно, пробежаться потом посчитать суффикс мин для вас уже бесплатно.
Вот, поэтому, то есть.
Да.
Да, вот, к сожалению, в статьи такие мелочи тоже описываются на вот такое, в таком стиле.
Да.
Вот.
Ну, где-то так, да.
Ну, где-то с помощью монеты, где-то просто вот интуитивно.
Ну, то есть, видимо, считается, что там все на высоком уровне.
Что как бы статью читают серьезные люди.
Они дети, 1 плюс 1 равно 2.
А это хоть афибонати.
Она работает, она работает вот хорошо.
Доказательства.
Вот дети, это потенциал.
Вот так вот.
Ну, там подразумевается, что мы тут болены на более серьезном уровне.
Мыслим все-таки.
Чем там вот это выучили, переписали и ничего не поняли.
Вот.
Чего, где было?
Нет, ну, бывало, да.
Нет, ну, как сказать, там, понятия так.
Одно дело, в каком стиле написано, правда, статья.
Другое дело, как бы понятно, что это не отменяет того факта, что статья как бы формально просто абсолютно верная.
Просто там, видимо, просто идея написана на более высоком уровне.
Но как бы понятно, что каждый из них может быть проверено, естественно.
То есть, как бы условия.
То есть, как бы на уровне студентов, как бы, да.
То есть, на экзамене я могу там случайно спросить у вас каждую из этих деталей.
Вы там не должны там расписать просто идеального формализма, да.
Вот.
Реально.
Ну, а в мире ученых там, соответственно, значит, просто ученый сам по себе это будет делать.
И может потребовать это от автора статьи, если у него возникнут вопросы.
Ну и тогда, как бы, либо автор ему объяснит, почему это так.
Либо они придут к тому, что там действительно бага, которую надо исправлять.
Либо автор скажет, что ученые стоят на его понимании.
Ну, скажем так.
Я писал, как бы, как это в идеале.
То есть, понятно, в реальности, конечно, может быть по-разному, но обычно там, да.
То есть, нет.
То есть, часто бывает проблема, что иногда бывает там к ученому,
ты спросишь там, почему, он тебе подробно расскажет, но думаешь, блин, почему это не написано?
Почему это не написалось в статье?
То есть, я не знаю.
Понятно, почему.
Потому что лично автор посчитал, что это очевидно.
Нет, ладно, там еще была, могла быть другая причина.
Может, он не посчитал, что это очевидно, но он вынужден был сокращать статью,
потому что ему там в журнале сказали, что нужно поменьше страниц делать.
Поэтому он подобными там мелочами пожертвовал.
То есть, считая, что как бы такие мелочи.
Но хотя бы корректнее сказать так, что некоторые мелочи в статье из-за там малого парня я пропускаю.
Детали читайте и дальше дать ссылку и два линии на тот же архив, кстати.
Вот, то есть, детали там.
А как бы то, что она опубликалась в статье, это значит сигнал того, что да, меня читали, да, посчитали это адекватно.
Вот.
То есть, вот так это работает.
Так вот.
Значит, с плюс бесконечности мы поступили так.
Если оказалось, что не бесконечность, то значит, что мы делаем?
Тогда мы и говорим, что там тут у нас что-то, тут у нас что-то.
Мы из этого сифт выкопали, тут плюс бесконечности не оказалось.
Оказалось, какой-нибудь С, тут казалось С штрих, мы их даже посвапали, если надо, деревья, да.
Но, то есть, после того, как мы их посвапали, оказалось, что у этой С-шки есть какой-то лист.
То есть, если она не плюс бесконечности, то у нее есть, естественно, какой-то адекватный лист.
Тогда и мы присоединяемся к этому листу.
Ну, хотелось, ну вот.
То есть, вот так вот мы говорим С.
Так мы делаем, пока не приходит mystical condition.
А в этот момент говорим, так, а не наступил и там час Х, не наступил и mystical condition.
Да, значит, как, значит, что такое судный день?
Судный день, значит, судный день говорит нам неожиданную вещь.
Он говорит нам, слушайте, а давай, ну вот, слушай, а давай-ка мы, ну судный день говорит нам, а давай-ка от этой вершины мы вызовем, собственно, еще раз сифт.
Что это будет означать?
Это будет означать, что он мысленно будет считать, что этих ссылок не существует.
Delete вызывать не будет, как мы с вами договорились, да?
То есть, он просто будет считать, что эти ссылки невалидные, он будет их там пересылать.
То есть, что там пошаманит, пошаманит, и тут получилась какая-то там, допустим, ну если плюс бесконечности, то понятно, там мы просто что-то посвапали, удалили, да?
Ну, не важно, ладно, вот в общем случае, давайте сейчас общий случай.
Тут получилась какое-то D, да?
То есть, тут получилась D, и еще какой-то лист, да?
Вот он, да?
И с этой стороны какой-то лист.
Вот так вот, вот так вот, вот так вот.
Да, да, ну сейчас я вот.
Вот.
Какой-то лист.
Возможно, мы эти деревья посвапаем, видите, указателей пока сюда нету.
То есть, этих все указателей не существует, мы их убили.
То есть, это как бы она.
Вот.
Ну, значит, возможно, мы их посвапали, и теперь, ну и теперь вот оказывается, что оказалось бы, мы теперь должны сказать, что эта вершина указывает только на этот лист, да?
Но у нас есть этот лист, и в нем тоже есть элементы.
Так вот, идея становится очень простой.
Мы эти листы объединяем.
Призваиваем им всем, да?
Да.
Да.
То есть, да.
Минимум, во-первых.
А во-вторых, мы уже предположили, что мы посвапали эти деревья, и это меньше этого.
А, но С, нет, С уже было ликвидировано, поэтому то, что мы могли достать снизу, оно, заведомо, не меньше.
С3 тут написано.
Ну, помните у нас, вот, было тут С, потом тут стало С штрих, да?
Но вместо того, чтобы просто копировать сюда С штрих, мы тут взяли и еще вызвали.
А?
Вот когда мистикл кодишн вызвали.
То есть, по факту, да.
То есть, как бы мы вызвали один раз сифт, получили вот этот лист, потом вызвали второй, и результат объединили с тем, что было раньше.
То есть, вот такой.
То есть, обратите внимание.
То есть, как бы мы потеряли две вершины, как бы, да.
То есть, получается, потеряли, то есть, в этом месте не один псевдоним, вот этот потеряли, а типа два.
Но как бы два листа объединили.
То есть, количество листов у нас, обратите внимание, тоже в этом месте уменьшилось на один.
Понимаете, да?
Вот.
Поэтому и нод, поэтому оказывается, нод.
Вот, поэтому с листами получается хорошо.
Вот.
То есть, этот лист прообразывается, и ровно в этом месте, именно в этом месте, элементы начинают карабтиться.
В принципе, с точки зрения анализа, ну, видимо, мы в следующий раз будем это прямо, видимо, пробежимся по этой структуре еще раз и проведем прям подробный анализ, почему все красиво работает.
Почему инварианты схлопываются.
Тем более, что нас вообще должны выгонять.
Ну вот.
А нет, начинают нас выгонять.
Поэтому, поэтому последнее, что скажу.
Но просто вот фишка будет в том, что в этом месте карабтится.
С точки зрения анализа, в общем, все эти элементы будут уже покарабчены.
То есть, как бы, то есть, пока элемент, пока лист ни с кем не объединяли.
И ничего не доставало там, ничего, может быть, не доставали.
Значит, тогда он адекватный.
В противном случае, карабт.
Но в принципе, ну вот, то есть основная идея будет в том, что, конечно, эти карабты будут, то есть mystical condition будет требовать, что высота дерева, она должна быть как минимум R.
То есть, для mystical condition, так оно ж у нас рыжее было mystical condition, да?
Да.
И оно требует, чтобы действительно rank, то есть V rank должен быть больше R.
А R у нас это будет констант, я так забираю вперед, скажу, она там обычно равна Q, Q, Q.
Неважно абсолютно.
Просто до объединить.
Такая Platoчка должна быть qualify.
Да, в crate, complexity, complexity и смотрите, серigram, Beauty, determine or mapping.
не важно абсолютно просто до обединить все как бы да ну вот то есть но вот ну
корректности будет но вот но просто корректно будет доказать что вот в этих
вот пока общедых списков суммарно адекватное количество элементов нет мы
нет почему быть мы как бы оставляем варианты естественно что там
псевдоним больше либо равен каждому из этих элементов естественно это нет
это мы все сохраняем и то что ассекеи тут расположены именно по каким-то по
правилам кучи мы тоже сохраняем естественно вот но просто вот это вот
это нам будет гарантировать на самом деле что скорее всего то есть элементы
ранга меньше чем r не попортится ну сами по себе элементы ну видите сами по
себе элементы ранг иногда меняют да ну потому что если мы вспомним обычную
бенумиальную кучу то значит когда мы их объединяем один из этих корней
становится рангом высшего уровня да вот тогда в этом месте он там начинает как-то
портится вот а так элемент ну я либо его достали и сфта и сказали ты нам
нужен ты теперь более высокого ранга поэтому ты покоррапчиной о покоррупчиной
да вот да начинает с какого-то уровня люди начинают корруптица до интересной
идее конечно да но до какого-то момента вот человеческой
компашки все адекватно вот ну ладно давайте на этом остановимся и тогда в
следующий раз продолжим
