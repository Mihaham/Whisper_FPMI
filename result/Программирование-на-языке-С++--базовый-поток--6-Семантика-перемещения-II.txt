Начнем. Напомню, о чем мы говорили в прошлый раз, какую
проблему пытались решить. В прошлый раз мы с вами говорили
про шаблоны с переменом числом аргументов, то есть
это шаблонные функции примерно такого вида. Пишем
pamplet, дальше class, ну или на самом деле тут, я не упомянул,
но я думаю, как и для обычных шаблонов понятно, что вместо
слова класс можно писать слово typeName, дальше многоточие,
ну и дальше называем как-то сущность, которая у нас
именует пакет параметров типов, то есть, собственно,
все типы, которые будут выведены при передаче аргумента
в функцию, они будут находиться здесь. Ну и дальше, собственно,
мы пишем обычную шаблонную функцию, вот, не знаю, она
может принимать какой-нибудь int x, допустим, но потом, как
правило, в конце идет пакет параметров аргументов
функции, который тоже может принимать произвольное
количество параметров, которые вычисляются на этапе компиляции,
то есть на этапе компиляции подставляются все конкретные
типы и сюда подставляются конкретные значения. Ну и,
собственно, мы с вами поговорили про несколько способов
работы с такими шаблонными функциями, то есть первый
способ, собственно, просто передача пакета в дальнейшую
функцию, то есть, если у вас есть какая-то уже функция,
которая может принимать произвольное количество
параметров, то я, соответственно, могу распаковать пакет,
например, внутри этой функции, могу передать какую-нибудь
функцию g, аркс, многоточие, и тогда все эти параметры,
они передадутся в функцию g. Ну, могу на них навесить
какую-нибудь функцию, ну, не знаю, например, допустим,
я знаю, что все вот эти аргументы являются указателями,
я просто могу написать звездочка аркс, многоточие,
и тогда каждый аргумент будет передан в функцию g
предварительно, ну, предварительно перед тем, как передать
функцию g, эти параметры будут разыменованы, точнее,
эти аргументы будут разыменованы. Дальше, второй способ,
который мы с вами рассмотрели, это метод откусывания,
да, ну, или метод рекурсии, то есть метод заключается
в том, что мы на самом деле передаем функцию не целый
пакет параметров, да, какой-то вот шаблонный, шаблонный
отдельный параметр head, условно его назовем, вот, ну,
и дальше все остальное, да, ну, и дальше сводим задачу,
сводим нашу задачу к какой-то работе над аргументом head
и в дальнейшем передаем в ту же самую функцию,
в дальнейшем, ну, соответственно, хвост, да, ну, и главное тут
не забыть прописать конец рекурсии, да, то есть написать,
как должна вести себя функция f, когда ей передают один
аргумент или как должна вести себя функция f, когда ей
передают ноль аргументов, вот. Ну, и наконец, третий
способ, это fold expression, собственно, это выражение
такого вида, args, операция, многоточие, ну, или многоточие,
операция, args, ну, и тоже аналогичное синтаксе с инициализацией,
да, то есть это какое-то начальное значение, то я могу написать
init op многоточие op args, вот, ну, и аналогично могу написать
многоточие args op многоточие op init, вот. Ну, соответственно,
таким способом я могу, то есть если мне нужно применить
операцию как всем аргументам пакета, я могу применить
ее точно таким же образом, вот, ну, и естественно, каждому
аргументу можно предварительно применить какую-то функцию,
да, или какую-то операцию, вот, эти примеры мы с вами
рассматривали. А вот, что хотелось бы еще дополнить
к предыдущему разговору, ну, после лекции возникали
всякие вопросы, ну, и с этим хотелось бы упомянуть
еще один момент, который связан вот с чем, как еще
можно применять пакеты параметров. Пакеты параметров
на самом деле еще можно распаковывать во всякие
сущности, которые, скажем так, которые являются
инициализаторами для вещей, которые доступны на этапе
компиляции. Ну, например, да, то есть мы с вами знаем,
что чтобы завести массив int a, я могу написать что-то
подобие такого, x, y, z, ну и так далее. Да, то есть,
как бы, если вот количество элементов, которые я тут
указываю, оно известный этап компиляции, то, соответственно,
я этими штуками могу проинциализировать массив. Да,
но то же самое касается стд array, то есть мы можем
написать, допустим, std array, вот, ну, указать там количество
элементов, допустим, 10 int, ну и, соответственно, дальше
фигурный скобка, так, неправильно, вот, треугольный
скобка здесь, дальше a, ну и фигурный скобка указать
элементы, которыми я должен заполнить мой массив. Вот,
с шаблонными параметрами, точнее, с шаблонными пакетами
это работает точно так же, то есть я могу, например,
написать так int a квадратные скобки, ну или там могу
в квадратном скобке написать size of многоточие от args, вот,
ну и дальше фигурный скобок указать распакованный
пакет параметров args многоточие закрывающей фигурная скобка,
вот. Это приведет к тому, что, ну, собственно, будет
записан args 0, args 1, args 2 и так далее, ну и соответствующие
элементы массива будут заполнены элементами args, вот.
В частности, таким способом можно, например, реализовать,
вот, кстати, да, вот после лекции подходили с вопросом,
то есть можно ли таким же образом реализовать шаблонную
функцию minimum, да, которая принимает произвольное
количество параметров, вот, ну и, соответственно,
можно таким образом вычислить, ну, ответственно, можно,
да, то есть можно воспользоваться методом откусывания, вот,
то есть откусывать по одному аргументу, да, ну, соответственно,
взять минимум из вот этого аргумента и всего остального,
вот. Можно поступить, ну, а можно поступить вот так,
да, то есть взять и распаковать все в массив, ну, тут, правда,
есть, в общем, есть несколько проблем, давайте, вот, допустим,
я пишу std array a, ну, и заполняю его элементами args, вот.
Ну, а дальше, собственно, в обычном цикле, ну, просто,
в цикле ищу, ищу минимум в самом массиве, вот. В чем тут
потенциальные проблемы? Потенциальные проблемы здесь
заключаются в том, что, ну, во-первых, array, да, он, в общем,
array, как и vector, как и остальные, как и остальные типы, они умеют
догадываться о том, какие параметры у них должны быть
в качестве шаблонов, ну, вот, да, вот, в общем, параметр
типа, который в нем хранится, параметр количества
элементов, который в нем хранится, в общем, они могут
вводить это исходя из инициализации, вот, про это
мы поговорим на одном из следующих занятий, вот.
Поэтому тут важно понимать, что вот эта штука сработает
только в случае, если вы, только в случае, если все
вот эти аргументы имеют один и тот же тип, да, то есть
если вы тут передали, допустим, все int или там все
даблы, все флоты, то, соответственно, array выведется
как массив int или массив флотов, и все будет окей, вот.
Если тут будут находиться элементы разных типов, то
тогда, соответственно, вам, ну, в общем, компилятор скажет,
что, что ничего не работает. Ну, в общем, на самом деле,
все работает так же, как и с обычным минимумом, да, то
есть, не знаю, вы обращали внимание или нет, но если
вы напишите просто std min от 1, допустим, и 0.0, то вот
эта штука не скомпилируется, почему? Потому что min ожидает
два аргумента одного и того же типа, вот. Если вы
min'у передадите два аргумента разных типов, то просто
он откажется компилировать, он скажет, типа, приведите
один из аргументов, ну, к тому типу, который вам
нужно, вот. И здесь будет то же самое, то есть, если
у вас в варксах будет, допустим, int, int, int, а потом
double, вот, соответственно, он скажет, что, ну, я не
знаю, какого типа нужно array создать, поэтому минимум
вызван просто-напросто не будет такой. Вот. А да, ну и
вторая проблема. Вторая проблема заключается в том, что,
к сожалению, тут, ну, понятное дело, что когда я создаю
массив, мне все вот эти аргументы функций придется
копировать массив, вот. То есть, тут еще будет
дополнительное лишнее копирование, которое бы, на
самом деле, хотелось бы избежать, но, к сожалению, вот
создание массива будет требовать, ну, собственно, создание
уникальных копий вот элементов, и поэтому это
решение может быть, скажем, не самое эффективное.
Вот. Да-да, вот мы сами хотим написать функцию
min, которая вычисляет минимум, ну, давайте, там
какую-нибудь, ну, давайте напишем авто.
В общем, шаблон тоже.
Template.
Класс, мы готовы.
Arcs.
Вот, я хочу написать функцию minimum, которая вычисляет
минимум из всех аргументов. Вот. Ну, то есть, какие
есть альтернативы? То есть, первое, я могу воспользоваться
вот методом откусывания, да, то есть, методом рекурсии.
Ну, то есть, я могу тут завести дополнительный
параметр head. Вот. Ну, и сказать, что
минимум из одного аргумента и всех
остальных, это минимум из всех остальных
и
того самого первого аргумента. Да.
Вот. Соответственно, если я не хочу этого делать,
я могу воспользоваться таким трюком. Я могу создать
массив. То есть, я из этих аргументов
могу создать массив. Вот. Ну, при этом, не указывая
шаблоны параметра, намекая компилятору о том,
что, ну, как бы догадайся сам,
догадайся, сколько тут элементов находится, какого они
типа. Вот. Ну, и дальше, собственно, в цикле пройтись
по массивчику и, собственно, классическим способом
найти, классическим способом найти
минимум в массиве. Вот.
Нет, вот тут компилятор
откажется это делать, потому что он скажет,
что, ну, вот тут вы ничего не написали,
поэтому, как бы вы сказали, ну, догадайся сам, кого
типа массив. А так как тут встречается int
и double, компилятор скажет, ну, я не знаю, что вы хотите, вы хотите
int или вы хотите double. Вот. Поэтому
ограничение данного подхода заключается в том,
что тут необходимо, чтобы все аргументы были одного
и того же типа. Вот.
Окей?
Хорошо.
Так. Ну, и давайте вернемся к тому,
какую проблему мы все-таки решали.
То есть, ну, у нас
необходимость в этих шаблонных функциях
возникла не на пустом месте. Вообще говоря,
мы с вами обсуждали вектор,
а именно метод emplaceback.
То есть, напомню, что
у вектора есть метод,
ну, вот я создал вектор,
который хранит какой-то
элементы какого-то типа
a. Вот.
И я хочу воспользоваться методом
emplaceback.
Вот.
Emplaceback x,
y, z. Значит,
напомню, что делает emplaceback. Emplaceback
по сути является эквивалентом вот такому коду
v.
уж
back от a
x, y, z. Но гораздо лучше, чем
вот такой способ по
нескольким вещам. Ну, первое, мне тут не приходится
в apro chip sacrifice,
а потом я его передаю в pushback.
Тут же я передаю параметры
конструктора. В отличие от pushback принимает
сам объект, который я хочу
ставить, а emplaceback принимает параметры конструктора,
с которыми нужно создать нужные мне объекты a.
Тут проблема заключается в том, что я создаю временный объект,
а потом его передаю в pushback.
И дальше pushback решает скопировать этот элемент
или переместить этот элемент.
параметры конструктора и сразу же создает элемент в нужном мне месте. То есть, я избегаю
создания вот этой самой лишней копии. Понятно, да? Вот. И какая у нас проблема возникла? У нас возникла
проблема с тем, что, вообще говоря, непонятно, как написать вот этот самый emplaceback. Потому что
emplaceback, он принимает параметры конструктора, но вообще говоря, у одного и того же класса
может быть несколько конструкторов, потом, во-вторых, мы не понимаем, так как vector это
шаблонный контейнер, то он может хранить себе элементы, вообще говоря, произвольного типа. То есть,
мы храним произвольный тип, во-вторых, у этого произвольный тип может быть сколько угодно
конструкторов, и поэтому мы не знаем, что должен принимать emplaceback. Ну, собственно,
тут возникает необходимость написать шаблонный emplaceback, который может принимать вообще все,
что угодно. Понятно, да? Вот. Окей. Вроде как мы эту проблему победили с помощью шаблона с
переменным числом аргументов. Но вот, смотрите, какая может быть незадача. Смотрите, какая может
быть проблема. Давайте я тут заменю x, y, z на значение, ну, допустим, 0, 1, 2. Вот. И, допустим,
у меня есть класс A, и в классе A написан такой конструктор, int ссылка x, int ссылка y, int ссылка z.
Вот. Ну, то есть, конструктор A принимает, действительно, он принимает 3 int,
но все 3 int он принимает по ссылке. Вопрос. Могу ли я создать A с помощью параметров 0, 1, 2?
Да или нет? Почему? Да, потому что 0, 1, 2 это что? Ну, в терминологии это R-value, да? Но это,
по сути, временные значения. Временные значения я не могу связывать с R-value ссылками. Понятно,
да? А теперь давайте посмотрим вот сюда. Я написал в emplaceback 0, 1, 2. Как вы думаете,
скомпилируется этот код или нет? И вот этот код скомпилируется, да, почему? Потому что,
ну, emplaceback мы предполагаем, он реализован как? Он реализован как шаблон с переменным числом
аргументов. То есть, я вот эти 0, 1, 2 передаю в переменный args. А потом с помощью этих args
создаю нужный мне элемент. Так как вот это args это переменная, то с помощью переменных я
могу создать A. Окей? Ну, кажется, это проблема. Почему? Ну, то есть, тут две проблемы. Первая
проблема заключается в том, что вообще говоря, A нельзя создавать с помощью 0, 1, 2, а тут как бы
у меня получилось создать элемент A с помощью параметров 0, 1, 2, с помощью R-value. Это первая
проблема. А вторая проблема заключается в следующем. Ну, смотрите, если A принимает параметры по ссылке,
ну, наверное, это зачем-то им нужно. Наверное, где-то внутри себя сохранит либо указатель,
либо ссылку на эти значения, да? А что получится, если вот этот A сохранит ссылку на вот эти вот
значения переменных? Ну, после того, как вызов emplaceback завершится, вот эта перемена уничтожится,
и A будет хранить себе ссылки или указатели на уже мертвые переменные. Понятно? Беда. То есть,
вообще говоря, хотелось бы запретить вот такое. И вот об этом мы сегодня поговорим. То есть,
мы хотим запретить иногда передавать параметры. Ну, короче говоря, мы хотим, чтобы emplaceback
научился как-то отличать. То есть, могу я передать туда R-value или не могу передать туда R-value.
Вот. В общем, глобальный план такой. Значит, упрощенный пример. Давайте посмотрим на слайде.
Значит, задача такая. Смотрите, давайте отвлечемся от этой проблемы. То есть, если эта проблема была
непонятна, ну, жаль, но давайте посмотрим тогда на примере более простой задачи. Смотрите,
я хочу сделать следующее. Я хочу написать функцию runningTime, которая принимает на вход два параметра.
Она принимает функцию от одного аргумента. То есть, функция runningTime принимает другую
функцию, которую она может быть вызна с одним аргументом. И принимает с другим параметром тот
самый аргумент, с которого мне должна вызнать первую функцию. И просто, напросто… Она items
вызывает функцию от этого аргумента и высчисляет, сколько времени эта функция запускалась. Но по
сути, такая метафункция, которая просто принимает другую функцию аргумента и вычисляет, сколько
времени работает эта функция на данном аргументе. Понятно? Ну, короче говоря, если я запускаю
рантайм от fx, то она просто-напросто вычисляет время работы f от x,
окей? Вот. Ну то есть она вычисляет f от x и заодно вычисляет время, за которое
функция отработала. Ну и соответственно в качестве возвращаемой, ну и собственно
возвращает она то самое время, за которое отработала эта
функция. Ну собственно тут просто стандартный подход с измерением времени
с помощью библиотеки time, stdc log, он просто-напросто возвращает текущее
время в каких-то единицах измерения. Ну и соответственно я сохраняю время
старта, ну и собственно в ретёрне я вычисляю время окончания, вычитаю из
него время старта, ну и делю на то, сколько вот этих вот условных единиц
прошло, ну точнее сколько вот этих условных единиц содержится в одной секунде.
Окей? Вот. То есть stdc log минус star возвращает мне количество времени в каких-то
условных единицах. Вот. И я собственно это время делю на количество этих самых
условных единиц в секунде и получаю время в секундах, сколько мне заняло
вызов этой самой функции func. Вот. В чём проблема? Ну казалось бы очень
простая задача, и реализация этой функции вроде как изображена на слайде.
Да, то есть, так, вы не против, если я... так нормально? Вот.
Ну, собственно, всё довольно просто. То есть я запускаю функцию running time, измеряю
время начала работы функции, запускаю функцию от аргумента и возвращаю, собственно,
то, сколько времени прошло. Вот. Ну, соответственно, вызываю function от пяти,
или вызываю running time от function от пяти, всё работает, ну, точно так же. Да, ну просто
running time дополнительно ещё возвращает время, которое было потрачено на вызов
функции function. Как вы думаете, в чём тут может быть проблема? В чём проблема в
такой реализации функции running time? Сейчас, где мы передаём ссылку? Ну, смотрите, вот
я... у меня вот running time принимает функцию... function в первом аргументе, принимает
пятёрку в втором аргументе, я в функцию передаю, ну, собственно, арк. То есть, ну,
собственно, тут, кажется, проблем никаких нет. Я вызываю function от пяти, и это
абсолютно эквариенты, как если бы я вызвал running time function от пяти. Вот. Какая
потенциальная проблема может быть? Ну, да, понятно, что тут было бы неплохо навесить там
шаблон с переменом в чём-то аргумент, давайте пока просто посчитать, что running time имеет
работу только с функцией одного аргумента. Вот. Пока давайте с такой функцией разберёмся. Вот.
С какой функцией... с какой функцией ей вот эта штука не сработает? Да. Давайте посмотрим на
следующий слайд. Смотрите, а что если у меня функция function, время, которое я хочу измерить,
принимает аргумент по ссылке? Ну, давайте посмотрим, что произойдёт. Вот я создаю
переменную int x равную нулю, вызываю function от x. Ну, никому не удивляет, что после этого x
стал равен единице. Ну, давайте, да, вот, функция function, она принимает значение и увеличивает
внутри себя значение на единицу. Да? Plus-plus value. Вот. Теперь я вызываю функцию function от x.
x изначально равен нулю. Ну, собственно, никому не удивляет, когда после вызова function от x
у меня x стал равен единице. Да? Нормально. А теперь сразу после этого я вызываю running time
function от x и вижу, что x остался равным единице. Вопрос почему? Ведь running time function от x
должен работать точно так же, как и вызов функции function от x, но просто
дополнительно считает время. Почему x не изменился? Хотя я вызывал вроде функцию function
внутри running time. Да, смотрите, что произошло. У меня функция running time, давайте, тут,
обратите внимание, у меня функция running time принимает аргумент по значению u. Да? То есть,
что произошло, когда я передал в running time аргумент x? Аргумент x скопировался в этот аргумент,
да, и функция function работала с этой локальной копией. То есть, функция function увеличила
локальную копию, а внешний x от этого никак не поменялся. Понятно? Вот. Это проблема. Как проблему
будем решать? Ну, предлагаю такое решение. Давайте просто, например, в running time принимать
аргумент по ссылке. Теперь кажется, что все нормально. У меня int x равны нулю, я вызываю
function от x, x стал равным единице. Вызываю running time function от x, а получается x равны двойке. То
есть, x передался по ссылке, и, собственно, внутри running time у меня этот самый аргумент, так как он
был принят по ссылке, он же изменился. Вот. Смотрите, у меня есть функция function,
которая принимает значение по ссылке. Давайте v. И делает plus-plus-v. Вот. У меня есть функция running
time, которая принимает какую-то произвольную функцию и принимает аргумент по ссылке.
Не по ссылке, а просто аргумент. Вот. И внутри этой функции running time я вызываю f от arg. Теперь
что я делаю? Я вызываю running time от function от x, где x, допустим, равен изначально нулю. Вот.
Что бы я хотел? Я бы хотел, чтобы вызов running time от function от x работал точно так же, как если бы
я вызвал просто function от x. Понятно? Вопрос. Что произойдет, если я просто вызову function от x?
Ну, x увеличится на единицу. Что на самом деле происходит? Я вызываю running time от function и от x.
Так, running time принимает функцию по значению и аргумент тоже по значению. То есть, на самом деле,
вот эта штука будет копией x. Вот. И что произойдет здесь тогда? Я вызываю function от вот этой копии и
увеличится копия вот это. А вот этот x никак не изменится. Хотя я бы хотел, чтобы при этом вызове x
тоже бы изменился. Ага. Вот. Как решить вот проблему? Я предлагаю так. Чтобы это решить, давайте просто
добавлю ссылку. В чем теперь проблема? Вот, да. Вернемся к исходной функции function,
которая принимает просто int. Я функцию function могу вызвать от 5. Я могу написать function от 5.
Все сработает нормально. Если я позову running time от function от 5, все сломается. Почему? Потому
что аргумент arg принимается по ссылке. А пятерку прикастовать к lvalue из ссылки я не могу. Да? То
есть, возникает проблема? Смотрите, чего бы я хотел? Я бы хотел, чтобы функция running time работала и в случае,
когда у меня функция function принимает lvalue, и в случае, когда функция function принимает rvalue. Но если я,
соответственно, принимаю аргумент без ссылки, то у меня нарушается работа функции, которая принимает
аргумент по ссылке. Если я принимаю аргумент по ссылке, то у меня ломается вот такая вот штука.
Понятно? В общем, running time — это очень-очень универсальная функция, то есть не получается
написать очень универсальную функцию running time. Проблема ясна? Самое главное — знать
проблему. Это первый ключ к ее решению. Нормально? Хорошо. Вот сейчас, да. То есть, смотрите,
если я пишу arg.impercent, то я не могу передавать туда константы просто. Если я напишу arg.impercent,
то я не могу передавать, точнее, я не могу использовать функции function, которые принимают
ссылку. Потому что они будут работать не с той ссылкой, которую я передал, а с локальной копией.
Собственно, проблема находится в этом аргументе. Проблема в том, что этот аргумент, к сожалению,
пока не умеет адаптироваться под передаваемые в него значения. То есть, если я в него передал lvalue,
то из чего хотелось бы? Хотелось бы, если бы я передал lvalue, то arg был бы ссылкой на lvalue.
А если бы я передал в этот аргумент lvalue, я бы хотел, чтобы этот аргумент был, как минимум,
lvalue-ссылкой, а как максимум — просто-напросто переменной. На самом деле, чисто так вот,
технически, проблему можно обойти, если писать перегрузку для функции runningTime. То есть, можно
писать одну функцию runningTime, которая принимает аргумент по ссылке, вторую функцию runningTime,
которая принимает аргумент по lvalue-ссылке. Ну и тогда вроде как одна будет работать,
когда я передаю lvalue, вторая будет работать, если я передаю rvalue.
Но проблема тут в том, что, во-первых, тут есть дублирование кода,
то есть приходится написать практически две идентичные функции running time,
это во-первых. А во-вторых, давайте вернемся, собственно, к замечанию,
которое было сказано несколько минут назад.
А что если я хочу написать функцию running time,
которая принимает не один аргумент, а много аргументов?
Ну что тогда? Мне тогда придется написать
всевозможные комбинации rvalue и lvalue ссылок, согласны?
То есть первый аргумент принимает lvalue,
первый аргумент принимает rvalue,
второй аргумент принимает lvalue,
второй аргумент принимает rvalue и так далее, и так далее…
То есть если у меня функции будет принимать 5 параметров,
соответственно, у меня там два в пятой степени вариантов,
то есть 32 вариантов функции мне нужно будет написать.
Понятно?
Попрос, как избежать от дублирования кода,
можно не написать универсальную функцию,
которая могла принимать все что угодно
и использовала нужный тип ссылки.
То есть если я в аргумент передал lvalue,
то этот аргумент стал бы lvalue ссылкой.
Если я в этот аргумент передал rvalue,
стал бы RVL ссылкой. Хотелось бы написать такую универсальную функцию. Ну и такую универсальную
функцию можно написать с помощью так называемых универсальных ссылок.
Давайте познакомимся с понятием универсальная ссылка. Прежде чем начнем, небольшое
замечание про сворачивание ссылок. Это просто такое правило изнк C++, которое говорит в
следующем, что если в какой-то момент у вас в программе возникает следующая ситуация,
ну вот представьте себе, что у вас есть какой-то тип, у которого уже есть ссылка. И вы на этот
тип со ссылкой навешиваете еще раз ссылку. Ну как такое может возникнуть? Ну давайте посмотрим на
вот функцию f. Вот у меня есть функция f, у нее первый аргумент это t амперсант, второй
аргумент t два амперсанда. Ну и представьте себе, что вы вызывает функцию f и указал явно в
треугольных скобках, что мне в качестве t нужно подставить int амперсант. И вроде как возникает
ситуация, что у меня есть int амперсант, на который я снова должен навесить амперсант. Так вот такая
ситуация с комплятором интерпретируется не как ошибка, а интерпретируется следующим образом.
Значит, если вы на 1 амперсант навешиваете другой амперсант, то это тоже самое как просто
합стотип с 1. Амперсант, вот если вы на амперсант навешиваете 2 амперсанда, то это то же самое,
что 1 амперсант. Если вы наоборот, на 2 амперсант, навешиваете 1 амперсант, то то же самое,
что 1 амперсант. И только если вы на 2 амперсанты навешиваете 2 амперсант,
то остается два амперсанта. Окей? Вот. Ну то есть правило запомнить очень просто, просто
берется минимальное из-за количества амперсанта. Вот. Окей? Нормально? Хорошо. Теперь давайте
поговорим про универсальные ссылки. Что такое универсальная ссылка? Значит, утверждение следующее.
Значит, универсальная ссылка — это ссылка одного из следующих двух видов, и только их. Вот. Если
вы видите функцию function таблоном параметром t, и в качестве аргумента он принимает t
двойной амперсант, то t двойной амперсант — это универсальная ссылка. Или если вы
создаете переменную с помощью авто и на авто навешиваете два амперсанды, то это универсальная
ссылка. Все. Других универсальных ссылок не существует. Вот. Это только эти два способа
создают универсальные ссылки. Если вы начинаете на всю эту штуку навешивать const, например,
ten двойной амперсант или const after двойной амперсант, это уже не универсальная ссылка.
Если вы пишете т200% — это не универсальная ссылка. Универсальная ссылка — это
только шаблонный параметр, двойной амперсант или авто двойной амперсант. Все. Либо то, либо то.
More DNM — это универсальная ссылка. Больше ничего не является универсальной ссылкой.
Волter ListTri silenceDown Универсальная ссылка имеет Twitter Vallс chin,
то есть универсальная ссылка похожа на универсальную ссылку, но при этом
универсальная ссылка похожа на RLV ссылку, но при этом RLV ссылка не является.
Давайте еще примеры. Вот, например, функция function, которая принимает
const, которая двойной персант. Как я уже сказал, это не универсальная ссылка.
const и двойной персант — это константная RLV ссылка.
Точнее, RLV ссылка на константу. Дальше.
Дальше.
Code after двойной персант — это тоже не универсальная ссылка.
Это правая ссылка на константное значение.
Дальше. Допустим, у меня есть класс stack с шаблонным параметром t.
Вот здесь мне написана функция push, t, двойной персант, value.
Вот тут t, двойной персант — это не универсальная ссылка. Почему?
Потому что шаблонный параметр t — это не шаблонный параметр функции push.
Шаблонный параметр t — это шаблонный параметр класса stack.
То есть универсальная ссылка — это только та ссылка, которая относится к параметру самой функции.
Вот тут параметр t, это не параметр функции. Это параметр класса stack.
А вот если я внутри класса stack написал свою шаблонную функцию push,
то у двойной персант — это универсальная ссылка.
Почему? Потому что u — это шаблонный параметр самой функции,
и она описана как U%
понятно?
вот, хорошо
теперь
что такое универсальные ссылки, как они работают?
универсальные ссылки работают
по следующим правилам
надеюсь, вы помните, что когда мы с вами обсуждали в прошлом семестре
шаблонные функции
мы с вами говорили про то, как
выводится шаблонный параметр
мы с вами говорили про то, как выводится шаблонный параметр, если мы передаем
аргумент по значению
мы с вами говорили про то, как выводится шаблонный параметр, если мы передаем аргумент по значению
вот, и наконец
третий способ вывода
шаблонных параметров
это вывод шаблонного параметра
в случае, когда передается аргумент
по универсальной ссылке
универсальных ссылок есть особый механизм вывода
шаблонного аргумента
смотрите, какие правила
вот, допустим, есть функция function, которая принимает универсальную ссылку
то есть T, двойной U%
как будет
выводиться тип T?
я буду передавать какой-то аргумент функцию function
первое
const и volatile квалификаторы не отбрасываются
то есть, если у аргумента, который я передал функцию function
есть
на него навешан какой-то
модификатор const или модификатор volatile
то эти квалификаторы отбрасываться
не будут
то есть, const не теряется
volatile не теряется
дальше, второе правило
если я передаю
в качестве аргумента
Lvalue значение
то тип T выводится как ссылочный
то есть, если я написал
function
от, допустим, x
перемена это всегда Lvalue
и перемена x
у меня
это const int x
равно 0
тогда тип T будет выведен как
const int %
почему const int?
потому что по первому правилу
константность не отбрасывается
почему %?
потому что x это Lvalue
а если передается Lvalue, то тип T выводится как ссылочный
с одним %
понятно?
дальше
ну и, наконец, третье правило
если передается не Lvalue, а Rvalue
ну, допустим, function от
0
тип T выводится как не ссылочный
то есть, просто как
тип int
окей?
то есть, универсальная ссылка умеет
понимать, что вы в нее
передали
Lvalue или Rvalue
то есть, если вы в нее передали Lvalue
то тип T выведется как ссылочный
если вы в нее передали Rvalue, то тип T выведется как не ссылочный
вот
понятно?
вот
а теперь давайте
обсудим вот такой момент
у меня есть функция function
она принимает
универсальную ссылку
arg
посмотрите, я сказал, что в первом случае у меня T будет имитив
constant %
в втором случае тип T выведется как int
вопрос
почему в первом случае будет
тип переменной arg?
смотрите
давайте мысленно подставим
тип T это constant %
мысленно подставим вместо тип D constant %
я получил constant %
на который навесил еще 2 %
что в итоге получится?
вон правило
у меня тип T выводится как ссылочный
я на него навесил еще две ссылки
получил в итоге одну ссылку
тип аргумента будет на самом деле
const int %
окей
какой будет тип аргумента?
тип T выводится как int
вместо T я сюда подставляю int
что получается?
int двойной %
да?
то есть arg будет иметь тип int
двойной %
вот
то есть в зависимости от того, что я передал функцию function
у меня тип аргумента
тип аргумента вот этого внутри функции
он будет иметь тип
обычной ссылки, если я передал Lvalue
либо хотя бы Rvalue
понятно?
посмотрите в чем смысл универсальной ссылки
давайте на чистом интуитивном уровне поговорим
что означает универсальная ссылка
универсальная ссылка означает
что аргумент этой функции шаблонной
в любом случае будет reactors 저
в любом случае будет являться ссылкой
универсальная ссылка означает, что
arg будет ссылкой
и весь вопрос заключается в том,
либо l-value с ссылкой, либо r-value с ссылкой. В каком случае ll-value
будет, если я передал l-value в такой случае.
В каком случае argumentArc станет r-value ссылкой.
wyb ideia в том случае, что я туда
передал r-value значения. То есть в этом смысл универсальных
ссылок. Раньше под видео я писал
Justinia Perca и feedback kal理на Литви eyebrows.
Если я писал int 2 amp then я eram
то я знал, что я сюда могу передать только R-value.
Если я пишу T, двойной амперсант,
то я знаю, что я сюда могу передать как L-value, так и R-value,
при этом тип выйдется корректно.
То есть тут будет или L-value ссылка, или R-value ссылка.
Давайте поупражняемся,
посмотрим на примеры.
У меня есть та самая функция function, которая принимает универсальную ссылку.
Есть целый набор переменных, есть переменная x,
есть константная переменная cx,
есть переменная rx, которая является R-value ссылкой на 0,
есть переменная cx, которая является константной правой ссылкой на 0.
Давайте пообсуждаем,
и тут будут значения.
Вот я вызываю function от x.
Тут два вопроса для каждой функции.
Какой тип будет выведен для T?
И какой тип будет у аргумента ARC?
Я передаю function от x. Какой тип будет у T?
Int или int&?
Int&, да, почему?
Потому что смотрим на предыдущий слайд,
при передаче L-value в качестве аргумента тип T
выводится как L-value ссылка.
Все, смотри, тип T это int&,
давайте мысленно вот сюда,
вместо T подставим int&.
Что в итоге получится?
Какой тип?
Int&, да.
Так, теперь cx.
Да, ну это мы разбирали вон там,
то есть если у меня передается константа,
то тип T выводится просто как констант.
То есть константность не теряется,
и при этом, так как cx это L-value,
то выводится constant&.
А тип аргумента какой будет?
Тоже constant&, да,
потому что если я на 1& навешу 2&,
получу 1&.
Так, теперь передаю туда rx.
Что будет?
Так, ну, хорошо,
т.е. это будет 0.
Так, ну, хорошо,
то, что int, все согласны,
теперь что там по ссылкам?
Почему 2?
Ну, смотрите, действительно,
rx имеет тип int2%,
но нас же интересует,
какое значение передается.
Вот rx сам по себе,
это что такое?
Это L-value или R-value?
L-value,
блин, смотрите, какое у нас самое главное
правило было?
Помните, когда мы с вами говорили про,
вы только начинали говорить про
move-семантику, мы с вами разбирались,
что такое L-value, что такое R-value?
Какое было самое главное правило
для L-value?
Переменная это всегда L-value.
У этого правила нет никаких исключений.
Какая бы переменная перед вами не была,
там, constant&, R-value ссылка,
не R-value ссылка и так далее,
это всегда L-value.
Почему? Потому что переменная по определению
это имена на область памяти.
Если это область памяти, то это уже location-value,
то есть L-value.
Когда я передаю сюда rx,
несмотря на то, что он имеет тип
r-value ссылки, у rx есть конкретное место в памяти.
Поэтому это L-value.
Понятно?
Поэтому функция в качестве параметра t
выведет int&1,
и хоть и будет
иметь аргумент arg.
Int&, да.
То есть, на самом деле, арг
будет являться ссылкой на rx.
Арг будет ссылаться на ту же область памяти,
что и rx.
Теперь CRX.
Константность не отбрасывается,
поэтому const int&, а амперсант или 2 амперсанда?
1 амперсант, да.
CRX это переменная, переменная всегда L-value,
поэтому вводится 1 амперсант.
И, наконец, тип тоже const int&,
давайте не буду писать.
Сейчас мы переходим к примеру,
следующий пример, они не совпадают.
Фанкция от 0, какой тип выведется?
Когда я переводю функцию от 0,
выводится тип просто int.
Да.
Да.
Да.
Да-да-да.
То есть,
чем станет t,
L-value ссылка или r-value ссылка,
зависит от значения, которые я передаю,
а не от типа аргументов, которые я передаю.
Нет,
потому что, смотрите,
Rx сам по себе
ссылается на r-value,
но Rx сама по себе переменная,
поэтому у нее есть короткое место памяти,
я на нее могу спокойно ссылаться.
Ну, спокойно,
мы с вами это обсуждали
на занятии по
симматикой перемещения.
Смотрите, что происходит, когда я пишу вот так вот,
Rx равно 0.
Вот это синтез,
который позволяет создавать
переменные,
которые могут быть связаны только
с временными значениями.
Как это работает?
Под капотом это работает примерно так.
На самом деле, создается какая-то область памяти,
в которую сохраняется значение 0,
и которая называется Rx.
То есть, R-value ссылка
на самом деле создает
участок памяти, в котором хранится это значение,
и на самом деле,
я могу менять, я могу написать Rx равно единице,
тогда в этом месте памяти напишется единица.
R-value ссылка создает
для временных объектов
не временное убежище, так скажем.
Поэтому на Rx можно ссылаться
так же, как и на обычный перемен int,
потому что под Rx всегда скрывается конкретная область памяти,
в которой хранится конкретное значение.
А вот когда мы используем Rx,
сам по себе Rx является L-value.
То есть, L-value или R-value
у нас нет никаких проблем.
То есть, когда вы создали Rx,
то все спокойно, вы же можете написать,
Rx равно единице, Rx равно двойке,
вы можете взять адрес Rx.
Сам тип Rx это int,
двойной персант, да.
А когда мы используем Rx,
то Rx является L-value.
То есть, L-value или R-value это категория выражения,
это категория вычисления,
а не тип.
У перемена Rx тип int,
двойной персант.
У Rx, как у выражения,
тип int
и категория значения L-value.
Если внутри функции function
мы напишем int,
двойной персант,
допустим R,
равно arg,
то это не скомпилируется.
Почему? Потому что arg это L-value.
Арк это переменная,
а переменная всегда L-value.
Ну, мне нормально.
Когда вы создаете R-value ссылку,
вы говорите,
что я создаю переменную типа int,
но ее пронициализировать
я могу только R-value значения.
Все.
То есть, по сути, R-value ссылка
это обычная переменная,
но которую пронициализировать я могу только с помощью R-value.
Все.
А так как Rx это обычная переменная,
просто своим отдельным приколом
все остальные фишки переменных остаются
такими же.
Сейчас какая строчка?
Эти строчка.
Ну, смотрите, Rx это переменная,
переменная это L-value,
поэтому тип T выводится как int,
амперсант.
Потом я вместо типа T
поставляю int, амперсант.
У меня получается int, амперсант,
на который я навесил еще 2 амперсанда.
Вот по правилам сворачивания ссылок
получается обычная ссылка.
Если это универсальная ссылка,
то в качестве T никогда не выведется
int, двойной амперсант.
Двойной амперсант в итоге получится.
Давайте следующий пример.
Если вы хотите, чтобы переменная
передалась как R-value,
вы должны писать stdmove.
Если вы делаете stdmove,
то тогда
вы должны писать
stdmove.
Если вы делаете stdmove,
то тогда
компилятору ничего не останется,
универсальной ссылке ничего не останется,
предполагать, что вы
передали туда R-value.
Давайте добьем примеры
и пойдем на перерыв.
Фанкшн от нуля.
Что выведется в качестве T?
int, да, почему?
Потому что 0 это R-value,
когда передается R-value,
то тип выводится как тип без ссылки.
А тип аргумента какой будет?
Вот int, 2 амперсанда.
То есть тип T
это int,
но когда я вместо типа T подставляю int,
у меня арг будет иметь тип int, 2 амперсанда.
Вот краткие двойная ссылка.
На int амперсанда навесили
2 амперсанда. По правилу,
если я на амперсант навешиваю 2 амперсанда,
получаю 1 амперсант.
А там я просто на int
без амперсанда навесил 2 амперсанда.
Если я на что-то без амперсанда навешиваю 2 амперсанда,
получится, естественно, 2 амперсанда.
Так, дальше.
Вот, кстати, вот пример.
Я перевел функцию function stdmove.x.
Что будет?
Так, почему?
Смотрите, stdmove.x это что?
Это L-value или R-value?
R-value. Какое у нас правило?
Если придается R-value,
то тип T выводится как несылочный.
То есть просто int, да.
Так. Ну и аргумент arg
будет иметь тип?
Да, int 2 амперсанда.
Так, stdmove от cx.
Так, да, будет const int.
Так, и тип?
Да, const int 2 амперсанда.
Так, теперь тут.
Ну я подозреваю function, но в треугольном folds указываю int амперсант.
От x. prisons будет равен тип T.
Да, тип T будет равен
int амперсанда, потому что, ну, я явно указал,
что я хочу в качестве type A использовать int амперсант.
Так, Sweep arg будет
int амперсант, да.
Так, теперь. тут я в качестве type T указываю
int 2 амперсант. Что будет в качестве type T?
Да, int 2 амперсант.
Потому что я тут явно сказал, я хочу в качестве type T
использовать int 2 амперсант.
Вот, а arg будет иметь какой аргумент?
да int двойной персант, потому что если она двойной персант,
навешивает двойной персант, получается двойной персант.
Вот, наконец, тут последние строчки.
Тип T это int,
а тип аргумента это
да int двойной персант.
Ну вот.
По сути, мы
после того, как вели универсальные ссылки,
мы, по сути, решили проблему, которую ставили
практически решили проблему,
которую ставили изначально.
То есть решение проблемы заключается в следующем.
Давайте напишем функцию runningTime.
Но в качестве
второго аргумента будем принимать
не ссылку или не будем принимать
аргумент по значению, а будем принимать его по универсальной ссылке.
Теперь почему
это будет более-менее
работать? Потому что если у меня будет
функция function,
я могу вызывать функцию function от нуля,
и когда я буду вызывать
функцию runningTime
от функции от нуля, ноль будет
передаваться в аргумент arg и будет передаваться
по правой ссылке.
Арг будет являться
rvalue ссылкой на ноль.
Когда я буду вызывать функцию function от int
&value, просто одного &,
то когда я буду передавать в runningTime
function от x, x будет передаваться по lvalue ссылке.
В зависимости от того, что я передал,
то есть 0 rvalue или x lvalue,
у меня аргумент arg будет
являться либо lvalue ссылкой, либо rvalue ссылкой.
То есть аргумент arg может мне
сообщать о том, что
на самом деле было передано
функцию.
Ну хорошо, аргумент arg понимает,
что в него передали,
lvalue или rvalue.
Но
все еще остается
некоторая проблема.
А именно проблема вот с чем.
Давайте снова посмотрим на то,
как реализована функция runningTime.
Вот есть функция runningTime, она принимает
функцию func по значению,
она принимает аргумент arg по универсальной
ссылке.
У меня есть функция function l,
которая принимает
аргумент по lvalue ссылке.
Я вызываю function l от x,
все работает.
Я вызываю runningTime от function от x,
все работает.
Я вызываю function l от 0,
происходит ошибка импиляции,
но это нормально.
У меня function l принимает аргумент по ссылке,
я передаю в нее 0, 0 это не lvalue,
поэтому передать ее нельзя.
Если у меня function l 0,
у меня все работает.
Вопрос почему?
Я бы хотел, чтобы runningTime
работал тогда и только тогда,
когда работает обычный вызов function l
от соответствующего аргумента.
Вопрос, почему function l от 0
не работает, а runningTime function l
от 0 работает?
Смотрите, в чем проблема.
Что это тут передает function?
Вот тут function я передаю rvalue,
то есть 0, согласны?
А что тут на самом деле
я передаю в функцию function l?
Я передаю арг.
А что такое арг?
Арг от перемена, а перемена это что?
lvalue. То есть на самом деле,
когда я использую вот этот runningTime,
у меня в function l передается lvalue.
Понятно? Понятна проблема.
Когда я передаю
function l
от 0
напрямую,
это не работает.
Но когда я function l передаю, грубо говоря,
пишу вот так, int
двойной имперсант
arg
равно 0, а потом
пишу function
l
от arg,
это работает. Почему?
Потому что я создал переменную, а перемена
это всегда lvalue.
То есть, казалось бы,
я старался, я подтел,
я вводил универсальные ссылки, объяснял,
как они работают, а переменная arg взяла
и сказала, ну хорошо, я там буду
либо правой ссылкой, либо левой ссылкой,
но при этом я сама по себе arg, я всегда lvalue.
Ну как бы
старание на смарку. Почему?
Потому что вот эта вот строчка func от arg
в нее всегда будет передаваться lvalue.
Проблема.
Ну еще одна проблема,
представь себе, что у меня есть функция function r,
которая принимает int
по rvalue ссылке.
Она принимает int двойной имперсант,
то есть рvalue ссылке, то есть она может принимать
только временное значение. Если я вызываю function r
от x, то возникает ce.
Если я вызываю running time от function r от x,
то возникает тоже ce. Почему? Потому что я function r
передаю на самом деле arg, а arg
это lvalue. Все нормально. Но при этом
я могу вызвать function r от 0,
а function r от 0 вызвать не могу,
я могу вызвать function r от 0,
а вызвать running time function r от 0 не могу. Почему?
Потому что 0 при передаче функции
running time внезапно превратится в аргумент arg,
а arg это lvalue, и спокойно я передаю
его в функцию function, что приводит
к ошибке компиляции.
Беда.
То есть проблема спустилась
на уровень дальше. Смотрите.
Чему я научился с помощью универсальных ссылок?
С помощью универсальных ссылок я научился
определять, что
передо мной.
lvalue
или lvalue.
Но возникла следующая проблема.
Какой в этом смысл, что я научился
это определять? Если все в итоге,
все равно сохранится
в переменную,
которая как всегда lvalue.
Чего бы мне хотелось?
Понятно, что тут объяснение проблемы.
А чего бы на самом деле мне хотелось?
Мне бы хотелось сделать следующее.
Мне бы хотелось сделать так, что
если у меня t это int аперсант,
то я бы хотел функцию f
передавать arg.
А если у меня t выводится как int,
то есть если я изначально передавал rvalue,
то я бы хотел, чтобы аргумент arg
и дальше передавался как rvalue.
А как этого достичь? Как мне arg передать
в другую функцию, как будто бы это было
rvalue?
В этом случае
я бы хотел, чтобы передавался функцию f
stdmove от arg.
В зависимости от того, что они
передали функцию running time
либо lvalue, либо rvalue,
я бы хотел передавать либо
arg, либо
stdmove от arg. Понятно?
Грубо говоря, я бы хотел
сделать условный stdmove.
То есть если мне изначально передали lvalue,
то я бы хотел не делать stmove. Если
мне изначально передали rvalue, то я бы хотел потом
в arg применить stmove. Понятно?
То есть я бы хотел, в зависимости от условия, выполнить
№ sdmove и № sdmove.
То есть вот чего хочется.
Если в перемену arg
передали lvalue,
то вызывается fng от arg. Если в arg
передали rvalue,
то вызывается不行 от stdmove от arg.
То есть, грубо говоря,
хотелось бы написать что-то вот такое, да, если там varg передали lvalue, то вызываю
func от arg, иначе вызываю func stdmove от arg. Вот. Возникает вопрос, на который, на самом деле, я уже
дал ответ, но давайте для повторения спрошу. А как можно понять, что на самом деле
передавали varg? lvalue или rvalue? Да, вот это можно определить по типу T. Понятно?
Если у меня тип T это ссылка, то значит мне изначально в arg передавали
lvalue. Если у меня T выводится без ссылки, значит меня в аргумент передавали rvalue.
Понятно? То есть на самом деле вот этот код можно переписать, ну опять же этот
псевдокод, да, можно переписать вот так. Если arg это lvalue ссылка, то значит вызываю
func от arg. Если arg это не lvalue ссылка, то значит вызываю func stdmove от arg. Согласны?
Окей. Ну и, собственно, вот то, что нам нужно, называется stdforward. Вот. То есть два
столпа, на которых держится стемантика прямой передачи. Это универсальная ссылка
и stdforward. Значит, что такое stdforward? Вот функция stdforward это буквально то, что
нам нужно. stdforward это условный stdmove. Давайте даже пропишу отдельно. То есть stdforward
это функция, которая либо делает stdmove, либо не делает stdmove в зависимости от
какого-то условия. Но конкретное условие такое. Если я в stdforward передал
обычную ссылку, то stdmove не делается. Если я в stdforward передал тип без ссылки,
то stdmove делается. Вот. stdforward, то есть stdforward работает так. Я в него в
треугольной скобке передаю аргумент. Точнее, в треугольной скобке передаю тип, с которым
был передан аргумент, и в круглоскобке передаю сам аргумент. Вот. И дальше stdforward смотрит,
если аргумент содержит ссылку, то он просто-напросто возвращает арк. Если тип не содержит
амперсант, если тип не содержит один амперсант, то он возвращает stdmove от арка. Вот. То есть
Решение заключается просто в следующем, вот в этой строчке.
Я вызываю функцию fun.cd.forward от arg с большой буквы в круглоскопках
arg с маленькой буквы, и все работает так, как надо.
То есть, смотрите, решение состоит из двух частей.
Первая часть – это прием по универсальной ссылке,
для чего мне нужно принимать по универсальной ссылке,
потому что я хочу уметь отличать lvalue от rvalue.
Если передали lvalue, то у меня принимается аргумент по lvalue-ссылке,
если я передаю rvalue, то у меня аргумент принимается по rvalue-ссылке.
Дальше внутри функции возникает другая проблема.
Допустим, arg – это lvalue-ссылка или rvalue-ссылка.
Вне зависимости от этого, arg по себе является lvalue.
Теперь мне нужно как-то суметь,
arg передать в другую функцию с учетом того, какой изначально был тип
передаваемого аргумента – lvalue или rvalue.
Мне нужно сделать условность demove.
Изначально условность demove – это stforward.
Я говорю stforward, arg с большой буквы.
По этим треугольным скобкам stforward понимает,
что перед ним находится lvalue-ссылка или обычное,
что изначально было передано lvalue или rvalue.
Дальше в круглый скоб передаю arg.
В этом случае stforward просто либо делает stmove, либо не делает stmove,
в зависимости от того, что ему передали в треугольной скобке.
Понятно?
Окей?
Ну вот.
Теперь все прекрасно работает.
У меня есть теперь две функции functionL и functionR.
functionL может принимать аргумент только по lvalue-ссылке,
а functionR может принимать аргумент только по rvalue-ссылке.
Я вызываю functionL от x – это работает.
И когда вызываю runningTime от functionL от x – все тоже работает.
Почему? Потому что функция runningTime
принимает аргумент по lvalue-ссылке,
и дальше stforward тоже передает его функцию по lvalue-ссылке.
Когда я вызываю functionL от 0 – у меня ошибка в компиляции.
Почему? Потому что я не могу в int.ampersand передать 0.
Когда я вызываю runningTime от functionL от 0 – тоже возникает ошибка в компиляции.
Почему? Потому что когда я вызываю функцию func от stforward от arg,
у меня stforward что делает? stforward делает move,
потому что он видит, что изначально был 0, значит изначально был rvalue.
Но stforward говорит, что я буду передавать функцию function,
вот этот аргумент arg, с помощью stmove.
Но функция func увидит, что в нее передали stmove, а stmove – это rvalue.
И, соответственно, functionL скажет, что, ну, погодите, я не могу принимать rvalue,
потому что я принимаю только int.ampersand.
Поэтому возникнет ошибка в компиляции.
Ну и последний блок, functionR от x будет CE.
RunningTime от functionR от x будет тоже CE. Почему?
Потому что во второй строчке функции runningTime у меня будет stforward.
stforward не будет вызывать stmove,
а functionR может принимать только rvalue значения.
Ну а в последней строчке все сработает, потому что functionR от 0 все понятно,
то есть там int.ampersand, и в runningTime functionR от 0 тоже все будет окей.
Почему? Потому что stforward просто применен к аргу stmove,
и тогда функция functionR примет stmove от arg,
что будет являться rvalue значения.
Окей?
Понятно?
То есть в целом картинка вот такая.
Вот. Если я передаю сюда, ну, допустим, x,
сюда я передаю 0, ну, путь такой.
Когда я передаю x, у меня t выводится как int.ampersand,
и все это в итоге, ну, давайте, тут вот...
Вот. Когда мне x попадает в функцию,
то тип t выводится как int.ampersand,
и arg будет являться ссылкой на вот это самое x.
Вот. Просто когда я делаю stforward...
Вот. У меня функция f как будто бы вызывает просто f от arg.
Ну, а так как arg это ссылка на x, то как будто бы я вызываю напрямую f от x.
Вот. Если я сюда передаю 0,
то тип t выводится как int, arg будет являться правой ссылкой на 0.
Ну, при этом arg сам по себе это lvalue.
Когда я применяю stforward, stforward видит, что t это int,
и поэтому он в функции f передает f от stmove от arg.
Вот. Поэтому когда я передаю 0, у меня вызывается stmove от arg.
Когда я передаю x, у меня вызывается просто f от arg.
Окей? Да.
Ну, stforward устроено довольно сложно.
Заметьте, что мы с вами не говорили про ток и реализован stmove, на самом деле.
Вот. И про ток реализован stforward.
То есть, про это мы поговорим ближе к концу семестра,
когда будем подробнее говорить про шаблоны.
Вот. Пока просто примите на веру, что stmove работает как надо,
и stforward тоже работает как надо. Окей?
Так, есть ли вопросы?
Да, еще раз хочу, да, еще обращу внимание вот на этот комментарий.
Заметьте, что в отличие stmove,
stforward обязательно принимает треугольные скобки,
ну, arg, принимает тип.
Вот. То есть, когда мы с вами вызывали stmove,
мы с вами просто писали stmove от x.
Когда мы с вами пишем stforward,
нам издать нужно передать в него аргумент,
ну, вот этот вот самый тип,
с которым был создан x.
Почему? Потому что stmove, на самом деле,
неважно, какой был изначально тип у x.
В детстве какого изначального типа у x был,
он просто-напросто приводит его к RLU ссылки, и все.
А stforward, ему важно, чем был изначально x,
то есть вот этот вот arg. Ему важно, чем он был изначально.
Он был изначально int and percent, и он изначально был просто int.
И в зависимости от этого, в зависимости от того, какой тип тут указан,
он либо будет делать stmove, либо не будет делать stmove. Окей?
То есть stforward обязан...
То есть мы обязаны писать stforward с треугольными скобками.
Ну, на самом деле, если вы напишете без треугольных скобок,
а нет, там проблема в том, что скомпилируется, ну ладно.
Обязательно передавайте с треугольными скобками.
Так, есть ли вопросы?
Хорошо.
Ну и, собственно, давайте теперь
объединим знания с сегодняшнего занятия и прошлого.
Собственно,
ну вот, вначале уже нам сказали, что, ну точнее,
дали рекомендацию, что, ну вообще говоря, было бы неплохо
написать функцию running time, которая может принимать произвольное количество аргументов,
потому что, ну, вообще говоря, интересно узнавать время работы не только функции
от одного аргумента, но и функции от нуля аргументов, от двух аргументов,
от трех, ну и так далее. Как сделать это решение более универсальным?
Ну, собственно, использовать шаблоны
с переменом числом аргументов.
Пропишем тут.
Template.
Класс.
Ну, собственно, шаблонный тип для функции.
Ну и дальше класс многоточие
args.
Ну дальше там
функция возвращает double.
Run time от
f, f и дальше принимаем
произвольное количество аргументов, и при этом произвольное количество аргументов
по универсальной ссылке. Обратите внимание.
args, двойной амперсант, многоточие,
args.
Вот. Ага.
То есть я принимаю какое угодно количество шаблонных параметров
по универсальной ссылке. Ага.
Что я делаю дальше? Ну дальше я вычисляю
время начала работы функции.
std clock. Вот. И дальше вызываю
функцию f от аргументов. Но чтобы передать аргументы
функции f, что мне нужно сделать? Что мне нужно применить к каждому аргументу?
К каждому аргументу мне нужно применить
условный std move, согласны? То есть std forward.
То есть я пишу f
от std forward
от
параметра args,
круглые скобки args,
и многоточие.
Ну по-моему, это распаковка пакета args.
Я применил к args какую-то функцию, и после нее
написал многоточие. Нормально?
Вот. Ну и дальше, собственно, return.
Ну и return, блабла, то, что там написано.
Вот.
Понятно?
Ну вот. Ну я просто-напросто заменил предыдущее решение
с одним аргументом на решение с произвольным количеством
аргументов. То есть ну, что тут изменилось? Заменилось то, что я принимаю
теперь args двойным персом многоточия, ну что говорит
том, что у меня несколько, что я принимаю много аргументов
произвольное количество. Вот. Ну и наконец я forward принимаю
к одному аргументу, а к несколько аргументу, то есть
применяю sd forward к args, ну и дальше распаковывает
пакет для передачи функции.
Нормально?
Вот.
Так. Ну и давайте рассмотрим примеры,
давайте просмотрим примеры применения вот этих самых
универсальных ссылок. Ну первый пример применения это
собственно имплейсбэк, то есть теперь понятно, как использовать имплейсбэк.
А теперь я что делаю? Я принимаю все эти аргументы, естественно,
по универсальной ссылке. Ну а дальше, собственно, передаю их в соответствующий
конструктор с помощью sd forward. Вот.
И еще примеры. Ну смотрите,
так, ну наверняка вы приступали уже к решению
задач по умным указателям, вот. И там в качестве
дополнительного задания указано там реализовать
функции makeunique и makeshared. Вот.
Собственно, смотрите, makeunique и makeshared, по сути, те же самые
функции, что имплейсбэк. Ну что делать, например, makeunique?
makeunique принимает в треугольных скобках
тип указателя, который я должен создать, вот.
А в круглой скобке принимает параметры конструктора, с которым этот объект
нужно создать. Да? Вот.
Ну и, собственно, давайте реализуем функцию
makeunique. То есть как она устроена?
Она принимает,
ну первым аргументом в треугольных скобках она обязательно
принимает тип указателя, который нужно создать,
вот. А дальше она принимает параметры конструктора.
Вот. Что она возвращает? Она возвращает unique.ptr.
Unique.ptr, который указывает на аргументе ptr.
И функция называется
makeunique.ptr.
И функция называется
makeunique. Вот. И эта функция принимает
произвольное количество параметров. Ну при этом, конечно, я заранее не знаю.
То есть, естественно, я не знаю, да. А вот конструктор,
конструктор типа t. Он принимает они аргументы по ссылке,
он принимает аргументы по RVLU ссылке. То есть этого я ничего не знаю.
Вот. Так я ничего этого не знаю, я простоris принимаю аргументы
по универсальной ссылке. Вот. И универсальная ссылка
разберется, каким аргументам нужно давать амперсан,
каким аргументам не нужно давать амперсан.
Ну и, собственно, решение просто запущается в том,
чтобы написать return, unique ptr от t, ну и, собственно,
ставлю туда выделенную память, new t, ну давайте тут напишу,
new t, forward, new t от, и передаю туда все аргументы, и передаю туда все
аргументы arcs, но при этом все аргументы передаю, ну,
с помощью stmov, либо, ну, короче, с помощью условного stmov, да, то есть
в каждом аргументе должен либо применить stmov, либо, либо не применить
stmov. Делается с помощью std forward, std forward от arcs, arcs многоточили, вот, и так, вот, понятно?
То есть, вот, я принял аргументы, я не знаю, какие аргументы там должны приниматься,
по ссылке, не по ссылке, в общем, универсальная ссылка сама разберется, а дальше все эти
аргументы я передаю в конструктор new, да, я пишу new t и говорю, что вот этот объект t
нужно создать с помощью вот этих вот аргументов, вот, но при этом каждый аргумент я передаю
либо с помощью stmov, либо с помощью, ну, либо просто с помощью обычной передачи, да, по ссылке, вот,
то есть std forward сам решает, какой аргумент нужно, какому аргументу нужно применить stmov,
какому аргументу не нужно применять, окей? Вот, это, так, презентация поехала, ну ладно, в общем,
это первый пример. Вот, второй пример, это, собственно, то, что мы с вами проговорили,
это emplaceback, да, emplaceback тоже принимает аргументы по универсальной ссылке и дальше,
ну, каким-то образом создает объект в нужном месте в памяти, вот. Ну или, например, у стека,
точнее у списка, у 2-вязаного списка, у 1-вязаного списка, bricks++, есть template,
да, который просто позволяет создать элемент в нужном месте, ну, просто позволяет создать
элемент, ну, с помощью параметров конструктора, вот. Например, у стека, да, у стека можно
сделать template, который принимает параметры конструктора carrots, вот, создает новый узел,
код semua, вот, принимает голову, хет, и создает там объект типа t, ну, объект, создает объект типа t
с помощью параметров конструктора args.
Но при этом предварительно каждый аргумент args оборачивается в std forward,
чтобы либо передавать его с помощью std move, либо передавать его просто по обычной ссылке.
Окей?
Нормально?
Так, ну давайте задам вопрос.
Понятно ли, вот допустим, вот смотрите, вот есть мой кюник,
понятно ли, почему мы тут принимаем аргументы по универсальной ссылке
и почему мы передаем их с помощью std forward?
Вот почему, все ли понимают на текущий момент, почему нужна вот эта вот связка?
Или есть какие-то вопросы?
Да, давайте.
Так.
Хорошо, давайте пример.
Давайте напишем класс.
Пусть у меня есть класс A, и у него поля, и у него есть два поля.
Int % x и просто int y.
И в публичной части у него есть такой конструктор.
Int % a, int b.
Так, ну, ссылка x инициализируется ссылкой a,
а значение y инициализируется значением b.
Ну и там еще какие-то методы, неважно.
Пока понятно.
Все, у меня есть какой-то класс A, у которого в конструкторе есть два параметра.
Первый параметр принимается по обычной ссылке, второй параметр принимается по параметрам.
Первый параметр принимается по обычной ссылке, второй параметр принимается по значению.
Окей?
Теперь, что я делаю?
Теперь я вызываю...
Теперь я хочу создать...
Теперь я хочу создать умный указатель.
Я пишу.
ptr равно make.
Unique, вот a.
Ну и, допустим, я туда передаю...
Давайте, тут, допустим, есть int a,
равное 0 и int b, равное 1.
Вот, я туда передаю ab.
Понятно, чего я хочу достичь?
Я хочу создать, грубо говоря, да, то есть, грубо говоря, что я хочу?
Я хочу создать new a от ab, да, ну при этом завернуть это в умный указатель.
make.unique создает умный указатель на объект a, unique.ptr.
Мы пишем просто аналог функции...
Есть функция cd make.unique.
Мы сейчас обсуждаем, как она устроена, на примере своей собственной реализации.
Окей?
Ох, ну тут, грубо говоря, грубо говоря, что делает make.unique?
Грубо говоря, make.unique просто устроит умный указатель.
То есть, в конструктор a я передаю переменную a и передаю переменную b.
Но при этом, при этом сам объект a сохранит ссылку на a и сохранит просто значение b.
В чем проблема?
Представьте себе, что я написал make.unique.ptr.
Я написал make.unique.ptr.
Я написал make.unique.ptr.
В чем проблема?
Представьте себе, что я написал make.unique.ptr без вот этого всего.
Просто args многоточие, и тут просто args многоточие.
Что сломается?
Вот я тут все аргументы принял по значению, и тут просто передаю все аргументы по значению.
Что сломается?
Чего я хотел?
Я бы хотел, чтобы x, ссылка x, ссылалась на переменную a.
Согласны?
То есть, когда я пишу new a в кругу скобки ab, у меня вот этот первый параметр уходит вот сюда,
то есть сохранится на его ссылке.
И дальше ссылка на x ссылается на то же самое, на что ссылается вот это a.
А вот это a и то же самое, что и вот это a. Согласны?
Так.
А что произошло, когда я передал аргументы a и b в функцию make.unique?
Вот эта передача почему? По ссылке, по значению.
Да, эта передача просто по значению.
Тут стоит args многоточие, args.
То есть, я просто взял и вот эти a и b скопировал вот сюда.
Так.
И когда я написал ut от args, на что создалась ссылка вот эта x?
Вот эта x теперь ссылается в локальную копию.
Понятно?
То есть, после выполнения вот этого кода, у меня вот этот объект, который будет создан,
он будет ссылаться в локальную копию.
После того, как функция make.unique завершится, все, функция make.unique завершилась,
локальные копии уничтожились, на что теперь ссылается x?
Ни на что. Теперь висячий указатель.
Он ссылается на память, которая уже удалена.
Понятно?
То есть, с помощью такой реализации у меня не получилось достичь того,
чтобы a напрямую передалось непосредственно в конструктор a.
Окей?
Почему?
Потому что тут я все принимал по значению u.
Да?
Теперь.
Теперь давайте добавим универсальную ссылку.
Вот для чего нужна универсальная ссылка?
Ну, на самом деле тут...
Давайте тут еще int, двойной персант y добавим.
Вот. Тут вместо b напишем 0.
Вот.
Ну, давайте двойной персант.
Сдамов от b.
Ну, ладно, так плохо.
Нет, все хорошо, все нормально.
Это сработает.
Вот.
Теперь смотрите, что произойдет, если я добавлю просто один аперсант.
Если я добавлю один аперсант, то я не смогу туда передать 0.
Да?
Поэтому что мне нужно делать?
Мне нужно передавать универсальные ссылки.
Почему?
Потому что универсальная ссылка мне гарантирует,
что каждый аргумент, который я добавил,
это 소фт будет передавать по обычной ссылке.
Влюс это будет передать по RVEL.
Понятно?
추 동안
то здесь
все вот тут требует универсальный ссылку,
чтобы каждый аргумент был передан либо по ссылке, либо универсальный ссылки.
Если угодно просто надо,
чтобы вы не производить лишних копирований.
Вот. Для чего мы передаем по ссылке?
Чтобы избирать лишних копирований.
Влу тоже я передаю, чтобы избирать лишних копирований.
Что произойдет, если я тут просто на австе передам args?
Если я просто передам args,
тогда из-за этого параметра конструктора,
из-за этого параметра конструктора, у меня вот эта
строчка не скомпилируется. Почему? Потому что
args — это переменные.
А так как args — это переменные, то они
не умеют связываться с RVL-ю ссылками.
Согласны?
Ну чего на самом деле мне нужно? Мне нужно
на самом деле к вот этому второму аргументу
применить stdmove.
Если я во второй аргумент передам stdmove
от arg, то все будет нормально.
А как мне понять, нужно ли применять stdmove или нет?
Смотрите, к первому аргументу
stdmove применять не нужно.
А к второму аргументу нужно применять stdmove.
Как отличить одно от другого?
Ну собственно,
вот этот отличик краски делает функцию stdforward.
stdforward смотрит, что
изначально мы
передали lvalue ссылку.
Но раз мы передали lvalue ссылку, значит не нужно
делать stdmove. Если мы изначально передали rvalue,
то соответственно нужно сделать stdmove,
чтобы дальше тоже пошла
rvalue ссылка. Понятно?
Еще раз. Универсальная ссылка гарантирует,
что lvalue передастся по lvalue ссылке,
rvalue передастся по rvalue ссылке.
stdforward гарантирует, что если я изначально
передавал lvalue, то он в эту же функцию
передастся с помощью lvalue.
Если изначально в аргумент
был передан lvalue, то он будет передаваться дальше
с помощью stdmove. То есть сохранится категория значения.
Понятно?
Почему называется forward?
Почему функция называется stdforward?
stdforward у нас слово
тематика прямой передачи.
Тематика передачи вперед.
То есть как будто бы я вот эти аргументы
a0 передаю не с помощью
функции makeunique, а передаю
сразу напрямую вот сюда.
Не меняя их категории значения. Понятно?
Ну, хорошо, тогда на сегодня все.
На семинарах поработать еще.
До встречи на следующей неделе.
