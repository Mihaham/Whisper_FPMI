Значит, все, давайте вернемся к делу. Я остановился на ссылках в прошлый раз.
Так, напоминаю еще раз, что самое главное нужно было запомнить про ссылки. Значит,
как в голове правильно их держать. Значит, ссылка это другое название для переменной.
Если вы завели ссылку, то это значит, что отныне у и х неразличимы, и любое обращение к у это
обращение к иксу. И на вопрос, правда ли, что от изменения у изменится и икс тоже,
я бы ответил, что не икс тоже изменится, а именно он изменится, потому что у икс теперь то одно и
тоже буквально. Но компилятор, впрочем, ссылки иногда хранит как указатели, когда не может
просто сделать замену. Например, если вы по ссылке принимаете переменную функцию, то она будет
как указатель передана. Ну, там еще и, например, если вы ссылку храните, ну, там мы разбирали,
если вы храните ссылку то на одно, то на другое, в зависимости от каких-то runtime условий, то
компилятор тоже будет вынужден ее хранить как указатель. Вот, по этой причине, когда вы функцию
передаете имп по ссылке, вы несете некоторые накладные расходы по сравнению с тем, как если
вы передавали его по значению, потому что передать имп по ссылке фактически это означает, что
обращение к нему это будет разыменование указателя, но в остальном они будут неотличимы, то есть тот
имп будет вести себя как будто это исходная переменная. Вот, если я, например, спрошу,
какой адрес у y? Да, ну вот там скажу, cout, адрес y и адрес x. Это одно и то же или нет?
Конечно, это одно и то же. Это адрес x будет просто. Тоже самое. Адрес той же самой переменной.
Адрес той самой переменной. Нет, какой указатель? Никакой указатель не знаю.
То, что она получила указатель, это вне нашего уровня абстракции. Это как оно реализовано в низком
уровне. Задача компилятора сделать для вас ссылку и переменную неотличимой. И он это делает. Как он
это реализует внутри? Ну да, с помощью указателей. Но для вас ссылка и переменная неотличимы,
поэтому вы узнаете адрес исходной переменной, а не адрес какого-то там указателя. Дальше,
что если я спрошу size of y? Ну я узнаю size of x. Размер ссылки узнать нельзя. Я могу узнать размер
переменной, на которую ссылается. Но самой ссылки я не узнаю размер таким образом. Ну size of y,
если я спрошу. Это будет size of x просто. 4 байта. То есть вы могли бы захотеть узнать,
сколько байт ссылка в памяти занимает. Вы не узнаете. Вы только узнаете, сколько байт
исходной переменной занимает в памяти. По факту она вероятно хранится как указатель. То есть
занимает 8 байт, но вы это узнаете только вот. Ну например. Так, да. Да, отличный вопрос. Давайте
как раз про это и поговорим. Можно ли объявить ссылку? Ну давайте сначала начнем с того ссылка на
указатель. Это окей или нет? Вот я говорю int звездочка p равно, ну не знаю, null ptr и говорю int
звездочка амперсант r равно p. Это нормально? Да, это абсолютно нормально. Я взял ссылку на указатель.
Указатель это самостоятельный тип, а ссылка на... Ну то есть я просто назвал, я завел другое
название для этого указателя. r и p это один и тот же указатель просто. Ну я сделал ссылку на указатель.
А вот указатель на ссылку сделать нельзя, как и ссылку на ссылку. То есть вот так писать нельзя.
Значит указатель на ссылку это бессмысленная конструкция. Это c и e. Ссылку на ссылку тоже
сделать нельзя. Впрочем, если вы попытаетесь вот так написать, то это будет означать нечто другое,
а не ссылку на ссылку. Вот, но я сейчас не буду даже вскрывать эту тему. Просто давайте пока считать,
что так нельзя писать. Вот и значит, ну если вы знаете, что это такое, вы можете этим пользоваться,
если вы правильно умеете пользоваться. Что? R-value ссылка. Я не рекомендую вам сейчас гуглить,
вот. Во втором семестре вы настрадаетесь с ними. Вот. Я рекомендую вам пока считать,
что их не существует. Если считать, что их не существует, возможно они обойдут вас стороной
до конца этого семестра. Вот. В следующем семестре мы обязательно с ними поработаем,
но пока без ущерба для понимания и даже с пользой для понимания можно считать,
что такого не бывает и это нельзя так писать. Вот. Короче, ссылку на ссылку заводить нельзя.
Нельзя заводить массив ссылок. Массив ссылок заводить нельзя. Ну, то есть вот так нельзя написать.
Интомперсант А из 10, допустим. Все равно нельзя. Просто нельзя. Запрещено заводить массив ссылок.
Вот. И вектор ссылок тоже нельзя. Ты пробовал? Продемонстрируй, я не верю. Я думаю,
что вектор ссылок нельзя заводить. Возможно, с какого-то стандарта она стала можно. Вектор
ссылок заводить нельзя по той же причине, что и... Ну, потому что внутри себя вектор же хранит
указатель на T. А если T это ссылка, то получится, что у вас указатель на ссылку там внутри должен
храниться. И это проблема. Так решил комитет по стандартизации. Но это бессмысленно. То есть
это лишено здравого смысла. Что такое указатель на ссылку? Вектор ссылок нельзя заводить. Вектор
ссылок нельзя заводить. Все. А какая ошибка, кстати, когда ты пытаешь завести вектор ссылок? Создать
указатель на ссылку. Но это именно та причина. Потому что внутри, когда ты подставляешь вектор
тип T, вот этот вот, у тебя там внутри образуется вот такой тип. Потому что он внутри такой массив
пытается хранить. И все, у него не получится. А вот ссылку на массив можно. А как завести ссылку
на массив? Ну, надо просто так же написать int вот так вот. Ну, допустим, у вас был другой массив,
и вы сделали A с ссылкой на тот массив. Это ссылка на массив. Ну, как и указатель на массив,
также есть ссылка на массив. Синтаксис такой же. То есть что с указателями, что со ссылками. Нет,
мы ссылку пишем рядом с типом. Но если мы хотим вот так писать, то нам ничего не остается,
как брать в скобки это. Потому что рядом уже не получится. Потому что это приоритет, ну,
потому что иначе это будет массив ссылок, а так нельзя писать. Вот. Массив ссылок заводить нельзя.
Ссылку на массив заводить можно. Ну, в первую очередь партия вот эта. Это ссылка на массив из 10
int. Ну, в прошлый раз я разбирал довольно много примеров. Ссылками точно так же,
как с указателями работает. Дальше. Можно... Вот смотрите, были функции, были указатели на
функции. Отгадайте, что еще бывает. Ссылки на функции. Ссылки на функции. Можно завести ссылку на
функцию. Почему нет? Ссылку на... Ну, ссылка на указатель можно. Это мы уже выясняли. Ссылку на указатель
на функцию тоже можно. Но можно ссылку на функцию. То есть я могу сказать, ну, допустим, функция,
которая возвращает void, амперсант f равно, ну, не знаю, g. g это некоторая функция. Теперь f — это та
же самая функция, что и g. Ну, то есть... Я не знаю, какой в этом смысл. Там на stackoverflow есть вопрос,
как всегда, в котором люди пытаются объяснить, зачем это, может быть, надо. Ну, мало ли,
вдруг пригодится. Вот, кстати... А, да, еще ссылку на void заводить нельзя. Вот ссылку на void
заводить нельзя. Вот если это без скобок написать, то это получится, как будто бы пытались объявить
функцию, которая ничего не принимает и возвращает void, амперсант. Так нельзя. А вот ссылку на функцию,
которая возвращает void, можно. Стоп, а ссылка, которая вообще возвращает, например, им, если функция
возвращает ссылку на им. Да, это нормально совершенно. И такое даже часто будет нужно. Сейчас им, амперсант,
какая? Вот эта? Это... Да, ну, она зачертнута. А, нет. Сейчас я про это поговорю. Это будет...
Сейчас, короче, это отличный вопрос. Сейчас про его поговорим. Давайте пока еще пару того,
чем можно и чем нельзя. Ну, ссылка на функцию. Окей. Значит, массив ссылок. Да, ссылка обязательно
должна быть проинциализирована при создании, но мы это уже обсуждали. А еще ссылка обязательно
должна быть проинциализирована посредством lvalue. Да, ну, то есть нельзя написать int амперсант
там x равно 5. Это должна быть обязательно какая-то, ну, реально существующая переменная. Ну, то есть
lvalue, чтобы это не значило. Ну, там написать int амперсант y равно plus plus x опять-таки можно,
а вот написать x plus plus нельзя, потому что x plus plus возвращает временную копию,
которая как бы не является реально существующей в памяти переменной, и поэтому на нее ссылаться
нельзя. А вот на lvalue можно. Ну, это все равно, как если бы я сделал plus plus x, а потом int
амперсант y равно x, да. Вопрос некорректный. В lvalue бывают выражения, а не переменные.
Лишь про expression имеет смысл спрашивать, какое они lvalue. Что? Бывают, да, сейчас мы про них тоже
поговорим. Так, если ты хотел спросить, является ли вот такое выражение, является ли выражение
lvalue, если x-константная переменная нет, ну, является lvalue все еще. Так, ну хорошо. Значит, теперь,
что я еще забыл сказать, значит, чем можно инициализировать, что можно то, это все нельзя.
Хорошо, давайте теперь поговорим вот про эту проблему, про которую тут некоторые из вас
спрашивали. Что будет, если я из функции решу вернуть ссылку? Тут не знаю, равно нулю. Вот я
завел функцию, в которой завел локальную переменную и вернул наружу ссылку на нее.
Значит, что будет, если я попытаюсь в дальнейшем использовать возвращаемое значение этой функции
где-то в мейне, скажем. Значит, будет УБ, и это один из наиболее распространенных сценариев, как
возникает УБ на практике. Это очень болезненный сценарий. Это называется DenGlingReference, висяча ссылка.
Значит, что зачем нужно? Зачем? Так, с точки зрения компиляции я, конечно,
могу написать вот так. Ну, F это как ссылка на Инт, я создаю новый Инт из того Инта. В чем проблема?
Это с точки зрения компиляции. С точки зрения рантайма это уже УБ. Давайте я вам приведу пример,
когда это не УБ. Что? Да. Как не скомпилируется? И так тоже скомпилируется. Я создал новый Инт из того
Инта. В чем проблема? Вот здесь происходит копирование. Вот из того Инта, который там был,
я создал новый Инт с таким значением, как там. Это компилируется, но это УБ, потому что ссылка
указывает на переменную, которая уже реально уничтожена в памяти. Ссылка ссылается на локальную
переменную этой функции, но при выходе из функции локальная переменная снялась со стека, и у вас
фактически вы обращаетесь к участку памяти, на котором раньше лежала та локальная переменная,
но она уже снята со стека, и это УБ. Хоть это и скомпилируется, но это УБ. Да, вот если,
например, вам в функцию передали переменную, вот если вам передали переменную по ссылке,
то вы можете вернуть опять же ссылку на нее, и тогда все будет корректно. И с амперсандом
все будет корректно. Но если вам передали по значению, то опять УБ, потому что это же снова
локальная переменная получается. Она на стек кладется вместе с локальными переменными функциями.
Опять, когда вы возвращаетесь с функции, она снимается со стека, значит вы ссылаетесь уже
на нелегальную память. Почему это не CE? Догадайтесь. Так решил комитет по стандартизации.
Значит, что? Х – это локальная переменная для данной функции. Когда я возвращаюсь из
функции, х снимается со стека. Значит, да, это хороший вопрос, почему компилятор не ловит это в
compile-time? Кажется, что, вот я не уверен, но кажется это алгоритмически возможно было бы отлавливать.
То есть, всякий раз, когда я пытаюсь вернуть из функции что-то, ссылку на переменную область,
время жизни которой заканчивается вместе с этой функцией, кажется это можно было бы отлавливать
в compile-time. Ну вот, мы можем с помощью тернардного оператора намутить что-нибудь такое, типа я
ссылаюсь на переменную, которая при одном условии глобальная, при одном условии локальная. То есть,
можно было бы на этапе компиляции запретить и все это вообще такое, такие действия? Это warning,
да. Почему это не ошибка компиляции? Честно говоря, я не знаю, почему они этого не сделают. Возможно...
Ну не всегда. Ну не всегда. В некоторых случаях замечать, в некоторых нет.
Если мы x создадим через new, если x это будет переменная из динамической памяти,
или это будет глобальная переменная или статическая переменная, то да, конечно,
на нее ссылку возвращать нормально. Вот. А если вы возвращаете ссылку на кальву переменную,
то это denlin-reference, это уб классическая. Кого? Ну если вы здесь напишете int звездочка p равно newint,
а потом скажете return звездочка p, то это, конечно же, окей. Потому что под p лежит динамическая
переменная, и вы, более того, вы даже не потеряли тем самым указательную, потому что вы можете потом
delete, delete ampersand p сделать извне, и это будет нормально работать. Вот. Так, окей. В чем прикол
возвращать ссылки из функций? А просто тогда присваивать можно будет. Например, можно вот так
написать. Что? Ну. Указатель указывает на динамическую память. Я вернул переменную,
дальше я могу адрес взять. Конечно. Переменная лежит в динамической памяти. Вот у меня stack,
а вот динамическая память. Вот мой указатель указывает сюда. И что? Если я снова возьму адрес
этой переменной, то я получу адрес того же самого куска памяти. Нет, я же не видел delete,
не вызвал delete. Вот когда я вызову извне. Что? Этот указатель указывает куда-то в динамическую
память. Я взял то, что под ним. Получил. Ну да, тут, конечно, интересно. Тут такое. Ну да, а что?
Какой у него еще может быть адрес? Ну да, да, да. Ну дальше, если вы возьмете адрес, то я думаю,
да, все будет хорошо. Ну должно быть хорошо. Вы получите снова адрес того же самой переменной.
Она все еще в динамической памяти. Так, окей, это была проблема висячих ссылок. Какие-то еще там
вопросы были про ссылки. Ссылку на контест? Ссылка на указатель можно, ссылку на массив можно,
ссылку на функцию можно, ссылку на контест нельзя. Так, последнее, что я хочу сказать про ссылки,
вот что. Допустим, вы решили сделать такую перегрузку функций. У вас есть функция,
которая принимает int и функция, которая принимает int&. Вот, можно ли такую перегрузку сделать?
Нельзя, потому что тогда получается вы бы сумели отличать ссылки от исходных. Да, ну,
то есть это заблуждение, что, допустим, если вы заведете такую функцию и такую функцию, то когда
вы вызоветесь от х, вы поведете первую, когда вы вызоветесь от y, вы поведете во вторую. Нет,
нет, ничего подобного. Вот, ну, ты правильно думаешь. Это часто встречающиеся заблуждения. Люди
думают, ну ладно, ну я заведу две функции, таким образом отличу х от y. Нет, ничего подобного. Просто
вам запретят объявить две такие функции, потому что нельзя перегружать. Ну, я на самом деле не знаю,
в какой именно момент возникнет ce, в момент, когда вы, наверное, в момент, когда вы их объявите,
определить еще не возникнет, потому что типы формально разные. Но когда вы вызываться будете,
у вас будет ambiguous call, потому что что сюда пойти, что сюда пойти, разницы нет для него. Это одинаково
хорошо. Ну, я думал плохо или хорошо сказать, но это хорошо, это почти нет приведений типов.
Ну, формально с точки зрения компилятора все-таки есть, но для вас видимость как будто нет. Ну,
если вы почитаете формально правила разрешения перегрузки, там про ссылки тоже есть параграф,
что если там амперсант, тут нет амперсанта, но это мы забьем. Ну да-да-да-да-да. Компилятор
реализует это так, но это разные типы формально, но для вас не отличимые. В чем проявляется,
почему это? Ну, давай. Я про конс пока не говорил, про конс будет следующий параграф,
я сейчас к нему перейду. Для компилятора существенно, что это разные типы, потому что в случае
снятия одного из них со стека нужно уничтожать, а в случае другого не нужно уничтожать реальный
объект. Вы это, мы это обсуждали в прошлый раз. Ну, я еще раз повторю, что это ключевое вот,
что есть в плюсах, вот эти ссылки, потому что в джаве, в питоне вы с ними, у вас нет ссылок,
вы просто, когда пишете вектор b равно a, вы на самом деле создаете, вы ссылаетесь на тот
же самый вектор, вы не указываете явно ссылку, но это приводит к тому, что ему в рантайме нужно
считать количество ссылок, указывающих на каждый объект, чтобы вовремя удалять. За счет того,
что в плюсах мы явно указываем, когда мы делаем ссылку, в компайл тайме понятно, в какой момент
нужно что уничтожать, а в какой не нужно. Когда отмирает ссылка, уничтожать сам объект не нужно,
когда отмирает настоящий объект, тогда его очень нажать нужно. Кто сам не удаляет? Сборки
мусора нет, да, но это тоже правда, у нас еще сборка мусора должна была бы быть. Все, про ссылки,
ну пока все, то есть это тема, к которой нам предстоит возвращаться еще неоднократно. Вот,
а теперь константы. Это предпоследняя тема перед началом большой эпопеи. Итак, предпоследняя тема
это константы. Можно объявить константную переменную, но я опять буду в примере ИНТА.
Что такое константный ИНТ? Что вообще такое константный Т, где Т некоторый тип? Нет,
подождите, вы вообще на какой вопрос пытаетесь ответить? Я пытаюсь понять, что это за тип такой?
Какое value? Я пока ничего не говорю про value. Ну не с одним. Я думаю, все вы пользуетесь константами
хоть раз в жизни. Я попытаюсь сейчас точно так же, как я навел правильную интуицию насчет ссылок,
как нужно мыслить о ссылках. Я сейчас попытаюсь донести, как нужно правильно мыслить о константах,
чтобы у вас правильно отгадывать, что произойдет в разных ситуациях. Какая должна быть правильная
интуиция о том, что такое константный тип? Это такой же тип, как и исходный, но это другой тип,
и отличается от исходного он тем, что в нем некоторые операции запрещены просто. Ну вот,
я в свое время, когда мне первый раз рассказывали про константы, и когда я вообще с ними работал в
плюсах, константы это еще одна очень большая боль, как и ссылки. Если вы с самого начала
неправильно себе представляете, что такое константы, у вас какая-то неправильная в голове модель мира
относительно них, то вы будете не отгадывать, что будет происходить, вы будете постоянно напарываться
на то, что происходит какая-то дичь неожиданная для вас. Как нужно правильно мыслить о константах?
Просто представляйте их себе как тип с урезанным функционалом. У вас есть, не знаю,
рациональные числа, в них еще деление определено, а вот в натуральных не определено. Ну, на множество
натуральных чисел нельзя делить, потому что ты выскочишь из множества. Ну типа если рассматриваешь,
не знаю, вы можете рассматривать целые числа, и там есть сложение, вычитание, умножение. А можете
рассматривать рациональные числа, там есть сложение,
вычитание и множение деления.
Вот, ну то есть это просто тип, у которого части операции
отсутствуют.
Вот, значит, константный тип, это тип, во всем похожий
на исходный, с той разницей, что часть операции в нем
отсутствует просто.
Вот это правильная интуиция относительно констант.
Вот, ну а какие в нем операции отсутствуют?
А в нем отсутствуют… Да.
Они взяли копию пасты и вырезали нескольких
пластов, да?
Ну, типа, примерно.
Ну, какие операции в нем отсутствуют по сравнению
с обычным int?
А вот как раз те, которые модифицируют этот аргумент.
Ну, то, что они модифицируют этот аргумент, это как
раз вторично.
Вот первично, то, что они у константа отсутствуют.
Вот, операции как раз называются модифицирующими, если они
у константа отсутствуют.
То есть формально операция может ничего не менять с переменной, ну по факту она может не
менять с переменной, но если она не разрешена для констант, она считается модифицирующей.
Ну это довольно сложно понять на примере int, это будет понятно, когда вы будете свои классы писать,
и вы поймете, что далеко не всегда операция, запрещённая для констант, на самом деле что-то
меняет. Она может ничего не менять, просто быть запрещённой для констант. Ну констант просто часть
операции отсутствует. Давай не будем, я понимаю о чём ты говоришь, ты забегаешь вперёд, пока не надо
про это. Потому что констант и компилятор может соптимизировать и встроить в код прям.
Давайте по порядку, давайте по порядку. Сначала какие операции запрещены? Ну какие? Присваивание
запрещено и все составные присваивания, понятно, вот с левым аргументом константа не запрещены.
Инкремент и декремент запрещен. Что ещё запрещено? Все вроде. Нет, это уже другое,
это уже сейчас приведение. Ну вот по сути да, чем отличается константный int от неконстантного?
У константового просто отсутствует часть операции, вот эти операции отсутствуют, возможно ещё какие-то,
я забыл. Вот эти операции, они потому и называются неконстантными, что у константа отсутствует. Ну то
есть попытка вызвать любую из этих операций над левым аргументом. X это будет CE. Просто нет
такой операции. Вот, но это не отменяет того, что X это L-value. И вот вам пример L-value,
которому нельзя присваивать ещё один. Ещё один пример был R-massive. Что? По определению. Ну
переменная это L-value. Вид value определяется синтаксически по виду выражения. Вот если у вас
просто переменная, то это L-value. Если у вас префиксный инкремент, то это L-value. Если постфиксинг,
то R-value и так далее. Это не зависит от того, какой там тип. Ну, почти не зависит. Если вы свой
напишете, вы можете всё испортить. В общем, это вот ещё один пример L-value, которому нельзя
присваивать. Но не берите в голову, забейте сейчас на то, какой это вид value. Это я так в сторону
немножко ушёл. Короче, нельзя присваивать и нельзя инкрементировать. Так, какие были вопросы
про константы? Ну давай. Можно ли как-то захакивать константы и изменить значение,
которое по ней лежит? Можно. Можно. Но про это я расскажу в параграфе 2.7. Давайте другой вопрос
какой-нибудь пока. А, да. Зачем нужны константы? На самом деле, я бы сказал так. Вообще константы,
я тут уж не знаю, имею ли я моральное право судить, значит, создателя за такое решение. Но вот
помните, я вам говорил, что неявные касты — это одна из больших ошибок в проектировании C++ была,
по мнению самого создателя. Вот. Константы в том виде, в каком они существуют в языке C++ — это
очень, ну я не уверен прям, что это очень большая ошибка, но это большое неудобство. Если бы константы
были изначально спроектированы иначе, то писать на плюсах было бы гораздо проще. Вот. Дело в том,
что в плюсах всякий раз, когда вы хотите запретить менять объект, вам нужно явно это сказать. А когда
вы не хотите запрещать, вам не нужно ничего говорить. То есть, по умолчанию, то, что вы
пишете изменяемо, пока вы явно не скажете, что оно не изменяемо. Странно. Логичнее было бы
сделать наоборот. Потому что в одном случае вы всегда забываете сказать, что оно изменяемо,
не изменяемо, потому что ошибки-то нет. Когда вы написали и пытаетесь изменить, ошибки нет. А
когда вы пытаетесь сделать наоборот, ну короче, если бы система была наоборот устроена, то вам бы
компилятор просто говорил всякий раз и забыл написать здесь слово изменяемый. Вот. Поэтому путаница
очень большая с константами возникает из-за того, что нужно все время помнить, держать в уме вот
это вот самому. А это константы или не константы? Если константы, то мне надо обязательно писать
конст. По-моему, в Rust-е что-то попытались сделать наоборот, но я не уверен. Я не знаю Rust. Вот.
Но, короче, да. Зачем нужны константы? Ну, про то, что там это какая-то ошибка, это вперед забежал
опять-таки. Пока первоначально нужны еще константы. Ну, чтобы объявить в коде какую-то величину,
которая меняться не будет. Что за глупый вопрос? Зачем же константы? Ну как? Вот вам захотелось,
не знаю, какой-то вот констинт модулус равной, там, какой сейчас принято делать, я забыл,
вот это число классическое. Вот он у нас сквозь... Нет, там сейчас, там сейчас, да, там сейчас в моде
какой-то другой, по-моему, стал. Ну, короче, да. Ну вот вам захотелось сделать просто число,
которое не меняется в течение работы программы. Вы его назвали константой. Отныне попытки его
изменить будут приводить к CE. Вот. А что это еще вам дает? А это вам дает то, что компилятор,
видя, что вы написали конст, он может опять-таки не заводить под это реально в памяти ячейку,
а просто ваши выражения подставить сразу и предвычислить даже некоторые из них. Вот,
естественно, компилятор видит, что вы объявили что-то константой, он имеет право в целях
оптимизации взять и просто подставить, ну, захардкодить это число в те места, где вы его
используете. И даже предвычислить некоторые выражения прямо в compile-time, если он понимает,
что и так понятно здесь, что будет деление на два, например. Ну, например, вот у вас x это,
скажем там, 16, когда степень двойки. Компилятор, зная, что это 16, оно никогда не будет меняться,
может деление на x заменить просто побитым сдвигом на 4, потому что он же понимает,
что оно не изменится и, значит, он эффективнее может оптимизировать. Вот зачем нужны константы.
Вот, но все становится интересней, когда на арену выходят указатели со ссылками. Да,
ну давайте сначала просто, вот если я говорю, constant x равно 5, int y равно x, так можно? Ну,
конечно, можно. Я просто создал новый int из того, и этот int это уже другой, это не тот же самый,
он изменяемый. Вот, ладно, ну и, конечно, я могу сказать const int z равно y. Я создал еще один int из
того, этот z теперь не изменяемый, но это все три разных int. Вот, что происходит, если я с
указателями пытаюсь работать. Окей, вот у меня есть const int x равно 5. Могу ли я сказать int
звездочка p равно адрес x? Нет, CE, нарушение константности, потому что указатель на int это
такая сущность, которая подразумевает, что разыменовав ее, вы получите int. То есть менять можете
то, что под ним. Вот, но здесь вы не должны уметь менять то, что вы разыменовываете. Int звездочка
это такой тип, что по операции разыменования он возвращает просто int. Ну, если быть точным,
ссылку на int. Вот. Ну, считайте, что просто int. Вот. И поэтому такая фигня не скомпилируется,
потому что у вас будет нарушение константности, вы тогда получаете разыменовывать, сможете менять,
они должны. Поэтому, если вы хотите указывать на констант, то вам надо const повторять,
const int звездочка p равно да. Это замечательный вопрос, очень правильный. Хорошо, вот я написал
const int звездочка p равно %x, а могу я сказать plus plus p? Могу, конечно, потому что это указатель
на константный int, а вовсе не константный указатель на int. Если я хочу сделать указатель,
который нельзя менять, то это пишется так. Я пишу int звездочка и const справа от звездочки.
Это указатель, менять который нельзя. Вот это константный аналог int звездочки. То есть вот
к этому b уже не применимо, plus plus, к самому b не применимо. Но если я разыменую b, я получу
просто int, и вот то, что под ним, то есть результат разыменования, я могу менять,
что хочу делать. Я могу написать const int звездочка const, и это будет означать,
что ни сам указатель сдвигать присваивать нельзя, ни после разыменования, то что под
ним сдвигать присваивать нельзя. Да, можно написать int const звездочка const. Надо запомнить,
если const перед звездочкой, то это означает, что он относится к тому, что под указателем,
а если const справа от звездочки после звездочки, то значит этот const относится к самому указателю.
Значит тест. Это что я сейчас объявил?
Почему? Нет, все нормально, но тут надо только правильный инициализатор написать, но я могу
написать на lptr, что я отупарюсь. Константный указатель на указатель, на константный указатель,
ну то есть сам этот указатель менять нельзя, но то, что под ним менять можно, а то, что дважды
под ним менять опять нельзя, то, что трижды под ним менять опять можно. Что? Бьёрн Страуструп,
я рассказывал на первой лекции. Чё вы такие вопросы? Не смейте оскорблять создателя. В СИ не было
const, их потом ввели, но изначально в СИ не было const, как из ссылок. Константный указатель
на указатель, на константный указатель на int. Да, это очень мудрая мысль, кстати. Наверное,
поэтому так и сделано. Потому что изначально не додумались добавить const, но об этом не подумали,
блин, это какие годы были, там 70-80-е годы? Господи, ну да, то есть ещё раньше, ну то есть тогда об этом,
конечно же, заранее не подумали, но когда поняли, что надо бы ввести const, уже нельзя же было всё
наоборот переделать, поэтому вот так, да. Ну да, можно написать const int звёздочка p,
а можно писать int const звёздочка p, нет разницы, как и здесь можно писать int const x, это неважно,
но мы будем писать const перед типом, по код стайлу. Не знаю, была пробой, думаю нет. Константный
указатель на обычный указатель, на константный указатель на int. Ну да, да, да, да, да, то есть
вот это константный указатель на int. Вот это константный указатель на обычный указатель на
константный указатель на int. Ну да, есть пословица, ехал const через const, видит const в реке const,
ну продолжение вы знаете. Да, ну короче, да, когда вы пишете на плюсах, вам нужно постоянно и много
раз в разных местах писать слово const, и если вы забудете, то ошибки компиляции вас впечатлят.
Вот, значит, умение по огромному логу ошибок компиляции понимать, в каком именно месте забыто
const, это отдельное искусство, вы ему будете учиться весь этот год. Вот, к концу года, я думаю, вы научитесь.
Просто предупреждаю, что вам, что нам предстоит с этим какое-то время жить. Так, итак, это были
константные указатели, указатель на константный, теперь константные ссылки. А, нет, еще не сразу,
вот смотрите, если у меня есть обычный int, если у меня есть обычный int, то могу ли я завести const int
звёздочку на него.
Конечно могу, потому что каст в эту сторону неявный
разрешён.
Приведение типов от неконстанты к константе разрешено,
и оно делается очень легко и неявно.
Вот это вот имеет тип int звёздочка.
Я пытаюсь constant звёздочку пронизализировать через
int звёздочка.
Это можно.
То есть я дополнительное ограничение себе таким
объявлением накладываю.
Вот это вообще-то указатель на неконстанту, но я буду
считать его указателем на константу.
И под этим менять, и теперь написать плюс-плюс звёздочка
b нельзя.
А плюс-плюс a можно, и тогда то, что лежит под b поменяется.
Но само b, то, что под b лежит, через вот это менять нельзя.
А то, что там лежит, менять можно через a.
И это на самом деле не так уж странно.
У вас просто есть разные способы доступа к одному
и тому же.
Один с доступом на запись, другой с доступом только
на чтение.
Вы же не удивляетесь, если у вас есть там, грубо говоря,
два юзера.
Один имеет право и читать и писать файл, другой только
читать из файла.
По сути, вот это оно и есть.
Вы сказали, вот через это разрешено только чтение,
а через это и чтение и запись.
Теперь константные ссылки.
Вот у меня опять есть обычный INT, и я решил завести ссылку.
Но я решил написать вот так, const int&b равно a.
Все нормально.
Я сказал теперь, что b это другое название для a, но
с той разницей, что b не допускает изменения, а a допускает.
Когда мы меняем a, конечно же меняется b.
Потому что a и b это одно и то же.
Просто называя его b, менять мы его не можем.
А называя его a можем.
Вы...
Да, это очень удобно именно для передачи функцию.
Потому что в функцию вы зачастую хотите передавать
тот самый объект, с которым вы ходно работаете, но запретить
функции менять его.
В этом смысл.
То есть вы хотите иметь дело с тем самым объектом,
не создавая его копию, но чтобы функция вам случайно
его не испортила.
Вот для чего это нужно в основном.
Поэтому, на самом деле, вот такое преобразование
типов, оно делается...
Это одно из самых распространенных преобразований типов,
которые в реальности используются.
Всякий раз, когда вы что-то функцию отдаете по ссылке,
вы, как правило, именно так делаете.
Вы отдаете по константной ссылке.
Вот это называется константная ссылка.
Это называется константная ссылка.
Вот.
Дальше.
Ну да, я могу поменять A, и поменяться B тем самым.
Поменять B я не могу.
Но, конечно же, я теперь не могу написать вот так.
Вот это будет CЕ.
Если я теперь решу обычную ссылку создать из B,
то это, конечно же, CЕ, потому что
B это константный int,
а я пытаюсь его сказать, что это...
Да, да, да.
То есть сказать теперь, что
имея B получить права на запись к нему,
таким образом я не могу.
Но если я здесь напишу A, то все нормально.
Ну понятно.
То есть A дает мне право как менять int,
так и передавать его дальше с правами на изменение.
B дает мне право только смотреть на int.
И, конечно же, имея B, я не могу дальше никому выдать права на запись к нему.
И, конечно же, имея B, я не могу дальше никому выдать права на запись к нему.
Все.
Имея B, получить не константную ссылку я уже не могу.
Ну, разумеется, если у меня есть
исходно константный int,
то на него я могу только константные ссылки делать.
То есть если у меня есть констант int X равно чему-то,
то написать int % B равно B я не могу уже.
Потому что, ну понятно,
исходно не было прав на запись, откуда они возьмутся.
Вот.
Зачем писать когда-либо констант,
если можно просто не менять ничего?
Вот.
Тут мы приходим...
А, ты что-то хотел сказать.
Тут мы приходим к трем, значит, важным...
Я бы не сказал прям столпам.
Ну, короче,
как правильно
передавать аргументы в функцию?
Этот вопрос,
который будет тоже вас...
Это один из вечных вопросов
языка C++.
Вот.
И сейчас мы подступимся к нему в первый раз,
но далеко не в последний.
Дискуссия на эту тему
не утихает и по сей день в профессиональном сообществе,
как это делать правильно, в каком случае.
Но давайте для начала осветим
возможные варианты
с, так сказать, наивным взглядом.
Когда вы хотите что-то передать в функцию,
у вас есть, по сути, три
способа.
Передать это по значению,
по обычной ссылке или по константной ссылке.
По константному значению
передавать
нет смысла никогда.
Потому что
если вы что-то хотите передать по значению,
то вам не важно
будет функция его менять
или не будет.
Если вы хотите функцию
отдать копию чего-то,
то вам не важно, что функция сделает с копией.
Поэтому...
Ну вот тут начинается
философия,
что якобы иногда...
В общем, более-менее
профессиональное собственность
сходится в том, что по константному значению
не надо передавать ничего никогда.
Вот.
Вот вроде как так принято
большинством код-стайлов. По константному значению
передавать это что-то бессмысленное
и странно.
Вот.
Поэтому на самом деле
есть реально три
способа.
То есть можно передать...
Ну давайте я буду не Инт писать, а произвольный Т.
Да.
Да, можно передавать по обычной ссылке,
а можно передавать по константной ссылке.
И надо каждый раз, когда вы объявляете
какую-то функцию, думать
о том, каким способом
она принимает каждый из своих аргументов.
По значению она должна
его принимать. И если вы действительно
хотите копировать это значение каждый раз,
когда передаете функцию, надо понимать, что если это тяжелый
тип, например, вектор или строка,
то она будет реально создавать полноценную копию
с выделением новой памяти, чтобы отдать в эту
функцию и в конце функцию уничтожать
эту локальную копию.
Если вы передаете по ссылке, то есть вы не хотите
копировать, то вы, конечно, несете
небольшие издержки, что обращение
к этому будет стоить вам разыменование
указателей на практике в реальности.
Поэтому
маленькие типы вроде Инта
и Чара так не принято передавать.
Вот по константной ссылке принимать Инты
не принято, потому что их можно
понимать по значению, это дешевле будет.
Но если вам
нужно, чтобы ваша функция меняла
ваш объект, который вы передали, то ваш выбор
это не константная ссылка.
Ну да, если у вас маленькая
переменная,
какого-то примитивного типа, то
не принято передавать ее по значению.
Ой, по константной ссылке.
Вот два наиболее
распространенных способа принимать функцию
это по значению и по константной ссылке.
Самый распространенный
это по константной ссылке.
Наиболее часто вы будете
видеть в реальном коде и будете писать
в своем коде вот такие функции, которые
принимают константные ссылки, потому что
как правило вы работаете с объектами сейчас
и вы не хотите копировать эти объекты.
Но если вы работаете с объектом
и действительно осознанно хотите его скопировать,
что функция с ним что-то сделала,
то это ваш выбор.
И это также ваш выбор, если вы Инт
передаете. Что?
Это прекрасный вопрос, и сейчас я как раз о нем
буду говорить следующим
пунктом.
Да.
Да,
если вам
указатель как бы он
это самостоятельный тип такой. Ссылка
не совсем самостоятельный тип, это как бы другое название
для. Вот.
Если вы хотите иметь дело
с указателями, можете передавать по указателю,
да. Но мы
имеем дело с указателями,
хотим иметь дело с указателями,
то когда реально это необходимо,
мы что-то с памятью хотим делать.
Вот. Ссылки пришли
на замену указателям, чтобы нам не
приходилось брать адрес и разыменовывать постоянно.
Мы стараемся избавиться, мы стараемся
вот так писать, если мы не хотим копию создавать.
Вот. А теперь замечательный
вопрос, очень правильный,
который
на самом деле логически следует из вот
этого вот, что я сказал. Раз
функцию можно,
ну, функции могут принимать объекты по константной
ссылке. Это означает,
что они обязуются не менять их и не копировать,
пока когда передаются.
Ну вот, допустим, у меня есть функция, которая принимает
const string&
то есть константную
ссылку, ну, константную ссылку на string.
А
могу ли я туда
отдать
строку, которая вот не
переменная, а только что созданная строка?
Там...
Что слабое?
В этом-то и проблема. Я же говорил, что
ссылки нельзя инициализировать посредством R-value.
То есть ссылку можно инициализировать лишь
реально существующей переменной.
А тут получается, что я пытаюсь
инициализировать ссылку временным значением,
которое даже в переменную ни в какую не записано.
Это неважно. Я пытаюсь
инициализировать ссылку временным значением,
которое не хранится ни в какой переменной.
Я могу тебе не string привести пример,
а любой другой. Вот у меня f принимает
const &&, а я 5 передаю
сюда. Что будет?
Могу ли я проинциализировать
константную ссылку конкретным
значением R-value?
Мы с ней не можем сделать ничего такого,
что нельзя было бы. А как компилятор
это должен реализовать?
Да нет, ложно.
Я не хочу проинциализовать.
Мы же не на стол хотим сказать о нём.
Так, я уже чувствую, что разрожается дискуссия.
Тихо, тихо, тихо
тебя ждет
ещё одно удивление
сейчас. Я предупреждаю.
Сиди, держись за стол
крепко. Можно так делать.
И можно так делать.
и можно так делать ровно по этой причине потому что вот такой способ принятия
аргумента функцию самый распространенный и было бы странно если бы чтобы передать
что-то функцию которая не собирается это менять и не хочет это копировать вам бы приходилось
заводить отдельную переменную и только потом эту переменную туда передавать у вас очень многие
функции стандартные вообще любые в любой библиотеке у вас функции зачастую имеют вот такую
сигнатуру не принимают объекты по константным ссылкам и очень хочется чтобы можно было в эти
функции отдавать объекты без перед без создания переменных под них а просто вот объекты как есть
числа например там не знаю поэтому это разрешено что же должен компилятор тогда с этим делать ну
он должен временно создать переменную под это как бы пока не отомрет вот эта ссылка это называется
lifetime prolongation продление времени жизни объекта когда вы инициализируете константную ссылку
посредством airvalue компилятор запоминает вот эту вот самую вот первую константную ссылку посредством
которой был объект который был проинциализирован этот объект и компилятор соответственно будет
уничтожать этот объект когда отомрет вот это вот исходная ссылка по которой он был проинциализирован
ну то есть я могу в мэйне написать грубо говоря конст стд стрингом персант там я могу написать
конст стрингом персант но стд я опускаю там s равно abc дальше я эту s куда-то передаю функции
создали другие ссылки на нее что там еще делаю но вот когда заканчивается область видимости вот
этой ссылки строка уничтожается это называется продление времени жизни потому что
если вы ну
ну тут давайте я сейчас не буду вдаваться в подробности как именно создается строка
из сишной строкея потому что это уже немножечко оп и вам это кстати самим предстоит скоро
реализовывать вот я просто пока говорю что я могу создать объект проинциализирую создать объект
посредством заведения константной ссылки на тип они самого то есть я могу объявить исходно объект
не как стринга как констрингом персант и эта строка будет жить пока жива вот это вот это
переменная исходная остальные ну компилятор вынужден это запоминать это называется продление
жизни посредством константной ссылки вот возникает вопрос а почему нельзя также сделать для обычной
ссылки тогда ну вот этой строки ну как тут как бы ну тут как бы создалась временная строка вот
она создалась там в динамической памяти выделился буфер и там значит ну что-то создался объект вот
эта строка не уничтожается пока вот эта переменная не выйдет из области видимости хотя если бы я
просто написал стринг обц точкой запятой то она бы уничтожилась сразу же когда когда создалась вот
для обычной ссылки для обычной ссылки по идее можно было бы сделать также но есть но это волевое
решение было это на самом деле очень глубокий глубокая мысль почему если константная ссылки
умеют продлевать жизнь объектам почему обычные не умеют вот ну то есть можно сказать так решил
комитет по стандартизации на самом деле так решил сам создатель и он решил это неспроста а
дело в том что есть один плохой пример когда продление жизни обычными ссылками приводила бы
к проблемам и вот какой но прежде чем показать этот пример я вам сначала задам интересный вопрос
давайте представим что у меня есть int x равные ну не знаю пяти люблю числа 5 а потом я говорю
конст дабл амперсант игрок равно x как вы думаете что будет
дело в том что int умеет кастоваться к дабл создавать временный дабл из
него а конст дабл амперсант умеет инициализироваться временным даблом это значит что инт не явно
скатится в дабл то есть x не изменит с x ничего не случится но создастся временный дабл из
него и вот к этому временную даблу будет привязана вот эта вот ссылка после этого вы сможете
менять x и на игрок это никак не повлияет потому что дабл создался из x то есть у вас был x x это
поменять тип x вы никак не можете как я говорил в самом начале неоднократно но дабл но это чем-то
надо проинциализировать что делает компилятор он видит что у него есть каст из инта в дабл а
этот дабл рвл ю можно проинциализировать им этот амперсант значит он применяет этот каст таким
образом у вас образовываются две перемены одна из которых инт спокойно вы с ним можете работать
а другая дабл со значением 5.0 изменение x не повлияет на этот дабл а дабл будет жить
отдельно но он будет константный ну да что что ну проверьте что так работает но так должен
работать да я вот просто вот этот вот отдельный пример рассматриваю потому что тут прямоугольник
нарисован поверх этого забейте это будет ce потому что нельзя ссылки инициализировать
временными объектами не переменными ну фактически да если мы заменим дабл на
ин то он будет просто на тот же самый инц ссылаться да а так создается отдельная
переменная под дабл да потому что это разные переменные что это же игрок ссылается на временный
дабл который был создан из инта посредством неявного каста это будет ссылаться на 1 это будет
одно и то же тогда x и y будет одно и то же но сейчас ты не одно и то же потому что но это не
может быть одно и то же игрок ссылается на дабл а и а икс на ин в как они могут быть одним и тем
смысле за что именно сделали зачем разрешили каст не явный к из инта в дабл или зачем разрешили
привязывать константные ссылки к временным объектам ну каст из инта в дабл не явный
создатель уже уже раскаивался а привязывает ссылки к временному объекту я объяснил почему
разрешили потому что нельзя привязать да кстати вот это хороший вопрос если здесь консту брать
написать просто дабл амперсант тихо дабл амперсант игрок равно икс почти что будет будет
сие потому что нужно привязать ссылку на дабл к инту но нельзя же ссылаться не над свой тип
значит нужно создать из инта дабл он будет временным но нельзя ссылку не стилизировать
временным даблом это будет сие со словами попытка инициализирует ссылку посредством
рвэлью это если конст не было бы вот и здесь кроется разгадка почему запрещено продление
жизни обычными ссылками не константными потому что представьте у вас было бы оно разрешено и
вот вы пишете допустим у вас есть какая-нибудь словно функция там не знаю своп которая принимает
ссылку на инт и другую ссылку на инт а вы подсунули этой функции два дабла но вы чуть-чуть ошиблись
в типе у вас функция принимает две ссылки и вы с ними что-то делаете а вы этой функции подсовывайте
не совсем тот тип потому что вы ну чуть забыли что тип не совсем такой чуть ошиблись тогда если
бы так можно было делать получилось бы что у вас произошел не явный каст эти ссылки про
индициализируют временными значениями созданными из вашего типа и вы думаете что вы передали их и
меняете свои собственные объекты но из-за того что вы чуть-чуть не отгадали тип у вас произошло
бы на самом деле каст который вы не заметили и вы думали что вы меняете их на самом деле не
меняете и это не было бы никакой ошибкой вы вот никак не отловили вот по этой причине страустроб
запретил продлевать жизнь объектов не константными ссылками но константными вот нужно оставить
потому что вот такая передача по ссылке нужна ну и последнее как вы думаете что означает
вот такая запись ну там на самом деле я даже не знаю это то ли ци то ли то ли ничего но
это бессмысленно так писать нет смысла потому что константность комперсанту то есть нет смысла
пытаться возможно это ци я не помню на самом деле это ци да вы проверили да это ци хорошо ну так
все равно не надо писать никогда ну понятно даже если бы это было не ци это бессмысленно это
бессмысленная запись потому что она ничего не дабы вот этот констант ничего не дает он как бы
говорит что сама ссылка она должна не это бессмысленно потому что ссылка и так не может
быть перепривязана к ничему другому в случае с указателями конст вправо от звездочки осмысленен
это значит что указатель двигать нельзя в случае ссылок константа не осмысленен это ци просто вот
и последнее допустим у меня есть вот такая функция и вот такая функция могу ли я перегрузку сделать
да могу принять по ссылке принять по константной ссылке это разные в общем то вещи если я буду
передавать константу то я попаду в эту версию если не константу то в эту версию то есть я могу
делать перегрузку в зависимости от того по константной или по неконстантной ссылке я принимаю это
прям раз ну то есть int и const int это разные типы и если я хочу int отдать или const int отдать это
раз я ну причем в эту сторону неявный каст разрешен если у меня есть функция которая принимает только
это то я могу и обычной int отдать вообще легко но если есть функция которые принимает только это
то констант на int я не могу и отдать конечно и если есть функция которая принимает t по значению
то тогда перегрузку уже ломается перегружать вот это с этим нельзя как я уже говорил и перегружать
вот это с этим тоже нельзя то есть принять по значению или по константной ссылке из этих
вариантов выбор сделать нельзя. Компилятор, ну эта перегрузка запрещена. Это будет амбигиус-кол.
Все, вопросы? В общем, там третья строчка, там констанция, можно засунуть в мерсенте
Ну догадайся, исходя из того, как я на доске пишу все это время. Наверное, я пишу так,
как я рекомендую не писать. Нет, по код-стайлу мы пишем вот так. Более-менее так все пишут.
Что еще раз? Что такое ссылка на лямбдо-функцию? В смысле, какой тип-то там будет? Давай в перерыве.
У лямбдо-функции ты не можешь тип точно назвать, тебе нужно будет и слово авто использовать для этого.
Нет, это нормально. Так, отставить. Все, нет, мы короче не будем про это сейчас отговорить.
Вопросы вот в рамках вот рассказанного есть? Какого черта? Это C++.
Ну это разные типы принципиально тогда вообще. Какой разговор? Если вместо ссылки указатель,
ну да, если ты вместо ссылки сделаешь указатель, да, точно так же будет работать.
А вот T звездочка и T звездочка const нельзя перегружать. Ну если у вас есть f от int и f от
const int, то так тоже нельзя перегружать, если нет амперсантов. Потому что и там и там копия непонятна.
Ну const int вообще не надо никогда принимать, я вам говорю, поэтому так это не актуально.
Ну и последняя тема, прежде чем мы сделаем перерыв и дальше начнем творить великие дела. Последний,
так сказать, параграф из области. Введение нам последний перед бурей. Это type conversions. Я
много вам рассказал про то, какие бывают типы, какие бывают странные указатели, ссылки массива
и так далее. И последнее, что нам надо обсудить, прежде чем мы начнем писать ООП, это какие есть
приведения типов. Значит в C++ есть пять способов приведения типа. Пять принципиально разных,
все они по-своему применимы в разных ситуациях. Нет-нет-нет-нет, вы не поняли, это не относится
к указаниям. Есть пять операторов приведения типа. Обычное приведение типа, сишное, статическое
приведение типа, динамическое приведение типа, reinterpret и константное приведение типа. Ну есть
пять операторов приведения типа, sys-tile-cast, static-cast, dynamic-cast, reinterpret-cast и const-cast. Все они
в своих ситуациях нужны и, значит, нам их все предстоит с вами изучить. В перерыве задашь
тогда. Тогда в перерыве задашь. Значит, на самом деле все не так страшно, как кажется. Я вам сейчас
озвучу первое правило приведения типа в C++, которое исчерпает большую часть ваших нужд в
приведении типа. Во-первых, приведения типа нужно стараться избегать, но это скорее нулевое
правило. А первое правило приведения типа звучит так. Если вы ничего не знаете о приведениях
типа и не знаете, какое вам нужно, значит вам нужен static-cast. Во всех остальных ситуациях вы
скорее всего будете подозревать, что приведение типа не совсем обычное, наверное, нужно что-то
иное. Вот все те приведения типов, о которых вы скорее всего сейчас думаете, когда я говорю
приведения типов, это static-cast называется. Нет, не sys-tile-cast, а static-cast. Есть такой оператор static-cast.
Как он пишется? Вы пишете static-cast в угловых скобочках. К чему? В обычных скобочках от чего?
Ну, то есть вы говорите там static-cast, допустим, к double от там от x, где x это int. Вы тем самым
делаете явное приведение типа от int к double. Вот. Да, sys-tile-cast. Сейчас я скажу, возможно,
для кого-то пугающие вещи, sys-tile-cast запрещен код-стайлом. Статик-cast. Я же первое правило
приведения типа. Всякий раз, когда вам нужно приведение типа и вы не разбираетесь, какое,
значит нужен static-cast. Нет, define запрещены тем более. Значит, ну, я на самом деле не знаю,
что еще сказать про static-cast, кроме того, что это вот то самое приведение типов,
которым скорее всего исчерпываются все ваши представления о приведении типов сейчас. Вот.
Ну, ты какой-то слишком умный пока. Пока этого ты не должен был знать. Значит, итак, static-cast это
вот классическое приведение типов, которое надо использовать всякий раз, когда вам нужно обычное,
чтобы это не значило приведение типов. Теперь, что же это все-таки за остальные приведения
типов, для чего они нужны? Из int в строку это не приведение типов, это функция преобразования,
то есть data-string. Но это не приведение типа. Это не приведение типа. Приведение типа — это вот
именно из одного типа сделает другой, не посредством функции, а вот посредством каста. Вот.
Dynamic-cast я пропущу. Сейчас не буду об нем рассказывать. Значит, ну, есть еще dynamic. Вот есть static-cast
и есть dynamic-cast еще. Dynamic-cast. Сейчас я не буду рассказывать, что такое dynamic-cast. Нет,
я не буду сейчас рассказывать, что такое dynamic-cast, просто потому что не хочу. Расскажу я о нем через
месяц примерно. Ну, просто сейчас вы пока не готовы к этому. Вот. Пока еще мы не готовы с вами
понять, что такое dynamic-cast, пока мы будем считать, что dynamic-cast не существует. Потребность в нем мы
осознаем примерно через месяц, и тогда и поговорим, что, оказывается, есть еще такой-то каст. Вот. Я
сейчас расскажу вам про остальные три каста, и я буду рассказывать о них в порядке ухудшения,
значит, в порядке устрашения. Я люблю называть их запрещенными заклинаниями языка C++. Вот. Значит,
три запрещенных заклинания языка C++, да. От самого лайтового к самому ужасному, и самое
лайтовое из трех, наверное, это reinterpret-cast. Значит, что такое reinterpret-cast? Reinterpret-cast.
Опять в угловых скобочках к чему и в скобочках от чего. Reinterpret, да.
Судя по названию, это по битовому отчету. Да. Это такой каст, который позволяет вам сделать,
например, следующее. Он говорит, возьми биты вот этой переменной и трактуй их, как будто это
другой тип. Никаких преобразований не делай, просто у тебя там int лежал, прочитай эти биты,
как будто там дабл записан. Ну, возможно, да, возможно. Значит, если вы на самом деле при
reinterpret-cast'е... Нет, получится всегда, все получится. Просто будет UB всегда. Ну, то есть,
вы можете любой тип привести к любому с некоторыми оговорками, о которых я скажу в следующем пункте,
а вы можете с помощью reinterpret-cast любой тип привести к любому. Просто прочитать биты одного
типа, как биты другого типа. Вот. Только надо понимать важную вещь, что reinterpret-cast'ить нельзя
сами типы, можно только указатели из ссылки. Тут есть некоторое вот такое концептуальное тоже
концептуальный момент. Когда вы пишете static-cast, вы делаете его к дабл, а если вы хотите сделать
reinterpret-cast, вот, допустим, у меня int, я хочу его как дабл прочитать. Как будто там... Ну,
давайте float, чтобы размер совпадал. Я пишу float-ampersand, просто к float не скомпилируется.
Почему я имею... Почему я пишу ampersand? Потому что я как бы говорю, не создавай новый float. А вот
считай, что вот это и есть float. Ты как бы теперь к нему обращаешься, как будто он float. Ты не
создаешь новый. Но это примерно, как я говорил, const int ampersand там y равно x. То есть, обращайся,
пожалуйста, теперь к этому x, как будто он const int. То есть, через это имя я обращаюсь к тому же
самому, но считаю его другим типом. Значит, если ты приравняешь это к y, ну, будет убе формально,
а в реальности будет следующее. Вот я говорю float ampersand y равно вот это. Именно float ampersand y.
Потому что если я говорю float y, это скомпилируется, но копия создастся в итоге все равно. То есть,
я говорю reinterpret cast как float x из битов x. Вот он записан как int в двоичной системе. Создастся
float вот с такими же битами. То есть, это будет какой-то странный float. То есть, вот прочитали
его как float. Вот как float кодируется по битам. Вот так он и прочитается. Вот, если так написано,
то y и x будут независимо существовать. Но если вот так написано, то когда ты x поделишь на 2,
float тоже как-то изменится. Но как именно изменится, это трудно предсказать. Потому что,
ну, биты просто будут, ну, там, деление на 2 в nt это будет по битовый сдвиг, а во float,
ну, у тебя там мантиса съедет на экспоненту. Ну, то есть, те же самые биты он будет читать,
как будто это float. Понятно? Соответственно, ты можешь y поделить на 2 и посмотреть, как x изменится.
Ну, он выполнит деление в исчезных числах, закодирует этот float обратно, как если бы он делел
на nt на 2. И int при этом прочитается как-то иначе. Нет, не всегда. Ну, reinterpret cast. На самом
деле, reinterpret cast у b почти всегда за редким списком случаев, которые, я не помню, ну,
можно на cpp-референс прочитать. Но это действительно иногда нужно, когда у вас есть какие-то структуры,
ну, у вас есть какие-то структуры данных там, с какими-то полями вида там. Ну, допустим,
у вас есть структура, ну, именно struct, и в ней много int в подряд лежит. И вам нужны эти int там,
ну, например, вам, например, да, хочется, чтобы вы считали эту структуру. Ну,
ну, в случае с практики, например, бывает такое, у вас есть какие-нибудь id-шники,
они хранятся там, определенная структура, там юзер какой-нибудь, да, у него есть id-шник
такой, id-шник сикой. И вам надо эту структуру интерпретировать как структуру другой вид
id-шника, но вы знаете, что там ровно те же числа в таком же порядке лежат. Чтоб вам стать и кастом
копию всех этих чисел не создавать, вы можете сказать, считай просто, что это такой, ну, другие
виды id-шников, но они просто лежат в таком же порядке, в таком же размере, и вы точно знаете,
что они так и лежат. То есть вам, вы reinterpret cast экономите операции просто, тем самым,
вы читаете биты как другие типы. Да, он будет читать этот и следующий за ним 4 байта. То есть,
если вы reinterpret cast эти типы, у которых не совпадают размеры, ну, удачи вам, как говорится,
просто вы будете читать следующие биты, он будет, да. Конечно, можно. У B, что вы хотите?
Статические ссылки, что такое статические ссылки? Константный ты имел в виду? Можем,
сейчас расскажу как. Статик каст — это вообще не то же самое, что reinterpret. Статик каст — это
создать из одного типа другой тип. Нет, нельзя. Нельзя статик кастом сказать, прочитай биты одного
числа как другой тип. Можно ли только создать одно число из другого по некоторым правилам
создания. Double вот умеет создаваться из МТА. Потому что я не создаю новый флоат. Я считаю,
что вот те биты, которые там написаны, это и есть флоат. reinterpret каст не умеет создавать
новые сущности. Он умеет только смотреть на существующие сущности, как будто они другой
тип. Вот поэтому ссылка. Вот это выражение оно LVL на самом деле, опять-таки. Вот ему присваивать
можно. Потому что ссылка, она как бы говорит, смотри на то, что у тебя уже есть, как будто это
тип другой. Да. Да, по-моему. А может и нет. Я не помню. По-моему, там есть оговорки, по которым
это не undefined behavior. Да. Никак не работает. Игнорирует их. Ну как, если у вас одинаковый,
если вы знаете, что типы одинаковые по внутренней структуре, и вам надо просто один трактовать как
другой, вы можете reinterpret кастнуть. Еще раз. Я не понимаю, о чем вы хотите спросить. Еще раз.
У вас есть два типа, и вы просто читаете биты одного как биты другого. Если вы знаете,
что биты одного в точности лежат так же, как биты другого, там ровно те же числа, ровно в том
же порядке, ровно с теми же промежутками, то вы можете reinterpret кастнуть. То все сбилось бы,
и вы бы читали числа не по тем битам. Да. Вот. Можно reinterpret кастить указателя. Можно reinterpret
кастить от одного указателя к другому указателю. То есть я могу, например, сказать float звездочка
y равно, ну я могу вот так еще делать. То есть я могу по плюсовому, скажем так, ссылку, ну прям в лоб,
а могу вот указатель на одно считать указателем на другое. Потом, когда разами новую, ну будет,
по сути, то же самое. Вот. Короче, reinterpret каст — это первое запрещенное заклинание языка C++.
Оно, возможно, вам будет иногда нужно, но я не рекомендую. Ну, в общем, используется осторожностью,
только в экстренных ситуациях. Нет, ну на нашем курсе нет. Я не знаю, с Филиппом будете вы или нет
писать это нам. Так, это первое. Теперь второе запрещенное заклинание, которое хуже, чем reinterpret
каст, я считаю. reinterpret каст, я вам сказал, умеет кастить любой тип к любому с некоторыми
оговорками. На самом деле, по сути, с одной единственной оговоркой — он конст снимать не умеет.
Ну, быстрее, быстрее. Я не понимаю, давай ты в перерыв подойдешь, сейчас я хочу закончить
быстро, устроить перерыв, и надо уже дальше двигаться. Сейчас я расскажу про два оставшихся каста,
и мы закончим. const каст. reinterpret каст все умеет, кроме одного, он const не может снять и навесить
не может. Если у вас была ссылка на int, если у вас была ссылка на константный int, то reinterpret
кастом вы не сможете сделать из нее ссылку на обычный int. Навесить? Навесить, кстати, навесить
может и может, ладно, снять не может. То есть, если у вас была ссылка на, если у вас был int,
если у вас был константный int, то вы reinterpret кастом не можете его скастить к неконстантному,
да неважно к чему. Вот к чему бы вы не кастили, только к константному сможете. reinterpret
каст не умеет снимать конст, а const каст умеет. Вот если вам нужно снять конст вероломно, то есть,
у вас есть переменная, у которой тип константное что-то, а вы хотите сказать, мне наплевать,
что она константная, я все равно хочу выполнить над ней операции изменения. Тогда у вас есть const
каст. Это второе по ужасности запрещен заклять, да. С++ неисчерпаемо богато, он позволяет тебе
иногда делать, с++ он позволяет тебе, он у тебя есть как бы экстренные, для экстренных ситуаций
нужны экстренные меры. const каст очень плохо, но это нужно для экстренных ситуаций, для экстренных
ситуаций экстренные меры. У нас в курсе будет как минимум одна ситуация, когда нужно const каст
использовать во втором семестре. Когда вы до нее доживете, вы поймете, что иногда это полезно.
Иногда это очень сильно в разы упрощает код, вам не приходится дублировать много строк благодаря
этому. Вот const каст уб, за исключением ситуации, когда у вас изначально это действительно было не
const. Какое корректное использование const каста? Вот у вас был int, смотрите, вот у вас был int,
потом вы сделали const int % ссылку на него, и вы хотите теперь сделать опять неконстантную ссылку
на то же самое, имея y. Вот вы допустим y приняли функцию по константной ссылке, но вы из каких-то
соображений знаете, что изначально он вообще-то был неконстантным, вам просто дали его как константу.
Тогда const каст легален, вы можете сказать const каст к int % const каст, как и reinterpret,
он только к указательным и к ссылкам может. И все, что он умеет, это добавлять и снимать const.
const каст к int % от y, там равно единице. Вот это нормально, это lvalue, разумеется, это ссылка. Вот.
Вот это корректное использование const каста. И x, конечно, изменится, да. Вот. Но если x изначально
действительно был константный, то это UB. Я не знаю, что ты хочешь сказать про const итератор.
Давай не, пожалуйста, давай в перерыве, очень-очень-очень напаздываю. const каст умеет только снимать
и добавлять const. Если вам надо из константного intа получить неконстантный даббл, то вам нужно
сделать сначала reinterpret к const int, а потом const каст к обычному int. Так. Нет, это все lvalue,
к ссылке и к указателю, к указателю lvalue. Они не создают новые объекты, они смотрят на старые
объекты через другой тип. И последнее. Sistyle каст. Это одно из самого плохого, что вы вообще
можете написать. Значит, что на самом деле такое Sistyle каст? Sistyle каст запрещен код стайлом. Вот
конст каст иногда бывает нужен. И иногда он вам один раз даже в курсе понадобится. Reinterpret
каст тоже вам может быть пару раз понадобится. Но Sistyle каст мы будем банить жестко. Как работает
Sistyle каст? Работает он так. Сначала он пробует, нельзя ли обойтись одним конст кастом. Нельзя
ли обойтись навешиванием или сбрашиванием константы. Если нельзя, то он пытается сделать static
каст. Если нельзя, то он пытается сделать static каст, а поверх него const каст. Если нельзя, то он
пытается сделать reinterpret каст. А если это нельзя, то он пытается сделать reinterpret каст, а поверх
него const каст. И только если ничего из этого нельзя, CE. Когда вы на самом деле пишете вот в таких
круглых скобочках приведения типа, вы сами того не подозревая, проходите все вот эти стадии
принятия, значит, последовательно. Нет, reinterpret от static, но это бессмысленно. В смысле const
reinterpret от static это бессмысленная конструкция. Ты сначала пытаешься static, потом static,
потом const, а потом static. Если это не получилось, значит, нормального способа привести нет,
значит, ты только reinterpret можешь пытаться сделать. Тогда reinterpret, потом const. И все. И самое
плохое, что вы не знаете, какой из этих кастов реально сработает. Когда вы пишете c style каст,
вы можете забыть константу, навесить лишний амперсант, навесить лишнюю звездочку. Это все
вам будет прощено, потому что он просто будет перебирать подряд касты, какой-нибудь да получится.
Таким образом, вы можете словить уб совершенно этого не заметив. Поэтому c style каст c++ в код
стайле запрещен и использовать ее рекомендуется только в низкоуровневом коде, когда вам почему-то
нужно писать на c, а не на c++. Но в нашем случае c style каст будет запрещен в коде. Вот это все,
что я хотел рассказать вам о приведениях типов. И мы закончили главу вторую, и давайте сделаем
перерыв. Мы до сих пор разговаривали о том, что есть какие-то переменные, есть какие-то типы,
можно что-то создавать, можно объявлять переменные, и можно с этими переменными
что-то делать в зависимости от того, какого они типа. Вот, но сейчас мы начнем говорить о том,
как свои собственные типы объявлять и определять. Вот, и два наиболее распространенных способа
объявить свой собственный тип c++ это объявить структуру либо объявить класс. Да, можно еще объявить
enum, можно еще объявить union, но про них мы попозже поговорим. Вот, но мы сейчас будем говорить про
структуру и классы, и в рамках этого пункта, а именно в рамках пункта 3.1, я буду считать,
что структура и класса это полные синонимы. На самом деле это почти правда. Структура и класс
c++ это почти одно и то же, с очень-очень маленькой разницей, о которой я скажу вскоре, но пока я буду
считать, что это совсем одно и то же. И я буду писать структуру вместо класс. Вот, как это...
Ну что ж такое, слушайте, ну все-то вам не так. Ну как же, ну потерпите.
Вот, я пишу структуру, объявляю имя структуры. Стракт я пишу. Это структура.
Так, я не помню, что у меня там... Сейчас. Блин, ну мне нужно из полноэкранного режима выходить,
типа, да. Сейчас, ну е-мое, ну что ж такое. Ну хорошо, давайте вот так сделаем, ладно. Если так, лучше.
Так, все. Я объявил структуру. Тихо, пожалуйста. Я объявил структуру, назвал ее s. В принципе,
на этом можно и закончить. Вот, но я могу структуру определить. Для структур, как и для функций,
я могу писать отдельное объявление, отдельное определение. Вот, после определения, кстати,
нужно точку запятой ставить. Такое довольно странное правило, после определения функций точку
запятой ставить нельзя, после определения структуры нужно. Вот, ну что из себя представляет структура?
Ну, обычно в структуре какие-то данные лежат. Вот эти данные называются полями структуры.
Введение в ООП. Introduction to OOP. Ну, я могу внутри структуры объявить какие-то поля,
то есть данные, которые в этой структуре храниться будут. Ну, давайте там, не знаю,
int x, double y, char c. Вот, вот это поля. Соответственно, я могу теперь в мейне создавать переменные
такого типа, как эта структура. И, ну, по умолчанию поля будут проницилизированы каким-то мусором,
как и в случае с локальными переменными. Вот, но я могу чем-то их проницилизировать по умолчанию.
Например, могу сказать int x равно 1, double y равно там 3 и 14, char c равно a. Вот, тогда,
когда я создаю структуру по умолчанию, эти поля будут проницилизированы вот чем там написано.
Вот, а я могу сделать и так. Я могу сказать при создании структуры явно, чем проницилизировать
поля. Это делается следующим образом. Я открываю фигурные скобочки и говорю,
например, вот так вот. Я перечислил значения полей в том порядке, в котором они были объявлены
в структуре. Таким образом, я проницилизировал структуру своими значениями. Если бы я не написал
чем, то они бы проницилизировались по умолчанию. Если там не написано чем,
то они бы мусором проницилизировались. Вот, я могу не все, кстати, так указать. Я могу сказать только
вот так. Тогда остальные проницилизируются по умолчанию. Вот это вот называется агрегатная
инициализация. Когда я инициализирую фигурными скобочками, перечисляя поля по порядку. Вот в
каком порядке поля объявлены, в таком они и будут применяться. Если там типы не соответствуют,
то будет CE. Либо преобразование типов, либо CE. Вот, как обращаться к полям структуры. Для
этого существует оператор точка. Я могу вывести поля этой структуры. Я могу сказать s.x, s.y, s.c.
s.c. Вот сейчас я поля этой структуры увижу, как они есть. Первое поле проницилизировалось
двойкой, а остальные проницилизировались, чем было написано по умолчанию. Вот, это оператор
точка. Если я имею дело с указателем на структуру, то я могу использовать оператор
стрелочка для доступа к полям. Давайте, допустим, скажем, что у меня есть... Ой. Допустим,
я... Что ж такое? Что я сделал? Извините. Так. Да, мастер ВИМА. Ну, я могу вот так сделать.
Вот. То есть, я скажу, что... Давайте, скажем, я структуру в динамической памяти создал. А,
да. Ну, s. p.s. Тогда мне нужно будет в конце обязательно писать delete p.s. А тут я... p.s
теперь это у меня указатель. Вот если я имею дело с указателем на структуру, то чтобы мне по
указателю на структуру обращаться к полям... Ну, я мог бы, конечно, писать вот так. Да,
то есть, в скобочках звездочка p.s, а потом точка x. То есть, если я напишу без скобочек,
точка приоритетнее, чем звездочка, поэтому оно будет неправильно работать. Вот. Ну,
чтобы мне не приходилось писать вот так, в c++ придуман оператор стрелочка. Это вот так пишется.
Значит, оператор стрелочка — это как бы разыменование и сразу обращение к полю.
Вот. Ну, сейчас будет то же самое, что и раньше. Вот. Кроме полей, я могу в структуре объявлять
еще методы. Методы — это функции. Ну, по сути, это операции, которые можно производить над
структурой. Я могу объявить, ну, какой-нибудь метод f. Вот. Функции, которые объявлены в структуре,
называются методами структуры. Я могу объявить какой-нибудь метод f, который, ну, собственно,
и выводит, допустим, эти поля. Вот. Когда я нахожусь в методе, мне не нужно писать там. То есть,
когда я нахожусь в методе, подразумевается, что поля у меня уже есть. То есть, я реализовываю
операцию над некоторым существующим объектом своей структуры. То есть, я просто здесь пишу вот так.
Да. И вот здесь я напишу, давайте я это удалю. Я напишу s, s там от 2. И дальше я пишу s.f. Я вызываю
метод f у структуры s. Этот метод, в свою очередь, у данного экземпляра структуры выполняет вот это.
Но в данном экземпляре структуры понятно, что x, y, z означают те вот значения, которые там лежат в
этом экземпляре. Вот. Экземпляры структуры называются объектами. То есть, s – это объект,
а это метод объекта. Но я, понятное дело, могу в f передать какие-нибудь параметры. Я могу из f
что-нибудь вернуть. Вот. Ну, то есть, обычная функция просто у нее есть еще дополнительные
переменные. Это поля этой структуры. Вот. Дальше вот такую ситуацию разберем. Вот я, допустим,
захотел сделать функцию от какого-нибудь числа. Я передал параметр сюда. Тогда вот этот x,
он будет означать какой x? Параметр. Как мне обратиться к полю, если у меня x затмевает
название этого поля? Есть ключевое слово vis. Есть ключевое слово vis, которое позволяет явно
обратиться к указателю на данный объект из тела объекта. То есть, я сейчас нахожусь в методе
объекта, то есть в теле объекта. Я хочу получить указатель на данный объект из тела. Для этого
я пишу vis. Vis – это указатель на данный объект. Соответственно, получить поле x данного объекта
я могу вот так. Да. Функции, если я объявляю методы в структуре, то неважно в каком порядке
их объявляю. В рамках тела структуры, неважно в каком порядке объявлены методы. Они видят
все друг друга. Вообще, эта область видимости фигурными скобками ограничена. Она называется
classScope. В ней можно тоже делать только объявления. Я не могу здесь писать expression,
я не могу здесь писать control statement. Вот здесь я могу писать только объявления. Либо полей,
либо методов, либо внутренних типов. Я могу здесь написать using vi равно vector int. Это будет
означать, что локально в рамках этой структуры vi означает vector int. Я могу делать, конечно же,
перегрузку методов. Я могу сделать f без параметров, а могу сделать f от int. Это будут два разных метода,
называющиеся одинаково, с разной сигнатурой. Это я объявил структуры, рассказал про слово vis
и про поля и методы. Я могу метод объявить внутри структуры и определить вне. Например,
я этот метод объявил здесь, а определить захотел из вне. Как мне это сделать? Понятно как,
так же как с namespace. Я просто говорю, что я теперь этот метод, пишу void s 2.2 f и определяю. Ну и
разумеется, здесь отсюда мне будут видны поля моей структуры и я могу запросто обратиться к ним.
То есть тот факт, что я вне структуры определяю метод, никак не мешает мне видеть все поля и
обращаться к ним с полным правым доступом. Дальше. Я могу внутри структур объявлять другие структуры.
Тогда они называются inner classes, внутренние классы. Я использую слова классы и структуры как синонима.
Внутренние классы. То есть я могу внутри s объявить еще структуру, стракт ss. И она будет хранить в себе,
не знаю, что-нибудь простое, float, f. Вот. И могу например объявить поле такого типа. Вот.
Соответственно из вне я тоже могу видеть эту структуру. То есть я могу захотеть объявить из
мэйна объект типа ss, но для этого мне нужно указать откуда он. То есть я вот так вот буду вынужден это писать.
Все? Нет, подожди, что значит поля из…
Так, минуточку. Ss это тип. Я не понимаю вопрос. Что ты хочешь написать? После структа завести
новую переменную. Где? В мэйне? Вот здесь. Завести переменную. Что такое b? А, ну и что? А что такое d?
D откуда? Из какого объекта? Из какого объекта она взята? S это тип, а не объект.
Ну вопрос бессмысленный, потому что поля имеет смысл брать только у существующего объекта. Да.
Нет, нет, нет, нет. Я не буду сейчас… В перерыве. Вопрос забанен. Про статические поля потом.
Можем инициализировать поля не константно? Можно инициализировать переменную. Ну да,
я могу написать double y равно x, например. Но я могу и экспрешным каким-то инициализировать, да,
результатом функции. Вы это сделаете, если у вас… Если циклические зависимости. Поля инициализируются в
порядке объявления. Сначала x, потом y, потом c, потом d. Нет, я имел в виду, вы же это инициализируете,
у вас не создается инициализация структуры. Не, не, не. Когда я пишу здесь инициализацию,
это означает следующее, что если экземпляр будет создан по умолчанию, то эти поля должны
быть инициализированы этим. Когда я здесь инициализирую чем-то поля, то я указываю
инициализаторы по умолчанию. Это значит, что в момент, когда будет создаться структура,
они инициализируются этим. Это не значит, что я объявляю перемену такого типа, они прямо сразу…
Пока я не создал s объект, я ничего не инициализировал нигде. Внутри чего? Что такое double s? Где? Вот здесь?
Что написать? Что такое y? Y откуда? Y бывает у объекта. Нету никакого объекта.
Y это поле объекта. У какого объекта ты берешь поле? Нет, ss это другой тип. Хоть он и внутри s
находится, это другой тип, никак не связанный с s. Он просто виден только изнутри s.
Да, конечно, вот я это и сделал в мейне. Я создал ss и назвал его ss маленькое. Это никак
не связанный с s тип. Просто его область видимости ограничена типом s. Можно? Конечно. Я внутри ss.
В смысле, где? Вот тут? Не понял, где? Вот здесь.
Здесь, что ли? Здесь? Вот так? После скобочки? Вот так? Так можно делать, потому что вы можете
тем самым... Я объявил структуру и сразу же создал переменную такого типа. Да, так можно.
Зачем? Это будет поле, да? Это будет поле s, да. Какое поле? Кольцо, блин. Это поле без объявленного
Математик детектат просто. Это будет поле... В смысле, без объявлённого? Это поле типа ss.
Тип ss только что определён. В чём проблема? Это переменная ss, которая имеет тип ss, да?
Это переменная ss маленькая, которая имеет тип ss большой, да. Это переменная ss маленькая с типом ss большой?
Да. Я объявил тип и сразу же переменную такого типа. Это будет поле класса s. Что? Это поле s,
полноценное поле s. Я могу сказать s.ss. Так, по одному. Что ты хотел сказать? Ещё или всё? Всё.
Чё там кто хотел сказать? Никто. Ты давай теперь.
Мы можем вот это ss маленькое по агрегатно-баннистерской? Да. Да. Агрегатно, я думаю, да. Ну, давайте попробуем.
Ну, по идее должно быть можно. Я не уверен, да, можно. Но агрегатная инициализация для полей, да,
почему бы и нет. Можем создавать объекты класса ss вне? Конечно, можем. Объекты класса ss вне? Да,
можем. Я же в мейне сделал это. Вот я сделал. Флот d равно… Что такое y? Это поле… Где? В каком объекте?
У нас есть структура s. У нас есть структура s и вот это… Когда ты объявляешь, у тебя нет ни одного
объекта s. Откуда ты берёшь y? Ну, вот вам будет ошибка компиляции сейчас.
Ну, типа нельзя обращаться к полю, не имея объекта соответствующего типа.
Просто в джаве вложенные ссылки, это имеют типа ссылку на хозяина и что-то такое,
поэтому можно к ним обращаться. Нет-нет-нет-нет, подожди-подожди. Одно дело ссылка на родителя,
другое дело внутренний класс внутри внешнего класса. Ты, наверное, имеешь в виду ссылка на
типа parent, ну как это супер? На родителя. Нет, на хозяина, типа внутри которого и поэтому он как-бы
может обращаться. Что такое хозяин? Здесь нет ни одного объекта. Так, какая разница? Это хоть
джава, хоть плюсы есть? Я бил класс внутри класса, а объект откуда взялся? В общем, если… Так,
ладно, нет, это долго. А ты что хотел сказать? Что понадобится? Ну, внутри какого-то… Ты пишешь
очень большой класс. Тебе нужен какой-то тип только в рамках определения своего внешнего типа.
Вполне себе нормальная ситуация. Ты реализуешь вектор. Внутри вектора нужно написать итератор.
Вектор int 2.2. итератор – это внутренний тип в векторе. Да, вот внутри вектора есть такая внутренняя
структура, итератор. Вот вам пример. Что? Функции внутри функции нельзя. А ты что хотел сказать?
Да, кстати, спасибо. Начиная с и плюс-плюс-двадцать, есть так называемый design initializers. Сейчас я
покажу, что это такое. Я могу писать так. s.x равно 2.y равно… Это не параметры функции, это
инициализаторы. Но это начинает с и плюс-плюс-двадцать. Можно и не по порядку. Да, в этом и смысл. Так,
тут правда у меня сейчас будет непоняточка. Да, это design initializers. Почему-то он меня компилирует
по умолчанию с и плюс-плюс. Странно. Ну, значит он поддерживает уже без всяких дополнительных
флагов. Вот, да, можно и так. Так, окей, ладно, идем дальше. Еще можно объявлять структуры
внутри функций. Вот функции внутри функций нельзя. Но структуры внутри структур можно,
и структуры внутри функций можно. Внутри функций я могу объявить структуру. Структуры внутри
функций можно объявлять. Внутри функций нельзя объявлять функции? Внутри функций объявлять можно,
определять нельзя. А структуру я могу объявить и определить внутри функции. Но я могу назвать,
ну давайте как-нибудь по-другому назовем. По-другому назовем. Значит, другая структура. Вот, и я могу
соответственно объявлять переменные такого типа. Вот. Интереснее, что я могу возвращать их наружу.
То есть представим, что это не f, а какая-нибудь там другая функция, там g. Да, это не main. А main будет
другой. И вот в main, допустим, я хочу... Ну, смотрите, я написал. Сейчас, минуточку. Так у меня не
получится, так у меня не получится, потому что она еще не объявлена. Да, у меня не получится так
сделать, к сожалению. Ну, я могу... Да, да, так не получится сделать. Но я могу авто написать,
конечно, но про авто я еще не хочу говорить. В общем, я теоретически мог бы этот тип вернуть
наружу из функции и внешней функции его использовать, хотя его объявление было в другой функции. Ну так,
просто тип создается и назвать его извне я не могу. Название, видимо, только из функции. Но сам тип
можно... Что? Нет, про авто забудьте. Все, забудьте про авто, я ничего не говорил про авто.
Значит, просто можно объявлять типы внутри функции. Ну, проблема... Да, сможете. Но проблема в том,
что вам возвращаемый тип никак не назвать, потому что он еще не объявлен, а слово авто мы пока не
знаем. Да, но вы никак не скастуете его к тому типу, которому надо, потому что назвать тот тип вы
не можете извне и вам никакой каст не поможет. Так, хорошо. Значит, вот эти вот эти классы,
которые внутри классов, называются inner classes, внутренние классы, а это называется local
classes, локальные классы или структуры, если они внутри функции. Вот. Ну и еще моментик. Как вы думаете,
какой будет sizeof от этой структуры, вот которой мне сейчас написано? 24. Вот у этой структуры размер
24. Почему 24? Казалось бы, размер nt4, размер w8, размер char1 и размер ss еще 4. Ну, я даже могу
закомментировать это. Нет, таблица функции, это вы что-то намудрили. А, блин. Ну, короче, да, вот я
закомментировал, у меня нет ss теперь. Сейчас еще где-нибудь что-нибудь не скомпилируется. Нет,
все равно 24. Почему размер этой структуры 24? В ней int, double и char лежат. Смотрите фокус. Если я
сейчас вот этот char перемещу сюда. Так, нет. То размер внезапно изменится и станет 16. От того,
в каком порядке я перечисляю поля, зависит размер структуры. Да, потому что переменную типа double
можно класть только по адресу кратному 8, а поля кладутся подряд. Вот в отношении полей компилятор
не имеет права их класть в веном переупорядочивать. Поэтому компилятор сначала кладет int, потом
char, потом double. Но int он кладет на адрес кратный 4, char на следующий за ним ближайший байт, а дальше он
3 байта вынужден пропустить, чтобы double положить на адрес кратный 8. Но если я
char возвращаю сюда, почему размер становится 24? Да, казалось бы я положил int, пропустил 4 байта,
положил double, пропустил, ничего не пропустил, положил сразу char и дальше зачем-то еще 7 байт
зарезервировано. Вот, дело в том, что память округляется до наибольшего поля, потому что
мы исходим из того, что следующую s мы должны уметь положить в притык к предыдущим. То есть
если я заведу массив нескольких s, то мне надо, чтобы они подряд лежали в памяти в притык. А
если я бы не дополнил до 8 байта, то получалось бы, что у следующей s все бы поехало, там уже они
лежали бы не на кратных 4 адресах. Поэтому он дополняет до 8 байт, чтобы следующий экземпляр s,
если это будет массив, лежал вот как надо ровно. Что комплиатор? Что не оптимизирует? В смысле,
почему он не... это и есть оптимизация, что он дополняет до 8. Почему он не меняет местами так,
чтобы всегда было 16? Потому что в случае структур, потому что во многих местах используется тот факт,
что поля лежат подряд. В сишном коде это часто используемый факт, это как раз в частности
вот используется, когда вы хотите реинтерпреткаснуть одну структуру к другой. Вы, когда пишете код со
структурами, вы часто опираетесь на то, что поля подряд лежат. Это вот базовое правило,
которое как бы не нарушается. Кстати, а что если бы я завел структуру, а единственным полем в ней
была бы ссылка? Ну, на Инт. А глобальным Интом? Бьют, но для учебных целей можно. На самом деле
мне сейчас не важно, чем она проинциализирована, потому что я объект не создаю. Какой будет размер
этой структуры? Да, если я такую структуру создам, то размер будет 8, потому что по факту там
хранится указатель на Инт, конечно. Потому что если я ссылку храню как поле структуры, то что
остается делать? Только указатель хранить. Это компилируется. Ссылка не инициализирована,
но я не создаю объекта. Я просто объявил поле. Я сказал, вот структура есть такое поле, но я же
не создал экземпляр. Это просто поле. Я не создал, в смысле, люди с ссылки. Вот если я напишу вот так,
то все это СЕ, потому что ссылка ничем не проинциализирована. Но пока я не создал объекта,
я не пытаюсь реально положить. Вот сейчас нельзя. Так, окей. Ладно, идем дальше. Давайте следующий файл откроем.
Давайте я назову его так. Следующий параграф будет называться инкапсуляция и модификаторы
доступа. Да, давай вопрос. Сайзов… чем ты ее проинциализируешь? Сайзов ссылки – это то же самое,
что сайзов… нельзя спросить сайзов ссылки. Все, что ты спрашиваешь про ссылку, ты спрашиваешь
происходный объект. Понятно? Ну если б я спросил… если я спросил сайзов хаха, то я узнал,
сколько занимает структура в памяти. Но она занимает восемь, потому что там по факту указатель
хранится. Но если б я спросил сайзов ее поля, я бы получил сайзов инта.
Ну в каком смысле отличили? Я узнал, сколько занимает структура. Но если я задам тот же самый
вопрос про ее поле, то мне как будто это инт будет. Это понятно. Ну да. Да, это правда. У одной 4,
у другой 8 будет. Потому что ссылку мы храним как указатель, иначе не получается. Так,
инкапсуляция, модификаторы доступа. Да. Чего-чего-чего? Да. Где сделать?
Нет, нет, нет. Ссылку нельзя перепривязать, понимаешь? Нет смысла делать заглушку под ссылку,
ее нельзя проницилизировать заново будет. Поэтому и нет. То же самое, кстати, с константами.
Константы тоже надо идентифицировать при создании, потому что переприсвоить им ничего нельзя потом.
Так, инкапсуляция. Существует три так называемых принципа ВВП основных,
называются инкапсуляция, наследование и полиморфизм. Вы наверняка о них слышали. Мы их подряд будем
разбирать и начнем с инкапсуляции. Что такое инкапсуляция? Ну, трудно сказать. Кажется,
что сообщество так и не пришло к единому мнению, что это значит. Вот, но почему у меня Bluetooth
включен? Ну, короче, если вы откройте Википедию, там есть два разных объяснения, как можно считать,
что в разных языках программирования. По-разному это определяется. Кто-то говорит, что инкапсуляция
это просто хранение данных и методов работы с ними в одном месте. А кто-то говорит, что инкапсуляция
включает в себя еще и сокрытие, то есть разгонячение доступа к данным методам. Ну, классический
пример со стиральной машинкой. У вас есть стиральная машинка, а в ней несколько кнопок. У
стиральной машинки есть какие-то внутренности, но вы не понимаете, как они работают. Все, что вы
можете делать с стиральной машинкой, нажимать на кнопки и выполнять какие-то предопределенные
операции. Стиральная машинка будет со своими внутренностями. Что? Да, кстати, это вполне
вероятно. Да, это, наверное, правда. Да, инкапсуляция, потому что мы в капсулу вкладываем. Да,
это правда. Это хорошее замечание. Ну вот, у вас есть типа машинка стиральная, и вы умеете только
на кнопки нажимать, а как она внутри реализована вы не знаете. У стиральной машинки есть какие-то
свои внутренние данные, но все, что она вам предоставляет наружу, это интерфейс взаимодействия
с ней. Ну вот, примерно такая идея. Это одна из главных идей ООП, что у вас есть какие-то данные и
есть какие-то методы работы с ними, но наружу вы предоставляете только методы. И вы еще занимаетесь
разграничением доступа. То есть вы говорите, что некоторые методы или поля из вне недоступны должны
быть, а пользоваться внешние юзеры могут только какими-то определенными. Вот для этого существуют
так называемые модификаторы доступа. Это такие специальные слова private и public. Ну protected,
да, но пока мы про них не говорим. Вот, допустим, у меня есть опять-таки какое-то поле, ну и другое
поле. Я могу сказать, что вот это поле приватное. Значит, что я пишу? Я пишу слово private. Тут у меня
автоматический отступ ставится, но обычно слово private по кодстайлу пишется либо на одном уровне
со словом struct, либо на половинчатом отступе. Вот. Ну, я буду писать на одном уровне. Вот, но
по Google кодстайлу вы на половинчатом отступе пишете. И, кстати, это еще одно объяснение,
почему табы не надо использовать. Google кодстайл это же один пробел, то есть private на одном пробеле? Да.
А вот так можно писать, да? Как? На одном пробеле. Да. Ну, если у вас отступ два пробела, то private
вы пишете на одном пробеле. А если отступ один пробел? Вот, а это давайте я напишу public. Если отступ один
пробел, то, значит, не повезло. Ну, пишите с нулевым отступом. Вот. Так, так, так, тихо. Значит, вот,
смотрите, я написал private, и теперь вот это поле у меня недоступное извне, а public это значит
доступное извне. Слова private и public в плюсах, в отличие от java там и c-sharp, они пишутся один раз,
после них ставятся двоеточие, и дальше вот все, что после слова private написано, считается private.
Значит, я могу слова private и public писать сколько угодно раз, в каком угодно порядке. Ну, то есть я
могу написать private, двоеточие, и дальше что-то наобъявлять, потом написать public, что-то наобъявлять,
потом слово private, что-то наобъявлять. То есть слово private распространяется на все, что ниже него,
вплоть до следующего модификатора доступа. Что по кодстайлу сначала вы должны писать? Я...
Сейчас скажу. Значит, что правильно писать в начале, что в конце, это тоже спорный философский
вопрос. Разные кодстайлы советуют по-разному. Кто-то считает, что нужно сначала писать public,
чтобы люди сначала видели, что ваш класс предоставляет, какие методы, а только потом,
как он устроен. Кто-то наоборот предпочитает сначала писать private, чтобы сначала было видно,
что вы храните, а потом, что вы умеете делать. Я никакой из этих способов строго не предпочитаю.
В кодстайле у нас не будет запрета писать не так, не так, не знаю. Как удобнее в каждом конкретном
случае, сами решайте. Вот. Ну или там на review будем обсуждать. А если вы не написали ни private,
ни public, то какой модификатор доступа применяется по умолчанию? И вот тут ответ на вопрос,
почему я пишу struct вместо class. Дело в том, что класс от структуры как раз с темой отличается,
что у класса все по умолчанию private, а у структуры public. И это единственная чем
он отличается от структуры C++. Вот. Значит, если бы я написал просто class, а не struct,
то у меня бы все не компилировалось со словами все private, доступ запрещен. Вот. Но поскольку
я пишу структуру, то там все по умолчанию public. Вот. Я отныне буду писать class вместо
struct, если буду что-то нетривиальное делать, но буду уточнять public. Вот. Ну такое соглашение,
что если вы хотите писать какие-то простые вещи, ну то есть вы не хотите писать, реализовать какую-то
сложную логику, то используйте слово struct. Если у вас там методы, ну если вы действительно там в
основном поля хотите напрямую к ним обращаться извне, а если у вас со сложной логикой какой-то
тип, который там сложные методы, который хочет инкапсулировать приватные какие-то поля, то лучше
пишите class. Ну такое вот общее соглашение, когда class писать, когда struct, в основном разницы нет.
Ну вот. Если я сейчас попытаюсь из main обратиться к polux, то будет ошибка компиляции со словами
нарушения прав доступа. И с private within this context. И это другая ошибка компиляции,
принципиальная другая по сравнению с тем, что мы встречали раньше, потому что это ошибка уже не
уровня, не видно имя или неоднозначный вызов, а уровня все видно, все понятно, что вы просите, но вам запрещено.
Вот. Ну я могу точно также методы делать с приватными и публичными. Кстати, да.
Ну, разумеется, сколько byte в памяти занимает S? 16.
Значит, не менять, обращаться к ним нельзя. Это запрещенное слово для вас. Значит,
какую правильную интуицию нужно держать про модификаторы доступа? Что означает слово private?
Слово private означает, что из вне структуры вам запрещено произносить это слово. И больше ничего.
Нельзя говорить с.x. Нельзя. Если вы говорите с.x, бан. Compile time error. Вы называете поле, которое
не имеете права называть. Из области, из класс скопа своего, ты, конечно, можешь обращаться к
чему угодно. Если я реализую здесь какой-то метод, то я запросто могу обращаться отсюда
к приватному полю. Если я нахожусь в класс скопе, то я запросто обращаюсь к своим полям. Более того,
если я этот метод реализую извне, то я тоже запросто обращаюсь к полям. То есть даже если я
реализую, ну не буду показывать, если я определяю этот метод вне класса, я все равно имею доступ к
своим полям. Потому что это мои поля, я реализую метод класса, конечно, он имеет доступ к полям.
Из метода класса я могу обращаться к полям этого класса. Этот метод публичный сейчас,
потому что он под паблик. Где он объявлен, такой и он. Он публичный сейчас.
Потому что мне нужно, чтобы класс был выровнен, чтобы он лежал по адресу кратному 8. Чтобы дабл всегда
лежал по адресу кратному 8. Потому что процессор считывает машинными словами, если дабл будет
лежать не по адресу кратному 8, то процессору, чтобы считать этот дабл, потребуется больше
инструкций. Он бы догнал до кратного 8, потому что иначе этот дабл бы в следующем с подряд лежал
бы не в адресе кратном 8. Если после дабла я объявлю еще ind, то размер станет 24. Потому что
если я эти структуры буду хранить в массиве, мне надо, чтобы все даблы по-прежнему лежали по
адресам кратным 8. Нет, если я не догоню до 24, то следующий с не будет лежать по адресу кратному 8.
Какие у нас в целом правила по названию классов, полей классов, методов?
Ну давайте лучше я скину код style и там это будет написано. Я не хочу сейчас про это говорить,
тратить время. Давайте лучше я что-нибудь содержательное скажу. Так, вот смотрите,
у меня есть метод, он публичный. Да, если метод приватный. Давайте, кстати,
не знаю, один просто буду здесь выводить. Могу ли я приватный метод определить вне класса?
Конечно, могу. Определить метод вне класса, это пожалуйста. Обращаться к методу вне класса,
к приватному нельзя. Какая должна быть правильная интуиция? Ну я же сказал, вы просто не можете
называть как бы вслух это название. Ну за исключением ситуации, что вы его определили,
определение этого метода написать, пожалуйста, вы можете вне класса. То, что он private public,
вот обратиться к нему откуда-то вне класса нельзя. Именно назвать его по названию нельзя. При этом,
если вы каким-то хитрым способом получите указательный этот метод и через этот указатель
сумеете его вызвать, это пожалуйста. Но назвать этот метод по названию нельзя. Да. Что у вас память?
Я не понимаю, что значит в память будут переменные. Слова private и public никак не влияют на
размещение класса в памяти. Так, понятно? Никак не влияют на то, кто будет первым. Вот кого вы
первым объявили, тот и будет первым лежать в памяти. Что там private, кто public, это никак не
влияет на размещение класса в памяти. Кто раньше объявлен, это совершенно не связанные вещи.
Вот теперь следующий вопрос на понимание. Вот смотрите, у меня есть voidf от int. Вот смотрите,
у меня есть структура, и в ней есть метод от int и метод от double. Один публичный, другой
приватный. И я пишу s.f от нуля. Что будет?
Значит, в вашей версии что будет? Ce или вызов метода от double? Кто считает, что вызов метода от double?
Все вы все неправы, да. Будет ce. И это логично. Нет, это логично. Это просто так решил комитет
фантастеризации, но это логично. И если вы вдумаетесь, вы поймете, что именно так и должно быть. Иначе
было бы очень неудобно. Что означает, что вы объявили какой-то метод private? Это означает,
что вы хотите запретить людям вызывать f с такими параметрами извне класса. Если кто-то пытается
вызвать f от int, компилятор должен ему сказать, что нельзя. Смысл запрета в том, чтобы как раз не
дать человеку сделать то, что нельзя делать. Если бы этот запрет работал так, что ну хорошо,
ты случайно ошибся, ну давай мы тебя это подстрахуем, тут другой метод есть. Ты, наверное,
на его имел в виду. Нет, типа так не должно работать. Смысл слова private в том, что если кто-то
пытается извне сделать это, он должен получить ошибку. Значит, правило следующее. Сначала выбирается
подходящая версия, потом делается проверка доступа. Сначала разрешение перегрузки, потом
проверка доступа. Вот такой принцип. Проверка доступа делается после того, как стало понятно,
кто, да, если бы она делалась до, то какой уровень доступа у методов это не влияет на то,
какой метод выбирается при разрешении перегрузки. Разрешение перегрузки выполняется до того,
как компилятор проверяет, а имеете ли вы право. Сначала компилятор пытается понять,
какой это вызов, вызов какого метода вы пытаетесь сделать, потом только компилятор проверяет,
а имеете ли вы право его вызывать. Вот здесь я объясняю, потому что когда написано private,
это означает, что вы хотите запретить этот метод, чтобы вы хотите разрешить метод от double,
но запретить от int. Когда вы пишете private что-то от чего-то, вы хотите тем самым себя обезопасить,
чтобы человек извне, пытаясь вызвать с такими параметрами, получил бы ошибку. Когда вы пишете
private, это же все делается ради удобства самого себя. Вы пытаетесь…
Да, именно. Если бы он вместо этого получал вызов не той функции,
которую он уже дал, это вряд ли то, что он хотел. Он пишет f от int, а ему говорят,
ты, наверное, ошибся, потому что f от int запрещено вызывать. Ты либо не ту версию вызвал,
либо ты неправильная, логика действия у тебя неправильная. Вот. Когда… Как это все связано
с перегрузкой? В перегрузке, как вы помните, первая стадия — это выбор кандидатов, потом отбор
самого лучшего из кандидатов, но только после этого делается отсе в подоступу. Вот здесь есть
важное понятие, два важных понятия — видимость и доступность, visibility и accessibility. Видимость
функции и доступность функции — это разные понятия, их надо различать. Функция вам, может быть,
не видна, но доступна, а может быть, недоступна, но видна. Вот сейчас функция f от int мне видна,
но недоступна. Видна — это значит, что она попадает в кандидаты на перегрузку и участвует в конкурсе,
кто лучший кандидат. Но когда выбирается лучший кандидат, мне говорят нельзя, мне этого кандидата
не положено. То есть доступность — это следующая стадия после того, как решается видимость и
выбирается из видимых кандидатов. Видимость — это концепция предыдущего уровня, когда решается,
из каких namespace, какая f взята и что там нужно из них по include, вот это все видимость. Из них
выбираются кандидаты, оттуда выбирается лучший кандидат. Когда он выбран, проверяется доступность,
и это уже другой термин. Вот. Короче, сначала видимость, сначала разрешение перегрузки,
потом проверка доступа. Вот. Ну и это не были бы плюсы, если бы не существовало способа обойти.
Приватность. Что-что? Что такое offset-off? Я такого не знаю.
Так, нет, define я не хочу слышать.
Ты не можешь называть приватные поля из-вне клавиши.
Если это приводит к тому, что тебе приходится из-вне класса обратиться к приватному полю,
значит ты CE схватываешь. Назвать имя приватного поля из-вне ты не можешь.
Так, последнее, что я скажу в этом параграфе, видимо это последнее, что я скажу сегодня,
это как обойти приватность. Есть слово, как и в случае с константностью, как и в случае с
ринтерпретом, то есть существует слово такое, такая мигалка, да, с звуковым сигналом,
позволяет обойти правила, если очень хочется. Что за слово позволяет приватность обойти?
Friend. Есть такое замечательное слово friend. Значит вы можете иногда, то есть у вас поля
приватные, публичные там функции, но вы можете некоторым функциям разрешить нарушать правила
доступа. Скажем так, добавить их в список исключений. Я могу сказать, например, что вот у меня
есть здесь функция, вот допустим у меня есть функция G какая-то, и я в ней хочу вывести X.
Сейчас это будет конечно ошибка компиляции, да, ну сейчас будет две ошибки компиляции,
потому что f от int приватная и x приватная. Но я могу в классе S написать, что вот эти поля
приватные, но некоторым функциям все-таки можно, несмотря на то, что приватные, к ним обращаться.
Такие функции называются друзьями. Друзья класса – это функции, которым разрешен доступ к приватной
части, несмотря на то, что они не члены класса. Да, разрешить только к каким-то отдельным приватным
полям нельзя, можно только ко всем сразу. Вот я могу написать, причем неважно в какой именно части
класса я это напишу, хоть в паблик, хоть в private, я пишу следующее. Friend – это ключевое слово,
и дальше сигнатура функции. Friend void g. Тем самым я объявил функцию g другом для класса S. Теперь
из функции g обращаться к приватным полям можно, но из main по-прежнему нельзя. Если бы я написал
friend int main, то из main было бы можно, а из g нельзя. Конечно, я могу написать friend int main,
friend void g, я могу несколько друзей. Friend неважно где написать, главное, что внутри S. Вот,
но внутри S нужно написать friend. Далее, я могу делать друзьями целые классы, то есть я могу
для класса S объявить другом целый другой класс. Для этого я могу написать friend class ss,
например. Ну, если у меня есть еще один какой-то класс, я могу написать friend class или struct ss.
Это означает, что всем методам класса ss разрешен доступ к приватной части класса S. Вот.
Если я объявил ss другом класса S, это еще не значит, что есть теперь друг ss. Граф не
ориентированный. Ой, наоборот, ориентированный, то есть и нетранзитивный еще. То есть отношение
дружбы, оно несимметрично и нетранзитивно. Ну да. Ну это понятно, то есть явно нужно
прописывать. Если вы хотите, чтобы s был другом ss, то нужно это в классе ss прописать. Вообще,
слово friend не рекомендуется по кодстайлу использовать. И это плохой кодстайл, если у вас много где
использовано слово friend. Вот. У вас в домашних задачах, вот когда вы будете реализовывать string,
например, у вас будет искушение написать friend много где. Но это ошибка. Я вам сразу говорю,
спойлер. В задачи string friend слово не нужно использовать ни разу. Вот если вы напишите friend,
то значит вы не пройдете код review, оно там не нужно. Вот. В следующих задачах вам иногда будет
нужно слово friend, но изредка. Вот. Писать слово friend много раз, это значит, что у вас плохая
организация кода. Если вы, если вам много раз приходится писать friend, это значит,
что вы плохо спроектировали класс. Ну потому что friend это слово, как бы это обход правил,
по сути. То есть это слово на экстренный случай. Если вам нужно почему-то нарушить правила вот в
этот конкретный раз. Это как с const-cast. Типа const-cast применять нужно очень редко на случай,
если почему-то вам в экстренной ситуации надо нарушить правила. То же самое friend. Если вам
нужно нарушить правила по какой-то причине экстренной. Вот почему-то вот здесь вот тот самый случай,
когда нужно. Тогда надо переменять friend. Но вообще писать friend часто не стоит. Много друзей это плохо.
Вот. Приватные поля нужны для того, чтобы реализовывать инкапсуляцию. Ну что значит
реализовывать инкапсуляцию? Чтобы ваш код был понятен для внешнего пользователя. Чтобы в вашем коде,
в ваших классах было понятно, какая часть является внутренней реализацией, а какая часть является
методами для внешнего юзера. Почему стиральная машинка или микроволновка закрывается крышкой
обычно? Почему вы как бы не видите все механизмы, почему механизмы не торчат наружу? Ну потому что
вам считается небезопасно в них тыкать. Вы если будете тыкать в приватные методы или поля извне,
вы что-нибудь случайно сломаете. Вот. Публичной делается та логика вот с понятным действием,
которая предназначена для внешнего использования. А внутренние поля, ну например у вектора
внутренний массив, он приватный, потому что извне тыкать в него лучше не стоит. Вы что-нибудь сломаете,
нарушите внутреннюю логику какую-нибудь. Вот. Приватные поля нужны, чтобы обезопасить вас от вас самих.
Ну вот так, например. А вот я только что это сделал. Смотрите, я сейчас взял адрес S,
который был... Смотрите, я сейчас взял... Ну вот S это объект типа S. Я взял адрес S,
скастовал его к ин звездочки и разыминовал. Что я получу? Единицу. Вот сейчас я получу
единицу. Потому что я таким образом получил доступ к приватному полю. Я же объяснил вам,
что значит приватность. Это значит, что вы не имеете права к ним обращаться,
называть их вы не можете. Но компилятор, конечно, не в состоянии проверить, что вы случайно разыминовываете
указатель, под которым лежит приватное поле. Приватность и публичность — это концепция,
существующая исключительно в компайл тайме. Если я за интерпрет кастил, то, разумеется,
я спокойно могу получить доступ к приватному полю. И запросто я могу сделать вот так,
без всякого разыминования. Ну, то же самое будет. Только здесь я адреса, мне нужно само S. Я скастовал
S к ссылке на int. И тем самым получил, ну, я начал трактовать биты S, как будто там int. Но оно
действительно начинается с int. И поэтому я и получил int, с которого оно начинается. Вот.
Ну, я могу, например, сделать так. Я могу сказать double, double звездочка, адрес S,
плюс один, и это разыминовать. И таким образом я получу 3.14. Понятно? Потому что я же знаю,
что в структуре S сначала лежит int, потом 4 байта пропущено, потом лежит double. Поэтому,
если я приведу указатель на S к double звездочке, топором просто, кувал, бульдозером, ну, на самом
деле, интерпрет кастом, сестайл каст, который работает как интерпрет каст в данном случае,
я получаю указатель на S, как будто это указатель на double. Я сдвигаю его на 8 байт вправо и получаю
реально указатель на вот этот double. И разыминовый под ним действительно оказывается double. Ну и,
конечно же, если здесь было написано private, это бы ничего не спасло. Я бы тоже самое... Ну,
какая разница? Да, кстати, кстати, кстати. Смотрите. Допустим, здесь написано const double. А я сейчас вот так
сделаю? Ну, я возьму и заменю. Скомпилируется или нет? Скомпилируется, потому что константность уже
потерялась. Ну как? Да, вот эта константность сейчас ничего не спасет, потому что, и даже хоть она
приватная, это ничего не спасет, потому что я взял адрес структуры, получил неконстантный указатель
на S, трактовал указатель на double, сдвинул на 8, получил неконстантный... Ну, это УБ, конечно,
но по факту я сейчас изменю поле, там будет ноль лежать. Ну, можно проверить, что там ноль лежит.
Ну все, на сегодня хватит. Там ничего не вывел, потому что ничего не вывел.
Что? А, ну да. Так он в начале, почему, его видно.
Не видно, что он вообще не вывел. Так, ну ладно. Что мы только что делали, это же УБ? Конечно.
Санитайзеры. Ну да, да, да. Вот сейчас Федя вам про санитайзеры расскажет. А как к следующему?
Ай, нет, ничего не ловит, смотрите. Все, пара закончена. Санитайзеры не помогут.
