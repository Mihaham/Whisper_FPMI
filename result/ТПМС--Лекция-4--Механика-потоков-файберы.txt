Приветствую еще раз. Теперь должно быть меня видно и слышно. И экран должен быть. И мы, кажется, готовы начать. Давайте договоримся сразу. У нас сегодня встреча в зуме. Я этому очень не рад. Нужно договориться о правилах.
Если у вас есть вопрос, то просто включайте микрофон и задавайте его. Лучше не писать в чат, потому что читать чат мне неудобно во время реакции. Просто включайте и сразу задавайте вопрос. Единственное, что не забывайте потом микрофон выключать, чтобы остальным это не мешало.
А правда, что записи нет? Записи вроде сейчас нет. Вопрос оператору. Записи сейчас правда нет.
Когда тема пойдет, я включу.
Когда она пойдет, ты уже не успеешь, потому что она начнется.
Ладно, обрежем.
Что лучше. Да, спасибо. Так безопаснее.
Ну что, давайте начнем уже. Время наше пошло.
Итак, мы с вами продолжаем говорить про синхронизацию.
И вот две последние лекции мы занимаемся синхронизацией с разных сторон. Мы синхронизируем потоки с помощью мютексов. В прошлый раз мы поговорили про кундвары.
Сегодня мы поговорим, наконец, про потоки.
Ну как про потоки? В прошлый раз мы уже говорили про потоки. Мы их научились запускать. Вернее, договорились, что мы их запускаем только в виде пула потоков.
То есть они в нашей программе присутствуют только в таком виде.
Но я думаю, предполагаю, что все же наше понимание потоков все еще несколько магическое.
Ну то есть, да, мы на первом семинаре обсудили с вами, ну или с некоторыми из вас, как мы представляем себе исполнение.
То есть есть процессор, есть там ядро. Это ядро считывает инструкции из памяти, использует call stack для того, чтобы по этому коду перемещаться, заходить в функции, выходить из них.
Мы, наверное, представляем себе, что вот есть, скажем, системный вызов shit yield, который передает управление планировщику.
Планировщик убирает очередной поток, намазывает его на процессор.
Но все же такое понимание, оно несколько, не знаю, магическое какое-то.
Потоки пока не очень несезаемые. Вот что именно это такое? Как его себе представить?
Ну, представить это бы не наш путь. В этом курсе мы, если хотим что-то по-настоящему написать, мы должны, по-настоящему понять, мы должны это написать своими руками.
Это такой основополагающий принцип наш. Вот все, о чем мы в курсе говорим, мы стараемся запрограммировать в одной из домаш.
Так что сегодня мы поступим с потоками ровно так. Мы научимся их писать.
Но я немного обманываю вас, потому что прямо потоки мы писать не научимся сегодня.
Вместо этого мы научимся писать файберы, которые для нас будут служить вот некоторым воплощением упрощенным потоком.
Файберы. С файберами мы уже столкнулись в домашних работах для того, чтобы симулировать различные конкурентные баги, а именно дедлоки и лайфлоки.
Вы с ними могли столкнуться в домашних работах, потому что тесты запускаются не только под потоками недетерминированными и параллельными, а под кооперативными файберами тоже с fault injection.
Но вот сегодня мы хотим использовать файберы как наглядную простую учебную реализацию потоков.
Но помимо такого использования файберов, у нас конечно же к ним есть самостоятельный интерес, потому что файберы в конце концов в нашем курсе будут служить средством выразительности,
которое позволяет нам в нашей программе конкурентно обслуживать пользователей.
Вот я вам показывал этот код уже на первой лекции. Это эхо-сервер, написанный как будто бы на потоках в таком же стиле, но при этом весь код исполняется всего лишь в одном потоке операционной системы, очень компактно упаковывая всю работу.
Вот на самом деле, конечно же, в курсе мы хотим сделать файберы именно такими полезными, которые умеют сетевой вывод, умеют приметиво синхронизации, умеют в будущем параллельность.
Но сегодня нам подойдут самые простые файберы, и на примере их мы сможем изучить механику потоков.
Ну и давайте еще раз проговорим, вы это, конечно, в домашних уже встречали, но лучше проговорить, что именно мы под файберами понимаем.
Почему вообще мы считаем, что файберы для нас могут служить хорошим примером реализации потоков?
Ну я бы сказал бы так, что мы готовы изучить потоки на примере файберов, потому что файберы ведут себя как потоки. Что это значит?
Ну вот у файберов, у наших учебных файберов есть три базовых метода. Стойте, давайте я оговорюсь.
Мы сегодня говорим про конкретную библиотеку, про тайные файберы, которые мы используем в курсе, и если у вас есть возможность, то просто откроете ее у себя на ноутбуке,
и если вы будете по ней ходить, задавать вопросы, мне кажется, что вам будет удобнее так.
Лучше перед глазами иметь у себя на компьютере весь код библиотеки.
Ну вот, библиотека вам предоставляет в первую очередь три функции. Во-первых, это функция RunShedular.
Есть разные способы это произносить, либо Scheduler, либо Sheduler, в зависимости от версии, либо это...
Sheduler это американский английский, Scheduler это британский английский, ну вот я говорю Sheduler, или планировщик, всегда так говорить безопасно, корректно.
Мы запускаем эту функцию и передаем туда некоторую лямду. И вот в вызове этой функции разворачивается планировщик,
ну потому что мы пишем файбер, и файбером нужен планировщик, и мы его воспроизводим в пространстве пользователя.
Вот в этой функции он разворачивается и начинает исполнение первого файбера, нулевого файбера, стартового, который исполняет переданную в эту функцию лямду.
Что это первый файбер, нулевой файбер делает? Он первым же делом запускает другой файбер.
Ну вот вызов Spawn прямо к запуску, точнее к исполнению нового файбера не приводит, потому что все наши файберы исполняются всего лишь в одном потоке операционной системы.
Они не параллельны. И вызов Spawn конструирует файбер, чтобы это пока не значило, и добавляет его в очередь исполнения в планировщики.
Очередь исполнения мы называем RunQueue. То есть сейчас исполняется нулевой, стартовый файбер, файбер номер один,
сконструированный, томится в очереди ожидания в планировщики, ждет пока ему передадут возможность исполняться.
Стартовый файбер доходит до шага один и вызывает функцию Self Yield. Что делает Yield?
Yield останавливает исполнение текущего файбера, передает управление в планировщик, и планировщик в свою очередь,
во-первых, помещает текущий файбер, который вернул ему управление, в хвост RunQueue.
А во-вторых, выбирает очередной файбер и запускает его.
Но вот опять, не совсем понятно пока, что это значит. Вот наше сегодняшнее целе разобраться, что именно происходит.
Вот посмотрите на код всего этого. Итого, мы заходим в этот метод Yield, вот сюда.
Управление возвращается в планировщик, в эту функцию, и после этого планировщик, видимо, запускает первый файбер из RunQueue.
А в этот момент в RunQueue находился только файбер с номером один.
Так что мы заходим сюда и продолжаем исполняться отсюда.
Выполняем шаг два и снова видим Yield. Что он означает?
Что нужно вернуться в планировщик и планировщик переключится на первый поток в RunQueue.
В данный момент RunQueue выглядит как?
Там находится файбер ноль.
Вот мы заходим в этот вызов теперь.
И выходим и продолжаем исполнение нулевого стартового файбера.
А оно остановилось вот в этой точке, когда мы зашли в Yield и начали исполнять первый файбер.
Ну отлично, мы из этого Yield прыгнули обратно сюда, сделали третий шаг и запустили второй, если отсчитывать от нуля, файбер.
Он снова пока не начал исполняться, он попал в хвост RunQueue, и RunQueue сейчас выглядит так.
Там находится файбер f1 и f2. f1 сейчас остановился здесь.
f2 сейчас, ну он пока еще не исполнялся, вот он, когда он начнет, он стартует просто с начала вот этой ляммы.
И теперь мы отдаем управление планировщику в нулевом файбере.
А что конкретно вот возвращает нам Spawn? Понятно, что Join Handle, а что у нас умеет Join Handle? Что это за объект?
Может быть я чуть позже поговорю об этом. Join Handle это, ну я не знаю как бы назвать по-русски Handle, давайте так я и буду говорить от беспомощности.
С помощью этого Handle можно дождаться завершения исполнения запущенного файбера.
Ну то есть это некоторая такая ручка для его, точнее для, не то чтобы для управления, вот файбер стартовал, он будет работать.
Когда планировщика появится возможность. Ну вот с помощью Join Handle, давайте я уже до конца пример дойду и скажу, немного осталось.
Мы говорим здесь Yield, передаем управление планировщику, планировщик выбирает первый файбер из RunQ, помещает в RunQ в конец файбер 0.
В итоге мы прыгаем отсюда, вот сюда, выходим из этого Yield, в котором мы когда-то остановились, делаем четвертый шаг.
Первый файбер завершает свое исполнение, планировщик получает управление обратно, выбирает из RunQ очередной файбер, там сейчас первый файбер в очереди F2.
Стартует его, печатает 5, файбер снова завершается и наконец исполнение доходит до стартового файбера, который возвращается, печатает 6 и блокируется.
Блокируется, он по сути не блокируется, но семантика Join Handle Join, семантика такая, заблокироваться до тех пор, пока файбер не завершит свое исполнение.
Вот Join Handle ассоциирован с некоторым файбером и заблокировавшись на H1 Join, мы дожидаемся пока файбер вот этот вот не завершит свое исполнение.
Про это есть отдельный пример, это него. Вот он, тут можно даже эту строчку стереть, она кажется никакой роли не играет.
Ну вот давайте этот пример проговорим, он простой, но тем не менее полезный сейчас сделать. Мы стартуем, мы разворачиваем планировщик, файбер начинает исполняться и печатает Hello from parent, потом запускает еще один файбер, файбер этот попадает в конец RunQ планировщика, пока не исполняется.
А дальше этот файбер продолжает работать и говорит Child Join и вот он блокируется, то есть он дальше не может исполняться, пока не завершится этот файбер, этот файбер пока даже не стартовал, поэтому мы уходим с исполнения, отдаем управление планировщику, останавливаемся и планировщик запускает этот файбер.
Когда этот файбер завершится, то файбер начальный, нулевой, сможет выйти из Join и продолжить работать. Ну вот поэтому строчки печатаются вот в таком порядке. Раз, два, три.
Мы пока не говорим про реализацию, мы пока говорим просто про наблюдаемое поведение. Да и давайте запустим этот пример, потому что мы тут проговаривали в каком порядке все печатается, вот полезно это своими глазами увидеть. Я надеюсь, что вы даже пробовали это запускать дома и что-то читать, это будет сегодня полезно. Простите, я не аккуратно нажимаю на кнопки.
Все шаги выполнились в каком-то предсказуемом порядке. Ну вот, если мы это все понимаем, если пока вопросов больше нет, то еще раз я повторю свое утверждение, что файберы похожи на потоки, поэтому если мы сегодня изучим, как они работают, как они написаны, то мы тем самым поймем, как устроены настоящие потоки.
Ну что ж, давайте пару замечаний все же еще сделаем, прежде чем переходить к реализации. Ну вот, во-первых, вы можете заметить, что вот эти файберы ничего полезного делать не умеют. Ну да, они умеют запускаться и переключаться друг на друга с помощью вызовов yield, но все же никакой полезной программы с такими файберами не напишешь.
Это нас сейчас не беспокоит, потому что в конце концов мы хотим научить эти файберы какой-то полезной работе, мы хотим научить их вводу-выводу, и в этом курсе мы вряд ли сделаем что-то сильно сложнее, а вот скажем, в спецкурсе про распределенную систему осенью мы будем на файберах писать в общем полноценный сложный промышленный код, где файберы будут общаться через RPC.
Там много всего будет, так что пока можно такие претензии к файберам отложить. Ну и вы сами в очередной домашней, которая будет правда через неделю, только научите эти файберы общаться с внешним миром.
Для нас пока это модель потоков, и что нам важно, что файберы умеют друг на друга переключаться и планироваться. Что уж они делают, насколько это полезно, это второстепенная сегодня задача.
Но вы можете возразить мне более содержательно, а именно, вот я говорю, что мы изучим потоки на примере файберов, но ведь потоки они похожи на, простите, файберы они похожи на потоки, но они все-таки потоками в том смысле, в котором мы их наблюдали в течение первых лекций домашних, они конечно не являются. Почему?
Ну во-первых, потому что потоки исполняются параллельно, а файберы упакованы в один поток. Вот если исполняется один файбер, то другой не может исполняться, они не могут исполняться одновременно на разных ядрах.
Во-вторых, файберы не дотягивают до потоков, потому что в потоках есть механизм вытеснения. Если, скажем, поток на ядре запустился, работает долго, слишком долго, то при очередном прерывании по таймеру в обработчике этого прерывания в ядре операционной системы запустится планировщик.
Планировщик увидит, что поток на ядре израсходовал свой квант времени, выберет другую задачу и намажет ее на процессор. Вот такого механизма у файберов нет.
Ну и давайте обсудим, насколько эти отличия принципиальны для нас. По поводу параллелизма. Параллелизма действительно нет и не будет сегодня, но он будет уже через неделю. Вот через неделю мы научимся строить файберы параллельными.
Вернее как, я расскажу вам идею, мне кажется, очень изящную, очень ловкую, с помощью которой можно задачу декомпозировать и потом легко поддержать параллельность в файберах.
Ну а вы это напишите даже сами. Так что подождем неделю и задача будет решена. Файберы параллельными у нас, безусловно, станут.
Вторая претензия состояла в том, что в них нет механизма вытеснения. Ну вот здесь потребуется, наверное, чуть более подробный комментарий.
Наши файберы называются кооперативными. Вот они отдают управление планировщику другому файберу только добровольно, в каких-то понятных точках.
Вот мы здесь говорим yield и перестаем исполняться и переключаемся на другой файбер. Если мы yield не скажем, мы исполняться продолжим дальше, никто нам не помешает.
Возможно, этого недостаточно. Ну вот скажем, для языка go, где у вас грутины, которые мы считаем почти что синонимами файберов, в go есть механизм вытеснения.
Но я утверждаю, что вот он в go нужен, а нам не нужен. Потому что мы пишем все-таки не язык программирования, мы пишем библиотеку.
Библиотеку, которая решает более-менее конкретные задачи. Библиотеку или в общем случае какой-то фреймворк, в котором предполагается решать какие-то определенные задачи.
Скажем, мы пишем сетевой код, где у нас много обработчиков запросов, много конкурентных активностей, и они друг с другом как-то взаимодействуют.
Взаимодействуют с помощью приметилов синхронизации, взаимодействуют с помощью сетевых вызовов. Их может быть очень много, но они собираются все-таки упаковаться в небольшое число ядер,
потому что они большую часть времени не то чтобы работают на процессоре, они большую часть времени спят. Спят в ожидании чего-то.
Спят, ожидая завершения сетевого вызова к другому удаленному сервису. Или спят в ожидании освобождения блокировки локальной.
И вот эти точки, где они блокируются, чего-то ожидают, они и будут точками, где в коде файберы передают друг другу управление.
Конечно, настоящие полезные файберы не будут делать, но кажется, что никогда не будут даже делать.
Так вот, им будет достаточно вот тех блокирующих операций, которые они будут выполнять.
Если мы будем переключать файберы в точках этих блокирующих операций, то нам вытеснение не потребуется, потому что задача наша таковы, что никаких тяжелых вычислений в файберах мы делать не планируем.
Если же, конечно, пользователь файберов решит что-то долго вычислять в них, то, да, он пострадает от отсутствия вытеснения.
Но он вроде как и не должен этого делать, иначе зачем он выбрал файберы? Почему он не выбрал просто потоки?
То есть это в его случае будет осознанным выбором, поэтому он понимает ограничения или специфику инструмента, который он собирается использовать.
В ГО ситуация сложнее, потому что там пользователь не выбирает между потоками и гарутинами, там есть только гарутины.
Поэтому там, значит, разработчики языка уважают принцип наименьшего удивления и ожидают, что пользователь может любую программу на ГО написать,
а значит, когда-нибудь придется все же гарутины вытеснить.
Но в любом случае мы будем делать параллелизм уже через неделю, наши файберы будут исполняться одновременно на разных ядрах,
и мы не будем делать вытеснения. Но при этом я скажу, что вытеснения сделать можно.
То есть если вы захотите, то к файберам можно приделать и вот такое, и механизм приемщину самый настоящий.
Но просто нас не интересует, мне кажется, что это не самая полезная функциональность.
Хорошо, есть ли вопросы к тому, что мы хотим сделать? Нужно ли что-то пояснить?
Верим ли мы, что мы научимся делать потоки после этого?
Ну, не знаю, нам это на этом курсе нужно или опять же нужно? Мы должны на осеннем заниматься.
Мы собираемся изучить потоки, устройства потоков на примере файберов.
Вот я сейчас спрашиваю, в какой степени нам это нужно? Я утверждаю, что нам это нужно, понимать, что такое потоки,
потому что если мы не понимаем, что такое потоки, то очень странно, как мы вообще с ними дальше работать собираемся.
Полезно понимать то, что мы трогаем своими руками. Мы же в конце концов инженеры.
Мы понимаем тогда, когда умеем это запрограммировать.
И я сейчас спрашиваю не о том, как мы собираемся пользоваться файберами,
а я сейчас говорю, что мы на примере файберов хотим понять потоки.
И вот верим ли мы, что на примере файберов мы действительно поймем потоки?
Может быть, я что-то не учел. Я вроде поговорил про функциональность,
про то, что файбер научится делать, эти выводы, синхронизацию.
Но, впрочем, они уже умеют про параллелизм, про утеснение.
Но вот чем-то в нашем уме файберы от потоков еще отличаются?
Наверное, да. Возможно, у меня, конечно, в голове все перепуталось, но, по-моему,
вот тот вот пример с тем, когда внезапно оказывается,
что в двух прочитанных переменных внезапно одновременно оказывается ноль,
может быть, вот этим они могут отличаться от потоков.
А это не имеет отношения к файберам или потокам.
Это происходит на уровне процессора и обращения к памяти.
То есть это на уровне железа происходит.
А потоки, файберы, это же такие сущности виртуальные.
Они появляются на уровне операционной системы, библиотека.
Это просто более высокий уровень.
Если мы сделаем файберы параллельными, а мы сделаем их,
то они будут исполняться на разных ядрах,
и тогда они будут наблюдать те же самые странные эффекты.
То есть тут ничего не поменяется.
Ну тогда вроде бы да.
Отлично. Значит, я вас убедил, что мы делаем потоки.
Мы сделаем потоки.
Ну тогда давайте переходить к реализации.
И начну я вот с такого вопроса.
Ну вот, написан код.
Вот он как-то себя ведет.
И вам дают задачу.
Вот, напишите реализацию этих функций.
Что тут выглядит самым необычным?
Вот почему нетривиально такое поведение реализовать?
Действительно, у нас есть функция yield, и она очень необычная.
Вроде бы мы вызываем обычную функцию.
Но при этом, как ведет себя обычная функция,
мы заходим в нее, она начинает выполняться,
может вызывать какие-то другие функции,
но в конце концов вызов функции завершается,
она возвращает нам управление.
Мы один раз в нее заходим, один раз из нее выходим.
Функция yield ведет себя иначе.
Мы заходим в нее, ну вот скажем здесь,
мы заходим в этот вызов yield,
а выходим почему-то из этого вызова yield.
Это довольно странно.
Кроме того, мы заходим в этот вызов yield один раз,
а выходим получается два раза.
С одной стороны, первый раз мы выходим отсюда,
ну не совсем из этого вызова, но все-таки выходим,
продолжаем исполнять какой-то другой код.
А второй раз мы выходим из этого yield,
тогда, когда нулевому стартовому файберу возвращают управление.
Когда видимо завершается второй запущенный файбер.
То есть у нас здесь какая-то очень нелокальная,
странная передача управления,
и мы заходим один раз, а выходим дважды.
Вот это самое нетривиальное, кажется, место в этом примере.
Потому что вот что такое сконструировать файбер тоже пока непонятно,
но в целом вот мы конструируем какой-то объект,
кладем его в какую-то очередь, это еще вот мы можем себе вообразить.
А как написать yield?
Под вопросом пока.
Тем более, почему под вопросом?
Потому что вроде бы мы, смотрите, мы пишем какой-то код,
и ему же придется исполняться на процессоре.
И в данном случае процессор нам помогать сильно не будет.
Вот мы умеем передвигаться по коду с помощью инструкции,
там не знаю, jump условных, безусловных.
У нас есть в процессоре инструкции call и read,
с помощью которых процессор двигается,
который компилятор расставляет в точках вызова функции завершения.
И мы привыкли, что для функций выполняется такое простое свойство,
что любые два вызова, они либо не пересекаются между собой,
либо один вложен в другой.
Давайте мы какой-то простой пример откроем.
Вот я взял Godbolt, написал какую-то программу с вызовами функций,
и вот у нас есть функция foo, которая вызывает функцию bar,
которая вызывает функцию baz, а потом baz вызывается прямо из foo.
И вы, наверное, понимаете, что чтобы двигаться по вот такому коду,
процессору нужно поддерживать call stack.
Потому что когда мы, скажем, вызываем функцию foo из main,
то мы, компилятор, знаем, куда мы хотим прыгнуть.
Адрес понятен нам.
Но с другой стороны, когда мы выходим из какой-то функции,
например, из функции baz, то компилятору уже, конечно, неизвестно,
куда мы вернемся, то ли мы вернемся в функцию bar,
то ли мы вернемся в функцию foo.
И для того, чтобы двигаться по этому коду,
процессору, ядру процессора, нужен call stack,
на котором процессор будет сохранять до 10 возвратов.
Когда мы вызываем функцию baz, то мы кладем на вершину stack,
после мантики инструкции call мы кладем на вершину stack
адрес очередной за вызовом baz инструкции.
Когда вызов baz завершается в инструкции red,
мы снимаем адрес возврата с вершины stack
и кладем его в регистр процессора, instruction pointer.
И это, кстати, нам сегодня понадобится единственный способ
instruction pointer манипулировать.
Это важно, потому что я сейчас утверждаю,
что никакого другого механизма движения по коду вашей программы,
по ее функциям в процессоре нет.
Есть stack вызовов, есть инструкции call, red,
положить на stack адрес возврата, снять со stack возврата и прыгнуть в него.
Вот это все инструменты, которые в нашем распоряжении имеются.
То есть, когда мы будем писать переключения
между разными частями файбера,
мы будем какие-то хитрые вещи с call stack делать, да?
Это не совсем то, что я прямо сейчас хотел сказать.
Я скорее хотел обратить внимание, что никакой специальной магии
в процессоре для реализации вот такого нетривиального поведения,
нелокальной передачи управления нет.
Мы собираемся сделать файберы из того, что вы уже знаете.
Если вы знаете про call stack и инструкции call, red,
а это, кажется, тема первого семинара,
то таких знаний достаточно, чтобы, простите,
написать собственные файберы с такой передачей управления.
И да, раз у нас ничего другого нет,
то нам придется к какой-то хитрости прибегать.
Но дело отличается, скажем, от Atomic,
потому что в Atomic вы знаете, там есть какие-то специальные инструкции
в процессоре для того, чтобы делать атомарные операции.
Здесь у нас обычный call, red, call stack,
и мы должны каким-то образом выразить вот такое странное поведение,
где вызовы разных файберов, разных функций, разных лямб пересекаются.
Они не вложены, не пересекаются,
фрагменты функций чередуются друг с другом на процессоре.
Ну и давайте себе примерно представим, как это могло бы выглядеть,
как это могло бы работать.
Ну, мы хотим сохранить состояние,
из которого вызвали yield, то есть, видимо, stack,
вершину stack вот этого вот файбера,
и регистры какие-то, которые, ну, незатираемые,
которые ему хочется запомнить,
и просто записать их, чтобы дальше можно было это восстановить
перед тем, как возвращать управление этому файберу.
Ну да, мы сейчас занимаем, мы сейчас рассуждаем,
как написать yield. Так, воображаем пока.
И тут есть как бы две стороны вопроса.
Во-первых, это работа с очередью планировщика.
Нам нужно поставить себя в очередь,
выбрать какой-то следующий файбер из очереди,
в общем, этот рангью участвует.
А есть такой чисто технический момент,
как переключить исполнение,
как переключить процессор с исполнения вот этой функции
на исполнение этой функции.
И вот это не вызов функции,
потому что мы выходим из середины почему-то
и прыгаем в другое место.
Так что нужно вспомнить, что такое вообще исполнение.
Исполнение с точки зрения процессора – это
что нужно к ядру процессора, чтобы исполнять код.
Ему нужен instruction pointer, чтобы, собственно,
понимать, какую инструкцию дальше считывать, декодировать, исполнять.
И ему нужен call stack, чтобы по коду двигаться.
Ну, там, pointer еще на корень таблицы страниц, в общем,
какие-то еще дополнительные вещи.
И, разумеется, регистр процессора, в которых
исполнение раскладывает какие-то свои
результаты, аргументы, возвращаемые значения,
все, что этому исполняемому коду требуется.
Когда мы говорим про переключение, переключение контекста,
то, видимо, мы должны вот это состояние
процессора сохранить
и сохранить с ядра куда-то
и активировать на ядре состояние
контекста исполнения вот этого,
ну, еще не запущенного fiber.
Когда мы говорим здесь yield, то мы активируем
контекст, сохраненный вот в этой точке.
Контекст — это набор регистров, который,
относительно которого,
исполнение процессора вообще что-то исполняет.
То есть, это такой согласованный набор регистров,
RIP, instruction pointer, RIP, stack pointer, RSP,
ну, и так далее.
Вот здесь мы хотим эти регистры сохранить
с процессора в память, и потом намазать
вот здесь, сохранить и намазать вот эти регистры,
которые были сохранены шагом ранее.
Пока мы не будем разбираться, как именно это все работает,
как мы сохраняем регистры, какие регистры, почему
такие, мы скажем, что у нас для этого просто есть
вспомогательный такой компонент, инструмент, который
называется executionContext.
Вот такая структура, у которой есть, ну,
по сути,
единственный метод — switchTo.
И что мы сможем с помощью него сделать? Мы можем
написать такую строчку.
Пока пользуемся им, как некоторым
черным ящиком, нам не важно, как устроено,
примерно, как устроено switchTo, мы с этим разберемся
чуть позже. Пока нам важна семантика.
Итак, представим себе, что мы,
процессор, мы исполняем код, и в этом коде написано
контекст switchTo, контекст штрих.
Семантика вызова такова. Сохранить
текущий контекст исполнения, то есть набор регистров,
в эту переменную.
И активировать набор регистров,
который сохранен в штрихованном контексте справа от switchTo.
То есть мы вот здесь переключаем
процессор на исполнение какого-то другого кода,
видимо, собственным стэком, потому что исполнение
всегда относительно какого-то стэка происходит.
С другими значениями содержимым регистров.
Но возникает вопрос, откуда взялся контекст штрих?
Откуда там взялись сохраненные регистры? Но, видимо, возможно.
Контекст штрих до этого когда-то сам
стоял слева от вызова switchTo.
И вот мы когда-то ранее сохранили в него состояние
процессора, а сейчас мы его активируем,
и в него возвращаемся.
Что значит, если мы прыгаем обратно по стэку?
Если мы прыгаем вперед, то есть заходя на уровень бы уже...
Что значит прыгаем по стэку? Мы не прыгаем по стэку.
Мы переключаем разные исполнения.
Любое исполнение в процессоре происходит относительно
стэка, потому что стэк
это некоторый путь сейчас
в дереве вызова функций.
Да, но вот насколько я понимаю, сейчас мы
конкретно сейчас мы
switchTo рассматриваем, если у нас контекст
штрих уже когда-то был. Это значит, мы возвращаемся
на уровень выше по стэку.
Уровень выше по стэку, я не понимаю, что это значит.
Это вообще звучит некорректно, если честно.
Ну, предыдущий элемент в стэке. В каком стэке?
Тут нет никакого стэка.
Ты понимаешь, значит, предыдущий в стэке? Я говорю, что
у нас есть процессор, он исполняет код.
И этот код вызывает метод switchTo.
И я регистры процессора сохраняю сюда,
я активирую регистры отсюда.
Намазываю их на процессор.
Да, это понятно, что делает switchTo.
Но что делать, если контекст штрих
у нас никогда еще не был?
Это странно, что ты прыгаешь в контекст,
который еще не существовал. Значит, ты написал
неправильную программу.
Получается, мы можем вызывать функции
только те, которые у нас были.
То, что это множество не пустое, мы пока не доказали.
Если ты про то, что нам...
Я понимаю, про что ты говоришь.
Ты не совсем все же корректные слова выбираешь.
Если ты выбираешь выше по стэку,
тут нет, к сожалению, общего стэка,
относительно которого мы все это делаем.
Я действительно говорю, что если мы
сохраняем текущий контекст с процессора
вот сюда и активируем этот контекст, то этот контекст
должен быть валиден. В нем должны быть
какие-то разумные содержимые регистров записано.
И откуда оно могло взяться?
Вот этот контекст штрих до этого в исполнении
когда-то находился слева от свечту.
И мы в него сохранили состояние исполнения на процессоре.
Но возникает тогда вопрос,
откуда взялся контекст два штриха.
И вот так можно откатываться, откатываться, откатываться,
добавляя и добавляя штрихи. Где-то должна быть база.
Это правда, но мы пока этот вопрос откладываем.
Мы пока про базу не говорим. Мы говорим про отдельную
и считаем, что вот контекст штрих откуда-то уже взялся.
Если мы вернемся вот
к этому коду,
то я иллюстрирую такой пример, что мы заходим
в этот Yield и выходим отсюда.
И здесь мы активируем контекст
вот в этом вызове Yield, мы активируем контекст,
который был сохранен вот здесь вот.
Но есть отдельная ситуация,
когда мы вызываем вот этот Yield,
и мы активируем контекст вот запущенного файбера.
А откуда он взялся, непонятно.
Ну, забегая вперед, я скажу,
что мы его сами руками сконструировали,
прям вот буквально руками.
Но это такой базовый случай,
а дальше все остальные переключения контекста
внутри файберов, они выполняются
с помощью вот такого вызова.
И вот происходящая здесь операция, она называется
симметричной передачей управления.
Небольшое замечание. Класс, про который
я сейчас говорю, называется ExecutionContext,
и он вообще-то находится в отдельной библиотеке.
И он не связан ни с потоками,
ни с файберами. Он оперирует
понятием исполнения.
Если вы вспомните первый семинар,
то какая там одна из важных мыслей,
которая должна была с вами остаться после него,
что на уровне процессора
у вас есть instruction pointer,
у вас есть stack pointer, у вас есть call stack.
Вот это и процессор
с помощью вот этих
с помощью вот этих структур данных,
stack, там таблица, страница, еще чего-то, исполняет ваш код.
Что это за код? Это код файбера, это код потока
из питредов.
Процессору неважно, на его уровне всего этого нет.
Мы сейчас говорим именно про исполнение
на процессоре и как процессор переключить
вызовы исполнения на другое.
Вот этот execution-контекст, он более универсален,
чем файбера. Файбера это всего лишь одно из
применений процедуры переключения контекста.
И мы собираемся ее использовать вот где-то
внутри этого вызова yield.
Давайте я сейчас сразу забегу немного вперед,
пока не важно, что это все значит.
И потом вызывать там какой-то switch-to в конце концов.
Хорошо. Если мы понимаем,
в чем сложность вот в этом переключении контекста,
в нелокальной передаче управления, и мы понимаем
семантику switch-to и само назначение
класс execution-контекст, то можно теперь
перейти уже к конкретному применению всего этого,
к нашим файберам, и разобрать два основных
элемента библиотеки, а именно сам файбер,
сам объект файбер и планировщик
файбера. Давайте начнем с файбера.
Вот он представлен в виде
соответствующего класса.
И нас интересует сейчас,
чем образован этот файбер.
Во-первых, файбер исполняет некоторую лямбду.
И эта лямбда в нем хранится в виде контейнера,
в виде уник-фанкшн. Это альтернативная
реализация std-фанкшн, которая
позволяет нам хранить move-only лямбду.
Есть код, который файбер
собирается исполнять.
У файбера, помимо этого кода, есть еще и стэк,
потому что проще
показать. Давайте посмотрим на другой пример.
Вот на такой.
Запускаем планировщик. В нем запускаем...
В нем файбер запускает
другой файбер и вызывает функцию foo.
В этой функции foo он вызывает функцию bar. В этой функции
bar он говорит yield.
И управление передается вот этому
файберу. Этот файбер вызывает функцию bus.
В функции bus тоже сразу говорит yield.
После чего возвращает управление сюда
и первый файбер завершает
свою работу. Ну вот давайте мы этот пример
запустим и продемонстрируем.
Ну, я надеюсь, понятное...
Понятное свойство файберов, но все же.
Видеть своими глазами тоже полезно.
Простите, что так неспешно. Тут просто
и EDE, и скринкаст пишется, и зум.
Все это не добавляет нам скорости.
Вот так вот.
Ну, я надеюсь, вам понравилось это видео.
Если вам понравилось, не забывайте
поставить лайк.
А если вам понравилось, не забывайте
подписаться на канал.
Все это не добавляет нам скорости.
Вот мы вызвали функцию foo и остановились
на breakpoint.
Смотрим на текущий стэк.
Ну, там что-то странное внизу происходит, но в конце концов
на верхушке вызов bar,
под ним вызов foo.
Вот мы сейчас в стартовом файбере
зашли foo, в нем зашли в bar и остановились
на breakpoint.
Вот как выглядит наш стэк.
После этого мы возобновляем
исполнение и, видимо, попадаем в yield
и перемещаемся в этот файбер
и останавливаемся на его
breakpoint. Вот мы теперь стоим на стэке, где
находится только вызов bass.
А дальше мы снова
из вызова bass, из этого yield,
прыгаем сюда. Возвращаемся
из этого вызова yield функцией bar,
останавливаемся на втором breakpoint.
И вот мы снова на стэке bar foo bar.
О чем это нам говорит? Что у каждого
файбера есть свой собственный стэк вызовов.
Они находятся в разных точках
в этой иерархии, в этом дереве вызовов
функций в программе.
Еще раз повторю, любое
исполнение на процессоре осуществляется
относительно некоторого стэка вызовов.
И у каждого файбера он свой.
Так что мы это можем наблюдать
в этой структуре.
Что такое стэк здесь?
Если смотреть в реализацию, то это
просто-напросто диапазон памяти.
Чарльзвездочка size t.
Откуда он взялся,
можно зайти в этот вызов
и посмотреть.
Мы этот стэк лоцировали.
Терпеливо ждем.
А локация это не что иное,
как сегодня все медленно.
Как вызов ММЭП?
Как вызов ММЭП?
Как вызов ММЭП?
Как вызов ММЭП?
Как вызов ММЭП?
То есть, когда мы
конструируем файбер, то мы лоцируем для него стэк
с помощью вызова ММЭП,
то есть просто заводим диапазон страниц в памяти,
которые будут использованы
для хранения, для поддержания
стэка.
Процессору совершенно не важно, в какую память он пишет,
когда он работает с коллстэком.
Вот то место, куда указывает регистр РСП в нем,
это и есть для него стэк.
Вот мы его выделяем так.
Тут еще есть много каких-то тонкостей в пути.
Мы пока их откладываем.
Да, можно сразу задать вопрос, почему ММЭП,
что с колл делать?
Во-первых, мы с колл делать будем не всегда.
Во-вторых, у этого есть некоторая необходимость.
Мы хотим именно память, выровненную по страницам.
Но это мы, если не успеем сегодня, то обсудим на семинаре.
Хорошо, возвращаемся в файбер.
У него есть стэк.
У него есть чар-звездочка из IST, то есть вью над памятью.
И есть, наконец, экзекьюшн-контекст.
Вот это поле заполнено, конечно же, не всегда.
Если файбер прямо сейчас исполняется,
то здесь ничего содержательного не написано внутри этого объекта.
Но если файбер сказал yield
и остановился,
то в этот момент вызывается свечту,
который и записывает в поле экзекьюшн-контекста
этого файбера текущие содержимые регистров процессора.
То есть это поле заполнено,
только если файбер сейчас остановлен
и находится, например, в ранг U.
И есть какие-то вспомогательные поля.
У каждого файбера есть идентификатор.
И у файбера есть состояние...
Ну вот, это состояние означает,
что файбер исполняется прямо сейчас.
Это что он находится в ранг U.
Это что он завершен.
Зачем эти состояния нам нужны, мы чуть позже увидим.
И можно теперь посмотреть
еще раз на код создания файбера.
Мы алоцируем стэк,
генерируем уникальный идентификатор для файбера
и, собственно, заводим структуру файбера,
мувая туда функцию,
которую он должен выполнять,
и передавая владение алоцированным стэкам.
Обратите внимание, что структура файбера
нигде наружу в API-библиотеке публично не торчит.
Пользователь к этому объекту доступа не имеет.
У него есть API-spawn,
API-yield, но есть slip-forward, get-id,
но прямого доступа к этому объекту нет,
и join-handle это, конечно же, не
ссылка прямо на объект файбера.
Это всего лишь ручка, с помощью которой можно заблокироваться
на ожидании завершения файбера, но все же это не файбер.
И вот, кстати,
когда мы говорим про STD thread,
то ведь экземпляр класса STD thread
это не то же, вот прям объект поток.
Это, на самом деле, такая же ручка, с помощью которой можно
сделать det через join.
То есть STD thread C++ в библиотеке
работать с потоками, это вот в точности то же самое,
что join-handle у нас.
То есть это не сам поток, это не сам файбер.
Мы пользователю доступа до этого объекта не даем.
Есть такие потоки,
есть файберы,
и есть class execution context,
который мы пока не понимаем, как устроен, но в принципе
можно было бы уже, имея вот такие файберы, потоки
и стэки, написать саму библиотеку.
Мы запускаем файбер, он начинает исполняться,
работает-работает, доходит до yield, в yield
мы говорим switch to, в yield
мы выбираем следующий файбер из очереди,
некоторый, который где-то хранится,
и переключаемся
на новый файбер. То есть мы
сохраняем регистр процессора в контекст текущего
файбера и активируем контекст выбранного из очереди файбер.
Но, тем не менее,
код написан не совсем так. То есть наш код,
когда мы говорим yield,
не переключает на самом деле файбер
сразу на файбер.
Вот мы отсюда прыгаем все-таки не напрямую
в этот код, в эту точку. У нас есть некоторые
промежуточный вспомогательный хоп.
И давайте, чтобы это почувствовать,
я задам такой вопрос. Вот есть пример, тут есть
три файбера. Стартовый и вот
два запущенных из него.
Сколько стэков в этом примере?
Три. То есть три файбера, три стэка.
Маловато. Да.
Нет, ну еще есть стэк изначально, на котором main вызывался.
Ну вот да, мы создаем файбер, и мы вроде бы
уже убедились, что у каждого файбера при создании
аллоцируется собственный стэк. У каждого файбера есть
совершенно отдельная память,
которую процессор использует для навигации по коду.
Но ведь есть еще и сама функция main,
и она запустилась в некотором потоке, у которого тоже
был собственный стэк, который аллоцировали уже не мы,
разумеется, а операционная система.
Но в конце концов, это тоже стэк.
И вот именно на этом стэке вызывается
функция runShaddler.
И что же она делает?
Она разворачивает планировщик, она запускает планировщик.
И вот на самом деле у нас на процессоре в этой
библиотеке исполняется не только файбер, а сам планировщик.
То есть он активный участник исполнения.
Он тоже выполняет некоторый код.
Что он делает?
С чего начинается вообще исполнение
функции runShaddler?
Мы запускаем файбер.
Что это значит?
Логически запускаем.
Пока конструируем файбер,
и помещаем его в очередь ожидания.
Вот как было заявлено, в планировщике есть очередь ожидания,
и вот она.
Это не совсем обычный список, это интрузивный список.
К интрузивности мы еще вернемся, причем много раз.
Это тоже, пожалуй, тема для семинара.
Вот мы сконструировали новый файбер, мы запланировали
новый файбер, то есть добавили его в очередь.
После чего мы перешли в runLoop.
И вот runLoop это функция, которая
работает на стеке
того потока, который
вообще вызвал runShaddler.
Вот эта функция,
мы же ее вызываем на стеке мейна,
и она исполняется, не завершается
до тех пор, пока внутри планировщика остаются
готовые исполняться файберы.
И вот эта функция
не завершается именно в вызове runLoop.
Вот мы здесь, в этом цикле, крутимся,
и на каждой итерации, пока очередь не пуста,
выбираем из этой очереди очередной файбер,
и переключаемся на него.
Что значит переключаемся?
Ну это означает, что мы
запоминаем, что сейчас исполняется
вот такой вот файбер.
Для этого есть поле current, а вы простите running.
Мы меняем состояние
выбранного файбера на running с runnable
и вызываем метод switchToFiber.
Который что делает?
Видим. Сохраняет состояние
процессора, который сейчас
выполняет функцию runLoop
в поле loop.context
планировщика.
То есть у него тоже есть контекст исполнения,
потому что он тоже исполняется, и с него тоже переключаются.
И активирует
на процессоре контекст исполнения,
то есть регистры, которые
задают исполнение файбера.
Итого, у нас в примере
в этом четыре активных сущности.
Это три файбера и один планировщик.
И у каждого из них есть свой собственный контекст исполнения.
И вот прыжки между этими объектами
происходят, смотрите, в каком стиле.
Все начинается, конечно, с планировщика,
вот мы его стартуем, он выбирает первый файбер,
переключается на него, файбер работает, работает, работает,
переключается обратно в планировщик,
ну и вот исполнение бежит так по цепочке.
Это лучше показать, вот я сейчас попробую
это сделать следующим образом.
Вот у нас есть программа,
вот мы в ней
вызываем, например, здесь
Yield
и
ну то есть что происходит при запуске
планировщика я показал, а вот теперь
я хочу показать то же самое со стороны
файбера. Вот файбер работает,
вызывает Yield, и это же обращение
к планировщику, это некоторый системный вызов, да?
Ну а чтобы сделать системный вызов,
нужно как-то адресовать текущий планировщик, как вообще его найти.
Но для этого
у нас есть функция GetCurrentShadower
и она реализована очень просто. У нас есть просто глобальная
переменная Shadower звездочка, которая указывает
на текущий планировщик,
в котором мы исполняемся, это такой способ его
найти в программе.
И вот мы уже на этом планировщике
вызываем метод Yield.
Вот планировщик, у него есть
системные вызовы, которые можно исполнять из
файберов. Пока мы говорим только про
Spawn и про Yield, но есть еще
SlipForer, это отдельная история, есть SuspendResume
для реализации приметива синхронизации
и есть Terminate, до которого речь еще дойдет сегодня.
Вот мы вызываем Yield.
И что происходит? Смотрите.
На планировщике вызвали метод Yield,
вызвали из файбера. Что делает планировщик?
Он находит файбер, который к нему обратился.
Как? Ну просто смотрит на поле
и в ранг.
Давайте мы сделаем
вот что.
Так, это будет немного сложнее,
чем я думал.
Итак, вот у нас, смотрите,
у нас есть сейчас такая раздвойная картинка.
А здесь у нас есть
вот такая картинка,
вот эта картинка,
вот эта картинка,
вот эта картинка,
слева,
слева,
нам потребуется некоторый сетап.
Картинка разделена на две части,
слева будет файбер,
справа будет планировщик.
Ну в смысле, что значит файбер-планировщик?
И планировщик это отдельные исполнения,
у которых есть свои собственные стеки.
И вот то, что происходит на стеке файбера,
я буду показывать слева. То, что происходит на стеке
планировщика, я буду показывать справа.
И вот мы говорили, с чего начинает работа планировщика.
Так, простите.
Он исполняет процедуру run loop.
Он выбрал очередной файбер
и запускает его.
То есть запоминает, вот кто сейчас running.
И когда этот файбер
запущенный вызывает yield,
то в планировщике
этот yield с помощью функции
getCurrentFiber через установленное
вот здесь поле running находит этот текущий файбер,
меняет его состояние обратно на runnable,
после чего
выполняет переключение контекста
в обратную сторону.
То есть мы
сохраняем регистры
процессора в контекст
исполнения файбера и активируем
loop.context.
Почему он инициализирован?
Потому что ранее вот здесь вот,
когда мы запускали файбер,
мы в этот loop.context
сохранили регистры процессора
для основного стека, для основного потока программы.
Вот мы его здесь сохранили,
а теперь мы в него готовы вернуться.
И вот именно этот switch2 это и есть
магия, потому что мы вот здесь
вызываем switch2,
лучше даже здесь, вызываем этот switch2,
а выходим из этого switch2, в который мы зашли ранее.
И вот именно эта функция,
switch2 это вот та самая функция,
в которую мы заходим один раз и выходим дважды в конце концов.
Скажите, это понятно?
Да.
Ну, если все понятно, то здорово.
Тогда что нам осталось
обсудить?
Ну, наверное, нам нужно договорить, что происходит,
когда мы возвращаемся в планировщик.
Вот мы вызвали switch2.shadower,
активировали контекст планировщика, вернулись в него,
вернулись из этой функции switch2Fiber,
сбросили runningFiber,
функция вызовStep завершился.
Ну, то есть, мы запустили Fiber,
он поисполнялся, а потом почему-то решил остановиться.
Почему он решил остановиться?
Ну, возможно, он вызвал yield.
Вот для того, чтобы разобраться, почему Fiber остановился,
у нас есть функция dispatch.
Потому что он сделал какой-то системный вызов в конце концов,
аналогия. И вот этот системный вызов
вырабатывается в методе dispatch.
Это может быть не совсем не то, что неаккуратно
написанный код. Возможно, его нужно написать иначе.
Я знаю, написать гораздо лучше,
но я вам пока не рассказываю, вы должны
это сами придумать в какой-то довольно поздней
домашней работе. Но в этом коде
начализация Fiber'а происходит по его состоянию.
Вот если Fiber вернулся в состояние runnable,
а так был устроен yield,
он менял состояние Fiber'а на runnable.
Вот здесь вот.
То планировщик понимает, что Fiber
сделал yield и просто его перепланирует.
То есть, снова добавляет в конец очереди.
И вот, смотрите, вот семантика метода yield.
Мы сейчас ее в коде увидели просто, как она реализуется.
Мы находим планировщик.
Сейчас мы
находим планировщик, вызываем на нем yield.
Прыгаем в него.
Возвращаемся
из метода switchTo в методе switchToFiber,
который был вызван из степа.
И помещаем
себя в конец rankU.
После чего планировщик
переходит на очередную итерацию циклопланирования,
выбирает себе очередной Fiber и запускает его.
Ну вот, почти все понятно.
Осталось только разобрать, как, собственно, работает
самый непонятный компонент, а именно вызов switchTo.
Скажите, а во сколько мы заканчиваем?
Сколько у нас времени осталось?
15 минут.
Ну, вроде по плану все.
Итак, если мы понимаем
все остальное, кроме execution-контекста,
как он устроен, то давайте подумаем,
как этот execution-контекст написать.
Это, может, такое, наверное, глупое предположение,
но это разве не решается просто
несколькими вызовами атомарного экщенжа.
Ну, причем здесь вообще атомарные инструкции?
Атомарная сна вообще не нужна,
она просто сделает слаб всех регистров, которые нужны.
Ну, так процессоры
все же не работают.
Давай я расскажу лучше.
Звучит действительно просто сохранить регистр, активировать регистр,
но тут есть нюансы, и из-за нюансов появляется что-то.
Ну, это сложно,
но тут аккуратность требуется в рассказе.
Итак, если мы понимаем,
как файберы и планировщик
взаимодействуют между собой,
как организовано взаимодействие в этих ролях,
как они используют класс execution-контекст,
то, кажется, с файбером это мы закончили.
И теперь нужно вернуться на уровень исполнения
теста, как устроен Switch2.
Давайте заметим, что
вот здесь, при реализации этого самого Switch2,
мы воспользуемся тем фактом, что у нас все-таки файберы
это не потоки, в том смысле, что файберы у нас
кооперативные, что в них нет механизма
вытеснения.
Если вы запускаете несколько потоков на ядрах
процессора, то вы можете ожидать, что между
любыми двумя инструкциями в ассембле
у вас произойдет вытеснение,
то есть, прилетит прерывание по таймеру, допустим,
и процессор переключится на исполнение кода
ядра операционной системы. Там запустит планировщик,
ну и вот что-то там случится.
Ну, в общем, вы этого можете ожидать абсолютно в любом месте,
с любыми двумя инструкциями.
И, конечно же, процессор должен учитывать,
что он прервал исполнение вашего кода
в совершенно произвольном месте.
И он должен помочь этому коду потом обратно
на процессоре восстановиться.
Поэтому, когда в процессоре происходит прерывание,
то он, конечно же, сохраняет буквально
все регистры, которые там есть,
которые программа могла пользоваться.
Потому что программа не могла к этому подготовиться,
она этого вообще всего не наблюдает.
Компилиатор же не думает, что вот произойдет
переключение контекста сейчас.
В нашей ситуации, в случае файберов,
все будет гораздо проще, потому что наши файберы кооперативные,
они не могут вытесняться, они переключаются
только в строго определенных местах,
а не явно, вызывая свечту.
Вот это единственная точка переключения.
Она всегда явная и добровольная.
И мы собираемся этим фактом воспользоваться.
Мы не собираемся сохранять в свечту
вообще все регистры.
И тут можно вернуться к примеру, который был в годболте.
Вот у вас есть функция foo,
которая вызывает функцию bar.
Она по себе может быть сложно устроена,
она там может алоцировать что-то на стэке, какие-то вычисления,
производить... Компилиатор разложит эти вычисления
при регистрам, а потом мы вызываем функцию bar.
А функция bar вообще может быть частью библиотеки
и скомпилирована быть отдельно.
И компилируя foo, компилиратор ничего не знает
про устройство bar, и компилиратор компилируя bar
ничего не знает про то, что эту функцию будет
и функция bar, если так наивно рассуждать очень,
могла бы взять и перезаписать,
переиспользовать все регистры, на которые полагалось foo,
и когда мы вернемся в вызов foo, то
состояние нашей функции
будет разрушено.
Вот, конечно же, такого не происходит.
Если мы вызываем одну функцию
из другой и мы компилируем их независимо,
то мы должны, мы хотим ожидать, что
после завершения функции bar все-таки регистры
процессора окажутся в каком-то предсказуемом
состоянии. И вот
эти ожидания зафиксированы в документе,
который называется Scrolling Conventions, соглашение о вызове.
И что нам из них сейчас интересно?
Интересно то, что, разумеется, функция
foo вызвана, функция bar вызвана из
функции foo может использовать какие-то регистры,
может их переиспользовать, перезаписать.
Но соглашение
о вызовах регламентирует, что
часть регистров, функция bar
после своего завершения обязана
вернуть в исходное состояние,
которое эти регистры имели до вызова.
То есть либо не трогать их вообще, либо
хранить на стэк, а потом обратно намазать
на процессор. Эти регистры называются
call-saved-регистры.
Разумеется, соглашение о вызовах
и call-saved-регистры,
конкретное соглашение о вызовах,
все это фиксировано для
конкретной операционной системы, для конкретного
процессора. Но вот мы все-таки говорим
не про библиотеку, которая будет работать
на любой операционной системе, на любом процессоре, мы говорим
про нашу конкретную библиотеку, которая должна работать на
линуксе и на процессоре с
архитектурой x86a4, поэтому мы
используем конкретно вот эти соглашения
о вызовах. Они говорят, что после вызова
функция bar обязана сохранить регистры r12, r15,
rsp, rbp, rbx.
Это касается
просто вызова функций.
Вот, ну и компилятор же, он когда компилирует
этот вызов функций, он мало что, то есть он не знает,
что эта функция сделает что-то магическое.
Но он ожидает, что после
вызова функции switch2-fiber,
там switch2,
вот эти регистры,
вот эти регистры перечисленные
должны находиться в неизменном,
в исходном состоянии, которое они имели до вызова.
Вот на этот вариант
будет полагаться компилятор, когда он будет компилировать
вот метод step, метод switch2-fiber.
Понимаете меня, да?
Так что мы должны сохранить
только перечисленный набор регистров.
Вот мы их сохраняем, после чего
мы трогаем rip, instruction pointer
и перемещаемся в другую точку программы.
Но,
смотрите, очевидное замечание,
написать такой код на C++ невозможно, потому что мы
манипулируем регистрами процессора, в C++ мы не умеем
манипулировать регистрами процессора.
То есть реализация switch2 будет ассемблерная.
Кроме того, вторая сложность.
Вот действительно мы можем
сохранить регистры с процессоров памяти,
просто скопировать их, а потом намазать другие регистры.
Но так мы можем сделать
почти со всеми, кроме rip.
Вот с rip мы трогать напрямую не можем.
Но когда я показывал вам
вот здесь вот код,
то я говорил, кто трогает rip.
Вот инструкция red, она трогает rip.
Она снимает
с вершины стека адрес, записывает
его в регистр rip и
вот процессор прыгает
по этому адресу. Вот это тот способ, которым
мы можем регистром rip instruction pointer манипулировать.
Итого, значит, мы
пользуемся тем фактом, что у нас
файберы кооперативные, что они переключаются только добровольно.
Поэтому мы здесь должны позаботиться только
о части регистров, о call и save регистрах,
которые зафиксированы в соглашении о вызовах.
И вот второе наблюдение, что мы должны как-то
аккуратнее быть с rip.
Не то, что аккуратно, некорректно говорю, что мы должны как-то
по-особенному его поменять.
Ну и давайте посмотрим, наконец, как это
реализовано. Вот я показывал вам класс execution
context. Он на самом деле не так-то прост, потому что
execution context это не только регистр процессора, это еще
состояние санитайзера, это еще состояние механизма
исключений, но под капотом
контекст процессора, он в библиотеке
называется машинный контекст, у него есть такой же
свечту, и вот на этот свечту мы сейчас
и посмотрим.
Это assembler-ная функция.
И давайте даже я не ее буду показывать,
а сначала покажу картинку,
о том, как она работает, а потом мы переместимся
в assembler-ный код.
Итак, мы хотим написать функцию
переключения контекстов, и у нас есть два аргумента,
контекст, в который мы должны сохранить состояние процессора
и контекст, который мы хотим активировать.
Вопрос, куда мы сохраним
регистр процессора?
В какую память? Но можно подумать, что прямо
в объект контекста. На самом деле нет.
Регистр процессора, который нам нужно сохранить, вот эти call и save
регистры, мы сохраним в память,
который точно можно безопасно пользоваться,
с которой никто не будет работать.
Нет, stack.
Вот мы уходим со стека.
Мы планировщик, переключаемся в файбер.
Мы планировщик, исполнялись на стеке операционной системы.
Мы переключаемся на исполнение кода
файбера на его стеке.
Так что стек планировщика,
стек, простите, стек планировщика, стек потока,
на котором была вызвана функция runsheduler,
использоваться не будет, пока мы в планировщик не вернемся.
Поэтому мы сохраняем все вот эти
call и save регистры прямо на стек потока,
с которого мы уходим.
Но вообще, чтобы попасть
в эту процедуру switch-машин-контекст,
мы же должны ее вызвать.
Так что ее исполнение начинается с инструкции call.
А инструкция call по своей семантике сама сохраняет
следующую за инструкции call адрес,
следующий за инструкции call инструкции, простите,
на вершину стека.
То есть когда мы вызываем эту процедуру первым шагом,
при ее вызове, собственно, при исполнении инструкции call,
и очередная инструкция после call сохраняется на стек.
То есть это произошло неявно при вызове этой функции.
После этого у нас есть стадия,
когда мы сохраняем,
аккуратно скажу,
в процедуре переключения контекста два больших шага,
мы сохраняем состояние текущего исполнения,
это стадия save, и мы активируем
следующего очередного исполнения, шаг activate.
Вот save, первый шаг,
половина save, это сам вызов функции.
Вот на этом шаге мы уже кое-что сохранили на стек.
Адрес возврата.
После этого мы пушим на стек те регистры,
которые мы хотели сохранить,
call и save три регистры, r12, r15, rbp, rbx, rsp.
Ну rsp мы не пушим.
С rsp у нас отдельная история.
Вот мы запушили вот эти все регистры,
кроме rsp, а дальше
мы хотим переключить исполнение.
И вот ключевой момент для переключения
стеков.
Мы делаем два мува. Мы сохраняем текущий rsp
в поле контекст.
Вот машинный контекст, сама структура,
в ней только одно поле, это rsp.
Вот достаточно его запомнить, чтобы
восстановить все остальные регистры, потому что
по этому поентру находятся совершенно стековызвы,
в котором сейчас свалены все остальные регистры,
которые нам нужно было сохранить.
Итого, первый шаг, это call сохранения rip,
потом шаги пуши сохранения call и save три регистров,
кроме rsp, а потом мы просто
сохраняем rsp в поле контекст,
ну то есть, по сути, мы сохраняем его
в поле файбера.
Вот сюда.
Ой, простите, вот сюда.
За это отвечает
вот эта строчка.
Мы двигаем текущее значение rsp
по поентру, на который указывает
первый аргумент функции.
А дальше мы выполняем симметричную работу.
Смотрите, тут все очень логично.
Дальше мы, наоборот, из памяти контекст
strig двигаем stack pointer в
процессор, после чего наш мир становится
красным. Вот тут синяя половина и красная половина
это мир синего stack и мир красного stack.
И вот после того, как мы сделали
вот этот move, мы знаем, что
на stack, который сейчас установлен,
видимо, лежат сохраненные регистры
rbp, rbx, r12, r15, причем именно в таком порядке.
Мы их
попаем со stack в обратном порядке,
разумеется, и говорим
red. И вот последний red
третьим шагом снимает адрес
возврата со stack и намазывает
его на процессор. И вот мы прыгаем в другое место кода.
Вот stack здесь, это такое
хранилище состояния, хранилище контекста. Нам нужно
всего лишь помнить один pointer для файбера
вершину его call stack.
Когда я говорю, что мы переключаемся в...
Простите, я немного завис.
Когда я говорю, что мы переключаемся в контекст
штрих, который ранее стоял слева и был заполнен,
вот о чем я говорю? Я ожидаю, что
если я вызвал такую процедуру в коде,
то, видимо, в контексте
штрихованном находится stack pointer,
который указывает на stack,
в котором уже ранее
кто-то сохранил все вот эти коди сейфт-регистры и
установил разумный адрес возврата.
И вот я здесь сохраняю текущее
состояние текущего исполнения на этот stack
и запоминаю rsp. И после того,
как я свои stack переставлю, попаду в красный мир,
то я со stack в обратном порядке все снимаю
и намазываю на процессор.
Можно вопрос?
Все же, если у нас stack всего 8 мегабайт,
учитывая, что
и пользователи внутри программы могут переменные
писать, и в целом глубина у нас может быть достаточно
большая, и контекстов много. Мы не боимся, что
эти 8 мегабайт закончатся?
Вопрос, кажется, к файберу у них не относится.
Во-первых, файбер либо остановлен, либо работает.
Сколько мы потратили какие-то
совсем крохи на этом stack?
Ну, файберов у нас теоретически может быть много.
Во-первых, никто не мешает тебе заводить stack для файберов
любого размера. Почему 8 мегабайт? Можно заводить,
ну, не знаю, можно гигабайтные stack и малацировать.
А, или это другой stack? Это не тот же stack, который...
Нет, это stack вызова файбера. Вот этот stack, вот он.
Вот он.
И не понимаю, при чем здесь
файбер. Ну, то есть потоки, файбер тут разницы особой нет.
Поток может переполнить stack, файбер тоже может переполнить stack.
Я в терминало не запутался просто, я
думал, почему stack они куча, а это вообще наш stack, а не
программный. Ну, я говорю аккуратно, я говорю close stack везде.
Это close stacks.
Можно тоже спросить? У нас уже контекст
должен быть уже потенциализированный, понятно, что мы,
когда нам приходит новая функция, мы там как-то распихиваем,
допустим, вот эти регистры R153.0
исполняем, вот. А про RIP
немного непонятно, потому что функция новая,
ну, нам придали лямбу новую, которую мы еще не разу не запускали.
Нам нужно в RIP ее фактически адрес дать.
И достаточно... Ты правильно все говоришь,
я понял, о чем ты спрашиваешь. Ты спрашиваешь про базу. Вот я говорю,
когда мы переключаемся в контекст,
вот здесь вот, то мы ожидаем, что он
заполнен чем-то разумным. Почему он заполнен? Потому что
ранее он стоял слева от switch2. Ну, вот, например,
когда мы говорим про планировщик, когда мы прыгаем в планировщик,
то мы ожидаем, что луп контекста заполнен, потому что ранее
этот луп контекста,
в него был
сохранен контекст потока, который исполнял
франшедулер вот здесь, в этой строчке.
Но когда мы первый раз переключаемся на файбер, то, кажется, у нас проблема,
потому что первый файбер еще ни разу не запускался,
у него ничего разумного нет. Но в этом случае,
при первом запуске файбера, это разговор просто на семинар.
Мы должны заранее для него подготовить стэк вызовов,
то есть привести его к такому виду.
Просто руками построить.
Для того, чтобы в первый раз он смог заработать.
Я последние слова скажу буквально, это важно,
мы не проговорили их, мне кажется, стоит
полезно понимать тоже. Вот смотрите,
вы запускаете файбер
вот здесь вот.
Он работает-работает и завершается.
Ну это же функция, да?
Просто функция. Компилятор ее скомпилирует
и в конце напишет инструкцию RET.
Что эта функция RET сделает?
Что эта инструкция RET сделает?
Вот. При виде инструкции RET
процессор снимает возврата со стэка и прыгает
по нему. Но с другой стороны, видимо, в корне
нашего стэка находилась лямбда, который файбер исполнял.
И если мы не постараемся, то при завершении
файбера просто процессор пробьет дно нашего стэка
и программа разломается.
Поэтому у нас два частных случая.
Во-первых, это старт файбера, когда мы должны
руками подготовить контекст исполнения на стэке.
А второй частный случай это завершение
файбера.
С завершением связана такая процедура,
которая называется трамплином.
Сейчас давайте этот сплит уберу.
Он, кажется, уже исчерпал себя.
Смотрите, когда файбер стартует,
он на самом деле стартует не с исполнения лямбды.
Он стартует с специальной функцией, которая называется
трамплином.
То есть, когда я готовлю файбер к запуску,
я заполняю его стэк так, чтобы при прыжке
при переключении в этот файбер
начала исполняться вот эта функция с некоторым
аргументом arg, в которой я передам каким-то образом
адрес текущего файбера, то есть this.
Это статическое, у него нет никакого this.
При старте файбера в эту функцию
передастся pointer на файбер, который хочет запуститься.
И вот эта функция, она
запустит уже
код пользователя.
Эта функция завершится, то есть, эта инструкция
red в вашей лямбде, она выполнится,
файбер выйдет из этого вызова.
А после этого он вызовет специальную функцию,
специальный метод планировщика syscall terminate.
И смысл его такой. Уйти
из трамплина, но больше в него не возвращаться.
Вот функция yield, это такая функция,
куда мы заходим один раз, выходим дважды.
А вот terminate мы заходим туда один раз, а выходим
никогда. Каким образом это достигается?
Ну, буквально, совершенно древиально.
Мы меняем state текущего файбера
на terminate и прыгаем в планировщик.
В планировщике мы выходим
из этого вызова,
возвращаемся в цикл, переходим в метод
диспетчеризации и видим, что если файбер
в состоянии terminate, то, видимо, он завершился
и нужно просто его разрушить.
Нужно освободить стэк, ударить файбер.
Ну, то есть, трамплин — это функция,
которая находится на дне
стека вызовов. Вот если мы посмотрим, например,
на пример со стэками,
запустим его,
то мы увидим, что
в корне стека, на дне стека лежит вовсе не
код пользователя, а лежит этот самый...
Ждем, ждем, ждем.
Лежит этот самый трамплин.
И когда этот трамплин
завершит вызов функции пользователя,
он вызовет terminate,
и исполнение навсегда покинет этот стэк.
Так что мы его не разломаем при выходе.
Ну что, я исчерпал время больше, чем должен был.
Вроде бы мы
разобрали то, что планировали,
разобрали переключение контекста, даже успели
поговорить про трамплины. Тут много деталей
осталось еще не разобранным, всякие интрузивности,
там локация стэков, синхронизация.
Ну вот это вы можете почитать сами, посмотреть,
прийти на следующий семинар, где вам об этом расскажут еще.
А в следующий раз мы поговорим уже
про то, поговорим про две важные вещи. Это будет
очень важная, мне кажется, рекция, новая в курсе,
которая не хватала. Мы поговорим, во-первых,
про те вещи, которые параллельными,
а во-вторых, мы поговорим, как их
научить делать что-то полезное, а именно
общаться с внешним миром.
Что спасибо за то, что пришли сегодня
в Zoom. Если остаются вопросы, то
мы, конечно, можем еще некоторое время продолжить.
Я отвечу на них с удовольствием.
На этой неделе тоже
домашнее задание, да? На этой неделе не будет.
Мы должны послушать еще одну лекцию,
где мы научимся делать файберы параллельными
и делать их, научимся выполнять
ввод-вывод в них, и после этого через неделю у вас будет
очередная домашняя работа, но уже большая и сложная,
и такая долгоиграющая.
А пока мы дорешиваем простые задачи про Кондвор и про Мютекс.
Хорошо, спасибо.
Еще про переключение контекста на армию.
Да.
Там сейчас оно режется, и я не знаю, почему.
Оно даже не депажится.
Но мне кажется, что это вопрос не для лекций все же.
Ну да ладно.
Ну тогда спасибо, до свидания.
Счастливо. Спасибо, до свидания.
