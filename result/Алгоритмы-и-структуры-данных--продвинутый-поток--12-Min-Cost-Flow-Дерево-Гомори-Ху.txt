так лайк поехали тогда уже ладно возможно сегодня придется ну это посидеть чуть подольше я
надеюсь не сильно подольше вот да да да да да так нет на этот раз нет вроде нет вроде все
нормально и тут вроде теперь лежат адекватные марки нет все вроде на этот раз хорошо так
лагика так что можете посидеть чуть подольше но пока бери пока им репа плана будет последние
занятия в семестре будет все ой ну мы не будет уже вот нет ну как бы предварительных а хотите
прям сразу сразу экзамен ноги нет ну прия ну в принципе как я уже говорил то есть
о каком-нибудь там скажет альтернативно даже не столько до сроки сколько альтернативного
времени значи экзамен можем договориться пожалуйста как я уже сказал это как бы и
сыква сколько угодно да вот ладно но давайте смотреть на чеченам сегодня удастся сделать так
ну начнем мы их наверное конечно с того о чем мы давно мечтали собственно поговорим о минкосте
вот тоже на самом деле не самая такая сложная вещь ну правда крыша минкост обычно да принято
считает такой алгоритм и сыква все знают как бы как вы да все знают как вы писать но мало кто
знает а почему он вообще работает ну вот или или уже все знают мои сведения устарели так кто
умеет доказывать минкост но так хорошо кто знает что такой минкост ну вот это как бы
да а бы я знаю вот нет вот нет это как бы нет известно да да да но там уже отдельная песня да
кто писал да кто писал минкос спит с потенциалами о да но мало ли но вот а кто писал минкос без
потенциалов вот логично да да а кто умеет доказывать нет хотя парадокс том что на самом
деле доказательства-то в общем-то не особо сложно значит смотрите ну давайте для начала сформулируем
задачу какая у нас вообще задача задача у нас заключается том что да мы все еще ищем вообще
поток казалось бы то есть тут как тут все как обычно какие-то ребра там у них пропускные
способности там есть вот все казалось бы тоже самое все да не все потому что теперь у нас помимо
пропустой способности появляется еще и стоимость то есть у нас тут совершенно внезапно выясняется
что оказывается пропустить пропустить машинку по дороге это оказывается денег стоит пускать
машину там машинку в единицу времени причем на каждой дороге еще и разные стоимости но там по
разному где-то есть платная дорога здесь как бы бесплатная ну так сказать там это там касать
сутки там вот это все вот иногда да иногда бывает бесплатная дорога
что нет пропускать способности есть а ну ой ну господи вот ну вот ну вот что еще бывает ну
бывает вообще ситуация когда стоимость отрицательная ну типа да это это я дорога я новая красивая
дорога я хочу по мне ездили я готова за это доплачивать нет ну или просто акция мало ли там
вот неважно и вот у нас задачи хочется найти максимальный поток но при этом сделать так
чтобы его стоимость была как можно меньше ну что такое стоимость потока ну да правда ну
могут быть и другие задачи бывают задачи вида возьми поток величины к минимальной
стоимости еще тоже вариант да ну соответственно стоимость потока ну давайте формально напишу это
конечно там перебираем серебра и говорим что это f от е умножить на ц это обретите внимание
до никакой остаточной сети я тут естественно не рисую хотя если я захочу нарисовать то как бы
даже понятно какие там стоимости будут да то есть если там стоимость будет номер 3 то то есть
я тут пропущу поток величины один какой-нибудь дата у меня появится обратное ребро пропускной
способности 1 и стоимости минус 3 логично а а ой а ой да да да да да да да вот да да но
она обычно косто называется да да да да да да да спасибо хорошо так это был кост но вот
теперь как это сделать но на самом деле мы эту задачу сведем к немножко другой задачи вы
будем искать задачи вы бы решать задачу о минимальной циркуляции да мы уже сталкивались
таким словом поэтому дай вспомнишь тоже такое циркуляция да то есть циркуляция в сети там
какой-нибудь это сложно в скобках нет это поток величины 0 на самом деле все вот то есть до сего
момента как бы у нас поток величины 0 ассоциировался ситуации когда ничего нигде не едет
вот ну в общем тогда действительно нам не принципиально была да потому что конечно
мы знаем мы теоретически знаем что любой поток декомпозируется на пути и циклы все-таки то есть
там вы вынуждены там для того чтобы поток был именно такой мы должны были сказать что какие-то
машины тут по какому-то по какой-то там круговой траектории есть вот вот но обычно нам это было не
надо потому что мы интересовались только максимальностью потока но в данном случае на
оборот даже если поток величины 0 то у вас то есть из зрения стоимости бывает выгодно машинку
пустить потому что оказывается что в данной сети конечно циклов нет вообще а так чисто
теоретически в общем-то какой-нибудь там цикл цикл какой-нибудь там отрицательной стоимости
в общем-то никто не он вот собственно никто не запрещал скажем так или даже вот так или вот так
вот такие подлянки бывают тоже вот то есть может вот вполне себе оказаться что да что вы выгода
чтобы машинка тут ездила и собственно там накручивала нам хорошую стоимость вот и вот
теперь у нас задача найти циркуляцию величины 0 как же это сделать циркуляцию до циркуляции
стоимости да да да да да все я уж совсем да и так как же это сделать ну во-первых
начнем с маленькой приятной те но вот с маленького приятного утверждения так ну на всякий случай
просто чисто для понимания то есть любую циркуляцию можно декомпозировать
в не более или на не более модуле циклов так ну есть пока не думаю что тут это открыл как
вот а по той же причине почему можно было декомпозировать на пути цикла то есть доказательства
там будет звучать так давайте тогда вспомним предположим что у нас есть ребро по которым
мы неожиданно что-то течет что такое циркуляция циркуляция такой поток в котором у каждой
вот
тут уже без вариантов мы зациклимся то есть вот мы нашли цикл ребер по каждому из которых что-то
что-то не нулевой течет. Ну так давайте вычтем один, то есть запишем этот цикл в декомпозицию с величиной
минимума из этих потоков и вычтем из него. Вычтем его. Одно из ребер обнулится. Ну хотя бы одно.
Все. Повторяем эту операцию не более, чем 0 раз и обнулим все. Вот такая вот. То есть в общем-то
декомпозиция на пути и циклы решалась почти так же. Вот. Да. Тут все просто.
Чего? Не в данном случае нет. Когда мы говорим об этой декомпозиции, мы на обратные ребра не
смотрим вообще. То есть мы смотрим только вот так сказать на физи. То есть как бы смотрим только
на то, что у нас по факту есть. То есть напоминаю. То есть у нас остаточная сеть это какая-то там наша
абстракция. То есть как бы условно какая-то там. То есть в реальной жизни обратных ребер не существует.
Ну вот. И вот этих вот машинок, в которых вот эти вот дорог пропускная способность 0,
но по ним течет минус 2. Поэтому вот это все-таки это как бы. То есть это как бы,
собственно скажем так. Называется там больная фантазия, собственно, электропомотоанализа.
Ну мы это уже обсуждали. Да. Вот. И так. Ну это утверждение в общем-то про стоимости ничего не
говорит. Это я пока просто так, чтобы немножко включить интуицию на тему циркуляции. Вот.
Правда, про стоимости здесь я вообще ничего не говорил. Хотя я мог бы, конечно, сказать,
что стоимость, скажем так, суммарная стоимость каждого цикла, ну взвешенная на f, это, конечно,
равна стоимости циркуляции, но это сложнее сформулировать, чем понять о чем речь.
Вот. Но более полезной на самом деле бывает такая. Давайте так. Введем тут вот определение. Давайте
введем, потому что тут, конечно, можно запутаться. Определение. То есть циркуляция. Давайте скажем,
что циркуляция минимальна, если ее стоимость минимально возможна. Среди всех вообще циркуляции
в этой сети. Среди, давайте так и запишем, всех циркуляций в сети. Вот так цирк в сети. Да.
Вот. Вот. Значит, это у нас такое определение. И введем еще такое. Давайте такую терминологию
введем. Циркуляция. Вот мне почему-то нравится слово считание. Локально оптимально. Локально
минимально. Ну вот. Ну или еще иногда там бывает термин оптимально. Если вот на этот раз остаточной
сети нет цикло отрицательной стоимости. На не нулевых. На не нулевых. На этот раз придется
тоже подчеркнуть по пропускной способности. Вот. Ну логия. Ну вот. Ну откуда берется локальная
оптимальность? Потому что давайте подумаем. Можно ли уменьшить вес циркуляции? Давайте посмотрим,
давайте посмотрим. Допустим, мы там случайно нашли цикл отрицательной стоимости. Тогда,
наверное, вдоль этого цикла можно пустить машинку. Ну или там даже несколько машинок. И
также, тем самым уменьшить циркуляцию. Поэтому. Ну да. Но я предпочитаю называть локально минимально.
Но не совсем. Ну и что? Ну в остаточной сети
естественно добавляем. На то это определение остаточной сети не поменялось. Стоимость
обратного ребра равда минус стоимости исходного ребра. Ну естественно. Ой,
боже. Зачем? У нас уже есть полный порядок. Извините. Спокойствие. Так вот. Поэтому да,
становится. Поэтому. Ну вот. Поэтому, конечно, простое утверждение. Можете сказать, что циркуляция
минимальна. Ну точнее так, если циркуляция минимальна, то она локально минимальна.
Вот. Вот. Казалось бы, это утверждение очень кажется даже недостойно вот этой
вот буквы Т, которую я тут написал. Ну как-то думаю. Но как бы, мы только что уже проверили,
что если она не локально минимальна, значит давайте по этому циклу отрицательной стоимости
проведем машинку и станет меньше. Вот. Да. Но почему это отрицательная? Да. Терема заключается
вот в этом. Да. Оказывается, да. То есть практически, на самом деле, это очень похоже на терему
Форда Фолкерсона, на самом деле. Ну, пока и без разрезов, которые. То есть просто у нас поток
максимальный тогда и только тогда, когда в остаточной сети нет улучшающего пути. Вот. Поэтому я,
в общем-то, и была мысль, на самом деле, Минкоста обсудить сразу, потому что суть, на самом деле,
та же. Да и доказательства очень похожи. Нет, доказательства не похожи. Но доказательства,
на самом деле, сильно проще, чем кажется. Просто доказательства звучит так. Предположим,
то есть жила была циркуляция F, не минимальная. Ну, допустим. Ну, как бы, как кому удобно. Можно
вводить себе там от противного, можно не вводить. И, допустим, выяснилось, ну вот, есть циркуляция F
штрих. И выяснилось, что стоимость F штриха строго меньше, чем стоимость от F. Тогда, смотрите,
в остаточной сети относительно циркуляции F, тогда есть такая замечательная циркуляция,
как F штрих минус F. Ну, типа, шо надо пустить, чтобы превратить F в штрих. Ну, где-то отменить,
понятно, где-то включить. Логично, да? Ну, я сейчас в качестве упражнения ставлю формальные доказательства
того, что это как бы корректная циркуляция. Что это циркуляция, она не нарушает какие-нибудь
пропускные способности, там бла-бла-бла, но я думаю, это более-менее очевидно должно быть.
Еще нет? Нет, ну скажем так, интуитивно понятно, что такое F штрих минус F по каждому ребру?
Ну, но инварианты того, что сколько втекает, сколько вытекает, это так же.
Так, неравенство на C-шку. Ну, тут смотрите. Нет, тут становится все очевидно, если мы распишем,
а какие пропускные способности у нас тут в остаточной сети. Ну, потому что давайте,
что в остаточной сети у нас, напоминаю, как бы есть у нас, то есть помним, что если у нас в сети G было
какое-то ребро, в котором течет, допустим, там сколько там F из C, то у нас появляется,
ну вот, то в GF у нас появляются два ребра. Появляется вот ребро с пропускной способностью C-F и
обратный ребро с пропускной способностью F. Ну вот, теперь возникает вопрос, можно ли пустить F штрих
минус F, то есть в этой вот сети. Да, мы знаем, что можно было пустить F штрих из C, допустим,
вот по этому ребру можно было пустить F штрих из C. Вот, но тогда у нас получается, что F штрих
меньше либо равно C, это по определению F штриха, но тогда автоматически из этого следует, что F
штрих минус F меньше либо равно, чем C минус F, потому что трава зеленая. Я не умею объяснять,
почему трава зеленая, да. Вот, но поэтому, ну вот, ну вот, ну вот так, но это означает,
что по этому ребру все в порядке. Есть, конечно, еще фишка, что вот по этому ребру может еще что-то,
соответственно, по. Не было, нет, но вот нет, фишка в том, что нет, здесь-то она, нет,
почему? Нет, просто нет, вот у этой циркуляции, как бы здесь по этому ребру, что-то потечет с целью
отмены. Вот, причем более того, что-то потечет, но это что-то как бы F превосходить не будет.
Ну вот, ну давайте так, там будет два варианта, если F штрих больше, чем F, то как бы этот поток
будет здесь, а здесь отменяться ничего не будет. Нет,
нет. Нет, но на самом деле... Нет, у нас отрицательный поток бывает, ну опять, бывает как минимум,
потому что у нас есть обратные ребра, и когда у нас появляется обратный, то есть, как бы виртуально,
мы все равно можем тогда хорошо вот мыслить терминок что тут обратные ребра типа есть просто
метод пропускная способность 0 а течет по нему минус f допустим да вот остаток сеть мы вот ставим
но отставим так и в этой сети остается только там про но здесь течет там f минус f штрих здесь
мы как раз пользуемся тем что и в штрих больше нуля но больше либо равно но вот поэтому как бы
то что здесь течет получается остается все в порядке ну ну вот на таких вот ребра
нет но это просто нет скорее способ мышление но там нету можно бы нет ну как бы нету может нет
просто тут фишка такая просто когда мы тут вводим поток но то есть когда мы вводим поток
в остаточной сети мы говорим что два давайте во-первых есть у нас тут по вот этим ребрам и туда
и туда течет поток давайте там то что вообще отменим и тогда у нас либо поток сюда идет то
есть это дополнение к этому либо идет поток сюда это типа вот отменяем вот то есть как бы мы
хотим чтобы поэтому ребра течет текло там минус 2 единицы потока для этого мы вводим здесь 2 единицы
поток ну вот ну со всеми определениями тут все сходится вот так шокаря но вот но это скажем
так это скорее так называть это что-то формалистическая но та суть одна то есть как бы в 4 минус f это
то что надо пустить чтобы текло у нас в сети не f а f штрих но теперь смотрите какая ситуация и
очевидно причем на костот f штрих минус f но он очевидно равен костот f штрих минус костот f
и автоматически это означает что это меньше нуля то есть вывод у нас в нашей сети есть существует
циркуляция отрицательной стоимости да казалось бы например из этого казалось бы еще не следует что
есть цикл отрицательной стоимости ну пока мир на уровне совсем очевидно пару предложений в
доказательства добавить придется да а пара предложений звуки нет а пара предложений будет
такая ну хорошо давайте возьмем эту отрицательную циркуляцию и декомпозируем ее на циклы как-то есть
же подозрение что хотя бы один из этих циклов окажется отрицательным вот да есть наверное где-то
там такое утверждение не знаю в каком правда не знаю почему-то в школьной программе нет такого
утверждения что если у вас есть там если у вас есть сумма там конечного числа величин и она
отрицательна то одна из этих величин отрицательно ну там аккуратно надо да ну да то есть да нет
логично да что если она да если да ладно да есть сумок да если сумма сумма какого-то ряда
стремится к чему-то отрицательному значит наверное хотя бы один элемент этого ряда отрицательный да
да да даже даже в принципе и так да действительно вот как-то но так что вот такое ну в общем-то
ну так то очень все доказательства кончено все мы проговариваем мы уже это проговаривали то что
если лока минимально то то есть мы уже там перед формулевкой церемы проговаривали
поэтому там все нормально ну вот так что мы все сделали мне все спокойно вот ну и
теперь собственно вот нет это в общем-то и порождает алгоритм на самом деле то есть алгоритм
вида а как собственно теперь это искать но правда конечно приятно не очень
нет упаре скажет а пока будем искать циркуляцию честно скажу дай это не самый лучший алгоритм
который вообще в мире существует да забегай вперед в мире в мире существует алгоритм
который зависит только от ве вот а мы сейчас будем зависеть от пропускной способности боль того
будем еще и жестко пользоваться тем что они целые ну ладно жесткость конечно относительно но тем
не менее так смотреть потому что идея будет такая вот потому что что мы будем алгоритм будет
устроен так мы изначально удалим из графа вообще все ребра а потом думаю будем добавлять ребра по
одному прямо по одной пропускной по единичной пропускной способности и пытаться там что-то
там модифицировать так чтобы в остаточной сети цикла отрицательной стоимости не было вот теперь
если это как мы будем проверять что цикла отрицательной стоимости нету вот но вот вот это
называется еще один вот то есть еще один момент почему это надо было делать вот собственно еще
тогда не сейчас вот жалко что но вот пуша пуша были эти золотые времена когда мы с вами обсуждали
потенциалы джонсона ну перейду переставия да ну это уже другое но как бы да ну как бы да ну как бы они
сразу концептуально как-то снимали сначала эпизод 5 там потом ну почему нету просто там типа
нет видимо нет изначально не просто сняли эпизод 5 типа шоу типа мы сразу вас окунаем шоу типа
война уже идет они просто там они до 4 ну вот ну вот ну вот ну вот ну тем не менее
давайте вспоминать потому что как бы помним мы значит потому что мы введем соответственно потенциал
то есть шутка это сейчас потенциал это просто какая-то функция на вершинах просто вот какое-то
мистическое число и мы знаем что приведенная стоимость у нас будет то есть кост с индексом
допустим е она равна чему она она просто равна обычной стоимости ребра только плюс потенциал в
начале минус потенциал в конце да приятность заключается в том давайте сразу сфорулирую
утверждение что для любого цикла там для любого цикла как цикл-то обозначить ро верно что
приведенная стоимость этого цикла равна обычной стоимости цикла так но это вроде должно быть
очевидно да вот ну то есть не хочется просто второй раз и шлёп шлёп и писать вот думаю не
так уже понятно вот чему это нас приводит так ну приводит нас к это следующему но давайте
сразу пишем на что определение потом вот что у нас наш потенциал п потенциал п не отрицательный
там если для любого е
ну да просто а ну ладно ладно лиси но для сети же будем говорить на счет да хотя но тут просто
важный момент да приведенная стоимость оказывается больше либо равна нуля но просто
единственное что нам конечно будет требоваться чтобы потенциал был не отрицательный в остаточной
сети вот потому но то есть идея у нас собственно отсюда и будет то есть мы будем то есть нам это
очень удобно да вот раньше мы пользовались этим потенциалом чтобы искать кратчайший путь не
фордом белман а дэкстрей ну дэкстрату побыстрее работает вот но вот здесь мы попытаемся делать
здесь вот мы попытаемся делать пример то же самое мы будем следить за тем чтобы все не нулевые
ребра в остаточной сети были не отрицательные относительно нашего потенциала в случае чего
потенциал под шо ма ни понятно да вот как же мы это будем делать ну как я сказал будем
добавлять ребра по одному и поддерживать в каждом момент времени у нас есть уже какая-то циркуляция
какой-то потенциал и нам гарантируется что в остаточной сети все не нулевые ребра имеют
не отрицательную стоя приведенную стоимость это вариант такой это я тогда вот так вправывается
вот спрашивается что дело значит если появилось новое ребро вот прит изначально да скажем ну
поболе изначально вообще кайф да потому что изначально у вас просто куча вершин не одного
ребра вводи любой потенциал и радуйся а теперь значит приходит новое ребро прописной способности
один и какой-то стоимость так но давайте сразу проверим если это ребро относительно уже имеющегося
потенциала не отрицательно то в общем-то делать ничего не надо мы уже победили правда так кстати
обратите внимание маленький приятный момент в каждый момент времени мы поддерживаем минимальную
циркуляцию нет пока не надо если если приведенная стоимость относить уже имеющегося потенциала
сразу оказался не отрицательной то мы победили то есть уже ничего делать не надо ну ладно давайте
нет но все проблема ну утверждение ну утверждение такое что если если есть не отрицательный
потенциал значит циклов отрицательной стоимости нету ну все поэтому как бы вот поэтому если вы
вот то есть у нас да да у нас у нас в варианте прописано что как бы у всех существующих там
ребер пока мне не нулевых там приведенная стоимость не отрицательна если вы добавили
ребро и у него приведенность тоже оказалась не отрицательная ну значит поздравляю циклов
отрицательной стоимости не появилось но вот когда парадокс том что нет но знания
ну точнее так алгоритм может показаться не тривиальным в принципе там поиск там потенциала
джонсона поиска тоже считается не следом одним из не тривиальных алгоритмов там по всем даже может
программируем и его даже редко использует обычно почему-то но на самом деле тут просто если
вы математически просто пропишите что такое потенциалы когда вы каким образом им пользоваетесь то
на самом деле все сложного нет то есть это просто вот просто это это называется просто включите
формального математика это не все программисты любят его включать но что поделать то есть у нас
к сожалению нет этого потом по принципу это электрической студии там это когда как там говорят
этого вот вы теперь просто до вот включился будильник вы простоли си можете делать утренняю
гимнастику многие люди не любят делать утреннюю гимнастику наша фирма это учла наш электрический
пояс мастирует вас самым добросовестным образом да на полном серьезе реклама 35 года в чем очная
они поэтому вашему телевизору да ну да ну потому что нет это просто это опять же ильфы петров
одноэтажная америка то есть они там они попали в электрический там были там просто попали в так
называемый электрический домик мистер рипли но там мистер рипли это в общем видимо человек
отвечающий за рекламу собственно там в джейл электрик ну вот и там просто вот реклама типа вот
там о какая у нас радость это отдельная песня там конечно вот так вот что делать если у нас
все-таки стоимость оказался отрицательна ну значит надо то ли поток что-то пустить то ли
потенциал перепилить начнем с того что перепилим потенциал как мы это сделаем значит если вот это
ребро в то давайте найдем значит смотрите д от x это будет кратчайший расстояние
ну по стоимости ам имеется ввиду по косто от именно вершины в до вершины x в значит остаточной сети
вот так что-то все прописываю но ладно поня нулевым ребрам
вот как это да как-то д от x найти ну элементарно для этого мы просто найдем
ведем понятие д с индексом п это абсолютно то же самое только приведенное естественно расстояние
нет д с индексом п вот ну что делать потенциал п называется да можно было его вести конечно
но но я думаю себе тут начал рисовать твердые знаки я думаю там понятие бы не стал вот так вот
значит ну и в принципе да если мы ну такое с помощью кунь д экстрима найдем да но можно
принять пенни с помощью д экстрима что форда был потому что что приятно потому что нам гарантировал
потенциал потенциалом гарантировал что по крайней мере без вот этого ребра отрицайков отрицательной
стоимости не значит корчейшие пути определены можно их искать так или иначе да да ну скажем так
у меня просто в голове нет понимания а как это еще можно понять сказано выше контексте да имеется
в виду конечно что имеется только ребра которые мы добавили да да более того мы не учитываем это
ребро да мы знаем что без этого ребра циклов отрицательной стоимости нет а с этим ребром может
и есть так вот будем искать так в чем это можно в алгоритме так себе и прописать давайте найдем
прямо расстояние приведенное потому что вот д экстрим можно найти да а потом так жественно
заявим что что такое д от икс это банально d p от икс но д с индексом п хорошо д пт вот
так только плюс п от в минус п от икса бреда то есть п от в вполне ну п тв вполне может быть не
потому что мы в рандомное место ребра вставляли да вот то есть вот просто то есть
получается надо то есть запустили д экстра потом просто пробежались фориком прописали вот это то
есть мы честное расстояние так вот вводим новый потенциал п штрих от икс присвоить соответственно
вот этот вот д от икс чем приятен такой потенциал он приятен тем что для всех ребер кроме вот
этого он все еще не отрицательный почему так ну потому что для любого ребра какого-нибудь
икс игрок и там какой-нибудь там стоимости кост но очевидно что п штрих от икс плюс кост минус
п штрих от игрок должно быть больше либо равно нуля почему потому что п штрих от игрок это
кратчайшее расстояние до игрока а п штрих от икс плюс кост это длина какого-то пути то есть
длина кратчайшего пути длина какого-то пути вычли возрадовались ну в общем как бы заклинание мы
уже произносили вот так ну казалось бы зачем мы-то да да да перепутали ой да мы мы все перепутали
да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
да да да да да да да да ну да кочмана скажу Austrian
Кошманов сказал, что и такую бессмысль такую бессмыслительную
чепуху не может управлять космическим кораблем мне
нехорошо.
Да тут вся невесомость моя, хочу и заберу управление,
ну и забирай, а я отключу управление.
Дай такое внимание, начинаем потение на Луну.
Вот.
Чего?
Да.
Ой, у сын Дука много чего есть.
Ой, это да.
Ой, ну если мы сейчас сын Дука, то чего бы обсуждать?
Нет, ну нет, сначала будет нормально, сначала будем читать стихи,
потом будем вспоминать про сначала Незайка на Луне,
потом про Спокойной ночи малыши и шнура, что там потом дальше,
а потом про поле чудес, естественно, да, да, да.
Ладно, это долгая история будет.
Так вот, Жил был с потенциалом, заказал то, что мы сделали,
у нас был неотрицательный потенциал, мы заменили его
на другой неотрицательный потенциал.
И то с проблемами, кстати.
Потому что вытекает вопрос, а что делать, если до каких-то,
от вершины В нельзя дойти до вершины Х, по имеющимся ребрам.
А такое бывает.
Бесконечный потенциал?
Нет, ну этого не хотелось бы.
А то вот приходит тут ребро, а тут бесконечность, бесконечность.
Ну не совсем так, конечно.
Да, есть одна маленькая подлянка.
Вы, конечно, дойдете от вершины В куда-нибудь, вот сюда,
но вот и введете новые потенциалы, но у вас тут будут вот такие ребра.
И если вы тут введете слишком большой потенциал,
то вот это ребро может стать отрицательным.
Да, то есть заметим, да, идея, конечно.
Идея понятна, что нужно просто взять все вот эти вершины
и увеличить или уменьшить их потенциалы на одну и ту же величину,
чтобы все эти ребра стали не отрицательными.
Ну как угодно.
Я бы сказал так, переберем все ребра, то есть переберем вот эти ребра,
найдем самые минимальные.
Если оно не отрицательное, то все нормально.
Если оно отрицательное, то равно, скажем, минус Вася,
то значит прибавим Вася ко всем вершинам.
Да, то есть понятно, конечно, вещь простая,
но просто надо обратить внимание, что об этом надо задуматься.
Это генту линукс.
Это надо сделать.
Так вот, хорошо.
Ладно, хорошо справились.
Но все равно мы просто ввели еще другой не отрицательный потенциал.
Зачем мы это сделали?
А сделали мы это вот зачем?
Найдем, значит, просто как понять вообще через это ребро
проходит цикл отрицательной стоимости или нет.
Надо, наверное, найти кратчайший путь от В до У.
Ну, который был раньше.
Да, мы его даже нашли, он у нас теперь равен до У.
То есть он, конечно, и есть.
Спрашивается.
Ну вот, теперь спрашивается.
Если у нас относительно этого потенциала П штрих
у нас теперь вот это ребро стало адекватным,
то в принципе все больше еще делать не надо.
Но что делать, если это ребро относительно нашего потенциала
стало отрицательным?
Тогда идея такая.
А давайте-ка возьмем вот этот вот цикл,
кратчайший путь и это ребро,
и пропустим по нему поток.
Упс.
Ну, смотрите, что произойдет.
Ну, заметим, что вот это ребро убьется,
а вот это ребро с положительной уже приведенной стоимостью,
оно появится.
Но проблема в том, что, казалось бы, появятся еще вот эти все ребра.
И у них тоже, раз у этих приведенная стоимость была положительная,
могла быть положительная, значит и у этих ребер
приведенная стоимость должна стать отрицательной.
Что же делать?
Вот картинка ответа тоже у нас где-то была.
Наверное.
Но проблема в следующем, что когда вы тут пустили поток,
то вот у вас были, допустим, положительные ребра какие-то,
относительно приведенной стоимости,
вместо них появились обратные,
но не вместо, а просто появились обратные.
И тогда у этих обратных отрицательная приведенная стоимость.
Как оно вот?
То есть это убили, а тут как бы...
А вот тут мы жестко пользуемся тем, что у нас сеть целочисленная.
Сеть целочисленная, и мы ребра добавляем по одной пропускной способности.
Да, вот ровно в этом месте мы этим жестко пользуемся.
Вот.
Ну, идейно возникнет.
По факту нет.
Да, потому что утверждение такое.
Зачем мы ввели этот новый потенциал?
А ввели мы его затем, чтобы относительно этого потенциала у всех тех ребр,
приведенная стоимость была ноль.
Нет, ну действительно, смотрите.
Рассмотрим x и y.
Так, у него приведенная стоимость вот тут.
PS штрих от x
плюс кост
минус PS штрих от y.
Только фишка в том, что на этот раз, да, это больше либо равно нуля, да-да-да,
мы знаем, это кратчайший путь, это какой-то путь.
Но теперь заметим, что это не какой-то путь, а тот же самый кратчайший.
Поэтому получается, что это равно нулю.
Может быть, ровно за этим мы этот потенциал вообще ввели,
чтобы была вот такая фишка.
Так что получается теперь.
То есть получается, вот мы нашли такой путь, и, соответственно, если нам надо,
то, соответственно, пропускаем цикл.
Тогда новых отрицательных ребер не появилось, а старое убилось.
Собственно, ура, процесс модификации завершен.
Так что в науке в этом месте возникает словосочетание метод Клейна.
Не знаю, вот этого товарища с экзотической бутылкой или еще там какой-то.
Соответственно.
Ладно, кто не знает, узнаете на топологии.
Нет, это не метод бутылки.
Если человек изобрел бутылку, это не значит, что бутылка изобрела все остальное.
Нормальный алгоритм.
Слушай, «Форт Волкерсон» с этого начинали.
Ну ладно, не с этого.
Но то есть на самом деле суть очень похожая.
То есть да, он там работает, он, конечно, за какую-то там…
Нет, ну смотрите.
Нет, ну смотрите.
Да, но тут метод Клейн, он там работает за какую-то там асимптотику мерзкую.
Да, сумма пропустой способности умножить на дэйкстру.
Да, по сути он работает.
Ну и дэйкстру, ну за сколько вы там напишете.
Так, ну как бы мы с вами на курсе, продвинутом курсе алгоритмов,
поэтому дэйкстру мы пишем за E плюс В лог В.
Не, я знаю, да-да-да.
Ну да, в ДЗ вообще нет заданий, да, почему-то в ДЗ нет заданий на дэйкстру.
Это дэйкстру с кучей фибоначи.
Ну почему-то когда-нибудь, когда E и В будут достаточно большими, она станет круче.
Нет, это понятно, да.
Да, поэтому это мы домножаем на сумму в сердцешек там.
Вот и радуемся.
Так что в принципе вот такую циркуляцию можно найти теперь.
Теперь надо найти мент-кост.
Как найти мент-кост?
Ну, что?
Ой, я еще и скобку не закрыл, господи.
Мы никогда не найдем мент-кост.
Так, еще и скобку не закрыли.
Значит, смотрите, как формулируется обычно мент-кост.
Ну обычно задача мент-коста формулируется так.
Дона сеть.
И скорее всего все ребра в ней не отрицательны.
Да, а вы что, видели задачи, в которые было что-то другое?
А, да.
Да, господи.
Да?
Да нет, на самом деле не исправит особо.
Просто подавляйте большинство задач обычно.
Ну скажем так, ладно, давайте можем потребовать, можно сделать там более слабые условия.
Как бы нет циклов отрицательной стоимости.
Я еще не помню ни одной задачи, в которой надо было реально циклы отрицательной стоимости искать.
Ну, по крайней мере, чтобы в исходной сети они были.
Но обычно там, по-моему, даже отрицательных стоимости как-то колышки нет.
Теперь вот, представим себе, дана сеть.
То есть дана какая-нибудь сеть.
На этот раз обычная сеть.
Какая-нибудь вот такая.
В ней какие-то есть выпустые способности.
И допустим, в ней, как бы там, давайте сейчас, для простоты давайте скажем, гарантируется, что кост от всех е больше либо равен нуля.
И нам нужно найти максимальный поток минимальной стоимости.
Ну, в науке как бы это называется обычно mean-coast-max-flow.
То есть максимальный поток, стоимость у нее должна быть минимальной возможностью для всех максимальных поток.
Как эту задачу свести к циркуляции?
В остаточной сети максимального потока.
Нет, как бы, да, самое смешное, что туда так тоже можно.
Давайте найдем просто какой-нибудь максимальный поток.
Но заметим, что любые два максимальных потока отличаются на циркуляцию.
Поэтому давайте в остаточной сети от максимального потока найдем минимальную циркуляцию.
Да, так можно.
Но не самым удобным способом.
Потому что как бы потом, но вот, потому что на самом деле можно, но вот, просто можно сделать это сам, можно с самого начала на самом деле свести задачу просто,
просто чуть-чуть модифицировать сеть и в ней найти соответственно уже циркуляцию.
Смотрите, идея такая, то есть на самом деле будет идея следующая.
Мы добавим еще одно ребро из TWS.
Ну что такое поток?
Это когда у нас вода из ниоткуда приходит в С и уходит в никуда в Т.
Но при этом и мистическим образом из ниоткуда приходит столько же воды, сколько потом уходит в никуда.
Так, ну давайте эти ниоткуда и никуда соединим ребром.
Ну получается, да, то есть там действительно бесконечные пропускной способности и какой-нибудь полуминус бесконечной стоимости.
Это не стоимость, это пропускная способность.
Но для того, чтобы нам было, чтобы нам было там допустим там фантастически выгодно действительно это пропускать.
Чтобы какой, ну вот, ну то есть, ну как бы еще, ну вот.
Ну то есть надо сделать так, чтобы как бы, если у вас есть циркуляция, где здесь течет 5, есть циркуляция, где здесь течет 7, то вторая циркуляция была заведомо лучше.
Вот, то есть кост там равен тоже, я так в кавычках напишу, минус бесконечность.
Почему в кавычках? Ну, минус бесконечность нам не подойдет, нам должно быть просто достаточно большое по модулю отрицательное число.
Но там, да, обычно там достаточно что-нибудь минус 3 на модуль С, на модуль там кост на модуль Е там подойдет.
Ну что?
Нет, ну три, ну просто так, ну два, потому что там у каждого ребра, потому что ребер у нас всего два Е там, условно, да.
Поэтому, ну вот, поэтому С на кост, ну да, ну хорошо, если вам нравится, можете 2.1 написать, пожалуйста.
Там, ну что-нибудь такое.
И тогда оказывается, что, ну вот, когда вы тут найдете минимальную циркуляцию, ну, во-первых, заметим, что если тут течет, если тут течет, там, из этой минус бесконечность течет,
что-то типа F, то это означает, что у вас без этого ребра просто из С в Т течет поток величины F.
Вы это ребро вводили для того, чтобы как бы чем больше здесь течет, тем лучше, и тогда в минимальной циркуляции получается F, это просто максимальный поток.
Вот.
Более того, так что можно, так что свести к минимальной циркуляции можно вот и таким способом.
Более того, таким способом это еще и легче писать.
Потому что где вы будете писать D extra?
Потому что идея будет такая, что так как тут у нас нету циклов отрицательной стоимости, то можно сначала добавить вот эти ребра, а потом добавлять вот эти ребра по одному.
Ну да, то есть изначально сделаем нулевой потенциал, будем добавлять эти ребра.
Ну там, так как стоимость не отрицательная, то как бы тут все будет в порядке, мы ничего делать не будем.
То есть, можно сказать, просто есть сети и все.
А потом после этого мы начинаем, ну согласно методу Клейна, просто добавлять по одной пропускной способности вот на это ребро и пытаться искать просто кратчайшие пути от SDT.
То есть в результате алгоритм превращается в следующий.
То есть как бы это ребро реально рисовать никто не будет, алгоритм будет рисоваться такой.
Давайте будем искать этот максимальный поток методом Форда Фолкерсона, но только пути от SDT мы будем искать минимальной стоимости.
Прям вот, жадно минимальной стоимости.
Вот, то есть вот, вот, собственно, общеизвестный алгоритм и доказан.
Вот.
Чего?
Как это?
Метод Клейна требует, чтобы вот этот путь был кратчайшим.
А мы всегда будем брать, мы всегда будем брать SDT, потому что, еще раз говорю, все ребра вот, мы сначала возьмем все вот эти ребра, потом берем вот это.
Но для этих ребер мы DX запускать не будем, потому что, во-первых, у нас изначально потенцион 0, а во-вторых, вот это.
То есть просто там как бы все будет в порядке.
Да, то есть это вот этим мы пользуемся, да.
Вот.
Более того, из этого алгоритма автоматически следует еще более такое.
То есть мало того, что он действительно найдет максимальный поток минимальной стоимости.
Так еще и в качестве добавочки.
Предположим, что у вас в некоторых задачах еще бывает такое.
Найдите поток величины К минимальной стоимости.
Да, так вот, оказывается, что на каждом шаге после там, после ИТ-итерации у вас в этой сети будет поток величины И, причем, минимальной стоимости.
Ну, как бы вы, ну, в принципе, вы могли, конечно, это понять и без этого.
Потому что как вместо максимального ?
Допустим, у вас есть алгоритм, который максимальный поток минимальной стойимости там как-то ищет вот черным ящиком.
Тоесть, допустим, у вас этот жагник допустим как-то работает.
Вы могли, конечно, итак сказать, что вот у вас тут СТ.
Хорошо, а давайте добавим вот там такое ребро, там пропускной способности K и найдем в нем максимальный поток минимальной стоимости.
Но вот...
Тем же жагник!
нет ну не совсем можем на самом деле потому что в принципе можно это сделать следующим образом
ну давайте там условно добавлять понятам непрерывно допустим это будет но мысль можно так то есть
давайте там добавим ребро там найдем там найдем корчайший путь и пропустим сток сколько сможем
ну вот то есть если ребро но вот то есть если мы там добавили там то есть если оно сделалось не
все что там было да ну значит там повторим операцию ну да типа постепенно будем добавлять то есть
в принципе то есть единственная проблема что нет гарантии что это алгоритм вообще закончится
ну вдруг там на каждом вдруг у вас там вы там добавили допустим два точка хотите добавить
два точка восемь а он там будем но вот а он там будет что-то стремящееся к этому там напишу на
каждой террации все меньше меньше меньше меньше вот да но здесь вот получается действительно так
ну в целочи да ну в общем не ценно вот но по чем да единственное где у нас да где у нас
не целочисленные да в задаче hard life в которой стоимости не было вот но тогда здесь получается
тоже что на самом деле то есть как бы вы когда то есть отсюда следует еще важная модификация что
надо искать не обязательно по единичке она сам для вопроса нашли корчайший путь и пихайте по
нему столько сколько можете там дробно не дробно неважно тоже будет работать вот так что вот таким
вот образом можно найти но вот то есть таким вот образом ищется минкост то есть более того
алгоритм поиска работает за величину этого потока умножить на опять же дэйвстро
то есть вот это алгоритм в общем-то да тут тоже практически написан ну либо ну как бы там два
варианта конечно да честно скажем то есть на олимпиадной практике 95 процентов случаев форт
белмена вам вот так хватит просто факт потому что во многих задачах там как бы жюри там либо
затрудняется либо просто они там не заморачивается в то что там еще какие там какие-то там отсекать
какого-то форт белман но иногда такое все-таки случается но в таких случаях ну значит надо надо
просто грамотно написать потенциалы просто вот очень аккуратно определить да что так бы найти
кричащий с помощью потенциала кричащий путь значит найти кричащий путь без потенциала и
собственно сказать что это новый потенциал тут вот тут тут главное не запутаться в этой
задаче до авто авто и начать потому что если вы есть какой-то вершины до какой-то вершины
из-за с не дошли значит не дойдете никогда как можно знаем поэтому поэтому там можно не
заморачивать так ну что вроде так ну что все вроде так ну в принципе да это так это практически
все что я хотел сказать о непосредственно мин костяки у нас так холодно тут вообще
нет оно закрыто то ты прикол да вот ну чертова знает так ладно так то давайте
смотреть сколько у нас тут времени так да ну неплохо да неплохо как это их могли бы тогда
начать их задержаться называется да так вот значит но тут конечно говоря имен кости нельзя
конечно обойти внимание мы одну конкретную задачу об назначениях да нет там тоже господи
я честно свой сегодня ничего страшного не будет ладно разве что дирек обориху ладно да это
не страшно вот но я сейчас говорю не про него а говорю я вот про что я говорю про знаменитую
задачу о назначениях по сути ну на более понятном языке для нас это называется найти в 2 дольном
графе про сочетание минимальной стоимости ладно максимальное про сочетание минимальной стоимости
более того еще и считается граф удобно считать полным двудольным вот да ну давайте подумать
закройся точку можем его найти да можем найти за да за n куб потому что нет ну да потому что у
нас поток величины n и каждую д экстру каждого д экстру можем пускать за н квадрат вот но тем
не менее но вот нам здесь придется константу получать но просто факт значит просто есть
алгоритм который там возможно был изобретен до со до появления мин косто но вот но и по
константе он работает ну так вот вражает шаразиков два лучше вот поэтому то есть он
то есть он достаточно так выражаясь литературным языком маст хевин соответственно и поэтому
придется его обсудить поэтому нас порнот поэтому сейчас нас поприветствует знаменитый венгерский
алгоритм вот да почему венгерский но потому что сначала его за 4 изобрели два венга а потом
через пару лет его допилили до куба еще два венга честно скажу да нет тот тот тот возможно
ваш google сейчас пригодится потому что я не гарантирую что эти пары венгов не пересекались
нет я знаю только одно что один из этих венков это кун да тот самый да тот самый спрос чай да
он венга когда нас сложно догадаться по фамилии но тем не менее да нет чем более
того там остальные фамилии тоже так не сильно сложные но как бы
так задача назначениях да они они про сочетание да
еще это что-то новенькое так хорошо воздоволь паблиш батькарель ткун
окей хангарин метод бекозы легче да потому что он так а так так так так как дедман
скарп так сейчас тогда было понятие симптутика а симптутика алгоритма ну нет ну нет ну ладно
где-то в соседних трудах описываешь такое да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
эти все приколы мы помнится но до известные факчно закон уютона придумал 국ко ньютон так это просто математические taught нормально просто законыгу���т
also
ну точно сначала их утвердить не то есть такую banki рассказывает про закон более
meriotta потому что там типа там более вы сокону 14
с лет раньше море younger ну как бы как бы точность была сомнительно но вот solver
провел там достаточно точные опыты и там все в порядке. Вроде такая байка была.
В чем заключается венгерский метод поиска? Сейчас редкий случай, берем про сочетание.
Значит, допустим, у каждого ребра, то есть допустим, значит, тут важный момент, мы считаем,
что доли одинаковой, мы ищем полное про сочетание. Вот, ну можно считать, что в серии образ
существует, потому что если ребер нет, ну пишем минус бесконечность, допишем плюс бесконечности,
сводим задачу к максимальному про сочетанию. Понятно, да? Точнее наоборот, ну вот. Вот,
ну заметим маленькую приятную вещь. Заметим, что к каждому, что если мы прибавим к каждому
ребру одну и ту же константу, то минимальное про сочетание, точнее про сочетание минимальной
стоимости, останется про сочетание минимальной стоимости, правда? Если мы говорим о совершенных
про сочетаниях, конечно. Логично, да? Вот, поэтому мы без особого исходного ограничения общества
можем считать, что там кост от УВ, да, можно теперь, как бы стоимость ребра можно вводить,
как кост от УВ. Можно вводить, что оно больше либо равно нуля. Ну и то, чтобы оно нам сильно
поможет, но тем не менее. По факту же, значит, мы ведем потенциал. Как-то потока нет, а потенциал
есть. Сейчас мы его будем вводить. Так, а как мы его будем вводить-то, а? Ой, ладно, давайте введем
как-нибудь. Ладно, давайте так. Что такое потенциал? Что у нас в данном случае будет потенциал? Давайте
для левой доли у нас будет потенциал P, а для правой доли потенциал Q. То есть потенциал P
это значит из левой доли просто какие-то числа, в Q это в правой доле какие-то числа. Но у нас
будет мистический инвариант. О господи, на латыни, да. Остался. Ну вот. Остался. Ага, да, да.
Ну вот. Минимальная, но минимальная по стоимости совершенное просочетание.
Но у нас будет лучше константа. Но у нас типа лучше констант. Вот, значит, фишка такая. Должно быть вот так.
Вот такая вот фишка. Да, на этот раз да. В принципе, но смотрите какая фишка. На самом деле,
заметить еще можно следующее, что если я возьму совершенное нот, да, вот это вот, да, вот эту
величину вообще, я объявлю, что пусть это будет, ладно, кост с индексом PQ писать долго, поэтому
буду писать кост штрих. Заметим, что... Действительно, отрицательными они могут быть. Ну забегая вперед, скажу,
что одни из этих потенциалов будут положительные, а другие отрицательные. Ну, в принципе, да, но у нас сейчас нет
задачи переформулировать в терминах это. Более того, сейчас мы просто давайте с другой посмотрим,
с венгерской стороны, да, это да. А то тем более потоки у нас там какие-то были. Поворот там,
остаточная сеть, поворот мозга, там вот это все. Кому это надо. Заметим маленькую приятную вещь.
Заметим, что искать минимальное, решать задачу по обычным стоимостим, по приведенным при любом
потенциале, это в общем-то одно и то же. Потому что если я возьму, вот сейчас мы активно пользуемся
тем, что мы ищем именно совершенное просочетание. Потому что, если я просуммирую стоимость любого
совершенного просочетания, то помимо обычной стоимости туда войдут просто потенциалы всех вершин ровно
по одному разу. Поэтому отсюда два уюта. Во-первых, минимальное присочетание осталось минимальным,
а во-вторых, приятно следующее. Если мы найдем совершенное просочетание на нулевых по приведенной
стоимости ребрах, то мы победили. Если мы верим в этот вариант. Более того, у нас будет цель. Мы
будем подгонять в процессе потенциал, чтобы у нас в итоге получился, во-первых, сохранился инвариант,
во-вторых, в итоге получилось совершенное просочетание на нулевых ребрах. В некоторых редакциях
эти ребра называются жесткими. Но мы их будем называть нулевыми. Вот такая суть.
Как же мы это будем делать? А делать будем так. У нас же был кунга, а он же умел просочетание
искать в обычном графе. Давайте так и сделаем. Давайте возьмем первую вершину и найдем из нее
удлиняющую цепь по нулевым ребрам. У нас есть потенциал. Понятно, что изначально мы подогнали,
что стоимость не отрицательная и исходный потенциал нулевой. Давайте возьмем первую вершину и
найдем из нее удлиняющую цепь по нулевым ребрам. Потом возьмем вторую вершину и тоже из нее найдем
удлиняющую цепь. Потом третий, потом четвертый и так далее. Это алгоритм Куна. Каждый найдем
работает за н квадрат. Вот мы и получили простой алгоритм за н куб без этих ваших потоков.
Вот в общем-то кайф. В общем, только возникает маленький вопрос.
В итоге он найдет. Если мы найдем n удлиняющих цепей, найдут просочетание на нулевых по вот этой
стоимости ребер. А это пока не будет. Потому что на каждом шаге мы найдем удлиняющую цепь.
А вот в этом и вопрос. А кто сказал, что на каждом шаге мы найдем удлиняющую цепь на нулевых ребрах?
Нет, к сожалению, нет. Действительно непонятно. Потому что в общем-то никто не обещал, что мы вообще,
что первый DFS вообще выйдет из этой вершины. Никто этого не обещал. Поэтому придется думать.
Да, ну не случайно же. Сначала один Геовенгер думал, потом еще. Да, сначала два Венгера думали,
потом еще третий пришел, начал думать. Они хорошо подумали, в принципе. Неплохо получается. Нет,
вообще шутки шутками. На самом деле венгерская математическая школа в этом мире очень уважаема,
на самом деле, очень сильная. Так что тут не надо ля-ля. Чего? Не, чехословак.
Ну вот, нет Эгдаш, да. Нет, тут по фамилии очевидно. Ну вот Эгдаш, да.
Как же нам добиваться того, чтобы удлиняющая цепь все-таки находила,
находила с. А то даже ребер нету толку. Но идея на самом деле такая. Вариант будет такой. Из каждой
вершины, если мы не нашли удлиняющую цепь, значит мы ее будем искать-искать-искать до тех пор,
пока не найдем. То есть приводит это к тому, что в очередной момент времени мы живем вот в этой
вершине, а на этих вершинах просочетание на жестких ребрах найдено. То есть найдено просочетание на
жестких ребрах, которое покрывает вот первые сколько-то вершин, мы хотим покрыть следующую.
Как мы это делаем? Запускаем DFS по жестким ребрам. Да, мы поддерживаем вариант, что имеющие
просочетания тоже на жестких ребрах, на нулевых в смысле. Итак, запускаем DFS. Допустим DFS по
нулевым. Значит, все DFS по нулевым ребрам. Запускаем DFS. Ну, если мы по этим нулевым
ребрам, то есть принцип тот же, как и в Куне. То есть направо идем по ребрам не из просочетания,
влево идем строго по ребрам по просочетания. Если мы нашли, если DFS случайно дошел до вершины
правой доли, не покрытой просочетанием, значит, удлиняющая цепь найдена, улучшили,
возрадовались. Логично, да? Или нелогично? Что делать, если не нашлось? Ничего страшного.
Сделаем следующее. Давайте скажем, вот DFS у нас куда-то дошел. Допустим, он прошел что-нибудь типа,
а что такое? Мне просто даже интересно, что вы ухватили.
Нет, это я не знаю. Так, ладно, давайте что-нибудь другое предположим. Тут ассоциации какие-то.
Так, ладно. Ладно, назовем его просто L plus и R plus. Все остальное назовем L
minus и R minus. Как вы же догадываетесь, в L plus у нас оказались только вершины
с просочетания. А в L plus соответствующие вершины с просочетания и наши бедные вершины.
Дальше, к сожалению, нам пойти не удалось. Хочется добиться того, чтобы смогли. Как
это сделать? Очень просто. Почему мы не смогли из этого L plus выйти? Потому что все ребра,
которым мы пытались тут куда-то выйти в R minus, у них, собственно, вот эта стоимость
штриховая оказалась больше нуля. Что же делать? А делать можно следующее. А давайте рассмотрим
все ребра, которые ведут из R plus в R minus. И найдем минимум. Назовем его, ну я не знаю, дельта.
То есть найдем минимальный ребро, который соединяет L plus с R minus. И теперь сделаем
неожиданный чит. Чит будет заключаться такой. Для всех вершин лежащих в L plus мы увеличим
потенциал. Увеличим, да? Сейчас подумаем. Что нам нужно? Нам нужно для каких-то вершин,
для каких-то L плюс или минус. Или для каких-то вершин в R тоже плюс или минус. Тоже что-то сделать.
Чем хочется сделать так, чтобы все ребра остались не отрицательными, но при этом хотя бы какие-то
ребра из L plus в R minus неожиданно стали отрицательными. Нет, ну почему нет? Все правильно. Я
утверждаю, что надо сделать просто вот так. Значит, я предлагаю так.
Да, наверное. Так, ну давайте разбираться. Не испортилось ли что-нибудь? Ну давайте думать.
Ребра из L plus в R plus не испортились. Да, потому что у них ничего не поменялось. L минус R минус
вообще ничего не поменялось. А вот тут дальше интересно. Ребра давайте L минус R плюс. Тогда
у них стоимости даже увеличились. Да, но нас вот эти ребра пока не интересуют.
И самое интересное L плюс R минус. L плюс R минус у них всех приведенная стоимость уменьшилась на дельту.
Но у них дельта и была минимум. Так что мораль простая. Они все остались не отрицательными,
но при этом хотя бы одно новое нулевое появилось. Поэтому что мы теперь делаем?
Ну вот, поэтому заново запускаем DFS. И при этом обратите внимание, старые, да, самое важное,
старые нулевые ребра, так как они все L плюс R плюс или L минус R минус, то они нулевыми остались.
Понимаете, да? Ну и главное, что внутри плюса ничего не поменялось. Это важно. Почему это важно?
Потому что это означает, что когда мы заново запустим DFS, то тут ничего не поменяется. То есть мы обойдем
как минимум те же вершины и плюс пройдем еще по одному ребру вот с этой дельтой. Понятно, да?
То есть получается, что на каждом шаге мы будем, на каждом новом DFS мы будем кушать хотя бы на
одну вершину больше. Следовательно, не более чем за N DFS мы удлиняющую цепь таки найдем. Вот,
понятно, да? Потом еще DFS, потом еще DFS, еще DFS, еще DFS. Вот. Ну вот. Нет, нет, нет, нет, нет, нет.
Нет, нет, нет, нет. На каждое DFS приходит увеличение количества вершин, до которых мы можем
дотянуться, но это еще не удлиняющая цепь. Да. Как говорится, да. Ну вот. То есть, да, вам, да,
вам может показаться, что алгоритм, что такой алгоритм работает долго. Да, так и есть. Это пока от N
в четвертый. Да, DFS работает за квадрат. DFS работает за квадрат. Вот. Для того,
чтобы увеличить просочетание на один, нам требуется пока N DFS. То есть N в кубе на каждое
увеличение просочетания. Для того N в четвертый. Так что это была, утверждаю, что это была оригинальная,
самая первая версия алгоритма была такая. А да, ну вот. То, что будет дальше, это уже теперь,
значит, как допилить это уже до куба. Ну, допилить, ну, наверное, очень просто. То есть, допилить,
то есть, что у нас работает за N в четвертый? Именно DFS. Потому что сами по себе вот эти вот,
там, нет, хотя нет. Значит, работают за квадрат две вещи. Первая вещь DFS, вторая вещь вот эта штука.
Ну, в итоге, да. А они не все пока.
Ну, потому что мы изначально не дошли к чему проблему. Я не остануся нулевыми.
Пшель минус арминск никто не трогает. Нет, ну, как сказать, шарано или поздно в нашей
сети попадется вершина правой доли, непокрытое просочетание. Просто, да, просто уже, просто тупо
по этой причине. Вот. Ну, значит, что нам не хочется? Нам не хочется пересчитывать вот это,
и нам не хочется пересчитывать. Что нам еще не хочется пересчитывать? Вот, да. Ну, DFS не хочется
запускать. Но, с другой стороны, DFS, в общем-то, с DFS-ом проблема решается предельно тупо. Да. То есть,
утверждается, что если нам кто-то с небес по факсу пришлет вот это ребро, то идея такая,
давайте просто из этой вершины запустим DFS, не снимая пометки вот с этих вершин. Потому что до них
мы все равно дошли, в чем более того так же. Поэтому просто начинаем с него и просто то же самое
берем. Тогда получается, что у нас все еще N DFS, но каждый DFS на этот раз, но эти DFS по каждой
вершине больше одного раза не бегают. Ну, это мы будем обрабатывать по принципу,
что найдем дельта, пусть дельта ноль. Ну, с небес по факсу нам его присылают. То есть,
пока мы не умеем адекватно дельту искать. Но если тут небеса и факса сейчас мы наладим,
то соответственно будет работать закуп. Ну, после дельта мы стартуем видимо из вершины правой
доли. Нет, мы только что смогли до нее дойти. Ну, нет, самый первый DFS мы запускаем естественно
из вершины L+. Каждый следующий DFS, пока мы тут линейщую цепь не найдем, мы запускаем
по сути из вершины правой доли. Потому что у нас вот эта дельта, это ребро, которое ведет из
какой-то вершины L+, в какую-то вершину R-. Мы эту дельту магическим образом превратили в ноль,
поэтому резко смогли. Или выяснили, что это вершины не из полисочетания, поэтому ура-радость.
Вот понятно, да? Теперь выясняет вопрос. Как теперь вот этот минимум искать? Вот,
ну, минимум искать, значит, идея оказывается такая. Ну, что тут можно сделать? А давайте в каждой
вершине правой доли для этого будем поддерживать такую интересную величину, как minq от V.
Вот. Вот будем такую штуку в явном виде поддерживать. Ну, изначально ее можно насчитать. Логично,
да? Вот. Ну, у из L, ладно, нагнал, L+. Да, вот теперь хорошо. Почему хорошо? Потому что если нам
с небес по факсу присылают minq, то, в общем-то, и дельту я могу легко найти. Я могу просто
пробежаться по всем вершинам не из R+, и взять из них minq. И это будет уже за линию. А за линию n раз
нас устраивает, потому что тогда каждую фазу мы будем делать уже за n квадрат. Это уже хорошо.
Ну, теперь выясняет вопрос. Ну, как меняется minq? Что? Просто находит минимальное ребро,
которое ведет в меня. Ну, оно может хранить и то, и другое. Ну, самое интересное. Ну,
minq, вы можете сказать, что minq – это чиселка. Есть army, но это при каком у это достигается. Но это
уже другой вопрос. Это тоже не против. А это, кстати, не так принципиально, потому что, в общем-то,
вы можете потратить потом вот этот времени, чтобы его в явном виде найти. Но если вы знаете,
в какой вершине надо искать, то вы перебираете просто все ребра и находите то самое. Это легко.
Ну, теперь выскажите вопрос. А как это minq поддерживать? Ну, что у нас происходит? Ну,
minq у нас принципиально меняется когда? Ну, во-первых, когда меняются потенциалы. Но здесь
это не сильно страшно, потому что если мы тут неожиданно решили выполнить вот эту операцию,
то, очевидно, у всех minq просто вот этот минимум, сколько уменьшился на дельта. Логично, да?
Значит, что еще? А, ну, если у вершины потенциал вычислась дельта, ну, значит,
minq у нее тоже увеличился на дельта. Тоже, в общем-то, неинтересно. Хотя это происходит
только для вершины R+, а, как вы уже догадываетесь, для вершины R+, в общем-то, minq нам уже неинтересен.
Вот, на самом деле, что там происходит в начале. Как еще меняется minq? А еще minq меняется,
когда у вас появляется новая вершина в R+. Но это решается так. Когда в DFS у вас появляется
вершина, прежде чем идти DFS дальше, вы просто перебираете ребра и обновляете minq. Ну,
вам нужно просто пререлаксировать, по сути. Причем для каждой вершины это делается за линию,
причем делается один раз в процессе поиска удлиняющей цепи. minq меняется, ну, либо вот здесь,
но тут оно меняется тривиально. Либо оно меняется, когда в процессе DFS у вас в L+,
появляются новые вершины. Но это обрабатывается тупо за линию. Главное, только в DFS сначала это
обработать, а потом уже искать нулевые ребра. Так что вот такая вот штука в результате. Вот
это вот minq превращает atent в четвертой, в вполне себе адекватное atent в кубе.
Ну да, вы же за линию пробегаетесь. Получается вот такой красивый кубецкий. Как говорится,
не Floyd, конечно, но тоже куб. То есть вот такая вот классика.
Выбираем из minq минимальное, чтобы выбрать дельту. И откуда запускать потом DFS.
Нет, конечно.
Если у нас m ребра, а не пол у нас, то это не работает.
Нет, у нас это не работает просто.
Почему бы?
Потому что у нас в таком случае у тебя прибавятся лишние стоимости, ты не сможешь их нормально вычислить.
Потому что хорошо, почему у нас работает конца в данном случае. Потому что мы знаем, что мы вышли конца, мы прибавили конца.
А теперь зависит еще от того, какие вершины мы возьмем по сочетанию. И просто по-разному мы зачитаем.
Ну вот.
Да, вот это.
Ты можешь всегда на себя добавить ребра с весом бесконечности и решить ту же самую задачу.
В смысле, да, просто вопрос. Можно ли оптимизировать среду 6.1?
Ну вот.
Да вот черту. То-то оно что, не очень понятно, наверное.
Честно говоря.
Скажем так, ответ на этот вопрос мне не известно.
Вот.
Так что вот.
Так что вот такая вот венгерочка.
То есть более того, она в итоге допиливается до достаточно хорошего кода.
Я, честно, не очень понял, как мы обработали ДФС на быстром.
У нас есть L+, R+, они увеличились постоянно.
Ну да.
Ну что мы делаем? Берем Минку, находим минимальное Минку.
Вот оно дельта.
И сделали вот эту операцию. Это все Минку уменьшило на дельта.
Ну вот. Так берем вершину, у которой Минку теперь ноль.
И типа.
И запускаем ДФС, еще и попутно записав, что как бы ДФС прошелся по вот этим ребрам.
Вот.
Как вы увеличиваете цепочку?
Ну вот.
Ну саму цепочку, ну как?
Ну самый тупой способ это в итоге, когда вы уже, когда ДФС уже сказали, что вы дошли до вершины непокиды при сочетании,
можете заново запустить ДФС и эту цепочку найти.
А более адекватный способ.
Давайте для каждой вершины правой доли просто ПР-шку хранить.
Откуда вы в нее пришли?
И тогда просто по ПР-шкам вы, собственно, это и настановите.
Потом Вайликом там пробежитесь.
Ну вот. Ну подробнее я сейчас не буду, но в принципе можно рекламировать.
То есть редкий случай, когда тут можно рекламировать Emax.
Потому что, скажем так, то есть был у меня такой коллега по Олимпиадам.
Собственно, Леша Золотов.
Но вы такого почти наверно и не знаете.
Он там сейчас с Олимпиадом отношения не имеет.
Тот Никтейм у него фреопат.
Вот.
Вот.
Так вот он известен тем, что у него Emax опубликована одна из самых коротких вообще реализаций этого алгоритма.
По-моему, строчек 30.
Ну может Лопатин.
Нет.
Да? Нет.
Ну не знаю.
Ну за Лопатиной не знаю.
Я там.
Были сведения за фреопата.
Нет, за Лопатиной что-то первый раз слышу такое.
Да ладно.
А ведь конспекты что утверждают?
Нет, просто что-то.
Нет.
Ну я не знаю.
А что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Что?
Нет.
Ну или это страховка.
Или типа Леша ее взял у Андрея Лопатина.
Нет, ну такое может быть.
Почему бы нет?
Ой, господи, да.
Как говорится, Андрей Лопатин.
Андрей Лопатин известен тем, что выиграл часы на последнем Huawei Code Challenge.
Чего?
Сейчас тайгуи.
Ну это уже другое.
Ой, господи, кошмар.
Так, ладно.
Ладно.
Ладно.
Так, ну все.
Есть ли по Венгельчике какие-то еще вопросы?
Так, хорошо.
Ладно.
Тогда это все мы убираем и обсудим.
И тогда перейдем немножко к другому.
Тоже, казалось бы, рассмотрим еще одну веселую задачу.
Но в общем тоже мы ее будем решать без потока.
Но, казалось бы, к потокам она какое-то отношение имеет.
Итак.
Следующая задача, которую мы будем решать, это будет задача о глобальном разрезе.
Задача такая.
Да, абсолютно обычный, неориентированный, но при этом взвешенный граф.
Причем гарантируется, что все веса не отрицательные.
Это важно.
Ну там, все угодно.
Вот.
Так вот.
Задача.
Найти минимальный разрез в этом графе.
Да.
Что такое разрез?
Да.
У нас и стока, и стока нет.
Ну в данном случае разрез, это просто, хотим представить
в виде двух разбиения на два множества.
Причем, что важно, оба эти множества не пустые.
Это важно.
Ну чтобы у вас там не было свободно сказать, что типа вот все, вот ничего, вот вам ноль, радуйтесь.
Вот нет, так не пойдет.
Надо вот именно минимальный, именно вот минимальный не пустой разрез найти.
Ну вообще так ладно.
Если граф не связан, то разрез стоимости ноль вы, конечно, найдете.
Это да, но это уже будет другое.
Значит, ст не равно нулю, и как бы хочется, чтобы стоимость ст была как можно меньше.
Вот.
Да, это важно.
Он не ориентированный.
Граф не ориентированный.
Более того, значит, как его можно, как это можно искать?
Значит, алгоритм, который точно работает.
Ну самое смешное, что да, ну и что?
Ну мы говорим так.
Допустим, мы решили, что вот у нас есть вершины С и Т, которые оказались в разных долях.
Допустим.
Допустим, скажем, что у нас такие две вершины.
Так, отлично.
Давайте найдем каким-нибудь потоками.
Так ладно, чемпионский у нас алгоритм пока за сколько там закуп работает.
Да, у нас на прошлом занятии целых три таких было.
Нет, мы еще там.
Если все не успеем, можем почесаться на тему того, как бы сделать чуть побыстрее, но все равно не получится.
Соответственно, да.
Ну вот, значит, запускаем как-нибудь запоток.
Но как бы непонятно.
Это будет минимальный разрез только среди тех разрезов, которые С и Т разделяют.
Да, конечно.
Далее.
Но как бы что можно сделать?
Мы же не знаем, эти С и Т или как бы.
Может они должны быть в одной доле.
Но тут есть два пути.
Самый тупой способ.
Ладно, давайте С и Т тупо переберем.
И у вас получится просто N квадрат поиска потоков.
Если вы подумаете 10 секунд, вы этот квадрат убьете.
Но можно перебирать не у вершины одну.
Ладно, четыре.
Хорошо, да.
То есть заметим, что можно вершину зафиксировать, а ты перебирать.
А можно пойти, кстати, за ту же симптотику немножко другим путем.
Вот вы взяли первые попавшиеся вершины С и Т.
Допустим, вы нашли между ними максимальный, то есть минимальный разрез.
Тогда как можно сделать меньше?
Меньше можно сделать, только если С и Т окажется в одной доле.
Тогда мы сделаем так.
Мы эти вершины схлопнем.
В одну вершину сожмем.
Ребра, которые соединяли, убьем.
Ребра, которые соединяли С и Т с чем-то еще, тоже будут соединять уже эту вершину.
То есть у нас получится граф на N минус одну вершину.
Возможно, стоит там чуть меньше ребер.
Повторим операцию.
Нет, это ровно столько же.
Пока это тоже N на поиск максимального потока.
Правда, да, по константе будет чуть лучше.
Но фишка тут в другом.
Что здесь перспективно?
Перспективность в том, что у нас на каждом шаге задача
найти две вершины и минимальный разрез между ними.
То есть обратите внимание.
Эта задача может оказаться немножко проще, чем
данные две уже тебе фиксированные вершины, найти разрез между ними.
То есть мы сами решаем, что тут найти.
Какие две вершины нас интересуют.
Эта задача может оказаться проще.
И говорим, что ответ либо это, либо...
Сохраняем, что это может быть ответом.
После этого сжимаем вершины СТ в одну.
И на оставшем графе повторяем операцию.
То есть у нас в результате N-1 вариантов ответа получается.
Но мы из них выбираем лучший.
И оказывается, что...
И оказывается, действительно, просто найти как-то СТ
и минимальный разрез между ними, оказывается, можно без поиска потока и гораздо быстрее.
Более того, мы это сделаем быстрее, чем вообще современные алгоритмы,
которые, кажется, умеют искать поток.
Ну потому что я честно говоря не знаю, можно ли искать поток за В квадрат.
Да, прям за В квадрат.
Ну...
Нету мало, я в прошлый раз утверждал, что лучше алгоритм за ВЕ, но по-моему...
Ну, но это не совсем так.
Ну, зависит.
Но при Е равного квадрата, да.
То есть уже не факт.
Как вы считаете?
Я считаю, неправильно.
Так, ну ладно.
Нет, ладно, мы сейчас не будем все скопать.
Скопать-то сколько это?
Но есть подозрение, что ладно, что если мы сделаем как бы решать задачу за квадрат, это круто.
А за В квадрат плюс Е еще круче.
А за Е плюс В лог В?
А будет и такая ассинтотика.
Е плюс В лог В.
Да, да, да, да, да.
Да, аналог Дейстер с кучей фюбоначища возьмите, да.
Сейчас вы увидите, да.
Сейчас вы увидите, собственно, никакой магии на самом деле.
Это шторм Варнер.
Да.
Да, то, что я сейчас рассказываю, называется алгоритм шторм Варнера.
Как я уже говорил еще раз, шторм не склоняется.
Как говорится, да, шторм не склоняется, потому что она мотивида.
Вот, как говорится, вот кто Варнер, я не знаю, но он склоняется.
Нет, ну мало ли, там можно ляпнуть, что там есть какой-нибудь Рихардт, но...
Не знаю.
Ну, я не знаю.
Ну, два варианта.
Либо потому, что он пропустил даму вперед.
Либо потому, что там шторм, наверное, пишется как-то вот так, а Варнер пишется как-то вот так.
И тупо по алфавиту она раньше оказала.
Ну, это уже другой вопрос, да.
Ну, Кэли через С.
Серьезно?
С, Т, О, Е, Р.
А.
Стор.
Ну, окей, ладно.
Хотя нет.
Да-да-да, это самое страшное, там три ошибки, да.
Во-первых, без H, во-вторых, с Е, в-третьих, не мотивида.
Если стереть, то что?
Ну, да-да-да.
Да, классика задачника Астера.
Один водитель автобуса сэкономил за месяц 89 литров бензина, а другой вообще никуда не ездил и никого не возил, поэтому сэкономил в 30 раз больше.
Отдельная сложная версия задачи написать имя Матильда.
По-русски?
Ну, в смысле по-английски, как напишется.
Вот что пишется так?
Что, неужели не так?
Ой-ой-ой.
Давайте расстоять.
Ой-ой-ой.
А где А?
Нет.
Еще.
Пум-пум-пум.
Матильда, лучше Матильда, да.
Может, она была просто не Матильда Шторм, потому что Матильда по-английски это Матильда.
Извините.
Ну, по-английски, да, если она...
Успешники Пети написано, что они предложили Мехдхильда Шторм.
Мехдхильд.
Я не знаю.
Откуда?
Откуда я взял Матильда?
Откуда же я это взял?
Я как бы не с потолка ошибка взял.
Ну ладно, кто-то, видимо, назвал Матильда и все, да.
Ну, как бы да-да-да-да.
Ну да, как-то называется, да.
Ты кто такой?
Я Британсбендайбург.
Борщ Леха, да.
Как-то так.
Ладно.
Так вот.
Ладно, сосредоточимся на алгоритме.
Итак, что у нас в алгоритме?
Алгоритм, значит, он предлагается вот n-1 раз,
типа находим две вершины минимальный разрез между ними и сжимаем их.
А находим их весьма неожиданным образом.
Значит, предлагается сделать так.
Заведем массив А.
В него мы пихнем какую-нибудь вершину.
Вот, просто присвоим.
А теперь делаем n-1 раз следующее.
Значит, в вот это вот.
Вот.
Вот, вот такую операцию сделаем.
Ладно, не такую, вот такую.
Да.
Значит, что это такое?
Ну, я буду получать v от A u.
Это я буду просто помечать просто сумму всех таких ребер.
То есть e равно, допустим, v u.
И, соответственно, v у меня будет лежать в A.
Ну, e, естественно, лежит e.
Вот.
Вот.
То есть вот такое я буду делать.
Более того, в принципе, я еще буду использовать всякие w, a, b.
Но это тоже я буду использовать, сумму по всем таким ребрам,
что значит там.
Не факт.
Дело в том, что когда вы эту вершину перенесете в эту долю,
то там начнут играть как бы ребра, которые ведут не в A.
То есть поэтому они на произменении лучше так не мыслить.
Добавим эту вершину в A.
Читайте Кормана.
Тогда это для вас будет стандартным обозначением.
Вот.
Так вот.
Так вот, добавили все эти вершины.
Так вот, после этого как найти две вершины и минимальный разрез?
Очень просто.
Все.
Тупо две последние.
Сумма ребер, соединяющих u с множеством a.
Ну, max это максимум.
Arcmax это типа при каком u оно достигается.
Нет, нижние подчерки это индекс.
Вы не заводили?
Да ладно, классика же.
Правда, она обычно заводится, чтобы подчеркнуть, что как бы сам по себе этот индекс не используется в цикле.
Да.
Да ладно, хорошо, хорошо, хорошо.
Если вам так разрывает это шаблон, то окей, пожалуйста.
Вот.
Если вам так разрывает это шаблон, то окей, пожалуйста.
Вот.
А минимальный разрез?
Вот этот вот разрез, знаете какой?
Короче, сейчас упадете.
Ну, это не очевидно, но тут, ну, кровь у тебя разрезана.
Ну, wavestate.
Да, w это предпоследнее, то есть s предпоследнее, t последнее.
Ну, давайте так.
Ну, действительно, так, теперь давайте думаем.
Откуда эта алгоритма взяла 7 точек?
Во-первых, в куб, а во-вторых, v на e plus log v.
Там можно фидкульшу искать.
Сходы вещественные.
Не проще, потому что нам придется, да, мы найдем минимальный разрез по величине,
но при этом мы не найдем, собственно, между вот эту вот вершину s, а нам это важно.
Ну, мы же не самые-самые, ну вот, и потом не говоря уж о том, что мы как бы, мы гарантируем,
что вот этот разрез, он минимальный конкретно между вот этими s и t.
Как бы чисто теоретически может...
Ну, два множества, да, нам нужно конкретно, чтобы у нас утверждение ключевое будет заключаться в том,
что это именно минимальный разрез, который разделяет вот именно вот эти s и t.
Да, можно идти до n минус 2, а если начинать с нуля или что?
Вода вообще не асимпатическая, да.
Ну, понятно, что такая фаза, конечно, реализовывается, но понятно, что как в dx3 мы реализовываем,
d at 2 это просто сумма весов ребер до a.
Когда новая вершина добавляется в a, мы эти d, соответственно, апдейтим.
Это суммарно за e работает, а минимум ищем, ну, либо ищем zb квадрат,
либо апдейты делаем с помощью с кучей фибоначий, тогда получается e плюс v.
Так и так и будет. Да, но дело в том, что мы это делаем только...
То есть это мы так только один разрез нашли, мы так n минус 1 раз должны сделать.
Ну, это же буквально...
Ну да, и функция немножко другая.
Потому что там сумма ребер, соединяющих там с заданным множеством, а не длина какого-то там пути.
Ну, скажу так, да, конкретно вот это вот работает за e плюс v логовая, да, я согласен.
Почему я тут домножаю на v?
Потому что я беру весь алгоритм, в который мы вот это вот все делаем n минус 1 раз.
Так что пока да, v и e мы, конечно, не перебили, но тем не менее...
Мы просто позволяем всем произвол выбора вершины v, да?
Ну, вот этой вот начальной, да.
И вот краски ее перебираем и запускаем?
Нет.
Нет, мы не перебираем, а значит это было бы v четвертый.
Нет, алгоритм вообще не так. Он устроен так.
Мы нашли вершины, то есть за e плюс v логовая мы нашли две вершины и минимальный разрез между ними.
Тогда ответ.
Значит ответ на задачу либо этот разрез, либо какой-то разрез, в котором sct лежат в одной доле.
Сжимаем вершины sct в одну долю, остался граф, наверное, с решением.
Повторяем.
Чего?
Вот, то есть я повторяю.
Чего?
Кого нашли?
Вот.
Да.
Почему это находит минимальный разрез?
Да, основное, что надо доказать, почему между этими вершинами sct минимальный разрез реально такой.
То есть нет, это по сути, нет, давайте так, давайте ограничим себя аккуратно.
Что нам нужно доказать?
Нам нужно доказать, что действительно между вот этими двумя вершинами в итоге минимальный разрез будет именно такой.
Вот это вроде, если мы в это, если мы в это верим, то как бы дальше все элементарно.
Да.
Но правда тут важно, что эти вершины найдены именно так, капсом.
Почему дальше будет все тривиально, если мы даже доказали, что между вершинами sct разрез ровно такой.
Что дальше у нас?
Смотри, у нас сказали, что у тебя либо, у тебя в ответе либо эти две вершины разреза в разных долях, тогда это ответ.
Либо в одной, мы их объединяем.
Вот.
Так.
Ну вот.
Так что теперь значит возникает, теперь начинаем думать, как же нам это.
Ну как же.
Ну да.
Нет, ну да, халявная, конечно, лекция, если мы только на третьем числу начали думать.
Значит, поехали.
Делать будем так.
Ну сколько?
Нет, почему третий?
Два с половиной часа.
Ну мы, конечно, начали не в девять, но тем не менее.
Да, да, да еще.
Ну да, можно еще придать там перерыв.
Там перерыв у нас пока один был.
Так.
Значит, смотрите, немножко магии.
Значит, смотрите.
Вот, значит, рассмотрим какой-нибудь разрез.
Это я буду называть СОПТ.
Так вот.
Рассмотрим какой-нибудь разрез между ССТ.
Вот.
Назовем его С.
Наша цель доказана вот.
То есть сейчас давайте.
Вот.
Мы, как говорится, хотим.
Что мы хотим?
Хотим, чтобы В от С было больше либо равно вот этого вот.
В от СОПТ.
Ну В от СОПТ у нас равно чему?
Ну, короче, В от В без Т и Т.
Ну, можно тут скобочка ставить, можно не ставить.
Вот мы это хотим.
Доказывать мы это будем следующим образом.
Смотрите.
Дело в том, что относительно этого, вот рассмотрим вот эти вот вершины В0, В1, В2 и так далее.
Вот в том порядке, в котором они были добавлены множество А.
Сначала вершины будут в одной доле.
Потом неожиданно перескочат в другую.
Потом вернутся в первую.
Потом вернутся во вторую.
И так они, короче, будут сколько-то времени скакать.
Но в какой-то момент у нас тут последние две вершины окажутся в разных долях.
Почему?
Ну, потому что мы разрезаться и взяли между этими двумя вершинами.
Это у нас, напоминаю, ВН-2, а это ВН-1.
Так вот, да, сейчас мы будем это все доказывать по индукции.
Как мы это будем доказывать?
А вот как, как говорится, назовет, значит, определение.
Вершина ВИ интересная, если ВИ и ВИ-1 в разных лежат, в разных долях С.
Ну, то есть, короче, вот интересными являются вот эта вершина, вот эта вершина, вот эта вершина, вот эта вершина, ну и так далее.
Понятно, да?
Никак не меняется.
С никак не меняется.
Это вот заданный фиксированный разрез между С и Т.
Мы хотим доказать, что он не лучше, чем оптимальный разрез.
Так вот, утверждение.
А, ну вот, давайте еще такое определение.
Давайте так скажем, что АЖТ это будет просто множество вершин с нулевой до, внимание, G-1.
Понятно, да?
Так вот, мистическая утверждение.
Значит, мистическое утверждение, что если я возьму стоимость
стоимость
стоимость ребер разреза, которые, только возьму не все ребра, а только те, кто лежат вот в первых G плюс одной вершине.
Понятно, да?
То оказывается, что это будет больше либо равно,
чем W от АЖ и G.
Правда, ладно, оговорка.
Если вершина в G интересная.
Отвечивает.
Ну, идея такая.
Рассмотрим вершину в АЖ, интересную вершину.
Рассмотрим все ребра, которые соединяют только первые G плюс один вершин между собой.
Но рассмотрим только из этих ребр, только те, которые пересекают разрез С.
Так вот, я утверждаю, что сумма их весов, она больше либо равна, чем вес ребер, соединяющих вершину WGT с вот предыдущим.
Да, по сути, мы хотим, если мы сейчас докажем это утверждение для всех интересных вершин по индукции, то мы это по сути докажем и для такой интересной вершины, как T.
А это ровно то, что мы хотим.
Ну, сумма весов, вес вот этого разреза, это сумма весов ребер, токсичек, СТ, в остальное.
Ну, нам дан разрез С, какой-то, да, и мы пытаемся доказать вот эти утверждения.
Мы доказываем вот эти утверждения.
Ну, типа да. Из этих разрезов как будто оптимальный будет вот этот.
Да, как-то не странно мы это докажем.
Как мы это докажем?
Ну, для этого нам придется немножко пошаманить.
Смотрите. Ну, будем доказывать по индукции.
Ну, потому что база индукции для самой первой вершины, интересной вершины, это очевидно.
Ну, потому что ребра, пересекающие разрезы, ребра, соединяющие эту вершину со всеми вот этими, это буквально одно и то же, правда?
А теперь давайте переходим от вершины.
Допустим, у нас тут есть вершина ВЖ и есть вершина ВЖ штрих.
Хотим доказать для нее.
Вот пусть для вершины ВЖ мы все доказали.
Теперь доказываем для ВЖ штрих.
Понятно, да?
Ну, поехали.
Давайте попробуем пооценивать.
Вес от С от А от Ж штрих, объединенное с ВЖ штрих.
Ой, да, тут объединение не с Ж, а с ВЖ, конечно.
Вот.
Что это такое?
Ну, давайте распишем эту штуку относительно Ж.
Потому что заметим, что в этот разрез, в множество этих ребер, очевидно, входят ребра вот эти, вот АЖ, объединенного с ВЖ.
Логично, да?
Ну, они туда входят.
Ну, конечно, это не все.
Туда входит что-то еще.
А что еще туда входит?
Ну, еще туда входит вот какие-то еще ребра.
Какие ребра туда входят?
Мы понимаем, что ВЖ штрих – это кто идет после Ж.
Сейчас.
Ж штрих – это после Ж.
Ж штрих идет после Ж, да.
Но плюс еще какие-то ребра надо добавить.
Какие ребра надо добавить?
Ну, надо добавить вот эти вот ребра, которые торчат из вершин от Ж плюс один до Ж штрих минус один куда-то.
Ну вот, то есть плюс там, ну вот плюс там что еще?
Ну, плюс В от, скажем так, С от, давайте так напишем, от множества ВЖ плюс один, ВЖ плюс два и так далее.
В там Ж штрих минус один.
В, ну, допустим, АЖ.
Ну, я мог бы АЖ объединенной Ж написать, но как бы нас сейчас это не интересует.
Значит, что это такое? Это все ребра, которые соединяют вот эти вершины с вот этими вот.
Так, что-то я еще забыл. Все я еще забыл.
А это и есть неинтересные вершины.
Так, осталась еще сама вершина Ж штрих.
То есть так, ну вот, давайте так напишем, В от, соответственно, С от, значит С от АЖ штрих и Ж штрих.
Вот, понятно, да?
Нет.
Нет.
Сейчас.
Нет, видите, нет, есть разница.
Тут внутри С написано не одно множество, а два.
Это разные вещи.
Это значит, что я беру как бы ребра между этими двумя множествами, оставляя из них только те, которые еще и разрез пересекают.
Ну, вот такие обозначения.
Ну, естественно.
Ну, когда, ну, были. Поэтому я тут С пишу. Какие-то были.
Да, так.
И чего берем?
Мы берем Ж штрих, следующий интересный индекс АЖ.
Ну, нет.
Мы либо нашли интересный.
Ну, Ж штрих, да, это следа. Ж это интересный индекс, а Ж штрих это следующий интересный индекс.
То есть строго интересный.
То есть для нас важно, что Ж и вся вот эта компания, они лежат в одной доле.
Вот. То есть как-то мы этим сейчас начнем пользоваться.
Значит, как же мы этим начнем пользоваться?
Так, это у нас вот такой вес.
Ну, теперь давайте попробуем это как-нибудь оценивать.
Значит, смотрите.
Это больше либо равно.
Ну, начнем с того, что с точки зрения больше либо равно.
Допустим.
Сейчас.
Ну да.
Давайте вот это мы убьем вообще.
Вот.
Ну, мы на самом деле с точки зрения больше либо равно мы можем убить любые ребра,
потому что тут мы пользуемся тем, что они не отрицательные. Это важно.
Да.
Это значит больше либо равно.
Значит, смотрите, какие мы оставим.
Тут мы пишем.
Ну, давайте так. Я пока перепишу.
Значит, АЖ объединенное с ВЖ.
Вот.
Плюс.
Плюс W от С от АЖ штрих и ВЖ штрих.
Оп-оп-оп.
Итак.
Что мы еще теперь сделаем?
А еще я сделаю следующее.
Чего?
Ладно.
Ну вот.
Значит.
Так вот.
Ладно.
Делаем предположение индукции.
Ну, по предположению индукции я тут могу вот эту штуку заменить на что?
На В от АЖ и ВЖ.
Логично, да?
И плюс я еще пишу вот это.
То есть В от С от АЖ штрих пока и ВЖ штрих.
Давайте тут СТ я сдвину.
Теперь следующий аккуратненький шаг.
Это было предположение индукции.
Теперь воспользуемся структурой алгоритма.
Структура алгоритма, что когда я выбирал вершину ВЖ, я выбирал вершину, у которой вот эта штука максимальная.
Стало быть, она больше, чем W от АЖ и, внимание, ВЖ штрих.
И плюс В от С от АЖ штрих, ВЖ штрих.
Здесь мы что-то два раза посчитали, но я могу два раза не считать.
Потому что я могу заметить, что множество вот этих ребер, которые соединяют ВЖ штрих с вершинами, с более ранними вершинами другой доли, входят в том числе и ребра, которые соединяют ВЖ штрих с вот этими всеми вершинами.
То есть я могу, то есть напишу так.
Больше либо равно от В от АЖ и ВЖ штрих, плюс В от ВЖ, ВЖ плюс один и так далее.
Ой, ну карлочи, господи, что я тут заморачиваюсь.
Эти вершины на самом деле обозначаются гораздо кроче.
Они обозначаются, ага, именно.
Ну вот.
Все.
Да.
Ну вот.
Да, подлянка, подлянка доказательства заключается в том, что как бы я не знаю, как это придумали, то есть из каких идей можно это как бы вывести, как бы к сожалению алгоритм, но алгоритм вот у меня есть только в таком виде.
То есть видно, вот такой алгоритм, вот такое доказательство, что он работает, да.
Как это придумали, я не знаю.
То есть как кто-то скажет, как говорится, как-то задача предвыдульный краф.
Вот.
Как говорится, кто-то тупо угадывает ответ.
Ой, а вы угадали ответ?
Ну вот это веселая задача типа там.
Что-то дан краф, найдите в нем количество связанных под граф по модулю два.
Угадали?
Ну вот.
То есть я один сидел, доказательство придумывал, да.
Понятно.
Ну да.
Но я не запустил, честно говоря.
Честно говоря, даже я никогда не умел угадать.
То есть я угадал ответ, только когда у меня, собственно, он просто из аккуратных формул выявился.
Но это уже ладно.
Но это, к сожалению, не тот случай.
Так что вот такая вот радость.
То есть вот такая вот почему-то аккуратная радость.
Так, ну что, есть ли тут какие-то вопросы?
Ну давайте.
Ну давайте.
Есть, хорошо, у нас есть V от двух аргументов.
Это разрез, понятно.
Не разрез, тут сумма ребер.
Ну да.
Это понятно.
У нас есть это значение V от C с одним аргументом.
Это означает следующее.
Берем множество.
Берем все ребра в гем.
И оставляем из этих ребер только те, кто пересекает C.
Ну скажем так, да.
В принципе, есть версии, в которых на самом деле вот это вот множество ребер называется C житое на самом деле.
Хорошо.
А с двумя аргументами?
А с двумя это берем все ребра, соединяющие два множества.
И ставим только те, кто пересекает C.
Ну да.
То есть иногда мы про них даже знаем.
Нет, если мы про них знаем, что они лежат в разных долях C, то как бы...
А, ну тогда мы C не пишем.
А если не знаем, то пишем C и поговорим, что все, что не пересекает разрез, удаляем.
Вот видите, в какой-то момент мы и перестали это писать.
Мы уже доказали, что разрез, ограничение ребер на разрез в C, он больше ребра, чем та наша личность.
А мы хотим доказать, что в целом разрез...
А, понятно.
Но нет, ну в конце мы как бы...
В конце для вершины T просто это утверждение будет выглядеть, что если мы возьмем вообще все ребра разреза,
то их вес больше либо равен, чем если мы T соединим со всеми вообще вершинами.
И это ровно то, что нам надо.
То есть картинка называется...
Так получается.
Вот такая вот неожиданная магия.
Аккуратненько.
Это реально магия.
Ну да.
Увы, буквально какая-то вот магия.
Ну, собственно, по имени Матильды, в общем-то, это уже можно было ожидать что-то подобного.
Неплохо.
За помощь этими звездочками? Чего?
Ну понятно, да.
Не, ну мало ли там, что Дорти Вагнер это кто?
Ну, это логично, потом мне приходит в голову, но это может быть...
Не, ну ладно, мама это кошмал, вероятно, про маму обычно так и пишут.
Ну или да, ну мало ли, может, это трехлетняя дочь.
Ну мало ли, да.
Нет, ну почему нет?
Как вы это, ей приснилось, да.
Так, ребят, напишите, вот так и зайдет.
Да, да, да, да, да.
Ну это да, но, сравнивая, но Рамуру Джан, когда ему все это приснилось, он все-таки уже не трехлетний батюшка был.
Что-то...
Ого.
Что-то вот вместо, ну в том числе похоже.
Короче, это не с потолка, наверное, взято?
Ну...
А как-то...
Что значит не с потолка?
Ну да.
Люди придумали где-то...
Стоп, или это появилось раньше DX?
Нет, это появилось после «Собачьего курица».
Ну да.
Нет.
Ну вообще, там все...
Такая идея совсем популярна, в самом деле.
В ссылках на реальную студию есть какой-то...
И ссылка на примок.
Нет, это немножко не о том, понимаете, это как бы уже механика, собственно, реализация алгоритма.
Да, она похожа на там DX, да.
Но она...
А это одно и то же.
Да, DX, то есть механика здесь одинакова.
То есть более интересно, на самом деле, откуда придумали, что вот такой жакник вообще работает, условно.
Ну для меня всегда была магия, как придумывать жакники.
По крайней мере, доказательная.
Ну если это стандартная жадность на матроидах, то, конечно, да.
Не, возможно, они просто анализируют...
Они придумали идею с тем, как можно брать любые две вершины, какие-то вершины между ними разрезают, так как склеивать.
Возможно, они заметили, что существует паттерн, в котором это будет одна вершина.
Они это заметили.
Ну может.
Ну может, я не знаю.
То есть это уже отдельная песня.
Чего-то их знает.
Ладно.
Давай.
Так.
Так, ладно.
Тут еще какие-то вопросы есть?
Так, видимо, ладно.
Нет.
Так, все.
Значит, как у нас приятная в этом смысле лекция?
Все.
Опять очищаем картинку и начинаем думать о другой задике.
Так, ну ладно.
Такое же, на самом деле.
Ну почти такое же.
Ладно.
Ну ладно, не такое же.
Так, ну хорошо.
Короче, данный ориентированный граф.
Найдите разрезы между всеми парами вершин.
Но для любой паре вершин найдите минимальный разрез.
В чем, что самое смешное?
Желательный сам разрез тоже.
Ну да, можно это сделать за n квадрат на поиск потока.
А мы это сделаем за n на поиск потока.
Но на самом деле интересен может даже не сок сам алгоритм.
Хотя алгоритм тоже интересен.
Сколько то, в каком виде мы выдадим ответ на задачу.
Еще круче.
Если какой-то разрез, у нас есть какие-то две доли.
И вот для всех вершин из одной пары вершин, где одна из одной доли, другая из другой.
Тут не доли, но понятно.
Мы уже нашли ответ.
Все еще круче.
Нет, как говорится, потому что подсказка в названии темы.
А тема называется дерево гомовиху.
Идея оказывается такая.
Оказывается, что для любого графа существует мистическое дерево.
Не, именно дерево, не куча.
Вот такое дерево на тех же самых вершинах.
Вершины абсолютно те же.
Веса какие-то веселые там.
На которых минимальные разрезы.
Дерево такое, что минимальные разрезы на этом дереве такие же, как в исходном графе.
То есть искать их нужно будет так.
Если вы хотите между вот этой вершиной и этой вершиной найти минразрез, что вы сделаете?
Найдете на пути минимальное ребро.
Вот допустим вот это вот.
И проведете вот такой разрез.
Самое эпическое, что совпадут и величины разрезов, и сами разрезы.
То есть это вот минимальный разрез, как разбиение на вот такие множество тоже будет работать.
Как говорится, может показаться...
Хотя самое смешное, что если брать пока не разрезы, а просто хотя бы величины,
то на самом деле оказывается не так сложно это понять.
Что существует такое дерево?
Допустим пока не верим только в величины, но не верим в сами разрезы.
И на самом деле про величины это сделать можно.
Потому что идея такая.
Вот Жил был граф.
Мы можем ввести такую матрицу F от G.
Введем такую матрицу F от IG, где F и G это просто мин разрез между I и G.
Просто матрица.
Мистическое утверждение, которое нам поможет.
Нет, еще круче.
Так вот возникает такое интересное утверждение.
Давайте, думаю, если вы сейчас 10 секунд помедицируете, вы даже поймете, откуда оно взялось.
Возьмем F и K меньше, чем F и G.
Да, просто возьмем разрез и K.
Ну да, все.
Ну да.
А F и K, да.
Если K прилежит вместе с G, то тогда F и G вынуждено будет больше либо равно, чем F и K.
Потому что просто F и G это будет лично какого-то разреза между I и K.
А F и K это минимальный разрез.
Так вот, следствие.
F и G больше либо равно минимума из F и K1, F, K1, K2, F, K2, K3 и так далее.
F, K, B, G.
Ну я тут не буду эти кванты рисовать, я думаю так понятно.
Ну в общем-то да.
Ну выводится отсюда достаточно легко, да?
Или не выводится?
Вроде выводится, да.
Ну по сути да.
Да, просто рассмотрим любую последовательность вершин.
И оказывается, это очень похоже на кое-что.
Да, это должно чем-то напоминать остовные деревья.
Ну потому что фишка в том, что, да, там оказывалось, что, ну давайте так.
Правда, в минимальном асторе было верно, что любое E, I, T, G, T оно должно было быть что?
Оно должно было быть больше либо равно максимума из E и K1, E, K1, K2, да?
Да, там бла-бла-бла, E, K, P, T, G.
Если у нас такой цикл есть, да?
То есть вот это вот ребро E и G, а это вот цикл в дереве, да?
Тогда если оно оказалось меньше этого максимума, то давайте максимум из цикла удалим, это добавим, получилось меньше.
Что?
Возможно, не знаю.
Знаю просто как утверждение.
Так вот, фишка такая.
Наверное, всегда.
Но с другой стороны, заметим, теперь у меня идея такая, а давайте-ка я в этих f-ках возьму максимальный остов.
Да, можно брать минимальный, а можно максимальный, в общем-то одно и то же, только со знаком минус, да?
Максимальный по размерам.
Да, по суммарной стоимости f.
Да, то есть я рассмотрю граф, у которого матрица смежности вот такая,
и возьму в этом графе максимальный остов.
То есть пусть у меня T это максимальный остов в вот этой вот, так сказать, матрице f.
Ну, минимальный остов минимальный, а максимальный остов максимальный.
Да, да, идея, да, идея на…
Нет, пока у нас задача убедиться, что вот это вот это не плотно какой-то там больной фантазии.
Хоть на сколько-то.
Так вот, рассмотрим вот такое дерево.
Тогда смотрите, тогда у этого дерева маленькая приятная вещь.
То есть смотрите, у любой вершины ИG есть путь по Т.
И, допустим, Т1, Т2 и так далее, Тq, Тg.
Вот какой-то путь.
Но смотрите, что мы знаем.
Но смотрите, что мы знаем.
Мы знаем, что f и g больше либо равно, чем минимум из f и f, f, t1, t2, f, t2, t3 и так далее, f, tq, g.
Это мы просто знаем, потому что это всегда верно.
Но по свойству максимума, оказывается, что f и g меньше либо равно минимума.
Потому что если бы оно было строго больше минимума, тогда мы могли бы улучшить остов.
Вот так что вывод очевиден.
f и g тупо равен этому минимуму.
Но что это означает?
Практически это означает следующее, что если у вас такой остов вам дали,
то для того, чтобы найти разрез хотя бы на уровне его величины,
надо просто в этом дереве найти минимальное ребро.
То есть дерево Гамариху, по крайней мере, в ослабленной версии вообще существует.
Ну да, в численной хотя бы версии.
Это, конечно, вообще пока не гарантирует.
У нас будет сейчас более усиленная версия.
Мы не только построим дерево, там за быстрее, чем за построить эту матрицу.
Ну ладно, потом при желании матрица уже легко строится, естественно.
Но мы построим дерево быстрее, чем построить матрицу в тупую.
И еще будем строить так, что у нас окажется, что минимальные разрезы будут находиться буквально вот так.
В частности, между каждой этой парой вершин минимальный разрез будет буквально вот такой.
То есть вот такую неожиданную мистику мы делаем.
Чем алгоритм, в общем-то, будет достаточно простой.
Ну если у вас в кармане лежит что-то типа «возьми граф, возьми две вершины, найди минимальный разрез».
Вот. То есть это, в общем-то, будет достаточно легко.
Так, но, однако, если верить хронометражу, то сейчас пришло время перерыва.
Так, давайте поехали, мы задержались, как всегда.
Вот. Итак, как же мы будем вот это вот дерево искать только уже с разрезами?
Как мы его будем искать?
Ну, для этого, для разминочки докажем одну маленькую приятную лему.
Да, лема приятная, доказательства не очень.
Почему? Потому что я никогда детали не помню.
Значит, смотрите.
Базироваться будем вот на чем?
Базироваться будем вот на чем?
Смотрите.
Сейчас вот концентрируйтесь, потому что доказательства, честно скажу, такое вот, скажем так, повырубаться надо неприлично.
Значит, смотрите, идея такая.
Жили-были вершины и ежи.
Вот.
Вот у нас есть граф и есть вершины и ежи.
Ладно, х игрок.
Ладно, все лема, давайте.
Значит, пусть у меня есть вершины и х игрок, и пусть у меня есть разрез А, а с тильдой это вот, где вот А лежит нот.
Это мин разрез для, значит, соответственно, х игр.
Понятно, да?
Пусть х' и y' лежат, ну, допустим, в доле А.
Тогда, ну, сформулирую так.
Существует минимальный разрез.
Там, b, b с тильдой.
Для х, для х' и х'.
Такой, что
А с тильдой целиком лежит в b или целиком лежит в b с тильдой.
Значит, перевожу на человеческий язык.
Предположим, что вы взяли х игрок и нашли тут какой-то разрез.
И вот у вас тут какие-то вершины и тут какие-то вершины.
Вот фишка такая, если рассмотреть вот эти две вершины в этой доле,
то когда вы ищете разрез, утверждается, что вот эти вершины можно сжать в одну,
которые лежат в другой доле.
И хуже от этого не станет.
То есть вот такая вот неожиданная идея.
И спрашивается, как же это доказывать?
Но начало доказательства как раз понятное.
Рассмотрим.
Ну, рассмотрим у нас тут. Тут у нас будут доли a с тильдой,
и тут будут b и b с тильдой.
То есть где-то у нас тут лежит.
Ну, без ограничения пока общности х будет лежать где-то здесь.
Вот.
Ну и без особого ограничения общности здесь будет лежать х' а здесь y'.
Вот с игроком у нас ограничение общности так просто уже не получится.
Потому что игрок будет лежать либо здесь, либо здесь.
И это, формально говоря, два разных случая.
Вот. Значит тут у вас в любом случае тут какие-то, тут какие-то и тут будет игрок.
Ну, пока будет тут.
Ну, хотя я утверждаю, что дальше будет то же самое капсул.
Ну, как тот алгоритм поиска суммы, там сумма фиатен, для n 1,19 за две трети.
Да, как бы я этот алгоритм не знаю, но это общеизвестный алгоритм.
Вот, Сергей Капельевич.
Вот.
Так вот.
Ну, давайте думать.
Ну, смотрите, что у нас тогда получилось.
Значит, хочется доказать, видимо, да, что если у нас вот они так разложились,
то мы могли бы на самом деле одно из этих множеств как бы перегнать вот сюда,
то есть либо это сюда, либо это сюда, идти похуже не станет.
Понятно, да?
Ну да.
Мы хотим доказать, что мы все вот это можем сжать в одну решку.
Но для этого нам нужно доказать, что как бы на самом деле там, вот в этой картинке,
ну, как бы везде вершины какие-то есть, да?
Но хочется показать, что, если мы перегоним это в одну решку,
что мы бы не смогли бы на самом деле сжать в эту прошлую решку в эту緩 sair,
В этой картинке везде вершины какие-то есть, но хочется показать, что если мы перегоним все вершины вот сюда или, наоборот, все вершины вот сюда, то типа хуже не станет.
Значит, как же мы это будем делать? Делать мы это будем следующим образом.
Давайте подумаем, давайте попробуем перегнать вот эти вершины сюда. В каком смысле это будет не хуже? А что нам нужно не хуже?
Нам нужно чтобы вот этот вот разрез, то есть нам очень хочется, чтобы от этого не увеличился разрез между х' и у', правда?
А что это сейчас за разрез х' и у'? Сейчас этот разрез можно представить в следующем виде.
Его можно представить в виде f, a, b.
Нет, вру.
Там f, значит, там a, b, даже не a, b, а и b, ну да, f, да, правильно, нет, ну, ой, ну, конечно, такое, ну, что поделать, ладно, давайте один, ну ладно, давайте один, два, три, четыре, хорошо.
Так, как назвать один, два, три, четыре? Ну, давайте вот так.
Так, и у нас тогда получается f, значит, тогда у нас разрез вот этот, это у нас что такое? Это f, 1, 2, плюс f, 1, 4, плюс f, 3, 2, плюс f, 3, 4, да?
Это вот текущий вот этот разрез. Нам очень хочется показать, что он больше либо равен такого же разреза, только, например, если вот эти вершины пойдут сюда. Понятно, да?
Ну, вот, ну, например, нас устроит, но если вот это пойдет сюда, то тогда что получится?
Ну, вот что, ну вот, то есть если вот это пойдет сюда, то величина разреза получится как бы f, 2, 1, плюс f, 2, 3, плюс f, 2, 4, то есть фактически разрез проходит вот так, видно, да?
Или что еще? Ну, вот, или нас, ну, вот, ну, или еще бы устроило, чтобы вот этот тройбан бы сюда пришел, да? То есть вот. Или еще хочется, вот.
Но я не утверждаю, что оба эти утверждения верны, но какой-то из них мне бы очень было бы занятно доказать. То есть f, 1, 2, плюс там f, 1, 4, плюс f, 1, 3, вот так.
Так.
Так. Ну, давайте, да.
Да. Ну, заметим, да, оба раза на самом деле можно тут пошлеп-шлепать, конечно, да.
Но я вам даже больше скажу. Здесь можно еще вот это пошлеп-шлепать.
А тут 2, 3. А тут да. Совершенно верно.
Так. То есть теперь у нас f, 1, 4, то есть хочется доказать либо вот такую сумму. А что это за сумма? f, 1, 4, плюс, то есть это, плюс это должно быть больше либо равно, чем вот это.
Или, наоборот, f, 3, 2, или вот это, плюс вот это должно быть больше либо равно, чем, соответственно, вот это.
Так. Ну, давайте смотреть, хотя вот, не знаю, поторопились ли мы, конечно, сокращать или не поторопились.
Так. Ну, с другой стороны, смотрите, на самом деле, давайте попробуем рассмотреть все-таки про вот это равенство, с единичкой.
Так. f, 3, 2, плюс f, 3, 4 больше, чем f, 2, 4?
Да.
Потому что f, 3, 2, плюс f, 3, 4 равняется f, 2, 3, плюс f, 3, 4.
И воспользоваться тем, что сумма этих величин, она больше либо равно, чем f, 2, 3, плюс f, 3, 4, это на самом деле больше, чем f, 2, 4.
Почему?
Потому что мы доказали, что f и g больше либо равно, чем f и k.
Да, но это же вы не учитывайте.
Это же надо, во-первых, полные разрезы брать, в том числе и с единичкой.
А это мы тут какие-то подморжиства взяли.
Вот.
Нет.
Смотрите, надо, как тут такое доказывать?
Надо как-то, наверное, пытаться пользоваться тем, что вот эти вот разрезы, ну, как бы...
Ну, ладно, про вот этот разрез мы, конечно, не знаем, что минимальный, а вот этот x y мы уже точно знаем, что он минимальный.
Вот.
То есть в принципе это означает, что мы знаем, что f, 1, 3, плюс f, 1, 4, плюс f, 2, 3, плюс f, 3, 4 меньше либо равен, чем шо.
Ну, в принципе, чем какой-то абсолютно любой разрез.
Ну, какой разрез тут можно?
Ладно, раз уж у нас тут мельтешат вот эти трибаны, давайте с трибаном напишем.
Я могу, например, сказать, что это меньше либо равно, чем f, 3, 1, плюс f, 3, 2, плюс f, 3, 4.
Пока вроде логично, да?
Так, окей.
Тогда, ну, в этом неравенстве шлёп-шлёп, шлёп-шлёп.
Ой, какая красота.
Так.
Ой, чего?
А, нет, нет, нет, нет, нет, нет, неправильно, неправильно, неправильно, неправильно, неправильно.
Потому что тут f, 2, 4 всё-таки.
Да, 3, 4 рано сбрасывается из счетов.
Да, то есть 3, 2 там и скинули, но вот надо, а, вот так надо.
Вот, видно, да?
Ну, вот, да. Ну, давайте смотреть.
Чем это нам, соответственно, помогает?
Ну, вот, это, ну, вот, чем это нам, соответственно, помогает?
Но, в принципе, я утверждаю, что вообще-то мы уже на халяву доказали вот это неравенство.
Да.
Причина очень проста.
Да, напоминаю, у нас ребра не отрицательные, да?
Поэтому, в принципе, отсюда автоматически следует, что f, 3, 4, то есть больше либо равно f, 2, 4 плюс f, 1, 4, а это больше либо равно, чем f, 2, 4.
А это меньше либо равно, чем f, 3, 4 плюс f, 1, 4.
По-моему, я тупо получил вот это неравенство.
Оп.
Ну, да.
Не, ну, какой-то из них.
Второе может понадобиться, скорее всего, если игрок окажется здесь, то вам придется пользоваться вторым.
Да.
То есть в данном случае верным оказалось вот это.
Ну, я просто честно скажу, я не помню точно никогда деталей, поэтому вот так.
Так что вот такая радость.
Так что вот смотрите.
То есть, как я сказал, к сожалению, формально говоря, когда игрок лежит здесь, это другой случай, но он, доказывается, аналогичный.
Вот.
Сейчас мы попробуем этим пользоваться.
Значит, это мы только немножко разомнулись.
Теперь, мы говорим так.
Ну, то есть это в принципе уже намекает, конечно, на то, что, действительно, что когда мы делим…
когда мы делим, то есть когда мы между их сыгрок нашли минразрез, то тогда оказывается, что когда мы берем,
то есть когда мы ищем разрезы между вот парами вершин, парами вершин, лежащими в одной доле разреза,
вторую можно также сжимать.
Понятно, да?
Так что вот такая нот, то есть вот такая вот у нас мечта. Именно между вот этими вот двумя, соответственно.
Да, это конечно правда еще вообще не доказывает, например, такой факт.
То есть верно ли, что минимальный разрез между вот этой вершиной и вот этой вершиной именно такой?
Ну то есть вообще говоря не факт. Нет, в принципе...
Нет, вообще не факт.
Нет, есть конечно... Нет, в принципе, конечно, если у нас была мечта построить дерево гомориху в слабой версии,
ну что такое слабая версия, это типа просто построить дерево гомориху, чтобы просто величины разреза были правильные,
то я могу сейчас предъявить алгоритм ЗН в четвертый.
То есть алгоритм очень простой. А давайте просто найдем вообще глобально минимальный разрез, тупо Шторм Вартером.
Вот там нашли бабах и бабах.
Типа тут какая-то доля, тут такая доля. Я не случайно тут рисую что-то похожее на мета вершины.
Потому что теперь просто идея будет в том, что давайте...
Теперь просто идея такая, между любой парой вершин такой, что одна берется отсюда, другая отсюда, ответ будет действительно вот такой.
То есть вот именно вот этот разрез, правда? А хотя нет, я даже сейчас и в сильной версии построю.
Потому что теперь у меня идея такая, давайте-ка я рекурсивно попробую найти все вот эти вот там минимальные разрезы,
тут какие-то деревья внутри вот этой доли, при этом сжав вот эту.
Как-то, да?
Что?
Да, просто в одну вершину. Ну, по крайней мере, минимальные разрезы здесь все вроде как там связаны.
И тогда эти деревья можно там прицепить. То есть тогда тут получится какое-то дерево, тут получится какое-то дерево,
давайте соединим их ребром просто за абсолютно любые вершины нам по барабану какие.
И получится, казалось бы, дерево в сильной версии.
По крайней мере, появляется такая образ мечты.
Да, конечно, слишком много вопросов возникает, если прямо к этому отнестись предельно формально.
Нет, пока еще нет. То есть на первом шаге это может и хорошо.
Но с другой стороны, а почему, когда вы тут будете искать, тут вообще будет появляться какое-то дерево внутри вот этой штуки?
Ну, там при наличии, допустим, вот этой вот гадости, которую надо куда-то подцеплять.
Так что тут... Чего?
Как говорится, добро пожаловать.
Нет, просто любая, по-хорошему, любая лекция по математике.
Потому что камерзные вопросы могут быть везде.
Самый камерзный вопрос, это когда изучаем...
У вас будет когда-то изучать такие интересные функции, которые, во-первых, бесконечно дифференцируемы, а во-вторых, их носитель ограничен.
То есть это означает, что множество точек, в котором эти функции отличны от нуля, там это множество ограничено.
То есть на каком-то отрезке лежит.
Так вот, камерзный вопрос на экзамене.
А такие функции вообще существуют, кроме нуля?
А то мы тут изучаем какие-то свойства, может мы изучаем свойства нуля?
Чего? Не подойдет.
Синус, косинус, они...
Нам нужны функции, у которых множество точек, в котором эти функции отличны от нуля, ограничено.
Поэтому нет. Просто бесконечно дифференцируемые функции, это не то.
То есть, да, синус, косинус, конечно, да.
Тогда, чтобы оно еще было бесконечно дифференцируемо, допоминаю.
Нет, там есть какие-то там красивые экспоненты есть, да, но...
Все? Нету?
Синус 0,1.
Синус 0,1.
Синус 0,1.
Синус 0,1.
Так вот. Значит, смотрите.
Значит, теперь смотрите внимательно.
Как мы теперь будем искать?
Так вот, значит, вот такая вот, да, лемма разомнулись.
По крайней мере, на первом шаге она нам даже поможет.
А теперь внимание, фишка.
Значит, как мы теперь будем искать?
Значит, дерево гамариху предлагается искать следующим жадным образом.
Значит, смотрите.
В каждый момент времени...
Вот, как бы, это такая первая фаза.
В каждый момент времени у нас будут...
То есть вершины будут разбиты на множество,
и на этих множествах будет построено какое-то дерево.
То есть такое дерево на метавершинах.
То есть это вот...
Заметьте, вот эти ребра не имеют прямого отношения к ребрам исходного графа.
То есть, естественно, могут быть ребра между всеми вершинами.
Более того, по умолчанию вообще можете считать,
что между всеми парами вершин есть ребра.
Ну, просто некоторые из них имеют вес 0.
Вот.
Значит, тут получается какая-то такая,
то да, где-то может быть там малый вершин.
Вот как-то вот так может быть.
Ну, вот.
Но, значит, что это за дерево?
Дерево такое.
Значит, история такая.
Для любого ребра в этом дереве...
То есть существуют две вершины.
Там какие-нибудь IJ.
Такие, что вес ребра, соединяющего их, это строго FIJ.
То есть реально минимальный разрез между вершинами IJ в исходном графе.
И более того, еще важно, минимальный разрез между ними,
это вот буквально вот это вот.
Понятно, да?
Так вот, сейчас будет немножко магии.
Значит, на каждом шаге мы теперь будем делать следующее.
Возьмем две вершины в одной доле.
Вот две вершины в любом ножте.
Первые попавшиеся две вершины.
Вот они там.
J' и I' допустим.
Так вот, идея у меня такая.
Найдем минимальный разрез между ними.
В общем, не просто так найдем минимальный разрез.
А сделаем мы так.
Вот все поддеревья относительно этой вершины временно сожмем,
ну, потом развернем, в метовершину.
Значит, это сожмем в метовершину, вот это сожмем в метовершину,
вот это сожмем и вот это сожмем.
Значит, вот эту штуку мы распилим.
Просто вот распилим.
И у нас тут тогда окажется, что вот у нас тут I' и I'
окажутся в разных долях.
Мы их соединим, естественно, вот тут F' и I'.
И метовершины тоже окажутся.
Да, метовершины окажутся тоже в каких-то долях.
Так вот, ну, допустим, у нас вот этот разрез прошел как-то вот так.
Тогда, значит, этой метовершины цепляем в соответствии с тем, в какой доле они оказались.
То есть вот F' и J', например, оказалось вот в этой вот доле.
Значит, мы ее сюда цепляем.
Вот как-то так.
Ну, цепляем вот за то, чтобы...
Да.
Ну да.
Чего?
Ну да.
Ну, типа того, да.
Так же такая вот радость.
Да.
Ну теперь остается только самое малое, доказательный вариант.
Доказательный вариант.
Какой вариант надо доказать?
Ну, точно.
Ну да.
То есть да, напоминаю, у нас был инвериент.
Нет, ну такие надо доказать.
Ничего не понимаю.
Да.
Да.
Ну есть одна маленькая проблема.
Рисуется она вот так.
Ну, смотрите, дело в том, что вот тут были вершины I и J.
Могло так оказаться, что когда вы распилили эту вершину отодверь, вершина J оказалась не в той половинке, куда подсоединили I.
Нет.
Мы их подсоединяем не в соответствии с этими вершинами.
Мы их подсоединяем в соответствии с тем, какой минимальный разрез мы тут нашли.
И это одна проблема.
Другая проблема еще в том, что, ну по-хорошему, надо еще доказать, что вот этот вот минимальный разрез, вот в этом вот, что мы найдем, он будет соответствовать минимальному разрезу вообще в исходном графе.
Что вообще говоря, мы искали минимальный разрез при условии какого-то там адского сжатия.
Да.
Но второе, но это надо просто аккуратно сделать.
Да.
Конечно же, как бы, доказательство того, что вот этот разрез между I и J, он как бы действительно такой, как в плане величины, так и в плане структуры.
Для этого нужно, конечно, обратиться к это теориям.
Да.
Мы не зря ее доказывали.
Вот.
Ну давайте так.
Мы доказали, что, ну мы, значит, ну просто эту теорию надо теперь очень аккуратно применять.
Вот.
Ну давайте ее, ну давайте ее аккуратно применим.
Ну, во-первых, вот ищем минимальный разрез между их штрих и J-штрих.
Да.
Вот докажем, что вот это все, вот это все под дерево можно сжать в одну вершину там и прицепить ребро.
Ну или просто вот просто сжать это все, как это доказать.
А очень просто.
Дело в том, что как бы что, это за под дерево, что это за ребро.
Это ребро, когда-то мы искали минимальный разрез между какой-то вершиной здесь и какой-то вершиной здесь правда.
Ну ладно, это был просто разрез между какой-то вершиной здесь, какой-то вершиной здесь, но такой разрез нашелся.
И тогда эта теория говорит, что когда мы ищем разрезы между вершинами в этой доле разреза, то вот это...
Вот.
Вот можно сжать.
Но это первая фаза. Хорошо, это теперь сжали. Теперь докажем, что прижатой этой вершине можно сжать вот это вот.
Ну то есть мы по индукции отсекаем листья, пока не приходит...
Ну сжимаем. Нет, ну не листья, а под деревья.
Ну мы берем листья и засовываем их в родители.
Ну можно и так.
Ну да, но правда чуть меньше шагов будет, если мы сожмем сразу под деревья.
Потому что, смотрите, мы показали, что все минимальные разрезы в этой доле можно искать при вот этой сжатой вершине.
Что теперь происходит?
Теперь мы знаем, что между вот этими долями на самом деле есть минимальный разрез, даже при этой сжатой, равный вот этому.
Значит, вот эту тоже можно сжимать.
Ну при тех двух сжатых, соответственно, тогда становится понятно, что в этой доле, ну и так далее.
Да, то есть здесь вроде как пока все аккуратненько и хорошо.
Теперь остается самое интересное.
То есть это приводит нас к тому, что f'g' теперь это действительно адекватный разрез, что так действительно можно.
Мы его буквально построили.
То есть мы сжали все вершины, а потом расписали разрез именно буквально так, как там разрез сказал.
Понятно, да?
Вот.
То переча.
Поэтому единственная проблема, сейчас вот самое интересное, что будет, что нам теперь нужно сделать, это решить вот эту проблему.
Потому что когда вы подцепили, вот было ребро и g.
И вот, допустим, вы его подцепили к половинке, и это оказалась не та половинка, в которой лежит g.
То есть нам теперь просто нужно показать, что в этой вершине, что здесь где-то найдется какая-то вершинка, у которой тут разрез будет такой.
Ну, как найдется.
Ну, как вы уже догадываетесь, то есть по-хорошему надо просто доказать, что разрез f и, то есть вот этот разрез между i и штрих, он вполне себе такой же.
Ну, просто другой вершины, кроме и штрих, тут может в принципе не оказаться.
Так, понятно, о чем мы доказываем, да?
Так, ну поехали.
Так, ну какие у нас тут проблемы?
Так, ну доказываем.
Очень хочется доказать, что, понятно, хотим, что f и g больше либо равно, чем...
Ну, хочется вообще доказать, что f и g равно f и и штрих.
Ну, нам уже известно, что...
То есть так, известно f и g, очевидно, больше либо равно, чем f и и штрих.
Почему это тупо известно?
Да потому что вот этот разрез и g, он минимальный для и g и какой-то для и и штрих, правда?
Понимаете, да?
Вот.
Поэтому отсюда и вот такая радость.
То есть и так, осталось.
Осталось нам показать, что просто f и и штрих больше либо равно f и g.
Понятно, да?
Но с другой стороны, про f и g можно кое-что...
Что?
У нас f и g это очень минимальный разрез.
Да.
Поэтому он меньше, чем любой другой.
Между и и и g.
Да.
А что касается, но про и и штрих, это нам ничего не говорит.
А смотри еще раз.
Рассмотрим вот этот разрез.
Он является разрезом, просто разрезом.
Не только для и и g, но и для и и штрих.
Но для и и g он является минимальным, а для и и штрих он является каким-то.
Но какой-то разрез между и и штрих больше либо равен минимального разреза.
Поэтому получается так.
Осталось, вот хотим доказать вот это.
А как мы это докажем?
А докажем это вот как.
Дело в том, что мы знаем, вот я здесь буду писать, что f и и штрих больше либо равно минимума.
И сейчас я изобретю...
Ну что я изобретю?
Ну изобрету я даже, наверное, понятно, что.
Тут я напишу минимум из f и g.
Да, ну, наверное, f, g, g штрих.
f и тут g штрих и штрих.
Вот такая логичная цепочка.
Так, но давайте думать.
Я думаю, что-то из этого я могу выкинуть.
Что?
Да, вот для этого ребра.
И вот предположим, что она оказалась не в той доле.
Ну мы считаем, что и оказалась в доле с и штрихом, а g оказалась в доле с и штрихом.
Так вот.
Но тогда смотрите, что из этого следует.
Заметим, что из этого следует, вот из этой картинки, что f и штрих, g штрих больше либо равно f и штрих, g.
Ой, значит мы тут цепочку неправильно выбрали.
Нам хочется пользоваться этим неравенцем.
Да, и штрих, конечно.
Но опять же та же причина.
Что это какой-то разрез между и штрих, и g.
И минимальный между и штрих, и g штрих.
Значит, как бы между и штрих, и g штрих он не больше.
Может такой, может меньше.
Ладно, поэтому да.
Поэтому напишем мы немножко здесь по-другому.
Давайте и штрих, и g мы здесь напишем.
Здесь мы напишем g, g штрих.
И здесь напишем g штрих, g штрих.
Вот такая цепочка.
Не факт, что правда, что f и штрих больше на минимум.
У нас цепочка заканчивается в...
Нет, она начинается в и штрихе и...
И кончается в и штрихе.
Да и тить вашу.
Ну ладно.
Хорошо.
Вот так.
А так у нас и было, нет?
Да.
Нет, не правда.
А у нас цепочка есть.
Сейчас тогда.
Сейчас.
Нет, цепочка-то есть.
У нас только и g.
Так, хорошо.
Смотрите, как надо.
Нет, не так надо.
Смотрите, надо и штрих g, раз уж.
Так, что нам еще надо?
Давайте так g и...
А, и все?
Нет, маловато.
Нет, ну да.
Нет.
Ну да, нам надо.
Нет, подождите.
Нам надо тогда, чтобы...
Да, да, да.
Тут придется g и штрих ставить.
Блин, жалко.
Так.
Ну хорошо.
Так.
Чего?
А, нет.
Погодите.
Да, подождите.
Все еще круче.
f и штрих, g и штрих.
Ну, помимо всего прочего в такой картинке, является
еще и разрезом между и и g.
Ну, просто...
Если бы не являлся, значит g было бы здесь, и проблем
бы не было.
Значит, так.
То есть вот такую радость мы можем сказать.
Да.
Ну, равно, как и про другие, но сейчас нам важно это.
Хорошо.
Но тогда что из этого следует?
Тогда получается, что f и штрих g и штрих больше либо
равно f и g.
Значит, да, его можно просто из этого минимумом выкинуть.
То есть это просто написать, что это равно минимум из...
f и g f, g, g, штрих.
Так, я то вытянул.
Да, я то вытянул.
Так, теперь неплохо было бы доказать, что f, g, g, штрих
больше либо равно, чем f и g.
Ну, это, конечно, брехня.
То есть оно на самом деле...
Так как они тут в одной доле лежат, то, в общем-то,
это как бы не факт.
Ну, конечно, оно вот.
То есть мало ли там что.
Но теперь возникает такая фишка.
То есть нам на самом деле ладно.
Вот это неравенство...
Если бы, конечно, доказали, что вот это больше либо
равно вот этого, мы бы победили.
Но на самом деле это, конечно...
То есть на самом деле, в общем-то, это будет не обязательно.
Так.
Так, сейчас, погодите, давайте попробуем.
Больше либо равно, чем минимум.
f и, значит,
запятая f, g, штрих,
и штрих.
Так.
f и штрих больше.
f и штрих.
Это мы точно знаем.
Так.
Но при этом мы заметим, что
и штрих, и ж штрих, он больше либо равен
этому, потому что у нас,
потому что у нас, помимо всего прочего, еще и ж штрих распались.
Неожиданно.
Прямо распали?
Ну да.
Так.
Ну да, и штрих, и ж штрих.
Так, хорошо.
То есть давайте пишем.
f и штрих оказалось больше либо равно, чем
f и ж штрих.
Это мы уже знаем, потому что да.
Потому что у нас тут внезапно и ж штрих.
Мы можем оставить только
f и и штрих больше либо равно, чем
f и ж штрих.
Да, то есть...
Ну да, значит получается равно...
А почему f и ж штрих больше, чем f и ж...
А то же самое.
Потому что это, помимо всего прочего,
этот минимальный разрез, он, помимо всего прочего,
еще и разрез между и и ж штрих.
Да, поэтому разрез для и и ж штрих может быть меньше, чем этот.
Да.
Да.
Равно f и ж штрих.
Так.
Но из этого следует лишь то, что
f и ж штрих оказался
больше либо равно...
А, ну да, это мы и хотим.
Ой.
А мы про ж штрих доказали, да.
А чем-то...
Ну не знаю, мы сможем доказать,
что это больше либо равно, чем f и ж?
Вот как-то не факт.
Потому что про f и ж штрих мы не знаем ничего.
Так что, увы, придется тисаться дальше.
Да, то есть скажу так, это верное утверждение,
но, увы, не сильно помогающее нам.
Так вот, значит, здесь смотрите, какая фишка.
Так вот, значит, мы пока видим, что все разрезы,
которые мы тут в жизни искали,
они отправляют ж и ж штрих в одну долю.
Правда?
Нельзя рассмотреть разрез
между ж и ж штрих,
и там будет два случая.
Либо ж лежит вместе с и
в одной доле.
Тогда этот разрез
является разрезом
для и штрих и ж штрих
и оценивается.
Либо наоборот,
ж штрих лежит в одной доле
с и и ж штрих,
тогда этот разрез является разрезом
для и и ж.
И оценивается уже 1.
Ну вот, вас посмотрите на этот разрез
между ж и ж штрих.
Так, ну посмотрели еще.
Есть доля,
и в доле, в которой нет
и и штрих,
есть либо ж, либо ж штрих.
Тогда мы можем оценить либо
f и ж, либо
f и ж штрих.
Вроде эти
большины нам...
Но так мы можем оценить одну из них,
но не две одновременно.
Мы оцениваем либо так,
либо так.
А f и ж штрих
мы уже оцениваем
f и ж.
Да.
Я говорю, что f и ж штрих
можно оценить либо
f и ж, либо f и ж штрих.
В зависимости от того,
что попадет в другую долю.
При развлечении ж и ж штрих.
Так.
Так.
Так, ну хорошо, давайте попробуем.
Давайте проведем
вот такой, какой-то разрез
между ж и ж штрих.
Тогда в долю с кем?
И штрих?
Нет, ну и штрих непонятно,
они попадут в одну долю или в разные.
Почему же?
Ну, что есть такое?
А сейчас? Я не знаю.
Мы не можем вот уже
в выстроенной
стацури дерева
поделить
для...
Мы там пользуемся каким-то деревом?
Мы там, когда мы сжимали
вершины, мы пользовались тем, что тут две вершины есть,
а тут мы это сидим, доказываем.
Но ведь мы знаем, что ребро
между и штрих и ж штрих
оно нужное,
поэтому все под дерево, которое
висит на вершине, содержащей и штрих
мы можем сжать.
А, ну хорошо.
А, ну хорошо, да.
Так, ну хорошо, да.
То есть если у нас разрез
получился такой,
то тогда оказывается,
что, действительно,
f ж ж штрих
больше либо равно,
чем f
и ж
ж штрих
больше либо равно,
чем f
и ж
и ж
и ж
окей.
А в противоположном случае,
оно больше или равно, чем f и ж
и ж штрих, которое больше
или равно, чем f и ж?
Да, которое мы откуда-то взяли.
Так, если у нас разрез
произошел вот как-то
вот так,
то тогда в зеленой
версии получается, что
f ж ж штрих больше либо равно
чего?
И штрих ж штрих?
И штрих ж штрих.
А эта штука больше или равно, чем
f и ж?
Нет, она...
Нет, мы разве ее по ежи отсекали?
Ну, мы так что...
А, ну да, да, да, да, да.
Больше либо равно f и ж.
Ага.
А, ну все.
А, то есть все-таки больше
либо равно?
Ну...
Угу.
Угу.
Угу.
Угу.
Ух!
Ух!
Если это правда вообще.
Так.
Ну это все, наверное,
хотя почему бы
этому не быть правдой, да?
Просто возможно, авторы доказательства
в это не верили почему-то.
Оригинальное доказательство звучало так. Заметим, что если я сейчас соединил ж штрих каким-нибудь ребром с весом А, то никакой из этих неравенств не нарушится.
Потому что во всех предыдущих разрезах ж и ж штрих отправлялись в одну долю, и это ребро ни во что ни в чем не участвовал.
А здесь, когда мы писали вот это неравенство, мы тут сравнивали только это с этим нотой, а вот это оставалось на месте.
И тогда получалось, что я тут могу еще плюс А написать.
А я могу задрать просто как угодно, поэтому даже если оно мелкое, я могу сделать так, что ф и ж остается.
Оригинальное доказательство такое. В оригинальной статье Гомариху написано так.
Может авторы этого не заметили, а может мы где-то проворались.
Хотя в принципе слету вот бара в этом доказательстве честно говоря я не вижу.
Да, потому что мы выяснили, что между и штрих и ж штрих оптимальный разрез именно такой.
Да, мы это уже выяснили, поэтому если и попало куда-то не туда, то давайте делаем ж и ж штрих.
И тогда это все тоже казалось бы должно быть сжато, потому что мы пользуемся только этим ребром и только вот этим ребром.
То есть вот этими ребрами мы даже не пользуемся, обратите внимание.
Пожалуй, без лишних подхадчик.
Единственная проблема, что к сожалению этот минимальный разрез между произвольными двумя вершинами к штурмартеру не сведем.
Потому что когда мы это делаем в компоненте, мы эти под деревья конечно сжимаем до вершины, но эти вершины остаются вершинами.
И минимальный разрез может оказаться, что это минимальный разрез он просто отсечет вот какую-нибудь вершину от остальных.
И это будет для нас не информативно.
Поэтому доказанная симптомика алгоритма это o от v умножить на find flow.
То есть o от n, насколько вы там поток с нуля ищете.
То есть каждый поток мы прям честно с нуля ищем.
Тем более, что у нас игра формально говоря разный.
Вот такая вот красота.
Но особая красота тут конечно в том, что в итоге получилось.
В принципе, как можно выяснить из одного из кубков МФТИ, не помню этого или предыдущего.
Отсюда можно вывести вообще эпическую теорему про компоненты вершинной косвязности.
Или реберной.
Сейчас там реберная была.
Да, теорема.
Определение.
Давай две вершины назовем реберно-косвязанными, если между ними существует k реберно-непересекающихся путей.
Теорема существует.
Реберная косвязность это отношение эквалентности на вершинах.
Вот доказательства.
Что такое косвязность? Это когда поток между двумя вершинами хотя бы k.
Отлично.
Но тогда если у нас тут от a до b, допустим, у вас тут минимум на пути хотя бы k, то есть все ребра k,
и тут минимум на пути от p до c хотя бы k, то минимум от a до c тоже будет хотя бы k тем более.
То есть мораль. Существуют компоненты реберной косвязности.
Как найти компоненты реберной косвязности?
Построим дерево-бреху, обрубим ребра-мельшика, возрадуемся.
В кубке была задача, правда, на 3-связность, и там, по-моему, компоненты реберной 3-связности можно как-то, видимо, без этого искать.
Не за открытки была задача.
Нет.
Хотя нет.
Ну, я не знаю, там, по-моему, возможно, насколько я слышал, кто-то давал в тексте, что как-то...
То есть нет, как-то вроде можно это...
Нет, мы с вами можем компоненты реберной 3-связности, наверное, найти относительно быстро.
Как-то, наверное, можно.
Да, была задача на открытке, два проспекта, и поездал.
Там, по-моему, реберную 3-связность.
Так.
Ты там решение сделал, конечно?
Нет, да, но тут вытекает...
Там за М плюс М логан.
Ну вот, потому что нет, потому что дерево-бреху, как бы оно вам так на халяву это найти не позволит.
Потому что проблема еще в том, что вам придется реальный поток искать.
Там была задача.
Ну, фишка такая.
В принципе, компоненты...
Ну, то есть я не знаю, как это можно найти.
Можно найти за...
Ну, я не знаю, н квадрат можно найти.
Давайте так.
Ладно, не за н квадрат, а за...
Ну, за n dfs-ов я могу найти хотя бы две вершины, которые...
Так, ну ладно, начнем с того, что за линию можно мосты найти, допустим.
3-связности.
Да.
Ну, допустим, во-первых, можно найти реберную 2-связность для начала.
Ну, так, для удобства.
Ну, чисто для удобства, чтобы мосты выкинуть и не думать.
То есть, допустим, у нас граф реберную 2-связан.
Теперь очень хочется найти какие-нибудь...
Ну, в идеале хочется найти две вершины, которые реберно именно 2-связаны, но не 3-связаны.
Как это сделать?
Ну, я умею только...
Ну, слетаю могу как бы только взять одну вершину a и перебирать все вершины b.
И для каждой из них проявить верно лишь, что они хотя бы 3-связаны.
Это делается тремя dfs-ами.
Ну, точнее так, это ищем поток, но поток в данном случае ищется просто тремя dfs-ами.
Вот.
Так, хорошо, нашли.
Ну, вот.
То есть там 3 dfs-а, но это правда уже требует от ей операции.
Ну, хорошо, если вы ни одну такую вершину не нашли, значит вы торжественно отпиливаетесь.
Хотя...
Ну, вот.
Хотя...
Нет, тут, конечно, красота заключается в том, что вы тут перебираете вершины b1,
допустим, какие-нибудь b2, допустим, b3 и так далее.
И пока вы тут 3 пути находите, значит все эти вершины в одной компоненте 3-связанности с ней находятся.
А как только вы находите какую-нибудь вершину b, которая тут 2, тогда можно заметить,
что тогда она 2-связана, видимо, не только с этой вершины, но и со всеми вот этими.
Вот.
Ну, типа того.
Да.
Ну, по факту, правда, все равно получается вот этот алгоритм.
Ну, просто заметим, что в этом алгоритме вы поток ищете тремя...
Ну...
А что происходит в варианте, когда мы делаем не максимальный поток, а максимальный бизнес?
Нет, ну тут не суть, смотрите.
Нет, просто в данном случае получится так.
Нет, ну да, хорошо, допустим...
Хотя нет, с разрезом тут, конечно, напряг, но...
Хотя просто нет, фишка в том, что, по идее, как бы a и b1 вы уже, допустим, точно знаете,
что они в одной компоненте, поэтому в будущих поисках вы можете a и b1 тупо жать.
Вроде как.
Интересно, если жать вершины, там, 3-связанность, это не попортится?
А нет, может попортится, потому что мало ли, может она...
А там 2-связанность b, 2-связанность b1, но если их объединить, там пути риска появляются.
Ну, потому что у вас тут a или b там надо искать.
Нет, это, конечно...
Хотя нет, в случае зрения потоков так быть не должно.
Вроде как.
Хотя нет, если потоки...
Сжимать их не получится, но получится, что...
Нет, хотя стоп, если вы найдете разрез между a и b величины 2,
то тогда очевидно, что b1, b2, вот эти все вершины должны просто в одну долю попасть.
Потому что в противном случае мы нашли между a и b1 разрез величины 2,
такого не бывает, как мы выяснили.
Значит, они окажутся здесь, и у нас все хорошо.
Нет, просто к чему я это?
Это получается, что, по крайней мере...
Хорошо, да, a и b разделили, причем эти все вершины, допустим, с этой стороны находятся.
То есть, да, эти вершины находятся с этой стороны.
То есть, про них мы все знаем.
Причем, по-видимому, да, мы знаем, что...
Правда, теперь дерево гамариху говорит, что эти вершины теперь можно сжать в одну
и искать DFS и дальше здесь.
Получается, в итоге, алгоритм за n квадрат.
Так, тут получается за n квадрат.
Но, видимо, существует алгоритм, который предлагает делать то же самое, но быстрее.
Может быть, там конкретно свойство, именно конкретно 3 связности есть.
Я не знаю.
Потому что, в принципе, такой алгоритм нам позволяет просто компоненты k связности искать.
За... там сколько получается?
Ну да, за o от n. То есть, за o от v умножить на e умножить на k получается алгоритм, на самом деле.
Да, так алгоритм за ve, а так вот это.
Окей.
Вот.
Но взгляд такой есть.
Так что, по крайней мере, про k связность можно поговорить.
Так, ну что?
Есть ли тут еще какие-то вопросы?
Ну, может и да.
Хотя...
Ну, пара.
Если ты ищешь дерево за v-куп, как минимум, за v-куп, на что-то еще, то что ты будешь делать на этом дереве?
Ну, это правда.
Ну, там...
Все что угодно, для всех.
У тебя запросов может быть.
Нет, может быть.
Ну, там просто...
Ну, тогда там, скорее всего, предпочетно что-то работать.
Нет, может быть...
Знаете еще, что может быть?
Нет, еще могут быть всякие вещи такие, что...
Может быть, вам дадут какой-нибудь граф со специальными свойствами, который позволит вам найти дерево гомориху быстро.
Просто вы будете что-то знать.
И тогда, собственно, да, будет получаться хорошо.
Так что, ну, как пойдет.
Так повезет.
Нет, погодите.
Сейчас на камеру это обсуждать не надо, потому что если придумывается реально интересная задача,
не стой, не стой, потому что кто-то выяснил, что, оказывается, решение более опубликовано на Ютубе.
Просто никто не знает.
Нет, или наоборот, все еще хуже будет.
Окажется, что, значит, решение опубликовано на Ютубе, а в раунде участвовал там кто-то из слушавших лекции.
То есть, если это будет кто-то знать, то это будет...
Это будет просто реально выглядеть как слив.
То есть, нет, конечно...
Нет, понятно, что, конечно...
Знаете, как это будет? Никто ничего не докажет, но коситься будут.
Это нормально, что люди, которые учатся в одном месте...
У них набор идей пересекается совсем.
Нет, это, конечно, да.
Но тут...
Нет, ну да, да, да.
Нет, ну тут вопрос нет.
Среди нас-то понятно, да.
Я имею в виду, что вообще лекцию точно будет слушать, наверное, тот, кто...
Там будут слушать те, кто будут готовиться к экзамену.
Нет, не есть вестиха.
Ну, как повезет.
Нет, хотя нет.
Как показывает практика интеллекту, иногда кто-то дослушает.
Нет, я могу даже сказать, кто.
Потому что, например...
Как-то, как выяснил я нот.
Потому что как-то ко мне приближал Леша Васильев.
И просто говорит...
И сказал, что у меня там в лекции ошибка.
Потому что выяснил, что он, оказывается, читал лекцию по гряди уголовных угол КШ.
Там, собственно, готовился по...
Одной из прошлого их записи сказал, у вас там в доказательстве ошибка.
Ну, доказательства там где-то было.
Ну, там даже не ошибка была.
Просто где-то недостаточно точно проговорили.
То есть там был какой-то момент, который надо уточнить.
То есть, естественно, он уточнялся.
Но как бы это...
Это пример того, зачем кто-то может это послушать.
Ну, и просто на самом деле я не знаю.
На самом деле, честно говоря, других мест, где можно послушать лекцию по дереву Гамариху на русском языке, я слету не знаю.
Но я не гарантирую, что их нет.
Ну, как вам сказать?
Ну, во-первых, там Паша Маврина не сильно много продвинутых, прям совсем продвинутых лекций читает.
Потому что у него там на слету есть курсы ЭТМО, но он все-таки это более стандартный.
Какой-то более...
Он там линкат читал, у него там ошибка была.
Да.
Вроде нет.
Нет, но про линкат еще вопрос, он какую часть рассказывал.
Он мог...
Да, реально.
Он взял другой потенциал.
Нет, он взял другой потенциал, но у него ошибка.
Просто он не учитывал, потому что у него потенциал меняется при операции.
Там он одноводится, конечно, у него ошибка была.
Ну, нет, нормально, да ладно.
Но там еще проблема, что в половине лекций он еще любит этого.
Что-то он читал по-английски.
Ну, не потому что он любит по-английски читать, а потому что там лекции, видимо, рассчитывались на не только русскую языку и аудиторию.
В принципе ладно, тоже ход на самом деле.
Но это уже другой вопрос.
Ладно.
Что у нас тогда?
Чем хочется закончить?
Чуть-чуть, наверное, еще посидим, потому что пару мелочей хочется попробовать разобрать.
Я, правда, говорю про статьи, которые были найдены неделю назад.
И это тоже.
Нет, ну там просто такие простые, что хочется их добить.
Чего?
Да, я их смотрел.
Не могу гарантировать, что полностью идеально, но есть подозрение, что основные идеи поняли и сейчас добили.
Ну, потому что с этой точки зрения было очень жалко, что у нас сейчас вон с той доски исчезли все данные про Push Relay.
Ну, как сказать, если у нас были электронные доски, то, конечно, да.
Нет, там, как считать, я помню, как-то в 57-й я читал про Push Relay, там действительно просто оказалось, что все, что нужно было, там на самом деле уместилось на доске одной.
Вот, там было в этом смысле красиво.
Ну, можно было, да.
Ой, доску перевернуть, ну, знаете, это как-то стандартная, да, как это, это называется, чешка и славака решили воссоздать нацию.
Понятно каким образом.
Да, чешка и славака решили воссоздать нацию чехс-славаки.
Да, следующий кадр, значит, стоит девушка, у нее на руках ребенок.
Кто? Девушка грустна. Славака, чех.
Значит так, парень берет ребенка, так переворачивает.
А вот теперь хорошо.
Ну, что-то такая какая-то ассоциация, да.
Как говорится, хотите более смешных шуток, смотрите современный КВН.
Ну, там, правда, там в той же игре будут, правда, более мощные шутки, на самом деле, да.
А, собственно, в той же шутке было, собственно, в той же игре была вот эта, собственно, про ГУС-услуги.
Да нет, так как мульти просто, да, смотрите, просто КВН 2004 год, третья, одна, восьмая, все, игра уже вышла.
Так что можно, я, кстати, в сериале рекомендую, очень хорошая игра получилась, действительно.
Ссылка в описании.
Да-да-да, для тех, кто не умеет губить, да-да-да.
Вот так вот.
Ладно, значит, давайте посмотрим, что хочется про Pushy Label доказать.
Ну, вообще так, первая идея, хочется в Pushy Label впилить линкат.
Да, очень хочется.
Ну, потому что, смотрите, в чем у нас вообще задача?
Мы знаем, что если мы делаем Pushy Label АВК, то у нас получается В квадрат Е.
А давайте вспомним, а за счет чего В квадрат Е?
Ведь заметим, у нас там почти всего ВЕ.
Например, у нас ВЕ насыщающих пушей, помните, да?
А еще у нас серые лейблы суммарно за ВЕ работают.
Вот, то есть единственная у нас проблема есть не насыщающий пуш.
Что такое не насыщающий пуш?
То есть когда избытор кончился, а ребро нет.
И мы выяснили, что если делать АВК, то таких будет не более, чем В квадрат Е.
Правда, есть оговорка.
Правда, мы там придумали кучу способов, как сделать так, чтобы у нас таких пушей было не более, чем В квадрат.
Это в прошлый раз было, помните, да?
Ну, как мы это делали?
Но одна из технологий, на которой сейчас будем базироваться, она базировалась на очереди.
То есть мы храним в очереди все вершины, которые сейчас избыточны.
То есть просто храним.
Технология была, что мы достаем очередную и делаем дисчарч.
Делаем дисчарч, попутно, если там мы где-то благодаря нашим пушам из этой вершины появился избытор,
то есть был ноль, стал не ноль, то значит мы ее в конец очереди пихаем.
Но это такая технология, как мы доказывали, работает за куб.
Почему она работает за куб?
Ну, например, потому что у нас есть, выясняется, что когда мы пройдем очередную итерацию очереди,
то есть там можно очередь говорить так, что первая итерация то, что было изначально добавлено,
вторая итерация, что было добавлено после, ну и так далее.
И тогда оказывалось, что на каждой итерации либо был выполнен релейбл,
либо просто максимальная высота избытка уменьшилась на один.
А этот максимум увеличивается суммарно не более чем на релейбл,
а суммарно релейблы увеличивают этот максимум не более чем на v квадрат,
ну 2 v квадрата, поэтому получалось хорошо.
Но это краткое содержание, помните?
А теперь идея такая, хочется попробовать попихать туда линкат.
Каким образом?
Ну, просто возникла мысль такая,
потому что дело в том, что ненасыщающие пуши часто они образуют целые цепочки.
То есть может быть окажется, что ненасыщающий пуш из этой вершины пропихнул поток сюда.
А потом выяснилось, что весь этот избыток скушался сюда,
то есть это такие пуши, которые указатель по ребрам не сдвинули.
Ну, потому что если сдвинули, то, в общем-то, ничего интересного.
Так вот, возникает такая идея.
Она в динице у нас уже возникала, применим ее и сюда.
Давайте в каждый момент времени, то есть здесь у нас есть указатель,
показывает на какое-то ребро, которое еще и смотрит по высоте вниз,
и там еще и пропускная способность не ноль,
то давайте заметим, что эти ребра образуют подвешенные деревья.
Ну, как-то так они их обновляют.
Это типа актуальное ребро.
Или даже текущее ребро.
Текущее ребро тут, конечно, двусмысленно в этом контексте.
Да, ну ладно, не путайте слово текущее и протекающее.
Вот так.
То есть текущее, которое current.
Нет, current это да, но просто по-английски...
Нет, current оно как бы к самой жидкости вроде слова не имеет отношения.
Да, это просто каламбур имеет мысль.
Нет, там есть отношение к потокам в виде concurrency, конечно,
но это другие потоки.
Current, который поток, кажется, воды тоже.
В реке, да.
Current это течение или поток.
Или также значение топ, село, толка или течет топ.
Теплый или current это течет топ.
Печально, ну ладно.
Ладно, все, хорошо, не победили каламбур.
Хорошо, ладно, ничего не поделаешь.
Бывает.
Значит, смотрите, у нас получается такое дерево.
То есть получается вот такие деревья.
Правда, это именно деревья.
То есть это не обязательно просто деревья.
Такие текущие вершины можно действительно так создать.
Что мы будем делать?
Инвариант.
Мы будем пытаться...
На уровне идеи хочется пытаться делать так.
Давайте создавать такие ребра, какие есть, какие уж деревья есть,
и пытаемся на них что-то сделать.
Идея возникает такая.
Допустим, у нас тут неожиданно образовался избыток E,
которое мы очень хотим пропихнуть.
Но у меня идея такая.
Давайте пропихивать это не только по вот этому ребру,
а ведь можно же до упора пропихивать в некотором плане.
То есть мы можем сделать push по этому ребру,
потом push по этому, потом push по этому,
потом push по этому, потом push по этому.
Возникает вопрос, что дойдет досюда при таких push?
Давайте предполагать, что тут пока пусто.
Но тогда, очевидно, надо на линкате просто взять минимум.
Вот, допустим, вот он.
Тут полезно будет из всех минимумов брать самый ближний корень.
И тогда окажется следующее.
Досюда дойдет ровно столько.
И мы можем, в принципе, сказать, что у нас сейчас
по этой штуке протекло вот столько,
и после этого это ребро убилось.
Можно сказать, убилось.
И тогда в этом месте мы просто делаем cut,
и указатель сдвигается на какие-то следующие ребра.
Но правда, формально говоря, мы не имели права делать push ровно с тока,
потому что всегда push делался ровно с тока сколько можем.
Поэтому вполне вероятно, что прописная способность этого ребра
была меньше, чем вот это е.
Поэтому по-хорошему нам придется тут вайликом это делать
до тех пор, пока мы в какой-то момент не упремся.
То есть закончится этой ситуацией.
Ну, давайте вот это ребро пока временно не трогаем,
просто отпилили пока и все.
Чем это закончится?
То есть заканчивается эта идея.
То есть заканчивается тем, что в какой-то момент
что-то отпилили, тут отпилили.
Ну, короче говоря, заканчивается тем, что у вас тут в е остался какой-то путь, и выяснилось, что у всех вот этих ребер профессиональные способности больше, чем е.
То есть это означает, что у вас тогда происходит просто цепочка ненасыщающих проталкиваний.
То есть вы можете просто там... Ну, понятно, все эти проталкивания вы делаете как бы условно за логарифом, да?
Ну, потому что вы там в дереве, ну, делаете это отложенные пуши, так сказать.
Как мы еще раз, мы взяли минимум, да?
На всем этом пути минимум отнять, а нулевые отрезать катом.
Да, нет, если... Какие из них нулевые?
Ну, в линкате у нас такая опция есть.
Да, ну, будем считать, что линкат это такая магическая структура данных, которая не просто ищет минимум на пути до корня, она еще и знает, где он находится, причем у всех минимум находится самый ближний к корню.
Ну, минимум найдем.
Но он же поддерживает только минимум, не арк-минюм. Мы еще не знаем, где это минимум на пути лежит.
Ну, сделаем, ой, ну, сделаем аккуратный спуск в плей-дереве, например.
Ну, во-первых, аккуратный спуск.
Но у нас опять-таки несколько меню на пути есть, и нам нужно для всех этих вершинок, из которых идет вот это ребро минимального веса, и у катателей этого ребра дальше.
Ну, да.
Нет, смотрите, нет, мы знаем, что как бы нету.
Да, согласен, согласен. У нас же всего же в игре, поэтому все хотят копираться и все делать, согласен.
Ну, вот, да и да. Но не говоря уже о том, что, я говорю потом, там это все равно, спуск делается аккуратным спуском в плей-дереве, там вроде потенциалы не портятся.
Да, тут уже надо вспоминать потенциалы, но мы сейчас не будем делать, просто поверим, что это делается.
Это будет в экзамене.
Ой, ну, на экзамене у вас будет время подумать.
У вас будет время подумать до экзамена.
Ну, вот.
Так вот, фишка просто такая, что когда вы, но тут правда еще фишка, когда вы этот минимум ищете, и вы ищете, когда этот минимум оказался, когда он оказался меньше либо равен Е.
Потому что если это, если минимум оказался строго больше Е, то все, что у вас произойдет, это вы просто по этому пути пропустите это Е и ребра не убились.
Просто это Е, этот избыток Е переместился вот сюда, в корень.
Вычитание на пути.
Да, но это тоже как бы, верим, что умеем такие вещи делать.
Ну, отложенные операции на сплей-дереве, наверное, мы умеем делать.
Надеюсь.
Нет, если на экзамене выяснилось, что не умеем, то, конечно, это будет очень грустно.
Да, да, да.
Нет, ну, я не хотелось бы, чтобы это было по принципу, да, все, что было в первом семестре остается в первом семестре.
Ну, не хотелось бы.
Нет, ну ладно, в данном случае, конечно, аккуратно сослаться, наверное, можно.
Но я просто, если это слету не будет очевидно, то скажу, ой, нет, а ну-ка уточните как.
Нет, ну на уровне примерности нет, ладно.
Нет, вряд ли я там буду свирествовать, а ну-ка, распишите мне сплей-дерево полностью.
Вы захотите применить здесь софт-хип?
Не, не надо. Значит, смотрите.
Значит, идем дальше.
Значит, смотрите.
Тогда у вас что происходит?
Вы тут будете, конечно, вот это вот упихивать, упихивать, упихивать, удалять ребра, удалять ребра до тех пор пока.
Но заметим, что так как каждое удаление ребро, это по сути его насыщение, то конкретное насыщение у вас будет не более чем логариф, правда?
Не более чем нм, суммарно, правда?
Поэтому получается, с насыщенными получается, там все это работает за нм, пока логн,
Ну, по крайней мере, на уровне идеи.
Но плюс еще без иксов.
То есть бывают еще просто вот эти вот проталки.
Когда просто мы вдоль пути просто что-то сделали не насыщающее проталкивание, никто не убился.
Чего?
Ну, каждая такая штука логарифом.
Нет, ну каждая такая штука логарифом, а теперь у вас есть какой-то вопрос.
А сколько таких штук?
Ну, та же оценка нм, нет?
Да, потому что мы после каждого, если мы будем до упивка проталкивать, то у кого-то указание сдвинется.
Не, не факт.
А вдруг тут профессоры способности 5, 7, 9, а вы хотите проталкнуть 2?
Так это та же логика, что у нас все чередями.
Ну, как сказать, да.
Но теперь надо думать аккуратно.
То есть к чему это приведет?
Это приведет к тому, что у вас, да, вот у этой вершины показатель, то есть у этой вершины перестала быть избыточной,
а вот это стало, но правда у нее при этом высота уменьшилась.
Может нам это как-то поможет?
Правда, как нам это поможет?
Все это не очевидно.
Ну вот, как нам это поможет?
Ну, в принципе, нет.
Но с другой стороны, давайте смотреть.
Что нам тут хочется делать?
Давайте попробуем аккуратно.
Хотя нет, можно попробовать это просто оценить.
Но первое, что можно, как воспользоваться тем, что у нас просто уменьшилась высота?
Хочется, конечно, очень соблазнительно ввести опять потенцеваль.
На этот раз просто сумма весов избыточных вершин.
И действительно, казалось бы, каждая такая операция уменьшает потенциал.
А расти этот потенциал будет не более чем.
Но правда, с другой стороны, как мы воспользуемся тем,
что мы тут пробежались аж на подсыпочке?
Как мы этим будем пользоваться?
Будем мы, видимо, пользоваться.
У нас же был потенциал максимум из высот, вершин с избытком.
Ну, был максимум.
К сожалению, он нам не гарантирует, что максимум у нас как-то упадет.
Поэтому тут действительно не все так просто.
Правда, тут мечта заключается в том, что, например,
на уровне мечты очень хотелось бы, конечно, чтобы...
Теперь вот думаю, возникает вопрос,
а куда этот избыток из этой вершины делать?
В идеале, на самом деле, конечно, ничего страшного не будет,
потому что в идеале так.
Если мы прям идеально храним все ребра,
текущие, которые есть, мы про в линкате храним,
то тогда получается, что если мы тут уперлись в какую-то вершину,
в этом смысле уперлись в какую-то вершину и дальше хода нет,
то значит, мы из этой вершины прямо сейчас должны сделать релейбл.
Понятно, да?
А релейблов у нас всего n квадрат.
Получается, каждая такая ненасыщая штука предшествует релейблу,
значит, без нее получается n квадрат лог n,
и того у нас получился уже на халяву алгоритм nm лог n.
Но да, в эти nm лог n еще входит,
что когда вы находите новое ребро, вы должны сделать линк,
а когда оно насытилось, вы должны сделать кат.
Нет, хотя нет, есть еще одна маленькая подлянка.
Когда вы делаете релейбл из какой-то вершины,
вы должны убить все вот эти ребра, которые в нее ведут.
Но это на самом деле не сильно страшно.
Потому что вы приближитесь за от токчащих из нее ребер,
как входящих, так и исходящих,
это одинаковое количество, и просто лишнее это все сделаете.
В сумме получится лишних операций nm лог n тоже.
Но это на самом деле для нас не достижение.
Если бы у нас была цель составить алгоритм за nm лог n,
то с динецом было бы проще.
Но тут приходит голубик итальян и говорят,
а давайте зафиксируем константу k, которую выберем позже.
И будем в этих деревьях следить еще за одной наглой вещью.
Мы будем следить за тем, что размер каждого дерева
не превосходит k.
Вот прям следить будем.
Да, именно.
Инвериант такой, все вершины так же в очереди,
обрабатываются они по очереди.
Инвериант звучит так, что у нас в каждый момент времени
есть какие-то деревья,
но при этом важно, что все активные вершины
являются корнями деревьев.
Активные в смысле избыточные.
По-хорошему говоря, если у нас так произошло,
что мы просто пихнули до корня и ребра не убились,
то эта вершина отправляется в очередь,
если ее там еще не было.
Понятно, да?
Ну и теперь давайте думать.
Но тогда, когда такой корень,
тогда получается, что когда мы достаем из очереди вершину,
значит она избыточна,
и мы видим, что она по-любому корень.
Что мы тогда делаем?
Ну делаем мы следующее.
Понятно, мы тут,
как положено, согласно диктатю,
ищем следующее хорошее ребро.
Ну понятно, ладно, если не нашли,
то удаляем вот эти ребра
и делаем релебл.
Временно останавливаемся.
Пихнув, может, вершину куда-нибудь в очередь,
а можно и не пихнуть.
А если не пихнули,
значит там какой-то релебл,
а если мы ребро нашли, то что делать?
Тогда мы замечаем, что это ребро,
тогда мы пришли в какую-то вершину,
которая в каком-то ленткате лежит.
Не обязательно это конец
какого-то пути,
то есть там всякие там
бла-бла-бла-бла-бла,
вот это вот все.
Нас начинают выгонять?
Да.
Можем, но не хочется.
Тогда возникает действительно
естественная идея.
Так, ну то есть действительно,
давайте сделаем,
ну то есть идея такая, давайте сделаем push
по этому ребру, нет, мы не будем это ребро
добавлять в ленткат, мы сделаем
тупо push.
Вот.
Значит,
то есть делаем
соответственно push.
Ну, точнее так,
если он оказался,
нет, точнее так, придется все-таки
добавить его к ленткату,
если этот push оказался не насыщающим.
Тогда мы делаем
соответственно push,
а из этой вершины
тогда уже делаем тот пропихон
до конца, который мы уже говорили раньше.
То есть наша же цель, чтобы все избытки
только в корнях остались.
И тогда у нас два варианта.
Ну, тогда у нас некоторое время будут удаляться
ребра, но суммарные удаления они будут
работать
за n лока, либо в какой-то момент
они закончатся.
Правда, единственная проблема, что это ребро
мы добавлять должны не всегда.
Потому что мы же
следим за мистическим вариантом.
Ну, здесь идея такая,
если оказалось, что можно
ребро добавить, и беды не будет.
То есть размер остался меньше, либо равно k.
Ну, в общем-то тогда все делаем
и не паримся.
Понимаете, да?
Вот.
Ну, вот.
Ну, а, соответственно,
а что делать?
Ну, вот.
Ну, а что тогда делать, если не получилось?
То есть если размер оказался
больше k. Ну, тогда мы просто
тогда мы просто
может быть за 1
пропихиваем поток здесь.
Вот.
Ну, вот.
И, соответственно,
делаем аккуратный пропихон
сюда.
Вот, понимаете, да?
Да, но потом
не забываем, особенно если это ребро
оказалось насыщающим, то есть
если оно насытилось, то не забываем
продолжить работу здесь.
Ну, теперь возникает вопрос.
Чем нам это помогло?
Ну, мечта оптимизации у нас, конечно,
заключалась в том, что у нас теперь, казалось бы,
куча операций работает за
nm log k.
Да?
Сейчас можно еще раз
повторить, что мы сделали?
Мы...
Когда мы вообще
это все делаем?
Мы делаем, когда у нас
мы запихнули какой-то астротопии
и не встретили
ни насытили, ни одной из ребров.
Ну...
Какую ситуацию мы рассматриваем?
Вот когда мы там решаем
добавлять нам дерево или нет?
Ну, мы пока просто...
Ну, мы проверяли, верно ли,
что если я сейчас это ребро добавлю, то
размер этого дерева будет больше k, да, или нет?
Да, когда мы добавляли ребро?
Когда... Ну, по сути оно добавлялись,
ну, мы его спокойно добавляли, когда
этот размер дерева не превосходил k.
Зачем мы его добавляли?
Мы же там пропихивали прямок,
как хотели какой-то...
Нет, ну там идея в том,
что мы его тогда добавляли, а дальше
пропихивали просто в общем порядке.
По всему этому.
То, что происходит при релейбле?
Нет, не при релейбле.
Нет, у нас новая операция,
вот эта вот, пропихни
до корня.
Ну, вот так вот.
То есть если
размер дерева позволяет, мы здесь подключаем
к этому дереву и просто пихаем до корня.
Да, просто я бы сказал,
это делаем.
Потому что в этой вершине мы заканчиваем делать.
Да.
Да.
Но это, погодите,
мы как бы ее отправим в очередь,
в порядке очереди ее обработаем.
Потому что, может, выяснилось, что вот уже эту вершину
могла выяснить, что надо релейбл делать.
Вот.
Но могла быть фишка, что это ребро
нельзя добавлять, потому что дерево будет слишком большое.
Ну, тогда нам придется сделать
пуш здесь, насыщающий
или не насыщающий. Да?
И потом после этого еще, значит, делать тут
вот это до проталкивания.
А где мы выиграли?
Что?
Почему
мы сэкономили?
Ну, просто мы сэкономили на том, что если
размер дерева не N, а K,
то как бы вся операция делается не злог N, а злог K.
То есть вот такая у нас мечта.
Правда, единственная проблема, что
операции с деревьями могло быть больше.
Вот.
Потому что нам тут
пришлось как-то
чуть поменьше делать, чуть поменьше прописывать.
Вот.
Но давайте думать.
Значит,
за счет чего у нас
не N,
ну,
потому что
заметим, смотрите, просто проблема такая.
То есть, ну, за сколько все это работает?
Ну,
по-хорошему это работает, можно оценить,
как там N, M,
log, там,
ну, как бы N, M,
log, K, плюс что?
Плюс количество ситуаций,
когда надо было что так, что эдак,
до пропихивать до конца, и ничего не поменялось.
Правда?
Ну, потому что, смотрите,
каждая попытка пропихивания
приводит либо к насыщению какого-то из этих
ребер, либо к тому,
что мы просто тут пропихнули все и остались до конца.
Вот. То есть, каждая такая
операция делается, ну, каждое
насыщение, ну, насыщение у нас всего
O от N, M, и каждое
залог K мы там находим это ребро,
там, откатываем,
катим его, то есть, отрезаем.
Понятно, да?
Но также у нас есть еще вот эти операции,
когда мы тут взяли из вершины и вот
в какой-то момент все-таки
в конце допихнули, что так,
что эдак.
К чему это могло привести?
Но, наверное, каждая такая операция
могла
привести к тому,
что вот, значит, эта вершина стала
новым избыточным корнем,
и мы его были вынуждены
добавить в очередь.
Что?
Что, значит, не работает?
Нет, алгоритм вот у нас работает.
Мы выясняем только, за сколько оно работает.
Что большое?
Где?
Нет, мы следим, что оно
не является большим.
Нет, ну, тут мы...
Вот.
Но тут смотрите, какая фишка.
Дело в том, что, да, то есть,
то есть, итоговое такое проталкивание
просто сделает нам в конце лишнюю
активную вершину.
А может, даже и не сделает
и нот, а может, даже и не сделает.
Но хотя заметим следующее,
что...
Но с другой стороны, заметим, что
насыщенным ребром может быть как эти ребра,
так еще и в случае чего даже вот это ребро, правда?
И таких операций
тоже нет.
То есть, как бы,
в NMLOC-K
входят только...
То есть, не входят в NMLOC-K,
то есть, у нас пока
не оценены только такие
проталкивания, когда тут
неожиданно, что и этот пушни насыщающий,
то есть, тут обнулилось, да?
И вот тут ничего нового
не появилось, да?
Ну, тогда это... Нет, мы
не продолжим, по идее, мы эту вершину
в очередь пихнем, если ее
там нет.
Чтобы она там была, это была бы
мечта.
Вот.
Так.
Нет, тут весь какой-то вопрос пришел не преподаватель, да?
Ну вот.
Нет. Так, ребят,
на всякий случай мы тут можем заниматься бесконечно
долго. Сразу
предупреждаю.
Вот я и говорю.
Нет.
Формально оно уже закончилось,
но мы тут можем сидеть бесконечно долго.
Так говорят. Нет.
А вот давайте так. Ну, просто
нет. Ну, давайте так. Мы в любой момент можем тут
так сказать, попытаться остановиться.
Да. Не хотел бы, конечно. Тем не менее.
Тогда, если он придет, тогда мы как бы готовы.
Но пока преподаватель не пришел,
почему именно без слова говорят, то мы хотели пока продолжить.
Что?
Мы закончим.
Постараемся к этому закончить.
Так вот.
Ладно.
Ну, просто да. Да.
Мы люди такие. Нас надо выгонять, потому что
мы любим алгоритмы.
Вот. Значит, смотрите.
Теперь давайте думать. Что у нас
произойдет?
Если у нас произошел вот этот не насыщающий
проталкиваний, тогда у нас либо вот эта
вершина, либо эта вершина добавилась в очередь,
либо она уже там была. Правда?
Но заметим, что если
она там уже была, значит, количество
активных вершин, которые у нас сейчас вообще есть,
у нас в результате этой операции
уменьшилось.
Понимаете, да?
Но заметим, что у нас суммарно
вообще что происходит?
А когда у нас количество активных
вершин вообще
увеличивается?
Оно увеличивается либо вот в таких операциях,
когда тут этой вершины не было.
Либо в процессе,
когда у нас тут что-то насытилось.
Ну, потому что тут в процессе
могло быть, что мы тут вот это
пихнули, тогда у нас вот
эта вершина могла добавиться, а могла
не добавиться.
Потом вот эта вершина могла добавиться, могла не добавиться,
и так далее.
но просто я хочу сказать что на самом деле все надо то сейчас как бы надо еще добавить
там что-то типа кулака где кулака это сколько раз вершины суммарно будут добавлены по адресу
все ну не судьба да ладно значит ладно вам повезло значит это не войдет в экзавер да
