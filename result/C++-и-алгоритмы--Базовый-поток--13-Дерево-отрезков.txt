Мы сегодня продолжаем говорить про задачи RMQ-RSQ. В прошлый раз, я напомню, мы поговорили про то,
как решать задачу статик-RSQ с помощью массива префиксных сумм. Поговорили о том,
как решать задачу статик-RMQ с помощью разреженных таблиц. Тут надо сказать несколько моментов.
В прошлой лекции в качестве формулы для запроса разреженной таблицы была написана следующая вещь.
Если мы хотим найти минимум на отрезке от L до R, то нужно обратиться к следующим элементам.
Естественно, в качестве K мы берем алгоритм 2-ичный R-R плюс 1, округленный вниз.
Обращаемся к элементам K, L, к элементам K, R-2 в степени К, и тут надо написать плюс 1.
Вот этот плюс 1 мы потеряли. Просто потому что, если мы возьмем, начиная с этого элемента, два степеника элементов,
то мы закончим в позиции R. Вот первый момент. Второй, мы не обсудили, какие вообще операции
можно осуществлять с помощью разреженной таблицы. Давайте кратко обсудим, какие вообще у нас есть
требования на операцию в случае разреженных таблиц. В общем-то, понятно, что, как и в любой другой
структуре данных, нам нужна ассоциативность. Второй пункт, что еще? Что нам было необходимо для
разреженных таблиц, чтобы она корректно работала? Идемпатентность. Да, обратимость нам не нужна.
Идемпатентность. Да, ну почему она нам была нужна? Потому что, если мы хотели посчитать минимум на
отрезке, то мы говорили, что мы его разбиваем на один подотрезок, на второй подотрезок. Эти подотрезки
могут теоретически пересекаться. Идемпатентность нам гарантирует, что операция будет посчитана
корректно. Вот. Значит, на самом деле этих двух операций вполне достаточно. Ну и давайте то же
самое сделаем для дерева Фенвика. Значит, мы обсуждали дерево Фенвика. И давайте обсудим,
какие там требования на операцию. Ну, первое классически это ассоциативность. Второе требование
это коммутативность. Это неочевидный пункт, поэтому я оставляю его в качестве упражнения. В общем,
посмотрите, где там на самом деле нужна коммутативность. Спойлер она там нужна. И третье
свойство, какое? Естественная обратимость. Да, ну потому что в случае суммы, скажем, если нам
дан массив, напомню, если мы хотим посчитать сумму на каком-то отрезке, то сумму на отрезке мы
сводим к суммам на префексе. То есть мы считаем сумму на таком префексе, сумму на таком префексе,
и вычитаем одну сумму из другой. Вот. И здесь мы, естественно, пользуемся обратимостью.
Вот. Это значит, что касается прошлой лекции, ну вот вкратце вспомнили, да, то есть мы обсуждали
префексные суммы, обсуждали разрешенную таблицу, которая позволяет решать задачу статика RMQ,
и посмотрели на дерево Фенвика, которое помогает решать задачу динамик RSQ. И у нас осталась одна
и покрытая задача. Какая? Да, динамика RMQ. То есть мы хотим считать какую-либо инопатентную операцию,
вот. И при этом желательно, чтобы мы дополнительно могли еще изменять эти самые элементы. Так.
Значит, сегодня мы рассмотрим структуру данных под названием деревоотресков, и она будет решать
более широкий класс задач, а именно динамик что угодно. Вот. Значит, мы сейчас построим деревоотресков,
научимся решать вообще произвольную динамическую задачу. Вот. Ну и заодно, соответственно, посмотрим,
как с помощью такой структуры данных может решаться задача динамика RMQ. Вот. Значит,
почему деревоотресков? Сегмент. Сегмент 3. Почему деревоотресков умеет решать любую задачу? Ну,
потому что единственное требование, которое накладывает на операцию, это ассоциативность. Ну,
сейчас мы на это посмотрим. Давайте дадим сначала формальное определение. Значит,
сегмент 3 или деревоотресков? Деревоотресков. Значит, это структура данных в виде... Так,
неправильно начал. Давайте чуть выше. Пусть А массив из N равна 2 в степенька элементов. Значит,
предположим, что мне дан массив, этот массив имеет размер 2 в степенька. То есть размер массива имеет
степень... его размер равен некоторой степени двойке. Ну, в общем случае, понятно, что у нас массивы
не равны степени двойке, но мы потом посмотрим, что с этим можно сделать. Пусть есть некоторый массив,
который состоит из N элементов. N равно 2 в степеньках, где K это некоторое натуральное число. Вот.
Тогда деревоотресков. Это структура данных в виде полного бинарного дерева. Бинарного дерева в
листьях которого хранятся элементы А, а во внутренних вершинах хранятся, хранится,
результат применения некоторой бинарной ассоциативной операции.
Вот требования на ассоциативность, ассоциативной операции от детей во внутренних вершинах,
от детей этой вершины. Этих вершин, давайте. Этих вершин. Пусть А это массив из N элементов,
где N это 2 в степеньках. Тогда деревоотресковая структура данных в виде полного бинарного дерева,
в листьях которого хранятся элементы массива А, а во внутренних вершинах хранится результат
применения некоторой бинарной ассоциативной операции от детей этих вершин. Тут необходим пример.
Пусть у меня есть массив А, ну, какой-нибудь, не знаю, 7, 1, 2, 5, 4, 0, 2, 3, 2, 3, 4, 5, 6, 7, 8, да. Вот
такой массив. И давайте попробуем, исходя из этого пределения, построить деревоотреск. Что нам
говорится? Нам говорится, что у этого дерева есть, что это полное бинарное дерево. Напомню, полное
бинарное дерево означает, что у него, что у каждой вершины ровно два сына, и все уровни этого
дерева заполнены. В листьях этого дерева хранятся собственные элементы массива. Давайте нарисуем
8 листьев. И нарисуем в них, напишем в них значение этого массива. То есть тут 7, 1, 2, 5, 4, 0, 2, 3.
Ну и, понятное дело, листья собираются в узлы более верхнего уровня. Эти узлы, в свою очередь,
имеют родителя, ну и корень дерева здесь. Значит, читаем дальше. Во внутренних вершинах хранится
результат применения некоторой бинарной ассоциативной операции от детей этих вершин. Ну давайте считать,
что у нас в качестве операции выступает, ну что минимум, максимум. Ну давайте максимум.
Все-таки мы стремимся решать задачу RMQ. Давайте возьмем в качестве операции максимум. Значит,
дети вот этой вершины это 7, 1, поэтому здесь мы сохраним семерку. Здесь 2, 5, максимум это пятерка.
Здесь 4, 0, максимум это четверка. 2, 3, максимум тройка. Здесь максимум это четверка. Здесь
максимум семерка. Ну и в корне хранится 7. Вот, построили дерево отрезков. Почему дерево отрезков
называется дерево отрезков? Ну, на самом деле, должно быть понятно, что если мы рассмотрим
произвольную вершину, ну скажем вот эту, что в ней хранится? Что такое 4?
Да, значит в узле, вот в этом узле, хранится максимум на вот этом подотрезке. Что хранится
здесь? Здесь хранится максимум вот на таком подотрезке. Что хранится здесь? Здесь хранится
максимум вот на таком подотрезке. То есть каждая вершина отвечает за некоторый свой подотрезок,
причем длина этого подотрезка равна степени двойки. Хорошо. Ну давайте, уже наверное понятно,
что в этом дереве каким-то образом закодирована некоторая информация о максимум. То есть,
если мы хотим максимум на всем отрезке, то мы смотрим сюда. Если мы хотим узнать максимум,
скажем, вот на таком отрезке, то мы должны посмотреть сюда и так далее. Давайте пока посмотрим,
как эту самую структуру данных можно построить. Пока все понятно, да? Давайте первый пункт,
построение. Давайте еще обсудим, что делать, если у меня вдруг так оказалось, что массив имеет
длину неравную степени двойки. Допустим, здесь нет тройки. Допустим, у меня массив имеет размер 7.
Что в этом случае делать? Ну на самом деле ничего сложного нет. Достаточно просто дополнить массив
так называемыми нейтральными элементами. То есть нейтральный элемент такой элемент, который не
меняет результат выполнения операции. Ну скажем, для сложения это 0. То есть каким бы числом вы не
сложили 0, результат операции не изменится. В случае максимума это какое число или какое значение?
Минус бесконечность, да. Давайте просто тут вот на тех элементах, которые не вошли в степень
двойки, то есть если нам не дан массив, который не дотягивает до степени двойки, то я просто
его дополню до ближайшей степени двойки значениями, некоторыми нейтральными значениями. Ну в случае
максимума это минус бесконечность. Поэтому понятно, что в этом случае результат применения двойки и минус
бесконечности будет двойкой, ну и так далее. Здесь максимум 4. Поэтому если у вас массив имеет длину
не степень двойки, то ничего страшного в этом нет. Как выглядит построение? Ну построение на самом
деле выглядит очень просто. Мы по сути это алгоритм только что и провели. То есть построение выглядит
ровно по определению. Значит у нас есть нижний ряд и нижний ряд мы будем заполнять непосредственно
значениями нашего массива. Сначала построим листья, потом построим следующий уровень,
потом следующий уровень и так далее. Вопрос. Каким образом мы будем хранить вот это дерево в памяти?
Какие есть предложения? Куча. Ну массив, да. Собственно у нас был уже пример в курсе, а именно
бинарная пирамида, которая тоже имела вид бинарного дерева, который мы хранили непосредственно
в одном массиве. Ну действительно давайте просто занумеруем следующим образом
элементы дерева. То есть сверху вниз, слева направо. Просто просто некоторым образом заиндексируем
наши элементы и будем все это хранить в одном массиве. Причем каждый элемент, например элемент
5 будет храниться в массиве под инденсом номер 4. Ну и давайте ведем некоторые вспомогательные функции.
Скажем, если я нахожусь в вершине номер и, то как мне получить родителей этой вершины? И пополам.
Ну да. Целая часть. Если я хочу получить левую вершину, я нахожусь в вершине и я хочу получить
ее левостонно. Ага. И минус один пополам. В чем проблема? А, вот тут? Да, согласен. И минус один пополам.
Здесь. Вот так. Ага. Right от и return 2 и плюс 2. Ну вот.
Ну и давайте, наконец-то, напишем код для build. Значит, заведем массив t, размера,
размера 2 модуля а-1, но предполагаю, что у меня размер массива это некоторая степень двойки.
Если у меня массив длину 2 степеника, то мне нужна длина массива равная а плюс а-1.
Если число листьев равно а, то общее количество внутренних вершин равно а-1. Ну и поехали, значит.
Сначала заполняем нижний уровень. То есть for i, for 0, to модуль а-1. Что делаем? t от i плюс,
смещение у нас равно а-1. Согласны? То есть, если я хочу проитерироваться по листьям,
то я должен взять ну, взять нулевой элемент, первый элемент, второй, и так далее, но со смещением
а-1. Вот. Это равно просто аи. Ну и далее for i, from. Теперь я хочу пойти вот так. Теперь я хочу
пройтись по уровням отсюда влево, отсюда влево и так. Ну то есть взять вот этот элемент и
пройтись по всем индексам, начиная от шестого по нулевой. Что я должен сделать? Я должен взять,
точнее i, а-2 до нуля и сделать следующую вещь. t от i равно, давайте в общем случае напишем
некоторая операция. Давайте операцию будем обозначать сразу вот таким символом. Вот таким
символом я буду обозначать бинарную астативную операцию. Нужно тут сразу обозначить. Вот так.
Значит это что будет? Это будет t от left от i, применение операции к t от right от i. Ну вот.
Кажется так. Ну то есть создаем массив из 2-1 элемента. Дальше проходим по всем листям и
заполняем его значениями массива. Дальше проходим по всем внутренним вершинам и заполняем их согласно
вот такой формулой. Естественно построение как и затраты по памяти являются линейными.
Ну хорошо, поняли как устроена эта структура данных, поняли как ее строить. Наверное до сих
пор непонятно как устроить запросы к ней. Ну скажем мне нужно найти минимум или максимум на вот
таком отрезке. На отрезке от сюда до сюда. Что я должен сделать? Давайте сначала идейно. Что должно
произойти? Как посчитать сумму, максимум, минимум вот на таком на таком отрезке?
Что разбить? 1, 2, 5, 4. Ну смотрите, если я буду смотреть на эти элементы все, то я потрачу линейное время.
ну то есть да идея стей за том что вот это большой отрезок чьим-то образом разбить на
узлы так чтобы этот отрезок был целиком покрыт. Ну то в данном случае что получается я должен
взять вот эту вершину должен взять вот эту вершин, и должна взять вот эту вершину. Все таким образом
смотрите один отвечает вот за этот подотрезок, пятерка отвечает вот за этот подотрезок,
Четверка отвечает за этот подотрезок. Идея состоит в том, чтобы разбить
отрезок запроса на какое-то количество не пересекающихся подотрезков.
И вот сейчас мы понимаем, почему в случае деревоотрезков нам достаточно всего лишь ассоциативности.
Нам нужна неидомпатентность, не обратимость. Почему?
Потому что если мы разбиваем наш исходный отрезок запроса на несколько не пересекающих подотрезков,
то нам не важна неидомпатентность, не обратимость. То есть мы просто собираем наш исходный ответ
из нескольких различных подотрезков.
Остается непонятный вопрос, сколько всего этих узлов может быть?
То есть верно ли, что их всегда от единицы?
Вообще говоря, можно придумать пример, когда у вас на каждом уровне дерева будет хотя бы по одной вершине, кроме последнего.
Верно ли, что их всегда логарифмически? Верно ли, что их будет линейное количество?
То есть верно ли, что существует такой отрезок, который разобьется потенциально на очень большое количество маленьких подотрезков?
Давайте эти узлы, эти отрезки будем называть фундаментальными.
Вот это фундаментальный узел.
Ключевой вопрос в анализе этой самой структуры данных, этого самом деле отрезка,
стоит в том, а сколько всего фундаментальных узлов нам понадобится для того, чтобы покрыть любой отрезок?
Вот утверждение состоит в том, что нам всегда будет достаточно логарифмического числа фундаментальных узлов.
Давайте это докажем.
А для покрытия произвольного отрезка
О от лога N фундаментальных узлов.
А на каждом отрезке
для покрытия всего отрезка достаточно
О от лога N фундаментальных узлов.
Рассуждения простые.
Значит, покажем, что на каждом уровне
не более двух фундаментальных узлов.
Ну почему это так? От противного.
Допустим, их больше брало, чем 3.
Допустим, у меня есть какой-то отрезок, и получилось так, что на этом уровне я взял 3 фундаментальных узла.
Что тогда?
Давайте их рассмотрим.
Вот есть какой-то узел, дальше идет какое-то количество узлов, дальше еще один узел, еще какое-то количество узлов, и последний узел.
Давайте мы их синим цветом обозначаем.
Есть 3 узла, между ними есть какое-то количество узлов.
Может быть 0, может быть 1, неважно.
Что мы знаем?
Каждый из этих узлов отвечает за какой-то свой подотрезок.
И все эти отрезки целиком лежат в отрезке, на котором мы вычисляем сейчас запрос.
Давайте посмотрим на центральный элемент.
Я обозначаю центральные в кавычках, потому что если их 4, то не понятно, какой центральный, если узлов 5.
Это просто некоторый промежуточный, то есть не крайний.
Что можно про него сказать? Так ли он нам сильно нужен?
Можно ли от него как-то избавиться?
Вообще говоря, неправда, мы не можем взять соседа.
Вместо четверки мы не можем взять пятерку, двойку.
Если мы берем соседа, то сосед отвечает за другой подотрезок.
Поэтому на соседа заменить вот эту штуку нельзя.
А на что ее можно заменить? На родителя.
Согласно, что если я перейду в родителя, то я уберу вот эту вершину и возьму родителя.
За какой отрезок мне отвечает родитель?
За тот же самый плюс еще какой-то.
То есть родитель покроет вот этот отрезок.
А если я беру вот этот отрезок, то родитель покроет старый отрезок и плюс возьмет еще вот такой отрезок.
Возникает вопрос, а вот этот отрезок не выйдет за границы всего запроса или нет?
Давайте пока остановимся, давайте пока напишем.
Посмотрим центральный элемент. Его можно заменить на родителя.
Еще раз, почему его можно заменить на родителя?
Потому что если я заменяю его на родителя, то, во-первых, он покрывает старый отрезок.
Так как он покрывает старый отрезок.
И хочется написать, что он не выходит за границы всего запроса.
Почему это верно?
Да, потому что этот элемент центральный и правее него есть еще какой-то узел.
И вот этот узел, он, ну, короче, понятно, что если мы переходим в родители, то этот узел максимум, что можно сделать, он может покрыть и вот этот отрезок.
Но он не выходит за границы. Он контролирует старый отрезок.
Давайте здесь.
И он не выходит за границы запроса.
Так как у старого узла есть брат и слева, и справа.
Вот. То есть таким образом мы получили, что если у меня в одном ряду находятся три фундаментальных узла, то я все центральные, то есть все некрайние, могу просто-напросто взять и заменить на их родителей.
И хуже не станет.
Если у меня получилось по какой-то причине, что я выбрал три листа в качестве фундаментальных, то я могу центрально из них свести к родителю.
Дальше иду к верхнему уровню снова, смотрю, если у меня там больше либранов, чем три листа, то я просто свожу к родителям.
Ну и так далее. И в итоге я могу отрезок целиком разбить на фундаментальные узлы так, что у меня на каждом уровне будет не более, чем два фундаментальных узла.
Это значит, что я любой отрезок могу покрыть логарифмическим числом фундаментальных узлов.
Что мы на текущий момент понимаем? Мы понимаем, что для того, чтобы покрыть произвольный отрезок, нам достаточно всего лишь логарифмического числа вот таких узлов.
Проблема все еще остается, и она заключается в том, что непонятно, как их искать.
Давайте попробуем разобраться.
Первая стратегия, которую мы рассмотрим, это стратегия поиска снизу вверх.
Возьмем какой-нибудь запрос, например, вот такой.
Мне хочется найти максимум вот на таком подотрезке.
Давайте сделаем следующую вещь.
Я буду стартовать с границ этого отрезка.
Возьму вот этот элемент и вот этот элемент.
И буду потихоньку откусывать фундаментальные отрезки с этого края и с этого края.
Каким образом я буду делать?
Буду делать это жадным образом.
Я буду смотреть сюда и буду думать, могу ли я перейти в родители или нет.
Если я могу перейти в родители, то я буду переходить в родители.
Если переход в родители даст мне какой-то плохой результат,
то я возьму этот отрезок и перейду в данном случае чуть правее и выше.
Ну, давайте пока чисто и дейно посмотрим, как это работает.
Смотрите, я нахожусь здесь.
Когда я нахожусь в вершине, я задаю себе следующий вопрос.
Что мне выгоднее сделать?
Мне выгоднее взять этот отрезок в качестве фундаментального,
взять этот узел в качестве фундаментального,
или подняться выше?
Что мне тут стоит сделать?
Подняться выше. А почему? Как вы это поняли?
Потому что он правый ребенок.
Да, потому что он является правым ребенком.
И если я перейду чуть выше, то я, грубо говоря, поднимусь влево.
То есть если я перейду в родители, то я покрою как этот отрезок, так и что-то слева.
Согласны?
Поэтому здесь действительно я перехожу сюда.
Теперь смотрим здесь.
Идем слева конца.
Что мне тут выгоднее? Остаться или подняться выше?
Остаться. Да, если я поднимусь выше, то что произойдет?
Я захвачу что-то лишнее.
Поэтому я остаюсь здесь и перехожу на уровень выше к элементу,
который отвечает уже за следующий подотрезок.
То есть вот этот отрезок я уже взял в качестве ответа.
Эту часть меня не интересует.
То есть я сдвигаю левую границу вот сюда и перехожу вот к этому элементу.
То есть я всегда буду подниматься выше.
Я нахожу здесь.
Теперь смотрим сюда.
Что мне выгоднее сделать?
Остаться или подняться выше?
Снова остаться. Почему?
Потому что если я поднимусь выше, то что произойдет?
Вот этот узел, он левый сын своего родителя.
Так он левый сын своего родителя,
то если я поднимусь выше, то вот этот узел верхний захватит какую-то правую часть.
А правая часть у меня уже обработана.
Считается, что либо она обработана, либо она меня не интересует.
Грубо говоря, тот узел, в котором я нахожусь, он отвечает за самую правую границу,
которая мне интересна.
Если я поднимусь правее и выше, то я захвачу что-то лишнее.
Поэтому я тут остаюсь и перехожу на уровень выше и лево.
То есть вот этот узел.
Вот этот следующий уровень и перехожу на левую часть.
Так, слева я нахожусь здесь.
Давайте прыжки вот так изображу.
Я нахожусь здесь.
Что мне тут нужно сделать?
Тоже остаться. По той же самой причине. Почему?
Этот узел мне отвечает за самую левую еще не рассмотренную границу.
Если я поднимусь выше, то я поднимусь налево.
А если я иду налево, то я захвачу ту часть, которая меня уже не интересует.
Поэтому я остаюсь здесь и прыгаю на уровень выше и право.
То есть вот сюда.
Ну и все. У меня так получилось, что левая граница теперь находится правее, чем правая.
На этом я завершаю работу.
Границы у меня пересеклись. Весь отрезок я покрыл.
Ну и действительно, если я рассмотрю эти отрезки, то у меня весь отрезок целиком разбивается вот на такие штуки.
Идея понятна?
То есть я просто иду с левого и правого конца.
И если мне выгодно подняться в родители, то я поднимаюсь в родители.
Если мне в родителя подниматься не выгодно, то я сохраняю эти фундаментальные узлы и поднимаюсь на уровень выше.
Давайте изобразим это в виде некоторого кода.
Так, значит, пункт называется
реализация запроса
снизу
к Юри от L до R.
Значит, первым делом я должен перейти к листям.
То есть у меня как выглядит запрос?
В данном случае у меня запрос выглядит как найти максимум на отрезке от единицы до...
чего тут?
До пятерки, да?
1, 2, 3, 4, 5.
То есть найти на отрезке от единицы до пятерки максимум.
Но стартую я с листьев, да?
Поэтому сначала я смещаю мои индексы до листьев.
Ну как это делается?
R плюс равно N минус 1.
И R плюс равно N минус 1.
То есть я оказываю в позицию номер 8.
И здесь оказываюсь в позицию номер 12.
Понятно?
Вот.
Ну а дальше цикл
while L меньше, чем R.
То есть пока у меня левая и правая границы не пересеклись,
да, я делаю следующую вещь.
Значит, для левой границы что я должен проверить?
В каком случае я беру вот этот узел?
Мы вспоминаем, что мы проверяли.
Если он является правым сыном своего родителя,
то мы должны этот отрезок взять.
То есть мы пишем, если L является
правым сыном своего родителя,
right of parent от L.
Ну так.
Такая запись, понятно?
Если L правый сын своего родителя,
то давайте еще введем некоторые переменные.
Тут буду хранить результат, который накапливается слева.
Изначально он равен ничему.
И результат, который мне будет накапливаться справа.
Если так, то я должен взять вот этот узел в качестве ответа.
Это означает, что я делаю left res,
такая операция, plus равно.
Давайте просто напишем равно.
left res plus L.
Ну и в итоге, куда мне должен L сместиться?
Наверх и вправо.
Если у меня L находится здесь,
то я смещаюсь вот сюда.
А если у меня L находился вот здесь,
то куда бы я сместился?
Ну тоже сюда.
Короче говоря, формула выглядит следующим образом.
В общем случае L равно parent от L плюс 1.
Должно быть похоже на правду.
Смотрите, если я нахожусь здесь,
то я иду вправо-вобратно и поднимаюсь наверх.
Попал.
Если я нахожусь здесь, то мне тоже надо попасть сюда.
То есть я иду вправо-вобратно и сюда.
Кажется, все работает.
Ну и аналогично мне нужно написать для правой границы.
Если R равно уже левый сын своего родителя.
Ну вот, что мы тут делали?
Вот здесь мы что делали.
Мы проверяли, если вот этот узел является левым сыном своего родителя,
то есть если при подъеме наверх мы захватим что-то лишнее,
мы тут останавливаемся и берем это в качестве ответа.
Окей? Вот ровно это здесь написано.
То мы пишем write res равно tr плюс write res.
Ну и обновляем R.
R равно parent.
Ну по аналогии с вот этой формулой, что мы должны сделать?
Да, мы должны перейти в лево брата и перейти в родителя.
Parent от R-1.
Все, на этом цикл заканчивается.
Так, дальше оставьте место на одну строчку.
И напишем return left res плюс write res.
Вот, этот алгоритм почти работает.
Он не работает в одном крайнем случае.
Какой случай мы не рассмотрели?
Да, смотрите, что произойдет, если у меня LRs впадут?
Когда такое может быть вообще?
Если возьмем отрезок 2, 3.
Ну, например, да.
Самый простой пример, это когда мы возьмем весь отрезок.
Либо весь отрезок, либо просто какой-то отрезок, который в итоге сходится в одну точку.
Понятно, мы в этом случае решили не брать этот отрезок в качестве фундаментального.
И тут мы решили его не брать в качестве фундаментального.
В итоге сошлись сюда, и в итоге в ответ ничего не записали.
И вот в случае, если мы подаем какой-то общий отрезок,
то это значит, что этот отрезок является хорошим как для левого сына, так и для правого сына.
Поэтому мы должны его в итоге включить в ответ.
Согласны?
То есть тут дополнительно нужно опять проверить, что если в итоге оказалось так,
что я попал в один общий узел,
я должен, например, добавить что-то к левому ответу.
Плюс равно t.
Вот так.
Вот, теперь кажется все.
Давайте еще раз проговорим, что мы делаем.
Мы берем левую границу и правую границу
и сдвигаемся к соответствующим элементам в листьях.
Дальше что мы делаем?
Идем последовательно слева и справа, поднимаемся чуть выше.
Значит, как мы это делаем?
Смотрим сюда, если нам выгодно подняться в родителя,
то мы просто поднимаемся в родителя.
Вот эта строчка.
Если мы понимаем, что при подъеме в родителя мы захватим что-то лишнее,
то мы должны перед тем, как подняться выше, сохранить этот результат.
То же самое мы делаем для правой границы.
И повторяем все это до тех пор, пока у меня левая и правая границы не пересекутся.
Если они пересеклись совсем, то есть вышли друг за друга, то я на этом заканчиваю работу.
Если они в итоге сошлись к одному и тому же узлу,
то это значит, что верхний узел отвечает как и за левую границу, так и за правую границу.
Поэтому я просто его включаю в ответ.
Так, точно вопросов нет.
А вообще должен быть.
И не один.
Не смущает вас, например, вот это, вот это, ну и в принципе вот это.
Ну какой нормальный человек будет так писать?
Да, отлично. В общем, вопрос стоял в этом.
Можно ли левт и райт заменить просто на рез?
Ну казалось бы, мы же можем в одной общей переменной накапливать общий результат.
Ну то есть неважно же, в каком порядке я считаю максимум, и так далее.
Ну здесь я нарочно так сделал, потому что, вообще говоря,
когда я давал определение деревоотресков, я не гарантировал коммунативность операции.
И собственно здесь я некоммунативность сохранил.
То есть я здесь отдельно накапливаю результат слева, то есть отдельно там левые подотрески,
и отдельно накапливаю правые подотрески.
И потом складываю их в нужном мне порядке.
То есть заметьте, что я здесь тоже сохраню порядок.
То есть сначала накопленный результат слева, и только потом добавляю TL.
Здесь наоборот, беру отрезок, который слева, и добавляю к нему райтрес.
Ну это все, чтобы не было проблем с коммунативностью.
Вот если у вас операция коммунативная, она как правило коммунативна,
там всякие суммы, минимум, максимумы,
то можно просто накапливать одним минимумом и максимумом, и их проблем нет.
Давайте поясним.
Это для некоммунативных операций.
Хорошо.
Ну и отлично.
Заметьте, что это построение, оно в точности работает по той теории,
которую мы недавно доказали.
А именно, мы на каждом уровне берем максимум два фундаментальных отрезка.
Либо левый и правый.
Кроме левого и правого мы ничего взять не можем.
То есть мы protective агр Consulting какой-то bangs.
Потому что имascal работает airplanes.
Ониprofезид 103
Inspector код намет и нас pouvoir отказывать,
а Dh Phys.
Что мы на either front end и defense.
Давайте попробуем понять, как выполнять обновления в данной структуре данных.
Снова давайте сначала на примере.
Давайте уберем.
И попробуем что-нибудь пообновлять.
Самое простое обновление – это обновление в точке.
Представьте себе, что мне дан запрос – изменить вот этот 0 на 8.
То есть изменить элемент в пятом индексе с 0 на 8.
Как выполнять такое обновление?
Да, на самом деле достаточно просто взять, пройтись по родителям и обновить их.
Ну почему? Давайте просто просуждаем.
Вот я изменил здесь 0 на 8.
Кажется, что здесь понятно, что делать.
Если мне сказали 0 изменить на 8, я просто пишу тут 8.
Дальше. На какие элементы повлияла вот эта 8 вот на этом уровне?
Значит, вот на этом уровне за вот эту 8 отвечает только вот этот узел.
То есть вот эта 8 покрывает только этот узел.
Поэтому я перехожу в родителя и беру максимум из нового значения и старого значения здесь.
Нет, не так. Я беру максимум из левого сына и правого сына.
То есть просто пересчитываю значение здесь.
Вижу, что оно обновилось, ставлю сюда 8.
Дальше. Какие узлы выше затронула вот эта 8?
Ну только вот этот узел.
Вот этому узлу вообще плевать, что там изменилось, потому что он отвечает за другой подотрезок.
Поэтому идем сюда и изменяем тут 4 на 8.
Почему 8? Потому что это максимум из вот этой 8 и вот этой 2.
Вот этот узел в свою очередь повлиял только на корень.
Здесь только корень на этом уровне.
Ставим 8.
То есть обновление в точке выглядит очень просто.
Идем снизу вверх и обновляем все элементы.
Ну давайте напишем что ли.
Так, обновление в точке.
Снизу вверх.
Так, как мы это будем делать?
Обновление в точке.
Обновление и.
В.
Ну, во-первых, как обычно, берем индекс листа.
Индекс листа получается просто как n-1.
Ну где n? Это размер исходного массива.
Вот. Ну и просто говорю t от i равно v.
Вот.
Ну и дальше просто соберу и в цикле поднимаюсь наверх.
Значит while i.
Ну как написать?
Давайте напишу while i не равно root в скобочках ноль.
То есть пока я не добрался до корня, я сделаю следующую вещь.
i равно parent от i и t от i равно t left от i плюс t right от i.
Вот.
Ну, кажется, все.
Давайте проверим, значит.
Нахожусь в листе, обновляю лист.
Дальше проверяю. Эту вершину у меня не корень, поэтому захожу внутрь цикла,
поднимаюсь к родителю и беру максимум из левой и правой части.
Дальше. Снова это не корень, поэтому поднимаюсь выше.
Снова обновляю здесь.
Это не корень, поднимаюсь выше, обновляю здесь.
Это корень, выхожу из цикла.
Ну все.
Окей?
Ну снова, что я тут делаю?
Существенная часть заключается всего лишь в этом цикле.
А в этом цикле я поднимаюсь от листа к корню.
Ну естественно, так у меня дерево полное и бинарное,
то это все занимает эту от log n.
Что?
Да, можно и такую оптимизацию устроить.
Если вы понимаете, что вы поднимаетесь-поднимаетесь,
и здесь у вас результат не обновился,
то вы можете на этом просто брейкнуться и закончить цикл.
Если у вас какой-то узел не изменился, то и выше тоже ничего не изменится.
Можно так.
Так или иначе, на астимптотику это особо не влияет.
На этом базовая часть, которая относится к деревьям отрезков,
я думаю, закончена.
Что я подразумеваю под базовой частью?
Базовая часть – это запрос, построение и обновление в точке.
Теперь давайте двигаться дальше.
И к чему мы будем стремиться сейчас?
Мы уже умеем достаточно много.
Мы умеем делать запрос, мы умеем выполнять обновление в точке.
Вообще говоря, дерево отрезков – это гораздо более мощная структура данных,
которая позволяет осуществлять не просто обновление в точке,
но и позволяет обновлять целую группу элементов,
причем тоже за логарифмическое время.
И наша цель за оставшуюся пару – научиться этим всем трюкам.
То есть как обновлять значение не только в одном элементе,
но и сразу на группе элементов.
При этом не важно для произвольной операции.
Прежде чем мы перейдем к этой части,
давайте рассмотрим некоторую другую реализацию,
которая нам понадобится, а именно реализацию запроса сверху вниз.
Давайте просто возьмем и немного этот запрос изменим.
Сделаем это здесь.
Попробуем придумать какую-то другую стратегию запроса,
которая бы двигалась не от листьев в корню,
а наоборот, от корню к листьям.
Ну, снова давайте возьмем тот же самый отрезок,
который мы брали до этого,
и придумаем какую-то другую стратегию.
Давайте изначально мы находимся в корне.
Что делать? Жду предложений.
А если сама вершина уже полностью все покрывает?
Понятно, что давайте так.
Я нахожусь в корне.
Если меня попросили минимум или максимум на всем отрезке сразу,
то я уже победил.
Согласны?
То есть у меня корень уже отвечает за весь подотрезок.
Давайте как-то зафиксируем, что запрос сверху вниз.
Идея.
Двигаемся от корня.
Если вершина целиком покрывает подотрезок,
запроса, то заканчиваем.
Ну, точнее, давайте так.
То возвращаем ответ.
Ответ из вершины.
Это первый момент.
Это первая и самая простая ситуация.
Мы находимся в вершине, и мы, допустим, понимаем, что мы покрываем весь отрезок целиком.
Все, тогда мы можем остановиться и сразу вернуть ответ.
Здесь не такая ситуация, здесь другая ситуация.
Здесь мы видим, что этот отрезок не покрывает этот отрезок целиком, а пересекает его.
Что мы должны сделать в этом случае?
Давайте просто возьмем и рекурсивно запустим все отлево сына и право сына.
Вот этот отрезок, вот этот узел, он ничего сделать сам не может.
Поэтому он просто делегирует свою работу левому сыну и правому сыну.
Если есть пересечение, то рекурсивно отправляем запрос в левого и правого сына.
В левого и правого сына.
Ну, давайте так и сделаем.
В корне мы ничего не можем сделать, поэтому отправляемся в левый сын и правый сын.
Находимся здесь. Что мы тут понимаем?
Нет, подождите, пока мы не смотрим правого сына, пока вот здесь.
Здесь мы находимся во второй ситуации.
Вот этот отрезок сам ничего решить не может.
Поэтому мы рекурсивно запускаемся от левого сына и правого сына.
Давайте пойдем влево. Что мы тут понимаем?
То же самое, он как-то пересекается с нашим запросом, но при этом полость его не покрывает.
Поэтому рекурсивно запускаемся влево и вправо, влево.
Да, вот этот узел вообще не при делах. Он вообще не понимает, чего от него хотят.
И вот это третья ситуация, которая может быть.
То есть всего возможно три ситуации.
Узел целиком понимает, что ему делать, то есть узел целиком отвечает за весь отрезок.
Или какой-то подотрезок, поэтому он просто возвращает результат.
Второй, он что-то понимает, но целиком решить задачу не может.
Поэтому мы делегируем левому и правому.
И наконец, третий, это отрезок вообще не при делах.
Если он совсем не при делах, то что делаем?
Да, ну просто возвращаем некоторый нейтральный элемент.
То есть говорим, что мы ничего не знаем и возвращаем просто ноль или минусу бесконечности.
Это последняя ситуация.
То есть если узел не пересекается запросом, то возвращаем нейтральный элемент.
Давайте его обозначать как-то так.
Ну вот.
То есть здесь мне вернулся сюда нейтральный элемент.
Дальше идем вправо.
А вот здесь как раз первая ситуация.
То есть вот этот узел целиком лежит внутри запроса.
Поэтому он может вернуть свой результат, то есть единицу.
То есть он тройке сюда возвращает единицу.
Здесь рекурсивный вызов закончился из тройки.
Что получается?
В тройку вернулся нейтральный элемент единица.
Что возвращает тройка в качестве ответа?
Единицу, да.
Он просто агрегирует результат, получает единицу.
Мы от семерки рекурсивно запустились вправо.
Что тут происходит?
Пятерка полностью лежит внутри запроса.
Поэтому тут мы можем сразу вернуть пятерку.
Все, семерка получила ответ от левого сына и правого сына.
То есть это единица и пять.
И что мы возвращаем в качестве ответа?
Результат применения операции к единице и пятерке.
Ну в данном случае пятерку.
Дальше мы рекурсивно спустились сюда.
Вот эта восьмерка не понимает, что ей делать,
поэтому делегирует полномочия этому сыну и этому сыну.
Вот.
Этот сын не понимает, что делать.
Вот его отрезок, за который он отвечает,
вообще не пересекается запросом.
Возвращаем пирожок с ничем.
А здесь?
Да, он полностью покрывает наш отрезок.
Поэтому возвращаем восьмерку.
Все, значит родитель получил результат от левого сына и правого сына.
Это восемь и ничего.
Поэтому возвращаем в итоге сюда восемь.
Ну и все, корень получил ответ.
Это пять и восемь.
Ну соответственно общий ответ это восемь.
Ну куда-нибудь.
То есть это ритм рекурсивный.
Понятно, да, как работает?
Ну давайте напишем.
Напишем, напишем.
Ну вот вместо этого запроса.
Реализацию запроса сверху.
Здесь кьюри, вход.
А вот тут интересно.
Здесь будем поступать следующим образом.
Помимо того, что будем хранить LR,
давайте еще добавим несколько аргументов,
а именно аргументы a,
аргумент node и аргумент ab.
Ну LR понятно, да, это граница запроса.
node это текущий узел.
ab это отрезок,
за который
отличает узел node.
Понятно, да?
То есть в данном случае у меня запрос
на отрезке от единицы до
два, три, четыре, пять, до пятерки.
И скажем, если я нахожусь вот в этом узле,
то этот узел отвечает за отрезок
от нуля до трех.
То есть ab у него 0,3.
Ну давайте решать.
В каких случаях мы точно знаем,
что нам делать?
Ну во-первых вот в этом случае,
да?
Давайте проверять.
Значит, если
отрезок ab
целиком лежит в отрезке LR,
то что в этом случае нужно делать?
То есть если отрезок, за который отвечает node,
целиком лежит внутри запроса,
то просто возвращаем до ответа.
То есть делаем return
to node.
Дальше.
Второй случай, когда мы знаем, что делать,
это случай, когда ab
вообще не пересекается
с отрезком LR.
В этом случае мы просто возвращаем
нейтральный элемент.
Окей?
Ну в данном случае там минус бесконечности,
или в случае суммы ноль.
Важно.
Ну и наконец, самое интересное,
что делать,
если у меня все-таки пересечение есть.
То есть если не вот это и не вот это,
то это значит, что ab каким-то образом пересекается с LR.
Но при этом ab целиком не лежит в LR.
Что в этом случае мы делали?
Да, просто рекурсивно спускались
левостына и правостына,
и соединяли их результаты.
Итак, напишем
левторез равно
кьюри, от чего
по-прежнему у нас интересует отрезок LR.
В какой узел мы спускаемся?
В левый.
Да, то есть
левтатноут.
Дальше. За какой отрезок отвечает
левтноут?
Если узел отвечает за отрезок ab,
то его левый сын отвечает за что?
Левая граница остается a,
а правая граница
a плюс b пополам
в целой части.
Ну, в терминах интовой арифметики
просто a плюс b пополам.
Ну и аналогично получаем
результат справа.
Это просто запрос
на том же отрезке LR
от
right node.
Что у нас выступает в качестве левой границы
у правого сына?
Да, то есть вот эта штука,
но плюс один.
А плюс b пополам, целая часть, плюс один.
А правая часть,
правая граница, просто b.
Все. И в качестве ответа
ретерн, ну, результат операции, да.
То есть
левтрез,
операция
ретерн.
Все.
Вот. Ну, эта штука тоже работает
за
θ от логарифма.
Ну, по какой причине? Ну, ровно под...
Ну, собственно, это следует из теоремы, которую мы обсудили.
Да, то есть если в какой-то момент, то есть если мы
спускаемся вниз и понимаем, что у нас там
возникает три узла, то есть, точнее так, на каждом уровне
мы берем не более чем два узла.
Вот. То есть мы спускаемся вниз, вниз, вниз,
и общий размер рекурсии у нас не превосходит
два логарифма Я.
Вот.
Ну, потому что если в какой-то момент мы попали
в отрезок, который целиком
покрывает какую-то часть
нашего запроса, то мы сразу возвращаемся.
То есть рекурсия растет не сильно.
Вот.
Да, смотрите, да.
Именно это я хотел прокомментировать.
Значит, смотрите, у нас есть теперь две стратегии.
То есть либо выполнять запрос снизу-верх,
либо выполнять запрос сверху-вниз.
В каких случаях какой запрос выполнять?
Значит, ответ такой.
Вообще говоря, запрос,
выполнение запроса снизу-верх, он чуть более эффективный.
Почему? Потому что он не рекурсивный.
То есть на рекурсию
какая-то память уходит.
Ну, потому что нужно
сохранить контекст, нужно создавать
локальные переменные, и так далее, и так далее.
Вот.
С другой стороны,
вот эта реализация, она нам, как я уже анонсировал,
она нам поможет решать
задачи, которые связаны с обновлением на целых отрезках.
Вот.
Запросы снизу-верх
такого делать не умеют.
Поэтому если у вас задача есть, скажем, какое-то групповое обновление,
скажем, нужно взять отрезок и обновить
сразу что-то все на нем, то это, скорее всего, вам
необходимо писать вот такую реализацию.
Если вам достаточно обновлять всего лишь один элемент,
то для эффективности лучше писать запросы
снизу-верх.
Значит, ну тут еще, наверное, стоит
написать, а как, ну то есть
нам же приходят запросы вида
кьюери lr,
да, то есть вообще говоря,
пользователь не должен знать о том, что
у нас есть какие-то вершины, у нас есть какие-то ab,
но вот кьюери lr
в данном случае просто-напросто равносильно
кьюери от lr
0
0, n-1
да, 0 это корень.
Ну согласны, да, почему?
Ну запрос от lr, начинаем
мы с корня, и корень отвечает
за весь отрезок целиком,
то есть от 0 до n-1,
где n имеет степень двойки,
где n равна степени двойки.
На этом давайте сделаем
перерыв и дальше уже
ворвемся в групповые обновления
на отрезках.
Переходим к главной цели
на сегодня,
а именно
мы как бы хотим научиться
выполнять групповые операции
на целом отрезке.
Скажем, что если мне
хочется взять
какой-то вот такой отрезок
и на всем нём прибавить
двойку.
Понятно,
что брутфорс алгоритм
это просто нам пройтись по всем элементам,
мы умеем обновлять каждый элемент
по отдельности и там скажем
снизу вверх каждый элемент пообновлять.
Естественно, это всё будет работать
за каллоген.
Вопрос можно ли
быстрее? И ответ
оказывается, можно, и более того,
это можно сделать
за алгоритмическое время.
Давайте сначала обсудим идею.
Без записей просто
как бы
это могло быть устроено.
Аналогия тут на самом деле вполне
себе жизненная.
Смотрите, давайте будем
идея такая,
когда мы выполняли запрос,
мы вроде как брали наш отрезок целиком
и разбивали его на некоторые
фундаментальные отрезки и брали запросы от них.
Вот здесь история такая же.
Давайте просто возьмём этот отрезок,
разобьём его на фундаментальные подотрезки
и будем хранить обновление не
в самих листях, а в фундаментальных
подотрезках.
Как мы это будем делать?
Аналогия такая,
смотрите,
допустим, мне нужен запрос,
давайте какой-нибудь,
пусть здесь будет, отсюда
с нулевого элемента по
четвёртой на плюс
два.
Устроено всё как в бюрократе
в какой-то абстрактной стране.
Есть
некоторые глава и некоторое министерство.
И министерство
дает поручение.
Вот этим слоям населения
нужно улучшить жизнь на плюс два.
Что происходит?
Министерство понимает,
что задача улучшить жизнь вот этим чувакам,
а вот этим не надо улучшать ничего.
Просто так взять
и пообещать, что у всех
жизнь станет лучше на плюс два нельзя.
Эти расстроятся.
Поэтому мы сделаем проще.
Это министерство
говорит,
это министерство поручает своим
подконтрольным, подминистерством,
вы разберитесь со своими людьми,
вы разберитесь со своими людьми.
Мы спускаем запрос на обновление
сюда и сюда.
Давайте спустимся сюда.
Эти чуваки тоже не глупые, они понимают,
что всем пообещать сразу плюс два мы не можем.
Нас это и не просили.
Нам просили улучшить жизнь только у этих чуваков.
Поэтому
этот узел понимает,
что пообещать всем сразу он не может,
поэтому мы просто делегируем полномочия
сюда и сюда.
Что делает этот чувак?
Он понимает, что а я тут при чем вообще?
Он попал под раздачу вообще ни за что.
Говорят,
что надо улучшить жизнь здесь,
здесь ничего делать не надо, но он ничего и не делает.
Заканчиваем работу.
Что происходит здесь? Здесь то же самое,
как и на верхних уровнях.
Здесь ничего улучшать нельзя,
улучшать не надо.
Поэтому мы спускаем поручение сюда и сюда.
Этот чувак совсем ни при чем.
И здесь соответственно мы уже в конце концов
можем сохранить значение плюс два.
Что происходит здесь?
А вот здесь происходит интересная вещь.
Вот этот узел целиком отвечает
зависеть от подотрезок целиком.
Ему поручили,
надо вот здесь улучшить
что-то, улучшить жизнь на плюс две единицы.
Но как бы спускать,
выполнять поручение это долго,
дорого и вообще говоря не хочется.
Поэтому мы не будем улучшать жизнь,
а мы пообещаем когда-нибудь улучшить жизнь.
То есть сохраним здесь
некоторое обещание на плюс два.
И вот собственно вот такой схемой
с обещаниями мы будем как бы реализовывать
наши групповые подновления.
Да, вот это следующий пункт.
Значит как
сохраняются обещания понятно.
Теперь происходит момент
написания отчетов.
Вот этот чувак
он поручил своим подчиненным
улучшить жизнь здесь и здесь на плюс два.
В качестве ответа
они выдают некоторый ответ.
Каково теперь
благосостояние наших граждан?
Что возвращает этот чувак?
Там как было восемь, так и осталось восемь.
Поэтому возвращает восемь.
Ему ничего не поручали.
Что возвращает здесь?
Ему поручили улучшить на плюс два,
тут раньше было четыре.
Поэтому возвращаем шесть.
Ну соответственно максимум из восьмерки шестерки
остается восьмеркой.
Здесь аналогично. Здесь возвращает двойку,
так как тут ничего не изменилось.
Тут тоже возвращается восьмерка, так ничего не изменилось.
Соответственно тут сохраняется восьмерка.
Теперь самое интересное здесь.
Корень от своего правого сына
получает ответ
восемь.
Возвращается ответ здесь.
Он спрашивает, каково благосостояние граждан здесь?
Вот этот чувак понимает, что реально семь.
Но когда-то он пообещал плюс два.
Поэтому тут возвращается девять.
И соответственно здесь обновляется значение
на девяти.
В итоге получается вот такое дерево.
Здесь хранятся какие-то значения.
Плюс в каждом узле
хранится некоторое обещание.
Когда-нибудь там что-то сделать.
Общая идея понятна.
Это действительно правда.
Почему? Потому что если мы посмотрим сюда,
то мы этот отрезок взяли и разбили
на фундаментальные подотрески.
Поэтому мы раздали обещание
ровно в фундаментальном количестве подотресков.
Поэтому их всего грифмическое количество.
Нет.
Сейчас пока просто идея.
Сейчас более формально все опишем.
Пока все понятно, да?
Теперь, формально.
Пусть
обновление
происходит
по некоторой.
И вот теперь какая должна быть операция обновления?
Операция должна быть
ассоциативной
и дистрибутивной
по
операции
по операции запроса
операции.
Будем обозначать ее вот так.
Что означает дистрибутивность?
Дистрибутивность означает следующее.
Если я к результату операции
применяю обновление С,
то это то же самое, как если бы я сначала применил
обновление к А
и обновление к В,
а потом посчитал результат.
Ну, в частности, понятное дело, что плюс
дистрибутивен по максимуму.
То есть, если я к максимуму
от АВ
прибавлю С,
то это то же самое,
что я возьму максимум
из А
плюс С
и
В плюс С.
Для такой операции это верно.
Соответственно,
операция умножения
дистрибутивна по сложению.
То есть, если у вас в качестве операции
в дереве отрезка выступает сложение,
то вы можете
выполнять умножение на отрезке.
В общем случае, эта штука
работает для дистрибутивных операций.
Что делать, если операция не дистрибутивна,
мы обсудим чуть позже.
Короче, так или иначе,
вся задача сводится к тому,
чтобы из недистрибутивной операции сделать дистрибутивную операцию.
Но это поговорим отдельно.
Давайте пока считать, что мы работаем с максимумами
и в качестве операции мы прибавляем
элементы на отрезках.
Дальше продолжим описание
того, что хотим сделать.
Теперь в каждом узле дерева,
помимо того, что будем хранить одно значение,
результат операции,
мы будем хранить еще дополнительное поле,
которое мы так и будем называть промис.
В вершине
будем хранить
будем хранить поля, ну давайте как назовем? Дайте value.
Результат операции на отрезке без учета обещания.
Без учета обещания. Будем хранить поля value и поля promise. Отложенное обновление.
В частности, вот здесь, что означает 7 и плюс 2? Это означает, что сейчас результат
операции тут 7, но с учетом обновления 7 плюс 2, 9. То же самое здесь.
С учетом обновления без учета обновления 4, с учета обновления 4 плюс 2, 6.
Такие дела. Мы научились давать обещания. Мы попали вот в этот узел,
этот узел обещает когда-нибудь выполнить обновление на плюс 2.
Но когда-нибудь обещание все-таки нужно выполнять. Поэтому давайте научимся выполнять обещание.
Выполнять обещание будем с помощью специальной операции, которую назовем push.
Вывалкивание. Пушноут. Выполнение. Обе. Обещание.
Вопрос. Как выполнить обещание? То есть я нахожусь здесь. И в какой-то момент
к этому в этот узел стучат и говорят, давай выполняй обещание. Что он должен сделать?
То есть мы должны обновить свой value. Давайте напишем так. Умножить равно на denote.promise.
Ага. То есть выполнение обещания стоит в том, что мы тут обновляем значение на то,
которое реально тут должно быть. Это 9. Так, что дальше мы делаем? Да, то есть смотрите,
мы вроде как выполнили обещание. И вот это обещание мы должны спустить к детям.
Это плюс двойку. Мы должны спустить сюда и сюда. Дети же ничего об обещаниях не знали до этого.
Выполнение обещания стоит в том, что мы говорим, что у вас на самом деле должно быть плюс два.
Соответственно эту информацию мы до них и доносим. Понятно? То есть вот до того, как мы не начали
выполнять обещание здесь, вот эти дети ничего про плюс два не знали. Как только мы начинаем
выполнять обещание, мы спускаем это обещание к детям. Окей, да?
Поэтому что мы делаем? Мы говорим tLeft от node.promise умножить равно tNode от promise.
То есть обновляем обещание в левом сцене и в правом сцене.
tLeft от node.promise умножить равно tNode от promise.
Ой, да, tLeft. А, нет, все нормально, все нормально, да.
Да, давайте сначала с этим разберемся. Значит, что мы сделали? Мы обновили значение в узле,
обновили обещание в левом сцене и правом сцене. Ну и после того, как мы обещание выполнили,
что мы делаем? Ну, забываем про это обещание. Все, обещать больше нечего.
Поэтому мы говорим в конце tNode.promise равно какой-то нейтральный элемент.
Ну, там некоторые значения, которые говорят о том, что никакого обещания на самом деле нет.
Ну, в случае сложения это ноль. Вот. Вот и все. Работает за единицу.
Ну, тут просто четыре альфантические операции, да?
Окей.
Не-не-не, вот этот push он просто выполняет обещание в одном узле node.
То есть мы говорим, что нужно выполнить обещание здесь, все, он выполняет обещание.
Так, давайте теперь напишем запрос на отрезке, но уже с учетом обещаний.
Давайте теперь посмотрим, как дружат вот эти обещания с запросами на отрезках.
Давайте рассмотрим вот такую конфигурацию, которая у нас получилась.
Вот такое дерево отрезков, тут есть обещание на плюс два, тут есть обещание на плюс два, и тут есть обещание на плюс два.
Ну и давайте сделаем какой-нибудь запрос интересный.
Давайте запрос на таком отрезке.
Значит, вопрос сразу такой. Все ли понимают, что выполнять запрос снизу вверх нам нельзя теперь?
Почему? Потому что про обещание знают только родители.
То есть как у нас? У нас обещание спускается сверху вниз.
Если мы будем выполнять запросы снизу вверх, то дети, возможно, о каких-то обещаниях не знают.
Поэтому, смотрите, вот тут в детях хранятся ложные значения.
Вот тут, вот тут, окей?
Поэтому, чтобы обещания сверху вниз все-таки дошли до детей, нам нужно выполнять запрос сверху вниз.
Давайте обновим, но заодно вспомним, выполнение запроса сверху вниз.
Ну, на самом деле, там придется исправить всего лишь пару строк.
Поэтому, не знаю, можете заново писать, можете просто как-то исправить.
Значит, запрос сверху вниз с учетом обещаний.
Что мы делаем?
Как ранее, мы находимся здесь, то есть стартуем с корня.
Что происходит далее?
Этот корень отвечает за весь отрезок целиком, и этот отрезок целиком пересекается с нашим запросом.
Поэтому мы рекурсивно запускаемся от левого сына и рекурсивно запускаемся от правого сына.
Ну, давайте пойдем с правого сына.
Значит, правого сына рекурсивно запускаются от левого.
И правого, в правом все заканчивается, ну вот возвращается ничего.
Дальше, восьмерка, восьмерка рекурсивно запускается от вот этого элемента.
Значит, этот элемент ни за что не отвечает.
Этот элемент целиком лежит внутри запроса, поэтому что он должен вернуть?
Он должен вернуть 4 뭐-то.
он целиком покрывает некоторый подотрезок, то, что в нём хранится.
В нём хранится текущее обещание, точнее, в нём хранится текущее значение и, соответственно, обещание.
Поэтому общий результат – это текущее значение плюс некоторое обещание, которое было дано до этого.
Давайте это и напишем.
Как и ранее.
Q или L, R, node, A, B.
Напомню, что есть вершина node.
Она отвечает за отрезок от A до B, и общий запрос – это L, R.
Ну, как-то так.
Мы говорим, что если отрезок A, B целиком лежит в L, R,
то делаем return t-node.value,
обновлённое на t-node.promise.
То есть, по сравнению с обычным запросом сверху-вниз,
у нас добавился вот этот суффикс.
Ещё один момент.
Если A, B вообще не пересекается с L, R,
то только как и ранее мы просто возвращаем ничего.
А вот теперь интересно.
Мы спустились сюда, передали запрос сюда, и передали запрос сюда.
Смотрим здесь.
Мы хотим выполнить запрос вот на этом узле.
Что мы должны сделать?
Как и ранее, вот этот узел некоторым образом пересекается с отрезком запроса,
но не покрывает его целиком.
Поэтому мы снова должны рекурсивно запуститься от левой части и от правой части.
Согласны?
Но есть проблема. Какая?
Почему я не могу просто взять и рекурсивно, как и раньше, запуститься от левой части и правой части?
Да, потому что надо сначала спустить обещание.
Смотрите, я нахожусь здесь.
И я делегирую запрос левому сыну и правому сыну.
Но левый сын и правый сын вообще ничего не знают об обещаниях.
Согласны?
Но раз они ничего не знают об обещаниях, то это значит, что прежде чем спускать запрос ниже,
нужно сказать, оказывается, было до этого какое-то обещание.
Как раз таки push выполняется в момент, когда мы спускаем запрос с верхнего элемента к нижнему элементу.
Как раз таки это тот момент, когда нас приперли к стенке и говорят, выполняй запрос.
Что у вас на самом деле там происходит?
Когда приходит какая-то проверка и так далее, в этот момент начинают выполняться все обещания и тому подобное.
То есть, если у меня AB не целиком лежит в LR, и AB не пересекается с LR,
то это значит, что AB пересекается с LR, и это означает, что мне нужно спустить запрос в левый сын и правый сына.
Прежде чем спускать запрос в левый сын и правый сына, как мы обсудили, нужно спустить обещание вниз.
Ну, ровно это и сделаем.
Пишем push node.
И вот push как раз пригодился здесь.
То есть, прежде чем мы начинаем делегировать запрос в левый сын и правого сына,
мы сначала спускаем им обещание, то есть делаем push.
Вот.
Ну а далее все просто. Ну а далее как и раньше?
Далее как и раньше.
Ну да, да, да.
Там LR равно бла-бла-блан, то есть то, что было раньше.
LR равно то, что было раньше.
Ну и делаем return LR плюс LR.
Вот.
То есть вот обновили две строчки.
Вот это и вот это.
Задайте какой-нибудь вопрос.
Почему?
Ну, обновление мы еще не написали, но обновление тоже будет выполнено за log n.
Ну опять же, в чем идея обновления на отрезке?
Наш исходный отрезок разбиваем на фундаментальные подотрески и в них записываем обещание.
То есть мы также будем спускаться сверху вниз и записывать обещание при необходимости.
Ну давайте еще раз проговорю.
Значит, если у меня отрезок, за который отвечает узел, целиком лежит в запросе,
то я сразу могу вернуть ответ.
Ответ теперь у меня состоит из текущего значения в узле плюс обещание, которое я должен был выполнить.
Теперь, если у меня отрезок AB вообще не пересекается с отрезком LR,
то есть отрезок AB вообще не имеет никаких общих точек с отрезком LR, то я просто возвращаю ничего.
Ну и в случае, если у меня отрезок AB пересекается с отрезком R,
то я должен делегировать, как и раньше, полномочия левому сыну и правому сыну,
но перед этим я должен сообщить им о том, что до этого были какие-то обещания.
Вот как здесь.
Прежде чем спуститься в единицу, я должен был в единицу, ну давайте до конца проведем.
Значит, тут плюс два убирается, теперь тут есть обещание на плюс два, и тут есть обещание на плюс два.
Все, я спустил это обещание в единицу, и теперь, когда я буду спрашивать значение у единицы,
единица мне вернет что? Она мне вернет тройку.
Потому что единица теперь знает про свое обещание.
Значит, единица вернула тройку, тут вернулось ничего,
значит, теперь тут вернулась тройка,
значит, я спустил запрос сюда, вот этот отрезок целиком лежит внутри запроса,
то есть тут пять, и плюс еще было обещание на плюс два, поэтому возвращается семь.
Значит, отсюда вернулось три, вернулось семь, берем максимум, возвращается семь.
Ну и здесь четыре плюс два, шесть, соответственно шесть, соответственно шесть, все.
Общий ответ семь. Похоже на правду? Ну да.
То есть вот у меня был исходный отрезок, один, два, пять, четыре, но при этом вот этот отрезок был обновлен на плюс два,
и вот это значение тоже было обновлено на плюс два, поэтому максимум это семь.
Все, согласны?
Окей.
Да, если несколько изменений, то обещания будут суммироваться.
Ну давайте сейчас напишем код обещаний, а потом приведем какой-нибудь ультимативный пример,
посмотрим, как это все работает на практике. Согласны?
Давайте напишем обновления, чтобы все стало...
Ясно.
Так.
Да, обновления.
Так, значит, обновления также будем выполнять сверху вниз.
Так мы выполняем обновления сверху вниз, то нам снова потребуются дополнительные аргументы,
ну точно такие же, LRB.
Так, давайте лишь мне что-нибудь сотрем.
Так, тут плюс два, тут плюс два, тут плюс два.
Так, ну и давайте на том же самом отрезке теперь выполним апдейт.
Ну, логика, вообще говоря, должна быть такой же.
Значит, смотрите, я рекурсивно спускаюсь сверху вниз, спускаюсь-спускаюсь, и в итоге оказываюсь вот здесь.
Что я должен сделать, если я в какой-то момент оказался в вершине, которая целиком покрывает
некоторый отрезок запроса?
Ну да, я должен остановиться и просто сохранить обещание, да, как и раньше.
То есть вот из девятки я спускаюсь сюда, сюда, вижу, что этот узел целиком покрывает
отрезок запроса, поэтому я тут просто беру и сохраняю обещание.
То есть спускаться в детей и реально там что-то выполнять, выполнять какие-то обещания,
реально там обновлять элементы, это долго.
Поэтому я просто беру самый крупный отрезок и сохраняю обещание в нем.
То есть как и раньше, if ab целиком лежит в lr, я говорю tenode.promise.
Ну собственно, насколько мы изменяем? На плюс 2, на плюс 3, на минус 5 и так далее.
То есть берем promise и делаем умножить равно delta.
Вот. Ну и сразу делаем return. На этом останавливаемся.
Так, естественно, если у меня отрезок ab совсем-совсем не пересекается с отрезком lr,
то что я должен сделать? Ну ничего, да, просто return.
Ну и наконец интересная ситуация. Интересная ситуация возникает где?
Например, здесь. Я нахожусь в этой вершине, и мне сказали, что нужно обновить значение здесь.
Но при этом этот узел отвечает не за этот отрезок, а еще за какую-то часть.
Ага. То есть предлагается сделать следующее. Предлагается выполнить update.
То есть если мне сказали, что нужно выполнить обновление здесь, то я рекурсивно запускаю update здесь
То есть я делаю update от lr в левой вершине, и эта вершина отвечает за такой отрезок.
Что? Да, еще delta.
И update тоже самое lr, но уже write node, plus b пополам, plus 1b на delta.
Что-то еще? Ну хорошо, смотрите, у меня есть 8. Ну, допустим, тут я выполнил update на минус 1.
Что я делаю? Я спускаю update сюда, спускаю update сюда.
Дальше спускаю update сюда, спускаю update сюда.
Этот узел целиком лежит, поэтому я тут просто обновляю на минус 1.
Дальше спускаю update сюда. Он говорит update здесь и update здесь. Здесь ничего не происходит.
Здесь дополнительно минус 1.
Что я должен сделать еще? Ну, смотрите, вот семерка делегировала update сюда и делегировала update сюда.
Да, у меня семерка потенциально от этих изменений могла пострадать. Согласны?
Давайте сначала с семеркой разберемся. Семерка сказала update слева, update справа.
Update слева и update справа потенциально изменил тут максимум.
Получается, что я должен написать t-node.value равно t-node.value.
Получается, что я должен написать t-node.value равно t-node.value.
Давайте хотя бы так. t-node.value умножить на t только left.
Ну, я тоже так думаю, но раз так начали, пусть так будет.
t от leftnode.promise, то есть значение, которое находится в левом сыне.
Ну, к этому результату нужно прибавить еще то же самое, но для right.
Ну, давайте тут напишем, как по-другому можно это сделать.
Это можно просто написать как qri от отрезка qri на отрезке a plus b.
Нет, не хочу так.
Ну, этот qri он еще будет мне что-то спускать, наверное.
Не, не будет ничего спускать. Давайте напишем qri от. За что отвечает правый отрезок?
Да, a plus b пополам плюс один, b, right node. Ну, и тут то же самое.
a plus b пополам плюс один, b. Ну, либо так, либо так.
Ну, не обязательно. Ну, по традиции это почти работает.
И что?
Сейчас, подождите. Нет, в этом ифе все нормально, смотрите.
Вот этот первый if, он отвечает за вот этот узел. То есть мы спускались-спускались, попали сюда.
То есть он отвечает за всех детей сразу. В нем уже было какое-то обещание, про которое дети не знали.
Просто обновили это обещание и все. То есть значение осталось прежним.
То есть значение тут по-прежнему старое. То есть значение тут хранит...
Короче говоря, тут значение это то, что знают дети. А вот это то, что дети не знают.
Вот в этом коде чего-то не хватает.
А пока это не работает. Тут не хватает одной детали.
Чего-то не хватает. Ну, сравните, например, update с query.
Не обновили промесы в листьях. Ну, вроде как вот update и вот update. Чего не хватает.
Давайте еще раз логика. Как выглядит update? Мне приходит update на некотором отрезке.
Я снова начинаю сверху вниз. Если я прихожу в узел, который целиком лежит в отрезке запроса,
то я просто в нем обновляю промес. Все нормально. Если я пришел в какой-то узел,
который вообще не пересекается запросом, то тоже все нормально. Я ничего не делаю.
Дальше у меня история следующая. Я попал в какой-то узел. Вот в этот узел.
И говорю следующую вещь. Я должен обновить все промесы здесь и обновить все промесы здесь.
А потом обновить здесь value. Вот, смотрите, общая логика такая. Что делает push?
Push выполняет обещания. Push говорит детям, что у них есть какие-то обещания,
про которые они не знали. Так вот, прежде чем спускаться в детей, нужно им сообщить,
что у них на самом деле были какие-то обещания, про которые они не знали. Понятно?
Поэтому вот тут нужно дополнительно написать push от node.
То есть это общее правило. Прежде чем спускаться в детей, вы должны пропушить в них обещания.
Вот это выполняется здесь. Прежде чем спускаться в детей, мы выполняем push.
То же самое и здесь. Прежде чем спускаться в детей, мы выполняем push.
Двойного не будет. Почему? Потому что то, что написано вот здесь, то, что написано вот здесь
и то, что написано здесь, это не пересекающиеся ветки. То есть либо выполняется вот это, либо вот это,
либо вот это. Вот. Соответственно, что происходит при push? При push мы передаем обещание в детей,
обновляем свое значение и выставляем промес в ноль. То есть мы ничего не обещаем,
обещают только дети. Все. Мы уже засрали картинку. Давайте нарисуем новую и поиграемся с ней,
чтобы понимать. Давайте какой-нибудь массив. 4, 5, 6, 7, 8. Давайте скинить значение, сгенерируем.
Ну слишком большое. Давайте, чтобы максимум был разумный.
Ну и снова будем делать максимум. Нет, давайте дайте минимум.
Сумму мы еще поработаем. Давайте пока минимум, максимум. Короче, минимум.
Операция минимума. 0, минус 5, 5, минус 5, 0, минус 5.
Так, ну выполнять запрос не интересно. Ну а давайте делаем перерыв, а потом поиграем.
Так, срок говоря, мы весь код, который сегодня был запланирован, написали.
В принципе, мы решили задачу динамика RMQ, ну на самом деле динамика что угодно,
с обновлением на подотресках. Да, единственный вопрос, который мы не обсудили,
это нужна дистрибутивность. Вы помните, от вот этой операции требовалось, чтобы выполнялось вот такое свойство.
Да, ну собственно, вот эта операция нам нужна, грубо говоря, в пуше.
Да, ну то есть вот, представьте, что вот это вот, то, что у нас хранится в node.value, а вот это, это промисс.
И вот когда мы выполняем пуш, мы на самом деле что делаем? Мы избавляемся от своего обещания
и говорим, что мы спускаем обещание в левого сына, спускаем обещание в правого сына,
и общий результат это вот эта штука. Так вот, чтобы это было корректно, чтобы пуш работал корректно,
у нас должно выполняться вот это свойство. Согласны?
Теперь давайте пример, ну давайте выполним какой-нибудь апдейт. Какой апдейт выполнить?
4,6 плюс 5. Окей, давайте рассуждать. Мы находимся здесь. Этот узел отвечает за гораздо больший отрезок, чем нам нужно.
Поэтому мы рекурсивно спускаемся влево и рекурсивно спускаемся вправо.
Так, слева ничего, поэтому тут сразу заканчиваем работу.
Идем вправо. Снова, этот отрезок отвечает за вот такой вот большой отрезок, и он пересекается с вот этим.
Поэтому спускаемся рекурсивно влево, спускаемся рекурсивно вправо.
Что происходит здесь? Этот узел целиком отвечает за отрезок, который лежит в запросе.
Поэтому здесь сохраняем апдейт на плюс 5, как здесь.
Обновляем промес, то есть раньше тут был промес 0, теперь мы обновили промес на плюс 5.
Окей, что делаем далее? Далее запускаемся отсюда, этот рекурсивно запускается сюда и сюда.
Тут ничего не происходит, а тут здесь сохраняем тоже апдейт на плюс 5.
После рекурсивного вызова здесь, что происходит? Вот мы тут рекурсивно вызвали апдейт вот этот слева,
рекурсивно вызвали апдейт справа, и теперь мы должны обновить значение здесь.
Вот из этого узла мы пошли влево, что-то обновили, из этого узла мы пошли вправо, что-то обновили.
Поэтому вот это значение теоретически могло обновиться. Но оно действительно обновилось.
На сколько? Да, теперь когда я спрашиваю результат операции слева, мне возвращается 10.
Когда я спрашиваю результат операции справа, мне возвращается бесконечности.
Поэтому я тут пишу просто 10. Дальше поднимаемся выше. То же самое здесь.
Здесь я делился на левый вызов и на правый вызов, поэтому теоретически вот это значение могло обновиться.
Когда я вызывался слева, я вызывал вот этот апдейт, когда я вызывался справа, я вызывал вот этот апдейт.
Теперь пришло время обновить значение. Что тут должно быть написано? 0.
Потому что теперь результат операции здесь – это 0, результат операции здесь – это 10.
Ну и рекурсивно я вызывался от корня. Поэтому корень рекурсивно вызывался.
Вызывал апдейт отсюда, вызывал апдейт отсюда. Вот. И здесь я теперь должен сохранить 0.
Нет, неправда. Промес у родителя – нейтральный элемент, то у всех его детей… Нет, неправда.
Давайте пример еще. Хорошо, вот это с выявленным запросом понятно, да?
Давайте другой запрос. Давайте синий. Давайте запрос, не знаю, ну вот здесь, вот на таком отрезке, на минус 1. Согласны?
Что я делаю? Я нахожусь здесь, иду рекурсивно влево, ну снова, да, давайте по порядку, вот здесь, что происходит.
Я нахожусь здесь. Вот это условие у меня не выполняется, вот это условие у меня не выполняется.
Поэтому я выполняю push, ну там push-ить нечего, поэтому переходим сюда.
То есть рекурсивно вызываемся слева, от левой части. Ну левая часть совсем не пересекается, поэтому там неинтересно.
И рекурсивно вызываемся влево. Ну вот здесь.
Вот этот узел целиком отвечает за запрос.
Поэтому что я должен сделать?
Сохранить минус единицу.
Все.
И вот здесь.
И вот здесь.
И вот здесь.
И вот здесь.
Сохранить минус единицу.
Все.
Ну вот вам пример.
Здесь не нейтральный элемент, и у детей тоже не нейтральный элемент.
Ну то есть проверим, что у нас действительно все правильно.
Значит, вот тут мы ничего не изменяли, вот этот элемент должен был измениться на сколько?
На плюс 4, да?
Здесь 5, которое приходит отсюда, есть минус 1, который идет отсюда. Ну плюс 4.
У этого элемента. Этот элемент тоже долженels도 замениться на плюс 4. То есть вот он плюс 5 и вот он минус 1. То есть 4.
У этого элемента тоже. Вот он сам плюс 5 и минус 1.
Вот этот элемент должен был измениться на минус 1.
То есть вот он на минус 1 приходит только отсюда. На плюс 5 никакого запроса нет.
Аwolf, а вот у нас допустим инцидизированное минусmiсконечность, и нам на этот ответ是 минус 5?
Ну, ничего. Да. Ну то есть нейтральный элемент это вот как раз такой элемент,
который, чтобы вы к нему не применили, останется то же самое. Ну и давайте
выполнить какой-нибудь запрос. Так, вот это уберем. Какой запрос будем выполнять?
Ну или давайте еще какое-нибудь обновление, чтобы прям точно все кейсы покрыть. Не знаю,
давайте еще сделаем апдейт в таком отрезке на плюс три. Что происходит? Запускаемся отсюда,
рекурсия нас ведет влево и вправо. Идем влево. Значит снова здесь рекурсивно запускаемся слева,
рекурсивно запускаемся справа. Здесь ничего интересного для нас нет. Поэтому сразу завершаем
работу. Запускаемся рекурсивно справой части. Вот этот отрезок, то есть попадаем вот в первый
случай. Вот этот отрезок AB целиком лежит в запросе. Поэтому тут пишем обещание на плюс три. Все,
вот тут два рекурсивных вызова закончились. То есть вот когда мы находились вот в этом узле,
мы сделали рекурсивный вызов слева, рекурсивный вызов справа. И теперь мы должны просто обновить
значение здесь. Обновляем значение, тут три. То есть минимум из пятерки и ноль плюс тройки это
тройка. Все, ну и родителю тоже сообщаем, что у нас новый результат три. Так, теперь рекурсивно
вызываемся отсюда. Значит, не очень хорошо. Давайте вот такой отрезок возьмем. Ну что бы было
интереснее. Значит, снова вот этот отрезок, он покрывает чуть больше, чем нужно. Поэтому что
делаем? Да, вот теперь сначала пушем. Понятно? То есть прежде чем переходить к обновлению здесь и
обновлению здесь, мы должны этим детям сообщить, что у них где-то выше было вот это обновление.
Поэтому делаем push. Как выглядит push? Мы просто избавляемся от обещания, обновляем значение
здесь и добавляем обещание сюда и сюда. Ну здесь можно сразу написать плюс четыре. Вот для чего
нужен push. Понятно? Все, теперь наконец сделали push и со спокойной совестью можем рекурсивно
запуститься от левой части от правой части. Находимся здесь. Общий апдейт на плюс три, поэтому
этот плюс четыре заменяем на плюс семь. Вот, это как раз тот момент, который не всем был понятен.
Смотрите, я обновил промес здесь два раза. Видно? То есть когда мне пришел сюда минус один, и теперь
мне пришелся запрос на плюс три. Это не один и тот же апдейт. Когда я обновлял здесь плюс пятерки
на плюс четверку, я выполнил тот старый промес, который был еще до этого, когда-то давно. А вот теперь,
когда я наконец дошел до сюда, я делаю тот самый апдейт, который меня просят сейчас.
Естественно. То есть если вы не выполнили старый промес, то вы его просто потеряете.
Если вы оставите его в родителе, то тогда вы не сможете корректно обновить значение здесь и здесь.
То есть рекурсия, в принципе, она может пойти дальше-дальше. Вот. Ну то есть здесь-то может быть все нормально, возможно.
Но когда вы будете, например, здесь спускаться рекурсивно влево и вправо, то у вас дойдут до сюда и до сюда некорректные значения обновления.
Поэтому так нельзя.
Ну давайте подумаем. Давайте подумаем. Ну вот тут что было?
Тут было 0, тут минус 1. Ну вот допустим мы этот минус 1 тут и оставляем.
Вот. Тут было что у нас? Тут было плюс 5. Мы делаем...
Так. И тут мы теперь должны сделать тут на плюс 3, то есть тут плюс 8.
И вот так кажется делать нельзя. Почему? Потому что у вас тут... Ну смотрите, когда вас в следующий раз попросят...
Короче, тут все запутано. Смотрите, вот когда вас попросят выполнить запрос вот на этом узле, что вы вернете?
То есть как раз таки разделение на promise и на value оно как раз заключается в том, что вот про это обновление не знают дети.
Давайте попробуем привести какой-нибудь пример, когда все сломается. Допустим я вот это обещание не спускаю детей.
Тогда тут спускается на плюс 3. Вот тут я обновляю плюс 5 до плюс 2. И все.
Тут что было? Плюс 5. Да, поэтому плюс 8.
Хорошо, я теперь тут должен... Теперь я должен обновить значение здесь. Какое значение должно быть здесь?
Тут значение 13. Сюда я должен вернуть... Справа возвращается 3, отсюда возвращается 13.
Здесь я должен записать сюда. Здесь я должен записать 3.
И ничего не сломалось, да, хотите сказать?
Давайте еще подумаем. Про этот promise дети не знают, знают только родители. В принципе, наверное, я согласен.
В случае promise вот это обещание можно не спускать. Вот это обещание можно не спускать. Почему?
Потому что когда мы будем выполнять запрос, если мы в итоге придем сюда, то тут хранится значение, про которое знают дети,
а вот тут хранится promise, про которое дети не знают, поэтому мы там корректно все обновим.
Наверное, можно не обновлять. Но мне кажется, что если мы все-таки обновляем, то так понятнее.
Ну почему? Потому что мы проталкиваем значение в детей.
Мне кажется, что вот этот push просто доваляет симметрию в то, что было написано здесь, и в то, что было написано там.
В принципе, я пока не вижу причин, по которым push обязателен вот здесь, но если что-то придумаю, то я напишу об этом.
Так, давайте. Тут что у нас было? Тут было плюс пять. То есть тут должно быть плюс семь, да?
Запутали. Какие у нас обновления тут были? То есть плюс семь. Суммарный.
А здесь? Какие обновления вот этот узел затрагивали?
Давайте так. Какие обновления мы вообще в принципе выполняли?
Так, плюс пять. Вот так?
То есть плюс пять было вот так? Вот так? Все, отлично. Вот так на плюс пять. Дальше?
Плюс три, да? Так, здесь плюс три. Дальше, вот тут суммарное обновление должно было приехать на плюс семь.
Да, все нормально. Здесь обновление мы пропушили, поэтому здесь два.
Здесь суммарное обновление. Здесь мы тоже в конце должны были пропушить.
Поэтому сюда в итоге пришло обновление на плюс пять минус один, то есть плюс семь тоже.
Вот, и здесь двенадцать. Похоже на правду. Ну, кажется так.
Давайте тут, значит, полностью на плюс три, тут полностью на плюс семь. Значит, тут плюс пять минус один плюс три, тут на плюс семь.
Здесь двенадцать. То есть тут нет никаких невыполненных обещаний. Здесь тоже, здесь тоже. Вот.
Ну, сюда пришло два.
Ну, давайте выполним какой-нибудь запрос. Ну, давайте запрос выполним, не знаю, вот здесь.
Что мы делаем? Мы спускаемся в левую часть, то есть здесь сразу тройка, то есть тройка сразу отвечает за весь подотрез, поэтому тройка возвращается обратно.
Здесь рекурсивно спускаемся сюда, рекурсивно спускаемся сюда и сюда. Получаем, что здесь нам не рады, ничего не возвращаем.
Спускаемся сюда, вот тут делаем push за счет того, что тут плюс семь и тут плюс семь.
Вот, спустились сюда и этот отрезок целиком лежит в запросе, поэтому возвращаем пятьдесят. Здесь тоже возвращаем.
Так, нет. Здесь возвращаем пятьдесят, здесь возвращаем два. Соответственно, берем минимум, возвращается два.
Ну, бла-бла, возвращаемся два, всеобще ответ два.
Нет. Еще раз. Когда мы спустились сюда, мы сделали push, то есть выполнили туда обещание, спустили обещание сюда на плюс семь, спустили обещание сюда на плюс семь.
Когда мы рекурсивно вызвались от левой части и от правой части, когда мы рекурсивно вызвались от правой части, нам ничего не вернулось, то есть нам вернулось не два, а ничего.
Потому что у нас обещание было раньше здесь, мы выполнили push, а потом поехали вниз.
Вот. То есть отсюда нам вернулось ничего, а отсюда нам вернулось пятьдесят.
Поэтому отсюда суммарно вернется пятьдесят и сюда вернется пятьдесят. Поэтому ответ три.
Ну вот такая история.
Ну и теперь давайте коротко поговорим про то, что делать в случае сумм, что делать в случае недистрибутивных операций.
Давайте еще один пример приведем уже в случае сумм.
Итак, ну снова давайте заведем какой-нибудь, ну давайте уже поменьше пример рассмотрим.
Достаточно будет. Ну пусть. Три, семь, минус пять, два. Пусть мы строим дерево отрезков по сумме.
Ну как обсуждали ранее, чтобы можно было выполнять обновление на отрезках, операция должна быть дистрибутивна.
То есть какую мы знаем дистрибутивную по сложению операцию? Ну это умножение.
То есть если мы хотим умножать на отрезки, то все равно тоже повторяется.
То есть вопрос заключается в том, а что если я хочу выполнять присваивание на отрезке?
То есть плюс в качестве ответа.
В данном примере я хочу не только складывать на отрезках, но еще выполнять обновление на подотрезке.
Например, взять вот этот отрезок целиком и тут прибавить всеми элементам плюс три.
Я думаю понятно, что старый способ не прокатит. Да, почему?
Ну почти, да. То есть я хочу показать, что старый способ не сработает. Почему?
Ну потому что если я тут сохраню обещание на плюс три и тут сохраню обещание на плюс три,
то вообще говоря неправда, что результат операции здесь это минус три плюс три.
То есть сложение не дистрибутивная операция, поэтому нельзя сказать, что минус три плюс три
это то же самое, что минус пять плюс три плюс два плюс три.
То есть нельзя просто взять обещание и спустить сюда и сюда.
Но можно прибегнуть к трюку и перейти в некоторое другое пространство,
в котором операция плюс будет все-таки дистрибутивна.
Смотрите, давайте перейдем к другим элементам, для которых плюс будет дистрибутивен.
И вот в качестве таких элементов я предлагаю хранить следующую вещь.
Помимо самого элемента давайте хранить пару решений.
Храним пару v и количество элементов.
Вот здесь хранится значение три, и он отвечает за один элемент.
Здесь хранится значение семь, и он отвечает за один элемент.
Здесь то же самое. Минус пять и один. Здесь два и один.
Дальше здесь десять и два. То есть сумма десять, и в этой сумме всего два слагаемых.
Здесь тоже минус три и два слагаемых. Здесь общая сумма семь и четыре слагаемых.
Чем это нам поможет? А поможет это нам следующим.
Смотрите, что должно произойти, если я пытаюсь, скажем, к семь запятая, давайте так, в общем случае,
к а запятая n прибавить дельту. Чему это должно быть равно?
Это должно быть равно, это должно быть a плюс дельта n, n плюс, ну и все.
То есть вот этот апдейт, он теперь работает следующим образом.
Он берет само значение, он берет количество слагаемых, и просто каждому слагаемому прибавляет дельту.
Ну а так как всего слагаемых у меня n, у меня выполняется вот такое соотношение.
Почему это будет дистрибутивно? Ну давайте посмотрим вот сюда.
Теперь я храню пары a, n, a плюс b, n, b. И здесь я выполняю плюс c.
Почему у меня равно плюс c?
Значит смотрите, если у меня есть сумма n, a слагаемых и сумма равна a, есть сумма n, b слагаемых,
которая равна b, то по сути эта штука вся равна a плюс b на n, a плюс n, b.
Согласны?
Согласно тому определению, которое мы ввели до этого, согласно тому определению, как складывать пару с числом,
у нас получается следующая вещь.
a плюс b плюс n, a плюс n, b умножить на c, n, a плюс n, b.
Вот.
Ну вот эту штуку мы уже можем расписать как?
Итак, a плюс n, a умножить на c, n, a плюс b плюс n, b умножить на c, n, b.
Получили дистрибутивность. Согласны?
Весь трюк заключается в том, что если у вас есть какая-то недистрибутивная операция, то вы должны ввести некоторую дополнительную информацию так,
чтобы операция в итоге стала дистрибутивной.
То есть в итоге этот плюс 3 действует так.
Он берет количество слагаемых, ну скажем, если вам поступил запрос в этом узле,
то вам в качестве ответа нужно вернуть минус 3 плюс 3 умножить на 2.
Вот такое решение.
А теперь самое интересное.
Это, что касается формальной стороны вопроса, то есть как из сложения по сложению,
из недистрибутивного сложения по сложению сделать дистрибутивное сложение по сложению.
Теперь как-то реально должно быть устроено.
Вообще говоря, хранить вот эти самые количества это не очень удобно. Согласны?
Вот я утверждаю, что вот эти вот количества, 4, 2 и так далее, у нас уже где-то хранится.
И вот это значение мы можем легко получить.
Два в типе не уровень. Нормально, но можно лучше.
То есть когда мы выполняем q или когда мы выполняем update,
мы одновременно с этим храним границу отрезка, за которую он отвечает.
Ну а зная границу отрезка, за которую он отвечает, мы всегда можем получить количество элементов,
за которые отвечает этот узел.
Поэтому в случае сложения по сложению, что тут нужно исправить?
Ну, во-первых, вот тут нужно промес.
Ну короче, как выглядит вот этот update?
Мы должны взять value и прибавить промес, умноженный на n,
где n берется вот по такой формуле.
Что дальше? Здесь понятно.
Ну и здесь пересчет, точнее, вот тут.
В value мне должен быть plus равно tnotedpromise умноженный на n.
Вот такая история.
Ну и в принципе таким же образом выполняется любая и другая операция.
Мы сейчас, например, обсудим, вот что если мне теперь хочется выполнять обновление не на plus,
а скажем, ну опять же, я работаю в той же парадигме, я работаю со сложением.
То есть у меня по-прежнему дерево отрезков хранит результаты суммы,
но в качестве апдейта у меня поступает операция присваивания внезапно.
То есть я хочу взять и на отрезке всем элементам присвоить единицу.
Но снова, присваивание – это не дистрибутивная операция.
Да нет, нет.
Если вы A, B берете, приравниваете дельта, то это не то же самое, что A присвоит дельта, плюс B присвоит дельта.
Операция присваивания – считаем, что возвращает результат присваивания.
В данном случае понятно, что дельта не равна сумме двух дельт.
Но ровно таким же трюком, если мы дополнительно в рассмотрение обводим количество элементов, за которые отвечает каждый узел,
мы можем выполнять и обновления.
То есть тут мы сохраняем обещание равно единице, и тут мы сохраняем обещание равно единице.
И когда нас реально попросит результат, то что мы должны сделать?
Ну не присвоить, нам достаточно просто вернуть.
Давайте, как выглядит результат.
Результат A, A на A, на дельту.
Что мы должны в этом случае вернуть?
То есть у меня есть узел, в котором хранится A и A, то есть в данном случае минус 3 и 2 элемента.
И поступает запрос, что я должен вернуть результат старого значения с учетом обновления.
Что я должен вернуть?
На самом деле, я должен просто вернуть вот эту штуку.
Ну да.
Мне тут говорится, что раньше когда-то здесь было два слагаемых, и их сумма была равна минус 3.
Но теперь тут хранится обещание, что нужно присвоить единицу.
Чему тогда будет равен результат операции в этом узле?
Ну раз тут всем элементам в этом узле была присвоена единица, и тут всего два слагаемых, то значит сумма эта 2 умножить на 1.
Поэтому 2.
Понятно?
Соответственно, здесь вместо вот этого значения вы должны вернуть просто промес, умноженный на n.
Ну в случае, если промес действительно есть.
Тут еще тонкий момент. А как отличить, есть промес или нет промеса?
Какой результат является нейтральным? Что является нейтральным результатом по вот этому обновлению на присваивании?
Самой value.
Ну вообще говоря, непонятно. Вообще говоря, это неправда.
Почему? Потому что если я тут храню равно 10, то когда меня попросит push, я вот это равно 10, пропушу влево и вправо.
Поэтому мне нужно просто хранить некоторое отдельное значение,
ну короче, некоторое специальное значение, которое будет говорить, что на самом деле присваивания не было, и все.
Ну не знаю, можно дополнительно bool хранить типа true или false.
Ну типа реально тут есть обновление какое-то или нет?
Все ясно.
Понятно, как разбираться с недистрибутивными операциями и тому подобное.
Ну в принципе минут пять есть, давайте тогда еще какую-нибудь задачу разберем.
Ну давайте какую-нибудь классику.
Дерево отрезков на самом деле очень мощная структура данных, она позволяет делать много чего,
то есть она позволяет выполнять групповые обновления на отрезках,
плюс несмотря на то, что формально она требует дистрибутивной операции,
практически любую операцию можно сделать дистрибутивной, ну там, с помощью некоторых хаков.
Может какие-то хаки дополнительно вы обсудите еще на семинарах.
Ну давайте небольшой мостик следующей лекции вброшу.
Дерево отрезков очень мощная структура данных, которая позволяет сделать многое.
Но не все.
Ну например дерево отрезков не позволяет вставлять новый элемент.
Ну представьте, что вы хотите в отрезок добавить некоторый новый элемент.
Или вы хотите выполнить операцию обновления,
в виде взять какой-то подотрезок и перевернуть его.
Как это сделать за алгоритм, непонятно.
В следующий раз мы научимся выполнять всякие перевороты отрезков.
Не знаю, взять вот этот кусок отрезка, переставить его в начало.
И все это будем делать за алгоритмическое время.
Но уже с помощью какой-то другой структуры данных.
Так, вернемся к дереву отрезков.
Значит, задачи ставят следующим образом.
Снова у меня есть массив.
Ну пусть тут один, ноль.
Понимаете, просто бинарный массив.
Задача стоит следующим образом.
Посчитать количество нулей на подотрезке.
То есть мне данный некоторый подотрезок.
Нужно сказать, сколько в нем нулей.
Как будем решать?
И что будем хранить в узлах?
Да, решение стоит в следующем.
Давайте хранить в узлах не сами значения, как раньше,
а просто количество нулей.
Возьмем и вот этот массив инвертируем.
То есть тут ноль нулей, тут один ноль,
ноль нулей, ноль.
Тут один ноль, тут один ноль,
ноль нулей, ноль,
ноль, один, один,
тут ноль нулей.
Ну и дальше просто-напросто складываем все значения.
То есть тут на этом отрезке один ноль,
тут нет нулей, тут один ноль, тут один ноль,
тут два нуля.
Ну и суммарно на всем моем массиве было три нуля.
Хорошо, это простая задача.
Даже можно поплотить обновления,
даже групповые обновления, все нормально.
Вопрос звучит в следующем.
А вот что, если мне приходит запрос вида
найти не количество нулей,
а найти
найти кат и ноль?
Скажем, найти позицию,
в которой расположен кат и ноль.
Не знаю, первый, второй, третий и так далее.
Как решить задачу с алгоритмическое время?
Поиск по бинарному дереву.
Поиск по бинарному дереву.
Ну понятно, что не такое.
Ну, допустим, мы идем в левую ветру,
смотрим, есть там меньше нулей, чем кат и ноль.
Ну примерно так, да.
Ну при этом понятно с учетом возможных обновлений.
И идея, на самом деле, простая, действительно.
Допустим, мне нужно найти какой?
Не знаю, давайте второй ноль.
Найти второй ноль.
Как мы это делаем?
Ну, смотрите, мы находимся в узле.
В верхнем узле.
Смотрите, если номер нуля, который меня попросили,
он больше, чем общее количество нулей,
то я сразу возвращаю, короче,
какой-нибудь none,
ну, минус один.
Ну понятно, если общее количество нулей
больше, чем ноль, который я запросил,
то ничего делать не надо.
Теперь мне нужно понять,
а в какой ветке мне нужно этот кат и ноль искать?
В левой или в правый?
Меня попросили второй ноль.
Я иду в левую ветку.
Тут написано единица, что это означает?
Это означает, что левая ветка меня не интересует.
Тут всего один ноль, а меня попросили второй.
Это значит, что я иду сюда,
и что делаю?
И ищу первый ноль.
То есть, если у меня тут было,
скажем, m нулей,
и меня попросили k ты ноль,
то в правой ветке я должен искать
k минус m ты ноль.
Согласны?
Иду сюда, ну и так далее.
Здесь то же самое.
Смотрю, верно ли, что тут мне хватает,
ну, что мне тут хватает количества нулей,
смотрю, сколько нулей слева, смотрю, сколько нулей слева,
и решаю, там, где мне продолжить поиск
в левой ветке или в правой ветке.
Вот.
Хорошо.
Гениально.
Более сложная задача.
Найти
k ты ноль на отрезке.
То есть, до этого задача формулировалась так.
Мне дан весь массив, и мне надо во всем массиве
найти k ты ноль.
Теперь задача ставится другим образом.
Есть конкретный отрезок,
и вот на этом конкретном отрезке
нужно найти k ты ноль.
Что ищем?
Вот этот?
Мы идем в вершину и смотрим.
Если в этой вершине
чай, чайная,
там есть ноль,
тогда, естественно, запускаемся от левого в правый левый.
Ну, сейчас, ну, допустим, я дошел как-то сюда,
и я понимаю, что здесь,
ну, у меня есть достаточно
количества нулей, но при этом...
Ну, то есть, меня попросили k ты ноль,
и я знаю, что у меня тут k нулей.
Это же не правда, что мне нужно искать поиск,
в общем, нужно продолжать поиск здесь.
У меня потенциальный k ты ноль может находиться здесь.
Так.
Давайте формально алгоритм.
Как он работает? Что мы делаем?
А как мы понимаем?
Есть у нас в целом где?
В целом на всем массиве или в целом здесь?
Ну, хорошо. Допустим, находимся здесь,
и мы понимаем, что вот суммарно вот здесь
у меня есть достаточное количество нулей.
Или даже так. Вот я нахожусь здесь,
и я понимаю, что вот тут количества нулей мне не достаточно.
Что тогда?
Ну, это же ничего не значит.
Наверное.
Ну, короче, метод решения
заключается к сведению к предыдущей задачи.
Какой задачей свести предыдущий?
Самый простой способ, который я знаю.
Возможно, можно действительно...
То есть, один из возможных еще вариантов
это действительно разбить на вот такие фундаментальные узлы,
посчитать общее количество нулей здесь,
и тут уже дальше понятно,
в каком узле нужно продолжить искать и так далее.
Что?
И как это нам поможет?
А, в смысле, вот тут обновить?
Ну, не хочется массив портить.
А вдруг у меня много запросов таких будет?
Смотрите, если я хочу найти
кат и ноль здесь.
Какой это ноль во всем массиве?
Ну, в данном случае каплю с первой.
А в общем случае?
Ага, кат и ноль
на b.
Это то же самое,
что k плюс
количество нулей
на
а,
и
и
и
и
и
ноль а-1
так, и
на всем
массиве.
То есть, чтобы найти кат и ноль здесь,
я могу просто посчитать количество нулей вот здесь.
Но о количестве нулей и как
посчитать количество sanity здесь, я думаю, понятно.
Мы просто
идем влево, влево и почитаем,
ищем вот эти самые фундаментальные 65-мин JK,
ну, то есть количество нулей мы считать умеем.
Это мы решили в качестве нулевой задачи, вообще говоря.
Да?
То есть мы считаем количество нулей здесь, допустим n.
И тогда кат и ноль на
этом отрезке, это просто n плюс
кат и ноль
все массиве. Вот и все. Хорошо, на сегодня закончим.
