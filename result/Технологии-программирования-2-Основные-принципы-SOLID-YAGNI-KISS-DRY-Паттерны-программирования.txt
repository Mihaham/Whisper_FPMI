Всем доброго дня или утра. Я не знаю, у кого какое время суток. Вот, мы будем считать, что сейчас утро.
Значит, мы с вами продолжаем изучать наш курс. Значит, у нас, как вы уже могли заметить,
лекционная и семинарская часть немного отличаются. Причем сейчас они отличаются кардинальным
образом. Но в какой-то момент времени у нас настанет пересечение. Вот, и на самом деле первый
момент, в котором у нас так или иначе настанет пересечение, это будет сегодня, потому что мы
сегодня с вами рассмотрим первые баторные проектирования, то есть то, каким образом можно
писать код. Давайте в качестве разминки вспомним, что у нас было в прошлый раз.
Да, критерии хорошей архитектуры. Первое, что у нас было. Еще что было? Да, тоже было. Мы еще
какой-то закон с вами посмотрели. Да, мы с вами рассмотрели закон Диметра. Про что он говорит?
Давайте попробуем вспомнить. Да, смотрите, если у нас есть класс А, который что-то знает о классе
В, и есть класс В, который что-то знает о классе С, то по идее в практиках объектно-ориентированного
программирования лучше не допускать, чтобы А что-то знала С. То есть так называемая
антитранзитивность, если мы говорим в математических терминах. И посмотрели,
каким образом ее можно решать. То есть мы с вами рассмотрели критерии хорошей архитектуры и закон
Диметра. Сегодня мы с вами двинемся дальше и посмотрим, а каким образом можно избегать из
лишней жесткости в архитектуре и делать ее максимально гибкой и адаптируемой. Вот, значит,
план на сегодняшнюю лекцию у нас будет следующий. Это попробовать расшифровать четыре аббревиатуры.
Первая аббревиатура это solid, вторая аббревиатура это dry, третья аббревиатура это kiss и четвертая
аббревиатура это yagni. Сразу скажу, что solid больше относится к объектно-ориентированному
программированию, в то время как другие аббревиатуры на самом деле не относятся
к объектно-ориентированному программированию, а вообще относятся к написанию кода и к
проектированию самих систем. И давайте как раз познакомимся с ними по порядку. Начнем
мы с вами с соли. Давайте я спрошу, есть ли среди вас те, кто не знает вообще, что такое
объектно-ориентированное программирование. Но у кого-то сейчас курс идет по объектно-
оритированного программирования. Главное знать, что в нем есть классы. У классов есть экземпляры,
у классов, точнее, классы могут представляться экземплярами, у классов есть поля и у классов
есть методы. Причем методы могут быть различного вида доступа. Хорошо, давайте я спрошу следующее.
Знаете ли вы, что такое абстрактный класс? Что такое абстрактный класс? Да, то есть это класс,
который по факту не полностью реализован, у которого некоторые методы могут не иметь реализацию.
Они обычно называются, в зависимости от языков программирования, это либо абстрактные методы,
либо могут быть виртуальные методы, если мы говорим про C++. Хорошо, давайте я теперь задам
еще один вопрос. Коллеги, которые приходят, давайте аккуратненько, чтобы не мешать слушать.
Знаете ли вы, что такое интерфейс? Смотрите, здесь я точно хочу уточнить, что по факту,
если мы сейчас посмотрим на обычные языки программирования, то даже в джаве класс абстрактный
и интерфейс сильно отличаться не будут, по крайней мере с восьмой версией джавы. Но,
если мы посмотрим истинную натуру интерфейсов, то до восьмой версии джавы интерфейсы имели свою
собственную сущность. Смотрите, интерфейс это роль, которую можно приписать классу. То есть это что
значит? Это допустим, если нам нужно получить метод write у какого-то класса, то по-хорошему
должен быть интерфейс типа writable. У него должен быть прописан метод, который имеется write,
и у него точно не должно быть реализации. То есть смотрите, у интерфейсов по классике не должно
быть никаких полей. Раз, все методы должны быть публичными. Два, три, ни одного метода не должно
быть реализован. То есть это чисто роль, которую можно приписать объекту. Там дальше я это расскажу,
просто нам нужно будет это для того, чтобы мы с вами разобрали аббревиатуру solid. Из чего
она состоит? Она состоит из пяти пунктов, как это можно увидеть. И эти пять пунктов такие. Первый
это single responsibility principle. То есть принцип единой ответственности. Сейчас мы будем детальнее
еще про них говорить. Вторая вещь это open-closed principle. Принцип открытости-закрытости. Третий
принцип замены Барбары Лисков. Сразу скажу, что у Лисков фамилия не склоняемая, потому что это
женская иностранная фамилия. Правило русского языка шестого класса. Следующий это interface
segregation principle. Принцип разделения на интерфейс. И как раз здесь мы и поймем, что такое интерфейс.
И последняя вещь это принцип обратимости-зависимости или, как он еще называется, dependency
inversion principle. То есть все вот эти шесть методов мы сейчас с вами рассмотрим. Давайте попробуем
догадаться чисто визуально. Как вы думаете, что будет говорить single responsibility principle?
Да, именно так. Single responsibility principle говорит следующее, что один класс должен играть одну роль.
И здесь я как раз буду показывать на картинке, которую я нашел, по-моему, на хабре. Собственно,
у нас есть слева робот, который себя представляет, ты ж программиста, он умеет, и повар, и садовник,
и маляр, и водитель. Но нам будет удобно из этого робота в точки зрения ООП сделать четыре
отдельных подробота, каждый из которых будет повара, садовником, маляром и водителем. То есть
мы создаем с вами четыре класса. Давайте вспомним как раз связь с предыдущим занятием. Помните,
мы с вами говорили про cohesion и про coupling. То есть cohesion это что у нас с вами?
Да, связность у три класса, coupling это связность между классами. Соответственно,
давайте подумаем, если мы у нашего товарища разделим на четыре класса, то что мы с вами
в терминах cohesion и coupling сделаем? Так, давайте подумаем. То есть у нас был класс, у него было
четыре ответственности, каждые из которых явно пересекались внутри одного объекта. И это все было
у нас в одном классе. Cohesion у этого класса какой? У нас нет ребер между вот этими объектами зачастую.
То есть у нас наоборот cohesion был низкий. А так у нас получается четыре класса с более высоким
cohesion. То есть в терминах cohesion мы с вами растем. Это cohesion, это coupling. Нам хотелось бы,
чтобы мы оказались здесь. Хорошо, cohesion это связность внутри класса, coupling это связность
между классами. Так, лучше? Все. Нет, нет, нет. Внутри одного класса. Смотрите, у нас
сначала вот это все, в сущности это были объекты одного класса. А потом мы их разделим на четыре
класса. То есть в момент времени t равна нулю, когда мы не разделили обязанности, у нас получается
есть по факту один общий класс, в котором есть внутри связи. Если неформально математически
говорить, давайте скажу, что это, грубо говоря, количество связи графе, поделенное на общее
количество связи. Понятно, формальное определение немного другое. Вот. Ну, тем самым у нас
получается доля связи внутри каждого класса растет. То есть у нас в терминах, вот если мы находили
здесь, то cohesion, так, стоп, high cohesion, low coupling. То есть мы находимся здесь, cohesion у нас точно
растет. Так. Что касается coupling? Связанности между классами. Ну, тут надо замерять. В общем,
потому что у нас, возможно, эти классы между собой сильно были связаны, но тогда надо смотреть по
зависимости в классе, все хорошо или нет. То есть мы можем пойти как и сюда, так и сюда. Но скорее
всего, если у нас хорошо продумана архитектура системы, то мы вправо не пойдем. Мы пойдем либо
вверх, либо влево. Собственно, приближаясь к нашей идеальной точке. Понятно? Сразу скажу, что
вся эта вещь чисто субъективная. Поэтому тут не надо воспринимать это все как истину в последней
инстанции. И сразу скажу, что solite обычно применяется в последней стадии. То есть перед,
точнее, после всех аббревиатур, которые мы с вами рассмотрели. Тут важно сказать, что бывает такое,
что один класс играет одну обязанность, или один класс должен выполнять одно дело. Но тут важно
обычно именно разделить по ролям все. То есть в принципе человек, он многозадачный. Но при этом
не стоит делать сразу класс человек, который умеет делать все сразу. Хотя в жизни такие примеры
случаются. Понятен ли вот этот принцип? Стараемся... Да. Вы еще раз говорите, у нас был класс, в котором было много внутрифункционала, потом мы разделили на много подкласса. Почему у нас тогда акохижен, который является связанным с внутри класса, увеличивается? Потому что, смотрите, еще раз, изначально в момент времени А это был один класс. А акохижен, считаю, если мы говорим в среднем по программам продуктов, он считается в среднем по всем классам.
Вот. То есть получается акохижен у нас внутри каждого класса относительно вырос, потому что здесь связи было много. Ну представьте себе, что у нас вот здесь типа было там очень полный граф. То есть внутри каждого из этих подклассов у нас акохижен единица. Ну можем считать. А тогда у нас получается, что в момент времени Т1 у нас акохижен для этих четырех классов.
Будет средний единичка. А в момент времени Т0, когда мы еще не разделили на классы связанность, то было меньше. Потому что у нас каких-то ребер здесь нету. Каких-то взаимосвязей.
То, соответственно, у нас в момент времени Т0 акохижен был меньше единиц. Вот. Но опять же, если акохижен в такой момент времени не растет, значит что-то у нас проблема с кодом.
Опять же, говорю, что это чисто субъективно. И тут у нас больше именно про такую вещь говорим. Так. Есть вопросы по этому принципу?
То есть если вы видите в коде, что у вас, допустим, какой-то класс а-ля университет делает много чего, ну подумайте. Может быть его надо на департаменты разбить. Или на какие-то другие роли.
Вот. Собственно, опять же, это помогает разрешать GotObject.
То есть, у нас не полный граф связанств между этими подклассами.
Да, да. Именно так.
Так, следующий принцип, который очень хороший и связан с тем, что не нужно копипастить много кода.
То есть не нужно переформатировать код из одного места в другое.
Метод называется открытость и закрытость.
Значит, запоминаем. С ним часто будем встречаться. Класс обычно открыт для расширения.
Чтобы вы понимали, что такое расширение, это extents.
С другой точки зрения это наследование.
То есть мы можем сказать, что класс обычно должен быть открыт для наследования и закрыт для модификации.
Как пример. Представьте себе робота, который умел резать что-то.
Дальше он говорит, окей, я закрываюсь на ремонт.
А дальше я говорю, что он говорит, что я умею красить.
Через некоторое время.
Понятно, что мы внесли модификацию нашего исходного робота.
И если наш робот снова захочет что-то резать, то у него возникнут проблемы.
Потому что мы это откатить не можем.
Поэтому лучше, если так делать, лучше создать наследника класса.
Робота, который умеет резать, который теперь есть функция красить.
То есть у него добавляется дополнительная функциональность.
Связано с тем, что мы с вами можем дополнительно красить.
Соответственно, если мы хотим, это на самом деле не очень хороший пример.
Лучше сделать так, что если у нас есть какие-то два класса.
Создать какой-то базовый класс.
И дальше отнаследовать от него два класса, которые умеют что-то делать.
Образно говоря, мы можем...
Если у нас какое-нибудь, допустим, есть транспортное средство.
То у нас в качестве транспортного средства может быть, например, какая-нибудь машина.
Либо самокат.
Кто знает, как самокат по-английски пишется?
Ну давайте скейт его назовем.
Конечно, это не будет самокатом.
И, допустим, эти оба транспорта умеют ездить с какой-то скоростью.
Допустим, у нас есть метод move.
Но при этом они могут передвигаться по разной поверхности.
Конечно, это не очень хорошо, и это обычно всех бесит, но все же реальности у нас такие.
Допустим, у скейта есть свои ограничения по скорости,
у машины есть свои ограничения по скорости.
И вот как раз зачастую паттерны проектирования, про которые мы сегодня будем говорить,
они заточены про то, чтобы как раз разрешать принцип открытости-закрытости.
То есть, смотрите, если у вас чешутся руки в каком-нибудь родительском классе,
поменять код, то значит, что-то в вашем коде, возможно, не так.
Так, давайте спрошу вопрос по этому принципу.
Так, нет вопросов. Хорошо.
Третий принцип называется принцип замены Барбары Лисков.
Значит, если говорить неформально, представим себе, что у нас класс B наследуется от класса A,
это значит, что замена класса A на класс B не ломает логику функционала.
То есть, вы пользовались объектом класса A, потом вы пытаетесь перейти на наследника
и пытаетесь вызвать тот же самый код.
Канонический пример, который есть, это вычисление площади фигуры.
В чем есть проблема вычисления площади фигуры?
Вот, у вас есть, допустим, класс Эллипсис.
И в качестве его наследника какой есть класс?
Круг.
И у него есть метод Эрия.
Допустим, который принимает какие-то параметры и вычисляет AB.
И он вычисляет по какой-то формуле эту функциональность.
Мы с вами понимаем, что если мы хотим посчитать площадь круга,
то есть, у нас есть Эллипс и мы хотим у него посчитать формулу круга,
то, соответственно, замена Эллипса на круг не должна менять формулы вычислений.
Если мы явно пропишем просто методы, которые у нас здесь есть,
точнее, параметры, которые у нас есть, то и площадь круга у нас посчитается неверно.
Потому что мы хотим для площади круга посчитать площадь это 1 квадрат,
а как минимум в Эллипсе нам нужно не использовать несколько параметров, а не 1.
То есть, если у нас будет поле, относительно которого мы можем посчитать код,
то тогда без проблем.
Если мы говорим про пример здесь, то мы говорим следующее.
Давайте посмотрим на картинку.
Представьте себе, у нас есть отец и сын.
Сэм говорит, что я готовлю кофе, а этот товарищ говорит, что давай тоже кофе.
Ему, говорит Сэм, сделаешь кофе.
Он говорит, что отлично, спасибо.
А теперь доверяют это все тоже самое сыну, дочернему классу,
вот этого маленького робота.
Он говорит, что я готовить кофе не умею, но вот вам вода.
То есть, он умеет отдавать какой-то другой результат,
чтобы функция «сготовь кофе».
Это не очень хорошо.
Соответственно, если мы говорим, что сделаем кофе,
то мы можем, допустим, сделать конкретный кофе.
Это нам никто не запрещает по спецификации.
Поэтому с этим нужно быть аккуратнее.
Зачастую этот принцип не часто встречается на практике,
но тоже с ним нужно будет быть аккуратнее.
И примеры. Тут как раз про фигуры.
Будьте аккуратны. Как решать его?
Нужно выносить функциональность не через параметры,
чтобы у нас ничего не ломалось, а заносить это в поля.
Этого класса.
Так, понятен ли этот принцип?
Этот принцип на самом деле самый сложный для понимания.
Почему это важно?
Потому что, зачастую, что нам позволяет вообще делать наследование?
И принцип ООП.
У нас есть класс А.
Мы можем объявить с вами образно говоря.
Давайте я на С++ напишу.
То есть у нас есть класс А,
который является новым экземпляром класса B.
Мы общаемся с вами с объектом класса A.
Потому что у нас класс A наследуется от класса B,
а наследуется от класса A.
Что мы с вами хотим?
Мы хотим, чтобы когда мы, допустим, высунули,
чтобы у нас было не только класс A,
но и класс B.
Мы хотим с вами, чтобы когда мы, допустим, вызовем A.find,
у нас выполнился функционал именно нормального класса,
а не наследника.
То есть, допустим, это если у нас есть абстрактный класс.
Вот.
Иначе это все будет работать.
Значит, как вы думаете,
когда можно обнаружить принцип нарушения барбаралисков?
В коде.
Виртуальное наследование.
Виртуальное наследование,
оно нам как раз помогает сделать вообще наследование.
Виртуальное может быть...
Смотрите, если вы в коде где-нибудь касты встречаете,
особенно динамик касты,
это скорее всего, что вам нужно перейти именно в конкретный экземпляр
конкретного класса.
А в принципе ОХОП лучше такого не делать.
То есть, закладывать функционал
в сам класс,
допустим, передавая в него какой-то параметр.
Вот.
Соответственно, если у вас в вашем коде будет достаточно много кастов
или проверка на типы,
значит, скорее всего, где-то принцип барбаралисков нарушен.
Так.
Давайте еще раз уточню.
Понятно ли это?
Угу.
Следующий принцип интересен.
И, как ни странно,
он является нативным джави.
Это принцип интерфейс сегрегейшн.
То есть,
суть в чем состоит?
Суть в том, что
не нужно ставить клиент
в зависимости от методов,
которые он не использует.
То есть, мы стараемся,
все наши функциональности, которые есть,
попытаться разделить на максимальное количество интерфейсов.
И вот в джави, допустим, запрещен такой факт,
как ромбовидное наследование.
Что такое ромбовидное наследование?
Давайте я это покажу.
Например, может быть, кто-то из вас знает.
Представьте себе, что у нас есть класс A,
в котором
у вас есть классы B.
Это я рисую так
наследник класса.
И есть класс C.
И мы говорим, что давайте
мы с вами класс D будем наследовать
от
класса B
до класса C.
И это обычно от.
Почему?
Почему не очень хорошо использовать
ромбовидное наследование?
Ну да.
Да, у нас будут методы,
которые не используют вообще.
Более того, если, допустим, у нас
реализации методов B и C
в какой-то момент времени совпадут,
точнее не совпадут, то непонятно,
какую реализацию класс D
должен брать.
И для этого
как раз возникает принцип разрешения зависимости.
И в общем, с ромбовидным наследованием
все обычно сложно.
Собственно, каким
образом его можно разрешать?
Если мы говорим в терминах ООП,
нам как раз понадобится понятие
интерфейсов.
И что нам поможет сделать
интерфейс?
Мы можем сказать
с вами, что у нас есть, допустим, класс A,
от него
наследуется класс B,
а от него
наследуется класс D.
Но при этом мы можем сказать,
что у нас с вами
есть
интерфейс C.
И мы будем
имплементировать
интерфейс класса C.
Точнее, имплементировать
интерфейс C. Это, допустим,
у него был метод read,
который, естественно, является публичным,
поскольку он имеет интерфейс,
и мы должны будем имплементировать этот конкретный метод,
который нам нужен.
Вот.
Вот так это работает в джаве,
то есть в джаве нет равновидного наследования.
Оно просто запрещено.
Но вам разрешается имплементировать большое
количество классов.
Если мы с вами сейчас пойдем
в любую документацию в джаве,
то зачастую
мы увидим вот такое вот.
У нас
я взял библиотеку Hadoop
для обработки больших объемов данных,
ну и давайте посмотрим на замечательный класс
IntWriteable, который позволяет
реализовать обертку над интеджером.
В основном мы видим
с вами, что IntWriteable наследуется
от класса Object.
В джаве за счет того, что у нас
идет линейное наследование,
мы всегда можем отпочковаться
от корневого класса, который является
Object. Но посмотрите,
сколько интерфейсов оно реализует.
Метод Writeable.
Как вы думаете,
что-то у Writeable есть?
Write. Хорошо.
Comparable?
Comparable, да.
И Writeable Comparable?
Comparable Write.
Да, это скорее всего Comparing Write.
Надо смотреть документацию, точно не помню.
То есть видно, что
вот у нас такая обертка есть.
Дополнительно, кстати, в джаве
есть такое понятие как Generic.
Это не совсем шаблоны,
но работает по похожим принципам.
Мы сразу видим, что
у нас класс InWriteable,
если мы захотим,
мы можем сделать intComparable.
Что нужно сделать, чтобы сделать
intComparable?
Сколько интерфейсов нам нужно будет
реализовать?
Один. На самом деле нам достаточно
будет реализовать интерфейс Comparable.
Вот таким вот образом
это можно решать.
То есть можно оплодить большое количество интерфейсов.
Это без проблем.
То есть старайтесь максимально сильно думать,
нужно ли вам большое количество
абстрактных классов или можете обойтись
с интерфейсами.
Так, давайте я спрошу про
Interface Segregation принцип, ясно?
Понятно.
Тут две разные диаграммы.
Была необходимость в Diamond
на следовании, а слева мы сказали,
что у нас же цели просто вообще другое.
Ну, согласен.
Согласен, это новая архитектура,
и здесь нужно решить, просто какие из методов
класса B и C действительно нам нужны или нет
и может быть их стоит вынести в интерфейс отдельный.
А когда вообще может возникнуть
ромовидное...
Не знаю. Обычно
это последствия
к чему может привести
неправильное архитектурирование.
Но зачастую, допустим, у нас
A.
Вот как раз пример.
Допустим, у нас есть
класс, собственно, обертка
над writable, дальше мы применяем
определенный тип, дальше мы
применяем метод для сравнения.
Соответственно, что такое int writable?
Это, собственно, int, который
и в writable, и comparison.
Готов к write, имеет
реализация метода write, имеет реализация
метода compare. Ну, пожалуйста.
Мы получаем как раз вот, типа,
вот этот класс, наследник этого класса
и этого класса. Но зачем
нам делать, если мы можем, допустим, сделать
два интерфейса и от них отимплементироваться?
Да, кода будет больше.
Но, по крайней мере,
с ромовидностью мы исправимся.
Есть еще некоторые паттерны,
которые позволяют избавиться от такого
ромовидного наследования.
Если забегать наперед, это
как раз запринтонный мост.
Вот. Там как раз вот
похожий пример
с, так сказать,
с устройством
и с тем, кем оно управляет,
можно будет разделить. То есть там
по факту у вас есть какое-то
ромовидное наследование, оно делится на
два простых наследования и
связь между ними.
Если будет два интерфейса с одинаковым функционалом, который был общим функционалом, это А.
Там же будет та же проблема, что непонятно, сколько в ДРС.
Там в ДРС будет условно два метода Райта.
То есть те методы, которые есть в А, которые общие в Б и Ц.
Если даже их разделить делом для копии А, то все равно они не решают.
Потому что сам проблема с тем, что у нас один тот же метод и не по этому кто выбирать.
А, типа что у нас?
Все равно же есть общий функционал и идея того, что просто их сделают.
Да, согласен.
Смотрите, тогда мы можем сделать следующее.
Давайте мы скажем, что Ц, вот если нам нужен, допустим, отдельный класс Ц в сопринянной роли,
мы создадим интерфейс Е.
Ц будет наследоваться от класса А и имплементировать интерфейс Е.
А тогда что у нас будет делать класс Д?
У нас должен быть такой же функционал, как у класса С.
А класс С что делает?
Наследуется от класса А и имплементирует интерфейс Е.
Тем самым нам по факту нужно сделать так, чтобы класс Д наследовался от класса Б.
И имплементировал интерфейс Е.
То есть вот таким вот образом мы прокидываем и решаем ромбовидную наследовательство.
Это один из способов решения.
Спасибо за вопрос.
Нет, не всегда.
Тут надо смотреть по коду и читать, в него вникать.
Да.
Да, да, да.
Ну то есть зачастую вам излишней реализации просто не нужно.
То есть ее можно добавить по месту.
Так, хорошо.
И давайте теперь еще один принцип, если с этим разобрались, будет очень важный.
На самом деле он такой фундаментальный и помогает решать проблемы не ромбовидного наследования,
а ромбовидной зависимости.
Смотрите, он формулируется из четырех тезисов.
Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
Второе, модули должны зависеть от абстракции.
То есть если у вас есть класс Б, дальше у вас класс Б что-то использует,
то лучше это делать через обертку.
Эта обертка, как ни странно, называется адаптером.
Дальше, абстракции не должны зависеть от деталей.
То есть нижний уровень не должен зависеть от деталей реализации.
А вот детали реализации должны зависеть от абстракции.
То есть смотрите, давайте я сразу на примере покажу, чтобы было понятно.
Вот пример.
Что мы здесь видим? У нас видите здесь четырехугольник A, B, E, C.
На левой картинке.
То есть у нас A, смотрите, зависит от B, B зависит от E.
A зависит от C, C зависит от E.
В чем проблема? Если мы с вами в E поменяем код, то что может произойти?
Ляжет либо B, либо C.
С высокой степень вероятности ляжет только A.
Ответственно, мы можем стрелочки из B в E и из C в E инвертировать.
Это как раз называется вет от инвертирования зависимости.
Принцип инвертирования зависимости.
Давайте мы скажем, что E, что B.
Для того, чтобы реализовать зависимость, нужно сделать интерфейс.
Роль, который ему нужно.
Мы ставим его в экземпляры класса.
И дальше у C ставим экземпляры класса тоже в зависимости от интерфейса.
А дальше E, который зависит снизу.
Получается деталь будет зависеть от абстракции.
Что нам это позволяет сделать?
Нам позволяет сделать так.
У нас метод C каким-то образом поменял функционал.
Ему нужно внести в зависимость в интерфейс.
В интерфейс лучше не менять, но допустим нам код E каким-то образом нужно поменять.
Мы меняем код E, но при этом интерфейсы у нас не меняются.
Они пристыковываются как к B, так и к C.
И ничего не ломается.
В хорошем случае.
Да, такое может быть.
Но обычно, скорее всего, вот прямо жестко копифасты в данный момент прямо не возникнет.
Нет, смотрите, это так.
Наследоваться от E в каком месте? Влево, вправо?
E в зависимости от C. E нет. Они в зависимости от интерфейса.
Ну да, они в зависимости от интерфейса.
Но по факту мы говорим следующее.
Представьте себе классический пример.
Тут, кстати, есть картинка.
Давайте посмотрим внимательно на картинку.
Я не знаю, плохо видно.
У робота есть рука, которая заменена на пилу.
Понятно, чтобы заменить эту пилу на какую-то другую вещь,
надо отпилить эту пилу и вставить что-то новое.
Что обычно делают в этом месте?
Делают переходник, который позволит одно заменить на другое.
В этом месте переходник – это как раз интерфейс, с которого мы можем подключиться.
Грубо говоря, если мы хотим с вами поменять зависимость,
то нам нужно сделать переходник.
И при этом, возможно, нам код класса E вообще придется переписывать.
Главное, просто в те пазы, которые у нас есть для класса C и B, встал интерфейс E.
А теперь направо. Какая зависимость между E и B и C?
Смотрите, в левой картинке B дергал на прямую E, и C дергал на прямую E.
А в правой, он говорит, так, B нам нужна функция, образно говоря,
чтобы мы готовим, допустим, какое-то блюдо, оно что-то взмешивало.
То есть мы взбалтываем блюдо при помощи инструмента E.
Мы говорим, что у B есть метод взболтать, у интерфейса есть метод взболтать.
И у C есть, допустим, метод перемешать.
Хотят болтать, перемешать, это одно и то же.
Давайте добавить приправу.
Что мы могли сделать? Мы могли пойти купить мясорубку,
какую-нибудь, которая это все будет делать.
Но потом, когда мы берем и вместо мясорубки подключаем какой-нибудь кухонный комбайн,
то мы понимаем, что у нас электричества внезапно нету, чтобы это все подключить.
А здесь мы говорим, что нам для того, чтобы работать с B и C, нам нужно два метода.
А кто именно их будет делать, нам вообще без разницы.
То есть, образно говоря, давайте еще, кстати, какой-нибудь такой классический пример.
Нам, допустим, нужно написать код какой-нибудь, который якобы будет работать как линукс-система.
То есть нам неважно, что именно и на каком устройстве это будет эмулироваться.
Мы делаем специальную прослойку, которая обладает этим интерфейсом.
А зависимость, которая находится внизу, она просто должна реализовывать эти интерфейсы.
Вы можете использовать Windows Subsystem for Linux для этих целей.
Либо поставить виртуалку, либо использовать Docker.
Вот у вас три варианта.
И это позволяет нам легко переходить и эмигрировать с одной платформы на другой.
То есть это больше пропортируемость.
Я ответил на вопрос?
Все, отлично.
Интерфейсы без полей.
Вообще без.
В классической терминологии интерфейсов интерфейсы не имеют никаких полей.
Да, то есть наследование полей происходит при наследовании классов только.
Ну вот, а у вас какой-то пример?
У нас есть интерфейс с полями.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
У нас есть интерфейс без полей.
Полей происходит при наследовании классов только.
Ну вот, а в какой ситуации у нас в ебулике суперважные поля,
которые должны быть влепаться и а,
и тогда интерфейс не прокатится?
Ну, придется дублировать код немного.
То есть обычно есть, говорю,
что обычно все-таки есть одна общая ветка наследования,
и дальше уже от нее ответление в виде интерфейсов.
Мы же в одном из предыдущих принципов убедились,
что если у наследника есть такой же метод,
так его лучше выносим из типа поля.
Например, площадь.
Так, вот этот, да?
Open-closed principle. Так, еще раз?
Можете сформулировать, я?
Площадь мы выносим в поле, чтобы могли...
А, согласен.
А, принцип замены барбаралисков.
Да, есть такое.
Собственно, видно, что некоторые из принципов
могут между собой конфликтовать.
Собственно, принцип лисков и принцип dependency inversion.
Выход посмотреть, насколько сложная у нас система
и использовать более приоритетно.
То есть если у нас система с огромным количеством зависимости,
ну, просто большая экосистема,
то лучше смотреть dependency inversion,
потому что самое важное в нашей системе это гибкость.
А что такое гибкость?
Гибкость — это возможность в любой момент времени
быстро адаптировать нашу систему к реалиям.
Вот, при помощи dependency inversion мы можем, в принципе, взять,
оцепить наш интерфейс Е, который здесь имеется,
и заменить его на новый.
И это нам намного важнее, чем смотреть на какие-то вот принципы замены.
То есть мы один из приоритетов, мы один принцип вставим, приоритет нет?
Да, да, да, да, конечно же.
Смотрите, у нас пять принципов,
и понятно, что возможных взаимосвязей,
типа включаем-выключаем принцип 32, 2 в пятый.
Поэтому некоторые из них могут в какой-то степени конкретовать.
Опять же, это субъективная вещь,
то есть надо смотреть, к чему стремиться,
и попытаться выставить приоритеты.
То есть обычно single responsibility — это хорошая вещь,
потом на практике часто очень сильно встречается dependency inversion,
и это вот обычно боль,
с которой я даже сталкиваюсь на практике,
в которой собственно классы приходится самим руками раздвигать.
Interface segregation — он в некоторых языках реализован.
Open-closed тоже зачастую важен, чтобы не лезть в родительский класс.
Потому что, смотрите, мы когда работаем с вами с программным продуктом,
работаем не только мы.
Работаем большое количество пользователей и большое количество программистов.
Соответственно, если мы пойдем править что-то, грубо говоря, в щиток,
то может произойти такое, что щиток вырубит,
и все останутся без света.
Так, это все принципы солят.
Давайте еще раз напомню.
Single responsibility principle, open-closed principle,
list of substitution, interface segregation, dependency inversion.
Так, есть ли вопросы по ним?
Хорошо.
Давайте тогда движемся к другим вещам.
Собственно, на самом деле,
солят обычно применяется после того,
как мы применим еще несколько принципов.
Первый принцип, который здесь возникает, это принцип ягни.
Он расшифровывается, вы не поверите как.
Вам этого не надо.
То есть зачастую, особенно мы в фистехе,
есть такая расположенность,
сразу сделает что-то вот такое супер-мега-уникальное.
То есть кажется, что давайте продумаем убер-мега-систему.
Кстати, про пример.
Помните, у нас возникали дебаты по поводу того,
что у нас сложная процедура верификации на курс.
Что там вручную надо одобрять заявки все и так далее.
А нельзя ли придумать какую-нибудь систему,
которая автоматически будет принимать заявки,
ну по крайней мере делать какие-то фильтры.
На самом деле, изначально, когда задумывалась система,
она не подразумевшляла, что в ней будет большое количество пользователей.
Изначально она вообще писалась для одного курса технологии программирования.
То есть нам не нужно было вот слишком сложные проверки.
То есть нам этого просто не надо.
И мы начинали отсекать все лишнее.
То есть вы читаете спецификацию,
и вообще, когда вы читаете первое техническое задание,
которое вам может прийти,
это не те технические задания, которые вы будете задавать.
Это, допустим, задание на выполнение какого-то проекта или какой-то стартап.
Вы начинаете думать о какой-то замечательной идее,
которую можно реализовать.
Вы понимаете, читаете, начинаете набрасывать идеи,
у вас скапливается огромный ворох идей.
А потом это называется брейншторм.
Кстати, важный совет.
Во время брейншторма не перебивайте людей.
То есть это именно накидывание идей на вентилятор.
После этого собирается и отсекается все лишнее.
То есть не нужно, так сказать, ограничивать себя в мыслях,
но, правда, нужно потом это жестко будет обрезать.
Все эти дополнительные функционалы.
Может быть, у кого-нибудь есть примеры,
как вы понимаете это все дело.
Возможно, мы с вами синхронизируемся сейчас.
Был ли у вас такой кейс,
что вы начинали делать какие-то вещи,
надумывали себе много-много-много,
а потом оказывается, что большую часть,
когда вы доходите до них, вам вообще не нужны?
Это такой жизненный принцип.
Допустим, вы говорите,
я сейчас реализую супер-пупер-мега-систему,
потом понимаете, так, это не надо, это не надо, это не надо.
То есть вы очищаете все шелухи.
Следующий принцип,
который позволяет нам это все сделать,
это метод кейс.
Это keep it simple-stupid.
То есть старайтесь сделать все максимально тупо,
в первую очередь.
Начинайте придумывать,
и потом начинайте вычислить.
Начинайте придумывать,
и потом оказывается следующее.
Здесь изображен,
мне не надо бежать впереди перевоза.
То есть сначала нужно остановиться,
попытаться выделить какие-то простые сущности
и начать реализовывать ее.
Здесь важен фазовый переход.
Обычно, когда мы что-то придумываем новое,
есть обычно несколько фазовых переходов.
Первый фазовый переход от нуля к единице.
То есть у вас ничего нету,
а потом вы делаете переход к тому,
что у вас что-то есть.
Как вы думаете, какой второй фазовый переход?
От единицы к двойке?
Нет, ну на самом деле от двойки до ста
бежать намного быстрее,
чем от единицы до двойки.
Как ни странно, потому что вы придумываете масштабирование.
На самом деле, если кто-то
уже решал математические задачи,
там бывает тоже такой кейс,
что для n равно 1 очевидно,
для n равно 2 какой-то простой пример,
а потом оказывается вся идея
раскрывается в том момент времени,
когда вы переходите от n равно двойки
к n равно тройки.
Возможно, сталкивались,
если решали какие-то телепиадные задачи по математике.
Поэтому давайте это зафиксируем,
что для того, чтобы перейти
от 0 к единице,
нужно делать все максимально просто,
потому что, скорее всего, от вас
очень быстро запросят новый прототип.
А потом вы только займетесь
масштабированием и внедрением
всяких технологий.
То есть это важнее.
То есть вы не можете
перейти от 0 к единицы,
а вы можете перейти
от 0 к единицы.
То есть стараемся очищать
все лишнее.
Смотрите, ягни
нам помогают оставить
только то,
что необходимо,
чтобы вообще начать реализовывать
единичку, чтобы не заглохнуть в этом.
А кис
позволяет как раз сделать переход
от 0 к единицы.
И следующая вещь
это драй.
Это мы больше
уже говорим про
переход от 1 к 2
или про другие
интересные вещи.
Ну, собственно,
не копипастим, если
грубо говорить.
Метод называется Do not repeat yourself.
Тут как раз Барт
Симпсон, который пытается написать
текст 500 раз.
В любой заставке Симпсонов
можно увидеть.
Стараемся не дублировать код.
Максимально
и четко.
Точнее, максимально
в многих местах, потому что, смотрите,
что у нас получается?
Если мы начинаем сильно дублировать код,
то у нас сильно растет каплинг.
Причем, самый худший
уровень каплинга, который существует.
Вы не поверите, есть
противоположный этому принципу
принцип.
Кто знает Антоним слово
WET?
Есть принцип WET.
Расшифровывается он как
write everything twice.
И, знаете, шутки
шутками, но если
мы говорим про
разработку систем, он обычно не
подходит. Но как только мы идем
в работу высоконагруженных
баз данных,
там как раз начинает
работать принцип WET. Он называется
принципом денормализации и
дублирования данных.
Потому что система начинает просто работать
быстрее.
Но про это вам расскажут детали,
наверное, на курсе баз данных или, если вас
это заинтересует, немного поговорим
про нормальные формы здесь.
Так, это принцип
dry. Теперь, смотрите, чтобы вы понимали,
в каком порядке они применяются.
Первый, применяются
ягни, то есть мы отфильтровываем лишнюю
шелуху. То есть здесь мы видим, что у нас
шифровывается желтая фигурка,
цилиндрик и так далее.
Дальше мы
вот у нас есть какие-то сложные
абстракции. Мы делаем их максимально
простыми, чтобы клиент сразу
получил хоть какую-то версию продукта.
Потому что, собственно, продукт это
деньги, деньги это время.
Наоборот.
Время это
деньги. Продукт это
время, время это деньги. Вот так вот.
Вот. А после этого мы с вами
уже начинаем группировать объекты,
для того, чтобы они не дублировались и для того, чтобы мы
могли поддерживать систему для
дальнейших фазовых переходов.
Так.
Понятны ли эти принципы?
Хорошо. Вопрос на понимание. Как вы думаете,
где в этой цепи солят будет находиться?
Где-то там еще...
Да, правее. Правее dry обычно
находится солят.
Я где-то пирамиду
видел. Мне надо будет ее, видимо, в чат
прислать. Я пришлю в
тему вопросов по лекционным материалам.
Типа, из чего эта вся пирамида стоит?
Ну, ягнитом на самом первом месте находится.
Так. Давайте двигаться дальше,
если вы не против. Теперь давайте
немного мы отклонимся в сторону,
для того, чтобы мы дальше
все понимали общий язык.
Мы будем с вами говорить про язык Unified
Moduling Language, UML.
И, собственно, здесь, как ни странно,
мы видим, что я уже
все классы писал не при помощи
кода, а при помощи вот таких вот диаграмм.
И давайте
как раз научимся механизмом использования
этих диаграмм. В следующий раз
мы будем рассматривать более детально
эти диаграммы. Они как раз будут полезны
для того, чтобы спроектировать первую
итерацию вашего проекта.
Давайте введем
нотацию, которая будет полезна
далее. Сразу говорю, что
обычно люди в 90...
Эта вся история возникла в 90-х годах,
и люди думали, что при помощи всех этих
диаграмм можно спроектировать весь код.
То есть, если сейчас
код пишется посредством чата ГПТ,
люди пытаются писать. Правда,
скоро скажу, чат ГПТ иногда фигню дает.
Причем очень жесткую
фигню. То есть оно кажется...
Знаете, читаете,
оно пишет, пишет, пишет,
а потом вы понимаете, что оно фигню
всякую написало.
То есть, которая даже может быть
визуальные тесты проходят, но потом
по существу оно делает не то,
что надо. Поэтому с этой штукой будьте
аккуратнее.
То в 90-х годах думали
все намного проще. Давайте мы нарисуем
диаграммы, а по диаграммам сгенерируем код.
То есть наладим четкие связи,
и дальше у нас
появится код. Это
далеко не зашло, но для проектирования
архитектуры это достаточно важно.
И в текущий момент времени.
Поэтому давайте знакомиться.
Представим себе, что у нас есть
template class.
Классы обозначены синим цветом. Кстати, мне
надо цветовую гамму будет поменять.
И у него здесь есть
следующее. У конструктора класса
есть модификаторы
доступа, во-первых.
Сверху написано поля,
снизу написаны методы.
Мы видим, что здесь
есть конструктор класса, template class.
Дальше у нас есть методы. Они
могут быть публичные и приватные.
И поля тоже могут быть
публичные и приватные. Вот эта штука
это комментарий.
Таким образом обозначаются комментарии
в этой диаграмме.
И здесь есть важный момент. Здесь есть
подчеркнутый метод.
Это означает статический метод.
Кто слышал понятие
статический метод?
Отлично.
Давайте еще раз
поясним, что такое статический метод.
Это метод, который можно вызвать
без наличия экземпляра класса.
Таким образом выглядит класс.
При этом между классом
могут быть разные типы взаимодействия.
В UML выделяют
три типа. В связи
первая композиция.
Давайте расскажу, каким образом это читать.
Это читается
следующим образом. У машины
есть четыре колеса.
Одна машина, если здесь не указано,
это означает, что здесь единичка.
Здесь указывается модификатор кратности.
У машины четыре колеса.
Причем важный момент. Здесь, видите,
у нас есть вот этот закрашенный ромбик.
Это означает следующая.
Это означает две вещи. Во-первых,
колесо это часть машины.
И без понятия колеса
понятие машины так или иначе
существовать не может. Почему?
Почему без понятия колеса
машина не может существовать?
Ну, какая цель и главная машина?
Ездить.
Вот.
А машина может ездить без колес?
Во принцетонах ездила.
Ну, во принцетонах ездила,
но зачастую нет. То есть
как бы это получается непосредственно
и важная часть
общего, единого целого.
Так, сейчас давайте вспомним.
Ну, да, наоборот, скорее
всего. Сейчас.
Наоборот неправда.
Значит у меня багов в презентации.
Это объект, который позволяет
осуществлять какое-то вращение.
То есть оно может вращаться,
но при этом колесо
получается колесо
непосредственная часть машины.
Поэтому обычно не запариваются,
потому что вот эти вот
тонкие связи как раз на человеческом уровне
сложно разделить.
То есть мы можем считать, что
машина без колес не поедет.
При этом колесо часть машины.
Сейчас давайте подумаем.
Как-то бы аккуратнее сделать.
Ну да, да, смотрите.
При создании объекта машины
вот это хорошее замечание
должно создаться в нем список
из четырех колес. Прямо при его
создании.
После вызова конструктора.
Можно просто для камеры вот
спросить, это может быть список
из четырех или что?
Нет, это здесь уже идет
реализация на уровне кода. То есть вы можете
как раз написать, что у вас
по факту в машине
будет список из четырех колес.
Как таким-то образом
в классе машины будет храниться
четыре объекта класса колеса?
Да, каким образом?
Если у нас объект класса машины
в класс машины как-то зависит от класса колеса,
зачем нам вот этот вот ромбик?
Если и так очевидно, что
у нас, чтобы
существовал класс машины, просто
обязательно нужно понимать, что такое
колесо, потому что в машине задействовано колесо.
Разве это не изучная
информация?
Смотрите, здесь как раз если мы
говорим про композицию,
то по факту это же дело
все для автоматической валидации.
То есть на этапе валидации, как раз
если мы...
А?
Ну на этапе, когда мы начнем запускать
этот код, проверять нашу диаграмму,
там вызовем каким-то образом
конструктор класса машины, и в нем не
окажется четыре колеса.
Да, все. Это означает,
что проверка не прошла
и, собственно, диаграмма неверная.
Вот что это означает.
То есть раньше затачились
под то, чтобы эта диаграмма работала.
И по ней можно было генерировать
работающий код.
То есть если бы, смотрите,
здесь бы ромбик был не такой, а
не закрашенный, то в принципе
мы могли бы сделать следующее. Создать класс
машины, а после этого в какой-то момент времени
в будущем добавить в нее четыре колеса.
Сейчас, нет, у нас уже в машине
описано, что у нее есть колесо. Разве это в описании
не достаточно? А, вот про вот это
колесо? А, да, это излишнее
описание. То есть в данном случае ромбик
это излишнее описание?
Нет, вот это вот излишнее описание.
Вот это, то есть его можно убрать.
То есть ромбик означает, что
в чем-то есть... Да, что-то другое, да.
Все.
А можно в описании
не указывать поле вилл
класса вилл, потому что оно из диаграммы
подтягивается.
Вот, причем смотрите,
поле, которое указывается, оно указывается
прямо с классом вилл.
Типа получается, как
это читать? У класса машины
есть четыре экземпляра класса
колеса, в котором можно
обратиться по полю вилл.
Вот такая же ромбик, это
именно является...
Как обязательный объект.
Содержится как объект.
Как обязательный объект.
Потому что есть и содержится как необязательный объект.
Вот, это агрегация.
Да.
Собственно...
Такой
интересный пример.
Собственно, класс состоит из
студентов, но при этом
студент, в принципе, может
существовать помимо класса,
он может присоединиться к какому-то
другому классу.
Либо вообще сделать индивидуальный учебный
план и ходить на занятия с кем угодно.
Вот, а та... А?
Просто тут я вижу
проявляться с предыдущей подписью.
Да.
Существование правой, штуки без лев.
А в предыдущей подпись мы решили,
что там не то должно быть.
А, блин, черт.
Может быть, все-таки там было описано то, что мы хотели?
Наверное, да.
Э...
Сейчас, секунду.
Наверное, да.
Тупню, туплю.
Да, давайте разбираться.
Скорее всего...
Сейчас.
Ну, тогда и пример с колесом
не очень хороший, потому что колесо
может существовать само по себе.
Хорошо.
Ну, например, какой-то такой руль пойдет?
Руль пойдет.
Ну, чем
тогда он управлять будет?
Ну, чем тогда он управлять будет?
То есть, руль это обычное устройство управления,
к чему-то привязанное.
Ну, тогда это делается
через наследование.
То есть, у нас есть базовый класс вида руль,
который присоединяется к классу вида
устройства движения,
и тогда это будет композиция.
Вообще, смотрите.
Тут можно четко не
разграничивать роли.
Опять же, это чисто вот нотация EML.
Она вот явно показывается.
То есть, можно не разграничивать роли,
а можно не разграничивать роли,
но она вот явно показывается.
То есть, вы можете рисовать ромбики,
и, в принципе, этого будет достаточно.
Главное, чтобы вы понимали, каким образом связи работают,
что одно содержит другое.
Вот. И для наших целей этого будет достаточно.
Мы тут не пришли для того,
чтобы EML изучать.
Потому что, а для того, чтобы изучить EML,
нужно отдельный семестровый курс,
который неприятный при чем.
Зачастую.
Визитивский закрашенный ромбик
обозначает то, что это теперь является
Ну, можно считать, да.
Да, да, да.
Да, да.
Вот.
А здесь студент может входить
посредственно в другие классы,
и ничто это ему не мешает.
Вот. Есть обычное
соединение, связь, ассоциация.
То есть, это когда у нас один объект
использует другой объект, но при этом
он является частью другого.
То есть, это обычные поля, которые
не специфицируются никаким образом.
То есть, у нас же может быть,
что у нас у класса
хранится какое-то другое поле, при этом,
которое не является его составной частью.
Ну, в принципе, да.
Такие связи обозначаются
ассоциацией. То есть, это просто
связь без специальных
концов.
Значит, следующая вещь, это
интерфейс. Мы про него уже
рассказали, что интерфейс у нас
исполняет роли, у него есть только методы,
и не может быть полей и реализации.
Здесь мы видим, что
у него обычно есть
только методы. То есть, видите, нет разделения
на полей и класса.
Ой, на полей и
методы. Вот. При этом
класс треугольник может имплементировать
интерфейс фигуры, и
класс circle имеет
имплементацию в виде
класса shape.
То есть, у них у всех есть площадь.
То есть, по-хорошему говоря, если мы хотим
соблюдать принцип Барбар Лисков,
то его можно решать
при помощи наличия интерфейсов.
То есть, мы делаем интерфейс отдельной круга,
отдельный интерфейс для эллипса.
Да, тем более это важно, потому что
у эллипса, так или иначе, обычно
есть специфичные поля, такие как
эксцентритет, большая и малая
полуось и так далее.
Вы же знакомы с
атрибутами эллипсов?
По-моему, на линейной алгебре должно
было проходить.
Ну, хорошо.
То есть, интерфейсы обозначаются
вот таким, обычно, методом,
способом интерфейс. Причем, есть
программы, которые
умеют рисовать такие диаграммы.
И реализация интерфейсов
важно, что она обозначается пунктирной
стрелочкой.
В отличии от наследования.
В наследовании используется
прямая стрелочка
с треугольничком.
То есть, у нас здесь есть животное,
animal. У него есть абстрактные методы,
moveTo.
Они обычно обозначаются курсивом.
И абстрактные классы тоже обозначаются
курсивом. То есть, у нас есть животное,
у него есть наследники класса
млекопитающий и птица,
а у класса млекопитающий есть
наследники
вида кот
и пёс. Один говорит мяу,
другой говорит гав
на реализацию метода сей.
Так, это понятно?
Угу.
Хорошо. Вот, наконец-таки мы с вами
разобрались с диаграммами.
И давайте, наконец-таки, начнём
мы с вами разбираться с
достаточно важной вещью. Это паттерны
проектирования. То есть, пока мы с вами
говорили про какие-то эфемерные принципы,
а теперь давайте поговорим
про принципы, которые имеют чёткое
решение в виде кода.
Вот. И, как ни странно, некоторые
принципы уже позволяют нам реализовать
определённые паттерны.
Значит, давайте поймём, что такое паттерны
проектирования. А это
некоторые принципы, которые
заранее оговорены между
людьми. То есть, чтобы вы понимали,
если я сейчас на каком-нибудь
собеседование приду
про программную инженерию, вам
скорее всего спросят, а какие
паттерны вы знаете?
Соответственно, все сразу поймут, что
мы говорим про паттерны проектирования.
Вот. Теперь давайте поймём,
каким образом они обозначаются. У каждого
паттерна есть заранее определённое
имя, либо несколько имён, по которым
все сразу понимают, что это за паттерн.
Значит,
к имени привязывается задача,
которую решает этот паттерн. То есть,
заранее есть задача, которую мы хотим решить.
У этой задачи
есть конкретное решение.
Конкретный подход
к решению этой задачи.
И те результаты
достоинства и недостатки, которые
даёт каждый из паттернов.
Потому что некоторые паттерны
зачастую могут считать
именно анти-паттернами. То есть, те подходы,
которые мне не стоит использовать.
Вредные советы, так сказать.
Но в некоторых
случаях они сильно помогают.
Так, давайте познакомимся.
Всего бывают три вида
паттернов,
типа паттернов. Первые
паттерны – это порождающие паттерны,
которые помогают создавать
новые объекты. Второй
тип паттернов – это структурные,
которые описывают связь между
объектами. И вот как раз паттерн
Bridge, про который я тут уже упомянул,
это как раз структурный паттерн.
И повиндейческий паттерн – это
паттерны, которые помогают наследовать,
посмотреть, каким образом
идёт общение между объектами.
То есть, выполнение функционала.
Если мы говорим,
так сказать, про физические
аналоги, я не знаю,
тут, наверное, половину у меня сейчас
заклюют, потому что ненавидят физику.
Но половину скажут, типа,
нормас, потому что есть
физика. Собственно, смотрите,
чтобы вы понимали,
порождающий паттерн – это создание материальных
точек.
Структурные
паттерны – это как раз так
называемая статика, или физика твёрдого
тела. То есть, как связь между
объектами. А повиденческие – это
обычная динамика. То есть, как у нас
всё происходит в динамике. Взаимосвязь
между объектами.
Вы не поверите,
паттернов всего насчитывают
или 22, или
23 штуки.
Пять из них повиденческих,
ой, извините, пять из них порождающих,
семь структурных,
и десять,
или одиннадцать повиденческих.
То есть, часть мы будем
с вами рассматривать на лексах, часть мы
будем с вами рассматривать на семинарах.
То есть, как только вы пройдёте
семинары по гиту и башу, у вас будет
первая пара по паттернам.
Давайте начнём
с первого паттерна. Это будет
порождающий паттерн, и он называется
фабричный метод.
Это как раз пример того, каким образом
можно реализовать open clause principle
в конкретном примере.
Представьте себе, что у вас есть
бизнес, который производит сетевые кабели,
и вы
занимались созданием хабов.
То есть, что такое хаб? Это
коробка, которая умеет разветлять сетевой
трафик. То есть,
вы засовываете в неё
что-то, и дальше идёт
перенаправление трафика. То есть, это обычно проводной
интернет. Ну вот, представьте
себе, ваш бизнес расширяется, и
вы думаете, куда двигаться.
И оказывается следующее. А давайте
попробуем производить Wi-Fi роутеры.
В чём
особенность роутеров?
Особенность роутеров
состоит в том, что они сами
создают собственную сеть.
И про это мы с вами ещё будем говорить.
Более того, если у нас с вами
Wi-Fi роутер, то
какую сеть может поднимать Wi-Fi роутер?
Wi-Fi, то есть беспроводную сеть. То есть, у нас
получается ещё один сетевой интерфейс, который мы с
вами можем использовать.
Вот. И дальше
как... То есть, у нас
получается две отдельных сущности.
То есть, мы хотим реализовать одну сущность
и хотим реализовать вторую сущность. Вопрос.
Каким образом связать
производство? Это делается
следующим образом. Давайте мы попробуем
найти что-то общее между хабами
и роутерами. То есть, между
допустим, созданием беспроводной сети и
проводной сетью.
Ну, да,
порты, общие интерфейсы
какие-то и так далее. То есть,
цель как раз вычленить общие.
Я говорю про общий случай, это просто
конкретный пример.
Давайте попробуем сделать.
И как раз что делает паттерн под названием
фабричный метод? Это порождающий паттерн,
который позволяет
определять общий
интерфейс создания объектов
в конкретном классе. И он позволяет
изменить поведение в
некотором подклассе. То есть,
сейчас давайте попробую пояснить
на примерах. То есть,
мы выделяем. У нас создается
два конкретных вида
классов. Первый у нас возникает абстрактный
класс под названием создатель.
То есть, это то, что мы вычленяем
общего в создании этих
объектов. И есть интерфейс
того, что именно мы с вами создаем.
То есть, допустим, здесь у нас будет
завод по производству роутеров.
Значит, конкретный
криейтор
А у нас, допустим, это завод
по производству хабов. Отдел
по производству хаб роутеров
обычных. А второй, это Brazil по
производству беспроводных роутеров,
беспроводных сетей. Что они будут
создавать? Здесь они будут создавать
беспроводную сеть.
А здесь они будут создавать проводную сеть.
Теперь вопрос. Если вдруг
придумают сеть 5g,
то что нам придется
в этом классе сделать?
в этой диаграмме
да смотрите нам нужно будет добавить
еще одного криэйтора который будет
создавать сеть 5g
и параллельно создать интерфейс то есть
смотрите
мы не ломаем логику в методе класса
криэйтор
возникает желание перелопатить код и
и что-то в него встроить
и не ломаем логику самих продуктов то
есть мы соединяем общую функцию допустим
при помощи интерфейса
из-за того что мы не ломаем конкретную
реализацию криэйтора
и не ломаем абстрактный класс
базовый класс это как раз нам позволяет
не нарушать принцип открытости
закрытости
да то есть это как раз пример применения
принципа открытости закрытости про
который мы с вами говорили
а вот и собственно
что на самом деле обычно делает
фабричный метод
просто создает объект определенного
класса
ну как раз то есть в конкрет creation
А у нас будет создаваться фабричный метод
создаваться
конкрет продукта а в конкрет CreatorB
создается конкретный пример
класса B
хорошо
давайте посмотрим на примере
как это происходит
да здесь есть пример базовых
кодов
на каком языке посмотрим с вами
О, Господи! Ну ладно, давайте попробуем плюсы посмотреть.
Значит, cpp-source.
Смотрите, давайте сразу абстракцию.
Так, код создался вот такой.
Извините, что написано на shared PTR.
Так, тему светлую оставим или тёмную?
Светлую нормально видно?
Смотрите, что мы делаем.
Мы пишем следующую вещь.
У нас есть метод connection via hub.
Дальше у нас возникает shared PTR-раутер.
Мы создаём вот этот вот hub.
Да, кстати, не нужный мне поиск.
То есть, видите, у нас класс типа router.
И у класса типа router есть метод connect to net.
То есть в зависимости от типа роутера мы будем подсоединяться к определённой сети.
Значит, если мы говорим с вами про Wi-Fi роутер,
делаем то же самое и создаём вызов сети.
То есть здесь кажется, что у нас просто есть два наследника класса router.
Это либо hub, либо Wi-Fi роутер.
И дальше вызываем метод создания сети.
Но не всё так просто.
Давайте мы как раз посмотрим.
О, здесь же вот такая штука появилась в GitHub.
Давайте мы с вами откроем класс роутер h.
Вот, да, опять же извините.
Видите, у нас есть у класса роутера два метода.
Первый метод это создать маршрут.
И здесь как раз мы увидим с вами, что у нас есть класс route.
И есть метод connect to net.
То есть присоединиться к сети.
Так, давайте посмотрим на реализацию каждой из этих классов.
Соответственно, видите, и вот этот метод create route – это как раз фабричный метод.
Который у hub будет создавать Ethernet route,
а у router, у Wi-Fi роутера будет создавать как ни странно Wi-Fi route.
То есть вот она как раз связь, которую мы с вами видели на презентации.
Вот она связь.
И в данном случае фабричный метод – это метод create route.
Так, хорошо.
И давайте посмотрим, собственно, теперь, что у нас в раутах есть.
Собственно, у метода route cpp ничего нет.
У метода route есть connect.
Метод connect, который мы с вами и вызываем.
Так, секунду, я что-то забыл рассказать.
Наверное, у роутеров было, да?
А, вот оно.
Вот каким образом у нас происходит соединение к сети.
К сожалению, здесь тоже можно разделять код.
То есть мы создаем с вами раут, вид маршрута, который нам нужен,
и дальше к этому рауту подсоединяемся connect.
То есть мы это делаем в базовом классе, не в классе наследника.
То есть это в данном случае вот метод, который здесь есть, – это метод do stuff.
Да, в итоге у нас получается цепь.
Какая?
Внимание!
Внимание!
Поверная!
Весело!
Да.
Ладно, давайте это…
В общем, вот такой вот паттерн, он работает.
Поскольку нас тут прерывает пожарная тревога, то мы сделаем
следующее.
Мы не успели рассмотреть один паттерн, мы его в следующий
раз рассмотрим.
Ну да.
Так что…
А теперь аккуратненько выходим.
