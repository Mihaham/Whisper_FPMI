значит в прошлый раз вы с вами остановились на том что стали решать рекурренты линейные вот
но впрочем можно вот сегодня мы попробуем их решить еще раз да казалось бы зачем особенно
с учетом того что у нас прошлый раз была неплохая симптомика да и забегай вперед сегодня лучшая
симптомику мы не получим но вот но оказывается есть фишка да новую симптомику мы не получим
а константу в лице количество фуриешек которые мы там будем запускать мы улучшим причем более
того возможно вот причем атака у нас пойдет немножко с другой стороны поэтому начнем мы вот
с чего вот иногда часто на вашем жизненном пути встречается динамическое программирование бывает
и часто иногда вот иногда формулы могут выглядеть замечательно так вот там еще
нет вот и часто так то есть и так и часто у нас динамика начинает выглядеть примерно следующим
образом дп и т равно сумме допустим мы сейчас я от балды что-нибудь напишу такое допустим
р и т плюс сумма по всем там g от нуля до и минус один дп допустим житая с и минус житая
ну пока и динамика выглядит как та которая встречается часто да по факту не очень но
соответственно и вот сказать такая ситуация хочется эту динамику посчитать то есть если
хотите хочется изобрести пятую оптимизацию динамическом программировании ну какие
оптимизации в дп мы знаем вообще ну не мы с вами вообще вот то что да есть конечно
до флагман конечно конверс халтрик действительно также есть оптимизация кнута есть разделяй
властва есть оптимизация лямбда да ну мы с вами по вот так мы с вами пока по моему не знаем
ничего из этого нет вышка ну тая разделяй властва вроде как и обсуждали до до не обсуждали вот
нет вот про кодекс халтрик понятно как бы для этого нужно в геометрию пойти ну да вот нанесу вот
но давайте сразу изобретем пятую оптимизацию вот там крыша еще одной но это не то вот то есть
пятую оптимизацию оптимизацию будем звать ее оптимизация фурье вот дай ну не по имени
французского математика который вел 18 веке конечно вот итак вот спрашивается как бы это
посчитать быстрее чем за квадрат ну для этого как всегда кто-то для кто-то для решения задачи
запретает комплексные числа а мы изобретем формальные степенные ряды да мне что-то страшно
употребляется в сочетании производящие функции вот а вот формальные степенные ряды все понятно
все это картинка все никто ничего не обязан ничего никуда не сходится и вообще кайф значит
давайте так и изобретем давайте вот скажем что дп рц по дп рц мы изобретем прям формальный
степенный ряд например да ой например вот так и скажем что r от x это у нас будет ну допустим
r 0 плюс r 1 на x плюс r 2 x квадрат плюс r 3 x кубе плюс и так далее а ну плюс и так далее дать
бесконечный ряд аналогичным образом мы вводим цет икс ну понятно даться 0 плюс ц1 икс плюс
ц2 икс квадрат плюс ц3 икс кубе плюс и так далее и конечно его величество дп от икс шать такое ну
так и пишем дп 0 плюс дп 1 x плюс дп 2 на x квадрат плюс там дп 3 на x кубе да на всякий случай скажем
что вот дп там допустим вот это вот дп второе и дп вот квадрат из кубчика второе это у меня
сейчас одно и то же вот значит вот изобретаем такую штуку чем она нам поможет теперь давайте
просто запишем это равенство в терминах формальных степенных рядов чем не получится
ну на самом деле да да единственное кстати да только единственная оговорщика что чтобы это
было верно нам придется сказать что вот эта штука должна быть равна нулю конечно нет а не эта штука
а какая какая это хорошо давайте вот это нет смотрите как ну во первых для вот этого равенства
она ни на что не повлияет потому что обратить внимание ни одного ц0 не использованы а во вторых
смотрите то есть а во вторых давайте вот запишем вот это равенство допустим мы говорим что дп равно
r плюс с умножить на дп вот прям так и напишем да то есть вот так опять что-то не работает
нет ну не совсем так нет ну ну где нет да вот тут парадокс на самом деле можно можно запутаться
кажется что степень не сошлись она самом деле не сошлись но не сошла но кое-что здесь все-таки
не сошлось в таком виде нет нет ну вот хотя нет нет хотя не не пока все нормально нет все нет все
на самом деле нормально да то есть там да ц ц равно нет ц равно нулю нам не особо принципиально на
самом деле пока но то есть так вот это утверждение точно верно для любых ну просто сейчас у нас будут
нет на самом деле да совершенно вы правы при яр sucked another получится но нам и не нужно
делить надце да потому что на самом деле заметил что дп равно и делить на 1 минус ц то есть
зап naszych фактически нам чисто для по-техническим то есть чисто для технических нужд на самом деле
может понадобилось чтобы ц было равно нулю просто чисто чтобы можно было нормально поделить вот
Но правда есть еще одна причина, зачем нам нужен 0. Дело в том, что в этом произведении как бы у вас
по идее, когда вы тут пишете произведение dPiT равно вот этой вот тоже вот rIt плюс вот эта сумма,
но в этой сумме еще должно появиться тогда согласно определению произведения dPiT умножить на
c0. Поэтому если бы вы тут не написали 0, у нас там были бы проблемы. Вот, но что для нас приятно?
Приятность для нас заключается в том, что у нас есть нод, что теперь у нас dPi равно r поделить на
1 минус c. Ну и фактически, то есть если у вас задание нод, ну теперь тут два варианта, либо вам
нужна, допустим, для 10 в пятый раз вычислить 10 в пятый вот таких значений, и тогда мы уже
просто знаем, как делить на р членам на р член. Ну вот, то есть это для нас не проблема. Ну или
альтернативная версия могла бы быть этой задачей. А скажите нам, пожалуйста, а чему равно dPi,
от там какой-то n, где n равно 10 в девятый или 10 в восемнадцатый? Да, казалось бы, вот, казалось бы,
такую задачу мы еще не решали. Да, мы действительно не решали. Но очень хочется. А хочется и решать,
вот почему. Потому что давайте вспомним, что-то мы там говорили про линейные рекурренты,
а что такое линейные рекурренты? Это такая последовательность, помним, а0, а1, а2, а3, а4 и
какой-то там бла-бла-бла, что там каждое а и плюс, допустим, и плюс катое равно, как мы помним,
у нас там чему оно равно? Чему оно равно? Там c0 на it, плюс c1 на а и плюс 1, плюс c2 на а и плюс
2, плюс и так далее, плюс там c, какой-то там, к-1, а и плюс к-1. Вот что-нибудь такое. А ведь смотрите,
что можно было бы сделать. То есть как еще можно было бы подойти? Потому что на самом деле возникает
такое следующее ощущение. А это что же на самом деле хочется записать в виде формальных степенных
рядов, правда? Ну вот, например, так и ввести, то есть допустим, а от x равно, ну как всегда,
а1x плюс а2x квадрат, плюс а3x кубе, плюс и так далее. Вот, и тогда мы неожиданно замечаем,
то есть мы неожиданно замечаем, что вот это утверждение можно записать кое в каком виде.
В каком? Ну заметим, что можно ввести какой-нибудь правильный многочлен. Давайте я даже такой,
такой c штрих, я его назвал, нет, c штрих не надо, это производное. Вот, c с волной. Догадываетесь,
почему с волной? Да, потому что очевидно, чтобы он имел отношение к а, его придется
поразворачивать. Так, спрашивается, что же я должен здесь сделать? Ну, давайте,
давайте-ка я так и сделаю. Я так и скажу, пусть у меня это будет c0 х витой, пардон, вкатой,
плюс ц1 х в к-1, плюс и так далее, плюс ц к-1 на х. Да, я намеренно в ц тильды не пишу свободный
член. Вот, и тогда кажется, и тогда у меня полное ощущение, что я могу написать что-то вроде а равно
а умножить на ц. А вот не совсем, не совсем прям тупо первая к-членов, но вот, потому что да,
то есть действительно, заметим, что, то есть действительно, допустим, каждый какой-нибудь
член с g с индексом g больше либо равно к, вроде как будет здесь посчитан правильно, согласны? Но
есть маленькая проблема, что есть еще члены а0, а1, а2 и так далее, которые тоже будут пересчитаны,
и там будет посчитано что-то нетривиальное. Поэтому нам придется кое-что сделать. Вот,
но с другой стороны посчитать это достаточно легко, можешь в явном виде запустить fft и посчитать,
к чему будет равно а умножить на ц с крышечкой, правда? Что? Мы знаем, на этом, на уровне первых,
как коэффициентов мы знаем, потому что они это инициализируют рекурренту. Вот, но получится у
нас в итоге какой-то шаманский многочлен p. Вот, то есть вот такая вот красота. И вот что-то знакомое,
да? То есть опять получается, действительно, что, то есть действительно можно сказать,
что a равно p делить на 1 минус c. То есть красота. Но видим, что в обеих этих задачах, то есть суть
сводится к следующему, да. То есть, по крайней мере, здесь мы вообще понимаем, что дано вот
такое частное, то есть дан степенной ряд, заданный вот таким отношением, найдите, пожалуйста,
у него коэффициент номер 1018. То есть вот такая задача. Что там, что там. Да, да, да, да, что очень,
очень приятно. Да, два многочлена конечны. Более того, даже мы себе тогда же и скажем отдельно,
что по факту у нас задача. Надо найти, то есть вот у нас есть два многочлена p и q, допустим,
конечная. И надо найти какой-нибудь n коэффициент, где n, какой-нибудь достаточно
большое. Это вот так называется. Вот это так вот обозначается. И нам вот очень хочется найти
конкретный n коэффициент. Вот. Ну, мы с вами в прошлый раз обсуждали, Дашу, можно там, то есть да,
можно там пытаться это ввести с помощью теоремы Гамильтона Крэйли и вообще Чутацкой выводить.
Ну вот, ну правда, там потом вывести потом, что ответ это надо взять многочлен x в n и там взять
от него отделение, взять остаток этого деления на там какой-то вот, вот едва ли не вот такой вот
многочлен. Ну ладно, почти такой там, во-первых, плюс один, во-вторых, там, ну не суй. Вот. Но это,
к сожалению, маленькая, то есть это там даст нам асимптотику какую-то там каллоген, но,
к сожалению, оно потребует от нас умения делить еще многочлены в процессе. Но на самом деле есть
более крутой лайфхак. Смотрите какой. Вместо того, чтобы делить, смотрите, мы подомножаем
и домножим мы это на что-то такое типа сопряженного. Вот и числитель и знаменатель мы домножим на q-x.
Да, придется потратить лишние две ффт. Вот. Но спрашивает, а чем приятен q-x? Да, действительно,
возникает маленькое приятное свойство. То есть если внимательно посмотреть на это, то легко понять,
что здесь коэффициенты при нечетных степенях нулевые. То есть в принципе я могу заявить,
то есть это равно какой-то многочлен допустим, ну здесь такого условия нет, то есть это будет
какой-то многочлен r поделить на какой-то многочлен t. Причем t от x квадрат. Вот, понятно, да?
Ну тогда идея такая, если вы делите на многочлен все степени которого четные, то на самом деле
заметим, что и этот многочлен можно разбить на два. То есть применяем прям вот фурьешный разделяй
властой классический. То есть давайте скажем, что это r0 от x квадрат плюс x на r1 от x квадрат.
Вот такая красота. Теперь заметим, что оказывается, если я теперь могу разнести эти
деления, потому что если я поделю r0 на t, то я получу опять же многочлен, в котором все степени
четные. А если я поделю xr1 от x квадрат вот это на это, то я получу многочлен, в котором все степени
наоборот нечетные. То есть вывод очень простой. То есть получается, что это равно, я даже тут
честно напишу, то есть это равно x в степени n пополам от r0 от x делить на, вот тут я пожалуй даже
t в виду. Чем мы и занимаемся на самом деле. Да, именно это мы и делаем. Вот, то есть это,
то есть, а именно, то есть если n делится на два, то мы оставляем только r0, а если не делится,
то здесь получается t в степени n-1 пополам r1 от t делить на t от t. Причем смотрите, какая еще
приятность. Приятность заключается в том, что размеры многочлена вот тут q и тут вот эти r0 и t,
они не увеличиваются. Потому что обратите внимание, если тут допустим размер k и тут
размер k, тогда здесь размер 2k и тут 2k, а потом мы из этого наращения взяли только половинку.
То есть обратите внимание, то есть мы от n к n пополам перешли, получается, за уже не деление,
как было раньше. То есть что там нет, у нас когда при быстром возведении в степени у нас что было?
У нас было одно умножение и одно взятие по модулю, а взятие по модулю у нас там внутри
себя требовало, по-моему, две или три fft, не считая рекурсии. Здесь же никакой рекурсии нет. Здесь
вы сделали ровно две fft. Причем в качестве добивки, в качестве добивки можно заметить,
что вот эта fft она на самом деле пишется еще достаточно оптимизированно, потому что отдельную fft
для q от x и q от –x писать не надо. По факту да. Вам достаточно сделать fft только для p и q и все.
А потому что что такое fft? Fft – это значение в точках. Причем точки у нас это такие точки,
что для каждой точки wn в степени g, верно, что минус wn в степени g у нас тоже в списке есть.
Вот поэтому получается, что отдельные fft для q-x читать не надо. Ну типа да, да, по кругу сдвинуть,
по сути, да. А как бы перевернуть круг и повернуть 180 градусов и вот так вот перевернуть,
это примерно одно и то же. Ну то есть да, по сути, да, надо там кучу n пополам пар,
как они просто поменять местами, это да, но это одно и то же. Так что вот.
А почему? Ну потому что заметим, что в оба этих вращениях здесь представляется x2. Когда вы
будете делить r0 на t, вот например столбиком, вы будете получать только многочисленные с
коэффициентами при счетных степенях. А когда вы вот этот вот часть будете делить на эту,
вы получите только на нечетных степенях. Поэтому, скажем, чтобы узнать коэффициент
конкретно при n члене, вам достаточно делать только одно из этих делений. То есть вот такой
вот неожиданный лайфхак. Вот скажем так, опытные люди утверждают, что по константе
это может оказаться неплохо быстрее. Но причины в общем-то очевидны. И рекурсии нет вообще,
и в какой-то ффтшку вы сэкономили. Ну то есть вам придется, конечно, сделать там, понятно,
что две обратные ффтшки вам придется сделать, тут ничего не поделаешь. Но с другой стороны,
и прямых ффтшек вам придется сделать две, а не три. Так что вот такой вот приятный хак. Вот так
может быть даже сильно проще будет. Так, есть ли тут вопросы? Вот. Хорошо. Так, ну если тут
вопросов нету, то значит тогда переходим к, видимо, заключительной части разговора по
ффт, по крайней мере, с большой, там, глобальных разговоров по ффт. Это что это будет у нас?
Ну если я ничего не признал, то придется говорить про многомерное преобразование ффт.
И так. Значит, многомерное. Значит, о чем разговор? Ну, мало кто знает,
что на самом деле многочлены бывают не только от одной переменной. Слышали о таком? Да, слушайте.
Чего? Ну мы-то не было. Ну мы-то не было? Когда? А ты не на тот мотан ходишь, да? Ага. Или, о,
извините, я случайно на третий курс зашел. Ну мало ли. Ладно. Ну ладно, неважно. Значит,
смотрите. Значит, идея такая. У нас будет жел-бел-атекс-ыгр. То есть, ну, типичный
многочлен от двух переменных. Ну так и выглядит. Вот такая вот красота благодать.
Вот. Ну, то есть, типичный его вид. Допустим, 2ху, плюс там, я не знаю, 5х2у4-7ху3, плюс 8х7-5. Ну вот.
Ну или 57. Вот. Неважно. Вот. Ну это еще, конечно, мало коэффициентов, но обычно, конечно,
удобно вообразить себе многочлены, а в виде вот такой таблички n на m. Вот такой таблички n на m.
Вот. Ну и вытекает такой, что иногда с этими многочленами тоже хочется что-то шаманить.
А именно, вот, допустим, два таких многочлена размера n на m очень хочется перемножать между
собой. Ну, то есть, для начала хочется складывать и вычитать. Ну вот. Но складывать и вычитать,
ну, наверное, каких-то вопросов нету, правда? Это не проблема. Вот. Вот хочется такие многочлены
перемножить. Как же это сделать? Ну, FFT. Ну да-да-да-да. Знаете, да. Классическая
ситуация в сервисе. Это называется, да, называется, там дается какая-то задача. Вы решаете,
вы набираете по ней 36 баллов, а потом смотрите, что ваш сосед набрал 86.
А как ты набрал 86? Рекурсия. Нет, я реальную историю рассказываю. Абсолютно реальная история,
причем для справочки, допростите меня этот товарищ, фамилию которого я не запомнил,
но это реально low name. А я, извините за нескромность, был кандидатом межнара. Вот. Вот. Ну, просто и так.
Ну, только единственное, да, можно. Да, то есть именно это, видимо, именно это на вооружение
берут действительно аплодеты. Там уже не кандидаты в межнара, а просто уже реальные межнара. Там
золотые, которые просто пишут это, у которых лозунг тут простой. Двумерный FFT не нужен.
Действительно, казалось бы, все прекрасно сводится к одномерному FFT. Каким образом? Ну,
просто давайте введем какой-нибудь А с крышечкой. Вот. Ну, крышечка. Знаете,
польский режиссер такой есть, да? Ну, мы уже обсуждали, да. Вот. Какой-нибудь ватлов крышечка,
вот это вот, да. Вот. Значит, соответственно. И давайте скажем, что А от какого-нибудь Т так
и будет равно, то есть действительно сумма-сумма, А ЖКТ на Т в степени, ну, хотелось бы так,
конечно, в наглую сказать, ЖКМ. В принципе, многочлен так задать можно. Но вы уже догад... Нет,
М. Почему? А, нет, Н. Ладно, в таком формате, конечно, Н. Да, согласен. Вот, пожалуйста. Вот. Но,
как говорится, все это, конечно, кайф, пока вы не захотите А с крышечкой умножать на Б с крышечкой.
Почему? Потому что, к сожалению, когда тут степени сложатся, то вы уже, вот, то как бы их сумма
жишек может вполне себе оказаться больше либо равно N. Поэтому распарщить вот это вот число,
как сказать, что там вот это это остаток, а это это частное отделение, вы уже не сможете. Да.
Поэтому есть, конечно, такой читерский вариант, два нот. То есть, просто сделать два и не париться.
Нет, в принципе, это помогает. Да, в общем-то, надо признать, что чуть менее, чем везде,
где вам потребуется двумерный ФФТ, в общем-то, можно сделать вот это. Вот. Но, тем не менее,
тем не менее, можно попробовать сделать и кое-что другое. Как бы, по асимптотике, на самом деле,
лучше не станет, но по константе есть шанс. И по точности, кстати, тоже. Вот. Вот. Какой
альтернативный вариант есть? Ну, потому что вместо того, чтобы сводить эту штуку к одномерному ФФТ,
мы попробуем на самом деле применить ту же самую логику только в двумерном виде. А именно, мы
попробуем каждый многочлен от x и y задавать в виде n умножить на m значений в точках вида w
n в степени g, w m в степени k. То есть, g, как всегда, от 0 до n минус 1, k равно от 0 до m минус 1.
Вот такой вот красота, да? Пока видно, да? Так, что у нас еще? Вот. Ну и что-то еще. В, w m в степени g,
k, 8, да. Ну ладно, тут понятно. Вот. Ну теперь вот возникает вопрос. А как бы это сделать? Главное,
мало того, как это сделать, так еще и возникнет естественный вопрос, а можно ли будет потом
этот многочлен восстановить? Ну по сути, да. Только это надо очень аккуратно расписать.
Действительно, идея заключается в следующем, что у нас есть многочлен от x и y.
Вот. Мало кто знает, но на самом деле он равен вот чему. Вот. То есть, его можно представить
в таком красивом миде, где ожитое это многочлен от одной переменной. Видно, да? Вот. И тут возникает
такая идея. Ну вот. Теперь возникает такая идея, что мы можем сделать себе пол работы на пути к
этому великому счастью и попробовать. Действительно, вместо того, чтобы, ну, то есть, да, у нас есть
коэффициенты каждого этого многочлена. Что это за коэффициент? То есть, если у нас есть табличка
вот этого, да, n на m, то тогда получается, что коэффициенты каждого многочлена – это просто
ожитое строчка соответствующего многочлена. Да? Так можно в ней же попытаться запустить в
каждой строчке честно запустить FFT. Что получится? Получится набор многочленов A от X WM в степени.
Так, нет. А, ну да. Так, только что-то не то. Так, ну да. То есть, если мы найдем действительно
тут значение в точках, то есть, как бы тогда получится следующее, тогда давайте думать,
что это нам даст. Если в каждом ряду. То есть, подставив вместо игрока WM в степени K,
то получится вот такая штука. J равно 0 от n-1. Получится ожитое только от WM в степени K на X
в степени J. То есть, смотрите, какая приятность. То есть, дело в том, что после того, как мы
сделали FFT по строчкам. Давайте я тут так и напишу. FFT по строчкам. Получается, что мы в каждой
строчке в K столбце находится вот такое значение. Правда? Видно, да? То есть, получается, что у нас
образовалась M многочленов от переменной X. И причем коэффициенты этого многочлена находятся
тупо в K столбце в нужном порядке. Удобно, да? Но тогда получается, что для того, чтобы вместо
X тоже подставить вот теперь WM в степени X. То есть, надо просто сделать FFT по столбцам.
Прям так и пишем. WM в степени J, WM в степени K. Вот. Многие будут писать, чему оно равно. То есть,
видите, оказывается, чтобы сделать такое FFT, то есть, чтобы найти значение многочлена A в этих
вот N умножить на M точках. Надо просто сделать N FFT по строчкам, а потом M FFT по столбцам. Ну,
естественно, если реализовывать это именно в таком виде, то рекомендуется, конечно,
перед второй фазой табличку транспонировать. Почему? Ну, потому что, напоминаю, у нас FFT
отпадно работает именно когда у вас элементы идут в массиве подряд. Вполне, да? Более того,
вот мне подозревает, что это может по константе работать лучше, даже может быть, чем единое FFT.
А, кстати, давайте посмотрим, за костью точку это будет работать.
Чего? Значит, давайте, да, M log, шо? Ну да, как это говоря, шо это за самолет, як, шо? Так, значит,
смотрите, первый раз мы делаем N раз по M log M, а второй раз мы делаем M раз по N log N. Да. Ну,
заметим, что это просто буквально равно NM log NM. Все, быстро на где-то придется умно. Ну,
с другой стороны, заметим, что, причем более того, то есть, в принципе, кажется, это может даже
чуть-чуть выигрывать, потому что, в принципе, когда вы делали один многощин, был размер NM,
и единое FFT будет ровно за стоком. Вот. Ну, тут, конечно, не знаю, слабая надежда, что это будет
работать быстрее есть, хотя, конечно, она сомнительная. Вот. Ну, тем более, что умножать,
умножать на два, и там, и там придется, если что. То есть, как бы, слабая надежда у меня теплится
только насчет того, что вот это вот целиком в кэш попадет с большей вероятностью, чем МН. Вот.
Впрочем, вот. Поэтому, как бы, может, может, за счет этого будет какая-то там, вот, там,
лучшая победа. Ух ты. А вот это мысль. Не, ну да, мысль, да. Причем там какой-то модуль,
популярный типа 7 миллионов, на самом деле есть. Тоже такой, периодически, то есть, редко,
но встречается. Это тоже фурежный модуль там какой-то. Вот. Да, спасибо, спасибо. Да,
действительно. Хотя, на поверх он не такой уж и маленький. Он, по-моему, там не два линии,
три на два, а там в какой-то двадцатый или что-то в этом роде. Поэтому. Или семь на два в двадцатый,
или что-то в этом роде. Да, ну, в принципе, да, да, действительно. Давайте, да. Ага, скинем.
Осталось только еще новую задачу придумать, да. А то, знаете, да. Ну, может. Ну, бывает,
бывает. Нет, ну, дать можно все, что угодно. Вопрос просто, да. Главное, чтобы какую-нибудь
олимпиаду это взяли. А то, знаете, там. А то, что-нибудь там, привередывая там координаторы на
Код Форси, с вами что-нибудь скажешь, или что-нибудь такое задайте. Помните, там был какой-то пост у
какого-то автора задачи, говорит, что вот у меня там редактором был Антон Трегуб, и вот лишь не
полный перечень причин, по которому он отвергал мои задачи. Дальше список, по-моему, из двадцати
вариантов. То есть, там это неинтересно, это легкая задача. Эта задача была в Петрозаводске такого-то
в более усложненном виде. Там, ну, это все и так далее. То есть, это вот издевательство вообще. Да. Ну,
то есть, ну, что делать? Ну, что делать? Ну, как бы, да. Чего? Только а то. Так вот, может, за счет этого
Код Форси, собственно, и держит планку, на самом деле, за счет вот именно таких координаторов. Такая,
они не просто не отвечают, они сидят и, собственно, гуглят по всем задачам, которые в базе у них. То есть,
они же не отбалдыш вспоминают. А, ну, это я в 17-м году писал. Да, это интересно. А, все-таки сделал? А, классно.
Нет, прям вообще все задачи. Ну, понятно. Нет, ну, супер-круто. А там прям вообще все задачи, да? А не прям это по пункту.
Да, ну, понятно. Ну, весело-весело. Потому что было бы неплохо, на самом деле, даже с точки зрения учебной
брать все задачи, которые были, еще и желательно протегировать по темам. Потому что преимущество было бы,
просто, мне как преподу это интересно, на самом деле было бы. Чего? Нет, ну, не обязательно. Нет, там фишка в
другом. Там, как бы, можно просто из таких задач можно нормальные учебные делать. Четкая тема. Ладно. Так,
ладно, на то он и умник, как бы, да. Так, соответственно, да. Так вот, значит, ну, что тут хочется обратить? Да, у нас тут есть
пока такой вот двумерный ФФТ. Но что в этом двумерном ФФТ приятно? Приятно тем, что, на самом деле, оно прекрасно
обобщается. То есть, как видите, то есть, на самом деле, можно абсолютно так же сделать и трехмерное ФФТ,
и четырехмерное, и пятимерное, и вообще сколько угодно мерное. Вот, ну, как бы, да. Действительно, как часто на нашем
жизненном пути нам хочется сделать пятибергное преобразование фурии. Вот, а если вам входно, вот, ну,
пятибергное, да. Чего? Ну, как-то, да, вот, получается. Нет, ну, с одной стороны, да, но с другой стороны, в этом
месте вы на самом деле здесь тоже, если вы хотите именно умножать, то вы никуда не денетесь. Почему? Потому что дело в том, что
перед умножением наручен, вам придется и по n, и по m тоже на два домножить. Поэтому домножение на два в степени вы не избежите.
Но, тем не менее, н-мерное преобразование фурии вам очень может захотеться сделать.
Ой, ну, д-мерное, господи. Вот, а причины есть. Вот сейчас я сформулирую задачу, в которой прямо руки будут
чесаться, сделать д-мерное преобразование фурии. Если бы так топорно. Все еще круче. Нет, причем начало вообще не будет предвещать.
Значит, смотрите, казалось бы, мы сейчас будем говорить о подмасочках. Ой, конечно, ой, мы с вами еще ЭДП на подмасочках не обсудили.
Ну, значит, сегодня обсудим как раз. Нет, потому что будет как раз сегодня время, когда вот эти долги надо быстренько закрыть.
Вот, смотрите. Значит, какая у нас тут идея возникает. То есть у нас есть какой-нибудь великий универсум, и в нем у нас элементы от 1 до, ну ладно, так и быть, d-1.
Ну, d обычно не происходит чего-нибудь там, если 20-ти что ли, я не знаю. Может, что-нибудь еще в этом вроде. И у нас есть функции.
Значит, мы работаем с функциями на подмножество. То есть у нас будет функция от 2 в степени u на r.
Так, ну я думаю вам в законовом выражении 2 в степени u, да? Ну, то есть просто множество всех под множество u.
Вот. Так вот. Вот у меня есть такие функции.
Значит, что я хочу? Хочу сделать следующее.
Значит, я хочу делать свертку.
Свертка такая. Я хочу по двум таким функциям f и g посчитать функцию h.
Только вот какую. h откаковывает под множество s.
Оно должно быть равно сумме f от s-штрих умножить на g от s-два-штриха.
Где s-штрих, s-два-штриха. Это тоже нот. Где у нас понятно, что s-штрих, s-два-штриха это подмножество u.
И что самое важное теперь? s-штрих-ыть. s-два-штриха равно s.
Вот. Чему равно ыть?
Не, ну не совсем чему угодно.
Стоп, стоп, стоп, не настолько. Нет, разности я не умею.
А вот все остальное да.
То есть именно в качестве ыть мы рассмотрим объединение, пересечение и симметрическую разность.
Ну на уровне масочек, если бы это задавали масочками, то эти операции соответствовали бы в масочках or, end и xor.
Вот. Вот такой вот красивый свертка мы хотим делать.
Вот как же это сделать?
Вот. Ну естественно хочется сделать fft.
Ну очевидно же да.
Так, ладно, первое что хочется сделать это сказать, что задача end это неинтересная задача.
Почему она неинтересная? Да потому что она идентична or.
Ну 0 на единичке поменять там во всех масочках и все в общем-то.
А вот or и xor друг другу так просто не сведутся, их придется немножко по-разному делать.
Но казалось бы, как же можно это делать?
Делать можно следующим образом.
Ну да. Казалось бы да.
Ну какая у нас напрашивается идея?
Идея напрашивается следующая.
А давайте k заведем многочлен от d переменных.
То есть давайте какой-нибудь составим такой многочлен.
По f вы составим какую-нибудь, ну я не знаю, функцию.
Какую?
Ну давай кем-то.
Так, что?
Не, f с крыши, f с волной.
Не, просто f большое я потом захочу использовать, потому что у меня ширина там.
То есть допустим у меня тут от d переменных.
И оно будет равно у меня чему?
Ну она будет равно, то есть сумме по всем, допустим, масочкам.
То есть вот этим вот 0,1 в степени d.
Вот. Я тут напишу что-то типа f от m на x в степени x1 в степени 0, x2 в степени m2 и так далее xd в степени md.
Ну то есть маномчики я забабахаю так.
Ну то есть маномчики я забабахаю так, что если у меня там какая-нибудь житая переменная есть, то значит я ее тут в маном вставляю, если нет, то нет.
Вот, понятно, да?
Ну и абсолютно аналогичным способом я могу получить и многочлен g.
Ну пока мне в общем-то не составляет труда вроде как такой многочлен построить.
Вот.
Так.
Ну а теперь возникает вопрос. Как же нам теперь получить h?
Есть один наглый способ.
Да, способ называется да перемножить многочлены.
Вот прям давайте так и введем.
Вот.
Он будет равен f стильдой умножить на g стильдой.
Вот.
Чем он нам поможет?
А поможет он нам следующим.
Что дело в том, что когда вы перемножаете маномы, у вас степень при каждом x становится 0, 1 или 2, правда?
Причем 0, 1 или 2 однозначно что в ксоре задает тот факт, чему равен был бы ксор соответствующих битиков, правда?
Ну потому что если там степень 0, значит оба битика были 0, 0.
Если 1, значит битики были 0, 1. Если 2, то 1 и 1.
То есть по этой информации or xor вы уже восстанавливаете однозначно.
То есть поэтому возникает такая естественная идея.
Вы делаете перемножение, потом прибираетесь по маномчикам.
Эти маномчики приводите к какому-то адекватному виду.
То есть условно говоря, там 2 заменяете на 1, там все 2 заменяете на единицы, но если мы допустим or делаем, да?
Ну вот, ну и собственно потом нот.
Ну собственно в общем-то и все.
В общем-то задача решена.
То есть вот такая идея могла бы быть.
Ну теперь, вы видите, какая-то просто азококую осемптотику это работает.
Вот, нет, проблема. Четыре. Если делать тупую, как у нас принято, то четыре.
Почему четыре? Потому что у нас принято каждое одномерное ффт удваивать.
По каждому направлению.
По каждому направлению.
И тогда как бы было у нас n направлений по 2 элемента, стало n направлений по 4 элемента.
Да, то есть, конечно, ффт все еще делается за вот единицы.
Но зато самих этих ффт у нас становится 4 в степени n.
Вот. И тут, видите, какая-то вопрос. А как бы оптимизировать этот алгоритм?
Ну да.
Ну нет, ну это не очень понятно, как одновременно много многочленов делать.
Ну совсем не увеличивать не получится.
Ну ксор...
Нет, ну смотря как, тут надо аккуратно.
Потому что пока если мы чисто перемножаем многочлены, то так, конечно...
Ну просто когда вы ищете честное произведение, то как бы совсем не увеличивать не получится.
Потому что у вас даже мономов будет больше, чем 2 в степени n.
Но правда тут же и шанс для оптимизации.
Потому что мономов у нас на самом деле всего 3 в степени n, на самом деле.
Потому что степень каждого х больше двух не будет, правда?
А теперь можно заметить следующее, что умеем ли мы делать FFT для многочлены размера именно 3?
Ровно 3?
Да.
Да.
Вот это вайбы нот.
Ну учитывая, что такое FFT?
Это когда мы многочлен задаем в виде его значения в n точках.
Если размер многочлены 3, то в общем-то ничто нам не мешает просто взять многочлен, взять эту параболу, а это парабола, да?
И просто задать ее просто тремя точками.
Причем любыми абсолютно, да?
То есть как бы ну константа, то есть там в зависимости от того, какие конкретно 3 точки выберете константа, может пошаманиться там.
Но это все равно будет константа.
Это даже не обязательно комплексный корки кстати брать.
В общем-то достаточно взять просто даже какие-нибудь там числа даже 0.1.2 подойдут.
Ну или там, ну или там, что вы там любите, больше там 57, 179.2, я не знаю, вот это все.
Вот, ну или 239 там естественно, да.
Вот.
Ну это так конечно не лучший вариант.
Ну минус 1.01 конечно лучше будет, наверное.
Вот.
Ну так просто чтобы чуть-чуть там.
Ну не важно.
То есть таким образом получается, то есть заметим, что расширять тогда в этой диспозиции нужно только на массивы, только на размер 3.
И это будет кайф.
То есть будет 3 в степени N и в общем-то будет хорошо.
То есть в принципе да, то есть получается, что эту задачу мы уже за 3 в степени N решать научились.
Очень просто.
Мы каждый размер каждого одиночного наращения сделали 3.
Вот, ну там заявили квадрат и все.
И стали каждое FFT делать на размер ровно 3.
То есть воспринимать как многочлен размера 3 и заменять его назначение в трех точках, именно ровно трех.
Вот, мы воспользовались тем, что мы за вот единицу умеем делать.
Да, кстати, вот что технология сведения к одномерному FFT делать не умеет, кстати.
Вот.
Так что можно сделать так.
Вот.
А что еще можно сделать?
Вот.
А еще можно, ну вот, ну конечно же, так как у нас D это 20, то наверно хотелось бы побыстрее.
Вот.
Но тут на самом деле можно попытаться обнаглеть еще.
Каким образом?
А вот каким.
Потому что как бы нам хотелось бы свести, конечно, свести FFT к многочленам все-таки от размера все-таки 2 в степени, а не 3 в степени.
Если сведение к одномерному будет работать.
Нет, ну скажем так, ну конечно можно, только для перемножения это не будет уже.
Ну вот совсем для перемножения, скажем так, для перемножения это может не сработать,
потому что там, хотя в принципе да, можно.
А, ну да, только придется делать это не 4, только придется это делать все-таки как там переводить либо в 4 в степени, либо в 3 в степени.
Чего?
Пока не будет хватит, но пока вы не будете делать произведение.
Вот.
Вот.
Вот, поэтому просто так не получится.
Поэтому придется тут, конечно, кое-что пооптимизировать.
Но каким образом?
Вот, но мысль на самом деле такая.
То есть, но на самом деле, то есть, идея будет такая, может быть, то есть немножко с читами.
То есть, хочется, конечно, действительно сводить задачу именно к произведению.
Но для этой ноты, нет, и в принципе действительно можно было бы это сделать, если мы будем подгонять.
То есть, как мы уже сказали, то есть, досели мы, вот, так говорите, стандартная ФФТ, то есть ФФТ у нас выигрывалась,
из-за того, что мы только в последний момент вспоминали, а в каких конкретных точках вычисляем многочлены, да?
А теперь у нас есть какая-то идея.
Давайте-ка их вычислять в каких-нибудь хороших точках.
А что такое для нас сейчас хорошие точки?
Ну, ФФТ само по себе мы можем для многочленов константового размера вычислить в любом месте,
поэтому хорошесть можно выбирать уже по-другому.
А в нашем случае можно, например, давайте рассмотрим ОР.
И можно найти такие х, что х квадрат равно х.
То есть, я хочу вместо вот этих х подставлять какие-то чиселки, искать в них значения.
В этом смысл ФФТ.
Так вот, я хочу подставлять такие х, чтобы х квадрат был равен х.
Зачем я это делаю?
Ну, мы помним, да, что после произведения мы там все квадраты обрубим в х, правда?
Ну, тогда, значит, что это за х?
Ну, очевидно, это эквивалентно тому, чтобы х просто был ноликом или единичкой.
Так вот, у меня такая неожиданная идея.
А сделаю-ка я...
Значит, смотрите, сейчас я аккуратненько сформулирую.
То есть, по каждому f-стильдой и g-стильдой я могу получить...
То есть, там что-то типа f-стильдой и g-стильдой.
То есть, что это такое?
Это будут значения многочленов f и g в точках 0 и 1.
Вот, могу я такое сделать?
Да, так вот, у меня идея такая.
Я не могу получить произведение этих многочленов.
Но я могу получить по ним значение многочлена h в тех же самых точках 0 и 1 в степени n.
То есть, смотрите, фишка такая.
Дело в том, что вот этой функции h...
Обратите внимание.
Тут надо очень аккуратно.
Этой функции h, по идее, будет соответствовать какой-то многочлен h-стильдой.
Но этой h-стильдой, на самом деле, оказывается, значение его в точках 0 и 1 должно совпадать с произведением этих значений у f-стильдой и g-стильдой.
Логично, правда?
Вроде логично.
Или не логично?
Логично, логично.
Все логично, все логично.
Поэтому получается, тонкость такая, что, формально говоря, то, что мы сейчас найдем h-стильдой, то есть h-стильдой это не произведение многочленов f-стильдой на h-стильдой,
если мы их тут будем делать именно на 2 в степени n.
Но конкретно в точках 0 и 1 подойдет?
Чего?
Или сомнения какие-то?
Мыша, мысль по дефолту может быть сейчас не тривиальная.
Т.е. сейчас так вот.
Но, чему это нас приводит?
Приводит это нас к тому, что работает у нас теперь не за 3 в степени, а за 2 в степени.
Да, кстати, только везде все эти степени на n надо домножать, понимаете, да?
Но там, помните, потому что там же вам придется каждую переменную, у нас там получается, что у нас получается,
то есть нам надо пробежаться по всем d-1 рядам и при каждом ряду сделать fft, при каждом фиксированном.
То есть получается, под этой переменной мы должны сделать 2 в степени d-1 fft.
Да, 2 в степени d-1.
И причем все это мы должны сделать d раз.
Логично, да?
Так вроде логично.
Нет или нет?
Нет.
Ну, смотрите, вот еще раз, давайте на двумерном случае.
Мы делаем n раз fft по m.
И тут m раз.
То есть получается, fft, если тут n, было бы 2n fft.
То есть соответственно, то же самое на трех переменах было бы тоже.
Так что да, поэтому фишка тут получается, что в таком виде это будет работать,
то есть уже на уровне идеи за 2 в степени n на n.
Ну, раньше в предыдущем точке были тоже 3 в степени n на n, на самом деле.
И 4 в степени n на n.
Вот, да.
Ну, 4 в степени n может быть, если бы мы перемножали в тупую,
было бы, наверное, там 4 в степени n было бы.
Вот.
Но тут, причем более того, но это для ORA.
Там было бы не 4 в степени n, там тоже было бы не 4 в степени n,
потому что надо было бы еще проверить, что масочки сходятся.
То есть мы перебираем пары и проверим, что маски сходятся.
В смысле, в смысле, какие пары?
Ну, вот мы перерываем 4 х 2 штриха и проверяем, что из-за n нужно еще...
Не, а зачем?
Если вы в тупую перемножаете, то как бы вы просто...
Нет, а зачем?
Когда вы перемножали именно многочлены, вы об этом не заботитесь.
То есть вы как бы об этом вспоминаете просто, когда мономы обрезаете.
Вот.
А?
В рычаге с норами есть значение по уровню степени D, аж с 3-4.
А также как и ранее?
Что-то такое.
То есть просто фишка такая.
У вас есть как бы менячленные, f в стильдах, j в стильдах и аж в стильдах.
И у нас есть мистическое утверждение.
То есть у нас нет мистического утверждения, что f в стильдах умножить на j в стильдах равно a ж в стильдах.
Но есть утверждение такое, что f в стильдах в точках от 0.1 в степени n,
умножить, вот то есть умножить на g в тех же точках.
тех же точках равно h, ладно, не очень, может быть, пишу
это, но суть такая, то есть конкретно в этих точках
это точно правда.
Вот, то есть получилась вот такая вот неожиданная
тонкость.
То есть, да, действительно, вот в точках 0,1 это будет
прям чистая правда.
Вот, потому что мы специально, видите, мы специально 0,1
взяли, то есть для того, чтобы х квадрат совпадал
с х, то есть, видите, квадраты обрезаются так, как нам
по ОРу надо.
Вот, да, кстати, сразу опишем, а что делать для ксора?
Да, то есть для ксора нам потребуются такие х, чтобы
х квадрат был равен 1, то есть в переводе говоря,
и там х это 1 и минус 1.
Вот, ну потому что в ксоре х квадрат должен превратиться
в х нулевой.
Вот.
Так что вот такая красота, оказывается, нас ждет,
но еще большая красота на самом деле нас ждет, когда
мы захотим это закудить.
Да, потому что когда, действительно, как закудить
Ну, иногда, да, но в нашем случае будет по-другому,
смотрите.
Итак, значит, как это закудить?
Ну, во-первых, как это хранить?
Ну, естественно, мы не будем заводить демерный вектор.
Да, казалось, что нам мешает, но кроме того, что это демерный
вектор надо реализовать, там еще, да, да, причем
как бы количество, можно вообще реализовать демерный
вектор, это вообще с переменным количеством измерений.
Ой-ой, шаблонный тензор звучит, как угарательство,
да.
Да, да, да, да, да, в нумпале есть, шаблон для бэрикевла.
Нет, при желании можно, может, даже, может, даже
мещерину подкинуть идею на ДЗ, да.
Ну, а чего, да?
Что сразу ало мещерино?
Здравствуйте, Илья Семирович.
Нет, я бы сказал просто, слушай, привет, у меня тут
идея, слушай, у тебя тут демерными векторами там
не получится.
Не, но мало ли, может, там с какими-нибудь марксами
что-нибудь еще в этом роде может это они не общел шаблонный вектор шаблонным
параметром в д
ну хорошо хорошо ну ладно ладно можно не но слава богу не нужно потому что
потому что на самом деле заметим следующего вместо того что пошла как вы
будете хранить эти эвки но очевидно что верно вы будете хранить массиве размеры
2 степени правда ну наверное да ну вот то есть вы как-то будете то есть вы их
будете как-то хранить и будет вам хорошо вот теперь выскакивает вопрос а как
сделать двумерные ффт то есть ну допустим вот у вас есть массив даже да
f от 0 там f от 1 х х и вот если я хочу это к этому f применить н-мерное
преобразование фурье то как я это должен делать я должен наверное то есть как я
это должен делать ну наверное якобы помните да должен там зафиксировать все
там зафиксировать то есть то есть делать это должен так то есть я должен
перебрать все значения переменной d от 0 до n минус 1 нет ладно и так давайте я
перебираю житую переменную от 0 до d минус 1 вот так да а что теперь должен
сделать а теперь дальше должен всеми возможными способами зафиксировать все
остальные значения да переменной кроме житой и их но вот и соответственно там
ффт и сделать правда то есть я тут должен перебрать то есть я должен был
тут написать там for m 0 равно от 0 до 1 for там m 1 равно от 0 до 1 там for m 2 равно
от 0 до 1 и так далее g минус 1 равно от 0 1 да но вот и так далее да вот то есть
можно было бы вот так написать да так в общем делаем вот таких 19 for и внутри
должен сделать следующее я должен взять фактически все масочки у которых значит
вот эти битики равны вот этому ладно да и минус один вот эти вот они тут равны да и
сказать что хорошо у нас теперь ставят но таких маски у нас целых две ну где он
житый бит равен нулю житый бит равен единице и для них сделать вот эту ффт да но по сути
вот так перебирать не надо конечно почему да я понимаю что уже хочется конечно да но тем
не менее вместо этого оказывается что достаточно перебрать просто все пары
масочек у кого-то которые отличаются ровно житым битом то есть вместо вот этого вот безобразие
надо просто написать for m равно от 0 до 1 х n минус 1 и тут мы будем перебрать так если житый бит жив
допустим да то тогда нам надо поработать с масочкой m и m минус 1 х 5 g а как нам с ними надо
работать так как же нам сделать fft на 0 и 1 давайте давайте внимательно подумать то есть у нас
имеет вид а плюс б на x да там а плюс б на и джитая даже можно сказать где а равно получается
м цифру там f от м минус один хресь хресь жи да и б равно f от м ну когда мы зафиксировали все
остальные переменные да у нас образовался многочлен размера 2 вот такого вида да от житой
переменной вот у него есть вот свободный член он находится здесь есть степень первая которая
находится здесь я хочу сделать для нее заменить ее на значение этого многочленов двух точках в
чем точке 0 и 1 но что же это за значение в точках 0 и 1 что по сути да то есть это вот у нас а и
а плюс б то есть в результате это магическое ft делается примерно следующим образом то есть
f от м плюс равно f от м минус один хресь хресь жи так что да нет просто оказывается что да то
есть как бы как бы как бы идеи но было очень страшно но реально вот да вот да мы написали
мерное прообразование фуриеда да правда страшно что это все а как же написать обратно как же
а ведь действительно смотрите как же как же восстановить обратно как же по числам а и а плюс
б восстановить числа а и б да то есть для этого придется сделать следующее ну формально во-первых
да то есть ну для этого самое тупое давайте просто сделаем то же самое но прям наоборот
нет хотя нет какая какая нам разница обратная то есть там но обратная фф т ну мы уже убеждаемся
что когда мы делаем обратные фф т нам по барабану в каком порядке перебирать значение правда
да по сути да поэтому на самом деле заметим что вот то есть каком порядке дот то есть в каком
порядке перебирать это нам не принципиально в каком порядке перебирать масочки нам
тоже не сильно принципиально но потому что все равно вы штаба Emily перебирайте по сути пара
так что получается что обратная фф то отличается только тем что вместо плюсика
вы пишите здесь пинусик одним символом буквально всё в каком смысле разберёмся
нет ну
так нету пройдите пройдите правильная мысль но тут действительно да
возможно да у кого-то вызывает ощущение что где-то этот код вы уже видели да да
предплазикает какой-то такой какой-то абсолютно паникующий аббревиатура как
создать п да да действительно да хотя действительно это очень страшно да
просто страшнее только фраза там типа штирлиц идет по коридору то есть просто
что она значит абсолютно непонятно но что-то она должна значить тот штирлиц
идет по коридору или там из-за пастор играет на аркане вот то же самое пастор
играет на аркане паспорта и пастор ты гады у господи да все все все вот ну выбросуем
сюда вот но на самом деле но на самом деле можно подумать еще вот о чем сделаем еще
один шаг вот мы говорим об оре да а теперь давайте подумаем а шум вот хорошо мы вот
это операция она превратила f массив вот который действительно хочется назвать м большое ф
большое но я говорю все я сегодня все да вот господи до самого начала на самом деле вот f
большое значит что же это такое f большое как мы помним да что такое f вот давайте подумаем что
такое f от м большого ладно ладно f большое а м маленькая что это такое то есть идея была
такая мы подставляем нолики единички вот то есть жили был вот этот вот многочлен f и
мы в него подставляем нолики единички правда ну теперь смотрите как ведут себя нолики
единички когда вы подставляете себе вот как ведутся эти новенькие единички маски m с
каждым конкретным мономом. Заметим, что если у вас есть какая-то переменная с нулем, которая в
этом мономе есть со степенью 1, то тогда этот моном зануляется. Но, а если в этой перемене
единичка, то она на этот моном никак не влияет. То есть получается, то есть если у нас тут есть
нолики и единички, то зануляются только те мономы, в которых есть переменные, которые тут
занулины. То есть не занулины, другими словами, будут такие мономы, что если тут х в мономе есть,
то тут у него единичка. То есть в переводе говоря, то есть просто пишем утверждение
мистическое, что оказывается, что f от m это сумма f от m штрих по всем подмазкам маски m.
Поэтому это и называется СОСДП. Не очевидна связь, да? На самом деле уже легко распорчить,
потому что СОС это на самом деле сам оверсапсет. Нет, это просто предлог. Нет, пока тут как раз
наоборот ничего страшного. Да, то есть конечно да, в каком-нибудь спортивном программировании обычно вам
это СОСДП расскажут, как бы никак не связывая это, что это на самом деле это просто инмерное
образование фурье такое. То есть вам просто скажут, что давайте решать вот такую задачу. Заметим,
что оно решается вот такой динамикой, которую если пихать ее не за два в степени n памяти,
а за честную два в степени n, то получится вот этот код. Кстати, кто раньше сталкивался с СОСДП?
Ну вот, понятно. Более того, мы могли даже просто задачу дать, потому что, в принципе,
если вам просто поставить такую задачу, решить ее за два в степени n, то скорее всего вы решение,
может там решение вида, давайте там забабахом какую-нибудь динамику, собственно вида там будет
такое что-то ДП от МЖТ. Там что-нибудь типа перебираем все подмаски, у которых первые же
бит совпадают, например. Вот и выяснится, что в общем, там если правильно пересчитывать,
то получится хорошо. За три в степени D? Да, решение называется, честно переберем все подмаски,
мы сегодня об этом поговорим еще. Да, есть очень тупой перебор. Четыре это совсем тупой,
а есть чуть менее тупой способ, то есть просто есть способ, как у маски M перебирать ее под
маски за вот их количество. В общем, очень тупым перебором. А в прочем, почему бы здесь-то об этом
не поговорить? Давайте раз уж об этом зашла речь, сегодня нам это все равно пригодится.
Вот задача, вот просто абстрактная задача, дана маска перебирать все подмаски. Так вот,
я утверждаю, что я умею это делать. Ну ладно, не умею. Я умею перебирать все непустые подмаски.
Да, да, у меня к сожалению такой код, что сейчас будет, что нолик придется перебирать отдельно.
А все непустые перебираются так. Смотрите. Да, M штрих, это штрих. Он есть, да.
Значит, надо доказывать битву и магию.
Нет, скажем так, битва и магия работает, потому что она в процессор зашита. Если вы живете в каких-то
других процессорах, я не знаю, в какой галактике их изготовили. Нет, всякое, конечно,
бывает. Если верить голливудским фильмам, то да, что все компьютеры имеют один и тот же
графический интерфейс, независимо от того, кто их изготовил в какой галактике. То есть к любому
компьютеру можно там клавиатурку свою подключить и так далее. Нет, до нуля-то оно дойдет. Но
понимаете, просто проблема в том, что после нуля эта штука, скорее всего, будет равна M.
Нет, ну do while тоже, потому что M-то тоже хочется обрабатывать.
Смотрите, do, значит, вы обрабатываете маску, делаете вот эту, а потом пишете while M больше нуля,
да? Ну можно и так. Нет, ну можно и так. Нет, ну, понимаете, да, я просто не очень люблю,
потому что там какие-нибудь, потому что с каким-нибудь continue тогда будут проблемы. Просто чем вот этот
форприятие? Он приятен тем, что если вам захочется сделать continue, вы просто пишете и не паритесь. А в вашем
варианте вам придется помнить, что до последней строчки вам надо дойти и что-то сделать. Тут вот
такая подлянка есть. Да, замечательно. Но, как я уже говорил еще, как говорил еще мой преподаватель,
оператору Go2 нет. Да, помните, да, все плюс-плюси нет, оператору Go2. Да, это называется, кто сказал вам,
да, кто сказал вам обратно, можете пойти его побить в темном переулке. Собственно, если ваш
компилятор его компилирует, это случайность. Ну да, так, то есть, ладно, так, то есть, насколько я
понял из ваших комментариев, в общем-то, а почему это работает, в общем-то, вопросов не вызывает. Нет, все
очевидно. То есть, на экзамене я могу спросить, расскажете. Хорошо, да, в принципе, ладно, оставим в
качестве упражнения. Хорошо, да, убедиться, что действительно эта штука действительно переберет
все подмасски. Причем, естественно, порядка убывания очевидна, но да. Так, но главное, что она все
переберет. Нет, скажите, видите, здесь абсолютно очевидно, что она переберет в порядке убывания,
очередное, что она переберет подмасски, потому что мы Эндем делаем. Останется только доказать,
что она переберет все. Вот, это самое тут нетривиальное, но на самом деле тоже не сильно страшно будет.
Так, ну, на самом деле, что нам тут остается еще добить? Ну, на самом деле, да, то есть, как бы,
если не рассказывать действительно СОС ДП через просто ДП без фурье, то, конечно, не будет очевидно,
а как тут тогда вместо ОРА сделать СОР? Ну, на самом деле, это, оказывается, достаточно просто,
особенно если найти зеленый маркер. Да, таища у нас, к сожалению, нету. Ага, а он перманентный,
по-моему. Не, вот я вот под цвет учу, вот чую под цвет ушел. Ну, да, флип, да, флип чартовый, да, все,
он не сотрется тут. Ну, нет, ну, смотри. О, кайфец, работаем, да. Значит, действительно,
как сделать зелененький СОР? Очень просто. Ну, потому что тут мы заметим, что вот этот
A плюс B к G. Так, ну, если подставить единичку, то получится A плюс B. А если подставить минус
единичку, получится A минус B. Да, ничего не напоминает. Да, вот это вот. Ну, бабочка, да. Ну,
ладно, это все редактор, конечно, а не бабочка. Ну, да, но в принципе, да, то есть, на самом, да,
как это ни странно, но мы действительно честно, на этот раз делаем вообще предельно честно FFT.
Да, обратно, конечно, то есть там фишка будет такая, то есть там, то есть там придется вот
вместо этой штуки там писать что-то типа там, как всегда, у равно f от m минус, значит,
1 х х g, значит, v равно, значит, f от m. И дальше написать, что f от минус 1 х х g теперь равно
у плюсв, значит, f от m равно у минусв. Это если в одну сторону. Вот, теперь у меня есть какой-то
вопрос, а что делать, а что делать, если вы будете делать обратно FFT? Да, на самом деле, да, то есть,
то есть как бы в качестве обратно вам придется тут добавить строчку поделить пополам. Или,
ну, на самом деле, чтобы константу оптимизировать, правильнее, конечно, будет на самом деле потом,
то есть правильнее, конечно, будет на самом деле потом в конце пробежаться фориком и
поделить уже сразу на два в степени. Вот, надо так делить на два, как-то это вот такое. Вот.
Почему? Ну, нет. Кстати, да. Нет, нет, нет, стоп, стоп, стоп, не совсем так.
Если модуль четен, то это еще не следует, что 1 минус 1 это одно и то же. Да, но, к сожалению,
с восстановлением назад будут проблемы, так что пользуйтесь нечетными модулями.
Нет, ну, можно в принципе. Нет, ну, давайте как бы ждем задачу,
да, весь Код Форсус будет там сидеть, страдать, да. Ну да, да, да, сделаем,
миллиард 7, миллиард 9 КТО радость, да, да, да, мы помним. Нет, ну да, нет, ну ладно тут,
не суть, развлекаться можно на самом деле как угодно, потому что на самом деле, да,
то есть если уж говорить о том, куда можно развлекаться дальше, то там как бы на самом
деле и там более как совсем страшные задачи есть. Так, сколько времени? А, кайфец.
Так, ну что? Ладно, есть ли тут еще какие-то вопросы? Нету. Так, ну тогда пришло время
перерыва как раз. Ладно, идем дальше. Так, ну, соответственно, ладно, да, так, значит,
какую-то, так, ладно, какую бы из дырчик позакрывать? Так, ну ладно, давайте тогда,
значит, ну начнем с того, что закроем дырчику, тогда уж ДП на подмасках раз у нас что-то зашла об
этом речь. Вот так, ну действительно так, ну уж, да, что-то можно сказать про ДП на именно подмасках,
ну кроме того, что да, есть, да, ну да, что есть, там есть такое ДП, что в качестве состояния ДП
могут быть, оказывается, под множество какого-то множества. Да, ну понятно, ладно, я думаю,
вы, конечно, в своей жизни там со такими задачами, наверное, сталкивались в своей жизни, да? Нет,
никогда. Нет, ну как-то просто с чем-нибудь хоть в таком-то виде сталкивались, но на самом деле,
конечно, ну в качестве, надо, ну какую-то базовую задачу надо упомянуть и, конечно же, мы, но тут
должны мы поговорить про задачу о поиске какой-то гамильтонного пути. Да, ну почему? Потому что
просто, потому что эта задача действительно имеет важное значение, собственно, в теории. Вот, значит,
о чем у нас вообще разговор? Ой, кстати, еще одна дырка, надо еще про эллеровые циклы поговорить, да? А,
говорили? А, слава богу, отлично. Вот, значит, что такое гамильтонов путь? Ну, обычно, значит,
определение такое, пусть у нас есть какой-нибудь граф. Путь называется гамильтоновым, если он
проходит по всем вершинам, причем ровно по одному разу, то есть там без вот этих вот там каких-то
возвратов в какие-то другие вершины, чтобы пойти в другое место. И вот возникает задача,
которую человечество на текущий момент, мало того, что не умеет решать заполиномиальное время,
так еще и имеет нот, имеет очень сильное highly likely нот на тему того, что заполиномы эту задачу
нельзя решить в принципе. Задача, ну, задача уже хотя бы дан граф, а есть ли в нем гамильтонов путь,
да или нет? Ну, как всегда, то-то и проблема, что в каких-то графах есть, а в каких-то графах нет.
Это не эта ситуация, когда там играют двое, Вася ходит первым и делает тот, а потом Вася ходит
вторым и делает тот. Напишите, кто победит. Да, именно, именно. Но да, да, да, то есть в Команда
Олимпиаде ЛКШ какого-то лохматого года такую задачу реально дали. Было очень смешно. Но там
эта традиция локошадских слоников берут свое начало с задачи слоники. Ладно, это я отдельно
расскажу. Это смешно. Так вот, значит, ну, на самом деле можно решать, конечно, что-нибудь более
продвинутое. Ну, можно решать так, можно найти гамильтонов путь минимальной длины, там, например,
и так далее. Ну, если, допустим, у вас у каждого ребра дана длина, вот, там что-нибудь такое, ну да,
то есть гамильтонов путь минимального веса, ну, там что-нибудь еще вот в этом вроде. Ну, все эти
задачи, в общем-то, решаются примерно одинаково. Решается они с тем, что вы заводите просто там
Dp от mask и V. То есть вам жутко, вы рассматриваете пути, которые прошли ровно вот по вершинам,
которые записаны вот тут, и вершина V, и которые заканчиваются в вершине V. Ну,
в базовой версии, то есть в базовой комплектации, когда просто надо там существует ли гамильтонов путь,
тогда можно просто сказать, что это бул, и просто существует ли путь, который проходит вот по всем
этим вершинам ровно по ним, и заканчивается при этом в вершине V. Ну, тогда понятно, пересчет
можно делать там как динамику вперед, да, то есть типа там for у V, значит, там, допустим,
пишем, если, значит, не там mask and 1 х х у, то есть мы проверяем, если вершина у не лежит, значит,
если выясняется, что ребро в у есть, ну, там, в какой-нибудь там, я вот напишу вот в таком виде.
Ладно, правильнее по-другому написать. Правильнее, конечно, написать, что for в, значит,
ну ладно, если уж так полный код писать, то есть там for mask равно от нуля до 1 х х n минус 1,
да, перебираем маски в порядке возрастания в данном случае, естественно, значит, пишем сразу,
если dp от mask, то есть это вот типичное такое dp, да, то, значит, перебираем такие ребра, значит,
если mask, то значит dp от mask, ну, можно так написать dp от mask или 1 х х у или равно dp от mask.
Вот, красота, красота. Вот, то есть, в принципе, можно тут выставить какого-нибудь восстановления
ответа, ну и так далее и тому подобное, это не очень интересно. То есть, ну, думаете,
то есть такая вот классика, кстати, за какую симпатику она работает? На n квадрат, а поточнее. Да,
то есть o от 2 в степени n на m. Нет, на самом деле, нет, есть целое направление, в принципе,
можно тоже там все это покопать, но там разные проблемы, как действительно, можно подумать,
а нельзя ли тут сделать 2 в степени n пополам какой-нибудь? М, количество ребра? Да. Обычно тут
не заморачиваются пишут n квадрат, но в принципе, но в принципе, заметим, что здесь на самом деле
можно, то есть вот такое решение получается 2 в степени n на m. Да, а, ну, я здесь фактически
куда-то написал, можно прям список ребр делать и будет хорошо вполне себе. Вот, ну, заметим,
что на самом деле можно применить какую-нибудь веселую технологию типа mipton the middle и забабах,
и получить o от 2 в степени n пополам на шота. В роли шота, ну, я не знаю, n квадрат плюс m будет.
Ну, для того, чтобы, ну, чтобы на первой половине и по второй половине, собственно,
забабахать вот эту честную динамику. Ну, так, знаешь, две цели. Во-первых, помянуть,
что как бы там фаза для m тоже будет, а во-вторых, ну, могут быть формальные кратные ребра. Да,
понятно, что почти во всех постановках задачи первое, что надо сделать, это избавиться от кратных
ребер, да, ну, вот упомянем. Хотя в принципе, да, согласен, m можно в общем-то так аккуратненько
и убрать, потому что на самом деле это не... Значит, как конкретно... Что конкретно я тут имею в виду?
Ну, имею в виду следующее. Разделим множество вершин на две части, на две половинки. Для каждой
половинки я вот эту динамику честно напишу за 2 в степень пополам, а потом нам просто эти два
гамильтона в пути надо скомпановать. Это же неправда. Неправда? Неведательно верно, что гамильтон в путь есть в любом панду, да, если... Бяка. Если его нет, мы получим, что его нет, но если он есть, то мы можем не получить, что он есть. Ну, согласен, согласен, да, да.
Так, жалко, обмануть не удалось. Ну, хорошо. Ладно, ладно, хорошо, ладно, я не знаю тогда алгоритм, как делается 2 степень пополам. Вот, все хорошо, тогда не знаю, ладно. Как говорится, ладно, да. Как сказал бы классик в этом месте, не импровизируй больше никогда. Ну, нет, я буду импровизировать, так интереснее. Вот, вот, ладно. Ну, вообще, ну, на самом деле, ну, шутки шутки,
ну, там действительно надо, то есть какие-то алгоритмы там в эту сторону, там перебор за более меньшую степень есть, конечно, да. То есть более того, там есть мечты даже, чтобы два было в степени какого-нибудь нот. Ну, чтобы там был, ну, какой-нибудь там, понятно, что два в степени лог, конечно, не получится, но два в степени... А вот два в степени полилог, это в принципе тоже там может быть вполне себе направление алгоритма. То есть там лог квадрат там какой-нибудь, вот это вот все. То есть это в принципе,
может, еще и ничего. Вот, вот. Ну, в конце концов, это n в степени, вот что больше, n в степени логарифом m или два в степени n?
Ну, давайте вопрос. Сравниваем, два в степени n и n в степени лог n.
Ну да, заметим, что это два в степени лог n в квадрате, да. Ну, что больше, n или лог n в квадрате? Очевидно, n.
Нет, ну, о-7-тотически, как всегда.
Ну, пока утверждается, что можно как бы вот это вот допилить до n. А каким образом?
Так, ну... Да, то есть не сильно сложным способом, но его понять не удалось. Не, просто если не сильно сложный способ, значит, если мы сейчас тут две минуты подумаем, то мы должны придумать.
Чего? Какого состояния?
Последний вопрос.
Так, ну, хожу в DP-маску, и что оно даст? Просто к DP-маске, к DP-маске ж просто так ребро не прицепишь, должен знать конец.
А, они свято верят, что нет?
Нет, можно, конечно, можно считать, что DP от 2 в степени n, то есть DP от маски, наш шоу может заканчиваться...
Так.
Это как?
Не можем. Не можем, мы же по першинам ходим рандомно.
Да.
Да.
Ну.
То-то и проблема, он слишком как-то идет, вот, да, это подлянка, да. То есть как бы нет, то есть какая-то ощущение, что да, с переходами тут, вот, к сожалению.
Да.
Так.
А, так, хорошо, то есть храним, на шоу может заканчиваться путь, прошедший по этим маскам. Так, и?
Да, логично.
И что это нам даст?
Да, дальше просто очень страшный пересчет показывает.
Ну, странно, что он за 2 в степени n, потому что как бы очевидно, как вот за 2 в степени n пересчитать, но это не очень интересно.
Ну-ка, и что?
Пусть, пусть, пусть, даже интересно, да.
Ой, боже мой.
Так.
А, ой.
А, такой чит, да.
А, я понял, да.
Ну, хорошо, да, хорошо, значит такая наглость, да. Заметим, что, да, заметим, что список смежности, список вершин достижимых и заданной за 1 ребро можно хранить в виде масочки, да.
Можно, да.
Тогда идея такая, за 2 в степени n, если не быстрее, ну да, за 2 в степени n на самом деле, а можно даже и за 2 в степени n при желании, можно для каждого под множество вершин хранить множество ребер, которые можно из них провести, типа, куда они придут.
Вот.
Ну да, типа да.
Ну тогда, если у вас для каждого под множество этот образ уже насчитать, то тогда в результате оказывается следующее, что если у вас получается вот так я пишу, маск dp от там 1 хрась-хрась n, то есть храним типа, что, то есть для каждой маски храним, где могут заканчиваться там путь, который прошел ровно по этим вершинам.
Вот.
Ну вот.
Ну вот.
Но тогда, соответственно, оказывается, что значит мы тогда берем эту маску, берем какие ребра мы можем к ней прицепить теоретически, автоматически.
И после этого там за 1 получается там, что там мы получаем.
То есть за какой-то там n, какое-то там вычитание понимаем, какие следующие вершины мы можем добавить.
Так все понятно, о чем мы говорим.
А как понять, какие ребра можно прицепить к маске?
Значит идея такая, утверждение номер 1.
Для каждой вершины мы храним маск out от v.
Что такое маск out от v?
Это маска всех, куда торчат ребра.
Ну я не буду, не хочу, достижим, а обычно это когда путь существует.
С соседей.
Да.
Всех соседей.
Всем соседям, именно происходящим из веребра.
Вот.
Теперь заметим следующее.
Теперь, если у нас есть маск такой, то по каждой маске я могу поставить, так сказать.
То есть маск out 2 от маска.
То есть я хочу рассмотреть множество соседей уже не у одной вершины v, а у под множества.
Если у меня есть вот такая штука, я вот эту штуку за 2 в степени n насчитаю.
Ну в тупую за 2 в степени n, но если чуть более умно, то 2 в степени n.
Ну вот если я там для каждой маски начитаю младший единичный бит, например.
Вот.
После этого тогда у меня, значит, динамика здесь будет работать так.
То есть вот вместо того, чтобы перебирать вот эти ребра, то есть на самом деле форик будет звучать так.
Смотрите.
Вот.
То есть оказывается так.
То есть пишем вот это вот dp mask.
То значит пишем int n mask равно, соответственно, пишем прям вот этот вот маск out 2 от маска.
Ну и дальше можно просто сказать перебираем.
Перебираем просто for v, значит ev.
Значит прям честно пишем.
То есть прям можно for v от 0 до n-1.
Если, значит, если в n-маске она есть, n-маск int 1 хресь-хресь v.
И, но при этом в маске ее допустим нету.
Там то есть не маск int 1 хресь-хресь v.
То значит dp от маск или 1 хресь-хресь v.
Значит или равно.
Ну просто равно true в нашем интервизе.
А, да, вы правы, вы правы, вы правы.
Да.
Нет, ну ладно там.
Нет, или равно 1 хресь-хресь v скорее получается.
Это не маск out.
Да, мы в явном виде.
Да, и конечно, что здесь у нас тогда уже не было вполне себе.
То есть тут тип маск.
Ну это я так пишу.
Понятно, что это int, естественно, но как бы смысл в другом.
Вот.
Да, то есть вот такой пересчет у нас имеет место быть.
Ну вот получается, что при такой жуте, то есть асимптотика получилась от 2 в степени n даже на n.
Да, прикольно, спасибо.
Да, маленький, маленький прикольный штука.
Тут прям даже иногда напрашивается там она.
Ну да, ладно.
Ладно, не уверен, что она нам просто на халяву сейчас еще этот n убивается.
Смотрим вообще все штуки, которые из любой вершины маски достижем.
Это же не значит, что есть критонок путь, который заканчивается.
Нет, в ДП написаны все вершины, на которых может заканчиваться гамильтонов путь по всей маске.
Ну.
То есть мы хотим взять маскал вот не от маски, а маскал вот от ДП от маски.
Да, маскал тут ДП от маски.
Ага, да, вы правы.
Да, вы правы, вы правы.
Так, хорошо.
Ну да.
Ну правда, помимо этого кода теперь у нас к сожалению еще там что-то есть.
То есть там есть инициализация динамики, есть собственно вычисление вот этих вот маскаутов и МаксАут2.
Но это несложно.
Вот, да, хорошо.
Ладно, пожалуй остановимся на этом в обсуждении этой задачи.
Но основное, конечно, что тут надо обсудить, это конечно то, что называется ДП по профилю.
Вот. Ну правда, ДП на профиле это конечно по факту частной случаи ДП на подмасках.
Но определенная классика, определенные там интервьюальные подходы там все-таки есть.
Но на самом деле заметим, что задача, но на самом деле задача в общем-то на ДП по профилю по-хорошему две.
Такие две культовые есть.
Это задача про доминожки, задача про симпатичные узоры.
Вот.
Да, но мы можем с вами быстренько обсудить задачу про доминожки.
Итак, ну давайте обсудим. В чем задача про доминожки?
Ну задача про доминожки у нас заключается в том, что жил был тут.
То есть жил был тубличко.
Там такую досочку ННМ.
Хочется его заполнить доминожками.
Хочется положить доминожки. Каждая доминожка должна две соседние клетки крыть.
Вот. И хочется их покрыть так, чтобы каждая клетка была покрыта.
И доминожки и тачали, и накладывались.
Сколько способов?
Ну по-разному.
Ну тут смотря как писать.
Нет, дальше в зависимости от ННМ возьмите вопрос, какая симпатичка вас удовлетворит.
Всякое бывает.
Потому что самое тупое, что можно сделать, это написать какой-нибудь ДП, там вида...
Ой господи.
Что я этим маркером пишу? У нас же зеленый есть.
ДП житое масковое.
Что это означает?
Означает это следующее. Мы идем слева направо.
Замостили жи столбцов, но при этом из житого столбца в жи плюс первый у нас что-то торчит.
И у нас в масочках ранит, а что собственно таки?
Это как бы однозначный процесс, потому что на каждом шаге мы просто в очередной столбец кладем доминожки,
причем замощаем либо вертикально, либо горизонтально в следующий столбец.
Если мы это насчитаем, то сразу автоматически получается, что ответ это ДП,
а там какое получается МТ нулевое. То есть М столбцов замостили и ничего не торчит.
Ну теперь возникает вопрос, а как...
А как собственно эту ДП пересчитывать?
Перебираем под маски.
Ну вот.
Перебираем под маски, которые нам подходят с предыдущим словом.
Ну да, то есть там...
Ну да, то есть смотрите, можно прямо даже код писать.
То есть когда вы перебираете, то есть for g равно от 1 до n,
for, там for маск равно от 0 до 1 х х n-1.
И дальше там for, там p маск, то есть предыдущим.
Перебираем предыдущую маску.
Дальше пишем какую-то мистическую функцию if там our neighbouring.
От маск, p маск и n.
То там ДП житое масковое, да, там плюс равно бла-бла-бла-бла-бла-бла-бла.
Вот, бла-бла-бла-бла-бла, бла-бла-бла-бла-бла-бла, бла-бла-бла-бла-бла.
Вот.
Ой, ой да, еще и да.
Да, вот называется да, слишком много бла-бла было.
так вот то есть можно писать вот такой код за сколько будет работать такой код
ну да сам нет а если бы мечты мечты тут еще вопрос за какой симптутику работает вот это
ну как сказать ну давайте смотреть для этого надо рассмотреть нот потому что смотрите был но тут
надо внимательно смотреть тут еще то есть был а neighboring да потому что если вы тут
передаете маска по маску n да вот то по-хорошему это как бы какая-то функция которая видимо
проверяется как-то за n поэтому тут два варианта либо вы в тупую тупой вариант 4 в степени n на
м на n да либо есть еще вариант предподсчитать эту функцию заметив что от же она никак не зависит
и тогда это даст вам тут плюсик в принципе это оптимизация так разиков ну в несколько вот хотя
конечно да чему должно быть n 4 степени было адекватно но я равно 10 ну может быть вот где-то
10 да может 11 может 12 может это все вот значит а neighboring я вот но теперь надо следует вот то
есть можно сделать так вот как-то теперь оптимизировать можно взять но вот но давайте
но тут давайте внимательно посмотрим на кое-что потому что в этой функции будет записано скорее
всего следующее но заметим что если что-то торчит следующий столбец то в этой клетке ничего не
так читать с предыдущего столбца поэтому первую строчку которую можно написать это написать если
то есть так и написать честно если п маск и маск то просто сразу выбрасываемся с криком false как
мы собственно это всегда уже там полтора семестра делаем вот но в противном случае теперь надо
вернуть что ну напишу так мы там мэй зилс битом вот все время у меня проблема как подвизки написать
что нули можно это разбить на пары соседних а точно а то что сплит точно ну хорошо да нет тут ладно
в чем даже не в том что я вот некоторые что-то я понял что я много лет писал сплит это и
демонстрировал себя как человек который вообще не знает английского понимаете почему да отлично
кто не понимает на всякий случай неправильный глагол да вот вот вот ну вот так что соответственно да
так значит маска там или п маск вот вот но эта функция как-то за линию пишется кстати
честно говоря нет честно говоря не знаю можно ли именно битовой магии сделать за единицу то есть
нет я понятно что я могу сделать понятно что я могу сделать предподсчет этой функции за два
в степене естественно да то есть да это никаких проблем нету но но вот но вот и можно сделать это
именно битовой магии я честно говоря сказать не готов вот мне такого неизвестно вот вот но просто
значит что это приятно да я конечно по дефолту продолжает работать за два в степенен но при
этом говорит нам о том что можно перебирать только маски не пересекающиеся поэтому на самом деле
можно здесь написать что-то типа но вон того то есть потому что надо перебирать по маске
должно не пересекаться с маском то есть это означает что когда то есть фор там по маске
значит являющиеся под масками такой маски как 1 х х n минус 1 минус маск ну например так вот
как их перебрать но вот мы уже с вами обсудили вот теперь вы секает вопрос за сколько мы это
сколько теперь это будет работать да но теперь мистический факт если вы перебираете пары маска
то есть мы если пересекая перебирайте пары не пересекающихся под масок то оказывается
вы перебирайте ровно 3 в степени n пар масок даже не от 3 в степени на ровно 3 степени n это вот
важный факт почему это так да потому что заметим что если я напишу просто маск и по маск в столбик
то я заметил что на в каждом разряде у меня должно быть либо 0 0 либо 0 1 либо 1 0 1 1 быть
не должно то есть поэтому поэтому здесь все просто то есть получается она в каждой позиции
три варианта поэтому всего 3 степени просто так и чисто задачи по комбинаторике может у вас даже
такая была на дискретке ну или просто это известный факт а во а потому что вот этот
перебор теперь за 3 степени ну потому что это более точное знание вот так да потому что о это
означает что это может быть там 2 на 3 степени 57 на 3 степени там 179 на 3 степени на нет тут
фишка в том что это ровно 3 степени то есть не больше и что самое главное не меньше то есть
может там быстро что мы там оценили как ты знаете знаете как бывает оценили обратную функцию керман
а там точно 7 только корень из обратной функции керману дознать вот была такая ситуация ну ладно
не было так а может и была мы не знали вот вот поэтому так вот здесь то есть поэтому можно
в принципе так кстати отсюда же автоматически следует что если вы перебираете маски их под
маски то тоже получится 3 степени н ровно по этой же причине ну только тут допустимо будет там только
будет до всем 1110 а 0 1 будет выкинута суть та же но вот на это просто хотелось упомянуть что для
подмасски что это вот важный момент так что еще вот но хорошо ладно то есть всем то я хорошо
значит выковырили получается сколько там 3 в степени n на м плюс и ну два степи ну да ну хорошо
ладно хорошо убили до убили м и остался м да правда обычно м скорее всего больше либо ровно
но у вас будет да потому что наверно туда 3 степени вы захотите поменьше но это уже
другое ой кошмар вот я буду это стирать будет весело конечно да вот ну ничего вот но к
сожалению конкретно этот конкретно такой метод уже к сожалению оптимизируется не очень но дальше
впрочем на самом деле тут зависит куда вы хотите оптимизировать потому что ну дальше бывают
экзотические подстановка постановка задачи которые предложил видимо там возможно там андрей
сережа станкевич где-то в лохматом 2002 году что делать если у вас n где-то 5 а м 10 слотой
нет просто не просто это была просто это просто была история да историческая задача просто там
был просто вендуй станкевич контест один была дана задачи симпатичный узор это на вот оглашенная
выше ограничения нет там количество способов нет она так не зацикливается она растет поэтому
фишка в другом поэтому конечно все сводится к матрице но да но это да но это не проблема как
бы но когда особенно когда матрица 6 на 6 это собственно никаких проблем нет вот то есть там
полу то есть то есть вывод то есть то есть можно то есть асимптотика получается 8 степени на лог м
иногда это оптимизация да что есть не факт я ну как сказать жарданов базис наверное есть всегда
другой вопрос не смотря шоу называется жардановым байзесом да пошепом в жарданову нормальную форму
матрицу привести можно всегда по моему другой вопрос еще она будет
нет комплекса у нас же поле по модуле миллиарде семь обычно нет это не рекуррент это именно
рекуррента на столбцы написано потому что вы матрица матрицу размера 2 в степени
возбудить степень а там не матрица 6 на 6 там 64 на 64 да так так ну давайте так давайте
вспомним откуда там вообще матрица берутся все так отлично так у тебя столбец у тебя какого
размера 2 степени ну вот а 2 степень ты перемножаешь за куб 2 степени в кубе это да да то есть
может кому-то да я могу написать что это вот равно 2 степени 3 и на лог м может кому-то так привычнее
метамка методом кого кита масса да мы прошли метод кита масса так погодить погодить сейчас
этот а этот метод насколько работает если мы тут вместо коэффициентов столбцы начинаем
подставлять такой ряд имеет рекуррент рят имеет рекурренту если у тебя только в этом
году столбцы находится тогда
нет параде вредится не запустить берли кэмп это хорошо осталось только вы запустить мы еще пока не
знаем как к сожалению да очень хотелось бы честно говоря узнать но пока пока нет вот да увы вот но
это другой вопрос да потому что я пока не очень понял как взял так чтобы это была именно вот
линейная рекуррента чтобы там создать сдвиг на 1 ничего не попортил ну так ну потому что была
линейная рекуррента надо чтобы вот этот выражался через линию это это это это а потом сдвинули
на 1 то есть я не этот а следующий и тоже будет линейная рекуррента причем такая же а как
честно говоря тут это сделать вот здесь чтобы без столбцов обошлось я ну как я уже говорю мне не видно
я не знаю да как вы это все я не я не знаю вот ладно но на самом деле тем более что в этой задаче это в
общем-то и не нужно потому что есть как бы другие подлое ограничение потому что самое подлое
ограничение в этой задаче это когда n умножить на m не превосходит 400 и это оказывается подло
потому что 3 в степенье начинает вылетать в трубу да чего но вот это вылетает трубу вот это вам
тем более не помогает поэтому вместо этого появляется метод изломанного профиля да да то
есть он неожиданно да он оказывается неожиданно приятен вот послушаю вас называется да
летающая гадость так так давайте разбираться дальше смотрите то есть идея будет такая то есть
мы будем то есть раньше то есть как в чем у нас проблемы да у нас там есть какие-то
состояния есть какой-то какой-то длинный пересчет значит мы сейчас изобретем состояние чтоб пересчет
был за единицу как нам это сделать а мы будем говорить аккуратно ладно мы же будем замощать
не целый столбец на каждом шаге а мы будем замощать по клеточке то есть вот идея будет
такая мы дошли вот до этой клеточки говорим что все выше ее и левее ее мы замостили только
возможно куда-то вправо от границы что-то торчит но вот и теперь наша задача эта клетка
не замущена теперь надо положить доминожку либо вертикальную либо горизонтально то есть
количество то есть dp у нас получается от икс там ну что-то типа от и ж или даже
джи и и маск то есть маск куда торчит все маска можно по-разному задавать кстати
вот разные способы вот вытекает вопрос вот в каком порядке эти клеточки записывать
а вот а вот не факт вот я не знаю мне что-то нравится вариант когда начинаю записывать
вот это 0 1 2 3 и так далее да тогда просто оказывается то есть код тогда выглядит
примерно следующим образом ну то есть тут получается конечно динамика вперед то есть
понятно что изначально мы пишем что d 0 0 0 равно 1 допустим да а дальше а дальше мы пишем так
for g равно от 0 до n минус 1 то есть for и равно от 0 до n минус 1 ну как всегда for маска равно от
0 до 1 хресь хресь n минус 1 значит дальше говорим так ну первое что хочется сделать это конечно там
лонг-лонг там лонг-лонг ссылка d равно dp житое и т масковое почему ну потому что вы до радости
мне там придется писать плюс равно вот эта гадость да но если я буду писать плюс равно эту
гадость то обратите то тогда он как бы формально если без оптимизации то компьютеру придется
вот эту вот ячейку в трехмерном массиве а это жирная операция потому что в этой жирной операции
ему придется взять значит там чё-то вот этот то есть вот это вот же и умножить его на вот размер
этого двумерного массива прибавить не умноженное на размер вот этого одномерного массива плюс
еще маска прибавить и все это прибавить к дпшки ну к указателю то есть оказывается кстати
настолько жирная операция, что с какого-то момента оказывается выгодно не использовать
многомерные массивы, использовать одномерные массивы, а перегонки вот этих там трех или там
сколько у вас индексов в один делать вручную. То есть у меня был даже такой прецедент, когда у
меня была пятимерная динамика. Вот я написал пятимерный массив и он получил tail. Я переписал
индексы честно, то есть индексы сказал массив одномерный, а индексы прям вот функцию написал,
как по пяти индексам получить один и по одному получить пять. Все, залетел там с полуторакратным
запасом. Хотя нет, по-моему и массив. Точно я не мог написать пятимерный вектор.
Нет, тот и прикол. Это был пятимерный массив. Нет, пятимерный вектор я точно не написал. Нет,
ну да, совершенно верно. Так вот выясняется, что если я это делаю вручную, почему-то он это делает
лучше. То есть видимо там как-то, ну просто вот это мой опыт получился такой. В чем это было
убедительно, потому что tail был 15 секунд в задаче. То есть как бы знаете, когда tail заменяется на
ok с результатом 9.2 как-то. Сигара код форсуса, если что. Так вот, но есть вот действительно такое,
может быть, оптимизация, которая поможет вам, если не асимпатически, то хотя бы по сократить
количество кода. Берем вот такую ссылку D. И вот сейчас я продемонстрирую, как ее использовать.
Ну начнем с того, что Dp. А, ну во-первых, вам конечно придется написать int ni равно i плюс 1.
Там, допустим, запятая, nj равно j. Ну придется тут рассматривать. Если оказалось, что i равно n
минус 1, то как бы ni равно 0, запятая, nj равно j плюс 1. Да, ну я здесь уже это напишу, хотя в принципе
перед форум в маске это можно было написать. Ну потому что понятно, ni и nj это как бы следующие i и j.
Так вот, первый переход, который я делаю, это Dp от nj, ni и. Ну в моей интерпретации получается так.
Маск хрязь хрязь один. А, нет, вру. Начать надо с того, что если оказывается, что в этой маске
битик есть, вот то есть клеточка уже занята, она торчит, то тогда надо просто сказать, что Dp
njt ni t маск хрязь хрязь один плюс равно D. Все. Ну я там не буду сейчас вот это по модулю там миллиард
7 писать, просто плюс равно D. Да, мы количество способов считаем, да, конечно. Нет, задача можно ли замастить, да или нет, она слишком тривиальная.
Вот, а если масочка не занята, то надо думать, что класть. Ну горизонтальную доминушку можно положить всегда
и получится Dp от nj, ni и там маск хрязь хрязь один или 1 хрязь хрязь n-1. Вот. Вот. Ну вот в моем способе получается так.
Так, ну теперь проверяем, что если оказалось, что i плюс 1 все еще меньше, чем n и при этом выяснилось,
что маск n-2 тоже пусто, то тогда кладем вертикально доминушку nj ni t значит маск хрязь хрязь один или один плюс равно D.
Да, преимущество вот, то есть у этого кода оказывается преимущество масса, потому что преимущество просто, во-первых, то есть мало того, что этот код теперь работает за асимптотику 2 в степени n на n на m
и это все, да, состояние динамики вот столько, но зато переходы за 1 обчитываются, да, то есть это просто уничтожает просто спокойно там все эти ваши 3 в степени, которые там были, но 2 в степени на n меньше, чем 3 в степени, правильно? Вот.
Так еще и приятность здесь заключается в том, что это буквально все. То есть там раньше помимо вот этого форика в динамике надо какие-то функции писать, битвы, там проверки какие-то, какие-то там маски соседние, не соседние, предподсчеты, а тут прям буквально все.
То есть кроме там мемсета, ДПшки и в общем-то там выковырения ответа больше ничего писать не надо. Вот, это называется ДП по изломанному профилю.
Прощай, ну почему? Ну мы могли бы не делать имперсант, но сделали мы для того, чтобы вот так писать.
Да, что? Действительно, пожалуйста, можно константу, ну я не знаю, может это быстрее будет, я не ставлю, может компилятор там возрадуется действительно от чего-то, но нет, не возрадуется.
Но всякое бывает. Так что это у нас что касается ДП на подмазках. Так, ну хорошо. Так, значит это такую дырочку по ДП закрыли. Так, есть ли тут еще какие-то вопросы?
Хотелось бы, то есть честно скажу, честно говорю, только пока состояние здоровья не позволило мне рассказать его сегодня, а так самому очень хочется.
Вот. Ладно, попробуем ликвидировать. Как-то вот как-то напоминает вот эта вот эта зачистка юзи до золот 1. Ну вот да, то есть как бы да, то есть какая-то вершина зеленая, если вершина помечена делаем ее зеленой.
Ну ладно, ну так и ладно. Ну хорошо, да, ладно, отдаленные, отдаленные, конечно, ассоциации, да. Ну не, ну как сказать, чем более отдаленные задачи, тем более там остаться, тем более потом на контест могут приходить жалобы, что все задачи одинаковые, хотя если формально тыкнуть, то выяснится, значит вообще на разные темы и так далее, но как бы, но видимо у кого-то видимо за эти казалось бы разные задачи отвечает видимо один отдел мозга.
Ну вот. Ух ты! Ну мало ли, ну. Не, ну как это, да, да, да. Нет, ну как-то, знаете, нет, есть же это классика какая-то, какие вино лучше всего? То есть это там, то есть конечно, то есть французы знают, что конечно наши вино самые красивые, там самые лучшие, самые грыстые, самые вкусные.
Но нет, конечно же, все грузины знают, что наоборот грузинские вино, конечно же, самые лучшие, самые восхитительные из наших гор. Ну вот, ну конечно, там рядом приходит веселый молдаваник, говорит, что у нас самые веселые вино, вино в Молдавии, но вот, но только евреи эти тихо улыбаются в сторонке, потому что они-то знают, что все эти вино мы наливаем из одной бочки, вот, да, сложный прикол, не обращайте внимания, да, вот.
Вот, да, не знаю, да, при чем тут это вообще, да, не важно, но да, что нас, на самом деле, да, что нас, на самом деле, да, все задачи по программированию, это на самом деле задачи на хакарасика, да, да, именно поэтому мы его изучаем на втором курсе, потому что это самый великий алгоритм, да.
Да.
Вот.
Ой, но господи, записывай многочлен, как строчку запускаем хакарасика, все, все, хакарасик нужен, только если вы перемножаете более, чем два многочлена, да, а два многочлена перемножаются префиксункой вообще, да, вот, да, вот.
Ладно, так, ладно, поэтому давайте пока закроем, так, давайте закроем дырочку попроще, значит, пришло время узнать, что такое БФС, не, не, я, значит, рекомендую не отключаться, да, так, что как говорится, да, рекомендую не отключаться, потому что кое-что интересное там, скорее всего, вы все-таки узнаете, потому что, да, сейчас вы, да, потому что, возможно, сейчас алгоритм Д-экстрим мы сейчас выведем, конечно, из немножко неожиданного места, да,
вот, значит, потому что, смотрите, просто до чем с нуля, вот, предположим, что у нас, представьте, у нас, то, программирование только появилось, и у нас возникла мечта находить кратчайшие пути в графе, как же это делать, ну, давайте начнем с самой простой постановки, какая у нас самая простая постановка, ну, просто дан невзвешенный какой-нибудь граф
и давайте, ну, так, честно, честно, честно его искать, ну, вот, честно, хочется найти кратчайшее расстояние от вершины С до всех остальных вот именно в ребрах, ну, ладно, ладно, портить доску, так, портить доску или нет, так, знаете, что, давайте, так, давайте я лучше сделаю то, что давно пора сделать и, собственно, две минуты потрачу, все, я быстро, и так, вот, значит,
вот, допустим, у нас теперь есть какой-нибудь там веселый граф, я даже большой нарисую, граф, да, у нас был ДФС, поэтому в этом и верим, да, ну, при желании можете считать, что граф это такой объект с вершинами и ребрами, значит, вершины это просто какое-то конечное множество ребра, это, значит, такая пара вершин, вот, нет, ребро это пара,
ну, это если кратных ребр нет, так что лучше так не говорить, нет, ну, вот, нет, ну, ладно, с точки зрения задачи о кратчайших путях, конечно же, там, это не надо, да, вот, значит, смотрите, значит, поехали, как найти кратчайший путь, ну, просто буквально первая идея, которая может прийти в голову это, конечно,
знаменитый волновой алгоритм, почему ФФТ, а, ну, а, такие ассоциации, ну, да, синуска, синус, нет, все гораздо проще, значит, волновой алгоритм или мы могли бы его назвать слоистым, потому что волна номер 0, все вершины находящиеся на расстоянии 0, то есть это вершина С,
в следующую волну попадут все вершины находящиеся от С на расстоянии 1, то есть в следующую волну попадут все вершины на расстоянии 2, ну, и так далее, вот, будет 3, вот, будет 4, что там еще будет, не на столько, да, ну, ладно, там будет 5, тут что будет, там будет, там будет, там будет, там будет, там будет, там будет,
так, ну, в нашем случае получится 6, 7, 8, рано, пока еще нету, да, ну, да, спасибо, согласен, так, вот, так, так, так, так, так, так,
так, так, так, значит, тогда 7 будет вот так вот, а 8 будет вот так, хорошо, да, в принципе, заметим, что между слоями могут быть ребра не только из слоев следующей, могут быть из слоев внутри себя, могут быть из слоев предыдущие какие-нибудь, и так далее, вот, вот, примерно так это и выглядит, а как это пишется,
вот, чисто терминологический вопрос, потому что дело в том, что этот алгоритм я буду писать не совсем так, как мы пишем классический BFF, хотя, конечно, формально говоря, наверное, можно, ну, и потом, знаете, просто тут, конечно, надо копнуть вообще, как бы, как оно так исторически слышно, вообще, кажется, поиск ширину это способ обхода графа, то есть это способ выписать вершины в паре в каком-то порядке все-таки, да,
ну, правда, как и поиск глубину это способ как бы обойти вершины, то есть записать их в каком-то порядке, вот, а наш полновой алгоритм, значит, я все-таки сейчас код напишу, потому что, значит, мы на этот код будем ориентироваться, значит, он будет писаться так, я просто делал то, что я эти волны буду хранить в явном виде, да, именно, у меня будет vector, vector int, waves,
но, конечно же, это никоим образом не отменяет там vector int, там, допустим, какой-нибудь D, ну, мог бы написать use, но не хочу, значит, смотрите, расстояние, значит, ну, хорошо, да, ну, можно написать dist, но просто, по-моему, это слово где-то в STL-е случайно есть, нет?
Ну, хорошо, нет, ну, мы можем писать using a STD-вектор, да, using a STD-вектор и не парится, да, значит, да, тут мы сразу пишем n и inf, какой-нибудь, да, ну, давайте ins напишем,
так, здесь у нас слоев у нас бывает n, просто n, нет, ладно, для явности напишем n и вот, ну, это как бы что вы хотите положить в каждый вектор, ну, как бы вы должны как-то ему сказать, что вы хотите положить вектор, ну, фигу, да, ну, вот, как пишет фига на C++, вот таким вот образом,
вот, соответственно, да, так вот, dist от s равно 0 пишем мы и, конечно же, там waves от 0 скажем, что это равно s, теперь мы говорим честно for int там wave равно 0 wave меньше n
значит n плюс plus wave
значит, смотрите, что тут надо написать, значит, ну, тут мы честно перебираем for int v, значит, в waves от v wave
значит, и тут мы и говорим, значит, for int nv, ну, видимо, у вас там есть какой-то список смежности, да, graph от v, и что у нас тут получается, вот, да, да, да, если оказалось, что dist от nv больше, чем dist от v плюс 1
или в нашем случае, ну, вот, но на самом деле, да, можно dist от v, но заметить, что dist от v и wave это буквально одно и то же, вот, плюс 1, то, значит, пишем dist от nv равно dist от v плюс 1
и, соответственно, waves от dist от v плюс 1 вот этого, точка pushback, pushback от v, for nv
вот такую штуку мы пихнем, вот мы ее пихнули, да, вот, то есть вот это мы будем называть волновой алгоритм, да, работает, ну, вот, потому что это мы будем называть волновой алгоритм, но, конечно, есть то, что мы будем называть bfs
то есть вопрос, конечно, что из этого bfs, вполне вероятно, но, как известно, конечно, у конкретно этого bfs есть, конечно, более простая реализация, реализация, ну, совсем известной очередью, да, то есть там вектор int
ну, допустим, dist опять же, да, от n и inf, давайте уж упомянем, и есть, конечно, q
вот, ну, изначально мы пишем, да, dist от s равно 0, q.push s, да, и тут мы неожиданно говорим while не q.
пока очередь не пустая, значит, мы говорим int v равно q.front q.pop, вот, то получается, что for int nv graph от v
и оказывается, что если, что у нас тут, ну, понятно, если dist от nv больше, чем dist от v плюс 1, то тогда оказывается, что dist от nv равно dist от v плюс 1, ну, вот, и, соответственно, q.push от nv
вот, это у нас классический, это мы будем называть классический bfs, но мы так будем называть, да, кстати, действительно, есть ваша задача доказать, что этот алгоритм вообще ищет кратчайшее расстояние, то как бы при вот таком волновом алгоритме это становится максимально наглядно,
потому что в терминах этого алгоритма заметим, что оказывается в каждый момент времени, то есть оказывается следующее, что сначала в очереди, потому что сначала в q находится просто нулевой слой,
потом после того, как вы обработаете нулевой слой, там будет находиться, то есть там wave, фактически все waves первое, потом пока вы будете доставать waves первое, вы туда, собственно, в очередь наложите waves второе и так далее.
Ну вот, так же и отсюда будет следует, что такой алгоритм действительно удобно работает, то есть без всяких векторов-векторов.
Вот, так, ну хорошо, говорим мы, первую задачу мы решили, даже за W plus E, но приходит время, наверное, повысить планочку.
Надо ввести VISA. Какие VISA? 1K. 1K, конечно, где K, но K пусть будет пока небольшое, там надо 50.
Да, да, спасибо, да, это важно.
А, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да
да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да,
да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да,
да, да, да, да, да, да, да, да, да, да, да.
Да, да, да, да, да, да, да, да, да, да, да, да, да.
Да, да, да, да, да, да, да, да, да, да, да.
Да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да, да.
Ладно, вернемся к делу.
Вот, значит, смотрите.
Итак, что же делать, если у нас есть ребра от одного до К?
Да, первая тупая идея, которая может приходить в голову, свести задачу в предыдущий путем распила каждого ребра на К частей.
Ну или сколько там?
Не, ну, пока К мелкая, можно было бы так и сделать.
Вот вам В плюс ЕК и радость.
Но когда К становится прям большим, это не очень.
Потому что когда бы участвовать там В, допустим, 100 тысяч, а Е это там есть 2 миллиона.
Поэтому мы пойдем другим путем.
Мы не знаем, что такое Д-экстра.
Мы выводим все с нуля.
Нет, да, можно написать ЕФФТ.
Вопрос зачем?
Ну, если ты умеешь сразу, теперь надо сравнивать, про многочлены говорить, какие многочлены меньше кого еще.
Ага, да, БФС на многочленах, классно, да.
Значит, смотрите.
На самом деле есть иожидная читерская вещь.
То есть, оказывается, вот этот волновой алгоритм прекрасно пишется.
Его можно писать так.
То есть, просто, ну вот, сейчас, погодите, ой.
Ну ладно, не будем все сказать.
То есть, идея будет заключаться в том, что у нас волн будет теперь N умножить на К плюс 1.
Вот.
Вот.
Да, сейчас, давайте, нет, смотрите.
Нет, погодите, погодите, давайте сейчас только внимательно смотреть.
Да, надо.
Поэтому, смотрите, значит, сейчас мы, знаете, давайте для удобства я даже это все сотру.
Потому что, ну, потому что, то есть, код, конечно, будет очень похож.
Конечно, если я сейчас писал, конечно, на проекторе, я просто там несколько строчек вставлял.
Ну, значит, смотрите, что поменяется.
Перебираем, значит, тут до N умножить на К.
Значит, перебираем.
Значит, four int V двоеточие, вот, да, эту строчку я зря стер.
Waves от wave.
Ага.
Вот.
Значит, а тут теперь делаем так.
Так, ну первое, что надо сделать, если оказалось, что dist, вот сейчас это будет важно, сейчас вы увидите.
Почему сразу проверку пишу?
Если dist от v равно wave,
потому что сейчас будет очень удобно действительно это делать вот так.
Значит, теперь four, значит, значит, такой картежик, допустим, v, n, v, w, graph от v.
Ну, то есть, я перебираю торчащие ребра из вершины v, вот вершину v с весом w.
Значит, смотрите, если оказалось, что dist от n, v оказался больше, чем dist от v плюс w,
dist от v плюс w, то что?
То тогда, естественно, мы объявляем, что, смотрите, я все делаю, dist от n, v равно dist от v плюс w.
И что еще?
А, ну и waves от n, v точка push от v.
Да-да-да, waves от dist от n, v, конечно.
Ой, давайте лучше.
Да-да-да, тут, конечно, да.
Waves от d.
Спокойно, спокойно, дальше веселее будет, да.
Зачем мы храним график? Мы же говорили, зачем мы храним? Откуда и куда?
А там, ну просто обычно это будет тип edge, а в типе edge уже как-то тупо не хранить начальную вершину.
Так что да, так-то, так-то, конечно, нет, но так хоть понять не будет.
Вот, то есть вот есть такой алгоритм.
Ну то есть, смотрите, идейно, конечно, алгоритм был бы красивый, если бы мы эти хранили не векторы, а листы.
И если вершина на самом деле вот в этом месте лежит в какой-то волне, но не в той, то имело бы смысл ее из этой волны перетащить.
То есть удалить из той волны и поставить в эту.
Я мог бы тут написать действительно, что давайте это будет вектор STD листов и для каждой вершины хранить итератор на нее, там вот это все, да.
Но на самом деле в этом нет необходимости, потому что на самом деле можно просто вот так написать.
То есть обратите внимание, что суммарно, кстати, к чему равно суммарное количество волн в таком графе, когда мы каждую вершину можем несколько раз добавить?
Суммарный размер?
Да.
Ну можно сказать НК, конечно, да, можно заметить, что каждую вершину мы добавим не более чем К раз.
Но на самом деле можно делать оценку еще тупее. Е.
Ну даже не тупее, просто другая оценка.
Заметим, что каждый, потому что у нас каждое ребро может повлечь у собой не более одного пушбека.
Поэтому суммарный размер волн Е.
Но с другой стороны он и ВК тоже.
Но лучше оценивать, как я.
Потому что ВК это как бы то, что мы в будущем захотим оптимизировать.
ВК надо оптимизировать.
А что, ВК сейчас плохо работает?
Ну просто да.
Нет, ну надо смотреть, потому что с оптимизацией там как бы помните, да.
Я уже рассказывал, какого уровня олимпиадники там работают.
Ну по крайней мере 10 лет назад, там несколько чемпионов мира там работало.
Причем я имею в виду не только Лопатина, естественно.
Но там более современные, там СПБ 4 чемпионы 2014 года и так далее.
Там серьезные люди, там квалифицированные.
Вот.
Так вот.
Заметим, что получается вот такой алгоритм.
Это желательно, конечно, то есть уже, конечно, может быть менее очевидно, а почему это вообще работает.
Ну вот.
Ну тут на самом деле надо доказать, что мы все-таки приговорим, там есть один точный момент.
Значит, давайте, смотрите, давайте докажем, то есть докажем, что кратчайший путь до В здесь находится.
Для этого мы этот путь рассмотрим.
Вот.
Допустим, вот у нас такой путь.
И тут какие-нибудь веса типа 5, 1, 4, 3, 8, 6.
Ну я от балды написал.
Значит, тогда надо, ну, во-первых, воспользуемся чем?
Так как у нас ребра не отрицательные, то в принципе оказывается, что, действительно, что префикс кратчайшего пути это кратчайший путь.
Ну, впрочем, это всегда так.
И тогда получается, что кратчайший путь досюда 0, досюда 5, досюда 6, 10, 13, 21 и 27.
Но фишка в следующем.
Теперь мы по индукции можем доказать, что каждый из этих вершин вот в свой слой попадет.
Причем попадет она в слой для нас, что самое важное, это прям ключевой факт доказательства, до того, как мы этот слой будем рассматривать.
То есть вот эта вершина попадет в 5 слой не позже того момента, как мы будем рассматривать 0 слой.
Вот эта вершина попадет 6 слой не позже момента, когда мы рассмотрим 5 слой.
Может она попадет и раньше, там может и другой путь в длине 6 есть.
Но, по крайней мере, когда мы рассмотрим 5 слой, рассмотрим эту вершину, эта вершина в 6 слой точно попадет.
Аналогично, когда мы рассматриваем шестой слой, мы эту вершину попытаемся добавить
десятый слой, может все, что может быть, выясним, что она уже была добавлена и так
далее.
То есть вот так выглядят все доказательства.
Понятно, да?
То есть как видите, мы знаем расстояние и находим правильный слой раньше, чем
мы до этого слоя добрались.
Поэтому получается, что этот алгоритм работает, и работает он за, получается, время О от
ВК плюс Е.
Причем самое страшное заключается в том, что есть вот такой ВК.
Более того, можно заметить, что на самом деле, если внимательно посмотреть на это
доказательство, то в принципе этот же алгоритм, ну почти этот же, на самом деле
работает, если я буду, у меня его работает не от одного ДК, а от нуля ДК.
Понимаете, да?
Ну доказательство поменяется только в том, что когда мы будем рассматривать, то
есть здесь будет подразумеваться, что вот этот форик будет работать до конца
массива при условии того, что конец массива может отдаляться.
Но это, конечно, определенная условность, то есть по-хорошему мне тут надо очередь
написать.
Ну смотри, ну просто вопрос, как этот фор развернется?
Я боюсь, что он развернется так, будут вычислены два итератора, и он будет этими
итераторами бежать, вот вычислить бедины на тот момент запуска этого фора.
А если ты будешь делать pushback, то как бы итератор не поменяется.
Ну да, ну да, то есть, конечно, можно написать очередь, можно здесь уже на этот раз прям
честно написать что-то вроде там int и равно нулю, и меньше там int, там wave.size.
Господи, прям какая-то румынская песня.
Ваи сатвейв, ваи сатвейв, точка сайс.
Ваи сатвейв, точка сайс, вот это вот, да.
Вот, это точка сайс, ваи сатвейв, да, кайф.
Господи, сколько народу по программированию поют, оказывается, да, как всегда.
Так, ладно, значит пишем int v равно wave сатвейв.
Так, ваи сатвейв, ваи сатвейв, вот, да, можно вот так написать, и в принципе на этот раз
вот получится хорошо без итераторов.
И тогда, ну здесь доказательства нужно подкрутить только в следующий момент,
что эта вершина попадет в слой до того, как мы прекратим обрабатывать этот слой.
То есть как бы если этой вершины не было до этой вершины в этом слой, значит она будет по pushback она и рассмотрена чуть позже.
Понятно, да.
То есть вот такой кайфец.
Вот, ну вот, то есть получается, что и 0k получается BFS, то есть такой волновой алгоритм можно написать.
Да, в чем это нот, как это выражает нот, к чему это приводит нас в этом месте?
Нет, ну не совсем так.
На самом деле есть вариант, там пишется 0k BFS, но это называется BFS на к очередях.
Не совсем, не совсем.
Но обычно, я не знаю, обычно такой код не пишется, обычно просто заметят следующее, что когда мы дошли до wave равно 57,
то заметим, что для нас актуальными являются только волны 57, 58, 59 и так далее для 57, плюс к, минус 1.
Ладно, плюс к.
Вот, то есть по факту имеет смысл хранить только вот эти вот к очереди и, собственно, их по циклу передавать.
Это называется BFS на к очередях.
Я, правда, не знаю как, но почему-то я нарядусь к этому, что в каких-нибудь у крышах иногда просто так и рассказывают.
Без может быть отсылки вот на это.
А так и рассказывают, да?
Чего?
Ну да, кто бы это мог быть, да.
А, ну кто-то был.
Нет, ну я не знаю, да, просто там в какой-нибудь зимней школе МФ3, да.
Ну просто это.
Чего?
Ну ЗОЖ.
ЗОЖ. Зимняя школа МФ3.
Не, просто есть зимняя олимпиадная школа, да.
Ну просто это такое вот олимпиадная лагерь.
Там есть, правда, есть отделение по информатике, по математике, по физике, по химии еще бывает.
И так далее.
То есть там, в принципе, да, тоже, то есть да, в принципе, вот.
То есть они, в принципе, да, существуют.
Там зимой и летом можно приезжать.
Там летом три смены, там, собственно, вообще.
Чего? В смысле нельзя?
А, ну, понятно, для школьников.
Но с тем же успехом можно сказать, что вам нельзя приезжать в ЛКШ.
Можно, как припыль.
Ну, в олимпиадную школу тоже можно попасть, как припыль, знаете.
Да.
А вы думаете, кто там преподает?
И откуда там почему-то рассказывают вот это в каком-нибудь ЗОЖе, да?
Ну, пора, ну, там, пора, потому что там, ну, я не знаю, то есть, ладно, кто там сейчас преподает, я не знаю.
Я как бы сейчас там не работаю.
Вот.
Но до какого-то момента там, как бы, вот, мои студенты быть и могли.
Вот.
Ну, значит, сейчас уже немножко другое.
Но ничего, значит, идем дальше.
Значит, это был вейс, это был кайф.
Значит, что у нас теперь?
Да, то есть можно писать BFS на к очередях, но, конечно, нас интересует под вид, когда у вас не 0k, а 0.1.
Потому что, на самом деле, если у вас k равно 1, и вам нужно писать 0.1 BFS, то на самом деле это приводит к простой модификации вот этого кода.
На самом деле, да.
Потому что оказывается, что мы должны уметь добавлять вершину в следующий слой, если ребро равно 1, или добавлять в тот же слой, если ребро равно 0.
Но в каждый момент времени у меня в очереди q есть какое-то окончание текущего слоя и начало следующего, правда?
Поэтому оказывается идея, а давайте просто заведем без того очереди DEC, и если 0, то добавлять в начало, а если и так, то добавлять в конец.
Приводит это к следующей экзотической реализации.
Ладно, не экзотической.
Вот.
То есть вот получается так.
Значит, пишется получается так.
DEC от int q, q.push от s, значит dist от s равно 0.
Вот.
Значит, и дальше.
Ну, как всегда, while.
Пока у нас q не empty.
Значит, поехали.
Значит, достаем v, отправляем эту v из очереди по указанному адресу.
И, соответственно, пишем for.
Значит, опять перебираем и убраем.
На этот раз вес нам важен.
Граф от v.
Значит, если оказалось, что dist от nv больше, чем dist от v, плюс w, то что мы делаем?
Ну, а первых пишем, что dist от nv равно dist от v, плюс w.
Значит, и дальше неожиданно говорим, что если оказалось, ну вот, то есть если w равно 1, то q.pushfront от nv.
lz q.pushback, а вот там pushfront.
Вот такая вот красота.
На этот раз важно заметить, что мы добавляем каждую вершину не более чем два раза.
Поэтому, как бы, если мы достанем два раза и два раза обработаем, ничего страшного не произойдет.
Вот.
Так что вот такая вот красивая реализация.
Это называется 01BFS.
Да.
Что?
Ага.
Да-да-да.
Эх, мечта-мечта, минус 1BFS, да.
Нет, ну да, минус, нет, ну, минус 1BFS, это че-то преодонсакарпа, конечно, да.
Да, чего?
Минус бесконечный, бесконечный BFS.
Бесконечный BFS.
Мечта-мечта, да.
Только, увы, так не получится.
Это называется BFS.
Да.
А вот он зачем нужен.
Вот.
Хорошо.
Значит идем дальше.
Идем дальше.
Значит, ну, смотрите, время, ну вот.
Ну, время, конечно, шло.
Но тут возникает естественный вопрос.
Нет, даже ничто делать, если k становится очень сильно большим.
Пока мы зададимся другим вопросом.
А что делать, если ребра бывают небольшими, но дробными?
И вот тут мне придется уже все-таки смотреть.
И теперь, значит, нулик-то мы и тут научились добавлять, если целые.
А теперь идея такая, что ребра у нас от одного до k.
Вот.
Но V на этот раз произвольные числа.
Действительно.
K?
Ну, допустим.
Допустим, k натуральная.
Ну, например, классика, это когда у нас ребра от одного до двух.
Так, вот тут возникает проблема, конечно.
Да, потому что раньше, потому что до сих пор у нас было,
что слой – это расстояние до вершины.
А слой номер корень из двух у нас такого слоя нет.
Но мы не можем завести массив, чтобы там был корень.
Мы можем, конечно, завести мапчик.
Но до этого мы доживем.
Потому что здесь есть два направления мысли.
На самом деле мы с обоими сейчас разберемся.
Ну зачем?
Не надо ничего округлять.
Все гораздо проще.
Нет.
Теперь у нас будет идея такая.
Номер слоя.
Значит, у меня номер слоя будет равно просто расстоянию до вершины.
То есть номер слоя давай, но округленное вниз.
То есть смотрите, слоев у нас все еще ВК.
Обратите внимание, тут у тебя нот.
Все еще ВК.
Вот.
И здесь тогда просто теперь придется написать.
Да, придется как-то это упихать.
Значит, придется написать, я зелененьким не пишу.
Floor.
Там Floor Adistotenv.
Вот.
Да-да-да, чтобы он еще и латих там парсил.
Действительно, вот эту скотчку можно занять на Floor.
Так что вот такая.
То есть смотрите, как-то не странно, то есть как вести дробный.
Я утверждаю, что для этого достаточно.
Ладно, недостаточно.
Так, вот смотрите.
Правда, тут возникает такая проблема, что вот этой проверки уже недостаточно.
Как недостаточно?
Автор, заветьте маленькую прятную вещь.
Теперь вершина может быть добавлена на самом деле в волну несколько раз.
Нет, смотрите, нет, фишка такая.
Теперь у нас может быть ситуация, когда у вас расстояние до вершины стало 3.57.
Вы добавили в третий слой.
А потом у нас оптимизация, и выяснилось, что оно теперь стало меньше, чем 3.49.
3.49.
Кстати, да.
Вот.
И выяснилось, что вершина может оказаться.
Поэтому...
Поэтому придется тут, конечно, написать...
Поэтому придется здесь написать все-таки какой-нибудь, ну я не знаю, user.
Ну самый тупой user, написать уже не парится.
В общем, обратите внимание, такой экзотический юзет получился, потому что как бы юзет это означает, что мы не то, чтобы добавили вершину в очередь, да, а в том, чтобы мы ее стали уже обрабатывать.
Вот.
Такая неожиданная красота получилась.
Ну теперь, как это ни странно, я утверждаю, что теперь, что если у нас веса от одного дака, то этот BFS найдет абсолютно корректное расстояние.
Даже не просто волды, а именно корректное расстояние.
Значит, эмулируем доказательства.
То же самое.
Значит, смотрите внимательно.
Смотрите внимательно.
Так, ладно, для простоты не буду тут два знака писать, да.
Ну давайте это упростим себе жизнь все-таки, а то тут да.
Вот.
Значит, смотрите, доказательства здесь будет такое.
То есть, да, вот мы знаем, тут кратчайшее расстояние так и будут.
Тут они будут 1.5, тут такой 4.2, тут 5.3, тут 8.7, тут 11.3.
Видно, да?
Теперь надо просто, то есть надо доказать то же самое, что вершина окажется с правильным расстоянием, в правильном слое, причем до того, как мы ее будем обрабатывать.
То есть, до того, как мы закончим это слое обрабатывать.
Причем, да, нет, пока не обязательно.
Нет, и потом это все равно не поможет.
В данном случае все гораздо проще.
Дело в том, что здесь мы начинаем пользоваться тем, обратите внимание, что у нас все веса не меньше единицы.
Это означает, что каждая вершина окажется с правильным расстоянием, когда мы будем рассматривать предыдущую вершину в предыдущих слоях.
То есть, сначала мы рассмотрим нулевой слой и найдем, что эта вершина 1.5.
И только после этого мы пойдем в слой 1 и будем обрабатывать эту, помимо всех прочих, и эту вершину тоже.
И в этот момент мы узнаем, что у этой вершины расстояние 4.2 и отправим ее в четверть слой, если она не окажется там раньше.
Возможно, с расстоянием 4.2, а может там 4.3.
Но обратите внимание, здесь доказательствами мы очень-очень жестко пользуемся тем, что веса ребер от одного.
Потому что, смотрите, насколько жестко, чтобы вы понимали, если я тут скажу, что, а давайте скажем, что ребра от нуля до ка, то этот алгоритм резко упадет.
Нет, там просто фишка будет такая.
То есть, смотрите, что произойдет, если я тут попытаюсь рассмотреть от нуля до ка?
Получится у меня так, допустим, 1.5, там 2.6, допустим, и ну я не знаю, ну вот, и какой-нибудь там 0.1.
Значит, то есть, да, тут как бы расстояние должно быть, тут 1.5, тут должно быть 4.1.
Так вот, фишка такая.
Вполне вероятно, что когда мы рассматривали s, вместо вот этого ребра мы рассмотрели сначала вот это ребро, у которого там было расстояние, допустим, ну я не знаю, значит, 1.2.
Тогда мы эту вершину добавили в слой номер один раньше, правда?
Потом стали ее рассматривать, и тут обнаружилось, что тут есть ребро веса 3.
И тогда обнаружилось следующее.
Ну вот, и тогда обнаружилось, что эту вершину мы добавили с расстоянием 4.2.
Видно, да?
Ну вот.
Ну вот, ну действительно, проблема?
Нет.
Потому что, ну вот, само в себе пока это не проблема, почему?
Потому что на самом деле тут…
то есть проблема на самом деле возникнет, то есть у этой вершины, допустим, 4.1 возникнет проблема, но проблема может нас настигнуть немножко в другом месте.
Ну вот так, давайте потом, в каком месте она нас может настигнуть?
Вот этой, да? Так, провели, и что?
Ну давайте, я даже 3.1 напишу. Ну и что?
Ну мы могли обработать эту вершину раньше, но мы обработаем ту, которая по идее должна быть раньше.
Да, вот теперь смотрите какая подлянка, что произойдет. Мы обработаем, ну понятно, то есть эти две вершины мы обработаем, но при этом если мы вот эту вершину обработаем раньше, то окажется, что мы сначала добавим вот эту вершину с расстоянием 4.3, да?
А потом вот эту вершину с расстоянием 4.1, и тогда вот эта вершина окажется с неправильным расстоянием, потому что вот мы через 4.1 ее еще не оптимизировали.
Сите, то есть у нас просто в явном виде есть контрпример.
Что если сначала пробежаться по слою и обновить расстояние слоя в слой, а потом пробежаться по слой и начать добавлять новый?
Ну я боюсь, тогда это начнет валиться, если у вас таких ребер цепочка.
Ну там автор Яны не запаску теста.
Ну конечно, но нет.
Это было очень странно, потому что тогда ты мог поделить все лица на лучего число, из АВ плюс Е, в аэропорту.
Да, кстати об этом.
А в чем проблема?
Нет, смотрите, проблема в том, что это все равно останется с нулем, то есть с нулем это не работает.
А так на самом деле поделить все веса на одну и ту же констант, то это вполне себе хак.
То есть на самом деле у Капилевича есть такая классическая, красивая, учебная задача.
То есть найдите расстояние от вершины до всех остальных, все веса от миллиарда до двух миллиардов.
То есть выясняется, что на самом деле в этой дыше не нужно писать никаких там страшных дэкстров с какими-то там страшными кучами.
Нет, сейчас погодите, дойдем.
Вы пока не знаете, что такое дэкстра.
Я вам так скажу, мы ее выводим на самом деле.
Ладно, его.
Да, дэкстра это он.
Помните, Эдзгер Вейн и дэкстра его зовут.
Да, он к сожалению умер там в 2000 каком-то там году.
Но действительно, оказывается, если у нас ребра от А до 2А, то мы в принципе можем просто номер слоя сказать, что флора дистат В делит на А.
Это называется, то есть это известно как А2Аbfs.
Но на самом деле вы можете заметить, что то, что у нас там имеет место, это на самом деле называется, то есть близко скорее к тому, что называется АКАbfs.
То есть видите, оказывается, что если все веса именно положительные, то вам не важно, насколько большие ребра, важно, как самое большое относится к самому маленькому.
Но вопрос насколько положительно, прям очень положительно или не очень.
Вот, то есть вот оказывается, а так оказывается, если они отличаются не более чем в 5 раз, то в принципе вы прям написали BFS и возрадовались.
И асимптотика ВК плюс Е.
Ну для мелких К это вообще кайф.
Вот, или если К не превосходит там, как мы уже выясняли с вами, Е поделить на В, так вообще тоже хорошо.
Но теперь возникает следующий вопрос, идем дальше.
Пока не вводим нуля, а вместо этого говорим, а что делать, если К прям большое-большое?
То есть К начинает быть вот, вот.
Да, ВНАК все равно уже реально многовато, хочется побыстрее.
Побыстрее.
Нет, ну теперь замечаем следующее, где в этой асимптотике нам требуется ВК?
Да, то есть обратите внимание, асимптотику ВК обеспечивает только вот эта строчка, ну и вот это все.
Все остальное, все остальные нетривиальные действия делаются за Е.
Обратите внимание.
Поэтому, если бы у нас была какая-нибудь там великая структура данных, такая великая, которая умела бы нам,
которая бы хранила вообще какие-то все возможные слои, но не пустые, и умела бы нам говорить, а кто сейчас ближайший не пустой,
то у нас это все было бы быстрее.
Что это за слой, что могла бы быть за структура?
Да, вот опять мы не знаем, что такое дерево на МДБОСа, да.
Кошмар, что многие, сколько уже поколений студентов не знают, что такое дерево на МДБОСа вообще, да.
Ну просто чисто вот, нет, у меня был один из вариантов, что сегодня тоже имеет смысл и эту дырочку залатать,
но с другой стороны, что-то сегодня хорошо пошло, сколько там времени-то вообще.
Хотя, может, мы сегодня и обсудим, кстати.
Да, погодите, то там, слушай, там достроено, там знаешь, сколько там до сутки с того дерева надо дожить,
там придется префикс функция, z функция, там вот это все.
Так это все частный случай.
Да, это частный случай.
Да, но это частный случай аха-карасика, а не дерева лайнера.
Точно.
Аха-карасик.
Алгоритм аха-карасик.
Так, значит, сразу алгоритм аха-карасик.
Аха-карасик.
Ну, во-первых, корасик, а во-вторых, она маркерит.
Поэтому ее фамилия не склоняется.
А вот этого я, кстати, достоверно не скажу.
Может быть.
Все, что я знаю, это то, что пишется ее фамилия вот так.
Корасик вот так.
Да, нет.
Нет, он аха, мы с ним уже сталкивались, кстати.
Когда упоминали там книжку про компиляторы?
Что?
Да, без к.
Да, да, да.
Да, без г, просто вау.
Да, да, да, мы помним.
Да, женские фамилии не склоняются.
Да, у нас с вами, на самом деле, у нас есть три очаровательные девушки.
У нас с вами участвуют в алгоритмах.
Правда, не с одной из них.
С одной из них мы уже даже столкнулись.
Правда, мы ее не особо упоминали.
Мы ей столкнулись, когда упоминали дикартовые деревья.
Дикарта?
Нет, дикарта он РНФ все-таки, нет.
Но дикартовые деревья изобрел, как-то часто бывает, не дикарта.
Ну, FFT тоже не фурьер изобрел, да?
Вот, то есть нет, как бы нет.
Нет, дикартовые деревья, ну, из-за интерпретации, что давайте, то есть как бы X это ключ, Y это приоритет, давайте нарисуем, получится красиво, да?
Ну, вот, то есть эта интерпретация, это тоже там конкретные там фамилии, то есть у меня ассоциируется за фамилиями Орагон Зидель на самом деле.
Там вот что-то такое, то есть фамилии вот такие Орагон и Зидель.
Ну, вот так вот, насколько я помню, Орагон это Сесилия.
Вот.
Вот.
Нет, Зидель это, по-моему, он все-таки, да.
Вот.
Значит, помимо этого у нас еще ожидается алгоритм Ахакарасик.
И еще в качестве анонсов.
И еще в качестве анонсов есть алгоритм Штор Варнера.
Да, Штор это Матильда.
Вот.
Это алгоритм о поиске глобального минимального разреза.
Это мы внутри потоков будем изучать.
Вот.
Да, то есть А4 есть такой тоже очаровательный алгоритм, как сама Матильда, так что хорошо.
Максимальный разрез умеют искать?
Максимальный?
Почему-то не одно и то же?
Да.
Почему-то не одно и то же?
Не, не одно.
Там просто там будем пользоваться тем, что веса не отрицательные, поэтому не получится.
Кстати, хороший вопрос, я не знаю.
Вот.
Так вот.
Ладно.
Это мы тут такое лирическое отступление, да.
Как говорится, аниленод.
Анилегкая роль девушек в алгоритмах, да.
Вот.
Вот.
Итак.
Хотя ладно, что тут, девушкам нечего жаловаться.
В конце концов, у нас, как известно, первая программистка в истории женщина была, помните, да?
Ну вот.
Вот это вот все, да.
То есть даже язык программирования в честь ее назвали, да.
То есть по нему это даже страшный анекдот, как девушка программист читает книжку.
Там ходит бабушка, смотрит на нее, там крестится испуганного, и выходит на следующие остановки.
Нет, а все мирно.
Девушка просто читала книжку.
Да, да.
Нет, ну я не знаю, как звали девушку, но неважно.
Эта история умалчивая, да это и неважно.
Да.
Вполне верно, что девушка даже не вчера там не в готическом была.
Вот.
Да, да, да, мало ли.
Вот.
Вот.
Так вот.
Нет, ну там всякое бывает, знаете, вы там аккуратнее с книжками, знаете.
Вот знаете, есть такая книжка, знаете, которая называется так.
Как же называется эта книга?
Да, как несложно догадаться, книжка про логические парадоксы.
Вот, то есть очень рекомендую на самом деле, вот просто вот прям реклама просто Ричард Смолли, там Смоллиан.
Как же называется эта книга?
Потому что вот, ребят, не пожалейте, реально.
Просто очарование абсолютное на самом деле.
Вот.
Да.
Да, вот прям вот так название звучит.
Ну вот, ну она и на русском языке есть.
Ну да, да, да, да.
Ой, знаем это пойду.
А, спасибо.
Вот.
Да, так, если возвращаться к алгоритмам, да.
Вот, да, просто рекомендую, да.
То есть как это говорят, что дух книги вообще, то есть парадоксы, да.
В общем, там парадоксы возникают настолько, что там говорят, по правтору говорят так, что, как говорится, профессор сейчас два счета докажет вам, что либо у вас не существует, либо его не существует.
Но кого конкретно не существует, ему неизвестно.
Ну вот.
Ну в общем, почитайте, не пожалейте.
На самом деле, просто очарование там просто очень смешно, действительно.
Вот.
Так это просто фишка.
Я как-то ехал в метро, читал эту книгу.
А потом смотрю, что-то там напротив дети какие-то, что-то там смотрят, что-то смотрят на обложку и что-то ржут.
Да.
Вот, да.
Что-то вспомнилось, да.
Вот.
Так, значит, соответственно.
Так, ладно, давайте, чтобы было понятно.
Вот.
А, кстати, на всех своих поднимите руки, кто столкнулся с этой книжкой.
Нет, вот с этой.
Да ладно, как вы сохранились, господи.
Я слышал.
Господи, как это, вот, 12 стульев даже читали, а это не читали, господи, как это, да.
Ой.
Ну ладно, рекомендую столкнуться просто, да, получите удовольствие.
Да.
Вот.
Ладно, значит, смотрите, так вернемся к...
Да.
Вот.
О чем...
Да, мы писали один КБФ с дробными весами.
Теперь неожиданно выяснилось, что карта отправилась в бесконечность.
Мы неожиданно обнаружили, что нам достаточно тем или иным способом там, скажем, хранить только не пусто.
Ну, например.
Вот самый тупой способ.
Просто вести мапочку.
Да, пока пустой.
Ну вот.
Ой, кстати, даже эти строчки сохранились, как здорово.
Так, только теперь.
Так, теперь, значит, вот эти вот строчки мы, конечно, тут сейчас немножко...
Значит, поперек.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Значит, попилим.
Так.
Так, ладно, черт с ним.
Так.
Ну, может, я просто код не буду дописывать, там очевидные вещи.
И получится так.
While не мап...
Значит, этот...
Ладно, не мап.
Waves.empty.
Попилим.
Так.
А вот тут оказывается очень приятная вещь.
Vector int ampersand.
wave
равно
звездочка waves
точка begin.
Да.
Как приятно.
Да, ampersand.
Ну что, второй раз не берете, не искать.
Так в мапе так...
Что такое waves?
Waves это теперь моп.
А, в этом плане.
Да, да, да, да.
Вот вы о чем.
Пожалуйста, пожалуйста.
Что такое waves.blog?
Ну да, то есть вместо того, чтобы прибираться по всем слоям, я буду просто искать их.
Я буду просто находить...
А какой там сейчас минимальный не пустой слой?
Ну и что?
А если его разыменовать, то что будет?
Ой.
Ой.
Господи.
Как говорится, да.
А еще говорят, что я занадобная.
Да?
Вот.
Хотя нет, я в этом месте тоже говорю, это моя школа.
Вот.
Да.
Ну собственно, да ладно, я предупреждал.
Да, правильно, молодцы.
Так.
Чего?
У Вайла не закрытая скобка.
А я еще код не дописал.
Почему-то в комментарии о скобочках написано.
Это не относится к коду.
Это над кодом написано.
Да, давайте еще определить, что там между строчек написано.
Да, еще там.
Ладно, значит хорошо.
Так, ну смотрите, честно перебираем слой.
Ну ладно, на всякий случай, если у вас там все веса целые,
но бывают нули, переберем специально для вас.
Там size t и равно нулю.
И меньше wave.size.
Плюс плюс и.
И получается пишем int v равно wave it.
Ну и дальше.
Ну фор понятно, как всегда.
Вn, v, w, e, graph.begin.
Граф от v точнее.
Ну и дальше, если там.
Так, во-первых, нет.
Да.
Use it.
Так, ладно.
В общем, короче так, дальше тут надо написать какой-нибудь там if,
use it от v.
И дальше абсолютно стандартную блаблаблажку написать.
В общем, я даже заворачиваться не буду.
Потому что дальше там код прям идентичный.
Потому что, что приятно, если волны нет, а ничего страшного, мы ее заведем.
Единственная, конечно, мелкая проблема, за сколько это будет работать.
Ну, на самом, так, единственное только, а сейчас оговорка, знаете какая мелкая оговорка, оговорка, оговорка, знаете какая.
Надо в конце написать waves.erase.
Ну да, erase притератору, да.
Как-то C++ за первый семестер сдал.
То есть я на экзамен не пришел, да, ну ладно.
А у вас еще не было экзаменов.
Господи, я просто люблю на экзамене про это спрашивать.
Ну и про это, ну да.
Ну какие методы у мапа там всякое вот это все.
Не, на экзамене по C++ я имею в виду, конечно.
Ну у нас не спрашивают, нас просят реализовать.
А, ну вот, ну тогда странно, если у вас попросили реализовать, у вас просили реализовать мапы и не реализовывали erase, и т.д., да, у вас?
А, ну, видимо, видимо еще попросят.
Ну вот, значит, будьте готовы, там.
Да, чего?
Ну конечно так, чем писать сет, может сразу мап-то, вот.
А, тем более, да.
Ну не важно, в общем, на самом деле это, ну в любом случае это не важно.
Ну не важно, в общем, на самом деле это, ну в любом случае, кроме шуток, имеется в виду, действительно, что удалять по итератору можно, это очень удобно, потому что искать не надо элемент.
То есть очень удобно, вы нашли элемент, почесали реп, решили его удалить, но если есть на него итератор, так по нему и удаляйте.
Это вам оптимизирует константу.
Так что полезно.
Вот.
Значит, к чему это нас приводит?
Какое-то дает нам 8.
Вот.
Но я боюсь хуже.
Пока это у нас дает нам асимптотику.
Какую-то.
Да, она нам дает асимптотику е лог, я бы сказал даже е.
Так, ну да, если вы заморочитесь в начале и как бы удалите кратные ребра за е плюс в, то да.
Нет, это если вы заморочитесь и уберете кратные ребра, тогда да, лог е и лог в, в это с точностью до константа 2 одно и то же, да, согласен.
Вот.
На этот раз нет.
Нет.
А, так еще и так.
Вы сказали минимальный, да, минимально ограничен.
Да, минимальный от единицы, чтобы веса вылазили.
Влазили, да.
Ну, можно и в лонг-лонг, неважно.
То есть теперь получается, да, мы изобрели алгоритм за такое е лог е.
Вот.
Более того, на самом деле, ну вот.
То есть, в принципе, вот е лог е.
Можно даже подумать, как его оптимизировать.
Нет, но я вам, ну вот.
Но на самом деле так скажу.
Можно делать за е лог е, хотя на самом деле я вам так скажу.
На самом деле это работает даже более, можно еще точнее оценку сказать.
За е лог к.
Максимальный вон тот вес.
Ну, потому что обратите внимание.
На самом деле у вас, когда вы обрабатываете очередную волну,
у вас дальше там лежит не более чем к следующих очередей.
То есть у вас размер мапа каждый раз не более чем к.
Поэтому получается е лог к.
Вот.
Единственное только, ну вот.
Ну теперь вот, единственное, теперь давайте подумаем.
Сейчас уже не будем переписывать код.
Теперь возникает вопрос.
Да, можно ли это допилить?
Так.
Как нам помогает Фибоначчева куча?
О, он сферичный.
Так.
Ооо.
Так, хорошо.
Давайте введем дичную кучу.
Там будет е лог к.
По основанию д.
Так, сейчас, погодите, погодите, погодите.
Так, давайте.
Так, смотрите, давайте думать.
Так, для того, чтобы ввести хоть какую-нибудь кучу любую другую структуру данных,
нам нужно подумать вот о чем.
То есть, ладно.
Сколько у нас в эту кучу инсортов?
Ну, самое главное.
Сколько у нас экстракт минов?
Так.
Так, так, так, так, что у нас еще?
И сколько у нас там всяких этих дикриски, там каких-нибудь дикрискиев?
Ну, как можно сделать дикриски?
Ну, самое тупое, что можно было, ну вот.
Сейчас, но это как бы надо вот.
Хотя нет, дикриски тут нам, хотя в такой реализации нам дикриски даже не сильно поможет.
А как там поможет, а как там поможет дикриски здесь?
Не, погоди, погоди.
У нас сейчас не так работает.
У нас вещь, у нас для каждого слоя в явном виде вершины хранятся.
Поэтому, когда у вершины меняет, то есть, смотрите, тут уже надо просто подход менять тогда.
Потому что когда мы сейчас, когда у нас там слой 179 меняется на слой 57,
мы вершину в явном виде перезапихиваем в слой 57, возможно, создавая этот слой.
Поэтому, на самом деле дикриски нам, поэтому обидно, но дикриски нам в данном случае никак не помогают.
Хотя это как бы, хотя это может быть следующая идея.
Вот, а это на самом деле уже следующая идея.
Потому что следующая оптимизация говорит так.
Нет, точнее так, это уже даже не оптимизация, потому что в принципе и так можно,
пока можно написать е-лог-к, можно вверх-вверх,
если это число целое, можно ввести дерево НМД Боаса,
потому что дерево НМД Боаса, все вот эти операции для целых чисел будет за лог-лог-к делать.
Это я вам так, анонс на будущее.
Ну памяти будет, ну, ой, ну там хэш-мапы, да, вот.
Ну память от ка, в общем-то, ну хотя да, не очень.
Да, нет, нет, если в ка было миллион, то в принципе можно ввести дерево НМД Боаса,
да, нет, нет, если в ка было миллион, то в принципе можно, кстати, самое смешное это.
Не, а в чем проблема? Там, кстати, ну да, но там, правда, вместо этого лог-лог-к начинаешь думать,
а не зайдет ли там хэгуша и корневуха, вот.
Нет, ну а что, да?
Нет, кстати, вполне вероятно, потому что когда у вас там много-много вставок,
допустим, а у вас там много-много вставок и не сильно много удалений, да,
то как бы там, тем более, которые еще идут последовательно, то в общем-то, корневуха вот так начинает работать.
Вот, на самом деле-то, вот.
Нет, хотя где-то корневуха в таком виде, ну ладно, в общем, лог-лог-к поверим пока.
Но можно еще дальше думать, то есть если ка,
ну потому что на самом деле следующая идея такая, что делать, если у нас ребра от одного до ка,
но они бывают еще и дробные?
Но если они бывают дробные, то выясняется на самом деле такой неожиданный чит.
Чит заключается в том, что, а кто сказал, особенно в свете мапа, что номера слоев обязаны быть целыми?
Именно.
То есть на этот раз слой номер корень из двух начинает работать.
То есть слой номер корень из двух.
То есть, смотри, то есть работает абсолютно так же, ну в предположении,
ну с твой оговор, конечно, мы предполагаем, что мы делаем вычисление абсолютно точно.
Вот, то есть вместо, ну вместо long double, поэтому обычно будем там,
будем хранить вот это вот a плюс b корней из двух, или там просто рациональные числа там.
Вот.
Ну вот это вот все, да, rational, да.
То есть все, что мы делаем, мы делаем абсолютно точно.
Это вот все, да, rational, да.
То есть все, что угодно.
И тогда, ну вот, и неожиданно оказывается, что все это начинает работать.
Причем на этот раз заметим, что номер слоя-то у нас все тот же, да.
То есть номер слоя теперь опять совпадает с расстоянием, да.
Поэтому теперь можно по индукции доказывать, что действительно каждая вершина будет обработана в своем слое,
причем не позже, чем мы закончили обрабатывать этот слой.
Понимаете, да?
То есть на этот раз уже да.
Причем более того, обратите внимание, теперь снимается ограничение, что веса от единицы.
Потому что если у меня тут какой-нибудь там 0.1, то на этот раз никаких там, никаких проблем нет.
Потому что, ну, здесь никаких проблем, потому что у нас слой 4.2, слой 4.3, это два разных слоя, да.
А, в-треть, даже если я тут случайно еще нарисую ребро на этот раз веса 0,
то все равно ничего страшного, потому что эту вершину мы обработаем, я утверждаю, в слое 4.3,
потому что мы дойдем до слоя 4.3 и обработаем это ребро и попытаемся запихнем эту вершину в слое 4.3.
Ну-ка давайте, то есть, ну-ка давайте-ка в итоге посмотрим.
Так, ну-ка давайте теперь посмотрим, что же у нас получилось.
Ну, на самом деле, да, можно не тянуть интригу.
Да, то есть, нет, давайте потянем пока интригу, чтобы явно уж видно.
Ну вот, то есть, теперь вместо того, то есть мы не храним слои, то есть у нас подход теперь такой.
Такие так, слои мы могли бы хранить и было бы тоже елок что-нибудь, да.
Но теперь у нас идея такая, а давайте не хранить слои, а просто храним вершины
и для каждой вершины храним номер слоя, ну то есть расстояние, да,
и в каждый момент времени из всех вершин, которые мы еще не обработали, выбираем минимальное расстояние.
Да, только идея, ну не совсем так, в BFS мы перебирали слои в порядке возрастания.
Да, то сейчас мы такого не делаем, но сейчас мы просто выбираем минимальный слой.
Нет, разница в том, что тут мы как бы и прям чисто слои хранили, а теперь мы этого делать не будем.
То есть у нас, то есть базовая версия, которую, кстати, там многие пишут, то что, да, то есть это будет такая,
то есть сет от pair, от, значит, допустим LD и int.
То есть храним в сете пары расстояния до вершины, сама вершина. Понятно, да?
Ну вот, то есть изначально, ну вот, ну и как всегда, вектор LD, d от, соответственно, n и int.
Ну как всегда, d от s равно 0, значит s равно, там, 0.
Вот. Что, думаете, он это не съест?
А, нет, ну, да, но это с большой, конечно, да. Хорошо.
Ну и дальше у нас там что начинается? Там vile-nea-s.empty.
Значит, что у нас тогда получается?
Значит, так, как-то там, tie от, ну, допустим, d, v.
А какие? Да? Окей.
Ну, допустим, d, v.
А какие? Да? Окей.
Так, хорошо, tie от dv равно звездочка s.bg.
Ну, это я хочу просто пару сразу расписать.
Ну, я могу тут пару написать, потом сказать d равно там p.first, вот это все.
Кстати, как бы он, может, он это не скомпилит, потому что выяснил штамп cost.
Ну, хорошо.
Так, хорошо. Так, во-первых, да, давайте, значит, pay raise-ом сразу бегим, да, вот.
Значит, поехали, как всегда, v, n, v, w, 2.
Твой граф от v, как уже многострадально было, да.
И как выясняется, что если d от n, v оказался больше, чем d.
Так, ладно, во-первых, тут dist и тут dist.
И тут dist, да, что ж такое?
Так, dist от n, v больше, чем d, то что?
Точно?
Вот, да, плюс v, да, конечно.
То, значит, тогда поехали.
Так, смотрите, нет, здесь не надо торопиться, то есть как бы, так говорят шахматы, тут надо не перепутать порядок ходов.
Вот.
А что не так?
О, вот такой вот красота.
Вот.
Так что вот такой вот неожиданный алгоритм, ну, по крайней мере, вариации сетом за e log v у нас получился.
Да, это буквально e log v.
Да, обычно.
Но этот алгоритм, обычный называется алгоритм, алгоритм дейкстрей с чем-нибудь.
Да, это да.
Но тут, конечно, подлянка, да, потому что на самом деле, да, тут я встретил еще тут подлянку, потому что почему-то, как выясняется, многие думают, что в алгоритм дейкстрей сет или куча зашита.
Так вот, на самом деле это не так.
Ну, хотя ладно, тут, конечно, можно как думать, потому что, судя по всему, в его, в оригинальной статье дейкстре, в общем-то, одновременно была версия алгоритма без кучи и алгоритма с кучей.
Идейно куча там зашита.
Нет, куча там, нет, идейно куча там не зашита.
Куча там зашита лучше, чем...
Нет, я бы, я бы, я предпочитаю мыслить так.
Идейно там никакая куча не зашита вообще.
Идея на алгоритм дейкстре заключается в том, что мы на каждом шаге можем взять вершину, до которой расстояние сейчас вот такое.
Там минимально возможно.
Минимально возможно, да.
Вот, то есть это, на самом деле, то есть как бы куча, это уже, наоборот, как это, как возможно этот минимум искать.
Вот, потому что, да.
Да, потому что, правильно, потому что есть дейкстра на куче.
Да.
Да.
Но успею wahrscheinlich.
То есть, честно скажу, то есть обычно я считаю алгоритм дейкстре то, что работает за E плюс V квадрат.
И Дейкстрра с длинными весами?
Вот.
Ну я не знаю, мне еще исторически, потому что, честно говоря, у меня прошел нот.
Потому что когда я впервые изучал уритм дейкстре, вот честно его рассказали просто стандартным образом.
То есть, вот сделаем...
То есть, сделаем, то есть, вот так вот будем перебирать все вершины и честно релаксировать.
Алгоритм будет работать за E plus V квадрат.
Доказательства там просто пишем доказательства. Думаю, как и вам в свое время рассказывали.
Но правда заметим, что сегодня нам это доказательство даже можно особо не эмулировать,
потому что из всего вышесказанного доказательства следует автоматически.
У нас просто технология, что мы себе вообразим, что мы идем по слоям, и на самом деле получается так.
Вот, просто аккуратненько докажем, что вот хорошо.
Хотя то доказательство, как мы, видимо, в какой-то момент узнаем, то доказательство тоже сработает,
потому что мы там можем подумать, а куда эту дэкстру можно вообще обобщить.
Впрочем, посмотрим.
Но пока же скажем, что вот да, есть, но тут полезно помнить, особенно в свете этого алгоритма,
что вот есть алгоритм за e плюс f квадрат, который будет минимум искать в тупую.
Как мы уже обсуждали с примом, этот алгоритм может обыграть вот этот алгоритм, если у вас граф полный.
Понимаете, да, потому что v квадрат log v и v квадрат тогда тут будет.
Ну, конечно, в классических речениях, когда у вас там 100 тысяч вершин, 200 тысяч ребер, конечно же, это лучше.
Но здесь уже и начинается, потому что вместо этого сета можно было бы сделать какую-нибудь кучу,
причем кучу, которая умеет делать хорошо дикориски.
Потому что по факту, если вы тут хорошо делаете дикориски,
то тогда на самом деле можно реализовать алгоритм дэкстры за e плюс v лог v.
И получается вообще хорошо.
Вот, понимаете, да?
Да, в общем, получается вот такая e плюс v лог v.
Получается, да, это симптосика как бы убивает и это, и это.
Другой вопрос, что вам придется реализовать кучу фибоначи?
Нет.
Тут называется, ну, если мы верим, что где-то в 17, в каких-то в гну, в 17 стандарте куча фибоначи есть,
ладно, не в стандарте, а просто в компиляторе.
Я говорю, кто-то из предыдущего поколения, у меня там студентов, у меня там куча фибоначи в каком-то гнушном компиляторе находил.
Ну вот.
Нет, а что такое?
Ну почему бы?
Не, ну как-то добрые люди добавили.
Не, ну как бы в конце концов, вы же пользуетесь 128, хотя его в стандарте тоже нету.
Ну вот.
Какие компиляторы?
Ну ждем, да.
Ну это да, тогда появится, да, тогда появятся задачи на 200, да, на 256, естественным образом.
Но это уже совсем, но это другая история.
Вот, так что вот таким образом получается.
То есть как видим, что такое алгоритм Д-экстра, но это просто БФС на бесконечном количестве очередей.
Да, как мы, собственно, да, можно так, так лекцию пафосной назвать, да.
Д-экстра как бы БФС на бесконечном, да.
Вот.
Так что получается, да, то есть вот так вот неожиданно нот неожиданно вывели.
Так, есть ли тут какие-то вопросы?
Ага, ну в принципе на самом деле можно тогда так, но можно видимо в этой точке и второй перерыв устроить.
А, стоп, или уже не надо, да.
А, 40 минут, да.
Боже, ну как показала практика прошлого раза, можем же и не уйти, да.
Ну ладно, значит, смотрите.
Нет, ну на самом деле да, так что тогда.
Нет, слушайте, как все долго рассказывается, потому что я думал, что это вообще все за мгновенный, придется сегодня потоки рассказывать.
За 20 минут какие потоки, нет.
Нет, ну смотрите, к этой штуке, как вы смотрите, тут про Д-экстра кое-что еще надо рассказать.
Вот, а во-вторых, еще как бы придется как минимум хотя бы упомянуть Флойда Форда Белмана еще.
А, ну и конечно его величество Джонсона.
Да, да.
Да, он возникает не в минкосте, если что, да.
Вот так вот, да.
Ну а что вы думали, что мы сейчас неожиданно минкост о чем изучать, да?
Нет, нет, на самом деле да.
Нет, ну просто полезно будет знать, но до этого мы доживем.
Но сначала, ладно, мы не будем сейчас переходить, прежде чем добавлять отрицательные ребра,
про Д-экстру мы еще чуть-чуть поговорим.
Смотрите, сейчас мы попробуем алгоритм Т-экстры обобщить, чтоб понять вообще, а куда он еще применим.
Ну, просто в чем идея?
Ну, потому что дело в том, что на самом деле иногда вес пути, то есть не обязательно,
бывает, что вес пути это тупо сумма весов ребра.
Ну, на самом деле бывает, бывает вес пути это максимум из ребер на пути.
Или минимум из ребер на пути.
Или сумма двух минимумов.
Или сумма двух максимумов.
Да там еще отдельная песня, а что такое путь вообще?
Потому что, что такое путь, как мы вообще ребра делаем?
То есть, нет, или может вообще, или есть же вообще классическая задача, я думаю,
многие из вас видели автобусы.
То есть, знаменитые задачи, которые дают просто второй в контесте на Д-экстру, когда вы ее изучаете.
Нет?
Нет, да ладно.
Ну, смотрите, классика жанра.
Значит, вам нужно доехать из города С в город Т.
Вы знаете, что у вас есть автобусы.
Каждый автобус совершает один рейс из пункта У в пункт В.
Причем вам известно, что он выезжает из города У во время Т.И.Т.
И приезжает в город В во время...
Нет.
Ну, Т-штрих, давайте, И.Т., неважно.
Ну, может, любую другую пупу подставьте, неважно.
Ну, так, короче, времена заданы, когда он выезжает, когда он приезжает.
Вы знаете, что вы можете пересесть из автобуса в автобус, если вы находитесь в одном городе,
и у вас там на пересадку есть, ну, допустим, минута.
Хотя бы.
И теперь задача.
Можете ли вы доехать до города Т?
Если да, насколько рано вы можете туда доехать?
Ну, конечно, я говорю.
Обычно эту задачу...
То есть, обычно, когда вы изучаете алгоритм Д-экстра,
то в учебном контесте задача идет едва ли не второй.
Да, при первой задаче напишите, собственно, Д-экстра.
И, в общем-то, ничего.
Удивительно.
Потому что, по-хорошему говоря,
время у нас движется в одну сторону.
Да, оно у нас линейно движется в одну сторону.
Слава богу, мы на том факультете, который глубокую релитибическую физику не изучает.
Поэтому у нас время течет в одну сторону.
И это дает нам возможность тоже ввести абсолютно те же самые, в принципе, слои.
Логично, да?
То есть, на самом деле, ввести абсолютно те же самые слои.
То есть, только слои у нас теперь будут просто конкретные отсечки времени.
И написать, по сути, абсолютно того же самого Д-экстра.
Да, можно это писать так.
Но на самом деле...
А можно даже себе воображать эти слои.
Но если мы хотим там себе пытаться понимать, когда Д-экстра работает, когда нет,
можно попытаться даже формальные требования себе ввести.
То есть, мы хотим сказать, что такое W-атро.
То есть, допустим, пусть РО это путь какой-то.
И вот W-атро это какой-то вот функционал.
Вот.
И нам на этот функционал должны быть выполнены какие-то условия.
Вот теперь давайте думать, какие условия надо выполнить на этот функционал,
чтобы алгоритм Д-экстра работал?
Наверное, неплохо бы ассоциативность.
Вот.
То есть, то, что...
Ассоциативность?
Нет, даже не обязательно, на самом деле.
Что функционал-приписок меньше, чем функционал.
Да, ну во-первых, да.
Нет, смотрите, какие у нас требования на самом деле могут быть?
Какими требования пользуются?
Ну во-первых, чтобы вот эти слои у нас вообще шли слева направо.
Аккуратно.
Мы должны говорить следующее.
То есть в доказательстве мы жестко пользовались,
на самом деле двумя вещами мы пользовались не явно.
Ну первое очевидное, что когда вы идете по пути,
да, и насчитываете расстояние,
то у вас оказывается, что как бы функционал вот этого пути
должен быть больше функционала вот этого пути.
Ну не меньше.
То есть в переводе говоря я напишу это условие такое первое.
То есть для любой,
то есть я пишу так,
что w от ro плюс ребрышка,
ну если я в пути прицепил ребро,
должно быть больше либо равно,
чем если я его не прицепил.
Ну то есть картинка такая.
Вот.
Вот.
То есть вот это для нас прямо необходимо.
Но достаточно ли?
А вот выясняется, что нет.
Выясняется, что оказывается,
мы не явно пользовались еще одной порлой штукой.
Я нам...
Что?
Не.
Не, ну это понятно.
Это можно сразу сказать,
что w каждому ro составляет элемент из линейного порядочного множества.
Это все понятно.
Не, мы пользовались еще одной порлой штукой.
Может быть сейчас даже не видна,
но это для нас совсем просто фундамент.
Мы пользовались такой порлой штукой,
что если вот это кратчайший путь,
то и все префиксы являются кратчайшим путем.
Нет.
Да нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Да нет.
Нет.
Вот например ситуация.
Если у вас функционал,
это сумма двух максимумов.
Хотя нет,
сумма двух максимумов.
Сейчас нет,
сумма двух максимумов.
Да, если сумма двух максимумов,
то у вас может быть какой-нибудь путь
в 10 в 9-й 1,
а тут будет
допустим 10 в 9-й пополам,
10 в 9-й пополам.
Да.
Тогда у нас кратчайший путь какой?
Вот такой, 10 в 9-й, 10 в 9-й.
Но если вы прицепите сюда
ребро 5,
то выясняется, что вот так ходить было не выгодно.
Потому что этот путь
как бы длиннее,
но если к нему прицепить так,
то вот этот путь начинает обгонять вот этот.
Нет.
Просто тут
два максимума,
хотя
пока ничего не поменял.
Хорошо, давайте подгоним,
чтобы поменялось что-то.
Так.
Сейчас скажем, скажем, скажем.
Скажем, скажем, скажем.
Так, хорошо, тут 11,
а тут минус 10.
Но почему? Здесь два максимума
дадут 10 в 9-й плюс 1,
а тут будут просто 10 в 9-й.
А здесь
кратчайший путь был вот этот.
Нет, смотрите, теперь кратчайший путь
вот этот.
Вот. Но
вот длина вот этого пути 10 в 9-й
плюс 1.
Да. А тут
10 в 9-й.
Да, все докрутили.
То есть не так очевидно.
Хотя
стоп, стоп, стоп.
Хотя с другой стороны это пример не очень интересен,
потому что, а нет,
хотя нет. Да, этому он удовлетворяет,
да.
Так что получается, видите,
это неожиданная подлянка.
Если бы вы писали стандартное доказательство алгоритма
Dx, вы бы это даже в явном виде увидели.
Вот.
Но вот.
Мы это условие
нам придется записать в следующем виде.
То есть
если у нас
оказалось W
допустим, у нас есть два пути
вершины, там S, вершина В.
Один называется Ро,
а другой называется Ро штрих.
Если оказывается, что
и у нас должно быть верно, что если
путь от Ро меньше либо равен,
чем
Ро штрих, то из этого
следует, что если прицепить вот это ребро,
то это соотношение
должно сохраниться.
Ну,
если они равны,
то как бы это будет верно в обе стороны.
Ну скажи так, равенство нас устроит,
в принципе.
Ну да.
Нет, ну на самом деле
я утверждаю, скажем так, смотрите,
проверить можно так, смотрите,
можно просто сейчас попытаться
проимулировать доказательства,
рассмотрим вот этот путь.
Теперь утверждение такое,
что мы как-то
непрерывно перебираем все
эти слои.
Правда, нам тут приходится интуитивно
предполагать, что в этом линейном порядке
множестве есть, то есть эти слои
непрерывным образом можно проверять.
Это не очень очевидно, потому что
у нас не обязательно действительные числа.
Ну я не знаю, может, конечно,
там как бы любое линейное
упорядоченное множество
можно...
Так, спасибо.
Нет.
Ага.
О господи,
так это что-то уже куда-то...
Нет, ладно, нет,
что-то надо аккуратно сказать.
Нет, можно, конечно, заметить,
что мы здесь рассматриваем...
Можно, конечно, сказать, что мы здесь
рассматриваем только не
самозацикливающиеся пути.
Мы здесь обычно, когда пишем алгоритм Dijkstra,
мы неявно рассматриваем
только не самозацикливающиеся пути
или, в худшем случае, пути, которые
зацикливаются только в конце.
Но таких путей у нас
это не конечное количество.
Логично, да?
Поэтому мысленно мы можем это конечное
количество отсортировать и идти по ним.
Поэтому, ладно, тут мы
себя не сильно ограничили.
Так вот, тогда получается, что когда мы идем
по слоям и видим действительно
все эти слои, то
что нам требуется?
То есть нам нужно гарантировать,
что если тут кратчайший путь,
допустим, 4,3, то он может быть
достигнут как вот этот вот предыдущий
кратчайший путь плюс это ребро.
А это, по сути, вот это условие
на самом деле и гарантирует,
что оно нам
и гарантирует, что на самом деле
кратчайшие пути действительно можно
так устроить.
Существует кратчайший путь
такой, что на каждом префексе
этот путь кратчайший.
Но там доказательство будет такое,
рассмотрим конкретный кратчайший путь.
Ну, во-первых, начнем с того,
что зацикливаться невыгодно по первому
условию.
Понимаете, да?
То есть зацикливаться нельзя.
Ну вот, нет смысла. Но тогда, если у нас
путь не зацикленный, то мы начинаем
с того, что вот этот путь подменяем
на, допустим, кратчайший путь
до сюда.
Вот, может быть даже убив зацикл.
Но я не знаю там, я боюсь только...
То есть подменяем на кратчайший.
Ну, надеюсь, есть подозрение,
что... То есть есть надежда, что
не выяснится, что этот путь проходит через эту вершину.
Почему?
А вдруг, мало ли.
Так.
Нет, ну ладно, если мы в какой-то момент
будем идти и натыкаться на вершину s,
то мы просто этот префикс обрубим как-нибудь.
Хотя, конечно, да, надо подумать,
как кто-то зациклы избавится.
Ну да, как бы там...
Действительно проблема.
Как бы у нас не обнаружился подлый цикл
по условно нулевым ребрам.
Какой-нибудь.
Нет, ну можно, конечно, говорить, что давайте
при кратчайших
путях, там при равенстве
минимум рассматривать путь с минимальным количеством
промежуточных ребер.
Можем такое сделать, да?
Вот.
То есть, допустим, рассмотрим
вот такой кратчайший путь
из них.
Хотя нет, тут как бы проблема.
Хотя нет, там вот подлянка.
Теперь подменим.
Ну да, то есть подменим
это на кратчайшее, потом...
Так, знаете, что?
Легче, на самом деле, проверять
по нормальному доказательству.
Поэтому давайте лучше, действительно, вспомнить
нормальное доказательство ДЕКСТР, тем более, что
адекватно будет.
Давайте вспомним, как у нас устроено нормальное
доказательство ДЕКСТР.
Устроено оно так.
То есть, вот, допустим, у нас есть вершина С,
вот у нас, допустим, зона,
до которой мы расстояние
типа насчитали, есть все остальные вершины,
в которых есть какие-то Д.
Мы утверждаем, что если
вот мы найдем какую-нибудь вершину В,
до которой как бы
вот это вот расстояние
плюс ребро, вот это минимальное, которое сейчас
в Д от В, то как бы это расстояние,
то это действительно расстояние.
Так понятно, о чем я говорю?
Так есть кто живой?
А то что-то спят
уже даже те, кто не спит вроде.
Вот.
Вот.
Вот.
Так вот.
И так вот, действительно, допустим, у нас УВ.
И так.
Теперь, значит, пытаемся доказать, что
у нас другого пути нет. Теперь говорят,
допустим, у нас есть какой-то еще путь, который
тут ходит вот так вот, вот так вот, вот так вот.
Вот тогда мы говорим следующее,
что жил-был у нас вот этот вот
У'В'
что это такое. То есть этот путь, первый раз
эту границу должен был пересечь
когда-то, да?
Вот.
Вот это мы назовем РО штрих,
а вот этот путь у нас РО.
Тогда смотрите.
Тогда дальше у нас цепочка звучит так.
W от РО штрих.
Значит, начнем с того, что по первому
вот этому свойству,
тут мы им пользуемся,
это больше либроном, чем W от
вот, в общем, короче,
У'В'
видно, да?
Это
больше либроном,
так, это что-то,
вот.
Это больше либроном, чем W
Сейчас, сейчас, сейчас
нет, погодите.
Вот.
Да, очень хочется это как-то связать с
D от W'
А как связать вот эту штуку с D от W'
Ну, заметим, что
вот.
Так.
Ну, вот.
Сейчас, чего?
Вот.
Ну, заметим, что
скажем так.
То есть этот путь, это такой, что
то есть это какой-то путь
внутри отметки от У'
и В'.
То есть это, на самом деле,
теперь мы, видимо, воспользуемся каким-то вторым
свойством.
И скажем, что вот этот вот штуку,
то есть это тоже W от
У'
В',
только единственное, что мы теперь скажем, это то, что
вот это вот, это минимум.
То есть это вот минимальный путь до У'.
Да?
Вот.
Ну, теперь фишка.
То есть вот теперь
мы понимаем, что
то есть
так.
А, ну да.
То есть это означает, что вот этот вот путь
рассматривался в оптимизацию
В'. Да?
То есть это означает,
что это больше либо равно, чем
то, что сейчас написано в
Дист от В'.
Вот.
Ну, потому что вот конкретно
такой путь там рассматривался.
Ну, мы предполагаем, что мы
как бы до У' нашли реально кратчайший путь.
Да?
Так, где шаманство?
Где шаманство пошло?
Где, непонятно?
Ну, значит, еще раз.
Так, вот это понятно, да?
Но теперь, смотрите, дело в том, что вот это, это какой-то путь до У'.
Да?
Теперь мы вынуждены воспользоваться вторым свойством,
что оказывается, это больше либо равно, чем
то же путь У' В',
только мы до У' дошли кратчайшим путем.
Реально кратчайшим.
Вот.
Но теперь заметим, что кратчайший путь до У'
какой-то мы уже нашли.
И это означает,
что мы
им уже релаксировали В'.
Да, то есть я здесь вот
из кратчайших путей выбираю именно тот, который
вот, который вот
в Дист от У'.
Вот.
Поэтому я здесь могу написать, что это
больше либо равно, чем то, что там
Дист от В' написано сейчас.
Там написано как минимум это,
а может еще что-то меньше.
Далее.
Так, теперь по построению алгоритма
это больше
либо равно,
чем Дист от В'.
Вот.
Это
что такое?
Но Дист от В',
так, это
равно.
Это буквально равно
нашему вот этому пути.
То есть это функционал
вот этого пути
и ребро У'
причем вот это вот
это именно Дист от У'.
Я здесь по Дист от У'
даже сам кратчайший путь подразумеваю.
Точечка.
Ну вот. То есть по идее вот доказательство
окончено. То есть я нашел
произвольный путь до вершины В', доказал,
что он не больше, чем Ваш.
Но обратите внимание,
я здесь воспользовался и первым свойством,
и вторым свойством.
Но при этом,
но что приятно, больше я не воспользовался ничем.
Так.
Ну, вторым
пользом мы воспользовались вот
то есть смотрите, мы
то есть первым
способом воспользовались, чтобы от этого
пути оставить только этот преферс.
Но дело в том,
что мы как бы, да, мы знаем,
что по У'-3,
по У'-4,
по У'-5,
по У'-6,
да, мы знаем, что по У'-3
мы шли как-то внутри, но это не значит,
что мы шли именно по кратчайшему пути.
Ну, до самого У'-3.
То есть может как-то в обход шли.
Поэтому как бы у нас цель подменить теперь
вот этот путь на кратчайший.
И мы воспользуемся вторым свойством, чтобы это сделать.
Дист не совсем нет.
Дист это
тот путь, который
имеется в виду прямо сейчас.
Но и мы по индукции считаем,
что для всех вот этих вершин
это реально кратчайший путь.
Понимаете, да?
Вот.
Ну, в прочем,
ну, вот.
Почему мы эти, ну, вот.
Ну, в прочем, ну, да.
Ну, в прочем, это сейчас
даже и не важно на самом деле.
Потому что
важность здесь не то,
а хотя, да.
Да, мы здесь пользуемся всем, что дист ату кратчайший,
потому что как бы мы этим пользуемся,
чтобы сказать, что вот этот путь больше либо равен,
чем то, что написано в дист ату реально.
Ну, а то штрих в смысле.
Вот, да, поэтому мы здесь все,
мы здесь всем тонко
воспользовались.
Вот, понятно, да?
Вот.
И тогда, то есть, видим, что получается,
то есть, получается действительно
что, получается, вот эти
условия, без этих условий,
scripture, можно доказать, и можно, конечно,
сложно доказать, что если этих условий
за выполненно, то да и экстра, видимо, обвалятся,
то есть, так в общем случае,
сложно доказать, то есть там Rich,...
но в принципе эти условия выглядят
достаточно сильно,
то есть, можно вот тестировать, например,
что, там, скажем, два максимума,
например...
Не работают, почему?
Но они не работают скорее по первому свойству, потому что сумма двух максимумов при добавлении ребра может уменьшиться.
Сумма двух максимумов не валится.
Хорошо. Сумма двух минимумов валится здесь. Сумма двух максимумов здесь не валится, а вот здесь, как выясняется, вполне валится.
Это действительно вполне валится. Какие еще примеры?
Ну, функционал с автобусами, когда у нас функционал пути равен бесконечности, если последователь автобусов некорректно, и весу последнего ребра, если корректно.
Что?
Ну, потому что вас интересует в этой задаче время, когда вы приедете, собственно, на финиш.
И поэтому вес пути – это, собственно, время финиша.
То есть это вас вроде как устраивает.
То есть если вы в город по этому пути приедете раньше, чем по этому пути, то воспользоваться тем же самым автобусом вам это не помешает.
Ну, по крайней мере, если вы при этом пути можете воспользоваться этим автобусом, значит при этом тем более.
Что у нас еще бывает? Бывает одно максимальное ребро?
Давайте проверим. Если у нас максимум на пути.
Ну да, максимум на пути из всех чисел. Что получится?
Первый очевидно кайфец, но второй тоже очевидно кайфец.
Какие еще примеры бывают?
А, ну так.
Нет, ну XOR как бы здесь пофейдится, очевидно.
И первое, в общем-то, XOR не надо.
Но это вот да. Ну тут разные варианты есть, то как бы вот полезно помнить, что Dextra тут, ну Dextra на самом деле тут по-разному может конечно и работать.
Что-что?
Битвы или?
Валится, валится.
Валится. Там как бы да. То есть может тут старший бит меньше, а потом старший бит меньше, а младший бит больше.
Тогда мы тут поорили и там да.
Так что да. Так что вот в принципе глядя на эти условия, можно неожиданно думать какую забодробительную Dextra забабахать.
Что?
Нет, не всегда тебе нужно пустить DFS, чтобы выяснить, что путь есть.
Да, это уже как это говорят, да.
Но это немножко другое.
Так что вот такую вот штуку. Ну то есть по-разному можно делать.
А самое главное для нас, что сейчас заметим, если функционал стандартный, но ребра бывают отрицательные, то это тоже автоматический фейл.
Ну просто по первому условию.
В чем более того, ну там в общем-то достаточно, то есть в общем-то аналогичным вот тому способу на самом деле легко привести контрпример.
Но правда мы заметим, что с отрицательными ребрами, если уж так переходить к отрицательным ребрам, то вообще начинается маленькая подляночка.
Да, подляночка заключается может в том, что кратчайшего пути может тупо не существовать.
Потому что есть такая замечательная объекта, как цикла отрицательного веса.
Да, не обязательно там все ребра отрицательные, главное, чтобы сумма была.
Тогда подляночка такая, до любой из этих вершин пути минимальной стоимости не существует.
Ну тут конечно может так случиться, что вообще пути не существует, тогда для них ответ плюс бесконечность.
Но если из вершины С до этого цикла дойти можно, то тогда кратчайшего пути не существует.
Потому что какой бы вы путь не взяли до, скажем, вот этой вершины, вы можете тут пробежаться по циклу и получить путь еще меньше.
То есть это называется так, существует путь сколь угодно малый.
То есть у вас не существует пути, который равен минус бесконечность.
То есть он существует путь, для любого С меньше нуля, существует путь, у которого вес не больше, чем С.
Чего?
Ну да.
Ну тут я просто меньше нуля, чтобы на автомате не начали говорить, для любого С больше нуля найдется.
Это не интересно.
Интересно, что любого С меньше нуля найдется.
Вот это неожиданная мощь.
Вот.
Поэтому здесь конечно приходится с этим справляться какими-то, то есть как бы эти ситуации приходится обрабатывать.
Да в общем-то, хотя даже если нам гарантирует, что таких ситуаций нету, то все равно приходится думать.
Вот.
Ну, пожалуй, наверное, как бы да.
То есть это разговор не сильно длинный, но все-таки, наверное, не 10-минутный.
Вот.
Поэтому я думаю, мы на этом остановимся.
Вот на этом остановимся.
А в следующий раз тогда будем обсуждать.
То есть обсудим и этот случай.
Там еще кое-что, правда, экстро обсудим.
Ну, посмотрим.
То есть кое-что я в Т хотел бы вам рассказать, я надеюсь.
Не, ну правильно.
Тут как минимум уже прозвучало про Берликампа Мессия.
Надо его обсудить, конечно.
Вот.
Значит, Берликамп Мессия.
А так еще там есть еще там всякие задачи там веселые типа там.
Ну, там логарифмирование, там ряд экспоненцирования, вот это вообще.
Чего?
Ну, тоже верно.
Спасибо, спасибо, спасибо.
