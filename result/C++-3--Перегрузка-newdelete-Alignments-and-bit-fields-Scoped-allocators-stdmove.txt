Еще три пунктика, и первый пункт из тех, что нам надо
обсудить, это перегрузка операторов new и delete.
Значит, у нас продолжается пока что тема локаторов
и выделения памяти.
Я буду в основном код писать, я думаю доска мне не очень
понадобится в этом деле.
Напомню, что у нас есть теперь уже несколько слоев
абстракции, когда у нас есть контейнер какой-то,
он обращается не напрямую к new, а к локатор trades, которые
в свою очередь обращаются к локатору, который обращается
к оператору new.
В прошлый раз мы разобрали вот этот участок цепочки,
пищевой цепочки.
Мы понимаем, что никакой контейнер стандартной
библиотеки на самом деле оператор new напрямую не
вызывает.
Но оператор new как и локатор тоже можно переопределять.
Можно подменить локатор, а можно подменить оператор
new.
Переопределение оператора new это гораздо более фундаментальная
вещь, чем переопределение локатора, в том смысле
еще более глобальное.
Вы можете локально подменить локатор в какой-нибудь
контейнер.
Вот этот контейнер работает пожалуйста с другим локатором.
Но C++, как известно, не черпаемо богато, он позволяет вам сам оператор new изменить,
поменять его действие. Соответственно, все локаторы, вызывающие оператор new,
будут натыкаться на ваш по-новому определенный оператор new.
Вот сейчас я скажу очень странную и шокирующую вещь. Тем не менее, это самая главная вещь,
которую надо запомнить про оператор new. Вещь такая, оператор new и функция с названием оператор new,
это не одно и то же. Есть оператор new, это то, что мы раньше называли оператор new, а сегодня мы
изучим штуку, которая называется функцией оператор new. Я не знаю, как это на английском вообще люди
понимают, потому что у них еще и называется это одинаково. Ну короче, то, что мы будем
переопределять, это не совсем оператор new, это функция с названием оператор new, и это не совсем
то же самое. Дело в том, что действие оператора new состоит из двух частей. Сначала он выделяет
память, потом вызывает конструкторы. Ну вот что происходит, когда вы, например, давайте я какую-нибудь
структуру заведу, логгер, у нее будет конструктор. Я даже установил себе плагинчик, чтобы было какое-никакое
автодополнение, а то мы так много времени будем терять. Вот, ну давайте у меня будет такая структурка,
которая значит делает лог, что с ней произошло. Создано, уничтожено. New Delete Overloading 9.4, да. Вот,
и что происходит, когда я пишу логгер звездочка ptr равно new логгер. На самом деле происходят две
вещи последовательно. Вот, когда мы впервые изучали оператора new, мы еще не знали про конструкторы,
но теперь мы понимаем, что работа оператора new заключается не только в выделении памяти. Сначала
выделяется память, а потом на этом адресе вызывается конструктор. Вот. Вот это вот называется new
expression. Ну, выражение new. Да, new что-то там, new te. И вот действие выражения new как раз оно стоит
из двух частей. Сначала вызывается функция с названием оператора new, которая выделяет память,
а потом на выделенной памяти вызывается конструктор данного типа. И когда говорят
о переопределении оператора new, имеют в виду именно переопределение первой части. То есть вы
можете переопределить функцию оператора new, но вы не можете переопределить поведение,
заключающееся вызове конструктора. Вот. Как переопределить оператор new? Вы должны написать
функцию со следующей сигнатурой. Вот звездочка, оператор new от size te, ну скажем n. И вот тут вы
должны что-то сделать. Вот эти действия должны сводиться к выделению памяти. Ну, как можно
переопределить оператор new? Я сейчас переопределю его неправильно. Я переопределю его очень тупо и
неправильно. Ну, что можно было бы сделать? Вот мы сейчас должны написать свое выделение памяти.
Вот стандартный оператор new что-то там делает, а мы сейчас по-своему это напишем. Как это написать
по-своему? Ну, да, malloc. У нас оператор new мы решились, нам лишились, нам нужна функция malloc. Понятно,
что оператор new вызывает сишный malloc. Ну, оператор new это фактически обертка над сишным malloc, умная
в некотором смысле. Вот в чем ее ум заключается, мы сейчас разберем. Я вам сейчас, я даже специально
заготовил код. Мы сейчас посмотрим просто, как стандартная реализация оператора new выглядит,
что она делает. Прям она не очень длинная, можно ее просто прочитать и понять, что она делает,
чем она от malloc отличается. Вот, но давайте будем считать, что мы просто делаем вот так. Значит malloc
от n. Нормальная, простая реализация оператора new. Давайте я еще вот здесь вот добавлю какой-нибудь
тоже лог, чтобы вы понимали, что мы реально сюда попали. Вот, я сейчас очень примитивно
переопределил оператор new. Я просто вызвал malloc на n byte из c s t d либо и вернул void звездочку. Вы
можете спросить, почему я возвращаю void звездочку, а не t звездочку, и что такое n? Ну n это количество
byte, а void звездочку я должен возвращать malloc возвращает void звездочку. Вот, но прикол в том,
что оператор new, вот этот вот new expression, он возвращает не void звездочку, а логер звездочку.
Но когда мы переопределяем оператор new, это все нам стандартом так гарантировано, что вот если мы
хотим переопределить оператор new, нам не нужно думать ничего о типах. Мы получаем, ну то есть
компилятор, он так все обустраивает, что реально вызывается наша функция, в которую уже передается
правильное число в байтах. И правильно делает, ну нельзя, ну либо глобально, либо в классе можно
переопределять оператор new. Вот. Сейчас а n это количество byte? Byte именно, да, это количество byte,
которое выделить надо. Оно само вычисляется как-то без вашего участия на лету, то есть когда вас
переопределил оператор new, вы количество byte откуда-то получаете от компилятора. Вот компилятор
передаст вам правильное. SizeOfLogger умножить на n. Ну в данном случае будет SizeOfLogger. Да, про это мы
сейчас поговорим. Вот то, что я сейчас сделал, это глобальное переопределение оператора new. Теперь
вообще все вызовы оператора new будут проходить через вот это. В частности, например, если я сейчас
заведу вектор, ну давайте, во-первых, я продемонстрирую, что оно так работает.
Значит, оно само, вот вся магия промежуточных стадий делается без вас. Все, что вы вольны
переопределить, это стадию выделения памяти непосредственно. Вот. Вычистение размеров в
байтах, а также каст отводить звездочки к чему надо, производится без вас. И вызов конструктора
производится без вас. Вот на том указателе, который вы вернете, будет вызван конструктор данного типа,
который просили создать. И это все делается без вашей воли, без вашего участия. Вот. Что сейчас
произошло? Я переопределил оператор new для выделения памяти, и мне его вызвали с одним байтом,
потому что размер этой структуры один байт, конечно. И вот потом был вызван конструктор.
Деструктор вызван не был, кстати, ну логично. Как именно? А кто сказал, что это плохо? Я
пока не говорю. А, в смысле, что это совсем неправильное переопределение? А, в этом смысле. Ну,
хорошо, давайте поговорим о том, что с проектором случилось. А что с проектором случилось? Ага. Ну,
это даже лучше. Хорошо. Почему это неправильное переопределение оператора new? Потому что оно
совершенно не удовлетворяет требованиям стандарта, что должен делать оператор new. Давайте вспомним,
что мы уже знаем про оператора new. Что он должен делать умного? Ну, например, если не получилось
выделить память, он должен кидать std bad alog, а мы вернем null ptr. Вот. Это не то поведение,
которое ожидается от оператора new. Нет, нет, неправильно. Здесь с выравниванием нет никаких
проблем, но об этом мы позже поговорим. Еще одна проблема, о которой мы, впрочем, не говорили.
Оператор new на самом деле, сейчас будет еще одно откровение. Я вас обманывал все это время. На
самом деле оператор new не сразу кидает bad alog, если у него не получилось выделить память. Сначала
он вызывает так называемую функцию new handler. Значит, стандарт говорит следующее. Если оператор
new не получилось выделить память, то он должен вызвать функцию get new handler. Так, сейчас подождите.
Опять не туда. Нет, вот сюда, да. Так, сейчас. Давайте я вам открою на себе периферен соответствующую
страницу. Пожалуйста, выдерни капель и воткни обратно. Что, что ужасно? Это Мексика. Мексика?
Голливудская Мексика, все желтая. Сейчас. Вот, по стандарту есть такая функция get new handler.
Ну хорошо, давайте. Ого, это что там, контакт плохой что ли? Да, я заметил, да. Может это дело
в контакте? О, да, похоже. Я его чуть-чуть шевелю и он меняет цвет. А вот сейчас я его не шевелю,
а цвет он все равно меняет. Слушайте, ну я не знаю, ну придется так жить, ну что я могу поделать.
Так, давайте не задерживаться. Так вот, есть такая функция std get new handler. Что она делает? Она
возвращает currently installed new handler, which may be a null pointer. Значит, handler это обработчик.
Ситуация, когда не получилось выделить память. Вот, вы можете кастомизировать функцию, которая
будет вызываться оператором new стандартным, в случае, если у него не получилось выделить
память, перед тем, как он отчается и кинет badlog. На самом деле, есть еще одна промежуточная стадия,
когда у нее не получилось выделить память, он сначала вызывает функцию new handler. А как он
понимает, что это за функция? А он просто вызывает вот эту функцию std get new handler. И если она
возвращает null ptr, это значит, что, ну все, нечего вызывать, нет никакой функции, кидаем badlog. А если
она возвращает какой-то function pointer, то он вызывает функцию по этому адресу. Вот, и заново пытается
вызвать malloc после этого. Ну давайте я вам просто, что уж говорить, давайте я вам просто покажу код. Да,
там и есть цикл. Давайте я вам просто покажу код, в конце концов. Мы с вами так много говорим,
я вам просто код сейчас покажу. Вот это код стандартной библиотеки Selang. Вот, значит,
так выглядит код стандартного оператора new. По умолчанию, который работает. Вот. Так, давайте
мы не будем придираться к коду стандартной библиотеки. Больше, пожалуйста, вот вопросы,
почему такой странный код style в стандартной библиотеке не принимается. Я не готов обсуждать это.
Вот такая сигнатура. Здесь происходит следующее. Ну вот эти строчки я пока оставлю без комментариев.
Так, господа, я не шучу. Код style мы не обсуждаем, иначе мы никогда не закончим дискуссию. Стандартная
библиотека это отдельная история. Их код style это что-то непостижимое. Мы не обсуждаем его. Вот.
Смотрите, что происходит. Вот берется этот поинтер, и пока malloc возвращает null ptr,
мы пытаемся вызвать new handler. Если он не нулевой, мы его вызываем, иначе кидаем badlock.
Вот. Да. И возвращаемся в вайле в начало. Мы вызываем в цикле new handler. Как теоретически
мог бы new handler что-то исправить? Теоретически new handler это функция, которая может что-то
попробовать освободить, допустим. Ну да, то есть вы можете у вас может быть какой-нибудь очень
долгоживущий сервер какой-нибудь, на котором если new понимает, что ему памяти не хватает,
то new handler вы определяете такой, чтобы он что-нибудь старое, древнее решил освободить. Ну что-нибудь
типа garbage collector, да. Вот. В конце концов он возвращает вот это p. Вот. Ну тут, видите,
еще есть значит ifdef если no exceptions, то есть если мы force'им в параметрах компиляции,
что мы без исключений работаем, то мы просто не кидаем ничего. Вот. Тут есть интересное вот это
вот интересный макрослип cpp weak. И тут есть комментарий, что это означает implement all new
and delete operators as weak definitions, so that they can be overridden. Вот. Вообще в нормальной ситуации,
если вы переопределяете функцию с такой же сигнатурой, то вы получаете ce со словами
«такая функция уже определена». Но здесь вот этот вот макрослип cpp weak — это такой костыль,
который говорит компилятору. Вот конкретно для этой функции, если вдруг ты встретишь другое
определение, то забудь про это и используй то. Так это и работает. То есть на самом деле,
когда вы глобально переопределяете оператор new, по стандарту компилятор обязан забыть стандартное
определение и начать использовать ваше. Ну разумеется, разумеется. Это внутренняя кухня. Да,
это конечно не нужно так делать. Вот. Но это просто костыль, потому что стандарт от компилятора
требует вот такого поведения. Вот. Так. Вопрос, почему, ну то есть как стандартный new должен
себя вести исчерпан. В принципе, если вы захотите его переопределить, то теперь вы знаете как.
А как, собственно, new handler-то поменять? Я вам сказал, что есть функция get new handler,
но есть логичная функция set new handler. Собственно, эта функция, которая позволяет вам установить
новый new handler, вы определили какую-нибудь функцию и function pointer на эту функцию передали в set new
handler. У нас уже была аналогичная ситуация. Помните с чем? Похожая пара функций get set,
вот с какими-то function pointers-ами уже была. Кто помнит? Я помню, что была. Ха-ха-ха-ха. Ну ладно.
Значит летом вы все вспомните. Ну была пара get terminate, get terminate и set terminate. Да,
мы этим занимались, когда исключения обсуждали. У нас была функция std terminate,
которую можно было подменить с помощью set terminate и узнать чему равна текущая функция
с помощью get terminate. То же самое с new handler. Вот, да, а вот это что такое? Я так и не сказал.
Что вы по этому поводу думаете? Ну что мы не можем выделять 0 байт, поэтому давайте выделим 1.
То есть если у нас объект, в котором нет полей, то мы под него выделяем 1 байт. Нет, объект,
в котором нет полей, он занимает 1 байт. Скорее, если нам просят выделить массив из нуля элементов,
то мы должны корректно это обработать все равно и на самом деле выделить массив из одного элемента.
Вот оператор new корректно это обработает. К сожалению, я не помню пример, когда это может быть
нужно, но в общем стандарт требует, так скажем. Так решил комитет. В целом примерно так же выглядит
это стд либо силенга. В целом можно посмотреть и в стд либо g++ написано примерно то же самое.
Вот, хорошо. Давайте теперь откроем, собственно, вот эту страничку. Я вам показал, как переопределять
оператор new вот с такой сигнатурой. Но на самом деле существует 22 разновидности оператора new,
которые перечислены вот на этой странице. Вот, давайте разберем их по очереди. Во-первых,
отдельно функцией является оператор new с квадратными скобочками. Вот, оператор new с квадратными
скобочками это другая функция. Вот если я сейчас напишу new логер квадратной скобочки, не знаю,
опять, то в эту функцию я не попаду. Ой, нет, я все равно в нее попал. А, правильно, да, совершенно,
да, да, да, ты прав. Оператор new с квадратными скобочками, ну в принципе это тоже можно прочитать
здесь же. Собственно, что тут далеко ходить? Оператор new с квадратными скобочками просто вызывает
оператор new. Вот, ну, формально это разные функции, хотя по факту они делают одно и то же. Ну,
можно переопределить оператор new с квадратными скобочками отдельно. Да, ну, тем не менее,
оператор new с квадратными скобочками он, ну, давайте я его отдельно переопределю и вы поймете,
что он все-таки является отдельной функцией. Вот, оператор new с квадратными скобочками,
size to n, и вот здесь я напишу вот так, а потом верну оператор new от n. Да, что вы хотели сказать?
Как это? Нет, нет, у нас пять раз конструктор вызвался, а new вызвался один раз.
Кстати, отличный вопрос, а вот это что такое? Почему 13?
Потому что захотел. Кто помнит первый семестр, мы обсуждали это. Да, на самом деле,
когда вы вызываете оператор new с квадратными скобочками, вы запрашиваете памяти больше,
чем size of умножить на n. Напоминаю, да, напоминаю, у нас размер одного логера один, и мы выделяем
пять штук, но запрашивается 13, потому что запрашивается 5 плюс 8, потому что на самом деле
запрашивается n умножить на size of t плюс size of size t. Зачем? Да потому что перед этим массивом
компилятор собирается положить число, в котором написано, сколько штук было этих элементов
в массиве, и он делает это тоже без вашего участия сам, да. Нет, это implementation defined,
но по факту компиляторы, все нормальные компиляторы так делают, вот, но вы не можете
на это полагаться. И вот сейчас, если я приду, сейчас, если я вот это вот вызову, я вот сейчас
так сделаю. Ну, вы видите, у меня вызвался вот этот оператор тоже числом 13, то есть на самом
деле мне уже в оператор new с квадратной скобочке пришло число 13, а потому что компилятор за меня
рассчитал, что надо выделить size of, меня попросили new логер 5, но на самом деле компилятор рассчитал,
что надо size of логер умножить на 5 плюс вот это вот число, куда я сам положу, и это все само
происходит без вашего участия, то есть когда оператор new с квадратной скобочке возвращает
указатель, дальше без вашего участия происходит сохранение числа по нужному адресу и вызов
конструкторов. Ну, на самом деле то, что я здесь делаю, это уб, вот в этом коде уб, знаете почему,
потому что я оператор new написал свой, а delete свой не написал. Если я приобрел оператор new,
то и delete мне надо переопределить. Давайте приобрелю оператор delete. Ну, вызывается
стандартный delete, но кажется, что пара new custom и delete стандартный, это формально уб, хотя
по факту ничего плохого не происходит. Да, что? По-моему нельзя, по-моему вы обязаны,
ну я не помню формальностей, формально по-моему это все уб, но вот по факту конечно ничего плохого
не происходит, потому что понятно, что происходит здесь, но стандарту кажется, говорит, что если вы
определяли свой new, то и свой delete тоже нужно. Вот, ну что принимает оператор delete? Он принимает
void звездочка P и кажется больше ничего. Да, и он еще no accept начинается и плюс 11. Вот, возможно,
если я этого не напишу, он даже не переопределится нормально. Вот, что этот оператор delete должен
делать? Он просто должен сделать free от P. Вот, вопрос, а нафига тогда число-то мы все-таки
сохраняли? Точнее вот, вот смотрите, у нас оператор delete с квадратными скобочками, он точно такой же,
то есть вот я могу написать и вот сюда вот вставить вот эту сигнатуру и здесь тоже сделать free от PTR.
Вот, а нафига же мы сохраняли число? Хорошо, я и здесь и здесь веду себя одинаково, когда я выделял
массив, а когда я выделял немассив, я во free отдаю один лишь указатель. Нафига же я в одном случае
сохранял число, в другом нет. Кого этих вот? Этих вот кого? Да, а для чего он его использует?
Что значит освободить? Вопрос в том, зачем оператор new квадратной скобочки на самом деле сохраняет
число слева от массива, если в оператор delete это число уже не передается, а передается только P.
В какой момент ему оказывается нужно это число реально?
Нет, это предположение не рабочее, потому что мы одинаково вызываем free, хоть мы массив удаляем,
хоть мы немассив удаляем. Cish на функция free просто принимает указатель и она уже точно не
может полагаться на то, что там какое-то число слева лежит. Потому что мы выделяем память
единым куском, мы один запрос делаем на память. Вот господин Барыкин правильно сказал, мы на
самом деле вызываем деструкторы, вот что мы забыли. Вот это число, которое сохраняет компилятор
слева от массива, оно нужно на уровне абстракции C++, дальше на уровень язык оси оно не передается.
Оно нужно на этой промежуточной стадии до того, как вы вызвали функцию с названием оператор delete,
чтобы вызвать деструктор нужное количество раз. Это число говорит компилятору, сколько штук
деструкторов вызвать. То есть free только вызывает деструкторы и все? Free? Никаких деструкторов,
это Cish-ная функция, в C вообще нет такого понятия деструктор. А как free понимает,
сколько памяти освободить? А это внутренняя логика malloc и free. Когда вы вызываете malloc,
он очень сложно устроен внутри, он запоминает хитрую сам таблицу храни, по какому указателю,
что сколько там было выделено. А вот мы запоминаем число не для того, чтобы malloc им там пользовался или
free. Они сами запоминают, что им надо. malloc и free запоминают какие-то числа для себя сами,
если им надо. А мы на уровень выше, еще число наверх, нас запоминаем, чтобы перед оператором
delete вызвалось нужное количество деструкторов. Чтобы, когда ваш код компилировал, вот этот код,
когда мы напишем сейчас delete квадратной скобочки, ptr, во что это превращается? Это
превращается на самом деле в цикл, то есть что делает компилятор при таком коде? Он делает цикл
for от 0 до того числа, которое левее ptr лежит на 8, ну там, возможно, с какой-то поправкой. Сделать
tilde logger, он же знает тип, вызвать деструктор соответствующего типа вот столько раз,
сколько написано слева, а потом вызвать функцию с названием оператор delete квадратной скобочки
от пойнтера уже сдвинутого на 8 влево. Вот что на самом деле происходит, когда вызываете оператор
delete. И переопределить вызов деструкторов нельзя, и переопределить вызов конструкторов нельзя,
можно переопределить только выделение памяти. А вот можно вопрос, у нас же delete, он каким-то
образом по сути отмечает, что у нас куча там теперь в этот память свободно. Кто? Что? Delete?
Мы не можем полагаться на то, что внутри себя делает free, потому что free это следующий
уровень абстракции, мы работаем с ним как с черным ящиком. На самом деле malloc и free устроены
очень сложно, и мы не можем полагаться на то, что они внутри там знают, но нам нужно на своем
уровне запомнить число, чтобы количество деструкторов правильно вызвать. А когда мы
вызываем malloc и free, мы просто полагаемся, что они как-то работают и возможно взаимодействовать с
операционкой, но это не точно. Ну вот они сложно на самом деле очень устроены. Реализация malloc
современная, она там занимает, не знаю, строк тысячу может быть. Да. Сейчас.
Ну не знаю, у меня все компилируется. Кого поставить? Ну хорошо.
Ну у меня ничего подобного. Вот, ну есть разные версии. Есть версия оператора delete с числом.
Честно говоря, я не знаю, зачем она нужна и кто ее вызывает. А, ну да, смотрите, вот если вы, вот,
оператор delete, есть у нее версия с числом еще. Она вызывается вместо первой версии, если,
ну, в общем, если дана, если таковая определена. Вот. Тогда вызывается, тогда предпочтение будет
отдано ей. Но можно обойтись и без нее, кажется, и вот этим всем обойтись. Ну, то есть, если вы
хотите каким-то, почему-то, вы хотите следить в операторе delete, сколько вы байт освобождаете
сейчас, то вы можете приобрететь эту и тогда всегда будет выбираться она вместо той. Видимо,
что-то такое. Вот. Давайте бегло просмотрим. Нет, вы можете просто хотеть, чтобы вы в delete
знали, сколько байт вы сейчас освобождаете. Это возможно, потому что вам будет просто,
точно так же, как в new, вам будет отдаваться size of, ну компилятор же знает, он, либо вам будет
отдавать size of t, либо size of t, может, на n, плюс там вот этот 8. То есть, вызывается он абсолютно так же,
просто поставляется вместо. Ну да, да, да. То есть, если хотите, можно, видимо, им пользоваться вместо
этим. Вот. Давайте бегло просмотрим остальные версии оператора new, их все можно переопределить.
Вот особый интерес вызывает вот эти вот версии. Смотрите, вот есть такая, а, да, ну, для начала,
вообще, как пользоваться нестандартными версиями new. Вот, например, вот есть такая версия, оператор
new size account std no throw tag. Это что такое? Кто помнит, что это за оператор new? Да. Гений. Да. Мы вкратце упоминали
такой оператор new, когда говорили об исключениях. Тоже я вам про него рассказывал. Это, этот оператор
new вызывает stag. Вы пишите new, ну, я могу вот так просто сделать, вот здесь вот, new в скобочках
std no throw от logger. Вот. И это будет не бросающая версия оператора new. На lptr возвращает. То есть,
у оператора new есть no throw версия. Это отличный вопрос, мы его обсудим чуть позже. Пока, пока
игнорируем этот, это тонкий момент. Вот. Ее тоже можно переопределить. Какая сигнатура для
переопределения этой штуки? Ну, надо просто переопределить вот это вот еще с... Ну, понятно.
С не no accept, а no throw. Причем const std no throw t. Вот это будет не бросающая версия. No throw new
cold. Да. No throw t это такой тег. Что такое тег? Это просто пустая структура, которая нужна только
для диспетчеризации, чтобы выбирать между версиями функций. Какой бул? Потому что там есть
много разных тегов. Вот, например, есть тег... Ну ладно, тут больше тегов нет, но есть кое-что
другое. Вот, например, есть placement new. Узнаете? Это placement new. Что эта функция делает? Вот вопрос
на понимание, как выглядит стандартная реализация вот этой функции. Значит, вопрос еще раз. Вопрос
на понимание, как выглядит стандартная реализация вот этой вот функции. Просто return ptr и все. Потому
что placement new это штука, которая вызывается, когда память уже выделена, надо лишь конструктор
вызвать, но часть выделения памяти уже сделана. Нам ничего не надо делать, поэтому мы просто
возвращаем ptr. Перегружать это, кажется, нельзя. Я, кстати, в предыдущие годы ошибочно на лекции
говорил, что это можно перегружать, а потом понял, что, кажется, это нельзя перегружать. Ну вот именно
placement new стандарт почему-то запрещает перегружать. Ну ладно, я не буду тут читать подробности. Вот,
давайте посмотрим на еще что-нибудь. Ну про eline я пока не буду говорить. Давайте посмотрим вот
еще на это. User defined placement allocation functions. Смотрите, вы можете создать функцию оператор new с
кастомными параметрами. То есть вы можете переопределить оператор new с каким угодно набором
параметров. Вы можете сказать new 123 logger от 5. И здесь вы можете написать, допустим, ну первым
параметром всегда идет size t, а вот здесь вы можете сколько угодно параметров написать int int int.
И здесь вы скажете custom new colt.
Да. А, здесь, здесь это не работает. Сейчас, подождите, да, это не работает, потому что квадратных
скобочек я не реализовал, а вот теперь нормально должно быть. Ну это какой-то, ну типа скорее на
оборот. No throw реализован через обычный. No throw реализован через обычный, просто он все ловит,
если что-то вылетело и кидает. Да, вообще довольно странно, что не наоборот, кстати, это интересный
вопрос, почему так сделано, потому что кажется, что это накладные расходы на исключения, которых
можно было бы избежать. Да, непонятно. Ну, по сравнению с вызовом самого new это все равно не очень
много кажется, но, кстати, это вопрос действительно очень хороший, почему так сделано. Ну вот в стандартной
библиотеке no throw new реализован через обычный new, хотя казалось бы логичнее наоборот, чтобы не,
чтобы не иметь дело с исключениями, если мы не хотим, а тут написано no throw new просто делает
подтраем обычный new и все ловит и проглатывает. Вот это как-то странно, ну я вот ничего не придумывал.
Ну я не знаю, может у них есть какая-то мотивация, может это просто недоработка в стандартной
библиотеке, можно сделать, можно попытаться сделать commit и исправить, я не знаю. New, который,
если не удалось выделить память, возвращает на lptr, а ничего не кидает. Так, дальше, вот, можно
определить new с кастомными параметрами. Правда, ну с какими угодно параметрами вы можете определить
свое new. Правда, если вы такое new определили, то вам и delete нужно парное к нему определить
с кастомными параметрами, иначе это кажется будет все опять-таки уб. Вот, мне теперь надо написать void
оператор delete от void звездочка P и трех интов, и тут сделать там тоже free от P, чтобы избежать уб,
ну потому что если я вызываю, если я делаю delete не той версией, которой делаю new, это формально уб.
Вот, правда есть проблема. У оператора delete нет синтаксиса вызова с кастомными параметрами,
нельзя написать delete от 123ptr. Поэтому, если мне хочется использовать кастомный оператор delete,
то мне придется вручную писать вызов деструктора и вызов функции оператор delete. Мне придется писать
ptr tilde logger, а потом 2.2.operaтор delete от ptr 1.2.3. То есть, если мы сделали такой кастомный new,
тогда нам нет другого выбора, как писать void оператор. Да, если вы сделали new с кастомными
параметрами, то вам придется и delete вызывать с кастомными параметрами, но до этого самим вызывать
деструктор. Ну нету синтаксиса у delete вызова с кастомными параметрами, вот почему-то не сделали,
не знаю. Вот, впрочем, есть один забавный кейс. Вот давайте вернем, значит, а не, не буду ничего
возвращать. Смотрите, вот что будет, кто-то этот вопрос уже задавал. Что будет, если я в конструкторе
брошу исключения в момент, когда делается вызов new? Ваши версии.
Куда? Кто память освободит? Ведь смотрите, как работает, еще раз, как работает оператор,
выделяется память, вызывается конструктор, и вам возвращается указатель на этот t. Память уже
выделилась, и тут вызывается конструктор, и конструктор бросает исключение. Кто освободит
память? А кто ее попросит? Нет, а если не завершится, если мы это все поймаем вот здесь вот,
то есть получается, что если в конструкторе во время выделения динамической памяти вылетел
исключение, то это гарантированный memo relic. Ничего с этим сделать нельзя. А кто вызовет-то его в
какой момент? Нет, то есть функция оператора new, она только память выделяет. Эта часть работала
корректно, исключение не вылетело. Кинуло исключение конструктор. Ну, в целом, да,
значит, это обязанность компилятора. Значит, стандарт говорит, если в момент выделения памяти
оператора new, точнее не в момент выделения памяти, а в момент вызова конструктора после выделения
памяти оператора new вылетело исключение, то компилятор сам обязан вызвать соответствующий
оператор delete и только потом вам отдать, что делать с этим исключением. Поэтому, на самом деле,
сейчас будет вызван кастомный оператор delete. Вот это тонкий момент, когда у вас вылетело
исключение. После того, как вы сделали кастомный new, компилятор сам найдет delete с такими же
точно параметрами и вызовет его в случае, если вылетело исключение в конструкторе. Так что
сейчас будет кастом delete called. Ну, оно не произошло, потому что это УБ, потому что,
когда вы меня не поймали на исключение, delete имеет право не вызываться, но вот так оно должно
произойти. Вот, custom delete called, потому что комитет по стандартизации так решил. Так, хорошо.
Указатель, который создан просто new, почему мы так не можем сделать? Чего-чего? Мы создали new без
квадратных скобочек какой-то объект. Да. И потом вызвали от него дали квадратные скобочки. Нет,
не квадратные. Вот этот мы вызвали. А если мы вызовем квадратные? УБ будет что. Почему это не
будет работать? Но если даже в стандарте реализация, то тоже самое, просто free вызвать.
Delete квадратной скобочки вызывает n деструкторов. Смотрит на число слева от массива, вызывает
количество деструкторов. Только потом функцию оператора delete. Так, дальше. Можно переопределить
оператор new для своих типов отдельно. Не глобально, а для своих типов. Вот это class
specific allocation functions. Вы можете сделать в своем классе метод оператор new. Вот, например, здесь. Я
могу сделать вот такой метод. И здесь напишу class specific new cold. Теперь, когда я буду вызывать new...
Когда я буду вызывать new стандартный для своего класса, у меня будет вызываться специфичный new.
Class specific new cold. Вот. Как это работает? Но также по правилу частное предпочтительнее общего.
Если у вас есть специфичный для вашего класса оператор new, то выбирается он. Если его нет,
то ищется, не переопределили вы глобальный оператор new. И только иначе вызывается стандартный.
То есть теперь вот для объектов logger будет вызываться специфичный оператор new,
который в классе определен. Вот. Я здесь не написал слово static. Но это, тем не менее,
работало. Почему? Ну, это же не метод объекта, это же метод, относящийся к всему классу. Потому
что так решил комитет по стандартизации. Значит, случаи оператора new, они статические,
даже если не написан static. Можно не писать static, оператор new, оператор delete все равно
будут считаться статическими функциями. Вот. Да.
Ну и то же, да, ну delete вызывается стандартный, но это уб. А может даже никакой не вызывает. Короче,
я не знаю, это уб. Но мне, если я сделал кастомный для класса оператора new, то надо и оператор delete
сделать кастомный. Вот. Два еще маленьких момента обсудим и пойдем к следующему пункту.
Еще я только проверю, что я ничего не забыл, как всегда. Вот. Ну, с исключениями понятно. Если мы
вылетел исключение в конструкторе, значит этот случай мы разобрали.
Смотрите, какая история.
Значит, я уже жду, что у людей начинаются некоторые. Да, да, ну сейчас должна возникать уже боль,
когда начинаю такое писать в определенных местах. Значит так, вот смотрите, я вот так сделал,
а теперь я говорю. Не-не, все гораздо проще. Не-не-не, нет, вот так. Вопрос. Как это работает?
Откуда оператор delete в таком сценарии будет знать, сколько байт ему принять в качестве вот этого вот?
Точнее, нет, не сколько байт ему принять, сколько байт ему принять. Ему вот, да, вот это работает
нормально, потому что оператору delete на самом деле не нужно знать количество байт. Вот, но хорошо, хорошо, хорошо.
Да, да, да, да, да, да, смотрите, смотрите, смотрите, да, да, да, вот смотрите, я говорю так, а потом я как раз,
видите, думаю, вот сын, вот сын, наследник мамы и папы. Ну, неважно какие тут поля, тут не знаю,
с. Вот, и теперь я говорю sun, нет, не так я говорю, father звездочка f равно new sun. И говорю delete f. Вот,
вот этот вопрос меня больше интересует. Откуда оператор delete знает, какой pointer?
Знает, что ему чистить вообще. Да. Ну, dead, да. Ну, в оператор delete. Откуда delete знает, что на самом деле мы
сам и у нас нужно почистить четыре? Откуда оператор delete узнает, что ему вот сюда нужно
принять не тот pointer, от которого мы формально вызвельнулись, а сдвинутый? А откуда он ее возьмет,
ее нет же. У нас нет ничего виртуального. Так, поднимите руки, кто понимает проблему. А кто
понимает, как она решается? Комитет по статартизации, конечно, понимаю. Я тоже понимаю. Я не до конца
понимаю, на самом деле. Ну, ответ простой, надо просто виртуальный деструктор объявить. Надо,
короче, чтоб тип был полиморфным, иначе это тоже не будет работать. Это действительно да, уб. Это
действительно уб. Потому что delete в таком сценарии никак не поймет, по какому указателю ему чистить.
Если тип полиморфный, то оператор delete сможет увидеть вот этот топов, он поймет сдвиг относительно
начала объекта и функцию оператора delete отдаст нужный pointer. Именно так и действует оператор
delete по стандарту. Он обязан, если тип полиморфный, сперва заглянуть, а что там написано, какой там
сдвиг и вот вызвать нужную. Вот, ну, можно скинуть там, там есть достаточно глубокий ответ на stack
overflow, что там происходит. Ну, в общем, там вызывается, ему нужно вызвать еще деструкторы
соответствующих под объектов, я не напоминаю, потому что это у меня тривиальные деструкторы у под
объектов. Вообще-то у сына мог быть свой деструктор, у папы, у мамы, у бабушки. Оператору delete нужно,
прежде чем освобождать память, вызвать деструкторы всех под объектов в правильном порядке. И вот он из
таблицы виртуальных функций должен подчеркнуть информацию о том, в каком порядке вызвать деструкторы
и по каким адресам каждый из деструкторов вызвать. И вот это все должно быть тоже записано в таблице
виртуальных функций, там в определенном формате. Ну, там висит адрес, скажем так, там висит адрес,
по которому вызывать деструктор в случае чего. И этот уже деструктор, в свою очередь, по этому адресу
написан код, который в правильном порядке все уничтожает, в том числе поля, деструкторы под
объектов и так далее. Но если нет виртуального деструктора, то это просто УБ, и так не будет работать.
Вот. Да. Ну. Зачем тебе вызывать деструктор строки, если строка сейчас со стека снимется,
ты хотел это спросить? Ну как тебе сказать? Деструктор строки сам содержит в отделе освобождения
некоторой динамической памяти. Да. Кажется, Илья просто говорил, что нужно писать всегда виртуальные деструкторы.
Кажется, мы раньше не делали такого со сдвигом указателя. Кажется, что вот конкретно такое пример
у нас раньше не разбирался, потому что мы никогда не делали new, а потом delete по сдвинутому указателю.
Это выглядит как какая-то ситуация, которая ужасно распространена, и это какое-то очень неочевидное
угло. То есть это не какая-то там высосанная из пальцев ситуация, это, кажется, ситуация, в которой вы можете
написать вообще, кто угор, надо выяснить. Ну окей, да. Значит, возможно, я забыл сказать или что-то, не знаю.
Просто если вы делаете delete по pointer не того типа, по которому делали new, то делайте деструктор виртуальным.
Тогда все будет хорошо.
Ну если вы собираетесь когда-либо в своем коде допускать, что будет делаться delete по pointer не того типа,
что был при выделении, то делайте деструктор виртуальным. Вот что из этого следует.
Ну если вы не делаете new delete с этими pointer, то кажется...
Да нет, написать new в нормальном коде так не делают.
Ну как редко делают.
New это не очень часто используемая штука, это довольно низкоуровневая штука.
Ну давайте потише вы там, вы что-то очень громко.
Ну если он виртуальный у бабушки, то все остальные у него унаследуют и станут полиморфными.
Да. Так, все. Это предпоследняя штука, которую я хочу сказать про оператор new,
теперь последняя штука. Если мы переоперим для бабушки, но не для мамы и для папы.
Нет, я думаю что он не вызовется, будет стандартный вызываться, потому что мы выделяем new не для того типа.
Так, ну мы же другой тип выделяем, нам другой размер надо выделить, например.
Так, последний вопрос. Задача. Задача на отл. Однажды мне такой вопрос задали...
В общем, мне лично такой вопрос на собеседовании не задавали, но я знаю, что однажды такой вопрос был на собеседовании, не помню куда.
Может быть, кстати, в Касперск, не помню. Как запретить создавать некоторый объект на куче?
Сначала вопрос простой. У вас есть некоторые типы. Вы хотите, чтобы объект этого типа нельзя было создавать на стеке?
Как это сделать? Как запретить? Попытка создать этот объект на стеке должна приводить к CE. Как сделать такое?
Кажется, можно сделать delete у оператора new публичный и приватный конструктор.
Можно проще сделать приватный конструктор. Ну или приватные конструкторы.
Можно сделать приватный деструктор. Конструкторов может быть много, а они публичные.
Можно сделать приватный деструктор. Это автоматически запретит создавать объект на стеке.
Прикол в том, что при создании на стеке прописывается явный его вызов?
Да, и при создании на стеке просто не дадут создать, если деструктор приватный.
В то же время на куче вы можете этот объект научиться создавать.
Если там new и delete. Допустим, вам деструктор можно будет вызывать только из определенных мест.
И конструкторы только из определенных мест.
И тогда вы сможете определенным манипуляциям с приватностью добиться того,
что на куче этот объект у вас создать получится.
Через оператор new.
В динамической памяти?
Да, в динамической памяти.
А какие это должны быть?
Ну, сделать там какую-то функцию random и из нее вызывать деструктор.
То есть деструктор вам придется вызывать явно из какой-нибудь функции, которая ваш друг.
Я же не могу сделать себя другом изнутри.
Ой, осторожно.
Классно.
А ...
А, сейчас.
А, может я тебя как раз перепутал?
И вопрос-то в другом.
что на куче запретить легко, а на стеке… короче, два
вопроса.
Как запретить создать объект на куче и только на стеке
разрешить?
И как запретить создать объект на стеке и только
на куче разрешать?
Вот.
А, ну да, чтобы запретить создавать на куче можно
просто сделать, например, оператор new… да, я вас обманул.
На самом деле запретить на куче создать как раз
просто, а на стеке не так просто.
Вот, чтобы запретить создавать объект на куче мы просто
оператор new для данного типа переопределяем так,
чтобы он, ну не знаю, равно delete, например, да, делаем
или бросал исключение.
Ну, короче, попытка сделать new от этого типа приводила
бы к ошибке.
Вот.
Запретить создавать на куче понятно как.
Как запретить создавать на стеке?
Нам надо, чтобы вызов деструктора делался в какой-то функции,
когда мы удаляем объект, которое бы… единственное
было можно делать вызов деструктора, а всем остальным
нельзя.
Вот, до C++20 не существовала способа, но начиная с C++20
появился так называемый destroying оператор delete.
Что такое destroying оператор delete?
Это такой специфический оператор delete, который,
если определен, то компилятор при вызове delete expression не
вызывает деструктор сам, не пытается, а дает это
на откуп вот этому оператору.
Вот, смотрите, тут написано.
If defined delete expression does not execute a destructor before placing
the called operator delete.
Если вы определили такую функцию, то тогда вызов выражения
delete от вашего поинтера не будет автоматически
приводить к вызову деструктора, и вы сами в этой функции
должны вызывать деструктор.
Это только начиная с C++20.
Вот, эта функция, определение этой функции позволяет
вам запретить создавать объекты на стеке и разрешить
только на куче.
Сейчас, это СЕ будет?
Чего?
Это СЕ будет?
Что такое СЕ?
Software engineer?
Не представляешь, это CЕ.
Это CЕ скорее.
Ну да, это будет CЕ, конечно.
Как именно мы запрещаем?
Вы делаете приватный деструктор, а эта функция является членом
вашего класса, и из нее деструктор вызывать можно.
Это приведет к тому, что на стеке объекты вашего класса
создавать нельзя.
Это будет CЕ.
Но при этом с помощью пары операторов NewDelete можно.
И вот из этой функции оператор Delete вы сможете вызывать
деструктор.
Понятно?
Вот такая вот, такой лайфхак.
Подожди, а предыдущий лайфхак не работал?
Да, предыдущий лайфхак...
Ну, я перепутал просто.
Что-то одно из этого можно было и раньше делать просто.
Ну вот запретить создавать объекты на куче можно было
просто, просто оператор New для данного t написать равно
Delete, например.
Вот.
А это легко как раз.
А вот запретить создать объекты на стеке, да, это
не так легко как раз.
Это я перепутал.
И вот это стало можно все плюс плюс 20.
То есть вот это мы в паплике определяем с деструком
Delete, а без деструка Delete вправить, да?
Чего без деструка Delete вправить?
Мы оператор Delete делаем членом класса, в котором вызываем
деструктор, а сам деструктор, приватный.
Мы можем деструктор удалить?
А, нет.
Ну можем, но тогда мы вообще никак не сможем объект
создавать.
Не, ну сможем через оператор New, но корректно мы его
создавать не сможем.
Удалить деструктор, а потом он написать...
Что значит удалить?
Написать равно Delete?
Да.
Тогда мы корректно с этим объектом вообще не сможем
работать.
А мы потом вот этот, который деструем Delete.
Так он удален, деструктор, нельзя вызывать деструктор
ниоткуда, если он равно Delete.
Нет, Илья.
Равно Delete и оператор Delete это разное значение слова
Delete, никак не связанное друг с другом.
Илья, а если деструктор сделать приватным?
Да.
Почему это слово не работает?
Ну, ты сделал деструктор приватным, но как на куче
теперь тебе объект создавать?
Ты сделал New, а Delete как делать?
Просто при попытке сделать Delete по TR, просто стандартным
способом, компилятор автоматически попытается вызвать деструктор
и не сможет, потому что он приватный.
Нет, а если я какую-то оберточную функцию напишу,
которая, какой-нибудь оберточный метод, который, у которого
есть уже доступ к этому Delete?
Что такое оберточный метод?
Ну, то есть тебе освобождать...
У оператора Delete сделать его random.
Ну, то есть тебе надо будет всякое удаление этого
объекта делать через какой-то оберточный метод, который
сделать random исходного класса.
Ну да, так по идее сработает.
Ну да, да.
Но это кривой метод, кривой способ, потому что нормальным
образом, ну как, ты сможешь его создавать на куче, но
тебе придется это делать как-то нестандартно через
какие-то непонятные заклинания, а вот с этим способом
ты можешь это делать стандартно.
New, Delete, пара New, Delete, как будто для пользователей
это выглядит, он пишет обычный код New, Delete, а внутри это
работает вот так, что просто он попадает в эту функцию
и она вызывает деструктор.
А, еще раз, извините.
А в Delete, ну в этом Delete, что мы делаем?
Как мы в итоге дойдем до деструктора?
Ptr, стрелочка, тильда, t, вызов деструктора.
Уже в Delete.
В функции DestroyingDelete, вот в этой.
Типа, а еще что делает DestroyingDelete, t?
DestroyingDelete, t это тег, говорящий о том, что это версия оператора
Delete с такими параметрами.
Почему мы в куче можем, а в стеке не можем?
Очевидно почему.
Может Delete мы в стеке не вызываем, да?
Потому что деструктор приватный, попытка создать объект
с приватным деструктором в стеке будет давать ce.
У нас Delete не статический?
Статический.
Оператор Delete всегда статический, даже если статик не написано.
Откуда он берет объект, который не может быть статичным?
Передается параметром ptr.
У нас же изначально должен вызваться деструктор, а потом уже оператор Delete.
Да.
Но в случае DestroyingDelete это работает не так, и для этого
специально прописано исключение из правил, начиная с C++20.
DestroyingDelete берет на себя ответственность из-за вызов деструктора
в том числе, как раз для того, чтобы решить вот эту описанную проблему.
Сейчас мы пишем оператора NewDelete.
Он ни разу не вызовет стандарты NewDelete?
Слушайте, давайте, пожалуйста, мы дальше пойдем.
Сейчас, когда у нас будет перерыв между парами, вы мне все вопросы зададите.
Просто нам надо еще два пункта обсудить.
Я надеюсь, что мы сейчас минут за 40 их обсудим.
Давайте пойдем дальше.
Я закончил про перегрузку операторов NewDelete.
Да.
Следующий пункт называется Alignment.
Выравнивание.
9.5.
Ну, если точнее, Alignments and bit fields.
Это короткий пункт.
Мы про него, я думаю, за 15 минут справимся поговорить.
Что такое выравнивание?
В принципе, мы уже знаем из первого семестра.
Да, значит, у нас объекты должны лежать по адресам кратным...
Ну, не обязательно размеру, кратным размеру наибольшего примитивного типа,
как поле, входящего в них.
Ну, короче, у нас есть варианты, что инты должны лежать по адресу кратному
size of int, double по адресу кратному size of double.
А если объект состоит из многих других подобъектов,
то они разбиваются на составляющие, и все приводится к тому,
что они должны лежать тоже по адресам кратным своим размерам.
Все сводится к тому, что числа на примитивном уровне,
числа инты и даблы должны лежать по адресам всегда кратным своему размеру.
И поинтеры.
Почему так?
Напоминаю.
Потому что так устроен процессор.
Потому что процессор читает не по одному байту.
Потому что процессор, когда читает число, 4-байтное,
он его читает одной инструкцией.
Машинное слово, допустим, он читает.
Или два машинных слова.
И если у вас будет в памяти лежать число не по адресу кратному 4,
то процессору, чтобы прочитать это число, потребуется
либо две инструкции потом как-то хитрое это число из битов составлять,
либо это будет вообще runtime error.
На самом деле, насколько мне известно,
интеловский процессор нормально справляется с невыровненными числами.
Это просто дольше работает.
Если число лежит невыровненное по адресу кратному нужному,
то интеловский процессор, он его прочитает,
но для этого ему придется больше шагов сделать.
Ему придется прочитать этот кусок, этот кусок,
склеить число из двух кусков и начать с ним работать.
А вот AMD процессоры, кажется, могут и упасть вообще.
Если попросить AMD процессор считать целое число с адреса не кратного 4,
то он просто упадет с R&E.
Ну там сгенерирует ошибку на низком уровне и все повалится.
Кажется, что даже где-то у нас на работе
однажды такой случай был из-за неправильного выравнивания.
Так вот, короче, неправильное выравнивание чисел – это УБ.
Потому что как минимум некоторые процессоры могут просто сломаться
и не суметь прочитать число по некратному адресу.
Вопрос, а как же мы тогда вообще существовали до этого?
У нас УБ все это время было, мы же писали вектор,
и в векторе мы тут делали вот это вот allocate,
которое в свою очередь делало new char.
Но чары не обладают никаким выравниванием.
Чары они на любой байт могут класситься.
Когда мы в векторе делали выделение памяти под несколько штук Т,
мы на самом деле выделяли чары,
а потом кастовали их в интерпрет кастом к Т звездочке.
То есть это что получается, если бы мы вектор W
таким образом создавали или вектор N.
У нас УБ, если вдруг мы new char не по адресу кратному 4 положили.
На самом деле нет. На самом деле все здесь хорошо.
УБ здесь нету, потому что оператор new умный.
Он застрахован от дураков, которые ничего не знают про выравнивание.
Оператор new, чтобы вы не выделяли,
он вернет вам адрес кратный 16 вообще.
Можете проверить.
На самом деле не кратный 16, а кратный так называемой штуке max align.
Max align T это такой тип в стандартной библиотеке,
который обладает наибольшим требованием к выравниванию из всех стандартных типов.
И он определен компилятором за вас.
И когда вы вызываете оператор new от чего-то,
он по умолчанию выравнивает возвращаемый вам указатель так, как если бы вы выделяли max align T.
Понятно, что такое max align T?
Ну, на уровне языка статусов нет.
Вы в оператор new получаете один байт.
Вот здесь, где мы тут писали, вот здесь.
Вы получаете один байт.
Но этот один байт, когда вы запрашиваете...
Давайте разберем по частям.
Вот я в оператор new прихожу, мне говорят, допустим, выдели один байт.
Я обращаюсь к функции malloc.
А как функция malloc себя ведет?
А также функция malloc тоже все выравнивает по max align T.
То есть всякий раз, когда вы имеете дело с динамической памятью,
когда вы делаете new, malloc, то, что они возвращают, выровненного по max align T.
Когда вы просите malloc выделить один байт,
на самом деле она, конечно, выделяет...
Я не знаю, там очень сложно все это устроено.
Она какую-то свою внутреннюю логику поддерживает.
Она, по факту, может выделить больше, чем один байт.
Но вы будете уверены, что вам дан один байт,
и дан он вам по адресу, кратному size of max align T.
Ну, один байт по max align T, это, конечно, сильно.
Расточительно, да.
Но, тем не менее, вот такое требование...
Не, это мало того, что это глупо,
потому что у нас в один байт не может поместиться тип,
который требует кратности больше, чем один байт.
Ну, я не знаю, глупо, неглупо, тем не менее, формально требования такие.
Как устроен malloc я сейчас не готов обсуждать.
Это вам, скорее всего, расскажут на втором курсе уже.
Malloc устроен очень сложно, там реализация занимает сотни строк.
Как называется параграф еще?
Параграф называется alignment and bit fields.
Параграф 9.5.
Выравнивание и битовые поля.
Вот.
Почему вдруг мы начали об этом говорить именно сейчас?
Да потому что как раз, когда вы будете писать свою задачу про stack allocator,
у вас возникнет эта проблема.
Покуда вы в allocator'е вызываете функцию locate,
оператор new, все хорошо.
Но если вы заведете stack allocator,
то есть массив на стеке, вот вы заведете массив чаров на стеке
и сделаете stack allocator на этом массиве.
Когда вы заводите массив чаров на стеке, там уже никакого выравнивания не гарантируется.
И если вы начнете на этом stack allocator'е выделять разные типы,
например, выдели два чара, а потом int решили выделить.
Если вы будете подряд так выделять этим stack allocator на стеке,
у вас возникнет беда, у вас int ляжет на адрес не кратный 4.
Если вы тупо будете писать stack allocator, не думая о выравнивании,
то вы схватите UB.
Поэтому, когда вы делаете allocator на стеке не с помощью оператора new,
а вручную распоряжаясь памятью,
сырым куском памяти чаров,
вам нужно думать о выравнивании.
Да и когда вы на куче делаете allocator, в принципе, у вас тоже могла быть проблема,
если вы на одном allocator'е выделили сначала 3 int, а потом решили double выделить.
Если вы так подряд будете выделять, то у вас double ляжет на адрес не кратный 8.
Покуда вы каждый раз к new заново обращаетесь, эта проблема от вас скрыта,
оно само там решается.
Но теперь вам нужно думать о выравнивании.
И для этого вам пригодятся ключевые слова align of и align as.
Давайте про них поговорим, значит.
Align of, для начала.
Есть такой оператор align of.
Это как size of, только align of.
Вы можете у произвольного объекта или у типа спросить,
какое у него требование к выравниванию.
Ну вот, например, вы можете спросить align of char, и вам скажут 1.
Можете спросить align of int звездочка, вам скажут 8.
Можете спросить align of любого типа, и вам скажут, какое у него требование к выравниванию.
Ну вот.
Ну вы можете, но это будет слишком расточительно как раз таки.
Если у вас, ну, если вам нужно выделять чары, а потом int,
то не стоит на max align t выравнивать, это слишком много.
Вот.
Это align as уже.
Я пока говорю только про align of.
Значит, align of это оператор, встроенный в язык, ключевое слово,
которое возвращает выравнивание данного типа в байтах.
Это ключевое слово.
Кстати, появилось только начинается плюс 11.
Как жили до этого, я не знаю.
Ну, сишные функции использовали какие-то.
И кроме этого еще ключевое слово align as.
align as это такая вот конструкция, такой спецификатор,
который можно писать после слова struct перед именем структуры,
чтобы сказать, как она должна быть выровнена.
Нет, вы можете, например, хотеть, чтобы структура была выровнена сильнее, чем,
по идее, она должна быть выровнена.
Например, у вас структура состоит из одного чара.
Тогда она будет выровнена по одному байт, то есть никак не выровнена.
А вы можете сказать struct align as 4, и она будет выровнена как будто ind.
А меньше она не может, чем ее?
Меньше, наверное, ob.
Ну, вы можете, например, сказать struct align as 64.
И это значит, она будет выровнена вообще по 64 байта.
А в чем мотивация?
Ну, мы хотим показатель позапихивать данные.
Вот. Вопрос.
Вопрос.
А зачем, может быть, нужно выравнивать какие-то типы сильнее, чем по 16,
по 32 или по 64, или даже по 128?
Нет, казалось бы, если у вас есть align as 16, если у вас максимальный тип для выра...
У вас все поля внутри структуры и так будут выровнены относительно друг друга.
Если вы кладете int, потом char, потом int, то после чара перед следующим int будет 3 байта пэддинг.
Зачем, казалось бы, нужно выравнивание больше, чем на 16 в такой ситуации?
Зачем, может быть, нужно выравнивать структуры больше, чем по max align?
Что же лучше разложилось?
Оно и так, если у вас поля подряд лежат, там и так пэддинг будет между полями, чтобы все выравнивания соблюдались.
Но вдруг еще один байтик и все, типа...
Нет, не понимаю.
Можно предположить?
Давай.
Ну пусть у нас есть структура, которую мы храним чаще всего какими-то большими блоками, то есть массивами.
И мы хотим в нее булов понапихать, не выделяя дополнительной памяти.
Ну вот мы в последние биты указателя просто эти булы засовываем,
зная, что все эти структуры лежат по адресу кратном 64.
Потому что у тебя тогда, когда ты эту структуру массивом размещаешь,
например, у нее размер 16, она будет занимать 17 байки, если там еще бул отдельно хранить.
И когда ты хранишь ее массивом, это плохо.
Особенно с счетом кратности, как оно будет ложиться.
Возможно, у тебя вообще байк 15 теряется.
То есть если у нас int и честное количество байков,
и мы можем платить в подряд по пять байков, а не четыре.
То есть если у нас int и честное количество байков,
и мы можем платить в подряд по пять байков, а не четыре.
Значит, ответ вот какой.
Иногда вам бывает нужно, но это уже выходит за рамки нашего курса,
и это вам скорее всего опять-таки расскажут на втором курсе.
Мы тут находимся на пороге низкоуровневого программирования.
Иногда бывает нужно, ну так скажем, конвейерно обрабатывать данные.
Бывают так называемые SSE инструкции у процессоров.
Когда вы берете и читаете сразу большую длинную цепочку байт,
например 32 байта за раз, и перемножаете сразу 32 битные числа.
Вот некоторые процессоры умеют, ну большинство на самом деле,
у интеловских, скажем, процессоров вы можете нагуглить векторные инструкции.
Vector instructions.
Это инструкции, которые позволяют вам сразу сказать,
ну это ассемблерные уже инструкции, у них есть тишные обертки,
но это выходит за рамки нашего курса.
Вот, например, вам можно быстрее перемножать числа или матрицы длинные так.
Вы берете и говорите, вот, кстати, господин Клич, в первом семестре именно так.
Именно это делал в своей реализации матриц, в том числе в своих реализациях биг интеджеров,
в том числе, там были векторные инструкции.
Вы просто считываете сразу много и перемножаете как бы 32 битные числа.
Вот.
Некоторые процессоры умеют это делать эффективно.
Вот.
И тогда вам нужно, чтобы эти числа лежали выровненные по 32.
Некоторые.
Это сейчас поменяю на все.
Ну, да.
Ну, формально не могу утверждать какие.
Ну, в общем.
Это выходит за рамки курса по C++.
И это даже выходит за рамки стандартной библиотеки.
То есть это расширение специальное, которые специфические для конкретных процессоров.
Можно на сайте интелла под ваш конкретный процессор найти, что там надо написать, чтобы оно так сработало.
Это вам даст ускорение во много раз, может быть, если будете перемножать длинные числа.
Но это скорее второй курс уже у вас будет.
Есть ли какие-нибудь стандартные библиотеки плюсов?
Ну, что-то типа.
Короче, чтобы можно было в compile time.
Если такое на процессоре доступно, то скомпилируйте.
Что можно поставить аргументы в constexpr, чтобы скомпилировать в зависимости от того, доступные эти.
Ну, вы можете вызвать.
Нет.
В стандартной библиотеке плюсов такого нет.
Вы можете вызвать функцию, там, какую-нибудь вида.
Если процессор сейчас у меня такой-то, ну, там, какая-нибудь низкоуровневая функция операционной системы,
которая говорит вам, у вас там поддерживаются эти операции или нет.
И если да, то начинать их вызывать.
Что-то такое.
И правильно делает, нефиг.
Ты что-то странное придумал.
Так.
Так вот.
Когда вы будете делать свой локатор, вам...
Так, это что-то не то.
Когда вы будете делать свой локатор, вам, вероятно, пригодится вот такая функция std align,
которая берет поинтер и выравнивает его по
нужному, ну, согласно нужному выравниванию.
Вот даже здесь в качестве примера есть, когда это может пригодиться.
Вот как раз, когда вы пишете свой локатор стековой памяти.
Вот.
В библиотеке Boost есть специальный локатор, aligned-локатор, по-моему,
который как стд-локатор только с фиксированным выравниванием.
Ну, вы можете сказать aligned-локатор от int 16, скажем.
И он будет выделять int вам с выравниванием по 16, ну, например.
Вот.
Это легкое упражнение написать свой локатор, который ведет себя как стандартный, но
кастомное выравнивание использует.
Что еще раз делает align?
align выравнивает, ну, берет поинтер, вот этот вот.
И возвращает поинтер выровненный по, ну, округляет, короче, до
ближайшего адреса кратного, чему надо.
Округляет вверх и decreases space argument by the number of bytes used for alignment.
Ну как, вас просят выделить int, а вы уже до этого, возможно, выделяли
сколько-то чаров.
Вы не можете так просто сказать следующий byte, возьми и верни, как будто я int выделил.
Конечно, у вас есть свой блок, и вам нужно сделать, да, сделать align и вернуть
только после этого.
Вот.
И есть еще одна функция полезная, тоже которую я вам покажу сейчас, называется
align unlock, начиная с C++17.
Эта штука, которая как mall lock, только с кастомным выравниванием.
Вы можете, это вообще C-шная функция, вот.
Если вы хотите уточнить, с каким выравниванием вы хотите вернуть вам указатель,
то вы можете использовать не mall lock, а align unlock, чтобы определенное
выравнивание было при этом указателе.
Не уверен, правда, что она может делать меньшее выравнивание, чем max align t.
Вот.
Но больше, чем max align t, может быть, вам понадобится когда-нибудь в жизни.
Ну и последняя штука – это битовые поля.
Это вообще кринш.
Значит, в C++ есть способ сказать, чтобы поле весило не байт, а несколько бит.
Там как-то очень больно это пишется.
Да, если вы такие, значит, экономные, что вам принципиально, чтобы ваше поле весило…
Причем оно реально работает, только когда вы массив этого выделяете.
Нет, почему?
Вот так вот это работает.
Ну, в смысле, потому что память под одну переменную все равно выделится кратно.
Значит, смотрите, смотрите, вот то, что я сейчас написал.
Я сейчас написал…
Почему это не рассказывают на программе в школе?
Не знаю.
Школа такая, видимо, не ваще.
Если я задам один тип, вот такой, и там скажу ему, выдели мне 5 бит, то он выделит мне 5, а 8.
Правильно, потому что размер одной штуки должен быть кратен.
Сайзов должен быть все равно целым числом байт.
А вот нет, там точно можно было какие-то упоротые размеры типа 27 брайт, но они реально работают, только если мы массив.
Вот этого я не знаю.
Я просто точно знаю, что так можно делать, и это иногда помогает запихивать задачи.
Вот этого я не знаю.
Но я знаю, что можно в рамках одной структуры можно указать полям, весить меньше, чем байт.
Это 4-х битовые поля сейчас.
Сайзов этой штуки будет 1.
Вот.
По стандарту здесь может быть либо int, либо unsigned int.
Да и все по-моему.
Ну то есть здесь либо char, либо unsigned char.
Ну короче, здесь ограниченное количество слов.
Здесь должен быть название какого-то целочисленного типа.
Вот сейчас у меня x и y это числа, которые могут принимать значение в диапазоне от минус 8 до 7.
Потому что у них 4-х битный размер.
Это значит, что 16 возможных значений.
То есть каждый из таких полей может принимать значение от минус 8 до 7.
А можно писать 2.1 или 2.0?
2.0, наверное, не знаю.
Ну либо CE, либо UB, 2.1 можно.
Это будет 1-битное поле, да.
Стоп, а что такое 1-битное 1.0?
Это 0 и минус 1, что ли?
А если int x 2.1, ну наверное да.
Но если написать unsigned int x 2.4, то это будет от 0 до 15.
А можно сделать не степень двойки?
Что? Не степень двойки? Да, можно.
Можно, например, сделать вот это 3, а вот это 5.
А число просто 2 тысячи уже сделано?
Да.
А они обязаны в сумме быть?
Нет, ну я могу сделать вот так.
Тогда это будет объект и структуру будет 2 байта весить.
Это число должно быть констатой?
Да.
Можно комплектировать?
Нет, нельзя.
Даже дробное нельзя.
2.1 это не то же самое, что bool?
Нет, конечно, bool это 1 байт, а int x 2.1 это 1 бит.
Если мы объедем всего 8 штук, а 2.1 это будет 8 байт.
Да-да-да.
Вот, эта штука очень полезна.
Лично я это видел в коде в промышленном.
Когда реализуются какие-нибудь сетевые протоколы, например.
Вот когда реализуется какой-нибудь протокол обмена сообщениями,
какой-нибудь TCP, например.
Там есть хедер, и в нем много разных флагов.
Там флаг сетового, флаг сего, флаг этого, того.
И вот это все в этой структуре, они битовые поля.
Нет, это флаги, которые говорят в пакете данных какую-то 1-битовую информацию несут.
Они могут 2-х битовые, 4-х битовые.
Но вот битвы поля очень полезны для этого.
Выравнивается до целого числа байт.
Я думаю, выравнивается.
Но было бы странно.
Должно выравниваться.
Не знаю.
Не пробовал.
Можно.
Но это...
Я не хочу это обсуждать.
Короче, откройте страницу TCP-референс, пробитые поля,
и прочитайте все, что с ними можно делать.
Два байта.
Два будет.
Я тебе и так скажу.
А, может он округляет до размера int вообще тогда?
Я не знаю.
Ну можно писать char, тогда 2 должно быть.
Возможно, он округляет до сайзов вот этого типа, который здесь указан.
Сайзов int.
Но если написать char, то должно не округляться.
Должно быть 2.
Да, наверное, вот чем дело.
Если вы пишете int, то он все равно выравнивает его.
То есть у него сайзов...
Короче, align of у него остается 4.
И поэтому он считает, что и сайзов тоже 4.
Да, вот видимо сейчас будет 4.
Но если написать char, то будет 2.
Вот так должно быть размер 2.
То есть тут у нас получается, что y он будет лежать как-то частично в одном байте, частично в другом.
Да.
То есть это получается как-то очень медленно, достаточно медленно работает.
Ну да нет.
Процессор все равно читает не по байтово, а сразу пачка из нескольких байт.
Наработать с этим гарсентом нормально не получится, да?
Получится.
Присваивать ему целые числа можно.
Но если ты переполнишь, то будет ub опять.
А, то есть если на первый момент будет ub?
Ну если вы переполните, то, наверное, будет ub, если это знаковое число.
И обрубится по модулю, если это будет беззнаковое число, как обычно.
Если я добавлю 2, 3...
То будет 5.
Если у меня обратно не подбавится.
Если это будет знаковое число, то это будет ub скорее всего.
А если это не беззнаковое число, то будет обрубление по...
Ну как unsigned int?
По модулю степени двойки возьмется.
Ну в плане по модулю 2 степени 3, да?
Ну да.
Так.
Господа.
Последний пункт нам надо обсудить, связанный с локаторами.
Давайте мы все-таки прочитаем.
Давайте мы все-таки сделаем рывок.
Его обсудим, и потом пойдем на перерыв.
А потом уже будет мух семантика.
Пункт довольно...
Криповый, значит.
Следующий, последний пункт, который нам надо обсудить в этой теме,
это так называемый scoped allocator.
Это шестой?
Да, 96.
Ну давайте всякого на inclusive тут, чтобы было полегче.
Чем нам scope, если мы с нас scope можем?
Чего?
Scoped allocators.
Смотрите, какая история.
Ну вот представьте, что у меня есть мой какой-нибудь allocator.
Ну я не знаю там.
Ну давайте я скажу, using my alloc равно...
Не, не так.
Вот я здесь скажу, template type name t.
Что-то плохо работает подсказка, даже не помогает мне.
My alloc равно std allocator at.
Ну просто допустим, у меня есть какой-то кастомный allocator.
Я...
Это потому что у меня скорее всего был до этого файл, в котором это было написано, я не знаю, кто это понимает.
Возможно он делает search по всей папке.
Вот.
Допустим, это какой-то кастомный allocator.
Я говорю, my alloc...
alloc.
Какой-то экземпляр моего allocator.
А теперь я завожу вектор...
из строк...
с my alloc...
в.
И начинаю pushback-ать туда строки.
abc...
Да, my alloc от std string.
Жесть.
Вот.
Чего?
Да господи.
My alloc от std string.
Вот.
Что...
вас здесь... ну вас кое-что должно смущать в этом коде.
Вот что тут... что тут не так?
Да, точно.
Это правда.
Я создал вектор от конкретного allocator.
По-моему это что?
Вопрос на отл-10?
Да нет, это вопрос на...
хор 7, я думаю.
Ну, есть проблема.
Представим, что my alloc это, скажем, стековый allocator.
Я хочу, чтобы ничего в динамической памяти не выделялось.
Но если я так напишу, не особо-то я добьюсь того, чего хочу.
Потому что...
string она же тоже делает new в своем конструкторе.
То есть я завел вектор из строк над каким-то там особым allocator.
Но сами строки в своих конструкторах тоже вызывают оператор new.
И они-то уже этот allocator не спрашивают.
Они используют стандартный allocator.
На самом деле, строки std-шные, они, конечно, тоже используют allocator в себе.
Но только они уже ничего не знают об этом allocator.
Они будут выделяться на стандартном allocator.
Вот давайте посмотрим на std-basic-string.
Вот. На самом деле, для тех, кто не знал, я сообщу, а для тех, кто знал, напомню.
Ну вот вообще это знать надо.
Значит, что std-string это на самом деле некоторый using.
А по-настоящему тип называется std-basic-string от char.
Вот. Но у basic-string есть и другие шаблонные параметры.
Но есть chart-rates, которые мы не будем, наверное, обсуждать.
А есть allocator.
Ну, короче, у basic-string есть параметр allocator, в общем-то.
Как и у любого контейнера.
Ну, string тоже вроде контейнер.
Формально, кажется, нет, но...
А, стд-basic-string удовлетворяет требования у локатора wire-container.
То есть string это тоже формальный контейнер.
А чем string в таком понимании, идейно, отличается от объекта?
Ну, она проще устроена. Там нету всяких...
Там нету этих заморочек, да, что тип может быть нестандартный.
Она подразумевает, что она работает с char, с символами.
И там есть операторы вывода, например.
Ну, там за счет того, что символы, а не произвольные типы, все проще устроено.
Вот. Есть cstr, например, data, ну и так далее.
Что?
А если std-basic-string отдавал?
Я думаю, так нельзя.
Так вот, у basic-string тоже есть allocator.
У basic-string тоже есть allocator.
Но при таком конструировании мы не используем этот allocator.
То есть string использует стандартный allocator.
А как нам сделать, чтобы строки, которые мы добавляем в свой вектор,
создавались на том же allocator, на котором создавался и сам вектор?
Нам нужно какой-то способ пробросить allocator во внутренние объекты.
Мы хотим, чтобы для объектов вектора использовался тот же allocator,
что и для самого вектора.
Ну, тот же тип allocator.
Вот.
Конечно, мы могли бы сделать так.
Вот так.
Значит, myalloc от char там, myalloc от std-string от myalloc от char.
И сюда нам придется, и тогда это не будет компилироваться.
Почему?
Потому что это не std-string от, ну, потому что это std-string от обычного allocator,
а myalloc, ну, давайте попробуем компилировать.
std-string is not a template.
А, потому что здесь надо написать не std-string, а std-basic-string
с шаблонными параметрами char, std-char-trades.
А char язык C++ не исчерпаем богат.
myalloc от char, myalloc от std-basic-string от char, std-char-trades от char, myalloc от char.
Ну, а еще у нас myalloc для allocator от std-string должен быть std-string от char.
Короче, я даже не буду, в общем, я просто все это отменю.
Ну, так и надо на самом деле.
Я не буду, в общем, доделывать это до того вида, в котором это будет работать.
Представляю вам решение.
Комитет по стандартизации думал-думал, как же победить эту проблему, и придумал.
Представляю вам std-scoped-allocator-adapter.
Итак, scoped-allocator-adapter.
От создателей C++-1 от set.
Defined только в заголовочном файле scoped-allocator.
Scoped-allocator.
Что эта штука позволяет делать?
Она позволяет вам не париться насчет пробрасывания allocator во внутренние объекты, а сама делает это за вас.
Как вы это используете?
Вы говорите, вместо вот этого вы передаете std-scoped-allocator-adapter от вашего allocator.
А мы должны?
Да.
Да, мы, конечно, должны.
Потому что мы на конкретном локаторе создаемся.
Вот.
Что будет делать этот scoped-allocator-adapter?
Как вообще это работать должно?
Вот ваши идеи.
Как должен быть реализован класс scoped-allocator-adapter, чтобы этот код работал корректно?
Давайте еще проверим, что он работает корректно.
Ну да, я здесь забыл std-string.
Ну, я просто отменил лишнее.
Вот.
Вот этот код работает корректно.
Утверждается, что теперь все строки создаются на том же самом локаторе, который я передал.
Ну, то есть, если бы это был stack-овый локатор, то никакой динамической памяти бы не выделялось.
Вопрос на... вот теперь уже вопрос на отл.
А что должно быть написано в классе std-scoped-allocator-adapter?
Как в нем должны быть реализованы методы, чтобы это корректно работало?
Взвешиваться можно?
Не могу пропагандировать суицид, к сожалению.
Может, он переобретеляет аккрата new?
Кто, а локатор? Нет, вы что, оператор new ни в коем случае.
Мы не пользуемся оператором new в контейнере.
Чего? Нет.
У вектора... Вектор от строк, но аллокатор в нем имеет тип scoped-allocator-adapter.
Это значит, что если у нас используется scoped-allocator-adapter, то это значит, что на самом деле мы храним где стринг,
a basic-string, char-trade и рома нашего нового кавринина.
И еще... Ты иногда отвечаешь, что у нас как бы другой тип уже векторе хранится как-то вначале.
Так, а почему мы в качестве параметра для вектора передаем аллокат уже другого типа, а не того же, как у нас указано в шоплоне?
Это может быть, если там, допустим, есть scoped-allocator, там может быть конструктор подходящий.
Вектор... Вот, вектор... Давайте вспомним, что делает вектор.
А может у scoped-allocator есть frame на все базовые классы?
И он может там менять тем более локатор?
Давайте вспомним, что делает вектор. Вектор в своем конструкторе создает...
Во-первых, он как вектор использует аллокатор. Давайте вспомним.
Во-первых, вектор выделяет на аллокаторе count-штук нашего типа.
Тут уже есть проблема, потому что нам нужно не string хранить, а string с нужным аллокатором.
Ну, забьем пока на нее. А потом он делает констракт.
Он делает констракт по указателю нужного значения.
То есть, когда мы делаем pushback-вектор, этот вектор берет аллокатор trades от нашего аллокатора, то есть от scoped-allocator, констракт по указателю от вот этих параметров.
Может внутри аллокатор trades есть функция, которая нам...
Нет-нет, аллокатор trades, напоминаю, аллокатор trades-констракт устроена просто.
Если в аллокаторе определен констракт, она вызывает его, а иначе просто вызывает placement-new.
Так мы не можем внутри аллокатор trades...
Аллокатор trades ничего не знает про scoped-allocator, это просто обертка, общая обертка над аллокатором, которая, если функция определяет, вызывает ее, иначе делает placement-new.
А аллокатор trades-то более высокий уровень абстракции, чем нам сейчас нужен.
А оператор new-то более низкий уровень абстракции, который нам сейчас нужен.
Проблема решается на уровне самого класса scoped-allocator-адаптер.
В нем так хитро определены методы, что когда вектор вызывает вот то, что он вызывает, scoped-allocator-adapter все подменяет так, что правильно все конструируется.
На самом деле в scoped-allocator-адаптере как раз переопределен метод констракт необычным образом.
Scoped-allocator-adapter это как раз пример аллокатора, у которого конструкт это далеко не просто placement-new, а что-то очень хитрое.
Что такое конструкт у scoped-allocator-adapter?
Давайте я, наверное, вам код открою готовый.
Прошлогодний просто.
А что из себя представляет scoped-allocator-adapter?
Он хранит в себе вот тот самый аллокатор, от которого он построен.
И когда, ну, allocate-diallocate работают стандартным образом, но когда у него вызывают конструкт, он ведет себя очень необычно.
Он не просто вызывает placement-new.
Он создает аллокатор нужного типа из того аллокатора, что он хранит, и уже на своем аллокаторе, который он хранит, вызывает конструкт от тех аргументов, которые ему дали, с дополнительным аргументом тот аллокатор, который он создал.
Это означает, что мы предполагаем, что все наши объекты так строены, что они себе конструкт предпринимают аллокатор?
Да, да.
Или последним. Смотрите, как это работает в конкретном случае вектора и строк.
Вектор говорит, сконструируй, пожалуйста, строку на данном указателе от аргументов...
Сейчас, мне кажется, что стринг все-таки...
Все-таки стринг придется другой тип указать. То, как я написал, все-таки не будет правильно работать, я вас обманул.
Потому что проблему с тем, что стринг по умолчанию другой аллокатор использует, мы не решим.
Вектор должен понимать, какие строки он хранит.
То есть стринг все-таки должно быть с указанным аллокатором.
У нас же по идее два вектора с разными аллокаторами, это тоже два разных типа.
С разными типами аллокаторов?
Ну да.
Значит, вот здесь вот я все-таки должен написать, using my string равно std basic string...
От нашего аллокатора, да?
от char std char trades от char и my...
Ну, скомпилировалось, он просто увидел, что у стринга нет этого нужного аллокатора и просто делал стринг по-прежнему через new.
Вот при такой реализации оно скомпилировалось, но все равно выделяло стринг через new.
А вот сейчас он будет выделять стринг правильно.
Значит, my lock от char.
Вот. Мне надо...
Не, my lock от char.
Чего?
Да это неважно.
А, ну можно сказать my lock от...
Ну можно сказать my lock от my string, наверное, да, хорошо.
Но это в принципе неважно, потому что он все равно же создать себе аллокатор нужного типа.
Вот, и здесь я пишу my string.
Потому что объект был бы... объект аллокатора был бы другим.
Он бы начал создавать на аллокаторе того же типа, но на другом объекте аллокатор.
Если у меня stack аллокатор, то у него могут быть разные буферы.
Он бы создал новый объект аллокатора из ничего.
И это бы означало, что строки он бы создавал на другом каком-то буфере, не на том, на котором создавался сам вектор.
Или он бы вообще не смог создать буфер, потому что он бы не знал, из чего создать новый объект аллокатора.
Суть в том, чтобы он создавал строки на том же самом аллокаторе, в смысле на равном данном аллокаторе.
У этого аллокатора будет другой тип, но как аллокаторы они будут равны, как объекты.
Потому что они будут указаны на один и тот же пул.
Нам надо, чтобы эти аллокаторы на одном и том же пуле создавали объекты.
И вот скоп аллокатор-адаптер позволяет заставить внутренние объекты создавать на том же самом, в смысле равенство аллокаторов, аллокаторе, на котором создавались внешние объекты.
Так вот здесь мы еще раз разбираем, как работает констракт.
Это пример аллокатора с нестандартным констрактом.
Мы получаем указатель на майстринг и аргументы, из которых надо создать майстринг.
А вот этот иф мы пока пропустим, будем считать, что это верно.
Дальше мы говорим, пусть innerLog это t2.2.allocatorType.
Не забываем tapeName, конечно.
Мы предполагаем, что внутри типа t определен usingAllocatorType.
И вот это ключевое предположение, на которое мы опираемся.
Но внутри стринг, как и внутри любого контейнера, определен внутренний тип AllocatorType.
Это требование к контейнеру, там обязан быть определен AllocatorType.
Таким образом мы понимаем, каков тип Allocator, на котором делать строку.
Дальше мы создаем объект такого типа, называем его innerLog, из того Allocator, который есть у нас.
То есть мы создаем копию того Allocator, который есть у нас, но это уже получается Allocator на char, а не Allocator на string.
А дальше мы вызываем констракт от нашего Allocator.
InnerLog теперь это Allocator на char.
Мы из строки, вот это t это string, t это myString.
В myString определен AllocatorType.
И там написано usingAllocatorType равно вот тот Allocator, на котором string делается.
Это myAllocator от char.
Так что вот этой строчкой мы узнали, какой тип должен быть у Allocator, на котором делать строку.
Теперь мы вот такого типа создаем innerLog и делаем его копией нашего Allocator.
ourLog это myAllocator от string.
innerLog теперь это myAllocator от char.
Мы делаем копию Allocator от string, и типа этой копии будет Allocator от char.
А дальше мы у нашего Allocator, который от string, вызываем констракт через AllocatorTrades.
По указателю на string от тех аргументов, которые нам передали, и с последним дополнительным аргументом innerLog.
То есть мы на самом деле вызываем вот такой конструктор от строки, вот здесь вот.
Мы по сути вызываем вот этот конструктор, вот этот конструктор, с последним аргументом Allocator.
Вот. То есть мы попадем в этот конструктор.
Вот здесь вот мы на нашем Allocator, Allocator.construct от pointer, а дальше передаем аргументы строки, и последним аргументом даем ей ее Allocator, который ей нужно.
Который является копией нашего Allocator, что приведет к тому, что они создаются на одном и том же пуле.
В качестве упражнения предлагаем самостоятельно реализовать Destroy для скопт AllocatorAdapter.
Остался вопрос, что такое ifconstects.std.usersAllocatorV.
А это как раз вот этот ifчик, который проверяет, правда ли внутри нашего типа T есть AllocatorType, который конвертируем в наш AllocatorType.
UsersAllocatorV это такая метафункция, которая проверяет, правда ли в нашем типе T есть usingAllocatorType, равный такому типу, что его можно создать из нашего Alloc.
Это просто метафункция, которая определена в стандартной библиотеке.
UsersAllocatorV это шаблонная переменная.
На самом деле это структура usersAllocator, в которой есть статик const bool value равно.
И там написано шаблонное маги, которое проверяет, что правда в типе T есть AllocatorType, конвертируемый в наш Allocator.
То есть мы должны в каждом контейнере подписывать...
Да, это требование к контейнеру.
Это входит в число требований namedRequirementsContainer.
Там должен быть указано AllocatorAwareContainer.
Если это AllocatorAwareContainer, то в нем обязательно должен быть AllocatorType и написано вот это.
А если это неверно, то есть если там окажется, что нет AllocatorType, вот именно поэтому это под constexpr.
Если окажется, что та строка, которую нас просят конструировать, она не поддерживает такой Allocator.
Это как в первом примере, который я разбирал, когда я не забыл указать Allocator в строке.
Я попаду сюда, а тут мы просто игнорируем Allocator и тут мы просто сделаем констракт без какого-либо Allocator.
То есть мы просто сделаем вот это, но уже без InnerLog.
Просто сделаем констракт на нашем Allocator от argument, но без InnerLog.
Это то, что происходило в первом примере и CE не было.
Это упрощенная реализация констракта, там на самом деле все еще хитрее, но это мы пока опустим.
В качестве упражнений можно реализовать Destroy.
Ну, в общем, кто еще раз Main.
Вот.
Чего-чего?
Мы не решили проблемы с ним, потому что это не STD String.
Это все равно Basic String.
Ну, я, кстати, думаю, что можно...
Вот так, может быть, оно даже скомпилируется, но я не уверен, может и не скомпилируется.
Сейчас.
Так, нет, не туда.
Минус STD C++17.
Компилируется.
Да, потому что у MyString есть конструктор, принимающий только один аргумент, а второй аргумент по умолчанию.
Нам не нужно...
Ну, если у нас есть вот этот вот конструктор, вот этот.
Вот этот, ну вот этот, да.
У него второй аргумент по умолчанию, и это не explicit конструктор, поэтому мы все равно в него попадаем, даже не указывая явно Allocator.
Поэтому даже вот такой код компилируется, несмотря на то, что типа MyString, а не STD String.
Потому что вот этот конструктор не explicit, а второй аргумент у него по умолчанию.
Он понимает, что я хочу сконструировать Mat String от одного аргумента, который является char звездочкой.
И второй аргумент у меня не указан, но у меня есть подходящий конструктор.
Как сконструить MyString, а второй аргумент просто по умолчанию подставить.
Ну, кто хочет, будет хотеть на экзамене отел, тот это заботает, пересмотрит, а остальные забейте.
Все, мы закончили тему Allocators, перерыв, и сейчас будет Move Semantica.
И соберемся.
Move Semantica и R-Value ссылки. Это то, чего все, я думаю, долго ждали. Пришла пора.
Вот. Ну, я всегда перед этой темой делаю дисклеймер, что с первого раза вы, скорее всего, не поймете.
Поэтому, чем раньше вы начнете пытаться понять, тем лучше.
Вот. У тех, кто начнет в феврале, гораздо больше шансов разобраться к концу семестра, чем у тех, кто начнет в конце семестра.
Оптимистичная тема.
Вот. Да. Я лично понял раза с четвертого, когда мне четыре раза прослушал в разных источниках и понял.
Вы можете, конечно, меня перебивать, задавать вопросы, пытаться понять, чтобы.
Но если вы не поймете все равно, не страшно. Вы можете еще несколько раз пересмотреть, и потом поймете.
А если поймем, то значит, может, это неверно.
Да. Если вы поймете с первого раза, ну, может быть, вы действительно такой умный, а может быть, вы что-то неправильно уложили у себя в голове, и надо еще раз пересмыслить.
Ну, параграф 10.1.
Идея.
Мув семантики 10.1.
И волшебная функция steady move.
Вот. Давайте вспомним, какие у нас были проблемы, связанные с лишними копированиями.
Первая такая проблема у нас была, когда мы реализовали функцию swap.
Вот функция swap, если попытаться реализовать для двух произвольных типов, она у нас была написана так.
Мы объявляем новый объект tmp, который равен x, потом x равен y, потом y равен t.
Когда вы это делали для интов, все было нормально.
Когда мы только ссылки изучали в первый раз.
Но когда у нас возникли нетривиальные объекты, наша реализация функции swap стала непригодной.
В таком виде, вот как сейчас написано. Понимаете, почему эта реализация swap не годная совершенно?
Потому что, например, если это строки, то это будет линейное время, не просто линейное, а тройное просто копирование.
Каждая строчка этого кода это копирование строки целиком.
Хотя, казалось бы, можно просто слопнуть указатели, но как это сделать в общем случае для всех типов непонятно.
Ну ладно. Следующая проблема.
Вот у нас есть вектор. Допустим, опять вектор и строк.
И мы в этот вектор решаем положить, вот прям буквально то, что мы недавно делали, какую-нибудь строку abc.
Понимаете ли вы, почему это плохо? Работает, вот если писать это так, как мы писали раньше.
Здесь опять лишние действия очень неприятные.
Потому что мы два раза вызовем конструктор строки на самом деле, и два раза обратимся к нью, хотя могли бы один.
Почему? Ну потому что давайте вспомним внимательно, что происходит при pushback.
У нас изначально в векторе, ну вектор у нас пустой, там допустим у нас, ну скажем, ладно, мы сделали v.reserve на 1.
То есть мы даже эту часть опустим. То есть что там вектор сам резервирует, это ладно.
У нас память выделена под объекты в векторе. И вот мы говорим v pushback abc.
Pushback принимает const t ampersand, t это std string. То есть создается std string из вот этого abc, чтобы передаться в параметр pushback.
Да, вот в этом месте явно создается std string, который принимается по константной ссылке в метод pushback.
После чего pushback там что-то делает, и дальше там написано new от ptr, t от того, что нам дали.
Да, placement new. Что такое t? t это std string. То есть в методе pushback в какой-то момент написано new от ptr, std string от вот этот вот x, который положили в вектор.
Это что такое? Это опять создание std string из того std string, который только что нам дали.
То есть мы один раз создали string, когда передавали ее в качестве параметров pushback.
Второй раз создали string из первого string, когда уже клали ее непосредственно в вектор.
Понимаете проблему? Мы два раза создали string на самом деле, когда так написали.
А уж совсем неприятно это выглядит, когда мы делаем резерв.
Ведь помните, когда мы реализовали вектор, у нас в какой-то момент нужно было реалацировать память.
Вот мы берем старый массив и перекладываем его в новый массив. Что такое перекладываем?
Мы берем все эти объекты и говорим new от вот этого вот pointer t от aritova.
То есть мы берем placement new, вызываем n раз на каждый вот этот объект.
В случае строк это означает, что мы создаем n новых строк каждой из соответствующей старой строки.
Но что такое создание новой строки и старой строки? Это опять new.
То есть каждый раз, когда мы перекладываем, вот если использовать нашу старую реализацию вектора,
ту которую мы написали, каждый раз, когда мы делаем реаллокацию, мы n раз вызываем new,
когда нам нужно переложить, нет бы просто взять и вот сюда присвоить тест pointer,
которые в этих строках хранились, потому что строки же сами хранят pointer на какие-то массивы чаров.
Нет бы нам взять и как-то умудриться вот сюда просто записать поля этих строк, чтобы pointer просто остались теми же.
Но нет, мы так не умеем делать. Мы конструируем полностью строки заново.
И не только строки, но любые объекты, которые мы бы перекладывали в векторе, мы бы их конструировали заново.
То есть мы n раз копируем.
То есть нам больно.
Да, это очень неэффективно.
Вообще это не только в pushback такая ситуация.
Вот, например, представьте, что у вас есть какая-нибудь функция, которая...
Ну, действительно, даже, к примеру, не pushback, а любая вообще функция,
которая принимает объект по константной ссылке и потом этот объект где-то сохраняет, скажем.
Вот.
Она могла бы этот объект сохранить прямо вот в его первозданном виде, не создавая копию.
То есть вот вы создали какой-то временный объект и отдали его в какую-то функцию, которая должна его сохранить.
И в нормальной ситуации вы бы могли вот этот вот временный объект, только что созданный, как-то положить сразу на нужное место, и все.
Но нет.
Если вы приняли по константной ссылке, вы вынуждены копировать.
И вот в таком сценарии у вас будет двойное создание объекта одного и того же.
И еще один сценарий – это когда вы бросаете исключения.
Вот, когда вы пишете throw что-нибудь, например, ту же строку несчастную.
Вот я говорю throw s, где s – это некоторая строка.
Эта строка копируется, как вы помните, в специальное место памяти, где будет лежать это исключение, пока оно летит.
Казалось бы, зачем?
Ведь ну зачем это, получается, надо создать новую строку из старой строки?
Но ведь та строка сразу же сейчас будет уничтожена.
Зачем копировать-то?
Можно как-то вот просто поля переложить, что ли?
Чего-чего во время копирования?
Ну если во время копирования вылетает исключение, то да, то полетит в итоге оно.
Но этот вопрос мы уж не обсуждаем сейчас.
Вот, кстати, про реаллокацию вектора.
Почему нельзя просто побитого скопировать память?
И скользь я про это говорил в прошлом семестре, а может и в этом, но, возможно, все забыли.
Почему бы не решить проблемы с реаллокацией вектора так?
Просто побитого скопировать память отсюда-сюда.
Это может быть какой-то указатель на какое-то свое поле.
Да-да, если там какие-то кросспойнтеры, ну если в каком-то, если эти объекты...
Если там что-то сложнее, чем просто поле...
Если там объекты, которые в полях ссылаются на другие свои же поля, то все сломается.
Вот.
И, кстати...
Чего?
Что?
А, вот все.
Да.
Вопрос в том, почему нельзя скопировать объект без вызова конструктора.
Почему нельзя сделать просто memcpi побитого вот этой памяти в эту, когда мы делаем реаллокацию вектора?
Потому что, если объекты были нетривиальными такими, что, например, у них были поля, ссылающиеся на другие поля, то все сломается.
И фат структура тоже не хватает.
Вот.
Вот.
Можно бы было написать if constexpr данный тип является int или чем-то там примитивным, и тогда скопировать побитого, а иначе...
Но с этими случаями и так проблем нет.
С этими случаями и так проблем нет.
Вот если структура нетривиальная, как ее перекладывать, непонятно.
Кстати, спойлер.
std string как раз так и устроено.
Там одни поля ссылаются на другие.
Вообще говоря.
Но это очень хитрое знание, которое мы потом разберем.
Ну, короче, вот уже для std string бы это работало неправильно в общем случае.
Потому что на самом деле в std string так устроена хитра оптимизация, что там как раз одно поле является ссылкой на другое, вообще говоря.
И как раз для std string уже бы это сломалось.
Но если вы пока не понимаете, то забейте.
Потом мы разберем подробно, как std string устроен внутри, и вы поймете.
Ну да ладно.
Mc5 побитого копирует.
Когда мы копируем строки, мы перевыделяем память под строку заново.
Медленно, конечно, мы нью должны вызывать на каждое копирование строки.
Еще раз.
У тебя есть 10 строк.
Каждая строка это указатель на огромный массив.
И так далее.
Нет бы взять и переставить указатели, чтобы они здесь лежали.
Нет.
Мы берем и говорим, возьмем эту строку и перевыделим вот эту память заново.
И выделим этот массив и перекопируем этот массив.
А этот забудем.
И так происходит у нас сейчас реаллокация вектора.
Итак, n раз.
На каждую строку вот это происходит.
Чего бы нам не переложить указатели.
А вот не получается.
Решение.
Давайте добавим волшебную функцию, которая называется std move.
Которая делает какую-то магию, после которой все быстро перекладывается.
Значит, смотрите.
Чего?
Решение современное выглядит следующим образом.
Я говорю, tmp вот здесь равно не x, а std move от x.
x равно не y, а std move от y.
Ну и y равно не t, а std move от t.
Создаем.
Но мы не копируем объект полностью.
Вот утверждается, что если написать так, то каким-то магическим образом.
При условии, что тип поддерживает move семантику, что бы это не значило.
Но все стандартные типы таковы.
В общем, если написать так, то каким-то магическим образом.
Для всех стандартных типов вместо того, чтобы копироваться.
Будет происходить перемещение.
Что такое перемещение?
А это как раз вот то, что мы и хотим в случае строк.
Что мы не пересоздаем вот этот вот огромный массив.
А по байтикам просто перекладываем поля и все.
Вот каким-то магическим образом, непонятно каким.
И не будет понятно еще в ближайший час, наверное.
То есть в ближайшую неделю получается.
Сегодня я не успею объяснить, что на самом деле делает move.
Я понимаю, что это звучит довольно настораживающе.
Но, к сожалению, я пока не могу никак лучше объяснить, что там происходит.
Я пока лишь говорю, что у нас есть следующие проблемы.
Я их вам перечислил.
У нас есть общая проблема.
Заключается в том, что иногда, когда объект хотелось бы просто переложить поля в другое место.
Нам приходится копировать целиком, вызывая конструктор копирования.
И для таких случаев стандарт придумал, комитет придумал следующее заклинание.
Вот пока иначе как заклинание я его воспринимать вам не предлагаю.
Мы обязательно разберемся досконально, что происходит на самом глубоком уровне.
Но пока, если я начну сразу говорить все формально, что происходит, вообще будет ничего не понятно.
Поэтому пока мы просто думаем, что это некоторое заклинание, которое чудом вместо того, чтобы копировать, перекладывает поля.
Ну вот здесь он не бесполезен.
Вот в этих ситуациях он действительно будет бесполезен, но это тоже мы пока не понимаем почему.
Но я пока утверждаю, что если написать вот здесь вот move и если написать вот там, где мы перекладываем тоже move,
а не копирование, то чудесным образом вместо копирования будет перекладывание полей просто.
В смысле STD move от ABC?
То есть когда мы вот там в placement new, да, ну STD move от ABC звучит довольно странно.
И ну так все-таки не надо писать, потому что оно и...
Ну там на самом деле vector и так реализован по-умному, что и без STD move оно нормально будет работать.
Просто мы пока по-туковому реализовали.
Да, но если написать STD move, то все равно должно работать.
На самом деле и без него будет работать хорошо, просто потому что vector очень умно реализован.
Но это мы потом поймем как он реализован.
Но STD move действительно здесь можно не писать, это и так будет быстро работать.
STD vector реализован по-умному таким образом, что вот это не приводит ко второму копированию.
Правда, что у нас вот равно, которое слева от STD move, это его часть?
Нет, ну нет, STD move это какая-то волшебная функция.
Она что-то делает странное с объектом, после чего его присваивание работает не как копирование, а как перекладывание полей.
А не слишком долго работает?
Нет.
Это правда, что vector внутри вот этого умного копирования используется STD move?
Ну да, он работает, он использует.
Вот давайте теперь с учетом новых знаний напишем как выглядит реаллокация будет.
У нас раньше было написано примерно следующее.
У нас был написано следующее.
Примерно такое у нас было написано, правда?
Когда мы на новое место кладем объекты старого массива.
Это копирование.
Вот.
Как теперь это написать, чтобы это работало быстро и волшебно?
Не R и T, а STD move от R и T.
Ну, которые поля перекладывают, да, значит.
Вместо того, чтобы создавать T от R и T, теперь мы создаем T.
От STD move от R и T.
Точно так же, как здесь.
Вместо того, чтобы присваивать TMP просто X, мы присваиваем TMP STD move от X.
И каким-то волшебством это работает за от ениса, а не за от N.
Значит, я пока не буду отвечать на этот вопрос.
Да, правда, но я пытаюсь рассказывать это в таком порядке, чтобы правда открывалась вам постепенно.
Если мы попробуем применить STD move к условно нашему написанному в первом семестре стрингу, оно будет нормально работать, просто по-прежнему медленно копироваться.
Да, в вашем первом семестре написанный стринг, к сожалению, не поддерживает действие move правильно, поэтому копироваться оно все равно будет по-прежнему.
Но стандартный контейнер, да.
Получается, он сделает одно конструирование и одно перемещение.
Да.
Так вообще переместили N объекта за от N.
Нет, нет, от N будет замять перемещение одного объекта.
N объекта такая, что от N.
То есть, со своим объектом move не обязательно будет работать быстро?
Я пока утверждаю только про стандартные объекты, про наши классы.
Сейчас мы поговорим, как сделать, чтобы move работал корректно с ними.
Итак, конец первой серии, типа занавеса.
Первое знакомство с move выглядит так.
У нас были такие проблемы, и тут пришла волшебная функция move, которую мы начали писать всегда, когда мы не хотим копирования, а хотим эффективное перемещение.
Каким-то чудом что-то внутри происходит совершенно непонятное, и, значит, для всех стандартных типов оно работает корректно.
Класс.
Мы ничего пока не понимаем, как это работает, но работает.
Конец первой части.
Вот на этом понимание move заканчивается у, не знаю, мне кажется, у...
У нас.
Ну, я не знаю, у вас, да.
Ну, я не буду утверждать насчет прям половины, но мне кажется, ну, где-нибудь треть всех людей, которые пишут на C++, примерно этим пониманием и ограничиваются.
В принципе, его достаточно, чтобы что-то писать.
То есть к функции move можно относиться как к черному ящику.
Она просто каким-то чудом заставляет объект эффективно перекладывать поля вместо того, чтобы копировать.
Вот.
Вы можете...
Нет, только к стандартной.
Ваши нет.
Вот.
Вот.
Вот.
Часть вторая.
Значит, серия номер два.
Поддержка move для своих объектов.
Да, да, уже, уже.
Да, да.
Прямо сейчас.
Ну, можно выключить свет, похлопать и включить свет снова.
Спасибо, спасибо.
Отлично, отлично.
Замечательно, замечательно.
Если что, я шутил, это было не обязательно.
Ну ладно.
Так, значит, теперь поддержка move для своих объектов.
Окей, мы поняли, что функция с demove это какая-то волшебная функция, которая для всех стандартных объектов заставляет их эффективно копироваться,
эффективно перемещаться вместо копирования, но для наших объектов пока это не работает.
А как сделать, чтобы для наших объектов это тоже работало?
А нам нужно для этого у своих объектов явно определить специальные методы, которые будут говорить, что им делать, если от них вызывается вот это вот.
То есть, когда мы говорим, да, название параграфа, значит, поддержка move в семантике, support for custom types.
Значит, как научить ваши классы тоже правильно работать в таких ситуациях с move?
На самом деле нам надо определить две новых операции для своего типа, чтобы для него это работало.
А какие это операции?
Это так называемые move-конструкторы, move-оператор присваивания.
Мы их обе использовали. Что происходит, когда я говорю t, b равно std move от a?
Ну, у меня есть... я создаю b не из a, а из чего-то, что получилось после std move от a.
И мне надо вот эту операцию для своего типа отдельно определить. Пока она отдельно для моего типа не определена, она будет работать как обычное копирование.
Если я для своего типа эту операцию определю специальным образом, то вот она так и будет работать, как я напишу.
Ну, понятно, что для всех стандартных типов они определены правильно.
Вот это move-конструктор. Вот если я написал t, b равно a, это был бы копий-конструктор.
А вот если я написал t, b равно std move от a, это я обратился к move-конструктору.
И мне надо его определить. А дальше я могу написать, допустим, a равно std move от b.
Ну, это какая-то бессмысленная деятельность, но вот теперь я вызвал move-оператор присваивания.
То есть раньше у меня был обычный оператор присваивания, когда я говорил a равно b.
Это копирующий оператор присваивания.
А если я присваиваю не просто b, а std move от b, то будет пытаться вызваться move-овающий оператор присваивания, что является отдельной операцией.
Move случайно не портит объект, от которого мы его выбрали?
Это пока, значит, ты забегаешь вперед, ответ нет, но подробности будут позже.
Что?
Так вот, нам нужно определить две новых операции для своего класса, чтобы он поддерживал move-семантику.
Вот умение поддерживать такие операции и называется поддержкой move-семантики.
Так, подожди.
Давай без забегания вперед, пожалуйста.
Тут и так совершенно очень трудно не сбиться и не запутать всех.
Я из всех сил стараюсь не говорить ничего лишнего пока.
Пока мы только понимаем, что вот есть такие две непонятные операции, нам их надо определить для своих типов.
И есть непонятная функция move вообще, когда вы совершенно не поняли, что делать.
Хорошо, давайте на примере string я напишу, как это должно выглядеть.
Смотрите, вы же помните, как конструктор копирования и оператор присваивания у string выглядит, да?
Давайте я вам для примера напишу, как должен выглядеть конструктор перемещения от string.
То есть как должен выглядеть этот метод у string, чтобы при перемещении все корректно работало.
Давайте вспомним, что у меня там есть char звездочка r или str.
У меня поля string какие.
Там еще есть allocator, но давайте пока без него, и так тошно.
Но вам, конечно, это все нужно будет с allocator поддерживать.
Size tss и size tcap, как обычно.
Три поля.
Как будет выглядеть конструктор перемещения для string?
Как и любой конструктор, он начинает с слова string.
А вот дальше еще одно чудо-юдо, которое совершенно непонятно, что означает.
Но надо это просто принять и смириться пока.
Значит, тип принимаемого аргумента будет таким.
String с двумя амперсандами.
Значит, это такой тип, новый.
Ссылок на ссылку не бывает, но это не ссылка на ссылку.
Это в общем, это нечто, с чем надо пока просто смириться.
Мы уже смирились с тем, что есть волшебная функция с дому, в которой непонятно, что делает.
Теперь нужно смириться еще кое с чем.
Можно так писать много, когда, но пока мы...
Воспринимайте это просто как часть синтаксиса объявления конструктора и считайте, что пока больше нигде так писать нельзя.
В общем, я ухожу от ответа на эти вопросы.
Я просто говорю, что чтобы определить для своего класса мувающий конструктор, нужно написать вот такую очень странную вещь.
Ничего не понятно.
Значит, вот непонятно, что это за тип.
Это особый вид ссылки, давайте так скажем.
Это особый вид ссылки на стринг, который непонятно, чем отличается от обычной ссылки на стринг.
Непонятно, где еще это можно использовать, но я вам гарантирую, что, по крайней мере, вот эту задачу мы решим таким способом.
Да, да.
Ну хорошо, так уж и быть скажу.
Это называется R-value ссылка на стринг.
R-value defines это единый термин.
R-value defines reference, ну в смысле это единый термин, его нельзя понимать, как R-value отдельно, reference отдельно.
Так вот.
Давайте поймем, как должен выглядеть такой конструктор.
Ну как и любой конструктор, список инициализации, что он должен сделать?
Вот сейчас вопрос на понимание, что надо написать в таком конструкторе.
Надо сказать, что str это просто s.str.
Дальше.
Cz это s.cz.
Cap это s.cap.
Тело конструктора, что-нибудь надо писать в нем или нет?
Ну вообще кажется стоит.
Что?
Типа как-нибудь...
Короче, у нас по идее сейчас появилась очень большая проблема, что у нас две разные строки.
Конечно.
Нам обязательно надо сделать s.str равно nullptr, как минимум.
Как ты в конструктор передашь ссылку на себя?
Ладно, другой вопрос.
А вот зря, ты не знаешь, вообще-то это можно сделать.
Нет, на самом деле можно написать ta равно stdmove от a.
Этот случай считается кринж, и мы его не разбираем.
Ну просто не принято так делать.
А если случайно так получилось?
Нет, мы с вами говорили.
ta равно a вызывает конструктор копирования от себя на неиннициализированной памяти.
Это просто убе.
Короче, в конструкторе такого не бывает.
В операторе присваивания мы разберем этот случай.
Понятно ли, почему вот это обязательно нужно написать?
Иначе будет беда большая.
s.str обязательно надо сделать nullptr, иначе все будет неправильно работать.
Кому, кто понимает, почему так надо написать?
Мы испортили англичан.
Правильно, да.
Когда мы присвоили строку...
Естественно, мы когда сделали вот такое,
после этого a испортилась, там стало nullptr.
Нет, я говорил, что функция stdmove не портит объект.
Но я не говорил, что присваивание не портит объект.
Это разные вещи.
Это не все.
Надо занулить поля еще у s.
Разве реклама не честна, что будет лежать после?
Нам нужно оставить объект s в корректном состоянии.
То есть соблюсти все инварианты.
Мы ему сделали pointer nullptr.
То есть после того, как мы так сделали, объекта как бы становится пустым.
Мы сделали ему nullptr указатель и занулили поля.
Мы должны после этой операции оставить объект s в корректном состоянии, но пустым.
Вот что должен делать move-конструктор.
Если мы замуваем вектор, то тот вектор, из которого move-нули, будет пустым.
Мы заберем просто указательный динамический массив,
а ему оставим nulli в полях и nullptr.
Да, после move-а объект должен остаться в корректном состоянии, но пустым.
После не самого move-а, а после вот такого конструктора от него.
Чего?
Мы прямо сейчас поменяли rvalue.
Да?
Давай ты... вопрос некорректен.
rvalue... я напоминаю, что value это термин относящийся к expression.
Я не знаю, что такое поменять expression.
Value бывают expression, а не объекты.
Давай ты уточнишь свой вопрос, когда у нас пара закончится.
Я сейчас покажу, как написать оператор присваивания, и на этом мы закончим на сегодня.
Давайте напишем напоследок оператор присваивания.
move еще оператор присваивания.
Что он должен делать?
Ну, я думаю, вот здесь мне места хватит.
Значит, оператор присваивания должен возвращать ссылку на string, обычную на сей раз.
Вот, оператор равно...
И принимает он опять такую же странную вещь.
String двойной амперсант.
S.
Вот, что будет делать move еще оператор присваивания?
Вот. Ну...
Ну, в принципе, можно сделать copy and swap, только в данном случае это будет move and swap.
Ну, можно сказать t...
Ну, помните, у нас было copy and swap?
Можно сказать t-копия равно std move от s.
Вот.
Потом мы делаем swap полей себя с копии, и все на этом заканчивается.
А почему мы не можем сразу с копии?
Или у нас есть...
Типа, у нас же тогда, ну, останется s в каком-то корректном состоянии.
Сейчас, сейчас, сейчас. Что вы предлагаете сделать?
Сразу просто свопаться с полями s.
Своп с s?
Да.
Так s не уничтожится.
Мне нужно, чтобы это был локальный объект, у которого бы вызвался деструктор по окончании.
Надо, чтобы мои поля уничтожились, в том числе вызвался delete квадратный скопчик для моего массива.
То есть мы не можем эти поля оставить в другом объекте, типа...
Мне надо, чтобы s пустым объектом стал после того, как я сделал move от них.
Он не просто в валидном состоянии должен быть, он должен быть именно как был пустым.
Ну, формально вы можете оставить его в непустом состоянии, но это очень странное поведение.
Кажется, я не знаю, вас проклянут.
Кажется, стандарт вам не запрещает так делать, но...
Просто здравый смысл запрещает вам оставлять объект в непустом состоянии.
Если я сейчас ничего не понял, что делать?
Я же говорил, что это нормально.
Нет, давай ты можешь что-нибудь спросить.
Сейчас, подожди, чего?
Ой, string, конечно.
Так, давайте я еще раз на это посмотрю, чтобы, на всякий случай...
Так, значит, ну если бы это был копирующий оператор писания, то мы бы просто написали string copy равно s, swap copy и все.
Правильно?
Swap это метод, который мы уже давно реализовывали еще в первом семестве.
Просто swap-ает наши поля с полями вот этого.
В том числе указатель swap-ает.
Значит, а теперь мы просто move-нули, то есть мы вызвали на самом деле вот этот конструктор,
занулили вот этому челику поля,
этот челик теперь стал как этот челик, и мы swap-нулись с ним.
Теперь мы стали как этот челик,
а наши поля теперь в копии, но копия локальная, поэтому у нее вызывается деструктор в конце тела,
и она уничтожается.
Корректно.
Сейчас, что получается, что мы приравнялись к какой-то другой строке
и сломали этим самым эту строку или как?
Нет.
Эту строку мы занулили.
Не, вот как извне для нас выглядит, что у нас там была строка, а мы сказали string b равно...
Я сказал b равно std move от a.
Конечно, мы занулили строку a.
После такой операции строка a становится пустой.
Не, а почему b равно std move?
Ну, это присваивание, мы вот именно это сейчас реализовали, как работает присваивание.
Ага.
Еще раз, зачем собственно?
Так понятно.
Ну, это идиома copy-and-swap.
То есть это оператор равно именно через move?
Это move-ующий оператор присваивания.
Он отличается от копирующего просто тем, что здесь move написано.
Копирующий был бы просто string copy равно s swap copy.
Что такое std swap?
Ну, ты мог бы.
Просто std swap.
Он сам себе содержит move, и это получалось бы в бесконечной рекурсии,
потому что он бы снова вызывал соответствующий конструктор или оператор присваивания.
Стд swap здесь ты не можешь вызвать, это из копии,
потому что std swap в себе содержит t, tnp равно std move от x,
а это значит, ты бы пришел в этот конструктор,
а потом ты бы опять пришел в этот оператор присваивания.
А в своем swap'е ты просто swap'ешь поля.
Да.
Ну, Лоберто, наверное, надо написать еще return this.
Да, да, да, да, да, да, да, конечно.
Нам точно-то надо написать std move?
Вот здесь?
Ну, у нас же и так рвались, сука, передается.
Так.
Нам надо вызвать move конструктор.
Чтобы вызвать move конструктор, надо написать вот такое заклинание.
Вот это заклинание, и вот это заклинание никак не связано.
Слово rvalue, не смотрите на него.
Вы начинаете делать то, что ни в коем случае нельзя делать,
пытаться из каких-то обрывков сказанного вывести то, что я не говорил.
Это ошибка, нельзя так делать, короче.
Пока лишь мы знаем, что есть вот такое заклинание для вызвания move конструктора,
вот такое заклинание для написания move конструктора, и больше ничего.
То есть из того, что мы ему сразу передаем rvalue suit,
не следует, что он вызовет?
Нет, не следует.
Если написать s, не будет move конструктора.
Вы забегаете вперед.
Пока мы знаем только вот эти два заклинания.
s это не rvalue, если вам так хочется знать.
То, что это rvalue suit, не означает, что это rvalue.
Не пытайтесь удивить смысл, которого там нет.
Не думайте пока об этом.
Мы пока знаем только два заклинания, больше ничего.
Мы вызываем move оператор присваивания.
За счет того, что мы пишем std move, мы попадаем в эту версию.
И в ней мы опять вызываем std move.
И в ней мы опять вызываем std move, чтобы вот здесь вызвать move конструктор.
Если мы напишем std move, мы вызываем не move конструктор,
мы вызываем copy конструктор.
Чтобы вызвать move конструктор, нужно вот такое заклинание.
Мы зайдем вот сюда.
Это оператор присваивания, а здесь мы зайдем в move конструктор.
Это оператор присваивания, а там move конструктор?
Да.
std move это не функция.
std move это функция.
Нет, это какая-то волшебная функция, которая что-то необычное делает с объектом.
Мы не понимаем, что.
Но в результате после ее вызова мы попадаем вот сюда.
Ну давай.
Я просто думаю, что надо людей отпустить.
Давайте я скажу, что на сегодня все.
И...
Чего?
Вторая серия не совсем закончилась, потому что
мне нужно еще сформулировать правила пяти.
Но я сформулирую в следующий раз.
Вторая еще не закончена пока серия.
Можно самим реализовать?
Да, мы это сделаем обязательно в следующий раз.
Функция move реализуется в две строчки.
Но как она реализуется мы узнаем в следующей серии.
