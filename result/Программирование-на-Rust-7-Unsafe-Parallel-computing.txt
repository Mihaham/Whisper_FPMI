Я, кстати, забыл вас поздравить. На прошлой лекции мы узнали всё о сейфрасте.
Вообще всё. Поэтому нам сейчас останется только посмотреть нонсейфрасте, а после этого мы будем параллелиться.
Сейчас мы посмотрим нонсейф и посмотрим параллельность.
Мы увидим, как пишет нормальный код нормальные люди.
Параллельность будет скучная, потому что я такой скажу, но вы всё знаете.
Параллельность в целом, я именно про нсейф, чтобы как нормальный код люди пишут, а не нсейф.
Потому что в некоторых местах сейф бесит.
Ну, блин, не знаю. Там, честно говоря, сильно нечего вам будет рассказывать про нсейф.
Потому что, ну, как бы, ну, что я вам расскажу про указатель, вы всё знаете.
Что там, третья мая?
Давайте тогда поменяем. Десятая. Сделаем.
Такс. Контрол, опшен, блин, опшенер, по-моему.
Блин, опять не угадал. А, оконрассент это...
Командер. Вот так вот.
Вот. И сейчас корректируем дату.
Это фигня.
Ну, честно говоря, это похоже на правду, потому что сейчас...
Уж по-другому не получается.
Такс. Ну всё, теперь всё правильно.
Ну что, начинаем?
Да.
Так, у нас седьмая лекция про нсейф и про параллельность.
На этот раз она будет очень простой, в сравнению с прошлой.
И вообще, наверное, это будет для вас самая простая лекция,
потому что до этого вам приходилось что-то новое изучать.
Сейчас ничего нового не будет.
Сейчас будет погружение в плюсы и параллельность,
которую вы прекрасно знаете.
Так что просто посмотрим, что есть разница по этому поводу.
Вот. У нас вот такой вот план.
Будем смотреть на нсейф и что он на себе представляет.
Какая идея за нсейфом.
Посмотрим чуть-чуть на указатели, на неинциализированную память.
На то, когда писать нужно нсейф.
Ну и чуть-чуть про параллельный компьютер будет.
Ну и еще парочка крейтов самых популярных в Расте.
Кроссбим и район.
Которые вам наверняка очень понравятся.
Так что давайте начнем.
Нсейф и его контракт.
Почти весь Курс, когда мы говорили о сейф Расте,
мы говорили о подножестве языка,
в котором нельзя сделать никакие ошибки
связанных с memory-safety и undefied-behavior.
Нон-сейф Раст это такое надо множество языка,
в котором вы уже можете совершить такие ошибки.
Ну прямо как в всяких языках типа плюсов.
Например взять и просто невалидный указатель разоменовать.
В Расте в онсейф это уже возможно.
Ну и более того, оказывается, что в сейф Расте
мы даже не можем написать вообще весь код,
который мы бы хотели написать.
Да, мы можем с помощью тех сейф-абстракций,
которые у нас уже есть, имплементировать все что угодно,
но порой мы хотим какие-то оптимизации, например.
Мы хотим написать на указателях BST, чтобы...
Ну ладно, BST будет работать так же официально как в плюсах,
но вот линкет-лист мы хотим, например, на указателях написать.
Потому что нам не хочется RC, нам не хочется overhead.
Для этого нам нужен онсейф, потому что Раст, к сожалению,
не может проверить в compile-time все нужные контракты,
что мы выполняем.
Ну вот давайте примерчики посмотрим.
Например, мы не можем написать просто так vector.
Как ни странно.
Потому что там есть достаточно такой непростой вариант.
У нас первая половина нашего...
Наша локация на чем-то инициализирована,
первая часть, а вторая не инициализирована.
То есть получается, что мы в любой момент можем выйти
за границы инициализированной локации,
пока мы пытаемся заменеджить vector.
Мы не можем сделать всякие оптимизации,
например, линкет-лист на указателях, как я сказал,
или, например, сохранить какие-то байты на локациях,
если очень хочется.
Или, например, делать различные другие оптимизации,
говорить компилятору, например,
вот этого значения скорее всего будет таким.
И он, исходя из этого, оптимизирует нашу программу.
Еще, например, видели ли вы функцию?
Если у меня большой vector был,
а потом я сделал много попов,
то он уменьшит будет или нет?
Нет, не будет.
Да, если вы хотите, там, по-моему,
шринг должен быть меток где-то.
Знаете ли вы функцию сприда от нет?
Возможно, видели.
Это функция такая slice,
которая принимает на вход мутабельную ссылку на slice
и возвращает две мутабельные ссылки на slice.
Но как это работает?
Вы создаете индекс,
и он делит пополам.
То есть до индекса не включительный,
с индекса и дальше включительный.
Естественно, это небезопасно.
Вы создаете две мутабельные ссылки.
Раз это не может проверить в своем сейф под множестве,
поэтому вам нужно спуститься до unsafe,
чтобы создать две эти мутабельные ссылки
и поддержать все варианты.
Мы еще посмотрим на сприт от mute.
Еще мы, возможно, хотим напрямую
с железом взаимодействия,
с экспорционными системами
или даже с FFI с другими языками.
Unsafe для этого уже
нужен.
В сейф Rust мы уже не можем проверить всех вариантов,
опять же, только в runtime,
и приходится пользоваться unsafe.
На самом деле unsafe Rust имеет очень мало что.
Смотрите, всего это мы умеем
roll pointer
dereferencing.
То есть мы создаем какой-то сырый указатель
и получаем значение.
Точно так же, как в плюсах.
И в сейф Rust вы вообще не можете это сделать.
Вам нужно обязательно ставить unsafe,
чтобы сказать Расту о том, что вы выполняете
условия на то, что этот указатель валиден.
Корректный участок памяти,
который принадлежит вам.
Вызывайте всякие unsafe функции.
Например, это интристики,
про которые я говорил для компилятора.
Аллокатор, который вам будет напрямую
возвращать какой-то кусок памяти,
который вы аллоцируете.
Это функция C.
Можно имплементировать unsafe trading,
который мы сейчас посмотрим тоже.
Или мутировать статики.
Почему небезопасно мутировать статики?
Вы наверное видели уже
предупреждение от компилятора.
Ну, потому что можно мутировать
из нескольких трудов, конечно.
Это небезопасно, это датарейс.
Поэтому Rust просто так мутировать статики не дает.
Это будет на этапе компиляции
просто обрезать.
Ну, блин, мы еще про трейды только
не знаем, как Rust к ним относится.
То есть, есть предложение, что в Rust вообще
трейды создавать нельзя, потому что
не может быть правильной компиляции.
Ну, конечно, можно создавать.
В общем, для статиков основная причина
это то, что из нескольких трейдов
можно мутировать.
Про трейды мы пока что не знаем,
но понимаем, что такая проблема может быть.
И ее можно сделать в плюсах тоже.
И еще у нас в Rust есть unions.
Мы про них не будем
подробно говорить.
Ну, в общем-то, unions прям как
FC в каком-нибудь, в котором вы можете
взять и одну и ту же структуру
несколькими...
за несколько, скажем так,
смотреть.
Например, превратить float
в union32t
с помощью unions. Наверное, на курсе
окоса. Задачка, конечно, такая была.
Приходилось смотреть
что из себя представляет float
внутри.
Это все
на самом деле приходит...
вся эта сила приходит с огромной ответственности
одновременно. До этого у нас программа всегда
стабильно работала, а здесь мы можем баться
просто произвольной
ошибку,
если мы вдруг пишем
неправильно unsafe код.
Давайте посмотрим на первый примерчик.
Самое простое, что можно представить себе,
это getUncheckedVector. Вектор у нас
не проверяет, правильно ли мы
индекс мы дали.
Обратите внимание,
что здесь у нас
индекс getUnchecked,
здесь не очень, наверное, понятно,
просто берем
у вектора
не проверяя абсолютно ничего,
элемент по индексу.
Мы избавляемся от проверки, но тем не менее
теперь мы можем получить убей, если у нас индекс неправильный.
У нас были ассоциированные с ним функции,
а с этим мы берем индекс
и вызываем ассоциированный с ним.
Не, вообще, это функция ассоциированная вектора.
Ну, индекс это
какой-то sliceIndex,
в общем, там дальше есть...
Есть еще, скажем так, дальше
функции, и getUnchecked
делает то же самое, но на slice.
Просто как sliceVector
представляем, по сути.
Вот.
В общем, такой вывод.
У каждой unsaved функции есть какой-то контракт,
который она с вами поддерживает.
Вот на первой лекции у нас был minCopy,
где мы должны были гарантировать то, что у нас
не пересекаются участки памяти.
Здесь мы должны гарантировать то, что мы правильный индекс засунули.
То есть такой элемент вектора действительно
существует, он не ходит за границы.
Иначе мы получим убе.
Ну, для этого нужно читать документацию, конечно.
Это то, как мы могли бы
воспользоваться unsaved в нашем коде.
Вот у нас есть getUnchecked.
Мы воспользовались через unsavedBlock.
Нужно явно пометить раз,
что мы хотим воспользоваться unsaved функцией.
Это в каком-то смысле
удобно, потому что мы можем просто взять
поиск и покодовать unsaved
и вы смотрите,
видите все точки, в которые воспользуется unsaved.
Если у вас получилась убе, то могло
получиться только потому, что у вас unsaved где-то
есть блок,
который неправильно отработан.
Сейчас у нас
ваинциализировано
или нет?
Ваинциализировано. Вон вектор.
Вектор, что там получается?
Единичка.
Да, вектор из единички просто.
Это же через запятую.
Вот.
Так.
Ну, кстати говоря, я еще забыл сказать,
вот эти unsaved блоки вы можете писать в любых имплах.
В любых функциях, по сути.
Unsaved блок – это выражение?
Это просто scope.
Ну, даже не так.
Это
просто scope, который поменчан
unsaved.
Это выражение, в котором
ты можешь вернуть что-то.
Так.
Вот это вот важное замечание. Вообще по историческим
причинам так сложилось, что у нас
каждая unsaved функция
внутри имеет неявно большой unsaved блок.
В итоге поняли, что это плохое решение,
потому что если вы пишете unsaved
внутри unsaved функции, то вы
даже не видите, что у вас unsaved используется.
Хочется как-то это явно прописывать.
В общем, мы решили, что это плохое какое-то
решение, и в будущих editions
раста могут это убрать.
То есть вас заставить
прописать явно unsaved блок.
В данный момент, конечно...
Сейчас клипы бросают warning на эту тему?
Вроде не бросают.
Ничего плохо не делают.
Но потом должен появиться линт.
Даже RFC 2585, в котором все это описано.
И в будущем может появиться вот такой вот линт,
который будет
для того, чтобы уменьшить
footgun radius
внутри каждой функции unsaved
нужно будет явно написать unsaved блок.
И в будущем это может стать
hard error в компиляторе.
То есть если вы напишете unsaved
внутри, то у вас не скомпилируется просто программа.
Это такая вот...
Придется признать, это была ошибка
в данный момент.
Приходится тебе исправлять.
Вот еще есть unsaved keyboard.
Который...
Ну, unsaved можно использовать для
trade.
Что значит unsaved trade?
Примерно написано
на слайде, понимаете ли вы, что это значит?
Например,
конкретно данный trade.
Может так произойти,
что у нас имплементация ORDA
будет некорректной.
В вполне нормальной ситуации, если
user берет, пишет для своей структурки ORD
и там для этой структурки ORD написано некорректно.
Вам придется это учитывать.
Если вы пишете свой код
не в save, а в unsaved,
тогда вы можете просто положиться на то,
что user написал ORD
корректно, но при этом он написал его некорректно
и получите UB в своем коде.
Это вам нужно учитывать то, что ORD user может
написать неправильно.
А если вы хотите довериться
этому, то в таком случае есть
можно объявить такой trade
trusted ORD.
Если user его имплементирует,
в таком случае он вам уже говорит, я точно уверен
в том, что эта имплементация корректна.
Unsaved trade это те trade, которые
небезопасно имплементировать.
Ими можно безопасно пользоваться.
Если там были бы какие-то функции,
ими можно было бы всеми безопасно пользоваться в save.
Вы небезопасно имплементировать.
То есть вы должны какие-то
контракты, которые этот
trade вам дает соблюдать.
В данном случае контракт
это то, что у вас ORD должен быть
имплементирован корректно.
Обязательно, представляйте себя
в полный порядок.
Например, есть такая история,
что
бет дерева
она же пользуется ORD.
А что будет, если ORD некорректный?
Просто там не полный порядок,
просто рандомный ORD возвращает.
Что произойдет в таком случае?
Ну, в общем-то, да.
У нас может произойти рандомная фигня,
но только не memory and safety
и не undefined behavior.
Потому что там написано бы дерево таким образом,
что если вы напишете некорректным образом ORD,
то все будет хорошо.
Но при этом
в общем,
все будет хорошо.
В общем, все будет хорошо.
В общем, все будет хорошо.
В общем, все будет хорошо.
В общем, все будет хорошо.
В общем, все будет хорошо
в таком ситуации.
Но вам приходится это учитывать в своей имплементации.
Когда можно было довериться юзеру,
не пришлось бы делать
дополнительных проверок никаких.
Когда решали, что сделать с ORD,
потому что юзер может написать же неправильно ORD,
делали ли ORD unsafe trait?
В общем, решили, что нет, как-то
это unsafe everywhere тогда будет,
и не нужно так делать.
Вместо этого мы скажем, что давайте это будет safe,
а всем юзерам скажем, что
в общем-то вы должны проверять
на то, что ORD действительно
корректно имплементирован.
К сожалению, это такой вот trade-off
в данной ситуации.
Таким образом, приходим к тому, что unsafe
это такая штука, которая объявляет контракт
между вами и между пользователем.
Вы что-то пишете,
с unsafe мы теперь пользователи
должны выполнять ваш контракт, который вы сказали.
Вы уже слышали
на первой лекции такие слова как
soundness и unsoundness.
Soundness это
код sound, это тогда, когда
вы его используете как хотите,
можете использовать внешний код,
код, например, из этой структуры,
если у вас функция unsaved
внутри структуры.
Как угодно
пользуйтесь кодом вокруг и тем, который у вас есть
с unsaved, но при этом у вас
не будет undefined behavior
и memory unsafety.
Ваша пин называется
sound, если ни при каких условиях
она не вызывает memory unsafety
и undefined behavior.
И unsound в противном случае.
По умолчанию,
когда вы пишете на Rust,
весь ваш save код
он sound,
потому что у вас все абстракции они sound,
соответственно то, что вы написали,
с memory unsafety
и undefined behavior.
Если вы начнете писать unsaved,
то тогда нужно проверять, что у вас действительно
та обертка, которую пишете вокруг unsaved,
она будет безопасна.
Убеждаться в этом.
И обычно,
когда мы пишем unsaved код,
мы оборачиваем его в какую-то
врэпим в какую-нибудь
абстракцию.
Например, если у нас есть unsaved api,
мы обычно делаем вокруг safe api,
который делает дополнительные проверки,
что юзер действительно не идиот и все получается.
Давайте перейдем
к split от mute.
Это такая silent функция, как можете обратить внимание.
Она понимает на вход
mute self,
это у нас просто какой-то slice.
И принимает какой-то индекс.
То, что она делает,
она просто проверяет, что у нас действительно
mid меньше либо равен лэм.
Если так, то все хорошо.
Если равен, тогда у нас получится
правый slice пустой,
а левый slice состоит
из всего массива.
В противном случае мы получим два
неперечекающихся slice,
то все безопасно.
Обратите внимание, что вот это вот я скопировал
просто в стандартной библиотеке,
и тут есть такой комментарий safety.
Очень любят перед unsaved блоками
это писать, даже
в каком-то плане необходимость,
потому что
это то, что объясняет,
как вы написали unsaved,
здесь безопасно.
Почему написано unsaved безопасно?
Здесь мы написали,
что мы выполнили контракт
split от mute unchecked,
который ничего не проверяет,
и просто делает split.
Ну, выглядит он примерно вот так вот,
unchecked, это unsaved функция,
которая, здесь такая же написана safety,
говорит, что тот, кто вызывает
эту функцию, должен проверить то-то,
ну и просто
делает два slice-а,
из указателя и из числа элементов.
Ну и все.
Вот так вот примерно выглядит unsaved код,
какой-то контракт,
и вы его выполняете,
когда используете unsaved код.
Вот, кажется, все, что я хотел сказать про unsaved.
Unsaved это про контракта.
Это так.
Ну ладно, наконец-то контракт
ты хоть куда-то больше не прислал.
Так.
Можно еще поговорить про указатели.
Указатели это тоже очень важная вещь,
когда вы пишете unsaved код.
Я их показывал вам на первой лекции,
но тем не менее, мы их там
активно не пользовались.
Я просто сказал, что это достаточно
бесполезная ерунда, когда вы не пользуетесь unsaved.
Ну, здесь
я создаю просто какой-то null-пойнтер,
проверяю его на null,
создаю еще один указатель.
Ну, mute означает то, что я могу мутировать
по этому указателю, а const
это когда я могу просто читать.
Все просто.
Здесь я создаю
mute указатель
на строчку.
Получается на строковый слайс.
Box не OBC.
Ну и с помощью
Into raw я делаю так, что
у меня Box превращается в указатель.
Это безопасно, а в обратную сторону уже
не будет безопасно, потому что тогда нужно будет
проверить, что указатель действительно показывает
навалидный участок памяти.
Ну смотрите, я тут пользуюсь unsaved,
потому что мне нужно разыменовать указатель.
Я хочу просто вывести
содержимое Box, первое
символ.
Понимаете ли вы, что значит
указатель и ссылочка одновременно?
Ну, вообще, как так получилось,
что мне так нужно написать?
Сейчас вы разыменовали указатель
и получили
ссылку на слайс.
Потом взяли
вот слайс
с слайсом 0.
Это просто
синтаксис создания слайса.
То есть когда я разыменовал, здесь у меня получился
слайс t, и после этого я сделал
слайс 0 еще, и слайс.
То есть кроме
вот этого вот, все остальное вам уже знакомо.
А в звездочке
const i 32
это указатель на const i 32
или константный указатель?
Нет, мы читаем слева направо.
Указатель на константный i 32.
Это не плюсы, чтобы справа налево читать.
Мы читаем слева направо.
Так.
Как раз спросил.
Хотя нет, в данном случае это
да, это
чуть-чуть другое.
Оператор срывания мута.
В общем, да. Оператор срывания мута, получается.
Мы делаем str из этой ерунды.
По сути, это на самом деле не один
оператор,
а это два оператора. Мы разыминовываем,
потом берем ссылку на содержимое указателя.
Ну и все.
То есть конкретный тип получается
ссылкой на ссылку str.
Так, очень важно
еще заметить, что
вы можете так свободно делать,
но если вы будете
создавать, например, мьют ссылку, вы должны убедиться в том,
что такая мьют-ссылка только одна
ульбоминг, например.
Если вы создаете мьют-ссылку
и вот просто так получилось, что где-то есть вторая
ссылка, то это уже instant to back.
Потому что это нарушает гарантии
раз-то, а раз может полагаться на это
при оптимизации, например.
Просто может разломать вам код, из-за того,
что вы создали вторую мьют-ссылку.
Так что
очень аккуратно относитесь к XM,
когда вы так вот создаете ссылочки.
Так, еще есть
некоторое различие между указателями
и ссылками.
Вот ваш однокурсник
комментировал первую лекцию
и говорил, что
ссылки в Rast больше напоминают указатели,
а указатели можно класть в вектор.
На самом деле это, конечно, не так.
Потому что на самом деле ссылки
в Rast это то же самое, что ссылки в плюсах,
ну, в кавычках.
Ссылки в плюсах это не first class object.
Они больше похожи на ссылки все-таки плюсовые.
Указатели это указатели.
Зачем указатели
от ссылок отличаются
в самом Rast?
Это тем, что у ссылок
есть lifetime, а указателей его нет.
Самое ключевое.
Соответственно, раз у нас есть lifetime,
то мы в безопасности, раз у нас все проверяет,
а когда его нет, уже все,
приходится проверять самостоятельно.
То, что вы не переживаете объект.
Так.
О, самое, кажется,
сейчас тут будут катерсисы.
Смотрите, pointer arithmetic.
У нас есть возможность
добавлять к указателям
и влево-вправо их сдвигать
с помощью add и sub.
Здесь я делаю add,
возвращаю первый элемент, возвращаю второй элемент.
Знаете, в чем здесь прикол?
В том, что на самом деле мне unsafe пришлось
написать не только потому, что я разаменовываю
здесь указатель,
но и потому, что у меня add это unsafe функция.
А почему так?
Я же просто добавляю что-то к указателю.
Ну объясни, как в плюсах.
Ну,
если мы
сдать arithmetic и указать,
получаем указатель, который выходит
из границы массива, из которого он был порожден,
мы получаем b.
Да, мы сейчас даже посмотрим
конкретный пример, почему так.
Это действительно может привести к b,
именно поэтому это unsafe функция.
Давайте посмотрим более конкретно.
Когда я здесь написал add и sub,
я сказал, что у нас
указатель, который должен получиться,
он должен быть в пределах той же локации.
И что значит пределах той же локации?
Почему это вообще нас беспокоит?
Потому что такие указатели
просто неволидны.
И любое их использование, вообще любое,
не только разаменование, а просто их
арифметика,
это undefined behavior.
Сейчас мы увидим даже конкретный пример.
Проблема может быть в том,
что компилятор просто решит
часть вашего кода удалить
на основе того, что у вас указатель
вышел за пределы локации.
И получается, что мы напишем такой
простенький код и отстреливаем себе ногу.
В сейф Rasty вы можете
чувствовать себя в безопасности,
а в AntSafe Rasty уже так не получится.
Вам приходится учитывать даже такую штуку.
Давайте для примера,
чтобы понять, а почему это так,
посмотрим на один CI-шный код,
в котором компилятор
делает три оптимизации и полностью
он ломает код.
Смотрите,
вот у нас есть такой код, и компилятор
его хочет прооптимизировать.
Что вы о нем думаете?
Это просто указатель на uint.
Указатель на uint.
что-либо, и если вы правильно это определение
припоминаете, то тогда вот эта проверка
в эфире всегда ложна.
То есть проверка в эфире всегда ложна?
Да, потому что такой стандарт.
Ну, там даже дело чуть-чуть в другом, наверное.
Ну да, да, мы сейчас это обсудим.
Ну, вообще, сам по себе, если вы не оптимизировать
код, вот как он есть, его запустить, дает какой-нибудь
УБ или мой вариант СФТ?
Ну есть тут УБ, просто скажите мне.
Я не оптимизирую, потому что он ноль написал,
компилятор скомпилировал ровно то, что увидел,
без оптимизации.
Мне ку-ноль не нравится.
Ку-ноль не нравится?
А почему не нравится ку-ноль?
Тогда все равно.
Наверное.
Что такое принц?
Принт это просто что-то, что выводит.
Ну, если они не равны, то УБ не случилось.
И все хорошо.
А если они все-таки равны, то...
Не, а что, типа, мы вроде даже Алясинга
мы не переиспользуем указатели.
То есть мы пишем через указатель на ку и читаем
через указатель, ну, через ку.
Так что, вроде как УБ даже ни в каком сценарии нет.
Просто непонятно, что с припроверкой.
Да, получается, что с виду УБ никакого нет.
Но создали указатель плюс один.
Ну, там сравнились.
Ну, какая разница?
Ну, если равны, ну, код правильный.
Если не равны, ну, какая разница?
Не зашутим.
Да, вообще, такой корректный, прикольный код.
Что там?
Давайте попробуем оптимизировать.
Компилятор такой берет и говорит,
раз уж у нас икуровняется ип,
когда мы заходим внутрь,
в таком случае мы можем
заменить ику на ип.
И тут все умерло.
Ну, почему же они равны?
Вот мы, получается, сейчас показываем на ку.
Ну, все ж правильно, да?
Ну, да.
Вот с такой же икой все корректно,
и теперь у нас по программе не корректно.
Теперь можно стереть эту строчку.
Можно стереть...
Смотри, мы взяли вместо ику,
ну, ику равняется 10,
написали, ну, просто ику заменили на ип.
Потому что они равны все равно.
Ну вот, присвоили 10.
Почему?
Ну, потому что...
Подождите, подождите.
У нас еще две оптимизации впереди.
Компилятор еще не все сломал.
Одна из оптимизаций будет как следствие того,
что если этот код оставить как есть,
то если программа будет успешной,
то это уб.
Ну, вообще утверждается, что конкретно вот этот вот код,
если опять его запустить без оптимизации,
то все опять будет норм.
Вот уже не...
Еще раз, вы понимаете, что теперь,
если программа будет успешной...
Ладно, блин, очень плохо, конечно,
что Андрей так хорошо шарит.
То есть запутать у него не получается.
Да, я понимаю, что ты шаришь стандарт.
Хорошо, давайте без Андрея.
Все остальное я понимаю.
Он просто сразу же видит УБ, а так скучно.
Ну, потому что я привык так...
В общем, кажется, что вроде бы все нормально.
П плюс один, оно же указывает
у нас на ку сейчас, да?
Вроде бы там равно 10, но все хорошо,
но вывели 10, все это же точно так же.
Потом говорим, после второй оптимизации,
ну, у нас тут раунд триб, да?
Зачем нам наш УИН ПТР,
ну, в общем,
вот это вот убрать, да?
Зачем надо это убрать?
Просто взяли, убрали такие, ну, получается.
Просто П плюс один равняется 10.
А потом самое веселое.
Третья оптимизация.
Как говорится, у нас же П и ку
это две разные переменные.
Получается, ку у нас никак не модифицируется,
давайте я просто зафигачу туда ноль.
Он же всегда нулем уйти.
Он просто не понимает, что П плюс один
сейчас на ку указывает.
А лессинг не прошел, да?
И все, и такой вернул ноль.
И получается, что у нас программа, которая
никогда не возвращает то же самое,
что было исходно.
Вот убой-то такое, да.
Ну, как-то так,
я соптимизировался, то все.
Вот когда мы начинаем,
вот какая из этих оптимизаций некорректна?
У нас же исходный ку вроде бы работал,
чисто в теории.
Все корректно.
Все оптимизация корректна.
Ладно, вы все очень умные, говорите, все оптимизация корректна.
Это действительно правда, компилятор бесконечно прав.
Это неправ программист.
Давайте дойдем до этого.
Могли бы подумать о последней оптимизации, да?
Ну, последней оптимизации типа ноль вставили,
и вот у нас все окончательно поломалось.
Ну, так и лессинг тоже.
Ну, все потому что вот лессинг, компилятор
думает, что у нас
ку и п это разные вещи.
Ну, оказывается, что это ошибка
программиста, потому что он зараза сделал
и П плюс один указатель сделал, и еще сравнился
у него с Катином.
Как стандарт мог?
Ну, компилятор просто взял и
все по стандарту.
Ну, то есть у нас есть П плюс один,
он не верит в том, что у нас
П плюс один может вызвать
и лессинг, и все.
Да, это реально кейс, ты можешь компилировать код.
По-моему, там С можно указывать
на один элемент
после массива. И в С в местах можно,
но, во-первых, это нельзя разуменовывать, во-вторых...
Мышка
IP указывается, поэтому я не разуменовал
П плюс один.
Ну, мы указали
на элемент за массив.
Да, это мы не разуменовываем.
Это еще хорошо.
Но при этом у нас...
В этом такове все было правильно.
Он был корректен до оптимизации.
Понимаешь, он просто по стандарту
не понимает, что П плюс один
указывает на один больше, он думает, что
алиасинга нет, что ты не модифицируешь.
Некорректно разуменовывать,
а он просто берет, и за счет
того, что здесь есть странность, то думает, что это
корректно заменить икона IP.
Если у нас в ходе нет УБ,
у нас есть гарантия, что оптимизатор
ничего не сломает.
И вот, значит, если оптимизатор сломал...
У нас есть УБ, мы взяли ИП, создали.
Смотри, мы создали, во-первых, УП,
а потом сравнились с ним.
С другим куском памяти.
Это два разных куска памяти,
которые не алисицы, и мы взяли
УБ, получим.
Ну вот там действительно...
Ну да, вот на самом деле...
Сейчас, а у Бэли это прям...
Вопрос веселый, просто потому,
что когда-то сравнить-то,
типа, можно?
Нет, там нельзя сравнить. Там, типа, можно
сравнить исключение в пределах
адрилотации.
Давайте не посадить.
Как вариант.
Там не только иксминский страдает, там и сравнение еще на фиге.
Тут не только П плюс один,
тут как бы создать
этот указатель, который выходит
на один байт, ну то есть
в пределах той же аллокации
и плюс один байт можно, но тут
проблема в том, что мы сравнились
с чем-то, что является другой аллокацией.
Сью уже такое все дальше
по стандарту сделал, и все.
И все сломал.
У нас нет еще проблем
с неравняемым или...
Мы уже там
П издвигали на один байт.
Формально.
Ну, на один байт, да.
А в чем проблема?
Ну, чара как бы
по одному байту.
Чара почти, наверное, выравнивает не один,
хотя кажется, он так даже...
Чар, по-моему, даже один четко говорит.
Указатель на
инсайн-интеллект.
Нет, Uint-ptr — это именно Uint,
в который можно записать
А, все, окей.
Это чуть-чуть другое.
Ну, вот
возможно это пригодится
на конкуренцию.
Наверное, вас это сильно испугало.
Взяли такие, сделали чуть-чуть что-то не так
и нога отстрелилась.
Наверное, нам очень страшно
теперь писать сейф-код после этого.
Ну, давайте еще посмотрим
на MemTransmute.
MemTransmute — это такая
штука, которая берет
произвольные типы,
просто
произвольные данные
произвольного типа
и перевозит их в другой тип.
Например, в данном примере я беру указатель,
который был на просто какой-то
юнион, то есть
указатель на константный юнион,
поменял его на указатель на функцию
и успешно вызвал. То есть Transmute — это
Reinterpret
Reinterpret
Reinterpret the cast, вот так
в писах.
Блин, так, конечно, формально получается указатель
на констант-воид.
Реально поприсовывался.
Ну, короче, это все
бесконечная, небезопасная
вещь. Ну, Transmute —
наверное, самое небезопасное, что вы можете делать,
потому что если
вы Transmute делаете некорректно,
то есть, например, во время Transmute
у вас получается объект,
у которого
некорректное состояние. Ну, например,
вы перевели U8
в bool, и при этом U8
имел значение
ни 0, ни 1, а, допустим, 2.
А bool не может иметь 2. И, соответственно,
в этот момент вы получили instantUb просто.
Что уже очень плохо.
Поэтому
Transmute'ом нужно быть аккуратным
и проверять все инварианты,
когда вы его делаете.
Единственная верификация,
которую он делает сам по себе, Transmute,
это проверяет то, что у ТИУ
одинаковый размер. Но если не одинаковый, значит,
уже по умолчанию все плохо
и что-то делать не так.
Ну, вот то, что я сказал.
Три, которые у 8, типа,
нельзя в bool переносить, даже если вы ничего
не делаете с bool'ом.
А Transmute выключает значение?
Да, Transmute
просто пожирает твой pointer,
делает новый pointer в данном случае.
Мне нравится
намекон здесь,
в этом месте.
Вы не можете это сделать.
Нет, вы точно не можете это сделать. Нет, вы не особенные.
Три раза подряд.
Вместо i32, i64?
Вместо i32, i64?
Во-первых, если i32, i64
приводить, то у тебя разный размер у них.
Transmute не скомпилируется.
А, сейчас, подожди.
Третья строчка снизу,
вместо i32, i64.
Нет, это ни на что не повлияет.
Это просто указатель
на функцию, где-то на какой-то кусок byte.
Только ее уже вызывать, кажется,
это уб, потому что
функции с таким типом-то у нас нет.
А, то есть в плане fn.
А, я понял, что здесь поменять, а вот здесь не менять.
Ну, тогда это уб.
Потому что, когда ты будешь вызывать,
в таком случае будешь думать,
что получается 42,
которая i64,
я оказал, что это i32.
У тебя просто type mismatch с разными размерами,
и это убы.
На уровне куда гено?
Ты этот регистр прочитал?
Регистр большой.
Ну, ты вместо ex и rax прочитал,
а там, короче, organic.
Ну, вот так, блин.
Я почти выяснил.
Регистр очень большой.
Я думаю,
что активизатор LVM
может тысячу и одним способом объяснить,
почему он этого не делает.
Не, вообще, если так сделать,
я думаю, комператор найдет тысячу и один способ
это сломать.
Еще, например,
если вы ссылку в mute-ссылку,
всегда это уб. Даже если у вас mute-ссылки не было,
если вы это сделали, то это сразу уб.
Instantly.
Почему уб?
Подожди, это мастер,
если мастер 32
у int и
у int 32,
а он скрипилируется или нет?
Он скрипилируется.
У int и 32 сравнить в ассерте?
В всей фрасте?
Это безопасно.
Он просто, правда, может сказать,
что разные типы.
И я не хочу это компилировать.
Если он скрипилируется, то в идее
тот ход даже скрипилируется.
Ну, это в большом случае, да.
Вот эту штуку разве нельзя проверить?
Ссылку в ссылку на mute?
Наверное, можно,
но наверняка есть какие-то хитрые
ситуации.
Наверное, нет, потому что ты держишь одну шейф-ссылку
и все, что ты знаешь,
это то, что могут быть
другие шейф-ссылки непонятно где.
У тебя появляется mute-ссылка.
Ты разломал просто
то, что система типов получается.
Чисто в теории компилятор
мог бы, наверное, как-то с этим поработать,
но...
Это сложное что-то.
Наверное, нет смысла
никакого просто это делать.
Будучи более конкретно,
если вы
создаете тип T, который у вас
невалиден, то в том случае это UB,
потому что, раз, всегда надеется на то,
что у вас тип T, который получается
в любом ментремене, он корректный.
Даже в unsafe-коде.
Да, но это, конечно, для mem-take,
который не может просто взять
и оставить не теоризированно.
Неприятно.
Ну, mem-take, ну да-да, нужно чем-то заменить.
Получается.
Еще есть Transpute-копия.
Но это как Transpute,
но только на этот раз он еще более небезопасен
и говорит, я не буду даже проверять,
что у ET одинаковых размеров.
Вместо этого возьмет тогда
ваш T,
создаст
побольше
копию, выделит какое-то
число байтов побольше под U
или поменьше, и переведет
T в U.
Ну и, естественно, проблемка будет, если
U было больше, чем T.
Ну, в плюсах взяли
лучше. Они взяли проверку
размера по Transpute, взяли копирование
Transpute-копии и получили биткаст.
Приходим обратно в плюсы, короче.
Да, это, конечно, очень полезно делать
касты такие.
Не, мне кажется, что
такой код целом не нужно писать.
Не нужно Transpute'ом пользоваться.
Не, касты в какой-то смысл есть, потому что вот этот
трюк с юнионом, который был
на аквасе, он в плюсах, в общем-то, работает.
Ну, это UBA, и нужно использовать
либо mem-cp, либо биткаст
более цивильно.
А иначе...
Вообще, Transpute нужно пользоваться только тогда, когда
вы хотите структурки
приводить одну в другую
просто с нулевой
стоимости, так сказать, zero cost.
Ну, он же все-таки что-то копирует,
представляет местами, так что
может создавать все равно новый объект.
А Transpute это про то,
чтобы просто битки по-другому
переинтерпретировать.
Как так?
У нас есть еще неинциализированная память.
Это же очень небезопасная вещь, Растя.
Получишь все понятно
по прошлому баллу.
Сейчас Transpute.
У нас же вроде нет гарантий
о порядке полей в структурах.
То есть мы о них ничего не знаем.
В чем смысл делать Transpute в мире?
Если мы не понимаем, что будет происходить.
Это действительно тактика.
Это правда в том, что если у тебя есть две структурки
репораст, то есть
по умолчанию, в таком случае Transpute одно в другое,
а Transpute ты вообще не знаешь, что произойдет.
Конечно, в итоге.
Большая суть есть в этом,
если ты репорси используешь.
Тогда ты точно знаешь, что они будут в порядке
в том, в котором ты их объявил,
какой у них будет паддинг между собой.
Подключевое словарие.
Да, там просто пишешь решетку RapporC
сверху.
Я хотел, кстати, об этом рассказать,
но там было как-то очень мало,
и это бы заняло все равно пару минут.
Примерно.
Так.
Да, вам хочется
сохранять значение, которое невалидно
для текущего типа.
Да, например, вектор.
Огромный, неинциализированный кусок памяти.
Просто.
Ну, например, один из примеров
это когда вы хотите под какой-то
T лоцировать огромный чанк памяти
и после этого прочитать
байты на, например, сети в него.
То есть вам не нужно там
внулять, например, этот кусок памяти
или что-нибудь в этом духе.
Вы хотите просто инициализированный кусок памяти
и постепенно его инициализировать.
Обычно мы используем
для этого Maybe I'm in it в Rast.
Даже необычно я использую Maybe I'm in it.
Это такая структурка,
которая из себя просто представляет
внутри находящийся T.
То, что она делает,
она в точности T внутри себя содержит,
но при этом Rast
никаких предположений о том,
в каком именно состоянии внутри
находится T, не делает.
Например, если у вас будет Maybe I'm in it Bool,
в таком случае Rast не будет делать предположений,
что внутри обязательно 0 и обязательно 1.
У вас там может быть
150, например, значение
и оно будет корректно
для Maybe I'm in it.
Вот есть такие вот три основные методы,
которые там есть.
Aninit это создает новый
Maybe I'm in it, в котором не обязательно
какие-то байты определенным образом заполнены.
В общем, вы не можете внутри полагаться
на содержание.
New это Maybe I'm in it, в котором
есть конкретное значение типа T уже.
А еще есть Assume I'm in it,
это когда вы уже
Maybe I'm in it привозите конкретный T.
То есть когда вы уже уверены в том,
что он инициализирован
и можете его перевести дальше.
Давайте посмотрим чисто например,
чтобы разобраться, о чем я говорю.
Попробуем создать массивчик
и постепенно его заполнить.
Ну вот у нас есть какой-то MyType.
MyType не важно какой, ну какая-то структурка.
Во-первых, до начала понимаете ли вы вот эту вот
строщу, самую первую?
Как она работает?
Что еще раз?
Она говорит о том, что мы предполагаем,
что значение bern, которое Maybe I'm in it
хранится.
Ну вот конкретно вот так вот я могу
написать, потому что у нас очень умный
Type Inference, он смотрит, что в конце после
того, как я сделаю Assume I'm in it,
мне должен получиться вот такой вот массивчик
из Maybe I'm in it типа.
Соответственно, то, что должно быть
вот на этом вот этапе, это
Maybe I'm in it от вот этого вот массива.
Он это выведет и
соответственно у нас будет
такой вот тип,
как бы его рассахали сверху.
Ну и у него пишется Assume I'm in it,
и получается соответственно такой вот массив.
Из Maybe I'm in it типа.
Неинтересированный массив, абсолютно.
Потом мы интервируемся по этому массивчику,
ну и каждому элементу присваиваем
Maybe I'm in it new,
он создает какое-то новое значение,
корректное уже,
и записывает его в элементы.
И смотрите, в конце мне нужно
использовать MinTranspute.
Я перевожу свой
текущий массивчик,
я вот здесь этот тип конкретно не прописал,
просто сделал так, чтобы Растов вывел за меня,
и сказал, что хочу его привести в массив
из MyType 256.
Понятно ли, что тут
происходит?
Maybe I'm in it, это грубо говоря,
такой контейнер, в котором
не обязательно
битики устроены правильным образом для t.
Нет, в этом коде его нет.
Ну, вообще, потенциально сейчас
обсудим, потенциально здесь есть memory leak,
если MyType
это какой-то тип, который что-то
алоцирует на стеке, например, Tabox.
Просто может быть такое,
что в процессе Calculate,
там, допустим,
на 10-м элементе у нас паника выкидывается,
а Maybe I'm in it
он на самом деле не дропает
свое содержимое, потому что он не знает ничего
о содержимом, он не знает корректно,
все, что он может сделать, просто уйти.
Ничего он делать не может этим.
Соответственно, у нас первые 10 элементов
не будут никак
проницилизированы,
не будут дропнуты, и у нас будет
memory leak. Поэтому нужно
аккуратненько это учитывать.
Так.
Вот есть у нас
вот такая вот
особенность.
Можем создать Maybe I'm in it box
и после этого, смотрите, я создаю
as.mute.ptr, который возвращает
mute.t
и пытаюсь по нему записать box.
Понимаете ли вы проблему,
которая здесь возникает?
Наверное, все-таки не понимаете, потому что
я вам бы этого не сказал, но
когда вы записываете что-то по указателю,
мы же берем указатель, разыминовываем, записываем
в него box. Казалось бы, все хорошо.
А что делать со старым значением?
Да, что делать со старым значением?
Указатель по умолчанию считает, что если его разыминовали,
что-то от него записали, значит на объекте, который был
до этого на старом значении, нужно вызвать drop.
А у нас же
Maybe I'm in it, он не знает ни о чем.
И получается, что мы получили
уб просто так. Мы представимся прямо сейчас
на неинциализированной памяти
вызвать drop.
Поэтому если вы хотите от этого
избавиться, то в таком случае вам нужно использовать
STDPTR модуль.
Он вам позволяет, например, STDPTR
write использовать.
То есть записать просто сырые байтики
по указателю, никаких drop не вызвать.
Ну, например,
есть прям
пример.
Разыминовал и разломался.
Получило бы.
Большую часть времени вам все-таки хочется,
когда вы разыминовываете указатель, drop
то, что там есть по содержимому.
Иногда, когда вы пользуетесь неинциализированной памяти,
то у вас там оказывается неинциализированная память,
и это нужно получать.
Вот.
Ну, есть STDPTR write, есть STDPTR copy,
который аналогичен
MemMove. То есть просто
копирует SRC, WDST,
все, что есть.
То есть берет указатель.
Куда мы хотим скопировать? Что мы хотим скопировать
и сколько байтов?
Здесь есть предположение,
что у нас не пересекаются
участки памяти.
То есть копий не делал никаких предположений,
а вот copy non-overlapping
уже таких предположений
делал предположения,
что у нас не пересекается память.
И это уже MemCopy получается.
Это как-то более понятно,
чем MemMove и MemCopy.
То, что одно
не делал никаких предположений, а второе
предполагается, что все-таки у нас
не пересекается геометрия памяти.
Еще одна ремарка.
Невалидно создавать указатель
на неинтересированную память.
Потому что указатели...
референсис, точнее.
Ссылки предполагают
то, что
находится...
то, на что они указывают,
оно сейчас валидно и проинтересированно.
Предполагается, что вы будете использовать
указатели.
Но что если мы хотим взять указатель
на какой-то полис,
указатель на какое-то поле структуры?
У нас есть структура,
допустим, из десяти полей,
мы хотим одной из полей, которая не
инициализирована, записать что-то.
Что же нам делать?
Может все-таки взять ссылку
про интерпретеру другого указателя
Ну, хочется
да, что-то такое сделать.
Как-то так сделать,
просто взять ссылочку.
Дело в том, что мы же сейчас получаем
УБР, да.
У нас неинциализированное поле.
Взяли ссылку на неинциализированное данное.
Даже несмотря на то,
что мы ее проинтерпретировали потом
к указателю сразу.
Как-то указывали
предвидение использования
в этой ссылке нет.
Да, вот на самом деле нет.
Проблема в том, что мы
не только в том, что мы создаем указатель
на ссылочку, которая у нас не создана,
но и в том, что у нас еще может реперпакет быть.
У нас не выровненный указатель
получится.
Как мы по нему будем что-то писать?
Скажи пограмче.
Представь, что у тебя
стоит реперпакет.
Не помнишь сакоса?
Представь себе структурку,
в которой ты сначала написал
лонг-лонг, а потом написал чар.
И наоборот, написал сначала чар,
а потом лонг-лонг.
Потом ты написал пэкт.
Ты в этой структурке не хочешь
никак выравнивать объекты.
Так бы у тебя был 1 байт, потом 7 байт пустых,
потом 8 байт.
А если ты пишешь пэкт, то в таком случае он выровняет
и у тебя будет просто 9 байт подряд.
Но дело в том, что когда ты пишешь
что-то 8-байтное,
то в таком случае ты хочешь 8-байтное
выравнивание.
Просто процессор даже не сможет записать
по такой памяти, он хочет выровнять.
А вообще тогда ссылку
на поле можно брать?
Можно.
SafeRust гарантирует, что так можно делать.
Он тебя гарантирует,
все будет просто работать.
Ты возьмешь ссылку на структурку, все будет просто работать.
И ты хочешь сказать
что из-за этого
он туда написать не может?
Потому что не нужно по колдователю.
Да, нужно по колдователю, если ты будешь указателем
пользоваться, то есть как бы ссылка
Rust гарантирует все будет хорошо работать,
а вот если ты будешь брать указатель, то все.
Здесь проблема в том, что ты берешь
скинициализированный память
как-то так
ну не знаю
если просто проблема скинициализированной памяти
ну просто один раз
вводим эту ссылку
смотри
предполагается что вы будете использовать
макросы AdrOf и AdrOfMute
такие макросы
которые берут поле и просто
возвращают у него
какой-то сырой указатель
по которому уже писать можно
такие особенные по ним можно
интересно как бы вы это сделали в плюсах если Pact
нужно было бы руками наверное делать
или там есть что-то
кстати это интересный вопрос
тут видимо там ну зависит от того
насколько компилятор кто пей
потому что это все-таки не стандартный атрибут
так что если компилятор
и баг
поменим
ну короче вот раз
это приходится с учетом его сейфти
учитывать
есть такой вот макрос который возвращает
указатель которому уже можно писать даже если у Aspect
никаких промежуточных ссылок
он не создает все хорошо он безопасен
ну в плане вызывать его
безопасно
а вот писать по нему уже не вот
да не безопасно на самом деле
даже вызывать
ну вот мы и пишем по указателю
тут что-то вот такое
у нас есть demo где есть field
и мы записали туда true
создали соответственно init
который представляет из себя
уже не demo
в таком примерчике
еще вы можете помнить такую звуку
я говорил на первой лекции
что когда вы пишете например option box t
то на самом деле вы получаете просто unique pointer
без каких-либо оверхедов
у вас box t себя представляет
просто указателем какой-то интеллизированной памяти
а
nullptr там не используется
когда вы накидываете option
то option понимает что там внутри
невозможно воспользоваться
ну невозможен nullptr
соответственно nullptr используется для того чтобы
null
эта штука называется niche optimization
но когда у нас t это
may be and need
то в таком случае мы не можем делать никаких предположений о том
какое у нас снизу значение
соответственно option от may be and need
любого типа t
это честный bool и честный
тип t рядышком
потому что у нас там произвольная байта в t
это
другим контейнером
относится например вы могли видеть non-zero
non-zero просто означает
то что что-то не нулевое
запрещает 0 использовать
и option от
non-zero это в общем-то
просто non-zero
который использует 0 в качестве non-zero
кстати тоже
а как-то
niche optimization на этапе компиляции работает
ну когда ты создаешь любой
non-zero option на самом деле в этом смысле
не особый
ты можешь любой создать абсолютно янам
и он будет просто прятать
битики дискриминанта где-то
в неиспользованных значениях
например
если у тебя bool то в таком случае он знает
что 1 и 2 это гарантировано
какие-то значения корректные була он не может их использовать
а вот 3 и 4 и так далее
он уже может использовать в качестве значений
дискриминанта
нау означать
а там рекурсивно
он знает у каждого значения
какие значения для него
корректны а какие нет
вот у бокса он понимает просто
что за счет того что там внутри используется кажется
non-nu указатель
он просто понимает что бокс это корректно
все кроме всех нулей
то есть там какой-то есть
да-да-да
он как-то их там пересекает
и какие-то забавные
штуки делает но в итоге он
оптимизирует использование памяти
интересно вот я все это на первой лекции
рассказывал там со ссылочками на godbolt
и никто ничего не помнит
я про них и не рассказывал про то что
option оптимизирует я помню я помню 2
була там было их
ну нужно наверное это перенести
ближе вот к этим лекциям
такую новость
вот теперь мы
дошли до момента когда у нас mytype
оказывается что в нем есть
дроп
я вам рассказал уже об этой проблеме
что если мы где-то посередине вычислений
элементов запаникуем
в таком случае мы не будем вызывать на мейбене нет дроп
вообще паника сама по себе когда она
анролится то тогда она дропа вызывает
на всех элементах
ну в принципе да
что-то такое
только
в общем
их можно ловить
а панику нельзя ловить
панику можно ловить только в трамплине
а если у тебя трэд 1
то есть они многопоточны ловить негде
в общем вы должны это учитывать
если вы запаникуете это в таком случае
нужно написать какой-то свой дроп
например если бы вы можете
в намеконе как написан вектор
какая-то простая
имплементация вектора
и там вот как раз будут такие штуки
учитываться
в имплементации
так понятно ли
не инцелизированная память
теперь нам нужно поговорить о том
когда нам хочется использовать ансейв
ну ансейв
такая штука
которая может нарушить вообще все гарантии
расто
и частенько говорят люди
что вся безопасность расто
это всего лишь шарада
это все на самом деле чисто виртуально
например вы могли найти
есть статья на хабре от Антона Полухина
который говорил
что расто на самом деле
пока что не такой быстрый
далеко не такой безопасный
который о себе говорит
на самом деле это конечно не так
расто это абсолютно безопасная вещь
но вам нужно уметь
как бы пользоваться ансейв кодом
если вы пишете
на самом деле
большинство безопасных языков
даже вот я знаю сешард
давайте я вам скажу про сешард
сешард тоже есть ансейв
например так же работает
вы лепите на функцию ансейв там можете пользоваться указателями
у всех языков
а вот еще в Питоне
в Питоне есть и расширение
это тоже потенциальный источник УБ
вообщем у всех безопасных языков
потенциально есть какой-то
ансейв под множество
иначе вы не сможете написать на этом языке
какие-то производительные программы
не Андрей
ансейв нужен в очень малом числе мест
а ты хочешь все остальное
ну как бы отстрелить себе ногу
в просто на ровном месте
в любом из 95% кода
как-то будет смешно
поэтому хочется чтобы большая часть языка была безопасной
только в каких-то определенных местах
ты уже где-то спустился
чуть-чуть там аккуратненько написал ансейв и все получилось
поэтому сейв это гораздо лучше
вообщем-то вам все-таки нужен ансейв код
когда вы пишете что-то низкоуровневое
тем не менее, если вам стало страшно
писать ансейв код, вы не бойтесь
если вы писали на плюсах, вы как-то выжили
поэтому наверное у вас получится
писать ансейв код в Расте абсолютно точно так же
да, ансейв код в Расте
капельку сложнее писать
потому что если вы будете писать какие-то структуры
то вам нужно будет учитывать variants
по которым говорили на прошлой лекции
но это достаточно редкая ситуация
там нужно быть по-честному вывести
какой у вас должен быть variants
для типа, как-то его поддержать
и все такое
самое важное в написании ансейв кода
это читать и писать документацию
в принципе
это верно и для плюсов
когда вы пишете какую-то функцию, вы в любой момент времени
не можете быть уверены, что вы пользуете сейв правильно
лучше все-таки почитать документацию
в Расте вы бы могли пользоваться
вы можете пользоваться свободно всем сейв кодом
когда вы пишете ансейв
или пользуетеся ансейв
тогда лучше почитать документацию
потому что вы можете сделать ошибку
и получить UB
просто не выполнив какой-то инвариант
давайте писать ансейв кода как можно меньше
минимизируйте его количество
и еще очень важно
преиспользуйте существующие крейки
в Расте их очень много
это вещь, которую вам в Расте
понравится
которую вы в Расте полюбите
то, что есть такие сильные крейты
достаточно написать одну строчку
у вас там подключено огромное множество возможностей
как мы говорим про кросс бим и район
вы там сможете написать
ворк стиленка
просто потому что
у вас есть уже готовые
в общем
готовые примитивы для этого
никакого ансейв не нужно
более того
всякие сейфти
баги, которые связаны с сейфти
это баги, которые в Раст комьюнити
наиболее
панишибл
я вам расскажу одну историю
наверное вы слышали про актикс
такая история была с ним
что актикс это вообще такой
актор системы
для веб программирования
она предназначалась
она самая быстрая в бетчмарках
она не предполагала, что кто-то ее быстро
спложить против
пришли Растасия
набежали в его репозиторий
посмотрели на его весь код
посмотрели на ансейв и сказали
тут у тебя сейфти баги
ансамбль
давай ты это починишь
просто иши написали
пока что все нормально
потом пришел тот, кто
это все пишет
я не хочу ничего чинить
мне все устраивает
я пишу это для бетчмарков
с одной стороны
он как бы прав
это же его код
с другой стороны набежали Растасия
они же хотят чтобы актикс
был популярным фреймворком
даже в проде
набежали люди
и сказали давай ты нормально напишешь
в общем там разгорелся скандал
в итоге репозиторий актикса
удалялся, добавлялся
передавались права
такая вот история
с одной стороны это хорошо характеризует комьюнити
потому что они следят за всякими
багами, вы можете быть уверены в том
что кредит, которым вы пользуетесь без сейфти багов
то есть вы пишете
почти всегда только сейф Раст
у нас в домашней
с другой стороны
когда к вам придет человек и скажет поправить сейфти баг
возможно вам будет не очень приятно
потому что вам придется это делать
о чем история кончилась?
ну кажется там
какой-то форк произошел
не помню что там было
вроде бы сейчас не он владеет репозиторием
либо он
вроде бы то ли он владеет репозиторием
но форкнулись
ну кажется это такая история
у вас может скулачивание в аниме светлоуто
вы еще ничего не сделали
ну короче доверяйте
кредитам которые
вы пользуетесь
это правда не действительно все безопасно
сейф Раст он действительно сейф
верьте в это, он сейф код не нужен
практически никогда, кто пишет вот я
сам себе Буратин и пользуетесь тем что они сделали
вот, не мучайтесь сами
ну и более того
если вы все-таки пишете ансейв код, то тестируйте свою работу
но, к сожалению, на лекциях
подробного обсуждения в мире не будет
это такой инструмент для того чтобы находить
в ансейв Расте
ошибки связанные с memory safety
но в домашке он у нас тем не менее будет
надеюсь завтра выложу
у нас будет одна домашка где нужно будет написать
небольшую ансейв абстракцию
небольшой вектор такой
который будет на стеке
ограниченного размера
и прейд смол век
я вас поздравляю, вы только что узнали
теперь и про однопоточный Раст
все, то есть и про
сейф под множество Раст
и про ансейв под множество Раст
какие-то мелочи остались за кадром
но в целом мы уже знаем про язык все
если вы все поняли, вы большие молодец
и теперь вы уже
готовы к тому, чтобы приходить писать про 2 код на росте
осталось
расшириться на
параллельность
и еще асинхронность
на следующей лекции
можно чуть-чуть отдохнуть
перед параллельностью
давайте 10 минут отдохнем
ну что, погнали
parallel computing, переходим на много трудов
перед тем, как пригодить на много трудов
нужно научиться создавать труды
так
ну у нас в первую очередь здесь такая вот функция
вы на нее смотрите, что вы видите
ну почти
ну под низом он
но вообще петроэто тоже только линксовская
точнее миксовская фигня
хотя по этому
порту был, поэтому
да, мы как раз в этом поговорим
про платонических IDFC
отлично
так, окей
так
это как минимум, еще тут видно
какой-то статик
ну есть подаваление, что без сэнда мы не
поймем, что это за статик
не, наоборот, мы пойдем, что такое
статик
ну давайте так
создаем труды
создаем какое-то число трудов 8
то, что я делаю, это создаю рейндж, потом мэп
запускаю какую-то функцию simulate
move, кстати, можно убрать
ну, я даже
это вот написал посредством того, чтобы убрать
здесь move, каким-то его здесь нет
пока что, чтобы не пугаться
в общем, у нас было, мы даже обсуждали
просто они говорили, что это нужно
иногда
ну здесь конкретно в данном случае
move не нужен
вот
вот сначала мы спускаем 3d, потом
handle join делаем и collect
что-то такое
вот
вопрос, почему нам нужен здесь
expect, мы написали expect и
thread payment
надо значит выключить
join
да, дело в том, что у нас thread может
запаниковать
до этого у нас были однопоточные программы
и паника сразу же ломалась программой
с backtrace, а здесь у нас
ломается конкретный thread
мы можем посмотреть
чем thread закончился
вот
ну и в общем-то join handle, когда мы
делаем join, он возвращает нам result
который из себя представляет
либо значение, с которым у нас закончилось
исполнение, либо
значение
ну, значение ошибки
в данном случае это будет thread panic
давайте посмотрим вот такую
штуку еще
у нас есть вектор, то мы запускаем
thread spawn
здесь внутри итерируемся
выводим ишки какие-то
joinимся, то есть во втором 3d
просто выводим содержимое вектора
тут все хорошо?
по-хорошему кажется
что вектор доживает
до join
ну, знаешь в чем дело?
в том, что раз не знает что такое join
вот смотри
у нас есть
во-первых thread spawn
он у нас требует статик
как вы можете помнить
а статик он требует
по какой причине?
по той, что у нас вектор, который мы создаем
он же может
в общем-то
он не переживает наш thread
если бы у нас не было join вообще
мы же можем просто его взять и forget сделать
соответственно мы не будем join-иться
соответственно, когда мы выйдем
из нашей функции
мы могли бы другую создать
вектор бы наш очистился, но при этом
thread бы еще мог к нему получить доступ
поэтому мы
затребовали статик, чтобы у нас не было никаких lifetime зависимости
на тех объектах, с которыми мы взаимодействуем
кэмплятор нам тут предлагает
воспользуйтесь ко move
ну move, насколько мы помним
move-ит внутри closure
то есть берет не по ссылке, а именно move-ит
вот
идея в том, что раз не знает ничего
о join-е, даже если бы он знал
то в таком случае даже между join-ом и thread-ом
мог бы быть произвольный код, который
в любое время не может запаниковать
и в таком случае, если мы
паникуем
то join не выполняется
ну и самая смешная вещь
в том, что ничто не мешает нам
просто лик сделать
на join-хэнду
поэтому получается, что
мы вынуждены поставить статик в тредспон
да, это безопасно
в целом, это в цели безопасности сделано
раньше в стандартном билетике Rust
у Rust вместо статика был произвольный
lifetime-a
но это было в те времена, когда в Rust не понимали
что делать с моими реликами
там даже с tdmem-foget был unsafe
ну то есть все, что было связано
с моими реликами было unsafe
ну и потом в процессе
изучения всего этого выяснилось, что
оказывается для ликов даже нельзя нормальную
мат-модель написать, ну то есть уже можете
много ресурсов
на хипе создать
потом зайти
в бесконечный цикл
мы же не знаем
мы не вернемся из-за того цикла
но при этом ресурсы у нас все еще
все еще мы владеем этими ресурсами
и они никуда не очищаются
получается
непонятно владеем ли мы этими данными
ну даже и так не владеем этими данными
а лик ли это? мы не знаем
вроде бы и владеем, вроде бы есть ссылка
но при этом в бесконечном цикле и данными
с учетом того, что вообще-то memory leak нам не дает никакого unsafety, мы его разрешаем.
Использовать память, которую мы не владеем, это одно, а другое дело, когда мы не используем память, которую просто выкинули.
Ну какая разница? Это безопасно. Плохо, но безопасно.
Да, и для FFI тоже хорошо. Ну там ансейв в любом случае был, поэтому не то чтобы открыл дорогу, просто наверное сделал жизнь чуть-чуть удобнее.
Наверное, там это как раз позволит сделать чуть-чуть меньше ансейвов.
Ну да-да, я про это.
Давайте сделаем так, как комплятор нас просит, просто допишем move. На самом деле здесь можно было написать просто Intuiter еще, тогда бы раз сам выяснил, ага, мне вектор сюда нужно замовить, тогда бы move нам не нужен был.
Это просто изляция проклона, вы помните.
Поэтому перед Red Spawn вы почти всегда пишете move, потому что вы хотите именно замовить объекты, которые вы пользуете.
Даже если вы там пользуете имя нового имена по ссылке просто.
Ну и те же самые рассуждения применяются к тому, почему UT, который мы возвращаем, должен быть статически lifetime.
Потому что мы не знаем, к какой момент закончится наш thread, и нам приходится говорить, ну мы должны иметь возможность вернуться в любой момент.
И у нас UT статик lifetime тоже.
Теперь давайте на такую программу посмотрим.
Что с ней не так?
Ну, что с ней не так?
Ну, что с ней не так?
Ну, что с ней не так?
Ну, что с ней не так?
Ну, что с ней не так?
Ну, когда ты пишешь data matches, то конечно да, но Borrowed data по ссылке.
Да, статика у нас не хватает.
Та же самая проблема, что и была до этого.
Ну, мы получаем такую-то ошибку.
Он требует, чтобы у нас был lifetime статик.
Иначе мы можем пережить дейта.
Давайте добавим RC.
RC же статик, она никаких lifetime и зависимости не имеет.
Есть ли проблемы в этом коде?
Сколько RC?
Так, это хорошее рассуждение.
У него уже дроб конкурент.
Да, у нас RC это штука, в которой у нас нет никакого томика внутри.
У нас там просто какое-то число, которое мы просто меняем.
И за счет этого получается, что у нас здесь data race на счетчике внутри.
Нам, конечно, раз скажет не совсем об этом.
Он скажет, смотрите-ка, TradeSend для RC не выполнен.
Получается, мы встретились с TradeSend, попробовав попользоваться.
Ну, окей, по примечению становится понятно, в чем суть этого гениального трейта.
Так, давай, в чем суть? Попробуй угадать.
Насколько я помню, он все-таки в модуле Market лежит.
Это означает, что можно передавать объект безопасно в другой поток.
Да, это означает то, что можно передавать объект безопасно в другой поток.
Небезопасность RC в том, что мы его можем склонировать, передать в другой поток.
Одна из ситуаций, это два трыда просто умирают, меняют на время на счетчик в RC.
Получается, что у нас data race.
А мы не хотим data race.
Мы хотим свободный стройгон.
Вот у нас там неатомарный счетчик и data race.
Как раз все это говорит.
Давайте теперь вспомним, что такое data race.
Все concurrency знаем, все очень умеют.
Ну, давайте, Андрей, самое простое определение, которое от Рома Липовски говорит,
подойти к школьнику на улице и сказать ему, что такое data race.
Неупорядоченная синхронизация и неатомарное обращение к чей-то памяти.
Все равно как-то зовут.
Не, у нас несколько потоков.
Хотя бы один пишет, а другой с чей-то памяти работает.
У нас есть несколько взаимодействий с чей-то памяти.
Один из них читает, другой пишет, и, по крайней мере, один из них не синхронизируется.
Это то, как Рома Липовски говорит, школьнику подойти на улицу,
схватить его за руку, сказать ему третью постулату, и вот вы объяснили data race.
Ну, кажется, что такое было.
Да, тут, конечно, в идеале нужны memory models, happens before и все такое,
но мы обойдемся и таким определением.
Все-таки с concurrency прошли, можно себе позвольте прощения.
С конкуренцией.
Да, мы сейчас дойдем до этого.
В тот момент, когда Rust был на его early stages разработки,
в тот момент люди верили в то, что memory safety и data race safety — это две разные вещи.
То есть что их нужно как-то по-разному абсолютно репатчить, скажем так, языке.
Но оказалось, в конечном итоге, что из одного выходит другое.
То есть это что из memory safety в одноопоточном случае можно чуть-чуть добавить трейты,
как мы сейчас видим с send-desync, и получается свободность от рейса вообще.
Data race — это вещь, которая абсолютно спокойно превратится в систему типа фраз.
Как вы понимаете, у нас мутировать мы из нескольких потоков не умеем,
потому что мы не можем иметь несколько мутабельных ссылок.
Соответственно, мы не можем data race получить.
Но есть одна сложность.
Дело в том, что у нас есть interior mutability.
Мы же иногда хотим все-таки ref cell, например, всякие такие вещи иметь, чтобы мутировать, имея несколько ссылок.
Собственно, это причина, почему у нас есть send-desync.
То есть если бы у нас не было interior mutability, а он нам в принципе нужен,
то в таком случае система wnrship rasta решала бы нам все проблемы уже и так,
на уровне еще компиляции за трейсами.
К сожалению, нам нужен send-desync.
Send-desync — это небезопасные маркерные трейты с таким вот значением.
Сейчас нам нужно разобраться.
Tip send — тогда, когда вы можете его безопасно посылать в другой трейд.
RC был небезопасен, потому что иметь несколько instances of RC — это потенциально, даже не пользуясь SIM,
это у data race на счетчике внутри.
Send-desync — это просто передать помутение?
Да, то есть в плане посылать его в другой трейд небезопасно.
Например, вектор безопасно посылать, но послали и все.
Какой-то есть, скажем так.
А вот теперь с синком немножко сложнее.
Это если его безопасно share-ить между трейдами.
Share-ить — это означает иметь ссылку.
Если у вас есть ссылка на несколько объектов из нескольких трейдов, то в таком случае вы его share-ите.
Синка означает, что данный тип безопасно можно, имея ссылку, share-ить между трейдами.
T — это sync только тогда, когда обычно не бьют ссылка, а обычно ссылка — это send.
То есть вы можете посылать ссылку на тип.
Например, если у вас есть какой-то статик И32, то его можно безопасно расширить между трейдами,
потому что вы будете его только читать по этой ссылке.
Ну это же безопасно, да?
Ну и соответственно, например, send-безопасен вектор И32,
потому что никаких у нас проблем не возникнет с тем, что он пошли вектор.
Утверждается, что этих двух трейдов достаточно для того, чтобы получить data-race-safety.
Давайте небольшой квиз за комприте, чтобы понять, какие типы sync и send.
Давайте И32. Он sync?
Сейчас. Да и кажется, что это sync, потому что мы его заширили, ссылку на него можем.
Она не вотазильная, кажется.
Да, send-а-sync. Посылать можем, но это просто и нет.
Так что мы можем посылать, потому что мы его заширили, ссылку на него можем.
Так что мы можем посылать, потому что мы его заширили, ссылку на него можем.
Так что мы можем посылать, потому что мы его заширили, ссылку на него можем.
Так что мы можем посылать, потому что мы его заширили, ссылку на него можем.
Да, send-а-sync.
Посылать можем, но это просто и нет.
Ну типа, если вы ссылку можете заширить, то все.
Такое упрощенное определение, достаточно простое.
На вектор.
Send-а-sync?
Или только send-а?
Ну да. И sync.
А ссылка у нас вторая.
Так.
Сейчас, погоди.
Это ссылка, но она не владеет.
Send-а-sync точно, да?
Или нет, обязательно send-а-sync нельзя?
Ну если что, давайте я скажу, что это статикстр.
Иначе вы просто не пошлете от друга по итогу.
А, ну конечно.
Ну, уточнено.
А если у вас здесь не статик, тогда бэнсейпом пользуйтесь и мучайтесь.
Ну да.
Это вроде и все.
Тогда send-а-sync и send-а-sync.
Да, send-а-sync.
Если бы оно было не статик, тогда бы там есть
spawn unchecked.
Он просто перестает
требовать что-либо от объектов
в плане лайфтайна.
И должны вы будете сами проверить, что вы заранее заканчиваете работу.
И только в объекте лайфтайна закончится.
Это unsafe, естественно.
Так, rc.
Он же send у нас
это именно move-нуть
или скопировать, если это код.
Что вообще значит send?
Send безопасно
можно взять instance rc-t
move-нуть в другой thread.
Он не send на третьем сик?
Я помню, он все-таки send.
Нет, ты можешь взять rc-шку
в одном thread.
И склонировать тебя там.
Создать thread, в который ты move-нешь одну из этих rc-шек
и у тебя датарейс на дропе.
А вот он на самом деле не синг тоже.
Потому что если вы возьмете
ссылку на rc-t, то вам ничего не мешает
его склонировать.
Если может склонировать, ну что, тогда вам мешает
получить просто rc.
Сел t.
Представь, что t у нас
send и синг.
То есть по барабану там
32, например.
Просто сел сам по себе.
Сейчас, сел у нас
в runtime.
Ну хорошо, смотри.
Если я хочу через сел что-то помодифицировать,
какую это ссылку требует?
А, нет, стоп.
Вот на сел вспоминать тогда.
Сложно.
Нет, ну это же interimitability.
Interimitability – это менять через обычную ссылку
с какими-то проверками пусть в runtime.
Это не синг
или нет, хоть стоп, оно же
поникнет, так что
сейчас, или там нет
автоматного счетчика?
Там нет автоматного счетчика.
Тогда это не синг, потому что
он мне не мог выиграть.
Ну это только send. Вы можете
послать сел, потому что он в одном
экземпляре у вас только существует,
но
вы не смогли бы его синг
сделать, потому что за счет того,
что у вас имеется ссылка на сел, вы могли
дезинфицировать из нескольких потоков то, что
под ним лежит и получить датарейс.
Там на счетчике уже датарейс,
походу.
Он же проникнет?
Ну, вторую мутабельную?
Нет, ты же мутабельную ссылку в принципе
не сделаешь.
Ну, имеется в виду, что
у него уже дрон какой-то
BorelMute.
Ну ладно, у него BorelMute уже
получается рейс
на флаге счетчика
для его забора
или мутабеля.
Не, так тебе же не обязательно...
Не, подожди, BorelMute, он берет не мют ссылку
на сел, а просто ссылку на сел.
И сел конкретно отличается от refSell
тем, что там нет никаких счетчиков,
он просто записывает. Но проблема в том, что
записывать это все равно датарейс.
От refSell уже он будет
проверять счетчики.
Так, MuteXGuard.
Что это такое?
Это, смотри,
MuteXGuard, когда блокируешь, получаешь guard.
LogGuard.
А, ну короче, то, что мы на
Guard написали, действительно...
Ну, вы писали там в Guard задачу.
Ну, вот, да.
Вот, брать, если что, MuteXGuard точно
так же, как тот Guard.
Там он защищает типы.
А может же тогда, что...
На самом деле, это немножко необычная ситуация.
Это только синг.
Это очень редкая ситуация. Обычно у вас тип
либо ничего, либо только send, либо send и синг.
Иногда бывает такое, что он only синг.
И это как раз про MuteXGuard.
Ну, было бы плохо, если бы вы могли в одном
3D залочиться, залочить MuteX, а потом
другому передать свой MuteX.
Если бы он был send.
Ну, тогда бы можно было разлочиться в другом
3D уже. Ну, как-то.
Ну, как-то.
Вот, non-sink.
Синг, потому что иметь ссылку безопасно.
Потому что все равно для того, чтобы разлочить
MuteX, вам нужно уничтожить, то есть иметь кладение.
Вам ничего не дает ссылка
на MuteXGuard.
Mute, да.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, короче, что он send.
Ну, он не дает ничего плохого.
Ну, типа он only синг.
Кстати, еще про он only синг
типы, это в основном возникает вроде бы
в логфрии алгоритмах,
когда типа только он only синг.
Короче, да, это очень редкая ситуация,
чтобы типа он only синг.
Ну, вам разлочиться.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Еще.
Он send.
Вообще как-то все же.
Вообще давайте не буду вас томить,
это на самом деле тоже типы исключения,
которые не синг и не send.
Так как он
не гарантирует никакой вообще
безопасности указатель.
Он unsafe.
Он unsafe, вы просто за счет этого
вам сказали, не нужно это не посылать
и не синхронизировать, вообще ничего не нужно.
Сами себе через unsafe
с указателями работаете.
В смысле, это уже и так unsafe trade.
Ты их как бы имприментировать может только
с unsafe.
То есть ты должен гарантировать то, что тип
действительно можно посылать.
Можешь.
Можешь написать просто
unsafe.impl
для
сента.
Для pointer
видимо нельзя, потому что
библиотечный тип.
Ну, чисто для его указателей нельзя.
Если уже хочется так, то тогда
можно, например, обернуть его и сказать,
что вот эта обертка умеет send и sync.
Ну, тогда вы уже должны, ну, типа вы делаете
unsafe trade, вы сами себя виноваты,
раз вам показывают, типа вот вы unsafe
написали, с этого момента я
откроюсь от вас, вы сами
проверяете все контракты.
Вот. Большая часть типов send и sync
ну, бывают такие вот исключения редкие.
Также еще send и sync это авто,
trade. Здесь, к сожалению, ключевое слово
авто в моем техе не подсвечивается,
но вообще это ключевое слово.
Они имплементируются автоматически для всех
типов, у которых все генерики,
все, соответственно, типы, которые
вы написали в самой структурке, они
send и sync.
Нет.
В версии не все
send и sync.
Плюс это вообще
land item, то есть там
наверно стоит просто пометка,
что это land item
ref cell, и поэтому у него там
какие-то есть свойства дефолтные, которые
знает компилятор и язык.
Почти все такие вещи
в стандартной библиотеке как-то помечены.
Это не кастели, это просто какие-то очень
базовые вещи, и в стандартной библиотеке находятся
практически только стандартные вещи,
очень базовые. Поэтому получается
так, что почти везде такие
написанные штуки. Вот.
Авто означает
то, что, как я уже сказал,
он имплементируется автоматически.
Вы даже не видите, имплементация происходит
в большую часть времени.
То есть это еще круче, чем
Drive Microsoft?
Ну да, авто, он имплементируется
прям вообще без вашего
как бы без вашего
ведома.
Ну это, естественно,
сильнее, чем Blank implementation,
потому что он проверяет именно, что у вас там
внутри, у всех типов что-то выполняется.
Вы могли, кстати,
в своем коде еще авто использовать, но пока
что это только nightly feature.
Я посмотрел
буквально в
tracking issue
по этой фигне, и там буквально
один пункт только не выполнен, поэтому
скорее всего, ну там с 20, наверное,
где-то, поэтому скорее всего появится уже
авто трейд и в user space в какой-то момент.
Пока что это только
языковая штука.
Бывают такие
очень редкие случаи, когда
send async неправильно.
Ну, в общем,
вдиравится. В таком случае вам нужно
руками их убрать.
То есть это нужно учитывать.
Вот. Смотрите,
здесь я использую, если вы решали
try, вы видели вот фича, и там
было что-то написано. Здесь я
использую фичу negative impulse для того, чтобы
как бы от имплз
сделать, да?
Сенда и синка для какой-то структурки.
Обратите внимание, что фичи
это только возможность
узнать для компилятора.
Stable компилятор Rast такие вещи не умеет.
Negative impulse достаточно
скоро должен появиться в ближайшем
будущем,
но
пока что их нет. Если вы хотите
Stable Rast, если что-то заэнэмплиментить,
то в таком случае нужно чуть-чуть, ну,
по частному признаюсь, покастылить.
Смотрите, у вас есть disabled send,
у вас meetXGuard это какая-то вещь,
которая умеет в синг, но не умеет
send. Соответственно, если у вас появляется
send в структурке, ну, disabled send,
то оно становится не send.
И, соответственно,
disabled sync тоже самое.
Вы просто ставите такие поля,
и, соответственно, у вас тест, теперь не send,
и не sync. Кастыль немножко,
но работает.
Я, кстати, не карантирую,
что это лучший способ решения
этой проблемы. Это то, что я сам
придумал.
Пойнтер одновременно
и send и sync отключат.
Плюс phantomData это то,
что это же за эстетики,
соответственно, он никак не повлияет на твою структурку
от того, что он тут есть.
А pointer он будет занимать
тебя честно памяти, требовать
своих заполнений и так далее.
Ну, берем phantomData указатель
или pointer?
Да, phantomData указатель.
Просто чтоб сократить
количество строк.
В общем, phantomData,
тут можно воспользоваться или написать какой-то тип,
который во что-то не умеет.
Вот, давайте вернемся к той
проблемке, что у нас была. Здесь нам нужно
воспользоваться arg. Просите внимание,
название не просто с а начинается.
AtomicReferencePointer, то есть это
SharedPointer плюс solid.
Он
в общем там атомарный счетчик, соответственно
он send и sync.
Не спокойно пользуйтесь.
Спокойно можете его посылать.
Конечно, он дает немножко больше
overhead, чем просто rc, потому что rc это просто
число, а внутри arg именно
atomic, который синхронизируется.
В курсе конкарзии вы знаете, конечно же,
что arg невозможно написать без атомиков,
как мне странно, да?
Более того, никакие приметивные синхронизации
без атомиков невозможно, в принципе.
У вас даже тогда 3D между собой
не смогут синхронизироваться.
Как жить тогда?
Чтобы атомики работали, вам
нужна модель памяти.
Мы могли просто сказать, что нам хватает
sequential consistency, но там вроде бы год, так
сказано, да?
Год там есть.
На лекции про планировщик
там показывается
часть имплементации
планировщика, и там попадаются слабые
атомарные операции.
А у батарейск просто упоротая,
его почти нет.
А есть ли это не UE,
это какая-то ничья?
Возможно, потому что там есть
ГЦ и, соответственно, у датарейса пофигу.
Непонятно.
В общем,
мы могли сказать, что нам хватает sequential
consistency, но мы в растеже,
мы хотим написать быстрее программу,
чтобы синхронизация была минимальной,
минимальной contention, так сказать.
Поэтому
то, что разделом сказал, давайте мы
переиспользуем модель C++20
модель памяти.
Она не идеальна, вы об этом знаете.
Возможно, не знаете, но слышали.
Это не идеальная модель памяти,
но, тем не менее, она очень хорошо изучена,
под нее есть много инструментов, все такое.
Именно поэтому RAST ее выбрал.
Потому что среди существующих вариантов
это и быстрая модель памяти,
и хорошо изучена,
и активно используется,
поэтому
выбрана была именно эта модель памяти.
Но вообще считается официально,
что в RAST нет определенной модели памяти,
несмотря на то, что
он пользуется модели памяти C++20.
И считается, что
если в Академии
появится хорошая модель памяти,
то в таком случае RAST сразу же заадоптит
себя.
Пока что мы пользуемся модели памяти
C++20,
и чуть попозже будем пользоваться чем-то поинтереснее.
Может, с меньшим
числом бага, быстрее, не знаю,
что-нибудь.
Давайте поговорим о модулях, которые есть,
о модулях CDSync, которые есть
в стандартной библиотеке.
Кстати, я вам не сказал
наверное про RASE,
в общем случае. Давайте пока что
посмотрим на SYNC.
В общем, у нас есть для начала
атомики,
о чем мы и говорили.
У нас здесь request handler какой-то,
в котором мы содержим арк
на число
запросов. Почему нам тут
нужен арк? Вроде бы у нас и арк
одновременный какой-то атомик, как-то
странно выглядит. Почему так?
Сейчас, а что у нас тут по мутабельности
вообще?
Что происходит?
Вы уверены, что получается атомик
в боговем и мутабельный,
а потом вызываем у него
атомик? Ну, короче, тут Interim Intability
внезапно.
Да, Interim Intability, все, потому что
атомик — это примитив Interim Intability.
Какая гадость! И странно.
Это не гадость, наоборот, прекрасно,
потому что формальный модель RASE,
модель Interim Intability,
который оказался в одном поточном случае
исключительно костылем,
внезапно в многопоточном случае
влазят атомики. И более того,
атомик — это просто многопоточный
analog cell.
Не, сейчас, все-таки не очень понятно.
Кажется, что если бы у нас не влажка,
то мы все еще могли бы...
Ну, смотри, ты просто не знаешь, когда
умрут все хендлеры,
у которых есть ссылка
в внутренний каунтер.
Из-за того, что ты не знаешь, какое время жизни,
тебе нужно пользоваться ARC, либо делать статический пример.
Пахнет плохо написанным кодом.
Сказал Парам.
Почему?
Ну, странные вайфтаймы —
это зло. Они приводят вот в каком-то
оверхеду, какие-то сигнализации
они нужны.
Ты можешь просто сделать статический каунтер
числа запроса. А если ты хочешь на статический,
чтобы он умирал вместе с request-хендлерами,
тогда тебе нужно
шерить между ними эту штуку.
Больше ничего не можешь сделать,
к сожалению.
Так. Могут ли некорректные
mem-реордеры привести к mem-variant-safety?
Мы же все еще можем написать
какой-то некорректный ордеринг.
И у нас получится, естественно,
датарейс.
Если мы, например, напишем везде
relax, то будем как-то пытаться там
синхронизироваться.
Может ли быть такое?
На самом деле нет.
Если вы не пользуетесь тем кодом, который
полагается на
корректные модели памяти, в таком случае
у вас никогда
не будет mem-reant-safety.
Более того, это правда для произвольных
гонок.
Но здесь сразу же вопрос-ответ,
потому что вы вряд ли ответите.
Что насчет общих
датарейс-кондишенов?
Датарейс – это лишь в частном случае гонка
на каком-то конкретной очейке памяти.
Рейс-кондишен – это уже
произвольный и плохо синхронизированный код.
Рейс-кондишены уже могут
случаться в расе. Ваша программа может
задедлочиться, она может
разломать какие-то инварианты.
Но тем не менее,
это тоже не буду доказывать,
что вообще рейс-кондишен не может нарушить
memory-safety в расе.
Такая вот прикольная штука.
Поэтому получается, что
вышло то, что называется
fearless concurrency.
Если пишем код
в safe-raste, то в таком случае у вас
не будет никаких датарейсов, mem-reant-safety,
undefined-behavior.
Никогда.
А те
рейс-кондишены, которые у вас вылезут,
они не приведут к ми-reant-safety.
Поэтому мы свободны от рейса.
Прям полностью
от них избавиться мы конечно же не можем,
потому что такая система просто не имеет
права на жизнь. У нас весь
all the world is racy.
Железо, на котором мы запускаемся, на os,
на котором мы запускаемся, все с
гонками, поэтому
системы, в которые мы
говорим, что мы
избавились от рейс-кондишенов, она
скорее всего просто не планирует.
Вот.
Смотрите, это просто пример такой
просто. Я сделал
трейдспол, но при этом не заджойдется.
Я написал 10 здесь.
Соответственно, я выйду за пределы
вектора. Но тем не менее, вспоминайте,
вектор, если я попробую так вот сделать, я получу
панику, если у меня десятка кажется здесь.
Поэтому я не нарушил mem-reant-safety.
Как-то так.
Вот если у вас будет
unsafe-код, здесь вот,
мы сделали get unchecked, вот таким вот глупым
достаточно образом, то
в таком случае вы уже можете получить mem-reant-safety
и все потому, что у вас пользуется unsafe.
Вы не выполнили
какой-то контракт.
Примерно понятно
наша свобода от датарейса.
Откуда растут у нее
ноги.
Где у нас рейс кондицион?
Так.
Ну и то,
что я сказал, на самом деле Atomic
это multi-threaded cell просто.
Это такое вот число,
в котором мы пишем.
Много поточное.
А что же такое
multi-threaded ref cell?
MutexGuard?
Нет, просто Mutex.
MutexGuard
это именно вещь, которая получается
в результате лока Mutex,
а сам Mutex — это Mutex.
В общем, Mutex — это
такой примитив синхронизации,
который нужен для защиты
какого-то те.
То есть в плюсах у вас Mutex был какой?
Он у вас не защищал никакой те,
он просто был примитивный,
на котором можно было позвать лок,
на котором можно было позвать онлок.
Так что Mutex имеет
темплейтный аргумент те,
и когда вы делаете лок,
то он возвращает ссылку на элемент,
чтобы вы модифицировали.
И говорит, никто больше этот элемент, кроме вас,
сейчас не может модифицировать.
Все остальные будут блокироваться
при вводке за лочти.
В общем-то это точно ref cell.
Кстати,
мне кажется, того, почему Mutex именно те.
То есть это такой контейнер, который те имеет.
На курсе Concurrency
было ли такое, что вы писали просто Mutex
с нижним подчеркиванием где-то,
и в итоге вам ассистенты говорили — ай-ай-ай.
И вот непонятно, что защищает этот Mutex.
Наверное, же такое было.
В крайней мере, если посмотрите
на код Chromium,
то там, если есть какой-то Mutex,
там обязательно есть комментарий, что
вот этот Mutex защищает вот это и вот это.
Что это такое?
То есть примерно так же, как и в Rust,
защищается Ten, но на самом деле Mutex защищает
какой-то SharedState конкретно.
Поэтому на самом деле
вот такое вот устройство Mutex, оно более
правильное.
Кроме того, в Rust
есть еще
несколько приемлемых синхронизаций
в стандарт-бюллетеке.
Barrier, Condvar.
В общем, MPC — это
ченел, который мультипродюсируется
в тюнер, ревелок и once,
который вы видите, наверное, в первый раз.
Это такой сингл тон
для того, чтобы глобальные переменные
преимущественно нациализировать
лишь один раз.
И все остальное на время читать.
Выглядится примерно вот так.
Emit call once.
У меня есть getCachedWall.
Если значений
еще нет, то в таком случае вызовется
call once, иначе все те,
кто придут,
один сможет выставить, остальные заблокируются
до тех пор, пока вот эта
функция не пройдет. И потом они дойдут до вал.
И все будут проходить сквозь.
Примерно понятно?
Так.
Теперь представьте себе
такую штуку.
Наверное, плохо то, что я не показал
с Mutex, я думал, что это будет достаточно
просто, если честно.
Но смотрите, когда мы делаем
Mutex log, в таком случае нам
возвращается ссылочка на те, которые внутри
он сохранит.
Ну, не просто ссылочка, там MutexGuard
возвращается какой-то.
Ну, представьте себе
такую ситуацию, что пока вы
холдили этот лог,
у вас паника произошла
в вашем тарде.
Это не та вещь, которая вам может
нарушить memory safety, но тем не менее
она может сломать вам некоторые варианты в коде.
То есть, это достаточно плохо,
если вы модифицировали
какие-то данные, посреди модификации
у вас произошла паника.
Это означает, что вы были где-то посередине модификации
и, скорее всего, там какое-то неконсистентное
состояние на данный момент.
В общем, не так как
C++, когда вы будете блокировать
Mutex,
вы будете получать
logResult от MutexGuard,
ну, от MutexGuard,
который в свою очередь дает
либо вам лог, либо PoisonError.
То есть, logResult это просто
алияс на result от
MutexGuard и PoisonError.
Ну, просто, знаете, у нас же
result это двух template-ных
аргументов штука, но вот это просто
алияс.
Вот, если у нас там
PoisonError, то в таком случае Mutex
Poison, то есть
ядовитый, скажем так,
если вы его попробуете заложить,
то в таком случае вы
это способ просто сообщить, что Thread,
который модифицировал эти данные,
запаниковал во время того, когда держал
MutexGuard.
Вот.
Именно поэтому, когда
вы будете пользоваться Mutex, вам придется
написать Unwrap, скорее всего.
Ну, либо поматчить и посмотреть
Poison.
Как-то так.
Ну, и то же самое относится к Thread.
Это Poisoning тоже, когда
у вас возвращается значение,
что у вас паника либо значение.
И к MPSC
очереди.
Там тоже
будет возвращаться result.
Так, все.
Мне кажется, про параллельно сильно
нечего рассказывать после курса
Поэтому мы можем перейти, наверное, к Raid.
Если у вас вопросы какие-то
по
азам, параллельно
страсти.
Там все основные
штуки.
Да, там.
Вот это вот, это не весь список.
Мы же еще знаем Mutex есть.
И статомики.
Симфофоров нет.
Ну, ты как минимум кажется
можешь ограниченным каналом
пользоваться.
Да, вроде.
Я могу это написать.
Ну, это да, это
сильно.
Спит ноль.
Ну, что ты сразу?
У тебя еще целых полторы недели.
Все еще целых полторы дни.
Так.
Crossbeam.
Это такая штука, которая содержит
в себе всякие инструменты для
конкарн-компьютера.
Ну, даже не конкарн, это параллельно.
Да, и для конкурентного тоже.
Даже
для конкарн-компьютера.
Для параллельного слабо подходит.
Вот.
Существует для того, чтобы дополнить
функциональности Dsync или даже
чем-то поменять его.
Есть вероятность того, что
части этого крейта перейдут когда-то
просто такой достаточно популярный
крейт с хорошими примитивами
и раз, часто
какие-то части из
сторонних крейтов в свою
библиотеку стандартную
мувают, если там что-то хорошее.
Там даже есть всякие
конструкции для того, чтобы писать локфрия алгоритма.
Прикольно.
Сейчас посмотрим.
До начала у нас есть Crossbeam Scope.
Это такая
штука, которая создает Scope Thread.
Для этого я специально показал
такое очень страшное объявление
Scope Thread.
Давайте мы посмотрим сразу же, например, того,
как
его использовать.
Что значит Scope Thread?
Вы хотите все-таки иногда что-то брать
из своего
Scope.
Соответственно, вам нужно
гарантировать то, что у вас Thread
действительно заджойнится в конце этого Scope.
В общем, то, что делает Scope Thread,
это безопасно делать таким образом, чтобы вы могли
быть уверены в том,
что ваш Thread заджойнится и, соответственно,
не выйдет мой вариант.
Сдает Scope для всех
Thread'ов, которые там внутри запускаются.
Потом их джойнет
все те, которые еще не завершились.
Ну и разрешает
даёт возможность
Thread'ам всякие
кэп через локальные перемены.
Ну и во время паники
возвращает ошибку. Давайте посмотрим.
Вот я создал
какой-то вектор People,
в котором есть три имени.
И после этого
есть Thread Scope.
Смотрите, вот здесь есть S. S это
такой Scope, в котором я, собственно, создаю
Thread'ы. То есть я когда пишу
вот здесь S Spawn, то это означает то, что
я создаю Thread, который
будет заджойнен, когда я вот сюда
вот выйду.
Обязательно заджойнен.
Где-где еще?
Это то же самое, что это String.
Абсолютно.
Ну здесь
как видите, я могу абсолютно спокойно
обращаться к верхнему вектору
несмотря на то, что
я создаю новое Thread.
Потому что мне гарантировали, здесь обязательно заджойнется
все Thread. Это безопасно.
Ну как-то так, просто достаточно.
А, да.
Это Result.
Давай посмотрим здесь такую штуку.
Дело в том, что
эти все Thread'ы могут паниковать.
Здесь я выложил какую-то фигню в каждом из Thread'ов,
который создал, и после этого паникую.
Если я сделаю MapR
и после этого что-то попробую вывести,
то получу вот такие вот две ошибки.
Абъявление?
Абъявление этого хитра.
А,
было бы очень похоже на типо ошибок.
Сейчас хитра.
Кстати, PrintLn
многопоточный?
Да. Внутри синхронизируется.
Как синхронизируется?
Это было бы не очень хорошо, если Print был
не многопоточный.
Вот. Часть CrossBeamChannel.
Это такая штука, которая альтернатива
к MPSC,
но при этом это не SingleConsumer,
а MultiConsumer.
Канал?
Канал этот может быть
лимитирован или может быть не лимитирован.
То есть, есть два варианта канала,
bounded и unbounded.
Примерно так выглядит. Вот я создаю
какой-то конец,
который я могу посылать и конец,
который я могу брать. Вот я могу
послать, и так, у пять элементов,
и так как я создал канал размер
опять, то в таком случае, если я еще раз попробую послать
что-то, то мне заблокируется
строчка код.
Ну и второй пример.
Если я создам unbounded channel,
то я его буду просто спокойно посылать.
Естественно, если я буду использовать
recfn, то тогда я буду блокироваться,
если у меня нет ничего в канале
либо брать что-то из него.
Ну, в общем, канал,
каким вы его ожидаете, увидите.
Они еще могут быть не только
блокирующими и не блокирующими, они еще
могут быть с тайм-аутом.
То есть вы можете указать тайм-аут.
В стандартной фабрики есть такая штука,
называется duration, вы можете указать, сколько
вы ожидаете.
Ну, можете использовать, в общем, send
тайм-аут. Еще можно не блокирующим,
например, попробовать послать или попробовать
взять что-то из канала. Если ничего
нет, то вы сразу же закончите.
Эти хендлеры могут быть распределены
между трудами, ну, еще бы.
Мы предназначены
для многоточного программирования.
При этом канал
multi-producers, multi-consumer.
Если у нас все
хендлеры одного
из концов были сдропнуты, в таком случае
канал зайдет в
состояние disconnected.
Ну, disconnected это
вы, наверное, в домашней помните,
что означает?
Так.
Ну, в общем,
сообщения могут быть посланы тогда,
когда канал
закрыт. Вы всегда можете
читать уже посланные сообщения.
Ну, и операции
на тех
каналах, которые уже disconnected
не блокирующие, потому что вам
уже нет смысла
синхронизироваться.
Еще
канал, ну, естественно, это такая вещь,
которая очень похожа на итератор.
Мы можем использовать на нем итер.
Это, кстати, очень прикольно,
потому что мы еще на лекции про синхронность
тоже будем говорить про всякие синхронные
итераторы. На самом деле, если вы решали
задачу try, то
gat это
gat стали, скажем так,
путем для того,
чтобы сделать синхронный итератор.
То есть, на самом деле, появилось такое желание,
сделать gat, именно потому, что
в синхронности
будут эти штуки.
Это такой просто
прикольный факт. В общем,
можно итераторы на каналах
воспользоваться. Делайте next,
блокируйте, до тех пор пока не возьмете что-то из канала.
Вот, например,
можно воспользоваться select
каналах.
Разбемение тоже есть
с select.
Интересно,
будет такое?
Да, кажется, у меня
есть примерчик,
на то, во что он безсахарится.
Тут понятно, что происходит.
Если receive,
делаем такое-то, если send такое-то.
С курсом concurrency
помните, что такое select?
Я, правда, сам не
решал эту задачу, поэтому
она отличная.
Тебе, значит, наверное, лучше знать,
что из себя представляет select
в курсе concurrency.
А это то, как
собственно имплементировано.
Он безсахаривается примерно вот так.
Тут не стоит
вдаваться в подробности. Select
это какая-то структурка, в которую мы кладем
то, что ожидаем.
Ну и дальше, мач. Если операция такая,
делаем то-то.
Как-то так.
В смысле мы конструируем операцию,
а потом применяем ли select?
Да, select это просто
macros для того, чтобы примерно такой
откод сгенерировать.
Так.
Вот это вам должен понравиться.
Тут есть утилитки всякие. Cache-padded.
Помните про false sharing?
Кто помнит, что такое false sharing?
Да.
И это некоторые особенности
связанные с тем, что у нас есть
каши.
А в каши попадают все они по одному byte,
а в плацовок все четыре.
Сейчас ты нагребай до собой
некоторые другие данные.
Для этого мы сидим и перебрасываемся друг друга
и применяем данные.
Кажется, вроде бы в прошлом
Рома на тикет-локе делал пример,
потому что там два атомика внутри.
На тикет-локе
нам же нужно хранить, кто сейчас
исполняется и просто счетчик
номеров тех, кто пришел.
Проблема в том, что если они лежат
рядышком, то в таком случае у нас получается
false sharing. У нас 3D,
которая захватывает один атомик,
захватывает и другой, потому что
cache-линия больше, чем размер одного
атомика. Захватом целую cache-линию.
Теперь шпад предназначен для того,
чтобы с этим бороться.
Мы увеличиваем искусственный размер структуры,
но при этом самой структурой пользуемся
как ни в чем не бывало.
Там есть заранее на этапе компиляции
прописанные константы.
Они используют все минимальные числа байтиков,
которые, возможно, на данной архитектуре
дописываются после структуры.
Еще есть shard-лок.
Это как RV-лок,
но только шардированный.
Например, если хэш-таблицу будете писать,
шардированные всякие,
тогда, наверное, это будет очень полезно.
Идея в том, что
RV-лок было бы плохо,
если бы у нас был contention
на любой части таблички.
Поэтому мы хотим
как-то поделить, например, хэш-табличку,
которую делаем многопоточной,
на части небольшие.
Соответственно, получается,
что если мы хотим взять
и ты лок,
то нам нужно заблокировать
какой-то определенный шард,
а не целый RV-лок.
И в итоге получается, что у нас
более маленький contention на риде,
но большой на оврайте.
Потому что нам нужно заблокировать
вообще все RV-локи,
чтобы на оврайт взять.
Вот такая вот штука.
И в некоторых случаях бывает полезно.
Ибаков.
Кто был на курсе
распределенных систем литовского?
Да, это я в конкуренции нужен.
Да, это я в конкуренции нужен,
но мне меньше нравится пример со спин-локом, по-честному.
Мне нравится больше пример с консенсусом.
Правда.
Наверное, Никита помнит,
что Ибаков нужен для того,
чтобы trade-in было удобнее
друг с другом конкурировать.
Я потребую, чтобы он лидировался.
Мне не нравится.
Короче, Ибаков нам нужен для того,
чтобы рандомизировать время ожиданий,
и при этом делать все больше и больше,
если у нас не получается.
В кроссдивовском Ибакове
рандомизации кажется нет.
Главное, это экспоненциальное наращивание.
Чтобы минимизировать contention.
Да, наверное, если это на одном компьютере,
то там нет смысла увеличивать ожидания.
Если распределенную систему пишут,
когда хочется рандомизировать ожидания...
Но в кроссдивовском это чисто конкурент,
и там рандомизация...
Да-да.
В общем, это про то,
чтобы писать спин-локи.
Кстати говоря, спин-локи лучше не пишите.
Это плохая практика, не пишите спин-локи.
Несмотря на то,
что они какие-то прекрасные и красивые.
Есть еще дек.
Что-то прекрасно написано.
Это конкурентный дек.
Блин, дек...
Что-то написал как-то нега странно.
Как колодокарт дек.
Ну ладно, представьте,
что там написано нормальное пятибуквенное слово.
Это колодокарт, он и про воркстиллинг, так сказать.
Блин.
В смысле?
Так, ну в общем,
это дек, который поддерживает воркстиллинг.
Воркстиллинг.
Вот там есть несколько...
Получается...
Ну, несколько очередей для каждого трыда.
Для каждого трыда оно локально.
То есть, это локальная очередь.
И есть глобальная очередь для
всех трыдов.
Ну, есть...
Там я уже не буду показывать подробности,
но есть такая штука, называется стил,
для того, чтобы красть задачи из других трыдов.
Ну, естественно, будем их красть
с конца очереди другого трыда.
Примерно помните, как планировщик ГО написан?
Расти, пожалуйста, у вас есть просто
кроссбим дек и пишите планировщик ГО.
Только так.
Вот.
Это я уже сказал, что
сначала пытаемся есть глобальную очередь, а потом уже у кого-то украсть.
Еще есть эпоха.
Это гарбельдж коллектор для локарей алгоритмы.
Проблему АБА, наверное,
тоже помните. Примерно.
Возникала проблема АБА,
и в результате у нас получалось
так, что у нас какие-то объекты
просто не оставались...
не очищались. У нас получался
memory leak беспрерывный.
Эпоха — это такая штука, которая
решает эту проблему.
Она себе представляет такой
полу-гарбельдж коллектор, который
тогда, когда мы пытаемся
позаимодействовать
с нашим локфри-алгоритмом,
он пытается увеличить
номер эпохи,
а потом
удалить две последние.
Две последние на две назад.
Удалить эпоху, которая была в две эпохи назад.
Это, наверное, единственный нормальный
способ писать некоторые локфри-алгоритмы.
Просто у нас же нет ГЦ.
К сожалению,
локфри-алгоритмы некоторые не пишут
в каком-то виде хотя бы.
И потом
только не последние две эпохи,
а на две эпохи назад. Проходим
и удаляем эпоху.
Я без подробностей рассказываю,
но в целом понятно, что у нас CRUISE BIM прекрасен
и можно писать локфри-алгоритм.
Мы дошли до последней части лекции
для одной из прекрасных фичей
расты, называется RAIN,
предназначен для
параллелизации данных.
По CRUISE BIM понятно?
Смотрите, RAIN это крейд,
который предназначен для дайта параллелизма.
Все ли помните, что такое
OpenMP?
Да, там третий курс, в прошлом химестре
вы должны были писать на OpenMP.
Ну, короче,
это такой OpenMP,
но взрослый и хороший.
Современный.
OpenMP,
вот Никитин объяснил,
ты не помнишь, наверное, да?
Ну, представь, что у тебя есть
цикли кфор. Ты в цикле кфор
можешь делать какие-то вещи, которые друг от друга
совершенно не зависят на каждой итерации.
Хочешь сделать их параллельно, быстро.
Здесь такая штука OpenMP называется.
Сверху прагма,
ОМП-фор,
и поставить какие-то настройки,
и у тебя то, что произойдет,
компилятор за тебя сгенерирует какой-то код,
который просто в каждом трейде это запустит как-то
эффективно.
Поделить на части и запустит.
Это ты узнаешь, наверное.
Если бы на моем курсе был,
ты бы узнал через год.
Видимо, что-то поменялось.
Короче,
у нас Рейн умеет
вот так вот делать.
Мы пишем пар итер и получаем какой-то параллельный
итератор.
У нас был обычный итер, и мы могли
написать мэп сам, и все бы работало.
Когда мы пишем пар итер, по сути, вообще ничего не меняется.
Просто пар.
И на самом деле, то, что только
произошло, это мой код стал параллельным,
а я ничего не поменял уже.
В общем, Рейн оптимально
разбивает задачи между трейдами
и выполняет их.
Он оптимизирован
для всяких CPU-баунт-задач, естественно.
Потому что предназначен для параллелизма.
Предназначен, да.
И там внутри ворка стилинк
Threadpool еще.
Еще, кстати, кроме пар итер,
я, наверное, дальше в лекциях не показывал это,
кроме пар итера есть еще пар бридж.
Пар бридж он превращает из
любого обычного итератора
параллельный итератор. Но, естественно,
если пар итер неэффективно, он просто будет
по всем трейдам по одному элементу раскидывать.
Что немножечко неэффективно.
Ну, это зависит от того,
какой итератор, конечно. Если элементы
очень долго будут обрабатываться,
то, в целом, пара бриджа вообще никакой оверхеда
не будет снести за собой.
Если там очень быстро
обрадуются элементы, тогда нужно
постараться всеми силами сделать так, чтобы можно было
воспользоваться пар итер. Пар итер можно
использовать на всякой коллекции стандартной бюллетеки
вектор, слайс, даже на Б-дереве,
кэштаблицов и так далее.
И знаете, на самом деле это все, что
можно сказать о районе.
Пар итер, пар бридж, все прекрасно работает,
точно такой же код пишется.
Но давайте мы немножко пообсуждаемся.
Во-первых, есть такая прекрасная
статья, называется
Improve Portability and Performance
от автора Leba ImageQuant.
Это такая штука,
которая предназначена для работы с изображениями.
Изначально эта штука
была написана полностью на C.
Абсолютно полностью.
Но в какой-то момент
выяснилось...
А, ничего не выяснилось, просто автор
решил приписать на Rost.
В общем, что произошло.
Там есть
очень много статей моментов,
что нравится автору в расте.
Например, то, что он смог использовать
State of the Art хэштаблицу,
у него в сишке было написано хоть какая-нибудь,
чтобы не мучиться, потому что там же
нет никаких дженериков, очень сложное
управление зависимостью и все такое.
Ну и там про клипы были всякие...
Как сказать правильно?
Комплименты, в общем,
расту, но самое главное для нас
то, что он сказал про ray.
Дело в том, что OpenMP это
просто какая-то библиотечка, это расширение компилятора.
Она поддерживается
не всем компиляторами, не на всех платформах
и так далее.
Ну и, соответственно, получается, что
если вы хотите написать что-то
на OpenMP, то вы сразу же
очень сильно обрезаете количество платформ
на котором вы можете это сделать.
Где-то автор этой библиотеки
сказал, что в OpenMP
можно было использовать где-то на 1.8, 1.16
где-то.
Из платформ, которые он хотел поддерживать.
И компиляторов.
Ну, короче, так я вот делал.
Ну, что ему еще понравилось,
это то, что ray
увеличил... перфоманс
это еще ладно.
Хэштаблицу можно использовать крутую.
Да, это удобно,
но можно было точно такой же в Сишке написать.
Ну вот ray
действительно такая была вещь,
которая геймчейнина.
Она является библиотекой Rast.
Она везде работает, где есть компилятор Rast.
И Rast уж можно использовать...
Ну, ray, раз уж он такой переносимый,
приводит к тому, что
в общем, мы начинаем компилироваться
на тех платформах, на которых OpenMP
не компилировался.
Ну и после этого есть еще такая ремарка,
что portability C...
Ну, вы можете, конечно, написать аналог
ray на C попробовать,
но вы сразу же столкнулись с тем,
что он даже 3D создать нужно как-то портабельно.
И в итоге получается, что
какая-то идея о портабельности C
это платоническая идея
в головах его создателей.
Потому что по факту на данный момент это слишком сложно.
В современном мире,
с кросс-компиляцией, с множеством стандартов.
Ну, не получится
ругать конечно C, слишком старый язык
в этом смысле, но
все равно как-то
в этот раз
более современный язык советую его использовать.
Я его советую
и вам его подаю.
Да, еще плюс ко всему,
ray это такой крейд, у которого
никогда не было никаких проблем с
memory-safety, просто не было никогда.
Соответственно, несмотря
на то, что он использует NatriumSafe,
вы можете быть уверены в том, что если вы программу
компилируете, используя ray,
то она абсолютно memory-safe
и будет быстро работать, компилироваться под всеми системы
и все классно.
Давайте посмотрим на некоторые возможности,
которые предлагает ray.
Во-первых, у нас есть ray-join.
Join, он берет текущий трет.
Если мы запускаемся
внутри thread.pula,
то тогда текущий трет,
который дошел до join, это трет
из thread.pula, он идет
выполнять одну клаузжу, а вторую
дает thread-у.
В общую очередь задача
thread.pula управляет.
И там они возможно параллельно
выполняются, возможно как-то
последовательно, если вдруг не повезет.
Вы также можете использовать это
вне thread.pula,
то есть такая вещь,
которая удобна тем, что можно даже
абстрагироваться
от наличия либо отсутствия рантайма,
и у вас в таком случае
текущий трет, который не из thread.pula,
будет выполнять две клаузжи последовательно.
Скорее всего, это работает так,
вот и так, ты операцию B просто,
скорее всего просто операцию B
посылаешь в thread.pula текущий,
берешь thread.pula, управляешь в нее задачу,
а операцию A сам будешь выполнять.
А если thread.pula наунта,
возможно просто опера упор B и все.
Если это закончит свою задачу вторым,
то это начнет просто точка изображения.
Просто к тому, что нельзя блокировать
thread.pula, хорошо?
Да-да-да.
Вопрос интересный.
Thread.pula нельзя блокировать,
это все-таки параллельность,
у нас пока синхронности нет.
Да, и это как раз то, о чем я здесь писал,
все задачи предполагают, что они CPU bound,
что вы не идете пытаться читать что-то из сети,
потому что если клоузжи заблочатся,
в таком случае это вам помешает
утилизировать ядра вашего процессора,
приблизительно так эффективно.
Ну, пример использования.
Не пишите такой ксорт,
там есть парсорт, если что, в рейн.
Можно, например, как-то так написать,
написать свой partition, который будет делить
каким-то образом текущий слайс,
и после этого просто делать splitted-mute,
join, две сортировки, все.
Вообще красота.
Так, еще есть rain scope.
Это, в принципе, очень-очень похожая вещь
на то, что в crossbeam.
Но дело в том, что crossbeam
он же не имеет никакого threadpool,
а район имеет.
И поэтому, в то время как
rain будет отправлять задачи в threadpool,
crossbeam будет создавать новые труды.
То есть ключевое различие между ними
именно такое.
Еще, кстати, важный момент.
У нас есть еще один важный момент.
У нас есть еще один важный момент.
Еще, кстати, важный момент.
В join, когда вы пользуете join,
это все на стеке происходит.
Когда вы будете пользоваться scope,
то в таком случае вы будете делать allocation.
Поэтому предпочитайте join scope.
Ну, соответственно, scope
ждает, когда все задачи закончатся,
это блокирующая операция.
Она более универсальная, чем join,
но при этом использует кучу.
Так что используйте join по возможности.
Кажется, это все, да?
У нас лекция закончилась.
Больше нечего себе рассказывать.
Да, одна лекция по синхронности.
Ну что ж, вопросов нет?
Вопрос, как ниже низкого уровня работает?
Муф — это мем-копия.
Просто мем-копия.
Ну а если там есть
показатели на полях?
Если у меня поле,
это указатель на другой.
Ну, это называется
self-referential struct.
И такой раз тебе
не позволяет писать safe в подножистве.
OneSafe — это сам себе обратина,
если такое молишь. Вообще есть там PIN.
PIN — это тема следующей нашей лекции,
потому что нам о синхронности нужно будет,
чтобы структурки нельзя было молоть.
И нам понадобится PIN.
Мы об этом поговорим на следующей.
