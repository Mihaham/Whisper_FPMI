Всем добрый день. Давайте продолжим разговор про геометрию, которую мы начали разбирать в прошлый раз.
Давайте я напомню, что мы занимаемся вычислительной геометрией. В прошлый раз мы рассмотрели большой
набор задач, связанный с различными примитивами. Там точки, лучи, линии, отрезки. Немного рассмотрели
многоугольники и тому подобное. Я надеюсь, поняли философию того, чего на самом деле мы хотим,
и что если вы живете в целом мире, в мире со счастливыми координатами, то в целом
вы можете решать большинство задач абсолютно точно. То есть те, которые вам не нужно привлекать
с вашим иррациональным вычлением и тому подобное. Мы показали, что большинство задач на самом деле
можно решить без всяких приближений, абсолютно точно, даже не используя классы для рациональных
чисел и тому подобное. Сегодня в целом мы продолжим заниматься тем же самым, но сегодня у нас будет
довольно специфическая тема, потому что сегодня мы занимаемся выпуклыми многоугольниками.
Рассмотрим несколько вопросов, связанных с ними. Во-первых, сначала посмотрим на то,
как вообще проверить произвольный многоугольник на выпуклу, за какое время это можно сделать.
Дальше немного поговорим про то, а зачем вообще это нужно, как можно применять знания о том,
что многоугольник выпуклый или нет. И в последней части поговорим про построение выпуклых оболочек.
Тоже одна из ключевых задач по алгоритмах. Давайте начнем. Наверное, я не буду открывать
какую-то Америку, говорить про то, что такое многоугольник. В общем, на самом деле вполне себе
достаточно школьного понимания, что многоугольник называется выпуклым, если при проведении
какой-либо прямой вдоль некоторой стороны, если возьмете произвольную сторону, проведете вдоль
и так окажется, что все остальные вершины этого многоугольника находятся по одну сторону от данной
прямой, то соответственно данный многоугольник мы будем называть выпуклым.
Наверное, из этого определения свойства факта про выпуклые многоугольники, наверное, сразу же можно
придумать довольно незамысловатый алгоритм того, как можно проверять многоугольник на выпуклость.
Действительно, давайте просто-напросто что сделаем. Давайте возьмем произвольную сторону,
под тема ConvexityTest, то есть проверка на выпуклость.
Ну и первый алгоритм, который мы рассмотрим, это алгоритм, назовем его условно наивный,
наивный алгоритм от n², где n предполагается количество вершин многоугольника.
Давайте еще, наверное, нужно сказать про то, напомню, как мы представляем многоугольники в памяти,
значит памяти мы многоугольники храним в виде набора точек, по 0, по 1, по 2, по 3 и так далее, по 4, по n-1.
И при этом предполагаем, ну давайте сначала будем делать такое разумное предположение, что у нас
в принципе все точки, они отсортированы, скажем, либо в порядке от подобного уголника по часовой
стрелке, либо против часовой стрелки, это на самом деле не важно. Когда будем говорить про выпуклые
оболочки, на самом деле мы поймем, что даже если вам данного многоугольника с произвольными, ну если вам
данные вершины в произвольном порядке, то их всегда можно упорядочить с помощью довольно простого алгоритма.
Так вот, значит, наивный подход заключается в следующем. Ну, собственно, вот как я сказал,
по одному из определений выпуклого многоугольника мы говорим, что если мы проведем прямую через
произвольного сторону, то все вершины этого многоугольника окажутся по одну сторону. Ну,
мы умеем это делать. И мы умеем узнавать какую сторону от прямой находится та или иная точка.
Собственно, этим мы занимались прошлый раз. То есть условно мы говорили, что
в зависимости от того, куда вам направил Rider норм 스�емер нормnothing, у вас тогда соответственно при
постановке точки в уравнении прямой будет либо положительное число, точнее, неотрицательное число,
а либо не положительное число. И вот если для всех точек выполняется это свойство,
что при постановке точек в уравнение прямой все значения будут неотрицательные и
или неоположительный, то тогда, соответственно, это прямоугольный выплой.
Собственно, алгоритм очень простой.
Для каждой...
Давайте проведем прямую
через каждую вершину,
через каждую сторону,
и проверим,
что все вершины
находятся в одной
полуплоскости
относительно
этой прямой.
Ну, собственно, просто воспользовались определениями.
Я думаю, понятно, почему этот алгоритм работает за этот квадрат,
потому что у вас, грубо говоря, если сделать набросы к алгоритму,
то вы, по сути, перебираете
for h in полигон,
то я так условно подпишу, что у вас есть некоторый многоугольник,
вы перебираете каждую его сторону, каждое его ребро,
и дальше, собственно, перебираете for vertex
полигон, проверяете, что
все вершины
находятся по одному сторону
от прямой h.
Соответственно, я думаю, понятно, что мы перебираем все стороны, перебираем все вершины,
и, соответственно, получается двойный цикл, который даёт краски,
который краски даёт нам ассиплотику n².
Но это, наверное, не очень интересный алгоритм,
то есть мы умеем проверять за преднамеренное время
выкуплость многугольника, но, наверное, хочется чего-то быстрее,
то есть вряд ли, если вам
многугольник с, условно, тысячу вершин,
хочется тратить миллионы операций на то, чтобы просто проверить выкуплованный или нет.
Поэтому давайте подумаем чуть больше
и, соответственно, изобретем
более хороший алгоритм.
Давайте, на самом деле, воспользуемся просто набросом другим определением
выкуплости, ну, точнее другим свойствам, да,
выкуплости, которое говорит следующее, что
многугольник выпуклый
тогда и только тогда,
когда все внутренние углы...
Ну, давайте напишу так,
многугольник, сколько хочу, строго выпуклый,
если внутренние углы строго меньше,
или меньше либо равны, чем 180 градусов.
Если все углы строго меньше,
180 градусов, многугольник будем называть строго выпуклым,
а иначе будем называть его нестрого выпуклым.
Точнее, если у него какие-то углы,
если есть какой-то развернутый угол,
то будем считать, чтобы многугольник нестрого выпуклый.
Чем это определение лучше?
Лучше оно тем, что, на самом деле, мы таким образом можем
провести задачу не к проверке,
что мы через сторону проводим прямую и даже смотрим для всех точек,
а мы можем ориентироваться только по конкретной вершине,
посмотреть на конкретную вершину и, грубо говоря,
понимать угол, который она образует с двумя сторонами,
он меньше 180 градусов или больше 180 градусов и так далее.
Давайте посмотрим формально на то,
что я хочу сказать.
У вас есть какой-то многоугольник.
Что означает, что у него все внутренние углы меньше 180 градусов?
Мы начинаем с какой-нибудь стороны, например,
по 0 по 1.
Рассмотрим эту сторону, даже на самом деле можно смотреть этот вектор.
Давайте рассмотрим следующий вектор, следующую сторону,
по 1 по 2. Что можно сказать про этот угол?
Мы можем сказать про него то, что поворот
от вектора по 0 по 1 к вектору по 1 по 2
осуществляется в положительном направлении.
Внутренний угол меньше 180 градусов,
поэтому при повороте от вектора по 0 по 1 к вектору по 1 по 2
я получу положительный поворот в терминах ориентирных углов.
Что я могу сказать про следующий поворот?
Если у меня дан вектор по 1 по 2, я рассмотрю следующий вектор
по очереди по 2 по 3.
Снова, так как этот угол по определению выпустости должен быть
меньше 180 градусов, то снова этот поворот,
который я осуществляю от одного вектора к другому,
в том самом направлении.
Грубо говоря, всякий раз, когда я прохожусь вдоль моего многоугольника,
я каждый раз осуществляю поворот в данном случае против шестовой стоялки.
Это и означает, что у меня все внутренние углы
меньше, чем 180 градусов.
Например, давайте я чуть поменяю
и сделаю вот такую вот штуку.
Допустим, у меня вот такой невыпшенный многоугольник.
Вот этот внутренний угол больше 180 градусов.
Как я это понимаю? Я это понимаю просто тем, что
до этого у меня все повороты осуществлялись против шестовой стрелки,
а теперь от вектора по 2 по 3 к вектору по 3 по 4
у меня поворот осуществляется против
по шестовой стрелки.
То есть поворот у меня в терминах ориентированных углов
становится отрицательным.
Поэтому вот этот просто-напросто вот этот обход
вдоль многоугольника
может сразу сказать, выпуклый у меня многоугольник или нет.
Давайте подведем итог.
Алгоритм.
Алгоритм.
Смотрим
на углы
ориентированные.
Смотрим на ориентированные углы
между векторами по 0, по 1,
по 2,
дальше по 1, по 2,
по 2, по 3
и так далее.
Последнюю что у нас будет?
N-2,
дальше у нас в конце будет PN-2PN-1
и PN-1P0
вернемся обратно.
То есть просто-напросто посмотрим на последовательные углы,
которые образованы каждой из вершин.
Посмотрим на последовательные векторочки.
И соответственно, если
все знаки
давайте скажем больше
все ориентированные углы
одного знака
одного знака
то выпукует.
Иначе
иначе нет.
То есть все довольно просто
и прозаично.
Просто-напросто смотрим на значение,
на величину, точнее на знак угла
между последовательными вершинами,
точнее между векторами, образованные последовательными.
Вопрос, мы должны заранее знать,
что самопересечений нет в этом случае?
Опять же мы предлагаем,
что многоугольники у нас идут без самопересечений
и кажется, что кругляк многоугольники простые.
В нашем контесте тоже речь идет
про простые многоугольники.
И да, нет.
Мы рассматриваем только простые многоугольники.
Тут соответственно возникает два вопроса.
Алгоритм простой,
но есть два вопроса.
Первый вопрос заключается в следующем.
Как узнать знак поворота,
который образован двумя сторонами?
Это скорее вопрос в предыдущей лекции.
Как мы определяем знак ориентированного угла?
Векторное произведение.
Тут не нужно прибегать никаким арксинусам,
рактангенсам и тому подобное.
Вот.
Вот.
Смотрим на знак этого самого векторного произведения.
И соответственно понимаем,
что у нас все повороты либо положительные, либо отрицательные.
И еще один момент нужно сказать,
что если у вас вдруг какой-то поворот оказался нулевым,
то векторы стали коллинеарны,
то тут уже зависит от задачи.
И если вектор не стал равно нулю,
то если от вас требуют строгую выпуклость,
то ответ нет.
Ответ все еще да.
Это первый момент.
Второй момент, естественно,
со сколько это все работает.
Я думаю, вы понимаете, что сложить этого алгоритма
просто от N работает за чистую линию.
У нас есть многоугольник, у которого N-вершин.
На самом деле кажется, что это наиболее эффективный алгоритм,
потому что сложно ожидать,
что у вас найдется какой-то алгоритм,
который по произвольному многоугольнику скажет вам,
что у него выпукло или нет,
просто не посмотрев на все стороны или на все вершины.
Вот такой простой алгоритм
проверки многоугольника на выпуклость.
Нет вопросов, правильно понимаю?
Можем идти дальше.
Давайте пойдем дальше.
Следующим пунктом давайте коротко поговорим про то,
где вообще можно применять
выпуклые многоугольники.
Отлично, мы умеем проверять многоугольник на выпуклость,
но зачем это может быть нужно?
Я думаю, вы понимаете,
что многие алгоритмы,
в частности, мы в прошлый раз это обсуждали,
что некоторые алгоритмы можно записать гораздо проще
и работать гораздо быстрее,
если мы точно знаем, что многоугольник не просто простой,
но еще и выпуклый.
Не нужно рассматривать всякие противные случаи
с тупыми углами,
и тому подобное, и тому подобное.
Точнее, с углами больше, чем 180 градусов.
Давайте в качестве примера я приведу классическую задачу,
которую мы рассматривали в прошлый раз.
Мы рассмотрели в прошлый раз ее решение
за линейное время.
Давайте я сейчас покажу ту же самую задачу решить
в предположении, что у нас многоугольник выпуклый,
гораздо более приятное время.
Речь идет про задачу проверки
проверка
принадлежности
точки
внутренности
выпуклого
многоугольника.
Мы в прошлый раз в конце лекции
рассмотрели задачу проверки
принадлежности точки
просто произволивая многоугольник.
Давайте я кратко напомню, что мы делали.
Мы просто брали точку и пускали луч
в произвольном направлении,
дали его в горизонтальном направлении,
не было каких-то противных случаев.
Считали просто количество пересечений с прямой.
Мы в прошлый раз не обсудили этот вопрос,
но, я думаю, всем понятно, что этот алгоритм,
который мы рассматривали в прошлый раз, работает за линейное время
от размера многоугольника.
Потому что мы смотрим на луч,
и для каждой стороны смотрим, пересекает ли этот луч
сторону конкретную или нет.
То есть при пересечении луча и отрезка
мы можем сделать за о от единицы.
Это требует одного векторного
и одного скалянного произведения.
Тоже рассматривали в прошлый раз.
А вот теперь другая задача.
Гарантированно нам дан выпуклый многоугольник,
и нам нужно проверить, принадлежит ли точка внутренности
такого многоугольника или нет.
Это линейное время.
Значит, как я это буду делать?
История такая.
Давайте изобразим какой-нибудь выпуклый многоугольник.
И возьмем какую-нибудь произвольную точку.
Просто можно взять первую точку,
которая лежит в массиве вершин.
По 1, по 2, по 3, по 4, по 5.
Возьмем произвольную точку,
например, точку по 0.
И давайте мысленно проведем вектора
от этой точки до всех остальных вершин.
Проведем вектор по 0 по 1, по 0 по 2, по 0 по 3,
по 0 по 4, и по 0 по 5.
Вот такие вектора.
Что можно сказать про эти вектора?
Что можно сказать про последовательность этих векторочков?
По 0 по 2.
По 0 по 1.
По 1 по 2.
По 2 по 3.
Ну там, по n-1.
Что я пишу?
По 0 по 2.
По 0 по 3.
По 0 по n-1.
Вот есть ли в этой последовательности векторок
какое-нибудь хорошее свойство?
Замечаете вы его или нет?
Ну, например, не знаю,
что можно сказать по углу,
который образуют эти вектора
с направлением вектора по 0 по 1.
Может, они все лежат в одной полуплоскости?
Они лежат в одной полуплоскости, это да,
потому что угольник выпуклый.
Давайте в терминах углов.
Я смотрю на угол, который образует вектор по 0 по 1,
с прямой, которая содержит этот вектор.
Дальше смотрю на вектор по 0 по 2, по 0 по 3,
именно в таком порядке.
Полярный угол увеличивается.
Давайте заметим следующую вещь.
Мы предполагаем,
что так у меня все точки,
все вершины многоугольнику упорядочны
вдоль какого-то обхода.
В данном случае я изобразил
против числовой стрелки положительное направление.
В принципе, может быть такое,
что и в отрицательном направлении.
И плюс тот факт, который вы назвали,
что у меня все точки находятся в одной полуплоскости,
краски дают мне понять то,
что все эти вектора
уже ассортированы по величине полярного угла
относительно вектора по 0 по 1.
Заметьте, что все величины углов увеличиваются.
Это нам пригодится.
Вот это хорошее наблюдение.
Давайте запишем отдельно.
Вектора
расположены
в порядке.
Возрастание
предназначение
или еще, может быть, убывание
ориентированного угла
относительно
вектора по 0 по 1.
Отлично.
Разобрались. Теперь давайте, наконец,
посмотрим точку, которая представляет для нас интерес.
Давайте возьмем точку,
которая лежит где-нибудь здесь.
В данном случае она находится внутри многоугольника.
Давайте еще раз.
Изображу ее здесь.
Точка лежит внутри многоугольника
или вне многоугольника.
Это первый шаг.
Второй шаг.
Проведем
вектор
по штриху.
Проведем вектор от 0
по штриху.
Короче говоря, сформируем вектор по 0 по штриху.
Смотрите, что я могу сказать.
Во-первых, эта точка...
Давайте сначала определимся с относительным положением
этого самого вектора относительно других векторов.
А именно давайте сделаем следующую вещь.
Давайте определим... Третий шаг.
Определим
между какими
направлениями...
Направлениями я имею ввиду
вектора по 0 по 1, по 0 по 2
между какими направлениями
расположен
вектор по 0 по штриху.
Снова вопрос вам.
Понимаете ли вы, как это можно сделать?
Как можно... Смотрите, для точки по штриху
я могу сказать, что
вектор по 0 по штрих находится между векторами по 0 по 3 и по 0 по 4.
Для точки по 2 штриха
он находится между векторами по 0 по 2 и по 0 по 3.
В целом, если точка находится где-то вот здесь,
то я могу сказать, что она находится дальше,
чем вектор по 0 по 5.
Если точка находится здесь, então unbelievable, что находится дальше, чем по 0 по 1.
что это можно сделать эффективным способом, если нам на уголик выпадать.
Да, правильно в чате пишут, отлично, действительно bin поиск.
Смотрите, из первого пункта следует, что направления отсортированы.
А из этого следует, что можно воспользоваться либо lower bound,
то есть, по сути, бинарным поиском, либо lower bound и upper bound.
Если мы найдем lower bound или upper bound, то по сути мы найдем векторы,
которые находятся в смысле ориентированного угла ближе всего к моему вектору.
Если я запущу бинарный поиск на этих направлениях для вектора по ноль по штрих,
то я получу вектор по ноль по четыре.
Я буду понимать, что вектор по ноль по штрих находится между векторами по ноль по четыре и по ноль по три.
Потому что по определению upper bound и lower bound, upper bound возьмет, что по ноль по четыре это первый вектор,
у которого угол больше, чем по ноль по штрих.
То же самое могу сказать про по ноль по два штриха.
Отлично. Вроде как разобрались, что мы теперь эффективно...
Давайте напишем, что это работает за от log n.
До этого первый и второй пункты мы проделали мысленно,
а третий пункт мы делали полезную работу, выполнили бинарный поиск.
И наконец финальный вопрос.
Допустим, мы умеем определять, между какими векторами у меня находится вектор по ноль по штрих.
А теперь вопрос, а как понять, лежит ли точка по штрих внутри многоугольника или нет?
Как понять, что точка по штрихе лежит внутри многоугольника, а по ноль по два штриха нет?
Все, отлично. Проверили, принадлежит треугольнику. Отлично.
Четвертое. В пункте три, ну последний пункт, говорим, что в пункте три нашли pi и pi плюс один.
Соответственно, из этого следует проверяем принадлежность по штрих треугольнику,
по ноль, по и, по и плюс один. Естественно, это занимает от единицы.
Я думаю, проверить принадлежность треугольнику вы все можете.
Если по ноль по штрих пересекает по три по четыре, то лежит, иначе нет.
В целом можно и так проверить пересечение двух отрезков, согласен.
Если посмотрим на отрезок по ноль по штрих и отрезок по четыре по три, то если они пересекаются,
правда это или нет, ну кажется, что да, если они пересекаются, то соответственно не принадлежит,
хотя может лежит на границе, ну это уже зависимость от задачи.
А если не пересекаются, то соответственно точка лежит внутри.
Можно проверить принадлежность треугольника.
Так или иначе, каким бы способом вы не воспользуете, я думаю, вы понимаете, что в данном случае мы свели задачу,
к заданию на большом многоугольнике, к заданию на маленьком многоугольнике, ну часто на треугольнике.
По сути свели задачу к одному педагогному поиску и поиску и определению принадлежности точки треугольнику.
Суммарно алгоритм работает за О от логай.
Так, есть ли вопросы по этому алгоритму? Да, надо не забыть, что одно замечание стоит, давайте пока.
Ну вроде вопросов нет, тогда у меня к вам есть, тогда есть вопрос у меня к вам, смотрите.
Замечание.
Ну, смотрите, в бинарном поиске, да, в бинпоиске.
А вам необходимо сравнивать,
сравнивать углы между собой.
Ну, давайте я поясню, что я имею в виду. Вот у меня есть, вот у меня есть вектор по 0 по 1.
И понятное дело, чтобы понять, какой из углов больше, то есть условно у меня есть по 0 по штрих,
и у меня есть какой-нибудь по 0 по i.
Я хочу понять, какой из этих двух углов у меня больше.
Ну, давайте если посмотрим на третий пункт, определим между какими направлениями расположен по 0 по штрих.
Ну и как бы, когда я сравню, то есть я хочу сравнить ориентированные углы между собой.
То есть я хочу сравнить ориентированный угол между 0 по 1 и 0 по штрих, и между 0 по 1 и 0 по i.
Давайте обозначу. Я хочу сравнить вот этот угол и вот этот угол между собой.
И вот тут смотрите, какой вопрос.
Кажется, что когда мы говорили про ориентированные углы, мы всего лишь говорили про то, как определить знак ориентированного угла.
То есть мы умеем определять знак ориентированного угла с помощью векторного произведения абсолютно точно.
А вот тут мы попадаем в ситуацию, при которой нам нужно сравнить непосредственно сами углы, то есть сами значения углов.
И вот тут возникает вопрос. Получается, в этом случае нам нужно уметь вычислять какие-нибудь арксинусы, арктангенсы, углов,
соответственно, получать их какое-нибудь радианное представление.
И в итоге мы приходим к речью с тем, что я сказал до этого, что все алгоритмы наши стремимся к тому, чтобы все алгоритмы работали абсолютно точно.
Вот вопрос. Понимаете ли вы, что углы на самом деле можно сравнивать тоже абсолютно точно, не прибегая к всяким иррациональным вычислениям,
арксинусам, аркосинусам, арктангенсам и тому подобное?
Понимаете ли вы, как по данной картинке, не по картинке, конечно, как каким-нибудь алгоритмам проверить,
что угол, образованный по 0 по 1 по i, угол по 0 по 1 по i, он больше, чем угол по 0 по 1 по штрих.
Нужно посмотреть на знак попарного произведения последовательных векторов.
Знак попарного произведения, я не совсем понимаю, что вы говорите, но на знак векторного произведения действительно нужно будет посмотреть.
Но вот на знак какого произведения?
Знак какого векторного произведения даст мне ответ на вопрос, какой из углов больше?
П1 по штрих и по штрих по i.
Я на самом деле не согласен.
Скорее всего надо посмотреть на угол между P0 по i и разностью векторов P0 по i и P0 по штрих.
Вот это может сработать.
Давайте сейчас к этому вернемся.
Почему мне не нравится вот такой угол?
P1 по штрих и по штрих по i.
Просто потому что вы предлагаете вот такие углы, вот такие вот вектора рассмотреть.
Но в целом ничто не мешает вот этому вектору P0 по i быть очень длинным.
И тогда он окажется здесь.
И соответственно угол уже будет в данном случае отрицательным.
Хотя мы понимаем, что от длины вектора направление не должно зависеть.
Тут у вас получается, что зависит.
Поэтому такой план не подойдет.
То, что сказал Голос, видимо, посмотреть на знак между P0 по i и разностью по i по штрих.
По-моему, тут такая же ситуация, кажется.
Вот это, кстати, может подойдет.
Надо подумать.
Сейчас P1 по 0, P4 по 0, P4 по 0, P1 по i по 0.
Давайте упростим задачу.
Давайте я скажу, как это проще всего сделать.
Проще всего посмотреть всего лишь на одно векторное произведение.
Векторное произведение P0 по штрих и P0 по i.
То есть, грубо говоря, достаточно посмотреть на знак вот этого угла.
Вы согласны, что если я знаю знак угла между P0 по штрих и P0 по i, я знаю, какой направлений у меня больше.
Если поворот рассчитывается в положительном направлении, то, соответственно, P0 по i находится дальше, чем P0 по штрих.
А если знак будет отрицательный?
Давайте я просто другую картинку нарисую.
Если у меня ситуация будет какая-то такая, P0 по 1, тут P i, а тут P штрих, то, соответственно, знак поворота от P0 по штрих до P0 по i будет отрицательным.
И это будет означать, что на самом деле у меня угол P0 по i находится меньше, чем угол, который образует вектор P0 по штрих.
Убедил? Понятно.
Ну, надеюсь. Давайте нормально пропишу, что смотрим на знак этого произведения.
И если обход многоугольника осуществляется в положительном направлении и знак...
Давайте так скажем, что если знак обхода многоугольника совпадает со знаком произведения,
то мы говорим, что P0 по i больше, чем P0 по штрих.
Ну, все, а иначе меньше.
Ну, меньше ли дровно, в зависимости от того, 0 или 0.
Ну, что значит знак обхода?
То есть тут я везде предполагал, что у меня обход многоугольника осуществляется в положительном направлении, то есть против числовой стрелки.
Ну, естественно, вы понимаете, что если вдруг у меня вершина многоугольника отсортирована по числовой стрелке, то тогда у меня знаки поворота будут отрицательными.
И соответственно, в этом случае мне нужно будет смотреть на отрицательный знак.
Все понятно?
Ну да, понятно.
Отлично. Замечательно.
Так, давайте подведем небольшой промежуточный итог и, соответственно, пойдем на 5-минутный перерыв.
Мы коротко вспомнили про то, что такое многоугольники, рассмотрели простейший алгоритм проверки на выпуклость, но простейший и эффективнейший на самом деле.
Ну и, надеюсь, я сейчас убедил, что выпуклость играет роль, то есть если вдруг у вас многоугольник выпуклый, то вы какие-то задачи можете решать гораздо эффективнее.
Например, проверять принадлежность к точке многоугольника вместо линейного алгоритма, можно применить алгоритм, который работает за log n.
Ну и заодно обсудили, я надеюсь, поняли то, что направление, точнее, величину углов между векторами можно сравнивать, опять же, не прибегая к артинусам и артангенсам.
То есть можно тоже смотреть чисто на векторные произведения.
Вот, значит, после перерыва поговорим про выпуклые оболочки, ну а пока давайте отдохнем 5 минут.
Давайте продолжим. Как и планировали, давайте поговорим про выпуклые оболочки.
Для начала традиционно, что это такое?
Выпуклые оболочки.
Начну. Выпуклые оболочки, или ВО, называется минимальная, давайте так, выпуклые оболочки, множество точек S, называется минимальная,
по включению выпуклое множество.
Выпуклое множество. Ну тут, наверное, надо пояснить, что такое выпуклое множество.
Ну то есть это множество, которое, давайте так скажем, которое с любой парой точек содержит все промежуточные.
Промежуточные. Ну то есть если вам известно, что вашему множеству выпуклые принадлежит точка A и принадлежит точка B, то выпуклые множества гарантируются, что все эти точки между ними тоже содержат.
То есть если содержат две точки, то соответственно весь этот отрезок тоже содержит.
Ну то есть, грубо говоря, интуитивное понимание такое, что вот это множество не выпуклое, потому что я могу взять вот эти две точки и могу провести вот такую линию, которая в центре не принадлежит множеству.
В то же время, если я возьму такую фигуру, то соответственно понятно, что какие бы я две точки не взял, то любой отрезок, который соединяет эти две точки, он тоже будет лежать на третьем множестве.
Называется минимальное по включению выпуклое множество. Ну собственно, содержащее.
Содержащее.
Давайте просто так. Содержащее S.
Обозначается, как он S.
В целом задача построения выпуклой оболочки.
Если возьмем какое-нибудь абстрактное множество, то в принципе выпуклая оболочка тоже может выглядеть практически произвольным образом.
То есть может представлять себя произвольную выпуклую фигуру.
Например, если я возьму, представьте, что я взял большое количество.
Ну что значит большое количество? Просто счетное количество точек, которые расположены по окружности.
То я думаю, вы понимаете, что выпуклая оболочка такого множества будет являться вот этой самой окружностью.
То есть окружность, которая, точнее круг множества.
Круг, который краски проходят через все эти счетные точки.
Это значит в счетном случае, если число точек счетно.
А теперь давайте рассмотрим ту же самую постановку.
Теперь я возьму конечное число точек, которые расположены по окружности.
Конечное число точек.
Ну что я могу сказать? Во-первых, понятное дело, что если я возьму круг,
у которого в качестве окружности выступают окружности, который содержит все эти точки.
Это будет выпукло множество, которое содержит все эти точки.
Но при этом, для выпуклы оболочки важно, чтобы это было не просто произвольное выпукло множество,
минимальное подключение, чтобы еще никак сильнее, грубо говоря, его уменьшить нельзя было бы.
Поэтому, если у меня есть какие-то точки, которые расположены, которые лежат на одной окружности,
то уже минимальная оболочка в этом случае будет вот такой вот многоугольничкой. То есть я просто
провожу отрезки между ними и, соответственно, получаю вот такую вот выпуклую оболочку.
Я думаю, вы понимаете, что никаким образом дальше сильнее ужать это я вообще не смогу,
потому что, скажем, если я проведу прямую какую-то линию между ними вот так, то, соответственно,
я потеряю вот эту связанность. И, соответственно, аналогично с другими. Если я проведу как-то вот
так, то, соответственно, эта оболочка уже не будет, точнее, эта ночь уже не будет минимальна,
и так далее. Но, вообще говоря, можно в качестве замечания написать следующую вещь. Замечание.
Значит, доказывать этого утверждения я не буду, но интуитивно, я думаю, оно понятно, что если
s конечно, то con от s это многоугольник с вершинами из s.
Если у вас количество точек во множестве s бесконечное число, то, в принципе, у вас
выпуклая оболочка может являться, ну, вообще говоря, какая угодно выпуклая фигура. Вот я привел пример,
когда есть окружность. А если у вас конечное число точек, то, в принципе, вы всегда можете,
то всегда выпуклая оболочка в множестве точек является многоугольник. Ну, почему? Ну, не знаю,
просто-напросто можно перебрать всевозможные многоугольники, которые образованы этими
самыми точками, и пересечь их все вместе. Так как вы берете пересечение, то вы гарантированы,
ну, во-первых, все многоугольники являются выпуклыми, во-вторых, когда вы берете пересечение,
то уже выпуклость сохраняется, ну и, соответственно, за счет того, что вы берете всевозможные пересечения,
да, эти пересечения конечны, у вас получается, как раз, во-первых, многоугольник, а во-вторых,
соответственно, вы достигаете минимальность таким образом, потому что эта фигура, это,
во-приворе, будет минимальной по включению. Соответственно, главный вопрос, хорошо,
мы умеем работать с многоугольниками, вы посмотрели это на первой половине лекции, соответственно,
в прошлый раз осталось только понятие, как, собственно, вот по данному набору точек построить
ее выпуклую оболочку. Ну и для этого у меня для вас есть, не знаю, в зависимости от того,
что успеем, либо два, либо три алгоритма. Давайте рассмотрим их по порядку.
Первый по порядку у нас будет алгоритм Джарриса.
Иногда его еще называют алгоритм заворачивания подарка.
Ну и действительно он похож на процесс какой-то запаковки и так далее, и эффективно довольно
понятен. Что мы сделаем? Давайте набросаем какое-нибудь произвольное количество точек.
И, соответственно, по данному мнению точек нужно построить выпуклую оболочку, то есть построить
минимальный многоугольник, который содержит внутри себя все вот эти самые, все вот эти самые
точки. Там минимальный, естественно, выпуклый многоугольник. Что мы будем делать?
Первый шаг простой. Давайте найдем точку, которая гарантированно войдет в нашу выпуклую оболочку.
Давайте я добавлю еще одну точку. Найдем точку по 0, которая гарантированно
будет частью выпуклой оболочки. Вершиной давайте.
Понимаете ли вы, что можно взять в качестве такой точки?
Точка с минимальной обсысой, либо с минимальной x координатой, либо с минимальной y координатой.
Я думаю, это понятно, что если у вас точка находится левее всех, то она гарантированно должна быть
вершиной многоугольника. Иначе вы построите многоугольник только по правым точкам, естественно,
левая точка никуда не войдет. Отлично. Еще надо дополнительно рассказать, что если вы берете точку
с минимальной обсысой, с минимальной x координатой или минимальной y координатой, и таких точек
несколько, то, соответственно, мы еще выбираем либо самый левый из них, либо самый правый из них.
Просто грубо говоря, берем самую крайнюю точку. Давайте для определенности скажем, в качестве такой
можно взять
аргумент по y среди всех p из s. Если таких несколько,
несколько с минимальной x координатой.
В данном случае у меня в качестве такой точки выступает вот эта точка. Давайте ее обозначим
как по ноль. Первый пункт простой. Следующие пункты тоже простые. Смотрите, почему алгоритм
называется алгоритм заворачивания под арк? Представьте себе, что эти точки это не точки,
а просто какие-то гвоздики, которые забиты в дощечку. И вот мы нашли минимальную точку,
и давайте за нее зацепим какую-нибудь веревочку. Зацепили веревочку, и соответственно протянули ее
далеко. И что делаем? Просто берем и заворачиваем эту веревочку вокруг нашего
множества гвоздиков. Что мы сделаем? Когда мы будем поднимать эту веревочку наверх,
мы столкнемся с каким-то гвоздиком. И уже будем оборачивать этот подарок,
вот эту упаковку и веревочку вокруг этого гвоздика. Поднимаем потихоньку наверх,
и мы встречаем вот эту самую точку. Дальше у нас веревочка цепляется за эту точку,
и соответственно мы продолжаем заворачивать упаковку, подарок, не важно что, вокруг уже этой
точке. И следующим встречаем вот эту точку. И так далее. Просто берем веревочку и соответственно
оборачиваем вокруг всех остальных точек. Вопрос заключается в следующем. На таком
идейном уровне все понятно, все замечательно, но хочется на формальном алгоритмическом
или математическом уровне понять, что это такая точка, за которую мы зацепимся в следующий раз.
Понимаете ли вы, каким свойством обладает точка, на которой мы упрямся в следующий раз.
То есть, грубо говоря, какую точку нам в следующий нужно добавить вот в нашу выплывную оболочку.
Как добавить следующую?
Например, давайте в этом случае рассмотрим. Мы понимаем, что следующая точка, которая будет
добавлена, это будет вот эта точка. Следующим пунктом нашей выплывной оболочки будет
эта сторона. Вопрос, а каким таким свойством хорошим она обладает, что мы ее выделяем среди
всех остальных? Опять же, с точки зрения алгоритма по математике. С минимально положительным углом.
Да, можно сказать, что с минимально положительным углом. То есть, если вы обход делаете в положенном
направлении, то да. Действительно, тут достаточно посмотреть на величину угла, на величину угла
между текущим вектором. Давайте обозначим, не знаю, по 1, по 2 и по 3. То есть, действительно, давайте
посмотрим на угол между вектором по 1, по 2 и по 2, по 3. Заметим, что этот угол является, во-первых,
положительным. На самом деле можно не уточнять, что минимальный положительный угол, наверное.
Да, можно не уточнять, что минимальный положительный, потому что у вас в любом случае может и будет
получаться выпуклым. Все точки будут находиться в положительной стороне. Но самое главное,
самое главное, что этот угол минимальный.
Например, если я смотрю вот какой-нибудь такой угол,
точнее вот такое вот направление,
то он уже не будет минимальным, но будет больше, чем вот то,
которое я смотрел сейчас, чем p2, p3.
Соответственно, действительно,
давайте просто-напросто найдем
вектор, который
будет обладать минимальным углом
среди всех точек, которые еще не добавлены
в выпуклую оболочку.
Как добавить следующую?
Найдем...
Ну, давайте так напишем.
Пусть
последняя...
Так, тут я забыл давать...
Ну, я сейчас напишу пункт 1 штрих,
что
добавим
p1,
которая...
Ну, p1,
такую что...
Пусть что...
p0, p1
образует
мин угол
с горизонталью.
Горизонталью.
Ну, сейчас я хочу просто делать индуктивный переход,
в котором мне нужно две последние точки.
То есть, условно, первую точку p0 мы берем
с минимальной координатой.
p0, p1 мы берем тоже по углу,
но смотрим уже на угол относительно горизонтали.
Надо вот тут вот...
У меня штриховка обозначена горизонталью, соответственно,
p0, p1 имеет наименьший угол
относительно этой самой горизонтали.
Вот. Соответственно, пункт 2.
Вот он, пункт 2.
Пусть последние
добавленные
добавленные
точки
это p-1,
p-i.
Просто найдем
найдем p-i
плюс один,
как
аргмин
величины угла, ну, собственно, вот того,
который я сказал, который вы сказали,
p-i,
p-i плюс один,
вот так.
Ну, аргмин по p-i плюс один, естественно.
Вот.
Соответственно, еще раз
давайте вернемся к замечанию,
которое обсуждали вот здесь,
что величину угла,
величину угла, ну, точнее,
сравниваем углы, сравниваем углы,
мы как раз таки, опять же, с помощью векторного произведения,
то есть не нужно вычитывать их напрямую.
То есть мы в качестве базового вектора
берем вот этот вот самый вектор,
p-1, p-i, и дальше для всех остальных точек
проверяем вот это вот самое векторное произведение,
точнее,
ну, короче говоря, сравниваем,
короче, берем минимум вот по этому самому
векторному произведению.
То есть если мы выбрали какого-то кандидата,
скажем, если у нас есть кандидат
p-,
и мы смотрим на произведение,
если у нас есть кандидат
p-, и так оказалось,
что
p-
p-2-
сейчас
вот здесь p-i
минус 1,
здесь p-i
p-i минус 1
и вот у меня есть две точки, скажем,
p-
и p-2-
Вот как мне понять,
что точка p- лучше,
чем точка p-2-?
И достаточно посмотреть на
произведение p-i
и p-i
p-2-
Если поворота осуществляется в положительном направлении,
то значит, что точка p-
что угол для нее меньше,
соответственно, p- лучше,
ну, p- меньше,
чем p-2-
А если знак наоборот
отрицательный, то соответственно,
p-2- лучше, чем точка p-3-
Вот таким вот образом мы
проверяем вот этот вот самый аргумент
Вот
Идея, я думаю,
понятна
в стиле реализации
можно на семинарах обсудить
Идейно просто
выбираем действительно угол
выбираем минимальный угол относительно
вот секущего направления
Давайте закончим
строение, тут минимальный угол,
соответственно, будет вот этот угол, дальше тут минимальный угол,
вот этот угол, ну и в конце мы
к начанию точки вот
строили вот такую вот
вот такую вот оболочку
По сути все
1 пункт 1 штрих
и пункт 2
Что я хотел еще сказать
Найдем точку p-0
Найдем p-1
добавим следующую
Ну и то, как мы выбираем минимум, я тоже
обсудил вроде как
Есть ли вопросы по этому алгоритму?
Сейчас мы обсудим его сложность
А пока давайте просто идею
Понятно ли, что мы сделали?
Окей, хорошо
Теперь давайте обсудим
сложность
Какая у этого самого алгоритма сложность?
Ну давайте пообсуждаем
Соответственно, пункты 1 и 1 штрих
мы учитывать не будем, они выполнены
за вот единицы
А, тут важный момент, понятное дело,
что нужно третий пункт написать
То есть в какой момент мы должны остановиться
Давайте допишем, что
Повторяем
Повторяем пункт 2
Пока p-1
не равно 0
То есть пока мы не вернулись
к сводную точку, то
мы продолжаем строить нашу кладоволочку
На этом я думаю понятно
Теперь давайте обсудим сложность
Давайте обсудим сложность пункта 2
И соответственно сколько итераций
точнее сколько раз мы этот пункт 2 выполнили
Тут как бы у нас стоит цикл while
то есть while p-1 не равно p-0
То есть пока точка, которую мы добавили
не равна точке по 0, мы повторяем пункт 2
За сколько выполняется пункт 2?
За сколько мы можем найти минимум
вот этого самого
угла между направлением
pi-1 pi и pi-1
точнее, вот за сколько мы можем найти
вот эту точку pi-1?
За сколько мы ищем минимум?
За отn, да, действительно
Действительно, пункт 2
выполняется за
Давайте вот это отдельно напишу
Значит, пункт 2
выполняется за отn
То есть мы ничего умнее
чем минимум за линейное время
придумать не можем
потому что, опять же, вам исходно дан набор точек произвольный
он никак не отсортирован и так далее
Поэтому никаких динарных поисков
и так далее, к сожалению, применить не получится
Поэтому, соответственно, используем
отn
Поэтому минимум ищем за отn
И вопрос, сколько итераций?
Сколько?
Итераций
Сколько итераций поиска минимума мы сделаем?
Мы сделаем
Ну, смотрите, пункт 2 мы повторяем
до тех пор, пока не построим
Да, n это пессимистичный оценок
Сейчас мы к ней придем
Пункт 2 мы выполняем до тех пор, пока не построим
выкуплую оболочку
Но выкуплая оболочка, если давайте обозначим
что модуль
с, то есть количество вершин
в выкуплой оболочке равно h
соответственно, число итераций будет
как раз таки h
И поэтому итоговая сложность у нас получается
отn умножить на h
Давайте еще упечатну, что h это
количество вершин
в выкуплой оболочке
То есть сложность алгоритма за o от n h
Да, действительно, в худшем случае
все точки будут в выкуплой оболочке
Пример мы уже приводили, когда все точки лежат
примерно на однойок polishing
Достаточно рассмотреть ситуацию, когда у меня
почти все точки принадлежат выкуплой оболочке
То есть действительно
в худшем случае
алгоритм работает за o отn2
В худшем случае
алгоритм работает за o отn
То есть, если
если вдруг так повезло, что у вас выплыва оболочка это всего лишь какой-нибудь треугольник,
внутри которого расположено много точек, то в принципе вы справляетесь за линейное время.
Но хуже, в случае действительно o от m квадрат, и это не очень приятно.
Это по сути означает, что множество из 10 тысяч точек вы будете обрабатывать примерно секунду.
Скажем, вам множество из 100 тысяч точек или даже множество из миллиона точек вы за разумное время,
вы не обработаете. Печально.
Преимущество алгоритма Джарриса заключается в том, что он простой, что у него есть довольно хороший и лучший случай.
И плюс, если вдруг так получилось, что вы заранее знаете число точек выплыва оболочки,
по каким-то своим соображениям, вы знаете, что в центре скоплено много точек, а на периферии точек мало,
тогда алгоритм Джарриса можно применить. Но в общем случае действительно он может давать довольно плохой результат.
Перед чем перейдем к более эффективному алгоритму, более эффективному опять же в терминах худшего случая,
наверное было бы интересно обсудить следующий вопрос.
А насколько вообще быстро и эффективно можно построить выплывную оболочку в теории?
И вот тут еще небольшой пункт. Нижняя оценка на скорость
построения выплывной оболочки.
Ну давайте я еще напишу дополнительное замечание, что так называется в алгебраической модели.
Сейчас поясню, что это такое в алгебраической модели.
Ну смотрите, на одной из первых лекций, на второй лекции, когда мы обсуждали с вами Фибоначью Пирамиду,
мы с вами пришли к выводу, что Фибоначья Пирамида почти все операции имеет выполнять за 1 единицей.
Например, операция у Декриске выполняет за отлагарифм в амортизированном смысле.
И мы с вами обсудили, что в принципе даже в теории в общем случае нельзя построить структуру данных,
типа пирамида, которая бы все операции могла выполнять за единицей.
Потому что иначе это бы противоречило теорияме, которая утверждает, что сортировку быстрее, чем зеленый логен, построить нельзя.
Вот тут на самом деле та же самая история.
На самом деле оказывается, что задачу сортировки можно свести к заданию построения выплывной оболочки.
Довольно интересным образом. Сейчас я к этому перейду.
На самом деле оказывается, что если вы умеете строить выплывную оболочку за линейное время,
то по сути вы умеете сортировать тоже за линейное время.
Но чего, естественно, невозможно.
Давайте приведу пример такого сведения.
Как можно свести задачу сортировки к задаче строения выплывной оболочки.
Допустим, вам данные числа x1, x2, x3 и так далее.
Давайте x0, xm-1.
Их нужно отсортировать.
Как мы это сделаем?
Давайте я представлю, что x0, x1, x2, x3 и так далее это координаты x.
А координаты y, грубо говоря, из этих чисел составлю следующие точки.
x0, x0 в квадрате, x1, x1 в квадрате и так далее.
xm-1, xm-1 в квадрате.
Грубо говоря, у меня была прямая, на которой были какие-то точки.
А я просто-напросто построил на них параболу.
x0, x1, xm-1.
Здесь, соответственно, xm-1 в квадрате и так далее.
Соответственно, точки лежат у меня на параболе.
А теперь я сделаю следующую вещь.
Давайте я просто на этом множестве точек.
Первый пункт, второй пункт, третий.
Построим ВО на пункте 2.
Вот.
Соответственно, если построили ВО быстрее, чем...
быстрее, чем за n лог n.
Давайте напишем ω от n лог n.
То и отсортировали, то и отсортировали быстрее, чем за ω от n лог n.
Почему это так?
Потому что задача построения выпуклого блокчика, по сути, заключается в том, что вы находите вершины выпуклого многоугольника.
Мы договорились, что у нас многоугольники, естественно, все вершины упорядочены вдоль какого-то обхода, вдоль обхода по числою следов, или по числою следов.
Соответственно, когда вы построите многоугольник, то вы заодно и построите, грубо говоря, некоторые упорядочения этих самых вершин.
Но, соответственно, упорядоченные этих вершин как раз таки, вдоль параболы, в одном направлении параболы или в другом направлении параболы, как раз таки даст вам сортировку.
Поэтому кажется так, что точки будут отсортированы.
На самом деле, эта модель не совсем та, которую мы рассматривали в первом семестре, или рассматривали, когда обсуждали пирамиду.
То есть там все-таки модель была такая, что нам разрешено делать только операции сравнения, то есть для сортировок, которые основаны только на сравнениях.
Верно, что быстрее, чем взаимодействовать, сортировать нельзя.
А тут кажется, что мы знаем точно, что мы сортируем числа, и тут мы можем применять какую-то алгебру.
Но на самом деле оказывается, что алгебра тоже, по сути, ничего хорошего не дает.
То есть на самом деле, если вы никаких свойств чисел не знаете, то есть не знаете, что это целые числа, или не знаете, что это какие-то равномерно распределенные дробные числа,
числа с вещественной числа, то, соответственно, тоже в общем случае быстрее, чем взаимодействовать, сортировать не получится.
Такое небольшое обоснование, почему выпуклую оболочку быстрее, чем взаимодействовать, тоже строить довольно сложно.
Хотя есть алгоритмы, которые строят выпуклую оболочку из-за линейного времени, опять же, при условии каких-то хороших предположений о множестве.
Ну это так, небольшой офф топ, просто интересный факт.
Давайте, собственно, от этого слайда перейдем к алгоритму, который действительно...
То есть мы поняли, что у нас есть нижняя оценка на скорость построения выпуклой оболочки, это n log n.
Ну и, соответственно, давайте перейдем к примеру алгоритма, который умеет строить выпуклую оболочку за этот самый n log n.
И этот алгоритм называется алгоритмом Грехома.
Ну, история у него такая же, как и у алгоритма Джарвиса, ну, по крайней мере, первые 2 пункта, 1 и 1 шлик совпадают.
То есть находим по 0, давайте я пропущу, как в Джарвисе.
1 штрих находим по 1, тоже как в Джарвисе.
Давайте я поясню сейчас, что значит в Джарвисе.
Вот набор точек.
Находим точку с минимальной y-координатой, а дальше находим эту по 0.
И находим p1, который образует минимальный угол с горизонталью.
Построили первые две точки.
Что делаем дальше?
Давайте напишу отдельно.
Добавленные точки будем хранить в стеке.
То есть в данный момент у меня в стеке находится точка по 0 и точка по 1.
А, блин, я забыл за важный момент сказать.
Чем алгоритмом Грехом отличается от алгоритма Джарвиса?
Отличается он тем, что...
Второй пункт.
Отсортируем все точки.
По величине угла относительно вектора по 0 по 1.
Естественно, это занимает n лога.
И спойлер, этот пункт занимает большую часть времени.
Все остальное мы сделаем за линию.
Соответственно, выбрали направление по 0 по 1.
То есть первые две точки выбрать в логике довольно несложно.
Ну а все остальные точки мы отсортируем по взрастанию этого самого угла.
То есть это будет первая точка, вторая, третья, четвертая, пятая, шестая, восьмая, девятая, десятая, одиннадцатая.
По величине угла, по взрастанию отсортируем все точки.
Ну и давайте еще отдельно напишем, что если у точек одинаковый угол, то у взрастания длины вектора.
Если точка расположена на одной прямой, скажем АВ, то А будет меньше, чем В.
Отсортировали.
Дальше делаем следующую вещь.
Как я уже сказал, мы добавлены точки, будем хранить в стеке.
В третьем пункте будем делать так.
Возьмем, перебираем точки в порядке взрастания, который получен на пункте 2.
Возьмем, перебираем точки в порядке взрастания, и если ПК минус 1, ПК угол, ПК, ПИ,
то значит точки ПК минус 1, ПК, это последние две точки, стеки, ПИ, текущая точка.
И если смотреть вот этот угол, давайте вот так сображу.
Давайте сделаем так.
ПК2.
И вот тут пусть будет ПК3.
И если вот этот угол меньше нуля, то есть что это означает?
У меня уже в стеке есть какие-то точки, и если я рассматриваю очередную точку,
и этот угол у меня получается развернутым, то есть внутренний угол получается больше, чем 180 градусов,
то есть поворот осуществляется в отрицательном направлении, то это означает, что у меня что-то идет не так.
То есть если у меня получилась вот такая ситуация, то это означает, что в данный момент у меня выплывала оболочка,
построенная неправильно.
Что я в этом случае делаю?
И если вот так, то удаляю последние точки из стека,
удаляю по одной, пока вот этот угол, ПК-1 ПК, ПКПИ не станет положительным, не станет больше нуля.
То есть грубо говоря, что я делаю?
Смотрите, я заметил, что вот этот угол получился такой, вот этот вот угол конкретный.
Что я делаю?
Я удаляю тогда точку П2 из рассмотрения, из моей выплывой оболочки, и рассматриваю теперь вот такую ситуацию.
П2 у меня остался здесь, и соответственно теперь я говорю, что буду рассматривать точку П0, точку П1 и точку П3.
Вот этот угол стал положительным, поэтому я оставляю так как есть, и добавляю ПИ стек.
Давайте более красиво напишу на картинке, что я делаю.
Ну вот, представьте, что у меня уже построена какая-то выплывая оболочка, вот так, вот так, вот так, вот так, вот так.
Ну и тут какие-то точки лежат, вот очередная точка здесь.
То есть тут П0, П1, П2, П3, П4, П5, П6.
Все точки я рассматриваю по возрастанию этого самого угла.
Ну и теперь очередь дошла до точки П4.
Все вот эти точки расположены в стеке.
П0, П1, П2, П3, П4, П5, П6.
Соответственно, на текущей итерации я рассматриваю вот этот вектор и вот этот вот вектор П.
Что я вижу? Смотрите, я вижу, что в данном случае, в данной ситуации,
у меня угол, который образует вектора П5, П6 и П6, П3, он отрицательный.
Что это означает? Это означает, что у меня не получается в данный момент построить выплывую оболочку.
Точнее, что у меня фигура в данный момент многоугольник получается не выплывой.
Ну, я в этот момент не отчаиваюсь, я просто-напросто говорю, что давайте я выкину точку П6, и стек тоже я выкину.
Соответственно, буду проверять теперь угол относительно вектора П4, П5 и П5, П3.
А про П6 я просто-напросто забываю.
Снова смотрю и вижу, что поворот от вектора П4, П5 до вектора П5, П4 осуществляется в отрицательном направлении.
Но снова меня это не устраивает.
Получается, что у меня в данный момент многоугольник получается не выплывой.
Чтобы гарантировать, что он будет выплывой, мне достаточно что сделать.
Мне достаточно просто-напросто удалить по 5, ну и из стека тоже удаляю по 5.
И, соответственно, теперь я проверяю вектора П3 по 4 и по 4 по штрих.
Все, смотрите, я вижу, что в этот момент у меня многоугольник остался выплылым.
И, соответственно, я спокойно-душом могу добавить по штриху в стек и продолжить алгоритм дальше.
Вот такая вот история.
Давайте кратко обсудим, почему это работает.
На самом деле это довольно понятно.
Можно рассуждать по индукции.
Индукция заключается в том, что на каждой итерации, после каждого добавления точки стек,
у вас построена выплылая оболочка для всех точек, которые вы уже рассмотрели.
Давайте в этом убедимся.
По предположению индукции у вас построена корректная выплылая оболочка для этого множества точек.
Тут есть какие-то точки, и для них вы построили корректную выплылую оболочку.
Вот она.
По 0, по 1, по 2, по 3, по 4.
Что можно сказать дальше?
На текущей итерации я рассматривал точку по штрих.
Что я знаю про направление по 0 по штрих?
Я знаю, что все точки, которые находятся правее, я уже рассмотрел.
Все точки, которые находятся правее, находятся правее, чем по 0 по штрих.
В этом смысле сторона по 0 по штрих сохраняет выплылость моего многоугольника.
Все вершины находятся правее нее.
Это следует из-за того, что я все углы рассматриваю в порядке взрастания.
Наконец, осталось понять, действительно ли все точки, которые находятся внутри треугольника по 0 по 4,
действительно ли все эти точки находятся внутри этого треугольника?
Это тоже действительно так.
Я избавился от точек по 6 по 5.
Вектор по 4 по штрих явно находится выше, чем направление на по 4 по 5 или направление на по 4 по 6.
Соответственно, это означает, что все точки, которые находятся...
На самом деле тут точек быть не может.
Все точки, которые находятся вот здесь, они гарантированно находятся ниже, чем эта сторона по 4 по штрих.
Соответственно, что я получил?
Я получил, что у меня фигура гарантирована в букле по строению.
Я гарантировал, что все углы у меня образуют положительный поворот.
Во-вторых, я убедился в том, что у меня все рассмотренные на текущий момент точки, они гарантированно находятся внутри этого самого многоугольника.
Это краткое обоснование, почему это работает.
Есть ли вопрос по работе алгоритма?
Пора бы закончить, перейти к следующей лекции.
Понятно ли, что сейчас произошло или есть вопрос?
То есть в целом история простая.
Сортировку написать все могут, отсортировать по углу это просто.
А дальше просто заводим stack, в котором храним точки, которые образуют мою выпуклую оболочку.
Когда берем очередную точку в порядке возрастания, смотрим на знак угла, который образует последние две точки,
то есть пока-минус-один-пока и текущий вектор, пока-пи.
Если этот угол отрицательный, то все плохо.
Нужно последнюю точку из stack удалить.
Снова проверяем. Если новый угол отрицательный, снова удаляем последнюю точку из stack.
Ну и так далее, пока мы не найдем этот самый нужный положительный угол.
Как только угол стал положительным, и все, отлично мы победили, кладем очередную точку в stack.
И все.
Ну и продолжаем, понятное дело, до тех пор, пока не переберем все точки.
Вопросов вроде нет, поэтому давайте, собственно, обсудим сложность алгоритма.
И закончим на этом.
Сложность.
Сортировка.
Сортировка, как мы сказали, работает за nlog n.
Вот это пункт 2.
А пункт 3.
Вот с пунктом 3 интересно.
Смотрите, мы вроде как, sdstack и sdsort можно тут будет использовать.
Ну sort, естественно, stack.
Но sdstack вас не получится использовать, потому что вам нужно смотреть на последние две точки.
Понимаете, да?
Пк и pk-1.
sdstack позволяет вам посмотреть на верхнюю точку, а на предпоследнюю не получится.
Вот это плохая новость.
А хорошая новость, ну, использовать sdvector.
Я надеюсь, вы понимаете, как sdvector превратить в stack, у которого можно посмотреть две последние точки.
Да.
Соответственно, на чем я остановился?
А, да, третий пункт.
Ну, смотрите, кажется, что третий пункт теоретически работает долго.
Почему?
Потому что, смотрите, на каждой итерации вы добавляете точку и плюс еще удаляете какое-то неопределенное количество других точек.
Но на самом деле я хочу сказать, что пункт 3 тоже выполняется за oatn.
Выполняется за oatn.
Почему?
Сам себе знаю вопрос.
Смотрите, в пункте 3 на каждой итерации добавляем ровно одну точку в выпуклую оболочку.
И удаляем несколько.
Позвольте, остальное я просто вслух поговорю.
Значит, не буду писать.
В общем, смотрите, теперь давайте посмотрим просто на каждую отдельную точку, на ее жизнь.
Как выглядит жизнь любой точки.
Жизнь любой точки довольно прозаично.
Она один раз ровно один раз добавляется stack, и, возможно, один раз удаляется из stack.
Смотрите, после того, как я удалил точку из stack, к ней я больше никогда не вернусь.
Жизнь любой точки состоит из двух вещей.
Во-первых, она гарантированно будет добавлена в stack в какой-то момент.
А во-вторых, возможно, она когда-то будет из него удалена.
Все мои действия сводятся к тому, что я один раз добавляю точку и один раз удаляю ее.
Все, других действий у меня нет.
Но, соответственно, а так как всего точек у меня n, то и, соответственно, действия я тоже сделаю не больше, чем 2n.
Из этого следует не больше, чем 2n действий.
Пункт два, сортировка, занимает n log n.
Ну а пункт три, все эти махинации со stack-ом, суммарно занимают линейное время.
Поэтому построили алгоритм Грехма, который работает за n log n.
Можно временно удалить верхнюю и посмотреть вторую.
Ну, можно и так.
Зачем?
Мне кажется, вектор будет гораздо проще воспользоваться.
Ну, не знаю. Развлекайтесь, как хотите.
Так, время. Что у нас там по времени?
Да, надо будет сделать перерыв. У нас еще разговор про наследование запланирован.
Так, есть ли вопросы?
В общем-то, детали реализации вы еще дополнительно, естественно, обсудите на семинарах.
Ну и в целом, на этом, наверное, с геометрией мы закончим.
В следующий раз будем обсуждать другую тему.
Вопросов нет. Отлично.
Тогда предлагаю лекцию по алгоритму завершить на сегодня.
Давайте сделаем перерыв 10 минут.
Большой перерыв.
Через 10 минут, когда поговорим про плюсы.
