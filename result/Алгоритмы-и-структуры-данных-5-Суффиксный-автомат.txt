Так, добрый день, продолжаем про строковые суффиксные
структуры.
У нас был суффиксное дерево, сегодня суффиксный автомат.
Значит, по моим представлениям об этой жизни, суфф дерево
и суфф автомат в каком-то смысле взаимозаменяемые
структуры, и, грубо говоря, достаточно знать что-то
одного из них.
На семинаре должна быть задача о том, как построить...
Ну, в общем, есть очень простое соответствие между
суфф автоматом для строки S и суфф деревом для строки
S-реверсунда.
То есть, если вы строчку записываете справа налево,
для нее стоит суфф дерево, а для исходной просто построили
суфф автомат.
Давайте напишу автомат.
Здесь дерево.
То они, ну, там будут практически одним и тем же объектом.
То есть, у них будет одинаковая структура рёбера переходов,
надо будет только понять, что написать на ребрах.
То есть, в каком-то смысле это очень похожие вещи,
и чтобы решать какие-то задачи, достаточно знать
одной структуры.
Это уже, в общем, вам на выбор, что вам более понятно,
что кажется более простым для написания и так далее.
Ну, что такое автомат сначала?
Давайте нарисуем какие-нибудь картинки.
Что такое детерминированный...
конечный автомат.
Так, кто знает, что это такое, пожалуйста, дайте знать.
Которое что, еще раз?
Ну, это на формалах должно быть.
Наверное, только по моему тематику, я надеюсь.
Вот.
Ну, концепция очень простая.
Это граф, ориентированный, у которого на ребрах написаны
какие-то буквы.
Так, я сейчас что-нибудь нарисую интересненькое.
Дальше, какая-то вершина помещена стартовой, давайте
вот так вот буду выделять у старт.
И какие-то вершины помещены терминальными.
Ну, давайте, например, будет у меня вот эта терминальная
и вот эта терминальная.
То есть, это ориентированный граф, где одна вершина выделена
в качестве стартовой и несколько в качестве терминальных.
Дальше, этот автомат, он все слова, ну, над, скажем,
произвольным алфавитом, либо принимает, либо не
принимает.
Принимает он те слова, которые соответствуют каким-то
корректным путям из начальной вершины в одну из терминальных.
Например, этот автомат принимает слово AB, ABE или, например,
ABCA.
Можно вот так пройти по этой петле и тоже прийти в терминальное
состояние.
Давайте нарисуем какие-нибудь примеры.
Принимает AB, ABE, потому что он заканчивается в этой
терминальной вершинке, ABCA, ну, например, можно целиком
пройти вот эту вот петлю и еще AB в конце, ABEXAB.
В общем, любой корректный путь по ребрам, по буковкам
заканчивающихся в терминальной вершинке это принимаемое
слово.
Все остальное это непринимаемые слова, не принимают.
Например, this automaton не принимает слово А, потому
что оно ведет в не терминальную вершину.
Не принимает слово ABEX, потому что, ну, опять-таки не
ведет в терминальную вершину.
Ну, и более того, он не принимает слово С, потому
что мы вообще не можем даже такое слово прочитать
в автомате.
Мы не можем встать в стартовую вершинку, прочитать как-то
С и закончиться в тюрьме.
Мы даже просто её прочитать не можем.
Поэтому это слово тоже считается непринимаемым.
Ну, формальное определение писать не буду.
Нам главное вот это вот интуитивное понимание
плюс картинка.
А ещё, значит, нужно сказать, что такой детерминированный
Это значит, что не бывает вот таких вот случаев.
Не бывает случаев, когда из одной вершины есть два
перехода по одинаковой букве.
Ну, так же, как у нас было в боре, в сухдереве.
Нельзя, чтобы была какая-то неоднозначность про чтение.
То есть, встав в вершинку, если мы хотим пересвечить
какую-то букву, то вариантов действия максимум один.
Но не два и больше.
Вот, значит, детерминированный, конечно, автомат.
И мы у такого автомата, ну, по сути, у такого графа
можем определить множество принимаемых слов.
Пусть А автомат через L от А будем обозначать множество
принимаемых им слов.
Вот, и нам нужно будет построить такой автомат, как можно
меньшего размера, чтобы он занимал как можно меньше
памяти, строился как можно меньше по времени, который
бы принимал все суффиксы некоторой строки и только
их.
По данной строке S построить, ну, вот я напишу, минимальный
в каком-то смысле автомат, а такой, что вот это вот
L от А, это есть все суффиксы строки S и только они.
То есть, автомат принимает еще только суффиксы некоторой
фиксированной строки S.
А почему, например, мы не делаем автомат, который
принимал бы все префиксы?
Ну, потому что он тривиальный, можно просто написать вот
так вот S сверху вниз по символю S1, S2, и так далее S&N, и все
вершины сделать терминальными, тогда мы понимаем все
префиксы только их, да, потому что начав из стартовой
вершинки, прочитав какой-то путь, это обязательно будет
префикс, мы заканчиваем терминальное вершине, тут
как бы автомат не очень интересен, а вот суффиксами
уже будет похитрее.
Хорошо, ничего дальше, определение.
Вот у нас есть некий язык, да, у нас есть язык суффиксов
строки S.
Дальше, если мы хотим строить автомат для какого-то произвольного
языка, в нашем случае это будет множество всех суффиксов
строки S, но давайте пока для произвольного языка.
Значит, пусть L произвольный язык, то есть произвольное
множество слов.
Отношение эквивалентности относительно этого языка
мы вводим, но сначала вводим правый контекст, значит,
если x это слово, то r с индексом l от x, это все такие, скажем
z, что xz это слово из языка.
И это мы будем называть правым контекстом.
Правый контекст, слово x относительно l.
То есть правый контекст это множество всевозможных
дополнений x справа до слова из языка, то есть что-то
мы пишем справа так, чтобы это было слово из языка.
Полезное такое мнимоническое свойство, правило, как это
следующее.
Что такое вот эти дополнения справа?
Это, например, когда вы заходите в поисковую строку,
вбиваете там некое начало вашего запроса, а вам предлагают
несколько дополнений до популярных запросов.
В этом плане можно в качестве l рассматривать набор популярных
запросов, что у гугла часто спрашивают.
x это то, что вы уже успели вбить, а z это все возможные
продолжения типа как быстро, если x это как быстро, то
в качестве z вас может быть почистить зубы, сшить
что-нибудь.
Все, самые популярные запросы дополняет в поисковую строку
вбивать.
Значит, дальше мы вводим отношение эквивалентности.
Мы говорим, что два слова эквивалентны относительно
языка l, если и только если у них одинаковый правый
контекст.
Слова эквивалентны, если и только если у них одинаковый
правый контекст.
Так, ну и дальше теорема Майхилла Нироуда.
Она говорит примерно следующее, что если у вас есть некий
язык l, вот как у нас здесь фиксирование некий язык,
и относительно него есть сколько-то классов эквивалентности.
Скажем, вот все слова нашего алфавита, все слова из
сигма звездочки, как-то разбились на классы эквивалентности
в соответствии с этим отношением.
Ну, конечно, это отношение эквивалентности, потому
что тут тоже отношение эквивалентности.
Все слова разбились на классы эквивалентности, и утверждается
теоремой, что в минимальном автомате, который бы принимал
ровно этот язык l, то есть распознавал бы этот язык
l, число состояний равно в точности числу класса
эквивалентности.
Ну давайте я это напишу.
Пусть l это произвольный язык.
Пусть, будьте здоровы, относительно отношения, относительно отношения
тильда с индексом l, есть ровно k классов эквивалентности.
K классов эквивалентности.
Тогда в минимальном диссерминированном, конечно, автомате, который
распознает в точности l, который принимает l, ровно
вершин.
В минимальном, ну давайте здесь напишу, полном, диссерминированном
в конечном автомате, принимающем l, ровно а вершину.
Вот, то есть если игнорируем это слово полный, то по сути
нам количество классов эквивалентности относительно
введенного отношения и говорим, сколько у нас
будет минимальный число вершин в диссерминированном
автомате.
Да, минимальный, минимальность здесь понимается с точки
зрения числа вершин, минимальный по числу вершин.
Ну смотри, что такое отношение эквивалентности, это по сути
набор пар x, y таких, что у них вот это вот одинаково.
Дальше, если у вас фиксировано некое отношение эквивалентности,
вот это вот tilde sin xml, то у вас все сигма звездочка
бьется на вот такие вот множества класса эквивалентности,
такие, что внутри каждого класса любые два слова
находятся в отношении, а меньше два слова не находятся
в отношении.
В этом смысле отношение эквивалентности это как
бы пары, находящиеся в отношении, а классы эквивалентности
это как раз множество такое, что внутри множество все
они попарны в отношении, а если добавить любое другое,
то они уже не будут в отношении.
Ну это будет без доказательства, это как бы для тех, у кого
есть формалки, вы наверное уже должны знать, если нет,
скоро узнаете.
Да уже должны знать.
Вот.
А для нас это значит примерно следующее, что вот это отношение
эквивалентности, в которое мы вводим равенство правых
контекстов, это и есть, собственно, оценка на то, сколько вершин
в автомате мы будем ожидать.
Сколько вершин в автомате, соответственно, каждая
вершина, по сути, представляет собой некий класс эквивалентности.
Так, хорошо, ну соответственно, из-за этой теории мы будем
возиться очень долго с классами эквивалентности относительно
нашего языка, разбираться, как они устроены, как устроены
правые контексты, что бывает, когда там между ними какие-то
соотношения и так далее.
Значит, давайте с этого момента считаем, что L это все суффиксы
строки S, а также в качестве всех строк там X, Y и так далее
мы будем рассматривать только под строки S.
Ну, потому что если мы берем какой-то не под строку,
да, какой-то набор символов, который не является под
строкой S, он у нас, ну, давайте напишу, значит, если X это
не под строка S, не под строка S, то скажите, пожалуйста,
чему равен правый контекст этой строки?
Пустое множество, да, потому что если это не под строка,
то мы ее как ни пытаемся, мы не можем добить ее до
конца строки S, до суффикса, поэтому это пустое множество.
Ну и более того, это, собственно, критерии того, что X не
под строка S, значит, и наоборот, если RL от X это пустое множество,
то X не под строка S, потому что иначе будет под строкой
хотя бы одно продолжение до конца было бы, мы можем
что-то дописать, то есть есть под строка, есть какое-то
окончание до конца строки, соответственно, вот это
было бы нашим элементом правого контекста, а мы
предполагаем, что нет ни одного элемента.
То, Эпсилон, пустая строка, ну, как бы пустая строка
это тоже строка, сигма звездочка, тут есть пустое слово.
Вот, ну чего, значит, как бы не под строками можем
выбросить, они все характеризуют всем, что у них правый контекст
пустой и в терминах нашего автомата, который мы в итоге
построим, это будут те слова, которые не отвечают
корректным путям в автомате, то есть вот, например, на
этом рисунке вот C это то самое не под слово, то есть
мы стоим здесь, мы даже не можем его прочитать, мы
не можем, начав стартовывершинку, прочитать C, ровно то же
받아path, то же самое будет с непод строками C, там
как бы какую часть можем прочитать, например, ABB,
AB мы можем прочитать, AB отсюда уже прочитать не можем,
мы из автомата вываливаемся.
Ровно то же самое будет происходить с непод строками,
мы ближе до кута доходим, потом не можем прочитать.
Вот, поэтому давайте пока игнорировать и считать,
что все строки, которые мы рассматриваем, это под
строки С.
Начну утверждение, если правые контексты двух подстрок
одинаковые, давайте их назову U и V, если правые контексты
двух строк одинаковые, то либо U suffix V, либо, наоборот,
U suffix U, то есть слова, лежащие в одном классике
эквивалентности, потому что мы знаем, что совпадение
правых контекстов – это то же самое, что лежать в
отношении эквивалентности, значит, слова, находящиеся
в отношении эквивалентности, являются обязательно
одно суффиксом другого.
Ну, доказательств здесь нехитрое, смотрите, раз
правые контексты совпадают, и они не пустые, потому
что мы договорились не рассматривать строки с
пустым правым контекстом, то есть хотя бы один общий
элемент.
Есть некое вот продолжение, есть некий вот тот самый
Z, такой, что U Z – это суффикс S, и V Z – это суффикс S, но
давайте это нарисуем, вот было S наше, что значит,
что U Z – это суффикс S, значит, где-то вот здесь находится
U, а все, что правее до конца строки – это Z, ну а тогда
U Z – это как раз суффикс S, U Z – суффикс S, то есть,
поскольку у меня оба эти множества не пустые, потому
что U и V – это по строке S, то тогда обязательно есть
хотя бы одно вот такое Z, такое, что U Z – это суффикс
S.
Более того, поскольку эти множества одинаковые,
то V Z тоже суффикс S, V Z тоже суффикс S, значит, вот
оно Z, да, мы как бы с конца идем, вот оно Z, где-то здесь
находится V, ну и, соответственно, оно либо вот такое какое-то
содержащее U целиком, либо вот такое, наоборот, вложенное
в U, ну и тогда видно, что в любом случае одна строка
суффикс другой. Понятно? Значит, ну давай, напишем,
U и V имеют одинаковое окончание сождения в S, в том смысле,
что вот она позиция такая, что в ней заканчивается
вхождение U и вхождение V, да, у них одинаковое окончание
вот в этой вот позиции. Ну и дальше, если длина U меньше
длины V, то U – это суффикс V, иначе, наоборот, иначе V – это
суффикс U.
Дальше утверждение об устройстве класса эквивалентности.
Утверждение говорит нам о том, как может выглядеть
любой класс эквивалентности. Значит, пусть C класс эквивалентности,
когда существует некая строка U, такая, что C состоит
из U и нескольких ее самых длинных суффиксов. Я так
не очень хорошо напишу, но пусть будет так. И несколько
ее самых длинных суффиксов. То есть картинка будет такой,
есть некая строка U, самая длинная строка в нашем классе,
лежащая в этом классе. Затем мы откусили от нее первый
символ, получили суффикс длинный 1 поменьше, откусили
еще один символ, получили следующий подлиннее суффикс,
ну и так далее. Несколько таких вот суффиксов, самых
длинных. Это все один класс C. А скажем, следующее уже,
если мы еще один символ откусим, то это будет уже следующий
класс. Я вот так нарисую, уже другой класс. Любой класс
содержит некую самую длинную строчку в себе, и затем
если вы многократно будете отбрасывать первый символ
вот этой вот текущей строки, то вы таким образом заметете
все C. На какой-то момент уже будет другой класс, но
главное, что C это вот несколько отличающихся на один таких
вот строчек по длине. Так, доказается, ну пусть U
это самая длинная строка в C. Пусть U самая длинная
строка в C. Дальше, поскольку все слова в одном классе
имеют одинаковый правый контекст, по определению,
класс эквивалентности, это множество слов, у которых
одинаковый правый контекст, такое, что к ним больше
никого нельзя добавить в этот же класс. Значит, еще
раз, пусть U это самая длинная строка в C, тогда все остальные
слова из этого же класса гарантированно имеют тот
же правый контекст. Для любого, ну там V из C и rl от U равно
rl от V, потому что они в одном классе, в одном классе эквивалентности.
Ну, а раз у них одинаковый правый контекст, то по предыдущему
утверждению гарантировано V это суффиксу. Тогда по
предыдущему утверждению V это суффиксу. Причем именно
в таком порядке не U суффиксу, а именно V суффиксу, потому
что U самая длинная, значит, не может быть наоборот.
Значит, мы получили, что в одном классе находится
одна строка U и только ее суффиксы. Вот теперь вопрос,
почему это непрерывный отрезок в порядке убывания длин.
То есть мы поняли, что здесь могут быть какие-то суффиксы
и только суффиксы. Вопрос, почему это обязательно несколько
подряд идущих. Ну давайте возьмем какой-нибудь самый
короткий. Пусть V самая короткая
слова из C. Самая короткая строка в C. Тогда мы точно
знаем, что в C лежит вот эта вот U и некий ее суффикс
V. Достаточно доказать, что все суффиксы промежуточной
длины тоже лежат в C. Если мы докажем, что между вот
этими длиннокрайностями все промежуточные тоже
лежат в C, то получается, что C целиком образует некий
отрезок суффиксов. Все более короткие не лежат, все более
длинные не лежат, а вот целиком отрезок здесь находится.
Ну давайте для этого рассмотрим произвольную промежуточную
строчку здесь, какую-нибудь W и докажем, что она имеет
тот же класс эквивалентности. Пусть W это суффикс U, причем
вот так у нас соотносятся длины. Длина U больше длины
W больше длины V. То есть это вот суффикс промежуточной
длины. Ну тогда что? Тогда мы знаем. Тогда мы точно
знаем, смотрите. Давайте я напишу вот такое вот соотношение.
RL от W, нет, RL от U вложено в RL от W и оно в свою очередь
вложено в RL от V. Тут нужна картинка. Так, что у нас есть?
У нас есть, что V это суффикс W, а W это суффикс U. Ну давайте
нарисуем. Давайте нарисуем какое-нибудь вхождение U.
Здесь вхождение U. Мы точно понимаем, что коль скоро
у нас в строке нашлось вхождение U, вот в этой нашей большой
S было вхождение U, то здесь же заканчивается вхождение
и V и W. Потому что вот они, вот здесь W, а здесь V. Поэтому
автоматически мы знаем вот такое вот соотношение,
что RL от U вложено в RL от W. Ну просто любое вхождение
U автоматически порождает вхождение W, а значит все,
что вот здесь справа лежало, раз оно было в правом контексте
U, то оно также лежит в правом контексте W. Возможно здесь
даже было бы не строгое вложение, наоборот строгое вложение
в случае, если например есть некое вхождение W, не продолжающееся
влево до вхождения U. Такой гипотетический могло бы
быть, поэтому я здесь пишу просто вложение. То же самое
с этими двумя. Вот есть наша S. Мы знаем, что V это суффикс
W, потому что W больше длины и является суффиксом той
же строки U. Ну то же самое. Это значит, что любое вхождение
W автоматически генерирует вхождение W, поэтому у нас
есть такое соотношение на классы. Навсюду где есть
W есть здесь же W. Поэтому любая строка, вот здесь вот, дополняющая
справа до суффикса, если она лежит здесь, то она автоматически
лежит здесь. Значит есть вот такое вложение. Вот,
с другой стороны, мы знаем, что RL от U равно RL от V. Мы знаем,
что внутри этого класса у них у всех одинаковые правые
контексты. А раз у нас крайние элементы равны, то значит
здесь тоже везде равенство. Поэтому правый контекст
строки W такой же, как и у, и у В. Значит W обязательно
в том же классе лежит. Значит отсюда RL от W равно RL от U.
Равно RL от V. Значит W лежит в C. Что и требовалось. Нам
ровно это и хотелось показать, что все слова промежуточной
длины между U и V лежат в том же классе. Ну вот мы показали.
Вот, ну и тогда, например, с использованием теории
Махиллони Роуд, мы уже можем описать, как будет выглядеть
наш искомый минимальный суффиксный автомат. Да,
то есть суффиксный автомат до строки S. Значит мы понимаем,
что каждый класс это с срока и нескольких суффиксов,
а также мы понимаем, как по сути они все устроены.
Ну не совсем, сейчас скажу. Значит нужно понять, что
с переходами будет примерно следующее. Смотрите, что
такое вершина в суффиксном автомате? Это по сути некий
классик эволентности. То есть набор строк. Вот есть
некая вершина, отвечающая набору вот таких вот строк.
И есть другая вершина, отвечающая еще кому-то набору строк.
И между ними бывают переходы. Да, ну автомат, понятно,
там нужны какие-то ребра. Вот когда есть переход
из одного состояния в другой, из одной вершины в другое.
Ну раз есть такой переход, что это значит? Значит что,
ну вот, например, мы стали в стартовую вершинку, где-то
у нас был акустарт. Мы могли до вот этой вершинки дойти
несколькими способами. Там вот первый способ нас
приводил бы в такое слово, второй в такое, третий в
такое, четвертый в такое. И дальше каким бы образом
мы до этой вершинки не дошли, мы можем прочитать буковку
с и попасть в другую вершину. То есть независимо от того,
как именно мы попали из стартовой вершины вот сюда,
мы можем дописать с и попасть в одно из слов вот этого
класса эволюмности, новой вершинки. Но это в частности
означает, что по сути дописывание буковы с справа ко всем вот
этим словам дает мне слово какое-то вот отсюда. То есть
если я допишу вот сюда буковку с, ну давайте пусть это будет
у, это будет у с с на конце. Если это в, то это в с с на
конце. Вот, и тогда по сути автомат будет выглядеть
так. Значит автомат. Вершины – это классы эволюмности,
как мы уже поняли. Вершины – это классы эволюмности,
классы эволюмности. Ну а переходы, то есть вот эти
вот ребра, ребра с меточками, ребра с буквами, это все
такие возможные, ну давайте я так напишу. Что такое
ребро? Ребро – это пара вершин и метка. Так, как
будет написать? Давайте я так напишу. Все тройки, класс
1, класс 2 и символ, ну пусть будет, так ц маленько тупо,
пусть будет, ну пусть будет д, такие что в классе ц1 есть
слово у, такое что в классе ц2 есть слово уц. А то есть
мы грубо говоря рассматриваем все пары классов, уд, рассматриваем
все пары классов, смотрим есть ли в первом классе такое
слово, что после дописывания одной буквы мы попадаем
во второй класс. И если есть такой, если есть такая
пара слов, то здесь у, а здесь уд, то мы добавляем переход
между этими двумя классами по стрелочке с меткой д.
Заводим такое ребро с меткой д. Вот, ну и чуть позже мы
докажем, что на самом деле это будет корректный переход,
то есть любое слово, вот если мы возьмем любое слово
вот отсюда, а даже давайте сразу докажем. Я утверждаю,
что если есть хотя бы один такой переход, то здесь
было слово у, а здесь есть слово уд, то тогда на самом
деле любое слово отсюда с помощью буквы д продолжается
обязательно сюда. Так, ну значит почему это так?
То есть у нас вот, представьте, что у нас были два слова,
в одном классе ц1, вот здесь была у и в. Почему после
дописывания буквы д мы попадаем обязательно в один класс
эквивалентности? Значит у и в были в одном классе,
почему уд и ув, vd наоборот, лежат тоже в одном классе
ц2? Так, кто-то может ответить? То есть у нас были два слова
одного класса, мы дописали к ним произвольную буквку
справа к обеим словам, к обоим словам, почему мы
обязательно получим слова из одного класса ц2? Да-да-да-да,
давайте я это и запишу. Пусть z это слово из правого контекста
слово уд, тогда что я могу написать? У, д, z это суффикс
v, суффикс с, тогда д, z это слово из правого контекста
у, потому что вот оно у и все что написано справа
это добивка до суффикса. Отсюда следует, что поскольку
исходно они были в одном классе эквивалентности,
то д, z также лежит в правом контексте для слова v, поскольку
они были в одном классе эквивалентности, ну и значит z лежит в правом контексте
слово v, д, то есть мы взяли произвольное слово из правого
контекста слово уд, получили, что это же слово лежит
в правом контексте слова v, д, ну и наоборот можно
провести то же самое, что любое слово отсюда лежит
здесь, значит у них одинаковый класс. Вот, тем самым мы показали,
что такие переходы действительно корректны, если есть хотя
бы один такой возможный переход, то есть я взял слово
отсюда, написал д, получил слово отсюда, то на самом
деле это будет верно для любого слова, какое бы
слово отсюда не взял и дописал бы тот же самый символ
д, то я обязательно попаду в тот же самый класс c2. И тем
самым мы как раз описали все возможные переходы,
что мы были в одном классе, нам нужно было дописать
одну букву, чтобы попасть в другой класс, ну вот они
все сразу все слова из этого класса целиком наследуются
в другой класс, предописывая одну букву. Так, и последнее,
что нам нужно, это еще понять, что такое терминальные
вершины, терминальные вершины, ну и начальные. Так, терминальные
вершины. Скажите, пожалуйста, как определить вот в этом
автомате, какие вершины будут терминальными? Еще раз?
Да, в программном контексте есть эпсилон. Я бы так сформулировал.
Терминальная, ну не так. Давайте так и напишем. В
программном контексте, в программном контексте есть
эпсилон. Терминальная это вершина, содержащая суффикс,
то есть мы как бы встали в стартовую вершину, как то
прошли, дошли до терминальной. И терминальные у нас должны
быть ровно те, которые отвечают суффиксом. То есть мы встали
в начало, что-то прочитали, закончились, прочитав
суффикс. Суффикс это те, у кого в программном контексте
лежит эпсилон. И более того, наоборот, если в программном
контексте есть эпсилон, то это обязательно вершина,
отвечающая только суффиксом, потому что только у суффикса
в правом контексте может быть пустая строка, пустая
строка.
Ну, значит, сущности содержания Эпсилона – это, короче,
те, кто содержит Эпсилон – это суффиксы, вот мы их
все помещаем.
Так, да?
Ну, конечно, да, конечно, например, если у вас есть
вот такая как-нибудь строка АВАВ, то у вас правый контекст
суффикса АВ – это Эпсилон и АВ, это нормально.
Ну, и начальная вершина, понятно, что это класс, отвечающий
пустой строке, какой правый контекст у этой начальной
вершины?
Да, все подстроки, начальная вершина, правый контекст
релет, кустарт, я напишу вот так, правый контекст
стартовой вершины – это все подстроки С, все подстроки.
А потому что начало – это как-нибудь пустая строка,
сколькими способами?
Нет, не так, все суффиксы, да, наверное, скорее, да,
все суффиксы.
У нас же правый контекст – это добивка до конца строки,
поэтому здесь будут все суффиксы.
Ну и только у этой вершины, у пустого слова в правом
контексте будут все суффиксы, потому что во всех суффиксах,
в частности, есть все слово С, на вся строка, значит,
в начале может быть только Эпсилон – пустая строка.
Ну вроде мы весь темат так описали, и как бы в принципе,
если нам нужно хоть за какую-то асимптотику построить
его, то вот он алгоритм.
Да, мы просто сначала бьем все подстроки по классам,
считая правые контексты, потом вот так проводим ребра,
находим терминальные вершины и стартово.
Вот, ну конечно, мы научимся это делать более эффективно.
Хороший вопрос, нет, он не полный будет, там не будет
не подстрок.
Давайте какой-нибудь пример нарисуем, выдавайте
тоже АБАБ, нарисуем его, АБАБ, так, ладно, значит,
какой правый контекст у строки АБАБ, значит только
Эпсилон, у БАБ тоже только Эпсилон, у АБАБ уже другой,
то есть это будет один класс, у АБ и Б еще свой класс,
у Эпсилон еще свой класс, то есть это были все, заканчиваемся
тут, перезаканчиваемся здесь, у АБА правый контекст
только Б, у БА тоже правый контекст только Б, у А уже
другой контекст, так, АБ уже было, Б уже было, А уже
было.
Так, вроде я все разбил, сейчас я нарисовал разбиение
всех подстрок слова АБАБ на классы эквивалентности,
проверяйте, что оно правильное, пожалуйста.
Ну, вроде да, вроде такое разбиение, это будет
стартовое состояние.
Ну и переходы какие, здесь будет переход по А, здесь
будет переход по Б, дальше, дальше, дальше, здесь будет
переход по Б, АБ, А, и здесь будет Б.
Вот такой автомат, значит, вот это будут суффиксные,
точнее, терминальные вершины, потому что в них есть суффиксы,
и только в них.
Вот, ну, короче, как видим, здесь нет неподстрок, да,
то есть все, что мы можем прочитать в этом автомате,
это только подстроки исходной строки.
Если мы стартуем в стартовой вершине и как-то здесь ходим,
то можем прочитать только подстроки исходной строки.
Ну, собственно, мы его так и строим, да, мы там в какой-то
момент сказали, что рассматриваем только подстроки.
И здесь число вершин, оно равно, конечно, числу класса
эквивалентности относительно нашего отношения, кроме
вот этого вот, когда RL это пустое множество, да, вот
этого как бы не включается в автомат, не включается
в автомат.
Отвечая на ваш вопрос, если бы хотели сделать полный
суффиксный автомат, то есть тот, у которого есть
из каждой вершины стрелки по всем возможным буквам,
то нам нужно было бы еще завести фиктивное состояние,
отвечающее не под словом, ну, не под строком, не под
строки.
И проводить вот такие вот ребра, значит, отсюда
по A мы переходим в неподстроки, отсюда по B мы переходим
в неподстроки, отсюда по A и отсюда по A и по B.
И здесь еще есть петли A и B.
Вот.
Но поскольку мы договорились, что нам не нужна явным образом
эта вершина, да, то есть если бы мы ввели дополнительно
такую вершинку и провели бы в нее все недостающие
ребра по всем недостающим буквам и еще бы зациклили
на нее бы петли повесили, то мы бы как бы могли читать
любое слово над нашим алфавитом, но, возможно, иногда бы
заканчивались вот этой вот вершине, которая отвечает
не под строчкой.
Значит, от этого у нас увеличивается число вершин на 1, но зато
мы можем читать любую строчку, заканчивая в кодте вершинки
гарантированно.
Вот.
Нам, в принципе, это не нужно, поэтому у нас число вершин
будет равно, ну, числу классифика лентности за вычетом вот
этого одного, за вычетом того, который не отвечает
под строчком.
Число вершин – это число классов эквивалентности
минус 1.
Классов эквивалентности минус 1, так как не включаем
непростройки.
Вот.
И он от этого в частности становится неполным, да,
потому что мы, по сути, все ребра, ведущие в вершину
отвечающую не под строчкой, мы их просто все удалили
вместе с этой вершиной и оставили только то, что
отвечает под строком.
Ну, тем самым мы уменьшим наш смат на одну вершинку,
но основная суть его сохранилась.
Все, что здесь, это какая-то фигня, которая ничему не
отвечает.
Мы ее просто игнорируем, считаем, что если мы попасть
туда, то же самое, что попытаться прочитать незаконный символ,
который не ведет ни в какую вершину.
Так, ладно, тогда давайте дальше изучать суффиксный
автомат на пути к тому, чтобы построить его за
линейное время.
Значит, обозначение, обозначение, пусть x это какое-то слово
через x в квадратных скобках просто или, скажем, x в квадратных
скобках с индексом s, мы будем обозначать класс эквивалентности
слова x относительно вот того самого нашего языка,
определяемого словом s.
Ну, как обычно, вроде стандартное обозначение квадратные
скобки – это множество всех слов, которые лежат
в том же классе эквивалентности, что и x.
То есть, можно так написать, что это множество всех
y таких, что x с y находится в отношении l, в отношении
эквивалентности тильда.
Значит, дальше, если c это некий класс эквивалентности,
то через лонгест от c я буду просто обозначать самое
длинное слово в этом классе.
Ну, а как знаем, любой класс устроен вот так.
Это некое самое длинное слово в этом классе и несколько
его самых длинных суффиксов.
То есть, лонгест – это просто вот то самое слово, от которого
мы берем суффиксы многократно.
И еще нам будет нужна суффиксная… Сейчас, давайте длину
сначала еще.
LEN определим.
LEN от c – это просто длина лонгест, число символов
в нем длиной класса, мы будем обозначать длину самого
длинного слова в нем.
И последнее, мне нужна суффиксная ссылка.
Класса c – это будет ссылка на тот класс, который содержит
самый длинный суффикс этой строки, которая лежит
в другом классе.
То есть, мы знаем, что самая длинная строка и несколько
ее самых длинных суффиксов лежат в одном классе, а
вот если мы возьмем следующий по длине, то есть, как бы
еще один символ откусим, возьмем следующий суффикс,
то это будет уже другой класс.
И вот этот класс будет ссылкой для c.
Ну, давайте я напишу так, у равно лонгест, пусть у
– это лонгест от c, а у штрих – это самый длинный суффикс,
самый длинный суффикс у, лежащий в другом классе,
c-штрих, тогда линк от c – это c-штрих, суффиксная ссылка
от одного класса – это другой класс, содержащий самое
длинное слово, являющегося суффиксом исходной строки
вот этой вот лонгеста c, которая при этом все равно
другой класс.
Утверждение критерии лонгеста.
Пусть у – это строка, тогда у является самым длинным
словом в своем классе, то есть, она равна лонгесту
от своего класса, если только если выполнено одно из двух,
либо у – это префикс s, либо существует два различных
символа a и b, такие что ау и бу – это подслова s, под
строки s, значит, слово является самым длинным в своем классе,
если только если оно либо префикс s, либо его можно
двумя разными способами продлить налево до подстроки
s, то есть, есть два разных символа, которые слева
можно писать, все равно получим подстрок s.
Так, ну первое, пусть у – это не лонгест, пусть у не
равно лонгест от своего класса, если оно не лонгест
в своем классе, значит, класс устроен как-то так,
есть некое самое длинное слово отличное от у, потом
вот его суффиксы, в какой-то момент здесь будет написано
у, ну что это значит, значит, например, вот если я рассмотрю
строчку длины на один побольше, какое-то там du, то раз они
лежат в одном классе, то у них одинаковые правые
контексты, у них одинаковое множество вхождений, и
по сути это означает, что любое вхождение у гарантированно
слева предваряется буквкой d, а значит, неверно, нет
и нет.
Начну давайте формально напишу, пусть у не лонге
в своем классе, тогда существует d, такое, что du и u находятся
в одном классе эквивалентности относительно нашего отношения,
а просто мы берем вот этот вот символ, ну берем строчку
длины на один побольше в том же классе эквивалентности,
ну и поскольку у них в одном классе, то они обязательно
находятся в отношении эквивалентности, значит, любое вхождение
u в s предваряется символом d, предваряется символом
d, ну потому что, что такое находиться в отношении
эквивалентности?
Значит, у них одинаковые правые контексты, то есть
по сути это, у них совпадают множество вхождений, потому
что любое вхождение u в s, это вот, по сути, вот эта
вот точка такая, что с правой от нее написано вот какое-то
окончание du суффикса, да, вот эти вот z, они по сути
нам определяют множество вхождений, множество завершений
вхождений, и если у этих двух слов одинаковые множество
вхождений, то получается, что вот всюду, где есть u,
есть также слева символ d, у них одинаковые множество
вхождения, потому что одинаковые правые контексты, а значит
неверно не это, не это, потому что всегда слева от u написано
d, значит u не может быть префиксом, потому что слева кто-то есть,
а слева от префикса никого нет, ну и при этом двумя
различными способами продлиться влево нельзя, потому что
всегда только d, еще раз, а что значит другая строчка
u, вот еще раз, u это какая-то конкретно, u это какая-то
фиксированная строка, да, вот мы ее зафиксировали
и говорим, что она является лонгестом в своем классе,
если только, если что-то, вот, значит мы доказали,
что если она не лонгест, то одновременно не это
и не это, то есть это импликация, видимо, справа налево, ну
там, взяли контрапозицию, это получилась импликация
справа налево, теперь слева направо, да, нет-нет, а это,
sorry, тут я не написал, это символ алфавита, это буквы,
да, спасибо, именно символы единичные, не строки, так,
в обратную сторону, пусть u это лонгест в своем классе,
лонгест в своем классе, ну и пусть, давайте для определенности
u это не префикс s, тогда нам нужно доказать, что есть
как минимум две различные буквы, такие, что ими можно
предварить нашу строчку u и они обе будут под сроками
s, ну давайте опять нарисуем этот класс эквивалентности,
отвечающий u, здесь u будет самый длинный и вот есть
ее несколько суффиксов, давайте нарисуем вхождение
u в s, например, как-нибудь вот так я нарисую несколько
вхождений, ни одно из этих вхождений не является
префиксом s, да, то есть вот здесь никто не начинается,
поэтому я могу посмотреть на символы, предшествующие
всем этим вхождением, мне нужно доказать, что среди
них не все одинаковые, мне нужно доказать, что среди
вот этих символов, предшествующих всем вхождением u, есть хотя
бы два разные, тогда мы как раз докажем, что есть два
разных символа, такие, что влево можно продолжить
наше слово u, но если они все одинаковые, то на самом
деле это слово должно было быть в том же классе, давайте
здесь напишу, да, рассмотрим, рассмотрим символы, предшествующие
всем вхождением u, всем вхождением u, если они все одинаковые
вдруг, если они все одинаковые, то картинка такая, в тюду
перед u располагается один и тот же самый символ, скажем
c, вот здесь c, здесь c и здесь c, ну тогда понятно, что u
и cu имеют один и тот же правый контекст, потому что у них
одинаково множество вхождений, то u находится в отношении
эквивалентности со словом cu, потому что у них одинаково
множество вхождений, противоречие с тем, что u это длинное, самое
длинное в всем классе, значит они не могли быть все одинаковые
и среди вот этих вот символов хотя бы два различные, скажем
есть какой-то c, есть какой-то d, победа, значит вот это вот
верно. Вопросы? Так, хорошо, значит и вот это вот
полезный критерий longest, он будет у нас на самом деле
база нашего алгоритма, давайте мы его немножко начнем ждать,
алгоритм построения. Значит он будет немножечко, немножечко
самая малость напоминать алгоритм построения сувдерева,
а именно тем, что во-первых он будет такой же ингриментальный,
то есть по одному символу дополнять нашу строчку,
как бы читать по одному символу строки s и перестраивать
автомат. То есть если у нас была строка s и для нее построен
суффиксный автомат, то мы читаем новый символ, перестраиваем
автомат, дописав справа, докинув справа в конец новый
символ c, также как в суффиксном деле мы читаем по одному
символу и перестраиваем нашу структуру на ходу.
Назваемый ингриментальный подход. То есть не то, что мы
прочитали один раз строчку, если сразу все построили, а скорее
так по одному символу перестраиваем. Ну и второе сходство, что ли, в том,
что мы тоже пока не следим за терминальностью. Если вы помните,
как работает алгоритм Уканина, он сначала все делает, сначала все
строит, проводит все ребра, все вершинки строит и только в самом
конце помечает терминальными вершины, которые, получается,
со всылками от самого длинного слова. Сначала все построил, потом
прошелся по мете вершины терминальными. Также и здесь, до самого конца алгоритма,
до самого конца алгоритма, не заботимся о терминальности,
потому что в конце, если мы правильно построим все вершины, все переходы, то
по мете терминальность будет очень просто. Нужно будет всего лишь найти класс
эквивалентности строки S. Это будет обязательно некая вершина,
отвечающая, она будет обязательно терминальной, потому что в ней содержится суффикс.
Ну а дальше мы знаем, что такое класс эквивалентности этой вершинки. Это S и
несколько ее самых длинных суффиксов, то есть все они тоже будут терминальными,
все хорошо. Дальше следующий суффикс, не попадающий в тот же класс
эквивалентности, достигается по линке, по сувсылке. То есть все вот эти мы уже
отметили терминальными, потому что они в одной вершине лежат, а следующее мы
должны взять сувсылку у этой вершинки и пометить терминальными их, потому что
они лежат в следующем классе, но это как бы следующих суффиксов. Дальше мы их
пометим, то есть мы прыгнули по сувсылке, пометили терминальными, потом опять у нас
есть следующий суффикс, лежащий в другом классе, он достигается просто по
сувсылке. Мы помечаем эту вершину терминальной и так далее.
То есть ровно так же, как в сувдереве, мы сначала все построили, потом встали в
самую длинную точку, в самую длинную вершину, отвечающую всей строке, и просто
по сувсылкам прыгаем, помечаем все терминальные. Вот, на этом сходство
заканчивается.
Теперь мы будем рассуждать в терминах лонгестов, потому что, смотрите, вот что
происходит, когда дописывается символ С. У нас как-то по сути меняются все классы
эквивалентности. Вот у нас поменялась строка, у нас, соответственно, поменялось даже
отношение эквивалентности. Если раньше нам нужны были суффиксы С, то теперь это
суффиксы СС. У нас все поменялось. И по сути, наша весь автомат должен как-то
перестроиться, с учетом того, что классы как-то изменились. Но, смотрите, у нас есть
удобное на самом деле представление классов через лонгесты, потому что если
нам известны только лонгесты от всех классов, то мы на самом деле все классы
тоже можем легко восстановить. Классы эквивалентности, они легко восстанавливаются
через все лонгесты. То есть, например, если вместо разбиения на классы нам
известны только лонгесты, то мы на самом деле все классы тоже можем восстановить.
Потому что вот мы берем некие, скажем, два лонгеста, и если мы видим, что один
это суффикс другого, и между ними никого нет, то значит все, что между ними, это
один класс, но все, что ниже, опять до следующего лонгеста, лежащего в другом
классе, это другой класс. То есть, по сути, чтобы восстановить разбиение на
классы, нам нужны только лонгесты. Потому что я рассматриваю все пары
лонгестов таких, что один это суффикс другого, они, соответственно, лежат в разных
классах, и все, что между ними, это один класс. Поэтому вместо того, чтобы
заботиться о том, как именно устроены классы эквивалентности, мы будем следить
за строчками, которые являются лонгестами. И все вот эти вот лонгесты, благо, у нас
есть как раз критерии лонгеста, чтобы понимать, что с ними происходит. А, если уж
мы знаем лонгесты, то все классы мы тоже восстановим. Потому что, как бы, ну,
предельные элементы в своих классах, зная предельные элементы, мы восстановим все
все классы сами себе. Еще раз? Ну, смотрите, так, v это суффикс u, то есть, вот все вот
эти прямоугольники, это лонгесты, и v это суффикс u, такой, что между ними нет
других лонгестов. То есть, грубо говоря, я рассматриваю все пары лонгестов, если
один это суффикс другого, и больше никто не является суффиксом этого, более
длинным, тогда все, что между ними, это один класс.
Ну да, да, да, да. То есть, мы взяли какую-то произвольную, произвольную строчку u,
являющуюся лонгестом, осмотрели все суффиксы, упорядочили по длине, и вот у
нас получилось такое разъединение на классы. Да, можно так сказать. Значит,
мораль. Вместо того, чтобы следить за классом, будем следить за лонгестами.
Вот вопрос, что происходит с лонгестами, что происходит с лонгестами при
переходе вот s к sc. Вот s к sc. А у нас есть критерии лонгеста. Что лонгесты это
либо префиксы, либо расширяющиеся влево разными способами, как минимум двумя
способами. Первое важное замечание, что если строка когда-то была лонгестом, то
она лонгестом останется. Потому что, если она была префиксом s, то она остается
префиксом sc. Если она предварялась влево двумя разными буквами a и b в строке
s, то в строке sc происходит то же самое. Все, что слева, оно не меняется. Поэтому
первое важное замечание, что если у была лонгестом, если у была лонгестом в s, то она остается
лонгестом в sc. Остается лонгестом в sc по критериям. Потому что в обоих случаях,
будь у префиксом s или имея оно два разных продолжения влево, дописывание c в
конец строки s ничего не меняет. То есть все, что раньше было лонгестами, остается. То есть
единственное, что может происходить, это только появляться некие новые лонгесты. Никто пропадает,
никто переставать быть лонгестом не может. Могут только появляться новые. Так, критерии я оставлю.
Могут только появляться новые лонгесты. Вопрос, какой лонгест гарантированно появится новый?
Еще раз? Да, sc. Гарантированно, sc это новый лонгест. Просто потому, что раньше это не было строкой в
s, это не было под строкой s. А теперь оно становится под строкой всей большой строки sc. И оно, конечно,
лонгест, просто потому, что нет вообще никакой строки длиннее, чем это. Давайте прописывать не
буду еще раз, почему это точно новый лонгест. Раньше это не было лонгестом, потому что это даже
под строкой не было. Ее раньше вообще в автомате нельзя было прочитать, потому что она длиннее,
чем s. С другой стороны, теперь это лонгест, потому что она теперь самая длинная. Теперь длиннее
нее никого нет. Есть какой-то у него класс, она там точно самая длинная. Ну давайте попробуем понять,
чему равен… ну давайте я вот так вот буду писать. Нет, не так, не так, не так. Да. Значит,
правый контекст относительно слова sc у слова sc равен epsilon. Потому что если у нас есть слово
sc, то единственный способ дополнить его до суффикса sc это написать пустую строчку, ничего не написать.
Вот. Соответственно, в классе sc относительно вот этой нашей новой строки sc, то есть относительно
нового отношения эквивалентности. У нас лежат все такие строки, единственное дополнение которых до
конца это epsilon. То есть это гарантировано точно суффикс sc, суффикс sc, которые раньше не имели
вхождения в s, не имели вхождений в s, которые не имеют вхождений в s. Ну почему-то суффикс sc
понятно, потому что у них в правом контексте есть epsilon. Почему они не имели вхождений в s? Ну
потому что если бы они где-то входили в s, давайте нарисую, было s, стало sc, если бы они где-то здесь
входили, то у них бы в правом контексте было бы еще вот это, какая-то не пустая строка, а мы рассматриваем
только класс этой строки, то есть только те слова, у которых правый контекст состоит только из
epsilon. Значит ничего, никаких больше вхождений было не могло. Ну и наоборот, если слово удовлетворяет вот
этим вот обоим условиям, то есть у нас с одной стороны суффикс sc с другой стороны раньше не входило,
то есть это слово обязательно вот такого вот вида, да, и больше нигде его раньше не было, то
гарантированно правый контекст этой строки только epsilon, потому что если бы там было что-то еще,
то гарантированно должно было быть вхождение левее, а его нет. Вот, то есть мы точно поняли,
что появляется новый лонгест, и мы знаем, как выглядит, то есть мы характеризовали его класс.
Это все суффиксы sc, которых раньше не было, то есть это как бы новые подстроки, те кого раньше
не было. Это вот все sc и несколько опять-таки самых длинных суффиксов, такие, что вот все они не
имели вхождение в s, а вот уже предыдущие, скажем, имеют вхождение.
Теперь вопрос, мог ли стать лонгестом кто-то еще? Кто еще мог стать лонгестом?
Ну пусть некая t, пусть t. Значит, давайте смотреть на критерий, критерий лонгеста. То есть у нас раньше
была некая строка t, она уже не могла быть не под строкой s, то есть она обязательно была под строкой
s, потому что все не под строки, мы уже вот здесь вот расположили, все не под строки s уже лежат в
этом классе коверенности, а все не под строки, они имеют пустой, ну как бы только, эпсилон в правом
контексте. Значит, t раньше была под строкой, но при этом не было лонгестом, то есть t это какая-то
подстрока, не являвшаяся раньше лонгестом, но ставшая теперь лонгестом. А раз она раньше не являлась
лонгестом, то она не префикс s и не имела двух продолжений влево, а теперь как бы либо стала
префиксом sc, либо имеет два продолжения влево в строке sc. Давайте это запишем. Пусть это t,
t имела вхождение в s, так как все не имевшие вхождений лежат в классе sc, в отвечающем
все строке. Значит, t не была лонгестом в s, но стала лонгестом в sc. Еще раз.
Почему все слова не имевшие вхождение в s теперь находятся в этом классе? Так,
комментарий не помню, давайте я на вопрос отвечу. Еще раз, почему вот это верно, почему все не
имевшие вхождение в s лежат в классе, отвечающем sc? Что такое слово не имевшее вхождение в s,
но теперь рассматриваемое, то есть это раньше было не под строка, теперь под строка. Ну,
потому что не под строки sc мы не рассматриваем, они как бы нам не интересно, отвечают отдельному
состоянию, который мы не строим. То есть была строка не имевшая вхождение в s, но теперь получившая
вхождение в sc, значит обязательно суффикс, потому что новое вхождение только суффикс sc, больше
никаких вхождений не появилось. Итого у нас была строка не входившая сюда, но теперь получившая
вхождение в sc. То есть обязательно какой-то суффикс, что-то такое. Но все суффиксы sc не
имевшие вхождение в s, вот оно мы знаем, мы уже это обсуждали, что это в точности класс эквивалентности
строки sc. Нет, в обе, в обе, в обе. То есть еще раз, да, ну давайте здесь проговорю. Вот я рассматриваю sc,
я понимаю, что у нее правый контекст, это только эпсилон. С одной стороны, строки лежащие здесь,
строки лежащие здесь, это обязательно суффикс sc, потому что у них есть правый контекст эпсилон.
С другой стороны, раньше не входили, потому что если бы не входили, у них бы кто-то был еще,
да, то есть если бы было здесь, то можно было бы дополнить чем-то еще. Теперь наоборот, пусть строка
вот такая, почему она лежит в этом классе, то есть почему у нее такой правый контекст. Но если она
суффикс sc, то у нее точно есть эпсилон в правом контексте, а если она не имела вхождение в s,
то ничто другое не могло быть в правом контексте. То есть это критерия, могу здесь равенство написать.
Вот, значит t не было лонгестом в s, но теперь стало в sc. Ну что это значит? Это значит, что раньше,
ну конечно, что оно как бы в частности не было префиксом, поэтому этот случай исключается.
Значит, раньше любое вхождение t в s предваряется одним и тем же символом,
любое вхождение t в s предваряется одним и тем же символом, скажем, x. Предваряется одним и тем
же символом x. Сюда, где sc, слева написано x. А дальше, я дописываю c в конец, и внезапно t пересовывает
лонгестом, то есть внезапно появляется как минимум два разных символа, которые предваряют t в
нашей строке sc. Ну тогда гарантированно t получил новое вхождение вот здесь вот. Такое,
что тут не x. Потому что раньше все вхождения обязательно предварялись x, а теперь это не так,
то есть появился какой-то еще символ. Но единственное новое вхождение, которое t могло
получить, вот оно, это суффикс. Все новые вхождения только суффиксы. Только вот эти строки получили
новое вхождение. Значит, обязательно t это суффикс sc, перед которым написан не x. Вот оно t,
и здесь написан некий y отличный от x. Чтобы ему стать лонгестом, обязательно появилось новое
вхождение, предваряемое другим символом. Так, значит, давайте это запишем. В sc появляется
появляется новое вхождение строки t, предваряемое другим символом, другим символом y не равно x.
Просто чтобы выполнился критерий лонгеста. Значит, смотрите, мы поняли, что если у нас есть еще
какой-то новый лонгест, отличный от sc, если кто-то еще стал лонгестом, вот если это t стал тоже
лонгестом, то для него верно следующее. Это суффикс строки sc, потому что только суффиксы получили
новое вхождение. Это суффикс строки sc такой, что если его на один символ расширить, то это же
будет не под строка s. Итак, t это, на чему можно характеризовать так, самый длинный
суффикс sc, являющийся, являющийся под строкой s.
Потому что если я возьму суффикс длины на один побольше, то получу уже yt, а yt раньше нигде не
входил, потому что всегда было только xt. Тем самым мы получили следующее, что если хотя бы еще
один лонгест появился, то есть если t это еще какой-то новый лонгест, то он обязательно
ретрируется ровно вот так. Это самый длинный суффикс строки sc, который также входил в s. Такая строка,
которая получила новое вхождение, но и раньше тоже имела вхождение, потому что более длинные
суффиксы, все более длинные, содержат в конце yt, а yt раньше никуда не входил. Тем самым мы показали,
что если новый лонгест есть, максимум один. Вот он, потому что такая строка, она единственна.
На самый длинный суффикс sc являешься по строкой s, но это просто какая-то конкретная строка,
потому что все суффиксы sc, начиная с максимальной длины, вот эти вот все суффиксы, лежащие в этом
классе, они не имели вхождения в s, а потом следующие как бы в другом классе, меньше длины,
длины на один поменьше, уже по-прежнему являются суффиксом sc, но имеют хотя бы одно вхождение в s.
И вот это вот самая t, единственный кандидат на новый лонгест. Из всего, что мы здесь делали,
мы поняли, что лонгест обязательно обладает таким свойством.
Нет-нет, классов не обязательно n-1. Ну вот, если вы рисовали картинку,
когда там для ab-ab рисовал, там было пять классов, кажется. Да, а n-то кто еще у нас? Я думал,
это n-то длина, я думал. Число класса эквивалентности с длиной мы пока не можем соотнести.
Еще раз.
Да-да-да, сейчас понял. Почему не мог кто-то более короткий стать?
Так, момент.
Вот.
u- undo.
ну еще раз смотрите почему то есть окей вот мы рассмотрим пусть это какой-то
новый лонгест почему он обязательно вот такой ну это ответить на вас на ваш
вопрос то есть мы уже поняли что он точно суффикс сс вот я его нарисовал
суффикс сс являешься по строкой с это мы все доказали почему самый длинный
почему он самый длинный ну потому что мне нужно чтобы перед ним вот был именно
этот y отрисован всех предыдущих х слов а как бы а меньше они ну они вот имеют
здесь как бы те же вхождения и у них ну собственно то что написано здесь оно
оно такое же грубо говоря еще раз
да да сейчас сейчас сейчас сейчас сейчас
смотрите все что все что было другое да то есть мы более короткий рассмотрим и вот
здесь скажем еще то но оно оно и так оно либо раньше было лонгестом либо не станет
лонгестом и теперь потому что если вот эти символы различные то оно и так было
лонгестом а если все эти символы одинаково этот другой то извините почему тогда это суффикс
вот этого потому что любое да то есть эти все одинаковые а это какой-то другой но такого
быть не может потому что вот это окончание вот этого также как вот здесь вот то есть он
обязательно именно самый длинный так хорошо да ну давайте тогда видим и последнее утверждение
попробуем доказать быстренько утверждение об устройстве ребер ведущих вершину в
утверждение такое я его на картиночке сформулирую пусть есть некая вот пусть есть у нас суффикс на
автомат для какой-то строки есть некая вершина в нем давайте рассмотрим все входящие ребра в эту
вершину все входящие ребра я утверждаю что во-первых на них на всех написано одна и та же буква
во-вторых если я упорядочу их в порядке убывания лен да то есть параке убывание длины лонгеста то
они друг на друга ссылаются по суффсылкам то есть иными словами если выфиксировано то множество
вершин имеющих ребров эту вершину во-первых на этих ребрах написано одинаковая буква во-вторых
эти вершины образуют как бы часть суффиксного пути часть пути по суффсылкам какая-то самая
длинная потом линк покороче линк покороче и так далее доказательства но давайте нарисуем класс
эквивалентности для вы поскольку это самая длинная строка и все ее суффиксы то они конечно
заканчивается на одну и ту же букву как пусть какой-то ц здесь не может пустой строки потому
что пустая строка это только корень но отдельная вершина соответственно и в нее не может вести
никаких ребер поэтому это все не пустые слова у них у всех одинаковый последний символ ну а дальше
раз мы знаем что вот это вот буква это по сути просто приписывание ко всем словам отсюда некоторые
одной буковки в конец то получается что только вот вот на этом последнем месте она может быть
да значит все ребра ведущие сюда обязательно имеют ту же самую последнюю ну как бы на них
написано та же самая последняя буква ц вот дальше почему это путь по суффсылкам потому что
каждая вершина это некий отрезок слов ну отрезок длин слов вот мы к ним ко всем взяли приписали
ц в конец то есть скажем вот это вот после приписывания ц переходят вот сюда например вот
эти вот три слова это вот они после приписывания ц дальше здесь там были несколько слов более
длинные опять я к ним ко всем приписал ц и попал в этот класс то есть опять здесь я заметаю некий
отрезок заметаю некий отрезок слов в этом в этом в этом классе ну и соответственно поскольку я знаю
что каждая вершина это некий отрезок длин то здесь тоже заметается отрезок длин после
дописывания одной буквы и если я рассмотрел здесь все ребра то получается я покрыл обязательно
слова по одному разу и тем самым у меня весь вот этот класс большой отвечающий вешенки в
он разбился на несколько групп но я вот так нарисую как-нибудь он разбивается на несколько
групп так что скажем последняя группа отвечает всем вот этим словам после дописывания ц дальше
следующая группа отвечает всем словам после даже этого ц ну это отвечает вот это так
Ну и все, собственно, давайте рассмотрим самое длинное,
вот этот самый блок, отвечающий самым длинным словом, это
некое самое длинное слово, несколько его самых длинных
суффиксов.
Если я отбрасывать них в C, то я получаю вот этот,
скажем, первый класс.
Потом я отбросил еще один первый символ, пришел
к другому классу, к другой группе, которая отвечает
в следующей вершинке.
Соответственно, вот отбрасывание первого символа здесь переводит
меня в эту группу, внутри вершинки В, и в другую вершину
на этом пути.
То есть я понимаю, что отбрасывание первого символа здесь – это
с одной стороны перевод в другую группу в вершинке
В, с другой стороны, в терминах вот этих вершинок, которые
имеют входящее ребро, это просто переход по суффссылке,
потому что я отбросил одну вершину, одно слово, извините,
одну букву, перешел в новый класс, в новую вершинку.
Ну значит, то, что отвечала та вершина, которая отвечает
вот этому первому блоку, будет ссылаться по суффссылке
на вершину, отвечающую второму блоку.
То же самое здесь, отбрасываю первый символ, попадаю в
третью, вот здесь отбрось, вал в третью группу, значит,
здесь идет такая суффссылка.
Вроде все, спасибо.
