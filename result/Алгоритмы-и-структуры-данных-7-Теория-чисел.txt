Кажется, на сегодня седьмая встреча, поправьтесь, или
не так.
Мы продолжаем говорить про теорию чисел, в моем
понимании.
Сначала я выпишу несколько формул, которые нам сегодня
понадобятся.
Терема первая.
Пусть классическое обозначение.
Pioten – это количество простых чисел среди первых анатуральных.
Когда нам известен порядок роста этого числа.
Это n делить на log n плюс, ну вот это вот второе нам
будет не нужно в статочном члене, но я напишу для общего
сведения, так сказать, n на log квадрат.
То есть количество простых чисел на отрезке от 1 до n
ведет себя, по сути, как n делить на log, натуральный
логарифм n, плюс еще какая-то поправка, которая в логарифм
раз меньше, чем вот это.
Ну наверняка у вас это было, по крайней мере, упомышечную
часть на каком-нибудь дискране или у КТЧ, что там какой-нибудь
тетто можно написать вот здесь вот вместо точного
равенства.
Но оказывается, даже верно такое соотношение.
Следующий факт.
Если мы рассматриваем все простые, опять-таки, не
больше, чем n, и сложим их обратно, то получим повторный
логарифм n, плюс некоторая константа, плюс, о большое,
то есть 1,9 логарифма n, где m это примерно 261 тысячное.
Вот такая информация, что если мы сложим обратные
простые на отрезке от 1 до n, обратные к простым на
отрезке от 1 до n, то у нас будет повторный логарифм
плюс, в пределе можно считать, что вот это повторный логарифм
плюс константа, плюс вот эта вот функция, которая
можно было бы написать здесь о малость единицы вместо
о большое от одной логарифмовой, можно написать просто о
малость единицы, если не вдаваться в детали.
Но что значит вообще эта запись?
Это значит, что существует такая функция f, которая
равна о большое от одной логарифмовой, то есть модуль
f не больше, чем, скажем, c делит на логарифм n, такая
функция f, что вот это вот выполняется равенство.
Сумма обратных простых – это повторный логарифм
плюс константа, плюс функция f от n.
Понятно?
Ну и третий факт, тоже я его спишу с бумажки, потому
что всякие константы есть, вот эти вот достаточно
члены, я их не запоминал.
Если мы просто посмотрим на обратный ко всем натуральным
гаммам от 1 до n, не обязательно простой, а просто все натуральные
от 1 до n, тогда это будет просто логарифм, не повторный
обычный логарифм, плюс опять какая-то константа, в этот
раз гамма, плюс от одной n, где гамма – это примерно
0,577.
Это константа Эйлера или… Да-да-да-да, Эйлера еще
я не помню.
Вот этот ряд называется гармоническим.
Сумма просто обратных к натуральным – одна первая,
одна вторая, одна третья и так далее, и все складываем
вплоть до одной n.
Получается натуральный логарифм плюс константа,
плюс от одной n.
Вот такие интересные факты.
Это все как-то доказывается, там есть всякие способы
это делать, но это скорее к курсу по непосредственной
теории чисел, там один из способов – это считать
какие-то интегралы, их оценивать аккуратно и так далее,
применять какие-то интегралины теремо-средним, это не то,
чем мы будем заниматься, поэтому я их просто привожу
без доказательств.
Так, мы будем этим пользоваться, например, в нашем первом
сегодняшнем алгоритме, в Риштере Тосфена.
Задача очень простая.
Найдите все простые от нода n.
Найдите все простые среди чисел 1, 2 и так далее n.
Первое, что здесь нужно сказать, это что у нас есть
довольно простой алгоритм, который проверяет простоту
данного числа.
Если вы даете код числа x, можно его проверить на
простоту за от корня из x.
Проверка x на простоту за от корня из x.
Это простой алгоритм, я даже не буду его подробно
писать.
Как проверить, что x простой за от корня из x?
Тривиальное утверждение.
Если x не простое, то есть составное, то у него есть
хотя бы один натуральный делитель не больше чем корень
из x.
Потому что если таких нет, значит все его делители
хотя бы корень из x.
Делитель – это такое d, что существует еще натуральное e, такое, что их произведение – это x.
Ну, если оба больше, чем корень из x, то такой равенец невозможно.
Значит, если нет ни одного делителя не больше, чем корень, то нет вообще ни одного простого делителя, кроме самого x.
Значит, можно просто перебрать все натуральные числа от одного до корня,
посмотреть, что ни одно из них не делит x, и если так, то x – простое. Это понятно?
Ну, значит, это мы так в сторонке заметили.
И как бы, в принципе, можно было бы это сделать здесь, для каждого числа запустить этот алгоритм за корень, но это было бы слишком долго.
Мы сделаем лучше. Значит, мы сделаем следующий алгоритм.
Он работает следующим образом. Сначала считаем, что все числа простые.
Сначала считаем, что все числа простые.
Ну, кроме единицы давайте сразу напишем.
Простые.
Дальше мы будем перебирать числа в порядке возрастания.
И если мы нашли какое-то очередное простое, P, например, тройку.
Если мы знаем, что P – это простое число, тогда мы точно можем сказать, что скажем P умножить на 2, P умножить на 3, P умножить на 4 и так далее, и так далее.
Все они непростые, потому что у них есть в разложении какой-то нейтривиальный делитель P и вот то, что осталось.
Так и запишем. Далее, если P – простое, то 2P, 3P, 4P и так далее непростые.
Ну, собственно, наш алгоритм будет так работать.
Изначально считают, что все числа простые. То есть для каждого числа хранит там булиский флаг true, что мы пока что считаем, что оно простое.
Потом идет в порядке возрастания по всем числам.
Если нашел число, про которое мы пока что не знаем, что оно составное, то есть которое мы пока что считаем простым,
тогда объявляем его настоящим простым, а все вот эти вот кратные ему объявляем составными.
Значит, код будет такой.
Давайте я напишу вот так. Prime от 2 до n состоит из всех трушек.
Изначально мы считаем, что они все простые.
Затем пробегаемся в эту массиву.
Если оно непростое, то мы его просто пропускаем.
А если оно простое, то все кратные объявляем непростыми.
Здесь как можно сделать? Здесь можно написать g от 2 до целой части n поделить на p.
И все такие числа, g умножить на p, объявляем непростыми.
Вот весь код.
Ну, собственно, делаем ровно то, что здесь написано.
Здесь единственно я написал, что какие именно числа мы объявляем непростыми.
Те, которые представляются в виде g умножить на p и при этом входят в наш интервал.
Значит, g должно не превосходить целой части n поделить на p.
Понятно?
Корректно здесь как бы плюс-минус очевидно.
Любое простое число, которое по-настоящему простое, мы объявим в конце простым.
Потому что мы его изначально считаем простым.
И никогда точно не положим, что оно непростое.
Потому что простое не может быть представлено в таком виде.
Не может быть представлено в виде произведения.
Поэтому все простые мы точно найдем.
А любое составное...
Поэтому мы точно поймем, что оно составное.
Потому что если оно составное, значит оно распадает в произведении чего-нибудь простого и оставшегося.
Значит мы когда-то раньше смогли найти это простое и вот этот остаточек.
И тогда это число положили непростым.
Так вот, простейшая реализация Рештарта-Сфена.
Давайте теорему я, наверное, оставлю пока что.
Ну и чтобы оценить асимптотику, нам нужна будет вторая теорема.
Асимптотика.
Здесь всякие линейные операции.
Вот это от n занимает создание массива.
Цикл за от n работает.
И вот здесь, вот за сколько это работает?
Ну это работает за n делить на p примерно.
Асимптотика, это сумма по всем простым, не больше чем m.
n делить на p.
n делить на p.
Потому что самая сложная часть, это вот этот вложенный цикл по g.
Но он работает вот тут написано за n делить на p.
Поэтому суммарная асимптотика ровно вот такая.
И слагаемые берутся только по простым p.
Здесь рассматривают только простые p.
Ну мы знаем асимптотику такого ряда.
Вот здесь написано, что это повторный алгорифм.
Только здесь еще в числителе n-ка написано.
Ну значит это, давайте я напишу так.
Просто theta вот n делить на log log n.
Здесь я даже игнорирую все вот эти вот остаточные члены.
Смотрю только на первый, на повторный алгорифм.
И то даже в терминах theta его напишу.
Мне даже не важна константа.
Потому что, ну да, когда мы оцениваем сложность,
мы не следим за константой мультипликативной.
Но получается такая асимптотика.
Так, я где-то обманул, да?
Наоборот, надо умножить.
Не туда посмотрел, извините.
Да, здесь log log обычный, поэтому там умножение.
Извините.
Опечатка.
Умножить, конечно.
Вот.
Кстати, я не знаю, как это называется.
Я его называю стильный решетор этого сфена.
Ну ладно.
Значит, вот такое решетор работает за n log log.
В принципе, это уже довольно круто, да?
Потому что, если у вас там, не знаю,
ну для какого n вообще есть смысл
писать такое решетор?
В нашей парадигме вот этой страны,
где программа должна работать 1 секунду примерно,
вот там, когда мы на кудфоркс засылаем,
нам нужно завести массив размера n.
То есть, в принципе, там n должно быть порядка 10 в 7 максимум.
Ну, может, чуть-чуть больше.
И тогда вот этот множитель log log,
он, в принципе, супер микроскопический.
Не знаю, что это.
Там 5 где-то или что-то такое.
Вот.
Поэтому, в принципе, можно сказать,
что это то, что нужно.
То есть, это близко к тому,
что у нас была функция керман обратная.
Помните, в прошлом семестре,
там вот, когда мы с nm писали,
что-то, что-то множит обратную функцию кермана.
И мы говорим, что она настолько маленькая,
что, в принципе, и так пофиг,
что это почти вот n.
Ну, все-таки не совсем, конечно, так.
То есть, это может быть что-то плюс-минус существенное.
Поэтому мы сейчас напишем, что за линейное время, за вот n.
Что?
Вот здесь вот?
Почему?
Да вроде нет.
Ну, типа понятно же, что бывают простые больше,
чем корень из n.
А, да, я понял вас.
Но, смотрите, даже если так,
то здесь будет сумма тогда до корня из n.
Да, и тогда здесь будет логарифм
логарифма корня из n.
И это все равно мелочь.
А в числителе все равно n останется, кажется.
Да, значит, дальше.
Что за от и?
Ну, я не знаю.
Я не знаю.
Я не знаю.
Я не знаю.
Здесь я, наверное, сотру эти уже штуки.
Так.
Это решито хорошо не только тем,
что оно работает быстрее,
но и тем, что позволяет посчитать больше информации.
Значит, а именно оно для каждого натурального числа
найдет его минимальное количество,
каждого натурального числа найдет его минимальный простой делитель.
Находим
минимальный простой делитель.
Давайте как-нибудь назовем эту функцию
d-min от x
для всех x от 1 до n.
То есть мы не просто поймем
простоту каждого числа в отрезке от 1 до n,
но еще и найдем минимальное простое делительwow
для всех этих чисел.
Вот.
Но если мы найдем эти минимальные простые делители,
то как понять число простое или нет?
Нужно просто сравнить его
со своим минимальным простым делителем, да.
Если число простое,
то единственное простое, на котором оно делится, оно само.
Значит, минимальный простой делитель, это оно само.
Ну и наоборот, если минимальное...
минимальный делитель равен числу,
значит, нет никаких 다른 меньших.
значит оно простое. То есть равенство d-min от x равно x это критерий того, что x
простое. Ну кроме случая там x равно 1, который мы игнорируем.
Так, ну давайте напишем такой код. Во-первых, мы заведем вектор простых.
Вектор int' куда будем складывать найденные на текущий момент простые.
Дальше заведем массив мин d. Так, ну здесь я уже пишу не код, а псевдокод.
Мин d это какие минимальные делители я нашел в данный момент у каждого числа.
И я в него положу числа 2, 3, 4 и так далее n. То есть изначально так же, как было
там, я считаю, что каждое число простое, то есть его минимальные простые делители
равен ему самому. Окей? Мин d от y равно i, мин d от x равно x. Это пока что такое
предположение мы делаем. То есть пока мы не нашли никаких других простых, мы
считаем, что число равно своему минимальному делителю. Минимальному
простому делителю. Дальше мы перебираем числа от 2 до n. Во-первых, если оно
простое, то есть если минимальный текущий найденный его простой делитель
равен ему самому, если мин d от k равно k, тогда мы его добавим в список простых.
Праймс пушбек к. Мы нашли число, поняли, что оно простое, ну в предположении, что мы
мин d корректно посчитали, поняли, что оно простое, запихали его в вектор всех
простых. Дальше следующее идет. Давайте начнем так. Мы вводим новую переменную
p, которая пробегает по списку всех простых и при этом должны выполняться два
условия. Во-первых, p умножить на k не больше m, потому что нам не нужно числа
больше, чем n. Во-вторых, что тоже важно, p должно быть не больше, чем минимальный простой делитель
найденной ука. Мы чуть позже поймем, что это все значит. Мы перебираем все простые, пытаемся
найти мин d для такого числа, которое должно быть не больше, чем n и при этом p это не больше,
чем минимальный простой делитель ука. Тогда скажите, пожалуйста, чему должен быть равен мин d
у числа p умножить на k? Если я знаю, что p простое, k какое-то, при этом минимальный делитель
вот здесь, вот хотя бы p, тогда чему равно мин d от pk? Ну, конечно, да, потому что как это число
раскладывается на множители. Там есть простое p и еще какие-то простые, каждый из которых больше
он очень p. Значит, минимальный делитель от точности p. Написали такую строчку. Все иное,
наш фор закончился и вот этот большой фор тоже закончился. Алгоритм занимает совсем чуть-чуть
строчек. Здесь самый сложный цикл, проверить два условия, что pk не больше, чем n и p не больше,
чем мин d от k. Ну, надо доказать корректность и понять время работы. Я утверждаю, что в конце
выполнения всего этого алгоритма мин d от x будет равно тому, чему нужно, минимальному простому
делителю числа x. Значит, для простых это очевидно верно. Понятно, что если x простое, то мы вот если в
конце положили мин d от x равно x, то нигде в этом цикле мин d от x не поменяется, потому что раз
x простое, то оно точно не представимо в таком виде, а значит оно не изменится. Первая мысль это,
что мин d от x для простых x найдется верно. Значит, в частности, в векторе primes будут точно все
простые. Ну, возможно, какие-то еще числа, но все простые там точно будут. Точно лежат все
простые. Хорошо, тогда давайте дальше посмотрим на какой-нибудь x непростой. Пусть x непростое.
И q это его минимальный простой делитель. Уменьшим x. Мы поняли, что для простых все хорошо,
теперь надо понять, что для непростых тоже все хорошо. Ну вот пусть x какой-то непростой с
определенным минимальным простым делителем q. Тогда как мы его обработаем? Значит, я утверждаю,
что когда k равно x девять на q и p равно q, мы выполним нужное присваивание, и вот это будет
равно x, а вот здесь будет написано то самое q. Мы скажем, что мин d от x равно q.
Так, ну тоже вроде все просто. Я понял, вот x какой-то непростой. Вычленил из него
минимальный простой делитель и рассмотрел остаток x залить на q. Понятно, что когда-то
k будет равно этому числу x залить на q. Простой оно не простое, неважно. Возможно, он добавится в
вектор. Дальше мы начинаем перебирать все простые в этом списке. Там точно будет вот это вот наше q,
потому что мы понимаем, что все простые точно джат в праймсе, значит, наша заветная q там точно
будет. В какой-то момент будет p равно q. Вот это неравенство будет корректно, потому что q множество
на k будет равно x и x все еще в нашем интервале, поэтому это неравенство будет всегда верно. Здесь
тоже все верно, потому что здесь написано q, а здесь написано мин d от k, но понятно, что мин d от k
больше 0, чем q. Значит, очевидно, минимальный делитель числа k больше равен q. Ну потому что,
если меньше, значит, в x есть еще какой-то меньший простой делитель, значит, мы мин d от x неправильно
нашли. Ну и значит, это неравенство тоже у нас будет всегда выполняться. И когда мы перебираем
простые, там 2, 3, 5, 7 и так далее, мы в частности дойдем до нашего заветного q. Сделаем такое
присвоение, мин d от q множество на k, то есть мин d от x равно p, то есть q. То есть вот эта строчка
выполнится, вы сделом то, что нужно. Более того, мы не просто правильно найдем минимальный простой делитель
для x, но и сделаем такое присвоение, такое присвоение мин d от x равно чему-то ровно один раз. Ну потому
что, когда мы можем выполнить присвоение мин d от x равно чему-то, когда p это его минимальный простой
делитель? А вот здесь вот, если это x, то мы говорим, что минимальный простой делитель x это p. Причем мы
мы знаем, что здесь простых меньше p нет. Значит, каждый
миндей от x присваивается ровно один раз. Значит,
синтезика от n. Я напишу так. Итак, миндей от x когда-то
верно присвоится. Верно найдется. Более того, миндей
от x обновится, то есть мы изменим его значение ровно
один раз. То есть в первый же раз, когда мы потрогали
значение миндей от x, мы туда положили правильное
число и больше этого миндей от x мы никогда не трогаем.
Ну, значит, синтезика как раз от n. Потому что если
мы каждое конкретное миндей от x трогаем максимум один
раз, и как раз у нас основное время работы возникает из-за
этого второго вложенного цикла. И суммарно он делает
операции ровно столько, сколько делает изменения
в массиве миндей. Ну, мы поняли, что таких изменений
ровно не больше mn. Значит, время работы феологритма
вот так. Вопросы? Нет вопросов. Хорошо. Ну, такая штука
нам позволяет найти, как я сказал, уже все минимальные
простые делители для всех чисел. Значит, мы можем
на самом деле отсюда извлекать еще полезную информацию
про факторизацию. Мы можем с помощью этого решета находить
разложение всех чисел на множители. Факторизация.
Ну вот представьте, что мы написали это решето для
всех чисел от 1 до n, нашли минимальный простой. Теперь
как разложить данное число x на множители? Предполагаю,
что x лежит в отрезке от 1 до n. Но мы знаем его минимальный
простой делитель. Давайте на него поделим. Будет x делить
mnd от x. Это опять какое-то число? Мы у него знаем опять
очередной минимальный простой делитель. Давайте на
него тоже поделим. Так, ну я сейчас умру, конечно, это
писать, но один раз не пишу. Вам, конечно, не советую
это писать, ну ладно. Ну смысл такой, что если мы знаем
IBM минимальный простой делитель, кife иitting今日 на него поделим,
то нам останется разложить вот это число на множители.
Ну, мы раскладываем точно так же. Берем минимальный
простой, описываем его и делим. Вот этого оставшегося
числа опять находим, mammals и делим. Пока не дойдем до
простого числа, простое число уже понятно, как раскладывается
на множители. Это просто ere само. Вот весь вот алгоритм.
Вопрос к вам, насколько работает такой вот спуск.
Сколько раз нам может понадобится поделить на minima vad,
логарифм, да. Это работает за вот логарифм. Потому что
каждый шаг это деление хотя бы в два раза. Минимальная
возможная простой это у нас двойка. Ну и таких делений
может быть тогда максимум логарифм. Вот, если мы написали
что-то, в принципе задача факторизации у нас решается
за логарифм. Задача разложения на простые множители решается
на логарифм. Хорошо.
В общем же случае, когда мы говорим про разложение
произвольных чисел, у нас, к сожалению, такой симпатике
хорошей не будет. И плюс-минус лучшее, что известно про
факторизацию числа x, это вот разложение за от корня
из x. Ну вот то, как мы проверяли на простоту в самом начале,
просто перебирая все делители от одного до корня, точно
так же можно не просто проверить на простоту, но и разложить
на множители. Потому что мы по сути находим все простые
от одного до корня, потом мы можем просто, ну простым
образом, определить степень вхождения каждого простого
вот этого x, просто, ну, деля столько раз, пока делится.
Потом останется какой-то остаток, который либо простой,
либо единица. Ну, потому что если оно там больше корня,
может быть максимум один простой делитель. Ну,
тогда вот то, что осталось, это тоже там простое число,
которое надо выписать. Вот. Ну, там есть, конечно, и получу,
наверное, алгоритмы, да, но главное, что они работают
не за полинома длины входа. Вот как у нас там когда-то
было, x сколько занимает запись x? Значит, она занимает
какое-то алгоритмическое количество бит. Чтобы нам
подать компьютеру на вход это число, нам нужно там
обычный алгоритм x бит потратить. Значит, в идеале, если мы
хотим, чтобы у нас все работало за там, ну, какие-то многочлены
от длины входа, у нас здесь должно быть что-то в стиле
алгоритм там в степени 2, в степени 3, что-то такое.
Короче, какая-то степень алгоритма должна быть
во времени работы, чтобы это работало за полинома
от размера входа. Но здесь получается корень из x. Корень
из x это что такое? Это, видимо, что-то такое. Два, ну, короче,
в общем, экспоненты от длины входа, но не полином. А вот
здесь все было бы хорошо, да, вот здесь было бы как
раз просто длина входа, там был x длины лог n, здесь работает
за лог n, но, к сожалению, это еще с линейным предподсчетом.
То есть нам нужно запустить до этого решето за отn. Предподсчет
за отn. Ну, что еще, еще даже хуже, чем корень из x. То
есть это работает, да, если у вас все числа небольшие,
вы можете запустить решето, тогда вы потом быстро можете
факторизовать. Если вы не можете запустить решето,
если у вас x большие, то, ну, вот лучше это можно, можно
за корень сделать, там, ну, либо что-то еще такое подобное,
но оно все равно будет экспоненциально долгое, ну, или там, по крайней
мере, не полиномиальное.
Так, окей, окей, окей, окей. Да, про решетов мы вроде
все обсудили. Теперь давайте еще такое маленькое, что
мне нужно сказать, это обращение по модулю. Тоже, наверное,
многие умеют. Обращение по модулю. Значит, такое
утверждение, пусть a и m взаимнопростые целые числа, тогда существует
такое целое x, что ax сравнимо с единицей по модуле m. Значит,
если a и m взаимнопросты, тогда существует такое x, что ax равно
единицы по модуле m. Этот x будем называть как раз обратным
к a по модуле m. Обратное число к a по модуле m. Вот, ну, чтобы
доказать, что оно существует, мы даже не будем пользоваться
никаким там теря-мейлера или малотеря-фирма, мы просто
скажем, что раз они взаимнопростые, a и m, то значит, существуют
такие целые x и y, что ax плюс my равно единицы. В прошлый раз мы
доказывали теорему о линейном представлении наибольшего
общего делителя. Если a и m взаимнопросты, тогда можно взять их
линейную комбинацию с целыми коэффициентами, чтобы получить
единичку. Наибольшего общего делителя равен единице.
Ну и более того, мы эти x и y умеем находить за алгорифм.
За алгорифм от a и алгорифм от m, от наших двух чисел. Получается,
нам расширенный алгоритм Ефклида, который был в прошлый раз,
находит то самое x, которое мы искали. x можно найти расширенным
алгоритмом Ефклида. Ну я так напишу совсем, не стараясь,
лог a плюс лог m. Тут можно оставить любое из двух слагаемых,
но давайте сумму это оценим, тоже будет верно. Вот такое
важное понятие обращения по модулю. Теперь давайте
немножко поговорим про криптографию, такую совсем
простую, про криптографические протоколы. Все это будет
сильно основываться на наших простых, которые мы в реште
ищем, и на обращениях по модуле тоже будет нужно.
Криптографические протоколы. Нет, это не про криптографию,
это про сжатие. Смотрите, вообще ситуация модельная
такая, у вас есть два агента, Алиса и Боб, они хотят как-то
обмениваться информацией. И обычно канал, по которому
они посылают информацию друг к другу, открытый. Мы
считаем, что он без шума, то есть не вносит никакие
погрешности в передаваемые сообщения. Сообщения передаются
вот в том виде, в котором они отправляются. Ну например,
я небольшой знаток, но мне кажется, что плюс-минус
вот так вот можно совершать какие-то транзакции в блокчейне,
типа биткоин и все такое, потому что там же есть какая-то
открытая база, к которой все имеют доступ. И если там
один хочет перевести денежки другому, то это известно
всем, но только просто информация о том, кто кому переводит
и какую сумму и все такое, оно как бы закодировано каким-то
образом. То есть в этом смысле канал, по которому
они общаются между собой, он открытый, все в него
могут смотреть. Но, тем не менее, они как-то могут
этой информацией обменяться. Возможно, сохраняя какие-то
приватные данные. Как именно его зовут, как именно его
зовут и так далее. Соответственно, есть еще какие-то
подслушиватели. В русском ее зовут Евой. Давайте подпишем,
что это Алиса, это Боб, это Ева. От слова подслушиватель,
кажется, так пишется. Ну короче, вот есть какой-то
подслушиватель, который видит этот открытый канал,
и который, пытаясь взломать то, что они друг другу
посылают, пытается понять, что они друг другу посылают,
используя только открытый канал. И если вот эта информация
здесь довольно хорошо зашифрована, и мы видим только вот этот
вот шифр от информации, то мы, скорее всего, не сможем
понять, что они между собой говорят. То есть они отправляют
друг другу что-то, мы это видим, само сообщение, они как
бы там друг другу кодируют. То есть Алиса закодировала
сообщение, отправила, потом Боб его раскодировал. Они
это все делают, но сторонний наблюдатель ничего не понимает,
он видит какую-то крокозябру, которая никак не может
понимать, о чем именно они говорят, то есть они, да.
Вот, значит, тут есть много всяких моделей. Давайте вот
первый криптографический протокол, это гомирование так
называемое, работает следующим образом. Изначально Алиса
и Боб очень встречаются, приходят в одну аудиторию в
назначенное время, и друг другом просто договариваются
о каком-то секретном ключе. Давайте считать, что А и
Б, так Алиса и Боб, тайна, то есть, ну не в открытом
доступе, а просто вдвоем встретились, их никто не
подслушивает, и вот они тайно друг с дружкой договорились
о секретном ключе. Договариваются о секретном ключе.
Давайте ключ, о котором они договариваются, будет каким-то
айксом, какой-то битовой строкой длины n. Просто вот
строчка из 0 единиц длины n. Самое простое, что они могут
сделать, это просто прийти в одну аудиторию, запустить
какой-нибудь компьютер, который выдает случайную битовую
строчку длины n, то есть написать программу, которая там выводит
рандпроцент 2 n раз, то есть случайный бит от 0 до 0, ну 0 и 1 n раз,
и просто говорят, что вот это вот наш общий ключ тайный.
Затем они его записывают на бумажке, расходятся по
домам, и в момент, когда им нужно обменяться какой-то
информацией, скажем, Алиса хочет передать Бобу какое-то
сообщение, y, а хочет передать y из 0 и 1 в n, Бобу. Тогда Алиса
просто отправляет побитого xor xay, xor y, xor y. То есть x1, xor y,
1 будет первый бит, x2, xor y, 2-ой бит и так далее, просто
побитого xor. Тогда, смотрите, мы получили, в общем-то, то,
что мы хотели от криптографического протокола. Если этот канал
открытый, и кто угодно сюда может иметь доступ, то есть
они общаются, не знаю, через электронную почту с каким-нибудь
открытым ключом или в большой компании, в общем, какой-то
открытый канал связи. Тогда это известно всем, но из этой
информации, в принципе, вы не можете извлечь y. То
есть если вы знаете битовую строчку из 0 и 1, зная, что
в ней какие-то биты пришли из x и какие-то из y, они
поxорились, получилось какое-то сообщение, вы не можете отсюда
извлечь y. Особенно, если x это равномерная случайная
строка, то у вас, по сути, каждый бит случайен. Но с
другой стороны, Алиса смогла зашифровать, а дальше Боб
сейчас может это расшифровать, просто еще раз поxoriflecx,
потому что xxoryxxoryx, xxoryxxoryx, это y. Поэтому Боб очень легко
расшифровывает. Зная вот то самое секретное сообщение,
он берет, xorik его с результатом и получает закодированное
сообщение. И больше никто так не может сделать, потому
что x не известно никому. И лучшее, что они могут
сделать, но это стройки и догадки, но вообще говоря,
эта строка выглядит абсолютно случайней. И по ней нельзя
получить информацию про y. Давайте подпишем, это все-таки
довольно важно, что в идеальном варианте x это просто случайная
вот такая битовая строка. Случайно равномерная строка.
0,1. То есть, среди всех таких строк мы выбираем случайно
и равновероятно, тогда вот это сообщение вне зависимости
от y тоже по распределению такое же, оно случайно
равновероятное в этом множестве. Вот, отличный протокол, но
к сожалению, тут два изъяна. Во-первых, им нужно сначала
очень как-то тайно договориться. То есть, они, грубо говоря,
должны хоть когда-то встретиться в жизни, они должны жить
рядом или что-то такое. А во-вторых, это в каком-то
смысле одноразовое кодирование, потому что, скажем, если
Алиса передала один раз вот такую информацию xxory,
потом захотела еще передать что-то и передала xxorz, когда
два сообщения y и z хочется послать, а она передает вот
это и вот это, то, к сожалению, здесь уже нарушается так
называемое нулевое разглашение, потому что злоумышленник,
если он смотрит на вот эти два сообщения, то он хоть
и, возможно, не может узнать y и z независимо, но точно
может узнать yxorz. То есть, какую-то частичную информацию
о том, что Алиса послала Бобу, он точно может получить.
И просто если вот эта вот xor и xz, эти две строчки,
получится yxorz. И хоть мы сами y и z еще не можем восстановить,
но какой-то кусок информации из того, что Алиса послала
Бобу, мы уже знаем. Вот, поэтому это кодирование, эта схема,
она такая одноразовая очень. Один раз послали и забыли,
потом в следующий раз придется опять заново встречаться
и договориться о новом x. Так. Второй алгоритм. Алгоритм
Диффи Хэммана. Ну, его можно считать не самостоятельным
протоколом, а вот заменой вот этого куска, когда они
договариваются о секретном ключе. То есть, как можно,
находясь на расстоянии, договориться о секретном
ключе. Алгоритм такой. Ну, любой из двух пользователей,
либо Алиса, либо Боб, либо кто угодно, какая-то аракул
какой-нибудь, договариваются о двух параметрах. P и G. Давайте
я скажу, что пусть A генерирует простое P и G, которое будет
являться первообразным корнем по моделю P. Так, кто
знает, что такое первообразный корень по моделю P? Так,
почти все. Хорошо. Ну ладно, половина скажем. Для нас
нужно будет просто следующее знание, что множество чисел
G в нулевой, G в первой и так далее, G в середине P-2 равно
по моделю P множество чисел 1, 2, 3 и так далее P-1. То есть,
все различные степени G по моделю P – это все различные
возможные остатки, кроме нулевого, по моделю P. Все
вот эти вот степени попарно различны и в каком-то порядке
задают нам вот эту перестановку. То есть, степенями G можно
покрыть все ненулевые остатки. Дальше, вот Алиса их сгенерирует
и публикует их. А публикует G и P в открытом доступе. Дальше
происходит следующее. A генерирует случайное A маленькое, B генерирует
случайное B маленькое. Затем, причем эти A и B друг другу
не сообщают, у них просто приватная информация. A знает
A маленько, B знает B маленько, и они пока что никому это
не сообщают. Дальше происходит следующее. Алиса отправляет
Бобу сообщение G в степени A, а Боб отправляет Алисе сообщение
G в степени B. То есть, они просто взяли случайные степени
G. Алиса отправляет G в степени A, а Боб отправляет G в степени
Вот они так обменялись какими-то степенями G. Дальше, теперь
мы получаем, что Алиса знает A и G в степени B, а Боб наоборот
вычисляет значение G в степени A и B. Если каждый из них знает
вот это вот, то Алиса может вывести вот это число в степень
A, получить G в степени A-B, а Боб может вывести G в степень
A в степень B, получить G в степени A-B. Поэтому в итоге
они оба у себя вычисляют значение G в степени A-B.
G в степени A-B. То есть, еще раз, Алиса просто присланное
сообщение возводит в степень A, в который секретное сообщение
у нее хранится тайно сгенерированное. Боб то же самое делает со
своим присланным сообщением, возводит его в степень
B, который он сам сгенерировал. Теперь у них у обоих есть
вот это вот число G в степени A-B. И это G в степени A-B можно
использовать как вот этот вот тайный ключ, секретный
ключ. Можно использовать как секретный ключ.
Ну типа того, да. Значит, смотрите, утверждается, если они так
пообщались, вычислили какое-то число, понятно, что они договорились
о какой-то конкретном вот X, да, вот то, что у меня здесь
было X, они договорились о каком-то общем, секретном
ключе. Теперь вопрос, насколько он, на самом деле, секретный.
Насколько Ева, вот этот вот подслушиватель, не сможет
его вычислить? Давайте поймем, что знает Ева.
Потому что задача дискретного агарифмирования сложная.
Значит, давайте перечислим все, что знает Ева. Она знает
первообразный корень по модулю P и знает две какие-то его
степени G в степени A, G в степени B. Больше она ничего не
знает. Просто это все, что передавалось по каналам.
Модуль с генератором, то есть с первообразным корнем, и
какие-то две его степени. То есть в идеале, что хотелось бы
сделать Еве? Ей бы хотелось вот это вот как бы
пралагарифмировать по основанию G, получить вот тот самый
показатель A, узнать вот отсюда A. Ну и потом вот это
число возвести в степени A, и тогда она получит тоже
самое G в степени B. Но, к сожалению, для Евы и, к счастью,
для нас, к счастью, для Лисы и Боба, задача вот этого
самого дискретного агарифмирования, то есть решение
уравнений G в степени X равно данному числу, то есть, по
сути, излечение вот этого A по значению G в степени A,
это сложная задача. И пока что ее никто не умеет делать
за полином от длины P, скажем. Давайте это запишем.
Самое простое, что может сделать Ева, скорее, что хочет
сделать Ева. Вот оно какое. Значит, это найти то самое
такое, что... Сейчас, секунду. Давайте я напишу так. Она
хочет найти A, решив уравнение вида G в степени X сравнимо
с константой C по моделю P. То есть нам известно вот
того, C равное G в степени A, нам известно основание G,
и нам хочется возвести в такую степень, это самое G,
возвести в такую степень X, чтобы было то самое нужное
число C в степени A. По сути, нам нужно решить такую задачу.
Ну и затем получить G в степени B в степени A. И тогда она
узнает тот самый тайный ключ. Разумеется, это не единственный
способ действия для Евы, но он такой самый простой, мы не
будем целиком доказывать корректность, потому что
здесь нужно много определений вводить, что такое надежный
протокол. Но по сути, ей нужно как раз таки решить
такое уравнение. Ну а вот эта задача сложная, ее никто
не умеет решать за полином от длины P. А на канты, вы
думаете, умеют? Ну что же вроде факторизацию просто
делать? Ну понятно, ладно. Мы живем в мире обычных
машин пока что, и считается, что такое уравнение пока
что никто не умеет решать за полином от длины P. Не
умеем быстро решать. Вот. Ну и на семинаре можно
разобрать вариант решения этого уравнения за отхорний
из P. То есть в идеале, если Алиса генерирует P достаточно
большим, ну не знаю, 100 знаков примерно, P порядка 10 в
сотой простое, тогда хотелось бы работать за полином
от 100, то есть за полином от длины входа. Но лучшее
как бы, ну или плюс-минус лучшее, что известно, это вот от
корня из 10 сотой, то есть примерно за 10.50. Это очень
долго, и как бы у Евы нет никакой надежды, что она
сможет это X быстро найти. Ну вот такой сюжет, который
позволяет им договориться о тайном X, Алисе и Бобу
договорятся о тайном X, явно не встречаясь. Вот как-то
послали сообщение, вычисляют одно и то же число, которое
является будущим секретным ключом для их общения. Окей?
Хорошо.
Так, ну давайте еще третий протокол посмотрим, протокол
RSA.
Кажется, тоже по первым буквам фамилий, авторов.
Значит, алгоритм такой.
Алгоритм такой. Ну здесь тоже немножко он односторонний
получается, значит он позволяет обеспечить одностороннее
общение. В том смысле, что вот Боб есть какой-то там
не знаю, какое-нибудь государственное предприятие, ну или там
государственный орган, он публикует открытый ключ,
по которому люди могут отправлять к нему письма. И эти
письма будут видны всем, но они будут как бы закодированы.
Никто не сможет понять, что в них написано, кроме
отправителя и получателя. То есть такое одностороннее
общение, мы предполагаем, что государственный орган
как бы не отвечает в ответ, ну или там отвечает открытым
текстом. Мы хотим закодировать только в одну сторону.
Работает следующим образом. Боб публикует.
Нет, давайте сначала, Боб генерирует различные простые ПК.
Различные простые ПК. И публикует n большое равное ПК.
П умножить на Q. Вот. И здесь уже такой как бы затравка на
будущее, что он опубликовал произведение двух простых,
и стороннему наблюдателю, если он знает только произведение
двух простых. Уже довольно сложно разложить это число
на множители. Вот я вам там скажу произведение каких-то
двух простых довольно больших. Чтобы разложить на множители,
ну опять-таки плюс-минус лучшее, что мы умеем, это
перебирать все простые до корня и искать там минимальное
из них. Потому что как бы не очень понятно, как найти
это самое разложение. То есть здесь опять-таки задача
факторизации, получение по вот этому вот числу отдельно
P и отдельно Q. Вот потому что она сложная, мы предполагаем,
или пока что никто не умеет это быстро решать, этот
протокол будет надежным. Итак, ну что он опубликовал
PN равное П в степеньку, а также число E, взаимно простое
с P-1 на Q-1. Тогда как работает общение? Если Алиса хочет
послать какое-то число X Бобу, хочет послать X Бобу,
тогда Алиса отправляет Бобу X в степень E по моделю
N. То есть если она просто хочет отправить X, то вместо
отправки непосредственно X, потому что если мы отправим
X, он будет всем виден, соответственно все знают, что отправила
Алиса. Вместо этого Алиса отправляет X в степень E. Вот
возводит это число в степень E, тем самым как бы, ну это
уже не сам X, а какая-то функция от него. Ну а дальше Боб,
чтобы раскодировать обратное сообщение, чтобы раскодировать
X в степени E, делает следующее. Ему-то известно разложение
N на простые множители по IQ. Он делает следующее. Он
находит D, это число обратное к E, вот как раз обратное
по модуле возникает, обратное к E по модулю P-1Q-1 и вычисляет
X в степени E в степени D. И утверждает, что это в точности
равно X по модулю N. Так, значит еще раз, как работает алгоритм.
Сначала Боб, государственный орган, публикует, генерирует
сначала два простых числа больших по IQ и публикует
в открытом доступе их произведения N. А также публикует
число E, которое взаимно просто вот с этим произведением
P-1Q-1. N и E в открытом доступе. Дальше, если Алиса хочет
послать Бобу какое-то сообщение, она просто позовет его
в степень E и отправляет по каналу X в степени E. Теперь
сторонний наблюдатель видит только X в степени E, но не
видит само E, то есть не видит само X, извините, не видит
исходного сообщения, видит только какую-то его степень.
Ну а дальше Бобу, чтобы расходировать это сообщение,
ему достаточно возвести его в степень D, такое, что
D это обратный к Е по модуле Q-1Q-1. Так, чтобы понять, почему
это работает, нужно, наверное, сказать, нужна нам все-таки
тирема Эйлера.
Так, вот есть такая тирема, которая говорит, что если
числа А и М, тогда А в степени фиат М-1 это единица по модуле
М, ну а значит, если мы обе части умножим на А, А в степени
фиат М равно А по модуле М. Значит, фиат М это функция
Эйлера. Фиат функция Эйлера. Вот. Нам не особо важно, как
именно она себя ведет, нам важно только лишь, что
фи от ПQ равно П-1 на Q-1. Что? Еще раз. Фи от П это П-1, да.
Так, что, косяк где-то? Сейчас, сейчас, сейчас, одну секунду.
Да, нет. Да, где-то не так. Извините. Момент. Вот здесь?
Сейчас, sorry, sorry, sorry. Я позорно загуглю тирема Эйлера. Да,
значит, я облажался, действительно. Тут нет, тут нету минус
есть. Да, спасибо. Извините. Дальше. Правильно ли я посчитал
фи от ПQ? Вроде правильно. Так, ну тогда смотрите. Да,
тогда смотрите. Значит, что здесь происходило? Нам
известно х в степени Е, а еще мы знаем, что D это обратное
к Е по модулю P-1Q-1. Вот. Ну, значит, ЕD это как бы единичка
по модулю P-1Q-1. И вот это вот это фи от Н. То есть мы
по сути, вот здесь вот, когда возвели х в степени Е, в
степень D еще, мы получили х в степени, и эта степень
сравнима с единицей по модулю фи от Н. Ну, значит, как раз
вот это вот то, что нужно. Да, если мы возводим х в степень
что-то кратное фи от Н плюс единичка, то есть единичка
по модулю фи от Н, то мы получим исходный х по модулю
Н. Значит, как раз вот это вот равенство выполняется.
Х в степени ЕD сравнимо с х по модулю Н. Вот следует
из теремы Эйлера. Вот. Ну, отлично. Значит, Боб смог декодировать
исходное сообщение Алисы. Просто возведением х в какую-то
степень. Вот. Ну, значит, тут надо сказать, что задача
возведения в степень простая. Мы в прошлом семестре учились
возводить винарно в степень. Ну, вот здесь любой алгоритм
быстрого возведения в степень по модулю. Там, скажем, за
алгоритм D это можно сделать, возвести в степень. Вот.
Но сторонний наблюдатель, что он видит? Он видит N, он
видит E, он видит х в степени E. Больше ему ничего недоступно.
У него есть как бы два способа действия. Первый способ
действия — это пытаться извлечь корень этой степени
из х в степени E. Если вдруг у него это получится, то
он сможет декодировать исходное E. Но это тоже не очень понятно,
как делать. Это не очень простая задача, если и решаемая
эффективна. Второй способ — это пытаться разложить
N-намножитель. Значит, если он запускает какой-то алгоритм
факторизации довольно быстрый, который смог найти такие
разложения N на PQ, тогда он сможет сделать все, что
нужно. Он знает N как раскладываться на PQ, отсюда он сможет найти
phi от N. Что это P-1 на Q-1 может найти просто перемножив
вот эти вот два числа. Ну и тогда обратное к E по модулю
phi от N он может легко узнать. Обратное к E по модулю phi
от N он тоже может узнать. Ну, значит, он знает D, значит,
он может смоделировать поведение Боба просто. Поэтому сторонним
наблюдателем в итоге у него выбор — либо пытаться
раскладывать N-намножители, либо пытаться извлекать
корень данной степени в ZN. Решать уравнение в стиле
X в степени E равно чему-то и искать X. По сути извлекать
корень. Обе эти задачи не очень простые, и поэтому
этот протокол в каком-то смысле надежный. Что даже
если сторонний наблюдатель видит все вот это вот, то
он не сможет, ну или по крайней мере быстро не сможет дикодировать
исходное сообщение. Так, хорошо, хорошо. Вот, ну тогда
мы немножко поговорили про кодирование, точнее
про криптографию, как обеспечить какое-то надежное
общение. Плюс-минус, то есть так, что они общаются
по открытому каналу и сторонний наблюдатель все равно не
может понять, о чем речь. Так, тогда, наверное, следующий
сюжет, алгоритм Штрассена. Вот, алгоритм Штрассена,
наверное, будет присклинаться за отравкой к следующему
разу, когда мы перейдем наконец к алгоритму FFT. Значит, алгоритм
FFT, напоминаю, он позволяет нам быстро перемножать
многочлены. Если у нас два многочлена, скажем, N на
N, то есть А0 плюс А1х плюс и так далее, там, вплоть
до АН, ХВН, и второй тоже самый с Б. И вот их можно
перемножить за N лог N. Да, ну, считая, что мы не паримся
с точностью и считаем все с какой-то погрешностью.
Вот, алгоритм Штрассена делает, ну, как бы, пытается
сделать что-то похожее, но с матрицами. Итак,
пусть есть две матрицы, две матрицы А и Б, размера,
давайте считать, что 2 вкатый на 2 вкатый. Для простоты
считаем, что это матрицы квадратные, и при этом у
них число строк, размерность этой степени двойки, 2 вкатый
на 2 вкатый. Наша цель – это найти А0хB. Наша цель – найти
их произведение, которое мы обозначаем за С. Ну,
есть понятное дело, очень простой алгоритм, просто
по определению, как их перемножить. Мы перебираем
строчку первой матрицы, столбец второй матрицы,
скалярную умножаем, получаем очередной элемент. Значит,
наивный алгоритм просто по определению работает
за куб от размера матрицы, за θ от n в кубе, где n равно
2 вкатый. Если у меня размер матрицы – это n, то перемножить
две матрицы n на n стоит n в кубе, ну просто по определению.
Оказывается, можно лучше, можно эффективнее, при условии,
что у нас есть операция вычитания. Значит, давайте
все это напишем. Можно немножко быстрее, мы сейчас это сделаем.
Давайте для этого мы разобьем атмосферу А на 4 кусочка.
То есть мы поделим пополам число столбцов и число
строк и разобьем на такие 4 равные квадратика. Каждый
квадратик будет иметь размерность 2 в степени камен с 1 на 2 в
степени камен с 1. То же самое сделаем с B и с C. Разобьем
все эти матрицы на 4 одинаковые квадратика.
А дальше происходит следующая магия, которую не надо будет
запоминать, но идея здесь довольно простая. Давайте
посчитаем следующие 7 страшных матриц. Как это придумать
мы обсуждать не будем, мы просто это посчитаем.
Вот такой рандом. Вот что это мы написали. Смысл такой,
вот у нас есть 8 под матриц, 4 отсюда, 4 отсюда. Мы хотим
сделать 7 рекурсивных запусков умножения матрицы меньшего
порядка. То есть если у меня исходные были 2 вкат
на 2 вкат, то теперь я буду перемножать матрицы размера
2 вк-1 на 2 вк-1 друг на друга. То есть это матрица в два
раза меньшего порядка. И число умножений стало 7.
В 7 умножений матриц в 2 меньшего порядка. Теперь если
я с помощью этих 7 матриц смогу вычислить вот эти
вот 4 ячейки, то я получаю исходную задачу, свел к
7 задачам в 2 меньшего порядка. У меня будет такая рекуррента.
ТОтн равно 7 ТОтн пополам плюс, видимо, n квадрат. Н квадрат,
потому что здесь мне нужно будет, то есть здесь самое
сложное это складывать и вычислять матрицы. Что
это такое? Вот. Но мастер Терема нам позволяет, что?
Ой, спасибо. Тета, извините. Да. Вот. Мастер Терема нам
позволяет такое решать. Мастер Терема. Мы там находим
что-то из этого a, что-то из этого b. Считаем логарифм
от семерки по основанию 2. Понимаем, что это сильно
больше, чем n в квадрате. Значит симптотика будет
тета от n в степени лог 7 по основанию 2. Просто из
мастер Терема напрямую получается. И смотрите, это уже лучше,
чем n в кубе. Чем вот то наивное решение, это будет лучше,
потому что это n примерно в степени 2.81. Ну, можно
2 плюс 7, он даже вроде. Но теоретически, да. Нет-нет,
больше этого нет. Ну не будем в смысле. Слабо. Но только
если большие матрицы. Да-да-да. Ну, смотрите, все равно как
бы здорово. Можно умножать не за куб, а за n в степени
2.8. Отлично. Вот. Ну хорошо, мы это посчитали. Давайте
я напишу, как выражаются конечные вот эти четыре
подматрицы через посчитанные. Вот, что-нибудь проверим.
У этого алгоритма есть еще, можно сказать, что он практически
применим, потому что он очень хорошо параллелится,
потому что вот вы, по сути, свели задачу к семи меньшим,
да, если у вас есть там, условно говоря, бесконечно, ну, там
достаточно много процессоров, вы каждому из них перейдете
эту задачу на вот, ну, переножение там двух каких-то подматриц.
Они это там вычисляют параллельно все. Вот. И тогда вы как бы
можете эффективно, ну, быстро посчитать а умножить на
б. Вот. А в каком-то смысле, сейчас, сейчас надо подумать.
Короче, можно сказать, что этот алгоритм в каком-то
смысле эффективен, потому что он хорошо параллелится
именно вот из-за того, что он разбивается на семь
независимых кусочков. Сначала они все считаются, потом
из них получается ответ. Вот. Так вот, утверждается,
что если мы посчитали те семь штук, то результатившие
четыре блока матрицы С считаются по таким формулам.
Так. Ну, вот это все учить не надо. Давайте просто
какой-нибудь докажем, да, что действительно получается
то, что нужно. Вот. И на этом, наверное, алгоритм мы оставим.
Ну, например, давайте вот С2,2 посмотрим. С2,2 правой нижней углы.
Значит, как он получается? Чтобы получить С2,2 мне
нужно умножить последнюю строчку в а на последний столбец в b.
С2,2 точно равно a2,1 умножить на b1,2 плюс a2,2 на b2,2. Вроде так.
Да, ну, то есть тут надо еще доказать, что когда в матрице
бьем на блоке, то по сути над блоками умножение получается
такое же, как над обычными числами, да, по строчной
и по столбцам. Ну, это просто. Ну, давайте проверим, что
вот это равно вот этому. Вот. На всякий случай. Давайте
это посчитаем. Значит, p1 минус p2 плюс p3 плюс p6. Так, интересно.
Ну, я не вижу здесь общих множителей, поэтому предлагаю раскрыть
скобки и умереть. Ну, давайте. Пусть веселость не сойдется,
кайф. Так, это p1 было. Дальше p2, я считаю. Плюс p3. Плюс p6.
Вот это? Это минус.
Нет, нет, еще раз, смотрите. Мы знаем вот это? А сейчас я просто пишу вот это
вот выражение, чему равно. Вот это вот равно вот этому. Да, вы про это?
Не, мы просто подставляем, чему равно p1, p2, p3, вот в эту форму. Вот то вот
подставляем сюда. Вот. Значит, p1, p2, p3 я подставил. Значит, осталось p6.
Так, я вроде все выписал, теперь буду сокращать.
Ну, я по-разному, типа, такие. Ну, в общем, чтобы было понятно, что с чем сократилось.
Все, вроде все сократилось, осталось как раз то, что нужно. А2,2,B2,2 плюс А2,1,B1,2. Ура, победа. Вот.
Ну, видимо, если вы посчитаете вот эти вот три штуки, то получится тоже то, что нужно. Те самые
произведения кусочков матрицы, которые нам нужны. Симметрично, очевидно. Отлично. Нет, нет, не надо.
То есть, тут главная идея, идея такая, что мы разбиваем наше матрице на четыре квадратика
одинакового размера. Потом как-то считаем семь каких-то странных произведений через суммы и
разности. Семь посчитали, получили такую симптомику. Ну, и в конце из этих семи произведений нужно
как-то их там с плюсами и с минусами взять, чтобы получить четыре из этих квадрат. Эти формулы не
надо запоминать. Вот они есть. Да, и получается, что вот получается такой алгоритм. Так. Окей. Вот. Ну,
круто. Получается, можно перемножать быстрее, чем Зейн в клубе. И тогда давайте последний сюжет на
сегодня быстренько обсудим, что успеем. Это число стиринга. Число стиринга первого и второго рода.
Так. Сейчас, сейчас, сейчас, сейчас всё будет. Так, хорошо.
Смотрите. Давайте на первом роде сначала сфокусируемся. Число стиринга первого рода. Их
можно определить двумя способами. Первый способ такой. Давайте мы будем рассматривать вот такие
вот многочлены. Х на х-1 и так далее, вплоть до х-н плюс один. Н умножители здесь. Нет. Нет, нет.
А, ну и тогда х факториал делит на х-н факториал. Тогда уж. Если так. Ну, потому что это как раз все,
ну, произведение всех до х, кроме произведения всех до х-н. Вот. Ну да, х здесь это не обязательно
целое число, это просто какая-то переменная. Поэтому не обязательно продавать этому какой-то
смысл. Вот рассмотрим на такой многочлен. И, значит, наш вопрос следующий. С какими
коэффициентами он раскладывается по обычной системе там 1, х, х в квадрате и так далее? Давайте
напишем так. СНК х в катах. То есть, ну понятно, какой-то многочлен в степени ровно n, значит,
его можно представить в виде такой вот суммы х в катах с кем-то коэффициентами. И вот наш
вопрос, как находить эти СНК? И вот эти вот СНК как раз будут являться числами стиринга первого рода.
Число стиринга первого рода. Так. Зачем нам это может быть нужно? Зачем нам это может быть нужно?
Ну, например, кажется, на одном из прошлых семинаров была такая задачка. Посчитать вот такую сумму.
К квадрат на СНК по всем К от 0 до n. Вот, значит, самое простое. Что здесь можно сделать? Следующее.
Сказать, что К в квадрате. Ну, это К на К-1 плюс К. Значит, эту сумму можно расписать как сумма по К от 0 до n,
К на К-1 СНК плюс такая же сумма К на СНК. Вот. А дальше, когда мы степень К заменили на вот такой вот,
как бы, ну, как это называется, такой неспадающий факториал, то есть К на К-1, ну, то есть на несколько
множителей, вот, это будет очень удобно сокращаться с СНК, потому что СНК это там как раз произведение
факториалов N-факториал делить на K-факториал на N-K-факториал. И там как раз вот это и К-1 сократятся с чем-то в знаменателе,
и будет вот эта вот сумма перепишется как там какая-то, ну, какая-то другая С, в общем. И, короче,
этот ряд считать сильно проще, чем исходный. Если мы перейдем от обычных степеней К вот этим вот
факториальным степеням, то есть произведения нескольких К, К-1, К-2 и так далее, их очень
просто перенажать с С-шками и складывать. То есть вот это вот посчитать проще, чем
исходное. Ну, и это тоже самое, то есть это там в многочисленной еще меньшей степени. Вот. Такие
задачи возникают, у вас же было распределение полосона на тервере, вот. Это возникает, например,
распределение полосона. Ну, или там, сейчас, сейчас. В общем, похожие идеи, да, не скажу, что прям ровно
такое, но что-то похожее возникает, когда вы считаете, скажем, вот есть у вас КСИ с распределением
полосона, и вам нужно посчитать ее там от ожидания третьей степени, третий момент посчитать. Вот. Там
как раз будет что-то подобное, и если вы вместо К в кубе напишите там какую-то сумму К на К-1 на К-2 с
киминкоэффициентом плюс К на К-1 плюс К, вот. Там это точно также просто просто сложится. Ну, там
тоже какие-то факториалы есть, и вот как раз они будут сокращаться с вот этим множителем. Вот.
То есть задача перехода от вот такого многочлена к сумме вот таких, ну, в каком-то смысле полезна,
что, ну, например, с ее помощью можно там просто считать моменты полосонского распределения. Ну,
и там, похожих распределений, в которых в вероятности есть какие-то факториалы.
Когда мы от степени переходим к произведению нескольких последовательных чисел. Вот.
Это число стерлинга первого рода.
Можно доказать еще. Давайте напишем утверждение. Утверждение. Модуль числа СНК. Это количество
перестановок на N-элементах, которые в циклическом разложении имеют ровно К от циклов. В разложении
на циклы имеют ровно К от циклов. Вот. Ну, например, если вы рассматриваете N равно тройке,
рассматриваете все перестановки на трех элементах, то как они у вас выглядят? Значит,
как может выглядеть такая перестановка? Давайте я все шесть нарисую быстренько.
Есть такой цикл. Есть, скажем, просто петля на единицы, два-три переходят друг в друга. Есть,
когда все три это отдельные петельки. Ну, перестановки. Перестановка это всегда такой
ориентированный граф. Несколько циклов. Дальше что бывает? Дальше бывает, скажем,
двойка это петля, а один-три друг в друга переходят. Тройка это петля, а один-два в друг
друга переходят. Ну и, видимо, цикл обратный к этому. Все возможны шесть перестановок на
трех элементах. И, соответственно, у каждой из них есть свой циклический тип. Здесь есть цикл длины
1 и 3, здесь есть циклы длины 1 и 2, здесь есть циклы 1 и 1, здесь 1 и 2, здесь 1 и 2, здесь 3. Ну и,
соответственно, если мы фиксируем количество циклов, какое число k, скажем, ну вот k равно 2. Мы
хотим, чтобы было ровно два цикла. Тогда нам подойдет вот это, вот это и вот это. Картинка,
где есть ровно два цикла. То есть, когда все распадается в два таких кружочка зацикленных,
количество таких чисел, количество таких перестановок, в точность равно модулю вот
этого числа стиленга первого рода. Ну, чтобы доказать, доказать можно самое простое,
просто написав рекурренту для вот этого и для вот того. Доказать это можно, доказав рекурренту.
Так, сейчас тоже едем к шуму.
Вот, значит, с такими начальными условиями, когда у меня k равно нулю, если, если s задать вот так вот
и потом начать этот рекуррент на вот так, то, значит, с одной стороны можно легко показать,
что вот это вот, вот в этом выражении, просто по индукции, если мы знаем, как выражается вот
этот n-факторный момент через степень k, то n плюс 1 легко выражается, нужно просто там написать
еще один множитель, раскрыть фиоскопки и получается, что там каждый коэффициент получается вот так вот.
Ну, а база такая же. Здесь же с этими циклами можно то же самое сделать, значит, можно доказать
по индукции, что вот эта вот формула, ну, если я модуль еще везде навешу, то эта же формула будет
отображать число перестановок на n элементах с k циклами. То же самое, значит, если у вас есть
формула, если у вас есть, ну, чтобы посчитать вот это, нужно, скажем, понять, где лежит этот
плюс первый элемент, либо в отдельном цикле, либо в одном из предыдущих, и получается, в общем,
такая же формула, если модуль навесить, будет то же самое. Ну, значит, мы поняли, ну, как бы,
постулировали, что вот это вот число одинаковое, только здесь надо еще модуль навесить, ну, и за
одно мы вывели, точнее, даже опять-таки постулировали рекурренту, которую можно доказать, которая нам
позволяет находить все эти числа за квадрат. То есть, если, скажем, у меня есть, если моя задача
это найти коэффициенты разложения n-ого факториального момента, нет, n-ого факториального момента через
обычные степени, то я могу просто за n в квадрате написать вот эту формулу, заполнить табличку
целиком, s и g, и вот эта вот последняя строчка, где будет там s, n, все нужные мне кашки, вот эти
коэффициенты как раз будут то, что мне нужно. Ну, эта табличка заполняется просто сверху вниз.
Получается, за квадрат мы можем это все найти. Так, ну, давайте тогда уже, поскольку времени совсем не
остается, я скажу, что числа второго рода, числа стерны второго рода решает обратную задачу, они
выражают x в степени n через сумму факториальных моментов, умножить на, вот здесь будет коэффициент,
равный числу стерны второго рода, s большое nk. Вот это вот число стерны второго рода, то есть,
ну, обратная задача, мне нужно, наоборот, x в n выразить через вот такие вот произведения по разным
k. И здесь коэффициент перед каждым таким слагаемым будет как раз число стерны второго рода,
которые, в общем, тоже как-то так считаются, там есть аналогичная рекуррента, которая позволяет
за квадрат посчитать это значение. Так, ну, на этом тогда всего спасибо.
