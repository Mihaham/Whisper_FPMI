Так, давайте начинать.
Я принял решение, мы, наверно, возместим лекцию, которая
в 21 февраля у нас пропала, потому что иначе я не могу
состыковать программу семинаров с лекциями, там будут дурки.
Вот, поэтому у нас точно неделя, а какое это получается?
16-е.
Вот, я проведу две лекции, одну в обычное время и сразу
следующую за ней.
Вот, со своей стороны могу только пообещать, что
ее материал не будет нужен для следующих лекций, поэтому
как бы если вы категорически отрицаете поход на лекции,
которые выпадают на праздники, можете не приходить, типа
на следующих лекциях вам это не понадобится, но
она будет обязательна в том смысле, что там и контесты
на нее и в экзамене она будет, поэтому на ваш вкус.
Вот, а аудиторию я еще сообщу дополнительно, о чем я начну
на первой лекции, я начну, короче, по окончающей пути
все там будет, я начну БФС да икстра, а звездочка,
а на второй будет Форд Делман и Флойд.
Так, окей, давайте вернемся к нашим орграфам, значит
в прошлый раз, я так понимаю, я закончил на таком утверждении,
что если есть ребро из-за А в Б, то алгоритм Касараю
скажет, что ID от А меньше, что равно ID от Б, вот было
такое?
Вроде да, хорошо, значит, сейчас мы будем этим
пользоваться для решения следующей задачи, задача
называется два SAT, SAT от Solace Satisfiability, два выполнимости,
значит представьте себе такую задачу, у вас есть
формула в виде два KNF, насчет такой два KNF это конъюнкция
скобок, в каждой скобке дезъюнкция двух литералов,
вот это примерно что-то типа такого Х или Y, и не
А или Б, и не Y или не В, вот такая конъюнкция скобок
в каждой скобке дезъюнкция двух литералов, литерал
это переменная или отрицание переменной, вот, и наша
задача посчитать, извините, найти какой-нибудь выполняющий
набор, найти выполняющий набор, то есть такой набор
значений переменных, на котором вот эта формула
равна единице, то есть набор, на котором формула равна
единице, вот, значит решается следующим образом, мы заводим
граф, в котором вершины будут выступать вот как
раз эти литералы, переменные и отрицания переменных,
значит мы заводим граф, вершины, это все литералы,
то есть все переменные и отрицания переменных,
например, вот здесь у меня будет Х не Х, Y не Y, а не А,
Б не Б, короче, для каждой переменной, которая состоится
в формуле, я завожу по две вершинки и помещаю их соответственно
пометками, там, переменная и отрицание переменной,
а дальше провожу очень естественные стрелочки, которые по сути
эквивалентны вот этим дизюнкциям, если стрелочка воспринимать
как импликации, то я могу записать все эти инвункции
в виде импликации и в виде стрелок нашего графа, значит
смотрите, что такое дизюнкция А или Б, значит это то же самое,
что сказать, что из не А следует Б, и то же самое, что если
сказать из не Б следует А, ну понятно, потому что дизюнкция
что хотя бы один должен быть истинной, это что значит,
значит если первым не верим, то обязательно верим в
второй, если не А то Б, ну наоборот если не Б то А, такое
очень простое замечание, ну давай тогда если видим
такую скобку, то проведем вот эти все стрелки, то есть
если я вижу такую скобку, ну тут ее нет, но если бы
она была, я бы провел ребро из не А в Б, а это есть у
меня вершина в нашем графе, соответственно ребро из
не Б в А, вот и так для каждой скобки, перебираем все скобочки,
и проводим два соответствующих ребра, которые по факту
эквивалентны, то есть если ребра воспринимают как
компликации, как эти логические следствия, то они эквивалентны
просто-напросто в нашей дизюнкции, значит делаем
так для каждой скобки, значит теперь смотрите, смысл такой,
я хочу сказать, что каждая вершина это какой-то логический
значение, true или false, это humidific tragedy, и если у
меня есть стрелочка откуда-то, и если вот это вот
откуда-то равно единице, то тогда все, что достигнуто
по стрелочке тоже должно быть единицей, ну, потому
что, да, вот представьте себе, что это истина литералка,
то не А равно единице, тогда для этого должно быть
В, ну потому что имплекация так работает, если посылка
истина, то заключение должно быть истинным, чтобы эта
имплекация была истинная, потому что если была 1 0,
то эта имплекация была бы ложная, на мне надо�
Нам не нужно, чтобы если единица, то здесь тоже единица.
Поэтому вот эти ребра, они как бы проталкивают единицу
из позиции во все остальные.
То есть если где-то один, если где-то получился истинный лейтенант,
то все, что из них достеремо, тоже должно быть истинным.
Вот, ну и поэтому утверждение формула Фи выполнило,
если и только если для любой переменной P,
вот в этом графе, который мы построили,
ну я напишу так id от P, не равно id от не P.
То есть для каждой переменной, она, точнее вершина, отвечающая этой переменной,
и вершина, отвечающая отрицание этой переменной,
лежат в разных компонентах сильной связности,
а id-шники, это вот ровно то самое, те самые id-шники из алгоритма Касараю.
Вот эти id нам проставляют в алгоритм Касараю.
Соответственно тогда задачу мы решим так, нам дали формулу,
какую-то такую вот, да, мы строим граф,
для каждой скобки, проводя по два ребра,
затем запускаем на этом графе алгоритм Касараю,
он всем вершинам, все вершины разбивает на компоненты сильной связности,
то есть у каждой вершинки поставляет id-шник,
номер компонент и сильность связности, где вершина лежит.
Ну и дальше просто по всем вершинам проходим,
если видим, что вершина лежит со своим отрицанием,
точнее если перемена со своим отрицанием в одной ксс,
в одной компоненте, тогда мы говорим, что решения нет.
Вот, ну а если это для всех вершин выполняется,
то есть если тут неверно для всех, то значит решения есть.
Не штекарайся с вами.
Ну, слева-направо очевидно,
потому что если было верно бы обратное, да, давайте от противного,
если бы существовала некоторая переменная,
которая попала бы в одну ксс со своим отрицанием,
что это бы значило? Вот здесь какая-то ксс,
здесь есть п, здесь есть не п.
Что значит, что они лежат в одной компоненте сильной связности?
Значит, они друг с другом достижены в обе стороны.
Просто по определению, компоненты сильной связности – это класс эквивалентности,
то есть внутри компоненты у нас есть пути в обе стороны, по определению просто.
То есть есть такой путь, есть вот такой путь.
Ну, тогда извините, давайте спросим себя, а какая из этих переменных истина?
Точнее, какой из этих литералов истинный?
Мы же знаем, что p должно быть либо 0, либо 1 равно
вот в этом выполняющем наборе.
Вот чему оно равно?
Но понимаете, что если по едиplayful,
тогда при проходе по этим стрелкам не p тоже должно быть едицей.
Ну потому что вот я здесь заметил, что если я где-то ставлю единицу,
то все, что достижено по стрелкам, потому что должны быть истинные эkaции,
здесь тоже должно быть едицей.
Ну, противоречие – у меня не может быть переменных,
и отрицание переменных одновременно истинными.
И наоборот, если едиzenцвт 01 здесь в не p,
тогда при проходе по стрелкам получаем, что
p тоже должно быть едицей. Противоречие.
Ну, значит тогда никто из...
по и не по не может быть единицей, противоречие.
Так это было простую сторону, теперь обратно, почему
если вот это верно, то форма выполнима.
Значит, давайте я скажу следующее, давайте я рассмотрю произвольную
переменную, и здесь есть два варианта.
Сейчас посмотрим, кто из них больше, у кого одишник
больше, УП или УНИП.
Вот я скажу, что если УП-одишник больше, чем УНИП, тогда я
назначу переменную П в значении 1, а если меньше, то ноль.
Ну, я напишу так, давайте не П равно 1, то есть П равно
нулю.
То есть я рассматриваю вот эти две вершинки, переменные
и отрицания к переменной, и та из них, у кого больше
одишник, истинна, то есть в этом случае у меня УП-одишник
больше, я говорю, что П-истина, а здесь у НИП-одишник больше,
поэтому я говорю, что НИП равно 1, то есть у кого одишник
больше, то это истинный.
Вот, таким образом я задал какой-то набор в значении
всех переменных, но поскольку у меня для всех выполняется
либо это, либо это, нет равенств, то точно какой-то
набор в значении переменных, надо доказать, что выполняющий.
Покажем, что это выполняющий набор.
Вот, пусть не так, что значит, что этот набор не выполняющий?
Значит, вот наша коньюция не верна, коньюция скобок
не верна, то есть не верна как минимум одна из скобок,
то есть есть какая-то скобка вида х или у, которая на
этом наборе ложна.
Ну, что такое дизюнция ложная, значит х равно 0, у равно 0,
то есть в терминах вот этих одишников у х одишник
меньше, чем у не х, и у у одишник меньше, чем у у,
на idx меньше id не x, и idy меньше id не y.
Значит, здесь я не умоляю опшности, потому что под
x и y может сковаться не переменная, а, например,
отрицание переменной, тогда отрицание литерала,
значит, если там два отрицания, они съедаются.
Например, если у меня здесь было написано не х или
у, тогда мне здесь было бы написано не х, а здесь
не не х, то есть х.
Здесь как бы, это именно литералы могут быть, x и
y могут быть литералами, не обязательно переменными.
Ну, а дальше очень просто, значит, мы с вами знаем, что
если есть такая скобка, то у меня точно есть такие
вот ребра.
Из не х есть ребро в у, давайте я вот так вот нарисую,
из не у есть ребро в х.
Да, это я вот там нарисовал, что если есть такая скобочка,
то я провожу вот эти вот импликации, потому что
если не х, то должно быть верно у, если не у, то должно
быть верно х.
Но вместе с тем утверждением, которым я в начале лекции
вспомнил, я могу написать, значит, давайте, я уже забыл,
как оно формулируется, значит, айдишник в начале меньше,
чем в конце.
Ну да, да.
Значит, ну давайте напишем вот здесь, айди не х меньше
равно, чем конец этого ребра, айди вот у, так это утверждение
с левой доски.
Дальше.
По вот этому неравенству айди вот у строго меньше,
чем айди вот не у.
Дальше.
Есть ребро из не у в х.
Значит, здесь можно продолжить не строгое неравенство,
айди вот х.
Ну а и от х мы знаем, что строго меньше, чем айди
вот не х.
Все противоречия получили, что значение строго меньше,
чем оно же само.
Противоречия.
Нормально?
Так, все активно пишут.
Вопроски есть?
Хорошо, ну давайте еще раз повторю, да, то есть, если
у меня была форма вот такого вида, что в каждой
скупке два литерала всего через дизюнкцию идут, то
можно построить граф импликации, который равен населению
нашей формы.
Мне нужно, чтобы все импликации были верны и просто проверить,
что никакая перемена не попала своим отрицанием
в одно и то же КСС.
Если это верно, то вот, например, так можно выбрать
выполняющий набор.
Вот, ну и эта басата, она такая довольно полезная
задача.
Всюду, где у вас выборы с двух опций может быть,
да, ну там не знаю, например, у вас какая-нибудь задача
по каким-нибудь выключателю, что вы можете нажать на
выключатель или можете не нажимать на выключатель
и должно там что-то выполняться.
Тогда вы можете просто вести буливскую перемену
для каждого выключателя, типа, используете вы его
или нет, ну и написать там необходимые условия.
Если задача достаточно хорошая, да будет как раз
форма в виде 20, ну и вот 20 решить, собственно, таким
образом, как мы обсудили.
Так, следующий микросюжет – это эйлеровость.
Эйлеровые, ну эйлеровость пусть будет.
Ну пусть будет определение, что ли, не знаю.
Эйлеровым циклом в графе называется цикл, который
проходит по всем ребрам ровно по одному разу.
Цикл, проходящий по всем ребрам графа ровно один раз.
Ну давайте, сразу тярема, тярема один.
Так, сейчас.
Пусть ориентированный граф G слабосвязан.
Слабосвязан – это значит связан как неориентированный
граф после удаления стрелочек на ребрах.
То есть в ориентированном графе у меня все ребра имеют
начало и конец.
Вот, когда я говорю слабосвязан, значит я как бы отбрасываю
требования одностороннести, я могу ходить по ребру в
обе стороны.
Он будет связан, ну как обычный неориентированный
граф.
То есть любой вершин есть путь любой другой.
Так вот, пусть орг граф G слабосвязан после удаления
всех висячих вершин.
Висячие – это те, у которых, короче, вершины без ребер
вообще.
Без входящих, без исходящих.
То есть это вершины без ребер.
Вершины без ребер.
Вот.
Значит тогда это уже дает, что в таком графе существует
эйверов цикл, если только, если входная степень равная,
входящая степень равная исходящей до всех вершин.
Тогда в G есть эйверов цикл.
Ну как угодно, давайте напишу изолированную, если вам так
приятнее.
Да, вы правы, извините, мой косяк, да, изолированная,
да.
Это я с деревом перепутал, там действительно одно.
Да, изолированных.
Спасибо.
Да, спасибо, спасибо.
В G эйверов цикл, если только, если для любовью вершины
V.
Ну я картинку давайте нарисую.
Числов входящих равно числу исходящих.
Можно написать in degree равна out degree.
Вот.
Ну и второе, значит, все то же самое, только существует
эйверов путь.
Если это верно для всех вершин, кроме двух, ну а две
вот это вот как раз, то есть если у меня есть какое-то
начало пути и конец пути, то в начале, получается,
у меня должно быть на одно меньше входящее, а в конце
на одно меньше исходящее.
Так, ну давайте я вот это вот скопирую, да, CTRL-C, CTRL-V,
вот это вот все, то есть это общая преамбула.
Значит, тогда в G есть эйверов путь, если и только если
для всех вершин кроме двух выполняется вот это, а
для одной из оставшихся входная на одно меньше
входящее, а еще для последней оставшейся, значит, ну
наоборот, да, сейчас, давайте все напишем.
Значит, если и только если, неприятный слой, значит,
надо еще оставить в случае, если есть сам цикл, да.
Слабо связано, значит, связано после игнорирования
ориентации, то есть у меня ребра со стрелочками,
а если убираю стрелочку, то должен быть просто
слабо, ну как бы связан, как неориентированный граф.
Так, для всех V, для всех вершин кроме, возможно, двух,
вот так напишу, кроме, возможно, двух
вершин, выполняется требование про входную и выходную
степени, вот, ну а для двух оставшихся, для двух оставшихся,
ну там, короче, одно на один больше, другое на один
меньше, другое на один меньше.
В этом случае, например, плюс один, в другом случае
минус один.
Так, давайте я напишу не V только, а, например, S и T,
значит, indegree больше для конца, для точки T, и меньше
для точки S. Можно так сделать.
Не понял?
И не, еще раз, смотрите,
сейчас, сознательно две картинки всего может быть,
то есть у нас либо есть L-ров цикл, ну это он автоматически
путем является, и это вот этот вот случай, когда есть
цикл, соответственно, у всех indegree верну outdegree,
либо вот такая картинка, где есть две точки S и T
отдельно выделенные, у которых indegree и outdegree
вот так соотносят, то есть для S верно вот это, для
T верно вот это, а для всех остальных выполняется
все же самое, что indegree верну outdegree.
Вот, поэтому я тут написал, кроме, возможно, 2, то есть
возможно для всех верно, что вот эти вот равенство
соблюдается, когда есть просто цикл, вот, а иначе
должно быть максимум 2, и для них должно быть такое
соотношение верно.
Значит, ну, это уже, наверное, многие из вас видели, я
здесь подчеркну только вот это. Тут важно сказать,
что он связан просто удаление изолированных вершин,
потому что, если забыть про связанность и просто
требовать вот этой вот штуки, тогда, ну, у вас не обязательно
есть реверс цикл, потому что если вы нарисуете какие-нибудь
два треугольника просто вот таких вот, да, здесь у
всех indegree равно outdegree, но реверс цикла нет. Другой
вопрос, конечно, что можно все покрыть циклами, да,
то есть можно взять вот этот цикл и вот этот цикл,
и это будет покрытие всех реверс циклами, но это
все-таки не ailer цикл, потому что это все-таки один цикл
должен быть, а здесь их в два. Вот, поэтому если мы
хотим прям один цикл покрыть, то мне нужно, как бы, чтобы
все покрывалось, то есть чтобы была одна компонента
связанности в каком-то смысле, чтобы можно было
где-то начать, все пройти, где-то закончить и прям
все реверсы посетить. На, поэтому не забывайте, пожалуйста,
говорить, что у нас граф, типа, связанный. Связанность
будет в этом смысле, что он связанный после удаления
ориентации и всех изолированных вершин, потому что изолированные,
их не нужно посещать, и они мешают на пределе связанности,
потому что если бы сюда вот к треугольнику добавить
изолированную вершину, то у нас все равно есть в этом
граф иллеров цикл, то есть изолированная вершина
не мешает ничему.
Значит, это в случае неориентированных графов.
В случае ориентированных условия чуть проще, надо
просто требовать связанность, и чтобы у каждой вершины
была отчетная степень.
Значит, быстренько давайте запишем тирема два, пусть
G неорграф, G связан после удаления всех изолированных.
Тогда цикл в нем есть, иллеров цикл в нем есть, если все
степени четные.
Степени все совершенно четные, и уже есть иллеров
путь, если только есть степени всех, кроме, возможно, двух
Так, давайте это я доказывать не буду, оно будет автоматически
истинно.
Ну, смотрите, здесь требование слева-направо очевидно
в обоих случаях.
Давайте пункт А, когда есть иллеров цикл в орграфе.
Ну, как бы понятно, что как выглядят иллеров цикл.
Мы где-то начали, в какой-то точке S, как-то ходим, можем
куда-то заходить, где уже были, и заканчиваем там же,
где начали.
Ну, тогда понятно, что в каждую вершину мы как-бы
возможно многократно зашли и вышли, зашли и вышли,
поэтому каждый проход через вершину как бы использует
одно входное и одно исходящее ребро, одно входящее и одно
исходящее.
Поэтому у нее обязательно количество входящих равно
количество исходящих.
На IN degree равно OUT degree.
Ну, просто потому что цикл использует все ребра, то
есть мы все ребра учли, и при этом вошли в вершину
ровно столько раз, сколько вышли из нее.
Значит, суммарно для каждой вершины, количество вхождений равно количеству выходов из нее.
Это требование тривиально. Ну, пункт B, собственно,
тоже очевиден. Если у меня есть, что такое Эллеров путь, я это уже тут рисовал. Это либо
реально путь, то есть который начинается и заканчивается в разных вершинках, тогда выполняется вот это вот, на что есть две вершины, для которых
цикл, ну, понятно, indigree, audigree отличается на единицу. Либо это просто цикл, то есть цикл тоже является путем и
значит выполняется вообще условие пункта А, а значит тоже все хорошо.
Вот, теперь в обратную сторону, почему если верно вот это условие про степени,
то мы как-то найдем обязательно Эллеров путь, Эллеров цикл.
Давайте сначала пункт B мы сведем к пункту А,
проведя ребро из ТВС.
Тем самым я увеличу здесь indigree, а здесь audigree, и если было верно вот это вот, то есть, если у меня было две вершины, для которых выполнялись вот эти вот условия,
то я теперь увеличу indigree для S и audigree для T. Тем самым у меня у всех вершин выровняются indigree и audigree, входящие и сходящие степени.
И значит, граф будет уже удовлетворять условие пункта А.
Поэтому в нем достаточно будет найти Эллеров цикл, если мы найдем там Эллеров цикл и потом удалим ребро из ТВС, то у меня как раз получше Эллеров путь.
Потому что цикл это что такое, мы как-то там ходим, используем это ребро, все посещаем.
Теперь если я из цикла этого выкинул ребро из ТВС, то значит у меня получше просто некий путь из С в Т.
Значит мне достаточно научиться как-то конструктивно находить Эллеров цикл
в случае пункта А.
Вот, ну а вторая теорема, то есть это я сейчас делаю алгоритм предъявляем, а вторая теорема
собственно там такое же доказательство в этом пункте, да, то есть тривиальное следствие, если есть Эллеров цикл, то там очевидно все степени четные.
В обратную сторону тоже тот же самый алгоритм сгодится для того, чтобы найти цикл в графе с четными степенями.
Значит так, пункт А, справа налево.
Так, ну давайте игнорировать все изолированные вершины, давайте возьмем какую-нибудь вершину неизолированную, С.
И давайте из нее запустим
тупой ДФС. Что такое тупой ДФС? Это ДФС, который
не переисползывает ребра, ну потому что там нельзя использовать ребра дважды, но при этом ему
допустимо заходить в одну и ту же вершину несколько раз.
Например, если я нарисую что-нибудь вот такое,
то ДФС может работать так, значит мы сначала зашли сюда, потом сюда, потом вот здесь, вот потом вернулись сюда, это все еще
как бы рекурсивные запуски ДФСа, то есть мы из этой вершины опять запускаемся, находим этот путь,
доходим до сюда и вот тут завершаемся. В какой-то момент видим, что дошли до вершины, из нее уже нету как бы неиспользованных ребер.
То есть по факту такой ДФС
без запоминания, напишу в кавычках,
будьте здоровы,
без запоминания,
то есть мы можем как бы повторно запускаться ДФСом из вершин, где уже были.
Можем запускать ДФС
из вершин, где уже были.
Значит единственное надо запретить себе переиспользовать ребра, потому что в Эйлер вам цикле я должен все ребра использовать только единожды.
Мне нужно как-то в вершине, когда я нахожусь в вершине, научиться находить из него какое-то исходящее рядо, которое я еще не сделал.
Это можно делать, например, так, мы можем в каждой вершине завести некий
указатель или номер ребра, 就是 первого непросмотренного ребра.
И тогда когда я наступаю в вершину, то у меня уже внутри хранится первый неиспользованный ребро, то есть указатель на param neispoz infrastructure.
Я беру его и использую и сдвигаю тот указатель, который я только что использовал,
представьте себе вот какая-то вершина, есть исходящее ребра и мне говорят ты вот эти уже использовал, а вот это перв Онииспользованный.
тогда при запуске я сначала иду вот в это самое первое неиспользованное и
сдвигаю указатель вот сюда то есть теперь первое неиспользованное это вот
это очень простой значит очень простой алгоритм то есть можно какой-нибудь там
птр от вы поддерживать это либо указатель либо просто номер первого
неиспользованы ребра номер первого неиспользованного и ребра
ребра в жевать в на то есть если же от в список всех ребер исходящих то как
раз птр может просто нам указывать на первую неиспользована взяли использовала
рекурсивно выпустились вот отсюда то есть мы нашли его из в ту рекурсивно
запускаемся до фс мату и увеличиваем то есть перейдем как рекурсивно
запустится увеличиваем птр от вы то есть я делал плюс плюс птр от вы и
рекурсивно запускаю до фс от то
так вот давайте хоть примерно рисую еще по по интеллектуален чем тот например
может быть вот такой вот град так здесь конец от росток так ну еще какая-нибудь
здесь петля вот что давайте на примере посмотрим как только гритм работает
он может быть например так мы запускаемся до фс от с это произвольно старта
вершина в ней ничего особенного нет я как угодно выделил главное что мы была
неизолированная да значит я запускаюсь ну пусть например до фс обошел вот так
вот так вот так вот так вот так дошел до с видишь что из нее не осталось не
использованы хребр и в этом случае он он делает следующее он разворачивает
стек рекурсии то есть как бы ну проходит назад разворачивает рекурсию с конца
начала и все вот эти вот ребра которые он прошел добавляет в ответ ну как бы
вот с конца с конца в начало с права налево то есть я беру вот эти вот все
ребра в порядке от конца к началу добавляю ответ вот это вот добавил
ответ вот это добавил в ответ а дальше вижу вершину из которой дальше
продолжает работать потому что из нее есть не использованы ребра он берет и
запускает из этой вершинки до фс например он найдет что-нибудь вот такое
нашел вот такой вот цикл опять мы попали в ту же самую вершину из которой
теперь нет не использованный хребр я все ребра использовал поэтому в этом
случае я начинаю откатываться в стеке рекурсии до тех пор пока не дойдут до
вершины из которых есть не использованы ребра то есть я иду от наиболее свежих
ребр и наиболее старом и добавляю их в ответ ну как бы в конце да то есть они
будут идти вот в конце до шоу завершения опять вижу здесь есть
неиспользованные ребра, я беру их все использую и тут у меня ДФЗ заканчивается, опять нет ни
одному неиспользованного ребра, тогда в этом случае опять я раскрываю весь стейк рекурсии,
записываю все эти ребра в том порядке, в котором они шли у меня в стейк рекурсии, вот, ну и
соответственно здесь, да, здесь будет раскрытие стейка рекурсии, вплоть до самого начала я дойду,
до вышинки С, с которой начал, тогда смотрите, если я как бы, если я печатал эти ребра в том
порядке, в котором вот мой ДФЗ их раскрывал, то у меня будет как бы вот такой вот цикл, а вот,
вот такой вот, вот такой, ну естественно тогда надо просто его развернуть, потому что эти все
ребра были в противоположном порядке записаны, то есть я записывал, когда я нашел последнее ребро,
вот это вот ребро, я его как бы самым первым напечатал, потом вот это было предпоследним,
это предпоследним и так далее, вот, ну получается они просто в порядке с конца, с конца, с права
налево написаны короче, и чтобы восстановить правильный цикл, в нашем случае вот такой,
надо просто их с права налево все прочитать, вот, ну почему это работает всегда, потому что вот в
тот момент, когда я дошел до вершины, из которой нет исходящих ребер, такая вершина всегда единственная,
потому что смотрите, вот в самом начале я запустил ДФЗ от С, он что-то там походил, вот когда в первый
момент мы начинаем выводить ребра, когда мы впервые поняли, что нет новых неиспользованных ребер,
вот обязательно это должно было быть, когда мы дошли до С, потому что если я начал в С, как-то там
хожу, что-то использую, и пришел в вершину, из которой нет неиспользованных ребер, то это,
блядь, на С, ну потому что каждый раз, когда я захожу в вершину и выхожу из нее, я уменьшаю
IN Degree и OUT Degree на единицу, но если они всегда равны, если для всех вершин они одинаковые,
то есть момент времени, когда я могу дойти до вершины без исходящих ребер, это только С,
потому что если я вошел в какую-то другую вершинку, вот например в эту, тогда у нее я использовал одно
исходящее, значит у нее есть как минимум еще одно исходящее, потому что они равны, значит единственный
момент, когда я мог вот так вот зациклиться и не увидеть больше новых неиспользованных, это значит
я должен был дойти до вот этого С. Потом, значит, я этот цикл раскручиваю, опять вижу вершинку,
в которой, ну вот, то есть если я использую все то, что в стеке рекурсии и то, что уже напечатано,
то эта вершина единственная, у которой, ну у нее есть непросмотренные, неиспользованные ребра,
я вот так вот их запускаю, и опять, поскольку здесь я использовал только одно, то есть я начал,
по сути, искать цикл вот отсюда, из этой вершинки, то закончусь я обязательно именно вот здесь вот,
потому что это опять единственная вершина, у которой я использовал ребер на одно больше,
чем, то есть исходящих на одно больше, чем входящих, поэтому вот этот вот цикл опять-таки
замкнется вот здесь, и вот таким образом я все вот эти циклы как бы склею в одну большую цепочку.
Так, окей, вот, ну хорошо, так, значит это тогда мы сделали, пункт b, повторюсь, решается просто
добавлением вот такого ребра из tfs, то есть если я знаю, где должно начинаться, где должно
заканчиваться, просто по сравнению in degree и out degree, то я могу добавить одно ребро,
найти таким же алгоритмом Эйлеров цикл и удалить из него одно ребро из tfs, получив тем самым
Эйлеров путь. Вот, а в случае неориентированного графа все даже еще проще, потому что когда
ребра у меня неориентированы, то есть без вот этих вот стрелочек, мне даже не нужно будет в конце
разворачивать наш путь, то есть вот здесь, вот когда я строю Эйлеров цикл в ориентированном графе,
у меня ребра как бы они идут, ну вот в таком неправильном порядке, что сначала последнее ребро,
потом последнее, потом это среднее и так далее, а если бы они были неориентированными, то мне бы на
самом деле можно было бы считать, что это прям правильный порядок Эйлерового цикла, потому что
если здесь убрать ориентацию, то то что я прохожу, это тоже будет Эйлеров цикл, вот прям в этом
порядке, вот это, вот это, вот это, ну короче все эти ребра, это будет Эйлеров цикл после
игнорируемой ориентации. Ну и собственно все тогда даже можно будет не разворачивать в этот список,
то есть я могу просто печатать все эти ребра в том порядке, в котором я их нахожу в ДФС,
вот печатаю и это будет обязательно эйлеров цикл, который, ну то есть его можно пройти двумя способами,
вот я его как-то прошел, да там, справа налево, против всего стрелки, ну и он будет все равно
всем удовлетворять. Так, чего, давайте перерыв тогда. Я перехожу к ДФС в неориентированных графах,
сейчас поговорим про неориентированные еще графы. Ау, сценарий, ну сюжет типа того, да. Значит,
смотрите, здесь, в отличие от ориентированных графов, есть небольшое упрощение в том плане,
что, ну вот смотрите, давайте нарисую картинку в случае обычных ориентированных графов и в случае
неориентированных графов. Смотрите, в этом случае, если у меня ДФС идет как бы вот так вот влево,
то что он делает? Он покрасит эту вершинку в серый, эту в серый, эту в серый, потом отсюда,
ребер нет, он красит ее в черный, разворачивается, красит эту в черный, подошед сюда,
видит ребра в черную вершину. То есть в какой-то момент вот эта вершинка серая,
а это черная на грейблэк бывает ребров в черную а здесь причем как бы как бы это эта вершинка
как бы ниже находится на а здесь смотрите вот когда я иду опять-таки здесь слева по левой стороне то
я покрасил эту шинку в серый эту серый эту серый и вижу как то есть вот это вот ребро я просматриваю
как бы при просмотре снизу вверх уже и это будет как бы ребро между серой и серой да то есть и
серой серая такие ребра уже как бы мы знаем это показали того что этот цикл мы помним что
ребро в серую это как бы цикл и в общем в неориентированном графе как раз проблема здесь
в том что это ребро ориентирован сверху вниз и как бы я не нахожу цикла вот при таком проходе
потому что как бы нету снизу вверх а здесь оно есть снизу вверх вот поэтому в неориентированных
графах мне даже не столько нужны вот эти вот цвета белый серый и черный мне достаточно будет
просто знать бывал я в вершине когда-то или нет потому что если я вижу что я в вершине бывал то
мне не важно какая она серая или черная да потому что это все равно значит что как бы у меня нашелся
цикл поэтому вместо цветов вместо цветов просто храним метки посещенности
метки посещенности ну вот там можно считать что какой-нибудь вектор был
юст тру если мы вершинку когда-то уже заходили в полце если еще никогда не заходили вот и тогда
dfs обычный да переписывается просто так что вместо проставления цветов white соответственно gray и
black я изначально говорю что все юзды это false а потом когда я захожу в вершину я ставлю в ней
юст равно true то есть у меня изначально здесь все false вот а когда я пишу dfs
значит я не помню я вот здесь передавал parent или нет не передавал хорошо давайте давайте тогда
не буду передавать значит я записываю что юст от в равно true то есть зашел сразу использовал
то есть это как бы пометка на серое или черное можно считать что true это значит
серая или черный вершин вот дальше там как обычно если надо проставляю всякие тыны
вот вроде все здесь больше ничего не нужно перебираем все исходящие ребра
и запускаем dfs только тех решений где еще не были то есть если это вершина белая если она еще не юст
тогда dfs отту вот что-то примерно такое да там еще всякие да вот можно писать но не буду не
буду писать что мы можем просто отказаться от цветов и использовать только вот эти вот
меточки true или false значит давайте еще нарисую какую-нибудь картинку побольше
вот сейчас вот например есть такой граф пунктирные рёбра тоже есть давайте их
слабенькими нарисую они они тоже есть графе но по ним dfs как бы ходить не будет значит как может
быть как работает dfs мы начинаем здесь спускаемся вот поэтому репорт давайте я на ребре нарисую
ориентацию это означает что я его прошел в dfs то есть я взял и dfs прошел вот отсюда сюда то есть
я находясь в верхней вершине запустился dfs от нижней за прошел вот сюда потом нашел вот до
сюда все здесь больше никаких ребер нету внизу рекурсия поднимается сюда потом идет например вот
сюда здесь вот сюда видит в этот момент времени смотрите он увидел ребро снизу вверх вот такие
рёбра которые ведутся внизу вверх я буду называть обратными обратное ребро то есть это такое ребро
которое я вот здесь вот не рассматривал потому что она ведет уже использованную вершинку да то
есть оно ведет уже уже юзанную вершину где юз равно труп потому что она посещена раньше там юз
равно труп вот ну значит здесь дальше поднимаюсь выше те вот эти вот ребра назначаю древесными то
есть у них их ориентирую сверху вниз вот дальше рекурсия поднимается видит еще например вот это
вот одно ребро снизу вверх оно тоже будет обратным да но она как бы ведет вот в противоположном
направлении как бы снизу вверх меня ведет но будет тоже обратная его никак не использую просто
ну если чё вот вижу обратные бро да например если мне нужно было бы узнать есть ли цикл в графе я
мог бы по наличию вот такого обратного ребра понять что он есть если я вижу такой ребро значит
есть цикл поднимаюсь вот да то есть здесь дфс все обошел рекурсия развернулась вернулась сюда
смотрите вот в этот момент мы еще например еще раз видим вот это вот ребро которая как бы обратная
то есть мы вот это обратное ребро увидели дважды снизу вверх и сверху вниз но на оба раза
прогнарируется потому что к моменту когда я нахожусь здесь и вижу это ребро этой вышины уже
использована вот ну дальше там пошел пошел наверх здесь все ориентировал увидел еще одно обратное
ребро ну и собственно собственно это он в ход закончил и того смотрите мораль какая у меня есть
на самом деле всего два типа ребер древесные это вот те которые я обхожу сверху вниз в процессе нашего
древесные ребра и обратное причем обратное я как бы два раза смотрю я на обратной смотрю когда
я нахожусь внизу и смотрю вверх и когда нахожусь сверху и смотрю вниз поэтому надо это иногда
учитывать аккуратно понимать что если я вижу ребро в вершинку который уже юст написан до
которой у которой уже использована тут либо ребро сверху не слили бы брос внизу вверх это надо
всегда всегда помнить что ну короче где мы находимся на вот тут или тут это на самом деле
довольно легко отследить потому что если вы например проставляете вот эти вот т.ин. и то
по соотношению на т.ин. и в этих двух концах мы сразу можем понять кто из них лежит выше а кто
ниже потому что понятно что если вышина выше то у нее т.ин. меньше а если ниже тут и больше поэтому
если мы видим обратное ребро то понять какого оно типа вверх или вниз да то есть я его вот отсюда
вижу или вот отсюда вижу на сверху вниз или сниз вверх я могу просто сравнить т.ин. у этих
двух вершин x и y вот и там где меньше там собственно начало вот здесь будет т.ин. от x меньше то есть
это ребро будет сверху вниз а если если я нахожусь в игреке то есть т.ин. от y больше чем т.ин. от x то
я вижу вот этот как раз ребро снизу вверх вот но и главное еще что можно что можно сказать что у
меня не бывает вот таких вот перекрестных ребер как бы между под деревьями потому что вот ну
например если бы такое ребро у меня было то есть представьте что у меня есть такой граф есть такое
ребро когда я бы на самом деле вот в процессе обхода вот этого dfs слева в левом под деревья
я на самом деле и вот до сюда бы тоже дошел и все вот это вот на самом деле как бы было подвешено
вот сюда то есть вот это вот все вот это вот все на самом деле висело бы где-то вот здесь если
такой ребро есть вот поэтому таких ребер вот перекрестных между двумя разными под деревьями
не бывает все ребра это либо прямые древесные ребра сверху вниз которые я в dfs обхожу либо
обратные когда я поднимаюсь в одного из предков то есть на самом деле в одну из вершин которые
в стеке рекурсии лежат то есть я спускаю сверху вниз вот они у меня все лежали на стеке стек
рекурсии и обратное ребро может вести только в одну из вершин на в этом стеке то есть в одного
из предков в этом дереве вот таких перекрестных ребер не бывает вот хорошо хорошо еще там и сказали
теперь самая такая наверное популярная датчика про неориентированные графы это поиск мостов
значит определение уже это связанный граф связанный не ориентированный граф
тогда
ребро г называется мостом
если после его удаления граф перестает быть связан я напишу так ли ни во же минус я не связан
например какая-нибудь вот такая вот картинка два треугольника с перемычкой вот это ребро мост
потому что изначально граф связан если его удали то граф становится да он распадается на две
компоненты связанности становится не связан вот ну и второе определение здесь же опять-таки пусть
же связанный граф связанный не ориентированный граф тогда вершина в называется точка сочленения
так ну тут по-английски как-то лаконичней получается cutpoint тут cutpoint но здесь
соответственно бридж так и есть значит точка сочленения если но аналогично ее
удаление из графа увеличивает делать граф не связан если же минус в не связан
вот тут поинтереснее пример это когда два треугольника зацеплены по вершинке
такой граф тогда вот это точка и точку сочленения потому что если ее если убрать но понятно что
когда удаляю вершину я также удаляю все ребра которые ей инцидент на то есть я удаю не
только точку но и собственно все вот эти вот ребра все эти 12-فр Está понятно что graph
распадается на две компоненты связанности вот это и вот это ну и собственно вопрос который
естественно себе поставить, это найдите, пожалуйста, все мосты, все точки соединения.
Весьма полезная штука, потому что многие коммуникационные сети моделируются как раз в виде графов,
то есть если у вас в вершинках какие-то клиенты, какие-то агенты, которые могут между собой общаться,
а ребра — это каналы взаимодействия, то вот мосты — это те каналы, удаление которых делает вашу сеть
не связано, то есть как раз вам нужно хоть расшибиться, но уметь поддерживать отказ
за устойчивость этого канала, потому что если он сломается, то вы не можете передать информацию отсюда
и сюда вообще никак, поэтому, наверное, вам надо особенно сфокусироваться на мостах, вам нужно,
чтобы они всегда работали. То же самое с точками сочленения, если у вас как-нибудь клиенты
вот так вот общаются, вот эти два между собой через него, то вам надо, чтобы этот клиент был
достаточно мощным, чтобы он умел все вот эти запросы передавать, потому что если он откажет,
то они между собой уже никак не свяжутся. Ну, давайте тогда найдем все мосты точек сочленения в графе.
Так.
Для этого мне понадобится следующая довольно нехитрая динамика. Смотрите, я хочу для каждой
вершины V ввести следующую функцию red от V. Какой смысл у этой штуки? Вот представьте себе,
что мы запустили какой-то DFS в нашем графе, он как-то, соответственно, там ориентировал все
ребра, древесные ребра ориентировал сверху вниз, обратные ребра не ориентировал, но они как бы идут
снизу вверх, мы считаем. Вот, значит, вот тут есть что-то достижимое из V под древесным ребром. Вот это
вот все как бы под дерево, все что ниже V лежит. В качестве red от V я хочу брать самую высокую
вершину, которая достижима вот отсюда прыжком по одному обратному ребру. То есть я могу сначала
из V куда-то вниз спуститься, потом взять и прыгнуть вверх по обратному ребру. Вот из всех таких
прыжков вверх я хочу выбрать самый высокий. То есть, например, отсюда я могу прыгнуть сюда,
отсюда вот сюда и отсюда вот туда. Тогда из всех этих прыжков я хочу выбрать вот этот самый высокий.
Ну а самый высокий — это, понятное дело, вершина с минимальным TIN, потому что все они ведут ну вот
куда-то куда-то сюда, то есть в стек-рекурсе в момент времени входа в V, то есть это как бы родитель
V или дедушка V или как бы прадедушка V и так далее, и они все понятны упорядочным по TIN,
потому что как раз TIN как раз сверху внизу не идет. Поэтому я могу написать формально следующее — это
минимум из. Во-первых, я напишу TIN от V это на случай, если я выше, чем V, прыгнуть никуда не могу. То
есть у меня, например, есть какое-то вот такое вот ребро до V, но выше, то есть вот этих вот всех
ребер нету. Выше, чем V я прыгнуть, например, не могу. Тогда мне нужен TIN от V здесь оставить. Вот.
Либо же это минимум по всем. Так, давайте я напишу WU — ребро графа таким, что W лежит в поддереве V.
Поддереве V, а WU — это обратное ребро. Обратное ребро. И по ним по всем нужно взять минимальный TIN
от U. То есть если здесь вести буковки, то я сначала спускаюсь от V куда-то до W и потом
одним прыжком прыгаю до U. Вот. Из всех таких вот прыжков с помощью одного обратного ребра нужно
взять самый высокий, то есть U с минимальным TIN. Поэтому я здесь беру минимум по TIN. Так,
вот это согласуется с тем, что я описал словами? Хорошо. Представьте, что мы это как-то насчитали.
То есть в каком-то смысле я знаю, как высоко я могу из каждого под дерево прыгнуть. Вот если
у меня есть V, то из всего, что вот как бы ниже, да, из всего, что достижено под ревесным ребром,
я знаю, как высоко я могу прыгнуть, используя один прыжок назад, то есть используя одно
обратное ребро вверх. Значит тогда, простое утверждение следующее. Ребро E является мостом,
если и только если, во-первых, оно древесное, то есть это ребро, который мы прошли в DFS. То есть
какое-то ребро сверху вниз, ну давайте я его назову там УВ, ВТУ. То есть вот такое вот ребро
должно быть. И во-вторых, должно быть одновременно выполнено, что вот отсюда я не могу прыгнуть выше,
чем ТУ. Это можно написать так. Ред от ТУ равно ТИ на ТУ. Вот, то есть на картинке, если у меня есть
древесное ребро из ВТУ, проверить то, что оно является мостом, можно так. Надо посмотреть на все
вот это вот под дерево, то есть все, что достижено из ТУ, и надо понять, что отсюда нельзя прыгнуть
выше, чем до ТУ. Потому что ред от ТУ это самый высокий прыжок, самый высокий прыжок вверх. И
получается, что, смотрите, я могу допрыгнуть до ТУ, то есть, ну, например, там как-нибудь вот так вот,
но выше не могу. Это значит, нет ни одного ребра ни сюда, ни куда-то еще выше. То есть вот таких
ребер нету. Ну тогда автоматически, значит, удаление этого ребра это мост. Ну, точнее, удаление
ребра делает граф несвязан. Собственно, я практически все проговорил, давайте немножечко напишем
здесь. Доказать. Ну что, слева направо. Значит, во-первых, очевидно оно древесное,
недревесные ребра мостами быть не могут, потому что если ребро недревесное, значит его ДФС,
ну, как будто бы не увидел. То есть он шел сверху вниз. Все, что он достиг, он достиг с помощью древесных
ребер, те, которые ориентировал сверху вниз. А обратные ребра, они как бы, ну, они с связанности
не помогали. Они это какие-то ребра снизу вверх. Понятно тогда, что это ребро мостом быть не может,
потому что его удаление на связанность никак не влияет. Мы его что-то раньше не видели в ДФС,
что теперь не будем видеть. Поэтому как бы недревесным оно быть не может. Чтобы быть мостом,
оно обязано было быть просмотрено в ДФС. Значит, очевидно, иначе граф останется связанным
под ревесным ребром. Так, второе. Значит, почему верно вот то вот равенство. Ну, что значит,
что ВТУ это мост. Это значит, что после его удаления у меня пропадает путь между ВТУ. То есть
раньше у меня был между ними путь, между ВТУ у меня есть ребро. А теперь после удаления оно
должно пропасть. Ну, потому что если путь между ВТУ сохранится, то значит и вся связанность
сохранится. Если как бы я удалил ребро между вершинами и между ними остался какой-то путь
вот такой, то очевидно связанность у тебя все как бы сохранилась. У меня связанность тогда,
получается, сохраняется вся. Значит, у меня должен пропасть путь из ВТУ. То есть если я
нарисую вот это вот под дерево ТУ, то есть то, что достижено из ТУ под ревесным ребром и все
остальное, все, что находится выше, у меня между ними не должно быть никаких ребер. Ну, то есть,
соответственно, вот из этого под дерево нет ни одного вот такого вот ребра в ВТУ или куда-то
выше. То есть таких обратных ребер нету. Значит, все обратные ребра, которые здесь есть, они либо
сюда вот ведут, либо еще вообще куда-то ниже. Поэтому самый высокий прыжок, доступный из этого
под дерево, он ведет в сущность в ТУ. Потому что иначе у меня была бы связанность. Вот,
значит, в одну сторону. Ну, в обратную как бы все аналогично. Значит, если у меня есть древесное
ребро вот с этим вот равенством. Ну, давайте просто перерисую. Надо еще что-то говорить. Нет,
вроде уже все и так сказал. Ну, собственно, да, единственный способ, как у меня может сохраниться
связанность после удаления этого ребра, это только что из вот этого под дерево я должен как-то
прыгнуть вот сюда. То есть должно быть вот такое какое-то ребро. Ну, мы знаем, что такое ребро это
ребро из под дерева ТУ куда-то вверх. Значит, это обязательно ребро, которое я должен просмотреть при
вот этом определении ред. И у него ТИН обязательно должен быть меньше, потому что такое ребро обязательно
ведет куда-то на самом деле в предка. То есть, ну, от корня, откуда мы запустились, то есть это ребро
куда-то вот до сюда. Оно ведет в одного из предков вершины ТУ. Ну, а поскольку самый высокий прыжок
доступный это только в ТУ, то значит в ТУ это обязательно мост. Ну, потому что вот этой вот
связанности мы никак уже не обеспечим. Ну, короче, то же самое сказал. Тут вопрос есть по корректности
вот этого критерия? Хорошо. Так, это с мостами. Теперь давайте точку слинения сначала тоже критерий
выведем и потом напишем, как именно этот ред насчитывать. Вершина В является точкой слинии,
если верно, одной из двух. Либо В это корень, то есть мы из него запускали внешний ДФС. В это корень,
и при этом из В есть хотя бы два древесных ребра. Из В исходит хотя бы два древесных ребра.
Либо же второй вариант В не корень, но есть какое-то древесное ребро из В в ТУ. Но есть древесное
ребро из В в ТУ такое, что ред от ТУ больше либо равно ТИ на ТВ. То есть самое высокое,
куда мы можем прыгнуть из этого поддерева, это только ТУ. Ну, или даже, возможно, sorry,
это только В или даже, возможно, ТУ. То есть самое высокое, куда я могу прыгнуть из этого поддерева,
это В или даже ниже. Тогда В это точка слининия. Так, ну, я, наверное, докажу, что, не буду доказывать
такую эквивалентность, я докажу, что первое, докажу, что если В это корень, то факт того,
что это точка слининия равносильна тому, что есть два древесных сходящих ребра. Ну, по факту это
пункт 1. Вот, смотрите, пусть В это корень, то есть это вершина, из которой запускается внешний
ДФС. Вот мы из мейна или из какой-то решающей функции запускаем ДФС от вершинки В, под стартовой
вершинке. Она все обходит, да, как-нибудь там еще насчитала вот эти вот реты, все таины. И
так оказалось, что вот у В есть несколько исходящих древесных ребер. Либо одно, либо хотя бы два.
Несколько. Ну, если ноль, то неинтересно. Это тогда просто изолированная вершина. Вот понятно,
что если одно ребро исходящее, то получается, что я взял в самом начале, нашел какое-то ребро,
запустил рекурсивно ДФСом отсюда и обошел вообще все. Я обошел вообще все достижимые
вершины, потому что иначе, если было бы что-то недостижимое, то вот здесь что-то было бы
недостижимое, я должен был туда прыгнуть бы из В. Но таких ребер нет. То есть если у меня одно
исходящее ребро, то получается я взял, с его помощью дошел до куда-то, и из конца этого ребра дошел до
всех остальных вершин. Значит В, понятное дело, не точка соширения, потому что вот я ее удаляю,
граф остается связанным, вот здесь все связанности сохраняются. Если у В всего одно исходящее древесное
ребро, то В это не точка соширения. А если хотя бы два исходящих ребра, то это уже гарантирована
точка соширения, потому что как может быть из корня два исходящих ребра. Вот я вот здесь начинаю,
как работает ДФС. Он посещает все, что можно. Лемма в белых путях, туда-сюда. Все, что было
достижимо по белым путям, все достижимо. То есть если все достигнется, если я спускаюсь по ребру
и потом здесь обхожу все, что достижимо, а потом мне нужно подняться и еще что-то обойти, значит
вот отсюда до сюда я никак не пройду без В. То есть я спустился по первому ребру, здесь обошел все,
что можно, но что-то не обошел. Отсюда до сюда никак без В я не попаду. Вот таких ребер у меня нету.
Таких ребер нету. Ну значит получается В автоматически точка соширения, потому что после ее удаления
между этими вот вершинками нет пути. Наоборот, если у В хотя бы два исходящих древесных ребра,
то В это точка соширения. Мы с корнем разобрались. Какие ребра мы назначили древесными? То есть мы
знаем, какие ребра мы назначили древесными, значит мы можем понять корень является точка соширения.
Так, ну теперь второй кейс, когда В это не корень.
Это пункт два. Раз В не корень, значит у него есть родитель в нашем дереве ДФС. Вот есть В,
есть вершина, из которой мы непосредственно в В пришли. То есть вот есть какой-то родитель
П такой, что П В это древесное ребро. То есть я сначала от корня дошел до П, потом из П
рекурсивно запустился в В. На вот есть такое ребро. Дальше, значит у меня надо сказать,
что В это точка соширения есть ли есть какое-то такое ребро. Ну хорошо, надо рассмотреть два
случая. Когда есть такое ребро исходящее, вот совсем неравенство, и когда такого нет. Вот видите,
первый случай, когда такое ребро есть. Вот пусть есть какое-то древесное ребро в ВТУ. Такое,
что ред от ТУ больше равно ТИ на ТВ. Ну тогда вроде понятно, что В это точка соширения,
потому что после ее удаления у меня пропадает путь между ТУ и П. Потому что вот что, что
означает это неравенство? Это значит, что из всего вот этого поддерева, то есть из всей вот этой вот
компонентно-связанности после удаления В, я не могу прыгнуть никуда кроме как сюда или сюда. То
есть по факту все обратные ребра из вот этого поддерева вели либо В, либо вообще оставались
внутри этого поддерева. Вот это вот неравенство означает, что не куда выше, чем В я прыгнуть не
могу. Самое высокое это только В или даже ниже. Ну значит, после удаления В у меня вот это все
поддерево остается компонентно-связанности, из которой я никуда перепрыгнуть уже не могу. То есть
не сюда не могу да потому что если было такое ребро у меня было бы здесь неравенство меньше
ну и так далее короче я из этого по дереву никуда не выберусь поэтому в этом случае обязательно в
эту точку сшли так как пропадает путь между ту и п пропадает путь тупая вот значит это
да существует pega с таким не равенствует существует и такими раменстве теперь второй
случае когда его не существует надо задать тогда в не точка сшли но вот что за что не существует
значит для любого ту для любого сына у меня это мер avons что выполняется в обратную сторону то
есть если вот это вот скажем ну давайте ихemás 1 у 2 и так далее ука для них для всех RED от Уит Halloween
строго меньше, чем tn от v. Надо тогда показать, что удаление v не нарушает связности. Вот. Ну,
чего? Удаление v не нарушает связанности. Что означает вот это неравенство? Это значит,
что из любого поддерева, у 1, у 2 и так далее, у к, из всех поддеревьев есть обратное ребро,
ведучие в p или выше. Потому что раз ред строго меньше, чем tn от v, значит мы можем прыгнуть
куда-то выше, чем v. Строго меньше, значит мы можем прыгнуть строго выше. То есть всегда есть
обратное ребро куда-то сюда или даже еще выше, куда-нибудь выше. Тогда после удаления v,
давайте представим, что я v удаляю, я удалил v и все вот эти вот ребра. Ну, тогда связанность у
меня хранилась, потому что из каждого поддерева я могу прыгнуть куда-то высоко, ну и потом,
если надо. Например, может быть такое, что у меня вот есть такой длинный путь и у меня есть вот
такое вот обратное ребро, вот такое обратное ребро. Тогда я могу из этого поддетего сначала
прыгнуть сюда высоко, потом дойти до p. Получается, что я сохранил связанность между этим поддеревом
и вершинкой p. Ну тоже самое для всех остальных поддеревьев, есть какой-то прыжок достаточно
высоко, и потом, если что, его можно спуститься до p, тем самым сохраняется связанность любого
под дерево и p. А если все связанности сохранились, то значит у меня связанности не исчезло.
Поэтому в этом случае v не точек осуществления. Согласны? Ну все, значит мы вывели критерий в
терминах этого red. Осталось написать алгоритм, который все эти red насчитает, и тогда я уже все
ребра умею проверять, на то являются они мостами или нет, и все вершины, на то являются они точкой
насчления или нет. Так, давайте его сделаем быстренько. Алгоритм нахождения red.
Алгоритм нахождения red. Он очень простой и устроен следующим образом. Смотрите,
у меня из каждой вершины, когда я попадаю в вершинку v, интересных ребер всего две
категории. Это либо древесные ребра, которые мы с помощью DFS проходим сверху вниз, и обратные
ребра, ведущие куда-то наверх. Значит куда-нибудь в u. Тогда как достигается red от u? Я утверждаю,
что это надо либо сразу прыгнуть по обратному ребру, то есть даже никуда вниз не спускаться.
Я сейчас хочу найти red от v. Тогда это либо мне нужно сразу прыгнуть наверх по обратному ребру,
никуда вниз не спускаясь, просто вижу обратно и сразу прыгаю по нему. Это один из возможных
способов. Либо мне нужно сначала куда-то спуститься в одно из поддеревьев и в нем прыгнуть наверх. То
есть я сначала куда-то спускаюсь и там беру red от, собственно, вот этой вершинки. Потому что,
если я хочу сначала куда-то спуститься, я выбираю, в какой из поддеревьев я спускаюсь,
например, вот сюда. И если я здесь знаю уже корректное значение red от u, то я, получается,
знаю, насколько высоко я могу прыгнуть из всего этого поддерева. То есть я знаю какой-то такой
прыжок. Может куда-то еще выше ведет. Поэтому мне нужно просто все вот эти вот red'ы просмотреть
и выбрать из них самый высокий, самый маленький. Из всех вот этих red'ов, которые я уже посчитал,
рекурсивно, нужно выбрать просто самый маленький. Ну, собственно, все. Просто все прыжки я таким
образом рассмотрю, потому что они либо сразу вверх, либо сначала в какое-то поддерево спускаются и
оттуда уже прыгут вверх, используя вот этот уже найденный red. Давайте я напишу то, что мне нужно.
Ну, я какие-то строчки опускаю, то есть там я юст опущу, я напишу только самое интересное.
Во-первых, мне, конечно, нужен tein, потому что я по нему определяю, какая вершинка выше,
какая вершинка ниже. Изначально я говорю, что red от v это tein от v,
потому что можно стоять на месте, и это уже какой-то прыжок вверх. Дальше перебираем все вершины.
И, значит, если я вижу прямое древесное ребро, если вижу древесное ребро, давайте я словами напишу,
если v2 это древесное ребро. Ну, в коде это означает, что не юст ату, не юст ату, потому что как раз
древесное это то, которое ведет в непосещенную вершинку, то есть там как раз-таки, где юст
еще стоит false. Вот, значит, если я вижу древесное ребро, то я сначала запускаюсь,
давайте я вот так вот хотя бы сделаю, то я сначала запускаюсь рекурсивным dfs,
и потом мой red обновляю через вот этот red. red от v равно минимум из red от v и red от tu.
Это вот этот случай, что я сначала использую древесное ребро, там рекурсивно, то есть я
считаю, что рекурсивный запуск dfs от tu мне рекурсивно правильно нашел red от tu, и после
этого я red от v обновляю через red от tu. Вот, но иначе, если же я вижу обратное ребро, обратное
ребро вверх, то есть как раз вот такое, что я из v могу сразу прыгнуть наверх, тогда нужно
просто обновить red от v через tu и tu. red от v, минимум из red от v и tu и tu. Все.
Да, секунду. Правильное замечание, да. Ну, потому что в каком-то смысле вот это вот ребро родителя,
это обратное древесное ребро. Можно по-разному это сделать. Ну, давайте вот здесь вот подпишу,
не в родителя, обратное ребро вверх, не в родителя. То есть это как бы в плане реализации
я подчеркиваю, в плане описания вот это вот ребро, которое я вижу, то есть если я прошел по
древесному ребру сверху вниз, в этой вершинке я в частности тоже вижу вот это вот ребро,
которое меня ведет в родителя. Я это ребро всегда-всегда игнорирую, потому что это типа обратное
древесное ребро. То есть я это ребро уже ориентировал как бы сверху вниз, понятно, что снизу вверх я
по нему пройти уже не могу. Но с точки зрения кода мы же на самом деле не вводим ориентацию на
ребрах, мы там не удаляем вот это вот обратное ребро снизу вверх, то есть отсюда сюда. Но как бы надо
проследить, что если я вижу ребро в родителя, то я его просто игнорирую, потому что ребро в родителя
это то ребро, с помощью которого я только что пришел. Его нужно вообще игнорировать, оно ни на что
не влияет. То есть вот можно было бы вот здесь вот написать, что если ту это родитель в,
то просто continue. Вот, тогда жизнь была бы проще, потому что такие ребра я уже сразу отсек. И дальше
как раз остается только древесное сверху вниз, либо обратное, но опять повторюсь, обратное у меня
бывают вверх и вниз, потому что находясь скажем где-нибудь вот здесь, я мог бы его увидеть вверх,
а находясь здесь я его увижу вниз. Ну как бы можно вести, можно добавить это условие, что я
рассматриваю только обратный вверх, потому что если нахожусь здесь и вижу вот это вот обратное
ребро вниз, то оно на самом деле ни на что не повлияет. Здесь и так будет ред меньше, чем здесь.
То есть это можно не проверять, но как бы для красоты лучше вот такие вот ребра сверху вниз вообще
тоже не смотреть. Обратный сверху вниз мы тоже пропускаем. Так, ну все. Значит мы с вами все реды
насчитали, мы с вами знаем, мы ориентировали как бы все ребра, мы знаем кто из них древесный и кто
нет. И дальше просто вот есть два критерия, с их помощью можно проверять ребра на мосты и точке
слинии и вершины на точке слинии. Вот так все, спасибо.
