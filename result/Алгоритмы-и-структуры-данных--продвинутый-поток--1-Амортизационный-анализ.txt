Так, смотрите, напоминаю, что по первым, так сказать,
нескольким задачам дедлайна у нас через неделю и сразу
приятная новость, туда будет добавлена еще одна задачка.
С тем же дедлайном?
Да.
Ну, скажем так, я ее в принципе даже могу сформулировать.
Смотрите, рекуррента будет немножко экзотического
вида.
Да, и смотрите какая.
Значит, рекуррента будет выглядеть так, t от m равно,
я запишу в таком виде, t от m плюс t от n минус m плюс,
ну скажем, 1, зачем-то непонятно, ну ладно, плюс логарифом
минимума от m и n минус m, где, я так напишу, m равно
m от n, значит это тоже целое число там будет подразумеваться
и, соответственно, m будет лежать от 1 до n минус 1.
Ну, то есть это означает, что, ну то есть смотрите,
что m будет зависеть от n, то есть скажем так, для n
равно 7, m будет равно 2, там для n равно там 19, m будет
равно, ну допустим там 18.
А вот не важно как, вот есть такое ограничение, что
для каждого n, значит m от n будет лежать на отрезке
от 1 до n минус 1, то есть по сути n тут разбивается
на два слагаемых.
Какая же дичь.
Это целое число, целое число на отрезке от 1 до n
минус 1.
Ну, совсем переписывать не обязательно, просто
потому, что как бы у вас в ДЗ это все будет сформулировано.
Ой, так, у меня опять очки развалились, ай, началось,
что такое, да ладно.
Правильно ли я понял, что можно даже не смотреть,
только все остальные значения решены?
Нет, в смысле, ну почему?
Потому что это дичь какая-то.
Нет, ну скажем так, это не дичь, потому что с этой
рекуррентой, когда мы будем изучать софт хип, мы реально
столкнемся, просто она нам будет жизненно необходима.
То есть вот поэтому…
Какая гадость.
Поэтому знаете, что как бы, поэтому хочется подготовиться.
Так, а где этот болтик-то?
Так, а, то есть классно, я сегодня без очков, отлично.
Так, ну что делать?
Что делать?
Ладно.
А, ну или вот, знаете, вот так вот.
Буду вот так вот на вас смотреть.
Вот так вот, да.
Да.
Или вот так.
Ну ладно.
А, вот это?
Ой, спасибо огромное, отлично.
Значит, я тогда потом разберусь.
Так, окей.
Ладно.
Вот.
Ну, в принципе, вот такая рекуррента.
На самом деле, то есть честно скажу, значит, на будущее
можно по идее ради интереса задуматься, что вместо
атома тут может стоять, ну вот, практически что угодно
с точки зрения результата.
Вот.
То есть на самом деле, у движения, что если я тут
логарифм заменю, скажем, на корень, или там на что-нибудь
еще не сильно линейное, то есть желательно там меньше,
чем линейное, то результат скорее всего будет одним
и тем же.
Ладно, не буду пока говорить какой, но думаю вы и так
догадываетесь.
Вот.
Нет, не М, но как бы задача будет решить ТАТ.
То есть утверждение, что у ТАТ на всем точка от конкретного
М зависеть не будет.
Вот так вот.
Ну вот.
Ну вот такая рекуррента.
Как это, да.
То есть ну на самом деле так, два момента, да, типичная
ситуация, да, в этом курсе мы будем много решать задачи,
а зачем нам это надо вообще.
Вот.
Да.
Ну вот иногда у нас присутствует в курсе такая проблема,
но на самом деле я объясню откуда она берется.
То есть, ну дело в том, что, ну то есть так, да, то есть
софтхип, конечно, объяснять не буду, но будет теперь
такая ситуация, что, предположим, что у вас есть там, допустим,
некоторое дерево.
Двоичное.
И не просто двоичное дерево, а как бы каждое вот это разбиение
на два, оно символизирует то, что у вас тут вот множество
разбивается на два.
Вот на M и на N минус M.
Изначально там N элементов, ну и там в каждом листе
там один элемент.
То есть вот они как-то тут по какому-то графику то
ли объединяются, то ли наоборот разъединяются.
Но фишка в том, что в каждой вершине для этого объединения
вы выполняете вот какое-то заданное число действий.
Вот такое.
И вам жутко интересно, а сколько этих действий суммарно.
И вот оказывается, что если при объединении двух множеств
вы тратите вот такое время, то есть, внимание, логарифм
минимума размеров, то вот оказывается, что суммарно
тогда это все объединение работает за, скажем аккуратно,
очень приятную симптомику.
Что?
Ну не совсем.
Не совсем.
Переливайка была бы.
Переливайка была бы.
Нет, ну не совсем.
Смотрите, классические переливайки на самом деле
вот в этом месте написано что-то типа
минимум m и n минуты с m на логарифм
то ли максимума, то ли n скорее.
А здесь просто логарифм.
Вот тогда.
Тогда бы получался лог квадрат.
А здесь обратите внимание, просто логарифм это важно.
Ну мало ли, потому что там будет у нас какой-нибудь
двусвязанный, там какой-нибудь список односвязанных,
причем биномиальных деревьев, которые мы будем как-то
объединять и так далее.
Вот.
Да, еще краткий анонс на тему того, что нас ждет.
Но не волнуйтесь, как бы это ни за мгновенно,
до этого мы должны дожить.
Вот.
Но сегодня мы как раз тоже сделаем, конечно, первый шаг
к тому, чтобы до этого дожить, но это не только ради этого,
потому что сегодня мы, конечно, будем тоже изучать достаточно
основополагающую тему.
Нет, знаете, парадокс заключается в том, что да, бинпоиск
в нашем курсе не изучается.
Вот.
Но знаете, ну просто как-то вот не очень понятно, что
про Двинтова можно про него рассказать.
Ну вот.
А так, что такое сампусель бинпоиск, или там бинпоиск
по ответу, я думаю все из вас все вы и так прекрасно
знаете.
А как писать его в десять раз быстрее?
Ой-ой-ой.
А значит, знаете, тот проблема в том, что я как бы очень
это там люблю иногда написать, собственно, лавербаунд
и не париться.
Иногда там такие коды получаются красивые.
Так что на самом деле лавербаунд это не то, на самом деле,
чем имеет смысл пренебрегать.
Чего?
Не слышу.
Я не слышу ничего.
Я как бы не только ничего не вижу, но ничего не слышу.
Чего?
Лавербаунд?
Убрать.
Господи, почему вы сегодня так тихо разговариваете?
Ну, так.
Вот.
Точнее, когда вот, стойте, как-то, как-то бывает, когда
вы между собой разговариваете, вы начинаете разговаривать
громко.
Это мешает.
А потом, когда вы начнете разговаривать со мной, вы
разговариваете тихо.
Ну вот.
Странно.
Вот.
Да, странно.
А разговаривать между собой и мешать собственно лекцию,
и вы не мешаете, там вам не стесняется.
Ладно, значит, смотрите, так, если вот по этому, по этой
рекурренте вопросов нету или есть, я говорю, она будет
добавлена сегодня в ваше домашнее задание, deadline через
неделю.
Ну, то есть, в общем-то, она, я думаю, так, может быть,
там просто чуть-чуть может быть сложнее, чем те рекурренты,
которые у вас там есть сейчас, то есть, в принципе, я не
думаю, что у вас там сильно большие проблемы с ней возникнут.
Ну, значит, надо хорошо порешать все темы.
Так я же говорю, не волнуйтесь, там произойдет следующее,
что, то есть, если там будут какие-то ошибки, у вас будет
возможность доработать.
Вот, ну, если, конечно, вы там не отправили пустой
лист в надежде потянуть deadline, конечно.
Да.
То есть, извините, после длайна можно будет еще доработать?
Значит, да.
Если уже до длайна отправлено.
Нет, если там первая осмысленная попытка отправлена до длайна,
то доработать, конечно, будет можно, да, естественно.
Так вот.
Ну, а сегодня мы пойдем, значит, еще одна важная
тема, да, на нее тоже будут веселые теоретические
задачи.
Вот, это, конечно, амортизационный анализ.
Вот.
Да.
То есть, это, собственно, вещь, там, без которой,
ну, без которой, там, на самом деле, в значительной степени
никуда.
Ну да, это мог бы быть пример, да.
Вот.
Ну, в принципе, действительно так.
Глобально о чем речь?
Ну, чаще всего, действительно, речь у нас идет beaches
о prestigious, departure, о некоторой структуре данных,
вот бывает, вот, бывает, вот, некоторая структура данных,
в которой, ну, есть там какие-то операции.
Ну, там, условно, условно, конечно, там, инсорт.
Но чаще всего там, есть, и операции со структурой,
это там, операция инсерта по рейсу какие-то.
Инсерты sheets, там, كان еще, там, что-нибудь, там,
бла-бла-бла, бла-бла.
Вот.
И обычно структура считается хорошей, если мы гарантируем, что каждая операция работает в идеале за от единицы.
Вот прям каждая.
Ну это прям совсем жиро?
Да, ну нет, наоборот.
Да, это прям хорошо.
Совсем жиро?
Да.
Но обычно это не всегда так получается.
Потому что иногда случается, что, например, выясняется, что там, скажем, инсерты и рейс работают, например, за от.
Плохо ли это?
Ну чаще всего плохо.
Потому что обычно тогда это означает, что допустим n операций мы тогда делаем за o от n квадрат суммарно.
Ну потому что мы так оценим, что каждая операция в худшем случае работает o от n, поэтому верхняя оценка o от n квадрат.
Но действительно бывает, что это исключительно верхняя оценка.
Ведь бывают такие ситуации, когда кажется, что в худшем случае оно может работать за o от n,
но гарантируется, что там, скажем, за 100-500 операций такое будет не более чем один раз.
Классическим примером является знаменитая очередь на двух стэках.
Ну-ка, поднимите руки, кто сталкивался с такой структурой данных.
Я не помню.
Ну сейчас напомним.
Все, спасибо.
Значит, можно заполнять побыстрее.
Я думаю, вам вряд ли нужно объяснять, что такое стэк и что такое очередь сами по себе.
Ну есть такое подозрение, да?
Вот.
Так вот.
Значит, смотрите, вот есть такая мистическая структура данных.
Вот, вы хотите реализовать очередь, а вы умеете только стэк.
Вот, у вас там есть какой-то там в кармане черный ящик, который умеет реализовывать стэк.
Тогда как его предлагается реализовывать?
Тогда предлагает следующее.
Заведем два стэка.
Вот.
Один назовем стэк in, а другой назовем стэк out.
И идея будет следующая.
То есть, соответственно, когда вам приходит...
Ну, что такое вообще очередь, да?
Очередь это структура данных, которая поддерживает, по сути, три операции.
Пуш, поп и фронт.
Что такое операция push?
Это добавь элемент в очередь.
Операция pop.
Достань...
То есть, достань первый элемент.
То есть, тот элемент, который сейчас находится...
Тот из элементов, который сейчас внутри очереди находится, который был туда добавлен раньше всех.
А front это...
А покажи, что это за элемент?
Да, не удаляй, но покажи.
Вот.
То есть, по сути, что такое в очередь?
Ну, у стэка, в общем-то, практически идентичный, на самом деле, интерфейс.
Абсолютно.
Только разница в том, что достается и показывается не первый добавлен элемент, а последний.
Вот.
Так вот, так что у нас тут добавлять?
То есть, мы говорим, что если мы хотим выполнить push, то мы просто добавляем элемент, соответственно, в stack.im.
То есть, push...
Вот, добавляем.
Вот. Ну, в ауте тоже есть какие-то элементы.
И если нам приходит pop или front, мы просто вот добавляем...
Удаляем верхний элемент.
Чего снизу?
Вот так.
Ладно, если вам так удобнее, давайте так нарисуем.
Вот.
Вот.
Да, два стаканчика.
Вот.
Но, вообще, какая проблема?
Что делать, если вот этот stack пустой?
Да, совершенно верно.
То есть, вот классический механизм...
Так.
Так.
Ладно, попробуем таким способом.
Так.
Ну, допустим.
То есть, если вот он пустой, а этот нет, то мы делаем неожиданную вещь.
Мы берем все вот эти элементы и по одному перегоняем stack out.
Просто вот достаем сверху и перегоняем.
Да, в принципе, действительно.
Это, да.
То есть, можно даже сначала даже не очевидно, почему это вообще имеет какое-то отношение к очереди.
Но, на самом деле, да.
Если уж говорить о том, как рисовать stack, то есть, как рисовать этот очередь на двух stack,
то на самом деле, вот.
Вот.
То на самом деле можно рисовать так.
Что такое очередь?
Это когда вы вот добавляете отсюда, достаете вот отсюда, да?
Вот.
Так вот.
Что такое очередь на двух stack?
Это на самом деле, да.
То есть, вы тут ставите вот такую границу мысленно.
Вот.
Вот.
Ну вот.
И говорите, что там вот тут элементы, тут элементы.
То есть, просто вот тут у нас некая, то есть, та же очередь, только между ними вот такая перемычка.
И как бы добавляете сюда, достаете отсюда.
Но если тут все стало пусто, значит, вам нужно сдвинуть вот эту перемычку.
Вот желательно вот сюда.
Как ее сдвинуть?
Да очень просто.
Вот эти элементы там по одному, собственно, вот сюда поперекидываем.
Вот.
Ну, такая вот классическая.
Да.
Вот.
Да.
Ну, у меня тут, честно говоря, классическая ассоциация из детства.
Но даже интересный соц. вопрос.
А кто когда-нибудь смотрел программу «Спокойной ночи, малыши?»?
Ух ты!
Абсолютная большинство.
Ну, я не знаю, да.
К сожалению, мы, возможно, там разные немножко выпуски смотрели.
Просто в моем детстве был такой.
Ну, скажем так.
Просто в моем детстве там одним из постоянных персонажей
был Амаяк Акапиан.
Амаяк Акапиан.
Фокусник такой известный.
Был когда-то.
Известный.
Да, сейчас, видимо, уже никто не знает, но не важно.
Так вот.
Редкий случай.
Так вот.
Он на самом деле, собственно, в одном выпуске обучал, собственно,
вот такому очень простому фокусу.
Значит, смотрите.
Значит, есть такой…
Значит, берем такой цилиндрик с двумя крышечками.
Такой цилиндрик, значит обернутый пленочек черным.
Вот такой.
Вроде оказалось бы его красивый, такойcartoon-цилиндрик.
euh- formula.
Значит, открываем крышку, значит открываем крышку,
кладём туда апельсин.
Вот, берём апельсин, кладём.
Всё.
Закрываем крышечку.
Закрываем крышку, колдуем, колдуем там.
Там вся aqua слik volk, halaj volkhelite там.
Вот.
Открываем крышечку и высыпаем оттуда конфеты.
вот такой простой фокус но вот но стоит быть вот вот эта картинка в принципе
четко собственно рисует собственно в чем секрет фокуса то есть как бы если
снять пленочку там оказывается что там просто две склеенные банки в одну из
которые заранее написаны конфеты то есть понятно главное тут просто все
перевернуть красиво вот но вот собственно вот очередь на двух стеках
собственно действительно устроено ровно таким же способом вот соответственно
значит к чему мы это все значит а мы это все к следующему вот то есть но то есть
в чем интерес почему нам очень интересно такая структура потому что в идеале мы
бы хотели чтобы действительно это чтобы все вот эти операции работали за от
единицы но мы видим что это не так вот например мы видим что операция да и поп да и фронт то
есть push реально работает за от единицы а вот поп и фронт как повезет как повезет потому что в
худшем случае от но заметим но с другой стороны тем не менее оказывается что называется говорит
что она работает за отн квадрат нельзя да потому что мы заметим что действительно заметим что
с каждым элементом на самом деле которые вы работаете будет проделана не более чем четыре
операции ну то есть добавить в этот стэк вынуть из этого стэка собственно добавить в этот стэк и
удалить стэк на этот раз уже навсегда то есть тогда получается что получается суммарное
количество действий не более чем отн то есть утверждение такое что если вы проделали с
этим стэком н операции то суммарное время работы этих н операции отн то есть смотрите
обнаружилась такая вот тонкая разница да что действительно отдельная операция может работать
долго но тем не менее суммарно все работает быстро то есть это то есть можно даже сказать что в среднем
эти операции работают за от единиц вот так тоже говорят вот вот на самом деле амортизационный
анализ но вот это собственно метод действительно анализа всем точке сейчас расскажу но который
позволяет но вот но который действительно позволяет действительно исследовать нер там
исследовать струит там структуру данных не методом вот за сколько работает в худшем случае
каждый отдельная операция а так сказать суммарно вот да
вот нет смотрите вот тут есть одна маленькая терминологическая подлянка спасибо за вопрос
то есть дело том что в среднем есть два смысла есть в среднем вот такой то есть когда вот когда
средний берется когда вы по сути говорите в среднем по там число операции которые сделаны
последовательно с одной структурой а есть средний да он ну там либо по всем данным либо
по вероятности то есть там с мыслям от ожидания вот то есть тогда это будем говорить что там то
есть скажем какой там квиксорт например который мы там будем изучать возможно даже сегодня
соптом там среднем работает за н лога но в том плане что если вы там включаете рандомы в качестве
там разделяющего элемента выбираете рандомный то там математическое ожидание времени работы
вот да в худшем случае там н квадрат но вот в среднем логен ну и там более точная
анализ показывает что там вероятность того что квиксорта вот там очень долго крайне
мало вот какая-то как-то так это работает но вот но это все вероятностный анализ то есть там
вероятностными анализами мы будем заниматься где-нибудь так это то есть это на втором курсе
вот но не потому что там мега сложно просто потому что скажи так там реально придется
там оперировать всякими от ожиданиями иногда дисперсиями там и так далее поэтому как бы
но поэтому поэтому хочется чтобы просто чтобы это просто изучили на соответствующем предмете
вот но вас на втором пути будет поэтому поэтому так вот вот но то есть поэтому мы не про какие
вероятности говорить не будем то есть там на первом курсе у нас будет максимум что у нас будет это мы
там иногда будем свято верить что там некоторые структуры данных существуют и работают и как-то
достаточно хорошо ну то есть честно скажу нас иногда нам придется поверить там существование
мега хеш таблицы которая умеет там добавлять себя удалять искать элементы за вот единиц вот
придется вот свято верить нет проблема в том что структур данных то вероятность тому от единицы
по вероятности будет ну да то есть вот с мыслям от ожидания да то есть нет вы конечно там на втором
курсе изучим действительно как откуда это вообще может браться там красивая структура данных с
не менее красивым анализом на самом деле вот но тем не менее но у нас среднее будет вот другое
значит смотрите давайте вот о том о другом подробнее значит смотрите значит потому что
действительно потому что если говорить о то есть если я вот тут наговорил действительно как-то
работает в общем вот сейчас на этом примере мы рассмотрим три на самом деле способа действительно
амортизационного анализа то есть вполне себе такие официальные техники собственно которые
можно даже в статьях встретить вот значит что нас вообще интересует и так значит смотрите
ну да значит способ номер раз значит внимание анализ просто в среднем вот давайте так его и назовем
что это значит это означает следующее что предположим что у нас есть структура данных
и мы выполнили несколько там допустим сколько-то операции с ней желательно с нуля эти операции
имели стоимости ц1 но в смысле вот реальные времена там допустим ц1 ц20 34 и так далее цен
вот так вот что такое анализ среднем анализ среднем он нам говорит что мы хотим действительно доказать
что действительно средняя то есть до каждой из этих операций может быть конкретно там какая-нибудь
большая но например мы говорим что самый тупой что ц1 плюс ц2 плюс ц3 плюс и так далее плюс цн
поделить на n оно не превосходит чего-нибудь ну как какой-нибудь красивого ну там я не знаю
вот там если глобально если так вот глобально от единицы от логен там ну и так далее ну то есть
например если операция средняя не превосходит логарифм средне аэритмическое то как бы мы
говорим что суммарно эти операции выполняются за n логан да но имеется в виду конечно да то есть
в идеале то есть обычно имеется в виду что для любого префекса этих операций выполнено что-то
аналогичное вот то есть вот в нашем случае на самом деле то что мы сейчас проговаривали вот
на пальцах да это практически вот анализ среднем то есть мы сказали что n вот если мы выполнили
n пушей там фронтов и попов то мы суммарно выполнили от n операции почему ну потому что
помимо вот от единицы операции которые там затрачены непосредственно на собственно вот
там добавление доставания там и стека и там или там залезание в него и доставание фронта да то
все остальные операции это перетаскивание элементов из одного стека в другой но суммарно мы из одного
стека в другой перетащили не более чем да не более чем пуши то есть не более чем n элементов
поэтому получается суммарно мы выполнили не более чем от n действий но в среднем получается
на каждое приходится не более чем от единицы вот то есть это вот такой один из таких простых
методов вот но конечно он работает далеко не всегда потому что чтобы он так красиво работал
конечно это желательно чтобы действительно все операции хотели оценивать одинаково вот то есть
на самом деле на самом деле у нас мы часто будем рассматривать структуры данных в которых
каждая операция даже в амортизированном смысле будет работать заразной асимптотики но вот
например там будет у нас скажем там куча фибоначчи например не это нормально ой блин это
софт хип не куча фибоначчи сравнению с ним это простая вещь достаточно вот в чем ее фишка да то
есть там тоже все это там вот забирая вперед вот рекламируем скажем что что такое куча фибоначчи
это куча то есть структура данных которая позволяет делать операции insert соответственно
экстракт мин а ну где тмин конечно фибоначчи нет вот ну ладно пока это любая куча ну ладно
почти любая на самом деле нас по начинаю сразу почти сразу будут интересовать сливаемые кучи
что значит сливаемые кучи это означает что мы можем там в любой момент взять две кучи и
создать из них одну но объединить по сути да ну понятно то есть если мы берем классические две
кучи то как бы будут проблемы то как бы потому что вам буквально придется там по одному элементику
из одной кучи в другую добавлять вот ну вот то есть на самом деле вот это вот это
интерфейс практически любой уважающий себя сливаемой кучи не уважающий себя тоже вот
да это вот почему-то называется meldable hips хотя конечно в литературе можно и mergeable hips но
вообще как бы это объединение двух куч там обычно обозначается словом meld вот ну и
теперь вопрос за ко всем точку это будет работать нет ну зависит от того какую кучу возьмете у нас
этих куч будет много нет откуда нет вот не надо говорить куча куч куча куча там ну как бы как бы
для вашей наверное декартовой деревья декартовых деревьев это как бы там все-таки да ну вот то есть
как бы немножко не то поэтому но да да да ну правда да ну правда для меня это дерево отрезков
декартовых деревьев все равно но это уже другой вопрос но вообще да но да но это уже детали до
этого мы тоже доживем но вот но как реализовывать этот интерфейс ну что-то зависит то есть если
брать тупую кучу то здесь конечно там слияние будет за n log n работать если значит там но там
могут быть у нас там будут какие-нибудь там левацкая куча какая-нибудь например у которой
все эти операции но кроме диетмина конечно будут работать за логарифом то есть какая-нибудь будет
левацкая куча то есть будет там логарифом логарифом тут будет ладно вот единицы тут будет
логарифом да причем до внимания это буду это будет честная оценка вот единицы это единица да
нет я рисовал единицу видимо не очень не очень вряд ли и нарисовал ну как бы это будет подвешено
там какой-то двойничное дерево поэтому как бы да поэтому получить сам минимум за вот единица
без проблем так вот а будет куча фибонач левацкая бенемиальная нет это принципиально разные вещи
кстати не не бенемиальный все предельно честно да ну и ну и в бенемиале и в левацкой но это
принципиально разные кучи там с принципиально разными подходами ну вы увидите так не ладно вы
пока вы пока не зависаете это тоже нас там скорее всего там где-нибудь там это тоже нас достаточно
хотя хотя да тут надо думать что нас скоро ждет действительно кучи или фурьятина ну ладно
но скажем так смотрите ну скажем так мы будем решать задачу быстрого перемножения в первую
очередь многочленов то есть мы захотим их перемножать за ну в идеале н логан карацуба не
карацуба это не поможет начнем бы конечно с него да так ну там ну как говорится вот зачем вот вы
вот порешаете рекуррент и мы собственно по нот и нот и мы потом с вами узнаем собственно
просто своими руками убедимся за сколько там карацуба реально работает потому что тоже
типичный пример и по которым появляется рекуррента вот вот но на самом деле там основной алгоритм это
быстрое преобразование фурье но самое главное там фишка в том что с умножением многочленов там
связано много чего еще но в конце концов быстрая длинная рифметика там быстрое умножение быстрое
деление там ну там в общем называется масса всего поэтому это у нас такой очень большой блок будет
но не слава там философский вопрос кстати за что оно работает ну то есть fft там без
условно есть но если уж говорить об этом то знаете то там скорее всего в разные подкрутки есть но
нет смотрите тут нет тут я дам датчет мы опять все отвлекаемся но тут я дам такой комментарий что
не знаю то же вместо кома но то есть вот мой скомандик по и си пи си гоши чебанов он там
свое время это откопал действительно какую-то библия там некую сишную библиотеку которая умеет
умножать числа там длины миллион за вот-вот вот-вот столичка вот-вот там 0.0001 там по-моему что-то
в этом роде или там 0.0001 не помню но он говорит что он там открывал собственно исходный код то
есть на самом деле там действительно какая-то черная магия из дефайнов в которой там можно
покопать что в каких-то случаях делается фуриатина в каких-то случаях делается карацуба ну и конечно
в каких-то достаток относительно до какого-то момента естественно делается просто столбиком
ну потому что действительно оказывается что там действительно если у вас там многочлены длины
10 или числа то гораздо легче уже пробежаться и перемножить их столбиком чем там изобретать
какой-то фурия то есть просто по константе вот хотя у фурия то может константа не самая плохая на
самом деле но все-таки там какие-то комплексные числа повылезают поэтому но вот вот там вот вот
в этой библиотеке люди прям вот очень сильно там заморочились там прям дефайны подгоняли
чтобы там максимально все ускорялось и так далее и собственно много в том преуспели поэтому вполне
вероятно что в питоне тоже на самом деле зашито что-то подобное вот так вот но это но вот но это
так это называется что опять анонсы что нас будет но вот что нас ждет не будем на это отвлекаться
потому что сейчас вот нам нужен амортизационный анализ так вот в чем смысл вот если леватская куча
или биномиальная куча там то есть да они вот работают вот за столько но есть ставка куча
фибоначи будет работать за вот столько то есть все операции кроме да кроме доставания минимум
будут работать за единицу правда это в внимание амортизированном смысле как это вообще понять то
есть да то есть в принципе да никто не гарантирует что там слия каждое слияние будет реально за
от единицы работать это не так да но а что такое в данном случае в среднем видите то есть операции
да суть именно такая да то есть по большому счету то есть анализ в среднем можно было бы
заменить более точно было бы сказать на анализ в сумме то есть и в сумме так и сказать что если у
вас там вот были там была пустая куча или правильно говорить набор пустых куч изначально был у вас
трог там пустых куч там n штук например и вы в них сделали а инсертов б экстракт минов там допустим
ци гет минов или д мэлдов причем гарантируется что у нас суммарно в кучах было не более чем
н элементов то тогда суммарно все эти действия будут работать не более чем вот суммарно то
есть вот ц1 плюс ц2 плюс и так далее там плюс допустим цн вот если у нас н действия было они
будут работать не более чем за от а плюс б на логарифом н плюс ц плюс д в данном случае вот то
есть это такой такой анализ такой анализ в сумме так сказать и в общем-то он иллюстрирует вообще в
чем глубокий смысл на самом деле то есть когда мы то есть как бы то есть аemos амортизационный
анализ когда мы не пытаемся анализировать отдельно каждую операцию и худшие случаи когда мы
пытаемся анализировать их какой-то взаимоисвестие в сумме вот то есть принципе дам может быть
и какие-нибудь еще случаи предположим что там то есть допустим если надо говорить что у нас
есть учетные стоимости допустим что там первая оператором первая операция работает за корень
там вторая операция работает за логарифом, третья там работает за, ну ладно, уже за обратную функцию
окирмана какую-нибудь. Ну и рядом тут операция, которая работает за квадрат. Очень весело. Вот. Да, то есть тогда, то есть как бы что означает, что учетная стоимость
этих операций таких? Ну это означает, что да, если первых было a, вторых b, третьих c, четвертых d, значит суммарная
стоимость, то есть по сути это прям определение практически, что если операция была выполнена вот там abcd для любых abcd, ну там адекватных, то
ну адекватных в том плане, что там понятно, что не могло быть так, что, скажем, вы там добавили в кучу 5 элементов, а достали 8, да? Вот. Ну там какие-то вот
такие вещи, то получается вот так. Вот. И на самом деле это тоже полезно писать, потому что да, вот иногда бывает, что некоторые операции работают
за n квадрат, но тем не менее структура данных может быть полезной, например, такая, если вы знаете, что вот этих операций мало.
Если их две. Вот, да.
Мы уже здесь, как бы, рассуждаем все равных по симптомам.
Да.
Ну понятно, что о, конечно.
Так, а что это значит? То есть у нас здесь получается несколько современных по сути.
Да. Ну а означает это буквально то же самое. То есть мы будем говорить, что алгоритм работает, то есть суммарно эти операции работают за от столько.
Это означает, что существует, не зависящая ни от каких abcd, великая константа какая-нибудь, какую мы букву не использовали, там f, да?
Что количество действий, то есть для любых попавшихся abcd и для любого там, то есть если бы это выполнили какие-нибудь там n операции, допустим,
если там a были первых, b были вторых, c третьих, d четвертых, любые abcd, и тогда количество действий не превосходит f умножить на вот это вот все.
Ну, это вроде очевидно, потому что мы можем разбить это на четыре оценки отдельно.
В каждой подобрать свою константу, возьмем из них максимум, и оно в магическом образе.
Сейчас, сейчас, сейчас, сейчас, сейчас.
Мы же не можем оценки разбивать, потому что мы не можем доставать.
Нет, просто, нет, смотрите, просто, нет.
Нет.
Нет, это, нет, это не о, понимаете? Нет, тут проблема такая.
Нет, это не, тут как бы abcd, это не совсем, это не константы.
Это количество операций, которые вы выполнили.
Ну, как отдельно, понимаете?
Как бы смысл амортизационного анализа в том, что иногда отдельно вы их просто оцените хуже.
То есть, конечно, можете.
То есть, смотрите, если вы оценили, что там вот эта операция в худшем случае делается за корень и zen,
это в худшем случае за алгорифм, это в худшем случае прям в худшем на этот раз за термана,
а это в худшем за n квадрат, то вы тоже можете сказать, естественно, что, то есть, тоже будет верно, что суммарно это работает за вот столько.
Да, то есть, как бы, как бы, условно говоря, для этого, да, то есть, достаточно оценить, если будет оценено в худшем случае.
Но просто фишка в том, что это не всегда необходимо.
То есть, может быть так, что, действительно, в худшем случае эта операция может и за куп работать,
но, то есть, если суммировать по всем операциям, то окажется адекватно.
Вот.
А это так, ну, это константа из Ошки.
В идеале тут должна быть константа С большая, но я тут вот из эколизии с этой буквкой только ее не поставил.
Так что вот такой вот смысл.
То есть, хочется вот так.
То есть, в данном случае вот оказываю.
И иногда это действительно помогает.
Потому что, если вы знаете, что там n², то есть, тут этих операций мало, то, в принципе, можно иногда использовать.
Да, в общем-то, и сама куча фибоначи.
Видите, например, что это означает?
В принципе, это означает, например, вот если внимательно посмотреть, то вот окажется, что, ну, например, вот сколько вы будете, есть у вас задача.
Допустим, вы решили добавить в кучу n элементов, а потом достать, а потом найти в них 3 минимума, да?
Тогда смотрите.
То есть, как это можно делать?
Говорите, если вы используете вашу классическую там, скажем, вот леватскую кучу, то что получается?
То получается n лог n, потому что вы n раз добавили за логарифом, и потом 3 раза экстракт добавили.
Но тут вы понимаете, что, наверное, где-то в 7-8 классе, наверное, вы писали подобную задачу, как-то еще не зная даже понятия куча, и по асимптотике у вас получалось лучше, правда?
Да.
Я еще не знаю параметры в классе.
Да?
Нет.
Ну вот.
А, ну вот, хорошо.
Ну когда вы, хорошо, когда вы…
Чего?
Ну, 3 минимума, может, вы не писали, но, я думаю, вы догадываетесь, да?
Да, может быть, 2 минимума вы писали.
Находишь?
Да.
Да, ну, по сути, да.
То есть, известно, что 3 минимума можно найти за oatn, правда?
Ну, практически там, ну, там как угодно.
Найти 1 минимум, действительно удалить, найти второй или второй минимум.
Найти 1 минимум, действительно удалить, найти второй.
Или там 3 итерации пузырька какого-нибудь, там все шо угодно.
Вот.
То есть, поэтому да.
Но с другой стороны, если бы вы доставали не 3 минимума, а n пополам минимумов, то,
конечно, вот эта штука была бы лучше, чем если бы вы там по одному эти минимумы
доставали.
Вот.
Ну вот, оказывается, на самом деле.
Нет, ну, отсортировать дай-то.
Ну, это другой вопрос уже, да.
А можно воспользоваться, для 3 минимумов теперь можно воспользоваться кучей фибоначи.
Потому что, смотрите, куча фибоначи позволит вам это сделать за oatn.
Потому что вы добавляете за oat1 элементы, а достаёте минимум за логарифм.
То есть, у вас получится n плюс 3 логарифма.
Ну, то есть, n.
Да, а это oatn, как мы знаем, да.
Вот.
То есть, видите, получается такая вот нодка.
То есть, правда, это будет амортизировано.
То есть, реально, особенно первый поиск минимума у вас будет работать ой, как не за логарифм.
Ну ладно, сам поиск минимума, конечно, не проблема.
Потому что я вам так открою страшную тайну.
Потому что структура, действительно, куча фибоначи, она, действительно, очень хитро будет работать.
Потому что операция INSERT, вот по началу особенно, будет устроена очень просто.
Все элементы будут находиться в двусвязанном списке.
И когда вы будете делать INSERT, просто элемент будет в этот двусвязанный список добавляться.
Всё.
А, и ещё поддерживаться минимум.
Ну, в виде там, где находится минимум.
Всё.
Пока вы не будете делать ничего, кроме INSERT и GetMin, куча фибоначи буквально ничего больше делать не будет.
Зато, как только вы потребуете ExtractMin, она скажет так, погодите, вернусь через 15 минут.
И начнётся там тотальный перестрой с каких-то страшных деревьев.
То есть там, скорее всего, особенно первый раз, точно там линия каких-то операций будет сделана.
Но нас это не волнует.
Потому что мы гарантируем, что, на самом деле, суммарно, ABCD операции будут выполнены вот за какое-то время.
Просто константа, возможно, будет чуть больше, чем вы ожидали.
То есть, когда вы думаете, так, отлично, вы сделали INSERT за две секунды.
Видимо, константа две секунды.
Так вот, фишка такая.
Константа, на самом деле, не две секунды.
Константа, на самом деле, 23 секунды.
Просто произошло следующее.
Просто, на самом деле, две секунды INSERT тратит прямо сейчас.
А в будущем он говорит, что на каждую операцию, на самом деле, у вас там будет ещё есть, теоретически, 21 секунда.
И когда вы там добавили 100 000 операций, у вас там получается 210 000 секунд, которые он имеет право потом себе как-нибудь использовать.
И он это будет делать.
То есть, гарантируется, что на 100 000 операций он потратит не более, чем 230 000 секунд.
Ну ладно, умножь на логарифм.
Вот.
Ну, кстати, это ещё одна иллюстрация того, о чём мы тут разговариваем.
То есть, мы разговариваем о том, что, действительно, у нас есть какая-то верхняя оценка.
Да, но это именно верхняя оценка за счёт того, что некоторые операции могут временно сэкономить прямо сейчас.
То есть, они сработают быстрее, чем в этой оценке ожидается.
Но это будет за счёт того, что к некоторому критическому моменту будет сэкономлено достаточное количество времени.
И это время будет использовано потом.
Вот.
Это ещё одна иллюстрация.
И, кстати, на самом деле, это приводит нас ко второму методу.
Вот, за этим английском языке есть такое слово «straightforward».
Такой прямолинейный, такой туболомный.
То есть, да, в некоторых структур, которые вы просто, когда методом пристального взгляда про них всё понятно,
ну, вот, например, как, собственно, у нас для очереди двух стерров, можно анализировать вот прямо так.
Но иногда, конечно, это достаточно сложно.
То есть вот в кучах нот.
Поэтому в кучах, например, или там ещё в некоторых сортировках мы будем использовать немножко другое.
Что же мы будем использовать?
Чего?
Банковский метод.
Ну, да.
Ну, и его тоже.
Ну, я сейчас расскажу на самом деле два метода.
Скажем так, первым методом очень удобно думать вот в этих терминах.
А вторым методом очень удобно писать формальные доказательства.
Вот.
Ну, то есть на самом деле суть, да.
От балды, если честно.
Ну, то есть, как бы, на самом деле, везде, когда мы тут пишем операцию, значит подразумеваем О.
Да.
Да, мы всегда подразумеваем.
Да, давайте напишем.
На самом деле...
Вот единицы, а там логом стоит, кстати.
Да.
Одного стола.
Да, да, да, да, да.
Это просто исключительно моя небольшая неаккуратность.
Вот.
То есть, как бы, да, я тут...
Да, ну, как вы видите, я тут не стремлюсь к тотальному формализму.
Вот.
То есть, конечно, можно тут построить красивое там абсолютно формальное знание, но как бы мы тут сейчас говорим не о том, как строится...
То есть, мы сейчас все-таки говорим об идеях.
То есть, у нас курс все-таки об идеях, которые за этим стоят и как это все придумывать.
Вот.
То есть, конечно...
Ну, поэтому там совсем до идеального формализма может доводить и не будем, хотя, конечно, в голове всегда должны держать, что вы должны это уметь делать.
То есть, да, иногда это будет...
Скажем так, когда вы там говорите, что когда вы выскакиваете в коридор, видите огнетушитель, говорите, решение существует, то есть вы должны быть готовы к тому, что если вас спросят, а что за решение, вы должны как бы продемонстрировать, как снять огнетушитель со стены, как его воспользоваться.
Вот.
То есть, как бы, да, если он вот, поэтому, то есть, выдана вот, то есть, как бы на экзамене, то есть, всегда такие вопросы могут возникнуть.
Вот.
Так вот.
Итак, значит...
Значит, перейдем к второму методу.
Значит, это метод бухгалтерского учета.
Мы точно туда вышли?
А что не так?
Чего?
Да нет.
Не, ну, как бы, реклама 1С тут уже самим фактом того, что мы в офисе 1С находимся.
А метод бухгалтерского учета это абсолютно реальная терминология.
Ну, там по-разному можно назвать метод бухгалтерского учета, метод моменток там.
То есть, на самом деле, интерпретации, анализы монеток разные.
А смысл, на самом деле, следующий.
Значит, смотрите, в чем будет смысл?
То есть, смотрите, вот у нас есть реальные стоимости, да?
Ну, типа, вот, времена С1, С2, С3, С4 и так далее, С.
Что это?
Это, допустим, это реальные стоимости.
То есть, опять, у нас есть структура данных, и мы с нуля выполнили N операции, да?
А теперь мы говорим, ну, это вот реальные времена.
Или реальная стоимость.
А теперь, смотрите, а теперь идея такая.
Мы будем...
Значит, у нас, помимо этих операций, будут еще монетки.
И мы эти монетки будем...
Смотрите, мы будем эти монетки получать.
Вот получено, будем говорить, что у нас там за каждую операцию выполняемую, да?
Мы будем получать какое-то количество монеток.
Допустим, там плюс, там, тут получено P1, плюс P2, плюс там P3, плюс P4, плюс Pn.
Ну, просто получать монетки корешать не интересно.
Но теперь фишка такая.
А еще мы будем...
А еще мы будем тратить эти монетки.
Так, вот у нас, да.
Вот.
Да, то есть у нас такая, ну вот.
То есть, ладно, тут тоже будет какое-то количество монеток потрачено.
Значит, в чем фишка?
Значит, зачем мы это вообще делаем?
Значит, идея будет заключаться в том, что мы будем...
Ну вот, что мы будем говорить, что когда мы тратим монетки...
То есть зачем? Мы не просто так тратим.
Мы монетки не просто так тратим.
Фактически мы будем их...
Мы ими будем оплачивать то, что вот тут какая-то операция длилась долго,
но вот некоторые ее отдельные моменты вы, пожалуйста, не считаете.
Вот.
Как говорится, вот, пожалуйста, ты вот эти вот, скажем, вот эти вот 57 действий ты не считай в общем времени,
а я тебе за это дам 57 монеток.
Вот такой смысл.
Как это работает?
Вот давайте, то есть пока это, конечно, абсолютно абстрактно.
Сейчас я покажу, как это работает на примере двух стэков.
Чего?
Уже спладывается понимание.
Да, но сейчас я покажу.
То есть нет, просто это действительно очень красивый анализ,
которым вот действительно очень удобно пользоваться, на самом деле.
Смотрите.
Как это работает на примере двух стэков?
На примере двух стэков
Так.
Да, да, да.
А вот давайте я вот сейчас на примере покажу, потому что, что я уже сказал, это была абстракция.
Сейчас я вам покажу.
Значит, анализ может быть выглядит так.
Смотрите.
Смотрите, какая фишка.
Значит, мы будем говорить.
Каждый раз, вот, значит, каждый раз, когда мы будем добавлять элемент в стэк, вот этот,
мы будем получать монетку.
Вот даже очень удобно мыслить в терминах, что когда элемент добавляется вот этот в стэк И,
мы привязываем к нему монету.
Вот мы получаем монетку и привязываем ее к нему.
Понятно, да?
А теперь фишка такая,
что когда мы начинаем перекидывать эти элементы в соседний стэк,
мы эти монетки выкидываем.
Почему?
Потому что, что такое монетка?
Это, то есть, монетка для элемента, это оплата.
Оплата за перетаскивание этого элемента из стэка Im в стэк Out.
То есть, зачем мы это делаем?
Мы это делаем вот зачем.
То есть, мы говорим, что это действие у нас становится оплачивать.
И мы его типа не учитываем.
В учетном времени работы.
То есть, тогда логика такая.
Смотрите, заметим, что у нас тогда,
помимо оплаченных действий,
то есть, просто в чем логика?
То есть, получается, что вот эти методы, это мы оплатили.
И у нас получается, но помимо оплаченных действий,
у нас есть только честное добавление и честное удаление.
И тогда получается, что все операции работают за ОАТ единицы.
Да, но правда, конечно, само по себе абстрактно это не должно, конечно, работать.
Потому что пока это может звучать как,
а давайте просто делать абсолютно рандомную операцию,
там какую-нибудь там рандомную шнягу и говорим, что,
ну да, скажем, как сделать сортировку за ОАТН?
Да, вот смотрите, тут тупой алгоритм сортировки за ОАТН, еще один.
Вот, то есть, берем элементы и, допустим, там за ОАТН находим максимум, перетаскиваем его в конец.
Но мы это время не учитываем, потому что мы платим Н-монеток.
А где мы их взяли, да?
Да, ну вот, потом еще один минус один и так далее.
Но, действительно, тут фишка в том, что тут мы как бы,
то есть, это называется, мы включили печатный станок.
Нет, ну да, инфляция тут, конечно, да, не совсем то,
но тут скорее то, что это называется, да,
что называется, у нас есть большой долг, так как бы нам его обслужить,
а давайте напечатаем кучу денег.
То есть, да, вот, ничего хорошему особо это не приводит.
Ну вот, но, как говорится, ладно, курс экономики,
это у вас там, собственно, будет тоже курс и на третьем,
потому что что там конкретно происходит.
Но в нашем случае нам важно следующее.
Потому что, да, в нашем случае нам важно следующее.
В нашем случае нам важно следующее.
Потому что, да, то есть, очень круто, что мы что-то оплатили,
но важно всегда помнить, ну вот, почему мы говорим, что все хорошо.
Потому что мы обнаружим следующее.
У нас здесь есть, в отличие от этой ситуации, важное свойство.
Мы не тратим, значит, утверждение номер раз,
мы не тратим монеток больше, чем мы получили.
То есть, мы никогда, то есть, важное вот свойство маркетизационного анализа
мы никогда не работаем в долг.
То есть, нам монетки, то есть, только те монетки, которые нам дали, мы используем.
В общем, у нас ни времени ни приема, нет адресательного количества.
Да, то есть, да.
И второе свойство, которое нам помогает здесь, мы говорим, хорошо, да,
все, что не оплачено, работает за вот единицы.
Но с другой стороны, обратите внимание, тут, что приятно,
с другой стороны мы заметим, что суммарно, мы получаем не более чем n монеток.
Понимаете, да, не более, чем n монеток.
То есть, это означает, что на каждую операцию не оплачено к действию от единицы,
а суммарное число оплачено к действию от n,
потому что мы получили не более, чем n монеток.
То есть, получается все оплаченные действия суммарны тоже делаются за уа тэн.
И тут же можно говорить, что на любое действие он получает не одну монету, а константное количество.
Ну, да, это уже вот вопрос того самого курса валют.
То есть, видите, тут тонкий момент такой, то есть, что такое монетка?
Монетка – это то, что вам позволяет оплатить от единицы действий.
То есть, вы заранее фиксируете какой-то курс, типа, какое количество конкретных действий, константных, вы оплачиваете одной монеткой.
Вот.
Да, формально говоря, да. То есть, конечно, эту конкретную константу там можно подкручивать.
В данном случае теперь мы сказали, что у нас вот наша золотая монетка,
ее хватает на то, чтобы перетинуть элементы из этого стека в это.
Ну, как бы мы знаем, что это вот единица вот так.
То есть, мыслить можно по-разному.
Можно мыслить, конечно, что давайте говорить, что одна монетка позволяет оплачивать один такт процессора, условно,
и тогда там давать не одну монетку, а от единицы монеток.
То есть, это может быть было более правильное.
Но иногда будем мыслить, что вот у нас монетка, все-таки будем единицу монеткой давать.
Хотя подразумеваю в голове именно это, да?
То есть, монетками можно обрабатывать только те операции, которые работают в среднем, да, от единицы?
Да.
Не в среднем, а в античном?
Да, да, да, да. Но как мы в будущем увидим, на самом деле, вот у вас там в будущем увидим,
это не означает, что вы обязаны получать там, допустим, именно от единицы монетки.
То есть, вот, да, в данном случае мы получаем одну монетку.
Но на каждом шаге вы имеете право получить логарифом N-монеток.
Ну, типа, если у тебя оценка нередко.
Да, то есть, здесь важно, да.
Но здесь давайте, чтоб понять, как это...
Тогда, смотрите, здесь это просто работает в итоге так.
Значит, работает это следующим образом.
Мы получаем, смотрите, учетную...
Значит, тогда здесь вводится такое понятие, как учетная стоимость.
Или амортизированная стоимость.
Вот, в языке и литературе чаще всего это называется amortized cost, соответственно.
Так вот, в данном случае, если вы применяете вот этот вид анализа с монетками,
то вы говорите, что учетная стоимость, она будет равна CIT плюс...
То есть, как бы, каждую монетку, которую вы получаете, она как бы увеличивает стоимость.
А каждую, которую вы тратите, она уменьшает.
Вот как-то вот так это работает.
О, пошло бы.
Cn плюс pn.
Вот.
То есть, обратите внимание, то есть, нельзя...
То есть, если у вас была мечта, что давайте за каждый элемент добавленный в массив перед сортировкой,
вы получаете o от n монеток,
это лишь означает, что добавление этого элемента в массив, у вас будет стоимость o от n.
Поэтому, суммарно, вы от этого n квадратов все равно так просто не делитесь.
Потому что теперь у нас n квадрат монеток.
Да.
То есть, помните, каждая выданная мама...
То есть, по большому счету, важный момент.
То есть, как бы, монетки, они операции не уничтожают и не создают.
Это способ такой, что как бы...
То есть, давайте считать, что...
То есть, вот в случае двух стэков, например,
давайте считать, что мы сейчас выполнили две операции.
Собственно, добавление и вот ту операцию,
и, типа, ту операцию, которым вы этот элемент перекинули туда.
По большому счету.
То есть, это мы сделаем в будущем, мы будем считать, что мы это как бы сейчас сделали.
А там мы ее считать не будем.
То есть, такое мысленное перераспределение.
Да.
Что такое перераспределение?
А вот это определение.
А почему это не c1 плюс q1 и c2 плюс q2?
Ну, потому что мы как раз...
У нас как раз смысл в том, чтобы вот оплаченные действия не учитывать.
Вот.
У нас, когда мы тратим монетки, мы тратим время.
Когда мы получаем монетки, то мы как бы мысленно записываем...
Нет, когда мы получим...
Ну, как сказать?
Потому что тут же...
Сейчас.
Нет, почему? Наоборот...
Ну, как бы, смотрите.
Почему мы оплаченные действия не считаем?
На самом деле, потому что мы их уже...
Мы их посчитали, когда нам выдавали соответствующую монетку.
То есть, здесь важный смысл, что для любого i должно быть верно,
что сумма по всем g, p житого минус q житого,
она всегда должна быть больше либо равно нуля.
То есть, что это я написал такое, да?
Это я написал, что мы никогда ни в какой момент времени
не потратили больше монеток, чем нам выдали.
Нет, мы могли потратить в какой-то момент больше монеток,
чем нам выдали за эту операцию, но не больше, чем...
Да.
Да, то есть конкретная q житая может быть больше конкретного p житого,
но гарантируем, что на любом префиксе вот так.
Так, вот вектор, погодите, потому что вектор — это следующая структура данных,
которую мы будем с этим всем анализировать.
Да.
Да, будем.
Обязательно мы сейчас это будем проговаривать.
Но пока вот так.
То есть, вот че...
Да, то есть, здесь получается такая штука, как учетная стоимость.
То есть, здесь говорят, что вот учетная стоимость,
скажем, кучи фибоначи, вот такая, да?
Но заметим, что смысл-то ровно тот же.
Потому что, то есть, учетная стоимость — это в том плане,
что...
Действительно, в чем смысл введения такой именно учетной стоимости?
То есть, это означает, что на самом деле...
То есть, это не означает...
То есть, каждая конкретная учетная стоимость,
она может быть как больше реальной стоимости, так и меньше.
Но у нас смысл в том, что...
Опять же, вот давайте я тоже на префиксы буду писать.
Для любого i верно, что сумма учетных стоимости —
это верхняя оценка на сумму реальных стоимости.
Ладно, тут же и...
То есть, вот в чем глубокий смысл.
Вот.
— Можно вопрос? — Да.
— А ранее было, что одна монетка — это, в смысле,
два раза завод изнисла.
Когда мы получили, или когда мы отдали ее?
— Ну, нет.
Нет, получение...
Ну, не совсем так, нет.
Получение монеток — понятно, в реальном времени...
Т.е. в алгоритме-то алгоритм сам по себе
от этого лишних действий не делает.
Смотрите, получение монеток и отдача монеток —
это то, что мы делаем для анализов.
Т.е. реальный алгоритм от этого не меняется.
То есть, получение монеток и отдача монеток —
это всего лишь способ пометить,
что вот это действие мы сделали когда-то вот тогда,
Но учли мы это действие раньше, а сделали мы это для того, чтобы сказать, что у нас нет такого, что тут 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
Нет, если изначально, да, но это по сути означает, что у вас инициализация выполнилась за там учетных от n получается.
Ну вообще изначально у нас ноль монет, если что.
Нет, то есть вы анализируете прям именно n операции, ну можно и так в принципе, да.
То есть это все равно будет, да, просто чуть-чуть другая техника получится, хотя, да, то есть смысл как бы примерно тот же, да.
Ну нет, то как смысл, вот сейчас, ну не обязательно от n там.
Ну это как повезет, ну в принципе, да, то есть смотрите, смысл такой, то есть учетная стоимость, это так, чтобы
сумма учетных стоимости была верхней оценкой на сумму реальных.
То есть смотрите, то есть, например, с точки зрения кучи фибоначи, будет говорить, что учетная стоимость, скажем, инсерта будет от единицы,
там, или какой-нибудь гетмина от единицы, а какой-нибудь экстракт мина логарифом.
То есть вот тут будет написано 1,1, логарифом 1,1 и так далее, но если мы гарантируем, что сумма вот этого больше либо равно, чем сумма этого,
то, соответственно, это вот нас устраивает.
Ну что, значит, одинаковые, ну плотно, но оценки на них, да.
Нет, ну или я не понимаю вопроса.
Ну да, ну как бы, скорее всего, да, ну как бы понятно, что, помните, что учетная стоимость, это тоже верхняя оценка.
То есть мы гарантируем, что каждая операция, там скажем, инсерт будет работать не более, чем за тому от единицы.
То есть не более, выполнить не более, чем там 57 операций. 57, раз она всегда фиксирована константа.
То есть понятно, что в реальности может быть так, что в одном случае она сделает там 28 операций, в другом 34, но
вот, но гарантируется, что всегда не более, чем 57. Вот как-то так это будет работать.
Да, то есть вот в чем действительно тут смысл.
Нет, ну просто,
нет, ну смысл в том, для более удобного анализа.
Потому что, скажем, вот в куче фибоначин, например, каждое конкретное действие может работать и за линию, если не дольше.
Потому что, как уже было сказано, то есть если вы там добавите 100 тысяч элементов,
да, он каждое будет добавлять чисто в список. А потом, когда вы доходите достать из него минимум, он там начнет действительно какие-то страшные структуры строить, и уж не менее,
чем ОАТН действие, он на это потратит.
И это будет записано вот в этих цешках. Но это нам так неудобно анализировать.
Почему нам неудобно? Потому что, если мы будем считать, то есть самый простой способ сказать, что каждый экстракт Мин работает за ОАТН, и тогда в худшем случае это работает за Н квадрат,
это нас не устраивает. Потому что это не так.
Вот. Поэтому зачем нужны учетные стоимости?
Вот оказывается, что если вот написать хорошо учетные стоимости, то мы обнаружим, что сумму учетных стоимости
мажорирует сверху сумму реальных стоимости.
И тогда, получается, мы можем нам просто удобно так, то есть удобно считать,
что в учетном смысле, вот, действительно, у Кучи Фибоначчи, действительно, там вставка работает учетно за единицу, а экстракт Мин учетно за логарифу.
То есть это учетные стоимости, вот эти красивые?
Да. Это учетные стоимости, это важно.
Да.
То есть, боже упасти, это нереально.
Короче, каждый раз, когда ты сделал операцию, там, ну, за пять операций, а не за двести, ты говоришь, что остальные 195 отложил на потом.
Ну да, и они будут...
Еще пригодятся.
Ну, типа того, да.
Но если реальная стоимость равна учетной стоимости, то это значит, что у нас потратились все монеты?
Ну, по сути, да.
А где мы, если вы учли, что мы где-то потратили?
А вы еще говорили просто, что...
А мы негде, потому что...
Неконстантные числа, монеты вы говорили?
Ну, иногда бывает, поэтому я тут пишу, видите, p1, p2, p3, да, видите?
Они могут и от n зависеть, в принципе, вполне.
Ну, то есть так, в принципе, вот это какие-то чиселки абстрактные.
То есть это чиселки и это чиселки, то есть, как бы, там реальные цифры.
Но потратились они нигде, то есть, только не в 8 точках.
Они потратились за счет того, что, как бы, наша задача, то есть, мы говорим, наша задача оценить сумму вот этих цешек, да?
И мы говорим, что оказывается, да, что эта сумма цешек и происходит сумма вот этих, чуть более экзотически устроенных цешек.
Вот. И оказывается, что сумма этих цешек оказывается вот там, вот отсюда берется.
Ну, что... Ну, я не понимаю вопрос, что такое написать 7 точек?
Ну, как бы, утверждение. То есть, это все, как бы, для того, чтобы, то есть, формально звучит так.
Мы утверждаем, что, то есть, отсюда следует, что реальное время работы не превосходит...
То есть, как бы, вот эти все n операции суммарно были выполнены за O от вот этих вот там, от 1 до n.
Вот этих вот C и D. Вот.
Да.
Ну, вот опасно тут употреблять средним.
Нет, ну, смысл-то тот же, да, что...
То есть, по большому счету, да, то есть...
Ну, то есть, по большому счету, да, то есть, смысл будет тот же, если мы докажем, что там вот учет, вот таким вот образом введенные учетные стоимости будут
не превосходить там для инсерта гетмина и там мэлда O от единицы, а для экстракт-мина алгоритма,
вот каким-то образом мы это, да...
Ведутся у нас эти монетки вот таким образом, что это будет происходить именно так, да.
То тогда получается, что мы гарантируем, что тогда...
Значит, там, если у нас было, опять же, A инсертов, B удалений там C гетминов и D мэлдов,
то есть, опять, тот же самый смысл.
То есть, время работы будет не превосходить не более, чем получается вот опять A.
A на единицу, плюс B на алгоритм, плюс C на единицу, плюс D на единицу.
То есть, и эта сумма будет зашита уже здесь.
Нет, зачем?
Нет, если у нас все C равны, это означает, что, по-видимому, мы вообще не получали и не тратили никаких монет.
Ну, нет, а мы вообще не получали.
Потому что, напоминаю, да, важный еще смысл заключает в том, что в этом анализе изначально у нас монет нет.
Все, вот у нас все, ноль, все.
То есть, поэтому, если у вас как бы все C, если каждая C равна, там, каждая учетная стоимость равна реальной,
то это означает, что, ну вот, то, особенно вот с учетом вот этого условия,
это означает, что у вас тут вот везде нулей.
То есть, по сути, никакой амортизации нет, мы вообще ничего не получали, ничего не тратили и работали честно.
Хорошо, а если у нас реально время, допустим, было D от единицы, а в конце мы взяли и потратили Nlog Nmonet.
А, нет, мы получали C-шки равны единице, получали алгоритм, а в конце взяли и все потратили.
Ну и что?
Ну, у тебя симпотика, видимо, Nlog Nmonet.
У меня же, стоп, у меня все полученные монеты потратятся, и при этом сложатся все C-шки, получится вот N.
Да, и что?
Мы, у нас, мы откладывали на каждой тратце алгоритм монетами, и потом взяли и все их потратили.
Должно же, в суммарности, должно получиться Nlog N.
Ну, ну не должна, просто да.
Ну, сформулирован тут как бы такой, тут такая тонкость, что, в принципе,
то есть фишка в том, что, что, да, эти учетные стоимости могут быть даже отрицательными.
Нет, я понимаю, что не могут, но я имею в виду, что вот, допустим, у нас C-шки были единицы,
но при этом мы на каждой получали лабиринт монеток.
И что?
А потом взяли и на последние итерации все, все, все, все монетки вообще потратили.
У нас был Nlog Nmonet, мы потратили, но при этом сумма всех C-шек равна O от N,
а в настоящем мы тратили Nlog Nmonet.
А сейчас мы получили то, что 8.O от N, а не O от Nlog N.
Ну, значит, ну просто у нас, да, тут оказалась просто такая отрицательная C-шка.
Правда, Канира Нот?
В смысле, если мы потратили в один момент Nlog Nmonet...
Да, мы же в один момент последний, в последние операции мы потратили Nlog Nmonet все.
Если мы их потратили, значит, что мы сделали O от Nlog N операции только на последний раз, да.
Ну да.
Это уже минимум 8.O от Nlog N будет.
Да.
Потому что мы только за последнюю операцию стоим.
Да, вот когда мы считаем суммарную, а мы считаем все точки для каждой из операций.
Сейчас, сейчас, чего еще раз?
Сейчас не слышу ничего.
Когда мы считали учетную стоимость, мы считали ее для всех операций, суммарную.
Но...
И мы сказали, что суммарная, учетная стоимость меньше, чем O, больше O равна, чем стоимость каждой из операций.
Ну скажи так, сумма учетных стоимости больше, чем сумма реальных, правильно?
Получается, мы получили...
Как бы...
Как нам из этого вы занесли точку для каждой из операций?
Ну, в смысле...
Ладно.
Нет, в данном случае просто смысл анализа будет в том, что просто показать, что каждая учетная стоимость для каждой операции будет не превосходить чего-то интересного.
При том, что у вас есть фиксированный способ действительно получения дачи монеток, фиксированный алгоритм.
У вас хуже курс покупки действий за монеты и покупки монет с действиями, он одинаковый, да?
Ну, конечно.
А, чего? Где? Давай.
Ну, да.
Ну да, прям эквивалентно, да.
Нет, ну не совсем так.
Хотя да, так на самом деле.
Да, ну это просто, видите, смысл такой, что у нас просто как бы...
В смысле?
Вот сам последний.
Все правильно.
У тебя, если что, вот эта сумма, она больше либо равна, чем реальная.
Ну поэтому да, вот эту вот сумму можно оценить сверху как вот это.
Она равна реальному, значит, что мы тратили монеты.
Если она равна, значит, мы ничего не тратили, ничего не получали.
То есть как бы...
Его мы потратили просто все, которые мы получили.
И что?
Ладно, я потом.
Ты за каждое действие получаешь столько монет, сколько ты...
Ты считаешь, что ты за каждое действие получаешь одну монету?
Нет, смотри, мы видим, что мы в функции можем получать монеты, а не константы.
Нет, просто...
Чего?
Так, ребят, чего я не слышу ничего?
Так, Денис!
Да вот слушай, вообще не слышу.
Так, можно еще раз тут...
Ну да.
Ну...
Ну не совсем так.
Формально в анализе мы можем потратить монетку и больше.
По большому счету это означает, что...
То есть тут парадокс в том, что мы можем выдавать полагарифму монеток,
а потом их потратить и в сумме получится хорошо.
Но просто это будет означать, что эти монетки просто никуда не пошли.
То есть ими ничего не оплачено, они и были потрачены в холостую.
В смысле? Подождите, подождите.
В смысле? Подождите, почему?
Вот почему они были потрачены в холостую?
Мы получали мы по log n монеток.
Да.
И в итоге потратили их все.
Но это значит, что мы суммарно потратили n log n монеток,
а мы потратим одну монету на от единицы операции.
Почему?
Мы можем потратить монеты не на что как раз.
Если мы потратим монеты на от единицы операции,
тогда у нас клиенты меньше в равномерном центре и примерно не работают.
Если мы фактически тратим монету на от единицы операции,
мы потратили все n log n монеты.
У тебя нет операции, на которые ты можешь потратить n log n монет,
если у тебя в суммарную действие от n.
А я ей говорю, что это суммарно не у от n получается.
Нет, вот так, суммарно это получится может и у от n.
То есть другой вопрос, что тогда анализ будет говорить так.
Мы хотим, чтобы при нашем алгоритме,
мы говорим, что учетная стоимость не превосходит,
вот эта штука будет не превосходить.
И тогда нам придется это сверху оценивать,
каждую эту операцию, как логарифом.
Очень простой пример.
Цейта равно единице, но при этом на каждом шаге мы зачем-то
даем логарифам монеты, а в конце тратим n log n.
Понятно, что алгоритм работает все равно за от n,
сколько бы мой монет не потратить.
Потому что сами по себе ничего не символизируют.
Ну если ты их на дело потратишь в конце n log n.
Ну ты не сможешь потратить в n log n монет на дело,
если всего от суммацеитов это n.
Ну так ты просто выбирай по одной монетке.
Если она работает за от n, то верно, что она работает
за от n log n.
Еще раз.
Ну вопрос, чтобы это было в излишестве.
Обычно просто в анализе это будет немножко не так выглядеть.
А кто сказал, что суммацеитов на сцену вообще?
Нет, ну как пример, если мы там делаем тупые какие-нибудь
единицы операции типа там, ну я не знаю, типа ничего
и просто добавляем логарифам.
Ну там, допустим, у нас каждая операция, допустим,
в структуре данных это напечатает на экране Hello World.
То как бы да, можно проводить анализ в духе, что мы там
на первой сколько-то операции каждый раз еще получаем
по логарифам монеток, а потом в конце неожиданно решили
эти монетки слить.
Вот, но неожиданно решили потратить.
Ну и да, и суммарно все равно получится с учетом этого
слива, что это суммарно работает за от n.
Да, правда, но при этом просто в анализе это будет
так не выглядеть, почему?
Потому что да, мы тут, смотрите, да, мы тут действительно
анализируем вот эти учетные стоимости, да, но как бы
помним, что при этом, что просто, но при этом просто
логика именно в том, что мы как бы вот эти вот отрицательные
стоимости никогда не вписываем.
И при этом анализе получится, что n операции будут работать
за o от n, но при этом, при тех же самых как бы p-шках
получается первая n-1 операции при этом сработали
за n лог n.
Потому что учетная стоимость каждой из этих операций
оказалась логарифом.
Ну просто потому что верхняя оценка такая у нас.
Поэтому отсюда там действительно вылезет, что может
получиться, что в доказательстве, что этот алгоритм
при таком вот таком не очень точном анализе работает
не более чем суммарно за n лог n.
Потому что каждая операция работает не более чем за
логариф.
То есть это просто не точное, то есть это на самом
деле это будет просто пример неточного анализа.
Вот, то есть на самом деле можно проанализировать
поточнее и обнаружить, что на самом деле там все
за линию работает.
Вот у нас нельзя какой-то конструкции, какой-то
неточный монет выдать, и мы обязаны задавать
логарифы.
И тогда у нас точно n-1.
Ну это другой уже вопрос.
В какой момент мы тратим квадрат с элементом?
Ну в какой решаем, в такой тратим.
То есть это как бы метода.
Вот мы решили потратить, вот на n мы Hello World, мы
решили потратить все монетки в данном случае.
Это не более чем метод анализа такой.
То есть это абстракция.
Да, конечно мысль про алгоритмы не хочет,
потому что хочется мыслить в алгоритме, что давайте
когда мы делаем что-то, мы получаем фиксированные
какие-то монетки или тратим фиксированные монетки.
Но на самом деле в данном случае мы просто по другому
поступили.
Мы мысли на себе сказали, что давайте вот именно
на n-ую операцию мы действительно все монетки потратили.
И тогда у нас, да, тут все учетные стоимости алгоритм,
а тут учетная стоимость минус n лог n, поэтому сумма
адекватная.
Ну типа.
Это алгоритм, метод, который для размышления
или для доказательств?
Ну для размышления, хотя и для доказательств,
он вполне себе тоже подходит, потому что очень удобно
описывать алгоритмы в духе, что давайте скажем, что
действительно мы каждый раз, когда кладем элемент
на стэк, кладем монетку.
В данном случае, то есть на практике еще раз, как это
выглядит, то есть на практике это будет выглядеть так,
что мы на каждый элемент кладем монетку,
а потом каждый раз, когда этот элемент перетаскиваем,
мы это перетаскивание оплачиваем.
И тогда получается, с одной стороны, не оплаченных
действий у нас у отн суммарно, а оплаченных
тоже у отн, почему? Потому что мы
получили всего n-монеток.
То есть смотрите, оплаченность
где она берется, то есть
здесь, смотрите, получается, здесь следующее,
что такое неоплаченные действия?
Неоплаченные действия на каждом шаге, это CIT
минус QIT, по сути.
То есть, как бы, часть этих действий, которые тут
выполнялись, мы оплатили.
Ну, отсылка с точки зрения
доказательства строгости и понимания, что это такое,
да.
Именно.
То есть, на самом деле так, это техника,
которой удобно это делать, не более того.
Да, то есть это просто техника.
Сейчас я расскажу еще одну,
которая тоже можно удобно что-то доказывать,
именно по той причине.
Давайте попробуем.
Что мы остановились, что мы тут, собственно,
обсуждаем.
Давайте попробуем так.
Еще кратенько пробежаться к тому, что у нас было.
Итак, какая у нас сейчас
основная цель?
Сейчас мы разрабатываем, на примере, очереди на двух стэках.
В первую очередь, действительно, методы,
которые позволят нам говорить
об структуре данных, что несмотря на то,
что отдельные процедуры
работают долго,
там отдельные какие-то операции,
в сумме все работает адекватно.
Вот.
А именно, это означает следующее,
что у нас есть структура данных некоторая,
и мы есть с нуля, есть какое-то нулевое состояние,
обычно характеризующееся тем, что там никаких элементов в ней нет,
в первую очередь.
И реальные времена этих n операций,
то есть, сколько в реальном времени
они выполняются, сколько тактов процессора или там
что-то еще в этом роде, это c1, c2, c3,
и так далее, c.
Ну, какая цель вообще любого анализа структуры временного?
То есть, мы точных c, конечно, не знаем,
потому что они реально могут зависеть от там
действительно конкретного устройства структуры,
называть каких-то конкретных ее состояний,
то есть предыдущих операций, там иногда фазы Луны.
Хотя нет, алгоритмы с фазой Луны мы обсуждать будем
на втором курсе, как мы уже сказали.
Но от разных вещей, поэтому там точное время невозможно.
То есть, одна и та же, один и тот же pushback будет там работать,
сейчас будет работать 22 тактов процессора,
а потом 28.
Но наша цель – попытаться как-то эти c оценить.
Ну, как бы, в классическом случае
мы просто говорим, что каждая операция,
то есть, например, мы говорим, что там скажем,
в куче какая-то операция insert работает не более,
чем O от логарифма, extract min не более, чем O от логарифма,
get min работает не более, чем O от единицы, melt работает
не более, чем O от логарифма.
Это, типа, вот в худшем случае, поэтому мы отсюда можем
вывести, что в худшем случае сумма всех
операций не будет превосходить в данном случае
плюс bn алгорифм, плюс c, плюс dn алгорифм, да?
Но тут мы обнаружим, что если мы незаметно переходим, то есть если мы
рассматриваем только вот последовательность операций, то иногда мы можем заметить,
что нам далеко не всегда актуально, насколько, то есть верно ли, что прям все
операции работают хорошо. Это только один из методов.
Вот. То есть это только один из методов, то есть типа в худшем случае.
Потому что мы обнаружили, то есть цель амортизационного анализа попытаться
отвязаться от того, что каждая, то есть от того, да, сходите, сходите.
Вот. Почему? 45 минут.
Соответственно. Вот. То есть цель амортизационного анализа,
то есть это сказать, что мы отвязываемся от этой вот идеи, что если какая-то
операция может работать долго, значит все плохо.
То есть амортизационный анализ служит показать, что иногда какие-то
операции могут работать долго, но в сумме все равно все будет хорошо.
То есть наша цель, то есть по большому счету, то есть наша цель это
анализировать сумму. То есть наша цель, то есть мы не знаем эти реальные
стоимости, они могут быть разные, но наша цель доказать верхнюю оценку
теперь не на каждую из этих цешек, но на их сумму.
Это вот о том, чем мы вообще глобально занимаемся.
Вот. Понятно, да?
Вот. Ну вот. То есть, ну, пример у нас оказался очередь на двух стэках,
когда мы понимаем, что N операции в очереди, реализованные на двух стэках,
все равно будет O от N, даже несмотря на то, что каждая конкретно из этих цешек
может оказаться там, T от N.
Вот. Все остальное, что мы обсуждаем, это лишь вот методы доказательства того,
что, вот, какие могут быть методы доказательства того, что сумма цешек,
она адекватна.
Ну вот. Ну, первый метод был вот анализ средним, но по сути он нам просто,
то есть это говорит, что давайте просто вот эту, про эту сумму что-то доказывать,
исходя из каких-то общих соображений, просто вот целенаправленно.
То есть в случае очереди на двух стэках мы просто заметим, что по большому счету
по большому счету мы с каждым элементом делаем не более, чем 4 операции со стэками,
то есть добавить первый стэк, вынуть из первого стэка, добавить из второго, вынуть из второго,
и получается, что с каждым элементом суммарно, ну, на больше мы ничего в этих операциях не делаем,
поэтому в сумме получается, что мы делаем не более, чем 4 N действий со стэкам,
то есть получается, у все, O от N работает.
То есть это был вот такой, это вот действительно анализ в среднем,
ну, то есть в среднем, короче, если они, типа, мы хотим доказать, что они там в среднем всего от единицы будут, но...
Вот, но, как мы уже сказали, бывают и другие ситуации.
Теперь, но можно не обязательно прям эту сумму анализировать в среднем.
То есть можно пытаться от этого отходить.
Вот, и с этой целью мы изучаем вот сейчас метод бухгалтерского учета.
Вот.
Ну, вот. Ну, значит, здесь действительно у нас возникло действительно много вопросов,
потому что, да, ну, вот, то есть попробуем еще раз так вдумчиво посмотреть на это с разных точек зрения.
Вот.
Потому что, смотрите, то есть, значит, точка зрения бухгалтерского учета на пальцах.
Ну, вот, на примере очереди на двух стеках будет выглядеть так,
что у нас есть действительно два стека, in и out.
И мы говорим, что когда мы добавляем элемент...
То есть когда мы добавляем элемент в стек in, мы кладем на него монетку.
Вот, получаем монетку.
Вот. И каждый... Ну, вот.
А когда мы перетаскиваем эти элементы из in в out, то эти монетки стираются.
То есть мы как бы одной монеткой оплачиваем одно действие по перегону элементов.
Вот.
И на основании этого мы утверждаем, что суммарно у нас все будет хорошо.
Почему мы это говорим?
Смотрите, то есть сейчас мы вот, то есть на уровне...
То есть на вот своей уровне житейской логики, да, вот мы сейчас забываем про эти вот формальные описания учетной стоимости.
То есть мы сейчас просто говорим, что каждая CIT можно...
Вот мы делим на две части.
Мы говорим, что это CI оплаченное, плюс CI неоплаченное.
Вот, понятно, да?
Говорим мы.
И теперь мы говорим, что действие, которое мы не оплатили, в данном случае получилось сколько?
В нашем случае получается от единиц, потому что что мы не оплачиваем?
Собственно, добавление элементов stack in, а также доставание его элементов из stack out, правда?
На каждой операции получается их от единицы.
Вот давайте даже эту в табличку запишем какую-нибудь.
Так, где бы нам табличку нарисовать?
Вот давайте смотреть.
Вот у нас какие у нас есть операции?
Вот давайте так скажем.
Вот давайте скажем вот реальная стоимость.
Вот давайте я буду писать реальная стоимость.
Вот.
И теперь тут будет оплаченное, а тут будет неоплаченное.
Вот, можно так.
И тогда смотрите, вот у нас есть push в нашей очереди.
Есть операция pop обычной.
И есть операция pop с перекладыванием.
Ну то есть вот тот самый сложный pop, который вот перекидывает, да?
Значит поехали.
Push у нас за сколько работает?
Push, смотрите, реальная стоимость push это 1.
Но я тут ошки не буду писать.
Вот.
Сколько мы оплачиваем?
Мы ничего не платим.
То есть мы да, пишем 0 в данном случае.
То есть мы ничего не оплачиваем.
То есть мы только получаем монетку в данном случае.
Ну вот.
Ну вот.
И не оплаченных соответственно вот то самое одно действие.
Ну то есть вот это плюс это должно быть вот это, да?
Теперь pop обычный.
То есть предположим, что мы сказали, нас попросили достать элементы,
мы полезли в stackout и обнаружили, что их там есть.
Но тогда абсолютно та же ситуация.
Мы ничего не платим.
А сколько работает pop с перекладыванием?
Он работает за...
Ну сначала вы делаете перекладывание за от k,
где k количество элементов в стеке in на момент начала операции, да?
То есть количество push с последнего перекладывания.
Ну да.
Нет, ну не-не-не, почему последнее перекладывание?
Ну после последнего перекладывания сколько push было?
Ну да, можно и так сказать, но это нам сейчас даже не принципиально особо.
В принципе, да.
И еще все-таки добавим плюс один.
Ну потому что k могло быть равно нулю на самом деле, да?
Ну вот на всякий случай там один напишем.
Но этот один просто будет помещать, что у нас есть то самое одно действие,
которым мы элементы из аута достаем.
А что?
Ну понимаете, это вопрос константы.
Понимаете, да.
Ну можем написать тут 2k, если хотите, конечно.
Нет, пока мы никакие монеты вообще не вводим.
Ну, точнее так, не-не-не, тут мы никаких монет не учитываем.
Другой вопрос, какую константу мы тут вводим?
То есть да, нам, наверное, логично сказать, что если у нас за одно действие
мы делаем один пуш или один поп, то, наверное, давайте напишем 2k.
Хотя по большому счету это не принципиально, потому что это верхняя оценка.
То есть это такая.
Ну теперь смотрим, сколько мы оплачиваем.
Вот, ну здесь вот с 2k возникает такой момент.
Заметим, что мы платим k монет.
Но правда заметим, что как бы тут вопрос в курсе валют,
потому что, в принципе, вместо одной монетки мы можем и две монетки положить.
Правда?
Поэтому мы говорим, что давайте вот кладем теперь по две монетки,
если мы объявили, что стоимость прикладывания одного элемента в другое это 2,
это 2, а не 1.
Поэтому пишем здесь 2.
И последнее действие, да, это не особо принципиально,
но просто раз уж возникает вопрос, давайте это вот скрыть.
Смотрите, ну просто психологически, видимо, удобно так, смотрите,
что мы говорим, что вот здесь положить элемент в стек это одно действие,
и достать элементы в стек одно действие.
А тут мы одной монеткой оплачиваем как бы доставание элемента из стека in
и помещение его в стека out.
То есть поэтому логично два писания.
А в том числе действие оплачено и получено?
Да, реальная стоимость, это сколько оплачено, сколько не оплачено.
И теперь как анализировать сумму, да?
Можно анализировать, что...
Смотрите, то есть как теперь анализировать действительно сумму?
Можно анализировать, что у нас есть push,
допустим, если у нас тут есть a push, b pop и c pop с перекладыванием, да?
Тогда по реальной стоимости у нас бы получилась асимптотика,
не превосходящая a, плюс b, плюс c умножить на вот этих вот k.
Я могу так написать, max k.
Обычно в классическом анализе мы говорим, что это k,
не происходит какого-то максимального k.
Ну понятно, от k, конечно, но не суть.
Но это max k у нас не превосходит, конечно же, n.
И более того, легко достигнуть пример, когда это бывает.
Поэтому в таком анализе мы ничего не можем сделать,
как сказать, что это a, плюс b, плюс c.
Вот так.
А так как у нас c не превосходит только n,
то это получается не превосходя n квадрата,
и получается оценка, что это все работает за вот n квадрат.
Да, это верное утверждение.
Но не точно.
Потому что сумма всех кашек у нас не равна сумме.
Да, потому что...
Ну да, то есть на самом деле да.
То есть с точки зрения среднего можно было сказать,
что на самом деле тут правильно было бы написать не c,
а сумма всех кашек на самом деле.
А она меньше или равна?
Да, можно было так написать.
Но мы сейчас анализируем по-другому.
Мы сейчас анализируем... У нас теперь рассуждение такое.
Потому что смотрите,
вместо того, чтобы суммировать реальные стоимости,
мы суммируем, что оплачено и что не оплачено.
Правда?
Поэтому теперь суммируем.
То, что не оплачено,
это откровенно a, плюс b, плюс c, то есть n.
Да?
А теперь оплаченное.
Заметим теперь, что каждая оплаченная не превосходит...
Ну то есть сумма оплаченная,
так как у нас мы никогда не тратили монетки,
которые не получали,
то получается, что здесь у нас получается,
что... Ну то есть здесь даже уже не важно,
конкретно тут 002k, это даже не важно.
Важно то, что сумма всего оплаченного,
то есть вот давайте я так буду писать.
Вот сумма всех циитых, она равна.
Сумма циитых неоплаченных,
плюс сумма всех циитых оплаченных.
Вот.
Рукопрохальство получается,
нам все равно нужно проверять,
что на каждом префексе не отрицается.
Ну да, мы говорим, что оно логическим образом спорится,
и ничего не говорим о том, почему.
Нет, в смысле, не понял,
почему рукопрохальство?
Мы будем все равно проверить,
почему у нас на каждом префексе не отрицается,
чтобы вообще корректно было.
Нет, смотрите, тут другая логика.
Тут нету никаких префиксов.
Так, вот в этом рассуждении, внимание,
никаких префиксов нет.
Есть просто утверждение о том,
что мы никогда не тратим монет больше,
чем получаем.
То есть смотрите, пока это...
Заметим так.
Ну, оно у нас работает по той причине,
что мы как бы для каждого элемента
монетки, которые мы тратим для его переноса,
находятся прямо на нем.
По сути, доказательство этого утверждения,
которое нам нужно для этого доказательства,
уже есть по сути доказательство всей задачи.
То есть мы ничем не упростили жизнь?
Нет, я просто показываю
разные методы мышления.
Нет, понятно, что с точки зрения того,
чтобы доказать, что там в среднем
все работает, в статах
мы делаем бесполезную работу.
Мы не для этого сейчас это...
Мы это делаем для того, чтобы понять,
как еще можно мыслить.
Потому что в большинстве ситуаций
вот так вот вы застрелитесь мыслить.
Потому что нельзя, там будут
сильно более сложные структуры.
Вот тот же вектор, например.
Ну, чуть позже обсудим.
Ну, скажем так, там
вам будет гораздо сложнее
прямым образом
доказывать, что там
суммарное количество действий ОАТМ.
Вот.
То есть там какую-нибудь сумму степеней двоек
вы, конечно, там можете расписать?
Но не будет.
Вот сейчас я поэтому и показываю.
То есть, смотрите, другой метод, просто другой.
То есть вместо того, чтобы доказывать
в среднем, мы говорим, что сумма цих
это неоплаченная и оплаченная.
Значит, теперь мы говорим,
мы пользуемся тем,
то есть это как бы то же самое, что
сумма неоплаченная
плюс сумма
выданных монеток.
Так.
Вот.
И в принципе, на каком-то уровне можно остановить.
То есть в данном случае можно было так и сказать,
что в нашем случае
неоплаченных действий, как мы уже поняли,
Н, ну там ОАТМ,
а выданных
монеток у нас тоже ОАТМ,
потому что мы на каждый
нот, потому что мы там на каждый
пуш кладем
две монетки.
Понятно, да?
То есть в данном случае
можно было доказывать вот таким образом.
Вот.
Теперь переформулировка того же
самого, теперь еще более формальная,
может выглядеть так, что давайте
введем учетную стоимость.
То есть смотрите, вот теперь
это мы отсекли, вот так вот, да,
это мы тут с этой стороны смотрели.
А теперь можно ввести следующее.
Теперь мы говорим, что у нас рядом
с каждой операцией
мы будем вводить
то есть будем вводить, сколько
на каждую операцию вы должны получить
монеток и сколько потратить.
Это мы должны сначала подогнать, чтобы потом доказывать, да?
Ну, скажем так, чем лучше подгоните,
тем лучше результат получите, да.
Но при этом
есть оговорки.
Оговорки заключаются в том, что
у нас все еще действует,
как бы принцип, что мы не тратим
монеток больше, чем получаем,
превращается вот в такое неравенство.
Вот. И это неравенство
приводит нас к тому, что
ну вот, то есть
из этого неравенства следует,
что сумма вот таким вот
образом введенных учетных стоимости
оказывается больше либо равна сумме реальных.
То есть для чего
мы это делаем? То есть делается это
мы не знаем реальных стоимости,
но мы знаем, что мы их сумму реальных
стоимости можно оценивать сверху
учетными стоимостими.
И поэтому
получается, что
если мы как бы сумеем подогнать
правила игры так, чтобы
сумма, чтобы каждая учетная
стоимость была у от единицы, то тем
самым мы докажем, что
суммарно все это работает за у от
n операции.
В данном случае это будет выглядеть так.
То есть теперь сейчас
рисуем примерно ту же таблицу, но
в профиль. Смотрите.
То есть тогда у нас технология
будет звучать так.
Итак, push, pop
и pop
с перекладыванием.
Она будет вот так звучать.
Пум-пум-пум.
И значит поехали.
Итак, пишем. Вот есть у нас
как всегда реальная стоимость.
Есть вот это вот полученные
монетки.
То есть PIT.
Давайте так.
PIT полученные монетки, QIT
и соответственно учетная стоимость.
Давайте я так и буду так описать.
Тут CIT, тут соответственно CIT.
Вот такое.
Значит поехали. Push.
Мы будем объявлять, что
мы будем делать одно действие
в push
и получать, как мы договорились,
2 монетки.
Понимаете, да?
Отратить ноль.
В результате учетная стоимость
оказывается 3.
Да, то есть обратите внимание,
учетная стоимость здесь оказалась больше.
Да.
Но к чему нас это приведет? Теперь pop.
Что у нас происходит с pop?
Чего?
Ну pop обычный конечно.
Да, за единицу.
Но мы говорим, что мы
монеток за это не получаем
и не тратим, поэтому учетная стоимость остается единицей.
И вот начинается
самое интересное.
Если произошел pop с перекладыванием
размера k, то есть мы переложили
k элементов,
то мы объявляем следующее.
Мы объявляем 2k
плюс 1.
То есть это реальная стоимость, да?
При этом
мы ничего не получаем,
но зато тратим
2k монеток на этот раз.
Вот.
Наконец-то мы что-то потратили.
Вот. И тогда
учетная стоимость оказывается
единица.
Вот.
То есть смотрите,
в принципе то же самое.
Этот анализ, конечно, остается
как бы понятно, что для этого
надо только показать, что мы никогда не работаем
в долг.
Потому что если мы предполагаем, что мы тут пишем что угодно,
мы тут всегда пишем тут ноль, а тут что-нибудь большое,
то мы про любую структуру могли бы так сказать,
что учетная стоимость вот единиц.
Но никакого физического смысла
в этом нет. Это будут просто абстрактные,
никак не связанные с реальной структурой данных
ее временем работы цифры.
Там, накрученные показатели какие-то.
Значит нужно доказать, что в любом претексе
да, то есть
ну или что то же самое надо по-любому доказать,
что мы никогда не тратим
больше, чем мы получаем.
А доказать это очень просто.
Ну в нашем случае.
Потому что доказать очень просто. Я говорю, что давайте
мы на каждой
просто эти два или эти две
две монетки будем класть вот скажем
на элемент вот в первом стеке.
А как это формально написать, типа
что мы вводим функцию, связанную с элементом, или что?
Кажется, что можно
Нет, в принципе в смысле
Ну в смысле, как вот это вот, типа
наше интуитивное представление, что вы положили две монетки
на каждый элемент? Скажем так, пап,
оно до самом деле, оно достаточно интуитивно
оно мне кажется достаточно понятно.
То есть не больше, чем количество элементов, которые
ты в целом положил.
У нас же будет еще трески с пластом?
Будет. Но кстати, может быть он
этой формальностью и займется, но
мне кажется, что он скорее запутает.
Потому что в данном случае, то есть вот это
такое рассуждение в данном случае кажется максимально понятно.
Можно разбить
можно разбить
префикс по попам с перекладываниями.
Тогда если на
префексе
до было сумма больше
рано нуля, то
доказать, что на новом префексе
в новом отрезке будет сумма
тоже больше рано нуля. Ну будет.
Ты собираешь на отрезке между попами?
Да, на отрезке между попами с перекладываниями.
Приложу пример, когда твоя рулупина
сначала все пуши,
а потом начинается попа с перекладываниями.
Да, и ты разбиваешь
весь свой отрезок работы
на попы с перекладываниями. Да-да.
И тогда если ты на первом докажешь, что там больше рано нуля,
то на втором тут у нас
на первом префексе. Нет, но по большому счету да.
Но я не знаю, то есть просто
мне кажется, когда вообразить в себе, что мы положили
монетки, это самое уже удобное.
То есть можно там, конечно, формально
что-то там требовать, что пусть у нас в кошельке
написано какое, то есть там докажем, что
то на момент попа с перекладыванием размера k
у нас в кошельке
будет не менее чем 2k монет.
Ладно, для красоты лучше просто докажем,
что их ровно 2k. Там
доказательства. Для этого мы докажем,
что
для этого мы докажем просто, что
там можно формально там писать, что
на самом деле у нас количество
монет, которые у нас в кошельке, равно 2
умножить на текущий размер stack in.
Честно, по индукции
прям доказательств. Так если вы любите
вот такие формальности,
ну, честно скажу,
в данном случае, честно говоря,
они не очень понятны.
Просто не очень понятно зачем.
А вы будете принимать решение
с 2 монетки, наверное?
Да.
Не, зря на самом деле.
Ну, смотрите, понимаете, тут на самом деле
действительно такой баланс это все происходит.
То есть действительно, что это может показаться
кому-то кажется формальным, кому-то кажется
неформальным.
Ну, вот действительно есть такое.
То есть у нас тоже конечно
я, по идее, compromise
формальности, но здесь вопрос такой.
Зачем формальность нужно,
в принципе.
То есть на самом деле
формальность
на самом деле нужна, для того,
чтобы
как минимум один человек понял другого
вот.
Но и для того, чтобы
суждения были абсолютно строги.
Чтобы не рукомахаться, то чего-то не было.
Ну вот.
Нет, ну практически да.
Нет, ну это зачем нужна строгость?
Ну это как, типа, заказывать, что корень из двух,
ну да.
Ну там как угодно, да.
Ну можно, да. Ну в конце концов, что тут?
Древние греки просто когда-то
геометрические доказательства сводили
к рисованию чертежа и говорению слова
смотри. Вот типа
очевидно. Вот.
Правда, там, потому что они же даже убедились,
что оптический обман никто не отменял,
но, соответственно.
Но это зачем нужна строгость? Ну, как бы вы уже
поступили на фисте, думаю, как бы у вас есть уже
адекватное представление о том, что такое
достаточно строгое доказательство.
Ну дальше
начинается фактически действительно понимание
выливания воды из чайника, ну даже скорее,
начинается метода вида решения
существует.
То есть как бы строгость потребуется,
то есть если вы там, то есть обычно
строгость в данном, то есть если мы
вот, то есть
строгость нужна, то есть в данном
случае, почему она нужна?
Потому что, например, да, вот вы мыслите в каких-то вот
категориях, что действительно там понятно, что
можно довести до строгости, ну и так понятно,
но вы рассказываете соседу,
а сосед не понимает.
Да, этим соседом чаще всего бываю я.
Нет, это нормальная ситуация.
Не потому что там, я не знаю, я там
называю это, я там тупой или нетупой,
называется, а потому что я
мыслю по-другому, вообще.
У меня в голове может быть там картинка принципиально
отличается от вашей.
Вот.
Это, ну вот, собственно,
это нормальная ситуация, собственно,
собственно, именно для этого, то есть может
потребоваться формализм.
То есть в данном случае как бы если у нас вот
одинаково, то есть если мы действительно
друг друга поняли, да, в данном случае,
то есть если, например,
вы уверены, что вы там вот это вот,
положим две монетки
на, называется, на элемент, можем
собственно себе адекватно понять,
и я это тоже понимаю, что действительно там
доводится до формализма, но там
действительно образ понятен, то тогда
тогда все в порядке, мы собственно на этом языке
спокойно договариваемся.
Вот. Но, соответственно,
если выясняется, что, скажем, вам
что-то понятно, допустим, нет,
или наоборот, то нам
тогда с вами приходится,
тогда приходится договариваться
в более формальном языке, если как бы цель,
чтобы один человек там убедил
другого, то есть там убедил другого, то есть
предъявил адекватное доказательство.
Вот.
То есть на самом деле, то есть вот так
таков вот на самом деле,
то есть смысл формализации.
То есть, да, давай.
А как вы еще доказали, что за линией все работает?
Потому что каника вскроет кредит архитектуры
до... Ну, мы доказали
так, но в данном случае мы сказали,
что, смотрите, ну, мы уже знаем
что если у нас
сумма кушек
никогда не превосходит суммы пэшек,
то мы знаем, что
сумму учетной стоимости
суммарно мажорирует сверху сумму реальных.
А мы предъявили,
что, во-первых, значит, сумма
учетных стоимости оказалась
от 0 от n, потому что каждая из
учетных стоимости оказалась от 1.
Да, 3 это от 1, да?
Вот.
А с другой стороны, мы доказали, что
то есть как бы
помещение монеток на элементы
мы доказали,
что сумма кушек
всегда меньше либо равна суммы пэшек.
А сумма пэшек, с другой стороны,
у нас откровенно 0 от n.
Почему? Потому что она не превосходит 2 умножить
на n. Потому что мы на каждом
шаге получаем не более чем 2
монетки.
Что-что?
Нет, ну, смотрите,
нет, ну, как сказать?
Что значит не всегда так можно?
Ну, почему? Нет, ну, всякое
бывает.
Нет, ну, иногда, ну, тот по-разному.
Иногда получается, иногда нет. То есть как бы в данном случае
нам повезло, что нам удалось подогнать
удобный, просто
удобный и понятный алгоритм
получения и
получения монеток и оплату ими чего-то.
На самом деле, что смешно,
пуш тоже работает амортизированно,
просто мы об этом и молчали.
Не, почему? Ну, не совсем.
Стек же тоже амортизированно пушит?
Ну, это уже другой вопрос,
как стек работает. На самом деле, нет.
Ну, если стек у вас
на указателях работает,
то там у от единицы честно.
Ладно, с оговоркой, конечно, что там выделение памяти
реально за у от единицы происходит.
Но это...
Что-что?
Ну, реально обычно там во всех адекватных
падениях считается, что выделение,
динамическое выделение памяти работает за у от единицы
все-таки. Вот, поэтому это не проблема.
Вот, да.
А дек может реализоваться
с помощью стеков или очередей?
Дек...
напряжен.
Ну, я не знаю. Это мне, по крайней мере, неизвестно.
А что там за мега алгоритм,
про очередь
не амортизированной пяти
на шести.
Ну, вот это обсудим, дойдем и до этого.
Это у нас...
Это все будет, не волнуйтесь.
Вот.
Значит, это вот были примеры. Значит, теперь...
Значит...
Ладно, теперь, значит, сейчас мы введем такой...
Так, ребят.
Значит, смотрите. Сейчас мы попробуем...
То есть, на самом деле, сейчас мы реализуем
третий метод анализа того же самого.
Вот. Давайте вот попробуем.
Значит, третий метод
будет называться...
Так, сейчас, где у меня...
голубой маркер...
Вот он.
Он так и будет называться.
Метод потенциалов.
Во.
Метод потенциалов.
Метод потенциалов.
Значит, говорит...
Ну, то есть, занимаемся мы тем же самым.
У нас есть операции, у них есть реальные стоимости.
Мы их сумму пытаемся каким-то образом
оценить.
Но теперь мы
мысли начинаем немножко по-другому.
Раньше мы говорили, что мы
при каждой операции
получаем какие-то моменты во время операции
и тратим какие-то монеты, да, в процессе.
А теперь
мы будем говорить не о
операции,
но о состоянии структуры
между операциями.
Её мы будем характеризовать
некими мистическими
числами.
Вот.
То есть, по сути, мы вводим
некоторые мистические
числа.
Фи-ноль, фи-один, и так далее, фи-ен.
С точки зрения формальной математики,
это просто некоторые
числа с некоторыми ограничениями.
Какими ограничениями?
А очень простыми.
Ну, мы будем... Ограничения
очень простые. Все фи...
Все фииты больше либо равны
нуля. И равно
ноль, один, и так далее, н.
И ещё
мы должны точно знать, что фи-ноль
равно нулю.
Вот.
И всё.
То есть, просто такая последовательность.
В реальности, то есть, это будет
чаще всего, это будет какая-то функция
состояния.
Функция состояния структуры.
И говорить...
И в этом случае мы говорим так,
что теперь у нас вводится учётная
стоимость теперь, c1, c2,
c3, и так далее.
И будем
говорить, что c и t, определение
очень простое. Это реальная
стоимость.
Плюс
потенциал
на момент начала операции,
минус
потенциал
на момент конца этой операции.
Вот
такую
учётную стоимость
мы введём.
А
видите, мы тут с нуля начали.
А c мы тут с единицы
нелеговали.
Нет, если вы будете с...
Тут и минус один, тут и...
Так вот.
А разве вы будете
и минус один?
Чего?
Да, вы
можете путаться,
что вы читаем,
а что прибавляем.
А, может
я и путаю, кстати.
Да, смотрите.
А теперь
смотрите, как это не перепутать?
Как проверять?
Проверять очень просто.
Зачем мы вообще эти учётные стоимости
вводим?
Глубокий смысл имеет
в этом только, если сумма
цитых больше либо равна, чем ци.
Чтобы этими суммой
учётных стоимости можно было
мажорировать сверху сумму реальных стоимости.
Давайте проверять.
Вот я ввёл вот такую
штуку.
Тогда сумма цитых
учётных равна
сумма ци плюс
фи н минус один минус фи.
То есть это равно.
Тут сумма вот такая.
Тут пишем сумма в секции цитых
плюс фи н
минус фи один плюс
фи один минус фи два
плюс и так далее.
Фи н минус один
минус фи н.
Здесь высекает всеми любимый
шлёп-шлёп.
Шлёп-шлёп.
Тоже шлёп.
Сейчас, так, что-то не то.
Да, минус один, да, минус плюс.
Тут минус плюс.
То есть получается, что это равно?
Просто сумма всех цитых плюс
фи н минус фи н.
Вот.
Да, но нам хотелось, чтобы
это было больше либо равно,
чем сумма цитых. В данном случае это не так.
Как это поправить?
Очень просто. Давайте всё-таки будем
прибавлять потенциал в конце и вычитать потенциал в начале.
Вот.
Тогда в этом доказательстве получается
минус вот, плюс вот.
Минус вот, плюс вот.
Тут тогда получается минус,
тут получается минус, тут получается плюс.
Тогда здесь получается минус,
здесь получается плюс и вот то,
что надо. Видите, зачем мы вводили,
что фиенная больше либо равно фи 0?
По большому счёту нам для этого анализа
достаточно было требовать, чтобы
фиен был больше либо равно фи 0.
но не случайно вот физики швы помните что физики сам по себе потенциал обычно
значение не имеет имеет значение разность потенциалов да то есть по
большому счету в общем-то как бы это доказать что будет работать и ко всем
потенциалам прибавите там 179 вот соответственно вот ну вот то есть
получается если вам удастся подогнать потенциалы собственно обладающие вот
таким приятным свойством то есть то есть теперь метод потенциалов говорит что
чтобы доказать что скажем сумма чтобы доказать что там все что сумма всех
этих операций равна от н нужно подогнать такие потенциалы чтобы вот
это вот учетная суббота вот эта вот штука была всегда вот единица ну или там
если вы хотите ученые но или подать потенциалы так чтобы у каждого экстракт
мина например здесь получался логарифом а у всех остальных получалось единиц
ну у каждого экстракт мина то есть допустим это операции с кучей фибоначи да
тогда значит вы докажете что учетные стоимости операции такие если вы
доказать подогонять сумеете подогнать такие потенциалы удовлетворяющие вот
этим условиям так чтобы учетная стоимость каждого экстракт мина была не
превосходила от логарифма а учетная стоимость каждого инсерта гетмина или
мэлда была вот единиц да ну типа того да вот то есть для очереди на двух
стэках это может выглядеть например так вот то есть ну ну давайте так нет ну ну
давайте мы сейчас мы сейчас отвлеклись от вонеток мы пытаемся мыслить без
монеток и мы говорим что фи и т это будет равно ну допустим ладно два умножить на
сайз вот этого стека им то есть объявим это потенциалом тогда давайте посмотрим
значит как у нас тогда это будет работать вот давайте проанализируем то есть как
бы вот смотрим это вот как нам вот способ мышления то есть как бы тогда то
есть нам вот удается так подогнать значит к чему нас это приводит приводит нас к
это следующему это нас смотрите внимательно значит приводит к тому что
смотрите значит смотрите то есть мы рисуем опять ту же табличку push pop и
соответственно там поп обычный и поп с перекладыванием к значит рисуем с и т она
равна чему но тут просто честно там переписываем 1 1 2 к плюс 1 как было
раньше вот теперь смотрим внимательно потенциал фи и минус первое ну вот чего
но вот но чему он мог быть равен ответ чему угодно поэтому так и пишем x x x да это не крестик
это x ну какое-то непонятное число да хотя ладно оговорочка хотя ладно вранье тут у нас да
мистический факт заключается в том что если мы делаем поп с перекладыванием к то на момент
этого перекладывания потенциал был в точности 2 к логично да ну мы это точно знаем потому что
как то есть есть у нас поп с перекладыванием к элементов это означает что на момент начала
этой операции у нас в стеке им было к элементов а в стеке аут было 0 элементов поэтому здесь мы
железно пишем 2 к а здесь мы пьем вот а здесь какой-то x непонятное
ой ладно кстати давайте еще 2 x напишем чтобы совсем понятно было потому что подон салмы
видите размер не просто размер стэка размер стэка умножить на 2 нету вот это нас не от
предыдущего а состояние на момент начала операции ведь это как раз и минус первое теперь смотрим
что у нас на момент кончания в пуше твоя получается 2 x плюс 2 поп обычный ничего не меняет 2 x поп
с перекладыванием 0 потому что у нас этот стэк опустевает теперь смотрим что же у нас получается
в учетных стоимости а но опять-таки начнем с того что а то теперь давайте смот да то есть все
потенциал у нас всегда больше либо равен нуля изначально он равен нулю очень приятно правда
это прямо уже отсюда понятно а теперь учетная стоимость ну поехали давайте пользуемся вот
этой формулой да то есть нам что нужно сделать то есть так сейчас так сейчас погодите так а
мы тут да вот тут плюс а нет породить да тут должно быть плюс здесь минус здесь да вот я
вот я и мы здесь просто забыли это поправить вот поэтому ставите тут плюсер тут не все не
перепутать до переча поехали значит то есть у нас должно быть вот это плюс вот это минус
то есть 2x плюс 2 2x плюс 3 минус 2 x 3 но вот тут получается это плюс это минус
это это минус это прям сразу 0 тут одиночи получается 1 здесь получается это плюс вот
это минус это вот и получается у нас опять что учетная стоимость это вот единиц
И это кажется уже можно считать строгим доказательством?
Да.
Ну, и то и то можно считать строгим доказательством.
Просто в одном случае вы обосновываете учетную стоимость тем, что у вас там вы кладете монетки, собственно, на элемент,
а в другом случае вы говорите, что у вас есть вот потенциал.
Да, это как бы более алгеброличное такое доказательство, да.
Да, но более формально как-то выглядит.
Ну, выглядит, да, может быть, но...
Прикольно, что такое.
Да, но, понимаете, вот, да, поэтому...
Но, понимаете, смотрите, есть разница между тем, как придумывать в каких терминах мысли,
и как бы когда это вы уже оформили и вот выдали заклинание.
То есть можно вообще сказать, что потенциал на количество монеток...
Да, то есть, на самом деле, да, по большому счету это одно и то же, на самом деле.
Смотрите, по большому счету, потому что вот эти методы можно легко перетекать друг друга,
просто потому что вот из этого метода можно получить этот,
просто объявив, что потенциал это сколько монеток у вас сейчас есть.
Вот.
Ну или наоборот, если у вас есть метод потенциалов,
то вы про монетки можете просто там говорить, ну, как-нибудь монетки вот обосновать.
Вот, то есть поэтому тут дальше вопрос просто в какой, в каких терминах вам удобно мыслить.
То есть можно удобно мыслить, что у вас у каждого, там скажем,
в каждом момент времени у структуры есть состояние, которое характеризуется каким-то числом,
которое хорошо подогналось.
Вот. А можно мыслить в терминах, что у нас есть какие-то монетки, которые получаются,
которые можно выдавать за что-то и, собственно, потом за это же что-то тратить.
То есть тот вопрос удобства мыши, то есть как бы, да, это идеи на это одно и то же.
Ну, то есть там доказание, то есть как бы понятно, доказываем мы одно и то же.
И, в общем-то, фактически разными словами примерно одно и то же,
но просто вопрос с какой из этих сторон потом удобно прийти к доказательству.
Это уже может зависеть от задачи.
То есть бывает и так, и так.
То есть бывает и так, и так, потому что там в статьях,
потому что в статьях можно встретить там и такие, и рассуждения одного толка и другого.
Так, а методик потенциалов нам же получается нужно еще сказать,
ну, для доказательства линейности всего.
Нам же по-хорошему нужно сказать, что просто у нас размер изменяется в суммаре не больше, чем на 2n.
Нам даже не нужно это говорить.
Почему? Ну, просто если бы у нас было не 2x, а там 2n каждый раз.
Нет, а где мы... Заметьте, мы в доказательстве нигде не пользуемся тем, что этот x это отn.
Обратите внимание.
Просто мы бы могли там добавлять не по 2, а по n, и сказать бы то же самое.
Если ты умеешь добавлять n элементов за одну операцию, то все так работает.
Кажется, что мы сейчас двойку на n заменим,
и у нас доказательство не особо изменится.
Мы опять скажем, что это вот n.
Ну, вообще да.
Ну, нет, в самом-все ничего страшного в этом не будет.
Просто да, поп с перекладами.
Ну, то есть эти операции будут работать за единицы. В чем проблема?
Хотя нет, стоп, стоп, стоп, неправда.
Вранье, неправда, неправда, неправда.
Да, смотрите, если вы кладете по n монеток, то здесь будет nx, а здесь будет nx плюс n.
Ну ладно, тут 2nx будет, и 2nx плюс n.
И, короче говоря, в общем-то, циитая получится n-1.
То есть тогда вы скажете, что push у вас работает за, есть учетная стоимость у отн.
Да, то есть, внимание, тут подлянка, что учетная стоимость операции,
она зависит от того, какой потенциал вы введете.
То есть, если вы введете неудачный потенциал, она может оказаться и у отн.
Но, то есть, когда вы говорите учетная стоимость, то есть вы говорите,
существует там либо потенциал, либо вот эти монетки, что в сущности одно и то же, да?
Ну вот, существует что учетные стоимости, там у push такие, у pop такие, у это все такие.
Но, как бы, смысл тоже тот же самый, да?
То есть, вы доказываете просто, что учетные стоимости такие,
если у вас там типа, говорит, для a, b, c, d, там, ну вот это все, что я повторяю.
Да.
В общем, у нас взялось произведение nx.
А это вот там просто Денис предложил, а давайте предположим,
что мы будем класть не 2 монетки, а n монеток.
Смотрите как, с одной стороны, тут у нас, давайте вот внимательно посмотрим.
Да, тут была, да, тут стоимость, да, 2k плюс 1, тут как бы 2nk, тут как бы ноль.
И тогда здесь получится 1 минус k на 2n минус 2, там что-то получится.
Но, просто, смотрите, просто, как бы,
если все просуммировать будет хорошо,
но просто по факту, просто анализ говорит нам о том,
что давайте оценим теперь учетную стоимость.
Окажется, что учетную стоимость здесь оценивается у нас сверху, в худшем случае, o от n,
а эта отрицательность в худшем случае оценивается как у от единицы,
потому что мы всегда оцениваем чем-то положить, да?
Поэтому получается, что это нам выдает, что пуши и попы могут работать за...
Ну ладно, это ладно, это ладно, это ладно, это ладно.
Поэтому получается, что это нам выдает, что пуши и попы могут работать за...
Ну ладно, этот поп за единицу, но вот пуша, оказывается, за o от n работает.
Нет, мы же достаем элемент не из инового стека, а из аутового.
Поэтому иновый стек не меняется от слова никак.
Так что здесь, здесь как бы 2x2x, и тут было 2nx, и останется 2nx, если что.
Во!
Когда мы делаем обычный пуш, мы добавляем n элементов, да?
Когда?
Или...
Нет!
Не-не-не, это я говорю, это просто...
Нет, это был пример того, что давайте просто потенциалы по-другому введем.
Или монетки будем по-другому класть.
А как мы по-другому?
Ну в том плане, что мы будем класть не по две монетки, а по n монеток.
Ничего этого не изменится?
Нет, от этого изменится то, что наш метод анализа тогда будет гарантировать,
только он скажет следующее, что поп с перекладыванием теперь работает за вот единицы,
но зато каждый пуш работает за вот n.
Это все, что нам гарантирует.
То есть просто, ну вот.
То есть как...
Ну вот.
То есть это просто...
То есть просто можно так сделать, просто вы получите немножко не то, что хотелось.
А!
Не 2nx, а просто nx.
А!
Ну ладно.
Ну...
Ладно, это уже детали.
Да, да, да, вот так.
Ну хорошо, хорошо, давайте.
Ну вот.
Ну учетное время работы, да.
То есть условная вот соговорка, что вот на тему a умножить на это, плюс b умножить на это и так далее.
Вот.
То есть как бы, да, вы доказали, что их можно сейчас оценивать так.
То есть если вы введете более удачные потенциалы, может у вас получится что-то лучше.
Вот.
Но правда, заметим, что как бы у вас сумма учетных стоимости, она все равно это верхняя
оценка суммы реальность, поэтому помните, что там как бы условно из реально квадратичного
алгоритма вы таким образом n log n не выковыряете.
То есть как бы вопрос в том, что вы просто как бы сумму этих цешек как-то вот перераспределяете
между собой, может быть что-то прибавляете, вот просто и там.
Чем лучше получится, тем лучше.
Так, давайте.
Вот между ними с монетками, да?
У нас там было обязательное условие, то что у нас сумма фрешек на любом реекции должна превосходить все лучше.
Да.
А здесь как мы их гарантируем?
Ну.
Не отрицательные?
А тут мы это пропис...
А здесь-то прописано, что потенциалы не отрицательные, а изначально потенциал ноль.
Окей.
У тебя сумма минус сумма, это потенциал тягущий минус ноль.
Ну да.
Нет, то здесь давайте, с точки зрения, если забыть о монетках, то как бы здесь потенциалы не рандомные,
здесь потенциалы вот такие, что фейта больше либо равно лев и нулевое равно нулю.
Это нам дает возможность сказать, что когда у нас тут получится, что вот эта штука реально больше либо равна сумме, чем фейта.
Вот.
Так.
Так.
Ну вот давайте так.
Ладно.
Давайте чтобы это как-то закрепить, давайте попробуем рассмотреть все это на более продвинутом примере.
Да.
Значит мы...
Так.
Значит мы рассмотрим вектор.
Итак, вот давайте подумаем.
Что такое вектор?
Вектор.
Вектор.
Итак, вот давайте подумаем.
Что такое вектор?
Да, да, да, да, да.
Нет.
Нет, это да.
Но в эту сторону мы будем мыслить на втором курсе.
Ну нет, геометрию у нас на втором курсе.
Ну да, просто для того, ну как...
Нет, не то чтобы у вас на этом курсе вообще геометрии не будет, просто она будет на другом предмете.
Так что геометрию, да.
Так что геометрию алгоритмическую мы будем изучать, когда вы уже собственно овладеете линалом.
Так что я думаю это там...
Как говорится, после этого смотреть на геометрию будет гораздо проще.
То есть вы будете с нее так это...
С более высокой колокольни смотреть.
Да.
Ну.
Нет, на самом деле тоже.
Но ладно, опять же.
Ладно, сейчас мы рассматриваем эстрелевский вектор.
Ну просто такой эстрелевский вектор.
Хотя мы его чуть позже сейчас попробуем модифицировать.
Ну, потому что что такое вектор вообще?
Это такой динамический массив.
То есть это массив с переменным размером.
То есть у нас есть какой-то вот массив.
И у нас есть операция.
Какие операции есть?
Ну давайте для простоты мы будем считать, что у нас есть операция pushback.
Соответственно popback.
И...
Оператор квадратной скобки.
Ну он же метод add, он же там ну в общем...
Ладно, конкретные детали это вы уже там с Ильей подробно уже видимо обсудите, если еще не обсудили.
Вот, ну pushback понятно что делает.
Он запихивает элемент в конец вектора, popback достает элементы с конца вектора.
Квадратные скобки просто говорят, так, а кто тут и ты?
Тыкните меня в него, пожалуйста.
Вот.
Но мы замечаем, что если это, это реализовывать в тупую,
то есть хранить реально вот этот вектор, а если делать pushback,
ну тогда как делать? Этот элемент памяти может быть занят, правда?
Тогда нам придется находить кусок памяти на единицу больше, все туда копировать.
И это приведет нас к тому, что как бы pushback будет работать за реальную линию, это нам больно.
Значит как же поступает std-вектор в данном случае?
Он говорит, что как-то, что да, если он говорит следующее.
Да, у меня в каждый момент времени есть буфер, да.
Вот, то есть сколько-то элементов занято, количество элементов, которые занято мы будем называть size.
А есть буфер, размер буфера, который чисто теоретически может это вообще сколько себя вместить.
Этот размер буфера называется capacity.
Вот, но это так получится.
На самом деле да.
Потому что тут мы говорим следующее, что пока у нас pushback и popback не выходит нас за пределы capacity,
мы их честно делаем и не заморачиваемся.
Там, туда-сюда, граница там двигается, реальные вот единицы.
Но как только неожиданно выяснено, что нам требуется сделать pushback, а буфер заполнен, что мы делаем?
Правильно, мы делаем реолокацию.
То есть мы объявляем, мы заводим новый массив размера 2 capacity.
И все вот эти старые capacity туда торжественно копируют.
То есть эта операция мы будем называть реолокацией.
Емкость.
Если брать дословный перевод с английского, то емкость.
Вот.
Емкость, емкость.
Так вот.
Ну а теперь вот возникает вопрос.
Это приводит к классической ситуации вида, что каждый конкретный pushback в худшем случае может работать за линию.
Потому что даже если вы вот эту память выделите за о от единицы, то копировать элементы вы уж точно будете за линию.
Ну там отдельная песня с какой константой.
Но обычно такого нет.
И тогда будет как раз, мы как раз тогда эту линию распределим амортизированно в явном виде.
Ну что значит распредел.
Если мы допустим у нас, у нас осталось, место осталось меньше чем половина.
Мы тогда на каждый push еще два элемента первых условно копируем во второй.
И тогда как-то оно все запомнится, у нас уже весь вектор будет перенесен вниз.
Ну теоретически так возможно, это уже да.
Но это предположение, что каждая конкретная память выделяется или освобождается за о от единицы.
Да, то есть если вы это поверите, то конечно да.
Я вот не уверен, что в это стоит верить.
Хотя в большинстве моделей, скорее всего, можно считать, что это нормально.
Потому что в большинстве моделей у вас и память, в общем-то она у вас заранее выдана.
Просто вплоть до того, что вы едва ли не там, у вас бесконечное число ячеек и вы там используете те по номеру, которые вам надо.
Ладно, на эту тему у нас тоже шоу будет.
Да, нет, на эту тему у нас вообще замечательное шоу будет.
Вот, не важно.
Нет, ну это мы просто задумались.
Ну там, ладно, долго объяснять, так видимо.
Вот, давайте на нотки.
Пока, ладно, пока давай, но пока вот просто говоришь, у нас тут есть вот такой конкретный метод.
Который в худшем случае push работает за линию.
И нам очень хочется что-то понять с ним.
Вот, как же нам понимать?
А идея очень простая.
Значит, на этот раз.
Ну, действительно, то есть мы сейчас хотим показать, что учетная стоимость действительно всех тут pushback'ов, popback'ов этой операции от единиц.
Кажется, что можно посмотреть, сколько у нас суммарно будет кофировали.
Ну, сказать, что их будет не больше, чем два на количество push'ей.
Ну, вот тут по-разному можно.
Ну, тут я не знаю, можно как-то там глобально суммировать на все это, какой-то колоколь не смотреть.
Но мы лучше не будем это делать, потому что я говорю, чуть позже мы захотим это еще улучшить.
Давайте скажем, что дрифт это константа.
Нет, мы...
Не.
Не, мы не будем это говорить.
Обоем вместо этого...
Так, внимание, говорите следующее.
Значит, смотрите, вот у нас произошла реаллокация.
Мы знаем, что после реаллокации у нас, по крайней мере, вторая половина буфера торжественно пуста, правда?
Поэтому теперь идея такая.
Каждый раз, даже вот, ну, можно сделать аккуратно.
Значит, ну, давайте вот, как это можно сделать?
Ну, например, давайте это сделаем методом монеток.
Так, давайте вот.
Так, вот у нас тут были два стека, а сейчас я тут буду рисовать...
Вектор. Значит, мы будем говорить.
Ну, можно к четыре.
В данном случае, в данном случае, наверное, может и две хватит.
Значит, идея такая.
Давайте каждый раз, когда у нас тут появляется какой-то элемент новый в буфере,
мы будем на него класть, рядом с ним класть две монетки.
Ну, поэтому и две.
Ну, тогда, смотрите, тогда у вас, посмотрите, тогда просто, когда у вас дойдет вот до этого, да,
то у вас будет количество монеток не менее, чем два умножить на вот этот размер второй половины,
то есть в точности по количеству элементов.
Так что, поэтому, как бы, на копирование этих элементов, собственно, новый буфер вам как раз хватит.
Ну, это...
Ну да, но это уже, да, детали, это неважно.
Как вам удобно мыслить.
Вот, пожалуйста, тут двоечку.
Вот, в чем это не менее, обратите внимание, потому что некоторые из этих элементов могут быть потом попопаны
и потом вместо них может быть запушен новый элемент.
Но меньше от этого монеток не станет, правда?
Можем даже развлечься из-за, там, и каждой поп подобных элементов, еще и из-за него платить за одно.
Ну вот, но это уже, в этом нет смысла.
Скажешь, что у попа из-за этого от нуля?
Да, то есть как бы анализ теперь выглядит так, смотрите.
То есть давайте...
То есть давайте вот, вот у нас тут табличка есть, давайте сейчас мы ее и попишем.
Значит, смотрите.
Значит, будем говорить, что реальная стоимость...
Пушь!
Так, теперь у нас, смотрите.
Так, ой, давайте я вот...
Так, вот это я, наверное, сотру.
То есть я тут вот копишу, конечно, вот это, что для любого И, сумма там, ПИТ, минус КУИТ, должна быть больше либо равна нуля, там, вот.
Вот.
И теперь вот здесь можно что-то красивое писать.
Так, значит, что у нас тут получается?
Так, значит, что у нас тут получается?
Значит, теперь мы, значит, смотрите.
Теперь у нас есть поп-бэк.
Есть пушь.
Пушь-бэк обычный.
И пушь-бэк с реаллокацией на К.
С реаллокацией.
Вот на размера К.
То ладно, даже не размера К.
Давайте тут вместо размера К введем функцию Капасити.
То есть мы от такого размера хотим полностью переллокировать?
Ну, типа.
Значит, давайте смотреть.
Реальная стоимость.
Реальная стоимость пушь-бэка единица, поп-бэка единица, поп-бэка с реаллокацией на Капасити.
Соответственно, Капасити плюс один.
Ну, плюс один, потому что потом-то мы этот пушь-бэк все равно делаем.
Что еще?
Пушь-бэк с реаллокацией?
Ну да. Пушь-бэк, ладно.
Оговорился, оговорился.
Ну, Капасити плюс один.
Ну, мы за от Капасити реалицируемся, еще от единицы тратим на, собственно, пушь-бэк в конце.
А мы не за два Капасити реалистируемся?
То есть это три Капасити.
Да какая?
Ну, я бы сказал за Капасити.
Ну, как бы память за вот единицу выделяем там и так далее.
И эту единицу мы тоже там сюда впихиваем, поэтому тут не будем уж писать Капасити плюс два уж совсем уж там.
Три Капасити.
Да, пожалуйста.
Как говорится, это вопрос курса валют.
Вы как бы измеряете монеты в сантиметрах или в килограммах, суть одна.
В общем-то, вот.
Ну, вот.
Так вот.
Теперь, значит, что мы...
Значит, теперь говорим, что за каждый пушь-бэк, можно даже не заморачивать сказать, за каждый, мы будем получать две монетки.
За пушь-бэкской локацией мы тоже будем получать две монетки.
За пом-бэк мы ничего не будем получать.
А теперь, раунда.
Равно как и пушь-бэк и поп-бэк, мы ничего оплачивать не будем.
А вот пушь-бэк с локацией мы потратим Капасити монеток.
Вот.
И тогда, если брать реальную стоимость, то есть теперь учетную стоимость, то что нам нужно?
Вот это плюс вот это минус...
То есть вот это плюс вот это минус вот это, да?
То есть здесь получается один минус два, прям даже что-то отрицательное.
Здесь получается...
А, по-моему, я тут перепутал неоплачиваемое и оплачиваемое.
Вот так.
Вот так красиво подгоним, вот.
Вот так.
Вот так.
Вот так.
Вот так.
А, футэ.
Нет, погодите, погодите, погодите.
Почему тут...
А, это мы мыслями неоплачиваемое...
Ой, это же...
Так, нет, неправильно.
Так, ладно, давайте так.
Хотя, нет, погодите, тут неправильно все.
Погодите, это же не та табличка.
Это была табличка...
Все, прошу прощения.
Та табличка, где оплачена, где не оплачена.
То есть, помните, когда мы тут мыслили, что каждое действие мы либо оплачиваем, либо нет.
Вот мы решили, что мы это действие не оплачиваем.
Пушбек обычно не оплачиваем.
То есть, поэтому тут 0,1.
А здесь, как бы, одно оплач...
То есть, тут как бы одно не оплачиваем, финальный пушбек, а вот это капасити оплачиваем.
Ну, я все способы показываю.
Тут уже кому как нравится.
Но и обычный попбек тоже мы не оплачиваем.
Когда мы не оплачиваем, значит...
Вот.
Остается только, правда, действительно, тут опять та же сложность.
Надо теперь убедиться, почему мы то, что мы оплачиваем, у нас всегда деньги есть.
Но в данном случае мышление очень простое.
Рассмотрим ситуацию после предыдущей реаллокации.
Тогда у нас тут было капасити пополам элементов, и тут вот капасити пополам пустоты.
Это означает, что начиная с того момента, там мы можем считать...
Ну, там у нас понятно, сколько монеток непонятно, возможно, 0.
Но это и не важно, потому что с того момента до нашей текущей реаллокации было выполнено как минимум капасити пополам пушей.
Понимаете, да?
И это нам, собственно...
То есть, это означает, что как минимум капасити монеток у нас есть, а то и больше.
Поэтому вот оплатить капасити мы вполне способны.
То есть вот так можно мыслить.
Если мы два раза увеличим, да, Вектор?
Да.
Можно вопросить?
Почему за попбэк получаем?
Нет, это оплачивать, не оплачивать.
Получать монетки и отдавать монетки – это другая табличка.
Сейчас мы ее тоже заполним.
А, то есть оплачивать пусть не оплачивается, но...
Да.
Нет, это не метод потенциалов, это как бы вот...
Это место в серверах оплачивать, не оплачивать.
Если мы используем метод, сколько монеток мы получаем и сколько монеток мы отдаем, то это будет выглядеть так.
То это будет выглядеть немножко по-другому.
Вот, значит, смотрите.
Смотрите, как это все будет отделаться.
А оно же не накопится в капасите монеток, потому что мы...
При пуше мы одну монетку, да?
Две.
Вот ровно для того, чтобы накопилось именно капасити, мы клали две.
А где написали, что у нас две кладется?
Вот здесь нарисовали.
Да.
Мы же могли что сделать?
Мы могли сказать, что у нас суммарно все пуши работают за их количество.
Но плюс время...
Да.
Но это был бы метод анализа номер один.
Да.
Мы сейчас просто по-другому мыслим.
А если мы типа с момента предыдущего реакциации, мы же накопили капаси пополам?
Нет.
Я же говорю, мы за каждый пушбэк, поэтому платим, даем две монетки, а не одну.
Вот сейчас я это пропишу, смотрите.
Значит, за каждый пуш, обычный, да, я говорю, что он делается за от единицы.
Мы за него получаем две монетки, а тратим ноль.
Поэтому учетная стоимость оказывается, соответственно, 3.
Вот.
Теперь внизу пишем.
Поп.
Тут все просто.
Значит, мы будем делать его за от единицы и ничего не тратить.
И получаем учетную стоимость 1.
А теперь внимание.
Значит, пуш с реаллокацией на capacity.
Вот.
Понятно, да?
Как мы здесь будем мыслить?
Здесь мы будем говорить так.
Это у нас будет работать за, как мы уже сказали, от capacity плюс 1.
Можно потратить capacity, да?
И мы говорим, да, мы получим за это две монетки, потому что, ну, пуш-то все равно делается, да?
Но потратим capacity.
В результате учетная стоимость окажется, это плюс, это минус, это 3.
Вот.
Вы называете старый capacity или новый?
Старый.
То есть я подразумеваю, что реаллокация это capacity, превращающийся в два capacity.
Да.
Вот.
Так что, в принципе, можно расписывать так.
То есть это как бы более, то есть по сравнению с вот этим, это, конечно, более точно, потому что здесь мы приписали, сколько вы на каждую операцию будете реально там давать монет.
А я правильно понимаю, что у нас после пуш с переносом баланс становится 0?
Не совсем.
Дело в том, что, как бы, то есть в идеале 0, то есть в идеале, если у вас были только пуш, там, pushback, pushback, pushback, pushback, pushback, pushback, pushback, pushback, pushback, pushback.
Вы видели 2, нет?
Ну да, но да, но да.
Нет, это вот тогда, да, но просто может быть так, что вы там дошли до сюда, потом сделали pushback, а потом сделали pushback обратно.
То есть это означает, что у вас к этому моменту накопится две лишние монеты.
Нет, я скорее о том, что вот мы, если уже сделали пуш с переносом, если мы хотели сделать второй, то нам хорошо бы есть, чтобы на этих старых элементах тоже были монеты.
Нет, нет, нет, нет, мы эти вообще не пользуемся.
Только на новые.
Как бы мы, скажем так, нам хватает только тех монет, которые были добавлены после последней реаллокации.
Ну это странно.
Почему?
На этом базируется доказательство.
Потому что мы говорим, что пусть у нас была предыдущая реаллокация.
Мы знаем четкий вариант, что после реаллокации у нас, непосредственно после реаллокации, по крайней мере, у нас было ровно половина свободных элементов.
То есть половина занята, половина свободных.
Поэтому мы говорим, что у нас на этот момент 0 монеток.
Ну ладно, сейчас мы добавляем этот 1, получается 2 монетки.
Ну и все.
И начиная с этого момента, как бы да, мы накопим монетки.
То есть получается такое, знаете, усреднение, но не по всем сразу операциям, а только мы разделили эти операции на блоки и усреднили внутри блока.
А?
Автомечки справа сверху огоняли?
Где, где, где, где?
Не оплачиваем.
Типа если на столу 1 мы получаем, потому что не хватит.
Не, ну как сказать, Кеда, здесь мы просто расписывали, сколько мы оплачиваем.
А что значит не оплачиваем?
Ну то и значит. Есть операции, которые мы оплачиваем, есть которые не оплачиваем.
Типа уменьшаем за счет накопившихся?
Ну там другой способ, давайте вот не путать, это один способ мышления, так чуть-чуть, но другой.
То есть как бы этот способ мышления говорит, что вы получаете какое-то количество монеток, да?
А потом какие-то действия, часть действий там уже имеющимися монетками оплачиваете.
И тогда вы отдельно оцениваете то, что не оплачено, а то, что оплачено, оцениваете сверху тем количеством денег, которые у вас есть.
То есть которые вам Субагна дают.
То есть в принципе наше оказательство заключается в том, что мы говорим то, что у нас есть половина массива,
в нее заполнили элементами, на каждом получили две монетки,
и в итоге накопится столько монеток, чтобы покрыть всю компасию.
Да, да, причем, да, ну да, ну да, то есть предыдущая локация, у нас нужное количество монеток на нее накопилось, да.
А?
Сейчас ничего не слышу.
Кладем...
Ну кладем две монетки, да.
А потому что в этой табличке мы не пишем, сколько монет мы куда кладем.
В этой табличке мы пишем только, что мы оплачиваем, что мы не оплачиваем.
Откуда мы берем монетки, мы здесь как бы, это мы пишем где-то в другом месте.
То есть здесь мы только умолчаем, то есть это мы себе тут мыслим, что мы это оплачиваем за счет того, что как бы каждый пуш приносит там две монетки.
Да.
То есть здесь это да, как конкретно, да, как конкретно все оплачивает?
Нет, ну в смысле, а что такое? Есть операция, которую мы не оплачиваем.
Чего?
Ну для удобства.
Кого не писать?
С обеих, кого мы не оплачиваем.
Нет, просто смотрите, то, что не оплачиваем, ну потому что если вы не оплачиваете, то это тем самым вы из анализа просто выкинули какие-то действия, которые реально были сделаны.
Потому что помните, да, то есть наша цель, вот у нас есть реальные стоимости, реальную сумму реальных стоимости надо как-то оценить, да?
Ну да.
Ну я бы так сказал, что оплаченное плюс оплаченное равно все действия, потому что каждое действие вы либо оплатили, либо не оплатили.
Да.
Ну да, поэтому не оплаченное мы просто суммируем, а оплаченное мы оцениваем сверху там количеством денег, ну убедивший, что мы всегда оплатили корректно.
И потом заявляем, что количество денег нам выданное оно небольшое, поэтому тоже все хорошо.
Да, но откуда взялись монетки мы здесь не написаны.
Да, мы это озвучили, да.
Ну конечно нет, с этой точки зрения, смотрите, с этой точки зрения вот эта таблица, она более формальна, да, более показательна, но вот.
Да.
Нет, а можно в принципе, нет, смотрите, если я хочу увеличить формализм.
Ну вот, но теперь вот, смотрите, а если, ну вот, но если хочется прям совсем формально, да, если вот этого там вот положения монеток не хватает, то тогда можно ввести действительно метод потенциалов, и в этом методе потенциалов тогда если у нас есть вектор, то сказать, что потенциал равен к чему.
А, ну в такой интерпретации, да.
Capacity minus Cz, да.
Так, а вот давайте проведем эксперимент.
Вот давайте так, вот пусть у нас потенциал как, нет.
Давайте сейчас, давайте просто, чисто чтобы потренироваться, раз ввозить такой потенциал, давайте с ним честно проанализируем.
Да, я понимаю, что кто-то уже понимает, что что-то не так, но давайте.
Значит, смотрите.
Так.
Итак, смотрим на вектор.
Так, сейчас я тут.
Так, ребят, ребят, ребят, потише, потише.
Так.
Значит, смотрите.
Так.
Итак, смотрим на вектор.
Так, сейчас я тут.
Так, ребят, ребят, ребят, потише, потише, потише.
Значит, смотрите.
Сейчас я тут вот это все поубираю.
Вот это все поубираю, поубираю, поубираю.
Да, легче было так.
И, смотрите.
То есть какие у нас операции есть?
Есть, опять же, push обычный.
Есть push с реаллокацией на capacity.
Да, да, да.
Погодите, погодите.
Сейчас мы...
Я говорю, давайте это.
Нет, здорово, что вы уже так и вперед мыслите, но давайте не будем торопиться.
Значит, смотрите внимательно.
Итак, вот если мы рассматриваем вот такой потенциал, мы его можем вести.
Он корректен, он не отрицательен.
Правда?
И изначально он, наверное...
Ну, смотрите.
Тут, ладно, есть маленькая оговорка, но мы ее опустим.
Потому что на самом деле к чему у нас равно capacity, когда СЗ равно нулю?
Ну, на самом деле, вектор всегда интересируется с восьмию элементом.
Ну вот, да, но тогда у нас будет подлянка, что потенциал изначально у нас равен восемь.
Ну, да.
Это нехорошо.
Но мы будем подразумевать следующее.
Мы можем как бы это подогнать так, что давайте пустой вектор не хранить себе никакого capacity, да?
А пока у нас элементов, скажем, не превосходит, ну, я не знаю, нот.
А там будем говорить, что если мы там добавляем первый элемент, то мы там создаем вектор размера два, например, да?
Ну, чтобы хранить вот этот вариант, что у нас после последней релокации все было вот хорошо, да?
Ну, понятно, что на этой мелочи там все будет от единицы потенциал, на от единицы.
Поэтому не проблема.
Итак, смотрим.
Пуш об, пуш обычный.
Так, ну, реальная стоимость единица.
Потенциал равен чему-то там какому-то х.
Но при этом потенциал в конце становится равен, то есть создая увеличивается, capacity тоже самое, поэтому получается х-1.
И учетная стоимость у нас там получается равна чему?
Ноль.
Ну, вот это плюс, вот это минус это.
Почему у нас текущий потенциал равен х-1?
Ну, потому что, потому что перед добавлением потенциал был равен х.
То есть capacity-size было равно х.
Теперь мы добавили элемент. Capacity не поменялось, потому что это обычный пуш.
Size увеличился на 1.
То есть, следовательно, потенциал уменьшился на 1.
Вот, да, оказался вам вообще кайф, да, пуши можно вообще не считать.
Да.
Ну, да, да, да, знаете, в продвинутых статьях очень удобно выяснить, что эти операции мы не считаем, потому что у них учетная стоимость ноль.
Не, реально, в полном серьезе.
Вот, да, там хорошее шоу будет.
Вот, далее.
Теперь пуш с релокацией на capacity.
Так, ну, отлично.
Он работает у нас за, как вы помните, capacity плюс 1.
Так, теперь смотрим.
К чему был равен потенциал на момент перед релокацией?
В точности ноль.
Пуш с сайс был равен capacity, а потенциал был равен нулю.
После этого.
Ага, если бы.
Да, вот конкретно такой потенциал стал равен capacity, ну ладно, минус 1.
Потому что мы тут еще один элемент докинули.
Поэтому так и пишем.
Capacity минус 1.
Теперь внимание.
К чему равна учетная стоимость такой операции?
Вот это, плюс вот это, минус вот это.
2 capacity.
И все.
Так.
Ну, в принципе, поп можно не писать.
Потому что мы понимаем, что такой потенциал дает нам, конечно, не то, что мы хотели.
Да, то есть каждая учетная стоимость у от н, а всего все операции работают за н квадрат.
Нет.
Вот.
Образ так.
Давайте, вот да.
Давайте все в порядке, все протестируем, смотрите.
Все что угодно.
Нам не нравится, что учетная стоимость плохого пуша равна у от capacity.
Нам не нравится, что учетная стоимость плохого пуша равна у от capacity.
Это у от н.
Capacity в лучшем случае у от н.
Это нас не устраивает.
Это уже другой вопрос.
Нет, а мы хотим поделять учетные стоимости так, чтобы это уже схлопнулось.
А как бы, знаете, а если мы хотим работать по принципу, заведем учетные стоимости,
а потом докажем, что эти учетные стоимости можно правильно просуммировать,
так может лучше сразу бы доказали, что можно все просуммировать.
То есть это как бы не та реакция метода, которого мы хотим.
Это называется.
Да.
То есть как бы да.
Вот.
То есть на самом деле надо просто перестроиться.
Ну да.
Нет.
Почему не чисто?
Нет, тут.
Ну вот.
Теперь надо просто ввести другой потенциал.
То есть это как бы да.
То есть это вот.
Ой.
Это вспоминается почему-то история.
Ну ладно.
Просто если неправильно перестроиться или уметь перестроиться,
то знаете, ситуация была такая, что жил там в Ленинградской консерватории.
Был лектор, который там.
был лектор, который там, ну там у них есть такое, что
перед выступлениями произносят какие-то вступительные
слова.
Вот.
И вот была ситуация, ситуация, вот лектор не умел перестроиться.
Есть ситуация, значит, у него там в каком-то утреннем
сеансе, значит, там придут дети из первого класса.
Вот.
Ну понятно, он там подготовил какое-то вступительное
слово.
Но там кто-то что-то напутал, и в результате в это время
вместо первоклассников пришли там что-то академики
из советской академии наук.
В результате человек не смог перестроиться и на
полном серьезе там минут 10 объяснял действительно
академикам-членам-корреспондентам, что скрипочки это такие
дощечки, на которые натянуты струнки и какими-то там жилками
там издаются как-то звуки.
Вот.
То есть вот человек просто не перестроился.
Вот.
Как было комментарий?
Это вызвало нездоровый смех всего звала, но это
совершенно не та реакция, которая нам нужна.
Вот.
Вот.
То есть что это значит?
То есть это не значит, что, конечно, не надо произносить
слово вообще, значит надо просто ввести другой потенциал.
То есть вот.
Вот.
Ну какой?
В данном случае предлагается...
Давайте...
Ой.
Это реальная история?
Знаете, вот философский вопрос.
Знаете, скорее всего, да.
Хотя...
Ну вот, скорее всего, нафиг.
Потому что, на самом деле, откуда я ее взял, ссылка
простая.
Значит, можете погуглить такую вещь.
Значит, смотрите.
Значит, просто очень рекомендую, на самом деле, вот, просто
вот.
Значит, просто на ютубе найдите такое, значит, эрак
клеондронников.
Первый раз на эстраде.
Нет, это к программированию вообще никакого отношения
не имеет.
Вот.
То есть, на самом деле, это просто рассказ, на самом
деле, то есть, некого ленинградского студента.
То есть, ну, речь вообще идет там, вообще...
То есть, простите, о Ленинграде, причем до Второй мировой,
где-то там, 30-е годы.
Вот где-то такие, ну, вот такое вот есть.
Ну вот, и речь идет, и происходит там все это дело в консерватории
или вокруг нее.
То есть, вообще.
Сейчас будем разбираться.
Так, давайте, не перебивайте, так, давайте вот доскажем
что.
Да.
Так что вот, нет, давайте я просто доскажу, после
этого вот перейдем к унициалу.
Так, ребят, так, ребят, я вообще-то что-то говорю на другую
тему, да.
Значит, смотрите, то есть, вот эта просто штука, вот
действительно, то есть, на самом деле, честно скажу,
то есть, если вот, то есть, знаете, просто любите хороший
юмор, вот очень рекомендую на самом деле.
То есть, может быть даже, я и тогда просто очень люблю
слушать, просто как минимум, потому что еще просто наслаждаюсь
просто русским языком, знаете.
Вот.
Так что вот очень рекомендую, вот просто это там, то есть,
это на ютубе, но как бы можно просто слушать, практически
хотя посмотреть тоже хорошо.
Так, все, об этом забыли, значит, возвращаемся к этому,
давай.
Мы теперь на поп тоже реаллокацию, что ли, будем делать, иначе
у нас потенциал отрицательно становится, когда мы попаем
меньше половины.
Так.
Ой, какая подлянка-то, а.
Да.
Мы можем поп просто отдельно доказать, чтобы это делать
максимально.
Ну, давайте, давайте, да.
Ну, хорошо, давайте вот это.
Да, подогнали, если потенциал будет меньше нуля, ну ничего
страшного, да.
Вот.
Ну, давайте разбираться.
Значит, давайте теперь разбираться, пуш обычный.
Ну, здесь можно разобраться так.
Если потенциал был равен x, то потенциал в конце стал
ну, либо x плюс 2, либо тупо x, если это был 0, 0, да.
Но тогда учетная стоимость становится равна либо 3, либо
1.
Оба варианта у нас прекрасно устраивают.
Почему x может быть?
Ну, потому что, может быть, мы это делали, этот пуш,
и он был в первой половине буфера.
Да, вот типа того.
Да, вот такое может быть.
Вот типа.
Значит, смотрите, теперь пуш с реаллокацией.
Ну, здесь теперь потенциал перед этим был равен, чему
он был равен?
Ну, size был равен, то есть, получается, здесь потенциал
был в точности capacity, обратите внимание, почему?
Потому что, ну, размер был capacity, поэтому 2 capacity
равно capacity.
Такой мистический математический факт.
Да, 2 capacity минус capacity равно capacity, да.
Вот, осталось что?
Осталось в итоге 2.
Ладно, вру, да, 2.
Ну, потому что непосредственно после реаллокации у вас
будет 0, потому что size будет в точности половинка
нового capacity.
Но при этом вы как бы один элемент все равно пушите,
вы все-таки 2.
И в результате, получается, что в результате пуш с реаллокации
получается 3.
Это нас устраивает.
Теперь делаем поп.
Ну, поп единица, значит, фи и минус первое, чему равно?
Ну, было х, осталось либо х минус 2, либо х.
Ну да.
Ну, и там либо это 0 было.
Ну, и тогда получается, что учетная стоимость этой операции
либо минус 1, либо 1.
Ну, почему?
Ну, 1 плюс х минус 2, минус х минус 1.
Нормально.
Но, короче, это не превосходит 1, так что это нас устраивает.
Вот, получается, да, вот такой потенциал нам красиво заходит.
Ура.
Почему у нас вся проблема в том, что учитная стоимость может быть минус 1?
Чего еще раз.
Почему у нас вся проблема в том, что учетная стоимость может быть минус 1?
Ну, forever note.
Ну, а вот о чем проблема?
Нет, учетная стоимость это note.
Нет, аire object, а вчетная стоимость это note.
Ч 지난tss芳idlм, чrel'?
Все равно положительнаяiz?
Не, не нужно.
Нет, на самом деле так.
Нас сейчас устраивает,
что эта учетная стоимость
не превосходит единицы.
Если она отрицательная, значит единица она не превосходит.
Вот.
Но оказывается, что...
Смотрите, логика тут такая,
что сначала мы говорим,
что если вводить прямо эти учетные стоимости так,
что они оказываются отрицательными,
то тогда сумма
вот этих учетных стоимости
она оказывается от.
Потому что каждая из этих учетных стоимости
не превосходит единицы.
Но с другой стороны мы знаем,
что мы потенциалы ввели правильно,
поэтому сумма учетных стоимости
она не менее, чем количество
суммы реальных стоимости.
Поэтому нормально.
Да.
Ну да.
Есть глобальная часть,
что этот метод, этим методом что-то докажем.
А есть конкретная метода,
которая говорит, что да, конкретно
учетные стоимости с конкретно этим потенциалом
оказались адекватны.
Да, на всякий случай,
перед вопросом скажу, да,
в науке и встречается, что там учетные стоимости
с какой-нибудь операцией ноль.
Это нормально.
Да нет.
Нет, такого не будет
просто потому, что обычно это означает,
что вы не можете сделать бесконечное
число поп-беков.
Ведь обратите внимание, вы поп-бекать
можете только то, что вы ранее запушбекали.
Поэтому нельзя просто так взять
и сделать поп-бек
из пустоты.
Потому что да, понятно,
что здесь мы конечно подразумеваем,
что когда мы делаем поп, мы делаем поп из не пустого
вектора, а если у нас пустой вектор,
то мы вообще перестаем анализировать, а начинаем
вопить.
А если у нас был вектор из
стаичных элементов, и мы много раз
делали поп-бек, он у нас
произойдет реаллокации в какой-то момент?
То есть он сократится? В текущей версии
нет.
Да, вот тут есть такая маленькая
подлянка, что в плюсовой версии
действительно есть эффект, что
если вы из вектора сделали
миллион пушбеков, а потом миллион
поп-беков,
то размер вектора будет миллион.
Ну и что?
Ну, с точки зрения памяти это неприятно.
Вот утверждается, что нет.
Ну, подробнее вы еще с Мишириным это обсудите,
но вот эксперименты показали, что там
от того, что вы сделали много поп-беков,
капасти не уменьшается.
Да, но вот сейчас мы об этом поговорим,
вот теперь у нас будет задача.
Помните, эстрелевские алгоритмы не идеальны,
потому что
ну, например,
как видим, у меня идеальность в том, что
в эстрелевском сете нельзя найти
катори по возрастанию элементов.
Нет, это другое, что можно...
Мы говорим сейчас об эстреле, да, существует
расширение эстреля, в котором это делается, да,
но как бы помните, что
это не все, что вы можете идеально придумать математически
как бы реализованно в эстреле.
Нет, не сделано это
чисто потому, что
в эстреле тоже есть такой трейдов
между что вообще можно сделать
и сколько накладных расходов это потом будет
жрать.
То есть там отдельная песня, как бы почему там
красночерное дерево, а не нормальная дикартячка
какая-нибудь.
Нет, а причины есть.
Именно.
Ну, если вкратце, да, то там во всех деревьях нужны какие-то
топ-информации типа приоритета
или размера под дерево, а в
красночерном дереве вам нужно только один бит
хранить.
Да, да, да, вот именно.
Да, там много причин.
Нет, ну ладно.
Ладно, до этого мы тоже...
Ладно, это мы тоже будем очень подробно
изучать все это, поэтому...
Чего?
Перерыв!
Прямо сразу
перерыв?
Да, погодите, зачем перерыв?
А вот здесь одна пара
не хочет перерыв.
Нет, ну сейчас, погодите.
Ну сейчас давайте дойдем до этого, да.
Нет, пара-то по этой локе, она уже там
и перерыв уже из-под нее закончился.
Да, там.
Нет, я просто хотел уже сформулировать задачу,
после которой действительно можно действительно выдохнуть.
А задача
будет такая. То есть да, мы говорим
о том, что истейлевский вектор действительно может
жрать сильно более лишнюю память, то есть
вектор на три элемента может жрать
от миллиона, потому что у него там
богатая история его там жизни.
Предыдущий. Вот.
Ну вот.
Поэтому наша задача будет такая.
Хочется изобрести вектор,
да, так и быть, мы верим в амортизированность, так и быть.
Но при этом
нам бы очень-очень-очень хотелось,
чтобы в каждый момент времени
выполнялось, что если его реальный размер равен
СЗ, то количество
памяти, который он жрет, было
400 СЗ.
400 СЗ очевидно.
Не, почему, давайте реанонсировать в обратную
сторону, когда по БК.
Так, вот тут возникает вопрос.
Так, чтоб.
Да, тут просто
возникает вопрос, просто кто-то заказывает перерыв,
просто можно сделать так, можно сейчас добить эту задачу,
собственно сделать перерыв, чтобы потом перейти,
попытаться перейти к очередина.
А нет, мы не перейдем к очередина, потому что нам
нужно вам красивый алгоритм
рассказать.
Из вашего домашнего задания.
Ну ладно.
Так, ладно.
Ладно, это мы тогда сделаем. Ладно, пришло время
пожалуй сделать перерыв, давайте.
Так, и теперь.
Значит теперь
давайте думать дальше.
И так, значит еще раз задача.
То есть нам предыдущая
реализация вектора не понравилась,
потому что действительно она
может жрать слишком много памяти
по сравнению с тем, сколько там реальный элемент.
Очень хочется, чтобы в каждый момент времени
количество, то есть
capacity не превосходило,
то есть capacity должно быть
в каждом момент времени меньше либо равно,
чем какая-то константа C на size.
Вот очень-очень-очень-очень
бы этого нам хотелось.
Вот какие варианты предлагаются.
Ну конечно классический,
такой самый классический вариант
в этом месте,
это конечно сказать, что давайте делать
реалокацию, конечно, не только когда у нас буфер
заполнился, но и когда этот буфер
стал слишком маленьким.
То есть когда элементов буфера стало слишком мало.
А именно, то есть это у нас вот большая
capacity, то есть когда все заполнилось.
Но альтернатива,
то есть альтернативный метод
теперь нам говорит следующее.
Так, а давай теперь скажем,
что если у нас, например,
оказалось, что прям вы
так напобэкали, что у вас там
количество элементов стало
четверть от буфера,
то есть прям вот совсем вот тут,
вот прям вот столько осталось,
прям вот Cz прям стало равно
capacity поделить на 4,
то
мы снова объявляем реалокацию.
Ну только размер capacity 0.2
Да.
Но конечно, чтобы у нас был там буфер,
чтобы не сразу там скакать туда-сюда,
мы конечно объявляем
что действительно
новый capacity у нас здесь станет теперь
capacity пополам.
То есть видите, мы сохраняем
вариант, что после реалокации,
что в расширении, что в сужении,
у нас size равен половине,
ровно половине capacity.
Вот такая вот
интересность.
Конечно.
Ну вот, но на самом деле увидеть
это все можно легче всего,
конечно, через монетки.
Потому что мы будем говорить следующее.
Смотрите, то есть фишка такая,
что когда мы делаем,
допустим, лишний push,
то есть push вот в эту сторону,
то мы будем получать,
давайте допустим две монетки.
А теперь идея такая,
что когда мы теперь
будем делать лишний pop,
то мы будем...
Да, можно тоже получать
две монетки,
но уже можно сказать
красненькие.
Да, не, ну, дайте иногда
для красоты анализа, давайте пусть у нас будет
столько-то красных монет, столько-то зеленых монет,
столько-то синих монет.
И там тратить мы будем,
на это мы будем тратить только синие монеты,
на это только зеленые и так далее и тому подобное.
То есть на самом деле вот там
есть какие-то красивые
рассуждения на эту тему,
в принципе, так тоже очень приятно думать.
Вот.
То есть вот так вот.
И тогда что это нам дает?
Ну так, на уровне оплаты.
Тогда на уровне оплаты получается, что
ну, во-первых, заметим, что если у нас есть запрос,
если у нас есть реаллокация на расширение, то на нее
деньги найдутся, потому что
после предыдущей реаллокации было хотя бы
капасти пополам пушей и капасти монеток на месте,
правда?
Но, теперь та же логика работает, если у нас
пришел запрос на
реаллокацию,
ну вот, пришел запрос на реаллокацию на уменьшение,
потому что для того, чтобы это произошло, должно произойти
как минимум
capacity поделить на 4
попов.
Этого хватает, чтобы заявить, что у нас есть теперь
capacity пополам монеток красненьких точно,
и их точно хватит на то, чтобы вот эти capacity поделить на 4
монеток переалоцировать.
В принципе, нам, в общем-то,
по нашей логике можно было по одной монетке давать.
Вот, удобно, правда?
То есть, видите, на уровне идеи
вот уже хорошо получилось.
Получается примерно следующее.
Вот, и, ну вот,
то есть, ну, как теперь, ну вот, ну теперь действительно
такой анализ, конечно, это чуть усложнит,
потому что теперь это будет у нас есть pushback,
обычный pushback с реаллокацией, есть popback,
а есть popback с реаллокацией на capacity, да?
Вот.
Ну а заметим, что,
ну, с точки зрения оплаченных и оплаченных, да, то есть, здесь у нас
получается capacity пополам
плюс один,
да, вот, если тут писать popback
с тоже, давайте, реаллокацией capacity.
А, действительно, так.
Давайте на 4, пожалуйста.
Так, что мы из этого оплачиваем?
Вот те самые capacity,
вот те самые capacity мы оплачиваем.
А вопрос, там не просто capacity на 4, мы же убираем они?
Нет, причем, ну копируем там, нет, ну как бы мы говорим,
что мы, как бы, там, память выделяется,
выделяется за вот единицы или там исчезает,
а вот копируем мы каждый элемент по единичке, поэтому пишем capacity на 4.
Ну, тут разные модели могут быть.
Ну, вот мы так, то есть, как вот, оплачено, не оплачено, получаем так,
мы успеваем все оплатить, потому что вот мы только что обсудили,
почему мы это все реально успеваем оплатить.
А для этого остается только понять, что на каждой операции
нам дают не более чем две монетки,
поэтому, как следствие, у нас суммарное число монеток OATN.
Ну, вот, как следствие, значит, да, все оплаченные суммарно OATN.
Да.
Значит, мы получаем запушь две монетки и запоп одну монетку.
Ну, и получать, и от этого нам будет даваться
только больше число монеток.
Да, давайте, кстати, теперь...
А, ну да, вот давайте сейчас мы вот эту табличку более аккуратно нарисуем.
Как паративном мессенджере.
Так, как это говоря...
Как это, да, сейчас я его наберу в компаративном мессенджере.
Отправляем сообщение к человеку,
на том конце стола просыпается.
Так.
Так.
Так.
Келокации, капасти.
Да, мы работаем как спи-ту-пи, так и спи-ту-си.
Так. Итак.
Вот опять же, да, написали реальность.
Так, капасти поделить на 4 плюс 1.
И теперь, но теперь все хитрее.
Каждый пуш нам теперь приносит две монетки.
А каждый поп приносит
одну монетку. Ну ладно, давайте.
Приносит теперь одну.
Вот. Теперь тратим.
Значит, пуш обычный не тратит ничего.
Пуш с реалокацией капасти тратит капасти монеток.
Поп обычный тратит 0 монеток,
поп с реалокацией капасити тоже тратит,
ну тратит уже капасити пополам монеток.
Ладно, на 4, хорошо.
Вот.
Значит, теперь CIT.
Но давайте смотреть. По этой логике, да, CIT
пуш весит 3. Пуш с реалокацией тоже весит
все еще 3. С попом уже становится
интереснее, потому что он теперь, ладно, весит не 3, но 2.
Потому что 1 плюс 1 равно 2.
А здесь, да, капасит на 4 плюс 1,
плюс 1 минус капасит на 4, то есть 2.
То есть видите, константы стали пожирнее,
но они остались константами.
А элементарно мы доказали. Мы сказали, что PIT это,
ну PIT это сколько монеток нам платят за операцию.
К PIT-е сколько платим мы, да?
Вот. Ну а просто теперь мы просто внимательно
посмотрим, как у нас устроены монетки. Мы всегда замечаем,
что когда мы их хотим потратить, у нас всегда столько монеток есть,
потому что. То есть доказательство все еще базируется
на инварианте, что у нас сразу после
реалокации занято ровно половина буфера.
И не важно, эта реалокация была
после расширения или после сужения.
То есть после этого набранных монеток нам хватит.
То есть мы не гарантируем, что их у нас ровно столько,
но что как минимум столько есть нам хватит.
Ну потому что, смотрите, нам нужно
перекопировать капасити поделить на 4 элементов в новый буфер.
Поэтому мы и пишем капасити поделить на 4.
А оно пусто, это мы как бы реалацируем.
То есть выделение памяти и удаление, оно у нас
типа за вот единицы мы считаем.
Потому что у нас обычно в C++ нет такой функции
освободи половину этого. То есть, конечно, если бы мы
писали сами менеджер памяти, то то есть мы бы сами
себе заменили, у нас есть огромное количество элементов
и у нас там есть какие-то свободные, не свободные
элементы, то мы бы так и сделали. Правда, там конечно
возникает оговорка, что начинаются эти свободные, не свободные
отрезки из какого-то момента, там едва ли не дикартячка
выплывает, но...
Ну да, да, да.
Ну, смотрите, если мы будем делать реалакацию
на капаси... А, смотри, если у тебя будет
капасти пополам, у тебя тупо не хватит монеток.
То есть доказательств, это пойдет что-то не так,
ты не можешь сказать, что у тебя хватит количества монеток,
но то, чтобы это оплатить.
Так, что, еще какие-то вопросы были?
Так что, вот такая получается красота, если мы мыслим
с точки зрения метода бухгалтерского учета,
а можно мыслить с точки зрения потенциала.
Правда, тут, конечно, такой пример, когда потенциал
вы, собственно, из бухгалтерского учета и выводите, но
давайте подумаем, какой здесь можно, тем не менее, выдать адекватный потенциал?
Вот какой тут можно подогнать потенциал, чтобы это
работало? Вот к вам вопрос.
А, прям модуль?
Нет, давайте попробуем.
Да, то есть, действительно, логично.
Идея та же, что если size равен
капасте пополам, потенциал должен быть равен, наверное, нулью.
А если куда-то там граница отклоняется туда или обратно,
то, наверное, хотелось бы, чтобы эта граница как-то...
Ну, можно, а можно не заморачиваться.
А вот давайте просто вот помеселимся.
Fiat' равно...
То есть, Fiat' равно
модуль, там Cz,
минус капасте пополам.
Всё, просто тупо модуль.
Вот давайте прям вот так попробуем развлечься.
А, может это ещё на два домножить, а?
А, давайте чтобы, да, чтобы
что-то поддерживать консистенцию с тем, что было раньше.
Вот, давайте 2 Cz, минус капасте, пожалуйста.
Ну, как бы да, курс вот, то есть, да,
фактически мы сделали только динаминацию валюты в два раза, но это уже так.
Да, вот давайте внимательно.
Так, сейчас давайте вот внимательно, сейчас я тут...
Модуль 2 Cz, минус капасте.
А если мы ведём 4 Cz, минус капасте?
Ну, можно будет тоже попробовать.
Ну, пока не знаю, я пока не знаю, что с этим будет.
А это же второй потенциал дать, у нас был первый,
ещё мы к нему добавили второй для ковки.
Не, не, не, не, мы полностью заменили потенциал.
Но по факту можно и два раза дать.
Нет, нет, нельзя.
Возьмём сначала один потенциал относить, до которого
пуши работают за O от единицы, а потом возьмём
второй относить, до которого попы работают за O от единицы.
Но счастья не будет.
Потому что всегда можно подогнать потенциал так,
что пуши работали за O от единицы, а попы работали
за O от бесконечности, или наоборот?
Это практически в любой структуре данных это можно сделать.
Так что...
Почему?
А почему мы не можем провести соответственно два потенциала
и считать потенциал как сумма этих потенциалов?
Можем.
Но тогда будьте любезны гарантировать, что
сумма этих потенциалов даст по каждой операции всё в порядке.
Потому что если, например, относительно одного потенциала
будут портиться вот эти две операции, относительно другого вот эти,
то в сумме получится испорчены все четыре.
То есть два потенциала, как бы недостатки друг друга, не...
Нет, там не два потенциала, там сумма двух величин.
То есть вы тогда должны гарантировать, что
если вы суммируете два потенциала, то
будет работать с каждой проблемой,
то есть каждое лишнее действие как бы нивелируется
одним потенциалом и игнорируется другим.
Вот так.
То есть как бы если один потенциал уменьшается, а второй не изменяется,
то это вас устраивает.
Там, собственно, будет так работать.
До этого мы тоже с вами дойдём.
Хотя сначала вы на это домашнее задание порешайте.
Ну, прошлое это немножко не о том.
Прошлое ещё нет, прошлое уже есть, да.
Прошлое ещё есть, а будущее ещё только будет.
Да, знаете, да, как это...
Эх, как говорил капитан очевидность на свидание, да.
Да, ну знаете, номер такой есть.
Да, капитан очевидность на свидание.
Это газета, что журнал?
Нет, КВН.
Причём сборная фистеха, что характерно.
Ну вот, то есть так и проходит, говорит, привет, я же пришёл.
А присаживайся на стул.
Ну вот, ты такой смешной, расскажи.
А я всякие стайны знаю.
Знаешь, когда будет выходить нот, кто будет вести программу «Вечерний урган»?
А знаешь, когда она будет выходить?
Когда? Вечером.
А знаешь, кто отец Аллы Пугачёвый?
Кто? Борис Пугачёв.
И так далее. А потом начинается красота.
Знаешь, я вчера был в кресле, сидел там.
Перечитывал Томик Есенина. Девушка, Сергея!
Ой, я люблю тебя ещё больше.
И ты знаешь, что было, то было.
Что будет, то будет.
Прошлого нам не изменить, а будущего мы не знаем.
Знаешь, вот снег, он превращается в воду.
Так и мы, когда взрослеем, становимся немножечко старше.
Однажды я понял, что если я вечером засну без тебя, то проснусь один.
Я очень хочу, чтобы у нас с тобой были дети.
Более того, я хочу, чтобы именно ты их родила.
Ну вот, очаровательный номер.
Остаётся только в диване.
Концовка номера. Уже играет отпивка.
И, собственно, капитан «Ичевидность» уходит.
Внимание, вопрос. Что написано сзади на его плаще?
Ничего.
Да, правильный ответ. Там просто написано «плащ».
Можете гуглануть, это КВН «Капитан «Ичевидность» на свидании.
Замечательно, на самом деле.
Судя по реакции самой команды, видимо, большого успеха у публики.
Может, поддержки этот номер почему-то не нашёл.
Ну, по понятным причинам.
Если он уже всё родил, может быть, простудия.
Нет, это другой вопрос.
Ладно.
Это на уровне Штирлец.
Да, да, да. Штирлец открыл окно и за окна дуло.
Штирлец нажал тальте в четыре, окно исчезло.
Да, да, да.
Понятно.
Вот.
Но это так.
Как, по-моему, вы начинаете, получилось действительно красиво.
Ладно. Пока тут шутками и прибаутками у меня тут табличка появилась.
Значит, давайте разбираться.
Итак, пуш обычный работает за единицу.
Пуш с реаллокацией работает за Capacity плюс единицу.
Поп работает за единицу обычный, конечно.
Поп с этой работает за Capacity поделить на 4.
На 4 плюс 1.
Так, ну поехали.
Вот с этим потенциалом разбиваемся.
Так, у нас тут двойка, напоминаю.
Да, вы, возможно, это не видите, но она тут есть.
Ну, тут, как всегда, тут она х.
А вот тут, как повезет.
Х плюс 2 х минус 2.
Да, х плюс минус 2.
Ну и как следствие, ну и, в общем-то, учетная стоимость тоже 1 плюс минус 2.
Ну так, плюс-минус.
А потому что, видите, потому что от того, что у вас сайс измерится на 1,
у вас модуль может как увеличится на 2, так и уменьшится.
Ладно, есть еще подлые случаи, когда он не поменяется вообще.
Да, еще бывают случаи х.
И тогда тут будет 1.
Если потенциал был минус 1, если тут было минус 1, осталось 1.
А, ну ладно, такого не бывает.
Такого не бывает, Capacity ничего там не бывает.
А если у нас 0 элементов, Capacity ничего?
Ну там уже отдельная песня.
Ну ладно, такие мелкие случаи, мы там говорим, что все завод единицы работает,
поэтому не заморачиваемся.
То есть говоришь, если элементов меньше 4, то как-нибудь там делаем как угодно.
Ну как угодно, чтобы это завод единицы был.
Ну как в рекурентах.
То есть мы тоже там это забиваем на локальности.
Вот, ладно.
Соответственно, да.
Господи, что он отвернутый состоит вообще?
Ему что, неинтересно что ли его?
Да, легче не стало, да.
Ну ладно.
А то что он там охранник что ли, я не знаю.
Причем который охраняет, видимо, меня от вас, я не знаю.
О, правильно.
Ладно.
Ну ладно, пусть стоит как стоит, ладно.
Так вот, пусть с реаллокацией на Capacity.
Был равен потенциал, ну видимо Capacity.
Можно спросить, почему еще не может быть 0?
Потому что у нас Capacity всегда степень двойки.
А это означает, что как бы эта разница всегда четная.
Поэтому как бы 1 на минус 1 поменяться не может.
Да, там такая ситуация.
Так вот, phi и t.
Так, ну потенциал после того как мы тут это расширились,
получился теперь у нас 2.
Да, здесь все железо бетонно.
И учетная стоимость 3.
Чего?
Нет, Capacity.
Нет, у нас тут двойка, напоминаю.
Зачем нам нужна эта двойка?
Так, посмотрим, что у нас там с попом.
Ну было x, стало x.
Ну да, тоже плюс-минус 2.
Ладно, даже мы напишем минус плюс 2.
Да, поэтому тут тоже один.
Почему мы пишем минус плюс?
Ну для того, чтобы тут было какое-то более соответствие.
И наконец самое интересное,
ради чего все и писалось, как говорится.
Так, чему у нас был равен pop с реаллокацией на Capacity?
Так, он был равен...
Ну size был равен получается чему перед вот этой штукой?
Нет.
Чему был равен size?
Вот.
Да, поэтому потенциал здесь было Capacity на 4 плюс 1 умножаем на 2.
Получается Capacity пополам плюс 2.
Минус Capacity.
То есть Capacity пополам минус 2.
Вот так.
После этого
потенциал стал равен 0.
Но потому что Capacity уменьшилось вдвое,
а размер там был Capacity на 4.
Ну после попы непосредственно.
Так, ну что, смотрим там по потенциалу.
Что-то там получается.
Это плюс, это минус, это шлёк.
Нет, нет, нет.
В минус пошло минус 2.
Нет, в смысле мы же Capacity на 4,
из него вычли Capacity на 2,
и у нас получилось какое-то отрицательное число,
что в целом вот 1.
Capacity на 4 минус Capacity на 2.
Ой, кайф какой. Да, вообще кайф.
То есть смотрите какая красота получилась.
То есть получается 3 минус Capacity на 4.
Вот так.
Нет, нет, нет.
Ну так, Омега какая-то.
Минус Омега ОТН, да, вот так вот.
Нет, ну нормально в принципе.
Ладно, каждая не превосходит единицы.
Ладно, от единицы, от единицы.
Ну значит всё нормально чуть-чуть.
На самом деле у нас это же вылезло,
потому что у нас два сайса в этой сторону.
Мы могли улучшить в том плане, что если в эту сторону,
то тут умножать на 2, а в эту сторону не умножать.
Да, но это уже да.
Это как бы эквивалентно тому,
что мы тут не одну монетку даём, а сразу две.
На самом деле.
Нет, в этом варианте мы давали одну,
и этого нам хватало.
Но с точки зрения потенциала, когда мы делаем попы здесь,
то получается аж на две.
Вот, поэтому тут получился такой перебор.
То есть он символизирует, что у нас куча лишних монеток.
Тут у нас ещё и лишние монетки образовались.
Ну в метре потенциалов мы же здесь получается сколько монеток?
Две монетки, да?
Ну да, нет, в метре потенциалов монеток не было вообще.
Да, но если переводить этот потенциал на язык монеток,
то да, мы на каждом шаге даём две монетки.
По факту да.
Тут будет более мерзкая формула, если мы будем символизировать одну монетку.
Но если вы подгоняете потенциал под монетки,
то проще уже на языке монеток это и описывать.
Чем-то не темно занимаетесь, да?
В данном случае это как бы да.
Получается так.
Это называется да.
Нам нужно забить гвоздь.
Мы можем использовать молоток и можем использовать тополь.
То мы можем там подгонять какую-то логику молотка
и подгонять её к топору.
Но кажется, может вместо этого лучше использовать молоток?
Микроскоп.
Да, ну микроскоп это да.
После этого начинается микрохиругия бензопилой.
О господи.
Если посчитать как монетки,
посмотрите за монетками потенциала,
у нас много элементов, но больше половины,
и мы их удаляем. Получается мы отдаем монетки?
Ну да.
То есть потенциал он как бы жёстче в том плане,
что мы говорим, что лишние монетки мы ещё и отдаём.
Нет, в принципе это очень удобно,
когда нам даёт, вот вам две монетки, они нам не пригодились.
Это очень удобно, знаете, страховая компания,
которая иногда вам возвращает кэшбэк.
Почему не за что?
Ну просто не понадобилось.
Вы хорошо себя вели, и вас не потребовалось страховать,
так что вот ваши деньги, очень удобно.
Ну какая-то часть.
Самое смешное, что на самом деле иногда это реально работает.
Потому что, я не знаю, вы сталкиваетесь,
но вы вряд ли, когда-нибудь будете покупать квартиру,
вы сталкиваетесь с таким понятием,
как налоговый вытечет.
Глуботий смысл очень простой.
То есть это означает, что когда вы там
по крайней мере первый раз покупаете квартиру,
то государство какую-то часть ваших же налогов
вам же и возвращает.
По сути таким образом оно просто поддерживает вас.
Да нет.
Но я не помню за учебу.
Будет считаться, сколько с вашей зарплаты налогов
как-то ушло, но правда там есть ограничения сверху.
Бесконечное число денег вам не вернут.
Только за квартиру и только за первую?
Это то, что я знаю.
Может быть и другие вычисленные,
может бизнес тоже могут как-то поддерживать.
За всякий ложь тоже есть налоговый вытечет.
Возможно, возможно, да.
Это такое уже.
Где?
А, поп с релокацией на capacity.
Тут написано capacity поделить на 4 плюс 1.
Тут написано capacity пополам минус 2,
мы тут вот посчитали.
И тут написано 0.
И минус capacity на 4.
Это супер.
То есть оно может уходить далеко от нуля,
но в нужную нам сторону.
То есть в минус-то оно идет там сколько угодно.
То есть в принципе это означает, что наша фирма может провести корпоратив.
Чего?
Ну это уже по опыту.
Это уже вопрос ближе из цикла,
как решать задачу.
То есть понятно, что есть конкретные методы решать задачу,
но где-то все равно придется что-то нащупать.
Потому что это уже из цикла.
Как угадать потенциал, как понять,
как выводить тавтологию.
Будет у вас там от логики такое развлечение.
Я помню, меня там однорубник как-то писал.
Самый популярный метод решения задачи по линалу.
Заметим что.
У вас не Богданов ведет?
Нет?
Ну я не знаю.
Просто это означает, что я не знаю человека, который вас ведет,
поэтому ничего как бы сказать не могу.
Нет, линал это линейная алгебра.
Ладно, у вас называется алгебридиометрия.
Нет, математическая логика это другой предмет.
Но там замечать придется.
Ладно.
Так, хорошо.
Есть ли по всем вот этим вот веселым потенциалам какие-то вопросы?
Ладно.
Тогда соответственно, Даша.
Ладно, тогда придется нам сейчас...
Ладно, чтобы у вас...
Ладно, чтобы у вас домашнее задание было консистентным,
мы сейчас тогда поговорим немножко...
Вернемся к рекуррентам, а точнее обсудим еще один алгоритм,
который в этих рекуррентах нам не помешает.
А, впрочем, если останется время,
можно тогда и карацуку обсудить, что бы нет.
Вот так.
Нет, ну что, сам-то алгоритм простой,
там фурятино надо будет отдельно обсуждать.
Вот.
Что?
Может и лучше.
О, плосно.
О, спасибо.
Так.
Так.
Ну вот.
Ну вот.
Какую сейчас там задачу хочется порешать?
Ну, на самом деле,
можно даже сказать, что
мы попробуем искать даже не столько медиану,
сколько катую порядковую статистику.
Да.
Вот.
Точнее, вот.
На n элемент.
Там какие-нибудь.
Можем даже для простоты сказать,
что они попарно различны.
Хотя там одинаковость там ничего особо не даст.
А таян вот.
Нет, мы не хотим прям сортировать элементы.
Дано число k от 1 до n.
Ну вот.
И возникает такой, внимание, вопрос.
Если бы эти элементы отсортировали?
Если бы их отсортировали,
кто из них был бы катом?
Непонятно.
Но на самом деле абстрактно,
пока мы ничего не знаем о массиве,
и может быть кто угодно.
И нам надо придумать алгоритм, который это найдет.
Желательно за линию.
И тут идеи вообще возникают.
Но идея возникает такая.
Отсортировать за o от n мы, конечно, не можем.
Точнее, можем только в отдельных экзотических случаях,
но в общем случае это невозможно в принципе.
Будем когда-нибудь доказывать для общего случая,
что сортировка...
Будем, будем.
Ну там будем оговаривать,
да, мне уже страшно, конечно, что-то обещать.
Но думаю, это будет в следующий раз.
Да, да, да, да.
Ну как сказать, я понимаю, что...
Да, тут можно отдельно потом выписывать,
сколько того, что я сказал, не сбылось.
Но тут честно скажу, я думал, что это будет сегодня,
но как-то вот да, что-то вот...
Так, ребят, что за шум пошел?
Значит, смотрите. Итак, как искать kt элемент?
Мы отсортировать не можем, но можем
неожиданно взять следующее. Мы можем взять
какой-нибудь элемент,
допустим, у меня есть какой-нибудь x, который будет равен
какому-то аитому элементу,
и мы можем за линию
переупорядочить эти элементы так, чтобы
сначала шли все элементы меньше x,
потом шли все элементы
больше x.
Это сортировка за линию?
Нет, это не сортировка, это переупорядочение.
Вот эту процедуру мы будем называть
partition.
То есть от массива A
и какого-нибудь элемента x.
Кстати, этот элемент вообще имеет вполне себе
отличное название pivot.
А вот, ну, слово такое.
Конкретное дословное перевод с английского я не знаю,
но вот просто такое...
Ну, наверное, да.
Ну, можете там тоже в Google Translate заглянуть, что это значит.
Такое слово упоминается.
Значит, смотрите, в принципе, да, на самом деле
это уже метод сортировки, на самом деле.
Впереди, то есть метод сортировки.
Выберем какой-нибудь там pivot как-то.
Проведем за O от N вот такую операцию,
потом дальше запустимся рекурсивно от части массива слева
и части массива справа.
То, что я описал, вообще называется quicksort.
Ну, нет, почему?
Нет, дальше...
Нет, это, собственно, quicksort.
Это отличается тем, каким образом вы выбираете pivot.
Вот.
Но тут оказывается, что...
То есть тут возникают, конечно, проблемы.
Ну, потому что, например...
Да, ну вот. Да, но на самом деле тут давайте так сразу рассматривать
тогда два брата quicksort и quickselect.
Потому что, смотрите, какая ситуация.
Потому что если ваша задача найти катую порядковую статистику,
то вы берете pivot и первопорядочный массив так.
А также говорите, что если эта позиция оказалась катой,
то, поздравляю, вы возвращаете X и радуетесь.
Но вам могло не повести.
Но тогда что делать?
Если оказалось, что этот X оказался на позиции больше, чем K,
то вы вызываетесь рекурсивно от вот этого массива
и ищете в нем катый элемент.
Ну вот.
В противном случае, если тут оказалось меньше K,
то есть тут оказалось L,
а этот оказался на позиции L плюс один меньше K,
то вы ищете тогда в этом массиве, но уже не катый элемент,
а K минус L минус первый.
Понимаете, да?
То есть вот так вот как-то вы этим занимаетесь.
Вот.
То есть это так устроен алгоритм quickselect.
Вот.
Ну, в принципе, да, мечта.
Как вот выбирать keynote? То есть мечта.
То есть в идеале, если нам постоянно удается угадывать
элемент, который делит массив пополам,
то оказывается, что quicksort тогда,
очевидно, будет работать за n log n,
а quickselect, очевидно, будет работать за линию, правда?
Ну почему? Потому что первая фаза работает за n,
вторая за n пополам, третья за n поделить на 4,
ну и так далее. Да, сумма о геометрической прогрессии
не более чем 2n.
Вот. Но возникает только проблема
от сита. Можно ли настолько это идеально сделать?
Ну тут два варианта.
Можно попытаться это прямо идеально. Ну вот.
Но тут идея в том, что...
А насколько идеально нам реально надо?
Потому что давайте рассмотрим хотя бы с точки зрения quickselect.
Ну с точки зрения quickselect, допустим, нам фантастически везет,
ну ладно, нам теперь чуть менее фантастически везет,
и массив может уменьшается не в два раза,
но хотя бы в 10 девят...
в 10 девятых раз.
Ну давайте предположим, что нам
достаточно везет того, что на каждом шаре хотя бы
десятая часть массива да отсеклась.
Тогда заметим, что время работы у нас получается.
n
плюс 10 девятых n
плюс, там не превосходит, конечно,
там 10 девятых в квадрате n, да?
Да, да, да.
9 десятых, 9...
Да, да, да.
10 девятых в кубе, n плюс и так далее.
Ну предположим, что нам фантастически везет,
и pivot выбирается в quickselect так, что
на каждом шаге хотя бы десятая часть массива выкидывается.
Ну понятно, что...
Но заметим, что это равно
n на 1 плюс 9 десятых плюс
там 9 десятых в квадрате и так далее.
Но сумма диаметрической прогрессии у нас 1 плюс q
плюс q в квадрате, плюс это чему равно?
Ну да, давайте вот напишем,
что в степень q и минус 1 равно q в степени n
минус 1 поделить на q минус 1.
Но мы не знаем, вы степень... Нет.
Ну а в случае бесконечности,
ну понятно, при n, стремящемся к бесконечности,
обычно это 1 делить на 1 минус q,
но если, конечно, q меньше единиц.
И больше нуля.
Вот.
Нет, главное это константа, да.
Потому что это не превосходит в итоге, да,
потому что тут конечное число...
n на, соответственно, 1 делить на 1 минус 9 десятых.
То есть, короче, 10n.
Ну, короче, да. То есть, более жирная,
с более жирной константой, но это все еще вот это.
То есть, ровно за счет, в принципе,
на вот этой идее уже начинается такое,
слушайте, а давайте будем просто там пайвот
выкидывать рандомно.
То есть, ну если нам пару раз не повезет,
ну ничего страшного. А если нам в основном везет,
то как бы в основном будем уничтожать 9 десятых раз,
да, теоретически нам каждый раз может не везти.
То есть, если каждый раз пайвот выбирает
минимальный элемент, то да,
мы работаем тогда за n квадрат.
Ну ладно, n умножить на k, наверное, да.
Ну ладно, хорошо, ну ладно, там можно подгонять так,
чтобы там прям n квадрат был, если мы прям отсекаем,
все вокруг этого элемента прям отсекаем.
Да, в худшем случае, но это вот типичный случай,
на н квадрат, но в среднем будет адекватно.
Ну в среднем у отн.
Да, в среднем у отн это нам хорошо.
Ну с квиксортом будет та же интерес. То есть, видите,
понятно, что к квиксорту пайвот будет выбираться вот так неудачно,
то будет работать за n квадрат.
Но если он будет попадать вот куда-то так,
чтобы каждый элемент хотя бы 1 десятая, каждый массив,
то тогда уровней у вас будет, собственно,
и на каждом уровне вы суммарно будете работать за отн.
Поэтому суммарно будет n логен.
Ну там дальше начинается там всякое веселье в духе,
что там реально эстрелевский, конечно, квиксорт,
там он отсекается.
Он говорит, что если глубина рекурсии стала слишком плохой,
так давайте по-другому сортировать.
Вот, но это уже ладно, это другая песня,
это мы, видимо, в следующий раз будем обсуждать.
А пока...
Вот, но теперь мы поговорим, да, но это все касается рандома.
Да, то есть, вот, случайная, то есть, квиксорт,
квикселлект с рандомным выбором элементов,
вот, работают именно так.
Но теперь возникает отсюда вопрос, а можно ли выбирать
все-таки пайвоты как-то не рандомно?
И оказывается, что можно.
Вот. И вот, оказывается, да, то есть,
вот, с рандомом обсудили, а есть, оказывается,
не рандомный вариант.
Так, сколько у нас там? Нормально.
Значит, смотрите, сейчас будет немножко магии.
Так, ну ладно, не будет.
Там магия будет...
Господи, магия будет, когда мы эту очередь
на шести стеках пилим будем, а тут...
Ну да.
Красивая структура.
Ну, это прокучит либо наче.
Так, сейчас смотрите. Итак, задача.
Ну, сейчас мы на самом деле будем такой, программа заставы.
Да, задача. Хочется выбрать катую порядковую статистику
для этого.
Значит, как же это сделать?
Делать мы это будем весьма неожиданным способом.
Так, да. Сразу напишем. Сейчас это будет называться
алгоритм...
Вот. Блюма.
Дефис. Или керетов, ладно.
Флойда.
Брата.
Ривеста.
Тарьяна.
Ой, доска заканчит. А, все.
Да, их пятеро.
Да, у нас в этом смысле будут два рекордсмена в курсе.
Алгоритм Блюма, Флойда, Пратта, Ривеста, Тарьяна
и алгоритм Орикава, Оребурга, Коса или Парка.
ЛЦПшки в суфмассе, конечно, будем.
Не, это Керкианин Сантакс.
Это две фамилии.
Вот. Ну, правда ладно, там их много алгоритмов.
Хотя, скорее всего, наш алгоритм будет построить
суфдерева лучше Уханином и ДФС.
Запусти, проблема.
Да, делов-то.
Ну да, что такое?
Лучше ты на суфавтомат построить из него суфдерева,
а дальше в суфмассу.
Да, да, да, Генту Линукс, да. Можете сделать своими руками все.
Извини, я слышал, что чувак как-то на Олимпиаде вот такое
написал, потому что нужно было в суфмассу.
Я тоже слышал, помню, оказывали Михаил Тихомиров, если не ошибаюсь.
Нет, потому что я вот от него такой байку помню просто.
Нет, ну там просто там какой-то персистентный Уханин
надо было делать.
Вот. Так, ладно.
Давайте не будем ругаться страшными словами раньше времени.
Ладно, значит, смотрите.
Так, давайте попроще чуть, значит, смотрите.
Итак, значит, мы сейчас, ну сразу скажу, идея алгоритма та же.
То есть мы найдем какой-то пайвот,
разделим, вызовем процедуру partition
и, собственно, вызовемся от нужной части.
Но каким же образом
выбрать пайвот? Так, каким образом выбрать пайвот?
Теперь, смотрите, внимание.
Сейчас будет немножко магии.
Наши n элементов мы разделим на пятерки.
Абсолютно первым попавшимся образом.
Прямо хоть прям по массиву вот так вот.
Да, у нас n разделить на 5 пятерочек.
Ну понятно, там за у от н можно принять меры,
чтобы n делилось на 5, очевидно, да?
Ну там лишнее количество максимумов там честно найти
и выкинуть в рассмотрение или даже вернуть ответ, если надо.
Так что тут без особого ограничения общности там
можно...
Что?
Ну, смотрите, ну я сказал, если n не делится на 5, то вы там лишнее
нужно там n процент 5 максимумов можете за у от н найти.
Ну, логично, да?
Это неинтересно.
Господи.
Ладно, пока я рисую, у меня прям n трига. Зачем вам это секундомер?
А, слушай, супер.
Да, вот это прям супер идея.
Просто потом не хочется пересматривать...
Да, прям тут возникает вопрос.
Если лекция, то мне хочется пересматривать, зачем ее записывать.
Ну да, да, да, да.
Нет, все понятно, просто забавно звучит.
Вот.
Так вот, смотрите.
Значит, смотрите, ребят, ребят, ребят, ребят.
Нет, ну там, знаете, уровень бесконечности.
Сначала точные тайм-коды, да, потом там, в общем,
с ответками, когда мы вернулись к старой теме, когда мы там
вообще-то обсуждали. Хотя да.
Это, конечно, практически нереально, знаете.
Это когда как бы вопрос за кадром там озвучивается в виде текста.
Вот.
Ну да, иногда и такое бывает, но...
Нет, ну...
Нет, ну это нереально, потому что это потом как бы...
Не выкручивай.
Нет, пройти, тут проблема, чтобы это монтажеры делали,
им должна поступить соответствующая информация.
То есть вы там готовы запомнить там,
какой вопрос Арсений задал на 57-й минуте этой лекции.
Сейчас, тихо, тихо, тихо, не слышу вопросов. Чего?
Нет, случайность.
А вот это вот не случайность.
Мы забьем массив на пятерке,
но, внимание, внутри каждую пятерку мы посортируем.
Ну каким образом, абсолютно не важно.
Это другой вопрос.
Ну, дайте, легче уже отсортировать и не париться.
Значит, смотрите, теперь идея такая.
Значит, мы посортируем эти пятерки,
и в каждой пятерке выберем медиану.
Вот в каждой пятерке выберем медиану,
и рассмотрим вот этот массив
размера n поделить на 5.
Да, массив этих вот медиан-пятерок.
Так вот, теперь идея такая.
Выберем медиану в нем.
Мы это сделаем рекурсивно.
То есть мы вызовем нашу функцию.
То есть мы вызовем в этом месте функцию partition.
То есть вызовем quickselect.
То есть quickselect от этого массива.
Ну, давайте я вот так и напишу.
Ну, давайте я вот так и напишу.
Ну, давайте я вот так и напишу.
Quickselect от этого массива.
Ну, давайте я вот так и напишу.
Quickselect, допустим, от массива A и, соответственно, K.
И так и пишем.
Разбить A
на пятерке.
Сказать, что B
это массив
из N поделить на 5
медиан-пятерок.
Ну, вот.
Теперь внимание.
Значит, X это
вызываем quick,
соответственно, select от B
N поделить на 10.
То есть там мы прям честную медиану находим.
Ну, вот. Ну, а дальше
по сути вызываем
значит, там скажем
pos равно partition
от A и X.
Ну, pos он возвращает, где этот X
в итоге будет лежать.
Ну, и дальше там стандартный вот этот вот.
Понятно, что если pos там больше K,
то там, понятно, return.
Там quickselect.
Соответственно,
от A от 1 двоеточие pos.
Ну, давайте я так напишу.
А quickselect это катый элемент?
А, вот я так напишу.
Извините, у нас сейчас quickselect
ищет медиану.
Нет, quickselect ищет катую порядковую статистику.
А, но при этом мы запускаем его, чтобы он нашел медиану.
Да, видите, поэтому мы тут пишем не K, а N поделить на 10,
потому что размер этого массива N поделить на 5.
Но LZ,
там, понятно, pos плюс 1 равно K там,
если уж совсем прописывать, то return просто X.
LZ, там, понятно, return.
Там quickselect там.
Вот это вот всё, blah-blah-blah.
От, значит, A от pos плюс 1 двоеточие pos.
Да, я тут, конечно, у меня массив немножко в один индексации,
не думаю что для вас это прям проблема и к получится минус пост да вот так
выглядит алгоритм такой псевдо коду такой вот а нам даже не пост нам сам
элемент надо вернуть нам надо еще написать что если у нас размер а меньше
ну да да да да формально каждый нам обязан написать что если там называется
сайза там то есть если n меньше либо равно там я не знаю какой например там
пяти то найти то там найти в тупую да да да но я говорю найти я это звать найти в
тупую давайте абстрагируемся от этих там незначительных деталей partition он
ничего не возвращает он берет массив и переупорядочивает в нем элементы
переупорядочивает в нем элементы таким образом что сначала идут элементы меньше
икса потом x потом больше икса да нет это не нет это не сортировка потому что
элементы меньше икса в этом в этом под массиве можете как угодно вот это
можно сделать за линию ну как угодно можно там отдельная веселая задача как
это сделать без дополнительной памяти но вот но как бы там можем сейчас
отдельно обсудить если останется время но я но это не принципиально
где в начале в смысле ну разбитые пятерки можно просто вектор пятерок
создать и не парится то есть это есть вы ищите медиану но мы но мы идем на более
общую задачу мы ищем катую порядковую статистику где к может быть равно
пополам то есть медиану мы то есть медиану мы тоже ищем но как бы но здесь
удобнее искать катую порядковую статистику значит смотрите казалось бы
да вот теперь давайте думать вот здесь у нас но вот то есть теперь можно сказать
следующее что вот но теперь но заметим что у нас есть два имеет место два
рекурсивных вызова нас пишем рекурренту т от n то есть если мы ищем катую
порядковую статистику в этом массиве да то она не ну так формально не
превосходит ну ладно но вот т от n поделить на 5 потому что мы вызываемся
вот от массива в 5 раз меньше плюс т от чего
т от как по ответ пока как повезет чего ну можно так сказать до n-2 но я
пока даже ничего писать не буду а и плюс от потому что заметил что все что
кроме рекурсивных вызовов мы делаем за линию
ну может от это пожалуйста какая разница но мы сверху оцениваем поэтому вот но
конечно теперь стоит только понять отт от чего если я тут в худшем случае
скажу что это т от n то это нас не интересует даже если я напишу t-1 нас
тоже это не устраивает нет это нет n-1 это не бесконечность это n-2 это n дай бог
чтоб квадрат да ну да да да скорее всего квадрат но заметил что мы не
просто так делали этот вызов на самом деле утверждается что здесь здесь будет
всего не хуже а что же здесь будет а теперь давайте попробуем значит для
того чтобы понять какую тут хорошую оценку мы можем написать вот я жалко к
ну ладно значит давайте давайте мысленно мысленно подчеркиваем мы тут не просто
эти пятерки отсектируем но еще я отсектируем вот эти все медианы
нет по факту мы этого не делаем мы там только медиану медианы еще но смотрите
как интересно вот вот она допустим вот она да заметим что все что слева и
сверху оно меньше либо равно нас а теперь думаем ну без лишних там каких-то
локальных округлений не будем о них там заморачиваться сколько элементов тут
меньше но заметим что пятерок здесь что-то типа n поделить на 10 мы плюс
минус одна да но и в каждой из этих пятерок по три элемента да то есть
получается здесь что-то типа 3 десятых n элементов то есть это означает что
этот найденный x обладает таким свойством что у нас массиве есть как
минимум 3 десят 3 десятых n элементов которая меньше нас но с другой стороны
мы замечаем что у нас есть по аналогичным причинам что-то типа 3
десятых n элементов которая больше нас то есть это означает что ну как бы
какой-то из массивов мы не знаем выкинуть будет левая часть массива или правая но
то что будет останется оно не более чем 7 n поделить на 10 потому что мы выкинули
как если мы из массива длины n выкинули хотя бы 3 3 десятых n то останется не
более чем 70 чего выкинули потому что ну выкинули но то что мы запускаем когда
мы запускаемся от массива это вот рекуссивно здесь это то же самое что мы
другую часть массива тупо выкинули нет вы гарантировали что у нас вот есть вот
одна один массив есть другой массив да мы гарантируем что в каждом из них есть
хотя бы 3 десятых n элементов но если их суммарный размер равен n ну ладно
минус 1 но там это и в каждом хотя бы 3 десятых n элементов то это означает что
в каждом из них в каждом соседе у каждого массива у соседа не более чем 7 десятых
поэтому получается вот такая рекуррент вот ну а теперь это просто теперь утверждение
мистическое теперь мистическое утверждение да т т равно как вы уже догадываетесь от
доказательства пишем нашу индукцию да в чем хотим тн меньше либо равно по индукции
значит cn ну и пишем т от n меньше либо равно cn поделить на 5 плюс ц на 7 десятых n плюс там
а это равно 1 5 плюс 7 десятых это сколько правильно 9 десятых cn плюс а это очевидно
меньше либо равно ц при ну там скажем я не знаю ц равно 10 а даже больше либо равно да ну потому
что мы гарантируем что если у нас есть вот этот вот второй запуск то мы гарантируем что размер
этого массива не более чем 7 десятых n не который второй вот этот вот этот да
ага так что вот такая вот красота
если а меньше чем что но если ц больше либо равно чем 10 а вот ну или что тоже самое если
а не превосходит ц поделить на 10 то как бы неравенство очевидно верно но как бы
такое такие ц подогнать можно вот так вот в чем а теперь собственно в чем у вас там задача в
домашнем задании теперь да ну заметим что ведь я тут мы сейчас тут опускаем там все технические
там опускает по первым пишем то что у нас тут есть неравенство да также опускаем еще то что тут
вообще округление какие-то есть вот где-то там плюс-минус единички но это мы забиваем вот ну
равно как и на то что чисто теоретически мы еще не явно подразумеваем что функция т монотонно
но мы подозреваем что вряд ли наверное если ну там что вряд ли наверное если массив увеличился
то алгоритм резко стал работать быстрее мы тут как-то вот сверху вот так оцениваем да но нас
это интересует вот что то то фактически задача такая вот мы говорим делим на пятерке да а
ведь почему на пятерке ведь мы могли бы делить на семерке или на девятке или на тройке или на
или на или там по 57 а внутри блока же мы тоже должны отсортировать да ну что но это же константа
ты же сортируешь массив длины 5 да ну и что 5 5 5 константа 5 квадрате тоже константа ну типа
да у нас это скорее всего будет работать дольше чем посортировать да нет смотрите по нет по константе
нас это интересовать не будет не волнуйтесь да да да ну да нет это действительно не интересен вот
поэтому но теперь вот будет загадка да то есть у вас будет получаться какая-то рекуррента то есть
вместо 5 тут у вас то есть если 5 у вас превращается в 2 л плюс 1 какой-нибудь да то у вас и тут
получается там что-то n delete на 2 л плюс 1 и тут что-то там получается да там вы опускаем то есть
интересовать будет такое но фактически вопрос будет такой при каких л как бы можно вот там
алгоритм все еще будет работать за отн а при каких л по крайней мере вот такое доказательство
работать не будет вот так да то есть вот собственно об этом и задача да нет она я не утверждаю что
она сложная ну да да да но там и смысл будет что как бы там задача так и написано по сути что
признаю что предположим что это формула прям истинно прям с равенством вот и тогда давайте
прианализируем при каких л по сути это у отн а при каких нет да да да да да да и что-то подоказывать
нет ну да их на них можно забить потому что смотрите потому что у вас в данном случае
там есть просто не более чем 4 лишних элемента да что мы с ним делаем так давайте просто там
4 максимуму найдем и выкинем их это все равно константа это это все равно константа пусть
она и увеличивается но нужно доказать что это не вот ну как бы самый найдетый способ докажите
что это омега от чего-нибудь побольше но как бы если докажете по-другому то как бы ну да да да но
можно рассмотреть нужно проанализировать эту рекурренту по сути и там понять при каких
эль она ровна от но при каких неров rom нет דоказательства не работает вот тут на
каком уровне шамане работает при что потому что вы недостаточно проанализировали рекур informações
или оно не работает потому что там рекурр Nãothat это жаль происходящее gardens another
уровень нас не интересует, а вот первый интересует.
То есть мы выжимаем, мы сейчас, то есть суть этого домашнего
задания выжить максимум из рекуррента.
Ну выжить максимум в том плане, чтобы понять, что
вы можете доказать, что t от n равно o от n log n, но ничего
лучше вы доказать не можете, просто потому что t от n равно
omega от n log n.
Вот.
То есть там нельзя доказать, что это на самом деле n log
n поделить на log log log n.
Ну мало ли, бывает такое.
Лог, ой, ну да, лог, лог, лог, знаете, у нас там будет
какой-нибудь один, у нас там вообще даже миностовый
будет с такой симпточкой работать.
То есть если количество, если e больше чем v log log log
v, то наш алгоритм будет работать за o от e.
Там же какая-то штука с обратной функцией открывается.
Ой.
Вот до этой штуки я не знаю, доживем ли.
Не, не, не, там это разные штуки.
Нет, там вообще шедевры, если так забегать вперед,
потому что у нас будет алгоритм, который, да, если e больше
чем v log log log v, хотя в общем формулировку я могу написать
любое константное количество v, то как бы алгоритм работает
за o от e, а так на самом деле общая симпточка e на логарифм
звездочка.
Да, логарифм звездочка это не обратная функция
да, итерированная логарифм, да.
А это означает, дано число, итерированная логарифм
числа x.
Сколько раз нужно брать числа двоичисленного логарифм,
чтобы он стал там меньше одного?
Ну вот, то есть это да, то есть это не обратная функция
кермана, это чуть более быстро растущая функция, но чуть.
Чуть.
Да, ну где-то там в очень-очень-очень-очень
там в очень-очень параллельной галактике, да, она конечно
там, да.
Да-да-да-да-да-да, но знаете, в наших этих человеческих
ограничениях все равно мелочь одну, мелочь другую, как
все равно эта мелочь пожирается реальной константой вашей
реализации.
Вот, ну и другое, но там со словами будет там вообще
много шоу, там есть такое, но там софтхипом можно написать
алгоритм, который будет работать за e на реально обратную
функцию кермана.
Ну ладно, и то вранье, потому что окажется, что там будет
ена, какую-то мистическую функцию, которая на самом
деле не более чем в 9 раз больше обратной функции
кермана на самом деле.
Да, на самом деле.
Не всегда, но там у него есть гарантии, что там этот
ответ ну не совсем прям неправильный, то есть там
такой трейдов мне, что я могу работать чуть-чуть
быстрее, но мой ответ будет чуть-чуть более неправильный.
Чуть-чуть быстрее, да.
Да.
Чуть быстрее, а дай хер.
Ну да, ну то есть условно, как бы у него есть две крани,
но там, нет, смотрите, софтхип, это шо такое, тоже хип.
И он говорит, все операции я делаю за от единицы, кроме
инсерта.
Инсерт будет работать за алгоритм 1 делить на епсилам.
И при этом я, но при этом епсилам это какая-то константа.
Мелкая там от 0 до 1 и второй.
Вот, но, нет, логарифм 1 делить на епсилам, ну не совсем,
да, но нет, ну не совсем, но константа такая относительная.
Ну потому что в данном случае восьминтотика это, восьминтотика
епсилам участвовать будет, потому что епсилам может
быть, например, 1 делить на n, а может быть там, я не
знаю, одна треть.
Подожди, логарифм 1 делить на епсилам, это константа
с константами.
Да, но просто это параметр алгоритма восьминтотике
тоже он будет учитываться.
То есть я говорю, он учитывает, что инсерт работает за логарифм
1 делить на епсилам, но и епсилам может зависеть
от n просто.
Вот, но просто там фишка такая, просто он внутри
себя софтхип говорит, смотрите, я тут вот всем элементам,
вы мне суёте, присваиваю псевдоним, то есть это типа
я вешаю на него табличку, чему он по моему мнению
равен.
Ну типа я могу там на Ваше повесить табличку Пети
и сказать, это Петя.
Ой, я так серьёзно в классе в сериусе делал.
Вот.
У меня был одногрупник Максим, я его Ваней называл.
Да, вот, да, это удобно, да.
Единственное, я гарантирую, что я тебе буду называть
то, чем я тебе буду называть не меньше, чем ты.
Ну то есть условно говоря, я не могу обозвать 179.57,
но я могу обозвать 57.179.
Вот.
Так вот.
Так вот, я буду обзывать их вот так и когда от меня
попросят достать минимум, я буду возвращать реально
минимум, но вот по этим табличкам.
Да, то есть никаких гарантий я не даю, кроме одной.
Я гарантирую, что если ты в меня добавил n элементов,
вот n инсертов, да, то я гарантирую, что, внимание, в каждый
момент времени, в каждый момент времени, вот тут очень
аккуратно, у меня, внутри меня находится не более
чем эпсилон умножить на n элементов, у которых
на табличке написано что-то отличное от их самих.
Вот.
То есть чем больше n, то есть смотрите, получается, чем
больше эпсилон, тем как бы да, тем быстрее я работаю,
но как бы тем больше табличек я там, тем больше табличек
я пишу левой пяткой.
Но на самом деле, забирая вперед, я скажу, что на самом
деле просто скорость заключается в том, что на самом деле
там все элементы отправляются просто там, у себя, они там
хранятся в какой-то единой палатке, на которой написано
что здесь живет Вася.
Все.
Вот.
Я считаю, что все, кто там живут, это Вася.
И пока Вася будет минимальная табличка, значит будет доставать
оттуда по очереди.
Как только, ой, палатка пустая, ладно, теперь реально
убрали палатку и так далее.
Иногда палатки начинают объединяться.
То есть там замечательное шоу на эту тему будет, но
вот.
Но как бы, помните, да, если, ну вот, то есть понятно,
что условно, если вас там, то есть если у вас там
действительно, там, Эпсилон бывает 1 на треть, ну окей,
значит у вас гарантируется, что там, в каждое время
времени у вас будет до n поделить на три элемента,
которые по неожиданной причине могут быть не то, что надо.
Но есть другая крайность.
Если Эпсилон равно 1 делить на 2n, то гарантируется,
что неадекватно там не будет вообще.
Но тогда при этом и инсерт будет работать за логарифом.
Но тогда это, скажем, по сути, это будет такая экзотическая
реализация биномиальной кучи, на самом деле.
Вот.
То есть в пределе вот так.
То есть это такой трейдов.
Да.
Эпсилон мы сами ставим?
Да.
Эпсилон мы ставим сами.
Это параметр алгоритма.
Так вот, вот фишка, то есть как бы зачем это вообще
надо?
То есть это на самом деле нам надо, это вот, может быть,
алгоритм из цикла, вот, мы хотим медиану, да, но заметим,
что для каких-нибудь наших целей типа партишена нам
точно медиана не нужна.
То есть, в общем-то, если мы возьмём медиану там плюс-минус
что-нибудь, нас это устроит.
В общем-то, туда-сюда там, туда-сюда там плюс-минус
там n поделить на 5.
То есть, например, там просто, вот теперь с помощью такого
вот софтхипа, вот, например, там будет алгоритм такой,
будем подробно ещё обсуждать, но смотрите, давайте, как
найти примерную медиану, вот теперь я хочу найти
элемент, который будет в отсортированном массиве
находиться во второй-третьей элементах, да, ну типа есть
третьи элементы меньше, есть третьи элементы больше.
Как мне это сделать?
Так вот, движение такое.
Берём все эти элементы, создаём софтхип с эпсилон
равно n поделить на 3, значит, с n поделить на 3, значит,
суём туда все эти элементы.
Каждый суётся за вот единицы.
Простите, а разве не приходит на n?
Вы же скажете, что эпсилон меньше 1 и 2.
Эпсилон меньше 1 и 2, да.
И поэтому я говорю сейчас пусть эпсилон равен 1 треть.
1, 1, 1 треть, всё нормально.
Значит, запихнули, и после этого достаём из этого хипа,
значит, n поделить на 3 элементов тоже за линию, да, и выбираем
из этих элементов реальный максимум.
Всё, утверждение – это то, что нам надо.
Почему так?
Да, просто потому что, смотрите, фишка такая, что да,
то, что оно вам выдаст как минимум, конечно, не обязано
быть минимум.
Но в каждый момент времени гарантируется, ну, как бы
тогда вы легко можете сказать, что, смотрите, этот элемент
он по псевдонимам меньше, да.
Напоминаю, у нас псевдоним не может быть меньше нас
самих.
Поэтому отсюда следует, что когда вы достаёте минимум,
вы гарантируете тем самым, что прямо сейчас в куче
находится не более, чем n поделить на 3 элементов,
которые меньше нас.
То есть не совсем там что-то от балды достается.
Поэтому отсюда в принципе и будет следовать, что на
самом деле максимум из того, что вы достали, он не
там порядковая статистика не менее, чем n поделить
на 3, ну, потому что вы достали n поделить на 3 элементов
и как бы выбрали из них максимум, да.
Но с другой стороны, его номер вот в ацеркированном
массиве не более, чем 2n поделить на 3.
Вот.
То есть потому что гарантируется, что там, когда вы его доставали,
в куче было хотя бы n поделить на 3 элементов, которые реально
меньше его.
Да.
А сколько памяти занимает он?
Нет, там...
Допустим, если мы его запустим для стриминга.
О, Господи.
Нет, для стриминга...
Нам придется все элементы сначала положить в видео.
Да.
Нет, смотрите, для стриминга такие алгоритмы вы не запихнете,
потому что он тоже гат амортизированный, естественно.
А амортизированные алгоритмы для стриминга это опасно,
потому что...
Что такое амортизированный алгоритм?
Это означает, что алгоритм в целом работает хорошо,
но в любой момент может зависнуть.
То есть не потому, что он там...
То есть не потому, что там в компьютере что-то глючит,
а потому что вот, оказывается,
компьютер вздумывался проделать реаллокацию.
Ну или там...
Переустановить Windows, я не знаю.
То есть, знаете, когда вы делаете стрим,
наверное, не очень хорошо,
если в любой момент прибоит трансляция,
и может там, я не знаю, сервер захочет
переустановить там Windows какой-нибудь, да?
Ну или там, на какой операционной системе это делается.
То есть поэтому, помните, да,
что структуры с амортизированной стоимостью
у них ограниченная,
очень ограниченная применимость.
То есть они хорошо работают,
если у нас есть задача там,
просто задача сделать что-то,
и нам нужно гарантировать,
что вот все это глобально будет там за две секунды работать.
Да, это нас устраивает.
Но если нам хочется,
если у нас структура данных видов,
мы делаем запрос,
если мы хотим делать запрос,
но какие-то запросы структуре,
если мы хотим, чтобы структура их там делала четко,
то обычно,
особенно если эти запросы откуда-то извне приходят,
то естественно будет хотеться,
чтобы структура не зависала,
а действительно за удобоваримое время вам что-то выдавала.
Вот.
По этому там, то есть условно там,
ну, обычно там это либо передача каких-то сообщений
по каналам обычно,
либо, например, если у вас там какие-то,
ну, то есть я не знаю,
либо какие-то микропроцессоры делаются,
и если к ним какие-то запросы делаются,
то внутри их никакие там сплей деревья
или там кучи фибонаки зашиты быть не должны.
Просто потому, что микропроцессор
не должен зависать по подобного рода математическим причинам.
То есть он как бы всё,
он должен всё.
Мне сказали операцию, я её вот за секунду выполнил,
и всё. Вот.
Ну, там будет хорошо, если там некоторые буду выполнять
за пол секунды, некоторые за 7,
но как бы вот за одну секунду выполню железно.
Вот. Ну, а если у него сильно
большого разброса по времени не будет,
так вообще кайф будет.
То есть чем более стабильно, тем как бы и психологически
удобнее будет с ним работать.
Так что вот такая вот нотка.
Поэтому да, вот амортизация, это конечно
не очень, но не говоря уже, конечно, о персистентности.
Сколько у нас времени?
Десять минут.
Десять минут после пары, да.
Ну, как всегда, да.
Ну, с персистентностью, ну ладно,
про персистентность мы видим,
почему персистентность и амортизированность
действительно работают не очень, мы тогда, видимо,
начнем в следующий раз.
Ну, вот.
Да.
Ну, это если вы знаете, что персистенция,
мы это обсудим, да.
Ну, пока же, да, напоминаю, что через неделю у вас
дедлайн по задачам, напоминаю, что у вас
появится еще одна. Ну, в принципе,
вы можете уже начать ее решать.
Ну, на видео эта задача уже сформулирована, если
что, так что. Ну, вот.
Ну, впочем, я ее оперативно вывешу.
Если амортизированность не детерминированная,
а рандомная, то по идее персистентность
ну, что такое у нас,
а у нас вот сейчас амортизированность она детерминированная.
Ну, в плане от одинаковых действий
разное время работает.
Ну, не, ну, все равно
не пойдет. Вот у Вектора всегда от единицы,
да, у всей операции, но там же какая
конкретно будет зала. Я имею в виду, что, например,
мы, не знаю, выполняем раздом же элемент.
Да. Вы выбираете.
Тогда если мы откатим, то все равно рандом...
Смотрите, рандом в этом смысле тоже
плохо, потому что нет гора, потому что
в любой момент она все равно может зависнуть.
То есть раз в год она зависит.
Я не про персистентность говорил.
Тогда не получится откатывать.
Вот давай сейчас Костя вопрос.
А можно у вас вопрос, с чем у нас
расписание на 10 минут в природе, если мы всегда опаздываем на 10 минут?
То есть мы опа...
Так, на первой паре мы на 10 минут
опаздываем по одной простой причине, опаздываю я.
Как бы это...
Ничего? На первой паре опаздывают
в мещере, да, потом вы.
А, то есть он просто знает за мной этот прикол, да.
Или по независимым
причинам опаздывать, да.
Ну, как вам сказать?
Ну, не знаю.
Нет, ну честно скажем так.
Это скорее косяк преподавателей называется.
Да, все это вот. То есть это
потому что косяк преподавателей, да.
Потому что первая пара должна начинаться в 9,
вторая пара здесь должна начинаться в 10.35.
Да.
Нормально, что я вместо пятерки подставил
типа 2k плюс 1,
и у меня получилось, что оно выполняется
2k больше или равно единицы.
Прям больше или равно?
Нет, это не нормально.
Да, мне тоже так кажется,
но вроде логично все.
У меня случилось просто больше.
Ну...
Типа должно быть просто больше единицы.
Ну...
Ладно.
Так, ладно.
Все, не буду палить ответ. Ладно, тогда на сегодня все.
А то у вас там у кого-то
еще следующая пара есть.
У всех.
А, у всех?
А, а что-то никто не приходит.
Вещерин опаздывает.
А, вещерин опаздывает.
А в чем смысл?
Нет, ну, смысл простой.
У вас один день на темиряйзерской.
Значит, смотрите, так...
О, да, прям буду как экскурсовод такой,
знаете хоть.
Нет, причина...
Ну, смотрите, так на самом деле отчасти исторически сложилось.
И сложилось вот почему.
Обратите внимание, что у вас не совсем...
Что у вас здесь находятся не совсем случайные предметы.
А у вас именно...
То есть обычно тут проходятся именно вот лекции,
семинары по алгоритмам.
Ну, именно по алгоритмам плюс самые там...
И в будущем тоже в основном скорее
по прогерским предметам, хотя математика тоже будет.
Почему это сделано? А сделано это вот почему.
Потому что обычно...
Ну, ладно, в нашем случае
это сложнее, потому что...
Ну, вообще, как бы подавляющее большинство
подавателей по подобного рода прогерским предметам
это действующие разработчики каких-нибудь компаний.
Ну, там Яндекс, Аби,
там ВК, там и так далее.
Вот.
Нет, это лишь означает,
что скорее всего, то есть многие прибавительно
работают по принципу, что у них есть там две пары
в неделю, то есть они их приезжают,
то есть они даже там проводят пары,
а потом после этого едут, собственно, на работу основную.
Вот.
Поэтому, значит...
Поэтому это сделается для того, чтобы им не надо было
ездить в Долгопрудный.
Ну, потому что, смотрите,
то есть как бы отсюда до Яндекса доехать как-то ближе,
чем из Долгопрудного, правда?
Ну, почему?
Нет, смотрите, у вас есть Илья Мещерин,
который работает в ВК.
Знаете, в ВК, наверное, отсюда все-таки ближе доехать,
чем из Долгопрудного.
Ну, или вот у вас есть еще Федор...
Там некий... У вас еще есть Федор Букреев,
где он работает, я не знаю.
Да.
Они откуда?
Я из Индии.
Вы из Долгопрудного едете или из Москвы?
Пора.
Ну, в зависимости, я там в разных местах живу.
Вот.
Но это уже...
Но это уже детали.
Ну, просто понять, суммарное неудобство
оценить.
Нет, у меня в зависимости.
В зависимости от того,
где я в какой-то момент живу, может мне там...
Потому что я бываю в Долгопрудном, бываю живу в Москве.
Так что там рандомно.
Так что-то соответственно.
Попрос по домашнему.
Вот в этой задаче, где, типа, найти,
какие ка подходят.
Нам для обоснования задача будет
просто поставить вместо пятерки
там по ка плюс один
и показать, что это доказательство
не срабатывает? Или...
Нет, этого не достаточно.
Ну, не срабатывается, смотря в какой причине.
В смысле оценить...
То есть, если вы покажете, что там при
каких-то ка действительно эта рекуррента
оказывается просто железно не ОАТН?
То есть, не в смысле...
Да, потому что оно работает только при
ка вот в таких ограничениях.
Ну, да. Ну, другой вопрос, что, как бы, да,
если вас... То есть, напоминаю, да, что у вас...
Если вас не сложилось доказать, то прям по такой
системе могло сложиться, что там ТЦН-Д
сработало, да?
Это тоже всё...
Ну, да.
То есть, минус Д тоже пытаться...
Нет. Ну, там легче бывает
просто доказать, что эта рекуррента, она не
это ОАТН.
В смысле при других ка, да?
Ну, при каких-то.
Ну, потому что может быть так, что вот эта рекуррента
записана при каких-то ка, там решение
просто не окажется, что
не окажется, что ТЦН равно ОАТН. То есть, окажется,
что оно там омеряет чего-нибудь
большего.
То есть, и всё. Тогда это уже железобетонное
доказательство, что вы не... там, что
ОАТН не получится.
То есть, нам нужно показать, что при
каких-то ка это вот такое доказательство
сработает, а при остальных доказать, что
оно просто не будет никогда работать.
Что просто это рекуррент?
Ну, да.
Ну, да, да, да.
Если у нас
есть один такой элемент, то
partition должна возвращать
паку из начала и конца.
Из двух позиций.
Ну, по-разному.
Можно так. А можно просто сказать,
что давайте в качестве элемента
имеем в виду пару видов самого элемента
исходного индекса, какого-нибудь.
Ну, то есть, да.
То есть, это уже такие технические
детали. Ну, в принципе, да, по-разному
можно. Да.
Так. Не, прям мне даже интересно это...
А...
О господи.
Странно.
Так, интересно, так.
Не, просто...
Как всегда, это как всегда. Если Илья не собирается
приходить, можно как бы и продолжить.
Не, мне прямо даже
интересно. Ладно.
Ну, это все нормально.
Да.
Это все нормально.
Дима, у тебя даже поза.
На очень высоком комфорте.
Ну, это все хорошо.
Мне кажется, это что-то...
Кару мы пяти видимо оптимально
на небольших.
Нет, это действительно не кару.
Да, кару мы пяти видимо оптимально
просто на небольших.
Или кару, но...
Кстати, а если используете 9 часов?
Мне кажется, это будет мечта.
Внутри 1 группа.
Ну, слушай, ты если еще партийщешь, это вот это.
Нет, внутри 1 группа.
Да.
Это все нормально.
Которые надо скинуть.
Если еще раз, что делать?
Если он предлагает
вот эти элементы меньше, где-то все больше.
Значит, их хотя бы...
Чего?
Ну, меньше, как стартов.
Ну, ладно.
Ну, прости, как стартов.
