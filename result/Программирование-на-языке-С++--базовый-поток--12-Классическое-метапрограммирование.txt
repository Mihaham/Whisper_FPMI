Всем добрый день, давайте начнем. Сегодня мы продолжим изучать метапрограммирование в C++,
ну и поговорим про некоторые особенности программирования на типах в C++. Наверное,
для начала стоит сказать несколько слов по поводу того, что такое в принципе метапрограммирование.
Ну, смотрите, если мы все время до этого изучали сам язык C++, как писать функции,
как писать классы, их методы, то вообще говоря, мы программировали в терминах того,
а как написать программу, то есть как написать программу, которая сделает определенные действия.
Вот. Метапрограммирование же отвечает на вопрос, как написать программу,
которая будет за меня писать программу. То есть, кругу говоря, мы пишем такую надстройку над
программой, которая автоматически либо подставляет какой-то код, либо автоматически этот код убирает,
и так далее. Вот. Соответственно, сегодня поговорим про классическое метапрограммирование,
под которым я понимаю примерно следующее. Смотрите, современные стандарты C++ становятся
все более-более лояльны к метапрограммированию. Они добавляют новые и новые фичи, которые
позволяют более удобным способом сделать то, чего мы, собственно, хотим. А чего мы хотим,
узнаем в течение сегодняшней лекции. Ну и под классический метапрограммирование я понимаю
методы, которые существовали в языке C++ практически с момента его создания. Ну и, собственно,
цель сегодняшней лекции показать, что на самом деле механизм шаблонов, который есть в языке C++,
на самом деле очень мощный. Вот. Можно сказать, что вот такой вот шаблон. Шаблоны это такой вот,
по сути, язык в языке, который позволяет делать много разных всяких вещей. Ну и, собственно,
я надеюсь, что на сегодняшней лекции мы еще ближе познакомимся с шаблонами. То есть, появится
больше понимания того, как они устроены, как они работают. Вот. И приведем примеры решения
некоторых нетривиальных задач с помощью шаблонов. Ну прежде чем мы перейдем непосредственно к
задачам, которые мы и собираемся решать, задачу метапрограммирования, которые мы собираемся
решать, давайте вспомним или поговорим про такой механизм C++, как частично специализация шаблонов.
Ну я напомню, что в C++ у нас есть механизм полной специализации, который говорит о том, что,
если у меня есть какая-то шаблонная сущность, ну, допустим, шаблонная функция f, которая принимает
аргументы шаблонным параметром t, и она каким-то образом работает, то для этого шаблона я могу
написать специализацию. Что такое специализация? Специализация это, значит, сущность, которая
начинается с вот такой преамбулы. Темплит с пустыми треугольными скобками. То есть, если мы встречаем
темплит с пустыми треугольными скобками, означает, что сейчас будет идти специализация. Вот. Я хочу,
допустим, специализировать этот шаблон. Что я могу сделать? Точнее, что я должен сделать? Я пишу полную
сигнатуру функции f и везде вместо конкретного типа t, в сигнатуре функции данной или в типе
функции, я прописываю конкретный тип. Ну, допустим, int x. Что это будет означать? Это будет означать
следующее, что функция f является шаблонной, и в общем случае, что бы ни было подставлено в качестве
шаблонного параметра t, функция f должна действовать вот таким вот образом. Но, конкретно в одном случае,
конкретно в случае, если вдруг в качестве шаблонного параметра t мне подставит int,
то шаблонная функция f должна раскрываться вот с такую сущность. То есть, я могу сказать следующее,
что в общем случае шаблонная функция должна вести себя одним образом. Вот. Конкретно для
какого-то специфичного типа функция должна вести себя некоторым другим образом. То есть,
в частности, если я буду вызывать функцию f от doublet, то шаблон f от double будет инстанцироваться из
этого общего шаблона. Если я буду вызывать f от int, то шаблон будет инстанцироваться из
вот этой специализации. То есть, как все будет происходить? То есть, компилятор поймет,
что функция f является шаблонной. Он взглянет в этот шаблон и поймет, что в качестве параметра t
нужно вывести значение типа int. Вот. И в момент вывода типа t равным int, компилятор поймет, ага,
а для t равным int у меня есть специальное указание. У меня есть специальные правила, которые говорят
о том, что на самом деле нужно генерировать код не согласно вот этой функции, а согласно вот этой
функции. То есть, механизм вывода шаблонных параметров происходит ровно так же, просто-напросто
генерируется несколько иной код. То есть, в случае doublet и всех остальных типов генерируется вот такой
код. В случае int генерируется вот такой код. Это механизм полной специализации, когда я полностью
задаю все шаблонные параметры. То есть, я говорю, что если в качестве шаблонов параметров мне
подставлены вот такие типы, то я буду действовать иначе. Окей? Вспомнили. Что такое частичная
специализация? Ну, как следует из названия, частичная специализация это специализация,
которая позволяет задать либо неполный список параметров, скажем, если у меня тут был еще
какой-то шаблонный параметр. Вот. А тут я бы указал специализацию только для одного шаблона
параметра, допустим. Вот. То есть, я, допустим, указал шаблонный параметр только для t. Тогда
это была частичная специализация. Кстати, тут написан бред, потому что, как мы увидим далее,
частичная специализация для функций не существует. Но в целом, идея, надеюсь,
понятна. Что частичная специализация позволяет задать неполный набор типов или даже позволяет
просто задать семейство типов, для которых частичная специализация будет работать. Вот. Ну,
давайте посмотрим, например. Представь себе, что у меня есть структура isPointer, которая является
шаблонной. Ну, шаблонная структура isPointer, которая параметризована произвольным типом t. Вот. И
внутри себя содержит одно статическое poly bool value, которое равно false, и статический метод isn't
pointer, который тоже означает false. Что это означает? Это означает, что я в этой структуре храню
следующую информацию. В poly bool я буду хранить, является ли параметр t указателем, как следует
из названия isPointer. Ну, а метод isIntPointer будет возвращать конкретно, является ли указатель,
является ли передный тип интовым указателем или нет. Ну, понятное дело, что в общем случае
передаваемый тип не является не указателем, ну, не тем более интовым указателем. Окей. Что я
могу сделать? Ну, смотри, давайте посмотрим сразу вниз. Пропустим второй пункт. Давайте посмотрим
вниз. Смотрите, внизу написано полная специализация. Как я уже сказал, полная специализация
характеризуется тем, что я указываю конкретно тот тип, для которого я специализирую. И полная
специализация начинается с преамбулы template пустые треугольные скобки. То есть я пишу template
пустые треугольные скобки, дальше пишу структуру isPointer, и дальше в треугольных скобках для
структуры могу указать, для какого типа я специализирую мой шаблон. Я говорю,
что я специализирую структуру isPointer для типа инсозвездой. И в этом случае, если мне будет
передан инсозвездой, то я говорю, что value, то есть в статическом поливалью, должно храниться true,
а статический метод isPointer должен защищать true. Окей. Вот здесь нужно, вот что тут важно отметить.
Важно отметить то, что на самом деле полная специализация, полная специализация, ну, здесь
не полная, а вот полная специализация не обязана каким бы ты ни был образом соответствовать
основному шаблону. То есть в целом, в теории, я могу тут написать, не знаю, вот в этой функции
могу написать std.acout что-то, а здесь могу написать создание вектора, std.vector, его сортировку
и так далее. То есть вообще говоря, шаблон и специализация могут вести себя абсолютно разным
образом. То же самое касается структуры. То что я тут, так прости, то что я в основном шаблоне,
и в специализацию я написал практически один и тот же код то есть то, что у меня основной шаблон и
специализация содержит те же самые поля и те же самые методы, это, на самом ли, совпадение. То есть,
в принципе, в специализации я могу прописать абсолютно другую структуру, которая ведет себя
абсолютно другим образом. То есть у нее могут быть абсолютно другие поля, абсолютно другие методы.
Окей. То есть в специализации основной шаблон не обязан быть хоть каким-либо каким бы ты
это не было образом связано структурно, то есть у них не обязаны быть общие поля,
не обязаны быть общие методы. Ну и конечно, частичная специализация,
вот как раз, давайте посмотрим на середину. Частичная специализация, напомню,
позволяет мне задать конкретное поведение, позволяет мне задать поведение не для
конкретного типа, а для некоторого семейства типов. Ну, в частности, я могу написать
следующее. Темпл от класс T, то есть ввожу шаблонный параметр T, и дальше пишу
struct isPointerTestSsDoy. Что это будет означать? Это будет означать, что этот шаблон,
точнее эта специализация, должна работать для всех типов,
которые удовлетворяют следующему соотношению, которые имеют вот такой вид.
Ну а какие типы имеют такой вид? Ну такой тип, такой вид имеют все указатели,
согласны? Вот. То есть таким образом, я задал частичную специализацию для
всевозможных указателей. Ну, на самом деле, не для всевозможных, ну это мы посмотрим дальше.
В общем, для всех указателей, для всех обычных указателей это работает. Вот. И, собственно,
в этой реализации я задаю в статическом поле value значение true, и в поле isIntPointer
задаю false. Ну потому что в общем случае, ну потому что эта специализация принимает
указатель, но при этом в общем случае это не обязательно новый указатель. Понятно? Ну,
то есть примеры, какие примеры применения? Ну вот, соответственно, я могу создать,
точнее я могу обратиться к структуре isPointer от int, то есть передать в качестве шаблонного
параметра T int. И что будет происходить? Ну, понятное дело, в качестве шаблонного параметра T
подставится int в основной шаблон. То есть сначала подставка происходит в основной шаблон. То есть
в основной шаблон подставляется int, и дальше комплятор проверяет, а подходит ли тип int под
T с звездой или под int с звездой. Ну, естественно, int не совпадает ни с int с звездой, не может
быть представен в виде T с звездой. Поэтому работает общий шаблон, и в общем шаблоне у меня
возвращается значение value, это false, и isPointer false. Что пройдет, если я передам в isPointer значение
charge с звездой? Ну, пройдет следующее. Опять же, в общий шаблон подставится значение charge с звездой.
Дальше charge с звездой будет проверяться со всеми специализациями, подходит ли charge с звездой,
удовлетворяет ли charge с звездой вот этим соотношением. То есть то, что charge с звездой может
быть равен одному из этих типов. Ну, понятное дело, charge с звездой не равен int с звездой, но при этом
charge с звездой может быть представлен как T с звездой. Если я в качестве типа T, если я в
качестве параметра T подставлю charge, то я получу точное соответствие. Согласны? Поэтому тут подходит
частичная специализация, и в качестве структуры isPointer работает как раз таки частичная
специализация, которая в качестве polyvalue хранит true, и истатическая функция isPointer возвращает
false. Ну и наконец тоже простой пример. isPointer от int с звездой, естественно, вернет в обоих
случаях true, в обоих случаях единицу, потому что у меня есть полная специализация на случай,
если я в эту структуру передаю int с звездой. Окей? Механизм специализации понятен? Супер.
На этом слайде показан еще один пример частичной специализации. Еще может быть
специализация, которая указывает лишь какой-то определенный набор параметров. В частности,
у меня есть общий шаблон структуры S, который принимает два шаблона параметра T и U. И у меня
есть две специализации, которые являются частичными специализациями. Почему? Потому что первая
частичная специализация, она сдает конкретный параметр для U, но при этом говорит, что типа T
может быть любым. И вторая частичная специализация говорит о том, что первый параметр обязан быть
float, а второй параметр может быть каким угодно. Если я создам структуру от bool bool, то я получу
единицу. Почему? Потому что вот этот вот S с параметрами bool и bool не подходит ни под вторую,
ни под третью специализацию. Структура bool int подходит по вторую специализацию, поэтому работает
она. Cons-float bool подходит по первую специализацию. Почему? Потому что, несмотря на то, что тут
качество первого типа указан cons-float, cons-float не совпадает с float. Поэтому третья частичная
специализация не подходит и работает общий шаблон. Если я попытаюсь вызвать S-float int,
то произойдет неоднозначный вызов. То есть компилятор увидит, что с одной стороны S от float
int подходит под вторую частичную специализацию, в то же время S-float int подходит по третью
частичную специализацию, и тут возникнет ошибка компиляции. Если подходят несколько частичных
специализаций, то компилятор, во-первых, руководствуется принципом наименьших
постановок, а если количество постановок одинаковое, то возникает проблема. Ну и конец,
как я уже сказал, частичной специализации шаблонов функций не существует. Термин частичная
специализация применим только к структурам и только к классам. Частично специализировать
функции нельзя, функции можно специализировать только с помощью полной специализации. Договорились?
Хорошо. pedestrians.com
Давайте наконец перейдем к применениям этих самых частичных специализаций, что с помощью них
можно делать, как на них метапрограммировать, так как можно программировать над программой или как
можно программировать еще, Infod knighting , называютarda программирование над
типами то есть мы в MOMY используем программируем над объектами, да, над значениями, вот
а в метапрограммировании мы будем программировать над типами
ну и давайте начнем с такое применение как определителя типов
смотрите давайте я приставь себе следующую картину
представлять тебе следующую картину у меня есть книг про шаблонная функция
verted?
И что может быть с этой шаблонной функцией?
С одной стороны, я могу вызвать функцию f от единицы
и в качестве шаблона параметра t получить int.
Согласны?
То есть, если я вызову f из единицы, то в качестве
t выводится степь int.
С другой стороны, если я вызову функцию f вот так,
const int и передам туда единицу, то что произошло?
Я тут явно указал шаблонный параметр, и тогда в качестве
шаблонового параметра t у меня будет выведен const int.
Ну, понятное дело, что в зависимости того является
тип t константом или нет, я могу выбирать различные
варианты реализации.
Ну или, например, не знаю, наверное, больше смысл
имеет там персант.
Ну и в частности, если мы передали просто int ссылка,
то есть как, не знаю, не в этом случалось, f от x и тут
f от x.
Если мы передали int ссылку, то соответственно, я знаю,
что вот этот x можно менять, то есть можно менять исходный
x, и тогда это изменение отразится на внешней переменной.
Если вы мне явно указали, что я хочу передать по
константной ссылке, я хочу передать const int, то соответственно
сюда вместо типа t будет поставлен const int, получится
const int ссылка, и тогда этот x я менять не могу.
Понятное дело, что в зависимости этого поведение моей функции
может меняться.
Согласны?
То есть могу я изменять x или не могу я изменять x?
Это абсолютно две разные вещи.
Вот.
Возникает вопрос, как находясь внутри функции, вот представьте,
вот я пишу шаблонную функцию, и мне в какой-то момент нужно
понять, вот тип t является константом или нет, как это
можно было понять, имея на руках текущие знания.
Кажется, что более-менее никак.
Почему?
Потому что, вот как я проверю, является ли t константом
или нет?
То есть мне нужно написать что-то типа, если тип t константный,
если t константный, то нужно сделать что-то, а иначе нужно
делать что-то другое.
Через исключение, а каким образом через исключение?
Вот, смотрите в чем проблема, проблема в том, что если
я буду пытаться присваивать, ну понятно, как можно проверить
константность или не константность?
Я могу просто взять x и пытаться ему там присвоить
какое-то значение.
То есть в единицу.
Вот.
Что в этом случае произойдет?
В этом случае, если тип t константный, то произойдет
что?
Пройдет ошибка компиляции, да?
То есть у меня программа в принципе не скомпилируется,
а я бы хотел, чтобы программа компилировалась, но при
этом в зависимости того, является ли тип t константным
или нет, она вела себя чуть иначе.
И вот тут мы приходим к необходимости иметь такой
механизм в языке, как определитель типов.
То есть я бы хотел, чтобы шаблон каким-то образом
смог проанализировать вот этот тип t и сказать мне,
допустим, является он константный или нет.
Знакомьтесь, как это можно сделать с помощью механизма
частичной специализации?
Смотрите, что я сделаю.
Я напишу специальную структуру, которую назову искonst.
Структура искonst будет шаблонной структурой, которая
будет хранить внутри себя статическое поле value, которая
будет хранить false.
То есть я говорю, что в произвольном случае тип
не является константной.
Так?
А в каком случае структура искonst должна хранить значение
true?
Ну а структура искonst должна хранить значение true только
в том случае, если ей в качестве шаблонного параметра
передали константный тип.
Ну давайте я для этого случая напишу частичную специализацию.
Вот.
То есть что я пишу?
Я пишу частичную специализацию, то есть я пишу template class
t, структура искonst и в треугольной скобке передаю
конст t.
То есть в этот шаблон будут подставляться все типы,
в этот шаблон будут подставляться все типы, которые удовлетворяют
вот такому соотношению.
То есть если тип представим вот в таком виде, то он будет
выбран в качестве специализации.
Понятно?
Теперь, как это будет работать в коде?
В коде это будет работать так.
Ну давайте я напишу такую функцию.
Я хочу в зависимости того, является ли тип так констант
или нет, ну просто вывести на экран, допустим, констант
или не констант.
Я могу написать так.
Если искonst от t, 2.2.value, то tout конст.
А иначе, cout non-const.
Понятно, как это работает?
Да, 2.2.value, смотрите, у меня поле value статическое.
Вот, поэтому искonst от t, это я создаю, ну обращаюсь
к структуре, точнее, к констанцированию структуры искonst,
параметром t.
И в зависимости от того, что у меня будет передано
в качестве параметра t, ну, допустим, если в качестве
параметра t будет передан int, то я создам искonst от
int.
Искonst от int не подходит под шаблон конст t, поэтому
работает первый шаблон, и там в статическом поле
хранится значение false, поэтому тут будет false, я
попаду вот сюда.
Если же я в качестве параметра t передам констинт, то что
произойдет?
У меня искonst будет параметризован типом констинт, то есть
сначала констинт подставится в первый шаблон, а дальше
компилятор будет проверять, а подходит ли констинт
под какую-то из частичных специализаций.
И компилятор увидит, что действительно.
У меня есть констинт, и констинт может совпадать
с конст т в случае, если я в качестве т подставлю
int.
И в этом случае в статическом поле value будет храниться
значение true, соответственно, тут вернется true, я попаду
вот сюда, вот в эту ветку, и выведу конст.
Окей?
Я смог получить определитель типа, то есть я смог на основании
шаблонового параметра сделать вывод о том, является
ли это тип константа или нет.
Кажется, что раньше существующими способами C++ я этого сделать
не мог.
Теперь же я могу анализировать, то есть я теперь могу брать
шаблонные параметры, их анализировать, выяснять,
есть ли у них какие-то требуемые свойства или нет.
Понятно?
Ну, собственно, упростим предыдущий пример, я напомню,
что в прошлый раз мы с вами познакомились с таким
классом из стандартной библиотеки C++ как integral constant,
я напомню, что integral constant хранит внутри себя статическое
поле value определенного типа, который я передал в качестве
параметра шаблона.
И предыдущий код можно упростить так, можно сказать,
что из конст у нас следован от типа integral constant, вот
хранит внутри себя статическое поле bool со значением false,
а из конста от конста t, то есть частичная специализация
у нас следована от integral constant, которая в качестве статического
поля хранит bool и хранит значение true.
Окей?
Ну, пример можно упростить еще сильнее, на самом деле
в стандартной библиотеке C++ есть еще целый набор типов,
помимо того, что есть integral constant, есть еще bool constant,
по сути можно считать, что тип bool constant от B это то
же самое, что и integral, ну просто сокращение от integral
constant от bool и B, вот, в то же время есть специальные
типы true type и false type, которые равны типам bool constant от true
и bool constant от false, ну просто-напросто вот эти типы true type, false type и bool
constant, они позволяют упростить написание вот этих самых
определителей типа, то есть сейчас, например, если я хочу
написать, я хочу написать структуру, которая в качестве
поля просто-напросто хранит значение false, как на предыдущем
слайде, я хочу написать структуру из конст, которая просто-напросто
хранит поле value, в котором хранится значение false, или я хочу написать
специализацию, которая хранит в статическом поле value значение true, в общем,
код можно упростить просто-напросто до вот такого, просто из конст унаследовать от
false type и из конст от const t унаследовать от true type, да, false type и true type
это такие специальные типы, которые внутри себя хранят поле value
со значения false или true, окей, ну просто вот эти вот самые определители типов
настолько часто используют, настолько часто пишутся, вот чтобы упростить
написание кода используются вот специальные типы, окей, хорошо, давайте приведем еще
пример, ну еще один пример, определитель типа это из pointer, ну опять же та же самая
задача, я хочу понять, является ли тип t указателем или нет, да, ну вот, мне есть тип t,
тут я выяснял, является ли тип т константы или нет, я сейчас хочу выяснить, является ли
тип t указателем, является ли тип t указателем, окей, ну опять же, да, я пишу общий
шаблон, общий шаблон из pointer, ну понятно, дел по умолчанию, произвольный тип указателем ни в
коем случае не является, поэтому я общий шаблон из pointer наследую от false type, ну и дальше я
прописываю следующий код, я говорю, что если у меня тип удовлетворяет вот такому шаблону, да, то есть
если мне передный тип может быть выражен вот в таком виде, то это означает, что это указатель я
должен вернуть, и значит, что у меня в статическом поле value должно храниться true, то есть я наследую
из pointer от true type, вот, а последние три специализации они сделаны вот про что, смотрите, вот для чего
представьте себе, представьте себе, что я в качестве шаблонного параметра, ну допустим вот из pointer,
да, из pointer, а передаю не просто указатель, а константный указатель, допустим int звездочка
const, вопрос, является ли это тип указателем или нет, ну константный указатель это указатель,
например, константный int это int, ну да, конечно, то есть константный указатель это естественный
указатель, потому что он куда-то указывает, но то, что его там изменить нельзя, ну ладно, это его
проблема, вот, а смотрите, а вот int за звездой const, равен ты со звездой, вот, давайте решим вот такую
загадку, что нужно подставить в качестве типа T, чтобы получилось равенство, ну кажется, что ничего,
согласны, ну что можно поставить в качестве типа T, ну если в качестве типа T подставлю int, то я
получу int за звездой, если я в качестве типа T подставлю const, то я получу constant за
звездой, ну я получу справа, что, указатель на константу, а следует стоять константный
указатель, ну я надеюсь мы ещё помним, что указатель, константный и константный указатель
это разные вещи, вот, поэтому, конечно, что бы я тут не поставил, всё равно получится указатель,
который не является константным, здесь указатель будет как ни крути не константным, а тут указатель
сам константный, вот, так вот, чтобы справиться с этой проблемой я прописываю ещё частительная
Я прописываю частичную специализацию в случае, если мне передали на вход константный указатель, дальше та же самая проблема может постигнуть волатайл указатель.
Консты волатайла обладают тем же самым проблемом.
Поэтому если в случае мне передали волатайл указатель, то я прописываю четвертый шаблон.
И наконец, если мне передали одновременно и консты волатайла указатель, я прописываю 5D шаблон.
Я учел вообще всевозможные случаи передачи указатель.
Какой бы мне указатель ни передали, неважно там константный, волатильный или константный волатильный, то все будет окей.
Понятно?
Ну в целом да, но этого к сожалению не избежать, потому что сложно написать общий тип.
Нет, точнее так. Смотрите, можно написать некоторый общий тип, можно было бы сократить.
Если бы при передаче в испойнтере я бы сначала приводил указатель конст волатайла,
только потом проверял подходит ли это указатель под конст волатайла.
Но кажется, что для понимания вашего проще написать вот так.
Нет, можно написать волатайл конст. Конст волатайл и волатайл конст абсолютно эквалентны.
Волатайл конст, ну в целом да. Волатайл и конст они в целом артагональны друг к другу.
Их можно писать в произвольном порядке.
Сейчас, можно было передать enable if, но тут на самом деле enable if ни при чем.
Нет, смотрите enable if он слушает для чего.
А сейчас, можно ли тут использовать enable if?
Можно ли тут использовать enable if?
Ну нет, смотрите, чтобы использовать enable if, там скорее всего тоже нет.
Чтобы использовать enable if вам нужно некоторое булевское выражение.
То есть вам нужно как бы для использования enable if вам нужно быть в этом положении.
То есть как бы для использования enable if вам нужно быть все равно какой-нибудь определитель типа.
А мы как бы это определитель типа пишем.
То есть как работает enable if?
enable if принимает в качестве первого шаблона параметра некоторое значение типа bool.
И дальше, ну собственно, тип, который я хочу подставить.
А как я получу это булевское выражение?
То есть как кажется, что в этом булевском выражении я должен понять, является ли тип каким.
То есть является ли тип указателем.
Я вроде как пишу уже определитель типа указатель.
Ну в общем, ладно, дойдем до enable if, обсудим.
Ну кажется, что тут enable if особо не применить.
Так, есть ли еще вопросы?
Окей.
Значит, еще один пример.
Ну абсолютно аналогичный с проверкой на то, является ли тип ссылкой.
Например, я хочу, допустим, проверить, является ли передный тип T
левой ссылкой, правой ссылкой, или вообще, в принципе, является он ссылкой или нет.
Ну вот, собственно, первые два пункта, это проверка на то, является ли тип L-value ссылкой.
То есть тип является L-value ссылкой, если он подходит под вот такой вот шаблон.
То есть в первом случае, в общем шаблоне, я возвращаю false.
Во втором, в частном случае, я возвращаю true.
Я проверяю, является ли тип R-value ссылкой вот таким вот образом.
То есть если тип удовлетворяется отношению T в двойном персент, то значит это R-value ссылка.
В первом случае, в общем случае, это false.
Так, вот.
В первом случае, в общем случае, это false.
Ну наконец, тип просто является ссылкой, если он либо L-value ссылкой, либо R-value ссылкой.
Вот тут я использую краски bool constant, вот этот тип bool constant,
в который я просто передаю требующее значение.
Да, и, соответственно, bool constant принимает значение true,
если тип является L-value reference, или он является R-value reference.
Не-не, смотрите, это работает по-другому.
Это работает по-другому.
Смотрите, давайте разберем.
Вот, что происходит, когда я передаю из R-value
референс от...
Ну, что? Интерперсант?
Ну да, давайте передадим интерперсант.
Что в этом случае произойдет?
Смотрите, тут важно понимать, важно понимать, что
в первую очередь, тип всегда сначала подставляется в общий шаблон.
То есть, сначала у меня подставляется в качестве...
Ну, сначала берется общий шаблон,
и в качестве типа T подставляется интерперсант.
Вот.
Дальше берется значение интерперсант,
и я его пробую подставить в частичную специализацию.
То есть, я проверяю, верно ли что интерперсант представим вот в таком виде.
То есть я проверяю, верный или что-нибудь имперсант представим вот в таком виде.
Верный или что-то имперсант представим вот в таком виде.
Почему? Как?
Ну нет, не совсем, потому что
нет не совсем так, потому что
здесь навешана одна ссылка
а здесь двойная ссылка. То есть смотрите, нет, смотрите, это не универсальная ссылка
это именно R-value ссылка.
Универсальная ссылка присутствует только в параметрах функций. Вот. То есть как бы
Вот тут я не могу подставить какой-то тип, который бы удовлетворял вот этому соотношению.
Поэтому тут эта частичная специализация не подойдет, и будет работать общая специализация,
которая скажет о том, что это на самом деле не R-value ссылка.
Ну и наконец еще один определитель типов, который на самом деле используется довольно часто.
Ну представьте себе следующую картину.
Вот у меня снова есть шаблон template класс T и класс U.
Вот, и функция принимает TX у Y.
И внутри этой функции я хочу проверить, верно ли, что тип T совпадает с типом U.
Могу я написать T равно равно U? Проверить ли это на равенство 2 типа?
Нет, операция равно равно к типам не применима.
Операция равно равно применима только к объектам.
Опять же, операции в обычной программировании я применяю к объектам. Я программирую объекты.
К типам я такие операции применять, к сожалению, не могу.
Но что я могу сделать для того, чтобы проверить одинаковые два типа или нет?
А я могу написать частичную специализацию.
Смотрите, я могу написать структуру isSame,
которая в общем случае говорит о том, что два типа T и U, естественно, не равны друг другу.
В общем случае isSame унаследован от false type.
А в частном случае, если isSame удовлетворяет,
точнее если передние параметры удовлетворяют вот такому соотношению T и T,
то есть если это два одинаковых типа,
то в этом случае isSame внутри себя будет хранить значение true.
Вот, я наследую в этом случае isSame от true type.
Ну и наконец такой небольшой бонус.
Смотрите, что если я хочу проверить равенство не от двух типов,
а равенство сразу многих типов?
Тогда я могу написать такой определитель areSame,
который будет использовать механизм вариативно-вариабельных шаблонов.
Я беру тип T, беру откусовую голову, беру все остальные типы, other.
И дальше говорю, что areSame унаследован от bool constant
с параметром b, который равен isSame от t other.
С параметром b, который равен isSame от t other и так далее.
То есть во что это раскрывается?
Что такое isSame от t other,
двоеточие, двоеточие value и амперсант, амперсант.
Помните этот синтактис?
Ну это выражение свертки, да?
То есть тут написано некоторый пакет параметров,
и я распаковываю его с помощью операции амперсант и амперсант.
Как это работает?
Это работает так, что берется is и other 1,
двоеточие, двоеточие value и isSame от t и other 2,
двоеточие, двоеточие value и так далее.
Да, тут просто раскрывается вот такое соотношение.
То есть я беру параметр t и проверяю его с каждым параметром из пакета other.
Понятно? Да.
Что сработает?
Короткая логика, короткая логика.
Кстати, сейчас, хороший вопрос, работает ли тут короткая логика.
Ну, кстати, нет, скорее всего нет, короткая логика не сработает.
Почему? Потому что, ну, понятное дело, чтобы раскрыть вот это вот два амперсанта,
ему нужно будет, так или иначе все типы проинстанцируются.
Вот, поэтому короткой логики тут не произойдет.
Так, есть ли тут вопрос?
Хорошо.
Так, ну, примеры применения.
Да, кстати, вот хороший слайд про примеры применения.
Смотрите, помните, когда мы говорили про вариативные шаблоны,
у нас там была функция суммы, и мы там столкнулись с проблемой,
в которой мы хотели написать функцию суммы, которая складывает несколько значений.
Но при этом мы не смогли никак, ну, допустим, вот, представьте,
я хочу написать шаблонную функцию сам,
которая умеет складывать только целые числа.
Но если я напишу вариабельный шаблон,
то тогда функция суммы сможет принимать вообще какие угодно параметры.
Я вообще никак не мог, по крайней мере, на тот момент,
проверить, что все типы действительно являются интами.
Вот вот как я могу это сделать.
Я могу написать template class int, то есть просто назвать пакет параметров int.
Понятно дело, что это никак не гарантирует то,
что в пакет параметров int будут переданы инты.
Понятно дело, что комплятору вообще плевать на то,
как я называю пакет, как я называю аргументы и так далее.
Но что я могу сделать? Я могу находиться внутри функции сам,
вызвать определитель типа isSame.
Ну, собственно, все те определители, которые я писал сейчас на слайдах,
все те же самые определители есть в стандартной библиотеке.
Ими можно активно пользоваться.
То есть я могу написать isSame v.
isSame v – это переменная, которая хранит тебе значение true или false,
в зависимости от того, совпадает тип или нет.
Я говорю, верно ли, что тип int совпадает с элементом пакета параметров int?
Ну, и распаковываю его с помощью операции i.
То есть я каждому типу из пакета параметров int сравниваю его с int.
Если все параметры совпадают с int, то есть если первый параметр – это int,
второй параметр – это int, третий параметр – это int,
то, соответственно, возвращается true, и статическая проверка проходит.
То есть проверка на этапе компиляции проходит успешно.
Если же хотя бы один из типов пакета параметров не равен int,
то тогда, понятно дело, тут какой-то isSame вернет false,
ну и, соответственно, общее буллевское выражение будет false.
Вот эта вот программа, точнее, вот эта вот функция,
она вызовет ошибку в компиляции.
Да.
Если у нас у isSameV явное преимущество над isSame,
или есть ли это частота, когда его иногда используют?
Нет, у isSameV есть преимущество, которое состоит в том,
что isSameV – это переменная, и у нее не нужно прописывать 2.2.value.
А как это вы делали?
Не делали два варианта, просто исторически так сложилось,
что в шаблонных переменах появились только все плюс 17.
Раньше не было шаблонов переменных,
поэтому нужно было постоянно прописывать это 2.2.value.
После того, как появились шаблоны переменных,
теперь можно использовать не класс, а можно использовать переменную,
которая делает, по сути, то же самое.
На самом деле то, что метафункции принимают тип, а не значение,
это как раз наследие старых стандартов,
потому что если функция может принимать тип,
то она также может принимать и константное выражение, то есть само значение.
В целом, да.
Второй пример, который показывает,
он показывает то, что, допустим, у меня есть какая-то функция,
которая работает с некоторой последовательностью значений.
Например, у меня есть функция, которая может принимать на вход массив,
причем массив произвольного типа.
Он может принимать либо вектор, либо указатель на выделенную память.
Понятное дело, что если я, допустим, передаю функцию вектор,
то вектор уничтожится автоматически.
Если же я передал просто обычный указатель на динамическую выделенную память,
то мне нужно для этого типа вызвать delete.
То есть как я могу проверить, нужно ли вызвать delete для этого массива или нет?
Я, собственно, могу просто написать определить типа std isPointer,
и если, действительно, в качестве storage или в качестве массива
мне передали просто обычный указатель,
то значит, указатель на динамически выделенные данные,
я, соответственно, могу вызвать delete.
Если же в качестве storage мне передали не указатель,
ну а, допустим, какой-нибудь вектор,
то есть вообще все что угодно, но не указатель,
то я delete не вызываю, пропускаю просто эту строчку.
Окей?
Хорошо.
Да, кстати, тут такой вопрос надо подумать.
Почему я в этой строчке написал вот так?
Так.
Delete квадратной скобки адрес.
Нет, ну, смотрите,
ну, посмотрите, почему бы мне не написать просто delete storage?
Ну, смотрите, я же вроде как в эфе проверил, что это указатель,
а если это указатель, то я могу по этому указателю вызвать delete.
В чем проблема?
Так, а если это не указатель, то что тогда?
Ну вот, смотрите,
если у меня storage является указателем,
то тогда я захожу внутрь delete,
и у меня может выполниться вот такой код.
А если у меня storage не является указателем,
то я внутрь этого ифа не зайду.
Вот.
Ну, тогда спрашивается, зачем я пишу вот так?
Зачем я себе усложняю жизнь?
Если storage это указатель,
то вот эта запись, это ровно то же самое, что и вот эта.
Но почему я предпочитаю вызвать вот это, а не вот это?
И вот тут есть один принципиальный момент.
Смотрите, на самом деле,
представьте себе следующую картину.
Представьте, что в качестве storage я передал вектор.
Так?
Если я в качестве storage передал вектор,
то компилятору, понятное дело,
нужно все равно скомпилировать все строчки.
Ему нужно проверить все строчки на корректность.
Понятно?
То есть, если бы я в качестве storage передал вектор,
то компилятор бы увидел, что я хулиган.
Он увидел бы, что я вызываю delete для вектора.
Можно ли вызывать delete для вектора?
Нет.
Delete можно вызывать только для указателя.
А если storage — это вектор, а не указатель,
строчка приведет к ошибке компиляции. Понятно?
Нет, смотрите какая история. Представьте себе, что вот тут в качестве шаблонного
параметра storage я подставляю вектор. То есть компилятор берет сюда, подставляет
вектор и начинает компилировать эту функцию. Предполагаю, что storage это вектор.
Да, и в любом случае, понятно, что компилятор не знает вот это из pointer
true или false, и он в любом случае зайдет вот в эту ветку if и
попытается скомпилировать эту строчку. Точнее, вот эту строчку, да?
Но вот эту строчку у него скомпилировать не получится, почему? Потому что delete нельзя вызвать для вектора.
Delete можно вызвать только для указателя. Поэтому, чтобы убедиться, что
справа delete всегда будет стоять указатель, я просто-апросто подстану вот так.
То есть я как бы обманываю компилятор. Что как бы, хей, смотри, тут на самом деле указатель.
И при этом я не говорю ему о том, что на самом деле ты строчки никогда в
жизни не найдешь, в случае вектора.
Да.
В целом, да, на самом деле мы по-нормальному решим этот вопрос, когда поговорим про if-const export.
На самом деле какие-то ветки можно компилировать, какие-то ветки можно не компилировать.
Но вот если мы используем обычный if, то такое, к сожалению, необходимо, к сожалению, прописывать.
Давайте продолжим обсуждение следующей проблемы. Смотрите.
Чего бы я хотел? Смотрите, вот код, который написан ниже, он говорит следующее.
Вот представь себе следующую картину, да, снова.
Я передаю массив, но я передаю динамический массив в функцию процесс индестрой.
Эта функция процесс индестрой, она каким-то образом обрабатывает этот самый динамический массив, да,
но и в конце его уничтожает. Смотрите.
Если в эту функцию я передам динамический массив в виде вектора, да, то понятно дело, что для вектора
автоматически вызовется деструктор, то есть мне не нужно об этом задумываться.
Если же в эту функцию я передам указатель на динамическую выделенную память, то мне необходимо будет вызвать дилит.
В связи с тем, что я говорил до этого, кажется, что логично написать вот такой код.
Смотрите, что я говорю. Если вот этот тип, если шаблонный параметр является указателем,
то значит для этой переменной, storage с маленькой буквы, необходимо вызвать дилит.
Если же storage не является указателем, то значит это вектор, но раз это вектор, то, соответственно,
для него дилит вызывать не нужно. Но в чем проблема?
Проблема в том, что если я попытаюсь скомпилировать вот этот код с параметром vector,
у меня пройдет ошибка компиляции. Еще раз, почему пройдет ошибка компиляции?
Потому что компилятор, когда представляет шаблонные параметры, он компилирует весь код целиком.
То есть даже если я нахожусь, то понятно, что компилятор должен скомпилировать вообще все возможные ветки.
То есть он компилирует if и он компилирует все, что находится внутри if.
Но если у меня в качестве storage, если у меня в качестве переменной storage выступает вектор,
то понятное дело, что для вектора дилит я вызвать никак не могу.
И вот в этот момент пройдет ошибка компиляции.
Понятно? То есть вот эта проверка происходит на этапе исполнения программы, а не этапе компиляции.
То есть компилятор не может понять, что на самом деле внутрь этой ветки if я никогда не зайду,
и поэтому эту ветку можно не компилировать.
С точки зрения стандарта компилятор обязан скомпинировать все возможные ветки исполнения.
Понятно?
Как решить эту проблему? И можно ли ее решить?
То есть, смотрите, очевидно, что вот это вот условие проверяемо на этапе компиляции. Согласны?
Ну то есть компилятор, вообще говоря, может понять, является ли этот тип указательным или нет на этапе компиляции.
То есть на этапе компиляции, то есть понятное дело, что на этапе компиляции происходит подстановка шаблонных параметров.
То есть на этапе компиляции компилятор понимает, что скажем, это вектор.
Раз он на этапе компиляции понимает, что это вектор, то он может шаблонные параметры подставить внутрь этого шаблона,
но внутри этого шаблона будет храниться соответствующее значение, true или false.
То есть понятное дело, что все эти операции компилятор может сделать на этапе компиляции.
Поэтому на этапе компиляции он может понять, что вот эта ветка, в принципе, будет бесполезна.
Да?
Как заставить компилятор отбрасывать некоторые ветки исполнения в зависимости от некоторых условий?
Давайте познакомимся с конструкцией, которая называется if constexpr.
Что такое if constexpr?
If constexpr, ну, собственно, тут мы описали проблему.
Так вот, чтобы решить эту проблему, необходимо написать if constexpr.
Вот тут, к сожалению, есть небольшая путаница.
То есть, на самом деле, if constexpr, на мой взгляд, не совсем удачное название.
Почему? Потому что кажется, что if constexpr проверяет, что правда ли,
что выражение, которое находится в скобках, является константным выражением.
На самом деле, не так.
На самом деле, if constexpr, это такой, 입ка, которая работает на этапе компиляции.
Смотрите, if constexpr обязательно должен принимать условия,
которые проверяемы на этапе компиляции, вот.
То есть, если обычное if проверяется на этапе исполнения программы,
то есть, когда программа уже завелась и работает, вот,
то if constexpr работает еще на этапе котлована,
на этапе запущенного программа.
То есть, программа компилируется, и компилятор проверяет вот это условие
на этапе компиляции.
условия истина, то он компилирует эту ветку. Если условие не истинно, то он просто на нее
полностью забивает. Понятно? Вот. То есть if-constexpr, на самом деле, скорее грамотнее будет
называть constexpr. if, да, то есть if, который работает на этапе компиляции. Вот. Ну, давайте посмотрим,
ну, собственно, как это решает проблему. Решает эту проблему следующим образом. Если мне в качестве
storage передали им-то указатель, ну нет, просто какой-то указатель, указатель динамическую выделенную
память. Тогда if-constexpr проверяет, верно ли, что это указатель, значит, компилятор понимает,
что да, это указатель, поэтому он оставляет эту ветку, точнее он оставляет этот код внутри
функции, да, то есть он оставляет код delete storage. Вот. Если же, если же в качестве storage я передам
вектор, то компилятор видит, что if-pointer от vector равно false, а значит, вот это if, проверка вот этого
if-a не проходит, а значит, вот эту ветку можно, в принципе, не компилировать, что компилятор и
делает, понятно? То есть if-constexpr позволяет либо включать какой-то код в зависимости
от некоторого условия, либо не включать код в зависимости от некоторого условия, понятно?
Окей! То есть я могу управлять кодой генерации с помощью constexpr, в зависимости от каких-то условий
я могу говорить, что вот это надо компилировать, или в зависимости от этого условия могу сказать,
что вот это компилировать мне нужно. Вот. Окей. Ну и смотрите,
как это может помочь нам на практике?
Например, это может нам помочь при работе с итераторами.
Например, когда вы говорили про итераторы,
я думаю, вы говорили про специальные функции,
которые имеют работу с итераторами.
Например, я хочу управлять итератором на n шагов вперед.
Понятно, что если это итератор random access, то я должен просто делать plus равно n.
Если это итератор просто forward итератор, то я должен n раз вызвать plus plus итератор.
Так вот, как функции наподобие advance или next
понимают, какие операции нужно выполнять.
В общем, это можно сделать так.
Допустим, я хочу по итератору получить элемент под номером n.
Что я сделаю? Во-первых, я извлекаю тег,
какой это итератор с помощью класса iterator.trade иterator.category.
Этот тег хранит для себя либо bidirectional итератор, либо random access итератор.
В контекст я проверяю, верно ли что мой тег, это random access,
corner mixes итератор. Если тег наследован от random access итератора,
Onu значит мой итератор является random access, а если
итератор является random access, то я соответственно могу сделать return итератор от n.
И при этом этот один итератор появляется только в
том случае, если итератор действительно является random access.
Если итератор не является random access, то этот итератор не будет
компилирован. То есть этот итератор просто libreствует компилятор и направляется на sixteen и ISC.
И также я могу написать ветку else.
Тут важно еще понимать, что если я для ifConstExport написал ветку else,
то ветка else тоже работает в constExport.
То есть ветка else тоже разрешает сетапь компиляции.
То есть если я написал ветку else, то она в зависимости от условий
либо компилируется, либо не компилируется.
То есть если на самом деле у меня итератор не удовлетворяет
условию random access, то я использую вот такой обычный цикл while.
Просто продвигаю вперед итератор на 1 шагу вперед
и возвращаю разуменованный итератор.
То есть в зависимости от того, является ли итератор random access или нет,
я использую либо операцию квадратной скобки.
Если же операция квадратной скобки не примема к итератору,
то я применяю обычное продвижение итератора с помощью plus-plus
и его разуменование.
Понятно?
Да.
Ага.
Нет, смотрите, у вас...
Цикл работает на этапе...
Цикл работает на этапе исполнения.
Если у вас внутри цикла написан if constexpr,
то есть цикл for какой-то,
и внутри for'ика у вас стоит if constexpr.
if constexpr.
Ну, смотрите, очевидно, что вот это условие
никак не может зависеть от итерации цикла for.
Потому что вот это условие
должно проявляться на этапе компиляции.
На этапе компиляции у меня, вообще говоря,
ну, я не могу там сказать, что там...
Что там предстоит переиром, ну, хотя...
Нет, не могу. Да, я не могу говорить,
что должно предстоить переиром на нулю и так далее.
Поэтому вот это if constexpr выполняется вообще
для всех итераций цикла.
Важно понимать, что вот это условие...
Я не могу сюда прописать условие,
которое будет зависеть от параметров цикла.
Потому что параметры цикла будут работать
только на этапе исполнения программы.
Так. Окей.
Поговорили про определители типов.
То есть мы поговорили про то, как
понимать, какими свойствами тип обладает,
какими свойствами тип не обладает,
проверять, допустим, является ли тип константой,
ссылкой и так далее.
И самое главное, как это можно применить на практике.
С помощью использования if constexpr
и в зависимости от каких-то условий.
То есть, допустим, если тип константный,
то я хочу, чтобы код содержал,
чтобы код работал одним образом.
Если тип не константный,
я хочу, чтобы код работал другим образом.
С помощью if constexpr я могу это организовать.
Теперь давайте поговорим про модификаторы типов.
То есть, что если я хочу
переданный в, не знаю,
допустим, шаблонную функцию параметр
как-то видоизменить?
Давайте про это...
Давайте про это поговорим.
Что такое модификатор типа?
Ну, модификатор типа, как я уже сказал,
позволяет изменить переданный навход тип.
Ну, например, представь тебе,
что мне передается навход некоторое...
Давайте вот конкретный пример.
CreateCopy.
Смотрите, у меня есть функция CreateCopy,
которая принимает на вход массив,
массив, т.е. рей,
размера n.
Что я делаю?
Я хочу создать массив той же длины
и скопировать все элементы массива r8
вот в новую созданную копию.
И вернуть саму копию. В чем проблема?
В чем проблема? Смотрите.
CreateCopy.
CreateCopy т.с.
а, ну, допустим, n.
Ну, и тут шаблонный параметр, класс.
Смотрите, в чем проблема?
Если я просто возьму
и напишу
autocopy
равно
nu t
от n,
то возникнет проблема следующего рода.
Когда я начну копировать все элементы
из a в копии, ну, допустим,
с помощью цикла, да,
pour int i равно 0,
i меньше чем n,
плюс-плюс i.
Вот, если я начну копировать и напишу вот так
copy от i равно i,
то возникнет следующая проблема.
Представьте себе, что в качестве шаблона параметра t
мне передали const.
Мне передали const int.
Ну, представьте, у меня есть, допустим,
есть массив constant,
и я этот массив constant передаю функцию
createCopy, и, соответственно,
в качестве шаблона параметра t, допустим,
вводится тип const int.
К чему это приведет?
Это приведет к тому, что, когда я попытаюсь
вызвать new от const int,
что в этом случае произойдет?
Ну, на самом деле произойдет ошибка компиляции,
да, почему?
Потому что константы я не могу создавать по умолчанию,
то есть я не могу создать массив
constant, не задавая им никаких начали значений.
То есть вот эта строчка даже не скомпилируется.
То есть написать new
const int
от n нельзя.
Вот. То есть возникает проблема,
да, проблема, которая состоит с чем?
Если в качестве параметра t мне передали
какой-то const int, я хочу, чтобы при создании массива
этот const исчез.
Понятно?
Ну, смотрите, вот если тип содержит константу,
то я хочу вот тут написать такой тип,
который константы не содержит.
Вопрос. Ну, вот смотрите, вот у вас есть тип t.
Вот. У вас есть тип t.
И вам известно, что
в нем содержится константа.
Как эту константу можно убрать,
ну, просто написав какой-нибудь обычный код?
Есть идеи?
Ну, кажется, что нет, да, потому что если const включен
в тип t, то он там содержит просто
обстановечно. Тип t он такой вот
в общем, такой
единый тип, неделимый, из которого
никак нельзя вытащить слово const.
Так вот, чтобы
исправить тип t, чтобы из типа t получить
некоторый другой тип, который конст не содержит,
можно воспользоваться модификатором типа.
И тоже на основе
частительной специализации.
Давайте посмотрим на пример сверху.
Что я делаю?
Ну, как обычно, я прописываю
общий шаблон, называю его
removeConst, который принимает
произвольный шаблонный параметр t. И что я делаю?
Смотрите, внутри этого шаблонного класса
я прописываю шаблонный
псевдоним type равно t.
Ну, помните, что такое шаблонный псевдоним using type
равно t. Ну, я просто нам
создаю псевдоним, который доступен
через имя этого класса.
То есть, я внутри removeConst
создаю новый тип, который называю type,
и этот тип полностью совпадает с t.
Что это означает? Это означает, что в общем случае
я предполагаю, что
на типе t нет
никакой константности. Если на типе t
нет никакой константности, то значит
снять константность типа t
то же самое, что и тип t.
А далее я прописываю специализацию
конкретно для случаев, когда тип удовлетворяет
соотношению const t. Вот если мне в removeConst
передали что-то похожее на const t,
то это означает, что в качестве
шаблонного псевдонима
внутри removeConst я прописываю using type равно t.
То есть, если мне передали нечто, что похоже
на const t, то тип, который хранится
внутри removeConst не должен содержать
этого самого конста. Понятно?
Да.
А почему это не отвечает
от работы const cast?
Потому что const cast
он... погодите.
const cast работает только с указателями
и ссылками. То есть const cast
может добавить конст либо указатель,
либо к ссылкам. К произвольным типам
с произвольным типом const cast не работает.
Ну и плюс,
какой const cast нужно написать тут,
чтобы это сработало?
Ну, непонятно.
Ну, короче,
const cast, чтобы сделать const cast
вам нужно явно указать тип, которым вы приводите.
А как сказать, что тип t
не должен содержать константу? Ну, кажется, никак.
Вот.
Ну и смотрите, как это работает. Теперь вместо того,
чтобы вызывать new от t,
вместо того, чтобы вызывать new от t,
я вызываю new от
removeConst от t.
Двоеточие, двоеточие type. Я пишу
removeConst от t, двоеточие, двоеточие type.
И таким образом что получается?
Если в removeConst мне подается на вход
const int. Что происходит?
Ну, removeConst понимает, что ему
был передан const int.
Дальше он видит, что под const int подходит частичная специализация
const t. Соответственно, в качестве параметра
t для частичной специализации выводится тип int.
И поэтому в
параметре
типе type содержится
значение int. И поэтому, когда я пишу
removeConst от t, двоеточие, двоеточие type,
вместо этого removeConst от const int
подставится int. И таким образом я создам
массив int, который можно изменять.
Понятно?
То есть таким образом вместо
removeConst от t, двоеточие, двоеточие type
подставится тип, который не содержит const.
Причем на этапе компиляции
я смог получить тип, который константности не содержит.
Это понятно?
Норм?
Окей.
Ну,
собственно, упростим код
ровно так же, как мы это делали в случае с
определителями типов. В определитель
типов мы использовали специальные типы
стд trueType,
стд falseType.
Здесь я предлагаю использовать
специальный тип typeIdentity, который просто
хранит внутри себя
параметры type
равный t. То есть я просто в typeIdentity
передаю какой-то тип t, и он хранит
внутри себя псевдоним, который точно совпадает
с шаблонным параметром.
Тогда я могу removeConst унаследовать typeIdentity от t.
Это будет означать, что removeConst будет содержать внутри себя
type со значением t.
И removeConst от constt унаследует
typeIdentity от t. Это будет означать, что в нём
будет содержаться псевдоним type,
который точно совпадает с типом t.
Ну, тип t, у которого я убрал слово const.
Так. Ещё примеры
модификаторов типов.
Вот, например, модификатор типа
removeReference. То есть, допустим, я хочу
снова. Кстати, вот снова та же самая проблема может быть.
Ну, кстати, ладно, тут
такой проблемы, наверное, быть особо не может,
потому что указателей
на ссылку не существует. Ну, в целом,
представьте себе, что я... Вот, представьте себе такую картину.
Представьте себе
вот такую историю.
Я хочу написать функцию
fill.
Я хочу написать функцию template
plus t,
которая возвращает...
Давайте, напишу тут auto,
и назову её
create
and fill.
И передам параметром tx.
Что будет делать эта функция?
Эта функция должна будет создать
массив... Эта функция должна будет
создать массив размера n,
то есть тут int n,
и заполнить его значениями типа x.
Окей? Ну, что я могу написать?
Я могу написать
auto
array равно
t от n.
Ну, и дальше заполнить этот массив значениями
типа... Точнее, значениями x.
В чём тут работа?
Если в качестве типа t
будет подставлена ссылка,
то есть если я в качестве шаблона параметра
передам ссылку, то что тут возникнет?
Тут возникнет массив ссылок, а массивы ссылок
запрещены.
То есть мне хочется сделать так, чтобы
вот тут оказался тип,
которым нет ни константности, нет ни ссылки.
То есть нам нужен модификатор
типа, который снимет
с параметра t все возможные
ссылки. Так вот,
для этого можно воспользоваться модификатором
типа removeReference.
Ну, как его можно реализовать? Очень просто.
В общем случае, removeReference от t, это просто
t. В общем случае, я предполагаю, что
на типе нет никакой ссылки.
Дальше я пишу специализацию
на случай, когда у меня написан t&,
то есть если тип подходит под определение,
что он совпадает с t и дальше
идет&, то соответственно в этом случае
я получаю просто тип без&.
На removeReference от t&
унаследован от typeIdentity от t.
Аналогично removeReference от t&
унаследован от typeIdentity
от t. То есть если у меня
в типе содержится&, то он должен быть снят.
Если у меня в типе содержится 2&,
то он тоже должен быть снят.
Соответственно, что я могу тут
сделать, я могу тут сделать
следующую. Я могу тут
написать
new
remove
reference
от
t
2.
type.
Вот.
И соответственно вот этот тип,
вместо этого типа подставится
тот же самый тип t, но без
ссылки или
либо без правой ссылки.
Окей?
Так.
Как раз осталось время.
Значит,
давайте поговорим,
в завершение поговорим вот о чем.
Давайте поговорим про
то, о чем мы с вами не говорили
в основной части курса.
Давайте поговорим про то, как реализованы
всем известные функции
stdmove и stdforward.
Вот смотрите, мы с вами на самом деле говорили про то, что
вот есть какая-то особая функция stdmove.
Ну, представь себе, у меня есть какой-то
x. Вот. И есть специальная особая
функция
stdmove от x.
stdmove от x.
А актор говорит о том, что
ну, x-у нужно притвориться временным,
и тогда, соответственно, если я вот это вот,
если результат этой функции буду использовать в каком-то контексте,
кто рождает временное значение,
то вот в этом самом контексте
и будет предполагаться временным.
Мы с вами говорили о том,
что делает move,
но при этом мы с вами не говорили о том,
как реализована stdmove. То есть как сделать так,
чтобы move делал именно то, что мы хотим.
Давайте об этом
поговорим. Ну, собственно,
stdmove выглядит примерно так.
Понятно дело, что stdmove — это шаблонная
функция.
Понятно дело, что stdmove — это шаблонная функция.
Вот. Она что-то возвращает.
Она называется move.
Она что-то принимает.
Какой-то x.
Вот.
И она что-то
возвращает.
Ну, давайте попробуем понять,
что нужно подставить на место пропусков,
чтобы stdmove работала именно так, как она работает
на этой библиотеке.
Ну, давайте начнем по порядку.
Давайте начнем
последовательно ответить на вопросы.
Что делает stdmove?
Вот stdmove что-то принимает,
и что stdmove делает с этим объектом?
Да, смотрите, stdmove делает
все, чтобы на выходе
оказалось rvalue.
Чтобы на выходе оказалось
по сути значение, которое
может быть проинтерпретировано как временное значение.
Окей.
Давайте тогда сразу ответим на
вопрос.
Какие там вопросы?
Что возвращает? Бла-бла. Да.
Давайте сразу ответим на вопрос,
что
что
принимает stdmove?
Нет, проще всего
будет ответить на вопрос, что возвращает stdmove.
Какой тип должен вернуть
stdmove? Вот смотрите, мне в stdmove
передали произвольный тип T.
Абсолютно произвольный.
Что мне нужно вернуть в качестве
результата?
Что еще раз?
Да, смотрите, мне нужно вернуть
тип. То есть, stdmove должен вернуть
некоторый тип, на котором навешано
2 амперсанта. Потому что 2 амперсанта
означает, что это
rvalue. Согласны?
Верно ли, что я должен
вернуть T
двойной амперсант?
Почему нет?
Да, и move-reference это верно.
Почему я не могу просто написать вот так?
Да, смотрите,
вот если мне в stdmove передали в качестве
T int амперсант,
то что тут произойдет?
Да, если я навешаю
2 амперсанта, получается амперсант. То есть,
move мне вернет lvalue ссылку. Понятно?
А я хочу, чтобы move всегда
возвращал rvalue.
Как сделать так, чтобы move всегда
возвращал rvalue вне зависимости
того, чем является тип T?
Что?
Так, как это
a?
Ну, нет, auto a2 амперсанта будет работать
так же.
Ну, хотя...
Да, это будет зависеть
от того, что я тут написал, но давайте...
Да.
Вот. Давайте еще тут авто напишем,
пусть компилятор сам разбирается,
как реализовывать.
Вообще можно было действительно
написать так.
Auto и return
stdmove.
Вот.
Так нет, мы же пишем свою версию
move, и мою версию move вызывает stdmove.
Вот.
Нет, статикас
мы не делаем.
Нет, мы его сделаем. Давайте вот какой
тип тут нужно писать? Смотрите, мне тут нужно
писать такой тип, который
с одной стороны бы являлся типом T,
но с другой стороны являлся бы типом T,
на который
обязательно навешано 2 амперсанта,
а не 1.
Вот.
Да, смотрите,
чтобы на тип, который находится
внутри T навесить 2 амперсанта,
мне нужно сначала с типа T снять все амперсанты,
1, 2,
а потом просто навесить 2 амперсанты, согласны?
Вот. Давайте я так и сделаю.
Давайте я напишу...
Давайте
тут напишу... Давайте я уже воспользуюсь
стандартным remove
референсом.
Remove
референс
T от
и по T.
Потом навешу 2 амперсанта
на это.
Move от
кто-то X.
Понятно?
То есть я говорю, возьми,
то есть remove референс, кстати,
remove референс суффиксом T, это по сути
псевдоним для... Давайте так вот.
std что-то что-то
2.2.type
это то же самое,
то std
что-то что-то, нижнее подчеркнение
T. Окей?
Просто псевдоним. Чтобы не писать
всегда 2.2.type, я могу написать
нижнее подчеркнение T.
Ну, это, собственно, шаблонный псевдоним.
То есть вот, я беру тип T и говорю,
давай снимем с него все ссылки,
там, 1 ссылку,
2 ссылки, а потом на то, что получилось, навесим
2 ссылки. Если я на нечто бессылочное
навешу 2 ссылки, то я получу тип с 2
ссылками. Согласны? То есть я получу R-value ссылку.
Ровно то, чего я хотел.
То есть stdmove в любом случае,
то есть stdmove в любом случае мне выдаст
ссылку на какой-то тип.
Двойную ссылку на какой-то тип. Понятно?
Теперь,
что еще, на что ответим? Давай теперь ответим
на этот вопрос.
О, а почему универсальную ссылку?
Ответ правильный. Давайте обоснования.
Почему универсальную ссылку?
Да, потому что в качестве
типа X,
потому что я хочу передать,
потому что stdmove должен работать именно
тем объектом, который я передал.
Ну а передать я могу как L-value, так и R-value.
Ну а универсальная ссылка,
это наиболее универсальный способ
принять параметры.
То есть если я передам L-value,
то X передастся по L-value ссылке,
то есть объект не будет скопирован.
Если я передам L-value ссылке, то объект не будет
тоже не скопирован, не перемещен, просто
будет сохранена ссылка на этот объект.
Поэтому я принимаю по универсальной ссылке.
И наконец, что я пишу в return?
Ну да, на самом деле,
смотрите, мне нужно
из X, который имеет вот такой тип,
получить X, который имеет вот такой тип.
Ну, тут
придется написать вот нечто подобие такого.
Кстати, cast
от, ну и дальше вот это вот
все,
std
remove
ref
variance t
от t
от X.
Кстати, cast это встроенная
операция приведения типа.
Я говорю, что X,
а, да, еще забыл два
персонала.
В стадии cast это встроенная
операция C++, которая
выполняет приведение типа.
И стадий cast может преобразовывать
один ссылочный тип
в другой ссылочный тип.
Все нормально.
Вот.
Как-то так.
Окей?
Вот, собственно, remove reference мне помог.
Remove reference мне помог
превентивно, точнее,
как-то директивно, точнее
навесить двойную ссылку
на нужный тип.
Вне зависимости от того, что было у типа t.
Если у него не было ссылок, то отлично.
Я просто на тип int навесил двойную ссылку.
Если типа t был int ссылкой,
то я одну ссылку убрал, получил int двойная ссылка.
Если был int двойная ссылка, то я
убрал двойную ссылку, навесил двойную ссылку,
получил двойную ссылку. То есть, в любом случае, я получаю
тип, на котором висит
только двойная ссылка, то есть
R-value. Вот. То есть, таким образом, move
в качестве
ответа всегда получает
R-value.
Вот, ну да. Мы про это говорили
все время, что говорим про move.
Move с объектом не делает вообще ничего.
Просто переводит один тип ссылки в другой тип ссылки.
Абсолютно.
Что R-value ссылка, что R-value ссылка,
это ссылка. А ссылки внутри устроены
как указатели.
Вот.
Ну и, собственно, вот решение.
На сегодня все.
В следующий раз
мы разобрали функцию move.
Еще одна интересная функция forward.
Функция forward — это такой условный move.
То есть, в зависимости от условия,
то есть, что было передано forward, он либо делает stmove,
либо не делает stmove. В общем, в следующий раз
посмотрим stforward, ну и еще кое-какие
фишки метапрограммирования. Вот.
Ну а на сегодня все. Всем спасибо.
