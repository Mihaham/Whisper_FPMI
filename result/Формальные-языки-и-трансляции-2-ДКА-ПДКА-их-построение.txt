Ну, кто помнит, на чем мы с вами в прошлый раз остановились?
Какую мы с вами теорему доказывали?
Да, мы начали доказывать с вами теорему, что для любого
недетерминированного автомата, существует недетерминированный автомат, в котором есть ровно один переход.
И давайте вспомним, какие у нас были действующие лица.
И что мы с вами доказывали.
В общем, давайте я выпишу.
Да, сегодня мы, видимо, будем писать слева направо или справа налево?
Давайте слева направо.
Итак, значит, мы с вами положили дельта штрих равно...
Что у нас получается?
Это напоминаю, у нас было стягивание переходов.
Дельта Q.
Кто помнит, что у нас?
Кажется, дельта Q1 эпсилон.
И был переход из Q3 по букве А в Q2.
То есть, у нас были переходы по эпсилонам, мы их протянули, добавили букву, переход по букве, пришли в Q2.
Дальше у нас F штрих.
Это были ребята следующие.
Это состояния такие, что дельта от Q...
Сейчас, секунду.
Это теку штриха такие, что...
Эпсилон принадлежали F.
А что еще?
Q0 вроде не поменялось у нас с вами.
Ой, не принадлежит F.
Sorry, туплю.
Не пересекались.
Потому что, смотрите, дельта Q3 эпсилон, это у нас было множество.
Напоминаю, это множество всех переходов, множество всех вершин достижимых из текущего состояния по эпсилонам.
И наша цель была доказать, что LATM, язык, задаваемый предыдущим автоматом, совпадает с языком, предыдущим, задаваемым новым автоматом.
Давайте вспоминать, какую сторону мы с вами доказали.
LATM вложено LATM штрих или LM штрих вложено в LATM?
LATM вложено LATM штрих, да?
Хорошо.
Ну, значит, теперь наша цель доказать это все в обратную сторону.
Отлично. Давайте докажем.
Пусть у нас слово лежит в языке, задаваемым M штрих.
Что это значит по факту?
Это означает, что существует такое Q штрих, которое доходит к завершающим состоянием F штрих.
Такое, что из конфигурации Q0 по слову W мы попадаем при помощи штопора в Q штрих эпсилон.
Да, какое-то количество шагов.
Давайте думать следующее, что у нас получается.
Давайте рассмотрим вот это свойство.
Что мы знаем для Q штрих?
Мы знаем, что дельта от Q штрих эпсилон, пересеченная с F, не пустое множество.
Давайте напишем это.
А что такое у нас дельта Q штрих эпсилон?
Множество вершин таких, что из Q штрих эпсилон мы можем в автомате M дойти до Q два штриха эпсилон.
А если эта история пересекается с множеством завершающих состояния по непустому множеству, это что значит?
Из этих двух фактов следует, что существует такое Q два штрих, находящиеся в множестве завершающих состояния нашего автомата, что Q штрих эпсилон
Q эпсилон выводится уже не в автомате M штрих, а в автомате N.
То есть мы построили с вами путь до конца.
А теперь давайте вспоминать, что мы знаем про автомат M штрих.
Какие переходы в нем имеют вид? Все переходы.
Однобуквенные.
Смотрите.
Тогда мы можем сказать, что наше слово W можем представить в виде слова W1Wk, где WIT принадлежит множеству сигма.
И тогда что мы с вами можем написать?
Мы можем раскрыть этот переход на K отдельных переходов, где каждый из этих K отдельных переходов по отдельной букве.
Потому что у нас все переходы однобуквенные.
То мы можем сказать, что существует Q1Qk.
Извините, об этом сете, о котором вы писали, из двух пунктов.
Оно разнесется только из второго.
Существует Q два штриха.
А, ну да, конечно, оно существует только из этого пункта.
Да, согласен.
Вот так.
Смотрите, теперь выписываем цепочку.
Которая у нас получается.
За один переход в автомате m штрих мы доходим до состояния Q1Wk.
А здесь что мы получаем?
Кукаты.
Кукаты.
Чему получается у нас равно?
Кто понимает по картинке?
Кштрих.
Кштрих, да.
Теперь давайте посмотрим определенный переход.
Ну, допустим, все эти переходы лежат в m штрих.
Причем переходы были за один раз.
Поэтому я сейчас буду писать снизу.
И мы вот такие цепочки нарисуем.
Однобуквенные.
Все ковидом заболели?
Дружненько.
Ну ладно, хорошо.
Так.
Ну давайте распишем первый переход.
Из этого следует, что на самом деле Q0W1Q2 принадлежит дельта штрих.
Да?
А это что значит?
Это существует такое.
Давайте обозначим его Q1.
Существует такое Q1 штрих.
Что?
Дельта от Q0 апсилу принадлежит Q.
Наоборот, Q1 принадлежит этому множеству.
Да, и...
Ой, Q1 штрих.
И дельта...
Сейчас, секунду.
Получается Q1 штрих.
W1.
Переходят в Q1.
А что из этих двух фактов у нас следует?
Давайте это в терминах дельта напишем.
Смотрите.
Это как мы распишем?
Давайте напишем следующее.
Вот у нас Q0.
WQ.
Если мы дошли с вами до Q1 штрих, не потеряв ничего,
то это что у нас получается?
Это у нас получается Q1 штрих.
W1 WQ.
И это путь в автомате M у нас.
Потом в автомате M за один шаг. Мы куда идем?
Исходя из этой.
Ага.
Q1.
Так.
А это что у нас такое?
По факту.
Индукция.
Но не индукция, но это ровно то же самое, что находится у нас здесь.
То есть посмотрите, наш путь в автомате M штрих
за один переход заменился на цепочку переходов в автомате M.
Да?
Потом, аналогично, повторяя все процедуры, мы можем сделать цепочку здесь.
Цепочку здесь, доходим до сюда, до Q штрих.
И как осталось нам до конца дойти?
Где место на доске?
У нас есть переход Q3.
Давайте я его обведу.
Вот, из вот этого перехода.
Получается, что у нас существует завершающее состояние Q2 штрих,
в котором из Q0 по автомате M мы можем дойти, имея все слово целиком, на входе.
Мы доходим до завершающего состояния Q2 штрих, на входе остается епсел.
Из этого мы можем сделать вывод.
Собственно, это и завершает наше доказательство.
То есть в прошлый раз, когда мы пытались собрать это все в цепочку,
это было сложнее, чем эту цепочку развернуть.
Потому что у нас определения были такие.
Так, понятно доказательство этой теоремы?
А что вообще означает за M штрих 1? Что значит еще один?
Где?
Переход за один шаг.
Переход за один шаг в автомате.
Вопросы, замечания, пожелания?
Вообще понятно, что произошло?
А может еще раз проговорить?
В общих чертах, что мы делаем?
Во-первых, нам надо дойти как-то до завершающего состояния в старом автомате, в F.
Ну как мы это делаем?
Мы понимаем, что мы дошли до завершающего состояния в новом автомате.
А как новый автомат построиться?
Это не что иное, что нам по епселонам позволяет дойти до завершающего состояния в предыдущем автомате.
Строим дорожку.
Эта дорожка такая.
А дальше мы понимаем, что у нас все переходы однобуквенные в автомате,
поэтому мы можем разобрать ровно каждый переход, в котором мы съедаем по одной букве.
И каждый переход по одной букве мы просто раскидываем на цепочку из вот таких действий,
которые по сути в обход нам дают цепочку перехода в старом автомате.
Все, замкнули истории, получили весь путь.
Ого!
Или все спят уже на второй неделе?
Ого, хорошо.
Так, ну тут есть краткое доказательство этого всего факта.
У нас неинтересно.
На самом деле, смотрите, что мы теперь можем сделать.
Я скипну.
Давайте поймем, как...
Ну, все-таки у нас курс немножко практический.
Давайте поймем, как мы будем хранить автоматы.
Ну, что вообще собой представляет автомат по факту?
Граф.
И он даже больше похож на взвешенный граф.
Да, только у нас переходы это будут...
То есть вместо весов этого графа у нас будут переходы по словам.
Вот.
Мы можем хранить nk списком переходов.
И мы можем даже сделать следующую вещь,
что nk с эпсилоном переходами хранить вот в таком, я не знаю, векторе векторов.
Точнее, не векторе векторов, а векторе чего?
Ну, если здесь символ, то можно векторе векторов.
Просто занумеровав все переходы по определенной букве.
Размерность алфавита у нас конечная, поэтому каждую букву мы можем занумеровать.
Да?
Вот.
И сразу скажу, что здесь будут храниться переходы...
То есть, говорим, работаем сразу с автоматами,
у которых длина переходов не более чем один.
То есть не более чем однобукленные переходы.
Вот.
Однобукленными переходами...
Ну, просто у нас эпсилон пропадает, и получается такая интересная картинка.
Вот.
Давайте поймем, как удалять эпсилон-переходы на практике.
Проводить так же, только алгоритмически оптимально.
Да, алгоритмически оптимально. Как алгоритмически оптимально?
Чтобы для каждой вершины найти...
А, ну, кстати, что это вообще будет значить?
У нас может быть линейный, при что я различный автомат,
у нас может быть линейный, при что я различный автомат,
у нас может быть линейный, при что я различный автомат,
у нас может быть линейный, при что я различный автомат.
Ну да, он скорее всего может так превратиться.
На самом деле, здесь алгоритм такой.
Мы будем строить с вами транзитивное замыкание графа по эпсилон-переходам.
Значит, что это такое?
Давайте для каждого состояния будем хранить следующий переход.
Следующее множество.
ΔК от Q эпсилон это то,
до куда мы можем дойти по эпсилон-переходам не более чем заказ шагов.
Ага, вопрос.
Контрольный.
Дельта ноль от Q эпсилон. Чему равняется?
Q.
А как посчитать ΔК плюс один Q эпсилон?
Хорошо.
Ну это объединение по...
Ну, как мы можем дойти до любого состояния за Q плюс один шаг?
Мы можем либо посмотреть, за что мы можем дойти за Q шагов,
и потом посмотреть, что мы будем делать за один переход.
Либо мы можем написать следующее.
Сейчас, дайте-ка подумать, как лучше записать.
Q штрих.
Получается Дельта Ката.
Вот так вот.
Ага.
Вопрос.
На знание языков все плюс-плюс.
Какая структура данных отлично подходит для того, чтобы решать эту задачу?
Конечно же.
Ну, потому что у нас по факту для каждого состояния есть битовая маска.
Ну, а по факту это свойство объединения битовых масок.
Ну, наверное, ICM-щики поймут, если вы умеете строить транзитивное замыкание за вот такую величину.
Там, по-моему, такое, да?
Я не помню.
ICM-щики что-нибудь пишут подобное?
Или нет уже?
Вот, у нас были...
А?
А, это количество вершин графии...
А, ну, это олимпионники, которые там, типа, быстро задачки пишут.
Давайте подумаем, до какого.
А?
Ну, может быть.
Ну, короче, порядка кубов все равно.
Я точно симптотику не помню в этом.
Но главное, что там константа 32 в знаменателе.
Да, она позволяет задачки запихнуть всякие разные.
Вот.
Давайте подумаем, какой максимально к нам надо?
Ну, модуль Q.
Я думаю, точно хватит.
Ну, потому что там, по принципу дирекле, мы дойдем все равно в какое-то состояние дважды.
Вот, и эту цепочку можно будет замкнуть.
Да, можно, да, отслеживать до сих пор, пока меняется состояние.
Но оно будет в мульку.
Смотрите, сложность каждого перехода будет O от модуль дельта действий.
То есть, можно эффективно реализовать эту штуку за O от модуль дельта действий.
От количества переходов.
Вот, потому что, видите, объединение этой штуки.
Вот, по дельту от Q эпсимум.
То есть, нам надо просмотреть все переходы.
Всего итерации O от модуль Q.
В итоге, симптотика получается O от модуль Q на модуль дельта.
Тут еще подсказали, что, возможно, еще Q в кубе где-то возникнет.
В общем, если мы предполагаем, что количество переходов в состоянии максимально,
ну, это порядка квадратов приблизительно,
вот, количество переходов приблизительно квадрата, количество стоян,
то мы получаем куб.
Да, привыкайте, здесь все причесания, приведения к нормальному виду,
работают за куб.
Да, тут быстрее никак.
Обычно.
Так, понятно, как можно построить дельта от Q эпсимум.
Ну, по факту мы строим так дельта от Q эпсимум.
Так, давайте к следующему алгоритму перейдем.
А теперь вопрос.
Как проверять принадлежность слова автоматному языку?
Ну, смотрите.
Во-первых, мы сделали все переходы однобуквенными в автомате.
Да, до этого.
И теперь мы можем с вами эффективно проходиться по множеству состояний.
Смотрите.
Алгоритм.
Первое.
Строим НК с однобуквенными переходами.
Это раз.
Два.
Для каждого слова на каждой итерации W равен W1 на НК.
Что мы делаем?
Мы по факту можем хранить множество дельта от Q0, W1 и WMT.
Да, то есть префиксы.
До куда мы дошли до префикса?
Давайте картинку нарисую.
Так, это дельта получается.
Как посчитать дельта от следующего?
Что сделать, если мы хотим добавить еще одну букву?
Ну да, то есть мы идем до N, а потом из каждой из них пытаться сделать переход по WMT плюс 1.
То есть опять же это будет двойная дельта.
Опять же, похожее объединение у нас с вами получится.
И что, какая симптотика будет в этой истории?
Ну не только.
Да, и в конце проверяем, что кукаты не пересекают со множеством завершающих состояний.
То есть дойти дошли мы или до конца, или да нет.
Окей.
Давайте подумаем тогда.
Временно каждый запрос будет такой.
Длина слова умножить на количество переходов плюс количество состояний.
Почему? Потому что на самом деле нам нужно в каждом переходе сделать объединение.
Ну давайте напишем сейчас.
То есть что такое дельта от Q0 в1 вM плюс 1?
Это по факту дельта от объединения, во-первых, в Паку.
В Паку, принадлежащем дельта от Q0 w1 wMt, дельта Q вM плюс 1.
Смотрите.
Дельта Q в М плюс 1.
Дельта Q в М плюс 1.
Дельта Q в М плюс 1.
Угу.
Смотрите, в чем особенность состоит.
Особенность состоит в том, мощность вот этого множества чего может достигать у нас.
Состояния, в которые мы перешли по букве.
Этих состояний у большой от модуль Q.
Переходов у от модуль дельта.
Слушайте, а может быть тут даже у большего симптома?
Давайте подумаем.
Может быть что?
Я говорю, может тут произведение модуль дельта на модуль Q?
Нет.
Да, я тоже думаю, что это как-то фигово.
Это иллюзия.
А на самом деле сумма дельта.
Да, а, тут амортизировано.
Мы же суммарно по всем переходам пройдем.
И на каждом переходе мы можем обновиться.
То есть сумма по дельту.
Максимально это будет от модуль дельта плюс модуль Q.
Да, согласен.
То есть, во-первых, нам надо перебрать все так или иначе вершины.
Все состояния.
А во-вторых, пройти по всем переходам возможным в нашем графе.
Возможно.
То есть, это от модуль дельта по ноль Q.
Ну и что думаете?
Это быстрый алгоритм?
Ну вот теперь представьте.
Вы пишете программу.
Там мы пишем с вами программу, какой-нибудь компилятор, да?
И мы такие.
Количество состояния в нашем автомате, я не знаю, сотня тысяч?
Ну, не сотни тысяч, там сотни, да?
Количество переходов там, не знаю, десятки тысяч.
А длина нашей программы, ну какая?
Ну, я не знаю, какая.
Ну, 100 килобайт.
Ну, 100 килобайт, да.
Хорошо, в библиотеку собираем.
100 килобайт.
Значит, получаем 10 в пятый, на 10 в четвертый.
Ну, и еще на какие-нибудь затраты, типа константы порядка сотни.
Вопрос.
Сколько у нас будет работать компиляция?
Ну, это зависит от того, как быстро изобретут более быстрый процесс.
Ну да.
Ну, в общем, это, как говорится, до фига.
Вот.
А вот тут вопрос.
Как вот одну?
А тематически вот эта вот плохая стратегия, как сравнивается с рекурсивным спуском?
Рекурсивный спуск – это немножко вообще про другое.
Потому что мы про рекурсивный спуск будем говорить в терминах грамматик.
Все-таки мы здесь автоматы.
Про автоматы говорим.
И здесь наша цель вообще состоит в том, чтобы, грубо говоря, у нас есть какой-то текст.
Да, длинный-длинный текст.
И его разобрать на наборы символов.
Ну, наборы токенов, то есть вычленито.
Вот.
Как это делается, кратце говоря.
Мы идем по входному тексту.
Закидываем наш входной текст в автомат.
Как только мы дошли до завершающего состояния.
Отсекаем токен.
Ну, в первом приближении это работает так.
Это не полный алгоритм.
Потому что там надо пройтись вперед, пройтись назад.
Там отсечь токен.
Вот.
Это совсем не то.
В общем, и потом мы наш текст нарезаем на токены.
То есть это там либо переменные, либо там, не знаю, точка запятой, скобочки и так далее.
Парсим вот эти все типы.
В общем, асимптотика достаточно большая.
Как вы думаете, за сколько хотелось бы это делать?
За длинный.
Да, за длинный слово хочется это делать.
Не домножая никакие асимптотики, связанные с автоматом.
Да, но тут доп. памяти еще указано.
В общем, мы поняли.
Во-первых, почему возникает неоднозначность?
Потому что на самом деле у нас неоднозначность поиска переходов по буквам.
Почему? Потому что у нас мощность множества дельта не равна единице.
То есть мы можем перейти по одной и той же букве в разные места.
Плюс нам надо хранить эту неоднозначность.
А как именно мы это можем сделать?
Вектор надо хранить.
А сколько в одном векторе у нас на один элемент хранится?
Отводится место?
В байтах.
Вектор НТОФ, если.
Я помню число, типа 12 байт в сумме на один элемент.
Но я могу ошибаться.
В смысле? Х3?
Ну ладно, ладно.
В общем, какой-то оверхед есть.
В общем, это бред.
Смотрите.
Для этого мы вводим следующее определение.
Вводим следующий термин.
Он называется детерминированный конечный автомат.
А детерминированный конечный автомат мы будем называть произвольным.
Нет, не произвольное НК, а НК определенного вида.
Давайте напишу.
D, K, A, N.
Такой, что для любого вектора у нас есть детерминированный конечный автомат.
Такой, что для любого кун.
Во-первых, меньше равно единице.
Во-вторых, для любого перехода он является однобуквенным.
То есть это автомат с однобуквенными переходами, в котором по любому состоянию, по любой букве, можем перейти не более чем в одно место.
Давайте подумаем, как улучшится алгоритм.
Алгоритм наш.
Как тогда наш алгоритм будет выглядеть при належности слова по детерминированному конечному автомату?
Смотрим, если есть переход по нашей букве, так идем по нему.
Ну да, если есть переход по букве, то идем. Если нет перехода по букве, ну извините, проиграли.
Смотрим, дошли мы до конца или нет.
Отличный алгоритм.
Но как вы думаете, есть ли здесь подвохи?
Как построить сегодня?
Первое, как построить детермины качественного автомата, во-вторых, какие затраты у нас будут.
Дополнительная память, которая у нас будет, это логариф мод количества состояний.
Но это зависит от того, в какой системе числения хранить. Я тут могу ошибаться.
Тут либо количество состояний в новом автомате, либо количество состояний в старом автомате.
Я спрашиваю, а что за фигня? На самом деле нам надо будет хранить индексы вершин в автомате.
А время этого автомата, построение этого автомата, ну как вам?
Отлично.
Ну многовато, да.
Давайте подумаем, почему это нам помогает? Почему мы забиваем на такую дополнительную сложность?
Смотрите, прикол.
Давайте вспоминать, что у нас в компиляторе происходит.
Ну в первой стадии компиляция.
При процессинге?
При процессинге.
Ну и вообще, когда мы строим какую-то структуру, сколько раз нам ее надо построить для компиляции?
Один раз.
Для любого языка программирования, которое мы с вами пишем, для любого парсера, для любого domain-specific language языка мы делаем один раз.
То есть автомат строится один раз и навека.
Ну до тех пор, пока вы не решите перекомпилировать свой язык программирования.
Вот, поэтому на такую вещь можно забить.
Я не помню, надо посмотреть, сколько в языках программирования количество состояний в детабилированном качественном автомате.
Я не думаю, что слишком уж много.
Ну да, конечно, там конечно не все так точно, ну типа не то как мы это математически смотрим, там на практике это все делается.
Плюс это еще делается каким-нибудь BFS.
То есть этот алгоритм на самом деле он BFS, в максимуме он 2 в степени ку, на самом деле он обычно занимает меньше сложности.
Вот, это значит то, что мы с вами должны были пройти в прошлый раз.
Теперь давайте я скачаю вторую презентацию.
Или мы допустим сейчас можем сделать перерыв, прежде чем мы будем с вами строить конечную DKA.
Давайте сделаем перерыв, потому что мы в следующей серии будем с вами говорить про то, как DKA построить.
Значит, наша цель сейчас понять откуда степень двойки возникает.
Здесь нам понадобится как раз наше множество дельта.
И цель, которую мы преследуем, ну по крайней мере во второй половине нашего занятия, если мы может еще успеем.
Нам надо доказать, что для любого недетерминированного конечного автомата существует аналогичный ему детерминированный конечный автомат.
Для любого NKN, давайте я обозначу опять же ку сигма дельта ку ноль f,
существует DKA м штрих такой, что l от m равняется l от m штрих.
Итак, смотрите, нам необходимо будет вести следующее определение.
Обозначение. Давайте обозначим дельта от s по слову w.
s это множество, если что, под множество q с звездой, под множество q.
Объединение. По всем q из s дельта от qv.
Логичное определение. То есть мы пытаемся не из определенной вершины перейти по букве по слову,
а из некоторого множества вершин перейти по букве.
И тогда смотрите, какой автомат мы будем с вами строить. Мы с вами будем строить автомат на множестве всех подножеств.
Два в степеннику. Альфавит, как вы думаете, поменяется, не поменяется?
Конечно, не поменяется. Так, дельта штрих подумаем.
Стартовое состояние, как вы думаете, какое будет?
Ну, стартовая единичка, все остальные нули, да. Или множество с ку-ноль.
И штрих. Давайте определять, что же такое дельта штрих будет.
Вот это? Мы раньше пытались проявить дельту с ку-ноль.
Вот это? Мы раньше пытались проявить дельту с ку-ноль.
Вот это? Мы раньше пытались пройти от перехода по букве...
Ой, от любого состояния по какому-то слову.
Теперь нам надо будет от множества перейти по какому-то слову.
Да, да, да... И сейчас будут картинки поясняющие, OK?
У меня на презентации просто подготовили на картинки для дельта.
Зачем это? Да, кстати, забыл сказать, что можно считать, что агрема там в основномутном переходе.
Ну, потому что мы уже научились в любом раз выводить свой разыказ в основномутном переходе.
Итак, давайте я пока собру.
И давайте подумать, и надо будет переходить с вами из множества по букве А.
Отъединение здесь по примерам.
Ну да, конечно. Из множества С по букве А, мы на самом деле будем переходить в это место.
А вы что, мне идею вообще даете?
А? Идея?
Идея такая, на самом деле, запустить ВФС в составном решении и просто собирать множество, которое мы переходим по каждому.
Чтобы при качестве состояния ходить под множество решений, в которых мы могли бы находиться на этом шаре.
Да.
Ну, а это...
Эшлиф, это будут такие С в состоянии...
На самом деле, с какого-то тракса вы еще встретитесь на курсе математической лынги, ой, на курсе творческих сленг.
Таким образом можно ввести язык МП.
Потому что, я не знаю, я бы не сказал, что МП на самом деле заключается в букве М.
Нет.
Ладно, хорошо. Это, в общем, на букве Н собирается слово недetermинирование.
В общем, которое можно, типа, по большему деревню ходить туда-обратно.
Ну, там, какая-то недetermинированность переходов.
Вот, а здесь мы пытаемся эту недetermинанность сложать в множество переходов, в которые мы можем пройти по каждому состоянию.
Где какого-то множества состояний.
И нам надо будет доказать, что L от N совпадает с L от N на 4.
Ну, давайте сделаем небольшой пауз.
Пауз в плане этого, а пауз в плане того, чтобы понять, что происходит с этой всей историей.
Смотрите, пример.
У нас с вами будут готовы замечательные автоматы.
Он у нас с одномокровными переходами.
Да?
Да?
Давайте посмотрим, как вы думаете, чему равняется будет проекта от Q1 по букве А.
Q1-Q2.
Q2, Q1-Q2.
Q1-Q2.
Дальше, как вы думаете, если это Q0-Q2A-B, куда мы переходим?
Q3-Q4.
Q3-Q4, да.
Ну, вот это получается 0-A-B, Q3-Q4.
А теперь смотрите, как мы будем строить этот доминированный, конечно, автомат.
В общем, мы начинаем с вершины Q0.
И идем по букве А сначала.
Смотрим, какие вершины мы с вами можем перейти.
Мы из вершины Q0 можем перейти A в Q1-Q2.
Поэтому мы создаем вершину, которая называется Q1-Q2.
Здесь Q1-Q2.
Мы делаем переход на Q1.
Потом смотрим, из вершины Q1-Q2 мы куда можем перейти?
Внутри.
А из вершины Q1-Q2?
Кучки.
Это значит, что мы говорим, что из состояния Q1-Q2 мы можем перейти в состояние Q3-Q4.
При этом, если у нас сегодня одно состояние в текущем состоянии было завершающее,
то есть идея такая, что мы смогли хоть одна вершина из этого логу спать оказалась завершающей.
Это значит, что идеологически из каждого состояния мы можем пройти по слову и по базе одной из этих завершающих состояний.
Ага?
Это идея того, как вся история строится.
А что такое F?
Ну, F- это все такие подмножества, которые пересекаются с F?
Да, это все такие подмножества, которые пересекаются с F в завершающем состоянии.
Вот как?
У нас же раньше F это было просто какое-то конкретное состояние.
F нет.
Это было какое-то множество состояний.
Просто мы не делали один осознание, которое говорит, что мощность Q1-Q2 можно брать на единицы.
Но если посмотреть автоматизацию на футболе, то не обязательно.
Я помню.
Кстати, вам надо по нашему футболу.
На этом примере идея понятна?
Что происходит?
Да.
Ага.
В общем, смотрите.
Мы с вами сейчас будем доказывать следующую рему.
Именно такой смысл.
Что?
Это вот.
Дельта 3.
Состояние футбола.
Вот.
Словом выиграешь.
Равняется.
Дельта.
Вот множество 0.
Словом выиграешь.
Давайте поймем, где такая конструкция.
Тут сложно.
Это дельта 3 как состояние автоматики.
А это дельта от чего?
От ножка состояния.
От ножка состояния автоматики.
Вот.
И поздравляю.
С вами второй раз.
В этот раз у нас новая модель.
В этот раз у нас нормальная.
В общем, давайте доказывать конструкцию индукции.
Словом выиграешь.
Так.
Дельта 2.
Словом выиграешь.
Словом выиграешь.
Словом выиграешь.
Угу.
А давайте подумаем.
Чему равняется дельта от 0 до B?
Словом выиграешь.
0.
Ну, это обвинение.
Выиграешь 0.
Словом выиграешь 0.
Дельта от 0 до B.
Ой, от 0.
То есть это у нас.
Сейчас.
Вот так.
Но при этом 0 у нас может быть только 0.
Поэтому это дельта от 0 до B.
А дельта от 0 до B.
Какого достоинства у нас вами?
0.
Да, это будет дальше 0.
Так как у нас все переходы на исходном автомате были от 0 до B.
А что же это какая-то дельта штриха?
Дельта перехода.
Куда мы можем перейти?
Ну, только в множество 0.
Потому что он одезерминированный.
Да, в нем нет перехода.
Поэтому это у нас получается.
Дельта от чего?
Просто здесь.
Ну, потому что туда мы перейдем.
Переход на автомате.
Кроме как то еще.
Кроме как то еще.
Хорошо.
Давай тогда переход.
Тут можно пройти двумя спусками.
Shirley's.
Torれて.
В tudpe, g.
sashay.
Провер параллельно в canceled period.
loose.
ubers who.
lazy.
IX, mm-hmm.
�락, mm-hmm, mm-hmm.
So, все.
В общем, 6 autistic.
Сziękuję.
С.
Давайте положим, что у нас есть слово W, это какое-то слово W шрифт на А.
Сейчас попробую.
Да, наверное так лучше сделать.
Сейчас посмотрим.
А, да, давайте смотреть.
Тогда давайте посмотрим, что же у нас такое.
Это тоже в них, вот, мы их убрали.
Куда может перелететь по слову W шрифта?
В нашем автомате.
Объединение по всем вершинам из дельта штрих от куной в штрих, дельта от куа.
Да, на самом деле это получается у нас по кул.
Так, секунду, что получается у нас?
Дельта штрих, вот, внимание.
Сейчас, секунду.
А, дельта штрих, это если что у нас множество, да?
Да.
То есть, смотрите, я утверждаю, что это дельта штрих.
Вот, получается чайку, вот дельта штрих от куной, рука.
Ваш штрих?
Думаю, ваш штрих.
Ваш штрих.
Почему это так?
Потому что что такое дельта штрих?
Ну, по факту.
Это множество состояний.
Сейчас, секунду.
Это множество состояний кул, из которых мы можем в...
Которые мы попали из кунуль два пр.
Так, давайте я напишу так.
Из множества куной.
Форма, слово это будет больше не х.
Ага, давайте вот так.
Вот так, множество С.
Мы переходим в конфигурацию состоящих множества С.
И у нас получилось вот так.
Да, все-таки это множество.
Да?
Но, поскольку у нас автомат утерминированный.
То это множество из чиноз состоит.
Сейчас, секунду.
Тут...
Ну, дельта штрих от куны С.
Он с такими...
Ну, сейчас я напишу.
Да-да-да.
Просто такие куклы можно опасть.
Да-да-да, сейчас я напишу.
Да-да-да, сейчас я напишу.
Я просто...
Давайте так лучше.
Если на это обозначим С.
Вот эта штука для С.
Ну, мы на самом деле попадаем вот так.
Да?
Так.
Отлично.
Ну, тогда смотрите.
Что мы можем сказать?
Мы можем сказать, что...
Поскольку у нас все переходы в этом слове однознательные.
В этом автомате.
Да?
Это что мы можем сказать?
Мы можем написать следующее.
Что...
За какое отстранительное состояние мы переходим в Т.
По уровню А.
За который уровень переход мы переходим из...
Вот этой штуки в СС.
На ста автомате.
Тогда что у нас получается, человек?
У нас получается, что...
Из...
Кунори.
Вот, словом мы пошли.
Мы переходим...
В этой очереди.
Ага.
А из этого что следует?
Чему сравняется у нас?
А?
Это что такое?
А Т, это...
Мы за какое количество переходов в автомате Р'
нашим новым
несловно думая по С' перешли до СС.
Да?
Посмотрим все переходы, правильно? Посмотрим.
Посмотрим какое это состояние от Т.
Да, штука такое в состоянии от Т.
Вот тогда у нас получается, что из Ку-муль
пошел вот в узольную штуку и переходим в Т.
А это что у нас такое работает?
С.
Вот.
Вот так?
Да.
Это сгорится, а в Ку-муль
не сгорится.
Да, первым у нас на самом деле отдаст
сразу дырка, штука, Ку-муль и выстрел.
Ага.
Чего?
Переход.
Переход, значит смотрите.
Мы хотим понять, почему вот это
можно написать таким образом.
Да?
Потому что это вообще символ из разного.
То есть почему мы можем этот переход
оставить пополам?
Давайте смотреть.
Как мы делаем?
Мы говорим, автоматия М4.
На самом деле, если на этом обозначен
за множество С, то у нас в нашем
депрессивном, конечно, автомате есть
переход, который находим у нас
с слова дубль-баш-трихана, а на конце есть
С.
Этот переход, этот автомат самодумный
переход.
Да?
Это значит существует момент за секунду
до этого, в котором вы не сверили
эту букву.
Фиксируем этот момент, зафиксируем
этот момент и обозначим вот
состояние С.
Это множество на самом деле.
Да и получается, что в этом множестве,
если мы убираем локу А справа,
то мы получаем дельта от
ку-муль дубль-баш-трихана, после перехода
в Т-эпсул.
А это раз дельта штиха от ку-муль
дубль-баш-трихана.
Вот.
Получается, что
последний переход это вот эта дельта.
Ага.
А теперь смотрите, что мы можем
сделать с этим выражением.
Мы знаем по предположению Дуктю,
что это штрих с В-штрихом
равно дельта с В-штрихом.
Так.
Это на самом деле дельта-штрих.
Вот.
Получается
дельта
от множества ку-муль
на слово дубль-баш-трих
и это по лукля.
То есть мы можем заменить дельту.
Осталось понять,
почему
мы вот эту дельту-штрих
можем заменить на дельту.
А?
В предположении Дуктю?
Нет, в предположении Дуктю уже работает.
Потому что переходы для буквы?
Потому что
вот это,
этот уже переход даже на автомате.
То есть смотрите, мы переходим
по одной букве в автомате,
меняя вот эту штуку
на дельту.
Да?
Поэтому мы вот этот переход
по одной букве можем заменить
с дельта-штрих на дельту.
Сейчас я поясню.
Сейчас я поясню.
Так, у нас получается,
смотрите,
просто если на выдох штука
раздача МЗТ,
получается,
у нас выводим впереди
Так, смотрите,
у нас получается,
есть переход
из буквы Т, из МЗТ,
по букве С,
ну, если мы используем дельту-штрих.
Дельта-штрих.
Ну, я напоминаю, что мы работаем
тех терминах. И получается,
получается,
что
из этого следует,
что С
на самом деле отмечено
как дельта-СА.
Ага.
Ну, это он
по дельте-дельту.
А это, поскольку
я там применю же дельту-штрих,
то это получается у нас,
что С
напоминается дельту-штрих
от входа ТА.
Только тут дельта-ТА у нас.
Ну, потому что
слово Т, а переход по букве А.
Ага.
Так, а вот это, что мы можем сделать
с вами, с этой штукой?
С двойной вентой.
Ну, это дейта от
Кун Ольгис по В-штриху.
Это по определению венты
нам стоит.
Опять, что мы можем расписать, существует
там промежуточная решина,
такая, что
ты получишь такой переход.
В общем, с вами
зафиксируется очень много таких переводов времени.
Но
вот, оказалось, что такое.
То есть, это он, когда... Посмотри.
Давайте еще раз идею. Мы раскрываем
все, кроме последней буфы,
а здесь
объясняем, почему переходы
интернеры, конечно, на автомате
нужно развить на наборы, развить
подможество, кроме перехода
в последний буф, раз.
Да? Вот эту штуку
заменяем только в положение индукции,
а последнюю штуку заменяем,
просто даться из перехода в автомате.
Перше?
Понятно?
Или все отрубились
и спать хотят?
На, слушай.
Ну, у нас получилась
дельта-штрих от дельты, да?
Мы хотим теперь эту штуку
заменить на дельту от дельты.
Как мы это делаем?
Почему так можем сделать?
Потому что, если разведем дельту от начания,
то у нас была вот эта штука,
это D,
есть переход по моду A.
Понимаем, что из D по A
мы переходим в мощность S.
Да? Вот.
Переходим в мощность S. Но с другой стороны,
по определению
состояния, как мы строили,
что же на самом деле S
должно быть дельта-штрих?
Это D по A,
ровно отсюда.
Вот, но с другой стороны,
это переход в автомате дельта-штрих,
поэтому дельта-штрих от A получаем.
То есть, получается,
дельта от A равно дельта-штрих от A.
У меня получается, что мы вот тут
дельта-штрих можем раскрыть.
Вот, а в конце потом мы сильнее
не дельта.
А может еще раз?
Вот это тоже?
Ну да.
Ну это мы просто расписали,
что такое дельта-штрих от D по A.
А.
А может уже
от D по A не получается,
просто вставление вместо S
по определению мощности с 0?
Нет, ну нет.
Вот над D же у вас там
определение или нет?
Это переход по B где?
Но не по слову.
А мы доказываем, что это для слова работает.
Так это лучше.
Так, давай, пройдем в минуту.
В общем, тут, опять же,
есть доказательства.
Будем почитать.
Ну, собственно, мы его пояснили.
Ну, то есть,
по автоматам уже.
Вот, теперь смотрите.
Давайте теперь перейдем
к доказательству теории.
А
для этого мне надо что-то стереть.
Ну, давайте, я думаю,
что это достаточно.
Нам надо доказать
следующей партии, понятно?
Итак, на третьем.
Если думать, что это язык
есть, ну давай ОМНР.
Чему это может быть
квалифицированным?
Этой квалифицированной
существует Q,
принадлежащую в прошлом завершенном состоянии.
Что?
Q принадлежит
на дельтр-кулоне по основному дебюржанту.
Ага.
А это разве теорема,
а не просто дебюржанная?
Не, на доказательстве теорема.
А.
Так.
Смотрите.
Это значит, что существует завершенном состоянии.
Такой, что Q принадлежит
дельтр-кулоне по основному дебюржанту.
Вопрос. А как это можно переписать?
Что дельтр-кулоне по основному дебюржанту.
Ну, мы это можем переписать
и квалифицировать образом.
Во-первых,
мы можем написать, что
дельтр-кулоне
Q, QB
пересечь дно, что завершает
в состоянии дебюржанта.
Да?
Угу.
Теперь, смотрите.
А
мы можем дальше
переписать.
Что это непонятно, потому что
дельты из множества кумоль
по слову DQB
пересечься от кумуста.
Да, потому что
эта штука это объединение
по всем множествам, которые лежат здесь.
А это кумоль.
Теперь, чем мы можем с вами
переписаться?
Демо.
Демо.
Демо.
Демо.
Дельт-каш-трика в кумоле D.
Да,
на доказательствах демо осталось.
Т.е. с демо не осталось недалеко.
Ага.
Знаете, что
дельт-каш-трика в кумоле D
принадлежит к кумоле D.
Да.
Это что к варианту?
Потому что D проглатывает с автоматом.
Да.
Я не знаю, когда.
Давайте вот все делать.
Все, показатель.
Т.е. идея
аккуратненько расписать индукции,
а дальше посмотреть,
делаться, грамотно сделать соответствия
между переходом к кумоле D
и переходом к кумоле D
с автоматом.
Что, как вам показатель в теореме?
Хорошо.
Нормально.
Ладно, не переживайте, для этого сама
можно начать лекцию.
Сейчас будет все проще.
Давайте вернемся к...
Так, вопрос
подоказывает в теореме.
Нет, быстрее.
Свидетель не сможет.
Почему такие простые
параметры в этом времени?
Ну, потому что он на то все формальных рисунков.
Да, на это все время можно и не жаловаться.
Что все это формально записать,
это будет быстрее.
Будешь какие-то
манипуляции произвести.
Итак, вернемся к сложности,
которые належат в новую языку,
т.е. первого конечного автомата.
Во-первых, у нас время по длине слова.
Дополнительная память. Давайте подумаем,
почему дополнительная память у нас проиграется.
Да, в бинбаске длины
в состоянии
мы находимся.
Здесь для состояния
нового автомата.
Да.
Да, просто нужно хранить
одежды к состоянию.
Время по строению автомата
это в баске, это не в модельку,
но для модельку это в старом автомате.
Да, немножко в баке.
Но в автомате это будет
длина у большой одежды в одну.
Надо бы поправить эти заказы.
У меня есть вопрос
к своей сложности,
которая раньше не была.
У меня есть вопрос о W,
если у нас
обращение
с фактически
динарной строкой длины
больше, чем машинное слово.
Если
аскут достаточно не бывает,
то само обращение
к массивам, в которых
лежат переходы, или какими
баскетчерами, которые лежат переходы,
не будет короче разуметься.
Ооо, это не из-за того,
да. Но люди просто
живут в памяти.
Они не нуждаются на их ощущения,
они живут в памяти.
Сейчас мы можем сказать от модуль В
на логариф модуль Q,
и все равно будет хорошо.
А будет логариф
нового Q.
Логариф нового Q
это старая ассутация.
Равно.
Дэйн Брэйн тоже не говорит,
что можно просто взять и по-любому
как собраться,
по-любому внутри W.
Сейчас нет, а почему логариф
это не правда, нет.
А логариф у нас размером старый.
То есть логариф новый.
Ну потому что беда в маске
надо хранить просто.
Это проблема, если
можно встроить такие такие
серии. Да, в общем
есть такие проблемы, да,
есть беда в маске.
Обычно, наверное, количество
состояний не 20 литров,
это он меньше,
его можно просто изменировать.
Там, грубо говоря,
вероятность того,
что мера того,
что мы то событие, которое
достигли, вот,
а константа в ротовстве панико,
она очень малая.
Это у нас не может быть. Да.
Товарищи,
значит, это еще не все.
Это не все виды автоматов,
а бывают автоматы
полные.
Они нам важны для чего?
Они нам важны для того, чтобы
мы всегда знали
по такой букве, куда мы идем.
То есть отличие определения полного
интерьерного коричневого автомата,
что это PDK, в котором знак
это PDK, в котором знак
не больше заменяется
на знак равно.
Но определение.
Ага.
То есть всегда
по любому автомату,
по любому состоянию,
по любому букве мы можем куда-то
перейти.
Есть у меня как что сделать?
Добавить как бы мусорную
состоянию?
Надо ввести все пусты?
Да. Вот смотрите,
вот идея такая.
Допустим, у нас есть переход по букве A,
нет перехода по букве B.
Когда мы заводим мусорную вершину,
делаем переход по букве B.
А в мусорной вершине какие переходы
будут? Себя сам себя.
Да-да. С звуком А.
Вот. Понятно, что можно
ополуммировать арены для любого PDK,
для того, чтобы полный PDK существует PDK,
доказательство будет
ровно вот такое.
Единственное, надо доказать, что
здесь уже надо опираться
на структуру теории графа,
то есть показать, что если вы зашли в стоковую вершину,
то вы из нее выпустите.
Вот. Это надо, например,
логически зарегистрировать.
Ну вот, давайте пример построим.
А, кстати, идея доказательства
понятна? Да.
Картинка в образе.
Берем правую
левую картинку,
а стоковую вершину,
я не знаю,
красный или зелёный.
Я просто не вижу.
А, я понял.
Надо будет всё по всеми целях делать.
Хорошо.
Хорошо.
Следующая теория,
которую мы сейчас хотим обсудить,
это теория,
которая доказательства не очень сложная.
Вот теория.
Это свойство автоматных языков.
Значит, смотрите,
автоматные языки
замкнуты относительно всех теоретических
множественных операций.
И замкнуты относительно операций клини.
То есть если у нас
язык L распознается автоматом,
то язык L со звездой
тоже распознается некоторым автоматом.
Давайте догадываем эти фазы.
И сразу скажу,
что у нас дальше
будут рассматриваться
автоматы с одним заключающим состоянием.
Вопрос. У нас есть два автомата.
Как построить автомат для саркетинации?
Соединим конечное
состояние одного с началом другого?
Соединим. Соединим конечное
состояние одного с началом другого.
Вот это. Надо на картинке
посмотреть.
Объединение.
Если у нас здесь
была последовательная соединение,
то вспоминаем, что у нас
в кроме курсвики какое соединение у нас получается?
Параллельное.
Правильно.
Ага.
Собственно, добавляем в это три года.
Единственное, что надо в конец
делать это же объединение, чтобы у нас автоматы
так же оставались одним завершающим состоянием.
Ой, чиху, мне кажется, у меня
не хватает.
А вот какой пункт называется, зачем мы
оставляем автоматы уже в состоянии?
А, чтобы потом не поролся
с этими проблемами.
Потому что когда мы будем замыкать
эту всю историю, там будут проблемы.
Ну, чтоб много переходов
не было.
Как звездочку сделать?
Из всех звезд.
Смотрите, предлагаю
историю такую.
То есть у нас
есть автомат.
Можно попробовать сделать
вот так. Можно.
Но это не сработает.
Это не сработает.
Нужно сделать начальное состояние принимающим,
а после...
Это не сработает,
это упражнение, подумайте, почему это не работает.
А работает такая картинка.
То есть нам надо сколько-то раз
провернуть наши слова.
Мы заходим в внутреннюю структуру,
заливаем счетчик,
считаем, сколько раз нам надо пройти,
выходим, заходим, выходим.
При этом завершающий состояние,
смотри, тут одно завершающее состояние,
это просто визуальный эффект.
Завершающее состояние это первое состояние.
Стартовое.
Угу.
Все.
Что дальше?
Что? Здесь?
Можете подсказать сейчас, пожалуйста,
что не так с тем,
даже если стартовое состояние делается...
Это упражнение.
Проблема будет с цифрами, на самом деле.
Если здесь цифра была,
то мы начнем с чем-то больше.
С чем-то много слов.
Да, да.
Просто чьи-то примеры.
Можно?
Ну, по факту, да.
Мы считаем, сколько раз мы
прошли через этот ассоциационный переход.
Сколько раз мы приедем
к нашему автоматику.
Столько раз мы проходим через этот автомат
целиком, и получается,
если мы прошли какой-то рассказ,
то мы распознали слово из языка
«эльфка».
Ну, вот.
То есть здесь есть язык.
Да, да.
Да, смотрите.
Есть доказательства
для математиков
перечечения.
Потому что перечечения принадлежат
через законный орган.
Есть математическое формальное доказательство.
И, я думаю, такое вы будете
строить на семинарах.
То есть у нас есть один автомат,
есть второй автомат, мы строим декарного
образования двух автоматов.
То есть, и повторяются переходы
по индексам. Смотрите, если у нас
из первого автомата во втором
был переход по первому состоянию,
а во втором — цикли,
то, видите, мы берем и переносимся по строкам.
То есть, смотрите, мы переносимся
из одного словца в другой,
но по строкам остаемся там.
Вот. Завершающий состояние —
это которое будет там и сам завершающим.
Хорошо.
Наполнение как строить, как вы думаете?
Построить полный автомат?
Построить полный автомат,
в котором мы уверены,
что по каждой букве
все сделаем, да?
И все завершающие состояния сделаем,
не завершающие,
и наоборот.
То есть, получается, смотрите,
агонка автомат. То есть, мы
пошли в каком-то состоянии,
дошли до конца
изначально в автомате,
а потом говорят, опа, а ты не пришел в конец.
Все, иди гуляй.
Не понятно.
Даже для этого нужно детерминировать.
Детерминированный, полный.
Детерминированный он всегда полный.
Полный он всегда детерминированный.
Да.
То есть, строим ПДК
и завершающий, не завершающий.
Вот.
И давайте
такую мотивацию закинем
на следующий раз.
Попрос, который
заключается в чем?
В чем проблема автоматики?
У них нет проблем.
Они прекрасны.
Он для какого
высока понятен больше?
На компьютере.
На компьютере, потому что
мы можем запродать прямо алгоритм.
Да, да, да.
Одным человеком более удобна
другая абстракция.
Какая? Регулярные языки.
Собственно,
регулярные выражения у нас есть.
Давайте напомним
о исполнении регулярных языков.
Вспомним семинар.
Тут ровно та же самая книжка,
которая была на семинарах.
Если у нас регулярное выражение
это ноль, то если
создаваем регулярное выражение,
это пустое слово.
Для единички
это слово из пустого символа.
О, пустое слово.
Дальше что? Я букву, это что
будет?
Множить из этого
этой буквы.
Дальше относительно каких операций
еще у нас есть регулярных языков?
Умножить плюс.
Умножить плюс и звездочка.
Плюс это огненение
умножить от этой патинации
буквы языков.
Итерация к линии
это такая что
при этом приоритет операции у нас
получается таким.
Попрос.
Последний.
Который хочется спросить.
Зачем мы доказывали сам что
это операция для автоматных языков?
Только что.
Он скажет что регулярная
качество
ноготение.
Да, что если у нас язык
регулярный и он создается каким-то
ноготением, то он является
автоматом. Для него можно построить
автомат.
А нам осталось доказать
базовый дух цифры.
Давайте отсюда. Как выглядит автомат
для нуля?
А если нам нужно оценивать
состояние?
Нет.
Помните мы доказывали
что замкнутость у нас должна быть
с одним завершающим состоянием.
Все как раз.
Как выглядит у нас две
единички?
Просто Q0 с завершающей и
больше Q0.
Как выглядит льда буквы?
Из Q0 ребров
по этой букве завершающие.
А дальше что нам остается
сказать?
Индукция в построении.
Индукция собственно пользуется фактом
западности автомата языка.
Все,
спасибо на этом.
