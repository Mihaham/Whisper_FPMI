Лекция 11 и наша тема динамические структуры данных.
Итак, мы с вами изучили довольно много структур данных, стандартных для DKS++.
У нас были совсем простые типы данных, такие как int, char.
Потом мы из них конструировали что-то сложное, например, строки мы могли конструировать из
char, мы могли конструировать из каких-то там int или double, например, массивы.
Потом гетерогенные типы данных, когда разные типы данных мы использовали для того,
чтобы конструировать структуру и потом можно же делать, например, массив структур, идти дальше.
И это то, чем то, что мы сейчас умеем уже. Но для решения некоторых задач массивы,
например, не всегда хороши. Какая главная проблема вообще у массива?
В чем особенность хранения массива в памяти? Они идут подряд, совершенно верно.
То, что мы здесь с вами размещаем все элементы массива подряд, с одной стороны,
дает нам громадное преимущество. Какое это преимущество?
Можно легко адресовать. Мы знаем начало, мы даем сдвиг и мы попадаем в нужную ячейку.
Это на самом деле преимущество. Мы за от 1 получаем с вами доступ к любому элементу.
Не во всех структурах данных доступ у вас будет за от 1, а в массиве,
потому что это просто формула, это от 1, следовательно, у вас доступ к любому элементу.
За это приходится платить всегда, когда что-то просто другое сложно.
То здесь в массиве делать сложно, как вы думаете. Вот если у меня есть хороший,
милый такой массив из интов, два, три, два, три оценки за сессию студента какого-то.
И вот в этом массиве мне захотелось ставить что-то в середину, например, этого массива.
Я хочу добавить, я пропустил, когда записывал, у него еще одна пятерка была, оказывается.
И хочу вставить в хронологическом порядке, не в конец именно, чтобы как он сдавал,
вот неправильно заполнил. Я хочу в хронологическом порядке его сессию вставить,
чтобы правильно записать. Мне надо вставить элемент массива. Что значит вставить?
Я не могу сейчас разрывать. У меня самое главное свойство массива, что все элементы хранятся подряд.
Из этого следует, что мне придется 2, 3 сохранить, потом написать вот эту пятерку,
а все вот этот весь хвост просто сдвинуть. Записать там его 2, 3, 4, 2. Но мы предполагаем,
что здесь были какие-то свободные ячейки, например, записанные нулями. Тогда это корректно делать.
И за сколько работает такая операция вставки у нас в массив? За от n, потому что мне приходится
двигать весь массив. Также удаление. Если потом я понял, что я вставил ошибся,
это было не его пятерка, и мне надо удалить назад. Но все, что я должен делать, это опять же брать
этот хвост и сдвигать, чтобы у меня не было пропусков. Потому что в этой структуре данных
не может быть пропуски. Они подряд располагаются, следовательно, не может быть никаких у вас
несуществующих ячейк. Иначе, если вы даже на какую-то сделаете хитрую структуру,
пометьте эту ячейку как свободную, как вы будете перемещаться правильно,
вот так адресовать, как в начале. И операция вставки удаления из массива, соответственно,
сработает за от n. И это и есть проблема наша в массиве. Есть другая структура данных,
которую мы начнем с вами изучать. Список. Мы будем ее рассмотреть как динамическую,
потому что она в начале не существует. Потом вы создаете один элемент, потом два, потом три и так
далее, сколько вам надо. То есть она изменяет свои параметры, то есть количество элементов,
другие параметры изменяет в процессе работы программы. Поэтому данная структура данных
у нас будет называться динамической структурой данных. Что же такое список? Давайте вот посмотрим.
Вот у нас есть какой-то элемент этого списка. Если там у нас элемент списка, элемент массива,
хранил только значение 2, 3, 2, то здесь придется чуть сложнее. Мы тоже будем эту двойку хранить
в этом списке, мы тоже можем хранить значения какие-то. Но поскольку они у нас будут в памяти
располагаться не подряд, нам нельзя с вами хранить только значение. Нам придется с вами хранить
некий указатель на следующий элемент этого списка, потому что мы их в памяти располагаем не подряд.
Ну таким образом вот это 2, там что у нас было? 2, 3, 2, 3, 2, 3, 2, но это точно не студент физтеха,
поэтому это просто гипотетический пример. В студенте хиждестибальная система,
двойку получить здесь невозможно практически. По теории вероятности, да? Должно же быть
нормальное распределение, поэтому R5, 6, где-то все время вы получаете 2. Итак, и вот этот список,
и вот этот список, когда последний у нас элемент, мы здесь ставим нулевой указатель, то есть ноль
можем просто записать, что с последнего элемента, вот так храним в памяти. Таким образом, это структура,
в которой у нас будет одно поле, какие-то данные, другое поле указатель, указатель на какой тип,
на вот эту же структуру. Сейчас мы это напишем, но пока концептуально поймем. И
бывают списки у нас односвязные, бывают списки двухсвязные. Это значит, что у нас хранится
указатель не только на следующий, но и на предыдущий. То есть вот у нас вот так будет
идти указатель, и у первого будет ноль, потому что предыдущего в него нет. В односвязанных
списках мы с вами перемещаемся только в одном направлении, в двухсвязанном можем в двух
направлениях, поэтому называется двухсвязный. Как правило, для того, чтобы нам с вами с этим
списком правильно работать, нам как минимум нужно иметь один указатель на него, потому что он
хранится где-то в динамической памяти, и если ничто из ни стека, ни статической памяти не указывает
на этот, вы не согласны с чем-то? Все, хорошо. Ничто не указывает на этот список, то непонятно,
как к нему начать с ним работать, поэтому у нас всегда будет указатель на первый элемент. Но,
как правило, если это двухсвязанный список, чтобы воспользоваться его преимуществами,
то можно ходить и в другую сторону, мы будем делать с вами и указатель на последний элемент.
Теперь давайте, пока мы с вами не начали писать код, который я сегодня как раз буду писать с
помощью указателей, чтобы получше с этой темой потренироваться, подумаем, а что в этой структуре
со сложностью? То, что мы обсуждали на массивах с вами. За сколько происходит поиск элемента? То
есть здесь я просто, если хотел до какого-то элемента дойти, я прибавлял, здесь мне нельзя
прибавить. Вот список, вот так у меня красивый нарисован в памяти, это может быть вот так. Вот
здесь у вас первый, здесь второй, здесь третий, здесь четвертый, здесь пятый, здесь там шестой и
так далее. Поэтому вы не можете прибавлять, вам придется идти по этой цепочке. Если вы идете по
этой цепочке, то какая сложность у нас будет поиск элемента в списке? ОАТН совершенно верно,
после контрольной все помнили. А дальше у нас с вами удаление и ставка, сравним. Если там мне
надо было что-то сдвигать, то надо ли мне здесь весь этот список сдвигать влево или вправо? Нет,
потому что я просто, если хочу добавить эту пятерку, что я буду делать? Я вот эту ноду сделаю
где-то там, а потом просто поменяю указатели. Этот сюда, этот сюда и так далее. То есть,
я грамотно поменяв указатели, некоторые изменю, и у меня эта нода хорошо вставится,
потому что если вот мы хотим вот здесь разорвать, вот между этими вставить, мы просто эту связь с
вами разорвем, какой-то сделаем элемент, и вот у нас получится новый элемент, который вставился в
память, и совершенно неважно, потому что где они лежат и что было. Кроме того, иногда это полезно
в некоторых, например, алгоритмах, когда требуется что-то сделать, и прежде чем я скажу что сделать,
я хотел вас как раз спросить ту же тому штуку про сортировки, про квадратичные сортировки. Какие
квадратичные сортировки вы знаете? Пузырек, ставками, выбора. За сколько работает каждая из них?
Н квадрат. Замечательно. А теперь, какая сортировка особенная? Что она умеет делать,
то что никакая другая не умеет? Вот этих трех, что вы назвали? У вас есть ставками, есть пузырек,
есть выбором. Какой у вас ответ? Почему ставками? Не совсем. Давайте так, уточню вопрос,
чтобы было понятно в каком направлении думать. Мы говорим о сложности алгоритмов, и вот с точки
зрения сложности чего-то одна из этих сортировок намного лучше, чем все остальные. Мало того,
она еще и лучше, чем даже быстрая сортировка или другие сортировки, которые вы будете,
ни другая ни одна сортировка это делать не умеет. Да, нет же, не пузырек. Пузырек у Бог во всем,
и в этом тоже. Поэтому, поскольку мы перечисли уже медного исключения, мы назвали ставками,
назвали пузырек, остался выбором. Давайте теперь просто кто-то из вас додумается,
скажет в чем выбора такая особенная, в чем ее такая крутизна. Не совсем, да.
Ну это для всех тоже, пузырек тоже, если он частично у вас или полностью сортирован,
одна итерация и все закончилось. Да, уникально, она дает минимум максимум и.
Хорошо, да. Ну ладно, на десятку вы бы не сдали экзамен, но я расскажу. Смотрите,
представьте себе, вот вы, вас как зовут? Леонид. Ну вот представьте себе, в другой
жизни где-то там Леонид не на фистехе учится, а работает на пристани крановщиком, разгружает
контейнеры с китайскими товарами, которые привозит в Долгопрудный по Москве реке на речном
вокзале. Итак, представьте себе, что это пристань, это кран, сейчас у меня будет художественное
тут просто рисование, вот кран, вот у него что-то свисает, вот это Леоня, вот сидит вот там наверху
высоко, глядит, все видит и здесь вот такие контейнеры. Вот контейнеры, такая жизненная задача,
их нагрузили ему на пристань вот в таком порядке, привозили и как-то сгружали, а завтра утром у него
приезжают грузовики, вот здесь такие грузовики, они будут подъезжать и забирать вот эти контейнеры.
Ему надо за ночь отсортировать контейнеры, чтобы грузовик, который в девять приезжает,
забрал первый контейнер, а потому что второй он не проедет к нему, не заберет. Ему нужно вот
этим краном пересортировать эти контейнеры между собой. Если Леоня будет делать пузырьком,
у него будет очень хорошее развлечение, он будет их постоянно менять между собой,
ведь операция смены контейнеров это поднять, куда-то в промежуточную переменную опустить,
потом поднять другой, он за ночь не успеет, потому что у сортировки пузырьком количество обменов
квадратично, как и у сортировки вставками. Сортировка выбором единственная сортировка,
которая линейная относительно количества обменов. Почему? Потому что умный Леоня,
который фистек закончил, он что сделает? Он спустится по этой лестнице и сначала пройдет и
выберет этот максимум или минимум, то есть тот, кто должен стоять на этом месте и один раз его
поставить на свое место. То есть сортировка выбором у вас единственная, которая не делает лишние
обмены, потому что когда обмена ничего не значит, когда вы инты меняете, это неважно,
но когда обмена это два контейнера или вы там сортируете, не знаю, какие-то огромные массивы
информации, то у вас выходит не только на первый взгляд необходимость считать количество
итераций именно сравнение, но вам надо посчитать количество обменов. И здесь количество обменов
линейно, потому что вы выбираете вот, например, контейнер максимальный и ставите вот сюда,
меняете их и вот этот, который у нас максимальный, больше никогда не будет тронут. Все, теперь из
остальных он выбирает максимум, допустим этот меняет их, и вот у вас там таким образом
происходит расстановка, у вас будет количество обменов, это n-1, потому что последний встанет на
свое место. И это максимально, и это как бы прелесть этой сортировки, вот как раз когда у нас указатели,
нам даже менять не надо, мы просто вот эти указатели подвесили в списке, это тоже, например,
когда список удобен, потому что вам не надо перезаписывать, вы можете просто менять указатель,
еще один для чего могут применяться списки. Теперь давайте перейдем к написанию того самого
страшного кода, который я вам анонсировал, для того чтобы мы посмотрели с вами как выглядит
реализация списков, и на ней как раз на этой реализации мы с вами потренируемся в работе
с указателями. Сама нода, как ее называют, или элемент списка, это некая структура, узел,
по-русски, которая состоит из следующих полей. Здесь какое-то поле данных, назовем вот это слово
date, которое будет иметь тип int, например, потому что это наш пример, у нас здесь вот эти оценки
но вы можете хранить все что угодно, другую структуру, другие типы данных, и у нас есть два указателя,
указатель на следующий, на предыдущий элемент. Когда мы с вами изучали структуру, мы говорили,
что структура может содержать указатель на этот тип структуры, который мы объявляем,
это было у нас на лекции про структуры, и это как раз сделано для того, чтобы вы могли объявлять
списки, иначе вы не сможете их сделать, потому что вы сейчас объявляете эту ноду и надо указывать
в самой ноде на эту ноду. Такая вот у нас замечательная рекурсивная штука. Итак, указатель
на следующий элемент назовем next, это указатель на ноду, которую мы объявляем, и указатель на
предыдущий элемент мы с вами назовем prev. Вот наше объявление, которое мы начнем с него работать.
Теперь давайте писать функцию main, где мы объявим следующие вещи. Нам потребуется указатель на
начало, его мы с вами назовем указатель начала, pointer, begin, указатель на начало. Тип у него будет
тоже. Это указатель на что? Он указывает на вот эту ноду, вот это тип, это есть нода. Значит,
нод, звездочка, побег. Побег это указатель на ноду. И теперь мы сделаем некую функцию,
которая нам инициализирует первый элемент этой ноды. Я вот здесь сейчас отрую, начну дописать эти
функции, потому что там у меня main, вам надо отступить еще, наверное, строчек 6 у нас будет в
main, а ниже будем писать функции, которые будет этот main вызывать. Итак, давайте напишем функцию first,
которая нам заводит первый элемент. Итак, функция first, она возвращает, как мы видим вот из этого
присваивания, указатель на ноду. Ну так ее и объявим. First это у нас указатель на нашу ноду.
Принимает она данные, которые надо положить в данный узел, списка, и это наш ind. Ну что и
сделать? Она объявит какой-то в нашей функции, мы объявим какой-то временный указатель,
который сейчас у нас будет храниться в стейке в этой функции, удалится, когда мы закончим с ней
работать. Итак, у нас есть некий pv, это указатель на ноду, которая сейчас у нас в динамической
памяти заведена, это stack, это динамическая память, и пока в ней ничего нет, пока мы просто завели,
теперь давайте заполнять ее смыслом. Как обращение у нас будет идти через указатель? pv это указатель,
нам надо разаменовать указатель и обратиться к элементу структуры. Разаменование указателя
это звездочка, обратиться к элементу структуры это точка. Эта операция c++, которая была очень
часто заменили, ну не заменили, а сделали альтернативную, которая более простая стрелочка,
поэтому мы будем писать сразу стрелочку. pv стрелочка d равно d, то есть вот это первое поле,
которое мне называется d, я кладу сюда то, что мне передали функцию. Чем меня инициализируют,
например здесь единицей, давайте чтобы было похоже на нас, двойкой инициализируемся. Мы
инициализируемся двойкой и вот сюда эту двоечку кладем. Еще нам надо что-то записать в следующий и
предыдущий, но поскольку она самая первая, у нее нет ни следующего, ни предыдущего,
поэтому это просто нули. Давайте тоже это сделаем. pv next равно нулю, pv prev равно нулю. Вот мы с вами
закончили функцию, которая в конце должна вернуть то, что она создала вот этот элемент
списка в динамической памяти. Мы возвращаем указатель на него, вот звездочка, которую мы
возвращаем, и этот указатель у нас присвоится указателю на начало списка. Таким образом,
в текущий момент у нас только вот это создано. Есть начало списка, есть один элемент списка,
который у нас в памяти. Вот этот кусок правее, ничего сейчас нет. Давайте теперь создадим еще
в мейне одну переменную, которая будет держать конец списка. p end. Конец списка. Пока я затру
все, чтобы ничего нас не отвлекало, и здесь у нас рисовалось именно то, что у нас в данный
момент в памяти. Вам так будет проще понимать. Вот у нас сейчас 2, 0, 0. Это то, что у нас сейчас
записано. И конец списка, наверное, логично, если у меня список из одного элемента, то его конец
совпадает с началом. Поэтому я просто присваиваю сюда указатель на начало, а не равный. Это
начальная инициализация конца списка. Теперь давайте докидывать
элементы и давайте вставим в конец нашего списка несколько элементов. Сюда сейчас я буду писать,
Леню придется нам стереть. Он уволился оттуда. Значит, функция, которую мы сейчас напишем,
это продолжение мейна, будет называться add. И мы будем добавлять с вами конец списка. Для
чего мы будем сейчас передавать адрес конца? Это операция. Взятия адреса конца списка и то,
что хотим добавить. Какая у нас была оценка после двойки? Пункт тройка. А потом была после тройки
снова двойка. Это нормальная ситуация. Два, он напрягся, получил тройку, расслабился,
получил двойку и так далее. Все логично объяснимо. Да, сейчас поймем. Это не ошибка,
это так задумано. Ну и несколько можем дальше добавлять. Самая суть, давайте напишем эту
функцию add. Я сотру first, чтобы нам было где писать. Все успели вот эту часть переписать? First все
переписали. На ее месте сейчас будем писать add. Итак, когда мы с вами добавляем в конец списка,
у нас что-то меняется. А именно, если мы добавляем конец, понятно, что у нас вот эта переменная
paint. Но тоже, если мы сейчас сюда второй элемент добавим, тоже у нас должна сдвинуться. Где-то нам
надо менять указатель. Как менять указатель? Ну, передав его можно, например, по указателю,
по адресу. Чтобы передать указатель по адресу, нам понадобится указатель, который на него указывает.
Правильно? То есть, у нас будет указатель, который по адресу передал получил этот, и мы
тем самым получаем с вами двойной указатель. Именно это у нас и будет сейчас функцией нашей add. Итак,
вот у нас функция add. Она ничего не возвращает, она просто добавляет элемент в конец списка,
но она принимает двойной указатель, который, допустим, назвали мы P. И кроме этого,
она принимает, кто я добавлю. Так что такое P у меня? Вот у меня P. P – это переменная,
которая живет на стеке. Впрочем, PN тоже живет на стеке. Но P – это переменная локальная для
функции add. PN у меня живет в main, и за функцией add я не могу менять переменную, которая живет
в main. Поэтому, чтобы получить возможность изменения, я использую возможность передач
по адресу. Я передаю адрес PN. Этот адрес копируется в указатель. Какой это тип? Если это тип
нот-звездочка, это нот. То есть, вот это нот. Это нот-звездочка, она указывает на нот. А этот
указывает на того, кто указывает на нот. Значит, он нот-звездочка-звездочку, он указатель на
указатель на нот. Но звездочка-звездочка – это вот наша P. Вот у нее вот здесь как раз такой тип,
видите, нот-звездочка-звездочка. Я знал, что вам понравится. Я знал, что это нельзя делать до
контрольной. И начинаем реализовывать эту функцию. Нот. Новую ноту создаем. Мы добавляем в
конец. Соответственно, нам нужна новая, которая сейчас добавится в конец. То же самое. Нот,
назовем ее PV, равно newNOT. Нот PV, newNOT. То есть, сейчас мы с вами создали некий указатель на ноту
PV. Через него создали новую ноту в памяти. Вот что у нас сейчас в памяти делается. Все вот это чудо
в стеке. К разным функциям, правда, относится это к функции add, это к функции main. Вот эти две
штуки висят у нас в динамической памяти. Заполняем ее смыслом, как обычно. То же самое. Через операцию
стрелочка. Значит, я что делаю PV? D. Равно D. Вот этот D, который мне передали, я кладу сюда. Вот у
меня был вызов с тройкой. Эта тройка вот сюда у нас записалась. Теперь давайте PV next. Вот у меня
следующий элемент. У него нет следующего, поэтому, наверное, мы сюда сейчас запишем с вами
0 PV next. Это 0 будет у нас. А вот PV prev чуть сложнее, потому что вот у меня предыдущий элемент,
и мне, по идее, надо связать. У него есть предыдущий. Как мне до него достучаться? Как узнаешь,
как кто у меня предыдущий? Вот меня создали, у меня, оказывается, есть предыдущий. Что я еще знаю? Я
знаю, вот это P, который указывает на P end, а P end указывает на предыдущий. Давайте через P и
вытащим этот предыдущий. Как? Разыменуем P. Если мы разыменовали P, то мы получили P end,
который указывает на предыдущий. Таким образом, PV стрелочка prev равно звездочка P.
Ну, это все или нет? Нет, потому что у этого теперь появился у первого следующий. Значит,
надо это 0 заменить на вот тот элемент, который мы только что создали. Давайте достучимся до этого
поля next. То есть, это у нас поле D. Напоминаю, это поле next. Это поле prev. Давайте достучимся до
поля next первой структуры, которая у нас была создана в памяти. Вот у меня P есть. P держит
у меня указатель на P end. P end знает, где находится эта нода, и внутри ноды надо выделить еще и одно
поле next. Как будет выглядеть эта структура? Значит, мне, чтобы добраться до P end, надо разыменовать
P, потому что P это указатель, а мне надо то, что содержимый указатель. Ведь P end указывает сюда,
адрес находится здесь. Это содержимое. Мне не интересно, где адрес P end. Мне интересно его
мясо содержимое. Это значит, что мне надо разыменовать вот этот P, чтобы получить содержимое этой
ячейки. Я разыменовываю P. Теперь, когда я его разыменовал, я должен поставить стрелочку,
потому что, чтобы добраться, собственно, до вот этой структуры, мне надо разыменовать
теперь сам P end и поставить точку. Это то же самое, что стрелочка. И теперь, после стрелочки,
к какому полю я обращаюсь? К next. А теперь я пойму, понимаете ли вы хотя бы что-то,
и спрошу рандомного человека, что надо написать дальше. Сделаем очень просто. Вот я вижу,
что молодого человека на последней парте точно он все знает. Да, вот вы. Что надо здесь написать?
Ладно, попытка номер два. Раз, два, три, четыре, пять, шесть, семь, восемь. Да, вот вы. Нет,
вот вы. Восьмая парта, самый крайний. Молодой человек в серой футболке. В нее смотреть назад,
это вы, да. Ну, хорошо. Давайте, кто знает тогда? Один, два, так много. Так, а почему все отличники
сидят в начале, а почему... Вот на последней парте поднял руку, молодец. ПВ, молодец. Видите,
и наша галерка тоже все знает. ПВ. Потому что мы хотели присвоить адрес вот этой второй ноды,
но у нас есть как раз указатель ПВ, который ее держит. Вот. Теперь смотрите, мы с вами завели
второй элемент списка, мы заполнили сюда данные, мы заполнили следующий элемент, мы заполнили
предыдущий элемент, и все ли я сделал, можно ли заканчивать функцию, или осталось сделать еще
что-то. ПН, да. Теперь вот нам надо указатель наконец нашего списка подвинуть, то есть его надо
изменить. С первого на второй. И как раз я его изменю за счет этого П. П поменяет нам содержимое
того, на что оно указывает. Итак, содержимое П это звездочка П. И это тоже ПВ, потому что
второй элемент это как раз ПВ. И вот мы закрываем функцию. Это прекрасная функция,
которая у нас получилась, которая добавляет, накидывает нам элементы в конец список, добавляет их.
Давайте теперь научимся с вами удалять, или сначала давайте попроще вставлять. Итак,
когда у меня будет накидано много элементов в список, вот у меня список, иногда мне захочется,
как я вам демонстрировал, что-то вставить в середину списка, добавить новый элемент,
которого не было. Это будет у нас функция insert. Вызовем ее из нашей программы в main. Ее тоже
будет уметь добавлять после какого-то элемента. Такая insert у нас будет уметь добавлять после
элемента. То есть вставлять она может после какого-то элемента. Если вставлять после,
она никогда начало не изменит. Но если она вставляет после последнего, она может
изменить конец. Поэтому начало мы передадим наш пб обычно по значению, а пн нам придется
также передать, чтобы его возможность была менять. Поэтому возьмем адрес пн. Теперь дальше,
после элемента 2 мы вставляем 5, так как мы хотели. После первой двойки, оказывается,
была пятерка. Мы ее не заметили. Человек так собрался и хотим добавить в список после двойки
пятерку. Давайте нашу процедуру insert напишем. Буду писать тогда уже здесь. Вам здесь видно?
Наверное. Итак, мы с вами вернем то, что вставили. Можно там игнорироваться,
возвращаем значение. Это неважно. Мы можем использовать это. Итак, вставляем новый элемент.
Значит, мы хотим с вами передать значение. Указатель на начало. Чтобы никто нам его не
попортил, мы передадим его как константный указатель. Пб будет у меня константный указатель
на ноду. Это локальный фибек. К тому побегу не имеет отношения. Об этом помним, потому что это
объявляется внутри функции. Читаем справа налево. Константный указатель на ноду. То есть,
мы не сможем поменять этот указатель, чтобы, если функция insert работает некорректно,
начало нашего списка хотя бы останется правильным. Кроме того, мы с вами должны дальше продолжать.
Второй у нас элемент нашего списка будет передаваться по чему? Уже по адресу,
потому что у нас с вами в списке требуется иногда изменить конец, если у нас последний
элемент, после него мы вставляем след на конец нашего списка, будет меняться. Поэтому это будет
указатель на ноду, как только что было. Здесь его p-end, чтобы было понятно, о чем речь,
но и другой p-end. Это не тот, который тот. Это локальная переменная в данной функции,
которая будет указателем на p-end, который функции main. То есть, у нас вот что вышло.
У нас вышло вами следующее. У нас сейчас есть две ноды. Давайте не две. Там много нод. Мы
добавили с вами еще троечку, двоечку. Вот что мы сделали с вами. В них есть указатель на
следующий. Здесь у нас указатель на предыдущий. Это текущая картинка. И вот у нас есть еще p-end,
который указывает на наш последний элемент нашего списка. Теперь смотрите, я хочу вставить
пятерку после двойки. То есть, фактически вот за этой двойкой сейчас появится нода с пятеркой,
которую я буду вставлять. И для того, чтобы правильно работать, я здесь завел две переменные.
Вот этот p-beg, который только что у меня объявился в функции insert, это не указатель на p-beg,
а это переменная, которая была передана по значению. Следовательно, просто вот этот p-beg
скопировался в этот p-beg. Этот p-beg держит начало списка. Мы не можем менять. А p-end у меня чуть
сложнее. У меня есть другой p-end, который указывает как указатель на указатель. Вот такая картинка.
Теперь передадим ключ. Это то, что мы ищем. Обычно программируют и называют это ключом. И
значение, которое мы вставим после ноды, которое является ключом, если оно найдется. Ну и самое
главное, тезис, что если найдется, может мы вставляем зачем чего нет. Поэтому давайте поищем,
будет ли она вообще найдена. Для этого нам потребуется if, где мы в лучших наших традициях
все сделаем и объявим, и присвоим, и получим результаты, в зависимости от этого будем
работать или не работать. Итак, объявим внутри if-a новую переменную нод, указатель на нод,
которая будет называться у нас pk. Ей же тут же сразу присвоим значение функции, которую мы сейчас
еще не написали. Именно функция find, которая будет искать в нашем списке нужное нам значение вот
этого ключа. Мы даем откуда искать pbek. Вот это переменная нас pbek. И что искать? Ключ.
Значит, нам нужна еще скобочка. И теперь самое время написать функцию find, где бы нам найти место.
А там вы не видите, да? Тогда функцию add, да. Потому что у нас будет хитрый
работать функция find. Если она ничего не нашла, она вернет 0, if не сработает. Если она хоть
что-то нашла, она вернет адрес. Любой адрес, это не 0. И значит это true, значит мы работаем.
В этом у нас с вами и суть. Так, давайте напишем вот эту функцию find.
Смысл в том, что у вас вы никогда не знаете вообще сколько вы напишете, потому что может
пойти вдохновение и вы можете писать очень много кода. А утром вы просыпаетесь и понимаете все,
что вы писали ночью, можно написать двумя строчками. Особенно это часто встречается
на Олимпиадах. Если вы на ИСМ ходите на студенческие Олимпиады программированию,
там очень часто такая ситуация, что командник пишет, пишет, пишет, написал 20 экранов. Недавно,
может быть, слышали финал был у нас как раз в России, проводился в манеже перед Кремлем. И
пистек там хорошо выступил, минутка рекламы. Вот, получил золотую медаль. Значит, так вот,
и задача не зашла. Что они делают, как правило? Ну, отлаживают, отлаживают, потом поняли,
что отлаживать это вообще такое, скажем, неблагодарное дело, особенно в чужом коде
разбираться. Иногда проще переписать заново. Садится другой человек переписывать заново,
было там 10 экранов, стал один экран, зашла с первого раза. Потому что не всегда количество кода,
оно соответствует качеству, поэтому никогда нельзя предугадать, чтобы решить задачу.
Итак, not find. Значит, find у нас с вами будет делать следующее. Мы объявим вот этот самый
константный указатель тоже на побег. Начало нашего списка. И, собственно, что мы с вами ищем?
int d. Давайте какую-то, объявим временную переменную указатель на нашу временную указатель. У нас
все начинается с p, потому что p это pointer. В информатике вот эта одна нода еще называется
вершины графа вертекс, поэтому мы будем это как бы, как в графах будем с вами писать. И дальше мы
начинаем этот указатель двигать. Вначале мы его с вами присвоим началу. Списка вот этому.
Пбек. То есть наш pv это пбек. Сейчас он, наша временная какая-то переменная, она указывает
на первый элемент нашей ноды. Теперь дальше я должен смотреть. Вот у меня вот здесь хранится то,
что я ищу или нет. Если да, то ок, я возвращаю, я смог найти. Если нет, я продолжаю идти. И pv должен
двигать next, next, next, next, пока не дошел до нуля. Потому что последний в next будет 0 у нас, правда? И
этот 0 мы с вами закончим наш цикл. И тогда очень просто. Прямо сделаем while pv. Смотрите,
когда он станет нулем цикл закончится, пока не 0 мы будем продолжать искать. И теперь если то,
что у нас хранится в нашей временной переменной данной у нас как раз те, которые мы ищем,
извините, равно вот этому d, вот это d, вот это d. Все, мы нашли. По идее мы можем с вами цикл
заканчивать, поэтому мы досрочно из нее выходим, делаем break. И дальше, если нет, мы просто сдвинемся
на следующий элемент. pv равно pv next. Мы сдвигаемся на следующий элемент списка. И когда мы будем на
последнем, то pv next будет равен нулю, у нас присвоится 0, while по нулю у нас выйдет,
тем самым мы в любом случае цикл будет конечным. И давайте вернем то, что мы нашли. И вот если мы
нашли 0, если у нас указатель этот нулевой, это значит мы прошли до конца списка, ничего не
обнаружили. Значит find вернет 0, 0 присвоится в pk. Результатом у нас тоже будет присваивание,
всегда то, что присвоилось как результат присваивания, это будет ложь и все. Мы никуда не
провалимся, поскольку некуда вставлять не нашли зачем. Если же мы с вами найдем такой элемент,
то это будет не 0 и ивс работает. Поэтому мы здесь объявили переменную и выполнили поиск и присваивание,
еще и результат. Это вот тот момент, когда в тот случай, когда присваивание в ифе разумно.
Можно было делать по-другому, но здесь оно хотя бы имеет смысл. Это вот не баг, это фитча, как это
говорят программисты. Теперь я создаю новую ноду, какую-то временную, которую буду сейчас
вставлять между нашими двумя элементами списка после того, кого мы нашли. Заполним ее сначала
значением. Вот что у меня сейчас получилось. У меня есть некое время, мы вот сейчас после
двойки будем вставлять новую ноду. Я создал ее в памяти, на нее у нас указатель pv. Что вы так,
как сепенди, так разговариваете? Сейчас еще три минутки. У нас указатель есть, и нам надо с
вами, нам надо с вами очень сюда заполнить вот эту пятерку, поменять все указатели. То есть вот этот
вот сюда, от этого на следующую и так далее, этот на предыдущую. То есть мы должны вот эту связь
разорвать между вторым и третьим, первым и вторым, и сделать ее между первым, вторым, вторым и третьим.
Ну давайте, поскольку времени мало, я просто это напишу, а вы дома посмотрите, почему это так.
pvnext это было, это pknext, то есть то, что мы нашли, его следующий, то есть если мы говорим pvnext,
вот он, на что он должен укаживать? Вот мы нашли ноду, вот его следующий, вот мы как раз на его
следующий пишем ему указатель. pvprev это pk. Теперь мне надо поменять, собственно, те остальные,
которые мы только что с вами нашли, вот за которым мы вставляем, у него тоже следующий поменялся,
следующий это вот этот новый, поэтому давайте его менять, на него указывает pk. pknext это pv,
этот новый, за которым мы сейчас вставили. Ну последний у нас небольшой такой if будет с
вами, если мы с вами не за последним вставляем, то есть если у наш pk, который мы нашли, не указывает
на последнюю ноду, мы разыменовываем этот pn, который двойной указатель, получаем адрес последней
нашей ноды, если наш pk не последняя нода, то есть потому что если за последним, то у нас частный
случай, поэтому если не равно, то обычный случай мы с вами сделаем это pvnext.prev равно pv,
то есть что я делаю, вот у меня pv, следующий сейчас указывает на вот этот второй, у него
предыдущий должен стать не первый, а мне надо замкнуть его на собственно pv, вот эта строчка она
это и делает, и а иначе, мне надо просто, раз у меня вставилось после последней, теперь то, что вставилось,
это есть последний, поэтому разыменовываю pn, чтобы его поменять, равно pv, возвращаем то, что мы с
вами новый элемент, который вставили, а иначе, если мы в них не вошли, возвращаем ноль, что не
смогли вставить, отлично, мы даже успели, а на этом на сегодня все, до свидания.
