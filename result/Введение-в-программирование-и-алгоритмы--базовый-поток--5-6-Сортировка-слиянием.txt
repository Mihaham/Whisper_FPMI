Давайте с вами вообще вспомним, что мы проходили на алгоритмах. На алгоритмах мы с вами проходили
несколько вещей. У нас была аннотация, амбратизационный анализ и сортировки.
Сортировки мы успели пройти всего 4-3 из них квадратичные. Это не очень круто, так что нам
нужно нагонять. У нас будет очень много сортировок еще впереди, как минимум две.
Нам необходимо их доделать и досмотреть, что это такое. Давайте с вами начнем с такого
небольшого повторения. Какие виды сортировок бывают? Я имею в виду, чем они могут отличаться и
что было бы круто что-то делать. Давайте сделаем подзаголовок виды сортировок.
Количество обменов. Количество обменов действительно мы ведем, но для видов сортировок
необходимы немножко другие штуки. Первое. Какой есть вид сортировки? Она называется
in-place сортировка. Это сортировки
ну или просто алгоритмы. На самом деле можно применять это слово к любым, не только к сортировкам,
которые не используют дополнительные хранилища.
По факту для вас как это можно интерпретировать? Интерпретируется это очень просто, что используется
только swap. Вот. Это первый момент какая бывает сортировка. Вторая. Это без доп памяти.
Доп. Смотрите. Без доп памяти подразумевает, что мы используем максимум у от единички памяти.
У от единицы памяти. Скажите мне, входит ли создание нового массива в создание памяти,
создание каких-то новых переменных? Вот создание новой переменной. Это сколько памяти занимает?
У от единички. У от единички. А создание массива размера n? У от n. Хорошо. А теперь вопрос.
Ну теперь вопрос будет следующий. У нас есть quick sort, правда? Quick sort надеюсь вы все помните.
Мы его проходили не зря. Quick sort использует ли доп память? Кажется, что нет. А quick sort что делает внутри себя?
Он вызывает что-то рекурсивно, правда? И у нас образуется стэк вызовов. Вы это проходили на языке.
То есть когда мы рекурсивно вызываем сами себя функцию, у нас появляется так называемый стэк вызовов.
Стэк вызовов, где мы начинаем что-то раскручивать. У нас есть этот вот вызов, у нас есть функция f от 10,
которая вызывает f от 5 и f от 7, но я просто рандомные числа пишу и так далее. И этот стэк вызов
он хранится, потому что кто зачем идет. Это тоже доп память. Поэтому quick sort это in-place сортировка,
потому что она внутри использует только свопы и не выделяет никакой доп памяти именно для массива
там какого-нибудь. Но она использует доп память, потому что она использует внутри себя рекурсию.
Именно в том виде, в котором мы писали. Если вы напишете не рекурсивном случае, тогда это будет
без доп памяти. Любую рекурсию можно заменить циклом. Правда, надо иногда постараться, чтобы
это сделать. И третий важный пункт у сортировок это стабильность.
Стабильность. Что это означает? Это означает следующее. Представьте, что у меня есть какой-то
массив А0, АИТ, АЖИТО и АН-1, к примеру. И мы с вами это сортируем и получаем там какие-то
вот такие вот штуки. Тут П от нуля. П, я имею ввиду, это просто перестановка какая-то. То есть мы
взяли и переставили элементы между собой. И так далее. Я получил здесь АП от И, к примеру,
АП от ЖИ. Так вот в чем суть. Если у меня АИТ равно АЖИТОМУ и И меньше чем ЖИ, то это
влечет за собой, что перестановка ИТ-го элемента меньше, чем перестановка ЖИТ-го элемента. Что под
этим подразумевается? Представьте следующее. У меня есть массив, ну к примеру, там не знаю,
0-2-3-2-2-4-1. Вот так. Я хочу это отсортировать. Если я получаю 0-1-2-2-3, то это стабильная
сортировка. Стабильная. Если я получаю 0-1-2-2-2-3, то это нестабильная. Вот что такое стабильная
сортировка. То есть еще раз, мы говорим о том, что если у нас элементы одинаковые по какому-то
признаку, то это стабильная сортировка, значит нестабильная. Вам сейчас может показаться странно,
зачем мне двоечки обозначают там, к примеру, отдельно считаю разные двоечки. Но представьте
следующее. Вот вы написали структуру, у вас там есть фамилия, у вас есть там оценка за контрольную,
еще что-нибудь. Вы берете и отсортировали, к примеру, всех там по фамилии. У кого-то сошлись фамилии,
и вы в разном порядке можете делать. У кого-то вы сначала отсортировали так, потом вы решили
отсортировать по оценкам за контрольную, например, и вы хотите, чтобы они шли в нужном вам порядке. То
есть в том моменте, как они сдавали контрольную, так можно, к примеру, списывания найти. Вот как
они сдавали друг за дружкой. Вот если у них ответ одинаковый, и у них одинаковая оценка за
контрольную, то, возможно, они списывали, а, возможно, не списывали. Но здесь все равно вопрос. И мне важно
стабильность в этом все. Мне нужно здесь как-то оценить. И поэтому стабильная сортировка – это
хорошо. И это неплохо. Вот. Таким образом, у нас есть вот такие вот три категории, которые мы можем
как-то говорить об этом все. Смотрите, у нас с вами были сортировки какие? Квадратичные.
И мы здесь кое-что ведем еще новое. Были квадратичные сортировки.
И был пока только QuickSort. Смотрите, квадратичные сортировки, они все у нас… Смотрите, пузырек
использовал только Swap. При курсе никакой не было. Давайте здесь мы разделим пузырек.
Пузырек. Выбор. Ставки. Для них всех они являются без доп памяти. То есть ничего из этого не требовало
никакой дополнительной памяти. Ни рекурсивной из остека вызов, ни какой-то вводить еще определенной.
Поэтому они все без доп памяти. Но есть еще одно важное свойство этих всех сортировок. Это
количество Swap. Количество Swap, которое возможно. То есть в среднем сколько количество Swap. И на самом
деле, вот здесь вот сортировка выбора выигрывает абсолютно у всех, потому что здесь достаточно N,
то есть тут O от N Swap. У пузырька количество Swap, O от N квадрат. А у вставок тоже O от N квадрат,
потому что мы все время перекидываем и Swap элемент, просто двигая его. В среднем это N квадрат.
Что касается QuickSort. QuickSort он in place, но с доп памятью. Именно для рекурсии. Это первое. Второе.
Количество Swap здесь в среднем. Это O от N log N. Количество Swap. А теперь стабильность.
Пузырьковая может нам гарантировать стабильность. В принципе, выбором точно
гарантирует нам стабильность. Если мы первый минимум двигаем, то если есть такой же минимум
дальше, то мы его встретим только позже и Swap'нем только позже. Вставками тоже нам может гарантировать
стабильность. То есть они все еще и стабильные. А вот QuickSort все зависит от того, как он написан.
По факту он чаще всего нестабилен. В плане написания, смотря что вы напишете,
как именно сделаете. Если вы поставите знак меньше, либо равно, либо меньше. Вот подумайте,
что из этого стабильное, а что нестабильное. Это то, что касается стабильности. Она может быть
стабильной. Но не всегда. А теперь важный вопрос. Верно ли следующее утверждение любую
сортировку? Даже те, которые мы еще не прошли. Сортировку можно сделать стабильней.
Верно ли это утверждение? Как вы считаете? Да. Да, почему? Иначе бы не спрашивали. Люблю такое.
На самом деле, да, действительно можно любую сортировку сделать стабильной. Каким образом?
Достаточно нам ввести следующую штуку. Пусть у нас сортируются не просто элементы,
а иты. А иты вместе с парой и. И если у нас элементы, и если у нас а ит равно ажитом и и,
то тогда мы сортируем по и и ж, что меньше. То есть еще раз, если у нас элементы а иты равны
ажитом, то есть как раз равны наши элементы, это может быть по любому признаку равным. Не
обязательно говорить, что мы говорим только лишь о числах. Это любые элементы могут быть.
То мы сортируем для стабильности по и и ж, если они у нас будут равны. Это понятно?
Или непонятно? Видимо понятно. Можно вопрос? Я не совсем понимаю. Я помню,
мы когда проходили сортировки за n квадрат, вы говорили, что средний случай это худший случай.
Там действительно средний случай это худший случай, потому что нам никак не влияло,
для нас никак не влияло именно сама суть свопов. То есть у нас из-за неопределенности ничего не
происходило. То есть все случаи были равны друг для дружки. Для квиксорта это не так,
к примеру. То есть там рандомный случай может разделить мне массив на 1 и n-1 элементов,
а вот в пузырек он всегда будет пройдется один раз по массиву и свопнет что сможем.
Понятно. И там такой же случай будет. Вот и все. Спасибо.
Понятно. Как стабилизировать квиксорт? Нам надо еще сортировать кусочки.
Представь, ты сделаешь структуру. Структуру, где у тебя будет помимо самого числа еще и индекс этого
числа. И ты сортируешь структуры. У тебя было, если аи меньше ожито, то ты там свапал,
к примеру, в квиксорте. Правильно? А здесь тебе необходимо проверить структуру,
если структура a.data меньше, чем b.data. А внутри еще один ик. Если a.data равно,
ну точнее дополнительных, если они равны, то ты сравниваешь их индексом. Все, ты доводишь
дополнительные сравнения. Понятно? Вот. Это то, что касается сортировок. Есть ли к этому вопроса?
Надеюсь, что нет. Больше. Поверно. Окей. Тогда мы переходим к сегодняшней сортировке. И это
сортировка. Слияние. Слияние. Сейчас, а можно еще вопрос, вот эти индексы и ожи,
это которые в процессе меняются или изначально? Изначально. Изначально массив, у тебя шла первая
двойка до второй двойки. Я понял. Сортировка слиянием. Сортировка слиянием. Очень полезная
сортировка, на самом деле. И вы сейчас узнаете скоро почему. Сейчас, момент.
Что касается сортировки слиянием. У нее есть просто несколько принципов, по которым она работает.
Давайте первое, что там необходимо сделать, это просто мерч. Давайте я напишу. По-английски это
мерч-сорт. У данной сортировки есть один главный метод. Как у QuickSort был partition,
здесь есть один метод, который нам необходимо будет описать. Он называется мерч. Слияние. Слияние
двух массивов, которые уже отсортированы. А и Б. И нам необходимо из того, что мы их замерчили,
получить отсортированный массив С. Я так изображаю, типа отсортирован по возрастам. Вот. Как это
сделать? Давайте представим, что у нас, ну не представим, а у нас вот есть мерч. Нам необходимо
отсортировать два элемента. Ну, точнее отсортировать это так, чтобы у нас получился большой-большой
массив. Как я могу делать? Ну, давайте сначала сделаем это на примере, после чего напишем
псевдокод. Пусть у меня есть массив один, три, восемь. И есть массив два, четыре, два, два, четыре.
Сейчас подумаю, пусть будет девять, например. Вот. Как нам отсортировать? Мы с вами строим массив С.
Массив С. У нас здесь три элемента и три элемента. Если их по три элемента, то мы с вами берем и делаем.
У нас суммарный массив будет из шести элементов. А так как они отсортированы по возрастанию,
нам достаточно сравнивать только лишь первые два элемента. И вести указатель на эти элементики.
Я сравниваю первые два элемента. Какой из них меньше? Один или два? Естественно, один меньше,
и я его записываю в массив С. После чего двигаю этот указатель. И теперь оно меня на три и два.
Я сравниваю опять два и три, наши элементы. Два меньше, поэтому я вставляю эту двойку вот сюда.
И двигаю здесь уже указатель. Сравниваю три и четыре. Дальше у нас три. И опять двигаю указатель.
Потом у нас четыре. Потом у нас восемь. И потом у нас девять. То есть смотрите,
мы идем по отсортированным частям, начиная с самого начала. Там самые наименьшие элементы
в этих массивах. Мы предполагаем, что эти массивы уже отсортированы. И просто их пытаемся слить между
собой. Для того, чтобы их слить, достаточно пройти у одного и у второго. Просто линейно. Линейно пройтись
по двум данным кускам, и тогда мы сможем записать наш массив. На примере понятно,
как работает сам мерч. Чудно. Тогда давайте напишем наш псевдопод.
Попрос. Массивы AB всегда должны быть одинаковых размеров, да?
Не обязательно. Ну, давайте тогда еще один пример сделаем. Пусть у меня есть восемь, есть один,
три, пять. Мне нужен массив из четырех элементов. Раз, два, три. Я беру указатель здесь, беру указатель
здесь. Вставляю сюда единичку. Двигаю указатель. Три меньше восьми. Все еще вставляю тройку.
Потом двигаю еще раз указатель. Пятерка. Пятерку вставляю вот сюда. Пять. А только потом восемь.
Тоже я смог смёртвить. Где без разницы какая длина массива? Сортировать отдельные массивы
кликсортом. Сейчас мы до этого дойдем. Давайте сначала мерч рассмотрим. А нам все равно, да,
они оба сортированы одинаково или один по возрастанию, другой по убыванию? В смысле,
они все должны быть одинаковы по возрастанию. Ну, по неубыванию давайте так скажем. Могут быть
одинаковыми. Понятно? Да. Хорошо, тогда продолжаем. Нам нужно написать вообще наш... Как же реализовать
стабильность? Ну, то есть что там будет элементом порядка? Чего ж вы так сильно вперед-то идете?
Давайте сейчас все проверим. Все посмотрим. Давайте напишем псевдокод на эту операцию мерч.
Мерч нам возвращает наш с. Правильно? То есть он возвращает какой-то массив, который мы хотим
как раз увидеть. Окей, тогда в этот мерч мы с вами передаем массивы а и b. Вот. Давайте введем индекс,
что у меня и... Давайте, чтобы не запутаться, и а равно и b, равно и c, равно нулю. Но мы начинаем
с самого начала. Да? Друзья. И а, и b, и c, это у вас указатель на начало массива? Это указатель на
начало массива, да. Все указатели начало массива. Вот. После чего я говорю пока и а меньше, чем а, и...
Это имеется ввиду количества элементов, я думаю вы понимаете, правда? Ну, то есть количество элементов
и и b меньше, чем b. Ну, то есть мы идем до конца массива. То в этом случае что мы делаем? Мы говорим,
что если у нас массив а от и а меньше, либо равен, чем массив b от и b, то в этом случае мы делаем
что? Мы говорим, что c от и c, равно а от и а. Ну и увеличиваем и c, и и а. То есть это будет и c, равно и c, плюс 1.
Я напишу так, но просто в одну строчку, чтобы у меня поместилось. И и а, равно и а, плюс 1. То есть я
двигаю эти указатели. Все, чудно. Иначе, иначе, я говорю, что c от и c, равно b от и b. То есть смотрите,
если у меня элемент а, элемент из а, меньше либо равен, чем элемент из b, то я вставляю в c наш
элемент из а. Иначе, я вставляю из b. То есть я просто сравниваю первые элементы и иду этими указателями.
Ну и здесь у меня и c, равно и c, плюс 1. И а, о и b, равно и b, плюс 1. А ведь можно увеличение и c просто
вынести за if. Вместо того, чтобы писать и в if, и в else. Можно. Можно. Пожалуйста. Вот. Скажите мне,
это весь мерч, который нам нужен или нет? Это не весь мерч, который нам нужен. Если у нас остались
элементы в каком-то измножестве. Да, нам надо написать. Остались ли элементы действительно в каком-то
измножестве? Это очень важно понимать, что вообще там происходит. То есть давайте сейчас я здесь сбоку
нарисую. Представьте, вот у меня есть массив а, и у меня вот есть массив b. Я получаю сюда массив
c. Причем самое начало, предположим, я вставил, ну вот, то есть вот до этого момента, я вставил вот так.
У меня и а, меньше а, уже не работает. А вот это все заполнено. Значит, мне надо всю часть b вставить
в c. Аналогично будет, если у меня в а останется какая-то часть, мне нужно доставить ее в c. То есть
я здесь дополнительно должен написать. While и а меньше а, c и c равно а и а.
И c равно и c плюс один, и а равно и а плюс один. И естественно для b. То есть смотрите, если одно из
этого не выполняется, мы перейдем к другому while. Иначе мы просто проверили, ну типа ничего страшного.
While здесь у нас и и b меньше чем b, c и b равно b и b, и c равно и c плюс один, и b равно и b плюс один.
Почему c и b? Ой, c и c, да. Спасибо.
Так, есть ли вопросы к самому мерджу? Получается, в данном примере указатель это номер элемента
массива. Это индекс. Индекс последнего элемента, который не сволкнут. Ну, точнее, не взят массив c.
Еще вопросы? Видимо нет вопросов. Хорошо, у нас с вами есть мердж.
Окей, мердж у нас с вами есть. Теперь необходимо вообще отсортировать наш массив. А что же нам
как его делать и отсортировать? Смотрите, мне как-то один раз сказали, мердж sort это
сортировка оптимистов. Почему? Потому что все считают, что у нас массив не отсортированный,
его нужно отсортировать. А мердж sort считает, что у нас каждый элемент отсортированный, уже все
хорошо и мы можем с этим работать. Именно в этом и будет заключаться сама суть. Представьте
следующее, у меня есть массив. У меня есть массив из чиселок. Каждый из чисел, давайте его как-нибудь
запомним, 1, 3, минус 1, 0, 5, 7, 3, 4, 9. Но мы его можем разбить на n под массивов. Мы его можем
разбить на кучу ячеек таких. 1, 3, минус 1, 0, 5, 7, 3, 4, 9. Смотрите, мы разбили кучу под массивов,
и каждый из них, каждый из них у нас отсортирован. Сам для себя я всегда отсортирован. То есть я есть,
ну типа вот один элемент, он всегда считается упорядоченным между собой. Чудно, тогда это
означает, что у меня этот кусок и этот кусок отсортированы, значит я могу их объединить в один
большой кусочек. И тогда в этом случае я получу элемент уже из двух чисел. Дальше объедини
другие кусочки. Здесь получу минус 1, 0. У меня так получилось, что они все в нужном порядке идут.
Давайте что-нибудь, ну ладно, буду зачеркивать, потом мы разъединим. У нас потом 5, 7. Здесь 3,
4. А здесь 9 так и осталось. Ну оставим его 9. У нас появились новые кусочки. Чудно,
тогда давайте их объединять. Мы опять их объединяем с помощью мерджа. 1, 3, минус 1,
0. Минус 1 меньше 1. Да, действительно, поэтому будет минус 1. Потом у нас идет 0,
потом у нас идет 1, а потом у нас идет 3. Потом я обвиняю два этих кусочка. У нас здесь будет
3, 4, 5, 7. А 9 все так же несчастное идет понемножку. Просто одна. Потом я объединяю
вот эти куски, получая здесь уже отсортированный массив. Здесь у нас будет минус 1, 0, 1, 3, 3, 4, 5,
и 7, и 9. Все еще несчастная одна. И после этого мы уже вместе их объединим, и девятка наконец-то
обретет свое место в этом массиве. Сейчас, момент, побольше его сделаем. Вот так. Вот,
то есть здесь у нас будет массив минус 1, 0, 1, 3, 3, 4, 5, 7, и 9. Таким образом я получаю отсортированный
массив. То есть я вначале должен разбить все на кусочки, потом мерджить друг за дружкой все это.
Это лучше всего делать рекурсивно. Рекурсивно, и тогда у нас будет какой-то стек вызовов. Конечно
же. То есть у нас будет использоваться какая-то доп память, но пока это выглядит так. Однако,
смотрите, в чем вся еще проблема? В том, что мы создаем новый массив C. Когда мы создаем
с вами новый массив C, у нас все очень грустно в том плане, что мы очень много памяти можем
израсходовать. По факту, мы каждый раз, в первом этапе, когда у нас 2 элемента, у нас их тоже мержатся.
На первом этапе, когда объединяются 2 элемента. 2 элемента объединяются, это естественно тоже мерч.
То есть это все мерч. Давайте, я сделаю небольшое пояснение. Это мерч. Это мерч. Ну, для всех
остальных аналогично. Это мерч. И это мерч. То есть мы просто берем все мерчем. У нас все
с вами хорошо получается. Класс. А можно вопрос? Да. А вот где девятки, там тоже мерч? Да. Спасибо.
Когда мы добавляем один элемент, мы тоже его мерчим. Вот. И таким вот образом мы с вами
получаем. А имеет ли смысл добавлять в мерч в конце дилиты A и B массивов? Смотрите,
вот здесь все и начинается как раз таки. Эта сортировка с лиянием требует памяти. Причем
памяти каждый раз у от N. То есть сколько у нас здесь элементов хранится? У нас здесь было N
элементов, стало N пополам массивов и суммарно их количество равно N. То есть каждый раз мы должны
выделять N памяти. Поэтому эта сортировка работает с O от N памяти. O от N памяти.
А почему O от N тут же получается выделяется на каждом уровне рекурсии правильно? Да. Тут же
каждый раз. Смотрите, здесь вопрос в том, что вы считаете дополнительной памятью. Если вы
очищаете все вот эти элементики 1, 3, минус 1, 0, 5, 7, 3, 4, 9. Если вы их уничтожаете, то у вас в
какой-то момент максимум до памяти используется O от N. Понятно? Вот. То есть еще раз. У вас в один
момент времени должно быть два слоя только. Этого достаточно для решения этой задачи. После этого мы
верхний слой очищаем и на основе него делаем третий слой. N же элементов. Правильно?
За какую скорость работает Merge? Сейчас. Ну что ж такое-то? Сейчас расскажу. То есть нам в
Merge надо дописать еще очистку вот этого первого слоя. Я пишу псевдокод. А ну то если вы не псевдокоде,
там очистка есть. Конечно. Но если только ты надзаб или C sharp не пишешь, тогда. Вот. Третий
слой создается за счет первого. Что еще раз? Вы сказали, что третья срочка создается за счет
первой с точки. То есть вы имеете в виду то, что первое очищается, освобождается место для третьей.
Поэтому памяти O от N дополнительно. Помимо этого, смотрите. Какова глубина вот этого чуда?
Кто мне скажет? Кто понимает? Третий по основанию 2 от N? Да. Ну то вверх мы должны округлить.
Но порядок такой. Выгорифм от N. Выгорифм двоично. Вот. Таким образом мы каждый раз с вами берем и
делаем сколько сравнений. Давайте сравним. На первой стадии мы сравниваем каждый элемент с каждым.
И это сравнение. И потом еще вставляем это. То есть каждый уровень занимает у нас. Ну вот
первый уровень как минимум. Занимает нас с вами. Второй уровень аналогично. Третий тоже. И так
далее. То есть каждый раз мы с вами вставляем по элементу. И мы суммарно вставляем сколько новых
элементов. N. Таким образом мы делаем это от N действий. А сравниваем мы сколько раз. Смотрите,
если у меня объединяется массив A и B. Они делают merge. C. То в этом случае у меня количество
сравнений это тета от A плюс B. Потому что мы сравниваем каждый элемент из первого массива и
сравним с каждым элементом. Ну каждый элемент из первого массива мы хотя бы один раз используем.
Каждый элемент из второго. Получается он в общее время это тета от N на log N. Н log N. Именно
такова работа merge сорта. То есть смотрите, каждое действие тетн количество действия log N. Суммарно
тета от N log N. Ну либо можно написать O от N log N. Чаще всего пишто просто в силу обозначений. Но
здесь и в среднем и в общем и в худшем случае всегда у нас будет N log N действий. То есть время
работы. Время работы от N log N. Время. То есть здесь нет очень сложной математики. Достаточно
просто вот именно порисовать и сказать сколько у нас будет уровней и сколько мы действие делаем
на каждом из них и из них. Сколько мы сравнений делаем для получения этого уровня. Каждый раз у
нас будет тета от N. Вот этот от N уменьшается количество элементов. У нас уменьшается количество
массивов. Да, количество массивов уменьшается. А вот количество элементов этих массивов
увеличивается. Вот сколько элементов вот на этом уровне, на третьем? Девять. Девять. А на первом?
Тоже девять. Получается, что мы должны вставить все равно эти девять элементов. Да, спасибо.
Можно еще раз про память? Почему-то это от N. Про память. Еще раз. Для хранения первого
это N элементов, правильно? Да. Для хранения второго куска сколько необходим элементов?
Сколько памяти необходимо? Массивов раз меньше. Массивов. Памяти сколько? Памяти столько же.
Столько же N, да? После этого я предыдущую ветку удаляю, правда? И я ее перекидываю в нижнюю,
а на следующем мне опять надо N элементов. То есть каждый раз мне надо два N памяти для массива
из N элементов. Понятно? Да. Вот. А можете, пожалуйста, напомнить, чем тета от пола большого отличается?
Сейчас скажу. Если у меня есть функция F, я могу зажать с какими-нибудь функциями вот
такими вот. А это F, это G, это C1 на G, это C2 на G. И вот если я могу зажать такими
функциями, то F это тета от G. Если я могу лишь ограничить сверху свое F каким-то C от G,
любым. Ну почти любым. Существует такое C, что оно ограничивает F. То в этом случае, давайте
вот так расчерю, то в этом случае F это O'G. Понятно? Да. Отлично. Окей. Еще вопросы к Мёртвому.
Какое? Вот количество операций, там где log2N, мы округляем в большую сторону,
это для ничего отночного случая нужно, да? Ну если у тебя степень двойки, ну представь,
у тебя не степень двойки, вот тут девятка так идет вниз. Они всегда так и будут идти вниз. То
есть тебе необходимо по-хорошему, чтобы понять сколько здесь действий, до степени двойки добить,
и тогда ты получишь правильный результат, если без округления. Понятно. Еще раз, а почему лопаты?
Каждый раз мы уменьшаем количество элементов в два раза. Правда? Вот. Все. Мы уменьшаем количество
этих массивчиков в два раза, если берем на степень двойки. Ну вот она, типа вот они, восемь
элементов. Видишь? Да. Оно уменьшается в два раза, то есть было восемь элементов, стало четыре,
потом два, потом один. Мы все время на два делим, поэтому логариф. И потом еще добавляем,
который не вошел в степень двойки. Да, если бы мы добились здесь до степени двойки, было бы
шестнадцать элементов, к примеру, то у нас было бы ровно, потому что это девятка объединялась ровно
как вот эти элементы слева. Ясно? Да, спасибо. Отлично. Еще есть вопросы какие-то к мерджу?
Хорошо. Теперь перейдем к самой сортировке вообще. Как это выглядит? Сама сортировка
заключается на рекурсии как раз таки тоже. Она рекурсивно начинает сама себя вызывать и в какой-то
момент делать мердж. Делается это достаточно просто. И здесь важно понимать вообще, а что
происходит, иначе вы можете запутаться. Значит, смотрите. Что делает мердж? У нас есть такой мердж,
нам необходимо рекурсивно его вызвать. MergeSorts вообще сам по себе. Мы туда передаем что? Мы
передаем туда массив и количество элементов, к примеру, в этом массиве. То есть это все,
что нам нужно. Но просто количество в принципе нормально, если вы пишете,
ну если я пишу псевдокода, то есть вы сейчас поймете почему. То есть у меня есть такой вот
MergeSort. И что я делаю? Я делаю условия остановки. Если у меня там, к примеру, n равно 1, то есть
один элемент, то вернуть. Иначе, что я делаю? Я говорю, что здесь вот сложно мне просто так это
сказать, как это правильно вам написать. Ну давайте так. B и C. B это у нас элементы. B это у нас
A от 0 до n пополам. C это элементы A от n пополам до n минус 1. Понятно, что я имею в виду?
Ну я делю массив пополам. А почему не AB, если мы скроем обозначение из мерджа,
которое написали? Ну хорошо, давайте AB, пожалуйста. Просто я A маленько использовал,
думал, что вас это спутает. 2 из 2 пуска. Так, и что я с ними делаю? Я должен с ними как раз
таки сделать так, чтобы они мерджились. Но они могут мерджиться только, начиная после того,
как разделятся на единички. Почему мы n минус 1 не включили? Да, кстати. Ой, да, спасибо.
То есть, что мы делаем? Мы здесь должны вызывать рекурсивно наш Merge Sort.
Merge Sort.
От чего? От A и n пополам. Merge Sort.
Merge Sort.
От B и n пополам. И Merge.
Чего?
A и B.
A и B, да?
Merge Sort работает просто. Он делит пополам, доходит до одного и начинает их мерджить между собой.
Этого достаточно. Понятно?
У нас какая-то ошибка. Почему у нас Merge A и B? Это же два массива.
А у нас должно быть функция 1 указательный массив и еще и n.
Merge. Подожди.
А, все, понял.
Merge. Вот, таким образом получается Merge Sort.
А если у нас нечетная качество элементов, то у нас Merge Sort B и n пополам. Там же не n пополам элементов.
А какая разница? У меня Merge работает для любых количеств.
Я поняла. Мы вторым аргументом передам количество элементов. Правильно?
Хорошо. Здесь тогда должно быть n равно 1 или n равно 0.
А, все, понятно. Хорошо.
Я правильно понимаю, что мы не передаем в Merge размеры A и B в силу того, что это псевдокод?
Да.
Вообще, по-хорошему, как это должно делаться?
То есть, смотрите, если вы говорите о коде на плюсах, то этот код должен выглядеть как передача массива.
И здесь должна быть левая граница, правая граница и серединка.
И вот здесь Merge должен использовать левую половину, а левую часть серединку и от серединки до правой части ровно как в Quick Sort.
То есть, вы как будто бы не делите массив, не присваиваете A и B.
Но я в силу того, что мы Merge так написали, я уже так пишу. Понятно?
Все.
Вот, но это не все про Merge Sort. Смотрите, обладает ли Merge вообще стабильностью?
Давайте вернемся чуть-чуть назад.
Обладает ли этот Merge стабильностью?
Да.
Потому что мы сначала, в случае равенства, мы сначала записываем элементы из A, а потом из B.
Да, то есть, смотрите, у нас элементы A идут до B, поэтому вот это условие – это гарантия стабильности.
Стабильность.
А стабильность нам гарантирует, когда мы будем, ну, не знаю, сортировать какие-нибудь определенные структуры и так далее.
Это достаточно полезно, чтобы вот если вы напишете меньше, то это будет уже нестабильная сортировка.
Поэтому за этим иногда надо следить, какие вы знаки им напишете, иначе будет все плохо. Понятно?
Так, смотрите, давайте сделаем еще один пяти-минутный, нет, давайте десяти-минутный перерыв.
Вот, ну, то есть, мы как бы час и перерыв десять минуток, потому что иначе вы на следующем умрете.
Что нас ожидает? Давайте я просто сразу скажу.
Нас ожидает все также сортировка, но следующего вида.
Это in-place merge, который вам придется реализовать потом в домашке точно где-нибудь.
In-place merge, что он сделает?
In-place merge будет мержить без дополнительной памяти только рекурсия.
Только рекурсия ему понадобится, то есть там будет память немного по-другому.
И еще важный момент, как вы думаете, вот количество свопов когда-нибудь играет очень важную роль?
А в чем?
Ну, вот у нас есть сортировки, к примеру.
У нас есть сортировки, играет ли там важную роль количество свопов, или это просто так, типа вы придумали и все?
Ну, количество свопов, оно достаточно сильно влияет на симпозицию.
Да, оно может этот коэффициент очень сильно влиять.
И вот один раз была задачка на межнаре такая, что там нужно было то ли отсортировать две структуры,
но там надо было это применить, короче.
И по итогу все пытались сделать какую-то быструю сортировку, а нужен был коэффициент.
Сортировку выбором надо было сделать.
Она работает за N квадрат, но зато у нее свопов всего N.
Это немного, потому что N лог N не заходило.
Вот, так что аккуратнее с тем, когда вы какую сортировку применяете.
Даже квадратичные сортировки очень полезны.
Окей.
Так.
Вот.
Вот.
Так что аккуратнее с тем, когда вы какую сортировку применяете.
Даже квадратичные сортировки очень полезны.
Окей.
Так.
Смотрите, одно важное уточнение.
То, что я написал про Merge Sort, вообще как он выглядит.
Там есть одна фатальная ошибка.
Если кто-то из вас ее поймет, то все будет хорошо, когда вы будете ее писать.
Какая ошибка?
Я сделаю вам подсказку.
То есть смотрите, Merge сам по себе написанный.
Но Merge Sort возвращает у нас с вами так-то то, как он должен выглядеть.
Какую-то цель.
Вот.
И надо понять, куда его вставить.
Вот это вам небольшое задание надо.
Относительно того, как это сделать.
На следующей лекции по алгоритму я, естественно, вам напишу, как это должно выглядеть.
Но подумайте, пожалуйста, самостоятельно.
Вот на тем, как нам совместить вообще Merge.
А теперь поехали говорить про In-Place Merge.
Что такое In-Place Merge?
Мы с вами говорили, что In-Place Sort это та, которая не требует памяти в каком-то хранилище.
То есть просто не выделяется память просто так.
То есть там не нужно создавать массив C, в котором мы будем класть результат.
Как же это делать?
Ну, здесь важный момент.
Давайте мы, во-первых, предположим, что у нас есть, как в обычном Merge, два отсортированных кусочка.
Два отсортированных кусочка.
А и Б.
Но в памяти они идут в подряд.
То есть если мы возьмем, к примеру, A объединенное с B, то они идут за другом.
Элементы я имею в виду.
Это хорошо и это классно, потому что, в принципе, мы так Merge и делали.
Но смотрите, что я имею в виду.
В обычном Merge мы строили вот такую вот штуку.
Но согласитесь, никто мне не мешал вот этот пятый элемент с девятым, например, совместить и оставить третий без всего.
То есть мы могли совмещать вообще любые два элемента.
Сейчас я буду требовать то, что мы будем Merge именно соседние элементы, а потом соседние массивы, а потом соседние еще другие массивы и так далее.
Это важно понимать, что вот именно в этом будет заключаться первое свойство Inplace Merge Short.
Мы хотим, чтобы эти элементы шли друг за другом.
Это первое, что нам необходимо.
Второе, что нам нужно.
Нам нужно понимать, что такое Lower Bound, я его напишу LB, и Upper Bound.
Скажите, точнее так, поднимите руку, тут есть такая функция, или напишите плюсик в чат те, кому не знакома бинарный поиск.
Бинарный поиск.
Понял.
Не знаком.
Не знаком.
Видимо все плюсики ставят здесь, потому что знакомы, или представляют, что это.
Но я сейчас расскажу.
Смотрите, что касается бинарного поиска.
Бинарный поиск.
Представьте, у меня есть отсортированный массив.
1, 3, 4, 6, 8.
И мне нужно найти 6 в этом массиве.
Как бинпоиск работает?
Я сейчас объясняю просто сам алгоритм, не пишу его псевдокод, он не очень сложный, я думаю, вы справитесь.
Мы берем средний элемент, так как массив отсортирован уже.
Мы берем средний элемент и смотрим, если он больше нашего элемента, который мы ищем, то мы идем влево, потому что левее находятся все элементы меньше.
Если он больше, чем элемент в серединке, то мы идем вправо.
И рассматриваем уже эту часть.
Первый у меня такой массив.
1, 3, 4, 6, 8.
6 больше 4.
Поэтому я рассматриваю только оставшуюся часть.
Оставшуюся часть у меня выглядит следующим образом.
Это просто 6 и 8.
В зависимости от того, как у вас написан бинпоиск, у вас может быть указатель либо на 6, либо на 8.
Но если на 8, то 8 больше 6.
Я ищу 6.
8 больше 6.
Поэтому я иду левее.
И у меня остается только кусочек из 6.
И таким образом я нашел этот элемент.
Lower bound и upper bound от X.
Что это такое?
Lower bound от X это...
Кто-то подключается, кто-то отключается, что такое?
Lower bound от X это у нас...
Первый элемент, который больше либо равен X.
Первый элемент, который больше либо равен X.
А вот upper bound это у нас...
Что?
Это первый элемент, строго больше X.
Ну или давайте так, сейчас я скажу.
Строго больше X.
Ну вообще, наверное, да.
Давайте так.
Первый элемент...
Больше либо равен X или меньше?
Да, больше либо равен X.
То есть смотрите, что такое upper bound и lower bound в моем случае.
Давайте я это сотру пример.
Сейчас нарисую другой.
С одинаковыми какими-то элементами.
Представьте следующее.
У меня есть массив 1, 3, 3, 3, 4, 6, 8.
Так вот lower bound от трех это вот это.
Upper bound от трех это вот это.
Lower bound, upper bound.
Это понятно?
Это понятно?
Ну то есть...
А разве не меньше либо равен?
Первый элемент, где именно?
Ты о чем?
Lower bound, наверное.
А, lower bound?
Да, хорошо, меньше либо равен.
Окей.
Сейчас, момент.
Тогда это последний элемент.
Если таким образом...
А, нет.
Нет, все правильно.
Это первый элемент больше либо равный.
Вы меня запутали.
Если такого элемента нет, то upper bound и lower bound совпадают.
Всегда.
Обычно вы обозначили один раз AP, а другой раз AB.
Ой, upper bound, потому что я не умею в английском.
Иногда.
А upper bound и lower bound.
Это пока понятно?
Да.
Чудно.
Следующий момент.
И теперь мы можем переходить вообще к in-place merger.
У нас с вами есть два отсортированных куска.
A и отсортированный B.
В этом случае мы с вами говорим о следующем.
Что in-place merge должен как-то соединить эти кусочки внутри себя
и построить это C просто внутри.
То есть не заводя новую память, не заводя что-либо,
он должен внутри себя сделать.
Для этого мы сделаем следующий шаг.
Давайте я их рядышком нарисую, будет получше.
Вот так.
Они два отсортированных куска.
Я выбираю в центре какой-то X.
То есть X это у меня A от там N пополам в центре.
Обозначу вот этот кусок это C1, вот этот кусок это C2.
Они оба размером.
Что еще раз?
N это размер A.
N это размер A, да.
Давайте напишу это.
N это у меня вот такой кусочек, и здесь у меня еще один кусочек.
N пополам, извините.
N пополам.
И здесь N пополам.
А дальше я выбираю границу, которая у меня является lower bound от X.
И обозначаю эти кусочки как C1 и C3 и C4.
Хорошо.
Но смотрите, я все это могу делать при каких-то условиях.
То есть мне нужны, вы понимаете, что у нас будет рекурсия впереди, я думаю.
А это означает, что нам понадобится понять, ой, понадобится какое-то остановочное действие.
Например, следующее, что если у меня A или B пустой, то у меня уже отсортировано все как надо?
Ну, наверное, да.
Ну, не наверное, а да.
Представьте, у меня A пустой, а B уже отсортирован.
Логично, что у нас оно отсортировано, правда?
То есть я напишу здесь следующее, что если у меня размер A равен нулю или размер B равен нулю, то в этом случае я могу сделать сектор.
И все.
Как бы мне больше ничего не беспокоит.
А lower bound, он первый элемент больше X где?
То есть почему он находится в месте?
Он меньше, он больше либо равен X.
В B.
Я ищу такой игрок.
Больше или равен?
А, в B?
В B, в B.
Вот.
Следующий момент.
Смотрите, если у меня A равно одному или, ой, и B равно одному, то есть если и в A, и в B находится один элемент, тогда что я делаю?
Я просто проверяю.
Если у меня A равен нулю или B равен нулю, то в этом случае я могу сделать сектор.
То есть еще раз.
Если у меня просто есть два элемента типа 5 и 3, то в этом случае я могу сделать сектор.
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
А нулевое?
И B?
Нулевое?
То есть еще раз, если у меня просто есть два элемента типа 5 и 3, вот они оба отсортированы.
Вот это A, вот это B.
То я их должен просто принять местами и получить 3, 5.
Это тоже отсортированный кусок.
Вот.
Для этого я их свапаю между собой и все, и тоже возвращаю.
То есть пишу тоже.
Вот это я назову все условия окончания рекурсии, самые
простые случаи с вами рассмотреть рекурсии.
Вот, а теперь, а теперь мы с вами будем рассматривать следующее.
Следующий момент. Пусть, пусть. У меня A больше, чем B. Ну,
больше либо равен. Тогда я как раз смотрю на те разделения, которые до этого делал.
Давайте я здесь еще раз повторю. У меня есть A, у меня есть B. Я здесь убираю элемент X,
здесь убираю lower bound, lower bound от X и обозначаю C1, C2, C3, C4. Смотрите,
о чем, что из этого я могу сказать. Если у меня X это просто серединка, то у меня здесь все
элементы меньше либо равны X, правильно? А здесь больше либо равны X. Но я это могу
гарантировать. C3 это lower bound, значит все элементы здесь меньше XA. Почему? Потому что X, ну,
потому что граница у нас lower bound. Lower bound это первый из больше либо равных X.
Понятно? Что люди начинают, как будто бы все плохо. Так,
окей. У нас здесь меньше X. И у нас есть C4. И здесь, когда мы выбрали lower bound, у нас здесь будет
больше либо равно XA. Ну, потому что lower bound убирается, там все элементы больше либо равны.
Чисто из выбора lower bound. Таким образом у нас получились вот такие вот штуки. Вот.
А более формально давайте сейчас это напишем. Что у нас X равно A от N. Ну, давайте я напишу
NA делить на 2, чтобы вы понимали, что это количество элементов AA. Вот. А C1 это у нас
A от нуля до NA пополам. C2 это у нас A от NA пополам до NA минус 1. Давайте напишу просто до
NA и не возьму этот отрезок. C3 это у нас B от нуля до lower bound X. И C4 это у нас B от lower bound X до
количество элементов B. Получается lower bound возвращает ID. Ну, это необходимые элементы.
Индекс, да. Ну, то есть в этом плане индекс, да. Правда. Вот. Таким образом мы с вами поучили.
А теперь давайте сделаем следующее. Мы хотим так, чтобы у нас все работало, все было классно,
все было хорошо, к примеру. Вот. И нам необходимо это как-то отсортировать внутри себя, чтобы мы
могли рекурсивно вызывать in-place merge. Для этого нам необходимо сделать какие-то кусочки,
плюс-минус равные, которые будут разделены чем-то. Это будет очень похоже на quicksort. Почему? Потому
что я хочу поменять местами, поменять местами C2 и C4. Что получу тогда в этом случае? Я получу
следующее. У меня есть C1, у меня есть C2, у меня есть C3 и у меня есть C4. В этом случае у меня C1
меньше либо равен XA, C2 меньше XA, C3 больше либо равен XA, C4 больше либо равен XA.
А почему C2 меньше XA? Ой, извините, здесь C3, а здесь C2. Так. Так лучше? А, сейчас. Да,
теперь да. Вот. Теперь все правильно. И смотрите, мы по факту разделили их от нашего XA. Просто вот
здесь вот у нас встал на место наш X. Какой-то. Потому что он находится в самом начале C2. Все. То
есть нам необходимо дописать вот этот псевдокод. Некий свод. Код C2 и C3. А почему X может быть в
конце C1? Мы так выбрали. Ну, смотри, вот C2, это A, N, A пополам. Начинать. А то, что вы нарисовали,
это будет типа A отсортированное или пока еще нет? Вот просто. Ну, вот он нарисовал C11, C3, C2, C4.
Так, конечно же, отсортированное. А почему, если C2 все больше либо равно X и C4 больше,
то как из этого следует, что там отсортированное? Смотри, A массив отсортированный. Ага. C1 и C2 это
часть A. Идущий подряд. Да? Да. Ну, значит, C2 отсортированное. Ну да, но почему не может быть
такое, что какой-то элемент из C2 больше, чем какой-то элемент из C4? Это может быть. Я не говорю о том,
что X стал в серединку. Плюс-минус. Да, нам хочется. Вот. А после этого, после этого я рекурсивно
вызову мой in place merge от C1, C3. То есть вот от этих двух кусочков. И вызову in place merge
от C2 и C4. От этих вот кусочков. Можно вопрос? Как мы выбираем AX? Это первый элемент? То есть это
первый такой элемент? То есть для чего мы пишем, что C1 меньше и равно X? Мы выбираем не первый X?
Мы выбираем просто средний элемент из A. А, просто средний. Просто средний. Просто серединка. Вот у
меня в начале написано X равно A от NA делить пополам. Это просто какой-то средний элемент. И смотрите,
когда я буду вызывать вот такую вот внутреннюю, так сказать, буду вызывать эту рекурсию, у меня
есть условия остановки, которые вот были написаны вот здесь. Ой, не вот здесь. Что у меня как-то он
припрыгивает очень сильно. Я, видимо, плохо сделал. Ладно. Условия окончания рекурсии. То есть мы в
начале пишем условия окончания рекурсии, а после этого тот, ту штуку, которую мы сделали вот здесь.
А можете объяснить, что происходит с вот этим X, который мы нашли?
Вот мы нашли. А почему он не будет относиться к C2? Нет, X у нас относится к C2. Но еще раз,
ты вряд ли сможешь выбрать серединку так, что это будет первый элемент. Правда?
Он всегда понял, почему она останется на месте. Ну, то есть у нас C1 не двигается. C1 остается на
месте всегда. У нас между собой меняется C2 и C3. Зачем это вообще делается? Вот у нас было два
сортированных, а получилось и ничего не отсортировано. Почему ничего не отсортировано?
Мы с вами и косетили в середину относительно в этой X. Слева все меньше либо равно, справа все
больше либо равно. Не напоминаешь? Все понятно. Окей, хорошо. И теперь мы вызываем рекурсивно от двух
других частей, но это все равно merge sort. Почему это merge? Потому что у нас есть остановка рекурсии,
похожая именно на слоп, где просто наслопаются два элемента. Мы с вами merge кусочки, маленькие,
маленькие кусочки. Мы с вами просто берем и merge между собой для того, чтобы получить что-то
что-то большое и отсортированное. Мы начинаем с малого. Что такое swap C2 и C3? Как происходит
вообще сортировка? Точнее их просто swap между собой. Представьте, у меня есть массив A, к нему
прибавлен массив B. И вот мне нужно сделать так, чтобы у меня получился массив B, а здесь массив A.
Как это можно легко сделать? Кто-нибудь знает? Может как-то через указатель? Нет, здесь не надо
прям через указатель. Есть вопрос. Зачем мы вообще делаем swap C2 и C3, если мы вызываем
in-place merge C1-C3 и C2-C4? Потому что эти куски у тебя in-place merge работает только если кусочки
находятся друг за другом. У нас будет условие, что они отсортированы и находятся друг за другом.
Помнишь? Или нет? Меня спущает молчание. Я что-то напутал с этими штуками. В следующий раз
буду лучше делать. У нас было два отсортированных куска и они идут друг за другом. Это было важное
свойство. Мы не можем делать in-place merge для кусочков, которые не друг за дружкой,
поэтому нам нужно поменять C2 и C3. Обязательно. Смотрите. Здесь же наверное реверс кусочков,
а потом реверс всего массива. Можно так, а можно сначала реверс всего массива, а потом реверс
кусочков. Смотрите. Первое решение всего этого – это реверс. Если это массив C, то это будет
реверс. Давайте не C, а D, а то вы запутаетесь. Реверс D. Это пишется достаточно легко. Я думаю,
вы понимаете, как до серединки дойти и свопать между собой. После этого реверс A и реверс B. Что
под этим подразумевается? У меня есть A1, A2. Давайте на каком-нибудь простом примере. Лучше
с чиселками. Думаю, так легче запоминается. У меня есть 3, 5, 6, 8, 1, 4, 3. Мне нужно получить
1, 4, 3, 3, 5, 8, 3, 5, 6, 8. Я просто взял пока рандомные кусочки, просто как своп работает.
Я реверсю все, получаю 3, 4, 1, 3, 4, 1, 8, 6, 5, 8, 3. После этого я должен зареверсить
каждый из кусочков. Я сначала реверсю A, это получаю 3, 6, 5, 8, и реверсю B – это 1,
3, 1, 4, 3. Получил. Понятно, как это работает? Там разве не 3, 5, 6? Как осуществляется реверс?
3, 5, 6, 8. Как осуществляется реверс? 4 int i равное 0, i меньше чем n пополам,
plus plus i swap a, i, t, i, a, i, t, n, minus i, minus 1. Есть ли еще какие-то вопросы?
Да, можете еще раз повторить, почему C2 и C3 мы не можем in-place merge местами поменять,
почему нам нужен именно этот swap. Так, в смысле еще раз, почему C2 и C3…
C3 мы именно swap'ом, а не in-place merge. А как мы можем in-place merge поставить его в нужное место?
Смотрите, еще раз, у нас есть 4 кусочка. Нужно C3 и C2 поменять местами,
чтобы слева стояло все меньше либо равное x, справа все больше либо равное x.
Это непонятно или понятно? Нет, это понятно. Но мы же знаем границы C2 и C3.
А, типа как swap сделать эти кусочки? Нет, swap – это я понял, вы сейчас говорили
про реверс. А почему нельзя in-place merge сделать от C2 и C3?
Еще раз, in-place merge работает для кусочков, которые идут друг за другом.
Да, они идут друг за другом. У нас массива IBA идут друг за другом,
C23 отсортированы. В чем проблема? Почему нельзя in-place merge применить? Правда?
Давайте еще раз, я не понял вопроса тогда. Смотрите, у нас A и B идут друг за другом.
Да. Получается C3 идет за C2.
Да. Вот, у нас C2 и C3 тоже в принципе отсортированы.
Да. Часть A и B. Почему нельзя
использовать in-place merge для C2 и C3, чтобы поменять их местами?
Он отсортирует C2 и C3, где C3 – это все меньше X, а C2 – это все больше либо равно X.
А зачем, если ты точно знаешь, что C3 меньше X, а C2 больше либо равно X?
Ну, то есть ты точно знаешь, что C2 больше либо равно X, а C3 меньше?
Ты знаешь, что они не на своих местах. Да, и поэтому я in-place merge как раз
поставлю все элементы C3 влево, а C2 вправо. А кто сказал, что ты их сможешь поставить in-place merge?
Ну, типа, либо я не понимаю, что ты именно хочешь сделать, либо зачем нам нужно вызывать
in-place merge C2-C3, в принципе, если мы точно уверены, что в C2 больше либо равно X, в C3 меньше X.
Мы их так поменяем местами. Мы отсортируем часть C2-C3.
Для того, чтобы менять местами, типа, in-place merge, для чего мы делаем?
Потому что мы не знаем, как внутри что устроено. Мы не представляем, у нас нет представления об этом.
C2 и C3, по факту, мы знаем об их представлении, что один меньше X, а другой больше либо равно X.
И C2 еще и начинается с X. Да, я на основе этого как раз делаю вывод,
что все элементы C3 встанут влево, а C2 вправо от X.
А если ты будешь делать in-place merge? Или просто merge?
Какой ты будешь делать там? От C2 и C3.
In-place merge? Да, они идут друг за другом, сами по себе отсортированы.
У нас все условия для in-place merge, они соблюдены.
Получается, результатом как раз будет C3 и C2 наоборот.
Объясни мне зачем? Сколько работает?
Вы поменять их местами. Вместо swap сделать in-place merge.
Ты понимаешь, сколько работает in-place merge? Нет еще.
Но в этом вся проблема. Ты очень сильно загрубишь еще больше свою программу. Почему?
Потому что in-place merge и так работает за NLogin.
Все, вот теперь понятно. Swap нужен для корридии.
Работает за OTN. Понятно? Ну типа понятно почему за OTN хотя бы.
Вот. Поэтому здесь мы используем эту штуку.
In-place merge. Смотрите. То есть он для A и B. Что? Еще раз вопрос.
Мы low bound и up bound реализуем через bin поиск. Да.
Но это обычный bin поиск, просто там надо понять меньше или больше уровня.
Ну, меньше или меньше уровня. Ну, типа такого.
Вопрос связанный с этим. А если мы не найдем такой элемент LBX?
То есть, например, вот у нас есть массив, состоящий из девятки, а другой массив условно 1, 2, 3.
Так еще раз. Говорят, что lower bound это первый элемент, который больше либо равен XA.
Ну, мы его ищем в B. Да.
Ну, вот если у нас, например, массив A состоит только из девяти, и X по сути это 9.
А в B у нас только элементы, например, только три штуки. 1, 2, 3.
Тогда B пустое, C4 пустое. Да, тогда.
А когда ты будешь объединять C2 и C4, у тебя есть условие окончания рекурсии.
Что если один из них пуст, то мы возвращаемся.
Все хорошо. Спасибо.
Так, смотрите, за сколько работает merge sort. Давайте с этим разберемся.
Ну, достаточно быстро мы на самом деле с этим разберемся.
Смотрите, A больше либо равно B. То есть, у A как минимум N пополам элементов от всего этого массивчика.
Правильно? Ну, это логичная вывод.
Это означает, что у нас в C1 и в C2 не больше, чем N пополам элементов.
То есть, тут больше либо равно N пополам. И тут больше либо равно N пополам.
Н на 4. N это всего. A и B.
Вот так напишу.
А условие, что A больше либо равняется B, мы сами такое условие создаем?
Да, это одно из условий. Я сейчас объясню, что делать, если A меньше бы. Я объясню.
Вот, таким образом, C1 и C2 больше либо равно N на 4.
То есть, вот этот кусочек больше либо равен, чем N на 4.
Больше либо равен, чем N на 4.
Этот C2 больше либо равен N на 4.
Но в то же время B меньше, чем N пополам.
Поэтому, в общем, вот эта вот штука, вот эта, она меньше либо равна, чем 3N на 4.
И вот эта вот штука тоже меньше либо равна, чем 3N на 4.
То есть, размер каждой из частей уменьшается, как минимум, в 4 третьих раз.
Понятно, почему 3N на 4?
То есть, это N на 4 плюс N пополам.
Ну, мы прям так грубо оценили.
Потому что B у нас меньше, чем N пополам.
N пополам плюс N на 4. 3N на 4.
То есть, каждый раз мы уменьшаем эти части в 4 третьих раз.
То есть, давайте напишу.
Размер.
Размер. Каждый.
Каждый.
Из частей.
Из частей.
В.
Ну, уменьшается.
Давайте так.
Не более.
3 четвертых N.
Следовательно.
Уменьшается.
Уменьшается.
В 4 третьих.
Следовательно.
А. Глубина рекурсии.
Глубина.
Рекурсии.
Рекурсии.
А. Меньше либо равна, чем логариф.
4 третьих от N.
N это длина нашего массивчика.
Вместе A и B.
Вот. То есть, у нас.
Уменьшается в 4 третьих.
Это что и по сравнению с чем?
Уменьшается в 4 третьих.
Вот этот кусок.
C1, C3.
Который у нас новый получился.
По сравнению со всем.
Понятно?
То есть, мы каждый раз уменьшаем, уменьшаем.
Меньше либо равно, чем логариф.
От N по основанию 4 третьих.
Таким образом.
Мы говорим, что у нас глубина рекурсии.
Меньше, чем логариф.
Следовательно.
Память на рекурсе.
Память.
На рекурсе.
Рекурсию.
О большое от логарифа.
N.
Ну, не важно какое основание для нас.
Вот.
А время работы.
Это O от N,
лог N.
Одного N place.
Merge.
А теперь.
Очень важный вопрос.
За сколько работает тогда сортировка?
А?
За N лог N.
Тогда.
Merge.
Работает.
Работает.
За.
O от N логариф.
Квадрат N.
Почему?
Еще раз.
У нас количество уровней.
Логариф N.
Одна, один merge работает
за N лог N.
Ну, типа, вот именно внутри
merge, вот то, что у нас есть N place.
Это означает, что они
просто перемножаются.
То есть N лог N на лог N.
Получается N лог квадрат N.
Это N place merge.
То есть у нас памяти не требуется дополнительно.
И это также стабильная
сортировка. Потому что мы все время
от X.
Смотрите, от X.
У нас слева мы выбрали
X в C1 и так
все, что было меньше либо равно X находилось
слева от X.
Правда? Ну, типа, даже если там был
X еще где-то, то он и так находился
слева первоначально.
В C2
оно все так же
сохранило порядок. И C4
все так же больше либо равно X, а также
находится правее X.
То есть стабильность
сохранена, потому что в C3 все меньше.
Это уже что-то
другое и нам не важно для стабильности.
Для стабильности нам нужно смотреть только
на равные кусочки.
На swap только 1,
C2 и C3.
В C3 нету равных
X. Вот и все.
Таким образом у нас с вами получается
вот такая вот штука, что мы
получили с вами in-place merge
in-place merge sort
за N лог квадрат N.
Так, пожалуйста, вот
первый логарифм, это глубина?
Глубина
in-place merge. Смотрите,
in-place merge это сам по себе merge.
То есть у нас был merge,
который работал за O от N,
правильно?
И получалось, что вся сортировка работает
за N лог N.
А теперь у нас вместо merge
in-place merge, который работает за N
лог N.
А сортировка работает за N
лог квадрат N.
Что касается типа
что будет если
у нас A меньше, чем B?
Если у нас A меньше, чем B,
то нам необходимо lower bound
заменить на upper bound
заменить на upper bound
после чего
и A и B
поменять местами. Все.
Ну, я имею ввиду вот здесь вот.
То есть мы будем
выбирать X из B
и вот здесь вот
ставить upper bound.
Почему так?
Ну, вы просто распишите
опять меньше X, больше X и так далее
и вы поймете когда что.
Также нужно будет свапнуть C23.
Вот.
То есть вы выберите X в B
X выберите в B
а upper bound будет
делить A.
И он будет делить
как вам необходимо.
Понятно?
Вот.
Таким образом мы с вами разобрали
A и B мы меняем местами с open.
Да, то есть A и B сами по себе
не меняются с точки зрения вот этих
треугольничков. Но они вот здесь
меняются, грубо говоря.
Еще раз upper bound, lower bound
мы как выбираем тогда?
Вместо lower bound у вас будет upper bound.
То есть вы имеете ввиду
C1, C2, там будет B от A?
Да, да, да.
Ну, то есть смотрите, здесь немножко
поменяется местами. Тут будет C1, C2
здесь будет C3, C4
то есть здесь важно просто
с этими индексами поиграться правильно.
По факту надо будет
менять все так же серединку.
Вот и все.
То есть вам необходимо
здесь будет чуть-чуть подумать
как это дописать. Понятно?
Вот.
Смотрите. Одни
самых сложных сортировок по факту
закончились, осталась только одна
впереди. Вот.
И это всего лишь hip sort
который достаточно понятный
и
приятный, назовем это так.
Вот. Я думаю вам больше
понравится, чем вот in-place merge.
Но in-place merge
очень полезная функция. Почему?
Смотрите, она меньше всего
облигает память от себя
и
с точки зрения того,
как она может объединять одновременно
какие-то файлики и так далее, она очень
хорошо заходит с большими данными.
И вообще
merge sort, если вы
когда-нибудь
на самом деле, скорее всего, в следующем
семестре, когда вам разрешат
это сделать, вы посмотрите
на функцию std
stable
sort, стабильная
сортировка. Она реализована
по факту на merge sort.
И там сказано, причем вот
внутри std сказано, что
если
у вас
позволяет
память
ну дополнительно o от n памяти
то работает за
n log n
если не позволяет
то за n log квадрат n
то есть там внутри реализованы как раз
эти две сортировки merge sort
и
ну и обычный
inplace merge
sort
вот таким образом у нас получается две такие вот вещи
это понятно?
все ясно?
тогда смотрите
просто еще раз повторить
почему merge работает
за o от n log квадрат
ну то есть почему там логарифмы
перемножаются, а они складываются
то есть почему они
складываются
еще раз inplace merge
он
merge между собой два массива
да?
да
сколько таких раз он это
делает? Он делает это логарифм раз?
да
ну значит n log n умножить на log n
сколько раз он делает это
чудо
вот
а обычный merge работает за n поэтому
там n log n
там же глубина n log n
и merge работает за то
вот таким образом у нас с вами получилась
вот такая вот
интересная сортировка
вот
следующее занятие будет
посвящено astdsort
на чем реализована astdsort, часть всего реализована
quicksort
так что считайте, что вы
пишете стдшную библиотеку
это очень круто, это очень классно
вот будете этим
заниматься как раз в первом
домашнем задании по алгоритму
а следующее задание будет через неделю
получается? Ну примерно так
потому что четвертая там вроде как праздник
да, у нас четвертого нет
лекции, это правда
четвертая праздник поэтому
лекции не будет, будет 11
значит
вот, мы с вами рассмотрим сортировки
будем уже переходить к другим темам
потому что мы как-то застряли
ну много их
вот
и впереди нас ждут
еще интересней темы
на самом деле, все будет очень хорошо
так что
всем спасибо, всем удачи
и до встречи
