Давайте сейчас быстренько, прежде чем мы вернёмся к
DFS-у.
Да, по DFS-у у нас всё равно много разговоров будет.
Значит, начнём быстренько с DP по профилю.
Ну, в чём заключается идея?
Да, идея у нас заключается в том, что одно из состояний
динамики является под множество какого-то множества.
То есть, у нас есть какая-то мистическая вселенная, там,
ну, какая-то там вселенная на N объектах, N обычно
не превосходит, ну, я не знаю, там, 15, там, 20, в редких
случаях там 24 бывает, вот, и очень хочется что-то делать.
Ну, классическая задача, которую нельзя не рассмотреть,
это, конечно, задача о Гамильтоновом пути.
Ну, по идее, задача едва ли не N по полу, по-моему,
N по полу, если я не ошибаюсь.
Вот.
Но, соответственно, N у нас маленькая, поэтому мы
себе даже усложним немножко жизнь.
Мы хотим, мы скажем, что веса, что ребра у нас взвешенные
и нам очень-очень-очень хочется не просто найти
Гамильтонов путь, но Гамильтонов путь минимального веса.
Так, что такое Гамильтонов путь вопросов не вызывает.
Так, ну ладно, для наших телезрителей на всякий
случай скажем, что Гамильтонов путь это путь, который проходит
по каждой вершине ровно один раз.
Вот.
Соответственно.
Вот.
Значит, хорошо.
Значит, как же нам это сделать?
Ну, здесь оказывается такая классическая, то есть классическая
динамика.
Здесь оказывается какая?
Ну, заметим, что, то есть как мы будем все это строить?
Мы будем как-то набирать этот путь, то есть набирая
по вершинке, по вершинке, по вершинке, по вершинке
и смотреть, сколько, какой у нас сейчас вес.
Но заметим, что когда мы пытаемся добавить в пути
следующую вершину, что нам надо знать?
Ну, нам надо знать все предыдущие, но заметим, что конкретный
порядок нам особо не принципиален.
Нам надо знать, в общем-то, только последнюю.
В результате получается классическая динамика
DP, маск, В.
Ну вот.
Ну, как кодировать под множество битвами, числами с вами
не надо обсуждать, потому что мы уже там Фенлика
обсудили.
А до этого еще что-то обсудили там, по-моему.
Вот, кстати, у нас в первом семестре тоже что-то с масками
было, по-моему.
Нет?
Ну, неважно.
Вот.
А, ну, да, да, да, да, да, то есть много чего было,
а много чего не было.
Ну вот.
Но маски были.
Так что тут комментарии, думаю, излишни.
Вот.
Ну вот.
Ну и получается DP от Масковая, то есть вы собрали путь,
который проходит ровно по одному разу в точности
вот этим вершинам и заканчивается в вершине В, и DP это минимальный
вес, за который можно этого достичь.
В результате, в результате эту DP можно искать, ну сами
выбираете, можно искать DP, можно делать DP назад, можно
делать DP вперед.
Вот.
И получается, ну вот, и получается, что там получается,
ну переходов у нас, ну вот, вот там асимптотика получается,
если вы храните матрицы смежности, граф получается
два в степени N на N квадрат, или, на самом деле, можно
аккуратно доказать, что если списком смежности,
то получается два в степени N на M, ну, потому что при
каждой фиксированной маске вы, по сути, перебираете
в серебра.
Вот.
Ну, формально там M плюс N, но если вы хотите, но как
бы если M меньше чем, меньше чем N минус 1, то вы можете
сразу сказать, что Гамильтонного пути нету.
Вот.
Вот.
Вот.
Ну, вот эта вот классика есть, там есть, собственно,
и другое, ну думаю, ну вот.
Ну вот.
Так, ладно, только на всякий случай спрошу, может, я
просто слишком быстро говорю, и так, поднимите руки,
кто когда-нибудь вообще писал в своей жизни DP на
подмазках в том или ином виде.
Вот.
Так, ну поэтому я и сказал, да, на всякий случай, да.
Нет, вообще, в будущем, честно говоря, вообще мысли, что,
по-моему, да, прежде чем начинать семестр, надо просто
эту вот анкету аналогичную Лошевскую пропускать и
думать вообще просто какие, какие темы надо проговаривать,
какие можно лучше предположить, что все знают, и лучше
заняться деревом NMD Boss, например.
Ну или там, я не знаю.
Ну просто надо, что это вот тут.
А то, знаете, просто если много времени тратить на
то, что все и так знают, то как бы это будет немножко
грустно.
Вот.
Значит, далее.
Значит, это у нас DP на подмазках.
Это у нас это.
Вот.
Ну, теперь, соответственно, немножко про DP по профилю.
Так.
Значит, что такое DP по профилю?
Ну, на самом деле DP по профилю это, можно сказать, частный
случай DP на подмазках.
А можно даже сказать, что это оно есть.
Потому что задача, которую мы будем сейчас некоторое
время долго и успешно решать, звучит так.
Жила была табличка.
Есть табличка NM.
Пум-пум, пум-пум-пум.
Там пум, соответственно, пум.
Пум-пум.
Во.
Значит, надо замастить эту табличку доминожками.
Ну, доминожка, это такая штучка.
Там два на один.
Каждая доминожка, вы должны замастить две соседние
перебру клетки.
Там, естественно, там всякие.
В общем, каждая доминожка должна замастеть именно
две клетки.
То есть там она высовываться за пределы не должна.
Пересекаться доминожки тоже не должны.
И вот сразу первая задача уровня ноль.
Можно ли это сделать, да или нет?
Если хотя бы одна четная, то можно.
Ну, да.
Да, какой-то вариант.
Боже упаси.
Да, это называется, да.
Задача из цикла, да, чем вы младше и менее искушены
в математике, тем быстрее вы правильно ответите
на этот вопрос.
Да.
Потому что ответ предельно простой.
Если одна из этих измерений четна, то вы можете вдоль
этого измерения просто положить доминожки и, собственно,
все заполнить.
Вот.
А если NM оба нечетные, то в принципе не судьба,
потому что количество клеток нечетные.
Тут все просто.
Вот.
Но сложнее начинается, когда вам гарантируется,
что NM допустим четна, и вас спрашивают, а сколько
способов замастить вообще?
Вот.
Да.
То есть это можно свести задачу количества порсочей
в дудольном графе, конечно, да.
Ну, а что?
Да, известная в скопках нет задача.
Ну да, там, хотя нет, кто-то там можно что-то делать,
там начинаются какие-то безобразия типа матрица
Тата там или что-то еще в этом роде.
Ой.
Ну ладно, не будем так себе усложнять жизнь.
Вот.
Так что вот.
Значит, что у нас получается теперь?
Вот.
Значит, как будем замастять?
Ну, классический способ здесь говорить так.
Значит, идем слева направо и замастяем по столбцу.
Вот давайте будем, да, ну естественно, да, скажем
про ограничения.
Обычно в такой задаче у нас там N какое-то небольшое.
Ну, дальше как повезет.
То есть допустим вот, допустим N у нас совсем до пяти
и M до стоточки.
Тогда идея такая.
На каждом шаге мы, значит, замастяем очередной столбец.
То есть вот, например, сейчас мы говорим, мы замастили
два столбца, и вот мы хотим замастить третий.
Но мы себе разрешаем, что у нас слева в него что-то торчит.
То есть на текущем шаге наша задача замастить третий столбец.
То есть сделать, ну вот, то есть положить доминожки так,
чтобы доминожка там, каждая доминожка лежала хотя бы
одной клеточкой в этом столбце, и при этом все, все клеточки были заняты.
Ну, можно перебрать все способы это сделать.
Вот.
Ну и, например, вот один из способов вот такой.
Вот, отлично.
Все, тут замастили, теперь так.
Следующий шаг может быть вот такой.
То есть теперь мы дошли до четвертого столбца, замастяем его.
Ну, например, вот так.
Там могли по-другому.
Теперь пятый столбец пустой.
Ну, такое тоже бывает.
А бывает и обратная ситуация, когда...
Наоборот, смотрите, то есть выяснилось, что торчащие доминожки
замастяют все.
Такое тоже бывает.
Ну, значит, тогда этот столбец мы замастяем триверально.
Ну и так далее.
Вот.
И в результате возникает естественная динамика.
ДП, то есть такая.
ДП получается, значит, и масковая.
То есть это называется...
Прошли.
То есть прошли из столбцов.
Вот, я даже так и буду писать.
Там, соответственно, в и плюс первый
первый
ведет
торчат
доминожки, маски, маски.
Вот эти вот.
Вот, понятно, да?
Вот.
Вот.
Ну, что можно сделать?
Значит, ну теперь возникает вопрос.
Как эту динамику улучшать?
Ну, ответ на задачу.
Где у нас, кстати, ответ на задачу?
ДП, Н, ноль.
Ну, по сути, да.
Нет, почему нет?
Именно ДП...
Нет, ДП, Н, ноль, да.
Астактовое состояние ДП от ноль-ноль равно 1.
То есть мы прошли ноль столбцов, и в первый столбец ничего не торчит.
Вот.
Но теперь возникает вопрос.
Как же это вычислять?
Ну, самый тупой способ, конечно.
Ну, я сейчас не буду полный код писать.
Но можно писать так.
То есть 4и.
Ну, то есть там понятно, что ДП, ноль-ноль равно 1, естественно.
Вот.
Значит, 4и от 1 до н.
Пишем, 4маск равно от 0 до 2 в степени n-1.
Значит, дальше, 4маск штрих равно от 0 до 2n-1.
Значит, соответственно, если маски не пересек...
То есть если...
Ну вот.
Если эти маски могут быть соседними...
Ну, как-нибудь за ОАТ мы, наверное, как-нибудь поймем, могут ли эти маски быть соседними.
То, соответственно, пишем там ДП, ит масковое.
Там плюс равно ДП, а ты минус 1.
Маск штрихное.
Вот.
То есть можно вот уже так написать.
Вот.
Спрашивается...
Ну вот.
За какой симпатикой это будет работать?
Ну, не на n квадрата, n на m.
Да, тут вот m, я ошибся.
Вот.
Ну, базовая версия такая.
То есть самую первую задачу так, в принципе, уже можно написать.
Кодик, кстати, получится простой.
А, впрочем, поднимите руки, кто такой изракод уже писал.
Так.
Такой или его аналог по симпатичным узорам?
Потому что мы предположим, что мы за линию проверяем.
Вот.
Да, но теперь давайте поехали.
Без чего можно обойтись?
Без умножения на n.
n или m?
n.
Так, а как обойтись без обнажения на n?
Ну, потому что у нас понятно, если на следующем столбце какие-то торчат, то это только горизонтальные в текущем столбце.
Ну, я скажу так, это необходимо, но недостаточно.
Мне кажется, мы можем предпочитать все.
Да, вот погодите, тут как бы разные оптимизации.
Потому что если хочется не домножать на n, то можно заметить, что функция maybe neighboring никак не зависит от того, при каком им мы ее вычисляем.
И в принципе, и на самом деле действительно можно сделать какой-то там предподсчет.
Там какой-нибудь m, b, n.
Только я уже пишу на этот раз маском а штрих.
Но, правда, его придется еще предпочитать.
А умножение на n можно заменить налогами?
Сейчас, дойдем.
Ну, там разные веточки, но мы сейчас дойдем, не волнуйтесь.
Все сделаем.
For mask, for mask штрих равно от нуля до 2 в степени n-1.
Значит, там m, b, n от маском а штрих равно maybe neighboring.
Burying.
От соответственно, mask.
Вот.
Ну, тут все просто.
Так, давайте.
В принципе, да.
Вот это уже действительно приятная штука.
То есть теперь у нас асимптотика превращается.
Теперь она становится 2 в степени 2n на n плюс n.
Это приятнее.
Вот.
То есть на самом деле это чуть-чуть расширяет нам возможности.
Потому что там, скажем так, n уже может быть даже не 5, а вполне себе 10.
Это же.
Так.
Что еще можно оптимизировать?
Да.
Ну да.
Одна из читерских оптимизаций заключается в том, что можно заметить, что для того, чтобы маска и баш-штрих были совместимы,
необходимо, чтобы маск и макс-штрих не пересекались.
Вот.
Как минимум.
Но спрашивается, насколько это прооптимизирует?
Ну да.
Да, классия нот.
Так, мы на пути, мы обсуждали уже эту идею или еще нет?
Ну, давайте быстро обсудим, да.
То есть, ну, в принципе, да.
У вас могла быть даже задача по комбинаторике.
Сколько существует пар масочек из n, которые не пересекаются?
Но ответ про спойлеры.
Оказывается, их ровно 3 в степени n.
В чем там разные доказательства бывают?
Потому что кто-то, на самом деле, там честно посчитал какую-то сумму цешек и получился бином ньютона.
Да, вот именно.
Но на самом деле, да, можно увидеть это и сильно проще, конечно.
Вот.
Потому что что такое не пересекающиеся маски?
Не пересекающиеся маски – это когда у нас действительно маска…
То есть, когда у нас на каждой позиции стоит либо 0,0, либо 1,0, либо 0,1.
А 1,1 не стоит.
То есть, получается, на каждой позиции у вас три варианта того, что там может стоять.
Итого получается 3 в степени n вариантов.
Остается только мелкий вопрос, а как это адекватно перебирать?
Потому что…
Ну, то есть, конечно, если бы у вас…
То есть, проблема в том, что, конечно, мы бы за…
На самом деле, мог бы быть такой чит, смотрите, какой.
То есть, может быть, чит, что вы тут не просто предпочитываете не в матрице смежности, а в списке смежности.
То есть, для каждой маски насчитываете, какие маски вообще валидны.
И тогда у вас… Ну вот.
И что тогда получается?
Тогда получается, что вы там будете работать за от реального количества переходов, а их не более чем 3 в степени n.
И в результате, если сделать список смежности, то получается там от 2 в степени 2n на n.
Но этот предпочет никуда не девается пока, да?
Плюс, ну, уже что-то не более чем 3 в степени n на m.
Так, ну, в принципе, тоже неплохо.
А зачем мы предпочитывали?
Вот. Ну, потому что мы пока еще не научили перебирать непересекающиеся маски быстро.
Пока не научились, конечно.
Но, конечно же, на самом деле, если ваша задача просто перебирать непересекающиеся маски, то это достаточно простая задача.
Ну, точнее так, потому что она сводится к одной известной задаче.
Задача называется перебирать под маски.
Вот. А вы уж перебирали под маски?
Нет, ну, баллики мы там в ФТ занимались.
Может, и этим тоже.
Сейчас, а зачем нам перебирать под маски?
Мы не можем просто, ну вот, перебирать не маски, а до 3 в степени n и просто динамику в первую очередь.
Слушайте, какой хороший чит.
Давайте вместо вот этого форика, вместо этих двух фориков реально переберем числа до 3 в степени n,
каждый из них распарсим и создадим по нему две динамики, то есть две масочки.
И еще не забудем, то есть maybe neighboring все равно придется вставлять, если что.
Но, на самом деле, в этом необходимости нет.
Ну, точнее так, так тоже можно, но это будет сильно сложнее, чем то, что я сейчас вам предложу.
Потому что, на самом деле, заклинание перебора будет звучать так.
Значит, перебираем маску.
Теперь говорим, значит, ввожу переменную in в маск равно 2 в степени n минус 1 минус маск.
Ну, короче, я инвертировал маску, да?
Теперь я должен перебрать все ее под маски.
Сделаю я это весьма простым способом.
Значит, for.
Сделаю я это весьма простым способом.
Значит, for.
Маск штрих равно in в маск.
Маск штрих больше нуля.
Вот.
Ну, можно так написать.
Маск штрих равно
маск штрих минус 1 and in в маск.
Все.
Значит, мистический факт.
Я утверждаю, что вот этот for переберет в точности не пустые под маски in в маска.
Вот что.
Можно оставить в качестве упражнения.
Почему?
Чего?
Можно?
Так, все.
Можно, да?
Ну ладно.
Оставим в качестве упражнения.
На экзамене у кого-нибудь спрошу.
Вот.
Ну, оговоримся, что здесь придется вам тогда все-таки запускать функцию maybe neighbouring.
Ну, вот.
Вот.
Ну, оговоримся, что здесь придется вам тогда все-таки запускать функцию maybe neighbouring.
Вот.
И еще заметим, что нулевую маску придется обработать отдельно.
Вот.
Значит, соответственно.
Ну, на то это и нулевая, потому что в этот for она как-то не власть.
Но, тем не менее, вот, то есть, конечно, да, ну, в этом случае вам, конечно, не потребуется никакой вот этот вот for.
То есть, и тогда уже действительно все это мы тоже выкидываем, выкидываем.
В общем, короче говоря, 3 в степени n получается на nm получается.
Хотя, с другой стороны, с maybe neighbouring можно было бы уже и разобраться.
Потому что, на самом деле, я утверждаю, что maybe neighbouring легко реализовать.
С очень маленьким предподсчетом можно сделать так, чтобы он работал за вот единицы практически.
Maybe neighbouring все, что проверяет, что у нас между двумя выбираниями четное число клеточек или что?
Нет.
Но нет, он проверяет, что можно ли взять маску, там, можно ли взять маску маск-штрих и замастить ее полностью так, чтобы в следующую столбец толчала ровно маск.
Ну, это практически эквалентно тому, что, во-первых, верно лишь, то есть, если вот писать эту функцию, там bool maybe neighbouring.
То есть, соответственно, если я буду перебирать там, соответственно, маск-штрих и обязательно n, то первое, что я проверю, пересекаются ли в маске.
То есть, просто я скажу, что если окажется, что они пересекаются, то есть, маск and маск-штрих, то я просто сразу выбрасываю с криком false.
А в противном случае, что я делаю?
Да, в противном случае я пишу некоторый код за линию, который говорит мне, return may, ну, я его называю вот так, may zeros be filled by, ну, допустим, vertical до минус, я не знаю.
Вот. Ну, то есть, передаю я туда вот эту вот маску, их вот, маск или маск-штрих и обязательно n, потому что я как бы не знаю, сколько там нулей в конце, поэтому я передаю все.
Ну, просто в чем фишка? Фишка заключается в том, что я передаю в эту функцию всего два в степени n вариантов масочек и я их могу предподсчитать.
То есть, в принципе, предподсчет этой функции он работает за два в степени n.
И после этого тогда функция maybe neighboring презаразно работает за у от единицы и на самом деле, конечно, никакого n тут нет уже давно.
Вот. Получается вот такой красивый три в степени n на m.
Можно уже заметить, что, в общем, n можно уже и не десятки, там уже и, ну, так, уже аккуратненько, ну, 12 точно, а так можно уже аккуратно и в сторону 15.
Посматривать дальше.
Впрочем, есть, ну, впрочем, на самом деле есть, конечно, там, конечно, разные варианты.
Есть какая нот.
То есть, на самом деле дальше ограничения могут просто пойти в две стороны.
Ну, есть, конечно, классическая ситуация, вот у вас тоже, ну, обе, там, классическая ситуация, когда, наоборот, n у вас все еще не превосходит 6, но зато m не превосходит 10.
В сотой.
Ну, ответ, естественно, по какой-нибудь простому модулю.
Или бывает еще, чтоб совсем было быстро, давайте сделаем это по модулю два в тридцать второго, ой.
Ну, типа, чтобы вы там просто делаете, да, делайте все вычления в Oneside Pint и не парьтесь.
Ну, ой, ну, как сказать, эта задача появилась до появления фурьерского модуля, так что.
Ой, Господи.
Главное, самое страшное, что, знаете, самое смешное, что если говорить об истории, то, по-моему, задача симпатичной узоры появилась просто едва ли не на в кашпе 2003 года.
Нет, а то и рай, там где-то вот 2003 или совсем вот какого-то лохматого года.
Ей решила только команда Пяти Митричева.
Да, тогда это, естественно, не было теории, которую все знают.
То есть, это сейчас как бы тоже такие базовые вещи.
Вот.
Получается, надо ДП изучать.
Ну.
Ну, ДП всегда надо изучать, да.
Самое время тащить в кошки.
Ну, там, нет, ну, там, правда, все аккуратно, это все достаточно быстро развивалось, потому что если вы там будете решать, я не знаю, может вам когда-нибудь надо на кубок МВТ дать финал 2000 года.
Там такая замечательная личная тренировка.
В чем-то такая блицевая такая немножко тренировочка, там, по-моему, только одна задача реально сложная, потому что где-то там будет просто едва ли не упр...
Просто там будет, просто буквально будет задача, напишите Флойда.
Флойда.
Ну, практически.
То есть, там, не, придумывать ничего не надо.
То есть, там вот уже, то есть, 2008 там, скажем, финал, ну, мы какие-то старые финалы вот решали, но вот очень старые, мы вот порешали двухтысячные.
Вот впечатление вот такое.
Там, скажем, 2008 это вот там, там уже нормальные задачи.
Ну, вот уже.
Ну, уже более похожие на современные.
Вот.
Так что.
Финал 2000 года, да.
Осталось только его найти.
СПС?
Нет, ну, в коже 2000 года тоже прикольно, но я боюсь, там все задачи вы уже давно знаете, потому что они уже раздеребанины по домашним заданиям.
Вот.
Ну, там те же симпатичные узоры, например.
Вот.
Не, ну, в конце концов, кто решал вот первый контест Танкевича, вот тоже можете убедиться, действительно, что, что было в 2002 году сложным контестом, то сейчас это как бы уже учебные, там какие-то простые учебные задачи.
Ну, относительно.
Вот.
Так вот, ну, давайте скажем, как решается задача в таких ограничениях?
Ну, в таких, в таких ограничениях, оказывается, у нас есть матрицы.
Потому что вот это вот, там, на этот раз вот эту матрицу, maybe neighboring на самом деле можно интерпретировать как матрицу, то есть если сказать, что у нас есть вот такая, такая целая матрица mbn от нуля до 2 в степени n-1 и от нуля до 2 в степени n-1, то можно заметить следующий приятный факт.
Что если я выпишу в таблицу такой dp и плюс первое, то есть я выпишу такой в столбец там 2 в степени значений динамик прификсированном i, то я могу заметить маленький приятный момент.
Что i плюс первый столбец я могу получить как матрицу mbn, домноженную на такой же столбец dp и того.
Вот, согласны?
Ну там, в общем случае с точностью доинверсии, да, но, хотя в данном случае матрица симметричная, поэтому не принципиально.
Вот. То есть к чему нас это приводит?
То есть к чему нас это приводит? Это нас приводит к тому, что вот если я вот обзову вот эту штуку dp и плюс первое, то тогда я могу обнаружить, что dpmt это что такое?
Это матрица наша в степени m умножить на dp нулевое.
Все, что вам останется, это с помощью быстрого возведения в степень вывести матрицу в степень.
Что получится?
Вот. Ну получится там асимптотика.
Ну то есть получается, что в таком варианте асимптотика может получиться за o от.
Ну, возведение матрицы в степени оно конечно, то есть умножение матрицы у нас это 2 в степени 3n получается.
Но зато вместо m у вас лога и получается адекватно.
Но это конечно работает только при очень маленьком n.
Потому что скажем при n равно 12 вам это к сожалению не поможет.
Потому что кто-то упихивает дальше.
Вот у вас будет домашнее задание, в котором например у вас размер таблички, произведение таблички может быть до 300.
Но при этом нет никаких ограничений на минимум.
То есть может быть табличка там скажем 17 на 17.
Ну это там макстест практически в этой задаче.
Вот. И тогда замечаем, что там допустим если у нас вот представить себе n равно m равно 17, то у нас проблемы.
Потому что это естественно не работает, 3 в степени n у нас тоже не устраивает.
Потому что это уже 3 в степени 17.
Это у нас что такое?
Это у нас 243 в кубе и еще на 9.
Ну там, то есть это пока еще в ТЛ, ну вот.
Ну то есть так, это на самом деле, ну то есть там да.
То есть какая-то там если будет то пожрана застава какая-то откровенная.
Потому что 243 в кубе это сколько у нас?
Ну это получается там наверное 9-10 миллионов уже где-то.
Если домножить еще на 9, то это уже там.
3 в 17 это 1 и 3 на 10 в 8.
А, спасибо.
Вот. Да.
Это само ток 3 в степени.
Домножить еще на 17, но как бы ТЛ там.
При всем том, что как вы наверное знаете, что действительно константа у этих решений прям муа.
Просто одна из лучших вообще во всем спортивном программировании.
Потому что, заметим да, что тут как бы у вас только сложение.
Ну то есть вам нужно делать сложение по модулю, но если вы избавитесь от процентиков, там совсем летать будет.
Но тем не менее там 17 на 17, скорее всего там тот ТЛ, который хочется не упихнется.
Вот.
Но оказывается есть тоже на самом деле весьма неожиданная техника.
Причем очень забавно, то есть техника нот.
То есть на самом деле код получится еще более маленький.
Так, техника называется, сейчас мы будем писать ДП по изломанному профилю.
Так, ну-ка кто знает что такое ДП по изломанному профилю?
Так кто его когда-нибудь писал?
Ага, так уже, так уже чуть меньше.
Так, ну ладно.
Что?
Ну да, ну да.
Ну мало ли, окей.
Я вот это слушал, но забыл вообще.
Ну вот, нет, сейчас давайте, вот сейчас быстренько вспомню.
Думал, что понял, а начал писать, понял, что не понял.
Ну сейчас.
А, правильно.
Я окончательно понял, когда написал.
Ну да, да, да.
А потом задумался, почему оно работает, и не понял.
Я понял, ладно.
Ну вот, ну, ой да.
Ну да, да, да, да.
Ну давайте таких фасот.
Ну вот, да.
Ну значит идея здесь оказывается достаточно простой.
То есть идея будет в том, что откуда у нас проблемы.
То есть отчасти одно из узких мест предыдущего решения было в том, что у нас переходов из там и этого столбства в ИТ плюс первый столбец очень много.
Вот.
Теперь мы сделаем так, что может состояние у нас будет побольше, зато переходов будет мало.
Вот.
Идея будет заключаться в том, что мы теперь будем класть не прям по несколько доминошек, чтобы замастить прям целый столбец.
А будем класть по одной, потому что мы будем проходить по клеточкам вот в таком порядке.
И следить за тем, что и в каждый момент времени говорить, так, эта клеточка занята.
Если не занята, то быстренько чем-нибудь занять.
Положить доминошку там либо такую, либо такую.
То есть мы уже видите, так это будет так.
Так чем с этой клеточки?
Ну положим горизонтальную.
То мы идем дальше, положим в эту вертикальную.
Идем в эту.
Ой, она занята!
Так.
Сюда положим, например, горизонтальную, а здесь она без вариентов.
Так эта занята.
Сюда положим тоже горизонтальную.
Сюда, ну здесь тоже без вариентов.
Ой, занята, а recall занята.
Не занята, но без вариентов.
Вот, тут занято, тут занято, давайте наконец-то положим
вертикальную.
Так, тут занято, тут занято, тут не занято, значит тут
кладём вертикальную.
Вот, ну сейчас давайте так, тут кладём горизонтальную,
тут допустим кладём вертикальную, вот, тут кладём горизонтальную
и вот допустим, значит вот теперь пока остановимся.
Что мы на очередном шаге имеем?
Мы дошли, прошли какое-то количество клеточек.
Вот, и теперь мы знаем, что справа от этих клеточек
есть вот набор из N клеточек, которые заняты.
Вот они заняты, вот, которые заняты, то есть кто-то из
них занят, кто-то нет, потому что могут торчать до минушки.
Остальные клеточки точно тут не заняты, а эти все
заняты.
Вот, но эта информация, ну вот, ну вот идея
заключается в том, что давайте вот эту информацию
и хранить в масочке.
То есть вот эти клеточки так и перенумеруют, ну там
по-разному можно перенумеровать, там есть разные технологии.
Есть технология, когда мы перенумеруем клеточки
в соответствии с их строками и есть вариант, когда мы
будем нумеровать клеточки в соответствии, вот, начиная
просто вот с этой.
То есть типа я каждый раз хочу заместить именно
нулевую клеточку.
Вот, то есть можно вот так делать, это уже там на самом
деле на вкус и цвет.
Вот.
Значит, ну в чем теперь фишка?
Ну теперь фишка заключается в том, что у нас есть состояние
по сути dp, там допустим x, y, ну допустим вот пусть у
меня будет x здесь, y здесь, x, y и маск.
Вот.
И тогда получается, то есть это означает, допустим
это означает, что мы, ну вот, то есть хотим замастить
x и y.
Вот так.
Ну вот типа до нее все замастили и тарчат у нас вот ровно
маски вот этой маски.
Ну и как мы это делаем, ну заметим, что у нас замастить
эту клеточку всего два способа, либо положить, если она
занята как у нас, то переход в принципе один, а если она
не занята, то кладете либо горизонтальную доминожку
либо вертикальную доминожку и в общем-то все.
Вот.
И получается в результате, что да, состояние у нас
конечно стало больше, состояние стало два в степени n на
n на m, но зато и обрабатываете каждое состояние теперь
за o от единицы.
В результате получается совсем просто минималистическая
симпточка, которая просто в одну калитку выносит все,
что у вас было раньше.
Ну кроме, конечно, ситуации, когда тут логариф m и это
прям критично.
Вот.
Ну да, то есть вот, собственно, вот так, конечно, да, то есть
это вот при nm 300, конечно, это начинает летать.
Понятно?
Так, ладно, кто-то тут руки не подымал, так, надо ли
подробнее?
Вот.
Ну, видимо, не надо.
Окей, хорошо.
Значит, тогда можно, значит, можно наконец возвращаться
собственно к DFS.
Вот.
Да, мы наконец с вами в прошлый раз узнали, что такое DFS,
для этого нам потребовалось целых полтора семестра.
Ну, технология сложная, действительно.
Да, надо было к ней готовиться, там FFT изучать, да.
Чего?
Нет, это никак не связано, это просто вот, ну вот,
ну это сформулирует так, что просто это надо как-то
быстро закрыть, чтобы больше об этом уже не думать.
Ну да, было, да, хотя, видимо, в текущем расходу был вариант,
ой, Господи, давайте я лучше просто в экзамене вам билет
оставлю, а там, называется, там, тратить на это время
мы не будем.
Ну вот.
Нет, просто в DFS есть, на самом деле, на что потратить
время и на что, и что чуть-чуть проговорить.
Вот.
Потому что начнём мы, вот с чего, значит, начнём
мы, пожалуй, с деревьев всё-таки.
Вот.
Ну, потому что, значит, ну, ну, потому что по поводу
деревьев, ну, есть хотя бы самая первая задача.
Найти диаметр графа.
Так, ну-ка, поднимите руки, кто умеет искать диаметр
дерева?
Так.
Ну, вот.
Кто умеет искать диаметр дерева за линию?
Ну, мало ли.
А кто умеет доказывать ваш алгоритм?
Так, хорошо.
Какой алгоритм для начала?
Да, правильно, всё это подлянка, потому что если у вас задача
найти диаметр дерева, то есть, конечно, читерский
вариант сделать это через ДП на поддеревьях.
Ну, там запустим два ДФС.
В одном ДФС мы для каждой вершины посчитаем вот этот
максимальный путь от меня до какой-нибудь вершины
у меня в поддереве.
А потом после этого, а, может, даже не после этого,
а прямо в этот момент для каждой вершины говорить,
так, ну, наверное, как бы у каждого пути есть толца.
Да.
И для каждой, когда мы обсуждаем, думаем вершины, думаем,
так, значит, мне нужно пойти в два моих поддерева.
И там в каждом из них выбрать самую глубокую вершину.
Так, ну, отлично.
Так, давайте я переберу эти поддеревья.
То есть, из каждого из них там найду самую глубокую.
Их просуммирую.
Вот, типа, вариант делать диаметр.
То есть, в принципе, так можно.
Так, ну, и что?
Обривите руки, кто это реально когда-нибудь писал.
Ух ты.
Ох.
Ну, слушайте, поиск диаметра именно таким образом.
Нет, просто динамику на поддеревье я понимаю,
что вы писали в том или ином виде, да.
Вот.
Да, потому что, да, есть вот действительно такой чип.
Да, потому что такой чип есть, да, как всегда,
знаете, как всегда, да, он приятен тем, что он, конечно,
самодоказывающийся.
То есть, что вы пишете, то и очевидно,
тут в данном случае очевидно, что работает.
Но есть сильно более простой алгоритм.
Проще, чем вот это.
Проще, чем вот это.
Есть сильно более простой алгоритм.
Алгоритм звучит так.
Возьмем первую попавшуюся вершину,
запустим DFS
и найдем самую удаленную вершину от нее.
Вот.
Это была вершина А, это была вершина В.
Теперь возьмем вершину В.
Запустим DFS от вершины В.
И найдем тоже самую удаленную вершину.
Это будет вершина С.
Да, утверждение.
BC диаметр.
Вот.
Так, ну, поднимите руки, кто когда-нибудь писал такое.
Ну, это делается с двумя адресами.
Ну, чтоб он возвращал пару,
пару, типа, расстояния.
Два вызова одного DFS.
А, ну, понятно, что это два вызова одного DFS.
Естественно, да.
Написать нужно один DFS.
А, в этом смысле, да.
Вот.
Кто умеет доказывать этот алгоритм?
А, ну, вот мы и натулились на тему,
которую имеет смысл обсуждать на лекции.
Так вот.
На самом деле, нет.
Тут, на самом деле, важно уметь,
потому что, на самом деле, сейчас мы просто увидим,
поймем, кое-что важное эти дома деревья, на самом деле.
Вот 630.
Итак.
Ну, действительно так.
Ну, ладно, тут все знают, что такое диаметр.
Диаметр – это у нас максимальной длины простой путь в графе.
Или, что то же самое, расстояние
между двумя самыми удаленными вершинами.
А давайте, давайте рассмотрим.
А как устроено дерево с точки зрения этого?
То есть, на самом деле,
может быть, может и много.
Но давайте вот представим себе,
как может выглядеть дерево, у которого диаметр,
ну, например, 10.
Как оно выглядит?
Вот.
Так.
Ну, нет, это, ну, да.
Это реальный пример такого дерева.
Действительно, вот он, да. Просто бамбуча, да.
Но на этой бамбуче, наверное,
что-то еще висит.
Ну, вот, может быть, центральное
решение, сколько угодно
Ну, да.
Ну, да.
Вот, да.
Ну, на самом деле, смотрите, да, вот эту вершину,
середину диаметра, действительно, мы, кстати,
вполне официально назовем центр.
Вот. И теперь я утверждаю,
ну, да, действительно, заметим, что на нее
я могу вот такие диаметры от ветвлений
веса 5 навесить
сколько угодно.
Могу еще вот тут что-то сделать, вот так еще могу сделать.
То есть вот что-то такое,
тут еще вот такие, кстати, да, они там не обязаны
быть там какой-то такой глубины.
Вот так можно сделать.
Как угодно.
Вот. То есть все, что угодно можно сделать,
но есть маленький приятный нюанс.
Приятный нюанс
заключается в том,
что я утверждаю, что диаметр в графе может быть
сколько угодно,
а центр в графе,
а в центр дерева может быть только один.
Ну, при условии,
ладно, при условии,
ну, смотря как определять центр,
но в том определении, который я дам,
как бы центр один.
Вот так.
Чего?
Во, да, потому что я определю так.
Хорошо, хорошо.
Да, согласен.
Ну, хорошо, если у меня диаметр 9, то я диаметр объявлю
вот это центральное ребро.
То есть если диаметр 9,
то я объявляю ребро,
то есть ребро и соответствующие две вершины в центр.
А если у меня диаметр
четный, то я объявляю
центр центральной вершины.
Так вот, я утверждаю, что
центры от диаметров
не зависят. То есть дереве
может быть сколько угодно диаметров,
ну, там,
вплоть до тета от н квадрат,
но ровно один
центр.
Ну, в этом вроде вообще
просто верится.
Вот, то есть, ну да,
ну вот.
Ну, нам же доказать надо.
Ну, пусть положим, что их два.
Рассмотрим.
Рассмотрим.
У каждого из двух диаметров,
проходящих через центр.
Получим, чтобы у нас дина больше диаметра больше.
Ну, да,
то есть действительно, заметим, что рассмотрим,
то есть действительно, вот у нас есть центр у одного
диаметра. Допустим, что у другого диаметра
нашелся где-то там
другой центр.
Вот как-то вот так.
Тогда мы замечаем,
что в данном случае мы от этой вершины
можем пойти в две стороны
и уйти на расстояние пять.
Так давайте я просто пойду
по какому-то из путей не в сторону
центра.
Ну, как бы да, у него тут, я как бы
могу пойти,
есть одно направление в сторону
центра, есть остальные.
Но так как у меня есть два направления с пятеркой,
то я выбираю просто, хотя бы одно из них точно
ведет не в ту сторону.
Ну, так я тогда иду-иду-иду-иду-иду
и получаю больший диаметр.
Все.
Вывод.
Получается противоречие, значит, центр один.
То есть на самом деле все
диаметры базируются
на одном центре.
Но
аналогичным образом можно, кстати,
можно доказать, естественно, и в нечетных диаметрах,
что вот это центральное ребро
оно одно.
Других вариантов нет.
Вот.
То есть в принципе
что вам, то есть по сути,
что вам нужно, чтобы сгенерить дерево
диаметра десять? Вам нужно взять центр
и сгенерить там, ну вот,
и сгенерить несколько
поддеревьев, хотя бы два из которых
будут глубины пять. Все.
Но все эти, все деревья должны быть глубины
не более чем пять, но хотя бы два
из них должны этой глубины достигать.
Тогда это будет
дерево с диаметром десять.
Вот.
Это, собственно, вот такой вот важный момент.
Вот. Понятно?
Вот. Ну, исходя
такого понятия центр, теперь легко доказать
про то, что там
предложенный алгоритм диаметр так реально ищет.
Вот. Ну, потому что
заметьте маленький приятный факт.
Концом диаметра
является любая вершина
на расстоянии, ну, в нашем случае пять
от центра, правда?
Ну, потому что я могу пройти
до центра, а потом просто уйти
в направлении не в эту сторону,
в которую можно пройти по пять, а такое
точно существует, потому что хотя бы два есть.
Понимаете, да?
Вот. Понятно, о чем вы говорите, да?
То есть, скажем, вот там вот эту вершину взять,
я просто иду пум-пум-пум-пум-пум и иду вот сюда.
То есть, везде,
где я беру вершину не из этого
поддерева, я просто вот могу
дополнять диаметр так.
А если я беру вершину из этого поддерева, то я просто
ухожу вот туда наоборот.
Вот.
Ну, получается, более
этого там в принципе уже можно даже решать какую-нибудь
веселую задачу вида сколько диаметров в дереве.
Вот.
То есть, исходя из этого,
видите, да, то все достаточно просто.
Надо посчитать, значит, найти центр,
надо найти, значит,
вершины на расстоянии, там,
на нужном расстоянии количество вершин
и ответ этот будет C из этих вершин
по два, минус там сумма C-шек,
чтобы мы эти две вершины не взяли из одного
поддерева. Все. Получается
решение за линию.
Так, тут понятно, о чем речь?
Да, будет понятно. Вот.
Ну, а теперь, чтобы что, как доказать алгоритм
теперь про два диаметра?
То есть, про два DFS вот эти.
Ну, практически,
ну вот, ну да, идея, ну, во-первых, да,
то есть, для этого надо просто
доказать, что первая вершина, до которой мы дойдем,
это действительно вершина на расстоянии,
ну, в нашем случае, 5 от центра.
Вот. Но, действительно, давайте подумать,
что у нас это может быть?
Ну, давайте, вот это будет не 5, а мы это
будем называть все-таки N.
Значит, что это за самая удаленная
вершина?
Ну, а с два варианта.
Либо мы, соответственно, до центра вот тут у нас
AB, до центра не дошли,
и тогда у нас вот тут, то есть, до какой-то LCA
дошли, а потом ушли вниз. Но тогда у нас тут
ребер строго меньше, чем L, и тут
строго...
Ну, точнее так, здесь у нас
ребер строго меньше, чем
DIST, соответственно,
от, значит, A и центра,
и тут их строго меньше, чем L.
Вот. А если мы пойдем через
центр, то через центр мы можем
найти не более, чем DIST плюс L,
но DIST плюс L мы найти можем.
То есть, DIST A, значит,
вот это, и в какую-нибудь сторону
можно найти такое. Больше мы не найдем,
но заметим, что, ну, вот, то есть, получается,
максимальное расстояние будет ровно
такое, причем любая вершина на таком расстоянии
должна обладать вот таким свойством.
То есть, мы обязаны пройти через
центр и из этого центра уйти ровно на L,
потому что она меньше нам неинтересна.
Вот. То есть отсюда действительно
следует, что у нас эта
первая вершина, значит, соответственно,
она находится на расстоянии L от центра
и, получается, значит, из нее диаметра найти
можно. Вот, собственно, и доказательства,
ну, а попутно еще вот
пара интересных вот
хороших взглядов.
Вот.
То есть,
то есть, на самом деле, отсюда
можно вывести даже вообще весьма
неожиданную задачу.
Вот, если мы все-таки уже говорили про какие-то
НП полные задачи.
И вот, есть следующая задача.
Вот, изоморфизм графов.
О, да.
Нет, я, кстати, не уверен, что она, по-моему, она даже
не НП полная, кстати.
Что?
Ну, она, по-моему, какая-то там тоже из каких-то
серьезных классов, но не НП полная там, я не
помню.
Ну,
я вот не помню.
Ну, я не помню детали, но не важно.
В общем, была такая сложная задача.
Вот.
Значит,
то есть, соответственно, у нас тут
действительно есть какая-то вот НП полная
нот, то есть, какая-то вот
НП полнота.
Вот. Но, соответственно,
это если говорить об обычном графе.
Ну, там об обычном графе. То есть, там, то есть,
обычных графов.
Вот.
На самом деле, я утверждаю, что
вот, то есть, мы сейчас будем решать такую задачу
изоморфизм деревьев.
Значит, а именно
вот, а именно, то есть,
то есть, задача данных два дерева
надо проверить, изоморфны ли они.
То есть, можно ли там перенумеровать
в одном из них
вершины так, чтобы
деревья прям совпали в точности.
Как же это сделать?
Ну, идея оказывается такая. Во-первых,
основная идея заключается в том, что
центр у деревьев
один должен быть.
Ну, то есть, начнем с того,
что просто найдем у обоих деревьев
диаметры и центра.
Но если выяснить, что диаметры не совпадают,
то до свидания сразу.
Но если диаметры совпали,
то тогда,
давайте сейчас для простоты рассмотрим
ситуацию, когда у нас диаметр
оказался четен.
Тогда заметим, что центр у обоих деревьев
восстанавливается однозначно, и по изоморфизме
они должны наложиться друг на друга.
Правда?
Ну, тогда давайте подвесим
оба дерева за эти центры,
и
получим маленькую приятную вещь.
То есть, получим немножко
другую задачу.
Задача будет называться изоморфизм
подвешенных деревьев.
То есть, ситуация,
то есть, данные два подвешенных дерева,
изоморфны ли они, но в том плане,
что корень разрешаете переводить только в корень.
Понятно, да?
Ну, то есть, если диаметр
четный, то мы легко сводим задачу именно
к такой, но, правда, если он
нечетный, то тоже не проблема, потому что
то есть, это там
да
ну, можно, да, ну, там, да, там
два варианта могут, ну, в принципе, да.
То есть, самое тупое можно что сделать, это
взять эти центральные ребра и вставить
на них вот такую вершину, например.
Вот один из способов такой.
То есть, там, как угодно.
Итак, значит, данные два
подвешенных дерева, и нам
нужно понять, изоморфны ли
они.
Как же это сделать?
Да вот.
Ну, в принципе,
ну, если у нас задача просто это сделать хоть
как-то за полиномиальное время, чтобы убедить,
что эта задача там не НП какая-нибудь.
А мы не можем придумать какой-нибудь хэш подвешенный
дерева?
Ну, это хэш, это даже уже оптимизация.
Нет, в смысле, который
будет, честно
может
как-то не хэшами делать.
Ну,
на самом деле, да, но до этого надо дойти.
То есть, скажем так, кончится тем, что я
утверждаю, что ее можно решить Н лог
Н без хэшей.
Хотя, самое самое, что идея
останется, но как бы исчезнут
эти ваши рандомности какие-то
и возможности. И теоретическая
вероятность коллизий каких-то.
Ну, потому что что имеется в виду обычно под
решением с хэшами?
Под решением с хэшами может
иметься в виду следующее, да, то есть
как описать дерево. Да, вот как описать дерево.
Вот у вас есть дерево, да.
Мы можем, допустим, запустить
DFS и прям
честно, там, каждый, там
и честно его записывать. То есть, знаете, вот эти
через открывающие, закрывающие, открываются,
открываются, открываются, да.
Открывается,
значит, закрывается,
значит, там открывается, закрывается,
закрывается, закрывается, закрывается,
там что-то еще, пум-пум-пум-пум-пум,
пум-пум-пум. Вот можно так
описать, да.
Вот, но в принципе, ну правда, заметим,
что если я попереставляю под деревья,
то может получиться другая скопочная
последовательность, правда?
Может такое быть, да?
Ну, тогда у меня
будет,
будет, например, такая.
То есть, давайте я эти
скопочные последовательности буду
сортить.
Да, то есть, ну чтобы идентичность, я
буду все под деревья выписывать в
отсортированном, по,
например, длине, при равных длинах
лексикографически, соответственно,
там, в общем, короче,
по строкам.
Вот. Ну там я не буду говорить,
ну вот. И тогда у нас получается,
что каждое, каждое
поддерево, то есть,
то есть, по каждому поддереву соответствует
fierce такая строка. Причем, более
того, разные по изоморфности
деревья, то есть неизоморфным
деревьям соответствуют разные строки.
Понимаете, да?
Ну, в принципе, то есть, это уже,
то есть, ну, то есть, какой-то
полином, в принципе, уже, честно,
получили. Ну я
так в слету там можно бить квадрат там
это или куб там, вот, неважно.
Но, на самом деле, если вы приходите и говорите, что
я олимпиагик, я могу что-нибудь попихать, я могу вместо того,
чтобы хранить последовательность, значит, именно правильных
скопчатых последовательностей, я могу вместо этих правильных
скопчатых последовательностей хранить хэши.
Ну вот, ну могу же я у стройки хэш взять, правда?
Честное его величество хэш.
И тогда возникает, ну вот, ну возникает такая идея,
что, ну вот, тогда у меня будет идея, а давайте я буду упорядочивать эти строчки не по, значит,
литерографически, а просто по хэшу. Понятно, да? Вот. И тогда что у меня получится? Ну тогда,
значит, ну вот, но тогда единственное, ну вот, то тогда, значит, как тогда у нас будет решение
задачи устроено? Ну, заметим, что, ну вот, то есть хэш я так, а, ну в принципе, я могу вычислить,
вычислить на самом деле объявном виде хэш. А, ну в принципе, да, если я в каждой, значит, храню хэш
и еще сколько вершин, то тогда, получается, суммарно я потратил, то есть, то тогда, получается,
я все хэши честно вычислю за время, ну, заметим, что если я знаю хэши, знаю размеры строчек,
то я, в принципе, хэш могу вычислить честно. Правда у нас полиминальный хэш, да? Ну, потому что
здесь я беру, там, h1 умножить на, там, основание в степени v2 плюс h2, все это, там, ну, понятен
принцип, да? Вот. Значит, что будет, ну вот, но тогда, получается, я могу, получается, здесь,
тогда, прям эти хэши честно вычислить за время, получается, n log n. Ну, потому что я должен, там,
в каждой вершине еще что-то сортировать. И после этого, собственно, там, то есть, получается,
я должен насчитать хэш одного дерева, насчитать одного и выяснить, равны ли хэши. Но у этого
решения есть недостаток. Это хэши все-таки. То есть, может быть, случайная коллизия. А как ее избежать?
Вот. А оказывается, можно. То есть, на самом деле, сейчас я проделаю примерно то же самое, но никаких
хэшей не будет. Значит, смотрите, ведь дело в том, что, пока я запускаю ДФС в одном дереве,
потом в другом, я встречаю какие-то поддеревья. Этих поддеревьев у меня небольшое количество,
правда? Так вот, я буду пытаться делать следующее. Я буду говорить, каждое поддерево, которое я вижу,
я буду пытаться перенумеровать. Ну, в том плане, я вижу поддерево. Вот, допустим, я буду говорить так.
Вот я запустил ДФС, я тут вижу. Так, вижу поддерево из одной вершины. Я объявляю, что это поддерево,
это будет у меня такое поддерево номер ноль. Вот. Ну, потом пошел тут куда-нибудь еще. Тут тоже ноль.
Вот. Тут я вот пошел вот так-так. Тут я тоже вижу поддерево из одной вершины. Оно у меня уже было.
Это ноль. А теперь я вижу, что у меня поддерево, из которого у меня еще не было. Ну, что это за поддерево,
говорю я? Так, это поддерево, у которого у корня есть ровно один ребенок, и это
дерево номер ноль у меня такого дерева еще не было поэтому я говорю так у меня
есть поэтому я объявляю это дерево номер 1 то есть смотрите я буду записывать так
то есть я могу сказать что каждое дерево задается тем какие деревья висят
на корне правда то есть я буду вот так писать если на вершине ничего не висит
то это наверное будет наверное дерево номер ноль если висит одно дерево номер
ноль то значит это будет дерево номер один что я теперь вижу так теперь я
вижу что у меня здесь висит два ребенка с нулями и одна единица ну естественно
я тут ну то есть пишу 001 пишу что это у меня будет 2
вот понятно да вот тут у меня еще какой-то dfs значит он тут тоже куда-то
нас отправит то есть это 0 потому что тут детей нет значит тут у нас допустим пусть
будет 00 и тут видим все но тогда видим а мы объявляем что дерево у которого
значит есть два ребенка и оба нули такого не было а мы теперь заносим да
именно то есть по факту мы делаем мап из вектора интов в нты да естественно
все вектора в этом мапе должны быть отсортированы вот то есть вот таким вот
но то есть dfs будет работать так мы запустимся от под деревья получим их
номера вот там n1 n2 там n3 там и тогда ленка отсортируем их то есть вот скажем
что они вот такие и теперь просто лезем в мапчик честно говорим если такой вектор
уже есть значит там там написано написано какой номер и тут должен писать если
такого вектора нет значит честно вставляем понятна
так вот теперь давайте смотреть внимательно что может показаться что
действительно это громоздко ну потому что понятно ну то есть дальше решение
понятно да то есть мы запустим dfs от одного дерева в том не вне стирая мап
внимание не стирая мап мы запускаем такой же dfs от второго дерева ну как бы
если у центров получится при этом одинаковые номера но там если у корней
получится одинаковые номера значит мы победили логично да вот ну если нет то
нет или что для того чтобы те деревья которые под деревья которые мы уже
встречали в первом дереве там были записаны сюда и номировались дальше в
этом и смысл вот но теперь вот самая большая такая не самый не тривиальный
момент за какую 8 точку это работает вот может показаться что то есть
действительно кажется что это едва ли какой-то там страшно n квадрат лог n
почему потому что для каждой вершины мы берем там вектор размера n и пихая нод
и ищем его где-то в мапе да а в мапе мы делаем логариф мн сравнений каждый из
которых работает тоже за отн и получается н квадрат логен так ну во
первых мы хотим отказаться от хэшей а во вторых это позволил логарифом это
убьет логарифом но не н квадрат поэтому увы придется а хотя нет но то есть это
но то есть нет по факту на самом деле если вы делаете он ордерет мап это просто
другая реализация уже того что могли бы сделать и без этого то есть просто хэш
будет по-другому устроен но относительно нет а на самом деле идея такая на самом
деле заметим что ну n квадрат вот этот лог n который у нас получился да но
оценку здесь можно конечно оптимизировать
да потому почему потому что на самом деле можно заметить следующее что у нас
ни как далеко не каждый вектор будет размера n более того у нас вектора суммарно
имеют размер н даже n минус один правда ну некоторые из них пустые правда но
суммарно н минус вот но там вот это вот и тогда что получается но тогда я
утверждаю следующее что если вы в мапчер подсовываете вектор размера к то все
сравнения в мапе происходят за от как потому что даже если вы этот вектор
сравниваете с каким-то более длинным вектором то все равно больше чем от к
операции ты сравнение вам не надо правда потому что либо вы эти два указатель
дошли до конца к и тогда вы тут же сразу поняли ответ либо не дошли и тогда это
еще быстрее вот ну то есть единственное только надежда что мапчик наверно не
копирует ключи для того чтобы сравнивать но он их не копирует поэтому
спасибо ему за это ром хотя тут оговорка не копирует это потому что вы прям так
написали чтобы не копировал но на самом деле да потому что потому что в мапе там
на самом деле пара хранятся в виде констов поэтому хотя нет хотя это как раз на
ворот повод скопировать конечно но нет он конечно этого не делает он да
называется он не псих и абсолютно молодец вот но тогда получается что по
факту у вас асимптует скринен квадрат логен а тогда вы прибегает то есть
получается сумма по всем вершинам и тогда в каждой вершине сумма это то есть
длина вектора это степень вершины и все сравнения будут делаться за степень
вершины умножить на ну логарифм n потому что логарифм n размер мапа но
сумма всех степень в смысле в смысле количества детей ну там можно 1 плюс
конечно что честно было но заметим что сумма 1 плюс дегов это буквально 2 и
минус 1 на логен ну то есть короче-то это от н лога то есть отсюда следует что
а что оказывается этот алгоритм работает за н логен
нет на самом деле знаете еще в строчках у вас такая ситуация могла возникнуть
потому что например вот знаете бывает такая ситуация вот когда когда у вас
там какой-нибудь первое занятие набор там первая задача может быть такая
реализуйте сет строчек сет на уровне вставьте строчку удалите строчку скажите
есть ли такая строчка естественно есть очень большой соблазн возможно кто-то
из вас делал просто взять и сделать это через остд сет ну хотя бы попробовать а
вдруг и выясняется что это решение получает от ей я получал кто-нибудь
окей таким способом а тут все честные всем все борьбе с другой задачей добавить
строчку и найти катерик сихографическую а ну ордера да ну ордер это слава богу
хоть кат элемент за логарифом ищет но на самом деле а вот это вот это фактически
доказательства почему как бы ставка удаления и поиск такой строки на сад
то есть на самом деле работают за удобавливаемую ассимптутику которую не
так просто обвалить потому что по факту все вставки удаю потому что каждая вставка
удаления и проведет поиск строчки будут работать за авто в таком сете за длину
этой строчки на логарифом количество строчек так что на самом деле да то есть
там то есть надо про очень жесткие ограничения ставить что прямо работала
только линия интересно да нет ну это наверное возможно возможно но это больно
нет ну как сказать нет ну если прям совсем поставить речи не прям зажать тель прям
совсем то может быть и может да не на уборной не на сток константа чтобы она не
перешибала логарифом хотя там проблем хоть и там а хотя быть я там отдельная
подлянка будет еще в том что если что у вас как бы либо строчек много либо
строчки либо строчки то есть либо строчки длинные либо строчек много а и то и то
одновременно как-то будет плохо вот там просто если строчек мало то там может начаться вообще
едва ли не перебор в тупую может работать если неправильно тесты делать его так что там да то
есть если как то есть если копнуть то на самом то есть хотя полезно задачи в таких то таким
задачем тесты делать конечно столько много во строчках узнать и понять можно вот так что то
есть на самом деле тут еще вот такие интересные штуки есть так что вот так вот мы решаем из
маркфизом за н лога так то есть так как я уже сказал то есть без без всяких шей то есть это
прям предельно честное решение там можно ли решить эту задачу за линию я не знаю вот но
пока меня такой алгоритм метко тоже есть в общем-то пишется тоже не сложно есть ли тут какие-то
так
так вот
На самом деле, что еще нужно знать про дерево?
На самом деле центр, полезно помнить, что центр это не
единственная вершина, за которую можно подвесить
дерево.
Ну скажем так, то есть центр это не единственная в своем
роде вершина.
Вот так скажем.
Вот, потому что в некоторых случаях оказывается полезным
конечно найти, подвешивать дерево не за центр, а за
центруид.
Так, ну-ка внимание, вопрос, поднимите руки, кто знает,
что такое центруид.
Так, вот, так, уже что-то не 100% пошло, да.
Так, ну и ничего, сейчас все узнаете.
Да, по каким-то меркам это звать, а как вы все расвоиговали
без этого знания.
Так что, соответственно, что будет дальше?
Ну вот, значит, что такое центруид?
Значит, тут центруид, это такая вершина в дереве,
значит, тут рассмотрим какое-нибудь абсолютно произвольное
дерево.
Да, ну, наверное, нет нужды говорить, что мы рассматриваем
не двоичные деревья, а произвольные деревья, в принципе они
пока даже не обязательно подвешены.
Значит, если у этого дерева N-вершин, то центруид, это
такая вершина, что если ее удалить вместе с ее ребрами,
то дерево разобьется на компоненты связности,
каждая из которых по размеру не более чем N пополам.
Вот, то есть вот такая красота, N пополам, или не N пополам,
но N-N.
Вот, красота.
Ну, вот и крайний вопрос, а такая красота существует
вообще?
Вот, оказывается, существует, причем более того, есть
вполне себе конструктивный алгоритм, как ее найти.
Найти ее можно следующим образом, смотрите, берем,
подвешиваем дерево за первую попавшуюся вершину, да,
буквально первую попавшуюся, и запускаем DFS, запускаем
DFS, насчитываем СЗ.
Насчитали СЗ, пришли, значит, теперь смотрим, если у всех
детей СЗ меньше или равно чем N пополам, то, поздравляю,
мы попали сразу.
Но, нам, предположим, нам не повезло, но заметим,
что такой тяжелый ребенок ровно один, если он есть,
конечно.
Да, но мы это уже в Хавилайте обсуждали.
Хорошо, пойдем туда, посмотрим на его детей, ну вот, ну и
на детей его детей, соответственно, потому что смотрим, есть
или у него тяжелые дети, ну есть так, идем, идем,
идем, ну дети, конечно, тяжелые, но тяжесть постепенно уменьшается.
И вот, явно, наконец, в какой-то момент, то есть обязательно
наступит момент, когда вот у вершины СЗ больше, чем
N пополам, а у всех ее детей меньше либо равно, чем N пополам.
Рано или поздно такое наступит.
Я утверждаю, что это и есть центроид.
Почему?
Ну, потому что если мы удалим эту вершину, останутся дети,
на которых висит не более, чем N пополам, и останется
то, что сверху.
Но так как, что такое то, что сверху?
Это все без того, что висит на нас.
Но если на нас висит больше, чем N пополам, значит, без
нас меньше, чем N пополам.
Значит, ура, это и есть центроид.
Значит, получается два вывода.
А. Центроид существует.
Б.
Существует алгоритм, который за ОАТН его найдет.
Удобно, правда?
Вот.
Чего?
Так, вот возникает вопрос.
Единственен ли центроид?
Ну, вроде как, из этого жалко рифму, практически следует
доказательство единственности.
Да.
Нет.
Ну, смотрите, на самом деле, да.
Сразу высекает пример такой, что может быть вот такая
вот, собственно, такая вот бабочка.
Такая галстук бабочка.
То есть, такая два дерева размера N пополам, соединенные
ребром.
Тогда обе эти вершины являются центроидами.
Но сразу заметим, что никто, кроме них, центроидом
не является.
Ну, потому что, если я, скажем, возьму какую-нибудь
вершину здесь и отпилю ее, то в одном из-под деревьев
будет обязательно вот просто целая балалайка, вот типа
висящая на этом дереве.
А на этой балалайке N пополам плюс один вершин есть.
Понятно, да?
Вот.
Значит, в этом случае, то есть, да, может быть, когда
центроида два.
А может быть, может быть, когда центроида три, четыре,
девятнадцать.
Но тут все просто.
Да, пятьдесят семь, конечно.
Сто семьдесят девять, две тысячи семь там.
Ну и просто десять пятый, да.
Вот.
Нет, а на самом деле, смотрите, значит, тут помогает следующие
рассуждения.
Рассмотрим центроид.
Посмотрим под деревьем, на котором, на нем висят.
Если они все строго меньше, чем N пополам, то вариантов
нет.
Ну, потому что любую вершину из любого поддерева возьмем
и тогда, значит, получается, на ней будет висеть все
без этого поддерева.
А это уже больше, чем N пополам.
Плюс еще там, плюс еще кто-то.
Понимаете, да?
Может быть, кто-то.
Но если мы эту вершину выкинем, то да.
Но нам без нее уже плохо.
Вот.
И второй случай.
Если оказалось, что существует под деревьем пополам.
Ну, два поддерева размера N пополам существовать не
могут.
Вот.
Но что тогда?
Тогда мы замечаем, что вот этот случай просто,
на самом деле, это вот этот случай.
Вот.
То есть, просто на самом деле, мы просто берем вот
это вот, просто глобально объявляем, что это просто
ровная N пополам.
Все.
То есть, вывод опять тот же самый, да?
То есть, либо у нас центроид единственный, либо у нас
существует такое центроидное ребро.
Вот.
Вот.
Которое соединяет две половинки.
Ну, по размеру половинки.
Конечно, эти деревья, может быть, это бамбуча, а это
куча.
Вот.
Куча бамбуча.
Ой.
Как сложно.
Вот.
Так что вот такая вот приятная штука.
Такая вот приятная штука.
Вправивается.
Вправивается.
Что с ней делать?
Ну, на самом деле, с помощью уже центроида,
конечно,
можно забабахивать, конечно,
какие-нибудь решения, какие-нибудь задачи
в виде разделяй и властвуй.
Вот.
Разделяй и властвуй.
Ну, например, классическим примером
на разделяй и властвуй можно ввести такую задачу,
например.
Вот давайте так.
Сейчас я все это уберу.
Так.
Вот.
Хорошо.
Ну, разумеется.
Да.
Ну, да.
Знаете, как это?
Как это?
Да, да, да, да, да.
Как бы, да, задачи на дерево делятся
на два типа. В первых написано
дерево, а во вторых написано
называется дан связанный граф
с, там, n-1 вершина,
n-1 ребро.
Там условно, да.
Да.
Или между любыми двумя вершинами
ровно один путь, там еще можно, да.
Ладно, там много, там много типов,
но в общем...
Да, да, да, да, да.
Да.
Да, связанный граф
без циклов.
Да.
Ой.
Ой, ну, да, да, да, говорят, классический...
Да, классический пример.
Да, серый с 2009 года.
Как говорится, условие
жюри. Дан кактус.
Уложите его в квадрат 10 на 9.
Вот. Как говорится.
Ну, естественно, в условии задачи
официальном было написано другое.
Там было написано.
Называется был крыша.
Там что-то был крыша. Там на Новый год или День День
привезли n-компьютеров.
Они были соединены проводами.
И теперь эти компьютеры нужно установить.
Для этого есть огромный зал.
Там 10-9 на 10-9.
Естественно.
И их можно компьютер установить.
Ну, там не указано.
Не указано.
Все что угодно может быть.
Вот.
Каждый компьютер хочется установить какую-то точку.
Но при этом хочется, чтобы провода, конечно,
не путались.
Поэтому требуется, чтобы
все провода были прямые.
Ну, там их можно растягивать или сужать.
И при этом, чтобы эти провода
не пересекались и не касались, кроме как в вершинах.
Но при этом
при анализе
обнаружилось мистическое свойство.
То есть, видимо, сеть устроена
таким безопасным образом,
но ребро не лежит
более чем в одном простом цикле.
Вот.
Ну, и, собственно, была такая задача.
Ну, и, собственно, задача, короче, можно ли уложить...
Там, ну, и граф, естественно,
25 вершин. Можно ли его так уложить?
Если да, то расскажите как.
Ну, кстати, поднимите руки, кто решал
когда-нибудь такую задачу.
Ага. Ну, да, логично.
Ну, просто кто-то, может, проиграл в серии
9-го года, собственно.
Ну, вот я и рассказал,
куда она взялась, в общем-то.
Ой, нехорошая задача, я тогда на нее...
Ну, это был просто мой последний сервис.
Собственно, я на нее тогда 3,5 часа
убил.
Нет, ну, правда...
Слушай, и там...
То ты прикол, что нет.
Я прям... С начала контеста 3,5...
Нет, там было... Нет, в этом смысле
было забавно. Представьте еще в качестве
добивки, там еще, извините, оффлайн-тестирование было
полное. Вообще.
Нет, до 2010-го
года включительно на сервисе было
полностью оффлайн-тестирование. На самом
сервисе вы посылали, вас проверяли,
говорили, принято на проверку.
Все. Это все, что вы знали.
Вообще.
Да. Да.
Мы так жили, да.
Да, были
люди в наше время, да.
Не то, что...
Стрессы все писали, да.
Да, ну, и... Ну, я не писал.
А, ну, я поэтому на международный,
видимо, не попал, потому что я не писал
стрессы, да. А может, ну...
Ну, вот.
Да, правда, правда, правда думаешь, да.
Правда, нет, у меня нет, у меня в этом смысле
было эпическое достижение по официально
публикованной табличке, я в таблице был четвертое
место, но на международный меня не взяли.
Вот.
Нет, потому что это таблица...
Нет, но дело в том, что таблицу делал
просто по официальным данным, не завище от
джуристнарк, а он просто брал, собственно,
ну, там, типа, берем все контесты, суммируем все.
Ну, вот. А там, как бы,
а там Кирюхина Светкова,
наоборот, Кирюхин Светковый,
вот, да, наоборот. Это там они более
хитрые, они смотрели. Так, ну, во-первых, сервис мы
не учитываем. Так, почему? Ну, там
тупые задачи какие-то неправильные.
Там, ну, вот.
Так, ну, опять, выкинем развлекательный тур,
потому что там был один тур, типа, одна задача, напишите
стратегию игр в дурака.
Обычного подкидного.
Вот. И там турникчик устраивался.
Вот, да, было там такой турник,
что-то еще там было. Ну, вот. То есть, выкинем
это, выкинем это. Потом давайте
еще поанализируем там еще, кто там
больше задач на сотку сдал. В общем, посчитали,
посчитали, пришли к выводу, что
не я. Вот. Ну, там
в общем, какие-то такие тогда рассуждения были, не как
вот сейчас просто вот. Вот есть четыре
тура, кто их выиграл, тот и сборная Россия.
Вот. А
тогда вот было мутно. Но там
после этого там еще какие-то
скандалы были, потому что кто-то так тоже сильно
не понял, с какого перепугания
я вообще. Ну, вот.
Ну, вот.
Но в результате
соответственно, сейчас-то делается по-другому.
Но сейчас, я думаю, и фамилии
Кирюхин Светкова, и вам, собственно, ничего не говорят.
Светкова прославилась.
Ну, нет, она прославилась, но сейчас
она как бы к этому никакого отношения не имеет.
Ну, вот.
Ну, это другая история. Ладно.
Вот.
Ну, да, тут, конечно, если возвращаться к этой
задаче, да ладно, у меня основная проблема, что я писал
на Паскале, на Паскале я не умел делать там большой
стэк, поэтому пришлось написать не рекурсивный
ДФС.
Вот, внезапно у меня получилось.
Вот.
Но там, честно, форта нула, что там из застав
одна была халява совсем.
Вот. Ладно.
Так, все. Не будем зависать.
А будем рассматривать другую
задачу. Значит, задача теперь такая.
Дано дерево.
Ладно.
Ну, вот.
Значит, дано дерево.
Вот.
Вот.
Значит, дано какое-то дерево.
На ребрах написано какие-то числа.
Числа могут быть даже отрицательные, а также дано еще
мистическое число К.
Задача.
Сколько судьб?
Сколько судьб?
Сколько судьб?
Сколько судьб?
Задача.
Сколько существует путей
длины
ровно К?
Ну, как-то
поможет.
Но начнем не с этого.
Но начнем с того, что подвесим дерево
с какой-нибудь вершин.
И заметим, что пути бывают
двух типов, которые проходят через этот корень
и которые не проходят.
Давайте...
За какой этим точку мы можем найти количество путей
размера К,
которые проходят через этот...
через корень?
Да. А, ну если хэш-мапом, то да.
Количество путей
длины К.
Через центр.
Сейчас, ну да.
Но проходить их через корень.
За ОАТН без таких хочу.
Нет, у К дерево взвешенное, да?
А где?
Ну, тогда с кучей.
Да.
Ну, у каждого
ребра есть длина.
Ну, как это сделать? Ну, идея, по сути, такая.
Запускаем ДФС и для каждой вершины
находим путь до корня. То есть, теперь получается,
сколько способов у нас взять два числа
из разных поддеревьев,
так, чтобы сумма этих чисел была равна К?
Логично, да?
Понятно, что имеется в виду?
Ну, как это сделать?
Ну, можно сделать так.
Вот у вас есть какие-то мешки чисел.
И, допустим, говорим, что первый мешок
мы прям честно записываем хэш-мап.
Теперь берем второй мешок
и подливаем к первому.
Ну, если подливать, мы для каждого числа проверим,
для каждого числа х проверим,
есть ли в этом дереве число
К-х, если да, то сколько их и добавим
это сколько к ответу.
Ну вот, после этого пробежались еще раз,
там подлили. Теперь берем это, ну и так далее.
Понятная идея, да?
А ну-ка, поднимите руки,
кто, собственно, сталкивался раньше с этой
или подобной задачей.
Так, вот, постепенно уменьшаемся.
Окей.
Я буду ленису руки подымать.
А то, как говорится, если на каждый вопрос буду руки
подымать, это я программировать не смогу.
Или две.
Ну, хотя, ну, что делать?
Хотя в гадли, что вас
на физкультуре подтягиваться не заставляют?
Нет.
Нет? Не везде.
А, вы что, плаванием занимаетесь?
А, везет.
В последние месяцы почти у всех плавание, кажется.
Что?
Здесь у всех плавание?
Слышь, смотри,
на весной сейчас начали всех отправлять
в бассейн.
Кому-то отправляли осенью в бассейн.
А, ну, нормально. Слушайте, мне нравится.
Повезло, повезло.
Ну, вот.
Ну, вот.
Ну, не знаю, нашел ПФ, вы никогда
не отправляли в бассейн. Нет, нас отправляли
на лыжи, во.
Не, сейчас все специализации в бассейн получим.
Это хорошо.
А специализа бассейна куда отправляется?
Ну, просто при такой толпе
она же должна куда-то отправляться. Или там
на фистейке появился второй бассейн.
Вот. Ну, ладно.
Значит, хорошо. Значит, это мы
за линию проходить через корень научились.
Дальше возникает естественная идея
вида разделяй и властвуй.
А давайте теперь пойдем в каждое под дерево
и запустимся рекурсивно.
Вот.
Да, может показаться,
что это решение за n квадрат
лог n.
Но это не так.
Ну, потому что, смотрите, вот вы...
Нет, смотрите.
Но дело в том, что, смотрите,
вот вы корень обработали за линию, правда?
Теперь заметим, что если вы запустите
вот этого под дерево, вы обработаете его
не за от n, а за от сколько там вершин,
правда?
Ну вот. И это, ну вот, и это.
Ну, по крайней мере, тоже для вот этой вершины,
для этой, для этой тоже. То есть, суммарно
каждый из этих DFS, все эти DFS будут
за линию, за n работать.
То есть, в результате получится
даже не... Нет, получится следующее.
Получится
от n умножить на, вот я так напишу,
глубину рекурсии.
Ну, потому что
заметим, что у нас на каждой глубине рекурсии
вы суммарно работаете за линию.
Ну, это правда.
Ну вот. По такому раскладу
можно это оценивать как глубина дерева.
Потому что есть там дерево у вас там небольшой
глубины, то, в принципе, это решение вполне адекватно.
Ни хрена не загорит.
Ну да, но можешь не повести, потому что дерево
может быть бомбу-ча.
Если дерево бомбу-ча, то
вы, конечно, из него, там дерево
просто глубины никакой не сделаете.
Но!
Теперь мы можем воспользоваться щитом.
Как бы, тут возникает вопрос.
Если мы выбрали корень, то хочется сказать,
что у этого под дерево корень будет вот эта вершина.
Но возникает мысль,
а кто сказал, что это?
Я ж могу вот это под дерево
подвесить уже, закрутить вот
эту вершину?
Ну, могу?
Вот, могу просто.
Хочу и делаю.
Вот, просто беру, подвешиваю за центро
и обрабатываю. Потом тут тоже подвешиваю
это и так далее.
Заметим, что N на глубину рекурсии,
а симтотика от этого не поменяется.
Но если я буду на каждом дереве
тратить O от количества вершин на то, чтобы
искать подходящую вершину, то тогда
я могу попробовать уменьшить глубину рекурсии.
И вот возникает вот зачем нужны центроиды.
А давайте сделаем центроид.
Зачем нам нужен центроид? Чтоб глубина рекурсии
была логарифом.
Чтоб каждый раз, когда вы идете в под дерево,
оно было размером в два раза меньше.
Понимаете, да?
Понимаете?
И в результате тогда, если вы будете брать
на каждом шаге, то есть тратить O от N
времени, чтобы найти центроид,
то тогда вместо
вот этой симтотики вы получите
O от N
лог N.
То есть получается, смотрите, то есть зачем
нужна, то есть как бы в чем смысл
центроида. То есть сам по себе центроид
позволяет найти,
то есть позволяет вам запускать
что-то типа разделяй властвуй
на дереве.
Вот.
То есть просто вот такое
разделяй властвуй на дереве.
То есть можно
выбирать, то есть технология решения
выглядит так. Берем центроид, рассматриваем
все, что проходит через центроид за какую быструю
симтотику, а потом после этого
выкидываем центроид и
рассматриваем оставшееся под дереве рекурсивно.
Это работает, получается, суммарно
за логарифом
за логарифом N умножить
за сколько вы
обрабатываете все проходящее через
центроид.
Вот. Понятно, да?
Я не понял, как мы пересчитываем тогда,
если у нас корень будет в вершины не подвешенная,
а какая-то надобная?
А так, а что вам надо?
У вас есть ОАТН-времени на то,
чтобы просто из этой вершины запустить
ДФС по этому дереву пересчитать
собственно длины путей.
Так что, ну вот.
Нам надо научиться
вообще центроид
Да, но так вы же только что обсуждали,
как это делать.
Нет, скажем так, если вам
дано дерево, то вы за линию можете
его найти. Да,
фишка в том, что имеется в виду, что
на каждой грузе надо делать
прям максимально с нуля.
То есть, никакие
старые ССС-шки уже не работают, надо
считать новые.
Мне кажется, не обязательно
Нет, чтобы глубина рекурсия
была ЛОГН, нужно брать центроид.
Это другой метод решения задачи.
Да, эту задачу можно решать
действительно методом сливаемых сетов.
Возможно, мы даже ее с вами рассматривали
в какой-то момент.
Или не было такого?
Ну ладно, это локальность.
Да, но есть просто,
нет, есть разные методы.
Да, конкретно эту задачу, конечно,
можно и переливать, короче,
можно и переливать.
Нет, на эту задачу, конечно, можно и переливайкой
решать, безусловно, я не претендую.
Да, ну вот,
красивой переливайкой, но на самом деле
это не нуля, а можно и так.
Но это, конечно, более
технический, потому что я помню, как-то я писал задачу
таким методом, и с этим мне оказалось удобно
каждое дерево просто честно копировать.
То есть копировать, перенумеровать
и передавать в рекурсию.
Это редкий случай, когда вы передаете
в рекурсию вектор векторов,
даже без ссылки.
Но это, оказывается, удобно.
То есть там, оказывается,
знаете, у меня там получалось
с помощью этого решения zn2logn,
прием там, по-моему, 2 или 3 тысячи, это прям
замгновенно работало. Правда, может быть,
часть из-за того, что судя по авторскому
учению, жюри такого не ожидало,
там была какая-то адекватная динамика,
ну вот.
Ну или там с каким-то там
адекватной
рекуррентной формулой,
может, из числа тех, которые мы с вами
в прошлом году обсуждали. Ну не помню.
Но, как бы, в случае чего
как бы можно.
Ой.
Капомысо-оддовик. Ну вот.
Но это, как бы, это на самом деле, да,
кто-то может сказать, что это вот это есть
центроидная декомпозиция,
но на самом деле это не так
еще. Ну вот, конечно,
скажи так, это, конечно, терминологичный
вопрос, является ли то, что я рассказывал
с центроидной декомпозицией,
но на самом деле я бы сказал, что центроидная
декомпозиция является то, что я скажу
дальше.
Вот, потому что это, как бы, это такой просто
разделяю властву через центроиды.
Вот.
Соответственно.
Значит, смотрите.
Значит, какую тут еще неожиданную
задачу можно решать?
Потому что как можно еще
ну вот,
может быть, обобщить дерево отрезков?
Потому что есть вот такая весьма неожиданная
задача. Задача
называется такая тоже. Представим себе, что
у вас есть тоже вот такое взвешенное дерево,
но веса пусть будут
не отрицательные.
И будет такая неожиданная ситуация.
А давайте
мы будем делать присваивание
в радиусе.
То есть у каждой вершины есть какой-то цвет.
И у нас есть запрос
вида
значит, покрасить
все вершины
находящиеся в радиусе
до расстояния не более
чем R от вершины V
в какой-нибудь цвет C.
Вот такой вот неожиданный вот
покраску.
Вот прято.
И второй запрос,
ну хотя бы такой самый минимальный простой.
Скажите, пожалуйста, а вершина V
вообще там в какой цвет покрашена?
Ну и как всегда,
вот дано дерево на 100 тысяч вершин
и какие-нибудь там 200 тысяч вот этих вот запросов.
А ну-ка, так, тоже давайте
тесить. А ну-ка поднимите руки, кто
начался с такой задачи?
О, как все уменьшается-то, да.
Ну окей, а где сталкивались, кстати?
Ага, логично.
А в какой-то группе было?
Нет, я говорю, в какой группе ЛКШ это было?
В 7.
Это в 7, да, было, но
тогда было 5.
Ой, Господи, да.
Не, ну это круто, да, конечно, хотя
там уже страшно было, да, потом.
В общем, после, как я впервые в жизни
узнал Дашу, я кому-то рассказываю про тот
ЛКШ, а говорят, ой, какой-то ой,
а у нас ЛКШ был.
Правда, в 11-й группе, но был.
Вот. Да, такое бывает.
Нет, или у вас он тоже был, просто я забыл
спросить.
Кто-то ЛКШ?
Ну, помните, мы вот это две недели назад рассматривали,
эту веселую задачу, про найдите
там наибольшего все подпоследствия
между строкой С и всеми подстроками
строки Т?
Нет, не было такого?
Рассматривали что-то такое, да.
Где?
На лекции это было?
Нет, правильно, у нас-то
да, мы это с вами рассматривали, да.
Но просто я помню,
просто мне сообщили, что где-то в 11-й группе
ЛКШ это тоже есть.
Учитывая, что в 11-й группе ЛКШ
появилось совсем недавно?
Ну да. Не, ну понятно.
Если в них кто-то был.
Ну кто-то был, нет, мне бы
сказал человек по имени Илюша Васильев,
так что да.
Так что да, тут
видимо важное
уточнение. Ну им такое
рассказывали, да.
Ну это
да.
Кошмар.
Хотя да, нет, хотя да,
это тот человек, который знаете, да.
А, ну этот, да.
Тот человек, который был. Да, я был
ЛКШ, читал так, делал лекцию по
Дереву Гомориху, я базировал
енот, я подготовки смотрел вашу лекцию.
У вас там в конце ошибка.
Вин, это тот чувак,
который на сервисе
после четвертого часа был там
топ 70,
а по итогу
что-то типа третий.
Не-не-не, он, не, у него,
ну воверх где-то после
момента второго часа я его вообще
вообще на втором месте видел,
но итог у него седьмой, к сожалению.
По первому кем?
Вообще.
Нет, по первому было нормально, да.
Да, но там
4 часа было нет. Ну да, да, да.
Ну посмотрим, ладно, главное.
Как это называется, главное, чтоб он там где-нибудь
был, по итогу Змороз намежна, да.
Вот.
Вот. Хотя, конечно,
будет чуть сложнее.
Но, впрочем, как повезет.
Ладно, не будем на это.
Ладно, это уже другое дело.
Значит, идем дальше.
Значит, вернемся к этой задаче.
Потому что вот оказывается, вот,
при решении этой задачи, собственно, сейчас вы
ну, может быть, не то чтобы узрите всю мощь
центроидной декомпозиции,
но, пока и мере.
Ну, что такое вообще
центроидная декомпозиция?
Ну на самом деле, это то, что будет,
если мы всю вот эту рекурсию пропишем
в явном виде.
Что я имею ввиду?
Я имею ввиду следующее.
Значит, я возьму какое-нибудь дерево.
Вот это вот дерево я возьму,
вовсю, возьму. У меня тут веточки разрастаются,
разрастаются, разрастаются, разрастаются,
разрастаются, разрастаются, разрастаются,
да, сейчас я побольше
нарисую, чтобы тут совсем наглядно было.
Вот, побольше, побольше,
побольше там бамбуча какая-то разрастается там вот вот бамбуча бамбуча да вот как так это
называется да кошмар вот кока-кола вон главное почему-то у нас есть афанты нет вот странно да
а нет хотя есть господи что это вот вот значит смотрите берем центроид ну допустим вот эту
значит я объявляю ее центроидом первого уровня такой это такой федеральный центроид вот
ну хотя но но но я не знаю ладно там можно сказать как же такая столица да хоть этот
центроид федерального уровня но у нас возникнет ощущение что таких центроидов у нас будет
вот но у нас у нас будет такой один ну ладно ну ладно лучше без федерального
уровня будет столица вот ну как всегда да естественно если у нас там в графе два
центроида вы выбираете любой вот значит теперь говорите так что у нас теперь есть столица и
все остальное но значит все остальное это значит у нас в данном случае три ну там сколько там в
общем случае может быть сколько угодно под дерево под деревьев каждое под дерево мы объявляем
федеральным округом и вы в каждом из этих федеральных округов тоже есть своя столица
федерального округа ну типа там вот вот то есть ну так кто тут центроид у этого то она
наверное вот это вот ну типа вот питер но типа ну питер город такой там ну знаете это к югу от
петрозаводска такой маленький вот что там 5 миллионов там всего чего вот да вот ну вот ну
вот допустим вот это будет новосибирск вот это будет ну да лучше сдастся больше на казань похоже
да вот это будет казань условно но теперь заметим что мы значит идем дальше значит в каждом внутри
федеральных округов есть всякие области у всякие республики типа на теперь облики республики
литокрай края там эти все вот вот так вот вот так вот там ведь их уже много много много там у нас
уже вот так что там у нас еще а ну вот вот вот это вот еще конечно так что там а ну тут вот так
вот получается да ну кто-то большой кто-то маленький тут всякое бывает вот внутри каждой этой области
лекаря есть обл центр то есть вот наверное вот вот уже наверное вот это иванова например как раз
вот это там кострома это там что там еще у нас есть липецк например вот что еще есть вот там
томск какой-нибудь так честь а ну давайте вот тут будет видите новгород где-нибудь так есть
какой-нибудь маленький сингапурчик автономный городочек такой да так что тут еще ладно так
ладно давайте еще вот это благовещенск еще вот будет пусть будет так есть благовещенск ну и давайте
что там еще владивосток давайте вот тут ой тут еще ой тут еще под дерево есть ой ой ой а тут
правда а потому что тут прям под дерево прям вот так вот так ну да как ой это вот точно да это
да как говорится это мы назовем перм да это мы назовем перм потому что по-моему это первая
по-моему пермский край у пермского края так это он такой большой но перм где-то на юге находится
там недвалинина границ или что-то в этом роде впрочем неважно но что будем делать дальше но
каждое внутри каждой области есть районы да вот ну вот так что тут можно давайте вот
есть вот районы районы районы там ну скажем там если это так это было Иваново так ну ладно
к сожалению не силен киография Ивановской области вот но правда тут заметим что города уже автоном
но их ничего нет да вот здесь можно чуть посложнее смотрите да вот условно если это Кострома то вот
это вот получается судеславль вот ну а вот это вот это уже типа берендеевы поляны вот
судеславль город ну скажем так в районе судеславском районе есть и такой объект вот так ну тут так что-то
отдельное там всякое висит ну не боюсь в общем короче говоря то есть я думаю суть вы уже более
менее поняли то есть на самом деле центроидная декомпозиция это когда мы едва ли не в явном
виде храним все вот эти деревья в логарифме рекурсии то есть смотрите имеется в виду что я храню прям значит
все цены то есть каждая вершина является центроидом то есть знаете вот в древней греческо демократия где там
получалось что каждый человек там хоть в каком-то виде но государство управлял ну потому что там
должностей немного и на каждой должности нельзя было много раз избираться поэтому
получало что практически каждый там хоть какой-нибудь после получал и там государство отношения или contenido
и он но здесь будет получается так что каждый город то есть как у нас есть иерархия вершим
каждой вершины является центроидом вопросу только какого-то уровня то есть есть главный
центроид есть центроиды второго уровня т fishes тогда причем более того у каждого центроидом есть
есть такая зона влияния, то есть, скажем, Москва влияет на все,
там, скажем, Новосибирск влияет только на свой округ,
ну вот там, скажем, Кострома влияет на Костромскую область,
ну вот, Бериндеревы поляны — это вещь себе, да.
Ну и так далее. Ну, глубина может быть тогда алгоритма.
То есть, мы будем прямо в явном виде,
каждое из этих поддеревий, для каждой решины мы можем что-нибудь в явном виде хранить и что-то делать.
Вот в качестве примера обычно и рассматривается вот эта задача.
Потому что идея будет следующая. Ну, значит, начнем сначала с разминочки, да.
Вот, ну, вернемся к задаче. То есть, мы хотим красить в каком-то радиусе и получать цвет.
А теперь представьте себе, что вы красите в радиусе только одной вершины.
Вот тычетесь только в одну вершину и краситесь только вокруг нее.
Как тогда решать задачу?
Структура данных в массе.
Ну, я, ну, не совсем. На самом деле будет структура данных стек все-таки.
Даже дек, я бы сказал.
Ну, потому что, нет, первая идея, конечно, будет понятна.
Сначала мы из этого корня, из этой вершины, из этого корня запустим DFS,
выпишем вершины с расстояниями и, а, ну и все, в общем-то.
Потому что, на самом деле, теперь покраски в радиусе,
потому что, на самом деле, теперь покраски в радиусах будут теперь в каждый момент времени выглядеть следующим образом.
То есть, мы знаем, что у нас там в радиусе до трех все покрашено в цвет A.
Потом, где больше трех, но не превосходит семи, было покрашено в цвет X.
Потом, до цвета десять, тут все покрашено в цвет Z.
Потом дальше идет там цвет 57.
И тут покрашено в цвет B.
Ну, давайте тут уже 179 нарисуем.
А, ну тут может быть еще в 2007, а там снова все покрашено в A.
Вот.
То есть, по идее, можно описать запросы вот таким образом.
То есть, у вас, то есть, форцухи, это вот такие вот концентрические такие окружности,
и в каждом слое все покрашено в свой цвет, понимаете, да?
Тогда, если вам нужно для какой-то вершины понять, в какой цвет она покрашена,
просто нужно бинпольском в этом деке найти, в какой-то слой она попала, правда?
Вот, понимаете?
А что если...
Ну понятно, если нам пришел запрос покрасить, условно, какую-то область,
и область на этом расстоянии целиком принадлежит этому центроиду.
Нет, парни, пока у нас нет центроид, пока мы временно забыли про центроиды,
сказали, что у нас покраски приходят в радиусе от одной вершины.
А, все тогда.
От одного корки.
Вот.
И тогда, если нам приходит запрос о покраске все в радиусе 35 в цвет П,
то тогда что у вас получается?
Вы тогда фактически из этой штуки просто выкидываете, выкидываете, выкидываете что-то,
и вместо этого довешиваете, тут вот пишете 35 П.
Понимаете, да?
Вот для этого нужен дек, хотя...
Ну, это лучше дек, это в принципе больше на стек похоже,
но на самом деле лучше дек, потому что в деке удобнее бинпоиск писать,
там есть оператор квадратной скобочки.
Вы писали, кстати, уже?
Уже написали этот дек?
Отлично.
Вот.
Так вот.
Но это если вас тычут в одну и ту же вершину.
Но, естественно, теперь возникает вопрос.
А что делать, если вас в задаче тычут в разные вершины?
Идея в вершине.
Значит, тогда возникает такая идея.
Ну вот, идея будет возникает такой.
Сейчас вот будет, может быть, немножко сложно,
но, значит, сейчас вот будьте внимательны.
Значит, идея такая.
Допустим, что вам пришел какой-то рандомный запрос в вершину В.
В вершину В.
С запрос, типа, радиус какой-нибудь, я не знаю, 345, свет Q.
Тогда вы говорите, так, интересно, а дойдет ли это до столицы?
И, допустим, выясняемся.
Думаем, какое у нас расстояние до столицы?
До столицы у нас расстояние 179.
Отсюда можно сделать вообще весьма неожиданный вывод.
Все в радиусе 345-179 от столицы должно быть покрашено.
То есть, поэтому я объявляю, 345-179 это у нас сколько?
Так, это 145 плюс 21, 166.
То есть, забабахиваем тут запрос, типа, 166 Q.
То есть, все вершины на расстоянии не более, чем 166 от этой вершины,
которая будет покраситься.
Но все ли мы покрыли?
Нет, не все.
Могут быть вершины на хорошем расстоянии от В, путь до которых не проходит через столицу.
Может быть такое.
Но тогда идея следующая.
Но заметим, что все такие вершины лежат, естественно, в дереве второго уровня,
в котором лежит вершина В.
Правда?
Теперь давайте смотреть.
У этого дерева тоже есть центроид.
Вот этот, центроид второго уровня.
И до него расстояние, допустим, оказалось, какое?
Ну, допустим, 343.
Да, могло оказаться, что расстояние до центроида второго уровня больше, чем расстояние до столицы.
Это нормально.
Вот.
Значит, соответственно.
Тогда, получается, в радиусе его, значит, тогда мы говорим так.
Значит, тогда мы этому центроиду второго уровня тоже передаем запрос.
Что в радиусе два от него красим все в цветку.
Но это касается только дерева второго уровня.
Понимаете, да?
Ну, то есть можно было сказать и про все, но мы будем говорить только про дерева второго уровня.
И отправляемся теперь под дерево относительно этого центроида третьего уровня.
Ну и, в общем-то, делаем примерно то же самое до тех пор, пока сама вершина В не окажется центроидом своего дерева.
То есть, по сути, идея такая.
Вот эту технологию со стеком мы проворачиваем в каждой вершине.
То есть, в каждой вершине мы, но в каждой вершине отвечает только за свое дерево.
То есть, мы в этом дереве как бы храним все расстояния, а также в этом, и в этом дереве мы храним все запросы, которые касаются именно этого дерева, именно этого центроида.
То есть, мы себе говорим, мы разрешаем себе делать запрос, записывать запрос в какой-то вершине, но только, но касается этот запрос только того под дерево, центроидом которого она является.
Понятно, да?
И получается, что исходный запрос вот так мы разбили на логарифом запроса.
Вот, понятно?
Правда, есть, конечно, теперь маленькая оговорочка.
Что когда нам придет запрос, в какой цвет она покрашена, мы начнем думать.
А кто ее мог покрасить?
Ну, кто-то из, действительно, центроидов начальников.
Да, у нас есть такая, можно вести понятие, центроидная иерархия.
То есть, я получил этот запрос.
То есть, получается, что если вершина у нас центроид пятого уровня, то она могла сама покраситься, а могли ее покрасить кто-то из четырех центроидов ее начальников.
Типа, вот столица, федеральный округ и так далее.
Но как понять, кто из них покрасил?
Ну, в них же мы храним вот такую штуку.
Какую?
Какие запросы внизу.
Да.
Если в домах хранить еще типа, понять, который из запросов, захватывающих нас, был последний.
Ну, да.
То есть, идея такая, давайте если просто для каждого запроса видеть, в какое время оно произошло, то получается у вас есть логарифм вариантов.
То есть, каждый начальник говорил, кого окрасил, и, собственно, вы из этих запросов просто берете последний и говорите, вот он.
В результате, ну, что получается?
Ну, тогда получается, что запрос гет вы обрабатываете, получается, за кое-сем точку.
Лог квадрат.
Да, лог квадрат, потому что у вас, ну, потому что центроидная глубина до логарифма и бинпоиск.
Вот, калори же вы делаете, ну, тут амортизация, но суммарно, но получается залог.
Потому что, заметим, вот это вот выкидывание стека, конечно, амортизированно, там за от единицы работает.
Понимаете, да?
Вот, ну, там. Думаю, достаточно очевидно, да.
Нет, почему за от единицы-то? У нас же каждый запрос, он появляется в логарифме вершины.
Нет, я имею в виду, что если вы работаете со стеком вот этим, вам пришел запрос новой покраски, то он амортизированно будет за от единицы работать.
Да, конечно же, здесь пишу логарифм, потому что вы логарифм, раз так делаете.
Да, тут, тут, да.
Вот, так что получается, вот это уже действительно и называется центроидная декомпозиция.
Кажется, можно где-то залогу делать.
Каким образом?
Потому что мы, по-моему, делаем супермного листьев действий.
Ну, мы делаем логарифм бинпоисков тут основная.
А какие действия мы делаем листья?
Я про то, что вот, как минимум, вот, когда мы центроидные, у нас в этих тителях есть какой-то запрос присвоения.
Так.
Точно, что если наш титель нас задевает в своем запросе, то, типа, нам уже ценнее его информация.
Ну, не совсем.
Нет, ну, конечно, да, нет.
Мы можем оказаться покрашены уже в запросе высшего центроида, но это не значит, что мы покрасим этим все, потому что там всякое бывает.
Вот.
Но, действительно, тут вот, ну, по крайней мере, вот такое вот есть.
Так что вот это уже и больше похоже на центроидную декомпозицию.
Ну, там много разных задач на это могут быть.
Там на каких-то серосах, по-моему, восьмой задачи, по-моему, уже это подсовывали даже.
Нет? Ну, вот.
Ну, да, не на последних серосах, но на, вот.
Но, как бы, если вы хотите уметь решать восьмую задачу, то да.
То есть, обычно для всяких там, чтобы стать призером-победителем вам, конечно, этого знать не надо.
Ну, вот, да.
Хотя, ну, хотя, нет, уровень, знаете, уровень постепенно растет, может, уже и на, может, когда-нибудь и надо будет.
Все-таки.
Ну, нет, ну, все-таки, знаете, уровень растет, конкуренция высокая, там, знаете.
Хотя.
Ну, тут по-разному, да.
Ну, нет, понимаете, ну, просто, по-разному.
Нет, понятно, что идеал, да, в идеале, конечно, да, серос, конечно, да, выигрывает не тот, кто знает, а тот, кто лучше придумает.
Но просто тут как бы дальше будет просто из цикла, может быть, сложнее, иногда будет просто сложнее дать задачи.
То есть, конечно, там на последнем, хотя на последнем серосе, да, повезло.
Вот там еще и жюри смогло дать достаточно сложные задачи, в которых ничего не надо знать.
А все надо придумать.
Ну, правда, вот там, правда, на Код Фольксисе это вызвало кучу негатива.
Там, потому что у кого-то был комментарий, там, в духе, ой, боже, вот зачем я ездил, я ездил во все эти школы, там, изучал эти сложные алгоритмы,
чтобы приехать на серос и выяснить, что я должен был написать два конструктива и один ДФС.
Оказывается.
А ей какое безобразие.
Ну, вот, ну, как говорится, жалко.
Жалко, что для человека, конечно, да, ликвидирование.
Как говорится, жалко.
Жалко, что для человека, конечно, да, Олимпиада это не придумать, а выучить.
Ну, вот, но это не отменяет того, что как бы в следующий раз могут дать задачи на это.
Ну, впрочем, не то чтобы я там, да, не то чтобы вы там когда-нибудь будете участвовать во серосе.
Ну, разве что в качестве членов жюри, конечно.
Ладно.
Так, ну, что ж, значит, получается, Centroid Decomposition обсудили, обсудили.
Так, ну, Heavy Light еще раньше обсудили.
Так же, ну, кажется, это вроде все, что я хотел сказать про деревья.
Поэтому сейчас у нас будет перерыв, после чего мы перейдем к DFS-у на более продвижение.
Наконец-то что-то руки стали подымать не все, так что.
Так же, значит.
Вот, хотя нет, сейчас я думаю, сейчас я буду рассказывать темы, на которые вы руки будете подымать достаточно активнее.
Да, потому что сейчас мы, конечно, будем рассматривать метод Ториана, который будет одним хопом находить нам, значит, целых пять объектов.
Значит, мосты.
Компоненты реберной досвязности.
Точки сочленения.
Компоненты вершины двусвязности.
И компоненты сильной связности.
Да, это будет делать практически один и тот же алгоритм.
Вот.
Так, ну вот.
Значит, но для начала оговоримся, что да, зачем я это дерево оставил.
Мы, конечно, то есть мы, конечно, сейчас с деревом о дереве говорить не будем.
Значит, уровень Easy.
Значит, уровень Easy.
Значит, метода Ториана.
Ну, этого метода Ториана.
Я думаю, там многие методы можно назвать методом Ториана, конечно.
Но конкретно у этого, конечно, есть уровень Easy.
Ну, там будет у нас уровень Easy, уровень Medium, уровень Card.
Уровень Easy и Medium будет работать на неориентированных графах.
Ну, естественно, да.
Ну, там все будет базироваться на DFS.
Но давайте вспомним, да, что когда мы запускаем DFS в неориентированном графе,
как мы уже с вами в прошлый раз договорились, для нас будут существовать только два типа ребер.
Ребра дерева DFS и обратные ребра.
Как мы с вами, ну вот.
Ну, то есть ребра, которые соединяют потомка с предком.
Ну, предка с потомками тоже соединяет, но вот для нас это неважно.
То есть мы будем считать, что существуют только такие ребра.
Вот. Понятно, да?
Вот. Ну, собственно, полезно такое, полезно так считать.
Вот.
Ну, а теперь, значит, задача, значит, номер Easy.
Так, ну, во-первых, конечно, введем простое определение.
Определение.
Конечно, мост это, да, дальше, да, я перестаю диктовать, вы на автомате пишете.
Да, то есть, можно так сказать, мост это ребро, удаление которого приводит.
Все, вы как-то не так пишете?
К увеличению числа компонент связанности.
Числа компонент связанности.
Вот.
Так, ну вот спрашивается, какие ребра в этом графе, вот в таком графе являются мостами?
Все.
Нет, красные ребра существуют тоже.
Да.
Два.
Второе.
Вот оно, вот оно.
О, вот так, вот так, хорошо.
Да?
Да.
Так.
Ну, да, да.
Ну, в принципе, да, заметьте, в этом графе у нас есть.
Ну, да, да.
Ну, в принципе, да, заметим, что да, мостом является там, ну, фактически все ребра, на которых висят висячие вершины, или под деревья там, или вот что-то такое.
Ну, вот, ну, самый нетривиальный мост здесь, конечно, вот это.
Потому что он разделяет граф на две самые нетривиальные части.
Вот.
Ну, у этого моста есть, конечно, понятие более нетривиальное.
О, поздороваться.
Я что, здравствуйте, нет?
Или я сам себе сказал, в голове, я про его поводу.
Вот, да, вот у меня такая же проблема есть, вот такая.
О, ладно, добрый день, добрый день.
Вот.
Вот.
Так вот.
Значит, опарник такой.
Значит, ну сейчас придется работать чуть посложнее.
Значит, определение.
Вершины уйве.
Значит, тут прям вот аккуратнее.
Вершины уйве.
Внимание.
Рёберна двусвязаны.
Рёберна, да.
Двусвязаны.
Если существует два рёберна непересекающихся пути.
И это важная оговорка.
Соединяющих уйве.
Во.
Вот.
Ну, то есть типичный пример, то есть, может показаться,
что можно было сказать другими словами, что через уйве можно провести цикл.
Но это не очень точно.
То есть, воображать себе можно вот такое.
Но не нужно.
Потому что гораздо лучше себе, конечно, воображать вот какого-нибудь такого рода пример.
Вот.
Потому что обратите внимание, вот эти два пути, они рёберна не пересекаются.
Вот.
Вершина, сколько угодно.
Понятно, да?
Ну и, конечно, да.
Ну и слава богу, что если уйве совпадают, то, конечно,
путь, который стоит только из вершины, он сам с собой рёберна не пересекается.
Так.
Ну, возникает сразу первое утверждение, которое оказывается не таким уж тривиальным.
Рёберная двусвязанность – это отношение эквивалентности.
Вот.
А что тут не тривиальный?
Да, ну давайте, ну-ка докажите мне, почему это так.
Ну, вот у нас есть УВДВ в вершинке, да?
Так.
Ну.
Так, ну давайте, да, сразу оговоримся, да, заметим, что рефлексивность очевидна,
то есть симметричность тоже.
Так.
Да, то есть теперь надо доказать транзитивность.
То есть надо доказать, что если между У и В есть хорошие пути,
и между В и В есть хорошие пути, то между У и В есть хорошие пути.
Склеим пути, ну а если они…
Ага, склеим, но только маленькая проблема.
Да, в идеале, конечно, хочется нарисовать какую-то картинку вот такую.
Так кажется, что проще всего просто выкинуть все мосты из графа
и сказать, что вот не наш компонент реабилитации.
Ага.
Это не докажет отношения эквивалентности.
То есть это докажет, что внутри…
Своили вот так.
Это докажет, что внутри компоненты связности
там любое ребро там лежит на цикле, это да.
Но это докажет, что любые две вершины соединенные ребром
у ребер-нуду связаны, но это не докажет, что ребер-нуду связаны
в отношении эквивалентности.
Так, ну-ка, вот давайте.
Так, давайте, подготовимся, у вас там как раз теоретическая задача.
Это все будет.
Даже две.
Да, но там вот хорошие.
Вот давайте к ним немножко подготовимся.
Там мясо полное.
Так, ну-ка, вот давайте, давайте, давайте.
Вот.
Ну вот, а ведь…
Синий.
У нас синий.
Там две задачи по 7 утра рождения.
Сейчас.
Ну.
Нет, тихо, тихо, давайте лучше задавайте.
Нет, там-то будет вкуснятина, это да, но…
Ну, окей, давайте мы рассмотрим самые ближайшие пересечения.
Да, первые пересечения.
Какое первые пересечения?
У нас из 2 цикла, давайте лучше склеим из 2 цикла.
Что такое склеим из 2 цикла?
Давайте вот, у нас есть путь из куб В и из В в В.
Есть.
Нижние 2.
Ну, допустим, они может даже пересекаются паре вокруг, кстати.
Вот, ну, давайте, вот мы взяли путь из куб В, дальше идем по пути из В в В,
до первого либра, который есть на, собственно…
Ну да.
На пути из куб В.
Ну, мы с тем же успехом просто можем тогда взять первое вхождение вот этого ребра на путь из куб В
и к нему прицепить, типа, конец, то, что после этого ребра на пути из В в В.
Ну, хорошо, ну, по сути это называется, мы возьмем путь вот этот у В В,
там, допустим, выкинем за него лишние крюки, там внутри него возьмем там простой какой-то путь,
может он вот так вот будет выглядеть.
Мы можем даже из этих двух тоже это сделать.
Остается только вопрос, а почему вот этот путь и этот путь не пересекаются?
Ну…
А теперь же…
Ну, если вот смотреть именно такой способ, как мы делали, у нас получается путь,
оба пути имеют вид, как это, типа, префикс пути из куб В и суффикс пути из В в В.
Ну…
В таком виде, кстати, не совсем.
Ну, там тогда надо точнее формулировать, что в том виде, как мы сказали, по-моему, это не так.
Ну, там, типа, берем путь от УВ, а потом там что-то, находим первое пересечение, что-то там выкидываем.
То есть это как-то, по-моему…
Ну, либо у меня какие-то в голове не те ассоциации вызывает.
Мне кажется, да.
Кажется, что проще, чем это, вот, предпочтение доказать, типа, то, что если вот рассмотреть компоненты по мостам,
ну, типа, после удаления мостов, то вот все вершины внутри одной компоненты, например, на двух связанных.
И из этого уже тогда очевидно, что это ошибка.
Ну, кажется, что вот это просто доказывает.
Ну, и как она, ну…
Ну, это картинка называется, ну, и как вы это докажете.
Ну, в одну сторону очевидно, типа, если у нас есть…
Вот гуд реально, да.
Ну, типа, если у нас есть мост, то это…
Ну, типа, если у нас есть мост, то это…
То это неправда, что пара всех вершин вверху на двух связанных.
Потому что, ну, понятно.
Просто поселим две вершины по разные стороны.
Нет, ну, это понятно, да. Хорошо.
Поэтому из того, что существует мост, получили…
Да, это понятно. А в другую сторону?
Ну, а теперь, допустим, у нас мостов нет.
Ну, рассмотрим.
Любой путь. Из УВ.
Да.
Вот. Надо не один путь, надо два пути.
Ну, вот у нас есть, получается, первые две вершинки.
Есть первая, вторая, вторая, вторая, третья.
Есть цикл, который…
Ревер на простой цикл, который содержит первые две вершинки есть.
Ревер на простой цикл, который содержит вторые две вершинки.
Значит, первый и последний мы как бы пометим.
Теперь посмотрим на общие вершинки у этих циклов.
Если у этих циклов всего одна общая вершинка,
то мы можем как бы склеить его типа восьмерткой.
Вот. Теперь, если у этих циклов…
Ну, общие ребра, потому что, может, от склеивания мы их избавиться не можем иногда.
Ну, помните, да, что у нас вот так бывает, да?
Да.
Теперь пусть у нас у циклов есть это.
Подождите, подождите.
Мы и пишем теперь первый цикл в какой-нибудь поярке.
В какой-нибудь цикл.
А теперь будем смотреть на его вершинки в таком поярке.
Не, ну и потом что? И потом что, значит, склеим восьмерткой?
Ну, если у нас только одна общая вершинка.
А, ну это если одна, а если…
Ну, дальше. Пусть у нас теперь можно…
Ну, давай.
Пусть у нас есть несколько общих вершинок.
Получается, у нас вот есть…
Так.
Затем здесь вот.
Раз вершинка общая, два вершинка общая.
Со вторым.
Первый там дальше как-то идет.
Дальше могут быть пересечения.
И вот тут второй цикл он как-то идет.
Возможно поэтому, или было возможно, поэтому.
Так.
Теперь у нас получается здесь какой-то кусочек.
Здесь какой-то кусочек.
Здесь первая важная вершинка.
Тут вторая важная вершинка.
Ноги.
Теперь мы возьмем эту часть от этого цикла.
Получается из двух частей.
На нашу исходную циклу мы возьмем ту, в которой есть важная вершинка.
И вот эту мы возьмем ту, в которой есть важная вершинка.
И соответственно оставшуюся часть мы как бы отпилим.
Дальше мы вернулись в то же самое место.
Дальше мы можем продолжать склеивать.
То есть у нас цикл был как-то, допустим, как-то странно пересекаться.
Ну, по-моему, цикл перестал быть циклом.
То есть было два цикла, стало просто два пути какое-то.
Которые описывали один цикл, но они могли пересекаться.
Я не суду, что у нас вот пошло как-то так.
Пошло как-то так, затем второй шел вот так вот зашел, вышел, зашел, вышел, зашел, вышел.
Ну, например.
И такое могло быть, да.
И где-нибудь у нас вот так вот.
Вот у нас две важные вершины.
Вот у нас есть первые два пересечения.
Мы смотрим.
У нас наша вторая важная вершинка в этой части.
В этой части, которая между пересечениями выциклется.
Вот.
Вот.
Вот.
А нет, он шел вот так.
Мы смотрим, она здесь или нет.
Она у нас, она есть здесь, поэтому мы эту часть удаляем.
Вот так вот.
То есть мы смотрим, она здесь, она здесь или здесь.
Она, она, она, она.
Сейчас, подождите, на какую часть удаляем?
Мы часть какого цикла удаляем?
А, ну да, если они пересекаются.
У нас вот есть циклы.
У них есть пересечения.
Вот есть две вершинки в первом цикле.
Идешь однажды после второй.
И у нас у второго цикла тоже есть.
Второй цикл как бы до них шел.
А если на этом пересечении есть сама вершина W, кстати?
Значит, мы говорим, что она нам нужна.
И остальную штуку отбрасываем.
То есть у нас вот они как-то пересеклись вот так.
И мы берем нужную нам часть из пересечения.
И казалось бы, идем дальше.
Идем дальше.
Давай можем склеить циклы.
Ну, я что-то не понял.
Как мы как бы убрали склейку сейчас?
Мы их типа, образно у нас есть циклы.
Если у нас возникают конфликты, когда мы можем склеить,
то мы просто отрезаем от них куски,
в которых нет нужной вершинки.
Ну, отрезаем.
Но если от цикла отрезать кусок, он перестает быть циклом.
У нас были два цикла.
Вот у нас есть два цикла.
Мы отрезали кусок и вклеили кусок из второго.
В конфликты.
Мы отрезаем не нужные куски,
сейчас в итоге один большой, хороший цикл с нужной вершинкой.
Мне кажется, я могу на поле показать, что у нас есть.
Ну, давай.
Давай.
Вернемся к этому рисунку.
Допустим.
Допустим.
Вот.
И, допустим, у нас вот тут вот, да, какое-то пересечение.
То есть, типа, тут мы прошли с порыбром X, Y, да?
Да.
И тут мы прошли с порыбром X, Y.
Вот.
А мы хотим, ну, вот, что-то вот такое вот сделать.
Ну, ну, тогда давайте мы, типа, вот,
вся вот это вот просто удалим.
Угу.
И из этого, ну, вот, и вот, короче,
из этого Y пойдем так же, как мы шли бы отсюда.
Нет?
Нет?
Сейчас.
Тут вам проблема какая-то с тем, что у нас теперь вид другой.
Непонятно, как это все мы делаем.
Нет, то сейчас.
Не, ну.
У нас уменьшается количество ребер.
Да, ну, теперь вид меняется.
Нет, ну да, но вид как-то, но вид как-то меняется.
Это больше не у восьмерка вот такая.
Почему?
Такая же у восьмерка.
После первого же удаления у тебя не это вот той вот вершины V,
с которой ты два раза приходишь.
Не, ну, скажем так, у этого, кстати, тут у этого рассуждения
еще такая вообще сильно болезненная дыра такая, что если тут X, Y,
это X игрок, а не игрок X.
Нет, это только по общению не важно.
Да?
Вот ты прошел по X игрок, а потом по игроку ты куда пошел?
Вот так что ли пошел?
А можно просто не проходить.
Да, можно с X сразу в X.
Можно сразу вот с того дела X пойти дальше.
Ага, так.
Это вообще не проблема.
Ну.
У нас есть два пути, справа верхний и нищий.
Давайте в обоих из них возьмем два самых правых.
Не, ну там начнутся всякие подлянки, что вы рассмотрите вот эти пути.
Но там просто выяснится следующее, что тут вам хотя бы гаранти...
Сейчас.
Что вам...
Нет, ну да, там просто с видами напряг.
Там просто надо тогда очень аккуратный какой-то инвариант тогда расписывать.
Потому что у нас как бы вот этот вот выкидывание этого пути выкидывает у нас в вершину V.
Сейчас.
То есть можно правда прописывать инвариант, что у вас есть два пути,
значит каждый из которых содержит там какой-то там...
там префикс какой-то, там суфикс какой-то,
кто-то там с кем-то не пересекается и так далее.
Мне сейчас так получилось, что...
Что получилось?
Вот мы гарантированно избавились от пересечений на одном из двух правых путей, да?
Нет, не да, мы избавились от одного конкретного,
то есть мы взяли пересенье и конкретно от него избавились.
Но пока это все, что можно сказать, что он выкинулось какой-то.
Потому что у нас теперь есть путь вот такой, в смысле вот такой, и вот это вот.
Как они между собой пересекаются вообще непонятно.
Сейчас я говорю, что можно взять самое правое из пересечений.
И тогда у нас теперь...
Вот путь, который есть у В, мы сейчас построили.
Он вообще ни с кем не пересекается.
Сейчас, а что такое самое правое пересечение?
Само ближайшее к В, в W.
Так.
Ну допустим, да, возьмем X игрок, да, первое ребро X игрок на пути,
который пересекается хоть с кем-то, так.
Так, ну окей, значит мы его, так.
Тогда на пути с W до U теперь становится вот таким, тут путь становится таким.
И что нам это дает?
Ну само по себе, так.
Ну что это нам дает?
Так как новых ребер у нас в путях не появилось,
то вот этот вот кусочек, видимо, как ни с кем не пересекался,
так ни с кем и не пересекается.
Угу.
Так.
Ну в принципе, да, повторяю, да.
То есть повторяю, да, хорошо.
Повторяю, да, повторяю эту операцию.
Может там, сейчас.
Ну вот, да, все, теперь у нас,
этот вот вторая половина пути может пересекаться только сама собой,
а для нее мы уже можем проделать такую операцию.
Сейчас, не, погодите, погодите.
В какой-то момент, может, до того, как мы,
потому что мы ж могли в какой-то...
Нет, ну тут, сейчас.
Угу.
Нет, погодите, ну тут, погодите,
мы тут на картинке явно пользуемся тем,
что у нас есть какая-то вершина В такая,
что тут ребро было до, а тут ребро после.
Потому что если это первое пересечение в озеро,
что вот этот путь не пересекается ни с кем,
а вот этот вот возникает,
а тут возникает пересечение чем где-нибудь вот с этим,
то, по-моему, нам может оказаться больно.
А ладно, есть беда с тем, что нижняя половина
равна пути может пересекаться только сама.
Ну вот, разные проблемы есть, конечно, да.
Да, в идеале, конечно, да.
Оставить бы об этом, ладно, давайте до краткости.
Ладно, на самом деле, ну тут можно бесконечно долго,
конечно, думать, то есть в идеале, конечно, так и да,
но не будем тратить время.
Потому что есть, на самом деле, сильно более простая технология
доказательства этого всего.
Значит, звучит она так.
Сейчас у нас просто единая такая технология.
Значит, вот у нас есть пути УВ.
И мы знаем, что от В есть два, то есть от В есть два
реберно не пересекающихся пути до В.
Так вот, идея такая, давайте пойдем по этим путям,
от W по направлению к В до первого, до первой, даже не ребра,
а до первой вершины, которая попала вообще в циклу В.
Понимаете, да?
Одно и допустим другое.
То есть, заметим, что вот эти два пути и эти части пути
уж точно никто ни с кем реберно не пересекается.
Ну, вершин, насколько угодно, реберно точно нет.
Но тогда, но тогда заметим, что два пути, в общем-то,
налицо, вот путь и вот путь.
Формальное доказательство, конечно, требует тут
рассмотрения двух случаев.
Потому что, во-первых, вы, конечно, В могло оказаться
между этими клеммочками, тогда вот путь такой, да?
Могло, в принципе, еще оказаться, что клеммочки
подсоединились к одной стороне.
Потому что, в принципе, вот такое тоже могло быть.
Да, но по большому счету, да, нам не принципиально.
Просто тогда вы делаете вот такой путь и вот такой путь.
Просто через В будет проходить.
То есть, по факту, можно сказать, что у вас был цикл,
вы к нему подсоединились клеммочками В и получили
реберно простой цикл через В и В.
Да.
Вот.
То есть, в общем-то, это все, что вам нужно.
Вот.
То есть, тут пора...
То есть, кажется, вот самое простое по формулевке доказательство
на самом деле вот такое.
Ну там, потому что кто-то это доказывает.
Например, там еще по индукции бывает, что пусть расстояние
между ними к, значит, для к-1 это верно.
Поэтому тут рассматриваем этот цикл.
Если это ребро попало, то хорошо.
Если нет, то заметим, что это не мост, то там существует
другой путь.
Это просто вторая клеммочка, по сути.
Вот.
Ну и заметим, да, ну и совсем заметим, что бывает еще
такой случай, когда эта вершина вообще одна и та же.
Вот так еще могло быть.
Видите, да?
Но как бы это нас тоже устраивает, но просто вот
оговорка, что такая картинка тоже бывает.
Понятно, да?
Вот.
То есть, таким образом у нас получается, что реберная
двухсвязанность это отношение эквивалентности.
И, как следствие, существует понятие компонента реберной
двухсвязанности.
А теперь возникает вопрос.
Как мы видим, что реберная двухсвязанность
это отношение эквивалентности?
А теперь возникает вопрос.
Как же найти компоненты реберной двухсвязанности?
Ну, по сути, да.
Да, в данном случае все просто.
Надо просто удалить все мосты.
Вот.
То есть, мистическая, ну тут по-разному, вот действительно
как можно доказывать.
Ну, можно доказать, что это может быть, но это
не может быть.
Ну, можно доказать, что это может быть, но это
не может быть.
Ну, можно доказать пока простой факт, хотя бы
не знаю, насколько там поможет ли он нам полностью,
но такое утверждение.
Там, допустим, скажем, пусть, значит, у и в, пусть у
в это ребро.
Тогда, можно сказать так, у в мост, тогда и только
тогда, когда у и в в одной компоненте реберной
двухсвязанности.
Вот.
Можно, кстати, такую утверждение сравнивать.
Ну, действительно, заметив, да, что как-то да, странно
что-то, то есть, заметим, да, что если это мост, то
тогда я утверждаю, что между у и в единственный,
реберно, единственный вообще простой, то есть скажем
так, то есть между у и в могут быть разные, конечно,
реберно, простые пути, потому что мало ли там какие
циклы можно описывать.
Но я утверждаю, что все они проходят через у в.
Ну потому что как-то, наверное, если, ну вот, ну потому
что, раз это, потому что, как бы, если существует
Если существует путь между УЕВ, который не проходит через это ребро, то тогда получается, что это просто не мост, потому что как минимум между УЕВ все равно пройти можно, понимаете, да?
Тогда что это означает, да? То есть это означает, что если это мост, то тогда это заведомо...
Да, наоборот, не в одной компании.
Да.
Тогда они заведомо не в одной.
А теперь возникает вопрос. Если две вершины соединены ребром и находятся в разных компонентах реберной двусвязности, верно ли, что это мост?
Ну конечно верно, потому что удалим это ребром.
Да, Е, ну вот.
Вот.
Тогда предположим, что оказалось, что это не мост. Тогда между УЕВ существует какой-то путь. Ну вот, ура, мы нашли два пути между УЕВ, ребры не пересекающихся.
Все, вывод, это... Ну вот.
Так же, значит, получалось, что это не... Да.
Это не мост. Ну в общем-то и все.
Понятно, да?
Вот.
Ну вот, ну как бы, да, тут новая этика эта вопрос, насколько нам это поможет.
Потому что, в принципе, если вот так по ребрам скакать, то кажется тогда действительно, что... То есть, идея после этого кажется очевидным, да, что если мы идем по ребру в дерево ДФС, если это как бы одна компонента реберной двусвязности, то если это не мост, значит одна компонента продолжаем.
А если там, допустим, оказалась не одна, ну значит началась какая-то другая, значит там это мост и началась другая.
Ну правда, конечно, конкретно такой метод, конечно, возникает такую оговорку.
А почему не может быть так, когда вы идете ДФСом и у вас будет там, что вот это первая компонента, вот это какая-то вторая, вон там еще третья какая-то началась, вот тут еще началась какая-то четвертая, но тут неожиданно выяснилось, что эта четвертая, она на самом деле первая.
Сейчас, так мы же определяем, в какой компоненте относится вершина, только в тот момент, когда мы закончили вне ДФС.
Ну мы, я еще пока никакого алкоголитма не говорил.
Ну я пока говорил просто, что предположим, что мы для каждого ребра, вот там, с небес по факсу прислали мост это или нет.
Тогда вот я запускаю ДФС и вот иду по ребрам дерева ДФС и говорю, так, вот у меня там это типа одна компонента, ой, это другая.
И тут говорю, это третья, это четвертая.
А теперь возникает вопрос, а может какая-нибудь из этих последующих компонентов подает с первой, например, или со второй?
Ну, если мы прошли по какому-то мосту, в какую-то вершину, да?
Да.
То исходная вершина и вот новая, они будут лежать в одной компоненте.
Да, ну в принципе, да, в данном случае...
То есть, собственно, то же самое рассуждение, которое мы...
Да, ну в данном, да, в данном случае заметим, да, что действительно, если мы прошли откуда-то по мосту...
Да, ладно, то есть, просто ладно, видимо, просто нам это в вершинной двухсвязности будет чуть сложнее, видимо, тогда.
В вершинной двухсвязности там же это и действительно неправда.
Но там, но там все по-другому будет.
Ладно, так вот, значит, если мы выкинем...
То есть, действительно, если мы прошли вниз по мосту, то при удалении его граф распадется на под дерево, дерево DFS вот на этой вершине и все остальное.
Ну и тогда легко заметить, что никакие две вершины, значит, из этих разных частей точно в одной компоненте Рюбергной двухсвязности не лежат.
Вот, поэтому действительно, получается, если компонента поменялась, то она поменялась навсегда и можно, в принципе...
Вот.
И тогда в результате, то есть, на самом деле получается примерно, то есть, на самом деле код можно написать примерно следующим образом.
Ой, а не пришло ли на время немножко компьютера?
Вот.
Сейчас, я быстренько.
Вот.
Потому что...
Так.
Сейчас вы его быстренько.
Ну, я же говорю, что у нас как бы все единым миром будет мазано, поэтому...
Соответственно.
Вот.
Оп-оп-оп.
Оп-оп-оп, оп-оп-оп, оп-оп-оп, оп-оп-оп, оп-оп-оп, оп-оп-оп.
Блин.
Так, значит, это вот так.
Это вот так.
Телевизор включаем.
Так.
Телевизор.
Вот теперь хорошо.
Так, вот.
Так, а наша телевизор...
Так, а камера повернута.
Так, ой.
Немножко магии.
Так.
Вот.
Вот это.
Так.
Опа.
Так.
Вот.
Так.
Так.
Опа.
Так.
Ого.
Ой, красивая зелененькая винда.
Так.
Это новая желто-зеленая винда.
Окей.
Так, окей.
Теперь у нас есть красота.
А, точнее не в шуда.
Правильно воткнуть, если быть точнее.
Ну, давайте попробуем.
Так, что у нас тут есть?
Давайте новый файл.
C++, nex, nex.
Файл какой-то там.
Ой.
Так.
Так, второй курс.
Это первый курс.
А вот у нас наша папочка.
Чего?
А, у нас весна 23, господи.
Вот.
Так.
Ну ладно.
Создадим новую папочку и напишем заново.
Тут как бы в этом маге скорее.
Так.
Так.
Осень 2000.
Так.
У нас же весна, да?
Что?
Нет?
Зима.
Зима?
О боже.
Блин.
Господи, какой кошмар.
Ну да, да, да.
Так.
О, Евковт.
Да.
Такой, да.
Ученый Евковт.
Да.
Так.
Так.
Ну давайте, будем искать мосты.
Значит, поехали.
Значит, ну у нас там, допустим, есть какой-то граф.
Так, ну напоминаю, что у нас есть их величество цвета.
Но это там потом...
А, впрочем, пока они нам не нужны.
Так.
Ну, во-первых, запускаем.
Значит, ну у нас есть вот стандартный DFS, конечно,
который нам говорит.
Там user.atv равно.
Ну ладно, давайте пока оставим DFS там color.
DFS gray.
Ну или просто gray, ладно.
Так.
Так, потом for int у gray.atv.
Значит, if user.atv равно white.
То, что мы делаем.
Ну, во-первых, там запускаем DFS.atv.
Ну вот, и говорим, что если vu мост,
то мы что-то начинаем делать.
Значит, а именно.
Какая тут у нас будет технология?
Идея будет такая.
Мы заведем мистический stack.
Ну вот, первое, что мы будем делать, это вершину в stack пихать.
Значит, если здесь оказалось, что vu мост, то что нужно сделать.
Значит, vector int comb.
То есть я сейчас найду новую компоненту.
Вот, поняли, да?
Так, ладно, пишем по-русски.
Сохранить.
Comp как новую компоненту реберной двусвязности.
Вот, по идее, вот можно так.
А, ну и не забыть, конечно, в конце все-таки это непонятно зачем, но use.atv равно black.
То есть вот получается, что компоненты на самом деле реберной двусвязности можно искать вот таким образом,
если, конечно, кто-то с небес по факсу нам сообщает, является ли вершина vu мостом.
Вот, понятно, да?
Вот.
Ну а возникает вопрос, как же это сделать?
Ну правда, есть одна маленькая оговорщика.
Все ли компоненты реберной двусвязности мы так найдем?
Ну, как минимум, если граф не связан, мы и DFS будем запускать несколько раз.
Так что без ограничений общества можем считать, что граф связан.
Вот все ли мы так компоненты сохраним?
Да, все, да, корневую компоненту мы так не сохраним.
Поэтому в идеале, в идеале, на самом деле лучше было бы написать следующим образом.
Даже не если...
Потому что, я же говорю, у нас общая технология.
Это то же самое, зачем так странно будет искать компоненты сильной связи,
когда можно было вот эти вот два DFS от косарая написать.
Вот.
А у нас такой единый красивый сейчас технологий будет.
Потому что, на самом деле, если vu мост, то можно его просто сохранить как мост,
а можно на самом деле сделать вот так.
Значит, смотрите.
То есть наша технология будет работать скорее так.
Может быть так.
Обработали вершину и после этого сказали.
Ну, можно, конечно, отдельно сохранить, достать из стека потом корневую,
а можно сделать вот так.
Смотрите.
Если...
Вот нам надо уметь четко определять, вот это будет максимально общее,
если v корень там первая в своей компоненте,
то вот сделать вот так.
Вот, понятно?
Вот.
Да, нет, наверное.
Не слышу.
Да, наверное, может быть.
Да.
Вот.
Вот.
Ну, действительно, правда, то есть такая технология всегда будет работать,
если выполнено два условия.
Первое.
Компонента Рюберна до связанности образует связное подвешенное дерево в дереве DFS.
Ну, то есть заметим следующее, что внутри дерева DFS вот это вот должно образовывать
какой-то связанный подграф.
Понятно, да?
И более того, этого связанного подграфа должен быть единый корень.
Понимаете, да?
А, ну, впрочем, ладно, у любого связанного подграфа в дереве есть корень.
Ну, LCA.
Вот.
Но теперь вот возникает вопрос.
Вот поэтому я знаете, вот к чему я это все говорил.
Верно ли, что действительно любая компонента Рюберны до связанности
образует внутри дерева DFS связанный подграф?
Ну, то есть от любой вершины до другой можно по дереву пройти,
при этом проходя только через вершины той же компоненты Рюберны до связанности.
Так, ну-ка...
Все мосты это...
Ну, кто...
Ну, вот.
Ну, по сути, да.
Да, можно...
Да, ну ладно.
Если плясать от этого, то можно сказать, да, что...
Заметим следующее, что, как бы, если мы удалим все мосты,
то как бы дерево распадется на такие поддеревья.
Ну да.
По сути, каждый из этих деревьев, как мы уже убедились,
компоненты Рюберны до связанности, так что в принципе сработает.
Но тогда отсюда получается, что если мы научимся про вершину говорить,
что она первая в своей компоненте Рюберны до связанности, ну или нет...
А, кстати, такой оговор, когда это должно быть вот так.
Дай.
Так, вот.
Да, вот так должно быть.
Вот.
То есть сначала DFS и потом вот так.
То получается, что можно так компоненту найти.
Вот, понятно?
Ну, думаю, так требуется доказывать, что если условия, которые я сказал, выполнены,
то компоненты вот такими стеками реально найдутся.
Да, нет, наверное.
Так, есть кто живой вообще?
Ну, вроде понятно, да?
Или непонятно?
Все понятно, ну вот, хорошо.
Ну вот.
И тогда получается, ну вот.
Но остался только действительно интеллектуальный момент.
А как же все-таки понять, является ли вершина первой в своей компоненте?
Ну, тут два варианта, действительно.
Либо она...
Ну, действительно, оказывается, что либо она тогда, значит, просто корень.
То есть либо оказывается, что она корень, либо мы в нее попали по мосту, в дереве DFS.
Но как же нам это определить?
Если она первая в DFS, то, конечно, легко определить.
А как отличить мост от немоста?
Но для этого есть тоже не менее стандартная технология.
Так, что-то вы уж совсем зависаете.
Или эту технологию никто не знает?
Так, ну поднимите руки, кто умеет искать мосты.
Ну вот.
Ну вот, логично, да.
Чего?
Ну...
Такое.
Скорее, нет.
Ну тогда вот скорей.
Значит, давайте вводим.
Ну, во-первых, для того, чтобы это было, мы тогда должны считать, конечно, в этом DFS.
У нас вводим такое понятие таймы.
Ну, мы обсуждали, что это такое, да?
И, конечно же, введем понятие uptime.
Что такое uptime?
То есть uptime от V...
Значит, это минимальное такое, смотрите, внимание, таймин от какой-то вершины U.
Ну, тут по-разному можно вводить, но я введу так, смотрите.
Минимальное таймин от U такое, что WU это обратное ребро.
Обратное ребро.
В общем, обратное ребро именно вот в порядке WU.
То есть вот это вот предок.
Хотя не сильно принципиально, в общем-то.
Ну вот, WU значит обратное ребро.
Важно, что это именно обратное ребро.
Ну вот, а W потомок V.
Вот такое формальное определение я введу.
То есть меня интересует...
Вы как-то не так нас ты ищете?
Да. Или вы просто как-то не в этой технологии над этим задумывались?
А что для вас up? Хорошо, может я просто могу...
Ну да, видимо, да.
Да, если да. Хотя, на самом деле, да.
Когда-то этого не задумываешь над строгой информировкой этого всего.
Ну это да.
Но суть, в общем, действительно понятна.
Потому что мы когда задумываемся, вот это у нас ребро, это мост или нет.
Но тогда, значит, мы знаем, что у нас есть поддерево.
Если это не мост, то тогда, значит, у нас из этого поддерева есть какой-то путь вовне.
Но из этого поддерева мы можем выйти только...
Ну, выйти, просто сделать первый шаг куда-то вне этого поддерева.
Вне этого поддерева мы можем только через обратное ребро.
Потому что мы помним, у нас в графе никаких ребер, кроме дерева DFS и обратных ребер, нет.
То есть получается следующее, что ребро является мостом дерева DFS тогда и только тогда,
когда из этого поддерева не существует обратного ребра, ведущего куда-то выше этой вершины.
Понимаете, да?
Но тогда отсюда и получается.
То есть тогда автоматически получается такое красивое, красненькое утверждение.
Значит, смотрим. Начинается с черного.
Пусть УВ ребро дерева DFS.
Ребро дерева DFS В ребенок.
Ребенок.
Вот. Тогда...
Как сказать? Тогда...
Тогда, значит, оказывается, что УВ мост тогда и только тогда,
когда я утверждаю таймин от В больше либо равен.
Нет, это оборот.
Да, наоборот, меньше либо равен uptime от В.
Наоборот, uptime от В больше либо равен таймин.
Вот так.
Кстати, да, по этому определению uptime, кстати, может оказаться и плюс бесконечности.
Ну, понятно, что в реальном коде вы часто пишете просто uptime от В равно таймин от В,
потому что вас интересует можно ли меньше.
Но на самом деле, если вот формально писать, то можно написать плюс бесконечности.
Да, но действительно заметим, что...
Да, действительно заметим, что если УВ мост, то значит,
здесь все обратные ребра, если они есть, ведут куда-то внутрь этого под дерево,
и от таймин всех этих вершин больше либо равен, чем таймин этой.
Поэтому получается верно.
Вот.
Ну и наоборот, если он не мост, значит, существует какое-то обратное ребро выше,
и uptime вы найдете.
Ну, пересчитать uptime получается достаточно легко.
Но более того, на самом деле для нас ключевое будет другое.
Вот, утверждение.
То есть это называется В первое в своей, ну первое в смысле корень,
в своей компоненте реберной двусвязности.
Вот так.
Тогда и только тогда, когда uptime от В больше либо равен таймин от В.
Вот.
Ну, я более это аккуратно написал, потому что сюда попадают как вершины,
висящие на мосту, так и, собственно, первая вершина.
Ну, самая первая вершина, из которой мы DFS запускаем,
она же, очевидно, является первой в своей компоненте, правда?
Поэтому вот я вот так аккуратненько и написал.
А ее uptime равен?
Ну, ее uptime равен, ну, как бы у нее минимальный таймин.
Поэтому как бы uptime у нее чему-то равен, но как бы уж не меньше, чем таймин.
Вот.
Правда, тут, конечно, важная оговорка, когда вы считаете uptime,
то есть важно смотреть, что это было именно обратное ребро.
То есть когда вы просто перебираете ребра и смотрите,
то вы не должны пройти вот по этому ребру и учесть его как обратное,
потому что оно им не является.
Понимаете, да?
Ну вот, поэтому, на самом деле, для этого, значит, вам придется сделать так.
Ну, во-первых, насчитываем таймины.
Да, у нас есть stack, у нас есть, давайте уж полностью допишу тогда,
vector edfs color.
Там use it, что у нас еще есть?
Там vector int таймин и uptime.
Ну и, конечно, нам придется ввести вот эту техническую переменную current time.
Ну и понятно, что первое здесь, что мы делаем, да, current,
то есть там пишем, что, значит, time int от v равно current time плюс плюс.
Вот.
Но как теперь насчитывать uptime?
Ну uptime, в общем-то, насчитывается с помощью динамики на дереве,
ну и какой-то проверки самих ребер.
Но для этого нам придется сделать тут, написать какой-то ID-шник.
ID-шник, он будет, внимание, номер ребра.
Понимаете, да?
То есть правильнее здесь написать так.
Значит, for, даже мы и по-другому напишем, for edge e град v,
но это я для того, чтобы избавиться сразу от кратного ребра.
Значит, я сразу говорю, что если ID-шник этого ребра совпадает с тем,
по которому мы пришли, то мы просто его игнорируем.
Понимаете, да?
А теперь надо отличить, то есть у нас это может быть прямое ребро,
это может быть ребро дерева DFS, а может быть обратное ребро.
Как отличить эти три случая?
Ну да, но на самом деле это чуть-чуть там.
Получается, заметим, что...
Да, ну, во-первых, давайте int u равно, конечно, e.finish.
Если оказалось, что user tattoo равно white, то что это значит?
То это означает, что значит e ребро дерева DFS.
И мы запускаем DFS от u и, соответственно, ID-шника этого ребра.
И после этого не забываем пересчитать uptime.
А, я забыл инициализировать uptime.
Значит, пишем uptime от v равно infinity.
Ну, по нашему определению это пока infinity.
Ну, а дальше пишем uptime от v равно infinity.
Ну, а дальше пишем uptime от v, min равно uptime от u.
О, интересно, может быть в каком-нибудь там лохматом стандарте
будет операция min равно хоть в каком-нибудь языке.
Вот, так, ладно, надо поправить или поняточить такое.
Вот, значит, lz.
Значит, если оказалось user tattoo, значит, если оказалось, что цвет серый,
то тогда это означает, что e именно в этом направлении обратное ребро.
И что тогда это означает?
Ну, тогда это означает, что просто надо пересчитать uptime,
только в min равно подсунуть уже time in.
Ну, просто чисто по определению, понимаете, да?
Ну, и в противном случае, ну, следующий случай,
если ребро черное, ну уж пропишем честно, значит, тогда можно сказать,
что e это, так сказать, прямое ребро.
А, ну, тут вообще тогда ничего делать не надо,
потому что прямые ребра мы игнорили.
Ну, на самом деле мы договорились, что у нас прямых ребер нет вообще,
но по факту мы как бы каждое обратное ребро рассмотрим и как прямое.
Видите, да?
Так, но если оно не белое, не серое, не черное, то что тогда?
Ну, ладно, назовем это assert false, да.
Хотя, ладно, более продвинутые скажут throw exception там какой-нибудь.
Ну, потому что, смотрите, дело в том, что мы с вами договорились,
что бывает только обратное ребро, потому что нам интересно рассматривать
ребра не дерево DFS, только вверх.
Но реально DFS, когда будет перебирать ребра, он каждое ребро
рассмотрит все-таки как смотрящие вверх и как смотрящие вниз.
Вот, поэтому я все-таки на всякий случай прописал.
То есть для нас здесь важная теория о том, что в неориентированном графе
нет перекрестных ребер.
Собственно, этот assert это и символизирует.
Так что как будет по-английски перекрестное ребро?
Crossing edge.
А, throw crossing edge exception, да.
Слушайте, прям скороговорка.
Crossing edge exception.
Господи, crossing edge exception.
В нашем случае тут скорее broken math exception,
потому что мы же доказались на таких.
Нет, понимаете, сломанная математика это как-то очень глобально.
Знаете, это из цикла доказывается, да.
Доказывается, это почему так жизнь сложилась или так мир устроен.
Знаете, некоторые люди, к сожалению, вредные такие,
очень любят такие вопросы отвечать именно таким образом.
Ну, так жизнь сложилась.
Какое доказательство?
Какое доказательство?
Это он все кроме тебя и так уже давно знает.
То есть, знаете, в детском садике все позавтракали,
доказали, что мы от ожидания линейно, собственно, пошли обед.
Еще там погулять успели.
Все кроме тебя так жили.
Ну, ты что?
Все бывало такое, да?
Как это, да.
Как говорится, да.
Народ замечает, о чем я говорю, да.
Как говорят некоторые армяне.
Так.
Ну ладно.
Неважно.
Вот.
Правда, потом кто-то это говорит, а потом бабаха и в академу идет.
Ну ладно.
Так.
А, нет, самое главное.
Хорошо.
Аптайм-то я насчитал.
Зачем?
Пока это сферически аптайм-ваговыми.
Так, теперь вот как мне понять...
А, ну да, в общем-то теперь вот про вот это как понять,
что v первая в своей компоненте вершины для связности,
то это эквивалентно, это эквивалентно тому,
что f аптайм от v больше либо равно time in от v.
А, а вот это мы вообще уберем.
Вот.
Ну я не буду писать, как сохранять компоненту,
потому что там все что угодно можете сделать.
Можете, например, там пробежаться в номерах компонент,
перенумеровать компоненту новым номером,
можете там вектор векторов из компонентов сделать,
в общем, как угодно.
Понятно, да?
Ну в общем, тут в принципе это.
То есть вот таким вот нехитрым образом находим мы находим мы мосты
и точные сочленения.
А, ну ладно, мосты мы не находим, к сожалению.
Потому что, ну если очень хочется отметить именно мосты,
то в том же DFS лучше это сделать так.
Если оказалось, что, значит, аптайм от u больше либо равен аптайм от v,
то, значит, то там пишем что-то типа сохранить,
сохранить e как мост.
Вот, можно еще так.
Да, получается, ну я понимаю, что вы, наверное, пишете код чуть проще,
потому что вам нужно либо, ну потому что вам,
поднимите руки, кто когда-нибудь искал именно компоненты рюберной двусвязности.
Ух ты, а для чего вам это было надо?
Задача компонентной двусвязности.
Так.
Нет, я помню какая-то задача, которая ты использовал,
наверное, не помню.
Сэшка в серосах.
Сэшка только не в серосах.
Нет, там было совершенно это связано с нашей Сэшкой в серосах.
Не надо было.
Там было еще два региона подряд, по-моему, 16 и 17 годы,
когда в первый год дали поезд мостов, а во второй год поезд точек сошнений.
Значит, нам остальное было искать компоненты рюберной двусвязности.
Прикольно.
Да, нет, ну.
Нет, это дэшка прошлого.
Не последнего, а типа.
Как вообще?
В какой-то дэшке в серосах нам нужны были тоже компоненты рюберной двусвязности.
А, да.
Это была частичка.
Дополнительно 17 баллов дали.
Ну да, ну все-таки.
Да, да, да.
Ну бывает.
Ну всякое бывает.
Нет, если копать дальше, ладно, рюберная еще, да.
Да, конечно, немножко более сложно.
Можно было просто сказать, давайте удалим мосты и запустим там DFS покрасим.
Можно было и так.
Дополнительно DFS, которые ищут мосты вот таким простым способом.
Вот.
Так.
Ну что, перед дальнейшим перерыв нужен?
Да.
Ну да.
Ладно, идем дальше.
Так, ой, не зря я это все стираю.
А, нет, не зря.
Сейчас, может быть, мне надо было убрать компьютер, конечно.
Потому что сейчас мы снова займемся математикой.
Потому что начинается уровень медиум.
Это уровень медиума.
Точка сочленения и компоненты вершины двусвязности.
Ну первое определение, конечно, очевидно, да.
А, определение.
В, точка сочленения.
Если что?
Ри, да.
Если, да.
Если удаление ее инцидентных рейсбер.
Удаление ее инсидентных рейсбер.
Ребро инцидентно в вершине, если оно из нее торчит.
Ребро инцидентно в вершине, если оно из нее торчит.
Ребро инцидентно в вершине, если оно из нее торчит.
Ребро инцидентно в вершине, если оно из нее торчит.
Ребро А и Б.
Вершинно двусвязаны, если существуют, внимание, вершинно не пересекающиеся пути,
вообще не пересекающиеся, вершинно не пересекающиеся
между собой пути.
Ребро инцидентно в вершине, если существуют, внимание, вершинно не пересекающиеся пути,
вообще не пересекающиеся пути.
Ребро инцидентно в вершине, если существуют, внимание, вершинно не пересекающиеся пути.
Но если написать вот так аккуратно, то да, оказывается, что любое ребро все-таки вершинно двусвязано с самим собой,
потому что можно из вершины в себя взять пути и из вершины в себя, понимаете, да?
Вот, а, ну, конечно же, как вы уже гадались, да, утверждение, вершинная двусвязанность на ребрах
это отношение эквивалентности.
Красота, красота.
Теперь как мы это будем доказывать?
Ну вот, благодаря замороченному определению рефлексивность доказана.
Ну, симметричность, опять же, сама очевидна.
А как же доказать транзитивность?
Вот, на этот раз, да, если выбрать правильную технологию, то оно покрывает все.
Потому что берем вот эти два ребра, находим между ними вот эти два пути.
Берем третье ребро.
Мы знаем, что между этими двумя ребрами есть два вершины вершинно, обратите внимание,
на этот раз не пересекающиеся пути.
Поэтому их соединяем, поэтому можно тоже по этим путям пойти до первой вершины,
которая на этом цикле лежит.
Вот так и, ну, допустим, вот так.
Все, подсоединяемся опять к циклу клеммочками.
То есть, заметим, что конструкция вершинно простая, никаких повторов нет,
поэтому, в принципе, вот спокойно вот эти два пути мы можем уверенно рассмотреть.
Ну, или если клеммочка с этой стороны, то там какие-то просто,
один из этих путей будет содержать вот это ребро, но суть, в общем-то, одна.
Вот, понятно?
Ну, вот, то есть, заметим, что там могут быть всякие частные случаи,
то есть, на самом деле, это рассуждение одинаково хорошо проходит,
если, например, вот, бывает еще вот такой случай, например,
когда вот третье ребро, например, вот с этим связано.
Но это означает, что одна из клеммочек просто состоит из одной вершины, ничего страшного.
Понимаете, да?
Ну, вторая какая-нибудь там вот такая, уже и там не заморачиваемся.
Вот.
Итак, вершинная двусвязанность – это отношение эквивалентности.
Вот.
Ну, теперь мне интересный вопрос.
Как найти точки сочленения?
И как найти компоненты вершинной двусвязанности?
Таким же ДФС, как точки.
Ну, вот, для этого, для того, чтобы говорить о каком-то там ДФСе,
нужно, опять же, говорить о, как доказывать какие-то теоремы.
Ну, есть, конечно, простая теорема,
которая быстренько сведет нас с точки сочленения к поиску компонент вершины двусвязанности.
То есть, можно просто себе сказать утверждение.
В – точка сочленения.
Точка сочленения – я тогда и только тогда, когда В инцидентно ребрам хотя бы двух…
хотя бы двух различных…
компонент вершины двусвязанности.
Вот такое мистическое утверждение.
Если мы в него поверим, то как бы все.
Ищем компонент вершины двусвязанности,
и для каждой вершины помечаем, собственно, какие там ребра есть.
Спрашивается.
Но как же их доказать?
Рассмотрим вот эти два ребра.
Да, в одну сторону.
Если хотя бы жила была вершина,
у нее есть два ребра из разных компонентов вершины двусвязанности.
Тогда я утверждаю, что вот эти две вершины,
по удалению хотя бы этой вершины,
окажутся в разных компонентах связанности.
Почему?
Да просто потому, что если ее удалить, а путь типа есть,
то, ну, поздравляю, вот на этих ребрах найден простой цикл.
Ура!
Да, это в одну сторону.
В обратную сторону также.
Возьмем, типа, две соседние.
Ну да.
Да, здесь картинка может быть та же самая.
Удалим, значит, вершинку,
граф распался на компонент связанности.
Но, очевидно, с какими-то из этих хотя бы двумя компонентами связанности,
она связана ребром.
То есть развал оказался, вот тут такая компонента, допустим.
Тут такая.
Может, там еще какая-то есть, я не знаю.
Ну, вот хотя бы две есть.
Может, там еще что-нибудь там левое.
Вот.
Ну, тогда я утверждаю, что вот,
ну, я не знаю, конечно, за всю компоненту,
но вот эти ребра точно,
точно тогда из различных компонент вершины и двух связанностей.
Потому что в противном случае между ними был бы путь,
не прошадящий через эту вершину.
Ну, вот, и тогда противоречие с тем,
что они из разных компонент связанности.
Вот, понятно?
Вот.
Так что да, это утверждение простое.
А теперь возникает мести.
А теперь вот самое интересное.
А как же, что же представляете?
Все компоненты вершины двух связанностей,
как же их найти?
Как же это сделать?
Ну, вот здесь уже доказывать надо будет сильно аккуратнее,
потому что этой красивой картинки с мостами у нас уже нет.
Я помню, когда-то я провел эксперимент,
я просто, честно говоря, там, просто честно,
там прописал просто все жуткие леммы,
которые написаны в этом месте у Тарьяна в статье 75-го года.
Это было страшно.
Можно у вас вопрос?
Если мы рассмотрим граф,
в котором заменены вершины с реврами,
не поменены листами?
Ну, больно, и что?
Вот.
Тогда мы случайно не свидевали задачу?
Нет.
Ну, потому что точка сочетания,
ну, как сказать, точка сочетания превратится не в мост,
она превратится в какой-то...
То есть если у какой-то вершины степень 57,
то там на ее месте образуется там, я не знаю,
полный граф на 57 вершинах.
Мостами там не пахнет.
Значит, что же делать?
Ну, теперь давайте хотя бы мысли на это, конечно,
не совсем формально пока, но подумаем,
как вообще должны выглядеть компоненты вершины двусвязности.
Ну, во-первых, можно сразу заметить,
что любые две компоненты вершины двусвязности
пересекаются не более, чем по одной вершине, правда?
Так, ну, во-первых,
заметим, что компоненты вершины двусвязности
это связное множество, правда?
То есть если взять все ребра одной компоненты вершины двусвязности
и инцидентные вершины,
то получится связный подграф, правда?
Срочно?
Я, т.е., что-то я не знаю,
я утверждаю, что два таких связных подграфа,
они пересекаются между собой не более, чем по одной вершинке.
Ну, потому что, если у вас два связных подграфа пересекаются,
скажем, по двум вершинкам,
то тогда у нас в одном подграфе есть путь между ними
и в другом подграфе есть путь между ними,
и тогда получается, что это не две разные компоненты вершины двусвязности.
А теперь давайте мысленно можно составить такой граф,
смотрите, можно составить граф между вершинами
и компонентами вершины двусвязности.
Вот представьте себе, вот есть вот это,
а есть вот всякие вот компоненты вершины двусвязности.
Оп, там разные.
И между ними,
и мы будем, давайте, между вершиной компоненты
мы как бы нарисуем ребро,
если эта вершина имеет к этой компоненте вершины двусвязности отношение.
Граф может получиться, ну, более-менее произвольный.
По модулю одного важного факта.
Это будет дерево.
Ну, потому что, действительно, я утверждаю,
что не может быть вот такого экзотического зацикла быть не может.
Потому что если у нас обнаружился вот такой вот цикл,
то на самом деле можно убедиться, что это одна компонент вершины двусвязности.
Понятно, да?
То есть на самом деле вот такой вот граф, то есть он дерево.
Ну и можно сказать, что вершина является точкой сочленения,
если она связана ребрами с несколькими компонентами вершины двусвязности.
Ну вот как-то так это будет.
Там как-то вот так, может быть вот так, ну по-разному.
Понятно?
Вот.
Ну ладно, правда есть оговорка, что каждый компонент...
А, ну еще оговорка, что каждый компонент вершины двусвязности
связан хотя бы с двумя вершинами, естественно.
Ну потому что в ней есть хотя бы одно ребро.
Так.
Да, вопрос на понимание происходящего.
Как в науке называется компонента...
Такие как...
Смотри, бывает так, что компонент вершины двусвязности состоит из одного ребра.
Как в науке называется это ребро?
Что?
Мост.
Совершенно верно, да.
В науке это называется мост, да.
Просто определение.
Мост – это компонент вершины двусвязности.
Это ребро, который образует компонент вершины двусвязности из себя любимой.
Да.
Вот.
Можно еще таким определением пользоваться.
Да, не надо, конечно, но можно.
Но полезное такое свойство есть.
Вот.
То есть, в принципе, иногда в некоторых задачах полезно как минимум
воображать в себе существование такого дерева.
Может, в некоторых задачах даже полезно его даже строить.
Ну, там есть всякие кошмерские задачи.
Вот.
В первую очередь, тут вопрос, как найти компонент.
Ну, вот.
То есть, на самом деле, в некотором смысле это образует дерево.
То есть, по большому счету выглядит это примерно следующим образом.
То есть, на самом деле, получается, по крайней мере, себе на уровне неформального воображения
можно себе вообразить, что получается вот такой снеговичок.
Ну, такой разветляющийся снеговичок, конечно.
Ну, вот.
То есть, да-да, тут бывают вот эти вот мосты типа.
Ну, вот, соответственно.
Но это пока может быть немножко на не совсем формальном уровне.
То есть, ладно, мы-то с вами с этим работали, поэтому себе это достаточно уверенно вообразить можем.
Но как бы надо же доказать, представьте, вы пишете статью 75-го года,
когда вы это только что придумали, и как бы никто, кроме вас, этого вообще не знает, не понимает и вообще.
Ну, а свойства ДФС-а пока еще глубоко никто не копал.
То есть, как убедить людей, что действительно это все не рукомахание.
Там не просто какой-то язык очесания и тыканье в картинке.
И там, знаете, это древнегреческое тыканье в картинке с подписью «Смотри».
Нет. Ух ты. В древней Японии были математики?
Там были места, где там в добычке висели и типа…
Не знаю про математики, но картинки рисовать умею.
Ну, может.
Нет, ну скажем так, я ничего не знаю про математику в древней Японии.
Если честно, я не уверен, что мы сильно много знаем про древнюю Японию на самом деле.
Правда, про супердревнюю.
Потому что про математику мы знаем в древнегреческую, естественно.
Потому что первое время там все доказательства сводились действительно к нарисованию картинки «тыканье носом смотри».
Но потом они достать в какой-то момент все-таки пришли к тому, что это не совсем работает.
Потому что, да, особенно в геометрии, где как бы…
Да, ну вы уже опытные люди, вы знаете, что как бы нарисованная картинка в геометрии это еще не accepted.
Потому что, да, VA-47 считает, что картинку можно было и по-другому нарисовать.
Да, далеко не всегда вы там обвалились именно по точности и ПТЛ,
а просто потому что там нарисовали более правильную картинку.
Да, бывает такое.
Вот, ну это была геометрия.
Значит, а это… Ну, значит, как же тут доказывать что-то?
Ну, правда, тут это называется что, тут из этой картинки надо вывести.
Мы же хотим какой-то алгоритм доказать.
Мы хотим найти компоненты вершины двусвязности.
Но как мы их хотим найти?
Ну, во-первых, начнем с маленького утверждения.
Нам очень хочется сказать, что вот, что наверно, наверно, да,
хотя бы в каждой компоненты вершины двусвязности,
то есть если вы пересечете дерево ДФС и компоненты вершины двусвязности,
то очень хочется сказать, что вы получите связный подграф.
Хочется такое сказать?
Так вот, на самом деле, мистическое утверждение…
А давайте, вот, на этот раз, видимо, раз уж формализм, так напишу.
Потому что жалко.
Вот, знаете, вот, действительно, почему это уровень медиум?
Потому что вот при мостах мы не обязаны были об этом заморачиваться.
То есть потому что там как бы все, удали мосты и все очевидно.
А тут вот, тут нельзя удалить точки сочленения и сказать все хорошо.
В тот место этого приходится делать следующее.
Значит, утверждение.
Утверждение.
Значит, пересечение… Ну, вот.
Я утверждаю следующее.
Пересечение…
Пересечение…
Пересечение…
Пересечение…
Рюбер нот, дерево ДФС и произвольные компоненты
Вершинные двусвязности
Это связное дерево
Корень которого
Корень которого имеет ровно одного ребенка
Корень этого индуцируется деревом ДФС
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершинные двусвязности
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
Вершины
