Все, не рация иерархии, это такая смешная маленькая
тема.
Ну, по сути, она ровно про то, о чем ему и кажется.
Задача тупая, просто вот, чисто механическая на
C++.
Есть у вас список типов, вот такой, какие-то базы,
есть какой-то child, ну, шаблон тоже, наверное.
Необходимо как-то сгенерировать вот такую шнягу, иерархию,
то есть сделать, чтобы child наследовался от баз.
Звучит по-идиотски, правда?
Ну, как-то очень легко.
Вы делаете child шаблонным с паком, и все наследуете
и круто.
Но паков-то не было раньше, до 11-х плюсов.
Но есть еще одна задача.
Линейная иерархия, да, вот эта вот с, ой, скатер-ирархия
называется, ну, как бы скатер, а вот эта называется
линейная, потому что, ну, в линию.
И дан тип лист каких-то типов, нужно их друг за друга
наследовать.
То есть по цепочке один, другой, третий, четвертый,
пятый наследуют.
Ну, тоже пока не очень понятно, в каком виде, ну, что там,
просто как-то это заводим, как-то тоже шаблонный, ну,
CRTP какой-нибудь, вот что-нибудь такое.
Ну, да-да-да, от него наследуя, и все работает.
Казалось бы, детские задачи, но до C++11 самым таким модным
частным способом и единственным, пожалуй, генерировать скатер-ирархию
было следующее.
Все понятно, да, тривиально, как бы, тут, ну, элементарно.
Ну, тут, по сути, примерно так, как вы в третьей домашке
практиковались рекурсивные типо-спискам типов, которые
как пара хвост-голова, вот тут так по такому списку
типов рекурсивно идут, и какое-то вот это вот рекурсивные
ноды что-то делают, и в итоге наследуются от каких-то
холдеров, которые вот как раз и есть те базовые классы,
которые мы хотели.
А вот это ребенок.
Ну, и как бы, получилась скатер-ирархия.
Линейную тоже тут очень весело делали, как-то вот промежуточные
что-то.
Ну, в общем, как-то делали.
Зачем только?
Ну, можно уже догадаться, в принципе, но неважно.
Мы просто закодим это, и будет предельно понятно.
А что мы закодим, и зачем вообще все это, вот эта вот
абстрактная задача в вакууме, что-то от кого-то наследовать
линейно, там вот так вот распластать.
Вариантический селект, отличная мысль.
Нет.
Да, main driven, что нет, был policy driven.
Не открывался сайты, правда?
Окей.
Он на китайском открылся.
Я не знаю китайского.
По японскому.
Это другое, вы не понимаете.
Ну ладно, как хорошо, что я успел все выгрузить.
Вот она, наша любимая абстрактная фабрика.
А мы будем ее писать.
Ну как, генерировать ее, вот то, о чем я говорил.
Никто дома, скорее всего, не попытался ручками
погенерить.
Нет, отлично.
Внимание.
Вот есть тут какие-то интерфейсы.
Кошки, собаки, коровы.
Наверное, лучше сделать их абстрактными, да, в смысле
I дописать.
Ладно, пусть такие будут, мне так проще.
Да, вызов метода, издай звук, он как бы сразу, сразу
Copy&Write запускает.
Короче, вот это наши интерфейсы, cat, dog, cow.
А вот это у нас конкретные продукты, наследники этих
интерфейсов.
Мы хотим сгенерировать два класса.
Во-первых, абстрактную фабрику, вот эту, как тут
была GUI-фактория, вот у нее там должны быть методы.
CreateButton, CreateCheckBox.
Такие же у нас должны быть методы createCow, createDog,
createCat.
Ну и, в принципе, это все, что здесь требуется.
Вот тут нужно как-то каким-то образом сгенерировать
метод create для каждого элемента в этом паке интерфейсов.
Ну и на вход, мы там в тесте.
Test, test, test.
Вот, делается абстракт-фактория от cat, dog, cow.
Ожидается, что у них будут какие-то виртуальные методы.
Как мы это будем делать?
Давайте думать.
Сгенерировать для каждого типа в этом паке виртуальный
метод create что-то там.
Мы создадим сначала класс, который,
которого шаблонный параметр это тип.
Ну, мы интерфейс мы узнаем.
То есть, нулевой шаг.
To plate class interface, astract, overload.
Я его вот так назову.
Ну какая-то там нужная сигнатура.
А какая?
Ну, в целом, кажется, что мы пишем в факторе, да?
Интерфейс, наверное, надо возвращать.
Наверное, uniquePTR, хорошо бы.
Мы сейчас создавать объекты.
Создавать объекты, это просто factory, да?
Вот.
А здесь мы наследуемся от абстракт-продюсер многоточия.
Ну, точнее, interfaces.
Да.
И затем, ну, в идеале, наверное,
нужно наследоваться, типа,
приватным юзингом вытащить.
Окей.
Ну, даже без приватного.
Вопрос.
Можно ли делать вариатически?
Да, можно.
Можно.
Вопрос.
Как теперь из этой шняги вытащить нужный нам create?
Точка абстракт-продюсер, тип.
Как-то неудобно, да?
Ну, как есть.
А можно просто create в треугольных скобочках указать,
что мы хотим create-ить?
Можно написать внутри шаблонный метод.
To play a class interface.
Ну, наверное, и.
И, да.
Чтобы не было...
И.
И, unique-ptr-e-create.
Вот так мне нравится.
Только что сюда вписать теперь?
Блин, ну слишком легко.
Что слишком легко?
Есть.
Ладно.
Не знаю, зачем я в прошлом году здесь жизнь усложнял.
Вы молодцы.
Будем дальше себе жизнь усложнять.
Окей, так работает, в принципе.
Для факта лучше даже делать не надо,
но если бы это была, например, tuple или select,
то могла бы возникнуть...
Тю-тю-тю-тю.
Tuple дальше будем писать.
Всю беду увидим.
Можешь не говорить.
Tuple дальше напишем.
Небольшой.
Маленький.
И все увидим.
Не надо спейлерить.
Тихо.
Ты тоже собрался спейлерить.
Я услышал.
Не надо спейлерить.
Так.
Ну, кажется, мы написали, да?
Ну, то есть если сравнить по сложности,
что вот Александреску в свое время пришлось
вот такую штуку городить с какими-то макросами,
типа TypeList 1, TypeList 2,
ну, тут просто ужас.
А у нас все работает.
Ну, внимание, мы только что сгенерили
функцию, в которой сгенерили класс,
в котором много виртуальных методов,
причем, ну как бы, виртуальные методы
генерируются по запросу.
Да.
Я что-то видимо не понимаю.
У нас есть structure, abstract producer
и виртуальный метод.
Значит, мы видимо хотим,
чтобы от нас наследовались.
Да, это абстрактная фабрика. Это интерфейс такой, типа.
Давай не будем про кавариантность, это больная тема для плюсов, ничего хорошего не будет.
Ну, согласно, что мы сгенерировали интерфейс фабрики.
Вот как ровно на этой картинке? GUI factory create button, create checkbox.
Виртуальные функции.
Сейчас.
Непонятно, да, ничего?
А у нас есть интерфейс, который для...
Вот можем, наверное, сходу нажать?
Вот у нас передается...
Сейчас у нас есть интерфейс, интерфейс...
Так, я забыл. Вот так.
Какой интерфейс интерфейса?
Вирчер, конечно.
Да, на первый вирчер. Ну, абстракт-фактор это интерфейс.
Interfactory interface.
Ну, это интерфейс для фабрики, которая умеет производить набор каких-то продуктов.
Create button, create checkbox.
А можешь какой-то небольшой для мячиков списать, как можно реализовать интерфейс?
А, так это следующий шаг.
Ну, согласен, что интерфейс мы сделали.
А дальше есть вот эти вот twin factory и mac factory, конкретные.
Их мы тоже хотим генерить.
Потому что там код, как мы упоминали, неоднократно абсолютно однообразный.
Нужно написать new и какой-то конкретный класс.
Ну, в нашем случае там будет типа new...
Вот интерфейс у нас такие, а new будут new Sphinx, new Spaniel, new Black Angus.
Вот она, concrete factory.
Ей на вход уже вот к вопросу о type тепла, type листах и прочем.
Уже приходят два type тепла.
Ну, потому что два пака нельзя.
А нам нужны интерфейсы, чтобы понять, какие методы оверрайдить.
И имплементация, чтобы понять, а что вписывать в...
Ну, как бы что new делать, да?
Итак, ну, первый шаг, надо распаковать эти паки, согласны.
Вот это вот наша традиционная техника.
Type tuple, interfaces.
Теперь ворядик будет, это специализация.
Тут implementations, и мы сделали специализацию.
И уже можно какой-то код писать.
Абстракт-продюсер в тревольскомчике interfaces,
разве триточки должны быть внутри?
Или я не понял, что мы делаем?
Тебе не хватает практики с ворядиками.
Триточки можно написать внутри, тогда это будет значить...
Ну, давай скажем, что interfaces, это было A, B, C.
Если мы пишем вот так, это значит A, B, C.
Но тут же один аргумент, фигня.
А вот если мы пишем вот так вот,
это значит все вот это вот выражение разверни.
То есть будет A, B, C.
То есть мы отнаследовались от всех таких выражений с подставленным паком.
Ага, вот.
Давайте вы будете придумывать, как писать конкретную фабрику.
Собственно, презентация, это была подсказка.
Скатер-ерархия, чтобы нагенерить виртуальных методов.
Была линейная иерархия.
Ну, скатер-ерархию мы только что сделали.
Наверное, нужна линейная.
Кто выскажет идею, что делать?
Вот этот класс в итоге должен стать самым дочерним классом
в некоторой цепочке наследования,
где самый родительский будет наш интерфейс.
Не знаю, я хочу заубирать все методы.
Ну, окей, давайте так.
С точности до того, что мы делаем.
Давайте напишем конкретную специализацию руками для этого шаблона.
Тогда должно стать понятнее.
От частного переходим к общему.
Кет, дог.
Так, сейчас.
Как мы это будем писать?
Вот так.
Type list, ket, dog, cow.
Type tuple.
Type tuple, sphinx, spaniel, black angus.
Так.
Ну, конечно, они все определены.
Фиг знает где.
Давайте перенесем пониже.
Почему tuple и type tuple?
Потому что этот tuple это будет прям std tuple.
Мы будем писать std tuple потом.
Так, что я ожидаю, что вот этот шаблон мне сгенерит вот в такой специализации?
Так, что я ожидаю, что вот этот шаблон мне сгенерит вот в такой специализации?
Я ожидаю, во-первых, отнаследоваться от публичного abstract factory ket, dog, cow.
Во-вторых, я ожидаю, что все виртуальные функции будут имплеменчаны.
Какие здесь виртуальные функции?
Три create.
Три create.
Нам нужен какой-то класс, который берет пару интерфейса и конкрет-тайпер.
New sphinx.
Но сейчас мы пока притормозим коней.
А сейчас overwrite different return type.
Ну, смотрите, все сломалось.
Мы не можем понять, какую функцию мы overriding.
У нас множественное наследование.
Да?
Как сейчас иерархия выглядит, вы представляете?
Ну, вот можно руками.
А почему у нас нет anima, от которого был ket, dog, and cow у нас следует?
Это три совершенно отдельных иерархии.
Да, потому что весь смысл в этой GUI-факторе в том, что она две разные иерархии, умеет для них генерировать объекты.
Просто потому что это название не было контр-интерфейсировано?
Ну, да.
Если домашню что-то делал, это уже потому что там anima есть.
Да, тут другая ситуация. Тут независимых три иерархии.
Наверное, что в GUI пришло.
А не работает вот такой create, как мне нашептал Аркадий.
Его неудобно overriding.
Ну, то есть можно явно указать, что мы...
Да, ну вот можно.
По-моему так, да?
А, слушайте, какой private?
Конечно же protective должно быть.
Все равно не работает.
Ну, а что, как?
Ну, тут предложили, что можно указать явно, из какого parent мы overriding.
Так ведь по типу...
Ну, вот сейчас не видно. Почему?
Они только return type.
Да, они даже перегрузками друг друга не являются.
И все это наводит на какие-то стрёмные мысли, что неудобно.
Я категорически не рекомендую себя в такую ситуацию загонять никогда.
Давайте придумаем, как сделать эти штуки перегрузками друг друга.
Было предложение tag добавить в аргумент.
Вот tag, да. Ну, Данила все запылирил.
Какое еще предложение было?
Мы хотим три разных виртуальных функции.
Чистых виртуальных.
Давайте и для abstract-факторе напишем явную специализацию для CatDog, чтобы увидеть,
что мы хотим в итоге.
Сейчас где CatDog cow?
Ну, посмотрим. Сейчас так.
Сейчас. Что-то я закодился уже, да?
Вот здесь я хочу.
А если бы у нас...
Ну, просто кажется...
Наверное, была бы такая, что бы мы не делали.
Наверное, у нас была бы проблема, если бы у нас было бы сложнее,
были бы какие-нибудь аргументы конструктора.
Да, да, да.
Нет, подожди, нет. Можно, знаешь, как сделать, чтобы не торчало тегов никаких.
Можно написать...
Нет, нет, без тегов вообще.
Можно написать концепт STD из ConstructibleFrom.
И тип явно указать.
И это будет частью сигнатуры.
И она даст нам возможность...
Давай попроще. Что-то придумал лютое, закоди-то сам.
Давайте к остальной аудитории вернемся.
Я написал явно специализацию для CatDog-cow abstract-factor.
Должен получаться класс, который принципиальный и квалентен вот этому вот.
Но даже вот в таком виде какой-то бред получается. Согласны?
Как-то у нас три одинаковых функции Create, которые разные значения возвращают.
Это фигня. И вызывать...
Такого можно добиться, но неудобно.
Короче, надо как-то их разделить, чтобы они были перегрузками друг друга, но...
Но в целом одинаково.
Вот да, и непонятно, как вызывать.
То есть можно... Вот здесь у нас какая-то деталь имплементации на самом деле протекла.
Тут как-то странно позвали.
Я предлагаю другой подход.
Я предлагаю завести класс Tag.
Видели ли вы где-то Tag-based dispatching?
Да.
Да.
Как-то что-то слышал, но...
Сейчас.
Я забыл.
Да, в Uniclock точно есть.
Еще в Tuple, кажется, или где-то там Construct and Place.
Конструктор.
Внимание на экран.
У Uniclock есть три конструктора.
Всегда принимается mutex на вход.
Еще есть дополнительный аргумент deferlockt, trytolockt и adoptlockt.
Что это такое?
Adoptlockt не блокирует мир.
Ну да, считай, что он уже заблокирует.
Не суть важна.
Главное, что это просто пустые классы, в которых нет никаких данных, структурки,
которые используются чисто чтобы выбрать какое из поведений конструктора мы хотим.
Почему так делается?
Потому что конструкторы в C++ безымянные.
В Rasty он говорят с именами.
Но у нас тут такая же ситуация.
У нас три одинаковых имени, мы хотим как-то их разделить.
Ведем теги и будем по тегам в соответствии с тем, кого мы хотим создавать.
Вот так вот.
Теперь это три честных перегрузки друг друга.
И мы даже знаем, как вызвать одну из них.
Написать.
Create, tag, get.
Вот так вот.
Ага.
У меня есть желание сделать так, чтобы мы не передавали тегу get,
а чтобы get оно в часть крейта переместилось.
Нет.
Подавив себе такие желания, при процессоре зло.
Давай, Аркадий, без выпендрежных решений сегодня,
потому что хочется успеть и разойтись.
Поэтому тег мы сюда вбахиваем.
Это раз.
А два.
Внимание, смешная техника.
Вот сейчас все эти сигнатуры create находятся в разных областях видимости.
И поэтому, строго говоря, перегрузками друг друга не являются.
То есть никогда при лукапе имен мы не сможем одновременно
в области видимости найти все крейта, которые есть в этих родителях.
Понятную фразу сказал?
Давайте сделаем вот так.
Using родителей create.
Да, есть специальный синтаксис, чтобы из всех родителей
собрать все функции с вот таким именем, или переменные, или using, что угодно.
В общем, собрать все такие имена create из всех родителей
и затянуть их в текущую область видимости.
Вот такая тема.
Теперь, когда у нас эти имена есть в области видимости,
мы можем звать просто create от тега.
И все.
Нужная перегрузка будет выбрана среди вот этих вот, которые мы явно вытащили из-за...
Что-что? Что так лица скорчили?
Да, теперь если извне мы используем abstract factory,
можно create в треугольных скобочках указать.
А тут из-за протек тогда через тега не получится.
Ну окей, теги отлично.
Это нам сильно упростит ситуацию с concrete factory,
с которым мы в ступор встали, не понимая, что делать хотим.
Да, потому что ты не знаешь, какие у тебя будут интерфейсы в этом списке.
Их сколько годно много может быть.
Ну можно янами сделать?
Какой янам?
Нет, это тебе на вход дают, черт знает, какой набор интерфейсов.
Ты не знаешь, какой.
Сколько элементов янами делать, какие у них имена давать.
Более того, это тебе не поможет, потому что...
В чем смысл тегов?
В том, что это разные структуры
для каждого типа, что ты сюда подставляешь.
А соответственно, вот эти функции create с разным интерфейсом в треугольных скобках
будут перегрузками друг друга.
И можно выбрать конкретную перегрузку,
дернув create, но указав конкретный объект типа тега.
Вот точно так же, как вот здесь.
Можно выбрать конкретный конструктор mutex, который хочется,
указав, перекинув туда объект конкретного тега.
Дефер-лог-т, фигурные скобки.
Это одинаковая техника.
Она частая и полезная.
Итак.
Да нет, так вышло.
Кстати, тег еще...
Ну, это уже будет не совсем тег,
но в него можно передавать какие-нибудь аргументы для паблики,
чтобы она их могла обработать.
Можно, если...
Можно, если хочется.
Давайте лучше с конкретной факторой пытаемся ее побороть.
Пока что про...
Make unique.
Сработает? Сработало. Ура.
ConcreteFactory.
Для случая cat, dog, cow
я ожидаю следующее поведение.
Сгенерить три функции,
которые оверрайдят то, что было в интерфейсе,
и вернуть кого?
Сфинкса Спаниеля и Блэк-Энгуса.
Вот.
Для таких двух-тайп теплов я ожидаю такой результат увидеть принципиально.
А вот у нас в данном примере сейчас cat только один наследник.
Соответственно, у друга тоже только один,
но потенциально подразумеваем, что у нас катов, там,
всего на десяток,
и мы хотим, чтобы для всех этих десятков свой крейс создался.
Правильно принимать?
Для всех этих десятков свой крейс? Ну да.
Хоть тысячу, хоть миллион.
В этом суть того, чем мы занимаемся. Мы генерируем иерархию.
Итак, вот так должно быть на маленьком примере.
Общий случай. Как мы будем действовать?
Мы наследуемся публичного Abstract Factory Interfaces.
Если мы прямо сейчас, прямо здесь наследуемся от Publick,
типа от Abstract Factory, то как мы зауверрайдим?
Вот здесь же мы не можем как-то взять и магическим образом написать все эти методы.
А, в этом дело. Сейчас.
Видимо, нужно раскручиваться по регурсии и имплимитировать это одно.
Да.
Пишем специализацию, отрезаем Implementation по куску.
Зачем?
И имплимитируем здесь Mekaray и наследуемся от Beset Handler.
Сейчас. Зачем нам по регурсии что-то раскручивать здесь?
Потому что это сработает.
Нужно определить виртуальные методы.
А мы можем определить виртуальные методы только не шаблонно.
То есть мы можем делать внутри шаблонного класса, но сам Mekaray не может быть шаблоном.
Не-не-не. Это я понимаю. Я пока не понял, зачем.
Нет, мы, конечно, можем, как в прошлый раз, делать прослойбы между виртуальным методом и...
Да.
Но...
Ну теперь здесь у нас некрасиво.
Здесь какой-то один факт, первый, по названию непонятно.
Да сейчас оберток навернем каких-нибудь и все будет нормально.
Это первое, что пришло в голову.
Но в общем и целом пользователь с Concrete Factory вообще никак не взаимодействует, кроме как создать его.
И все.
Да, но у нас здесь, кажется, сразу есть небольшая проблема.
В Concrete Factory, допустим, у нас есть почка и иерархия наследования, скажем, ну не знаю, A, B, C, D.
И Concrete Factory, она же может...
Ну сейчас нет, наверное, она даже на более раннем этапе была.
Может ли у нас такое быть, что у нас есть одинаковые шаблонные документы?
В этом списке?
Да.
Нет.
Не может.
Ну ты тамашку какую-нибудь решаешь.
Вот там есть задача, где там надо поюникать, посортить списки.
Ну вот если надо...
Я не понимаю, что можно. Я говорю, что может ли юзер, в смысле не по ошибке, намерен передать...
Это бессмысленно.
Нет, не может. Все, давай считать, что не может, и таких глупостей не думать.
Да, задавите каратора.
Давайте не думать о таких глупостях.
Что тут не хватает?
От наследовательного Crypt Factory с отрезанными глупами.
У нас получается, что мы явно никогда не наследуемся от Abstract Factory.
Нет, надо. Ну сейчас мы ничего не оверрайдим, вот эта ошибка компиляции будет так-то.
А если наследоваться еще одной только Abstract Factory, которая...
Нет, нам нужно сначала...
Вот здесь...
Да, вот здесь мы наследуемся от Abstract Factory только одной.
Ну так это не то, что мы ожидаем.
Это не то, что мы ожидаем, да.
Мы хотим уметь скастить Concrete Factory от всех параметров сразу.
Мы хотим, чтобы работал вот такой код.
Ну, короче, можно такой костыль навернуть.
Давайте внимательно на этот код посмотрим.
Уже мы с тегом разобрались, пришла пора.
Вот видите, это Unique PTR на Abstract Factory.
А туда мы засовываем что-то через Make Unique Concrete Factory.
Что?
Ну это смысл...
Это смысл паттерна Abstract Factory.
У тебя где-то написан какой-то код.
Minecraft Spawner Spawn Mobs.
Если бы Minecraft был написан на C.
Ну там плюсы добавили, этим все испортили.
И тут мы хотим сделать switch, create.
Там по интерфейсу, cut.
Ну глупый пример получается, но давайте считать, что там...
Ну какой-нибудь интерфейс моб был, или энимул, или еще что-нибудь.
Ну план вот такой, да, вообще использование Abstract Factory.
Вы где-то создаете конкретную factory,
где вы знаете, какие вы хотите наследники.
Cat, dog и cow.
Потом это передаете в какой-то код,
который уже не знает, каких вы наследников используете.
И происходит OP.
Наследование полиморфизма, инкапсуляция.
Вы сокрыли детали того, кого вы там спауните в этом спаунере.
Каких именно котов.
Ну в этом смысл.
Поэтому наша общая Concrete Factory
вся целиком должна наследовать Abstract Factory.
Нельзя на каждом уровне иерархии наследовать ее кусочек.
Итак.
Что?
Давайте так и сделаем.
Это хороший вариант.
Потому что все то же самое, что здесь написано сейчас у нас,
можно сделать через виртуальное наследование.
Что мы хотели сюда написать?
Знаете, это зашло достаточно далеко.
Давайте, ладно, продолжим без врапера.
Нет, виртуальное наследование делает все дороже.
Нет, тут виртуальных вызовов ровно столько же,
сколько бы если бы вы их руками написали.
Zero Cost.
Если виртуальное наследование бахнуть,
уже не Zero Cost.
Ой, ну да.
All Interfaces вот так надо.
Type to Pal.
Вот так, вот так.
Вот так.
И кажется мы в шоколаде, да?
Внимание, мы написали...
Вы не передали, нужно передать человеку о наследовании.
Да, конечно.
Здесь нужно прокинуть.
А вот я прокинул All Interfaces.
И при наследовании нужно прокинуть наследника.
Наследник, ну вот этот торт мы наследуемся.
Да.
Любите шаблоны?
Я их люблю.
Ну вот с такие моменты я начинаю делать вот это вот мое любимое.
Потому что я не могу читать, что тут написано, если честно.
Вот так стало чуть полегче.
Да, есть у нас на работе...
Есть у нас на работе люди, которые вот так мне отвечают на вопрос,
почему у нас лимит 135 символов в Clang-формате.
Ну что тебе, просто купи монитор побольше.
Что, какие проблемы?
Да.
Окей, сейчас примерно понятно, что происходит.
Паки отщипываем, All Interfaces прокидываем.
Надеюсь, тем, кто сидит молча, тоже хоть чуть-чуть понятно.
По-моему, не квадрат.
Потому что мы сделали по сути ровно то, что на этом слайде.
Тут предлагали это с какими-то там промежуточными типами,
но мы вот просто в лоб пошли и сделали.
Вот, линейная иерархия.
В конце наша абстракт-факторе, в корне там что-то.
Знаете, единственное, что...
В принципе, да, давайте запустим.
Вот тут закомментируем про Tupel.
И попробуем запустить.
Во-первых, оно скомпилировалось,
во-вторых, написало Sphinx.
А что я тут пишу?
Видите?
Работает.
Меняем на Kao.
Какой TypeID напишет?
Black Angle?
Не знаю. TypeID это...
Implementation Define какая-то штука.
Не интересно.
Стандарт не может требовать, что у тебя TypeID.name выводит.
Вас не смущает, да? TypeID.name печатает,
какой на самом деле тип в runtime лежит под этой штукой.
Мне просто было лень писать метод MakeSound
и вписывать там Meow и Moo всякие, как обычно делают.
Но по сути, это ровно то, что ожидали, то и получили.
Мы чисто по интерфейсу абстракт-факторе
и вернули Create для коровы и получили Black Angle,
не зная, что на самом деле будет.
Теперь в чем понт?
Мы добавляем какой-то новый интерфейс
в всю эту иерархию, наш прекрасный класс.
Просто ее сюда дописываем, сюда дописываем то, что нужно,
и дальше весь код продолжает работать.
Прекрасная идея. Давайте удалим собаку.
А, тут не было лукавства.
А, тут было лукавство, смотрите.
Мы забыли удалить эту штуку.
Ой, обманка, но вы повелись, ха-ха.
Ну, все равно работает.
Можно обернуть кучу оберток, и все будет нормально.
Обертки.
Ну, юзинги, обертки и там всякие.
Все сделайте, если захотите.
Ну, так давайте вырежем собаку.
Время к концу. Давайте вырежем собаку.
Почему бы и нет.
Ну, сбилделось.
И она написала. Sphinx.
А может Create по-другому вызвать?
Да, сейчас мы его явно через этот Black Angle.
Да, давайте вернемся к той идее классной,
что вообще-то мы хотим вот так вызывать.
Будет ли это работать?
Нифига, работает.
А?
А, неудачный кет.
Ну, потому что мы везде публичное наследование бахнули.
Ну, вот тут вопрос, почему это сработало?
Почему?
У нас в самой Abstract Factory еще вот эта штука была.
А, ну нет, окей, здесь понятно, почему работает.
Просто вот работает и все.
Да.
Private, public.
Тыры-пыры. Ну, тут можно еще много чего запрятать.
Давайте считать...
У нас остается беда еще, что мы публично наследуемся
от кусков имплементации, хотя бы private.
Но при этом нам нужно все еще публично...
Но при этом кускок один нашей имплементации
наследуется Abstract Factory и он уже...
Смотри, да, мы не можем здесь сделать не публичное наследование,
потому что тогда мы не сможем прикастить вот в этой строчке
Concrete Factory, Abstract Factory.
Не можем, не мы...
Чего?
А, явно оператор каста можно написать, но это, конечно, дичь.
Ну, например.
Ну, это все равно неудобно.
Короче, основной идею вы поняли, правда?
А дальше ее можно крутить в очень много разных направлений.
Давайте сейчас не будем вот это вот докручивать,
потому что на практике вы такой не встретите,
если вы не будете его крутить.
И мы уже все это уже мыслим,
потому что мы все это уже мыслим,
и мы не будем вот это вот докручивать,
потому что на практике вы такой не встретите нигде,
только в книжке Александреско.
А зато покрутим тюпл. Я хочу написать стд тюпл.
Мне скучно этим прекрасным вечером, субботним.
Хочу вот такой тюпл, чтобы он работал.
Сможете придумать?
Короче, сначала мы создаем тип tuple-leaf,
у которого два шаблонных параметра
и size t index.
Индекс нужен для того, чтобы можно было
иметь в себе одинаковый тип,
и при этом можно было заделюсить,
какое имя, хотя бы по индексу.
Вот. Ну там, не знаю, какой-нибудь метод
фигу написать, фигу.
Затем мы задаем
template class t tuple-base
просто форму декларации,
просто декларация без
struct tuple-base.
Дальше значим. Затем template class многоточие ats,
еще size t многоточие indexes,
tuple-base под
сейчас.
Наверное, нужно все-таки,
чтобы это нормально работало,
нужно в декларации
class t и class...
ну еще оставить pack в декларации.
Просто class многоточие, кажется.
Давайте просто вот так сделаем.
Теперь мы...
ОК.
Да, хорошая мысль.
Integer sequences от...
Сначала integer sequences,
потом...
Давай просто index sequences.
Ну да, index sequences.
Из...
Да.
И эта штука публично
наследуется от...
Нужно вывести по голове.
Зачем по голове выводить?
Все готово.
Мы можем теперь публично наследоваться
от tuple-leaf,
s и s многоточие.
Скатер иерархия.
Тут неважно, как наследоваться.
Вот.
И теперь мы в tuple
наследуемся от
tuple-base ts...
Нет, первой sequence нет.
Ура!
Что мы наколдовали!
По обоим одновременно.
Если вы не знали, что так можно делать,
то сегодня узнали.
Можно в любом выражении,
в любом вообще выражении,
написать сколько угодно паков много,
но все одинаковые длины.
Потом, после этого выражения,
написать троиточие, и оно все у вас развернется.
Линея.
Не каждая с каждой, а как зип.
Зип в питоне.
Да.
Это так работает.
А?
Проверка на одинаковую длину.
Отлично.
В tuple-leaf у нас будет еще значение храниться.
В tuple-leaf будет храниться значение, да.
Теперь.
Теперь я хочу гетать по типу
и гетать по индексу.
А нужно, наверное,
сделать один класс,
который касается tuple-leaf.
А, нельзя специализация.
Тут придется
мучиться линейным поиском.
Можно просто перегрузку.
Тогда Даня-то знает все.
Слышали идею
кто-нибудь?
Что ты сделал тегом?
Мы хотим гет сделать от типа и от индекса.
И то, и другое?
Нет.
Смотри.
Это тоже самое хочется.
Можно просто завести две перегрузки.
Перегрузка тега от индекса.
Пока сделаем по индексу, потом подумаем.
Ладно, давайте писать.
Type.
Одновременно.
Нет, типы могут быть одинаковыми,
но для этого мы сделали индекс.
Если ожидание такое, что если мы написали tuple
с несколькими разными типами,
то у нас будет ошибка.
Это стандартный tuple так работает,
если кто-то не знал.
Итак.
Есть раз, есть два.
Нет, конечно.
Сейчас идея, тема всего происходящего,
это генерация иерархий.
Тепла во многих стандартных библиотеках,
она выглядит ровно так же, как Александреску
20 лет назад предложил генерировать.
Мы с каторой иерархию сейчас сделали.
А теперь нам нужно диспетчеризироваться.
Опять же, такая же проблема,
как с create.
Есть метод byType, который вернет нам value.
Но вопрос, какую конкретную value мы хотим получить?
Чувствуете аналогию с create?
Tag. Просто по тегу делаем так,
что они все друг к другу к перегрузке.
И с каким тегом вызвали, то и получим.
Я подумал, мне лучше совсем чуть-чуть
сделать вместо этого один метод.
Гет лип,
у которого return type
найдет
тип листка,
полный.
Зачем?
Если мы тюпл протокол делаем,
тогда так будет чуть-чуть попроще, наверное.
Не думая о сложном, думая о простом.
Усложнить всегда в себе жизнь можно.
Как вы могли уже понять по нашим домашкам,
там всегда можно сделать легко, просто и быстро,
а можно начать усложнять себе жизнь
и растягивать с часа до 2-3-8 часов время решения.
И его тоже.
Давайте сейчас не будем,
у нас осталось буквально 10 минут.
Ну что,
у нас осталось, чтобы Get работал.
Но я думаю, вам очевидно. Или нет?
Да.
Только это там
классный
test, туда-сюда,
sound,
тюп и
так, да?
И значит за фронтаем.
Шедует название пака.
У-у-у-у.
Сейчас вообще тогда это будет по шаблонам определять.
Нет, так не работает.
Ладно, у нас же тут ADL.
Ребят, у нас тут ADL сегодня, да?
Давайте прямо здесь и объявим.
Пусть ADL нам ее находит.
Не нужен теперь, да.
Просто себя принимаем.
Видите, да?
Нишен прямо в классе.
И такой же для
AST.
Только непонятно, какой тип мы вернем.
Но я говорю, что мы вернем автоамперсант
и всем становится сразу спокойно.
Неважно.
Я сейчас полностью забил на перфект форвардинг.
Это...
Кажется, вообще во всем курсе метапроги
сейчас нигде ни разу не расписывается подробно,
как правильно перфект форвардить все.
Возможно, стоит один раз это разобрать, но явно не сегодня.
Ну, это раз, во-вторых, везде форвард,
еще noexept от noexept от весь код функций,
ну и еще там пару деталей.
А requires requires весь код функции
тоже надо написать.
Итак, смотрите, оно компилируется.
Если в факторе...
Нет, это нужно не для чтения ошибок,
а для...
Да, SFINAE friendly overload resolution.
Ну вот, работает. Записали по
типу, достали по индексу.
Внезапно. Ларчик просто открывался.
На этом предлагаю закончить...
