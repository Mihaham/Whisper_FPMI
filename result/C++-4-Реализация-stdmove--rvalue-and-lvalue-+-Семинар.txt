Да. Параграмм 10.2. Значит, напоминаю, мы закончили в прошлый раз на том, что реализовали move
конструктор и move оператор присваивания для строк. Напоминаю еще более общую картину. У нас
у нас есть несколько проблем. У нас было несколько проблем, ради которых мы ввели волшебную функцию move,
которая каким-то чудом вместо того, чтобы копировать объект, умеет его перемещать. Ну,
вызов этой функции приводит к тому, что чудо какое-то происходит, и объект перемещается,
чтобы это не значило. Дальше мы ничего не поняли о том, как она работает. Вот,
сейчас давайте я допишу, значит, что мы тут делаем. String copy равно std move от str,
дальше swap с этой копией и return this. Вот, проверьте быстренько, все ли я правильно воспроизвел. Вроде
все правильно. Вот, пояснять я сейчас не буду, что здесь написано, потому что мы на этом закончили в
прошлый раз. Значит, мы сказали дальше, что чтобы эта магия работала для своих типов, нужно для
них поддержать особые методы. Значит, особые методы – это move конструктор и move оператор
присваивания. Move конструктор – это штука, которая вызывается, когда вы пишете string a равно std move
от другой строки, а move оператор присваивания – это когда вы делаете присваивание a равно std move
от другой строки. Вот. Здесь у нас есть вот такой моментик, непонятно, что это такое. Но утверждается,
что если закрыть на это глаза и воспринимать это как еще одно волшебное заклинание, пока непонятно,
что все будет нормально происходить. Вот это непонятно. Нам пока непонятно, что это такое,
и непонятно, что вот это такое. Но это какие-то заклинания, которые работают, и не трогай,
что называется. Ну, это тип, да. Ну, что это за тип такой? Понятно, что это тип, так называется. Но
откуда берется этот тип и что он означает? Непонятно. Вот. Ну, да, по всей видимости, да,
потому что это как бы из вот написанного. Можно догадаться, что, наверное, после std move
получается такой тип. Вот. Ну ладно. Короче, вот если так написать, то будет работать. Теперь,
прежде чем копать глубже и, значит, переходить на уровень средней школы, ну, то есть, прежде
чем начать разбираться в том, что это такое, значит, наша сегодняшняя цель – понять,
что это за тип формально и что он умеет, откуда он берется, а также понять, что делает std move
на самом деле. Вот. План на сегодня, ну, на пару, на вот эту примерно такой. Вот если мы за сегодня
успеем, каждый из вас успеет понять досконально, что это за тип, а также что реально делает move,
это будет победа. Маленькая победа. За пару… два урока. 45-минутных, в смысле. За одну пару,
да. А потом придет Федя и будет рассказывать вам про вывод типов. Так. Какой Федя? Какой Федя
было лучше? Да что такое этот ваш Федя? Так, господа, прежде чем начать разбираться в том,
как это работает, нужно вот еще что сказать. Вот это, ну, это я уже говорил, это называется
move constructor, это называется move assignment operator. А что было бы, если бы я не написал, не вообще вот,
ну, стринг бы реализовал как раньше и пользовался бы функцией std move для своего стринга? Что бы
тогда было? Тогда бы все работало как раньше, а именно было бы все время копирование вместо
move'а. Значит, первое, что надо понимать, если вы для своего класса реализовали copy constructor и
copy assignment operator, но ничего даже не сказали про вот эти два, то для вашего класса операция move
будет работать как копирование. То есть, если у вас в классе нету вот этих методов, то вместо них
будут соответствующие копирующие вызываться. Это значит, что ваш класс просто не поддерживает
move семантику. Но это для обратной совместимости сделано, потому что все это, вы же понимаете,
что это все начиная с C++11. Вообще, на самом деле, так интересно прям вот наблюдать такую вот смену
поколений. Я себя чувствую таким стариком, когда рассказываю вот про это, потому что 11 год, как раз
когда я поступил на первый курс, и когда я поступил на первый курс, у нас препод, он был одним из немногих
людей в России, кто в этом разбирался, он работал в Яндексе и делал там доклад типа, это вообще
ноу-хау, вот смотрите, как теперь можно делать. И он пришел и нам про это стал рассказывать, мы ничего
не поняли вообще. Вот, но он рассказывал, что это вообще так круто, так круто, так круто, вот смотрите,
как клево. Мы сидели такие, что ты несешь, вообще какая move семантика, господи, что они там выдумывали
в этом C++. Вот, а сейчас это база, то есть это все знают. Ну то есть, сейчас это реально вот прошло,
ну сколько прошло, 12, ну 11 лет, считайте, прошло полных, и с тех пор это реально такая штука,
которую на всех собесах спрашивают, типа это обязательно знать надо, иначе какой вы C++
разработчик. То есть, прям вот, понимаете, насколько мир меняется быстро. Поступил бы я на год раньше,
чем, да, так до этого бы вообще еще не было. Ну тогда это обсуждали, ну как мы сейчас говорим,
вот там C++ 23, им добавят такую-то штуку flat map, и она, наверное, будет так круто работать,
но пока никто ничего о ней не знает, и вот только там какие-то люди на конференциях докладывают
что-то про нее. Вот, вот тогда это была move семантика, вот примерно в таком статусе. Так вот,
если вы не определили свою классу move операции, то они будут работать как копирующие операции,
но тут есть сложные условия, ну я уж не буду ради этого открывать cpp-reference, но вы сами откроете,
а есть, вот раньше было правило трех, а теперь будет правило пяти. Вот раньше было rule of three,
теперь будет rule of five. Да, значит, что, а, это было сделано для обратной совместимости, почему? Ну
потому что, если вы человек, который ничего не знает о move семантике, то вы можете писать как
раньше, и оно будет работать как раньше. Вот как это, принцип такой, не сломай. Вот, то есть,
вы можете на c++11 писать как будто вы ничего не знаете о move семантике, и даже если люди будут
использовать sdmove над вашими типами, они будут просто работать как раньше, будут просто копировать,
ну как и раньше. Вот, но если вы решили использовать эту фичу и написали, то вот у вас может быть выигрыш
эффективности. Так вот, что говорит правило пяти, начиная с c++11, оно говорит, ну то же самое,
что и правило трех, ну можно догадаться, что оно говорит, если вы помните, что говорит правило
трех. Правило трех, напоминаю, говорит, что если в вашем классе реализован нетривиальный копи-конструктор,
копи-оператор присваивания или деструктор, хоть что-то одно из этого, то нужно реализовать все три.
Что говорит правило пяти, оно говорит, если в вашем классе реализован или копи-конструктор, или копи-оператор
присваивания, или деструктор, или move-конструктор, или move-оператор присваивания, хоть что-то одного из
этого, то надо реализовать все пять. Ну, в крайнем случае, можно не реализовать эти два, если вам
наплевать на производительность, но желательно реализовать все пять. Тут есть следующая, еще одна
довольно интересная история с тем, что правило трех, как известно, не является частью прям стандарта,
то есть это не ошибка компиляции, если вы реализовали копи-конструктор, например, но не реализовали
копи-оператор присваивания. Вот, очевидно. На самом деле, это была большая плошность комитета, что они
не сделали это ошибкой компиляции, они пожалели об этом спустя, ну, уже довольно скоро, потому что
стало понятно, что это штука, которую нужно было просто добавить, ну, как в стандарт, как нельзя
так писать и все, и люди бы не делали ошибок, и не было бы вот этих вот сообщений в октябре в чате
первого курса каждый год. А почему у меня все упало с сегментейшн фолтом? Я что, что-то неправильно
сделал, когда стэк писал свой? Вот, ну, примерно потому что люди написали копи-конструктор, а про
копи-оператор присваивания забыли. А? Что? Ну, на основе люди пишут стэк до того, как проходят опы, и это
проблема. Вот. А сейчас эту ЦЕ не могут добавить, потому что все сломается, потому что обратная
совместимость сломается, то есть они поняли, что нужно было сделать эту ошибку компиляции, но уже не
могут. Но в c++11 все постарались золотать дыры, как могли. Вот. Ну, ворнинг, наверное, есть, но в c++11
сделано следующее. Если вы, во-первых, если у вас, ну, в нулевых сначала, move-конструктор и move-оператор
присваивания умеют тоже генерироваться копилятором внезапно. То есть вообще-то я могу написать вот здесь
равно дефолт и здесь написать равно дефолт. Вопрос. Как вы думаете, что делают move-конструктор и move-оператор
присваивания по умолчанию сгенерированного? Нет. Да, да, да, вот. Все то же самое. Вот человек, что у полей
вызывают. Ну, move. Да, да, вот. Все, человек правильно. Надо, вот, хороший, хороший. Мыслишь, как комитет, чтобы, чтобы... Надо
мыслить, надо мыслить, как комитет постнартизации. Значит, что бы должен делать, что бы должен делать... Да, на вкус, как комитет пахнет, как комитет.
Наверное, мы комитет постнартизации с вами. Что должен делать move-оператор присваивания и move-конструктор по умолчанию?
Вызывать move у всех полей просто. Ну, то есть, если копирующий конструктор по умолчанию он просто говорит,
вот это вот все, и на этом заканчу деятельность, как бы работал copy-конструктор, не равно default, он бы просто сделал вот это
copy этого, это copy этого, это copy этого и пустое тело. Так? Что бы сделать... И, конечно, это неправильно бы для строк
работало. Что сделает move-конструктор по умолчанию? Он сделает R, std-move от str R, scz, std-move от str scz, cap, std-move
от str cap. Что сделает оператор присваивания по умолчанию? То же самое, он просто сделает каждое поле
присваивания std-move от соответствующего поля там. Будет ли это корректно работать для строк?
Конечно же нет, потому что от этого поля целые строки не очистятся. Тут работает следующее правило,
то правило, которое я говорил про то, что если move-операции у типов нет, то они работают как
копирующие. Это указатель, а это целые числа. Для них move-операция не определена. Вот это, блин,
очень важно понятие запомнить, потому что будет половина из вас в этом ошибаться и чушь какую-то
писать и говорить. Вот если у вас типы примитивные, целые числа, даблы, указатели, то есть не классовые,
то для них move-ающая операция работает как копирующая. От того, что я сделал один int равно
std-move другой int, второй int нулем не станет. Он просто скопируется, потому что для него копирование
то же самое, что move. Поэтому для строки, для нашей move-конструктор работать будет так же,
как по умолчанию. Он работать будет так же, как и копи-конструктор по умолчанию, то есть неправильно.
То есть у вас будет просто два указателя на одно и то же и два одинаковых числа. То же самое с
оператором присваивания. Во-первых, он, конечно же, не удалит старую строку, потому что никто delet
не вызовет. Он просто сделает все поля равно std-move соответствующие поля, если равно default
написать. Вот. Окей, значит, а для каких типов move-конструктор по умолчанию нормально будет
работать? Ну, например, вот известных вам big integer. Вот если вы писали big integer на векторе,
то для него move будет работать вполне корректно. Ну, правда, он у вас там не занулит поле, возможно,
какое-то поле во втором big integer. Вот. Но если у вас big integer на векторе написан, то move для
него корректно отработает по умолчанию. Вы можете в свой big integer написать big integer равно default и он
будет нормально работать, потому что он просто сделает ваши поли вектор равно std-move от другого
вектора. Но вектор-то корректно move поддерживает, поэтому это будет корректно работать. Ну,
знак будет... Да, вот. Ну и аналогично, если у вас нету вот этих вот сишной мерзости, сишных
поинтеров, референсов и так далее. Ну, это уже и референс, не сишная мерзость. В общем, если у вас
нету в классе никаких сишных нискорнивых штук, а просто все поля, это другие объекты, которые move
поддерживают, то и для вашего класса move-оператор по умолчанию будет работать правильно. Да. Отличный
вопрос. Как это будет работать, если у вас в полях есть ссылки? Да никак, он тоже не сможет
это сгенерировать. Здрасте. Нет, про это мы пока не будем говорить. Нет, это будет ошибка компиляции,
я думаю. Точно так же, как... Ну, кстати, вот насчет move-конструктора я не уверен, но я думаю,
что будет CE. Все-таки это было бы очень грустно, если там не CE. Если у вас в полях есть ссылки или
константы или массивы, то я думаю, что это будет CE. Массивы? А, рэ? Да-да-да, сишные массивы,
если у тебя поле, это сишный массив. Ну, массиву вообще нельзя присвоить другой массив, даже без
move-а, а с move-ом-то и по-давно, я думаю, нельзя. Вот, короче, что-то я затрудняюсь сказать, что будет,
если у вас в полях ссылки константны или массивы при move, я думаю, что будет CE. Вопрос, не знаю,
это большая проблема, я не знаю как, если честно, надо думать. Ну, надо какую-то логику специальную
пойдешь, или запрещать move-операцию просто. Я не знаю, вот что будет, если вообще, блин,
короче, я не могу сходу ответить, я могу ответить, понимая, что такое move, вот, короче,
мы с вами сейчас напишем код функции std move, и вы, глядя на него, можно догадаться, что будет,
если туда подставить ссылку в тип. Ну, короче, ничего хорошего, но я не уверен, будет ли это
ошибка компиляции, к сожалению, я что-то никогда не пробовал. Короче, очевидно, что так не надо,
все будет плохо, но вот будет ли это прям CE-шкой, не знаю. Надеюсь, что будет. Надеюсь,
то, что я не пострадаю, как говорится. Ладно, давайте не будем обсуждать разные варианты,
у нас большие планы еще. Ну, короче, ничего хорошего не будет. Так вот, теперь, если,
я могу, конечно, написать равно delete. Вот, что будет, если я напишу равно delete сюда и сюда? Ну,
тогда понятно, тоже это вопрос, ну, это вы должны понимать, тогда это значит будет CE, такая попытка
такое сделать. То есть, если я напишу равно delete, то это уже значит, что move будет работать не как
копирование, а просто будет CE вызывать. Если, ну, потому что я явно запретил, если тебя move-уют,
выдай CE. Вот, а не делай копирование. Бывают типы, у которых, наоборот, копирование запрещено,
а move-ы не разрешено. Кто знает пример такого типа? Да, это классический пример типа, у которого
разрешен move, но запрещено копирование. Молодец, второй пример такого типа. Ну, давайте вот это
оставим, значит, у вас будет курс многопоточки, там вы это обсудите. Вот, да, ну, потоки, да, потоки
исполнения запрещены к копированию, move-ы не только разрешено. Вот, ну, и у нас с вами будут еще несколько
примеров типов, у которых копирование запрещено, move-ы не разрешено, но мы попозже их увидим. Вот,
вот они слева направо, да. Если у вас в классе реализован хотя бы один из копий конструктора,
копий оператора присваивания, move-конструктора и move-оператора присваивания, то компилятор уже
не будет генерировать move-конструктор, move-оператор присваивания сам. А вот если ничего не реализовано,
то он сгенерирует сам. То есть, если у вас класс такой, что вы не реализовали в нем никакие из этих
пяти методов, то он сам сгенерирует вам и копи конструктор, и копи оператор
представления, и move конструктор, и move оператор представления без вашей просьбы.
Ну потому что если типы такие, что они тривиально, ну они стандартным образом
копируются, стандартным образом уничтожаются, то компилятор логично думает, и в
целом он прав, как правило, что и move'аются они тоже стандартным образом, если
копирование на них стандартно работает, то и move не стандартно работает, но если
вы хоть что-то из этого сами реализовали, то move оператор, move
операции, уже компилятор не будет реализовывать, только если вы явно не попросите.
И они будут работать как копирование, но вы можете явно попросить
и тогда я сказал, что они будут делать, а можете написать равно delete, и
тогда я тоже сказал, че будет. А можете определить их, в том числе можно
написать, что они равно default, а для копирующих написать равно delete, и
тогда их не будет. Но кажется, если вы определили move'а, то копирующие сами
тоже не сгенерируется. Будут только мувы еще у вас. Вот, это правило 5. Ну, правило 5, это не все то,
что я сказал. Правило 5 это, что если у вас есть хоть одна из этих 5, то нужно реализовать остальные,
желательно. Вот, но остальные, в остальном правило действует вот так. Вот, ладно, теперь я вот это
стираю. Мы пока решили не все наши проблемы, которые были заявлены в пункте 10.1. Тем не менее,
мы двигаемся дальше и, конечно же, нам не терпится узнать, что же делает функция
std move. Значит, сейчас я на доске просто напишу полную реализацию функции std move. И это частично
прояснить дело, но появятся новые вопросы, отвечать на которые нам придется долго. Ну, то есть мы копаем
вглубь и по мере того, как мы копаем, мы открываем, мы вроде что-то начинаем понимать, но в то же
время у нас возникают более экзистенциальные вопросы. Вот сейчас я напишу функцию std move. И это
абсолютно нормально, если у вас сейчас возникнет реакция, типа, что за фигня происходит. Ну,
тем не менее, следующим пунктом мне ничего не остается, как просто привести вам std move
и implementation. Итак, ну давайте просто представим, что мы заглянули в код функции std move. Вот что там
будет написано. Ну, во-первых, у нее должен быть какой-то возвращаемый тип. Ну, этот тип, он
должен быть типом того, что нам давали только с двумя амперсандами навешенными. Ну вот, вот эти
два амперсандика, это какой-то особый вид ссылки, да, то есть вот этот вот тип string 2 амперсанда,
он какой-то, а, ну да, я забыл, начало-то очевидное. Ссылок на ссылку не существует. Нет,
ссылок на ссылку не существует. Запрещено стандартом. Амперсанд пишется с буквой D на
конце. Правильно говорить амперсанд «да». Я не знаю, почему-то все каждый год говорят
амперсанд «та», и мне каждый год людей переучивать приходится, надо говорить амперсанд «да». Я не
знаю, почему у людей такая интуиция в этом отношении. Может мне еще и в отношении R-value
ссылок переучиться, а то каждый год люди предполагают одно и то же и неверно, предполагают,
может мне в какой-то году уже надо уже согласиться и сказать «да, вы правы, так и есть», типа и все. Это
ссылка на ссылку. Ладно, начало очевидное. В принципе, начало понятное. Вот, дальше начинается
интересное. Нам надо написать возвращаемый тип. Возвращаемый тип. Ну, если бы Федя пришел со
своим рассказом про вывод типов попозже, я мог бы написать авто, а потом, значит, отложить этот
вопрос, но нет, уж давайте как следует. Напишем возвращаемый тип в начале. Так вот, нам нужен тип,
как был у Т, только с двумя амперсандами. Хотелось бы написать нечто такое. Вот, хотелось бы,
вот если вы, вот попробуйте проследить за ходом рассуждений, особенно те, кто видео смотрит
перед экзаменом, вам это полезно будет. Значит, вот, наверное, вам естественным желанием кажется вот
такой тип возвращаемый написать, правильно? Ну, потому что вам нужно сделать тест двумя амперсандами,
но это неверно по некоторым причинам, которые пока мы понять не в состоянии, а верным является
следующее. Нам нужно сделать сначала убрать все амперсанды и только на то, что получилось,
навесить два амперсанды. СТД remove reference Т. Нет, это бы компилировалось, но давало бы не тот тип,
который надо. Вот, я утверждаю, что по некоторым причинам написать просто Т2 амперсанды возвращаемый
тип. Неверно. Нет, это не ЦЕ. Нет, это не ЦЕ. Это еще некоторый тип, но это не тот тип, который нам
нужен. Нам нужен вот такой тип. Вот именно такой тип. Значит, нам нужно, чтобы на результирующем
типе было два амперсанды навешано, но просто навесить два амперсанды на Т неверно по причинам,
которые я сейчас не готов объяснять. Я утверждаю, что вот так будет работать нормально. Значит,
нам нужно снять все амперсанды, если они были, и навесить два. Вы помните, что такое
стд remove reference Т? Все, стд remove reference Т, ну мы ее с вами реализовывали только для Т и для Т
амперсанд. Но на самом деле стд remove reference Т, она удаляет все амперсанды с типа. Их может
быть либо один, либо два. Три не может быть. Если вы навесите один амперсанд на два амперсанды,
то у вас... Я сказал, что Т амперсанд и еще два амперсанды — это некоторый тип, который на
самом деле эквилинтен типу Т просто с одним амперсандом. Есть правило сворачивания ссылок.
Если у вас навешана ссылка на ссылку, то они по некоторым правилам преобразуются в одну или две...
Нет, нет, нет. Не надо, пожалуйста, искать ложные аналогии. Не надо пытаться видеть аналогии там,
где их нет. Я понимаю, что хороший математик тот, который видит аналогии между аналогиями.
В смысле... Там есть функция addLVLUreference, addRVLUreference, но они... Короче, давайте просто вот вы поверите,
что надо так. Все со временем образуется. Подождите. Я, значит, написал возвращаемый тип. Теперь,
значит, функция называется move. Ну, с этим вы еще могли смириться. Ну, то есть непонятно,
мы остается, почему нельзя написать просто Т-двойной амперсанд, а надо именно вот сначала снять,
а потом навесить двойной амперсанд. Но то, что я напишу сейчас, совершенно оправдано вызовет
у всех buthurt, и вы совершенно, возможно, отчаетесь, но я вас очень прошу потерпеть. Вот сейчас я
напишу такой тип, что вы вообще перестанете понимать. Но давайте считать, что просто там тип
какой-то, который... Мы пока не понимаем, почему он такой. Ну, вот он таким должен быть и только
таким. Вот иначе ничего не будет работать. Просто поверьте, что вот именно такой тип мы должны
принять. Нет, тип будет выглядеть так. Т с двумя амперсандами. Значит, мы должны принять Т с двумя
амперсандами, а вернуть remove reference от Т с двумя амперсандами. И только так, не как иначе. Вот
любая другая компенсация не будет правильно работать. Значит, я предупреждал, что сейчас у вас будет
очень много вопросов, но, к сожалению, ничего не поделаешь. Нет-нет-нет-нет. Это приколы, связанные
с некоторыми проблемами, о которых мы пока еще не успели подумать. Но пока я могу, к сожалению,
вам сказать лишь следующее, что вот на этот тип надо просто закрыть глаза и смириться. Я никак не
могу. Нет-нет. Я рассказываю вам в том порядке, в котором, на мой взгляд, это проще всего осознавать.
Я не знаю другого порядка, в котором это можно рассказать, где это вызывал бы меньше бадхерта.
Тем не менее, вот на данном этапе я вас прошу смириться с этим типом и поверить в то, что вот
здесь просто навешивание Т с двумя амперсандами не сработало, нужно именно такое. И если вы в это
поверили, то в принципе осталось немного. Ну здесь еще no accept. Нет-нет. А, значит,
реализация просто в одну строчку можно в две написать, как вам удобно. Ну давайте я напишу
в одну строчку. Ретерн, статик каст. Нет. Вот к этому вот, к СТД рему в референс Т. Я все понимаю,
пожалуйста. Я понимаю, что… Значит, вот это вся функция с демоуф. Ну, здесь написано просто
сделать статик каст этого Икса вот к этому типу, который нужен. И все. Больше ничего не надо делать.
Потому что она не кидает исключений. Эта операция всегда успешна. Статик каст этот всегда отрабатывает
успешно. Что зачем писать? No accept значит, это библиотечная функция, она не кидает исключений.
Если мы ее вызываем из какой-то no accept функции, то это должен быть корректным. Если бы я не
написал no accept, то это бы означало, что попытка вызвать ее из no accept функции, это вообще говоря
опасно. Это безопасная операция с точки зрения исключений. Она не кидает исключений никогда. И
всегда завершается успешно. Этот статик каст всегда работает корректно и возвращает нужный тип.
Ремув референс т это то же самое, что type name std remove reference от t 2.2.type. Вот чтобы не писать
type name blah blah blah type, мы пишем remove reference t. Все ссылки убирает? Все ссылки убирает.
Remove reference убирает все ссылки и наверх навешивает две. Это тебе так кажется. На самом деле мы
сделали очень многое. Был тип такой, а стал такой. Это очень большое действие, очень существенное. Вот
вот тип здесь, к сожалению, с ним можно лишь смириться. Я говорю, что статик каст в данном
конкретном сценарии, статик каст это просто работает как интерпрет, можно сказать. То есть
он просто трактует x как вещь такого типа и все. По стандарту это корректная операция всегда. Вы
можете всегда от типа x сделать каст, ну от типа t сделать каст к навешанным 2 амперсандам на t.
Ну не к навешанным 2 амперсандам на t, а вот к такой штуковине. Я попробую все-таки дать
некоторую интуицию, почему нельзя просто так написать. Потому что если вы навешиваете 2
амперсанды на тип, на котором уже были амперсанды, то это работает по странным правилам. Например,
если у вас был тип с 1 амперсандам и вы навесили 2 амперсанда, и по правилам
преобразования ссылок это станет 1 амперсандам, а не 2. Есть следующие правила преобразования
ссылок, которые называются «reference collapsing rules». Если у вас тип был с 1 амперсандом и вы сделали
еще 1 амперсант на него, то будет 1 амперсант. Если 1 амперсант а вы на него сделали 2 амперсанда,
то будет 1 амперсант. Если же 2, а вы сделали 1, то будет опять 1 амперсант. И только если вы
сделали два амперсанды повер двух амперсандов будет два амперсандов вот из-за этих правил почему эти правила
такие это тоже хороший вопрос но они такие вот вот если сделать другими все будет плохо но вот правила
преобразования ссылок работают так поэтому здесь мы не можем себе позволить написать т2 амперсанды
если бы мы написали здесь т2 амперсанды и т уже было бы с амперсандами то мы бы получили реально
не два амперсанды в конце а нам нужно гарантированно получить ровно два амперсанды в конце потому мы
сняли все амперсанды и навесили два на чистый т без амперсандов и получили т с двумя амперсандами
это по стандарту всегда корректная операция любой объект типа т можно скастить такому же
типу с двумя амперсандами и это ничего не поменяет самому подожди что подожди что
то есть мы по сути делаем два кашля один а вот мы же понимаем т амперсанды и амперсанды
есть то есть мы скастили я понимаю но в конструкторе ну не совсем мы не скастили здесь как раз т не обязательно
с двумя амперсандами здесь как раз произойдет схлопывание ссылок но оно произойдет по еще
более странным правилам забейте короче здесь будет довольно странный тип принят но тем не
менее каким бы он ни был в конце получится т с двумя персантами короче если если вам нужно
объяснить что делает функция move в двух словах функция move это просто каст к типу с двумя
амперсандами все вот больше ничего и эта функция на самом деле даже не генерирует никаких
процессорных инструкций это просто хак для компилятора эта функция в рантайме ничего не
делает это все компайл тайм штука то есть вызов move в рантайме это 0 это вообще 0 действий это даже
не вызов функции это функция вся суть функции move в том чтобы сказать компилятору иди не в эту
версию а в эту по сути move можно заменить просто статик кастом к стринг двум амперсандам если вам
надо было в той сценарии когда вы пишете когда вы пишете а равно sd move от b где b это стринг вы
можете написать с таким же успехом а равно статик каст к стринг два амперсанда от b и это то же
самое что сделать move но просто чтобы вот такой фигней не заниматься и не думать каждый раз
статик ас сейчас к скольким амперсандам я делаю вы просто пишите move если хотите муфающую операцию
к сожалению я не готов сейчас ответить на этот вопрос это это слишком сложно я пока вот пока
вынужден просить вас игнорировать этот этот момент я боюсь что мы даже сегодня не успеем
это разобрать в общем есть очень неприятные случаи которые к сожалению так просто не объяснить но
вот мы сейчас еще некоторое время поговорим о проблемах сопутствующих применение функции и
осознаем что здесь именно такой тип нужен был но я мог бы вместо я мог бы чтобы вас не пугать
написать есть три знака вопроса сказать что мы просто не знаем какой тип сюда поставить вот
авто бы не работала к сожалению тоже не работала бы потому что авто отбрасывает все амперсанды о чем
вы узнаете как раз сегодня на второй паре вот авто с двумя амперсандами бы работала но только
начинать но только начиная си плюс плюс 20 потому что это было было бы сокращена версия шаблона
тогда нужно было бы не писать имплей тейк на и те а и тогда непонятно что было бы писать здесь ну
короче все плохо так все я рассказал что делать муф муф это просто статик аск типу с двумя амперсандами
нет это не мета функция это нормальная функция вот теперь мне предстоит за оставшееся время
попытаться объяснить хоть немного что за дичь происходит и чтобы наконец объяснить что за дичь
происходит мне нужно сделать две вещи вот видимо мы оставшуюся часть пары потратим на эти две эти
два пункта значит сейчас нам предстоит ввести формальные понятия l-value и r-value наконец-то
после чего нам предстоит ввести формальное понятие что такое r-value ссылка и почему она
так называется и что с ней можно делать что с ней нельзя делать это частично прояснит ситуацию но
не полностью вот а полностью ситуация прояснится видимо уже через неделю когда мы поймем что
одними только r-value ссылками проблема не решается иногда нужны некоторые специальные ссылки
которые не l-value не r-value а вот такие вот универсальные называется и вот тогда-то мы
поймем что вот здесь именно такая ссылка и должна быть отлично все мы закончили третью
серию я понимаю что у всех у всех сашок но если что если что если к моменту когда вы все поймете
и при исполнении своем познании вы придумаете более удачный порядок изложения в этой теме вы
можете мне это рассказать и я подумаю может быть он действительно более удачный потому что я
ну вот сам я понял с четвертого раза когда мне это рассказывали и вот тот порядок изложения
который я вам сейчас даю это вот лучшее что я мог изобрести за 4 года чтобы минимизировать
количество возгласов что за херня в аудитории вот если вы придумаете другой порядок изложения
в котором этот число возгласов будет меньше расскажите мне вот я стараюсь минимизировать как
могу так вот дальше мы вводим формальное определение l value и r value и так чтобы
разобраться в том как же работает вся эта шняга нам нужно понять а что вообще такое
ссылки и что они умеют и почему они значит так себя ведут ну что вот эта штука с двумя
персантами я сказал что это типа когда называется r value ссылкой на t что это за тип такой какими
свойствами обладает чем отличается от обычных ссылок и как он себя ведет и что с ним можно
делать что нельзя чтобы объяснить это нужно сначала все-таки окончательно решить вопрос
что же такое r value то на самом деле потому что r value и l value и то и другое потому что все время
мы говорили ну это такой вот ну это того чем мы нельзя присваивать ну вы же уже понимаете что
это неправда у нас с вами уже был пример у нас было дофига примеров l value которым
нельзя присваивать и у нас был даже пример r value зар infra у которого можно присваивать
кто помнит пример р вл у которому можно присваивать да когда мы вектор был делаем
квадратной скобочке получается рвл у которому можно присваивать то есть определения l value
рв лу как то что мы можно и нельзя присваить не выдержит критики давайте введем формальное
Формальное определение синтоксическое, как ни странно.
Первая штука, это самое главное заблуждение, которое у всех есть относительно вот этих вот вещей.
Я, кажется, вам это уже говорил в первом семестре, но тогда это не было настолько важно.
Вот сейчас я просто, не знаю, нужно красным цветом написать и в рамку обвести,
что L-value и R-value это понятие, относящееся к экспрешенам, а не к типам.
Это некоторая очень глубокая мысль, которую вы, скорее всего, тоже не сразу осознаете.
Не имеет смысла спрашивать про тип. Он L-value или R-value? Это бессмысленный вопрос. Нету такого.
Типы не делятся на L-value и R-value. Выражения делятся на R-value и L-value.
Кажется, к этому моменту курсик должен был быть уже понятно.
Вот. Ну, вот меня спр... Ну, это становится...
Люди очень выпадают, значит, из... Представляете, когда они видят вот эту штуку,
стринг 2 амперсанда, это же R-value ссылка, а значит, это R-value.
Нет, ничего не значит. Это вообще никакое не value. Сам по себе тип, это никакое не value.
И то, что у вас есть R-value ссылка, это не значит, что она... Ну, это значит... Нет, это ничего не значит.
И L-value ссылка не значит, что она L-value. Никакой тип не значит, что он какой-то value.
Value имеет смысл спрашивать только про expression. Вот у вас написано это expression.
И вот про expression в целом можно спросить, он какой value?
Expression может состоять из разных переменных, разных типов.
Вот смотря, что там с ними делается, будут разные value.
Но, еще раз повторю, не имеет смысла спрашивать про тип, что он какой-то value.
Тип это никакой не value. Так вот теперь, когда мы это осознали, я просто напишу табличку.
Ну, на самом деле, я могу открыть ее на cp-reference.
Вы можете открыть ее сами, но, наверное, я все-таки на доске попишу какое-то время.
А потом, наверное, не знаю, может я ее открою.
Значит, все expression делятся на два вида L-value и R-value.
И сначала мы перечислим те expression, которые состоят из стандартных типов.
Ну, то есть, для своих типов вы можете определить операции так, что у них value будут странными в результате этих операций.
Но я сейчас напишу, как это работает для стандартных типов.
Ну, во-первых, если у вас есть просто идентификатор, то есть, имя переменной, выражение, которое представляет себя просто имя переменной, это L-value всегда.
Напротив, если у вас есть литерал, то это R-value всегда.
Литерал?
Литерал это, ну, 5.
Вот, если у вас есть литерал, то это R-value.
А если у вас просто выражение идентификатор, имя переменной, то это L-value.
Неважно какой это тип.
В двух кавычках ABC это имя переменной.
Значит, в двух кавычках ABC это, к сожалению, L-value.
Потому что там есть исключение из правила как раз для строковых литералов.
И, честно говоря, я сам не знаю или не помню.
Значит, я...
Давайте просто считать, что любой литерал это R-value.
А когда мы дойдем до исключения...
Короче, вы можете считать, что любой литерал это R-value без ущерба для понимания всего оставшегося курса.
И вообще языка C++...
Ну, короче, я не знаю ситуации в жизни.
Ни разу не встречал, когда знание о том, что строковый литерал это L-value, а не R-value, что-то меняло.
Короче, просто считаем, что любой литерал это R-value пока что.
Любой литерал это R-value. Понятненько?
Вот.
А любой идентификатор это L-value.
Дальше.
Давайте вспомним, какие мы знаем еще операции.
Если у нас есть бинарные операции.
Ну, например, сложение, вычитание, бинарная звездочка, бинарный слэш, бинарный процент.
Вот такая штука.
Вот такая штука.
Вот такая штука.
Вот такая штука.
Вот такая штука.
Вот такая штука.
Вот такая штука.
Это все R-value.
Вот.
Если у вас выражение на верхнем уровне представляет в себе результат какой-то из этих бинарных операций, то это R-value.
Ну, только для стандартных типов.
Для своих типов вы, конечно, можете определить операции так, что они будут странные value.
Но это все для стандартных типов только пока что.
А если вы делаете присваивание?
Или составное присваивание?
Ну, короче, вот все эти штуки это L-value.
Это произвольные expression.
Ну, то есть вид value выражения определяется тем, что на верхнем уровне в нем происходит.
Ваше выражение, оно синтоксически парщится, и на верхнем уровне это результат какой-то операции над двумя под выражениями.
И вот результат финальной операции это и определяет, какой вид value выражения в целиком.
Вот если ваше выражение на верхнем уровне представляет в себе результат одной из этих операций, то это R-value.
А если результат вот этих, то это L-value.
Там A-палка равно B, A-циркумфлекс равно B, и A вот такой сдвиг.
Да, этот знак называется циркумфлекс, если кто не знал.
А если у вас A равно равно B, а меньше или равно B? Да, сравнение тоже R-value.
Это отличный вопрос. Сейчас как раз мы до этого дойдем, но пока мы разберем стандартные операторы.
Дальше. А какие у нас еще есть стандартные операторы?
Точка.
Ну, точка это плохой пример, слишком сложно. Давайте покажем что-нибудь простое.
Вот давайте, да, унарный амперсант. Вот унарная звездочка это L-value.
А унарный амперсант это R-value.
Унарный амперсант, это указатель.
Ну, взять адреса, да.
А унарная звездочка это L-value.
Ну, унарную звездочку к чему можно применять? Ее можно применять к указателям и тому, что ведет себя как указатель.
Ну, вот результат унарной звездочки это L-value.
А если у нас указатель на указатель, то унарная звездочка...
Унарная звездочка это L-value, все, конец разговора.
Ну, будет указатель, который является L-value.
Вот. Дальше. Какие еще мы знаем стандартные операторы?
А, инкременты. Действительно.
Префиксный и постфиксный.
Префиксный инкремент и декремент это L-value, постфиксный это R-value.
Просто по определению.
Ну, это хорошо, что для вас уже логично.
Вот. Отлично. Ну, сейчас.
Запятая относится к числу операторов, про которые так просто не скажешь.
Ну, давайте перейдем к этим операторам, про остальные.
Ну, там New и Delete, например. Это L-value или R-value?
Ну, я не знаю даже, честно говоря.
По-моему R-value, но я как-то не задумывался.
Throw, да. Throw. Это R-value или R-value?
По-моему R-value, но я тоже не уверен, если честно.
Ну, может есть какие-то убогие случаи, в которых надо...
Ну, то есть понятно, что для этих операторов тоже есть формальная категория значения того, чего они возвращают.
Но это чисто техническое определение. Упоротый случай никогда это не нужен.
Чего? Void.
Ну, тип Void, а категория значения как-то в стандарте определена.
То есть результат throw – это какой-то вид value.
Но я ни одного случая в жизни не знаю, когда это требовалось бы для чего-то.
То есть формально у него какая-то категория есть, но я не знаю вообще, для чего.
Поэтому давайте мы это не будем обсуждать.
Вот. Сейчас мы обсудим два наиболее интересных оператора.
Это тернарный оператор и запятая.
И что же мы знаем про тернарный оператор?
А, ну прекрасно. То есть тогда вообще отлично.
Тернарный оператор, если все, ну давайте так, если оба оператора L-value.
То есть вид value тернарного оператора зависит от того, какие виды value у операторов.
Если оба оператора L-value, то и результат тернарника это L-value.
Соответственно тернарный оператор считается R-value, если хотя бы один.
Ну я имею ввиду не левый, а хотя бы один из вот этих.
Либо средний, либо правый. Да, понятно.
Если хотя бы один из операторов R-value, то тернарный оператор считается R-value.
Запятая. Как устроено запятая?
Ну кажется, я тоже говорил. Если правый оператор это L-value, то и запятая считается L-value.
У запятой вид value такой же, как у правого оператора.
Значит, запятая считается L-value, если правый оператор L-value.
Так, минуточку.
Перечисление параметров функции это не оператор запятая.
Это уже надо знать к текущему моменту.
Это мы раза три обсуждали, мне кажется, уже на лекции.
Оператор запятая только в экспрешенах фигурирует.
Перечисление параметров функции это не оператор запятая.
Это другой элемент синтезиса, это не оператор.
Как использовать оператор запятую? Мы его использовали в комплейтах, но...
А запятая в R, а в B запятая в H, чтобы сломать.
Это, кстати, хороший вопрос на понимание, как это будет работать в плюсах.
У запятой самый низкий приоритет. Это распарщится вот так.
Нет, присвоит B самому себе, это может быть много чего действить.
То есть можно, чтобы ломать питанистов, периодически такие вещи писать?
Ну да.
Ты не учитываешь того, что тебя за это сломает ревьюер.
Если ревьюер питанист, то как бы все нормально.
А потом у вас упадет прод, да? В чем цель?
Закоротить человека просто.
Так, короче, запятая, если правый оперант это R-value.
Вот, окей. А теперь самое интересное.
На самом деле все эти пункты не очень интересные.
Вот эти пункты совсем не интересные, вот эти пункты чуть поинтереснее.
А теперь два самых интересных пункта.
Это cast и вызов функции.
Cast.
Static Castor, Dynamic Castor, Interpret Cast, Const Cast.
Значит, предпоследний пункт в определении.
Если это Cast Expression, то есть либо Static Cast, либо Dynamic Cast, либо Interpret Cast, либо Const Cast, либо C-Style Cast, прости господи, то
cast expression, если результирующий тип имеет вид, как вы думаете, какой, если результирующий тип с одним амперсантом.
Если результирующий тип с одним амперсантом.
И это R-value, если результирующий тип либо без амперсантов, либо с двумя амперсантами.
Ну, давайте так скажу, если результирующий тип это L-value reference.
Нет, это не один и тот же тип, в смысле, это разные типы.
Нет, мы не договариваемся, что с T и 2 амперсанты это один и тот же тип, это разные типы совершенно.
Просто мы договариваемся только о том, что я пишу формально.
Вот мы договариваемся, что если у меня Cast Expression и в нем результирующий тип это non-reference или R-value reference, то результат такого каста считается R-value.
Понятно.
Значит, предпоследний пункт определения.
Выражение каста, то есть static, dynamic, reinterpret, const, а также sys-style-cast считается L-value expression, если мы прикастили к типу с одним амперсантом.
И это считается R-value expression, если мы прикастили либо к типу вообще без амперсантов, либо к типу с двумя амперсантами.
И именно поэтому это называется R-value reference.
Ну, это как бы намек на то, почему оно так называется.
Это такая ссылка, что прикастив к ней, мы получим R-value.
То есть R-value и R-value reference это типы?
R-value reference это типы, да.
R-value reference называется тип вида что-то и в конце два амперсанта.
А L-value reference называется тип вида что-то и в конце один амперсант, но больше, чем два амперсанта не бывает.
Если появляется больше, чем два амперсанта, то они схлопываются по правилам, которые я сказал, за исключением случая, о котором я не сказал, но это мы пока опустим.
Я говорю, если у вас есть методические рекомендации, как лучше излагать это все, you are welcome.
Я с удовольствием послушаю в конце года, потому что я не знаю лучшего порядка.
Так вот, cast expression и последнее, function call, вызов функции.
Function или метод call.
Вызов функции и он по таким же правилам устроен.
Ну, cast это не совсем функция.
Значит, вызов функции или метода определенного, ну, какого-то точно по таким же правилам работает.
Результат вызова function call, то есть вызов чего-то от чего-то, это L-value если,
или возвращаемый тип от L-value reference, и R-value, если это либо non-reference, либо R-value reference.
И именно поэтому это и намекает, почему эти ссылки так называются.
Потому что если вернуть ее из функции или из cast expression, получится R-value выражение.
Это одна из особенностей.
Теперь давайте попробуем...
А, ну, еще мы не сказали про оператор точка и оператор стрелочка.
Ну, кажется они L-value.
То, чем является оператор точка и оператор стрелочка зависит от того, чем был объект.
Ну, например, вот я взял и сказал, не знаю...
Ну, вот у меня была какая-то структура S.
Это что, L-value или R-value?
Нет, зависит от... вот это R-value.
Ну, потому что function call же у нас...
Ну, нет, это не так.
Так, это... тут скорее всего правила слопы... то есть если поле было типа ссылка...
Вот если сам X был L-value-reference, то я думаю, это все-таки будет L-value.
Но в нормальном случае, то есть когда это не ссылка, когда это обычное поле, это будет R-value.
Ну, потому что сам объект R-value, вот это же R-value.
И у него точку взяли, это R-value остается.
Я же могу описать объект точку.
И что?
Мы же правда можем написать S.X.
Можем, и это будет R-value.
В чем у тебя проблема?
Ну, потому что присваивание возвращается к хорошему L-value.
Какое присваивание?
Ну, короче, мы присваиваем...
Где здесь присваивание? Здесь обращение к полю.
Ты еще раз. Мы к полю можем присвоить.
Спокойно. И в этот момент у нас R-value превратится в L-value.
Что-то такое...
Кто тебе сказал, что присваивать мы можем только L-value?
Ты какие-то устаревшие взгляды.
Нет, просто...
Если у нас по ходу меняется тип операции...
Что значит по ходу меняется? По ходу чего?
По ходу того, что происходит.
Где происходит? В compile-time или в runtime?
Зачем нам вообще нужны типы?
Это правда.
Зачем вообще нужны виды value?
Если можно присваивать, можно не присваивать.
Можно что-то еще есть.
Потому что от вида value зависит, какая операция будет вызываться.
Move или Copy.
Это типа кастыль, чтобы различать просто разные...
Да-да.
Так, давайте я все-таки добавлю этот пункт в определение.
Значит...
А давайте просто cpp-reference...
Господи, откроем. Что мы уже...
Я вам основные пункты написал.
Сейчас мы посмотрим на не основные пункты.
Сейчас. Да, какой вопрос?
Если у нас в ES-case был constant, то это тоже станет L-value, да?
Константность никак не влияет на категорию типа.
На категорию expression.
Сейчас.
Ну, может быть, как-то и влияет, но это какие-то очень тонкие случаи, которые несущественные для понимания.
Так, давайте-ка посмотрим на формальное определение теперь полностью.
Вообще стандарт написан так, чтобы было потруднее.
Понимать его.
В стандарте нету четкого определения L-value и R-value.
Оно собирается по кусочкам из всего стандарта.
Ну, то есть в стандарте нету места, в котором написано L-value называется одно из следующего, а R-value называется одно из следующего. Нет.
В стандарте просто про каждый оператор отдельно одним из пунктов сказано, какой он value, и все.
То есть нету в стандарте прям четкого вот где собрать.
Добрые люди на CPP Reference все-таки сделали эту кропотливую работу и по кусочкам из стандарта собрали понимание, что такое L-value целиком.
Вот что такое L-value.
Значит, страница на CPP Reference называется value category.
Да, если что, это называется категорией значений.
Значит, у каждого выражения есть две характеристики.
Есть тип и есть категория значений.
Это артагональные вещи.
Ну, то есть они как-то связаны друг с другом, но это разные вещи.
Можно отдельно спросить про выражение, какой у него тип, и можно отдельно спрашивать про выражение,
какой у него категория значений.
В десятый раз повторяю, что нельзя спрашивать каким value является этот тип.
Это бессмыслийный вопрос.
Может только про выражения спрашивать, каким оно является типом, а также каким оно является категорией значения.
Так вот, что такое L-value.
Ну здесь в принципе перечислено.
перечислено это имя переменной имя функции или или data member regardless of
type так или data member возможно я вас сейчас
стд сим да возможно я вас все-таки обманул и с с точка x это было l value да
хорошо давайте читать дальше да да наверное я вас обманул извините значит это все-таки
было l value да да да да да или ну если я написал s круглые скобочки точка x это все-таки l value
формально они r value несмотря на то что с было r value да член поля класса это l value значит
вызов функции или перегруженного оператора чей возвращаемый тип это l value референс дальше
результаты вот таких вот присваиваний префиксного инкремента разыменование обращение по индексу
квадратными скобочками к встроенным операторам операторам дальше обращение через точку член
объекта за исключением случая когда m это член перечлен член енума или нестатическая функция
член или когда а нет я вас все-таки не обманул смотрите а точка м это все это все-таки р вл ю
когда a это r well you а aim это нестатический член типа объектомyy мв обращение к точке
обращение точкой к полю это lble ю за исключением ситуации когда
А также, когда a это R-value, а m это нестатическое поле член объектного типа.
Какая нестатическая функция члена?
То есть, ну как это, функция члена, которая является нестатическим?
А, а это переменная всегда R-value?
Нет, а это произвольный expression здесь.
Имеется в виду, если он писал s, круглые скобочки, точка m,
и m имела тип какой-то класс, и вот, ну и тогда это будет R-value.
Ну короче, это довольно тонкий случай, который на самом деле я не предлагаю вам выучивать наизусть.
Что такое a.exe, если a это нестатическая функция члена?
R-value?
Нет, в смысле не R-value.
Давайте забьем, пожалуйста. Ну это какие-то технические детали определений, которые несущественны для понимания.
Ну, существенные случаи мы разобрали.
Значит, вот, стрелочка является L-value, кроме случая, когда m это бла-бла-бла,
значит, точка со звездочкой является L-value, в случае, когда a это L-value, а mp это указатель на член,
стрелочка со звездочки является L-value, ну и так далее.
Значит, запятая, когда b, L-value, тернарный оператор, когда оба являются L-value,
строковый литерал является L-value почему-то.
Ну, забьем.
Cast expression к L-value-reference, а также non-type template-параметр типа L-value-reference.
Ну, если у вас был параметр шаблона типа int&%
int&%?
Ну да, вы сделали int&% параметром шаблона.
Как?
Ну так и написали template в скобочках int&% x, и тогда x это будет L-value.
Вот, а также, ну в общем, в общем, не важно.
Вот, короче, вот это L-value.
Забейте, пожалуйста, это несущественно, если мы будем погрязать детали, мы не доберемся ни до чего.
Вот основные случаи мы разобрали, если вам интересны детали, вы можете читать стандарт.
Я не хочу разбирать эти упоротые случаи сейчас.
Дальше, к сожалению, мне придется приоткрыть вам еще одну неприятную истину.
R-value подразделяется на два подвида, pair-value и x-value.
Но для текущего понимания можно на это забить и просто не разделять их.
То есть, смотрите, есть понятие pair-value и есть понятие x-value.
Pure r-value, а также expired-value.
Но мы не будем сейчас разбирать, почему они подразделяются, просто мы как будто объединим два списка в один.
Вот это считается R-value.
Ну, я не буду перечислять еще раз, но тут все написано, что является R-value.
Что такое R-value, чтобы L-value в принципе по жизни?
Значит, L-value это то, чему можно присваивать, ну, так примеризительно.
Как правило.
Указатель на zis.
Да, да, указатель на viz является R-value.
Отличное R-value.
Да, отличное R-value.
Дальше результат вызова функций.
Ну, тут если вкратце сводится к тому, что все то, что связано с R-value с ссылками, это как раз x-value.
Но забейте, вот пока не надо думать, почему.
Понимать, чем отличается pair-value от x-value на данной стадии не надо.
Надо просто знать, что есть L-value и R-value.
Так, конец четвертой серии.
Мы с вами дали формальное определение L-value и R-value.
Есть ли вопросы по этой части, кроме задротских вопросов, и да, а если я возьму вот такой вот анперсант,
и сделаю функцию член, стрелочку со звездочкой, вот эти я не буду в детали сейчас.
Вот какие-нибудь экзистенциальные вопросы, философские такие, глобальные на уровне.
В том списке с L-value у нас, ну, так сказать, слева можно стоять L-value, а справа все что угодно.
В каком списке?
Ну, на доске, который был.
Плюс равно, равно, равно.
Неважно, что стоит слева и что справа.
Результат операции плюс равно это L-value для всех встроенных типов.
Неважно, да.
Ну, если это компилируется, то ради бога.
Ну, например, для вектора bool обращение по индексу это не L-value, как мы знаем.
И мы уже понимаем, кстати, почему формально.
Обращение по индексу к вектору bool это не L-value, потому что обращение по индексу к вектору bool дает тип без амперсандов.
А он R-value по определению.
Так, последний пункт, который мы сегодня успеем разобрать.
Это все-таки что же такое R-value ссылки и операции над ними.
И после этого пункта вам должно стать понятно все кроме того, почему bool такой странный тип принимает.
И почему такой странный тип...
Ну, короче, все кроме этой вот проблемы, почему в одном месте мы пишем T с двумя амперсандами, а в другом remove reference T с двумя амперсандами.
Но все те загадки, которые были в прошлый раз, к концу этой пары будут у вас разгаданы и останутся лишь новая загадка, почему такие странные типы move принимает и возвращает.
Почему нельзя было просто написать T с двумя амперсандами.
Значит, последнее, что я сейчас расскажу, это что такое R-value референсы.
Значит, пункт 10.5 называется R-value references и операции над ними.
Так, параграф 10.5, R-value references.
И, не знаю, их свойства.
Смотрите, когда-то...
Какие-то вещественные числа получились.
Когда-то мы с вами проходили в этой аудитории обычные ссылки.
И я вам тут говорил, что, понимаете, ссылка это просто другое название для того же объекта.
Что значит, модификация ссылки это и есть модификация того самого объекта и так далее.
Ну, в целом, для R-value ссылок все это верно остается.
То есть они по своим свойствам как к обычной ссылке.
То есть точно так же, если у вас есть R-value ссылка на что-то, то это просто другое название для него.
Модификация R-value ссылки это то же самое, что модификация исходного объекта.
R-value ссылка не может быть перепривязана к другому объекту.
Она не может быть ничем не проинициализирована.
То есть все эти свойства ссылок сохраняются.
Есть два ключевых различия, которыми отличаются R-value ссылки от обычных ссылок.
В принципе, этим все сказано.
А дальше можно просто разбирать примеры.
Два главных отличия, чем отличаются R-value ссылки от обычных ссылок.
Первое отличие уже было произнесено.
R-value ссылка, будучи возвращенная из функции или из каст операции, является R-value выражением.
Это первое из двух главных отличий R-value ссылок от L-value ссылок.
А второе главное отличие.
R-value ссылка может быть проинициализирована только R-value выражением.
В то время как L-value ссылка только L-value выражением.
Не константная.
Константная L-value ссылка может быть проинициализирована как R-value, так и L-value выражением.
Но вот R-value ссылка, любая, может быть проинициализирована лишь R-value выражением.
Например, давайте вспомним какие-нибудь примеры.
Вот я говорю int x равно 0.
И говорю int двойной амперсант y равно x.
Это корректно или нет?
Нет, это CE.
Жестко.
Это CE, потому что...
Да, именно.
Вот это CE.
Это CE.
То это нормально.
Вот это OK.
Что?
Конечно.
Как и константную L-value ссылку, в общем.
Подождите, ну вас же не смущало, ну или смущало, но вы уже забыли.
Вы же можете написать вот так.
Const int амперсант cx равно 1.
Мы же так делали с вами.
И не раз.
Ну, в случае константных ссылок...
Ну да.
R-value ссылки, как и константные ссылки, продлевают жизнь временным значением.
Да.
Нет, double амперсант y равно x это CE.
Вот const double амперсант y равно x.
Это нормально.
Один амперсант.
Один амперсант.
Const double амперсант.
Double амперсант y равно x.
Это нормально.
Создаст современный double из этого x.
И к нему привяжется константная ссылка.
Одинарный амперсант.
Такого типа нет.
Ты имеешь в виду вот это?
Это некорректно.
Что-что?
Имеет ли смысл константная R-value ссылка?
А что такое имеет смысл?
Что ты называешь имеющим смысл, а что ты называешь не имеющим смысл?
Имеет ли это применение практическое?
Ну, бывает.
Редко, но бывает.
А чем они вообще отличаются?
Ну, у тебя, когда ты пишешь какой-нибудь библиотечный код,
формально тебе нужно разобрать все четыре случая,
когда мы будем писать какие-нибудь библиотечные функции,
у нас может в виду наложение константности на move
получиться константный R-value,
да, константный двойной амперсант.
Такое бывает,
и это приводит к тому, что оно ведет себя как копирование.
То есть целенаправленно
константные R-value ссылки
никто не создает, мне кажется,
но они могут возникнуть как комбинация
наложения константности на move,
и в этот случай иногда бывает нужно
отдельно обрабатывать, например.
Вот.
То есть это вполне себе корректный тип,
да, и он может существовать.
Так, окей.
Да.
Пожалуйста, почему
нельзя создавать R-value ссылки
на временные значения на R-value?
Мы обсуждали это
в октябре.
Ну, хорошо, давайте я напомню.
Почему L-value ссылки не константные,
не продлевают жизнь объектам?
Мы обсуждали, у нас был
пример, почему так нельзя делать.
Это было еще на заре остановления C++,
когда Страустер пришел, как
должны ссылки продлевать жизнь объектам.
А именно пример такой.
Напоминаю о нем уже, по-моему,
даже не во второй раз, но
я, по-моему, все забываю. Значит, если у нас есть вот такая
штука,
а потом мы вызываем f от x,
а f принимает
double ampersand,
то если бы мы умели не константными
L-value ссылками продлевать жизнь объектам,
у нас была бы
проблема, потому что мы бы создали
временный double из этого int
и думали бы, что мы получили ссылку на то,
что передали, а на самом деле
нет.
Это причина,
по которой C++ запретил не константными
L-value ссылками продлевать жизнь объектам.
Потому что в случае неявного каста
мы бы никак не смогли опечить ситуацию,
что мы ссылку на временный объект сейчас
получили или ссылку на настоящий объект.
И мы бы очень трудно дебажили это.
Но в случае константных
мы можем так себе позволить делать,
потому что мы все равно менять ее не собираемся.
Какая нам разница? Мы с реальным объектами
делали или с временным.
Но вот в случае с R-value ссылками
нам принципиально, чтобы они умели
инициализироваться R-value значениями.
В этом весь их смысл.
Нам как раз нужно, чтобы они умели инициализироваться R-value значениями.
Потому что именно благодаря этому
мы по R-value ссылке
можем принимать результаты CDMOV в функцию.
Именно благодаря тому,
что R-value ссылки
инициализируются R-value значениями и только ими,
у нас правильно работает перегрузка.
Когда у нас есть какая-нибудь функция,
принимающая string
двойной амперсант,
а также функция, принимающая
const string амперсант,
то мы,
имея R-value,
попадаем сюда,
а не сюда.
И в этом как раз и есть суть
R-value ссылок.
Вся суть R-value ссылок
в том, чтобы они
при перегрузке
забирали себе
ту версию,
которая вызвана
от R-value.
Вот если мы вызвались от R-value,
и у нас прописана
вот такая версия foots,
то мы обязательно попадем сюда.
Вот эта версия годится и для R-value,
и для L-value.
Но она менее предпочтительна,
потому что эта версия годится только для R-value.
И если у нас есть R-value,
то мы попадем
как раз сюда.
Если у нас есть эта версия наряду с этой,
то при вызове от R-value предпочтение будет
на этой версии.
Именно поэтому, если у вас есть в классе
и вы от R-value что-то делаете,
вы попадаете сюда.
Но если бы у вас не было этой версии,
то вы попадали сюда по общему правилу,
потому что эта версия годится и для того, и для другого.
А если бы у вас
была еще и вот такая версия,
то в нее бы вы попадали только когда
у вас L-value.
Вот это версия годится
Вот эта версия годится только для L-value expression, вот эта версия годится только для R-value expression, а эта годится и для тех, и для других.
Но вы тогда в центральный никогда не попадали?
Нет, если у вас тип константный стринг, то вы бы попадали в центральную.
Константный стринг?
Ну если вы вызвались от const-string, то вы бы попали сюда.
Но если вы вызвались от обычного стринг, то вы бы попали либо сюда, либо сюда, смотря какой вид value был.
Вот.
Понятно, почему R-value ссылки обладают таким свойством, что это главное их свойство, они только через R-value могут быть проинциализированы.
Сейчас мы с вами, сейчас еще парочка примеров.
Что-то Федя все нет и нет.
А если я вызову const-string, то будет SE?
Если ты вы...
Что такое SE?
Я это почувствовал просто.
Какую букву ты назвал буквой S?
Ты как бы разворачивался сейчас просто.
Ну в смысле, ну я не могу.
Почему ты это читаешь как SE?
Solo extension.
Это по-русски.
Это буква C, это не S.
Это C, это CE.
Это человек, который говорит OK.
Я знаю человека, который говорит CCH.
Это что?
Если мы вызовемся от const-string 2A, ты хочешь спросить, что ты спросил?
Да, const-string 2A.
Если мы вызовемся от const-string 2A, мы попадем...
Мы вызвались от R-value или от L-value для начала?
Это же R-value.
Минуточку.
Тип не является каким value сам по себе.
Мы вызвались от какого expression, ты мне скажи?
Мы вызвались от sigma.
Минуточку.
То, куда мы попадем, зависит не только от того, какой тип был, но и от того, какое value было.
В смысле? Да? Что?
Так я только что 5 минут про это говорил.
Если мы вызываемся от строки, которая является R-value, то мы попадем сюда.
А если мы вызываемся от строки, которая является L-value, мы попадем сюда.
Но при этом тип строки может быть как string, так и string 1A, так и string 2A.
Тяжело отрезать...
Нет, у меня есть переменная const int 2A.
Вот смотри, у тебя есть переменная const int 2A, R, допустим, равно 0.
И что ты пишешь? Ты пишешь f от чего?
От R.
Тогда ты вызываешься от L-value.
И мы попадаем в string.
И ты попадаешь в эту версию.
В эту ты не можешь попасть, потому что это нарушение константности.
В эту ты не можешь попасть, потому что это не R-value у тебя, а L-value.
Значит единственное, куда ты попадаешь, это сюда.
Если бы он был не константный, то мы попали в нижнюю.
Если бы вот здесь не было этого, то мы бы попали вот сюда, потому что мы вызвались от L-value.
Сейчас здесь глобально даже будет.
Чтобы отличать временное объект от невременное.
Чтобы отличать R-value от L-value.
Это же какая-то очень празматичная цель.
А мы на чем пишем, по-двоему?
Мы же не ждем, что у нас будет разная идея, когда мы вызываемся от R и от R+.
Да, именно.
В этом разном поводе.
Нет, ждем, конечно.
Просто R это невре...
Так, смотрите.
Вот сейчас нужно понять одну важную вещь.
Вот я формально все это проговорил, но тем не менее это пока пример не покажешь, люди не поверят.
Демонстрирую на примере.
Вот смотрите.
Вот у меня допустим есть R-value ссылка на ноль.
Вот у меня есть такая R-value ссылка.
Я написал int2&y равно 0.
И я говорю f от y.
При этом у меня есть f от int&, f от constant& и f от 2&.
Куда я попаду?
Ты именно такой пример сделал.
У тебя функции строки принимают, а я от intа вызываюсь.
Это не важно.
А, значит вопрос.
У меня есть три функции.
Вот такая, такая и такая.
И я написал вот это.
В какую версию я попаду?
Ну да.
Вот не в эту.
Ну, я тут может быть, короче, я не уверен на сто процентов, что в эту...
Вот тут может быть, может быть там есть правило, что какая-то неоднозначная.
Но главное, что не в эту.
Вот самое главное, надо понимать, что не в третью.
Если я напишу так, я попаду куда угодно, но точно не сюда.
Это слово мозги.
Потому что...
Да, что?
А как мы вообще можем во вторую попасть?
Во вторую, я думаю, не можем.
Ну, может я забыл какое-нибудь правило в стандарте, какое-нибудь исключение из правил?
Ты проверил?
Нет, нет, нет.
Ну, проверь, проверь, что мы в первую попадаем.
Почему?
Значит, еще раз.
А почему мы попадаем...
Почему мы точно не в третью попадаем, понимаете?
Потому что Y это не R-value.
Потому что Y это не R-value, а эта штука только от R-value вызывается.
Ну, это K-value.
Y это L-value.
Первый пункт определения L-value, это переменная.
А, это же сдохнет дом.
Это пример очень, просто пример реальной жизни.
Но это же сломает мозг всем.
Да, я же предупреждал.
И что?
По-моему, она в третью попадает.
Нет, в третью, но точно не попадает.
А у меня попадает.
Может, он там тоже снимет?
Я тебе не доверяю.
Она попадает в третью.
Сейчас, ну он пишет локас.
А у нас уже обычный ссылка.
А, у меня третья, это ваша первая.
Угу.
Короче, он попадает в эту.
Блин, как вообще тебе доверять?
Ну-ка дай письмо.
Все нормально.
Да, все.
Мы проверили, что мы попадаем сюда.
Давайте выясним.
Еще раз, вот это очень важный пример.
Видимо, на нем мы сегодня и закончим.
Почему мы попадаем именно сюда?
И не сюда, и не сюда.
Я ломаю, доламываю всем мозг просто.
Мы точно не сюда попадаем,
потому что Y это L-value.
Мы не можем попасть сюда.
Сюда мы попадаем только от R-value.
Дальше у нас варианты.
Мы можем попасть либо сюда, либо сюда.
Но чтобы попасть сюда,
нам нужно сделать дополнительный каст
навесив const.
Мы можем попасть как сюда, так и сюда.
Но попасть сюда, это значит
сделать const-cast, const-intu, неявный.
А сюда мы попадаем
без кастов каких-либо.
Сюда нужно добавить
навесить тип.
Это более частная версия.
Это более общая версия, чем это,
потому что она годится для константных int.
А это только для неконстантных.
А у нас не константный.
У нас же не int, у нас какой-то очень странный тип.
Почему нет кастов?
Почему нет кастов?
Ну, формально,
там
я боюсь, что
я вам очень сильно упрощаю
на самом деле
мир.
Спасибо.
Сейчас я
давайте напоследок.
Ты не помнишь в каком разделе стандарта
написаны правила
выбора версии вот в этих случаях,
в этой ситуации.
Сейчас я попробую.
Давайте откроем главу
overloading, 276-я страница.
Тут в стандарте есть
параграф.
Где тут эта
эта штука?
Ладно, я не найду быстро.
Ну, в общем, вы можете открыть главу
16-ю в стандарте, overloading она
называется, она занимает страниц 30.
И там, значит, все формально
описано, включая правила, как быть,
если у вас вот всякие ссылки
и прочее.
Без амперсантов.
Да, это airvalue будет.
Если
написать вот так,
то да, мы попадем
вот в эту версию.
А если мы напишем вот так, то мы попадем в эту версию.
Это не очень логично,
потому что, по идее,
каст к тому же типу, который
есть, не должен менять.
Он меняет категорию expression.
Все, давайте на сегодня закончим, значит.
Живите с этим пока, как хотите.
Можете накопить вопросов,
в следующий раз мы о них ответим.
Ну вот пока живите с этим.
Мы начинаем главу 11-ю.
Торжественно открываем. Вывод типов.
Так как у нас формально семинары,
все-таки вопросы какие-то.
Вы вообще
подробно разбирали,
как выводится тип шавлонного
аргумента?
Ну типа, если вы напишете какую-то функцию,
template, type name,
t, void,
f, t, x, return,
x, нет, не return,
x, не суть. Вы понимаете,
как это t,
в каких случаях, к чему он равен?
Хоть какое-то представление.
Ну хоть в каком-то плане.
Я, например, вопрос
плохо понимаю.
Окей, хорошо.
Ну сейчас тогда выясним. Смотрите.
Собственно,
11.1 пункт,
это ключевое
слово авто
в его, да.
Сейчас там глава 11,
типа параграф 1 или как, не так у нас.
Кто заполнил телефон?
Там лежал
девайс.
Вот.
Собственно,
у ключевого слова авто, на самом деле,
есть несколько смыслов. Его смыслы менялись
с...
Закройте
дверь-то, пожалуйста, в итоге.
Вот.
Смысл ключевого слова авто,
на самом деле, менялись с развитием языка.
Сейчас
у него есть
основных
три значения, с которых мы на два
сегодня посмотрим.
Третью уже, наверное, не успеем.
Какой этап называется официально?
11 вывод
типов, 11.1
авто.
Вот.
Сейчас посмотрим на
первое.
Это, значит, так называемый
placeholder, то есть такое
слово, которое заменяет произвольный тип.
То есть, ну...
И простейшее
его...
Разберись сам, с чем мы это называем.
Ну, более-менее.
Сейчас рассмотрим, что мы конкретно
говорим компилятору. Значит, есть
, наверное, три основных варианта,
как в такой ипостасе, для меня это слово авто.
Первое, это в параметрах функций.
Значит, смотрите.
Вот. Я решил начать
с этого, хотя это, на самом деле, самое позднее
из введений. То есть оно...
Вот такой синтаксис появился в 20-м
стандарте, но, мне кажется, его проще всего понять.
Почему? Потому что это
просто, вот, эквивалентно
тому, что мы напишем...
Что такое string?
Ну, считай, что string.
Не суть.
Здесь это не принципиально.
Вот.
Значит, вот запись ниже.
Ну, все-таки я напишу string view, чтобы было
одинаково.
Если коротко, то это не владеющая строка.
Вот запись
на 14 строке просто
раскрывается в запись на 9 и 10
строке.
Вот это самое простое, что происходит.
Абсолютно эквивалентные вещи.
Соответственно,
мы можем навесить конст,
навесить конст на персант.
Ну, нет,
не при процессор,
это уже делает компилятор.
При процессор занимается только макросами и всякими
директивами по хэштегу.
По решетке.
Это уже встроено в язык, это круче, чем макросы,
но это вот такое преобразование
кода.
Ну, я утверждаю, что такое.
Что ты имеешь ввиду?
Ну, только, ну в смысле tail у вас не будет.
Какое-то имя
для этого типа придумается,
для этого шаблонного аргумента,
но вы его не знаете.
Есть вопрос, что если у нас
стрек функция, как сейчас
на 10-й строке, то есть мы ее можем вызывать
в целом для
разных типов данных, и она просто
будет новая создаваться
каждый раз.
Это все, все еще происходит на темпе компиляции.
На самом деле, посмотрите, как это все работает.
Это я написал просто функцию, чтобы меньше
занимать времени и места
на экране. Она принтирует строку
двоеточие, тоже справа.
То, что справа...
Давайте посмотрим, что делает функция f,
чтобы мы поняли, что я с ней собираюсь делать.
Она принимает аргумент и возвращает
название его типа. Это тоже кастомная
штука, я написал.
Она немножко...
Если останется время, посмотрим.
Она возвращает прям строкой имя типа
вот, аргумента.
Вот, соответственно,
можем в таком случае
посмотреть.
Как вы считаете, что...
Несколько простых примеров, чтобы я проверил,
чтобы вы не спите. Вот f от единицы, что
вернет?
Int. Справедливо.
Там, значит, если я...
Вот у меня есть const integer, это
для всех примеров сегодняшних будет
есть const integer и массив
с пяти интов.
Вот, если я функцию передаю
const integer,
просто const int, const integer
равно 1. Что вы увидите?
const int.
После этого
возникает вопрос. Илья, ты рассказывал им,
как появляются шаблонные
типы?
Нет? Хорошо.
Тогда я должен
сказать, что
значит, на самом деле
будет не const int.
На самом деле будет просто int.
И это то, почему
нужно об этом поговорить чуть поподробнее.
Смотрите, какие правила?
Правил много, как всегда, но
основные следующие. Если у вас
тип не ссылочный,
у него
отбрасываются
CV-квалификаторы.
const volatile.
const отбрасывается, про volatile
мы, скорее всего, не говорили.
Но const, что важно, отбрасывается
тот, который самый внешний.
Что это значит?
Если я передам в f,
я передам
что-то вроде
const int
звездочка
const pter.
Вот
что здесь вы видите?
const int звездочка, правильно.
Если же тип
ссылочный,
вернется то, что под ссылкой
не сама ссылка.
Вот.
То есть ссылки тоже отбрасываются,
когда мы вводим...
Ну,
известным, наверное, вам исключением.
Что такое универсальная ссылка, вы же знаете?
Нет.
Вы не успели.
Тогда за одним исключением.
Нет.
Это не xv.
Сейчас
перейдемся.
Значит, смотрите, есть
в языке особая запись.
Давайте перейдем сейчас, тогда посмотрим.
Мы можем написать
вот так.
Вот.
И это особая конструкция языка внезапно,
которая работает не так, как обычно.
Так, ладно, я не буду.
Давайте напишу.
Чтобы
он не ругался.
На что ругался? На то, что у меня не
использована переменная. Видите?
Желтенькое. Желтенькое плохо.
Нет, желтенького хорошо.
Asystile это хорошо, да?
Просто если я напишу как надо,
у вас будет еще больше вопросов.
Нет, к такому вопросов нет.
Ну, хорошо.
Окей, не суть.
Суть в чем?
Суть в том, что
когда у нас написано вот так,
именно так, никаких дополнительных
констов, именно rvalue ссылка,
и это именно шаблонный аргумент,
после которого стоит два амперсанда.
Это универсальная ссылка, она
выводится по другим правилам.
И она внезапно,
тип, который вы получите в value,
будет зависеть от того,
какую категорию выражения
вы передадите в функцию.
Обычно у вас тип
от категории не зависит. Здесь зависит.
Соответственно, если коротко,
то если вы передадите
в эту функцию rvalue,
то у value будет тип t2 амперсанда.
Если вы передадите функцию
lvalue, у value будет тип
10%.
Не совсем.
В смысле, да, правила сложения
амперсандов там есть, но то,
как выводится сам по себе t,
ломает правило то, как обычно
выводится.
Если туда передать const int
амперсант,
то будет именно он.
К чему я это сказал? К тому,
что это правило, в том числе
работает с авто.
Соответственно, эта функция
работает по тем же правилам.
Сейчас мы посмотрим чуть подробнее.
Сейчас посмотрим чуть подробнее.
Давайте дойдем здесь до конца.
Как думаете, что выведет
это f?
Нет, это она, к сожалению, не выведет.
Мы передали lvalue.
Я напомню, что f пока просто
авто.
Что?
Статик?
const char звездочка, все правильно.
Смотри, здесь главный тип,
это звездочка, самый внешний.
Поэтому он бы убрал вот этот
const, но не внутренний.
Итак,
int.
Напомните, как выглядят int?
Да, это массив
из пяти int.
Видите сверху?
int звездочка или
квадратные скобки?
int звездочка или квадратные скобки?
Смотрите,
я могу рассказать следующее.
Здесь в начале программы всегда будут
вводиться типы каких-то базовых вещей,
какие они есть. Здесь выведется
на самом деле int 5.
Несмотря на это, вот здесь
действительно выведется int звездочка.
Потому что это еще одно правило вывода аргументов.
Если мы получаем массив, мы его
дикеем к указателю.
Именно стишный массив.
Просто вот такое правило
у вывода шаблонных аргументов.
Это когда мы функции получаем,
в смысле, если как шаблон мы получаем
массив, то мы считаем, что это указание?
Когда еще раз
как выведется type?
Потом.
Она с помощью
некоторой магии возвращает имя типа.
Пока мы не знаем, как она выглядит.
Когда у нас еще раз массив,
когда у нас
случай, когда массив не указатель,
не очень было видно по коду.
В смысле, массив не указатель.
Вот смотри, здесь int.
А, когда я просто вызываю
вот здесь, я просто вызываю
type of int. Он выведет int 5.
А там мы что делаем?
Что, где мы что делаем?
В предыдущем коне мы тоже
написали. А, здесь мы вызываем f от int.
f выводит тип
и вот видите f. f выводит
тип
от аргумента. Аргумент она
преобразует в int звездочку.
Вот.
typeof это функция,
которую просто типа делает. typeof
да. Это функция
нет. Это моя функция.
Которую я частично стыдил
стасакой и рухлоу.
Просто это немного странно. Ты говоришь, вот мы запихем тип
в мою функцию и получаем вот это.
Нет. Ну, в смысле
я говорю, ну пока примите, что это
магическая штука, которая принимает значение
и возвращает его тип.
Строкой.
Но она не очень красиво сделана. Там просто на макросах.
Так, ну
пока это особо красивее не сделаешь.
Не суть.
Вот то, что она возвращает, это просто для визуализации
и потом проверим, что все правильно. Вот.
Что еще?
Значит, смотрите, у нас есть f от add.
add это что? add.
Смотри, add это функция. Она говорит, что
складывает, но она врет, но это не важно.
Вот. Это функция, которая принимает
int со ст возвращает ноль.
Если вы помните, у нас в прошлом семестре была
контрольная, на которой нужно было написать тип
функции, которая принимает массивы, вот это вот все.
Вот. Очень
удобно, когда есть авто, и не нужно этого делать.
И можно просто
передать функцию, которая принимает
штуки, возвращает int.
И...
И посмотреть тип. Нам разве
указательна функция?
Функции и указательна
функцию кастуются к друг другу очень просто.
Не нужно для этого специально ничего делать.
Вот.
Да, ну, смотрите,
вот что сейчас вы видите? Это все
скомпилируется.
Вот. Смотрите, мы вызываем f от add.
Вот.
Кажется, что здесь оно тоже
кастанется на самом деле автоматически
из вывода типов к...
Ну, и это будет не sizeT
на самом деле, потому что sizeT это просто
using. Настоящий тип там
unsigned
long.
Да. Ну, на моей машине
так. Ну, на моей машине так кажется.
Да.
Никто не запрещает.
Вот.
Значит дальше,
смотрите, у меня есть вторая категория.
Мы функцию f меняем, добавляя
к ней вот здесь const.
Ну, соответственно,
давайте быстро.
const int, верно.
const integer.
const int снова.
Что логично, как бы.
Но нужно помнить, что раньше это было не так.
Вот. Здесь что будет?
char звездочка const,
все так.
C,
int звездочка const.
Только что показывал CF.
CF это как f, только перед авто const стоит.
int звездочка
const, нет?
int звездочка
const.
Ну, мы же набрасываем на верхний тип const.
int звездочка const. Окей.
Сейчас посмотрим.
И add.
Вот здесь что будет?
Тоже очень простое упражнение,
на самом деле. Никого под лоха.
Все, все так.
У нас const просто добавится
после звездочки.
Вот.
const добавится вот сюда.
Вот.
И, значит,
в последний случай добавляется
ampersand auto.
Добавляется ampersand auto.
Ну, наверное,
можем, на самом деле, пока запустить,
посмотреть, что у нас сейчас получилось.
Ну, ничего страшного.
Значит, посмотрим то, что надо.
Значит, смотрите, вот у нас.
Какие типы были? int literal, int
string literal внезапно.
Это не char звездочка,
а вообще это тоже массив.
int и это int 5, как я обещал.
И const и даже const int.
Значит, первая секция.
const звездочка.
Сошлось. int literal int int
const char звездочка int вот.
Здесь все тоже сошлось.
Почти.
Да.
Не long int.
Long int, да.
Дальше мы добавили const.
Везде навесилось const.
И вот сюда добавилось const.
Да, кажется, сошлось.
Значит, const auto.
Здесь, на самом деле, начинаются некоторые
хитрости, потому что, как я уже говорил,
если мы принимаем
по имперсанду...
Ну, давайте посмотрим.
Что будет здесь?
const int имперсант.
Ничего необычного.
Print просто печатает
в консоль две вещи.
Первую и вторую.
Мы берем f по auto
какой-то const
и auto само сжирает
const.
Погоди, ты про print спрашиваешь,
или про что?
Вот там у нас наверху сжирался const,
сейчас перестал. Это из-за того, что мы принимали
просто по auto, оно сжирало, а потом
начало передавать по const auto, да?
Почему появился const?
Потому что он все еще сжирается, но мы навешиваем
руками чему угодно еще один const.
OK?
Print тут вообще не причем.
Print тут вообще не причем.
Print вообще строка приходит.
Да, он просто печатает строки.
Все.
OK.
Дальше что?
const char звездочка.
Так, вот здесь вот const char звездочка,
думаете?
А что мы еще f добавляем?
Мы теперь
кроме const добавили амперсант.
А я вам напомню,
что вообще-то,
вообще-то, строка это не
const char звездочка сишная, изначально.
Это массив.
Это массив.
Из раз, два, три, четыре, пять,
шесть, семь, восемь, девять, десять.
Из раз, два, три, четыре, пять, шестнадцать
элементов.
const char
шестнадцать
амперсант const.
Амперсант const.
Вот народная
мудрость. Навешивать const на амперсант
нельзя.
Амперсант всегда const.
Вы не можете менять то, на что строка
ссылается.
Мы можем перепривязывать ссылку.
Вы не можете перепривязывать ссылку.
Не можем, но можем менять то, на что строка.
Да.
Но, типа, если бы тут был указатель,
если вы меняете указатель, вы меняете то, на что
он указывает.
В смысле, сам указатель меняете, а не
то, что под ним. Ссылкой так нельзя.
Ссылкой всегда. Типа константная.
Если мы ее меняем, то мы меняем
тот объект, что под ним.
В общем, хорошо. Давайте посмотрим, что выявилось.
Значит, что у нас здесь?
const.
const.char.amper.16
Ну,
почти угадали с индексом, нормально.
const.int.amper.15
Вот, заметьте, у нас под
амперсантом оригинальный тип сохранился.
И здесь у нас просто
звездочка заменилась на амперсант. Это теперь ссылка
на функцию, а не указатель.
Почему когда был const, там был указатель
в верхней секции,
так.
Ну, вот.
Окей.
Вопрос в том, почему
у нас раньше было вот так,
а стало вот так?
Ну, смотри, оригинальный
тип у строки вот такой.
Окей?
По правилам вывода типов
в шагловных аргументах,
если у нас тип
не ссылка
и
массив,
то мы
из массива его кастим в указатель.
По правилам вывода шаблонных
аргументов, если шаблонный аргумент у нас
получается массив,
то мы его кастуем в указатель.
Вот это и происходит вот здесь.
Окей? Окей.
Соответственно, здесь происходит ровно то же самое,
просто еще один const навешиваем.
Дальше. Вот здесь
у нас уже это правило не работает.
Потому что у нас
автоамперсант. Автоамперсант это уже
ссылочный тип. Если тип ссылочный,
мы выводим просто то, что под ссылкой.
Строго.
Собственно, мы вывели
то, что под ссылкой, кажется.
Вот идентично то же самое.
const char
ampersand 16
const char ampersand 16.
Точно так же с int.
const int ampersand 5
const int
ну ладно,
ну мы ссылку навесили,
раньше он был не ссылочным.
Вывелось
const int 5,
мы навешали еще
нет, вывелось int 5,
мы навесили ampersand и const.
Получилось const int 5.
Все.
Вроде все сходится.
Понятно, да?
И вот теперь тогда самое
неочевидное.
Мы делаем вот эту вот самую универсальную ссылку,
которая работает по-другому.
Подожди, Федя, а вот то, что там было с функцией,
оно тоже как-то странно сработало?
Оно тоже как-то странно сработало.
Как именно? Здесь просто указатель заменился на ampersand.
Ну, смотри.
Опять же, функция кастуется в указатель на функцию.
Если она просто выводится как
шаблонная штука.
Теперь мы добавили ampersand, значит должен
вернуться просто тип.
Ну какой тип у функции?
Ну, собственно, вот такой
только без ampersanda.
Плюс мы
навесили ampersand.
Нет.
Ну, хорошо, давайте вот здесь делаем
такую же функцию.
int
not add
int
not add
int size t
Так, что там?
Size t.
Да, и давайте выведем
function type
type of
not add
int size t.
Вот, что у нас появилось?
function type
вот, просто int
от штуки, никаких звездочек.
Ну, а почему
должна быть звездочка?
Потому что мы разбирали синдексы с
первым семестрем.
Наверное, потому что мы взяли не указатель
на функцию, то есть не адрес ее,
а просто... Ну да, типа я
могу с тем же успехом написать
адрес функции.
Тогда
там будет звездочка.
Еще раз, в чем вопрос заключается?
По факту это указательная функция.
А, мы, наверное, говорили указательная функция.
Видимо, вопрос отпал в процессе
задавания. Окей. Ну, опять же,
тут в плюсах у нас
так сделано, что функция,
ссылка на функцию, указатель на функцию,
они практически
неотличимы на самом деле. Кроме каких-то
супер выдуманных
случаев вы можете
от всего этого вызывать
круглые скобки,
вы можете все это кастить друг к другу
имплиситно, так что
это, кажется,
никогда не важно.
Ну, функция по природе своей
это указательное место в коге.
Но вообще, я подозреваю,
что это на следе C.
Ну, плюс, это дает возможность
если зачем-то нужно
делать переменную указатель
на функцию и делать его в какой-то момент
nullptr.
Прикольно, наверное.
Ну, вообще, кроме шуток, я
в продакшн коде видел такое, что у нас есть какая-то
функция. На самом деле указатель на функцию
просто лежит где-то, доступный
всем. И когда программа включается,
в зависимости от каких-то настроек,
от каких-то конфигураций
в рантайме, в этот указатель
задумывается одна из разных функций. Не знаю,
логировать файл и логировать по сети.
Ну, банальный пример.
Да.
Нет, ничего.
Да.
Да.
Да.
Вот. На самом деле
это не просто какая-то глупое
и бесполезное правило, потому что
вы не можете
в коде
делать что-то такое.
Ладно, я даже не знаю, как это нормально
писать. Ну, в общем, если у вас
получился тип
именно массив,
вы, кажется, не можете приравнять его другому массиву.
То есть, ну, не произойдет
по символному копированию, это просто
тишная структура, у него нет оператора равно.
Поэтому, на самом деле, в большинстве случаев
с указанием работать действительно удобнее.
Правда, теряется информация о
его размере, что неприятно.
Если мы
в функцию, которая
const, auto, percent вызовем
от
int, auto, percent, она станет
const, int, auto, percent.
Сейчас, сейчас, какую функцию?
Ну, вот эту функцию, которая
CRF, кажется.
CRF, которая const, auto, percent.
Да, если мы вызовем от int, auto, percent.
Так.
То будет const, int, auto, percent?
Если мы ее вызовем от int, auto, percent. То есть,
мы делаем int, auto, percent,
ref равно 5.
Так, да?
Потом мы делаем CRF от
5.
И грим
print.
Давай попробуем разобраться.
Значит,
только нет 5 от ref,
видимо.
Так, что такое ref?
Ref, int, percent, percent.
CRF вызывается.
const, auto, percent, аргумент.
Ну...
Ну, const, int, percent,
конечно, будет.
Да.
То есть, он инициализирует
снуку из...
Давай так, почему это должно быть
CE?
Окей.
Это не то же самое, что int, да?
В смысле, не то же самое, что int?
Ref сейчас имеет тип
не такой же, как...
Ref сейчас
имеет тип не такой же, как...
Просто int.
Ну, вроде нет. С чего бы.
Ну, давайте вот так сделаем.
Посмотрим,
что нам первое выведет
последний блок.
int, percent, percent.
Ну, по факту,
все, что бы мы с ней не сделали,
то же самое, что с обычным int.
Да.
Что по факту происходит?
Компилятор создает, типа, временную
переменную.
Да. В целом, это
практически эквивалентно
к тому, чтобы написать int. Но
не совсем эквивалентно, потому что вот как-то я могу
выяснить, видишь, что это int, percent, percent.
Так, сейчас, стоп.
Что значит передать функцию универсальную ссылку?
Окей, хорошо.
Значит, смотрите, у нас есть теперь универсальная
ссылка.
Почему я функцию назвал frf?
Ну, я думаю, до этого должно было бы понять.
f функция, cf
добавили константу,
crf добавили константу и референс.
И frf
это потому что forwarding
референс она называется иногда.
Потому что позволяет
удобно передавать аргументы,
но об этом, видимо, еще чуть позже скажем.
Так вот.
Смотрите, единица это что?
Это тип int,
но value категория
rvalue.
Что у нас значит выведется?
Какой тип
нам вернет?
After percent, percent.
Нет, она ведет int, percent, percent, выведет.
Const integer мы туда закидываем.
Какой будет тип?
Просто int, percent, percent.
Вот, у нас уже две версии.
Все, да, int, percent, percent.
Int, percent, percent. Хорошо.
C string.
Не const, int, percent, percent.
Может const, тут два мнения
не поковоюют.
Мне кажется, что int, percent,
percent мы так константные как.
Нет,
int, percent, percent.
Он бы его не накидывал.
Он не накидывает сверху
константу.
Мы подали констант,
и ее уберет.
Но auto убирает
все консты, и поэтому он
убирает.
Auto без референсов убирает все консты.
Мы вообще не знаем, что такое
тип int. Поэтому const.
Подожди, Миша, тип int, percent,
это rvalue.
Нет.
Ну, в смысле
Миша, видимо, имел в виду, что мы
в чем вопрос?
Почему один имперсант?
Почему один имперсант?
Ну, хорошо. Какой у этого
тип? const, int.
Какая у этого категория? lvalue.
Это просто переменная.
В смысле?
Да.
Просто переменная это самое базовое
lvalue. Какое только есть.
Категория lvalue выводится один имперсант.
Окей?
Да.
Я начал
наш разговор с того, что это особенная
штука, которая работает
в зависимости от категории, которую мы
передаем.
Значит, один.
В каком комментарии?
60.
А, да.
Тогда у нас и в первой строке
должны быть.
А в первой строке изменить lvalue.
1 это rvalue.
Вы сказали, что const отбрасывается
когда?
Когда тип не ссылочный.
Не ссылочный.
Тип, который мы
подаем.
Тип, который
получается.
Нет, смотри. Видишь?
Даже учитывая, что мы передавали
не ссылочный тип, и то, что мы навесили
имперсант, уже изменило то, как он выводится.
Так что не совсем.
То есть имперсант в конце,
он с констами может что-то делать.
А имперсант после авто...
С ним не будет отбрасываться, на самом деле.
Если мы просто вот здесь напишем имперсант,
уже const не отбрасывается.
Дальше.
Так, что в строке это выйдет?
У нас тут literal.
Literal lvalue.
Literal lvalue, верно.
Что-то вы знаете.
Это хорошо.
Размер.
Нужен ли размер?
Мне кажется, нужен.
Только вот здесь, по-моему, 16 будет.
Да, ссылка на массив.
Вот так он выводит.
Что я сделаю?
Передай ссылу.
Окей, ну собственно все.
Мы остальное посмотрели.
Что тут? Абсолютно то же самое.
С int и с
функцией ничего не поменялось.
Потому что это lvalue.
Имя функции это lvalue.
Окей.
Хорошо. Это был
в теории самый простой и понятный.
С точки зрения
чистой работы авто,
я надеюсь, у вас нет вопросов.
Вот в этом варианте авто
просто буквально
синтактически раскрывается в понятную конструкцию.
Окей?
Все согласны?
Правила, да.
Ну я надеюсь,
что с этими примерами немножко,
с правилами тоже немножко
стало понятно, что происходит.
Смотрите, где еще
можно писать авто?
Значит, второй
пример, который я решил показать,
потому что я думал, что он очень простой.
Не тут-то было.
Да.
Это плюсы. Так, не будем показывать самое страшное.
Смотрите, вы можете
делать вот так.
То есть вы можете писать авто
в возвращаемом значении
функции.
Ну это вроде логично.
Вот. Вроде логично.
Когда мы пишем
return, мы можем понять,
что мы забрали. Да.
Соответственно, какие есть ограничения?
Все
не отброшенные
значения return
должны возвращать один и тот же тип.
Что это значит?
Что если у меня есть
то есть не тестоваться к одному?
Да.
Например, если я возвращаю int и long-long,
то оно будет на меня материться.
Именно так.
Вот смотрите. Подожди,
можно проведу, пожалуйста, пару?
Спасибо.
Смотри.
Мы можем принимать какой-нибудь bool.
Вот так нельзя.
Вот так делать нельзя
несмотря на то, что
вообще-то вот так делать можно.
Вот так делать можно.
Вот так делать нельзя.
Потому что
тернарник выводит
общий тип и кастует
к нему результат.
Да, конечно.
В смысле выводит тип во время компиляции, но в рантайме
кастанет, если надо.
Ну вот у int
с ist это будет очевидно
int.
Что?
Нет? Ты думаешь нет? Давай проверим.
Смотри.
Будет, будет, да.
Сейчас.
Я уверен,
что это все еще...
вообще const в возвращаемом значении имеет мало смысла
на самом деле.
Но, допустим, давай.
Можно.
CV-квалификаторы, значит, можно.
А если вернуть в одном
branch lvalues
и в другом lvalues?
Хорошо, давай выясним.
Так, во-первых, вот так уже можно?
Нет, стоп, так в обоих.
Ну нет, подождите, вот это вообще
не ссылка.
Ну ладно.
Нормально же вообще.
Переденную раму
создали? Нет.
Я скажу короткий ответ.
Просто авто отбрасывает все ссылки,
поэтому возвращаем эти бутыни.
Что авто делает?
Что справедливое?
Авто здесь работает ровно
по тем же правилам.
Значит...
Ну в смысле вывод типов авто.
Хорошо, а если
возвращаемый тип авто апельсанта?
В смысле? Возвращаемый тип
не может... А, в смысле если добавить
авто апельсанта?
Ну, тогда вернется...
Нет, в плане тогда он уже не будет отбрасывать ссылки.
Он все еще будет отбрасывать, а потом
помыть сверху.
Хорошо, давайте я объясню,
как это примерно работает. Значит,
у вас
берется return.
Представляется, как будто вот этот
значение return, этот expression,
как будто это аргумент функции,
у которой template typeNameT
t
x выводятся типы
и вот этот тип
подставляется возвращаемое значение.
Если тип вывелся одинаковый,
то все хорошо. Собственно, поэтому у нас
и CV-квалификатор нам разрешили взять,
потому что const
отбросился,
потому что авто отбрасывает const.
Давай вспомним.
Вот здесь был пример. const int мы передаем,
авто отбрасывает const.
Помнишь такое было?
Что значит в авто передавать тяжелую структуру нельзя?
Ну вот у меня есть структура
очень тяжелая.
А я ее хочу передать,
и она у меня скопируется вместо того,
что даже если я захочу...
Ты пишешь autoAmpersand,
ты передаешь. Сейчас, если ты хочешь из функции
вернуть lvalue или
ты хочешь из функции вернуть
тяжелую структуру?
Вы в функцию?
Напиши autoAmpersand.
Да, наверное, свободно.
Оно будет просто все по ссылке принимать.
Сказали, какая интуиция
вокруг этого, а не то, как это реально работает.
Вот, значит...
А, лямдовый...
Если я буду представлять не так, как это работает,
то это мне может не помочь.
Вот, смотрите, в чем большие плюсы.
Опять же, можно не писать сложные типы.
Вот мы тут возвращаем массив
из int. Мы не задумывались о том,
что лучше кастомить на звездочку, нормально.
Мы делаем return int.
Мы возвращаем функцию из функции.
Опять, очень удобно.
Можно из функции вернуть
итератор. Супер!
Здесь у нас небольшая развилочка.
У нас есть простые примеры,
а есть вопросики.
Ну, давайте быстренько с простыми примерами
развернемся.
Почему функция
high и higher order? Потому что функции
в других порядках те, которые принимают
и возвращают другие функции.
Что здесь вернется?
Type of high, high
результат вызова higher order.
int это массив из 5 чисел.
Это не СЕ случаем?
Что?
Нет, это не СЕ. Мы этот код...
Смотри, каждый раз, когда я компилировал код до этого,
этот код тоже компилировался.
Почему это должен быть СЕ?
Потому что у нас return int
определен... Он разный
для разных... У нас же несколько версий
return int, в зависимости от того...
А, сейчас, стоп.
Что?
Нет, не...
А, ну да, он его выведет сразу просто.
Хорошо.
Сейчас, видимо, один...
он возвращает на значение тоже массив
и приводит... Да,
ровно по тем же правилам.
Кажется, это указатель на функцию.
Это будет указатель на функцию?
Какой-то не указатель.
Указатель на функцию, которая возвращает
указатель на функцию,
которая возвращает
видимо, массив.
Нет, мы тут берем...
Мы берем только результат.
Просто указатель на функцию,
которая возвращает
указатель на массив,
а принимаем значение где-то.
Да, все так.
Ну вот, давайте запустим
вторую часть нашего семинара.
Вот, мы возвращаем
указатель на функцию, которая возвращает
не указатель на массив, а указатель
на инты. Конечно же, потому что опять же
массив дикеется к указателю.
Это важно.
В данном контексте это важно, раз мы
разбираем, как это работает.
Соответственно,
здесь все по-старому.
Дальше.
Смотрите.
Да, что ж такое? Это все самое интересное.
Показываю.
Вот сюда давайте.
Туда смотрите, туда не смотрите.
Вот у меня есть функция
add.
Которая принимает
что-то и что-то, и что-то возвращает.
У вас будет несколько этих функций,
в зависимости от принимаемых значений.
Да, конечно.
Какой тип будет у самодин?
Я сегодня уже
проспелерил. Это будет инт.
Возвращает инт? Да.
Здесь будет sizeT.
Вот.
Дальше что?
На самом деле,
вот такой синтаксис
с возвращаемым значением, это может сказать
неполная версия
синтаксиса вот такого.
Когда мы пишем
автовозвращаемым значением,
а после функции
стрелочку и что она вернет?
Сейчас разберем, зачем
это делается.
Во-первых, это просто новый синтаксис указать
с возвращаемым значением.
Если я пишу a.size-3,
оно не кастуется.
a.size-3.
Что такое a?
Ну, в любом массиве.
a.size-3 не кастуется к инту.
a.size-3.
a.size-3.
Тоже не кастуется.
G, ты мне утверждаешь,
что не кастуется, а после этого спрашиваешь,
кастуется ли.
Давай проверим.
Хорошо.
Потому что если мы напишем for int q
равно 0,
q меньше,
чем a.size-3,
это будет бесконечный цикл, если a пустой, например.
Это более-менее понятно,
потому что sizeT
это более широкий тип.
Если бы у нас
оставалось инт,
у нас было бы минус 2,
и бесконечного числа не было.
А a остается в sizeT,
потому что sizeT это более широкий тип.
А тут нам сказали,
что size плюс int кастуется в инту.
Да, действительно.
Почему-то нет.
Но он кастуется же.
В чем еще раз был вопрос?
Миша, можешь повторить?
Вопрос был в том, что тут сказали,
что sizeT кастуется в инту,
как минимум в некоторых примерах можно?
Да, вопрос.
И какой контент?
Запущенный код.
Ну, смотрите, вот здесь
скаставалось.
А вот здесь не скаставалось.
Честно говоря, я не знаю, почему.
Ну, смотри, вот видишь, у меня есть функция add,
да?
Принимает int и sizeT.
Здесь должны вывести
int и sizeT.
Авто возвращает, a плюс b.
И авто принимает сумму.
И тип суммы int.
Int плюс sizeT,
typo в самом 1.
Int плюс sizeT, int.
Плюс язык возможностей.
И язык возможностей и функции typo.
Что еще раз?
Вдруг функция typo реализована не вверх.
Вдруг...
Может быть и так.
Стоп, а sizeT это же using?
Да, но это на long consigned
using, а не на int.
Окей.
Ладно, это мистика, честно говоря.
Я попробую разобраться, почему так.
Но к следующему разу уже.
Что еще раз?
Нет.
Этот авто теперь ничего не делает.
Возвращается ровно то, что справа написано.
Зачем тогда вообще авто?
Сразу поговорим об этом.
Смотрите.
В чем разница между
тем, чтобы вот здесь писать тип
и вот здесь писать тип?
Разница, на самом деле, в одном.
Разница в том, есть ли у нас
доступ к вот этим объявлениям или нет.
Вот здесь есть.
Как это можно использовать?
Ну, что-то вроде того.
Мы можем вызвать
какие-то функции над типами
A и B
и сказать, что мы возвращаем вот это.
Чуть позже мы сегодня
дойдем до того, как
это прям можно использовать
использовать.
Но идея такая.
Окей.
Еще раз.
Нет.
Да.
Хорошо.
С одной стороны немножко раз, с другой стороны немножко
удивлен, что вы не спросили,
а что будет с трикурсивными функциями,
например.
Да, в общем-то даже...
Смотрите, что я могу сделать?
Что могу сделать? Значит,
if i
равно 0
turn i
иначе return
rec
i
минус 1
плюс 1.
Нет, все будет хорошо.
Зачем inline?
Смотрите, если я не делаю
inline, все-все еще работает.
Я получаю warning. Какой warning я получаю?
Эта функция
определена в header файле.
Правильно? Если этот...
Это HPP-файл, он инклюдится.
Если он заинклюдится в несколько
cpp-шников, у меня одна и та же функция будет
определена... Ну, короче, один и тот же
символ будет иметь разное определение. Если
я говорю inline, я говорю
компилятор, я понимаю,
что может быть так, пожалуйста, сделай так,
что все было хорошо.
Он не будет инлайнить
собственно.
Он все равно не сможет ее заинлайнить.
Это, ну, типа указание
линковщику, можно сказать.
Вот, смотрите.
Вот здесь что
выведется? Выведется
int rec
int.
Да?
Но есть один нюанс.
Как обычно.
Да, смотрите.
Что я могу сделать? Как я могу перевисать эту функцию,
в эквалентном виде?
Значит, я могу написать...
Если int больше 0, давайте
ретерним rec
от i-1
плюс 1, а иначе
ретерним 0.
И это ошибка компиляции.
Потому что когда мы дошли
до сюда, мы парсим файл сверху вниз.
Дошли до сюда.
Ага, мы должны вернуть rec.
Давайте посмотрим, что возвращает rec.
А я вычисляю, что возвращает rec.
Хрень какая-то, я не буду это вычислять,
говорит компилятор.
Ну да.
Да.
То есть будет еще?
Да.
Ретерн 0?
Да.
Если мы сейчас вот здесь напишем
if false
ретерн 0,
все будет хорошо.
Потому что...
Ну как бы самый тупой ответ.
Потому что так решил комитет.
Но что это дает?
Это дает, например, там какую-нибудь скорость компиляции.
Вот.
Но, в общем, вот так.
В смысле, еще раз.
Как работает авто?
Нам говорят, все ретерны должны
иметь один тип,
который выявится в авто.
Мы такие смотрим, ага, ретерны есть, 0, int.
Считай, что ретерны этой функции 0.
В смысле, int.
Иду дальше. Ага, ретерны этой функции int.
Так, я должен вернуть int.
Все сходится. int равно int.
Дальше идет ретерн 0, int равно int.
Все сходится, все работает.
Я не готов обещать, что это самое логичное
поведение, но это то поведение, которое есть.
Вот. И есть
еще один интересный нюанс.
Значит,
с этим вариантом авто.
Смотрите, какая есть прекрасная функция у меня.
Бранч ретерн.
И здесь возвращаю разные
типы.
По ифу, по булу.
И вообще разные, даже не
кастуются друг к другу. Но на меня компилятор не ругается.
Вот.
Да.
И с иф констекстуром
так можно.
Кажется, начиная с C++17
так можно.
На самом деле, странно, что раньше
что раньше.
Почему не сразу
так можно было?
Ну,
а в чем проблема?
Проблема в том, что у нас
выведется
функция с одним названием разными возвращаемыми
значениями. Ну, то есть в смысле
это не проблема. Все нормально. То есть вот
что у нас есть. Смотрите.
Вот. То есть я говорю first branch return
at true, second branch return at false.
Type of first у нас
будет один,
type of second второй. Там будет int и строка.
Вот.
Собственно.
Вот. Видите.
True branch basic string,
false branch int.
Вот.
Что?
Что?
Что значит
branch return?
Никакой.
Это не функция. Это шаблон функции.
Нельзя вызвать шаблон функции.
Можно вызвать только функцию. Чтобы вызвать функцию,
все ее шаблонные аргументы должны быть
известны.
Известны не значит, опять же,
как бы
явно написаны, но
должны быть известны. Если ты просто напишешь
branch return,
это не функция.
Окей.
Все.
И у нас остается последнее
простое использование авто.
Которое
на самом деле обычно используется.
Это переменные.
Вот.
Если коротко,
правила вывода ровно те же самые.
Мы представляем,
что
это на самом деле не переменная аргумент
функции, выводим типы
и подставляем тип, который получается
слева
пишем переменное равно
штука. Вот. Соответственно, с этими
знаниями
const auto tu выведет нам
очевидно
const int.
Поэтому с х нам выведет
просто int.
Что нам интересно, что
вот здесь вот у нас есть, смотрите,
const int number, авто
будет типа
конечно же просто int.
Потому что константы мы отбрасываем.
А да, но тут не int, да-да-да-да,
здесь будет onSineClone, да.
Вот. А да, смотрите,
при этом у нас синтаксис,
мы можем писать
автоназвание равно
инициализатор,
автоназвание
равно в фигурных скобочках
инициализатор, автоназвание
в фигурных скобочках инициализатор.
Это все одно и то же.
До сих пор пока в этом инициализаторе ровно
одно значение.
Да, могу.
Что если хочешь завести таким образом
инициализер лист? Так, давай
я из головы скажу, что если ты делаешь переменную,
то ты можешь.
Вот это будет инициализер
лист от int.
Но кажется, это работает
только в переменных.
По-моему...
Чем это отличается от строки 16?
Чем это отличается от строки 16?
А, ну конечно же тем, что тут у нас
несколько значений, а не одно.
А если я хочу инициализер лист из одного значения?
Тогда пиши std инициализер
лист от int.
Все, что
я могу тебе посоветовать.
Да.
Да.
Вот это будет такой
тип и std инициализер лист. Кажется, про него
вы говорили про него?
А, ну вы матрицы писали.
Так что да, это будет инициализер
лист.
Так, что еще тут есть интересного?
Ну правила
те же самые.
В том числе правила с
универсальной ссылкой.
Auto%&& работает так же.
Вот. Поэтому давайте быстренько
угадаем вот эти вещи.
И?
И?
Нет, блин, просто
int, да.
Просто int? Почему просто int?
Почему %&&?
Потому что это...
Потому что
он сам добавил 2 %&&.
А бы факто %&&
наверное.
Нет, в смысле, единица
это int.
Это не const. Но единица
единица это Rvalue, да.
И поэтому у нас должно
прибавиться 2 %&&
это значит... Но const и на есть.
Да, ну я не знаю
откуда вы взяли const.
Нигде нет слова const.
Просто нет. Но действительно должно быть Rvalue.
Это должен быть %&&.
Если мы берем ee, то что у нас стоит справа?
Справа стоит lvalue, название переменной.
Значит, должен быть %&&.
ee
Понятно.
Move всегда 2 %&&.
Move всегда 2 %&&.
Ну, типа того.
Из функции возвращается
ссылка %&&.
Это Rvalue, просто правило.
Если из функции возвращается Rvalue ссылка,
то это выражение является Rvalue.
Вот.
Класс.
Да, в форике тоже можно так писать.
Почему здесь
вектор bool?
Вектор bool здесь потому, что
в отличие от любого другого вектора, вы не можете
написать вот так.
Вот.
Потому что вектор
нанесен Rvalue в данном случае.
Нужно будет писать, например,
вот так, если вы хотите что-то менять.
Либо вот так, если вы не хотите ничего не менять.
Почему это именно с bool-овским вектором?
Смотри.
Что тебе bool-овский вектор возвращает по квадратным
скобочкам?
Новый объект.
Если функция возвращает
неосылочный тип,
это выражение является Rvalue.
Значит нельзя взять
Rvalue ссылку.
Не совсем.
Сейчас в смысле зануляться объект?
Да, но у тебя bool никто
не зануляется. У тебя есть bit-reference,
который можно мувать.
Его внутреннее состояние будет муваться.
Какие-то указатели. Указатели тоже будут
на самом деле тупо копироваться.
Я не понимаю, что значит это предложение.
Вопросительное предложение.
Еще раз.
Смотрите. Что такое move?
Действие move. Вызов move конструктора
или move оператора
присваивания.
Когда он вызывается.
При выборе
перегрузки функции вы понимаете,
что у вас
значение имеет
Rvalue
категорию.
Rvalue категория
может быть
достигнута тем, что откуда-то
у вас Rvalue ссылка. При этом
Rvalue ссылка может быть
частью Lvalue выражения.
Тогда не вызовется move.
Это коррелирующие
понятия, но не строго
связанные.
Тебе явно нужно помедитировать на эту тему.
Так, мы про это поговорили. Кажется, это
просто правда, это все.
Давайте посмотрим,
что у нас идет дальше.
У нас есть еще кое-что.
Собственно, пункт...
Так, какой у нас был?
Почему 8?
Ты мне врешь.
Сейчас будет 11 и 2.
Ключевое слово decal type.
Значит,
сразу же говорю,
decal type есть два вида,
которые работают по-разному.
Вот.
Пишутся одинаково, выглядят одинаково,
работают по-разному.
А ключевом слове
decal type?
Окей.
Смотрите.
В самых общих словах,
интуитивно, decal type
принимает какое-то выражение
и возвращает его тип.
Примерно.
То есть делаешь это
похоже на авто, на самом деле.
Вот.
Какие есть два типа у decal type?
Decal type от
просто объекта,
то есть названия какого-то,
типа от названия переменной.
И туда же вы можете делать
доступ
к членам этой
переменной или разыменовании
или доступ по указателю.
В общем, либо название переменной, либо просто доступ.
Либо произвольное выражение.
Вот давайте сначала поговорим
про то, как это работает с
переменными.
Смотрите.
Вот type name это опять моя функция,
которая принимает тип
и возвращает его имя строкой.
Окей?
Окей.
Вот здесь я взял примеры
из предыдущего файлика,
где у нас были
переменные с авто.
Мы увидим,
в чем разница. Вот смотрите.
У нас есть const int 2,
decal type at 2.
Так, это был
четвертый.
У нас увиделся const int.
Все, мы не отбросили const.
Мы на самом деле ничего не отбрасываем.
Когда мы попадаем в decal type
от entity, мы просто возвращаем
тип entity, какой он есть.
Ничего не меняем в нем.
Очень удобно.
Когда мы передаем функцию...
В какую функцию?
Сейчас, зачем
это нам нужно бывает?
Зачем нам узнать
тип выражения?
Нет, узнать тип
мы не могли бы просто type name
от 2 сделать.
Нет, type name это моя функция,
которая возвращает имя,
а decal type конструкция языка, которая
возвращает тип.
Да, здесь будет const int.
Что значит тип? Ну, смотри.
Это значит, что я могу написать вот так.
Она возвращает класс,
который является типом,
или что?
Нет, объект класса.
Она возвращает тип.
В каком виде?
Вот в таком.
Можно написать вот так.
Decal type от выражения 1 плюс 1.
Ну, давайте, ладно,
просто decal type от...
Не знаю, вот у меня есть int a равно 5.
Потом я говорю decal type от a.
Хочу, чтобы мой variable был ровно
того же типа, что и a. Как я могу это написать?
Вот так.
Такой же тип, как у a, пусть будет variable.
Теперь variable это int.
Unused переменная.
lvalue и rvalue это категории выражения,
это не тип.
Тип и value категории
разные вещи.
Да, амперсанды все сохраняют.
Я смешил вот так.
Теперь...
Он работает не так,
он выводит по-другому.
Вот.
Собственно.
Да, в данном случае variable
будет иметь тип
int%
Вот.
Собственно говоря,
здесь я...
В этих всех примерах показывается
ровно, что тип сохраняется.
Вот.
Ровно такой, какой есть. Вот у меня там, например, есть структура s,
у которой есть int, int% и char
амперсанд, амперсанд.
Я там смотрю,
какой тип будет у вот этого выражения.
Вот у этого выражения будет ровно такой тип.
Смотрите.
s и int
это int% char амперсанд, амперсанд.
Все точно так же.
Через точку тоже так же.
Все. Если мы вызываем
декл-тайп от имени
какого-то объекта, либо от
доступа к этому объекту,
все. Вернули просто его тип.
Видите, здесь
сохраняются все массивы,
сохраняются даже
const char это массив. Все хорошо.
Нет, это все
в компайл-тайме.
Для экспрешена другие правила.
Сейчас мы до них дойдем.
У тебя у любого экспрешена
его тип известен в компайл-тайме.
Да, да.
Вот.
Точно так же. Вот пример.
У меня сентенс, видите,
через авто выведен и
сразу же напрямую декл-тайпом.
И первый выводит еще раз
char звездочку, второй массив.
Вот.
After after const char звездочка
массив.
Окей, декл-тайп экспрешен.
Так, где он начинается?
Вот он начинается.
декл-тайп от экспрешена зависит
от value категории
выражения, которое ему передали.
Если экспрешена
lvalue
категория, ну
glvalue на самом деле,
то он навесит
1%. Если rvalue,
то навесит 2%.
Соответственно,
смешное, так сказать,
нюанс.
Если я добавлю скобочки
вокруг, вот здесь вот, что написано?
Здесь написаны примеры, которые были раньше.
Только я везде добавил скобочки.
Вот раньше у меня был
se, это
ну что-то вот такое.
А теперь se в скобочках.
Что делают скобочки? Скобочки
изменяют тот
декл-тайп, в который мы попадаем, потому что больше это не просто
название объекта, это уже какое-то
выражение. Более того, это
lvalue выражение в данном случае.
Вот.
Соответственно,
вот единичка там в скобочках
нам выдает
просто int.
Потому что я вам набрал.
Тут тонкий момент, значит.
Ладно, давайте сначала не тонкий момент
разберем. Видите, у нас все это
lvalue выражение мы просто навесили 1%.
То есть
раньше у нас se выдавал int,
теперь se выдает int%.
С стрелочка
i выдавал int, выдает int%.
С стрелочка r, референс,
выдавал int%,
навесили еще 1%, они не схлопнулись.
Все еще int%.
был char
навесили 1%,
стал 1%, по правилу
схлопывания амперсантов.
Скобочки навешивают 1%,
правильно? Нет.
Скобочки в зависимости от
категории выражения навешивают
на самом деле от 0 до 2 амперсантов.
Если это lvalue, то всегда 1%.
Вот, от 0, потому что, смотрите,
у нас раньше был int literal,
он возвращал нам
с скобочками тоже возвращает.
Это на самом деле всегда выражение,
скобочки ничего не меняют.
Для rvalue
в разных ситуациях они могут навесить либо 0
амперсантов, либо 2 амперсанта.
Он не смотрит.
Значит, смотрите,
для xvalue
мы навешиваем
2 амперсанта.
А для rvalue, который не xvalue,
мы навешиваем 0 амперсанта.
На самом деле, давайте
более понятным языком.
Я попробую коротко объяснить,
что такое xvalue.
У нас есть rvalue.
Какие у нас бывают rvalue?
rvalue это либо что-то возвращается из какой-то функции
или оператора, правильно? Объект просто
бессылочный.
Либо объект возвращается с навешанными
двумя ссылками.
Вот, если
в тупую
и без подробностей, то
xvalue это, если у нас
возвращается штука с двумя ссылками,
а prvalue это, если
возвращается просто тип
бессылочный.
Все.
Если xvalue, то
вот если здесь поставлю
sudo move,
то скобочки добавят 2.
Да.
Вот.
Видите, теперь int%
2 на 2.
Да.
Сейчас.
Почему
скобочки это всегда так работает, да?
А почему, допустим,
если мы подадим...
Нет, скобочки, еще раз, скобочки сами по себе
ничего не делают. Вот, возможно,
совершил ошибку. Скобочки ничего не делают.
Скобочки просто изменяют
тот декл-тайп, в который мы попали.
Есть 2 версии
декл-тайпа. Одна просто
типа наименований,
а другая от выражений.
И вот скобочки
превращают наименование в выражение.
Да. Значит, поэтому
сейчас вот будет следующая тема.
Да.
А сейчас сколько?
Ага, окей, хорошо.
Еще сейчас часик.
Быстро говорю. Смотрите, можно
писать декл-тайп от авто? Ну, мы начали
позже, между прочим.
Мы начали позже. Можно
писать декл-тайпа от авто, например, в возвращаемом значении
функции. Что это значит?
Это значит,
что
мы просим компилятор здесь
выводить возвращаемое значение
не как по правилам авто, а по
правилам декл-тайпа.
Да.
Ну, мы просто просим компилятор
выводить возвращаемое значение не по правилам авто
с отбрасыванием констам, с отбрасыванием
амперсандов, а по правилам декл-тайпа
с трушным типом.
Окей? Соответственно,
важное замечание. Если у вас есть какая-то функция
voidf,
которая, значит,
возвращает декл-тайп авто,
то у вас есть
функция,
которая, значит,
возвращает декл-тайп авто.
То вот это
void
лишний.
То вот это
не то же самое, что вот это.
Окей?
Поэтому просто так лишний раз
скобочки позаретерна не пишите.
Да.
Я буквально
не понимаю,
что это значит.
Я буквально на той неделе
на баш за такую фигню.
Нет.
Здесь будет 0 амперсандов.
Так.
Что мы не успели
с вами рассказать?
А, нет.
Этого уже сегодня точно не успеем.
Давайте я скажу, что
смотрите.
Соответственно, декл-тайп авто
работает тоже в объявлении
переменных. Его можно писать.
В аргументах функции нельзя.
И еще
одна его особенность. Если вы пишете декл-тайп авто,
вы никак не можете его изменять. Вы не можете
написать constant декл-тайп авто.
Так нельзя. Вы не можете написать
декл-тайп авто амперсанд.
Так нельзя.
Декл-тайп авто должен быть сам по себе.
Нет.
Нельзя.
Нельзя.
А зачем?
Да.
Декл-тайп от авто
это вот такая конструкция языка.
Нет.
Ну, типа.
Вот.
Собственно говоря,
если коротко, то все.
Соответственно, вот здесь можно
проходить по вектору булов даже.
Типа
не рекомендую, но можно.
Вот.
Тогда давайте, наверное, заканчивать.
Я вам
вышлю еще тогда в чатик этот
код и еще
некоторый другой.
Да, я вам вышлю код,
где используется
возвращаемый значение декл-тайп. Еще, значит,
быстренько с них пикну вот такую штуку,
которая с помощью, вот это вот квинтэссенция
всей этой пары. Значит, вы можете
вот
у нас добавились, кажется, в 20 или 23
плюсах
вывод ЗИСа.
Конст, не конст. Можно было раньше
так сделать. Вот здесь
у нас как-то
вы когда пишете квадратные скобочки, вам обычно нужно копировать
код
два раза. Для константной версии,
для неконстантной версии. Либо делать конст-каст.
Вот эта версия делать
без конд-каста автоматически
копию одной и той же функции для
константового и неконстантного типа.
Вот нужно посидеть, подумать,
как это работает.
Если вы это поймете, мне кажется, вы поняли,
что было сегодня за пары.
Вот.
Все.
