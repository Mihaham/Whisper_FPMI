Итак, всем привет. Спасибо, что пришли попозже. Там очень важные вопросы обсуждались на предыдущей
пары, отличие барокко от классицизма. Линия прямая, волнистая. Барокко – она волнистая, а прямая – это
классицизма. Но от культуры к науке сегодня я вам наконец-то расскажу полезные паттерны. Вот прям
такие метапрожные паттерны, которые можно использовать на практике. Это даст вам даже пользу
какую-то. Но паттерны невозможно понять в вакууме. Да и, блин, по-моему, у них нету даже никакого
описания нормального. Это просто такая штука, которая в народе обсуждается. Вот что-то мы там
называем type-statem, что-то называем expression-template. Ну ничего не понятно. Поэтому предлагаю идти от
частного к общему, уловить какую-то общую связь между всем происходящим, понять, что все это вот
на самом деле – это вот оно. И еще, что это примерно одно и то же на самом деле. Различия тут какие-то
косметические. Итак, первым нашим кейсом будут ранжи. Ранжи мы уже видели, уже как бы понимаем,
что там происходит. Правда ведь? Происходит что-то вот такое. Берем какой-то контейнер,
какие-то юхи навешиваем, получаем какой-то став. Ну и что будет, если мы… Ну вот это вот
притефункшн использует и строку возвращает функция. Что будет, если мы посмотрим на тип?
Мы уже знаем, что мы внезапно увидим, что мы запомнили всю историю изменений. Начали с
вектора. Тут ну какой-то маленький костыль, с которым мы так до конца не разобрались, ну бог с
ним. И take view. Ну вот он take был. Дальше фильтр навесили. Ну вот он фильтр. Ну и лямбда тоже
сохранилась. Прямо в типе получилась такая матрешка из того, что происходило. Окей? Кейс два.
Черт, возможно это будет очень короткая лекция. Вот я хотел заранее сказать. Обычно лекции
прошлогодние, поэтому с ними более-менее все понятно по таймингу и по содержанию. Это оригинальная,
вчера за пару часов накиданная. Возможно сейчас будет не очень хорошо. Но пока идем бодро. Второй
кейс. Фоли. Помните такую? Да, на конкарнсе вам про него Липовский скорее всего что-то
говорил, если у вас было конкарнсе, что мол от Фейсбуке ребята сделали себе вместо стандартной
библиотеки кастомную. Среди прочего в ней есть свои фьючи, которые там гораздо лучше стандартных,
тем что это фьючи, а не какая-то костыльная фигня. Юнифекс тоже от Фейсбука, но он похоронен.
И там не фьючи, а по-другому. Сейчас дойдем до всего. Да-да-да. Ну вот есть Промес. Поднимите
руку, если вы не умеете работать со фьючами. Это плохо. Короче, фьючи — это такой смешной канал
от одного потока к другому. И по этому каналу можно посылать ровно один объект. Промес — это
входная дырка, а фьюча — пока здесь ее нет. Вот некоторые фьючи — это выходная дырка, из которой
прилетают нам данные. В Промес один раз послали Инт, из фьючи один раз получили Инт. В стандарте
они тоже есть. Но проблема в том, что стандартный фьюч необходимо сидеть и реально ждать потоку,
пока не прилетит Инт. И это бывает очень неудобно. Тут сложно в двух словах объяснить, но вот практика
показала, что неэффективно сидеть и в трыде, ждать, пока нам прилетят данные. Там есть такой синхронное
ожидание. Поэтому придумали... Ну на самом деле фьючи и стандарты — это урезанные нормальные
фьючи. Вот нормальные фьючи придумали ребята из Твиттера, и весь Твиттер на них работает. И их
суть не в том, что можно дождаться результата, который вам прилетит из фьюча, из этого выхода,
а в том, что можно повесить колбэк на момент, когда прилетит результат. Такое синхронное
программирование, колбэки лучше там активных... Или там даже ну просто ожиданий. И вот это как бы
общая шняга, о которой постоянно говорят последние много лет в любых языках программирования. На
самом деле все, конечно, не так просто, но вот — фу, это колбэк. И вот здесь вешают какой-то колбэк
на значение, которое потом прилетит фьючу. То есть вот это вот via возвращает фьючу. Почему
пока не понятно — ну ладно. И эту фьючу мы превращаем в другую фьючу, навесив колбэк. Вот
фу, Инд, который прилетит, обработает как-то, ну в квадрат, например, возведет, или скастит
к флоту. И мы получим новую фьючу, которая уже что-то другое возвращает. И вот можно так колбэки
навешивать, навешивать, навешивать и такую цепочку вычислений получить. Вот за три минуты что такое
фьюча? Какая проблема у вас с этой идеей есть? Вот один поток отправляет данные в промисс, посылает
их. А кто-то другой совсем потом в другом месте пытается дождаться уже там после всех колбэков
обработанного результата. Вопрос — какой поток будет выполнять колбэк? Вот этот фу, вот который
отправил или который хочет принять? Ну вот вообще говоря непонятно. Поэтому ввели понятие экзекютера
тот, кто будет запускать колбэк, грубо говоря. И вот сказали, что мы хотим взять промисс получить
фьючу и сразу ей указать экзекютер, на котором мы будем исполняться. Что вот мы хотим, чтобы колбэки,
которые мы потом выдадим, они вот на этом потоке исполнялись. Ну конечно нельзя просто на потоке
что-то исполнить, там трэдпулы на самом деле, но неважно. Короче указываем, где исполнять вот этот
колбэк. В общем и целом проблематика понятна. Вот мы хотим указать, где исполнять вот этот колбэк.
В целом больше здесь ничего понимать не надо. Вот. Ну для кого-то это все было повторение. Но мы же
можем вот так написать. Ну то есть синтаксис вот такой в целом и фьюч. Вот вы взяли промисс,
получили фьючу. Там такой как бы билдер, навесили экзекютер, навесили колбэк. Но
можем поменять местами эти строчки. И что в такой ситуации делать? Если мы уже повесили колбэк,
то есть другого потока уже могло прилететь значение. И у нас уже есть значение и колбэк. И мы как бы
уже хотим исполнять колбэк, но еще не можем, потому что не знаем экзекютера. И начинаются всякие вот
нестыковки. Начинаются костыли, какая-то синхронизация дополнительная типа давайте подождем пока
выставят экзекютер. Можно проще. Фейсбу... черт. Да, окей, ладно, пусть так будет. Фейсбуки
придумали вот такую хитрую схему. Вместо того, чтобы испромисли доставать просто фьючу,
мы достаем некую псевдофьючу, семифьючу. Вот у семифьючи нельзя навесить колбэк.
Единственное, что с ней можно сделать, это навесить экзекютер. То есть вот это вот via
экзекютер вызвать. И вот как только мы экзекютер навесили, мы получим уже настоящую фьючу,
на которую можно повесить колбэк. То есть get семифьючу, возвращает семифьючу, via уже фьючу.
Колбэк навесили, все еще фьюча, но может уже другого типа. Почему это круто? Потому что если мы
опять накосячим и пытаемся местами поменять или вообще забудем эту строчку с via, нам сразу ошибку
выдадут. Что вот этого метода then value его нету в семифьюча. То есть мы на уровне системы типов
предостерегаем себя от некоторых ошибок. Вот такой кейс. Почувствовал кто-то связь вот этого с
предыдущим. С рэнжами. Вот рэнжи был ли кейс, вот фьюча в фейсбуке. Ну как бы да. Но тут ничего не
обращивается типами. Тут просто два разных типа. Семифьюча есть и есть фьюча. Вот их два. Ну да,
можно и тут пайп навесить. Тип. Это тупые фьючи, никаких концептов. Все на стэке хранится без
пендрежа. Они не ленивые. На куче в смысле. Все не ленивое, все активное. Вот тупой вариант. Ну окей,
чтобы лучше прочувствовать нам нужен третий кейс, хотя он конечно не поможет нам наверное. Да. Ну
стандарт хотят запихнуть наконец-то что-то вроде фьюч, которое стандартизирует наконец-то всякое
многопоточное программирование. Прям вот нормально стандартизирует. И код на этой штуке выглядит вот
примерно вот так. Я знаю ничего не понятно. Да, может даже кому-то не нравится. Да, тут много чего
можно по-другому писать, но в целом это должно казаться вам похожим на самом деле на рэнжи.
Потому что авторы у этих штук одни и те же. На что? Может быть. Может быть. Но это везде теперь есть.
Это и в фьючах, которые в твиттере придумали изначально. Там тоже венол был. Но что происходит?
Вот какой-то конструктор зовется, чтобы что-то получить. Потом он куда-то пайпается. То есть такой
поток данных. Потом эти данные. Вот это вот он. Это как бы тот же самый via, который мы только что
видели. Вот via и какой-то, via и executor. Вот этот он, это то же самое. Только тут переменовали
executor в scheduler. Потом там какой-то венол еще комбинируется несколько значений. То есть это
в принципе те же самые фьючи, только более статические, более оптимальные. Ну что значит
более статические? То же самое, что и для рэнжей значит. Что зашивается в принципе вся цепочка
вычислений в тип вот этого значения. То есть вот это это как бы такая фьюча значения в будущем. И
там зашито все вот это. Я вот очень хотел вам показать, как оно зашито. Но, к сожалению,
к сожалению, текущая имплементация вот как бы вот этого пропозала std exec. Вот в ней тут все
очень мудрено сделано. Очень мудрено. Тут все вот эти вот цепочка, она вот внутри какой-то лямды
зашита и через тип возвращаемого значения лямды как-то там восстанавливается. Возможно. Скорее
всего. Потому что, конечно, когда вот такие вот огромные вещи строятся, там все тормозит.
Короче, да. Предлагаю вам поверить мне, что здесь на самом деле ситуация такая же как с рэнжами. Мы
накапливаем, накапливаем, накапливаем какую-то вот последовательность операций, которые были
раньше. А потом их все схлопываем. Давайте к следующему кейсу перейдем, который мне
гораздо ближе к сердцу. Вы, конечно, не знаете, что это такое. Можете по ссылке догадаться,
о чем сейчас речь пойдет. Такой кусок кода. В двух словах. Что здесь происходит? Все. Что происходит?
Мы хотим специализировать или даже издалека зайти? Наверное, нет. В общем, в какой-то момент мы
хотим в коде декларативно задать, какие ресурсы мы запрашиваем из какой-то там абстрактной среды.
Мы ее просим, дай нам такие-такие-такие ресурсы. Мы с ними собрались делать это, это и это. И за
нас какой-то runtime волшебным образом все делает. Ну и код вот этого запроса ресурсов выглядит
примерно вот так. Что мы там говорим? Реестер мы хотим прочитать текстуру с именем вот таким.
Использовать ее будем в пиксельном шейдере, если кому-то это о чем-то говорит. Ну короче,
будем где-то там использовать в специальном месте. Ну и вот это вот использование, его обязательно
там нужно указывать. И как использовать? Да, это вот где использовать? А как прицепить какой-то
переменной? То есть там как бы отдельный язык, к нему нужно такой интроп прикручивать,
прокидывать всякие данные. И вот мы говорим, что через вот такую переменную, объявленную вот в
другом языке, мы собираемся работать с вот этой текстурой. Текстура слова не вызывает вопросов.
Да, сейчас я могу очень сильно бежать, пожалуйста задайте вопросы про все слова,
которые вы не понимаете. Потому что тут конечно много специфики, но трюк. Текстура это картинка,
вот картинка из пикселей. Вот подряд идут пикселя и вот. Что? Бывают 3D текстуры. Ну то есть это конечно
странная такая штука, но вот вообще изначально словом текстура назывались картинки, которые
налепливаются поверх моделей путем развертки. А сейчас наступила деградация и слова картинки и
текстуры стали синонимами. Это конечно вот печально, но вот так вот. То есть это как пиксель,
фрагмент и тексель. Вот вообще говорят все разные слова. Ну вы наверное только слово пиксель знаете,
да? Ну вот да, это вот в эту сторону различия, но еще там есть фрагмент отдельно. Ну вот как бы
шейдеры изначально назывались фрагментными, потому что работали на фрагментах, а не на пикселях,
а потом пришли Microsoft и такие да все же одно и то же и назвали пиксельными. И теперь всех путаницы
и все слова слились в одно единое и никто не различает. Ну ладно, что-то это в сторону отошел.
Вот это отличный вопрос, про него нужно тоже обязательно сказать. Я хотел даже слайд вставить,
но не успел честно говоря. Значит к такому интерфейсу мы пришли далеко не сразу. Изначально
действительно был просто метод ReadTexture, куда вот эти вот вещи прокидывались параметрами. Потом
внезапно оказалось, что на самом деле есть куча нюансов, что вообще-то есть еще всякие конфиги,
запросы, что можно сделать опциональный запрос, можно там насильно переключить как мы используем
детали. В общем, вот здесь еще на самом деле куча разных опций есть, что дописывать. Это
A, то есть можно дописать точку optional, можно дописать точку handle, ну дальше я там покажу.
Много разных комбинаций того, как можно читать текстуру. И вот метод стал ReadTexture просто каким-то
диким монстром, у которого куча дефолтных параметров, некоторые из которых вообще були какие-то.
И ты видишь вот такое типа ReadTexture, две строки, вот такая строка и такая. И ты типа,
вот к чем отличается FarDownSampledDepth от DownSampledFarDepth? Вот они просто в аргументы методу
кидаются и как бы пф. А дальше еще четыре буля и какие-то вот такие вот енамчики. И типа невозможно
с этим работать. Плюс невозможно это расширять, потому что вот эта вся система, она постоянно
меняется, мы ее дорабатываем, улучшаем, что-то добавляем и... Да, как только мы что-то решили
добавить, в метод прилетает еще один аргумент и еще один аргумент. И в какой-то момент надоело
ходить и править код при добавлении нового аргумента. И людям, просто читающим этот код,
нифига не понятно, что происходит. Поэтому переделали на Builder. Вот это вот какой-то вопрос был.
Да, про это дальше сейчас пойдет речь, что таки некоторые конфигурации невалидные. Вот в этом
еще проблема. И получился pattern builder. И пока что... Да? Отличный вопрос, про это поговорим дальше.
Нет, ну ты на неправильных вещах концентрируешься. Потому что когда я закрою вот эти вот все вещи
руками, и ты увидишь просто вот там две строки, еще там другие штуки сейчас будут, ты ни черта не
поймешь, что происходит, что этот метод делает на самом деле. Можно потом все вот эти вот строки
в одну слепить, в одну сигнатуру метода, и тогда будет в принципе понятно. Но еще нужно на сами
аргументы посмотреть, чтобы понять, какая строка к чему отвечает. Какая строка это название ресурса,
а какая название там переменной какой-то. Для этого я слышал, что делает, например, у нас что текще,
что bind to shader var это все строк получается, а можно сделать как бы для них специальные,
как они называются, пусть есть... Strong type def, да. Чтобы это были разные типы. Ну ты не поверишь,
здесь примерно это и происходит, но это альтернативный выбор, да, можно. Мы решили пойти не по этому пути,
потому что помимо bind to shader var есть еще 10 разных вариантов, что можно сделать. Ладно,
не 10, 4. Ну все равно там немало вариантов. И для каждого из этих вариантов, что мы можем сделать с
текстурой, какие-то свои опции. И вот эти опции, как их прокидывать в один метод? Ну окей, ладно,
не будем, это же глупо, в один метод давайте разные методы сделаем. Возможно. У нас, к сожалению,
сейчас C++17, если бы был 20, то можно было бы со структурами сделать. И там указывать всякие,
ну как стракчер, дизигнейт, это не шалайзер, вот. Слышал про такие. Ладно, ну сейчас покажу попозже
тогда. Ну вот с такими трюками можно. Вариантов много, но мы остановились вот на этом и сейчас
я буду пытаться вам продать. Почему? Это здорово на самом деле. Вот такая штука. Вот если мы этот
stage не указали, должна быть ошибка. Вот это некорректно. Ну почему? Потому что на GPU есть
разные кэши, которые некагерентные, их руками надо флашить. И в общем, если вот это не указать,
то мы не знаем, какой кэш флашить. О, приходите программировать GPU, ребята. Да, то есть это
проблема. Хочется это валидировать как-то. Еще вот такой пример есть. Еще к вопросу, почему мы такой
решили взять. Потому что внезапно есть legacy, которое надо поддерживать. Вот тут я вот так вот сделал,
типа bin to shader var и все работает. А есть вот такие куски кода, там по тысяче-две тысячи строк,
где там какой-то ресурс, только этой переменной цепляется, только той, только десятой, и все это
написано руками. И с этим тоже нужно как-то работать. Поэтому мы там сделали способ увернуться от вот этой
всей системы запросов и получить прям handle на ресурс, который уже можно руками дальше куда-то
закидывать, куда тебе надо. Ну и в таком случае нам там нужно явно указать, как мы его будем
дальше использовать, чтобы опять же кэши там правильно пофлашить. Аля там вот здесь вот эта штука
не явно говорила, как мы будем использовать. А здесь нужно явно, потому что мы не понимаем,
какое будет использование. И если вот это вот убрать, ну опять же, нужно выдать ошибку. Что вот
нельзя получить handle, пока ты не указал, как будешь использовать. Но при этом еще вот такая
комбинация должна работать. Вот как бы с методами я не очень себе представляю, как все такие комбинации
перебрать. Что мы могли и просто заменить shader var, и еще там взять handle, и как бы понести его куда-то
дальше, что-то с ним хитрое делать. А почему тут очевидно, а до этого не очевидно было? Потому что
bind to shader var написано. Вот use as явно говорит, как ты будешь использовать. Bind to shader var это
один из способов использовать. Вот просто есть yinam вот этот вот, и вот в нем есть прямо элемент
yinam usage shader var. Вот про это речь. То есть тут как бы куча таких разных хитрых комбинаций,
которые вот без такого билдера как-то не особо рассматривались. Он возвращает handle, из которого
можно ресурс руками достать и работать с legacy кодом. То есть идея вот этого всего автоматизировать,
все такие вот запросы типа вот bind to shader var, можно как бы это проще, чем то, что там было до этого
по хитрым техническим причинам, сейчас не буду вдаваться. А есть legacy, но которые переписывать
пока сил нету просто. Там очень сложно, там очень мудренно, напутано все. И для вот этого кейса legacy
нужно прям достать сырой handle и прям с ним ручками что-то поделать. Ну вот, и как бы мотивировка.
Почему такой билдер? Потому что куча разных комбинаций. Вот методов получалось слишком много. У нас
были методы изначально. Простые, казалось бы, понятные методы. Их стало слишком много, с ними
стало мне неудобно работать. А еще вот я тут read показал. Помимо read есть еще там modify, rename и create,
а еще register. И вот там как-то очень много комбинаций получалось, очень много методов и... А, еще есть
буферы, кроме текстур. То есть ну там совсем взрыв мозга был, поэтому мы сделали так. И вот все
вот эти вот ошибки, которые надо валидировать, мы конечно же валидируем прямо на этапе компиляции.
Вы уже должны догадаться как. Нет, ну какой свинае? Ну ты прав, конечно, что там есть свинае,
потому что у нас C++20 нет. Да, куча дополнительных типов. Я, наверное, даже вам их покажу. Да,
камеру придется... Не знаю, просто пусть экран будет видно, мою говорящую голову-то вообще не
может. Так, давайте только за временем слететь. У нас еще час. У нас еще час. Слишком быстро идем.
Можно еще проборок? Можно. Мы хотим уловить общую связь между всеми вот этими вот кисами,
которые я показываю на самом деле. Ну в каком-то смысле. Не тот файлик. Нужен вот этот файлик.
Ну вот файлик. В нем есть куча всяких разных методов типа read.
Причем две версии. Какой-то history, modify, rename, еще что-то. Ну и остатки старых методов это
неинтересно. И вот они как раз возвращают некоторый virtual resource semi-request. По-моему,
это отличное имя, но лучше я не придумал. Значит, нам нужен virtual resource semi-request.
Потому что это не настоящие ресурсы на самом деле. Да, там некоторая абстракция
поверх настоящих ресурсов. Нет. Виртуальность значит не напрямую. Типа индирекция какая-то
в моей голове, по крайней мере. Ну вот тут такой смешной класс, и он какой-то ресурс-реквест
policy принимает. Наверное, стоит уже несколько вкладок начать открывать, потому что мы тут офигеем.
Ну я control-кликнуть вообще хочу, но...
Сейчас. Вероятно, мне стоило заранее все эти вкладки открыть. Я тупанул. Ну вот, я открыл то,
что нужно. Смешной енам. В нем есть какие-то битовые флаги, которые описывают свойства
реквеста. Что там, он был read-only, опциональный, запрос истории, имеется ли одно, имеется ли другое.
И вот этот semi-request, у него прямо в тип зашито, аргументом шаблона, элемент этого енама. Ну,
произвольные флаги, которые описывают... Вот бесит GitHub, а? Зачем он мне это открывает? Почему
не пропадает этот? Веб-технологии были ошибкой. Да. То есть прям в типе хранятся какие-то флаги по
поводу того, что происходило. Ну и здесь там выбор текстуры или буфер, и пока что эти флаги
просто прокидываются без изменений, что не очень интересно. К вопросу про что будет,
если что-то там недовызвать. Ну вот здесь будет нехорошо, конечно. Вопрос, как сделать хорошо,
очень просто. NoDiscard дописать. Атрибут NoDiscard. Да. Я его не написал, не знаю почему,
потому что в моей голове полгода или год назад это было не сильно большой проблемой. Вот такой
атрибут есть, который можно повесить на класс или функцию. Если повесить его на класс, то объект
этого класса нельзя будет просто выкидывать, не использовав. Если повесить на функцию, то
и возвращаемое значение функции нельзя будет выкидывать, не использовав. Вот этот атрибут бы здесь
проставить и очень много где. Я, наверное, даже этим займусь в понедельник. Очень хорошее замечание было.
Ну вот это часть паттерна. Если у тебя типа всей цепочки известная, то ты можешь не на куче
хранить, а прям внутри своего объекта, как поле хранить, без локации. В этом и смысл RNG и вот этого
execution, который я показал. Нет, проще смотреть вот на это. Ну вот ты пишешь класс FilterView и тебе
что нужно? Тебе нужна какая-то лямбда, какая-то функция, и нужен какой-то другой view. Что ты
сделал бы в OP-мире? Ты бы завел интерфейс iView, какой-то интерфейс iFunction и хранил указатели на два
объекта на стеке, ну какие-нибудь уникпоинтеры. И мы расходуем память, расходуем perf на индирекцию
и на то, что на куче выделяем память. Плохо. А здесь-то мы внутри класса FilterView, мы знаем,
какой нам view прислали. Вот этот. Не какой-то там, а вот конкретно этот тип. И знаем,
какую лямбду прислали. То есть мы это все в своем типе храним? Да, мы храним всю цепочку внутри типа
посредством аргументов, а в самом инстансе объекта мы прям по значению можем сохранить
вот эти вот вещи. В начале цепочки, в смысле где-то где вектор, например, да? Ну здесь мы пока не
знаем, куда нас засунут. А зачем нам? Ну как бы цепочка состоит из вызовов каких-то функций. Вот
ты вызываешь функцию Take и она должна конструировать новый объект, в котором как-то должны сохраниться старые
объекты. Но старые здесь это вот этот вектор или там ссылку сохранить и цифра 3. Ну ты сделай
структурку, в которой лежит ссылка на вектор и int. Причем ссылка на какой вектор ты знаешь,
вот у тебя тут тип есть. То есть это прям вот просто структурка. Да, да. Да, а потом эту матрешку как-то
схлопываем. То есть если ты начнешь, ну в самом конце, в прошлый раз я range 100 показал, помнишь его?
Вот он как раз схлопывает матрешку, перекладывая ее в какой-то конкретный контейнер. Ну или если
даже ты просто проитерируешь какой-то view, то ты тоже как бы схлопнешь матрешку, когда begin вызовешь,
он там по всей ней пройдется и накопит все, что там необходимо знать.
Ну с type-листом да, здесь аналогий конечно много, но я их не продумывал. То есть в задачи type-листы вы
примерно то же самое делали. Вы в итоге вот наворачивали такую матрешку, где все старые типы,
друг к другу как-то хранятся просто за счет того, что как бы лист это и есть алгоритм, который
отработал. Вы же все такие трюки использовали, что не делать через cons, а прямо структуру,
которая реализует алгоритм, становится хранителем head и tail. Вот такие вещи. Ладно, кажется вопрос
понятен. К самому интересному, что вот virtual resource request, у него есть эта прекрасная полиция,
ну еще там какой-то тип, но это не суть важно. А дальше начинаются методы, которые bin to
shader var. Ой да, когда я говорил, что у нас много вариаций, я не шутил, у нас тут еще и матрицы
через эту систему, прокидываются и view, и проекции, и там, а вот, собственно, use as, и at stage,
который я, а где at stage, а вот он. Вот, и комбинаций много, и вот давайте на at stage внимательно
посмотрим, потому что тут вся суть возвращается как бы тот же шаблон, но с другими шаблонными
аргументами. А если в фоли прям два отдельных класса было, semi-future и future, то вот здесь вызов
at stage вернет как бы другую специализацию того же шаблона класса, у которой там аргумент один
шаблонный просто прокидывается, а вот второй прокидывается хитрым образом. Ну, тут у меня
не очевидно написано, но вот этот flip policy, он берет ту policy, которая была раньше, где она? Вот она.
Берет ту, которая была раньше, и какой-то битик меняет на true. Ну, то есть суть был экземпляр такого
класса, у которого в типе было написано policy, в которой не было, как же я потерялся в этом коде,
где в типе не было вот этого битика, а как только мы at stage вызвали, битик появился в типе, тип
поменялся и битик другой, а вот method handle, он внезапно требует. Ну, представьте, что это requires,
а не какой-то жуткий macro со свина с спиратоном внутри, но мы просто requires пишем, что мы требуем,
чтобы была policy has usage stage, has usage type. Единственный способ их там выставить, это вызвать
at stage use as. Таким образом, в обратном порядке не скомпилируется, потому что тип другой,
там пока не выставлен битик. Надеюсь, вы примерно поняли вот эти трюки мои с policy, и это, по сути,
вот есть основная идея. В шаблонах типа хранится некоторое состояние, которое ограничивает,
что вы можете делать с текущей специализацией нашего класса. По этому коду, по унывающим
лицам, вижу вопросов нету. Да, requires это жуткий макрос, который тут там еще закостылин под
doxygen и потом за undeflin. Ну, в смысле, нужно ли где-то еще свиная в коде, да, нужно, но я предпочитаю
каждый раз заново такие хаки делать, не давать распространяться грязным хаком по всей кодбазе.
Ну, то есть, как бы, обновиться на C++ 20 — это вопрос нескольких месяцев для нас сейчас. Вроде там
все готово более-менее. Ну, вот надо просто сесть и сделать. Да, просто вот requires, оно здесь не
зря называется requires, я просто напишу прям обычный requires с C++ 20. А что еще здесь хорошо посмотреть?
Мне нужен код. Не знаю, что тут у меня. Смешная проблема может возникнуть. Ни фига не видно, да? Сейчас.
Вот я что-то такое писал, да. А, собственно, почему дискарты меня не волнуют, сейчас я и покажу.
Вот такой код написали и решили дальше продолжить.
Блин, ну, наверное, как-то так, да, на таком примере. Вот такой код нас не очень устраивает и вообще это
что-то странное. Ну, как бы, просто вот этот вот билдер, он был сделан исключительно для того, чтобы
декомпозировать сложный метод с кучей аргументов на маленькие кусочки, где аргументы постепенно
указываются. Вот мы не хотим, чтобы люди умничали и вот такие какие-то вещи, а еще, не дай бог,
вот этот вот объект промежуточный, какой-то там реквест, сохранят куда-то в поле и начнут куда-то
прокидывать его, это будет полная дичь. Поэтому от этого нас сохраняет и спасает вот так. Вот такая
смешная штука, два амперсанда. Да, ну, я уверен, что кто-то здесь не знает точно, что это такое. Ну,
вот это вот, это то же самое, что и конст в конце, то есть конст после метода. Это значит, что аргумент
this, то есть текущий объект, он должен прилететь через value expression. Иначе говоря, вот такой код
тупо не скомпилируется. Почему? Потому что вот это, какая категория? l, это переменная, имя переменной,
можно написать move, но это уже заставит человека задуматься, что это он странное такое делает,
да? Видим вот такой код и как-то уже неловко, что мы два раза move-нули и, ну, наверное, что-то не то.
Вот, окей. Что? Конст? Если бы вот так написали, да, это не сработало, потому что тут указано,
что не конст должен быть. Но, если честно, над конст-семантикой тут вообще не думал,
потому что не задумано так делать. Задумано не умничать, писать просто и радоваться жизни.
Нет, конечно. Все это придумано абсолютно не мной. Если мы загуглим type state, да, это прям вот,
мне кажется, это что-то не то. Ну, какая-то первая ссылка, да, какая-то первая ссылка из Гугла.
Покажите пример кода. Я, по-моему, ее открывал, и здесь был пример кода.
Ну, вот тут какой-то пример кода, вопрос только. Ну, вот, кстати, да, насчет машины
состояний, в принципе, да, вот то, что у меня тут написано, это машина состояний, по сути.
Нет. Ну, в смысле, это во всяком случае стоит машина, потому что вот у нас есть вот это полисе
смешное. Вот полисе. Это текущее состояние. А дальше есть какие-то переходы между состояниями.
Блин, картинку даже можно нарисовать. На следующий год нарисую обязательно. Ну, вам приходится терпеть.
Так, ну и вот тут у ребят какая-то картинка есть, что вот тортует с пустого билдера,
дальше header добавляет много раз, body и build и все. Ну и, кажется, эта библиотека как-то что-то
позволяет делать, и меня смущает, что они тут не показывают, да. Давайте экземпл откроем.
А ну вот, R-value ссылки. То есть это частая такая техника, идиому можно сказать.
CC это странное... Да, как бы у всех свои расширения.
Да, ну... Возможно слит, если написать. Надо слит написать, да. Тут есть прекрасная лекция,
вот где подробно рассказывают про этот паттерн. Если вы чуть-чуть видите хотя бы,
вот тут тоже самые R-value ссылки используются. И вот тут, и вот тут. То есть нет, это супер частая
штука. Вот, я, конечно же, ее не сам придумал, я вам рассказываю только. Давайте пойдем к следующему
кейсу. Хватит хвастаться моими достижениями. Ну вот, надеюсь, я как-то немножко прорекламировал,
что вот эта штука конкретную задачу решает. И вот она не просто где-то там в вакууме чуваки
на гитхабе библиотеки пишут, а прямо сейчас в проде крутится вот это все.
Eigen. Eigen. Что-то на немецком. Да, собственная, ну библиотека собственной, она про матрицы. Вот
какой-то отрывок кода. Ну какую-то матрицу создали. Ну, наверное, пока посижу, там уже немного слайдов
осталось. Да, кстати, тут тоже есть метапроженный трюк, на который я даже так не посмотрел особо,
наверное. Давайте подумаем, что происходит во второй строчке. Нет. Но не вектор, а матрица. Да,
вот тут матрица 3f. Это значит, матрица 3 на 3 из флотов. И вот у нас тут 9 значений этой
матрицы забиваются. Но какого черта это работает и как? Потому что, видовость двига возвращает
другой тип. Не матриц 3f, а что-то еще. Вот, по-моему, ты прав. По-моему, там именно как-то так,
что-то такое схитрили. И у них приопределен оператор запитает для какого-то их типа,
возвращаем его отсюда и чисел. То есть, вы как бы единичку, да? Вот это кажется, что парсить надо,
что вот этот список с запятыми вдвигается в матрицу. На самом деле, нет. На самом деле,
здесь единичка вдвигается, а дальше через запятую перечислено все остальное.
Ну, а в чем проблема? Инты кастятся к флотам? Ну, как-то это работает, в общем. Я проверял,
этот код компилируется. Ну, дальше мы берем матрицу, саму на себя умножаем, вот третьей строчки.
Берем два вектора, тоже какие-то вводим, вектор наперемножаем друг на друга, и вот ту матрицу
умножаем на итоговый вектор. И хотим посмотреть на тип. Ну, я думаю, уже можно догадаться,
что мы увидим там то же самое, что и в ренджах. Ну, тут совсем все понятно должно быть, даже понять
нечем в ренджах, правда? Вот у нас какой-то эйгенпродакт двух матриц. Вот там матрица 3 на 3,
матрица 3 на 3. А дальше все это вместе еще раз продукт на матрицу 3 на 1. Ну, потому что вектор
это тоже матрица. Ну, и векторное произведение скушалось внезапно, а вот там произведение матриц,
они отложились вот в такую некоторую цепочку тоже. Зачем? Там есть оптимайзер.
Бэк пропагейшн тоже через эту технику можно устроить в плюсах. Но тут это сделано не для
бэк пропагейшна, тут это сделано, по-моему, чтобы все-таки заоптимизировать. То есть вот почему они
сразу не перемножают матрицы? А потому что у них есть опять же великое множество комбинаций. Спарс
матрицы, такие матрицы, там косолинейные, криволинейные. Да, и они сначала строят вот
это все дурацкое дерево. Это же дерево, по сути. И в ренджах было дерево. Да, фильтр. Да, оно все
откладывает в вычисления. А в конце, когда ты уже попросишь, ну все, я числа хочу, дай мне матрицу,
оно возьмет и запустит некоторую такую хитрую машинку, которая будет по этому дереву ходить и
пытаться оптимально вычислить по скорости и там, наверное, по памяти, по потере точности, например.
То есть вот такие хитрые фокусы, так как у них дерево, они могут делать. Теоретически в ренджах
возможно то же самое, практически нет. Ну вот, кажется, это последний кейс. Теоретически у тебя в
ренджах есть целое вот это вот дерево из типов, и ты можешь написать какой-то хитроумный код,
который знает все про все вьюхи и может их как-то схлопнуть, приордерить и как-то заптимайзить.
Оно локально происходит, а речь не об этом, речь о глобальном каком-то. Вот в Эйгене,
насколько я знаю, некоторые глобально есть взгляды, они прям вот глобально оптимизят.
У этого, конечно, у всего есть некоторая проблема, что когда вы пишете вот такой смешной код,
как я, автор равно m2 на v3, немножко не ожидайте увидеть там какой-то дурацкий Эйген-продукт от
и так далее и так далее. Но кажется, что матрицу множили, должны матрицу получить. Вот если хотите
матрицу получить, вы вместо авто обязаны теперь матрицу писать прямо. Вот это может быть неудобно.
Вот этот продукт автоматически кастится к матрице. Ну то есть можно написать вот здесь вместо авто
matrix3f и там есть implicitCast, который форсирует все вычисления. Ну, кстати, да. В NumPy все привыкли,
Python можно творить что угодно, но то, что в плюсах то же самое творят, это для меня было немножко
сюрпризом, когда я узнал. Вот, ну это все кейсы, которые у меня есть на сегодня, давайте общую
идею обсудим. У них есть некоторая волшебная коробка, которая умеет более оптимально сложные
матрешки вычислять. Вот она прям смотрит, видит полную матрешку и понимает, что тут
можно переставить местами, вычислить в другом порядке и будет быстрее, лучше, круче.
Может быть. Тут такая же идея примерно. И в ренджах-то примерно та же идея,
что будет быстрее, если вот эти вот ленивые вычисления сделать, будет быстрее. В Эдине,
кажется, даже умнее, чем просто ленивые вычисления, но не факт. Вот я не влезал,
честно говоря, в коробку, эту черную. По-моему, там очень умно сделано все, писали очень умные люди.
Да, это просто есть айген. Прикол в том, что линал реализуется одним способом в одном месте,
через бласс. Тут есть сайтик, вы можете подробно почитать. Если вам когда-то в жизни понадобится
какой-то линал считать быстро и круто, я вам крайне рекомендую айген. С ним работать прикольно,
и он все многомерные кейсы покрывает вообще. Матрикс 3F, вы видели, что это на самом деле никакой
не Матрикс 3F, а Матрикс Flow 3.3. Здесь любые числа могут быть, а еще есть Спарс-матрица и прочее.
В общем, я уже забыл, в чем вопрос был. Наверное, надо тогда дальше идти. У нас остается 25 минут,
давайте поговорим про общий вид паттерна. По всем этим кейсам они более-менее на две категории
развалились. Какие? Нет, это общая идея всего. Ну, фактически, да. Я бы сказал даже,
просто по признаку того, что мы храним в аргументах шаблонных, параметрах шаблонных типа. Либо мы храним
всю предыдущую историю, либо мы храним какое-то короткое представление, что сейчас происходит.
Вот в примере моем, там вот одного янама с флажками хватает. Можно было вместо этого тоже всю историю
хранить как там в айгене, но это было не нужно. Это слишком сложно, тут обошлись меньше крови. Во
фьючах фейсбука то же самое. Вот они могли бы начать городить как в стд экзекьюшн, но им это все
не нужно, потому что у них там фьючер все на куче хранит и вот это вот статическое, но слишком
сложно. Они обошлись по сути одним битом информации. Либо у вас сэмифьючер, либо фьючер. Это тоже,
как бы состояние. Сэмифьючер и фьючер в общем-то для пользователей примерно одно и то же, но одно из
них как бы полноценное, другое нет. У одного есть колбэки, у другого нет методов для колбэков.
Вот, ну и кейс, когда мы целое дерево того, что раньше происходило строем, он в общем случае
expression templates называется. Что смешного? Тут все серьезно. Нет, енто не монады.
Вот набежали блин со своими монадами. Сидели никому не мешали. В этом шутка, Андрей. Нет,
ну монады тут где-то близко топчутся, потому что и RNG это монады, и матрицы с какой-то точки зрения
это монады, и фьючи это монады, и вот эти вот из execution хитрые там сендеры какие-то это монады.
Вот только то, что у меня там написано, это не монада. Это вот простой рабочий крестьянский
прикладной код, когда надо сбилдить кучу информации, некоторые комбинации некорректные,
некоторые там еще что-то, и мы тупо вот защищаем от дурака. Ну кстати, слово дурак оно обидное,
а защита от дурака оно вот ни разу не должно быть обидным, потому что дурак это вы сам всегда,
да? В три ночи усталый, глаза уже слепятся, написал не то. Вот если вы себя защитили от этого,
то вы молодцы. Ну вот если у вас на уровне системы типов реджектятся тупые ошибки,
то вы защищаетесь не от какого-то абстрактного Ваньки дурака, который и дурак, а вы-то умный,
нет, вы защищаете себя от самого себя. Да? Дурак это вы в три ночи, не выспавшийся,
голодный, усталый, злой, вот в этот момент вы совершаете эти тупые ошибки. Можно ли
вас дураком назвать? Наверное нет. Ну надо себя как-то любить все-таки, да? То есть мы как бы с
абстрактной точки зрения дураки, с прикладной нет. Но да, это отступление. Давайте рецепту все-таки
прочитаем, от Монада отойдем. У нас вот это вот expression templates это чисто плюсовый трюк про то,
что ну как работают шаблоны в плюсах. Я не уверен можно ли такой трюк сделать с другими
системами дженериков и про в какой-то степени pattern composite, наверное. Но давайте читать,
что вот у нас есть набор операций. Наверное встать мне надо, я привык прыгать. Да, надо встать,
чтобы привлекать внимание, чтобы вы не заснули. Что общий рецепт такой, что есть набор операций и
какие-то данные, над которыми мы работаем. Вот были матрицы, были ранжи, были сэндеры
асинхронные, непонятные, неважно даже. Мне кажется еще можно всякого придумать, если постараться.
Это все в одно. Но это не совсем функциональный дизайн. Возможно. Просто дизайн как слово,
оно там покрывает столько всего и там столько всяких разных вещей. Вот слово
функциональный дизайн, я если честно не видел, чтобы оно как-то формализованно вводилось тоже.
И какого-то представления, что люди говорят, когда имеют в виду функциональный дизайн,
у меня пока нет. Ну, монады, наверное, функторы, вот это все, оно здесь не очень близко по моим
ощущениям. Ладно, все, хватит меня отвлекать. Давайте пройдемся по пунктикам, что мы зачем
занимаемся всем этим, что вот есть эти вычисления над данными и мы хотим одно из трех вещей делать.
Либо защищать себя от тупых ошибок, вот инварианты какие-то, enforce it. Либо хотим
откладывать вычисления, либо хотим, ну как-то ленивые, но это одно и то же. Вот ленивые отложенные
в этом контексте неважно. В случае с ренджами вы откладываете вычисления до момента, когда их
вот прям необходимо, когда Bigin позвали. В случае с фьючами, ну вы откладываете вычисления до момента,
когда там что-то произойдет в будущем и с точки зрения вот этого вот паттерна, это все одно и то же
или там функционального программирования. Итак, берем, что мы делаем? Берем наваливаем историю
всего происходившего внутри типа, возможно не всего. Некоторые ветки, возможно, стоит выкидывать,
да, видели там cross-product в вегане, он выкинулся. Ну, видимо, потому что с ним никаких оптимизаций
не придумаешь и как бы это ну вот так. Возможно, там есть какой-то не... возможно есть другой метод,
который ленивый и который нормально делает. Возможно, я просто не тот метод вызвал.
Стандартный это тип внутри типа, внутри типа и так далее. И каждая вот эта вот функция или операция,
которая обрабатывает, она возвращает новый тип, новую обертку над тем, что было. Ну, конечно,
это такой общий рецепт. На практике мы можем и сворачивать в какой-то другой тип матрешку
по ходу дела. Иногда это бывает полезно и нужно. Вот если... хотя, да, вы уже большие, в ваш год Рома
еще этого не придумал и не рассказал. Вот Аркадий, разве что, с Андреем могут знать. До бесконечности
растягивать вот эти вот ленивые вычисления бывает плохо. Бывает, что это не оптимально по памяти,
по другим параметрам. Иногда хочется взять и прямо запустить эти вычисления прямо сейчас. То есть
иногда имеет смысл пользователю прямо выдать руками инструмент, который матрешку сворачивает,
несмотря на то, что технически нужды нету сворачивать эту матрешку. Просто может быть объект уже очень
большой. Если у вас какая-нибудь асинхронная операция, которая уже килобайт занимает из своих
под кусочков, возможно стоит как бы оборвать и дальше где-то в другом месте пойти. Вот и
некоторым функциям можно забанить, принимать некоторые типы, то есть инварианты тоже в таких
схемах с ранжами, они работают. Какие, кстати, мы видели на прошлой лекции инварианты, которые с
помощью типа фэнфорсятся в ранжах? Ну вот что-то такое-то. Да, с помощью типа ранжа из-за
счет того, что у нас не какой-то там опэшный интерфейс iView или iRange, мы можем прямо в тип вшить
какую-то информацию о том, что с ним можно делать. Например, является ли он бормранжом? Это тоже как
бы type-state в каком-то смысле, состояние внутри типа. Ну и все, сворачиваем бутерброд. Да, такое делают,
всякое делают. Sentinel-4 в смысле... Ну конкретизируй, в любом ранже можно сравнивать Sentinel с
итератором. Ну типа, является ли Sentinel итератором, вот это как раз type-state, мне кажется. Потому что в
зависимости от этого ты можешь там по-разному запрещать сюда передавать, запрещать туда передавать. То есть
как бы type-state он не всегда может быть совсем явным, он может быть таким запрятанным за другими
какими-то свойствами типов и оберток. И type-state, но это немножко из другой идеи пришло. Да, type-state это
скорее вот то, что мое детище я показывал. И что еще? И future. Ну там через точку как билдер мы
настраиваем какой-то объект. То есть имеется вариация паттерна билдера и мы хотим ловить какие-то
ошибки, enforce it in варианты опять же. Но мы какой-то state сохраним прямо внутри аргументов шаблона типа,
не типовые шаблоны аргументы или ну просто разные типы можно завести, когда это удобней.
Нет, потому что ты CPO начинаешь придумывать, когда через палку пишешь или через свободную
функцию. А через точку ничего придумать не надо. Ну сделай, сделай твоя сущность подчеркивания
интерфейс, который с RTP, который закидывает все, что нужно с дефолтами. Ну да. Ну view interface
помните? Показывал. Вот аналог этого делаем и все, проблема решена. Ну то есть. Зови тот кейс,
конечно. Если у тебя супер много операций и на каждом объекте нужно уметь как бы теоретически
делать каждую, кроме каких-то маленьких запретов, вот очень маленькое количество запретов,
то тебе, конечно, через методы будет тяжеловато. Очень много методов, будет очень много кода,
не знаю. Кажется, что это не самая хорошая идея. В таком случае, наверное, свободные функции лучше.
Там еще есть, наверное, более тонкая разница, что если мы работаем с методами через точку,
то мы можем из доступных перегрузок только в базе скаститься, если мы пишем типа A точку метод,
а если мы пишем через свободную, то мы можем намного больше войти. Я не очень понял о чем-то. Ну
вот, например, у меня есть какой-то тип, да, там не знаю, тип foo, да, есть тип bar, у которого есть,
к сожалению, implicit constructor от foo. Вот. И тогда, если мы работаем с методами класса, то тогда у нас
не будет, кажется, доступным иметь у bar метод какой-нибудь баз и написать у объекта типа foo точка
баз. Ну, я все равно не воспринял на слух пример, но, кажется, ты хочешь сказать, что система с
свободными функциями, цепочками и прочим, она более расширяемая и больше кейсов покрывает странно.
А, ну, окей, да, ну. Надо на самом деле, на самом деле и то и другое, пока что в зарождении таком находится,
да, вот там ранжи совсем недавно выкатили, execution тоже пока пекут, и мы, как человечество,
пока не особо понимаем, каким последствием это все приведет через 10 лет. Да, все нормально будет,
придумают как это решить, это техническая штука, но вот какие-то дизайнерские последствия этих
решений, они пока очень неочевидны, и там, ну, через пять лет, наверное, будет уже понятно в
ретроспективе, что мы все сделали неправильно, опять все ошиблись, давайте заново все переделывать.
Да, до нотации монады, то, о чем я мечтаю. Ну, короче, тут примерно то же самое написано,
вот просто вы могли в каких-нибудь презентажках, с каких-нибудь конференций наткнуться, что есть вот
такая штука, наткнуться, что есть вот такая штука. Я утверждаю, что это одно и то же, то есть expression
это частный случай type state, просто в качестве вот этого состояния вы храните предыдущую историю,
ну, вполне себе состояние. Ну, в моих глазах отличий между этими вещами нету и, ну да,
втащим-то у меня на этом все. Нас десять минут до конца, мы можем поговорить про жизнь,
про барокко, про задачи, про какие-то вопросы по этому материалу, но мне кажется, я и так уже
каждую мысль по два раза повторил и надо будет ужимать в следующем году. Ну что, ни у кого никаких
вопросов, проблем, чего-то волнующего. Я говорю, что это частный случай, это я сам вчера ночью
придумал, но мне кажется, это очевидно. Согласны ли со мной вы? Ну, то есть вот если говорить,
что type state это такая общая штука, что храним состояние внутри типа и в зависимости от этого
ограничиваем кого кто может вызывать, тем самым варианты in force, то это ничем не отличается от
вот этого примерно, что там. Ну, окей, в expression template их еще отложенные учисления можно сделать.
Ну, здесь тоже в принципе можно, если честно, в type state, да, как бы, ну. У меня вопрос, если мы
начинаем умножать, ну, вот у нас была библиотека Eigen, в общем, там мы исключительно со тиралами
работали, если мы начинаем резко вводить числа из консоли, то у нас это все перестает работать.
Если ты вводишь, в смысле, нет, значение вот эти вот, нет, все работает. У тебя в тип зашито
только размеры матриц. Ну, если так фундаментально посмотреть, то у тебя зашито сюда там ранги и
размерности тензоров. По-моему, тензоры тоже в Eigen есть в каком-то виде в расширении, но только
фигойнки, по-моему. Я пытался с ними работать, ничего не вышло. Ну, окей, давай вот эту информацию
выкинем из типа. Если вот нам нужно в нашем кейсе, то выкинем. Как? Ну, в спане мы справились с этим.
Динамик Extend пишем по какой-то оси или по еще чему-то. Вот если ранг тензора должен быть динамический,
то это вообще, пиши пропало, тут ноль информации будет, и валидировать статически, что размерности
при умножении матриц совпадают, а Eigen это делает, да? К вопросу инвариантов, вот я тут этого не
подчеркнул, но тут они есть. Когда вы делаете продукт, Eigen проверяет, что у вас размерности
совпадают. Ну, вот если они динамическими станут, то эти проверки отправятся в ранг тайм.
И, ну... А, тут еще, как бы, в карте истории можно добавить, что у нас есть все еще интерфейсы,
и у нас эти объекты, которые там стоят и наставляют, они, как правило, что-то полезное делают,
ну нет, не обязательно. Они могут не просто копить стейп. Ну да, могут. Ну вот да, на самом деле,
этот паттерн еще с TypeRaiser дружит, потому что, если вы хотите, вы можете обернуть вот эту всю шнягу
в TypeRaisedMatrix. Ну, Matrix, TypeRaisedMatrix размера 1, что-нибудь такое. Ну, вот это все вместе,
по-моему, это будет то же самое, что и Matrix 1 на 1, да? И можно взять и... А, нет, стоп, это вектор,
это вектор. Можно вот эту информацию, как бы, прокинуть через ранг тайм, и... Ну, это такое
уже усложнение, которое, мне кажется, на детали не влияет, и... Как, ну, идешь рекурсивно и
разворачиваешь. Ну, switch по типам — это когда ты метод вызываешь, и он в разном классе, по-разному
реализован. Ну, вот так, например. Ну, или... Ну, то есть, тут вариантов много, я верю, вы придумаете.
Просто мой вопрос был по тому, что кажется, что у нас спан был, и вот, по поводу слайса,
там не очень сильно менялся функционал, если нам известно или неизвестно. А тут? Сильно, да.
Много копипасты, много болей, много страданий. Ну, вот, теоретически, тут все параметры можно
взять и отправить в ранг тайм. Можно даже тип значений, которые мы храним, отправить в ранг тайм и
сказать, что это там big integer, там какого-то или еще что-нибудь. Ну, в общем, все можно отправлять в
ранг тайм. Вопрос, на что вы готовы, как автор библиотеки, пойти? Ну, авторы библиотеки Айген,
по-моему, только вот размеры. То есть, ранг нельзя, только размеры матриц менять можно в ранг тайм
и через динамик экстенд. Ну и, собственно, в задачах спан и слайс вы должны были научиться,
как там минимизировать копипасту до какой-то степени. Ну да, то есть, вполне себе неплохое
упражнение, если кому-то из вас совсем нечем заняться накануне за четные недели, это написать
вот свой аналог Айгена с вот этими вот матрицами, еще поддержкой ранг тайма. Ну, наверное, хорошая
идея, наверное. Ну, она нудная просто будет. Да, то есть, ну, не знаю. Я бы сказал, я бы сказал,
что самый классный пример здесь вот тот, что мой, не потому что он мой, не поэтому, потому что это
просто обычный билдер, вот этот классический паттерн-билдер, где мы просто постепенно накладываем
какую-то информацию, вместо метода build здесь вот этот handle. Ну, как бы, я это не проговорил явно,
но вот этот handle он как бы сворачивает, в каком-то смысле, бутерброд и билдит итоговый объект. Нам
понадобились варианты enforce. Какой у вас пример билдера был на технологиях программирования?
Бургер. Сет котлета, сет это, сет то. Ну, давайте enforce, что там нельзя больше, чем две котлеты
класть. Как это сделать? Вот у вас есть метод от котлета. Как? Да, просто в счетчике классно,
сохраним количество котлет, от котлета возвращает билдер нового типа, новую специализацию, где счетчик
конкрименчен. Как только он два, у вас метод от котлета пропадает. Ну, то есть вот это, мне кажется,
самое такое прикладное. Что? Да, requires, через requires метод пропадает. Если у вас нет requires,
вы пишите SFINAE сами. Ну, лучше... Ну, можно подумать насчет моделирования процесса поедания
бургеров как monad, но в свободное время, а лучше, закрывшись дома в ванной. На этом предлагаю
закончить. Теперь время совсем вышло. Всем спасибо, что пришли. Все свободны.
