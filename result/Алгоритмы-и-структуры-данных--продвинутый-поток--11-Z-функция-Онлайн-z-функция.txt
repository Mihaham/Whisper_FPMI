Итак, в прошлый раз мы обсуждали префикс функции, сегодня мы попробуем обсудить еще одну маленькую функцию.
Еще один способ, как найти подстроку в строке за линейное время, напомню, что мы ищем.
Собственно, шаблон P pattern в тексте T.
Ну, еще один красивый способ как это можно сделать, это Z функция.
Ну, определение здесь такое.
На этот раз давайте скажем, что S у нас в ноль индексации.
И введем такое понятие, как Z.
Ну, вот тут очень интересно, то есть, формально говоря, оно водится и от нуля тоже часто.
И, ну вот, то есть оно, соответственно, да, это тоже целое неприцательное число.
То есть, точнее массив целых неотрицательных чисел, где Z и T равно максимальное такое L,
что, значит, префикс длины L равен подстроке длины L, заканчивающейся, начинающейся, это важно.
Да, вот чем хорошо писать на полу интервалов, это сразу хорошо.
Ну, да, здесь пока, в общем-то, определение простое.
Ну вот, возникает естественный такой вопрос.
Действительно, как же ее найти?
Ну, а главное зачем?
Ну, в отличие от префикс функции, это действительно сложно.
Можем быть, действительно, что-то придумать.
Ну, хотя самое простое, если мы эту Z-функцию откуда-то с небес по факцию достаем,
то тут применяется такой классический такой метод поиска подстроке в строке
насчитать Z-функцию для строки P$T.
Ну, или в других переводах P$T.
Что такое диезик или доллар?
Это какой-нибудь символ, которого нет ни в строке P, ни в строке T.
Очевидно, что если посчитать такую Z-функцию, стреляя подобного рода строки,
то легко заметить, что в какой-нибудь позиции,
то есть, допустим, если вот это нарисовать вот таким вот образом,
то в какой-нибудь, в этом символе строки T начинается вхождение строки P,
тогда и только тогда, когда ZPT равно mod P.
Причем диезик обеспечивает, что будет именно равно, а не больше либо равно,
если у вас тут диезика нет.
Ну, думаю, тут нот. Думается, тут идея достаточно простая.
Вот. Ну, а что же нас теперь интересует?
Что же нас теперь интересует? Как же эту Z-функцию найти?
Ну, в общем-то, метод здесь достаточно простой.
Значит, как же его здесь искать?
Ну, во-первых, конечно, да, самое тупое, что можно найти, это, конечно, что Z от нуля равно чему?
Ну, обычно длина строки.
Ну, по такому определению, это просто действительно длина строки, и, в общем-то, это очевидно.
Но настолько же очевидно, настолько и тривиально, и, в общем-то, не интересует.
Потому что в некоторых версиях, собственно, Z от нуля не определяют вообще, ну, просто в силу неинформативности.
Значит, это лишь штука.
А вот все остальные Z от одного Dn-1, они ищутся, ну, вот, оказывается, весьма, ну, то есть весьма таким простым образом.
Значит, каким же образом они ищутся.
Вот. Они, в общем-то, ищутся очень просто.
Значит, поехали. Ну, вот, каким образом.
Значит, ну, идея такая.
То есть мы будем идти по строке.
Вот идти по этой строке S.
Честно идти, идти, идти.
И, честно, ну, там, после нулевого элемента, честно Z насчитывать, насчитывать, насчитывать.
И вот, допустим, мы добрались до этого символа, хотим посчитать цветы, которые все предыдущие насчитали.
И тогда идея такая.
Вот у нас же были вот эти Z, которые находили какие-то подстроки, которые равны префиксу.
Так вот, давайте найдем такую из этих подстрок, которая, внимание, заканчивается позже всех.
Заканчивается позже всех.
Ну, в общем-то, если вы там затытое поддерживаете, то, в общем-то, поддерживать эту штуку тоже не сложно.
Понятно, то есть L будет равно argmax.
Соответственно, там J плюс Z житого.
Ну, вот, соответственно, J плюс Z житого, значит, один меньше ребрем.
J меньше.
Вот, легко. Ну, если мы сейчас с помощью его ZI напишем, то, собственно, поддерживать и поддержать это L будет уже не сложно.
Ну, тем более, как мы это будем делать?
Ну, самый тупой способ говорить, но первый такой тупой случай говорит, что если совершенно случайно оказалось, что эти L и L плюс ZI вот тут,
они заканчиваются, то есть L плюс ZI вот тут не проявляет этого символа, его не покрывая, то здесь мы тогда насчитываем Z от I в тупую.
Вот такая вот приятная вещь.
Вот давайте, прям совсем с тупой.
Но может так случиться, что действительно, скорее всего, пока не психологически так кажется, так случится, что L и L плюс ZI на самом деле L плюс ZI будет чисто больше, чем I.
Но что это означает?
На самом деле это означает, что эта строка является префиксом, и это означает, что, в принципе, мы с точки зрения Z кое-что про нее уже знаем.
Ведь действительно, давайте заметим.
Давайте вот возьмем и заметим.
То есть раз вот эта строка равна префиксу, то в принципе вот эта подстрока, начиная с этого символа вот по этому, она равна вот какой-то вот этой подстроке.
Вот, кстати, как вы думаете, где начинается эта подстрока?
I минус L.
Да, совершенно верно. Она начинается в позиции I минус L.
Вот, мы заметим, так как вот, то есть про эту подстроку мы что-то знаем, но тогда получается, ну, интересный факт, что если мы хотим понять, что вот начинается этого символа, сколько символов будут совпадать с префиксом, то, в общем-то, первые несколько мы можем уже сказать, то есть говорить то же самое, что и про I минус L.
Но Z от I минус L мы уже знаем.
И тогда, получается, по Z минус L мы без труда можем понять, дойдем ли мы хотя бы вот до этой границы или нет. То есть более точно оказалось, то есть в случае 2a, например, говорит, что если оказалось, что Z минус L оказался строго меньше, чем сколько?
R минус, получается.
Ну да, мы R не вводили.
Да, в классических интерпретациях R, но вот как мы обошли.
Да, вот длина этой строки действительно равна L плюс Z от L минус I.
Вот. То есть если оказалось, что Z от этой штуки не доходит до этой границы, то есть тогда мы можем гарантировать следующее.
Вот здесь есть совпадение.
А следующий символ не совпадает.
Но при этом заметим, что здесь эта строка тоже, получается, совпадает, а здесь тот же самый.
С этим совпадает, следовательно, с этим не совпадает.
Следовательно, из этого мы выводим, что Z от T тупо равно Z от I минус I.
Ну и второй случай.
Оказалось, что Z от I минус L больше либо равен, чем L плюс Z от L минус I.
И вот здесь, конечно, очень легко сделать одну маленькую багу.
Очень хочется соблазнительно сказать, что давайте скажем, что Z от T тоже все равно равно Z от I минус L, уж как минимум точно.
Вот. Потому что, ну, как бы, ну, что ж их от I?
Тут обычно алгоритм говорит следующее.
То есть вот правильно написать его так.
Действительно, что Z от T равно, теперь пишем, L плюс Z от L минус I далее в тупую.
Что мы подразумеваем под словосочетанием «далее в тупую».
То есть мы говорим, что мы точно знаем, что Z от I теперь не меньше, чем столько.
Ну ведь, действительно, раз Z функция здесь, раз тут совпало с префиксом такое количество элементов,
то, конечно, мы понимаем, что раз вот эта строчка равна вот этой, то получается она тоже совпадает с префиксом.
Вот. Поэтому мы точно знаем, что Z от I это как минимум длина этой строчки, но может быть больше.
И это мы уже узнаем в тупую.
Ну здесь, конечно, да, очень иногда хочется, особенно в каком-то олимпиадном замоте, действительно, скопировать,
прямо написать Z от I равно Z от I минус I далее в тупую, или что-то еще в этом роде.
Но, боже вас упаси, так делают.
То есть как минимум с точки зрения доказательства это неправда, потому что мы только вот про эти части,
про эти вот строки знаем, что они равны, а вот хотя бы равен вот этот символ и вот этот.
Что мы не знаем, то и не знаем.
Вот. Поэтому, действительно, не получится.
Действительно, у нас так делать.
Так что, ну вот. Ну вот. Ну отсюда, в общем-то, и получается. Действительно такая.
Вот.
Так. Ну что? Ну вот.
Ну таким образом получается, что вот Z-функцию вот таким вот образом нашли.
Ну и здесь мы доказали, что эта Z-функция работает.
Логично, да? Видно, да?
Вот. Остается только мелкий простой вопрос.
А почему она за лигию работает?
Каждый шаг насчет тупую увеличивает правую границу максимально.
Да, совершенно верно. Здесь идея простая.
То есть заметим, что каждый шаг в тупую, потом в перспективе вот эта вот L плюс ZL,
эту правую границу нам увеличит. Действительно.
Ну и здесь, особенно это хорошо видно для нашего случая 2b,
когда мы говорим, что Z-функция дошла до границы, а дальше мы ее будем двигать прямо в тупую.
Каждый шаг на единичку.
Вот. Ну в случае 2a просто там граница не поменялась, все за вот единицы.
Ну а здесь, действительно, граница уже будет начинаться в I и идти правее-правее-правее.
Да. Здесь такой, может, одно из самых наглядных доказательств того, что это зайгнет.
То есть там вот префикс функции, это может быть там иногда неочевидно.
В общем, зависит от интерпретации.
Ну вот, здесь получается хорошо.
Да.
Действительно. Вот такая вот получается хорошая.
Да.
Но возникает, правда, действительно, да.
Действительно, итак.
Так что, таким образом, да, Z-функция действительно окажется действительно хорошей, красивой вещью.
Вот. Ну, в общем, вот.
Причем, на самом деле, как показывает практика, сама Z-функция может очень много чего уметь.
Собственно, и сама по себе.
Вот.
Вот.
Но давайте вот для начала.
Действительно, хочется, конечно, первое.
В префикс функции было такое преимущество вот по дополнительной памяти.
Понимаете, что префикс функции могла использовать дополнительную память не от P плюс T, а только от P.
Вот возникает тогда такой естественный вопрос.
А не божим ли бы обойтись дополнительной памятью от P при вычислении Z-функции, когда еще по строку строке.
Наверное, можно пытаться только хранить максимальную правую, ну, левую правую границу.
Вот.
Ну, то есть вот эти L и L плюс Z.
Ну, в общем-то.
И только их меняет.
Ну, да.
В общем-то, да.
Действительно.
Можно заметить, что, если мы будем считать тут Z-функцию, то диезер гарантирует нам, что если там больше тут ничего не произойдет.
Ну, то есть, конечно, тут Z будет ноль.
И более того, он гарантирует, что все там левые эти правые границы закончатся где-то на диезе.
Может быть, ну, там непосредственно перед диезе.
Вот.
Но, действительно.
Но тогда, когда мы будем насчитывать, скажем, эту функцию здесь, то заметим, что хранить каждое конкретное значение нам уже не нужно.
Потому что здесь Z будет не более чем P.
Получается, вот, когда в этом алгоритме отсылки будут только, вот, там могут быть отсылки только где-то вот к Z-м уже, соответственно, где-то уже в P.
Поэтому, на самом деле, то есть, опять же, как префикс функции, в общем-то.
То есть, делаем абсолютно то же самое, только конкретные Z-ки не храним.
Просто, если очередная Z-ка, ну, там.
То есть, храним, конечно, вот эти вот максимальные L, соответствующие L плюс Z, или это вы храним.
Ну, вот.
Ну, вот.
Ну, а дальше просто каждую Z-ку честно вычисляем и говорим, что если она оказалась в модуле P, значит, ура, вхождения нашли.
Нет?
Да.
Но, правда, действительно, у этого алгоритма, конечно, есть один еще маленький недостаток.
Какой маленький недостаток у него есть?
Что этот алгоритм, конечно, не совсем онлайн.
Что префикс функции был еще одно преимущество.
То есть, можно было, ну, то есть, он, в принципе, работает по принципу, а вот, что, как бы, вот, гастротина считали,
теперь добавили один символ, его и там, в идеале, там, амортизировано за O от единицы, действительно, что-то досчитая.
А если насчитать автомат префикс функции, то даже и в честных получалось.
Ну, правда, это, конечно, работает, только если у нас стал ставить констант.
Впрочем, чаще всего это так.
Вот.
Сперва, действительно, хочется даже прям чуть-чуть подумать на эту тему.
Действительно. А вот, действительно, можно ли было бы, действительно, насчитывать Z функцию в некотором плане онлайне?
Суждается, что можно.
Да. Прям, то, правда, не за O от единицы, да?
Ну, в смысле, как бы, понятно, что каждый символ может быть за O от единицы, но учетно O от единицы.
Ага. Учетно O от единицы, да.
В общем, там, на самом деле, просто алгоритм.
Вот.
Я не знаю, я мог бы попробовать раскрыть.
Не, погоди, погоди, сейчас.
Что-то?
В смысле, что, ну, как префикс функции, у нас же каждый символ может быть за сколько угодно, но если всю строку добавили, то суммарно O от единицы на символ.
Ну, понятно.
То то же самое.
Ну, я понял, я понял.
Сейчас.
Ну, да.
Нет, ну, давайте даже интрига.
А ну-ка, давай попробуй.
Даже интересно.
Так.
Так.
Ну, я на этом то, сколько угодно.
Да, конечно.
Да.
Вот.
В чем будет основная идея?
Вот, допустим, у нас есть...
Так.
Ну, давай сфагулируем тогда максимально четко.
А что мы сейчас...
Что мы хотим?
Что мы хотим?
Мы хотим уметь добавлять символ в конец строки.
Да.
Ну, pushback.
Да.
Вот, символ C.
И хотим узнать Z и T.
Ну, дается I, мы хотим узнать Z и T.
Что там?
Запросы, как раз, да.
Да.
Вот эти мы можем делать за от единицы строго, то есть, не удивительно.
That-functions?
Да.
Да, моя запунция говорит.
Вот эти от единицы в среднем, ну, то есть, учетно.
Вот эти от единицы в среднем, ну, то есть, учетно.
Так.
То есть, по сути, аналогично, как у нас коррекция функции, и так умеем делать.
Вот. Какая основная идея нашего алгоритма?
Значит, ну вот пусть у нас есть текущий предыдущий строки.
Вот. И вот мы к нему нападаемся 2700.
Значит, мы будем поддерживать минимальную такую позицию и, не нулевую причем,
что суббикс в начале ИС падает соответствующим предыдущим строкам.
Ну, то есть, что как бы И плюс затытое равно текущей длине строки.
Вот. Ну, как бы несложно понять, что когда мы будем делать новый символ, эта позиция будет только не убывать.
Вот.
Первый вопрос.
Первый вопрос. Ну, давайте дальше посмотрим так.
Вот у нас есть текущий СКС, есть вот этот символ И, да?
Заметим, что тогда Z функция для предыдущих символов уже почти однозначна и меняться не может,
потому что их как бы, ну как бы, постройка сначала дней до конца текущей строки уже не дойдет.
Вот. И говорим, что тогда мы для всех предыдущих Z уже начитали к этому моменту.
Вот. Как тогда посчитать, ну как всегда отвечать на второй запрос?
Ну, то есть, если нам дается позиция меньше, чем И, то просто отвечаем Z функцию в этой позиции.
А если хотя бы И, ну вот тут какая-нибудь позиция G.
Ну, в целом понятно, отвечаем, значит...
Ну, то есть, мы уже понимаем, что Z функция с началом G такая же, как G минусы,
ну с учетом того, что она там не больше, чем оставшийся субекс.
Да, но это может все еще быть больше, чем И.
Да. Ну, и то же самое не больше, чем G минус 2.
Если у нас G минусы все еще хотя бы И, то мы можем еще раз почистить их.
Ну, в общем, мы можем взять G по модуле И просто.
Сейчас, сейчас, сейчас. Покажи G минусы, я понял.
Ну, то есть, мы понимаем, что ZGT на самом деле это минимум из ZG минусы и...
Ой, так уже минусы, я не знаю.
...G минусы и модуля С минус G, да, без минусы единицы, да.
Ну, вот. Ну, а это можно логично расписать как минимум из ZG минус 2И,
ну и там чего-то большего, что уже можно не учитывать.
То есть, аналогично получаем, что это минимум из ZG по модуле И и S минус G.
Таким образом, мы научились заутентицем восстанавливать любое имя Z функции, если потребуется.
Как добавить теперь символ C в конец?
Ну, очень просто.
Вот у нас есть текущая наша позиция и добавляем C.
Смотрим, правда ли, что если мы добавим C, то и все еще остается...
Ну, у нее Z функция все еще максимально возможна.
То есть, правда ли, что там вот этот символ C совпадает с символом, ну, типа на I или V?
Если совпадают, то мы просто дописываем C в конец, оставляем и на месте, и все отлично.
Иначе мы говорим, что, ну, теперь значение Z функции V точно такое, вот S минус I, модула S минус I,
а из двигаем на единицу.
Вот, и теперь проверяем для нее то же самое.
Ну, то есть, как это, как бы, чуть более аккуратно?
Ну, вот, значит...
Давайте так скажем.
А что, ну, посмотри, самый тупой алгоритм, который тут предлагается, давайте просто идти.
Ну, в смысле, нет, это вроде, идейно, мне кажется, должно уже понятно быть.
Ну, нет, идея такая понятна, что мы Z функцию, мы можем просто идти теперь просто и слева,
и смотреть, у кого Z функция дальше дойдет до S, и делать тоже...
Да, мы можем теперь идти, вот, начиная с C вправо, и вот, ну, вот, допустим, мы сейчас на элементе тоже как раз G, да?
Мы знаем, что, как бы, текущая джит функция, мы можем через Z G минусы предрексировать, потому что она уже точно посчитана.
Ну, да.
Если она доходит до конца строки, то проверяйся, что Z G...
Ну, да, да, да, да, да.
Вот так просто.
Ага.
Так, классно.
Так, есть ли какие-то вопросы?
Да, вначале.
Есть ли какие-то вопросы?
Да.
Да, так.
Как говорится, там просто никто в прямом эфире не слушает.
Нет, послушаю.
Ну, понятно.
Так, ну, все-таки нет, реально, все понятно?
Или требуется что-то уточнить?
есть ли уже вольт?
наверное не сомневаюсь, что это надо аккуратно написать
потому что, например
нам нужно понять, чем приносить и в начале
то есть, что лучше всего приносить не 0 и 1
и понятно, чтобы аккуратно не обрабатывать
по случаю первых символов в строку
ну там, то есть
у меня есть даже какое-то подобие кода
не, ну понятно
ну можно, не, ну не вот это
когда один символ, как бы более-менее все понятно
ну да, когда второй, нормально
вот, да, спасибо, огромное
ну пожалуйста, так, ну да, это красиво
так, ну что
нет, так, господа, так это
тестим аудиторию, так
требуется ли это там повторить
или осветить какие-то моменты
давайте еще раз
так, сейчас проверим, собственно, насколько это
понял я
сейчас я попробую это все
да, с третьей написать заново
ну вдруг меня, я не знаю
да, так, смотрите
итак
так
я в группу скину код
этой функции
хорошо, итак, поехали
итак, значит, что мы еще раз хотим
значит, мы хотим насчитывать
эту функцию в некотором смысле
в онлайне, что это означает
это означает, что у нас есть
строка S
в ноль аддексации, естественно
и мы выполняем к этой строке
два типа запроса
первый тип запроса
приписать
в строке S новый символ
C какой-то, но новый не в смысле
что его там, такого символа больше нет
просто вот, вот, глянить строк на один
вот, и
второе, что-то второе нужно сделать
что нужно сделать
это, конечно же
то есть, действительно
найти z от i
для
некоторого
значит
i, который лежит
на полной интервале
глядя
значит, мы ставим на то
мы ставим на то, что
ну, как и в префикс функции
мы ставим, то есть, заметим, что
как и в префикс функции мы ставим на то, что
zi-то мы будем определять
даже честно
вот
и от единицы учет
вот
кое-что мы будем делать
в общем-то, можно заметить, что для префикс функции
у нас происходило то же самое, правда
ну, потому что префикс функции честно насчитывалась
ну, слава богу, она
каждая префикс функция зависит только от того, что
с левой и никак не зависит от того, что с правой
ну, как вы помните, когда мы приписываем
новый символ c, то мы там скакали
что-то там по i, p от i, p от p
помните, да, поэтому получались
на самом деле, получались ровно такие же асимтуицы
но в z от i
в z от i, на самом деле
действительно
оказывается, тоже можно
так делать, но чуть-чуть-чуть более
хитрый очень сильно
а именно
значит, что мы будем делать
мы будем пытаться
значит, вариант будет следующий
в каждый момент времени
мы будем пытаться
хранить
давайте еще какую-нибудь маркеру возьмем для этого
значит, полк разума
давайте побольше нарисую
значит, для текущей строки s
мы будем
хранить некое
мистическое
я очень хочу
достать именно красной марки
я не знаю
почему
я не знаю
почему-то у нас позавчера
фибоначевый кучевый текал красный указатель
и вот так удобно было
называть, как и называть красный указатель
так вот
мы хотим находить
значит, вот такое вот число
ну будем его называть
допустим
поз
давайте поз
поз
это будет такое
минимальное
допустим l больше нуля
такое, что
l плюс z от l
равно модуль s
вот
первая позиция
на которой
z функция
честно доходит
до конца
вот
ну и соответственно
видимо оговоримся, что или конечно же
модуль s, если такого нет
уговоримся
может так случится
легко пристепелек
и будем
хранить такой инвариант
значит, инвариант будет говорить
что
называется
Ну вот, z от нуля до поз включительно, нот насчитана и сохранена в явном виде.
Ну, представьте, для поз значение не финальное.
Ну ладно, хорошо.
Для поз не включится.
Ладно, хорошо. Сохранено в явном виде.
Давайте вот так попробуем.
Ну действительно, почему мы именно вот до поз не включить?
Потому что заметим, что если у всех этих товарищей действительно z какие-то поменьше, они до конца не доходят, вот так, вот так, что-нибудь еще,
то тогда заметим, что эти z-ки уже финальные и не поменяются уже никогда, потому что сравнения облубаются раньше, чем заканчивается даже уже строка.
Поэтому эти z-ки можно сравнить.
Вот.
Вот, ну теперь вытекает мистическая нота.
Значит, как же нам теперь искать?
Значит, как искать zi?
Значит, когда мы ищем теперь zi, получается следующее.
Значит, ну вот.
То есть действительно, как теперь насчитать zi?
Насчитать его очень просто.
Значит, ну во-первых, если оказалось, что i меньше, даже меньше либо равно, чем поз, допустим, да,
то тогда просто к этому массиву отсылаемся.
Ну, видимо, меньше, что не важно.
Вот.
Ну, можно написать меньше, хорошо.
Ну, можно написать меньше, можно...
Ну, ладно, давайте отдельно этот случай поразбираем, кстати, потому что он на самом деле определенно интересный, можете им идти отдельно.
Вот.
Ну, если, давайте скажем, значит, i равно поз, то ответ, ну, понятно какой.
Модули с минус поз.
Этому уже точно знаем.
Если же i больше поз, то мистическое утверждение.
Значит, z от i минус поз.
Скорее всего, z от i равно минимум.
Ну, да, да, да, да, да.
Сейчас формируем правильно.
Сейчас формируем правильно.
Тогда оказывается, что z и t равно z от i...
Значит, да, вру.
Значит, очень аккуратно, да.
Минимум из, значит, z...
От i минус поз.
Да, i минус поз и...
Модуля с минусом.
Ну, да, модуля с минусом.
Вот так оказывается.
А, ну, правильнее, конечно, еще...
Раз уж поз у нас красный указатель,
так давайте его красным описать.
Ну, вот, начиним вот, собственно, ключевое утверждение.
Почему это так?
Почему же это так?
Причина, в общем-то, очень проста.
Действительно.
То есть здесь рассуждение прям практически то же самое.
Вот, допустим, у нас есть вот этот вот мистический поз.
И мы пытаемся насчитать...
Ну, допустим, вот i находится где-нибудь вот здесь.
Я тут подальше где-нибудь рисую.
Ну и что теперь можно заметить?
Можно заметить, что раз вот эта вот строка теперь...
Она совпадает с вот этой строкой,
которая начинается...
Какой позиции?
Минус поз.
Ну, начинается она ровно в позиции, раз вот тут поз и,
поз соответственно в позиции и минус поз.
Вот.
И в результате рассуждения абсолютно аналогичная, собственно,
в этом пункте, который у нас тут был.
То есть, если оказалось, что z и минус поз оказалось меньше,
чем вот эта вот длина этой строки,
то есть вот как-то вот до сюда z-ка доходит, допустим, да,
то, соответственно, тут потом тут x, тут y, тут x, то тут тоже y.
И оказывается, что z функцию тут можно прям скриппать.
Ну, а если z-ка оказалось больше, значит, вот эта вот строчка
совпадает, соответственно, с вот этой строчкой.
И тогда можно действительно писать,
что это минимум из вот этой z-ки и ноты, и вот этой штуки.
Вот такое простое доказательство.
Да, вот это понятно?
Совсем.
Так.
Где?
Что?
А почему у нас может быть x- и?
Потому что может так случиться,
что реальная z-ка вот в этом месте окажется сильно больше.
А, все понятно.
Это второй случай.
Пусть оно окажется вот так.
Тогда мы знаем, что здесь тогда действительно
налицо вот такое совпадение, но только до сюда.
Дальше просто символов нет.
Поэтому пишем минимум.
Вот.
Ну, на самом деле, нот, ну, здесь получается следствие,
которое надо, правда, очень-очень...
Ну, правда, да, следствие здесь очень простое.
То есть, на самом деле, следствие, что, опять же, если,
ну вот, то есть z-i-t равно, на самом деле,
минимуму из z от i процент пост
и модуль s минус i.
Самое главное, что это верно для всех i.
Ну, да.
Ну, для всех i...
Ну, на самом деле, да.
Ну, если мы еще...
Да, если мы возьмем i меньше постов, то это х х тоже верно.
Ну, то есть, надо, правда, сказать, что z нулевой это там
либо модуляция, либо бесконечность, чтобы это...
Сейчас, хотя нет, хотя нет, хотя тебе нет.
Не совсем так.
А хотя...
А, нет, ну, это правда, да, потому что...
Нет, ну, да, да, да.
Это как бы всегда верно, потому что z-i-t
по-любому не превосходит вот этой штуке.
Да, если и меньше, чем пост.
Ну, ладно, самое смешное, да, самый интересный случай.
А что делать, если и делится на пост?
Ну, ничего страшного, на самом деле.
Если и делится на пост, то как бы это...
Нет, на самом деле, давайте этот случай
и когда и делится на пост, рассмотрим по трубке.
Это на самом деле очень интересный,
очень такой интересный случай,
который нам периодически может пригождаться.
Потому что дело вот в чем.
Ну, вот, то есть, действительно,
что означает, на самом деле...
Что означает, что у нас, оказывается,
вот эта строка равна вот этой.
Вообще говоря, это означает маленький приятный факт.
Это означает, что наша строка постпериодична.
Ну, потому что это означает, что для любого
достаточно адекватного g,
s от g равно s от g плюс пост.
Вот.
Да, обратите внимание.
Конечно же, длина строки не обязана делиться на пост.
То есть, ну, там типичный пример, например,
какой-нибудь a, b, c, a, b, c, a, b, c, a, b.
Вот, допустим, здесь пост равен 3 Ом.
И, действительно, строка 3 периодична.
То есть, любые два символа на расстоянии 3 совпадают.
Ну, легко убедиться, что, что, действительно,
строка постпериодична, то есть, вот в этом смысле
этого определения, тогда и только тогда,
когда у него этот пост дотягивается до конца.
Вот.
Да, вот.
А, на самом деле, что касается самого поза,
как такой, на самом деле, минимальной такой величины,
которая дотягивается до конца,
то, на самом деле, как бы, в некоторых статьях,
это вообще там для этого отдельное определение находится.
Ну, кстати, про этот пост можно еще приятную штуку сказать.
Вот, кстати, давайте маленькое приятное упражнение на понимание.
Чему равен пост?
Есть нод в терминологии префикс функции.
Ну, это, по сути, модуль С...
Что?
Все строки?
Нет, это модуль С минус префикс функции от всех, от последнего элемента.
Да, на самом деле обратите внимание, да.
Еще маленький приятный факт, что пост, на самом деле,
равен модуль С минус пи от...
Ну, соответственно, модуль С минус один.
Ну, раз...
Потому что обратите внимание,
что это, фактически, максимальный собственный суффикс,
который совпадает с префиксом.
То есть, мы, по сути, храним значение префикс функции
и по нему как-то восстанавливаем эту функцию.
Нет, ну, не совсем.
Ну, не совсем.
То есть, в принципе, да.
То есть, на самом деле, так.
Мы в явном виде храним...
То есть, ну, по факту, мы в явном виде храним
префикс функцию в конце, по большому счету.
В общем-то, да.
И фактически, наверное, можно даже примерно прикинуть,
что, в общем-то, примерно этим мы, в общем-то, и занимаемся.
Вот.
Ну, теперь тогда...
Ну, вот.
Так вот, я действительно к чему?
То есть, поэтому неудивительно оказывается,
что если вот и делятся на пост,
ну, на самом деле, заметить можно утверждать и следующее.
Вот.
Давайте задумаемся, вот над чем.
Ну, вот.
Внимание, вопрос.
Какие еще строки будут дошадить до конца?
Вот.
Ладно.
Я сейчас переформулирую это.
Может быть, даже удобно переформулировать
в терминах префикс функции.
Очень хочется это сформулировать,
потому что раз уж тут зашла речь, то нельзя не отметить.
Там делится у маленького приятного свойства.
Так.
Так.
Ага.
Ну, вот.
Значит, смотри.
Прижила-была.
Сейчас вот абстражно.
Строка С.
То есть, давайте на этот раз, давайте для удобства,
может быть, в один индексации рассмотрим, хотя по барабану, в общем.
Смотрите.
Значит, я очень хочу рассмотреть вот что.
Допустим, вот эта вот строка имеет длину P от S.
Понятно, да?
Вот.
Ну, вот.
И теперь возникает следующий вопрос.
Я хочу рассмотреть вот эту всеми любимую последовательность.
П от P от modulus.
P от P от modulus.
Ну и так далее.
Ну, она может быть, конечно, очень большой длиной.
Понятно, да?
Вот.
Ну, вот.
Ну, на самом деле,
на самом деле оказывается, что ее можно,
на самом деле представить не обязательно за линию,
но в более компактном виде.
Так что, смотрите.
Нет, давайте, оказывается, нам, возможно, пришло время,
на всякий случай, ввести еще такое красивое понятие, как
удивительно, как shift с индексом S.
Вот давайте так.
В терминологии вот статьи, которые мы сегодня, по крайней мере, начнем изучать,
будет понятие такой массив.
Значит, такой вот тоже массив.
Shift.
Значит, S от одного до N.
И shift S от, допустим, Итого.
Он равен как раз вот
действительно минимальному такому
урону.
Да.
То есть, да.
Минимальному такому L,
что, действительно, S от L плюс 1 до I,
ну, раз уж в один индексации,
равна S от 1 и минус I.
Ну, короче говоря, минимальный, ну, то есть, так, можно сказать,
минимальный период этого префекса строки S.
По большому счету.
Понимаете, да?
Ну, ладно.
Давайте.
Конечно, L больше 0 нас интересует, конечно.
А то мы могли бы сказать, для L равно 0, это верно.
Ну, интересно.
Вот.
Ну, одновременно, просто он же shift, он же это, он же минимальный период.
Ну, просто иногда полезно смотреть именно на него,
потому что понятно, что он тождественно равен, как мы уже догадываемся,
просто I минус префикс функции, правда?
Согласны?
Ну, в один индексации, конечно.
Так вот.
Можно теперь заметить.
Так вот.
Вот в терминах shift на самом деле есть мистическое утверждение.
На самом деле мистическое утверждение звучит так.
В общем, я его сформулирую так.
Значит, вот утверждение.
Если этот shift достаточно мал,
то есть если shift, допустим, S от модуль S меньше,
вот чуть позже поймем, чего,
то я утверждаю, что на самом деле shift от P от S
равен, собственно, исходному шифту от S.
Да, замудренное, конечно, утверждение получилось,
но хочу я сказать следующее.
То есть, смотрите, что такое shift?
Shift – это вот эта штука, да?
Вот это вот shift.
Так вот, я утверждаю, что если вот этот shift достаточно мал,
то когда вы тут скопнете на P от P от S,
то оказывается,
что вот этот скачок тоже будет shift.
Вот я утверждаю, что он в точности им.
Осталось только выяснить.
Ну вот, и в общем-то и дальше некоторое время,
то есть на самом деле отсюда будет следовать, что дальше тоже будет,
то есть скачки shift, shift, shift и так далее,
ну и до некоторых моментов.
Но давайте поймем, откуда же я это утверждение вообще взял?
Ну, как мне понятно, что вот если мы завернем еще на shift,
то такой суффикс будет префиксом.
Да, ну во-первых, заметим, что строка shift периодично, да?
Поэтому получается автоматически, что действительно,
вот эта строка, конечно же, там, вот действительно,
аналогичной вот этой вот строке, естественно, равна.
Вот этой вот, в смысле, с shift.
То есть, получается, что строка длины вот этой P от…
То есть, получается, вот эта вот строка длины P от S минус shift,
это кандидат в P от P от S.
Но возникает естественный вопрос.
А чего не больше?
Вдруг окажется, что мы возьмем какой-нибудь,
какой-нибудь максимально яркий маркер,
например, черный,
и вдруг совершенно случайно окажется,
что на самом деле еще вот эта строка внезапно оказалась равна вот этой.
И она же, конечно же, вот этой.
Вдруг такое окажется?
И вот эту вот длину, допустим, назовем,
какую-нибудь A, вдруг так окажется?
Ну, с другой стороны, что тогда можно сказать?
У нас в нашей строке есть два периода, вовсе, которые,
ну, как бы, близкие, значит, не один, ну, как бы, не один, как-то огромный,
но я думаю, что можно противоречить того, что shift минимальный.
Ну, нет, ну как минимальный?
Ну, тут, да, то есть, в принципе, да, заметим, что из этого, на самом деле,
мы не можем сказать, что shift минимальный,
что префикс функции здесь была посчитана неправильно.
А каким же образом мы можем это сделать?
Ну, что мы знаем? Что мы знаем, что если у нас, ну, типа S E равно S E плюс shift, да?
А еще мы знаем, что S E равно S E плюс L,
теперь. Ну, где ли вот этот больше shift?
Так, давайте, я попробую это, наверное, более, ну, в общем,
аккуратно нарисовать еще.
Так, давайте, я даже что-то больше нарисую.
Тут нам, прям, вот, нужна, прям, вот, хорошая иллюстрация.
Да, то есть, если у нас есть, то есть, давайте посмотрим.
То есть, если у нас произошло так, что вот тут у нас, действительно,
произошел вот этот shift и вот это равенство,
то, на самом деле, как бы, мы не можем сказать, что shift минимальный,
что вот тут у нас, действительно, произошел вот этот shift и вот это равенство,
то, на самом деле, как у нас строчка вообще устроена?
Оно устроено так, что вот есть вот этот вот блок по шифту,
и, на самом деле, заметим, что строчка дальше устроена так.
То есть, у нас тут вот блок, блок, блок, блок, блок, блок, блок,
блок и в конце огрызов.
То есть, на самом деле, заметим, что эти строчки абсолютно одинаковые,
а это префикс, это одинаковый стройки.
Вот, понимаете, да?
Понимаете?
Да, нет, наверное.
Отлично.
Вот, то есть, получается, что вот это вот равно, получается, вот, тому же самому сдвинутому нашу.
Вот.
Окей.
Да, ровно, из этой же картинки абсолютно же следует, что тогда вот эта вот штука автоматически равна вот этой вот, ну, посмотри.
Видно?
Теперь давайте предположим, что что-то пошло не так.
Ну, вот.
И выяснилось, что, оказывается, можно еще, то есть, для шифта тут, то есть, префикс функцию найти чуть больше, чем, чем вот это вот.
То есть, оказывается, что у нас равенство оказалось вот какое-то вот такое.
То есть, вот это вот оказалось равно, что-то вот тут еще.
Вот.
То есть, равно и этому, и автоматически там где-то вот это.
Да?
Вот так, ну если сдвинуть, ну вот.
Да, получается вот так.
Чуть меньше сдвинули, наверное, но то ли досюда там где-то, то ли досюда.
Тогда что вообще получается?
Ну.
Давайте, если вот попробовать действительно поизраться так, то да.
То есть, если у нас тут сдвиг на L, то вообще можно заметить, что вот этот префикс, допустим, вот этот, вот этот вот.
разбился она, то есть этот shift допустим разбился на допустим на вот этот вот x и y, правда?
Ну то есть в принципе можно заметить на самом деле, ну можно на самом деле пытаться вот так вот
нарисовать, да, чтобы везде x и y допустим, x и y, вот x и y, и тут вот так, где-то тут у нас,
так, ну и тут на самом деле где-то вот, непонятно где x и y, ну вот, ну еще кончик непонятно там,
но и тут заметим, что у нас имеет место x и y, вот, вот, и так, но что мы тогда знаем? То есть смотрите,
что мы знаем? Мы знаем, то есть если shift достаточно маленький, достаточно где-то маленький,
то мы знаем, то с одной стороны мы знаем, что вот эта строка равна вот этой, но с другой стороны
раз мы еще вот это знаем, то получается, что очень интересно, что вот x и y на самом деле равен y и x,
то есть вот такое мистическое свойство, x и y равен y и x, понимаете, да? А что это вообще значит? А
значит вообще интересная вещь, что если я вот эти две строки удвиню влево на x и y, то как бы эта
строка увеличится на x и y, а эта увеличится на y и x, то тоже самое, понимаете, да? Вот эти две черные,
видите? Вот у нас тут есть вот эти две черные спряты, которые равны, да? А давайте удлиним влево на длину
и x плюс y. Это одна удлиниться на, получается, x и y, а другая удлиниться на y и x, что, как мы выяснили,
одно и то же. Вот тогда получается, что мы неправильно считали префикс функцию для глобальной строки.
Получается, если shift достаточно мало, то вот впечатлительно видно на люксу. А теперь внимание,
вопрос. Как вы думаете, что я должен написать в утверждении, чтобы вот это рассуждение про
если shift не больше, чем треть слиной строки, то это точно достаточно. Так, треть. Нет, нужна ли нам именно треть?
Нет, ну давайте подумаем, чем мы вообще пользовались? По большому счету, по-моему,
мы в явном виде воспользовались только тем, что у нас вот этих блоков как минимум два, правда?
То есть мы воспользовались тем, что у нас есть вот этот блок и вот этот блок. По большой нот.
Ещё мы где-то сказали, что x, y, y, x. Хотя да, где мы этим воспользовались? Ну, где мы воспользовались тем,
что x, y, y, y, x? Откуда мы это выкручивали? Из того, что там начинается новая строка,
которая как бы лучше, да, вот из y, она предлевается ещё хотя бы на, то есть хотя бы на x. Ну да, по большому счету, да, поэтому...
Ну да, правда, тут возникает вопрос, действительно. Ну да, получается, при таком доказательстве,
получается маленькая приятная вещь. Ну вот, не знаю, но третья получается всё-таки. Ну да. Так, ну допустим,
если shift, можно сформулировать действительно утверждение о том, что модуле 9 НАТО. Так.
Теперь давайте, ну вот. Ну, у меня почему-то жуткое подозрение, что можно и надо.
Давайте попробуем. Давайте-ка попробуем вот что сделать. Давайте попробуем рассмотреть
случаи, когда у нас блоков. Вот давайте рассмотрим. Ну, а первое, давайте, давайте вот посмотрим.
Действительно, можно ли требовать, что действительно таких блоков у нас хотя бы три? То есть,
нельзя ли потребовать, что у нас вот этих блоков хотя бы два? Давайте проводить.
Будем проводить красивый научный работа. Ну нет, нет, нельзя. Прям пример есть?
Давайте возьмём. Вот у нас есть. Давайте предположим, что у нас есть блок, блок и префект.
Shift, shift и что-то ещё. Так. Теперь возникает вопрос. Предположим, что у нас неожиданно
вот тут оказался X и Y. И вот это вот оказывается равно. Ладно, не вот это. Вот это. Ну, в смысле, вот такому.
У нас же игроке так определялся, что вот эта строка начиналась с него.
Да, да, да. Хорошо. Да, это, наверное, надо поменьше. Вот так вот нарисуем. А, ну если это блок устраивался,
то и вот. Вот тогда, действительно, что у нас получается? Мы же знаем вот что. То есть, я утверждаю,
что, ну то есть, так как у нас вот это вот равно вот этому напоминаем, да, вот, например, вот такое,
то можно это как-то сдвинуть. То есть, видим, что у нас тут, действительно, на лицо, действительно, сдвиг игрока.
То есть, по крайней мере, можно точно утверждать следующее. Что, с одной стороны, это X и Y,
но с другой стороны, смотрите внимательно, по крайней мере, мы точно знаем, что, ну раз вот эта
строка по факту совпадает с префиксом, да, обратите внимание, то тогда получается, вот эта строка начинается с игрока.
Это с одной стороны.
Это уж с игрока точно. А вот что тут будет идти дальше? Будет обязательно дальше идти здесь X?
Полое ощущение, что идти там дальше. Но почему?
Давайте так, ну если у нас, ну не знаю, например, для нас таки ровно два шип, то это неверное, что ли, там, примеры есть.
Если для нас таки ровно два шип, то, очевидно, не подойдет.
Да, ну действительно, если тут прям пусто, то, действительно, можно привести, действительно, к примеру, строку АВА-АВА.
Да, например.
Ну да, то есть, заметим, что совсем мало не получится. То есть, действительно, на лицо видим, что здесь шифт равен 3,
а вот в этой строке шифт уже, наверное, равен чуть меньше.
Да, действительно, действительно.
Такого не хватает, интересно.
А приписать, интересно, один символ, то можно, чтобы это было адекватно?
То есть, если тут ровно, то не получается.
А если написать вот так?
Если один символ написать консульту, то тоже не получается.
Тоже не получается.
Ну вот в данном случае, ну вот этот пример не подходит.
А какой?
Нужно Б, каждый раз, два раза было. Не по одной, а по две.
Если мы допишем консульту Б?
Нет, если мы допишем консульту Б, то там шифт будет уже не 4.
Будет не 4?
Конечно.
Почему?
Ну, потому что тут АБАБ, а тут АБААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА
Да, вот так странно, что, действительно, если это символ-нот, то если символ есть, то, как бы
А, можно, например, АА БАААААаАААААААААА АА в конце еще
АА БАААААААААА ААБААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА
тут шифт вот такой да действительно обратить внимание тут шифт 5 а в этой
строке шифт уже 2 4 ну в смысле 4 ну что ж действительно да получается что
действительно границу мы нашли точно воду лес делить на 3
вот действительно
да действительно есть такое маленькое приятное свойство
ну что но действительно но тем не менее на самом деле утверждение оказывается
достаточно красиво на самом деле с точки зрения префикс функция но означает
следующее что если префикс функция как бы меньше строки всего лишь на треть
обратите внимание пока она меньше на 3 то некоторое время префикс функции
образуют такую убывающую арифметическую прогрессию правда причем обратите
внимание то есть если у нас эта прогрессия идет там допустим шагом и
то есть там с-э и с-2 и так далее то она будет идти до тех пор пока тут оставшаяся
длина не станет меньше чем строго меньше чем 3 и только после того как
действительно она будет 3 и только после этого мы можем утверждать что этот
шифт неожиданно уменьшится в принципе возникает тогда получается что
последовательность префикс функций может быть представлена как таки
последовательность арифметических прогрессий где количество этих
арифметических прогрессий получается не превосходит чего
ну вот ну получается логарифма ведь действительно если взять прям целую
арифметическую прогрессию правда то мы можем заметить что когда но вот что
сколько не было шаров а как минимум в полтора раза строчка уменьшится правда
а это не дает нам в этот способ как раз логарифм устанавливать
считать сейчас префикс функцию да ну если у нас всех бы значений нужно
перебирать как-то там какая проблема там ну как арифметическая прогрессия это
конечно да но просто там как бы в дереве при фиксунце в эту арифметическую
прогрессию еще могут лезать поэтому совсем просто наверное не получится хотя
наверное да быстро скорее всего в эту сторону
там вроде как раз рассказали там были были про периоды нет про периода ну то есть
когда рассказывали как раз о ток не да да да да нет ну понятно какие-то
свойства да ну и действительно давайте ладно нет а давайте ладно раз уж пошла
такая раз у нас сегодня такой по-моему сегодня получился такой тип и получается
такой типичный семинар на самом деле где мы тут больше думаем чем читаем да ну
прежде чем вот это стереть мы только да он это что-то не доделали
а на самом деле это делали мы просто отдельно рассмотрели случаи когда и делится
на пост и просто рассмотрели про периодичность мы не обсудили заново
добавление символов а ой ой ой ой ой ой кошмар так да отматываем да прямо
по ремонтаже там уже какой-то все типа да тут тут мы прервались продолжение будет
через 37 да но действительно давайте смотри вот там эти формулы мы поверили
конечно мы занимались тем что вот когда и делится на пост мы начали
рассматривать интересный случай и заметили что в принципе если пост
достаточно мало то можно даже даже предсказать чему будет равен следующий
пост в случае чего но вот но в общем это и не важно тоже ладно с этим то мы
поняли остается только один маленький вопрос хорошо за это мы научились
считать причем честно вот а теперь мы с кайта просто как же этот символ
приписывать но здесь уже на самом деле никаких проблем особо нет потому что
как вы как вы знаете за функцию для строки с мы насчитывать уже умеем за от
единицы поэтому можем просто начинать способ вот проверить вот пост подходит
ли нам и нет как проверить мы знаем что как бы до конца строки с у него под строка
доходит и возникает вопрос следующий символ равен этому ц если равен то в
общем-то пост никуда девать не надо за 1 если нет то значит пост двигаем на
единичку остается только понять верно ли что вот этот под строка равна
префикс как-то проверить ну заметим что за эту функцию от пост плюс один ну
в предположении что этого символа ц нет мы вычислить можем правда быть только
за вот единицы вот как мы уже поняли то есть дальше то есть дальше тут ну то
есть получается как мы тут неожиданно доказали на самом деле то есть на самом
деле начинает с этого места то есть тут просто это за функция в строке с идет
тупого периода у нас такая с периодом пост такая последовательности период мы
знаем ну ладно не совсем период период там поможет для того что она обрубается
вот но это не важно то есть важно что мы знаем но важно что в любом случае главное
что мы их знаем и главное теперь можем проверять если z функция до сюда до
езда же не доходит до конца то ее проверять бессмысленно а если доходит то
значит проверяем нельзя лишь у и носим 한번 в цель этот пост будет просто
сдвигаться сдвигаться сдвигаться сдвигаться но и сдвигаем до тех пор пока
очередной пост продлить не удастся. И получается, ну фактически получается метод двух указателей.
Такой классический метод двух указателей. Вот амортизирован, это получается за от 1.
Вот. Ну на самом деле, да, можно на самом деле задуматься, то есть про такую отдельную фишку
действительно нельзя ли как эту учетную стоимость изменить на, может быть, чуть
более худшую, но честно. Вроде как из-за функции можно будет создавать префикс функцию,
поэтому тогда мы вам префикс функцию тоже научим даже. Ну да. Кажется, что эта функция так не прокачивается.
Сейчас. Ну так сказать. Нет, ну почему? Нет, ну смотрите, ну дело в том, что как бы, ну тут,
конечно, идея может быть уже в том, что вот исходя из этого утверждения, мы на самом деле можем
знать, как устроены на самом деле все эти подходящие посты в принципе. Они устроены как красивые
арифметические прогрессии. Ну вот такого-то момента, да. Да. И действительно, идея может заключаться в том,
что для каждой, допустим, для каждой, допустим, этой арифметической прогрессии, допустим, мы,
честно, храним все символы, которые нефть теоретически можно применить.
Нет, хотя, ну вот. Хотя нет, ну там будут, конечно, всякие подлямки, конечно, неприятные. Потому что когда мы
перемещаемся к следующему, как там следующие символы считать? Так что да, не так просто. Поэтому
лучше начнем с префикс. Вот. А вот этому алгоритму вопроса есть? Нету? Хорошо. Значит, тогда вот что.
Ну вот. Тогда действительно последнее, что мы сейчас делаем, тогда перед переживом. Далее, ну вот. То есть действительно,
последнее, что хочется, это задуматься вот над каким вопросом. Раз мы уже поняли, что префикс
функция действительно обладает вот такими скачками действительно арифметической прогрессии,
то действительно нельзя ли вычислять новую префикс функцию с добавлением нового символа каким-нибудь
красивым и учетным образом. То есть красивым и неучетным образом. И оказывается маленькая приятная
вещь. Ведь действительно. Итак, вот давайте внимание еще раз, что мы хотим. Вот хотим мы строку s,
мы хотим вычитать у нее префикс функцию, но при этом, когда добавляется символ c, мы хотим эту
префикс функцию тоже вычислять, но при этом желательно за от какой-нибудь адекватное время, но что важно,
честно. Без вот этой амортизации. Так что это можно сделать. Ну на самом деле, давайте подумаем вот о чем.
Заметим, что можно на самом деле, если у нас s равно, как всегда, с от одного до модуля с какого-нибудь,
то есть в один адекват, то что мы делаем? То как мы обычно вычисляем вот эту вот префикс функцию?
Обычно мы скачем, да, то есть там код что-то в духе там for, там действительно g равно p от там бывшего
модуля s, g больше нуля, g равно p от g. Если там совершенно случайно оказалось, что s g плюс первое
равно s, равно вот этому новому символу c, то значит p от вот этот модули s плюс 1 оказывается теперь равно.
Равно теперь получается g плюс 1 и соответственно бряк. Было дело, да, помните? Было дело?
Там была префикс функция. Префикс функции такое было когда-нибудь? Так вот, теперь возникает вопрос.
Очень хочется, что мы знаем, что учетная стоимость работы этого кода от единицы, ну там можно как-нибудь с
монетками писать, а мы хотим в честную. Ну вообразить себе теперь это можно следующее. Ну во-первых,
заметим, но заметить можно следующее. Давайте нарисуем, на самом деле, то есть раз уж мы в прошлый
раз ввели автомат префикс функции, то неплохо бы ввести дерево префикс функции. Вот давайте просто так
и введем. То есть у нас будет действительно тоже в дереве вершины 0, 1, 2 и так далее модуль s,
вершины с каждым новым c будут добавляться и из каждой вершины и у нас будет ввести ребро в петлю.
Вот как-то вот так это будет. Такое деревце какое-то. Ладно, оно конечно не абсолютно
рандомное дерево, да. Мы конечно знаем, что это дерево будет спорним в 0. В нуле как-то вот так это
будет может быть. Какие-то деревья могут быть. Что на этих деревьях может произойти?
Вот. Ну теперь по большому счету. Ну вот, то есть по большому счету теперь что у нас? Когда у нас
приходит новая вершина, новая вершина с номером модула s плюс 1, то что мы пытаемся сделать? Мы
пытаемся взять вершину с номером модула s и прогуливаться по этому дереву до тех пор,
пока справа от очередной позиции соответствующей вершине окажется новый символ c, правда? Понимаете,
да? Но как мы уже поумним, да, у нас имеет место фактически функция go от вот этой вот позиции,
ну там по смысле и она же это, то есть от и и вот этого символа c. У нас есть функция go, правда?
Понимаете, автомат у нас, в общем-то автомат у нас за счет чего работал? Автомат у нас работал за
счет того, что мы как бы для каждого и для каждого c заранее преднасчитывали, собственно, если мы
будем из этой вершины пытаться искать проход по символу c, где мы его найдем, правда? Это работало по
принципу, что, ну то есть работало, что отсюда следовало, что если автомат, если это у нас конечная,
конечная штука, то в общем-то вот в терминах дерева можно сказать, что как бы докуда нам
надо подняться, чтобы тут по символу c пройти было можно, правда? Понятно, что я говорю?
Или уже мух настал? Ну это когда автомат, но просто фишка, просто ради чего мы вообще все это делаем?
Ну, например, хотелось показать дерево, а вдруг теперь мне сказать такая идея, а как бы это делать,
если размер алфавита не равен вот этой вот констанции? Ведь заметим, что префикс функции
сам вообще работает, даже если вам там подсовывают абсолютно произвольные числа или, знаете,
еще как бывает, произвольные камешки, которые между собой умеют, ну там, в худшем случае,
если они умеют сравниваться только на равно и не равно, то я боюсь, конечно, вы без этого,
если только на равно и не равно, то возможно мы тут ничего и не выбираем. Вот, ну либо там,
ну вот. Но с другой стороны, значит, полный автомат, просто в чем проблема? Проблема в том,
что полный автомат мы таким образом не построим, ну или построим, но за неудобоваримую для нас ассоциацию.
Вот, но возникает такой действительно естественный вопрос. Вот, а можно было бы сделать действительно
что-нибудь, можно ли бы сделать что-нибудь, чтобы находить действительно, где этот символ
впервые встретится вот на вершине, за куть хотя бы удобоваримой симпульте. Правда, у меня есть
такое неожиданное решение. Если мы верим в персистентный сет или персистентный мап,
то смотрите какая идея. Вот, идея такая. Допустим, мы вот для этой вершины у нас есть, для вот этой
вершины у нас есть мапчик, который для каждой чиселки скажет, где тут у нас ближайшая вершина,
чтобы по этой вершине можно пройти. А теперь заметим, что вот для этой вершины мапчик должен
отличаться только, ну по сути в то, что мы должны добавить, что переход по символу, который идет
сразу после нее, он, собственно, другейший. Логично, да?
Ну, смотрите, значит, мы хотим в каждой вершине хранить такой мап, где по каждой, вот допустим у нас
эта вершина В, и хранить в мапчик, который по символу С сопоставляет, ну то, что мы называем
Go от ВС. Правда? А теперь смотрим, вот рассмотрим вот эту вершину, у которой предиксун идёт сюда.
Как устроен этот переход, да? То есть Go устроена так, что если конкретно из этой позиции можно по
символу пройти, то мы прям в ней и проходим. А если нет, то мы тогда идем сюда, и по сути,
вот в этом мапе уже ответы еще, правда? Получается, мап вот этой вершины отличается от мапы этой вершины,
но там буквально в одной позиции. То есть надо посмотреть символ, который идет после этой вершины,
и, собственно, его либо заменить, ну либо добавить, если его там в мапе не было, правда? Ну и все. Тогда
получается идея, давайте хранить. Ну тогда... Может быть даже персистентный не мап, а персистентный массив.
Ну, в смысле, просто одинаково... Не, ну как... Не, ну, поедете, массив, поедете, мап, потому что у нас,
вот эти фиселки же произвольные, то есть если вы, конечно, заранее сожмете координаты, то, конечно,
можно и персистентный массив, да. Но если не сожмете, то лучше уж там, лучше воображать себе нашу любимую
персистентную авею. Ну, не дикотечку уже, да. Вот дикотечку мы не любим, она вероятностная, да. Ой, хотя, может быть,
будто у нас вероятностная алгоритма, мы ее не полюбим. Но, в принципе, вот персистентный... Получается,
что, по крайней мере, с помощью персистентного дерева, действительно, о от лог-рифма вполне
можно. Правда, здесь есть маленькая оговорка, прежде чем опустить вас, скажу. То есть здесь мы в явном
виде воспользовались тем, что символы можно не просто сравнивать на равно и неравно, а еще их
можно сравнивать на то, кто меньше, кто больше. Ну, формально говоря, если вы умеете строить
персистентную хэштаблицел, ну, там, с этими вашими руполок единицы, да, то, в принципе, в принципе...
На другой деле, на практике нам же символы должны как-то, ну, как-то подавать на ввод, да, и они должны,
ну, не знаю, иметь хоть что-то, номера или как-то... Ну да, по большому счету, да. Ну, тут вопрос как бы,
да, в идеале, конечно, символы нам по-любому выдаются как последовательность битых, можно связывать
хотя бы как последовательность битых. Другой вопрос, что, как бы, тогда придется сравнивать за о, от
количества этих бит, а мало ли, как они вам поддаются. Хотя, с другой стороны, конечно, строка из алфавита,
там, каждый символ, которого является каким-то вот этим вот экзотическим забубенным, этой шнуром...
Ну, просто логарифм у нас и, ну, не знаю, делоплод увеличивается, ну, понятно, зависит от шнуров бит, так что можно себе позволить добавить.
Ну, если, ну, наверное, ну, там, да, ну, да, получается, вот за логарифм можно, да, ну, я не знаю, вот интересно,
можно ли обойтись без персистентных это, то есть как бы, то есть без персистентного чего-нибудь, но за логарифм,
получается, можно где-то, а на той лекции прям так предлагалось пользоваться, это персистентный
деструктур, или оно, или там всё-таки это умные, там, собственно, достаточно умные учёные умеют обходиться без этой чёрной модели.
Ну, вот, то есть, не знаю, может, они там действительно пользуются тем, что есть
арифметические прогрессии с ними, красиво можно работать. Ну, впрочем, ну, конечно.
Ну, что ж, кажется, ну, да, пожалуй, пришло время сделать переговор.
