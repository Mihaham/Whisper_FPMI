Так, все, давайте начинать тогда. У нас с вами седьмая лекция. И про что мы сегодня с
вами будем говорить? Мы закончим с вами пробу дерева. У нас там должок остался минут на 30,
наверное, это удаление. Потом у нас будет сплей дерева, там быстренько, и если успеем,
там еще что-нибудь разберем. Но если не успеем, значит на этом все. Что? А оно вообще не в эту сторону.
Б-дерево часть вторая, и сплой дерева. Окей, ну давайте. Все же помнят, что такое б-дерево.
Это дерево, в котором хотя бы t-1 элемент в узлах, кроме корня, не больше чем 2t-1 и глубина
всех листьев одинаково. Вот окей, нас будет интересовать удаление. Удаление из б-дерева.
И мы будем гарантировать себе следующее. В ходе спуска во всех узлах, кроме корня,
на пути хотя бы t-элементов. Казалось бы, зачем вам это надо? Потому что у нас ограничение t-1 из
определения, для б-дерева ранга t. А здесь мы хотим прям на 1 больше. Этой краски нам надо
быть, чтобы когда-нибудь мы его там спустим, этот элемент, и удалим его. Чтобы у нас остался t-1.
Вот. Окей, как-то будет делаться. У нас будет несколько случаев. И первый случай такой.
Ладно. Первый случай откладывается. А мы спустились в узел и не можем найти маркера
нормально, хотя он даже типа запакован. Вот так спустились в узел. Узел давайте обозначим как-нибудь
x. В нём есть искомый ключ k. Ой, почему в узел? Извините, в лист. Вот. То есть мы сами спускались,
спускались, спускались, пришли в лист, и в нём есть нужный нам ключ. Вот что мы будем делать?
Просто удалим его из листа. Почему? Потому что мы гарантируем, что у нас хотя бы t-элементов
в нём есть. Вот по вот этому вот интересному утверждению. Пока что мы не знаем как,
но давайте просто поверим в это. Вот. Просто удаляем. Случай. Второй давайте перейду
на следующую досочку. Это мы с вами пришли в узел x. Это у нас будет внутренний узел, то есть
листовой. И в нём есть ключ k. Вот что тогда делать, если мы пришли внутренний узел, в нём есть ключ.
То есть как бы такая у нас ситуация. Это x, есть ключ k. Есть какие-то его дети. Вот что можно
сделать? Какие у нас будут варианты? Ну, вариант первый следующий, что, то есть случай A. Давайте
обозначим левого сына за y, а правого сына за z. Вот такая ситуация. В y больше либо равно,
чем t. Минус один. Больше чем t просто. Т ключи. Вот что тогда можно сделать? Ну, будто бы можно
абсолютно легитимно взять отсюда последний элемент. Затем сюда, а этот удалить. Почему это
можно сделать? Потому что этот элемент самый большой среди тех, кто меньше k. Поэтому просто
берём на него заменяем. А k выбрасываем. Вот. Как-то так. Хотя бы t. Потому что если у нас меньше,
чем t, то есть t минус один, то мы не можем просто вот туда удалить. Вот. Тогда пишем вместо k
максимум в y и удаляем k. Удаляем вот этот максимум по y. Суть второй. Это y t минус один
элемент. Но в z больше либо равно t элемента. То есть ситуация такая же абсолютно.
З, у, х. Ключка. Что тогда мы делаем? Мы делаем абсолютно аналогично, а только наоборот из z выпиливаем.
Аналогично 2a, но вместо
максимум по y будет минимум по z. Ну окей. Казалось бы классно, да? Какой у нас случай остался? Да,
в случае v у и z по t минус 1 элементу. Что тогда предлагается сделать? Будут идеи какие-нибудь?
Ну да. Идея следующая. Сделаем узел y штрих, состоящий из y плюс k плюс z. То есть будет
такой вот, дайте здесь нарисуем. Здесь lr, чтобы было понятно кто у него соседя. Это l от r, то есть мы выпилили отсюда k, просто убрали. И у них ребенок будет вот такой вот.
Y, k, z. То есть мы просто взяли и k перекинули вниз. Мы его отсюда удалили, внули его в этот узел,
но войден дочерний. И рекурсивно выдвинемся от этого узла дальше. Ну вот смотрите, давайте просто посмотрим. Вот у нас наша ситуация. Вдруг здесь тоже были дети какие-то такие неприятные, маленькие. Да, у них? Вот как сморжить этих двух? То есть у инжера там тоже есть свои дети какие-то?
Здесь какое-то большое, здесь какое-то большое может быть. Если их сливать вот так вот просто, то это будут какие-то огромные дети. То есть тут допустим 2t минус 1, тут 2t минус 1, в общем 4t минус 2 вообще в ребенке. С ним не понятно что делать.
Поэтому, то есть смотрите, наша цель какая? Взять и k докинуть до листа каким-то образом. Вот этот ключ k провести. Вот, и потом воспользоваться первым случаем.
В плане?
Ну да, да, рекурсивно от него запускайтесь. Просто основным ключом удаления вызываете.
Удаляем, здесь имеется в виду по правилам B дерево.
Давайте здесь допишем далее.
Удалим k из x.
И новый ребенок.
Это y'.
Какой случай мы еще не рассмотрели?
Не, с корнем все легко.
Лист это вон первый пункт.
Пришли в узел, а в нем нет ключа k. Он есть в каком-то из детей.
Видите, мы же еще это не разобрали. Мы только знаем, что если мы пришли в узел с ключом или пришли в лист.
Но что делать, если мы пришли в лист без ключа, мы еще не знаем вообще.
В узел без ключа.
Пришли в узел x.
Ключ k лежит в x.
Ну, x это ребенок.
То есть, вы находитесь в вашем прекрасном x.
И вы знаете, что где-то вот здесь, в каком-то вот поддереве,
вот это вот x.x находится ключ k.
Например, вы просто посмотрели, сравнили вот эти вот два элемента и поняли, что k между ними находится.
Что тогда нужно делать?
Давайте здесь нарисую большую картинку.
Вот нам понадобятся вот эти вот, так сказать, ребенок и его два брата акробата.
Слева и справа.
Что делаем тогда?
Ну, внезапно пункт A.
Это если у нас
пункт A даже не так.
x.city содержит больше либо равно t ключей.
Что тогда мы делаем по-вашему?
Просто спускаемся в него, да и все.
Случай B сложнее.
x.city t-1 элемент.
Что тогда хочется сделать?
Как-то мы можем объединить его с соседом, если у него может быть много элементов.
2t-1.
Что?
Ну, типа того, да.
И вот следующее.
Пусть в x.city-1 или в x.city-1 хотя бы t элементов.
То есть в одном из них хотя бы t.
Что мы тогда можем сделать?
Допустим, у этого размер больше либо равен t.
Что можно сделать?
Вот отсюда вот пилить максимум.
Перекинуть его вот сюда.
А этот элемент в ребенка закинуть.
Тогда у нас здесь, кажется, t элементов.
И при этом все хорошо.
То есть нам нужно лишь понимать, откуда можно отрезать.
Тогда
пусть у x.city-1
больше будет t.
Что тогда мы делаем?
Тогда вместо
Так, это будет у нас x.ity.
Вместо x.ity пишем
Максимум от x.city-1
x.ity перебрасываем
в того
x.city
Окей, перебросили.
Что дальше-то?
Ну да, дальше можем в x.city спускаться.
Здесь все будет хорошо.
Ну и в случае v
я думаю последним этапом исключения,
что у вас в обоих по t-1 элементов.
Понятно, что кого-то придется объединять по t-1.
Ну и в случае v
только вот придется объединять по t-1 элементу.
То есть смотрите, у нас в x.city там t-1 элемент
еще и в этих вот двух
чуваках по t-1 элементу.
Ну давайте просто совьем с одним из соседей.
Причем сольем путем того, что мы x.ity
будем туда вниз опускать.
Опустив x.ity
Ну и рекурсивно называемся от этого узла.
То есть будто бы как вот здесь вот
делали.
Ну и в случае v
теперь все.
Маленький алгоритм на три досочки.
Давайте пример рассматривать.
У нас с вами будет сегодня
одно большое B-дерево,
из которого мы будем удалять элементы
рассматривая разные случаи.
Так, чтобы
Так, чтобы
Кого именно?
Ну и x.city вы опускаете и сливаете его
в двух чуваков.
В плане включить корни, вы его можете опускать.
Причем проблема.
Все то же самое абсолютно.
То есть здесь вся ситуация, если вы в корне
абсолютно аналогичная.
Вот.
Как бы с этим вообще проблем нет,
что мы в корне находимся.
Так, здесь AB,
здесь D,E,F.
Так, здесь
J,K,L.
Здесь no.
Здесь
Q,R,S,
U,V
И здесь Y,Z,T
равно 3.
Вот такое вот дерево у нас с вами.
Ну почти весь алфавит английский
я бы уместил.
И мы сейчас будем с вами просто-напросто кучу удалений делать
подряд.
И перерисовывать дерево после этого.
Удаление F происходит.
У вас запрос, ну и рейс F сделать.
Смотрим алгоритм.
Мы стоим в корне.
Все OK.
Смотрим, что F будет находиться вот здесь.
Правда ли, что здесь больше либо равно
Да, отлично, все, просто спускаемся.
Находимся здесь.
OK, F снова.
Спускаемся, он где-то здесь должен быть.
Больше либо равно ты был слов? Да.
Спустились. О, мы в листе оказывается.
Значит, в нем можно просто F удалять.
Поэтому дерево
можно я не буду перерисовывать его.
Я его потом перерисовываю,
когда будут более масштабные изменения.
Просто
вырезаем F.
Дальше следующее, удаление M.
Вот я стою здесь, снова смотрю.
Лево больше либо равно T?
Да, ну и M где-то здесь должен находиться.
OK, спускаюсь сюда.
Нахожу M.
Ага, мы находимся
не в листе, поэтому это не первый
случай.
И при этом у нас есть наш ключ.
Поэтому находимся где-то во втором случае.
Теперь надо выбрать один из трех.
OK, в Y больше либо равно T ключей?
Да.
Потому что вот он ваш.
Сейчас, подождите.
Тра-та-та.
А, ну да, все OK.
Вот он наш Y.
В нем больше либо равно T ключей.
Поэтому мы берем, делаем следующее.
A, B.
D, E.
И что мы с вами делали?
Мы говорим, берем максимальный элемент,
перекидываем вот сюда.
Дальше что?
Здесь остаются вот эти вот G и K.
Здесь
N, O.
Вот.
Вот мы и удалили с вами L.
L.
Вот он.
Мы перекинули наверх, вместо M.
Да, J, K, L.
Да, удалили M.
Ну да.
Ну давайте посмотрим.
Это в случае A.
Просто-напросто.
Что?
Раз, два.
Слева, справа.
Это Y, это Z.
Ну да.
Ну что поделать?
B дерево, это такая штука
интересная.
Особенно по терминологии.
С кого мы тут дальше удаляем?
Удаляем G.
G которая.
Удаляем G.
Давайте здесь писать в случае, что это был первый случай.
Это был 2A.
Теперь я хочу удалить G.
Ну что здесь?
Спускаюсь вниз.
Больше либо равно Т-узлов?
Да, все хорошо. Спустились.
Вижу, что G есть такой чувак
и при этом у него
оба ребенка по T-1.
Ну тогда смотрим.
То есть в Y и Z по T-1 элементу
значит это 2V.
Как тогда действовать?
Ну опять же по алгоритму
будто бы опускаем этого чувака вниз.
Делаем один большой узел
и от него вызываем удаление.
А, B.
Здесь
N, O.
Давайте А, B.
Правее прикину.
И посередине у них будет результат
этого гениального слияния.
D, E.
G, J, K.
Да.
То есть вот мы с вами вниз прокинули
этот элемент.
Ну и дальше вызываем
эрейс G в этом узле.
Ну смотрите,
когда вы сливаете,
у вас проблема в том, что если вы просто
бы оставили бы узел D, E,
J, K сразу,
у вас здесь вот
вот у этого чувака
самого правого сына,
у этого чувака самого левого сына могут быть большими.
Вы не можете так просто взять их и схлопнуть в одного.
Там же могут быть оба по 2T-1.
Их нельзя так просто сложить.
То есть у вас могли быть здесь сыновья,
которые огромные.
И если бы вы схлопнули их в один,
все было бы совсем плохо.
А так у вас все очень вариант поддерживается
и дальше вызывают удаление G, вы корректно это обработаете.
Ну мы находимся в листе,
поэтому удаление G выполняется
по первому случаю, вот так вот.
Все.
Да.
Если вы их просто так схлопните в одного ребенка,
то это проблема.
Так нет, они схлопнутся
по нужным вам правилам.
То есть если у вас здесь много детей,
то посидите, например, сюда один
и не будьте их сливать,
как в 2A делалось или в 2B.
Ну смотрите, если у вас здесь
дети
были какие-то большие,
то вы бы удалили бы G
путем вот такого вот алгоритма.
Как в 2A вы делаете.
Или в 2B.
То есть вам бы не пришлось
схлопывать детей на самом деле.
Нет.
Если здесь T элементов,
то смотрите, это в случае 2A
становится тогда.
То есть вот ваш новый X,
вот ваш новый Y,
вот ваш новый Z.
И если в Y много элементов, вы удалите
путем просто подмена.
Вот.
То есть поэтому так просто здесь не делается.
Потому что у вас могут быть какие-то сложные ситуации.
Так.
2B.
Так, дальше удаляем B.
Так, давайте я здесь нарисую,
что здесь было.
У вас TX.
Так.
Q
RS
QB
YZ.
Вот такое дерево у нас теперь.
Теперь мы будем удалять D.
Вот мы стоим
в узле P, в корне.
Мы понимаем, что нам надо идти влево.
Проблема в том,
что у вас здесь T-1 узел уже.
Вы не можете так просто пойти.
То есть какая ситуация, что
мы находимся в узле,
у нас нет нашего
внутреннего узла, мы не лист,
поэтому первый случай отсекается.
При этом ключ находится не внутри нас.
То есть не второй пункт.
Значит, пункт третий нам нужен,
потому что ключ находится где-то в ребенке.
При этом прикол в том, что мы не можем
просто так спуститься в ребенка.
Потому что у вас здесь по T-1 элементов.
Поэтому что делать? Происходит
слияние внезапно.
По пункту
вот этот вот.
У вас появляется один здоровый корень.
Вот мы наконец-то пришли к тому моменту,
когда высота уменьшилась, кстати.
Его дети.
Это A, B.
D, E, G, K.
N, O.
Q, R, S.
U, V.
Y, Z.
Вот такое вот дерево.
И теперь из него удаляют D.
Ну окей, смотрим.
Переходим сюда, видим,
что здесь много элементов.
Больше верно, чем T.
Поэтому просто D здесь удаляется путем
отпиливания.
В случае 3V.
Что?
Кого?
Да, конечно, вы просто пробегайте
по ним.
Смотрите, чтобы реализовать 3-й случай,
вам нужно понять,
что ключ K лежит в X-рейтам.
Вы это делаете с помощью
краски просто либо прохода линейного,
либо бинпоиском как-то по узлу.
Вообще, по-хорошему, в идеале вы
сначала вызовите и проверьте,
есть ли он или нет.
Потому что если элемента просто
нет в дереве,
зачем-то что-то мучится его ломать
как-то.
Но можно и не делать файнт
на самом деле. Просто если в какой-то момент вы пришли вниз
и там нет элемента, то
да, чуть-чуть перелопатели
свой дерево.
Ну круто, конечно, но зачем вы это делали?
Не очень понятно. Ну окей, перелопатели,
оно все еще корректное будет после этой
операции. Вы просто пойдете вниз и обнаружите, что
элемента нет.
Ну ладно, ничего страшного,
можно вызвать один проход. Можно вызвать
файнт сначала, потом
всю эту процедуру, но зачем?
Ну например, вот вы перелопатели
уменьшили глубину. При этом у вас
D вообще могло не быть в дереве на самом деле.
Ну я же говорю, да, вы можете дерево
перелопатить, оставить его корректным.
Вот, но при этом ничего и не найти.
Что?
Ну, спускаться лишний раз-то долго, потому что
вам читать надо два раза.
Странички вот эти вот.
Ну перелопачевое
дерево тоже не то что прям классная идея, если честно.
То есть как бы чтобы быстрее, здесь
сложно сказать, все есть
железо, грубо говоря, на котором вы пишете, и ранга дерева.
Здесь как бы нельзя давать какую-то теоретическую
оценку.
Так, ну и последний случай
это УДМБ.
Стоим в корне, все нормально,
идем вниз, смотрим. Ага,
элементов мало.
Но у нас есть любимый брат,
который с нами поделится.
Вот этот вот чувак, вот он сейчас
будет жертвовать собой.
То есть вот такой случай у нас, что
xCity содержит
xCity содержит t-1
элемент, вот наш ребеночек.
Но у него есть брат,
большой брат, который содержит много элементов.
Поэтому это 3b.
Что делается?
Полняется следующий трюк.
Сюда пишется e,
сюда пишется c.
Единственное проблема в том,
что у вас как бы здесь ключ удалился,
поэтому вы должны будто бы вызвать,
будто бы у вас на самом деле здесь d
остается,
и вы делаете e raise от d от этого узла дальше.
Потому что у вас здесь есть дети,
с которыми тоже надо как-то управляться,
и нельзя просто вырезать элементы,
схлопнуть детей.
Дети это вам не игрушка.
Вот бы дерево доказывает.
Подождите, сейчас.
d остается.
У вас же здесь d, e, g, k?
Будто бы было, да?
Как изначально.
А, мы d удалили, все, окей.
Сейчас, подождите.
И смотри, что у вас происходит.
Вот вы будто бы такое дерево оставили,
дальше и raise от e здесь делать,
от этого узла.
Потому что если вы просто выпилите отсюда d,
у вас есть два ребенка, с которыми надо что-то делать.
Ну да, да, да.
Вот сейчас вы будете тоже рекурсивно запускать от него.
То есть будто бы вы взяли,
поперекидывали элементы,
но вот этот чувак, его e отсюда надо удалить,
на самом деле.
То есть это будто бы вот как 2a мы делали с вами,
чтобы вызвать вот этот узел,
вот этот узел,
вот этот узел,
вот этот узел,
2a мы делали с вами,
чтобы вызвать этот e raise max, вот этих вот.
То есть вы там не просто выпиливаете чувака,
а вызываете от него e raise нормально,
чтобы с детьми все было хорошо.
Иначе, ну, дети расстроятся.
Как бы отца забрали,
а с ним ничего не сделали,
надо о них позаботиться.
Грустная история.
Я забыл дописать последний шаг,
что здесь еще нужно с ребенком разобраться.
Но почему это так?
Давайте мы из
этого дерева,
вот из этого, да,
вот отсюда
сделаем delete a.
Что тогда происходит?
Давайте будем считать, что здесь еще есть какие-то дети.
Да, да, да, да, да.
То есть вот, допустим, у нас есть какие-то дети.
Ну, здесь их нет,
но давайте допустим, чтобы было понятнее,
что нужно доделать.
Только их надо как-нибудь обозначить по-хорошему.
Давайте t1,
t3,
t4, t5.
Ну, это t2, соответственно,
у меня просто негде его написать.
Что тогда вы должны сделать по-хорошему?
Ну, во-первых, как мы с вами и говорили,
что у вас происходит?
Во-первых, у вас происходит
эта вот переброска этих чуваков.
То есть вот ваш p.
Здесь что-то страшное.
Что будет здесь?
Во-первых, у вас сюда e перебрасывается,
сюда c.
Тут такое вот дерево получается.
Ну, единственное, здесь у вас будет слияние большое.
Да, сейчас отменим.
То есть у вас сначала здесь все сольется.
c, l, p, t, x.
Вот.
Сейчас e, c, l, p, t, x.
Вот.
Сейчас.
И что я хочу еще сделать?
Давайте я буду считать,
что у меня здесь...
Ладно, давайте я нарисую просто новое дерево.
Чтобы не танцевать
на этих старых костях.
У меня есть такое дерево.
Так, здесь будет p.
Здесь будет что-то страшное,
не нужное нам.
Здесь будет c, l, m.
Здесь будет n, o.
Ой, кто там левее?
Jk.
Сейчас.
Надо буквы подобрать.
Это a, b.
Здесь будет d, e, f.
Не нужны.
f, g.
h, i, j.
О, вот такое вот дерево пускай у меня будет.
Ну, здесь там какая-то часть,
которая нас не очень интересует.
Вот.
Я хочу вызвать у него delete
от a.
Что тогда я делаю?
Ну, я перерисовал,
чтобы здесь было три ключа,
чтобы мне эти слияния не нужно было делать.
И они у меня не портили картину.
Мы выходим сюда, отлично.
Вызываем запуск отсюда.
Смотрим.
Ага, здесь t-1, чувак, грустно.
Но здесь их три,
поэтому этот чувак может поделиться с нами на самом деле.
Поэтому что происходит?
Происходит такая вот трансформация
следующего вида.
Ну, давайте детей их нарисуем сразу.
t1,
t2,
t3,
t4,
t5.
Что мы с вами говорили?
Мы с вами говорили, что c мы будто бы перекидываем сюда,
а d сюда.
Это пункт
3b.
Что у вас здесь происходит?
У вас, понятно, остается этот p несчастный.
Стоим
правым под деревом.
Здесь мы с вами говорили, что
происходят страшные вещи.
Ну, gm тут вообще не страшно,
что происходит.
Это я даже рисовать не буду.
Что происходит здесь?
Вы сюда пишете d,
да,
а сюда будто бы пишете
a,
b, c.
И проблема в том,
что если у меня здесь еще остается d, e, f
с их деревьями,
то мне нужно делать и рейс от a здесь,
и рейс от d здесь.
Это грустная история.
Вот так делать не нужно.
Поэтому что здесь делается?
Вот здесь остается e, f,
в которых какие дети были?
У e правый ребенок,
это левый ребенок, это t5.
Здесь у вас
t1,
t2,
t3.
А t4 был левым ребенком d.
И мы не можем его сделать левым ребенком d,
там abc стоит.
Но смотрите, какое красивое вакантное место есть для t4.
Давайте поймем, почему это работает.
Элементы все в t4
меньше, чем d, согласны?
Потому что это левый ребенок d.
Но больше, чем c,
потому что они в правом поддереве от c.
То есть все элементы t4
между c и d. Что здесь происходит?
Они все больше, чем c,
потому что это
их левый родитель,
назовем это так.
Родитель номер один, родитель номер два.
А у
c родитель
это d.
Поэтому все вот эти вот чуваки должны быть меньше, чем d.
Поэтому все элементы t4
снова между c и d и заняли корректное положение.
То есть мы здесь не дописали
саби на самом деле,
что
левого
ребенка
x, c,
и плюс один
на место
подвешиваемого, назовем это так.
Потому что это сложно
описать словами и не влезет сюда.
Вот.
Теперь понятно.
Это все в долине из b дерева.
Наконец-то мы закончили.
Приключение на
полтора часа. Вошли и вышли.
Откуда я могу стирать?
Где бесполезную информацию?
На самой правой доске?
Так.
Так, кейс-плей дерева.
Сплей дерева это вообще очень простая
штука на самом деле.
Если не доказывать теорему,
которую мы не будем доказывать.
Поэтому это очень простая штука.
Сплей дерева
обладает
одной операцией.
Называется сплей.
И через нее все выражается.
И мерч, и спли.
Все через сплей выражается.
Вот.
Окей.
Здесь даже определение сложно написать,
потому что просто дерево поиска обычное.
Здесь совсем все просто.
Давайте скажем, что такое сплей.
Сплей
от x
сделай
x корнем
путем
комбинации
поворотов.
У сплей всего три вида поворотов.
Называются они не очень
лицеприятно.
Надеюсь, YouTube нас не забанит.
Поэтому просто напишу их название.
Вот.
Собственно, их три штуки.
Как вы можете видеть, они
состоят из двух слогов разных.
Вот.
Что?
Абсолютно так, как написано.
Прям плохо видно?
Ну, Z, I, J.
З, A, J.
Там, не знаю, просто оставляйте варианты.
Вот.
Окей.
Соответственно,
что теперь?
Давайте рассмотрим просто,
как они все выглядят.
И первый случай,
когда мы будем
и первый случай,
это вот этот прекрасный товарищ.
Что?
Три вида.
Вот.
И первый это
товарищ Фрейд.
Вот.
Что?
Это R.
Рут. Это корень.
На первой партии
он свободное место есть.
Ну, не то чтобы это много
времени займет.
Окей, хорошо, я буду рисовать еще крупнее.
Но это уже
останется изменение, к сожалению.
Вот что делает Зиг?
Он делает, что у вас, когда вам остается
лишь один шаг до победы,
он делает поворот
вдоль этого ребра.
Достаточно крупно?
Слишком хорошо видно.
Ну, есть симметричный ему
и это наоборот,
если вы находитесь справа,
то как бы можно делать Зиг влево,
можно делать Зиг вправо, как вам удобнее.
Нет, мы не будем изобретать
AVL дерево.
Мы вообще сейчас себе ничего не будем гарантировать
на высоту.
Как бы это дерево, оно, ну не знаю,
оно очень похоже
на студента, оно вообще ничего не делает,
только иногда
что-то там себя проворачивает,
совсем надо.
Вот. Типа, если вызовете сплэн,
так что бы что-то сделать, значит вообще делать ничего не будет.
Следующий чувак это
удвоенный Зиг.
Ситуация какая?
Вот у вас есть ваш дедушка,
у него есть ребенок в виде
вашего отца.
И есть вы,
давайте раздолбай.
Вот.
Есть у них тут под деревья какие-то свои.
Д.
С.
Д.
Что делает
товарищ Зиг?
Он делает два поворота.
Раз.
Два.
Два Зига, вау.
Собственно, почему это?
Когда это происходит?
Это происходит, когда у вас вы,
ваш отец и ваш дед
как бы на одной прямой находитесь.
Вот.
Тут тоже можно много про что шутить, я не стану.
Додумывайте сами.
Как это происходит?
Ну, промежуточная
стадия такая, что у вас есть X,
у него есть бывший дед,
теперь отец.
Его отец
становится сыном.
Какая ирония.
А.
Ну и дальше теперь мы
занимаем место деда.
Выполняем второй поворот.
Вроде бы так, да?
Как нам занять место деда так, чтобы никто не был против?
Будто бы X.
Ну, X станет корнем, это понятно.
Кто был
от него справа?
А, ну понятно.
Здесь станет дед.
Отец станет здесь.
Будто бы здесь будет D.
Здесь будет A.
Здесь будет B.
Здесь будет C.
Вот это товарищ Зиг-Зиг.
Мы заняли место деда.
Вот.
Ну, есть еще один
последний чувак, это
Зиг-Заг.
Он выполняется, когда
скажем так, вы с отцом
и дедом образуете угол.
Что тогда
происходит?
Ну, происходит абсолютно
все то же самое.
Вообще ничего не
меняется, на самом деле.
То есть, сначала, после первого
поворота, ну, дед
все еще на недосягаемых высотах
со своим правым
поворотом.
То есть, в первом повороте
он все еще на недосягаемых высотах.
То есть, в первом повороте
он все еще на недосягаемых высотах
со своим правым под деревом.
Но вы уже выше.
П, здесь
А, здесь
B и здесь
C. И выполняется поворот
до летового ребра.
Вы заняли вершину мира.
У вас справа дед, слева
отец.
Вот три вида
поворотов.
Собственно, сплей от
X внезапно.
Это применяй
повороты, пока не стал корнем.
В зависимости от того, какой тебе нужен.
Либо зиг-зиг, либо зиг-заг.
В зависимости от того, как ты там с имя
отцами, дедами, прадедами
находишься в каких-то
соотношениях. Вот.
И если вдруг тебе остался один шаг до корня,
то так уж и быть, сделай один раз зиг
и захвати власть.
Вот. Стань корнем в дереве.
Непринципиально
вообще.
Ну, авторы
решили, что более подходит
другое слово для однозначного поворота.
Я не знаю
почему, честно говоря.
Нет, нет, нет. Это не в этом
прикол.
Скажем так, зиг – это просто поворот.
Один.
Зиг-зиг – это двойной поворот, а зиг-заг – это
надо было как-то же назвать для третьего случая.
Я думаю, там Локи, например, такая
была.
Ну, в плане, их специально
так называют. Это нужно их вводить специально
для анализа.
Да, для заказательства.
Для кода достаточно знать, что есть
все. И вы вот там как-то им
крутите свое дерево.
Вообще, вот эти вот
зиг-зиг-зиг-заг, они нужны
в следующую теорему, которую мы доказывать
не будем.
Что?
Да.
Ну, симметричных
надо сделать, да. Ну, понятно, что я
рисовал только в одну сторону, а если симметричные?
Собственно, про что
эта теорем прекрасная?
Теорема гласит следующее.
А высоте?
Не так.
Не так. Немножко не высоте, а
о, времени с плей.
Вот как вы думаете, за сколько
делается операция с плей?
Почему, Логориф, у вас дерево бомбу к Машту родится?
Что?
Как понесли такое
аж?
Да, внезапно.
Это вообще не очевидно,
на самом деле.
Ну, вот у нас было это
на лекциях раньше.
Ну, у средняя по набору операции,
если вы вызовете кучу раз с плей,
то у вас вероятно, что в среднем
за QLogin
они отработают.
Ну, конечно.
Ну, как бы плохие деревья,
плохие времена.
Хорошие деревья, хорошие времена.
Все хорошо.
То есть в среднем дерево
хорошее получается.
Но, понятное дело, что можно привести
операцию в последовательность с плейов, которые будут
работать очень долго.
Ну, вы этим на семинаре
будете заниматься вообще.
Пытаться ломать с плей дерево.
Окей, немножко
о том, как реализована операция.
Зачем вообще сплей нужен, на самом деле?
Вообще непонятно, зачем мы делаем сплей,
потому что это амортизированный логариф,
что хуже, чем обычные деревья,
которые мы с вами прошли.
Но сплей — это такая интересная особенность,
что...
Ну, давайте посмотрим на практике вообще,
когда вы используете деревья поиска.
Чтобы там что-то найти, вставить или удалить, да?
Предположим, у вас есть там какой-нибудь сайт ваш,
там есть login, ну,
и там есть пользователи.
И вы храните там какие-нибудь там
логин и пароли, не знаю.
Вот, их можно хранить в хэш-таблице.
Не знаю, что это такое, но можно.
Можно хранить массивы, просто ходить, бегать по массиву
и смотреть, правда ли, что подходит?
Вот. Можно хранить дерево поиска.
И, как бы казалось бы,
если у вас какой-то содержательный сайт,
то там есть касты людей, которые
часто на сайт заходят,
а есть касты людей, которые
редко на сайт заходят, да?
И, как бы, получается,
что вам по-хорошему
элементы, на которые часто обращаются,
чтобы они находились повыше.
Собственно, это сплей делает.
Там find работает следующим образом.
Раздаваете find как в дерево поиска,
и дальше от него сплей этого элемента вызываете,
чтобы его в корень поднять.
И, поэтому, если у вас какое-то очень малое количество людей,
которые постоянно,
то есть очень малое количество уникальных
запросов постоянно делается,
то сплей будет работать очень быстро
на них.
Нужна сгубина будет небольшая
для этих элементов.
И, конечно, понятное дело, вам придется
ходить туда, на дно,
за редкими пользователями.
Вот мотивация сплей-дерево.
Я не знаю такого.
Мне кажется, что нет,
если честно.
Потому что у сплея
есть еще много
сплея такая штука, что
мы с ним вот так
буквально почти разобрались,
но там очень много теоремий,
в том числе теоретико-информационных.
Есть такая штука теории информации,
которая оценивает, сколько вам информации надо узнать,
чтобы найти элемент какой-нибудь, например,
деревья или что-нибудь такое.
Оказывается, что сплей это оптимально.
Но мы этого не будем делать,
потому что мы
все-таки,
скажем так, еще жить хотим.
Давайте подумаем, как выражать операцию
через сплей.
Ну, файн понятно.
Ищем, плюс сплей.
Как делать инсерт?
Ну, чтобы элемент поднять в корень.
Так, нет, это не круто.
Мы же хотим его еще вверх поднимать.
Но мы же популярные должны вверх
как-то закидывать.
Вот.
Как делать инсерт, по-вашему?
Так, мы выучим динарно в дереве,
если его упасть, я скажу.
Здравствуйте.
Если элементик меньше, то идем в левый,
если больше, то идем в правый.
Как в обычных, да.
У нас же дерево поиска.
Прикроем.
Что?
У нас дерево поиска.
Конечно, да.
Теперь мы будем делать сплей.
Значит, у нас все операции будут
заканчиваться сплеем, если что.
Да.
Ну, удаление давайте.
А от кого сплей-то дергать?
От него не будешь играть.
Вот нет.
Давайте сделаем мерч сначала.
Как сделать мерч?
Как мерч?
Как мерч-то сделать?
Вот у вас два дерева, от кого вы сплей будете вызывать?
Наивное.
Выбрать случайный элемент.
И сплеить можно же.
Все равно в среднем быстро работает, да?
Это уже похоже на правду.
Это сплей от T1.max.
Что будет особенность T1
после вот такого сплея?
Не так, что у вас есть вот этот ваш T1.max.
И у вас правой ребенка нет.
У вас все слева будет.
Да.
Все.
T1 и T2.
Это деревья.
Но мы искренне верим.
Опять же, везде мерч.
T1 точка ключи.
Меньше, чем T2 точка ключи.
Нет, за виду, вот такое соотношение на них, конечно.
Как в Декартовом дерево было, например.
Вот у вас есть дерево.
Вы засплеили его максимальный элемент.
Значит, он стал корнем.
Было корректно.
Да. А так что некорректное, что ли, будет?
В смысле? Нет.
У вас изначально какой-то дерево, у которого
есть какие-то элементы, здесь какие-то элементы.
Максимум где лежит?
Максимум где-то здесь лежит.
Вот вы путем сплея подняли его вверх.
И превратили это в
дерево без правого сына.
А его правое место
вместо правого сына занимает T2.
Все.
Мерч от двух детей
вызывается.
Все.
T2 подвесили ее
правым сыном.
Зачем?
Не может быть.
У вас условия на ключи, видите?
Нет.
Нет, смотрите, если у вас нет
этого соотношения, все, что вы говорите,
это будет фигня полная.
Так не получится сделать.
А так получится.
Ну что, если ты подсинешь сюда T2, ты ничего не сломаешь.
Нет.
Вершины T1 меньше, чем все вершины T2.
Максимум из T1.
Которые все равно будут меньше, чем
любой из T2 по этому счету.
Стоп, я как-то так понял.
То есть мы вместо того, чтобы нарисовать
сначала T1 и T2, нарисовать T2 и T1
вот на самом низу нарисованного?
Нет.
Это вообще просто дерево какое-то абстрактное.
Абстрактное, то есть
стоит у него T2, стоит у него T1?
Здесь?
Ничего.
Вот жила T1 прекрасная.
Давайте я нарисую побольше.
Вот жила T1 прекрасная.
У него был какой-то самый правый чувак.
T1 максимум, больше нет.
И жил был T2.
Жил себе в ус не дул.
Случилось страшно, их надо смёрзнуть зачем-то.
Вы берете и делаете сплей отсюда.
То есть поднимаете именно в T1 этот элемент наверх.
Вот у вас ваш T1 точка максимум.
И вот все остальное.
T1 штрих.
Ну это, который без максимума, если его бы означать.
Все это T1 будет.
И вот ваш T2.
У которого все ключи больше,
чем вот этот вот чувак.
Теперь мы берем и делаем так вот.
Все. Мерш окончен.
Ну мы умеем вызывать мерш,
у кого-то таких вот чуваков.
Нет.
Это два разных дерева.
Вообще разных, никак не связанных.
Что?
Ну, ищем X.
Плюс сплайт X.
Вот он есть.
Еще раз.
Вам нужно, чтобы элементы, которые вы запрашивали,
они были вверху.
Ну прям, вы хотите как можно выше отправить,
чтобы, потому что есть тенденция,
что уникальных запросов
Find будет мало.
Это жизнь
такова.
Вот. И вы это делаете с помощью
сплей. Поднимаете вверх,
и от него меньше спускаться надо было.
Ну будто бы да.
Ну да, каждый раз новый царь горы.
Побеждает тот, кого вы последним спросили.
Что? Да.
T1, это T2.
Фух.
Сплит.
Если вы сделаете
сплей от X,
давайте сделаем сплей от lower bound
от X. Сплей от
наибольшего элемента,
это наименьшего элемента,
больше либо равный данного.
Ну как искать всякие lower bounds,
вы должны были обсуждать на семинарах.
Если вы на них не ходите, то
да.
Это понятно, что вы пишете идею.
Вы должны еще такими штуками заниматься по-хорошему.
Вот если вы делаете сплей от lower bound от X,
это значит, что у вас влево,
то есть у вас что будет здесь?
У вас будет ситуация, что здесь будто бы
X, ну или что-то очень похоже на X.
Здесь все меньше X.
Здесь все больше X.
Ну и здесь есть то,
куда вы хотите отправить X,
вы либо делаете вот так вот разрез,
ну либо вот так вот разрез.
Все.
Да.
Что?
Ну если есть X, то это будет lower bound
от X до X.
Lower bound от X это
наименьший элемент,
больше либо равный, чем X.
Если X нет, то он будет lower bound стоять.
Не очень важно, что он стоит.
Здесь есть то, куда вы хотите отправить
элемент равный X.
Хотите вправо, будете вправо.
Может быть, да.
Тогда он вправо уйдет, дерево.
Окей.
Как хотите, так и делайте.
Здесь свобододействие.
Если бы не по X, то,.
Ну хочу.
Ну бывает такое в жизни огорчение,
что мне хочется сделать split
по отсутствующему элементу.
Ну я хочу построить дерево
меньших и дерево больших.
Почему нет?
Я делаю надрез вот так вот.
То есть у меня это одно дерево,
это другое дерево.
И я его не удаляю.
Чего я хотел-то написать?
Ну это плюс X.
Я не знаю, что такое X.
Короче, ладно.
Плюс, разрез.
Доль.
Ребра.
И скорня.
Позовем это так.
Ну теперь пора сделать.
И рейс, наконец-то.
Как и рейс сделать?
Сделаем find.x
и merge детей.
Если X был.
Все, победа.
Все, победа.
То есть видите, у вас здесь каждая операция
занимает какое-то константное число вызовов в сплее.
Чего?
Client включает в себя сплей.
Вот у тебя есть левый ребенок, есть правый.
Ну я понял.
На семинарах вы не присутствовали.
Окей.
Значит, семинарист плохой.
Так, определение.
Что такое lower bound?
Lower bound
ловер
баунд
баунд
от X
это
наименьший элемент
больше либо равный X.
Ну, не обязательно.
Он может находиться...
Может быть X это лист, где-то наименьший
элемент, который больше него, где-то там вообще в другом
поддереве.
Ну это конечно.
Но X у вас далеко не в корде. Вы хотите сначала ловер баунд найти,
потом сплей от него вызвать.
Вот upper bound и lower bound
вы должны были на семинаре реализовывать.
Если нет, то
настоятельно попросите семинаристов это сделать.
Если они отказываются,
то жалуйтесь в чатке, не знаю.
Так, ну окей.
У нас остается две минуты как раз таки.
В целом
мне больше нечего вам рассказывать.
Что?
Не-не-не, его не будет.
Все, мы про деревьев позже закончили.
Что?
Дальше будет разреженная таблица,
фенвик, дерево, отрезков
и деревья по неявным ключам.
Так, есть ли еще вопрос?
