Ладно, всех поздравляю с началом очередного модуля контрольного. Вы написали плохо,
к сожалению. Она еще до конца не проверена, я один проверяю. Так, ну а тема вообще этого
модуля, это уже последняя часть окоса, которая формально выходит за рамки курса по окосу,
поскольку тут не будет уже больше никакой архитектуры, про операционную систему будет тоже очень мало,
в основном про всякие прикладные промышленные вещи, что можно делать поверх UNIX-системы и как
это использовать программную культу. И начнем мы модуль с разделяемых библиотек. Что такое разделяемые
библиотеки? Это важная часть любой UNIX-подобной системы, то есть есть ядро. Ядро выполняет какие-то
системные вызовы. Системные вызовы делают к ядру обычные приложения, но если вы будете делать каждую
отдельную программу, писать полностью для взаимодействия с ядром, вы замучаетесь и непонятно,
зачем это нужно. Все-таки при реализации любого софта нужно иметь, реализовать какую-то осмысленную
логику, а не бодаться низкоуровневыми вещами. Большая часть реализована в каких-то библиотеках,
которые можно использовать и радоваться жизни. Что такое разделяемые библиотеки, если мы говорим
про стандартный для вас язык программирования C++, либо для языка C, либо для других компилируемых
языков, это просто некоторый набор исполняемых модулей. Когда вы компилируете любую программу,
вы получаете сначала некоторый бинарный файл, который в UNIX-системе заканчивается на точку
Windows, обычно точка OBSH, если Visual Studio, который содержит уже скомпилированный код, который пока
еще не готов к выполнению. Дальше можно взять все эти бинарные модули, запаковать в архив,
добавить к нему индекс и получим какую-то библиотеку. Раньше так и делали, сейчас практически этим
способом никто не пользуется, это называется статическая библиотека. Не очень удобно, потому что
в конечном итоге у вас все равно все объектные файлы на стадии линковки попадают в исполняемые
файлы, с которыми они линкуются и никакой экономии места, экономии совместного использования памяти
у нас не происходит. Современный способ это все-таки разделяемые библиотеки или shared libraries,
фактически это самые обычные L-файлы точно так же, как и исполняемые файлы программы. Есть некоторые
отличия от настоящих исполняемых файлов в том, что у них не прописана точка входа, но зато есть
таблица экспортируемых символов, по которым можно найти какие-то определенные функции. Любая
программа самая тривиальная, если конечно она не написана на assembler, использует как минимум одну
библиотеку под названием libc. Может быть библиотека libc++, может быть стандартная
математическая библиотека libm и еще куча разных дополнительных библиотек. Где ищутся библиотеки и
кем это происходит? Когда вы запускаете программу, которая подразумевает используемый разделяемый
библиотек, то запускается на самом деле сначала маленькая программа под названием интерпретатор
ld.so, либо какие-то разные варианты названия этого файла в разных дистрибутивах. Что делает эта
программка? Она читает заголовок lfile программы, строит дерево зависимости от библиотек и сначала
загружает все библиотеки и программу, после этого уже передает управление самой программе. Где ищет
эта программа библиотеки? В каком порядке? Во-первых, в заголовках lfile могут быть
прописаны относительные либо абсолютные пути до каких-то файлов, которые нужно загрузить. Во-вторых,
есть стандартные конфигурации для разных дистрибутивов. Есть текстовый файл gtcld.so.conf,
который в свою очередь содержит загрузку еще каких-то других текстовых файлов,
все это можно посмотреть. И там просто перечислены каталоги, где нужно искать файлы библиотек,
если не указано путь к конкретному файлу. Затем идет поиск в переменной окружении ld library pass,
и если библиотека найдена, все успешно, если нет, ну получаем ошибку, что программу невозможно
запустить. Есть еще переменная окружения под названием ld preload, куда можно прописать явные
названия некоторых файлов с библиотеками. В чем смысл этой переменной окружения? Те библиотеки,
которые там перечислены, они загружаются в первую очередь и имеют самый высокий приоритет. Для чего
это нужно? Нужно это для того, чтобы переопределить какие-то функции в библиотеках, для которых нет
исходных текстов, либо нужно по каким-то причинам использовать стандартные библиотеки. Обычно
используется в линукс-дистрибутивах для того, чтобы исправить поведение, сделать более тесную
интеграцию для какого-то софта без исходных текстов. Итак, насчет поиска библиотек. В принципе,
я сегодня общался с Павлом Охтямовым, он сказал, что вам все это рассказывал, поэтому я просто немного
напоминаю. Можно закодировать путь до используемых библиотек в сам файл, в сам исполняемый файл,
который библиотеки используют. Для этого в соответствующей секции l файла, раньше они назывались
DT подчерканья pass, в современных линковщиках используется run pass, прописывается текст,
где искать какие-то файлы с библиотеками. И если при линковке вы указываете параметр R pass,
то этот каталог будет использоваться для поиска библиотек в дополнение к тем, которые используются
для стандартного поиска, то есть переменные ld library pass и файлы etcconfig. В чем особенность
содержимого этой секции? Там можно использовать специальные тексты подстановки, которые начинаются
символа доллар, которые позволяют прописывать разные шаблонные параметры, которые будут
использованы уже именно при запуске программы, а не жестко вкомпилированные. Обычно используют только
одна из них под названием dollar origin. Это размещение текущего исполняемого файла,
в каком каталоге он находится. В некоторых случаях можно еще использовать загрузку библиотека относительно
текущего каталога. Если, например, говорить про систему windows, в которой тоже есть библиотеки,
есть дллки. В windows обычно библиотеки ищутся рядом с программой, не так как в linux, и можно
симитировать поведение, то есть положить библиотеки либо рядом с исполняемым файлом, либо на уровень
выше в какой-нибудь подкаталог lib, ну и так далее. То есть может состоять какое-то имя и дальше по этому
произвольному имени найти какой-то файл. Ну а как можно загружовать, использовать библиотеки?
Некоторые тривиальные примеры. Так, видно ли что-нибудь на экране? Совсем плохо, да? Ладно,
я постараюсь проговаривать словами основные моменты. Итак, мы можем программу разбить на какую-то
библиотеку, но если крупнее делать, то не все влазит в том-то и проблема. Итак, у нас может быть
какая-то функция, реализованная в отдельной библиотеке. Вопрос первый, как библиотеку
скомпилировать? GCC либо Selang, смотря что вам больше нравится, если указать опцию shared,
то при линковке будет генерироваться не исполняемый файл, будет генерироваться именно библиотека. Дальше
минус O, и можно указать имя файла, моя великая библиотека. Обычной библиотеки в линукс начинается
с префикса lib, это действие по умолчанию, и заканчивается на фикс.so. Так, ну и соответственно,
файл или файлы, из которых библиотека собирается, и кто помнит содержимое прошлого
семестра, что еще необходимо библиотекам? Позиционно независимый исполняемый код.
Вот опция минус fpig говорит компилятору, что при генерации машинного кода нужно следовать
правилам позиционно независимого кода, поскольку библиотека в общем случае может быть размещена
в произвольной части виртуального адресного пространства. Так, все, вот у нас появился файл lib
migrate library resso, прямо в точности как было сказано с опцией минус O. Так, ну и теперь есть некоторая
программа, которая эту библиотеку использует. Как использовать библиотеку? Нужно для компиляции
юнита текущего, то есть исполняемого файла программ C, знать, какая сигнатура у функции, то есть это
можно сделать либо подключением внешнего заголовочного файла, либо явно ее прописать. И дальше,
если мы попытаемся просто программу скомпилировать из данного исходного файла, мы честно ее доведем
до стадии получения объектного кода, но не сможем слинковать, поскольку undefined reference
to function опция, точнее две опции, минус L маленькая и каноническое имя библиотеки. Соответственно,
mygre, регистр зависима, греат, library будет линковать нашу программу с библиотекой,
которую невозможно найти. А почему невозможно найти? Наверное, потому что этот файл находится
не в одном из путей slash-lib, slash-usr-lib, ну и так далее. То есть не в одном из путей, который является
стандартом для размещения библиотек. При линковке можно указать дополнительную опцию, вот минус L
большой, это дополнительный список каталогов, каждый отдельный опция, это дополнительный каталог,
где искать файл с библиотеками. И все, на выходе мы получаем теперь наконец-то нашу программу
program. Ну что, давайте ее запустим. Получаем ошибку. Невозможно загрузить библиотеку, нет такого файла
или каталога, но мы же видим, что библиотека здесь есть. Почему такое опять же происходит? Ну,
потому что если посмотреть лдд на нашу программу, а лдд тоже ничего не находит, not found.
Not found, потому что имя библиотеки не является полным либо относительным именем файла. Это
просто какое-то название. И название ищется в одном из стандартных каталогов. Можно, конечно,
дописать переменное окружение, взять, например, текущий каталог. Вот теперь у нас программа
действительно находится, и она может быть запущена. Все хорошо, все замечательно. Но переменные окружения
у нас не всегда бывают проставлены. Опять же, не всегда бывает возможность поменять стандартное
расположение путей. Так, отменяю переменную окружения ld library pass. Теперь моя программа опять
не может быть запущена. Так, ну как можно использовать теперь секцию динамика run pass для того,
чтобы наша программа всегда запускалась, независимо от того, где библиотека находится.
Наша программа находится в некотором каталоге R pass, библиотека находится рядом. И если при
компиляции указать еще вот такую страшную опцию, минус WL запятая, минус R pass запятая,
одинарная кавычка, доллар, regin, slash, еще одинарная кавычка, то теперь все хорошо,
все замечательно. И давайте посмотрим на нашу программу. В нашей программе все хорошо находится,
программа запускается. Я могу создать еще какой-нибудь подкаталог, переместить теперь нашу программу и
нашу библиотеку в этот подкаталог. Попытаться что-то запустить из подкаталога, и все будет
хорошо, замечательно работать, независимо от расположения. Давайте посмотрим внимательно на
то, что это за такая странная магическая опция, на что она влияет. Так, ну поехали. Что означает
опция минус WL? Вам рассказывали раньше? Не помните? Ну рассказывай. Итак, на самом деле здесь есть линковщик
по названиям LD. Можно посмотреть MAN на команду LD. Это исполняемый файл, который вызывается,
в свою очередь, компилятором GCC и имеет кучу опций для того, чтобы собрать из
нескольких объектных файлов что-то полезное исполняемый файл. Обычно вручную его редко кто вызывает,
потому что там требуется прописывать огромное количество опций, которые являются специфичными
для каждого линукс-дистрибутива, и знать их совершенно не обязательно. И для того,
чтобы из компилятора GCC, который является оболочкой поверх LD, передать какую-то дополнительную опцию
в линковщик, используется как раз опция минус WL, а дальше через запятую прописываются дополнительные
опции. То есть минус R pass, это будет отдельная опция минус R pass, а дальше через пробел опция
следующая, которая содержит строчку origin. Почему я, кстати, эту штуку заключил в одинарной кавычке?
Да, потому что все-таки команду GCC я выполняю из интерпретатора bash. С точки зрения синтеза
интерпретатора bash, вот $ и какое-то название означает, что нужно раскрыть переменную с
названием origin, превратить ее в какой-то другой текст, и чтобы этого не происходило, приходится
либо экранировать символ доллара, что некрасиво, либо заключать это в одинарной кавычке. И вот dollar
origin у нас прямо точно попадает в нашу программу. Так, программа уже исчезла, я переместил subdir.
Полезный инструмент для исследования исполняемых файлов e-file в библиотек называется readelf. Там куча
всяких опций, в частности опция "-h", отображает общие заголовки про e-file, то есть мы видим,
что наша программа это 64-битный e-file для архитектуры Arch64, для CBA Unix System 5,
в котором пользуется Linux, есть некоторые n3-поинт, правда, рандомный, потому что это
позиционный независимый код. Так, ну и что еще тут полезного есть? В общем-то здесь все, есть еще
опция "-d", опция "-d", отображает текстовые секции, и вот здесь у нас есть секция под названием run pass,
которая соответствует прямо в точности тому тексту, который передан через опцию линковки run
pass, и затем уже при загрузке этой программы строчка $origin заменяется на каталог, в котором находится
исполняемый файл. Для чего это в целом бывает полезно? В целом это бывает полезно для того, чтобы
сделать какую-то нестандартную произвольную поставку программы, то есть обычно программа в Linux
принято устанавливать через пакетный менеджер apt-get install и поехали. Но не всегда это бывает
возможно. Почему? Потому что для того, чтобы сделать какой-то пакет, вам нужно держать отдельного
человека под названием Montainer, который будет собирать ваши пакеты под разные дистрибутивы,
которых огромное количество, под разные версии дистрибутивов, которых тоже очень много. В общем,
на самом деле достаточно неблагодарная и неприятная работа. Можно поступить проще. Если у вас небольшая
команда вы делать какой-то софт для Linux, вы можете программу один раз вашу скомпилировать,
положить рядом все использования библиотеки, скомпилировать при этом, естественно, с опцией
минус Rpass для того, чтобы все используемые вами библиотеки были доступны в вашей программе.
На самом деле, с одной стороны, это плохо, потому что лучше по возможности использовать библиотеки,
которые поставляются в поставке любого Linux дистрибутива. Во-первых, они автоматически
обновляются, всякие security updates очень быстро накатываются. Если вы делаете свою поставку,
включая все возможные сторонние библиотеки, то вам придется самостоятельно их поддерживать,
обновлять. В то же время, обновление библиотек не всегда бывает полезным, особенно в наших
современных реалиях. Слышали недавно новости всякие, что что-то ломается внезапно, потому что
какой-нибудь автор опенсорсного проекта сделал комит под названием Russian нехорошие буквы,
и что-нибудь в этом духе все начинает внезапно ломаться. Если вы фиксируете версии библиотек,
то, как минимум, вы можете все протестировать и не наступить на какие-то серьезные проблемы.
Поэтому, с одной стороны, полезно держать все библиотеки локально с точки зрения безопасности,
но нужно внимательно отслеживать за тем, чтобы не эксплуатировались какие-то уязвимости.
Если вы все-таки решаете пользоваться системами библиотеками, а для большинства
опенсорсных библиотек все-таки стандарт, то вы можете их дополнительно устанавливать.
Обычно в любых пакетных менеджерах это какие-то пакеты, которые начинаются с букв лип,
дальше название библиотеки, и что содержится в таких пакетах. Пакеты это, как правило,
платформы зависимые, то есть библиотеки для x86 не будут работать на армии наоборот,
содержат вот эти самые SO-файлы, которые разложены в правильных местах. Кроме SO-файлов,
возможно, могут быть какие-то ресурсные файлы, связанные с библиотекой. Таких библиотек очень
много, обычно они являются зависимостими и вставятся в любом случае, даже если вы
делаете поставку системы не под разработчика, а под офисного секретаря. Все равно куча файлов
и пакетов с библиотеками у вас будут установлены. Кроме пакетов непосредственно с библиотеками,
бывают еще пакеты, которые заканчиваются на суффикс минус дев, либо на суффикс минус девел.
Как правило, это пакеты без привязки к конкретной архитектуре, то есть это платформы независимые
файлы. Обычно они содержат заголочные файлы, dotage, dotage, HPP, то есть хидрофайлы, которые
необходимы для того, чтобы компилятор понял, как те библиотеки использовать. И что означает строчка
решетка include какое-то название? Это вопрос. Я услышал правильный ответ, потому что некоторые
студенты говорят, что решетка include означает подключить библиотеку. Вот если я это услышу на
какой-нибудь перездаче, ребят, не обижайтесь, я буду очень злый. Решетка include это просто
включение одного текстового файла в текущую программу. Все, не более того. Подключение библиотеки
это только на стадии линковки явным образом. Для чего нужны хидрофайлы? Для того, чтобы
какую-то стороннюю библиотеку можно было использовать, и компилятор понял, какие сигнатуры
в ней используются. Кроме того, что содержатся хидрофайлы, иногда в библиотеках, особенно в
опенсорсных, содержатся дополнительные описания, например, сведения для компилятора,
где эту библиотеку найти и какие опции компиляции требуются, чтобы эту библиотеку правильно
использовать. Стандартом для практически любого линукс-дистрибутива является команда pkg-config,
потому что она очень простая, и сделать для своей библиотеки маленький коротенький файл с текстом того,
какие у нас используются опции компиляции, это не так сложно. Есть несколько режимов использования,
то есть pkg-config с указанием названия использования библиотеки просто выдает обычным текстом опции
для компилятора, который можете дальше скормить GCC либо Selangu, либо просто проверить,
вернуть код возврата 0 или 1 наличия библиотеки, чтобы в этом могли как-то автоматизировать shell
скрипти либо в make файле, и выдать код диагностическое сообщение о том, что требуется
достановить определенную библиотеку. Где все такие файлы лежат? Давайте рассмотрим на примере
какого-нибудь библиотеки, например, Fuse3. Что такое Fuse? Это у нас будет через несколько лекций позже,
вам эта библиотека понадобится. Итак, у нас есть библиотека libfuse, мы можем опросить опции линковки,
которые требуются, чтобы скомпановать что-то с библиотекой под названием Fuse3. Вот получаем
опцию минус l Fuse3, минус l PisRed, то есть она требует еще библиотеку POSIXThreads. При этом нет опции
минус l, значит файл с библиотекой лежит где-то в стандартном пути. Опять же,
здесь могли быть какие-то дополнительные опции минус l. Cflux – это опции, которые требуются на
стадии компиляции, а не на стадии линковки. Здесь могут содержаться, например, указания о том,
что требуется позиционный независимый код, в современных дистрибутеах он и так по умолчанию
подразумевается, либо дополнительные пути для поиска заголовочных файлов с опцией минус i.
Что-то похожее на CMake. CMake вы, наверное, умеете использовать. Ну и где эти файлы лежат? Обычно
это все раскидано по иерархии. Если это Debian либо Ubuntu, хотя в Ubuntu может отличаться так. Это
называется USRLib. Что у нас есть USRLib? У USRLib есть полный триплет названия системы. Так,
Arch Linux GNU. Дальше pkg.config. И тут куча файлов, которые заканчиваются на .pc. Давайте посмотрим,
что это за файл библиотеки, который мы использовали. Это простой текстовый файл, который указывает,
что все находится в префекте slash usr. Сама библиотека находится там-то. Для Debian это
какое-то стандартное расположение. И вот то, что нужно выдавать компилятору libs. Можно повторно
использовать переменные. И compile.flux. То есть такой очень простенький текстовый файл,
который несложен написать. И он обычно идет в поставке, ну если не всех, но по крайней мере
90 процентов опенсорсных библиотек. Так, для чего вообще нужны вот эти вот все инструменты,
типа pkg.config.si, make и так далее. У вас может быть проект, который состоит из нескольких
исходных файлов, по которому нужно получить в конечном итоге исполняемую программу. Обычно
это делается с помощью утилиты make, которая автоматизирует процесс использовать текстовый
make-файл. Опять же, текстовый make-файл вы писали в прошлом семестре. Когда у вас проект очень
большой, то его поддерживать, используя make-файлы, становится достаточно тяжело. Потому что
появляется огромное количество зависимости, которое нужно вручную поддерживать. И кроме того,
какой самый большой недостаток make-файлов и утилиты make? Вы фактически жестко привязываетесь к
конкретной платформе, потому что у вас может быть разное расположение внешних библиотек,
разное расположение компиляторов, разные compilators. Make-файлы в общем случае не портируемы.
Причем не только между разными операционными системами. Даже между похожими операционными
системами, например, FreeBSD Linux или FreeBSD Mac, у вас могут быть какие-то отличия. Для того,
чтобы как-то нивелировать эти различия и все-таки один раз написать файл, который правильно соберет
вашу программу. Когда-то давным-давно пришли к выводу, что make-файлы, наверное, нужно генерировать
автоматически для каждой целевой платформы. Сначала использовались обычные shell-скрипты,
которые назывались Configure. Если вы что-то собирали open-source, наверняка часто встречали такие
проекты, в которых есть shell-скрипт с названием Configure, который нужно запустить сначала. Он выполняет
проверку, а что у вас есть в системе, создает какие-то рудименты, в частности make-файл.
А следующей стадии это уже запуск утилиты make, который по сгенерированному make-файлу соберет вам
проект. Чем плох Configure-скрипт? Начнем с того, чем он хорош, почему он раньше часто использовался.
Хорош тем, что для его работы требуется только интерпретатор shell. Я не говорю слова bash,
потому что bash, опять же, не самая портируемая штука. Shell есть на любой UNIX-платформе. Достаточно
удобная штука. Но поддерживать shell-скрипты даже, на самом деле Configure-скрипты, они тоже генерируются
автоматически с помощью отдельных инструментов AutoTools. Тоже достаточно замороченно. Поэтому
сейчас практически все проекты упенсорсные постепенно переходят на утилиту по названиям CMake,
с которой вы на первом курсе уже познакомились. Это кроссплодворный инструмент, который по
декларативному описанию проекта умеет генерировать либо make-файл для сборки,
либо какие-то проектные файлы для, например, Visual C или X-кода, которые вы можете в графической
линии открыть и радоваться жизни. И вот с точки зрения поддержки библиотек, в CMake есть разные
уровни поддержки. Слово find package вам знакомо? Молодцы. Есть библиотеки, для которых хорошая
поддержка есть в CMake. Для некоторых обычного опенсорсных библиотек эта поддержка идет в самой
поставке CMake. Это не сторонние модули, достаточно качественно прописанные. Все банально просто.
Find package – такой-то пакет, который присутствует где-то среди стандартных модулях CMake. У вас
сразу определяются все требуемые вам переменные, которые вы можете дальше использовать. Возможно,
какие-то дополнительные функции, макросы. Все хорошо, все замечательно. Самое главное,
что это все одинаково работает на разных платформах. Не только Linux, не только macOS,
но еще и Windows. Наиболее показательный пример – это, например, использование Питона в качестве
библиотек. Для всех очевидно, что Питон на самом деле – это не только интерпретатор,
но еще и библиотека. Если не очевидно, то скоро станет очевидно. Хорошая поддержка наиболее
популярных опенсорс-проектов, в частности, таких как Питон либо OpenSSL. Но все-таки модули
написаны не для всех библиотек. Второй уровень поддержки, чуть хуже по качеству, но при этом
покрывающий значительную часть всего опенсорсного, заключается в том, что можно просто взять и
использовать существующий в ГНО-системах инструмент pkg-config, который я вам только что показал.
Есть мод-пакет в CMake pkg-config, который добавляет новую команду checkmodules, которая, в свою очередь,
ищет описание для pkg-config, которое для ГНО-окружения, как правило, присутствует и создает те же самые
переменные, что и обычные пакеты для CMake, но просто плюс одно дополнительное действие. Где это работает?
Работает, естественно, в Linux, FreeBSD, OpenBSD, в MacOS с некоторыми ограничениями, в частности.
pkg-config не входит в базовую поставку, но если вы маковод и при этом программист либо разработчик,
либо просто айтишник, то, скорее всего, у вас стоит хамбрю, и через хамбрю вы можете поставить все,
что угодно. Обычно это все опенсорсное. И получать окружение близкое к Linux, и все это тоже будет
работать. А вот с Windows уже сложнее, здесь требуется уже полноценная поставка МНГВ с кучей пакетов,
работать будет не всегда. На тот случай, если совсем ничего у вас не опакечено, какая-то
странная библиотека от неизвестного производителя, но для которой вы знаете имя, знаете какие в ней
есть характерные для нее заголовочные файлы. Можно использовать функции Find Library для того,
чтобы найти сам файл с библиотекой. И Find Path для того, чтобы найти, как правило,
это каталоги для заголовочных файлов. И по некоторым хинтам, зная какие-то определенные заголовочные
файлы, которые должны присутствовать в библиотеке, вы можете тоже найти. Но понятно, что здесь уже не такая
тесная поддержка, какие-то дополнительные опции вам придется все равно прописывать вручную. Но не так
много библиотек, которые не покрыты ни модулями CMake, ни текстовыми описаниями для ПКВ консистенции.
Библиотеки могут быть слинкованы на стадии сборки программы. В этом случае подразумевается,
что вот то, что я вам показывал, вывод. Давайте глянем на библиотеку. Так, вот у нас был собран
файлик с программой. Смотрим на заголовки динамической секции Read Elf-D. Вот есть текст под
названием Run Pass, который прописывает в лабирее дополнительный поиск. И есть еще строчки
Read Ed. Это какие библиотеки требуются до загрузки программы. И все эти записи, они появляются на
стадии сборки проекта. При этом вы жестко привязаны к тому, что вы какую-то библиотеку должны
использовать. На самом деле, это не единственный способ, как можно загрузить библиотеку. Библиотеки
можно загружать в том числе и после загрузки программы. Для чего это может понадобиться? Для того,
чтобы выполнить какой-то произвольный код, про который вы не могли предполагать на стадии сборки.
Как это сделать? Просто создаем с помощью мап какую-то часть виртуального адресного пространства,
которая помечена как исполняемая. После этого загружаем туда код либо эту часть адресного
пространства мэпим на какой-то существующий файл. Все. Дальше у вас есть начало в виртуальном
адресном пространстве, какой-то указатель. Объявляете typedef на функцию и запускаете как
обычную функцию и радуетесь жизни. Обычный такой подход используется на самом деле для just in time
компиляции, когда вы код какой-то генерируете на лету и затем хотите его исполнять. Почему нельзя
так взять просто с помощью мапа подключить файл с библиотекой? Потому что файл с библиотекой это
на самом деле достаточно сложная штука, которая подразумевает, что вам нужно код загрузить,
найти все еще зависимые библиотеки, аккуратно разобраться с тем, что является переменными,
что является функцией, прописать нужные ссылки, то есть долинковать. Но в некоторых простых
ситуациях можно обойтись и самым обычным простым ммапом. Так, ну простой пример, где можно
использовать ммап для простой загрузки библиотеки, это использовать какую-нибудь очень простую
функцию, которая с одной стороны не использует никакие другие функции, с другой стороны не
использует никакие данные из, например, секции констант. Пример такой функции, это функция,
которая вычисляет значение f-32 умножить на 5 деление на 9, проще некуда. Давайте этот код скомпилируем
и извлечем настоящий код, который мы дальше можем подгрузить с помощью ммап. Так, ну для
компиляции, так, здесь мне нужна только компиляция, это простая функция, никакой линковки не требуется,
поэтому flag-C. Естественно, позиционно независимый код, если мы хотим использовать его в произвольном
месте. Так, название файла пусть будет не суть важна, пусть будет автоматически, и вот у нас есть
некоторый код. Компиляция, но не доведенная до стадии линковки, создает нам файл, который заканчиваем
от .o и с помощью телета ObjDump мы теперь можем посмотреть, что в этом файле содержится. Таблица
символов, которые содержит. Символ Fargain to Celsius мы можем посмотреть на код. Код достаточно короткий,
всего 34 инструкции, размером 4 байта каждая, и по сути нам из этого файла нужно извлечь вот этот
вот бинарный код, то есть последность данных D0083FF и заканчивается оно должно на 0.3.0. Все, достаточно
извлечь вот этот маленький кусочек, загрузить в нужную часть памяти, взять указатель на вот этот
байт с содержимым D1 и начать его выполнять. Все будет хорошо, все замечательно. Как-то, кстати,
много получилось, вроде простая функция. Так, OS, эксперимент. Это он жестко оптимизировал,
ну ладно. Можно поразвлекаться с разными опциями компиляции, посмотреть, что у нас тут,
да, любая оптимизация. А, я слово Extern не написал, поэтому выкинул, понятно. Так, ладно, можно
поразвлекаться с опциями оптимизации, чтобы делать код компактнее, но в принципе 34 инструкции
по 4 байта каждая, это не так много. Так, точнее 34 даже меньше, это 16-личная запись. Так, ну ладно,
вот у нас есть какой-то файл, давайте мы этот файл теперь как-нибудь загрузим и выполним. Для
этого будем использовать обычный MAP, вот вся программа, которая это делает. Так, не обращаю
внимания на загрузочные файлы, то есть мы хотим запустить некоторую функцию, которая принимает double,
возвращает double. Соответственно нам нужно получить адрес этой функции, сделать каст указателю на
функции и дальше эту функцию после каста просто взять и выполнить. Так, ну а получить указатель
начала функции можем следующим образом. Мы должны загрузить какой-то файл, либо сразу
взаимапить, обязательно указать protExec, что вообще означает protRead или protExec,
это означает, что у вас памяти доступно для чтения и для выполнения. Соответственно
получаем функцию и эту функцию просто выполняем. Так, ну а что мы туда должны загрузить, что означает
выполнить какой-то код? Наша функция должна содержать не начало вот этого файла, она должна
содержать что-то, что начинается с байта D10083FF. Как отсюда это все извлечь? У нас есть объектный
файл, который получен компилятором, а мы хотим вытащить только этот код. Я вам это уже показывал на
лекциях, хотя бы на звание команды. Что? ObjCopy. ObjCopy это команда для манипуляции объектными файлами,
если вы посмотрите man, либо help, он будет огромный, там куча всяких возможностей, которые не факт,
что вам понадобится. Итак, самые основные опции, которые понадобятся нам для того, чтобы что-то
отсюда извлечь. Minus j мы хотим взять только определенную секцию, которая называется точка текста.
Это, кстати, ограничение, почему через мап трудно загружать какой-то исполняемый код,
потому что есть еще куча других полезных секций и надо с ними тоже что-то делать. Так,
минус O большое, это формат, в который нужно сконвертировать, прикопировать. И форматы,
тут всякие разные, supported targets, меня интересует формат, который называется binary, это просто
plain binary без всяких заморочек. Имя исходного файла объектного и имя файла, в котором мы хотим
что-то записать, пусть будет функция B. Так, получаем файл, который имеет размер 56 байт. Похоже
это на правду или не похоже, это мы можем выяснить, если посмотрим. Раз, два, три, четыре, пять, шесть,
семь, восемь, девять, десять, одиннадцать, тринадцать, четырнадцать строк. Кто в голове быстро умножает?
56, ладно. Действительно, 56 байт, можно еще посмотреть hexdump этой функции. Так,
начинается с... hexdump вредная, конечно, команда, она делает реверс. Так, D1, 0, 0, 8, 3, F, F. Ну да,
похоже на правду. Так, заканчивается все на D6, 5F, 0, 3, C0. Да, вот, это только содержимое нашей
исполневой функции. Ну окей, теперь, что там требовалось? Так, первый аргумент это имя файла.
А, еще надо скомпилировать это все. Так, компилируем, запускаем теперь наш код. Скоро мы первый аргумент
это имя файла с функции, второй аргумент это аргумент нашей функции, что-то типа 100, и получаем
значение функции. А функцией, напомню, исходно была вот такая F-32, и, соответственно, если мы
запустим эту функцию с аргументом 451, мы получим 232. Никому эти цифры ни о чем не говорят. У кого в
школе был кумир? О, одного человека был. Помните, там был робот такой. Так вот, у робота была штуковина
измерить температуру. И если вы пытались измерить температуру больше чем 232, у вас программа ломалась.
Как вы думаете, почему? Потому что в таких условиях роботы не живут. Это сделано из
педагогических соображений. Что это вообще за числа такие 451? 451 градус по Фаренге,
то она же 232 градуса по Цельсию. Это температура, когда воспламеняется бумага. Ну и, соответственно,
если бумага горит, то можно считать, что жизнь уже закончилась. Так, ладно, мы загрузили что-то
через МАП. Почему мы это смогли сделать? Во-первых, у нас тут только одна функция. Функции, на самом деле,
может быть, несколько. И тогда придется уже аккуратно разбираться адрес начала каждой конкретной
функции. Для этого нужна таблица символов. У нас может быть несколько секций, а не только секция
с кодом. И вообще много всего остального. Поэтому в реальной жизни с МАП можно поразвлекаться. Но самое
главное, почему про это нужно знать. Потому что МАП — это некоторый базовый инструмент, но на самом
деле в реальной жизни он не используется. Но зато позволяет не делать никакие новые системные вызовы
для того, чтобы делать динамическую загрузку библиотека. В реальной жизни в POSIX API есть две функции,
точнее, три. DLopen и DLC, которые загружают какие-то исполняемые модули, в частности библиотеки,
и позволяют находить в них отдельные символы, таблицы символов, то есть указатели на функции.
Почему это сделано в виде именно библиотечных функций, а не системных вызовов? Потому что,
по сути, здесь не надо постоянно лазить в ядро. От ядра нам требуется только открытие файла и
только МАП. Я вам уже показал, как используется МАП, и в рантайме нужно загрузить файл,
дальше его аккуратно распарсить. На самом деле, опять же, в библиотеке DL это делается не вручную,
есть другие сторонние библиотеки, которые парсят L-файлы, и в конечном итоге мы можем открыть
библиотеку, и в открытой библиотеке мы можем найти какой-то символ по имени. Что такое символ?
Это просто название функции в сишном синтаксисе. Есть еще функции на языке C++, есть функции на
языке GoLang, и там немножко сложнее. Чем хорош это API? Он существует, на самом деле, не только в POSIX,
в Windows тоже есть похожие функции, которые ведут себя, на удивление, аналогичным образом,
просто называются по-другому. Что означает название h модуле все большими буквами? Это
просто void звездочка. Что такое LPC str все большими буквами? Это const char звездочка. В Windows,
конечно, немного странный программный интерфейс, к нему надо привыкать, но, на удивление, под Windows
все то же самое будет работать, как и в POSIX, просто немного другими названиями. Ну и как этой
штуковиной теперь можно пользоваться? Я вижу кого-то из 29 группы, у кого вчера был семинар,
поэтому вы сейчас будете скучать и спать. Показываю для всех остальных. Как этим всем пользоваться?
Допустим, ух, можно сделать шифт поменьше, иначе не лазит. Видно? Так, с помощью Daily Open мы открываем
какую-то библиотеку, указывая в качестве обязательного аргумента имя файла. На самом деле,
здесь что может быть под названием библиотеки? Это может быть абсолютное имя файла, это может
быть относительное имя файла, либо просто название библиотеки без пути. В данном случае библиотека
будет найдена под тем же самым правилом, что и библиотека при запуске программы. То есть просматриваются
перемены окружения ld library pass, просматриваются конфиги lds soconf и так далее. После загрузки библиотеки
вы ищете символ с определенным именем, используя dl sim. Что Daily Open, что dl sim возвращает ввод
звездочка, который вы можете прикосновать чему угодно. Ну и в случае успеха вы можете по адресу
функции уже что-то вызвать. Ладно, посмотрим это на практике. Так, ну для линковки здесь под
Linux требуется LDL, под Mac это не требуется. Так, скомпилировали, запускаем. Так, но я поставил
лидия паузы, чтобы можно было исследовать поведение нашей программы, а исследовать мы будем в другой вкладке.
Для этого я выясню процесс ID 660797 и посмотрим на карту памяти для этого процесса.
Ой, ужасно, ничего не видно. Ладно, сделаем тогда вот следующим образом. Нана, насколько я помню,
в прошлый раз выглядела нормально. Нет, выглядит конечно ужасно. Так, ладно, давайте не будем ничего
исследовать. Или я могу сделать просто мелкий шрифт, потом посмотреть в записи.
Вам уже скучно стало. Так, что я хотел показать. Вот вы загрузили библиотеку, что нас ожидается
увидеть в карте памяти. В карте памяти? Ладно, давайте я сделаю все-таки мелкий шрифт,
посмотреть потом в записи. Если ломаете глаза, лучше их закройте. Запустили программу, мы видим
в зависимости, в карте памяти у нас подгружена стандартная сибиблиотека, загружена библиотека
DL, которая содержит реализацию функции DL open и так далее, загрузчик LDSO, стэк, ну все плюс-минус
стандартно. Если у вас система x86, а не ARM, как у меня, то скорее всего с библиотеки будут идти выше,
чем стэк. Они ниже. Так, теперь мы загружаем библиотеку. Она у нас загружена по какому-то адресу,
что у нас при этом поменялось в карте памяти. Так, поменялось то, что у нас появилась какая-то
библиотека, точнее ничего не появилось, это какой-то мусор, потому что я не указал
аргумент командной строки. Так, аргументы, название библиотеки и название функций плюс аргумент.
Так, dipm.iso, функция пусть называется sin и аргумент 0. Ладно, попытка номер два.
Здесь поменялся, естественно, process ID. Так, вот мы запустили, теперь загружаем библиотеку. Вот она
загружена по какому-то адресу. И библиотеку libm мы теперь можем действительно наблюдать. Она загружена,
если x86, то ниже области стека. Почему? Потому что стек у нас уже выделен, какие-то библиотеки у нас
загружены, и где мы можем подгружать новые библиотеки. Очевидно, уже ниже стека. На самом деле,
если используется позиционный независимый код, то это не особо принципиально. Библиотеки
можно загружать абсолютно куда угодно, в совершенно рандомное место. Только вот адреса загрузки у нас
всё-таки немножко отличаются от того, что мы видим в качестве возвращаемого значения
dlopen. Потому что dlopen просто на куче размещает метаинформацию про библиотеку, и это содержимое
никак не связано с содержимым файлов библиотеки. Дальше находим какую-то функцию sin. А вот указатель
на функцию sin, он уже попадает на часть загруженной библиотеки с правами чтения и исполнения. Ну и
честно выполняем функцию sin. Все верят, что sin0 это 0. Аналогичное мы можем сделать для
косинуса. cos0 это единица. 3,14,159. cos3,14,159-1. Вроде тоже похоже на правду.
Ну и зачем вообще это нужно? В языке Python вы пишете импорт. В каком случае происходит
реальный импорт какого-то файла? Вот чем удобен Python вы можете написать огромное количество импортов
в вашей программе, но реально все будет происходить именно в момент выполнения этого кода. Более того,
есть еще импорт лип, который позволяет динамически создавать модули и загружать. Достаточно
гибкая штуковина, потому что вся стандартная библиотека и все сторонние библиотеки совершенно
необязательно вам могут понадобиться сразу. Совершенно необязательно они вам могут понадобиться
когда-нибудь. Они могут понадобиться при каких-то определенных условиях. Еще более
понятный и распространенный пример это система плагинов. Что такое плагин я думаю объяснять не
нужно. Вот как бы вы стали их реализовывать. Очевидно плагин это что-то, что хранится в
отдельном файле, который вы загружаете по мере необходимости, например исходя из какой-то
конфигурации запуска программы, либо по требованию пользователя. Кроме того, у вас могут быть какие-то
нестандартные ситуации про расположение библиотек, в том числе если вы на лету загружаете что-то из
интернета, запускаете, ну потом библиотек возможно удаляете, либо оставляете для работы дальше.
Вот для всех этих ситуаций вам требуется динамическая загрузка уже после выполнения
программы. И для этого как раз используется, на самом деле часто используются всякие
высокоуровневые средства, но в их основе все равно лежат функции dellopen, dellsim,
ну либо в случае с windows это luad library. Тут есть некоторые побочные эффекты, раз уж мы питон
вспомнили, вот что сделает эта программа на питоне. Вы объявляете какую-то функцию, вот чем хороши языки
типа питона. Мы можем обсуждать, чем они плохи, собственно курс о косу этому посвящен, но есть
и положительные моменты, в частности всякие способы выстрелить себе в ногу, залезть в словарь
глобальных имен, что-то в нем натворить, либо просто достать оттуда что-нибудь просто по строковому
литералу. В частности вы можете объявить какую-то функцию, любую переменную, зайти в globals и найти
функцию произвольную, дальше ее выполнить. Можно ли тоже сами сделать на оси или на плюсах? Нельзя, да?
А может можно? Да, вот на самом деле можно. Есть dlopen, dlsim. Так, теперь, как это все-таки можно
сделать на оси и на c++? У dlopen есть одна особенность, под windows, кстати, у luad library тоже, что если вместо
имени укажется нолевой указатель, то здесь это корректная ситуация, и в данном случае возвращается
описание метаинформации для текущего модуля. Текущий модуль имеется в виду текущий lfile. Если это
является программой, то указатель на программу, если вы этот код запускаете из какой-то подлинкованной
библиотеки, то соответственно ссылка на библиотеку, и если у вас есть кайт с библиотекой, который вам
вернуло dlopen, вы можете через dlsim найти какую-то функцию произвольную, просто по ее имени, обычной
конс-чар-звёздочкой, либо std string, и дальше эту функцию вызвать по указателю. То есть все то же
самое, все те же самые динамические возможности интроспекции, как и Python. Ну, почти. Для этого вам
требуется, наверно, чтобы все-таки таблица символов у нас всегда была. Для библиотек таблица символов
это стандартная практика, а вот у исполняемых файлов таблица символов обычно отсутствует. Зачем
таблица символов исполняемому файлу? Тем не менее, если внимательно почитать манн на команду ld,
на линковщик, там можно найти опцию, которая называется либо "-e", либо экспорт-динамик. В описании
написано, что эта опция заставляет линковщик добавлять все символы в экспортированную динамическую
таблицу. Если испортить этот факт, то можно тут нахулиганить и сделать точно такой же способ
поведения, как в Python. Так, ну давайте опять же рассмотрим такой пример. Так,
пример программы. У нас есть две функции. Одна функция называется кошечка, другая функция
называется собачка. Кошечка говорит мяу, пёсель гавкает. Соответственно, можем ли мы,
зная название функций, вызвать какую-то правильную функцию? Ответ да, можем сделать точно так же,
как в Python. Для этого что нам нужно сделать? У нас есть некоторая строка чарная, которая содержит
название функции. Сначала мы получаем доступ к нашему исполняемому файлу с помощью del open,
и самое главное, что аргументом является нулевой указатель. Соответственно, del open возвращает нам
указатель на текущий исполняемый файл, который в свою очередь содержит функции cat и doc. Дальше
находим в этом исполняемом файле нужную нам функцию и спокойно ее выполняем. Казатель,
все хорошо, все будет работать точно так же, как на Python. Ну окей, давайте это все проверим.
Компилируем, запускаем. Вот так вот, любители котиков. Что у нас пошло не так и почему? У нас
нет таблиц символов, поэтому del sim нам честно вернул нулевой указатель, который не обрабатывается,
получаем segmentation fold. Так, ну и как ситуацию исправить? Мы модифицируем опции пенковщика,
заставляем его в наш исполняемый файл добавить все экспортируемые символы точно так же,
как это было бы для библиотек. И вот теперь, так, ну что, песель на этот раз? Песель заработал.
Ну и котик, в принципе, тоже ничем не хуже песеля. Так, ну вот, обратили внимание, что я здесь добавил
опцию –wl, запятая та опция, которую нужно было скормить ливточкой hd, то есть –e. И здесь
напрашивается, кстати, вот такой эффект. Если у нас есть исполняемый файл, который может содержать
таблицу символов, на что это исполняемый файл похож? На чей-то на библиотеку. А если у нас в библиотеке
есть функция под названием подчеркивание start, на что эта библиотека похожа? На исполняемый файл.
То есть, на самом-то деле, кто нам мешает делать какие-то гибридные универсальные l-файлы,
которые ведут себя и как библиотеки, и как обычно исполняемые файлы? Ну, чтобы не полонить лишние файлы,
не полонить лишние сущности. На самом деле достаточно удобно сделать программу,
которую можно использовать с предоставлением некоторого API. Мешает нам вот что. Несколько лет
назад я студентам показывал вот такую опцию командной строки, которая позволяла создать
вот такие гибридные файлы. Но в последних сборках стандартной C-библиотеки эту лавочку прикрыли. На
самом деле это не штатная функциональность. И DL Open теперь просто ругается, что, извините,
вы мне почему-то подсунули исполняемый файл вместо того, чтобы скормить мне библиотеку. Эта штука
перестала работать, и вот такая опция больше, ну все, лавочка не работает. Как же нам все-таки
сделать исполняемый файл, который ведет себя одновременно и как библиотека, и как исполняемый
файл. Возможно ли это все-таки или нет. Но было бы, наверное, удобнее. На самом деле можно. Есть
некоторые хаки. Так, что нам для этого нужно? Для этого нам нужно внимательно почитать MAN на
линковщик LD. Итак, вот у нас есть файл простой. Так, и здесь требуются некоторые нестандартности.
С одной стороны, мы хотим получить библиотеку, которая экспортирует функцию под названием Function,
чтобы можно было эту функцию использовать где-то извне. С другой стороны, нам хотелось бы эту
библиотеку использовать как обычный исполняемый файл. Ладно, давайте мы ее скомпилируем как библиотеку,
то есть собственной shared, какой-то ELF файл, не важно как называется. Так, и сделаем это все из файла
по названиям main.7. На самом деле линкового мейна здесь нет. Так, вот мы получили библиотеку,
файл по названиям ELF, который ведет себя странно, не запускается, явно делает что-то не то. Так,
но тем не менее мы можем теперь запустить наш любимый Python, написать import ctypes,
дальше ctypes.luats library, знакомое название. Это название API Windows, то есть понятно,
кто проектировал этот модуль, любители Windows. Загружаем наш файл по относительному имени,
он даже честно загрузился. У нас там есть функция, которую мы можем найти под названием function,
и эту функцию мы можем запустить. Она говорит, да, я действительно являюсь функцией. То есть на самом
деле как библиотеку мы ее честно скомпилировали, понятно почему, потому что опция shared. Так,
хорошо, давайте теперь еще раз внимательно посмотрим на исходник. Аут 16, это рандом,
который остался от puts. То есть по умолчанию ctypes модуль Python подразумевает, что функция
принимает аргументы типа int, неважно сколько их, и возвращает тоже int. Там у нас был мусор,
который остался от функции puts, но видимо 16 символов, который потом оказался как возвращаемое
значение нашей функции. В Python можно тут еще прописать, откройте документацию на ctypes,
потому что это уже off-top, там есть параметры restype у функций и параметр argtypes, их можно
специализировать, тогда все будет работать. Но по идее на семинарах вас тоже нужно показать. Так,
ладно, давайте вернемся еще раз к нашему исходному коду, в котором я дописал что-то не
стандартное, а именно функцию под названием custom.start, которая является фактически заменой точки
входа. И при компиляции мы можем что-то дописать в секции lfile, в частности есть такая штука,
как точка входа, и кстати точка входа совсем не обязательно может быть именно подчеркивание
start. Для любой программы вы можете переопределить точку входа и получить какой-то исполняемый файл с
нестандартной точкой входа. Как нам только его теперь запустить? Запуститься он уже должен. Так,
запускаем, и за счет чего он работает? Что происходит при запуске библиотеки? Вообще,
при обработке любого lfile. У каждого lfile есть секция, которая называется интерпретатор.
Интерпретатор lfile как-то странно звучит, да? Ну, такая вот терминология. Два подчеркивания
атрибут, два подчеркивания, дальше секция. Во-первых, что означает два подчеркивания атрибу,
два подчеркивания, дальше две скобочки, что-то там, две скобочки закрываются. Это нестандартные
возможности компиляторов GCC и Selang. Ну, насколько нестандартные? Они существуют уже много лет,
и маловероятно, что кто-то их сломает. Атрибут section и в кавычках название секции означает,
в какую секцию исполняемого файла именованную нужно положить ту или иную переменную, либо даже
функцию. Так вот, секция interrupt для lfile. Это entry point 734, это как раз указатель на custom.
Entry point, интерпретатор, это исполняемый файл, который на самом деле явно захардкожен в lfile.
Он является обычно специфичным для каждого линукс-дистрибутива, даже не дистрибутива,
для каждого поколения линукс-дистрибутивов, там плюс-минус несколько лет, и архитектуре
процессора. То есть у вас там, скорее всего, будет x8664, если не Macом 1, не разбери Pi.
То есть что у нас происходит? На самом деле, вот этот интерпретатор, это честно какая-то команда,
которую можно запустить. И эта команда принимает в качестве аргумента исполняемый файл, является
ничем иным, как тем самым ldso, который выполняет поиск всех библиотек, загрузку программы в память
и передачу выполнения. Если вот эту штуку не прописать, то будет непонятно, как библиотеку
запускать. Для библиотек это поле пустое, а для исполняемых файлов не пустое.
Тем самым мы все-таки можем обмануть систему и сделать гибрид, который будет
запускаться и как исполняемый файл, и в том числе мы можем теперь без потери функциональности
использовать его как библиотеку. Давайте уже честно допишу func restypes,
рестypes определю как ctypes. Возвращаемого типа у него нет,
и func archetypes никаких аргументов нет.
Файл себя ведет и как программа, и как обычная библиотека.
Что еще можно вытворять, используя вот эти самые атрибуты?
Синдекс есть еще раз, два подчеркивания, атрибут два подчеркивания, дальше две скобочки,
потом что-то, потом две скобочки. Это вещь вне стандартов языка C и C++, просто устоявшаяся
традиция. Почему именно такие страшные названия? Для того, чтобы случайно не использовать в каких-то
легальных конструкциях, не придумать имя с похожим названием, чтобы случайно на это не наступить.
Поскольку вещи вне стандартов, но при этом поддерживаются как компиляторами C, GC, так и C lang,
есть еще очень полезные атрибуты у разных функций, которые свойственны различным модулям,
в том числе библиотекам. Это конструкторы и деструкторы для исполняемых файлов. Что такое
конструктор? Это штука, на которой выполняется при загрузке модуля. Деструктор, очевидная штука,
выполняется при выгрузке модуля. В том числе эта штука работает с библиотеками. Конструктор
вызывается при попытке загрузить библиотеку. Если происходит успешная загрузка, то сначала
выполняется инициализер, который объявлен на атрибутах конструктор. Когда вы библиотеку выгружаете,
то у вас выполняется функция деструктор. Итак, демонстрация конструктора и деструктора.
Выглядит файл модуля очень простым образом. Есть какая-то функция,
которую можно вызывать сколько угодно раз. Есть конструктор, который выполняется один раз.
Есть деструктор, который может быть либо выполнен, либо не выполнен. Отчего это зависит?
Когда вы пытаетесь закрыть библиотеку, уменьшается количество ссылок на ее использование и библиотека
реально выгружается только тогда, когда больше никакая часть программы эту библиотеку не использует.
Урон в этот момент может быть выполнена какая-то финализация. Компилируем этот модуль.
Надо еще не забывать вот такую опцию, особенно если используются внешние функции.
Модуль скомпилировали. Загружаем мы обычным дель опеном. Примерно, что я вам показывал,
есть функция дель опен для файла, дель сим для имени функции. Название функции мы знаем.
Давайте потом выгрузка с помощью дель close. Скомпилирую теперь раундер.
Функция называлась function. Обратите внимание, что я явным образом не вызываю функции
финализации и финализации. Тем не менее, они у нас будут явным образом все равно вызваны.
Why? Потому что я не указал правильное имя файла. Так, что у нас происходит?
У нас окружается библиотека. После того, как она именно в момент вызова дель опен,
у нас выполняется произвольная функция этой библиотеки, которая помещена атрибутом конструктор.
Дальше можем выполнять какие-то произвольные функции, творить все что угодно.
В тот момент, когда мы делаем выгрузку библиотеки с помощью дель close, у нас вызывается функция,
особенно атрибутом, деструктор. Но не факт, что это у вас в общем случае всегда будет происходить.
Так, слова конструктор, деструктор, они вообще откуда взялись?
Языка C++. И последнее на сегодня, язык C++. На самом деле, я вам показываю примеры на языке C,
который содержит таблицу символ с C-шными именами. Все то же самое будет работать с плюсами.
Тут есть одни маленькие тонкости. В плюсах есть namespaces, там есть классы, всякие перегрузки функций,
много всего остального. Для того, чтобы разрешать всякие разные неоднозначности,
имена в таблице символов кодируются достаточно страшным образом. Подчеркиваем Z, дальше abracadabra.
И в этой abracadabra в принципе можно разглядеть исходные имена namespaces, классов и так далее.
Чем плох такой способ кодирования? Плохом тем, что он является стандартом для GCC, Selang, Intel Compiler.
Все это работает в Unix-подобных системах. Под Windows уже не так все хорошо. Там в MinGV один стиль.
Microsoft имеет совершенно другие представления о том, как нужно кодировать имена.
Вообще в целом никакого единого стандарта на способ именования не существует.
Что-то похожее используется в том числе в языке программирования Rust.
Когда вы компилируете программу на Rust, у вас все функции превращаются в какие-то страшные имена,
которые вообще там хэши содержат. Что-то похожее есть в Go, но там, правда, не так страшно.
В общем, есть разные способы для разных языков программирования, как закодировать имена.
И если вы знаете этот способ, то вы можете смешивать программу на разных языках программирования,
загружать библиотеки откуда угодно.
В том числе вызывать различные конструкты.
И вот на самом деле вся эта история, что я вам показываю в создании генетической загрузки библиотек,
она к плюсам имеет большее применение, чем к языку C.
Потому что использовать на плюсах плагины это более осмысленно.
Вы можете контролировать полный жизненный цикл.
И вы какие-нибудь фреймворками, библиотеками на плюсах пользуетесь?
Или только стандартной C библиотекой в реальной жизни?
Если пользуетесь, но можете порыться в документации ваша любимая фреймворка,
скорее всего вы найдете что-то, что позволяет работать с механизмом плагинов.
Механизм плагинов, по сути, вырождается в DL Open Delsie.
На этом все. Как вы можете заметить, Рудали все хорошо обучается.
И качество рисования картинок все лучше и лучше.
Это вот библиотека.
Красиво получилось.
Да, выкатили, да, но непонятно, будет ли его адаптировать.
Что-то непростая задача.
Ладно, есть ли у вас вопросы?
Ну тогда на сегодня все.
