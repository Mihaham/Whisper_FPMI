ДПИТ на 2 в степени минусы по 2.
С из Н по, видимо, и минус 1.
ДПИТ на 2 в степени минусы по 2.
Нет, С-ка надо.
ДПИТ на 2 в степени минусы по 2.
Так.
Сейчас, не перебивайте, спокойно.
Идея такая, пусть ДПИТ количество связанных графов.
Что такое количество связанных графов?
Это количество всего графов, минус количество несвязанных графов.
В каждом связанном графе есть компоненты связанности, которые содержат вершину номер 1 и все остальные.
Эта компонента содержит и вершин от 1 до N-1.
Вот мы и перебираем.
Мы выбираем ее, то есть что это за вершины.
Вот и минус 1, первая вершина на месте.
Мы выбираем ДПИТ способ сделать ее связанной.
Это должно быть связанной.
И 2 в степени все остальные ребра на всех остальных вершинах.
Вот.
Так.
А теперь осталась только задачка.
А теперь задача.
Упихайте эту формулу.
То есть упихайте эту формулу так, чтобы она считалась не за квадрат.
Вот.
Но, видимо, это уже Денис на лекции рассказывал.
Ну или...
Да.
Ой, а точно цшка нужна вообще, да?
Черт, нужна.
А то просто...
Ну как бы нет, просто возбождаем.
Цшка не из N-1 по N-1.
Да.
Н-1 по N-1.
Хорошо, да, N-1.
Ну и это помогает?
Не сильно, да, неправда.
То есть нет, в общем, просто на халяву сказать, что давайте
рассмотрим производящую функцию ДПИ, заметим уравнение,
пока не помогает.
Ну можно почитать количество, наоборот, не связанных грамм.
Кажется, чуть-чуть упрощаем, все.
Отдаешь один.
Ну да.
Ну да.
Нет, есть, конечно.
Ага.
Нет, ЦСН-1 по...
Нет.
Сильное желание.
Подожди, а как-то не связанная грамма.
Будешь сказать, там же форма меняется.
Там же ДПИ будет другая уже, да?
Да, это правда.
Да.
Я не прав.
Там никакой причины общаться.
Да.
Да.
Нет, может, вы думаете, что все не сильно?
Сходите с ним просить.
Ну так, а больше всего расписать двоечи глажки под суммой.
Нет, тут, видимо, логика такая.
Значит, это N-1 факториал.
Тут мы делим на I-1 факториал.
И тут N-I факториал.
Да?
Поэтому как бы есть идея такая.
Как?
Ну, ЦСН-1.
Факториал может пихать в экспенсионную прозвищу функцию.
Да-да.
Вот непонятно, что делать.
А, нет.
А, смотрите.
Нет, смотрите.
Нет, все круче.
Смотрите.
Запишем равенство таким образом.
ДПН на N-1 факториал равно 2 в степени ЦСН по 2 делить
на N-1 факториал минус сумма по всем И от 1 до N-1.
Значит, ДПИТ будет 0.
ДПИТ делить на I-1 факториал умножить на 2 в степени ЦСН-I
по 2 делить на N-I факториал.
Вот.
Вот.
Так.
Ну, я не знаю, насколько это честное умножение я сейчас
не готов сказать.
А, ну, видимо, надо сказать, что ДП от 0 равно 0, видимо,
для удобства.
Да?
Да.
А ДП от 0 равно 0?
Да.
Ну, то есть, да, давайте, вот это ряд А, а это ряд B.
А это ДП, а это X.
Вот этот ряд X.
Тогда получается, тогда должно получается, вроде как
все более-менее сходится.
Ну, если считать, что ДП от 0 равно 0, да, то есть вот
типа X от 0 равно 0, да, и B от 0 равно 0, кстати, давайте
еще скажем, чтобы удобно было.
Потому что мы так и хотели сказать.
Сколько?
Ну, сколько существует связанных графонов для вершинах?
Ответ.
Черт его знает.
Ну, для N минусы-то он нормальный, потому что хочется записать
вот такое уравнение.
Да, X.
Да, X, нет, у X умножить не может, и вот тут, и тут N
минусы-то, как бы, смотрите, тут перемножается, и тут
перемножается N минусы-то член.
Так что, казалось бы, кайфец.
То есть, я говорю, то есть, надо только, чтобы и у
X и у B, значит, там были, там, как бы, вначале 0-ки,
видимо, для того, чтобы это, как бы, было адекватно.
Ну, чтобы там вот с N-ными членами не было.
Нет, а это просто вот рассмотрим.
Ну, похоже, но не совсем.
Видите, тут N и N минус 1, а тут N минусы и N минусы.
То есть, разница.
Разница есть.
Ну, видимо, B это просто умножить на N, да?
Ну, нет, ну там формально можно говорить, что сейчас,
как бы, что это такое.
Знаете, что это такое?
Нет, а равно B' умножить на X.
Вот можно вот так написать.
Да, а мало кто знает, то формальные ряды можно дифференцировать.
Вот, да.
Ну, просто как убить лишнюю N знаменателя?
Дифференцируем, а потом домножаем обратно на X.
То есть, степень при X остается, а в знаменателе вот лишняя N убивается.
Если мы, короче, поставим сейчас вместо A' на X нас ползет,
что X равен нулю решения.
Ну, X равно...
Почему X равно нулю решения?
Просто она шутка, потому что у нас рядом означает...
Да, да, да.
Ну, в смысле, я понимаю, это просто шутка была.
А, шутка.
Ага, да.
Да, шутка, да.
Ну, вот.
Ну, нет, то-то по...
Ой, замечательно.
Да, 1 плюс B, во.
Все.
Ну, да, вот.
То есть, в сущности, вот.
Ну, да, вот.
То есть, в сущности, гениальный ZD.
Считается, если там еще нужен только для фиксированного N?
Да, маловероятно.
Как мы, кстати, расти получаем?
Последний расти получается просто с первого.
Нет.
Если вам...
Нет, смотря для какого фиксирования.
Нет, если ваша задача посчитать для какого-нибудь N эту штуку,
то как бы...
То как бы да, на самом деле, реально выполнять деление никому не надо, естественно.
Потому что как найти N-ый член вот этой вот формального степенного ряда, да?
Да, нет.
Нет, потому что у нас есть стандартный факт, как выпустить N-ый ряд.
То есть, допустим, у нас есть какой-нибудь такой ряд вида P от X делить на Q от X.
Так, ну, вот.
Ну, вот.
Причем N, допустим, не сильно...
Ну, вот.
Так, ну, вот.
Причем, допустим, допустим, еще и там выясняется, что, допустим, Q может быть там не сильно большое какое-нибудь, да?
Ну, вот.
Ну, желательно, чтобы там Q было не сильно большое.
Просто у нас...
Да, нет, это рассказывал, потому что это нужно было, когда мы линейную рекурренту искали,
но, в принципе, это должен работать и так.
Потому что, в принципе, можно написать вот такую маленькую приятную вещь.
Вот.
Значит, чем это нам помогает?
То есть, пока ничего не делим, только перемножаем.
Ну, чем это нам помогает?
А помогает нам это тем, что вот в этой штуке есть только там X квадраты.
То есть, ну, вот.
А так как есть при X квадрат...
То есть, получается, здесь, на самом деле, коэффициентов не нулевых будет, во-первых, столько же, сколько было раньше.
А во-вторых, вот здесь их, конечно, будет уже в два раза больше, но при этом заметим, что интересует нас только половина из них.
Ну, вот это, то есть, эту штуку можно написать так.
P штрих от X.
Ну ладно, давайте так.
P1 от X квадрат плюс X на P2 от X квадрат.
Вот так назовем.
И делим мы это на там Q1 от X квадрат.
Вот так.
То есть, в результате, вместо того, чтобы искать n-ый коэффициент вот такого отношения,
Нужно найти n пополам.
Ты там плюс-минус один коэффициент.
Там либо такой рекуррент, либо такой.
Вот.
Так же.
То есть, а, правда.
Ну вот.
Так же соответственно.
То есть, единственная проблема, что...
Ну вот.
Нет, почему лог квадрат?
Ну, в принципе, да.
Получается, да.
Получается лог квадрат.
Поделить, конечно, лучше.
Ну, если вы там 100 тысяч на элементах.
То есть, в данном случае, да, в рекурренте он у нас неплохо работал, когда у нас Q было мелкое.
Ну, помните, у нас там n log n log k получался, да.
Вот.
То есть, это, конечно, да.
Ну вот.
То есть, поделить, поделить, конечно, будет все-таки проще.
Да.
Чего?
Так.
Ну да.
Если можно сказать.
Там на кейф было стоять про то, как я делаю.
И сказать, типа, я на члене рекуррента.
И там комментарии.
Прямо в точно такие же обозначениях.
Я смотрю, такой, типа.
Прямо.
Прямо.
Оказалось, что комментарий оставил некий голова.
Ну, я вам больше скажу, я этот лайхак оттуда же и взял.
Ну да.
Ну что, я тоже кейф читаю, да.
Вот так мало.
Так что, да.
Это очень понравилось.
Ну как бы, да.
Да.
Да, конечно, да.
Можно, конечно, тебе сказать, да, господи, вы что думаете?
Майк Мирзаянов думаете, откуда?
Да.
Но это как всегда.
Да.
Как шутка, это не заходит, потому что не является общей
сделанным фактом, что он из Саратовского государственного
университета там, допустим.
Да.
А в какой-то момент переехал в ЭТМО вместе с Кодфорсиасом.
Ну.
Вот.
Забыл за собой и Саратовский?
Нет.
Ну, не знаю.
Нет.
Ну как?
Нет.
Ну как архив?
Африканский видео все-таки.
Или какой архив он был?
Нет.
Ну как такие?
Нет, СГУ.
Нет, ну да-да-да-да.
А СМС ГУ, конечно, да, какой-то аналактимусы есть, это да,
но кто поддерживает, сейчас я не знаю.
Он просто отдельно в ТАФУ нахвилит.
А, да.
А, да.
Ну окей, хорошо.
Так, ладненько.
Вообще, да.
Да.
Тема лекции вообще у нас потоки.
Да.
Вот.
Ну да, это видно.
Ну ничего.
На часа третий две доски все-таки принципиальные, потому что я утверждаю, что основную тему лекции всю я выпишу просто на одну доску.
То есть на самом деле вместо может быть... То есть запись потребуется только в качестве аудиоверсии, чтобы тут расписать, а что это все значит вообще.
Сегодня мы будем искать поток.
Причем более того, если вам вы очень не любите алгоритм Диница, или вам кажется, что поиск блокирующей потоки это что-то страшное, громоздкое, непонятное и лучше этого избегать, ликуйте сегодня вождей.
Сегодня мы будем проталкивать предпотоки.
Мы будем называть это технологией Голберга.
Ну, мы уже говорили.
Хедлайнером сегодняшнего мероприятия является американский математик Эндрю Владислав Голберг.
Так. Нет вопрос в каком... Нет, обсудить-то обсудим, куда мы денемся, да.
А вот когда мы его обсудим, это вопрос.
Ладно, ну ладно, времени у нас много, успеем все.
Ладно, спасибо за напоминание, да. Ой, господи, а то как-то уже бежит, как это потоки без масштабирования, что-то такое.
Ладно, значит, смотрите, пока проталкивание предпотока.
Значит, как мы его будем проталкивать?
Значит, идея очень проста.
Мы... Ну, начнем мы с весьма неожиданной вещью.
Вот раньше мы говорили, что дальше у нас практически в каждый момент времени в сети тек именно поток.
Не всегда оптимальный, но мы там искали какие-то там удлиняющие пути в остаточной сети, как-то пропихивали.
Сегодня мы от этого откажемся.
Значит, мы заявим теперь, что у нас...
Значит, теперь у нас будет определение.
Значит, пусть у нас есть сеть, как всегда.
Ну, давайте вот ВЕЦСТ.
Тогда, значит, Ф...
Значит, давайте ЗЕ, соответственно, Р.
Больше либо равно нуля.
Это предпоток.
Вот.
Если для любой вершины В, ну, которой не исток, исток, естественно...
Значит, ну, во-первых...
Во-первых, оказывается, что сумма входящих потоков оказывается больше либо равна, чем сумма исходящих.
Так, ну и сразу напишу.
Второе. И второе, конечно...
Сейчас... Нет, я просто сказал... Нет, я просто это уже сказал.
Вот. Нет, я подпишу, да, естественно.
Да-да-да-да.
E.finish равно V.
E.start равно V.
Ну и, конечно, вот это условие надо подписать.
То есть, на самом деле, это отличие от определения потока только в вот этом знаке.
То есть, фактически, поток это такой предпоток, у которого тут равенство.
Вот, да. То есть, на этот раз мы разрешаем себе, чтобы там в вершине скапливалось бесконечное количество машин.
Но появляться из них откуда они все еще не могут.
Вот. Так вот, у нас будет идея, что мы будем...
Как бы у нас в каждый момент времени теперь в сети будет предпоток, и мы его будем проталкивать по каким-то правилам.
Но причем правила будут очень жесткие.
Значит, во-первых, у нас есть...
Значит, во-первых, у нас есть действительно такое определение предпотока.
А во-вторых, у нас еще неожиданно появляется в сети такое понятие, как высота.
Нет, ладно, вранье.
Да, высота числа целая.
Не отрицательная.
Ну, это не раз, она всегда фиксированная функция.
Но у нее есть, значит, маленькие требования.
Требования будут такие.
Значит, в каждом момент времени будет выполняться.
Во-первых, что ашот, значит, из стока будет всегда равен модулю V.
А высота стока всегда будет равна нулю.
Вот, это два таких условия.
Но есть и важное третье.
Значит, важное третье.
То есть, для любого ребра в остаточной сети...
Вот я называю так.
Для любого ребра, допустим, у там...
Давайте В, У, допустим, С.
Значит, лежащим в, внимание, остаточной сети...
Ладно, в G, F, вот так.
Хотя надо было E, F сказать.
Ну ладно, не важно.
Ну ладно, E, хорошо, хорошо.
Ну, Господи, ну.
Швы такие вредные.
Значит, итак.
Для любого такого ребра в остаточной сети,
естественно, с подразумеванием, что С больше нуля,
оказывается верно, что высота У не меньше, чем высота В минус 1.
То есть, если у вас в остаточной сети есть живое какое-то ребро,
то оно может уменьшать высоту не более, чем на 1.
Да, оно его может не уменьшать вообще.
Оно может его там отправлять просто куда-то в небеса,
но ниже, чем на одну ступеньку, вы не спуститесь.
Да, высота вполне может быть там сколь угодно большой.
По крайней мере, на уровне определения.
Естественно, при тех ограничениях, которые у нас будут,
мы докажем, что это невозможно, но тем не менее.
А.
Ну, и сейчас, конечно, не очень возможно.
Е от ФС, это же у нас больше, чем и ребро с обычной капасти,
которая с капасти 0 обратно.
Кажется, что он просто больше, чем вот такие машины.
Что такое Е от ФС?
Это, получается, мудрость.
Это е от ФС или от С?
Да, у нас есть. Добавляются ребра, которые обратно.
Да.
Да, это да.
Получается, что если ребро заполнено, то то обратное тоже,
на счет сети он тоже имеет больше 0.
Нет, если ребро обратное, какое-то ребро заполнено,
то оно как бы здесь не учитывается.
Не случайно здесь С больше 0 написал.
На счет сети имеется вопрос.
Кто по которому еще поток может пройти?
Да, то есть имеется в виду ребра, по которому поток пустить может.
То есть ребра с пропускной способностью 0 здесь нас не интересует.
Да, но пропускная способность именно остаточная.
Это важно.
Такие ребра мы будем называть ненасыщенными.
Но у нас будут насыщенные ребра,
которых понятно Ф равно С и ненасыщенные.
Вот у нас есть такая высота.
Мы будем пытаться менять предпоток и высоту.
Соблюдая вот этот вариант, конечно.
Но при этом мы очень жестко себе описываем,
каким конкретно образом мы будем менять диспозицию.
Как мы ее будем менять?
Будем мы ее уметь с помощью всего двух функций.
Первая функция вас приветствует Пуш от В.
Вот.
Нет, враги.
Не В, а Е.
Ну давайте, которые мы назовем В, У.
Ну и допустим С.
Вот.
Ну какие у нас требования?
К тому, чтобы для какого-то ребра можно было вызвать функцию Пуш.
Ну, во-первых,
excess от Е, fo от В должен быть строго больше нуля.
Ой.
А что такое excess?
Да.
Это, как следует из названия,
это такой избыток.
Вот мы можем написать на самом деле вот такое определение.
Вот такая разность должна быть больше либо равно нуля.
Давайте вот эту вот, значит, соответственно,
вот эту вот разность будем называть excess от В.
Или избыток.
То есть такая логичность.
Для того, чтобы пустить по ребру какие-то машинки,
мы будем называть их excess от V.
Такая логичность.
Для того, чтобы пустить по ребру какие-то машинки,
нужно, чтобы они в начале этого ребра были.
Вот.
И второе требование.
Машинки у нас умеют ездить только вниз.
Потому что на бензине мы экономим.
Соответственно.
Поэтому мы прям жестко себе требуем,
что h2 обязан быть равен h2-1.
Ладно.
Видимо, надо тут, в такой формулевке надо написать,
конечно, там, что вот это вот.
Да, давайте так вот напишем.
Во.
Вот так.
Но давайте напишем, что это c, конечно, должно быть больше нуля.
Ну, то есть, пихаем предпоток только в ноток.
Только, соответственно, по ненасыщенным ребрам.
Да.
Ну, я просто тут c пишу вот здесь.
Да.
Могу с индексом f написать.
Ну, давайте, ладно, если вам так удобнее будет.
Давайте так.
Да.
Да.
Вот так.
Да, пожалуй, да, это правильно будет.
Так вот.
Что же делает Пуш?
Что делает Пуш?
Ну, делает он простую вещь.
Он по этому ребру пускает столько потока, сколько может.
Ну, то есть, у слов договора там дельта f это будет минимум
из, соответственно, cf и чего там?
Excess от v.
Ну, вот.
Ну, и пишем, соответственно.
Так.
Ну, значит, теперь надо прибор реально пустить.
Значит, пишем там push flow от e.
Ну, в смысле, вот реально пустить поток, типа вот это.
Там типа и тут пустить по обратному ребру.
Там пустить вот это все.
Вот.
Ну, и, возможно, не забыть о том, чтобы там какой-нибудь
excess от v минус равно дельта f.
А тут дельта f, конечно, надо написать.
Вот.
И excess от u плюс равно дельта f.
Вот.
Ну, потому что это excess там по-любому насчитывать
придется.
То есть, вот такое, ну, вот.
То есть, вот только в таких случаях мы будем пускать поток.
Чего?
Да.
То есть, опускаем только вниз.
Ну, значит, да.
Как это вообще пронициализировать?
Это вообще отдельная песня.
Это мы тоже обсудим.
Значит, это у нас push.
Это единственная функция, которая будет реально менять потоки.
Но для того, чтобы этот поток, чтобы можно было что-то
адекватно делать, наверное, как-то надо уметь менять высоты.
Справиться с этим нам поможет функция relabel.
Или в других переводах лифт еще она иногда называется.
Лифт.
Итак, значит, функция relabel от v.
Которая не исток и несток.
Значит, требования к этой функции.
Какие у нас требования?
Ну, требования тупые.
На самом деле, я скажу так.
Из v нельзя, значит, первое.
Значит, из v нельзя выполнить push.
Но, тем не менее, excess от v больше 0.
Вот.
То есть, если у векшины нет избытка, то мы с ней ничего не делаем.
Ну, действие в принципе можно сказать одно.
Ну, просто h от v.
Просто надо поднять вершину v на минимальную высоту, с которой push сделать можно.
Ну, формально я так и напишу.
Это 1 плюс минимум, значит, h от u такое, что там v у cf лежит в еф и cf больше 0.
Вот.
Ну, понятно, что все такие h от u как бы больше либо равно, чем h от v.
Поэтому как бы высота увеличивается хотя бы на 1.
Ну.
Нет увеличения.
Строго увеличения.
Да.
У нас были вот эти три…
Ну да.
Ну вот, да.
А если будет равенство, значит push можно было выполнить.
Ну, сразу скажу.
Смотрите, такому быть не может по одной простой причине.
А раз у вас xs от v больше 0, значит в эту вершину что-то втекает.
А раз в эту вершину что-то втекает, значит в остаточной сети есть обратное ребро.
Вот.
Да, тут вот оказывается такая неожиданная вещь.
Но на самом деле еще был действительно вопрос, как это инициализировать.
Значит, инициализировать будем так.
Значит, и нет.
Значит, инициализация.
То есть на самом деле может быть много алгоритмов, но инициализация будет одна и та же.
Значит, идея такая.
Ну, во-первых, изначально h от v равно 0, где v лежит просто по…
Ну, просто во всех вершинах изначально высота 0.
Ну, кроме, конечно же, там, понятно, h от s равно 0v.
Давайте h от t, уж так и быть, выделим, равно 0.
А теперь перебираем все ребра, торчащие из истока.
Ну, вот там допустим.
И по всем этим ребрам впускаем поток.
Причем на максимум прям.
Все.
Нет, именно push-flow.
Смотрите, какая ситуация.
Действительно, когда мы нарисовали такие высоты, у нас могут быть ребра, которые ведут с высоты v в высоту 0.
Ну, как могут быть, они почти, наверное, есть.
Поэтому как добиться того, чтобы вариант сохранился?
Очень просто.
А давайте насытим все такие ребра.
Обратите внимание, теперь у нас нет ребер, ведущих с высоты v, на высоту 0.
Но есть ребра с высоты 0, на высоту…
Бывают 0, а бывают v.
Кстати, обратите внимание, что в самом начале вы не можете сделать push.
То есть вам придется делать relabel.
Ну, ничего страшного.
В чем теперь заключается концепция?
То есть будем называть это концепция проталкивания предпотока.
То есть мета-алгоритм получается у нас такой, который мы будем называть.
То есть была у нас концепция блокирующих потоков.
А теперь у нас будет, собственно, концепция, как мы ее будем называть, Голдберга.
Хотя, если мы их тронем, ничего страшного не будет.
Ну, с точки зрения нашей задачи, заметим, что у нас ничего не поменяется, если мы по петле пустим максимально возможный поток.
То есть ничего страшного не будет.
Нет, я имею в виду, что здесь даже не надо заморачиваться, что будем считать, что петель нет, вот это все.
Это концепция их кушает автоматически.
Итак, концепция Голдберга.
Ну, во-первых, выполняем линит.
И второе.
Делаем push и relabel.
Пока можем.
Вот.
Что значит пока можем?
Вот прям буквально.
Можно писать было vile, там можно хоть у какой-то вершины сделать push и relabel, берем какую-то вершину и делаем из нее push или relabel.
Ну, было хорошее ребро, а стало вот таким.
А тут ограничение на высоту только снизу, если оно было выполнено, то как бы от того, что вершина увеличилась, соответственно у нас этот инвериент точно не нарушился.
Не, на исходящих понятно.
Потому что ты берешь минимум по всем h от u.
Где входящих?
У тебя выполнялось неравенство.
Ты увеличил h от u.
Вот.
Так вот.
Так, ну вот теперь возникает вопрос.
Ну вот, то есть метод заключается в том, что как бы тут ничего не сказано о том, как мы ищем эту вершину, как выбираем, делаем push или relabel.
Да, ну осталось только выяснить, как вершину найти.
Ну, правда, для нас это возникает вопрос.
Хорошо, допустим у нас в какой-то момент выяснилось, что нельзя сделать push или relabel.
Да, внимание, вопрос.
И будет, и значит что?
Ну.
Ну.
Такой.
Серьезно?
Так.
Так, говоришь.
Ну.
Ну, не, ну что, маркер как вот, маркер как маркер для флипчартов.
Да, все нормально.
Ну да, да, да, да, да.
Да, да, да, да, да.
Печально, но ладно.
Надо.
Что-то по push call.
Access должен выполняться в функции push call.
Да, кажется, что Access.
За обновление Access должна выполнять функцию push call.
Да.
Вот, то есть Access это будет, да.
Лучше верно в красной 4.
Либо в зеленом написать.
В зеленом?
Ну, мы не изменяем Access в одном из случаев.
Мы не изменяем.
Я вас понял, да.
Ну, давайте AccessA2 плюс равно, плюс равно C напишем.
Да.
Ну, можно было бы AccessAtest написать еще для удобства, но необходимости в этом нет.
Нет, ну, можно писать AccessAtest, да, он ни на что не повлияет, он будет, видимо,
может быть, в итоге он будет там запись, насколько пихнется.
Почему я от S ульцем?
Там же выменяет.
И кем?
А, ульцем.
Еще вопрос.
Да.
Делебрактор, который выходит из S, он не может AccessAtest слушать.
Что, AccessAtest просто бесконечный?
Да, просто бесконечный.
Сейчас.
Где написать, кем написать?
Я вам скажу, что если мы просто будем Access снять, то нормально.
А если в конце будет AccessAtest менять, то будто бы в конце AccessAtest будет минус по поводу.
Ну, вообще говорят да.
Так, ну, породите.
Начнем с маленького приятного утверждения.
Давайте.
Во-первых, заметим, что если AccessAtest, ну, такое, тупое утверждение 1,
утверждение.
Если Access от V больше нуля, то из V можно сделать либо push, либо relabel.
Вот.
То есть.
Ну, действительно, просто либо у вас есть ребро ведущее.
Ну, просто рассмотрим.
То есть, как мы уже сказали, ключевое такое соображение, что из вершины V существует ребро, ненасыщенное ребро.
Теперь, ну, вот, рассмотрим все кириллы.
Либо хотя бы одно из них ведет в высоту ниже, и тогда мы можем сделать push, либо ни одно не ведет, и тогда можно сделать push.
Вот.
Ну, потому что логично, как бы, как бы, либо можно сделать push, либо нельзя сделать push, и тогда можно сделать relabel.
Да, просто вот, как бы, на уровне логики.
Вот.
Так что здесь пока тривиально.
То есть, таким образом, вывод такой.
То есть, этот алгоритм заканчивается, как бы, на уровне логики.
Таким образом, вывод такой.
То есть, этот алгоритм, в тот момент, когда алгоритм заканчивается, эксцессы исчезают.
Да, как в науке называется предпоток с нулевыми эксцессами?
Поток.
Совершенно верно.
Да, давайте это тоже зафиксируем.
То есть, утверждение.
Так и так и напишем.
Предпоток с нулевыми эксцессами – это поток.
То есть, в принципе, приятная новость.
Когда алгоритм закончится, мы получим поток.
Вот.
Но есть более важная теорияма для нас.
Можно уж даже теориям сказать.
Ну вот.
Если алгоритм, основанный на КГ алгоритм, на концепции Голберга алгоритм,
завершился.
То…
Что?
Ну вот.
То…
Значит, имеющийся предпоток с нулевыми эксцессами.
То есть, мы получим поток с нулевыми эксцессами.
Ну вот.
Ну вот.
Ну вот.
То есть, мы получим поток с нулевыми эксцессами.
имеющийся предпоток является максимальным
потоком в сети G
ну пока стоит добавить только до об чем он собственно максимальный
ну черема говорит ну как это говорит как бы нет там лет 15-20 наскорбли но у нас на
заборах они такое пишут и че да да хочется сказать что да у нас нет
удлиняющего пути в остаточной сети там это вот поэтому потеряем форда фолкерсона
поток максимально хочется сказать а почему нет пути то вообще так и что
но это же не значит что пути нет
нет по причем тут почему пушки пушку можно делать только пушку сейчас
делать потому что у нас эксцессов нету ну не обязательно
не правда почему нет для всех этих ребер это утверждение продолжает быть выполнено
во первых мы как бы не можем сделать пушки не по этой причине даже то есть там
то есть ну какая какие-то ребра торчат вверх это да но это проблема все равно у нас
эксцессов у нас эксцесса обнулились поэтому пошло нечего пушить так ну-ка
но да но да заметим что да да рассмотрим простой удлиняющий путь улучшающий да
заметим что он состоит не более чем 2 минус 1 ребер поэтому получается что
высота коня высота т должна быть хотя бы 1 ну потому что каждый шаг по инварианту
уменьшает высоту не более чем на 1 а может и не уменьшает вообще можно и так сказать или еще
красивое рассуждение можно с другой стороны посмотреть попрешу заметил рассмотрим высоты
от 0 до v заметим что по принципу дирихле найдется высота на которой вершин нет тогда
тогда рассмотрим такой то есть пусть эта высота какая-нибудь там 57 тогда у нас возникает разрез
57 то есть вершины по высоте выше 57 и ниже утверждение это этот разрез насыщенный
потому что нет у ребер которые ведут из вершины выше этой высоты вершину ниже этой высоты
ну почему ну собственно вот почему понятно да вот тем более того кстати это удобно
судьи да еще вопрос о том вот была классическая задача как найти минимальный разрез в сети но
вот как бы концепция голберка предлагает вам еще один неожиданный способ прям буквально на
халяву его найти вот так что классно то есть как бы да то есть если это вообще закончится
когда-нибудь то значит потом и найдем максимальный поток да да да да да совершенно
да парадокс этой концепции заключается в том что в каждый момент времени пути из-за
сфты нету но это нормально потому что по сути я бы сказал так потому что тот концепция работает
так вся вода значит но опять мы насытили в серебре из-за значит теперь в процессе вся вода будет
либо заперта ну вода там будет куда-то там гоняться по вершинам как-то там перегоняться но в
какой-то момент кончится закончится то есть каждая машинка в итоге либо придет в т либо
вернется в с вот так чем магическим образом окажется что в т пихнется максимально большое
количество машин но что-то ну не знаю ну как сказать
так но вот да но вообще но возникает каше более интеллектуальное утверждение спрашивается
а не может ли быть но вот там не окажется ли случайно что алгоритм будет работать бесконечно
да ну что да но мы можем сделать релайбл увиди и что да вот сразу сказать такая интеллектуальная
ситуация жила было ребро мы сделали пуш потом сделали релайбл от этой вершины сделали пуш по
опять повысили вот это вот так не уменьшаем не уменьшаем например да
то есть конечно да то есть вдруг мы можем у вершины сделать бесконечное число релайбл
нет вот тут ну тут интересно прочитать интуицию да так давайте это а я тут пока немножко это
ой поликвидирую последствия маркера
при этом на самом деле когда высота всех стало хотя бы два
когда мы уже не можем последнюю вершину вообще ничего и что а ты где в том что ты делаешь
так ну ладно этот подстерк нет ну ладно таких соображениях конечно сложно придумать хотя
наверное можно но ладно не было но я боюсь там это я думаю это не за 2 минуты делается ключевая
лемма звучит так на эту тему пусть excess от в больше нуля да ну давайте на всякий случай
ладно оговоримся везде когда я пишу excess от в больше нуля я подозреваю что в это не
исток и несток а вот а ну собственно а ну собственно заметим что я здесь в общем-то в определении
может говорить что excess я рассматриваю вершины только такие не исток и несток ну ну как сказать
да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
да да да да да да да да да да да да да-да-да да да да да да да да да да да convert лsk
скажем нет ну это даже по-моему то то знаете так тонкость граничится с буквоедством на самом деле если честно да да потому что
поэтому легче уже вот так написать вот все вот то есть знаете действительно что в концерте что безопаснее называется каждую там каждую секунду кричать
осторожно сосулька осторожно сосулька осторожно сосулька или то но вот или потом когда кому-то на голову придется сулька сказать мы же в начале ну мы же когда-то там в начале 2 дня назад предупреждали что там сосульки
сложная аналогия да ну ладно вот короче говоря я имею ввиду вот что давайте в каждом месте вы вот это писать значит если excess у и сосулька
вот
то ладно значит из в в с существует путь ну какой путь ну естественно да в остаточной так сказать сети по не нулевым ребрам
нет жеф на этот раз нет нет сторожа придется обезвреживать именно вам тут на этот раз именно жеф потому что уже жеф это собственно все сеть весь граф в том числе и вершина вот ну ключевое утверждение такое ну следствие из него очевидно
то есть просто следствие видеться ремы тогда а шатве меньше либо равно 2 модуль вы минус 1
ну если в эту левую поверить конечно
вот но осталось только выяснить а откуда же это лемма взялась из какого кармана я ее достал
ну как сказать да вот ну вот а идея на самом деле оказывается очень проста смотрите жила была вершина в и был в ней избыто то есть лишние машинки приезжали да допустим что до эса я дойти не могу
тогда идея такая а давайте я посмотрю а докуда я вообще могу дойти прям вот как-то вот как всегда dfs по не нулевым ребрам запущу короче да то есть получится какая-то красота красота красота в общем вот это типа вот пусть
я дойти могу и где-то оказалось с так вот утверждение значит в это множество в текает положительное количество машин почему так ну я тут сейчас вот не хочу расписывать хотя можно вот
расписать аналогично тому как это делали там два занятия назад но типа то есть давайте просто то есть если я присумирую ну если я присумирую все эксцс включая кстати t если он тут случайно окажется то я получу строго положительное число правда
ну потому что увы он положить но всех не отрицать вот но тогда смотрите но тогда что такое эксц это как бы входящие машинки минус исходящие да если у нас тут пока какой какое-то ребро внутри этого множества есть то
то тогда вот то тогда у вас очевидно там исходящие входящие также там поубиваются
может у каждого но смотрите но в каждый момент времени когда вы делаете релайбл когда вы делаете релайбл у вас эксц больше нуля значит в этот момент у
вас существует путь до вершины с а у вершины с высота фиксировано модуль в
да но да но просто мы не сильно большой высоты можем до этого с упасть
я могу например первым шагом сделать нет плюс равно 100 не можешь вранье так плюс
равно 100 можешь но теперь фишки такая плюс равно 100 конечно ты сделать можешь но фишка
в том что после этого если у тебя кажется там вы плюс 100 высота допустим да то как бы тебе
потребуется 100 вершин для того чтобы спуститься до с то есть как бы взлететь влететь легко а вернуться
обратно проблема вот так что вот так что вернемся клейме что такое суммарный избыток вот этого
но я утверждаю что это просто сколько машинок въезжает извне минус сколько выезжает вовне причем то есть то
что внутри оно тут по плюс минусе ц вот но так как эта сумма больше нуля значит хотя бы одна машинка
сюда въезжает а это означает что хотя бы одно обратное ребро они нулевое в остатке сидит тут
существует противоречие вот ну противоречие с тем что мы казалось бы мы сказали что как будто вот
это все вершины в которых мы можем дотянуться оказывается не все да вопрос на понимание а каким
образом это как бы это вот это противоречие каким образом наличие вершины s внутри этого множества
дизавуирует указанное противоречие да совершенно верно да именно то есть s это единственная вершина
у которой может быть и почти всегда и будет отрицательный избыток да совершенно верно
господи вообще надо как-то переучиваться чтобы xs называть избытком а то знаете это при вот
кстати вот на защите диплома вас может ждать неожиданный прикол нет вам знаком такой человек
как константин вячеслав киеваранцов нет ну вы с ним познакомитесь потому что это один из
ведущих если не ведущих специалистов преподаватель в области машинного обучения вот так что у вас
свое время это обязательно ждет не обязательно с ним или или как-то еще но я думаю там так или
видимо там со его творчеством там вы познакомитесь так вот значит на защите диплома значит кто-то
засчитал диплом по машинному обучению но вот но вот ей естественно там употреблял там какие-то
слова там типа типа там фичи фичи там добавим фичи обучим чемпием посчитаем пиджа там и так
далее значит в какой то что этоzar Herroto говорит на правах записlate зануды значит позволю себе
заметить что употребление в русской речи слова bitches оскорбляет русскоязычные сообщество аula
но от машинного обучения оно так и есть, поэтому надо говорить не фичи, а там студент, факторы, признаки, нет почему, претензия в том, что защита диплома ввелась на русском языке,
а употребляем мы соответственно какой-то англоязычный термин, хотя в русском языке есть нормальный аналог, в данном случае абсолютно идентичный.
Нет, ну тут у нас так, код мы пишем, да, но я постоят к тому, что по-хорошему надо называть там excess, надо называть избытком, да не будет у нас,
ну почему, нет, в данном случае функции нет, по-русски избыток там, поэтому excess, ну так.
Нет, ну мы говорим определитель, да, тут нас путает то, что мы вроде и в математике как бы и в программировании конечно там пишем код на русском языке,
в программировании конечно там пишем код на английском языке, это да.
Ну как бы да.
Сказать, что мы можем сделать.
Нет, ну у нас, да, можем, не, ну все равно, нет, когда мы запретаем функцию, мы ж пишем там f от x, а не там y от x, к сожалению, да.
Ну тогда уж есть y от x, y от a, например, я не знаю или там y от f, вот этого вот.
Было, но к сожалению, это мы прикалывались, да, то есть это мы больше прикалывались, чем это приняли, чем так реально пишут.
То есть как бы, то есть мало ли, там нет у меня учителей, там мой преподаватель физики вообще прикалывался, что может быть вы там когда-нибудь это изучите глубокую физику вообще и там изобретете закон, который будет там написан вот как-то вот в таком формате, там вот я не знаю.
Там будет закон Руховича такой, да, например, да.
Тут дот там можно все чертить.
Нет, это одна буква.
Нет, ну может быть вот такой закон, да, действительно, пожалуйста.
Вот так формально сегодня рыды называют.
Ну в общем-то.
Ну нет, на еге осторожно, там можете есть.
Ну тут нет, ну окей, тогда ладно.
Ну там как бы, скажем так, есть риск, что как бы это проверяющий эксперт может не оценить юмора.
Там мало ли, знаете, ну вот.
Нет, ну как сказать.
Ну а он скажет, ну извините, если вас в школе не научили, что буквы нельзя называть русскими, там функции не называются русскими буквами, ну соответственно.
Ну да, ну как сказать.
Как говорится, разные мнения, там опасно, потому что когда-то на заре еге были прецеденты, когда там бабушка посчитала, что там человек не умеет писать сортировку от того, что он написал не пузырёк, а кусорт.
Вот, ну сейчас такого нету, конечно, уже видимо безобразие.
Ну если это правда, это может, мне там байку передавали, конечно.
Такое, ладно.
Так, итак, смотрите, к чему мы в итоге подошли.
Подошли мы в итоге к тому, что у нас высота оказывается ограничена, причём ещё и вполне себе простой пандемиальная вещь.
То есть более того, на самом деле, мало того, что из этого следует алгоритм конечный, так ещё и возникает ощущение, что мы и выполним не более, чем пандемиальное число действий.
Более того, сейчас мы даже получим более точные оценки на то.
Значит, смотрите.
Нет.
Почему?
Не совсем так.
Это почти правильное утверждение, если рассматривать не все пуши, а один конкретный вид пуши.
Называется это будет это вид насыщающие пуши.
Значит, смотрите.
Да, действительно, вот идея, действительно.
Так, ну начнём с простого факта.
Все релеблы выполняются суммарно за ООВЕ.
Да.
Ну потому что для каждой вершины...
Нет, нет, давай так.
Один релебл для одной вершины выполняется вообще за её степеньку.
Выполнять релебл, делать релебл мы будем не более, чем там вот 2V-1 раз.
Да, для каждой вершины не более, чем 2V-1 раз.
Тогда если мы посуммируем по всем вершинам, по всем её релеблам, то получится 2V-1 раз на сумму по всем ребрам.
Так, давайте, хорошо.
Мы это делаем.
Пробираемся по всем вершинам, значит, релеблы.
И делаем количество релеблов.
Отправляем в ящик.
Ну, получается, что мы всё это делаем.
Делаем по всему вершинам.
Так, давайте, хорошо. Мы это делаем, пробираемся по всем вершинам релейбла и делаем на количество релейблов от v умножить на дег от v, это не превосходит сумму по всем вершинам 2 модуль v-1 на дег от v.
Это равно 2 модуль v-1 на сумму дег от v.
Равно, короче, 2 модуль v-1 на, ну давайте 2e напишем, да, все. То есть да, приятно, и даже еще константа не сильно большая. Не это там от v-e, где там o может быть 57 в степени 179.
Нет, тут умножить.
Ну это как это, в науке это называется умалое, да.
Нет, там есть, конечно, чемпионаты, там, конечно, хотя там разные чемпионаты иногда. Бывает, например, чемпионаты, как известно сортировать быстрее, чем за n лог n нельзя.
А теперь задача, а сортировать за n лог n плюс cn, где c как можно меньше. Да, такой чемпионат в науке реально есть.
Вот.
Вот он утверждает.
Так.
Итак, стрелайбл это да.
Это да. Значит, теперь пуши.
Значит, пуши у нас бывают, давайте скажем, насыщенные, не насыщенные пуши, а насыщающие.
То есть это когда в результате, соответственно, вот это вот c, там cf становится в результате пуша нулем.
А еще бывают ненасыщающие.
Насыщающие, которые полностью капастик 0 свой, да?
Не совсем.
Ну, формально мы все равно напишем вот так.
Потому что дело в том, что, то есть почему мы не можем просто написать, что ненасыщающие это те, которые делают excess 0?
Потому что бывают пуши, которые в общем-то и ребро убили, и избыток обнулили.
Вот. Поэтому, поэтому мы будем их относить в категорию насыщающих.
Насыщающие, когда минимум сработал по c, а ненасыщающие, когда минимум сработал по excess.
Да, причем строго по excess.
Да, то есть если ничья, то отправляем насыщающие.
Так вот, и теперь вот уже было оглашено практически действительно утверждение верное.
То есть только вот по модулю этого одного слова.
В процессе?
Нет, в процессе концепции Голберга будет выполнено не более чем, я даже тут обычно пишу 2v-e, но я даже не пишу 2v-1 на…
На e.
А, на e. Да, не на 2e, а на e.
Да, потому что как бы… Ну сейчас увидите почему.
Насыщающих пушей.
Почему так?
Ну вот.
Именно насыщающих, это важно.
Ну все, что мы можем делать с вершиной после насыщающего пуша, это ревей.
А что значит с вершиной?
Нет, с вершиной мы можем делать все, что угодно, но фишка такая, да.
Допустим, пусть ребро находится на высотах 57-56, и вы сделали насыщающий пуш.
Для того, чтобы вы сделали следующий насыщающий пуш, или вообще следующий пуш, что нужно, нужно, чтобы эта вершина обогнала эту, вы сделали пуш по обратному ребру, не важно насыщающий или нет.
А потом обогнали еще и вот эту вершину.
То есть это означает, что по каждому конкретному ребру вообще там…
То есть получается…
По сути, да.
Но можно даже уточнить, заметим, что если мы рассматриваем ребро и обратное, то заметим, что на каждой паре высот вы сделаете не более одного насыщающего пуша по обоим этим ребрам.
Поэтому я вот здесь пишу вот так.
Ну смотри, жила было ребро на высоте 57-56.
Мы его насытили.
Что нужно, чтобы еще раз его насытить?
Нужно его насытить, то есть пихнуть поток по обратному ребру.
Но для этого нужно, чтобы вот у этой вершины высота стала 58+.
Кто эта вершина?
Конец ребра.
Ну просто она же должна в этом направлении пойти.
Но мало этого, мы должны еще теперь в итоге повысить потом эту вершину на 59+, и уже тогда делать повторный пуш.
Насытили это ребро.
То есть пропускать способность у него ноль.
Чтобы оно стало не ноль, нужно, чтобы в обратную сторону что-то протекло.
Мы это можем сделать только через пуш.
А пуш требует, чтобы вот эта вершина тогда, если хотим в эту сторону делать пуш, стала выше.
То есть мы должны сделать не просто релейбла, а чтобы высота увеличилась хотя бы на два.
Вот, хорошо.
Сделали.
А теперь пуш, вы хотите еще раз пуш в эту сторону?
Так давайте теперь эта вершина должна выше стать.
Получается, что высота обоих вершин между двумя пушами увеличились как минимум на два.
То есть я поэтому 2VE я бы отсюда на халяву вывел, но если чуть-чуть внимательно присмотреться, можно увидеть и 2V-1.
Ладно, на самом деле вот так.
Нет, ладно, не так.
1-1.
Ладно, 1.
Потому что с высоты 2V-1 пуш может быть, и с высоты 1 тоже.
Но если мы будем делать это, то мы будем делать так.
А если мы будем делать это с высоты 2V-1, то мы будем делать так.
Потому что с высоты 2V-1 пуш может быть, и с высоты 1 тоже может быть.
Что у нас на прошлой лекции было?
Я не помню точно где, но мы точно также оценивали количество.
Да, это был Эдман Скарп.
Потому что да, там была похожая ситуация.
То есть дело в том, что мы проталкивали поток, то есть помните как был Эдман Скарп?
Мы запускали БФС.
И поток пропускался только по ребрам, у которых там расстояние, правда наоборот, тут 57, тут 58.
Но тогда выяснялось, что для того, чтобы...
Ну да, типа того, да.
То есть там выяснялось, что для того, чтобы разносытить это ребро, нужно чтобы эта вершина обогнала это.
Тут было 58, 59, а потом 59, 60.
Поэтому выяснялось, что по каждому ребру, каждое ребро может насытиться не более чем V пополам раз.
Выяснялось у нас.
Отсюда мы доказывали симпатику Эдман Скарпа.
Да, то есть идея вот почти такая же, только конечно немножко в другом контексте.
Так, ух ты, вот чудо, кроме нас там кто-то есть.
А то в общем-то стало вообще казаться, что только мы сюда пришли, а так больше там занятий нигде нет.
Я догадываюсь, что неправильно, да.
Правильно?
Ну нет, это странно было бы правильно, потому что почему мы занимаемся, а остальные нет.
Не то, чтобы я против, я обеими руками за, но как бы...
Чего?
Ну да.
Ну это да.
Но они тоже на физитете как бы, да.
Ну это да.
Нет, ну всякое бывает.
На физитете, конечно, общепринятые выходные часто игнорируются, но с другой стороны, я как-то раз пришел на занятия, а никого нет.
А мне сказали, а чего, да, 8 мая праздник, да, все.
Так что скорее всего 8 мая будет выходной.
Ладно, правда настос с вами скорее всего них.
Да, конкретно на занятия алгоритмов это не коснется.
Так, ладно.
Так, есть еще тут какие-то вопросы?
Да.
То есть мы еще не каштаром...
Как это, не то чтобы в принципе не любим по баллоне?
Нет, ну...
Нет, нет, вопрос будет...
Нет, чтобы понять как это писать, надо будет предъявить алгоритм как это делать.
Но вот фишка в том, что писать это конечно будет прям муа, потому что тут все очень просто пишет.
Нет, вот...
Да, а теперь вопрос как, как ищем конкретно?
Да.
Но фишка в том, что про эту концепцию можно кучу всего доказать, что мы сейчас делаем.
Уже до того, как мы предъявили хоть один алгоритм.
Потому что, видите, мало того, что релейблов, то есть высоты небольшие, так еще и оказывается насыщающих кушей оказывается мало.
Мы не насыщающие.
Да, не насыщающие мы не оценили.
Но я думаю мы это сделаем после перерыва, который уже явно наступает.
Ладно, все, возвращаемся к делу.
Итак, на чем мы остановились?
Мы остановились на том, что релейблы у нас, оказывается, суммарно работают за VE, насыщающих кушей тоже VE.
Теперь мне стекает вопрос.
Спрашивать, а сколько бывает ненасыщающих?
Вот, но это уже не так тривиально.
Потому что ненасыщающих кушей на одной высоте может быть сколько угодно.
Единственное только, что мы знаем, это, конечно, то, что каждый ненасыщающий куш обнуляет испыток.
Так, поэтому возникает нот.
Ну, действительно, у нас возникает теорияма.
Там тоже, видимо.
Ладно, теорияма в процессе.
В процессе.
В процессе КГ будет выполнено.
Будет.
Не более чем.
Не более чем ненасыщающих куш.
Да, определенно, не более чем.
Как же получить оценку?
Ну, как всегда, чтобы получить оценку, надо ввести правильный потенцеваль.
Какой потенцеваль ввести?
100.
Чем приятен такой потенцеваль?
Потенцеваль приятен тем, что каждый ненасыщающий куш уменьшил потенциал хотя бы на один.
Но мог увеличить.
Это неправда.
Нет, насыщающий мог его увеличить на высоту той вершины, в которую он проводился.
Поэтому не все так просто.
То есть насыщающий куш – это плюс не более чем 2v-1.
2v-2.
То есть когда ты делаешь куш…
То есть он…
Да.
Но тут вопрос не до какой степени она может расти, а насколько она суммарно может увеличить.
Она же внутри этого диапазона может туда-сюда ходить.
Это насыщающий.
Не насыщающий.
Плюс не более чем минус один.
Минус один.
Да, но у нас на потенциал еще влияют релейблы, очевидно.
Но как влияют на потенциал релейблы?
Заметим, что по каждой вершине, если высота вершины увеличилась 57 на 179, то и потенциал увеличился на 179-57.
Почему насыщающие…
Так что вот такие оценки.
То есть так как насыщающий всегда уменьшает потенциал, меньше нуля он не становится, значит получается можно написать сумму вот этого вот.
Вот, нет, ну да.
Ну как много, на самом деле получается там…
Ну на самом деле я вам так скажу, можно написать, что это не превосходит, называется 4 модуль V на модуль E плюс 2 модуль V в квадрате.
Вот теперь хорошо.
Ну у нас высота не более чем 2V минус 1, но нам даже не важно сколько релейблов, нам важно, что суммарно по каждой вершине как бы релейбл увеличил потенциал не более чем на 2V минус 1, а все вершины 2V минус 2.
Ну нет, мы даже не считали, мы считали, что высота не более чем 2V минус 1, а каждый релейбл увеличивает высоту хотя бы на 1.
Но это и не важно.
Нас сейчас интересует, нас сейчас даже не интересно количество релейблов, нам интересует на какую высоту они задирают вершины.
Вот.
Ну то есть нет, на самом деле произошла как бы историческая ситуация.
Вот.
Почему на одну? А я не на одну, я на все считал.
Да.
Ладно.
Так хорошо, да, неправ, неправ, неправ.
Вот так.
Вот.
Да, то есть не насыщаясь каждой, не насыщающей 2V минус 2 суммарно вот столько.
Релейблы суммарно вот столько, да.
Хорошо.
Но получается очень интересная вещь.
То есть мы уже достигаем асимптотики 1, если нам просто с небес по факсу в каждый момент времени сообщают, а что собственно делать.
То есть обратите внимание, мы в принципе оказывается пушей сделаем не более чем от V2E.
И релейблы суммарно работают с ZVE.
Нет, ну смотрите, ну да, то есть в качестве упражнения придумать.
Ну там так.
Ну там начинается техника.
Во-первых, давайте, давайте.
Нет, ну на уровне кукарека давайте так.
Надо придумать не очередь, а можно придумать там, скажем, двухсвязный список.
Почему двухсвязный список?
Потому что из него удобно из середины удалять.
Давайте запишем, будем хранить двухсвязный список вершин, у которых там избыток больше 0.
Вот.
А еще у каждой вершины давайте хранить там, я не знаю, там список ребер.
Там тоже список ребер, по которым можно сделать пуш, допустим.
И при каждом релейбле его там аккуратно поддерживать.
Ну в принципе можно, да?
Ну вот.
То есть там аккуратно можно допилить, и тогда получается на каждом шаге вы за от единицы будете понимать, надо релейбл делать или пуш.
Если пуш, то где?
А его никто не, а его никто не требует за от единицы, потому что они суммарно ZVE работают, от нас устраивает.
То есть обратите внимание, узкое место не здесь.
Чего?
То есть узкое место на самом деле это вот здесь, в ненасыщающих пушах.
Потому что все остальное, кроме них, работает ZVE само, просто само работает ZVE.
Вот.
Но это же и дает возможность действительно думать, а как бы действительно они взяли как-нибудь красиво организовать.
Действительно там поиск, там, собственно, там пушие релейблы действительно так, чтобы тут было побыстрее.
Вот.
Но для этого надо возвыситься над концепцией пуш релейбу.
Потому что, ну что такое возвыситься?
Ну идея, идея она будет так.
Ну потому что как у вас будет обычно, вот представься, что вы пишете в коде.
Да?
Как вы пишете код?
Ну наверное вы напишете сеть, напишете значит там какой-нибудь класс.
У которого будет там функция пуш, функция релейбл и соответственно что-то еще вроде что-то еще виртуальный там чисто виртуальный метод значит там найти поток.
Ну да.
Ну потому что это это типа класс типа типа типа типа отнаследуете от него собственно все алгоритмы наследы там которые основаны на пуш релейблу.
Да еще желательно вы там.
А вы еще там напишете конструктор.
То есть там фишка такая еще напишете конструктор, который будет принимать в себя сеть и делать вот это.
Это важно.
Это как бы заметь это не часть.
То есть это как бы часть концепции.
Вот.
То есть и нет мы не перегрузим.
Это да.
То есть максимум что можно сделать это дополнительное действие делать, но не более.
Вот.
Ну там можно задуматься.
Ну вот там разные варианты есть значит то вот то есть то есть возможно у вас в самом классе даже сеть может быть будет даже как то доступно только в режиме ридонли.
Вот.
А ну вот а что-то мне но что-то мне но ты высоты тоже в режиме ридонли и менять их можно только с помощью методов пуши релейбл.
Ну в идеале так концептуально.
Ну вот то есть ну в идеале то есть я себя там просил вас там написать супер код там с код ревью то я требовал что-нибудь подобного.
Вот но вам повезло.
Да вот конкретно вам.
Да.
Нет в прошлом по-моему нет в прошлом по-моему не было.
Но скажи так скажи так несколько несколько поколений ваших предшественников такое писал.
Вот.
То есть в какой-то момент я стал что-то упирать больше на больше на алгоритмы чем на коде.
Ну отчасти видимо с приходом того что у нас тут у вас есть соседний предмет на котором вас мучают всем всем по всеми подобными вещами.
Вот.
Ну собственно причем более того это логично делать это именно там потому что это занятие за задание по C++ а не по алгоритмам на самом деле.
Чего.
А.
Ой ну даже.
Ну да.
Ну вот хотя не так хотя надо хотя надо подумать может на самом деле зря это дело может на самом деле.
Вот так вот.
Но на самом деле сейчас дальше на самом деле было бы еще круче.
Мало того чтобы написали такой класс но прежде чем реализовывать алгоритм вы бы ввели наследник вы бы ввели наследника.
Называется Dischargeable там такой Dischargeable.
Значит смотрите апгрейд этой концепции.
Мы запрещаем себе пользоваться пушкой лейбл.
То есть мы отправляем в приват.
А разрешаем себе пользоваться только великой функцией Discharge.
Смотрите.
Значит фишка такая.
Потому что да.
Значит но алгоритм будет значит он вообще по идее работает для абсолютно любой вершины мы будем запускать.
Он даже не будет требовать чтобы чтобы избыток был больше нуля.
Хотя работать он будет такой ваил.
Он будет работать такой ваил.
Но то есть действительно как следует из названия там цель обнулить избыток в это распихать вещества.
Ваил.
Ваил.
Ваил.
Ваил.
Ваил.
Ваил.
Ваил.
Ваил.
там цель обнулить избыток В, то есть распихать его куда-нибудь. Как мы его будем делать? Ну идея тут
подсказывается Ефимом Батьковичем Деницем. Потому что смотрите какая идея. Допустим мы, ну то есть
как мы вообще теоретически могли бы искать вершину в ребро, по которому можно сделать пушь? Наверное
мы бежали по списку ребр, правда? А теперь ситуация. Жили-были ребра. Вот, вы бежите-бежите-бежите-бежите-бежите
и неожиданно выяснилось, что пушь делается вот по этому ребру. Тогда есть подозрение, что до
ближайшего релейбла, наверное, вот эти ребра трогать смысла нету, правда? Потому что либо они
насыщены, либо не подходят по высотам. А если они сейчас не подходят по высотам, то они в общем-то,
если там будет релейбл от этих вершин, тем более не подойдут. Поэтому храним тот самый, я вот забыл,
как мы его в прошлый раз называли, итератор от вершины, от ребра. Значит, смотрите. Значит, пишем.
Значит, если оказалось, что итератор, ну вот. Значит, если оказалось, что вот этот вот it от v,
validin, то что мы делаем? Не факт, не факт, не факт, не факт. Validin это означает, что как бы этот
итератор указывает на какое-то ребро. Ну типа да, помните у нас было. Сейчас все будет спокойно. Нет,
тут просто есть очень аккуратная реализация с такой минимизацией символов. Смотрите, тут просто
ситуация такая. Оказывается, что если, оказывается, что значит it, значит c, ну давайте я так, it c
минус it f оказалось больше нуля, end-end, значит h от it finish оказался действительно равен h от v
но h от v минус 1, то в этом случае что я делаю? Да, тогда я просто делаю push. Причем обратите
внимание, итератор я не двигаю, потому что может оказаться это ненасыщающий push, поэтому делаю
тут push от, ну так сказать it. Ну можно звездочка, push от it напишу короче. Тут конечно it от v
везде подразумевается. Вот так. Вот, в противном случае я делаю, то есть it от v точка next. Не
переприсваиваю, а именно точка next, он типа сам внутри себя двигается. Смотрите, это очень удобно
обретите внимание, то есть сразу, что если у меня сейчас xs обнулился из быта, то указатель
должен остаться на этом ребре, что он и делает. А если это насыщающий push, то то есть на следующей
итерации он посмотрит на это же ребро, скажет, что у него там остаточная пропускная способность 0,
поэтому он перейдет дальше. В этом смысле здесь удобно. Так вот, значит это был такой. Ну а в
противном случае, что мы делаем? Если оказалось, что итератор уже не валиден, то очевидно нам
просто нужно сделать relabel от v, во-первых, и объявить, что it от v равно begin от v. Все, это вся функция.
Да мы и push больше нигде больше делать не будем. То есть на самом деле дополняю, то есть теперь такая,
то есть так сказать discharge концепция. То есть первый init и второе. Делаем discharge пока,
пока что. Ну вот, пока есть, нет, можем мы всегда. Пока есть вершины с excess больше нуля. Ну формально
я должен вот так написать, конечно. Вот, то есть мы, да, то есть мы себе, то есть мы даже уже
использовали push relabel, делегируем конкретные функции. Да, это называется, мы пишем код более
высокого уровня, кстати. Вот. Да, ну чем-то нам поможет.
Нет, ну можем, да. Нет, что мы можем. Нет, мы всегда можем, вопрос только конкретно как.
Ну да, нет. Ну да, допустим мы даже там, да, то есть допустим мы даже в push relabel допилим
там соответственно 6 там. Да, нет, это можно, безусловно. Но вопрос как бы улучшить ли нам
это асимптотику. То есть, к сожалению, да, потому что непонятно, за сколько это работает, потому что,
да, потому что в принципе, то есть понятно, что discharge конечно выполнит, то есть в итоге так,
discharge, если избыток был больше нуля, то он конечно выполнит. Хоть либо push, либо relabel уж выполнит.
Но это вполне может оказаться ненасыщающей push и как бы пока ничего не понятно. И ничего не
горит. Поэтому нам придется придумать пару новых алгоритмов. Вот. Ну то есть, конечно, да,
если вы будете просто там поддерживать очередь из выточенных вершин, и тогда, тогда, пожалуйста,
да, там как бы асимптотика будет автоматически от в квадрате. Да, но это ничего страшного,
потому что асимптотика, у движения такое, сами по себе, если у нас сама по себе последует из
discharge, да, если мы просто рассмотрим алгоритм, то она будет работать за от, я утверждаю,
что она будет работать за от ve плюс количество вызовов discharge. Да, потому что, почему? Ну,
потому что суммарно пробегания вот эти по всем ребрам, они все равно за ve работают. Ну, за два
ve в смысле. Понятно, да? Ну, утверждение такое, рассмотрим последовательность discharge,
которые, а ну давайте напишу, что я тут уже собственно. Вот, значит, утверждение
последовательность discharge, то есть не весь алгоритм, а именно вот последовательность discharge
в процессе, ну назовем это dk, не буду здесь спалчем, вот работает за от ve плюс количество
именно вызовов discharge. А смотрите, ну потому что, смотрите, discharge будет двух типов, те,
которые заканчиваются за от единицы и те, которые двигают итератор. Ну, те, которые за от единицы,
они пишутся сюда, вот сюда. А все остальные двигают, значит, а кто у нас двигает? Ну,
либо у нас двигается итератор, значит, вот здесь, либо он двигается здесь, и мы делаем relabel. Но,
но, как мы помним, у нас высота, то есть relabel меняет высоту, значит, высота меняется не более,
чем там 2v минус один раз. Вот, и итератор у нас двигается тут в процессе, то есть между relabel
и итератор двигается не более, чем там степень вершины раз. Ну и relabel тоже работает за степень
вершины раз. Да, да, да. Не более, чем дек, поэтому сумма. Да, да, да. Ну, можно, ну там.
Нет, это не совсем так, потому что есть еще, потому что в discharge вы еще натыкаетесь на неинтересные
ребра, по которым нельзя сделать push. И вы на них тоже тратите next. Нет, это тоже WE, да. А мы еще ни
одного алгоритма не сказали. Смотрите еще раз. Рассмотрим, значит, в последствии discharge. У нас
discharge бывает двух типов. Те, которые двигают итератор, и те, которые не двигают. Но те,
которые не двигают, они завершаются за вот единицы. Их, соответственно, вот столько. А те,
которые двигают, ну давайте подумаем, сколько раз у нас итератор двигается. Между relabel и
итератор двигается сколько раз? Ну, ровно там, держат вершины раз. Логично, да? Вот. Более того,
relabel, каждый relabel, кстати, потом работает за такую же асимптотику. Но relabel у нас самих там
2 вы минус 1, правда? То есть, получается, у каждой вершины тогда суммарно этих движений итераторов
от 2v умножить на ее степень. А суммарная степень всех вершин, когда мы суммируем,
получается е. Все. Получается вот такой. Получается от 2e. Двойки какие-то убрал, естественно.
Так что вот такой вот красота. Остается только придумать совсем красоту, как теперь пихать
поток как-нибудь хорошо. Потому что если от балды искать на каждом шаге, куда делать дискчатч,
то может быть больно. Вот. Ну, значит, смотрите. Ну, начнем с Кормана. Потому что Корман и компания
в этом месте предлагают алгоритм, который они гордо называют, поднять в начало.
Они говорят. Ну вот. Занесем все вершины, которые не исток,
и там, соответственно, сток в односвязанный список. Дальше алгоритм говорит следующее.
Будем. Значит, будет, значит, будет, значит, будет, но вот. Пройдемся по списку.
Вот. И выполним дискчатч от каждой вершины. От каждой вершины.
Вот. Да, важный момент. Значит, при этом, если в результате дискчатч, значит, высота вершины В
увеличилась, то. Ладно, тут скобочки поставим. То. Что мы сделаем? То мы, да. Как следует из
дозвания, да. То поместим В в начало списка. И, внимание, начнем заново. Вот.
А все. Ну, давайте хорошо напишу. Ну и, соответственно, если дошли до конца. Вот. То завершаем работу.
Вот. Вот такой простой алгоритм. Простой. Почему он работает? Ну да. Вообще, да. Вообще не очевидно,
почему этот алгоритм вообще, действительно, хотя бы находит поток. Действительно. Да,
потому что хочется сказать. То есть, да, он делает какие-то дискчатчи. Конечно, там все хорошо. Но
хотя бы, это хорошо. Допустим, он закончился. Хотя еще отдельная песня. Закончился ли он? Хотя,
ладно, когда-нибудь. Да, понятно, что он закончился, потому что релейблов у нас не бесконечное
количество. Это да. Но возникает вопрос. Да, а верно ли, что в конце у нас вообще, как бы,
все избытки убились? Ну, в целом. Ну, что такое в целом? Все эксцессы в целом. Знаете, как это.
Смотрите. Идея очень простая. Значит, на самом деле базируется все на одном очень интересном
наблюдении. В каждый момент времени для любого ребра ВУЦФ, там, лежащим в ЕФ, такому, что можно
выполнить пуш от Е. Нет, ладно, не можно выполнить. Неправильно так писать. Правильно писать такого,
что С от Ф больше нуля и H от В равно H от У плюс 1. Да, это не эквивалентно тому, что можно выполнить
пуш по причине избытка. Вот так вот. Верно следующее, что У в списке идет дальше В.
Ну или, соответственно, У равно Т, естественно. Ладно или С, хорошо. Ну, можно. Ну, можно. Не, ну,
можно С от Ф в конец списка запихнуть, конечно, если хочется. Да, но в самом начале у тебя все высоты равны
нулю и ребер, по которому ты можешь сделать, нет вообще. Да, вот в этом смысле кайфежно. Ребра,
по которым делать пуш, появляются потом. Как это называется, да. Как-то говорят в некоторых областях,
удовольствие должно случиться потом. Сначала должно случиться совпадение интересов,
собственных общих взглядов. Так, о чем я это вообще? Вот, соответственно, волшебство должно
случиться потом. Вот. Так вот. А в процессе теперь давайте думать, в какой момент это условие может
вообще нарушиться? Да, изначально это так. Теперь по индукции. Пока диск-чаши делают тупо пуши,
у нас это условие не меняется от слова никак, правда? Да, потому что, вот, потому что,
ну, заметим следующее, что в результате того, что мы делаем пуш, у нас появляется обратное ребро,
которое ведет наоборот, как бы увеличивает высоту, поэтому на это условие не влияет никак. То есть
проблема может возникнуть только у вершины В, у которой мы неожиданно решили вызвать релейбл.
Но, как мы уже в самом начале обсуждали, в результате того, что мы вызвали релейбл,
в новых интересных входящих ребер не появилось именно входящих. Вот мы в самом начале это
обсуждали, вот как я спрашивал. Ну, потому что не может так случиться, что у тебя вершина В
поднялась, и тут, оказывается, из какой-то вершины в нее появился ребро с разностью высот минус один.
Это значит, что перед этим оно было с разностью высот минус много, а такого у нас не было просто
по исходной концепции пуш релейбл. Вот у нас там написано. Ну, зато могли появиться исходящие
интересные ребра. Но ровно для того, чтобы избежать их проблем, мы их перетаскиваем в начало.
Такая вот неожиданная приятность. Так что получается, что алгоритм работает. Все более того,
в каждый момент времени интересные ребра в нем образуют ациклическую сеть, причем топологическая
у нас в списке топологическая сортировка этой сети. Но из-за этой лемы автоматически следует,
что если алгоритм закончился, то он найдет вам правильный ответ. Да, почему он заканчивается?
Ну, потому что у нас каждый проход заканчивается либо концом алгоритма, либо релейблом. А релейблов у
нас мало. Вот. Нет, почему? Мало. Сколько у нас самих релейблов, так сказать? Да, давайте подумаем,
кстати. Нет, релейблов у нас не ве. Релейблов самих вызовов релейблов в квадрат. Другое,
просто они суммарно работают за ве. А тут нам вот это утверждение сразу помогает. То есть мы
работаем за количество дисчарч. Но наш алгоритм... Сколько раз дисчарчи вызываются в этом алгоритме?
Они вызываются в умножить на количество релейблов плюс один. Да, в куб.
Значит, почему? Ну, потому что, смотрите, потому что граф у вас ассоциклический, да, с интересными
релейблами. То есть это означает следующее, что когда вы делаете разрядку, весь этот избыток
переходит в вершины, которые пока не выполнены релейбл, они переходят в вершины, которые находятся
дальше по списку, ну или высоты. То есть это означает, что если вы дошли до этой вершины сейчас,
то перед этими вершинами, то есть перед этим у вас тут в этих вершинах избытка нет и не появится,
пока им не до ближайшего релейбла. То есть тогда получается, если вы дошли до конца, значит вы
такжественно зачистили все избытки. Так, нет, не так. Вот, такжественно зачистили все избытки. Вот так.
Да, и более того, и пуши мы делаем именно только в сторону топологической сортировки. Так что вот
такая красота. Уже, кстати, не самый неприятный пишущийся алгоритм, не правда ли? То есть какой-нибудь
с СТД листом вообще на халяву напишете. Чего? Нет, вам из середины очереди придется доставать вершину.
Да, мы всегда начинаем сначала, но потом ты в середине останавливаешься и перетаскиваешь
элемент в начало. То, что ты достал из очереди, ну ты зря достал. Да, мы не удаляем, мы идем по
очереди, но как бы это. То есть мы проходимся по списку. Вот, но в принципе это уже можно написать,
и как мы уже выяснили, это уже работает за В куб. Ну, формально за Ве плюс В куб, но понятно,
что это В куб. Потому что у нас проходов мало. Потому что у нас проходов В квадрат. Почему В
квадрат? Потому что каждый проход заканчивается релейблом. А релейблов у нас В квадрат. Ура,
да здравствует у нас. Ну вот, В куб плюс Ве. Ну, В куб формально плюс Ве, но как бы. Потому что это
единственная причина, когда у тебя Ве может оказаться больше, чем В куб. Но в противном случае
Е это не более чем. Да, можно сделать там формальную симптомику. Можно, да, а если аккуратно делать,
получится симптомика В куб плюс Е. Ну, где Е уходит именно на склеивание. Ну ладно, В плюс Е там,
но В вписывается в В куб, поэтому да. Вот, но это уже такие там просто прикольные мелочи. Вот,
так что в принципе, казалось бы, да, алгоритм. То есть в принципе, кажется, что действительно,
можно остановиться, но есть еще более просто пишущийся алгоритм.
Вот. Нет, очень маленький. Нет, ну на самом деле, ну маленький. Смотрите, и по констанции главное
по коду, потому что обратите внимание, что вы делаете. То есть вы делаете, то есть по коду вы
пишете буквально там push, relabel, discharge и вот пять строчек на это. Все. Ну не знаю, может вылезти.
Ну есть подозрения, но вылезти может. Ну вот, так что да. Нет, в принципе, забавно было,
когда на входном тестировании на ICPC кто-то сказал, что там какой-то задачи на поток писал,
кто-то писал прям вот это или какой-нибудь другой аналог. Потому что это не единственный алгоритм
поиска ЗВК с помощью вот этого вот. Почему? Потому что это вот алгоритм, который предлагают
кормы на компании. Ну ладно, я не гарантирую, что это придумали именно кормы на компании,
но вот они предлагают такое. Но называется, слушайте, другой алгоритм. Возможно,
еще более нагло пишущийся. Ну быстрее, не быстрее сейчас вот вопрос, конечно, но тем не менее.
Ну просто, тут сейчас будет из цикла «Ощутите красоту игры». Значит, есть такая идея. Значит,
алгоритм два. Значит, делаем ИНИТ, а дальше потом пробегаемся там. Заводим там Q,
там допустим Q. Заводим на этот раз очередь. Вот. Значит, пробегаемся.
Then. How do you think? What will be next line? Exactly. Как будто у нас другие варианты,
что очереди есть действительно. Вот.
It's almost all. Yeah, but with small detail. We should change not the charge, but push. In push we should say.
Something like that. Yeah, I know that Q does not have this method, of course, but nevertheless.
No, no, no. You should use just array used, of course. Used array or something like, for example,
if excess of U was equal to zero immediately before push, then we should insert this.
No, no, no, it's not true. Yeah, it's true. Yeah, okay.
Ну не совсем. Есть массив excess, есть массив use of. Массив use of просто хранит.
Просто вы сделали в вершину, сделали push, а вершина уже в очереди там сидит. Такое могло быть.
Все, новый алгоритм. Вот. Если она в очереди нет, потому что ты уже мог ее добавить,
по сути, кстати, да. На момент этой проверки ты мог уже добавить. Нет, а там вот том и фишка.
Проверка может выполняться по принципу, если перед push значит так избыток U был равен нулю,
значит добавляем в очередь. А нет, нет. Да, даже вот так. Да, даже вот так вчителить можно, да.
То есть может это кому-то это может показаться проще, чем какой-то там лист изобретать,
в начало какой-то пихать. Хотя, хотя плюс-минус одинаково. Но тут нет, тут просто интересно,
что просто поворачивать голову можно по-разному. Просто фишка в том, что это тоже работает за куб.
Да, немножко жалко, что я вам не даю это в качестве домашнего задания доказать,
что это за куб работает. Не было, когда-то это была красивой теоретической задачей,
ну ладно, сейчас я так расскажу. А доказательство, между прочим, очень простое. Ну вот такие,
вообразить себе это надо так. Смотрите, вот у вас изначально в вершине Q находятся какие-то
вершины. Назовем вот эти вот вершины с их обработкой. Это типа там блок 0. Ну изначально
просто это все вершины, в которые ведут ребра из истока. Но это другой вопрос. Пока вы обрабатываете
эти вершины, в очередь будет добавлено что-то еще. Это что-то еще мы назовем блок 1.
Какая симметрическая разница? Смотрите, вот очередь. То, что в ней изначально находится,
назовем блок 0. Когда алгоритм, когда мы достанем все эти вершины и подисчерчим их, у нас в очередь
добавится что-то еще потом. Это мы назовем блок 1. Обрабатывая блок 1, в очереди окажется блок 2.
Ну и так далее. А теперь выесекает вопрос. Нам жутко интересно, сколько блоков будет?
Не на столько. Ну совмещаем, что вообще в каждом блоке каждая вершина находится не более чем один
раз. Потому что юзят. Потому что каждый блок формируется, когда мы обрабатываем вот эти
предыдущие вершины. Поэтому каждая вершина лишний раз не добавится. А теперь выесекает вопрос,
а сколько самих блоков? По нашему утверждению мы оцениваем количество дисчерчей. Количество
дисчерчей это в на количество блоков. А сколько у нас блоков? А какие у нас блоки вообще бывают?
Ну блоки у нас бывают в том, что блоки бывают двух типов, внутри которых произошел релейбл и
внутри которых не произошел. А есть остальные? А вот давайте-ка, а вообразите себе ситуацию.
Бывают блоки, внутри которых вообще ничего не произошло.
Не совсем. За ее степень, плюс сколько раз вызывался дисчерч. Может, вполне может. Дисчерч может
состоять из одного ненасыщающего пуша. Так что тут такая неприятная мелочь есть.
Поэтому нет. Тут надо просто вообразить себе, что происходит с избытками относительно высот.
Вот жил-был вершин. Мы пробежались по всем вершинам, в которых были избытки. Проделали
из них пуш и при этом релейблов не было, никакие высоты не изменились. Что можно сказать про
расположение избытков в сети? Нет, они не стали нулевые. Потому что вполне вероятно,
что вы разрядили вершину, а потом в следующей вершине, собственно, все-таки наделали в
предыдущий избыток. Мы что-то не гарантируем, что эти вершины отсортированы по высоте.
Нет, при желании можно различие отсортировать их по высоте, конечно, подсчетом. Но фишка алгоритма
в том, что этого не душит. Потому что самое главное, что вам надо, будет выполнено и так.
Что же у нас произойдет? Заметим, что произойдет следующее, что избыток в целом станет пониже.
Например, максимальная высота вершины с избытком заведомо уменьшится после одного
блока без релейбла. Если у нас там все избытки находятся на высоте максимум 179, то после одного
блока без релейблов максимальная высота явно будет 178, потому что мы тут на высоте 179 все избытки
зачистим. Но избытки у нас идут строго вниз при пушах. Единственный способ увеличить высоту
какого-то избытка, это вызвать релейбл. Если бы отсортировали, там бы аккуратненько понизили,
но на самом деле достаточно, оказывается, ввести еще один потенцеваль.
Блока в блоках с релейблами, вот так скажем, их не более чем в куб. Сейчас мы ее формализуем.
Мы вводим потенцеваль, как вон тот потенцеваль, только не sum, а max.
Давайте будем потенцевал и хранить максимальную высоту избыточной вершины.
Для простоты будем считать, что t здесь тоже учитывается,
но для того, чтобы у нас не выяснилось, что вершин нет, поэтому потенциал
резко ушел в минус бесконечности. Это уже будет модификация, но просто нет, можно,
но просто зачем, когда у вас есть уже вот это? Уже проще написано. Давайте докажем, что мы докажем.
Заметим, что потенциал, если у нас есть блок, который без релейблов, то в таком блоке потенциал
уменьшается на один, хотя бы на один. Но каждый релейбл, обратите внимание, увеличивает потенциал
насколько? А можно точнее оценить. Потенциал, он увеличивает на не более чем разность высот,
на которую этот релейбл вообще вершину поднял. То есть если релейбл поднял вершину с высоты 57 на
высоту 179, то тогда и потенциал этот увеличился не более чем на 122. Логично, да? Вот. Но таких дельт,
если дельты именно по всем вершинам просуммировать, то тогда получится сколько там,
2v2. Ну 2v-1 на v-2, если быть точнее. Ну тогда получается суммарно потенциал увеличивается не
более чем на o от v2 при релейблах, а без релейблов каждая фаза его уменьшает хотя бы на один.
Значит фаз без релейблов тоже o от v2. Ну может возникают, но зато какой кот. Впрочем, да,
кто-то нам уже предлагает активно какие-то ноты. Давайте на каждом шаге их отсортируем,
да, чтобы красиво было. Ну да, потому что на самом, да, а если есть задача написать код попроще,
то сейчас вообще ощутите кайф.
Во. А вам слабо. Вот просто вот-вот вообще в тупую. Никаких очередей, никаких сортировок,
просто вот. Да, доказательства абсолютно тоже самое, как вы догадались. Ну по красоте кода,
да, доказательства абсолютно такое же, как вы понимаете. Да даже не блок, просто итерация влайл.
Просто пробирайтесь по лишним алгоритмам. Ну смотрите, тут два варианта, либо вы берете тупо по всем
вершинам, либо вы где-то там в пуш увеличиваете константу пуша на то, чтобы там поддерживать
эксцессы. То есть да, конечно вы скажете, что тут надо как-то избытки проверять, но понятно,
что в реальности это проверяется, что просто помечаем тут флагом, называется, а был ли тут
избыток на самом деле и в общем-то все. То есть если пробежались влайлом и избытка нигде не
нашлось, значит бляк, все. Не, это называется, это больше похоже на предподсчет, скорее предизучение,
потому что это называется, потому что тут ситуация такая, вы пишете все эти алгоритмы,
там разными способами видимо там какими-то, исследуете какой из них там лучше и быстрее и
соответственно лучший заносите себе в Team Notebook. Все. Это делается естественно до контеста.
Правда парадокс в том, что конечно не один из этих алгоритмов конечно старого доброго
Деница вам не отменит, потому что скажем таким образом про сочетание на 100 тысяч вы не пихнете,
поэтому Деница вам писать придется. Вот так или иначе. Но с другой стороны, если у вас там
просто граф на 200 вершин, то можно написать и это и будет кайф. То есть формально вообще могло
быть распространено мнение о том, что в Олимпиадах может быть это все вообще не надо.
И вот потому что. Пуши лейбл. Не, не, не, не. Тут вас приветствует команда Mipshovermasters,
которая буквально позавчера написала контест, в котором две первые халявы решаются потоками.
Нет. Идея на потоке есть, но писать там потоков не надо. Чего? Нет, может вы задачу нет,
может в эту задачу г, конечно, сдали, конечно, там какие-нибудь жаги, может какой-то доказатель.
Ну там тупая дпшка, следующая да, но как бы следующая из. Потому что по
принципу там напишите сети, давайте искать минимальный разрез в ней, ну как выясняется,
что в ней динамика ищется. Но в задаче е в общем-то тоже. Только вам прямо сказали,
найдите поток, да. Вот, да, это конечно весело. Так, ну ладно, да, хорошо. Ой,
надеюсь Глеб Костырев не будет сейчас смотреть это видео достаточно быстро, потому что,
ну я просто хотел, чтобы этот контест они тоже написали. Вот, это вот как-то да,
а то они решили отдохнуть перед гуиром. Да, но судя по результату, это помогло не очень.
Ну плюс одну ничья получилось, но по штрафу как бы вы были сильнее, да.
Почему? Рассмотрим, ну вот у нас значит, вот у нас этот нотоносец, ну только там, понятно,
линии у нас не 5, а 2v-1, ну в смысле 2v. Вот, и вот, допустим, у нас есть ноточки с избытком.
Спрашивается, теперь мы, куда девается избыток? Из каждой вершины избыток девается на высоту
строго на один меньше. Да, то есть они тут как угодно, но теперь рассмотрим вот вершины на
самой высокой линии. Тогда весь их избыток опустится. Ну дискчарч занимается тем,
что опускает избытки. Да, если релейбл не случился, тут вообще в процессе, мы тут везде
пробежали, релейбл не случился, тогда все избытки опустились, в частности с верхней линии избыток
опустился. Чего? В каком их? Нет, у нас дискчарч заканчивается ровно в одном случае, пока
excess больше 0. То есть пока есть что пихать, пихаем. Так что вот такая красота. Так,
еще тут какие-то вопросы? Вот. Да. С корнем? Нет, ну с корнем не знаю. Нет, ну нет, есть алгоритм
какой-то в 8 точке, в котором возникают корни. Вау, лог в квадрат, лог в квадрат делить на е.
Я понимаю, да. Ну как бы за ве лог ве умею. А, и вы умеете. Ну это просто 1 и в процессе линкад.
Мы это в прошлый раз обсудили, но это именно лог в, а не в квадрат делить на е.
Нет, Сеанора. Какого Сеанора? Нет, линкад это слейтер Атальяна, не путайте. Чего? Сеанор? Где?
Сеанор? Не-не-не, другой какой-то. Нет, линкад-то понятно, да. Нет, просто нет. Нет, ну тут
действительно возникает вопрос, да, как тут упихать за в квадрат делить на е, действительно. Я прям даже
интересно, можно ли вообще глядя на это, сейчас просто на халяву упихать за в квадрат делить на е.
Но тут возникает вопрос, откуда можете оставить 7 точек вообще в квадрат делить на е.
Это не он. Да, но это не он. Да, но нет, этот может, наверное, за единицу пихнуть, причем так,
что мало не покажется. Да, вариант билда. Так, в квадрат делить на е, типа там доказывается,
что фаз мало, что ли, вот этих вот или шо. Или там типа аккуратно гарантируем, что у нас релебов
будет мало. Как это выказано, непонятно главное, как из большого е делать.
Здесь написано на википедии, как это называется. На английской википедии? Ну да, конечно.
В квадрат делить на е. Нет, давайте потом. Откуда такая 7 точка взяться может вообще?
Ну, наверное, там какой-то есть потенциал, что происходит. Нет, ну там есть, но там непонятно.
Ну там щит, конечно, такой понятный, не очень. Нет, там нету. Возникает, конечно, нет, прям страшно,
а там прям точно страшно. Или возникает просто мысль такая, как Рома предлагал, давайте отсортируем
вершины. Идея такая, давайте отсортируем вершины в порядке убывания высоты и будем
делать дискчарч именно в этом порядке. В чем более того, даже еще в качестве прикола,
давайте делать не просто дискчарч, а типа если надо сделать релебл, то мы в этом месте остановимся.
К чему нас это приведет? Приведет к тому, что мы за О от В плюс Е, обратите внимание,
значит какую-то воду протолкнем, какую-то совсем до упора протолкнем, а все остальное будет что?
А потом все остальное повышаем куда-то. Да, потом можно сказать, а давайте теперь прибежимся снизу
вверх и будем делать релеблы. А может АВ, а впрочем по барабану. Ну просто что, идея в том,
чтобы все сразу релеблы сделать. То есть фишка на самом деле в том, что мы потратили все эти пуши
в Ве плюс количество дискчарчей. Получается за фазу. Если потенциал брать в качестве суммы,
то значит мы уменьшили потенциал. Причем кажется, что не на единицу, а может быть много вершин.
А потом сделали кучу релеблов.
То, что здесь написано, в основе этого алгоритма, некий ахуджа энд орлин, добавили скейлинг и смогли
запустить этот алгоритм за обольшую нм плюс р квадрат лог у, а потом привязав к этому динамик 30,
вот конечно динамик 30, а просто линкат.
Да, линкат. Смогли добиться 8 точек и уже вот так.
Интересный вариант. Нет, ну линкат-то да, но осталось только выяснить. Осталось только придумать,
где. Возможно, правда, для этого нам придется понять, а что такое масштабирование и как оно работает.
Нет, в нашем случае это мы как бы следующим заходом, но давайте так.
Пока остановимся, хотя в принципе интересный этот момент, подумать.
Ну, значит, смотрите, ладно, потому что у нас в принципе появится алгоритм за VE лог V, это тоже неплохо.
Вот, но до этого она. Хотя нет, VE лог V неинтересно, он уже появился, а вот VE лог C.
Где у нас VE лог V появился?
В Диннице.
Ну, у нас был алгоритм Диннице, да.
Но у меня за VE лог V работает.
Ну, а почему, ну вот.
Там идея такая, ну просто если вы для каждой ноты вы в Диннице храните от каждой вершины указательный указатель, да.
Так вот, идея такая, если рассмотреть все эти ребра, на которые эти указатели смотрят, получится по две, там, лес-деревьев.
Вот, ну там, фишка заключается. То есть давай.
Но это на халяву или как-то по-другому?
На халяву.
Просто одна секция.
Сейчас.
Здесь есть section 5, use of dynamic trees, и здесь просто описывается, как сюда припушиваются.
Да, но это сюда, это в смысле в их какой-то новый алгоритм, который...
Нет, нет, нет. Ну, здесь кажется, что...
А, пропушили label? Так.
Ну, в крайней мере, первые четыре секции показывают то, что мы сделали.
Нет, ну, конечно...
Ну, такой, конечно.
Вообще говоря, когда, если мы начинаем уже соединить совершенно на слои по высотам,
то их, ну как, обновлять все слои label для...
Ну, пишем сразу, и у нас discharge написано вот так, как тоже.
Мне кажется, мы сейчас просто изобретаем, как мы делимся.
А дальше уже, может, VIRON может прокрепить, и VINCA, и все.
Кстати, ну, я не всем понимаю, вот кажется, вот этот способ, потому что VIRON нормально не делается.
Ну, этот...
Ну, с масштабированием, да, тут напряг.
Нет, я догадываюсь, откуда тут можно взять линкат.
Да, опять же, стержи указателей.
То есть, если мы возьмем все ребра, на которые сейчас вот этот смотрим дисчак,
ну, допустим, по этим ребрам можно нормально push делать,
то тогда из этих ребр можно действительно сделать подвешенное дерево, это да.
Ну, там фишка-то, они делаются...
Ну, там, видимо, идея в том, что давайте возьмем целый путь,
и на нем прям супер-пуш.
Прям супер-пуш на нем сделаем, да.
Потому что суммарно беготнее лишний раз с итератором их будет VE все равно, да.
Но это уже похоже на Денису.
Да, на Деница, да.
Ну, похоже.
Ладно.
Нет.
Ремарк.
Ремарк.
Ремарк.
Ремарк.
Ремарк.
Ремарк.
Нет, здесь ничего.
Ну, давайте так.
На всякий случай давайте...
Так, ладно, давайте вспомним.
На всякий случай и так надо вспоминать, откуда он с Линкадом Деницем брался.
Значит, на третьем.
Давайте вспомним.
Линкад Деницем брался следующим образом, смотрите.
То есть, когда у нас есть вот эта вот сеть, веселая, да,
то как бы у нас в каждый момент времени,
у каждой вершины был итератор,
который смотрел на какое-то ребро.
Так вот, если рассмотреть все,
в каждый момент времени рассмотреть все
ребра, на которые указывают все эти указатели,
то получится набор деревьев
подвешенных.
Одно из них подвешено даже к вершине T.
Идея, на самом деле, такая.
Понятно, дерево может быть какое-нибудь
произвольное, куда-нибудь рандомно
подвешенное, не туда.
Пока у нас вершина S,
значит, идея теперь такая,
что
говорим,
смотрим, куда подвешена вершина
S.
Если вершина S подвешена к вершине T,
то мы
берем весь этот путь.
На нем делаем прямо за логарифом
единый пуш на минимум на нем.
Это делается с помощью линкада.
В линкаде будет такая отложенная
операция, сделай пуш по моему
ребру.
Не только по моему, а по всему,
что у меня там есть.
По сути, пуш на пути.
Только возьми теперь вот этот минимум
и сдвинь на нем указатель.
А сдвиг указателя, это что такое?
Это переподвешивание.
Еще бывает, что из S путь у вас
ведет не в T, но значит, вы доходите
до конца этого пути и, соответственно,
сдвигаете
последнее ребро.
Или выясняете, что там уже
больше некуда сдвигать, значит, вот это
сдвигает.
Но тогда это означает, что вы там
шли-шли-шли-шли и куда-то
пришли. Тогда надо просто видим
вот это ребро идет неправильно, надо его
сдвинуть.
Последнее на этом пути. Или если его нет,
значит его убить и тогда уже... Но это все
равно wild true.
Потому что
это
идентично
обычному алгоритму Деница.
Кончится просто тем,
что
у вас просто путь будет состоять из одной
вершины S, потому что даже из вершины S закончились
ребра.
Но это и будет означать, что алгоритм Деница
закончился.
Но при этом заметим, что
интераций у нас немного, потому что каждая
интерация тут либо сдвигает
либо убивает ребро и все равно сдвигает
итератор. А сдвигаются суммарно
итераторы за E.
И каждый работает с алгоритмом.
Потому что это линка.
Нет, yellow V.
У вас yellow V.
А фаз Деница у вас V,
поэтому
этого получается yellow V.
Здесь то, что
мы хотим применить
пушилей.
Здесь пушилей будет тоже
какой-то пушла.
Нет,
здесь тоже
возможен там действительно, видимо, фишка
в том, что если я тоже буду в каждой вершине хранить
итератор на то, что я могу
сделать, то, конечно, эти итераторы тоже будут
что они будут?
Они тоже будут образовывать такие
подвешенные деревья. Правда, корень будет внизу
где-то.
И тогда, по идее, для каждой вершины
и вот тут сверху вообще можете сказать
ой, а давайте возьмем
допустим возьмем этот
эксцесс и прям допустим его полностью сделаем.
Чего?
А потому что из каждой вершины исходит
ровно одно ребро, которое мы сейчас смотрим.
Вот.
Да, но правда
это такая модификация, это не совсем
пушилей был, потому что мы как бы
на пути мы тогда будем пропихивать
столько потока сколько здесь,
а там теоретически ниже мы могли бы этих
пушей делать побольше.
То есть тут
надо поаккуратнее в этом плане делать.
Наверно
подразумевается, что где-то вот в этом месте мы
тут можем себе там обхалявить жизнь каким-то
образом. Вот.
Видимо куда-то в эту сторону
надо думать, но возможно они там придумали
что-то еще, я не знаю.
Да, ну
не откажусь.
Кстати,
пришли, пожалуйста, будет действительно интересно.
Еще здесь есть такая интересная
ремарка.
Срочу алгоритм все очередь.
Потом написано,
что
какие-то индусы умеют пропачкать, что это работает
не за m-ку, а за m-ку над корень.
Какие...
Корень, а ну корень из m, да.
А ну при ликвидации кратных
ребер, да это строго не хуже, вот так
скажем.
Не сказать, что строго лучше,
что m бывает в квадрат, но
да, но не хуже заведом.
Ну, допустим.
Так, ну выбирать.
Нет, самое смешное, да, что нет, в принципе
можно вообще поддерживать
там, скажем так, можно вообще поддерживать
на самом деле самую большую высоту, можно
поддерживать даже вроде без особой потери
асимптутики.
Но она как-то там, что при пуше, она все равно
меняется не более чем, максимум
меняется не более чем на один.
Так, хорошо.
Так.
Ну, понятно, да.
Мы сказали, что этот способ
работает за n квадрат
корень из m.
То есть на самом деле достаточно сортир получается?
Нет.
Ну, не совсем сортир,
именно на каждом шаге найдем
из всех вершин выберем вершину с максимальной высотой.
Ну, в принципе это легко делается на самом деле.
Давайте, то есть давайте для каждой высоты
хранить какие вершины у нас сейчас
на этой высоте есть.
Ну, избыточные естественно, да.
То есть при пуше это
поддерживается элементарно.
При релейбле в общем-то тоже,
потому что при релейбле у нас есть запас по времени.
Точнее так, при релейбле делаем так.
При релейбле мы можем это сделать
просто там.
А, в прочем,
неважно, потому что если выполнили
релейбл и вершина повысилась до какой-то высоты,
можем проверить, не максимум ли это.
То есть поэтому в релейбле вообще
проблем нет, с поддержкой максимума нету.
ну вот а если мы вот с этой высоты делаем там пуш то тогда высота уменьшается не
более чем на один поэтому за вот единицей и находимся равно ну как
может добавиться может нет но смотрите как а элементарно потому что а какая
будет максимальная высота если был ри лейбл то это он а если а если ну если в
процессе директоре был ри лейбл то это высота то это вершины будет но а форте
нет это вершины не будет потому что она не интересная потому что у них сейчас
избытка нет а на смотрите а давайте так утверждение такое если выполнить
и был ри лейбл то самая высокая вершина интересующая нас находится в высоте в
новой высоте этой вершины минус 1 ну потому что мы после потому что мы эту
вершину значит последний раз 10 и могло быть несколько ри лейблов да но когда мы
последний раз устаканили на ее высоту и собственно полностью разрядили но это
мы сделаем только пушам и тогда пуш привел к тому что на высоте вот это минус
один есть избыточная вершина так что следует на высоте но то она тут точно
будет поэтому значит новая максимальная высота это вот этот ри лейбл минус 1 да
ну господи как это нет да да да ну да к сожалению не могу сказать на камеру как
имский там с кай хабом дочь и дочь что пользоваться какой там александра в
океан там лишь не могу такие фамилии называть да ну а не там доказали где-нибудь
на 27 странице там типа как мелкое утверждение
господи мясо мясо мясо нет смысла что нет нет что что что доказывать то я не
понял вот мы сделали и был до вершина в итоге попало на высоту 179 тогда куда
она последний раз дело куда она делал свой избыток с высоты 179 когда она только
попала в экшен 179 избыток в ней был куда она делал свой избыток в какую-то
вершину на высоте 178 вывод утверждение значит тогда на вершине стоит но так
как эта вершина была по максимальной по высоте то 179 это еще больше значит вывод
макс больше чем 170 178 высоты не будет 178 достигнута то есть вывод
но вот так что то есть это то есть как бы вот то есть вот какой-нибудь вот подобного
рода алгоритм можно реализовать там без особой потеря симптутики да
вот так что-то то есть другой вопрос чем это поможет вот да вот нет а вот
они просто в тупую находить жадную максимуму вообще-то само ну понятно что
сатурейта да сатурейта двое это мы знаем мы разделяем вот так покажем что
вот так вот так ладно давайте ладно не во время лекции наделать потому что как бы это
можно было бы делать если якобы все но на этом у меня материал на семестр закончился но есть
одна проблема он не закончился и более того мне даже здесь еще и кое-что есть нет погодите мы
вот здесь мы должны обсудить другое как харлайд закуп пихать теперь не закуп лог ц там до логовая
точнее да там лог бен поиск вот этот вот да а я утверждаю ну потому что как у нас был устроен
харлайд напомню да так но тут надо вспомнить как у нас был устроен решение задачи харлайд
так да да мы делаем над так но теперь но тут нам как бы уже придется вспоминать как мы конкретно
делали сеть вот мы че говорили так вот допустим у нас есть с и мы хотим понять существует ли
подграф плотности строго больше чем ц помните да вот то есть но вот но что такое но мы говорили
е ж 3 дилить на модуль ваш трех должно быть строго больше чем ц это это верно тогда и
только тогда когда 0 больше чем ц модуль во штрих минус модуль е штрих и мы пытались строить
сеть с отрицательными ребрами так чтобы у вас там пропускная способность разреза была такая
помните да ну правда с отрицательными ребрами мы решили там с отрицательными ребрами ведущими
там сток мы проблему решали было дело ну давай но правда давайте вспомним как
вот что такое ц от в штрих то есть там ц в штрих ну чтобы вот эта штука попала
в разрез надо просто говорить что давайте из каждой вершины то есть ну
как всегда мы там у нас есть вершины есть и сток и сток то есть как всегда у
нас там есть и сток есть сток и с каждой вершины в мы отправляем веселое ребро
пропускной способности с но это типа что если то есть вы говорим что в этой
доле разреза у нас все что мы берем под множество а в то что не берем
понимаете да вот но откуда взять минимум но что такое и штрих и штрих это
получается все ребра которые ведут из доли с в долю с правда вот значит тогда
идея такая но заметим что е штрих то есть из доли с в долю с это на самом деле
равно ц модуль в штрих минус как там получается минус модуль е плюс е 2
штриха придумали мы где я два штриха то есть как бы это все ребра которые не из
этого множества понимаете да так значит но вот можно было бы придумать так но мы
придумали по-другому потому что на самом деле вот потому что на самом деле нам
захотелось сказать что как бы что такое ребра торчащие из ве штрих это как бы
ну как бы ребра то есть если у нас из какой-то вершины вы торчит ребра она лежит ве
штрих из нее торчит ребра то она ведет либо ве штрих либо куда-то еще правда вот но
правда но вот но правда теперь вот у нас идея была такая мы тут домножаем на два то есть
мы хотим вот то есть 20 ве штрих и тогда вот у нас идея такая что если я присуммирую то есть
если я просуммирую все степени всех вершин ве штрих то что у меня получится то у меня получится
что все ребра которые ведут из ве штрих ве штрих учтутся два раза а все ребра ведущие из ве штрих
не ве штрих учтутся один раз правда поэтому получается следующее то есть вот минус сумма там
диагат ве по всем ве лежащих ве штрих плюс ну вот ну плюс получается количество ребер в разрезе
поэтому то есть идея такая что есть у всех ребер тут оказывается в обе стороны пропускная
способность объявляется один но из каждой взятой вершины мы здесь пишем не с отце минус степень
этой вершины да и конечно 20 да понятно да да правда да у нас вазикал парадокс что из
не торчит ни одного ребра но это компенсируется тем что вот эти пропускные способности бывают
отрицательные понятно да поэтому поэтому на самом деле делается то есть это так то есть на
самом деле оригинал советовал так давайте сразу тут еще просто прибавим двое ну чтобы вот эта
степень сразу убилась и здесь тогда сразу прибавим двое и у нас возникнет естественный
вопрос ну и после этого тогда возникнет вопрос существует ли вот в этом в этой уже
абсолютно нормальной сети разрез величины строго меньше чем вот этот вот а это разрез
величины там 2 модуль е на воду и ве минус 2 да или нет чего а действительно а откуда два
если теж у нас не в графе до 2 2 и вы да ну потому ну вот ну потому что у нас тут когда мы тут
суммируем то там степени то как бы каждый ребро кто бьет из в 4 в 4 будет учтено два раза вот
ну вот что но вот но нет нет просто идея такая вот просто вот 2 е штрих то есть ребра из
свс их учитываем так просуммируем все степени в штрих тогда эти ребра учтены два раза но при
этом есть еще ребра кто ведут из ве штрих куда-то еще они как бы и учитываются один лишний раз
поэтому тут вот минус это и плюс разрез по этой логике это называется почему мы не модуль
пишем ну хорошо допустим а чертова знает зачем может потому что потоки там всякие не знаю ну да
ну на самом деле да ну вот но потому что нет смысла что значит корректно но потому что если
я к любой вершине добавлю вот такие два ребра тут плюс 2 и тут плюс 2 то величина любого разреза
увеличится ровно на двое чем не важно это вершина попала в левую долю или вправо
ну по-разному можно дам вот а теперь красота но вот теперь вот эти карты просто хорошо такой
максимальный поток в таком графе мы научились пихать за сколько но то есть мы нет поток мы
вот но вот но да получается но то научились пихать за выкуп и получается hardlife мы умеем
риск решать за в куб логовая получается потому что ну а потом ну потому что там реальный бен
поиск там за в квадрата там на лог в квадрата потому что там всего в квадрат дребей отдельный
вопрос как там организов generating ну как там организовать на самом деле бин поиск он
с другой стороны, пока у нас асимптотика с кубом, можно просто эти дроби честно
выписать и отсортировать, и потом по ним реально честно бинпоиск делать,
то есть решение получится еще и в целых числах, но на самом деле тут фишка оказывается в том,
что на самом деле от бинпоиска можно здесь избавиться, потому что у нас сеть очень красиво
устроена, давайте представим себе, что мы движемся по вот этим вот С в каком порядке,
но мы да, поэтому в бинпоиске у нас будет вопрос, существует ли подграф, у которого степень больше
чем С, но не совсем, если идти по убыванию, то как бы смотрите, мы для предыдущего С нашли
какой-то ответ, но выяснилось, что некоторые вот тут ребра могли перенасытиться, потому что вот
возможно в предыдущем потоке ребро оказалось насыщенно, у нас там было все в порядке,
но нам идея такая, нам при каждом С хочется найти максимальный поток, даже другой вопрос,
к чему он там равен, это нам даже не так важно, но допустим мы при каком-то идее такая, при каком-то
С мы нашли максимальный поток, а теперь давайте уменьшим С чуть-чуть, то есть допустим С там
перешло в какой-то там С штрих меньше, чем С, вот тогда что произошло, тогда могло произойти,
но заметим какие проблемы возникли, проблемы возникли только в том, что у нас у этих вот ребер
пропускная способность уменьшилась, а это означает, что в предыдущем потоке могли быть
проблемы, но правда, если там течет по ним вода и все равно так, чтобы тут в 2 С штрих
укладывается, значит все в порядке, но если как бы потока там течет много, значит мы этот лишний
поток отменяем, как мы его отменяем, то есть на самом деле мы просто говорим,
что у нас то есть эксцесс от этой вершины резко стал больше нуля, причем обратите внимание,
немножко парадокса, да, у этой вершины может быть какая угодно высота при этом,
да, важный момент, обратите внимание, да, мы как бы высоты остаются с предыдущей террацией,
смотрите тут просто чит возникает такой, дело в том, что когда вы тут делаете избыток,
вот это ребро остается насыщенным, поэтому с этим ребром там никаких проблем с вот этой вот высотой
не будет, да, вот, ну как бы заметим, что у нас инвариант на ребра никак не зависит от избытка в
принципе, да, поэтому как бы мы просто делаем избыток так, чтобы не произошло ничего лишнего,
да, то есть просто отольем и продолжим работу, ну понятно, да, эксц понятно будет больше нуля и
продолжим там любой вот этот алгоритм, то есть заметим все асимптотики обратите внимание будут
выполнены, то есть там любого из этих алгоритмов они продолжат быть выполнены, вот давайте самое
простое рассмотрим вот эту например алгоритм будем делать, то есть на каждой его итерации будет
то же самое, то есть либо высота уменьшится, либо мы выполним релейбл, да, что нет, а вы симптотики,
но утверждение такое, что дело в том, что ну как бы хочется сказать, что мы как будто суммарно как
будто пихаем поток один раз, а не много, это правда, оказывается в некоторых, ну не совсем так, но
просто смотрите, вот у нас было доказательство, что один раз мы ищем, пока эксц есть и как бы все
нормально, да, единственная разность теперь происходит, что иногда у нас как бы избытки
появляются просто сами собой по внешним причинам, но каждая такая операция увеличивает наш избыт,
то есть увеличивает потенциал не более чем на 2v, правда, вот этот, да, увеличивает на 2v и делает
она это не более чем в квадрат раз, потому что у нас всего в квадрат сэшек вот этих,
какой вы, ну вот, то есть тогда получается суммарно потенциал, ну вот так, нет, никакой, мы не делаем бинт,
вот такая фишка, мы не делаем бинт поиск, мы идем аккуратненько, а хотя нет, погодите, если потенциал
суммарно увеличивается на v-куп, то у нас итерации вот таких v-куп дает v в четвертый, нет, пока еще,
нет, пока еще рано радует, нет, надо додумать, так,
нет, мы должны убить лог, поэтому, то есть, что мы идем вот как-то вот,
вот мы смотрим, считаем для начала для правой границы поток, вот этим, да, теперь берем центр, считаем для него, если для него все плохо, откатываемся, если неплохо, переходим...
Ну откатываемся, прям заново совсем придется откатываться.
Если откатываемся к тому, что было для правой границы, ну тогда там...
Все еще будешь делать горифом запуска в поток, вот этих вот, которые наследуются...
Нет, нет, нет, если откатываешься заново, то там, извините, работа с потенциалом вылетает в трубу.
Мне гарантия, что у тебя то, что ты от того откатываешься, это будет нормально.
У тебя все хорошо будет, как будто все равно будет тебе честный еще один запуск в поток.
Вот, поэтому, да, ну-ка, ну-ка давайте аккуратненько, да, тут не все, ну вот, то есть, да, хочется, конечно, да, хочется сказать, что тут действительно как-то аккуратнее, да,
то есть потенциал у нас, конечно, называется, может неожиданно возрадоваться.
Это не, ну как не сильно, ну, насколько-то, а нам, нам пока, как бы пока мы никак не пользуемся тем, насколько это уменьшилось.
Я, я, я, я всем то, что отцы никак не зависит, кстати.
Вот, нет, у нас просто фишка, что, как бы, были какие-то избытки, то есть были, были у вершины какие-то избытки, и неожиданно выяснилось, что там, на ребрах, на ребрах, причем, правда, ребрах ведущих, правда, в Т.
Нет, хотя нет, эти ребра все еще насыщенные, видимо, будут таковыми, но просто на вершинах появились еще какие-то избытки, которые мы начинаем еще куда-то пихать.
Вот, возникает естественный вопрос, почему, почему, то есть почему, как бы, ну вот, то есть как бы, то есть совсем, совсем примитивный анализ у нас пока, что с кем, то есть мы замечаем, что так как мы тут, то есть замечаем, что мы, получается, в квадрат раз увеличиваем потенциал, ну вот, и это, а, стоп, погодите.
Нет, нет, потенциал увеличивается на а от в, и он делает это в квадрат раз в процессе.
Нет, да, мы и по высотам просто избытки, а, хотя нет, у меня есть неожиданный чип.
Идея такая, вот у нас есть отсортированный массив вот этих в квадратах, да?
Так вот, идея такая, давайте возьмем в этом ряду каждый в этот элемент.
Возьмем каждый в этот элемент.
Запустим этот алгоритм, запустим этот алгоритм только на этих дробях.
Вот, тогда у нас потенциал будет увеличиваться в процессе не более чем в раз, каждый раз увеличивается на 2v, не более чем 2v, значит получается добавление к увеличению потенциала суммарно не более чем от v квадрат, значит все еще v куб.
Вот, да.
Делим на выпусков, находим в каждом.
Нет, в каждом мы ничего не находим.
Идем с конца.
Вычленяем под последовательность длины v, вот так.
Такое, что между каждыми двумя элементами тоже не больше чем v элемента.
Да.
Ну вот, да.
А какая разница?
Сейчас увидим.
Идем с конца, делаем вот эту штуку, до тех пор пока мы можем.
Пока не есть, надеюсь, первый раз.
Первый раз мы нашли штуку на которой меньше.
Хорошо, значит начнем предыдущий, а от него пойдем просто по элементам до этого.
Можем даже заново запустить.
Были две дроби, вот для этой все хорошо, а для этой уже нет.
Ну и мы просто идем здесь вот сзади, потому что между ними очень мало.
Так.
Ну вот.
Вроде работает.
Ну это не кажется, просто два раза по кубу получилось.
Ну как нянчка мы берем.
Так господи, что за умирание, господи.
Ну для того, что смотрите, нам нужно, скажем так, как бы мы умеем делать это как бы
за В куб, если у нас вот это уменьшение проходит не более чем В раз.
А у нас дробей В квадрат.
Поэтому идея такая, давайте поделим последователь на блоки по В.
И сначала поймем в каком блоке у нас будет ответ, как мы это поймем.
Давайте в каждом блоке возьмем начало, начальную цешку.
И значит для этих вот, ну всего у нас тогда получится В.
Начало, начальную цешку.
И значит для этих вот, ну всего у нас тогда получится В.
Начало блока.
И для них вот за куб поймем, собственно, где там ответ между какими.
Вот.
Это мы поняли за куб.
То есть, но теперь у нас тогда остался блок и в блоке вариантов тоже В.
Тоже В.
Ну вот мы берем В, например, а не 2х, чтобы получить тот же бинпоиск.
Мы сейчас делали бинпоиск, но делили не на две части.
Потому что мы, ну потому что, ну чтобы блока рифмы избавиться.
Тупой бинпоиск делал все это за В куб блок В.
Потому что мы заново запускали поток.
То есть у нас есть переменная кат, которая зависит.
А, все я понял, все.
Ну вот, да.
Да, тут нетривиально немножко, но тем не менее, да.
Что оказывается просто этот алгоритм устроен так, что как бы если я там, допустим, у меня есть,
от В раз у меня неожиданно уменьшаются пропускные способности каких-то ребер.
Причем что приятно, кстати, обратить внимание, абсолютно любых ребер на самом деле.
То есть на самом деле эта технология говорит нам следующее.
Мы можем просто сказать, что, ой, а у нас, допустим, у нескольких ребер неожиданно уменьшилась пропускная способность.
Нам сейчас абсолютно было плевать на то, что эти ребра обязательно ведут в Т на самом деле.
Это могут быть любые ребра.
То есть надо их просто разно...
То есть там просто на заданную высоту как бы.
То есть если там лишнее что-то образовалось, значит объявляем тут избыток и продолжаем.
То есть главное, что это прям именно пачкой получилось.
То есть если таких...
То есть как бы понятно, мы там...
То есть каждую пачку мы можем обработать так, что вот асимптотика куб от этого не потерялась.
Почему после...
У нас мы запустили...
Если мы сделали вот ваитрац, идем с конца, да?
Да.
Почему после последней предпоследней будут работать за, понимаем, за В квадрат?
Нет, она не верна, что каждая итерация будет работать за квадрат.
Верно, что суммарно все это будет работать за куб.
Нет, да.
Да.
В квадрат.
Нет, ну смотрите, у нас так...
Но нам известно, что...
За счет чего у нас вообще победа, да?
Напомним вот алгоритм.
У нас есть потенциал, и он говорит, что там вот каждый лишний вайл, да?
То есть каждый вот этот фор, да?
Ну то есть сколько у нас этих форов вообще?
Ну потому что, да, мы говорим, мы работаем с в.е. плюс калибры.
Сколько у нас этих форов вообще?
Ну потому что, да, мы говорим, мы работаем с в.е. плюс калибры.
Спрашивается, сколько вот этих форов будет?
Мы хотим доказать, что вот В квадрат.
Почему мы это говорим?
Потому что мы замечаем, что у нас как бы все форы делятся на те форы, в которых были релеблы, а их так и так В квадрат, да?
А есть те, которые без релебла, но они уменьшают потенциал.
Остается только убедиться, что суммарно потенциал увеличивается не более, чем на В квадрат.
Ну релеблы его увеличивают суммарно на 2 В квадрат, поэтому это нас устраивает.
Но теперь к ним прибавляется еще увеличение потенциалов, которые есть у нас, то есть которые вот за счет этого.
Но так как каждое конкретное добавление вот на все ребра, то есть если мы один раз скопом все ребра уменьшили какие-то,
то тогда потенциал увеличивается не более чем на 2 В, потому что максимум.
Следовательно, если мы делаем это не более чем в раз, то суммарно потенциал увеличился еще дополнительно на О от В квадрат.
И это нас устраивает. То есть куб остается жив, потому что высоты мы не обнуляем.
Продолжаем его запускать. Высота не затирает, совершенно верно.
То есть алгоритм обладает таким свойством.
То есть блокирующие потоки тут, кажется, просто так не помогут.
А вот в процессе Push Relay вот оказывается уменьшать ребра можно.
Увеличивать ребра это, конечно, проблема, потому что если вы увеличите пропускную способность ребра, то проблемы могут возникнуть.
Хотя нет.
Хотя, кстати, увеличение ребра, если у вас у какого-то ребра неожиданно увеличилась пропускная способность, то это тоже не проблема.
Потому что мы говорим, а давайте-ка из этого ребра просто по максимуму пихнем воды, и избыток будет здесь.
У вас два варианта. Либо это ребро торчит вверх, там ведет куда-то вверх, и тогда избыток, и тогда ничего вообще не меняем.
Либо это ребро ведет куда-то вниз.
Тогда вы говорите, а давайте-ка пихнем по максимуму из этого ребра, и избыток тогда будет внизу.
Тогда по новым тогда не нулевым ребром будет обратное ребро, но будет торчать ветвь, и у нас победа.
Да, это если увеличиваем.
То есть получается вот такой неожиданный чит.
Ну, в данном ноте.
Чего?
Ну, эксцесс меньше нуля мы делать не можем.
Тогда как мы припихиваем по максимуму?
Ну, мы припихиваем по максимуму, который на текущий момент.
А если появилось новое ребро, то нам надо добиться, нам просто надо сделать какие-нибудь, хотя нет, эксцессами просто так, может, на халяву не получится.
Здесь мы все-таки воспользовались тем, что мы все-таки из Т делали эти эксцессы.
То есть отменили какой-то поток, и тем самым просто отменили поток в Т, поэтому...
Мы, кстати, все еще умеем удалять ребро.
Чего?
Мы умеем искать потоки и удалять ребра, если у нас есть еще закуп.
Нет, удалять ребра мы умеем.
Но, правда, нет, аккуратно, просто рандомно удалять ребра нельзя.
То есть не в текущий момент.
Смотри, нельзя сказать, что мы умеем там.
Делаем два запроса.
Первое – удали ребро, второй – скажи поток.
Нет, это мы суммарно ЗВК делать не умеем.
То есть это мы делаем, только если ребра удаляете там не более чем В раз.
Вот так.
Ну, ребро вообще-то...
Нет, давайте еще раз подумаем.
Ладресу уже об этом зашла речь.
То есть что делать, если от вас попросили уменьшить пропускную способность?
Какого-нибудь произвольного, абсолютно произвольного ребра.
На этот раз не обязательно ведущего в Т.
Вот.
Так, что у нас тогда?
Сейчас.
Нет, тут раз надо добить, потому что дальнейшая тема будет уже никак не связана с предпотоками.
Вот.
Чего?
Ну вот, допустим, мы уменьшили пропускную способность.
Тогда что это означает?
Тут вопрос, какой поток тут тек?
Если потока течет меньше, чем С3 меньше либо равно, то ничего делать вообще не надо, и так кайф.
Если потока текло стало течь больше, чем С3, значит вот этот F-С3 лишний,
надо отмерить.
Но как мы это делаем?
А, правда, слушайте, нельзя это так просто сделать.
Потому что здесь XS плюс F-С3, а тут минус F.
А, да, тут проблема, потому что...
Да-да-да, тут мы все-таки пользуемся тем, что у это Т было.
Да, потому что у этого Т было.
Вот.
Вот.
А, да, тут проблема, потому что...
Да-да-да, тут мы все-таки пользуемся тем, что у этого Т было.
Да, потому что Т это единственная вершина, которая там...
Ну да.
Что, из Т типа ничего не выйдет?
Что в Т может быть там...
В Т может быть отрицательный XS.
Нет.
Нет.
Нет, отрицательный XS у нас в С.
В Т он как раз глубоко положительный.
Просто фишка в том, что XS там просто из Т у нас фишка, что из Т ничего не вытекает.
То есть поэтому как бы там...
Да, ладно, хорошо.
Ладно, это тоже хорошо было понять, ладно.
То есть мы все-таки пользуемся тем, что у нас тут ребра именно в Т и никуда, кроме...
Жаль, жаль, жаль.
Нет, может, конечно, если там на ребрах...
Ладно.
Так, ладно.
Так, ладно.
Ладно, я думаю так.
Так, по-моему так.
Ладно, давайте так.
Ладно, думать это уже можно, но я думаю точно.
Сейчас надо сделать перерыв, а потом сделать финальный наскок, собственно, чтобы разобраться с масштабированием.
Вот.
Так что вот, что мы сегодня еще и сделаем.
Ладно, давайте немножко о масштабировании поговорим.
Значит, масштабирование это тоже предслов численный алгоритм, если что.
Да, то есть напоминаю, да.
То есть там в дробях, то есть в дробных числах это будет работать только там...
Ну, там с трудом уже начнет работать.
По крайней мере, упихивать до упора.
По крайней мере, вы будете там бесконечно долго.
То есть можно, наверное, про масштабирование говорить, что у вас там вы найдете ответ,
поток, отличающийся от максимального, не более чем на сколько-то, забегая вперед.
Вот, но соответственно.
Ну, то есть у нас пока предварительная идея такая, что все...
Итак, говорим о масштабировании.
Давайте разберем тут быстренько идею.
Значит, идея такая, что все пропускные способности у нас целочисленные.
То есть это вот E в Z больше 0.
Может даже больше 0.
Вот.
И в чем заключается самый тупой алгоритм масштабирования, который делается?
Он говорит, что давайте переберем, допустим, степени двойки.
Допустим, какой-нибудь R равно 2 в степени log2C округленное вниз.
Там R больше 0, Rdiv равно 2.
Вот так вот скажем, да?
Значит, пихаем поток в 0.
То есть пихаем поток методом Форда Фолкерсона,
рассматривая, правда, при этом лишь ребра с остаточной пропускной способностью больше либо равно, чем R.
То есть по сути вы там DFS запускаете по ребрам с остаточной пропускной способностью хотя бы R.
Вот, спрашивается.
Ну, спрашивается, за сколько это будет работать.
Значит, утверждение.
После фазы, после R-фазы, назовем это R-итерацией,
останется пустить, то есть ну просто вот мы тут спустили сколько-то потока, и сколько-то нам по стоку еще осталось до максимума.
Так вот, останется пустить не более чем, даже строго меньше, чем?
R-новое.
R-новое?
Ну, R-новое оценка, которая вроде работает.
Скорее R-ное, наверное.
Ну, в разрезе у нас все.
Да, хорошо, R-ное.
Да, почему это так?
Ну, идея стандартная.
Пусть выяснилось, что по таким ребрам из S до T дойти нельзя.
Ну, давайте как всегда рассмотрим, а докуда можно.
Нашли, поставили разрез.
Пропускная способность этого разреза.
Так, разрез пересекает не более, чем E-ребер.
У каждой пропускная способность получается меньше, чем R.
Ну, потому что было бы R, прошли бы еще.
Значит, получается суммарно осталось пихнуть не более, чем Re.
Ну, тогда мистическое утверждение.
Следствие.
Ну, вот.
На каждой итерации.
Итерации.
Удается найти.
Удается найти.
Строго меньше, чем 2 модуль E.
Собственно, улучшающих, увеличивающих путей.
Ну, потому что дело в том, что на каждой следующей фазе вы будете пихать R пополам.
А вам осталось пихнуть не более, чем Re.
Значит, больше, чем 2E не пихнете.
Логично, да?
А можете считать, что была нулевая?
Ну, скажем так.
Ну, log2c, c это максимальная пропускная способность.
Можете считать, что вы перед этим делали итерацию в 2 раза больше.
У вас получится, кстати, разрез от просто s и все.
Так что можете считать, что была нулевая итерация.
Итого тогда.
Ну, вот такое следствие.
Такое следствие.
Значит, асимптотика у нас получается от E.
Ну, DFS у нас за E работает.
Даже не за V плюс E, а за E, если правильно делать.
От модуль E умножить на сколько там?
Получается, ну, вот.
Ну, да.
Значит, DFS работает за E.
Значит, DFS работает за E.
Самих DFS тоже от E.
И еще домножаем на логарифм, потому что мы это логарифм разделаем.
Вот.
E квадрат, logc.
Вот.
Ладно.
Не буду дописывать.
Формально, конечно, это ни черта не утверждение.
Ну ладно, и утверждение, но тривиальное.
Но понятно, что имеется в виду.
Это самое тупое масштабирование самым тупым DFS.
Чего?
Ну, да.
То есть часто бывает, что уже пихайте это и будет вам счастье.
Абсолютно.
Да.
Абсолютно любым DFS.
Да.
Абсолютно.
Да.
Абсолютно любым DFS.
Да.
А то есть, как бы если мы...
Это работает за N.
Слушайте, если вообще просто DFS искать путь, вам может вообще никогда не закончиться.
Да.
Да.
Да, но здесь важный момент.
Мы пользуемся, мы очень сильно пользуемся тем, что тут целочисленная сеть.
В смысле, если...
Ну, в целочисленной...
Ищем просто DFS, и даже если у нас целочисленная сеть, то у нас даже тогда может в 8-м плотечке вылезти C и не подлогарифм.
Да.
Ну да.
Но масштабирование это убивает.
Правда в 8-м точке вылезает C.
То есть это не полинома твоей.
Вот.
Так же соответственно.
То есть там O от C не будет, будет вот тот.
То есть там C не будет, будет лог C.
Да.
Так.
Это вот такое масштабирование.
Но самое веселое для нас, это что делать, если мы захотим...
Если нам очень хочется делать динец плюс масштабирование.
Да.
Но тут важный момент.
Но тут для того, чтобы это понять, нам нужно сказать следующее.
Нам нужно извить, а где у нас собственно масштабирование...
Когда мы делаем масштабирование?
Потому что можно же...
Ну тут просто как бы вот эту сумму всегда можно понять двумя способами.
Можно понять, что там...
Ну, допустим, делаем вот это, и на каждый итерат составляем только ребра с прутом.
И на каждый итерат составляем только ребра с прутом с способностью больше либо равно R,
и делаем на них динец честного.
А можно делать наоборот.
Ну вот.
Можно делать динца и каждый блокирующий поток искать с помощью масштабирования.
Вот мы пойдем вторым путем.
То есть динец плюс масштабирование.
Значит, будем делать так.
Там.
То есть как бы пишем стандартного динца.
While true.
Но сначала пишем KBP.
То есть BFS от S.
Ну типа, типа слоистая сеть.
Устроим.
Значит, понятно, что если оказалось, что D от T равно плюс бесконечность, то как бы выбрасываемся.
Так, как у нас по-английски будет выбрасываться?
Правильно.
Да.
Да, бряк.
Да, бряк.
Вот.
Это называется.
Как будет по-английски lose?
Ответ карман.
Да, потому что потит.
Да, как-то не странно.
Почему-то потит.
Ну там lose это да.
Lunga в гольфе это hole.
Вот.
Ну вот.
И теперь значит for.
Соответственно там R равно.
Ну допустим можно даже, вот можно даже я вот так честно написал, но можно написать так.
Там R равно C.
R там больше нуля.
Там R там diff равно 2.
Ну тут конечно там оценка будет чуть-чуть не такая там, но суть останется той же.
Значит, и тут ищем.
Там блокирующий поток методом прям вот на этот раз честно, на этот раз методом Диница.
Методом Диница.
Рассматривая.
Рассматривая.
Только.
Рассматривая.
Только.
Ребра.
Да, только ребра с остаточной пустой способностью.
Больше либо равно R, Е естественно.
Вот.
Понятно?
Да.
Ну уже внутри БФС.
Нет, внутри БФС мы никакие ребра как всегда не удаляем.
Внутри БФС нам по барабану, в БФС мы рассматриваем все.
То есть обратите внимание, само масштабирование идет только не в БФС, а только в блокирующем потоке.
Да.
Такие не в ДФС, а в ДФСах.
То есть мы делаем здесь фактически лог СДФСов.
Нет, зачем, погоди, зачем, какие ограничения?
Так мы и так не выбросили, не понял, о чем вы.
Все, я вот уже здесь выбросился сразу.
Вайл, если что, вот здесь заканчивается.
Вот, ну теперь давайте думать.
Почему-то жуткое утверждение, что это работает круто.
Теория, о которой мы сегодня хотим доказать, это то, что это работает за В, Е, лог, С.
Почему-то мы такое утверждаем.
Каждая фазка работает...
Нет, ну ДФС будет работать за Е, казалось бы, хотелось бы, по крайней мере.
Ну тупой ДФС работал бы за Е, их был бы всего лог С, поэтому фаз всего В.
Да, мы хотим показать, что каждая фаза единица работает за Е, лог С.
Понятно цель, да?
Понятно?
Все еще живы.
Е, лог, хотим показать, что тут все работает за Е, лог, С.
А как мы это будем показывать?
Но давайте вспомним, за что у нас работает Д?
ЗБМ, ГНМ блокирует, ГНМ блокирует.
Поэтому думать надо теперь над следующим.
Теперь внимание, вопрос.
То есть он в какой-то момент находит путь и прописывает по нему что-то.
Вправивается.
Ну а теперь давайте думать, почему он...
У нас, казалось бы, какой-то масштабирует.
Теперь давайте думать.
Мы ищем пути, значит, ребра Р, но при этом помним, что мы уже пробежались по ребрам 2R.
То есть пробежались по ребраме личной 2R, причем на том же БФС, обратите внимание, причем мы туда-сюда не бегаем.
На ребрах 2R и там что-то попихали.
И мы теперь точно знаем, что на таких ребрах мы от С до Т дойти не можем.
Спрашивается.
Спрашивается, ну и какой вывод из этого можно сделать?
Вот возникает такой естественный вопрос.
ДФС-ом...
Ну как?
Куда не бегаем?
Можно не спускаться, получается, по ребрам, который больше, чем 2R.
Нет, почему? Это неправда.
Это неправда. Может мы не дойдем до 2R, до пути длины 2R, но мы можем дойти, но там мы встретим, можем ребра где-нибудь 1.5R, например.
Или там 1.2R.
Так, ну-ка, ну-ка, ну-ка, ну-ка.
Что мы еще можем сделать?
Но хотелось бы, наверное.
А сколько у нас путей может быть?
Пойдем.
У нас есть стандартный метод определения.
Запустим из С, Д, Ф, С, правда, по слоистой сети и посмотрим, докуда можем дойти.
Выйти из этого разреза мы можем не более, чем дойти.
То есть по сумме там будет строго меньше, чем 2R на, допустим, модуль Е.
Логично, да?
Вот.
Тогда.
Так, ну что это означает?
Так, насколько это нам помогает?
Это означает, в принципе, следующее.
Пока нам это не то, чтобы помогает.
Ну, хочется сказать, что это означает, что в следующих DFS мы на самом деле протолкнем, получается, как и ранее было, не более, чем 2E путей.
Получается, вроде, да?
Это означает, что в следующих ДФС мы на самом деле протолкнем, получается, как и ранее было, не более чем 2e путей.
Получается вроде, да?
В следующих облегхазах сумасшедшие.
То есть, мы можем, бывает, тоже внести под рассмотрение.
В бане? А, нет, сейчас.
Посмотрим, может, у нас этот развес наслаждается сети, да?
А может, я перепутал, а?
Может, все-таки другую интерпретацию обыштабирования нужна?
Так, работало, да?
А нет, очевидно.
Нет, там, понимаете, какая ситуация? Хорошо.
Давайте так.
Да.
Хорошо.
Давайте сюда.
Хорошо.
R больше 0, R делить равно 2.
Господи.
Хорошо, давайте так, пожалуйста.
Ну, тут я его убрал.
А, это да.
Да, хорошо.
Так, ну давайте так.
Теперь смотрите.
Давайте так.
Да, мы запустили 1.
Точнее, запустим цена вот какой-нибудь R равно R.
Значит, мы знаем, что улучшающих путей на этом 1 у нас будет не более чем 2e.
Но за сколько у нас суммарно работают все блокирующие потоки здесь?
Суммарно Wild True.
Да, ну вот, суммарно Wild True, да.
Улучшающих путей плюс...
Да, ой, здесь тоже BFS от S.
BFS нам Wild True не нужен.
Нет, нужен. Почему?
Да, Wild True не нужен, да.
Да, так.
Так, давайте так.
Давайте так.
Значит, запускаем.
Значит...
На месте форука можно добавить?
Нет, нет, не нужно.
А, нет, не нужно.
Надо просто сказать, что в BFS мы тоже рассматриваем только ребра с пропускными способностями от R.
Да, блокирующий поток.
И блокирующий поток тоже это учитываем, естественно.
Нужно, например...
Wild BFS.
Это там внутри.
Просто мы ищем в итоге.
Пишу Wild BFS.
Нет, вообще так, Wild True.
Нет, Wild True тоже самое.
BFS пишем.
Значит, если осталось плюс бесконечность, бракается Wild, но не for.
Это не return, это брек.
Не путать.
То есть как бы из этого цикла мы не выбрасываемся.
Зачем это?
Потому что фаза...
Потому что фаз может быть, но мы прям до упора ищем.
Просто не нужно каждое аж BFS.
Ну вот, то есть смотрите.
Чего?
Саша, скажи, что мы делаем.
Вам нужен BFS.
По-моему, там пишется таким образом.
Мы делаем форик, да?
Затем запускаем BFS на сети только на ребрах больших и равных R.
Я просто покрою всю реализацию.
Да.
И там пишется таким образом.
Если D от T стало больше в сравнении с плюс бесконечности,
то...
Мы ничего не делаем.
На этой R это рация.
Да, на этой R это рация.
Мы ничего не делаем.
А иначе делаем wild BFS.
То есть мы ищем блокирующий поток.
Да.
И приходим...
Нет, ну не один ищем блокирующий поток, а ищем...
Да, нужно найти больше аналогиш потом.
Знаешь, что я сделаю сейчас?
Ну да.
Это прям делаем честного Деница.
То есть разница только в Денице.
Когда рассматриваем ребра, проверяем не просто,
что у него больше 0,
а проверяем, что она больше либо равна R.
Все.
Это единственное, что мы в Денице меняем,
а дальше Деницу пишут абсолютно честно.
Понятно.
Ну вот.
Вот так предлагается.
Буквально вот этот код предлагается.
Чего?
Саша именно это и предлагает.
Я просто помню, писал ему,
у него есть шаблон.
Ну я не знаю.
Предлагается именно это.
То есть форм внешний.
А тут тогда Дениц честный,
тогда других вариантов нет.
Ну и все.
Теперь давайте смотреть,
за сколько работает Дениц внутри.
Смотрите, какая фишка.
Я отражаю следующее,
что Дениц тогда будет работать
они будут работать за сколько?
Я утверждаю, что они будут
они будут работать
суммарно
по всем
суммарно
по всем BFS
давайте вот так, суммарно по всем BFS
да?
Значит, модуль
количество удаленных ребер
плюс V
на
количество путей.
Количество путей, по которым мы что-то
пропихнули. Понятно, да?
Ну теперь
разложим это по суммам.
Это работает BFS на суммы
E удаленных, плюс
модуль V на сумму по всем
BFS количества путей.
Но
количество удаленных путей
количество
удаленных путей на каждом BFS их E
Хотя нет, неправда.
На каждом конкретном BFS
удаленных ребер E
А всего BFS у нас
соответственно V.
Поэтому пишем, это не более, чем
модуль V.
Количество BFS
умножить на
модуль E
плюс модуль V
на количество путей. Сколько у нас путей?
Но смотрите, у нас осталось
пихнуть не более, там меньше, чем
два E.
Да.
И на каждом пути, который мы нашли
пихаем хотя бы R.
Значит тут получается
спокойно домножаем на 2E.
Но BFS у нас тоже,
извините, V.
Мораль.
О от модуль V на модуль E.
Ну
по традиции
просто в концепции блокирующих потоков
мы знаем, что их
потому что расстояние там не уменьшается.
Ладно, здесь будет отдельная песня, может быть
чуть-чуть придется модифицировать доказательства, чтобы
там убедиться, что несмотря на то, что мы тут
ребра рассматриваем не все, а только такие,
но когда некоторые иногда исчезают,
там бывают обратные ребра,
то профессиональная способность меньше, но потом они
неожиданно появляются.
Возможно чуть-чуть придется
по шаманитам доказательствам, но суть та же.
Расстояние до вершины
уменьшаться от этого не начнет.
Вот В.
Повторил.
Дениц как работает?
Каждый DFS в Денице
работает так.
Он в итоге
находит путь, а до этого какие-то ребра удаляет.
Это все, что он делает.
Поэтому мы отдельно суммируем,
что DFS удаляют и какие пути нашли.
Но каждый путь
обрабатывается за В.
При одном BFS
удаляем ребер, понятно сколько их.
А теперь нас интересует, а сколько
путей за все BFS мы вообще нашли?
А теперь вспоминаем, что мы живем
в этом вот форе.
Так как мы больше ничего не смогли сделать
на предыдущей итерации, значит
путей длины 2R не существует.
Это означает, что минимальный разрез
меньше, чем 2R по той же логике.
Мы на следующей итерации
пихнем не более, чем 2R путей.
Кошмар, уже не первый раз в подряд
две интерпретации этого суммы
я второй раз не угадываю.
Как всегда, мораль, помните доказательства.
Где сойдется, то и пишите.
В данном случае достаточно
просто сходит.
Так что можете написать VE лог C. Если не заходит,
придется писать линкад.
Но лог V это меньше,
чем лог C, правда?
Ну, конечно. Ну давайте подумаем.
Допустим, у вас V обычно это сколько?
100, а C это обычно там
10-9.
Логарифм 10-9
это 30, логарифм
100 это
7. 30 подлита 7.
Оптимизация в 4 раза.
Очень хочется верить, что мы не стараемся написать
даже масштабирование.
А, ну да.
Ну там от E зависит,
на самом деле.
Правильно замечено, что
если у нас V100, то в общем-то мы садимся
и пишем любой кубический алгоритм и не паримся.
Поэтому да, актуально
становится, если у нас V2000
и E2000.
Даже не 5.
И тогда, правда,
если C у вас 10-9, то
за лето пишется за...
Нет, за лето пишется, за
осень упихивается.
Ну окей.
Да, алгоритм конечно там...
Это делает алгоритм динется с линкатом
сильно теоретическим.
Да.
Так.
Ну вот, так что да.
Так что вот получается.
Неплохо.
Давай.
Да.
Правда, что мы можем пускать потоки,
вообще, вот мы в R трассы,
мы можем пускать потоки
только кратные R.
Просто вообще, только кратные R.
То есть, если он даже больше...
Даже если у нас больше, то пускай кратные R.
Да, пожалуйста.
Ну да, ровно та же причина.
То есть как бы...
То есть как бы...
Ну да, вы знаете, что пути
длины 2R у вас не найдется.
Вот.
Поэтому разрез вот такой,
вы ищете, на каждом пути
просто убиваете ровно R.
Поэтому все оценки остаются.
Я...
Ладно, нет.
Я просто хотел сказать,
что раз у нас остались...
Мы...
Мы выпустили поток
кратные R.
Правда, если
ребро
веса больше,
чем условно R,
по ребру можно пустить еще поток
какой-то большой, но мы не пустили,
то можно, в самом деле, ограничить
ее пропускной способности,
потому что мы уже не пустим поток.
Мы пустим, вполне себе.
Вполне вероятно, что вы найдете еще один путь
пропускной способности R, который еще раз пройдет
по этому же большому ребру.
Да, там может быть
пропускной способности R. То есть как бы
и 2R, и 3R, и так. То есть у нас гарантии
только что мы не найдем путь, прям целый
путь на 2R. Ну вот.
Но конкретные ребра могут быть и R,
и 2R, и там миллиард.
Пожалуйста.
Ну, например, да.
Так что вот такая радость.
Так что да. Ой.
Слушайте, красота. Хорошую дырочку.
Ну ладно. В следующий раз нам предстоит
масштабирование.
А чем может...
А я вот не знаю, чем может
помочь масштабирование.
Да лучше тогда
уже вот этот предложенный алгоритм.
Не прислал еще?
Вот давай, да.
Вот эту статью и пришли.
Про корень изъеда. Это интересно.
Ну а что, да.
Ну а что, изучим. Будет у нас
такая крутая новинка.
Все ваши предшественники умеют поток только
за купы искать. Мы пойдем дальше.
Нет, они так не...
Извините, у нас ни у кого не было алгоритма,
что на каждом шаге тупо находим вершину
с максимальной высотой
и пихаем из нее.
Вот там
алгоритм такой. Давайте тупо так делать.
Оказывается, это работает за V квадрат E.
Ой, ну как сказать...
С точки зрения практики, да.
Но я тебе больше скажу. На практике
в 99% случаев
ты вообще даже не будешь знать, что такое Push Relay
и будешь везде писать Диница, и он будет всегда работать.
Там почти наверно. Это другое вопрос.
Да.
Кубичный код. Это находит статью,
доказывает, что он работает, на самом деле, за квадратом на корень.
Ага, посылаешь...
Да, посылаешь об этом
клад жюри и
называется ноды, гордо задираешь нос и уходишь
с контеста. Да, конечно.
Конечно, жюри
разводят руками, потому что там было решение
за линию простой жадности.
Или как
в тачешке бывает. Вы изобретаете
решение, которое работает за
сумму на 2 в степени количества
различных простых делителей числа N.
Значит, говорите, что это
должно работать, потому что сумма алгоритма работает
за 136 миллионов.
Значит, гордо
получаете ТЛ,
гордо уходите. Жюри разводят руками,
потому что у жюри было нормальное решение
в тачешке.
Ну, это вот
кого-то вчера, да, кого-то позавчера
не было, просто такой прикол случился.
Ой,
хотя ладно, можно будет вам этот контест тоже
дать. Интересно, со сколько
вы справитесь.
Так, ладно, есть ли тут какие-то вопросы?
Еще.
Так,
ладно, четко.
Да ничего.
Ну, просто вот за эту
четко вы можете добиться того, чтобы у вас там
осталось, чтобы у вас там
осталось все пути,
которые вы могли пихать, меньше единицы.
Но, правда, оставшееся,
останется вам пустить где-то там
2E и так далее.
Мы же можем и дальше уменьшать.
Мы, кажется, можем все еще за лофф С
сделать так, чтобы у нас,
за лофф С умножить на E,
чтобы у нас поток был не больше, чем
1,9 на С.
Ну,
типа того, да.
Ну, разве что так? А,
нет, погодите, ой, на эту тему
я, господи, еще одна важная вещь,
которую я забыл сказать. Ой,
про просочетание.
Ладно, если уже зашла
речь о том, как
найти не весь поток, а почти весь,
то есть вообще крутая задача.
Чего?
Нет, просто ситуация такая. Допустим, вы хотите
найти, вот даже тут такая задача.
Дан двудольный граф, хочется найти просочетание.
Нет, погодите. Нет, там
другая фишка. Ничего не надо думать, просто
ситуация такая.
Ну, там обнаружил,
просто весело. Ну, предположим, что
просто так, вы даже, как бы, дадан вам
двудольный граф, и вам говорят, так, значит,
миллион вершин, два миллиона рыб.
Но при этом
вам, при этом,
ладно, так и быть, мы зачтем вам ответ,
если ответ это
95 процентов от максимального.
Да, но теорем
об этом я, по-моему, не успел рассказать, поэтому
надо сейчас быстро.
Условие рассказывал, а решение не рассказывал.
А решение, ну вот. Ну, решение достаточно
тупое, теперь вот можно его рассказать.
Сделаем 19
итераций единица. Все.
Да.
Ну, правда, нет. Да, правда,
это тоже будет тейлиться, вам придется это пихать
всеми правдами и неправдами.
Вот. Потому что он там
закрутил, конечно, жестко.
Но, тем не менее, утверждение, если вы сделаете
19 итераций единица, то
оказывается, вы найдете 95 процентов.
Собственно, действительно.
То есть, про сочетание размера не менее,
чем 95 процентов от максимального.
Мы даже обобщим это утверждение.
Мы рассмотрим ситуацию, когда мы сделали
к итерации единица при поиске
про сочетание.
Смотрите.
Что же делать?
Значит, третье такое. Мы сделали
к. Что произошло после
к итерации единица?
Расстояние от
СДТ стало больше, чем
сколько?
Ну, вот.
А точнее?
Чем?
Три?
Да, было три.
Потом хотя бы пять, потом хотя бы семь и так далее.
Так что, в принципе,
можно заметить, что там расстояние все стали
2k плюс три. Что это означает?
Рассмотрим в остаточной сети
максимальный поток.
Этот поток будет состоять из
вот таких вот удлиняющих цепей.
Вот так вот, да?
И тут еще давайте нарисуем.
Но заметим, что
в каждой из них вот этих вот
ребер хотя бы 2k
плюс один.
Но как устроена
удлиняющая цепь?
Оно устроено так, что вот это вот
ребра, это ребра, которые у вас
при сочетании уже ранее найдены,
и каждая удлиняющая
цепь как бы увеличивает
цепь.
Каждая удлиняющая цепь как бы увеличит вам
про сочетания на один.
Но, смотрите, так как мы взяли
просто максимальный поток целиком,
то эти все пути как бы по ребрам не пересекаются.
Логично, да?
Вот.
Да и по вершинам не пересекаются. Впрочем, это неважно.
А важно другое.
Что для того, чтобы найти,
чтобы увеличить тогда
по каждому пути про сочетания
на один, вам нужно найти
и взять для этого целых
коребр, которые вы нашли раньше.
Понимаете, да?
То есть вывод неутешительный.
Точнее, наоборот, утешительный.
Величина оставшегося
потока
не превосходит
величины уже найденного
делить на к.
То есть вы нашли
сколько-то, а осталось найти
вк раз меньше.
Но!
Тогда из этого следует, что
модуль f это что такое?
Это в точности модуль f найденного
плюс модуль f
сколько там осталось.
Да?
И это...
Но, как мы уже поняли,
соответственно,
тогда
оставшиеся мы оцениваем,
как f найденное на k,
и получается тут модуль f
найденного умножить
на сколько?
На k плюс 1 делить на k.
Откуда?
Да, и там было что-то похожее,
но, правда, немножко из других
рассуждений. А, ну хотя примерно
такие же, да?
Ну, там такое, да.
Да, но тут как бы
теорема по-другому формулируется.
Пусть мы сделали k-итерации,
тогда мы нашли уже что-то.
Получается, выводим мы следующее,
что это f найденное
отсюда получается больше
либо равно, чем k поделить
k плюс 1 на модуле f.
То есть это означает, то есть это локальное такое,
то есть мы сделали k-итерации и уже нашли
вот столько.
Да, это мы будем
это называть в кавычках теорема
Данилюка.
Вот.
Ну, как бы
утверждение доказано
Алексеем Данилюком, собственно,
в своей дипломной работе.
Ну, да.
Ну, просто каждой единичке
вот этого потока в декомпозиции
оставшегося, ему соответствует
k-реберфпросочетание,
то есть k-реберфпросочетание, то есть k-единец потока
уже найденного.
Потому что, ну, длина такая.
И пути тут так устроены.
Да.
Вот.
Вот такое вот
неожиданное, заметим, шо.
Это жесть.
Да.
Ну, то есть это такое просто красивое,
заметим, шо.
То есть, оказывается, да, то есть
оказывается, там
Денис достаточно быстро найдет почти
все, что вам надо.
Вот.
Ну, там
о, господи,
кошмар.
Вот.
Так.
Так, ладно, так, есть ли еще что-то,
я шо сюда могу за быстро?
Ну, может.
А что шафлит? БФС возрадовался,
что тут тебе шафлит?
А, или ты хочешь прям ДФС
и найти за это, ну, не знаю.
Скажем так, там проблема в том,
что, по-моему, как бы на самом Петрозаводке
даже дохи никто не сдал.
Хотя пихать пытались многие.
Ну, я не знаю, и может быть многие из них на самом деле
до этого додумались.
Вот.
Ну, то есть, в принципе, если поставить себе цель,
если вы себе поставите цель подумать,
то это, наверное, вот это вот там
непридумываемым не выглядит.
Вот. Но другой вопрос,
что он там, конечно, прям совсем закрутил,
то есть там совсем какие-то там мощные тесты
там, видимо, написал, там какие-то, ну,
ТЛ там две секунды был, но тем не менее там
это не...
За Е корней из В, да.
Ну, естественно, понятно, надо было,
чтобы просто Деницкий зашел за корней
за Е корней из В, но
как бы это вот успешно добился.
Вот.
Так же, соответственно.
Нет, это при этом в том, что там надо было
упихивать, потому что как бы
сильно логичные жаги, которые захочет
писать любой липиадник. Давайте напишем
теница и будем пихать туда итерации не
за корень из В, а по
кавтейлю, по кавтейле умещается.
Почему это не сходится?
Ну, потому что, видимо, это
Данилюк очень постарался.
То есть он человек постарался, там
ужал константу там хорошо, наверное.
То есть там, видимо, можно как-то очень хорошо
писать это.
Остался.
Ну, может. Ну, не знаю.
Вот никому не удалось, хотя почти, наверное,
люди пытались. Нет, может, конечно,
в Петрозаводске такие вещи там жадности не пихают,
а зря. Ну, что там мне
в это не верится.
Все еще очень странно, что
в Петрозаводске 19 итераций заходят, а
написать итерации пока не таяли.
Нет, ну, просто может быть следующая итерация.
Это еще фишка в том, что, я думаю, там
почти, наверное, были тесты, где 18 не заходит.
Ну, мне так кажется.
Ну да, все еще.
То есть
вы же не могли проверить, придумали ли
участник вот это или написал сочетание.
Ну, это да. Но там, видимо, просто фишка была
в том, что надо было еще и ДФС очень хорошо
написать. Прямо-то как-то
очень хорошо.
Но это вопрос уже,
как говорится, к Данилюку.
Осталось только выяснить, где он сейчас.
Уже не в Португалии.
А, вы следите, да?
Понятно, да. Уже не в Португалии.
Это где? В Испании?
Ну, может в Испании.
Ладно. Так, ладно.
На этом мы, пожалуй, остановимся.
Так что да, пора уже на самом деле
останавливаться.
