В динамике их обычно есть и их много.
То есть, если много раз подникает одна из вас удача, то перейдет к нам еще динамика.
Жарная амбаритма. Здесь сложнее сказать, потому что обычно их там просто нет.
И набер не возникает, поэтому давайте надеемся, что их крайне мало.
В полном переборе их может быть что много, что мало, их все равно заново все время считают.
Раз, решаем.
Ну, например, вспомним задачу кузнечки.
Там кузнечки, которые имеют прибыль на один вперед и на два вперед.
Там надо собрать либо максимум, максимально возможную сумму, либо еще что-нибудь.
И у нас там много раз возникало то, что мы вынудили были смотреть назад.
То есть, при подсчете DP этого, мы смотрели на DP и минус два и минус один.
То есть, никак, у вас каждую задачу, каждую подачу числялось бы по два раза.
Если бы вы явно не погнали объекта.
Здесь. Ну, жарная амбаритма, мы выяснили, что во-первых, она не работает.
Во-вторых, там перескальчивая подача вообще не будет, если вы жарным амбаритмом действуете.
Ну, и полный перебор, ну...
Очень долго.
Ну, там, наверное, экспоненциально было бы даже быть.
Потому что с каждой позиции из два варианта выбора, например, на один вперед или на два вперед,
что-то порядка 20 мин.
Ну, около того. По большой 20 мин вариант же.
Нет. По-моему, там в точности числа Фибоначчи.
Да? Ну, ничего. А, ну, окей, просто правда.
Ну, это не особо важно.
Короче, вариант один важный, что это экспоненциальный рост.
Экспоненциальный рост нам вообще никак не требует.
И мы будем там скорее верить, что вот эта вот штука мы будем пользоваться примерно никогда.
Вот. Второй критерий.
Это, так сказать, на чем мы рассматриваем оптимальность под задачу.
Оптимальность решения.
Формулируем это так.
Сейчас я напишу это для дофей и для жаренька.
Ну, по этому счету я не веду.
В одиночном программировании мы подозреваем, что у нас есть оптимальное решение под задачу просто меньшего размера.
В плане того, что у нас есть какое-то состояние, мы уберем оптимальный вариант.
Нет. А мы рассматриваем, что у нас есть под задачей меньшего размера оптимальное решение.
То есть, у нас для задачи меньшего размера.
В очередь, тогда, как жадники, рассматриваем, что вы находитесь в том состоянии, и вы выбираете локально лучшего варианта.
То есть, пузнечики встали в какой-то клетке и верили, что если вы проигрываете либо на 1, либо на 2 вперед и выберете лучшего варианта, то это даст вам глобальный оптим.
То есть, каждый локальный шажок приводит вас...
То есть, если вы каждый раз действуете оптимально, локально именно, то вы придете к оптиму в итоге.
Вот. Ну, мы выяснили, что это в общем случае неправда.
То есть, здесь подозревается, что у вас оптимальность локальная.
На каждом шаге.
Ну, и в полном переборе, каждое решение активально построено.
Которое вы рассмотрели, но вообще здесь просто прочее.
То есть, основное отличие DPA жадника в том, что у нас DPA много пересекающихся поддодач, и у нас есть оптимальность именно для задачи меньшего размера.
Так как в жаднике у нас обычно мало пересекающихся поддодач, и при этом у нас оптимальность локальная.
То есть, мы в текущем состоянии идем в лучший вариант, веря, что в итоге это нам даст победу.
Окей? Отлично.
Ну, и приобрести инью разрешения.
Окей. Ну, теперь поедем дальше ознакомиться с разной задачей на DPA.
И первая задача, как будет наибольшего, заставить что-то подследовать.
Или сокращенный MVP.
Или the longest increasing subsequence.
Ну, значит, формулироваться очень просто.
Данку этой масси, ну, и последовательности, а1 на n,
надо выбрать, ну, и найти.
И каты от одного до n такие, что p1 и каты.
А это каты, при этом k максимально.
Вот.
То есть, в нашем случае, давайте пример проведем.
Начнем такого.
Ну, что-то вроде бы вот такое вот.
Длина 0, 1, 3, 4.
Вроде бы длины 6 здесь нигде нет.
Ну, давайте подумаем, как что-то.
Ну, полным перебором понятно, как.
Вы перебираете все возможные подпоследовательности и проверяете их на обрастание.
Окей.
Давайте прийдем в какой-нибудь жадный алгоритм.
Выбирать самое маленькое число?
Ну да, давайте возьмем, наверное, вот мы стоим.
И если мы верим, что это элемент включает,
тогда мы берем просто самый меньший элемент длины него.
Постоянно.
Например, в том, что мы верим, что он включается.
Если нет, то не понятно, что делать.
Окей, хорошо.
Тогда допустим, что мы перейдем здесь.
И мы искренне верим, что нам нужно брать самый меньший элемент.
Слева, ну, справа от нас.
Берем минус один, там 0, 1, 3, 4.
Ну, здесь это сработает.
Ну, может здесь работать, почему?
Может перейдем, например, когда это не работает?
Ну, вот пример, когда это сработает.
Вы возьмете сразу минус один, и закончится ваше путешествие.
Ну, давайте попробуем решить это динамикой.
Как мы с вами уже выяснили,
нам нужно свести так задачу меньшего размера.
Давай действовать как в кузнечке.
Будем учиться искать решения для префикса подпоследовать.
Для префикса нашего массива.
То есть для каких-то первых, какая элемента.
Вот, да.
Давайте, в общем, решим задачу для код префикса.
То есть если мы знаем ответ, вот здесь вот какой-то,
то, по идее, если мы знаем саму подпоследовательность,
то как ее можно продолжить справа?
Ну, будто бы найти наименьшее число,
то мы можем найти, например,
вот здесь вот, вот здесь вот.
Вот здесь вот.
Вот здесь вот.
Вот здесь вот.
Ну, чтобы найти наименьшее число,
большее, чем конец подпоследовательности найденной.
Ну, тогда как бы мы сможем ее продлить,
причем как можно менее увеличивая последний элемент.
И, видите, у нас здесь в предусуждении очень много раз
возникает слово «последний элемент».
Ну, давайте объединим эти два подхода.
И, в общем, следующее, что пусть dpi,
эта длина mvp
на массиве
ai,
и при этом
ait
ходит на mvp.
Немножко не так выразится, не по-русски, да?
Что я хочу?
Я хочу, чтобы найти такую возрастающую подпоследовательность
на префиксе,
чтобы она заканчивалась на ait и обязательной,
при этом было максимальное впадление
среди всех таких.
Вот что я хочу.
То есть, например, для
вот такого ситуации
у меня бы значения wdp были бы 1,2.
Потому что здесь у меня длина 1, понятное дело,
а здесь у меня я могу продолжить 1 и 2.
Для вот такого варианта,
чтобы у меня обязательно был при этом этот элемент последний,
у меня будет ответ 1 длина mvp.
Почему?
Потому что я не могу никакой из этих продолжить.
Минус 1, чтобы осталось возрастание.
Окей.
Ну и как это считать?
Ладно.
Давайте потом как-то пересчитывать.
Что такое DPI на самом деле?
Ну будто бы в лучшем случае, если мы не можем продолжить
никакой из подпоследовательностей ранее найденной,
ну как вот эта вот ситуация,
то у нас ответ 1.
Поэтому у нас считано это будет что-то типа максимума
из единички
и чего-то еще.
Вот.
Чего еще вопрос?
Предшествующих элементов,
которых можно продлить.
То есть 1 плюс
максимум по i меньше,
по g меньше.
Таких, что a gt
меньше a it,
dp gt.
Да.
То есть тогда действительно мы
берем лучшую подпоследовательность
строго левее i-того элемента,
которую можно продлить
и закончить этим элементом.
Ну, это тратит наш смысл.
Хуже.
Тебе еще нужно a gt меньше a it смотреть.
Тебе за линию придется бегать.
Ну и как это считать?
Ну как это считать?
Ну как это считать?
Не, ну потом не придется.
Потом мы выясним как это лучше делать.
Пока что да.
То есть вот такая вот формула интересная.
Ну или это можно переписать по-другому.
1 плюс
максимум из нуля
по g меньше i,
а gt меньше a it,
dp gt.
Вот.
Окей.
Ну сразу видно тогда, что пересчет
для каждого i можно делать
просто пробегаясь по всем g меньше i.
Итоговеримо квадрат.
Окей. Какая база у динамики будет?
Ну, у нас
все равно везде в пересчете здесь будет
фигурировать 1 плюс максимум.
Поэтому там не особо важно.
Можно их в 0 поставить все элементы,
можно в единицы поставить все элементы.
Я обычно делаю так, что dp
нулевое равно 1
равно нулю.
Ну или там минут бесконечности, как вам угодно.
Вообще не предстоит.
Так, это база.
Так, ну с формулой пересчеты,
с порядком пересчеты мы определились.
Что нам осталось?
Остался, но я не держу этот ответ.
Давайте сначала найдем просто длину.
Идем выбежать длина.
Ну да.
Потому что там нужно проверить.
Для каждого элемента
найти максимальную длину
dp и заканчивайся к нему.
Потому что ответ очевидно в каком-то элементе это закончится.
Вот.
Окей.
Ну прикольно, да?
Казалось бы, что-то некруто.
Квадратичное время на одну последовательность.
Давайте улучшать.
А решение за ngm.
Ну смотрите.
Видите, что у вас здесь
вот есть максимум на префиксе.
Узнаете, кто считать умеет
такую штуку?
Дерево отрезков нам помощь.
То есть мы будем хотеть обновлять
5 элементов в точке.
Вот это вот делать присвоение.
И запрашивать максимум на префиксе.
Единственная проблема
это вот это вот ожитое меньше аито.
Это очень грустная история.
Поэтому давайте
так сказать шаг 0
отсортируем
пары
аито и.
По неубыванию
первой компоненты
и в случае равенства
по убыванию
второй компонента.
Отлично.
Теперь мы получили какой-то порядок
на этих парах.
Ну давайте будем идти теперь вдоль этого порядка.
По массиву
из пункта 0
пойдем в форум
и что будем делать?
Вот нам приходит очередной элемент.
Какой-то там аито и.
Как посчитать dpi?
По определению там уже, будто бы.
1 плюс максимум
из 0
максимум
и
ожитых меньше аито
dpi
ожитых
Ну зачем
их сортировали?
Для того чтобы на момент
рассмотрения аитова
все элементы
которые мы рассмотрели были строго меньше
аитова.
А если были какие-то равные ему
то все элементы которые пожи меньше и
все элементы которые слева еще
не были рассмотрены.
Поэтому в их местных точках
динамика будет равна нулю все еще
и никак не будет влиять на наши
рассуждения.
Поэтому на самом деле мы имеем право
переписать это вот так.
То есть убрать просто условия на ожитые меньше
аито.
Потому что оно естественно
выполнится если вы идете по этому порядку
из массива 0.
Да, потому что вы равные не хотите
рассматривать.
Если было по расстанию
значит у вас бы сначала заполнился этот элемент
а потом вот этот вот.
И у вас бы учелся этот элемент в рассмотрении
вы бы рассматривали наибольшую не убывающую
распространительность.
То есть вы разрешили бы себе равенство
а так вы себе этого
запрещаете когда вы это делаете.
Потому что вы берете сначала этот элемент
а потом только этот
вы будете спрашивать на префикс
и у вас этот элемент не даст эффекта
на этот.
Но это глубокая мысль.
Вот.
Но это максимум на префиксе.
Максимум на префиксе.
А это
изменение в точке.
Ну или по индексу.
То есть у вас первый шаг
это O от N log N.
Второй шаг это M на
O от N log N.
То есть O от N log N.
Итоговое решение O от N log N.
При этом сама идейность не поменялась.
Мы лишь поменяли порядок пересчета.
За счет того, что мы сделали
хитрый порядок себя
мы можем использовать нашу структуру данных
которую мы проходили с вами ранее.
Окей?
Тогда второй сюжет
это наибольшая
общая подпоследовательность.
Или N2P
или
Longest Common Subsequence
RCS.
Собственно в чем суть?
Есть две последовательности
надо выбрать наибольшую
общую подпоследовательность.
Так что
в этом сюжете
есть две последовательности
надо выбрать наибольшую
общую подпоследовательность.
Пример.
Длины 4 я уже вижу.
Это вот она.
Что я так строил.
И будто бы длины 5 нет.
Если начнутся минус 1, то у меня
0 единиц дальше нет.
Поэтому не получится.
Если начнутся единицы, то
1, 2, 3 единицы.
Ну да, это ответ.
Пока что продолжим проект
потом вернемся к счетному сюжету
связанному общему для всех задач.
Что здесь можно делать?
Давайте придумаем жадник.
Давайте сначала полный перебор.
Вам нужно перебрать ее подпоследовательность
отсюда.
Посмотрите, что она общая.
Долго.
2 степени N, 2 степени M.
То есть 2 степени N
и 2 степени M
еще на равенство.
Это плохо.
Жадная алгоритма.
Будто бы давайте
не знаю, что тут жадного можно выбрать.
Давайте фиксируем одну
подпоследовательность.
И будем искать первый элемент, равный 0.
Нашли.
Вот наш текущий ответ.
Перепрыгиваем сюда и ищем следующий
элемент равной единицы.
Здесь сработал. Это победа.
В общем, случай, конечно, не сработает.
Потому что у вас банальный ответ может
начинаться не с первого ремонта.
То есть можно специально построить такой пример,
что у вас, если будете идти таким жадником,
то у вас цвет накопится здесь
и где-то здесь, а на самом деле надо брать кусок отсюда.
То есть на каждый жадник
найдется свой контент-пример.
Просто над ним можно думать,
может быть, долго.
Поэтому не беспокойтесь,
если у вас контести на динамике, там
будут все тесты.
Задача будет.
Вот.
Окей, ну, давайте попробуем
придумать динамику.
Какие-нибудь будут идеи из зала?
Ну, типа квадратик,
и там что-то вроде редакторского расстояния.
Редакторское расстояние
очень сложнее, чем мы нам поняли.
Ну, верно.
Это вы как бы решили, не знаю,
квадратное уравнение через формулы Кардана.
Примерно такой
сложности задачи у вас
возникла.
Я имею в виду, вот у нас квадрат, да.
Мы можем либо смачить последний символ,
либо попытаться смачить
последний символ и вот этот вот префикс.
Ну, понятно, да. Вот так или просто
перейти к последнему самому.
Так, теперь перевожу на формальный язык.
Предлагается рассмотреть два префикса
длины И и длины Ж.
Здесь длины И, а здесь длины Ж.
И пытаться их как-то жадно попродолжать.
Ну, не жадно,
но как-то их попродолжать.
Давайте
ДПИТОЕ ЖИТОЕ
ЭТО НОП
Ну, длина НОП.
Вот.
АИ
БЖ
Тогда какие у нас есть варианты?
Это как устроено ДПИТОЕ ЖИТОЕ?
Перещал.
Ну, первый вариант может быть таким, что
вот нам приходит новый элемент
БЖИТОЙ плюс 1
и он оказывается равный АИТОМУ.
Тогда будто бы мы можем взять
в течение так вот. У нас был БЖИТОЙ, да?
Вот такой вот ответ.
А теперь если мы знаем ответ для вот такой вот задачи
и нам приходит БЖИТОЙ
То что тогда?
Ну, будто бы если БЖИТОЙ равен АИТОМУ,
то все классно.
Вообще не так. Вот для такой подзадачи.
Да, вот так, все.
Вот АИТОЙ и БЖИТОЙ.
Первый вариант там нужно рассмотреть такую подзадачу, да?
Почему?
Ну, потому что вдруг ответ
для вот этой вот этой
совпадает с ответом на вот эту и вот эту.
То есть на расширенную, на один символ.
На одно число.
То есть на один символ.
То есть на расширенную, на один символ.
На одно число.
Давайте так.
Если они у вас не совпадают,
АИТОЙ и БЖИТОЙ.
Вот если у вас АИТОЙ и БЖИТОЙ
не совпадают,
в которые вот новый символ приходит,
есть ли вариант,
что это будто бы ответ
на такую подзадачу?
С БЖИТОЙ минус 1, да?
Будто бы.
Потому что у вас БЖИТОЙ не совпадает с АИТОЙ.
Значит вы не можете противить наибольшую
общую подпасительность АИТОЙ.
Так мы бы его раньше встретили уже.
Нет, у нас будет пересчет
ФОРИ и ФОРЖИ. Мы бы его встретили все равно
в той ситуации.
Пересчета
ФОРИ внутренний,
ФОРЖИ будет.
То есть ответ для этой задачи, как выражается
для А1АИ
Б1БЖИМинус1?
Для А1АИ
Б1БЖИМинус1?
Для АИБЖИМинус1?
Бинго!
В ДПИ
Для Минус 1.
Второй вариант.
Наоборот, вам взяли все то же самое
и написали только АИТОЙ в конец.
Первая последовательность.
И они снова там не совпались.
Дописные АИТЫ не совпадают с БЖИТОМ.
Рассуждение абсолютно аналогичное.
И это мы с вами говорили в случае
если они не совпадают.
А если они совпали?
Тогда мы можем сразу же сказать, что
ДПИТЖИТОРАВНО
ДПИТОМУ
Минус 1.
Ну да.
Если у вас АИТОСАНПАЛСБЖИТОМ
то вы можете взять под задачу меньше здесь
и на один меньше здесь
и будто бы продлить для нее ответ.
В этом случае нам еще не нужно
считать следующего.
Почему?
Нет, их надо считать.
Иначе у вас просто динамика
не будет корректно поддерживаться.
А может ли быть такая ситуация, что у нас
АИТЫ
не равен БЖИТОМУ
но ДПИТЖИТОЙ все равно лучше
чем эти оба?
Уже на текущем подсчитываю.
Это вас вечно и не вечно.
Ой, ой-ой-ой!
Да-да-да!
Опечатка, извините.
Все, вопрос отпал.
Извините, да.
Я сейчас смотрю и думаю, не понимаю.
Сам все пытаюсь вести заблуждение.
Ну все, тогда это работает.
То есть такая вот формула.
То есть каждое ДПИТЖИТОР
вычисляете просто по максимуму из трех.
И вам нужно гарантировать, чтобы для каждого ИЖИ
все вот эти элементы
уже были вычислены.
То есть если мы заполним, так сказать, матричку
то для подсчета вот этого вот элемента
вам нужно знать этот, этот
и этот.
Для подсчета этого
вы уже знаете этот, но еще надо знать этот.
То есть и того у вас
какая база должна быть.
База должна занимать вот эту вот область еще.
Все, что вот тут.
То есть у вас база должна быть
первый столбец и первая строка.
Тогда вы знаете ответ.
То есть тогда вы можете пользоваться
здесь переходом.
Да, иногда, если вы
уже написали плюс-минус переходы,
вы можете понять, какая вам база нужна,
чтобы у вас просто все эти формулы были определены корректно.
То есть база тогда здесь какая.
Ну если мы считаем прям
реально две параметры,
но если мы считаем прям реально
для длины и и для длины ж,
то есть будто у нас реально а1 и тра-та-та,
аи-то индексация,
тогда здесь совсем все просто.
Равно нулю.
Равно нулю.
И думать не надо больше особо.
А, кстати, вопрос, потому что понимаете,
когда я пишу тут двоеточие всякие
и так далее.
Это к питанистам референс.
Если я здесь пишу двоеточие, то я беру просто
все вот это вот измерение.
То есть dp это нулевое, это вот
все нулевые элементы.
А здесь наоборот я беру по-другому измерение.
Сберу ноль и все элементы.
Вот.
Это база.
Но ответ понятно где лежит.
Где?
Ну не говорите, что максимум по и ж,
дп и ж.
Дп и нм, да.
Ответ лежит в дп и нм.
Ну если возьмете максимум по дп и ж,
по всем и ж,
вы конечно получите ответ тот же самый.
Но вопрос зачем?
Консистентность.
Надо чтобы каждое решение тогда кончилось.
А, то есть когда у вас в ответе будет
сумма динамика, это будет совсем все уже
друбственно, да?
Да.
Окей.
Теперь общий момент, который я
забыл сказать первой задачей.
Ну давайте их разберем в общем случае.
Это как восстанавливать ответ.
То есть мы с вами
говорили все время про длину.
Но при этом промулировка, что надо
найти в общем-то эти индексы.
Ну или хотя бы с вами элементы вывести.
Но если вы увидите все элементы, то понятно,
индексы легко уже восстановить.
Что предлагается делать?
Предлагается делать максимально все просто.
Вы заводите массив поид,
массив предков.
Ну там, Ancestors.
Как хотите, Reparent, Ancestors,
как угодно называйте его.
В котором будет лежать
для итова чувака
оптимальное ж.
То есть если вы
для итова возьмете оптимальное ж,
а дальше потом возьмете вот этот вот
максимум поид и поид
и вы будете прыгать назад,
пока вы там не придете
в никуда,
то вы восстановите ответ.
Аналогично в этом решении,
только здесь вам надо спрашивать не просто максимум
на префиксе, а еще позицию максимуму
уметь возвращать.
Но дерево отрезков с этим тоже справляется.
Поэтому здесь тоже можно
оставить такой так ответ.
Ну, здесь
я думаю тоже понятно.
Если вы для каждой пары и ж
храните, откуда у вас был оптимальный
переход.
То есть у вас память увеличивается лишь
в константное количество раз.
То есть в классическом ничего не меняется.
И это прекрасно
на этом подходе, потому что
есть варианты, где можно не восстанавливать,
точнее восстанавливать не имея
массив предков, просто по ходу
динамики с конца идти обратно.
Но это что-то
совсем больно.
Почему больно?
Ну, не знаю, я не очень люблю такие алгоритмы.
Они неконсистентны.
Назовем это так.
Да надо какие-то эбристики придумывать, а тут
мы идем по общей схеме.
Ну, если попросить, на семинар вам, брат, как
представлю, например, в этой задачи без
массива предков?
Ну, тогда третья уже.
Это рюкзак.
Есть такая задача
комменатурной оптимизации.
У меня есть две постановки, есть такая
житейско-обывательская, есть
линейно-агибраическая.
Линейно-агибраическая,
боюсь, я вас запугаю.
Поэтому пока что будем жить на житейско-обывательской.
При этом есть две постановки
издачи в рюкзаке.
Обе начинаются одинаково.
Что у нас есть
10 предметов.
И там у каждого
есть своя цена.
Мы хотим собрать максимальную.
Мы хотим собрать...
А, и у каждого есть свой вес при этом еще.
То есть там, не знаю, бутылка воды
весит 0,5 и ценится
в автомате 65 рублей.
Вот, а
не знаю, 0,5 нефти наверно дороже
стоит.
Хотя вес тот же самый.
Нет, там плотность разная, ладно.
Не получилось.
Ну, не суть.
Попытка была неудачна.
Вот.
Ну, окей, не знаю.
Слиток серебра той же массы и золота той же массы
явно по-разному стоят.
И типа вам золото вроде выгоднее
брать.
Вот, и у вас есть предметы, есть каждого вес
и у каждого цена.
Вот.
И задача первая.
И обе задачи звучат так. Вам нужно брать
максимальное количество
максимальную по стоимости коллекцию предметов
в свой рюкзак так, чтобы она суммарно по весу
не превосходила какой-то W
ограничения.
И первая задача.
Первая постановка задачи.
Это непрерывный рюкзак. Вы можете
делить предмет как хотите.
Ну, там, не знаю, взять и откусить
там одну питую золота.
Слитка золота.
Если вы считаете, что это оптимальный коэффициент.
Вот.
А другой задачей так нельзя делать.
Это так называемый дискретный рюкзак.
Вы либо все берете, либо ничего.
Ну, пример, не знаю, вы
пришли грабить магазин бытовой техники.
Там явно вам пол стиральной машины не пригодится.
Вот.
Ну, давайте запишем постановку.
Мы же здесь коэффициентскую объяснил.
Теперь давайте страшную постановку
напишем.
Или алгебраическую.
Даны
два вектора
С
В
В
В
В
Страшно, да?
Скажите, когда остановиться
я перейду на житейскую платочку.
Найти
Вектор В
Из-за 2M
Такое, что
скалярное произведение W
на B
не превходит W большого
и скалярное произведение C на B
максимально.
Это из условия задачи,
чувак.
Это сколько у вас рюкзак может вместить.
А алгебрическая постановка такая
переводим на русский.
Есть два вектора
стоимости и ценности каждого предмета.
Вектор стоимости и предмета.
Да, да, мы будем считать, что не натуральный.
Что, ноль?
Ну, скажем так,
если у вас вес нольевой, то
это круто.
Если стоимость нольевая,
то это не круто.
Поэтому давайте считать, что эти тривиальные случаи
мы отбросим все-таки.
Хотя, конечно, понятно, что ноль это натуральное число,
и все в это верить надо.
Кто не верит, тот, не знаю,
плохой человек.
То есть у вас есть вектор стоимости
и вектор весов.
Вам нужно найти вектор из 0 единиц,
то есть ноль не берем предмет,
один берем предмет.
Такое, что у вас скалярное произведение,
то есть суммарный вес этих предметов будет не превосходить.
W стоимость
к максимуму стремится.
Полный перебор.
N на 2 в степень.
Хорошо.
Вам же, когда вы посмотрели вектор,
вам нужно еще посчитать все-таки.
Это важно.
Если было бы или просто 2 в степень,
то уже было бы классное решение.
Потому что вы от целой N-ки избавились.
Ну, вы знаете,
это как методы борьбы.
Если у вас решение за O,
2 в степень N на N в пятый,
то вы будете очень радоваться,
если вы 2 в степень N на N-кубе сможете прийти.
Неважно, что это не даст
колоссального прироста,
но вы будете радоваться.
Вот.
Примерно как радоваться тому,
что вы смогли сделать...
Выкинули из печечной коробок,
когда падает шарма обычно.
Ладно.
Вот.
Не, ну да, действительно.
Ну, относительно, конечно.
Но этому печечному коробку вы были бы рады потом.
Вот, окей.
То есть, здесь можно решить
экспоненциально долго.
Есть разные там оптимизации
определенные.
Короче, об эту задачу
уже столько сломано,
не знаю чего.
Там уже просто куча по ней статей,
куча всяких дискретных метод оптимизации там применяются.
Но никто не может найти
в любом случае решение быстрее,
экспонентом.
То есть, так сказать, это задача
из-за полных задач, так называемых,
что на данный момент человечество не умеет решать о запаленном.
Ну, не умеет.
Если научится, то...
То, кто научится, то получит миллион долларов, так сказать.
И...
Делать много чего странного.
Вот.
Окей. Ну, это неважно.
Там все расскажешь потом.
Кому-то на треть, кто-то на втором курсе.
Ну, как решать?
Решение за...
N на W.
Ну, вы скажете, как так?
Ну, вот.
N, W по лином.
На что я отвечу, что
круто W у вас записывается в битах.
То есть, это экспоненциальное число по числу бит,
на самом деле.
Поэтому подходит под отклинии NPR.
И не задумывайтесь об этом.
Для формулистов было сказано.
Для тех, кто на третьем курсе сейчас сложности изучает.
Окей.
Как решать?
Здесь не очевидно вообще, как решать.
Поэтому это такая самая экзотическая издача,
которую мы рассматривали.
Здесь человек, что придумал вот следующее.
Что пусть DPI, TDP
это ответ.
Ну, лучшая стоимость
в качестве этого здесь рассматривается.
Макс стоимость, если
рассматриваем
первые им предметов
и
ограничение веса
не веса
W обножим.
Вот.
То есть, мы взяли такой подзач,
что у вас три узачок легкие
и предметов мало.
Давайте подумаем над базой.
Круто.
Вот сто рюкзак.
Нельзя ничего положить. Хорошо.
А если 0 предметов
вес, вместимость любого рюкзака,
то тоже ответ 0,
потому что ничего не можете положить.
Нет предметов.
Окей, это база.
Как пересчитывать?
Ну да, все очень концептуально
пришло, на самом деле.
ДПИ даже
у нас будет равно максимуму С.
Первый вариант,
мы не кладем этот предмет,
но считаем, что его невыгодно положить.
Тогда что это такое?
ДПИ не сводится.
Именно так.
Ну,
то есть,
если у нас есть
один предмет,
и минус один,
ну, ограничение С у вас то же самое.
То есть, вы не кладете этот предмет.
Не кладем.
И ты предмет.
А теперь, если мы его кладем?
Жиминус что?
Какой вес?
Вес.
Победа.
Я вас поздравляю, мы смогли.
Активно.
Зачем собирать ответ?
Если можно, ответ не собирается.
Если можно,
все в нули засунуть.
Да.
Плюс сейты, конечно.
То есть, чтобы уберете от сейты.
Правильно.
Окей.
Порядок тоже будет в два вложенных пора.
Сначала у вас будет
пор по предметам.
Пор по И.
Внутри будет пор по W.
Но восстановить ответ
здесь два варианта.
Первый вариант это
хранить предков абсолютно так же.
То есть, вы понимаете, как хранить предков.
Если вы пользуете этой формулой,
чтобы вы этот предмет положили в ответ.
Дальше здесь с конца.
И смотрите, какие состояния
вы использовали.
И с этим берете и
этот.
И выписываете
предметы.
Окей.
Тут возник прикол
от коллег, что они ничего не поняли.
Давайте возьмем
и эту задачу еще раз разберем.
Только на примере.
Нужен какой-нибудь массив.
Похоже на правду.
Давайте теперь
рассмотрим.
Ну, это наша АИТ.
Это И.
Давайте по 1, 2, 3,
4, 5, 6.
Теперь нам надо их отсортировать.
Как мы говорили, отсортируем
сначала по неубыванию
первой координаты.
В случае равенства, по убыванию
второй.
В случае равенства, по убыванию
0, 2,
ой, минус 1 есть еще.
Минус 1, 3.
Записали
0, 2.
Записали
1, 6, 1, 1.
2, 4, 3, 5.
Окей.
Теперь выпишем наш массив ДП.
Мы идем в форум.
Изначально все нули.
Вот нам говорят, минус 1, 3.
Мы берем
третий индекс.
Вот эту вот штуку берем
и пишем
ДП третья
равно 1
плюс максимум
из
ДП
житых по
ж меньше
и.
Здесь максимум из нуля.
У нас здесь все нули, поэтому можно без этого.
Хорошо.
То есть по ж меньше
трех.
Это
вот это 1, 2.
Берем здесь максимум 0, 0.
0.
Плюс 1, 1.
Следующая ДП, вот эта штука.
0, 2.
Какой 0?
Получилось 1.
Да, мы считаем ДП третьей
и хотим положить
изменения в точке.
Че?
Пожи меньшим тройки.
То есть всех кто левее.
Максимум 0.
Да это мы только что написали.
У нас было значение.
Дальше.
0, 2.
ДП второй. Снова берете максимум
на префиксе.
0, поэтому здесь 1 снова будет.
Второй чувак.
1, 6.
Пишем ДП 6.
1 плюс максимум.
Пожи меньшим 6.
ДП житых.
Берем максимум.
Вот он.
Победа.
1 плюс 1 это 2.
То есть у вас здесь
лучшая подпоследовательность, которая заканчивается в этом элементе
в шестом, это 0, 1.
Или минус 1, 1.
Причем здесь,
как вы спрашивали, вы можете с помощью ДО
спросить не только максимум, но и позицию максимума.
Поэтому вы знаете сразу
либо этот, либо этот ответ.
Но там не важно, какая у вас политика именно.
Выбор в случае равных.
Дальше. У вас подают сюда.
ДП 1, 1.
ДП 1 считается как?
ДП 1 снова берем. Вторую компоненту
все время рассматриваем.
Это будет максимум на префиксе, но левее у нас ничего нет,
поэтому 0.
Плюс 1, поэтому здесь 1 ответ.
А вот если бы мы их рассмотрели в обратном порядке,
сразу вам скажу,
то у нас сначала бы здесь бы появился 1
и он мог бы заафектить
эту штуку просто-напросто.
У нас 1 бы стоял где-нибудь здесь,
то у нас было бы минус 1, 1,
а потом еще 1 вот эта вот была бы.
А теперь такой ситуации быть не может.
Потому что сначала рассмотрели
саму правую и так далее.
Дальше 2, 4.
Когда ДП 4
это максимум
на префиксе плюс 1, то есть 2.
И ДП 5
это максимум
на префиксе плюс 1,
то есть 3.
Поэтому ответ вот он.
По массиву переходов
можно понять, что этот отсюда.
Это там не знаю, откуда-нибудь отсюда,
например.
Когда мы двойку считали, мы либо отсюда, либо отсюда брали.
Ну все.
То есть ответ
минус 1, 2, 3.
Я так понял, что была проблема
с тем, что было не очевидно, что надо брать именно вторую компоненту пары
в качестве индекса.
Так, ладно.
С этим разобрались и
а, ну рюкзак мы закончили.
Ну тогда поехали
вторая, так сказать, часть лекции.
Она у нас будет посвящена матричному ДП.
Надеюсь, вы научились
перемножать матрицы за
2, 4.
А теперь
у нас будет
матрица.
Мы научились перемножать матрицы за
кто-то за 2, кто-то за 1,
кто-то за 3 года обучения.
Матричная ДП.
В чем его суть?
Его суть в том, что если у нас есть
какой-то...
Вот здесь, видите, мы рассматриваем
например, вот здесь вот,
мы рассматриваем переход точечно.
Но вдруг мы умеем переходить в
двумерной динамике, пересчитывать
ДП и ты весь массив
через ДП и минус 1 весь массив.
Просто он будет умножаться
на какую-то матрицу.
Ну тогда нам можно будет как-то
это оптимизировать, это дело.
Ну сейчас будут появты примеры.
Ну самый простой
пример, нулевой, так сказать, это числа
Фибоначчо. Помните, как мы их считали?
Мы их считали за линию.
Второй вариант, мы
можем воспользоваться формулой
Бене через золотое сечение и
победить.
А теперь будем рассматривать следующий вариант.
Вспомним же, что у нас есть просто рекуррента
на самом деле.
Давайте запишем
вектор
fn, fn-1.
И пересчитаем
его
через вектор
fn-2.
Какую матрицу надо написать здесь?
Давайте первую строку.
fn через fn-1, fn-2
как выражается?
1 плюс 1.
fn-1 выражается 1, 0.
Просто-напросто.
У вас fn-1, fn-2
не участвуют, у вас есть fn-1, есть.
То есть так называемая матрица
A. Матрица перехода.
Вы можете сделать это
кучу раз
и показать, что здесь у вас будет просто-напросто
что-то типа такого.
f1, f0.
Это A в степени n-1,
это f1, это f0.
Вы просто взяли
и применили вот эту же форму еще раз.
И просто так много раз
ее поприменяли.
Чтобы посчитать эту штуку,
вы можете посчитать через fn-2, fn-3.
И у вас снова
матрица A выделится.
В силу ассоциативности
умножений вы можете
сначала ашки все поперемножать.
Так как у него
с квадратами, вы их просто пишете,
что это в степень.
Окей.
У вас должно быть на первом семинаре
алгоритм бинарного возведения в степень.
Как число
возвести в степень n за алгоритм n?
Было такое дело?
Что если число четное,
вы считаете его
корень и просто умножаете.
То есть степень пополам берете.
А если степень нечетный,
то делаете минус 1 и он остается четный.
Но это же все работает
с производственными объектами на самом деле.
То есть мы можем здесь
возвести...
В самом деле у нас решение работает
за 2 в кубе.
Это время возведения матрицы.
Время перемножения двух матриц.
На от
на логе
это бинарное возведение в степень.
Это бинарное возведение в степень.
В степень.
То есть что равно от логен.
Окей?
Хорошо.
Давайте теперь попытаемся это обобщить как-то.
Дело
а именно
рассмотрим
произвольные рекуррентные соотношения
соотношения
не совсем произвольные.
Сейчас напишу как они будут у нас называться.
То есть раздел первый пример
на самом деле здесь.
Это линейные
рекуррентные
соотношения
в постоянными коэффициентами
так называемые LRSPK
произвольного порядка.
Ну как решать?
То есть
что мы имеем?
Ровно
лямбда первой
а н-1
лямбда катой, а н-катой.
То есть вот порядка k рекуррента вам.
Либо начать от второго порядка.
Здесь порядок k.
Лямбда это просто какие-то числа.
Давайте выпишем как считать.
Выписывает следующее соотношение.
Н-к
плюс два
плюс один.
Вроде бы.
Здесь будет что-то страшное.
Мы не знаем что это такое пока что.
Давайте выпишем первую сроку матрицы.
Просто лямбда, вектор, лямбда.
Дальше какая матрица будет?
Ну да.
Дать ноль.
Короче я утверждаю, что он будет иметь вот такой вот вид на самом деле.
Такой вот блочный вид матрица будет иметь.
Это нули, это единичная.
Ну почему это так? Вроде понятно.
Потому что у вас n-1
вот, n-1 выражается здесь.
Или нет, или нет? Не туда сместим.
В другую сторону.
Наоборот здесь будет вектор нули, здесь e.
Здесь будет n-1, братцы, первая компонента.
Получайте n-1.
Все, потому что все остальные должны быть
нулями в этой строке.
Здесь ноль, единичка,
потому что с n-1-2 берется.
Все нули. Ну и так далее.
То есть итоговое время решения
от кавкуба log n
для поиска n-го члена рекурриента.
Что?
Ну я не очень хочу к этому стремиться.
Скажем так.
Нет, ну есть алгоритм штраса,
но я понимаю.
Честно, я не очень знаю, можно их быстро перемножать.
Здесь я не эксперт
во всяких матричных умножениях.
Возможно и можно,
но я не уверен, честно говоря.
Это надо быть
гуру бычматов
с матричными размножениями.
Окей.
Казалось бы, круто, да?
Так, первый курс. У вас же были
три системы уравнений или нет еще?
Ну, которые в матричном виде записывать.
Некоторые там три переменных, три уравнения.
Там теория Макронекера Капелли вам что-нибудь говорит?
Грустная история.
Ну ладно.
Не, ну я
уйду в эту сторону, немножко с другой стороны зайду.
Ладно.
Здесь уже будет
просто такой фан-фэкт,
фан-прикол, так сказать.
Второй сюжет.
Пусть у нас есть
рекуррента следующего вида.
Пам-пам-пам.
Ну давайте
лямбда 0
прям в степени K.
Лямбда KT.
Просто лямбда KT.
Лямбда KT.
То есть у нас
будет с вами
то есть смотрите, у нас здесь было
однородное линейное-рекуррентное
соотношение.
Линейное, потому что у вас здесь все в первых степенях
и нет произведений никаких.
То есть у вас все линейная комбинация.
У рекуррента понятная постоянная коэффициента,
потому что лямбда 0 это константа.
Еще она однородная,
потому что у вас здесь нет
неоднородности.
А здесь у вас есть
неоднородность.
Это у вас
какая-то непонятная штука
близко от пункции от N.
В нашем случае много членов.
Как мы будем с этим
справляться?
Незапно выясняется, что
давайте напишем
утверждение,
что
C из нуля...
Ой, как сложно.
Очень сложно сейчас.
Типа такого.
N-1 только.
N-1 квадрат
и так далее.
И так далее.
Вроде бы это похоже на правду.
Ну, бином не тонн расписали.
То есть смотрите, что
можно, грубо говоря, заявить, что
у вас здесь есть
так называемый...
что вы N вкаты можете разложить просто
коэффициентом через N-1 по степеням.
Еще более такое
просто утверждение, что если вы рассмотрите набор
единица
N, N квадрат, N куб
и так далее степени N, то это базис
пространства многочленов.
Но это вроде бы очевидно, потому что многочлен
это линейная комбинация МНОМА.
Не, базис это первый семинар
по аналиту.
Ну, базис это вы умеете...
у вас есть базисные вектора, вы умеете выражать любой другой вектор
через них, просто их линейной комбинацией.
Все.
То есть вы умеете любой многочлен выражать
через N, через 1,
N, N квадрат и так далее.
Это вроде бы очевидный факт.
Но при этом вы умеете тогда
по этому утверждению
выражать N вкатой.
Просто через N-1 вкатой.
То есть тогда у вас и N-1
во всех степенях тоже является базисом многочлена.
Ну окей.
Знаете что, мы можем написать просто формулу
перехода в следующую.
А N
сейчас
N-1
N вкатой
N-1
N-1
N-0
Здесь A
N-1
N-2
Дальше
А, ну
здесь можно даже проще, здесь можно без
N-1
Дальше здесь будет N-1
вкатой
N-2 вкатой
N-1
и 1
Вы спрашиваете, причем здесь динамика?
Я...
Если мы успеем, мы разберем еще сюжет сегодня.
Похожий на матричное применение.
Я просто рассказываю математические приколы.
Всякие разные связанные с этим.
Ну,
первый вектор это 1.
Здесь вроде понятно почему.
Дальше
N вкатой
здесь 0.
А N вкатой мы сами выяснили, как выражается.
C из K пока
C из K пока минус 1
C из
0 пока
Здесь будет везде 0
Ой-ой-ой-ой-ой-ой-ой-ой
Здесь N в степени K минус 1
Дальше N в степени K минус 1
Дальше N в степени K минус 1
Здесь 0
Здесь C из K минус 1
пока минус 1
Здесь 2 0
Здесь37
ͬͮͩ́͡͡͞� world
lying
Да, спасибо!
Сейчас. Подожди, нет, не лямбы.
Здесь будут гаммы.
Сейчас я скажу, что такое гамма.
гамма каты где гамма 0 это что такое это вам нужно выразить так сказать вот этот
вот ваш прекрасный то есть гамма 0 это вот такие вот коэффициенты что вас ну да можно вам не
советую это можно один раз ручками посчитать гамма это такая штука чтобы это было равно
лямбда нулевой кат и плюс ну или же опять дай здесь говорят что можно просто у вас есть
матрица перехода от базиса к базису то есть вы можете взять вектор гамма катах получить как
вектор лямбда кат как этот вектор лямбда кат х умножить на матрицу перехода из цшек ну матрицу
перехода мы сейчас допишем как классная матрица балдеж да то есть смотрите знаете кто это такой
треугольник паскаля то есть вы эту матрицу легко заполнить на самом деле это не надо цшки считать
заново с нуля это просто треугольник паскаля матрица перехода между гаммами лямбдами тоже
треугольник паскаля то есть все прекрасно здесь нули чтобы получить гамму вам нужно лямбды
перемножить на матрицу треугольника паскаля вы получаете гаммы и дальше считаете всю рекурренту
вот конспекте у меня есть страшное место где у меня соединены эти два подхода и там прям такая
огромная матрица но я думаю здесь понятно что это тоже будет от k в кубе на log n для тех кто знает
что такое дифуры помните у вас там есть неоднородные решения дифуров с постоянными
коэффициентами вы там тоже решаете сначала однородную часть потом неоднородная познакомьтесь
если вы разложите неоднородную часть по базису вы получите решение то по такому же методу на
самом деле то есть теория дифуров в этом плане очень похож на теорию рекуррента
окей теперь собственно сюжет какой-нибудь да надо привести хороший чтобы не все время
матрицы писать очень прикольная дать что-нибудь прикольное напишем рассмотрим такую задачу
что у нас какого-то региона все-таки
а
т-сюжет число гладкое а n если для любого и
1n-1 а и ты минус а и минус 1 по модулю не превосходит единицу то есть у вас все
соседние цифры отличается не больше на единицу посчитать количество гладких чисел длины n
да полный перебор
полный перебор самый примитивный полный перебор это за 10 в степени n перебрать но еще на n надо
умножить не забыть конечно же как делать будем ведем дпн катая ответ
давайте число гладкий количество гладких чисел если длина n и число и заканчивается на к
ну понятно как делать на самом деле плюс-минус что у вас какой здесь переход
равно здесь будет три случая что если вы заканчиваетесь на к то вы можете взять
дп то есть вы берете число на длину на 1 меньше и просто-напросто приписывайте к нему число
равное к тогда вас устроит все эти числа которые длины n-1 заканчивались на к-1 как
плюс-1 момента почему дп н-1 ката плюс-дп к-1 к-1 плюс-дп n-1 к-1 это если к
1 8 если у вас 9 то вы не могли 10 заканчивается хорошо если к равно 0 наверное дп n-1
каты плюс-дп n-1 к-1 к равно 0 третий случай это дп n-1 к плюс-дп n-1 к-1 к равно 9
ну за от 10 н 10 н короче да вас действие здесь будет состояние разных пересчет за вот единицы
4n внутри 4k база понятна какая дп длины 1 рассматривайте на все числа просто что такое число есть одно
теперь давайте возьмем и но это за линию до решения потом круто да теперь давайте
предположим что н ну не 10 5 а 10 сотый ну не знаю зачем-то вам понадобилось считать числа
10 сотый но это такой иллюстрирующий пример есть пример круче он рассмотрим в следующий раз
как-то как-то сделать быстрее
пусть а n-ый это вот такой вот вектор дп н-ый 0 дп н-ый 9
тогда смотри что мы умеем делать по сути мы везде используем n-1 везде а это значит что то есть
мы умеем текущий слой выражать через предыдущий ну давайте обозначим что это просто вектор с текущим
слоем тогда как можно выяснить что а n можно написать что это а умножить на а n-1 осталось
выяснить чему равна матрица а ну смотрим так если к равно нулю то я учитываю только нулевой и
первой с коэффициентами один вот такая матрица
3 цикличная у вас везде по три единицы и только здесь на краях по двоечке есть
есть классная теория про то что такие матрицу можно за квадратом нажать друг на друга вот
здесь есть специальный вид которые что можно их как перемножать быстро
я не помню точный ход как это сделать да да того вот на это даже нас не очень интересует на
самом деле что их можно быстро перемножать нас интересует то что тогда это равно а в степени n-1 на
а 1 а 1 нам известен это вон база это просто единица
казалось бы 10 в кубе да потому что у вас матрица размера 10 на 10 то есть как бы тысяча но вы с
н перешли долог м становишь всего лишь умножение на тысячу 2 это несерьезно наоборот более чем
серьезно то есть как бы получили экспоненциальную выгоду умножив на константу то есть там у вас
было 10 она здесь вот здесь кубе ну в 100 раз увеличили константу зато у вас экспоненциальный
спад пошел и то есть если уметь пересчитывать какой-то слой динамики какой-то измерения когда
она у вас многомерная только через предыдущие ну все просто до списывайте через матрицу и
линию превращайте в логариф и вот ну еще круче пример мы рассмотрим с вами на следующей лекции
там будет размер матрицы расти экспоненциально вот и дальше нас будет под отрезком на в следующий
раз и совсем немножко мы коснемся под мостом так чисто посмотреть что-то такое и мы закончим
с динамикой в следующий раз это будет лекция 12 у нас останется три лекции они будут посвящены
геометрии ну если что там останется счет очень еще сделаем вот а так все на сегодня я вас план до конца
