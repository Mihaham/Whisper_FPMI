ну собственно кстати к вопросу о всяких сплей деревьях называется думаю пришло
вот дот думаю вот мы добылись до линката да собственно пришло но то есть пришло время
заниматься действительно чем-то интересным но не то что мы все время занимаемся чем-то не
интересно но тем не менее ладно как говорится да структура считает да по камере если есть
верить программе экзамена структура линкат считается одной из самых сложных но с другой
стороны мы уже выяснили что на самом деле сложных структур данных на самом деле не существует
пока нет но я не знаю хотя нет но нет на самом деле еще атомик хип существует но об этом позже
ну вот ну посмотрим ладно давайте не подумал пока как бы давайте доберемся до линката
что мы вообще вообще по идее хотим вот больше раз мы обсуждали хевилей что для нас хевилей то есть
хевилей это да но фиксированное дерево там какое-то мистическое вот это вот мясо мясо мясо мясо там
красивое quantities
дерево дерево дерево дерево дерево
вот и мы ос reading this note hope to do that
но именно там мы скажем на ребрах мы хотим offset какие-то мистические чиселки и хотим
делать для них на них все что мы обычно делаем здесь картями или всякими овелиями то есть а
то есть прибавить на пути, присвоить на пути, найти сумму на пути, найти минимум на пути
и прочее вот это вот развлечение.
Как вы в прошлый раз убедились, если дерево фиксированное, то оказывается, хавилайт это позволяет делать.
Причем даже не залог квадрата, еще и просто залог, как мы неожиданно выяснили.
Придется немножко пострадать, но логарифм будет достижен.
Но мы сегодня бросим себе более масштабную задачу.
Мы хотим, чтобы дерево менялось.
То есть представьте себе, помимо оглашенных мной операций,
помимо оглашенных операций, мы будем делать мистическую...
Мы объявим, что дерево у нас все-таки будет всегда подвешено.
Но оно будет не одно, их будет несколько.
Никакой сбалансированности, естественно, не гарантируется, деревья абсолютно произвольны.
Вот.
И в этих деревьях неожиданно.
Нам очень захочется делать мистическую...
Эх, так зеленого маркера нет, поэтому...
Не жалко, что зеленого нет.
Ну ладно, фиолетовая будет.
Нет, то, что там есть, оно не пишет.
Ух ты, спасибо.
Вот это спасибо.
Что, преподаете, что ли?
Нет.
Нет?
Ой, ух ты, зачем вам маркеры?
Так, ух ты, значит, смотрите.
Итак, у нас будет теперь операция линк.
Значит, что будет делать операция линк?
Значит, она возьмет корень какого-то дерева В
и подвесит его к дереву У.
Даже не к дереве У, а к вершине У.
Потому что самое страшное, У не обязана.
То есть, единственное, что требуется, что У обязана быть
вершиной другого дерева.
То есть, не того дерева, корнем которого является В.
Что? Да, цикл делать нельзя.
То есть, вот эти супердинамики конвективить
в глобальных этих мы не занимаемся.
Вот.
Но подвешиваем из ребра весовый.
Соответственно.
То есть, вот такая красота.
Это было дерево.
Ну вот.
Но у нас есть обратная операция.
Обратная операция называется КАТ.
То есть, это означает, что гарантируется, что есть ребро от УВ.
И надо его удалить.
Причем, более того, здесь будет подразумеваться,
что вершина В будет являться ребенком вершины У.
Есть.
Значит, внимание.
У нас не просто система деревьев.
У нас система подвешенных деревьев.
Да, это важно.
В чем корень?
В чем, что важно, корень задаем не мы.
Корень аннот.
Вот.
То есть, при КАТе подразумевается, что У является родителем.
То есть, давайте я так напишу.
То есть, У это родитель.
Значит, В ребенок.
Точнее, это было перед КАТом.
После КАТа называется вершиной У.
Больше нет ребенка по имени В.
В отправляется в свободное плавание и обливляется корнем своего дерева.
Вот.
Собственно, логично.
Вот.
Да, вот.
Да, именно ребенок.
Да, не путать с потомком.
Да, допоминаем, что у нас ребенок и потомок это разные вещи.
То есть, скажем, правнук это потомок, но не ребенок.
Вот так.
Вот.
Ну, конечно, как реализовать структуру данных, поддерживающую вот эти две операции?
Ну, совершенно метод.
Метод, как всегда, работает.
Вот.
То есть, более того, я не сильно даже усложню жизнь.
И скажу, что на самом деле я ж могу и корни захотеть менять.
У меня будет специальная операция.
Она почему-то в литературе называется Эверт.
От У.
То есть, мистическая операция, которая говорит, возьми вершину У и скажи, что она в своем дереве теперь новый корень.
Зачем-то?
Так. Ну, пока мы никуда не делись.
Пока мы не вспомним, что, к сожалению, всякие операции...
То есть, у нас там возникают всякие наши классические, технические операции.
Типа Summa Tuvae там.
То есть, я не знаю, там Assign Tuvae.
Ну, практически...
Ну, как сказать?
Ну, с ассоциативностью.
Так. Ну, давайте подумаем.
Нет, ну, в принципе, думается, что да, наверное, ассоциативность.
Ну, там так.
Нужны какие-нибудь ассоциативности, если вы делаете массовые операции, там другие требования будут.
Ну, например, если я там хочу прибавить что-нибудь на отрезке, да...
На пути, да.
Да, тут тоже надо было написать.
То там, понятно, должна быть, видимо, какая-то коммутативность еще.
Вот там коммутативность, вот это все.
Ну, то есть, по большому счету, мы не будем здесь заморачиваться об суперформализм.
Мы просто скажем, что...
Ну, типа того, да.
Вот, то есть, вот это вот все, там всякие суммы, присваивания, минимум, это максимум, бла-бла-бла.
Вот.
И вот тут-то мы немножко начинаем страдать.
Да, потому что уже метод не работает.
Что же делать?
Нельзя же честно выполнять линк и кат, и после каждого раза строить на дереве ХЛД, правда?
Почему нет, если операция линк и кат, типа пять?
Ну, да.
Ну, да, если только они не редкие.
Если они редкие, то действительно делать ничего не надо.
Вот.
Чего?
Ну, в принципе, да, геново, да.
Кажется, что можно придумать, пытаться какую-то оффлайда,
потому что есть динамик-инвективити со стандартной технологией,
да.
Да, ну, мы, ну, видимо, что-то в эту сторону можно думать.
Да, ну, правда, да, это мы будем обсуждать, когда мы будем обсуждать СНМ.
Пока же мы за нот.
Но, как бы то, что я сейчас скажу, конечно, никакого отношения не к СНМ,
и там иметь не будет.
И к оффлайдам тоже.
Хотя, конечно, забирая вперед, у нас, конечно, структура данных получится до жути амортизированная.
Вот.
Поэтому, к сожалению, да, персистентные линкаты, к сожалению, не до структуры данных,
которые нам удастся хорошо поддерживать.
Вот.
Ну, ничего.
Но тем не менее, значит, как же мы это красиво будем хранить?
Значит, ну, то есть, понятно, что нам надо придумать какую-то структуру данных,
которая будет очень красиво как-то хранить эти деревья.
Вот.
Ну, вот.
Умеем ли мы?
Ну, вот.
Ну, мы умеем обычно хранить деревья.
Но обычно все наши способы хранения как-то красивых деревьев сводились к тому,
что мы эти деревья как-то делили на пути.
Вот.
Отдельно.
Ну, вот.
Ну, там.
То есть, как-то мы еще и для удобства себе говорили, что мы множество вершин делим на пути.
Каждый путь идет строго сверху вниз от предка к потомку.
Вот.
Вот.
Ну, например, как...
Ну, типичный пример у нас был Хэви-Лайт.
То есть, мы на каждом из этих...
То есть, мы там делили дерево на пути какие-то.
И на каждом пути хранили какое-то дерево отрезков или там какой-нибудь ВВ или что-нибудь еще в этом роде.
Или там еще какое-нибудь дерево, чтоб там вместо лог квадрата было гори.
Вот.
Значит, сегодня мы будем делать примерно то же самое.
То есть, на самом деле, каждое дерево...
То есть, каждое дерево у нас будет в каждый момент времени храниться в виде вот таких вот путей.
Вот.
Давайте.
Таких вот путей.
Вот.
То есть, будут пути.
Будут...
Так, давайте вот так сделаем.
Так.
Так, так, так, так.
Вот.
Значит, так, так, так.
Не, давайте два мартиры сделаем.
Так.
Вот.
Ну и соответственно, там каждый путь у нас будет какой-то.
То есть, там пути бывают абсолютно разные.
То есть, тут у нас еще какая-нибудь вот такая.
Такое вот будет.
Ну, теоретически я сразу скажу, может быть, вот еще-нибудь вот такого рода вполне.
Вот.
Но и т.д.
И т.д.
И т.п.
Вот.
Но ветвистость тут может быть какая угодно.
Давайте вот так.
Вот так.
И вот так сделаем.
Вот.
Вот.
То есть, у нас каждая нота.
То есть, смотрите.
То есть, у нас опять же, так сказать, нот.
Ну вот.
Вот.
То есть, у нас ребра будут.
Ну, давайте так.
Сейчас это будет, конечно, неформально.
Но они будут рыжие и синие.
Вот.
Ну.
Ну, скажем так.
У нас есть возможность пользоваться цветными маркерами.
Поэтому у нас будут рыжие и синие.
В оригинальной статье слайтера Торьяна.
Соответственно, они назывались.
Они бы назывались такие.
Что-то типа.
Сплошные и прирывистые.
Или что-то в этом роде.
Рыжие, сплошные и синие.
Да.
Там гарантируется, что у каждой вершины.
Существует не более, чем одно рыжее ребро, ведущее
из нее в ребенка.
Вот.
Ну, у нас вот.
Да.
Просто волей оказавшегося у меня в руке маркера.
Они будут рыжие.
Какой принцип покраски?
Вот.
Какой принцип покраски?
Ну, как я уже сказал, принцип простой.
У каждой вершины не более одного рыжего ребра в ребенка.
Если говорить об инварианте, то это все.
Ровно один, если это не не обязательно.
Не обязательно.
Вот.
Вот.
Вовсе не обязательно.
Да.
То есть, в точке зрения инварианта это все.
То есть, да.
В инварианте мы там требовали, что там рыжие ребра, это
какие-то там тяжелые ребра.
Ну, там красные были, правда, неважно.
А синие, это какие-то там легкие ребра.
То есть, там какие-то инварианты на СЗЭшке там выполнялись.
Ну, то сейчас мы этого делать не будем.
То есть, мы себе неожиданно заявим.
Мы себе неожиданно заявим, что у нас каждое дерево
мы будем хранить в виде вот такого разбиения на пути.
Но как выглядит в каждый конкретный момент времени эти пути,
мы, говорите, мы никак не ограничиваем.
Ну, собственно, кстати, в какой структуре данных
мы уже с чем-то подобным сталкивались?
Да.
Совершенно верно.
То есть, помните, у нас в сплее тоже было, что гарантируется,
что это двоичное дерево поиска, но какое конкретно,
а может быть любое.
То есть, магия заключается не в том, что в каждое время
может быть любое дерево, но в совокупности оно
магическим образом работает адекватно.
Да, в роли магии, как всегда, метод потенциалов.
Ну, причем, как вы уже догадываетесь, мы сегодня
от него, в общем-то, никуда не деемся.
Вот.
Но храни нот.
Но хранить как мы будем хранить?
Ну, хранить саму структуру будем так.
То есть, как вы уже догадываетесь,
на каждом пути мы будем хранить что-то умное.
В роли чего-то умного какое-то двоичное дерево поиска.
Потому что, как вы уже интуитивно догадываетесь,
наверное, это не просто должно быть дерево поиска,
желательно дерево поиска, которое поддерживает всякие
сплиты, мержи и прочую радость.
Логично, да?
Вот.
Значит, смотрите, изначально мы на самом деле будем считать,
что это достаточно произвольное дерево.
Вот.
Потому что, забирая вперед, скажем, что, в принципе,
основной анализ самой структуры позволяет тут, в принципе,
хранить абсолютно любое.
Что АВЛ, что декортичку, что сплит, что там.
Все что угодно.
И в результате мы получим, что, на самом деле,
асимптотика всей этой радости – лог квадрат.
На операцию.
То есть, если совсем тупую реализовать.
Вот.
Ну, эта структура данных тоже на уровне анонса.
Оказывается, мистика.
Да.
То есть, в общем случае, если вы впихнетесь туда произвольное
дерево, то у вас получится лог квадрат.
Но если вы вместо этого произвольного дерева просто
подставите сплей, вот просто подставите,
то магическим образом выяснится, что лог квадрат превратился
в лог.
В общем, это действительно достаточно волшебная вещь.
Но пока вы не используете правильные потенциалы в сплее.
Вот у нас с вами правильные потенциалы, поэтому, собственно,
у нас все будет.
Но пока, конечно, до этого надо дожить.
Начнем все-таки с лог квадрата.
Без этого никуда.
Но для этого, для того чтобы…
Ну, для лог квадрата нам, конечно, придется более
глубоко посмотреть, а что тут вообще происходит,
как конкретно мы эти всякие линки-каты будем…
с этими линками-катами будем работать.
Вот спрашивается, как же мы будем действительно с ними работать?
Ну, вот эти вот… какие-то операции на путях
и из деревьев отрезков, типа, да.
Но у нас, конечно, мечта у нас будет об операции линка,
об операции кат и об операции переподвешивания.
То есть, от нового корня.
Вы про пути рыжей говорите?
Нет.
Ну, не совсем.
Здесь я говорил про другие пути.
Нет, обратите внимание, здесь УВ – это вообще абсолютно
две произвольные вершины в одном дереве.
Мы структуру храним на рыжих путях?
Структуру храним на рыжих путях.
Если быть точнее, значит, происходит так.
Значит, каждому…
Значит, мы храним вообще структуру данных линкат,
или там линкат 3, как оно называется, в виде набора рыжих путей.
То есть, каждая вершина лежит ровно в одном рыжем пути.
И у каждого пути есть еще синее ребро.
То есть, это ребро родителя этого пути.
В общем, информация о нем хранится в корне,
вот, так сказать, дерева,
которая соответствует пути.
То есть, смотрите, каждому пути соответствует дерево.
Другие, которые вот это, а которые сбалансированы.
Вот сейчас у нас опять немножко путаницы будет.
То есть, есть как бы поэнот.
То есть, ну давайте, давайте его «авеликой» называть.
Вот.
То есть, как бы мы, то есть, у нас будет так.
Мы будем считать, что у нас каждый рыжий путь – это условная «авелька»,
и в корне «авельки» хранится информация о синем ребре,
торчащем из начала этого пути.
То есть, типа, там, куда оно ведет, там,
ну да, куда оно ведет, сколько оно там весит и так далее.
Вот.
И так вправивается, что же нас теперь ждет.
Значит, как же, как же мы будем реализовывать все эти линки и каты?
Ну, как вы уже догадываетесь, так как у нас структура рандомная,
только за конкретную структуру путей мы цепляться не будем.
Она у нас будет постоянно меняться.
Краеугольным камнем, конечно, является такая мистическая функция expose.
Значит, вот тут я прям полное определение напишу.
Значит, экспо, значит, операция expose от «у».
Значит, ну, на языке рыжие наше, это вот, это orange blood, вот, слушайте.
Слушайте, хорошее.
Ну, прям как раз.
Так вот, на языке нашей вот этой вот рыжей-синей декомпозиции,
точнее, раскраски, то есть экспо у «у» можно определить так.
То есть, нужно выполнить
минимальные
число
перекрашиваний.
Ребят,
вот,
вот,
вот,
вот,
вот,
так чтобы появился ржей путь
от у до корке
надо в чем чтобы не было то есть никаких изногласий еще важное подчекнул причем
конец пути то есть нам нужно не просто сделать так чтобы там у соединился с ржем путем с корнем
да но нужно чтобы еще и там на самой у ничего не висела никакие то есть у самой у больше
никаких рыжих детей быть не должно да еще минимально вот но то отдельная песня действительно
как но то как это сделать но на самом деле просто такое определение на самом деле уже вроде как
дает интуитивное представление о том а шоу мы собственно будем делать но просто давайте
просто давайте вообразим как вообще каким напрашивающимся способом вообще этот эксполс
можно выполнить типа того да вот давайте да только давайте вот это я покажу значит смотрите
значит давайте поподробнее значит подробнее да хотя вот идея такая то есть но начнем вот в
чего начнем с того что у нас где-то вершина у находится на каком-то ржем пути изначально так
но начнем мы с того но начнем из того что если у не конец своего пути да все пути мы естественно
сверху вниз храним да то естественно вот это вот ребро мы объявляем синим вот я когда его буду
обводить синим это означает что его перекрасил в синий цвет вот вот то есть теперь то есть это
мы делаем то есть в овл кем это делаем с помощью стандартного сплита что же мы делаем дальше
вот но тут мы неожиданно натыкаемся на начало то есть на начало этого пути и мы видим что оно
куда-то приходит то есть это видится какой-то синий ребро который ведет нас в какой-то другой
путь вот вот он вот он вот он вот какой-то еще путь ну а что мы делаем в этом случае ну во-первых
конечно но вот если у этой вершины действительно есть то есть какой-то рыжий ребро вниз то мы его
то мы делаем сплит вот так вот оно вот и после этого тогда вот эти два русской пути мы
смёрзиваем вот таким вот нехитрым образом вот что такое минимальный способ нет а что а что мы
могли нет ну как сказать зависим мы в общем-то пока форсировано делаем в общем-то ну скажем так
пока у нас нет каких-нибудь этих отложенных операций как бы и вот а вот а вот а в конкретном
этом контексте отложенных нет то ничего не делаем то есть делаем как более того забирать
вперед ничего нового тут мы не изобретем и будет работать буквально так вот дальше тут таки путь
опять у нас значит че еще да еще может в принципе так сложиться что путь вполне может оказаться
пути в принципе здесь же и заканчивается в этом смысле это называется нам повезло вот ну и мы так
делаем делаем делаем делаем до тех пор пока не дойдем до корня вот ну и здесь уже понятно без
вариантов тут красим тут красим то есть вот так будет работать эксполс на самом деле он будет
состоять из последовательности splice значит смотрите да то есть еще важно конечно отметить
что каждая вот такая операция у нас будет называться splice
ну по сути да ну вот я сказал так да вот то есть вот это вот конкретная операция когда когда мы
идем вверх и вот мы тут синий ребро красим в рыжий возможно перекрашиваю еще какой-то рыжий в
это мы будем называть splice ну фактически заметим что у нас что происходит у нас как получается
эксполс работает за один сплит плюс последовательность splice мы заметим кого конкретно и с кем нужно
splice мы обычно там выясняем за от единиц но в том плане что мы понятно что у нас есть путь мы
знаем кто у него синий ребро вот единственное что там конечно по каждой вершине мы должны
будем внутри дерева как-то понимать где оно находится и кого сплит но обычно это понимается
легко ну скажем правда как то есть конечно мы на это потратим не вот единицы там конечно логарифа
но с другой стороны мы и сплит но то есть конкретный сплит на первой велики мы явно тоже
за логарифом делать будем правда поэтому физически мы ничего не теряем
но количество действий на логарифу все-таки потому что каждый каждый вот этих свой каждый
splice все-таки и сплит мерш какой-то да то есть больше то есть условно говорят так конечно мы
бы это делали за количество splice если бы эти пути были там этими как их списками досвязанными
да были бы они двусвязанными списками нас был бы кайф так что в принципе если вы хотите сделать
линкат по двусвязанных списках то пожалуйста осталось только выяснить зачем вам нужна такая
структура данных хотя вот интересно если придумать какой-нибудь очень крутой она там
крутое применение то можно прям задачу на олимпиаду дать решение давайте напишем линкат но чтобы
была адекватная септотика сделаем его на списках работать оно будет правда тоже за логарифом
обычный линкат тоже работает с логарифом так что зачем нам это надо непонятно чего
а сделаем супер онлайн давайте отлично отличить да да да да почему бы нет ладно теперь будет
correlate но вот так ну теперь давайте посмотрим хорошо дать значит смотрите значит это значит это
у нас есть мистический эксполс то есть вот такое делать эксполс он будет то есть это будет так
внутренняя операция конечно потому что она влияет только на внутреннюю
переказ то есть понятно пользователи в общем-то абсолютно нахать кого мы
считаем рыжим и кого синим вот то есть ему нот он как бы у нас человек простой
стомтипом он взвести мне вы видите мне 300 грамм сосисок и все в общем-то вот но
вот но внутри конечно это будет операция важная то что практически с
любой когда угодно что мы будем делать мы всегда будем хотеть делать эксполс ну
например для нот но для разминочки вот для разминочки мы реализуем да
какой бы операцию нам для разминочки реализовать ну конечно же да есть такая
операция лца не кстати уже неплохая структура данных да то есть уже прикольная
могла быть такая абстрактная конечно немножко но задачка то есть там то есть
да но вот это дерево делайте липки делайте каты делайте переподвешивание что самое
страшное и еще и сделайте лца да совершенно верно да спасибо дайте еще
киевске нет окей да но действительно да оказывается что совершенно неожиданно
лца тувэ в общем-то с помощью эксползу делается очень несложно то есть делается она примерно
следующим образом то есть она то есть она делается давайте тут а нет рижем рижем все
правильно было то есть мы пытаемся делать так мы делаем эксполс от у потом делаем эксполс от
в и что дальше
ну по сути да но то есть дальше вот то есть дальше говорим что-то там вот так скажем
риту а ритор ну что-то получается что п с нет да что ж я все время не тем цветом пишу
вот аня нет ритор вот это так напишу перронт от пс от вот так скажи вот так вот так условно
я реализую все три строчки так ну действительно давайте вот попробуем нарисовать откуда я взял
откуда тут даже уже не я а кто-то из вас взял эти три строчки но чем логично откуда потому что
жила была жила было у жила было в жил был их лца и где-то тут кой да мы объявили эксполс от
у эксползату сказал что вот путь теперь выглядит вот так потом мы сказали эксполз от в то есть
путь теперь выглядит вот так и для этого мы тут вот это вот синенькая ребрышка отпилили таки
наоборот пока сидит синие ребрышка тут отпилили часть пути но и тогда берем путь от у берем
родителя берем родителей этого пути и вот он и лца то есть вот такой вот очень простой элегантный
метод но тем не менее в этом месте я произношу любым и два слова найдите ошибку
ну да хоть когда у предыдует так ну давайте смотреть потому что в принципе есть подозрение
что у нас есть проблемы когда кто-то тут чей-то предок но сейчас давайте разберемся вот если у
не предки друг друга то как видим действительно все успешно работает и даже лца может быть корнем
ничего страшного не будет вот но давайте предположим что он но давайте предположим что
совершенно случайно кто-то у нас казался чьим-то корнем вот но например у оказался корнем в предком
что тогда произойдет тогда кажется что сначала путь тут будет выполнен вот такой эксполс а потом
будет вот такой так то есть теперь но то есть теперь обнаруживается что родительский путь
у то есть это на самом деле путь корень и у него значит этого родителя тупо не существует
так тогда вытикает правда маленькая приятная задача даны вершины у его скажите пожалуйста
machen對ving cooler но нет но давайте после случаев рассмотрим чтобы убедиться когда это
бывает когда нет то есть в данном случае действительно оказывается но это на
пути и у действительно при этом а если а давайте посмотрим а что будет если на оборот в родитель
вот если оказалось наоборот что нас вот у нас вот у нас вы что тогда тогда оказывается тогда
оказывается да эксползату на лицо значит эксползат в но то же самое только вот делаем тут один вот
и тогда оказывается что parent от p-satu это в это точности правильный ответ
ну да на самом деле да как легко убедиться в этих случаях все гораздо проще есть то есть на
самом деле оказывается единственный случай когда этот ответ неправильный это когда на самом
деле этого паранта тупо не существует то есть я так напишу допишу по питоновской ритурен
parent и этот parent существует по-русски так напишу ну вот но в противном случае что мы вернем в
противном случае мы скажем что ответ это тупо вот но знаете это там типа типа а равно 5 там 5
и в том бы и делится на три л за 7 да вот это вот так вот питом же есть да будет
нет ну как сказать не но я тут просто написал я просто написал тут трендарный оператор но
питоновский вот то есть как бы я просто вот это не хотел стирать поэтому написал это немножко
вот вас там ждет то есть там будет такой формат то есть там в питоне можно писать вот так вот там
5 иф там б процент 3 равно равно нулю л за 7 вот питом есть такая конструкция да потому что тот
же самый трендарный оператор просто он пишется вот так а это а это кому как привычно то есть как
бы понять как бы просто у каждого языка просто там своя логика возможно там просто там под
своему там по-своему надо повернуть голову чтобы там бы адекватно писать на языке вот
ну да но получилось так да то есть вот такая вот приятная то есть л сашечка оказывается
реализованность такими приятными свойствами да то есть обратили но вот то есть кстати более
того к вопросу о то есть на самом деле если у нас задача выяснить является ли какая-то вершина
предком другой то есть например является ли вершина у предком в это общем из этих картинок
сразу решение делаем эксползат в этом тупо проявляем проверяем они на этом ли пути случайно
оказался ну там конечно везде правда смотрите есть один тонкий момент то есть везде для этого нам
придется каким-то образом выяснять для вершины какому пути она принадлежит то есть у нас как бы
как вы догадываетесь у нас вряд ли будет такая структура данных которая просто там будет какой-то
массив который там для каждой вершины будет прописывать в каком бы там в пути номер каком
он лежит правда у нас мы такую перекаску не можем себе позволить то есть конечно то есть
условно эвейки обычно придется видимо от вершины у просто идти по родителям доходить до корня там
в условном сплее как вы уже догадываетесь видимо придется просто сплее вызывать поэтому то есть
получается чтоб поэтому проверка является ли кто-то предком кого-то у нас будет к сожалению не
за единицу а за логарифм и это не считая эксполза вот то есть поэтому тут везде такие логарифмики
будут выплывать так так ну что еще можно сделать так ну в принципе еще есть такая простенькая на
самом деле с точки с этой точки зрения простенькая операция и верт как же сделать и верт
ну как-то да ну да то есть оказывается да при помощи такой технологии действительно там как
сделать у кордин да очень просто делаем то есть у нас какой-нибудь и верт давайте вот
то есть эвертоту будет писаться так значит мы делаем как всегда эксползату и а дальше мы
условно делаем реверс пас а то то есть обратите внимание мы этот реверс делаем только может
быть внутри пути то есть то есть условно говоря все вот и все вот эти синие товарищи ну хотя
нет кстати обратите внимание в общем-то синие то есть синие товарищи указывают не на путь
синие товарищи указывают на вершину то есть как бы мы висим на вершине то есть как бы у
этой вершины этот рыжий путь может там меняться может там сплите тела сплится мерзится но над как
бы если на него что-то тут о синих ребрах висит оно никак не меняется поэтому в принципе мы вот
этот вот путь можем спокойно реверсить и не заморачиваться поменяется то что мы путь храним
сверху вниз то есть когда мы находим какой-то путь у которого нет родителя то значит его начало
это корень поэтому когда мы сделали реверс мы сказали что теперь у это корень то есть у был
конец вот кстати может быть отчасти зачем мы вообще от учета отпиливали да то есть вот одна из
причин зачем отпиливали то есть мы сказали что то есть вот то есть мы эксползату сказали что у
меня теперь есть путь от начала корень а у конец а давайте сделаем теперь реверсу этого пути
теперь у это начало то есть корень все то есть вот оказывается да то есть то есть оказывается
вот так вот таким вот простым способом можно это сделать вот я та вот
ну как видите залог квадрат твой залог умножить на сколько сплайсов вы сделаете
то есть да нет правильно сказать если честно то залог на количество сплайсов плюс 1 ну вот
это если честно да так да нет а что значит подвешиваем вот давайте внимательно задумываемся
вот давайте подумаем смотрите давайте в нем да внимательно нет в чем проблема нет а что
поменяется но первое давайте внимательно скажу еще раз подчеркиваем где мы вообще в каком
месте вообще этой всей структуры мы храним синие ребра да то есть у каждого пути в хоре там в
хоре этого пути хранится информация что на самом деле этот путь подвешен за синие ребро какой-то
вот вершине и у него есть еще какой-то вес все вот то есть принципе заметь что в принципе сам
по себе вот этот путь вообще не знает что на нем что на нем там вообще что-то висит
напоминаю нас на каждом ребре чиселка хранится мы с этими чиселками еще страдаем вот ну можно
на вершинах естественно хранить они на рёбрах но как бы суть одна хотя с ребрами как бы реализация
еще вообще вопрос как этот путь вообще нормально хранить кстати еще будет впрочем прям тут
что-то реализацию надо внимательно смотреть потому что чтобы как бы внимательно доказывать почему
у нас там со сплеем получится все хорошо потому что да чтобы поддержать интриги то есть честно
говоря да ты знаешь сегодня мы убедимся это простой алгоритм но кода но вот но как бы года года
скажем 4 до сат лично мне не было понятно откуда там вообще берется логерев его нет потому что
вообще мистическая история вот парадокс том что классическая реализация ну как бы
после свинка там так как бы все знают что если блинкате написать с плей то вместо лог квадрата
будет логерев до этого года все знают ну если ну в сообществе ну как бы просто ну знаете просто
общие сведения ну как бы вот есть тирем пифагора там допустим да и есть вот это да ну вот там не все
я знаю доказательство те римпи фагора но как вы transportation знают все но также и здесь вот но
как бы если доказательство те римпи фагора как бы скорее всего в том сообщении в котором и сами
крутимся все-таки скорее всего вам расскажут хотя нет ну давайте так вот поднимите руки кто
готов был бы выйти к доске теоретически да и в течении там подумав две минуты рассказать
доказательства теперь пифа гора и вот не рискнешь хряща ладно ну вот ну может быть
нету дальше будет зависеть от того какие доказательства хотите дай их там конечно да
нету я я говорю любое доказательство на самом деле ну то есть вот это вот классическое доказательство
давайте там нарисуем квадратик и там посмотрим его площади да вот это все вот нет но я не хочу
сейчас в это углубляться просто как бы ради интереса так просто ради интереса был вот ну
вот но к сожалению тут история уже не такая потому что так прикольная история была заключалась
следующим потому что в принципе доказательства то есть так на уровне если вы хотите доказать что
вот это вот там правильная реализация работает залог квадрат то это доказательства найдете в
куче мест начинает просто свитки конспект вот торпора потолка в конспекте там блок квадрат
все чуть-чуть четенько расписано там все хорошо замечательная вот там можно это найти или там
на английском языке будете гуглить можно там какие-нибудь вики там что-то еще и мой тишины
конспекты найти кстати то есть знаете как и странно там можно найти конспекта assignment
продвинутого логовитмического курса вм идти вот и кстати там вообще хороший такие конспекты
вообще очень интересные вот но почему-то там залог квадратом расписывает все
вообще это как только доходит до сплея логарифа там подсчета начинает говорить
ой ну там нет ну там как бы все там что-то потанциал и красиво схлопнутся и
будет хорошо вот самое страшное что потом вы находите вы не отчаивайтесь
находите видео лекцию станки еще просплей дерево тупра линкат но он говорит вам
буквально то же самое с точностью долгарифа окей но ну хорошо но я нет я
рассказываю просто момент несколько лет не дает давности вот все что нашел было
так а самое страшное естественно как конечно тут в этом случае надо но чего
а что говорит оригинальная статья так вот оригинальная статья значит про
динамики там слейтор и тарьяна про динамические деревья она говорит следующее а давайте
подставим какой-то мистическое деревья с абсолютно какой-то не подберу другого
слова там какими-то укуренными вариантами вот не подберу другого слова то есть там
какая-то черная магия так вот там с какой-то черной магией так вот на самом деле можно
показать что вот это вот черная магия то есть это черная магия действительно работает и тут
вместо лог квадрата будет логариф вот чем я уже я уже начал думать что может это такое просто
совпадение какой-то мистическое заблуждение какой-то еще как бы кажется что работает
залогарифом на самом деле доказательства ни у кого нет ну я не знаю но я не знаю то замедлили
нет лакшер открывался как раз просто надо было оказывается надо было просто открыть статью
секрет просто нет секрет оказался простой дело в том что с плей дерева было изобретено
абсолютно теми же авторами да но теми же авторами через датам если верить статьям через два года
после лентгата нет то есть они не видимо там были изысканий там появилось плей дерева появилось
мистическое статья о том что то есть плей дерева который там у нас там есть куча разных этих
деревьев там пойте мы с вами обсуждали там под разные нужды там разные потенциалы там
блабла блабла и вот выясняет что сплей дерева убеет все главное просто верить в амортизацию вот то
есть амортизация аллилуйя да вот это вот но то что и ну вот и оказывается одним из применений
оказывается что давайте вместо там этого безобразия давайте подставим сюда с плей и тоже будет работать
вот то есть такая вот на это пока мне лично моя история изыска изыскания этого вопроса была
вот это соответственно что нас ждет но как выяснилось действительно не сложно чем более того то есть
то есть более того собственно мы с вами уже даже подготовились собственно сделать там правильный
потенциал сплея но до этого надо еще дожить и так потому что ладно хорошо мы научили мы поняли как
так что мы еще поняли но в принципе я думаю вы уже ну в принципе я думаю вы догадывает то есть
вы догадываетесь как теоретически можно делать вот эти все операции но на самом деле тут у вас
есть даже выбор но потому что самая тупая идея на что вы можете сделать это конечно сделать
эвертат у быстренько то есть делаем эвертат у делаем экспозат в на этом то есть ну там добиваемся
того что у и вы у вас лежат на одном пути являются его концами да ну так давайте на этом пути после
этого там объявим там либо возьмем сумму либо там сделая опять там повесим в корень отложенную
операцию вот эту да присваивание или там вот прибавление и после этого там может по и вертим
обратно после этой极ив masey можно сделать так можно на самом деле сделать так может
благодарь не спит на самом деле делать и так далее но то есть как вы потом как потом �итрый
подобные вещи tracing уже делать аккуратно имея в виду относительно своем в каком потенциале мы
живем но заранее скажем что ничего страшного там не будет ну в конце концов там линки катым и
будем делать но там самый тупой для кум comedy самый тупой идейно можно просто сделать кибетам
пару вертов и не парится в принципе кстати может даже не самая плохая вещь но собственно
краеугольниками как делать линк как делать как вот как вы думаете что проще
но на самом деле но скажем так там есть пара оговорок оказывается что как в кате пожалуй
сделать проще вот значит как пожалуй сделать него но потому что в кате ну хотя нет флага и
так и так то есть придется вот то есть нельзя просто так там поспитить какой-то путь то есть
у нас вот ну вот будет у нас вот такая вот красота то есть просто так отспитить никого нельзя вот
но мы но вот но обычно кат конечно делается простым естественным образом как вы уже радуешь мы
делаем эксполз отве чего а ну хотя хотя хороший вопрос хотя да ладно здесь а ну да поэтому кат и
легче можно видео его на самом деле можно как угодно делать но вообще да самый логичный вариант
действительно который тут уже подсказывает действительно давайте просто сделаем эксплу тупо
эксползот у и неожиданно обнаружим что после этого действительно у нас вершина в соедини нас у
теперь синим заведомо синим ребром и остается просто в этом вместо этого синие ребра написать
что а больше тут нет ничего вот так parent от там песо тв равно то есть там присвоить так сказать ну
все чуваке вату но нет и я честно предлагал видимо более сложным почему-то мне хотел
сделать эксползот вы сделать сприт в дереве но пожалуй и этот вариант лучше впрочем как всегда
кодовая фраза эти там и там поймем потенциал и тогда относительно этого потенциала что-то
и пойду потому что скажем вот с линком например у нас вот потому что в линке есть маленькая
подляночка потому что в линке например авторы просто очень жестко требует что реализация
должна быть именно значит поехали эксполз но во первых эксползот у вот прям обязательно
вот линк вот мы хотим в подвесить ку то есть к абсолютно я но вот вот у меня есть вершина у
она живет в каком-то дереве и жила была вершина в который является корнем другого дерева что-что
кого верт нет но это другой вопрос но обычно скажет так в линке подразумевается что вы
такой да в принципе не там не очень сильное предположение можно от него обойтись но вот
дефолтная реализация все-таки говорит что линк все-таки подвешивает корень вот хотя
так вот это делаем эксполз от и после но вот а дальше что важно делаем ну в оригинальной
статей используется конечно в этом месте такое слово как агрегат но на нашем языке это
просто написано просто мэрш я так напишу условно мэрш пэссот у пэссот в
вот ну конечно он будет подразумевать что между этими двумя путями есть еще
какое-то ребро и его надо учесть вот но это уже детали
вот такая красота эксполз есть мэрш есть радость есть вот то есть вот идея на вот такая реализация
что нет туда вот подлянки на том что авторы требуют что вот реализация дадут быть вот
такая почему-то ну какая ну бы самая тупая реализация которая могла бы быть давайте сделаем
эксползат в но первое нет ладно хотя даже не эксползат в самой тупой что можно было сделать
но раз вы корень а давайте синим ребром подвесим и руку и вообще не будем париться вот вообще сам
эту поршу могли сделать это вот это но но вот но по каким-то видимо потенциальным причинам
по каким-то теоретически потенциальным причинам вообще но нет как-то ну как сказать потому что
этот мёрзший ашкин то есть как бы не надо что этот мёрзший это просто честно взял там два
то есть там просто момент такой что если уж мы храним на ребрах какую-то информацию да то
нам придется то есть у нас это не просто деревья у нас какие-то мистические деревья то есть там
какие-то мистические деревья которые каким-то образом видимо эту информацию еще и хранят то
есть и это кстати отдельная песня как это делать то есть может быть вообще было бы нам легче если
информация вершина хранилась вот отдельно как реверс делать то есть один из вариантов вообще
знаете какой это вариант на самом деле если у вас там скажем там я не знаю там ка есть у вас там в
пути ка вершин то предлагается хранить там какой-нибудь сплей дерево то есть там пытаться хранить какой-нибудь
сплэйде там сплэйдерва на 2 ка минус одну вершину даже для того чтобы на промежутчинах
вершина хранить себе собственно сами по себе чиселки нет понятно да что есть конечно очень
большой соблазн действительно для каждой вершины хранить чиселку который ведет ее в родитель но есть
один маленький нюанс нюанс называется реверс но как как еду как и нет но там как бы нет но там
какие варианты есть да то есть как бы либо вы это все храните в одном дереве либо как бы вы
вершинке храните в одном дереве и а сам массив ребер в другом например да то есть если там для
вершины знаете что она там на приписи там я не знаю 57 в своем пути то значит тогда ребро ведущие
в родители это просто там 56 и ребро да вот то есть ну теоретически можно так то есть можно так
можно эдак да ну то есть на самом деле до идеи на конечно можно сказать так что давайте просто то
есть на самом деле как бы не кончится то есть можно просто каждый ребро мысленно всегда сплитить
надо сплитить на два ребра и тот одну вершинку в этой вершинке хранить чиселку идейна в общем-то
тогда ничего тогда в общем тоже очевидно что идеи на все сводится тогда к случаю когда у нас
чиселки на вершинах находятся вот но тут как бы да тонкие маме анот но поэтому вот но мешка
что будет предназемевать в этом месте конечно когда мы тут сливаем два пути мы подозреваем
что эти два пути соединили бром то есть это да ребро тут в пс от в написано вот это синее ребро
и мы это но вот и мы как бы должны должны это в мёрчить ну да совершенно верно да да то есть на
самом деле дай решать до фпс от вы сейчас ничего не было написано но на самом деле вот как бы
вопрос где использует вот этот вес а вот он вот надо создать новое ребро весовый ты через него
еще и померз то есть по-хорошему да тут надо через запятую еще в 8 написать вот это для нас
будет важно дожутия принципиально важно так так так так вот теперь но то кажется вроде нам
удалось вроде достаточно точно понять как это пенот собственно как это реализовывать
пока ими на уровне идеи и в принципе легко заметить что по такой реализации на самом
деле все работает за не более чем логарифом плюс эксполс правда а многие операции работают
даже за единицу плюс эксполс по сути правда но потому что всякие потому что как бы помним
реальное время реверсов и всяких там присваивания на пыл на всем динам всем там на все в эльки то
вот единицы потому что да вот эти отложенные отложенные там всякие эти присваивания развороты
и так далее никто не отменял вот то есть по сути теперь вопрос за сколько у нас работают эксполс
вот эксполс у нас работают на самом деле за нот эксполс она за сколько работает
но пока мы этого не знаем мы знаем точно только одно эксполсы работают за логарифом умноженный
на число сплайсов
так сейчас я не понял еще
почему знаем нет у нас да да нет ну как сказать нет если мы говорим об обверте для сумма то нам
как бы не ничто в конце не мешает сделать эверт от того корня который там был изначально то есть
тут подразумевается что корень по идее подразумевается внимание еще раз что как бы корень
задает по идее пользователь то есть как бы если мы в сумме решили при подвесить дерево за какие-то
там свою вершину из под своих нужд то но то как бы нам надо не забыть потом вернуть все на место
вот или использовать какие-то еще варианты вот потому что нет смотрите потому что на самом
деле если у нас есть сумма тувы и у его не являются предками друг друга то на самом деле
совсем уж при подвешивать никому не надо потому что обратить внимание мы могли бы сделать на
берем эксползат у там сделать эксползат вейс и добавить к ответу вот эту сумму потом сделать
еще раз эксползату и добавить к ответу вот эту сумму то есть никаких то есть никаких
переподвешиваний зато 3 эксползав прочим с но прочим совсем но прочим сывер в иверте тоже
вам эксполз потребуется поэтому тут вы как бы в этом месте никаких экономии эксползов нет ну да
так что так и так да что там три что там три вот то есть тут по разному можно делать сумму там
присваивание тоже можно вот но типа но вот ну типа того да а мы но нет толковые если мы разрешаем
себе делать внутренние верты то все эти операции делаются тупым образом делаем и верт от у делаем
эксползат в то есть получаем вот этот корневой путь на котором делаем все что нам надо и после
этого вызываем и верт от того корня который там был раньше вот то есть как бы такой тупой
вариант который у нас был раньше но можно пытаться от него его избегать если не очень
хочется но в любом случае конечно там что эффективнее что нет то есть в данном случае хотя
бы разобраться такое симпатику но как я уже говорил работает у нас все за логарифом умножить
на сплайсы но то есть по факту то есть но на самом деле то есть все равно то есть по факту так у нас
есть какие-то сплайсы каждый из которых это какие-то операции с деревьями но ключом на то есть
ключом анализа у нас будет будет то что то есть мы сейчас будем считать сколько у нас сплайсов
вот сейчас смотрите внимательно сейчас у нас будет немножко нет реально то есть наша цель сейчас
посчитать учетное количество сплайсов они учетное время работы ну то есть как бы это не ничего
страшного это мне то есть если мы докажем случайно что скажем учетное число сплайсов на операцию там
скажем ну я не знаю корень корень из n да то из этого то есть это будет эквивалентно тому что мы
докажем что если у нас были какие-то деревья которые там изначально были n вершин каждая там
состоялась там n деревья в каждой состоялась одной вершины и мы с ними сделали кооперации то
значит суммарное число там всех то есть там суммарно все эти там ку вот этих вот запросов были
выполнены за ку корней из n точнее так точнее так ладно вы не так то есть как бы если у нас было
ку запросов в каждом из этих запросов было константное количество обратите внимание эксползов
но вот поэтому получается что о от ку корней из n сплайсов было выполнено ну а дальше все зависит
от того как вы конкретно сплайс делали но теперь самое тупое что если делаем рандомные овл и ну или
там я не знаю может кто-то из вас там я знаю дикотячку любит я не знаю вот то будет там ку корней из n на
лог n но если мы докажем что сплайсов не корень из n а корень кубический из n будет ку корней кубических
из n а если мы случайно докажем что сплайсов от единицы то будет вообще ку на вот этот логариф но
ничего из этого нам к сожалению доказать не удастся ну где-то к сожалению но где-то к счастью да
что корень из n тут был бы конечно неожиданностью но мы так вот но мы нацелимся на то чтобы доказать
что учетное число сплайсов у нас логариф на операцию на операцию эксполз да то есть если у нас
будет выполнено там ку вот на этот раз не ку вот этих операций если у нас будет ку всего именно
эксползов то я утверждаю что сплайсов будет о от ку логан где н количество вершин участвующих в
этом вот все то есть вот такая вот идея вот спрашивается как же мы это будем делать какой
же мы потенциал введем так ну смотрите значит я временно значит смотрите тут внимательно сейчас
я временно убираю вот это все хотя как бы да ну да но это избегаешь перед немножко нет сейчас
пока все будет гораздо проще значит смотрите дальше ты так оценим что сплайсов я временно убираю
вот эти операции хотя конечно забирай вперед скажем скажем что анализ эксполза сам по себе
анализ вот этих вот операции не даст потому что может быть эти операции работают там помимо
эксполза какие-то простые операции на которые там задирает потенциал на небес правда значит на
я тут это уберу ну еще заодно вот жалко вот это стучки поставили а доску не поставили
хотя конечно давно пора было сюда как вторую доску притащить так такая красота была ну ладно
на самом деле на счет рить дело в том что тут важно подчеркнуть значит у нас с вами есть
ребра значит у нас ребра бывают рыжие и и синие вот а еще а еще они бывают тяжелые
и легкие
так так давайте кто назови партии синие от фиолетового адекватно отличается так на камере
нормально от них вот значит синие от фиолетового но вот то есть смотрите что такое тяжелое легкое
ребро ну смысл ровно тот же как минимум виртуально то есть в явном виде нам конечно сложно будет
виртуально как сзат вы можем правда поэтому мы в принципе можем то есть мы можем как бы
иметь в виду что у каждой вершины есть какой-то потомки какие-то поддирала и им можно сказать что
пусть сзат вы это как бы количество ее потомка считая себя любимую естественно ну тогда
естественно вводит автоматически водится понятия тяжелых легких ребер абсолютно так же как мы
делали это в прошлый раз, то есть напомню, что у нас ребро УВ, где у родителей является тяжелым,
если тут у меня оказалось, что СЗОВ больше либо равно, чем 1 вторая СЗОТУ. Ну, как всегда,
тяжелого, как всегда, у каждой вершины не более одного тяжелого ребенка. Вот, мечта, мечта.
Значит, вершины у нас тяжелые. В прошлый раз мы уже обсуждали с вами, что в хавиллайте есть
большой соблазн у каждой вершины объявить ровно одного тяжелого ребенка, просто отправить самое
тяжелое под дерево. Это в принципе даже может эффективнее работать, потому что путей будет
меньше. Но здесь мы этого делать не будем. Здесь мы прямо жестко определяем, что у нас есть тяжелое
ребро, есть легкое ребро. Итак, ну давайте смотреть, как вы думаете. Итак, чему же будет равен наш
потенциал? Наш будет, давайте, красивый зелененький потенциал. Значит, наш потенциал будет количество,
ну да, логично. Ну, как вы уже догадались по маркерам, которые я взял в руки, количество
рыжих, легких. Вот такой потенциал у нас будет. Вот, понятно, да? Почему
я беру, вот как вы знаете, сразу расскажу мне монику, потому что я потенциал так не помню.
Но на что я ориентируюсь? Я ориентируюсь на следующее. Я сразу всегда держу в голове,
вот просто как запомнить, почему именно рыжих, легких, а не там, я не знаю, тяжелых синих, там,
я не знаю, или там тяжелых рыжих, или там тяжелых легких, там вот это вот все. Да, да, да, вот это
все, да. Так вот, я запоминаю очень просто. Я вспоминаю, как работает иверт. Потому что как у
нас работает иверт? Он работает за один эксполс и один реверс. То есть, мне очень хочется, чтобы
реверс, то есть вот реверс, поменял потенциал не очень сильно, сам по себе реверс. А ведь,
заметим, реверс это серьезная операция. Она берет огромное количество рёбер и удаляет их,
а вместо них по сути добавляет другие рёбра. Ну другие в том плане, что они по сути поменяли
направление, но с другой стороны, заметим, что дерево, то есть у этих рёбер понятие тяжелость,
легкость и так далее сильно поменялось, правда? Вот, поэтому очень хотелось бы,
чтобы, то есть очень хотелось бы в потенциале, то есть если бы я в потенциале как-то использовал
какие-нибудь рыжие тяжелые рёбра, то у меня могли бы быть проблемы. Потому что, как у меня
поменялось количество тяжелых рёбер, я не знаю. Вот, но очень удобно мы сейчас, заметим,
что на любом пути от вершины до корня у нас всегда не более чем логарифма лёгких рёбер.
Ну пойте, в прошлый раз мы сталкивались уже с такой идеей, что если вы идете от вершины до корня,
то у вас изначально СЗ1, в конце СЗН, при проходе по легкому ребру сайс возрастает в два раза,
хотя бы. Поэтому мне как-то сразу почему-то становится комфортно на душе, потому что я вижу,
что количество рыжих, скажем, лёгких рёбер. То есть мы понимаем, что когда вы убили этот путь,
у вас там было не более чем логарифма лёгких рёбер, когда восстановили, у вас их стало тоже не
более чем логарифм. То есть в худшем случае у вас изначально лёгких было ноль, стало логарифм.
То есть потенциал увеличился не более чем логарифм. Ну ладно, не самый универсальный способ именно это
запомнить, потому что в принципе, как легко заметить, количество тяжёлых рыжих рёбер,
конкретно ребёрс поменял тоже не сильно. Но тем не менее. Там действительно картинка будет
именно такая, что с ребёрсом разобрались за логарифм. Но давайте в первую очередь рассмотрим сам
эксполз. То есть у нас цель, в общем-то, как-то сами сплайсы рассмотреть. Но хотя,
с другой стороны, чтобы их рассмотреть, надо ещё посмотреть, кто увеличивает потенциал. Но,
в принципе, самая жёсткая, кто увеличивает потенциал помимо самого эксполза, это ребёрс.
Потому что, как вы уже поняли, сам по себе ребёрк, кроме эксполза, может увеличить потенциал
на логарифм. Но, слава богу, что это именно логарифм. Кто у нас ещё может повлиять на этот потенциал?
Ну, по сути, да. В каком месте потенциал меняется помимо собственных эксползов или уже рассмотренных
линкокат. Но давайте думать, как у нас работает линк. Обратите внимание, он помимо эксползов
мёржит два дерева. Важный момент, добавленное ребро тут же становится рыжим. Теперь мы заметим
следующее, что от самого по себе мёржа на самом деле все остальные ребра не меняются от слова
никак. И в плане лёгкость-тяжелость меняется только у ребер самого этого пути,
которого мы мёржим. Она может поменяться сильно. Когда вы мёржите вот этот путь с вот этим путём,
да? Нет, погодите, вот этого ребра у нас не было вообще, напоминаю. Оно только появляется.
Да, конечно, от всех ребер, связанных непосредственно с этим путём, их на самом
деле тяжелая лёгкость могла поменяться. Но чем приятен наш потенциал? Тем, что если ребро синее,
то нас это не волнует. Нас волнует только, если оно рыжее. Но заметим, что для всех остальных
рыжих ребер у нас тоже ничего не поменялось. А что произошло непосредственно в мёрже? Ну там
как угодно. На самом деле, конечно, вот эти ребра вполне могли перестать быть лёгкими и стать тяжёлыми.
Но на самом деле заметим, что вот у этих ребер вообще ничего не поменялось от самого мёржа,
да? А вот у этих ребер на самом деле они могли быть лёгкими, были лёгкими и стали тяжёлыми.
Нет, из тяжёлых лёгкие от того, что к ним что-то подвесили, они не могут. Да,
поэтому получается, что с линком нам даже повезло. Оказывается, сам по себе мёрж,
само все слияние этих деревьев на самом деле потенциал даже уменьшает. Ладно, может увеличить
на один случайно, если вот это вот ребро оказалось лёгким. То есть поэтому нам фантастически повезло.
То есть линк увеличивает потенциал не более чем на один, если прям вот очень-очень не повезёт.
А вот кат, вот с катом в этом смысле подлянка, конечно. Хотя, ну с катом в чём подлянка? Казалось
бы, да? Что делает кат? Кат на самом деле у нас, помните, мы реализовали кат с вами каким образом?
Мы его реализовали так. Жил-был У, то есть мы тут сделали expose от У, то есть добились того,
что у нас тут вершина В, то есть тут отдельно висит, и потом мы удалили вот это ребро. То есть вот это
ребро, в чём удалили, казалось бы, когда оно синее. Казалось бы, удалили ребро, ещё и синее.
Ничего не поменялось, идём дальше. Но нет. И тут подлянка в том, что вот тут как раз вот эти вот
рыжие тяжёлые ребра могли стать лёгкими. И тут потенциал, то есть оказывается парадок,
что кат как раз мог увеличить потенциал, а не линк. Да, но слава богу, он тоже это сделал не
более чем за логарифом. То есть тут не более чем логарифом новых лёгких ребер неожиданно появилось.
Обычно удаление уменьшает потенциал. Ну да, а у нас вот так. Поэтому лично у меня это вызывает
ощущение парадоксальности. Хотя, в принципе, ну да. Ну почему? Ну я не знаю. Ну что такое искусственность
этот вопрос, к сожалению, мне сложно залезть в голову там Дэниелу Слейктуру и Роберту Эндре
Тарьяну. Кстати, авторам этого счастья. И там как бы что у них было в голове, когда они,
собственно, хотят доказать, что у них вот ровно такое. И что? А у нас в потенциале было количество
кучи или что? В каких у нас такой потенциал был? Фибоначчи у них количество кучи по себе не было,
там было количество деревьев. То есть там куча, это связанный список деревьев. Вот и количество этих
деревьев, да, было. Но это да, это есть такое, конечно. Ну ладно, нет, ну окей, нет. Если вас так не
вызывает парадоксальность, просто хотелось подчеркнуть, что да, касталинк у нас потенциал
практически уменьшает, точнее увеличивать не более чем на один, а вот кат может его увеличивать
до логарифма. То есть это означает маленькую приятную вещь, что все кроме эксползов на самом
деле увеличивает потенциал суммарно не более чем на кул и логарифм. Вот. То есть и так. То есть
напоминаю, что у нас было ку запросов, которые порождают условно о от ку эксползов. Ну там что-то
типа не более чем что-то типа 3 ку и так далее. А теперь давайте, ну вот, это у нас потенциал,
но напоминаю, что этот потенциал, напоминаю, он не на время работы, это на количество сплайсов.
Помните, да? Теперь, то есть мы оцениваем количество сплайсов. Вот. То есть мы отдельная
песня потом будем думать, собственно, как оценивать то, как конкретно сплайс делается. Ну, значит,
смотрите. В чем магия? Но давайте, но для этого давайте смотреть. А какие сплайсы мы вообще делаем?
Вот какие сплайсы мы вообще теоретически можем делать? Вот. Так, давайте все-таки введем эту
буковку. То есть давайте скажем так, у нас всего, допустим, ладно сейчас подниму, ку операций и,
соответственно, ку штрих не превосходит там о от ку непосредственно эксползов.
Понятно, да? Ну, про потенциал, ну вот. Так. Ну, в принципе, смотрите. Просто на самом деле можно
заметить следующее. Я вот почему тут нарисовал заранее вот такую картинку. Потому что заметим,
что сплайсов у нас бывают два. Вот не помню, как они там называются, но здесь они называются
простой и сложный. Вот есть такой простой сплайс, когда выяснилось, что оказывается, чтобы покрасить
это ребро в рыжий, мы просто его красим, картинируем пути и все. То есть такой сплайс мы назовем,
давайте назовем его простой, а вот этот назовем сложный. Нет, простой, то есть сплайс называется
простым, да, если для перекраски синего ребра в рыжий цвет не пришлось перекрашивать кого-то
рыжего в синий. То есть сплайс должен перекрасить синий ребро в рыжий. Бывают ситуации, когда для
этого нужно какое-то рыжее в синий перекрасить, бывает, что не надо. Вот когда не надо, это просто,
а когда надо, это сложно. Ну да. Ну, естественно, я тут, конечно, не все нарисовал. Конечно же,
у каждой такой тут вершины, тут позвать, что тут везде, конечно, там всякие синие,
но и тут везде, в общем, там всяких синих этих, там до шиша на самом деле. Вот тут они, вот тут,
вот тут могут висеть. То есть никто ж не сказал, что путь прямо обязательно до тупика идет. Вот.
Ну и так далее, и так далее. Как говорится, и так дальше, и так дальше, и так дальше. Как сказал
представитель какой-нибудь польской команды. Вот. И так. На самом деле начнем с такого
разминочного утверждения. Так вот, смотрите. Маленького разминочного утверждения.
И так, значит, видите, у нас там куштри всяких, ну вот, то есть у нас вот этих вот,
значит, получается там куштри всяких эксползов. Я утверждаю на самом деле следующее. То есть
есть такое маленькое утверждение. Вот простых сплайсов. Всего не более.
Вот. Не более чем сколько. Я утверждаю, что не более чем куштри. Может я наврал.
Но почему-то у меня жуткое ощущение, что их даже не от куштри, а просто куштри.
Причем причина на самом деле достаточно банальна. Дело в том, что простой сплайс,
он чем отличается от сложного? Он отличается тем, что он увеличивает,
что он уменьшает число синих ребер. Обратите внимание, смотрите, как у нас, что у нас
происходит вне эксползов. То есть вне эксползов режиссивность ребер на самом деле меняется не
очень. Вообще, то есть, заметим, что мы, что, как бы, вот я же вроде как не наврал. Давайте вот
внимательно проверим. Если скажу, что мы ребра, мы не занимаемся перекраской ребер вне эксползов.
Правда? То есть у нас только эксполз, понимаете, перекраска. То есть единственное, что у нас может
произойти, это в линк-кате, то есть в линке-кате могут появиться новые ребра и удалиться новые
ребра. Правда? Вот. Но на самом деле, но, заметим, следующее, что когда линк добавляет новое ребро,
оно обязательно рыжее. Правда? Вот. Ну, в кате, конечно, может быть хитрее. Ну, хотя ладно,
наврал. В кате, конечно, мы можем сделать это ребро синим, но мы его все равно тут же удаляем.
Поэтому, как бы, получается, извне новые синие ребра не особо часто появляются. Даже не просто
часто, они никогда не появляются. А где же у нас они вообще могут появляться? Просто где у нас
количество синих ребер может увеличиваться? Ведь должно же так происходить, что они должны
увеличиваться, правда? Изначально их нет вообще. То есть, обратите внимание, у нас синих ребер, в
принципе, нет вообще изначально, потому что у нас изначально просто Н голых вершин, которые мы как-то
там потом линкаем друг с другом. Спрашивается, а за счет чего у нас вообще может увеличиваться,
тогда получается количество синих ребер. Да, но где? Да, вот обратите внимание, видите, вот это
в самом начале. Да, совершенно верно. То есть, обратите внимание, да, в самом начале у нас оказывается
просто магическая операция. Ровно за счет этой операции у нас количество синих ребер вообще
может увеличиваться хоть когда-либо. Потому что извне у нас количество синих ребер не
увеличивается глобально. То есть, он делает эксполс и убивает синие ребро. Линк создает новое
ребро в момент мержа, но это ребро рыжая. Поэтому получается только в эксползе, на самом деле,
за счет эксполза количество синих ребер увеличивается, но увеличивается только в этом месте. Но это
происходит не более чем один раз на каждый эксполс. После этого синие ребра только уменьшаются. То есть,
сложный сплайс оставляет количество синих ребер тем же, а простой сплайс их уменьшает. То есть,
тут можно ввести просто чуть другой потенциал и с помощью его доказать утверждение именно вот
в этом месте. То есть, глобально у вас простых сплайсов получается не более чем сколько эксполсов.
То есть, обратите внимание, видите, у меня разница есть Q операции, я имею в виду линк от вот этих
вот запросов. Но вот Q штрих эксполсов. Вот давайте не путать обозначения. То есть,
простых сплайсов получается не более чем Q штрих. Причем, видите, даже не от Q штриха,
а просто Q штрих. Вот такая вот классическая идея. Какой рис? Нет, ну там, да нет. Нет,
просто какую последнюю мысль имеется в виду там? Как бы я по идее просто сказал, что заметим,
что у нас как бы помимо эксполза количество синих ребер не увеличивается никак. Внутри эксполза
оно может увеличиться на один вот в этом месте, а остальное состоит либо из сложных сплайсов,
которые оставляют количество синих ребер тем же, либо берет простой сплайс, который уменьшает
их количество. Но заметим, что изначально у нас синих ребер ноль. Следовательно, рассмотрим
такой другой потенциал, количество синих ребер. Нет, такие, видите, то есть, как вот интересно,
то есть утверждение такое, что вот глобально мы сейчас не заморачиваемся, сколько там всего
сплайсов, но говорим, что докажем, что простых сплайсов не более чем Q штрих. Доказательства.
Нам рассмотрим потенциал, там другой потенциал, не этот, а другой, там синий, равный количеству
синих ребер. Этот потенциал изначально ноль, и он увеличивается не более чем Q штрих раз.
Каждый простой сплайс его уменьшает, а увеличивается он не больше чем Q штрих раз. Он
не может уменьшиться больше, то есть, по сути, монетку кладем короче. То есть, давайте так,
то есть, как всегда, на каждое синие ребро кладем синюю монетку, как всегда. Вот,
интересно, в какой стране у нас синие монетки? Рыжие монетки чаще встречаются, конечно,
хотя нет, у меня синем. Но мало, нет, у меня ассоциация жетунчик в метро, на самом деле.
Ух ты! Не, ну да, на самом деле, да, сам бог велел нам, конечно, класть цифровые рубли
на виртуальные ребра, конечно. Это да, вот они зачем изобретенные. Хорошо, да, ну вот,
ну короче, хорошо, ладно, жила было синие ребро, ладно, синие ребро, это хорошо, да, ура. Вот,
поэтому получается Q штрих очень удобно. Ну, пока это ввело нот, то есть, ну как бы заметим,
что этот потенциал мы ввели как бы внутри доказательства, и он в общем-то выполнил свою
функцию и исчезает. Поэтому, ну вот, то есть, просто мы показали, что простых сплайсов не более
Q штрих. Ура. Так, ну нам же, наверное, интересно, что такое, что же делается сложными сплайсами,
как они влияют на наш основной потенциал. Ну давайте так, итак, ну давайте значит еще
раз запишем. Значит, давайте попишем увеличений, ну для этого там анализ теперь проводим так,
увеличение, значит, пишем увеличение phi. Ну, во-первых, вне эксполза, что у нас будет вне эксполза?
Так, ну мы выяснили, что в кате плюс лог, ну вот, в реверте плюс лог может быть,
да, то есть, в реверте плюс лог, в кате плюс лог, в линке плюс один может быть, во всех остальных местах,
но вот, но правда, но правда, в остальных местах, к сожалению, мы этот иверт начинаем вызывать
несколько раз. В некоторых реализациях, помните, во всякие суммы и так далее, мы там называем,
мы там делаем иверт много-много раз, поэтому, да, поэтому, да, поэтому мы, ну вот, поэтому можно
сказать, ладно, но где-то, наверное, можно написать, что не превосходит что-то типа 3q log n, вот так,
вот именно q обратите внимание, да, вот, то есть, наверное, трешечку можно. Хорошо, ну теперь,
что происходит, что меняет потенциал внутри эксполса, чем приятен эксполс, эксполс приятен тем,
что он никак не меняет тяжелолегкость ревер, он меняет их только синий рыжий, вот, вот, но теперь
давайте смотреть, значит, как у нас потенциал. Ну, не совсем так, нет, это нам сейчас надо
аккуратно анализировать, смотрите, сплайл тоже, смотрите, дело в том, что, ну, так,
ну, в принципе, да, да ладно, что-то подозрительное. Нет, ну, да, нет, у меня просто было,
но по идее кажется, что, что в принципе уже победа на самом деле, потому что сложно, что
делает сложный сплайс, но, хотя, то есть, ну, правда, заметил тут, но, хотя нет, все-таки придется
расписывать, потому что это сложный сплайс, по идее, может потенциал не поменять от слова вообще,
так что-то надо внимательно, ну, давайте, ну, давайте, давайте не будем тогда забирать,
просто аккуратно распишем, значит, вне эксполза не более чем 3 коллоген, что у нас еще есть,
есть еще начало, там, начало эксполза, вот это вот, я вот это имею в виду,
вот, но это суммарно не более чем q, ладно, да, ну, вот, даже q-штрих.
Все, да, да, да, вы правы, вы правы, вы правы, вы правы, на этот раз да. Так, хорошо, начало
эксполз такое, так, что у нас еще, так, какие у нас еще, а вот простые сплайсы,
ну, давайте, смотрите, простые сплайсы, так, то есть каждый простой сплайс, по идее, может
увеличить и, ну, вот, он может увеличить потенциал и на 1 вполне себе, но их, но это у нас суммарно не
более чем q, мы только что доказали, спасибо, спасибо, спасибо, ну, да, ну, ладно, давайте так q-штрих,
которые хорошо не превосходит, ну, да, ну, хорошо, давайте 10 напишем, хотя 10 я отбалды написал,
наверное, если подумать, давайте, давайте так немножко повторим, это вот всегда пробежаться,
пробежаться никогда не помешает лишний раз, давайте подумаем, там сколько,
сколько раз мы можем вызвать эксползу в операциях, так, в линке мы вызываем, сколько эксползов,
один, ну, в кате мы вызываем тоже один, так, нет, в иверте само по себе один, вот, дальше,
но во всяких эдах мы начинаем делать просто несколько ивертов, получается,
да, три, да, то есть там три, в лцшке мы вызываем три, да, ну, да, даже вообще два, ну, да, слушайте,
откуда, ну, поздравляю, да, тройбан на месте, все нормально, все, да, о, наш тройбан, число фистеха,
нет, нет, смотри, когда мы делаем сумм, у нас один из вариантов, это значит сделать иверт,
то есть там, то есть надо так сделать иверт для того, чтобы там вершина устала корнем,
потом сделать эксполз от В, сделать на этом пути хорошо, а потом сделать иверт от того корня,
который был раньше, ну, да, но там, да, там во всех вариантов, по-моему, выплывала тройка,
ну, окей, вроде так, можем добиться, что тройбан, да, ну, чтобы вернуть сюда, да, совершенно верно,
так, ну, окей, это у нас все потенциально, это все увеличения потенциала, так, потенциала вне
сложных сплайсов, нет, нет, ну, учитывая стоимость логарифм не совсем, во-первых,
пока мы еще претендуем пока только налог квадрат, во-вторых, напоминаю, мы оцениваем количество
сложных сплайсов, да, пока проблема в том, что мы оцениваем количество сложных сплайсов,
а не время работы, да, подчеркиваю еще, да, это немного, ну, вот, то есть это может немножко
рвать шаблон, поэтому я это вот несколько раз подчеркиваю, да, что как бы метод потенциала
применим не только к времени работы, в принципе, да, но, взрослые, мы только что метод потенциала
сюда применили же и ничего не пострадали, вот, и так пришло время разобраться со сложными сплайсами,
так, но, на самом деле, смотрите, анализировать сложные сплайсы мы будем следующим образом,
значит, каждый сложный сплайс, он перекрашивает одно рыжее ребро в синее и одно синее ребро в
рыже, правда, вот, но тут возникает, но тут возникает действительно, но какие-то случаи
возникают, я нарисую вот такую табличку, смотрите, вот у меня есть, да, то есть там как бы, да, то есть
как бы четыре случая, что это за четыре случая, это четыре случая типа, какое, какое ребро тяжелые
легкими мы перекрасили-то спокойно сейчас все будет, да-да-да, какое тяжелое ребро мы перекрасили
здесь, т.к. тяжелое или легкое ребро мы перекрасили в рыжий цвет и тяжелое лег кровью,
прикрасили в синий цвет, тогда в принципе какие у нас случаи бывают, значит, бывают случаи когда
у нас тут ну 4 случая, да, значит там сразу пишем там тяжелое-тяжелое-тяжелое легкое, легкое- тяжелое и
фиолетовый фиолетовый фиолетовый легкая легкая так вот это да как говорится самая приятная
часть анализа случай когда мы перед когда у нас мы заменили когда мы там заменили тяжелое
решение на тяжелый решение вот такого вообще не бывает потому что из вершины двух тяжелых
детей не бывает вот убили вот вот убили как всегда как раму восьмого да вот так теперь смотрите а
теперь предположим что мы покрасили в рыжий цвет тяжелое тяжелое ребро да вот это отказал бы
хотя погодить вот нет вот этот случай на самом деле приятно анализировать зелененький
конечно потому что как меняется потенциал в этом случае тяжелый легкий да строго минус один
вот тот наоборот смотрите да смотрите тут плюс один тут 0 но смотрите какая штука ведь
заметим что я утверждаю что вот этих вот случаев всего суммарно не более чем лога
нет ну хорошо давайте так не более чем ку штрих лога но раз уж мы тут везде так
суммарно рисуем давайте тут ку штрих логан рисовать да и те так и те было также что на в одном на
одном экспозида мы перекрашиваем в рыжий цвет не более чем логарифом легких ребер
потому что как всегда у нас на одном пути не более чем логарифом легких ребер в принципе как
всегда то есть таким образом получается что значит тогда тогда получается что значит
сложных значит так кстати так на всякий случай так давайте вот вот так вот нет это
просто чтобы а то кажется что работа сложных сплайсов нас не более чем треку такого у нас
такого счастья у нас нету это неправда вот так вот значит смотрите ну да то есть вообще
выглядит как победа почему потому что ну дело вот что то есть у нас есть вот то есть у нас
сложных сплайсов бывает вот таких не более чем ку штрих логан и есть какие-то оставшиеся вот эти
тяжелые вот эти вот сплайсы которые уменьшают потенциал но мы ради этого и собственно и
расписывали что суммарно потенциал на самом деле увеличивается не более чем на получается
ну что-то типа 6 кулоген плюс еще треку видно да то есть отсюда следует что вот эта вот штука
не превосходит но то есть получается что значит вот эта штука будет происходить не более чем
получается что-то типа там может быть 7 кулоген раз ну или там 6 кулоген плюс
треку но понятный ку оценивается сверху как 6 там не хотя нет треку как кулоген наверно не оценится
нет ну 4 не нет ну 4 4 нет потому что у нас есть простые на треку у нас даже это ладно это
у нас есть тут треку треку логан и тут еще треку логан так что это вот 6 плюс еще треку самое тупое
кашлук штриху сказать что это не более чем треку логан поэтому 9 нет понятно что при хоть да да
понятно что нам нужно просто чтобы он был хотя бы 8 для того чтобы как бы тройка оценила сверху
логарифмом это да поэтому скорее всего так и будет но но в общем так но на самом деле эти
разборки принципиального значения не имеют потому что у нас как бы есть уже мистическая да по
хорошему как бы да в оригинале это бы называлось теорема 1 и теорема 2 но наши практически теорема
2 можно сказать сложных splice splice не но вот то есть сложных splice так чего значит сложных
splice не более чем о отку логан вот так вот там уже 7 8 9 бла бла бла
я тоже мы ровно эту теорему в общем-то и доказали вот так вот а вот мы нет мы анализии нет ну как
нет мы анализировали количество splice потому что но вот значит доказательства прозвучала так то
есть доказывалось так давайте подумаем то есть то есть мы доказали что у нас есть потенциал
который изначально был 0 и каждый но вот из сложных splice у нас всего значит что у нас делают
сложные splice сложные splice они у нас либо вот такого вида их отку логан в принципе либо у нас
вот конкретно вот этот splice который уменьшает потенциал а теперь рассмотрим насколько суммарно
увеличился потенциал мы проанализировали там по моему просто все нашу возможную реализацию и
убедились что там отку логан раз ну может по факту да ну вот эти ладно простые splice тоже есть поэтому
тут надо аккуратненько но тут везде надо аккуратненько потому что тут как бы вот везде
небезопасно то есть как всегда эти если и хочется продать что-то не лог квадрата лог мы должны
вернуть то есть тут нам нужно просто максимальная аккуратность то есть когда-то я был вообще
настолько испуганный что я тут на самом деле писал прям полную реализацию почти в чем начинаю
просто кстати вообще в этом смысле очень интересно даже написать там почитать авторов потому
что авторы на самом деле начали описание спа этой структуры данных не так вот в оригинальной
статье на читатес там начиналось все интересно то есть там говорилось так а давай вот то есть
там так предлагал а давайте предположим что у нас каждый момент времени все деревья бамбуки
да так они говорят да пишем но я не помню что они там предлагали помните кстати на тот момент
помните как-то еще не изобрели кстати поэтому приходилось страдать там с этим интересно какое
дерево они на сплит мёкш тогда подсовывали а ну какой-то ладно наверное у них было какой-то
умный дерево вот хотя хороший вопрос дикарта чая не изобрели и с плей не изобрели что там
могло быть то вообще сплит мёртшего в эля но они там может и придумали но я же говорю статья
сплея от нирже пришла через два года то есть там по-моему что-то типа вот там да я не помню
там кто-то я пошлёт сказал что там линкат это 84 а сплей 86 но я могу ошибаться может может 82
84 там или там что-то в этом роде вот но вот но не стоит то есть они там дощадочным с этого
потом вот будем это модифицировать да это так оригинально поэтому с этого исчезнение всегда
на самом деле как бы статьи тарьяна это обычно статьи которые в качестве литературы советовать
можно то есть там красиво все написано там минус только один по-английски но как бы
обычно для программистов это минусом быть не должно и так но что же у нас получилось но по
факту смотрите то есть мы интересно да мы тут теперь доказали мистические теоремы о том что
простых сплайсов там всего не более чем линия а сложных сплайсов у нас не более чем кулоген но
отсюда следует маленькая но вот но в принципе отсюда раз у нас но заметим что так как у нас
эксполса состоят только и фактически из простых сложных сплайсов и вот этого вот то в принципе мы
уже можем сделать вывод что если бы то подсунем любое там где любой дикартач любой овл который
умеет за логарифом делать сплит и мерч то тогда мы уже можем заключить что все операции делаются
за лог квадрат с рейтинг так сказать ну в среднем плане амортизации естественно то есть на этот
раз мы применяем даже самый тупой вот первый метод да то есть мы говорим что у нас там учетная
стоимость лог квадрат в том плане что заку операции вы как бы всех там кооперации вы выполните
видимо заку лог квадрат понятно да а он появляется из-за того что вы как одно смотрите ну потому
что в данном случае потому что дело в том что каждый сплайс вы делаете за логарифом потому что
каждый сплайс это сплит там то есть это сплит и мержи каких-то деревьев более того вы еще
делаете кучу этих лишних логарифов еще когда-то но их уже их правда немного потому что
сплитов и мержей вне экспоза вы делаете там ну там не более чем вот единицы на запрос вот
поэтому они дают логарифм но суммарно у нас пока лог квадрат но тем не менее ресурс для оптимизации
откровенно есть потому что в том плане что как бы утверждение такое что то есть я утверждаю
что можно сказать что мы на каждый запрос тратим время от логарифма плюс экспоз потому что вне
экспоза мы работаем мы делаем какие-то операции которые работают за логарифом правда или нет
нету правда давайте давайте еще раз переберем да что делает линк линк вне экспоза это просто
мерч на урте ревер кат вне экспоза это вообще ничего не это не сплит обратить внимание мы
праве давайте еще раз помним до правильным ка то есть правильным экспозом мы добились того
что удаляемое ребро стало сидим поэтому даже сплита нету ну то есть он то есть мы его запихнули
экспоз очень просто но мы как бы шутка где находится синее ребро оно находится в каком-то
рыжем дереве в каком-то рыжем дереве где-то в корне этого дерева хранится информация что на
самом деле оно соединено синим ребром с чем-то вышим и все мы просто идем в это рыжее дерево
которое получилось и просто пишем шо а теперь где-то родителя вот да вот такой вот неожиданный
местицизм да но кстати обратите внимание это тоже требует логарифа потому что вам придется это
то есть по вершине найти в какой найти корень дерева в котором она лежит это важно но как бы
обычно в любом адекватном дереве делается за логариф другой вопрос насколько адекватным
способом скажем сплэй дереве как бы то есть сплэй дереве у нас нет операции вершина в скажи
кто у тебя корень есть операция вершина в а пойди-ка стань корнем вот в какой-то в эльке там все
адекватно часто пойди по родителям возрадуйся или там если вы там захотите сюда писать красно-черное
дерево не знаю зачем вам это понадобится конечно но вот но мало ли то то же самое то есть там но
там фиксирую бина фиксируем логарифом хорошо так но вот но теперь вот мистико то есть как видим
что на самом деле от самого дерева ничего не зависит если мы с деревом все адекватные операции
делаем за логарифом в толиемном смысле то мы получаем лог квадрат ноленка если там придется
это найти так хорошо линк как а реверс ну реверс сам по себе это вообще за вот единицы делается да
да внезапно да потому что это отложенные операции которые там проталкиваются и на симпатику не влияют
что там еще есть но все остальное понятно все остальное это комбинация линков катов там и вертов
и там каких-то простых операций так что не уже ничего интересного не вот но сами но вот но вот
это в ней то есть в ней эксползов то есть как видим мы там тратим не более чем там одно действие
там один какой-то сплетмерш что-нибудь вот но тем не менее теперь есть а теперь мистика почему-то
оказывается что если вы сунете сюда дикарть очку или овл то будет лог квадрат а если сунете сплей
то почему-то будет логариф остался только выяснить почему но это видимо нам придется
и так внимание вопроса стал столько посмотреть на это все и понять откуда но скажу спрашивается
откуда же сплей деревья вместо лог квадрата берется логариф но на самом деле просто из
предыдущих из лекции по сплею из предыдущего занятия плавно на самом деле вытекает откуда
потому что мы с вами специально заморочились и доказали про сплей дерева какой-то мести там
какой-то мистический факт на тему того за сколько там все операции работают точнее за сколько
работает у него сплей ну-ка давайте напомните ко мне за сколько работает сплей у сплей дерева
но от логарифмов чего
но вот да но на самом деле так давайте вспомним что сплей деревья у нас но вот да то есть у нас
тут в качестве рыжие лошадки действительно давайте скажем что есть у нас то есть действительно
сплей от вершины в у нас работал за асимптотику не более чем значит там что-то типа единица плюс
три логарифма двоичных чего но не совсем цз ну можно сказать так можно сказать и так но мы
доказали более серьезный факт мы сказали следующее мы сказали что у каждой вершины есть какой-то
вес желательно не меньше единицы дай да вот так что то есть поэтому поэтому давайте напишем так
логарифм можно в скобочках написать так логарифм сз взвешенный от в после минус логарифм двоичный
сзв от в до пассуя но вот то есть по сути обнаружилось так что то есть мы говорили так что есть такая вещь
что такое сзв это сумма весов всех вершин в поддереве но мы помним что изначально у вершины
в было какое-то поддерево а потом в конце вершины в стало корнем это дерево поэтому
сзв после по сути сумма весов просто всего дерева вот да мы с вами доказали что сплей работает
вот за столько из этого сделали вывод что там все операции работают как-то адекватно вот правда
у нас конечно была маленькая поднот правда она сейчас будет такая маленькая может быть это
психолог больше психологическая правда подляночка дело в том что сейчас у нас веса будут изменяться
вот но так как они будут изменяться поэтому придется более точные какой-то анализ делать
мы так вот это это у нас операция учетная но давайте вспомним а за счет какого потенциала
какой у нас сплей потенциал да то есть действительно помните что у нас потенциал
сплея вот давайте фиг сплей это сумма просто по всем в просто в структуре данных значит пишем
логарифом двоичный сзв да у нас был вот такой потенциал вот ну вот то есть вот такой ну теперь
пришло время узнать но теперь вот остается только вопрос какие то теперь нам просто все что
это правильно повесить веса на вершину как же мы это сделаем но а вот этот вопрос мы уже ответили
неделю назад сзв от в будет равно 1 плюс да я не спрашиваю вас что я напишу дальше я спрошу
какой маркер я дальше возьму нет кайф синий конечно я возьму синий маркер а синий маркер
я возьму потому что я переберу до всех моих синих детей и для каждого синего ребенка
я добавлю к ответу сзв помните у нас уже был такой потенциал хэйвилайти даже не потенциал а вес
правда мы там не было потенциалов потому что да как бы хэйвилайта как бы хэйвилайта отличается
от линката тем же чем дерево отрезков отличается от сплея да чем оно отличается тем что там все
честные их но но при этом хэйвилайты дерево отрезков это фиксированная железобетонная структура данных
то есть как бы сплей он как бы такой хитрый вот такой вот он как бы подстраивается аккуратно то
есть как бы он он может так изменять структуру да то есть изменять то есть подстраивать себя
под обстоятельствами получается в итоге хорошо то есть как бы дерево отрезков в этом смысле берет
железобетонную структуру оно как бы не гибкое то есть как только вы там скажете что ой а вставь
пожалуйста середину элемент тут его полномочия все вот а но вот но вот а здесь зато нет но это
вот за счет вот этого вот так что вот такой сзв я утверждаю что относительно этого потенциала
у нас все должно быть хорошо сзв здесь да сзв да это именно честные это честное размер под
дерево да то считая и себя и синие детей рыжих детей все считать то есть ну как всегда то есть
то есть как бы когда мы рассматриваем рыжий путь мы как бы вывешиваем в гирлянду и на каждой
вершине смотрим что у нас тут еще висит ну как всегда себя любимую считаем вот так что вот такой
вот сзв и теперь давайте ну вот то есть вот так вот работает у нас действительно условный
сплей сейчас еще раз не понял вот мы его но вот мы ее определили нет это не сумма
весов по дире да в нашем пределе предыдущем это сумма весов сумма да вот по всем в потомках
правильно пока я где подвох у нас какая-то сумма теперь она вот чему-то ну рада ну заметим
что мы как бы вес каждой вершины в каждый момент времени можем определять вот таким образом
через нет я нет нет подожди я тут перебираю не потомков я перебираю ребенков все
хорошо ну у нас с левой написано сумма весов по потомкам а справа какое-то число
а вот и ладно хорошо хорошо давай уберем две буквы да все да да все да понял о чем я
читаю хорошо хорошо да спасибо на самом деле дать степень глюк на лицо хорошо давай даблы да
все это был вес вот хорошо ввели вес и теперь у нас все но и теперь давайте думать как мы
действительно влияем на потенциал ну для этого нам нужно сделать вот что то что мы хотим мы по
сути как всегда но раз уж мы начали в такой парадигме мы наверное хотим этим и закончить
мы хотим доказать что все эксползы но акцент но на самом деле мы хотим что все операции суммарно
работают за откулогом правда понимаете да вот но для этого водится у нас вот такой потенциал там
но вот то есть водят то есть там соответственно водится какой-то потенциал но вот ну так что
давайте рассмотрим за сколько же у нас относительно этого потенциала работает эксполз
подпрашивается дадут но за сколько он работает относительно этого потенциала
нет это нелегкие это синие да напоминаю ребра у нас будет рыжими и синими а бывают
тяжелыми легкими и это не всегда коррелирует вот так же именно синие да как бы отличайте
синие ребра от легких ребер да ну да жалко немножко получилось что мы неделю назад
конечно легкие ребра обозначали синими но что делать вот сегодня у нас легкие
ребра фиолетовая да вот ну можно и так сказать да так вот хорошо и так но давайте смотреть
значит смотрите относительно этого начать теперь давайте рассмотрим тот же самый эксполз вот
просто тут же самую схему так ну и давайте думать как у нас вообще меняется потенциал при
последовая при эксползе но заметим что вот этот вот конкретный сплит он в общем-то потенциал
даже уменьшает правда вообще кстати давай вот но вот а вот все а вот тут уже поинтереснее
конечно тут потенциал может увеличиваться впрочем давайте посмотрим но хотя тут самое страшное
что тут даже но вот что тут иногда что хотя но хотя самое страшное что здесь действительно вот
в этой операции давайте посмотрим что заметим что тут веса могли увеличиться да заметим маленькую
смотрите заметим маленькую приятную вещь когда вы сделали здесь плит у этой вершины увеличился вес
но при этом маленькая приятная вещь я утверждаю что если мы рассмотрим корень вот этого оставшегося
дерева я утверждаю что сзв у него не поменялось вот давайте поймем эту важную идею что такое
сзв это мы говорим так то есть практически каждый то есть каждое дерево олицетворяет вот такую вот
цепочку правда то есть как бы как бы как рыжий путь вот это вот такая цепочка на каждый из на
каждой вершине которого висит какое-то дерево да где-то больше где-то меньше да вот но хранимое
это не так мы его храним в виде какого-то двоичного дерева польско вот давайте вот так
нарисую, чтобы не было идеального дерева. Но как бы суть та же, допустим, если я назову
эти деревья там Альфа3, там Альфа4, Альфа5, A6, Альфа7, то тут у нас тоже получится,
получается Альфа1, тут получится Альфа,2, здесь получится Альфа3 и обратите внимание,
просто плохо нарисовал. Тут получается Альфа4, Альфа5, тут получается Альфа6,
то получается альфа-7 да понятно вот то есть в реальной то есть сплей дерева устроена как-то так
но на каждой вершине висит какие-то гирки и что такое сзв и сзв это получается что такое
гирка висящая на под дереве на сплей под дереве то есть в переводе говоря то есть на этой вершине
по сути вот сумма всех этих гирек но если я возьму корень этого сплей дерева то на нем
бесит получается все то есть сзв от корня сплей дерева совпадает с чем
да хочется сказать что сзв от этой вершины но это неправда да будет парадоксально но сзв от
этой вершины да это покажется не тривиально пока вы не вспомните что как бы когда вы рассматриваете
путь что вы понимаете что как бы путь то висит на начальной вершине то есть вот на этой первой то
есть в реальном этом вагне видите как все устроено то есть как бы вот у вас есть
вот этот вот ну допустим вот этот вот путь и вот на этой вершине он как бы целиком висит
вот не самая тривиальная идея но как бы если въехать то в принципе все нормально вот
ну вот ну в смысле нет в смысле в реальности cz одно а czv другое ну просто да просто cz что
cz здесь что czv тут идентичен ну вот это вот да ну дети у них синие
правда заметим что это я так нарисовал в принципе у него вполне там левый ребенок с плейдерами у
него вполне мог бы и быть и czv не обязана быть только чисто этой идеей вот почему бы нет вот
но фишечка тут заключается в другом то есть на самом деле то есть да то есть но вот
то есть в принципе да тут она тут на самом деле конечно да может появиться действительно
подлянночка даkr ну вот подлянночка будет заключаться в том что конечно там действительно
но вот конкретный вес но то есть оказывается что действительно то есть конкретный вес то есть
конкретный вес как этой вершины получается поменялся вот у вершины у вот когда вот
тут от плите для конкретный вес поменялся а именно даже увеличился понимаете да но как это
повлияло на созыжки оказалось бы созыва тоже поменялась как у вершины у так и у всех остальных
вершин правда то есть тогда не у всех остальных а у всех получается получается там предков
сплейдере но правда весь кайта просто сколько может быть предков у вершин там то есть в
результате этого сплета сколько может быть предков у вершины у
нет подали по предков сплейдере нет заметим что да потому что заметим следующее что вот с
точки зрения вот этого рыжего пути ничего не поменялось то есть заметим да что от того
что мы тут как-то поменяли вот это я вот вот скажем у этого дерева ничего не поменялось
потому что нем гифки как висели так и висят да да да вот это подлянка да что это в нормальном
да да а сзв это всплэйдере да да осторожно да сзв всплэйдере сзв в линка в нормальном
дереве вот но теперь давайте вот поймем еще раз да но заметим что как я уже сказал если мы
перекрасили какое-то ребро то я то есть как бы на ну на дабл ее оно влияет только у самой
вершины очевидно да а уса а сзв она влияет может повлиять только на веса вот этих вот да ну типа
предков сплэйдере очевидно да но это да правда для этого желательно еще и добиться чтобы вот
эта вершина была как бы ребенком в этом плане в каком-то смысле да или чем-то еще вот но самое
важное что ладно в любом случае как бы тут это не было переустроено заметим что вот скажем на
вот этот путь или вот этот путь то есть у этих вершин веса не поменяются от слова никак и сзв
не поменяются от слова никак потому что как бы как бы то что внутри гирек мы там как-то там
кого-то стали считать синим и рыжим как бы нас не волнует потому что как бы нас в данном случае
на гирку влияет только то что как бы главное шоу вы меня на синим ребре висите а кто вы там у
себя внутри это ваше дело но правда теперь заметим теперь возникает вопрос сколько убивает предков
сплэйдере так вот мистический ответ не сколько да смотрите давайте вспомним а как делается сплит
сплэйдере да вот конкретно здесь напрашивается классическая штука мы вызываем сплэйд у то есть
у объявляется корнем вот этого дерева и после этого сплит будет заключаться в том что мы просто
отпиливаем правое поддельно неплохо тогда то есть там жила было дерево потом мы объявили что у
нас тут у корень и значит мы просто отпилили правое поддельно то есть заметим что это привело
нас к тому что на самом деле у вершины у изменился в от нее и создает вы от нее а не ассоции этого
не изменился от слова никак равда кстати у всех вот этих решений не поменялся никак а потому
что как мы уже сколи у корня сплэйдер его сзв это как бы сумма всех вершин просто которые на
этом пути вообще висят нет нет сзв а туни вот тот и фишка сзв а ту не поменялась а конкретно
от этой операции ну понятно что от самого сплея конечно нет а само сплей естественно все
сзшка поменялись это да но правда мы знаем что они там поменялись как-то адекватно то есть они
то есть там но то есть они поменяют они поменялись так что учетная стоимость оказалась вот такая да вот
то есть я не понял от они вот поменять ну нет ну потому что нет фишков но вот но от самого
себе отрезания отражаешь и потенциал не поменялся от слова никак просто и фито ты прикол это магическая
идея но да вес вершины поменялся вот от самого себе отпиливание вес поменялся а сзв а сзв вес
никак не поменялся ну сзв это говорит так берем вершину в берем что на ней висит под дереве да
под дереве сплея и в этом под дереве сплея мы берем все веса вершин вот которые там немцы
и суммируем эти веса вот то есть такая вот идея ну да с одной стороны два но за другой
стороны давайте подумаем чему равен сейчас сзв от у да то есть это сумма всех гирек синих которые
висят на всех рыжих вершинок да понятно да когда мы объявили вот это ребро неожиданно синим ладно это
это ладно не надо так рисовать конечно да ладно когда мы тут что-то отпилили то есть по сути это
означает что мы вот эту вот часть пути да то есть это как будто желоба вот это вот вершина допустим
и мы неожиданно вот это ребро объявили синим но тогда получается что то есть мы как бы удалили
это под дерево но добавили одну вот эту гирку а на этой гирке как раз висят просто абсолютно те же
вершины со своими под деревьями то есть вот абсолютно те же вершины вот это вот то есть вот
это вот суммарный размер ну типа того ну нет ну как перекинули скажем так да вес немножко
перераспределился кто-то и приколся создание czw не поменялась никак
да вот от самого этого пиливания вот пытаемся додогащего создавать у от этого самого по себе
этого отпиливания не поменялось никак потому что что-то пошла раньше мы как бы для создавая
туп суммировали все вот эти вот вершинки до сумми рвли сумму гирек от них да теперь мы суммируем
вот эту гирку то есть вот сумму вот этих гирек и собственно гирку от самой вершины у но что
такое гирь как У теперь? Это ну те под деревья, которые были раньше, плюс вот это дерево. А что
такое ССЗ от этого дерева? Прям буквально в точность. То есть такая вот, да, да, тут вот
действительно магия, да, вот действительно тут конечно вот магия, да, но очень красивая магия.
Чем она нас это приводит? А приводит нас, ну вот, то есть это вообще, то есть на самом
деле для нас это конечно очень приятно, что сам по себе, то есть и так сам по себе этот отпил он
выполнил за единицу реального времени и не поменял потенциал. Приятно, да? Теперь и более того,
он ушечку сделал корнем, что приятно, да? Давайте скажем, что это У не просто У, а У0. Ну и как вы
уже дорадуетесь? Давайте, значит, ребра, по которым я буду делать сплайс, это у меня будет В1 У1,
тут будет У2 В2, тут будет там У3 В3, ну короче и так далее. Ну будет у меня там допустим К
ребр. Так ладно, на всякий случай, вот это вот все можно уже стирать? А то да, то есть нет,
может это было приятное свойство, что когда мы работаем с экспозом, у меня тут прям вот четко
дописано его определение. Вот, я думаю уже, да, то есть думаю, как бы уже, как бы шел третий час
работы с ним, так что, наверное, уже интуитивно поняли, что это такое вообще. Так, да, как всегда.
Ну потенциал, ну вообще, ну как бы тут имеется в виду, что мы суммируем по всем вершинам, то есть
вершины, они как бы не в одном сплэй дереве находятся, а в нескольких. И конечно же, да, ну как и ранее,
на самом деле, потому что когда мы исследовали само сплэй дерево, мы подсумевали, что у нас на
самом деле есть N вершин, которые распределены по нескольким деревьям, которые мы иногда сплитим
и мерчим. И вот, и потенциал был общим, то есть была вот общая сумма. Ну вот, ну давайте так,
смотрите. Нет, ну вот, ну просто смотрите, значит, еще раз, давайте тогда тут побольше картинку
нарисуем. Жил-был путь. Рассмотрим вот один конкретный путь, в котором была какая-то вершина
у. Мы решили вот это ребро объявить синим. Давайте еще допилим. Теперь давайте посмотрим. А теперь
давайте думать, чему равен, значит, смотрите, вот давайте вот эти вершины, допустим, мы назовем,
что эти вершины равны, там я не знаю, чему они там равны, ну давайте чем-нибудь технически,
давай какой-нибудь, возьмем радикальный черный цвет, v1, v2, v3, и так далее, v, там какой-нибудь l,
уж не знаю. Да, то есть и так, значит, в реальности, в реальном дереве путь у нас, то есть реальное
дерево устроено так, то есть сейчас есть этот путь, который, возможно, на чем-то даже висит, да? А еще
тут на нем висят какие-то деревья, там альфа-1, альфа-2, альфа-3, ну там и так далее, и так далее,
в конце там альфа-l. И на, кстати, тоже что-то вполне себе висело. И так, смотрите, и так,
значит, было у нас какой-то, но этому пути соответствовало какое-то, то есть это вот как бы,
так сказать, реальное дерево. Какое-то вот реальное дерево, да, то есть вот, ну как всегда,
вот. Хотя, да, что тут реальная, конечно, вопрос. То есть реально это типа интерфейс мы предлагаем,
да? Вот, а тут, ну вот, ну и было тут дерево, которое, но этот путь мы как бы храним в виде
какого-то вот там сплея, да? То есть там вершина, сколько у нас тут, да, тоже там,
девять вершин, там какая-нибудь вершина У была где-нибудь там, ну где-нибудь была, не важно. Мы
сделали сплей от У. И в сплея от У у нас обнаружил, что у нас теперь есть вершина У, и у нее вот эти
вот там, тут, допустим, вот эти три вершинки, а тут, допустим, вот эти вот пять вершинок, как-нибудь.
ну вот так не важно теперь вершина у находится вот здесь вот красота красота вот и теперь но
теперь рассмотрим потенциал в этот момент времени да ну потенциал у нас напоминаю равен сумма
лок СЗВшек по всем вершинам в том числе от этих но заметим что перестраение вот в
этом дереве нас изeday других деревьев не влияет очевидно потому что для всех остальных деревьев
это как бы ли там либо его это не касается либо это там перестраение деревьев какой то
синей гирки да. Но перестраение синей гирки у нас естественно там на вес никак не влияет
потому что оттого что вы там перестраивайте вершины количество вершин меняется это ponятно
теперь давайте второе но вот а вот теперь то есть конкретно то есть поэтому рассматриваем как
меняется как меняются веса как как меняется веса и сзв шки у этой штуки что такое сзв шка
сзв шка это то есть данном случае это то есть сзв но то есть сзв шка это как бы сумма гирек
у этой вершины сзв совпадает с ее гиркой у этой вершины сзв шка это сумма вот этих трех гирек
правда а у этой ушки это что такое это сумма сзв шок просто всех девяти гирек понимаете да
вот
но то сумма соответственно сзв шка но что такое сумма сзв шка это по сути так как в каждой
синей гирке сумма вес синей гирки это сколько вершин в ней находится да то есть получается
сейчас сзв от у это ровно количество вершин которые в принципе находятся на этом пути или
висят на нем в гирках понятно да то есть поэтому я и говорю что в этом в этот момент времени там
сзв от у равно просто сз от получается v1 потому что обратите внимание в реальном
дереве как бы все это это просто под дерево вершины v1 правда а теперь давайте подумаем
что поменяется от того что я тут неожиданно решу отсплитить вот это дерево то есть в
результате вот этой операции то есть объявили вот это ребро синим то есть я по сути объявлю
следующее что этого ребра больше нет а вот это вот все на самом деле просто висит то есть это
тоже такой висит то есть такой еще одна гихка можно сказать ну точнее вот гиха то есть просто
мы в гирку вершины у довесили вот это вот все но тогда что путь но да но пилили ты ну да когда
мы вот здесь синие ребро сделали да но теперь смотрите а что поменялось собственно вершина у
осталось корнем своего дерева да то есть путь и путь и как и нот то есть поменялось то что
конкретно вес вершины у увеличился на увеличился на размер вот сумму вот этих трех гирек ровно
правда вот но я отражаю что сзв не изменился потому что сзв да суммируется уже не 9 гирек а только
так и получается суммируется только вот эти 6 гирек но плюс еще вот эти вот то есть да то есть
ну да то есть добавилась но вот но так но суть осталась той же то есть суть осталась тоже то мы
как бы сзв это как бы то есть это по прежнему путь
отуба от 1 до у на этот раз он чуть поменьше стал но очевидно что тогда раз у корень своего пути то
получается сзв а То это по прежнему 6 git в legislature опять то есть ничего не поменялось то есть
то есть как бы получается веса немножко перераспределились, но СЗВ не поменялись,
то есть получается и потенциал не поменялся, то есть вот немножко магии, то есть оказывается можно
поменять. Вот так вроде разобрались.
Нет, мы удаляли именно то ребро, которое вело от У вниз, потому что оно поменяет,
что это не просто сплит, мы начали эксполс, мы начали эксполс и сказали, что я хочу,
чтобы у меня ниже У ничего не было. Чтобы это выполнить, я вызвал сплей от В, сплей от У,
я могу всегда вызвать сплей от У, а потом после этого я просто объявил, что правого под дерево
у него сплея нет. То есть для этого я объявил, что это типа новое сплей дерева, у него есть синий,
в корне хранится синий ребро, которое там висит на том же У, то есть как бы смотрите,
то есть это как бы идеально нужно смотреть. То есть это все какое-то вот рыжее дерево,
у которого значит есть там синие ссылка в У. То есть в общем-то само это дерево тоже является
каким-то сплей дерева, у которого синие ссылка ведет туда же, куда-то вот из В1 вот это синие
Вот такая вот красота. Идем дальше. Что у нас теперь происходит? А теперь давайте посмотрим,
что у нас происходит теперь. Когда мы делаем вот эти вот сложные сплайсы.
Заметим маленькие приятные факты. На самом деле сложный сплайс от простого тут принципиально
отличаться ничем не будет. Потому что как мы с вами только что выяснили, заниматься они будут
одним и тем же. То есть как будет устроен сложный сплайс? Мы вызовем сплей от У1 в своем дереве,
потом отпилем вот это дерево, припилем вот это. Но заметим маленькую приятную вещь. Как мы уже
поняли, после того как вы вызвали сплей от У1, именно сплей, сам по себе припил-отпил, но потенциал
не влияет от слова никак. Логично, да? Мы это только что выяснили. А если мы делаем простой сплайс,
ну тоже никаких проблем, просто мы лишних отпилов не делаем, правда? То есть как бы естественно
мы, чтобы как бы подмёрзнуть, мы естественно сплей от У2 обязательно вызовем. Понимаете, да?
Чего? Да, но это сплей. Я имею ввиду, что я пока
доказываю только одно, что вне сплеев потенциал не меняется. То есть сам по себе потенциал
меняется только внутри вот этих сплеев. Мы вызываем сплей от этой вершины, вот внутри них
потенциал естественно меняется. Да, и он тоже меняется. Но вне сплеев вот сами по себе вот эти
операции, вот сами по себе припил-отпили, потенциал не меняют. Это всё, что я хочу сказать.
Просто вы имеете ввиду общий потенциал, да? Ну естественно. Ну а какой ещё? Ну как это да, вот этот
потенциал на самом деле от самого по себе факта от пила-припила не меняется. Он меняется от факта
сплея. То есть ещё раз, как устроен expose? Мы делаем сплей от У, отпиливаем от него правое поддерево.
Ну отпиливаем вот в этом смысле. То есть сплей поменял потенциал, отпил – нет. Теперь мы делаем
сложный сплей. То есть делаем сплей от У1, потенциал поменялся. Мы отпилили правое поддерево от У1,
потенциал не поменялся. Мы припилили другое правое поддерево, потенциал не поменялся.
То есть потенциал, ну вот. Ну вот. Потом у2, потом для у2 где-то то же самое, то же самое. Вот. Да. То
есть да. Или что то же самое, что я хотел сказать только одно. Учётная стоимость сплайса без учёта
сплея единица. То есть для чего я это делаю? Потому что я не знаю, я не знаю, как меняется потенциал
сплея. Ну сейчас не знаю. Я знаю, что относительно этого потенциала, я знаю, что учётная стоимость
вот каждого сплея, она вот такая. Что это, что такое учётная стоимость? Помните, это что такое?
Это не важно. То есть учётная стоимость это реальная стоимость плюс потенциал после минус
потенциал до, правда? Но для того, что если я хочу теперь посчитать учётную стоимость экспоза
относительно этого потенциала, то я должен тогда, получается, разбить её на составляющую,
каждый считать именно учётную стоимость. Сплей я знаю только учётную стоимость, значит я должен
посчитать учётную стоимость самих вот этих отпилов-припилов, правда? Так, ну это вот понятно,
вот основа амортизационного анализа, основа логики. Вот, нет, они не влияют на что, то есть да,
нет, они не влияют на то, что они не влияют на потенциал, а сами по себе отпилы-припилы,
реальное время работы их от единицы даже, понимаете, да? Но тогда из этого, да, у каждого
конкретного, каждый конкретный сплайс делается за единицу, за единицу без учёта сплея. Но,
погодите, тут надо очень аккуратно, тут надо не запутаться, потому что мы же кулоген доказали,
вы же там не доказывали, что относительно какого-то потенциала там учётное количество сплайсов лог,
да, и ну его можно ввести, да, мы доказали, что их вообще не больше, чем кулог, да, в принципе,
из этого можно сделать вывод, ну да, да, да, хорошо, давайте, да, скажем так, ну давайте так,
нет, ну тут тут будет просто не совсем так, там будет одна подлость, поэтому тут аккуратненько,
хотя нет, в уме на самом деле, да, это мой нот, то есть в уме, конечно, да, можно себе это держать,
что, ну нет, просто учётные стоимости надо везде, потому что раз у нас есть потенциал,
надо всегда проследить, что он не меняется просто так, ну вот, хотя давайте вот на всякий случай
надо ещё прикинуть, хорошо, раз уж мы, ну в некотором смысле, да, хотя-то, хотя давайте ещё,
кстати, о припилах и отпилах давайте ещё подумаем, а как влияют на этот потенциал линки, так,
линки, каты и другие операции, ладно, слава богу, эверт, кстати, что приятно, на этот потенциал
влияет только посредством эксполза, потому что сам по себе реверс, заметьте, сам по себе реверс
пути на весах вершин не отражается от слова никак, вот, ну вот, а теперь давайте вот с линком
катом проблемы, потому что линк на этот раз, хотя с другой стороны, вот, посмотрите, тут ещё
одна неожиданная вещь, почему линк делается именно конкатинацией, обратите, вот, неожиданный был
вопрос, потому что я утверждаю, что линк на потенциал, ну линк на самом деле на потенциал влияет каким
образом, он, ну, рыжая ребро, конечно, да, но вес, ну, как всегда, как делается слияние двух деревьев,
как всегда, мы у левого дерева находим правую, самую правую вершину, вызываем из неё сплей,
объявляю корнем, и потом после этого подвешиваем, да, то есть получается, мы делаем опять сплей,
но это делается там за логарифом учётного времени получается, и после этого привешиваем вершину,
тем самым увеличивая, значит, СЗ только у корня, ну и соответственно, а потенциал увеличивая не
более, чем на логарифом этого СЗ, то есть получается, да, но вот тут как бы вот аккуратно, да, ну, то есть
вот получается, да, то есть относительно этого потенциала, да, то есть получается, что, да, то есть
относительно такого потенциала мы сработали за expose плюс логариф, cut, ну, то же самое,
только ещё лучше, потому что этот потенциал, cut, уменьшает всё-таки, потому что когда мы
что-то, когда мы там отпилили синюю, там, отпилили синюю вершину одного бедняги, ну, вот, то как бы
просто у него вес уменьшился, значит, как бы вес уменьшился, потенциал увеличился, вот, так,
но это относительно этого потенциала, но тут вот опасно, видите, всё-таки мы начинаем действительно
мыслить терминов, то учётная стоимость относительно сплейного потенциала, вот, ну, давайте, ну, это
значит, ну, давайте, да, то все остальные вершины, всё остальное у нас не поменялось, потому что мы
помним, и верт у нас ничего не поменял, то есть там, потому что, вот там, потому что помимо expose,
там есть только reverse, а reverse вообще делает из единицы и не меняет, не трогает потенциал никак,
вот, остаётся только теперь финалочка, то есть давайте посмотрим, значит, собственно, собственно,
сам по себе expose, как же работает, я утверждаю, что учётное время expose относительно этого
потенциала равно чему? Внимание, то есть, итак, вот, то есть время учётное относительно вот этого expose,
относительно вот этого потенциала phi-splay, так сказать, этого сплейного потенциала, да,
но не превосходит чего? Значит, предельно честно пишу, обратите внимание, вот, значит, один,
значит, ну, во-первых, делаем сплей от, значит, сначала мы делаем сплей от удоль, да, значит,
это один плюс получается три логарифма двоичных, так сказать, вот тут сейчас неожиданно будет,
на самом деле, cz от v1, вот, минус три логарифма двоичных, ну, чего тут, так сказать, cz синего,
то есть, на самом деле, вот так скажем, v от u0 можно дано, ну да, v от u0, по сути, ну, когда мы делали
сплей, у него был какой-то вот синий вес, вот этот, но не синий вес, а просто вот вес, да, тут, в принципе,
я вообще могу, то есть, видимо, совсем уже для красоты можно, на самом деле, тут этот вес аккуратненько
и в синий перевести, хотя, да, вот у тебя есть прилагательное синий, какое член предложения, синий, ну, вот, ну,
почем не ваш, а, ну, нет, именно, вот именно, нет, cz от v1, то есть, все вот это под дерево, да, то есть, как бы, когда u0 станет
корнем, на нем будет висеть ровно вот это все под дерево, вот, так, смотрите, значит, дальше что мы делаем? Дальше мы делаем,
собственно, вот этот отпил, этот отпил, учетная стоимость этого отпила относительно нашего потенциала, это 1, как мы выяснили, да?
Потому что я оценил cz, потому что я это czv от u0 оценил сверху, оценил снизу, как v от u0, да, хотя, в принципе, хотя, да,
наверное, правильнее было бы тут можно и cz написать, ну, скажи так, сейчас на это забирай вперед, ничего не повлияет, но, как бы, можно и так, ну, просто тут czv до, ну, можно сказать,
ладно, до не важно, понятно, что, как было изначально, тут, так вот, это у нас, это, что это такое? Это вот, это вот от сплитили, вот, так вот, теперь дальше,
мы переходим к splice на v1, u1, за сколько работает этот, что это такое? Значит, теперь, когда мы работаем от v1, значит, мы делаем splay от u1, да? Да, давайте, я вот тут тоже напишу, что вот это вот, это splay от u0,
теперь у нас прозикается splay от u1, ну, как его оценить? Его можно оценить как 1 плюс 3 на логарифм двоичный, на этот раз cz от v2, там, пишем черненьким, cz от v2, минус, конечно же, 3 логарифма двоичных,
да, то есть, опять же, тут, тут пишем czv от u1, вот, нет, не то же самое, я вот так сказал, скажем так, это не то же самое, что вот это, но я сказал, вот это включает вот это в себя,
да, мы же можем там писать, если что-то не поедет в 1, просто поедет в 1, да?
там, splay от u1, то есть, это от сплителя, а вот эта вот единичка, это splice, понятно, да?
Вот, теперь, что мы делаем? Идем сюда, делаем вот этот splice, ну, то же самое, то есть, пишем-то, то есть, он может быть простым, может быть сложным,
ну, я тут даже, ну, вот, давайте уж, ладно, пишем-то, пишем, то есть, тут уже получится cz от v3, да, то есть, пока я предельно все честно пишу, я, собственно, тут ничего не делаю особо,
вот, три логарифа двоичной, тут получается czv, czv от u2 и плюс один, опять, плюс bam-bam-bam, ну, bam-bam-bam, короче, да, то есть, и так делаю по всем splice'ам,
ну, да, ну, вот, вот, так вот, допустим, по, ну, вот, то есть, по этой логике, допустим, мы делали, сделали k splice'ов, то есть, k splice'ов, и тогда у нас, по этой логике, оказывается, что root пусть у нас будет равно vk плюс первое, да?
Вот, ну, теперь получается, значит, заметен, теперь следующее, давайте я теперь вот это сотру, потому что это нам, в общем-то, больше уже, да, этому вот реальнее, значит, это я убираю, вот так вот, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем, убираем
Вот, ну, теперь смотрим, значит, это все меньше либо равно чего, значит, теперь заметим следующее, то есть, я замечаю, что логарифм двоичный СЗ от каждого выитого, он не превосходит, даже не логарифм двоичный, я даже короче запишу,
ключевое в другое, СЗ от выитого, оно на самом деле не превосходит, а если быть точнее, даже строго меньше, чем нас, ну вот, да, по большому счету, чем, да, я даже вот так напишу, меньше В от, значит, У и плюс первого,
ну просто потому, что это составляющая его часть, даже В, ну, естественно, то есть, давайте, чтобы, ну, я тут пропишу, что это не превосходит СЗ В от У и плюс один, очевидно, что до, что после, да, но тогда из этого следует, что у нас такое, ну вот, что у нас имеет место, называется, такой красивый шлеп-шлеп,
вот так, то есть, сейчас, ну вот, сейчас, нет, погодите, сейчас, сейчас, погодите, от У и плюс первого или, а, нет, неправильно, вот так, вот так, и тогда, смотрите, то есть, в принципе, тогда эта штука дает нам очень красивый шлеп-шлеп,
то есть, такой, с точки зрения меньше либо равно, заметим, что вот этот вот плюс СЗ убился минус вот этим, вот, тут получается тоже шлеп-шлеп, но, правда, тут надо аккуратно, видите, убились логарифмы, но не эти единички, значит, смотрите, там, пум-пум-пум, но тут надо аккуратно, мы же учетную стоимость делаем, да, то есть, нам надо тут очень аккуратно разбираться, то есть, там это уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-уходит, уходит-уходит-у
уходит, это получается не превосходит, значит, если рассматривать логарифмы, то выжил только три логарифма двоичных, значит, ну, давайте, напишем его аккуратно, СЗ от, так сказать, ВК плюс один, значит, минус три логарифма двоичных, что там получилось, СЗВ от 0,
даже, а то 0, тут уже полезно написать до, а то мало ли там что, потому что, ну, вот, но, к сожалению, то есть, в принципе, конечно, это была бы уже победа, то есть, в принципе, потому что, заметим, что, ну, вот, то, потому что вот это вот не, то есть, это минус, а это не, а этот СЗ от ВК плюс один равен тупо Н, ну ладно, не равен, он равен размеру всего дерева, но нам не происходит Н, да,
но, к сожалению, я тут вынужден вот эти единички написать, то есть, это равно два на количество сплайсов в дереве, в, значит, экспози, вот, понятно, да?
У 0, а это, это до, да, это русское слово до, ну или лота такая еще есть, да, вот.
Очень интересно, слушайте, а как по-английски будет нота до? Вот СИЛИЦА, видимо СИДА, ой, ну да, да, да, да, да, так вот, ну и теперь добиваем, так как это не происходит Н, а это идет в минус, то получается, это не превосходит три логарифма двоичных Н плюс два на количество сплайсов.
В экспози, то есть, вот такая учетная стоимость, то есть, смотрите, то есть, учетная споемость конкретного экспози получается вот такая, вот.
Да, но нет, тут вопрос, как ее просто аккуратно, просто аккуратно это, потому что, опять же, тут как бы, чтобы аккуратно сказать учет, то есть, то есть, надо как бы либо модифицировать потенциал так, чтобы он убил и сплайсы.
Ну да, ну это нет, ну можно там зайти, так как вы сейчас это, скажем так, можно теоретически накрутить вот это вот, то есть, сказать, что давайте общий потенциал, это потенциал сплея, плюс вот тот потенциал зеленый, который у нас был, вот это количество там этих лестих рыжих.
Вот, я сделаю по-другому. Я скажу так, учетная стоимость относительно самого экспози, учетная стоимость самого экспози, она вот такая, да, то есть, логарифм плюс экспози.
Значит, далее я скажу, фии, я так скажу, любой, там любой операции, операции вне, вот, за вычетом эксполза, эксполза, ну да, ну.
Ну давайте так, да, заметим, что сплайсы мы делаем только в эксползе, это да, но теперь давайте подумаем, хотя знаете, вот, то есть, мне хочется сказать, что она тоже какая-то адекватная, но вы знаете, правильнее сказать, давайте уж давайте по-честному тогда писать.
Начнем с, вот, снова с нами его зеленые величества. Давайте вот, линк, давайте так скажем, линк, нот без эксполза.
А, да, да, да, да, да, да. Давайте так, т относительно, да, списплея, но вот это. Так, вот давайте так, линк, что нам, так, какую подлянку нам сделал линк? Да, линк сказал, что мы взяли коринг, коринг с плей дерева к огневому пути, если говорить формально, да.
И к этому корню, ну, точнее так. То есть, ну, хотя, да, не совсем так. На самом деле произошло следующее. То есть, дело в том, что этот линк, он состоит из дополнительного сплея, уж как мы сделали мерч, мы взяли вот начало этого пути, вот эту ноль, да, объявили сплей.
Ну, да, ну, вот то же самое, да. То есть, не более чем, значит, вот это вот, ну, то же самое, там, ну, вот, точнее от логарифма N на, собственно, вот это вот, это будет, собственно, сплей от 0.
И плюс, собственно, само подвешивание к этому у 0 какого-то дерева, которое изменит только СЗВ от у 0 самого, изменит его не более чем на N, а его логарифм не более чем на лог M, да.
Поэтому получается плюс, пишем аккуратно еще, лог 2N.
Нет, нет, я тут просто очень аккуратно предупрежу, что у нас тут как бы этот без эксползоит линк состоит из сплея от у 0. То есть, этот сплей не связан с эксползом, это дополнительный сплей, да.
Ну, вот, то есть, тут подвешивание к у 0, ну, вот, и это равно O от логарифма.
Вот так. То есть, учетная стоимость тут тоже от логарифма, то есть, какой-то не происходит какой-то константы на логарифм, да.
Вот. Так, ну, давайте еще скажем.
Так, что у нас тут еще? Т, там, фи, сплей, от, теперь давайте, так, у нас был красная, веселая штука.
Так, красная штука, кат, без эксползо.
Да, совершенно верно. То есть, ну, хотя, нет, ну, да, то есть, здесь, хотя, тут, хотя, заметим, что это, хотя, нет, тут все еще тупее.
Дело в том, что, ну, как бы, нет, что мы сделали? Мы сделали, там, когда мы отпилили вершину V от вершины U, что мы делали? Мы делали эксползоту, который уже объявил, что ребро у V синее.
То есть, поэтому это, на самом деле, не превосходит просто U от единицы на, ладно, даже, даже не рыжая U от единицы, а синяя U от единицы.
Почему синяя? Потому что, помимо этого эксползо, все, что мы делаем, собственно, от, ну, вот, отпил синего V.
Вот так. Вот, собственно, и все.
А, хотя, нет, слушайте, а ведь вы правы.
А нет, кстати, а уже не обязаны, кстати.
Нет, смотрите, сейчас мы не обязаны. Нет, ну, нет, спойлер так, нет, ну, во-первых, давайте так.
Отдельная, нет, скажи, отдельная песня верно ли, что в результате эксползо от U окажется корнем? Спойлер, нет.
Вообще не обязан. Но в данном случае нам начхать, нам начхать вот это, чтобы, потому что вот этот отпил, он делается за U от единицы.
Ну, реально, вовремя U от единицы он делается, в любом случае.
Но потенциал он только уменьшает.
Потому что, по сути, он просто, как бы, ну, вот, то есть, по сути, он уменьшает, то есть, он, конечно, уменьшает, то есть, конечно, изменилось на этот раз много СЗВшек.
Ну, то есть, мы можем добиться того, чтобы уменьшилась только одна СЗВшка, конечно, вызвав сплей.
Но на самом деле в этом нет необходимости.
Потому что уменьшится куча СЗВшек, то есть, изменится куча СЗВшек, но они все именно уменьшатся, они увеличатся.
Поэтому, как бы, уменьшение потенциала нас устраивает.
Поэтому получается, то есть, получается, в общем, не более чем, то есть, один отпил.
Это был кат.
Но, на самом деле, учетная стоимость всего остального, то есть, там всяких вот этих вот опенод,
ну, вот, то есть, давайте, вот, скажем, там, то есть, учетная стоимость этого фиссплея от Эверта.
Эверт без эксполс.
Но это просто тоже, то есть, не превосходит абсолютно технической от единицы на, там, типа, реверс на всем деле.
Потому, вот, почему от единицы?
Потому что он отложенный.
Вот такая красота у нас неожиданно получается.
Ну, всякие, ну, вот, в общем-то, я могу, ну, в этот Эверт, в общем, ну, все остальные операции, в общем-то, они комбинации линков, катов и эвертов.
И чего? И что-то еще. Вроде, что-то еще тоже отложенные операции в корень дерева.
То есть, вывод такой, что учетные стоимости, значит, всех операций вот такие.
То есть, все работает с залогарифом плюс эксполс. Эксполс работает с залогарифом плюс сплайсом.
Это учетно, да?
Но тогда, но, как мы помним, что такое, по сути, учетные стоимости, да?
То есть, мы говорим, что верт, верт, верт, верт.
Что такое, по сути, учетные стоимости, да?
То есть, мы говорим, что верны учетные стоимости, подразумевая следующее, что если мы просуммируем все эти операции, то,
то реальное время работы всех, суммарное реальное время работы всех операций не превосходит суммарно, суммарно учетного времени, правда?
Ну, мы и вот потенциал удовлетворяем всем условиям, поэтому, да?
То есть, вывод.
Ну, тогда получается, что у нас, тогда отсюда следует, что суммарное, давайте тут уже тоже, значит, да, со сплайем тут все понятно.
Но тогда отсюда получается, что, значит, то есть вывод такой, то есть, суммарное нот, то есть, суммарное время,
суммарное реальное время работы, но и время работы там Q операций, ну вот, с Q штрих эксползами,
получается, не превосходит суммарного учетного времени.
Работы, там тех же самых Q операций, с Q штрих эксползами, что теперь, а эта сумма у нас не превосходит чего?
Ну, во-первых, сумма всех эксползов, сумма всех эксползов, ну вот, сумма всех эксползов, это получается не более чем три,
то есть, это значит не более чем три на Q штрих логарифом 2n, плюс два на количество сплайсов за все эксползы.
Вот, и плюс еще все, что было за вычетом эксползов, а все, что за вычетом эксползов, очевидно, имело место O от Q логан.
Но, как мы помним, количество сплайсов у нас тоже было Q логан, помним, да?
Вот, Q штрих это, ну как мы помним, Q штрих это O от Q, то есть, получается это равно O от Q логан.
Ну, в принципе, это по сути означает, что в среднем все будет выполнено за логариф.
Да, может в первый раз выглядеть черно-магически, да?
Ну, тогда у нас больше как-то реже-синей магии.
Нет, черный это так, это в конце, даже черный, знаете, мы уже чистую техническую работу сделали, то есть, основная красота в режесте.
Вот, так что вот такая красота.
Так что вот такая красота, вот такой вот логариф.
Так, вот такой вот логариф.
Есть ли тут какие-то вопросы?
Нет, то реализовываю, ничего страшного в реализации нет.
Нет, ну как, ну там, к сожалению, проблема, что у вас будет...
Нет, ну как, вам придется реализовать сплей дерева, в котором у каждой вершины есть ссылка на родителя.
Ну, например, ну по-разному, а там не важно, на себя, на это, по-моему, там даже удобство это сильного не даст, потому что вам все равно идти до корни.
Единственная проблема, что у вас в каждой вершине еще должна быть потенциальная, то ли отсылка, то ли действительно информация об этом вот самом синем ребре.
Да, но она хранится именно как бы в корне сплей дерева.
То есть мы сплей дерева храним как структуру из стой дерева и информация ребре?
Нет, ну не совсем так.
Ну вот, ну нет, ну можно, конечно, сказать и так.
А, ну в принципе, да, можно сказать и так, на самом деле, да.
Иначе ее просто...
Ну, возможно, да.
Так что... Давай.
Почему мы вложили количество сплайсов, у нас больше на два?
На два?
А потому что у нас вот в этой сумме была вот тут единичка из сплея.
И вот тут единичка на сами вот эти.
Это вот, ну, сама вот эта перекраска, то есть мы как бы сделали сплей, потом надо отпилить вот это под дерево и припилить вот это.
Мы это нарисовали единичку.
Ну, потенциал там не поменялся.
Поэтому я так для понятности рисую два.
Количество сплайсов это нет.
А, ну...
А вот, ну, в этом смысле, да.
Да, у нас тут коребер получилось, с которым мы работаем.
Поэтому, да, ка.
Так что очень красивая вещь.
А что такое?
Нет, ну, как всегда, да.
Это, конечно, проблема, и мне Генту Линукса, да.
Все можно делать своими руками, но, да, надо сделать.
Ну, математически красиво зато.
Вот.
Не, ну, кто-то когда-то даже писал, можно погулять.
Там, в принципе, какая-то, я думаю, если там погулять, то реализация Павла Кулявского там может быть нагуглена.
То есть, может быть, по-моему, там даже не сильно большое число строчек получил.
Вопрос, конечно...
Нет, ну, это возможно.
Это важно.
Сплей, во-первых.
Не такой короткий, на самом деле.
Да.
После сплея тебе нужно вот эти опера, чтобы поддерживать структуру самого дерева дополнительно.
Да.
Ну, да, ну, да.
Ну, тут такое, да, куча технической работы, конечно, да.
То есть, конечно, надо, то есть, конечно, если это очень аккуратно писать, то проблем нет.
Так, ладно.
Есть ли еще вопросы?
Так, ну ладно.
Если нет вопросов, ладно.
Тогда, видимо, пришло время второго перерыва.
Ну, видимо, оставшееся время поговорим о чем-нибудь еще прекрасном.
А фишка, на самом деле, такая.
Ну, вот сегодня мы попробуем немножко обсудить такую замечательную штуку, как атомик ХИП.
Ну, нет, нет, самую ядерную часть мы сейчас обсуждать не будем.
Ничего не предвещало, видимо.
Не, претен.
Вот претен метод четырехрусских, он как бы, скажем так, он как бы выходит за рамки.
То есть, каждую конкретную задачу, конечно, за час и даже там за быстро можно обсудить.
Но просто задача несколько и хочется обсудить их все.
Потому что мы как минимум применим метод четырехрусских к буревому переножению матриц раз,
к, ну, естественно, к задаче про РМКУ, там, за О от единицы, там два,
и, конечно, к его величеству левеланцестер квейрес.
Но там тоже надо рассказывать, потому что там возникнут эти все там куча композиций, их тоже надо отдельно обсуждать.
Мы тоже применим метод четырехрусских и получим там супер божикосмический левеланцестер квейрес
О от Н предподсчета и О от единицы за ответ.
Да. Нет, на самом деле нет. Если вы знаете, если вы уже знаете как это делается Н лог Н предподсчета единицы,
то, в общем-то, там, скорее всего, и знаете основы метод четырехрусских, детали вы, в принципе, можете уже додумать.
То есть там не супер что-то божикосмическое будет.
Ну, то есть, там надо как-то очень, ну, там забирать, просто скажу, там просто идея такая.
И заметим, что можно там двоичные подъемы искать только от листов, там я скажу, да.
А во-вторых, заметим, что если листов там, скажем, меньше, чем Н поделить на лог Н, то мы, в принципе, уже победили.
Да, двоичные подъемы, в принципе, только для листов можно считать без предков, если у вас есть там соседние декабризы.
Ну, в общем, основная идея вкратце вам рассказала.
В общем-то, детали, в принципе, можете уже, ну, то есть мы там в следующий раз их явно обсудим, но, в принципе, основную идею вы можете додумать уже сейчас.
Вот.
Ну, вот, но это просто обет от четырех русских, это весь такая, просто хочется ее прям вот отдельно ее обсуждать, потом посмаковать там, действительно, эту красоту.
Ну, и, в принципе, вообще, знаете, вот, как мой научный руководитель вообще, в принципе, считает, что, ну, что на самом деле хорошее занятие, это на самом деле такое занятие, которое посвящено одной идее.
То есть новая идея должна быть одна, просто она там вот, рассматриваем ее там с разных сторон.
Вот. Ну, у нас, конечно, там у нас с вами четыре с половиной часа, поэтому такое, конечно, там невозможно.
Но, как бы, если у нас есть какая-то новая там свежая идея, то хочется ее, конечно, посмаковать как-то достаточно хорошо.
Вот.
А пока Atomic Hip.
Ну, просто когда хочется Atomic Hip, все-таки немножко к хипам.
Смотрите.
О чем вообще речь?
О чем вообще речь?
Что же такое Atomic Hip?
Да.
Как говорится, куча у нас немало уже сложена.
Но теперь, ребят, смотрите еще одну.
Ой, интересно, Магомаев мог так спеть, а?
Я, знаете, вот Магомаев пел, а любви немало песен сложено, я спою тебе спою еще одну.
Итак, Atomic Hip.
Вот.
Ну, вряд ли он об этом пел, конечно.
Да.
Значит, о чем речь?
А речь вот о чем.
Дело в том, что в игру вступает снова уже позабытый нами жанр работа с целыми числами.
Работа с целыми числами, с целыми W-битными числами.
Вот.
Потому что, в принципе, на самом деле, это такой отдельный жанр в науке.
Отдельный жанр в науке говорит нам, то есть давайте предполагать, что мы там работаем именно с W-битными числами,
давайте на этом какие-то алгоритмы делать.
Вот.
То есть, помните, мы уже отдельно пытались рассматривать задачу, что если мы сортируем не абстрактные камешки какие-то,
которые нельзя отсортировать быстрее, чем Z-logan, а именно W-битные чиселки, то уже...
Что такое W-битные чиселки?
Ну, состоящие не более, чем из W-бит.
Где W-битные – это битность вашего процессора.
Давайте коротенько напомню раз один вопрос.
То есть, смотрите, дело в том, что в каком мире живем.
Мы, по идее, живем в мире рам-модели.
Что это означает?
Ну, я сейчас не буду рисовать ту же картинку, но суть такая, что мы живем в мире, где у нас память состоит из W-битных чисел,
где W – это какая-то константа.
В современном мире она 64, но теоретически в науке она может и расти.
Ну, мы и надеемся на это.
Значит, в чем смысл W-битности?
Мы знаем, что все операции с W-битными числами мы делаем за О от единиц.
Но там могут быть, на самом деле, честно скажу, какие-то детали конкретные,
потому что, скажем, если вы там погуглите Atomic Hip, то вы сразу наткнетесь на очень страшное словосочетание Transdichotomial Model.
Да, вот прям страшное слово.
Я не могу сказать, что я до конца понимаю, что это значит, но в нулевом приближении они говорят так,
что, видимо, они иногда отдельно прописывают, что, типа, умножение мы тоже умеем делать за единиц.
Да, это бывает не всегда так.
Вот.
Ну вот, в этом смысле моделя, там можно, действительно, бесконечно долго копать.
То есть, честно, я пока, по крайней мере, не копал.
Но суть такая, что мы знаем, что сортировки над такими числами можно делать быстрее, чем за N log N.
Но, как минимум, у нас были...
Ну, помните, у нас была эта смешная, там, Киркпатрик Сордза N log W.
Ну, который N log log C, по сути.
То есть, есть такое.
То есть, там следующее применение, я не знаю, которое у нас в последнее время как-то вылетает из программы,
но, видимо, в какой-то момент мы с вами, наверное, будет время обсудить.
Вот это, конечно, дерево онемдебоса.
То есть, дерево онемдебоса – это когда вы хотите реализовать такой сет.
Ну, то есть, обычный сет, но на W битных числах.
Оказывается, что вы можете реализовать так, чтобы у вас действительно это все работало за все операции за log W.
В чем-то отдельный технический интерес будет реализовать не только, типа, insert, insert, delete, erase, search,
но и, конечно же, lower bound, upper bound или там всякие, даже обычно в классических интерпретациях, successor, predecessor.
То есть, для каждого элемента найти там следующий, предыдущий.
Но это эквилентно lower bound.
Нет.
А, ну, хотя, в предположении, что у нас бесконечное число памяти, на самом деле совсем бесконечное,
то есть, на самом деле там даже это не используется.
Да, вот мистика в том, что там оригинальное дерево онемдебоса, оно просто требует, типа, в идеале от W памяти.
Да, так, в наглую.
Но вот, но зато все операции делает, не за от W, от 2 в степени W, конечно.
Да, то есть, конечно, чтобы это реально припилить это к реальной жизни, вам, конечно, придется использовать хэш-таблицу.
Но, с другой стороны, там во многих интерпретациях вам придется делать хэш-таблицу.
То есть, там, если копать там, потому что есть какие-нибудь более продвинутые версии того же самого, типа там Fusion 3 там называется или что-нибудь еще.
Но там, к сожалению, тоже в качестве черного ящика используется мистическая хэш-таблица.
То есть, совсем мистическая.
То есть, в плане, есть черный ящик, типа, вы кладете элементы, достаете оттуда элементы, находите элементы и все за единицу.
Будь здоров.
Вот.
Будь здоров еще раз.
Нет лавербаундов там слова.
Нет хэш-таблицы.
Какой лавербаунд?
Нет, там его нет.
Причем, это, кстати, на самом деле, это может быть в блоке вариаций хэлгоритмов отдельная песня.
А как это вообще сделать?
Вот для этого бы еще дожить до этого.
Ну, в принципе, обычно у нас в курсе иногда бывает, собственно, как сделать статическое.
То есть, видите, хотя бы уже задача.
Дано n чисел.
Ну, там, допустим, дано n чисел.
Задача построить какую-нибудь за oatn, за какой-нибудь вероятности oatn хэш-таблицу.
В смысле, в отожидание.
Так, чтобы потом за oat единицы для любого числа проверять, есть он хэш-таблица или нет.
Но n чисел даны заранее.
Ну, естественно, не ацертированы никак.
Вот. Оказывается, да, там существует веселый алгоритм.
На самом деле такой.
Но, как вы понимаете, он вероятностный.
Поэтому, как бы, если он и будет, то в блоке вероятностных алгоритмов.
Вот.
Так вот.
А что ж такое atomic hip?
Ну, мы сейчас не про дерева на md-boss.
Мы поговорим про atomic hip.
Значит, суть у нас такая.
Мы хотим очень.
Значит, у нас есть w-bit.
Я хочу создать hip на w-bit-ных числах.
Вот как-то вот очень-очень-очень хочется.
То есть сказать, что вот atomic hip.
Вот.
Значит, мне очень-очень-очень-очень хочется.
Значит, пишем, что это все на w-bit-ных числах.
И в этом месте мы говорим, что...
Что мы говорим?
А говорим и следующее, что...
То есть, естественно, за какое симптомическое я хочу это реализовать?
Ну, естественно, если бы я сказал, что у вас insert за логарифом и extract-min за логарифом,
то, наверное, это было бы не очень интересно, правда?
Потому что обычный hip это прекрасно делает.
Если бы я вам сказал, что я хочу делать insert за o от единицы
и, допустим, extract-min,
я хочу делать за o от логарифа n.
Интересно ли нам такое?
Особенно, если я скажу, что амортизация разрешена.
Это же самое, что мы можем.
Это же амортизация.
Но не совсем.
Хотя нет, это практически то же самое, что куча фибоначьего, так скажем.
Необычная куча, необычная.
Любая куча амортизации.
Нет, любая куча амортизации это как бы insert за логарифом и extract-min за единиц.
Да, то есть, extract-min за логарифом это, в принципе, апгрейд.
То есть, для этого надо либо кучу фибоначьей изобрести, либо там как-то аккуратно делать.
Нет, в принципе, да, можно там пытаться даже половину этой оптимизации делать,
потому что там суть могла быть знаете в чем?
Суть могла быть в том, что давайте...
Ну там какая-нибудь суть в духе, что давайте в insert-е просто делаем push-back,
а потом, когда придет время extract-min, давайте за o от n быстренько из этого массива сделаем кучу.
Вот, да, именно.
Вот именно с этим жестом, да, совершенно верно.
Вот.
Ну то есть вот такие какие-то не будем сейчас это копать.
Вот, но суть такая.
Наверное, мы хотим как-то воспользоваться тем, что это w-битные числа,
а не какие-то опять абстрактные камушки в вакууме.
И мы этим можем воспользоваться.
И мы этим воспользуемся так, что наша ставка будет log n поделить на log log n.
А нигде?
Да, мы просто знаем, мы знаем, что оно есть.
Вот, мы знаем, что оно есть.
Но как бы, но мистика в том, что вот, да, w мы еще будем пользоваться в каком месте?
Мы еще знаем, что n скорее всего меньше, чем 2 в степени w, естественно.
Даже скорее всего в некотором смысле сильно меньше.
Ну так, чтобы с запасом, чтобы там не это, не 2 в степени w минус 1, чтобы элементы вообще,
чтобы там с этими элементами вообще что-то можно было делать дополнительно.
А, да, ну вот.
Нет, скажем так.
Не, ну n должно хотя бы, чтобы у нас эта n, во-первых, как бы в битность влезала, да,
и у нас вообще на n элементов память была.
Памяти у нас, очевидно, тоже там вряд ли больше, чем 2 в степени w,
потому что ячейки вы как-то номировать как-то надо, да.
Правда, там дерево на МДБОСа будет, конечно, жрать чуть больше.
Там, скорее всего, 2 в степени w на константу какую-то еще.
Ну вот.
Но поэтому тут надо аккуратно.
Так вот.
То есть в этом смысле ограничение вот такое есть.
Но как бы при достаточно большой там w-битности на самом деле можно рисовать так.
Но как мы уже говорили, есть же сортировка, которая вот,
сортировка w-битных чисел, которая работает за n лог лог n.
Тоже, казалось бы, от w не зависит, но вот с такими ограничениями.
Так вот.
Как же мы это будем...
Ну вот.
Ну вот.
Значит, что же это такое?
Значит, что же это такое?
Значит, ну на самом деле, значит, технология тут будет мистическая.
Технология будет звучать так.
Да.
Ну в принципе, ну вот.
То есть технология будет звучать так.
Вот мы хотим такую кучу.
Да.
Куча, сразу скажу, какие у нее применения.
Ну первое применение, которое там вы сразу откроете в Википедии,
это что алгоритм dx на w-битных числах будет теперь работать,
как бы за сколько?
За e плюс v лог v делить на лог лог v.
Вот.
Вот.
Но более продвинутые свойства с помощью такой кучи окажется,
что можно искать, что миностов на w-битных числах можно искать
за асимптотику.
Правильно, e плюс v.
Да.
Нет, там придет, нет, там отдельная песня.
Как?
Этому будем очень отдельно обсуждать.
Нет, там более хитрый алгоритм.
Это будет модификация алгоритма Фрэд Монтальяна.
Потому что есть алгоритм Фрэд Монтальяна.
Он работает за крутую асимптотику.
Он работает за e лог звездочка v.
Там такая мистическая асимптотика.
Там много мистических, что алгоритм будет ищет миностов за e лог звездочка v.
Но если e больше, чем v лог лог лог v,
то тогда он работает за u от e.
Ну, в миностове e это как минимум v-1, поэтому не принципиально.
Да, но вместо v лог лог лог v я могу сказать любое константное число логов,
на самом деле, там забавно.
Да, то есть если e больше, чем v лог лог лог лог лог лог лог лог лог v,
вот я 10 раз сказал, то как бы будет за u от e.
В миностовах e всегда как минимум v-1.
Поэтому вот e.
А v лог лог лог лог лог v,
ну, формально говоря, когда-то есть разница между v,
v лог лог лог лог лог лог v,
и e там для достаточно больших e.
Да, даже не в этих ограничениях, конечно, но тем не менее.
Да, на практике можно считать, что это u от e.
Да, но там фишка в том, что там просто в одном месте используется куча фибоначи.
Но оказывается, что если вместо кучи фибоначи использовать вот это,
то там количество итераций из логарифма звездочка v превращается в 2.
Нет, просто в 2.
Просто в 2.
То есть там просто есть несколько фаз,
каждый из которых работает за u от e.
Вот, просто там так будет фаз, там лог звездочка,
а тут фаз будет 2.
Ну, там вот.
Ладно, это я вам так поанонсировал,
что, видимо, в следующем семестре будет.
Да, нет, я миностовый тоже хочу в следующем семестре.
Но вот, потому что там, да, весело там.
А так если, если повезет,
может, мы с вами все-таки,
попробуем найти e на обратную функцию кирмана.
Ну, давайте пока поймем.
Значит, для этого нам нужен atomic heap, хоть что-нибудь из него.
Что?
Да.
Вот.
Да, вот это будет действительно расстрел.
Да, но...
Ну, уже расстрел, потому что если soft heap я уже о своей жизни рассказывал,
то то я еще пока не знаю вообще.
Я пытался один раз почитать, и пока не получилось.
Но это ладно, это мы доживем.
Давайте пока, давайте поймем какую-нибудь более простую вещь.
А именно, потому что atomic heap,
ну, полностью мы его с вами не разберем.
А мы сведем его к неожиданности.
Ну, то на самом деле цепочка такая.
То есть там на самом деле три кучи, я все время забываю, как они называются.
Вот это вот, потому что есть как бы atomic,
то есть на самом деле у нас имеется в виду там три кучи.
Одна называется atomic heap,
другая af heap,
третья q heap.
Нет, примерно, на самом деле одна свой,
ну, то есть по сути одна свойца другой,
другой сходится с третьей.
Давайте я их буду называть так, но с оговоркой,
что я могу заберечь.
Потому что давайте,
потому что кто-то скажет,
а может наоборот,
может вот это называется af heap,
а его можно свести к atomic heap, я не знаю.
Но дело в том, что я хочу свести эту задачу
к хипу,
который будет делать
insert за o от единицы
и extract
min
за o от единицы.
Но при этом в маленьком предположении,
маленьком чудесном предположении.
При этом, что я хочу гарантирую,
но при этом гарантируется,
что в каждый момент времени
cz от heap
в каждый момент времени
не превосходит лог квадрат n.
Да, то есть он мелкий.
То есть, да, как это связано,
но обратите внимание, n у нас ограничена битностью, да,
алгорифм n тем более.
То есть мы как бы рассчитываем на то,
что у нас
то есть n не превосходит получается,
ну вот,
ну да, n у нас не происходит
в два степени double,
то есть получается у нас мы как бы лог квадрата
это что-то типа вот битность числа,
битность чисел в квадрате, да.
То есть мы рассчитываем, что
чисел в принципе не очень, не много,
и рассчитываем, что мы с ними будем работать
за o от единицы.
Так вот, но и это еще не все.
Мы сведем тут
значит,
там просто идея еще такая,
просто мы эту кучу сведем
к вот это точно называется, я думаю, qhip.
Как бы не наврать, конечно, но ладно.
Так вот, она будет делать
insert
за o от единицы
и экстракт min
да, как хочется написать отрицательную асимптотику,
но нет, вот единицы.
Весело.
Ща больше.
Так.
Нет, это еще не все.
По-моему, все-таки вот так.
Ой, ну ладно, ладно, не так хорошо.
Вот так все-таки.
Ну ладно, ладно, не так хорошо.
Вот так все-таки.
Ну ладно, суть одна там не принципиальна.
Смотрите, что это такое,
то есть это мы берем w
и еще из него какой-то, видите, корень извлекаем,
по сути.
То есть я так в скобочках припишу,
что это корень четвертой степени из w.
Мы сводим это к этому,
а это к этому.
Вот реализация этого использовать,
это как черный ящик.
А реализация этого использовать,
это как черный ящик.
Так вот, вот это магия будет.
Значит, это какая-то там магия,
потому что там оказывается,
то есть можно рассмотреть,
что в некотором смысле,
рассматривать какие-то не все биты,
а только правильные.
И окажется, что там как-то состояние
на этих правильных битах,
собственно, ограниченное количество,
и на них можно построить что-то типа автомата.
Чего?
Амортизировано.
Амортизировано.
Амортизировано.
Да, то есть поэтому я не уверен.
То есть, может быть, в какой-то момент
хотелось бы, конечно, это тоже добить,
хотя в прошлый раз, когда мы пытались,
нам не удалось.
Но там действительно черная магия,
потому что для этого придется там действительно
все там Fusion 3 обсуждать,
там все эти X-Fast и Y-Fast,
там, в общем, долго к этому можно идти,
долго обсуждать и взрывать себе мозг.
Это конкретно Q.
Ну нет, ну да.
Да, но это конкретно Q.
Но технология, с помощью которых
действительно это сводится,
она к этому адским автоматам отношений не имеет,
и ее как раз обсудить хочется.
Но на самом деле технология сведения
тут везде одна и та же.
Она будет называться B-дерево.
Ну, что-то типа B-дерево, если быть точнее.
Значит, фишка такая.
Я хочу, чтобы у меня эти элементы были в B...
Ладно, давайте себе вообразим даже не B-дерево,
а B-ичную кучу.
То есть, хочется, чтобы...
Вот.
То есть, у меня есть B-ичное дерево.
Вот.
То есть, такое вот B-ичное.
То есть, везде, у каждой вершины B-детей.
И какая-то высота.
Ну, типа.
Вот.
То есть, будем хранить.
Но, правда, естественно, идеальная B,
то есть, идеальная B-ичная куча,
конечно, накладывает...
То есть, там не все N-ы подходят, правда?
Вот.
Ну, во-первых, скажем, чего равно B?
Ну, и здесь все очевидно.
Значит, давайте, в первом сведении я скажу, что B это...
двоичный логариф МН.
Значит, двоичный логариф МН.
То есть, давайте, я тут буду себе, допустим,
вот эту вот, действительно, штучку как-то хранить.
Как-то хранить.
Допустим.
Нет.
В будущем нет, но изначально хочется, что да.
Потому что нам хочется, как всегда, мы же мечтатели с вами,
поэтому нам хочется мечтать, что у нас есть набор вот таких деревьев.
В чем набор деревьев какой?
Ну, во-первых, давайте подумаем, какая может быть высота?
Какая высота, кстати, у такого дерева?
Ну, на самом деле, очевидно, высота у такого дерева логарифом Н
по основанию логарифом Н.
Это тот самый логН делит на лог логН.
Что-что?
Верхний. Пока верхний.
Хотя, забегая вперед, нижний будет тоже самый.
Вот.
Потому что, скажем так, основная идея будет у нас такая.
Почему именно столько?
Идея у нас будет в том, вот как это свести...
Зачем нам нужна теперь вот такая куча?
А очень просто.
Потому что дело в том, что нам же в идеале захочется делать какой-то вот экстракт-мин.
Обычно...
Ну, как делается экстракт-мин?
Ну, обычно...
Обычно экстракт-мин делается...
То есть, то экстракт-мин обычно делается, что мы свапаем с каким-то там ребенком.
И после этого делаем какой-то севдаун.
На севдаун делается за высоту умножить на.
Умножить на.
Умножить на количество детей, чтобы из них выбрать минимум. Правда?
Так вот.
Очень-очень хочется...
Этот минимум на самом деле...
Вот для того, чтобы искать минимум быстрее, давайте вот в этих все элементы хранить...
То есть, вот эти вот корневые элементы хранить...
Вот в этом вот маленьком хипе.
Давайте назовем его AF-хип.
Для себя.
А это вот Q-хип.
То есть, вот это вот...
То есть, вот на вот этом вот мы храним AF-хип.
Вот.
Ну, типа да.
Вот.
Так что...
Да, но на самом деле да.
В идее, конечно, возможно, нам потребуется, чтобы у нас еще всякие декрески еще за единицу делались.
Ну, кстати, ладно, давайте допишем, что нам сложно, что ли.
Да.
Что?
На всех.
В каждой...
Тут, тут, вот тут AF-хип.
Тут AF, тут AF, везде.
Но я говорю так.
По сути, у каждой вершины, у которой есть дети, я храню этих детей в хипе.
В AF-хипе.
То есть, я сразу всех детей храню?
Ну, детей, да, не потомков, а именно детей, да.
А, то есть, у каждой вершинки есть свой AF-хип?
Да.
В котором хранятся дети.
Типа в идеале B.
Но это в идеале.
Да, декрески, забыл сказать, конечно же, ну, чтобы у нас была адекватная D экстра за E плюс В лог В, нам требуется декрески адекватной за единицу, правда?
Поэтому ставочки тут, конечно, такие.
То есть, всякие тут декрески, конечно, везде потребуется.
Везде потребуется.
За от единицы.
Ну, и тут понятно.
Ну, там обычно будет речь уже о том, чтобы просто выпиливать рандомные элементы за единицу.
Поэтому, соответственно.
Ладно.
Итак, давайте думать.
Как же это сделать?
Ну, конечно, жестко.
Ну, а первых, как вы уже сказали, таких деревьев у нас, то есть, как бы придется, то есть, саму себе кучу придется хранить в нескольких деревьев, правда?
Ну, типа того, да.
Но, правда, тут есть оговорчика.
Оговорчика будет заключаться в том, что, конечно же, мы будем хранить несколько таких деревьев.
Но так как у нас вот, да, то есть, как бы, но идея такая.
То есть, для каждой высоты h мы будем хранить не более, ну, допустим, не более, чем b-1 дерево.
Вот.
Ну, во-первых, смотрите.
Значит, магия такая.
То есть, в идеале хотелось бы, чтобы это была куча, да.
Но, правда, будьте внимательны.
Сейчас у нас парадигма будет меняться каждую минуту.
Потому что мы как бы мечтаем, мы думаем.
Потому что, смотрите.
Ну, как бы в идеале просто у нас мелькает такая идея, что раз у нас тут b детей, то хочется сказать, что если у нас есть, то есть, раз у нас есть деревья разных высот, да.
Ну, мы знаем, помните, в какой-нибудь там биномяльной куче у нас были идеи, что если у нас есть два дерева одинаковой высоты, то мы из них можем делать просто одно дерево более высокого порядка, правда.
Но тут мы хотим, чтобы, как бы, высоты были более-менее одинаковые, да.
Ну, вот.
Поэтому, наверное, хочется идейно иметь себе в виду, что у нас, как бы, если есть b деревьев одинаковой высоты, вот я тут высоты h имеется в виду.
То есть я очень хочу, чтобы у меня этих, чтобы если у меня стало в какой-то момент b деревьев высоты h, то я быстренько из них сварганил новое дерево высоты h плюс один.
А вот.
Но как же я это сделаю?
Вот как?
Действительно, как же я это сделаю?
Сделаю я это неожиданным образом.
На самом деле, знаете, я скажу, что это b дерево, это ну не прям куча.
Это b-ичное дерево отрезков.
Да, такая смена парадигмы, да.
Ну, по сути, да.
То есть у нас типа на нижнем ряду хранятся все элементы, а тут вот мы тут постепенно храним минимумы, минимумы и так далее.
Вот.
То есть мы пока имеем в виду, честно скажу, может быть, да.
Как-то, может быть, вы даже записывайтесь, потому что тут сначала давайте, как говорится, да, поймем окончать на победную идею, а потом уже будем записывать на самом деле, да.
Вот.
Но суть одна.
Теперь, но тогда в таком случае возникнет вопрос.
Хорошо, как этот минимум выпиливать?
Потому что хорошо, понятно, что, наверное, в каждом элементе вот в этом минимуме мы, наверное, можем хранить ссылку на то, а что это за минимум вообще, да?
Но идея, на самом деле, может быть, ну вот, в принципе, мы можем хранить ссылку на это, а что это за минимум вообще, да?
Но идея, на самом деле, может быть, ну вот, в принципе, да, если у нас есть такая парадигма, то есть у нас есть вектор, векторов куч такой, да.
Ну аши у нас, слава богу, ну пока не сильно много, пока кажется, что и столько, хотя их явно может оказаться чуть побольше.
Но асимптотика такая.
Потому что давайте себе вообразим.
Хорошо там, то есть как мы хотим вообще удалять?
Удалять мы, наверное, хотим так.
То есть удаляем так, то есть мы находим, где тут на нижнем уровне находится этот минимум и что с ним делать?
Присвоить ему бесконечность?
Ну, как сказать, да. Можно, конечно, присвоить бесконечность, но тогда, как бы понятно, мы должны будем как-то периодически это прореживать.
То есть мы должны будем периодически, то есть мы там периодически должны будем как-то от этого избавляться.
Значит, тут предлагается неожиданная вещь.
А давайте-ка мы просто, если тут какого-то ребенка надо отпилить, давайте его отпилим.
И всех детей, на всех уровнях.
Ага, ну нет, ну со всех детей, ну всех не получится.
Ну всех, наверное, многовато.
Поэтому...
Да, это да-да, но это в идеале, если тут по б детей.
Да, то есть если выпиливать, тогда у нас получится б на лог-лог-н там каких-то деревьев, которые надо аккуратненько как-то куда-то там вставить, как-то с ними разобраться.
Нельзя ли поддерживать статически эту структуру?
Нет, ну там статически совсем не получится.
Но для того, чтобы у нас была там со всеми инсектами амортизации, предлагается делать так.
Мы себе разрешаем, чтобы количество детей было от б пополам до б.
Ведь что-то подобное у нас было, помните?
Мы разрешаем, то есть, пойте, в круче фибоначи мы себе сказали, что ладно, если от нас пилили одного ребенка, то нормально.
А вот если отпилили второго, значит что-то не так.
Значит пришло время отпилить нас.
Ну и здесь примерно то же самое.
Ну собственно или там в софте P у нас тоже что-то подобное возникало.
Хотя бы выяснили, что вроде нет в этом необходимости, но там обычно в сифте считается, что давайте отпилим б пополам.
Что типа пока от нас отпилили немного детей, нормально.
Если отпилили половину, значит давайте расформируем нас как родители.
Вот.
Так что вот такая идея.
Идея получается такая тоже рекурсия.
То есть отпиливаем ребенка и проверяем.
Если здесь осталось более чем b пополам детей, значит в этом месте все в порядке.
Если детей оказалось менее чем b пополам, то тогда мы эту вершину расформировываем.
То есть все эти вершины добавляем в наш вектор векторов как деревья высоты ноль.
А отсюда значит выпиливаем элемент, если тут и смотрим сколько тут осталось и так далее.
То есть вот такая идея.
То есть идея такая. Мы поддерживаем вариант, что у каждой вершины детей от b пополам до b.
Когда мы решили отпилить ребенка, мы проверяем.
Если у родителей больше чем b пополам детей, мы ничего не делаем.
Но как только их осталось b пополам или меньше, мы расформировываем тогда родительскую вершину.
То есть отпиливаем уже аж вот это под дерево.
Объявляем, что этого родителя больше нет.
А все его оставшиеся не более чем b пополам детей это полноценные деревья высоты ноль.
И мы их добавляем в наш вектор векторов.
А мы храним для каждой высоты.
То есть аж равно, допустим, ноль, один, два, три, четыре, пять.
И идея тут такая. Мы в каждом дереве храним набор каких-то куч.
Вот набор, набор, набор, набор, набор.
Ну и фишка будет в том, что надо...
Ну там просто добавление.
Ну тогда пришло время...
Нет, они не будут за себя ссылаться.
Нет, это не пересекающиеся деревья.
То есть важно, что как бы объединение...
То есть каждый элемент лежит...
Там подразумевается так.
Каждый элемент этого дерева это отдельное дерево высоты аж.
Ну типа да.
Ну и во всех наших, да.
То есть там фишка будет такая.
То есть мы просто все эти бэп-полам детей попушбэкаем вот сюда.
Ну вот.
Мы выпиливаем эту вершину.
И теперь смотрим. У этой вершины у дедушки тоже могло остаться не более чем бэп-полам детей.
Но если осталось более, то все в порядке.
Если осталось не более, то мы тогда ее расформироваем.
И вот здесь отправляем список вот этот.
Очень удобно, оказывается.
Удобно, оказывается.
Но правда тут оговорка.
Мы поддерживаем вариант, что тут в каждом списке деревьев не слишком много.
Ну потому что если это не прореживать, то тогда скорее всего будет ситуация, что все будет лежать вот здесь.
И тогда у вас по сути дерево превратится в список.
Это нам не надо.
Вот поэтому.
Но это на самом деле все делается как в инсекте.
Потому что все делается, ну как бы все вставки такие сюда, они поддерживаются очень просто.
То есть вы когда вставляете дерево, говорите, если у вас тут образовалось списки б деревьев,
то вы тратите от б времени на то, чтобы соответственно превратить их в одно.
Логично, да?
Вот.
Но причем рекурсивно, естественно.
Потому что могло так случиться, у вас тут б превратили в одно, push back то ли сюда, и у вас тут уже переполнение.
Вот.
Вот.
По сути так, просто фишка.
То есть так делается инсект.
Ну потому что инсект как делается.
Мы создаем дерево высоты 0 из себя любимой, пихаем его сюда.
Но вот с вот этим вот каскаем объединений.
То есть вот такая классическая идея.
Хотя в общем-то, как показывает Пашка, вообще-то достаточно сложная такая.
Хотя сложно тут будет.
Идея-то может и несложная, но остается только понять, почему это работает за адекватную симпатику.
Ну хотя в принципе...
Это вот самое интересное.
А, ну и самое главное, что как искать минимум-то вообще?
Экстракт минимум, как делать?
Очень просто.
Это все.
Нам гарантируется, что высота любого дерева...
Но нам...
Ну хотя с другой стороны, давайте подумаем.
А какая может быть у нас высота дерева?
Вообще?
Ну заметьте...
Ну вот.
Ну да.
Заметим на самом деле следующее.
Что по сути у дерева высоты аж.
То есть, во-первых, заметим, что...
Ну я утверждаю, что как бы у каждого дерева есть такое свойство СБ дерева.
Такое, что все листы находятся на одной и той же глубине, правда?
Вот.
И причем у каждой вершины, которая не лист, детей хотя бы пополам, правда?
Поэтому какая-то оценка типа log n на log log n остается верной.
Вот. Потому что...
То есть тогда у нас действительно высота, то есть действительно логарифм n все еще, но по основанию не log 2n, а log 2n пополам.
Но это как бы все равно log n вот.
Но как бы отличие только в том...
Ну по сути тут там двоечка просто где-то вот здесь вылезет, по сути, да?
Ну не важно.
А ну или там даже минус один, но хотя да.
Давайте так.
Вот это точно верно.
Там уже конкретную алгебру прописывать не будем.
То есть получается, да, есть там какое-то ограничение на высоту.
Но самое главное, что просто эта высота, будем считать, что она не превосходит log 2n.
Поделить на log n.
Зачем я это себе говорю?
Потому что я хочу следующий.
Как я буду искать? Я хочу еще экстракт мин быстро искать себе, да?
Как я это буду делать?
А я это делаю простым образом.
Я возьму все корни.
Все корни.
То есть я как бы возьму все корни всех деревьев, которые у меня тут есть.
И такжественно отправлю их в еще один af-hip.
Который у меня на этот раз будет реально.
То есть видите, здесь у меня размеры должны были быть не более чем логарифом.
А вот тут мне лог квадрат и пригодится.
Ну не лог квадрат, он конечно там получится поменьше.
Там по факту лог квадрат n даже меньше.
Это поделить на log log n по факту.
А как мы можем все этого af-hip засунуть?
Ну в смысле, для каждого дерева, у каждого дерева, который тут лежит, будет вот этот минимальный элемент, который мы будем отправлять сюда.
Короче, от него минимальный?
Да.
То есть от каждого дерева минимум.
То есть это такой вот супер там.
То есть как бы у нас как бы мы побили как бы элементы на кучу чемпионатов.
Там какие-то чемпионаты высоты 0, высоты 1, высоты 2 и так далее.
И у нас получилось таких не более чем лог квадрат чемпионатов.
И чемпионов этих чемпионатов мы отправили себе в суперфинал.
Вот.
Как удалять?
Как удалять?
Ну удалять значит еще раз.
Как удалять?
А почему мы это экстрактно сделали за лог?
Мы таким образом экстрактно находим, да?
Да.
А каким образом это сделано за лог?
А потому что...
А смотрите, фишка такая.
Потому что как мы будем устраивать конкретное удаление элемента?
Причем даже не важно, кстати, минимум или произвольного.
Значит до какого-то момента...
То есть мы будем идти от листа до корня.
Но обычно, когда нам нужно просто найти минимум,
обычно мы для каждого элемента будем хранить, где этот минимум находится.
А так, когда вы говорите удалить минимум,
но обычно, помните, у нас есть классика, что когда вы в куче фибоначей,
когда вы хотите удалить какой-то элемент,
обычно у вас есть какой-то итератор на тему того, где он находится.
Здесь будет подразумеваться примерно то же самое.
То есть подразумевается, когда лежит...
Вам не скажут абстрактно, у тебя там был элемент,
равный 57, удали его.
Нет, такого у нас не будет.
У нас есть...
Ладно, максимум что...
Ну там, конечно, разные технологии есть, как это обойти, но, соответственно...
У нас есть итератор на минимум.
Ну допустим, вот вам тыкнули, вот этот лист надо удалить.
Как мы это делали?
Удалять каскадно.
То есть в какой-то момент удаление...
Каскадно-каскадно, в какой-то момент удаление закончилось.
Вот.
Но тогда из этого элемента просто надо...
Так как тут все дети хранились в атоме к хипе,
значит мы просто сделали удаление из этого АФ-хипа.
Но там мы предназбываем, что удаление уже как-нибудь за единицу сделается.
А где АФ-хипа?
В каждой вершине дети хранятся в АФ-хипе.
То есть из этого АФ-хипа элемент удалили.
Но здесь, очевидно, дилит тоже делается за единицу,
потому что дилит можно свести к экстракт-мину,
где крестки до минус бесконечности, экстракт-мину.
Поэтому дилит тоже за единицу неважно.
Значит вы его удалили и за одно минимум пересчитали.
Потом вам придется пройти до конца, и эти минимумы правдейтить, конечно.
Поэтому, то есть у вас получилось,
то есть вы потратили время, и получается от высоты дерева,
то есть лог-н делить на лог-лог-н,
плюс время, которое вы потратили на формирование вот этих деревьев.
Нет, мы его не будем оптимизировать.
Мы просто докажем, что это работает круто.
Я думаю, вы уже даже примерно догадываетесь, каким образом.
То есть на самом деле просто фишка такая,
потому что очень хочется сказать, что на самом деле инсорт,
то есть на самом деле инсорта на самом деле,
у нас на самом деле работает от единицы за счет чего?
Это просто куча нулевой кубины.
Ну вот.
Потому что смотрите, чаще всего инсорт будет,
просто мы тут попушбекали, и все, на этом закончили, да?
Единственное то, что мы здесь делаем,
мы попушбекали, и все, на этом закончили, да?
Единственное то, когда тут стало слишком много деревьев,
давайте их объединять.
На это надо потратить, ну, наверное, о от б времени, правда?
Ну, о от б конкретно здесь, плюс еще тут, тут, тут, тут, да?
Ну так идея такая, давайте добавим,
то есть давайте каждому инсорту добавим две красные монетки.
То есть каждый раз, когда мы добавляем элемент,
мы кладем в него две красные монетки.
Ну вот, что?
А, да, да, да, пардон, пардон, пардон, да, вот здесь надо рисовать, конечно.
Давайте две красные монетки.
Для чего я это делаю?
Я хочу поддерживать инвариант.
То есть я хочу поддерживать инвариант,
что у меня на каждом дереве, то есть на каждом корне каждого дерева здесь,
лежат по две монетки.
Вот, понимаете, да?
На каждом корне по две монетки.
Да, на каждом корне по две монетки.
Тогда, когда мне приходит время объединять деревья,
я должен превратить 2b монеток в две монетки.
Я очень хочу надеяться, что 2b минус 2 монеток,
2b минус 2 монетки мне хватит на то, чтобы создать b дерево.
То есть сделать вот эту вот о от б операцию.
Ну, можно сказать, что у нас не 2, там 2b минус 2.
Ладно, сказать, что у нас лишнее 2b минус 2, но еще две монетки накидать.
Ну, там, хотя нет, две монетки лучше уже не накидывать.
Ну, короче, пусть будет 2b минус 2 больше либо равно b и будет радость.
Правда?
Что не так?
Что смущает, что 2b минус 2 больше либо равно b?
Давай.
Давай, не умирай, пока тут дадут.
Вот.
Ну, да, просто мы b достаточно большое возьмем и все, да.
Ну, скажем, b равно, там, я не знаю, 3.
Вот, там пойдет.
Ладно, не важно.
Вот.
Ну, вот.
Но тогда получится, что конкретно инстинкт действительно работает за 1.
Потому что все вот эти вот каскадные мержи мы тупо оплатили.
Удобно, да?
Да.
А теперь фишка.
Откуда мы еще монетки возьмем?
На вот, потому что у нас же еще есть вот эти вот каскадные безобразия, да?
Так вот, фишечка теперь такая.
b пополам b, да?
Ну, в принципе, да, тут, наверное, вы уже могли давно пробить, на самом деле, уже.
Потому что мы же, ну, вот, давайте, когда мы выпиливаем...
Смотрите, когда мы отпиливаем ребеночка,
мы кладем на вершинку...
4...
Да, 4, то есть вот на этого родителя кладем 4 зеленые монетки.
Да.
Это не считая тех вот красных, которые тут лежат.
Да?
Да.
Это не считая тех вот красных, которые тут лежат.
Да.
Да, они лежат только...
Нет, она лежат именно на родителе, но только на корне лежат какие-то две,
но на нем могут еще свои зеленые лежать.
Именно когда мы отрезаем...
Да, когда мы от вершины отрезали какого-то ребеночка,
мы положили мне 4 зеленые монетки.
Зачем мы это делаем?
Да, потому что...
Да, то есть теперь идея такая.
То есть, когда у нас осталось b пополам детей,
то получается...
А может я даже и переборщил, может даже двух зеленых достаточно.
Да, давайте две.
Потому что, смотрите, у нас тогда останется b пополам деревьев
и b зеленых монеток.
И тогда получается мы можем теперь...
Ну, может быть там, ладно, 4 монетки может и стоить,
чтобы там оплатить совсем мелкую технику.
Но суть в том, что просто так как у нас будет b пополам деревьев
и b пополам деревьев и b зеленых монеток,
то тогда получается, что мы теперь каждое дерево можем добавить
с своими двумя монетками.
А мы помним, что от единицы у нас было чисто на то,
что мы дали эти две монетки.
Ну, ладно, плюс сам пушбек, но на самом деле там пушбеки,
кроме самого первого, легко оплачиваются, очевидно.
У нас перед постом мы удалили b пополам.
Детей?
Да, отлично.
Так что мы в этом месте делаем?
Мы удаляем эту вершину.
То есть мы там получается удаляем эту вершину.
А вот на эти b пополам детей у нас образовалась b монетка.
Вот эти вот сколько-то монеток.
И теперь, да, теперь на каждое дерево мы распределили
по две монетки на каждое из этих деревьев,
и с этими монетками их пушбекаем сюда.
И тогда получается, что мы их после этого пушбекаем за бесплатно.
Ну, да, я просто подчекивал, откуда они взялись.
Ну, сформулируем так.
Ну, там нот.
Ну, как бы, когда ты его удалишь, ты там положишь еще две зеленые монетки.
Ну, смотри.
Но на самом деле сам по себе проход по этому дереву мы не оплачиваем.
У нас лог n делить на лог лог n, да?
Поэтому, в принципе, сами вот эти вот от единицы там операции
и т.д.
Они не считаются.
Да.
Но можно и так сказать, да.
Ну, да, тут каскадо.
Потому что в этой вершине тоже хранятся зеленые монетки.
Если мы отпилили, решили отпилить к нее ребеночка,
то мы делаем не только это, но еще и тут две монетки кладем.
И вот это все.
Так, это всё.
только это но еще и тут две монетки кладем тратя на это все равно от единицы
времени просто конечно ну типа того туда ну например смотрите мы же как бы
проход сам по себе мы работаем за логен поделить налог логен поэтому в
принципе на каждую вершину там от щедрот своих положить лишние 2 2
монетки никаких проблем нет
но например но если быть четная дата но можно там раздая ну скажи так эту
мелочь можно уже допилить как угодно можно сказать что бэк счетной сказать
чтобы полом нас устраивает можно сказать что давайте вместо двух
музыки чтобы не лишь две две зеленые монетки вот на это и две какие
я моментки на все на всякий пожарный но там просто чтоб гарантия что у нас там
лишнее лишь киев от единицы действия мы можем
оплатить здесь оплатить там вот за это там передать наверх в общем как угодно
это но это уже откровенной де té это уже откровенный детала реализации вот но
так то есть то есть мы таким образом то есть конкретно то есть мы добили
того что то есть потому что то есть мы показали следующие то есть мы показали что если у нас
есть дерево и две монетки которым дерево две монетки то мы pushback-нуть их вот в это дерево
можем за ноль за учетное время ноль ну просто в инсерте эти два монетки мы просто даем красными
монетками создаться сам факт инсерта остальные зеленые монетки берутся ну уже понятно откуда
вот то есть уже из там самих структуры стальные ну вот вот но единственное там конечно оговорка
чтобы во всех этих объединениях конечно есть еще такой важный момент что мы эти б-элементов
еще должны выпилить из аф хипа и добавить в них один но это все вписывается в отб потому что мы
из этого хипа мы умеем доставать доставать элементы за единицу и совать элементы завод единицы
понятна логика да нет в этот аф хип мы кладем просто корни все то есть там элементы
грехи в корнях всех вот этих деревьев и там ну деревьев мало поэтому тут аф хип адекватный
потому что тут высота у нас не более чем лог в каждом не более чем лог деревья поэтому получается
лог квадрат даже потому что у нас есть аф хип который говорит что если хип маленький то мы
все за единицу делаем то есть эти фишка именно в том что мы говорим что если элементов мало
например там логн или лог квадрат то мы все умеем делать за единицу мы говорим так тогда мы можем
для за н тоже быстрее работать потому что делим на уровне делим на максимальный уровень так чтобы
на каждом уровне все за единицу делать то есть по сути идея в этом то есть таким образом вот
дапло но то есть таким вот на самом деле не самым хитрым образом на самом деле то есть как бы не
самый хитрый амортизации уже в общем-то нам знакомый получается что вот это сведение выполнено
ну да нет там нет сейчас где ну нет здесь мы не делаем декриски мы сделаем мы здесь
делаем дилет отсюда вот этот вот да но если он поменялся надо проследить что если он
случайно поменялся но не расформировался то значит да но это все равно от единицы поэтому
да но это все равно от единицы поэтому не интересно вот так что вот таким образом мы
внезапно победили вот это сведение декриски а элементарно как-то хочешь уменьшить вот этот
ключ так но вот нет ну как бы ответ так а вот давайте действительно подумать хороший вопрос
нет нет на самом деле фишки но вот
нет ну так вот хороший вопрос вот давайте думать вот давайте внимательно думать
умеем ли мы декриски за вот единицы адекватно делать а может но вот да
там просто фишка такая если вырезал элементы тебе придется пробежаться до корня и поменять
минимум это на самом деле действительно то есть действительно тут оказывается подляночек
да не умеем поэтому с точки зрения поэтому с этой точки зрения возникает вопрос они
поторопились и мы выводить дерево отрезков да вот да да я обнаглел да вот да то есть
да нет хотелось бы конечно декриски за вот единицы это да нет это нелогично потому что у
тебя тут как бы формально все минимумы по всей высоте изменим могут изменять если на каждом
шаре делаешь декриски реально минимального элемента в дереве то тебе придется по всему
проходить в таком формате нет ну вот нет поэтому нет с этой точки зрения на самом деле вот
действительно может возникнуть действительно маленький красивый вопрос действительно не
а теперь давайте попробую хорошо с деревом отрезков мы поняли а теперь давайте а теперь
нет а теперь нет а теперь давайте а теперь давайте кучу вернем кучу элементов этих вот
хорошо потому что смотрите в итоге идея нот но давайте посмотрим куда нотку куда нас вывезет
потому что давайте предположим что это куча реальная просто то есть как бы храним реально
боечную кучу просто гарантия что у каждой вершины детей может быть не ровно б от
б пополам до б и соответственно гарантируем что естественно каждый элемент меньше чем дети
то есть вот такая вот идея ничего мы продолжаем смысле что так так все нот да да да но до этого
да сейчас не понял вопроса всех детей храним в чем но детей храни до детей естественно храним
в куче да твоя в куче да ну поехали так как тогда все это но insert работает абсолютно так же тут
никаких проблем нет вот теперь это просто как делается но как делается экстракт мин но на
самом деле заметим что экстракт мин делает но экстракт мин тогда по такому раскладу делается
так то есть получается что нам нужно расформировать ну как бы тупой вариант был бы нам нужно взять
расформировать корень объявить что у нас есть просто теперь появилась там от бы полам да
б деревьев надо их попу же быть но это долго это логарифом она логарифом деревьев пушбек от нас
все-таки не устраивает но с другой стороны идея такая а челка рифм да а давайте это
умное слово сив да он смотрите как на самом деле все делается мы идем в какой-нибудь лист да
понимаете да и swap инот то что мы делаем то есть идея такая то есть давайте то есть
это то сделаем так то есть в этом листе напишем допустим плюс бесконечность в этом элементе
напишем вот наш элемент и после этого сделаем честный севдал пока предельно честный правда
прямо часто часто его опустили и опустили прямо вот за высотой опустили потому что на
каждом уровне работаем за понятно сколько да понимаете логику да а
после этого теперь говорим так вот у нас тут образовал слишком плюс
бесконечность а вот ее давайте выпилим
понятно да нет смотрите как мы делаем вообще экстракт мин в абсолютно
обычной двоичной куча мы делаем так помните мы делали так мы минимум свапали
с последним элементом да делали тут всегда он а вот этот последний элемент
удаляли да ну там поп-бэк просто делали да так вот здесь мы делаем
абсолютно то же самое то есть посвапаем ее единственное что она вот и проделаем
себе просто вот честные севдауны но если окажется что этот элемент все равно
меньше своих детей то как бы ну и хорошо если не окажется то мы его свапаем с
минимумом да но вот там свапаем с минимум и где но там и где он там
оказался идем там под деревой делаем то же самое то есть абсолютно классический
севдау только единственное что с каждой вершиной то есть на каждой высоте мы
тут за единицу работаем потому что мы минимум из детей находим в эфх и пе
чего а мы обратите внимание мы в этом месте никого не удалили то есть мы
сказали что этот элемент теперь плюс бесконечность и мы его посвапали но
структуру дерева мы пока никак не поменяли то есть я посвапал и делаю
севдауны севда он свапает некоторые элементы но не меняет структуру вот но
потом в конце у нас просто останется что ну мы уже потратили логан поделить
налог логан времени да а теперь вот этот вот плюс бесконечность вот давайте
теперь ее выпилим и вот теперь то все начинает работать значит что это значит
что это дало это дало что теперь декриски мы делаем также как делали в
куче фибоначи а именно то есть вот у нас жила было вершина которую мы неожиданно
захотели уменьшить она находится то есть на ней какой-то борода висит какая-то
да ну и она на чем-то там висит да так вот идея такая а давайте-ка выпилим все
это под дерево помните как мы в куче фибоначи делали декриски мы просто
были так вершина не корень а давайте сделаем ее корнем и делаем вот тут
но вот перед тем как ее добавлять дерево естественно мы скажем что это так как это
декриски то мы теперь в этой вершине можем ее уменьшать как нам заблагорассудится
предварительно сделаем и добавляем дерево да положив на нее две монетки которые мы за сам
фарки киски нам дали там какие-нибудь специальные красивые рыжие монетки
что не но нет те зеленые монетки которые на ней лежали они остаются лежать на будущее
ну типа того но вот так но при на но а но опять это та технический деталь
давайте ну экономисты пока не пришли так что давайте хочет это добиться не
хочется в следующий раз возвращаться нет вот там хорошо там просто но фишка будет такая
ну нет вот там ладно там уже оказывалось что но там в будущем когда у нас будет
каскадин когда можно сказать что новопришедшие две монетки на самом деле то есть как бы мы
говорим так хотим там отпилить а там и так уже много монеток но отлично значит
эти монетки оставляем а наши новые две монетки положим потом то есть по сути нам тогда то есть
можно это довести так что реально новые монетки нам придется класть не на каждую высоту а только
зологарифа то есть а только один раз когда мы отпилили от кого-то ребенков и нам сказали
что нет у нас еще нормально мы сами выпиливаться не будем что вот так что поздравляем да мы
превратили кучу в деревоотресков потом деревоотресков превратили в кучу и победили
да но про нет это просто как бы наш способ как мы к этому пришли ладно остается только
финальный вопрос как вы думаете как вот это сводится к этому но на самом деле да
нет смотрите идея на самом деле очень проста вот здесь смотрите здесь b равно лог 2 n так вот
идея такая как свести вот эту штуку с размером лог квадрат n вот это размера лог 1 делить на 4
практически тоже самое только здесь сказать что b равно лог степени нет это важно 1 5 для
чего я делаю потому что высота такого дерева будет ну то есть будет но будет что-то типа вот
логарифом вот этого да то что-то типа 2 лог лог n но вот ну поделить что-то такое в общем там понот
да то есть на самом деле да то есть высота такого дерева здесь будет вот тупо константа
почему я здесь делаю пятую а не четвертую ну чисто для того чтобы у меня получилось что
у меня тут как бы высота бывает высоты деревьев там бывает не более чем констант там 11 или там
в два раза больше там неважно но вот но как бы я хочу чтобы но как бы тогда вот в этом хипе
у меня должно лежать получается сколько у нас получается должно лежать там вот элементов
b умножить насколько высота поэтому как бы мне не надо лог степени 1 5 мне нужно чтобы умещалась
лог 1 5 умножить на константу поэтому я тут вместо поэтому я тут себе как бы потребовал чтобы нет
тут нет хотя нет тут наоборот когда надо нет тут тогда надо наоборот сводить немножко то есть
тогда это надо сводить чтобы тогда чтобы тут была четвертая тут придется бы конечно а нет стоп не а
не нормально нормально да да да так чтобы один чтобы как бы 11 на вот этот лагерь на вот это
умещалось вот в это и оно умещается еще раз потому ну давай посчитаем а какая у нас глубина всего
значит глубина у нас получается логарифом по основанию логарифом в степени 1 пятое
логарифом в квадрате это что такое это логарифом двоичный логарифом в квадрате
n поделить на логарифом двоичный логарифом двоичный в степени 1 пятое понимаете да это на
самом деле равно 2 лог лог n поделить на 1 пятое лог лог н шлеп шлеп 10 тупо алгебра
нет нет логарифом лог квадрата логарифом x квадрата так это 2 лог x нет так что нет
степень сюда выносится правильно вот получается тут константа то есть тут как бы то есть конечно
да желательно да начинается какого-то n заметим что действительно 11 вот этих неправосудно там
это не более чем вот столько да поэтому там начинается что видимо реально это начинает
работать до прием больше чем 2 в степени 20 степени 12 там какие-таки числа иногда употребляются
ну а при меньших n все константа да ну в данном случае да но там просто где-то употребляйте
штамп же отдельная песня как же работает собственно сам кусип вот скажем так видимо
будет время желаний силы может быть мы один там четыре с половиной часа на это потратим и то
не уверен что уложимся вот ну вот то есть я поэтому честно скажу поэтому я не уверен то есть
как бы шоку хип пойдет у нас программа но вот эта технология как бы она достаточно стандартно
поэтому вот это хочется вот так что ладно так что в следующий раз видим будет чем-нибудь
полегче да поэтому например метод четырех русских а на этом все
