Сегодня будет некоторая теоретическая лекция опять на примере того, что это такое,
как это работает, для чего это нужно, почему это важно и что вы с этим можете делать.
Как вы думаете, почему называется амортизационный анализ?
Чего? Что? Для чего? Есть какие-нибудь идеи?
Квиксорт оценивается. Квиксорт оценивается амортизационно.
Что еще раз среднее?
То есть это среднее время работы. Ну типа.
Хорошо, но это не совсем правда.
Смотрите, на самом деле амортизационный анализ работает для некоторых вещей и
чаще всего он связан с оценкой конкретной операции. Квиксорт не является такой глобальной операцией
по факту. Вы можете посмотреть, за сколько он в среднем работает и что он делает,
но это скорее оценка именно конкретно какой-то операции.
Да, в сортировках, то есть мы можем сказать, что у нас может то выполняться, то не выполняться,
тот или иной И, грубо говоря. У нас количество свопов от этого будет меняться, значит и время
будет меняться. Да, это можно смотреть, но опять же здесь вопрос скорее про то,
за сколько работает именно какая-то операция. А для начала ведем некоторые определения,
которые нам нужны, а дальше поймем, что это все значит. Смотрите, нет ревиальный процесс, момент.
Давайте еще попробуем левое окошко закрыть.
Я попал, отлично. Короче, какие у нас есть здесь определения? Первое, что нам нужно знать об
аморитетонном анализе. Ну, предположим, у нас есть какие-то операции. У один, у НТ есть такие операции,
мы с ними пытаемся как-то работать и пытаемся их как-то оценивать и понимать, что там происходит.
Вот здесь у меня индекс поехал, но это неважно. Пусть реальное время работы каждой операции равно Т1,
и так далее, ТН. И что будет, если мы нарисуем это на каком-нибудь таком вот графике? Предположим,
у нас есть вот это время работы, а вот это номер нашей операции. Я тебе чуть поменьше это сделаю.
Вот. А к чему все это может приводить? Это может приводить к следующим интересным вещам. Пусть у меня
там первая операция занимает всего два действия. Два каких-то вот таких вот тривиальных,
фундаментальных действия, то есть две единицы чего-то. Ну, тиков, времени, как хотите можете
назвать. А другая операция может занимать чуть побольше. Третья вообще очень много, четвертая мало,
потом еще что-то большое, потом опять мало, потом еще меньше, а потом опять большое, и так далее.
Вот это реальное время работы. Это не прикольно оценивать, не интересно с этим работать. Почему?
Потому что это каждый раз зависит от каких-то условий, от чего-то, что произошло, от чего-то,
что нам нужно будет в конкретном времени оценить. И мы не хотим этого делать. Почему? По очень простой
причине. Потому что какая-то операция может повлиять за собой другую операцию, какая-то может
зависеть от предыдущих операций, что-то может происходить. И это оценивается очень нетривиально. И
общее время работы какое? Ну, это вот все, что вот тут вот так вот. Я сейчас повыделяю. Вот. К чему мы все
это хотим свести? Мы хотим свести это к какому-то новому амортизационному времени. Вот это ТИТ со
звездочкой. Это и есть то самое амортизационное время. Я просто буду пытаться сделать так,
что у меня все будет плюс-минус выровнено. Максимум какие-нибудь небольшие ямочки есть или там
вот такие выбенки. Но в итоге я пытаюсь это все выровнять между собой. И у меня получается такое
среднее время работы одной операции. То есть я беру и раскидываю это на все. И вот это все,
это суммарное время, это Т звездочка. То есть амортизационное время работы алгоритма. А вот
это суммарное время работы нашего алгоритма реальная. И мы для того, чтобы оценивать хоть как-то
с помощью больших и так далее, говорим, что вот эта Т со звездочкой, она должна быть больше, чем наша Т.
Заметьте, что амортизационно не означает, что они все одинаковые. Да, мы пытаемся свести к какому-то
такому одинаковому конструкту, но в том суть, что мы здесь пытаемся это сделать не обязательно
на сто процентов. Понятно? То есть здесь мы можем работать амортизационно как хотим. Есть пока к этому
вопросу. Вот, а надо на семинарах больше сидеть. Короче, в действительности, смотрите, у нас есть
реальное время работы. Вот Т1, к примеру, работает там за два каких-то такта. Т2 работает, не знаю,
там за четыре. Т3 за десять. Т4 опять за два и так далее. Вот это неудобно понимать и оценивать каким-то
образом. Я хочу все это свести так, чтобы оно было все плюс-минус равномерно. Я пытаюсь его оценить,
чтобы суммарное время вот этих времен, сумму мы возьмем вот этого всего, оно равнялось вот примерной
сумме вот этого, но было больше, потому что благодаря тому, что оно будет больше,
оно всегда позволит нам с этим работать. Понятно? Вот. Это не совсем правда, потому что мы очень
часто хотим оценить время работы одной операции. Тебе все равно придется понять вот этот столбик,
почему он равен? Понятно? То есть ты точно знаешь, что Т и Т звездочка, это равно там Т, ну грубо говоря,
разделить на какой-нибудь Н. То есть у тебя Н операции, у тебя есть Т, вот Т со звездочкой только,
прошу прощения. Ну вот среднее, грубо говоря, вот эморфиционное время, оно такое. Понятно? Да.
У нас есть четкое количество действий, грубо говоря, целое всегда. Правильно? Представь,
что у себя нечетное количество, а здесь четное количество операций. Ну не знаю, операции 10,
суммарное время их 91. Ну где-то же, значит, что-то будет чуть выше. Нет. Это важный момент здесь. Да.
Это важная информация. Почему? Потому что вы чаще всего, в каком случае вы эморфиационный
анализ применяете, в случае какого-то дисбаланса с точки зрения операции. Мы сегодня рассмотрим
с вами несколько структур данных на то, что где у нас это не работает. Вы дальше с ней встретитесь,
и кто-то из вас писал, что вектор же можно использовать. Вектор, он работает за ввод единички только
эморфиционно. Не работает всегда за ввод единички. Добавление элементов, к примеру. Это тоже отдельно
доказывает, это тоже отдельно работает. И нам важно, во сколько мы, в принципе, получаем этот ответ.
Если у нас было одно расширение, изменение, еще что-то, которое глобально повело то, что у нас
время резко вскочило, а потом опять очень долго идет маленьким временем, то нам интересно понять,
вот оно повлияет настолько сильно, что у нас будут проблемы с точки зрения времени. То есть,
не знаю, элемент мы добавляем за у от логарифма, за у от н или за у от единиц. Вот это важная для
нас информация. Потому что мы никогда не работаем с одной конкретной операцией. Мы работаем с каким-то
количеством операций. Вот и все. Поэтому здесь, да, мы можем терять информацию о конкретной операции,
но мы можем предполагать, даже когда это было. Но это не будет проблемой для нас. Еще есть вопросы?
Теперь все понятно. Ну хорошо, посмотрим, как вам все понятно. Смотрите. Ну вот, графички я вам
порисовал, сделал. То, вообще, из этого можно сделать. То есть, нам нужно как-то вот вычленить вот эти
тейты со звездочкой всегда и как-то с ними работать. Вообще, самые популярные методы амортизованного
анализа это следующее. Это метод усреднения, бухгалтерский метод, банковский метод, метод,
не знаю, там, бухучета, всегда по-разному называют. Вот, почувствуем сегодня себя немножко бухгалтерами.
Да, посмотрите, я про все вам расскажу. Вот, и существует еще метод потенциала. Мы с вами сегодня будем
рассматривать каждый из этих методов, но первое, для чего мы это вообще будем оценивать, в каком случае.
И мы с вами хотим поработать со следующей структурой данных. Структура данных — это очередь
на двух стеках. Встречали такое? Кто-то да, кто-то нет. Давайте с вами подумаем, как нам с помощью
стеков реализовать очередь. Для этого, ой, да, все правильно. Как с помощью стеков можно это сделать?
У нас есть два каких-то стека, и мы как-то будем перекладывать элементики друг из дружки,
чтобы у нас получилось это в виде очереди. То есть, мы с вами помним, что стек по какому правилу работает?
Ли-фо. Откуда фи-фо? Это в очереди правильно. Вот, нам нужно из-за этого принципа перейти сюда
с помощью некоторых каких-то конструкций того, что у нас происходит. У вас здесь расписано. Давайте
порисуем. Рисовать всегда полезно и интересно. Предположим, у нас есть два стека. У нас есть
стек ау, у нас есть стек ин. И представим что-то в виде очереди. Я утверждаю следующее. Я буду
класть элементы, то есть, пушить в свою очередь какую-то кью, а я их буду просто класть в наш стек ин.
Предположим, что я положил сюда один, два, три. С точки зрения очереди это будет как выглядеть? Если
я добавил сначала один, потом два, потом три. Предположим, очередь выходит сюда, входит сюда.
Три, два, один. Они приходят отсюда, уходят отсюда. Это первый нюанс. Второй нюанс. Предположим,
что я хочу из своей очереди убрать элементы. Для того, чтобы убрать, я должен убрать единичку,
правильно? В стеке я не могу докопаться до этой единички. Согласны? Что в этом случае делаю? Я
в этом случае все элементы переношу в стек ау. Я отсюда забираю, сюда кладу. У меня здесь поп,
сюда пуш. Получаю здесь три, два, один. И отсюда эти элементы уходят. Получается вот такая вот картина.
И после того, как я пытаюсь удалить элемент, я просто удаляю его из стека ау. Получается,
что я удаляю единичку. Теперь я отсюда удалил эту единичку. У меня эта очередь сдвинулась.
Лучше я вот так вот сделаю. Один, два, три. Тут еще место в очереди есть. Я удалил эту единичку.
Теперь я хочу запушить элемент. Пушить я всегда буду, ну, ставить в очередь, я всегда буду в
стек in. Я поставлю сюда четыре. И четыре у меня встает как бы в мою очередь. Теперь предположим,
что я хочу удалить элемент. Какой мне удалить надо элемент? Из ау, то есть два. Вот этот элемент я
удаляю, я удаляю опять из этого стека. То есть смотрите, пока стек ау не пуст, я удаляю элементы
просто из него. Как только стек out пуст, я переношу все элементы из in в стек out и оттуда удаляю.
Понятно? Понятно, как это реализовано? Всем? Точно? Да.
Почему нам нужно удалить? Еще раз, мы делаем очередь, мы не делаем себе массив, мы делаем очередь.
Мы четыре удалим только после того, как все удалим впереди. Еще есть вопросы?
Неужели все понятно? Чудеса? Можно.
Да, очередь очень можно быстро написать. Когда я обычно спрашиваю на экзамене,
как, на чем написать очередь, мне люди говорят, ну, на двухшестном списке, они на одна связана.
А стек можно на одна связана написать. В этом случае все ломаются. И мы посмотрим с вами сейчас,
за сколько это все работает. Предположим, что у вас написан только стек. Вы с этим как-то живете.
Окей? А это на самом деле очень удобная конструкция в изряд. Какое ваше предположение, за сколько это работает?
А? Ну вот представьте, у нас есть n элементов в очереди, мы n элементов вставляем, n элементов
убираем. Вот наша, по сути, операция здесь является и вставкой, и удалением.
За what n? Почему? Это другой вопрос. Грустная история. Ну ничего, значит, мы сейчас рассмотрим это еще раз.
Действительности да. Смотрите, вот это перенос элементов с одного стека на другой занимает много времени,
согласны? Но в то же время, если я удаляю просто элементы и у меня out не пуст, тогда это происходит быстро,
за what единички. Я предполагаю, что push и pop это такие вот фундаментальные вещи, фундаментальные
операции, и они работают за единицу времени. Окей? Ну типа, это не сложно. Так вот, с одной стороны в одном
случае удаление, оно сработает всего за одну операцию, ой, за один тик такой, а в другом случае за
количество элементов в n. Вот это тот самый дисбаланс, который непонятно, как решать с точки зрения
обычного анализа алгоритмов, как мы с вами сделали. То есть, если я скажу, что работает за what n,
это не круто, это непонятно, потому что в действительности оно не всегда так работает, и мы хотим понять,
за сколько это будет действительно работать. Поэтому здесь нам на помощь приходит тот самый
амортизационный анализ. И на примере очереди на двух стэках мы с вами будем сейчас разбираться с тем,
что здесь есть, как это делать. На примере всех трех амортизационных анализов, его методов,
которые я вам говорил. Поехали. Вот если мы говорим с точки зрения вот такого некоторого обобщения,
то то, что мы сейчас с вами проговорили, это вот здесь вот и описано. То есть, по факту вот
интуитивно мы видим, вот когда вы понимаете, что нужен амортизационный анализ, вы интуитивно
видите, что у вас после какой-то одной тяжелой операции есть много маленьких и легких. Значит,
здесь что-то не так. Значит, здесь есть какая-то хитрость, и почему-то это было сделано. И с этим
необходимо поработать. И первый метод, с которым мы с вами знакомимся, это метод усреднения. Метод
усреднения очень прост в своем представлении. Вы просто считаете количество действий, которые
у вас выполняется на всем промежутке действий. Получается таким образом амортизационное время и
говорите, что в среднем, то есть вот это ТИТ звездочка амортизационное время одной операции
равно Т звездочка разделить наверное. Понятно? Вот это в этом заключается метод усреднения.
Метод усреднения очень прост, но не всегда работает. Это не означает, что мы с помощью
него можем посчитать абсолютно все. Нет, к сожалению, у нас будут здесь проблемы. Вот, и мы с вами
с этим столкнемся на следующей лекции, когда будем говорить про новое бинарное дерево поиска. Но,
пока здесь этим можно еще посчитать. Это очень часто применяется в каких-то достаточно простых
структурах данных. И очередь на двух стэках одним из таких является. Смотрите, для простоты я буду
говорить, что очередь в начале и в конце является пустой. То есть я в начале в нее что-то вставляю,
она была пустой, что-то какие-то элементы есть, и в конце обязательно все элементы удалю. Вот я буду
пока говорить в таком обобщении. Это просто упрощается с точки зрения подсчета. Поехали
с вами дальше. Первое, добавление элементов. Добавление элементов требует всего лишь один
push. Вот сюда. Согласны? Вот. То есть вот push это происходит вот так. Мы делаем этот push и
если я буду вставлять n элементов, то есть я говорю, у меня есть n элементы, которые вставляются в мою
очередь. Я вставляю n элементов, значит у меня получается n умножить на единичку, n вот таких
вот простейших операций будет сделано. Согласны? Теперь поехали с вами в удаление. С точки зрения
удаления. Когда мы с вами просто берем и удаляем элемент из out, это вот один раз происходит,
и больше этого элемента у нас не появляется. Поэтому в этом случае мы говорим, что каждый
элемент так или иначе был будет удален из out. Согласны? Поэтому мы говорим, что это количество
операций, которая там займет, количество вот этих простых тиков, это будет 1 умножить на n. То есть n
попов из out будет. Окей? Теперь давайте с вами рассуждать. Представим следующую картину. У меня
вот есть stack out, а есть stack in. Я вначале перебрасываю вот сюда, а как я там обозначал, это n и t. Хорошо.
Вот у меня есть n и t элементов, вот я их перебрасываю сюда, они у меня становятся. Потом я начинаю еще
раз удалять все эти элементы, в это время там что-то вставлялось, и у меня появляется n и
плюс первое, к примеру, элементы. И я опять их перебрасываю. Согласны, что каждая переброска
одного элементика, это два действия. Отсюда pop, отсюда push. Правда? А теперь мне нужно понять,
чему равна сумма всех этих n? Так как я вставляю суммарно n элементов, то у меня всегда вот эта
переброска элементов, я должен буду удалить все n элементы, то вот эта переброска элементов
будет происходить вот по сумме n и t, а сумма n и t это равно суммарно n. Потому что все элементы
побывали здесь и сюда тоже перешли, и каждый это сделал единожды. Окей? Понятно?
Мне не нравятся ваши потухшие лица. Это просто вытащить элементик.
Тащить элементику не надо, он и так бедный. Еще раз, добавление вот было,
мы с вами только что говорили про это. Добавить это 1 умножить на n. Тоже n операция нам требуется.
Подожди, там у меня написано именно удаление элементов, вот это является пересчетом удаления,
только лишь удаление. Вот, то есть смотрите, я перетаскиваю n элементов отсюда сюда и для того,
чтобы их перетащить, я сначала удаляю вот отсюда, потом вставляю вот сюда, поэтому это умножается
еще и на 2. Вот, благодаря этому мы с вами получаем, что у нас удаление, друзья, удаление суммарно
занимает 3n простых операций, простейших. Согласны? Понятно? Нет, мы не заполняем, вот это только лишь
удаление. Удаление всех n элементов из очереди займет 3n действий. Нет, из нашей очереди, из очереди.
Очередь это равно вот этой композиции. Смотри, вначале все пусто, потом я кидаю элементы сюда,
я и могу удалять и вставлять элементы в любой момент времени, абсолютно в любой. Я вставляю сюда
элементы и я говорю, что каждый элемент вставляется всего лишь один раз и все, что нужно для вставления,
это сделать push. Поэтому мне нужны n операции простых, ну типа n таких вот действий, простейших,
для того, чтобы вставить элементы. Получается n вещей. Теперь удаление элементов. Что происходит в
момент удаления элементов? В момент удаления элементов я должен перетащить часть, если у меня
out пустой, то перетащить часть элементов отсюда сюда, а это два раза, то есть отсюда pop делаю,
сюда push этого элемента, а потом отсюда еще удалить. Получается три действия таких. Два действия
на перенос, одно действие на удаление. Сколько я переношу элементов? Ну предположим, что их
перекидываю периодически. Каждый раз я перекидываю, ну вот каждый элемент, который перебрасывается,
он перебрасывается едино, он не может переброситься потом еще раз. Согласен? Этому на самом деле вот
с переброской у нас будет делаться следующее. Вот у нас есть какое-то нытое элементы, к примеру. Нам
нужно их перебросить. Мы их перебрасываем сюда. Это займет два нытох простых операций. Потом я
беру, удаляю из out, удаляю из out это тоже будет нытое. Согласен? Потом я беру, у меня здесь уже что-то
вставилось, еще раз перебрасываю, еще раз что-то происходит и так далее. Поэтому удаление у меня
занимает 3n таких операций. То есть удаление и вставка мы с вами посмотрели. Суммарно они будут
стоить 4n для моей очереди. Ой, сейчас будет смешной косяк, 4n делить внутри. Прошу прощения. Такое тоже
бывает. Вспоминаю себя на олимпиадах. Неправда. Мы добавляем, удаляем, вставляем, удаляем. Нет,
нет, смотрите. Я сказал, что у меня есть всего лишь элементарные операции push и pop. Еще раз,
у меня есть элементарные операции. Я не смотрю, как реализован стэк. Стэк можно вообще на этом
реализовать. Кстати, еще очень важный момент. К примеру, почему очередь иногда можно сделать
на стэке? Потому что очередь у вас всегда нужен односвязанный список, а стэк можно представить
в виде расширяющегося массива. Подумайте об этом. Ну типа, вы просто кладете в массив и удаляете
с конца. Удалять с конца за 1 можно в любом массиве. Ставить в конец тоже за 1. Но можете взять
очень большой массив и просто мусор хранить и вот понимать, где вы находитесь сейчас. Вот вам
применение вот этого чуда. Очень полезно. Да. Будет, но еще раз, если вы сделаете его,
к примеру, на 10 тысяч или на 100 тысяч элементов, ничего критического не произойдет, если это инты.
Да, такое возможно. Никто не спорит. Никто не говорит, что это мир идеален. Вот, но что поделать?
Вот, поэтому, да, ну там 4, естественно. Поэтому в действительности амортизационное время работы
с одним элементом и вставкой его и удалением это 4. Если хотите, можете разбить, что амортизационное
время вставки это единичка, амортизационное время удаления это 3. Три таких вот простейших действия.
И это хорошо. То есть мы говорим, что амортизационный это работает за у от единички. Нет здесь никакого у от н.
Окей, понятно. Вопросы к этому есть? Еще раз. Перекладывание за счет чего работает? За счет того,
что мы удаляем отсюда, вставляем сюда. Это два. Окей, вопросы есть? Вопросов нет. Хорошо.
Пересмотрите следующее. Следующий это банковский метод. В самом деле, банковский метод периодически
определяют по-разному. Вы можете самостоятельно, мы с вами посмотрим и один случай, и второй случай,
как здесь что происходит. Банковский метод представляет собой следующее. Представьте,
что вы бухгалтер и работаете с монетками. Ну, например, с рублями. Не знаю, у вас по одному рублю,
у нас инфляция и так типа хорошая. Можете с центом и так же играться. Короче, плюс-минус одно и
тоже будет. Короче, представьте, у вас монетка. Рубль у вас есть, вы с ним как раз-таки что-то
делаете. И вот вы за каждую простейшую операцию должны будете компьютером. То есть у вас компьютер
такой, вы могате. Либо он будет что-то делать, либо не будет. Причем, пока у вас есть деньги,
он делать что-то будет. Но как только они у вас закончатся, ваша дружба закончилась,
все, к сожалению, у вас не будет больше компьютера, он не будет ничего выполнять. То есть вы не можете
никогда вылезать в долги. Запомните это на рабоучение. А суть банковского метода в следующем. У
вас есть какой-то мешочек с монетками, и вы их можете раздать. Либо какой-то конкретной операции
давать какое-то определенное количество монеток, либо элементам, которые есть, они будут тратить
эти монеты. Вот вы можете исходить из этого. И тогда в этом случае вот то количество монет,
которое вы отдали, является тем самым амортизационным общим временем. Причем каждый элемент в каждый
момент времени или суммарно, вы не должны действительно залезать в отрицательное число.
Нельзя быть должником компьютера. Это машина, а вы всего лишь кожаный мешок. Поэтому, к сожалению,
здесь ничего не будет работать. Только за деньги, к сожалению. Таким образом, в этом случае,
когда у нас есть тот самый мешочек, с которым мы с вами работаем, мы и начинаем с ним что-то
делать. И так мы сможем оценить время необходимое нашей работе. В данном случае лучше всего раздать
каждому из элементиков какое-то количество монеток. Вот в этом случае можно это сделать.
А предположим, что мы каждому элементику дадим четыре монетки.
Ну мы живем в цифровом мире. Представь, что у тебя есть биткоин, и ты богатая. Вот,
ну все. К сожалению, все. Ну в действительности вот так. Просто представить. Да. Изначально мы
просто это придумываем на самом деле. То есть мы с помощью этого пытаемся оценить. И вот грубо
говоря, если я возьму и дам три монеты мне, и я попытаюсь их как-то раздать, как-то оптимизировать,
у меня ничего не получится. Я буду в долгах, а значит, это не работает. Вот. Мы здесь с вами
работаем с точки зрения времени. Вот эта монетка обозначает одно время, грубо говоря. И каждая
операция будет стоить какое-то время для нас. По-хорошему. То есть каждая операция стоит ту самую
монетку. Вот монетка равно время. Время, деньги, запомнили? Нет, нет, нет, нет, нет. Вы можете
просто прикинуть, как вы можете это раздать и как с этим работать. Вот здесь я понимаю,
анализируя просто, типа, саму структуру данных, что на push мне нужно, ну на вставку элемента мне
нужно одна монетка. На то, чтобы убрать элемент, мне понадобится точно три монетки. И вот если я
раздам четыре монетки каждому из элементов в своей очереди, то есть, грубо говоря, в push я возьму
и еще дам три, заплачу сам, и еще дам три монетки элемента, тогда он всегда сможет оттуда уйти с
этой очереди. Вот такая адская карусель получается. Поэтому как-то так. И вот здесь сама суть в том,
что, типа, мы раздали эти монетки, получили что-то, и если мы потратили 4 монеток, значит, в среднем одна
операция стоила четыре. Понятно? Отличается от подхода. В среднем, я считаю количество действий,
получаю сумму и уже тут смотрю. Здесь у меня есть какое-то определенное количество денег,
и я от него отталкиваюсь. Да. Это твоя интуиция должна быть. В этом действительности есть свой
шарм этого всего. То есть, да, вы откадываете от того, сколько вам монеток нужно. Вы можете
поанализировать код, понять, что с ним делать. То, что у вас существует метод усреднения, равно, что он
всегда очень полезен, очень интересен. Мы с вами посмотрим на более сложные структуры данных, что с
ним происходит, окей? Могу пять монеток всем раздать. Элементы идут радостно с одной монеткой. Могу,
могу. Мне главное оценить вот само качество, количество. Вот. Поэтому здесь в действительности
с банковским методом все просто. Вот именно с точки зрения стека на двух, ой, господи,
очереди на двух стеках. Самое интересное всегда происходит в методе потенциалов. Вот здесь ваша
интуиция должна работать на полную катушку. Что здесь подразумевается? Смотрите. Ведем некоторые
потенциал. Потенциал из состояния нашего какого-то в не отрицательные целые числа. Он может быть
нулевой, но он всегда не отрицательный. Это первый важный момент. И я скажу, что амортизационная
стоимость одного действия будет равна реальному количеству действий, которое у меня было,
плюс потенциал, который был, плюс разность потенциалов, которая изменилась в этот момент.
Понятно, что я сейчас сделал? Непонятно. Грустная история. Смотрите. А, предположим,
ну вот я говорю, что ТИТ со звёздочкой равно ТИТ плюс ФИ СИТОВА минус ФИ СИ минус первое.
Что такое СИТ? Это состояние какой-то моей структуры. Что такое может быть состояние?
Состояние просто сколько элементов в структуре? Сколько, не знаю, элементов в левом стыке? Сколько
элементов в массиве? Может быть логарифм от количества элементов и так далее. То есть
вот этот потенциал, он должен как-то из состояния возвращать чиселка. Как это вы можете делать?
Это любое ваше представление. Главное, что должно быть здесь, что каждый потенциал не отрицателен. То
есть для любого И ФИ СИТОВА больше либо равно нуля и первое, что у вас есть, что ФИ в нулевом
состоянии равно нулю. Вот это является потенциал. Вы же физики. Кто тебе такое сказал?
Ещё раз. Нулевой равен нулю. Хорошо. Первый может быть равен трём, а второй может быть равен нулю или один.
Ну СНОЛЬ это состояние в самом начале. Начальное самое состояние. Ну ещё раз у меня может быть
сначала. Ну представь, что я убрал элементы. У меня сумма элементов типа в моей очереди. Я убрал
элементы. У меня состояние-то уменьшилось. И ФИ уменьшилось. У меня нет возрастания здесь.
Ещё. Первое точно возрастёт или не убывает? Ну ещё раз. У тебя может быть вот такой график.
Ну да. Ну у тебя иначе вот это не будет выполнено. В начале вниз мы не пойдём,
но потом мы можем ходить. Вот такой график спокойно может быть. Да.
ТИТ и ТИТ? ТИТ и СИТ, конечно, связаны. Да, смотрите. Для того, чтобы перейти с СИ-1 в СИТ,
я должен был потратить какое-то количество действий, какое-то количество времени. Вот этот
переход занял у меня таитое время. Это реальное время, которое заняло. Понятно? Всё, вопрос.
Да. Потенциал. Потенциал – это просто функция из состояния внеотритательные числа, обладающая тем,
что первое у нас нулевое. Ну вот в данном случае я буду говорить об этом. И для любого он
не отрицательный. Всё, это функция. А я говорю здесь выполняется равенство – это уже дальше.
Потенциал – это просто функция. Выполняется равенство – это я говорю, что у меня будет такая
мартизационная стоимость ТИТ-го звёздочка. Для чего я это делаю? Смотрите, важно понять,
для чего я это делаю. Давайте смотреть. Предположим, что СИТ-я звёздочка равно ТИТ плюс ИСИТ минус ФИ
от СИ-1. Да? Согласны? Вопрос следующий. Чему равно Т звёздочка? Оно равно сумме СИТ-я звёздочка.
Согласны? И оно равно сумме, получается, стейтах. Да? А потом здесь у меня чё начинается? Плюс ФИ от С1
минус ФИ от С0, плюс ФИ от С2 минус ФИ от С1 и так далее. Закончится это всё, что будет плюс ФИ от СМТ
минус ФИ от СН-1. Согласны? Это получается, что сумма стейтах плюс ФИ от СНТ минус ФИ от С0. Вот это
у меня ноль. Согласны? Вот это у меня не отрицательное. Правда? Получается, что всё это больше либо равно,
чем Т, потому что вот это это Т. Поняли, в чём суть, в чём фичает этого всего? Вот именно в этом.
Зачем я говорю, что у меня ФИ С0 должно быть нулевым? Потому что вот этот минус, он не должен
мне случайно убить. Это так, чтобы Т со звёздочкой было меньше, чем Т. Мне этого не нужно. Мне нужно
сказать, что у меня амортизационное время должно быть всегда больше, чем Т. А вот это может быть
какое-то больше либо равно нуля. Может быть ноль, может быть нет. Понятно? Почему это называется
метапотенциалов? Ну я думаю, вы с потенциальными полями, по типу, ну со школы ещё знакомые, по типу
вот силопритяжения. Вы неважно, по какому пути пройдёте, у вас работа одинакова. Вот это оттуда же.
Просто дискретно. Вопросы? Сейчас мы всё будем смотреть. Подождите, сначала теоретическую часть.
У вас могут быть возникать проблемы с тем, что у вас что-то будет не работать. Важный момент здесь
какой? Мне надо подобрать такой потенциал, что все ты и ты одинаковы почти с точки зрения, ну типа,
не знаю, симпатически, можно сказать. Ну то есть этот там работает за один, этот за два, этот за три,
но это нормально. Тогда в этом случае ты хотя бы понимаешь, чему равна сумма Т равна, понимаешь? Вот.
А вот всего остального здесь уже начинается интрига. Если же ты потенциалы ведёшь такие,
что у тебя ты и ты будут различаться, то тебе это не даст ровным счётом ничего. Почему? Потому что
я хочу сделать так, чтобы я написал, что Т со звёздочкой примерно равно ты и ты какая-нибудь
звёздочка, любая и ты, умножить на Н. Я хочу к этому свести. Я хочу убрать тот самый дисбаланс,
про который мы говорили с самого начала. Вот это перекидывание, чтобы у меня не было дисбаланса.
Функция Fee в смысле?
Примерно то же самое хотим. Мы хотим, чтобы вот это было одинаково. Но функция потенциала может
прям абсолютно. И мы с вами посмотрим на следующей лекции. Обычно после неё умирают. Не в прямом
смысле, а то мало ли ещё что-нибудь скажут. Но в действительности да, это всё сделано для того,
чтобы вот это мракетационное время работать. То есть весь фокус именно вот в этом. И всё.
Понятно? А теперь предложить потенциал для очереды на двух стэков.
Каком-то в каком? Почему? Это было пальцем в небо или как? Интуиция почти верна, но не
совсем. Разность тоже не сильно нам поможет. Разность всегда будет при удалении, к примеру,
единичка. Ин плюс три аут. Может быть, что-то и получится на самом деле. Я не думал. Но в
вам важно понимать, как подойти к выбору потенциалов. А выбор потенциалов должен
заключаться в следующем. Когда у вас есть какая-то дешёвая операция, разность потенциалов должна
быть дешёвая. Потому что у вас вот это время ТИТ, оно дешёвое. А значит, вот эта разница должна
не быть дорогой. Это первое. Второе. Когда вот эта операция дорогая, вот эта разность потенциалов
должна быть скорее отрицательна для того, чтобы выровнять что-то дешёвое. Понятно?
Да, это правда. Только двойное количество элементов. Потому что у нас время, ну вот
типа реальное время работы. Это же нужно сделать поп и сделать push. Два раза количество. Можем. У
тебя получится, что время работы будет h. Смотри. Давайте сейчас я попишу, потом я раскрою все карты.
Смотрите, все очень просто. Если вы говорите, что ваш phi от s этого равен количеству элементов
Предположим. Согласны? Вот мы это взяли. Предположим, что мы перекидываем элементы. Вот в моем а,
вот это пусть будет h какое-то. Я перекидываю эти элементы в alt. Тогда моя ТИТ звёздочка равно
Оно равно 2a плюс 1. Потому что я сделал поп отсюда h элементов, push сюда h элементов и pop верхнего
элемента. Согласны? А теперь разность потенциалов. Потенциал, который есть сейчас, так как я перекинул
все элементы, у меня ноль. Согласны? Ну у меня высота стокеин стала ноль. Я ж удалил элементы.
Подожди, я говорю phi s это. Я ещё не сделал minus phi s. И делаю минус. Phi s и минус первое. На
si минус первом шаге у меня h элементов лежало в моем стокеин. Согласны? Минус h. Смотри, у тебя
время работы это h плюс 1. Проблема. А вот если я возьму два на количество элементов и сделаю
минус два h, все будет хорошо. И в этом случае у меня будет здесь просто единичка. Осталось проверить
для других элементов, что это будет происходить так. Вот это удаление с перекидыванием. Что
будет происходить с удалением без перекидывания? С удалением без перекидывания все будет очень
просто. Я буду говорить, что ты звездочка, это равно. Если я удаляю элементы, у меня в аут что-то
есть, то мне не важно удалил я элементы из аут или нет. У меня потенциал остался такой же. Согласны?
Как был h, так и остался. Поэтому я говорю, что это 1, потому что я сделал поп из аута. Плюс h
минус h. Это 1. Ну и последнее, что у меня осталось, это t и t со звездочкой в случае вставки элемента.
В случае вставки элемента я говорю, что 1 тик трачу на push, правильно? Стало у меня количество элементов
h, ну или h плюс 1, как хотите. Тут 2 на h плюс 1, можно так делать. Минус 2 h, это равно 3. Смотрите,
1, 1, 3. Они все в силке, они никак не зависят от n, они ни от чего не зависят. Значит,
у меня вот в принципе, вот если я возьму все это t и t, я вот этого знаю, что там будет 3,
вот этого всего, там n, суммарно. Ну у меня получится то же самое. Будет 4n,
у меня будет 4 просто. То есть среднее время работы операции будет такое же. Вот и все, да.
Фив всегда постоянно, иначе ты не можешь их… Ты можешь пытаться подбирать ее, как хочешь.
Главное, чтобы в итоге у тебя была она одна, была определенная и ко всему подходила.
Чего? Я не понял вопроса. Что значит переменная зависит от h?
Типа ты коэффициенты пытаешься подобрать. Ну я только что это делал. Я вот
первое, что рассмотрел, мне сказали, пусть будет это h. Просто h. Мы рассмотрели здесь и получили,
что у нас здесь будет h плюс 1. И мы поняли, что это нам не подходит. Поэтому я такой, а давай я на 2
домножу. Домножу. Получил здесь 1. Осталось проверить для всех остальных. Для всех остальных это
тоже подходит. Для всех остальных это тоже подходит. Я нашел потенциал. Ну еще раз, вы подбираете
потенциал, вот здесь вы идете прям вообще по наичу. Нет такого, что вы такие типа, блин, все, я знаю,
как выбирать потенциалы. Почти, наверное, нет. Это всегда вот просто наработка, интуиция,
понимание того, как это происходит. Главная суть потенциалов, что вот благодаря тому, что мы с вами
там получили, мы говорим о том, что амортизационное время у нас корректно работает. Понятно? Вот.
Если мы все времена просуммируем. Еще раз, нет, подождите. Нет. Вот это удаление, вот это тоже
удаление, друзья. Вы чего? Просто какие-то элементы удаляются с помощью, с помощью того,
что мы перебрасываем элементы. Какие-то элементы удаляются просто из-за ута. Но не может быть такое,
что элементы и так, и так удаляются. Он один раз удаляется. Вот, поэтому четыре суммарные.
Вот откуда вот это? Вот это, да? Смотрите, у вас есть 1 стэк, у вас есть 2 стэк. Вот это пустой,
вот это вот я считаю именно для вот этого случая, когда это пустой, а здесь аж элементы. Что я должен
сделать? Я должен сделать поп из аж элементов, а потом push. А последнее, так как я удаляю элементы,
то я должен сделать еще один поп. Вот, поэтому 2 аж плюс 1. Вот это? Это вставка. Когда я вставляю
элемент, я всегда вставляю свой стэк in. Согласен? Было аж элементов, стало аж плюс 1 элемент.
Я говорю, что вставка занимает одно время, 1 тик, в реальное время. Вот это и так. 2 аж плюс 1 — это
новый потенциал. Когда я обновил его, то есть я вставил этот элемент, у меня стало 2 на аж
плюс 1 потенциал. А 2 аж предыдущий, 2 аж-2 аж сокращается, получается 3. Еще вопрос. У меня
потенциал очень важный, очень нужный, не раз там пригодится. Для вектора пригодится,
для сплэй дерева пригодится. Но где вы его еще встретите потом? Очень удобная штука. Окей,
вопрос к этому есть? Видимо, нет. Но здесь вот написано примерно то же самое. Да,
вот не примерно, а то же самое. Ага. Вопросы есть? Вопросов, видимо, нет. Можно.
Еще раз, я могу реализовать стэк с помощью массива, очередь не могу.
Ну да, можно.
Усреднение не всегда считается, вообще не всегда. Вот мы с вами посмотрим, что это не работает в
сплэй дереве. Нормально вы не посчитаете. А банковский метод, он более такой игрушечный и
ну типа периодически с помощью него можно посчитать, это нет никаких проблем, можно это сделать.
Метод потенциал строго математичен. Каких? Каких возможностей я реализовываю стэк на массиве? Еще раз?
Ты не сможешь хранить разные типы значений в стэке? Кто тебе сказал?
Хорошо. Вы шаблоны уже прошли? Со структурами? Так, ну да, меня смущает. И делать имплейтные ноды нет,
тоже у вас не будет нормально это работать, потому что у вас должен один тот же тип указаться.
Ты всё пытаешься теперь сделать так, чтобы это не работало, но это работает. Это можно использовать.
Вот, то есть мы можем. Точное количество мы не получим. Амортизационное время еще раз,
это тоже это среднее, но у него может быть и снизу и сверху еще ограничения какие-то.
Мы получили среднее время. Мы никогда не получим точное,
потому что если мы говорим вообще про реальное время, то оно вот так скочет.
Что мы делали в прошлых методах? Мы делали, за сколько работает алгоритм, алгоритм, а не конкретная операция.
И рассматривали это асимпатически. Здесь я рассматриваю не асимпатически. Вот вообще не асимпатически.
Я рассматриваю конкретные n элементы. Понимаете, в чем вся проблема? Когда вы будете говорить про асимптотику,
асимптотика где начинает выполняться? У вас может быть какая-то вот такая вот функция,
а потом она вот так идет. Вот ее асимптотика там на 10 в 20 степени начинается. Асимптотика, асимптотика.
По сути своей да, но здесь в принципе мы к этому не пришли.
Потому что меня будет интересовать, за сколько я удаляю из очереди такой конфигурации. Потому что я то за n удаляю,
то нет. Я могу взять и ограничить только сверху от n сказать. Я хочу понять, как это работает с точки зрения вот такого элемента.
Точно ли вот то, что одна большая тяжелая операция, она перекрывается маленькими или нет?
Давайте с вами посмотрим еще на какую-нибудь интересную штуку. Например, счетчик, двоичный счетчик.
Двоичный счетчик очень прост. У нас есть массив S,K, ячейщик. Там хранятся нолики и единички. И все,
что есть у двоичного счетчика, это инкримент. Берем и увеличиваем чиселка, то есть на единичку.
И нам нужно перекидывать бит. За сколько работает инкримент? Амортизационно или в принципе, как вы думаете?
Так, а? Почему? Потому что я спрашиваю, что... Смотри, ну типа самое первое, самое грубое оценка это у от nk.
Потому что мы можем поменять в k-бит. Теперь мы рассмотрим опять три разных метода, которые есть, только мы будем это рассмотреть быстрее,
потому что, я надеюсь, вы поняли саму суть методов, окей? А первый метод это метод усреднения.
Когда мы говорим с вами, тут много слов написано, я специально написал, потому что это больше для вас почитать.
Я буду рассказывать это больше, окей? Вот, чтобы вы потом к экзамену или к семинару спокойно могли взять, открыть и прочитать.
А здесь мы будем говорить о следующем. Смотрите, как часто меняется первый бит, а нулевой? Он меняется каждые два раза.
Вот инкримент в начале был ноль, потом один, мы увеличиваем его, он меняется каждый раз. Согласны?
Второй бит как часто меняется? Инкримент. Мы раз сделали инкримент, он мог не поменяться, потом сделали два и он уже поменялся.
Каждый второй раз меняется второй бит. Потом мы говорим, что каждый четвертый раз меняется третий бит и так далее.
Понятно, что я имею в виду. То есть мы когда делаем инкримент, наше изменение одного бита какого-то будет сопровождаться,
выполняется только каждое n делить на какое-то количество раз, два в степени i.
Вот благодаря этому мы можем посчитать количество действий. Понятно, почему так происходит, я надеюсь. Правда? Нет?
Кто понимает, что происходит? Давайте так.
Кто не понимает и боится что-то спросить?
Смотрите, у нас число представлено в двоичной форме, в двоичной записи. Все, что делает двоичный счетчик, он берет и прибавляет единичку числу i.
И нам нужно взять и пересчитать это в массиве. Давайте порисуем.
Лучше задавайте вопросы, потому что потом вам с этим работать. Я знаю, как с этим работать, мне не сложно.
А вас не хочется подставлять. Смотрите, у нас есть какое число? 1, 0, 1, 1, 1, 0.
Все делает двоичный, вот это число x. И вот это вот, все это a, вот это i. Это и есть все двоичный счетчик.
И у меня все, что есть, это инкримент. То есть это x плюс 1.
Когда я сделаю один инкримент, у меня будет 1, 0, 1, 1, 1, 1, 1. Первый инкримент.
Мне нужно поменять всего один бит. То есть вот здесь всего одно действие.
Когда я сделаю еще один инкримент, я получу 1, 1, 0, 0, 0, 0. И здесь у меня поменяется, уже будет 6 действий.
Понятно? И мне интересно, за сколько работает инкримент амортизационный.
То есть вот это как раз пример того, когда у нас действия как-то вот так вот увеличиваются, увеличиваются, потом берут, уменьшаются, потом увеличиваются.
И так далее. Вот это вот разнобой как раз будет. Понятно?
И вот здесь может быть разное увеличение количества этих единичек.
Вот. И я говорю о том, что я точно уверен, что первый бит меняется n раз.
То есть вот я n раз делал инкримент, n раз менялся этот бит. Он менялся то на 0, то на единичку, то единичку, то на 0. Понятно?
Прям прибило вас, я смотрю. Вот если смотреть так в центр, то очень грустно выглядит эта картина.
По бокам ничего, не знаю. Настроение, какой-то радиус поражения.
Ну ладно. Так вот. Первый бит меняется n раз, второй бит меняется n пополам раз,
третий бит n на 3 раза. Ой, n на 4, прошу прощения. Этот n на 8 и так далее. Почему?
Потому что если у меня был здесь 0 и я сделал инкримент, вот этот бит не меняется.
А вот если была единичка и я сделал плюс один, то этот бит поменяется. То есть вот это n пополам.
Аналогично дальше n на 4 и так далее. Понятно? Вот. И с этим мы всегда работаем. Да!
Да, извиняюсь, там это проблема. Да, два в степени этого логорики. Да, вот.
Но в общем суть такая, что мы с вами берем это и сделаем. И когда мы суммируем все это,
мы с вами получаем геометрию. Какую? Правильную геометрическую прогрессию.
Это верно. Вот у нас один плюс одна вторая, плюс одна четвертая и так далее.
Возможно вы видели мем, что заходит математик в бар и вот это вот все. Вот примерно то же самое.
Ну короче, здесь получим, что у нас будет два n действий. После n инкриментов у нас будет два n действий.
Оно ограничено сверху двумя n, когда мы делаем бесконечную эту прогрессию.
Поэтому мы говорим, что у нас в принципе в среднем амортизационно работа инкримента это два действия.
То есть у от единички. То есть инкримент здесь работает за у от единицы.
Могли бы вы когда-нибудь об этом подумать вообще?
Я спрошу обязательно на экзамен. Именно про это.
В действительности да. То есть смотрите, вот с точки зрения подсчета здесь подсчет не тривиальный.
Нужно было понять как это делать. Согласны?
Давайте посмотрим на банковский мет. Что там происходит?
Не скажу, что вам он больше понравится. Здесь тоже много-много слов.
Я буду вам все это пояснять еще раз.
Это вот типа это часть для того, чтобы был такой маленький конспектик у вас по итогу.
Это такая дополнительная часть для вас.
Здесь подразумевается следующее.
Ой, у меня тут это поехало, но не суть важна.
Смотрите, стоимость каждой операции, стоимость каждой записи.
Это один какой-то рубль, одна монетка.
Я, как владелец мешочка с деньгами, буду теперь выдавать не элементы, а операции.
Денюшки.
Инкременту дам два рубля за записи денег.
А удалению ноль.
Я люблю больше увеличения на единицу, с нуля на единицу перезаписывать, чем просто нулевой делать и чайку.
Прям вообще все поехало. Прошу прощения, я пофикшиваю.
Что мы будем делать? Смотрите, при каждой установке бита в единичку,
то есть каждый раз, когда я делаю бит, который был нулевым единицей,
я трачу один рубль на то, чтобы поменять этот бит.
И плюсом к этому всему, я прикрепляю к рассматриваемому биту еще один рубль.
Типа рубль в уме.
То есть мой инкремент тратит два рубля.
Один на то, чтобы вставить, второй отдает вот этому биту.
И каждый раз над каждой единичкой у меня будет рублик.
Согласны?
А теперь, когда я еще раз увеличиваю, у меня становится ноль,
я же должен тоже откуда-то взять деньги на то, чтобы поменять вот этот ноль.
Согласны?
Тогда в этом случае я беру и делаю следующее.
Я беру вот этот рубль, который я оставил, это единички.
Я единички люблю больше, чем нольки, получается.
А я трачу его на то, чтобы здесь поменялся элемент.
И стало нулем.
Ага.
Понятно?
Вот.
Ну смотрите, вот благодаря этой экономности, с точки зрения денег,
у меня получится, что я могу потратить всего 2n рублей.
Смотрите, здесь вообще интересное представление того, как мы вдаем монетки.
Это не просто так происходит, это происходит только лишь благодаря тому,
что мы через элемент распределяем эти монетки и с ними работаем.
Понятно?
То есть вот мой мешочек, че хочу, то с ним и делаю.
И вот от него отталкиваюсь.
А здесь это именно и происходит.
То есть очистка любого бита будет ноль, увеличение на единичку – 1.
Вот.
А поскольку каждая такая операция требует установки не более всего лишь одного бита,
то есть одному инкременту мне достаточно дать 2 рубля.
И все.
У меня всего будет 2n рублей.
Все, конец, у меня одна операция стоит 2.
Смотрите, с самого начала у нас было ноль.
Поэтому там и не было монеток.
А как только появляется единица, там же был инкремент, который 2 давал.
Вот оно тут и появилось.
Понятно?
То есть любой инкремент тратил вот эти две монетки.
У нас всего инкрементов n, получается 2n.
Заметьте, какой нетривиальный подход к банковскому методу.
То есть со стейком на двух очередях все было как будто бы одинаково.
Как будто это бесполезно, что метод усреднения, что метод банковский.
Они одинаковы.
Есть другой подход.
Если у вас развита логика с точки зрения распределения монеток,
можете делать так.
Всегда. Пожалуйста.
Окей?
Да.
Смотрите, каждому инкременту я даю 2 рубля.
Да?
Что может сделать инкремент?
Он может взять и поставить куда-то единичку.
Единичку он поставит всего один раз.
Ноль на единицу поменяет в любом из мест, где есть.
И он даст этой единичке монетку.
А все остальное он будет, вот у всех единичек, которые будут меняться на ноль,
он будет забирать эти монетки.
Ага.
Вот.
К максимуму он сделает одну такую единичку.
Вот этой единичке тоже там были монетки от предыдущих разов.
Всего инкремента сколько?
n.
Получается 2n.
Понятно?
Сейчас, ноль.
Да.
Зачистку он берет от этих монетки.
Ноль, ноль, ноль, ноль, ноль, один.
Да.
Чтобы вот здесь стал ноль, а тут единичка, и ты сюда монетку кладешь.
Сейчас, единичку с монеткой.
Так нет, инкримент тебе дает две монетки.
Вот у тебя вот здесь плюс две монетки.
Ага.
А первое, что происходит?
Вот эта монетка, которая была здесь, тратится на то, чтобы эта единица стала нулем.
Это первое.
Вторая монетка, вот которая здесь была первая монетка,
она тратится сюда для того, чтобы стала единицей.
Она тратится сюда для того, чтобы стала единицей.
Ну и третья вот эта кусочка для того, чтобы ей выдать монетку.
Еще вопросы?
Попробуйте понять.
Пожалуйста.
Я вас прошу.
А последнее, что есть здесь, это метод потенциалов.
Метод потенциалов достаточно здесь интересный.
Потенциалом здесь будет выступать число единиц, превращенных в нули при этой операции.
Так, давай.
Почему?
Каждый инкримент максимум в одну единицу добавит.
Максимум один ноль превратит в единицу.
У тебя быть другого случая не может.
Да.
Ну то есть благодаря тому, что мы у единичек оставили монетки, мы можем забить на них.
Но только лишь благодаря этому.
Это важный момент, и важно это всегда понимать.
Ну а с потенциалами все интересней, все проще.
А у вас есть вот эта вот g it.
g it это число единиц, превращенных в нули после этой операции.
А потенциал это число единиц в записи.
В начале потенциал ноль, у нас число ноль, потенцал ноль.
Согласны?
Вот.
Мы с вами понимаем, что вот если у нас gt – это число
единиц, превращенных в нули при ит-операции, то
phi s и t, оно меньше либо равно, чем phi от s-1, минус g
плюс 1.
Ну, число единичек поменялось, вот, типа, вот так я могу
ограничить.
Согласны?
Ну, смотрите, давайте еще раз попишу.
Это последнее, с чем я вас сегодня мучаю, относительно
теории.
И в этом семестре последнее, что у вас будет теоретическое,
это будет в самом конце.
Баначева куча.
Вот.
Сейчас мы будем с вами заниматься с плей-деревом, потом динамикой.
У нас будет такая больше практическая.
Так вот, смотрите еще раз, phi s и t – это количество
единичек.
Количество единичек, да, которые, состояние с итом
находится, да.
То есть у меня состояние с итом, сколько там есть
единичек.
А g и t, а нам говорит это следующее, число единиц, превращенных
в нули после ит-операции.
То есть, грубо говоря, я пришел с s и t – первой операции
в s и t, сколько единичек потерялось.
Сколько единиц нить ушло.
Зову это так.
Понятно?
Ну, типа это просто вот превращение, сколько мы
потеряли.
Логично, что разница этих потенциалов, ну вот сколько
было там количество единиц, сколько было до этого, сколько
стало.
Оно, по сути, g и t.
Плюс один, я могу сверху ограничить это все.
Понятно?
Ну то есть я могу сказать, что phi от s и t минус phi от
s и минус первое меньше либо равно, чем g и плюс один.
Специально ограничиваю так, чтобы оно было меньше
либо равно.
Мне нужно это будет дальше, вот дальше, вот там.
Равно написать.
Ты уверен, что ты сможешь равно написать?
Не, не это.
Не правда.
Ну а третье.
Давайте еще раз.
Ноль, один, один, один.
Плюс один.
Один, ноль.
Ноль, ноль.
У меня g и t – три.
Правда?
Весь у меня коллекция единичка – три, здесь один.
А, ой, я это… А, нет, все, все.
В смысле единичку, g и t плюс один.
Или где единичка?
Вот эту.
Эта единичка, она могла быть отсюда, ну вот единичка
это возникает вот от того, что здесь был ноль, стало
единица, а могло быть не быть такого.
Плюс один, плюс-минус один, грубо говоря.
Либо ее не было, либо она есть.
Это сколько единицу шло, мы не считаем, сколько
единиц пришло.
С нулевой они содержат единицу, у вас x равно нулю.
У вас x равен нулю.
Это первое, что я сказал, что мы это предполагаем.
Последнее, давайте я сейчас кратко расскажу, что здесь
есть, и вы можете быть свободны.
Прошу прощения за такую немножко тигомотную, может
быть, лекцию, больше связанную с такими выкладками математическими.
Но поверьте, следующая лекция – это выстрель.
Так вот, когда мы с вами это все сделаем, дальше мы
можем оценить ТИТ, и мы можем сказать, что реальное
время работы, оно меньше либо равно, чем ЖИТ плюс
один.
Потому что мы меняем вот эти единички и максимум
еще добавляем еще одну единичку.
Согласны?
Вот.
И вот это подставляя сюда, учитывая с разностью потенциалов
и так далее, мы с вами получим, что у нас ТИТ равно двум.
ТИТ со звездочками аморцизационно.
Понятно?
Меньше либо равен, чем два.
Не больше, чем два, да.
Не больше, чем два.
И это нам хватает.
Нам два хватает, значит это всегда заод единички.
Понятно?
Все, на этом, в принципе, сегодня все.
Хорошего вам вечера.
Спасибо.
