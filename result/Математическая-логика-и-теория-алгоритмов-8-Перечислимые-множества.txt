Так, давайте начнем. Значит, мы постепенно приближаемся к центральному
результату вот этой части курса, то есть именно теоремии о том, что бывают
причислимые, но неразрешимые множества. Может быть, даже мы сегодня в конце его
успеем изучить, ну, может быть, начнем с этого следующего лекции.
По крайней мере, первую половину лекции я хотел посвятить вопросу о том, что
вообще такое перечислимое множество. Да, у нас в прошлый раз было определение, но на
самом деле есть много других определений, и разные факты удобно
доказывать через разные определения. Ну, точнее, так часто говорят про разные
определения, но мне кажется, корректнее говорить про одно определение и много
эквивалентных свойств. Значит, так что, давайте так и озаглавим. Эту часть
свойства эквивалентной перечислимости.
Свойства эквивалентной перечислимости.
Значит, базовое определение, которое считается определением, точнее, базовое
свойство, которое считается определением, то, что есть перечисляющая машина. Да,
давайте его назовем, значит, обозначим цифрой 0. Значит, нулевое
свойство, которое оно же определение, то, что есть перечисляющая машина. Значит,
есть машина с потоком вывода. Такое, что множество выведенных слов совпадает с
данным. Такое, что множество выведенных слов
совпадает с данным множеством. Тогда данные может перечислим.
Ну, это можно по-разному рассказывать. Можно говорить, что любое слово из множества
будет рано или поздно напечатано, а любое слово не из множества не будет напечатано
никогда. Значит, при этом, если множество бесконечное, то такая машина не может
остановиться. То есть, она будет работать бесконечно долго, чтобы вынести бесконечно
много слов. Вот так. Хорошо, значит, тогда какие еще есть свойства эквивалентные?
Так, ну, например, первое. Значит, первое, давайте в том же духе, что есть такая же
машина, напечатающая без повторений. Давайте я напишу аналогично, только печать без
повторений. Аналогично, но слова в выводе не повторяют. Во выводе не повторяются.
Так, значит, второе свойство. Значит, второе давайте через полухарактеристическую функцию.
Значит, вычислимо полухарактеристическая функция. Значит, в полоте была характеристическая,
которая единица внутри множества и ноль вне множества. А вот эта вот функция, дайте ее
обозначим из чертой с индексом А от Х. Это по-прежнему будет единица, если Х принадлежит А, и не
определено, не определено, если Х не принадлежит А. Вот так, хорошо. Значит, третье. Значит, я думаю,
что мы не все это изучим, не все свойства. Значит, третье, что А это область определения вычислимой
функции. Значит, четвертое, то А это область значений вычислимой функции. Значит, пятое, А это пустое,
или А это область значений. Так, а что такое? Область значений судо-определенной вычислимой
функции. Значит, такие функции еще называются тотально вычислимыми. Значит, тотально вычислимая
функция. Это просто синоним. Так, ну и дать на это шестое. И на этом осталось, там можно еще парочку
добавить. Вообщем, шестое будет следующее, что А это проекция разрешимого множества пар. Проекция
разрешимого множества пар В. Вот, что значит проекция? На начале, что мы вторую координату забыли.
Ну не забыли, а стерли. Да, то есть А это множество таких Х, то существует Y такое, что пары Х,
пары Х, Y лежит в В. Так, что же тут не так? На моем с доской, а не со стилусами. Значит, пары Х,
Y лежит в В. Значит, при этом В разрешима. Значит, можно еще немножко поговорить про то, что такое
разрешимое множество пар. И про это можно говорить двумя способами. Значит, можно прямо ввести какую-то
явную модель вычисления на парах. Например, у машины тюринга на входе записано сначала одно слово,
потом пробел, потом другое слово. И вот это мы считаем, что мы пару подали на вход машине тюринга.
Или, например, у машины тюринга будет две ленты, и на первой ленте записано одно слово,
на второй ленте записано другое слово. Ну или любым другим способом мы как-то научились подавать
два аргумента на вход программе. И тогда получается та же самая теория, что мы можем считать, что если
подали пару из множества В, то тогда машина выдала 1, если подали на вход не из В, то машина выдала 0.
Это будет разрешимое множество пар. Это один подход, а второй подход, что мы просто как-нибудь закодило
пары в отдельные числа или в отдельные слова. Но тоже есть много разных способов, да там
взаимнооднозначная, не взаимнооднозначная. И тогда мы используем обычную программу с одним входом.
Но этот вход понимается как код пары. И можно считать, что программа начинает с того, что она декодирует
эту пару в два одинаковых аргумента, и потом уже с ними что-то вычисляет.
Ну, в общем, это все одно и то же. И на интуитивном уровне вообще никакой разницы нет.
Просто есть алгоритм, который по паре понимает, лежит эта пара в множестве В или не лежит.
Ну а тогда утверждается, что если мы вот вторую карнавсу отрем и оставим только первую, то разрешимое
множество превратится в перечислимое. И наоборот, любое перечислимое может быть представлено в таком виде.
Так, хорошо. Но давайте в каких-то направлениях это докажем.
Да, да, да. То есть множество перечислимое утверждает следующее, что множество перечислимое
тогда и только тогда, когда для некоторого разрешимого В выполнено это равенство.
Так, хорошо. Ну давайте скажем из 0, 1.
Значит, как может пришлять без повторений?
Значит, идея такая, что мы запускаем старый...
Да, во-первых, очевидно, что из единицы следует 0, потому что это просто частный случай.
Да, значит, из единицы 0 очевидно, из 0, 1 следующее.
Вот пусть у нас есть программа, которая перечисляет, может быть, с повторениями.
Но мы ее... Выход будем обрабатывать так.
Значит, будем запускать программу, печатающуюся повторениями.
Но вывод не забывать, а хранить. И хранить все уже напечатанное.
И хранить все уже напечатанные слова.
И далее при получении нового слова.
При получении нового слова.
Прежде чем напечатать, проверить, что оно не было раньше.
Проверить, что оно не было напечатано раньше.
Не было напечатано раньше. Ну и соответственно, если было, то тогда пропускаем.
И заданными не печатаем.
Если было, то пропускаем.
Если не было, то печатаем.
Ну и тогда ясно, что от всех повторов останется только самый первый.
Если слово встретилось первый раз, и еще раньше не было ни разу напечатано, то мы его напечатаем.
А если оно уже было, то сколько бы раз оно не повторялось, мы все равно все новые
разы пропустим, и в итоговый поток их не отправим.
Вот так. Ну что, понятно, да?
Более чем счетов тут вообще ничего нет.
Потому что и сами алгоритмы записывают словами в конечном алфавите,
и то, с чем они работают, записывают словами в конечном алфавите.
В общем, здесь все внутри натуральных чисел происходит.
То есть функция, например, в алгоритмической может быть не вычислимой, просто и для нее вычислима.
Да и любая другая, если беденцарно, то А это область определения.
Не, ну то смотря, что вы называете алгоритмической функцией.
Ну например, алгоритм по сравнению с два числа, если ее область определения.
Не, не, не, сейчас. Значит, здесь все функции нужно определить на конечных словах.
Или на натуральных числах.
Все, что у действительного аргумента в эту теорию плохо ложится,
это ее можно расширить, но мы пока не будем так делать.
Ну так выделяем область памяти, и каждый раз, когда старый аргумент что-то напечатал,
мы как бы работаем как посредники между старым алгоритмом и итоговым потоком вывода.
Значит, если старый алгоритм потока вывода напечатал, то мы это как бы ловим
и сравним с тем, что уже было напечатано.
Если еще не было, то мы это отправляем в итоговый поток вывода
и записываем в список того, что уже напечатано.
Если было, то просто игнорируем и считаем дальше.
То есть есть как бы отдельный кусок памяти, где запускают старый алгоритм,
и отдельный, где мы храним его вывод.
Не, ну как, по битву сравниваем.
То есть мы в детали не лезем, считаем, что там сравнивать строки вы умеете.
Если вдруг надо будет, то даже на машине тюринга можно написать.
Такие нескромные детали лезть не будем.
В общем, считаем, что все, что вы можете запрограммировать сами, заведомо вычислимо.
И то, что это вычислимо в конкретных паделях мы особо смотреть не будем.
Так, хорошо.
Ну, нулевое первое получилось эквивалентно,
потому что из первого нулевой это очевидно, потому что частный случай.
Значит, очевидно, частный случай.
Если мы можем без повторов напечатать, то значит с повторами тоже можем напечатать.
Так, хорошо, теперь давайте из первого второго, ну или из нулевого второго,
то есть как вычислять полухарактеристическую функцию.
Вот, ну это очень легко на самом деле в эту сторону.
Значит, программа, вычисляющая полухарактеристическую функцию.
Значит, она имеет вход X, и она умеет запускать перечисления.
Да, значит, просто запустили перечисление A.
Значит, запустили перечисление A, и ждем появления X.
Вот, если появилось, то тогда печатаем единицу.
Да, значит, если появилось, то тогда возвращаем единицу.
Вот, значит, в программе больше ничего не нужно писать.
Да, то есть не нужно писать, если не появилось, то делаем что-нибудь еще.
Это и не нужно, это и вообще и ошибка была бы.
Потому что мы не знаем, появится ну или нет.
Процесс бесконечный, соответственно, в общем случае невозможно определить, что никогда точно не появится.
Вот, соответственно, что же получается?
Получается, что если на самом деле X есть, то тогда он появится в перечислении.
Тогда мы его дождемся, и тогда вот это условие сработает, и мы вернем единицу.
Если на самом деле X нет, то это условие никогда не сработает.
Да, значит, если на самом деле X нет, то это условие никогда не сработает, и эта машина будет работать бесконечно долго.
Вот, значит, нужна оговорка, что если перечисление может закончиться, то есть если будет конечное множество, и оно закончится, и там и саня появилась,
то нам все равно нужно искусственно там зациклиться, чтобы работать бесконечно долго.
Вот, хорошо, значит, из первого, второе получили.
И второе, третье.
Значит, ну и второго, третье, это просто очевидно.
На самом деле, дело в том, что тому множество а это как раз в области определения полухарактеристической функции х и а с чертой.
Потому что как раз на элементах а она равна единице, и поэтому определена.
На элементах ни и за она не определена, и значит, они не входят в область определения.
Так, значит, дальше давайте из второго в четвертое.
Значит, из второго в четвертое удобно делать так.
Ну, можно сказать так, что а это область значений вот такой функции.
Значит, функция х, умноженная на х и а чертой от х.
То есть, мы вместо единицы сам х печатаем.
То есть, это будет х, если х лежит ва, и не определено, если х не лежит ва.
И как раз, если х и а с чертой вычислимо, то тогда умноженная на х, она тоже вычислимо.
Так, теперь пятая.
Так, может такое пятая. Пятая это значит без повторов.
Так, пятая самая удобная из первого получать.
Значит, из первого получаем пятая, но тут нам немножко нужно случаев разбирать.
Значит, если множество пустое, то у нас это как отдельный случай рассмотрено.
Если а пустое, то тогда подходит.
Значит, если а конечная, ну как-то можно, я напишу это как упражнение.
Значит, упражнение построить вычисливую функцию, в которой область значений, это данное конечное множество.
Ну, там есть много разных способов.
Ну, например, можно на входе n, вот как число убрать, остаток по модулю число значений
не зависит от остатка выдавать нужное значение.
Вот, или еще как-нибудь.
Вот, а если обрез конечная, то тогда мы сделаем такую функцию.
Значит, f от, дайте я напишу не х, а n, чтобы подчеркнуть, что это число.
Значит, f от n это n-ый элемент, n-ый элемент перечисления без повторов.
Вот, тогда получается, что это всюду...
Кстати, тут даже не обязательно без повторов, можно и с повторами.
Значит, можно и с повторами.
Так, давайте...
Тут можно и с повторами.
Можно и с повторами.
Ну, в общем-то, так или иначе получается, что если процесс бесконечный, то для любого n, на n-ом шаге что-то будет выведено.
Поэтому это будет сюда определено.
Ну, а с другой стороны, любое элемента будет в перечислении, поэтому на каком-то шаге будет выведено.
Значит, поэтому вот значение точно совпадает с нашим множеством.
Так, теперь самое интересное, это шестое.
Значит, я одно направление напишу, как из третьего делать шестое.
А там из четвертого и пятого примерно аналогично.
И потом еще из шестого нулевое, и этим цикл замкнется.
Да, значит, например, как из третьего и четвертого.
Да, значит, например, как из третьего делать шестое.
Ну, смотрите, пусть... Тут мы уже от полухарактеристической функции отходим.
Пусть A это область определения f, и f вычислимо.
Значит, тогда, значит, можно написать следующее.
Значит, B это будет следующее.
И это будет следующее. Это будет множество из пар X и K.
Значит, такое, что f от X останавливается за не более чем K шагу.
Значит, то, что D разрешимо, это формально почти очевидно.
В смысле, интуитивно почти очевидно.
Формально там чуть попозже поговорим, когда закончим разговор про перечислимость.
Значит, интуитивно то нужно сделать.
Что нужно сделать? Ну, надо взять ту машину, которая вычисляет f,
запустить ее на входе X и как бы симулировать K шагов.
Если за эти K шагов она остановилась, то, значит, сказать, что ответ да.
Если не остановилась, то ответ нет.
Значит, в чем тут основная фишка? В том, что фиксируемо число шагов.
Если мы будем спрашивать, остановится ли она вообще,
то это будет как раз неразрешимая задача.
Это проблема остановки, и про это мы будем скоро говорить.
Если мы фиксировали время, то на это фиксированное время можно взять и запустить.
Значит, с точки зрения обычного программирования это более-менее очевидно,
потому что это как называется программа, которая запускает другие программы?
Это компилятор. Компилятор это и делает.
Компилятор берет текст программы и берет входной файл,
ну и в итоге запускает эту программу на этом файле.
Это может быть развито на этапы. Сначала какой-нибудь экзешник сделать,
потом экзешник запустить.
Но если все это вместе воспринимать как один компилятор,
то этот компилятор ровно это и делает.
А если еще там ему лимит на время поставить, то он делает ровно то, что здесь написано.
То есть запускает программу на данном входе на какое-то число шагов,
то есть на какое-то время.
Если мы берем тезис Чорча, то тогда можно сказать, что раз мы это умеем делать на компьютере,
значит и на машине Тернига тоже умеем.
Но, конечно, это не только эстезисы Чорча следует,
но и может быть получена как формальная теория,
она называется универсальная машина Тюринга.
Машина, которая запускает другие машины.
Про это мы чуть позже поговорим подробнее.
Пока что ограничимся тем, что, во-первых, действительно А это проекция В.
Почему? Ну, потому что если f от x определено,
то тогда значит за какое-то конкретное число шагов оно вычисляется.
Тогда f от x вычисляется за какое-то число шагов, значит за какое-то t шагов.
И, соответственно, получается, что пара xt лежит в В.
А тут еще нам нужно начать, что если x лежит в А, значит если x лежит в А, то f от x определено,
значит он принял какое-то конкретное число шагов, значит пара xt лежит в В,
и значит x принадлежит к проекции В.
Ну, и наоборот, значит, на самом деле эти стрелки можно в обратном направлении пройти.
В обратном направлении тоже все стрелки верны.
Ну, если правильно квантеры расставить, то есть если x лежит в проекции, то значит для некоторого t,
значит для некоторого t пара xt лежит в В, значит для этого t f от x вычисляется за какое-то
не более чем t шагов, ну, значит останавливается, значит f от x определенно, значит x лежит в А.
Вот, значит действительно получается, что А проекция В.
Так, ну что? Насколько это понятно, какие-нибудь вопросы?
Так, ну что? Насколько это понятно, какие-нибудь вопросы?
Насколько это понятно, какие-нибудь вопросы?
Так, ну что же, остается, чтобы все замкнуть, нужно из шестого куда-нибудь перейти.
Ну, можно прямо в нулевой перейти.
Что, как перечислять проекцию? Да, значит из четвертого и пятого шестого примерно аналогично.
Значит, из четвертого шестого, из пятого шестое, получается аналогично.
И остается, чтобы замкнуть весь круг, нужно из шестого перейти в нулевой, например.
Значит, как перечислить проекцию? Ну как, помните, как обходить эту самую кетку?
Как доказывать, что множество рациональных чисел счетно?
Ну, а здесь примерно то же самое.
Значит, здесь будет решетка.
Значит, соответственно, здесь там х, значит здесь у.
Значит, вот есть какая-то решетка.
Значит, дальше каким-нибудь способом можно это обходить.
Ну, на самом деле, чтобы было попроще программу писать, удобнее обходить вот так вот.
Да, значит, вот как бы я вот так вот условно нарисую уголкам.
Как бы все затрагиваю все больше и больше углы.
То есть, программа получается такая.
Значит, пусть.
Пусть это разрешимое множество пар.
Значит, пар.
И, соответственно, программа перечисляющая.
Значит, программа перечисляющая проекцию В.
Будет вот такая.
Значит, это просто цикл по всем к.
Для к от нуля до бесконечности.
Значит, дальше для х от нуля до к.
Ну, три тут ложных цикла получаются.
Дальше для у от нуля до к.
Значит, если.
Значит, если пара х лежит в Б.
То.
Напечатать.
Икс.
Вот тут даже не совсем, как я нарисовал.
Так что мы как бы каждый раз все старое снова перебираем.
Значит, если хотите, можно какую-нибудь другую программу написать более.
Которая не бесконечно числа раз одно и то же делает.
Все по одному разу.
Но тут нам не важно.
Мы тут не заботимся ни об эффективности, ни о чем.
Вот почему это работает.
Ну, смотрите, если у нас х лежит в проекции.
Ну, так оно здесь было.
Вот.
Вот это вот.
Давайте я здесь тогда припишу.
Вот это вот.
Это называется проекция Б.
Можно написать, что проекция на первую координату.
Но у нас других не бывает.
Вот.
В общем, смотрите, если х лежит в проекции, то это что значит?
Это означает, что для какого-то.
Давайте я тут еще отдельно напишу.
Значит, если х лежит в проекции Б, то это по предельному означает,
что существует у такой, что пара х и у лежит в Б.
Значит, тогда на шаге.
Значит, на шаге максимум из х и у.
Вот эта пара попадет в рассмотрение.
Значит, х и у попадет в рассмотрение.
Ну и, следовательно, программа напечатает х.
То есть х получается попало в выход программы.
Ну и, с другой стороны, если х попало в выход программы,
то значит, вот это вот условие сработало и означает, что х лежит в проекции.
То есть опять же в обратную сторону тоже можно пройти.
Вот.
Значит, что здесь важно?
Важно, что до этого шага с таким номером программа точно дойдет.
Потому что если к фиксировано, значит, если к фиксировано,
то вот этот вот цикл конечный.
То есть у нас, значит, почему нам нужно именно так вот?
Ну, потому что если мы, не знаю, будем там по первой вертикали
идти вот туда в верхней бесконечности и искать, будет там х или не будет,
то если его там нет, то мы на все остальные вертикали потом никогда уже не перейдем.
И тогда у нас не получится все написать.
Поэтому нужно с одной стороны все больше и больше вертикали захватывать,
с другой стороны, на каждой вертикали идти ко все более и более высоким точкам.
Ну и, соответственно, в принципе любой порядок обхода тут сработает.
Важно, чтобы это была единая последовательность.
Вот. Хорошо, значит, вот эти вот, эти шесть свойств,
семь свойств получаются равносильно.
Ну что, меня просили прерыв сделать, давайте сейчас сделаем на пять минут,
а потом будем применять эти свойства для разных утверждений.
Так, ну что, давайте я разные свойства подхожу на разных,
через разные определения.
Ну, например, да, например, утверждение один.
Значит, утверждение один, что если A и B перечислимы, то пересечение тоже перечислимо.
Если A и B перечислимы, то тогда пересечение будет перечислимо.
Ну, например, можно доказывать через, это треть у нас получается,
через область определения вычислимой функции.
Доказательства.
Значит, пусть A это область определения функции F.
Ой, так, почему оно?
Так, сейчас, я не понимаю, они садятся, не заряжаются?
Я еще на другом проблеме. Ладно, сейчас.
Так, значит, доказательства такое, что пусть A это область определения F,
значит, AB это область определения G.
Ну, тогда пересечение,
значит, пересечение, это область определения, ну, например, суммы F плюс G.
Да, значит, я тут все время буду переходить от понимания базовых объектов
как слов из 0 единиц, к пониманию их как чисел и обратно.
То есть, если, ну, на самом деле, это совершенно неважно, какая операция будет.
Но если я не веду, что это числа, что беру F от N, беру G от N,
и просто их складываю как числа.
Если будет, например, конкатинация, то это будут строки.
Почему это будет? Почему пересечение это область определения?
Ну, потому что если хотя бы одно слагаемое не определено,
то соответственно и сумма тоже не определена.
А если в область слагаемых определена, то сумма определена.
Ну вот, поэтому сумма будет определена только если и то, и другое определенно,
как раз пересечения. Так, ну ничего, понятно, да. Так, хорошо, значит, утверждение 2, значит,
утверждение 2 с объединением, значит, если а и b перечислимое, значит, то тогда
объединение перечислимо. Вот, тут вот этот уже не подойдет, да, значит, нужно что-то другое,
ну, например, можно через область значений. Да, можно сказать, что пусть, пусть а это область
значений f, значит, а b это область значений g. А дальше мы рассмотрим такую функцию, значит,
h от n, это будет равняться f от k, если n равняется 2k и g от k, если n равняется 2k плюс 1. Вот,
ну тогда, конечно, h будет вычислимо, и область значений h как раз будет объединением a и b.
Область значений h это как раз объединяемое. Ну, потому что все, что получается ва, будет значение на
каком-то четном числе, все, что значение g будет значение на каком-то нечетном числе,
ну и наоборот, да, ничего лишнего тут не появится. Так, так, ну хорошо. Ну, давайте еще, чтобы, чтобы
показать. Следующее утверждение не то, чтобы очень интересно само по себе, но оно тоже, оно
позволяет на последнее ориентироваться, значит, утверждение 3. Значит, смотрите, если бы это
перечислимое множество пар, перечислимое множество пар, то тогда его проекции тоже перечислимо.
Значит, проекция b тоже перечислима. Да, то есть, перечислимый это всегда проекции разрешимого,
но проекции перечислимого будут все еще перечислимым, а не чем-то большим. Значит,
смотрите откуда это берется значит доказательства вот это вот бы я как
множество пар будет само проекции множество троек да то есть из свойства 6 мы
получаем что бы это множество таких пары с игрек то существует з такое что
тройка x, y, z лежит но и цит разрешимое множество вот а я кто такой проекция
б, значит да проекция б это множество таких x то так квантор забыл что
существует y такое что x, y лежит в b вот а это получается из предыдущих множество
таких x то существует y существует z такое что тройка x, y, z лежит в ц но дальше
те есть то что вот эти вот два квантора можно как бы склеить да то есть можно
дайте я сейчас тут напишу обозначение объясню данной доске значит получается
x то значит существует пара да значит что x и дальше левая от пары и правая от
пары лежит в ц вот но и дальше надо теперь смотреть как бы множество пар да то есть
тут конце нужно писать что это множество x такое что существует п то пара x, p лежит в д и что
это за обозначение значит я имею ввиду следующее да все-таки нужно немножко в явном виде поговорить
про вычислимое кодирование пар вычислимое кодирование пар
что есть какой-то x натуральное число значит y натуральное число и мы из них вычисляем
некоторые код пары значит p от x, y тоже натуральное число вот это как бы одна функция значит еще есть
наоборот функция левая и правая левая из натуральных натуральные и правая из натуральных натуральных
соответственно мы хотим чтобы было следующее чтобы левая и правая пары были согласованы да то
То есть мы хотим следующее, чтобы левая от пары x и y
равнялась бы x, и правая от пары x и y
равнялась бы y. То есть если мы сначала
образуем код пары, то он может декодировать, и при декодировании
получится ровно то, из чего мы этот код собирали.
Вот. Ну и более того, все эти функции должны быть
вычислимыми. То есть функция пары, функции
проекции левой, функции проекции правой, все они вычислим.
Вот. Ну, например, можно вот такую функцию
рассмотреть. Это не то, что я рисовал, да, по диагональкам.
По диагональкам. Сейчас я попробую наизусть написать.
Вроде должно быть следующее. Значит, x плюс y на x плюс y плюс 1
пополам и плюс x. Да, это вот треугольное число.
Значит, это такая форма. Соответственно тому, что мы по
диагонали мы идем, перескакивая сразу там из лево-верхнего угла
в правый-нижний, идем по диагонали мы так по все более-более высоким.
Значит, если мы просто будем нумеровать подряд, то ровно вот
эта формула получится. Значит, это пример. Это пример, когда это еще
взаимнооднозначное. Вот. Ну, для l и r будет немножко сложнее
формула, но ясно, как это делать. Нужно вот это треугольное число
называется. Нужно те максимально треугольное число, которое меньше
данного, меньше либо равно. Вот. Соответственно, вычесть его из данного
получится x, а то, который здесь будет, ну, номер треугольного числа, из номера
треугольного числа вычесть x, получится y. Так. Ну, примерно понятно, да?
Это не непонятно. Не, ну, тут, смотрите, тут это, это похожее на, ну, это почти
будет корень из удвоенного числа, да. То есть, смотрите, вот у вас есть число n,
вам нужно эти целые x и y так, чтобы n равнялась вот этому. Как это, как вы это
будете делать? Ну, смотрите, вот то, что здесь до центрального плюса, да, это
треугольное число. То есть, 0, 1, 3, 6, 10 и так далее. Это сумма архитектurических
прогрессий. Да, и нужно сначала найти наибольшее треугольное число, которое
будет не больше данного. Вот. Дальше, номер, номер этого треугольного числа это
будет x плюс y. Дальше, как найти x? Ну, нужно само это треугольное число
вычесть из нашего, получится x. А если мы знаем и x и x плюс y, то и y мы тоже
знаем. Вот это будет вычисление l и r. Вот. Хорошо, соответственно, что вот здесь
получилось? Значит, здесь получилось, что вот это вот p, и это прям будет код
пары. Код пары вот этой из y и z теперь. Значит, код пары из y и z это p. Но как
тогда y и z из него получить? Ну, нужно те вот функции, левую и правую, от него
взять, да, значит, и получится y и z. Вот. Ещё остается вопрос, что это за d?
Значит, что за d? Ну, нужно, чтобы, то есть, значит, d будет, программа, которая
вычисляет, ну, вычисляет d в том смысле, что находит ответ, лежит ли данная пара в d или
нет. Значит, программа, разрешающая d, будет делать так. Она получает пару из x
и p. p, я понимаю, тоже как пару. Из этой пары выуживает левую и правую, то есть
y и z. И потом всю эту тройку подаёт на флот программе, которая решает про c. Лежит
тройка в c или нет. Вот. Ну и тогда получается, да, что вот эта пара будет
лежать в d, тогда это только тогда, когда тройка лежит в c. Вот. Ну а нижнее
получается, просто определение 6 уже для, уже для проекции, да, не для, но чтобы, а для
проекции. Вот. Так. Ну ничего, пример понятно? Ну, в общем, тут такая важная идея, что вот
два одинаковых квантора можно как бы склеивать. На что существует одно, что существует другое,
то же самое, что существует пара. Вот. Их вот так можно кодировать. Так. Ну хорошо, какие-нибудь
вопросы. Да, да, да. Вот та форма, это взаимнооднозначное, взаимнооднозначное
соответствие между парами, натуральные числа, начиная с нуля, и сами натуральные числа, начиная
с нуля. Ну, потому что это вот такая номерация, так давайте это нарисую, то я имел в виду,
под диагональками, да, то есть это вот такая вот номерация, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
10, 11, 12, 13, 14, 15, да, и так далее. В общем, вот такая номерация пар сдается ровно вот этой формой.
Значит, почему? Потому что вот без этой добавки это будут те числа, которые здесь по вертикали
стоят, по первой вертикали. А дальше, когда мы идем по диагонали вниз, то у нас х плюс у сохраняется,
а х увеличивается на единицу. И тут тоже как раз х плюс у сохраняется, х увеличивается на единицу.
Ну, грубо говоря, да, нужно носить какое-нибудь число, не знаю, 156, да, оно лежит где-то вот тут.
И мы хотим понять, на какой оно диагонали. Мы ищем наибольшее число, которое не больше
данного. Это я что-нибудь не соображу, сколько, да, в общем, от 156 нужно там отойти назад,
и сколько-то будет вот здесь. И это будет сумма х плюс у. А дальше все, что осталось, это будет х.
Все, что осталось от треугольного числа до нашего, это будет х. А у это то, что сколько осталось от х
до х плюс у. И так мы найдем х и у. Вот. Ну, хорошо. Хорошо, начнете, наверное, двигаться дальше.
Дальше мы приближаемся к неразрешимым задачам. То есть вот то, что мы хотим
доказать, значит, теорема, то существует перечислимое, но неразрешимое множество.
Но чтобы хотя бы поставить, чтобы сформулировать множество, которое будет таким, нужно немножко
еще поговорить про модель вычислений. А именно есть вот такие два похожих, но немножко разных
понятия. Одно понятие – это универсальная машина тьюринга, а другое понятие – это
универсальная вычислимая функция. Значит, смотрите, что такое универсальная машина тьюринга?
Ну, неформально говоря, универсальная машина тьюринга – это компилятор машины тьюринга,
который сам написан на машине тьюринга. Тут можно, давайте я вот тут немножко отвлекусь,
здесь я вернусь и напишу определение. Здесь немножко расскажу, есть такие два подхода к
архитектуре компьютера. Значит, архитектура компьютера.
Значит, есть понятие Гарвардская архитектура, Гарвардская и Принстонская,
или Неймановская. Гарвардская архитектура устроена так. Значит, есть вот процессор,
значит, есть данные, и процессор как-то работает с данными. Соответственно, вся программа зашита
в самом процессоре. Программа здесь. По такой логике могут в настоящее время работать какие-то
простые устройства, типа там калькулятор. Если он не в телефоне, а отдельное устройство,
калькулятор, то оно работает примерно так. То есть, оно конкретно умеет складывать, умножать,
можно даже кинетинусы считать, если инженерный калькулятор. Но там, в общем, данные – это более
или менее нажатие на кнопки, ну и какая-то память есть, где хранится. А что именно делается,
это полностью его схемой определяется. Бывают какие-нибудь даже более хитрые устройства,
которые на этой логике основаны. Может быть, какая-нибудь поточная обработка звука, например.
Она может быть электронная, но там конкретная программа на уровне железно зашита. Кстати,
бывают оборудования для майнинга криптовалют. Она может быть специально для конкретной
криптовалюты, с конкретными функциями специально сделана, и вот эту валюту она майнить умеет,
а никакой другой не умеет. А что к принцессу? Принцесская архитектура – это, собственно,
то, к чему мы привыкли. Все там компьютеры, смартфоны и даже совсем мелкие устройства могут
быть сделаны на универсальных чипах. Соответственно, есть процессор, есть память, и эта память разделена
так нечетко. В этой памяти есть программа и есть данные. Соответственно, процессор читает
программу и потом на данных эту программу выполняет. Это граница пунктирная. Если нужно
больше места для программы, выделим место на диске для программы, и будем оттуда читать
программу. Если нужно меньше, то эту программу сотрем и будем использовать для данных. Эта граница
как бы смещается. Соответственно, если вот этот процессор в гарвардской архитектуре некоторую
конкретную программу исполняет, то для чего его сделали. Майнит криптовалюту, обрабатывает звук,
суммирует числа. Могут какие-нибудь простые чипы в какой-нибудь сим-карте или еще в каком-нибудь
простом устройстве тоже могут по конкретной программе работать. А вот этот процессор может
любую программу прочесть из памяти и на данных ее запустить. Любые смартфоны, смарт-часы, компьютеры,
ноутбуки, планшеты, они все работают вот так. Есть много всего, операционная система,
разный уровень памяти и так далее, но глобально это все вот так. И программы, и данные в одном и том
же месте находятся, и процессор с ними работает. Обычная машина чуринга, как на семинарах,
здесь уже во всех группах было определение, что там есть нож состояний, нож символов, функции
перехода. Это как раз гарвардская артиктура, что там конкретная программа зашита в функцию
перехода. А универсальная машина чуринга получает как бы программу для другой машины
чуринга тоже из памяти и потом ее применяет. Теперь переходим сюда. Универсальная машина
чуринга это у двумя аргументами м и х. Это соответственно, можно сказать, просто равняется
эматык. Значит, словами получаем так, что машина у получает код машины м и вход х.
Соответственно, запускает эматык, ну и возвращает то, что получилось. Универсальная
машина чуринга, функция, это похожая вещь, но чуть более общая. Я как-то пытался написать,
что это такое каллиграфическое у, а это у прямое. У будет просто от пх, там п была пара, здесь
поэта программа. От px это просто вычислимая функция двух аргументов. Для любой вычислимой
функции одного аргумента, любой вычислимой функции f одного аргумента, существует такое p,
но для любого x, значит, у от px равняется f от x. Значит, универсальная вычислимая функция,
это немножко более общее понятие. Можно сказать, что это универсальный язык программирования.
Можно считать, что p – это текст программы, x – это входные данные программы, а у – это компилятор.
Вот как здесь. Программа p, данные x, они закодированы какой-то парой, поэтому хранятся
в одном и том же месте. А вот этот процессор – это функция у, которая что-то вычисляет.
Ну да, давайте раз уж не так.
В узком смысле универсальный машинный тюринг – это в узком смысле, а в широком смысле универсальный
машинный тюринг – это любая машина двух аргументов, которая вычисляет универсальную
вычислимую функцию. В широком смысле универсальная машина тюринга – это просто машина тюринга,
вычисляющая универсальную вычисляющую универсальную машину тюрингу. Есть такой спорт – это попытаться
построить универсальный машинный тюринг, который будет как можно меньше постояней и символов
алфавита. И там вообще какие-то однозначные числа, типа там четыре состояния, семь символов,
или чуть ли не меньше. Но это будет универсальная вычислимая функция именно в широком смысле,
то есть в узком смысле так и не хватит. Но теорема, которую тюринг доказал – это то,
что универсальная машина тюринга существует. Ну и в принципе это не то, чтобы что-то прям
сложное, но немножко такое мутурное рассуждение. То есть нужно сначала как-то договориться о том,
как мы данные кодируем. В чем тут трудность? Трудность в том, что у модели, у ЕМО и машины
М, может быть сколько угодно символов алфавития и сколько угодно состояний. А у моделирующей
машины У должно быть фиксированное число состояния, фиксированное число символов алфавития. Поэтому
нужно как-то договориться, как мы кодируем произвольное множество через ограниченное число символов.
Сейчас, что еще раз вычислимо? Сейчас, вот здесь П – это просто число.
Сейчас, смотрите, здесь некоторая тонкость. Это мы чуть позже будем обсуждать. Значит,
здесь именно то, что написано, что существует такое П, а откуда его взять – это как бы непонятно.
То есть вполне может быть так, что есть какое-нибудь простое семейство функций,
например, прибавление фиксированного числа. То есть, что f от x – это x плюс константа. И хотелось бы,
чтобы по этой константе было бы легко понять, какое тут П. Но это определение вообще не
гарантирует. То есть, там нужна некоторая настройка, чтобы можно было понять, как именно искать это П.
Значит, здесь только утверждать, что оно существует. Хорошо, в общем, формально я
в тюрем не буду доказывать. Но идея такая, что нужно как-то закодировать. Идея доказательства
значит, что нужно закодировать программу M и конфигурация M.
Значит, так, чтобы вычисление на этой самом машине было бы цепочкой простых строковых
преобразований. Так что, вычисление на M было бы последовательностью простых строковых преобразований.
Ну, типа того, что выделить под строку похожий шаблон, и с этим шаблоном провести, заменить на
другую строку, которая следует из программ машины Turing. Ну и, соответственно, тогда машина U уже
должна выполнять эти преобразования. То есть, вот эта машина U красивая должна выполнять эти
преобразования. Вот так. Ну, значит, детали мы не будем изучать. При необходимости, я думаю,
вы это сможете легко сделать. Но не думаю, что необходимости возникнет. Ну, значит,
собственно, мы почти добрались до неразрешимых задач. Но получается, что начнем с них в следующий
раз. Давайте я их пока сформулирую. Значит, что мы будем изучать в следующий раз? Мы будем изучать
две проблемы. Много разных проблем изучать. Значит, неразрешимые проблемы, вязанные с машинами
Turing. Вязаны с машинами Turing. Так, значит, первое. Первое – это проблема самоприменимости.
Проблема самоприменимости. Значит, это, скажем, S, который есть множество таких машин. Значит,
что универсальная машина на вот таком диагональном входе останавливается. Так,
что-то имеется в виду. Я тут, значит, я немножко смазываю обозначение, потому что такие пуристы
говорят, что вот тут надо писать M, а тут надо писать код M. То есть число,
которое как бы или номер, или наоборот, и там, и там номер. Но вообще, я это буду отождествлять.
То есть мы как-то, мы уже научились пары кодировать в числа. Ну, а машина Turing – это набор
каких-то конечных множеств. Мы их так потихоньку все закодируем в одну большую строку или в число.
Ну и, соответственно, можем машину Turing запустить на своем собственном коде. И дальше
что-то получится. Может, она остановится и что-то скажет. Может, никогда не остановится.
Но есть такой игрушечный пример. Будем смотреть машина Turing на какие-нибудь программы. Программа
должна понять, есть ли в лове на входе символ твердый знак. Значит, как это может делать программа?
Может быть, программа, в которой в том тексте программ будет твердый знак. Значит, именно там
константа символ равен твердому знаку, и мы идем по всем символам, сравним с твердым знаком.
Вот эта программа, где твердый знак есть. А, и мы будем считать, что эта программа, она как бы ищет,
пока не найдет, а если его нет, то она никогда не остановится. Она ходит по циклу и ищет твердый знак.
Если твердого знака нет, она никогда не остановится. Но если ей ее собственный код дать, то она
остановится, потому что там есть твердый знак. А может быть, другая программа, которая будет
описана следующая. Возьмем символ SHA, а потом возьмем следующий символ. И будем этот следующий
символ искать, также по кругу. Тогда понятно, что эта программа делала то же самое. Но в тексте ее твердого знака нет.
Соответственно, получается, что это может быть осмыслено, что может быть
осмыслено программу запускать на самой себе, как в коде. И соответственно, она может остановиться,
может не остановиться, даже если она, вообще говоря, делала то же самое. Второй пример это
проблема остановки. Или иногда говорят, проблема останова. Как бы такой инженерный более термин.
Халтинг проблем. Тут уже просто два дается на вход. Аргументы и машина, и сам аргумент.
Так что просто у от mx останавливается.
Вот так. Ну и давайте еще третий пример. Проблема тотальности заключается в том,
что у нас дана только машина m. А нам нужно понять, верно ли, что для любого x от mx
определена. То есть у от mx остановится. Верно ли, что машина останавливается всегда? Вот так.
Ну в общем, давайте я оставлю спойлеры, что мы изучим в следующий раз. Это получается перечислимо,
но неразрешимо. Это тоже перечислимо, но неразрешимо. А вот это получается не перечислимо,
и дополнение тоже не перечислимо. Вот, соответственно, вот эти вещи мы будем
доказывать в следующий раз. Попутно изучим несколько интересных техник,
ну и может быть еще примеры изучим. Спасибо за внимание.
