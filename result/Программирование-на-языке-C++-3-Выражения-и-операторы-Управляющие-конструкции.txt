Так, у нас третья лекция сегодня. Мы начнём... Мы в прошлый раз уже начали говорить про
операторы и выражения, и сегодня мы продолжим, наверное, большую часть лекций мы будем говорить
про них. Вот, я вам сказал, что в программе... Программа, так сказать, исполняемый код на C++
state of statement. Statements бывают declaration, то есть можно что-то объявить, бывают expression,
а бывают так называемые control statements. Вот, в прошлый раз мы обсуждали declarations и, вроде как,
их обсудили, и в этот раз мы предполагаем, что мы обсудим вот эти две вещи. Так вот,
параграф 1.4 expressions and operators. Я уже начал говорить, что выражение неформально — это просто
набор переменных и литералов, соединённых операторами и скобками, и первый вид самый простой операторов — это
арифметические операторы, да, плюс-минус умножить разделить процент. Вот, ну, к арифметическим
операторам, наверное, можно ещё отнести... Значит... Наверное, честно говоря, больше никаких
им нельзя отнести. Вот, арифметические операторы, наверное, я их в строчку запишу, это просто вот
эти пять арифметических действий. Вот, кстати, в прошлый раз кто-то подходил, задавал вопрос,
давайте я это для всех скажу, что если вы делаете, если вы выполняете арифметический оператор над
какими-то вещами двух разных типов, то они сначала должны перевестись к одинаковому. Например,
если вы делите 5 на 3, то это будет 1, потому что вы вызываете деление над типом int и int,
и результат снова int. Но если вы сделаете 5 делённое на 3.0, то это уже вызываете деление int на
double, и поэтому левый int поднимается до double, и получается у вас 1,666667. Вот, имейте это в
виду, это не совсем как в питоне работает. Вот, и оператора вот такого у вас нет. Вот это вот означает
комментарий. Хорошо. Дальше побитые операторы, bitwise operators. Значит, что это такое? Ну, это
побитые i, побитые i или побитые xor. Ну, я думаю, тоже не надо пояснять, как они работают. Бьём
биты, побитые, делаем над ними соответствующую операцию. Вот, они определены над целыми числами,
над дробными, по-моему, не определены. Вот, ещё есть побитые сдвиги. Сдвиг влево и сдвиг вправо.
Вот про этот оператор и про этот оператор стоит отдельно сказать, что для целых чисел они работают
как побитые сдвиги, а для некоторых других типов они работают особенно. Например, если левый
аргумент это c in, c out, то эти операторы, если левый аргумент у них поток, то вот этот оператор
действует как вывод в поток, а этот действует как ввод из потока. То есть, на самом деле,
ещё раз напоминаю, что вот то выражение c out влево-влево, какой-то x, это на самом деле вызов
оператора от левого аргумента c out, который имеет тип OStream, и правого аргумента int. И он действует
иначе для таких типов аргументов. Так, что-то я русскими буквами начал нумеровать. А на интах,
что вот эти операторы делают, которые сдвигают? У тебя есть битовое представление числа. Ты
берешь биты и сдвигаешь влево, а заполняешь освободившееся место нулями. Например, я могу
тройку сдвинуть влево на 2, и это всё равно, что умножить на 4. Получится 12. Да, но тройка – это
вот такое число в двоичной системе, а я сделаю вот так. Тут нули, а я вот так сделаю. Это будет
побитый сдвиг на 2. Аналогично вправо я могу сдвигать, тем самым я буду убивать значащие разряды.
Такие вот операции. Дальше операторы сравнения. С ними тоже, наверное, всё понятно.
Comparison operators. Значит, что это такое? Это вот такое равенство, неравенство, меньше, больше,
меньше ли равно, больше ли равно. Опять понятно, как они действуют над интами. Опять-таки, если вы
вызываете их над разными аргументами, аргументами разных типов, то эти аргументы приводятся к
единому типу сначала по правилам приведения типов. Если вы через равно-равно или неравно пытаетесь
сравнивать флоат, и будьте аккуратны, флоаты или даблы у вас могут быть из-за точности. Один и тот
же флоат может быть закодирован разными способами, скажем. Ну, в общем, будьте аккуратны. Я сейчас не
буду вдаваться в подробности, но могут быть проблемы. Равно-равно может выдавать не совсем такие
результаты, как вы ожидаете, а кто-то у меня просит зачем-то локально записать эту встречу.
Зачем это делать? Я не знаю, я ее и так записываю. Нет, я вам не разрешу сам мне записывать, наверное,
я сам записываю. Идем дальше. Логические операторы. Logical Operators. Это вот такие операторы.
Значит, Logical и, Logical или, Logical не. Да, кстати, насчет побитовых операторов я еще забыл вот
такой оператор побитого отрицания. Это унарный оператор, он инвертирует все биты числа. Logical и,
Logical и, Logical и нет. Они принимают в качестве параметров bool, левым и правым аргументом,
и возвращают bool. Ну, отрицание просто берет bool и инвертирует его, как булевское значение.
Вот, понятно, что, опять-таки, если у вас вы передадите аргументы не типа bool, то они будут
сконвертированы в bool, по правилам, которые мы обсуждали. Также понятно, что здесь, наоборот,
если вы сюда передадите bool, то они будут сконвертированы в int, надо помнить. Вот такие
операторы, они требуют целых чисел на вход, и соответственно, если вы передадите bool, то они
будут явно сконвертированы в int, а если вы вот сюда, наоборот, int передадите, то они будут
конвертированы в bool. Вот у этих операторов есть одно важное свойство, так называемое
ленивое вычисление или short-circuit по-английски. Значит, что такое short-circuit?
По-моему, так это пишется. Значит, как работают эти операторы? Если левая часть ложна в операторе
конъюнкции, то правая часть не вычисляется. Это дает вам возможность, например, безопасно
писать так. Вот если у вас есть вектор, и вы хотите там проверить, что vsize хотя бы 5 и
что-то спросить про v4, то вы можете вот так написать. Вот конъюнкция гарантирует вам,
вот этот оператор гарантирует вам, что он не случится ошибки, он не будет как бы делать вот
это вот действие, если здесь условие было ложно. Поэтому так писать безопасно. Вот если это условие
ложно, правая часть не будет вычисляться. Вот поэтому так можно писать. Аналогично, если у вас
в дизъюнкции левая часть истинна, то правая часть тоже не будет вычисляться. Это гарантируется
стандартом. Вот. В частности, например, если вы напишете там, я не знаю, если вы напишете
там какое-нибудь условие true или сделаете increment, то increment не сделается. Вот. Потому
что это true, значит правая часть не вычисляется. Хорошо. Давайте дальше перейдем к более интересным
операторам. Следующая группа операторов – это операторы присваивания. Значит assignment operators.
Ну, это обычное присваивание, а также это составные присваивания. Плюс равно, минус равно,
умножить равно, поделить равно, процент равно. Дальше побитые операторы равно и с побитыми
сдвигами присваивания. Кажется, все, я больше ничего не забыл вроде как. Значит, что делают эти
операторы? Ну, как вы, наверное, и так знаете, давайте проговорим, что, например, означает вот этот
оператор. Это значит, что вы A заменяете на A умножить на B. Как бы, по смыслу, это эквивалентно
вот такому. Вот. Это эквивалентно такому для целых чисел, ну, там и для дробных и так далее,
но для своих типов это может быть переопределено чуть поумнее. Вот. Но на самом деле смысл в том,
что вы просто в A кладете результат, как если A умножить на B. Вот. Чем интересны операторы
присваивания? Интересно, какое у них возвращаемое значение. После присваивания получается то,
что получилось в результате присваивания, собственно. Вот. Если вы, например, напишете,
если вы, например, выведете в cout результат присваивания там x равно 5, то вы получите 5
на выходе. Значит, присваивание возвращает вам то, что получилось в итоге присваивания. И это
позволяет, например, делать присваивания в строчку несколько, одно за другим. Вот. Когда вы так
пишете, это эквивалентно вот этому, и это в свою очередь означает, что вы сначала y присвоите z,
а потом x присвоите y. Значит, операторы присваивания, они правоассоциативны,
правоассоциативны. Это значит, что если вы напишете несколько в строчку любых вот этих
операторов подряд, то они будут выполняться справа налево. То есть это будет эквивалент
тому, как если бы скобки у вас стояли в выражении вот сначала самое правое,
потом предыдущее и так далее. В отличие от всех предыдущих операторов, предыдущий оператор
левоассоциативны. То есть если вы напишете a plus b plus c, то это эквивалент тому, как если бы вот так
написали, а не вот так. Так, значит, возвращаемые значения оператора присваивания – это то, что
получилось в результате присваивания. Это, кстати, иногда бывает, приводит к такой ошибке,
когда новички начинают писать на плюсах, они пишут там, допустим, у их x равно нулю что-то
сделать. Да, и вот это, это компилируется, и это корректный код, но он делает не то,
что могло бы показаться на первый взгляд. Так, что-то в чате много написали, я все пропустил.
Так, если написать 3 больше 2, или 2 делить на 0 равно нулю? Ну, деление на 0 не должно произойти,
да. Вот. Ну, на самом деле, 2 делить на 0, мне кажется, вам просто компилятор скажет, что так
нельзя писать, потому что он уже сразу заподозрит, деление на 0 – силочисленное,
мне кажется, компилятор вам что-нибудь скажет. Но если вы с переменными так сделаете,
то деление на 0 не должно произойти у вас. Ну, короче, ошибки в отчлене правой части не должно
случиться. Так вот, возвращаясь к ИФУ, вот если так написать, это корректно, но это условие
всегда ложно, потому что оно возвращает 0, и таким образом это фолс. Вот. Поэтому
будьте аккуратны, не путайте присваивания со сравнением.
Извините, можно просить? Да, только очень глухо как-то слышно. Ну, давай.
Ну, в общем, х равно у равно z, то есть сначала мы говорим, что у разно z, а потом говорим, что х
равно у, потому что возвращается то, что случилось, а не то, что было. Ну, то есть все значения этой
игры равны z? Ну, все значения становятся равны z после такого. Вот. Здесь впервые, когда мы
разговариваем про операторы присваивания, мне нужно ввести понятие L-value и R-value. Все выражения
подразделяются на два вида. Бывает выражение, которое называется L-value. Давайте я прям такую
нарисую. Ну, значит, вот такую вот схемку. Значит, все выражения
бывают либо L-value, либо R-value. L от слова left, R от слова right. Это довольно странное историческое
такое название, исторически сложившееся. Но смысл вот в чем. Формальное определение осуществлять
не буду. Я веду неформальное, а формальное мы ведем сильно позже, возможно, во втором семестре. Но
неформально L-value это как бы то, что может стоять слева от оператора присваивания, а R-value это то,
что не может стоять слева от оператора присваивания. Исторически идея именно такова. То есть некоторым
вещам можно что-то присваивать, некоторым вещам нельзя что-то присваивать по смыслу. Вот,
например, если вы берете просто переменную какую-то, то она L-value, потому что ну как бы
ее, ей можно что-то присваивать. Если вы берете результат, допустим, сложение двух чисел x плюс y,
то ему нельзя ничего присваивать, потому что результат сложения это никакая не переменная,
это какое-то временное значение, которое вычислено на ходу, на лету, и оно в памяти,
возможно, даже не хранится никакой. Вот. И вот это интуитивное понятие того, что переменные
соответствуют какой-то ячейке памяти, и выражение просто вычислено на лету, и никакой ячейке
памяти не лежит, это вот формализуется в понятиях L-value и R-value. Ну, более правильно понимать L-value
как нечто, чему соответствует какая-то переменная, какая-то ячейка памяти соответствует,
а R-value — это то, что, возможно, вычислено на лету и никакая ячейка памяти ему не соответствует,
это такое временное значение. Так вот, каждое выражение, оно либо дает L-value в результате,
либо R-value. И L-value, как правило, это то, чему можно снова что-то присваивать, а R-value — это
то, чему нельзя присваивать. Почему я про это говорю сейчас? Потому что вот как раз операторы
пресваивания возвращают l-value в отличие от всех предыдущих упомянутых операторов.
Вот результаты всех предыдущих операторов, вот всех, которые здесь перечислены,
и в том числе вот этих, — это r-value. А вот результаты операторов пресваивания — это l-value.
Это значит, что можно, например, написать так. x равно y, и восьмой я думаю, пресвоить z.
А это будет означать, что я x-у сначала присвоил y, а потом x-у же я присвоил z. Вот по итогам оператор
пресваивания получается не просто значение такое получилось после пресваивания, а как бы сама
та переменная, которая получилась, и является результатом пресваивания. В данном случае x.
То есть после пресваивания получается та переменная, которой пресваивали. Вот поэтому
эта конструкция работает корректно. Если я результату пресваивания снова что-то присваиваю,
то получится, что я присваиваю тому же самому. Значит, итак, результат пресваивания — это l-value.
Ему снова можно пресваивать. А результат всех предыдущих операций — это r-value.
Идем дальше. Следующая операция — это инкремент и декремент.
Инкремент и декремент бывают префиксный и постфиксный. Что такое префиксный инкремент?
Это вот такой, который перед переменной ставится. постфиксный — этот тот, который после переменной
ставится. Аналогично декремент, значит, инкремент — это увеличение на единицу.
декремент — это уменьшение на единицу. Я буду говорить про инкремент только, а про декремент
все аналогично просто в обратную сторону работы. Префиксный от постфиксного чем отличается?
Префиксный инкремент — это такой, который увеличивает переменную единицу и возвращает
то что получилось, а постфиксный увеличивает переменную на единицу
возвращает то, что было.
Отсюда если подумать, можно сразу увести следствие.
Результат префиксного инкремента это сама переменная, которая
и была, а результат постфиксного инкримента это временное
значение, скопированное старое значение переменной,
а сама переменная уже равна другому числу.
Поэтому результат префиксного инкримента это L-value, а результат
постексовый инкремент, это R-value.
Значит, вот это L-value,
вот это R-value.
Соответственно, результату префиксного инкремента
можно что-то присваивать, результату постексового
инкремента нельзя ничего присваивать.
В общем, я делал
A++ и A++,
и у меня между этим разницы не было вообще.
То есть у меня значения
увеличиваются один в том и в другом случае.
Так, никто и не говорит, что разница в этом.
Значения A увеличиваются на один
и в том и в другом случае.
Просто результат первого, это увеличенное
на единицу значение, а результат второго
это предыдущее значение.
Если ты напишешь вот так
A было равно нулю до этого,
то ты получишь один.
А если выведешь A++,
то ты получишь ноль.
Вот в этом и разница.
Значения A должны измениться на один.
Значение A изменяется на один
и в том и в другом случае.
Но значение этого выражения
это и есть то, что получилось,
а значение этого выражения
это то, что было до увеличения.
Да, и при этом
первое это Lvalue,
а второе это Rvalue.
То есть результат вот этого выражения,
еще раз говорю, это сама переменная A
и, стало быть, ей снова можно
что-то присваивать, а результат второго
это скопированное старое значение
переменной A
и ему нельзя ничего присваивать,
потому что это временное значение,
которому не соответствует никакая переменная.
Так вот, инкремент и декремент
для себя требуют как оператор
присваивания Lvalue в качестве аргумента.
То есть я
не могу, например, сделать
++ от, не знаю,
A++. Вот если у меня есть
две переменных A и B, я сделал их сложение,
а потом попробовал инкрементировать то, что получилось.
Не получится, это будет ошибка
со словами Lvalue
required as
an argument of increment.
Значит, инкрементировать
можно только Lvalue.
Инкрементировать можно только переменные,
ну, то есть что-то, что в памяти
хранится, а не какие-то временные значения
выражений.
Ну и
вот если я, например, напишу так,
да, напишу
++ от
A равно 5.
Так можно написать,
потому что A присвоить 5 это
Lvalue,
оно снова
соответствует переменной A,
и после этого A еще инкрементируется.
Вот, да, можно ли
писать вот так,++ A
++.
Так можно.
Значит, вот это все OK,
вот это я зелененьким помечу, вот это OK.
А вот, например,
написать так,++
от A++,
это не OK.
Как в том меме с Гриффином.
Значит, вот это OK, вот это not OK.
Кстати, если оскобки
не поставлю,
как это будет распаршено?
Если я просто напишу++ A++,
это тоже будет не OK,
потому что пост-виксные операции
приоритетнее префиксных,
если к одному и тому же выражению
применена какая-то пост-виксная операция
и какая-то префиксная,
то пост-виксные считаются приоритетнее,
поэтому написать так без скобок
и это все равно, traps,
с такими скобками, это не OK.
Потому что это все равно, что вы пытаетесь делать префиксный инквимент.
Вот результат пост-виксное, то есть A thermovalue, так нельзя.
Ну хорошо, идём дальше. Дальше у нас ещё предстоит
обсудить парочку операторов. Вот. И ещё один оператор
важный, который я хочу обсудить, это тернарный
оператор. Тернарный — это значит, что у него три аргумента.
Ну, бывают операторы унарные, бинарные и тернарные. Вот
все предыдущие операторы были либо унарные, либо
тернарные. Вот это тернарный сейчас будет. Он единственный
такой, все плюс-плюс, поэтому он и называется тернарный.
Сразу всё становится понятно, он такой один. Значит, это
оператор, знак вопроса двоеточие. Это такой сокращённый
if, как бы, сокращённая условная конструкция. Как им пользоваться?
Вы пишите некоторые условия. Значит, condition. Ставите знак
вопроса. Дальше пишите первый expression. Дальше ставите
двоеточие и второй expression. Вот. Как работает этот оператор?
Он вычисляет этот condition. Он ожидает, что там будет
булевское значение. Если нет, то приводит его к булевскому
значению не явно. И дальше, если это true, то вычисляется
выражение 1 и возвращается его значение. Если это false,
то вычисляется выражение 2 и возвращается его значение.
Ну, например, я могу написать там x присвоить y больше нуля,
тогда 1 иначе 2, например. Вот. Получится, что в зависимости
от того, был ли x больше, был ли y больше нуля, x станет
равен либо единиц, либо двойки. Так работает тернарный
оператор. Тернарный оператор можно даже, значит, в левой
части присваивания. Например, я могу так написать y больше
нуля, тогда a иначе b что-то присвоить. Так тоже можно
делать. И еще интереснее, можно делать даже так. Допустим,
не знаю, y больше нуля, тогда a иначе b, значит, скажем,
точка size. Допустим, a и b это вектор или строки. Вот.
Вы можете написать там n равно и в зависимости от
какого-то условия, либо у одного вектора, либо у
другого вектора спросить размер. Так тоже можно делать.
Вот. Что по поводу вида value? Вид value тернарного оператора
зависит от того, какие виды value были у среднего аргумента
и у правого аргумента. Как вы видите, если я написал
вот так, то это l value, потому что я ему снова могу присваивать.
А если я написал вот так, то это будет r value. Ну, на
самом деле правило такое, если хотя бы один из аргументов
средний правый r value, то весь тернарный оператор считается
r value. В противном случае l value. Т.е. тернарный оператор
r value, если хотя бы один из аргументов r value. А, например, вот корректно
ли такое выражение? False, знак вопроса, a++, 2.++a, всему этому
присвоить единицу. Вот такое выражение. Такое выражение
некорректно, потому что слева от присваивания стоит
r value. А почему это r value? По формальному правилу, что
вот это r value, а это l value. Поскольку в тернарном
операторе хотя бы одна из частей r value, значит весь
тернарный оператор считается r value. Значит, ему присваивать
нельзя. Ну, казалось бы, у меня же здесь false написано,
и всегда будет вот это выбрано, а это не будет. Т.е. казалось
бы, этот тернарный оператор – это всегда вот это вот
значение, а никогда не это. Почему же тогда ему нельзя
присваивать? Потому что вид value выражения проверяется
раньше, чем вычисляется само выражение. Т.е. вычисление
выражения – это вопрос времени выполнения программы.
А анализ того, какой это вид value, то есть какой тип
и какая категория value выражения – это задача компилятора.
Компилятор не занимается вычислением выражений,
компилятор занимается анализом типов и анализом
видов value. И всё то, что я сейчас говорю – это ошибки
компиляции. Вот я когда сейчас говорю какое-то выражение
некорректно, я имею в виду, что компилятор выдаст ошибку
компиляции. Проверка видов value, как и проверка корректности
типов происходит на этапе компиляции. Поэтому вот это
не корректно с точки зрения компилятора. Не важно, что при его вычислении всегда получится
реально lvalue. Важно, что формально, по виду выражения, оно rvalue, а значит присваивать ему
компилятор запретит. Ну и что, что на практике в рантайме получится что-то хорошее? Мы не можем
заранее вычислять, мы должны сначала проанализировать виды value и типы. И компилятор запретит такое
присваивание. Что-то еще забыл сказать про тернарный оператор, а и вот что забыл сказать. В тернарном
операторе работает следующее правило, как и в булевских операторах, что если условие истинно,
то правый аргумент не вычисляется, а если условие ложно, то левый аргумент не вычисляется. То есть,
если здесь false, то вот это не будет выполнено, а если здесь true, то вот это не будет выполнено.
Ну то есть вы можете написать допустим там какое-нибудь условие х больше нуля,
знак вопроса, a++, 2.b++ и быть уверенным, что ровно один из инкрементов выполнится.
Вот. Это тернарный оператор. Ну вы на семинарах наверное еще пообсуждаете тернарный оператор и
какие-нибудь придумаете примеры его использования. Тернарный оператор я рекомендую в коде использовать,
но с умом. То есть, если у вас есть какой-то if, вот например, если вы хотите написать if х больше нуля,
то а присвоить 1 иначе b присвоить 1, это разумно заменить на тернарный оператор. Но если у вас там
огромный многоуровневый if, то лепить вереницу тернарных операторов наверное не стоит. Короче,
пользуйтесь с умом. Да, ну еще один момент, последний наверное про тернарный оператор,
который я сейчас скажу. Это то, что типы выражений вот этого и вот этого тоже должны быть,
но если не одинаковыми, то хотя бы приводимыми друг к другу. Например, если вы сделаете тернарный
оператор, у которого значит тут скажем false знак вопроса два с половиной двоеточие два, то тип этого
выражения будет double. Несмотря на то, что как казалось бы всегда возвращается if, но тип выражения
это понятие времени компиляции. В вычислении выражений компилятор, еще раз повторяю, он не
занимается. Задача компилятора понять все типы и понять все виды value. В данном случае, чтобы понять
тип выражения, компилятору нужно найти общий тип между средней и правой частью. Поэтому тип
этого выражения это double, несмотря на то, что при вычислении реально будет всегда int получаться,
но нет. Поэтому если, например, у вас есть какая-нибудь функция f и вы решите ее вызвать вот от такого,
то выберется версия от double. Представьте, что у вас есть версия от int и от double и вы вызвали f вот
от такого выражения. Выберется версия от double, потому что тип выражения double. Тип выражения это
понятие времени компиляции.
А можете немножко ниже опустить? Там не видно было нижнюю строчку.
Так что ли?
Да, спасибо.
Окей.
Так, предпоследний оператор, о котором я расскажу, это оператор запятая.
Это, пожалуй, самый кринжовый оператор C++.
Значит, оператор запятая — это следующая вещь. Это такой оператор, который вычисляет
левую часть, вычисляет правую часть и возвращает правую часть, и больше ничего не делает.
Вид value у него такой же, как у правой части, и тип этого выражения такой же, как тип правой части.
Зачем это нужно? Ну, если вам захотелось несколько выражений в строчку записать,
то вы можете это сделать с помощью оператора запятая.
Это звучит неубедительно, я понимаю. Не очень понятно, зачем это может быть нужно.
Ну вот, поверьте, бывает полезно. В общем, пару раз, наверное, за этот год мы столкнемся с ситуацией,
когда нам нужен будет оператор запятая, и вот когда он окажется нужен, это будет очень такой
катарсис. Но пока что выглядит немного как кринж.
Ну, соответственно, вы можете, например, вот так писать. Это корректно. То есть,
запятая возвращает правую часть, и вид value такой же, как у правой части. То есть,
вот написать так — это всё равно, что b присвоить единицу. Вот, можно вот так написать a,
присвоить b, запятая c. Это всё равно, что a присвоить c. Вот. Ну, можно писать plus plus x,
запятая plus plus y. И этому ещё что-нибудь присвоить. Так тоже можно. Это значит,
что x увеличится единицу, y увеличится единицу, а потом y присвоится 2.
Здесь надо сделать важную оговорку, что не всякая запятая является оператором. Вот,
вы можете подумать, например, что самое распространённое заблуждение, которое люди
делают, это что вот, например, если у вас есть функция какая-то, voidf от int x запятая int y,
то они думают, ну вот, наверное, вот это оператор запятая. Нет, конечно, это никакой не оператор
вообще. То, что это является символом запятая, это не значит, что является оператором. Операторы
встречаются только в экспрешенах, в выражениях. А это никакой не экспрешен, это список аргументов.
Точно так же, как когда вы пишете include и ostream, вот это же не оператор меньше, правда? А это не
оператор больше. Ну и что, что символы используют те же самые? Вот это не оператор меньше, потому
что это совершенно другая синтоксическая конструкция. Здесь вообще речь об операторах, никакой не идёт.
И это точно так же не оператор запятая. Поэтому, значит, например, когда вы пишете f от, когда вы,
например, вызываете функцию f от plus plus x запятая plus plus y, представим, что f это некоторая функция.
Здесь нет гарантии, что сначала сделается plus plus x, потом сделается plus plus y. Вот. И,
например, если вы вызовете функцию от plus plus x запятая plus plus x ещё раз, то нет гарантии,
что второй аргумент будет больше, чем первый. Вот в такой конструкции, в таком выражении,
в вызове функции, это не оператор запятая. Это потому что вот это вот не экспрешен, а это просто
перечисление аргументов функции. Вот всё вместе это экспрешен. Но просто список аргументов функции
внутри скобок, это не экспрешен. Поэтому здесь неприменимо правило, как к оператору запятая,
что сначала вычитается левая часть, и только потом правая. Вот в операторе запятая это верно,
а в списке аргументов функции это не обязательно так, и нет гарантии, что будет левый аргумент
меньше правого в итоге. Точно так же не является оператором запятая, когда вы объявляете несколько
переменных на одной строке. Вот это не оператор запятая, и более того, вот это не оператор
присваивания. Вот это может вообще кого-то сильно шокировать, но вот когда вы объявляете переменную
и инициализируете её, пишете равно, вот это не считается оператором присваивания, и работает оно
по другим правилам. Если, например, для своих типов вы переопределите присваивание как-то по
особенному, то оно не будет вот здесь вот работать, потому что это не присваивание. Символ равно используется
такой же как и для присваивания, но по факту это никакой не оператор, потому что это объявление,
а не expression, а expression является только вот этой частью, в этой конструкции.
Так, это что касается оператора запятая. Ну и последний полезный оператор, о котором мы сейчас
поговорим, это... Да, очень слышно из-под воды тебя, говори как-то по-другому.
Извините, можно еще буквально одно слово, что делать запятая, просто я немножко это...
Запятая еще раз берет и вычисляя. Она сама по себе ничего не делает. Запятая это просто способ
вычислить несколько выражений подряд, фактически. То есть что формально такое запятая? Это значит
вычисли левую часть, строго после этого вычисли правую часть и результатом объяви правую часть.
Вот и все. Между левой и правой частью ничего не делается. Просто вычислять сначала левая часть,
потом правая, вот и все. Вот допустим, вот это две скобочки A запятая B равно 1, то я просто
попробовал, у меня получилось что-то странное. Ну это все равно, что просто написать B равно 1.
А в чем смысл этого действия тогда? Запятая это просто последовательное вычисление
нескольких выражений, одно за другим. Да, ну а A равно B скобочкой запятая C? Это все равно,
что A равно C. Запятая просто вычисляет это выражение, вычисляет после этого выражение и
возвращает то, что получилось справа, то есть C в данном случае. Написать так, это все равно,
написать вот так. А плюс плюс X плюс плюс Y равно 2, это значит сначала увеличить X на 1,
потом увеличить Y на 1, вернуть то, что получилось после вот этого и вот ему присвоить 2. Просто
какая-то странная операция получается, непривычная. Ну она довольно забавная,
да она довольно странно себя ведет, возможно. Но иногда бывает полезно, редко, но бывает.
Так, чего пишут в чате? X равно 0, запятая Y равно 1. Можете еще раз сказать, что тут оператор. Тут
нет ни одного оператора. Вот в этой вот записи нет вообще ни одного оператора. Это не оператор,
это не оператор и это не оператор. Потому что равенство, которое используется при объявлениях,
не является присваиванием, а запятая, который используется для перечисления объявлений,
тоже не является оператором запятая. Поэтому в этой записи, в этом объявлении, нет ни одного
оператора. Соответственно, для чего это надо знать? Надо для того, что если вы будете определять
операторы для своих типов и будете писать вот такое, то не удивляйтесь, что они не будут
действовать, потому что это никакие не операторы. Внутри запятой может быть присваивание,
что внутри запятой? В смысле? Ну, конечно, может. Любые выражения могут быть разделены
запятой. Пожалуйста, запросто. Любые экспрешены. Слева любой экспрешен, и справа любой экспрешен.
А через плюс можно писать три выражения? Да, можно. Просто это будет партия,
то же самое и запятой. Если вы напишите A, B, C, это будет все равно, что вот так написать.
Запятая лево ассоциативно, как и плюс, как и другие арифметические операторы, как и большинство операторов.
Спасибо. И все-таки последний оператор, о котором я сейчас расскажу, это оператор Сайзов.
Сайзов – это оператор, он довольно нам будет часто нужен для разных учебных примеров, да и вообще по
жизни. Это такой встроенный оператор, и он же является ключевым словом языка C и C++. Ну,
то есть встроенным язык словом, которое имеет предопределенное значение. Этот оператор,
который позволяет узнать размер в байтах данной переменной или данного типа. Я могу
написать Сайзов от какой-то переменной и получить число, обозначающее количество байт,
которое эта переменная в памяти занимает. Так я могу, например, узнать, сколько байт
занимает int у меня. Например, если у меня есть int A, я могу вывести Сайзов от A и узнать,
что это скорее всего 4. Вот так я могу и для остальных переменных сделать. И на самом деле я
могу писать Сайзов даже не от переменной, а просто от типа. Сайзов от int, например. И я узнаю размер
переменной типа int. А Сайзов от вектора будет капасити его выдавать, да? Вот, значит, очень
правильный вопрос, что будет выдавать Сайзов от вектора. Надо понять следующую вещь. Сайзов
от любой переменной — это константа, причем известная на этапе компиляции. Сайзов — это
количество байт, которое занимает в памяти именно переменная. И результат Сайзова известен всегда
на этапе компиляции. В частности, для вектора это будет, скорее всего, 24. Почему для вектора это
всегда… Независимо от того, сколько элементов лежит в векторе, Сайзов от вектора — это одно и
то же число. Почему? Потому что элементы вектора, они не относятся к памяти, которая относится
самопеременной вектор. Когда у вас есть вектор, вектор, он на самом деле устроен как? В нем есть,
ну как бы, поля, то есть в нем есть число, которое обозначает, сколько в нем элементов, число,
которое обозначает, под сколько элементов память выделено, а также в нем есть поинтер,
который указывает на массив из самих элементов. Вот когда вы заводите вектор, переменная В
представляет из себя вот такую вот структуру. В, сам вектор, это же динамический массив, и в нем
есть вот этот вот указатель на какой-то storage, который хранится в другой памяти. И вот размер
вектора, вот это вот, это V.Size, а вот это вот, это Сайзов от V, и это разные вещи, это надо
обязательно не путать, то же самое со стрингом строкой. Когда у вас есть строка, то Сайзов от
строки — это просто сумма размеров ее полей, а V.Size — это количество элементов, которые выделены
этой строкой, но сама переменная S, как и сама переменная V, она фиксированное количество байт
занимает. Понятно? Вот это очень важная разница, это надо не путать. Мы с вами в дальнейшем обсудим
подробно, как устроен вектор, разумеется, и как строка устроена. У вас будет даже задание написать
свою реализацию строки, вот одно из первых заданий в этом семестре скоро, и вы поймете,
как это работает, но пока что просто знайте, что Сайзов от строки и строка точка Сайз — это
разные вещи. Вот, мы не будем вызывать Сайзов пока от вектора, мы будем Сайзов пользоваться для
примитивных типов, чтобы узнавать их размер. Простите, а в переменной Capacity, что содержится,
она у вас в табличке, в второй строке? У вектора есть, вам, я не знаю, уже рассказывали об этом на
алгоритмах или нет, но у вектора есть количество элементов, которые в него положено, а еще у него
есть зарезелированная память, и size — это количество элементов, которые реально лежит в нем,
а Capacity — это количество элементов, под которые память выделена. Size — это количество элементов,
хранящихся в нем, а Capacity — это количество элементов, под которые память выделена.
Понял, спасибо.
Сайзов возвращает, я думаю, что он возвращает sizeT, а не int.
Я думаю, что тип возвращаемого значения Сайзов — это sizeT, ну то есть тот самый тип,
который нужен для индексации, для размера, ну или unsigned, ну вряд ли int, он же беззнаковый.
Так, это, пожалуй, все, что я хотел рассказать про операторы, но не совсем. Значит, последняя вещь —
это таблица приоритетов операторов. Сейчас я вам ее покажу. Для этого мне нужно расшарить вам
другой экран. Сейчас я это сделаю. Вот на сайте CPReference мы можем найти такую таблицу,
в которой перечислены приоритеты операторов. Ну вот здесь перечислены все операторы,
которые есть в языке C++. Мы с вами рассмотрели не все из них. Часть из них мы рассмотрим позже,
а часть мы, возможно, даже и не будем рассматривать в этом курсе, но большую часть из них мы и так
рассмотрели. Смотрите, это самым приоритетным является scope resolution. Ну, формально это не
совсем оператор, но можно его в некотором приближении таковым считать. Это когда вы
пишете std 2.2.cout. Вот когда у вас есть expression std 2.2.cout вправо-вправо x, влево-влево x,
то понятно, что вот эта 2.2. в первую очередь выполняется. То есть оно как бы самое приоритетное.
Дальше у вас идут поцсексные унарные операторы, дальше у вас идут префиксные унарные операторы,
дальше идут бинарные операторы вот в таком порядке. Причем вот здесь про каждую группу
операторов написано её ассоциативности. Слева направо, справа налево, вот эти бинарные операторы
ассоциативны слева направо, вот эти бинарные операторы ассоциативны справа налево,
и запятая опять слева направо. Про запятую следует помнить, что у неё самые низкие
приоритеты всех вообще операторов, на самом низу таблиц приоритетов проходится. Надо понимать,
что означает приоритет операторов с формальной точки зрения.
Вот некоторые думают, что приоритет операторов — это то,
в каком порядке реально будут происходить вычисления, это неправда.
Вот сейчас я попробую вам объяснить, как правильно понимать приоритет операторов.
Вот представьте, что у меня есть выражение, но я не знаю, ну давайте я напишу какое-нибудь выражение.
Ну вот такое давайте напишу выражение.
Вот это некоторые expression.
Когда компилятор синтоксически парсит это выражение, он во-первых понимает,
что это выражение, а не объявление, и дальше его задача — понять,
какой оператор обладает самым низким приоритетом в этом выражении.
Самым низким приоритетом, согласно таблице, в этом выражении обладает вот этот оператор.
Это значит, что компилятор начинает строить дерево синтоксического разбора вот так.
Он понимает, что вверху этого выражения стоит вот этот оператор, и его левым
аргументом является вот такая штука, а правым аргументом является вот такая штука.
Дальше каждый из этих под- выражений он парсит отдельно.
Здесь он видит, что есть оператор, вот такой, а здесь вот такой.
И он понимает, что левым аргументом этого оператора является нечто под названием
Estd, а правым — нечто под названием Seout, а здесь левым аргументом является
под названием x, а правом нечто под названием 5.
Если предположить гипотетически, что у плюса был бы приоритет
ниже, чем у оператора побитого с двигателем, то выражение
выпарщилось по-другому.
Ну вот, например, если я возьму вот такое выражение
std seout x присвоить 5.
Ситуация кардинально поменяется.
А именно, здесь уже наименьшим приоритетом обладает вот
это.
И тогда в дереве синтоксического разбора вверху будет стоять
вот это, и его правым аргументом будет 5, а левым аргументом
будет выражение std seout x, соответственно, дальше
это распадется на x и std seout, ну и дальше это распадется
на std и seout.
Вот что такое приоритет операторов.
Приоритет операторов — это на самом деле правило
того, как компилятор строит синтоксическое дерево
разбора.
Вот у вас есть выражение, его надо синтоксически разобрать,
надо понять, это какая операция над какими аргументами.
Вот приоритет как раз говорит компилятору о том, какая
операция стоит вверху синтоксического дерева, и что является ее
аргументом, и дальше он рекурсивно разбирает ее
части.
Что означает ассоциативность в этом смысле.
Вот, например, если у вас написано a plus b plus c, что означает,
что плюс лево ассоциативен.
Это значит, что если у вас на верхнем уровне находится
несколько операторов одинакового приоритета, то вверху окажется
тот из них, кто левее.
Вот тот факт, что плюс лево ассоциативен, означает,
что дерево будет построено так.
Если бы плюс был право ассоциативен, то дерево было бы построено
стартуя с этого плюса.
Соответственно, если у вас там есть, ну, можете самостоятельно
поупражняться, если у вас есть длинное выражение,
в котором много операторов, то вы можете самостоятельно
построить деревья синтоксического разбора для этих выражений.
Вот, и здесь есть одна обманка, одна важная для понимания
вещь.
Тот факт, что дерево синтоксического разбора так выглядит, не
означает, что реальные операции будут выполняться именно
в таком порядке, как написано согласно дереву синтоксического
разбора.
То есть, что я имею в виду?
Представьте, что у вас, например, есть такое выражение.
А умножить на b, плюс c умножить на d, плюс e умножить на f.
Давайте я, наверное, даже отдельную строчку напишу.
А умножить на b, плюс c умножить на d, плюс e умножить на f.
Ну, дерево синтоксического разбора для этого выражения
будет выглядеть так.
Сначала левый плюс, слева от него а умножить на b,
дальше справа правый плюс, и здесь c умножить на d,
а здесь d умножить на f, и e умножить на f.
Вот.
Понятно, что значение этого выражения определено
однозначно в целом, то есть, что результатом этого
выражения будет сумма трех произведений, но нет совершенно
никаких гарантий относительно того, какой именно из произведений
раньше посчитается.
Компилятор может сначала посчитать это, потом посчитать
это, потом посчитать это и сложить, ну вот, он может
сделать вот так, сначала это, потом это, потом это.
Он мог бы сначала вот это посчитать, потом это,
потом это, потом сделать вот так, потом вот так.
Он мог бы, значит, сначала посчитать вот это, потом
посчитать и это, потом их сложить, потом посчитать
и это, а потом только сложить итоги.
То есть, тот факт, что синтоксически эта конструкция распарсилась
единственным возможным образом, не означает, что порядок
вычислений будет именно таким, как написано слева-направо.
Это очень важное понимание, которое надо держать в
голове.
Приоритет операторов говорить лишь о том, как синтоксически
компилятор видит эту запись, но не о том, что реально
будет происходить в раундтайме.
Приоритет операторов — это понятие этапа компиляции,
а понятием этапа выполнения является так называемый
order of evaluation — порядок вычисления выражений.
И это другая штука, про которую мы попозже поговорим.
Что-то в чате написали, приоритет умножения выше
приоритета сложения.
Я об этом и говорю, что эта конструкция будет распаршена
вот так, за счет того, что приоритет умножения выше
приоритета сложения.
Если бы приоритет умножения был ниже приоритета сложения,
то эта конструкция была бы распаршена так, что у
вас на верхнем уровне идет умножение, ну то есть,
эта конструкция была бы распаршена вот так.
У вас тут три умножения, и было бы сначала A умножить
на вот это, потом умножить на вот этого.
Нет, приоритет умножения выше приоритета сложения,
именно поэтому синтоксическое дерево разбора вот так выглядит.
Но это все еще не имеет никаких гарантий относительно
о, в каком порядке будут вычислены вершины этого
дерева.
Понимаете разницу между приоритетом и порядком
вычислений?
Это важная разница.
Приоритет не говорит о том, в каком реальном порядке
будут вычтения происходить.
Приоритет дает лишь понимание, чему равно значение выражения.
Напоследок поговорим про control statement, то есть, про
управляющие конструкции.
Значит, мы закончили говорить про операторы, и сейчас
поговорим про управляющие конструкции.
Третий вид стейтментов, который может встречаться
у вас в функциях, это control statement.
Значит, это будет у нас параграф 1.5 в нашем повествовании.
Я назову файл просто control.
Итак, вот у вас есть main, и что я могу здесь написать
из управляющей конструкции?
Управляющая конструкция – это значит такие штуки,
которые влияют на ход выполнения программы каким-то образом.
Наверное, самая простая, самая известная дика – taif.
Значит, как выглядит taif?
Я пишу taif, да, я заголовок сейчас сделаю, 1.5 control statements.
Значит, как пишется taif?
Если условие какое-то, то есть, вот здесь вот пишется
булевское выражение, которое, ну, то есть, здесь пишется
выражение, которое должно быть приведено к типу буль.
Здесь можно написать любое выражение, лишь бы оно к
типу буль было приводимо.
И дальше я пишу, соответственно, какой-то набор других инструкций,
причем я могу либо написать одну инструкцию, и тогда
мне фигурных скобок писать не надо, либо я пишу несколько,
тогда я их в фигурных скобках пишу.
И вот здесь вот у меня новая областидимость начинается,
более локальная.
Вот.
Я могу написать так, могу написать if boolexpression и какой-то
statement без фигурных скобок.
Вот.
Так тоже можно, тогда по default будет только вот этот statement.
По кодстайлу мы, наверное, так будем стараться пореже писать,
вас приучать писать в основном с фигурными скобками, но если
какой-то if очень короткий, нужно сделать что-то очень маленькое,
там if x больше нуля и y плюс плюс.
Ну, хорошо, можно писать так.
Я пишу if x больше нуля, там и, значит, говорю y плюс плюс.
Вот.
Это корректно, по default будет только это.
У if есть else clause, так называемый, то есть я могу опционально
после этой закрывающей фигурной скобки написать
еще else, и здесь будет написано то, что нужно сделать, если
условия не выполнены.
Вот.
Ну.
Заметьте, кстати, кодстайл.
Вот.
Многие пишут вот так.
Это мы будем банить.
По кодстайлу, который рекомендует Google, который рекомендует
Яндекс, который будем рекомендовать мы, else пишется на той же
строке, на которой была предыдущая закрывающая фигурная скобка,
и призываю вас также делать.
Ну вот так не надо делать.
Вы можете после else написать еще if, и по кодстайлу опять-таки
это пишется на той же строке, на которой else, значит else if,
и дальше какой-то там еще expression, bool expression.
Вот.
Вы можете таким образом делать сложные составные
условия.
Вот у вас есть один if, если он не верен, то проверьте
другой if и так далее.
Вот.
Надеюсь, что вы не будете делать так.
Тут некоторые зачем-то делают так, они берут и
каждый следующ if начинают еще на уровень глубже.
Вот так не надо делать, потому что вот эта запись,
она по сути эквивалентна предыдущей записи, только
на больший уровень вложенности спущена.
Вот.
Если вам нужно несколько if проверить один за другим,
то оставляйте их на одном уровне, а не задвигайте
в более глубокий уровень вложенности.
Вообще уровень вложенности надо экономить.
Вообще, кстати, есть такое наблюдение, это скорее
наблюдение из области кодстайла, и оно у вас будет в кодстайле
написано, который я вам скину, а что на самом деле
else не так часто нужен.
Вот.
На практике, в большинстве случаев, когда вы пишете
else, можно обойтись без него, и код проще станет.
Вот.
Последите за собой.
На самом деле, когда вы что-то делаете при условии
каком-то, обычно то, что вам нужно сделать без
этого условия, это является подмножеством действий,
которое нужно сделать при условии, и можно общую
часть просто вынести из-под if, и у вас останется, ну
как бы, код станет короче, исчезнет из него кэппипастные
строки.
Бывает такое, что при условии и при нарушении условия нужно
сделать принципиально разные действия, вообще не похожие
друг на друга, но чаще все-таки бывает так, что при условии
вам надо что-то сделать, а при отсутствии условия
сделать что-то, но поменьше, или наоборот.
То есть, оно является подмножеством другого.
В таком случае не нужно писать else, нужно просто вынести
общую часть наружу за if, и оставить только if без else.
Так просто код красивее будет.
Значит, спрашивают про код стайл, первую скобку
после if.
Ну, в нашем код стайле мы рекомендуем делать вот
так.
Ну, опять-таки, это код стайл, который рекомендуется
гуглом и яндексом, и он вот такой, мы будем ему следовать.
У гугла и яндекса плюс-минус общий код стайл по C++, вот
он такой.
А сколько мы будем пробелов ставить в табли?
В табли можно ставить либо 4, либо 2 пробела, главное,
чтобы одинаково в течение всей программы.
И вместо таблов нужно всегда ставить пробелы, самими
таблами мы никогда пользоваться не будем, но у вас будет
отдельный семинар, посвященный код стайлу, вскоре, и там
вы про все это поговорите.
Хорошо, if обсудили, давайте обсудим switch.
Следующую управляющую конструкцию это switch, значит,
что такое switch?
Это способ выбрать из многих вариантов, что делать.
Так пишется switch x, где x – это целое число, ну или
здесь некоторые волочительные выражения можно написать,
и в зависимости от чего, от чему оно равно, вы можете
делать разные вещи, например, case 1, если оно равно единице,
то что-то сделать.
Значит вот, do something, а дальше case 2, еще раз do something, ну
и так далее, case 3, еще do something.
Не обязательно случаи делать подряд, и вообще не обязательно
они хоть как-то должны быть упорядоченны, я могу сказать
case 1, потом case 8, case 5, и тут опять do something, так, вот.
В конце я могу сказать default, default это на случай, если
у меня ни один из кейсов не сработал, и после default
я опять могу сказать что-то сделать, и это будет сделано
в случае, если вот ни один из предыдущих кейсов не
выполнился.
Тут есть одна очень большая подлость, а именно в C++, как
и в C, switch работает следующим образом, что если у вас какой-то
кейс выполнился, то считается, что выполнены все кейсы
после него.
Ну то есть, что это значит?
Если x сейчас был равен единице, я встану вот на эту метку
и выполнится не только вот это do something, а все ниже
лежащие тоже.
То есть, как бы формально находится просто первая
метка, которая соответствует тому, чему надо, и все, что
ниже нее выполняется, буквально делается прыжок на вот эту
метку, и все, что ниже нее выполняется.
Если вы хотите, чтобы у вас выполнилось только то,
что находится вот в этой секции, но не то, что ниже
до следующих меток, вы здесь пишете break, break это управляющее
слово, которое говорит, что, ну, закончим, выходи
отсюда.
Вот в данном случае, если у меня x равен единице, выполнится
только это.
Если x равен восьми, впрочем, выполнится и это, и это, и
это.
Если x равен пяти, то выполнится вот это, и это.
Если x не равен ничему из вышеперечитенного, то выполнится
только это.
Я могу написать break вот здесь, допустим, а здесь
не писать.
Тогда при восьмерке у меня выполнится и это, и это.
При пятерке выполнится только это, при всех остальных
значениях выполнится только это.
Вот.
Ну, обратите внимание опять на код style, но только я ставлю
отступы.
То есть после switch я ставлю фигурную скобку, и дальше
у меня есть вот, как бы, внутренняя область видимости,
метки, вот эти кейсы, я ставлю на том же уровне,
на котором стоял switch, а то, что внутри, я пишу уже
собственному.
Так, это по поводу switch.
Теперь циклы.
Ну, есть цикл while, да, опять плохо слышно.
Извините, сейчас, то есть, если кратко, то switch, мы говорим
switch, просто пишем далее кейс какой-то, какой-то,
какой-то.
Да.
Типа кейс один, кейс восемь, кейс пять.
Ты хочешь проверить, чему равен х?
Нет, я хочу понять, откуда берутся номера.
Нет, в смысле, тебе здесь написано буквально следующее,
если х равен одному, то сделай это, иначе, если х равен
восьми, то сделай это, иначе, если х равен пяти, то сделай
это, иначе сделай это.
Это просто более короткий, более, ну, так сказать, правильный
способ выбрать из нескольких вариантов, чему может быть
равен х.
Вместо того, чтобы писать if, else, if, else, if, else, if, можно
писать switch и просто для разных вариантов сделать
разные.
И, типа, он первый, он прыгает на первую метку, которая
выполнится, и все, что ниже, заведомо делает, если нет
брейка.
Да, да, до ближайшего брейка, и до ближайшего брейка
делает.
А дефолт всегда делает.
Дефолт – это если ни одна из этих меток не сработала.
Если он все метки проверил и ни одна из них не выполнилась,
то он делает то, что после дефолта написано, но дефолт
необязательно писать, может не быть никого дефолта,
тогда просто ничего не сделает, если ни одна из меток не сработает.
То есть, если ни что не сработало, окей.
Да.
Так, значит, это был switch.
Теперь циклы.
Ну, самый простой – это цикл while, здесь у вас какое-то
буллевское выражение, и тут какой-то набор действий.
Ну как работает while – проверяется, истинно ли вот это, если
истинно, то выполняется то, что в фигурных скобках,
и снова проверяется – истинно ли вот это, если истинно,
то выполняется то, что в ущербных скобках, и снова
проверяется – истинно ли вот это, если истинно, то
выполняется то, что в ущербных скобках, ну и так далее.
А если в любой из этих моментов оно ложно, то то, что фигурно
скобки не выполняем, сразу начинает выполняться то,
что после идёт.
А точно так же с while как и с if можно у вас может быть инструкция из одного просто действия
состоять и не обязательно фигурные скобки тогда ставить. Но по код стайлу мы будем вот в циклах
всегда требовать фигурные скобки, потому что иначе это трудно читаемый код и не рекомендуется так
делать без фигурных скобок цикла писать. Хотя формально это корректно так писать. Здесь может
быть любое буллевское выражение, в том числе и то, которое приводится к буль, хотя само тип буль
явно не имеет. Этот цикл с предусловием. Есть цикл с постусловием do while. Он выглядит так do
фигурной скобки а дальше while и здесь какое-то условие.
Значе точка запятой вот здесь ставится. Как это работает? выполняется в любом случае то, что
в фигурных скобках. Потом только проверяется условия и если оно верно, то снова выполняется
то что в фигурных скобках и опять проверяется условие если оно верно то опять выполняется то
в фигуроскопках и так далее. Как только это условие становится неверным, мы идем дальше выполнять.
Вот. Понятно, что в чем разница между вот этим циклом и вот этим принципиально? В том, что в этом цикле,
если условие изначально ложно, то цикл не выполнется ни разу. Если в этом цикле условие изначально
ложно, то цикл выполнится один раз все равно и только потом проверит условие и перестанет выполнять.
Это цикл с предусловием, это цикл с постусловием. Ну и самый мощный цикл. Да, с do-while тоже возможно
всего одно действие. То есть, например, я могу написать do++x while какое-то условие. Вот я могу
так даже написать. Но опять-таки по код стайлу мы так не будем рекомендовать писать, а будем
требовать фигурные скобки. While пишется на той же строке, что и закрывающая фигурная скобка
перед ним. Ну и самый мощный цикл это for. Значит, for на самом деле позволяет имитировать все остальные
циклы и вообще, строго говоря, вам другие циклы-то и не нужны, все можно for-ом сделать. Но они
используются для красоты, это такие более простые циклы, что ли, для минималистичной версии.
Что делает for? Значит, у for следующий синексис for initializer, дальше bool expression, дальше iteration
и здесь тело цикла. Значит, что такое initializer? Это некоторое объявление или выражение,
которое будет проделано в самом начале цикла. Если это объявление, то вы тем самым ведете
переменную область видимости, которая будет считаться вот этим вот циклом и тем, что внутри
него. Вот. Ну, традиционный способ, что здесь можно написать, это объявить какой-нибудь счетчик int
и равно нулю, например. Вот. Я могу здесь объявить несколько переменных. Я могу не обязательно int
объявить, я могу объявить какой угодно тип. А я могу вообще ничего не объявлять, могу просто изначально
что-то сделать. Вот так, например, могу сделать, если и до этого был какой-то переменный. То есть
здесь я могу сделать любое объявление или expression. Любой абсолютно declaration или expression
здесь подойдет. Ну, declaration переменной я имею в виду. Понятно, что не могу здесь объявить using или
объявить функцию. Переменную я могу только объявить. Могу несколько переменных объявить через запятую.
И это все еще не будет оператором запятая, напоминаю, в объявлениях. Вот это не оператор запятая.
Дальше Boolean expression. Здесь любой expression, который приводится к bool. Например, проверка того,
что и меньше чего-нибудь. И меньше десяти. Но здесь может быть любой boole expression. Здесь может
быть любой expression, который будет приводиться к bool. Если он не приводится к bool, то будет ошибка
компиляции. Итерация это просто любой expression. Вообще любой expression. Как правило, здесь пишут
increment, но можно делать и decrement. А можно делать и плюс равно два, например. А можно делать что-то
вообще не связанное со счетчиком. Можно говорить аито равно одному. Аито равно и. И, пожалуйста,
вы просто будете так, значит, можно вот так написать, и вы будете просто все элементы какого-то
массива А приравнивать очередному индексу И. А это вот уже оператор запятая. И таким образом
вы в одном expression и присваивание делаете, и increment. Вы можете и вот так делать. Вы как бы
присвоили и после этого и увеличилось. Извините, а корректно ли по двумерному массиву проходить
одним таким циклам в форум только с двумя initializers или это некрасиво? Нет, ну это корректно,
но это некрасиво. Вы можете синтоксически вам сказать, здесь можно любой declaration,
в том числе несколько переменных объявить. Здесь любой boole expression, а здесь вообще любой
expression. В том числе здесь может быть присваивание оператора запятая, тиранарная оператор,
что угодно. Любой экспривызов функций здесь может быть. Здесь может быть куча действий
через запятую. Это все будет expression. Синтоксически это будет корректно. Компилятор это скомпилирует,
но рекомендуется все-таки писать так, чтобы понятно было. Стандартный самый вид цикла
for это вот такой, то есть когда вы берете счетчик и этим счетчиком проходите до какого-то значения,
а потом выходите. Здесь вы делаете значит какие-то действия. Как работает for? Сначала
происходит вот этот declaration или expression, так сказать, инициализация цикла. Сразу же проверяется
условия. После этого выполняется тело цикла, если оно истинно. Дальше, после того, как тело цикла в
первый раз выполнилось, впервые делается вот это выражение, вычисляется. И снова проверяется
условие. Если условие истины, мы опять заходим в тело цикла и опять вычисляем вот это выражение,
а потом опять проверяем условие и опять заходим в тело цикла. Потом опять вычисляем это выражение,
опять заходим опять проверяем это условие и опять заходим в тело цикла. И так мы делаем
до тех пор пока наконец не произойдет такого, что это выражение ложно. Как только это выражение
выражение ложно, мы перестаем заходить в тело цикла и дальше идем сразу сюда.
А, значит, вот.
Можно в форе любую из вот этих трех секций оставить пустой,
то есть можно, например, ничего вот здесь не написать,
это будет означать, что вы просто ничего не объявили вначале,
ну и ничего не сделали.
Можно вот эту секцию оставить пустой, и тогда это будет считаться,
как будто все время у вас true.
А можно вот эту оставить пустой, и тогда будет считаться просто,
что вы ничего на каждой итерации не имплементируете, ничего не делаете.
Можно просто вот так написать, и это будет бесконечный цикл.
Вот.
А существует два управляющих слова, которые позволяют,
так сказать, влиять на ход выполнения цикла.
Это break и continue.
Значит, слово break внутри цикла означает, что нужно выброгнуть из цикла,
независимо от того, какие там у вас были условия от цикла,
просто как только встречается команда break внутри цикла,
все, с этого момента из цикла происходит выход,
и вы сразу же оказываетесь вот здесь.
Ну, обычно никто не пишет break просто так, обычно break пишут по default,
то есть если там что-то произошло, то break.
То есть вы делаете, делаете цикл, и вдруг в середине цикла вы поняли,
что если что-то случилось, то надо сразу же выпрыгнуть из цикла.
Когда происходит break, вот здесь больше никакие условия не проверяются,
ничего не вычисляется, вы сразу же выходите вот сюда.
При этом, разумеется, все локальные переменные, которые действовали внутри цикла, уничтожаются.
Вы остаетесь только с теми локальными переменными, которые были во внешней области.
Вот, к сожалению, в C++, как и в C, нельзя сделать break сразу с нескольких уровней,
можно сделать break только из цикла, и только из самого вложенного цикла.
А как же go2?
Ну, go2 это вообще другая история, про него я сейчас вкратце скажу,
но именно словом break сделать выпрыгивание на 1 уровне вверх, например, нельзя.
Вот, ну и второе слово, которое позволяет управлять ходом выполнения цикла, это continue.
Это еще одно ключевое слово, еще одно управляющее слово,
которое говорит, что нужно забить на весь остаток цикла и вернуться к началу.
То есть снова вычислить вот это, снова, значит, сейчас я снова напишу, что тут было,
значит, и меньше десяти, да. Вот, continue говорит, что нужно забить на все оставшиеся команды
внутри цикла и сразу вернуться сюда, то есть вычислить снова вот это и снова проверить условия,
ну, то есть закончить эту итерацию преждевременно, забить на остаток и вернуться сюда.
Ну, опять-таки, continue никто не пишет просто так, его, как правило, пишут под if,
если x равно 1, continue. Это значит, если вот мы дошли до этого места и выяснили,
что здесь x равно 1, то все, что дальше написано, мы в этот раз не делаем,
а сразу переходим к следующему шагу, то есть опять инкриментируем, опять проверяем меньше десяти.
Аналогично можно делать break, continue в while и в do while.
Вот, в if и в switch делать break, continue нельзя, ну, в switch можно делать break,
он там имеет другое значение, а в if под if делать break, continue нельзя.
Ну, еще два управляющих слова, о которых я расскажу, это go to и return.
Давайте сначала go to. Go to это довольно слово с плохой репутацией,
это слово, которое позволяет вам просто прыгнуть на произвольное место кода из данного места.
То есть вы можете написать, у вас есть какая-то, вы можете в коде ставить метки,
вот я могу сказать label и сделать в какой-то момент go to label.
По сути, я могу так циклы имитировать.
Это крайне не рекомендуется, это нужно в очень редких случаях, значит,
это в древние, там, на заре 80-х годов, когда программирование только зарождалось, значит,
так люди писали, но сейчас в современных языках программирования это очень осуждается,
и рекомендуется так не делать почти никогда.
Очень редкие случаи, когда так все-таки стоит писать.
Ну, они бывают, но, наверное, мы не будем их обсуждать.
Ну, в общем, такая возможность есть по историческим причинам,
вы можете в коде ставить в произвольном месте метки,
и в какой-то момент, если какое-то условие выполнилось, говорить go to это метка.
Ну, например, теоретически так можно выпрыгивать сразу из нескольких уровней вложенности цикла.
Правда, с C и C++ есть трудности в этом плане, что если вы, например, с помощью go to попытаетесь
запрыгнуть внутрь, наоборот, какой-то области видимости, скажем, у вас есть цикл,
и вы хотите запрыгнуть внутрь него с помощью go to, вам, скорее всего, выдастся ошибка компиляции,
потому что нельзя делать прыжки через go to, минуя объявления каких-то переменных, например.
У вас в цикле есть какие-то внутренние переменные, вы не можете запрыгнуть в середину,
минуя их объявления, минуя их инициализацию, потому что непонятно тогда, чему эти переменные равны
должны стать и в какой момент они должны создаться.
Но выпрыгивать наружу из циклов можно с помощью go to, и можно таким образом выпрыгивать из нескольких сразу.
Но я все равно не рекомендую вам так делать, это довольно...
В общем, подумайте несколько раз прежде чем это применить.
Это считается очень плохим код-стайлом, так писать это очень запутывает логику выполнения.
Ну и есть слово return.
Return – это слово, которое означает возврат из функции.
Простите, можно вопрос?
Да.
А насчет прошлого там, где вы написали label, а потом go to label, что это в принципе значило?
Label – это что, команда какая-то?
Label – это, значит, специальная...
Ну вот C++ позволяет ставить метки, то есть можно строки кода помечать какими-то метками.
Label, то есть я могу перед произвольной строкой кода сказать abcdef и поставить двоеточие.
Это будет называться меткой.
То есть я эту строку кода пометил.
И это нужно для того, что если я потом хочу сказать go to, я могу назвать какую-то метку.
Просто будет со соответствующей строкой кода ассоциирована вот такая метка, по которой двоеточие стоит.
И можно, например, как это можно сказать?
У нас в цикле есть while, и мы там просто пишем go to label, и он просто выпрыгивает из цикла и идет туда.
Почему? То есть допустим какой-то if сработал, да?
Ну вот у меня есть допустим...
Вот у меня есть какая-нибудь метка abcdef.
И вот у меня есть какой-то while, а внутри него...
Вообще я не хочу эти примеры показывать, потому что вам не нужно этого писать никогда.
Я вам показываю пример того, чем никогда нельзя...
А, ну хоть бы ладно.
Это запрещенные приемы, так не надо делать.
Ну вот я могу почему-то вдруг, там if что-то случилось, там я не знаю, x не равно y, я могу вот здесь написать go to abcdef.
А abcdef это метка, которая после этих двух while стоит.
То есть таким образом я смогу выпрыгнуть сразу с двух уровней цикла.
Вот.
Если бы я написал break, то я бы выпрыгнул только из внутреннего цикла.
А я хочу выпрыгнуть сразу с двух циклов.
И это могу вот таким образом сделать.
Можем вопрос?
Да.
Вот вы говорите, что типа go to запрещенный прием, а как тогда вы выпрыгиваете с двух циклов?
С помощью флагов, что ли?
Давайте так скажу.
Вот я 12 лет программирую на C++.
И много где работал в разных компаниях.
Там в Яндексе два с половиной года.
Там в ВК.
И значит еще кое-где.
И олимпиадки писал.
Ни разу все в это время обходился без go to почему-то.
Не знаю.
Как-то вот.
Ну типа есть подозрение, что если писать хороший код, то go to не нужен.
Ну то есть да, вы можете теоретически извратиться и придумать ситуацию, когда только go to вас спасет.
Но вот я утверждаю, что если вы все нормально пишете, то вам go to ну очень вряд ли пригодится.
В этом году, в этом курсе он вам не пригодится ни разу.
Нет, я пользовался go to.
Вот были случаи, когда я пользовался go to.
Это было там в некоторой компании.
И это было на чистом C.
Вот на плюсах я никогда не пользовался go to.
На чистом C я пользовался go to.
Но не для того, чтобы выпрыгнуть из многих циклов, а для других целей.
Но там это было оправдано.
Там это нужно было для того, чтобы освобождение ресурса в правильном порядке работало.
Вот.
Ну когда вы на чистом C пишете, это, наверное, смысленно иногда.
Но если вы пишете на плюсах...
Ну вот я за все годы своей, так сказать, практики ни разу не встретил необходимости.
Возможно, и вы не встретите.
Я думаю, что и вы не встретите.
Скажем так.
Давайте последнее.
Это слово return.
Ну про return все понятно.
Это способ вернуться из функции.
То есть если вы находитесь в какой-то функции...
Кстати, к вопросу о том, как выйти сразу из нескольких циклов.
Вот, пожалуйста, представьте, что у вас есть функция, и вам нужно выйти из нее.
Ой, я лишнее удалил.
Ну ладно.
Вот представьте, что у меня есть функция, и мне надо выйти из функции.
Я могу написать return.
Слово return позволяет вам выпрыгнуть сразу из функции, в которой вы сейчас находитесь.
Вот это хорошая замена GoTo.
Кстати, если у вас есть какая-то длинная сложная операция из циклов,
и вам нужно, значит, из нее выпрыгивать, вы можете в отдельную функцию вынести,
и тогда просто return выходить из нее.
Return это значит выйти из функции.
Можно, если функция возвращает что-то, например, int,
то вам нужно после return написать, что она возвращает.
Это return 0.
Ну, я могу аналогично из main выходить.
Например, я могу написать return 1 в main.
Main это же функция, которая возвращает int.
Я могу внутри любого места main написать return какой-то int,
и тем самым у меня выполнение закончится на этом месте.
Вот.
Ну, вот как вариант на замену GoTo,
выпрыгивание из этих циклов можно сделать с помощью return,
если внутри функции находим.
А функцию можно прописать внутри main, например?
Нет, функции объявлять внутри других функций,
определять внутри других функций нельзя.
Я уже говорил про это.
Тогда у этого же будет большая проблема,
как у нас в main может быть уже использована структура данных и так далее,
которых не будет в области видимости.
И они будут не доступны функциям.
Ну, в общем, я утверждаю, что если вы пишете хороший код,
то все эти проблемы решаем мы без GoTo.
В общем, вы, когда начнете писать,
вы увидите, что как-то, в общем, вы справляетесь, скорее всего.
Ну, короче, до крайней случаи это слово есть,
но пользоваться им, я думаю, вам не пригодится никогда.
Все, мы с вами закончили говорить про control стейтменты.
На самом деле есть еще один, который я вам не назвал.
Это try catch.
try catch.
Это последний control стейтмент, который существует в языке C++.
Но я не буду про него вам сейчас говорить,
потому что он связан с темой исключений,
которую мы с вами еще не обсуждали.
И мы будем обсуждать ее либо в конце этого семестра,
либо в начале следующего.
И тогда мы поговорим, что try catch – это не так просто.
А пока на сегодня все.
Мы закончили с вами тему control стейтменты.
И почти закончили главу первую.
Нам остался всего один параграф из нее.
