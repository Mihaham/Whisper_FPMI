Так, добрый день. Мы начинаем говорить про кратчайшие пути в графах. Давайте пару тривиальных
определений. Ну, если у нас есть обычный граф, какой-нибудь, мы можем добавлять к
его описанию слова невзвешенный. Это как бы значит, что все ребра одинакового веса,
все ребра одинаковой длины, все ребра одинаковой стоимости. И тогда длиной пути мы можем просто
называть количество ребер в нем. Тогда, собственно, длина пути – это число ребер в нем. А расстояние
между вершинами у и в – это длина самого короткого пути между ними. Расстояние дист у в от у до в
– это длина самого короткого пути между ними. Ну, точнее от у до в. Вот, если пути нет, если у
недостижимо в, то мы говорим, что дист равно плюс бесконечности, если такого пути нет. Вот,
значит, это обычный случай невзвешенного графа, когда все ребра у нас одинаковые, ну, или можно
сказать, что они имеют вес один. Ну, еще такой взвешенный граф. Взвешенный граф – это когда на
всех ребрах еще написаны какие-то веса. Значит, если g, давайте, напишу, это обычный граф ve и w. Это
взвешенный граф. Если вот это вот – это обычный граф, а w – это весовая функция, которая каждому
ребру сопоставляет какой-то вес. То есть, взвешенный граф – это когда у нас дан обычный граф ve,
а w – это какая-то функция из множества ребер, ну, куда-нибудь, пусть будет в r. Весовая функция.
Вот. Тогда в этом случае длиной пути называется сумма весов-рёбер в этом пути. Ну, и, соответственно,
расстояние – это, опять-таки, длина самого короткого пути оттуда v, если мы под длиной пути
подразумеваем, опять-таки, вот ту самую сумму весов. Длина пути p. Я напишу так. Вес от p – это сумма
по всем ребрам входящим, значит, по всем ребрам e входящим в p, вес ребра e. Ну, и расстояние,
соответственно, определяется аналогично. Если у нас определена длина пути, то мы выбираем
среди всех путей самый короткий по этой длине, и это и есть, собственно, расстояние между вышинами.
Вот. Ну, вроде, вроде, вроде стандартное определение, да. Очень естественно мы
определили, что такое, собственно, длина пути. Значит, первый алгоритм, который мы рассмотрим,
это будет алгоритм BFS, который работает на невзвешенных графах и находит кратчайшее
расстояние от одной вершины до всех. Первый алгоритм BFS, значит, по-английски это вот так
расшифровывается, по-русски это поиск ширину. Это алгоритм поиска кратчайших путей от одной
вершины S до всех остальных. Здесь кайт стартовой вершины, мы хотим найти расстояние от нее до всех
остальных в невзвешенном графе, в утяжении взвешенной. Значит, алгоритм очень простой. Давайте
заметим следующее, что вот если у нас есть вершинка S, то каково расстояние от S до S? Ну, ясен пень
ноль, потому что есть путь, стоящий на месте, использующий ноль ребер, поэтому можем сразу сказать,
что dist от S равно нулю. Ну, в массиве dist я буду сохранять найденные вот те самые расстояния,
которые я ищу, расстояние от S до всех вершинок. Теперь давайте рассмотрим ребра, исходящие из S.
Ну, там какие-то ребра. Понятное дело тогда, что до этих вершин кратчайшее расстояние равно единице,
но потому что расстояние ноль быть не может, потому что ноль может быть только для S, мы можем на
месте только стоять, а для них есть как бы пудленый один. Значит, для них для всех dist равен единице,
то есть меньше нельзя, а единичка уже есть. То же самое для них для всех, если я рассматриваю
всех их соседей, то есть рассматриваю все стрелочки из них исходящие, то для них для всех dist уже
двойка. Ну, при условии, что это новая вершина, то есть понятно, что нет смысла оставаться там
на том же уровне, то есть нет смысла идти в ту вершину, для которой dist уже найдена. Поэтому мы
среди всех исходящих ребер рассматриваем только такие, которые ведут в новые вершины, и для них
говорим, что dist равно двойке. То есть на этом уровне у всех dist равно двойке. Опять-таки понятно,
они не были найдены раньше на уровне 0 и раньше на уровне 1, значит до них нет пути меньше длины,
но есть пути длины 2. То, что мы сюда поставили, это правильная вершина ответа. То есть до них
реально dist равно 2. Ну и так далее. Мы вот так идем по графу, по уровням, нулевой, первый,
второй и так далее. На каждом шаге мы раскрываем вершинку, то есть рассматриваем все исходящие
ребра и обновляем ответ для всех этих вершин, которые не достижимы по одному ребру. Вот,
все, такой алгоритм, очень простой. Значит, как мы его будем реализовывать? Мы его будем реализовывать
с помощью очереди. Значит, будет очередь вершинку, будет вот этот массив dist. Значит, он изначально
заполнен, ну давайте я напишу плюс бесконечностями, как знак того, что пока еще никакой путь не найден,
ни до какой вершины никакой путь пока не найден. Значит, начинаем, говорим, что вершина s лежит у
нас на нулевом слое и добавляем ее в очередь, купуш s. То есть мы нашли вершину s, мы знаем для
нее кратчайшее расстояние и добавляем ее в очередь. В очереди у нас будут лежать те вершины,
вот которые нам надо раскрыть, те, для которых надо рассмотреть всех соседей, для них обновить ответ.
С самого начала это будет только s. Мы рассматриваем потом ее соседей, соседей, соседей и так далее. И вот те,
кого мы рассматриваем, в очереди у нас будут лежать. Значит, как мы работаем с очередью? Пока она не
пустая, мы достаем оттуда первую вершину. Достаем и сразу удаляем. Куфрант-купоп. Дальше вот то,
что я называю раскрытием вершины, то есть просмотров всех соседей и попытка обновить
дист для всех соседей. Ну, это мы уже не раз делали. И ребор всех соседей, ну, точнее всех ребер,
сходящих из данной вершины, мы делаем вот таким циклом по всем элементам массива g от v. Если g от v это,
как обычно, список смежности, то есть список вершин, в которой есть ребро из данных.
Вот, соответственно, есть у меня ребро из v в tu. И я хочу сказать, что для вершины tu у меня
теперь появился новый путь. Можно сначала дойти до v, потом, используя это ребро, попасть в tu. Ну,
давайте это сделаем. Если dist tu равно плюс бесконечности, то есть мы еще не нашли никакого пути
tu. Тогда мы нашли путь до v сначала, а потом плюс одно ребро от v до tu. Я говорю, что dist tu
равно dist v плюс 1, q pu tu. Конец. Вот весь алгоритм. Так, да, и давайте я еще вот это напишу,
что вот это вот то, что я делаю, вот эту циклу, я буду называть раскрытием вершины v. Раскрытие v.
Ну, по-английски это expansion. Раскрытие, то есть просмотр всех соседей и обновление для них
dist. Вот. Ну, такой очень простой алгоритм, который вот как бы обходит наш граф, собственно,
почти так, как надо. Тут, на самом деле, есть небольшая хитрость, почему-то все корректно
работает, потому что, на самом деле, вот давайте проследим, как работает, что у нас вообще в очереди
лежит. Изначально в очереди только вершинка s. Ну, понятно, она достается, сразу удаляется из
очереди. В очередь складываются все вот эти вот вершинки, то есть после обработки s в очереди
лежит целиком первый слой. На все вершины расстание 1. Потом мы начинаем постепенно эти вершинки
удалять из начала очереди, а в конец очереди сваливать вот эти вот вершинки. То есть, скажем,
когда у меня обработается первая вершина первого слоя, очередь вот такой станет. Первая удалится,
но вот эти вот добавятся. То есть у меня будет вот это вот начало, вот это конец. То есть, по сути,
у меня в очереди будет как бы сначала кусок конец предыдущего слоя и потом начало следующего.
Вот. Это как бы полезно иметь в виду, если мы хотим понимать, почему это работает корректно.
Что у нас не то, что в очереди лежит очередной слой, мы рассматриваем целиком слой и потом
переходим на следующий. И дальше как бы в этом слое работаем. Мы скорее вот так вот. У нас в очереди
лежат вершины с двух слоев сразу, из предыдущего и со следующего. Вот. Но эта корректность не мешает,
сейчас мы все докажем. Значит, ну, сначала я давайте отмечу, что это, очевидно, работает за линейное время.
Так. Ну, собственно, по той же логике, что, например, DFS работает за линейное время,
потому что у меня очевидным образом вершина добавится в очередь максимум 1 раз. Но потому что
добавляется она только в случае, когда там изначально лежала плюс бесконечность и мы
потом исправляем на что-то небесконечное. качестве каждая вершина побывает в очереди
максимум 1 раз. Значит, она раскроется максимум 1 раз. Значит, каждое ребро исследуется максимум
один раз. Поэтому, собственно, такая симптомика получается немедленно.
Теперь корректность. Для доказательств корректности я сформулирую следующие
три утверждения про внутренний устройство нашего алгоритма, и всех будут доказывать
параллельно друг за другом по итерациям вот этого цикла, цикла while, пока очередь
не пустая. Значит, первое. Пусть к – это dist от q.frank. То есть вот пусть в какой-то
момент времени у нас там алгоритм что-то поработал, и вершина, лежащая в начале
очереди, имеет dist равной в точности k. Тогда я утверждаю, что в очереди лежат
вершины в следующем порядке. Сначала идет несколько вершин с dist в точности k,
потом несколько, возможно, ноль вершин на расстоянии ровно k плюс 1. То есть вот ровно
то, что я говорил. У меня сначала заканчивается предыдущий слой k-тый, потом, возможно,
несколько вершин со следующего k плюс 1. То есть в очереди все dist-ы выглядят вот так. Сначала
несколько одинаковых равных k, потом несколько одинаковых равных k плюс 1.
Насчет первого утверждения. Второе. Значит, в этот момент времени все вершины, для которых
настоящий dist-sv не больше чем k, имеют dist от v равный настоящему dist-sv. Здесь такая небольшая
путность обозначений в том плане, что dist, когда это массив, то есть квадратные скобки, это то,
что наш алгоритм находит. То есть это как бы то, что алгоритмы считают правильным ответом. А dist
как функция, соответственно, в круглых скобочках, это настоящий ответ, правильный ответ. То есть я
вот эту штуку определял как настоящее, кратчайшее расстояние. А это то, что наш алгоритм считает.
Так вот, я утверждаю, что в этот момент времени, если k это вот эта штука, то все вершины,
для которых настоящее расстояние не больше чем k, правильно найдено. То есть для них,
для всех, уже правильно найдено кратчайшее расстояние. Ну и третье. Каждое обновление
dist, ну давайте от tu, всегда корректно. То есть если в нашем алгоритме мы когда-то выставляем
dist от вершины равно чему-то, то это на самом деле в точности настоящее кратчайшее расстояние. То
есть не бывает такого, что мы в dist положили что-то неправильное. Я утверждаю, что мы всегда кладем
только правильные величины. Но собственно отсюда и будет следовать корректно всего нашего алгоритма,
потому что если мы для всех вершин выставляем правильные ответы, то тем самым мы как бы для всех
вершин в принципе найдем то, что надо. Такое утверждение. Вот совокупность этих двух утверждений
мы будем доказывать, наверное, индукцией по количеству итераций цикловайл.
Ну начало. Когда еще ни одной итерации цикловайл не сделана база, что мы сделали до вайла?
Мы в очередь положили вершинку s, сказали, что на расстоянии ноль. Тем самым у меня в очереди
k равно нулю, то есть как бы есть единственная вершинка, для нее dist равно нулю. Понятно,
что правильно посчитано и никаких вершин других нет. Значит, база, когда в очереди лежит только
вершинка s, для нее k равно нулю и все три утверждения очевидны. Потому что да, верно, что в очереди
сначала несколько нулей, потом несколько единиц, но в плане расстояния единиц вообще нет, ну как бы
это ничему не мешает. То есть я здесь не утверждал, что здесь обязательно кто-то есть, возможно,
их и нет. Сначала несколько нулей, потом несколько единиц. Это верно. Дальше здесь все вершины,
для которых настоящее расстояние не больше нуля, имеют корректно выставленный dist. Ну это верно,
потому что единственная такая вершина, это s, мы для нее уже поставили dist s равно нулю. А мы уже
имеем dist s равно нулю. Ну и третье тоже очевидно, к этому моменту времени у нас только вот это
обновление произошло, оно очевидно корректно. Так, еду дальше. Переход. Ну давайте рассмотрим в
какой-то момент времени, пусть очередь действительно выполняется, для нее выполняется первое условие.
То есть мы как бы доказываем по индукции, пусть в какой-то момент времени в очереди реально вот
такие вот dist. То есть для них dist вот такие, для нескольких следующих dist равен k плюс 1.
Мы обрабатываем эту вершинку, соответственно удаляем ее из очереди, раскрываем и пытаемся
понять, что с очереди произойдет. Вот пусть это была v, мы ее как бы хотим удалить.
Нам надо доказать вот эти три утверждения. То есть сделают переход, что все эти утверждения
сохраняются. Ну во-первых, смотрите, если за v была еще вершинка с dist ровно k, то у нас
структура очереди останется. У нас будет сначала несколько k-шек, потом несколько k плюс 1,
и возможно мы в конце еще добавим несколько k плюс 1 за счет того, что мы раскрыли v. От раскрытия v
мы рассмотрели несколько вершин, и для них, возможно, присвоили dist равно k плюс 1. И вот эти
новые вершинки могут сюда поместиться. Поэтому первая свойство тривиально выполняется. В случае
же, если v была единственная вершина с расстоянием k, то есть у меня было k, а потом сразу несколько
k плюс 1, и это было единственное v. Ну тогда все еще проще. У нас в конец очереди, возможно,
помещается несколько вершин с dist равным k плюс 1, и все. Тогда у меня в очереди вообще
все dist одинаковые. Но это тот случай, когда мы целиком обработали очередной слой, и наша
очередь в точности состоит из вершин следующего слоя. То есть там даже нет перехода как k плюс 1,
там просто вот эта вот величина, ну она одинаковая у всех, все dist одинаковые. Хорошо,
первым мы доказали. Второе, что все вершины, для которых dist не больше чем k, имеют правильный
dist. Ну тут опять два случая. Либо v была не единственной вершины с dist равным k в очереди,
либо единственной. В этом случае, смотрите, к моменту удаления v из очереди, у меня в очереди,
ну точнее после обработки вершины v, у меня в очереди по-прежнему будут вот эти вершины с dist
равным k, потом несколько вершин с dist k плюс 1, и возможно еще несколько новых вот от раскрытия v.
Ну тогда понятно, что если раньше у меня, короче, если вот это вот условие выполнялось раньше,
то оно и теперь будет выполняться, потому что k не изменилось. Если раньше для всех вершин с
dist не больше k у меня были правильно насчитаны в эти самые dist в массиве, и k не изменилось,
потому что после удаления v, в этом случае, у меня k не изменяется, у меня вот это вот dist
остается таким же как было. Значит второе условие тривиально сохраняется. Следжательный случай
только когда у меня v была единственная вершина с dist равным k. Ну давайте поймем. Вот у меня v,
я рассматривал v, и мне говорят, что к моменту ее рассмотрения все вершины с dist не больше
чем k правильно обработаны, то есть для них найдено правильное расстояние. А я хочу доказать,
что после удаления v, после ее раскрытия, у меня будут правильно найдены все расстояния не больше
чем k плюс 1. Потому что я перехожу от k к плюс 1, мне нужно теперь доказать, что все вершины с dist
не больше чем k плюс 1 будут правильно обработаны. Зная, что до этого были правильно обработаны все
вершины с dist не больше чем k. Ну что такое вершины с dist не больше чем k плюс 1? Что такое dist
su не больше чем k плюс 1? Значит это либо меньше либо равно k, и тогда для них уже все хорошо по
предположению индукции. Либо это в точности k плюс 1. То есть мне надо сказать, что все вершины с
dist k плюс 1 у меня правильно найдутся, что для них я поставлю правильное расстояние. Но это вроде
понятно, что значит, что dist su равно k плюс 1. Значит есть какой-то путь из s до u длины в точности
k плюс 1. Тогда я могу рассмотреть, точнее последнее ребро на этом пути, какое-то ребро w у. Значит тогда
длина пути от s до w это в точности k. Ну раз я последнее ребро отпустил, то здесь осталось k
ребер. Ну а значит опять-таки по предположению индукции для w у меня уже все корректно найдено,
там dist w равен тому, чему нужно, равен k. И при этом у меня v была последняя рассмотренная вершина с
dist равным k. Значит к моменту удаления v из очереди у меня w тоже уже будет удалена и раскрыта. Ну
значит для u будет найдено правильное расстояние. То есть к моменту удаления v w уже будет
удалена, уже будет раскрыта и удалена. Следовательно, то что нужно мы получаем, что dist u мы найдем таким,
каким нужно, dist s u. Профит. Так, вопросики есть? Хорошо, значит второй пункт мы тоже доказали. Ну а
третий, собственно, тривиально из этого всего следует. Если у нас все до этого присвоения были
корректными, то какие мы делаем присвоения вот в момент раскрытия v? Мы присваиваем только те
dist вот этим вот вершинкам, если для них еще dist был не найден. Ну что значит он был не найден?
Значит пока что до них не было найдено никакого пути длины меньше либо равно, чем k плюс 1. Но
смотрите, все вершины на расстоянии не больше чем k мы уже обработали, для них корректно
проставили dist по пункту 2. То есть если бы до вершины был dist не больше чем k, то мы бы ее должны
были уже найти по предложении индукции. А раз мы ее не нашли, то до нее расстояние хотя бы k плюс 1.
Поэтому если я в этот момент времени, в момент раскрытия v каким-то вершинам проставляю dist равно
k плюс 1, то это точно правильный ответ, потому что все вершины с меньшим расстоянием у меня уже
обработаны, они уже удалены из кучи даже, из очереди, sorry. Значит когда я выполняю такие присваивания,
у меня эти присваивания корректны, это настоящее правильное кратчайшее расстояние. Вот, ну вроде все.
Хорошо, значит ну тут на самом деле я, возможно, несколько громоздков все это доказал, на самом
деле доказательство оно вот тут нарисовано, что можно было бы просто сказать, ну вот послаем,
просто идем и все, как бы все очевидно. Но это было бы очевидно, если бы я сделал типа две очереди,
одна очередь у меня хранит как бы вершины на предыдущем слое, а во вторую я вкладываю
вершины следующего слоя. И тогда совсем очевидно, то есть я целиком рассматриваю очередной слой,
добавляю в следующий слой вершины как бы следующего слоя, понятно, что я их туда все добавлю.
Вот, ну тут небольшая тонкость, что чтобы так не делать, чтобы не заводить две очереди, а обойтись
одной, ну вот тогда придется чуть повозиться, понять, что как бы оно корректно. Хорошо. Так, ну с
БФС мы разобрались вроде. Тогда я иду дальше.
Так, следующий алгоритм, это алгоритм 0К БФС. 0, так, ну давайте маленькое К, БФС. Значит, это опять-таки
поиск кратчайших расстояний от 1 до всех, но при условии, что граф уже взвешенный и веса всех ребер
это целые числа от 0 до K. Значит, граф взвешенный, весовая функция бьет из E в целые числа от 0 до K.
И опять-таки мы ищем кратчайшие расстояния от S до всех. Ищем расстояния от S до всех.
Вот, уже переходим к взвешенным графам, но с таким ограниченным условием, что все веса, то есть по факту
это эффективно, если K какое-нибудь небольшое. То есть представьте, что у вас там в графе почему-то все
ребра имеют маленький вес, ну там 0, 1, 2, 3, 4, например. А тогда это, в принципе, вот сейчас будет
довольно эффективный алгоритм, как находить себе кратчайшие расстояния. Итак, давайте заметим, во-первых,
что в графе такого вида длина любого пути не превосходит что-то типа NK. Ну, точнее, длина любого
кратчайшего пути строго меньше, я утверждаю, чем NK. Ну, где N это, как обычно, числовище в графе.
Почему? Так. Ну да, да, да. Потому что, на самом деле, можно сказать так, потому что, если есть путь,
то есть простой путь. Путь без повторения вершин. Значит, в нем максимум N-1 ребро. Каждое
ребро имеет вес максимум K, поэтому я мог бы здесь даже написать не больше, чем N-1 на K. На более
точной оценке, но мне такой хватит. Вот. Значит, тогда я сделаю следующее. Я заведу NK очередей.
NK очередей. Значит, и в очереди с номером D я буду хранить как бы те вершины, до которых
расстояние типа равно D. Вот типа. В D этой очереди храню вершины, до которых найден путь длины D.
Вот так напишу. Найден путь длины D. Вот. Значит, тогда, как я это могу реализовать? Ну, я завожу,
собственно, массив очередей, как я обещал, размера NK. Так нельзя описать, но я напишу так.
Мне можно. Значит, NK очередей. В нулевую я изначально пихаю S. Говорю, что D от S равно 0,
но пока сначала такое же. Вот. Но еще мне понадобится массив used, в котором я буду хранить,
раскрывал я вершинку или нет. Я завожу вектор bool used. Изначально там все false. И там для каждой
вершины сказано, раскрывал я ее или нет. То есть как бы удалил ли я ее уже из очереди. Значит, тогда в цикле по,
собственно, всем D, перебираю очереди в порядке возрастания номера. D меньше NK, плюс-плюс D. Я иду
под этой очереди. Пока D еще не пустая, достаю первую вершинку, как обычно. Значит, пока неверно,
что QD это empty. Достаю QD.front. Сразу ее удаляю. Вот. И раскрываю. Но на самом деле не совсем. Я ее
раскрываю, если раньше до этого не раскрывал. То есть на самом деле может быть такое, что я вершину вижу,
достаю из очереди несколько раз. Ну потому что, смотрите, очень простой пример. Вот, например,
я из S нашел ребро веса 3 в вершину V, а потом нашел более короткий путь, скажем, вот такой, веса 2,
в нее же. То есть тогда понятно, что я этот путь тоже обнаружу. Но тогда у меня вершина V будет
сразу в двух очередях. Во второй и в третий. Потому что до нее есть путь длины 2, до нее есть путь длины 3.
Ну, наверное, понятно, что если я ее раскрыл в момент обработки второго очереди, то нет смысла
обрабатывать в момент обработки третьей очереди. Потому что я ее уже раскрыл, я до нее нашел правильное
расстояние, а теперь мне говорят, что там есть еще какой-то путь длины 3, но он мне не нужен,
мне не надо ее раскрывать. Поэтому вот здесь я напишу, что если я ее уже раскрывал, то я ее
игнорирую. Если used в это, то continue. Вот. А иначе я ее сейчас буду раскрывать и сразу помечаю раскрытый.
Так. Ну, раскрытие работает очень просто. Как всегда, на самом деле, как в прошлом,
как в дейстре, это у нас будет чуть позже. Вот. Значит, раскрытие, собственно. Ну, тут уже смотрите,
тут у меня ребра становятся взвешенными, поэтому я не могу просто говорить, что я перебиваю все
конечные, все концы ребер. Мне нужно сказать, что я перебиваю реально все исходящие ребра,
но вот пусть у меня есть какая-то структурка edge, которая хранит в себе вес ребра и, собственно,
то, куда оно ведет. Так вот, я перебираю, как обычно, все исходящие ребра из вершины v,
завожу, ну, какой-нибудь x равное, видимо, d плюс e точка кост. Вот. И тем самым я, получается,
нашел до вершинки e точка tu. Вот, если у меня есть, если ребро e, оно ведет из текущей вершины v
в вершину e точка tu имеет вес e точка кост, то я до этой вершины нашел только что путь длины x. Да,
потому что до v есть путь длины d, потом я еще прибавляю новое ребро, вот это вот e, получается
путь веса x, путь длины x. И я могу сделать следующее, я могу взять и добавить вершинку вот эту вот в
очередь номер x. Ну, если это осмысленно. Так, а dist у меня есть, да. Если dist вот e точка tu больше
чем x, то есть получается, что я нашел как бы более эффективный путь до вершинки e точка tu, да,
более короткий. Тогда я, собственно, туда его сохраняю, то текущая найденная расстояние равно x,
ну и добавляю e точка tu в x в очередь. qxt push e точка tu. Так, все, раскрытие закончилось,
while закончился и for по d тоже закончился, конец.
Вот, ну давайте какую-нибудь иллюстрацию я приведу. На самом деле вот эта вот лучшая иллюстрация.
То есть смотрите, когда я обрабатываю вершинку s, я ее раскрываю и говорю, что эту вершину я
ее кладу в первую очередь, а эту в третью. То есть я уже вижу путь длины 1 до нее, путь длины 3 до нее.
Потом я иду в порядке увеличения этих дешек, потом я рассматриваю в первую очередь вот эту вершину.
И ее я опять раскрываю и нахожу путь до вершинки v длины 2, значит я v кладу во вторую очередь.
Тем самым как бы я нашел вот этот путь длины 2 от s до v. Потом у меня вершинка v находится и во
второй очереди и в третьей, но если надо, там она опять раскрывается, но только в момент обработки
второй очереди. В момент обработки третьей очереди она уже не раскрывается, да.
Дерево? Дерево поиска в смысле? Или какое дерево?
Это правильно говорите, это вы Dx описываете. И там на самом деле не дерево поиска, а куча
достаточно, потому что нам нужно только добавлять и извлекать минимум. Ну это следующий алгоритм,
да. Ну вообще вы правы абсолютно. Здесь как бы это просто эффективно, то есть то, что вы говорите
добавляет логарифмическое множество, а здесь маленько, то тут нет никакого логарифмического множества.
Тут как бы за линию, грубо говоря. Вот, ну абсолютно правильно говорите, но просто другой алгоритм уже,
следующий будет. Вот, значит, давайте я сначала опять скажу про симптотику. Симптотика здесь
получается m плюс nk. Ну из стандартных соображений, значит, каждую вершину я раскрываю максимум один
раз за счет меток юст, поэтому суммарно все вот эти форики работают за отm, за количество ребер
в графе. Все раскрытия работают за отm. Ну а все остальное это проход по очередям, да, то есть у меня
nk очередей, и плюс еще надо сказать, что каждая вершина добавится максимум в k очередей. Значит,
каждая вершина может присутствовать. Так, это, кажется, не важный факт для доказательства симптотики,
ну на всякий случай отмечу, присутствует не более, чем в k очередях. Ну, потому что если я в какой-то
момент времени нашел до какой-то вершины какой-то путь, что это значит? Значит, я был вот здесь, до нее
корректно здесь, это d, потом я взял, рассмотрел какое-то ребро веса e точка кост и нашел расстояние,
точнее путь до вот этой вершинки веса x. Вопрос, когда я эту вершинку e точку могу добавить в другую
очередь? Ну, во-первых, я ее могу добавить только в очередь с меньшим номером, потому что добавляю
я вершину только в случае, когда у нее уменьшается дист, то есть если дист, который там уже лежит,
строго больше, чем то, что я нашел. Поэтому если я эту вершину куда-то еще и добавляю, пушу в новой
очереди, то их номера будут всегда меньше, чем x, то есть они будут только уменьшаться, уменьшаться,
уменьшаться, уменьшаться. Но понятно, что стать меньше, чем d оно не может, потому что если к моменту
рассмотрения v у меня e точка tu еще не найдено, ну тогда понятно, что расстояние до него хотя бы d.
То есть, грубо говоря, я рассмотрел все вершины на расстоянии не больше, чем d, и эту вершину, так давайте
я на самом деле вот так вот скажу, k плюс один может быть, в худшем случае. Вот, значит, к моменту
времени рассмотрения v, у меня если e точка tu нет, значит она находится на расстоянии не больше,
чем d плюс k. Ну и потом я, получается, ее могу добавить в d плюс k, минус 1, d плюс k, минус 2 и так далее,
вплоть до d этой очереди, в случае, если тут есть ребро веса 0, ну и тогда, получается, на максимум k
плюс 1 очередь посетит. Вот, поэтому вот опять-таки откуда берется nk, потому что каждые вершины
максимум k очереди посещают. Так, вот, ну а корректность здесь, собственно, тоже практически тривиальна.
Давайте я не буду доказывать, я просто формулирую утверждение, которое, ну по факту, эту корректность
и гарантирует. Так, значит, как это формулировать-то? К моменту начала d этой итерации,
начало d этой итерации внешнего вот этого фора, да, то есть когда d равно очередному значению,
к моменту начала обработки очередной итерации внешнего фора q dt содержит все вершины на расстоянии d,
кроме, возможно, тех, которые достижимы из тех, которые там уже содержатся по путям нулевой длины.
То есть q от d реально содержит все вершины на расстоянии d, но, возможно, еще какие-то не содержат,
но те, которые не содержат, точно можно обнаружить по путям длины 0. То есть вот q от d это какая-то
очередь, и из нее, возможно, есть какие-то пути по нулевым ребрам. И тогда, если я добавлю все вот
эти вершины, достижимые по нулям, добавлю в очередь q от d, то тогда это будет полностью все
множество вершин на расстоянии ровно d. Сейчас допишу и перерыв. Значит q от d содержит все вершины
с dist sv равно d, кроме, возможно, тех,
которые достижимы из них по путям нулевой длины.
Вот. Ну и тогда как раз, когда эти пути длины 0 обработаются, то есть я обрабатываю все эти вершинки,
рассматриваю вот эти ребра веса 0, и они постепенно добавляются в конец этой же очереди.
Поскольку здесь q от d равен 0, они все будут добавляться в конец этой же очереди, и значит,
они все рассмотрятся к моменту окончания d тетрации. Ну, значит, как раз все вершины на
нужном расстоянии рассматриваются. Вот перерыв.
Следующий на очередь у нас алгоритм d экстры. Граф, опять-таки, взвешенный, но веса могут
быть не обязательно целые маленькие числа, а любые неотрицательные, главное. Граф взвешенный,
весовая функция бьет из ребер в r больше равно 0. Я так напишу. Ну, нет, давайте я вот так
напишу лучше. То есть все веса неотрицательны. Все веса неотрицательны. Опять-таки,
ищем расстояние от 1 до всех. Алгоритм можно написать так. В каждое время у меня все вершины
делятся на две группы. Использованные и неиспользованные. Использованные – это,
как бы, для которых мы уже нашли дист. Мы знаем, что, ну, то есть корректный дист, да, дист,
который мы нашли равен настоящему расстоянию. Вот. И мы их уже как бы все обработали. Это,
значит, обработанные. Для них мы уже знаем, то есть нам известен дист. Известен дист.
Вот. Они использованы. Это те, для которых у нас есть только оценка на дист. Вот, например,
в 0kbfs я, когда раскрываю еще одну вершинку, я по факту нахожу некоторые оценки на дист для
концов ребер. То есть я, когда вот рассматриваю v, рассматриваю все исходящие из нее ребра,
я знаю, что до этих вершинок есть какие-то пути. То есть я сначала от s кратчайшим путем добираюсь
до v, потом использую это ребро. Понятно, что это не обязательно кратчайшее расстояние. Но это
оценка на кратчайшее расстояние сверху. То есть это какой-то путь, который есть в графе,
который больше равен, чем настоящий дист. Вот. Соответственно, для этих вершин я знаю только
какие-то оценки на дист. Известны оценки на дист. Значит, тогда, говорит, там работает так. На каждом
шаге из всех неиспользованных я выбираю вершину с минимальной вот этой вот оценкой. То есть вершина,
для которой текущий известный дист минимально возможен. Выбираем неиспользованную v с минимальным
дист от v. То есть, как всегда, в массиве дист от v у меня хранятся текущие найденные оценки на
настоящее расстояние диста от s до v. Из всех неиспользованных вершин v я выбираю ту,
у которой минимальная вот эта вот оценка. Ну и объявляю это настоящим дистом. Говорим,
что эта, собственно, оценка и равна настоящему ответу. Потом вершину v помечаем использованной
и раскрываем. Помечаем v использованной. Ну то есть переносим ее вот в этом множество и раскрываем.
То есть, опять рассматриваем все исходящие ребра ведущие из v. Для всех концов этих ребер
пытаемся обновить оценку на дист. То есть, скажем, для этой вершины, если я раньше знал какой-нибудь
вот такой вот путь до нее, то, возможно, теперь я нашел более оптимальный. Ну, как обычно. То есть,
у нас, возможно, был какой-то путь до этого, а сейчас я узнал более короткий. И этим более
коротким путем я обновил дист для этой вершинки. Все, весь алгоритм. В конце утверждается, что все
достиженные вершинки будут помечены использованными, и для них будет найден корректный дист.
Давай сначала с этим дотикой разберемся. Ну, тут есть две реализации. Обе бывают полезными. Самое
простое — работать за квадрат. За n квадрат. Потому что, смотрите, по факту что мне нужно сделать?
Мне нужно n раз. У меня не больше чем n итерации, потому что, ну, каждая итерация перемещает одну
вершинку отсюда-сюда. Итерация не больше чем n. На итерации мне нужно найти вершину с минимальным
дистом среди неиспользованных. Но для этого достаточно по ним по всем пробежаться и выбрать
минимум просто. Заделся за линию, за отn. А затем мне нужно еще ее раскрыть. То есть, по факту,
у меня сначала поиск минимума, потом раскрытие. Поэтому такая симптотика, такой алгоритм работает
за n квадрат плюс m. Давайте я напишу один раз. Вот так вот. Потому что у меня n итерации, на каждой
итерации я за линию нахожу минимум, и потом еще раскрываю все вершины. Но поскольку каждая
вершина раскроется только единожды, значит, каждое ребро рассмотрится только один раз. Значит,
суммарный вклад всех раскрытий от m. Но мы живем как бы в парадигме, что у нас m, ну давайте я так
напишу, по порядку это хотя бы n и не больше m квадрат. Потому что если m меньше чем n,
то понятно, что граф не связанный, и можно тогда решить задачу на какой-то связанной компоненте
отдельной. Потому что если m меньше, ну меньше m-1, тогда граф не связанный, даже из s не все
достижимо. Значит, сначала мы тогда на первом шаге можем оставить только то, что достижимо из s,
и потом уже на этой компоненте связанно что-то делать. И тогда уже будет как раз верно вот это
соотношение, что в связанном графе ребер хотя бы n-1. Иначе я могу сузиться на компонент
связанности. Ну а и m не больше m квадрат, потому что мы считаем, что граф у нас простые, то есть
без кратных ребер. Значит, вообще m не больше, чем n-1 в случае ориентированного графа, потому что
нет кратных ребер. Ну поэтому здесь достаточно оставить n квадрат, у меня получается d x из 1 квадрат.
Вот, вторая реализация требует времени m log n и работает, если мы будем использовать,
например, бинарную кучу. Используем бинарную кучу. Потому что, смотри, давайте поймем, что нам
вообще нужно. Вот здесь, когда мы работаем с неиспользованными вершинами, что нам нужно? Мне
нужно уметь находить вершину с минимальным, то есть по сути находить минимум, вот здесь, в этом множестве.
Извлекать его, то есть удалять, перемещать из неиспользованных в использованные, надо найти
минимум, удалить минимум. И вот раскрытие вершины, это, на самом деле, декрестки, несколько декрестки,
потому что что такое раскрытие? Это попытка улучшить оценку диста досюда через там какое-то значение.
Но если я дисты воспринимаю в качестве ключей, то есть как раз то, что в куче хранится,
тогда я их могу только уменьшать. Если у меня уже есть какая-то оценка, то я эту оценку могу
только уменьшать, нет смысла увеличивать, потому что я путь только как бы, ну, все более-более короткий
и нахожу все более-более оптимально. Значит, мне в куче надо уметь делать, в нашей структуре надо
уметь делать декрестки, но это куча просто. Extract-min, get-min и декрестки это куча, все работает за алгоритм.
Давайте напишем, что мне здесь нужно. То есть как бы храним кучу неиспользованных вершин,
упорядоченных по дист. Значит, тогда мне нужно N раз уметь делать get-min, N раз уметь делать
Extract-min и maximum-M раз уметь делать декрестки, потому что декрестки столько, сколько ребер в графе максимум.
Вот, каждый из этих штук работает максимум за алгоритм, ну, get-min вообще за единицу, Extract-min за от
алгоритма N, декрестки за от алгоритма N. Поэтому в предположении, что M по порядку хотя бы N,
здесь основной слогами будет вот это, M log N. То есть там еще будет M log N, но оно несущественно по сравнению с M log N.
Поэтому как раз-таки вот эта штука дает нам такой, собственно, вставляющуюся методики M log N.
Окей? Вот. Ну, еще для общего развития скажу, что есть не только бинарная куча, например, фибоначьего куча.
Так, фибоначьего куча. Это что-то, что основывается там на биномиальной куче, как-то там оно в каком-то смысле
ленивая реализация биномиальной кучи, то есть он какие-то операции откладывает на потом, и за счет этого получается лучшая
оценка времени работы. Так вот там давайте напишем, за сколько работают все эти операции. Ну, get-min, как, в общем-то,
всегда можно всегда реализовать за единицу, потому что можно просто поддерживать указатель на минимум.
Экстракт-мин работает за учетную единицу.
Нет, get-min за единицу.
Значит, экстракт-мин за амортизированную единицу, а декрески, нет, здесь логарифм, извините, здесь логарифм амортизированный,
вот декрески за амортизированную единицу работают, декрески за амортизированную единицу.
Значит, там идея такая, если вы вдруг помните, как работает там биномиальная куча, как у нас работают декрески.
Значит, ну вот мы находим какую-то вершинку, мы ее, мы уменьшаем у нее ключ и хотим как бы ее поднимать наверх,
ну сифтап сделать для нее. Так вот фибоначевая куча вместо этих сифтапов мы обычно можем просто вырезать все ее,
все вот это вот под дерево и назначить это очередным деревом.
Тогда это, соответственно, у меня уже перестанет быть биномиальным деревом, ну будет что-то похожее на биномиальное дерево.
То есть я просто беру вот это вот под дерево, вырезаю его целиком из предыдущего под дерево и назначаю это очередным корнем.
То есть это как бы очередное дерево в списке деревьев.
И там, если все это достаточно хитро сделать, получится учетное стоимость единицу на такой запрос,
потому что это работает за единицу, там, высплетить и подвесить к списку корней.
Так вот если делать достаточно хитро, то есть там еще что-то поддерживать, то это будет учетная единица, амортизированная единица.
Ну и тогда симптотика здесь будет, смотрите, если я перемножу, тут будет n, тут будет n лог n, тут будет m.
Поэтому суммарно будет m плюс n лог n. Вот такой прикол.
Да, и это может быть лучше, чем обычная реализация бинарной кучей.
Ну понятно, потому что если m достаточно большой, то я m не умножаю на алгорифм, а только n умножаю на алгорифм.
Ну понятно, что это может быть выгодно.
То есть как бы иллюстрация того, что если мы какие-то более крутые структуры разрабатываем,
то мы можем вот такие классические алгоритмы типа dx улучшать дотику.
Это в принципе довольно хорошо.
Так, ну теперь корректность.
Почему мы тут все правильно сделаем?
Корректность.
Ну я хочу доказать, что все вот эти вот перетаскивания вершины из неиспользованных в использованные,
то есть вот пометка вершины использованной, они как бы всегда правильные, что в этот момент у меня реально вот это вот верно.
Что все вот эти вот, мы говорим что, эти всегда верны.
Что когда я перетаскиваю вершину из неиспользованных в использованные, я всегда уже правильно для нее нашел дист.
Ну опять доказываем эту индукцию по количеству итераций в нашем алгоритме,
по количеству этих перетаскиваний из неиспользованных в использованные.
И здесь нам надо заметить следующее.
Что вот по дороге, пока мы все это делаем, выполняет следующее соотношение.
Значит пусть у неиспользованная, но такая, что существует кратчайший путь до нее из s, не использующий других неиспользованных вершин.
Существует кратчайший путь от s до u, который не посещает других неиспользованных вершин.
То есть у такая крутая, что путь до нее, ну по крайней мере один из кратчайших путей до нее выглядит вот так.
То есть я сначала кратчайшую петляю, потом за одно ребро сразу перемещаюсь в u и заканчиваю.
То есть я не использую никаких других вершин отсюда.
Только несколько использованных, потом последнее ребро в u.
Так вот тогда, это совсем просто, тогда мы уже нашли до нее корректный дист.
То есть если есть такой путь, то мы его нашли и наша оценка совпадает с правильным ответом.
Ну вроде как бы это очевидно, доказываем это утверждение по индукции вместе с корректностью нашего алгоритма.
Если в этот момент в времени эти все использованные, значит вот эта тоже использована, значит для нее правильный найден дист.
И она уже раскрыта. Ну а когда она раскрывалась, она как раз передала вот сюда вот в u длину этого пути плюс вес этого ребра.
А если этот путь кратчайший, то получается, что мы в u положили дист s у, на профит.
То есть если есть путь неиспользующий неиспользованных, тогда мы его уже обнаружили.
И значит если что, мы эту вершину можем сразу помечать использованной.
Вот, значит это мы заметили тривиальным образом, значит теперь докажем, что вот та вот вершина v выбираем алгоритмом.
Действительно удовлетворяет вот этому равенству, что оценка, которую мы нашли совпадает с дистом настоящим.
Удовлетворяет равенству дист, найденное равно правильному значению.
То, что мы хотим доказать, что все вот эти вот перетаскивания, то есть когда я вершину v нашел на очередном шаге, извлек минимум из кучи, это уже правильный ответ, для него уже правильно посчитано на расстояние.
Так вот, ну почему это так? Пусть не так, давайте от противного пойдем, пусть не так.
Тогда, если тут не равенство, то здесь значок больше будет. То есть оценка, которую мы нашли, строго больше, чем настоящее расстояние диста с v.
Ну меньше быть не может, потому что все, что мы находим, это только оценка сверху на расстояние. Все, что мы находим в дист кладем, это по факту какие-то пути в графе.
То есть мы, дист, там не случайных значений, это обязательно какие-то пути до вершины v, поэтому меньше, чем настоящее расстояние быть не могут.
Они всегда больше либо равны, но если не равно, то строго больше.
Хорошо, давайте тогда рассмотрим какой-нибудь настоящий, кратчайший путь до v, вот этот кратчайший, настоящий путь.
Так, оставлю на картинке, рассмотрим настоящий, кратчайший путь из s в v.
Как он выглядит?
Ну он как-то там петляет поиспользованным, потом, возможно, прыгает внеиспользованные, как-то здесь ходит, возможно, возвращается назад, ну и так далее, зато в конце доходит до v.
Какой-то сложный путь.
Но давайте рассмотрим первую вершину в этом пути, которая неиспользованная, то есть я сначала хожу по использованным и вот первый прыжок внеиспользованный, давайте я обозначу эту вершинку за u.
пути от s до v, первая неиспользованная. Значит понятно, что если u равно v, то вот это вот верно,
и мы уже победили на противоречие с предположением. То есть если v это сама по себе первая неиспользованная,
то для нее вот этого неравенства быть не может. Мы уже доказали, что для нее точно равенство
выполняется. Значит u и v это разные вершины, но тогда смотрите, раз u это, давайте напишу, что u это
первая неиспользованная на этом пути. Значит по замещанию, который я выше сделал, то что там
уже лежит оценка, это правильное расстояние distance u. Понятное дело, что эта штука меньше
равна distance v, потому что если u лежит на коротчайшем пути отсюда до сюда, то понятное дело,
что вот начало это коротчайший путь до u. То есть я сначала коротчайшим путем дошел до u, а потом
еще каким-то образом дошел до v. Понятно, что если это не коротчайший путь, то его можно было бы
сократить, и тогда у меня бы уменьшился путь до v. Поэтому то, что я здесь прохожу, это очевидно
коротчайший путь от s до u. И значит он по весу не больше, чем путь от s до v, потому что там
еще были какие-то ребра не отрицательного веса. Значит расширение пути только увеличивает дист.
Но это не разница тривиальна, если все ребра реально не отрицательные. Вот, но это по предположению
меньше, чем дист от v. В итоге мы получили, что оценка на u меньше, чем оценка на v. Значит в
алгоритме u должна была бы достаться из кучи раньше, чем v. Следовательно u должна быть извлечена из кучи
раньше, чем v. Противоречие. Вот вроде все доказал. Вопросы? Кайф.
Заметьте, здесь было принципиально важно, что все ребра не отрицательны. Потому что если бы
ребра были отрицательного веса, у меня бы, например, вот это не раз не сработало. Ну и вообще как бы
тогда, тогда весь алгоритм не работает на самом деле. Что же делать с отрицательными ребрами? Пока что
у нас ни один из алгоритмов не умеет с ними справляться. Давайте вообще поймем, что нам дают
отрицательные ребра. На самом деле они иногда делают так, что кратчайшее состояние в принципе не
определено. В том смысле, что его можно сделать сколь угодно большим по модуле отрицательным.
Минус 10, минус 100, минус 1000, минус 10 тысяч и так далее. Сколь угодно большим по модуле
отрицательным. Сколь угодно близким к минусу бесконечности. В присутствии в наличии отрицательных
ребер в графе DIST, ну там ST, в соответствии с нашим старым определением, может быть
некорректно определено, а может быть не определено. Ну вот на самом деле я тогда
утверждаю, что по факту это означает, что DIST равен минус бесконечности, то есть я могу
набрать там сколь угодно большой по модуле отрицательный путь. Нет, про простоту нет,
нигде требований. То есть возможно мы там какие-то циклы наматываем. Так вот, в этом случае DIST я
могу объявить равным минус бесконечности, и это по факту означает, что существует цикл отрицательного
веса, цикл C отрицательного веса, ну такой, что он достижим из S и из него достижимо T. То есть
картинка как бы очень тривиальная. Мы сначала из S до кого-то доходим, потом начинаем сколь угодно
долго петлять по циклу отрицательного веса, то есть суммарный вес всех этих ребер меньше нуля,
на вес вот C меньше нуля, и потом я дохожу до T. Ну понятно тогда, что как бы вес можно сделать
сколь угодно большим по модуле отрицательным. Что я говорю, минус здесь, минус 100, минус 1000 и так
далее. Вот, и это я утверждаю единственный способ, когда DIST может быть ну вот так неопределен,
то есть как бы быть с минус бесконечностью по факту. Вот, значит почему здесь я могу поставить
эквивалентность? Ну понятно, что справа налево это очевидно, если такая картинка есть, то реально
DIST можно сделать сколь угодно большим по модуле отрицательно. Дошел, пропетлял столько, сколько надо
раз, достаточно уменьшился, и потом дошел до T. Понятно, что я могу любое наперед заранее, как бы
любое наперед заранее число набрать в качестве веса вот здесь. В обратную сторону, почему если
DIST снизу не ограничен, то обязательно есть цикл? Ну, тут можно такое рассуждение провести, что
значит пусть все веса-рёбер по модуле не превосходят какого-то C, по модуле не превосходят C,
то есть это я сейчас доказываю пункт слева направо, что если DIST не ограничен, то реально есть такой цикл
между ними. Так вот, пусть все веса-рёбер ограничены по модуле к значениям C, понятно, что такое C существует,
потому что w это функция, ну как бы из конечного множества в r. Вот, значит тогда посмотрим путь из S в T
веса меньше, чем минус Cn с минимальным числом рёбер. То есть да, поскольку я знаю, что по
предположению DIST не ограничен, то значит для любой задно-наперед константы я могу набрать
вес, могу набрать путь веса меньше такого, меньше минус Cn. Из всех таких я выбираю путь с
минимальным числом рёбер. Вот. Ну тогда что? Тогда поскольку у меня здесь вес меньше минус Cn,
то в нем обязательно есть цикл. То есть картинка точно выглядит как-то вот так. Потому что если у меня
все ребра по весу не происходят по модулю, а суммарный вес меньше минус Cn, то рёбер точно по крайней
мере n, даже по крайней мере n плюс 1, если тут строгий значок, значит у меня точно вершины
повторяются, поэтому я когда-то в цикл точно войду. Вот. Но при этом, смотрите, если у меня вес
меньше минус Cn и рёбер минимально возможное количество, тогда этот цикл точно отрицательного веса,
потому что если бы он был нетрицательного веса, я мог бы его отбросить и получить путь опять вес
не больше, чем минус Cn и с меньшим числом рёбер. Противоречие. Значит на этом цикле обязательно
отрицательный вес. Обязательно отрицательный вес. Окей? Так, ну чудно. Как же тогда жить с
этими отрицательными циклами и с отрицательными рёберами вообще? Здесь нам нужен алгоритм Форда
Белмана. Алгоритм Форда Белмана. Тут опять мы ищем крошайшие пути от одной до всех,
но весовая функция произвольная. То есть тут уже нет ограничений, что все веса не отрицательные,
веса могут быть отрицательными. Значит w функции с g в r, уже любая без ограничений, ну и ищем
расстояние от s до всех. Вот. Значит тут работает очень простая динамика на самом деле. Смотрите,
давайте мы введем dp в этой каты. Это длина, минимальная длина пути из s в использующей
не больше чем k рёбер. Минимальная длина пути из s в использующей не больше k рёбер. Я насильно
ограничиваю число возможных доступностей для использования рёбер, только максимум k. Вот.
И в этом предположении считаю все крошайшие обстояния. Ввожу такую дпшку. Значит насчитывается
она тривиально. dp v нулевое, это когда я не могу использовать рёбер вообще. Все пути должны
состоять из нуля рёбер. Тогда dp очень просто определяется. Это 0 в случае, когда v равно s,
и плюс бесконечный в случае, когда v не равно s. Ну потому что если я могу использовать только
0 рёбер, то я могу только стоять на месте, а значит я могу только в s находиться, и тогда расстояние
равно нулю. Иначе я никуда добраться не могу, и туда считаю, что путь имеет иную плюс бесконечность.
Вот. Теперь переход. Переход от k в основе k плюс 1.
Например, давайте предположим, что я знаю все расстояния из использующей не больше чем k рёбер.
Теперь я могу добавить к ним одно рибро новое. То есть я могу ко всем путям длины, точнее использующим
не больше чем k рёбер, могу добавить еще одно новое k плюс первое. Но давайте поймем, что такое
например dp в это k плюс первое. dp в это k плюс первое. Ну, во-первых, я могу использовать по-прежнему
не больше чем k рёбер. То есть одно из потенциальных значений, это просто dp в это k. Это когда
я использую не больше чем k рёбер. Либо же, второй случай, я использую в точности k плюс 1 рибро.
Давай тогда рассмотрю последнее. Вот что такое последнее рибро? В используешь k плюс 1 рибро.
Значит, ну это какое-то рибро у В, какого-то веса, да, там кост. Ну и тогда, чтобы попасть в В за
k плюс 1 рибро, мне нужно сначала в У попасть за k рёбер. А это я уже знаю, это dp ut kt. Поэтому здесь
вторая опция, это мне нужно перебрать всевозможные входящие рёбра у В. У В это ребро графа. Здесь
значение равно dp ut kt плюс стоимость ребра у В. Давайте напишем кост ut vt. Очень простой
переход. То есть я либо использую не больше чем k рёбер, либо использую вот это k плюс 1
рибро. Его просто перебираю. Перебираю всевозможные входящие рёбра в В. И если я знаю начало вот
ребра У, то я, получается, сначала должен из С попасть в У за k рёбер, это dp, уже известное,
плюс вес последнего ребра. Вот такой простой пересчёт нашей динамики.
Так, простое замечание. Если в графе нет отрицательных циклов, то нам достаточно посчитать
все слои вплоть до n-1. Если в G нет отрицательных циклов, ну то есть циклов отрицательного веса,
циклов, что их вес, суммарный вес всех рёберов на них меньше нуля. Так вот, если таких циклов нету,
то dp в это n-1 всегда в точности равно distance v. То есть нам достаточно сделать n-1 переход в
нашей динамике, и мы тогда найдём все кратчайшие стоения. Начну это просто, потому что если
отрицательных циклов нету, то истинно настоящий правильный путь, кратчайший, очевидно, содержит не
больше н-1 ребро. Потому что если он содержит хотя бы n-1, то он обязательно зацикливается. Если он
использует хотя бы n-1, то значит в нём какая-то вершина посещена хотя бы дважды, значит мы точно
какой-то кусок проходим, ну короче какой-то цикл у нас на пути есть. А если циклов отрицательных
нету, то получается вес этого цикла не отрицательный, его можно смело отбросить, только улучшив наш дист.
Поэтому не было смысла нам петлять тут по циклу. Значит если реально нет отрицательных циклов,
то мы наверное в первом шаге найдём все правильные дисты. Значит насколько это работает? Это работает
очевидно за nm. Потому что у меня n слоёв, n переходов в динамике, ну и каждый переход, каждый слой я
по факту вот здесь вот перебираю все вешки и перебираю все ребра. Ну это как раз m, за отm работает,
потому что по факту мне нужно просто все ребра в графе перебрать. Вот он, то есть я для каждой вершины
перебиваю все входящие ребра. Это отm. Перебиваю просто все входящие ребра. Вот, поэтому у меня столько
слоёв в динамике, слоёв dp, ну а это время подсчёта очередного слоя. Время на слой, вот. Ну и там как
обычно можно сказать, что нам на самом деле достаточно вот и вот столько времени и, скажем, от n памяти
потому, что как это часто у нас бывает k плюс первый слой выщипывается только через ל�-катый,
поэтому нам достаточно только два слоя хранить, предыдущий и следующий, и, поэтому нам
памяти достаточно линейное количество. То есть у меня динамика двумерная и n на n получается.
Но на самом деле мне достаточно только два слоя хранить, поэтому на самом деле достаточно линии памяти.
Времени-то? Да нет.
Для каждой вершины я перебираю второй карандат и все входящие ребра.
То есть я для каждой вершины по факту вот здесь, вот эта формула работает за число входящих ребров v.
Потому что я просто здесь все перебираю.
Поэтому вот если у меня k и капли с ними фиксировано, то суммарно вот эта штука по всем v работает за от m.
Потому что я для каждой вершины рассматриваю все входящие ребра.
То есть я рассматриваю по факту просто все ребра, их линия, их m.
И так делаю n раз, потому что мне нужно от 0 перейти...
от кара в 0 перейти кара в 1, потом к 2 и так далее вплоть до n-1.
n переходов каждый за m работает.
Так, значит, без отрицательных циклов мы разобрались.
Но что с отрицательными циклами?
Ну, можно игнорировать, конечно, но можно полностью здесь все разобрать.
Сейчас разберем.
Да-да-да, абсолютно правильно.
Так мы и сделаем.
Значит, теперь считаем, что отрицательные циклы могут быть.
Теперь считаем, что могут быть отрицательные циклы.
Что могут быть отрицательные циклы.
Тогда я сделаю еще одну насильную итерацию нашей динамики.
То есть я еще насильно посчитаю n-т слой.
Насчитаем dp на n-м слой.
То есть для всех вершин посчитаю dp в это n-т.
Утверждение.
Если c отрицательный цикл, то, по крайней мере, для одной вершины этого цикла,
существует хотя бы одна вершина на этом цикле,
для которой dp уменьшилось.
Дп в это n-е стало строго меньше, чем dp в это n-1.
То есть если я сделаю всего лишь еще одну итерацию,
то есть много не надо, мне одной хватит.
Если я сделаю всего одну лишнюю итерацию,
то у меня на каждом цикле я обнаружу, по крайней мере,
одну вершину, у которой dp уменьшилось.
Понятно, что в отсутствии отрицательных циклов
такого быть не может.
Мы уже доказали вот здесь, что если у меня циклов отрицательных нет,
то, наверное, в первом шаге я нашел правильный ответ.
И тогда здесь было бы равенство,
потому что если бы я позволил еще одно ребро,
если бы я сделал еще один переход в динамике,
у меня бы dp не изменилось,
потому что нет смысла использовать n на ребро,
если нет отрицательных циклов.
А вот если они есть, тогда на каждом цикле я найду,
по крайней мере, одну вершину, для которой dp уменьшилось.
Ну и тогда давайте я напишу алгоритм.
Это утверждение я уже докажу на следующей лекции.
А сейчас напишу алгоритм.
Мы запускаем dp до n-ного слоя,
дальше находим множество вершин,
до которых dp уменьшилось,
ну то есть для которых
dp уменьшилось.
Вот это мне нравится выполняется.
А dp в это n-ое
уменьшим dp в это n-ое.
И из них всех я запускаю,
ну что типа dfs?
И говорю, что все вершины,
достижимые из них dfs,
имеют минус бесконечный дист.
Из них запускаем dfs,
для всех посещенных вершин
говорим, что дист равно
минус бесконечность.
Ну это вроде почти очевидно,
потому что если мы нашли вершину,
у которой dp уменьшилось,
то это скорее всего вершина
на отрицательном цикле,
значит все, что из нее достижимо,
очевидно, имеет на самом деле
минус бесконечный дист,
потому что я сначала могу от s дойти до v,
потом сколько угодно долго петлять по c,
и потом дойти куда надо, до t.
Поэтому все, что достижимо из v,
на самом деле имеет минус бесконечный дист,
потому что я могу петлять по c.
Я для них объявляю ds равно
минус бесконечность,
ну и собственно все.
И тогда после этого я знаю все вершины,
на самом деле минус бесконечное расстояние,
ну а все остальные,
для них правильный ответ
это просто dp с n минус первого слоя.
То есть если я вершину не посетил
на этом шаге,
то для нее ответ это просто то,
что обычный фортбол он бы нашел.
Докажем это,
сейчас переходим в 202nk,
кто хочет, и там мы докажем,
что это все правильно работает.
