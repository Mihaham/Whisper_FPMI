Так, судя по тому, что начались всякие генерёжки и прочие
мероприятия, скоро наступает посвят.
Но, возможно, он в этот раз пройдёт более активно
по той простой причине, что вроде никаких ограничений
нет.
В общем, жили-были студенты в семёрке и решили не отмечать
посвят.
В процессе отмечания им не хватило сока, но значит
они кого-то пошлют за соком.
Время уже позднее, поэтому первокуров послать нельзя.
Они не совершеннолетние, для них движет комендантский
час.
Но старокуры совершеннолетние, они уже спокойно ходят.
Старокуров как-то лень, поэтому отправляют самых
младших, самых духов по армейской терминологии.
Ну, в частности, второкуров.
Прибегают, в общем, из всей компании послали самого
младшего, то бишь второкурсника, прибегают он в палатки
и видит.
Там есть куча сока.
Вот его послали за литром апельсинового сока.
Он побежал, принес и его бусинка из всей компании
выпала и послала еще за литром апельсинового
сока.
Тем компания захотела бананового сока.
Он побежал, принес, но у него начали возникать некоторые
подозрения.
И, возможно, этот хитрый второкур, естественно,
из всех школ, программ, информатики, умеет считать,
начал о чем-то догадываться.
Ну да, возможно, кэш у него не очень много, поэтому
нужно выбирать, какой закупить еще.
Нет, его отправили злобные старшекуры, которые устраивают
слобную защиту и требуют ровно конкретного.
Ну, известно, что как только он сбегал за апельсином,
его снова послали за тем же.
Только что его первый раз послали за банановым.
Какие будут предложения?
Так, как предложила Оля.
А, тем более, она в том, что она может сама исправить,
что сколько он взял.
Он сразу взял 2 литра бананового сока, притащил один виду,
затем его послали снова за банановым, и он очень
быстро смог его выдать.
Почему он смог его быстро выдать?
А свадьба была уже в рюкзачке, конечно, небольшом рюкзачке,
но сколько-то у него помещается.
Злобные старшекуры снова послали его на этот раз за
виноградным за 1 литр.
Нет, поправили его, попросили бы за виноградным.
Если он каждый раз будет брать по 2 литра вместо 1,
то насколько реже он будет бегать в палатку?
Нет, мы не знаем, в каком порядке он будет бегать в палатку.
Короче, он будет бегать в палатку по 1 литру.
Он будет бегать в палатку по 1 литру.
Он будет бегать в палатку по 1 литру.
Есть одна большая проблема.
Это бедный второкурор, у которого нет денег 7 пачек
40 сразу.
Ну, ему каждый раз давали.
Можно нанять другого второкурора?
Ограничение по финансам.
А какой интерес так его бегать?
Это какой-то дополнительный ресурс.
То есть, просто предположив временную локальность,
если мы пыли какой-то сок, то значит скорее всего
мы захотим еще получаем снижение частоты похода
в палатку в 2 раза.
Ну, допустим, нашего второкура объема рюкзачка, ну и, соответственно,
кэша в кошельке хватает на 4 пачки сока.
Его пока первый раз послали за одним виноградным,
и он помнит некоторую историю действия до этого.
Что он может предположить?
Какой брать еще?
Ну, давай, пиши.
Так, наш второкур.
Ну, хорошо.
Не с этим любят инициатора.
Ну, может быть, Оля сделает.
Ну, то есть, можно сделать примерно так.
Он предположил, что скорее всего они решили пить стоки по алфавиту,
и взял 4 литра сока, 2 виноградного и 2 грушего.
То есть, он предположил такие вещи, а именно временную локальность,
то есть, если какие-то данные нам понадобились, то скорее
всего, им понадобится снова, и пространственную локальность.
Возможно, нам понадобятся соседние данные.
И, имея рюкзачок и количество коша в кошельке на 4 пакета сока,
насколько реже он стал бегать в палатку?
Ну, плохое такое ускорение.
Да.
Дальше он стал решать домашнюю работу по какому-то предмету,
связанному с программированием.
Осталось писать что-то такое.
Что-то такое.
Думайте, какие-то законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательные законодательные законодательные
законодательные законодательныеori
законодательные законодательные законодательные законодательные
Если мы ее только что исполнили, очень великая вероятность,
что мы ее будем исполнивать снова.
А еще и массив мы проходим последовательно. Что это нам дает?
Значит, нам нужно, если мы умеем из какого хранилища данных относительно медленного,
которое нам приходится ждать, пока мы вытащим данные, вытащить сразу несколько данных,
следующий элемент нам тоже нужно вытащить. А если мы какой-то элемент только что используем,
стоит его сохранить в чем-то более быстром и снова использовать. Вот так работает кэш.
Если вы лезете в оперативную память относительно медленного устройства,
вы сохраняете данные в кэше процессора, вытащить даже не вы, а это делается прозрачно для вас,
вы просто набраете часикл с памяти и внезапно некоторые обращения с попаданием в кэш
приводит к тому, что вы обращаетесь к данным быстро. Если вы тащите данные с диска,
то вам нужно дождаться, пока магнитный диск довернется нужным секторам к считывающей головке,
а сам блок головок дойдет до нужной дорожки на диске. Это ждать долго, но зато как только вы
это считались, можно считать сразу несколько сектов и они сохраняются в оперативной памяти,
в более быстром устройстве. А теперь вы решили посмотреть, ну, допустим, лекции на ютубе.
Всем потоком. Внезапно оказывается, что канал Fistech во внешний мир тоже не бесконечный.
Что же в таких случаях делает Google, чтобы такой хаббор-эффект не положил ютуб?
Они ставят кэширующий сервер. То есть некоторое время до того, как Google стал убегать из России,
он стоял в 210 ППМ, все равно им хватает телекома. И на самом деле все, что смотрелись в ютубе,
смотрелись с этого сервера. И это все сохранялось в кэше этого сервера. А он в единственном
экземпляре забирал данные от Google. Смотрит у нас целый поток лекции перед экзаменом. В единственном
экземпляре забираем данные с реальных серверов Google и сотни потоков отдаем здесь. Вот так работает.
А теперь как же нам с учетом этого написать программу, которая будет дружесленна к использованию кэша?
Допустим, у вас есть две матрицы, и вам нужно их перемножить.
Вот где такие матрицы. Как нам заставить наш комп считать, перемножать их быстрее?
Вот такой нехороший. В прошлый раз подвергалось обменю коммутативность и ассоциативные сложения.
Теперь я вам расскажу вам неправильные вещи про аналит. Вот у нас есть какая-то матрица.
Как нормальный человек. И вторая матрица.
Как ее перемножает нормальный человек? Идет по строке и по столбцу.
Что у нас не так с матрицами? Исправляем до правильного размера.
Здесь идем по строке или по столбцу? Как решетками отмечено.
А во второй? Сколько строк должно быть во второй?
Написываем.
При этом, допустим, мы в кэш утаскиваем, прочитав некий элемент, утаскиваем соседний.
Мы попали сюда. Промах мимо кэша. А здесь взяли данные из кэша. Промазали из кэша, промазали из кэша.
Идем здесь. Промазали. Попали в кэш. Промазали. Данные в кэш. Попали. Промазали. Данные в кэш.
Когда мы шли по строке, то сколько у нас получилось промахов мимо кэша, то есть реальных обращений к памяти?
Всего три. А когда мы шли по столбцу?
А какова у нас вообще сложность перемножения матрицы, алгоритмическая, если у нас две матрицы N умножить на N?
Аналит, вроде, никак не давали, сдавали.
Какая у нас сложность транспонирования матрицы?
То есть потратив время порядка N в квадрате, мы можем эту матрицу транспонировать.
И после этого мы в некоторую константу раз быстрее будем делать операцию, которая делается N в кубе раз.
Если кэш у нас побольше, например, целых четыре элемента сохраняют, тогда у нас и попаданий в кэш будет больше.
Первый раз мы промазали, затем взяли из кэша, из кэша, из кэша. Промазали из кэша, то есть где-то раз так четыре, ускорим.
То есть нам нужно хранить данные в своей структуре так, чтобы они же по возможности лежали последовательно.
И обращаться к ним по возможности последовательно.
Наш бедный процессор предполагает, что мы будем забирать данные именно последовательно.
А также использовать те, которые мы только что использовали повторно.
Теперь вот у нас есть некоторый кусочек данных, который занимает 7 байтов.
Есть, допустим, у нас кэш-линейка, которая на конкретной модели процессора допустим 8 байтов.
То есть в реальности, чтобы вычитать эти данные, мы читаем по какому-то адресу и в кэш попадает 8 байтов.
Прочитали один раз, затем мы хотим прочитать второй кусочек данных.
Сколько у нас, что у нас прочитается второй раз.
А также возможно, что наши данные окажутся
например вот здесь. И чтобы прочитать вот этот кусочек данных из 7 байтов,
физически будут два обращения к памяти. Первая прочитает аммидиатмично маленькими буквами,
вторая где большими. Еще одна контроинтуитивная вещь. Мы хотим прочитать 7 байтов,
а вместо этого из памяти прочитали два раза по 8 байтов.
Ну и два раза лазили в оперативную память. Память у нас медленная, ну по крайней мере относительно
регистр процесса. Ну или диск у нас медленный относительно оперативной памяти. Принцип
остается тоже. Как же нам сделать так, чтобы нам не приходилось лишний раз лазить в оперативную
память, если мы читаем кусочками по 8 байтов. Да, давайте заплатим памятью за время.
Обычно размер кэш линейки это некоторая степень двойки и вообще все считается некими
кусочками по 2 в степени Н байта. Допустим несколько байтов размер кэш линейки в процессоре,
или с жесткого диска мы считаем какими кусочками минимум 512 байтов, с магнитом оптического минимум
по 2 килобайта, с 2 мешек тоже возможно большими кусочками. Исходя из этого, как мы можем
ускорить работу нашего перемножателя матрицы? Что мы можем сделать с размерами этой матрицы?
Какое же, если не тысяча на тысячу? Ну можно тысячу такое некруглое число.
Округлито тысяча двадцать четырех. Ну попробуйте написать перемножение матриц и попробуйте
и померить время. Насколько быстро будут они перемножаться после этого?
Ну алгоритм это хорошо, но не будем отбирать хлеб у кафедры мол.
Если мы хотим померить, то сколько раз ускоряет нам кэш, то как мы должны поставить эксперимент,
так чтобы на это минимально влияло наше все остальное и сделать минимальную погрешность.
Да, внезапно вам пригодится та культура эксперимента,
которую вы освоили на ПИЗЛАБах, ну или не освоили. На что потратится время,
если вы будете писать это в какой-нибудь среде заработки и вводить матрицу такого размера вручную.
А как же нам их ввести тогда, если не вручную?
Ну можно, например, сделать так с перенаправлением потока ввода-вывода.
Ну и здесь, несмотря на то, что мы отключим от процесса всяких медленных положенных мешков,
ввод-вывод займет существенное время, потому что в любом случае ввод-вывод медленнее,
чем оперативная память. Нам нужно что-то, что работает быстрее, быстрее, чем оперативка.
Значит, матрицы должны у нас для чистоты эксперимента генерироваться на ходу,
то есть по какому-то правилу генерироваться, причем меньше, чем за n куб, существенно меньше.
То есть за сложный порядок от n квадрат, в крайнем случае n квадрат много,
генерироваться прямо перед вычислением в нашей программе, прямо в оперативной памяти,
а затем уже перемножаться. Попробуйте, что будет, если перемножать строку,
можно их даже генерировать сразу трансформированными. Строку на столбец, строку на строку, столбец на
столбец. Ну и сколько это займет времени? А просто померить. Время вы можете с помощью
утилиты тайм. То есть запускайте под утилиты тайм вашу программу, и она мерит сколько времени
на работу. Ну вот и будет интересно посмотреть, сколько у вас получится. Какое ускорение у вас
получится от использования кыша. Следующий эксперимент. Можем ли мы залезть в данные
другой программы. Ну или не другой программы, а хотя бы другой кусок данных нашей программы.
Пишем некую структуру.
Интересно, по каким адресам у нас будет лежать этот самый
массив Х?
Ну давайте проверим.
Справим ошибку.
А вот библиотеку Lipsy мы как раз пролинкуем, причем динамически. Вот мы запускаем,
делаем несколько запусков. А теперь вспоминаем Fizzlabs. Что мы можем вынести из нескольких
последовательных экспериментов. Адреса у нас. Но сами адреса у нас меняются.
Используется адрес Space-Layout-Ranomization, ISLR. Это для того, чтобы всякие злобные хакеры,
типа Николая и Владислава, нам ничего не поломали. По крайней мере, чтобы это сделать было труднее.
Можем ли мы, обращаясь только к нашему массиву, изменить значение Х? Как?
К указателю прибавить 17? Что с этим сделать? У нас 23 интересно.
Что это вы подсовываете мне какое-то левое значение, говорит компилятор?
Может так сделать?
Интересный результат. Почему такое?
Интересное число. 1643. Что бы оно значило?
То есть в самом младшем байте 123, в следующем 45. Ну вот и интерпретировалось.
С учетом того, что у нас Литл Эндиен. А как бы нам напрямую записать?
Прямо в Х. Прямо в этот байт, где лежит Х.
Нет, ну это не интересно. Плюс 17 мы в соседний байт записали.
Только ли Интел?
АМД тоже.
Взяли и записали.
Ну у нас 16 байт. С 0 по 15. Если сдвинуть на 16, мы вылезем за пределы.
На 17 это уже шаг дальше. А как можно изменить эти данные на 0, если у нас будет некая строка,
которую мы сюда копируем. В этот самый массив.
Здесь у нас некие данные. Некая строка. Состоящая из 16 байтов.
Если мы хотим, чтобы это была строка, какой должен быть последний байт?
Причем не код символа 0, а именно численно 0. А что будет, если мы с помощью СТРЦМП
копируем в этот массив строчку, в которой будет 16 значащих символов. Ну и естественно символ
терминатор 0. С 0 по 15 будут значащие, а на 16 месте будет символ терминатор за значением 0. Что тогда произойдет?
Чего не хватает? Вот тут у нас лежат 4 байта этого самого X, в предложении 4-байтовый.
В общем, самый младший что-то значащий. Допустим, как раз 3 0, потому что число у нас небольшое,
не превышает 256. Если у нас в строчке появится еще один символ, то символ терминатора как раз
затрет от значения. То есть мы передаем просто строчку, состоящую из каких-то символов в количестве
16 штук и затем символ с нулевым кодом. В предположении, что кто-то положится функцией СТРЦКОПИ,
например. И честно копируют до символа с нулевым кодом. В результате происходит переполнение этого
массива и данные попадают в соседний. А если у нас был, допустим, логин и айдишник пользователя,
и айдишник пользователя внезапно стал нулевым. Что у нас стало с пользователем? Вот такие бывают
последствия переполнения. А что же делать, чтобы переполнения не было?
Моно вам об этом что-нибудь подсказывает?
СТРЦКОПИ
Монологично не в копе, но именно ограниченный.
Теперь вдруг выяснилось, что некоторые западные, ну и восточные типа TSMC компании не хотят с
нами работать. И в частности, поставлять процессором. Что же делать придется? Значит,
придется делать свой процессор 160 СТРДЦКОПИ. Ну давайте сделаем небольшую модельку такого
процессора. И некий эмулятор, его работа на СИ.
Допустим, наш процессор будет
поддерживать. Будет иметь несколько регистров. Назовем их А, Б, Ц, И, Д. И пусть они в неком
будут иметь номера с 5 по 8. Пусть он у нас будет делать некоторые команды. Например, ОСТОНОВ,
СЛОЖЕНИЕ, УЧИТАНИЕ, ПРИСВАЕВАНИЕ. Ну и команда инфорегистров, которая задамит нам все
содержимые регистров. На вход у нас приходит некоторая команда. Дальше мы должны разобрать,
что это за команда и что-то с ней сделать. Сами регистры нам выгодно хранить в виде
чего? В виде некоторого массива. Считали нашу команду, если она не ОСТОНОВ, не 0. Проверяем,
если это команда СЛОЖЕНИЯ. Читаем номера регистров, с которыми нам нужно что-то сделать.
Может быть они окажутся недопустимыми. Мы это обрабатываем. А если все хорошо,
к одному регистру из нашего регистрового файла, т.е. массивы регистров, предлагаем значение
другого. Вот у нас уже процессор, который что-то умеет делать. Логично с вычитанием.
По команде MOV что-то присвоить мы берем и записываем данные в наш регистр. А по
команде info-registers мы берем и все нам выводим.
А как нам в принципе организовать витвление в нашем процессоре? В одном случае сделать
одно в другом другое. При этом мы должны сохранить такую важную вещь, как обратная
совместимость. Бинарные программы, написанные под наш процессор. Предыдущие вещи должны
работать на более новый. Вот каждый номер регистра или номер команды мы использовали целый байт.
Можно. Возможно вариант. Мы введем еще один битик, в котором будет граница информации да или
нет. Т.е. есть или нет эти поведки zen или поведки else в нашем витвлении. Не стоит
использовать их любитые как флаги. Все-таки могут быть любые значения.
Как мы можем проверить условия, что один регистр больше другого? Используя существующие команды.
Например один регистр равен другому. Точно равен. А давайте мы из одного регистра другой вычтем.
И возможно получим одно очень интересное красивое число, если они равны. И поставим
большого брата следить за нами. Если в результате какой-нибудь операции получается
нолик, ровно нолик, все биты нолики. Пусть он поднимает такой яркий флаг, название zero flag.
А какие еще флаги у нас могут быть?
Какими-нибудь интересными числами, которые получаются в результате вычлений.
Положительные числа детектировать сложно. А отрицательные проще.
Как мы без знака вытащим отсюда?
Допустим, если процессор у нас 8-битный, с какой маской?
Если в результате это побитые операции у нас получился нолик, верно ли, что число у нас отрицательное?
Имеет отрицательный знак. Значит оно не отрицательное. Не отрицательно додектирует проще, чем положительно.
А можем мы с помощью комбинации этих двух флагов сказать, что у нас число положительное?
Если сигн флаг у нас нолик, при этом zero flag тоже нолик, значит число положительное.
Какие еще эффекты стоит отлавливать?
Например, сможем ли мы отлавливать факт? Число у нас четное.
Можем ли мы обращать внимание на тот факт, что мы сложили допустим в 8-битном регистре?
127 плюс 127. Сколько у нас получилось? Интересно. В процессе сложения у нас изменился старший бит.
На что это намекает? Что у нас случилось? Ага, то есть флаг про переполнение. Еще про что?
А если у нас без знаковые числа? Мы сложили 128 и на сколько получилось? На ноль.
Пожалуй, об этом факту тоже стоит поднять какой-нибудь интересный флаг.
Что у нас произошел? Перенос в старший разряд. А если мы такой флаг сохраним и при этом захотим сделать динку?
Мы захотим складывать 16-битные числа, а у нас процессор поддерживает 8-битные.
Был ли перенос? Да, соответственно. Затем в старших байтах складывать старший одного флага и старший другого, плюс флаг переноса.
Вот, пожалуйста, у нас получилась длинная рифметика на базе этого флага.
А как бы нам сделать условное исполнение? Причем так, чтобы наш процессор быстро работал.
Вот сидят тут студенты. Слушают про архитектуру.
Параллельно решают задание по Матану, чтобы написать контрольную, которая будет на следующей веопаре.
Пока у нас делается одна операция, мы готовимся к следующей.
Пока мы записываем результат одной команды, мы вычисляем следующую и вытаскиваем из оперативной памяти данные для после следующей.
Что же это за организация труда такая? На заводах еще используется конвейер.
Вдруг мы говорим так, а теперь в срочном порядке переходи по тому адресу исполнять другую команду.
Поможет то, что мы уже частично сделали следующую команду на конвейере.
Например, вы готовились к 15 минут контрольной лекции по Матану, которая будет на следующей паре.
Вдруг вам говорят, извините, у вас будет вместо этого лекция по физике, но тоже с 15 минут.
И вообще в лабораторном.
А могут заложены заботливо разложенные шпаргалки под партами 239?
Почти.
То есть нам нужно по возможности не допустить срывов конвейера.
Теперь мы сделаем иначе.
Приходит на следующую лекцию преподаватель Матана и говорит, если у вас окажется меньше чем 7 человек на лекции, то она не будет контрольная.
Ну а затем будет, допустим, лекция по физике, и если вы просто готовитесь к лекции по физике на тех же условиях, то конвейер не потерялся.
То есть нам выгоднее вместо того, чтобы прыгать куда-то в другое место, исполнять другую команду, просто некоторые команды исполнить условно.
Как раз у нас в номерах команд старше бита не используется.
Допустим добавим такое условие.
Если в старшей бите команды
Стоит эта единичка и, допустим,
то выполняется эта команда тогда и только тогда, когда зервь флаг установлен.
И старший бит не установлен, значит мы эту команду исполним безусловно и всегда.
То есть там стоит нолик, скобочки.
Убираем старший битик.
С помощью вот такой маски все остальное осталось тем же самым.
Сомневаешься? Оставь скобки.
Если тебе не очевидно, значит хотя бы лечитаемость эта нужна.
И все остальное осталось тем же самым.
И мы запросто приделали условное исполнение, сохранив обратно совместимость.
Вот так мы взяли и сделали свой процессор.
Вот примерно об этом и будет следующий контест.
Атаковать с помощью переполнения буфера, быстро перемножить матрицы и написать свой процессор.
И мы уже вплотную подошли к ассамблеру.
