В прошлый раз мы делали фанкшн и делали его через виртуальные функции, в этот раз мы делаем ене, будем делать уже без виртуальных функций.
Наверное, даже чтобы замотивировать, зачем этим всем заниматься, надо посмотреть еще раз на этот фанкшн и подумать, где здесь может тормозить.
Где здесь перв проседает?
Вот тут сейчас есть два таких крупных места, где перв проседает. Фундаментальных.
За счет чего?
Вот, а как работает виртуальный диспатчинг? Напомните мне кто-нибудь.
Ну, у нас в типе есть указатель на виртуальную таблицу.
В типе, в плане?
Ну, в риалте.
Да-да-да. То есть прямо в каждом объекте перед этим объектом лежит указатель на виртуальную таблицу.
Да.
Собственно, можно пройти по идее...
Ну, это детали. А что главное лежит в виртуальной таблице?
Указатели на виртуальную таблицу.
Ну да. Просто обычные указатели на функции, которые показывают, что нужно вызывать для этого объекта в качестве виртуального метода.
То есть вот тут мы дергаем какой-то кал, кол.
И что происходит? Мы на самом деле из вот этого вот объекта storage...
Окей, тут даже еще больше неэффективностей.
Во-первых, мы загружаем из памяти указатель storage.
Дальше мы по нему проходим, и туда, где он указывает, там где-то лежит указатель на виртуальную таблицу.
Виртуальную таблицу.
Его тоже нам нужно загрузить. Загрузили, значит, storage загрузили.
Загрузили vtable.ptr.
А пройдя уже vtable.ptr, нам нужно еще и загрузить сам указатель на функцию call.
Итого три операции load.
А кос у всех тут был, правда?
Помните, там есть move из памяти, он дорогой.
Вот три операции загрузки чего-то из памяти.
Каждый из них по крышу промахивается, в принципе.
Почему я так говорю?
Потому что сама функция может быть не в кэше.
Раз промах.
А storage мы куда-то на кучу унесли.
Она вообще где-то в стороне от всего происходящего.
Это два промах.
Ну и vtable.ptr тоже может быть далеко не в кэше и три промах.
Ну и всего там, если вспомнить аналогию, которая, кажется, вам приводил,
то там типа 300 условных единиц занимают все эти путешествия,
а мы хотим меньше.
Из этих трех разыминований можем мы выкинуть какие-нибудь?
И как?
Было предложение еще на прошлый тайм сохранять указатель на функцию сигнатуры white-noid?
Ну какую-то, да.
И называть ее?
Ну вот.
Стоится на предложение развучено, это прям вот здесь,
хранить какой-то указатель на функцию.
Ну непонятно, какой сигнатуры, наверное, такой.
Ну да.
Вот, и тогда, чтобы сделать оператор круглые скобки,
нам нужно всего одну загрузку чего-то не прогретого не в кэше.
Ну тогда уж даже не void, а red.
Ну red, да.
То есть каким-то таким образом это делать.
Ну это сильно лучше может быть, особенно с условием,
что сам объект function, с которым мы работаем,
он, наверное, тоже будет в кэше.
Ну то есть это резонное предположение, когда вы пишете какой-то класс абстракцию,
что пользователь вашего класса сам позаботится о том, чтобы этот объект был в кэше.
И все поля, которые у вас в этом классе, можно считать они прогреты.
А вот если что-то у вас на кучу вынесено и там где-то лежит,
ну это никто прогреть не сможет за вас.
Вот, а еще есть неэффективность, помимо того, что в операторе круглые скобки.
Которая гораздо на самом деле хуже, чем вот то, о чем сейчас говорили.
Лямда это нормально.
Лямда это просто краткий синтаксис для того, чтобы определить еще один класс
с оператором круглые скобки и какими-то полями.
Ну вот нью на свободные функции, это конечно да, как-то неэффективно,
но я бы больше даже сказал, что вообще нью это неэффективно.
Вот удивительный факт, что аллокаторы оказывается очень медленные бывают.
Ну это прекрасная идея, но когда речь идет о кросс-плате,
то там сразу беды начинаются.
Вот здесь мы там смогли тесимолок подкрутить, а здесь не смогли.
Вот его просто авторы не портировали на эту платформу.
Либо иди сам портируй, либо стандартные локаторы этой платформы используй,
либо свой пиши, ну или еще какой-нибудь сторонний джемолок, еще что-нибудь.
В общем, на самом деле это просто неэффективно.
Ну или еще какой-нибудь сторонний джемолок, еще что-нибудь.
В общем, народная мудрость гласит, что если можете без аллокаций написать,
то лучше писать без аллокаций.
А можем ли мы, внеся некоторое ограничение на то, что вот здесь происходит,
конкретно где-то вот здесь внеся ограничение, обойтись без аллокаций на куче?
Ну нам не известно комплайлтами размер нашего объекта,
поэтому мы можем его засунуть в наш стэк.
Ну не в стэк, а как бы inline, это вот лучше, прямо inline в наш объект.
Но это, конечно, правда. Давайте скажем, что он не больше 64 байт.
Вот это прекрасная идея, потому что практика показывает, что огромное количество...
Ну вот тут про указатели на функции сказали, что когда мы запихиваем
какой-нибудь указатель на функцию или указатель на член класса,
то мы там неэффективно все это тратим.
Но практика показывает, что в принципе такие типы, такие TypeRace контейнеры,
они используются для всяких колбеков, для передачи какой-нибудь колбека,
трансформации чего-нибудь в какую-нибудь там штуку, посещающую что-то
или обрабатывающую что-то. И все эти вещи обычно маленькие.
Ну вот очень редко бывает так, что вы в лямбду и вот сюда запихиваете много-много-много байтов
чего-то там непонятного. В большинстве случаев вы просто this туда захватите,
и все, это 8 байт. Соответственно, кажется весьма резонным предположением,
что в большинстве случаев тут мало байт, и нет никакой нужды это все на кучу выносить.
Надо это все впихать прямо вот в inline память.
Ну и сразу, чтобы так сказать не быть голословным, давайте...
Да нет, надо просто гранулярность каша смотреть.
Это 4 байта, да. Нет, это не про фолдшеринг, а про то, что у вас просто данные в память
загружаются по кашлении. Ну сейчас, что я говорю.
Даже за 1 байту, это не так.
Это не про фолдшеринг, а про то, что у вас просто данные в память
загружаются по кашлении. Ну сейчас, что я говорю.
Даже запрос 1 байтика прочитать из непрогретой памяти, он по дороге к процессору
с собой захватит вот такой регион в Эль 3, вот такой регион в Эль 2, вот такой там
в Эль полтора какой-нибудь, и в Эль 1 у вас долетит, во всяком случае, хотя бы 64 байта
окружающие вот этот вот 1 байтик. Ну я бы сказал наоборот, больше, чем 64 байта
делать бессмысленно, если мы как-то смотрим на это как чистый такой оптимайз
всего подряд. Но вот тут другой ответ есть. Вот вы пытаетесь число придумать, а
ребята из Electronic Arts сказали, не будем мы числа придумывать, вот у них замечательный
шаблон, есть fixed function. На работе у нас им обмазано примерно все. Заметьте, он
принимает int и type name. Ну type name это понятно что, это вот самая наша сигнатура,
ой, это не тот VS Code, да. Вот, type name это вот эта штука, сигнатура. А что за int?
Тут самый inline размер, ну и если мы сейчас чуть-чуть поскролим, видимо вот это.
Сейчас надо найти, где этот size and bytes устанавливается, вернее используется.
Жесть, что так много? Давно этот код не читал, ну вот, не удается мне найти, сейчас.
А, ну конечно мы здесь этого не найдем, да, потому что нам нужно на самом деле вот
сюда, ну ладно, давайте, да, internal, вот. Там просто fixed function это обертка,
и опять же на следовании используется, приватная, кстати, как вы в принципе в slice
уже делали. Вот, где здесь...
Function detail наследуется от function base detail.
Да, без навигации по коду, конечно, очень неудобно, но кажется, кажется, вот сейчас
вот здесь где-то должно найтись, и да, е-мое.
Нету, да? А вот function storage, вот же он.
Внимание, так сказать, на экран. Ну, тут еще какой-то класс используется, хитрый,
но кажется, это в целом не весь размер объекта, то есть в придачу к этому тут еще что-то
хранится, какой-то указатель, ну вот хоть что-то, поэтому выставлять его надо, наверное,
не 64, если мы хотим там, чтобы все в кошелинью вылезло, но тут даже не в этом суть, даже если
мы в кошелинью не влезаем, вот этот класс, он вполне разумный. Мы можем прям ну просто
под все use-кейсы, которые у нас в кодовой базе есть, подогнать нужный размерчик,
и если мы там этот колбэк не просто передали куда-то, а еще и храним, то хранить хочется
как можно меньше байтов, и вот такой класс прекрасно помогает и работает. Ну, еще раз
повторюсь, что это просто другой класс, нежели STD Function, вот 32 вы сказали, и лямбду,
который больше 32 байт внутри, в захвате вы передать не сможете. Вот.
Статик и серд будет? Да, статик и серд будет, просто скажут вам, не компилируюсь,
а можно по-другому. И вот у стандартной Function, если вы в какую-нибудь реализацию
STD C++ или C++ полезете, там на самом деле тоже можно найти вот такую забавную конструкцию,
где какое-то хранилище байтиков прямо внутри класса Function, но оно работает хитрее,
и вот никакого дополнительного параметра нету. И этот Function работает и для размеров больших,
и для маленьких. Ну, можно посчитать сам размер и сделать специализацию, если размер меньше.
Нет, как мы сделаем специализацию? Да, специализацию сделать мы не можем.
Давайте еще раз поймем почему, потому что тип лямбды нам известен только в этом конструкторе.
Сделать специализацию всего класса Function не получится. Конкретная любая специализация Function
должна уметь и на куче хранить, и как бы внутри себя. Ну и несложно догадаться,
как это сделано на самом деле. Ну вот Union. Здесь оно кажется тоже про это,
но там вот этот вот интерфейс публичный немножко хитрый. Просто делается Union из
либо storage, либо массив байтиков какой-то, причем уже фиксированный. Что-нибудь такое.
Повод использовать Union вместо варианта есть, потому что вопрос в количестве байт.
Да, мы же собрались здесь делать 64 байта, соответственно нам... Нет, в рантайме нужно следить за
типом во всяком случае. Не факт, мы могли бы использовать у варианта его индекс для слежки,
что у нас там сейчас лежит. Указатель на кучу или прям сырые байты. Но я говорю, это неэффективно,
потому что у варианта по-моему size t используется. Вот если я не вру, то там по стандарту говорят,
что должен много-много вариантов уметь поддерживать. Ну и это size t это максимально жирно,
когда у нас всего два варианта. Зачем брать какие-то бусты, когда ты сам можешь взять и сделать здесь
bull on hip. Ну 2.1 тебе не поможет, потому что... Да, тут как бы еще не получится что-то запихнуть.
Нет, ну эта идея правильная, ее можно развить. Я слышал, да, что Rast все умеет хорошо распихивать,
но удачи им с аби-стабильностью, аби-совместимостью и прочим-прочим. Ну то есть вот как вы
игру устанавливаете, у вас там иногда заново ставится какой-нибудь Microsoft, CPP, Visual C++,
Redistributable, тыры-пыры. И все жалуются, какого черта у меня на компе 30 версий Microsoft Visual C++.
Ну от чего это как думаете? Ну да, у них нестабильная аби была у Microsoft долгое время,
и несмотря на то, что стандарт особо не менялся, они такие, мы обновили C++ Redistributable,
вот наш стандартный билетек теперь умнее и круче, но аби сломали, поэтому пересобирайте все свои игры,
либо это. Говоря, не были какие-то серьезные проблемы, потому что стандартный билетек,
она не весит в гигабайты. А Visual C++ Redistributable весит в гигабайты? Ну в Rast такая же проблема,
сколько весит все эти ваши крейты, которых вы там подключаете, и особенно с мономерфизацией,
ну там как бы если на Rast будут активно писать приложения такие, ну как по типу офисных,
которые там на каждый компьютер ставятся, вроде Excel и прочее, то это очень быстро все взорвется,
мне кажется. То есть какие-нибудь сервера, никаких проблем, весь сервер закинули, окей,
а вот если что-то там для юзеров, то ну начнет немножко пригорать у них от размеров всех этих
бинарей. Ну в общем-то мы в сторону отошли. Мы о чем говорили? О том, что не хочется 8 байт целых,
когда нам нужен один булевый флаг. Ну сказали, можно просто сюда Bool подпихать. А вот если вы
внимательно слушали курс Concurrency, там был еще прикол такой, что если у вас есть указатель,
то вообще-то там есть битики свободные. Ну тут то же самое можно сделать. А мне кажется,
на любой архитектуре так же будет. Да, это не совсем связано с архитектурой такого типа, это зависит сильно
от компа. Ну да, ну как бы всегда можно как-то что-то придумать. Вроде да, можно же еще выровнять
руками адрес, просто взять и выровнять. Нет, вот здесь
ну как бы да, но вот здесь ничего не получится сохранить, потому что в ней юниона нужно хранить.
Это здорово, но мы тогда от вот этого charbytes тоже отъели один байтик. Ну как бы все, мы этот байтик
не можем использовать. Я говорю, что вот здесь во всяком случае, вот если мы будем использовать не как
здесь написали виртуальный перлиморфизм, а руками будем делать, то у нас вне этого юниона во всяком
случае что-то будет. И вот в это что-то мы как раз и можем попытаться запихать. Не факт, что получится,
но может. Вот, то есть поняли две идеи. Во-первых, мы хотим вместо вот этих вот виртуальных прыжков
по памяти туда-сюда, туда-сюда сделать все максимально вот прям плотно и близко к сердцу,
что называется. Нет, давай мы сейчас писать начнем, и тогда про конкретные имплементации уже поговорим.
Сейчас основные идеи, во-первых, избавиться от локации, ну и да, я кажется тоже не договорил,
что здесь у нас, конечно же, будет флаг из onHip такой примерно, и вот здесь мы будем его либо
устанавливать true, либо false. Если мы на кучу вымещаем, то храним в этом юнионе просто там указатель
вот туда, на что-то, что через нее выделено, иначе прямо в этих байтах храним. Вот, это одна идея,
и вторую тоже, кажется, сказал. Ну, вроде все. Надо... Да.
Почему вы вот эту логику, с тем, как мы храним наш сторож, не отдать кому-то другому, скажем, аллокаторам?
Почему вы не перевожите эту историю?
Потому что пытались научить аллокаторы хранить данные прямо внутри классов, которым они относятся,
но получилось из этого какая-то мегауродливая шняга. Ну, ты, конечно, в правильном направлении
мыслишь, что надо бы тут все пообобщать, вынести, навести там декомпозицию, но сегодня мы этого делать
не будем. Это вы можете домашки сделать, развлечься вот в Авдовль. Вот, да, ключевые слова для тех,
кто сейчас так в полухо слушает и потом будет гуглить заново. Вот эта вот называется идея с юнионом
из какого-то буфера и указателя на кучу называется, сейчас, SBO, да, small buffer optimization.
Вы, возможно, где-то слышали вот это вот, small string optimization, но идеи в принципе везде одинаковые.
Ну, в нашем случае это, наверное, правильнее называть small function optimization.
Ну, короче, вот все эти слова, они про одно, что вы вот такой юнион делаете и в рентайме решаете.
Будем либо прямо сюда пихать или на кучу выносить. Вот.
Вот эту проблему мы отдельно фиксим. Это два независимых направления для развития.
Одно это сделать small buffer optimization, чтобы не так часто на кучу выделять.
Другое направление для развития – это вместо виртуальных вызовов использовать прямо указатели на функции.
Сейчас мы это все будем писать просто. Все, закончили со вступлением и мотивацией, что это и зачем это.
Будем творить.
Так, ну, с классом N, кстати, будет гораздо проще.
Наверное, мы даже мудро поступили, что решили вот эти все, ну, простой случай function разобрать.
Наоборот, сложный случай... Кто здесь простой, кто сложный.
В общем, вот с этим всем не нужно будет нам морочиться, что ARX, их там распаковывать, что-то там придумывать.
Function мы с этим разобрались и хватит.
С сцене у нас вообще ничего нет. Нам фактически единственное, что нужно...
Они единственное. Давайте сразу начинаем с вопроса.
Какие функции мы будем стирать?
Что? Что такое Get?
Публичный интерфейс вот такой. Вы можете сделать...
Какой из операторов присваивания?
Нет, ну, копирование или Mova?
Окей, оба.
Конструктор.
Копирование Mova, наверное, имелся в виду.
Ну вот да, я тоже так считаю. На самом деле тут невозможно сказать, что мы вот просто вот эти конкретные функции прямо стираем.
Потому что в сигнатурах этих функций уже зашит наш тип.
Поэтому мы будем чуть-чуть другие какие-то функции стирать.
Но по смыслу да, нам нужно что-то, чтобы копировать.
Копировалка какая-то, что-то, чтобы Mova, и деструктор. Что-то еще нужно?
Ну вот про доступ надо подумать. Каждый раз, когда мы получаем доступ к объекту STDN, внимание важно.
Давайте внимательно на интерфейс посмотрим, потому что, кажется, многие из вас не работали с Энни.
Это хорошо на самом деле, но вот есть функция ЭнниCast. Ей мы передаём конкретный тип, который хотим попытаться достать.
Да не придется нам TypeID использовать.
В смысле? Ну тут тоже возможно сейчас я покажу хак, а может не покажу, а может вы сами догадаетесь.
Ну да, тут правильный Аркадий сказал, что мы вот так пишем, а дальше в рантайме этот ЭнниCast каким-то образом смотрит.
Конкретно в этом Энни лежит ли там Инт или не лежит? Если лежит, возвращает на него ссылку, а если не лежит, кидает исключение.
Что? А ну да, прямо специальное исключение есть. STD BadCast. Возможно мы с ним даже поиграемся, а может и нет.
Ну давай сюда посмотрим.
Ещё, чтобы совсем смешно было, давай C добавим. Это там будет строка buy.
И сюда moveNim C. И опять же попробуем вывести, даже в B moveNim, чтобы ещё смешнее было.
И попробуем вывести B. Вот это должно работать. Кажется, здесь нужно как-то уметь копировать.
Здесь может нужно как-то уметь move, а может как-то и не нужно. Впрочем, это в детали имплементации утыкается.
Ну вот вектору нужно вообще использовать move... Да, блин, какой пример привести?
Unique pointer. Когда вы Unique pointer мываете, тип, который внутри лежит, нужно мывать?
Нет, давайте здесь также сделаем. Поначалу. То есть move штуку пока нам не надо. Потом увидим, если понадобится.
Осталась копировалка, она очевидно нужна. Мы тут прям копируем-копируем, нужно уметь это делать.
И деструктор, конечно же, тоже нужен, потому что у нас там будет, видимо, что-то на куче.
Надо его как-то очистить, поэтому деструктор храним. Всё или что-то ещё?
Ну, мне тоже кажется. Давайте пока на этом остановимся, но надо решить сигнатуры.
Где бы их написать? Давайте здесь напишем.
Сейчас, может быть, нам, наверное, нужен будет какой-то всё-таки класс, оборачивающий тип, чтобы...
Ну, зачем-то. Нам нужно, чтобы Anycast, шаблонным параметром, умел кидать исключения.
Но, кажется, хорошим кандидатом будет StaticCast к ссылке.
Давай пока не думать просто про Anycast.
Давайте сигнатурами того, чему стираем, определимся. И что это вообще за функция?
Как ты вызвав какую-то функцию void?
Ага, вот так хорошо. Но с дестроером, очевидно, он будет там...
Ну, наверное, просто дилит вызывать, да? А может и деструктор.
Ну, давайте вот так.
Вот это я у вас хочу спросить. Что интуитивно эти функции будут делать?
Что делает копер? Он берёт значение ванкова из космовой звёздки и копирует по адресу void.
А дестроер вызывает деструктор по адресу void.
Сейчас, ты сигнатуру хочешь написать?
Ну, давай сейчас.
Так, вопрос. Какие preconditions на вот эти вот указатели?
Alignment?
Да не alignment. Ну, ты их проговорил, но не явно.
Типы должны быть одинаковые.
Типы должны быть одинаковые. А что это, просто указатели куда угодно?
Нет, на объект.
И from и to?
И from и to, да. На to может не лежать.
Вот, а давай конкретно, потому что мы же в runtime не сможем понять, под to лежит объект или не лежит.
Ну, а если мы новые any копии конструируем от другого?
Да нет, ну, с этим всем справимся сейчас.
Нет, ещё раз, вот по to мы говорим, там лежит объект? Мы требуем, чтобы...
Вот. Зачем я на английском пишу? Я заработался.
Ну, мы же тут учебой занимаемся, а не работаем.
У меня мозги как-то отформатированы, уже писать комментарии на английском.
Ну ладно. Вот это важное решение, да?
В этом месте легко запутаться, когда вы половина кода своего контейнера замечательного написали,
думая, что вот в этом аргументе должен быть объект, а вторую половину кода думая, что его там нет.
В итоге запускайте, ну и, конечно, у вас там всё ломается, крашится, улетает.
Окей, это мы зафиксировали. Ну и как мы собрались вообще жить, да?
Храним копии. По-моему, у меня какое-то более удачное название было в прошлом году.
Это не копи-конструктор, потому что копи-конструктор, у него другая сигнатура, кажется, что.
Ну да, ну в целом пусть копия будет.
Ну да. Ну сейчас мы ещё развлечёмся с этим. Окей, то есть вот такая шняга получается, да?
Нет. Мы определились с тем, у чего мы стираем типы, нам надо написать конструктор, да?
Конструкторы все. Вот function мы, помните, вообще не парились про копирование, мувы.
Вот теперь пришла пора париться. Ну, но первый конструктор он не про это.
Первый конструктор у нас про то, что мы собрались инициализировать
Да нет, нормально. Ну вот тут можно лямду прям бахнуть, на самом деле.
Да нет, прекрасно. Знакомьтесь с оператором плюс. Унарным оператором плюс.
Да, он не явно кастит лямду. Ну явно скорее.
Да вообще лямды, у которых нет захвата.
Нет, он как раз и не явно кастит это в коде у нас, как явно кастит.
Ну да.
Формально он не явно кастит указатель, с которым предъявлено плюс как нового.
Ну короче, такую шнягу в коде вы можете когда-нибудь где-нибудь встретить.
Плюс и лямда. Это значит, я хочу, чтобы эта лямда стала указателем на функцию.
А вот этот плюс, он насколько и диаметр чему нужен?
То есть я буду с комментарием писать?
Зависит от того, с кем ты работаешь.
Ну, лучше, конечно, объяснять такие приколы.
Ну, вот так.
Я не расслышал. Ну ладно.
А ощущение, что уже код написанную читать за словарем?
Да нет, просто надо должную эрудицию иметь.
Как эти старости, философы, всякие латынь должны были знать обязательно,
чтобы трудами своими обмениваться, читать статьи научные.
Вот тут так же.
Но при этом, говоритель на латыни уже никто не умел.
Ну, не древность, а старость, имеется в виду.
И не писал особо никто, кроме вот научные статьи какие-то.
Ну, у нас C++ похож на латынь чем-то.
Так, давайте не будем все-таки лямбду.
Пока не будет понятно, почему.
Но действительно, тут был совет, что давайте отдельно заведем шаблонную функцию,
которая будет статик, которая будет сигнатуру иметь ровно как наш копьер.
Но на этот раз мы внутри нее знаем T.
Импульс.
А что она делает?
Возьмем импульс.
По объекту, разминованному afro.
Ни U2, а каст.
Кстати, каст.
K, const, D, звездочка, afro.
Разминование.
Разминовать это нужно.
И...
Ага.
Ой, получается, еще moof тоже.
Отвечать moof или не moof.
А статик каст не работает.
Ну разве не...
Нет, здесь const, каст. Тут const, каст не нужен, все нормально.
Нет, я говорю про статик каст, мне кажется здесь...
Почему нет?
Теп потерял скобку.
Вроде хватает скобок. Что происходит?
Ну давайте не будем страдать фигнёй и сделаем...
Const add.
Причем ему надо указать, да, что мы const, вроде да.
Вот так вот.
Чуть не компилировалось, а это нормальная функция.
Ну да, обернули, чтобы было красивше.
На самом деле там какие-то причины есть глубокие.
А плейсмент new тоже, кажется, нужно инклюдить, да.
Да, плейсмент new, он как бы...
Там хитрости какие-то вот...
Да-да-да, ну вот я лучше вот так.
Да, окей.
Ну и здесь, соответственно...
Ну я не знаю, как это делать.
Ну я не знаю, как это делать.
Да, окей. Ну и здесь, соответственно...
Ну нужно заклинание некоторое написать, да, что мы берём вот этот шаблон
с типом T, причем...
Reference или...
Вот так вот, да. Подставили нам, не подставили.
To remove const, to allow reference?
Да. Всё убрать, типа const, to allow reference, всё.
И пихнули, запомнили копир.
Ну, по аналогии, destroyer.
Тут давайте уже просто с скоростью света.
Так...
Так...
Да, конечно.
А он не должен выводить шаблоны?
А он умеет выводить тип.
То есть тут какая сигнатура? Шаблон...
Чего тогда не умел выводить?
У конструктора add сигнатура вот такая.
Вот Dp, а он выводит, что ты играли.
Он каждый отможен, надеюсь, если бы...
Ну я не знаю, красивший или так.
Ну, он вот так стало более красиво.
Ну ладно.
Ну да.
Ну, похоже на правду.
И мы их сохранили, и... Ещё нет.
Сейчас...
Как это?
Сейчас, кажется, у нас всё, конечно,
будет работать.
Так, внимание, вопрос.
А дату как мы заполним?
Ну, вот в дату что пихаем?
А, дату можно выделить?
Дату пока что выделим.
Ну, СБО мы тоже сегодня попытаемся написать.
Но пока просто, да, пока мы просто делаем new.
Ну, опять надо вот это вот заклинание кастовать.
Можно просто юзинг сделать.
А где?
Ну ладно, действительно можно.
Шаблонный юзинг, а просто индистрайл.
Я не понял, где ты хочешь юзинг вписать, но...
Вот так.
И, увы, наш Т.
Нет, форвардим, конечно же.
Хотя это, конечно, всё фигня какая-то.
Но форвардим, окей.
Кажется, мы запомнили всё, что нам нужно.
По крайней мере, мы так предполагаем.
С первого раза обычно ничего не получается,
но давайте пробовать.
Мы хотим копий конструктор.
Как написать копий конструктор?
А, а вот тут мы и можем, наверное, распрали...
Нет, не можем, потому что сейчас...
Копируем копию.
А вот хоть памяти выделить мы не знаем.
Так, копия от...
Ну вот, да.
Теперь хочется что-то с датой сделать,
но ничего не работает.
Это умная мысль, действительно.
Тут конструктор нет.
Тут много сейчас очень вариантов будет.
Давайте с таким пока доживём.
На что мы наткнулись, да?
Мы хотим память под ещё одну шнягу выделить.
Мы не умеем, да? Сколько памяти?
Ну, по-разному можно с этим справиться.
А я предлагаю сделать максимально тупо.
Нет.
Сказать, что копия у нас никуда-то,
а плейсмент не вызывает.
А просто не вызывает.
Ну а почему нет? Самый простой вариант.
По-моему, вполне нормально.
Ну, с такой сигнатурой тоже можно доехать кое-куда.
Потому что как альтернатива,
мы могли бы сейчас отдельно стереть тип
или запомнить размер могли бы.
Мы могли бы отдельно стереть тип
для какого-нибудь конструктора ещё одного.
Давайте пока так.
А как это помогло?
Мы теперь сказали, что у нас копия,
прям копирует from и возвращает новый объект.
А это значит что?
Что мы вот здесь, в копий-конструкторе,
не позабыли?
Просто копиер вызовем.
От чего от адра даты? Всё.
Ну, конструктор копирования сложился чётенький.
Давайте за 30 секунд
move конструктор.
Копер.
Копер.
Что делаем?
Ну,
я бы сказал
заменяем на
nullptr.
Почему?
Потому что в какое состояние после move придёт вот этот адр?
Валидное не нашли в салающейся.
Ну, valid button specified.
Вот это вот всё.
Какое у нас валидное состояние может быть?
Наверное, вот это всё лишнее.
Пока рано.
Да, давайте скажем, что дата nullptr
это состояние пустой n.
Тут опять же много вариативности.
Мы действительно
здесь впишем exchange.
И всё хорошо, в принципе. Окей.
Ну, накапливается, если у вас много кода
использует этот тип.
Где exchange? Attility вроде.
Окей.
Давайте destructor.
Потому что какая разница?
Нам нужно перевести адр в
любое валидное состояние.
Так, а в чём проблема?
У нас объект на куче живёт.
Мы просто указатель на куче украли у другого.
Смотрите, представьте, что это был вектор всё.
Мы просто у другого вектора спёрли указатель на данные.
Вот эта дата станет nullptr,
а у нас дата появилась.
Дестроит на nullptr?
Делит nullptr же работает у нас, правда?
Ну, сейчас можно сделать, можно не сделать.
Я был прав.
Короче, в destructor что пишем?
Делит дата, да?
Проиграли.
Ну, потому что, да, тип нужно знать.
На самом деле мы и destroy хотим поменять,
чтобы он не просто удалял и оставлял как есть.
Мы начали умничать,
а надо было по-простому пока сделать.
Потому что это undefined behavior, насколько я знаю.
Если мы выделяли память через new и t,
то надо delete тоже через t,
потому что там могут быть всякие перегруженные операторы,
какие-то странности.
Короче, давайте симметрично.
Через new выделили, через delete удалили. Всё, всё.
Что?
Ну, это же не destructor я написал, а destroyer.
Он уничтожитель.
Анигилятор давайте назовём.
Вот, так совсем хорошо.
Просто аннигилировали нашу дату, да?
Запустили код, скрашилась. Почему?
Наш код скрашилась.
Наш. Ну, наш. Кто ещё код писал?
А, ну ещё, почему же дату почистить 0pd?
А, нет, какая разница?
Какая разница? Объекты уже всё.
Ну, вот прям в этой строчке краш.
А, мы не проверили 0pd?
Да, листок нет.
Да, вот этот аннигилятор прекрасный.
Он может быть на самом деле любой фигнёй и как-то не очень хорошо, наверное.
Сейчас может быть.
Он может быть 0pd. Почему не может быть?
Мы тут пока не до конца класс дописали.
Я гипотетическую ситуацию вам сказал.
Прямо в текущем коде кажется, что он всегда валидный будет.
Но, короче, из опыта на это обязательно попадётесь.
Забудете, что у вас аннигилятор бывает 0PTR.
Поэтому я предлагаю вот так просто писать.
Вот конкретный оператор Bool сделать,
чтобы понимать, валидный мы или нет.
И когда вот такие вещи делаете,
проверяйте.
Тут же проверка даты, а не длитра.
Даты, а не длитра.
Ну да. Нет, смотри, либо наш объект Eni
в валидном состоянии, у него хороший копир,
хорошие аннигиляторы, хорошая дата.
Сейчас.
Давайте я откачу, не Destroyer больше.
Destroy add по 0PTR это нормально.
Да, но там может не быть Destroyer.
Но если там нет Destroyer,
то почему мы сравниваем с 0PTR дату?
Потому что...
Да, мы говорим, что у нас критерий
того, нормальный ли у нас класс,
это дата не 0PTR. Вот если дата не 0PTR,
то вариант соблюдён, что копир правильный,
Destroyer правильный и дата правильная.
Мы его наводим и соблюдаем везде в коде.
Давайте, чтобы у меня...
Ну вот да.
Нет, я имею в виду, что...
Это как-то тогда не последовательно,
но сейчас у нас текущий вариант кода такой,
что у нас Destroyer не может быть в валидном состоянии.
Это абсолютно неважно, потому что мы этот код
собрались развивать. Нам надо писать код такой,
и мы проверяем.
Да, почему?
Потому что мы имплементацию Destroyer
можем поменять. Destroyer в каком-то моменте
начнёт быть 0, и давайте так оставим пока.
Потом сыграет, не сыграет, не знаю.
Что нам тогда гарантирует сейчас, что у нас не может быть
как бы такого этапа развития, что у нас копытаем
дату 0, а Destroyer не 0?
Это вариант, который у нас будет всегда.
Если наш класс,
вот этот вот оператор ExplicitBull
вернул труд для него, значит он полностью
валидный. Всё внутри него валидное.
Вот это давайте всегда говорить, что ровно так,
а не как иначе.
Да непонятно,
какой ассерт бахнуть.
Ассерт?
Нет, если дата валидная,
то она указывает на объект некоторого
типа T, а Copy и Destroyer
указывают на специализации
вот этих шаблонов для такого же типа T.
Вот этот вариант у нас.
Типы T, которые вот здесь стёрты, вот здесь
и вот здесь, они не отличаются.
Давайте дальше поедем. Вы к каким-то мелочам
придрались, но это так, просто
написали и написали.
Оператор присваивания у нас ещё горит.
Как его пишем?
Может вообще сейчас всё переписывать придётся,
потому что мы не продумали, и
оператор присваивания у нас не получится.
Можно писать в лог, просто Destroyer и оператор.
Какое первое действие в операторе?
Нет, неправильно.
Вот это первая строчка в операторе присваивания.
Всегда.
Ой, блин, ну придумали идиом.
Давайте сейчас без хитрых идиом всё в лоб
писать, чтобы максимально понятно было.
Дис.
Отлично.
Если в дис у нас уже что-то было,
надо...
Надо, конечно же, удалить
то, что у нас раньше лежало.
Сейчас у нас же нет кое-какого варианта,
если мы delete пройдёмся по дате,
то она у нас не станет птр,
и поэтому если мы буквально так напишем,
то у нас потом вызовется...
Нет, возможно.
А, нет, да-да-да, окей.
Хорошо, это не важно.
Теперь вызываем копер азот дата и
присваиваем на дате.
Да, остальные понимают, что происходит.
Хорошо, я надеюсь, это правда.
Ну и забыли вот это сделать.
Окей, то же самое, но с move.
Ну, кажется, вот эти две строчки копируем, да?
Мы просто удалили.
Да? Всё просто, всё хорошо.
Мне нравится, как у меня код стайл гидит,
просто то-то там, то-то тут.
Очень сложно.
Ладно, как-то так.
Ну, окей.
Кажется, мы справились совсем,
кроме одного.
Anycast.
Просто последний для нас фронтир, да?
Да шо вы начинаете сразу TypeID свой?
Нам надо проверить,
решит ли в этом нашем Any то,
что мы ожидаем.
Шаблонные и виртуальные?
Сейчас и просто виртуальные запрещены
на этом семинаре.
Давайте сейчас
копер и дестроер в принципе сравнивать можем.
Давайте для удобства нам
нужно вытащить тип.
Я запутался, какой у нас код стайл.
Да, мы будем вот здесь основной код
писать, без исключений.
Ну, так удобнее просто, да?
Чтобы там фронтать, ничего не пришлось.
Нам здесь проверить, что
в void звездочки дата лежит
ровно такая шняга,
которая соответствует вот этому t.
Берем копер для этого t.
Все.
Вот оно сравнение.
Надо только
собраться силами и все,
мне удалось написать буквы.
Поняли, что произошло, да?
Так как я сказал, что у нас вариант,
что если дата валидна,
то она указывает на объект типа t,
а копер и дестроер соответствуют
копер импл и дестроер импл
для такого же t.
Соответственно, мы можем
по тому, что в копер лежит
копер импл для t,
сделать вывод, что void звездочка
действительно указывает на объект типа t.
Все.
Единственная проблема,
это то, что у нас тут...
Опять, вот какой вариант был,
если дата валидна, то тыры-пыры.
Поэтому вот в таком виде оно скорее всего скрашится.
А оно скрашится, знаешь, когда?
Когда у нас дата скрашена 100,
дата обгубилась, а копер остался в предыдущем.
С другой стороны...
С другой стороны, да, мы просто дату,
которая 0 птр...
Ну, вот это как бы кажется, что случайно сработало,
поэтому я все-таки строго своим рассуждением буду следовать.
Ладно, не будем, ладно, все, убедили.
Фигня какая-то. Нормально.
Ну...
Окей.
То есть в Anycast мы что сделаем?
if авто птр равно
Anycast kt
return ptr
else
badcast
Good.
Нам заинклюдели? Заинклюдели.
Отлично.
Кажется, все.
Скомпилировалось внезапно.
Давайте попробуем запустить.
Будет чудо
Хеллоуинское, если оно заработает.
Тут опять что-то не то мне показывают.
Exit with code 0.
Где консоль?
А, вот.
Выявила 42, hello, bye.
Ну, да.
Но я предлагаю не думать плохому.
Убедитесь, что убе нету.
Тесты лаундера пока расставлять нигде не надо.
Пока у нас абсолютно строгий и правильный код.
Мы просто стерли функции.
Все хорошо.
Нормально. Все.
Почему вы так боитесь?
Мы пока ничего хитрого не сделали,
а вы уже боитесь, что у нас там...
Не, не, не. Рано.
Address und Define.
У меня все продумано.
Лик может быть.
Да нет, адрес тоже лики умеет ловить.
Все, чтобы мозги мне пудрить.
Да, но лик более легковесный.
Так, давайте
от шуток к перерыву видимо.
Перед тем, как мы сядем, это оптимизировать.
А на перерыве предлагаю как-то в голове подумать.
Как можно вот эту конструкцию, пока что получившуюся,
оптимизировать по байтикам,
по количеству лоудов.
Ну и про СБО
в голове начать подумывать.
Как тут юнион припендюрить и чтобы все работало.
А пока перерыв до 18.30.
Ну что, придумали, как оптимизировать
что-нибудь?
Прекрасная идея.
Давайте объединим копир и дестроер
в одну и ту же функцию.
Ты сказал один и тот же указать.
В одну и ту же функцию.
Нет, ну мы можем просто принимать важный момент.
Вот будет звездочка и вот звездочка.
Возвращать будет звездочка.
Просто в одну и ту же функцию мы передадим 20 секунд ПТ
и возвращаем ничего. Просто их поставим.
Можно еще от каждого из них сделать текст
на размер.
И в качестве будет звездочка возвращать
либо объект скопируемый.
А можно создать клост-экспорт звездочка
клост-экспорт паун.
Клост-экспорт паун.
Что-то вы какие-то накидываете мысли.
Ключевая идея следующая.
Напишем ИВ в рантайме.
И будем делать трейдов.
Что у нас здесь меньше памяти будет тратиться.
Вот тут будет всего одна шняжка.
И...
То есть это меньше памяти.
Всего одну штуку надо будет загружать.
Всего один указатель надо будет загружать
вот здесь, например, там где-нибудь.
Вот здесь.
Но трейдов, опять же,
здесь джамп будет лишний.
Не всегда это будет быстрее.
Заметьте.
Да.
Да.
Вот если мы здесь джамп поставим, то
Бранч-предиктор, скорее всего, вообще никак не сможет понять,
чем мы от него хотим.
Это пайплайн.
А как?
Тебе нужно один указатель на функцию
сохранить.
Если у нас две разные функции, то мы уже научились.
Это идея для оптимайза.
Давайте действительно здесь какой-нибудь енам передавать
и в рантайме делать и в свитч что угодно.
Сейчас мне что-то не хочется так делать.
Но эта идея понятная, простая.
Я думаю, если захотите, сами напишите.
Так делают, например, вот тут.
Вот он, енам.
И вот здесь разные опции.
Дестракт-функтор, копия, move.
И если включен RTTI, то там getType,
gatefunk какой-то.
Ну вот, function-manager,
function-manager-base. Не поверите.
Вот у них шаблонный конструктор.
Тут он вообще не шаблонный.
Потому что весь класс шаблонный.
Function-manager-base.
Он весь шаблонный.
Вот тут эти статические функции.
И ровно один такой вызов основной.
То есть они говорят, что мы будем стирать ровно одну функцию.
Вот этот вызов менеджера.
И сюда запихивать кучу всяких аргументов.
To, from и какой-то енам.
В зависимости от енама уже либо копия, либо move,
либо деструктора какой-нибудь.
Ну и вот как-то так они живут.
Где эта гадость инициализируется?
Тут еще какие-то слои абстракции накручены.
А, это еще другой менеджер.
Еще третий менеджер.
Ну, много деталей. Давайте на них не смотреть.
Мы поняли, что так можно и будем делать сами по-другому.
До него сейчас дойдем.
Еще немножко про функции я хочу сказать.
Откуда?
Зачем?
Сейчас дойдем.
Чисто про вот сами эти функции.
Вот мы поняли, их можно мержить друг в друга
и в рантайме делать ИФы.
Можно пойти чуть-чуть по другому пути,
объединить их в структурку,
назвав ее vtable.
И это ровно он и есть.
Виртуальная таблица функций.
Сейчас.
И, собственно, вот эти все прекрасные вещи,
они тоже больше имеют отношение к...
Ладно, как это все распутать?
Давайте вот так. Эта структурка уедет вовне.
Сделаем вот так.
То есть за счет того, что эту структурку добавил,
никакой indirection не появилось, ничего не сломалось.
Все понимаем, да?
Пока нет.
Отличная идея.
Только сейчас ничего компилиться не будет, да?
Ой, сейчас надо будет поменять, да?
Надо будет сделать вот так вот, вот этого и...
Вот этого.
Вот эта вот ровная идея, про которую я сейчас хочу сказать.
Только...
Да.
Но тут структура, тут код style говорит, что надо не так,
что-то я...
А я сейчас прокомментирую,
почему это может нам захотеться в некоторых исключительных случаях.
Вначале давайте перепишем, чтобы я мог дальше уже с таким кодом...
Вот так.
Вот так.
Вот так.
Наверное, это можно было как-то быстрее
заменами сделать.
Но что поделать?
Ура.
Не ура.
Ну вот, и если совсем аккуратно сделать,
то, наверное, можно и не вот так жить,
а сделать какой-нибудь wetable make
и сравнивать уже так.
Ну ладно. Короче, идея в чем?
Давайте весь функционал, о котором мы размышляем,
все-таки его как-то сгруппируем
и будем вместе трэйчить.
Ну и как правильно заметили,
вернулись в беседу,
я закончил переписывать тупой код,
wetable.
Просто сгруппировали все стертые функции.
Теперь мы можем, как справедливо заметили,
взять и сделать вот так.
Вопрос только один, а где это будет храниться,
вот этот вот замечательный wetable?
Нет, звездочка.
Ну да.
Я не буду этого делать.
Потому что мы не сможем поменять,
да, мы хотим менять, на что мы указываем,
а не то, на что мы указываем.
Ну и куда мы будем указывать,
я выберу...
Inline, constexpr, static...
constexpr же?
Ну да, constexpr, static.
Так.
Ровно?
Ровно.
Ну он incomplete в этом контексте,
поэтому надо это вынести вот сюда.
Да, и теперь вот так еще.
Ну в общем вот теперь скомпилиться.
Да.
Да, она не особо считается глобальной,
она непеременная, это константа.
Вот сюда кладем.
Да, она теперь не static, она теперь inline.
Потому что да, оно и по умолчанию будет inline.
Короче, вот так.
Кажется, там были какие-то правила
про то, что шаблонные constexpr переменные
автоматом inline давайте для безопасности оставим.
Но идея ясна, да, теперь мы ухраним
таблицу виртуальных вызовов,
как и компилятор, когда компилируют
виртуальные вызовы где-то в стране, в родате,
а здесь запоминаем просто указатель,
и мы по сути переизобрели
виртуальные вызовы ручками.
Почему это может быть хорошо?
Потому что мы теперь можем обобщить этот код,
чтобы он и вот так умел работать,
и вот так в зависимости от шаблонного аргумента
у нашего контейнера.
Ну да, сейчас это писать не будем,
но идея именно такая. А зачем?
В каких случаях вообще вот такой вот дурацкий трюк,
с тем, что мы на хуй ну там ferro data вынесли,
он будет хороший?
Когда она будет сильная?
Вот тут экономия будет в два раза,
и мы по-другому ее умеем экономить,
когда у нас только копия и родилитер.
Экономия будет, когда у вас много разных
функций стерта.
То есть виртуальные таблицы вызовов почему хранятся
не прямо в объектах, а где-то там вдалеке,
и объекты на них ссылаются?
Потому что обычно у класса много виртуальных методов,
ну там штуки две-три хотя бы.
Если у нас всего один виртуальный метод,
то наверное мы бы не виртуальную какую-то иерархию устроили,
а просто STD-фанкшн написали, это было бы быстрее.
Вот, и соответственно из таких соображений
можно сделать свой какой-то TypeRace-контейнер,
у которого в зависимости от количества стертых поведений,
кто мне так яро пишет,
в зависимости от количества стертых поведений
разное поведение того, где витейбл хранится,
инлайненный или где-то на кучу вынесенный.
Надо как-то считать количество этих самых функций?
Ну вот две у нас посчитали.
Вопрос, когда их может быть больше,
справедливый абсолютно вопрос должен напрашиваться.
Спасибо от блог.
Ну тут я опять отселась к этой замечательной библиотеке.
Вот.
Видите, что написано?
Да.
Вот в этой библиотеке их реализация Function
умеет стирать несколько разных сигнатур
вызова у одного и того же объекта.
То есть вы туда закидываете такой класс,
у которого несколько разных
операторов круглые субтитры,
которые вы можете изменить.
Вот.
И она запомнит несколько разных операторов круглые скобки.
И всех их она запомнит.
Авто-авто можно авто.
Стереть нельзя.
Ну и вот тут показывают, что давайте шаблонную лямду
туда внимание впихнем.
Ну у шаблонной лямды шаблонный оператор круглые скобки.
И вот эта Function сама как бы инстанцирует
этот шаблонный оператор круглые скобки от вектора
и от сета, как здесь написано.
И запомнит в своей виртуальной таблице все ссылки.
Ну вот раз так можно делать,
легко предположить, что тут вообще-то много чего разного
может быть интересного, и тогда уже количество того,
что вот здесь напихано, может вырасти.
И вот тогда подобный прикол с тем, что мы в table умеем
как онлайн хранить, так и выносить на кучу, он пригодится.
Еще мотивирующий пример из другой библиотеки.
Нет, ну через шаблонные аргументы.
Да, у тебя тут просто две сигнатуры написаны.
Ты знаешь, что ты хранишь все сигнатуры, которые тебя попросили,
плюс какой-то копирователь и какой-то ломатель.
Ты считай.
Ну что-то такое, да.
Короче, это в compile-time все делается. Тут runtime-overhead 0 на это.
А другой мотивирующий пример.
Я надеюсь, что кто-нибудь просто сядет
и загорится желанием это написать руками.
Any object. Очень смешной класс.
Он точно так же, как вот that function,
запоминает несколько разных поведений.
Да, только как им пользоваться я не покажу.
И вот эти поведения закодированы загадочными CPO.
То есть это такой Any,
в который мы закидываем любой объект,
и он запоминает некоторые CPO для этого объекта.
Вот в аудитории точно был один человек,
который код на ренджах принес в спарте,
вот он должен понимать, о чем речь идет.
Все остальные, наверное, нет.
А как замотивировать это?
Наверное, никак. Что такое цепошки?
Мы до них дойдем через раз где-то.
Пока тут были доки, там, кажется, был пример.
Нету, нету, нету.
А, TypeRanger.
Отдельный документ для нашего любимого.
И тут, кстати, хороший врайтап
по поводу того, что я рассказываю,
вообще, в общем-то, в общем-то,
что мы делаем.
Ну, в общем-то, в общем-то,
в общем-то, в общем-то, в общем-то,
мы делаем врайтап по поводу того,
что я рассказываю, вообще, в общем и целом,
что куча параметров есть у того,
как мы TypeRanger хотим делать.
Ну, это мы вроде и в прошлый раз чуть-чуть проговорили.
И вот у них замечательный и не Unique, и не Ref, и не Object.
И с помощью некоторых загадочных CPO
представляются поведения какие-то.
Ну и, конечно, там Vtable может разрастись.
Давайте закончим с этим.
Вернемся через раз или два.
Все, время для финалочки,
для small buffer optimization.
Пытаюсь понять процент спящих аудиторий.
Не сильно большой.
Давайте писать small buffer optimization.
Как мы это будем делать?
If constexpr size of t.
Но вот здесь мы не знаем t.
Мы можем сделать
copier и deleter implementation,
чтобы он...
В принципе, даже не обязательно,
но если мы хотим явно,
там просто size-off принимать.
Ну, я предлагаю начать с UNION.
Кто-то в какой-то момент сказал,
что в runtime не понадобится хранить.
Он был прав.
Все, это замечание. В тот момент мой мозг
не дошел до этого момента, но да.
Давайте начнем с того, что байтики выделим.
А, планировать.
RLINE 100.
Вам плохо как это работает?
Я не помню, почему.
Прикейте на C++23.
Будущее пришло.
Не надо.
Вот так сделаем.
А, теперь мы модифицируем vtable,
который сам выбирает чистить хипу.
Как он с этим умеет?
Да.
Вот, вот.
Да.
Кто-нибудь еще понял, что молодой человек сказал?
Давайте сначала думать, да.
Как меняем сигнатуры того,
чего мы стираем?
Это неправда.
Давайте с конца пойдем.
В операторе присваивания.
Если мы хранили в онлайн-буфере,
нужно нам вызывать дилит?
Нет.
Нам нужно просто вызвать деструктор.
Ну, давайте вот с этого начнем.
Кажется, это несложно сделать.
Давайте просто вот здесь,
как уже тут кричат просто,
и в констэксперсайзов.
Давайте вот так напишу.
Мне казалось, можно.
Сейчас только 64.
Давайте вынесем это все наружу.
СССО?
Я запутался в аббревиатурах.
Какая из аббревиатур самая?
А, нет, это другая аббревиатура.
Small Buffer Optimization.
Ну...
Меня все овцем не шатает.
Я не знаю.
Я не знаю.
Ну...
Меня все овцем мешалось в голове в плане кодстайлов,
поэтому...
Все и одновременно. Именно так.
Ну...
Сейчас мы оставили за скобками вот эту вот идею,
что VTable можно выносить в онлайн,
а можно туда.
Вот ее мы оставили.
Это очень полезно, потому что у нас фиксированные размеры вот тейбла.
Две функции.
Я показал примеры. В Unifex и Function 2
VTable имеет размер разный, в зависимости от шаблонных аргументов.
У нас такого пока нет.
Поэтому просто про VTable забыли.
Ну, действительно, если мы хотим с VTable то же самое делать, то да.
Тут просто будет еще один union, и дальше уже погнали.
Сейчас мы хотим сами байты объекта,
да, функционального объекта,
или там какого-то. Вот их хотим научиться
либо на кучу выносить, где мы new делали,
либо в онлайне хранить.
Ну, давайте по сути просто принимать union в 3 функция.
И тогда мы, наверное, мембров
нужно еще accessить.
И адреса fb.
И тогда можно передавать адреса просто мембров.
Ну, адреса у всего этого будут одинаковые, да.
Вот я сейчас думаю, как нам лучше обойти
Stdlonder. Наверное, Аркадий
говорит абсолютно дельную вещь.
Давайте этот union вынесем
вот даже куда-то пораньше.
Union будет называться
storage.
И мы уже будем не...
Пока это не трогаем.
Storage не знает, в каком он состоянии.
По байтам скопировать storage это
нормально, но зачем?
Не нужно.
Да. Прямо внутри вот этой вот функции
шаблонной мы понимаем, что у нас
какой из кейсов был. Маленький был,
или большой. И в специализацию прям вшиваем,
и в storage либо
inline используем,
либо data.
Да. Либо так.
Давай ты выяснишь этот вопрос, а я
пойду дальше в святом неведении и
предположении, что я все-таки правильно
помню, что здесь он не нужен.
Пока не нужен. Все, с дестроем просто
совладали, кажется. Вопрос.
Конечно, хотим.
Абсолютно правильная мысль.
Но если ты дойдешь до того, чтобы
реализовать...
Я уже закрыл, да?
LibUnifex.
Если ты когда-нибудь в своей жизни дойдешь
до того, чтобы написать все, что вот здесь
вот описано в этом документе,
AnyUnique, AnyRev, AnyObject,
вот там такая мысль вот так зайдет.
Но это жутко сложно,
потому что просто так
исторически сложилось, плюс и не самый
дружелюбный язык.
И конкретно эта штука, она как бы
идейно не сложная, а написать это жуткое
просто мороко.
Ну не только boilerplate,
куча всяких подхаков, хитростей.
Тут все в шаблонах.
Тайп-листы, кстати, используются, нами любимые.
И это, кажется, это все фигня.
Это не основной код, это просто какая-то оберточка.
Вот тут все интересное.
AnyHippo-located storage,
TypeRs-built-ins, Vtable,
Detail.
Где Detail?
Вот сюда и в Detail.
TypeRs-built-ins.
Ладно, это какая-то не то.
VTableHPP.
Тоже как-то мало.
Где мой эффект вау, чтобы сейчас 1000 строк было в файле?
Что-то неправильное происходит.
AnyHippo-located storage.
Ну да.
Значит, домашню вам выкатываю из этого.
Не, ну реально, как-то мало кодов.
Ну сколько мы там, 4 файла по 200 строк?
По 1000.
Ладно, не так страшно, как мне память говорила.
Не, ну там страшно.
Не, не, не.
Я подумаю, что такое домашню, но видимо не в ваш год уже.
Это нормально.
Просто тут очень-очень шаблонов много, очень много сущностей.
И конечно запутаться легко в том, что происходит.
Ладно, все, давайте допишем, допишем, допишем.
Допишем, допишем, допишем.
СБО.
Чем мы остановились? Мы дестрой сделали?
Дестрой должен работать.
Так, а вот они пришли коду, что вот в одном месте
алоцировать это все?
Хорошо. Если ты захочешь писать свой уник object или any object,
сделай, чтобы они рядом хранились и в каше одновременно прогревались.
Сейчас мы таким заниматься не будем.
Я сигнатуру не поменял, да?
Такой просто вопрос.
Мы написали тейпл.
Думаю, мы чуть-чуть представим, что мы написали его в самом общем.
То есть мы поддерживали, сколько угодно вертальных вызовов,
но он тоже как-то активизирован.
Есть ли профит от использования его в игре того,
что язык его оставляет?
Да, потому что ты можешь писать обобщенные коды,
где этот две тейпл живет.
Может в статической памяти, может прямо здесь,
в онлайне, что там, он ближе к кэшу,
быстрее загрузится и, ну,
больше контроля, как обычно.
Да, с точки зрения…
Нет, то же самое.
Ну, если ты за онлайн, что будет меньше?
Ну, понятно, да.
Да, кстати, товарищи,
насчет Юниона,
что мы будем делать вот с этой строчкой?
Удалим ее и будем проверять нормально.
Как?
Ну, там где звездочка this.
Но нужно завести
еще одну всю эту функцию
verifying.
Нет, мы же не у объекта,
который мы стираем, проверяем свойства,
а что вот наша штука, наш объект Any
содержит какой-то другой объект.
Byte и Date.
Ну, в дате мы не знаем, какой элемент
Юниона активный.
Ну, есть у кого-то стеснение и проблемы с Юнионами?
Комплексы какие-то, в детстве Юнион покусал,
мы сейчас шоковой терапией будем лечить.
Ну, тут не нужен вариант, потому что мы на самом деле
в Compel Time все знаем.
Единственная проблема, мы реально не знаем,
в операторе Bool кто из них активный.
Вот к неактивному получать доступ нельзя,
только к активному.
Ну, попали в ситуацию, когда активный inline
и это Byte какого-то объекта, который мы вообще не знаем.
Что это за объект, какой у него тип?
Который оказалось, что ноль, да.
Все сломается.
Вот поэтому возвращаемся к тому, о чем я говорил,
а вы не понимали, о чем я.
Будем через VTable проверять.
Теперь копир будет таким аракулом того,
есть валидин или наш Any или нет.
Тогда нужно возвращаться в Move операторы?
В Move надо.
В Move надо.
Да, вот тут уже ничего не работает.
Вообще про Move забудьте, они все теперь сломаны
чуть более чем полностью.
Да.
Нам бы с копированием разобраться.
Давайте только...
Я сейчас такой трюк тут проделаю.
Я буду копировать в наш VTable значение
вот этой constexpr переменной.
Так.
С копером что делаем?
По сути, в VTable
мы будем копировать
значение вот этой constexpr переменной.
По сути, в операторе...
В конструкторе копирования
нам нужно разобраться,
насколько большой у нас объект.
Если он большой, то мы хотим new сделать
и в дату сохранить результат new.
Если объект был маленький,
то мы хотим запустить placement new
от адреса вот этого inline
или от адреса вот этого вот.
Иными словами,
теперь мы будем делать не вот так,
теперь мы будем делать вот так.
Обратно, да?
Как сразу начали писать,
к тому и вернулись.
И это будет storage.
Кто не понимает,
что здесь надо написать?
Ну, вот в копьер,
который теперь выводит.
Так.
Ну а что в первой ветке пишем?
Placement new.
Ну, std construct art.
Кто-нибудь, предиктуйте, пожалуйста.
Третий раз, пусть надо брать этот...
Ну, пока-пока сам не бывает.
И кастовать звук.
А то он уже скачет.
А то он уже скачет.
А то он уже скачет.
А то он уже скачет.
А то он уже скачет.
А так скастуется?
Да.
Ну да, он и так.
Ну, без разницы.
Лишний амперсант не помешает.
А, тут еще разуменовать, да?
А то амперсант...
Отлично.
А вот тут куда теперь...
Вот тут что теперь будет?
Да.
Да.
Да.
Окей, копьер поправили.
Не до конца.
Сигнатура, где она?
Вот она.
Так.
Так.
Прекрасно.
Прекрасно.
Ну, муф, да, надо сделать.
Давайте думать.
У нас был такой муф.
Что с ним делать?
Кто еще не спит?
Как ты его здесь сделаешь?
Нет, в смысле...
Даже если бы мы его так написали,
то это нас бы не спасло.
Потому что в случае, если у нас на куче,
то мы можем просто этот указатель поменять,
и все будет хорошо.
А что, если мы в онлайне хранимся?
Копию не хочется.
И его копировать дорого,
и все-таки надо на этом...
Ну, вот именно так получается,
что надо пойти в VTable и запихать еще и мув-штуку.
Которую мы до сих пор...
Ну, я не очень понял,
говоришь ли ты это с сарказмом, но да.
Ну, вот...
Тут как-то слои уже наслаиваются сарказмом на сарказмом.
Да, не костыли, тут так и надо.
Нам нужен муф.
Муф будет отличаться только дурацким вписыванием.
Что-что?
Можно такое вопрос?
Мы делаем, кстати, каст,
в конец-то звездочка у массива,
я уже ничего не понимаю,
но у меня была голая мысль,
возможно, неправильная,
что можем делать каст...
В смысле?
Мы кастим указатель на байты
к указателю на объект.
Это не важно,
чары и байты в этом плане эквивалентны.
Может, я тут просто уже закодился,
и тут надо Reinterpret бахнуть.
Просто если не Reinterpret,
мы делаем Access,
там нужно еще и сгаланду оборачивать.
Да, насчет Align.
Формально говоря, у каждого T свой разный Align.
На момент объявления вот этой штуки
мы не знаем, какой у нас Align.
64 больше не бывает.
А в конструкторе
говорим, что либо
sizeft больше,
либо...
Меньше выбираем.
Ну, тоже sbo-size.
В принципе, пусть одинаковые будут.
Ну, все закастылино.
Alignment соблюден.
Единственное, что...
Ну, вот все-таки с нувом нужно как-то немножко аккуратно.
Что сделать?
Вот тут вот это вот, оно как бы особо не нужно.
Тут на самом деле нужно просто
так вот сделать, да?
Ну, при этом, а зачем мы тогда вообще
какой-то статик каст делаем, да?
А зачем мы вообще тогда это стираем?
Это же вообще стирать не нужно.
Более того, давайте скажем, да, что просто.
Вот так.
Будет вот такой статик-кассерт смешной.
Почему мы решили добавить?
Потому что мы пишем move-конструктор.
И предположили, что в other лежит тип,
у которого размер меньше смалбухера.
Он лежит тогда прямо в байтах,
где вот этот вот any лежит.
И у нас тоже есть эти байты.
Соответственно, нам нужно в наших байтах
какие-то байты, которые там лежат.
Причем move-конструировать.
Вот ровно этот placement-move-конструктор,
вот это вот move-imple и стирает.
А потому что если же второй случай, да,
то есть тут какой ИВ был,
что мы там меньше СБО или больше,
во втором случае вот тут вот
мы и так можем просто взять
и вот эту дату вот так вот сделать.
Как же ты прав, я сам себя запутал.
Да, ты абсолютно прав.
Дело уже не туда.
Делаем так, да?
Про это сейчас подумаем.
Ну вообще же мы же вспомним, да,
что мы теперь решили, что критерий того,
что мы не пустые, это то, что
копия у нас нулевой.
Теперь нул ПТР в дату пихать,
это бессмысленное действие.
Давайте mover.
Mover сделаем, здесь будет...
Вот так.
И за счет того, что мы всю структуру вынесли,
у нас все работает без изменений, как-то приятно.
И теперь здесь мы понимаем, что надо написать.
Понимаем ведь?
Чего?
Ну да, просто позвать Mover.
Причем вот так.
Да, я специально обратите внимание,
в Mover написал какую-то смешную шняжку
с R-value ссылкой.
Вот так.
Что к чему кастить?
Значит, я закодился
и надо ринтерпедкаст.
Mover конструктор сделали,
давайте сделаем Mover оператор присваивания.
Кто-нибудь скажите мне, что писать.
Это Mover оператор присваивания.
Соответственно, в всяком случае, Mover надо использовать.
И в свою дату мы будем использовать Mover.
Ну окей.
Кажется, с горем пополам мы справились со всеми местами.
Единственная сейчас проблема
это то, что...
Вот это вот не хватает.
Чего?
Вот это вот не хватает.
Вот это вот не хватает.
Чего?
Чего-чего-чего?
Да, вот здесь надо.
И вот здесь надо сказать, что мы копию обнулили.
А еще, заметьте,
такую наглядную досаду у нас где-то память утекла.
Ну ладно, это сложно заметить.
Память утекла вот здесь вот где-то.
Давайте посмотрим на этот код.
И запомним, что здесь происходит.
Мы в ветке для маленького буфера
просто PlacementNew делаем в ту,
под того, что было во фроме.
А здесь мы просто передвигаем указатель.
Ну и сейчас произошло много всего плохого сразу.
Вот где-то вот тут.
Адр пришел в плохое состояние.
В обоих кейсах.
И если СБО был, и если его не было.
Давайте разбирать.
Случай, когда СБО не было.
То есть хранилось на куча.
Мы вызвали мувер на Адере.
А мувер сделал что?
Присвоил.
Но у этого Адера осталась ссылка
на этот объект на кучу?
Осталось.
Ну дабл фри получается.
В случае СБО мы сконструировали в ту новую штуку,
мувнув то, что здесь было.
В FromInline остался жить объект?
Остался.
То, что мы его мувнули, это не значит, что этот объект куда-то делся.
И у этого объекта в том числе может быть
что-то выделено на куче даже внутри.
Мы же не знаем, какой Т.
Мы после этого прекрасного мува
занулим копир
и решим, что все нормально.
То есть какая-то на самом деле фигня будет.
Поэтому я говорю, что надо стирать не функцию move, а relocate.
Знаете, в чем отличие?
Что?
Можно swap.
Тут на самом деле миллион.
Пока с этим сами не поедем.
Ну что?
Пока с этим сами не поиграетесь.
Не прочувствуете, насколько тут как угодно можно писать
и какие разные результаты получить.
Я предлагаю такое решение.
Вместо того, чтобы делать move, делать relocate.
Relocate от move отличается тем, что он еще и удаляет то,
откуда мувнулось.
То есть здесь я еще и удалю.
Тут, кстати, неправильный каст.
Еще и удалю вот это.
Ну, мы, коли move-нули, все, там ничего нет,
мы переместили.
Здесь я сделаю exchange, как раньше было.
Вот, и с таким relocate...
И с таким relocate это уже будет просто работать.
Потому что, что здесь мы из Ather
полностью опустошили его хранилище
и поставили там копир в 0 птр,
сказав, что не валидная Эня,
что здесь то же самое.
Не здесь, а вот здесь.
А вот здесь.
А вот здесь.
Не здесь, а вот здесь то же самое произошло.
Я надеюсь, до вас
чуть-чуть хотя бы донеслись мои слова сейчас,
потому что уже чувствую все.
Давайте напоследок проверим, работает ли оно.
Не работает.
Ну, пошли касты.
Давайте все стать касты.
Удалим касты.
А теперь, кажется, нужно вландр оборачивать.
Вот, например, access-показательный.
А, в AnyCast у нас еще проблемы, да?
В AnyCast все сломалось.
А что-то не так пошло.
Так.
Тут у нас все нормально?
Все нормально.
И тут все нормально.
Итока, да.
Что не constexpr?
Да не, не, не, все нормально уже.
constexpr-переменные могут быть там
ODR, Ust, все или как это называется.
Нинственная проблема вот тут.
Мы не знаем, что делать.
Ну, что нам возвращать?
Ссылку на inline?
Да, ну, честно скажу,
у меня нет ответа на этот вопрос.
То есть, я писал function, а не any
с подобными фокусами.
Кажется, в прошлом году тоже у нас было.
Наоборот.
Ну, вот, да.
Гениально.
Да, что-то под вечер не соображаю.
Ну, да.
Кажется, здесь...
Да, или в прошлом году тоже в такой последовательности было.
И вот это я писал.
Какие-то воспоминания возвращаются ко мне.
Да, только зачем я все это снаружи пишу?
Когда можно...
Если меньше,
то data.inline
иначе data.hip
О!
Хоба!
Ну, во-первых,
смотрите, что тут на консоли вывелось.
Это не похоже на int42,
который я туда заложил.
Ну, тут СБО сработал, да?
Где я?
Накосячил.
Ищем ошибки в меньше-больше.
Ищем ошибки в меньше-больше.
Есть ошибка в меньше-больше.
Если меньше, то inline.
Меньше либо равно.
И тут везде тоже.
В таких случаях, кстати,
лучше бы завести какую-то...
Ну, вы поняли.
Получится.
Констэкспор был переменную,
в зависимости от тега, говорит, use СБО или нет.
Так.
Умогло, не помогло.
Давайте поставим здесь breakpoint.
Вообще...
Интересно.
Я ожидал, что сейчас все заработает,
и мы с поколением будем работать.
Вот.
Интересно.
Я ожидал, что сейчас все заработает,
и мы спокойненько разойдемся пораньше, в какой-то веке.
Мы положили туда int 42.
Пытаемся делать они каст.
А вы положили туда-таки 42 или нет?
Давайте посмотрим this.
Что лежит в inline?
Incomplete type.
А.
Не прокатило.
Да?
This.data.inline.
Ampersand.
Не выглядит похоже.
Не выглядит похоже.
Не выглядит похоже.
Не выглядит похоже.
Не выглядит похоже на 42.
Не выглядит похоже на 42.
Разминовать надо.
Не выглядит похоже на 42.
Мы конструктор не поменяли.
Я понял, где все.
Что мы тут делаем?
Нет.
Да, if constexpr то же самое.
Так, иначе. Так. Ну это в начало. Да, разумеется.
Была, не была. Не была.
42 положилось. Да нет, сейчас получится.
Нет, вы смотрите, да. Вискот-то нормальный вообще редактор. Он видит, что в утейбле лежит копия РИМПЛ для ИНТА.
Мы шагаем. Так, если меньше, то дата inline, наш адрес.
На шаг выше. Нормальный return value. А, так это мы уже прошли все, да? Получается, мы где-то дальше
скрашились. На каком шашке? После move мы скрашились. Причем move это был move assignment и после
move assignment что-то сломалось. Ну да, я себе копию разнули. Вот так надо было, да.
Ну все, мы точно пришли к успеху. Все?
Домашнее задание для Аркадия личное. Выяснить, где не хватает остатей лаундера. Скажи, где ты
считаешь нужны студии лаундера? Когда мы дестрои делаем в принтер перед касте, дестрои ад, кажется, тут нужны лаундеры, потому что у нас типа, вот у нас доз, по-моему, это просто везде, где мы пытаемся в указатель,
и потом обращаться, как указатель, на объект, который уже стартовал lifetime, там нужно студовал написать. Нет, мы просто знаем, что это активный член юниона. Мы же из юниона каждый раз заново его достаем. Да, но этот же член юниона это inline, который массив байтов, и мы не знаем, когда lifetime объекта стартовал.
И здесь мы должны, кажется, декларировать, что это объект, который стартовал lifetime. Ну, короче, я помню, что есть свои смыслы.
Проползал сейчас? Ну, я не помню. Проползал, это была та штука сейчас. В телеграмму скинул.
Кажется, нам нужно интерпреткастить, когда мы пытаемся именно inline storage перевести указатель.
Ну, по крайней мере, короче, открой inline storage. Там просто пример прямо написан.
Это домашнее задание. Я вспомнил, там были какие-то изменения.
Изменения? Изменения.
Вопрос, в какой стандарт она вмешана? Кажется, в 20-й, да?
Если честно, я искренне верю, что тут не нужен ландер.
Нет, я с точки зрения стандарта. Меня в прошлом году, по-моему, убедили, мы внимательно это вычитали, и все было хорошо.
Ландер нужен когда? Когда у нас был старый указатель на какой-то объект.
Потом тип поменялся. Да, потом тип поменялся.
И тут в данном случае у нас указатель на where.
Мне казалось, что там пытаются об этом мыслить как по лайфтаймах объекта.
То есть, это типа попытка назвать... Ну, короче, там был этот Тимур Дуглер, который рассказывал про start object lifetime width.
Да, я тоже все это смотрел, разбирался, но потом я успокоился.
Сейчас ландер моделирует поведение очень похоже на это start object lifetime width.
Но моделирует в том плане, что он как бы говорит, что сейчас существует объект какого-то типа...
Ладно, давайте на этом на сегодня закончим, наконец-то пораньше.
Всем спасибо, что пришли, и все свободны. Вот эту вот бодягу с ландером можно тут гнуть еще час где-то.
В итоге это скатится просто в вычитывание стандарта. Это уже как-то неинтересно.
Самое интересное я показал. Дома вам придется сделать такое же в меру своей извращенности.
Если захотите витейбла как-то выносить по-разному, пожалуйста.
Смолбуфер тоже, пожалуйста. Вот как бы весь мир для вас открыт.
Я решил забить на ландеры, мне стало немножко стыдно, поэтому я хочу сейчас явно проговорить еще для всех, если у вас вдруг какие-то проблемы с ними могут возникнуть.
Ландеры надо писать каждый раз, когда мы из байтов получаем объект.
Он говорит, а под этим указателем на байты на самом деле лежит какой-то объект.
Зачем это отличается от стати каска?
Сейчас будет не совсем точно и возможно уже даже не совсем правильное объяснение, но Clang умеет кашировать то, у кого он сделал виртуальный вызов для внутренних оптимизаций.
Если вы положили в этот объект одну реализацию интерфейса, по вызыванию, как это Clang может инвариантными группами запомнить?
Проще, не погружаясь в конкретику, когда мы, например, какие-нибудь релакиты зовем или что угодно, где мы обращаемся к СБО.
Вот внимание, Лондер это только про СБО, про тех, кто особо продвинутый и будет сидеть и выписать.
Каждый раз, когда мы к этому СБО обращаемся и делаем какое-нибудь копирование MOV или еще что-то, или даже Anycast, самое важное Anycast,
Каждое это обращение, оно может быть на самом деле закашировано компилятором вовне.
Мы достали указатель, указывающий на какой-то конкретный объект. У этого объекта какие-то данные лежат структурированные.
Какие-то данные из этого объекта компилятор может закашировать у себя, и в рамках вашего отрезка кода вы можете поменять, что внутри Any лежит,
а компилятор этого не заметит и подумает, что вот этот вот reinterpretcast, ну старый объект должен вернуть.
Вот он выше вернул этот объект, значит и здесь тот же самый. Компилятор не понимает этого.
Да, они прям реально кашируются. Еще там какие-то кейсы бывают, но...
Да, это самая частая оптимизация компилятора. Увидеть, что мы два раза один и тот же код выполняем, чтобы получить одни и те же данные и закашировать их.
А на самом деле, на самом деле данные отличаются, он этого не замечает и все ломается. То есть у вас типа протухшие данные на чтении появятся из кэша.
Вообще-то reinterpretcast сам не делает этого. Потому что это исторически он этого не делал никогда.
И вообще то, что такая проблема существует, заметили разрабы кланга, типа там за день до релиза C++17 и быстро прибежали, затолкали лондер.
Теперь мы с ним живем. Это не самый хороший фикс, возможно другие фиксы более какие-то нормальные можно, но вот...
Ну там вообще что-то странное, короче, да. Ну вот лондер нужно писать каждый раз, когда вы small-буфер, ваш small-буфер, получаете к нему доступ.
То есть ветки, где просто на куче лежит объект, не надо ничего делать, потому что вы его потом удалите дилитом, честно, а потом через new создадите новый, и как бы проблем нет.
А вот здесь это одни и те же байты всегда, и new и дилит не вызывались, и компилятор запутывается.
Поэтому каждый раз, когда вы reinterpretcast'ите буфер с байтиками к конкретному объекту, зная, что там лежит объект, нужно позвать лондер.
Здесь лежит на куче, это указательно какой-то объект на куче. Он был создан через new и будет удален через дилит.
Проблем никаких не возникнет, это обычный C++. Здесь мы в каких-то конкретных байтиках inline когда-то давно создали объект, а теперь reinterpretcast'им эти байтики обратно к конкретному объекту, к типу.
И вот здесь компилятор может подумать, что объект, который лежал в этих байтиках, не поменялся, а он мог поменяться, потому что кто-то мог позвать, присвоить вашему Any другой Any, где другой тип был, другой объект лежал, у которого там другие виртуальные функции были.
Вот про это речь. Ничего не понятно, да?
У нас в прошлый раз был storage, это либо указатель на кучу, где лежит какой-то тип, он может поменяться, но из-за того, что мы делаем всякие new и дилиты, компилятор понимает, что происходит.
Ну просто в новые байты все попадает, как бы абстракция, new, delete, она от этого спасает. А вот когда мы руками эти байты менеджим, и у нас вот просто массив байт, и мы в него кладем то один объект, потом удаляем, кладем другой объект, потом третий, компилятор может закашировать что-то из старого объекта, как Аркадий сказал, указательные виртуальные функции.
И не понять, что при новой загрузке, вот AnyCast новом, на самом деле должен прийти указатель на новый объект, у которого новые виртуальные функции, новые данные, и компилятор просто из каша их возьмет, типа оптимизирует так код, и все сломается.
И вот Лондер говорит, нет, здесь новый объект лежит, ничего, никаких вещей не кашируй. То есть а-ля, я знаю, что лежит объект под этим адресом, и я хочу его получить. А вот это выражение, только reinterpretcast без Лондера, оно как бы игнорирует объектную модель, оно ничего не значит.
Да, корректность не меняется, потому что имплементацию STD-Londer это просто, а, ладно, тут built-in-Londer, корректная имплементация STD-Londer, может быть, это просто return p.
Может быть, return p это окей.
Может у вас компилятор, который и так таких оптимизаций не делает, поэтому ему никакие метки не нужны, корректная имплементация вообще без всего. Ну вот в кланге эта оптимизация есть, поэтому тут built-in-Londer прямо используется.
Вот дальше почитайте, пожалуйста, сами про этот Лондер, но общая идея, надеюсь, так приблизительно понятна.
У меня есть вопрос, мы Лондер должны перед любым рейтингом кастиковой позвать или нет?
В любом.
Не ошибешься, но тебя закидают тряпками.
То, к чему, от чего, ну короче, вот у тебя есть объект, который ты получил в результате рентепредкаста.
Указатель.
Вот если ты куда дальше передаешь указатель, там может вызваться виртуальный метод, то значить нужно писать Лондер.
Мы же, наша оптимизация может не только при виртуальности взаимодействовать.
Ты пишешь шаблонный код, обычно ты ни Лондер, ни рентепредкасты вне шаблонов не используешь.
Если ты пишешь руками рентепредкасты без шаблонов, то тебя уже сразу расстреливать надо, да?
А в шаблонах, ну понятное дело, что мог прилететь кто-то виртуальный.
Ну да, то есть если в принципе это может быть вызвано виртуальным методом, значит нужно писать Лондер.
Собственно поэтому и в Destroyer нужно писать Лондер, потому что он может вызвать виртуальный код.
Да, в Destroyer это нужно.
Вот здесь я кстати тоже написал, потому что мы могли бы продолбаться и закэшировать неправильную виртуальную эту
и пройти через, ну паранойя, короче.
Вот здесь по факту сломаться ничего не могло, чтобы соблюсти стандарт, по-моему, все равно нужно.
А почему вот тут один рентепредкаст там не написан?
Потому что это кейс на куча.
Нет, ну здесь у нас в теории могло бы быть так, что у нас есть какой-то виртуальный метод перегруженный на R-Value.
Проблема в том, что там еще и в двадцатых плюсах какие-то изменения к СТД Лондер были с разменением 17,
Андрей нас покинул, ему приспичило, он прям заботил четко, как этот СТД Лондер работает, чертов.
И вот он знает. Если вам очень интересно, вы можете либо сами почитать, либо у Андрея спросить.
А я предлагаю, поверьте мне на слово, что только там, где вы к Смолбуферу обращаетесь, нужно писать СТД Лондер.
Допустим, мы используем аллокатор, который ралансирует на стеге.
Конкретный код, берем томик стандарта и вот конкретно смотрим, тогда можно сделать какие-то выводы.
В этой домашке, когда вы дома будете ее решать, вот это вот про спая, вот там, если вы захотите до баллы написать СБО,
в пишите Лондер везде, где вы рендер предкастите Смолбуфер.
На сороковой строке нет Лаундера.
Да, абсолютно правильно, здесь должен быть Лондер, а здесь его нет.
Если что-то падает с какой-то непонятной ошибкой в рандайме, мы как-то можем...
Это УБ.
Я понимаю, что это УБ, мы как-то можем, не вчитываясь в каждую строчку, понять, чтобы где-то забыли Лондера.
Нет, это С++, если ты с такой ошибкой столкнешься, ты...
Сам компилятор помнит, что он куда-то это изположил.
Это же, так как это Implementation Defined, по сути, запомнил это имя, то как это...
Нет, нет, может какие-нибудь эти анализаторы...
Черт знает, это настолько, настолько жуткая вещь, настолько жуткие дебри, что, скорее всего, всем без разницы.
Вроде бы хотели же Start Lifetime as ST какой-то написать.
Это про другое.
Это точно про другое?
Нет, это про другое.
Потому что это стартует Lifetime нового объекта, а у нас здесь уже есть объект, который мы хотим получить.
Я не помню детали, но может быть замысел в том, что мы когда конструируем, мы один раз стартуем Lifetime, и потом он не может...
Да, мы когда-то выпадем что-то, мы можем стоптануть Lifetime, вот так играем.
Да, да, да, да, я про это говорю.
Это вот решение, оно на окоторе, где-то внутри.
Ты такие вопросы задаешь, но без шансов.
Потому что нам говорят, что там может что-то сломаться, а на окоторе, как бы, все должно ничего не сломаться.
Честно, но они оба последуют стандарту, могут все сломать, в принципе.
Согласны стандарты?
А на это, на охотчеке запускается подкладка, да?
Да.
То есть сотни активизаций?
Да.
Можно, кстати, добавить задачу на G2C.
Вроде, Шаланг 18-й уже поддерживает его без оговорок и с перегрузками.
Поэтому, по сути, он его поддерживает.
Ты можешь скачать и его собрать себе?
Кто-то уже собрал его.
А в их репертуаре он может даже собрать и есть?
Ну, G2C не есть, но судя по их статусу, вроде, есть.
Ну, там какая-то ограниченная оптальзия.
Ну, в смысле, там не офигенно ограниченная.
Там не учтет только про прогрузки и перегрузки.
А, ну, может, я как раз гляну на этот вопрос?
Ну, ты.
Только там же такие можно только написать.
Там типа смесь статических...
Техно сбавлялся.
Ну...
Вот я в Lipsy.xx пытаюсь найти лондер. Не могу.
Чего?
Кажется, не совсем томный почталист.
Да нет, том.
А, все, я понял, почему я ничего не находил.
Я думал, это значит... Да.
Опа.
Код.
Так, так, так, так, так.
Э...
Э, нет.
Нет.
Ну...
Нет, ну, смотрите, в unordered map используется лондер.
Почему-то считаешь 14 стандартов, а не 17.
Hash value type.
Ну, больше, чем 4.
А, ну, вот да.
Да.
Вот у них тут какой-то CC, это непонятно какие-то данные.
И, ну, ничего непонятно.
Вы знаете, хорошо читаем.
Да.
В мапе тоже самое есть.
Какой-то config.
Ну...
Ну, не знаю.
Ладно, предлагаю разойтись. Уже сидим 5 минут лишних.
Поставьте лондер вот на SBO, если будете писать SBO.
Еще лучше разберитесь.
Ну, это вам, типа, один раз разобраться, потом забыть сразу.
Оно в памяти не сохраняется.
