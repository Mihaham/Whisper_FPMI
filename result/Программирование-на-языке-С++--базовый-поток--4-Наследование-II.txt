Начнем с того, что вспомним о чем мы говорили в прошлый раз.
В прошлый раз мы с вами начали говорить про наследование.
В прошлый раз мы говорили про наследование как инструмент,
который вроде как позволяет избавиться от некоторого дублирования кода.
Условно, если у нас есть множество классов, у которых есть какая-то общая часть,
есть какие-то общие поля, есть какие-то общие методы,
то мы этот общий функционал можем вынести в какой-то так называемый базовый класс.
А дальше все остальные классы наследуют от этого базового или строят целые иерархии классов.
Каждый следующий класс добавляет какой-то новый функционал.
О чем мы с вами не поговорили, так это про понятие родства.
То есть на самом деле мы бы хотели еще дополнительное свойство,
которое бы задавало бы нам некоторое родство классов.
В том смысле, что мы бы хотели, наверное, некоторые классы,
если мы понимаем, что они все принадлежат какому-то общему концепту,
мы бы хотели, например, хранить их в одном массиве.
Но опять же, если возвращаться к примеру с мебелью, то есть у нас есть стол, стул,
не знаю, там есть всякие парты, шкафы,
и мы бы, наверное, хотели бы потенциально иметь возможность сохранить массив мебели,
в нулевой ячейке хранится стол, в первой ячейке хранится стол, ну и так далее.
Но при этом у каждой мебели есть свое собственное свойство,
которого нет у других элементов.
И мы с вами в прошлый раз в конце самом поговорили вот о чем.
Условно, если у меня есть какой-то класс А,
и от него наследован класс В,
то мы с вами сказали, что, в принципе, если наследование публичное,
то вот этот публичный наследок задает связь между этими классами следующее.
В является А.
То есть из этого следует, что везде, где я могу использовать А, там же я могу использовать и В.
Ну, в частности, я могу, например, создавать объекты вот такие.
То есть я могу создать объект А и при этом создать его с помощью объекта типа В.
Ну и то же самое касается, например, массивов.
Я могу завести массив, допустим, из трех элементов,
и заполнить его элементами В.
Допустим, В от единицы, В от двойки.
Ну, казалось бы, я достиг, чего я хотел.
То есть я могу в массиве, в котором хранятся объекты А,
сохранить туда объекты типа В.
Ну, вот на самом деле нет. На самом деле я не совсем добился, чего хотел. Почему?
Потому что при присваивании объектов производного класса объектом базового класса, что происходит?
Происходит срезка.
То есть в объекте А остаются только те части, которые...
В общем, в объекте А остаются только общие части с объектом В.
И плюс, когда я буду вызывать методы, то есть если я буду вызывать, допустим,
Вот представь себе, что у меня есть метод F и в классе А, и в классе B.
Какой метод тут будет вызываться?
Вот если и в классе А есть метод F, и в классе B тоже есть свой собственный метод F.
Какой будет метод вызываться?
Да, всегда будет вызываться метод...
метод класса А. Почему? Потому что у нас есть такой процесс как затенение.
Точнее, нет, тут не совсем затенение. Тут речь идет о том, что если у меня есть объект А,
то компилятор принимает решение о том, какой метод вызвать на основании
типа самого объекта.
А вообще говоря, нам бы хотелось следующего свойства.
Нам бы хотелось, чтобы все работало так.
Нам бы хотелось, чтобы компилятор каким-то образом мог посмотреть,
точнее, компилятор самопрограмма каким-то образом могла посмотреть,
какой объект там на самом деле лежит, и в зависимости от этого выбрать
один метод или второй метод. Давайте более конкретно.
Вот представь себе, у меня есть два класса. Есть класс А, есть класс B.
И в классе B есть метод F.
При этом B унаследован от А.
То есть метод F в классе А говорит о том, что был вызван метод F из А,
и метод F в классе B говорит о том, что был вызван метод F из класса B.
При этом B является наследником А.
Ну, смотрите, что происходит. Тут я создаю объект типа B.
Вот. Это B.
Тут часть, которая относится к А.
Тут часть, которая относится к B без А.
Что я делаю дальше? Дальше я создаю указатель Bptr.
А со звездой Bptr.
Который указывает вот сюда.
Ну, смотрите, объект типа B унаследован от А публичным образом,
поэтому B является А.
Поэтому раз я могу создать указатель на А, то я могу создать указатель на А,
который указывает на B. Согласны?
Ну, представьте себе, что А это мебель, а B это стул.
То есть указатель на мебель может указывать на стул. Логично.
Вот. Окей.
И дальше что я делаю? Я говорю Bptr.
Велочка F.
И тут вопрос. Чего бы я на самом деле хотел?
Ну, согласитесь, я бы на самом деле хотел, чтобы Bptr,
так как он на самом деле указывает на объект типа B,
я бы хотел, чтобы он вызвал мне метод F, который находится в B. Согласны?
Ну то есть если я говорю, используй мебель, я бы хотел, чтобы
мебель использовалась по назначению.
Я указываю, мебель давайте использовать по назначению.
Я бы на самом деле не хотел, чтобы...
Не знаю, что можно делать с мебелью. Ну, мебель можно купить.
Вообще говоря, когда я говорю, давайте использовать мебель по назначению,
имею в виду, что давайте на него что-нибудь положим, и так далее. Согласны?
То есть хотелось бы, чтобы программа каким-то образом могла посмотреть,
а что же там на самом деле за объект лежит и в зависимости от этого принимала решение
какое метод вызывать.
такого делать не получится. Почему? Потому что, ну, компилятор, потому что у нас язык C++
это статически типизированный язык. Да, компилятор что делает? Он просто смотрит, ага, bptr,
какой тип имеет bptr? bptr имеет тип указатель на a, но раз это указатель на a, то значит,
что он указывает на объект a, поэтому я буду называть метод f, который находится в a. Вот, беда.
Как эта проблема решается? Эта проблема решается с помощью такого механизма как виртуальные
функции. Собственно, чтобы получилось то поведение, которое мы хотим, необходимо метод f объедить
виртуальным. Итак, что такое виртуальный метод или виртуальная функция? Виртуальная функция — это
функция или метод, выбор реализации которого происходит на этапе выполнения программы. Вот,
то есть, если я помечаю метод виртуальным, то я говорю компилятору. Вот, когда ты будешь
вызывать метод, погоди, не торопись, подумай. На том объекте, для того объекта, от которого я вызываю f,
вот там, возможно, лежит не то, что ты ожидаешь. Как это происходит? Вот, допустим, снова тут метод
f не виртуальный. Как все устроено? Снова, объект есть объект типа b, есть указатель bptr,
который указывает на b, но на самом деле он является указателем на a. Я говорю bptr f, что
происходит? Компилятор видит, ага, f — это виртуальный метод, а раз f — это виртуальный метод, то значит,
тут не все так просто как кажется. И тут компилятор говорит, ага, на самом деле, по факту, я не знаю,
что тут может быть. То есть, указатель на a может указывать как на объекты a, так и на объекты b,
согласны? Вот, тут компилятор говорит, я не знаю, что на самом деле будет, поэтому тут я пока ничего
делать не буду. И потом, когда уже программа начнет свое выполнение, в процессе выполнения
программы, когда мы дойдем до этой строчки, программа посмотрит, что тут находится,
ага, тут лежит объект типа b, поэтому я буду вызывать метод f, который находится в b. Понятно? То есть,
виртуальные методы — это те методы, перед вызовом которых программа сначала смотрит,
что там за объект реально лежит, и только потом происходит реальный вызов. Ну, собственно,
да, то есть говорит, что решение о том, какую версию методы выбрать нужно, то есть, это решение
принимается во время исполнения программы, так называемое позднее связыванием, а не на этапе
компиляции. То есть, до этого у нас все функции разрешались на этапе компиляции. То есть,
до этого программа всегда знала на этапе компиляции какую функцию ей вызывать. Ну,
за исключением того, что мы использовали указатель на функцию. Вот этот механизм,
когда решение о том, какую функцию вызвать, откладывается на этап выполнения, называется
позднем связывание. Почему позднем связывание? Потому что, собственно, сама
функция A с реализацией связывается и на этапе исполнения программы,
не на этапе компиляции. Что следует знать про виртуальные функции?
Достаточно всего лишь один раз объявить метод виртуальным, и дальше во всех
наследниках он будет виртуальным. Вот у меня есть класс A, в нем я объявил
виртуальную функцию F, и дальше в структуре B, если я объявил точно такую же
функцию, то эта функция автоматически станет виртуальной. Все функции с такой же
сигнатурой, точнее с таким же типом, будут виртуальными. Вот. Ну и тут есть метод G,
метод G не объявлен в виртуальном ни в структуре A, ни в структуре B, поэтому, когда
я буду звать PTR G, у меня будет вызываться метод G, который находится в A. Почему?
Потому что G не объявлен в виртуальной, поэтому происходит раннее связывание. То
есть компилятор принимает решение, какую функцию вызвать на этапе компиляции. На этапе
компиляции все, что знает компилятор, это то, что PTR указывает на A.
Ну раз PTR указывает на A, значит G должен вызываться из класса A. Вот. А во
второй, в последней строчке PTR F, F это виртуальная функция, поэтому тут работает
позднее связывание, то есть программа принимает решение, какую функцию вызвать
на этапе исполнения. То есть сначала она смотрит, какой там объект реально лежит,
видит, что там реально лежит объект типа B, ну и потом вызывает F. Окей? Хорошо. Ну,
собственно, вопрос такой. Вот исходя из всего этого, можно было подумать следующее.
Давайте посмотрим вот на эти строчки кода. Ну или даже вот тут. Я создал объект B, потом
создал указатель ABPTR, потом сделал BPTR стрелочка F. Тут может возникнуть естественный вопрос. Ну
погодите, а зачем компилятору откладывать решение о том, какую функцию вызвать на
этап исполнения, если кажется, что тут все можно сделать на этапе компиляции? Ну смотрите,
компилятор же не дурак, компилятор же может все проанализировать. Он же может понять, что,
смотрите, у меня есть тут объект B, у меня есть указатель A, он указывает на самом деле на B,
поэтому тут нужно вызывать метод из B. И вот в том примере то же самое. Ну компилятор же тоже
все видит, он же программу вообще читает, он же видит, что PTR на самом деле указывает на объект
B в динамической памяти. Поэтому, когда он будет вызывать PTR от F, ему нужно вызвать метод F из B.
То есть как бы зачем его откладывать на этап исполнения, если он все это может сделать на
этапе компиляции? Вопрос. Зачем откладывать на этап исполнения, если кажется, что всегда можно
сделать все на этапе компиляции? Или не всегда? Всегда ли по указателю можно понять во время
компиляции, на что он указывает? Ну да, конечно нет. Ну вот пример, собственно очень простой пример.
Представь себе, что тот факт, на что указывает указатель, зависит от того, какие данные мне
пришли на вход. Ну допустим, вот я пишу int x, sin x, и дальше, если мне ввели x, то я создаю объект B.
Если мне ввели не 0, то говорю new A. Вот. Можно ли вот по этому участку кода сказать,
на что будет указывать PTR? На A или B? Нет, то есть на этапе компиляции это неизвестно. Это будет
известно только на этапе исполнения. Вот. Для этого нам нужно позднее связывание. И тут вот будет,
и соответственно вот этот вот пример, когда, в общем, позднее связывание помогает. Потому что,
если я введу значение 0, то в последней строчке будет вызываться метод F из B. Если я введу не 0,
то соответственно у меня PTR будет указывать на объект типа A, и в последней строчке будет
вызываться метод F из A. То есть в зависимости от введённых данных, у меня будет вызываться либо
один метод, либо другой метод. Вот. Собственно, для этого нужно позднее связывание. Ну и тут
внизу написано замечание про то, что позднее связывание, естественно, работает дольше,
чем раннее связывание. Вот. Ну, я думаю, вы понимаете, да? Потому что если компилятор всё знает заранее,
он может всё заранее соптимизировать. Если вот тут в позднем связывании, ну тут явно происходит,
сначала компилятор должен, точнее программа должна посмотреть, что там реально за объект лежит,
только потом вызвать метод. Это всё более накладно. Ну, про накладные расходы мы поговорим чуть позже.
Пока концептуально всё понятно, да? Супер. Ну, давайте, собственно, попробуем поупражняться,
посмотрим, какие методы где будут вызваться. Собственно, вот у меня есть структура А, вне объявлен
виртуальный метод f и не виртуальный метод g. Дальше есть структура B, вне объявлен метод f и
виртуальный метод g. Структура C, вне объявлен метод f и константный метод g. Ну, давайте посмотрим
сначала вот сюда, попробуем понять, что там у нас будет происходить. Вот я создал объект A,
а равный b, объект b равный c и объект c равный c. Вызываю a.f, что будет вызываться?
Так, вот тут, то есть тут есть два варианта, либо a, либо b. Кто за a? А кто за b? Так, кто за a?
А, поясните, почему тут будет a? Ну, смотрите, вроде как я написал, а a равно b и вызываю a.f,
при этом метод f, он виртуальный. Почему тут на самом деле будет вызываться все равно метод f? Вот такой.
Вот, да, смотрите. Что у меня происходит? Что такое a? А это переменная. Какой тип имеет
переменная a? Переменная a имеет тип a. То есть в памяти у меня хранится только объект a. Что тут
происходит? Тут происходит срезка. То есть я тут создал объект b, то есть создал временный объект b,
а потом этот объект скопировал в настоящую переменную a. При этом я скопировал только вот эту
часть, которая относится к a. То есть у меня в памяти хранится только часть, которая относится к
a. И поэтому a является объектом типа a, и ничего кроме метода a у него вызвано быть не может.
Понятно? Короче, вот весь второй столбец, на самом деле он довольно-таки понятный, потому что тут
везде вызывается тут метод a, тут метод b, тут метод c. Почему? Потому что это не контекст применения
виртуальных функций. Еще раз, виртуальные функции работают только в случае, когда я работаю с
указателями или ссылками. Смотрите, обычная переменная, если у меня есть переменная a, и она имеет
тип a, то значит под этой переменной однозначно скрывается объект типа a. Понятно? Но если у меня есть
указатель на a, то указатель на a может указывать как на объект типа a, так и на объект типа b, так и на объект
типа c. Виртуальные методы работают только с указателями или ссылками. С обычными переменами
виртуальные функции не работают, потому что если у меня есть обычная переменная, то я всегда знаю,
что там за объект лежит. Если переменная типа a, значит там лежит объект типа a. Если переменная типа b,
значит там лежит объект типа b и так далее. Мы об этом в конце поговорим. Вот, поэтому второй столбится
чисто на понимание. Если у вас есть обычная переменная, то для обычных переменных всегда вызываются
ровно те методы, которые вы ожидаете. Так, кстати, в последней строчке будет ce. Я понимаю почему.
Почему в последней строчке будет ce на самом деле? Да, потому что g тут константный метод. В общем,
константные методы можно вызвать... Так, стоп. Нет, бред. Все нормально будет. Все окей. Это если бы,
наоборот, a и b были константными, то метод других нельзя было вызвать. Нет, все нормально. Так,
давайте посмотрим вот на последний столбец. И вот тут уже интересно, потому что тут в дело
вступают указатели. Давайте разберемся с первой группой примеров. Вот у меня есть указатель на a,
который на самом деле указывает на объект типа b в динамической памяти. Если я вызываю метод f,
что происходит? Да, вызывается метод f из b. Почему? Что делает компилятор? Компилятор видит,
что указатель a по b указывает на a. То есть, реальный тип указателя a по b — это a. Он идет в структуру a,
видит, что там есть метод f, но этот метод f — виртуальный. Значит, ему нужно дополнительно
посмотреть на то, на что указывает указатель, и принять решение, какой метод вызвать. Ну, соответственно,
он смотрит на объект, видит, что там лежит объект типа b, и он вызывает метод f из b. Вызываю a по b
g. Почему? Да, потому что метод g не виртуальный, там раннее связано, там все делается исходя из
типа указателя. Вторая группа. A по c указывает на a, но на самом деле там лежит объект типа c.
Так, что тут? c, да, почему? Потому что, еще раз повторяю, что достаточно объедить виртуальность
один раз, и все остальные методы тоже будут виртуальными. То есть, что делает компилятор?
Компилятор заглядывает в класс a, видит, что метод f — виртуальный, значит, ему нужно дополнительно
посмотреть на то, какой там объект реально лежит, и вызвать метод того объекта, который там реально
лежит. Там лежит реально объект c, в классе c есть своя версия функции, поэтому будет вызвана именно
она. Вот. Окей. Так, последняя строчка. Ну, тут понятно, да, тут тоже a. Окей, ну и наконец у меня есть
указатель b, который на самом деле указывает на объекте по c. Вызываю метод f, что будет? c. Так,
вызываю метод g, а вот не совсем. Вот смотрите, действительно в классе b метод g объявлен как
виртуальный. Согласны? Вот. Но какой там метод объявлен виртуальным? Там объявлен виртуальный метод
вот такой. void g. А в классе c какой метод? А в классе c метод void g const. Вот этот да этот метод — это
не одно и то же. Понятно? То есть в классе b объявлен вот такой виртуальный метод. Вот это — это другой
метод, который не совпадает с этим. Поэтому на самом деле в классе c нет метода g, которые соответствуют
тому, что в b, поэтому будет вызываться именно метод из b. Что? Первая цепь, потому что метод f — виртуальный.
Виртуальность наследуется. Сейчас, в классе a метод f — виртуальный, а класс b у наследован от a,
поэтому и в b f тоже будет виртуальным. Вот он смотрит в класс b, видит там метод f, но еще раз,
виртуальность наследуется в том смысле, что не явно там будет подставлен виртуал. То есть компилятор
все равно не явно там отставит виртуал. Вот. Я согласен, это не очевидно, это плохо. То есть когда мы
смотрим на класс b, мы хотим явно понимать, что это метод виртуальный. Вот. Я покажу, как это правильный
дел. Вот так делать неправильно. В общем, это скомпилируется. Метод f будет виртуальный,
но с точки зрения там читаемости кода это плохо. Значит, дальше я покажу, как правильно
прописывать виртуальные методы в наследниках. Так, тут все примеры понятны. Вот последний
пример понятен. Виртуальность относится именно к конкретному типу метода. Если метод поменялся,
поменялся сигнатура, то это уже другой метод. Вот. Вот этот метод g, который сверху и вот этот
метод g, который снизу, это два разных метода. Вот. Поэтому класс c не объявляет, не определяет
свои собственные версии верхнего метода, поэтому к компилятору ничего не остается, как вызвать
метод из b. Окей? А вот, короче, вот тут никак. Да. Вот тут? Потому что, смотрите, еще раз,
APC указывает на a. Поэтому компилятор заглядывает, ну, то есть тип указателя APC,
это указатель на a. Поэтому он заглядывает в структуру a, видит, что там лежит метод g. Этот метод g не
виртуальный. Раз он не виртуальный, значит, просто его вызываю и все. Вот. Ну, короче, вот последние
строчки, ну, можно было вызвать метод g, но, в общем, нужно было сначала указатель на b, привести
указатель на c, потом вызвать метод g, но про это еще поговорим. Вот. Вот так вот, просто через указатель
вызвать g из c нельзя. Да. Да. Тогда b определяет свою версию g и пользуется, ну, тогда смотрите,
что бы было. Давайте подробно пропишем. Значит, вопрос такой. Есть, давайте я коротко напишу,
что вот у меня есть класс a, в нем есть void g. Так. Какой просто void g? Виртуал, окей. Виртуал
void g. Дальше есть b, в котором определен void g. И c, в котором объявлен void g. Что бы тогда было?
Вот давайте тут пропишу, что не явно есть. Тогда вот тут, ну, понятное дело, тут есть только виртуальный
метод g. Вот тут, помимо вот этого метода, не явно компилятор еще дополнительно добавляет
virtual void a.g. То есть, на самом деле, в b тоже есть метод g неконстантный и тоже виртуальный. То есть,
метод b будет использовать, то есть, если я буду обращаться к неконстантному методу g, то тогда
он будет обращаться к неконстантному методу из a. Вот. А тут c переопределяет свою версию g и при
этом содержит, ну, я так напишу, b, void g, константный. Вот. Окей? А, звездочка p равно new t,
то когда p стрелочка g будет вызывать c. Да, если будет, давайте так напишем. Давайте,
если напишу s.const, разуменованный g, точка, ой, разуменованный p, точка g, то тогда вызовется,
ну, давайте, а, тогда ничего не вызовется. Вот тут ошибка компиляции будет. Смотрите,
если я разуменую p и скажу, что воспринимает как константу и вызову метод g, то тогда, ну,
смотрите, что это сделал компилятор? Компилятор видит, что на самом деле p это указатель на a,
поэтому, когда я разуменую указатель на a, получится ссылка на a. Согласны? Дальше говорю,
что эту ссылку нужно сделать константной ссылкой. Вот. Окей. И теперь я через константную
ссылку на a вызываю метод g. Иду в a и вижу, что тут нет константного метода g. Поэтому ошибка
компиляции. Окей. Ну, давайте короче напишем. Если указатель был бы константным, я вызывал бы
p, стрелочка g, то была бы ошибка компиляции. Почему? Потому что компилятор идет в класс a,
и еще тут константный метод g, тут константного метода g нет. Вот. То есть сначала компилятор
проверяет, есть ли такой метод в базовом классе, а уже потом там смотрит виртуальность,
невиртуальность и так далее. Есть ли вопросы? Окей. Окей. Окей. Так. Ну, собственно, виртуальность
работает и внутри методов, да, то есть если вы внутри какого-то метода вызываете виртуальный
метод, то он будет работать. Ну вот, собственно, пример такой. У меня есть структура a, в ней есть
не виртуальный метод printName. Вот. Важно отметить, что printName не виртуальный. И есть виртуальный
метод name, который в зависимости от типа возвращает либо a, либо b. То есть вот есть структура b,
которая переопределяет виртуальный метод name, который возвращает b. Вот. И смотрите, внутри
printName я вызываю метод name. И вот внутри printName этот name будет работать как виртуальный. То есть
вот я сделаю ptr стрелочком printName и будет выведен b. Почему? Потому что в классе a есть метод
printName, будет вызван метод printName, но этот printName из себя вызывает name, который виртуальный. И
вот тут в этот момент компилятор будет думать, какой метод ему вызвать, из a или из b. Окей? Нормально?
Окей. Так. Единственное место, где не работают виртуальные методы, это конструкторы и деструкторы.
Вот если вы в конструкторе или деструкторе вызываете виртуальный метод, то метод всегда
будет выбран именно тот, который относится к текущему конструктору или к текущему деструктору.
Ну, оно и в целом не понятно почему. Потому что, когда вы находитесь в конструкторе,
вот представьте себе, что вы находитесь в конструкторе базового класса и вызываете
виртуальный метод. А этот виртуальный метод в теории должен вызвать метод своего наследника.
Но смотрите, что мы знаем. Мы знаем, что, как создает наследник. Наследник создает так.
Сначала создается базовая часть, а потом все, что отн brought, к наследнику.
И вот представьте себе, вы создаете наследника.
Далее создается базовая часть.
И в конструкторе базовой части вы обращаетесь к методу наследника.
Наследник еще не создан.
Поэтому как вы к нему обратитесь?
По-этому так делать нельзя.
И в этот момент будет вызваться именно метод именно того класса, который создается.
Аналогичная проблема с деструктором.
Если вы вызываете деструктор, сначала заш приготовится часть, которая отн Anita наследника.
вы идете в деструктор базового класса, и если в деструкторе базового класса вы
вызываете виртуальный метод, то этот виртуальный метод может относиться к
наследнику, а наследник уже уничтожен. Поэтому виртуальность в
конструкторах и деструкторах просто-напросто не работает, окей?
Хорошо. Ну и собственно, при чем тут полиморфизм?
Мы с вами говорили про что? Мы с вами говорили про то, что есть основные
концепции ОП, это Abstraction, encapsуляция, полиморфизм и наследование.
Про наследование мы в целом поговорили. Вот теперь полиморфизм.
В прошлом семестре мы с вами говорили про так называемый статический полиморфизм.
Полиморфизм времени компиляции. Что у нас было про полиморфизм
времени компиляции? Ну, это понятное дело там. Перегрузка операцией, то és мы делали так,
что разные объекты использует одну и ту же операцию при сложения и работают
по-разному, или, например, шаблоны. Шаблоны Texas тоже пример статического
полиморфизма, то есть мы используем одну и ту же функцию, которая работает занимать
множество разных типов. Значит, смотрите, на самом деле, что мы сейчас
сделали с помощью виртуальных функций, так это динамический полиморфизм.
Почему? Потому что, смотрите, у меня есть несколько классов, есть класс A, есть
класс B, есть класс C, и я к ним могу обращаться одинаковым образом, то есть я
могу у всех их вызвать метод F. Но в зависимости того, на что указывает
указатель A, на объект A, на объект B или на объект C, у меня будет
работать разные реализации. То есть, смотрите, я написал один и тот же код, но
в зависимости того, что тут за тип лежит, у меня будут
вызываться разные методы. Собственно, это и есть свойство полиморфизма.
Полиморфизм — это свойство системы, которая позволяет использовать различные
реализации в рамках одного интерфейса. То есть, еще раз, у меня есть указатель
ap, использую p стрелочка f. То есть, смотрите, у меня есть общий интерфейс, то есть я
вот этот стройш кода никак не меняю. Но в зависимости того, на что реально
будет указывать p, у меня может быть вызван либо метод из A, либо метод из B,
либо метод из C, либо и так далее. Окей? Вот. Ну и, собственно, практическое применение, ну
пример такое. Я утверждаю, что, имея на руках динамический полиморфизм, я теперь
могу создать массив из элементов разных типов, ну, какими-то ухищрениями.
Ну, смотрите, как это работает, например. Ну, смотри, допустим, я хочу, ну, допустим,
у меня есть там, не знаю, какой-то зоопарк или какая-то игра, в которой, соответственно,
мне нужно создать систему, которая будет хранить всю информацию о животных и так
далее. Вот. Я завожу общий класс animal, то есть базовый класс animal, в котором будет
просто-напросто базовый, в котором будет просто-напросто виртуальный метод voic, ну,
собственно, там, не знаю, животное, пусть подаст голос. Вот. Дальше пишу структуру
кошка, структуру собака, структуру леса и, собственно, как-то реализовываю для них
метод voic. То есть метод voic он виртуальный, и, соответственно, для разных, для разного
типа животных он будет работать по-разному. Что я делаю дальше? Дальше остаюсь массив,
допустим, из десяти указателей на животных. Ну, а то есть вот мне есть массив. Ну, и,
соответственно, есть указатели, которые указывают, каждый из которых указывает на свой,
там, на свой объект. Ну и, собственно, что я хочу сделать? Я, допустим, хочу сделать так,
чтобы вот весь зоопарк разом подал голос. Что я делаю? Я просто-напросто в цикле прохожусь по всем,
по всем элементам, и у каждого элемента вызываю метод voic. Ну и теперь, смотрите, если тут кошка,
то будет вызван, то будет вызван метод voic из кошки. Если будет док, то из собаки. Если покс,
то из весы и так далее. То есть, смотрите, я смог создать массив элементов одного типа. Я напомню,
что C++ можно вставать массивы только из элементов общего типа, в данном случае указательно животное.
Вот, но при этом каждый элемент работает по-своему. То есть, я у каждого элемента вызываю свой метод,
и каждый метод работает по-разному, в зависимости от того, на какой реальный тип я указываю. Понятно?
Супер. Так, что у нас по времени? Нормально. Так, давайте поговорим про... Так, есть ли вопросы по
виртуальным функциям? В целом, общие такие слова про виртуальные методы, все. Теперь давайте поговорим
про частные случаи, и в частности поговорим про виртуальный деструктор. Ну, давайте посмотрим на
мотивирующий пример. Вот у меня есть какой-то класс, ну, допустим, я написал свой собственный класс stack.
Дальше моя программа развивается, я решил, а почему бы мне в своей программе не написать дополнительный
класс stack с поддержкой максимума? То есть, ну, просто это то же самое стать, но при этом поддерживает,
в любой момент знает, какой максимум у меня хранится сейчас в элементах stack. Ну, естественно,
предполагаю, что stack max каким-то образом наследован от stack. Ну, почему? Потому что везде, где я
подставляю stack, я хочу иметь возможность подставлять stack max. Потому что stack max является частным
случаем stack, то есть stack max реализует отношение, то есть stack max является stack, поэтому логично сделать
публичное наследование. Что я делаю дальше в программе? Я создаю указатель stack и создаю new stack max,
то есть, у меня есть указатель на stack, но на самом деле он указывает на stack max. Все нормально. Дальше
вызываю delete. Ну, собственно, так как я выделил динамическую память new stack max, я должен для
указателя stack, для указателя stack ptr вызвать delete. Вызываю delete, и вот в этот момент у меня
программа ломается. Вопрос, почему? А почему двойное? Где двойное? Давайте посмотрим, как все работает. Вот у
меня есть указатель stack, допустим ptr, который на самом деле указывает на stack max. Давайте вот тут.
Это часть, которая относится к stack, это часть, которая относится к stack max. Вот. Выделено с помощью
new. Дальше делаю delete. Давайте отсудим сначала двойное удаление. А где будет двойное удаление?
Что делает delete? Давайте вспомним. Delete делает две вещи. Какие? Первое вызывает деструктор для
объекта, на который указывают. То есть, по этому объекту будет вызван деструктор. А второе, ну,
очищает память. Вопрос, в чем двойное удаление? Понятное дело, что у этого объекта вызывается
деструктор, то есть, там свою память очистит. А дальше, собственно, delete очистит саму память,
вернет в системе. Скажется, двойного удаления нет. Но есть другая проблема. Какая? Вот, да, смотрите.
Действительно, проблема будет в том, что вот тут вызовется только деструктор stack. Почему? Смотрите.
Вот компилятор видит эту строчку. Давайте поработаем компилятором. Вот он видит эту строчку,
ему нужно генерировать какой-то код, ему нужно генерировать какие-то инструкции. Что он видит?
Он видит, ага, нужно вызвать очищение ptr. Значит, delete по указателю означает, что мне нужно первое
вызвать деструктор, второе очистить память. Он смотрит на тип ptr. Видишь, что ptr имеет тип указатель
на stack. А раз ptr имеет тип указатель на stack, то значит, я должен вызвать деструктор для
stack. Он говорит, что первым делом вызывают деструктор stack. Ну а потом, не знаю, очищение памяти.
Ну, погодите, реально-то у меня хранится не только stack, но и вот stack max. Что с ним произойдет?
Он просто останется там висеть в воздухе ночью. В худшем случае он просто останется висеть в воздухе,
а в лучшем случае, не знаю, там будет какая-нибудь ошибка во время исполнения, да.
Ну, на самом деле Free там сработает нормально, потому что Free уже работает на уровне… Программа,
короче, посмотрит на указатель. У программы где-то сохраняется информация о том, что по этому указателю
было выделено столько-то байт-памяти, поэтому Free сработает нормально. Тут главная проблема
с деструктором. Еще раз, всем понятно, в чем проблема? Виртуальный деструктор – это вот ключевой
вопрос. Ну, не знаю, по крайней мере на 90% собеседований спрашивают про виртуальный деструктор.
Смотрите, еще раз, ptr – это указатель на stack. Но при этом реально он указывает на stack max.
Если я делаю delete ptr, то компилятор видит, что ptr – это указатель на stack и вызывает деструктор
только для stack. То есть снова delete опирается только на сам тип указателя. Вопрос – как решить эту
проблему? Ну, кажется, вот такую проблему мы уже сталкивались, когда работали с методами. То есть
у нас был указатель на A, который указывал на B. Когда мы вызывали метод F, он вызывал всегда метод
F. А нам бы хотел, чтобы он вызывал иногда метод B. Как мы решили эту проблему? Да, с помощью слова
virtual. Поэтому решение такое. Вот тут описание проблемы. Решение – использовать виртуальный деструктор.
То есть если я хочу, чтобы компилятор, точнее, чтобы программа принимала решение о том,
какой деструктор вызвать, в зависимости от того, на что указывает указатель, а не на реальный
тип указателя, я должен делать деструктор виртуальным. То есть в стэке я делаю виртуальным
деструктор, ну и соответственно дальше все будет окей. То есть что теперь будет происходить.
Теперь тут появится шаг 0. То есть понять, что за объект. То есть нулевым пунктом delete сначала
выясняешь, что там реально лежит за объект. Понимаешь, что там лежит на самом деле stack
max. Вызывай деструктор stack max. Ну и потом возвращает память системе. Окей? Мораль. Если вы
используете виртуальные методы, то в вашем классе обязательно должен быть виртуальный
деструктор, окей? То есть если вы предполагаете, что ваш класс будет использовать полиморфизм,
короче, правило такое, очень простое. Если в вашем классе есть хотя бы один виртуальный метод,
то и обязан быть виртуальный деструктор, окей? Вот, если в вашем классе нет виртуальных метод,
виртуальный деструктор вам тоже не нужен. Мы обсудили виртуальный деструктор,bum,а
следующий на очереди это ключевые слова overwrite и final. про что это?
смотрите, вот тут мы уже вот мы уже тут толкнулись со следующей проблемой. вот по
коду, допустим, мы смотрим в класс C, вот по этому коду, вообще говоря,
не всегда очевидно, что мы делаем. то есть если мы пишем void.g, то есть что это
может означать, что мы создаем какую-то новую, новую невиртуальную функцию G, или это
может означать что мы создаем что мы переопределяем виртуальную функцию G
которую уже объявят в каком-то классе senator, в каком-то классе предки.
чтобы разобраться, в том что, что ook это же на самом деле означает создание новой
невиртуальной функции или переопределение старый виртуальной, нам необходимо
пройтись по всей герархии наследования и понять есть ли виртуальные
versions G или нет. вот, это первая проблема. то есть когда мы читаем код, неочевидно
Это виртуальный метод или нет? Вторая проблема заключается в следующем.
Смотрите. Да, кстати, она тоже тут указана. Вот смотрите, вот я написал void j const.
Смотрите, возможно я имел в виду, что я бы хотел переопределить
виртуальный метод j, но допустим каким-то образом ошибся. Ну, например, добавил
лишний const. Или, что еще чаще бывает, не написал const. Просто взял и забыл написать
const. То есть тут объявлен метод j как const, а тут я const забыл. Ну или, например,
у меня в классе A написан виртуал void f int, а в классе B решил написать void f
long, ну и думая, что я как бы переобредил виртуальный метод f. Ну, при этом понятно
дело, что f от long и f от int – это две разные функции, поэтому метод f от long не
будет виртуальным, а метод f от int будет виртуальным. Ну и то же самое, вот как я
сказал, с константностью. То есть очень частый паттерн – это забыть const. В
классе A const есть, в классе B const нет. В этом случае виртуальность будет
потеряна. То есть, когда я буду вызывать метод f от нуля или j через PTR, у меня
будет вызываться метод sA, то есть у меня будет вызываться метод f sA и метод j sA
просто-напросто потому, что методы в B они не являются виртуальными.
Что делать? То есть как решить эту проблему? Проблема решается очень просто с помощью
ключевого слова override. Кто делает ключевое слово override? Override говорит
следующее. Я могу вот к этой функции добавить в конце override. Override говорит
следующее. Компилятор, пожалуйста, проверь, что я действительно переопределил какую-то
виртуальную функцию. То есть override делает следующие, делает две вещи. Первое, он
явно показывает в коде, что вот эта функция, что вот этот метод является виртуальным,
и он переопределяет какой-то виртуальный метод, ну снаружи, ну точнее из базовой
класса. А второе, если на самом деле, вот, допустим, тут const. Если на самом деле этот
метод не соответствует никакому виртуальному методу из базового класса, то тогда у вас
будет ошибка компиляции. Компилятор просто-напросто возьмет и скажет, погодите, вы
хотели переопределить какую-то виртуальную функцию, но при этом никакой виртуальной
функции с такой сигнатурой, ну да, с таким типом, с такой сигнатурой просто-напросто
нет. Понятно? То есть override защищает от ошибок. Override говорит, что вот я хочу
переопределить какую-то виртуальную функцию. Вот. Если вы примените override к структуре
B, то увидите следующее сообщение об ошибке. Ну, во-первых, увидите, что есть функция B от
FNLONGINT, и компилятор скажет, что она помещена как override, но на самом деле ничего не
переопределяет. И, например, BG. Компилятор говорит, вы пометили ее как функция,
которая переопределяет какую-то виртуальную, но при этом она ничего не переопределяет. Вот. То
есть override зависит, во-первых, защищает от ошибок, а во-вторых, просто-напросто
документирует ваш код и говорит, что вот этот метод на самом деле виртуальный, и он
приопределяет виртуальный метод из базового класса. Замечательное слово, пользуйтесь на здоровье.
В смысле, перегружен? Нет, в этом нет. Это просто ошибка компиляции. Потому что f отlong и f отint
это две разные функции. Если напишете f отlong overwrite, компилятор посмотрит в базовый класс, увидит,
что нет никакого метода f отlong и скажет ошибка компиляции, потому что такого метода просто нет.
Конст overwrite пишется в конце типа функции.
Хорошо. Я сказал, что виртуальные функции работают только для полностью
совпадающих типов. Это означает, что если у вас типы функций чем-то отличаются, например,
одна функция принимает int, а в наследнике функция принимает long, то это будут две разные функции.
Или если они отличаются константностью, то тоже будут две разные функции. Из этого правила есть
одно исключение. И это исключение называется ковариантные возвращаемые типы. Что такое
ковариантные возвращаемые типы? Ковариантными называются следующие типы. Если у вас есть
класс A и класс B, допустим, класс C, и допустим, есть методы f. Что я могу менять в методах f?
При этом я говорю, что вот этот метод f соответствует этому методу f, и этот метод f соответствует
этому методу f. Все эти методы являются разными реализациями одной и той же функции. Так вот,
эти функции могут отличаться только одним свойством. Это возвращаемым значением. При этом
возвращаемые значения должны следовать свойству ковариантности. Ковариантность означает следующее,
что если f возвращает, допустим, указатель на A, то вот этому f разрешено возвращать наследника A,
то есть наследника указателя A. Например, указатель на B, и вот этому f тоже разрешено возвращать
указатель на C. Вот такую замену делать можно. Понятно? То есть я могу заменять указатель на
базовый класс на указатель наследника, или ссылку на базовый класс могу заменять ссылку на наследника.
То есть единственное изменение, которое я могу выносить в виртуальной функции, это заменять
указатель на базовый класс на указатель наследника, или ссылки на базовый класс ссылка
наследника, но только в возвращаемом значении. Нормально? Хорошо. Так, следующая полезная ключевая
слоя это ключевое слово final. Ключевое слово final тоже применимо к виртуальным функциям, и оно
означает следующее, что вот эта версия метода, она финальная, ее дальше переопределять нельзя. Вот
пример. Вот у меня есть структура A, в ней есть виртуальный метод f. Дальше есть структура B,
я тоже объявил метод f в тот же самый и пометил его как final. Смотрите, final на самом деле работает
точно так же, как overwrite. То есть final говорит о том, что есть где-то виртуальный метод, и я сейчас
его переопределяю. Но final дополнительно еще говорит следующее, что вот этот метод является последней
версией этого метода. Мои наследники этот метод переопределять не имеют права. Смотрите, почему это
приводит. Я создаю структуру C, которая тоже публичного рода наследника от B. Переопределяю функцию f,
метод f, и в этот момент я получу ошибку компиляции. Ошибка компиляции мне скажет, что виртуальная функция
C переопределяет final function. Она переопределяет final function, но при этом делать это не имеет права.
То есть final просто говорит, что в дальнейшем этот метод будет, в дальнейшем этот метод
переопределять просто-напросто нельзя. Ну для чего это может быть полезно? Ну это может быть
полезно просто-напросто если вы понимаете, что в него ничего нельзя добавить, и нет
никакого смысла в него что-то добавлять, что-то изменять. И плюс это помогает делать некоторые
оптимизации. Ну например, представьте себе, что у меня есть вот такая иерархия. Тут есть метод f,
тут есть метод f, который обозначен как final, но тут как бы ничего нет. Какую оптимизацию может
сделать компилятор? Смотрите, я делаю b, звездочка b, равно ну что-то там, ну там, new какой-то тип. И
дальше делаю b, стрелочка f. Смотрите, вот да, и тут этот f виртуальный. Вот смотрите, если бы вот
этого final не было, то в чем бы пришлось делать компилятор? Что пришлось бы делать в программе?
В программе пришлось бы смотреть, на что реально указывает b, да, на какой объект. На объект типа
b или на объект типа c. И в зависимости от этого вызвать метод f. Согласны? Ну а если метод f помечен
как final, то что теперь достаточно мне сделать? Мне достаточно просто подставить вызов метода f из b,
согласны? Потому что у меня есть указатель на b. Указатель на b может указывать либо на b,
либо на его наследников. Но наследники не имеют права переопиливать f. Следовательно, f единственное
возможно это вот это. И поэтому тут просто-напросто будет вызван метод f, без какого-либо позднего
связывания. Понятно? Да, тоже ce. Overwrite это всего лишь подсказка. Вот если бы вы не писали
overwrite, то была бы ошибка императора, потому что void f везде одна и та же. С final тоже понятно?
Окей. Так, а ключевое слово, так, финальный, да, финальный может помнить только виртуальную
функцию. Это я сказал, да, можно объединить виртуальную функцию и сразу сделать ее финальным,
как бы. В общем, это может быть полезно только в случае, если вы просто-напросто не хотите,
чтобы в наследниках появлялась такая же функция. Вот если вы не хотите, чтобы в наследниках
переопределялась функция с такой же сигнатурой, с таким же типом, вы просто пишете
virtual функцию и сразу же объявляете ее финальный. Вот. Тогда наследник просто-напросто не сможет
заново эту функцию переопределить. Вот. Ну редко возникает, но иногда встречается такой паттерн.
Вот. Значит, что еще можно сделать финальным?
А финальным можно сделать не только метод, но и класс.
Смотрите.
Вот. Ну, кстати, все написано, да?
Вот у меня есть структура A, есть структура B,
и она объявлена как final.
То есть, я говорю, struct B, final, ну, и она унаследована от A.
Что означает финальная структура или финальный класс?
Это означает, что от этого класса или структуры
наследоваться больше нельзя.
Если вы хотите запретить наследоваться от данной структуры или класса,
то просто помечаете ее как final, и все.
Вот. Ну, для чего структура или класс может быть помещена как final?
Ну, например, по следующей причине.
Ну, во-первых, вы можете просто так пометить,
что в логике вашей программы от этого класса ничего наследовать нельзя,
плюс final можно поветить те классы,
для которых вы написали...
Ну, точнее так.
В общем, допустим, у вас есть какая-то иерархия классов, да?
И мы с вами говорили, что...
Вот представьте, что у меня есть класс A, класс B, класс C,
и у меня есть виртуальный метод f.
Тут тоже есть метод f, тут тоже метод f.
Вот. Смотрите, о чем мы говорили.
Мы говорили, что для каждого класса,
для каждого класса, у которого есть виртуальный метод,
мы обязаны написать виртуальный деструктор.
Да?
Но представьте, что мы знаем,
что вот этот класс будет последним в иерархии,
то есть от него больше ничего не будет наследовано.
Так вот, собственно, вот для этого класса
можно не писать виртуальный деструктур, вот.
возможных проблем, да, вдруг там кто-то там возьмет ваш код и наследует свой C.
Чтобы пометить, что от этого класса нельзя наследоваться, ну, потому что в моем
классе, например, нет виртуального деструктора. Ну, то есть, я не ожидал, что от моего класса
будут наследоваться, поэтому не стал писать виртуальный деструктур. И вот для
этих целей я могу пометить структуру или класс как final, и, таким образом,
сказать, ну, там остальным разработчикам, ну, или себе в будущем, да, что вот я запретил
наследоваться от этого класса, возможно, каким-то ненадуманным причинам. Вот. Понятно?
Окей. Так. Следующий пункт, в общем, следующий пункт это чисто виртуальные
функции и абстрактные классы. Это все про что? Значит, давайте рассмотрим
следующую проблему. Вот. Значит, реальный пример. Вот, допустим, вы пишете свой
собственный messenger, вот. Пишете его на C++ и, соответственно, вводите вашу
программу какие-то сущности. Какие сущности? Ну, одна из очевидных
сущностей это, соответственно, так, как вы пишете messenger, да, то, естественно,
иметь под рукой класс сообщения. Вот. Соответственно, мы пишем класс сообщения,
ну и что мы понимаем? Мы понимаем, что, в целом, в общем, да, сообщение можно
отправить к какой-то чат, вот. И, сообщение можно отобразить, там, на экране
какого-то там устройства. Ну, то есть, грубо говоря, каждое сообщение поддерживает
две операции, да, это отправка в чат и, соответственно, отображение. Вот. А дальше
сообщение делится на несколько видов. Да, то есть, есть текстовое сообщение,
есть картинка, есть видео, есть голосовое, есть, соответственно, стикер и так далее. То есть, есть куча разных сообщений,
при этом в целом они все отличаются способом отображения на экране. То есть, метод
send у них общий, там у них какая-то мета информация тоже общая, но при этом метод display может отличаться.
Поэтому разумный способ какой? Создать общий базовый класс message, то есть, общая, в которой буду хранить общую информацию для всех сообщений.
Ну а каждое конкретное сообщение, типа text message или sticker message, я просто-напросто наследую от message.
Вот, и при этом сделаю виртуальный метод display, и каждый
последующий класс будет просто-напросто переопределять свой виртуальный метод display, и таким образом я буду хранить массив сообщений. Давайте еще раз покажу, зачем мне нужно
Зачем мне нужны виртуальные функции и
наследования. Ну, смотрите, я могу просто-напросто завести
массив message, давайте, допустим, вместо d
вектор вот
message указатель
message вот. Ну и дальше, собственно, я могу в цикле, например, for int i равно нулю, ну давайте просто
А, мы это не проходили, ладно.
Просто for int i равно нулю и меньше чем message.size
плюс плюс i
ну просто отображаю все сообщения, да
messages от i, стрелочка
display. Вот, то есть я написал вот такие вот три строчки, и при этом мне не важно, что там, какие там реальные сообщения у меня хранятся, да, то есть если там
если там в этой ячейке хранится стикер, то он корректно отобразится, если там хранится текст, то он корректно отобразится. Вот, собственно, вот наглядно преимущество
наглядно преимущество полиморфизма и виртуальных функций, да, то есть я написал общий код, и мне вообще, говоря, плевать, что там за сообщение. То есть, конечно, сообщение отобразится корректно.
Но в чем проблема? Давайте порассуждаем.
Идет этим на следующие вопросы. Вот на предыдущем слайде я написал class message, написал класс сообщения.
Вот мне кажется, что с этим классом что-то не так. Почему? Потому что мне кажется, что этот класс он не жизнецпособен по следующим причинам.
Первый вопрос. Имеет ли смысл просто глядеть и создать абстрактное сообщение?
Ну, смотрите, у меня есть текстовое сообщение, я понимаю, что это такое. Есть видео сообщение, я понимаю, что это такое.
Есть голосовые сообщения, сомнительно, но окей. Есть там всякие стикеры, то есть все понятно.
А мне говорят, что пришло сообщение. Что это за сообщение? Как мне отобразить произвольное сообщение? Есть понимание?
Но кажется, что нет. Непонятно, как вообще устроено просто абстрактное сообщение в вакууме.
То есть создавать объекты типа message кажется неприкольно, потому что у него нет никакой конкретики.
Дальше. Вот смотрите, в классе message есть метод display. Что значит отобразить произвольное сообщение?
Непонятно. Я понимаю, как отобразить текст, я понимаю, как отобразить картинку. Как отобразить просто сообщение? Ну, непонятно.
Дальше. Следующая проблема. Я сказал, что я планирую, что у меня будут создаваться новые типы сообщений, и я буду наследовать их от message.
И я хочу, чтобы каждый сообщение реализовывал метод display. Вопрос. Как мне заставить каждый класс реализовывать этот display?
Потому что если я создам какой-то тип сообщения, например, видео, и не напишу метод display, ну просто забуду.
У меня будет использоваться display из базового класса.
А я бы хотел, чтобы компилятор мне как-то говорил, что, ну погоди, вот для этого класса нужно обязательно реализовать метод display.
А такого у меня нет. Если я не реализую для своего собственного класса метод display, то он просто-напросто будет браться из общего класса message.
Короче, проблема. Хотелось бы, чтобы все это как-то было как-то учено в программе.
Оверайт просто-напросто проверяет, то действительно ли вы переопределяете какой-то виртуальный метод из базового класса.
Не-не-не. Еще раз. Вот. Оверайт он просто-напросто спасает от ошибок.
Ну, например. Вот. Ну вот тут пример.
Представь себе, что у меня есть класс A, я в нем определил виртуальный метод F.
Дальше я в классе B пишу вот такой вот метод. При этом, то есть я хочу в классе B переопределить вот этот виртуальный метод.
Если я напишу просто вот так, то тут есть две проблемы. Первая проблема, ну, для читающего код.
Вот, представь себе, я просто так взял и заглянул в класс B. Как мне вот по этому коду понять, что этот метод что-то переопределяет?
Ну, никак. У него не написано ни виртуал, ничего и так далее.
Вторая проблема. Ну, смотрите, я хотел переопределить метод F из класса A, но при этом забыл написать конст.
Если я забыл написать конст, то этот метод будет просто-напросто отдельным методом, который никак не связан с этим.
Как мне защититься от этих двух проблем? Я пишу снова оверайт.
Оверайт означает, что этот метод переопределяет виртуальный метод из базового класса.
То есть оверайт утверждает, этот метод что-то переопределяет.
То есть теперь, когда я читаю код, как я вижу, что этот метод переопределяет виртуальный метод, это во-первых.
А во-вторых, если на самом деле он ничего не переопределяет, как вот тут.
Насмори, здесь метод конст, а тут не конст. То есть компьютер смотрит, ага, вот.
А тут не const. То есть компилятор смотрит, ага. Вот есть такой метод, в базовом классе такого метода нет.
Он дает ошибку компиляции, говорит, ты хотел что-то переопределить, но на самом деле ничего не переопределяешь.
Вот, понятно?
Если напомните, где конкретно CE было?
А, ну так вот, то же самое.
Вот. Я написал fatlong и написал, что он override.
Но на самом деле никакой виртуальной функции fatlong нет.
Поэтому CE.
Да, почему мне в message нужен метод display?
Потому что вот в такой ситуации, в этом примере, я тогда не смогу вызвать display.
Потому что компилятор возьмет, то есть он поймет, что message от I это указатель на message.
И указатель на message я вызываю display.
Ну, а если у message нет метода display, то тогда ошибка компиляции.
Понятно?
То есть он сначала заглядывает в нужный ему класс, и дальше засмотрит виртуальный или не виртуальный метод.
Вот. Если он этого метода не находит, то ошибка, естественно.
Да, если бы снизу не было const, override бы выдал ошибку.
Так.
Окей. Как решаем эту проблему?
Как отвечаем на эти вопросы?
Для решения этих проблем используют так называемые чисто виртуальные функции.
Вот. Еще одно определение.
Чисто виртуальные функции.
Чисто виртуальная функция, это функция, которая объявлена следующим образом.
Виртуальная функция равно 0.
Вот. Равно 0 означает, что эта функция чисто виртуальная.
Вот.
Что такое чисто виртуальная функция?
Чисто виртуальная функция, это такая функция, чисто виртуальный метод,
это такой метод, который можно оставлять без реализации.
Первое правило.
Если вы объявили чисто виртуальный метод, то его можно оставлять без реализации.
Исключением является чисто виртуальный дисструктор,
perquè у чисто виртуального дисструктора обязана быть реализация.
При этом реализация чисто виртуального метода обязана быть вне класса.
То есть, я тут написал класс iMessage, создал чисто виртуальный деструктор,
и поэтому внизу, ниже этого класса, я пишу реализацию этого самого деструктора.
К чему приводит наличие чисто виртуального метода? Кроме того, что его можно не реализовывать.
Во-первых, мы решили одну из проблем. Мы решили проблему два.
То есть, если мы понимаем, что для класса message не имеет смысла какого-то дисплея,
то можем просто написать дисплей и не писать его реализацию. Вот это первое.
Второе. Если в вашем классе есть хотя бы один чисто виртуальный метод,
то этот класс автоматически становится абстрактным.
Что такое абстрактный класс? Абстрактный класс, по определению, это класс с хотя бы одним чисто виртуальным методом.
Кем свойством обладают абстрактные классы?
Первое. Объекта абстрактного класса создавать нельзя.
То есть, вы не можете создать объект абстрактного класса.
Если вы попробуете создать объект абстрактного класса, например, i message m, будет ошибка компиляции.
Или если вы попробуете сделать new i message, тоже будет ошибка компиляции.
Объекты абстрактных классов создавать нельзя.
Но может создавать указатели и ссылки на абстрактный класс.
Вот тут у меня есть message, но тут векторе я храню только указатели на сообщения.
Вот такое делать можно. Создавать сами объекты абстрактного класса нельзя, но создавать указатели и ссылки на него можно.
Вот, соответственно, вот пример. У меня есть i message ptr, который указывает на текстовые сообщения.
Или есть ссылка на i message, которая, на самом деле, ссылается на text message.
Вот. Это отмет, который объявлен с равно нулю.
Его можно не реализовывать, а второе, наличие чисто виртуального метода, говорит о том, что класс является абстрактным.
Вот, дальше. Что еще можно сказать про чисто виртуальные методы и про абстрактные классы?
Если у вас в классе объявлен чисто виртуальный метод, и наследник не реализует этот самый чисто виртуальный метод, то он сам становится абстрактным.
То есть у вас есть класс, в нем есть чисто виртуальный метод, наследники могут реализовывать этот метод и перестать быть абстрактными.
Но если какой-то из наследников не реализует данный метод, то он становится абстрактным.
то он становится абстрактным, то есть объекты этого класса
создавать нельзя.
Ну и, собственно, таким образом, смотрите, мы решили
все вот эти вот проблемы.
Смотрите, если я сделаю message
абстрактным классом, то есть, например,
вот тут я сделаю метод display
чисто виртуальным методом.
Что тогда произойдет? Первое.
Ответ на первый вопрос. Я тогда не смогу создавать
объекты типа message. Круто.
Я этого и не хотел, на самом деле.
Я теперь могу не реализовывать display.
Ответ на второй вопрос.
И, наконец, ответ на третий вопрос.
Как заставить наследников реализовывать display? Очень просто.
Я делаю display чисто виртуальным методом.
И если наследники не реализуют display,
то тогда их самих создавать будет нельзя.
Я буду получать ошибку компиляции. Понятно?
То есть таким образом я гарантирую,
что я могу не реализовывать display в классе message,
а все наследники message обязаны
будут реализовывать этот метод display.
Вот.
Чем хороши абстрактные классы?
Почему внезапно тут в процессе слайдов
у меня message превратился в iMessage?
Смотрите, абстрактные классы, как правило,
помещаются префиксом i от слова interface.
Потому что абстрактные классы
создают так называемый interface.
То есть сами классы,
сами объекты абстрактных классов
создать нельзя. И вот абстрактные классы
реализуют так называемый interface. То есть как бы
они говорят, как устроены
вообще все объекты, которые у нас следованы
от моего класса. То есть, в частности,
interface iMessage говорит следующее. Все объекты
сообщений реализуют метод display.
То есть все сообщения можно отобразить.
Вот. То есть это interface.
То есть каждому сообщению можно обратиться
к дисплею. Понятно?
Окей. Ну и вызов
чисто виртуального метода в конструкторе и диструктуре абстрактного класса
приводит к undefinedBehaviour. Но это понятно,
потому что мы с вами говорили, что в конструкторах
и диструктурах виртуальность не работает.
Вот. Если вы в конструкторе
или в диструктуре вызываете чисто виртуальный метод,
то это приведет к неопределенному поведению.
Вот. Ну и, собственно, вот в последнем пункте
я сказал, абстрактный класс используется для определения
интерфейсов и создания семейства классов
с одинаковыми свойствами. То есть, грубо говоря,
как все выглядит. Вы описываете интерфейс,
то есть описываете абстрактный класс,
и все интерфейсные методы, ну типа как,
взаимодействие там с вашими классами, описываете
вот с помощью чисто виртуальных методов.
А дальше наследуетесь от этого интерфейса
и реализуете те методы, которые
нужны. Окей?
Ну вот.
Ну, например, я бы мог создать, например,
интерфейс-контейнер в C++.
Я создал интерфейс-контейнер и говорю,
что в любой контейнер можно добавить
элемент, ну, например, с помощью метода push.
У любого контейнера можно спросить размер size
и, не знаю, у любого контейнера
можно, не знаю,
спросить, пустой он или нет.
Что бы я сделал? Я бы сказал,
класс iContainer,
интерфейс-контейнеры,
и вот.
И вот.
Вот.
Паблик.
И написал бы следующие методы.
virtual
size
t
size
const
равно 0.
Ну, и там какие-то другие методы.
И тогда любой наследник
класс iContainer обязан был бы реализовывать метод size,
но тогда в каждом наследнике был бы тоже метод size.
Окей?
Вот.
Какой вопрос?
Да.
В абстрактных классах
могут быть
как и виртуальные методы, так и не виртуальные методы,
так и поля. Единственное, нельзя
создавать просто объекты этого класса.
По всем остальным они ведут себя как обычные классы.
Да.
У абстрактных классов могут быть и конструкторы,
да, вполне.
Да, абстрактный класс нужен только для того,
чтобы от них наследовались.
То есть абстрактный класс — это класс, который нельзя создать,
от него можно только унаследоваться.
Есть ли вопросы?
Окей.
Ну, и давайте в конце
поговорим, у нас как раз 5 минут осталось,
давайте поговорим про то,
как же на самом деле это все работает, как это все устроено.
Ну, заглянем чуть под капот
C++ и
поговорим о том, как работает это самое,
ну, как C++ достигает вот этого
самого позднего связывания.
Давайте еще раз поясню, в чем у нас
идея. Вот есть указатель P, который
указывает на
B, то есть у меня есть
объект B,
вот, и P указывает
на самом деле вот сюда.
Ну, и допустим, у меня
в классе A, давайте еще напишем, что у меня есть
класс A, в нем объявлен
виртуальный метод F
и есть B, ну, который тоже
определяет свой собственный F,
overwrite.
Вот. Я делаю следующую вещь,
я говорю P
от F.
Ключевой вопрос такой,
а как компилятор понимает,
точнее, как программа понимает,
что вот тут лежит объект типа B?
Давайте снова взглянем,
давайте взглянем на программу с точки зрения,
ну, с точки зрения того,
как программа видит память.
Вот. С точки зрения программы
память компьютера выглядит так.
Вот.
Вот, когда программа читает
данные вот по этому указателю,
она идет по этому указателю
и видит там 0, 0, 1, 1, всякие нолики, единички.
Вопрос, как по этой последовательности ноликов и единичек
вообще, говоря, понять, что там за объект?
Ну, непонятно, да,
потому что, ну, смотрите, в теории
объект типа A может содержать
такую последовательность ноликов и единичек, да?
Объект типа B тоже может содержать
такую последовательность ноликов и единичек.
Вот.
То есть отсюда мы делаем
такой вывод, что на самом деле,
чтобы понять,
какую версию функцию f нужно вызывать,
компилятору нужно сохранять
какую-то дополнительную информацию о том,
которая бы говорила на этапе исполнения,
какой класс тут
на самом деле лежит.
И история звучит
в следующем. Смотрите.
Если у вас
в классе есть хотя бы
один виртуальный метод,
то компилятор для этого класса
создает так называемую таблицу виртуальных функций.
Что такое таблица виртуальных функций?
Вот у вас есть класс A,
и компилятор для него
создает таблицу виртуальных функций, значит,
в ней записана следующая информация.
В ней, грубо говоря, записана функция,
точнее метод, и адрес,
по которому он расположен.
Там 0x, там a, f
и так далее.
Потом есть класс B.
В классе B тоже есть виртуальный метод,
ну, допустим, это тоже виртуальный метод f,
ну, и допустим, есть еще виртуальный метод g.
Что тогда делает компилятор?
Компилятор создает две записи
в таблице виртуальных функций для b.
Значит, создает
запись для f,
что функция f лежит вот по такому-то адресу.
И есть функция g, которая тоже лежит вот по какому-то другому адресу.
То есть для каждой виртуальной функции
компилятор создает таблицу
для каждого
класса с виртуальными функциями.
Компилятор создает таблицу виртуальных функций,
которая просто- просто говорит,
какая функция, где расположена,
то есть, где искать код соответствующей функции.
А дальше
что делает компилятор?
Компилятор перед
каждым таким классом, у которого есть таблица виртуальных функций,
кладет указатель,
Указатель, который называется указатель на таблицу виртуальных
функций.
Вот, и что на самом деле происходит?
Сначала идёт указатель на таблицу виртуальных
функций, потом часть, которая относится к А, потом часть,
которая относится к Б без А.
И вот этот указатель на самом деле указывает вот
сюда.
Что происходит в момент исполнения программы?
В моменте исполнения программы происходит следующее.
Компиляторы видят, что П указывает на А.
У Ашки есть виртуальные функции, а раз у Ашки есть виртуальные
то это значит что вот этот метод add возможно не тот, чем кажется.
Поэтому что делает компилятор?
Компилятор понимает, что так как а имеет виртуальной
функции у него есть таблицы виртуальных функций,
и поэтому компилятор понимает, что на самом деле этот указатель
указывает на указатель на таблицу виртуальных
функций.
Вот так.
И что он делает?
Он просто-напросто идет по этому указателю, дальше
идет по этому указателю, и в этой таблице ищет нужную ему функцию.
Понятно? Что происходит? Еще раз, допустим, я сделал вот так. Если я сделал вот так,
то вот этот указатель на таблицу виртуальных функций будет указывать на
таблицу виртуальных функций для a. Когда я буду вызывать p стрелочка f, что будет
происходить? Компилятор пойдет по указателю p, потом пойдет по этому
указателю из таблиц виртуальных функций, и вот из этой таблицы возьмет указатель
на f. Понятно? Если бы тут хранился указатель на b,
тогда бы программа тут сохранила указатель на таблицу b,
этот указатель пошел бы сюда, поэтому из этой таблицы виртуальных
функций он пошел бы сюда, и дальше он увидел, что f расположена по такому-то
адресу, и запустил бы функцию вот по такому-то адресу. Понятно? Домашнее задание,
лабораторная работа. Можете самостоятельно поиграть и проверить.
Смотрите, можете создать иерархию этих полиморфных классов
с виртуальными функциями и проверить, что, допустим, a со звездочкой p равно
nu a, а со звездочкой q равно nu a, ну и там то же самое сделать с nu b и nu b, и просто
просто взять и прочитать вот эти вот первые 8 байт. Ну как это можно сделать?
Ну, например, с помощью RinterpreterCast, size t указатель от, например, p,
разыминовать его, вывести, и тогда вы увидите, что для всех указателей, которые указывают на a,
для всех указателей, которые указывают на a, будут выводиться одно и то же число,
для всех указателей, которые указывают на b, будут вывод�иться одно и то же число,
allemaal число будет равным для a и для b, вот. Это как раз говорит о том, что в начале каждого
объекта лежит вот, собственно, какой-то указатель размером 8 байт
который указывает нам таблицы виртуальных функций.
И еще одно замечание. Вот это как раз-таки тоже обосновывает, почему позднее связывание
работает несколько дольше чем обычный вызов методов и функций. Почему? Потому
Давайте проверим, сколько у нас тут обращений по указателю происходит.
Сначала мы обращаемся к указателю P, потом мы обращаемся к указателю из таблиц виртуальных функций,
потом мы обращаемся к указателю, где лежит сама функция, и только потом вызываем эту самую функцию.
То есть, раз, два, три, как минимум три прыжка по памяти, и только после этого вызывается сам метод.
Поэтому по производительности виртуальные функции работают чуть дольше, чем вызов обычных функций.
Есть вопросы?
В пронтайме такая целинкопка происходит?
Ну, типа того, да. В пронтайме происходит выбор нужного метода.
То есть, делается сама система?
Да, это уже делает сама программа.
Ну, про Dynamic Cast поговорите на семинарах.
Так, есть ли еще вопросы?
Давайте.
Да, если класс абстрактный, то он будет хранить 8 байт.
Короче, если абстрактный класс пустой, то он будет хранить только указательную таблицу виртуальных функций.
То есть, пустой абстрактный класс будет занимать 8 байт.
А, вот, сейчас, секунду.
Еще одна лаборатория, которую вы можете проверить.
Вы можете написать класс с виртуальными функциями и без виртуальных функций.
То есть, один тот же класс.
Но в одном классе виртуальные функции, в другом классе не виртуальные функции.
И сравните их sizeOf.
И увидите, что sizeOf класса с виртуальными функциями на 8 байт больше,
чем sizeOf класса без виртуальных методов.
Вот.
Ладно, все, спасибо.
