Сегодня хочу много успеть.
Значит, во-первых, за мной долг про задачу штрих с
прошлой лекции, когда мы хотели найти все вхождения
всех словарных слов в текст, значит, давайте я кратко
напомню.
Есть n слов, есть текст t, надо найти все вхождения.
Причем найти это значит не количество найти, а,
грубо говоря, вот прям выписать весь список, что
на какой-то позиции заканчивается вхождение там из первого,
здесь закончилось вхождение со второго и так далее.
Вот прям все вхождения выписать, да, написать кто,
где заканчивается.
Вот.
Ну и давайте вспомним, как мы эту задачу решали.
У нас, когда мы t скармливаем нашему, ну, по сути, автомату
ахкарасик, да, то есть мы построили бор на вот этих
вот словарных словах, потом посчитали все вот эти вот
су-ссылки и переходы go, да, для каждой вершины,
для каждой буквы, мы как бы знаем, куда мы переходим,
если такую-то букву прочитаем.
Вот, затем мы встаем в корень бора, и каждая следующая
вершинка получается из предыдущей переходом по очередной
букве текста.
То есть мы просто много-много раз делаем переход go по
очередной букве нашего текста, t1, t2 и так далее.
Вот.
И мы с вами вроде как обсудили, что vt в каждый момент времени
это будет самый длинный, самый длинный суффикс,
строки с t1 по ti, которые есть в боре.
Вот.
Но это простое утверждение, потому что каждый раз,
что такое go?
Go – это приписывание одного символа и оставление максимально
возможного суффикса, который был в боре.
Ну, собственно, если мы так проделаем все и раз, то
есть написали первый символ, оставили максимальный
суффикс, дописали второй символ, оставили максимальный
суффикс и так далее, то в конце после этого шага
у вас будет как раз равно тому самому максимальному
суффиксу.
Вот.
Значит, vi – это самая, давайте, картиночка, вот vi – это
какой-то такой суффикс, самый длинный, интересующий
нас.
И мы понимаем, что в этой позиции, как только пришел
символ ti, у нас могли появиться некоторые вхождения.
Некоторые вхождения словарных слов могли только что кончиться.
Ну, какие-то слова?
Это те слова, которые являются суффиксами вот этой штуки.
А суффиксами вот этой штуки мы знаем, кто являются.
Это все что достижено по суфсылкам.
Потому что суффиксная ссылка для vaïtae – это максимальный
собственный суффикс, который есть в боре, суфиксная
ссылка суффиксной ссылки – это второй по максимальности
собственно, суффикс вaïtae, который есть в боре и так
далее.
все возможные слова, которые могли здесь закончиться,
все возможные словарные слова sg, которые могли только
что получить полностью свое вхождение, являются
достижимыми из vi по слух-ссылкам, то есть если я рассмотрю
все вершины vi, link от vi, link от link от vi и так далее,
то те из них, которые являются терминальными и будут соответствовать
словам, которые только что получили вхождение.
Вот если скажем вот эта терминальная, вот это терминальная,
вот это терминальная значит как разhong錯но эти слова
только что получили вхождение, так как являются суффиксами
vi, но с другой стороны они являются словарными словами,
потому что они терминальные, а терминальные в точности
словарные одни из вот этих слов.
Значит мне нужно просто на вот этом вот пути по
instagram сblocks найти все терминальные и каждый из них только что
получила вхождение. Давайте я так и напишу, на пути по совсылкам, на пути по
совсылкам. Из ВИ надо найти все терминальные. Делать это очень просто. Давайте просто для каждой
шина хранить не просто совсылку, как вот здесь, а так называемую длинную совсылку, это ссылка на
ближайший терминальный вот на этом пути. Давайте еще что-нибудь здесь нарисую. Здесь было линк в
кубе от ВИ, здесь линк в четвертое от ВИ. Так вот длинная суффиксная ссылка будет вести на
ближайшую вот в этом пути, которая является терминальной. То есть длинная совсылка отсюда
будет вести сюда, отсюда сюда, отсюда сюда, отсюда сюда. То есть мы не будем прыгать по
совсылкам все вот эти вот разы до первой терминальной, а сразу предпочитаем какая из них,
то есть сколько раз нужно прыгнуть, чтобы мы оказались в его терминальной вершине. Давайте
это напишу как-нибудь типа, ну кажется я это обычно называю компрест, компрест,
линк, типа сжатая сжатая совсылка. От В это ссылка на самый длинный суффикс В,
самый длинный, собственный суффикс В, который является при этом терминальной вершиной,
которая является терминальной вершиной. Если у меня такие сжатые компрест линк будут посчитаны,
то найти вот на этом длинном пути все терминальные очень просто, нужно просто прыгать по компрест
линкам. Мы встали в ВИ, если она терминальная, ее надо вывести, затем применяем к ней компрест
линк, попадаем сразу в терминальную вершину, ее выводим, потом опять применяем компрест линк,
попадаем в следующую терминальную, ее выводим и так далее. То есть вместо прыжков по линкам
мы будем прыгать по вот этим сжатым сжатым сс ссылкам компрест линк, только попадая в те самые
нужные терминальные вершины. Ну а чтобы их посчитать, как найти их? Найти очень просто,
значит, компрест линк от В, это либо просто линк от В, если это терминальная вершина,
линк от В, если линк от В это терминальная. А иначе мы понимаем, что как бы один прыжок
недостаточно, то есть мы один раз прыгнули по су ссылке, попали в ней терминальную,
значит нам нужно от нее взять первую терминальную, а это у нас уже лежит в компрест линк,
поэтому здесь я пишу компрест линк от линк от В. Вот, и тогда соответственно эти сжатые ссылки
можно посчитать просто BFS-ом точно так же, как мы считали в алгоритме Ахкарасик сверху вниз,
если для всех более коротких слов насчитаны компрест линк, то для В мы также можем посчитать
эту самую сжатую ссылку. Вот, соответственно подсчет суммарно за то же линейное время.
Ну я напишу от В, где В число вершин, потому что для каждой вершины за от 1 это насчитывается.
Ну и вот потом, когда мы текст обрабатываем, мне нужно просто вместо линк прыгать по компрест
линк и все. Вопросы? Что-то понятно? Так, ну тогда, а да, а симпточку надо тогда ответить,
значит а симптотика решение вот той исходной задачи будет такая. Ну, во-первых, надо сначала
построить БОР плюс автомат Ахкарасик на исходном множестве слов. Это будет что-то такое, да? Сумма
длин всех SI умножить на размер алфавита. Так, ну тут у меня не очень хорошее обозначение,
ну пусть будет так. Да, то есть это суммирование, это алфавит. Плюс текст мы обрабатываем за его длину
просто и плюс величина ответа, где ans это суммарное число всех вхождений, суммарное число вхождений
словарных слов текст, словарных слов текст. Потому что каждое вхождение мы находим за единицу,
вот мы встали в ВИ, взяли компрест линк, это вхождение словарного слова в текст, взяли еще
раз компрест линк, это еще вхождение. То есть каждый прыжок по компрест линк дает нам какой-то
информации, которую нужно напечатать, нам мы нашли очередное вхождение и получается, что каждое
вхождение мы обрабатываем как бы за единицу. Поэтому, ну понятно, что нам, если нам нужно вывести все
вхождения, то у нас в каком-то смысле здесь будет зависимость от ответа, чем больше вхождений,
тем больше время работы. Но на самом деле каждое такое вхождение мы находим за единицу, потому что
компрест линк как раз прыгает только по вхождениям. Поэтому симптомика вот такая, здесь появляется
вот эта слагаемая зависящая от ответа, но оно как бы с коэффициентом будет один,
потому что каждое вхождение находится за единицу. Вот.
Так, хорошо. Тогда идем дальше. Сегодня у нас суфик массив, основная тема.
Суфиксный массив. Задача такая, у нас есть строка. Давайте в ноль индексации сразу.
Есть строка из n символов. Наша задача это лексикографически отсортировать все ее суфиксы.
Давайте пока не будем задаваться вопросом, зачем это нужно. Давайте пока сначала зачем-то это сделаем.
Отсортировать. Ну понятно, что лексик графический, потому что строки мы сравним по умолчанию
лексик графический. Давайте я это пропишу. Лексику графически и ее суфиксы. Ну какой-нибудь пример.
Традиционно такой. Давайте я занумирую. Вот тогда сортировка здесь будет такая.
Сначала идет суфикс, который начинается с шестой позиции, то есть просто А. Потом будет суфикс,
который начинается с четвертой позиции, это А. Потом будет А, ЦАБа целиком. Так А, ЦАБа, БА, БА, ЦАБа и ЦАБа.
Ну легко понять, что все эти строки сверху внизу порядочны как раз лексик графически. И все суфиксы здесь присутствуют.
Вот по сути нам нужна перестановка, какому порядку здесь написаны все суфиксы. Ясно, что каждый суфикс
однозначно определяется своим первым символом. Вот этот суфикс, который начинается с шестого символа,
это суфикс, который начинается с второго символа и т.д. то есть вместо суфиса можно написать
его первый номер. Номер первого символа в этом суф принципе. Поэтому нам нужнаuberестановка.
и я ее буду обозначать. Порядок сортировки всех суффиксов в лекс-порядке. Так, вот это нам
нужно сделать. Ну, давайте для удобства мы дополним нашу строчку справа каким-нибудь символом,
который заведомо меньше в лекс-порядке всех символов строки. Давайте я вместо s буду писать
с решетка. Добавил в конец какой-то символ, который гарантированно меньше всех символов исходной
строки. Если нам известно, что исходные все символы, скажем, маленькие латинские буквы,
то всегда подойдет решетка, потому что у нее ASCII код меньше, чем у всех маленьких латинских
букв. Вот, и более того, мы вот эту строчку, давайте я теперь вот это, вот это теперь s,
то есть я как бы сделал s плюс равно решетка. Я добавил решетку и теперь считаю, что это новая
строка s. И давайте я ее еще и зациклю. То есть буду как бы символы строки располагать не так
слева-направо, а по циклу. В том смысле, что после решетки опять идет начало строки,
первый символ a, ну точнее нулевой. 0, 1, 2, 3, 4, 5, 6, 7. После 7 опять 0, то есть символ a.
Вот, зациклили, прибавили решетку, и тогда мы можем определить для любого i,
для любого k под строку, которая начинается в позиции i длины k. Нужно просто встать в эту
позицию и читать k символов против всего стрелки, ну в порядке возрастания номеров до тех пор,
пока мы k символов не прочитаем. Если раньше под строка у меня, скажем, было ограничено концом
строки, то теперь у меня уже такого ограничения нету, я могу сколько угодно долго петлять по этому
кругу, хоть там, не знаю, сто раз его обойти, это все будет под строка вот этот зацикленные строки.
То есть под строка с началом в i и длины k, ну это понятно, что такое, нужно встать в i-ты символ
на круге и читать вот так вот k символов, порядка возрастания номеров до тех пор, пока k символов
не прочитаем. Так, ну давайте я не буду писать, понятно, что имеется в виду s i, s i плюс 1 и так
далее, там, вплоть до конца строки, s 0 и так далее и так далее, ну в общем, мы ее зациклили, да, можем
как бы начинать сначала, главное, чтобы здесь было ровно k символов. И теперь мы будем делать
следующее, вместо того, чтобы сортировать суффиксы, мы будем сортировать все под строки, длины которых
являются степенями двойки. Значит, на нулевом шаге мы отсортируем, отсортируем все под строки длины 1,
на первом шаге все под строки длины 2, на втором шаге все под строки длины 4, ну и так далее по
степеням двойки 8, 16 и так далее, пока не отсортируем все строки достаточно большой длины, чтобы считать,
что все суффиксы тоже отсортированы. Ну давайте сразу конец поймем, что вдруг вот, давайте
предположим, что мы отсортировали все под строки длины, являющиеся степенью двойки, которая больше
равна, чем длина исходной строки. Значит, там на каком-то примерно log n там шаге отсортированы все
под строки длины там какой-то 2 в степени r, которая больше и равна длины исходной строки n. Да,
да, да, да. Ну она, конечно, не обязательно там присутствует, но если происходит зацикливание,
то там решетка и 0 символ. Так вот, мы делаем так сколько-то итераций, например, как-то мы умеем
эффективно переходить вот одной итерацией к другой, и пусть на последней итерации у меня
отсортированы все подстройки длины степени двойки больше либо равно, чем n. Больше либо равно,
сейчас, секунду. Ну давайте рассмотрим какие-нибудь две вот такие подстроки длины хотя бы n. Во-первых,
раз у них длина хотя бы n, значит, что они целиком как минимум один раз весь круг огибают,
поэтому там точно есть решетка. Да, раз длина больше либо равно, чем n, то целиком весь круг,
по крайней мере, один раз обходится, в них есть решетка. Поэтому, если я их запишу как строки
обычные, то в них где-то на разных местах будет решетка. На разных местах, потому что начало
разные, значит, и первое вхождение решетки тоже разное. Итого, у меня будет вот такая вот
сортировка всех подстрок длины 2 степени r, и здесь на всех разных местах будет решетка по одному
разу, ну что-то такое. И все они будут, более того, обязательно друг друга строго меньше,
ну потому что соседние не могут быть равные, потому что там решетка в разных местах,
значит, они друг друга строго лицеграфически меньше, вот в таком порядке с верху вниз. Ну
тогда, если я оставлю вот эти вот куски моих строк, то есть все до решетки, то я получу суффиксный
массив. Потому что, что значит, что эта строка меньше, чем эта? Это значит, что, скажем, вот эта
штука равна вот этой, а здесь решетка, здесь что-то больше решетки, либо отличие между ними где-то
вот здесь, вот и скажем, у них вот такой префикс совпадает, а эти символы меньше. То есть,
если одна строка меньше другой с дописанной вот здесь правой решеткой, то после удаления решетки
первая строка будет меньше равна, чем вторая. Потому что, если есть две строки, одна меньше другой,
у них в конце дописан один и тот же символ решетки. Ну то есть, я игнорирую все, что правее решетки,
потому что это точно уже не влияет на сравнение. Вот. Одна меньше второй в конце у обеих решетки,
если решетки сотрут, то неравенство может максимум стать нестрогим. Но, на самом деле,
потому что у них длины будут разные у всех, поэтому равенства там точно не будет. Вот. Значит,
если я просто вот так вот напишу все эти строки, все эти подстроки, то они будут в порядке возрастания
идти, во-первых. Во-вторых, это будут суффиксы, потому что это некие конечные куски, после которых
идет решетка, то есть конец строки. Значит, все вот это суффиксы в некотором порядке, все suffix
в нашей строке, и они идут в лексиграфическом порядке. Поэтому, чтобы решить исходную задачу,
задачу, достаточно научиться сортировать все подстроки
длины вот такой вот, хотя бы n. Согласны? Вот, значит,
вместо исхода мы будем решать вот эти задачи.
Не совсем, потому что,
что
потому что вам нужно сохранить вот если у вас есть два такие суффиксы и вам
нужно чтобы это было меньше этого, чтобы при удалении решетки это было
меньше, чем вот это. Потому что иначе, если бы у вас решетка была бы больше,
чем a в вас был бы порядок наоборот, и соответственно это считалось бы меньше,
чем вот это. Но... То есть вам нужно чтобы решетка была примерно эквивалентно
на концу строки, то есть если какая-то строка заканчивается
решеткой, то это должно быть меньше, то есть это как
бы знак конца строки, более короткая длина у этой
строки, поэтому она должна быть меньше, чем что угодно
другое.
Так, ну что, давайте сортировать все подстроки длины 1.
Ну, этот шаг тривиален, как отсортировать все подстроки
длины 1?
Ну да, обычные или подсчетом каким-нибудь, если мы считаем,
что все символы строки это там какие-нибудь маленькие
латинские буквы, ну ладно, не важно, пусть есть какой-то
алфавит, там сигма, давайте я пройдусь по нашей строке,
подсчитаю число вхождения каждого символа, ну в общем
сейчас будет обычная сортировка подсчетом, подсчитал количество
вхождения каждого символа, вот, а дальше, ну зависит
от того, как вы привыкли писать эту самую сортировку,
значит я давайте напишу ее сразу стабильно, вот так,
мы это когда-то год назад, кажется, делали, там не больше
чем размер алфавита, knt it плюс равно knt i минус 1, то
есть сейчас knt it это количество символов неравных i, а меньше
равных i, вот, а дальше мы пойдем по нашей строке
право-налево и напишем что-то типа так, вроде так, это
должно написаться, похоже на правду, да, давайте кратко
что-нибудь нарисую, вот была у меня, например, такая
строка, давайте я все буквы сразу переведу в нули, короче,
в числа, 0, 2, 0, 1, 2, 1, что-нибудь вот такое, значит после
вот этого knt у меня будет knt нулевое, это 3, потому
что есть 3 нуля, knt вот 1 это будет 5, потому что 3 нуля
и 2 единицы, knt двойки будет 7, и вот это число, которое
тут написано, отвечает тому, какая последняя позиция
должна быть у нуля, то есть на какую позицию нужно
положить самый правый ноль, на третью, потому что их
здесь 3, на третьем месте должен быть последний ноль,
на пятом месте должна быть последняя единица, на седьмом
месте должна быть вторая двойка, потому что ассортированная
версия будет вот такой, как раз на третьем последний
ноль, на пятом последняя единица, на седьмом последняя
двойка, и если я по этому массиву теперь буду идти
справа-налево, скажем встречаю 0, вот оно si равно нулю, тогда
у меня knt от si это та самая последняя позиция, куда
нужно положить вот это вот число, ну в 1 индексации,
я ее дальше уменьшаю на 1, чтобы получить 0 индексацию,
и вот сюда кладу то самое i, если i было здесь, я его положил
сюда, дальше иду в единицу, вижу, ага, единицу нужно
положить на 5 место, вычитаю, ну в 0 индексации получаю
4 место, кладу вот сюда, вот это вот, там i-1, дальше
беру двойку, вот эту двойку кладу сюда, эта единица
уже пойдет сюда, потому что knt от 1 уже на 1 меньше,
да, оно перейдет сюда, ну и так далее, сидя справа-налево
я раскладываю каждый элемент в последний, как бы, в конец
своей корзинки, то есть я определил, что вот эта корзинка
нулей, эта корзинка единицы, эта корзинка двоек, и кладу
последнюю двойку на последнее место в корзинке двоек,
ну и так далее, кажется, такое мы делали, да, пока
первый шаг, ну нулевой, точнее, вот, значит, дальше
идея следующая, чтобы переходить там от шага k к шагу k плюс
1, смотрите, предположим, что у нас отсортированы
все подстроки длины 2 в катой, да, мы идем по степеням
двойки, на каком-то k там шаге отсортированы все подстроки
длины 2 в катой, а теперь мне нужно отсортировать
подстроки длины 2 в степенька плюс 1, ну понятно, что любая
подстрока длины 2 в степенька плюс 1 разбивается на две
одинаковых кусочка по длине, одинаковых по длине кусочка
длины 2 в степеника, да, и если вдруг мне нужно сравнить
между собой две подстроки длины 2 в степенька плюс
1, чтобы понять какая из них больше, какая меньше
мне нужно в каком-то смысле разбить ее на два кусочка,
каждую из них разбить на два кусочка, сравнить, какой здесь знак, какой здесь знак.
Если, например, вот здесь вот точно уже значок меньше, то есть этот кусок меньше этого, то и суммарно вот это меньше, чем вот это.
Если здесь равенство, то знак неравенства между длинными строками определяется знаком неравенства вот между этими двумя.
И по сути мне нужно просто сделать церковку пар.
Потому что разбив длинную строку на две короткие, я сначала делаю сравнение по первому элементу пары,
если равно, то делаю сравнение по второму. Это в чистом виде сортировка пар.
Значит, если я каким-то образом смогу представить вот эти вот все более короткие куски в виде чисел, то мне нужно будет отсортировать массив пар.
Ну, давайте, значит, этот массив чисел заведем. Что за массив чисел?
Мне нужно каждой подстроке длины два степеника сопоставить некое число так, чтобы равным строкам отвечали равные числа,
а разным строкам отвечали числа, которые соотносятся также как исходные строчки.
Если одна строка меньше другой, то число, отвечающее первой строке, должно быть меньше числа, отвечающего второй строке.
Значит, это то, что у нас будет называться класс эквивалентности.
Класс эквивалентности.
Для каждой подстроки длины два вкаты я буду хранить некое число, которое будет называться ее классом эквивалентности.
И эти классы между собой, как числа, соотносятся также как исходные строки.
То есть если исходные строки были равны, то у них одинаковые классы эквивалентности, а если одна строка меньше другой, то класс первый должен быть меньше, чем класс второй.
Такое числовое отображение, ну точнее отображение из строк в числа, сохраняющее знак меньше, сохраняющее меньше и равно.
Ну тогда давайте введем. Усицы ИТ – это тот самый класс эквивалентности.
Класс эквивалентности.
Строки, которые начинаются с позиции И, имеют длину два степеника.
Класс эквивалентности такой строки.
Ну понятно, здесь там зацикливание, да, и если эта штука больше, чем N, то она берется по модулю и как бы вот этот круг обходится через разрез.
И с конца в начало обходится.
Еще раз?
Не, мы не будем так делать.
Ну это интересная идея, да.
Так можно, но там синтетика будет чуть хуже, потому что когда вы умножаете на два вкаты, у вас в лучшем случае будут числа порядка N квадрата.
Да, получается, если номер класса умножено на длину, то это N квадрат примерно в лучшем случае.
И их сортировать уже, вот такой сортировка не получится. Сортировка под счетом там уже не пройдет.
Да, там можно обычно сортировку какую-нибудь, ну, quick sort, но тогда будет чуть хуже синтетика. Но идея интересная, правда.
Еще раз?
Ну это число.
А, вы про это? Нет, считаете, что вы не знаете теорию групп?
Окей, номер класса эквиваленции, так будет лучше?
Так, хорошо, секунду.
Окей, это название просто. Смотрите еще раз, что мы хотим?
Мы хотим в каждой строке длины два степенька сопоставить некое число.
Так что, если две строки длины два степенька равны, то им отвечают одинаковые числа.
А если одна строка длины два степенька меньше другой, то число, отвечающее этой строке, меньше, чем вот это число.
То есть, по сути, мне нужен, извините, гомоморфизм частично упорядоченных множеств.
Да, то есть, как бы, отображение в числа сохраняющего значок меньше.
Если это меньше этого, то число, отвечающее этому, меньше числа, отвечающее этому.
Вот.
Ну блин, я так назвал эквивалентность, потому что как бы у вас бывают подстроки, встречающиеся в разных позициях, но которые одинаковые.
И мне нужно сказать, что они как бы одинаковые, они как строки длины два вката одинаковые, эквивалентны.
Поэтому им должно отвечать одно и то же число.
Да, ну окей, это как бы эквивалентность подстрок на вот этих первых два степенька символов.
Да, вы правы, все, я сам затупил.
То есть, это да, скорее номер класса, то есть число, вот то самое числовое отображение из подстроки в число, сохраняющее значок меньше.
Вот, ну а теперь мы понимаем, что если у меня есть некие две подстроки длины два степенька плюс один.
То мне нужно просто сравнить сначала С от этой штуки с С вот этой штуки.
Если тут значок меньше, то значит меньше из них, то у кого значок меньше.
Если равно, то я сравниваю по номеру класса вот этих вторых половинок.
И это в точности сортировка пар. То есть, если я каждую строку, да, давайте я здесь веду позицию И.
То такую подстроку я могу отнаждествить с парой СИ запятая С и плюс два степенька.
Ну а номер класса левой половинки, номер класса правой половинки.
То же самое для любой другой подстроки.
Теперь мне нужно посортировать эти пары.
Ну и как бы у меня будет готова уже сортировка вот на этом К плюс первом этапе.
Если у меня раньше была сортировка для подстрок длины два вкатый, то теперь будет готова сортировка для подстрока длины два в степени К плюс один.
Вот. Вопрос, как эту сортировку делать максимально эффективно.
Да, конечно, можно запустить там произвольный алгоритм за N log N.
Ну тогда симптотика будет N log квадрат.
Если пары сортировать за N log N, то итоговая симптотика будет N log квадрат.
Ну потому что на каждом шаге мы сортируем за N log N и у нас лог, лог итерации.
Потому что мы переходим к К плюс один, К плюс два и так далее.
По степеням двойки до тех пор пока у нас вот эта степень двойки не будет больше иначе N.
Таких шагов алгоритм примерно.
Вот. Значит будет ассинтотика N log квадрат.
Но мы можем с вами эти пары сортировать за линию.
Не за N log, а за линию.
Потому что все элементы пар у меня не больше, чем N.
Маленькие числа не больше, чем N.
Потому что всего подсрока для недвовката не больше, чем N.
Значит и номеров класса эквалентности нам достаточно максимум N.
Поэтому все вот эти числа всегда будут не больше, чем N.
А значит мы по сути можем сделать ту же самую сортировку подсчетом, только это будет сортировка пар.
А пары мы сортировать тоже уже когда-то учились.
Итак, вместо такой сортировки будем использовать сортировку пар за линейное время.
Кто-то помнит, как выполнять сортировку пар за линейное время?
Да, да, да, все правильно.
Сначала выполняем произвольную сортировку, сравнивая пары по второму элементу.
Затем стабильно по первому.
Это будет как раз верно, потому что в последнюю очередь будет сортировка по первому элементу.
То есть если у двух пар первые элементы разные, то порядок между ними будет такой, какой надо.
Потому что в конце была сортировка по первому элементу пары.
А если у них вот эти штуки одинаковые, то из-за стабильности сортировки порядок между ними будет такой же, как порядок между этими двумя цшками.
Поэтому в случае равенства первых элементов у меня сравнение будет происходить как раз по второму элементу из-за стабильности этой сортировки.
Как вот здесь, мы просто делаем ту же самую сортировку подсчетом, только сначала по второму элементу пар, потом по первому.
Итого алгоритма такой.
Поддерживаем P и C для каждой террации.
На какой-то cut иterации пусть у нас было P и C.
Чтобы перейти от cut иterации к следующей, K плюс первый, мне нужно создать вот тот массив пар.
Дальше мы его так хитро сортируем. Сначала по второму элементу, потом стабильно по первому.
Сортируем в скобочках сначала по второму.
Потом стабильно по первому.
Эта сортировка уже дает нам новый порядок P.
Давайте я назову P штрих.
Это дает P штрих, потому что у меня есть новый порядок следования всех подстрок длины 2 в степени K плюс 1.
Ну а также отсюда легко извлечь C штрих.
Легко найти C штрих, потому что теперь эти пары, если они равны, то они в одном классе эквивалентности.
Если пары различные, то в разных, и нам нужно изменить как классы эквивалентности.
Сейчас про эти детали мы еще поговорим.
С точки зрения кода.
Вот это я оставляю. Это нулевая итерация.
К этому моменту мы посчитали массив P на нулевой итерации.
Еще нам нужно найти массив C.
Ну, например, это можно сделать так.
Лапень.
Массив.
Что я тут написал?
Напоминаю, что в перестановке P написаны некий порядок всех суффиксов, то есть порядок всех подстрок длины 1.
То есть там находится, по сути, какая-то перестановка всех номеров индексов, всех индексов в каком-то порядке.
Что такое C от P от нуля?
P от нуля – это тот, точнее, тап от строка длины 1, который я посчитал минимальный.
Потому что в массиве P они написаны в порядке возрастания.
P0 – это минимальная строка.
Значит, номер классикоэвалентности должен быть нулевым.
Ну, минимальным. Я назначаю ей минимальный номер.
Дальше. Я иду по моей перестановке P и изначально говорю, что следующая подстрока имеет тот же самый классикоэвалентности, что и предыдущая.
Номер класса для P равен номер класса для P-1.
Но только если там написаны, на самом деле, различные символы.
То есть, если символ, написанный на позиции P, не равен символу, написанному позиции P-1, то тогда я увеличу текущий номер класса эквалентности.
Вот, например, если у меня была… Давайте я восстановлю эту штуку.
Вот после сортировки всех символов исходной строки у меня будет вот такой массив.
Значит, ну это не P, это скорее там сейчас, ну ладно.
Значит, это то, что получается после сортировки.
Дальше я иду по… А здесь как бы написаны некие индексы.
Так, кто-то записывал вот исходную перестановку, которая у меня тут была написана, строка из 0 единиц и 2?
Спасибо. Вот.
Соответственно, переставка P будет такая.
Значит, 1 будет 3,5, 2 будет 1,4.
Вот это будет P, то есть в каком порядке нужно писать все суффиксы, точнее все подстроки длины 1, чтобы получилось все в порядке сортировки вот этого вот массива, был лексографический сортировок.
Сначала ноль. Я говорю, что вот он, да, нулевая позиция, это будет нулевой класс эквалютности.
Здесь будет ноль. Дальше, я вижу 2, вижу, что здесь символ такой же, как предыдущий, эта символ thunderstorm.
Поэтому номер класса оставляю. Здесь номер класса такой же, потому что символы равны.
А дальше я сначала как бы пытаюсь поставить ноль и изначально говорю, что здесь будет ноль , но потом вижу, что этот символ отличен от предыдущего, поэтому здесь номер класса будет другой.
здесь будет 1, вот, ну и по сути я просто прохожусь по вот этой перестановке, да,
если вижу, что очередной встретившийся символ не равен предыдущему, то я должен
увеличить номер класса эквивалентности, тогда как раз у меня выполняется то
свойство, которое мне нужно от класса эквивалентности, что равным строкам
отвечают равные классы эквивалентности, а разным, да, когда я перехожу от одного, от
одной строки к другой, я уже номер класса увеличиваю, и если предыдущая строка
была меньше, то значит и номер класса эквивалентности у нее тоже меньше,
потому что я увеличил на один, номер класса стал больше, значит, если тут будет
значок меньше, то здесь будет тоже значок меньше.
Потому что класса всегда будет не больше, чем n.
Ну, правда.
Ну, потому что под строк всего n, каждую по строке мы назначаем какое-то число,
да, ну новое, не отрицательное, и их тогда максимум n нам нужно.
Вот, значит, нулевой шаг мы вроде как сделали, теперь делаем переход к следующему.
Ну, давайте считать, что там у меня сделаны первые k шагов, и у меня после k шага правильно
подсчитаны массивы c и p. Теперь делаем тогда переход к k плюс 1.
Хорошо, значит, во-первых, мне нужно найти порядок сортировки всех построк длины 2 в степени k плюс 1.
Я должен все подстроки сгруппировать вот такими парами по 2 в степени k подряд идущие и выполнить
сортировку. Сначала мне нужна сортировка по вот этим вторым половинкам, да, по вторым аргументам.
Но смотрите, на самом деле, когда я сортирую все пары по вторым половинкам, я, по сути,
сортирую все подстроки длины 2 в степени k, да, потому что все правые половинки всех подстрок
это в точности все подстроки длины 2 в степени k. Но такое мы уже делали, это по сути просто перестановка
p. На p это порядок сортировки всех подстрок длины 2 в степени k. А теперь мне нужно делать то же самое,
вот когда я сортирую пары, давайте я восстановлю это вот, по сути, я должен отсостровать пары вот
такие вот, по вот этому аргументу. То есть я опять-таки сортирую все подстроки длины 2 в степени k,
только теперь они уже как бы начинаются не вот здесь, а как бы вот здесь вот. И тогда, давайте
назову p new, тогда новое, p n пусть будет, тогда то, что новое должно быть на нулевой позиции, это
что-то типа p 0 плюс 2 в степени k, да, потому что если p 0 это вот это вот это вот, да,
тогда самая маленькая строка длины 2 в степени k начинается где-то вот здесь, например. Тогда p n
от нуля, то есть когда я сортирую вот эти вот пары по второму аргументу, самая маленькая должна
встречаться вот здесь. То есть я игнорирую первую половину и беру, чтобы вот это, хочу чтобы вот
это было самой маленькой среди всех подстрок длины 2 в степени k. Поэтому минимальной строкой вот в
этом вот порядке сортировки будет просто вот это. Мне даже не нужно заново ничего пересортировать,
потому что они у меня уже отсортированы, только единственное, нужно сделать поправку по вот этому
2 в степени k. Да, да, спасибо, минус, конечно, минус, да, потому что если вот это это p 0,
то p n от нуля наоборот на 2 степени k левее. Вот, ну и так далее, да, если я знаю, что там p i
t находится на i-том месте, то p n i t это то, что находится на 2 степени k левее, поэтому первый
шаг очень простой. p n i t это просто p i t минус 2 степени k. Ну, если это число отрицательно,
нужно прибавить n, чтобы не, то есть давайте так напишу, да, если p n i меньше нуля, тогда p n i
плюс равно n. Ну, я считаю, что как бы если происходит зацикливание, то максимум на 1
оборот круга, то есть он не может быть сильно отрицательным. Вот, ну а дальше я не буду так
подробно прописывать, понятно, что все вот эти вот вычисления, они как бы по модулю n происходят,
потому что я зацикливаю мой круг, да, и все, что там отрицательно, на самом деле соответствует
какому там числу, которое не отрицательно по модулю n. Смотрите, p это порядок сортировки,
p 0 это номер начала самой маленькой строки, p 1 это как бы вторая по минимальности и так далее,
то есть вот есть у меня все подстроки d n 2 в степени k, они все начинаются в какой-то позиции,
соответственно, каждая подстрока d n 2 в степени k отреждествлена с номером начала, если k фиксировано,
то просто подстрока это по сути номер начала. Когда я их сортирую, у меня получается некий порядок
вот этих вот начал, да, там сначала одна строка, потом другая, третья и так далее, и p как раз
говорит в каком порядке все эти начала расположены. p 0 это такое число, что вот эта вот строка
минимальная, p 1 это вторая в порядке сортировки, p 2 третья и так далее. И тогда вот как раз здесь когда я
взял в качестве p 0 минимальную вот этот вот индекс, то чтобы взять минимальный с точки зрения p
над нуля, с точки зрения сортировки пар, нужно просто на два в степени k влево прыгнуть,
потому что вот эта сортировка как раз пока что игнорирует первые два в степени k символов и
сортирует все по вот этой правой половинке, поэтому здесь нужно сделать прыжок на два
степенька влево. Вот, а c – это следующее, сит – это
номер класса эквивалентности, строки, si, и так далее, si
плюс два степенька минус один. То есть я встал в it-ую
позицию, прочитал строку для n2-го степенька и сохранил
номер класса эквивалентности. Поэтому, когда я здесь
пишу c от i в степени 2, от i плюс два степенька, я имею
ввиду номер класса эквивалентности вот этой строки. Так, ну что,
вот сейчас мы сделали первый из двух шагов сортировки.
Напоминаю, сортировка у нас из двух шагов. Сначала
по вторым элементам пары, потом по первым. Вот по
вторым только что сделал. Тут даже никакой сортировки
нет, это просто как бы перенумерация. Вот этот
двиг влево на два степенька. Остается сделать стабильную
сортировку по первому аргументу. Ну, это мы умеем делать,
у меня есть массив, мне нужно сделать сортировку стабильную
по нему. Ну, давайте я сделаю обычную стабильную сортировку
Я за нулю все, что есть в кнт. Обнулил все содержимое.
Дальше проходимся по всей строке. Делаем плюс плюс
кнт от ci. Потому что мне нужно сделать сортировку
по вот этим штукам по номерам классов. Ну, давайте я для
каждого класса посчитаю, сколько раз он встречается.
Давайте я здесь напишу. Опять префиксные суммы.
Складываем в кнт сумму на префиксе до него. Здесь
вроде бы можно писать не больше, чем n, потому что
номера классов эквилептности, которые я здесь присваиваю,
я уже сказал, что все классы – это гарантированное число
от 0 до n-1. Потому что под строк максимум n на каждом
шаге, значит, номеров классов тоже достаточно максимум
n. Поэтому здесь, когда я делаю переходы, здесь достаточно
и рассматривать максимум n-1. В итоге, вроде это правильно.
То есть, вот так префиксные суммы я насчитал. А потом
нужно расположить их стабильно. То есть, у меня есть некий
порядок pn. Это порядок следования элементов. И теперь я должен
его переупорядочить стабильно с использованием этой массивы
префиксных сумм knt. Ну давайте делать. Я должен пройтись
Вот вроде так это будет выглядеть. Ужасно. Значит, еще раз, что
тут произошло? pn – это перестановка, которую я должен как бы пересортировать
стабильно по какому-то параметру. Поэтому вот здесь вот я
иду, у меня здесь всегда внутри pn и, вот оно pn и, вот оно pn и,
я иду по массиву pn от и справа налево. То есть, это как бы текущий порядок
сортировки. В каком-то порядке у меня все элементы там переставлены. Точнее, вот
в порядке вот этой вот сортировки по вторым аргументам. Там находится некий
порядок следования всех элементов, какая-то перестановка. Дальше я иду по ней
справа налево, узнаю номер класса, узнаю номер класса левой половины, то есть
вот как раз вот эту штуку узнаю. Ну а дальше все как обычно. Узнаю, где он,
какая позиция ему отведена в перестановке p, это вот этот самый knt, вот c. Он говорит,
на какую позицию надо его поставить. В один индексации. Затем делаю минус-минус,
чтобы получить ноль индексации и заодно сдвинуть этот самый указатель, сдвинуть
корзинку на один влево. И дальше в эту позицию кладут то самое p на ты. То есть, я
взял элемент из перестановки, понял на какую позицию надо поставить и туда его
поставил. И теперь у меня массив p уже будет хранить правильную перестановку
сортировки всех по строкам 2 в степенька плюс 1. То есть, я как бы старый массив p
переиспользовал, он мне больше не нужен. Если раньше p это была сортировка всех
по строкам 2 в степенька, то теперь p это сортировка всех по строкам 2 в
степенька плюс 1. Ну вот вроде все. То есть, по сути, вот эта строка ровно такая же,
как была там, только по модулю того, что я сортирую не перестановку 0,1,2 и так далее,
n-1, а перестановку p-n. Вот в том же порядке справа налево по ней прохожусь. Так, все,
теперь p это нужная сортировка. p искомая сортировка для 2 в степенька плюс 1. Потому что сначала я
сортировал по вторым элементам, потом по первым стабильно. Теперь p это то, что нужно. Вот и
остается насчитать массив c. Так, как я делаю массив c. Видимо, я завожу вспомогательный,
потом перекопирую из него в c. Да, окей. Давайте напишу код, потом мы разберемся,
что он делает то, что нужно.
Уф!
Так, ну здесь ничего хитрого. Значит, мне нужно завести новые классы эквивалентности c,
n для всех подстроков длины 2 в степенька плюс 1. Я знаю, что p-0 это самая маленькая подстрока длины
2 в степенька плюс 1, поэтому для нее класс это 0. Потом я иду по перестановке p слева направо,
в порядке возрастания индексов, и хочу посчитать номер класса эквивалентности для очередной
подстроке длины 2 в степенька плюс 1. По умолчанию я считаю, что номер класса такой же,
как у предыдущей. То есть, я считаю, что текущая строка равна предыдущей. Но только если номер
класса левой половинки у текущей строки не равен номер класса эквивалентности левой половинки
прошлой строки, тогда мне нужно увеличить текущий номер класса. То есть, я взял как бы вот,
вот у меня есть p, текущая строка, есть p-1, предыдущая строка, состоящая из двух кусков длины
2 в степенька, тут 2 в степенька, тут 2 в степенька, здесь и здесь. Если вдруг номер класса t старый,
в порядке 2 в степенька, если номер класса эквивалентности этой половинки не равен вот этому,
значит вот эта строка и вот это различны, мне нужно увеличить текущий номер класса. То есть,
я как бы иду в порядке возрастания по ним, по умолчанию считаю, что они одинаковые, но если вдруг
я вижу, что это не равно этому, то я перешел к новой строке, нужно номер класса увеличить. У меня
изменился класс эквивалентности. Если же они одинаковые else, вот здесь скажем равенство, но при
этом вот здесь вот не равенство, вот это не равно вот этому. Это как раз вот эти штуки, это в точности
сравнение класса эквивалентности для вот этих кусков длины 2 в степенька. pt плюс 2 вкатой, это вот оно,
и по имени с первой плюс 2 вкатой, это вот оно. Если эти классы различны, значит тоже нужно увеличить
номер класса эквивалентности. А если это не выполнено, то получается, что у меня левые куски равны,
правые равны, и ничего делать не нужно, и значение по умолчанию верное. Все. В конце я прошел всю
перестановку p, посчитал cn как номер класса эквивалентности всех построк новой длины,
2 в степени k плюс 1, и чтобы это cn переместить на место c, я делаю мем цп и просто копирую в c
содержимое массива cn. Все, теперь вот после вот этих вот, после всего этого безобразия, у меня p и c,
это то, что нужно для k плюс первой итерации. То есть это сортировка плюс класса эквивалентности,
плюс класса эквивалентности всех построк длины 2 в степени k плюс 1. Что нам собственно и требовалось,
мы начали с p и c, которые решали задачу для построка длины 2 в степени k, а теперь после
переобразований получили, что в p и c лежат то же самое, только для 2 в степени k плюс 1. Победа.
Вот. Ну и все, и таким образом мы делаем вот это вот преобразование столько раз,
пока 2 в степени k не станет больше либо равно, чем n, и в конце мы уже говорили, что перестановка p
будет совпадать с суффиксным массивом, потому что там вот мы говорили, что если отбросить все,
начиная от решетки вправо, то это будет та же самая перестановка суффиксов. Там неравенство будет
сохраняться, поэтому то, что у вас будет в конце в массиве p, это и будет суффиксным массивом,
это и будет сортировкой всех суффиксов. Все, поэтому алгоритм суффиксного массива мы построили.
Так, ну а симптотика понятна какая, давайте фиксируем. А симптотика будет n log n,
потому что log итераций и каждый раз это за линейное время, потому что все, что сейчас написано на
доске, работает за линейное время. Это просто какие-то форики, перекопирование, зануление
содержимого массива, это все за линию работает. И таких итераций всего алгоритм.
Так, шикарно. Дальше, чтобы это все как-то использовать, нам нужна еще следующая штука,
следующая надстройка над этим суффиксным массивом, это так называемый массив lcp.
Массив lcp. Значит, lcp расшифровывается как longest common prefix. Ну и смысл очень простой,
у двух произвольных строк lcp находит длину самого длинного их общего префикса.
Например, если у меня есть какая-нибудь abats и, не знаю, aba-abada, то их lcp равно
трём. Длина наибольшего общего префикса равно тройке, потому что вот она abba,
и дальше продлить ее нельзя. Просто длина наибольшего общего префикса.
Так, давайте я для нашей строки abatsabba восстановлю суффмасс с учетом того,
что в конце у меня еще дописана решетка.
А решетка, точнее abba, решетка, abatsabba, решетка,
вот. После дописывания решетки суффмасс будет выглядеть так. Собственно,
вот массив P после исполнения всех хатератов будет выглядеть ровно вот так. 7, 6, 4, и дальше
вот это вот все содержимое. Если нам нужно получить массив для исходной строки s без решетки,
то мне нужно просто везде эту решетку игнорировать, и эта же самая пересновка
будет суффмассом для исходной строки. Это мы уже обсуждали. Массив lcp делает следующее. Он
для каждой пары соседних строк в этом порядке находит их lcp. То есть для всех соседей в этом
порядке мы подсчитаем длину наибольшего общего префикса. Давайте считать. Здесь 0,
но нет общих символов. Здесь 1, вот она h, только h общего, больше ничего нет. Здесь 3,
да, потому что abba общая, дальше уже не общая. Тут единица, видимо, только a общая, здесь 0,
здесь 2, потому что ba здесь 0. Значит, массив lcp это массив наибольших, точнее длин, наибольших
общих префиксов для всех пар соседей в этом суффмассе. lcp it, lcp it, это длина lcp it,
точнее it и plus первого суффикса в порядке лексиографической сортировки. Я взял два
последовательных суффикса из суффмасса, нашел у них lcp и это положил в lcp it.
Давайте от массива lcp читаем. Пусть у меня уже посчитан массив b, то есть посчитан суффмасс
для всей моей строки abba-tsaba решет. Теперь я хочу как-то быстро, эффективно насчитать
вот эти вот lcp-шки всех пар соседей, наибольшие общие префиксы всех пар соседних строк в этом
порядке. Утверждение. Пусть в какой-то момент времени мы нашли lcp неких двух соседних строк
в нашем суффмассе и этот lcp хотя бы двойка. Пусть вот здесь lcp было хотя бы двойка у двух
соседей. Причем вот эта штука начиналась с позиции и. Вот здесь первый символ в этом суффиксе имел
номер и. Тогда если я отброшу вот этот it из моей первой строки и рассмотрю суффикс, начинающий
с позиции с 1, то его lcp с чуваком, который ниже, будет хотя бы это число минус 1. Давайте
здесь нашу все-таки k. Тогда здесь будет хотя бы k-1. Давайте текстами я это напишу. Пусть
p житое равно i и lcp житое равно k, хотя бы двойка. Пусть p какой-нибудь там s это i плюс 1,
тогда lcp с больше равно, чем камень 1. Что тут написано? Пусть где-то в суффмассе на
каком-то житом месте находится суффикс, начинающий с позиции и. На житом месте была строка и. И здесь
же вот эта lcp, у lcp номерация такая же, как у суффмассива. Пусть здесь lcp было хотя бы два,
равно k, хотя бы двойка. Дальше пусть позиция и плюс один, точнее суффикс начинается в позиции
и плюс один, встречается в моем суффмассе где-то на позиции и. Вот она, строка начинается с и плюс
один, и это какая-то истая позиция. Тогда здесь lcp и, то есть вот это вот lcp, будет хотя бы k-1.
То есть если где-то мы знаем lcp и, то для и плюс один, который находится где-то там в произвольном
месте его суффмасса, lcp будет хотя бы k-1. Так, ну доказательств здесь очень простое. Смотрите,
давайте нарисуем вот эти две строки. У них есть некий общий префикс, длины k. Вот это одинаковое,
вот эти k символов одинаковые. А дальше символ написан вот здесь, вот меньше символ написан вот
здесь. Здесь какой-нибудь x, здесь какой-нибудь y, здесь значок меньше. Потому что это с одной стороны
k это lcp, с другой стороны они отсортированы в порядке возрастания, поэтому первые различные
символы упорядочены ровно так. Раз это строка раньше, значит x меньше чем y. И это был суффикс,
начинающийся с позиции и. Если я отбрасываю первый символ вот здесь вот, и перехожу к суффиксу,
который начинается с и плюс один, я отбросил первый этот символ и. Дальше у меня понятное дело,
что вот эти вот первые там k-1 символ будут такими же. Вот эти вот k-1 такие же, как здесь k-1,
потому что один символ откусил. Дальше идет x. Если я выполню самое вот с этой строкой, отброшу
первый символ, то у меня тоже самое. У меня опять будет вот эти вот k-1 символ, такой же как здесь,
потом y, больше чем x. Поэтому вот эта строка, получается отбрасыванием первого символа из
этой строки, идет точно в суффмассе где-то ниже, чем вот это. То есть давайте я нарисую стрелку,
после отбрасывания первого символа переход сюда, а это после отбрасывания первого символа вот
туда. Потому что здесь идет вот те же самые k-1 символ, потом символ y, который заведомо больше
чем x. Поэтому это больше чем это, гарантированно. Но возможно кто-то между ними еще вклеился,
а в принципе такое может быть. Никто не говорит, что здесь обязательно никого не
появляется. Вполне возможно, что здесь кто-то другой встревает. Отсюда уже очень легко
заключить, что lcp, то есть смотрите, мы знаем, что lcp вот этих двух, ровно k-1. Потому что было k,
я отбросил первый символ, стало k-1, а следующий уже точно различен. То есть вот здесь будет
k-1 общий символ, здесь будет y. Между ними lcp ровно k-1. Но тогда понятно, что между каждыми
соседями в этой отрезке lcp будет хотя бы k-1. Потому что если хоть где-то lcp меньше,
чем k-1, то значит общие символы там, не знаю, пусть например lcp это k-2. Когда вот здесь k-2 общие,
а здесь будут разные, там k-1 символ будут различны. Но извините, вот здесь вот k-1 символ
совпадали вот с этим, то все, что между ними, строчки больше, чем это, но меньше это, они должны
конечно же такой же общий префикс иметь lcp ровно k-1. Поэтому никаких различий в позициях с номерами
k-1 быть не может. Значит, все, что было здесь по дороге, они имели все тот же префикс длины k-1.
А значит, это lcp наследуется здесь в этой отрезке длины хотя бы k-1. Оно будет здесь везде. Вот,
ну как мог, обрисовал. Поэтому алгоритм будет следующий, очень простой, ну в плане. Нельзя,
потому что сюда мог кто-то встрять. Вот здесь вот вполне возможно могут быть какие-то строчки,
между ними. И поэтому здесь, да, между этой и этой k-1, но между этой и следующей вполне возможно
больше, чем k-1. Значит, алгоритм будет следующий. Сначала заводим k равно нулю. Так, да. Нет,
perdон. Значит, сначала, чтобы вот с этими индексами будет большая запара, да, вот это gs,
мне нужен массив обратный к массиву p. То есть, p это у меня сейчас перестановка всех в каком-то
порядке. А чтобы, наоборот, чтобы по i, чтобы по суффиксу, по нему позицию в суффмассе,
мне нужен вот этот обратный массив. Значит, это будет у меня pos. pos это массив обратный к
суффиксному. Массив обратный p. Находится он просто. Находится он очень просто. pos от p от i равно
i. Просто обратная перестановка. Значит, дальше. Я буду идти по всем порядке убывания длины. То есть,
первый суффикс, который я рассматриваю, длину полную, да, начиная с позиции 0, потом с позиции
1 и так далее. Значит, первым делом вот я вижу, что при переходе вот i плюс 1 у меня текущая lcp
может уменьшиться максимум на 1. Поэтому тут я пишу такую строчку. k равно максимум из k-1 и нуля.
Если k это найденная lcp на предыдущем шаге, то при переходе к i плюс 1 может в худшем случае
упасть максимум на 1, но при этом, конечно, не может быть. Вот. Ну и дальше я делаю следующее.
Если pos it равно чему-то, видимо, n-1, тогда continue. Да, если текущий рассматриваемый суффикс,
максимальный вообще во всем суффмассе. То есть, если его позиция в вхождении в суффмасс,
это n-1. То есть это максимальный суффикс. У меня не с кем брать lcp, потому что я беру lcp текущего
со следующим, да. Следующего за этим, за последним нету, поэтому я просто его игнорирую. lcp здесь
не будет разделён. В этом случае делаю continue. А иначе, значит, я завожу j. Ну давайте, ну да,
пусть будет j. Это тот чувак, который сразу под ним идёт. То есть, pos i плюс 1. Потому что pos i — это
та позиция, где находится i, а j — это, соответственно, что находится прямо под ним. Вот здесь будет i, а здесь
будет j сразу под ним. И я знаю, что у текущих двух строк, по крайней мере, первые k символов точно
одинаковы. Из-за вот этого перехода точно первые k символов одинаковы. Возможно, кто-то ещё. Но
вот давайте, пока следующие символы одинаковы, я буду увеличивать k. Прям так и напишем. Пока
s и плюс k равно s g плюс k. Ну, там надо ещё добавить проверку, пока мы не вышли за пределы строки,
но мне лень это делать. Я делаю плюс плюс k. Пока вот эти символы одинаковы, я просто увеличиваю
текущую длину lcp. Ну и в конце пишу lcp pos it равно k. Конец.
Вот, значит, что я сделал. По сути, здесь просто как бы вот, ну, как у нас недавно было с z функцией,
мы точно знаем, что ответ хотя бы такой, а дальше я его просто купую и перебираю. Пока тут равенство,
я увеличиваю k. Так же, как было с z функцией. Я точно знаю, что ответ, по крайней мере, такой,
а следующий символ, если одинаковый, то я просто наивно расширяю текущую k. Пока здесь равенство,
я увеличу эту границу. Вот, while. И в конце в lcp создает то самое k. А симптотика здесь будет тем
же причинам линейная, потому что понятно, что вся трудность только в цикле while, но основная
сложность только в цикле while, всё, понятно дело, за линейное время работает. Но каждый трансвит
цикловал увеличивает k на 1, при этом k уменьшается на 1 всего один раз для каждого i. Значит,
уменьшение k будет максимум n, поэтому увеличение будет 2n, поскольку k ограничено точно mk.
Значит, время работы будет линейное. Норм? Не норм? Вопрос, может?
Нет, это скорее, ну, можно считать, что это часть алгоритма, да, но по сути, это как бы два
независимых алгоритма, потому что мы сначала построили sufmas, потом на его основе построили
массив lcp. Ну, причем здесь не столько используется там алгоритм, сколько мне нужно просто знать
все и вот обратно к нему pos. То есть, зная sufmas, мы можем поставить массив lcp, но пока это не
применение еще. Вот применение сейчас будет. 10 минут. Так, да, хорошо. Значит, ну, применение тут такие.
Да, значит, первое это lcp двух подстрок. Есть строка s, запросы вида там l1, r1, l2, r2. Какие-то две
подстроки мне выделяют в моей строке. Мне нужно узнать у них lcp, ну, точнее длину lcp. Делаю следующим
образом. Я нахожу, где в моем суфиксном массиве включается суфикс, начинающий с l1, и где суфикс,
начинающий с l2. Вот давайте их как-то нарисую. Вот он где-то l1, вот он где-то l2. Между ними там
может быть какое-то произвольное количество других суффиксов. Я утверждаю, что чтобы найти
lcp двух вот этих суффиксов, мне нужно взять минимум на отрезке lcp в этом массиве. То есть,
если я знаю lcp для всех соседей, то lcp для двух произвольных суффиксов это просто минимум на
отрезке. Давайте примерно нарисуем вот здесь вот скажем. Вот надо мне найти lcp вот этого чувака
и вот этого. Тогда я беру минимум из двух чисел единиц и тройки, потому что единица это lcp вот этого
и вот этого, а тройка это lcp вот этого и вот этого. Из них минимально это единица. Как видим совпало,
lcp у них равно единице. В общем случае, есть два суффикса, давайте нарисую что-нибудь вот такое.
Есть два суффикса и я знаю lcp на всем отрезке между ними. То есть, я знаю lcp вот здесь,
lcp вот здесь, lcp вот здесь, lcp вот здесь. Тогда lcp вот этих двух крайних это минимум на отрезке.
Ну почему? Давайте как-нибудь это все пронумеруем, не знаю, x1, и далее xm. Пусть k это минимальный из
x. Значит, во-первых, если k это минимум среди всех значений lcp, то гарантированно к символов во
всех этих суффиксах одинаковые. Вот начало длины k у них у всех одинаковое. Потому что если k это
минимум среди всех x, то значит все x больше равны чем k, а значит у любых двух соседей lcp хотя бы k.
Значит, просто вот эти первые k символов перекочевали, они равны, эти первые k символов равны вот этим k,
эти символы равны вот этим k, ну и так далее. Поэтому если k это минимум среди всех на отрезке,
то значит первые k символов точно уже одинаковые у них у всех. У двух крайних одинаковые. Ну и у всех
посередине тоже. Согласны? Вот почему k плюс первый нельзя взять? То есть мы поняли, что первые
k символов точно одинаковые, почему k плюс один не одинаковые? Ну если бы не были одинаковые,
вот скажем, этот символ равен вот этому. Давайте какой-нибудь c и c. Пусть они одинаковые. Но тогда
из-за того, что эти строки расположены между ними, здесь тоже должны быть везде символы c. Потому что
с одной стороны вот эта строка больше собрана чем это, с другой стороны меньше собрана чем это.
Поэтому никакой другой символ отличный от c здесь не может. Если здесь какой-нибудь d, то значит
здесь вот противоречие это с этим. Если тут a, то здесь противоречие это с этим. Поэтому единственный
способ сделать так, чтобы здесь строка была между ними двумя, это обязательно здесь c. И между ними
всеми тоже будет c. Поэтому если k плюс первые символы у крайних строк тоже равны, то и между
ними всеми, то есть на всем этом строке тоже должно быть c на k плюс первой позиции. А значит,
тогда минимум должен быть не k, а k плюс один, потому что у них не просто к символов совпадает,
но и k плюс один тоже везде совпадает. Поэтому тогда k это не правильный минимум, на самом деле
k плюс один был бы правильный минимум противоречия. Давайте еще раз утверждение напишу это.
Так пусть pos l меньше pos l тогда длина наибольшего общего префикса, суффиксы начинаются с l этой
позиции и суффиксы начинаются с r этой позиции. Это в то же время минимум среди всех l на отрезке
от pos l до pos r минус 1. pos l это позиция, где встречается суффикс, начинающийся с позиции l. pos r это
позиция, где встречается суффикс, начинающийся с позиции r. Ну и здесь я вычислил ничку, потому что,
ну давайте вернемся сюда. Вот оно, да, вот здесь написано будет lcp там pos l, то есть вот это вот
это lcp pos l того со следующим, а это lcp pos r минус 1 со следующим, то есть pos r. Мне не нужно
брать вот этот pos r, lcp не нужно закончиться на предыдущем, потому что вниз идти не нужно,
этого с последующим брать не нужно. Поэтому ровно на таком отрезке нужно взять lcp,
а минимум, sorry, на таком отрезке массива lcp нужно взять. Вот, но чтобы его находить,
мне достаточно начислять спарстейбу. Чтобы находить минимум на отрезке,
достаточно построить спарстейбу.
Не надо, потому что у меня есть некий фиксированный lcp, я могу за n log n насчитать, ну как бы строить
структуру, которая потом за единицу позволит мне находить минимум на отрезке. Ну вот, собственно,
здесь оно и используется, за единицу мы находим минимум на отрезке. Вот, значит, если мы научились
находить lcp любых двух суффиксов, скажем, вот это вот мы знаем, что lcp, тогда lcp любых двух подстрок,
это ну реально насчитывается, нужно просто обрубить наши суффиксы до вот тех позиций, которые, в общем,
которые мы рассматриваем. То есть, если lcp вдруг вылезает за пределы рассматриваемой строки,
то нужно lcp уменьшить до длинной строки. Вот и все. То есть, когда я посчитал lcp двух суффиксов,
чтобы посчитать lcp двух подстрок, мне нужно его уменьшить до длин обеих строк, чтобы он был
не больше, чем длинный обеих подстрок. Вот так. Вот все. Присвоить. Вот это мы решили задачу
нахождения lcp двух произвольных подстрок. Вторая задача, немедленно вытекающая из этой,
это верка равенства двух подстрок. То же самое с некой фиксированной длинной строка s,
вам дают ее какие-то кусочка с l1pr1 и с l2pr2, спрашивают, правда ли, что они равны,
как подстроки, правда ли, что это равные подстроки. Решается очень просто. Ну,
во-первых, мы проверяем, что у них одинаковые длины. Во-вторых, мы проверяем, что lcp этих
двух подстрок в точности равны линии произвольной из них. Если lcp равно, то значит,
просто вот эти символы работают этим. И все. Вот. Заметьте, что это мы решили решение задачи,
которые осматривали на первой лекции, которые мы решали через хэши. Чтобы проверить равенство
двух подстрок, мы считали хэш их обеих, проверяли их на равенство. И там с небольшой вероятностью мы
могли ошибаться. А здесь детенцированный алгоритм, который, да, чуть дольше работает,
потому что это n-лугена, там было oatn. Ну окей, чуть дольше работает, но зато никогда не ошибается,
всегда воздушает правильно. Вот. Все, спасибо.
