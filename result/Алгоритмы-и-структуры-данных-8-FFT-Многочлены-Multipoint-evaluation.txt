Так, значит, что мы уже умеем с прошлого раза?
Давайте начинать.
Мы научились перемножать два многочлена за n log n,
если n – это, ну, длина, скажем, каждого из них.
Мы научились это делать в поле ZP, и мы избавились
от рекурсии.
Избавились от рекурсии, чтобы это работало чуть
быстрее в плане реализации.
Вот.
Давайте тогда вернемся к задачке, в которой мы мотивировали
наше вхождение в FFT.
Значит, есть текст T и шаблон S.
Надо найти все вхождения S в T не более, чем с K ошибками.
Секунду.
Вот.
Значит, что мы хотим?
Смотрите, вот есть строка T, и мы всюду прикладываем
к ней строчку S.
То есть вот здесь вот выделяем окошко той же длины, что
и S.
Вот здесь вот.
Вот здесь вот.
Ну, в общем, все окошки одинаковой длины, равной длине S мы выделяем.
И хотим понять, сколько есть совпадений между S и окошком,
который мы выделили.
То есть в каком-то смысле нам нужно во всех вот таких
вот подстрочках T фиксированной длины найти, сколько символов
совпадают с S.
Для этого мы сделаем следующее.
Значит, мы запустим цикл по всем буквам, цикл по
всем буквам из алфавита, и давайте одновременно
и в T, и в S заменим все вхождения C на единички, а все вхождения
остальных букв на нули.
Значит, внутри цикла заменяем вхождение C на единицу, вхождение
всех остальных на ноль.
Значит, такой переход удобен тем, что теперь можно считать
скалярные произведения вот этих вот кусочков,
соответственно, окошков T и всей строки S, тогда скалярные
произведения равно просто-напросто числу совпадающих C, потому
что у нас только 1 на 1 дает какой-то вклад в скалярные
произведения.
Если там 0, 0 или 0, 1 или 1, 0, это будет 0 в вклад в произведение.
Поэтому вот такое вот скалярное произведение такого окошка
на S – это число C совпадающих в этом отрезке с S.
Дальше, если мы возьмем вот этот следующий окошек
на 1, звеним его, то опять скалярное произведение
его с S – это сколько совпадающих C в этом окошке с S, ну и
так далее.
И тогда, если мы это сделаем, если мы как-то посчитаем
все такие скалярные произведения для всех буквок и, соответственно,
тогда для каждого окошка просуммируем, сколько было
совпадений по каждому символу алфавита, то мы узнаем,
в скольких позициях происходит, наоборот, совпадение.
И если это количество совпадений хотя бы S-K, то значит, ошибок
не больше, чем K.
Понятно?
Если совпадений хотя бы S-K, то значит, ошибок максимум
K.
Поэтому наша цель сделать следующую.
Для каждого символа алфавита T из Сигма найти скалярные
произведения всех подотресков длины S в T и T.
И S, sorry.
То есть мы выделяем все окошки вот такой вот длины
в нашей строке.
Ну теперь уже эта строка из 0 единиц, можно ее рассматривать
просто как вектор чисел, да, соответственно, как многочлен
или как вектор.
Выделяем все такие подотрезочки и их все скалярно умножаем
на S, где S тоже вектор чисел, единицы нулей.
Каждое такое скалярное произведение, то количество
совпадений.
Если выделяем все скалярные произведения, то мы будем
знать количество всех совпадений для каждого окошка с S.
Далее для каждого подотрезка суммируем количество совпадений
по всем буквам.
Если оно хотя бы модуль S-Sk, то значит, получилось
вхождение максимум с ошибками.
Вот, значит, теперь остается для каждого сима алфавита
посчитать скалярные произведения всех подотрезочков на какой-то
фиксированный вектор S.
Значит, сделается это следующим образом.
Давайте мы будем воспринимать, как я уже сказал, будем воспринимать
T просто как многочлен, да, потому что здесь написаны
какие-то числа, там нолики, единички.
Давайте эти числа воспринимать как коэффициенты многочлена.
Соответственно, если здесь были какие-то цифры, T0 и
так далее, T там какое-то, N-1, давайте, да, N-1, тогда я
ставлю в соответствии многочлен T от X равный T0 плюс T1X, плюс
так далее, плюс Tn-1 и Xn-1, стандартным образом многочлен
сопоставляю.
Вот, а для S мы сопоставим реверс для многочлен.
То есть если у меня строка S состоит из симулов, точнее
из чисел, S0 и так далее, SM-1, вот, здесь я веду многочлен
с противоположной нумерацией, то есть младший коэффициент
будет вот этот, а этот будет старшим.
То есть я ввожу такой многочлен S от X, равно SM-1, плюс SM-2
на X, S0 и Xn-1, вот, а дальше я их перемножу.
Ну и давайте, например, посмотрим, какой будет коэффициент
при X в степени m-1.
То есть если я перемножаю вот эти две штучки, какой
будет коэффициент при X в степени m-1?
Ну понятно, надо перемножить T0 на S0, чтобы получить вот
это вот первое слагаемое, а значит T0 на S0, либо можно
взять T1X умножить на S1 и Xn-2, потому что там будет
X и Xn-2, они сложатся, получится как раз M-1, будет M1S1, ну и
так далее.
В общем, мы вот так должны пройтись, чтобы получить
одинаковую степень m-1, вот это у меня будет как раз
первое необходимое нам скалярное произведение.
Согласны?
Просто перемножил два многочлена.
Вот, ну и аналогично, если я рассмотрю, скажем, коэффициент
при X в m-2, значит тоже, откуда он берется?
Надо умножить вот это на это, то есть T1S0, либо вот
здесь второе слагаемое, T2X2, здесь предпоследнее, S1Xn-2
будет как раз X в m-2, то есть T2S1 получается коэффициент,
ну и так далее.
Опять мы идем вот так друг на встречу дружки двумя
На указателях получится последнее слагаемое TMSM-1,
ну и так далее.
Если я аккуратно напишу коэффициенты при всех больших
степенях X, то у меня как раз получатся вот такие
вот штуки, которые в точности равны тому, чему нужно, потому
что вот это, это скалярное произведение первого подотрезка
в T на S, T0, T1 и так далее, умножить на S0, S1 и так далее.
Вот это, это скалярное произведение второго
подотрезка на S, T1, T2 и так далее, на S0, S1 и так далее.
Ну и в итоге коэффициент при, давайте напишем, коэффициент
при X в степени m-1 плюс какой-нибудь k есть TKS0 плюс TK плюс 1S1 и так
далее.
A плюс m-1, S m-1, это одно из нужных скалярных произведений,
одно из необходимых скалярных произведений.
Ну и всё, значит, мы нашу задачу, поиск всех скалярных
произведений свели просто к тому, что переносит два
многочленов, и они вот так волшебным образом, коэффициенты
при нужных степенях X дают нам как раз те самые скалярные
произведения.
Значит, мы вот эту задачу, вот эту вот верхнюю решили
за время n лог n, то есть для каждого фиксированного
цена нужно переносить два многочлена, и где-то там
при должных степенях X как раз хранятся те самые скалярные
произведения.
Да, ну и поскольку раз у меня есть два многочлена,
один с n коэффициентами, другой с m, понятно, что m меньше
равно n, потому что иначе задача не очень осмысленна,
то есть n больше из них, и время произведения это
n лог n.
При этом многочлены очень хорошие, там только нули
единицы в качестве коэффициентов, поэтому скорее всего никаких
переполнений, никаких проблем с точностью не будет, если
просто в комплексных считать.
Да.
Это я для каждого, вот для фиксированного ц, время
такое.
И плюс, надо ещё умножить это всё на то, сколько символов
в алфавите.
Если он константо, то это и будет асимплотика, если
он не константо, ну здесь дополнительно какой-то
множественный появляется, множественный на размер
сигма.
Значит, давайте я ещё раз это пропишу, для каждого
ц время работы есть n лог n, вовсе время работы, соответственно,
на модуль сигма.
Ну и значит, как обычно, если мы считаем, что алфавит
– это маленькие латинские буквы, то это как бы константо,
её можно в этим точке не учитывать, но для того, чтобы оценить
реальный время работы, лучше как бы как-нибудь на 26 надо
будет умножить.
Вот это вот, чтобы понять вообще, насколько это быстро
уложится ли это в время, которое вы хотите.
Но если это не константо, если там, скажем, могут быть
какие-нибудь, не знаю, какие-нибудь числа вместо символов,
то тогда надо аккуратно смотреть, чему равен размер
алфавита.
А чтобы было вот так вот удобно, потому что когда мы переворачиваем
строку и считаем коэффициент при какой-то степени х,
у нас, чтобы найти коэффициент при должной степени, мы
как бы идём с двух сторон, ну с противоположных сторон
в наших многочленах, потому что если мы фиксировали
степень, то при росте одной степени вторая должна убывать.
А мне нужно, чтобы при вот таком движении у меня как
бы и индекс УТ возрастал, и индекс УС возрастал, поэтому
мне нужно С реверснуть.
Вот, значит, вроде сделали, тем самым мы решили нашу
задачу про строки, про вхождение максимум с к ошибочками.
Вопросы?
Хорошо.
Да.
Ну надо аккуратно написать, какие у нас границы на
к.
Значит, это верно, если, ну, собственно, вот это вот
не превосходит n-1, то есть к не больше, чем n-m.
Вот это верно, согласны, что если это верно, то можно
так написать.
Вот.
Ну а другие нам на самом деле не нужны, потому что
давайте поймём, вот если к такое, то что тут будет
написано?
Здесь будет написано t с индексом n-m на s0 плюс на
s1 плюс и так далее, последний будет, видимо, как раз n-1
на m-1.
Но это, собственно, ровно последнее скалярное произведение,
которое нам нужно.
Оно заканчивается в последнем символе, значит, никакие
другие коэффициенты нам просто не нужны.
Значит, мы рассматриваем все к от нуля до n-m, они задают
нам все необходимые скалярные произведения, больше нам
ничего не нужно.
Так, хорошо, задача следующая.
Уже не про строки.
Задача такая, есть многочлен p, p от x, надо найти обратный
к нему по модулю x в степени m.
Обратный – это такое число, что в произведении единица
по модулю данному.
То есть, ищем, такое-то q от x, такое, что p на q сравнимо
с единицей по модулю x в m-t.
Иными словами, p умножить на q минус 1 делится на x
в m-t.
Все одно и то же.
Ну, что такое единица по модулю x в m-t, что такое
вообще делится на x в m-t?
Это значит, что у этого многочлена нет коэффициентов
младше m-того.
То есть, там свободный член, член при x, x в квадрате
и так далее, при m минус 1 степени все нули, и только
возможно при m-той более старших есть какие-то коэффициенты.
Главное, что вот эти первые m коэффициентов от нулевого
до m минус первого равны нулю.
То есть, пока не понятно, зачем это нам нужно, давайте
поверим, что это зачем-то нужно, мы это применим в
следующей задаче.
Давайте как лему это воспринимать.
Первое, что я сделаю, это скажу, что давайте считать,
что m – это степень двойки.
Потому что, если m – это не степень двойки, то я могу
m увеличить до ближайшей сверху степени двойки,
так что это условие станет только более сильным.
Если я решу задачу в более сильном условии, то я, соответственно,
решу исходную задачу.
Ну, потому что здесь тут написано делится на x в
десятой, я скажу, а давайте вместо такого q найдем такое
q-штрих, что оно делится на x в шестнадцатой.
Давайте m – это 10, а я найду такое q-штрих, что делится
на x в шестнадцатой.
Понятно, что это только более крутой q-штрих, значит
его в частности можно использовать вместо такой, мы решили
исходную задачу.
Поэтому можно считать, что m большой от степень двойки.
В противном случае можно m увеличить.
Можно увеличить.
И тогда алгоритм, который мы будем использовать, работает
так.
Мы будем идти по всем m-кам, по всем степням двойки,
1, 2, 4, 8 и так далее, и решать задачу для все больших и
больших m.
То есть мы сначала найдем такое q, что pq – это единица
по модулю просто x в первой, потом, используя это q, мы
найдем какое-то новое q, какой-то q-штрих, что pq-штрих
– это единица по модулю x в квадрате, потом по модулю
x в четвертой, ну и так далее, в общем, когда-то дойдем
до x в м.
То есть будем увеличивать степень у икса в два раза
каждый раз.
И решать вот эти задачи друг за дружкой.
Скажите, пожалуйста, как решить задачу для единички
вот здесь?
Если у нас есть p, то чему равно q такое, что единица
по модулю x?
Да, конечно, если p, давайте я напишу, что у нас p состоит
из коэффициентов а0, а1х и так далее, тогда в качестве
q вот здесь можно взять просто 1 делить на а0, тогда их произведение
– это единица плюс что-то деляющееся на x, потому что
все вот эти вот слагаемые, когда я их поделю на а0,
там будет, ну, в общем, что-то делящееся на x.
Я так и напишу – x умножить на что-то.
И это, конечно, единица по модулю x.
Вот, ну так, конечно, можно сделать только если а0 не
равно 0, но если а0 равно 0, то мы и исходную, и эту
задачу никак решить не можем, потому что если в
многочлене p у нас вот этого члена нет и все делится
на x, то, извините, мы не можем никакого q подобрать,
такое, что pq сравнимый с единицей по модулю x в
m.
Потому что эта штука всегда будет делится на x, раз
это делится на x, то это делится на x, и x не может быть сравнимый
с единицей по модулю x в m.
На единица – значит, свободный член единица, а тут написано,
что все члены хотя бы с x начинаются, поэтому такого
быть не может.
Значит, если это неверно, то есть а0 равно 0, то решения
в принципе не существуют, давайте где-нибудь пометим,
если а0 равно 0, то решения нет, решения нет.
Если же все хорошо и вот это вот выполняется тогда,
тогда мы можем решить базу, собственно, как бы это можно
воспринимать как индукцию, вот базу мы решили, мы нашли
такое q, что pq единица по модулю x.
Хорошо, а теперь давайте считать, что у нас откуда-то
есть такое q, пусть есть q, пусть есть q, такое, что
p на q – это единица по модулю x в m какой-то, давайте m маленькая,
мы хотим найти новый q штрих, хотим найти q штрих, такое,
что p на q штрих – это единица по модулю x в степени 2m,
значит мы будем искать q штрих в следующем виде,
значит в виде q от x плюс x в m умножить на t от x, где
t некий неизвестный на гаче, значит мы будем решать
нашу задачу в предположении, что первые m коэффициентов
в q штрихе совпадают с коэффициентами из q, но на самом деле можно
показать, что это обязательно ровно так и выполняется,
потому что если верно вот это, то после взятия
всего по модулю x в m-той у меня здесь остается вот
это p, а здесь значит должна остаться вот это вот q, поэтому
как бы младше m коэффициентом из q штрих обязаны быть теми
же из q, вот поэтому мы считаем, что мы просто перекопируем
младше m коэффициентов из q, а следующие m коэффициентов
это многочлен t и я еще из этого всего вынесу x в m-той,
то есть обе вот эти штуки – это многочлены с m коэффициентами
каждой, но только t это как бы коэффициенты при старших
степнях x при второй половине степеней, будем искать q-штрих
в таком виде, далее, далее, далее, давайте мы еще будем
считать, что p от x это p0 от x плюс x в m-той на p1 от x,
то есть вот у меня был какой-то большой p, вектор коэффициентов
многочлена p, я во-первых сначала обрубился на первых
2m коэффициентах, у меня все равно последнее нужное
мне равенство, оно по модулю x в степени 2m, поэтому все
что правее, все что начинается с 2m того символа меня не
интересует, все что правее меня не интересует, а это
я поделю пополам, слева будет p0, справа p1, когда p вот
в таком виде представляется, значит есть такое, есть
мы точно знаем еще, что p0 на q это 1 по модулю x в m-той,
то есть это было верно для p, но понятно, что p и p0 не
отличаются если мы работаем в x в степени m, поэтому вот
это вот уравнение можно чуть уточнить, написать что
здесь написано p0 вместо p, потому что все равно все старшие
степень не влияют, ну и давайте мы вот это вот сравнение
напишем чуть точнее, а именно мы напишем что p0, давайте
я не буду писать в скобочках x, не лень, я напишу что p0
на q это 1 плюс x в m-той умножить на r, а раз оно сравнимо с
1 по модулю, значит есть какое-то вот это вот частное
r, такое что выполняется такое равенство, ну и соответственно
r, скажем, можно довольно легко посчитать, мы можем
просто перемножить эти два многошена друг на друга,
и все коэффициенты начиная с m-того засунуть в многошен
r, а если нам известны p0 и q, то r можно просто одним f
of t найти, ну точнее как бы тремя f of t, но одним перемножением.
Вот, ну и теперь давайте попробуем понять, чему же
тогда должен быть равно t, потому что у нас единственное
неизвестно это t, надо его найти, ну мы хотим, чтобы
выполнялось вот это вот равенство, то есть p0 плюс x в m-той p1 умножить
на q плюс x в m-той t, было сравнимо с 1 по модулю x в степени 2m,
это мы хотим, но мы хотим найти такое t, чтобы это выполнялось,
ну давайте раскроем здесь скобки, будет p0 на q, дальше
будет x в m-той на p1 q плюс p0 t, плюс еще произведение
вот этих вот маномов, но оно сравнимо с нулем по
этому модулю, потому что там есть просто множество
по модулю x в степени 2m, мы можем вот это даже не перемножать,
потому что оно делится на модуль, вот, значит есть
такая штука, это все сравнимо по модулю x в степени 2m,
и мы хотим, чтобы это было равно единице, хотим, чтобы
это было сравнимо с единицей, так, ну давайте еще заменим
вот это вот p0 q, у нас же есть что p0 q это 1 плюс x в m-той
на r, значит все вот это вот вместе сравнимо с единицей
плюс x в m-той на r плюс p1 q плюс p0 t, так, ну и что тогда
дальше?
Мы хотим, чтобы это было единицей по модуле x в степени
2m, но вот единичка есть, единственное, что мне осталось
сделать, это чтобы вот это вот делилось на x в степени
m, потому что если это делится на x в степени m, то вот это
все слагаемое делится на x в степени 2m, и здесь как
раз та самая заветная единичка, поэтому мы теперь хотим,
чтобы вот этот вот, вот этот множитель r плюс p1 q плюс
p0 t был сравним с нулем по модуле x в m-той, потому что
еще раз, если это верно, тогда весь этот множитель
делится на x в m-той, это делится на x в степени 2m, а значит
как раз вся эта сумма сравнима с единицей по модуле x в
степени 2m, единичка плюс что-то делящееся на x в степени
2m, поэтому если мы этого добьемся, то мы решим задачу.
Осталось решить вот такое сравнение, ну давайте поймем,
что здесь неизвестно, неизвестно здесь только t, все остальное
нам известно, p0, p1 это то, что у нас было на входе, q
это многочленец прошлого слоя, r это вот здесь вот
неполное частное определение на x в степени 2m, это нам
все известно.
Вот, ну давайте разрешим это уравнение относительно
t.
t должно быть сравнимо с элементом обратным к p0, умноженному
на минус r минус p1q по модуле x в степени 2m, но у чуда обратная
к p0 по модуле x в степени 2m мы уже знаем, это q, вот она,
обратная к p0 по модуле x в степени 2m это q, значит
просто здесь я могу заменить обратное к p0 просто на q,
значит у меня есть просто выражение для t, t это q умножить
на минус r минус p1q по модулю x в мт, вроде все, то есть
мы нашли то самое t, которое хотели, вот, ну теперь осталось
разобраться со симптотикой, о чем мы сделали, мы научились
переходить от, давайте вот сюда вернемся, вот такого
сравнения к вот такому, то есть мы увеличили степень
в 2 раза, за сколько, ну по сути что нам нужно было,
нам нужно было найти вот это r, то есть вот первый
кусок, это найти вот это вот r, которое нам здесь нужно,
а дальше применить вот такое вот преобразование, но
это все, это просто несколько перемножений многочленов,
потому что вот здесь вот нам нужно перемножить
p0 на q, чтобы извлечь те самые коэффициентции r, это
просто перемножение, вычитание единиц и отбрасывание каких-то
там коэффициентов, отсюда мы знаем r за одно перемножение,
и здесь нужно сделать два перемножения, p1 умножить
на q, потом изменить знак, вычесть r и еще умножить на q, значит
все вот это, весь переход от x в мт к x в степени 2m выполнен,
ну выполняется за o от m log m, потому что всюду по дороге
у нас были многочлены всего лишь с m коэффициентами,
у нас, ну окей, вот здесь возможно там, да, когда мы их перемножим
у нас будет 2m коэффициентов, но это все равно o от m, я перемножил
два многочлена с m коэффициентами, получил с 2m коэффициентами
максимум, да, значит здесь нам известно r отсюда, ну
и здесь все произведения производится по модуле x в мт, значит нам
нужно от многочленов только первые m коэффициентов знать
и перемножать мы их можем за m log m, вот, все, ну осталось
оценить итог восьмую точку, когда вот мы много таких
итераций делаем, по всем степеням двоечки, каждая
итерация это новая m log m, вот чему равна эта сумма,
давайте поймем, давайте.
Ну, смотрите, мы вот это знаем, тогда в этом уравнении
оно происходило по модуле x в мт, это ну как бы предположение
индукции скорее, нет, нет, нет, еще раз, вот это предположение
индукции, дальше, на самом деле вот это условие и вот
это, это просто одно и то же, потому что здесь, у меня
когда я пишу p от x и рассматриваю по модуле x в мт, мне на самом
деле не нужны никакие коэффициенты старше, старше минус 1, здесь
ровно это и написано, то есть я здесь отбросил все
коэффициенты, начиная с мт, то есть p по модуле x в мт
это просто p0, поэтому это одно и то же, так что нашли
еще раз, да, мы часто перемножили, вычислил единичку, отбросил,
ну как бы поделили на x в мт, деление просто сдвиг
влево, так, ну чего, значит мне нужно посчитать переход
по всем степеням двоечки, каждый переход от m к 2m работает
за от m лог м, значит тогда итоговое время работы
это просто сумма по всем степеням двойки, давайте
я скажу, пусть m большой это два степени какой-нибудь
в к, тогда мне нужна сумма по всем, скажем g от единицы
до к, два вжитой, но логарифм два вжитой, похоже, так, вот
тут кайф, я никогда это не проделывал явно, давайте
попробуем, два вжитой ножи, гин два вжитой, да, умею
делать, значит смотрите, это все не больше чем сумма
пожи от одного до к, к на два вжитой, я оцениваю
уже через к, и остается к умножить на сумму пожи
от одного до к, два вжитой, вот, ну понятно, что это такое,
мы знаем это точно, это заведомо не больше чем удвоенное
два в степеника, то есть два в степеника плюс один,
а это есть от m логм, вот, поэтому даже несмотря на
то, что у меня вот здесь по дороге было куча fft, да,
каждый из них соответственно работал за какой там m логм
для разных m, но если мы все это просуммируем, то как
бы самые сложные, самые сложные переходы, они вот
в конце, да, от m пополам к m, как бы вот это вот дает
основной вклад в симптотику, а все остальное там какая-то
мелочь, которая ни на что не влияет, не там, коэффициент
на два, возможно, умножить, да, вот здесь будет двоечка
в определении у большого, ну и все, все мелкие, они
как бы пренебрежимы малы по сравнению с последним
шагом, то есть как будто бы мы просто взяли и там
что-нибудь, что-нибудь на что-нибудь умножили, да,
взяли два многошлина вот такой степени, просто друг
на друга перемножили и как будто бы сразу обратили,
но на самом деле по дороге мы делали много-много более
мелких fft-шек, которые пренебрежимы малы по сравнению вот с
этим, окей, ну хорошо, значит, тогда мы научились обращать
по модулю x в m-той, теперь полезная задача, деление
многочленов, есть два многочлена, надо поделить один на другой
с остатком, значит, данные многочлены, давайте их назову
f и g, а надо поделить f на g, то есть найти такие по и
q, давайте q и r я их назову в разнообразии, q и r такие,
что f это gq плюс r, а степень r меньше, чем степень g, ну
вот прям как если бы вы их в столбик делили, у вас
там получается какое-то неполное частное и остаток
степени которого должно быть меньшей степенью делить
это, вот, ну такая задача деления, научились умножать,
давайте научиться делить, давайте научимся делить
так, ну сейчас будет магия, а смотрите, давайте для
с не нулевым старшим членом, не нулевым старшим коэффициентом,
определим метод reverse, rev от p, это когда я просто-напросто
беру и разворачиваю порядок следований коэффициентов,
значит это опять многочлен, а n плюс а n минус 1 x плюс
и так далее, а 0 x в n, просто reverse на векторе, так, значит
тогда я утверждаю, что верно следующее, что reverse это
мультипликативная функция, в том смысле, что reverse от
произведения g на q равен произведению реверсов
g на q, reverse от g на reverse от q, ну чего, давайте докажем
для приличия, давайте скажем, что это утверждение, давайте
докажем, пусть g это что-то типа g0 плюс g1x плюс g какой-нибудь
kt x в kt, а q это q0 плюс q1x плюс qmt x в mt, ну считаю, что старшие
коэффициенты не нулевые, но иначе можно отбросить
несколько старших, чтобы первый значище был не нулевой,
чтобы старший значище был не нулевой, вот, ну давайте
посчитаем, чему равен коэффициент при какой-нибудь степени
x в этом произведении, значит, коэффициент при какой-нибудь
x в l-той в многочлене g на q, он равен, но понятное дело,
нужно перебрать все такие и плюс g с суммой l и перемножить
g i t на q g t, это коэффициент при x в l-той в многочлене
g на q, значит, когда я применяю к нему реверс, вот к этому
многочлену g умножить на q, я применяю реверс, у
меня понятное дело, что старший коэффициент будет gkt на qmt,
он будет не нулевой, многочлен будет в точности степени
k плюс m, поэтому при реверсе у меня x в l-той перейдет
в x что-то типа m плюс k минус l-той степени, да, значит,
эта же штука, коэффициент при x в степени k плюс m в
реверс от g умножить на q, правда, вот, ну и то же самое
надо при какой-то степени x найти коэффициент в этом
произведении, не очень интересно, ну давайте сделаем, давайте
для приличия напишу ревод g и ревод q, что это такое,
gk, gk минус 1x, g0x в k-той, ревод q, это qm, qm минус 1x, далее q0xvm-той,
значит теперь я должен перемножить и понять, чему
равен коэффициент при вот такой степени x, ну давайте
посмотрим, коэффициент при x в степени k плюс m минус
l в произведении этих реверсов, рев g на рев q, значит, чему
он будет равен? Мне нужно взять отсюда какую-то степень
x, отсюда степень x, а так, чтобы они вместе, чтобы сумма
степени была k плюс m минус l и вот понять, чему там будут
равны коэффициенты, ну давайте напишем сумма по, так, нужны
какие-то еще буквы. Ух ты, да, кстати, где-то я такое
видел, давайте еще раз равно x в k-той, нажимает 1 на x,
и типа из этого все очевидно. Так, хорошо, давайте, действительно,
кажется, это выглядит более приемлемо, ну понятно, что
это доводится, да, то есть если аккуратно посчитать
коэффициент такой степени в этом произведении, то
будет ровно то же самое, зуб даю, да, но нам тут предлагают
более изящное решение, действительно, можно заметить,
что когда мы делаем реверс, это как если бы мы подставили
1 делить на x вместо x и все умножить на x в k-той, да,
потому что здесь, ну вот давайте сюда вернемся, здесь
когда мы поставим вместо x, 1 на x, здесь ничего не меняется,
здесь будет же 1 делить на x, она надо, чтобы умножить
на x, а, умножить на x в k-минус, ну в общем, да, как раз ровно
это и будет, так справа налево оно и получится. Так,
хорошо, тогда что такое реверс от g умножить на k, g умножить
на q, но это видимо как раз x в степени k плюс m на g на q,
ну g от 1 x и q от 1 x, нам надо проверить, что вот это равно
вот этому произведению, но это вроде как очевидно,
да, окей, да, действительно, спасибо, так изящнее, значит,
еще раз, да, вот первое доказательство, можно явно
посчитать кефиценты и получится то же самое, либо более изящно
заметить, что выполняется такое вот соотношение на
ревы, тогда написать чему равно рев от g умножить на q,
и оно будет в точности равно вот этому произведению.
Так, ну хорошо, едем дальше, значит, это мы знаем, тогда,
зная вот это равенство, я сейчас могу навсягать такое,
рев от f равно рев от g умножить на рев от q плюс рев от r умножить на
x в степени, степень f минус степень r, степень f минус степень r, значит,
ну вот здесь, да, то есть мне нужно взять реверс из этой штуки,
произведение понятно, что можно расщепить, да, поскольку рев мультипликативен,
и ну тут еще проблема вот с этим r, да, потому что когда я взял такой
многочлен и в конце вот g умножить на q, в конце добавил r, я как бы его добавил
к младшим коэффициентам, и после реверса они стали самыми старшими,
да, они стали идти прям в самом начале, вот там, где старшая степень f, там была
младшая степень r, младший коэффициент r, ну и чтобы это учесть, мне нужно его
реверснуть, а еще сдвинуть влево на достаточно большую степень, потому что
если я ревершу r сам по себе, давайте картиночкой нарисуем, вот было g умножить
на q, а r у меня было где-то здесь, то есть это прибавка к каким-то младшим
коэффициентам, при вот этом большом реверсе, у меня r перемещается сюда вот
сначала и реверсится, а если реверс на r сам по себе, то он будет вот здесь,
мне нужно его еще сдвинуть на такую степень чтобы он как раз влиял на старшую степень
окей вот хорошо значит есть и теперь мы берем обе части по модулю x в степени сейчас надо быть
аккуратным дег f минус дег g плюс один да вот и поскольку смотрите поскольку дег r меньше дег g
то вот эта вот штука большая равна вот этой
потому что если меньше значит меньше равно значит дег g минус единицы ставим минусики в обеих частях
не знать не нравится меня и с ним противоположные получается что вот эта степень это хотя бы вот
этот степень значит когда я беру по такому модулю у меня последние слагами вообще уничтожится
потому что здесь домножение на x хотя бы в той же степени в которой в модуле поэтому после
взятия по модулю x в этой степени у меня получается такое равенство что реверс f равнимо с реверс g
на реверс q по модуле вот этого x x в степени f минус дег g плюс один
такие задачи мы уже умеем решать потому что смотрите здесь известный рев f и рев g мы не знаем
только рев q и поэтому чтобы это решить да чтобы разрешить это сравнение нам нужно как бы поделить
обе части на рев g то есть найти обратный к этой штуке по модуле x степени m а такой мы за что
решали чтобы это сделать нам нужно идти обратно к этой к этой штуке благо она обязательно существует
потому что реверс он что делать он нам на младший коэффициент ставит то что раньше было старшим
а старший был не нулевой значит теперь младший не нулевой поэтому обратный всегда существует вот
мы мы его находим по прошлому значит из прошлой задачи да значит находим обратный к рев от g по
вот эту модулю ну и соответственно нужно слева домножить обе части на вот это самое обратное
получится рев от q с помощью одного произведения опять да то есть одно переножение многочленов
знаем рев от q по тому же модулю так но раз мы знаем рев q по такому модуле я утверждаю что мы на
самом деле рев q целиком знаем потому что какая степень была у q если мы делили многочлен степени
на многочлен степени g у нас обязательно получится многочлен степени ровно dg-g так работают так
работают степени поэтому вот эта штука это многочлен степени максимум dg-g то есть просто q
это многочлен ровно такой степени dg-g но когда я сделал реверс у меня на старшее место встал младший
коэффициент возможно был нулевой поэтому степень от штуки не больше чем dg-g поэтому когда я
многочлен по модулю x в степени больше его степень я ничего с ним не делал это я отбрасываю
всем многочлен начинаю вот с этого все мономы начинаю вот с этого но они все и так нулевые
потому что этот многочлен меньше степени значит на самом деле это просто в точности равно рев q
без всяких зайти по модулю потому что степень меньше чем вот это вот но а если я знаю рев от q
я знаю q, надо просто еще раз развернуть порядок следования коэффициентов. Но если мы знаем q,
то r найти отсюда вообще никакого труда не составляет, надо перемножить g на q и вычесть из f.
Ну все. Ну давайте раздаем. Чему равна вообще степень q? Степень q в точно равна степени f
минус степень g. То есть если мы все операции делаем в множестве вещественных чисел,
ну или там комплексных, то в степени складывается переперемножение. Раз вот здесь
должно быть написано на грешной степени в точности f, то степень q должна быть равна
dg f минус dg g. Это окей? Вот. Ну тогда после реверса степень q на самом деле может только упасть,
потому что вот здесь гарантировать старший коэффициент не ноль, дальше я разворачиваю
порядок следований элементов, теперь старшим на старшим оном это тот, который раньше был
младшим. Старший коэффициент тот, который был младшим. И может здесь степень могла уменьшиться,
но точно не вырасти, потому что число коэффициентов не увеличилось. Поэтому диагода r уже не больше,
чем просто диагод q, но это равно dg f минус dg g. Вот. Здесь написано большая степень. Вот здесь x
находится в большей степени, чем степень вот этого многочлена. Поэтому это взятие по модуле не
влияет. Так. Ну вот вроде все. Ну смотрите, что такое обратное. Это такое, что домножение на
этой единице. Ну давайте вот здесь я напишу. Пусть мы нашли какой-то многочлен h, такой,
что h на rev g это единица по модуле нужному. Тогда давайте я теперь обе части умножу на h. Вот здесь
умножу на h и здесь умножу на h. Тогда это будет единица, то есть можно отбросить. А здесь написано
обратный к rev g на rev f. Ну поскольку надо просто поделить на эту штуку, а мы, ну как бы поделить
то, что нужно обратный. Так. Начнем по симптотике. Значит вспоминаем, что мы здесь делали. Мы один раз
нашли обратный по модулю. Причем этот, ну как бы вот здесь вот m не будет степень f. Это мы делаем
за n лог n. Если n это степень f, делаем за n лог n из прошлой задачи. Но потом надо еще какие-то
два многочлены перемножить, что-то там вычесть. Это тоже n лог n, где n максимальной степеней.
Поэтому симптотика здесь опять n лог n. Да, конечно, с больше константа, чем в fft, потому что здесь
много-много раз в fft применяется, но n лог n тем не менее.
Вопросы? Хорошо. Так. Почему можно отбросить модуль? Смотрите, вот тут написано какой-то
многощен по модуле и в степени большой. Что такое многощен по модуле x в какой-то степени?
Конечно, мы просто в этом многощене отбрасываем все мономы, начиная с этой степень, нам мы отбрасываем
все мономы, деляющиеся на x в такой степени. То есть, просто wouldn't mind 꼈 с этой степень
отбрасыв., clouds smit & dir. Значит, если мы покажем, что степень этой
штуки меньше чем вот это, значит, мы просто ничего не отбросили. Но давайте
посчитаем, чему равна степеньieraェ 회за. Мы знаем, чему равна степень q, и это просто разность
степеней f и g, потому что так не работает. А что происходит,
когда мы делаем реверс? Ну мы взяли вот эти коэффициенты,
меняли их порядок, понятно, что степень от этого, как
бы, обычно не изменилась, но максимум могла, возможно,
могла упасть, потому что мы, когда делаем реверс,
у нас младший коэффициент стоит на место старшего,
если младший был нулём, старший стал тоже нулём.
Но по крайней мере точно не вырос, потому что число
коэффициентов не выросло. Значит, Degfg не больше, чем
Degq, равное Degf-Degg, а эта штука меньше, чем вот это,
на единичку хотя бы. Всё. Так, дальше можно? Значит,
следующая задача, тоже, тоже очень полезная, это так
называемый мультипоинт эвалиуэйшн. Ну, собственно, название
очень говорящее, на грошей надо посчитать его значение
в данных k-точках. Давайте здесь будут h-ки. Нужно найти
его значение в точках B0 и так далее Bk. Давай B1 и так
далее Bk. Вот, ну если точек мало, то задача не интересна,
ну там, если в одной точке, надо просто поставить это,
за линию работает. Точек много, и мы применяем наивный
алгоритм. То время работы будет примерно k-то, а мы
сейчас научимся быстрее. Рема очень сложная. Значит,
P от B равно значению остатка при линии P на x-b. Давай так
напишу. Знаете, какую терему? Да, должны знать. Ну, это
верно просто, если мы напишем, что P от x, не знаю, зачем
значит, если вдруг мы знаем вот это вот, то есть если
мы поделили P на x-б остатком, тогда на самом деле это
никакое не R от X, а просто какое-то О, да, потому что
степень остатка должна быть меньше, чем степень
от 1 до 2. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Ну, вот так вот. Ну, вот так вот. Ну, вот так вот. Ну, вот так вот.
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
Спасибо за просмотр!
meditation.x-b!
allesus.org
meditation.x-b!
discount.y-x!
discount.y-x!
wu!
free.
free.
free.
free.
free.
free.
free.
Здесь произведение «всех», но вот «всех» я уже не буду
писать.
Ну какое дерево?
Значит, смотрите, я утверждаю, что можно наш нлщnp просеивать
сверху вниз и брать, ну то есть как бы, если бы мы
просто брали p по модулю всех вот этих вот листиков,
то мы бы ничего не выиграли, потому что мы все равно
делим как бы много раз, один тоже многошлин на маленькой
степени, это та же самая симптотика была.
Вместо этого давайте сделаем следующее, давайте мы возьмем
сначала p по вот этому модулю, то есть, например, мы ищем
x по модулю x-b3, тогда я взял p по этому модулю, потом
по этому, потом по этому, потом по этому, каждый раз
у нас степень уменьшается вдвое, поэтому задача становится
все проще.
Здесь мы когда брали по модулю, у нас там, ну примерно
n логн, это было, дальше у нас стало многошлен на
степени 8, потом мы многошлен на степени 8 делим на многошлен
на степени 4 с остатком, это примерно 8 лог 8, дальше
здесь 4 лог 4, да, 4 лог 4, здесь 2 лог 2.
Вот это вот мы уже такое делали, да, сумма m лог m по
степеням двойки, это то же самое, что последнее с
логами с точки зрения симптотики, поэтому вот такой спуск
это по времени то же самое, как просто взять по модулю
первого многочлена, вот, и при этом ответ у нас не
портится, да, потому что если я беру по модулю вот
этого, потом по модулю этого, потом по модулю этого,
потом по модулю этого, то это как если бы я изначально
взял по эту модулю.
Значит, ну наверное здесь нужно какое-то утверждение,
что если многочлена, то p по модулю, ну как бы процент
qr, процент r, это то же самое, что p, процент r, где процент
это остаток отделения.
Ну ровно это здесь и происходит, да, вот если r это то, что
в листике, qr это все по дороге, то есть я делю исходное
многочлен сначала на что-то больше, ну содержащее r,
вот оно, да, содержит r, умножь на что-то, потом на
что-то меньше и меньше, и в итоге делю на r с остатком,
ну от этого понятно, что остаток такой же, как если
бы я сразу поделил на r, да, сейчас, сейчас мы дойдем,
это чтобы время работы было хорошим, пока скажите
пожалуйста, это очевидно или как это доказывать,
очевидно, хорошо, я просто пока не сразу понимаю верно
это или нет, в смысле почему это верно, но это верно конечно,
я не понимаю почему, а, ну понятно, да, потому что
просто если я, скажем, рассмотрю все в кольце вычетов по
модулю r, да, то есть рассматривать все по модулю r, то вот это
вот, оно не меняет остатка по модулю r, потому что здесь
я как бы вычитал что-то обратное qr, поэтому остаток по модуле
r не поменялся, вот так можно сказать, ну хорошо, значит
мы поняли, что спуск вот такого вот вниз, он не меняет
остатка по модулю последнего листика, который мы идем,
тогда смотрите, алгоритм такой, мне же нужно найти
как бы остатки отделения исходного многочлена на
все вот эти листики, тогда алгоритм такой, сначала
я беру p по модулю вот этого многочлена, это работает
примерно за, ну давайте считать, что k не больше
чем n для удобства, давай считаем, что k не больше
чем n, можно и больше, ничего не поменяется, значит,
по скане больше чем n, тогда я вот здесь делю многочлен
степени n на многочлен степени k, значит это работает за
n лог n, дальше, у меня есть остаток p определение на
этот большой многочлен, чтобы получить остаток p
определение на это и на вот это, я могу делить уже
не p, а остаток, но при этом остаток имеет уже степень
не n, а k, уже меньшую степень, потому что я делил на многочлен
k-та степень, значит остаток имеет степень меньше к,
поэтому вот здесь вот, когда я беру p процент, Вот эта
штука, это занимает времени примерно кокол к, а потому
что я уже поделил, то есть я никак не п делю, а вот
это вот все делю с остатком на этом многочлен, и это
работает за кокол к, тоже самое я этот многочлен делю
с остатком вот на этот, это опять за кокол k работает.
значит, я знаю остаток определения p на вот это и вот на то
теперь этот остаток я делю на это и на вот это
это работает за k пополам лог k пополам потому, что опять степень хотя бы в два раза уменьшилась
поэтому здесь вот p процент эта штука работает за k пополам лог k пополам
здесь то же самое я беру p
по модулю этого многочлена это работает за k пополам лог k пополам
ну и так далее вот здесь и вот здесь
И, наконец, зная вот эти все остатки, я беру опять эту штуку по модулю последнего.
Это работает опять за k делить на 4, ло k на 4, потому что степень хотя бы два раза уменьшилась.
То есть я просто взял исходно многочлен по большому этому модулю,
по тому модулю, и ну просто спускаю, зная остаток, спускаю вниз по всё меньшим и меньшим многочленам.
Значит, тогда чему уровну время работы?
Ну вот, я его тут, собственно, писал, да? Сначала будет n log n.
Потом будет два раза k log k.
Потом четыре раза k пополам, ло k пополам.
Восемь раз k на 4, ло k на 4, ну и так далее.
Вот. И вот это вот всё можно тоже как-нибудь аккуратненько оценить.
Как же это оцениваю?
Ну давайте напишем, что тут написано, да?
Ну если k это степень двойки какая-нибудь, пусть k это два в степени какой-нибудь l,
ой, мамочки, то у меня написана сумма.
Вложи это на вот l.
А, ну да.
Значит, смотрите, здесь будет 2k. Вот, короче, вот эти множители будут одинаковые везде.
Это будет всегда 2k, то есть два в степени плюс один.
Множество логарифов.
Два вжигай.
Похоже на правду?
Вот. Ну вот такое мы уже когда-то делали.
А, ну не совсем.
Немножко другая, но тоже хорошая сумма.
Значит, когда мы складываем логарифмы от 2 в степенежи,
у меня логарифмы двойка исчезают.
Это просто сумма жишек.
Сумма первых l натуральных шисел ведёт себя как l квадратно-симпатически.
Поэтому здесь написано 2...
Значит, о, вот l квадрат.
О, вот л квадрат.
А вот л квадрат.
А вот л квадрат.
И здесь написано 2...
Значит, о, вот l квадрат на 2 в степени l.
Потому что здесь сумма первых l натуральных шисел.
Вот. И с точки зрения k это, я так понимаю,
k на лог квадрат k.
Правда?
Вот это k, l это лог, значит лог квадрат.
Вот.
Ну, собственно, тогда получается, что основное...
Ну, там одно деление занимает какой-то n лог n.
А дальше k лог k квадрат.
Лог квадрат k, в смысле.
Вот.
Мы всё сделали. Единственное, надо ещё сказать,
как мы эти многочлены находим.
Надо ещё аккуратно посчитать,
сколько уходит времени на то, чтобы все вот эти многочлены явно записать.
Потому что тут я их так написал, красиво, как произведение.
Ну, и, в самом деле, когда я беру, там, многочлен по модулю многочлена,
мне не нужно знать его как произведение.
Мне нужно знать его как набор коэффициентов.
Поэтому мне ещё нужно аккуратно посчитать,
сколько времени занимает вот эти вот подсчёты всех многочленов,
раскрытия всех скобок, когда я иду снизу вверх.
То есть, первый шаг моего алгоритма.
Я строю такое полнабинарное дерево
и во всех этих многочленах раскрываю скобки
с помощью обычного произведения многочленов.
Да, то есть, вот здесь написано, на самом деле,
произведение этих двух, нормальное такое раскрытое,
как набор коэффициентов.
строил это дерево, надо понять, за сколько это работает, а дальше я просто п, беру по модулю
корня и спускаю этот остаток вниз, не сниз, беря каждый раз остаток за там очередное кало к.
За сколько работает подсырение дерева? Ну, видимо, что-то такое же сейчас получится. Да,
очевидно, получится то же самое, потому что, смотрите, вот тут я когда писал какое-то
время работы, да, вот оно кало к, это я делил многочлен с остатком на многочлен степени к,
но понятно, что примерно столько же с точки зрения симптотики занимает время просто произведения
двух многочленов размеров вдвое меньше, потому что если я делил многочлен степени к на многочлен
степени к за кало к, ну, то это занимает столько же времени, как если бы я взял два многочлена
размера как пополам и перемножил с помощью fft. Поэтому вот эти вот суммы, которые я написал,
от кало к, кополам лока и так далее, вот эта вот сумма, а вот она. Это же время равно времени
просто построения дерева. То есть вот эта штука просто равна времени построения дерева.
То есть новых слагаемых у нас не появляется и итоговая симптотика,
н лог н плюс к лог квадрат к. Нет, к – это число точек, с которых мы ищем значение. Ну,
я тут предполагал, что они больше, чем n, если к больше, чем n, ну, давайте напишу так, давайте,
пусть. Значит, точно верна такая оценка. Если m – это максимум из n и k, тогда симптотика
точно от m лог квадрат m. Это прям железно. Просто взяли максимальное и м лог квадрат
посчитали. Вот теорема без у, что значение в точке – это значение остатка определений на
листья как раз. Просто теорема. Окей? Ну, еще раз смотрите, вот есть теорема, что значение
многочлена в точке в точности совпадает со значением остатка уделения многочлена на такой
вот 2-члене x – b. Это теорема без у, вот мы ее доказали здесь. Чтобы найти значение p в каких-то там
к точках, b1 и так далее, bk, мне по сути нужно взять исходный многочлен и поделить его с остатком на
всевозможные x – b и t. x – b1, x – b2 и так далее. Все остатки – это как раз значение, которое мы ищем
по теореме. Но вот ровно это мы и делаем в нашем дереве. Мы идем сверху вниз, берем p по модулю
текущего многочлена и в конце p по модулю x – b, это есть как раз значение в точке b. Профит.
Несколько я понимаю, более эффективного алгоритма пока неизвестно здесь. То есть мы умножаем и делим
за одно и то же время, да, за n лог n примерно. А здесь вот квадрат алгоритма возникает. Несколько
я понимаю, пока здесь не умеют скачивать этот лог квадрат, пока вот вроде m лог квадрат – самое
эффективное, что есть. Так, ну и вероятно последний на сегодня. Задача тоже такая весьма-весьма
естественная. У нас есть линейная рекуррента. Как бы я ее задал? Давайте пусть будут у меня
коэффициенты ее какие-нибудь. Не помню, ну ладно. Бог с ним. c0 и так далее, c, s-1 – какие-то числа.
Дальше a0 и так далее, a, s-1 тоже какие-то числа. A it для всех i больше равных s равны
линейной комбинации предыдущих s членов последовательности вот с такими коэффициентами.
Ну давайте я напишу t0 на a i-s, c1 на a i-s-1 и так далее, t, s-1 на a i-1. То есть эта сумма
по всем g от 0a до s-1, cgt a i- с плюс g, кажется. Да, похоже на правду. Вот, и с нас задана линейная
рекуррента. Вот ее начальный отрезок, начальные условия. Вот ее коэффициенты. И мы знаем, что каждый
каждый член выражается через s предыдущих вот такой линейной комбинации. Ну соответственно,
задача найти какое-то там аэнное для достаточно большого аэн, ну для аэн, которое дано.
Так, ну вопрос в зал. За сколько мы умеем такое решать? Вот представьте, что s какое-нибудь не
очень большое, там порядка тысячи, а аэн большое, там миллиарды. За сколько можно такое решать,
зная уже то, что мы знаем? Без FFT даже, про FFT можно не думать. Да, прекрасно. Потому что у нас
есть очень простое соотношение. Мы такое когда-то выписывали, что мы можем написать столбец
значений, столбец s последовательных значений, написать, что он получается из предыдущего,
домножения на не очень сложную матрицу. Ну здесь что-то будет видимо вот такое,
а здесь будут как раз вот те самые коэффициенты cs-1, cs-2 и так далее ценоривое. И поэтому,
чтобы посчитать там какое-то аэнное, нужно взять начальный столбец вот этих вот чисел,
возвести эту матрицу в степень что-то типа n-s, и это как раз работает за куб этой матрицы,
но алгорифм в степени, потому что произведение работает за куб, произведение матрицы работает
за куб. Но что еще на алгорифм, мы за бинардного зрения в степень. То есть,
такой подход даст нам асимптотику, давайте мы пишем teta s-куп луган.
Сейчас сделаем еще лучше.
Так, смотрите, давайте предположим, что в какой-то момент времени у нас нашлось выражение для
ak как линейная комбинация первых с численов нашей последовательности. Значит, сумма по g от 0 до
s-1 некая, пусть будет bg на aj. То есть, вот пусть откуда-то мы знаем линейное представление
какого там k-того члена последовательности через первое s. Хотим найти новые коэффициенты d0 и
так далее ds-1 такие, что они выражают 2 k-тый элемент нашей последовательности через те же самые
первые s-членов. Если мы такое научимся делать достаточно эффективно, то получается, что мы
смогли перейти от k к 2 k за какое-то быстрое время. А дальше та же самая техника бинардного
зрения в степень, что если нам нужно умножить на k на 2, то мы умножаем вот за это. Если нам нужно
от k прийти к k плюс 1, то там еще какая-то должна быть проверочка, тоже простая, чуть позже просмотрим.
Значит, вот самый интересный шаг вот такой. Зная откуда-то выражение ak через первые
s-членов, давайте попробуем найти выражение для 2k через те же самые первые s-членов.
Ну, мы точно можем написать вот такое. Значит, откуда? Ну, потому что если ak выражается
через первые s, то 2k выражается ровно таким же образом через члены, начиная с k. Это верно,
если k у нас хотя бы с. То есть, если k как-то выражается через первые, давайте нарисую,
вот k как-то выражается через 0 и так далее с-1. Тогда 2k выражается ровно тем же образом через
вот эти вот k и так далее k плюс с-1. Ну, просто потому что зависимость вот этого от всех предыдущих
такая же, как вот этого от вот этих предыдущих. Там просто одно и то же правило навешивается,
вон оно там какая-то сумма насчитывается. Поэтому понятно, что это как бы просто сдвиг нашей
последовательности на k куда-то, и поэтому у нас выполняется такое соотношение. Дальше я могу
написать то же самое для g плюс k. А g плюс k, это сумма давайте по i, на 0 до s-1, b и t, на а и плюс g.
Ну, то же самое, вот это вот написал для g плюс k. Опять, если k выражается как-то через
первые s, то g плюс k также выражается через элементы, начиная с g, до g плюс 8-1. Поэтому
вот сюда я могу подставить, да, вот это вот сюда могу подставить, и получится, что у меня адвокаты,
это сумма по всем g, 0 до s-1, по всем i, 0 до s-1, b и t, b g t, на а и плюс g t. Вот, а это страшно
похоже на произведение многочленов. Да, вот прям сумма по i, сумма по g, произведение коэффициентов,
на а с индексом сумма индексов, сумма и плюс g. Вот, поэтому, если я нарешу вот такой вот многочлен,
возведу его в квадрат. Ну, давайте, давайте он будет е у меня. Значит, b от x умножить на b
от x с помощью fft за s лог s. Ну, значит, я могу взять все это многочлены в квадрат за s лог s.
Это будет ровно вот это. На, если его коэффициенты какие-то ешки, то здесь написано просто сумма
по всем i от 0 до 2 s-2, e и t, a и t. Просто потому, что коэффициент при каком-то, ну, давайте,
при вот этом вот a и t равен всевозможным, ну, значит, суммой всевозможных произведений b
с разными индексами, сумма которых равна вот этому. А это ровно, как если бы мы просто
b взяли в квадрат и взяли оттуда нужный коэффициент. Понятно? Вот, это почти то, что нужно. А именно,
мы что хотели? Мы хотели выразить двокатый член через первые s, а взяли и выразили через первые
2s. То есть, здесь выражение, зависящее от а0 и так далее, а2s-2. Нам нужно как-то это преобразовать
сумму d и t, a и t для i от 0 до 1. Так, давайте думать.
То есть, мне нужно в каком-то смысле выразить все вот эти вот ашки с номерами 2s-2, 2s-3 и так далее
вплоть до s через первые s, через нулевой и так далее с минус первой. Значит, как это сделать?
На самом деле, я утверждаю, что достаточно рассмотреть вот такой многочлен. Так, надо понять,
правильно ли я написал. Ну, сейчас давайте какой-нибудь нарисую. Такой попробуем.
Просто-просто. Это, по сути, характеристический многочлен нашей рекурренты.
Видимо, не совсем. Да, вот здесь у меня, значит, тут, ну короче, короче, если что, я могу здесь вот
массив c развернуть, чтобы, если надо, вот это вот старше, старше было вот здесь. Ну, короче,
посмотрим. Возможно, не надо, возможно, надо. Я рассматриваю такой многочлен и я утверждаю,
что если рассматривать вот это опять вновь как многочлен e, как набор коэффициентов e, то мне
нужно будет просто взять его по модулю p, и это будет нужное мне представление.
Что такое f? Это e у меня такое.
E. Там минусы именно, да. Ну, это характеристический многочлен.
Значит, я утверждаю, что чтобы получить набор вот этих вот коэффициентов, мне нужно взять e по
модулю p, и это будет то, что нужно. Ну, по крайней мере, остаток действительно будет
иметь степень ровная с минус 1, ну не большим с минус 1, да, и вот те коэффициенты как раз там
будут лежать. Так, ну давайте поймем, почему это верно. На примере какого-нибудь, ну давайте
рассмотрим просто e, e, значит, давайте вот здесь вот есть слагаемая e it на x, еs на x в st. Давайте
поймем, что происходит при взятии его по модулю p от x. Значит, еs на x в st при взятии по вот
этому модулю, ну давайте я множитель отдельно оставлю, возьму x в st по модулю p от x. Чему это
равно? Ну, понятно, что неполно частной будет единица, а остаток будет как раз c с минус 1,
x в st минус 1, плюс c с минус 2, x в st минус 2 и так далее, c нулевое. Согласны? Просто если x в st
поделюсь с остатком, то вот это ровно будет остатком. Да, неполно частная единица это остаток.
То есть получается, смотрите, мы взяли и теперь я еще на еs это все умножу.
Просто еs здесь выпишу.
То есть при взятии еs и x в st по модулю p у нас как раз пропадает зависимость от x в st и
появляется зависимость через x в st минус 1 и так далее, x и тогда ну как бы вплоть до
x в нулевой степени. Значит, сейчас, верно ли, что она правильная? Мне хочется понять, что еs,
а st это еs на c с минус 1, а с минус 1, плюс и так далее, плюс c ноль. Ну, это верно, вроде,
просто по нашему определению. Вот если я поставлю там вместо и s, то у меня получится ровно вот это,
еще умножено нужный коэффициент. Поэтому, действительно, взятие вот этого манома по модулю
p от x и замена, да, как бы x в степени какой-то на а с тем же индексом, это в точности прокидывание
еs в более младшие слагаемые, в более младшие члены нашей прогрессии, нашей последовательности.
Ну и, собственно, тоже самое работает дальше для всех остальных. Если возьму x в s плюс 1 по
модулю p от x, то это что? То это вот это вот, еще умножить на x и взять еще раз по модулю.
Ну, сейчас. Давайте одну строчку напишу и на этом закончим. Вот это вот.
Дальше я раскрываю, вот эти остаются, и будет здесь опять x в s, да, то есть здесь останется одно
x в s, которое надо будет брать по модулю, а x в s по модулю p от x как раз раскрывается так как нам
нужно. Поэтому все вот то, что я написал, действительно верно, и мне нужно просто этот многочлен взять,
взять его остаток по модулю p от x, и тем самым все вот эти вот более старшие члены прокинем в младшие.
Да, у нас появится зависимость более старших членов от более младших. Вот, ну и итоговая симптотика
будет s лог s на лог n, потому что s лог s это время, необходимое на вот это вот все промежуточное,
да, мне, значит, я что сделал? Я возделал многочлен в квадрат и взял его по модулю p. Все это работает
за s лог s, потому что у меня были по дороге многочлены степени s, и это нужно сделать примерно лог n раз,
потому что так работает бинарное разделение в степень. Мне нужно там единицу добить до n,
умея переходить там от как 2k, но еще нужно научиться переходить от как k плюс 1, но это
тривиально, там нужно просто, там нужно один раз сделать вот это вот прокидывание, это вообще
можно сделать до вот s. Вот, ну время вышло, поэтому на этом все. Спасибо.
