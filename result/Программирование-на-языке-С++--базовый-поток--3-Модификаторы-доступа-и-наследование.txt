Добрый день, давайте начнем. Следующий пункт нашей программы — это наследование.
Наследование — это одна из трех-четырех концепций объектно-оритерированного
программирования, с которым мы с вами начали знакомиться в прошлом семестре.
Напомню, что объектно-оритерированное программирование — это подход
программирования, в котором мы, соответственно, логику нашей программы
выделяем в отдельные классы, структуры, объекты, их взаимодействия между собой.
И мы с вами поговорили о том, что существуют четыре основные концепции
объектно-оритерированного программирования — это абстракция, инкапсуляция, полиморфизм
и наследование. То есть первые три вещи мы с вами так или иначе поговорили.
В некотором смысле мы к ним еще вернемся.
Сегодня и на следующих занятиях погрузимся в то, что такое наследование,
как эта штука позволяет нам писать, что она позволяет нам сделать,
как она упрощает написание кода и так далее.
В общем-то, суть наследования довольно-таки проста.
Извучается она в том, что вы написали какие-то свои собственные классы,
какие-то свои собственные типы, и вполне себе возможно, что в процессе проектирования ваших программ
у вас возникла необходимость написать класс с похожим функционалом.
Что значит с похожим функционалом?
Либо его функционал полностью или частично совпадает с тем классом, который вы уже когда-либо писали.
Например, интерфейс класса, который вы пишете,
совпадает с интерфейсом того класса, который вы уже когда-либо написали.
Например, у нас есть класс стека и есть класс очереди.
Понятно дело, что стек позволяет нам добавить элемент в конец, удалить элемент с конца.
Очередь позволяет сделать то же самое.
По сути, в некотором смысле можно считать, что очередь это стек,
но просто с каким-то дополнительным функционалом,
в частности с возможностью удалить элемент из начала.
Ну и собственно так.
Оно следовательно является одним из основных понятий, на которых держится ООП.
Другой пример.
Представьте, что вы проектируете какую-то игру, какую-то программу,
в которой у нас есть набор персонажей.
В данном примере есть набор персонажей, типа лучник и есть там боец ближнего боя.
У них есть общие характеристики.
У всех игровых персонажей есть какие-то общие характеристики.
Например, у них есть показатели здоровья, показатели силы, показатели опыта и так далее.
И в целом, как бы, все персонажи участ are отличают только тем,
какие действия, точнее, какие специфичные действия они могут делать.
Например, каждый персонаж может выполнять действия, например, лечение.
То есть, в какое-то время он там может подождать
и вылечить, восстановить свои чки с дороги.
Либо же он может, например, вступить в ближний бой.
Или если мы говорим о лучнике, он может вступить в дальний бой.
То есть, например, боец ближнего боя в дальний бой вступить не может,
лучник не может вступить в ближний бой.
Вот, соответственно, у них есть какие-то общие черты, и при этом есть какие-то отличия, которые делают, грубо говоря, одного персонажа, именно персонажа этого типа.
И, соответственно, я думаю, вы понимаете, что если мы пишем какую-то большую программу, допустим, если останемся в том же сеттинге игры, то, понятное дело, в процессе возникнет необходимость вводить новых персонажей.
Либо как-то развивать игру, вводить новых персонажей, или как-то персонажей этих развивать, в общем, добавлять какой-то новый функционал, и так далее.
И я думаю, вы понимаете, что довольно-таки накладно для каждого нового вводимого персонажа прописывать всю ту же самую логику, что вы прописывали для предыдущих персонажей.
Потому что, как я уже сказал, у нас, в принципе, программа может развиваться, то есть наша вымышленная игра, она может как-то развиваться, то есть мы можем хотеть добавлять какие-то общие черты для всех персонажей,
можем уметь добавлять, можем захотеть добавить какие-то новые характеристики для персонажей.
И каждый раз, когда вы будете добавлять нового персонажа, вам нужно им держать в голове то, что вот у вас у всех персонажей есть такой набор характеристик,
плюс у каждого персонажа должны быть реализованы вот такие вот свойства, и, соответственно, этот персонаж отличается как-то другими штуками.
И если вы хотите ввести какой-то новый акционал, вам придется во всех классах этот функционал внести.
Ну, в общем, проблема. Первая проблема.
Вторая проблема, на самом деле, еще заключается в том, что, вообще говоря, если мы посмотрим на такой вот мымышленный код, то есть у нас есть 4 класса, Арчер, Мили, Кавалерия, Импостер и так далее.
Вот с точки зрения кода на C++ все эти классы никак не взаимосвязаны друг с другом.
Грубо говоря, вот у вас есть Лучник, у вас есть Кавалерия.
И, собственно, как минимум вы не можете их хранить в одном массиве.
Вообще говоря, это логично. Если вдруг игрок хочет создать свою армию, он, соответственно, добавляет Лучников, Кавалерию и так далее.
И вполне себе логично это все хранить в одном массиве.
Но в C++ мы знаем, что в массиве может храниться только элементы одного типа.
А это все 4 разных типа.
То есть с логической точки зрения мы с вами понимаем, что, в принципе, они реализуют один тот же концепт.
Они реализуют одну и ту же сущность, как игровой персонаж.
Но при этом они имеют разные типы, поэтому мы не можем их хранить даже в одном контейнере.
Беда.
И в этом нам тоже поможет Наследование.
Давайте обсудим как.
Смотрите, как я уже сказал, Наследование это свойство системы, свойство языка программирования,
которое позволяет создавать новые типы на основе существующих.
Значит, решение с помощью Наследования заключается в следующем.
Давайте я заведу специальный класс, такой общий класс, который назову класс-персонаж.
Вот класс Hero.
И вот в этот класс персонажа заведу все общие свойства, все общие характеристики,
которыми обладают все персонажи в моей игре.
Например, подсказатели силы, здоровье, опыта вынесу в структуру этого персонажа,
плюс какие-то общие методы, какие-то общие свойства, какие-то общие действия, которые могут делать эти персонажи,
тоже вынесу в этот класс.
Этот класс как-то реализую.
А дальше, собственно, уже понимая, что у меня есть некоторый общий концепт персонажа,
я возьму и всех конкретных персонажей, там лучник, кавалерия, ближний бой и так далее,
унаследую от этого общего класса персонажа.
В частности, возьму класс Archer, унаследую его от Hero.
Просим, если мы чуть подробнее потом поговорим.
Но, в общем, чтобы унаследовать один класс от другого, мы просто ставим двоеточие
и после этого пишем имя класса.
То есть строк Archer, двоеточие, Hero.
Ну, что означает Public, мы через 5 минут поговорим.
А что означает Наследование?
Наследование, собственно, говорит то, что все те свойства,
которые обладает клад, который написан справа от двоеточия,
все те же самые свойства должны быть и у моего класса тоже.
И уже понимая это, держа это в голове, я просто-напросто внутри класса Archer
прописываю дополнительные свойства, дополнительные характеристики,
которым обладает мой новый класс.
Окей?
То есть, по сути, что я тут говорю?
Я говорю, что лучник полностью обладает чёртовым персонажем
и плюс кое-чем ещё.
И вот это вот кое-что ещё я прописываю внутри фигурных скобок.
Окей?
И вот в этом контексте говорит следующее, что Hero, то есть, персонаж – это базовый класс,
Archer – это производный класс, или класс Наследник.
То есть, получается такая вот и рамка.
Есть базовые классы, а эти производные, это не классы, то есть, класс Наследники.
Более того, эта связь уже видна языку C++,
и язык C++ может уже на этой основе делать какие-то выводы.
То есть, если раньше я написал класс лучника,
написал класс персонажа ближнего боя,
и, соответственно, с точки зрения C+, то есть, это были два разных класса,
то теперь, зная, например, о том, что лучник и боец ближнего боя
наследны от того класса персонаж,
компилятор может позволять делать какие-то вещи, которые присущи обоям этим типам.
Ну, в частности, например, мы сможем создать массив,
в котором можно сохранить объекты обоих этих типов.
Но об этом мы ещё поговорим позже.
В целом, концепция понятна. В целом, для чего это нужно?
Окей.
Хорошо.
Да, ну, собственно, я на предыдущем слайде беру пример,
как выглядит синтез наследования.
Ну и, собственно, вот, как это работает.
То есть, теперь я могу создать объект типа персонаж,
объект типа лучника, и, соответственно, и у персонажа, и у лучника
будет такая характеристь, как HP, то есть, здоровье,
будут такие же методы, как heal.
Но при этом у лучника будет дополнительный метод shoot,
то есть, будет метод выстрелить, которого нет у персонажа.
У лучника это полностью, ну, является полной копией персонажа,
то есть, полностью совпадает по свойствам с персонажем,
и плюс ещё обладает какими-то дополнительными методами.
Ну, в частности, вот, обладает методом shoot,
которым обычный персонаж не обладает.
Окей?
Так.
Теперь давайте поговорим про вот эти вот самые,
про вот это вот самое слово public, которое пишется после двоеточия,
вообще говоря, как ведут себя модификаторы доступа при наследовании.
Значит, смотрите, ну, мы с вами в прошлом семестре
говорили про два модификатора доступа.
Это public и private, да, то есть, с ними всё просто.
Public – это секция, которая позволяет, ну, вообще,
всем, всему коду в нашей программе обращаться к этим полям методам.
Private секция разрешает обращаться к этим полям методам
только, ну, собственно, изнутри самого класса, да,
то есть, только объектам этого класса, только, в общем, да,
только самому этому классу, ну, и плюс друзьям этого класса.
В случае наследования всё остаётся то же самое.
Вот. Если внутри класса написан private,
то никому, кроме этого класса,
обращаться к этим полям и методам нельзя.
Если public, то всем подряд можно обращаться к этим полям и методам.
Вот. Ну и, соответственно, то же самое распространяется
и на нас... кстати, вот это вот разграничение касается наследников.
То есть, если у меня, смотрите, есть класс archer,
ну, структура archer, и она унаследована от hero,
то это означает, что archer не будет иметь доступ
к приватной секции hero.
Ну, вот пример. Вот у меня есть структура hero,
которая обладает публичным методом heal
и приватным методом updateHP.
Вот. И есть archer, который реализует метод rest.
Вот к методу heal archer обращаться может.
А вот к методу updateHP archer обращаться не может.
То есть, возникает тут довольно странная ситуация,
ну, с одной стороны странная, в общем,
заключается она в следующем, что
внутри класса archer есть метод updateHP.
Но самому archer этот метод недоступен.
Вот. То есть, метод updateHP может вызывать только hero.
Но при этом сам archer вызывать updateHP не может.
Окей? То есть, private на самом деле распространяется
и на наследников тоже.
То есть, если в моем классе, например, вот в классе hero
есть приватный метод updateHP,
то его наследники к этому методу тоже не будут иметь доступ.
Понятно?
То есть, private – это прям вот жесткое закрытие.
То есть, вот к этому методу могут обращаться только объекты этого класса.
Наследники обращаться не могут.
Пример понятен?
Окей.
Ну, собственно, вот.
Теперь в контексте наследования у слов private и public
появляется еще один дополнительный смысл.
Значит, private и public могут обучать не только модификатор доступа,
но и режим наследования.
Вот. Что такое режим наследования?
Значит, режим наследования пишется как раз таки вот после…
как раз таки после двоеточия, да, то есть
структ archer – public hero.
Что означает слово public перемещено сюда,
или что означает слово private?
Что означает слово private помещенное туда?
Смотрите.
Private и public наследования отличаются тем,
знает ли внешний код,
о том, унаследован класс или нет.
Смотрите.
То есть, на самом деле, эта аналогия довольно-таки прямая
с модификаторами доступа.
То есть, про private и public мы с вами говорили так,
что если что-то помещено в секцию private,
то, по сути, никто, никакой внешний код,
не имеет права знать о том, что там находится.
Ну, что там находится какой-то метод, что там находится какой-то поле и так далее.
Если там есть модификатор доступа public,
то, соответственно, все имеют право знать,
что у меня там есть такой метод,
и все имеют право к нему обращаться.
Вот с наследованием, по сути, то же самое.
Вот если я пишу archer.publichero,
это означает, что весь внешний код
знает о том,
что archer унаследован от hero.
А если весь внешний код знает о том,
что archer унаследован от hero,
и может использовать эту информацию,
то это значит, что весь внешний код
имеет право обращаться
к полям и методам hero
через объекты archer.
Вот у меня есть стул.
Я говорю, что он там унаследован
от концепции мебель.
Если я знаю, что стул унаследован
от концепции мебель, то, соответственно,
я могу использовать эту информацию.
Например, я могу понять, что раз это мебель,
я могу пойти в мебельную магазину
и купить стул там.
Если бы стул реализовывал приватное наследование,
то стул бы являлся мебелью,
но при этом я бы об этом не знал.
Тогда бы я не имел права
пойти в мебельную магазину и купить стул.
Странный пример.
Вот история.
Приватное наследование
то, что этот класс действительно
унаследован от другого класса,
но при этом никто другой,
никакой внешний код не имеет права
использовать эту информацию.
Приватное наследование
это наследование, при котором
я унаследую только для своих внутренних нужд,
а любой внешний код не имеет права
право использовать информацию о том, что я от кого-то унаследован, окей? Да, да, это вот
вообще другая вещь, да, то есть даже если у hero есть какие-то приватные поля, даже
несмотря на то, что написано паблик, archer не сможет использовать приватные поля hero, то есть если
что-то стало приватным, то это приватное останется навсегда. Открыть уровень доступа нельзя будет.
Давайте посмотрим на конкретные примеры. Вот у меня есть класс A, публичное поле x, и есть
приватный метод f. Есть структура B, которая публичным образом унаследована от A, вот,
и в ней есть метод h. И давайте посмотрим на этот метод h, что в нем происходит. В нем я x
предстояю значение 0 и вызываю метод f. Вопрос, какие из этих строчек я смогу вызвать? Смогу ли
я сделать x равной 0? Почему? Ну, тут, кажется, все просто, потому что поле x является публичным,
я к нему обратиться могу. Да, окей, здорово. А могу ли я вызвать метод f? Почему? У меня же публичное
наследование. Да, смотрите, что тут мы делаем? Во-первых, мы должны проверить две вещи. Во-первых,
есть ли метод f в структуре B? Ответ да, нет. Можно ли обратиться к тому, к той или иной
вещи? Мы задаем два вопроса. Первый вопрос, вообще говоря, этот метод или поле есть в моем классе или
нет? Вот для f ответ положительный или отрицательный? Есть ли метод f в моей структуре B? И ответ да,
есть. Почему? Потому что B унаследовано от A, не важно каким образом. То есть факт состоит в том,
что B унаследовано от A. Если B унаследовано от A, значит в B есть все те же самые свойства,
что и в A. Вот, и действительно в классе B есть метод f. А теперь другой вопрос. Имеет ли
право класс B обращаться к своему методу f? И ответ нет. Да, почему? Потому что f пришел в класс B
через класс A, а класс A запретил использовать свой метод f. Вот, поэтому метод f вызвать будет нельзя.
То есть он как бы есть, но к нему доступа нет. Окей, другой пример. Та же самая структура C,
ну в смысле по виду, значит у нее тоже есть метод h, у нее тоже x равнули f, но при этом
унаследование приватное. Изменится ли что-то в этом контексте внутри структуры C или нет?
Так, да, нет. Нет, почему нет? Да, потому что вот это вот слово, вот это слово влияет только на внешний
код. Смотрите, структура C же знает, что она сама унаследована от A. Но раз она знает, что она унаследована
от A, значит она может спокойно обращаться и к x, и к f. Единственное, тут все окей, потому что x
не является публичным, то есть класс A разрешает пользоваться x всем, ну кто может это делать,
а к методу f обратиться нельзя, потому что A запретил использовать f вообще кому бы то ни было,
кроме себя. Вот, модификатор наследования, который пишется после D, он на самом деле влияет только
на внешний код. То есть на код внутри структуры B и структуры C он никак не влияет. То есть если
класс унаследовал какой-то другой класс, то он может спокойно обращаться ко всем публичным полям
того класса. Вот. Окей, ну смотрите, тут два вопроса. Первый вопрос, типа внешний код,
он действительно, ну то есть можем ли мы считать, что внешний код это видит, и второй вопрос, какая будет
ошибка. Ну вообще, с точки зрения программирования, лучше считать, что приватность означает, что мы не имеем
права знать об этом. То есть это как бы, не знаю, вашего класса могут быть приватные поля, и если вы
что-то поместили в приватную секцию, скорее всего, вы имели в виду, что это какая-то деталь реализации,
которую знать не стоит. Которую можно не знать. Вот тоже самое, кстати, приватная реализация. Это означает, что вот это какая-то
деталь реализации, и вот внешнему коду об этом знать не нужно, об этом знать не обязательно. Вот. Другой вопрос,
что ошибка компиляции, скорее всего, будет осмысленная. То есть ошибка компиляции, скорее всего, она не скажет вам,
что такого метода нет, или такого поля нет. Ошибка компиляции покажет, что просто нет доступа. Ну то же
самое, как если бы вы обращались к приватному полю и к приватному методу. Вот. Окей. Теперь давайте
посмотрим, ну представим себе, что вот у меня есть какая-то функция main, вот. И внутри функции main
написан следующий код. Я создаю объект a, и обращаюсь к полю x и к полю f. Вопрос, получится мне это сделать или нет?
A.x. Получится обратиться? Да, ну a.x всё получится. Почему? Потому что x это публичное поле структуры a. А к методу f?
Нет. Ну тут всё просто, тут вообще никого наследования нет, потому что есть класс a, и у него есть просто
публичное поле x, и есть собственный приватный метод f, к которому обращаться нельзя. Окей. Ну я думаю, тут
сразу везде понятно, что к методу f, не тут, не тут, обратиться будет нельзя, потому что f является приватным,
а f-тость никак не снимается, к сожалению. Вот. Теперь давайте посмотрим на объект класса b, и объект класса c,
обращение к x. Вот b.x равно 11, скомпилируется это или нет? Да, смотрите, почему? Потому что мы проверяем,
есть ли в классе b поле x. Ответ да, почему? Потому что оно пришло из класса a. Теперь проверяем,
можно ли к x обратиться, ну можно ли обратиться к x. Смотрите, b унаследовано от a публично, это значит,
что b всем рассказывает, что он наследован от a. Вот я там являюсь наследником a, и все здорово. Вот.
Поэтому, когда я обращаюсь к b.x, компилятор говорит, ну окей там, мы имеем право знать о том,
что мы унаследованы от a, и при этом x является публичным полем, поэтому к x мы тоже можем обратиться.
Вот. А в случае c.x? c.x нет, да, почему? Потому что, несмотря на то, что x содержится, действительно,
в классе c действительно x содержится, но при этом класс a, точнее класс c, наследует класс a
приватно. То есть, тут он не сообщает всем, что он наследник, он как бы такой бастар,
говорит, вот я лучше скрою о том, что я от кого-то унаследован. То есть, внешний код не имеет
права об этом знать. Ну и тут компилятор ровно это нам сообщит. То есть, как бы скажет, ну как бы да,
в классе c есть x, но вообще ты не должен был об этом знать, потому что x пришел из класса a,
который унаследован приватно. Вот. То есть, как бы к полям и методам своего базового класса ты
не имеешь права обращаться. Ну, точнее, внешний код не имеет права обращаться. Окей? Есть еще вопросы? Да.
Ну, в некотором смысле, да. Мы не можем в класс наследник добавить поле, который... Нет, почему? Нет,
в класс наследник можно добавить все что угодно, и поля, и методы. Вот. Там не совсем все так просто,
то есть там, в общем, мы до этого дойдем. Ну, короче говоря, если у вас есть класс a, и класс b у наследован от a,
то вы не можете создать, короче, то вы можете создать массив из объектов класса a. И туда
можете помещать как объект класса a, так и класса b. Вот. То есть, грубо говоря, вы урезаете все доны
меньшего класса. Ну, мы до этого дойдем еще. Да. Вот. В общем, да, нам будет на слайдах, но по умолчанию,
если не писать через двоеточки никакого слова, то по умолчанию, для структуры public, для классов
private. Ну, ровно такое же отличие, как и для модификаторов доступа. Окей. Значит, наследование
обводит еще один модификатор доступа, ну, еще один уровень наследования, это protected. В прошлом
семестре мы на самом деле так с курсом упоминали, и в прошлом семестре я говорил, что protected это
на самом деле то же самое, что и private. И вообще говоря, если мы не знаем про наследование, то это
действительно так и есть. Protected работает точно так же, как и private. Вот. Единственное отличие
protected от private заключается в том, что protected дополнительно разрешает получать доступ к полям и
методам для наследников. Вот. То есть, если private запрещает вообще всем, то protected запрещает
внешнему коду, но разрешает наследникам. Окей. То есть, protected работает public, как public для
наследников, но при этом как private для внешнего кода, то есть, для ненаследников. Окей. Ну, то есть,
какой тут пример? Вот есть структура A, в которой есть protected поле X и protected поле F. Я структуру B
наследую от A, и при этом B имеет право обращаться к полям X и F. Почему? Потому что X и F являются
protected полями A. Вот. И так как B наследует от A, то A разрешает B использовать свои поля X и F. Вот.
Но при этом внешний код к X и F не имеет права обращаться. То есть, если я пишу A.X или A.F
во внешнем коде, ну, тут третья строчка снизу, то это не скомпилируется. И плюс последняя строчка B.X
и B.F тоже не скомпилируется. Да, почему? Потому что protected, еще раз повторю, protected разрешает
обращаться к полям и методам только наследникам. Внешнему коду по-прежнему запрещено. Окей. То есть,
к X и F я могу обратиться только изнутри A или только изнутри наследника A, то есть B. Понятно?
Из main я добраться до X и F никак не смогу. Вот. Ну и модификатор доступа, ну, точнее,
модификатор наследования protected также может быть написан и после двоеточия при указании типа
наследования. Вот. И означает это, ну, по сути, то же самое, что модификатор доступа. То есть об этом
наследовании, о том, что B наследует от A, имеет право знать только, ну, сам класс B и все наследники
класса B. Вот. То есть, внешний код не имеет права знать о том, что B как-то унаследован от A,
но если кто-то унаследуется от B, то тот имеет право использовать информацию о том, что B унаследован
от A. Ну, вот, например, у меня есть класс A, у меня есть класс B, который protected образом унаследован
от A, и есть структура C, которая унаследована от B. При этом C имеет право обращаться к X и F.
Почему? Потому что A, потому что B является наследником A, то есть в B содержится все те
же самые поля, что и в A. Потом C унаследовано от B, то есть в C содержится все те же поля,
что и B. Вот. То есть поле X и метод F в структуре C содержится. И при этом я могу к нему обращаться,
почему? Потому что B protected образом унаследованно от A, то есть C знает о том, что B унаследовано от A.
А раз C знает о том, ну, грубо говоря, знает о том, что B унаследовано от A, он может спокойно к
нему обращаться. Вот. Но при этом с внешнего кода, вот, если возьму последнюю строчку, да, создам
объект B и обращусь к B.X и B.F, то тут будет ошибка эмпиляции. Почему? Потому что B protected
образом унаследовано от A, а раз он protected образом унаследовано от A, то значит, что внешний код
не имеет права знать о том, что B унаследовано от A. Понятно? Ну и давайте еще посмотрим, например,
вот у меня есть структура A, в нем есть публичное поле X, есть приватный метод F, есть protected
метод G. Вот. У меня есть структура B, которая protected образом унаследовано от A. Вот, есть X равный нулю, F и G.
Каким из этих трех строчек я могу обратиться? То есть какие из этих трех строчек не приведут к ошибке эмпиляции?
Так, ну, X, с X все будет нормально, да, почему? Потому что B унаследовано от A, и при этом X являются публичным
полем. Окей, к F я могу обратиться? Нет, F приватный, к F вообще никогда нельзя обращаться. Вот вообще
никогда. То есть тут сразу везде, где F поставить минус. Вот. А могу ли я внутри B обратиться к G? Да,
потому что, во-первых, B знает о том, что унаследовано от A, так как B унаследуется от A, естественно,
знает кто его предок. Плюс сама структура A разрешила своим наследником обращаться к G,
да, потому что это protected, поэтому к G обращаться внутри наследников можно. Окей, так, теперь на
правую сторону, допустим, снова у нас есть какая-то функция main, и я обращаюсь A.G. Могу я это сделать или нет?
Нет, для внешнего кода protected работает как private, да, поэтому к G обратиться я не могу. Дальше,
ну, B.X, а, да, могу ли обратиться B.X? Почему нет? Да, потому что B protected образом наследования,
да, protected наследования означает, что никто, кроме моих наследников, не имеет права знать о том, что я унаследован
от A. Функция main, естественно, не является наследником B, поэтому, вообще говоря, мы не имеем права
использовать информацию о том, что мы как-то унаследованы от A, поэтому к X мы обратиться не
можем. К G, естественно, по тем же самым причинам мы тоже обратиться не можем. Вот. Можем либо обратиться к
A.X? Да, A является непосредственным методом B, да, он находится в его публичной области, поэтому к A.X
мы можем спокойно обратиться. Вот. Теперь то же самое для A.C. Могу ли обратиться C.X? Нет, да,
C.X обратиться не можем, почему? Потому что, ну, смотрите, мы проверяем, да, где находится X? Ну, в самом
C.X нет. Поднимаемся выше, то есть можем ли я подняться выше? Да, то есть C всем сообщает о том, что у наследован
от B, поэтому можно подняться в B. Смотрим в B. Есть непосредственно в B поле X? Нет, поле X в B нет.
Можем подняться у наследника, но у наследника подняться не можем, почему? Потому что B запретил
внешнему коду знать о том, что наследован от A, поэтому как бы внутри класса C поле X нет, ну, в смысле,
для внешнего кода поле X не существует. Вот. Ну, по аналогичным причинам нет C.G, а C.H? Да, ну,
снова продолжаем логику, да, внутри структуры C метода H нет, поднимаемся в наследника, это сделать
мы можем, потому что наследование публичное, вот. Ну и, собственно, в структуре B мы как раз находим
нужный метод H, поэтому тут все окей. Так, есть ли вопросы? Да. Ну, нет, с друзьями все,
ну, с друзьями все остается так же, да, то есть, если какой-то класс объявляет какую-то функцию
с твоим другом, то эта функция теперь получает полный доступ, там, ко всем приватным,
protected полям. Вот, смотрите, да, хороший вопрос. Смотрите, допустим, у нас структура A сказала
следующее, что у меня int main это друг. Вот если структура A объявляет, если структура A объявляет
функцию своим другом, то это значит, что структура A разрешает обращаться к своим private и protected
полям. Но, но, при этом все вот это по-прежнему останется ошибкой компиляции. Почему? Потому что
несмотря на то, что A разрешает доступ к своим полям и методам, B запрещает знать о том, что кто-то
у него односледован. Ну, то есть, ну, не знаю, представьте себе, что, не знаю, вот у вас есть родители,
если они такие очень гостеприимные, они там приглашают, они хотят пригласить всех ваших друзей,
но вы своим друзьям не рассказываете, что, вот, как бы, где вы живете, где находятся ваши родители. Вот,
поэтому, естественно, ваши друзья не могут там прийти к вам в дом. Ну, такая вот аналогия. Вот, то есть,
тут проблема именно в B, да, то есть, когда я обращаюсь в B.X, как бы, нет, давайте тут, я обращаюсь, вот,
я обращаюсь в B.F, обращаюсь в B.F, и, как бы, класс A, он как бы рад, ну, как бы рад, он вызвать метод F, да,
потому что Main его друг, но B сказал нет, я, как бы, протектор образом наследуюсь от A, то есть,
я сам, вот, сам B, никому не расскажу о том, что я наследовал от A, кроме своих наследников, вот, и,
поэтому, B, Main не рассказывает о том, что наследовал от A, поэтому, к доступу к функции F и функции G
я не получу. Понятно? Да. Нет, давайте тут, правильно я понял вопрос, что, вот,
допустим, у меня есть структура A, структура A, у меня есть какой-то, допустим, приватное поле, да, private index, и вот у меня есть
структура, которая наследована от A, и она объявляет там кого-то своим другом, friend, допустим, avoid F, и вот у меня есть
это вот самое avoid F, я создаю B и обращаюсь в B.exe. Вот это вопрос. Ну, давайте подумаем, кто считает, что тут будет ошибка
компиляции? Смотрите, B в структуре B объявила функцию F своим другом, то есть, как бы, B говорит, что я могу, что я позволяю всем
обращаться к моим приватным полям, методам и так далее. Вот, например, внутри структуры A, X приватен. Могу ли я тут с помощью B
обратиться к exe? Кто считает, что можем? Кто считает, что не можем? Поздравляю, вы победили. Да, обратиться тут мы не можем. Почему?
Складить это было бы довольно странно, если бы, ну, как его назвать, не знаю, какой-то сопляк наследник разрешал бы
обращаться к приватным полям своего предка. Ну, как бы, структура A говорит, нет, нельзя к exe обращаться, а структура B такая
приходит, наследник тогда говорит, да нет, можно, всем можно. Ну, так же не должно работать. То есть, как бы, сама структура A
запретила X. Если сама структура A запретила обратиться к exe, то как бы сама структура A должна разрешать им пользоваться.
То есть, как бы, не может прийти B и сказать, что нет, на самом деле всем там можно пользоваться. Вот. То есть, вот это вот слово
friend относится только к тому, что в структуре B. То есть, если бы B объявил какие-то поля, то тогда бы мог обратиться.
Или если я тут написал там слово private, то тогда бы friend f знал бы о том, что я унаследован от A. Вот. Но при этом на доступ
на доступы в наследниках это никак не распространяется. Понятно? Да.
То же самое. Потому что X является полем, который находится в структуре A. И структура A говорит, что я разрешаю пользоваться только
к наследникам, но не внешнему коду. Вот. Да, friend влияет и на protect private. Вот. То есть, friend влияет только на сущности, которые объявлены
внутри самой структуры. Вот. То есть, если где-то внутри этой структуры написано private and protected, то к этому с помощью friend
можно получить доступ. Если где-то в наследнике написано private and protected, то, к сожалению, вот это friend никак на это не повлияет.
То есть, сама структура должна позволять или не позволять обращаться к полям или методам. Окей? Идем дальше. Хорошо. Да.
Какие три функции? Сейчас. Какая стройка смущает? Вот эта? Нет, ну тут все окей. Почему? Потому что, смотрите, у меня есть B. Я вызываю B.h.
Если у меня в структуре B функция h, метод h. Да, он есть. Я могу к нему спокойно обратиться. Или вас смущает то, что внутри h вызывается x, f?
Нет, в этом-то никакой проблемы нет. То есть, как бы, метод же может обращаться к приватным полям своего класса, и это же нормально.
То есть, суть в том, что я не могу непосредственно обратиться к x, f и h. Но при этом сами методы класса, естественно, не могут обращаться к ним. Вот. То есть, тут проблемы нет.
Так. Что? А, ну тут, не, ну в смысле, да. Да, имеется в виду, что с x нет никакой проблемы. Нормально? Хорошо.
Ну, если коротко, да. То паблик, в общем… то режим наследования паблик говорит о том, что все имеют право использовать информацию о том, что мой класс унаследован у кого-то другого.
Вот. P comunacle режим наследования говорит о том, что никто не имеет права использовать информацию о том, что я как-то от кого-то унаследован. То есть, если я с помощью внешнего кода, или с помощью своего наследника,
пытаюсь как-то использовать поля-еплименты, которые находятся в моем предке, то будет ошибка в компиляции. Вот.
Протектор действует точно так же, как и private, но только за исключением наследников.
То есть, если кто-то унаследовался от моего класса, то, соответственно, я этому наследнику позволяю пользоваться своими полями и методами.
Окей?
Хорошо.
Вот. Ну и на самом деле такое небольшое замечание.
Вообще говоря, таким чистым наследованием, как правило, называют наследование именно с помощью public.
Потому что, как правило, когда мы делаем какое-то наследование, мы хотим этим что-то сказать.
Мы хотим сказать, что вот эти вот классы как-то связаны каким-то функционалом.
То есть, например, там, где можно поставить A, туда же можно поставить B. Почему?
Потому что B обладает этими же свойствами и характеристиками.
В этом смысле private и protected наследование используются, к вашему счастью, наверное, гораздо реже.
И в большинстве ситуаций private и protected наследование можно просто-напросто заменить на A-композицию.
То есть, смотрите, вот если у меня есть структура B, и я приватным образом наследуюсь от A,
то в целом примерно то же самое может добиться, если я просто-напросто в структуру помещу в приватную секцию поле, которое будет иметь тип A.
Согласны?
Вот структура B будет иметь все те же самые поля и методы, что и A в случае структуры B.
Ну и плюс структура C тоже будет иметь все те же самые поля и методы, что и A.
Но при этом мы к ним сможем обращаться через имя A.
И во втором, то есть и в случае структуры B, и в случае структуры C, у меня в классе появляются поля и методы A.
Но только в третьем случае я получаю к ним доступ через имя A, а во втором случае получаю к ним доступ непосредственно, как если бы это были мои собственные типы.
В этом смысле реализация с помощью B и C, они эквалютны за некоторым исключением.
И одно из исключений это такая оптимизация компилятора, которая называется empty-base-optimization.
В чем она заключается?
Включается она в следующем.
Вообще говоря, в C++ любой тип данных, точнее объект любой тип данных, обязан занимать в памяти как минимум один байт.
Ну это просто связано с тем, что стандарт C++ гарантирует, что если у вас есть два разных объекта, то они обязаны лежать в разных местах памяти.
Поэтому если вы заведете в пустую структуру, например структуру A, она будет занимать один байт.
Кстати, вот еще одно замечание про наследование, что если у вас есть какая-то структура,
допустим структура A, в ней есть поля x, y, z, пусть интовые.
И вы как-то берете структуру B, наследуетесь от A, ну и пусть тут еще есть int A.
Вот, то в памяти структура B будет выглядеть примерно так.
Сначала будет идти часть, которая относится к A, а потом часть, которая относится к B.
То есть вот как-то так.
x, y, z.
Вот.
Так, а в чем заключается empty-base optimization?
Значит, empty-base optimization заключается в следующем.
Если у вас структура A пустая, то
Сайзов A будет, ну давайте скажем, больше правильной единицей, но на самом деле на практике правило единицы.
Потому что объекты C++ не могут занимать меньше одного байта.
Но в этом случае, если вы B унаследуете от пустой структуры, или B унаследуете от пустого класса,
то на A место вообще тратиться не будет.
Вот.
То есть size of B
будет в точности равен
size of int.
Короче говоря, если вы унаследуете от пустого класса, то место на этот класс в наследники не тратится совсем.
Ну даже несмотря на то, что по стандарту требуется, чтобы все классы занимали как минимум один байт.
Ну почему это так работает?
Ну потому что если у вас есть структура B, то
даже если структура B будет пустой, то мне достаточно хранить один байт для самой структуры B,
и тогда у меня разным объектам будут соответствовать разные адреса.
Поэтому, в общем, иногда вот этот вот трюк с приватным наследованием используется именно для того, чтобы
не занимать много места памяти.
Потому что если вы внутрь структуры B внесете объект A,
то если вы сделаете вот так,
то есть если вы внесете поле A внутрь структуры B,
то вот на этот A уже будет тратиться один байт, как минимум.
А если вы выполните наследование,
то вот на это наследование не потратится ни одного байта.
Это вот такой вот небольшой пример, когда приватный или препарктальный наследование может быть полезным.
Окей?
Хорошо.
Ну и, наконец, вот то, про что я сказал.
Мы когда с вами говорили в прошлом семестре про классы и структуры,
в качестве одного из отличий, точнее, в качестве...
То есть я сказал, что классы и структуры на самом деле отличаются только тем, что
в классах по умолчанию все приватно, в структурах по умолчанию все публично.
Ну, это на самом деле так.
То есть классы и структуры, они с точки зрения кода и так далее,
они эквиваленны, да, вот за исключением вот такого отличия.
Ну и плюс, на самом деле, есть еще одно отличие,
которое связано с наследованием,
по сути, оно то же самое, да?
То есть если структуры...
Если мы после структуры, после двоеточиля не пишем слово паблик или правит,
то по умолчанию считается, что вы наследуете публичным образом.
Для классов по умолчанию считается, что вы наследуете приватным образом.
Вот.
То есть на этом список отличий классовح структур заканчивается,
то есть, если коротко,
то для классов по умолчанию все приватно,
что наследование, что пар Lite, методы,
А в структурах по умолчанию все публично, что наследование, что поля, методы и т.д.
Все это второе и последнее отличие структуры от класса.
Давайте поговорим про то, как ведут себя уже изученные нами концепции вместе с наследованием.
В частности, поговорим про то, как ведут себя конструкторы и деструкторы,
если вдруг возникает в ваших классах наследование.
Снова пример. Допустим, у меня есть написанный класс stack,
и у меня есть его наследники stackMax и stackMin.
То есть, stack с поддержкой максимума, есть stack,
плюс есть stack с дополнительной поддержкой максимума,
и есть stack с дополнительной поддержкой минимума.
Понятное дело, что класс stack содержит указательную динамическую память,
поэтому у него есть какие-то конструкторы, деструкторы и все подряд.
То же самое касается stackMax и stackMin.
Так как мы реализуем stackMax и stackMin,
так как нам нужно хранить максимум минимум,
нам необходимо еще дополнительно хранить указательную массив,
либо дополнительный список.
Так или иначе, нам в stackMax и stackMin нужно прописать дополнительную логику,
как правильно выделять ресурсы, как ее очищать.
Вопрос заключается в следующем.
Вот у меня есть stackMax.
И stackMax в какой-то момент вызывает свой конструктор.
Нужно
сначала создать stack,
то есть сначала создать часть, которая относится к stack,
а потом из Terr grow ltт tart consultativeей,
для которой есть р brewing,
при котором, например, вот вlan 학,
более Elizabeth, более Terrya.
В принципе, в consecutive линдии irgendя� HTML,
Когда я пишу конструктор по умолчанию, любой конструктор вашего класса устроен следующим образом.
В первую очередь, он всегда вызывает конструкторы базовых классов.
То есть, части, которые относятся к базовым классам, создаются всегда без вашего ведома.
То есть, создание наследника состоит в том, чтобы создать наследников, а только потом вызвать конструктор вашего класса.
То есть, в частности, конструктор по умолчанию StackMax сначала вызовет Stack по умолчанию, и только потом сделает необходимую инциализацию дальше.
Примерно то же самое касается и конструктора копирования во втором примере.
Если мы посмотрим на Stackmin конструктор копирования равно default, то конструктор по умолчанию для вашего класса сработает так.
Он вызовет конструктор копирования для класса Stack, то есть, часть, которая относится к Stack в вашем классе, копируется друг в друга.
И потом выполнится тело непосредственно своего конструктора копирования.
Тут оно будет просто пустое по умолчанию.
Кстати, в первом примере StackMax, в первом примере конструктора копирования, тут будет немного иначе.
Смотрите, тут я написал конструктор копирования, и дальше написал пустые фигурные скобки.
И вот тут будет проблема. Почему?
Потому что я сказал, что чтобы создать StackMax, нужно все проинциализировать по умолчанию, и только потом запустить фигурные скобки.
Смотрите, что мы знаем про фигурные скобки.
Мы знаем, что фигурные скобки в конструкторе начинаются только тогда, когда все поля и вообще все части уже проинциализированы.
Возникает вопрос, а как тогда будет проинциализирована часть, которая относится к Stack?
И ответ заключается в том, что часть, которая относится к Stack, будет проинциализирована по умолчанию.
Это означает, что компилятор сам не догадается о том, какой конкретно конструктор нужно вызвать для базового класса.
Ну точнее, если вы напишете равно default, то компилятор догадается, что, наверное, если вы пишете конструктор копирования, то все нужно скопировать.
Если вы пишете конструктор по умолчанию, то нужно вызвать конструктор по умолчанию.
Если вы пишете самостоятельно фигурные скобки и не прописываете ничего в списке инциализации, то единственное, о чем может догадаться компилятор, это то, что вам нужно все проинциализировать по умолчанию.
Так вот, как сказать компилятору о том, что мне нужно вызвать конкретный конструктор моего базового класса?
Ну и, собственно, ответ заключается в том, что нужно это тоже прописать в списке инциализации.
Ну смотрите, вот я пишу класс StackMax, значит, написал конструктор по умолчанию, ну, понятное дело, он просто равно default, вот, и пишу конструктор копирования.
Вопрос, в чем заключается копирование Stack с поддержкой максимума?
Ну, копирование получается в следующем. Сначала я должен скопировать часть, которая относится к стеку.
То есть у меня есть базовая часть стека, и я базовую часть стека, ну вот, стека Other, копирую в базовую часть своего стека.
То есть вот, в списке инциализации я прописываю конструктор, который должен быть вызван для моего предка, для моей базовой части.
И только потом прописываю все то, что мне нужно для копирования всех остальных частей, которые относятся к моему классу.
Понятно?
Так.
Ну, в целом, да. Ну, короче, тут идея в том, что если у вас класс A, точнее, наоборот, класс B, следовало от класса A,
то вы можете сохранить ссылку на объекты типа B. Вот. Вот так это работает.
Причем как это работает? Это работает так, что вот это вот A будет ссылкой на часть A, которая находится в B.
Ну, смотрите, так как класс B у меня содержит все то же самое, что и A, то, соответственно, ссылку я тоже могу создать.
Просто вот эта ссылка будет ссылаться только на ту часть B, которая относится к A. Понятно? Вот.
То есть из чего состоит B? То есть B состоит из части, которая относится к A, ну и там, ко всей дополнительной части, которая относится к B.
И вот эта вот ссылка будет ссылаться только вот на эту часть.
Окей? Да.
Не, никуда. То есть у меня в памяти вот есть объект. Вот.
Значит, в памяти вначале расположено какие-то данные, которые относятся к A, а потом идут данные, которые относятся, ну, только к B.
Вот. Когда я ссылую ссылку, у меня, по сути, эта ссылка ссылается только вот на эту часть памяти.
Нет, остальная память, она по-прежнему тут находится, но просто ссылка ссылается вот только на эту часть. Да.
Да.
Не, не, ничего не кастуется. Нет, нет, как бы тут чисто дело, ну дело в памяти. Вот.
То есть как бы вот, допустим, вас A занимает, не знаю, там 8 байт, B занимает, не знаю, 24 байта.
Вот. То есть первые 8 байт – это вот то, что относится к A, остальные 16 байт – это то, что относится к B, без учета A.
Вот. И вот эта ссылка, она ничего не кастует, она просто-напросто, ну как бы считает, что она ссылается вот на объект A.
Ну, действительно, это так, да. То есть тут, на самом деле, вот эта вот, вот эта вот часть памяти, она вообще неотличима от объекта A.
То есть, грубо говоря, B состоит из A и чего-то еще. И вот эта ссылка ссылается только на часть B, которая относится к A.
Все. Да.
Ну, опять же, тут не совсем, ну, можно считать, что, ну, наверное, можно считать, что каст, но просто можно считать так, что конструктор stack'a принимает ссылку на stack.
Вот. В adder содержится часть, которая относится к stack'a, поэтому в нее можно тоже создать ссылку. Вот.
Что мы имеем право?
Ну, с помощью константной стэк, мы можем создать ссылку.
Что мы имеем право?
Ну, с помощью константной ссылки не можем. Если бы была обыкновенная, то могли бы.
Да, да. Да.
Это хороший вопрос.
Ну, типа, да. Ну, не хочется говорить про родитель номер 1, родитель номер 2. В общем, допустим, есть A, есть B, есть C.
Такая ситуация, возможно, C++.
Вот. То есть, называется множество наследований.
Ну, про него мы поговорим как-нибудь в другой раз.
Вот. Ну, просто такой теоретически возможно.
Вот. Ну, вообще говоря, как правило, такое, ну, многим констант такой запрещается, потому что добавляет хаотичности в код и так далее.
В общем, про это мы тоже поговорим.
Вот. Ну, в этом случае на самом деле тоже будет работать.
Вот. То есть, если C публично у наследованного A и C публично у наследованного B, то я также могу создать ссылку A на C и ссылку B на C.
Ну, просто компилятору тут будет немного сложнее работать, но в целом.
Ну, как бы, в самом простом случае это будет устроено так, что у вас сначала идет часть, которая относится к A, потом часть, которая относится к B,
а потом часть, которая относится к C без A и B.
Вот. Тогда ссылка на A будет ссылаться вот сюда, ссылка на B будет ссылаться вот сюда.
Дальше начинается прикол, а что, если у A и B есть какая-то своя общая часть.
Ну, в общем, давайте пока не думать.
Так. Есть ли еще вопросы?
Окей. То есть, резюмируем.
Значит, классы инициализируются в следующем порядке. Сначала инициализируются базовые классы.
То есть, если у класса A, то есть, если у класса есть какие-то предки, то сначала инициализируются они.
Вот. Причем то, как они будут пронициализированы, вы можете задать списки инициализации.
То есть списки инициализации вы можете задать, что мой наследник, что мой предок один должен быть сгенерирован так, наследник второй должен быть сгенерирован так и так далее.
Вот. А затем, а затем создаются поля класса наследника.
Причем в строго порядке объявления.
Ну, вот такой пример.
Вот у меня есть структура A, которая есть два конструктора, конструктора tent-A и конструктора двух int.
У меня есть структура B, в которой есть одно интовое положение z, при этом b у нас следовано от A.
Значит, как я могу написать конструктор для B?
Значит, конструктор для B я могу написать, например так, да, конструктор B от tent-A будет просто вызывать конструктор A от x, да, то есть я просто-напрасно говорю, что чтобы создать B, мне нужно создать части, которые относятся к A, с помощью одного int, с помощью x.
с помощью xA. Вот. Если я, например, допустим, создать конструктор B, который принимает два аргумента, я могу, например,
в списке интеллизации указать, что вот все эти два аргумента пойдут в конструктор A.
Вот. Если у меня B принимает три аргумента, то я говорю, что первые два аргумента пойдут в A, а остальным аргументом третьим я
заполню Z.
При этом, заметьте, что конструктор по умолчанию,
что конструктор по умолчанию, я просто так вот создать конструктор по умолчанию я не смогу. То есть я не могу написать там B пустые круглые скобки и фигурные скобки.
Почему? Потому что в этот момент, так как я не написал в списке интеллизации,
компилятор попытается вызвать конструктор по умолчанию A, а A нет конструктора по умолчанию.
Понятно?
То есть, если вы в списке интеллизации не написали, как нужно создать наследника, наследник будет создан с помощью
конструктор по умолчанию. Если же вы хотите вызвать какой-то другой конструктор, а не конструктор по умолчанию,
то вы через дветочие прописывайте, что, вот, я хочу A вызвать конструктор от вот таких аргументов. Вот.
При этом важно понимать, что отдельно поля структуры A я заполнить не могу, то есть я не могу написать
Кажется, у меня это есть на слайдах или... Ладно, кажется, нет. А, нет, вот есть. То есть отдельно
поля базового класса я проинфициализировать не могу. То есть класс A, то есть если у меня B унаследован от A,
то A у меня входит в B целиком, ну как бы вот, в единым целом. Поэтому и часть, которая относится к A,
я тоже должен создать и создавать единым целым. То есть сейчас, например, я тут не могу,
вот в этом примере я не могу создать конструктор B, который отдельно проинфициализирует x, x, y, y, z, z.
Вот. То есть я должен именно передать параметры в конструктор A, вот. А единственное поле,
которое я могу проинфициализировать тут самостоятельно, это поле z. Окей?
А есть пример? Вот. Смотрите, давайте посмотрим на это пример. Тут может показаться, что мы
делаем что-то неэффективное, ну, в смысле, с точки зрения написания кода. Смотрите,
вот давайте посмотрим на последнюю, ну, на третью строчку снизу и четвертую строчку снизу. Вот я
пишу bintx.ax или bintxy.axy. То есть что тут я тут пишу? Я говорю, что если я вызываю конструктор,
то есть если вызываю конструктор одного аргумента, то я должен вызвать конструктор для A. Если
вызываю конструктор от двух аргументов, я вызываю конструктор для A от двух аргументов. То есть,
по сути, кажется, что я просто-напросто подменяю конструктор B конструктором A. И во втором случае
тоже подменяю конструктор B конструктором A. Вот. Ну, кажется, что я просто-напросто тупо дублирую
код. Ну, как бы я прописываю один и тот же конструктор несколько раз. А представьте мне,
что я хочу сказать следующую вещь. Я хочу сказать, что на самом деле класс B должен задержать все те
же самые конструкторы, что и A. Вот. То есть он должен принимать ровно такое же количество конструкторов,
и он должен принимать ровно такие же аргументы, что и конструктор A. Вот. Я это могу сделать с помощью
директивы using. Вот. Вторая строчка снизу, ну или третья. Вот. Я пишу using A.A, и это означает,
что в классе B должны быть точно такие же конструкторы, как и в A. В этом случае я B
могу вызывать точно таким же, могу создавать точно таким же набором параметров. Вот. И при этом
все эти параметры будут просто-напросто передаваться в конструктор A. Ну, а часть, которая относится к B,
будет создана по умолчанию. Окей? Ну, то есть, если это примитивный тип, то она будет заполнена мусором.
Вот. Если это какие-то классы, то она будет заполнена конструкторами по умолчанию. Понятно? Ну и такой
просто способ, грубо говоря, унаследовать конструкторы. Потому что конструкторы сами по себе не
наследуются. Да. Не, ну вот это имеет смысл. Если, допустим, у вас, ну если, допустим, у вас структура B,
представьте себе, вот если у вас есть какой-то класс B, ну не важно, у вас есть класс B, который содержит
какое-то поле, ну не знаю там, типа STD-вектор V. Вот. И, допустим, в классе A есть какие-то, есть какие-то
конструкторы? Типа конструктор от NTA, от NTA и DLA, от DLA и BLA, ну и так далее. Куча-куча конструкторов. Вот.
И я бы хотел, чтобы A, да и при этом B унаследован от A. Вот. То есть, класс B отличается от класса A
всего лишь на I, чем вектор. Вот. Ну и я бы хотел, чтобы в классе B были ровно такие же конструкторы,
как и в A. Ну, естественно, мне бы не хотелось вручную переписывать, что у класса B есть конструктор от NTA,
от NTA и DLA, от DLA и BLA, и так далее. Вот. Поэтому я просто пишу using, ну, в публичной области, естественно.
Я просто пишу using B.B. То есть, я говорю, что как бы из B нужно взять все конструкторы. Вот. И в этом
случае все те же самые, ой, наоборот. А. Что мне из A нужно взять все конструкторы. Вот. И в этом случае у меня в B
будут ровно те же самые конструкторы, что и в A. Еще раз. Если мы это не напишем, то действует обычное
правило для классов. А какое у нас обычное правило для классов? Если мы в классе B не написали ни одного
конструктора, то в нем есть только конструктор по умолчанию. Вот. Нет, так нельзя. Нет.
В целом, да, можем, но у этого есть, в общем, так можно посвести с любым методом. Вот. Но, как правило,
это не нужно, потому что методы автоматически подгружаются. То есть, конструкторы, да, вот,
наверное, это стоит подсветить. Что? Зачем нам нужно писать вот так? Потому что конструкторы,
в отличие от обычных методов, ну, грубо говоря, не наследуются автоматически. Вот. То есть, как бы,
если у вас в классе A есть метод F, то метод F появится в классе B. Но если в классе A есть какой-то
конструктор, то автоматически в классе B он не появится. Вот. Чтобы они появились автоматически,
нужно писать вот так. Окей? А нет, с деструктурами по-другому. Там дальше поговорим. Не, он даже
наследуется, но просто класс B не сможет получить к нему доступа. Ну, в смысле, если B попытается
вызвать конструктор, ну, приватный конструктор для A, то он зафейлится. Нет, конкретный конструктор,
ну, короче, нет. Вы либо импортируете все конструкторы, либо никаких конструкторов. Нет,
точнее, нет, вы можете сделать так. А, сейчас. Смотрите, если вам нужен какой-то отдельный конструктор или
отдельный конструктор, то вы прописываете его руками. Если вам нужны все конструкторы кроме одного,
допустим, кроме конструктора A от NTA, то вы можете отдельно написать вот так using A 2.2.A и
написать там B от NTA равно delete. Вот. То есть как бы вы можете так вот либо опционально какие-то
добавить вручную, либо какие-то вручную удалить. Окей? Хорошо. Так, теперь с деструктурами. А с
деструктурами, на самом деле, та же самая история, но в смысле в порядке. To si, когда мы говорили
про конструкторы, конструктора вызыва в следующей порядке. Сначала вызываются конструкторы для
предков, а потом вызываются конструкторы для самого класса. С деструктурами ровно обратная
ситуация. Сначала вызываются деструкторы для полей вашего класса. То есть сначала будут вызваны
деструктуры для В, например, для Вектора и для остальных полей. И в самой последней очереди будет
вызван деструктур А. Вот. Вот деструктор, в отличие от конструкторов вызывать явно не нужно, потому что
деструктур всегда только один и
конструкторов может быть много, а
диструктуры в классе всегда
только один, поэтому диструктура всегда
вызовется автоматически
Если у вас класс унаследован
от каких-то других классов, то их
деструктура тоже будет вызвана
автоматически.
Например, у меня есть класс B,
у меня есть какой-то класс A.
Есть класс B, который
унаследован от A. И в классе Б содержится
допустим два стека зачем-то.
Соответственно, я пишу диструктур B и
сначала в диструктуре Б вызовутся
Деструкторы для стеков, то есть для S1SoC и для С2, а потом для С1SoC
а когда в конце деструктуры закончают JS üz disconnected, в конце вызываются деструкторы для частью сpart2
понятно?
если вам нужен вызвать какой-то конкретный деструктор, вы должны прописаться в списке инт telescope
и если вам нужно чтобы вызвался деструктор, вы можете об этом не думать, в touble, т.е. да grasp
Единственное, что важно понимать, что конструкторы выполняются в прямом порядке, то есть сначала наследники, потом поля класса, а деструктор в обратном порядке, то есть сначала поля класса в обратном порядке, а потом предок.
Так, теперь к интересной части, к срезке, вот про то, как на самом деле связаны между собой классы. Смотрите, вот я про это еще не проговорил, про это не сказал, но вообще говоря стоило.
Смотрите, публичное наследование реализует так называемую симматику является. То есть если у меня класс B публично унаследован от A, то с такой симматической точки зрения можно считать, что B является A.
Почему это верно? Потому что если класс B унаследован от A, то значит все то, что верно для A, верно и для B. То есть если в классе A есть какие-то поля, то и в B они есть. Если в A есть какие-то методы, то и в B они есть. Причем если в A они доступны, то и в B они тоже доступны.
То есть по сути везде, где встречается A, я могу подставить B. И от этого ничего не потеряю. Согласны? Вот этот принцип называется принцип установки Барбарлистков.
То есть если везде вместо одного типа вы можете подставить другой тип, то вот этот тип является подтипом вот этого типа. То есть на самом деле B является A, то есть B унаследован публичным образом от A.
Вот. И вот давайте сейчас будем жить парадигме, что мы работаем с публичным наследованием, то есть у нас при наследовании реализуется семантика является.
Вот. То есть у меня есть какая-то структура A, есть структура B, которая унаследована от A. То есть B является A. К чему это приводит?
А это на самом деле приводит к тому, что на самом деле действительно если в коде, ну везде где в коде вы можете подставить A объекты A, вы можете подставить и объекты B.
Ну вот примеры следующие. Я создал, ну вот в самом конце. Я создал объект типа B. Вот. И создал объект типа A с помощью объекта типа B.
И это возможно. То есть так делать можно. Почему? Потому что B является A. Раз B является A, то везде где я могу подставить A, ну тут я мог подставить A? Мог.
Вот. Поэтому везде где я подставляю A, я могу подставить и B. Вот. Ну и логично я могу написать A, присваивание B. То есть вообще говоря в нормальной ситуации я могу присваивать только объекта одного типа.
Ну то есть я могу присваивать только объекта одного типа тому же самому типу. Но тут так как у меня объекты типа B являются объектами типа A, то вот это присваивание тоже работает.
Но при этом заметьте, что не наоборот. То есть, например, написать вот так у меня не получится. Почему? Потому что если B является A, отсюда вообще не следует, что A является B.
Да? Ну то есть из того, что стул является мебелью, не следует, что любая мебель это стул. Понятно? Вот.
Вопрос. Как это работает? Что при этом происходит? Вот давайте сосредоточимся вот на этих примерах.
Ну, допустим, мне удалось присвоить объект типа B, объекта типа A. Ну, точнее создать объект типа A с помощью объекта B или присвоить B, A.
Что при этом происходит? При этом происходит такая вещь, которая называется срезкой. Что такое срезка? Срезка это явление, при котором...
Вот смотрите, вот у меня есть, допустим, объект A и есть объект B. Вот в объекте B находится часть, которая относится к A, часть, которая относится только к B.
Значит, срезка заключается в следующем. Часть, которая относится к A копируется вот сюда.
То есть при срезке теряется часть информации. То есть как раз не только часть, которая относится к A копируется, а вся остальная часть остается в B.
Вот. Собственно, вот такое вот копирование наследников в предков называется срезкой.
Вот.
Ну, да, собственно, опять же, срезка, повторю, что тут написано.
Тут срезка может работать только в случае, когда у меня наследование публичное.
То есть если бы наследование B от A было, допустим, приватным, вот этот код бы не сработал.
Ну, почему? Потому что вот этот код, он жестко испортит тот факт, что вообще говоря, B унаследован от A.
Да, так как B не унаследован, так как я не имею права в этом знать, то вот этот код не сработает.
Вот. Единственное исключение заключается в том, что если бы тут, допустим, написано было Protected, вот как в примере, как вот в последнем примере.
Если B Protected образом унаследован от A, то это, по сути, вообще говоря, означает, что, понятное дело, что B знает о том, что унаследован от A.
Поэтому внутри B я могу использовать тот факт, что B унаследован от A, и поэтому я могу выполнять срезку.
Вот. Понятно? То есть срезка во внешнем коде возможна только если внешний код знает о том, что кто-то от кого-то унаследован.
Понятно? Срезка. Ну, простой пример такой.
Вот, допустим, у вас есть, ну, представьте себе, что у вас есть, допустим, stack с поддержкой максимума.
Вот. И вы как-то с ним поработали.
Вот. А потом вам необходимо, а потом вдруг, ну, у вас появилась необходимость скопировать stack, но при этом часть, которая относится к максимуму, вам не нужна.
То есть вам нужно использовать только stack, ну, только те элементы, которые в нем содержатся.
Когда вы пишете, когда вы можете написать stack s равно sm, и в этом случае у вас stack скопируется только та часть, которая относится к stack.
Вот. При этом та часть, которая относится к максимуму, у вас будет потеряно, но вам этого и не нужно.
Вы как бы тут пользуетесь только возможностью stack, а на максимуму забиваете.
Окей?
Ну, здесь у меня stack max унаследован от stack.
То есть если у меня stack max унаследован от stack, тогда вот это возможно.
Если бы stack max и stack были бы абсолютно разными типами, то вообще говоря, вот так написать бы не мог.
Ну, точнее, я бы мог это написать, если я написал какой-то специальный конструктор, который бы позволял бы мне создавать стейки на основе stack max.
Не-не-нет. Вот у меня есть такая иерархия. Stack max унаследован от stack.
Вот. Я создал stack max, и дальше о чем говорит публичное исследование?
Публичное исследование говорит о том, что везде, где я использую stack, я могу использовать stack max.
Но в частности вот тут. Я могу создать любой stack, передавая ему аргумент stack max.
Вот в этом случае stack скопируется только часть, которая относится к stack.
Потому что что такое stack max? Stack max это stack и плюс еще что-то.
И вот это вот еще что-то скопировано не будет. Вот это срезка.
То есть я по сути срезал ту часть, которая относится только к stack и скопировал только ее.
Ну, погодите. Во время выполнения программы ничего добавить в класс не можете.
А добавить в класс вы можете только после компиляции. То есть вы как бы внесите изменения в код, и потом заново скомпилируете программу.
Но если так, то у вас в наследнике тоже появятся эти методы.
Ну, можете, да, но вы же код пишете на этапе компиляции, то есть до компиляции.
Вы же не можете во время исполнения программы что-то добавлять в классы.
Не, ну смотрите, у вас же классы, есть две вещи.
Вот у вас есть класс, есть объявление класса, в котором вы, точнее, определение класса, в котором вы прописываете все параллельные методы, которые в нем есть.
А определение метод вне класса означает, что вот у вас есть этот метод, который вы не определили, и вы определяете его в другом месте.
Но при этом сам класс-то знает, что у него есть этот метод.
То есть вы не можете объявить метод внутри, объявить метод класса, который не написан внутри вот этих фигур скопов.
Есть еще вопросы? Окей.
Так, ну и понятное дело, что вот, да, такой пример.
Значит, срезка не всегда делает то, что нам нужно.
Вот, в частности, вот такой пример.
Представьте себе, что у меня есть структура A, и в ней есть поле, ну поле строчки, которая содержит просто-напросто имя класса.
Ну и понятное дело, что в конструкторе я просто пишу, что имя класса это, ну в структуре A я пишу, что имя класса это A.
Потом я беру структуру B, наследую ее от A и говорю, что имя класса это B.
Ну нормально, в структуре B есть поле name, и в конструкторе B я говорю, что name это B.
То есть когда создается объект A, у меня там в name сохраняется A, когда я создаю B, у меня в name сохраняется B.
Ну вот незадача.
А если я напишу, ну я создаю A, a.name равно A, все отлично.
Создаю B, b.name равно B, все отлично.
Но, когда я выполняю срезку, то есть я пишу A, A, A равно B,
начинаются проблемы. Какие?
Смотрите, в B у меня есть поле name, которое содержит B.
Ну так как name это общее место для класса A и для класса B, то поле name как раз таки скопируется с помощью срезки в A.
И таким образом у меня вот в этом объекте в поле name будет храниться A, будет храниться B, хотя хотелось бы A.
Понятна проблема?
Вот.
Поэтому иногда хотелось бы сделать так, чтобы, в общем, при срезке копирование объекта ввело себя немного иначе.
Ну и решение на самом деле заключается довольно простое.
Нужно просто-напросто в классе A написать конструктор, который принимает B.
Вопрос как это сделать?
Да, смотрите, у меня есть структура A.
И естественно структура A, она же не, ну, то есть как бы у меня наследник, он же определяется после структуры A.
То есть у меня есть структура A, и после нее определяется наследник B.
Вот. Как написать в структуре A метод, который бы принимал объекта типа B?
Ну очень просто. Я вот в первой строчке пишу forward declaration, то есть я пишу объявление класса B.
То есть я говорю, что где это у меня будет класс B.
Вот. Дальше в структуру A я пишу конструктор от B.
То есть я говорю, что A, const B, other.
Вот. Дальше прописываю структуру B.
Ну и собственно в конструкторе A, который принимает B, прописываю необходимые действия, которые мне нужно сделать, если мне в структуру A подастся объект B.
Вот. Окей?
То есть если меня не устраивает поведение при срезке, я просто-напросто могу написать дополнительный конструктор в структуре A.
Но при этом я должен помнить о том, что так у меня наследник всегда определяется после предка, то до предка я должен сделать вот этот самый forward declaration, который написан в первой строчке.
Окей?
Вот.
Да, ну в абсолютно аналогичном образом можно запретить срезку.
То есть допустим, вы хотите, чтобы такое безобразие было запрещено.
То есть вы не хотите, чтобы с помощью наследников можно было создавать предков.
Но в этом случае вы просто пишете, конструктор A от наследника равно delete.
И, в образом, от наследника создаваться будет нельзя.
Окей?
Хорошо.
Так.
Теперь важная часть затенения методов.
Последняя часть.
Смотрите.
Вот мы с вами говорили, вот все это время мы с вами говорили о простых ситуациях.
Вот у меня есть класс A, в классе A есть какие-то методы, потом есть класс B, который наследуется от A, и поэтому в B получаются все методы, которые находятся в A.
Да?
Но, возможно, же и более сложная ситуация.
У меня есть класс B, который наследуется от A.
И в A есть метод F.
Но в то же время в B тоже есть метод F.
То есть, у меня и в предке, и в наследнике есть один и тот же метод.
Что при этом происходит?
При этом происходит следующая вещь.
Вот, есть у меня в классе A есть метод F, который принимает Int, и в классе B есть метод F, который принимает Int.
А если я буду вызывать метод F с помощью класса B, с помощью объекта класса B, у меня будет вызываться метод, который находится в классе B.
И эта ситуация называется затенением методов.
То есть, если у меня в классе B есть метод,
метод с таким же именем, что и в классе A, то при вызове через класс B у меня будут
вызваться именно методы, которые находятся в классе B. Еще раз, это называется затенение метода.
То есть наибольший приоритет имеют методы, которые объявлены внутри класса наследника.
Запомнили. Тут мог возникнуть вопрос, а можно ли как-то все-таки обратиться к методу F,
которая находится в классе A, и ответ – да, можно, вот последняя строчка, в общем, вот с
помощью такого способа вы можете обратиться к методу, которая находится в классе A. То есть,
если очень хочется, вы можете написать, ну, это называется полным именем метода. Вы пишите
B.A.F. A.F – это полное квалифицированное имя, называется полное квалифицированное имя F.
Вот. Окей. Но это все еще очень простые примеры. То есть, если у меня и в A есть F от int, и в B есть F
от int, то приоритет будет отдаваться наследнику. То есть, если вызываетесь через наследников.
Другой, более странный пример. Смотрите, у меня в структуре A метод F, который не принимает
аргументов. Структура B у наследована от A, и она реализует метод F, который принимает int.
Ну, смотрите, казалось бы, в классе A есть метод F, который не принимает аргументов. В классе B
есть метод F, который принимает int. Казалось бы, это два совершенно разных метода. Один ничего не
принимает второй, принимает int. Но даже в этом случае работает затенение. Даже в этом случае
работает shadowing. Смотрите, я вызываю B F от нуля, вызывается F от int. Все нормально. В классе B есть
метод F от int, он и должен вызываться. Но при попытке вызвать B.F без аргументов у меня внезапно
возникнет ошибка компиляции. И вот это важно понимать, что если у меня и наследники, и предки
есть одни и те же методы, то класс наследника полностью помещает все методы класса A, которые
имеют одно и то же имя. То есть, когда я попытаюсь B вызвать метод F без аргументов, несмотря на то,
что в классе A он есть и он доступен, все равно класс B скажет, погоди, у меня есть свой хороший
метод B, который нужно вызывать с помощью int A. Поэтому без аргументов его вызывать нельзя.
Проблема понятна? Да. Если есть большая иерархия, то тоже можно обращаться B.C или B.A и так далее.
Вот. Эта проблема понятна? Если у вас и в предке, и в наследнике есть метод с одним и тем же именем,
то предпочтение будет обдаваться именно наследнику. Даже несмотря на то, что у вас
сигнатуры методов разные. Вот. Ну тут такой, не знаю, риторический вопрос, логично это или нет. Ну,
с одной стороны, логично, да, потому что если вы в наследнике написали какой-то специфичный метод,
то, наверное, вы имели в виду, что для наследника имеет смысл вызывать именно этот метод, а методы
предка вызывать не имеет смысла. Вот. Ну, с другой стороны, ну, как бы, если методы не пересекаются по
сигнатурам, то, наверное, можно было бы их решить такое. Ну, в общем, так или иначе, мы живем в
реальности, в которой это есть. Вопрос, как с этим бороться. Есть три пути. Первый, это просто
принять как факт, что вот это все работает именно так и стараться не допускать таких ситуаций.
Если путь смирится, это не наш путь, то мы используем пункты 2 и 3. Пункт 2 заключается в следующем.
При вызове используем полное имя метода. Ну, собственно, как и раньше, да, то есть b.a.f. Вот. То есть,
если вы хотите вызвать метод предка, то вы пишете полное имя этого метода. Если это вас не устраивает,
то есть не хочется писать постоянно полное имя метода, то в этом случае можно писать решение с
помощью директивы using. Как мы писали вот тут. Ну, решение, собственно, описано выше. Вот если у
меня есть структура a, в которой описаны методы f, и есть структура b, которая тоже пишет свой метод f.
И, допустим, я хочу, чтобы через структуру b был доступен обычный вызов метода f, который находится
в a. В этом случае я могу написать директивы using. То есть, я пишу using a.a.f. И что это делает? Это
говорит о том, что при вызове метода f у b нужно рассматривать еще и дополнительные методы a. Понятно?
Да. Если они пересекаются, то смотри пункт два. Вот. Нет, нет, там просто будет предпочтение
даваться метод b. Окей? Ну, все. Ну, в общем, что еще раз? Да, да. Так.
Ну, тут вопрос. Либо будет предпочтение даваться b, либо ошибка вариации. Это надо отдельно проверить.
Я точно сейчас не скажу. Так. Все. Последняя проблема. Ну, ладно. Нет, давайте без проблем. Давайте
просто оставим тизер на следующее занятие. Смотрите. Допустим, снова та же самая ситуация.
У меня есть объект b. Короче, у b есть свой метод f, и у a есть свой метод f. Вот. Ну,
у каждого из них своя версия метод f. Вот. У меня есть указатель a, который указывает на
самом деле на объект b. Вот. У меня есть b, который содержит часть, которая относится к a, и часть,
которая относится только к b. Я создаю указатель a, допустим, ptr, и он указывает, и он может указывать
вот на b. Ну, почему? Потому что, так как b является a, то и указатели a, естественно, могут указывать на
объект b. Понятно, да? Ну, смотрите, в b есть часть, которая относится к, вот. Поэтому этот указатель
будет указывать именно на нее. Вот. То есть, смотрите, у меня есть объект b, у меня есть указатель b ptr,
который думает, что он указывает на a. Вот. Потом я пишу b ptr, стрелочка f. В этом случае вызывается
метод a. И вот это поведение может быть уже довольно странным. Почему? Потому что, смотрите, ptr имеет
указатель на a. Вот. Но при этом он указывает на объект типа b. И вот тут возникает вопрос,
что логичней? Опираться на тип указателя или опираться на то, на что на самом деле он указывает?
И вот на самом деле в большинстве ситуаций нам бы хотелось второго поведения. В этой ситуации
нам бы хотелось поступать так. Мы бы хотели, чтобы указатель смотрел на что реально он указывает,
чтобы он мог посмотреть. Я указываю на a или я указываю на b. Если он указывает на a,
он бы вызывал метод f. Если бы он указывал на b, он бы вызывал метод b. Вот. Мы бы хотели,
что в зависимости от этого вызываем метод, вел бы себя по-разному. Вот. Но тут, к сожалению,
в обычном рамках того, что мы с вами сегодня обсудили, к сожалению, в данном примере всегда
будет вызываться метод a. То есть, компилятор всегда будет опираться только на статический тип
указателя. То есть, если есть указатель a, который указывает на b, то равно будет вызываться метод,
который находится в a. Вот. И про то, как это победить, мы с вами поговорим в следующий раз.
А на сегодня вот такое небольшое резюме. На это у меня все. Есть ли вопросы? Нет. Если вы тут
напишете вместо указателя a, то будет указатель на b. Потому что адрес b имеет b указатель.
Все. Спасибо. До встречи в следующем деле.
