Первая лекция, точнее первой половине лекции, мы подсвятим массивам и строкам,
но в стиле языка C. Да, не удивляйтесь, в стиле языка C. Почему это так?
Ну, просто по опыту оказывается, что по опыту общения на экзаменах
со студентами первого курса, по опыту общения на семинарах,
в общем, выясняется, что не все понимают разницу между массивами указателей и тому подобное,
не все умеют ими пользоваться корректно.
А это вам все пригодится, особенно при выполнении первого задания,
и все это на самом деле очень полезное знание и важное знание, как мне кажется.
Поэтому давайте этому некоторое время уделим.
Итак, что такое массив?
Значит, массив по одному из определений, взятому с известного сайта с справкой,
это последовательность элементов одного типа, которые расположены непрерывно в памяти
и к которым имеется доступ по индексу через некоторый уникальный идентификатор. Да.
Вот буквально минуты назад была ссылка, где можно было все эти лекции найти.
Так, ну в общем, определение понятно, то есть что значит непрерывно в памяти?
Значит, выполнимо адресной арифметикой, грубо говоря.
Если у вас есть один элемент, то к доступу к следующему элементу вы можете просто получить
адрес на арифметике, прибавив единицу к соответствующему указателю.
Доступ по индексу тоже понятно, все элементы как-то пронумерованы,
и вы к каждому элементу можете получить доступ по его порядковому номеру.
Уникальный идентификатор – это тоже имя массива, с помощью которого вы можете обращаться к его элементам.
То же все понятно. Ну и массив элементов одного типа – это значит,
что в массиве у вас могут храниться элементы только, скажем так, одного типа.
Не как в питоне, где в листе может храниться данные различных типов и так далее,
строго один конкретный тип.
Ну и давайте сразу вопрос сходу. Что такое array?
Вот на самом деле, C++. Что такое array?
Что? Это имя. Так, еще какие версии?
Указатель.
Указатель, отлично. Да, ну вот, в общем.
Да, самый распространенный ошибок. Действительно, array – это указатель, это массив,
нет, действительно, как вы правильно сказали, это имя, или некоторые идентификаторы.
Assim competitor, да, то есть array – это просто имя, которое обозначает, ну,
короче, это некоторое имя переменной.
Вот. Кстати, что такое переменная?
Именно lining-область памяти.
Именно ланков diphtheités – да, самое лаконичное определение –
это именно
Как этого [? shortest word than stores, ?], это sack.
Once defined in the most ordinary�� hoe.
Ну а теперь вопрос, какой тип
Указатель на целое число, еще более точное.
Константный указатель, супер, неправильно.
Да, действительно, многие считают,
на самом деле, к сожалению, многие пособия, учебники,
они как-то потворствуют всем этим предубеждением,
что RA это указатель или даже константный указатель.
Давайте скажу правильный ответ.
RA имеет тип массив интов размера 10.
Это прям такой тип. В языке есть тип массив интов,
ну и сколько бы указывать какого размера.
На самом деле, массивы действительно часто ведут себя
как константные указатели.
Но, тем не менее, они ими не являются.
Давайте я попробую как-то доказать на примерах,
почему это действительно так. Давайте рассмотрим вот такой вот код.
Давайте я выведу sizeof array. Что такое оператор sizeof?
sizeof возвращает размер в байтах, который занимает данную область памяти
или данная переменная.
И вот если я попрошу sizeof array, то он мне выведет 40.
То есть сам array занимает в памяти 40 байт.
А основной область памяти занимает 40 байт. Ну а 40 байт
как раз 10 интов. Если я спрошу sizeof адреса первого элемента,
то он мне вернет 8. Почему 8? Потому что в большинстве систем
размер указателя занимает 8 байт.
Соответственно, здесь мы уже видим, что размер указателя и размер массива
это разные вещи. Также мы можем попросить sizeof int10.
sizeof int10.
То есть int10 это как раз тип, который обозначает
массив интов размера 10. Ну и если я спрошу размер
константного указателя на int, то я получу тоже 8.
Но если вас это не убеждает, то можно попросить явно, то есть никак попросить,
можно оставить компилятор как-то расколоться. То есть как-то его пытать так,
чтобы он вам явно сказал, что такое array. Ну вот например, можно попытаться взять
10. Понятно, что операция умножения для массивов и для указателей не определена.
Но тем не менее, если я попытаюсь так сделать, то у меня возникнет ошибка компиляции.
И вот тут компилятор мне расскажет всю правду. То есть он мне расскажет правду, как он воспринимает на самом деле array.
И вот тут он мне говорит, что на самом деле, короче, у него нет оператора
умножить для int, который является четверкой, и int10.
То есть компилятор вам тут явно сказал, что array для него это int10,
а никакой не указатель. Понятно? То есть массив
Это прямо тип, это не указатель и не констант указатель, это прям тип.
Откуда берется предубеждение, что массивы это на самом деле указатели?
Но на самом деле массивы довольно часто приводятся к указателюм. У них устроено поведение,
что они просто берут и неявно приводятся к указателю без вашего спроса.
Ну когда они приводятся к указателюм? Когда вы их раз congregation? То есть вы можете разcommunicate имя массива.
И тогда вы получите собственно то что лежит под нулевым элементом.
сам нулевой элемент массива. Вы можете складывать имя массива с другим числом,
тогда массив приводится к указателю и выполняется адресная арифметика. Вы можете
сравнивать его с другими указателями, тогда тоже. Если в одной части находится
массив, то массив приводится к указателю и сравниваются собственно сами указатели.
Ну и также происходит конверсия, когда вы объявляете какую-то функцию, которая
принимает массив. То есть на самом деле функцию нельзя принять массив, ну вот прям
по значению, вот как описано здесь. Вот так делать нельзя. То есть если даже вы так
напишете, то для компилятора это будет выглядеть так, что вы принимаете на самом
деле указатель.
Ну и соответственно есть исключение, то есть в каких ситуациях массивы на самом
деле не приводятся к указателям. Ну существует всего три ситуации. Первая это,
как мы уже упоминали, сайзов. То есть если вы попробуете сайзов от массива, то он вам
выведет размер массива в байтах. Взятие адреса. Если вы берете адрес какой-то
переменной, то этот оператор возвращает, собственно, позицию начала этого элемента в
памяти. То есть вам на самом деле будет возвращен не указатель на int, а вам будет
возвращен указатель на массив размера 10. То есть если выполняете операцию
разыменования, то вам возвращается указатель на массив, а не указатель на
первый элемент. Вот. Ну есть еще одно отличие, о котором поговорим чуть позже, это
связано со строками. То есть если у вас в правой части стоит массив, то массив
присваивается, ну точнее не массив, а с правой части стоит массив чаров, то он
прям вот целиком будет присваиваться туда, куда надо.
Окей? Все понятно? Отлично. Так, ну давайте поговорим про передачу массива в
функции. То есть, как я уже сказал, массивы нельзя передать функции по значению. То
есть всякий раз, когда вы указываете в аргументах функции, что вы хотите
принять массив,で компиляторы это выглядит ровно так, как если бы вы хотели
принять просто указатель. То есть компилятору вообще плевать, что вы там указали.
Массив не массив, массив размера 10.
Массив размера миллион, а он будет принимать указатель.
Это ничего не сделать нельзя. И к сожалению это иногда бывают проблемы. Почему?
Потому что, когда вы в аргументах функции указываете, что
если вам нужен массив размера 50, то вы что-то имеете в виду.
То есть вы, наверное, имеете в виду, что вы работаете с первыми 50 элементами массива.
И чем это плохо?
Если вы пытаетесь использовать эту функцию для массива размера 50, то все, наверное, будет работать нормально.
Если вы пытаетесь использовать, в общем, вашу функцию для массива размера 100,
то всё тоже, кажется, будет нормально.
Ну потому что вы как бы в функции сказали, что вы будете использовать только первые 50 элементов,
а передали массив размера 100.
Ну хорошо, работать с первыми 50, вы никуда за границами массива не выходите,
но при этом, если вы будете передавать мессив feminum в функцию,
массив размера 10, то тут может возникнуть беда.
Почему?
Потому что, вроде как, пользователь,
который пользуется вашей программой,
видит, что вы указали массив 50,
когда вы указывали, что хотите принимать массив размера 50,
этим что-то сказать. Но при этом, если вы передадите в эту функцию массив размера
10, то компилятор ничего не скажет. Почему? Потому что для него что-то указатель,
что это указатель. То есть он выполняет преобразование массива в указатель.
А указатели ничего не знают про размер памяти, на который они указывают.
Поэтому если вы передаете массив размера 10, то возникает проблема потенциальная.
Согласны? Как это этой проблемой избавиться? Может кто не знает?
Что? Ну, наверное, не очень интересно передавать и массив, и размер.
То есть нужно отдельно... То есть тогда для каждого массива,
представьте себе, что у вас куча массива, тогда для каждого массива нужно еще
помнить его размер. Но как наверное хочет, чтобы компилятор сам...
Он же умный, он же видит ваш код. То есть он читает вашу программу,
то есть не только вы ее читаете семинарист. Компилятор, наверное, тоже должен
чем-то заниматься. Вот как заставит компилятор проверять размеры ваших массивов,
не передавая отдельно какие-то аргументы.
Да?
Например, да.
Например, передать по ссылке или по указателю.
Действительно, можно передать указатель на массив.
Указатель на массив
это вполне себе определенный тип.
Как я уже писал,
я писал, как он выглядит.
В частности,
указатель на массив размера 50
выглядит следующим образом.
И вот собственно здесь
я как раз объявляю,
что моя функция принимает указатель
на массив размера 50.
Ну и теперь смотрите, что происходит.
Если я передаю указатель на массив размера 50,
как в первом случае,
то все окей.
То есть я беру адрес массива
размера 50 и передаю его функцию.
Дальше.
Я пытаюсь передать функцию
указатель на массив размера 10.
И вот тут компилятор начнет жаловаться.
То есть он выдаст вам ошибку.
Он скажет, что
вы передаете мне указатель
на масив размера 10, хотя я
ожидаю указатель на массив размера 50.
Ну, согласитесь, что указатель на участок памяти
размера 10 и указатель
на участок памяти размера 50
это разные вещи.
Ну и то же самое касается, когда вы передаете
указатель на массив большего размера.
То есть указатель на массив размера 10
и указатель на массив размера 100
это разные типы.
И тут компилятор вам дает ошибку.
Аналогичным поведением может добиться вот, как вы правильно сказали,
передачи ссылки на массив. То есть ссылка на массив выглядит точно так же, как и указатель,
только вместо звездочки вы пишете амперсант. Поведение абсолютно точно такое же. Ссылка на
массив размера 10 и ссылка на массив размера 50 абсолютно разные типы. И вот как раз таки
на этой разнице можно добиться ошибки эмпиляции. Все понятно. Ну и некоторые правила работы с
массивами, я напомню, я все помню. Нельзя создавать массивы ссылок и массивы функций.
Массивы ссылок и массивы функций запрещены. Эти все синтаксисы, а вот это у вас не
скомпилируется. Но при этом можно создавать массивы из указателей и массивы из указателей
на функции. То есть если вы хотите завести массив функции, то вам на самом деле нужен массив
указателей на функции. Если вам нужен массив, который ведёт в какие-то другие элементы,
то вам нужен массив из указателей. Первое правило. Второе, нельзя создавать
с неизвестным числом elementos, но можно его объявить.
Все понимают рать между определением и объявлением.
То есть объявления вы просто вводите в некоторое имя.
Определение – это вы, грубо говоря, выделяете память под этот участок.
Поэтому, естественно, определить массив с неизвестным числом элементов нельзя.
Потому что сколько элементов вам нужно выделить – неизвестно.
Поэтому, если вы используете какой-то такой синтаксист,
то у вас будет ошибка амп marti what.
Если вы используете вот такой синтаксист,
то тут ошибки амп marti what нет, почему?
Да, потому что это не массив с неизвестным числом аргументов.
Это специальный синтаксис, который говорит о том, что компилятор сам определит, сколько элементов мне нужно.
Вот вы перечисляете какие элементы, и компилятор сам считает, сколько элементов занимает ваш массив.
Ну, в частности, B имеет тип массив размера 3 из интов.
Ну а как объявить массив с неизвестным числом элементов?
Очень просто, можно добавить ключевое слово extern.
Extern означает, что вы объявляете массив, определен он в какой-то другой единице трансляции.
То есть, определен он в каком-то другом файле.
На первом семинаре, если вы этого еще не делали в первом семесте,
на первом семинаре вы обсудите, как писать многофайловые программы.
Я очень надеюсь, что вы активно будете писать многофайловые программы в течение этого семестра.
В общем, часто программы изделяют на несколько файлов.
И вот, например, в одном файле вы просто используете все эти имена, а в другом файле вы определяете.
Например, в одном файле вы можете написать определение, то есть у вас есть массив размера 10,
который сам состоит из элементов 1, 2, 3 и так далее 10.
А в другом файле вы просто его используете, просто объявляя его extern.
Еще правило. При сравнении массивов, это правило следует из того, что мы говорили в самом начале лекции,
при сравнении массивов сравниваются на самом деле не сами массивы как значения,
а просто сравниваются их адреса.
Поэтому если вы сравниваете два разных массива, то есть массивы, которые лежат в разных ячейках памяти,
у вас всегда будет false, Excel, millise ve Pickups.
Потому что их адреса всегда разные, даже insight·refundlex tas.
Даже несмотря на то, что их контент может быть одинаков.
Просто так нельзя. Нельзя применить негативно равно равно или негативо не равно jackun catch.
Так, ну массивы нельзя присваивать друг к другу, к сожалению.
То есть если у вас есть какой-то массив b,
который вы чем-то инициализировали, а потом завели массив a,
и вы хотите скопировать элементы b в массив a, то просто присваивать у вас так не получится сделать.
Ну просто так нельзя, нет такого синтезиса.
Есть исключения, связанные со строками, а мы об этом поговорим чуть позже.
Но есть небольшой лайфхак, если все-таки хочется присваивать один массив другому.
Оказывается, что если вы заводите массив в качестве поля структуры,
вы же обсуждали структуры, да?
В общем, если вы внутри структуры заводите массив, то внезапно присваивание начинает работать.
Ну вот, честно, я тут завел структуру s, внутри завел поле array размера 3,
создал переменную c типа s, создал переменную d типа s,
и присвоил один элемент структуры другому элементу структуры,
и у меня внутренние массивы взяли и скопировались.
Точнее, один массив взял и скопировался в другой.
Это полезный лайфхак, запомните его, он вам пригодится еще.
То есть структуру можно присваивать свободно, даже если там есть массивы.
Массивы тоже будут копироваться прям по байтову.
Ну и коротко про динамические массивы.
Динамические массивы, все то, о чем мы говорили до этого, это стековые массивы.
То есть это массивы, которые залодятся на стеке.
То есть вы знаете, что есть стековая память, есть глобальная область памяти,
есть статическая, есть динамическая.
Все то, о чем мы говорили до этого, это стековая память, то есть массивы выделяются на стеке.
Есть еще динамические массивы, которые выделяете в куче.
Ну и химтоксис, я думаю, вы помните, это new int,
и в фейератной скобке вы указываете количество элементов, которые вам надо.
При этом new возвращает вам реально указатель.
Нет. Динамические массивы, можно считать динамический массив, это указатель.
Точнее Saidack Nemesis выработывает динамическую массиву только через указатель.
То есть new возвращает вам не указатель на массив,
а он возвращает чисто numbick, то есть указатель на первый элемент.
То есть тут никаких приколов нет.
Сайзов от new int и сайзов от указателя окажутся равны.
Да, и такой вопрос тоже в аудиторию, вот как вы думаете, а зачем нужны вообще динамические массивы?
Ну, смотрите, у нас есть стековые массивы, которыми, ну, вроде как, можно пользоваться свободно.
Зачем динамические массивы? Зачем какой-то new? Ведь каждому new нужно еще написать delete.
А если мы используем обычные стековые массивы, то там ничего не нужно писать.
Так, вот я слышал первую идею, что переполнение стека. Да, действительно, стековая память, она ограничена.
То есть размер кучи может быть достаточно большой, ну, это почти там, размер, доступный вам в оперативной памяти.
Ну, а стековая память может быть ограничена. Но при этом, если вам не хватает стековой памяти,
ну, вы можете в параметрах компилятора указать, что вам нужен какой-то увеличенный размер стека.
Ну, то есть, естественно, там не до бесконечности, но вот так. А еще какой? Я еще слышал.
Что еще раз? Чтобы не было утечки. Ну, стековые массивы как раз не утекают никогда.
Ну, как раз-таки это довод против того, чтобы использовать динамические массивы, потому что не утекают.
Да? Сейчас, сейчас там кто-то руку поднял, да.
Чтобы из разных блоков можно было использовать…
Ну, а почему бы, ну, можно же завести один, можно же тоже завести стековый массив и работать с указателем на него, то есть из разных блоков тоже.
Ну, сейчас, например, завести глобальный массив из различных функций, из различных блоков, просто-напросто через указатель использовать его значение.
Так, еще какие идеи?
Смотрите, динамические, стековые массивы, размер стековых массивов, самое главное отличие, размер стековых массивов обязан быть константой времени компиляции.
То есть, если вы попробуете написать какой-то такой код,
то этот код не является корректным. Почему? Потому что n, в данном случае, размер массива, не является константной времени компиляции.
А теперь вопрос, а кто такой писал и у кого такое работало?
Вот, отлично, отлично. Ну, в общем, здесь нужно поговорить про отличия, в общем, тут нужно превластовствовать про язык C++.
Что такое язык C++? Это способ самовыражения или язык программирования? В общем, нет. Что такое язык C++?
Описано в стандарте языка C++. Кто-нибудь видел такой документ, как стандарт языка C++?
То есть, не справка, а прям документ. В общем, рассказываю. Есть стандарты языка C++.
Это такой огромный документ на примерно две тысячи страницы, в котором вот четко описано по полочкам, что такое язык C++ и что не является языком C++.
В общем, если вы хотите узнать, что такое язык C++, то вот эти две тысячи страницы. Там все описано.
Что должно происходить, если вы напишете то-то? Что должно происходить, если вы напишете другое? Что будет происходить, если вы напишете что-то еще?
В общем, полное описание стандартной библиотеки, что там, что делать, за какое время и так далее.
Вот это вот полная спецификация языка C++. Такой вот чисто сухой и технический документ.
Естественно, по нему язык C++ выучить невозможно, но просто это некоторый технический документ,
в котором можно обращаться, если у вас там что-то идет не так. В общем, есть документ.
А есть компиляторы. Компилятор – это программа, которая просто берет ваш текст, который написан на языке C++
и переводит его в некоторый исполняемый файл, то есть файл, который можно запустить на компьютере.
Значит, компилятор – это программа. Программы пишут люди.
Естественно, люди пытаются написать так, чтобы это соответствовало некоторому, то есть соответствовало этой самой технической спецификации,
то, что написано в документе. Но, так как программы пишут люди, то, естественно, возможны баги.
Возможно, баги, возможно, какие-то неточности, то есть что-то работает не так, как описано в стандарте.
Какие-то фичи, может быть, еще не реализованы.
По-моему, сейчас до сих пор не существует еще ни одного компилятора, который даже 17-й стандарт полностью поддерживает.
Ну, 20-й точно никто еще не поддерживает, но вот 17-й тоже не полностью реализован.
Существуют баги. А что еще существует? Осуществуют фичи.
То есть фичи, которые создатели компиляторов пытаются привнести, то есть какие-то фишечки.
Например, они говорят, что по стандарту массивы переменной длины запрещены.
То есть, если вы пытаетесь написать такой код со всеми включенными проверками,
в частности, если вы будете компилировать с параметром pedantic,
то компилятор выдаст вам предупреждение, что комитет по стандартизации языка C++
запрещает использовать массивы переменной длины.
То есть размер массива обязан быть константой времени компиляции.
Ну, тут может быть вопрос, а кто такой вообще комитет по стандартизации?
Почему он решает, как нам писать программу? В общем, комитет по стандартизации — это вот тот,
кто пишет эти самые документы, принимает стандарты языка C++, в общем, и все такое.
Да, но при этом компиляторы некоторые разрешают использовать массивы переменной длины
просто потому, что считают, что это иногда удобнее.
Ну и вообще, на самом деле, в языке C, который является прородителем языка C++
массивы переменной длины на самом деле разрешены.
Я, честно говоря, не знаю, как это там реализовано, но, в общем, они там разрешены.
Ну, поэтому некоторые компиляторы вам позволяют это делать.
Но если вы хотите писать переносимые программы, которые работают для любых компиляторов,
для любых систем и тому подобное, в общем, старайтесь писать так, как завещает стандарт.
Со всеми включенными проверками и так далее, и так далее.
Ключевое отличие динамических массивов от нединамических — это в том, что
массивы динамические могут иметь переменную длину.
То есть переменную в том смысле, что она может быть вычислена в процессе работы вашей программы.
То есть вы можете ввести ее с клавиатуры, а затем выделить столько памяти, сколько вам нужно.
Ну и главное правило динамических массивов — не забывайте, в общем, очищать за собой память.
То есть если вы в какой-то момент вызвали new, то для каждого new вы должны вызвать свой delete.
Это, я думаю, понятно.
Отлично. С массивами закончили. Есть вопросы по массивам?
Замечательно. Давайте тогда перейдем к строкам.
Ну, допустим, я написал вот такую программу, которая состоит из...
просто я в кавычках написал string.
Что такое в кавычках string?
И какой тип у этого вот чего-то?
Вот как это называется, то, что я написал в кавычках?
Что еще раз?
Это вы про тип говорите?
Тип константная строка. Ну окей.
Что?
Константный указатель. Так, еще.
Указатель на константу.
Массив констант. Вот, это более точный ответ.
Да, действительно. Ну, во-первых, что такое string?
Вот то, что вы пишете в кавычках, называется строковым литером.
Ну, знаете, есть литералы, то есть 1, 1.0 и так далее.
Вот то, что вы пишете в кавычках, это строковый литерал.
Строковые литералы имеют тип не char звездочка, не const char звездочка,
не char звездочка const и даже не const char звездочка const,
а имеют тип const char 7.
Ну, не то, что 7, а вот в данном случае имеют тип const char 7.
То есть массив константных чаров.
То есть строковый литерал – это массив.
Вот, в чистом виде массив.
Почему 7? Ну, потому что 6 элементов и плюс в конце стоит завершающий 0.
То есть любая строка должна завершаться нулевым символом.
Ну, снова, как это доказать?
Очень просто. Давайте я попрошу sizeof string.
Если я попрошу sizeof в кавычках string, он мне выдаст 7.
Потому что размер чара размера 7 – это 7 байт.
А если я попрошу sizeof string, он мне выдаст 7 байт.
А если я попрошу sizeof string, он мне выдаст 7.
Потому что размер чара размера 7 – это 7 байт.
Если я попрошу размер const char 7, то есть типа.
Вот, тип const char 7. Сколько занимает байт памяти?
Тоже 7.
Если я спрошу, сколько байт памяти занимает указатель на константный char?
8.
Потому что любой указатель занимает 8 байт.
Ну, 4 или 8 байт.
Ну, и также я могу заставить компилятор выдать мне всю правду.
То есть загнать спицы под ногти и вот попытаться добиться от него правды.
Ну, вот в частности я могу строку умножить на 4.
Строковый литерал умножить на 4.
И он мне скажет, что я не знаю, как произойти умножение между int и массивом char размера 7.
Ну и так, это массив.
Так как строковый литерал – это массив, то у него можно обращаться к элементам по индексу.
Ну и бла-бла.
Ну, единственное исключение.
То есть массивы char ведут себя точно так же, как и обычные массивы, с единственным исключением.
А исключение заключается в том, что вы можете присваивать один массив char в другом массив char при инициализации.
Важно, что только при инициализации.
То есть вот так, как написано в первой строке, писать можно.
Так, как написано во второй строке, писать нельзя.
Потому что это не инициализация.
Это уже переприсваивание, так скажем.
С обычными массивами такое не прокатит.
А вот с массивами char так можно поступать.
Ну и еще один интересный эффект.
Вот, смотрите, допустим, у меня есть две строки, два строковых литерала – keq и lol.
И я пытаюсь сравнить keq равно равно keq и keq не равно lol.
И вот оказывается, что если я сравниваю keq с keq, то у меня воздает true.
Если я сравниваю keq с lol, то у меня возвращается false.
Так это что получается, что у меня строки тоже сравниваться могут?
То есть могу ли я сравнивать строки с помощью равно равно, неравно, меньше, больше?
Если что, это правда.
Если я сравниваю keq равно равно keq, то будет true.
Если я сравниваю keq не равно lol, то будет false.
Словаря, а что к словарю?
Ну нет, по буквену точно они не сравниваются.
А keq и keq – это не разные массивы?
Нет, это один.
В целом, да, но на самом деле не всегда так.
Объяснение, почему для строк может показаться, что это работает, хотя на самом деле нет.
Строки на самом деле тоже сравниваются просто как указатели.
То есть если вы пытаетесь сравнить один массив чара с другим массивом чаром,
то тоже будут сравниваться их указатели, то есть указатели на первые элементы.
Немного про строковые литералы, как они вообще расположены в памяти и тому подобное.
Компилятор, когда анализирует вашу программу, он встречает ваш строковые литералы.
Keq, lol, string и так далее.
Так как это массивы, они должны где-то храниться, согласны?
И для строковых литералов компилятор заводит специальную область,
которая на самом деле является глобальной областью.
В глобальной области он заводит так называемую таблицу строковых литералов.
То есть у него есть такая специальная таблица, в которой он заводит вот эти вот самые массивы.
И далее всякий раз, когда вы обращаетесь к какому-либо строковому литералу, например Keq или lol,
он идет в таблицу строковых литералов и смотрит какие элементы там лежат.
То есть можно считать, что строковый литерал это такое имя для некоторой записи вот в этой таблице.
Грубо говоря, когда он встречает вот такую запись Keq, он просто идет в эту таблицу и смотрит,
какой массив там на самом деле лежит.
Если он встречает lol, он идет в эту таблицу и смотрит, какой элемент там на самом деле лежит.
Поэтому когда вы сравниваете Keq и Keq, то на самом деле сравниваются адреса.
Но так как литерал Keq обращается к одной и той же области памяти, вам возвращается true.
Но при этом это не гарантировано. То, что так получилось, это повезло.
На самом деле компилятор может вполне себе для каждого отдельного строкового литерала
завести отдельную строку в таблицу строковых литералов.
То есть вполне возможно, что у вас есть какая-то другая запись, которая содержит то же самое значение Keq.
И когда вы обращаетесь к Keq один раз, когда вы обращаетесь к Keq второй раз,
у вас компилятор может обращаться к абсолютно разным элементам памяти.
Поэтому то, что это работает так, как правило это работает так, но это не гарантировано.
Поэтому вот так вот сравнивать строки нельзя. Понятно?
Понятно про таблицу строковых литералов, что там происходит и так далее.
Замечательно.
Давайте я до конца дойду эти слайды и потом сделаем первых пять минут.
Ну и давайте про строки. Что такое строки?
Вот на самом деле массив чаров и строки это разные вещи. Все это понимают.
Что не любой массив чаров это на самом деле строка.
Ну вполне возможно у меня есть, ну представьте себе, что у меня есть массив чаров,
в котором хранится просто-напросто все буквы латинского алфавита.
То есть A, B, C, D и так далее. Но при этом это не строка, это просто массив с каких-то элементов.
Так вот строкой в языке C, в языке C++ называется часть, какая-то часть элементов массива чаров,
которая ограничена в конце элементом ну короче нулевым терминатором, ноль символом.
Вот все, что ограничено ноль символом является строкой.
Если это что-то не ограничено нулевым символом, это строкой не является.
Это является просто частью массива или мотивом.
Ну и давайте посмотрим на примеры.
Как я могу работать со строками?
Ну например я могу завести указатель на строку.
То есть я могу сказать, что cons char звездочка static string равно low.
Куда указывает static string? Вот этот указатель static string куда указывает?
Да, в таблицу строковых литералов.
То есть у меня есть некоторая таблица, в которой хранится low с завершающим нулевым символом.
И вот этот указатель указывает на начало этого самого массива.
Я могу завести строку в стеке.
То есть я могу сказать char stack string 4 и присвоить ему keg.
Тогда у меня вот эта строка keg будет храниться в стеке.
То есть три элемента на keg и, собственно, на последний элемент 0.
Я могу завести вот такую штуку char yet another string и присвоить ему справа фигуринскоп их keg.
Могу завести строку в динамичной области памяти.
То есть могу завести в hipn, то есть завести new char 9 и присвоить ей указатель на эту выделенную память.
Сейчас о этом поговорим.
Давайте вот про последние строки, где CIN.
Там, где stack string, я могу вести строку с клавиатуры, то есть с консоли.
То есть если я веду STD CIN stack string, то я могу вести строки размера не более чем 3.
Понятно, почему не более чем 3, да?
Потому что у меня массив имеет размер 4, первые три символа под строку,
и последний символ зарезервирован специально под нулевой символ.
То же самое для строки в динамичной области памяти.
Я выделил массив размера 9, поэтому в этом массиве я могу хранить строки размера максимум 8.
То есть больше чем 8 я завести строку не смогу.
Потому что у меня последний символ нулевой будет негде хранить.
Ну и, собственно, вопрос, в какой строке подвох?
В третьей, почему?
Да, отлично.
В третьей строке нет нулевого завершающего символа.
Понятно, почему?
Да, потому что когда я указываю в фигурных скобках, перечитаю элементы,
то у меня, собственно, первый элемент копируется, второй элемент копируется,
третий элемент копируется, а четвертый элемент, собственно, не создается,
вы его не указали.
Поэтому если вы хотите таким образом создавать строку,
то нужно явно указывать нулевой символ.
В этом принципиальное отличие, строки от массива.
В третьей строке находится не строка, а всего лишь массив из трех элементов.
Ну и, как вы знаете, для строк есть очень обширная богатая библиотека,
которую студенты очень любят пользоваться, это c-string,
как копировать строки с помощью strcpi, как сравнивать строки с помощью strcmp,
брать размер строки можно с помощью starlen, и так далее, и так далее.
Естественно, нет. Что это за бред? В чем проблема?
Главное c-style-строк.
Как вы считаете, в чем главная их проблема?
Да нет, они на самом деле довольно компактные.
По одному байту на символ.
Да, отлично.
Грубо говоря, строка не знает свой размер.
Нонсенс.
Если вам дана строка, то просто так узнать размер вы не можете.
То, что размер строки вычисляется, это одна из главных проблем.
И вот на самом деле большинство из этих функций работают за размер длины строки, минимум.
Но многие из них на самом деле могут работать из константа и в какое-то логиохимическое время, и так далее.
И просто-напросто потому, что многие строки просто-напросто не знают свой размер.
И это печально.
Ну, давайте попробуем все-таки, с учетом того, что у нас есть вот такой вот неудобный интерфейс для работы со строками,
что размер строки вычисляется за длинное время, и так далее, попробуем решить какую-нибудь примерную задачу.
В общем, посчитать количество входения символов в строку.
Ну, заводим функцию countSymbol, который возвращает sizeT, то есть количество входений.
Вот, мы принимаем указатель на строку, то есть указатель на начало строки,
и применяем символ, который нужно посчитать в этой строке.
Ну, задача понятна, да?
Ну и вот вам пример решения.
Я просто прохожу в цикле от нуля до размера строки,
и если у меня i-то элемент строки совпадает с символом, то я увеличиваю счетчик.
В конце я этот счетчик возвращаю. В чем проблема хором?
Да, это все работает за o от n квадрат. Почему?
Ну снова, потому что стрлен каждый раз будет вам заново вычислять размер строки,
то есть он будет проходить от начала строки до конца, вычислять размер и так на каждой итерации.
Как решить эту проблему?
Да, одно из возможных решений – это просто взять и сохранить в отдельную переменную,
то есть написать там что-то типа size равно sterlen, ну блабла.
Ну а второе решение – просто-напросто забить и итерироваться по строке,
как по обычному массиву с помощью указателя,
и проверять, встретили мы нулевой символ или нет.
Как только мы встретили нулевой символ, значит мы добрались до конца строки и завершаем работу.
Вот и все.
Это к вопросу об удобстве использования обычных C-шных строк, обычных C-шных массивов и так далее.
Давайте резюмируем.
C-style массивы, тековые массивы, они более-менее удобны,
но при этом мы не можем их просто так взять и передавать в функцию,
они постоянно спонтанно берут и переводят с указателем, что нас не всегда устраивает.
При передаче в функцию они не всегда проверяют размер и так далее.
Плюс они могут иметь какой-то расширяющийся размер.
Динамические массивы. Динамические массивы могут иметь произвольную длину,
которую вы укажете на этапе исполнения, но при этом вы должны помнить про то,
что нужно постоянно удалять память, ну, очищать память.
Строки вроде как тоже вполне себе простые.
Они являются почти всегда массивами.
Не можно обращаться по индексу, они занимают довольно мало памяти,
но при этом нужно постоянно помнить, что StarLeno вычисляется за линейное время.
Многие функции работают тоже из-за этого неэффективно и так далее и так далее.
И на самом деле кучу из этих проблем, да, это все было резюме, значит,
все, что мы узнали вот за эти сколько? 40 минут.
И на самом деле все эти проблемы можно решить с помощью
так называемого объектно-ориентированного подхода,
которым будем заниматься в течение этого семестра.
Но, к сожалению, объектно-ориентированное программирование
тоже заставляет очень много проблем и очень много сложностей.
И вот я надеюсь, что вот в течение этого семестра мы их все преодолеем
и сможем писать очень крутые классы как массивов, так и срок, и кучу-кучу всего.
На этом первую часть предлагаю закончить и 5 минут перерыв.
Так, первое, о чем хотелось бы поговорить
в рамках уже курса объектно-ориентированного программирования,
это про обобщенное программирование, ну, либо
про C++ шаблоны функций, так называемые.
Значит, немного истории.
От языка C нам у нас следована довольно обширная библиотека,
в частности, есть библиотека для работы с различными математическими функциями.
Вот. Ну и вы знаете, что
у нас есть библиотека для работы с математическими функциями.
Вот. Ну и вы знаете, что, например,
для того, чтобы вычислить абсолютное значение
ну или модуль числа, существует довольно много различных функций.
В частности, есть функция ups, есть функция laps,
есть функция liliups, fabs и так далее.
И при этом каждый из функций принимает различный тип,
возвращает различный тип, ну, зависит от того, что вы передали, и так далее.
Ну, снова вопрос. Как вы думаете,
для чего нужно такое большое разнообразие функций?
Ну, зачем для каждого типа нужно заводить отдельную функцию
с отдельным именем?
Да, отлично. Значит, в языке C нет перегрузки функций.
То есть такого понятия, как перегрузка функций, нет в языке C.
Ну, что такое перегрузка функций? Давайте напомним.
В общем, перегрузка функций — это возможность создавать функции
соединяется с одним именем, но с различными аргументами,
с различными типами аргументов. Ну окей.
Ну, смотрите, в языке C++ у нас есть перегрузка функций,
мы можем сделать то же самое, но при этом назвать все функции одинаково.
Класс?
Супер, да? То есть куча функций,
которые делают одно и то же, но при этом принимают различные типы,
но называются одинаково. В чем проблема?
Ну, казалось бы, ну хорошо, одно имя, но теперь можно удобно
пользоваться такими функциями. То есть неважно, что вы передаете
функцию abs, у вас абсолютное значение будет вычислено
корректно, и плюс возвращаться будет корректное значение.
А в чем проблема-то?
Ну, пофиг на обратную совместимость.
Нам на язык C уже наплевать. Мы пишем на плюсах.
Ну да, дублирование кода, короче говоря.
По-умному, так, на секундочку.
Дублирование кода плохо тем, что если вы совершили ошибку
в каком-то одном месте, то вам придется это все продублировать
и в других местах. Нужно проследить, а где вы еще используете этот код,
нужно не забыть, там везде все исправить и так далее и так далее.
В общем, проблема. Поэтому, наверное, хотелось бы
упростить жизнь не только пользователю, то есть пользователю
вашей библиотеки, который может просто вызвать abs
от произвольного типа, но и при этом, наверное, хотелось бы упростить
себе жизнь, как написать такие программы более четко, лаконично и понятно.
И о чудо в языке C++ есть такой инструмент,
и он называется шаблонной функцией.
В общем, с использованием шаблонной функции все то, что было написано здесь
можно легко уместить вот буквально в сколько? В 3-4 строчки.
Вот таким образом.
Все интриговал? Подробнее.
Как написать шаблонную функцию, что она вообще делает?
Шаблонная функция пишется следующим образом.
Сначала идет преамбула. Сначала вы говорите,
что вы на самом деле хотите написать шаблонную функцию.
Для этого вы пишете ключевое слово template, и дальше в треугольных скобках
вы перечисляете шаблонные параметры.
В частности, вы можете написать template class t, и при этом вы говорите,
что я не знаю, какой тип мне будет подан в итоге,
но пока вместо типа использую тип t.
Просто абстрактное имя.
Либо вы можете написать template typeName t.
Слова typeName и class абсолютно в этом контексте взаимозаменяемы.
То есть нет абсолютно никакой разницы, используете вы class или typeName.
Просто класс писать чуть короче, а typeName чуть понятнее.
Решайте, что вам более приятно.
Сначала вы пишете преамбулу template class t.
А дальше вы пишете функцию так, как вы бы ее написали обычным способом,
но просто везде вместо конкретного типа, который вам нужен,
подставляете тип t.
То есть вы говорите, я не знаю, какой тип будет в итоге мне нужен,
но пока использую вместо этого типа t.
Какое-то пропущенное значение.
Например, для абсолютного значения вы пишете abs tx,
то есть вы принимаете какую-то переменную типа t,
она возвращает t.
И что вы должны сделать с этим x?
То же самое для суммы.
То есть вы можете принять два аргумента,
оба из которых будут иметь один и тот же тип t,
но какой тип будет уже позднее.
Sum tx ty, return x plus y.
Если вам нужно несколько параметров,
то вы уже сам обязаны принимать два аргумента одного и того же типа.
Потому что вы указали, что у вас первый аргумент имеет тип t,
и второй аргумент имеет тип t.
Мы чуть позже поговорим, как компилятор понимает,
какой тип нужно подставить, но пока просто нужно запомнить,
что если вы указали два одинаковых типа, то значит при вызове они должны быть одинаковы.
А что если вам хочется два разных типа?
То есть вы тоже не знаете, какие типы вам будут переданы в итоге,
но при этом вы хотите написать более общую функцию.
Для этого вы можете просто через запятую указать шаблонные параметры.
То есть templat класс t, запятая класс u.
Тогда вы можете принимать первый аргумент с помощью типа t,
а второй аргумент по типу u.
Ну в частности функция print,
которая принимает два произвольных значения и печатает их.
Понятно? Вот это простейший синтаксис, как все выглядит.
Как использовать шаблонные функции?
Шаблонные функции также просто используют,
как использовать перегрузку функций.
То есть вы просто берете и вызываете эту функцию как обычную функцию.
В частности, abs от 0.0.
Что такое 0.0? 0.0 это литерал типа double.
Поэтому вместо типа t у вас в итоге будет поставлен тип double,
и все будет работать так, как будто бы вы написали функцию abs,
которая принимает double и возвращает double.
Ну то же самое для функции sum.
Если вы передаете 1 и 1, то оба значения имеют тип int,
поэтому тип t выводится как int,
и у вас как бы производится сложение двух интовых чисел,
и возвращается int.
Ну вот проблема, про которую я говорил.
Если у вас sum принимает два аргумента разных типов,
в частности 1 и 0.0,
1 имеет тип int, 0.0 имеет тип double.
С одной стороны компилятор думает, что тип t должен быть int.
С другой стороны компилятор думает, что тип t должен быть double.
Компилятор жалуется, выдает ошибку компиляции и говорит,
что я не понимаю, какой тип t вы имеете в виду, int или double?
Вот так нельзя.
Ну еще одна проблема, то есть можно написать функцию,
которая вообще не принимает ни одних аргументов, например get 0.
Get 0 это такая функция, которая возвращает 0 произвольного типа.
Например типа float, типа int и так далее.
Вот если вы просто возьмете и вызовете эту функцию get 0,
то у компилятора в принципе вы не даете им никакого шанса вывести тип t.
То есть компилятор вообще не понимает, какой тип t вы имеете в виду.
Ну естественно тут тоже возникает ошибка компиляции.
А как все-таки застаивать вот этого примера,
которые не работали, работать?
Ну есть еще альтернативный способ использовать шаблоны,
это явно всегда прописывать тот тип, который вам нужен.
Как это происходит? Вы пишете название шаблонной функции,
дальше в треугольных скобках указываете тип,
который нам на самом деле нужен. Ну например в первом примере,
1.1, у вас тип t обычно уводится как int.
Ну а что если вы хотите, что у вас тип t был не интом, а лонгом?
То есть вы хотите складывать два лонга.
Ну один из способов это привести 1 к типу лонг,
вторую единицу к типу лонг и просто вызвать функцию sum.
А можете просто в треугольных скобках явно указать то,
чего вы хотите. Вы хотите использовать функцию sum
с типом t равным лонгу.
И все будет работать.
Дальше, в этом примере у вас
ничего до этого не работало.
Но здесь вы можете явно указать, какой тип вам нужен.
Вы здесь явно указываете, что в качестве типа t вам нужен дабл.
И уже никаких проблем не будет. То есть 0.0 уже является даблом,
а первая единица будет приведена в итоге к даблу.
Потому что вы сказали, что вы хотите принимать дабл.
Ну и в последнем случае, когда у компилятора нет шансов ничего вывести,
вы можете просто в треугольных скобках указать, какой тип вам нужен.
И тогда вот этот get 0 в треугольных скобках float
будет возвращать вам 0 типа float.
То есть два способа вызвать шаблонную функцию.
То есть вы можете довериться компилятору, и он выведет вам все типы автоматически.
Ну и если вам не нравится, как компилятор выводит тип,
или компилятор в принципе не может догадаться, какой тип вам нужен,
вы можете в треугольных скобках явно указывать нужный вам тип.
Круто?
Да, да.
То есть вы имеете в виду следующее, что если у вас есть, допустим, функция print,
как в предыдущем примере, который вынимает tx и uy,
да, вы можете явно указать print int float треугольных скобок.
Ну и дальше указать параметры.
Да, через запятую тоже можете указывать все те параметры, которые вам нужны.
Но об этом еще подробнее поговорим, как это все будет работать.
Пока вопросов нет по базовому синтаксису.
Отлично. Давайте перейдем к чуть более сложной вещи.
Про то, как компилятор выводит тип.
Как компилятор понимает, какой тип вам на самом деле нужен.
Правил на самом деле несколько, и они все довольно простые.
Это не полный перечень правил, но они покрывают 95% того, что нужно практике.
Вот, допустим, у меня есть такая функция f, которая принимает два аргумента,
x и y, и оба имеют шаблонный тип t.
Правила такие.
Когда вы передаете функцию f какие-то аргументы,
происходит следующая вещь.
Const и volatile к валификаторе игнорируются.
То есть не важно, передали ли вы const int, передали ли вы volatile float.
Не важно, вот этот const и вот этот volatile отбрасываются.
То есть в итоге x будет выведен без const, y будет выведен без const.
Первое правило.
Второе. Ссылки отбрасываются.
То есть если вы передали ссылку на int, то в итоге x будет иметь тип int, а не ссылка на x.
На самом деле второй пункт он чуть более широкий,
и мы об этом поговорим позже.
Когда вы будете готовиться к экзамену, я в камеру скажу вам из будущего.
Смотрите, второй пункт имеет в виду следующее.
Игнорируется категория значения.
То есть не важно, что вы передали lvalue или rvalue,
то есть всегда будет приниматься только тип t по значению.
Так, если бы это было по rvalue.
Теперь к вам.
Третий пункт. Массивы.
Ой, третий пункт того, как происходит вывод типов.
Массивы не сводятся до указателей.
Ну, это стандартный пункт,
то есть если вы передаете функцию массив,
то на самом деле тип t будет выведен как указатель на первый элемент.
То есть массивы не принимаются.
Функции не сводятся до указателей на функцию, но тут тоже стандартная вещь.
То есть нельзя передать функцию, можно передать только указатель на функцию.
То есть даже если в качестве аргумента вы укажете функцию,
то там будет иметь в виду указатель на функцию.
Ну, и пятый пункт, про который мы уже поговорили,
это типы, соответсвующие одному шаблонному типу
должны совпадать. То есть у вас не может быть такого, что тип T вывелся и как int, и как double.
Нет, один тип, одно значение. Да, непросто, понятно. Ну давайте упражнения, поупражняемся, посмотрим,
как это все работает. Ну вот та же самая функция f, которая принимает два аргумента типа T,
ну тип T это шаблонный параметр. У меня есть один аргумент X, переменная X, которая имеет тип int,
есть переменная CX, которая имеет тип constant int. Ну и давайте, собственно, посмотрим на вызовы
функции f. Вот в первом случае, какой тип T у меня выведется? Int. Ну тут все просто. Я передаю две
переменные типа int, соответственно, в качестве типа T вводится int. Во втором случае я передаю X и CX.
X имеет тип int, CX имеет тип constant. Какой тип выведется? Int. Почему int? Да, вспоминаем первое правило,
константность игнорируется. Отлично, T равно int. Так, ну я передаю CX и CX, какой тип выведется?
In. Да, снова константность отбрасывается, поэтому вот этот X и вот этот Y будут иметь тип int,
без константности. Так, усложняем задачу. Я завожу ссылку на X, называю ее rx, и завожу массив
int размер 11. Так, функцию я передаю CX и rx. Почему? Да, константность игнорируется, ссылочность тоже
игнорируется. Так, теперь я передаю адрес rx и передаю массив. Указатель. Все согласны, что указатель?
Да, адрес rx, что такое ссылка? Ну ссылка это по сути альтернативное имя переменной X. То есть rx
ссылается на то же самое, что X. То есть когда я беру адрес rx, я на самом деле беру указатель на int. А r
это вроде как массив, но при этом мы говорили, что массив не выводится до указателя. Поэтому и
слева стоит указатель на int, и справа стоит указатель на int. Да, поэтому тут выводится просто
int указатель. Так, я беру адрес CX и беру адрес X. Какие есть варианты? Указатель на int. Есть еще
варианты? Так, отлично. Давайте по порядку. Первый аргумент, какой имеет тип? Первый аргумент имеет
тип указатель на константный int. Второй аргумент имеет тип просто указатель на int. Что делать?
Давайте вариант громче. Не должно компилироваться. У кого еще есть версии? Кто считает, что это не
скомпилируется? Поднимите руки. Кто считает, что это скомпилируется, но не знает как? Кто все остальные?
Поднимите руки. Просто слушают меня. На самом деле это не скомпилируется. Почему? Потому что
константость игнорируется на верхнем уровне. Грубо говоря, если бы тут был, скажем,
cont стоял не здесь, а здесь, то есть если это был константный указатель, то тогда константость
указателя была бы проигнорирована. Все понимают разница между константным указателем и указателем
на константу. Если бы было так, то действительно все было нормально. Но ситуация у нас другая. У нас
есть указатель на int и указатель на const int. И вот это принципиально разные типы. Согласитесь,
это разные вещи. Указывать на вещь и указывать на неизменяемую вещь. Если бы оба были константные
указатели, то константа себе отбросилась. А тут у вас два разных типа. Указатель на int и указатель на
константный int. Это два разных типа, которые, скажем так, несовместимы друг с другом на прямую.
Поэтому тут будет ошибка эмпиляции. Ну и предпоследний пример. Тоже ошибка. Почему? Потому что с одной
стороны тип t выводится как int, с другой стороны тип t выводится как double. То есть тип выводится
отдельно для каждого аргумента. Для первого аргумента выявился int, для второго аргумента выявился
double. То есть два несовместимых типа. Ну не то что несовместимых, а просто конфликт. Поэтому тут
тоже ошибка эмпиляции. Так, ну и в последнем случае double. То есть мы явно указали double,
поэтому к эмпилятору ничего не остается сделать. Как вывести double? Все будет нормально. Ну и
действительно, кажется, нигде не набагали. Все нормально, все так и должно быть. Есть вопросы?
Такому-то из пунктов. Ну окей. Ну и то, про что мы говорили, про то, можно ли указывать несколько
типов через запятую, да, можно. Допустим, у вас есть функция f, которая принимает два разных
шаблонных параметра t и u. Тогда вот эта вот функция, тогда вот этот вызов теперь начинает
работать. До этого он не работал, потому что у вас был конфликт. Теперь конфликта нет, у вас один тип
выводится как int, а второй тип выводится как double, поэтому все нормально. Можно будет явно
указать два типа. То есть double и double. Тогда у вас и первый тип выведется как double, и второй тип
выведется как double. А можно поступить хитрее. Можно указать только один тип, и вот тут работает
следующее правило. Если вы указали не все типы, то есть не все шаблонные типы в треугольных
скобках, то тогда первые типы, которые вы указали, подставляются такими, какими вы указали,
а следующий тип выводится. То есть в данном случае тип t будет подставлен, а второй выводится на
основании того, что вы передали. Понятно? Да, ну то есть если у вас допустим есть, сейчас, сейчас все
появится. t, u, v. Ну вот, если вы указали три шаблона параметра t, u, v, а указали только первый,
то тогда у вас подставится в качестве типа t float, а типа u, v компилятор попытается вывести.
Ну указать первый и третий нельзя, указать второй и третий нельзя. То есть только либо
первые несколько, либо вообще никакие. Ну это как с аргументами по умолчанию функций,
то есть только первые несколько, а остальные нельзя. Окей? Так, второй тип. Ну как вы знаете,
функцию можно передавать не только по значению, но и по ссылке. Давайте рассмотрим правила,
как выводится аргументы, то есть как выводится шаблонный тип по ссылке. Тут на самом деле все
просто, тут все гораздо проще, чем вот с передачей по значению. То есть грубо говоря, если вы
передали аргумент по ссылке, то есть указали t с ссылка, то у вас никаких незаведения типов
не происходит. Тип выводится так, каким должен быть. Если вы передали константу, то выводится
констант, если вы передали инн, выводится инн, если вы передали указатель, то выводится ссылка
на указатель, что бы это ни значило. Ну и тут вот примеры, соответственно, у меня есть переменная
у меня есть константная переменная cx, у меня есть ссылочная переменная rx, у меня есть массив array,
как и в предыдущем примере. Если я вызываю f от x, то в качестве типа T у меня подставляется int,
ну и общий тип вводится как int&. Ну типа T это int, я вместо типа T подставляю int,
и получается int&. Если я беру константный int, то у меня тип вводится как const int,
ну и общий тип это const int ссылка, но ссылка на константный int. Если я перейду как ссылка на int,
то типа T тоже вводится как int, и итоговый тип тоже ссылка на int.
Если я перейду массив, то у меня массив принимается по ссылке на массив.
То есть массив не приводится к указателю на ersten элемент, а вот принимается вот массив как он есть.
То есть мы же знаем что массив можно принимать по ссылке.
это мы еще тогда на первой части лекции узнали, поэтому type-t выводится как n10
и общий тип это ссылка на массив...
Да, в третьей строке, ну смотрите, у вас rx это ссылка, поэтому вроде как,
наверное, кажется, на основе того, что я раньше сказал, так как неизвление
происходит, type-t должен вывести к ссылке, но при этом у вас не существует языке ссылки на ссылку,
ну поэтому чтобы не было такой, грубо говоря, тавтологии, у вас просто вместо
выводится в качестве type-t не int-ссылка, а просто int, но в итоге у вас все равно
получается int-ссылка, поэтому все нормально. Тут на самом деле более сложная проблема,
это я вот туда говорил, в чем на самом деле там проблема, но это вот через лекции 4
поймем, что на самом деле было. Ну просто на самом деле, короче, если tldr,
то такого типа как ссылка, ну скажем так, значение выражения не может быть ссылкой,
он может быть либо l-value, либо r-value, и здесь на самом деле вы подставляете функцию l-value,
поэтому выводится как обычный тип int, но при этом ссылка. Короче, сложно все, но это вас ждет позже.
Других вопросов нет? Ну и последняя строка в этом блоке f от нуля. Здесь ошибка компиляции,
я думаю, понятно почему, потому что нельзя создать ссылку на r-value, короче, нельзя создать ссылку
на временное значение, то есть нельзя написать вот так. Что? То есть вот так писать нельзя. Ссылка
обязательно должна быть связана с какой-то областью памяти, 0 это литералы, это просто константы,
которые вот встраивается в ваш код, у нее нет никакого адреса, она бездомная, поэтому на нее
ссылаться нельзя. Но при этом можно создать константные ссылки на литералы. Строковый литерал,
ну смотрите, массив должен быть сохранен, поэтому вот он хранится в таблице строковых литералов,
но обычные литералы, ну типа 0, 1, 1.0, ну они просто вот подставляются, ну просто их битвы
представление подставляется в нужное место и все. Ну у них нет какого-то постоянного места памяти.
Строковые литералы, это вам, строковые литералы, напоминаю, являются исключением, то есть строковые
литералы являются lvalue, то есть это единственные литералы, которые являются lvalue, все остальные
литералы являются rvalue. Давайте дальше. Значит, если вы хотите вот такую функцию передать константу 0,
то вам нужно в таком случае явно указать, что вы хотите использовать константную ссылку,
то есть вы пишете просто const int, и тогда у вас будет константная ссылка, а константную ссылку
можно провинциализировать константой, ну не то что константной, а литералом. Все, разобрались?
Следующий пункт, параметр шаблона по умолчанию. Ну смотрите, давайте аналогии с обычной функцией,
вот у вас есть функции, вы можете там указать аргументы по умолчанию, то есть вы можете,
например, указать функцию, которая принимает три аргумента, но при этом третий аргумент у вас
будет с значением по умолчанию, то есть вы можете вызывать функцию как с одним аргументом, так и с
двумя аргументами. Вот с шаблонами примерно то же самое, но только в следующем смысле. Вы можете
сказать, что в общем случае тип T должен выводиться, но если тип T невозможно вывести,
то нужно использовать аргумент, который вы указали. Ну вот, например, давайте вспомним наши примеры
с GetZero. GetZero не принимает никаких аргументов, поэтому компилятор в принципе не может догадаться,
какой тип вы имеете в виду, поэтому вот эта вот первая строка работать не будет. Понятно почему,
да? Потому что по этому вызову непонятно, какой тип T вы имеете в виду. Есть альтернатива, вы можете
в треугольной скобке указывать, что, например, какой тип вы хотите, ноль какого типа вы хотите
вернуть. Ну вот, сейчас если GetZero от double, будет возвращать вам ноль типа double. А можете поступить
хитрее. Можете сказать следующим образом. Вы можете завести шаблонный параметр по умолчанию,
то есть вы можете сказать, что если тип T по какой-то причине вывести невозможно, то используй int.
Синтаксис, я думаю, понятен, класс T и равно int, то есть тип, который вам нужен. И тогда вот этот вот
синтаксис начинает работать. Когда вы вызываете GetZero без аргументов, компилятор понимает,
что тип T вывести невозможно, но при этом у него есть аргумент по умолчанию, который,
собственно, он будет подставлять в этот момент. Ну и при этом старый синтаксис тоже
остается валидным, то есть если вам нужен конкретный тип, вы его можете указать без проблем.
Ну и еще один факт, который нужно знать про параметр шаблона по умолчанию. Параметры шаблона по
умолчанию могут ссылаться на предыдущие шаблонные параметры. То есть вы можете сказать,
что template класс T, а класс U по умолчанию должен быть таким же, как и тип T. То есть если шаблонный
параметр U вывести невозможно, то он должен быть таким же, как и тип T. Ну вот примеры. То есть вы
можете для функции f указать оба параметра сразу, то есть int и double. Тогда тут вывода типа нет, то есть,
как говорится, обычно говорят, что нет контекста вывода. То есть ничего не уводится, у вас просто
вместо типа T подставляется int, а вместо типа U подставляется double. Во второй строке у вас в качестве
типа T выводится float, а тип U компилятор вывести не может, потому что у вас нет аргумента типа U.
Видите, да? Но при этом вы до этого сказали, что тип U в общем случае должен быть таким же,
как тип T. Поэтому если вы указали тип T как float, то тип T у вас равен float U и тип U
тоже равен float U. Все нормально. Ну и последний вариант. Вы вызываете f от нуля и что происходит?
У вас тип T выводится как int, потому что есть аргумент x типа T. То есть тип T выводится как int.
Тип U вывести невозможно, но при этом компилятор понимает, что он должен быть таким же, как и тип T.
Поэтому с и U и T это тип int. Понятно, да? Вопросы?
Я пишу класс T, а дальше что? А, просто T.
А у вас не получится, то есть если вы попытаетесь сделать вот так? А, вот так? Не-не-не, это не сработает.
То есть если вы передаете 0 и 0.0, то нет, то считается, что... Тут есть контекст вывода. То есть компилятор
попытается что-то вывести, и у него не получится. Он скажет, что у вас есть противоречие.
Окей. Да, ну еще один важный пункт, про который важно помнить. Сейчас я договорю. Вот этот пункт.
Значение аргументов по умолчанию. Давайте издалека начнем. В общем, для шаблонных функций тоже можно
писать аргументы по умолчанию. То есть вы можете писать шаблонную функцию, в которую сдадите
аргументы по умолчанию, и тогда эту шаблонную функцию можно вызывать как с одним аргументом,
так и с нулем аргументов. Но важный момент. Вот это вот значение по умолчанию, которое вы указываете
вот здесь, оно вообще никак не влияет на вывод типа. То есть вот это значение в момент вывода типа
будет проигнорировано. Что это означает? Это означает, что если вы вызываете функцию f без
аргументов, то, наверное, вы ожидаете следующих поведений. Я вызываю функцию f без аргументов.
Эта функция у меня шаблонная. Если я вызываю без аргументов, значит в качестве аргумента у меня
подставляется ноль. Ноль имеет тип int, но соответственно в качестве типа t у меня
подставляется int. Вот такое поведение вы ожидаете. Но работает не так. Вы вызываете функцию f,
и в этот момент компилятор ничего не понимает уже. Вот вы вызываете функцию f, компилятор уже не
понимает, что подставить в качестве типа t. То есть последовательство немного другое. Компилятор
сначала должен вывести тип t, а уже потом подставить аргументы по умолчанию. Поэтому вот эта штука
работать не будет. Как заставить ее работать? Ну просто указать аргумент по умолчанию тип t int.
Тогда если вы вызываете функцию f без аргументов, то у вас, ну компилятор понимает, что тип t вывести
невозможно, подставляет в качестве типа t int, который вы указали там. Ну и дальше в качестве первого
аргумента подставляет 0, который вы указали в аргументах. Вот это и все. Потому что тут есть
контекст вывода. Компилятор думает, вот вы указали аргументы. Значит у вас, смотрите, у вас есть
единственный шаблонный параметр t. Тип t, ну то есть он видит, что есть шаблонный параметр t, и t
фигурирует в аргументах функции. И он понимает, что он же не дурак, он может его вывести. Все, вы
передаете 0, 0.0. И компилятор смело бросается, все, я бегу выводить. Моя выводить, я умею это делать.
А потом понимает, что ну нет, 0 это int, 0.0 это double, не состыковка, и все, проблема. Поэтому такая
штука, работа не будет. Перерыв. Давай, да, сначала вопрос. Тип по умолчанию, тип переменной, по умолчанию должны совпадать?
То есть вы имеете в виду вот здесь? Нет, нет, нет. Вот как раз из-за того, что у вас все происходит в обратном
порядке, тут если вы напишете 0.0, то все будет нормально. Давайте пример напишем, что вы имеете
в виду. Template класс T равно int и ну скажем f tx равно 0.0. Вы это имеете в виду? Здесь происходит
следующая вещь, как я рассказал. Когда вы вызываете f без аргументов, компилятор понимает, что вывести
тип T ему не представляет возможным. Поэтому он берет тип T, который вы указали по умолчанию. Это int.
И после этого он x' присваивает 0.0. Но так как существует преобразование из добла в int, то все будет
нормально. Теперь перерыв. Важный момент, который нужно обязательно обсудить, когда мы говорим про
шаблоны, это понятие инстанцирования шаблона. Что такое инстанцирование? Это от слова instance,
экземпляр, получение некоторого экземпляра шаблона. Давайте поподробнее поговорим про то,
как вообще работают шаблоны, что они генерируют, какой код, как они связаны с обычными функциями и
так далее. Первый вопрос для затравки такой. У меня есть некоторая шаблонная функция f,
не важно, что она делает, просто она принимает некоторый шаблонный параметр. И далее я пишу
просто функцию main, которая выводит не hello world. Сколько экземпляров функции f у меня есть в моей
программе? Что такое экземпляр функции? Давайте вспомним про то, как выглядит процесс компиляции
программ. Когда у вас есть функция, вы компилируете ваш файл, ваш файл с программой или несколько
файлов с программой. У вас для каждой функции генерируется некоторый ассемблерный код, грубо говоря.
Генерируется некоторые инструкции процессора для функции f, для функции g и так далее. Для каждой
функции заводится некоторый исполняемый код. Сколько исполняемого кода порождает вот эта функция f,
которую мы завели здесь? Предполагаем, что мы ее как-то реализовали. Есть вариант 1, есть вариант 0.
Смотрите, а как быть с тем, что у меня шаблонная функция f должна работать с int,
с doub, с con, с char, с in, с in и так далее. То есть функция f генерируется для всех
возможных типов. Это in, in, in, in, in, in, in, in, in, in, con, in, in, con, in, con, in, con, in, con, in, con, in, con, con, in, con, con, con, con, con, con, con, con, con, con, con, con, con, con, con, con, con.
Да, отлично. Правильный ответ 0. Я надеюсь, понятно, почему. Ровно по той причине,
которую я объяснил. Потому что для разных типов t у вас должны сгенерироваться разные
ассемблерные инструкции. Я думаю, понятно, что сложить 2 int не то же самое, что сложить 2 doub.
Для них процессовая инструкция абсолютно разная. Поэтому вот функция, которая вызывается для int
и функция, которая вызывается для doub, они должны иметь разный набор инструкций. Соответственно,
должны быть разные. Поэтому шаблонные функции инстанцируются или создаются лениво. До тех пор,
пока вам не понадобилась ни одна из функций, никакого исполняемого кода не порождается.
Вот если вы возьмете данный код и прогоните его через какой-нибудь компилятор, то увидите,
что вашим исполнением файла есть только функция main. Функции f в принципе нет. Нет, если вы пишете
обычную функцию, при этом ее не используете, то код для нее все равно создается. Но это связано
с тем, что если вы написали функцию, и она вполне себе возможна, что она нужна в какой-то другом
файле, в какой-то другой единице трансляции, вот так далее. Для шаблонов функции это не происходит,
потому что сами подумайте, что нужно сгенерировать функцию для всех возможных типов, хотя на самом
деле они вам не понадобятся. Плюс вы же можете писать свои собственные типы, структуры и так далее.
Для них тоже нужно все создавать. Естественно, нет. Поэтому они создаются только по мере необходимости.
И вот этот вот процесс создания функции в момент необходимости называется инстанцированием.
Что важно запомнить? Важно запомнить то, что сейчас появится. Шаблон функции это не функция. Самое
главное. Шаблон функции это всего лишь некоторое указание компилятору, как нужно создавать
функции. Вы дали некоторую кальку компилятору и говорите, что вот по такому алгоритму нужно
создать новые функции. То есть мы переходим на некоторые новые уровень программирования,
которые часто называются метапрограммирования. То есть мы программируем не саму программу,
а программируем программу, которая должна написать вам программу. То есть, когда вы
пишете шаблонную функцию, вы, на самом деле, говорите компилятору, как нужно написать вашу функцию.
Понятно, да? Поэтому шаблон функции не является функцией, и сам код ведет себя не так, как вы ожидали.
Генерация исполнения кода действительно не происходит, если шаблон ни разу не вызван.
то если шаблонную функцию у вас не разda не вызываете, то ни одной функции не существует.
Если вы вызываете шаблонную функцию,
то в этот момент, если компилятор видит, что вы вызывает шаблонную функцию,
то в этот момент он понимает, что ему нужно создать функцию с нужными типами.
Вот, именно в этот момент, он начинает генерировать код.
Понятно, да? Во время компиляции, не во время исполнения, во время компиляции.
Ну и, собственно, инстанцированием называется процесс генерации кода из шаблона.
Инстанцирование кода – это процесс генерации кода из шаблонной функции.
Ну или из любого шаблона, на самом деле.
Потому что у нас будут еще шаблоны классов и так далее.
То есть если мы рассмотрим данный пример и посмотрим на функцию main,
смотрите, что у меня происходит. У меня вызывается f от нуля.
Вот в этот момент, когда компилятор читает вашу программу,
он понимает, что вам нужна функция f, которая в качестве шаблонного параметра подставляет int.
Поэтому генерируется код для функции f от int.
Когда вы вызываете функцию f от 0.0, в этот момент, когда читает компилятор ваш код,
он понимает, что вам еще понадобится функция, которая принимает double.
И генерирует вторую функцию, которая принимает double.
Даже когда вы вызываете f от единицы, компилятор видит, что вам нужна функция f,
которая принимает int. Но так как она уже сгенерирована, ему ничего делать не надо.
Он просто берет и подставляет вот то, что вам нужно.
То есть в данной программе, которая здесь описана, у вас существует две версии функции f.
f для int и f для double.
Это понятно.
Как еще можно инстанцировать шаблонные функции?
Во-первых, можно их заиспользовать. Если вы их используете, то компилятор начинает генерировать код.
А второй момент, вы можете явно попросить компилятор сгенерировать определенную функцию.
Даже если вы ее не используете, вы можете попросить компилятор сгенерировать эту функцию.
Точнее, не с помощью такого синтаксиса.
Вы пишете template, а дальше пишете прототип функции, которая вам нужна.
И компилятор сгенерирует вам любезно код для этой самой функции, даже если вы ее не используете.
Может быть, не понятно, зачем такое вообще нужно.
Если вы в этом файле вообще не используете эту функцию, зачем ее нужно генерировать?
Ну вот, представьте себе такую ситуацию.
Давайте порисуем чуть здесь.
Смотрите, у вас есть проект, который состоит из большого количества файлов.
И вот здесь вы используете функцию f от int.
Вот здесь вы используете шаблонную функцию, которая понимает int.
Здесь вы используете ее, ну и так далее, во всех файлах.
Когда компилятор анализирует ваш код, то есть на самом деле компилятор, и об этом вы поговорите на семинарах,
он компилирует программу по файлову.
Сначала компилирует первый файл, потом второй, третий файл, и так далее.
Потом только в конце собирает одну общую программу.
Когда компилятор видит, что здесь использовалась функция f от int, он начинает ее генерирует.
То есть он в этом файле сгенерировал вам функцию f от int.
Дальше компилятор видит, что в этом файле у вас есть функция f от int.
И в этом файле он отдельно тоже сгенерирует функцию f от int.
И у вас получается так, что в каждом файле у вас генерировался по своему экземпляру функцию f от int.
Ну естественно, это сильно раздувает ваш код и увеличивает время компиляции.
Так вот, чтобы такого не происходило, вы можете в отдельном каком-то файле cpp
явно сказать то, что написано там, template f от int и так далее,
вы можете сказать, что в этом файле вы инстанцируете эту функцию,
а вот в этих всех файлах вы не пишете тело всей функции,
а просто пишете прототип функции, как мы это делали ранее.
То есть вы пишете, что существует некоторая шаблонная функция,
но при этом тело ее написано где-то вот здесь.
И вы явно для нужных вам типов инстанцируете ее в этом файле.
И тогда в каждом из этих файлов у вас функция f создаваться не будет,
потому что у вас тела в ней нет, то есть непонятно, что создавать.
И в конце, то есть на этапе линковки, у вас вот это вот определение
потянется из вот этого файла.
Примерно понятно, что происходит?
То есть грубо говоря, таким образом, вы можете попросить компилятор
нужную вам версию функции шаблонной создать в одном файле,
а в остальных файлах просто ее использовать, а не генерировать заново.
Так, пойдем дальше.
Ну и давайте поговорим про компиляцию шаблонов,
что там вообще происходит и так далее.
Ну смотрите, вот тут возникает, в зависимости от того, что я сказал до этого,
возникает такая проблема. С одной стороны, шаблонная функция это не функция.
То есть компилятор вроде как на основании только шаблонной функции
никакого кода сгенерировать не может.
Потому что если он не понимает, какой тип вам нужно подставить,
исполняемый код в принципе невозможно сгенерировать. Согласно?
Непонятно, сколько байт вам нужно выделить для такой переменной,
для такой компиляции и так далее.
Но при этом компилятор же должен как-то уметь проверять вашу программу на корректность.
То есть хотя бы базовый синтакс, нужно же проверить.
То есть верно ли, что у вас поставлено везде, где нужны точки с запятой,
верно ли вы используете оператор if и так далее.
И вот тут возникает такая идея,
которая называется двухфакторное инстанцирование,
то есть двухэтапное инстанцирование.
Инстанцирование шаблонов на самом деле происходит в два этапа.
На первом этапе, когда компилятор встречает вашу шаблонную функцию,
компилятор читает вашу программу и видит,
что вот вы решили завести какую-то шаблонную функцию.
Компилятор проверяет лишь базовый синтакс,
который не зависит от шаблонных аргументов.
То есть все, что не зависит от шаблонов аргументов,
он проверяет на корректность.
Но сейчас давайте посмотрим, вот на такую функцию f.
Что здесь можно проверить такого, что не зависит от шаблонов аргументов?
от шаблонных аргументов. Давайте, первая строка, вторая, третья, четвертая, пятая.
Вот какие строки не зависят от шаблонных аргументов? Точнее, какие строки не
зависят от типа T? Вторая. Ну действительно, проверить строку с вызовом функции g
можно и без шаблонных аргументов. То есть компилятор что проверяет в этом случае?
Существует ли в принципе такая штука g, которую можно вызвать с круглыми
скопками? Пока скажем, что существует ли функция g в принципе?
Можно ли ее вызывать без аргументов? Ну и в принципе все. Она не зависит от
непосредственных аргументов. Ну и четвертая. Действительно, размер чара не
зависит от того, какой типа T у вас выведен. Тип чара он фиксирован для
определенного компилятора и для определенной платформы. Ну а первая
строка очевидна, что она должна быть проверена только на этапе генерации кода.
Почему? Потому что непонятно вообще можно ли складывать 2x. Например, если вы в
качестве типа T у вас будет выведен указатель. Складывать два указателя
нельзя. Поэтому это все остается на второй этап.
Вот. Плюс, возможно, x это константа. То есть у вас в качестве типа T будет выведен
константа. Поэтому вообще не факт, что x можно что-то присваивать.
Дальше g от x. Тоже непонятно, можно ли вызвать g с помощью аргумента x? Ну и
последняя строка, естественно, непонятно. Верно ли, что размер типа T он больше, чем
размер чара? А что если T равен чар, на самом деле?
Да, вторая и четвертая строки проверяются на первом этапе. Остальные строки на
втором этапе. Двухэтапное инстанцирование.
Окей?
Ну потому что size of T, то есть вы же не можете проверить для произвольного типа
верно ли, что он больше, чем размер чара? А статик осерд. Да, давайте поговорим.
Статик осерд, это такая специальная инструкция, которая проверяет
условия на этапе компиляции. То есть у вас внутри статика осерд
стоит некоторое условие, которое можно проверить на этапе компиляции, вот.
И если оно не удовлетворяется, то у вас возникает ошибка компиляции. То есть это не во
во время исполнения, то есть не то, что во время исполнения компилятор начинает проверять размеры типов и так далее,
нет, компилятор начинает компилировать программу, то есть собирать исполняемый файл.
Если в этот момент статик-ассер проваливается, то ошибка компиляции.
Поэтому, так как статик-ассер должен быть проверен на этапе компиляции,
ему на этапе компиляции нужно понимать действительно ли sizeof-t больше, чем sizeof-chart и так далее.
Так, ну и поговорим про перегрузку.
Я уже напоминал, что такое перегрузка для обычных функций.
Перегрузка – это такое свойство, которое позволяет вам создавать функции с одним и тем же именем,
но при этом принимать аргументы различных типов.
Существует такая понятия, как перегрузка шаблонных функций.
Значит, как это работает?
Вы можете завести шаблонные функции с одним и тем же именем,
но при этом которые принимают различные типы шаблонных параметров.
Ну, в частности, вы можете завести шаблонную функцию f,
которая принимает два аргумента и при этом которые имеют различные шаблонные параметры.
Например, t и u.
В то же время у вас может существовать функция, которая тоже принимает два аргумента,
шаблонные параметры которых совпадают.
x и y.
Вы можете написать шаблонную функцию, которая принимает, например, один аргумент.
Это тоже будет перегрузкой.
Вы можете написать шаблонную функцию f, которая принимает шаблонный указатель.
Это тоже будет считаться перегрузкой.
В принципе, поведение перегрузки ожидаемо довольно.
Более того, в один и тот же момент времени,
помимо шаблонных функций, у вас могут существовать не шаблонные функции.
Вот, например, в последней строке.
У вас есть шаблонные функции, которые принимают два аргумента,
и есть не шаблонная функция, которая принимает два аргумента.
Это вполне себе нормально, вполне себе возможно.
Тут возникает вопрос, что на самом деле у меня будет вызвано?
Хорошо, у меня есть куча функций, которые принимают два аргумента.
Вот я вызываю функцию от двух аргументов, что у меня в итоге будет вызвано?
И вот тут есть довольно сложные и обширные правила.
На самом деле правила перегрузки довольно сложные.
Я не уверен, что вообще в первом семестре как-то...
Короче, правило выбора перегрузки там занимает примерно две страницы в стандарте,
даже больше, по-моему.
Естественно, их запоминать не нужно.
То есть вы примерно интуитивно понимаете, как это работает, и нормально.
Когда в дело входят шаблонные функции, тоже там есть очень огромное количество правил и так далее,
но самые главные из них перечислены здесь.
В общем, что важно понимать?
Как происходит выбор нужной функции?
Смотрите, если у вас есть точное соответствие,
то есть если какая-то из функций, не важно, шаблонная, не шаблонная,
может обеспечить точное соответствие типов,
то скажем, вы передаете два инта, и у вас есть функция, которая принимает два инта,
или у вас есть функция, которую вы передаете, инт и дабл,
и у вас есть функция, которая может принять инт и дабл,
тогда эта функция, всегда, короче, будет выбрана в качестве одной из победившей перегрузку.
То есть будет выбрана эта функция.
То есть точность и соответствие всегда лучше, чем не лучше.
Дальше второе правило.
Допустим, у вас получилось так, что у вас есть несколько точных соответствий.
Совсем плохо.
У вас есть несколько функций, которые обеспечивают точное соответствие.
Тогда среди них будет выбрана та, для которой нужно меньше всяких
преобразований типов, шаблонах подстановок и так далее.
То есть компилятор, он как мы, ленивый, то есть чем меньше действий, тем лучше.
Нет, нет, не может быть.
Ну это правило, это общий правило, если у вас нет, если у вас нет
точного соответствия, то среди них, ну да, тут не совсем корректно, в общем, если нет
точки соответствия, то чем меньше преобразований типов, тем лучше.
Короче, чем меньше действий выполнять, тем лучше.
Ну и последнее, если у вас есть шаблонная функция, которая обеспечивает точное
соответствие, и есть не шаблонная функция, которая обеспечивает точное соответствие,
то не шаблонная функция всегда лучше.
Ну оно и понятно почему, потому что, если вы написали шаблонную функцию, то вы, грубо говоря,
описали, как нужно действовать, вообще, в общем случае, для всех произвольных типов,
и при этом, если у вас есть какая-то функция, которая говорит, как нужно действовать
для каких-то конкретных типов, то естественно нужно предпочесть ее,
потому что вы написали конкретную функцию для
Наверное, вы имели в виду, что для конкретных типов нужно висеть себя как-то по-другому,
в частности, так, как вы указали.
Давайте проверим себя.
Вот есть три перегрузки функций, две из них шаблонные, одна из них не шаблонная.
Какая из функций вызовется в каждом из случаев?
Давайте первый случай. У меня есть функция f, которую я вызываю с аргументом 0
и с аргументом 0.0, то есть с аргументами типа int и с аргументом типа double.
Почему первая?
Потому что, заметьте, что среди всех функций только она обеспечивает точное соответствие.
Последняя функция не точное соответствие. То есть int и int не то же самое, что int и double.
Вторая функция тоже. Она ожидает два аргумента одинаковых типов.
То есть, в принципе, вторая функция выбрана не будет, потому что невозможно вывести тип.
Первая функция может обеспечить точное соответствие int и double.
Поэтому тут действительно первая функция.
Во второй строке 0.0 и 0.0, то есть два аргумента типа double.
Первая или вторая? А может третья?
Кто за первую? Кто за вторую?
Действительно, вторая. Почему? Потому что какие функции обеспечивают точное соответствие?
Первая и вторая. Третья не точное соответствие.
Но при этом, почему мы выбираем вторую, а не первую?
По принципу наименьшего действия. Нам тут меньше всего нужно подставлять.
То есть, первую функцию нужно подставить t, потом еще u подставить, потом еще cos.
Во второй функции мы просто подставляем t, и все нормально.
Одна постановка, поэтому вторая функция выигрывает.
А тут по какому правилу?
Все три функции обеспечивают точность соответствия.
В первом случае можно подставить в качестве t и u int,
во втором случае в качестве t можно подставить int,
но при этом третья функция точно подходит, и при этом она является обычной функцией.
Обычная функция всегда лучше.
Я вызвал эти три функции, давайте рассмотрим на третью.
f от 0.0.
А вот что если мне очень сильно хочется, чтобы выиграла обязательно шаблонная функция?
Я хочу вызвать функцию f, которая обязательно шаблонная,
и при этом, которая среди всех шаблонных функций подходит лучше всего.
Указать тип, но тип я тоже не хочу указывать,
это же запарно слишком, указывать постоянно нужный тип и так далее.
Что? Что сделать?
В смысле удалить ее?
Кого?
Что значит проинтилизировать функцию?
Я не совсем понял, что вы имеете в виду.
Самый простой способ это сделать так.
Просто указать пустые треугольные скобки.
Мы же помним, что во-первых треугольные скобки это явный признак того,
что вы вызываете шаблонную функцию.
Во-вторых, если вы не указываете какие-то параметры, то вы говорите,
что они должны быть выведены автоматически.
Вот здесь ровно об этом и говорится.
То есть вы говорите, что вы вызываете шаблонную функцию,
но при этом ни один из параметров не указываете,
поэтому вы говорите, что они должны быть выведены.
Что будет обязательно первое?
У меня, конечно, нет такого способа, я не знаю такого способа.
Что? Не скомпилируется.
Это мое предположение, но не должно компилироваться.
Если вам очень хочется разные типы, то...
Короче, даже если вы укажете int, вы можете указать int,
запятая int, и тогда будет выбрана первая функция.
Почему? Потому что первая функция задает два шаблонных аргумента.
Поэтому будет выбрана она.
Вот как выбрать первую шаблонную функцию без явного указания типов, я не знаю.
Ну, я подумаю, может, что-то придумаю.
Или вы если придумаете, скажите.
Я такого способа не знаю пока.
Может, его и нет.
Так, можем дальше двигаться?
Или вопрос еще есть?
Окей.
Теперь поговорим про термин, который специфичен для шаблонных функций.
А именно специализация шаблонов.
Начнем с проблемы.
Давайте вернемся к старой доброй функции abs,
которую мы написали шаблонной.
У нас есть замечательная функция abs,
которая принимает шаблонный параметр t,
принимает один аргумент и возвращает модуль переданного числа.
Ну, вот вы пишете свою математическую библиотеку, пишете, пишете,
и вдруг понимаете, что вам нужна структура для представления комплексного числа.
Ну, комплексное число представляется двумя значениями.
Это действительно часть и мнимая часть,
поэтому разумным способом это наверное завести для нее структуру.
То есть структура, которая хранит два поля.
Действительно часть и мнимая часть.
Ну и наверное вам бы хотелось, чтобы для комплексного числа
тоже корректно считался модуль.
То есть можно было вызвать abs для комплексного числа,
и все корректно бы работало.
Но проблема в том, что если возьмете и просто так вызовете
шаблонную функцию abs для комплексного числа,
то возникнет проблема.
Причем проблем будет несколько.
С чем они связаны?
Ну, во-первых, не будет проблем с тем, чтобы вывести тип.
Давайте говорить с тем, что тип будет выведен корректно.
И на самом деле сообщение компилятора нам об этом говорит.
То есть он говорит, что вот как раз, вот это наше слово новое,
инстанцирование шаблонной функции abs прошло успешно.
То есть в качестве типа T был выведен тип комплекс.
Все нормально.
Проблемы начались далее.
А именно на каком этапе?
У нас есть два этапа, первый или второй?
Вот, проблема началась на втором этапе инстанцирования.
То есть подстановка прошла успешно,
а вот в момент генерации кода, то есть на втором этапе инстанцирования шаблона,
возникли проблемы.
И проблемы связаны со следующим.
Во-первых, непонятно, как сравнивать на неравенство структуру и число.
Вот.
Ну, это первая проблема.
А вторая проблема, непонятно, что значит минус от структуры.
Ну, спойлер, на следующей лекции мы с вами поговорим,
как для своих типов можно перегружать операции.
То есть можно заставить вот эти все операции работать.
Ну, то есть на равенство не имеет смысла комплексный число сравнить.
Ну, например, как заставить работать унарный минус, сложение и так далее.
Вот мы об этом поговорим.
То есть это возможно.
Но в данном случае мы этого не реализовали,
поэтому компилятор жалуется.
То есть проблема.
Наш общий шаблон, который мы указали,
он не подходит не для всех типов.
Вот сейчас для комплексного числа он не подходит.
То есть для него нужно что-то специфическое.
Согласны?
Вот.
Как можно решить эту проблему?
Ну, вот в прошлом пункте мы поняли,
что на самом деле можно просто написать обычную функцию abs,
которая принимает комплексное число.
Да?
То есть мы понимаем, что если мы напишем обычную функцию,
которая принимает комплексное число,
то она будет выигрывать перегрузку и все будет нормально.
Вот.
Но при этом есть проблема с, так скажем, несимметричностью синтаксиса.
Смотрите, у вас одни функции abs шаблонные,
а другие функции abs нешаблонные.
Ну, как-то странно, да?
Наверное, хотелось бы, чтобы все было шаблонным,
либо чтобы все было нешаблонным.
Ну, для симметрии.
Ну, почему это нужно?
Потому что представьте себе, что кто-то захочет,
ну, то есть кто-то, не знаю, считает,
что все функции abs являются шаблонными.
И попытается вызвать функцию abs вот таким вот способом,
с пустыми треугольными скобками.
Ну, и тут возникает проблема,
потому что у вас функция abs шаблонная,
для типа комплекс не работает.
Поэтому, наверное, хотелось бы следующего поведения.
Хотелось бы написать шаблонную функцию abs,
которая в общем случае делает
какие-то действия, которые мы указали,
а в каких-то специфических случаях,
то есть для конкретных типов,
ведет себя по-другому.
Мотивация понятна?
То есть в общем случае одним способом,
а для каких-то специальных типов действует по-другому.
И вот как раз таки для этого существует такой механизм,
как специализация шаблона.
Иначе говоря, полная специализация шаблона.
Выглядит она следующим образом.
Значит, если у вас есть
шаблонная функция,
то ее можно специализировать
для специальных типов.
Синтакс есть следующий.
Вы пишете templat,
но при этом указываете
пустые треугольные скобки.
Это как раз говорит о том,
что вы сейчас пишете не шаблонную функцию,
то есть вы сейчас не объявляете шаблон,
а специализируете шаблон, который был объявлен выше
или где-то ранее в коде.
И дальше вы пишете функцию так,
как если бы вместо типа T
был подставлен конкретный тип.
Вот сейчас вместо типа T
вы просто представляете комплекс.
И вот эта штука является тоже шаблонной функцией,
но при этом она специализирована для типа комплекса.
Ну как выглядит
получение модуля комплексного числа,
ну вот примерно таким образом.
Давайте предполагать,
что мы тоже возвращаем комплексное число,
у которого нулевая внимая часть,
а дистинная часть это просто квадратные корень
из суммы квадратов действительно внимой частей.
Специализация относится к ближайшему шаблону?
Да, к ближайшему шаблону.
Если у вас есть несколько шаблонных функций,
то специализация будет относиться
к самому ближайшему, ну как с ипом.
else относится к ближайшему ипу.
Также специализация относится
к ближайшей шаблонной функции.
Ну и теперь вот эта штука работает.
То есть как
выглядит действие с точки зрения компилятора?
Вы вызываете функцию
abs от комплексного числа
c. Компилятор
понимает, что в качестве шаблонного типа t
нужно вывести комплекс. То есть вот
он смотрит сюда, видит, что действительно
один шаблонный аргумент, и он может его ввести.
И он выводит типа t как комплекс.
А дальше он понимает, что в случае с комплексом
ему нужно действовать как-то иначе.
То есть у него есть на этот случай специализация.
И он же идет в нее,
и в общий шаблон.
Понятно?
Вот.
Не, это не перегрузка.
Перегрузка
была бы если...
Что такое перегрузка?
Перегрузка позволяет вам писать
для разных типов.
Перегрузка это одно имя, разные типы.
Здесь предполагается, что
для шаблонных функций
что означают разные типы?
Разные типы означают, что их разное
количество...
Да, ну давайте еще раз.
Если у вас есть функция,
которая принимает tx и ty,
и есть шаблонная функция, которая принимает
tx и uy,
то это перегрузка.
Потому что первая функция принимает два аргумента
одинакового типа, вторая функция принимает
два аргумента, но потенциально разных типов.
То же самое если вы принимаете
с одним аргументом.
Левые функции у вас два аргумента принимают,
а эта функция один аргумент.
Здесь у вас то же самое, то есть у вас
и эта apps, и эта apps принимает один аргумент.
Но при этом они работают
в рамках одного общего шаблона.
Давайте еще как-нибудь
попробуем объяснить.
Когда у вас выбирается перегрузка,
у вас происходит выбор, какую функцию
выбрать, либо вот эту функцию, либо вот эту функцию,
либо вот эту функцию.
Когда вы пишете специализацию, у вас выбирается
всегда вот эта функция.
Но при этом компилятор, когда у вас возникает
определенный щелчок, триггер,
специальный тип, комплекс,
он понимает, что нужно использовать не вот это тело,
а вот это.
Вот и все.
Еще вопросы?
Окей.
Да.
Да.
Я уже сказал, что
можно поступить так.
Но разница такая же,
как между обычной функцией
и шаблонной функцией.
В частности, какие?
Вот эту функцию вы не можете вызвать
с помощью шаблонного синтаксиса.
Вот эту специализацию вы можете вызвать
с помощью шаблонного синтаксиса.
Первое. Второе.
Если вы на самом деле,
представьте себе, что вы на самом деле
никогда не вызываете apps
от комплексного числа.
Вот никогда.
Тогда в этом случае, когда вы написали обычную функцию,
у вас все равно код сгенерируется.
То есть исполняемый файл будет содержать
определение этой функции.
А когда вы пишете шаблонную функцию,
мы знаем, что они инстанцируются лениво.
Поэтому если вы ни разу не вызовете шаблонную функцию
с комплексным числом, у вас даже кода для нее
не сгенерируется. То есть код будет более компактным.
Да.
Еще раз.
Перегрузка разрешается
в момент вызова.
Сейчас.
Неправильно сказал.
Перегрузка это...
Перегрузка относится к механизму
выбора функции.
То есть перегрузка,
когда происходит момент
выбора перегрузки, у вас
выбирается та или иная функция.
То есть у вас выбирается либо функция f,
которая принимает два одинаковых шаблонных параметра,
либо два разных шаблонных параметра,
либо один шаблонный параметр и так далее.
А после выбора перегрузки,
после того, как все типы будут
подставлены, начинается процесс
выбора специализации.
То есть компилятор выбирает,
либо вы используете общий шаблон,
который у вас был где-то описан,
либо вы действуете каким-то специальным образом,
который описал разработчик.
То есть они действуют на разных этапах.
То есть перегрузка относится к выбору
грубо говоря, шаблонных параметров.
Давайте так. Перегрузка выбирает
шаблонные параметры, а специализация
выбирает реализацию конкретную.
Еще?
Окей.
Так, ну и
видимо, последний пункт
здесь,
это параметры шаблона, не являющиеся типами.
На самом деле, в качестве шаблонных параметров
могут выступать не только
типы,
то есть не только f от nta,
f от doubla и так далее,
но и, во-первых, целые числа
в этих указателях,
в-третьих, ссылки,
ну и начиная со стандарта c++20,
возможно указывать числа с плавающей точкой,
ну и некоторые типы
или классы специального вида,
в общем, мы это не трогаем, в общем, самое главное,
что в качестве шаблонов параметров вы можете указывать
целые числа, указатели и ссылки.
Для чего это может быть
нужно? Ну, смотрите,
например, можно описать вот такую функцию сам,
интересную.
Вы пишете template
и дальше говорите, что вы эту функцию сам
параметризуете
двумя целыми числами, n и m.
Ну и дальше вы можете вернуть значение
n и m.
Ну и теперь как вы можете
посчитать значение двух целых чисел?
Ну, например, вы можете вызвать так, сам
с треугольных скопок 3 и 8,
ну и дальше пустые круглые скопки, которые
означают вызов функции.
В этот момент у вас выведется 11,
то есть вернется из функции 11.
Что важно понимать?
Смотрите, у вас
шаблонные функции
инстанцируются на этапе компиляции.
Что это означает? Это означает,
что в качестве шаблонных параметров вы
обязаны указывать константы времени компиляции.
То есть нельзя просто так взять
и сказать, что вот у вас есть int
x равный единице, ну там, не знаю, вы
просвоили единицу или
сочетались с консолей и потом вызвать сам
один запятая x с треугольных скопок
и ноль. Вот это не скомпилируется. Почему?
Потому что x неизвестен
на этапе компиляции.
Ну то есть, еще раз, как это выглядит?
У вас есть
шаблонная функция sum,
которая параметризована
двумя целыми числами.
Когда компилятор в вашей программе
встречает
вот какую-то такую штуку,
он начинает
генерировать функцию вот с таким
именем. То есть он начинает там
то есть он говорит, что вот есть функция sum
0,1
и для нее там
генерирует какой-то код.
Дальше, когда он встречает функцию sum
от 11,2,
он генерирует отдельную функцию. То есть, смотрите,
вот эта функция и вот эта функция – это абсолютно
разные функции. Понятно почему?
Ну ровно по той же причине,
почему у вас f от int и f от double – это разные
функции. Вот здесь то же самое.
Вот эта функция параметризована числами 0,1,
вот эта функция параметризована числами
11,2. И у вас компилятор где-то
создает функцию, ну я пишу условные названия,
то есть он как-то условно так называет,
и генерирует абсолютно другую
функцию, которая делает просто складывать 11,2.
Вот и все.
Можно. Сейчас. Нет.
Вот здесь нельзя.
Короче,
ну давайте забегая вперед, скажу,
что если вы напишете const export,
то можно.
Но вообще говоря нельзя.
Потому что считается, что
возвращаемое значение функции – это
не константа времени компиляции.
То есть, ну логически-то мы понимаем, что это константа времени компиляции,
но компилятор должен в этом убедиться,
и вы, чтобы его убедить, должны написать, что это const export.
Но это мы позже поговорим.
В общем, важно понимать, что
вот эта функция
и вот эта функция
для компилятора разные функции.
И он их должен сгенерировать
на этапе компиляции.
А чтобы их можно было сгенерировать на этапе компиляции,
ему нужно вот эти вот параметры
3 и 8, 1 и x, знать
на этапе компиляции.
Но так как x – это не константа времени компиляции,
она вычисляется только на этапе исполнения программы,
то компилятор, естественно,
сгенерировать ее не может.
Зачем это вообще нужно?
Сума – это какой-то дурацкий пример,
абсолютно бесполезный, никто так делать не будет, естественно.
Вот полезный пример.
Смотрите.
Я хочу написать шаблонную функцию,
которая принимает массив,
обычный стековый массив,
сишный.
Произвольный
сишный массив, стековый.
Я хочу написать такую функцию.
Что мне нужно написать? И при этом я хочу этот массив
принимать по ссылке,
чтобы его не копировать, чтобы не работать с указателями и так далее.
Что я должен написать?
Я не могу просто взять и написать
ну, не знаю, например,
template
class
array
и написать
не знаю, какой-нибудь void
f
array
ссылка x.
Ну, смотрите, если я напишу вот так,
если я напишу вот так,
то массива я, конечно, смогу принимать.
Согласны?
Потому что когда я буду передавать в эту функцию массив,
то у меня в качестве типа array
будет выведен массив, тип массива.
Но при этом, что я тут не понимаю?
Я не понимаю размера этого массива.
Плюс в эту функцию, в принципе,
я могу передавать произвольные значения.
То есть компилятор не знает английского языка.
То, что вы написали тут array, не значит,
что он будет принимать только массивы.
Он будет принимать тут произвольные типы, так,
как если вы написали там t и так далее.
Более того, я вам скажу, что компилятор вообще плевать, что вы там напишете,
какие-то свои имена и в общем так далее.
Окей, понятно?
Чтобы гарантировать,
что ваша шаблонная функция принимает
массив произвольного типа и произвольного размера,
вы можете написать следующим образом.
Ну, вы пишете const t
и даже пишете ссылку на массив.
То есть ссылка array и в квадратоскоп указываете n.
Так как вы не знаете,
какой размер массив вам будет в итоге передан,
вы указываете его в качестве шаблонного параметра.
То есть у вас первый шаблонный параметр это класс t,
то есть тип элементов, который хранит массив.
А второй параметр это размер массива.
И вот эти оба параметра,
они будут выведены на основании того,
что вы туда передадите. Понятно?
И вот, например, таким образом
можно круто написать функцию, которая
принимает произвольный массив и возвращает вам
ну как произвольный,
стековый, статический, да,
то есть не динамический, который принимает
нединамический массив и возвращает его размер.
Без всяких приколов там sizeof,
там delete на sizeof t и так далее.
То есть у вас компилятор принимает этот массив,
выводит тип t, выводит его размер
и вы просто возвращаете его это размер.
Понятно?
Не кокнуло?
На каком этапе
непонятно?
Ну, смотри,
что здесь происходит. Я пишу
шаблонную функцию arraySize.
Смотрите, чего я хочу добиться?
Я хочу, чтобы эта функция принимала
массив по ссылке
и возвращала его размер.
При этом я хочу, чтобы она принимала произвольный массив.
Но как мне
принять произвольный массив?
Ну, во-первых, я говорю, что чем мне характеризуется массив?
Массив мне характеризуется типом,
поэтому я пишу шаблонный тип t,
то есть class t. То есть у меня функция тоже должна
принимать массив произвольного типа, типа t.
Ну и плюс
моя функция должна уметь принимать массив любого размера.
Я вот указываю второй шаблонный параметр
size t, n.
Ну и даже я пишу обычную функцию,
которая принимает ссылку на массив.
Просто вместо конкретного типа подставляю t,
и вместо конкретного размера подставляю n.
И когда я вызываю эту функцию
вот здесь,
у меня в качестве типа t
выводится int, в качестве
n выводится 11. Ну и я возвращаю
n, то есть возвращаю 11. И эта функция
у меня работает так. Она принимает произвольный
массив и возвращает его размер.
Ну а здесь пример
того, что можно
шаблонные функции параметризовать
указателями. Ну вот в частности я тут параметризовал
указателем на функцию.
Ну что тут происходит?
Я эту функцию call вызываю
шаблонным параметром f,
ну где f это некоторая функция.
Вместо f подставляется
ее указатель, и я могу из этой функции
вызывать эту функцию
через указатель.
Ну это просто пример
как можно применить указатель. В принципе
на практике
я думаю, что имеет какое-то большое значение.
Главное, чтобы вот второй блок
поняли. Второй блок понятен,
что можно в качестве шаблонных параметров
указывать не только тип,
но и там целые числа.
И эти целые числа, если возможно,
тоже будут выводиться. Ну вот в частности
в качестве размера массива.
Ну и вот это все.
Ну вот это все.
На самом деле про шаблонные функции
это все.
Вот.
То есть о чем мы поговорили.
То есть мы говорили про мотивацию шаблонных функций,
узнали базовые синтактис, как выводятся
параметры шаблонов,
поговорили про инстанцирование, перегрузку
и специализации
шаблонных функций.
Ну и вот сейчас поговорили про
параметры шаблонов, которые не являются типами.
Ну и на самом деле я утверждаю,
что вы получили довольно мощный инструмент,
который позволяет писать
обобщенные алгоритмы.
Вот, смотри, давайте вспомним
прошлый семестр. Вы наверняка писали
алгоритм типа сортировки.
Как вы писали? То есть как выглядел
прототип функций сортировки?
Ну типа вот,
для интов. Типа sort, дальше принимаем
int по указателю и принимаем
размер. А теперь, ну то есть
верно ли, что та сортировка, которую вы писали,
не знаю, там, сортировка с лиянием
или быстрая сортировка, верно ли она
работает только для интов?
Ну естественно нет, сортировать можно даблы
и вообще что угодно. Все, что можно сравнивать,
мы можем спокойно сортировать.
Поэтому, соответственно,
мы спокойно можем написать
функцию наподобие
класс T,
который принимает,
возвращает ничего
и принимает
указатель на
начало массива и указатель
на конец.
Конец сортировки
последователь. Ну то есть
в общем, привыкайте
к такому синтаксису. То есть мы сначала принимаем
начало последовательности и указатель
на конец последовательности, а не размер.
И в задании, на самом деле, вам
нужно будет тоже реализовать шаблонные функции
примерно по такому же синтаксису.
И эта шаблонная функция теперь не привязана
к никакому конкретному типу, просто
для каждого конкретного типа у вас будет подставляться
нужный параметр T и
функция сортировки будет работать вообще для произвольных
массивов, для произвольного типа,
для произвольного типа и так далее.
Вот такой
замечательный инструмент мы сейчас
получили в руки.
Вот.
Ну о чем тут можно еще
поговорить.
Значит,
изучали ли вы в прошлом семестре ключевое слово авто?
Вы его написали?
Вы авто
написали?
Вы авто использовали?
Хорошо.
Я уточню, в каком контексте вы использовали авто?
Что для вас слово авто?
Еще раз.
Автоматическое определение типа, отлично.
Да.
Кстати, в прошлом году мне все еще говорили,
что авто это автоматическая
память и так далее.
Окей.
Давайте поговорим про историю
ключевого слова авто и вообще как оно работает
и так далее. Смотрите,
из оси плюс плюс одиннадцать,
небольшую историю, ключевое слово авто
использовалось просто для обозначения
переменных с автоматическим временем жизни.
То есть, грубо говоря, для обычных стековых переменных.
Вы просто говорили, что эта переменная
создается здесь и умирает в конце блока.
Ну, собственно, это обычное классическое
поведение любых переменных, которые объявлены
в локальной области видимости.
Поэтому особо применения
у него не было и, соответственно, никто
его не использовал, и поэтому
комитет по стандартизации, тот самый из оси плюс плюс,
это было решение, что слово бесполезное,
поэтому давайте его выпилим,
что, на самом деле, довольно не часто происходит,
потому что, как кто-то говорил, должна быть обратная совместимость.
Но обратная совместимость не с языком
C, а со старыми версиями
языка C++.
Программа, корректно написанная на языке
C++ 2003 года, должна компилироваться и в языке
C++ 2020 года. То есть, вот такая
обратная совместимость. С ключевым словом авто
такого не произошло, в общем, от него решили полностью
избавиться в старом
понимании и ввели новое понимание,
как вы правильно сказали, автоматически
вывод типа. То есть, теперь для переменных
можно не использовать
конкретные,
можно не указать конкретные типы, а просто
полагаться на компилятор, чтобы он автоматически вывел на основании того,
что написано справа от присваивания,
ну и от зависимости от того, чем вы его инициализируете.
Ну и, собственно,
в старый смысл
слова авто был отдан слову register,
а в C++ 17 слово register
убрали, и теперь оно вообще не используется.
Значит,
мораль в общем в чем?
Вы можете использовать ключевое слово
авто для автоматического
выведения типов. То есть, например,
вы можете писать авто x равно 0,
и у вас x автоматически будет являться типом int.
Если вы напишите авто y равно 0.0,
то у будет являться автоматически типом w,
ну и так далее. Важно понимать,
что когда вы объявляете переменную
с
словом авто, это не означает,
что переменная может иметь переменный
тип. Это не значит, что переменная
может так спонтанно брать и менять свой тип.
Нет, авто означает лишь то, что
в данном конкретном месте мы выводим
тип x, и начиная с этого момента
у нас тип x остается
неизменным.
Все-таки мы помним, что у нас C++ язык
со статической типизации.
Если у вас какая-то переменная имеет определенный тип,
то этот тип у нее остается до конца ее жизни.
Поэтому понимание того,
что слово авто означает, что тип x
может в один момент времени быть int,
в другой момент – влатом, в третий вообще комплекс,
это неправильно.
Авто лишь означает просто вывод типа,
автоматический вывод типа.
Естественно, вот такая штука не работает.
Если вы просто объявите переменную
с плейсхолдером авто,
то это не скомпилируется, потому что
компилятору не понятно, какой тип имеет переменная z.
На самом деле существует
такое негласное правило,
которое называется 3a
almost-always-auto.
То есть старайтесь использовать
авто почти везде, где возможно.
Потому что это
уменьшает
всякие трения в вашем коде.
Если у вас есть некоторая функция,
которая что-то возвращает,
то лучше написать
авто x равно f,
чем указывать какой-то конкретный тип.
Почему? Потому что программы меняются,
программы эволюционируют.
Допустим, вы можете в какой-то момент решить,
что функция f должна возвращать не float, а double,
потому что double является более точным типом,
и достаточно.
Если вы писали старый тип,
то вы могли забыть, что вы
изменили точность вашей программы,
то есть изменили возвращаемое значение функции
float на double, и у вас везде
происходило
приведение типов
с double на float.
А тут вы заменили double в одном месте,
и везде у вас все подтягивается,
все как надо.
И плюс это увеличивает...
Нет,
это не может заменять программу
просто потому, что авто выводится на этапе компиляции.
Но ваши типы подставляются
на этапе компиляции.
Хотя на самом деле нет,
это даже немного ускоряет
программу и компиляцию.
Почему? Потому что, смотрите,
допустим, в этом контексте
вы написали не авто x, а float x.
Во-первых, ему нужно проверить
совместимость типов
на этапе компиляции.
Во-вторых, в случае необходимости
ему нужно сформировать код,
который бы проводил приведение из double
во float, ну или из int во float.
И плюс во время исполнения вот это вот приведение
тоже бы выполнялось. То есть авто, наоборот,
даже ускоряет и компиляцию,
и исполнение ваших программ.
Ну и на самом деле это повышает абстракцию
вашего кода. Ну то есть, смотрите,
когда вы пишете вот так, то скорее всего вам
не интересно, какой конкретный тип
имеет x. Ну, например, у вас функция f
измеряет, ну не знаю, какую-нибудь
среднюю оценку по всему институту.
Но вам не важно, в чем она измеряется,
во float-ах или в double-ах. Вам важно получить эту информацию,
а какого типа не интересно.
Даже если она будет измеряться в каких-то специальных значениях,
то есть вы завели специальную структуру
под это дело, то вам тоже это не важно. Вам важно лишь ее получить
и как-то с ней работать.
Какой конкретный тип вас не интересует.
Ну, естественно, это очень полезно,
когда у вас есть какие-то очень-очень длинные типы,
которые либо лень писать, либо на самом деле
длинные типы, которые не имеют никакого смысла.
То есть не имеет смысла их
полностью специфицировать.
Ну, например, ближе к концу курса мы будем изучать
стандартную библиотеку языка C++, и вот там есть такой тип.
Есть std unordered set,
который является шаблоном, который принимает
произвольный тип. То есть unordered set
это просто множество, ну это тип множества,
который там, у которого вы можете спросить,
какие элементы есть в множестве, вы можете добавлять
элементом из множества, удалять из него и так далее.
Вот такой тип.
А еще внутри этого типа есть другой тип,
который называется const reverse iterator.
Вот const reverse iterator позволяет вам
проходить по элементам этого множества.
Чтобы написать цикл, который проходит по элементам этого множества
в обратном порядке,
вам нужно писать, ну в старом, в C++,
вам нужно писать следующую вещь. std unordered set,
long, long, const reverse iterator,
it равно s cr begin.
Ну вот cr begin это такая специальная функция,
которая как раз возвращает вам нужный итератор.
Когда вы вызываете функцию cr begin,
то уже понятно, что вы хотите.
Вы хотите, грубо говоря,
новый итератор на начало обратной последовательности.
Поэтому вот эта вот строка
она лишь
занимает время, она не добавляет никакого
понимания кода. Согласны?
То есть если вы понимаете, как работает эта функция,
то прописывание полного типа не даёт никакого
вообще понимания.
Поэтому естественно лучше написать авто
и не париться об этом.
Короче, правило almost always авто
старайтесь везде, где можно,
писать авто.
Код не замедляется, комплианс не замедляется,
И все замечательно. Я понял.
Так, что самое главное? Что нужно знать про авто?
Я не знаю, говорили вам про авто, так как вы шаблонные функции не изучали в прошлом месяце,
наверное, вам и это не говорили. Правила вывода авто, то есть как выводится вообще тип?
Как компилятор понимает, какой тип нужно вывести? Так вот, приятная новость заключается в том,
что правила вывода авто точно такие же, как и правила вывода для шаблонных функций.
То есть тип авто выводится по тому же алгоритму, который мы обсуждали для шаблонных функций.
То есть если у нас авто идет по значению, то это значит, что отбрасывается конство латайл,
отбрасываются ссылки и так далее. Если вы принимаете по ссылке, то ничего не отбрасывается,
тип выводится таким, какой он есть. Там есть несколько исключений,
но самое главное, если вы делаете вот так, пишете авто x равно фигурно-скопко что-то,
то у вас выводится необычный тип, который называется std initializer-list.
Об этом мы тоже поговорим в курсе, что какой initializer-list, для чего он нужен и так далее.
Но вообще в остальных ситуациях авто работает примерно так, как вы ожидаете.
На этом подведем резюме. Шаблоны развивают идеи перегрузки, мы пишем общую реализацию
для некоторого множества типов, плюс шаблоны можно перегружать, можно специализировать и так далее.
Шаблоны инстанцируются по мере необходимости, как мы уже сказали.
Если вы не используете ни разу шаблонную функцию, то ни одного экземпляра функций у вас нет.
Но использование объявления авто позволяет упростить код.
Это самые главные мысли, которые должны извлечь.
Вопросы? В принципе, по всему, что мы обсуждали.
Да.
Можешь, пожалуйста, громче.
Я, к сожалению, не расслышал.
Так.
То есть вы говорите примерно следующее.
Если мы пишем авто х, а потом пишем вот так, да? Вы про это?
А, типа, хотим ввести х и при этом, чтобы он на основании того, что мы ввели, вывелся?
Нет, это невозможно, хотя по той причине, что, например, у нас язык статически типизирован.
То есть у вас все типы должны быть известны на этапе компиляции.
Поэтому так нельзя.
Есть тип.
Начиная со стандарта C++17 есть специальный тип стандарта библиотеки, который называется std-any.
Вот переменные такого типа, они могут хранить что угодно.
То есть вы можете написать x равно 5, и там будет int.
Вы можете написать x равно string, и там будет const char звездочка.
Но при этом парадокс в том, что тип х всегда будет оставаться стд-any.
То есть тип х на самом деле стд-any, но при этом он хранить может что угодно.
Вот такой интересный тип.
Не все, наверное, но некоторые из вас должны напишут его в третьем задании.
Честно, я не знаю практических применений, мне кажется, по приколу.
Но вообще применения можно придумать, наверное, какие-то.
Ну, например, можно сделать так.
У нас есть программа, в которой вы выводите в консоли какой-то тип.
То есть вы пишете, например, cint, там s и x.
И говорите, что если в качестве s была введена строка int,
то значит там нужно переменную скринтип int и работать с ним.
Если с консоли был введен double, значит нужно работать с double.
И так далее.
Тут тоже, на самом деле, непонятно зачем это нужно,
потому что есть тип std-variant, но в целом какой-то такой пример.
Ну или просто чтобы сделать ваш симтаксис более питоноподобным.
Так, еще вопросы.
Нет, если у вас есть две переменные типа n и обе хранят int,
то их складывать можно.
Но из подвыпер, необычным способом.
Чтобы получить конкретный тип, вам нужно сделать std anycast int от x,
плюс и бла-бла, то же самое от y.
То есть вы должны сказать, из x вытащи int и используй его.
И так далее.
То есть, естественно, x сам не хранит.
Он хранит себе информацию о том, какой тип он содержит,
но при этом на этапе компиляции это неизвестно.
Поэтому вы должны на этапе исполнения просить выделить конкретный тип.
Ну это мы совсем в сторону отошли.
Короче, с помощью авто нельзя сделать так, чтобы вы ввели что-то с консоли,
и он автоматически вам вывел тип.
Нет, потому что тип у вас должен быть фиксирован на этапе компиляции.
Ничего ввести вы на этапе компиляции не можете.
Еще вопрос.
Ну смотрите, на самом деле вот эти две лекции в прошлом году мы изучали две с половиной пары.
Тут мы справились за полторы.
Это, видимо, очень как так действует замечательно.
Есть некоторые бонусные темы, которые тоже есть в программе,
которые мы можем сейчас рассмотреть.
Вот смотрите, я предлагаю вам на выбор следующее.
Есть категория шаблоны переменных.
Нет, давайте не так.
Есть категория шаблоны псевдонимов.
Есть категория агрегатной инициализации.
Что звучит более интересно?
Агрегатная инициализация.
Агрегатная инициализация, да.
Это правильный выбор.
Потому что на самом деле у меня есть только она.
Ну и плюс в первом задании она вам пригодится.
Агрегатная инициализация.
Что такое агрегатный тип данных?
Короче, агрегатный тип данных это либо массив,
это одно из двух.
Либо массив, либо структура.
Давайте так говорить.
То, что здесь написано.
Агрегатный тип данных это либо массив, либо структура.
Структуру вы писать умеете, массивы вы писать умеете.
В чем прикол агрегатной инициализации?
Дело в том, что массивы и структуры
можно инициализировать с помощью фигурных скобок.
То есть если у вас есть такая структура S,
то вы можете не писать отдельно, скажем, s, s,
и дальше писать s.x равно чему-то.
Нет, вы можете сразу взять
по-체적енному скобку указать,
чем вы должны прин Lou fries sonts to x
и что их должны содержать.
Если у вас есть массив структур,
то массив и структура так инициализирует.
То есть вы пишете фигурные скобки,
и дальше во вложенных ещё пос squeezах
как должна быть проинициализирована каждая из отдельных структур.
Понятно, да?
Вот такой удобный синтаксис для того, чтобы задать начальные значения для структур и для массивов.
Более того, агрегатную инициализацию можно использовать при возврате из функции.
То есть предстоит себе, что у вас есть функция, которая возвращает структуру S.
Тогда можно не писать на основу что-то наподобие такого,
то есть можно внутри функции не создавать структуру, не создавать ее поля в отдельности,
а можно просто написать return и сразу писать фигурные скобки, чем вы должны проинициализировать возвращаемое значение.
То есть вы сразу пишете return и в фигурных скобках вы пишете, чему должен быть равен x и чему должен быть равен y.
Вот сейчас эта функция просто берет и каждое поле переданное ей структур увеличивает на единицу и возвращает копию.
Более того, если у вас функция принимает какой-то из агрегатных типов,
ну структуру давайте говорить, если у вас функция принимает структуру,
то вы можете просто в качестве аргумента функции передать фигурные скобки, чем вы должны эту структуру проинициализировать.
Вот и все. То есть очень удобный синтаксис, очень лаконичный и понятный.
Что нужно передать, как вы сразу инициализируете и так далее.
Ну и есть несколько правил, по которым осуществляется агрегатная инициализация.
Первое правило очевидно, каждое поле или каждый элемент массива инициализируется соответствующим элементом из списка.
То есть вы просто смотрите структуру по порядку, то есть сначала у вас объявлен x, потом y, потом z,
и соответственно из этого списка у вас сначала инициализируется x, y и z.
Ну и тоже самое элемент массива, сначала нулевой, первый, второй и так далее.
Внутри фигурных скобок, вот важное правило, внутри фигурных скобок запрещены преобразования с потерей точности.
То есть, если у вас есть структура S, давайте здесь рассмотрим, вот у вас есть структура S,
и у нее в качестве первого аргумента идет x, тогда вы не можете ее взять и проинициализировать вот так 0.0 и 0.0.
Почему? Потому что преобразование из double wind это преобразование с потерей точности.
Вот, преобразование с потерей точности в фигурных скобках запрещены.
Но при этом, если у вас в качестве поля выступает тип long, а вы передаете int, то так можно,
потому что тут нет потери точности, это просто как называется, продвижение, преобразование без потери точности.
Если агрегатный тип состоит из агрегатных типов, то каждый из таких полей можно инициализировать в ложной агрегатной инициализации.
Но это ровно про то, что было вот здесь.
То есть, если у вас есть структура, скажем, не S, а структура A, у которой в качестве поля есть другая структура S, int x,
то вы структуру A можете инициализировать вот так, то есть указать 0.0 и 1. Вложная инициализация.
Четвертый пункт можно пропустить, про статистические поля мы еще не говорили.
Количество элементов в фигурных скобках, естественно, не может быть больше, чем требуется.
То есть, если у вас в структуре два поля, то 4 аргумента вы передать не можете, ну нельзя.
А вот меньше можете, то есть, если у вас в структуре, скажем, три поля, но вы передали только два,
то все оставшиеся обязательно проинциализируются нулем.
И вот это очень важное и полезное правило, что если вы указали не все, то у вас все оставшиеся будет
инициализироваться нулем. Ну какое у этого главное применение, кто знает?
Да, массивы. То есть, как за 0 массив, очень просто. Ну просто пишем int, какой-нибудь array, 10,
и просто тут пишем пустые фигурные скобки. То есть, не обязательно указывать все нули,
вы просто пишете пустые фигурные скобки, и пустые фигурные скобки означают, что вы просто пропустили 10 элементов.
И каждый из этих элементов будет проинциализирован нулем. Вы можете сделать следующим образом.
Можете написать 1,2,3. Вот, 1,2,3, и тогда у вас первые 3 элемента будут 1,2,3, а остальные будут
инциализированы нулем. Нет, не обязательно. Вот. Ну и вложенные фигурные скобки на самом деле могут быть опущены.
Что это означает? Это означает, что, например, вот в этом примере,
ну там, где мы создавали массив структур. Вот. s, r, нижнее подчеркнение, s. Вот тут можно просто написать в строку.
1,0,2,1. То есть вложенные фигурные скобки можно опускать. Ну почему это работает, ну и точнее как это работает.
Ну вот смотрите, у вас есть структура s, которая в памяти как выглядит, то есть как она занимает место в памяти.
У вас есть сначала идет int, потом идет double. Когда вы создаете массив из s? Вот эту? Давайте здесь напишу.
Ну в общем, если у вас есть структура s, то она выглядит в памяти как, сначала идет int, потом идет double.
А когда вы задаете массив из s размера 2, сейчас появится, то у вас сначала идет int, потом double, потом int, потом double.
И соответственно вы можете инициализировать вот, ну просто там скажем 1,2,1,2. То есть опуская внутренние фигурные скобки.
Ну и соответственно пример, все вот эти примеры с массивами мы обсудили, то есть можно опускать внутренние фигурные скобки,
то есть можно часть фигурных скобок опустить, можно все фигурные скобки опускать и так далее.
Ну вот в частности все три вот эти инициализации создают массив из трех элементов s.
Вот первый элемент имеет поля 1,1, второй 2,2, третий 3,3.
Дальше здесь можно опустить, ну тут мы опустили фигурные скобки для 2,2, тут мы опустили фигурные скобки для 3,3.
Здесь мы вообще все фигурные скобки внутренне опустили.
Ну здесь то же самое, только можно писать без равно. То есть можно писать равно, можно не писать равно, без разницы.
Ну и то, про что мы говорили, тут есть потеря точности.
То есть 1,0 пытается преобразоваться в int, а преобразование double int это преобразование с потерей точности.
Вот этот синтаксис, давайте забудем, это статическое поле, его нет.
О статических полях мы в следующий раз поговорим, что это такое, как они работают.
Ну и последний пример. Если вы передали только один аргумент, то, как я уже говорил, все остальные будут интеллизироваться нулями.
То есть у вас поле x пронинтелизируется единицей, а поле z пронинтелизируется 0.0, ну из-за нулиться просто.
Да, ну и вот здесь, в этой строке последний пример, у вас есть структура, какая структура, вот структура S,
у которой первое поле int, а второе поле имеет сколько значений, а вот эта структура Foo, сколько значений имеет?
5, то есть всего 6 иннициализированных значений.
Вот если вы при этом укажете 7 иннициализированных значений, то будет ошибка эмпиляции.
Потому что непонятно, зачем вы вообще последний писали.
Ну и на этом с бонусом тоже все. Какие есть вопросы?
Окей, тогда на этом...
