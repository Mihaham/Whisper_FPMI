ну хорошо поехали итак мы продолжаем изучать как-то до нас теплоход снова
плывет мимо дифференциаль двоичных деревьев войском вот ну как бы да хотя возможно да
что-то не что-то нет реальной смотонализа там на уровне слов лог конечно нам сегодня потребуется
и даже не только для оценки асимптотики но начнем мы с такой замечательной структуры данных как
б деревья мы уже начали обсуждать что это такое то есть не буду сейчас там комментировать на
тему того это там сильно зачем это надо это мы уже в прошлый раз спокойно обсудили вот но
напомним же определение значит ну начнем с того что б дерево это такое нетривиальное дерево
поиска это единственное у нас будет дерево поиска который мы не можем назвать двоичным мы
тоже мы не можем сказать что оно кайч на потому что количество ключей в каждой вершине то есть
вот у нас каждой вершине есть какой-то набор ключей которые мы храним в отсортированном по
возрастанию порядке вот и у нас есть на те нот и эти количество может от вершины к вершине
изменяться но при этом есть мистическая константа т допустим больше либо равна двух и великая
первая собственно условия говорит нам о том что количество ключей в любой вершине не превосходит
2 t минус 1 вот да а еще количество ключей не меньше чем t минус 1 если что если что
нет тут более не тривиальные условия да если вершина некой шеф то есть нам допускается что
в корне может быть сколь угодно мало ключей главное чтобы их было больше либо равно одного
но как сказать иначе это бы это достаточно бессмысленная потому что значит откуда уже
для того чтобы понять напомним откуда нас берутся под деревья напоминаю что с не просто к ключей а
у нас на самом деле еще значит у каждой вершины есть под деревья причем напоминаю что у нас под
деревьев ровно к плюс 1 мы их так вот можно их нумеровать там допустим т 0 т 1 и так далее
т к и мы понимаем что в т и там значит т и т дерево содержит ключи только вот то есть если
это и то содержит какой-то ключ x то из этого следует что x лежит между x и минус 1 и x и вот
ну естественно мы здесь будем подразумевать что x нулевое равно минус бесконечности а x к плюс
1 равно соответственно плюс бесконечности ну можно было там по другому условия написать но я думаю вы
и так все понимать вот спрашивается за счет чего же обеспечивается добрый день еще раз балансировка
вот за счет чего у нас обеспечивается балансировка чего не откали а как нет
количество под деревьев оно идентично количеству вершин плюс один тут без вариантов вот было но
балансировка же как бы сам себе эти условия балансировку не обеспечивают потому что скажем
абсолютно произвольное двоичное двоичное дерево поиска вполне себе будет удовлетворять на самом
деле свойство б дерево скажем ст равно 2 давай а вот я и говорю плюс бесконечности
потому что мы из единицы тут мирим а я вас понял да да да да да да так правильно так
правильно да очень пяточка да нет балансировка конечно балансировка запуска но на самом деле
достигается за счет другого то есть мы делаем произвольным количество ключей в вершине но зато
3 теперь мы можем жестко требовать что для любой вершины в верно что глубины всех ее под деревьев
совпадают
совпадают то есть вот обратите внимание да то есть в овл дереве мы говорили что там совсем
жестко чтоб совпадали глубины мы делать не можем но мы можем заявить что они там отличаются на плюс
минус один это нас устроит но при этом тогда мы жестко говорили что у каждой вершины под дерево
два но там может быть каких-то не существует но два но теперь смотрите здесь глубины под деревьев
совпадают косвенным фактором является то что если вершина не лист то все под деревья существуют
то есть не может быть так что скажем что там существует тут деревья только первое второе третье
и 27 вот что нет то не такого не бывает либо существует все либо не существует никого вот
тут все очень удобно в этом плане вот так вот так что вот такая вот балансировочка ну в принципе
в прошлый раз мы кажется даже вывели что на самом деле глубина у нас оказывается то есть глубина
всего дерева у нас не превосходит чего там у нас было вот да вот какая-то вот такая штука да у
нас была не будем сейчас повторять вывод собственно в качестве упражнения можно привести
вот и чему это нас приводит но то есть она нас приводит к тому что глубина вполне логарифмична
с этим жить вполне можно но как конкретно с этим жить вот но более того нам то есть мы наложим
на себя еще дополнительное ограничение как минимум на вставках и удалениях потому что
напоминаю что откуда мы такое взяли чтобы в вершине хранилось много ключей то есть мы это
взяли для для таких деревьев которые мы просто в оперативной памяти как у нас там на олимпиадах
обычно принято хранить не будем то есть смысл будет заключаться в том что в оперативной
памяти мы в каждый момент времени имеем право хранить от единицы чем не сильно желательно с
большой константой от единицы вершин вот все остальные вершины хранятся где-то там в
какой-то удаленной памяти ну там начинают жесткого диска и заканчивая там где-нибудь там из интернета
скачиваем откуда-то вот и поэтому хочется сделать так чтобы этих скачиваний было как можно меньше
но по константе то есть понятно что их должно быть наверно от логарифма потому что там я там
ясно наверно чтобы там проделать какие-то инсерты дилиты наверно уж как-то быстрее чем
зологарифа мы это делать не будем ибо у нас не амортизация у нас невероятности эти наши любимые
но вот я да но вот я сообщаю маленький приятный факт это еще одно дерево с честной асимптотикой
то есть у нас его нет у нас сегодня будет конечно же там мистическое дерево с амортизированной асимптотикой
да но которые сплои естественно вот но до чем мы все-таки с б дерево вот и вот то есть бы у нас
дерево будет с честной асимптотикой потому что будет от логарифма но сколько скачиваний вершин нам
для этого потребуется вот ну и но вот но очень хотелось бы конечно уложиться в идеале совсем
прям вот прям реально в лог но вот но давайте смотреть как же у нас это будет получаться
вот что что ну хотя хотя какие у нас операции вообще хочется делать вот самые базовые операции
какие хочется делать вообще ну да по модулю константы да как всегда так ну крейтс ну крейтс
допустим просто да первую очередь нас интересует на самом деле первая конечно операция нас интересует
а так интересует insert и нас интересует там delete ну или там erase вот давайте попробуем для
разминочки написать что-то типа search но нет понятно что легко но нам это нужно в первую
очередь для того чтобы так ознакомиться с инфраструктурой которая у нас есть так ну так давайте
дать так начнем с того что у нас даже что у нас вершине вообще есть ну понятно что для
программирования этой вершины нам конечно потребуется наверное там мистическое слово template
ну как сказать мне кажется что пройтись по списку легче чем удалять ну по разному на
самом деле это делается но вот ну можно в списке можно там векторе на самом деле так
ну да ну для этого тогда при скачке надо там элементы какие-то в сет храни так что знаете
легче уже легче в массиве хранить что ли но как сказать смотрите обычно обычно там в этом
смысле не там за сколько мы работаем самой вершине не так принципиально просто потому
что время работы все равно будет там не будет превышать время просто скачки самой вершины на
самом деле так ну значит что у нас тут и так ну вот ну то есть получается у нас такое класс
ноде что мы в нем храним ну допустим там что что можно ну вот ну можно ладно там для
простоты допустим какой-нибудь вектор давайте хранить вектор int допустим так как мы будем как
называть ключи да так и так и будем называть главное капсум не писать а так так а действительно
зачем и писать ну как сказать нет ну как вам сказать нет template наверное помешает просто
потому что как бы то есть он не понадобится в самой ноде но он потребуется при реализации всего
остального в прочем тем более шалат не нужно относиться к этому как к идеальному коду особенно
потому что в силу того что мы собираемся писать дальше а что мы собираемся писать дальше
ну вот то есть дальше заметим что у нас должен быть мистически мистическая речь то по которому
мы должны писать указатель то есть по которому мы должны скачивать детей вот причем это необычный
указатель это какая-то мистика как да да это не но звездочка а какой-то да
сам почему сам да но лучше не на солнце не надо на так но лучше да давайте какой-нибудь
но дайди что ли вот так что вот ну допустим будет вектор а вот но дайде это не что вместо
указателя то есть это некий объект то есть пока то есть который указывать на вершину где-то там
в этом вашем интернете ее можно скачать но того что у нас интерфейс так хорошо мы умеем только
там скачивать вершину целиком и кстати загружать вершину целиком тоже вот это в том-то и прикол
что обычно нет там обычно оказывается что там скачать скажем один ключик и скачать
50 ключиков это оказывается примерно одно и то же но помните мы с диском уже с жестким диском
уже сталкивались такой ситуацией что оказывалось что там скажем один элемент и скачать и несколько
там подряд приличного размера для нас прям было одно и то же буквально ну да нет ну да типа того
да то есть да нет конечно нет речь не будет идти а т равно 10 пятый боже упаси конечно нет но там
ты обычно там упинается константа типа 50 там 50 там может сотчика там не настолько то есть 10
пятая конечно классно да потому что в лимпиадах ограничениях тогда у нас все бы хранилось в
одной вершине да да и замечательно давайте тогда внутри каждой вершины хранить эти элементы в да
действительно каком-нибудь сете да вот так вот давайте попробуем значит примерно понять как
с этим работать так ну и все что у нас есть конечно это там но надо вот но например что-нибудь типа
но ди айди рут вот допустим какой-нибудь рут у нас есть вот и так значит теперь вот давайте
выжим функцию серч но вот да действительно можно до лучшее написать конечно до лучше
написать и не вызывать чем вызывать но не написать да так но давайте попробуем так
для разминочки нет хотя в принципе может быть нет но мы уже себе написали в интерфейсе
срочи и пишем срочи вайну хорошо-хорошо файнт ладно так нет тогда это вообще написать
экзист во все во чего с английским окей окей хорошо хорошо хорошо да все ладно но почему бы не ну
для начала можем хотите экзиста можно было вообще каунт его назвать но ладно так так ну вот так ну
давайте еще о вот что еще надо было в шаблон занести то вот а ну да на самом деле да хорошему
надо это сюда еще писать да ну тип ключа да хорошему надо еще компара так там сюда написать но
это какая тебе разница пробьет люк или не дам она о чем мы хотим ой-ой-ой все да действительно все
безобразие ой господи зачем я попросил чтобы не снимали на господи а да действительно ну да
надо намек на то на каком языке последние годы живу да но правда я там геометрию пишу они вот это
вот ну вот ну ладно до нее мы в следующем семестре тоже доберемся не в следующем
встрече вот так вот и так хотим найти ключик значит смотрите значит но допустим давайте
вот здесь можно найти прям допустим самое простое но где допустим айти кур так допустим ну равно
естественно рут так но но вот но и допустим while там допустим кур точка valid то есть
во первых там пока этот кур указывает хоть на какую-то вершину значит что мы говорим там
но где так сказать там от бла-бла-бла там допустим но где равно значит там соответственно
ну назовем это даун лот но где откуда вот так ну что тут можно сказать так да сразу при
ага ой а походу имела бы смысл на самом деле ключики нумеровать нуля да
да да да естественно ничего нет ну как бы найти да тут минус единичка тут когда совершенно
но да но в данном случае как всегда значит ищем наш ключик как мы его ищем вот ну естественно
int пишем int num равно lower bound естественно но лавер баунт от чего но как всегда но где точка
кейс точкой меги но где точка кейс точка и и соответственно что там еще ну собственно кейда вот
а то мало ли то вдруг вы там побежите фориком это писать там каким-то непонятно нет ну скажем
так мы предполагаем ваши знания на входе не настолько нулевые но да да да шесть ацектированный
массив то существует вот такая магическая функция да вас экзамен по эстреле уже был вот так вот так
ну и минус соответственно понятно но где точка кейс точка беги вот так но что здесь можно
сказать но во первых скажем что если оказывается что значит дум там меньше соответственно этого
сайза там да ой но где точка кейс точка сайз там энд энд там соответственно там нодя точка кейс
нумовая прям равно нашему ключу то выбросится с криком тру вот в противном случае что мы
делаем в противном случае так и пишем кур равно нодя точка чилдер а ну и в общем-то все но остается
там сам в конце вайла остается только выбросится с криком фолс и и на этом все вот так ну вот
примерно так экзис может выглядеть обратить внимание приятность данного экзиса заключается
в том что мы с вами в каждый момент времени храним не более чем один вершина да вот у кого-то мог
быть соблазн здесь на самом деле вызвать вызваться рекурсивно но б-дерево это не та структура данных
в которой надо вызваться рекурсивно но вот потому что соответственно портирую если у вас была бы
тут рекурсия глубины логарифом то вы бы хранили логарифом вершин а этого нам не нужно вот ну
в общем-то не случайно рекомендует что при прочих равных рекурсию лучше избегать вот ровно
соответственно ровно по причине там хранение кучи всего лишнего вот например так что так
выглядит экзис так есть ли тут какие-то вопросы
да нет наверное
окей
так хорошо да нет наверное так ну хорошо ладно это был такой
но здесь я просто честно думаю дальше может год даже писать не будем просто здесь хотелось
просто показать чем мы вообще работаем как-то вообще примерно выглядит потому что в инсерта
хабиритах конечно же хранение одной вершины в один момент времени мы конечно не обойдемся
вот чем же мы обойдемся так ладно давайте ну в первую очередь давайте это сотрем я думаю это
нам уже не нужно вот значит вот давайте-ка с вами думать как же нам сделать например инсерт это
такая задача медиум у нас как всегда как у нас как как часто бывало на старых добрых топ кодерах
есть задача easy задача медиум задача хард да потом пришел кут форсис где задача стала 5 ну вот
и соответственно ну и такое бывает
еще у меня три из трех падала правда не на код форсис но да а на топ кодере ну бывает
не не не ну не не не это из мемасов пепетромитричева тесты там есть на самом деле да если
петр беда в комнате где сидит петр митричев отключает системные тесты просто все что он не
почел он дел руками ставится accept это мы помним да это мы эту классику мы помним вот и так
инсерт как же нам ставить в дерево элемент желательно не сильно большое количество вершин
загружая так но идея на самом деле очень просто что в идеале конечно идея простая то есть если
его нету да ну допустим мы откуда-то знаем что его нету да хотя на самом деле параллельно мы
будем проверять то можно просто пройти до листа в котором он есть и торжественно в этот лист его
вот вот у нас корень значит мы тут идем там идем идем идем идем идем идем идем идем идем
шли шли шли и вот о пришли это лист допустим да ну мы считаем что нет но преимущество в том что
пока мы идем вот так мы заодно еще и можем это случайно выяснить ну вот что что есть ли этот
ключ если мы где-то его по пути встретили значит мы торжественно сообщают что он уже есть и как бы
вставлять не надо ну или там я не знаю можно конечно забабахать там мульти сет но это уже в
зависимости от задачи но здесь это как видите не принципиально потому что в идеале в идеале
хотелось бы конечно сделать что-то самое простая версия если мы там это простые олимпиадники
которым там заморачиваться а скачку не надо то есть мы там мы простые олимпиады там в этих ваших
банках не работали там собственно не принципиально там делаем и 5 запросов базе данных или 25 вот
вот нет я тоже в банках не работал но мне брат просто рассказывал нет 10 не принципиально потому
что 10 константа а вот если не в 10 облагорифом вот это уже тогда да да ну хорошо хорошо ладно
ладно да ладно по-разному но все равно тут как бы мышление тут все равно принципиально разное
но что тут хочется хочется дойти до листа и сказать так хорошо вот мы его не нашли до листа дошли
никого не нашли что делать куда вставлять ну и те казалось бы простая давайте тупо вставим
вот в этот список элемент и возрадуемся что нам мешает возрадоваться полной мере какой нет
глубина вообще не поменялась ни у кого конфигурация дерева вообще пока не поменялась от того что
вы вставили в дерево какой-то там в лист какой-то ключ прям список да то есть конфигурация этих
менялась нет постоп так внимание внимание никакого под дерево у нас не появилось например у нас
в листе есть просто список ключиков да но да но они все пустые да да напоминаю да пойте
фишка б дерево да что как бы либо все дети пустые либо все дети не пустые это вот это очень удобно
то есть знаете когда у вас 57 детей не надо думать что у вас там 25 и пустой 27 нет там соответственно
вот то есть все просто как бы все все вот все одинаковые то есть каждый отвечает за свой диапазон
ключей но как бы идейно все одинаковые вот поэтому в данном случае для нас в общем не сильно большая
проблема казалось бы просто если у нас есть список ключиков ну что вставляем куда-то в список до
количества детей величества 1 все равно все они пустые какая разница поэтому мешает нам немножко
другая вещь только вот так пока никто не сказал да как бы мешает нам то что количество ключей
могло стать неожиданно больше чем 2t-1 да если нам повезло их меньше чем 2t-1 то мы в этом
месте заканчиваем работу то есть дерево вообще не поменялось структурно там поменялось только
тут что какие-то ключи да но отберите да да да совершенно верно что делать если у нас тут
стало количество вершин 2t но идея крайне простая значит раз у нас тут образовалось 2t детей так
давайте сделаем неожиданную вещь мы выберем медиану среди этих ключиков и вынесем ее в родителя
то есть операция будет выглядеть так давайте даже отдельно нарисуем вот желала была допустим
у нас вершинка и вот у нее где-то вот здесь был ребенок и у ребенка неожиданно стало
2t детей тогда мы делаем следующее так смотрите что мы будем делать значит мы будем говорить что
тут t-1 допустим тут видимо t и вот есть этот мистический ключик мы его назовем
вот мы его назовем ключик обведенный в красный кружочек вот и сделаем мы
теперь следующую мистическую штуку значит в этой вот корневой вершине у нас вот сокрых
раз два три четыре пять шесть семь раз два три четыре пять шесть семь раз два и появляется
торжественно вот этот ключик обведенный в красный кружочек и вместо одного ребенка здесь
появляется два вот так что мы как всегда как говорится мы снова экспериментируем в области
воспитания на этот раз мы распиливаем ребенка на две половинки вот да ну собственно о чем мы
только не делаем нашу делать нашу такой в прошлый раз помнится это кладбище смёрзвали
да и чем мы там прошлом году занимались так вы в прошлом году дитей а у нас там кучи были
мы там тоже могли дитей резать да все нормально да господи да но я то ведь оно в этот день у
нас двойственные деревья поиска теперь тут это как бы мы у нас как бы это мы сейчас будем это не
только пилить детей но это переворачивать деревья еще мы будем всякие но можно может даже сегодня
но не совсем ставку-то в этот массив-то вы все равно будете за там вот и делать так
что скорее т h получается а есть да это был бы кайф если бы это был один только маленькая
проблема после этой операции когда мы это сделали но скажем так но я так скорее всего
наверное да можно показать скорее всего можно показать что если вы там делаете n подряд вставок
то они суммарно наверное сделаются за там вот это да хотя не факт потому что мы на каждом шаг
потому что мы на каждом шаге все равно делаем загрузку и делаем поиск поэтому так что с этой
точки зрения тут лучше да ты аж не считать вот но заметим да что просто так на этом мы остановиться
не можем потому что может так случиться может так случиться шуме эту вершину будем прообразывать
куда-то вверх правда так но нет как бы идеи на олимпиадном в общем-то как бы в принципе никто
нам не мешает все это прообразывать прообразывать до тех пор пока надо и в худшем случае может
произойти только то что мы дойдем прям аж до до корня и выяснится что аж до в корне уже 2t
элементов что тогда произойдет да именно тогда мы сделаем новый корень и соответственно и двух
ему детей вот обратите внимание ровно в этой ситуации глубина дерева вообще меняется но
обратите внимание что конечно ничего страшного не происходит но в том плане что как бы все под
деревья все равно остаются одинаковыми вот но как видим глубина меняться можно это нормально да
потому что понятно что если вы там было у вас пустое дерево глубину 0 вы добавили туда миллион
элементов наверное каким-то образом глубина должна была стать чем-то адекватным вот но такая
реализация нас не очень устроит то есть как бы с точки зрения там там олимпиад может она свою
точке зрением скачивания вершин давайте думать сколько вершин нам придется скачать на самом
деле получается нам придется качать два 2 умножить на глубину вершина правда потому что нам придется
сверху вниз пройти потом еще снизу верхови а еще напищом еще еще доп проблема такая что нам придется
для каждой вершины снизу еще и предка качать у нас стати в интерфейсе мы родителя кстати
не прописывали да но родителей все равно очень бы не хотелось хранить вот
по какой причине обратить внимание что дело в том что если у вас родитель
поменялся вот вот такого рода да то придется у всех внуков видимо поменять
храним стыда только да ваша то есть мы храним не логарифом вершин по которым
спускались логарифом айдишки кав а да окей хорошо выкрутились
ну как я уже сказал но я сказал ну плюс минус да вот ну как всегда знаете это
знаете классические задачи у вас там были в седьмом классе такие задачи что там
это там как бы на вход подаются 10 чисел там вам нужны там что-то типа сейчас как
нет нужно вывести к сумму при этом разрешается использовать не более трех переменных но были
у вас такие задачи седьмом классе где-нибудь такие знаете упражнения на сэкл-4 такое
классическая что сложная задача не ну а сколько ну считай н а ну да потому
не надо считать потому что у нас 10 чисел нам это это знаете поэтому поэтому храним x
который мы считаем храним анс в котором храним ответ и заводим переменную и как
индекс цикла все неприятного да нет нет нет нет третьего нет прийдите до итерации
цикла в чем-то хранить придется там фор и от одного до 10 те придется ну хорошо там
10 заменяется на там действительно за 200 там заменяется на 500 вы пишете на турбо
паскаля там сильно большой код не сработает да ладно вот но здесь фишка в другом да здесь
конечно то есть в принципе да то есть мы до два логарифма считывание сделали но возникает
вопрос они взяли все-таки количество считываний по оптимизировать вот я утверждаю что очень
хочется сделать так чтобы значит чтобы вершины по камере считывали не более чем логарифм раз
ну загружали естественно как получится
но почему да он лото плод какая разница что такое считывать ну считывать это вот да он
вот загрузить вершину откуда-то ну как бы да ну загрузить но да он лодчо
что ну мы как бы сейчас получать две глубины туда обратно хочется обойтись только так
ну как бы да ну загрузить себе вершину да ну вот а вот хочется этого избегать нет пока два нет
почему но а нету я имею в виду только только скачивание потому что да понятно что там все
эти вершины там придется потом загружать еще и в новом виде понятно да но но вот вот чего
но наоборот сервера локально но в плане мы данного это сервера нас а плот с нас на
сервер да а загрузить то куда в какую сторону ну к нам ну не загрузить скачать
что ну так не понял вопроса а плоте так и называю а ну а план вот но вот от плотну
там собственно там положить в память там отправить отправить на сервер то самое
ну потому что это могут быть высокочастотные запросы вот я вот не случайно вот вспомнил опыт
работы братов сбербанки вот у них там действительно было принципиально в каком
момент чтобы там в базе данных обращение было прям вот как можно меньше там 5 или 25 им там
было дожути принципиально то есть как бы то есть как бы каждая операция до что вы там работать
желательно максимально быстро вот поэтому даже если глубина оказалась бы небольшая то как бы
тем не менее все равно там будет ли у вас операция работать за там 300 миллисекунд или за там 10
миллисекунд это про вот дожути принципиально вот ну вот и хочется конечно звать от скачек конечно
от лишних скачек конечно избавляться вот как бы сделать так чтобы не скачивать вершины
на обратном пути ну когда ну как бы когда идем нам нужна новая вершина мы ее скачиваем
финин слово скачиваем тоже вызывает коллизию вот вот давайте так и скачиваем да
получается делаем как-то в любой операции нет да ну да без этого никак безусловно
нет но мы ее скорее закачать нет мы ее будем закачивать они это там и обыкда
ну да непонятно вот спрашивает так ну а давайте так без тюрьмы если отместить
терминологически там там собственно вопрос это там суть остается как лишний раз эту вершину не
считывать что у нас есть вершинка в которой строго меньше чем 2t-1 то понятно что выше уже
так верно а если в ней 2t-1 что делать вот можно но вот нет вот фишка в том что добыть если мы
допустим даже знаем что элемента у нас нет может быть такая проблема что если мы просто придем
вершины у нее 2t-1 ключей то может оказаться неприятная ситуация чтобы всех ее всех всех
ее потомков по 2t-1 детей но это да но это да да но
да но заранее да но заранее это сложно поэтому классическая версия действительно здесь
предлагает следующее то есть давайте просто хранить этот вариант что мы добавляем вершину
в под дерево у корня которого заведомо меньше чем 2t-1 детей то есть мы не будем про то есть мы
будем прям превратим это себе в три в вариант мы будем работать только с вершиной у которой
меньше чем 2t-1 ключей то есть что нам это да но во первых да но начало с того что если нам
не повезло и в корне 2t-1 детей то в общем-то то тогда глубина дерева так жестко в этом месте
меняется да то есть смотрите обратите внимание почему тут именно t-1 и 2t-1 то есть классическим
распилом на самом деле является именно когда ключиков 2t-1 и в этот момент можно распилить на
две вершины равно как и наоборот если у вас есть две соседние вершины по t-1 ключиков то в
принципе можно как бы один из ключиков сверху в общем-то спустить в этом месте но если там
конечно достаточно много ключей но проделит мы сейчас будем еще отдельно разговаривать вот
вот то есть на самом деле вот классическим распилом скорее вот это является вот и тогда
идея такая то есть давайте мы просто идем идем идем и в каждый момент времени у нас но после
того как мы с корнем разобрались мы говорим так мы находимся в вершине и у нее строго меньше
чем 2t-1 ключей ну для чего мы это делаем это для того чтобы мы из ребенка в эту вершину ключик
то есть мы понимаем в какой ребенок в какого ребенка нам надо идти и что так если у этого
ребенка 2t-1 ключей значит мы его распиливаем значит у родителя ключиков становится на 1 больше
мы прям добились того что мы можем так сделать вот но при этом значит после того как мы это
сделали мы переходим в ребенку которого заведомо там t-1 ключик но нам уже плевать потому что мы
теперь работаем не с родителем а там с одним из этих двух ребенков ну или там если тут было
в принципе 2t-1 значит этого ребенка идет то что приятно то есть приятно тем что мы действительно
идем прям идем вниз вниз вниз вверх мы уже больше не ходим и в конце концов мы приходим в лист у
которого меньше чем 2t-1 ключей и это означает что в этого листа просто надо этот ключик вставить
и работу завершить ну или там я не знаю например можно при спец на самом деле с
этим эффектом тоже если мы там попутно ключик нашли то в общем-то давайте выбросимся вот так
ничего страшного в общем-то конечно тут то есть конечно получится что экзис поменял дерево но
ничего страшного вот так же разные реализации могут быть но почему тут надо копать чтобы
деревья кстати вот кстати в тех самых базах данных кстати бы деревья очень любят на самом
деле что да нет а ну да ну корень придется отдельно за и файт потому что начинаем с того
что проверяем если в корне 2 т-1 детей то как бы его распиливаем и файт придется отдельно по
той простой причине что как бы в этом месте меняется собственно корень и мы не можем как бы
предков ставить да тот и оно тот и оно то есть придется это вот то есть придется этого предка
создать да как говорится было у нас корень и было у нас там это называется 7 там верховных
министров но один стал немножко ровнее да ну так ну я не боюсь там и файт все равно придется там
если это вершина фиктивная совершенно нефективная так что проблемы лишний вайфа не на самом деле
не решит то есть да то есть придется тут немножко это там пострадать чуть-чуть а а элементарно
когда мы пришли в лист мы обнаружили что там меньше чем 2 т-1 детей то есть все что вам надо
это пола значит вставить список этот ключик и собственно загрузить вершину то есть отправить
вершину домой по тому же адресу нет почему нет измениться как раз могут тут очень много кто на
самом деле то есть они там все попутно могут измениться потому что во всех там произошло
вот это пропихивание но просто фишка в том что как бы допустим вот эта вершина изменилась но
окей мы там значит распилили там допустим эту вершину на 2 там увеличили ключик там и отправили
там и в эту вершину там отправили собственно на сервер что тут оказывается ключиков теперь
чуть больше вместо вот этого ребенка есть вот эти два ребенка ну как повезет в худшем случае
поменяется все потому что если вы там в переполненное дерево запихивает но как что такой суммарно
только инсерты туда суммарно это будет не много раз но как повезет что есть еще и рейсы а
то может но вот то есть может и там сейчас добавить в переполнен а потом сразу дарил потом
ну как всегда но там как всегда по модулю того что там там миллион инсертов с нуля
наверное будут работать там за там завинью наверное да скорее да но может и нет но
но по сути да но тут дальше как повезет потому что тут как бы тут классический симпатический
анализ тут уже не совсем так работает но нет мы говорим так в каждой вершине с которой мы
работаем и прям требуем что в ней было меньше чем 2 т-1 ключей поддержим это так думаем куда
идти в какого ребенка так берем этого ребенка если выясняется что у него 2 т-1 ключей то значит
мы делаем вот такой распил и там переходим в нужного ребенка вот этот
а почему там должно что-то сломаться по глубинам
нет а ну сейчас сейчас ну чего не но да то есть мы как бы вы мы выносим ключик как бы вот
при этом но то при этом нет а где глубины поменялись вообще у под деревьев вот этих
того у всех вот этих поддельев на самом деле деревья не поменялись глубины не поменялись
что поменялось-то вообще но вот а ну ну ну допустим вот тут какие-то дети вот так вот выглядели
Ну мы могли, но нам уже по барабану, потому что мы идем в ребенка.
Так, ну допустим.
Все, что мы заявляли, все еще работаем.
Ну порядок естественно сохраняется, вот все.
Ну то есть да, мы посмотрим там, в зависимости от того, наш ключик как бы меньше или больше этого, мы спустимся либо в этого ребенка, либо в этого.
Нет, это неважно. Ну просто да. Так, ну важный момент конечно заключается в том, что если тут ребенка было, если вот в этом ребенка было меньше, чем 2t-1t, то мы естественно этого не делаем.
И просто спускаемся в этого ребенка.
А здесь как бы да, мы переходим в ребенка, ну там допустим этого, ну или стоит он логично и повторяем операцию.
То есть тут тоже выясняем в какого ребенка еще здесь надо спускаться, тоже там подымаем вершину если надо, ну и все.
Так что видим, все очень просто.
Вот. Ну как очень, да.
Вот.
То есть как бы да, вот такой вот аккуратненький проходик тут принято делать.
По сути глубина дерева меняется только в высоту самого корня.
Да.
Да, да, да.
То есть да, дайте как в красно-черном дереве, кстати тоже такой эффект есть, потому что там черная глубина меняется только в том случае, если мы там красный корень торжественно перекрашиваем в черный цвет.
Вот.
Вот.
Так что получается такой вот красивый инсерт у нас получился.
А у следующего два т-скачивания будет два аж скачиваний?
Нет, обратите внимание, нет.
Скачиваний у нас теперь стало аж.
Потому что мы для каждой вершины с которой работаем скачиваем ровно одного ребенка.
Другой вопрос, что эти ребенки, ребенок мог распилиться на два там как бы, как это там загрузка будет выглядеть, это отдельная песня.
Точнее, ну загрузка в смысле отправка.
Вот.
Но скачер теперь аж, вот собственно ровно из-за этого мы тут сейчас и решили наложить в себя такое страдание дополнительное.
А загрузок в сети их стало?
Ну их, ну как бы.
Ну как сказать, загрузок в сети собственно от этого меньше.
Но осталось на самом деле примерно столько же.
Потому что обратите внимание, при старом подходе мы как бы при вот этом проходе мы только скачивали, но ничего не отправляли.
Ну точнее ничего не меняли.
Вот.
Но зато здесь мы могли идти тут сверху вниз, и там, ну вот.
Вот.
Но зато здесь мы могли идти тут сверху вниз, и там соответственно отправок вершин могло быть там до, ну сколько там, до 2 аж получается.
Потому что каждая вершина вот из этих вот могла распилиться на две.
Вот.
Ну там что-то там, ну да типа 2 аж получается, да.
Вот.
Чего?
А сейчас их тоже 2 аж.
Ну если аккуратно реализовывать, если в тупую, то 3 аж, если прям вот при этом распили, прям их сразу загружать.
Но на самом деле нам это не нужно.
То есть на самом деле как бы нам нужно загрузить, загружать только то, что мы уже менять не собираемся.
Если мы там скажем, хотим пойти в эту вершину, то прямо сейчас ее торопиться загружать не надо.
Главное только запомнить ID-шник, по которому ее потом надо, значит надо отправить, но пока ее загружать не надо.
И получится те же самые 2 аж.
Вот.
Чего? Кого?
Вот.
Не волнуйся.
Вот.
Вот.
Так что вот такая диспозиция.
Значит такая вот красивая диспозиция у нас получается.
Так, что мы собственно с этим теперь.
Ну вот.
Но это была как бы задача медиум.
И теперь у нас возникает такая классическая задача HARD.
Теперь выполнить удаление ключа из этого всего.
Чего?
Чего?
Ещё раз, то есть у нас вот такие 2 аж или аж скачиваем?
Ну, которые до нас нашу предку тоже может скачать.
Ну, в смысле, мы можем хранить две вершинки.
Нет, ну все равно аж мы как бы ска... Походу, нет, скачиваем мы только путь от корня до вот этого листа.
То есть да, мы потом распиливаем их, потом перезагружаем, но как бы скачиваем только аж теперь.
Прям честный путь от этого вот корня до этого.
То есть по сути вот ска... То есть потому что скачиваем мы ровно то же самое, что скачивали бы вот в этом вот экзистер.
Собственно, вот ради этого мы это все изобрели вообще.
Вот.
Всё? Всё? Да? Нет? Наверное?
Бл...
Вот.
Ну вот, значит, что же у нас получается дальше?
А что получается дальше? Вот. А теперь, значит, пришло время понять, а как же мы будем удалять?
Да, хоть за какую-нибудь константу вообще.
Мы также спускаемся, если мы найдем вершину, то мы с одним ребенком, то перебросим сюда из соседнего что-нибудь.
Ну вот так.
Вот.
Вот. И действительно.
Ну вот. Но про нот.
Ну вот. Ну так-то да, потому что да, вместо сплита можно делать действительно некоторые мерш.
Вот давайте внимательно посмотрим, как мы это будем делать.
То есть вот, да, вот очень хочется, давайте идем сверху вниз и прям вот храним красивый инвариант,
что в каждой вершине, в которой мы находимся,
ну, скажем так, скажем так, больше либо равно t, ну или для корня больше либо равно, ну ладно, для корня не заморачиваемся особо.
Да, больше, ну там, с корнем мы там отдельно, допустим, разберемся, да?
Ну корень у нас вообще никаких проблем нет.
Ну, хочется вот больше либо равно t, нет, ну почему?
Ну, корень, если он станет пустой, ну, не надо его.
Не, ну, не совсем.
Корень, если корень пустой, то надо тут как-то смержить, к сожалению,
потому что тут же количество, дети еще вот такие есть, с ними надо что-то сделать.
Поэтому просто так взять и удалить корень мы не можем.
Если корень пустой, у него один ребенок, поэтому...
Нет, он был, у него было два.
Нет, если корень пустой, то такого корня не было, мы его уже удалили сами.
Так, если у корня всего один ребенок, зачем нам такой корень?
Давайте лучше этого ребенка корнем и сделаем.
Ну вот, а то знаете, как оно вот, а то какой-то, а то какой-то эффективный сотрудник получается, который непонятно зачем нужен.
Все знаете, там это, сейчас как этот фильм назывался, офисный планктон, видели такой?
Нет? Нет? Нет.
Нет, нет. Там просто описывалось.
Там как бы... Ну, потому что человек очень боялся там любого аудито.
Почему боялся? Потому что пришли там аудиторы, стали спрашивать там, чем вы занимаетесь.
Там он там что-то описывает, что там очень важно, там издулзри, бэбэбэбэ, там поэтому проявляют, проявят, принять заказы.
Так, подождите, вы понимаете заказы? Нет, заказы принимает моя секретарша.
Ну вот, а вы их передаете собственно там начальству?
Нет, там эта секретарша перейдет еще одному сотруднику, а он уже идет в начальство.
а вы чем занимаетесь вот он ну понемногу я вам объясняю в индустрии очень важно там ну и
так далее там какая-то такая интеллектуаль потом говорит что мы все удивились как он работает
потом покопались и обнаружили что он был уволен еще три года назад но вследствие ошибки в
программе бухгалтерии он еще получает зарплату оказывается ну нет ну ну может и один вес но
только фильм американский если что так что но может и один вес но чем короче офисный план то
лучше посмотреть целиком там нет нет нет нет там вот вот так вот как-то было написано ладно ну
пересмотрите потом запись да прежде что и стоит пересматривать естественно вот ради этого она
вот значит смотреть и так хочется в идеале действительно неплохо было бы конечно вот давайте
нот неплохо было бы так и следить но правда тут еще оставляем подлянка сразу с полю заключается в
том что если мы вставку могли говорить что мы хотим вставлять прям только в листы никуда кроме
а да то к сожалению удали элемент который мы хотим удалить может оказаться абсолютно где угодно
но философский опрос особенно еще и по центру а нет хотя нет а нам без разницы главное что
да его можно да вершину можно опустить да но поправка просто так опустить не получится то есть
конечно идеальный для нас вариант это конечно когда значит у нас есть это вершинка которую мы
хотим удалить допустим да и у нее есть двое детей и детей потом но а у детей ровно по т-1 тогда их
можно смёрзнуть и возрадоваться так ну хорошо так хорошо ладно
то есть да действительно заметим до что в общем-то задача то есть если мы случайно шли шли шли где-то
в середине дерева нашли ключик который мы хотим удалить то никаких проблем казалось бы с этим нет
то есть легко там допустим свести то есть свести на самом деле задачу к удалению листа просто в
качестве удаляя удаляемого элемента будет там элемент который типа тут самый большой в левом под
дереве ну или самый маленький в правом под дереве то есть нот то есть не проблема
чего но нет но мы и в инсекте вообще одновременно в памяти две вершины хранили да так что тут без
вариантов вот ну хорошо да не сильно большая проблема вот но правда но тем не менее тут
конечно но но как но тем не менее вариант как-то придется соблюдать должен например потому что
заметим что слияние только если тут t-1 тут t-1 если например тут оказалось t-1 а в правом под
дереве больше либо равно t то как бы на самом деле сказать что ладно давайте там пойдем в
левом под дереве удалим самый большой элемент и его там запишем сюда это может нам вызвать
просто фундаментальные проблемы почему потому что заметим что может так случиться что в этом
подделье у всех вершин по t-1 по t-1 ключу и это означает что если вы уменьшите ключ там удалите
хотя бы один из этих ключей то дерево такой же высоты вы тупо не построите просто ключиков мало
ну нет ну да действительно можно пода можно святое действительно поверить что ладно допустим вот
из этого под дерево наверно еще можно каким-то образом выпилить там минимальный ключ хорошо
конкретно локальный вопрос действительно ладно локально решили хорошо то есть в переводе
но вот то есть действительно когда мы хотим удалять то есть мы но вот но правда для того
чтобы так смерживать нам еще придется каким-то образом гарантировать что когда мы сюда пришли
здесь больше либо равно чем-то ключиков мы либо перекидываем из соседнего ребенка в наш ключ
но но да но правда пришло время кажется делать уже единым общим образом неправда нет боже
упаси рекурсивно не надо нет мы пока требуем того же самого варианта то есть мы говоришь мы
требуем варианта того что значит мы удаляем какую-то то есть мы находимся сейчас какой-то
вершине хотим что-то из нее удалить и но в ней больше либо равно чем ты вершина вот
допустим ну как здесь можно сделать можно сейчас для простоты сейчас давайте пока вот
сейчас не будем об этом просто всем думать пока предположим что удаляемая вершина находится
по-любому в листе пока предположим позже мы снимем это предположение а вот вот в этом
то есть собственно суть того что мы сейчас обсуждаем как же мы поддерживаем но начнем
с корня конечно жил был корень в корне больше либо равно чем ты вершин вам никто не обещал
но в корне вам правда достаточно больше либо равно чем два вершин на самом деле но могло
так случиться что в корне вершина один точнее да но в смысле ключик один а детей двое и
мы допустим без ограничений общности хотим спуститься вправо вот прям вот хотим спуститься
вправо так но что делать но как всегда если там уже т или более ключиков то просто идем туда
и не паримся правда а что делать если ключиков там t-1 но тут на самом деле да все варианты уже
предлагали собственно остается их объединить тут у нас остается два случая первый случай если
нам фантастически повезло и у соседа тоже t-1 ключиков то все что нам остается это опустить
собственно этот ключик вот сюда и объявить что у нас теперь есть новый жирный корень вот понятно
да кстати в этом месте корень поменялся и вот и в этом месте у нас высота могла уменьшиться вот
так что у нас еще вот но это если нам повезло но вполне вероятно что нам не повезло
так
а ну по большому счету да только разница будет в том что у нас как бы от того что мы опустим
вершину или там делаем то что я сейчас скажу корень просто не поменяется ну по сути да поэтому
я собственно дай сейчас этот случай отдельно рассматриваешь этот случай когда у нас корень
меняется и так что делайтесь тут t-1 а тут больше либо равно t тогда спустить не получится или
ну вот ну здесь на самом деле можно выполнить по-разному да но в принципе да но на самом
деле тут два способа нас двумя способами можно жить то есть по-любому придется конечно эту
вершину опустить отсюда какую-то поднять вопрос какую ну да самый тупой что можно
делать это выполнить что-то типа левого поворота да то есть сказать что если у нас это вот допустим
это ключик x и вот у нас тут самый правый ключик допустим его будем называть и к штрих и у него
тут висит под дерево допустим альфа да ну и тут какие-то вот какая-то тут борода висит пум-пум-пум то
тогда мы просто делаем простую вещь то есть мы мы теперь объявляем что в этой вершине теперь значит
у нас становится ключиков на один меньше то есть вот та же борода да видите тут борода было из
7 с альфой теперь 6 потому что без альфа вот дерево теперь у нас значит тут и к штрихами объявляется
корнем неожиданно так ну а здесь ключиков становится на один больше пум-пум-пум и вот
тут x и от которого здесь мы вот это вот под дерево альфа и вешаем и тут бары и тут старая борода
вот так вот такая красота у нас получается то есть вот это это у нас получается такой вот
можно сказать такой поворот в б дереве но естественно естественно допустим и симметричная версия если надо
вот и кстати обратите внимание там на самом деле еще один способ на самом деле иногда
пропихивать ключик куда-нибудь пониже даже то есть обратите внимание что там можно иногда
пытаться думать что если мы хотим удалить ключик из середины не хотим ли мы случайно
действительно этот ключик там то есть на самом деле просто вот такими поворотами пропихивать
в лист чтобы потом его оттуда так жестко дали ну да но правда совсем в наглу это будет сложно
потому что как бы заметим что поворот там потребует поворот или мерч нам потребовался если тут было
т-1 вот как интересно когда каждый когда каждый опаздывающий тверк попадает на камеру вот
соответственно вот но не совсем не совсем но поворота нет но заметим что подобного рода поворот
можно применять всегда если тут больше либо равно т а тут меньше чем 2 т-1 но к сожалению оба
этих условия в общем-то обязательными не являются ну почему в этой верши тут нужно чтобы было
меньше чем 2 т-1 потому что как бы у нас тут количество ключей увеличилось на 1
ну я их 3 в корень и перенес вот он нельзя потому что тогда не тогда непонятно было бы куда
девать под дерево альфа ага и тогда и тогда глубина альфа была бы такая же как глубина
вот у этих детей инвариант на тему равности глубин бы нарушился так что увы просто так
повесить между ними альфу нельзя еще мы не хотим думать что у родителя с размером с количеством
ключей не но как сказать но мы садите мы сейчас мы сейчас рассматривали один конкретный случай
когда у нас корень и в нем один ключ да но на самом деле да заметим что в общем-то это
работает когда то есть это работает даже не просто когда у нас то есть да то есть может быть вот
так тут в принципе то есть как бы да тут вот то есть на самом деле если в этом корне на самом
деле больше чем один ребенок то в общем-то работали бы абсолютно так же разница была бы только в
том что если нам довелось опустить этот x вниз и сделать мертв что корень бы не поменялся да более
того да совершенно верно да но но да но заметим но но более того что на самом деле ровно такую же
операцию мы будем пытаться проделывать и везде и во всех случаях не только когда это вершина корень
но обратите внимание зачем нам требовать что как бы в этой вершине даже если она там есть она не
корень то тут больше либо равно чем t ключей это нам принципиально важное требование почему потому
что мы не знаем может нам придется просто эту штуку опустить и все поэтому вот больше либо равно
t нам придется жестко поддерживать потому что может так случиться что нам как бы какой-то ключик
очередной придется опустить потому что мы вот хотим там пойти в одного из его соседей их тут
вот а тут t-1 ключиков и тут t-1 ключиков тогда его придется тупо опустить без какой-то компенсации
для родителя вот так что можно соответственно это и опускать вот так что вот такая вот у нас
красота получается вот но правда теперь остается только вот собрать это все в кучку то есть хорошо
мы можем теперь запустить search и искать этот элемент только теперь искать этот элемент и
попутно делать и причем попутно еще делать так что каждый раз когда мы приходим вершину в ней уже
больше либо равно чем t ключей они как потому что если у обоих детей 2t-1 это означает что мы как
бы хотели пойти в одного из них обнаружили что их там 2t-1 что больше чем t-1 и просто туда пошли
так что отдельно этого случая у нас нет да но у нас конечно да да единственное конечно если только
мы не упомянули это вот интеллектуальную мечту что нет почему мои родители опускать принципе у
нас не было задачи опустить родителя нет а точнее так специально такой цели нет мы
опускаем родителей только если это обусловлено какой-то необходимостью да нет мы эти действия
проводили для того чтобы в ребенке куда мы хотим пойти было не минимальное количество вершин
не минимальный число ключей то есть как бы мы это делали только вот если мы хотели пойти в ребенка
а в нем t-1 ключ если там больше чем t-1 ключ мы вообще ничего не делаем тупо туда идем
да совершенно верно вот то есть на самом деле там проблема возникает но вот то есть проблема
только возникает если напоминаю мы где-то в середине то есть жила бы у нас вот середина
и тут обнаружился ключик который мы реально хотим удалить то есть если вот нашли этот
элемент но вот именно его мы хотим удалить но как бы тут дальше просто можно и в эту сторону думать
но это будет не очень оптимально если вы будете думать сторону а как бы нам эту вершину опустить
в лист но цитически можно это сделать то это не самое оптимальное просто будет так вот тогда
вам реально придется разбирать случай когда тут 2t-1 и тут 2t-1 то есть возможно вам там вам тут
реально страдать придется вот вот я поэтому да и например да вот поэтому я и проговариваю
это просто что вместо этого лучше сказать что мы лучше тогда но во первых конечно то есть мы
делаем вид что удаляем не его а того кто следующий то есть это вот который там минимум справа например
да ну вот ну точнее так тут аккуратно потому что смотрите вот мы когда нашли этот элемент мы
что делаем нет ну погодите но мой но породите и запоминать там как повезет потому что как мы
уже сказали может так случиться что ни отсюда нельзя удалять просто так ключи и не отсюда
нельзя просто так удалять ключи но потому что их тут минимальное количество для задней высоты
да да но она поэтому мы проговариваем то есть если мы встретили ключик такой да то что мы
говорим так рассмотрим двух соседних детей если у вас тут t-1 и тут t-1 ну значит мы этот ключик
торжественно опускаем сюда и продолжаем то есть у нас типа все еще теперь все еще у нас теперь
есть вершина в которой есть удаляемый элемент вот ну кстати да и но вот т.е. но но как бы она вот
теперь пока протолкнулась то есть некоторое время мы пропихиваем пропихиваем пропихиваем но в
какой-то момент неожиданно обнаружилась в какой-то вершине что ну если мы так дошли до листа то
кайф мы ее просто удаляем но если у нас обнаружилось что у нее соседние дети соседних
где-то хоть у кого-то больше либо равно t, но тут непонятно,
тут больше либо равно t, да, для нас даже тут более
худший случай будет, это когда, ну вот, то даже когда
оба больше либо равно t, но это неважно, то есть тогда
если какого-то ребенка больше либо равно t, то мы говорим,
что допустим, если у левого больше либо равно t, то мы
запускаемся, то мы как бы отсюда удаляем максимальный
элемент, то есть обратите внимание, нам заранее его
даже знать не обязательно, ну то есть можем считать,
что плюс бесконечность, когда мы придем в лист и
скажем, что надо кого-то удалить, значит мы ему удаляем
максимум и его сюда записываем, вот, понятно, да, вот, делаем
это только у того ребенка, у которого больше либо равно
t, но если тут было t-1, а тут больше либо равно t, значит
тогда удаляем минимум управа под дерево, но пока тут t-1,
тут t-1, как я уже сказал, опускаем, опускаем, опускаем, то
есть вот получается еще одна такая красивая операция,
но правда скачивать придется, конечно, уже, видимо, не
аж вершина, все-таки 2 аж, потому что для каждой вершины
нам, возможно, придется и, собственно, два, там два
ребенка скачивать и ни одного, при условии того, что мы
даем ребенку с днем t-1, ну да, но правда, как всегда,
как повезет, да, то есть нам, конечно, чаще всего будет
вести, но в лучшем случае все равно, да, а в листах
у нас тоже больше либо равно t, всегда, да, всегда, ну,
на уровне инварианта, да, а если в листе t-1, вот ровно
ради этого мы и добивались того, что когда мы придем
в лист, там будет больше либо равно t, вот, то есть как
бы закончится тем, что мы придем в лист, там больше
либо равно t вершин, значит, нужную мы торжественно удалим,
так что вот такая вот красота, вот, то есть это вот таким
вот примерно образом у нас выглядит дилет.
Мы уже не собираемся пытаться оптимизировать, чтобы меньше
Ну, тут, боюсь сказать, никак и не получится.
Ну, что подозреваю, ну, то есть там может, может кто-то
там докажет, что можно так сделать, чтобы это было
не больше чем полтора, там, аж там, или там опять же
что-нибудь про средние, там кто-нибудь докажет.
Ну, амортизировано, когда insert-delete, insert-delete, insert-delete,
ну, тут, конечно.
Ну, шутка, ну, как все сказать.
Ну, это да, ну, тут разное бывает, разное бывает.
Вот, так, ну, вот, но это вот, но это вот действительно
есть рассматривать с точки зрения действительно
промышленности.
Так, о, эти времена, московское время 10 часов 33 минуты,
это означает, что пришло время сделать перерыв.
Так, ладно, ребят, всё, поехали, поехали, поехали, поехали,
работаем, работаем, работаем, работаем, работаем repeat
repeat
expansion
Так, что ж, сейчас мы продолжим говорить об боед дереве,
но сейчас мы включим соцсостовал режим олимпийoupe, в том
плане, что мы сейчас забьём на, там, вот эти, вот, там,
там при логарифме скачиваний или там наоборот загрузок
сейчас когда мы удаляем
мы получается спускаемся туда
ну понятно, короче, спускаемся
спускаемся, да
потом мы, возможно, находим вершину, которую нужно удалить
смотрим, если оба сына по t-minus один, то мы
смёрживаем эту вершину в них и рекурсивно выпускаемся от этого
ну типа, ну типа рекурсивно
да, в противном случае делаем поворот
в противном случае
в противном случае
мы удаляем максимальную вершину, допустим, из левого
если в корне этого левого
если в левом ребёнке
хотя бы t детей
вот это и в этих, да
если там t-minus один, а у правого больше, чем t-minus один, то ну вы поняли
вот
так что соответственно
но
вот
вот, значит идём дальше
вот, значит
теперь мы попробуем
значит всё-таки изобрести сплит и мерж
так, ну здесь
как бы да, я думаю там
здесь присутствующим, наверное, не надо читать лекцию
что такое там неявное дерево поиска
явное дерево поиска, да?
или надо?
ну вообще-то говоря
ну давайте попробуем
нет, ну как сказать, ладно
потому что я помню, в прошлый раз опрасывали
выясняли, что дикартовые деревья тут писали
по-моему, чуть более чем все
мы
какой чёткий критерий
то есть надо понять, что значит термин
нет, ну обычно
ну как сказать, ладно, хорошо
значит термин, обычно вот разделяют, есть такое понятие
как там неявное, допустим, дерево поиска
заключается в следующем
ну потому что заметим, что если у нас есть
допустим обычное двоичное дерево
то у нас есть и нордер обход
помните
и нордер обход, который мы
обходим левое под дерево, записываем корень
обходим правое под дерево, помните, да?
то есть он нам позволяет, если это реально
дерево поиска, то мы таким образом
выводим все элементы, находящиеся в нём
в порядке возрастания
вот
то есть ну обычно
если мы так, то что мы
обсуждали, это называется явное дерево поиска
потому что в нём реально можно искать ключи
но заметим, что
есть вот маленькая приятная вещь
что если мы
в каждом под дерево будем хранить дополнительно
его размер, то есть в каждой вершине
храним вот переменную СЗ, да?
которая хранит сколько вершин
в под дерево, то в принципе мы за
тот же асимптотику того же самого
сёрча можем на самом деле
искать не только просто
элемент, но и, скажем, найти каты по
возрастанию элемента, но число к найдите каты
по возрастанию элемента, и это вот аккуратным
спуском тем же делается
вот
теперь возникает следующая идея
вот нам
иногда, например, хочется
то есть решать там всякие задачи, типа
например, до нас
там дано набор строчек
вот прям даже строчек вообще
ну это могут быть массивы, там
я даже сейчас скажу просто строчек
и хочется с ними делать какие-нибудь операции
типа конкатенировать строчки
да? там
там сплитить там допустим
или вставить какую-нибудь строчку там
какую-нибудь булковку там
ну и там ещё какие-нибудь операции делать
там, найди там, не знаю там, пятнадцатую букву
там, в третьей строчке
там, как угодно
вот, вот хочется такое делать
как это делать? ну идея получается такая
а давайте-ка хранить
то есть тогда в
нашем двоичном дереве
пока ещё
только что была поиска, давайте хранить
большую строчку
то есть вот, допустим, есть у нас строчка там
абракадабра какая-нибудь
то давайте хранить эту строчку
в двоичном дереве поиска таким
образом, чтобы иноридный обход выдал
ровно эту строчку
как это будет? ну например
вот я сейчас не буду гнаться со сбалансированностью
прям идеальной, то вот будет
вылететь это вот
примерно так
там абракадабра, там вот это
соответственно бетат, ну тут допустим
д, аа
так, значит
б
вот
так что
соответственно
вот
то есть ну правда заметим, что
это не является
уже классическим деревом поиска
ну просто потому, что как бы тут
о том, что там какие-то элементы меньше
каких-то, речи нет
вот, то есть, но нам
вожен только вот конкретный порядок
но мы здесь
как бы для удобства не явно подразумеваем
что у нас в вершинах
ключики есть
и это порядковый номер
соответствующего символа в строке
мы сейчас и не кардачу
принесем? нет, нет
нет, нет, нет
нет, ну
ну не то чтобы никогда
вот
вот, ну конечно
вот, нет, но это
и называется дикартач
это называется дерево
по неявному ключу
двоичное дерево с неявным ключом
почему он неявный?
потому что обратите внимание, что
в явном виде мы просто эти ключи не храним
вместо этого мы храним СЗшки
то есть реально в дереве мы храним
там один, тут один, два
тут четыре получается
один, один, три
один, два, там шесть и одиннадцать
вот
поэтому там найти
там какой-нибудь седьмой элемент
мы все еще будем искать его за логарифом
там аккуратненьким спуском
вот
так что такая вот маленькая красота
вот, понятно?
вот, понятно?
так, ну вот
так что вот красоту видим
так что красота хорошая
вот
ну а теперь вот возникает вопрос
как же делать конкатенацию?
ну вот конкатенацию или это
то конечно ключевыми
операциями у нас становятся
такие веселые вещи как
сплит и мерч
да, ну кстати
да
и это мы хотим везде
потому что мы заметим
最近 я вот ввел все с понятием
дерево по ниявному ключу
но мы заметим что у нас любое дерево
может быть дерево по ниявному ключу
то есть мы сейчас даже не будем обслуживать
дикартого дерева по ниявному ключу
то есть вместо этого
потому что мы не знаем что такое дикартовое дерево
поэтому у нас
вот мы сегодня попробуем чтобы у нас сегодня было
richt applies countries
по неявному ключу.
Ну начнём мы конечно с B дерева по неявному ключу.
Ну в B дерева конечно стоит оговориться, что B дерева
не является двоичным, но думаю как бы тут аналогию
проводите, правда.
Чего?
Почему не является двоичным?
Потому что там у вершины бывает больше чем два ребёнка.
В плане оно может быть двоичным?
Ну может быть, да.
Ну в общем ключей не является двоичным.
Ну обычно когда мы говорим о двоичном дереве, мы думаем,
что оно всегда двоичное, а тут как повезёт.
Да, конечно B деревом, да, то есть двоичное дерево
конечно да, в частном случае B дерево, особенно с константой
t равно 2, да, но вот, нет, это воронёк, а нет, это воронёк,
да, это воронёк, да, не, даже не в этом дело, просто
двоичное дерево может быть не идеально сбалансированным.
Поэтому, нет, поэтому, поэтому, поэтому да, поэтому B дерево
двоичным деревом не является от слова там.
Нет, двоичное дерево может быть идеально сбалансированным.
Ну да.
И B дерево может быть двоичным.
Да, да, да, ну хорошо, хорошо.
Ну да, да, да.
Не, кстати, t равно 2, потому что количество ключей не
менее чем t-минус 1 всё-таки.
А ещё t больше не было в двух пунктах.
Вот да, но это ровно для того, чтобы как бы в каждой
вершине был хотя бы один ключ.
Да, но это другое, да, но поэтому там, да, отдельные,
да, идеально сбалансированные двоичные дерева а-ля двоичная
куча, да, могут вполне оказаться B дерево.
Вот, ну ладно, это всё, экилибристика уже словесная пошла какая-то.
Вот, это не очень интересно.
Вот, интересно другое.
Значит, в таких деревьях по неявному ключу, да, ну
понятно, что во-первых, как делать?
Ну во-первых, конечно, у нас модифицируется немножко
операции insert, ну то есть всё, что у нас превращается
в таких деревьях, в как раз поиск атового элемента,
но во всех деревьях, в том числе и в B деревьях оно
делается так же.
Как я сказал, мы тут, ну вот, то есть там в каждой вершине
придётся реально ССС-ку хранить, но это уже там технические
детали, к тому же, как я уже сказал, мы уже этого там,
ну в основном мы себе включили олимпиянника и не паримся
по таким мелочам.
Вот.
Вот, значит, во что у нас превращается insert?
Ну insert у нас теперь просто, ну insert у нас изменяется
каким образом?
Он изменяется тем, что у нас есть ключик, да, то есть
вместо того, чтобы вставлять ключик, мы вставляем ключик
в заданную позицию, то есть раньше мы его вставляли,
куда его вставлять мы думали там по результатам сравнения,
а теперь мы его куда мы его вставляем мы смотрим по
результатам каких там вычислений и сайзов под деревьев.
Так, это понятно о чём я говорю, да?
Вот.
Ну тут пока не...
Вот.
Так.
Вот давайте-ка вот эту штучку мы тоже проденем, а то...
Вот.
Вот.
Нет.
Почему?
Нет.
До этого я вот так вот говорил.
То есть знаете, вы ведем наш репортаж там, вот это вот
всё.
И вот.
Ну когда-то так было, знаете, когда давным-давно, когда
на сцену ещё выбегали вообще с этими вот микрофонами
типа аля дубинка, вот это вот всё.
А, ну причем там и сейчас такое бывает, если удобно.
Вот.
Там можно какие-то.
Вот.
Так что ответ.
Не, ну самое главное там не начать это, если вы там
не начать там выбирать без микрофона и не начать
там просто что-то кричать, а потом когда вам дают
микрофон, взять микрофон и начать вот так же вот кричать.
Так.
Ладно.
Ну.
Ну это будет уже немножко другой герой, на самом деле.
Да.
Так.
Так вот.
Значит, что хочется делать?
Ну вот.
Значит, ну соответственно, вставка, как вы сказали,
то есть там вставка делается так же, только в какое под
дерево вставлять мы уже решаем за счет того, что там
сайзами.
Вот.
Соответственно, там вот аккуратненько.
Вот.
Ну и с дилитами, в общем-то, то же самое, да, когда мы
говорим дилит, то есть мы теперь дилит говорим не
удали элемент равный вот этому, а удали элемент номер
такой.
Но принципиально, например, в Б-дереве, ну, равно как
и в ВВЛ красночерном, собственно, от этого сами по себе реализации
инсортов, дилитов и исчерчей не меняются, согласны?
Вот.
Ну а в неявном, ну, когда у нас есть неявный ключ,
хочется, конечно, делать операции, в первую очередь,
сплит и мерч.
Вот тут надо формально прописать, что это такое.
Что такое, действительно, сплит и мерч?
Вот что такое сплит и мерч.
Ну, операция сплит, это, по сути, так.
То есть, ну она вот, как я уже сказал, то есть операция
сплит, то есть она получает на вход такой вот этот вот
неявный массив, то есть, ну, по сути, каждое дерево
хранит в себе, по сути, такой неявный массив, ну, или строчку.
И число к.
И задача теперь заключается в том, чтобы разбить элементы,
то есть, строчку на две, то есть, как бы в одной из
которых, то есть, если тут было n элементов, то в левом
должно остаться k, а во втором n-k, естественно, с сохранением
порядка.
Это мы будем называть сплит.
Вот, понятно, да?
Вот.
Ну, а также есть, конечно, еще операция мерч, но она
получает на вход, ну, по крайней мере, по указателям,
два массивчика размера, допустим, n1 и n2, и делает из них единый
массив размера n1 плюс n2.
Да, заметим, никаких копирований элементов тут особо не происходит,
то есть, в том плане, что когда мы делаем сплит, вот
это дерево само по себе перестает существовать.
То есть, все его элементы перенаправляются в k, вот
в эти два.
Ну, и тут, наоборот, если вот эти два дерева перестают
существовать, все их элементы отправляются сюда.
Вот.
Понятная идея, да?
То есть, ну, заметим, что, кстати, если мы реализуем
такие сплиты и мержи, то, в общем-то, кстати, вставки
и удаления на самом деле у нас уже появятся автоматически,
правда?
Ну, потому что как добавить элемент куда-нибудь?
Да, ну, просто сделаем сплит, создадим там, ну, в каждом
дереве у нас есть операция, создай дерево из одного
ключа, да?
И после этого сделай два мержа.
Ну, или если вы хотите удалить элемент, то как бы два сплита
и один мерж тоже решают проблему.
И даже сердж.
Ну, да, ну, теоретически, да, и сердж можно сделать
с помощью сплита и мержа, конечно.
Хотя нет, ну, вот.
Иногда они требуются.
Надо просто вернуть назад потом.
Ну, да.
Да, ну, это, конечно, мерзость та еще.
Но, впрочем, тут это, конечно, так теоретически.
Но, как бы, вопрос как бы, как это реализовать практически?
Потому что тут я уже молчу о всяких там технологиях
отложенных операций, на самом деле.
Ну, потому что раз вы писали дикартовые деревья, там
скорее всего писали, там, скажем, прибавление.
То есть, например, если у вас это не строчка, а массив,
то, например, нам иногда хочется делать, скажем,
прибавление на отрезке, да, присваивание на отрезке.
Ну, или там вообще его величество реверс на отрезке.
Ну, да.
И всякие реверс на подотреске.
Так, ну, поднимите руки.
Кто когда-нибудь писал реверс на подотреске?
Так.
Понятно.
Да.
За квадрат.
Да.
Понятно.
Нет, ну, все, нет, в смысле, нормально за логарифом
дикартячки.
Как?
Как его, нет, как него не надо.
Ну, вот.
Нет, сплит реверс на подотреске в дикартячке.
Ладно, хорошо.
Кто писал реверс на подотреске в дикартячке?
Хорошо.
А, вот.
А, то есть, нашлись те, кто тут пихал корневую.
Понятно.
Ну, ладно.
Значит, придется потом в свое время это...
Значит, придется в свое время это отдельно обсуждать.
Окей.
Ревью?
Нет.
Ну, где-то, думаю, будут.
Что?
Чего вы?
С кодом, с кодом.
Не, в этой теме у нас стеретических задач не будет.
Не, в этой теме у нас стеретических задач не будет.
Слушай, мне страшно накаркать.
Если честно, то, что у меня, честно скажу, у меня
что-то так забывает, что если я скажу, что вот задачи
будут, скажем, сегодня, то вот там
просто сложится просто тысячи звезд, чтобы
сегодня не было.
Честно скажу, я планировал, как бы сегодня там поехать
в фистех, там, собственно, сесть и действительно в том числе
контест этот сделать, если честно.
Вот.
Тьфу, тьфу, тьфу, тьфу, тьфу, тьфу, тьфу, тьфу, тьфу.
Да, потом если приеду на фистех, там
меня поймает Демид
и дальше мы будем...
И дальше мы будем до 12 ночи...
Вы поймаете Демида?
Ну, я не знаю, есть проблема, что Демид, по-моему,
на фистехе особо не бывает, я так понимаю.
Последнее время, да.
Особенно когда у нас появились...
Последнее время, а в принципе, по-моему, он это...
Ну и что?
Ну он катается...
Нет, а что катается, а что олипиадами занимается, что ли?
Ну, в смысле, как участник
или что?
А, ну это возможно, хорошо.
Ну окей.
Нет, ну окей.
Ну окей, ладно, не важно.
Ну я так в любом случае как пример привел.
Знаете, там как бы теоретически
поймать где угодно может кто угодно.
В конце концов, да.
К сожалению, в худшем случае у меня
еще может быть плохое самочувствие, к сожалению.
Ну ладно, эту проблему мы, я думаю,
решим как раз. Ладно, так вот.
Итак, ну вот.
Ну, соответственно, пока я просто так...
Ладно, мы чуть позже подробнее поговорим о том,
как делать тут технологию отложенных операций.
Вот. Всякую.
Пока же я просто
сосредоточимся на том, как делать
сплит и мерж.
Вот. Я почему вообще...
Да, ну начнем мы с B-дерева.
Потому что технология в B-дереве,
сплита и мержа, мне кажется, вот такая максимально
будет более наглядна, чем если бы мы ее обсуждали
скажем в ВВЛ или там,
о боже, в красночерном дереве, хотя конечно
этим мы сегодня тоже займемся обязательно.
Итак.
Итак, как же
сделать
мерж
в B-дереве?
Да, начнем мы именно с мержа.
Вот как сделать
мерж
в Дереве?
Ну вот сколько
корней объединить нельзя, потому что между этими
корнями что-то
должно, напоминаю, быть.
И это что-то должно быть адекватной глубины.
Ну вот, кстати, давайте вот с этого и начнем.
Да, начнем с того, что когда мы
слева объединяем два дерева,
в B-дереве принципиально вопрос
одинаковые ли они вообще глубины?
Или нет?
Или нет?
Так вот. Ну давайте пока
для простоты предположим, что да.
Вот жили-были два дерева,
тут у нас корень
и тут корень.
И как же их объединить?
У них одна такая глубина или?
Вот допустим, у них абсолютно одинаковая глубина H.
Ну если у них
сумма
этих ключей
в корнях сильно большая,
то мы новый корень
съедем.
А как?
Нет, погодите.
Для начала, вот допустим, у них по T-1
ключиков.
Тогда все нормально.
Если у обоих хотя бы T-1,
то мы просто создаем новый корень,
которому их подвешено.
Замечательно, а ключик в этом корне кто?
Если по T-1, то мы просто смерзим их.
Возьмем список.
Ага, замечательно, смерзим только
между вот этими ребенками.
Тут получается какие-то два ребенка.
Что с ними делать?
Э-э-э...
Да, ну вот
а точно получится смерзать
той же высоты?
Черт!
А в чем проблема зацепиться?
А тут двух.
Потому что просто их схлопнуть
удастся только если тут T-1, тут T-0
или там плюс-минус один еще.
А если тут 2T-1
и тут 2T-1, то вы их просто так и схлопните.
А мы хотим залог смерзать, да?
Ну конечно.
в идеале нет ну скажет нас как я сказал мы включили олимпиадник и забили на
эти скачивания все так что
одну но на самом деле да только мы даже не одну вершину на самом деле тут вот
под таким техническим причинам обычно мерш не раз не рассматривается понятия
слить два дерева просто два дерева рассматривается понятие слить два
дерева и один ключик между ними да вот но сейчас собственно вот вот но вот нет
это оказываю в этих терминах оказывается сильно удобно думать сейчас
увидите но да то есть на самом деле да то есть да ну в том плане свести мерш
без ключика к мержу с ключиком в общем-то легко но правда поможет для того что когда
вы отсюда его удалите как бы тут высота могла и уменьшится соответственно вот ну вот а вот вот
вот это оно что пока пока нам хотел чтобы глубина одинаковая но мы пока сказали что
примерно одно и то же поэтому значит давайте и так сливаем через элемент то есть у нас
есть два дерева и элемент между ними случай номер раз высоты деревьев оказались равны как
тогда слить ну идея тогда объединяем эти вершины в одну через вот этот ключик теперь теперь все
в порядке кроме того что количество ключиков может быть здесь больше чем 2 т-1 то тогда
значит распиливаем на два не обязательно в этом месте обратите внимание да но потому что не факт
потому что могло быть так что здесь 2 т-1 ключиков а тут 3 чтобы ну как бы потому что
когда вы сейчас лили у вас тут как бы количество детей равно количество ключиков плюс один это вас
до февра до первую очередь нужен дашь обнимешь под деревья рекурсивно как-то
нет рекурсивно но не получится там рекурсивно но в смысле у тебя тут допустим вот так вот и
тут вот вот и будет у тебя там это шесть шесть ключиков и восемь детей как это сейчас мы
даже ничего не разделяем мы говорим объединим эти сперва сольем в одну вершину теперь говорим
если количество ключиков здесь оказалось больше чем 2 т-1 то то тогда мы там берем этот ключик
посередине я просто подчеркиваю еще раз что он не обязан совпадать с вот этим ключиком
и возвышаем его до нового коке все но я могу заменить слово ключ конечно но я но я под
ключом имею ввиду вот этот там символ строке ну или там число в массиве и так далее да ну я
уже перестал это подразумевать хорошо элемент все но не во мне лучше давайте или меня лучше
элемент давайте хотя конечно да то что мы сейчас говорим конечно можно делать и когда мы мерзим
появному ключу тогда надо гарантировать что вот этот явный ключ больше всех вот этих и меньше
всех вот этих да тут важная оговорка да потому что потому что пока эти вершины были корнями
у них вполне могло быть меньше чем t-1 ключиков ну с элементов поэтому как бы но поэтому надо
их объединить понять что их больше два либо понять что их не больше чем 2 т-1 и нас все в порядке
либо понять что их больше и распилить уже в том месте в котором надо вот ну понятно что такое
место найдется потому что количество элементов не более чем там 2 т-1 умножить на 2 плюс 1 там
соответственно но соответственно вот так что вот такая красота вот так что там еще надо
ну вот вот но сейчас погодите на но сейчас дойдем но в первую очередь важно конечно что важный
тот момент что мы вот это слияние сделали даже не за от логарифма но по сути за от единицы ну если
конечно считать т константой то есть обратите внимание слияние деревьев с одинаковой высотой
делается вообще за от единицы понимаете да идем да но вот значит но вот теперь значит повысим
планочку будьте здоровы а теперь предположим что у нас допустим ну без ограничения естественной
общности там правое под дерево оказалось сильно ниже то есть тут аш-1 а тут прям вот аш-2 и
между ними все еще элемент который между нужно между ними втиснуть что же делать в этом случае
да совершенно верно то есть мы тупо идем соответственно здесь по правому пути там
идем идем идем идем и доходим до под дерево высоты вот как раз той самой аж 2
но не совсем но нет почему нет в церкви мы как бы шли просто до конца и впихивали вершину
да ну можно и так сказать конечно да ну да да что какая-то схожесть действительно есть почему бы
не да можно но здесь смотрите но здесь вот но здесь заметим что мы будем спускаться только до так
чтобы там высота под дерево была аж два потому что в этом месте все что вам останется казалось
бы это что сделать это вот объединить вот эти два под дерево да но остается ваша оговорка что
могло так случиться что в объединении больше чем 2 и минус один вершин тогда мы достаем вершину
и то есть распиливаем ее на два и соответственно заносим сюда чем более того процесс это получается
такое каскадное распиливание потому что здесь тоже может казаться теперь 2 ты вершин и так вот
да ну да практически до что-то очень похоже получилось вот понимаете да мы спускаемся до
высоты аж два да причем обратите на этот раз причем это железно придется сделать потому
что никакие гарантии того что тут там скажем меньше чем 2 т-1 вершин нас уже не спасут потому
что мы тут подмежить можем уже называется очень жирный корень поэтому на этот раз обратно идти
придется вот ну например да просто стека идишников храни мы не паримся но у нас был
интеллектуальный вариант который заключается в том чтобы у каждой вершины у всех ее детей
одинаковая глубина помните да это нет ну это мы пока там вы изучите еще изучаем б-дерево
да но когда мы вот здесь смёрзли тут у всех детей одинаковая глубина мы ровно ради этого вот
сюда и шли вообще а что мы там а что мы там могли делать там во всех операциях как бы глубины
всех под деревьев сохраняются можно аккуратно проследить и убедиться в этом ну да не но там
по сути просто ну а за счет чего смотрите вот жила была вершина да и было были у нее дети
одинаковые глубины и взяли мы это и распилили мы эту вершину вот так вот надвое и вот эту вершинку
отправили там куда-то наверх вот там ставят ставили и тут вместо одного ребенка стало два но
это но этого ребенка но этих двух ребенков глубина оказалось абсолютно такой же как была
у того одного ребенка поэтому ничего не поменялось ну и при обратной операции тоже мы при всех
поворот но поворот это просто как бы мы перетянули этого ребенка с этим ключом сюда но как бы
глубины от этого не поменялись уровень не поменялся так что ничего не поменялся
ну потому что она может компенсироваться 2 t-1 ключом здесь
гениально гениально да да да действительно да на самом деле да как делать сприт чтобы не да как
делать сприт с логарифом плюс два скачиваний да то есть заметим что проблемы у нас с прокидыванием
вверх могут возникнуть только здесь поэтому если мы гарантируем что мы тут идем идем сверху и
гарантируем что тут везде меньше чем 2 t-1 вершин да то заметим что только вот при вот
этом объединении там может быть мы там подымем этот ключик но тем не менее здесь все объединим
и возрадуемся и на этом остановимся потому что дальше все в порядке да да да классно отлично
да все давайте пойдем реализуем базу данных с реверсом на подотреске но пожалуй пожалуй но
да нет ну просто в дереве придется глобально хранить глубину но в принципе там при всех
инсертов и рейзах в общем-то глубину дерева главный заметим что в явном виде кстати
глубину вершины вам хранить не надо ну смысле чтобы там у вас самой вершине было написано
да там как они глубин то есть глубина я под дерево то есть вы просто там рядом с корнем то есть вы
храните там корень в каком-то миде если вы там рядом с корнем храните глубину то в общем-то дальше
проблем ну да но просто скачивать тратить на это память там вот эту скачку все кому это надо
ну если мы олимпиагики нам по барабану если мы не олимпиагики туда так давай сейчас
начать но лайфхак следующий там у нас опять возникала идея чтобы вот когда идем наверх вот
это не делали это каскадное проталкивать не приходилось для этого перескачивать эти вершины
заново если мы все-таки все-таки выключили режим олимпиагика опять так вот идея оказалась
давайте когда мы идем сюда мы как и ранее в инсорте добиваемся того что когда мы находимся
в вершине мы знаем что в ней меньше чем 2t-1 ключ но делаем абсолютно так же как раньше тогда
это приводит нас к следующему что если мы нам нужно сделать объединение вот здесь да и протолкнуть
ключик вверх то мы как бы его проталкиваем объединяем его вот с этой вершиной но дальше
это не идет потому что тут было меньше чем 2t-1 вершин значит тут стало все в порядке
потому что мы я же говорю мы сверху когда шли мы этого добивались вот против мы в инсорте умели
идти сверху вниз и добиваться единственная маленькая оговорка что вам как бы если вы там
поддерживаете сзшки вы поддерживаете сзшки да то как бы вам придется их тут пересчитывать но
в общем-то зная размер собственно вот этого дерева вы в общем-то там заранее все это предпочитать
а тут-то неважно смотрите если у вас тут меньше чем главное 2t-1 да согласен но и да но да но
конкретно здесь мы сделаем аккуратно хорошо то есть мы говорим что здесь главное 2t-1 а вот с
этим ребенком делаем меньше здесь мы ничего специально не заморачиваемся типа 2t-1 2t-1 объединяем
если надо заносим эту вершину то есть даже отдельного случая на эту тему не рассматриваем
да да то есть мы как бы главное то есть мы по сути досюда просто доходим они прям
досюда то есть не поберем право ребенка и так далее то есть по моему ну кстати да тут даже
лишних скачек кстати по сути не будет на самом деле то есть мы прям то есть количество скачек
равда как и кстати асимптотика будет в точности аш-1 минус аш-2 плюс ну ладно плюс два но почему
плюс два потому что смотрите потому что как бы вот на этой глубине все-таки вот этот коринг нам
все-таки придется скачать но да конечно и глубина и ссшки да да да да да да да да да да да да да да да
вот так же такая красота у нас получилось такая вот красота и ну вот но да но асимпточка но здесь
на самом деле это асимпточка вот приятная видите что мы работаем не за от прям логарифма а за от
именно разности усут то есть если разности там не сильно различаются то и работает это там не
очень медленно то есть там если высоты отличаются на 10 то как бы это все будет работать за от 10 вот
ну как бы понятно в худшем случае конечно это будет работать за от логарифма вот но
здесь я все-таки подчеркиваю что это работает именно за от единицы плюс вот разность высот почему
потому что нам сейчас это ой как пригодится как там это пригодится да сейчас там это пригодится
в сплите да неожиданно но мы сейчас будем делать сплит с помощью мержат когда у нас такой был
никогда но если писать дикарточку но не просто подвешивая под корень или левая
потерева а делаем мёж с левым потерем ну дикарточка господи о господи дикарточка
кто изобрел да как это называется да как как всегда да заводить там и потом опять индийская
версия кто хочет стать миллионером кто да кто изобрел дикартово дерево пишем рене декат там
я не знаю исак ньютон там сисилия рогон ой ну или там или там баба базидель как
подлянка заключается в том что тут два правильных ответа но хотя тут надо копнуть там на самом деле
не самый тривиальный вопрос в этом плане да а ну да вот да посмотрели они на это почесались и
поэтому заменили вопрос на кто изобрел револьвер да там сэмюэль кольц там что-то там что-то там и
кто изобрел револьвер да как это да как легко не его как вы сейчас револьвер изобрел сэмюэль
кольц кто изобрел кольт остается загадкой да ну по крайней мере по этому фильму там википедии
это наверно знает а рогон а рогон сисилия вот нет не надо ну ну вы знаете там по моему
и через они там как бы знаете не эти все существа не о том чтобы изобретать дикартовые деревья да как
это называется да и собрали сейфы и пошли там наносить котевки власти это собрал за их добрый
волшебник да что называется даггер да где-то за стенкой двое ученых изобретали дикартовый
дерево да нет почему не не и вставил между ними гипофиз а твой так это уже булгаков пошел да
вот так вот и так сплит давай ну нет по факту нет вот мы сейчас для удобства считаем что мерж
это вот у нас то есть нам даны два дерева и ключиками и вот элемент между ними конечно же если вам
нужно сделать мерш двух деревьев без ключика то да вы там достаёте просто оттуда аккуратненько
ключик и сморчу эти но правда это уже происходит не за от вот там разности высота реально залазали
тут уже без вариантов вот но и просто именно в таком виде это нам пригодится потому что давайте
попробуем теперь сплит сделать в таком виде то есть вот не в таком а вот в таком то есть сплит
от строчки длины n и к это значит бой говорит что мы хотим получить массивчик длины к-1 собственно
вот этот вот к-т элемент и массивчик n-к с сохранением порядка естественно вот такая у нас
мистическая цель вот причем более того да нам может повезти нам везет нам сильно очень повезет
если этот элемент находится в корне потому что если этот этот мистический элемент с давайте
его цена звать если он находится в корне вот так и бороду еще рисуем да так то жила было ц
но вот нет тут как генту линукс да вы можете сделать все и вы будете делать все пока вы
все не сделаете как бы ничего работать не будет поэтому все-таки придется довести то есть
конечно идейно понятно что делать да безусловно то есть давайте мы тогда распиливаем эту вершину
на так сказать две вершины вот с этими ключами этими детьми и этими ключами этими детьми между
ними остался вот этот элемент ну вот собственно вот ответы состоялся но просто к тому что это
распиливание корни то есть это мистическую операцию распиливание корня делать придется еще
кстати мистическая подлянка будет еще заключаться в том что вам придется тут еще сзшку пересчитать
используя так что возможно вам придется в вершине чтобы лишних скачек не делать еще хранить сзшки
всех детей напоминаю в корне в корне может быть меньше чем t-1 ключика
напоминаю нет тут экзотический случай тут другой экзотический случай тут бывает если
это вершинка с краю вот нет говорим что ну вы говорите что вот вот у вас тут есть порядок да
вы тут можете типа аналог инордор отхода запустить так вот я хочу чтобы эта вершина в этом инордор
отхода была катой ну да но но проговорить стоит потому что как бы скажем так тут может наступить
разрыв шаблона называется или как говорит или перефразирует там или как это перефразирует
классик тот может немножко кокнуть вот но да уже знаете да вот вот это я вот на это хочу
обратить внимание нигде не прописано что эти массивы обязаны быть одинаковой глубины в общем-то
на уровне интерфейса никто даже не то есть на уровне интерфейса вы вообще не знаете что такой
глубина потому что на уровне интерфейса у вас есть мистическая структура данных там которая может
так и называется там я не знаю там clever строка там я не знаю но вот или там умный стринг там я
не знаю шо шо в общем но или там переставляйте джонглируйте словами как хотите я не знаю то
есть clever строка и у нее есть интерфейс она умеет делать сприт умеет делать мерш умеет найти
там как элемент ну и так далее и тому подобное на уровне интерфейса вы вообще кстати это да это
важно кстати когда вы будете там когда вас будете готовить код код ревью у вас как бы и код должен
удовлетворять таким требованиям кстати да да будет вот тем более знаете вот так как вы да с точки
зрениях тех самых олимпиад кстати за которые вас тоже теперь зачет будет да ну то есть ладно там
честно скажу пока конечно мало вероятны что мы там будем проводить код ревью хотя конечно мы еще
подумаем а что такое у вас того в киша его ввели уже много лет назад
да я получил минус балл за употребление инициативных слов во время занятия
да как бы все-таки не нужно управлять все-таки это как бы это по всем причинам вода тут а занятия
тут девушки и на камеру соответственно да я не знаю какая из этих причин важнее мне кажется
каждый из них достаточно чтобы заработать пожизненный срок воскопа не тот шаблон вот так вот
так вот значит соответственно но вот но это не но так конечно нет реально в олимпиадах конечно
дамы там в ровно по этим причинам придираться не будет но хотя в некоторых случаях что в сложных
задачах на самом деле как бы имена называется гадость кодить скажем так обычно лучше не надо
то есть лучше писать как бы красивый упрошенный код вот с черными ящичками где как бы вне дикартовы
дерева вы не думаете о том как устроено дикартовы дерева а внутри дикартовы дерева вы не думаете
о том как его использовать но это сложных задача как бы лучше писать так просто вы просто уменьшаете
вероятность ошибки бывает но по-разному вы знаете но тут нет но это конечно да но просто тут
еще компенсируется тем что да там конечно крайне редко вам дадут еще там сложную задачу в которой
нужно будет реализацию умирать обеими ногами но то есть обычно задачи на реализацию она в первую
очередь задачи на реализацию то есть знаете там ну классическая такой задачи вот я не знаю
есть вот моих любимых задач в этом направлении знаете какая смотрите данку в пространстве нет
трехмерным трехмерным все нормально не дам да ну что угодно там можно и пролепить а может хоть
пролепить может доход много граней господи только не только небольшого количества граней там по
мобу там можете считать что 10 20 максимум 50 и есть лампочка вне многогранника найдите
освещенную площадь поверхности этого многогранника это же как нектое константа умножить ну да нет
это задача это задача где-то нашел по моему где-то там по моему в каких-то контестах 2007 года
но там в той задачи реально кубик был если что так что не прием но повернутый там естественно а
может ну или выпукло но это не важно ну ладно очень детально просто суть в том что нет понятно
что это идейно понятно но как бы суть том что как бы это надо вот реально аккуратно кодить
то есть аккуратно кодить и потратить на это явно не 20 и не 30 скорее всего не 40 минут вот
нет но при грамотной тренировке конечно вашего кодера может вы конечно и начал
а я спорно там еще по моему там было а возможно было два кубов о да я сказал там было два куба по
моему да нет но они не пересекаются но конечно отбрасывать тень могут там возможно даже задача
была там найдите площадь тени даже то есть нет там как бы понятно что это идейно все понятно но
как бы вам придется писать там действительно проекцию там это у многограничия там это это кубика
на кубик там еще их там может освещение точка которые вне всего да но я привожу задачи не
в пример того как что сложные математические задачи я привожу в пример задачи в которой как
бы это сложно сделать именно практически то есть вам все это придется написать
в 3d 3d спрессы вот это просто фишка то что вам надо просто да так вам просто все это надо
написать и как бы нигде не набар и главное грамотно использует то есть это вот хороший пример что
там вот действительно вот тут как раз вот подход что вот разбить все на маленькие функции
каждый решает свою локальную задачу соседа не вмешивается это вот прям то есть тот подход
который здесь вот становится прям вот максимально очевидно почему писать надо именно так вот так
что тут вот когда вот то есть это понятно что там то есть это из разряда прошел геометрия
вообще большая часть геометрии из разряда понятно что пока вы не сядете это писать то он
вот потом выяснится да то есть там два варианта да либо надо было тренироваться это реально
писать либо на самом деле изучать как это писать правильнее потому что может быть просто другой
алгоритм за ту же асимптотику, но пишет в десять раз проще, вот, так что тут, конечно, такое.
Вот, так, что у нас дальше? Вот, так вот, значит, это был, значит, смотрите, экзотический случай,
значит, еще раз вернемся, что если у нас ключик, у нас есть крайний, но, как мы уже сказали,
здесь нам никто не сказал, что вот эти деревья обязаны быть в одинаковой глубины, более того,
если тут, скажем, элементов сильно меньше, чем здесь, прям, значительно меньше, то, как бы,
глубины заведомо будут различаться, очевидно, если мы говорим, конечно, обе деревья, да, и,
в общем-то, о любом. То есть, ну, если тут три элемента, а тут три миллиона, три, то уж,
наверное, глубина будет различаться, правда? Там, в любом более-менее адекватном дереве.
Да и неадекватном тоже. А, мы если не храним, то, но вот придется хранить. Другой вопрос,
что хранить ее можно не в каждой вершине, а только вот у вас есть, вот у вас есть структура данных
B дерева. И храните вы два параметра. Первый – это указать вот этот ID шник корня,
второй – глубина. Этого вам хватит. То есть, там, аккуратно это поддержать, вам удастся без труда.
Вот. Так вот. Ну вот, со сплетами мержами разобрались. Если элемент, выпиливаем элемент,
находится в корне. А что делать? А что делать? Если выпиливали элемент, выпиливали вы,
либо вылипали. Короче, вот этот вот элемент посередине, он окажется не в корне.
Че ты в сисюке плакать хочешь уже? Не знаю. Как-то твоим образом, как-то не сильно,
честно говоря, там метчится. Если на каждую проблему плакать,
знаешь, это как бы называется, проблема не решится от этого. Не, ну как сказать,
если ты, конечно, вы не младший из сестер, которая прилетела обратно на остров,
а там от чудовища уже от расстройства умерла, тогда там слезы внезапно помогают. Да, ну вот.
Да, господи. Зачем плакать, господи, сессия еще далеко, в конце концов. Да и то, в общем-то.
Мы амортизируем, а плакаем. Мы сразу переходим к результату. А, плакать, ну да.
Мы решили предупредить другой беда. Ну я предпочитаю, ну как раз. Ну да-да-да,
ну правда. А, ну тогда это когда мы плачем, мы говорим это, забиваем гвозди в голову,
получается, да. Ну окей, хорошо. Хотя это хорошо, когда я говорю плакать, я подразумеваю
забить гвозди в голову, да. Как говорится, да. Не, хорошо, так кому-то можно, да, хорошо это будет
звучать, да. Как говорится, да, но если ты еще раз так сделаешь, тебе придется поплакать,
я прослежу. То есть так это будет звучать как-то, да. Ну ладно. Так вот, значит, смотрите,
предположим, что вы решили удалить, решили делать сплиты, но неожиданно выяснилось, что вот этот
с-это элемент, то есть вот этот элемент с, который катый, он находится где-то вот в этом поддереве.
Тогда, значит, мы делаем весьма неожиданный финт ушами. Ну если оно потом будет адекватной высоты.
Сейчас давайте вот аккуратно. Значит, делать будем так. Мы отсплитим аж два поддерева, то что слева и
то, что справа. И останутся еще, собственно, у нас вот эти два ключика. И теперь, а дальше мы,
ну типа рекурсивно, на самом деле нет, будем сплитить теперь вот эти деревья, вот это дерево.
Ну что будет получаться дальше, давайте. Тут я даже немножко разверну рекурсию. Так,
вот давайте сразу рассмотрим случай, если у нас как бы нам захочется отправиться в край. Но ничего
страшного не будет. Значит, мы просто будем спитить, значит, у нас просто справа тут дерева не будет,
а слева будет. Ну, значит, да, будем с этим чуть позже разбираться. Ну, слева, естественно,
все симметрично. Да, то есть вот тут у нас, в этом дереве у нас. Давайте, ну я давайте еще
вот этот случай рассмотрю, когда мы там идем куда-нибудь вот сюда, но здесь тоже все понятно.
Чего? Абсолютно то же самое. Просто у нас одного из этих вот деревьев, которые у нас тут возникали,
здесь просто нет. А из того, что вот если у нас справа ничего нет, ну значит справа ничего не
будет. А из того, что слева, значит, мы создаем вот это вот дерево, только без вот этого элементика.
Вот, то есть вот здесь так, если тут вот опять мы оказались где-то в середине и тут надо идти
куда-нибудь сюда, ну значит снова пилим вот так вот, вот так вот, радуемся. Хорошо. Чего еще?
Чего? А, ну могло быть такое, хорошо. Нет, ну почему нет, какая разница? Ну, ничего страшного,
да, ну хорошо, да, если тут ключиков нету, то значит, ну мало или там t равно 2 еще бывает. Да,
так что, ну да, могло быть такое, хорошо. Значит, к чему нас это приводит? Ну, наконец, в какой-то
момент мы наконец доходим до ситуации, когда у нас наш ключик наконец нашелся, но у этой вершинки
может быть борода, а может и не быть, там как повезет. Но здесь соответственно тоже уже делаем
финальный распил, по крайней мере финальный для спуска вниз. И вот теперь начинается достаточно
интересная вещь, потому что обратите внимание, то есть у нас теперь, да, то есть да, нас попросили
разбить дерево на два дерева, один ключик. Мы перевыполнили план. Вот, у нас много, у нас теперь,
да, у нас теперь много деревьев, вот так вот. Вот.
Ну вот, да, ну вот действительно интересно, что произошло следующее, что когда, то есть как бы у нас
есть вот наш супер наш ключик c, то что слева, то есть заметим, то высоты у нас аккуратненько убывают.
Ну ладно, да, нет, разница может быть какая угодно, потому что мы тут справа могли сколько
угодно идти в левое поддерево. Да, мы каждый раз получали два, в смысле, у нас разница между
соседними будет, кажется, максимум единицу, потому что мы когда сплитили дерево, скажем, вершины h,
мы получали дерево вершина h и дерево вершина h минус 1. Ну не факт, если мы рассматриваем вот эту
последствия деревьев, которые оставались слева, тут разница может быть какая угодно. Ну какая
угодно. Нет, слушай, ну в смысле вполне возможно, когда мы отпилили это дерево, потом значит у нас тут
образовалось поддерево и мы идем влево, влево, влево, влево и слева ничего не остается все время,
то есть поэтому каждое следующее может быть какое угодно. То есть естественно, если мы померзим,
отсортируем по высоте не только эти поддеревья, но и то, что оказалось справа, то да, скорее всего да.
А, точно, мы же не хотим их местами менять. Вот, да, это важно. Вот, то есть вот тут какая-то такая
красота. Вот, ну ладно, еще мелкая оговорка, что кажется, из того, что мы, кажется, обсудили раньше,
следует, что, кстати, вот эти первые два дерева вполне могут быть и одинаковой глубины, кстати.
Чего? Ну вот, но в целом для нас важно, что они хотя бы не убывают.
А, не убывают? Пардон, ну ладно, не возрастают. А это не важно. Ну, они даже не просто не возрастают,
но важно так, что они все-таки строго убывают, ну кроме вот этого последнего. Потому что после
создания, ну смотрите, тут-то, хотя тоже, ну вот, нет, ну как вам сказать, смотрите, вот предположим,
что вот жила была вершина, и вы тут перешли в поддерево высоты аж. Вот это вот то, что
отпилено слева, какой высоты? Оно может быть аж плюс один, если вот тут слева были какие-то
ключи, да, или если это оказалось вторым в списке, да, то есть если это первый ключик, а это дерево
второе, то тут оказалось дерево тоже аж, то есть могло быть аж, могло быть аж плюс один. Ну,
ну можно и так сказать. Да, но заметим, ну ладно, для нас, в самом деле, будет важно следующее,
что каждое следующее дерево, оно не соответственно, не больше предыдущего. Понимаете, да? По глубине,
конечно. Ну, мы, а мы их сюда выписываем. Ну, было вот такое дерево. Вот, стало вот такое.
Вот такое дерево. Ну, если вот это, значит, стало вот такое дерево, такой ключик, вот такое дерево,
в котором мы еще пошли курсивно. Вот такой ключик и еще вот такое дерево. Ну, в данном случае так.
Вот такая вот идея. Да, то есть высоты здесь, конечно, могут быть такими относительно,
там, то есть каждое следующее дерево имеет высоту не больше предыдущего. Вот, понятен принцип, да?
Ну, теперь возникает такая идея. Ну, основная идея теперь заключается в том,
чтобы на самом деле просто пробежаться теперь в возрастающем порядке, их аккуратно теперь смершить.
То есть, так как мы смерживать будем через заданный элемент, обратите внимание,
то получается, каждый веж будет работать не за логарифом, а за разность высот и,
получается, суммарно получится адекватный логариф. Ну, а это, ну, это не особо принципиально,
потому что одинаковые высоты мы всегда, одинаковые мы сливаем за от единицы. Ну, да, но там, смотрите, как это можно делать.
Можно делать аккуратно, можно говорить, что если у вас образовалось два дерева одинаковой высоты,
да? Ну, допустим, да? Так, что, где? Вот.
Нет, просто говорим, что у нас мерч за разность высот плюс один, и плюс один выносится в количество, которое логарифом.
Ну, типа того, да.
Дмитрий, вы уже сказали, что делать вот, например, мы хотим, на порез, допустим, корень, мы удаляем, что у нас, если размер станет слишком маленьким.
Сейчас какой размер? У корня размер может быть маленьким.
У корня, но потом же внизу даже сам.
Так, а это не важно, когда вы тут сплитите вот эти вот вершинки, они же корнями становятся, то есть, как бы, то есть,
когда вы тут вот эту вершину распиливаете, она, по сути, уже корень, потому что то, что сверху, уже распалось.
Поэтому то, что там малый вершин, нам плевать. Да, вот в каждом из этих орней, может быть, малый вершин, все нормально.
То есть, это мы потом в мерже будем потом об этом думать.
Чего? Ну, может получиться, ну, нет, ну, может получиться, ну, вообще можно подумать, смотрите, нет, смотрите, на самом деле все гораздо проще.
То есть, на самом деле, то есть, как сделать вот тут классический алгоритм, да, вот, то есть, как бы нам теперь аккуратненько избавить, мы знаем, что у нас все высоты не убывают, да.
Знаем такое? А еще мы знаем, что когда вы сливаете два дерева одинаковой высоты h, то получится дерево либо высоты h, либо дерево высоты h плюс один. Согласны?
У каждого дерева мы в явном виде храним высоту.
Мы не храним высоты в вершинах, только в дереве.
Ну, для каждого глобального дерева храним высоту, мы ее там можем поддерживать. Вот так. Ну, можете, если вы включите совсем олимпиадник, можете в каждой вершине высоту поддерживать.
Но по факту просто этого не нужно. Так вот, так вот, поэтому, значит, как теперь аккуратненько слить, значит, это все?
Ну, во-первых, давайте сведем задачу к ситуации, когда у нас все высоты строго убывают.
Чего?
Ну, в смысле, ну как сказать, вот ситуация была такая, вот могло возникнуть так, что вы вот отпилили дерево h и пошли рекурсивно в дерево h, да?
Так вот, а в этом дереве h могло оказаться много-много-много ключиков, и вы тут где-то посредине пошли. И тогда вот у этого дерева вполне себе высота будет h.
Мы отпилили h, у этого h.
Да, потому что вот с этими ключами, да.
То есть, да, то есть, видимо, три подряд таких ситуаций, видимо, уже не будет, у следующего дерева уже точно будет глубина h-1.
Ну, можно даже, смотрите, можно даже аккуратнее сказать.
То есть, мы пробираемся по числам типа h, h-1, h-2 и так далее, h- там, допустим, какой-нибудь z, да, ну, мы там до z-а какого-то проходим, да.
И, значит, на каждой из этих итерации мы сплитим дерево вот такой высоты.
То есть из каждого из них может получиться, тут может получиться от h-1 до h, тут может получиться от h-2 до h-1, тут может получиться от h-3 до h-2, ну и так далее.
А может и не получится, да. Но если получится, то hier высоты такие.
То есть, как бы, да, поэтому, видите, тут как бы, да, совпасть случайно два идущих подряд могут, здесь и идущих подряд вышли уже не могут.
Так что вот такая красота получается.
Вот, так вот они эти элементы, мы их тоже как бы в список пишем.
Нет, нет, у нас не совсем, у нас как бы слева получилось дерево элемент и справа дерево элемент.
То есть по сути у нас было так, вот у нас есть этот будущий цетто элемент, у нас сначала
образовались вот эти два дерева этот элемент, потом там вот эти два, ну и так далее. То есть как бы
слева это идет и справа. Вот, поэтому одинаковые могут быть, но только желательно сделать так,
чтобы высоты были строго убывающие. Ну, давайте поймем, предположим, что нам повезло и высоты
строго убывающие. Тогда идея простая, тогда давайте просто мержить вот эти два, результат с вот этим,
результат с вот этим. И тогда заметим, что когда мы сливаем вот это дерево, скажем, с каким-то
деревом, которое по высоте не больше чем это, то результат получится не более чем вот это плюс
один, то есть не более чем вот это, правда? Понимаете, да? Нет, поэтому получается, если они по парно
различной высоты убывающие, то как бы слияние получается, что у нас никакое, просто я для чего это
делаю? Для того, чтобы у нас по высоте тут тот, кто справа не обгонял то, что слева. Для чего это
делается? Это делается для того, чтобы мы гарантировали, что слияние вот тут двух соседних происходит
от разности высот этих деревьев. Понимаете, да? Но плюс один, понятно. Но просто если тут будет у вас
в сумме помимо единичек, когда будет логарифм, будет это минус это, плюс это минус это, плюс это
минус это, то как бы разности телескопически сократятся и останется только там вот эта высота
минус вот эта высота. То есть таким образом получается, то есть конкретно вот эти деревья,
если они по парно различных высот, то мы их аккуратненько, то есть по парно различных,
точнее строго убывающих высот, то мы их аккуратненько залогарифм и смёрзли обратно. Вот, понятно, да?
Но что делать, если у нас бывают всё-таки одинаковые высоты? Тогда у нас начинает быть обгон,
правда? То есть тогда возникает действительно такая мелкая проблема, что там может так
случиться, что здесь высота какая-нибудь там h, а тут стало h плюс один в результате, правда?
Причем, более того, если за этим не следить, то как бы по крайней мере теоретически, там может
быть h плюс 2, h плюс 3 и так далее, то есть там уповать на то, что обгон будет всегда не более,
чем на константу, поэтому это нам по барабану, тут нельзя. Обгон может оказаться и намного. И как
бы там долог квадрата не дошло. Сначала равные, потом выяснилось, что тут h,
тут h плюс один, мы их слили, получили h плюс два, потом там дальше обгон пошёл, ну и так далее.
Ну, возможно, математически можно там додумать и аккуратно показать, что такого не случится,
но более надёжно тогда сделать так, на самом деле. Смотрите, просто сначала идём справа налево и
добавляем все эти деревья, так сказать, в стек. При этом следим, что в стеке попарно различные все
элементы. Ну, если обнаружилось, что новый элемент равен предыдущему, значит мы их сливаем,
то есть достаем тот предыдущий стека, сливаем и пытаемся добавить в стек. Если выяснилось,
что там оказалось тоже равный элемент, потому что этот типа больше, то сливаем его и так далее.
Чего? Ну, не совсем. Ну, тут скорее как в стеке, потому что фибоначевые-то мы в явном виде для каждого
размера хранили, а тут мы, к сожалению, у нас порядок принципиальный. Фибоначевые куча в
каком порядке мы сливали деревья, нам по барабану было. Ну, так и мы там могли поменять местами,
а тут вот мы их менять местами не можем. Но как бы это неважно, потому что мы же аккуратно
всё равно следим за тем, что у нас никто никого не обгоняет никогда. Вот, и в результате получится,
что в стеке у нас лежат деревья теперь строго убывающие и задать условия предыдущие.
Получается очень удобно. Вот. В такой версии никаких потенциалов нет. Ну, не знаю.
Нет, ну когда сливаем, то да, но просто как бы если... Просто там проблема в том,
что телескопической суммы нет, потому что если обгон справа, то как бы у вас теперь слияние
происходит не за левое минус правое, а за правое минус левое. Ну, не важно. Вот. Хорошо.
Не обязательно. Нет, мы используем, во-первых, последний, только последний элемент и то,
что у нас есть. Если они оказались одинаковых высот, мы достаем этот элемент из стека,
сливаем и теперь нам снова нужен последний элемент из стека, но который был перед этим.
Нет, наш уже не может оказаться больше, потому что тот строго больше, чем то,
что мы достали. Нет, мы не могли получить, потому что мы доказали уже, что у нас массив все-таки
убывающий. Может быть не строго, но убывающий. То есть у нас не может так оказаться, что изначально
у нас там могут идти два идущих подряд элемента, но каждый следующий не может
оказаться больше предыдущего. Но на единичку больше, да. Но ровно для этого мы этот стек
и вводим. То есть мы аккуратно в стек добавляем эти элементы, причем если мы пытаемся добавить
одинаковый с предыдущим, то мы вместо этого их сливаем и пытаемся рекурсивно добавить результат
объединения. Возможно выяснится, что он равен предыдущим, и тогда мы еще раз объединяем,
ну и так далее и так далее. Так что таким образом, оказывается, что и сплит мы в итоге
сделали за логарифом. Это называется за логарифом. Так, ну а теперь тогда возникает... Так,
какой у нас вопрос возникает? Ну как зачем? Ну как минимум для того, чтобы делать деревья по
неявному ключу, а так же, чтобы делать там... Ну потому что теперь если вы... Так, ну давайте так.
Значит тогда я вам теперь сейчас могу... Ладно, давай задам вопрос пока. Что значит нормальное?
Ну потому что ты будешь добавлять, ты будешь добавлять элементы по очереди.
Ну это глубинаш не превосходит логарифма. Ну глубина оценивается логарифом. Да, по факту,
да, мы все эти мержи делаем за о от разности вот этих вот высот плюс... Чего? Не, ну почему? При
желании можем оценить, но дело в том, что когда мы вызывали сплит, мы заранее не знали,
какие у нас тут высоты будут. Более того, скорее всего, ну да, можно оценивать, конечно,
глубиной вершины С, конечно, где она нашлась, но так как мы заранее не знаем, где она находится,
она абсолютно где угодно может быть при одних и тех же ключах. Ну да, вероятность не так же
оценивается немножко. Ну да, хорошо, все что угодно может быть. Зачем мы все это делали?
Ну ладно, задам более простой вопрос, если вы не все писали дикартячку. Кто когда-нибудь в своей
жизни писал дерево отрезков? Так, так, проблема, да, так, хорошо. Кто писал когда-нибудь дерево
отрезков с прибавлением или присваиванием на отрезки? Так, кто-то уже не уверенно начинает
подавать. Нет, спящий, ну, спит он, спит, да. Ой, о боже. Вот, ну вот, так вот, начнется отречь,
да, все, спасибо, спасибо. Нет, просто попроси, наверное, просто как вы делаете присваивание
на отрезках. Но речь идет о технологии отложенных операций, правда? Вот, то есть это означает,
что вы пользуетесь тем, что вы идете сверху вниз, и у вас есть отложенная операция,
которая говорит, что если я хочу пойти в детей, то прежде чем туда пойти, я протолкну известную мне
отложенную операцию, правда? Если я туда не пойду, я не протолкну. Было такое, да? Ну, то есть,
на уровне идей, то есть, заметим, что если вы это делали в дереве отрезков, то вот, например,
вот в таком б-дереве вы также это можете делать. То есть, с помощью б-дерева вы прекрасно можете
делать те же самые присваивания и прибавления на подотрески, правда? Ну, чего? Почему? Ну,
те же. Ой, ну, те у нас все равно константа. Ну, и потом, да, это отдельный вопрос. Да,
пропихивание отложенных операций в базах данных, это хорошо, конечно.
Кажется, мы можем проталкивать только того сына, в который мы идем, а остальных не проталкиваем.
Того сына, да, того, ну вот. Не, ну, там... Ну, да, да, да. Не, ну, понятно, что... Поэтому я говорю,
в этом месте лучше уже легче включить или пианика, это да. Потому что вряд ли будут там сплит, мерч,
реверс на подотреске делать на базах данных, как-то знаете. Базы данных обычно не для этого пишутся,
ой, не для этого. Ну, бывает. Но просто нет. Если вот отослаться просто к этому, то, во-первых,
на б-дереве теперь это можно прекрасно делать, потому что тоже отложенные операции прекрасно
работают. Но чем это круче деревоотресков? Тем, что теперь все это прекрасно теперь объединяется
с операциями типа вставки, удаления, ну и просто сплита мерча. То есть, если вы там решили в середину
массива еще элемент вставить, то ничего страшного, собственно, никаких проблем. Но более того,
классическая фишка, которая тут появляется, это, конечно, знаменитая задача реверс на подотреске.
Как делать реверс на подотреске? Но, оказывается, замечаем, что реверс это такая же отложенная
операция. Потому что что нужно, чтобы развернуть б-дерево? Надо что делать? Как бы надо развернуть
массив ключей, развернуть массив детей и развернуть всех детей рекурсивно, правда? Поэтому получается,
что, в общем-то, это может быть та самая, то есть, получается, что это прекрасно реализуется как-то
самая отложенная операция. Вот. То есть, получается, что если у вас есть сплит и мерч, который
реализуется сверху, то, получается, у вас есть практически все, что имеет дикартовое дерево. Но,
в отличие от дикартового дерева, теперь у вас будет невероятный с полигарифом, а честный. Вот.
Так что? Ну, можем попробовать обсудить. Но это мы обсудим после перерыва. Итак,
так, ой, зачем я это убираю? Так, господа, вылезаем. Да, мы уже полностью научились делать сплит и мерч для
б-дерева. А теперь возникает такой вопрос. А не можем ли мы случайно, ведь, действительно,
б-дерево как-то сложное дерево с какой-то мегзоапокосной реализацией, а не можем ли мы сделать то же самое в овл-дереве?
А вот давайте подумаем. А вот давайте вот внимательно подумаем. Допустим, у вас есть овл-дерево.
Что такое овл-дерево? Это двоичное, помните, двоичное дерево поиска, где для любой вершины
гарантируется, что разность высот двух под деревья одной и той же вершины не превосходит
единицы в ту или иную сторону. Помните, да? Внезапно, да? А, или там что-то другое интересное, да?
Не, вы убирайте, давайте. Так, ну давайте, ну захлопните, ну, шутя такое. А то понимаете, в чем проблема.
Вы там смотрите, мне тоже становится интересно, и это задерживает лекцию, понимаете. Вот, вот, овл, да.
Итак, значит, итак, теперь внимание, вопрос. Ну, давайте попробуем. Как делать мегж в овл-дереве?
Вот такая загадка. Ну, давайте, чтобы это сделать, давайте скажем, что, да, сливать мы тоже будем через точку.
Ну, то есть тоже будет промежуточный элемент, с которым мы хотим все это слить. Вот, понятно, да?
Сливать. Ну, хорошо, объединять. Нет, нет, не важно. Вот, объединять. А мы можем ее достать, если ее нет?
Ну, как вся, если нет, то достанем и сведем задачу в предыдущий. Ну, просто, как вы догадывали,
сплит-то нам тоже мы будем через вот эту технологию делать. Вот, поэтому, то есть наша задача, как всегда,
если у нас есть два дерева одинаковой высоты и вершинка между ними, то заметим, что мы прекрасно
можем слить деревья за о от единицы, правда? Даже если они отличаются на плюс-минус один, мы все равно
можем провернуть вот такую приятную операцию, правда? И это прям будет работать за о от единицы.
Если они высот h1 и h2, что в этом случае сделать?
Давайте второе подвешивать куда-нибудь внутрь первого. То есть, по первому спускаем, ну, по большему спускаем.
Так, ну да, понятно, что по большему мы спускаемся вправо, и вот, допустим, натыкаемся на какую-то
вот высоту, типа, эта вот высота h2, но тут как повезет. То есть, может, мы наткнулись на дерево высоты h2, может, не наткнулись.
Мы наткнулись, видимо, либо на h2, либо на h2 плюс h1.
Безусловно.
Ну, просто если там подвесить, например, или нет?
Ну, вот. Нет, ну, на самом деле, эта идея оказывается очень простой. Вот, допустим, у нас возникло первое дерево высоты не более, чем h2, давайте для формальности скажем, да?
Тогда идея такая, вместо того, чтобы, значит, мы разрушаем вот это, да, вот так вот. А, давайте вот, у нас же есть цветные маркеры, да.
Так, ух ты, новый общий родитель, да.
Так, давай, а, значит, да, я же вот, да, вот смотрите, у нас же это мы удаляем, а вместо этого объявляем, то есть, правым ребенком вот это, и у них детей подвешиваем вот так.
Но два, две проблемы. Ну, конечно, вот для этой вершины придется пересчитывать там всякие суммы, ну, или шоу у вас там, но это полбеды.
Основная беда заключается в том, что глубина вот этого поддерева увеличилась.
Увеличилась.
Кстати, самое страшное, не обязательно на один, а даже могла увеличиться на два.
А, ну, да.
А, ну, это неважно, потому что, ну, ладно, смотрите, заметим, что было, нет, ровно h2 могло тупо не существовать.
Если обе вершины, нет, у вас два, а, ну, да, нет, я имею в виду, что, короче, если у вас было меньше, чем h2, то левый ребенок, он ровно h2, а у этой вершины будет 100 h2.
Да, то есть, действительно, если тут, да, то есть, если тут меньше h2, то тут заведомо, во-первых, было h2 плюс 1, а вот их конкретно здесь было.
У нас могло не быть h2, у каждой вершины с высотой h, хотя бы один ребенок, высоты h.
Да, но мы-то идем по строго заданному пути, а не по рандомному.
Напоминаю, да.
Да, порядок важен, у нас нет задачи просто взять эти элементы куда-нибудь пихнуть, так-то мы могли бы их в связанном списке хранить, если бы нам был порядок не принципиально.
Поэтому, да, если тут h2 и тут стало меньше, чем h2, нет, ну, тогда заметим, что вместо этого мы можем просто подвесить вот это дерево, тут получается h2 плюс 1.
Но это неверно, что больше ничего не надо делать, потому что тут из h2 плюс 1 превратилось в h2 плюс 2, и, возможно, какие-то повороты нам тут все-таки придется сделать.
А это и неважно.
Главное, что у нас, главное, что если случайно, то есть, мы знаем, что если у нас есть, у какой-то вершины высота увеличилась на 1, причем других проблем нет, да, то как бы там, как бы поворотами, начиная с нее и до корня, мы решить эту проблему умеем.
Ну да, там магическая цепочка поворотов, я бы сказал.
Но это, правда, если тут меньше, чем h2, потому что если тут оказалось равно h2, то здесь, конечно, тут, конечно, как повезет, потому что может нам повезти, и тогда тут окажется, что вот такой везучий случай, когда тут h2 плюс 2.
Тогда, как бы заведомо, тут h2 плюс 1, и тут становится h2 плюс 1, то есть вообще ничего делать не надо буквально.
Но могло так случиться, что тут было h2 плюс 1, а станет h2 плюс 2, и все равно цепочку поворотов делать надо.
А вот если слева меньше, чем h2, то это вот.
А, вот, да, действительно, основная проблема заключается в том, что тут еще могло быть h2 минус 1, тут h2, а мы бах-бах и захотели послевать.
Ну слева сделать повороты, а после этого слевать.
Правда, но правда это будет называться, что мы в этом под деревом высота увеличилась на 1, и значит просто поворота надо делать, начиная не с этой вершины, а с вот этой.
Сейчас, я, может, что-то не понял, откуда мы берем вершину, которая у нас с общим родителем становится?
Вот эту, ну это, ну как сказать, вот эта вершина, это первая вершина на правом пути, которой высоты не более, чем h2.
А мы мержим также через промежуточное.
А, да, вот, то есть, да, мы замечаем, что из прошлого раза мы можем сделать вывод простой, что если мы неожиданно взяли в дереве, выпилили под дерево,
и заменили его под деревом высоты на единичку больше, то оказывается, что, начиная с него, можно делать цепочку поворотов так, что в результате дерево стало абсолютно корректно.
Вот, по сути, мы в прошлый раз ровно это и доказали, там предъявив, собственно, в явном виде цепочку поворотов.
Вот, здесь это тоже вот налицо.
Еще более того, повороты делаются так, что это делается за от разности высот, прям то, что нам надо.
Понимаете, да?
Вот, понимаете?
Вот.
То переча.
А теперь его величество сплит.
А?
Когда мы делаем повороты?
Когда мы делаем повороты?
Ну, нет, повороты, ну, как сказать, когда мы, ну, по сути, можно сказать так, мы вместо вот этого под дерево, по сути, подвешиваем новое, вот это вот.
Независимость от h2, h-1.
То есть, высота этого, ну, вот.
Ну, вот.
Ну, в данном случае, если тут h2, h2, значит, высота увеличилась на 1, и других некорректностей нет.
Поэтому получается, что начиная с него, делаем повороты.
Какие конкретные повороты обсуждались на прошлой лекции?
Вот.
Да, но если тут h2-1, то у нас там высекают мелкие проблемы.
Вот.
Ну, как, ну, на самом деле, ладно, там увеличивается, конечно, на 2, но за счет того, что тут тогда будет, если тут h2-1, то тут будет точно h2.
Поэтому получается, что проблемы, там, разве что у этой вершины, у которой теперь высота изменилась, но само дерево осталось корректным.
Вот.
То есть, там нужно было идти вверх?
Да, но начиная уже с него.
Ну, можно и с него, на самом деле, тут как бы все корректно будет просто.
Вот.
Так.
Ну, теперь как делать сплит?
Но, заметь, ну, сплит делаем абсолютно так же.
То есть, сплитим по катому элементу.
Так.
Ну, отлично.
Если этот кат-элемент оказался корнем, то сплит понятно как делать.
То есть, просто дети становятся самостоятельными деревьями, корень становится отдельным городом товарища.
Но если совершенно случайно выяснилось, что, там, скажем, кат-элемент находится в правом под дереве, то как бы мы все равно корень отправляем в свободное плавание,
левое под дерево живет, и, значит, сплитим вот это.
То есть, обратите внимание, ну, то есть, делаем абсолютно так же и получаются абсолютно те же вот цепочки, как были раньше.
Вот.
Сейчас.
Только единственное, только что на каждом шаге у нас теперь появляется ровно одно дерево с одной из сторон, это точно.
Они, как раньше, могло и с обоих, могло и не с обоих, а теперь прям принципиально.
То есть, опять такие же, то есть, у нас опять задача.
Дана вот такая цепочка деревьев, и надо их каким-то образом смешать.
Она точно не возрастает?
Вот.
И еще одна маленькая подлянка.
Маленькая подлянка заключается в том, что на этот раз мы даже не можем гарантировать, что эти...
Скажите так, а можем ли мы гарантировать, что высоты этих деревьев, ну, хотя бы не возрастают?
Ну, просто в прошлый раз у нас тоже были невозрастающие деревья, и мы с этим прекрасно справились.
А теперь внимание, вопрос.
Верно ли, что каждое следующее дерево не выше предыдущего?
Ну, кстати, вроде бы верно.
Да?
Ну, давайте разбираться.
Вот жило было под дерево высоты h.
Теперь думаем, какое будет следующее.
Но заметим, что дальше мы пойдем вправо, и тут может быть высота h плюс 1.
Но заметим, что отпиливать-то мы не его будем, а отпиливать мы будем в лучшем случае его левое под дерево.
А если повезет, то мы вообще сейчас пойдем влево и еще там ниже отпиливаем.
Поэтому как бы отпиливать мы будем вот как бы либо это дерево целиком, либо какой-то его под дерево.
И это будет меньше, либо равно h.
Поэтому мы можем на этот раз гарантировать, что каждая следующая высота не больше предыдущей,
а это означает, что как бы слить эти деревья за, собственно, за h или за разность высот там первого и последнего мы прекрасно можем, оказывается.
Ну там, точнее, разность высот плюс количество деревьев, конечно же.
Вот, понятно?
То есть на самом деле у нас просто тоже самое?
Ну подда.
Прям технология та же, то есть оказывается, так что если вам не нравится b дерево, просто пишите avl со сплитом.
А это и не работает, наверное.
А если не нравится avl, то пишите b дерево.
Ну вот, если вам не нравится avl, то, пожалуйста, у нас есть красно-черное дерево.
Да, сейчас будет вообще чит сезона.
Красно-черное дерево со сплитом и мержом.
Чего?
Ну а что, все на камеру записывается, да, значит будет.
Чего?
И потом, на самом деле у нас сейчас как-то...
Нет, если кто-то спонтирует так, что этого не будет, это будет плохо, конечно, да.
Нет, ну там, конечно, всякое бывает.
Нет, ну как сказать?
Нет, еще ваша задача сейчас меня, как всегда, вытрясти.
А то, знаете, недавно вообще у меня произошла забавная ситуация.
То есть называется там...
Я вот сейчас преподавец в 57 школе,
ну вот, ко мне пришел одиннадцатиклассник,
ну там, зовут его Илюша Васильев, если быть там, может быть.
Кто же это такое?
Да, знаете, такого, да, ну вот.
Ну вот, и он говорит, что я тут это, Волкашак читал лекцию по Гомориху,
называется на основе вашей лекции.
Так вот, у вас там в конце бага в доказательстве.
Да, говорит, там что-то недодоказано.
То есть нет, нам удалось разобраться.
Ну вот, соответственно.
Так что, в том числе и ваша задача сделать так,
чтобы на экзамене не выяснилось, что, оказывается, что-то недодоказано.
Волкаша просто с интересной подготовкой лекции читается.
У нас зимой, кажется, наш лектор просто полтора часа
во время пары убил вот эту самую самому разобраться.
Ну, так а думаете, с какой целью такие лекции назначаются?
Вы задали какой-то вопрос, и человек сломался на полтора часа.
Нет, мне страшно, что вы, получается, задали вопрос
в начале лекции, видимо.
Нет, спустя минут 40, наверное.
Там в середине просто.
Нет, если он сломался на полтора часа.
То есть лекция была два слишком.
Лекция суммарно была много.
Ну понятно, да.
Ну вот тут...
Да.
Возможно.
По одиннадцатым.
Не, Леша Васильев в одиннадцатом.
Это я вам гарантию даю.
Так вот.
Но давайте думать, как же сделать мерч в красно-черном дереве.
Вот.
Так, ну давайте, для этого, конечно, нужно вспомнить,
а что такое вообще красно-черное дерево.
Но в случае човка, в помощь вам презентации,
которая уже в группе находится, кстати.
И прочие повороты, которые нам сейчас вспоминать не надо.
Путь по одному цвету всегда одной длины.
Нет.
Да, значит, давайте вспоминать.
Что такое красно-черное дерево?
Это дерево, у которого все вершины красные и черные.
Гарантируется, что у красной вершины не бывает
красных детей.
И гарантируется, что корень черный.
И гарантируется, что на пути
от любого, от корня до любого
крестика
абсолютно одинаковое количество
черных вершин.
Но отсюда следует,
что от любой вершины до всех
крестиков, которые у нее в поддереве,
одинаковое количество черных вершин тоже.
Но это следствие.
Главное, как бы, что от корня везде одинаково.
Вот.
Не уверен.
Потому что вообще еще есть random balance
3 на самом деле.
Это аналог
декартачки, в которой не хранятся приоритеты.
Но это персистентно.
Нет, персистент, то есть тут вообще ни при чем.
Нет, просто есть
декартовое дерево. Что такое декартовое дерево?
В нем в каждой вершине хранятся приоритеты,
и мы строим так, чтобы по ним было куча.
Вот.
Мы пишем просто персистентную
декартачку вот ровно вот так.
Да, потому что мы там не храним приоритет,
и вместо этого в каждый момент, когда ввержем,
мы просто сливаем, кидаем монетку,
какой корень будет корнем.
Ну, там монетка может быть 1-2,
или как принято это делать,
вероятность будет
больше у того, кто тяжелее,
ну и так далее.
Персистенты декартачки так пишут.
Но вообще, по идее,
это называется random lead balance, по-моему, 3.
Поэтому РБ,
аббревиатура может быть неоднозначная.
Я, собственно, к этому.
Я у меня во всех шаблонах.
Ну вот. Итак, давайте думать,
что же нам теперь?
Итак, ну давайте так.
Что же нам делать?
Как же нам теперь слить?
Так, ну начнем с простого.
У каждого дерева
есть черная глубина.
Черная, черная глубина.
И вот надо опять будем
сливать через промежуточную вершину,
ну естественно.
Так, ну если эта черная глубина
одинакова,
вот не глубина одинакова,
а черная глубина одинакова,
то есть тут BH и тут BH,
то как слить эти два дерева?
Через промежуточную вершину.
Да, просто корень черным,
и все.
Да, никаких проблем.
Да, как бы все.
Ждет сценографистка в кабинете,
вы диктуете там пару новых теорем.
Ну вот.
Ну и конечно же держите это в секрете,
и на какую камеру не записывайте.
Сибирский паренек.
Советский математик, да.
Да, правда как-то странно, что история как будто
на этом обублено, то есть как будто он доказал,
сказал и пошел дальше
дрова рубить.
Ну ладно.
Так вот, а теперь
следующий вопрос.
Что делать,
если у вас совершенно случайно
казалось, что черные высоты различны?
BH1 и BH2,
и промежуточный элемент.
Так, ну казалось бы,
да, мы спустимся до той же самой
черной глубины,
и давайте просто подвесим вот эти вот два
дерева вот так.
То есть вот как всегда.
Да, вот такие вот это вот.
Зелененьким вешаем.
Вот, но возникает маленькая
проблема.
Нет, возникает
нет, с цветами никаких проблем нет,
черная вершина никаких проблем с цветами не дает.
Проблема возникает больше,
ну вот.
Проблема возникает в том,
что да, тут из-за этой вершины теперь с черным путем
проблема возникает.
Да, ну вот,
и поэтому, ну как сказать, можно
наверное и так выкрутиться, но легче кажется так.
Давайте объявим эту вершину красной.
Да, но теперь у вас
возникает максимум какая
проблема может быть, учитывая, что эти вершины заведомо
черные. Ну вы здесь можете выбрать, чтобы эта вершина
была черной, да?
Давайте скажем, если выяснилось, что эта вершина
красная, значит у вас классическая ситуация
из инсерта.
Помните, то есть у вас классное дерево, все хорошо,
только вот как есть как бы родители ребенок
красный, это только один раз такое встречается в жизни.
Ну а мы помним, что там
цепочка каких-то там перекрашиваний
поворотов, в общем поворотов мало,
прекрасно решит проблему.
Вообще прикольно, но получается без инсерта и мерча
не сделаем особо.
Ну на самом деле
да, и без делита еще.
Да, то есть на самом деле инсерт
и делит мы проходили с вами не зря.
Нет, ну можно там всегда
нет, можно конечно хранить
между... как бы если у вас есть
10 элементов, давайте хранить дерево на 2
и минус 1 элементом, где там посредине лежат
фиктивное, конечно.
Но не уверен,
что это нужно делать.
А у нас не может быть такого, что 3 красных?
А откуда?
Нет, у вас эта вершина
заведомо черная. Ну вы можете
выбрать эту вершину так, чтобы она была черная.
А справа?
А справа она черная, потому что
она корень.
И там
заведомо, что подъем тоже устроен
красивым образом, так что
все это сработает реально за разность
высот. И при этом
глобальная черная высота будет там
насколько я помню
не более либо BH1, либо BH1
плюс 1.
Так что вроде никаких проблем
тут быть не должно.
А, единственная проблема, которая у нас может быть
это как раз вот эти две красные.
Да, поэтому мы как бы там
но это проблема мы
решаем, и черная высота от этого
вроде как не уменьшается.
Или уменьшается?
Вроде нет.
А после темы, кажется, вообще можно просто выделить
по дереву?
В смысле?
Я может что-то из варианта забываю?
Так, ну вот давайте внимательно думать.
Потому что как мы теперь будем сплитить?
Ну сплитить, естественно, будем
работать также, только разница будет
в том, что
если мы просто будем сплитить, то мы можем обнаружить
что у каждого поддерева
которое получится
заметим, что корень может быть
как черной вершиной, так и вполне себе
красной, правда?
Да и промежуточная
вот эта вершина, она тоже вполне себе
какой-нибудь красный может оказаться, правда?
Я бы даже больше скажу, в принципе
вот такая ситуация тоже вполне
возможна, очевидно.
Потому что это поддерево вот с этой
вершиной может быть не связано напрямую.
Нет, сплит делаем как всегда.
То есть жил был корень.
Так, ну вот, допустим
он оказался, его порядковая статистика
оказалась меньше, чем К.
Ну значит тогда мы в левую часть сплита
отправляем вот это поддерево,
не важно тут какая вершина красная или черная,
ну вот, и также
ну вот, и эту вершину.
А вот правое поддерево мы типа
сплитием рекурсивно.
Мы можем просто перекрасить, если у нас
красный корень.
Что перекрасить?
Просто если у нас получился дерево с красным
корнем, мы просто перекрасим.
Погодите, погодите, погодите.
Я сейчас просто аккуратненько,
потому что надо понять что-то хотя бы о варианте,
потому что как бы нам бы неплохо
было бы, чтобы эти деревья были
отсортированы по убыванию,
хотя бы по невозрастанию черной высоты.
Если мы сейчас наточим перекраш,
то есть у нас как бы и без перекраски начинаются вопросы.
То есть, во-первых, давайте подумаем,
верно ли, что каждое следующее дерево без
перекраски обладает не больше
черной высотой, чем предыдущее?
Наверно.
У нас влево под дерево есть черная высота,
у правого под деревом черная высота такая же, да?
Это означает, что для любого его под дерева
черная высота не более,
чем такая?
Я говорю, не более, потому что
может оказаться, что тут красная вершина,
и у этого черного под деревом высота
inverse такая же, пока у этого.
Такой может быть.
Напоминаю, тут промежуточные
Да, тут промежуточные вершины могут быть и красными, и черными, как углы.
Все нормально, если у него красный корень, то у него высота строго меньше.
Нет, в смысле, черная высота у него такая же.
Тут кажется, можно еще кое-что.
Если у нас дерево получилось с красным корнем, то черная высота у него должна оказаться меньше.
Потому что предок у него точно был черный.
Нет, погоди, погоди, почему это?
Смотрите, сейчас расскажу ситуацию.
Жил был корень.
И был у него левый ребенок черный и правый ребенок красный.
И было у них одинаковое, естественно, согласно инварианту, черная высота BH.
И отпилили вы левое поддерево высоты BH.
А потом, бах, пошли еще раз вправо, и как следствие отпилили вот это поддерево целиком.
Внимание, вопрос, какая черная высота у этого дерева?
У него черный корень.
Ну да, еще.
Ну, значит, не нужно перекрашивать.
Не нужно перекрашивать, значит, равенство у нас устраивает.
Так.
Упередается, что если мы отпилили в какой-то момент дерево, и у нас под деревом получился красный корень.
Так.
То у него где, ну, до этого был черный, у него был черный предок.
Соответственно, черная высота уменьшилась.
Соответственно, если мы перекрасим, то мы не сломаем ничего.
Так.
Ну, хорошо.
А можно чуть по-другому попробовать?
Так.
Да.
Нет.
Сейчас.
Не все способы сразу называются.
Так.
То есть, что вы хотите, значит, предлагается следующее, что утверждается, что так пришло время выдать вам билет.
Ладно.
Вернемся к делу.
Так.
Итак.
Значит, что нам тут предлагалось?
Предлагалось, значит, так жестко объявить, что, во-первых, черные высоты здесь действительно не возрастают.
И при этом, более того, еще и читерским образом гарантируется, что если вершина красная, то предыдущий знак неравенства заведомо строгий.
Вот.
Нет.
Это как бы...
Ну, тут, правда, возникает вопрос.
Ну, возникает вопрос, насколько...
Да.
Но зачем нам это надо?
Так как раз у нас гарантируется, что если вершина красная, то предыдущий знак неравенства точно строгий, то тогда проблему красных корней можно решить очень легко.
Мы их просто перекрашиваем, и при этом отсортированность никак не порчится.
Понимаете, да?
Мы делаем.
Мы делаем сплит в красно-черном дереве.
Мы делаем сплит.
Делаем классическим образом.
Ну, вида там.
Берем корень, значит, там, собственно, понимаем, что там, скажем, катая вершина хоть справа, и, значит, отправляем эту вершину опередней вот этого под дерево типа влево.
Если бы она...
Если бы оказалось, что кар где-то справа, то мы эту вершину вместе с правым под деревом проявили бы справа.
Ну, все, спасибо.
Я просто немножко торочился.
Вот.
Ну вот.
Итак, что же получается?
Итак, у нас есть веселые деревья.
Значит, получается, у нас есть абсолютно корректные на этот раз деревья.
И там промежуточные вершины.
Нам, в общем-то, на самом деле плевать уже, как красные они там, или зеленые, и черные.
Вот.
Это корень дерева тоже.
Не.
Не, не факт.
Видите, ниже корня.
Самое первое, конечно, черное.
А вот, а дальше потом...
А, кстати, не факт.
А, кстати, не факт.
Если самое...
То есть корень, конечно, отправится либо туда, либо туда, скорее всего.
Но...
Как бы...
Ну вот.
Но как бы там...
Получается, если он отправился вправо, то там могла быть и красная вершина.
Почему бы нет?
Но это нам не важно.
Мы, на самом деле, уже забиваем в этом месте на это.
То есть у нас есть просто ключики.
Ключики, корректные деревья.
То есть можно писать меж на тимплейках сразу для RB3, для AVL?
Ну, в принципе, да.
Так что вот.
То есть получается даже красно-черное дерево
прекрасно поддерживает сплит мёртвые там эти...
Основной вопрос.
Это же в предположении, что неравенства были строгими.
Как были каши, они становятся нестрогими.
Да.
Они становятся нестрогими.
Но сливать под деревья...
Как бы мы уже научились.
А если они были нестрогими?
Нет.
Мы доказали следующее, что если у дерева оказалась красная корень,
то неравенство точно строгое.
Ладно.
Вот.
Это фишка.
Мы же походу испортили там инварианты.
Какой?
Ну, например, то, что путь до крестика должен быть.
Оттого, что мы в каком-то дереве взяли его корень.
Внимание, кстати.
В этом месте это дерево становится как отдельное дерево.
Никаких предков нет.
Да.
Поэтому мы здесь спокойно можем перекрасить красную вишину в чёрную
без нарушения инвариантов каких-то.
Нет.
Вопрос к этому.
Вот когда мы из него вырезаем...
Слушай, когда мы вырезаем, а мы же из дерева ничего не вырезаем.
Мы по факту у дерева распиливаем на два поддеревы одну вершину.
С правым поддеревом работаем рекурсивно, а левое поддерево запихивается туда.
То есть на самом деле мы ничего не вырезаем.
Вот какое объединение, которое мы показали на низком рисунке?
Да.
Здесь.
Мы такое не делаем, да?
Мы просто оставляем как раз личные деревья и потом их мерзим.
Ну да.
Всем я говорю, пока мы делаем вот этот распил,
у нас даже не парит вообще эта вершина красная или чёрная там корень.
То есть получается мы так же как у B3...
Нет.
В общем мы делимся на деревья и потом уже их мерзим.
Ну да.
То есть сначала мы получаем список этих деревьев с промежуточными ключиками,
а потом уже их мерзим классическим образом.
А здесь промежуточный ключик это чёрная серка, да?
В данном случае да, вот эта чёрная.
Да, вот эта.
В данном случае да.
Но потом может промежуточной следующей статьей эта красная.
А для того, чтобы превратить эти деревья,
корректные помодлю того, что корень может быть красный.
Хочется сделать в абсолютно корректном перекрасе в корень чёрный цвет.
Но перекраска корня изменяет чёрную глубину, чёрную высоту.
И этот факт нам нужен для того, чтобы показать,
что в результате этой перекраски как бы отсортированность деревьев по невозрастанию остаётся.
Так что получается такая вот красота.
Ну и в общем-то.
Чего?
Ну в смысле мэж, да, заразится глубина.
Ровно за счёт этого сприт получается тоже за то, что надо.
Ну я бы сказал так, за от глубины каты вершины плюс один получается.
Ну то есть конечно вот эта классическая красночёрная радость
на тему того, что вот там от единицы каких-то там переворотов при подвешивании
конечно тут вылетает трубу.
Ну вот, тем не менее.
Так что получается, что на самом деле, да, то есть на самом деле сплит и вершины,
прочие и вершины подотрески, это не есть прерогратива красночёрной, именно дикартьячки.
То есть на самом деле это умеют все.
И на самом деле, то есть эти операции можно вполне себе делать не за вероятность нелогарифом,
а за предельно честный.
Вот даже вот выбирайте каким способом.
Так что вот такая красота.
Не знаю.
Хороший вопрос.
Я не пробовал, если честно, я не знаю.
Так что можете попробовать, да будет даже интересно.
Так, ну ладно.
Но теперь пришло время, как бы да, в программе это есть, но вот вопросы возникли так,
что придётся поговорить про деревоотресков в технологию отложенных операций.
Нет, ну смотрите, нет, во-первых, про это мы вынуждены поговорить,
ну потому что я говорю, то есть мы должны в том или ином виде это обсудить.
Просто, ну а так просто я спрашивал, как бы все ли это знают, ну вот подняли руки,
я заметил, не все, и дело даже не в спящих.
Ну вот, поэтому сейчас мы просто быстренько обсудим.
Ну и ещё, ну и вторая цель, как всегда, то есть давайте,
как бы чтобы привести нас с вами к единой терминологии.
Потому что там выясняется, что как бы вроде все в целом знают,
а потом выясняется, что под одними теми же словами подразумевается вообще не то.
Потом выяснится, что для вас там технология отложенных операций,
оказывается это сплит-ребилт, например.
А, ну да, так было проще, ну ладно.
Так еще ладно, включаем телевизор.
Ну, а что, да? Представьте, чтоECTO в 아까шем году была в 18.
И в 18 obsession.
В 18?
нет так но чудо представьте себе до каковица представьте себе что да представьте что даты
до встречи дасты перед битвы встретились два войска но вот там там один из полководцев обладает
красноречия мы другой нет и там вот да и там что-то мы да мы сегодня нас ждет славная победа там
мы победим вас мы уничтожим вас и там и вот и захватим ваша года второй или это мы так сделаем
так так то что ж и так триангуляции до ланы пересечения полуплоскостей так когда
дерево нет это нет это программа третьего семестра скорее всего вас ждет примерно то
же самое поможет того что в вашем случае скорее всего тут будут еще потоки видимо
нет просто-то но почему нет 3 это удовол 4 это хор 5 это отл
но у конян почему-то ну да ну или там да соф автомат конечно и ну но софтомат
там извините по алгоритм со всеми доказательствами да вот плана так вот
нет но там не переживайте собственно более того мало того что они самые сложные доказательства
так еще и мы будем как бы его проходить где-то явно во второй половине следующего семестра когда
у вас то формалка когда вы на формалках уже хорошо поработаете с автоматами в принципе но
поэтому после этого на самом деле там понять доказательства будет не очень сложно на самом
деле ну ты не там но так так ну ладно господа давайте ой выключите там свет пожалуйста вот
спасибо но вот так так но первых вот тут мы пробежимся что да у нас тут сплида так
ладно сплит у меня тут например с плей дерева но с плей дерева мы явно будем
обсуждать уже в следующий раз так бла бла бла бла бла бла а ну ладно давайте тут пробежимся на
всякий случай быстренько да но так напомним потому что ну а первых да что как бы если вы
дерево отрезков надо вспомнить что мы говорим о задачах рск и рмку но ладно тут тут определение
думаю вас достаточно классическое вот видно да но и раскуречь сам квари да то есть это
классическая постановка это типа заменить одно число в массиве и найти сумму на подотрески но
рмку то же самое что с минимумом но скажем так в принципе идея на общем-то мы еще нет потому
что все деревья которые ладно мы не знаем пока не шуткой декор тачки декор тачки и шуткой
с плей вот но мы знаем другие кучу способов как это делать за логарифом да с помощью сплита и
мержа в общем-то это делает овл прекрасно как мы уже поняли и красно-черная там и б там в общем
как угодно но надо рассмотреть другие способы потому что да сейчас будет разговор о программировании
математики математически бы глобально ничего нового не узнаем но программистки
наверно дерево отрезков писать проще чем овл со сплетом и мержем правда вот поэтому но давайте
разминочка статик рск но здесь вот смотрите здесь мы вводим понятие частичные суммы но вот частичные
суммы они же префиксные суммы но нет статик рск это означает что предположу что массив не
меняется что мы тогда делаем тогда мы говорим что давайте просто насчитаем сумму каждого
префикса и тогда после этого сумма здесь получится достаточно простой ну понятно она
просто пересчитывается просто вычитать то есть там идеальная структура данных от предподсчета
от единицы на запрос все в честную не фарах colton bender это как бы он делает то же самое но
когда она не статичная нет как бы нет эти два человека с тремя фамилиями собрались не для
того чтобы написать вот эту строчку да но нет сейчас мы этом до этого мы тоже доживем не волнуйтесь
нет метод четырех русских это для нас да значит так вот здесь возникает конечно очень это тот
очень интересный момент сейчас нам тоже еще попишем значит на третьем вот у нас есть еще
такая штука как статик рмку вправывается что это значит но вот ну как бы да то есть заметим
минимум обратимой операции не является но вместо обратимости в игру вступает и демпатентность
соответственно да что такое демпатентность да вот тут так вот во втором абзаце это слово вот есть
вот оно и демпатентность вот да это такой факт что как бы у вас есть как бы операция на множестве
элементов даже на мульти множестве оказывается что если вы добавите элемент который уже был то
ничего не поменяется это называется и демпатентность вот результате появляется такая классическая
штука как спарс тейбл
я погодите нет здесь все правильно сказано
но да тем что да да да но да я к сожалению иногда включаю режим черномы где на конечно это да но
да тем что мина а ну да ну да мина а ес что есть ясно вот так что такая красота но пересчет
думаю тут вопросов сильных не вызывает я думаю то есть никаких проблем нет вот то есть бомжи
болта с помощью такой таблицы вполне себе можно вычислять минимумы на подотрезке даже за от единицы
потому что любой отрезок но чем там тут написан какой-то текст но суть его догадывается в том
что любой отрезок можно покрыть двумя отрезками длины степени двойки но так и быть пусть они
пересекаются понимаете да вот так что вот такая красота но пожалуй сейчас мы все-таки включим
свет и попробуем найти решить еще продвинутую версию стать корымку значит продвинутая версия
такая представьте себе что нам нужно сделать но то есть у нас есть какие-то элементы мистического
множества на котором определена операция быть да да если бы это есть это да мы сейчас будем
обсуждать дюджин спортси да но то есть раз уж раз об этом зашла речь то как бы не опомянуть об
этом нельзя вот и так ну да и вот опять там когда да в каждой песне
не тогда в каждое но там берет каждой песне настает момент когда можно не смывать он
нужен для того чтобы забыли припев и мы могли его спеть еще один раз и снова он да просто
так вот это мы будем звать операция быть да но у нас уже вы уже встречали такую операцию в прошлом
семестре да значит операция быть значит фишка такая дан массив из элементов а он статический и
и очень значит и но на множестве а операция значит апелла операция быть все что про нее
известно что операция быть ассоциативно это означает что массив меняться не будет но нам
очень хочется отвечать на запросы уить на подотрезке да но порядок не принципиален потому
что уить ассоциативно то есть мы можем отрезок разбить как угодно на два отрезка найти эти
рекурсивно потом скрыть этих в конце вот так что здесь в общем не очень сложно вот значит это
быть все в этом мире быть ассоциативность но ассоциативность это означает что а1
в скобочках быть а3 равно а1 быть а2 быть а3 но да сразу видно что мы с вами фенвик и не
обсуждали да нет это тоже все будет не волнуйтесь там все фенвик это весело да вот значит это
быть значит и очень хочется отвечать на запросы быть на подотрезке заметим что к сожалению тут
уже как бы операция и обратимой быть не обязана поэтому префиксная сумма вылетают и
конечно и демпатентностью тут не пахнет да тут даже коммутативности нету господи какая
демпатентность уже вот спрашивается что же делать какой квадрат зачем квадрат операции на квадрате
когда дерево у нас будет следующим семестром а может и ну подумаем ладно но вообще как бы
это геометрическая структура данных поэтому как бы по идее следующим нет там такой это там
такое красивое дерево на самом деле она хотя да пока оно дерево может логичнее его и сейчас
конечно да там-то да там такой красивый шоу с доказательством да ну вот значит смотрите что
тут делать вот но идея оказывается неожиданно простой внимание да но да но цель конечно что
хочется быть и быть конечно хочется делать за за сколько правильно за о от единиц вот логично
да но какая идея могла бы быть вот но идея может быть такая но если нам плевать за какой симпатику
предподсчет да давайте насчитаем ответ на всех подотресках и сохраним да да
ой ой ой но это отдельно пись это на так это так эту песню мы отдельно будем
рассматривать и в подробности да да да это шоу нет это шоу тоже есть конечно конечно
нет есть там вообще за этот четвертый там но это вот так вот так тихо да конечно же
мы хотим отвечать на запросы за единицу боже упаси считать иначе да да да да да да да
наша цель сделать как спортсах предподсчет за ноготь нет можно конечно не хотя нет тут
конкретно тут с фара холтон бендером крыши вопросы будут сейчас то есть а
ну в принципе а ну а ну да если да если не сводить когда если их водить колсашка туда
в принципе да нет классический фар холтон бендер от сводит все-таки задачу колца а вот так
плюс минус один а потом это да да если да если делать напрямую то наверно да сработает наверно
а ну хотя так что бы ему не сработать да в общем смешно ладно очень смешного будет конечно лад
вот сейчас хотя так что погоди погоди как фар холтон бендер сработает если тебе для
подотрезка все возможных массивов длины не более чем ка надо посчитать ответы
а ну что такое плюс минус один с операции уйти
да нет там было принципиально что с точки зрения с точностью до двига там
массивов все длины ка всего два степени к минус один и поэтому их можно было предподсчитать
русских на этом и основа но какой сдвиг у нас даже операция необратима какой сдвиг
не обратим но минимум не обратим но слава богу там можно прибавлять числом константу и минимум
позиция хотя бы минимуму не поменяется там этим начинаем пользоваться вот но нет с бытию я
боюсь так фар холтон бендер просто так на халяву не сработает так что увы да так что не все так
просто да знаете так что нет как говорится нас попытались придавить авторитетом но но нет но как
говорится геннадий короткий еще это не удавалось и тебе тоже не удастся да это называется не но
геннадий как есть айвы чей не рассказывал эту бойку что ли я мы как-то давали контеста пистей то
есть офисерский контест был в петрозаводске значит мы давали и там была была у нас одна
веселая задача ее тоже отдельно расскажу на том что они не важно не важно какая задача но
ладно давайте быстро расскажу что мы говорим и там задача и там история была такая что дачи
геннадий короткий значит пишет задачу так что он написал задачу посылает получает васи смотрит
так и так он говорит там он что-то но там и там и что-то вроде потестил там что-то по брут форсел все
нормально смотрит так никто задачу не задает это все в таком случае делаем правильно пишем
еще и слушайте а у вас там тесты точно правильно я тут по брут форсел у меня все работает значит
мы открываем задачи открываем тесты смотрим как у него ответ из 17 цифр при том что ответ
должен быть по модулю миллиард семь и с чистой совестью отправляем ему ноу коммерс но собственно
через пять минут он получил акцент вот это я называю да он попытался продавить авторитетом
да ну действительно с какой вероятностью больше бага у них или у меня действительно
вот так вот так вот и так что же здесь делать но здесь мы все-таки предположим что n это степень
двойки сейчас вы и сейчас вы поймете почему смотрите потому что мы построим что-то среднее
между деревом отрезков и полным протоколом мерш сорта но это будет бы но это будет больше
похоже на полный протокол мерш сорта потому что на каждом подотреске будем хранить от длины
этого отрезка элементов чем реально оптамуш по факту 2 не свести а то мне придется это совсем
это вживаться в роли а там как бы там это палка зубы там вылетали не надо вот вот ну что ты хочешь
чтобы я в следующий раз принес мы к тому же и кулак у меня тоже есть в принципе ну и что у меня
от этого кулака нету что ли лишь там есть кулак вот значит смотрите что я буду делать значит на
каждом подотреске я насчитаю префиксный и суффиксный и я считаю внутри каждого подотреска вот
этого из дерева отрезков я насчитаю все эти на префиксах и эти на суффиксах спрашивает как я
буду теперь искать уить на подотреске но идея очень простая но во первых если у меня
элия оказались из разных половин то я могу теперь идти на этом подотреске найти за от единицы
правда ну просто я как бы возьму ответ то есть ответ у меня какой-то вот такой будет и тогда
значит я возьму суффикс здесь и префикс здесь понятно да но но но что делать если у меня элия
окажется в одной из половин ну что пойдемте в правое под дерево да вот пойдемте правое под
дерево и если элия оказались тут в разных половинках то тоже за от единицы ну или там
дальше спускаемся спускаемся спускаемся но в принципе получается такой уйдь уже за логарифом
да это логариф безусловно нет это это штука конечно перестанет быть логарифом если мы с
вами неожиданно научимся за от единицы понимать а собственно в какой отрезок нам надо реально
там реально идти как же это понять по разнице по разнице ничего не поймет что разница если
между ними разница 5 это может быть 5 элементов здесь а могут быть здесь хорошо по разнице вы
ничего не поймете вы только можете по разнице вы можете конечно там оценить снизу что ниже куда
вы точно не пойдете но вот нет на самом деле заметим следующее почему я специально подчеркнул
что у меня n это степень двойки почему я специально подчеркнул потому что заметим что
элия попадут вот в корне в разные половины тогда и только тогда когда у них самый старший бит вот
этот вот там какой там к-1 различается правда более того они попадут в одну половину половину
когда он будет совпадать они попадут в одну половину здесь и в одну половину здесь тогда
и только тогда когда первые два 2 бита совпадают правда поэтому идея оказывается очень просто если
вы хотите как понять на каком уровне у нас произойдет сплит надо просто взять л сорр на это
ссор а не быть да то есть не путайте вот ссор и быть да у нас я понимаю что там может быть
проблема потому что прошлом семестре у нас быть бывал ссором да но но в данном случае идти это
другая но да правда для ксора легче при фиксу там это префиксные ксоры написать про то что ксор
коммутативная обратимый там в общем и ассоциативный еще так что да конкретно для ксора это писать не надо
вот это лучше для шаблона писать вот так вот делаем л сорр и смотрим на какой позиции находится
старший единичный бит как это на сделать ну на самом деле просто там так как у вас этот
сор будет все равно нуля до 2 степени к-1 да то тогда получается что вы там заранее можете там
за отн предпочитать для каждого числа кто у него старший бит понимаете да нет ну нет зачем она
логарифом просто за отн это можно предпочитать она точно вот единица работает предпочитать
а ну да а это функция называется да а это функция называется логарифа двоичной логарифа
округленной вниз да да окей но да но ладно это вы в любом случае предпочитать так или иначе
можете вот но дальше но вот нет но дальше в общем-то идея будет достаточно просто то есть там по
разному можно реализовывать то есть теоретически вы теперь как бы поняв уровень вы можете там
еще и понять в какие конкретно массивы вы попадете но на самом деле конечно есть еще более но может
быть на самом деле еще более крутая реализация на самом деле вот нет нет фишка будет такая на
самом деле дело в том что смотрите ведь суммарная длина всех этих массивов она как бы равна ровно
ну ладно 2 м правда так вот давайте на каждом уровне все префиксные суммы запишем в один
массив и все суффиксные суммы напишем тоже в один массив тогда я утверждаю что если вот
и леру у меня окажутся где-то здесь то тогда вам потребуется префиксная сумма вот здесь и
суффиксная сумма здесь правда и тогда при такой реализации окажется что вам просто на
соответствующем уровне нужно взять значение суффиксной суммы в эльтой ячейке где л это
абсолютное значение и надо его пройтить с префиксным префиксной суммой записанной в эльтой ячейке
соответственно уровне то есть получается прям реализация прям совсем куда-то
так мы спускаться не собираемся мы же уровень за вот единицу ищем
а супер пожалуй пожалуй да да да да да да да да да заметим еще что у нас как бы мы не можем эти
эти два отрезка не могут быть вот эти отрезки да то есть они могут только те которых у которых
есть вот общий родитель поэтому окажется что как бы в каждой паре действительно можно там в
левом отрезке можно считать только суффиксные сумма тут только префиксная получается по памяти
прям идентично классическому спортстейбл вот да спасибо да вот так что так что это был
понятно вот отлично так сколько у нас там времени так ну ладно теперь ладно теперь надо быстренько
разобраться с первым отрезков так так телевизор включись как-то телевизор включись холодильник
юда там и так далее да
так ладно выключить через новый свет пожалуйста
так давайте сейчас побыстрее пойдем так но вот кстати дерево отрезков так но вот если так
действительно так если давайте вкратце вот так или это уже рассказывать не надо это все равно
все знают но я помню что я спрашивал кто-то кто там писал дерево отрезков выясняется что кто-то
никогда не писал так что вот кто не писал давайте вот давайте первую смотрите внимательно потому
что все в остальном это не интересно как раз уже так но мы будем соответственно как хранить ну
храним мы вот примерно таким образом но вот даже тут вместо тысячи формальных слов он одна красивая
картинка на самом деле вот она то есть если мы это делаем для например суммы дамы и я пишу
дерево отрезка предположение что у меня два степеника элементов вот вот то вот оказывается
что вот очень удобно на самом деле хранить яче прям ячейки прямо в массиве ну потому что как в
куче да что дети у вас это там 2к и 2к плюс один ну и здесь там со сдвигом на единичку вот так
что вот такая вот красивая штука вот вы да вот главное вот почему-то я все равно нарисовал на
всякий случай красивую презентацию она почему пригодилась вот ну то есть как бы то есть видим
что вы не на нижнем слое храним весь массив а сверх вот такие суммы но каждая сумма пересчитывается
через две нижние вот но правда здесь вот надо поаккуратнее вот что оговоримся что если у вас
задача изменять один элемент то рекурсивный код писать не надо ну потому что на самом деле вот
захотели вы изменить вот этот элемент вместо пятачка появился кол да что делать но на самом
деле поставить вместо пятачка кол и пробежаться по всем родителям и собственно пересчитать вот
в общем заметим что только как бы подотрезки к которым этот пятачок отношения не имел в общем-то
и сами не поменялись вот но заметим что но вот то есть это в общем-то заметим что в общем-то это
прекрасно делается циклом ваил так у меня тут код не сохранился интересно во между прочим
сохранился то есть на самом деле видите присваивание обратить внимание что это делается вот таким вот
простым нехитрым способом но если присваивание одного элемента конечно нет это как раз нее мою это
до снизу да как-то знаете это до снизу и код и экстра без кучи куча крутых программистов почему-то
вообще могут не подозревать что оказывается это существует нет кто-то реально удивляется что
кто-то реально считает что там сет или куча прям впаянный в алгоритм д экстра намертво почему-то
нет нет и просто прочитали что теория так сразу удается а так но я не знаю не просто читали
д экстру без кучи изначально поэтому но вам еще я вам еще д экстру не читал да так вот
нет там была алгоритм д экстра с кличной кучей но не было самого алгоритма д экстра это нам в этом
семестре еще с вами предстоит это все веселье обсуждать там ну вот ладно да так вот но это
было присваивание это был файн сон вот сумму искать тоже можно не рекурсивно обратить внимание
вот ну кот работает вот за счет чего то есть он работает за счет того что вы вас есть под
отрезок вы думаете можно ли этот отрезок то есть это отрезок можно разбить на пары вот отрезков
у которых есть общий родитель ну вот и возможно на краю еще какие-то лишние элементы вот они да
вот тогда вы можете просто добавить эти лишние элементы к ответу и перейти на более высокий
уровень вот причем как понять является ли самый левый элемент отрезка лишь кем очень
просто надо просто понять там просто вот по индексам давайте посмотрим надо просто понять
он theater у нас все правые элементы четные а все левые элементы нечетные поэтому отличить
левый элемент от право очень просто вот вот�о очень оказывается удобно на самом деле
видите, если сумма на префиксе надо искать, вообще кайф, то есть тут вот прям красота
получается. Вот, так надо подробнее или все понятно? Так надо подробнее? Нет? Отлично. Вот, но в результате
код получается тоже на самом деле, на самом деле он по-моему как-то даже красивше получается,
чем там код того же самого сверху. Ну вот, так, ну хотя, а такими темпами, конечно,
на полу интервалах. Спасибо. Нет, олимпиаде я, кстати, на отрезках пишу. Ну, чисто по привычке,
на самом деле. А, кстати, а, погодите, погодите, слушайте, не факт, нет, погодите, нет, это отрезки,
все нормально. Нет, видите, мид плюс один, все нормально. Нет, я знаю, что есть полуинтервалы,
я знаю, что это круто, да, но, но, извините. Так, ладно, все, на этом, пожалуй, все. Так,
придется в следующий раз закончить. Эту и соответственно. Но ничего страшного.
