Что у нас происходит? Происходит примерно следующее. С хреш-функциями мы с вами закончили,
а графом пока переходить чуть-чуть рано, но мы это сделаем ровно на следующей лекции. Начнем
говорить про графы, про BFS, DFS, про DX3, про DIN, и так далее. В общем, много всего нас ждет
впереди. Сегодня будет такая более теоретическая, скорее, тема, чем практикализуемая, с которой мы
как раз-таки будем разбираться и просто теоретически смотреть и думать, типа вот это тоже
существует, это очень прикольно. Кто-нибудь когда-нибудь слышал что-нибудь про Фибоначи? Надеюсь,
все слышали. Правда? А про Фибоначеву кучу кто-нибудь слышал или пирамиду? Нет. Вот, видите? А вот
сегодня будет именно такое. Мы с вами поразбираемся с тем, что есть. Кроме того, кто из вас был на ДОП
семинарии Булат? По амортизационному анализу. Ага, значит, смотрите, объясню, что будет
происходить после того, как мы разберем пирамидки. Мы поговорим с вами достаточно сжато про амортизационный
анализ, потому что Булат с вами еще раз про это говорил. Третий раз повторяться не самое классное,
так как вас немного там было, то я очень кратко пройдусь, потому что там происходит. Это вам
понадобится с точки зрения реализации вектора и вообще почему вектор так работает. Вот, когда
вы до этого дойдете? Возможно, это будет очень скоро. Есть запись, я знаю. Я знаю, что есть запись,
но заставлять вас смотреть запись чего-то дополнительного, возможно, немножко жестоко,
вот, поэтому лучше... Я вам кратко это расскажу, а дальше вы сами решите, если вам будет недостаточно,
вы посмотрите. Если достаточно, значит, на экзамене спокойно ответите. Вот, все просто.
Окей, а давайте тогда начинать. Смотрите, сегодняшняя тема называется пирамиды. Куча
разных пирамид мы будем сегодня рассматривать, ну как куча. Всего их будет две, вот, а третью вы
уже знали. А третья, какие пирамиды будут рассмотрены, ой-ой, сейчас, будут рассматриваться
вообще, в принципе, сегодня. Ну, бинарная пирамида — это то, что мы проходили с вами еще в прошлом
семестре, это где у нас было построение пирамиды, это где мы доказывали хипсорт, смотрели,
насколько это все работает и так далее. И у нас сегодня будет бинемиальная пирамида и фибоначева
пирамида. Это две очень интересные структуры данных сами по себе, которые могут позволять делать
какие-нибудь вещи. И для того, чтобы их сравнивать между собой, вот мы как раз-таки попробуем с вами
оценить время операции каждой из тех, которые здесь есть. Гет минимума, вставки элемента,
экстракта минимума, уменьшение какого-то ключа и мерджить между собой пирамидки. Вот, такие вещи
часто нужны, часто встречаются, поэтому это основные такие функции, которые нам необходимы. Вот,
как-то так. Вот, смотри, тут стоят вопросики. Кто мне готов сходу сказать,
насколько это работает в худшем случае и получить от меня хотя бы почет и уважение,
давайте так типа назову. Плюс бал не обещаю. Да, минимум сверху. За единицу что? Get mean, I insert.
За логариф. Хорошо, экстракт. Тоже за логариф. Декриз. А это уменьшение ключа. Ну, то есть у нас
есть какие-то элементы в пирамиде, мы берем и уменьшаем ключик. Нам надо установить за логариф.
А мерч? А? Мерч пирамиды, в которой есть m элементов и n элементов. Вот, минимум n. Не,
не подходит. Давайте еще. Вот единицы. Очень сложно мерчить пирамидки за вот единицы. Вот m
плюс n. Это если мы будем перестраивать всю пирамиду. А можно ли что-нибудь придумать еще?
Что еще раз m log n? Почему? Да, можно вставлять каждый элемент поочередно. То есть здесь,
в зависимости от того, что захотите, можно реализовывать и так, и так. Да, в худшем случае
все это работает вот за столько. Мы сегодня дойдем с вами в конце до того, что у нас фибоначевая
пирамида сможет делать почти все эти операции, да, от единички. Кроме одной. Кто не знает ответ
какой? Юнион? Нет. Не юнион. Еще? Декриз? Еще? Мерч? Еще? Гетмин очень странно не за вот единички
делать, если честно. Пирамида для этого сделана все-таки. Хорошо, пусть это будет такой небольшой
интригой, который в конце будет понятно, что с этим делать. Но перед тем, как вообще перейти к
фибоначевой пирамиде, сначала поговорим о биномиальной пирамиде. Это такой предвестник
фибоначевой пирамиды, которая ляжет в основу всего остального, что мы будем понимать. Но
перед тем, как говорить о пирамиде, мы поговорим о дереве. Что такое биномиальное дерево? Смотрите,
биномиальное дерево, оно задается немножко рекурсивно. Примерно следующим образом. Биномиальное
дерево, ранга 0, это одна вершина. Биномиальное дерево, ранга K, это когда у нас есть корень,
и к нему присоединены биномиальные деревья, рангов 0, 1 и так далее, K-1. Просто. То есть,
мы к дереву подцепляем всех его сыновей вот таким вот образом, чтобы у них ранги были различны.
Ок? Понятно? Вот. Чиселки, которые тут указаны, 0, 1, 2, 3, это как раз вот те самые ранги,
которые здесь присутствуют. Если говорить чуть-чуть альтернативно, то как можно представить еще
какое-нибудь биномиальное дерево, ранга K? Можно сказать, что это просто два присоединенных друг
к другу биномиальных дерева, ранга K-1. Это понятно почему? Да? Вы очень сложно реагируете.
BK-1 относится к вершине тоже. Давайте еще раз, смотрите. Вот. Вот это все, это BK-1. BK, ну,
это как раз биномиальное дерево, ранга K-1. И я к нему присоединяю еще одно такое.
Корню, если вот это является биномиальным деревом, ранга K-1, то вот здесь присутствуют все сыновья
от 0 до K-2. И плюс я добавил еще одного сына, K-1. Понятно? Теперь стало понятнее? Вы хотя бы
говорите. Мне страшно. Биномиальное дерево, ранга какого-то вот K-1, это ранга K-1. Смотрите,
давайте еще раз. Возвращаемся сюда. Что такое ранга 0? Это одна вершина. Ранга K рекурсивно
задается друг от дружки. Фактически здесь мы воспринимаем ранг, это как что? Количество
детей. Видите это? Сколько у корни есть детей? Давайте посмотрите еще раз на этот пример,
что вас в нем смущает или не смущает. Еще раз, я очень плохо слышу. Можно?
Не интуитивно. Это согласен, нужно было обвести. Да, тут прошу прощения. Но фактически это делается
вот таким вот образом. Таким образом мы можем вывести некоторые свойства в действительности.
Что мы можем сказать про это биномиальное дерево, которое есть? Мы можем сказать,
что если у нас есть ранга K данное дерево, тогда количество вершин в нем это 2 в степени K.
Просто? Хорошо, ладно, предположим. Если вы не задаете вопросы, я считаю, что вы все понимаете,
все хорошо. Ок. И я могу сказать, что глубина дерева BK это либо K плюс 1, либо K в точности. Все
зависит от того, как вы считаете. Иногда их считают по ребрам, иногда по вершинам. Существует
реберная высота, существует вершинная высота. Здесь как вы захотите, так и сделать. Почему
это так? Ну это опять же в силу того построения, которое там есть. Потому что вот даже если глянуть
на вот этот вот кусочек, то если высота вот этого это там K минус 1, то высота всего станет K.
Ну оно увеличивается на 1 благодаря вот этой вот корню,
которой у меня есть. Вот. И это работает со всеми, что у нас происходит. Таким образом мы можем
сказать, что у нас K это всегда логарифм двоичный от N, потому что у нас количество вершин такое.
То есть глубина логарифмична. Хорошо это? Скорее хорошо. Любой пирамиды и любого дерева это
действительно хорошо. Теперь что такое пирамида? Смотрите. Вот то, что здесь написано, это не
является еще определением пирамиды. А первоначально, перед тем как перейти к пирамиде, давайте в каждом из
деревьев будем поддерживать свойства пирамиды. Что такое свойство пирамиды? Ну свойство пирамиды
это когда любой потомок не меньше, чем его предок. Помните такое в пирамидах? Было? Было. Вот. Ну как бы
тут нарисовано просто дерево, которым есть это свойство. Какого оно ранга? Три. Три. Хорошо. Да,
это просто дерево ранга три, в котором мы еще добавили какие-то числа. А вот что такое пирамида сама
по себе? Смотрите. Биномиальная пирамида это структура данных, которая состоит из бинарных
деревьев с уникальными рангами и указателя на минимальный элемент. Смотрите, в чем суть? Суть
примерно в следующем. У вас есть некоторые деревья различных рангов. Каждом из них вы поддерживаете
свойства пирамиды. Вы связываете все эти деревья вот таким вот списком. У вас здесь есть какие-то
элементики. Согласны, что сверху стоят минимумы из каждого, который есть? Ну не знаю там какие-нибудь
числа. Давайте 0, минус 1, 5, 6. Вот. И у вас еще будет указатель на минимальный элементик. И вот это
все в купе называется биномиальной пирамидой. То есть это не просто кусочек этого всего, а именно
все вместе. Да. Лучше всего делать ранги по возрастанию, так будет просто проще, когда мы увидим,
типа когда мы будем делать мерч между ними. Так в общем это не принципиально, но будет в силу
реализации удобнее так. Вот. И ранги, самое главное, заметьте, что они уникальны между собой. Нельзя
делать одинаковые ранги. В биномиальной пирамиде нету одинаковых рангов у вершинок. У всех деревьев,
которые есть. Ну смотри, что такое биномиальное дерево ранга 2? Как вы нарисовались?
Вот так. Вот. Вот это будет ранга 3 уже. Это все является деревьями. Деревьями какого-то ранга. Мы
все эти деревья между собой еще объединяем в список кладем, грубо говоря. Ну вот это вот
какой-нибудь односвязанный список. Вот. У нас все связано между собой. Сверху лежат минимумы. Мне
из любой пирамиды всегда нужно уметь доставать минимальный элемент. Для того, чтобы быстро
достать минимальный элемент из любой этой пирамиды, я хочу знать минимум среди всех этих
деревьев. Вот минимум это есть указатель, который мне должен указывать сюда. То есть у меня должен
быть указатель на минимальный элемент? Нет. Нет. У тебя все вот это связано называется пирамиды.
Каждое по отдельности это дерево. В каждом дереве корень минимальный элемент. Но тут может быть 0,
тут минус 1, тут 5, тут 8. У тебя есть указатель, который указывает на самый маленький. На минус 1.
Еще раз дерево не строится так. Дерево строится по правилу пирамиды. Вот так. Никакого слева
справа здесь нет. У тебя здесь даже уже три потомка. А может быть К потомка. Нельзя ходить влево-вправо.
Ну в плане типа у корней могут быть разные значения. Где именно лежит минимум я не знаю.
Окей. Вот это есть пирамида. А теперь смотрите. У меня дано какое-то число N. N это количество
элементов моей пирамиды. Могу ли я по этому числу N понять, как выглядит моя пирамида с точки
зрения рангов моих деревьев? Да. Правильно. Спасибо. Да. Это в действительности разбиение на
степени двойки. Разбиение на степени двойки единственно. Поэтому представление единственное.
Внутри они могут конечно перемешивать с точки зрения элементов там как угодно. Вот здесь у меня
сколько элементов сейчас? Три, четыре, семь, восемь. Восемь, один, двенадцать. Тринадцать. Тринадцать
элементов. Вот. Ну для тринадцати вот отдельное разбиение. Да. У нас не бывает неполных. У нас
каждое дерево оно является определенным рангом. Вот. То есть у вас когда есть определенное количество
каких-то элементов вы точно можете построить биномиальную пирамиду в единственном виде с точки
зрения рангов. Да, это правда. И мы можем это использовать между собой. С чем? Для того, чтобы
понимать, что у нас всегда будет в результате при любых мерджах и так далее какая-то одна
общая структура понятная нам, которая нам необходима. И теперь какие есть операции для биномиальной
пирамиды? Ну первое это get минимум. Как мне взять минимум? У меня есть указатель. И это я могу
вытащить этот минимальный элемент. Не вытащить в плане экстракт сделать, а просто понять какой у
меня элемент минимальный за от единички. Поэтому указатель. Согласны? А теперь давайте смотреть,
что нам делать дальше. Как нам жить с мерджем? Вот у меня есть две биномиальные пирамиды. Как
вообще с ними что-то делать? Здесь у меня есть такая пирамидка и будет еще какая-нибудь. Мне
надо их слить между собой для того, чтобы получить опять одну биномиальную пирамиду. Вот. А я предлагаю
отталкиваться сначала со следующим вопросом. У вас есть два каких-нибудь дерева одинаковых рангов?
Вот у вас есть дерево, не знаю, ранга там пять и вы хотите его слить еще с одним деревом ранга
пять. Что мне делать? Ну вот у меня здесь один, здесь пять. Дальше что? Да, и я получаю вот таким
вот образом тебе дерево ранга шесть. Согласны? Окей, хорошо. Это первое. А дальше как из этого
получить, что я хочу склеить две пирамиды? Да, все правильно. Смотрите. Повторю на всякий случай,
если вдруг не услышали. Когда у вас есть биномиальные пирамиды, вот их ранги это по факту
в какой-нибудь степени двойки. Вы можете это использовать для себя. Для себя в каком плане? Ну,
представьте, что у меня есть, не знаю, биномиальная пирамида фактически с нулевым первым и третьим
рангом. У меня есть третий, не знаю, там второй и нулевой. Вот когда вы складываете вот эти
чиселки, толбик, вы как их складываете? Вы складываете и переносите что-то в больший разряд. Вот,
и получаете фактически ровно как с двоичными числами, что вы сложили два одинаковых разряда,
получили следующий. Фактически здесь будет ровно это же. Вам необходимо просто взять это и
перестроить под это, то есть соединять их между собой корректно, тогда вы получаете новые пирамиды
и после этого переходите к следующему уже рангу и смотрите, что происходит там и так далее. И в
зависимости от этого у вас происходит сложение. Грубо говоря, вот здесь вот у меня есть 0.1.3 и 0.1.2. Вот,
ранги у пирамид. У первой 0.1.2, у второй 0.1.3. Что я делаю в начале? Я складываю две пирамиды,
мерджу между собой, ранга 0. Я это умею, мы только что показали, как это сделать. Соединить
меньшую, соединить больше к меньшей, присоединить. Я получаю пирамида ранга 1. Дальше у меня есть две
пирамиды ранга 1 и еще третья получилась. Но я могу сложить хоть те, хоть те, тут без разницы. Но
предположим, что я соединю те пирамиды, которые у меня были изначально. Получу пирамиду ранга 2.
Таким образом, у меня есть уже пирамида ранга 1, есть пирамида ранга 2, которая у меня, грубо говоря,
в уме где-то находится. И у меня еще две пирамиды ранга 2 и ранга 3. Значит, у меня есть две пирамиды
ранга 2. Я их также складываю между собой, получаю пирамиду ранга 3. И я ее складываю еще раз с деревом
ранга 3. Не пирамида, дерево, sorry. Вот. И тогда, когда я сложу две по три, получу четыре. Таким
образом, у меня получится биномиальная пирамида, в которой будет только лишь ранг 1 и ранг 4. Понятно,
что я делаю? Представляете, как это реализовывать? Не понятно, что я делаю? Очень неинтуитивно. Ну,
давайте на каком-то примере разберем. Не знаю. Но это и должно быть представлено, как в степени двойки.
Давайте порисуем пирамидки. Ну, в принципе, сейчас я думаю, ну, давайте даже нарисуем пирамиду ранга
3. Может, у нас что-нибудь получится. Арите, первая пирамида. Ну, называйте числа. Что я могу тут
сказать? Называйте числа, будем складывать на примерах. Сейчас, давайте. А, ну, хорошо. Давайте
я сначала нарисую всю пирамиду. Что у нас там? 0, 1, 3. И 3. Такая вот пирамида. И мы ее складываем
с другой пирамидой. Раз. Теперь называйте числа. Три вижу. Семь. Девять. Да, не забывайте,
что это должно все-таки... Здесь пирамидки сохранить. Минус один.
Четыре. Дальше. 57. Ну, давайте что-нибудь не такое. Ну, ладно. Очень хочется, пожалуйста. Дальше.
Не могу. Два. Да что ж такое-то? Четыре. Девять. Так могу. Ты серьезно? Десять. Хорошо. Десять.
Окей. Сохраняется тут свойство пирамиды везде? Сохраняется. Давайте сюда. Ладно,
я вас понял. Один. Три. Восемь. Два. Семь. Три. Девять. Хорошо. Отлично. Что здесь будет... Да.
Вот это и вот это по отдельности. Да. Еще раз. Сами кусочки – это деревья. Ну,
одинарная может быть. Да. Никто не спорит. Вот этот кусок, грубо говоря, может быть,
потому что разложение у нас может быть такое. Да. Да. Обязательно. У нас поддерживается
свойство пирамиды везде одинаково. Да. Да, это в определение зашито. Ну, давайте их складывать
между собой. Что я вначале делаю? Смотрю вначале на самый минимальный, ну, любые ранги. И получаю
вначале здесь следующее. Ну, возможно, мне тут доски не хватит. Ну, ладно. Я получаю здесь что?
Пирамиду, ранга, ну, дерево. Ранга один. Один. Три. Согласны? Получаю такое дерево. Теперь смотрите,
у меня есть 7,9, 3,8, 1,3. Какие сложимы между собой? Ну, давайте вот эти сложимы, ровно как там
на примере, чтобы вы могли ассоциацию построить себе. Хорошо. Я складываю 7,9 и 3,8. Что к чему
подвешиваю? Вот. Получаю здесь у меня 7, здесь у меня остается 9, а сюда уходит...
Извините, да, это уже я. 3, сюда уходит 8, сюда уходит 7 и 9. Согласны?
Отлично. У меня получилась пирамида, ранга два. И здесь... Отлично, мне их нужно сложить между
собой. И то где? Получается два. У нее остается все также 7, 3, 9. И дальше мы просто дописываем
этот кусок. 3, 8, 7, 9. Согласны? Отлично. Забываем теперь. Это пирамида какого? 3. Вот это мне
нужно сложить вот с этим. Это неприятно к ней. Ну, в смысле, переписывать это не прикольно. Но
итогом у меня будет следующее. Давайте я напишу 1, 3, а вот здесь сейчас будет много вершинок. Минус один у
нас наверху, поэтому я для него повторяю все, что у меня здесь есть. Это там что 2, 5, 4, 57,
а 4, 9, 10. И вот сюда уходит вот эта двойка, все что у нас было. 2, 7, 3, 3,
9, 8, 7, 9. Вот это у меня получилось две пирамида связанные между собой.
Показатель у меня в конце будет вот сюда. Понятно, что происходит? Да. А, в смысле это? Да,
конечно. Честь вопроса. Теперь стало понятнее, откуда у меня появилось вот это вот все. Да?
Понятно, как получилось пирамида ранга 1 и ранга 4. Можно.
Никак. То есть нет такого, что вот здесь все элементы должны быть меньше, чем что-то еще нет.
Они просто между собой существуют. У вас есть указатель на минимум. Указатель на минимум очень
легко в плане merge понять, какой должен быть минимальный элемент. Вы постоянно понимаете,
вы постоянно проходите по вершинам и смотрите минимальные элементы. Вы осознаете, что у вас
находится сверху. Так что здесь все достаточно просто и понятно с точки зрения реализации.
За сколько это будет работать, как вы думаете? А? Максимум из ранга. А если у нас N вершинок,
имеется в виду? За log N, да. Ну, почти за log N, а log N вот этого и log N вот этого сложить получите.
Вот. Потому что вы должны пройтись по всем. А степеням двойки здесь, по всем степеням двойки
здесь, грубо говоря, в худшем случае. Но это максимум, что вы можете сделать. Потому что,
когда у нас N вершин, я точно знаю, какое у нас разложение в степени двойки. Максимальное их
количество логарифм. Вот. Поэтому, да, если у вас в дереве P1 там N1 элементов, в дереве P2 N2
элементов, то вы получаете, что у вас весь этот мерч работает за от логарифм N1 плюс логарифм N2.
Просто? Почему? Выглядит красиво. Не знаю. Вот. А теперь смотрите, как мне реализовать все остальные
структуры, все остальные операции, которые у меня есть через мерч. Ноль. Ранга ноль. Да,
добавление элемента просто. Мы просто добавляем сюда пирамидку ранга ноль. Она уже может
являться пирамидой. Можно дерево сказать, можно пирамидой. Как удобнее здесь. Вот. Мы мерчим их
между собой, получаем общую пирамиду, все хорошо. Все просто. За сколько работать будет?
За лог. Да, за логарифм N просто. А то дерево, куда мы добавляем? Потому что логарифм единички,
но все-таки нолик. Вот. Это правда. Все достаточно просто и понятно. А теперь смотрите. Вопрос в
уменьшении ключа в нашем дереве. Наши пирамиды, я бы сказал. Вот у меня есть конкретный, не знаю,
какой-нибудь. Вот я хочу девять уменьшить. Вот я знаю, что я уменьшаю девять, я прямо на него
указываю, представляю, где он и так далее. За сколько у меня будет работать уменьшение? Как
его сделать? Ну да. А как мне это сделать? Просто сделать сифтап, да. Для восстановления
корректности это аналогично просто бинарной пирамиде. Нам достаточно сделать сифтап,
потом, если что, сделать еще один сифтап. Все будет хорошо. У меня вопрос. Что-нибудь может
нарушить такая вещь? Минимум нарушится? Ну подождите. Смотрите, я уменьшу это на 5, на 6.
Так, они поменяются местами. Ага, вот. Это важный момент здесь, это правда. Что нам стоит делать в этом
случае? Менять местами неприкольно. Просто менять указатель. То есть нам нужно пройтись по всем
нашим вершинкам. Отлично. Да, все правильно. Нам достаточно просто посмотреть на минимальный,
который был, на тот, который стал, если вдруг мы дошли до корня. И тогда в этом случае, если что,
поменять этот указатель. Просто? Вроде просто. Понятно, что я сделал? Или непонятно, чего делать?
Или вообще непонятно, что мы тут делаем? Давайте так. Это тоже принимается. Мотивация не ясна. Ну
почему не ясна? Смотрите, я хочу, чтобы вот эта табличка выглядела лучше. Ну пока,
пока может быть и нет. Хотя смотрите, за сколько мерч работает? За сумму логарифмов. А у нас уже,
да, у нас было до этого не было суммы логарифмов. Улучшилось ли? Ну, улучшилось. Окей, с декриз понятно.
А что нам делать с удалением? Вот я экстракт Мин делаю. Как вы думаете? Мы это обсуждали в мерде.
Ну давайте еще раз. Смотрите, мы каждый здесь складываем между собой, за вот единицы получаем
новую пирамиду. Согласен? Сколько здесь, если у меня здесь вот n1 элементов, сколько здесь может
быть деревьев? Не больше, чем логариф. Ну, аналогично здесь. Ну, складывая вот это все,
получил логариф. Как удалять? Экстракт Мин, да. Все правильно. Смотрите, что нам сейчас только что
сказали. Сказали нам следующее. У нас есть вот это. Есть у нас эта пирамида. Я удаляю вот этот минимум.
Что я могу сделать? Давайте рассмотрим две различные пирамиды. Первая пирамида,
только то, что я сейчас выделил, а вторая пирамида будет состоять из тех кусочков,
которые были здесь. Догласны с тем, что вот в этих пирамидах, ну вот в этой пирамиде все
ранги различны. Да, потому что они были предыдущие тоже различны. Догласны ли вы,
что здесь все различны? Это тоже логично, значит было бы странно. Вот, это тоже различны между
собой. Ну и тогда мы получаем, что у нас есть раз пирамида, два пирамиды. Мы мерджим две пирамиды,
получаем пирамиду. То есть то, что касается экстракт-мин, я здесь просто экстракт написан,
но суть такая же. Я просто беру, разделяю эти пирамиды между собой и мерджаю. И этого достаточно,
чтобы это сделать. То есть смотрите, все построено на одном лишь мерджа. Ну get-min не построено на
мерджа, хорошо. Там типа все просто. Все остальное построено на мерджа, поэтому все достаточно
очевидно и понятно работает между собой. Сколько будет работать экстракт? Ну у меня вот в начальной
пирамиде было n элементов. А? Хорошо. А rank может быть больше логарифма?
Или может? Почему не может быть логарифм rank меньше логарифма? Почему всегда rank меньше логарифма?
rank я имею в виду, который вот здесь у меня k есть. Ну можно так, но действительно смотрите,
у нас здесь n элементов. Мы с вами доказывали, что rank равен логарифму n. У нас не может быть
здесь больше, чем n элемент. Согласны? В начальной пирамиде было n элемент. Очень вряд ли их
вообще стало n-1. Вот. Поэтому здесь грубая оценка. Здесь за логарифм, здесь за логарифм. Ну здесь
точнее n элементов, здесь с n элементов. Максимум, который возможен. Ну значит мердж работает за два
логарифма n. Согласны? Вот. Ну получается логарифм. Да. Лучше всего да. Здесь скорее вопрос не о памяти,
а о скорости. Вот. Да. Да. Ну, например, 3. У дерева нет 2 по деревьям. Смотрите, вот у нас,
вот это дерево. Ну такой треугольник, конечно, получился, но все же. Это дерево. Дерево ранга
4. Ну вот там вот 3 получилось, значит ранга 3 была. Если я удалю корень, сколько у меня появится
под деревьев? Вот. Чего вопроса? Уходите от мысли, что в дереве всего 2 потомка. Поздно. Первый
семестер закончился. Вот это. Ну нужно воспринимать чуть-чуть это по-другому. Можно. Вот здесь
будут 4 ребенка. Да, если мы удаляем минус 1. Вот здесь 4 мерджа. Не, мы не каждая по дереву,
мы между собой их связываем. Они ж являются, они ж. Да. Ну у них же у всех разные ранги. Разные. Ну
нет, я их связывать могу очень быстро, это несложно с точки зрения реализации. Здесь вопрос
скорее реализации. С точки зрения смысла все просто. Поэтому это получается пирамида. Там пирамида,
все хорошо. Вопросы? Теперь все понятно про пирамиду биномиальную. Отлично. Получаем уже такую
табличку. Поинтереснее стало? Ну чуть-чуть поинтереснее стали. А теперь мы переходим к фибоначевой
пирамиде. Что это такое и как вообще с этим жить? Я понял, что из-за того, что я делаю презентацию,
я достаточно быстро рассказываю. Поэтому, либо я просто не рисую так много, как это делают на доске,
иначе было непонятно. Но вы если что останавливаете, пожалуйста. Про фибоначевую пирамиду. Смотрите,
ну сначала мы определим, что такое фибоначевое дерево. Смотрите, фактически это то же самое,
что биномиальная, но есть один нюанс. Фибоначевое дерево ранга 0 это одна вершина. Фибоначевое дерево
ранга K это корень, к которому присоединены фибоначевые деревья ранга больше либо равных нуля,
больше либо равных единиц и так далее. То есть у него K детей, но эти ранги могут быть больше либо
равны чему-то. То есть если у тебя есть там, не знаю, 5 детей, то это не означает, что 0, 1, 2 и так далее идет.
Почему? Потому что у вас в фибоначевом дереве могут быть помеченные деревья. Помеченные деревья
означают следующее, что у вас не будет какого-то одного ребенка. То есть оно фактически выглядит
ровно так же как было. Как было у нас? У нас было следующее, что если у меня это ранга K, то у него
есть 0, есть 1, есть 2, ну деревья и так далее. K-1 и все это является тоже биномиальными деревьями.
Было такое? Только что было. Что означает помеченное фибоначевое дерево? То есть смотрите,
деревьями фибоначи не только являются вот эти вот кусочки, но представьте, что одного сына просто
забил. Ну все, минус один сын, грустная история, но что поделать? Такое тоже бывает с деревьями.
Важное уточнение. Нет, сейчас, это неправильно. Больше либо равно K-2. Почему? Это не больше
либо равно K-2? Оно сделано здесь больше либо равно K-2 для чего? Потому что количество детей K-1.
Ранги сами по себе различны, но вот типа один из них может быть выкинут. Какой вот этот вопрос?
Понятно, то есть у меня становится уже не K детей, а K-1. Я выкинул любого рандомного сына у этого
дерева. Да. Одного. Два нет. Здесь мы считаем, что да. Ранги не совпадают. То есть та же самая
фибоначевая пирамида. Ой, господи, пибоначевая пирамида, извините. А то же самое биномиальное
дерево, просто где некоторые деревья могут не иметь одного какого-то ребенка.
Понятно? Это вот такой вот прикол здесь добавлять. Сейчас будем понимать, для чего вообще это все сделано
и зачем мы можем так делать. Какое есть интересное свойство для фибоначевого дерева? Ну смотрите,
минимальное количество элементов в фибоначевом дереве ранга K, если оно равно NK, то оно больше
либо равно, чем FK. F это фибоначевое число. Число фибоначевого. Понятно? То есть для ранга K у нас есть
FK. Ну как это сделать? Ну это сделать достаточно просто по базе ну как бы нулевого ранга. Одна
вершина первого ранга. Почему у меня там написано 1? Потому что может быть помеченное дерево, все
правильно. То есть смотрите, что такое фибоначевое дерево ранга 1? Это либо вот это, либо вот это,
потому что вот эту связь я убил. Я могу избавиться от одного стына. Вот я избавился. Да.
По сути, да. Нет. Но это если выкинуть именно максимально, не обязательно он выкидывается.
Сейчас еще раз. Подожди. Давай еще раз. Допустим у нас есть дерево ранга K минус 2. K плюс 2. Есть.
У него должны быть все дети. Есть ребенок ранга K.
Но это будет еще одно ранга K. Вот здесь смотрите, оно считается, что это различные сами по себе
деревья вот в нашей голове будут. Мы убрали это все. А? Ну фактически, если относиться к рангу именно
по количеству детей, то это обязательно такое произойдет. Если убирать именно такие, то да. Вот.
Такое возможно. Вот. Ну а теперь смотрите, что касается перехода. Переход здесь достаточно простой.
Вот у меня есть какое-нибудь дерево ранга K. У него много-много детей. Ну и вот только что как раз то,
что ты нам рассказывала, я и сделаю здесь. То есть у меня есть ранга K минус 1, который я помеченный
могу сделать и из него что-нибудь выкинуть. И это получится дерево ранга K минус 1. Ой, K минус 2.
Ну то есть я из него еще что-нибудь повыкидываю. Вот. А есть все остальные. То есть я именно вот
этот кусок убираю. Оставляется здесь K минус 2. Sorry. И вот этот кусок. Вот. Я утверждаю, что одно из них
имеет ранга K минус 1, другое фибоначиваем деревом ранга K минус 1, другое фибоначиваем деревом
ранга K минус 2. А эти фибоначивают числа по предположению индукции. Н. Количество вершин.
Количество вершин в дереве ранга K. Да. Смотрите, я должен подпереть снизу. А согласны ли ты,
что если я уберу большее количество вершинок, то как бы я подпираюсь снизу? Ну вот. Еще есть
вопросы? Утверждение следующее, что если у меня есть фибоначивое дерево ранга K, то вот я K
зафиксировал. То есть если в нем сказать, сколько количество элементов, то есть количество вершин N,
K, оно будет больше либо равно, чем фибоначивое число KT. Понятно? У тебя в дереве ранга K
количество вершин будет больше, чем KT и число фибоначи. Ты не можешь сделать его с меньшим
количеством вершин. Понятно? Отлично. Теперь смотрите. Ну как бы фибоначивое число можно
ограничивать, ну тут здесь написано 3 вторых в степени K-2. Но это все достаточно просто,
хотите докажите. Ну как бы я говорю, что это больше либо равно, чем 3 вторых в степени K-2.
K, напомню, это ранг. Это число фибоначи. Ну как бы и что мне тут сделать? Ну вот это, вот это я
могу еще и прибить тем, что N-KT. Ну для чисел фибоначи есть такой прикол. Давайте назову это так.
Вы можете погуглить, посмотреть, как это доказывается отдельно. Вот у нас есть вот такая вот вещь. Значит,
у меня что там K-2 будет, ну если я прологрифмирую обе части, то?
K-2 там будет меньше либо равно, чем там логарифм трех вторых N-KT.
Ну я получаю здесь, что K у меня зависит логарифмично от количества элементов. Это пока понятно? То есть
у меня ранг зависит от элементов с помощью логарифма. Красиво, красиво, очень полезная
вещь на самом деле. Сейчас будем дальше доказывать. И сейчас мы встретимся с тем, о чем мы будем еще
потом чуть-чуть попозже поговорим. Это называется амортизационный анализ. Он здесь опять нам пригодится.
Но перед этим, что такое вообще фибоначевая пирамида? Ну вот мы с деревьем сейчас посмотрели,
прозбирались. Фибоначевая пирамида это набор из фибоначевых деревьев и указательный минимальный
элемент. Причем корни всех деревьев не должны быть помечены. То есть корни выглядят как биномиальные
пирамида. Вопрос, что там внутри, вот это уже другой вопрос. Там может быть что-то уже помеченное.
Вот. И свойство пирамидов каждой из этих кусочков тоже должно поддерживаться. Какой здесь есть важный
нюанс? Чем отличается от биномиальных пирамид?
Мы можем повторяться. Рангами мы можем повторяться. То есть ранги у фибоначевых здесь деревьев внутри,
у каждого это может повторяться. То есть у пирамид биномиальных мы требовали, чтобы ранги были различны.
Здесь нет такого. Здесь мы можем, смотрите, здесь у меня фибоначевая пирамида 1, фибоначевая 2,
фибоначева 2, дерево ранга 2, 3 и 3. Могу так сделать? Да могу. То есть с фибоначевым пирамидом такое
возможно. И здесь очень просто понимать, что вообще с этим всем делать. Нам нужно сделать какие-нибудь там
операции на фибоначевой пирамиде. Ну get минимум, как сделать? Но у меня есть указатель на минимум, я
все так же сделаю get минимум, завод единички. Согласны? Merge. Я не знаю, вы прочитали или нет?
Прочитали. Что там написано? Конкатинация списка. Что это значит? Просто сливая между собой. Да,
смотрите. С Merge мы делаем следующее, что у меня есть первый список, есть второй список, давайте
их построим друг за дружкой. Получили наш ответ. Вот. С Merge эти два восхитительных, две восхитительные
пирамиды. За сколько это будет работать? За единицу. Я думаю вы понимаете, что список добавить к списку,
все просто. Еще раз. Сохранение минимума. У тебя есть указатель там, указатель там. Найти
минимум между ними несложно. Вот здесь, смотрите, хотелось бы, да, но это тоже можно реализовать
завод единички. Подумайте над этим с точки зрения реализации. Обязательно ли это такой вот прям
тотальный список? Или это массив указателей какой-то? Или это указатели, где у меня есть нулевые,
первые ранги и так далее. Подумайте над этим на досуге. Назову это так. Вот. А что касается
insert? Ну, insert делается аналогично. Добавьте фибоначевую пирамиду ранга ноль и вы получите
радость из того, как это получилось. Работает завод единички уже лучше, чем предыдущая. Заметьте,
то есть в предыдущем, смотрите, insert не работал завод единицы, merge не работал завод единицы,
getmin тоже работает завод единицы. У нас осталось что? Декриз и экстракт. Можно.
Как мы что? Ну, смотрите, а merge понимаешь? Ладно, давайте сейчас. Вот у вас есть две фибоначевые
пирамиды. Ну, давайте вот эту просто добавим сюда в конец. Я получу такой список из шести. Могу я
сделать это завод единички? Ну, вообще это никак не влияет. Вот здесь мы поддерживали это для того,
чтобы складывать их правильно, merge между собой правильно. А вот здесь, ну, здесь никак не влияет.
Это первое. Ну, а как сделать insert? Ну, что такое? Ты добавляешь одну вершинку. Ты
добавляешь одну вершинку, это фибоначевая пирамида ранга ноль. Ну, да. Добавь. Вот. Тоже
работает завод единички, да? Не за что. Можно. Как добавить список к списку? Да. То есть,
фактически, это списки, просто связанные между собой. Ну, вот это все является какой-то
ноды связанной. Ну, добавить быстро, это самое важное. Хорошо. А понятно, что я сделал? Вот. А
теперь давайте, знаете, фибоначевая пирамида не построена на каких-то гиперумных вещах,
кроме того, что это. Вот. Ну, типа, для того, чтобы прийти к тому, что это, это, ну да, это один свой
прикол. А вот предположим, что я должен сделать, да, decrease. Вот как самое быстрое сделать decrease?
Вот самое простое, что у вас приходит в голове. Представьте, не знаю, что у вас есть пирамидка,
ну, там что-нибудь еще. Вам надо удалить вот этот элемент. Что я сделать можно? Как это сделать
быстро? Да, я просто возьму, отрежу этот кусок. Ну, я же могу делать одинаковые ранги. И вот этот
кусок вынесу в новый. У меня появится, ну, грубо говоря, было там, не знаю, 5 пирамид. О, 5 деревьев.
Стало 6. Ну, в чем-то принципиально проблема? Нет. Это другой хороший вопрос. У тебя такой же был?
Отлично. Это правильный вопрос. Что делать с тем, что оно помечено? То есть, смотрите, если вдруг
вот это его родитель не является помеченным, тогда в этом случае я говорю о том, что я просто вот
этот кусок вытягиваю, сюда ставлю и помечаю вершинку. А вот есть вот этот? Ну, перенесу. Перенесу
и что-нибудь с этим должен буду сделать. Нужно подумать, что тут делать. Но в действительности
удалять помеченные не самая лучшая идея. Вот. Вопрос следующий. А что делать, вот типа,
если у меня родитель помечен? Ой, не, это долго. Давайте самое, самое простое, что есть. Давайте
вот тут отрежем. И это перенесем туда. Но у него что же тут есть? Продолжение какое-то, правильно?
Вот это? Продолжаешь дальше. Корень не может быть. Корень не может быть помеченным. Если
мы удалим и корень станет помеченным. Как ты это при себе представляешь? Есть очень простое решение
в этом плане. Всё такое можно делать. Но в действительности там не будет таких случаев.
На самом деле, когда вы просто отрезаете какой-то кусочек, который вы хотите удалить,
мы же удаляем здесь, правильно? Тут всё удаляем. Вот, точнее, уменьшаем, sorry, не удаляем, а здесь
у меня уменьшается. Вот. Для того, чтобы поддерживать, я неправильно говорил, простите,
не для удаления, а для уменьшения. Я же не хочу восстанавливать здесь всё правильно относительно
удаления, а к удалению мы сейчас вернёмся. Забудьте, что я сейчас говорю. С точки зрения уменьшения,
когда я хочу уменьшить что-то, мне нужно восстанавливать правильно пирамидку, правильно? Я просто
рисовал одно, говорил другое, могло быть немножко диссонанс. Вот я хочу здесь уменьшить, там, не знаю,
минус пять сделать. Мне фактически нужно повышать эту вершинку, делать сифтап. Это долго, это неприкольно.
Поэтому я просто отрезаю кусок и туда кладу. Вот. Но если вдруг у меня помечено, я выше иду и там
отрезаю, потом выше иду и там отрезаю, и так далее. Вот. То есть, я как бы уменьшаю ключик, отрезаю
этот кусок от своего поддерева, вставляю в конец списка. Хорошо, ну хорошо. Помечаю родители, не
могу пометить родителя, значит, родителя тоже отрезаю, добавляю в конец списка, всё хорошо,
уменьшаю только ранг у него на единичку. Из-за того, что я уменьшаю ранг на единичку, у меня всё
получается корректно, потому что у меня родитель, когда переходит вверх, ну, у него теряется сын.
Согласны? Этот кусок теряется. Могу я уменьшить на единицу ранг? Я уменьшаю на единицу ранг.
Нет, у нас было только вот такое. В этом и суть, понимаете? Оно снизу ограничено, не сверху.
Поэтому дерево ранга ка, может быть, ребёнок ранга ка. Никто не ограничивает здесь. Да. Нет,
мы идём вверх. У меня есть указатель, что я делаю меньше этот элемент. Я отрезаю этот кусок,
помеченный или нет. Если не помечено, то всё хорошо, я просто его помечаю. Если оно помечено,
то я такой. Значит, я не мог отрезать просто так кусок. Ну, давайте тогда отрежу его тоже,
потому что он ненужный, и уберу пометку, и сделаю ранг на меньшую единицу. Могу, так могу и так далее.
Если я ранг уменьшаю, я могу сделать эту пометку? Так его самого я не уменьшаю, у него сколько было
детей, столько осталось? А, если он был до этого помечен, то хорошо, типа сделаю ранг меньше на
единицу и пометь. Почему? Можем. Просто я этот кусок буду уменьшать. То есть смотри, у этого было
сколько детей, если он помечен? Ну, не знаю, там ка минус один. Я отрезаю ещё один, ставил ка минус два.
Могу я его выкинуть вверх и сказать, что у него ранг теперь не ка минус один, а ка минус два? Могу.
Чего моя проблема? Чего? У меня всё, что должно быть в моём дереве, это вот это. Ну, у меня
стало меньше детей, согласен, что если до этого у него был ранг ка минус один, ну, уберу я одного
ребёнка, останется то же самое. Больше ебровно ка минус два будет уже всё. Будет такой? Будет,
конечно. Сомнительно, но окей, да? Вот такой примерно. Вот, это хорошо. А сколько таких
деревьев? Много. Согласны, что у меня слишком большой список получается? Есть такое. Неприкольно.
Ну, смотрите, типа, с одной стороны, декриз работает за сколько? За ранг. Давайте оценим.
Смотрите. Вводим ваш любимый метод потенциала. Давайте оценим, за сколько будет это работать.
Сколько раз мы вверх будем подниматься и как тут жить? Давайте введём потенциал, это количество
деревьев в моей вот этой цепочке, плюс два умноженные на количество помеченных деревьев.
Могу я так сделать? Могу. Чему у меня равно амортизационное время? Оно равно реальному
времени, плюс потенциал после и минус потенциал до. Согласны? Согласны. Вначале я такой, я прошёл
и вот типа дельта деревьев выкинул вверх. Вот типа вот это вот всё это дельта, то есть один плюс
вот этот вот кусок дельты, помеченных мной родителями, которые были помечены. Согласны?
Перехожу вверх. Вот. Это время t. Один плюс дельта. Дальше сколько у меня стало деревьев? В начале
у меня было t, я ещё сверху добавил дельту и плюс один вот этот кусок, который я сам выкинул вверх.
Согласны? Отлично. Сколько у меня было помеченных деревьев? Было помеченных м большое. Сколько я
выкинул помеченных деревьев и убрал метку? Ну согласны, что дельту? Вот я шёл вверх только на
дельту этих вершин. Отлично. То есть минус дельта и плюс один, потому что у меня ещё что? Да, потому
что я там ещё добавил помеченное дерево. Вот. Ну как бы 2m минус дельта плюс один. Чудно. А что было
до этого? Ну в самом начале было t плюс 2m. Ну там минус 2m, это в кобочке надо было взять,
я простите, тут не взял. Вот. Ну всё. Всё это вычитаем, получаем 4. Амортизационная константа.
Константа? Правильное замечание. Вот нужно думать, что делать с этим дальше. Ну то есть амортизационное
время декриза от единички. Давайте так. Показала вам, что от единички? У нас что осталось? Какая ещё
операция? Да. А? У фии минус первого нужны скобочки, это правда, да, я сказал это. Экстракт у нас
остался. Смотрите, если бы всё… Согласны ли вы с тем, что экстракт вряд ли будет работать за вот
единица? Была бы какая-нибудь киллерфича, типа, в виде этой афибоначевой пирамиды, почему? Я могу
сказать, что она работает не меньше, чем за логарифм. Как вы думаете, из-за чего? Худший случай. Ладно,
амортизационную могу показать. Она работает на самом деле не меньше, чем за логарифм и за
сортировки. Сортировка, построенная на сравнениях, не может работать быстрее, чем за НЛГН. Помните
такое было? Этот вот нижний барьер, который у нас есть. Если бы вдруг у вас фибоначева пирамида умела
всё делать быстрее, то есть всё за у от единички, то у вас была бы сортировка за у от Н. Ну,
потому что у вас всё в фибоначевой пирамиде работал бы за у от единицы. Ну, вы же минимумы
вытаскиваете просто и получаете сколько? Н минимумов за у от единицы. Ну, было бы за у от Н
тогда эта сортировка. Что странно. Такого быть не может. Поэтому хотя бы за логарифм, потому что
Н экстрактов, вот эти вот, которые у вас будут, они должны давать логарифм. То есть НЛГН минимум. Вот
как работает экстракт. Мы, кстати, даже с вами сегодня амортизационный анализ не успеем. Какой
кошмар. Ладно, ничего страшного, мы придумаем. А с экстрактом фибоначевой пирамиды. Смотрите,
как работает экстракт в этой фибоначевой пирамиде. Мы удаляем вершину и делаем мерч просто,
как в биномиальной пирамиде. Вот. Ну, все достаточно просто. Удаляем, ну, как бы вот ровно то,
что у вас было вот в биномиальной пирамиде. Вы раз, два, мерчите. Их мерчить можно подряд. За у от
единички. Согласна? А теперь смотрите. Для того, чтобы это не вырождалось все вот в эту большую
такую цепочку, как только у вас встречается экстракт, вы же все равно будете проходиться по всем
элементам для того, чтобы минимум найти. Согласна? Ну, потому что вам нужно вот протыкаться. Ну,
вы не знаете, минимум будет лежать здесь, здесь, здесь, здесь, здесь, здесь или здесь. Вам нужно
пройтись по всему. То есть это как минимум у от н. Вы не можете быстрее просто делать. Хотя,
в действительности это не у от н можно делать, а быстрее. Но у от н имеется в виду n это количество
пирамиды. Не у от н вершинок. Ну, если мы не будем их как-то склеивать, то да. Так вот,
вторым этапом вы все равно проходите по этим пирамидам. А давайте пирамида одинакого ранга
склеивать. Ну, деревья между собой очень легко склеивать и делать из них ранг побольше. Согласна?
За счет этого вы их постоянно укрупняете. То есть с помощью экстракта у нас идет укрупнение нашей
пей вот этой вот вещи, которая есть. То есть как только у вас не будет жуткого вырождения между
собой в такую вот цепочку. Понятно? Понятно, что я делаю с точки зрения склеивания. Ну, это на самом
деле легко хранить с точки зрения вектора с указателями на пирамида одинакого ранга. То есть
в В0 у вас лежит какой-нибудь вектор, в котором там находятся указатели на все пирамиды ранга 0.
Склеить между собой пирамида ранга 0, а потом добавить это в В1. И так дальше. То есть вы это
легко сделаете. И будем это делать. А теперь вопрос. Сколько будет работать экстракт? И что с
этим делать? Ну, мы введем все тот же потенциал. Оставим его ровно таким же. И экстракт как будет
считаться? Ну, смотрите. Вот что такое T, что такое D? D это количество вот здесь. T это первоначальное
количество деревьев. D это сколько остается в том, где мы удаляем этот минимум. Вот. Ну, мы их
склеиваем между собой, и нам нужно пройтись, найти минимальный указатель, который есть. Согласны? То
есть это 1 плюс T плюс D. 1 удалить, T по всему пройтись, D еще и тут пройтись. И там, и там
пройтись, найти минимум в вершинке. Так? Согласны? Узнали? Не знаю. Вот. Теперь смотрите. Пусть у меня
остался T деревьев. После того, как я прошелся T, я подразумеваю, что... Ну, я их склеил между
собой все. Поэтому у меня остался какой-нибудь там T штрих. А количество маркированных? Ну, 2M. У меня
как были маркированы, так и остались деревья. Согласны? Ничего я здесь критического с ними не
сделал. У меня все равно в... Здесь вот помеченные не могло быть. Если тут были помеченные,
ну, они остались и так далее. Мы их соединили, все хорошо. То есть количество помеченных деревьев
осталось такое же. Ну, и вот здесь у меня тоже не хватает скобочек, если что. Тут уж простите. Вот.
T минус 1 — это то, сколько было. Плюс D плюс 2M. Это как раз то количество деревьев, которое стало. Вот.
Сейчас я правильно посчитал? Да. Да. Вот. Phi минус 1. Ну, T минус 1 плюс D. Количество
деревьев. Вот. Все это сложив, я с вами получу, что у меня будет это все равно просто T штрих.
А T штрих — это что? А T штрих — это количество деревьев, которые у меня здесь есть. Да? А теперь вернемся
вот сюда. Согласны ли вы, то у меня количество элементов в дереве ранга K не больше, чем f от K?
Да? Был такое. Логарифм мы с вами получали? Получали. Чудесно. Вот. Поэтому количество, на самом деле,
вот этих деревьев, которые есть, вы же смёрзете все, что у вас будет, у вас все также получится
в степени вот эти двойки. Ну вот, у вас получится логарифм N. И экстракт работает амортизонно
за логарифм. И если мы по итогу посмотрим на все, что у нас есть, то у нас есть фибоначевая пирамида,
которая делает почти все за единичку, кроме удаления элемента. Удаление элемента работает
за логарифм. Все остальное работает за U от единицы. Но декриз, важно понимать, работает амортизонно
за U от единицы. Как вы думаете, вы хоть где-нибудь когда-нибудь встречали фибоначевую пирамиду?
Ой, ладно, там может быть, но очень вряд ли. На самом деле, фибоначевая пирамида очень имеет
огромнейшую константу. Очень-очень большую. И на каких-то адекватных данных фибоначевая пирамида
не умеет давать хороших результатов. То есть, вот эта U от единички, она большую константу имеет,
ну извините, вот эта вот C, которая у вас будет, если вы реализуете ее, вы увидите. И биноминальная
пирамида работает объективно лучше в этом плане. То есть, в контесте у вас не будет такого, что вам
нужно будет фибоначевую пирамиду полностью реализовывать именно в том плане, что она умеет
работать категорически долго. А? Ну это другой вопросик. Все может быть. Вот. Поэтому фибоначевая
пирамида это такой прикольный покемон в мире алгоритмов, я бы назвал, который в действительности
очень важен с точки зрения такой теоретической части алгоритмов. То есть, да, такие вещи
существуют. С точки зрения асимптотики это работает достаточно быстро, с точки зрения практики это
работает не очень быстро. То есть, важно здесь основать, что существуют и такие вот вещи. Но
иногда к результатам этого мы вернемся. Мы вернемся в этом в графах. Я вас прошу, за сколько что будет
работать, вы должны мне будет рассказать. Потому что в одном из алгоритмов это будет интересно и
полезно. Во всем остальном в действительности это больше такая теоретическая часть, которую я думал,
что я расскажу еще в прошлом семестре, но я вам там провел контроль. Вот. Поэтому в этом семестре вот
отдают дань, уважение тому, что есть. И, если не ошибаюсь, эту пирамиду придумал когда-то Тарьян.
Так что как-то так. Да, у нас время подходит к концу, к амортизационному анализу. Значит,
я вернусь на следующей лекции, возможно. Я очень кратко пробегусь на тему того, что у вас происходит
вообще в мультипликативной схеме. Так, ты хочешь уйти, все понятно. В мультипликативной схеме
о расширяющейся массива, динамически расширяющейся массива. Булат вам это показывал. Вы можете это
посмотреть. И если на следующей лекции вы мне скажете все, что все было понятно и нам это не нужно,
то это один вопрос. Если скажете, что если вас будет, да это, веду немножко хаоса,
40 процентов из вас скажут, что вы этого не видели. Если будет один человек, то будет грустно,
конечно, но там уж прикинем как-нибудь 40 процентов. А то мы это быстро с вами разберем. В любом случае,
если что, есть и моя лекция, еще записанная на лектории тоже, где вы можете это глянуть. Она
давно была уже сделана, но суть останется все равно такой же. На этом, в принципе, все. Давайте
сделаем фото и закончим.
