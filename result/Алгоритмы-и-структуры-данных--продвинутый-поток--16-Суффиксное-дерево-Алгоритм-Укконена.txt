Вот. Значит, что мы будем делать? Сейчас мы уже откажемся от полиндромов. То есть теперь мы уже действительно будем решать задачу поиска подстрок в строке уже в сардовой версии.
То есть на этот раз у нас есть текст. Значит, у нас есть текст. И нам очень-очень-очень хочется отвечать на запросы. Ну, самые простые запросы могут быть.
Дается строка П. Пожалуйста, за О от П. Ответьте, пожалуйста, входит ли она в текст Т, как подстрока? Да или нет? Ну, совсем в идеале, конечно, там... Ну, тогда, в самом деле, там можно будет потом докрутить и бегать вперед, что можно и получше, аж, скажем, найдите самые первые увлажнения, найдите самые последние, найдите сколько их там, ну и так далее и тому подобное. Вот. Ну, это уже такие мелочи-детали.
Вот. Пока давайте вот просто. Теперь вот давайте думать. Как же нам искать подстроки в строке? Да, на этот раз все. Мы забыли слово полиндромов. То есть полиндромы сейчас уже теперь становятся не причем. Что же... Ну, вот как же нам это можно было бы сделать?
Ну, первая идея, которая тут возникает, это... Вот, в общем, здесь у нас текст Т. Допустим, какая-нибудь классическая наша Аббатсабба. Аббату какая-нибудь вот. Аббаба, что ли? Ну, вот, в общем, так вот.
Вот. И тогда вот возникает такой вопрос. Как же, вообще, можно ли вообще завести структуру данных, в которой можно действительно такие запросы отвечать за ОАДП?
Ну, первая идея, которая возникает. Ну, давайте из всех подстрок... Вот, возьмем все-все-все квадрат подстрок и каждую за линию добавим в вор. Вот. Получается запкну.
Ну, на самом деле не совсем так. А почему? Потому что можно добавлять каждый суффикс. Да, совершенно верно. На самом деле, да, можно все подстроки не добавлять, а можно добавить только все суффиксы.
Потому что добавив суффиксы, вы добавите еще и все подстроки, потому что каждая подстрока это рефикс какого-то суффикса. Да. Соответственно, поэтому можно прямо этот ботчик и создать. А давайте его даже и создать.
Итак, что же у нас тут будет?
Вот, давайте так и добавляем. Вот я сейчас буду прямо все суффиксы добавлять. Так, а вот что у нас там? А вот савва.
Так, абаба. Да, сейчас нам будет очень тяжело, да.
Можно крестик там поставить. Что там еще?
Значит, Б, там А, что там дальше? Будешь так не делать, да. БА, СА, БА, АБАБА.
Так, что там еще? А, СА, АБА. Пока тяжело, но сейчас чуть полегче будет.
Так, что там еще? С, А, СА, АБА. А, тут все просто. АБА, АБА, АБА. Все нормально, да.
Так, что дальше? А, А, вот собственно АБА, АБА, АБА. Так, кум-кум-кум, развилка. АБА, АБА, АБА.
Так, что дальше? БА, АБА, АБА, АБА. Так, что дальше? Так, ААБАБА. Ой, так, погоди, что-то не то.
А, АБАБА. Так. Не все, это бага началась только с какого-то момента.
А, вот этот, да. Вот так вот. Так, что там дальше? ААБАБА, ААБАБА. Уже полегче стало.
Так, АБАБА. Так, АБАБА. АБАБА. Что там? ББАБА, ББАБА. Ну вот. Так, теперь просто.
Куда-нибудь вот сюда БАБА. БАБА вот сюда. АБА. Ой, вообще ничего не надо делать. БАБА. Ой, ничего не надо делать. А, ничего не надо делать. Ура. Ура, мы это сделали.
Как можно было ощутить в процессе, это работает за квадрат.
Как говорится, места много и времени много, например.
Теперь и нервы жалко. Ой, а мы взяли не ту же строшку, которая у нас была в прошлый раз, да?
Может, не ту же. А я взял ту же самую.
Теперь, значит, начинаем думать, где же можно процесс вообще оптимизировать. Если внимательно на это посмотреть, то мы замечаем следующее.
Что-то развилок мало. То есть, видите, на самом деле, видите, тут огромные длины вот этих вот цепочки.
А теперь заметим следующее, что у нас же это не просто цепочки, а ведь каждая такая цепочка, вот если мы откуда-то сверху идем куда-то вниз, то то, как мы идем, это под строка, правда?
И вы задаете естественный вопрос. А нельзя ли на самом деле построить вот то же самое, но давайте попробуем так. Попробуем построить вот абсолютно то же самое, но вот эти цепочки сжать.
Значит, как это будет вообще... Смотрите, сейчас мы берем... Синий у нас хорошо пишет, мы его не использовали. Вот сейчас давайте как бы так. Делаем то же самое, но хитрее, смотрите.
Ну, а первым давайте так. Строка у нас будет нумероваться с нуля, поэтому давайте я сейчас тут попишу 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. Вот.
Значит, давайте попробуем. Делаем абсолютно то же самое. Значит, делаем так, смотрите. Первое, что мы делаем, это создаем кой и добавляем в суффикс 0, 13. На нем мы пишем, так и пишем.
Значит, первым пишем, что это буква А. Ну, переходим к букве А. И что это соответствует под строке 0, 13. Да, нам будет очень удобно мерить под строку в виде полуинтервала.
Вот. Значит, я буду рыженьким все-таки подписывать буковки. Так, рыженьким или... Нет, давайте черненьким. Почему черненьким? Вот здесь я черненьким писал. То есть это я имею в виду, что на самом деле это ребро длинное.
То есть на самом деле я имею в виду, что оно очень длинное. Но реально я эти буковок не храню, а я их храню вот в виде вот этой подстроки и говорю, что это ребро имеет переход по букве А.
Вот. Теперь добавляем следующий суффикс. Ну, здесь все просто. Как его добавлять? Ну, по букве В искорбии перехода нет, поэтому получается так. Тут переход по букве В, тут мы пишем, что мы пишем?
Совершенно верно. 1, 13. Ну и тут вот это заклинание пишем.
Так. Дальше становится интереснее. Потому что дальше от саба, а баба. Так. То есть как бы в старом боли мы должны были пройти по букве А, убедиться, что перехода по букве С нет и ответвиться.
В нашем случае это нас приводит к нод, к тому, что придется в этом месте создать новую вершину.
Так. Ну придется подвинуть чуть-чуть.
Значит, получается, видите, переход по букве А и мы его распиливаем на два ребра. То есть первое ребро тут будет, ну получается, 0, 1, а тут будет получается, давайте поближе нарисую, 1, 13.
Вот. То есть тут имеется в виду буквы, я тут даже на будущее побольше нарисую, Б, А, С, А, Б, А, а-ба-ба.
Вот. И, значит, здесь произошло ответвление. То есть, видите, тут идет переход по букве В, а вот тут будет идти переход по букве С. И получается, что получается?
А, С, А, Б, А, а-ба-ба, а-ба-ба. И получается приятная вещь.
Ну и здесь мы, соответственно, по ребру пишем, что это переход 3, 13.
Вот. Все будет дальше.
Так. Ну ладно, следующее ребро будет очень просто. Это будет ребро по букве С, тоже 3, 13. И тут, соответственно, вот это вся цена.
А-ба-ба.
Ну, тут развилок, очевидно, не будет, поэтому можно как угодно писать.
Давайте еще следующий, давайте суффикс добавим.
Теперь дальше, а-ба-а-ба-ба.
Так. Ну и здесь идем А, Б, А, ой, надо ответвляться.
Значит, создаем новую вершину.
И получается здесь теперь ребрышка 1, 3.
1, 3.
Да. Видите, ну как бы, чтобы глубина была 3, поэтому тут вот 2 отсекаем.
А здесь уже решаем, что мы рисуем.
Раз у нас тут А, Б, А, то получается придется рисовать ребро на С, 13.
И переход этот будет, конечно же, по букве А, а этот переход по букве С.
И вот это ребро, кстати, автоматически становится ребром 3, 13.
Вот.
Значит, соответственно, А, Б, А.
Да, вроде как сюда мы ходить не будем, поэтому по барабану.
Так.
Что у нас дальше?
Где?
Вот.
Сейчас какое? Вот это?
Не-не-не, смотрите, не надо, на нем как раз С, А, Б, А, вот все правильно написано.
Видите, я не случайно точку именно здесь поставил.
То есть мысленно я как бы ее так же и поставил.
Вот. Ну давайте, ладно, еще раз эту операцию проделаем.
А, ну хотя ладно, тут уже чем дальше, тем легче, можно уже и до конца делать.
Вот, например, когда у нас тут Б, А, А, то как бы вот развилочка будет здесь.
А вот это ребро, значит, то есть это 1, 3, теперь 3, 13, и тоже 1, 3, обратите внимание.
Вот. А вот это ребро будет у нас, соответственно, тоже А, Б, А, получается тоже 7, 13.
В этом получается А, Б, А.
Значит, это буква А, это буква С.
А, ну и все, в принципе.
Вот. Ну и соответственно, что там дальше?
А, дальше вообще приятно. Теперь А, А, Б, А.
Теперь А, и тут ответвляться, а вершинка уже есть, это очень приятно.
То есть поэтому давайте просто берем букву А, пишем, что тут под строка тоже от 7 до 13.
Но придется ее тут, правда, писать немножко в другом порядке.
А, Б, А.
Ну ничего страшного.
Что не так?
Да, господи, тут, знаешь, я каждый раз думаю, что там может дальше не надо рисовать, но тут уже просто мало осталось.
Нет, ну реально, сколько там осталось? Что там дальше?
А, Б, А. Ну значит, вот это мелкое ребро придется попилить. Ну давайте покилим.
Видите, внутренние ребра, нет, в принципе, хороший пример, то есть показывает, что тут может происходить.
Так, тут будет 1, 2, тут будет 2, 3.
Переход по букве А.
А будет еще переход по букве В.
И этот переход будет такой.
На нем будет написано БАБА.
То есть что такое БАБА, БАБА, это под строка с 9 до 13.
Так, что там еще?
Так, это А, БАБА, теперь...
Ну ладно, придется.
Так, ладно, эту бабу придется куда-то сюда впихивать.
Так, давайте впихнем бабу вот сюда.
Так, это буква Б, это буква А, тут переход.
Под строка, соответственно, тоже 9, 13.
Переход по букве В, тут придется написать.
Так, значит, эту букву, значит, да, тут буква А, тут буква В, тут баба, тут баба, да.
Вот.
А, и эти под строки еще тоже придется там вписывать, что это 1, 2, а это 2, 3.
Вот так.
Ну что делать?
Так, теперь у нас, теперь надо просто добавить эту под строку.
Так, значит, пишем ответвление буква Б, тут получается 11, 13.
И тут пишем БА.
Не-не-не, все нормально, потому что на этом все.
Почему на этом все? Потому что А, БА есть, БА есть, А есть, все.
Да.
Нет, получилось чуть быстрее.
Нет, почему?
Ну, вот эти стрелочки не надо было в таком количестве рисовать, так что получилось быстрее.
Да, ну а синтетически, конечно, все равно есть ощущение, что это квадрат.
Прям ощущение.
Но с другой стороны, конкретно ребер есть подозрение, что я нарисовал значительно меньше.
Вот как вы думаете, вот давайте, сколько я ребер нарисовал?
Желательно синтетически ответить, сколько я нарисовал.
Почему?
Вот действительно, сколько ребер, или что, практически то же самое, сколько вершин вообще может быть в таком, такой сжатой версии?
Ну, не совсем.
Ну, скажем так, да, еще такое бывало.
Но в целом, если говорить, да, лучше правильно сказать так, что добавили еще, когда мы делили ребро, мы как бы удаляли одно ребро и добавляли два, вот такие еще вопросы.
Поэтому корректнее скажем так, на каждом шаге мы добавляли не более чем две новые вершины.
Почему?
Да просто потому что, ну, глобальный синтет, предположим, что еще тут надо было бы какой-нибудь суффикс добавить, мы тут что-нибудь припишем.
То есть мы до какого-то момента там будем идти, идти, идти, идти, и в какой-то момент, ну, может быть, мы так и дойдем, тогда вообще ничего добавлять не надо.
А может быть, нам придется все-таки ответвиться.
Тогда, если нам не повезет, и тут будет не вершина, мы значит ее тут создадим, а то одну вершину, и после этого создадим новое ребро в новый лист.
То есть это худший случай, потому что, может быть, нам ответвиться придется, как мы уже сказали, еще и в самой вершине.
Как мы убедились, такое может быть.
Ну, вот.
Это означает, что, действительно, количество вершин не более чем два модуль Т, ну, на самом деле, там, скажи так, если Т больше либо равно двух, то там не более чем два модуль Т минус один, на самом деле.
Ну, потому что ладно, то есть для длины, если строка длины один, у нее будет две вершины, но там, если у строки длины два, там будет максимум три.
Понятно, да?
Ну, потому что она будет, условно, либо АА, и тогда там будет две вершины, либо она будет АБ, и тогда у нее будет три вершины.
Вот. Ну, а дальше там поеду все там плюс две, плюс две, плюс две, ну и так далее.
То есть, таким образом, размер, то есть количество вершин, то есть не более чем два модуль Т минус один, при модуль Т, больше либо равно два, можно прямо вершины.
То есть приятная структура. То есть, по крайней мере, хоть памяти она требует линей.
Эта структура называется сжатый суффиксный бор.
Ну, название предельно логично, потому что, во-первых, это бор, во-вторых, суффиксный бор, потому что это бор построенный на суффиксах строки, и, в-третьих, соответственно, сжатый.
Потому что, да, мы его сжали, то есть все вот эти цепочки мы сжали. Да, вот это бы называлось просто суффиксный бор.
А вот теперь у нас тут сжатый суффиксный бор.
Вот. Заметим, что, да, это еще не совсем тот бор, но заметим, что он бы нам позволил искать любые подстроки в тексте Т, правда?
Ну, например, вот, предположим, чтобы с небес по факсу нам прислали подобное безобразие. Естественно, без вот этих черных символов.
Тогда вот мы бы искали, например, существует ли подстрока, ну, допустим, бацап. Как бы мы это делали? Делали бы это, вот в боре бы делали бы честно, шли бы B, A, C, A, B, ура, дошли до конца, нити не обвалились, значит подстрока есть.
Здесь будет то же самое, разница только будет в том, что мы можем теперь находиться не только в вершине, но и где-то посередине ребра. То есть сначала это будет то же самое B, A, теперь проходим по символу C.
И находимся в некоторой позиции. Вот в этом месте мы будем отобрять слово позиция. То есть потому что у нас каждое ребро теперь не длины, а теперь вот это ребро длины 10.
И мы будем говорить, что мы находимся, например, в 9 символах от финиша. Ну, нам будет удобно мыслить именно в символах до финиша, а не в символах от начала, хотя понятно, что суть одна.
То есть дальше теперь, когда мы думаем, можно ли пройти по символу A, теперь мы говорим, так, у нас есть подстрока, наше ребро это подстрока с третьего по 13, мы в 9 символах от конца.
Значит, какой там у него следующий символ? Так, 13-9, 4. Думаем, какой у нас четвертый символ в строке T? Ой, буква A. Все, значит, по ней можно пройти и мы по ней проходим.
Теперь мы находимся в восьми шагах до конца этого ребра. И перед нами пятый символ. Так, это буква B. Так, он совпадает со следующей буквой, поэтому мы ней проходим.
Таким образом, строка подсапки для этих подстроков. Если тут будет символ C, то мы говорим, так, следующий символ у нас шестой. Ну, там осталось расстояние 7, 13-7, 6, шестой символ A. Не совпадает с C, ой, значит, нет здесь прохода по символу C и, значит, такой подстроки у нас в тексте T нет.
То есть, видим, да, небольшой такой технический накрут, но, в общем-то, жизнь нам он сильно не портит, правда?
Более того, если бы еще и, вот, когда тут A, B, B и A, мы тут еще и помечали бы, что это там конец строчек каких-нибудь, мы бы там могли еще на этом дереве еще какую-нибудь динамику потом DFS насчитать и насчитывать там.
И уметь там поддерживать, что если это подстрока, то скажите мне, пожалуйста, где у нее самое левое обхождение, самое правое. Ну, понятно, да?
Ну, самое левое, потому что, типа, найдите, там, типа, самый глубокий лист у меня в пантере или, наоборот, самый не глубокий лист. Ну, не помеченный в вершинах.
Ну, тут, конечно, вот, да, есть маленькая техническая тонкость иногда, что, допустим, там некоторые суффиксы заканчиваются не в листе, но более того, мы сейчас на этом будем очень серьезно в алгоритме обращать внимание и этим пользоваться, кстати.
Вот. Но теоретически вам может там для своей задачи захотеться, чтобы все суффиксы заканчивались в местах.
Ну, делается это простым, естественным образом. Вы добавляете в конец диэзик. Ну, или доллар, или что вам там больше нравится.
Вот, как всегда. Тогда вы можете гарантировать, что действительно все, тогда действительно, что все суффиксы будут заканчиваться в листе.
Понятно, да?
Тут вот полукно, поэтому получается, что жатый суффиксный борт это такая красивая структура данных, которая могла бы нам очень так помогать.
Какие планы?
Вот. Она могла бы нам действительно очень сильно помогать.
Ну вот. Ну и сейчас самое интересное для нас будет это, конечно, как ее построить. Да. А ведь ее сложно строить. Мы же даже не знаем, что такое суффиксный массив.
Вот. Ну ладно, сегодня и не узнаем, в общем. Ну и тем более, что ладно, узнаем это суффиксное массив, по этой штуке вообще для нас так не строится.
Еще и за линию, а не за эти ваши инлогены.
Потому что, да, наша сегодняшняя ставка – построить это за линию. Вот. Вот, собственно, наша цель – это сделать.
Значит, каким же образом мы будем это делать? Делать мы будем это в следующем образе.
Значит, на самом деле строить дерево мы будем по-другому. То есть, именно вот мы не скучали сегодня, вот утром обсуждали, что мы будем строить дерево.
Значит, на самом деле строить дерево мы будем по-другому. То есть, именно вот мы не скучали сегодня, вот утром обсуждали, собственно, дерево полиэнтронов, потому что технология будет похожая.
А именно, мы будем настолько себе уверены, что скажем, что изначально строка Т – пустая, и будем к ней приписывать по одному символу и пытаться подмодифицировать наше дерево.
Давайте посмотрим, как это будет выглядеть.
Ну, в самом начале, значит, сейчас я еще раз попробую это построить. Получится квадрат, если не куб. Но, тем не менее, подход будет выглядеть следующим образом.
Смотрите, а давайте-ка, то есть, изначально у нас строка пустая, поэтому я заведу корень, и для удобства скажу, что суффикс номер ноль, ну, то есть, что такое суффикс номер ноль?
То есть, я буду говорить, что суффикс номер ноль – это суффикс, который начинается от голевого символа. Понятно, да?
Вот. И так. То есть, ну, изначально дерево будет выглядеть так.
Теперь начинаем добавлять буквы. Первый к нам приходит буква А. Вот. Что же происходит? По большому счету, значит, это означает, что к суффиксу суффикс номер ноль удлинился на букву А. Правда?
Так. Ну, мы находимся в вершине. Это означает, что из этой вершины, то есть, мы должны этот нулевой указатель сдвинуть по букве А. Нам нету воздвига.
Что мы тогда сделаем? Ну, тогда мы создадим новое ребро. Да, на всякий случай длинное. И скажем, что у нас тут будет такое ребро от нуля до единицы.
Переход по букве А. И оно будет соответствовать букве А. И этот нулевой суффикс теперь заканчивается где? Правильно, вот в этой вершине.
Но еще кое-что поменялось. А еще раз появился первый суффикс. И он будет здесь. Ну, пустой.
Дальше к нам приходит буква Б.
Ну, тут сложнее. Придется побольше нарисовать, потому что, видите, в перспективе эта строчка длинная будет.
Так, значит, буква Б. Ну, так что надо сделать? Ну, во-первых, у нас вот этот суффикс удлиняется, но на этот раз она находится в листе, и в него ходит ребро.
Поэтому все, что тут надо сделать, это мысленно добавить букву Б. Это мысленно делается. А немысленно вот эту единичку изменить на другой.
Обратите внимание, вот этот рыжий нолик, он тут так и остается. Как уже легко догадаться, этот рыжий нолик здесь навсегда.
Что приятно, если лист заканчивается в листе, то он навеки, он всегда будет заканчиваться в этом листе, где околя.
Ну, там, конечно, вот это ребро может подпиливаться, но сам лист от этого никуда не перейдется.
Так, теперь единичка. Так, надо теперь этой единичкой, она заканчивается не в листе, поэтому нужно из нее сделать переход по букве Б.
У нас нет перехода по букве Б, но придется завести.
И эта единичка теперь торжественно отправляется вот туда, причем навсегда.
И у нас получается буква Б.
Буква Б.
Так, и тут пишем, соответственно, тут мы пишем букву Б, тут пишем 1-2.
Когда вот и все, не в коем случае у нас еще булочка.
Что же нас ждет дальше? Дальше нас ждет буква А.
Так, ну поехали. Удлияем суффиксы.
Значит, что нам для этого нужно?
Так, буква А мысленно добавляем, и здесь уже немысленно приходится двоечку менять на троечку.
Так, добавляем букву А и тоже троечку.
А вот здесь, это заканчивается не в листе, следовательно, надо ее сдвинуть по букве А.
Но на этот раз мы ее сдвинуть можем.
И мы будем это делать.
Вот, вот примерно здесь. Да, она находится где-то на левре.
И троечка.
Что же дальше?
Так, ой, все весело будет.
Дальше будет буква С.
Так, ну значит, будем писать тут букву С.
И тут, соответственно, четверочку.
И тут четверочку.
Ну, соответственно, с буквой С. Но 0 и 1, они тут навсегда.
С этим мы ничего не делаем.
А вот с двоечкой начинается интересность.
Почему?
Да потому что мы хотим из этой позиции теперь перейти по символу С.
И у нас не получается.
Потому что тут нет перехода по символу С, как можно.
Что же делать?
Придется создавать новую вершину.
То есть распиливаем это ребро.
Вот, то есть А и, соответственно, БАС.
То есть тут пишем, что это 0 и 1.
А тут пишем, что это 1.
И создаем новое ребро.
Куда эту двоечку, собственно, и отправляем.
Отправлю.
Хоп, я ее больше тут не видел.
То есть когда у нас делается новый суффикс, и он заканчивается в середине ребра,
ну, в этот момент его еще неделя.
Потому что если бы следующая пришла бы буква АВ, мы бы его просто сдвинули сюда и всё.
То есть что мы делаем?
Вариант такой, мы храним текущие суффиксные дерева и для всех суффиксов храним, где они заканчиваются.
Но если они заканчиваются в листе, то, как оказывается, никуда из этого листа уходить не надо,
надо просто это финальное ребро удлинить на символ.
А остальные придётся вот двигать.
Мы их двигаем, обратите внимание, в порядке уменьшения длинных суффиксов.
Вот, значит, буква А, тут у нас буква...
Да, тут переход по букве Б, соответственно.
И тут переход по букве С.
Ну да, от трёх до четырёх получается.
И тут, соответственно, буква С.
Так, это ещё не всё.
Суффикс номер три.
Вот он.
Суффикс номер три.
Теперь сбегается буква С.
Ой, а буква С нету, что делать?
Но придётся на этом козе.
Помню я этот зелёный маркер, где был пункт.
Так, буква С.
И тут тоже получается от трёх до четырёх.
По букве С.
И тройба мы отправляем вот туда.
Опа.
А сюда... а здесь появляется четвёрточка у нас.
Так, ну поехали.
Буква А.
Так, ну поехали.
Так, ну придётся тут везде дописывать вот эту букву А.
И, что самое неприятное, потому что букву А мы дописываем мысленно,
и вот эти вот пятачки придётся везде нарисовать вместо четвёрочек.
Но при этом, а вот эту четвёрочку мы наконец сдвигаем вот сюда.
И тут получается пятачок.
Что происходит дальше?
Буква В.
Так.
И опять то же самое.
Опять надо мысленно нарисовать букву В,
и немысленно поправить эти пятёрочки на шестёрочку.
Но при этом, смотрите, эти указатели никуда не деваются, да?
Ну вот.
И тут возникает первая такая оптимизация,
в которой явно тут уже руки начинают чесаться девушек.
Вот в этих вот полуинтервалов всегда будет стоять цифра равная текущей длине строительства, правда?
То есть, поэтому первая оптимизация такая,
давайте раз мы навсегда тут напишем плюс бесконечность.
Это первая оптимизация.
Ну понятно, что плюс бесконечность, понятно.
В реальности вы пишете миллиард,
и когда вы тут пишете миллиард, вы рассчитываете,
что этот процесс запускается до строки длины не более чем миллиард.
Понимаете, да?
Вот.
Ну вот там, потому что вам придётся всё-таки мыслить,
потому что если вы находитесь вот где-нибудь вот здесь,
на этом блоке,
то вам придётся там говорить, что мы находимся на вот этом вот подстроте от 1 до миллиарда
и дофинишем где расстояние там миллиард минус там, я не знаю, миллиард минус 3.
И миллиард минус 3, это будет означать, что вы находитесь где-то в этой позиции.
Понятно, да?
Ну или там, миллиард минус 4, это будет где-то вот в этой позиции.
Ну или там миллиард минус четыре, это будет где-то вот в этой позиции.
Пока вы будете тут подходить, так как у нас тут вы... эти позиции никогда не доклонят к концу строки,
потому что конец строки будут от них убегать, поэтому как бы конкретные символы найдутся.
Так вот, вот идея будет помещать плюс бесконечно. Понятно, да?
Ну там по-разному. Можно так мыслить, можете мыслить темно, что в каждый момент времени это число равно длине,
длине строки, поэтому там, собственно, вы это в каждое время выясняете.
Но короче говоря, что приятно, теперь заметим, что вот эти 0, 1, 2, 3 вам теперь вообще брать не надо.
То есть вам теперь имеет смысл брать только суффиксы, которые заканчиваются не в месте.
Понимаете, да? А для этих символы приписываются, приписываются, но мысленно.
То есть поэтому я вам даже пометил, что мы будем перебирать суффиксы, начиная со четвертого.
Вот по случайному совпадению, видите, пятый суффикс тоже заканчивается не в месте.
Хотя насколько это случайно? Ну ладно, давайте еще порисуем, а потом посмотрим еще на тему случайных совпадений.
Давайте попробуем. Буква А.
Так, нет, погодите, я торопился.
Потому что четвертый суффикс и пятый мы еще не сдвинули его, обрадовались.
Значит, его надо сдвинуть по букве В, но сдвинуть мы его можем.
Ведь он находится на репре от одного до плюс бесконечности, с расстоянием на бесконечности плюс бесконечность минус два.
Так, ну и пятачок тоже можно сдвинуть. Куда его можно сдвинуть? Да вот сюда его можно сдвинуть.
Вот не сюда, а вот сюда. Ну и четвертый суффикс.
Дайте мне яича.
Буква А.
Так, ну как мы уже сказали, тут мы нарисовали ААА.
Но видите, кроме черного мы ничего не имеем. Синее рыжие остается на месте, поэтому все в порядке.
То есть по факту начинаем работать с четверочкой.
Так, надо сдвинуть ее по букве А. Можем ее сдвинуть? Можем.
Значит сдвинуть, ну и сдвигаем.
Так, можем ли мы пятачок сдвинуть по букве А? Можем.
Можем ли мы шестерочку сдвинуть по букве А?
Да тоже можем.
Ну и семерочка появляется.
Что дальше?
Так, дальше у нас будет буква А.
Так, тут начинает быть интересно. Начинаем перебор с четверочки.
Ну ладно, я тебе букву А докидываю.
Так, есть ли тут переход по букве А?
Ой, нету. Придется делать.
Придется, значит, распиливать, соответственно, это ребро на одно.
То есть получится у нас тут, как уже говорили, один-три, и тут от трех, да, той самой, плюс бесконечности.
Вот так.
Тут переход по букве С, тут переход по букве А.
Значит, мы тут пока рисуем только одну букву А.
И она будет у нас соответствовать, это какой у нас символ или седьмой, да?
Седьмой, плюс бесконечности.
И четверочка навсегда отправляется сюда.
Я тут буду даже помечать, что как бы мы теперь перебор будем в будущем начинать с пятерочки.
Понятно, да?
Вот.
Теперь пятачок.
Пятачок. Так, есть ли тут переход по букве А?
Опять нету, да? Что ж ты будешь делать?
Так.
И получается примерно следующее.
Значит, ну вот.
Ну здесь понятно, опять симпус бесконечности.
Буква А.
Тут у нас тоже буква А.
Ну здесь соответственно тоже.
Понятно, тут тройбан.
Тут один, три.
И пятачок отправляется в свой лист.
А мы его как бы отправили?
Так, шестерочка.
Вот куда угодно из нее есть переход, а буква А нет.
Что делать?
Ну, придется его рисовать.
Тут еще нам повезло, тут лекшина.
Это будет буква А.
Это будет тоже симпус бесконечности.
И что тут получается?
А, В.
И что-то еще получается, да?
Ну и тут соответственно буква А имеется в виду.
И рыженькая шестерочка отправляется.
Но, видите, это не значит, что нам сейчас тоже придется создавать новое ребро.
Потому что здесь по букве А у семерочки переход поднимется.
Шестерочку сдвинули.
Теперь семерочку.
Семерочку говорить надо.
Вот так.
Она идет сюда, шестерочка идет сюда.
Вообще как-то очень интересно пока получается.
Может быть это еще пока не так бросается в глаза.
Но давайте я еще букву Б добавлю.
Там же буква Б идет дальше.
Да.
Да, дальше идет буква Б.
Все переходы есть.
Но вообще получается очень интересно.
Обратите внимание.
Вот там, восьмерочка идет вот сюда.
Вот.
И девяточку сюда.
Обратите внимание.
Вообще как-то очень странно получается,
что если рассматривать, какие суффиксы заканчиваются в листах, а какие-то не в листах.
Но почему-то получается, что они первые несколько суффиксов заканчиваются в листах.
А потом находится какой-то первый, который заканчивается не в листе.
И все за ним тоже почему-то заканчиваются не в листе.
Вот возникает вопрос.
Это у нас тест такой удачный подобрали?
Ну, ты знаешь, что всегда будет? Почему?
Ну, что если у нас есть наибольший суффикс, который не в листе,
значит, что суффикс больше, у козыров это префикс.
Так, да.
Тогда если взять этот большой суффикс без первого символа,
это будет суффикс, у которого префикс это следующий суффикс нашего.
Ну, на самом деле, да.
И тот тоже не в листе, получается.
Ну да, ведь по большему счету заметим, что под строка, даже любая под строка, да?
Ну, можно так сказать.
Суффикс заканчивается не в листе тогда и только тогда,
когда есть больший суффикс, с которого он начинает, правда.
Или что, тоже самое.
Вот строка заканчивается не в листе тогда и только тогда,
когда у неё есть вхождение в тексте,
которое заканчивается не в конце строки Т. Правда?
Ну ведь, если у какого-то суффикса есть такое свойство,
у него есть вхождение не в конце строки Т,
то очевидно у всех его меньших суффиксов тоже такое свойство есть, правда?
Поэтому получается, что действительно, начиная с какого-то момента,
то есть здесь вот этот момент, мы будем этот момент так и называть, кстати,
max not suf, вообще not live.
Я прям в коде так и пишу. Ладно, в коде я пишу last not live, но last не правильно писать,
потому что он не последний. Он наоборот первый получается.
А, ну можно его first not live называть. Ну, выбирайте, как вам удобно.
Max not live, first not live.
Ну да, это называется да.
Да, генерал Реми, у вас есть претензии? Да. Какие? Тогда нет.
А зачем вы сказали да? Ну да, меньше букв.
Так, значит, что у нас? Ну вот, но тогда вытекает следующая идея.
Так, вот мы уже построили это дерево в тремя способами, два из которых строили шаты.
Значит, сейчас я все это собру и построю дерево еще раз.
Да, знаете, вот мы такие, это, конечно, немножко однообразно, но зато мы это делаем упорно.
То есть, знаете, это вообще хороший метод. Сделали что-то там, заметили, где тут можно пооптимизировать,
делаем так чуть-чуть оптимизировать, потом еще что-то заметили. И вот так сейчас постепенно мы это все и перейдем.
Так, смотрите. Сейчас я все это собру. Так, значит, что из этого стереть?
А, ну ладно, это корректное дерево, лучше его не стереть. Значит так, убираем.
Не, не, не.
И так. И так, давайте заново. И так те читаем. Добавим первую букву А сразу.
И сразу говорим. Так, вот у нас. Вот так. Переход по букве А, как всегда, ноль, сразу на этой срисуем эту бесконечность.
И получается букву А. И мы теперь говорим. Значит, теперь отличие у нас такое.
Я буду хранить только первый суффикс, только вот этот вот max.not.suff.
То есть этот max.not.suff равен единице. Вот этот он будет единственной у нас режим max.not.suff.
И куда он сейчас будет нас указывать?
Ну, это не риблекс. Нас интересует до первой списки суффикс, который заканчивается не в листе.
И нас будет интересовать, по сути, а где он находится. То есть если пройтись по суффиксному борту, по этому суффиксу, куда мы придем?
Ну, потому что он... Ну, max, потому что он максимально подлиннее. А так я предлагал first написать.
Давайте fst.
Так, ладно. Хотите, пишите fst. Я буду first писать.
Не такие длинные слова, чтобы тут экономить.
Так вот. Итак, первый суффикс заканчивается не в листе, потому что в корне.
Сразу видим, да? Ну, такое тоже бывает.
В принципе, кстати, заметим, что это так всегда будет, если строка заканчивается на символ, который больше нигде в этой строке не смещается.
Итак, дальше. Буква B.
Так. Есть ли переход из этого первого суффиса по букве B? Нету перехода. Придется рисовать.
Ну, мы рисуем, как всегда.
Вот видите, я этих рыжих указателей не рисую, поэтому дело идет быстрее.
Ведь я не пишу, если бы я черный не рисовал, было бы линейно, может быть, даже линейно быстрее.
Ну, первое отправляется к черту куда? А теперь мы говорим, так, второй суффикс.
Так, ну, второй суффикс, он уже неинтересный, он уже пустой.
Поэтому он тут не очень интересно. Он отправляется в корень, и на этом все.
Итак. Вот сейчас будет такой интересный случай.
Буква A. Есть ли переход из вот этого второго суффиса по букве A? Отчуда здесь.
Значит, этот второй суффикс... Так, вот, да, внимание, мы перешли по букве A, но перед этим, да, мы не забываем дописать тут еще буквы A, чтобы не догнать.
Понятно, да? Ну, легко заметить, что он тут может, они тут могут гнаться сколько угодно, но он до сюда никогда не дойдет.
Вот, потому что это ребро на каждом шаге будет удлияться на единичку.
Ну, а так как двойка заканчивается не в листе, то получается, и все остальные, как бы, дальнейшие суффиксы тоже будут заканчиваться не в листах, следовательно, ничего нового не появится, можно больше ничего не делать.
Удобно, правда?
Угу.
Все, пока. Все, неудобно?
Вот, что, когда ничего делать не надо, разве неудобно?
Ну вот, значит, дальше. Дальше будет интереснее.
Буква C.
Так, ну, придется тут пилить.
Потому что...
Нет, у нас переходы из двойки по буквы C.
Значит, так и пишем.
Три плюс бесконечность, тут приход C, тут приход B, кстати.
А, да, я забыл, что тут надо C нарисовать, тут C нарисовать и вот тут C нарисовать.
Так, двойки больше нет.
Сдвигаем first not lift на троечку.
А я тут C нарисую, да?
Так, теперь думаем, а можно ли его продлить на символ C?
Так, троечка где была?
Так, это была пустая строка, она была в корке, да?
Так, есть ли из этого корги переход по символу C?
Ой, нету.
Пусть придется брать из этого корги, рисовать переход по символу C.
Со спонтанкной комбинацией.
И получается...
И троечку получается first not lift сбегаю,
но на этот раз, видите, этот first not lift обогнал уже даже символ C,
поэтому он отправляется в корень.
Вот видите, каждое нетривиальное действие,
то есть там типа распиливание вершины и создание нового ребра,
там распиливание ребра и создание там вот этого,
получается, мы оплачиваем, по сути, с двигом вот этого ребра, правда?
Вот давайте поэмулируем этот процесс еще.
Буква A.
Так, четверочка сдвигается сюда.
Вот.
Четверочка сдвигается сюда,
а тут везде приписывается буква A,
но они приписываются, напоминаю, мысленно.
Так, дальше буква B.
Так, тут приписывается буква B.
И... переход идет.
Вот этот четверок я теперь вот сюда оплазываю.
Дальше приписывается буква A, повторяется то же самое.
Видите, прям буквально вот прям, милые вот единицы.
Ну, конечно, да, такие быстрые вот единицы, это, конечно, предвестник какой-то амортизации, да?
Вот.
И теперь снова буква A.
Так, ну, поехали.
Коррихона по букве A нет.
Значит, распиливаем ребро.
Так, что тут у нас?
А, во-первых, я забыл тут единицу нарисовать.
А тут 0,1.
Тут, соответственно, теперь будет 1,3.
А тут край-бан.
Значит, да, из этого места мы теперь пилим переход по букве C.
Тут переход получается 7 плюс бесконечность.
Вот.
И, соответственно, тут буква A.
Четверок прищезает.
А вот теперь немножко магии, да?
Так, теперь пятачок.
Так, то есть у нас был суффикс BA.
Где заканчивается суффикс BA?
Где-то вот здесь.
Есть ли из этого места переход по букве A?
Нет.
Значит, придется в явном виде опять пилить ребро.
И рисовать переход по букве B.
По букве A.
Так.
Значит, пятачок сдвигаем.
Теперь у нас шестерочка.
Так, шестой суффикс.
Раньше был буквой A и заканчивался здесь.
Есть здесь переход по букве A?
Опять.
Слава богу, хоть вершины и на то совсем.
Ну, в общем, поэмулировали, поэмулировали.
Тут получается буква A.
Так.
Теперь следующий суффикс.
Следующий суффикс без этого символа.
Он был пустым.
И он смотрел вот сюда.
Есть ли отсюда переход по букве A?
У чуда есть.
Следует нас, значит, мы вот сюда его и проведем.
И на этом мы остановимся.
Вот, понятно, да?
Вот.
Ну, соответственно, можно это эмулировать дальше.
Но, я думаю, суть уже видна, правда?
То есть, заметим, что в принципе-то...
То есть, получается, алгоритм устроен так.
У нас есть first not leave.
Причем в лице позиции в этом суффиксном боле.
Правда?
Понимаете, да?
Угу.
То есть, прям вот в этом виде позиции.
Прям в этом суффиксном боле.
И тогда, получается, когда приходит новая буква,
мы говорим так.
В этой позиции можно пройти по этой букве.
Если можно, то проходим и не заморачиваемся.
Если нельзя,
то создаем, если надо, новую вершину
и новое ребро.
Понятно, да?
И берем этот суффикс,
отпиливаем у него единичку,
ищем, где он у нас в боле,
и повторяем операцию. Правда?
Понимаете, да?
В чём, казалось бы, заметим,
что каждый такой шаг
увеличивает нам указатель на единичку.
И из шагов, получается, мы будем делать ОАТН.
Следовательно,
наш алгоритм работает
за ОАТН.
Ну,
только если мы, на общем, находимся,
где же заканчивается суффикс.
Да. У нас есть только одна маленькая проблема,
которая не даёт нам возможности сказать,
что у Чудо мы победили.
А момент такой.
Вот, допустим, вы там нашли
вот этот длинный суффикс, он мог быть и длинный,
выяснили, что там пришлось тут лист
под него делать. Тогда надо от этого суффикса
отпилить единицу и найти,
где он в боле
находится.
Мы точно знаем, что
в боле есть, но вопрос где?
Вот, если предполагать, что нам
там говорят с небес
по факсу, где он находится,
то мы получили
корректный линейный алгоритм. Согласны?
Вот, если нам, вот.
Так что нам, как всегда,
остается просто извести небеса и факс.
Вы так себе смеётесь,
как будто я, я на предыдущих лекциях
эти слова сочетания никогда не употреблял.
В общем, я вас
помню, вы были, бывали у меня на лекциях вроде.
Ну ладно.
Это просто особый талант застрелять людей
каждый раз.
Соги хотели шутить.
Ну, правильно, правда.
Ну, так и надо.
Ладно. Так вот.
Ладно.
Вы сказали, что мы поддерживаем First New Peer.
Первую планицию,
от которой суффикс
не заканчивается в листе.
Да.
И мы, кто-то прикроет новый символ,
мы пытаемся сразу же
его продлить.
Ну, пытаемся
пройти по нему, по этому новому символу.
Если не получается,
то соответственно, правильно.
Во-первых, если это не вершина,
то создаём в этом месте вершину.
Во-вторых, от вершины создаём новое ребро
по этому символу.
Вот там с бесконечностью.
После этого берём вот эту строку,
в которую мы в эту вершину приходим,
отпиливаем от неё первый символ
и перемещаемся
в позицию соответствующую этой строке.
Вот видите, тут было вот A-B-A,
поэтому теперь мы перемещаемся в позицию B.
Вот у A-B-A
мы суффикс уменьшаем на единичку.
То есть, по сути,
первый символ отпиливаем.
И теперь надо найти,
где это B находится.
Мы могли бы это делать в тупую, конечно.
Да?
Да, прям рекурсивно, да.
Ну, не рекурсивно, а скорее
это вайли как-то.
Да, да, да, да.
И утверждают,
что с ума, но тогда у нас
трёсток некуда.
Указатель будет двигаться.
Не просто от N не более,
чем N раз.
Ничего удивительного.
Ничего страшного, что внутренних вершин
у нас действительно не более, чем N-1.
Считаю вот эту, правда.
Потому что у нас листов не более,
чем N.
То есть, сжатие привело к тому,
что каждая внутренняя вершина
хотя бы два ребёнка да имеет.
Ну, может и больше.
Вот у нас уже есть.
Поэтому получается, что да.
По сути, получается два указателя.
Это правого указателя добавляемый символ,
а левого указатель просто не двигается.
Да, по сути, да.
Левый указатель не двигается.
Ну да, то есть, видите,
всё-то в этих строчках, видимо, они одна и та же.
Что мы скажем?
Ну, когда мы распроизведем эту посетку?
Позицию.
Да.
Знаете...
Нет, можем даже,
чтобы, может быть, это...
Если честно, можем на самом деле даже
начать в этом месте код писать.
Да, ещё не всё понятно,
но, на самом деле,
основную магию.
Значит, смотрите.
Давайте-ка.
То есть, выглядит это будет,
примерно, следующим образом.
Давайте это я всё убираю.
Вот это я, наверное, даже не убираю,
потому что эти функции нам могут приведиться вообще.
Так, смотрите.
Страт 0.2.
Что мы будем хранить в вершине?
Ну, в вершине мы хранить немножко не то.
Ну, во-первых, да.
Так, ну ладно.
Давайте лучше это стру.
Поехали.
Что мы будем делать?
Во-первых, мы заведём,
ну, раз уж у нас таким режиме
это пошло,
страт позицию.
В этом позиционе
мы будем хранить всего два инта.
int
v
tu
Типа, в какую вершину мы идём?
Ну, в каждую вершину входит ровно одно ребро, правда?
Да.
И, соответственно,
dist2.
Ну, я, конечно, ту и ту.
Ну, я, конечно, ту и те лишние
не пишу обычно, но
я понимаю, нести пойдёт.
Страт позиции.
А что
мы будем хранить
в ноде?
В ноде мы будем
что нам понадобится хранить в ноде?
Так.
Ну, во-первых, конечно,
будет у нас такая
деревесная составляющая,
как переходы.
map
из char, как вы думаете,
куда?
Ну, тут уже сразу договориться.
Тут варианты могут быть разные.
Ну,
смотрите,
можно, конечно, сказать, что давайте выйти.
Да.
Но возникает такой ещё момент.
Нам же
в перспективе потребуется по позиции
восстанавливать символ, правда?
Поэтому, наверное,
для каждого ребра
где-то должны
вот эту вот подстроку хранить,
правда?
Поэтому давайте
в каждом ребре такое хранить.
int edge
edge l и edge
от замечательного названия вообще.
Это мы храним вершинкой.
Да.
То есть мы храним в ребро входящие.
Да.
Ну, можно так.
edge l и edge
edge
я пишу, что это имеет отношение к ребру.
Да,
можно, конечно, сказать, edge begin
edge end, конечно,
но edge l и edge
r, мне кажется, интуитивно понятно
должно быть.
Да.
То есть это полуинтервал l и edge.
Вот.
Ну, вот.
Ну, так.
Надо ли нам что-то ещё?
Ну, на самом деле ладно, кое-что
нам ещё не хватает.
На самом деле мы уже замечаем,
что нам же придётся ребро распиливать
как-то, да?
То есть у нас должна быть функция
типа возьми позицию
и создай в ней вершину, ну, если можно.
Ну, если это не вершина, конечно.
Но тогда по ребру
неплохо было бы на самом деле и родителя
звать, поэтому давайте так и напишем.
int
edge
Ну, типа полная информация уже
как до конца.
Вот.
Ну, вот.
Ну, и в общем-то всё.
Пока.
Вот.
Значит, далее теперь будем сделать.
Вот. Значит, такие доды создали.
Ну, в будущем я скажу, то для того,
чтобы вот делать эту чёрную манью с перескакиванием,
нам придётся ещё кое-что добавить.
Ну, пока же давайте разбираться.
Так. Ну, на этот раз давайте
может быть для ускорения процесса.
Да, вот мы быстро новообразились.
А, ну да, вот смотрите.
Эту пару процедур мы можем
даже особо не менять.
Хотя на самом деле
правильнее, хотя не совсем.
На самом деле они у нас
конечно немножко модифицируются.
Потому что, во-первых, они станут
ближенькими.
Так.
Хотя, знаете,
так.
А нет, ну парни, давайте сначала
поймём, что мы вообще храним.
Для начала мы замечаем,
что мы храним стрим С, конечно.
Дерево у нас
это, естественно,
вектор нодов.
Так.
И, как вы уже убедились,
ещё нам потребуется для хранения,
то есть ещё хранить
вот эту вот позицию.
Это важно.
Позицию
first not leave.
Вот я утверждаю, что больше ничего
хранить вообще не потребуется.
Понятно, да?
Так, в результате
получится лучше.
Сейчас будет немножко магии.
Так, далее.
Ну, во-первых, да, и нет, давайте
напишем сразу, чтоб не париться.
Ну, во-первых, да, void
finite.
Ну, ладно,
с венитом тут не очень, конечно, получится.
Ну, во-первых, понятно,
S равно
быть-пыть.
Nodes равно
там пока
единственные вершины, которые будут
состоять из чего?
Из пустого мата.
Угу,
пустого мата, совершенно верно.
Ну, вот так.
Или ноль пись бесконечности.
Минус один, минус один
напишем.
Знак того, что ну, не ведёт у нас в корень
вибра.
И ещё
минус один, знак того, что родителя тоже
нет.
Так, что там ещё?
Ну, и, наконец,
first not leave.
First not leave.
Значит, first not leave.
Так, ладно, давайте я тут
чуть подлиннее нарисую,
потому что
ну, а в first not leave понятно, что
мы идём в вершину ноль и находимся
от неё на расстоянии ноль.
Ну, потому что мы будем считать,
что корень никогда не является листом,
даже если у него нет детей.
Ну, понятно, что как только мы тут
первый символ добавим,
это у нас исходит. Понятно, да?
Ну, теперь давайте попробуем
подписать.
Сейчас, наверное, там всякие, не буду
писать мелкие инфраструктурные функции,
по дереву, по ледробу вы уже и так
поняли, как мы в принципе хотим писать.
Значит, поехали!
Теперь пришло время, значит, давайте
представим себе, что мы
добавляем новый символ.
Новый символ у нас будет
естественно, в чёртеньком.
Значит, смотрите.
Значит, дальше будет работа так.
Ну, во-первых,
давайте попушбэркаем, конечно,
этот символ у нас.
Вот так.
Вот так.
Вот так.
Вот так.
Вот так.
Вот так.
А дальше алгоритм устроим.
А теперь говорим.
Я так напишу, смотрите.
Значит, while что, соответственно.
Так сказать.
Я так напишу.
Ну, потом чуть-чуть под шаманем
будете готовы. Пока эта штука
валидна,
эта штука, в смысле,
краснотливка,
краснотливка, конечно.
And then
не
can grow
пока
мы, значит, не можем
из этой позиции пройти.
Партизим лучше.
Что мы делаем?
Ну, тут непонятно.
Эта позиция может быть вершиной,
может не быть, правда?
Ну да, поэтому, смотрите,
я в этом месте пишу так.
int
допустим,
new v,
новая вершина,
равно
build
new
v
build
node
if need.
Вот на месте этой позиции.
Ну, то есть в том плане, что
если мы находимся в вершине,
то эта функция ее тупо
в ее номере вернет. Если
что?
Из Формана?
Форман есть у Конин? Не знал.
В таком стиле.
Да?
Не знаю.
Не, ну, как сказать?
Ну, нет, ну, на самом деле, видимо,
это просто хорошая практика кода, когда вы,
в принципе, когда какой-нибудь сложный код пишете,
лучше на высоком уровне, так и там
какие-нибудь штуки, просто говоришь, я сделаю
функцию, которую потом буду думать позже.
То есть, прям, я здесь же
возможно пропишу, что я от этой функции хочу,
потом, когда я буду писать функцию, у нее
как бы есть интерфейс, я не буду думать о том,
что было это. То есть, ну, полностандартный метод
декомпозиции кодов, с которым мы уже встречались.
Ну, да и насяг, я думаю,
вы тоже с этим сталкиваетесь.
Так вот, значит, создаем эту вершину, просто
распиливаем ребро, никаких вот, ничего
дополнительного пока не делаем. Понятно, да?
Значит, что теперь надо?
Теперь нужно создать
новое ребро из этой вершины, правда?
Еще обратите внимание,
можно здесь это прям так и сделать,
ну, давайте я тут уже две строчки так и потрачу.
Ну, во-первых,
значит, я так и напишу,
смотрите, nodis
от newwe
.children
от
соответственно ch
Чего у меня будет равно?
Да!
Вот.
Ну, остается нам теперь только добавить
новую вершину!
Вот это вот. Nodes.
Как там говорили? Mplaceback, да?
Давайте.
Сейчас же опять улез вот тут.
Давайте pushback сделаем.
Мы же на русский пишем.
Нет, давайте скажем так.
Для сохранения отсылки того, что мы делаем, то же самое, что делали в дереве калибровых, лучше сделаем так же, как там.
Ну и не прикольно.
Давайте map, chartings.
Значит, push, push.
Так, edgeA у меня будет равно чему?
Подающие параметры, что я тут должен написать?
Ну, это мы с последнего символа начинаем.
Где n предыдущие для нас строки.
А сейчас?
Так, ну я тут опять потрачу лишние символы, потому что ретраж рад.
У меня привычка, у меня у строки длина, ничего не надо с собой проделать.
Да, можете написать size, если хотите.
Хотя ладно, иногда моя ретро радость была, что сложные задачи на строке, там, я и представители моего поколения решают с уфиксным деревом, а новое поколение приходит и говорит, сука, автомат наш и все.
Нет, у нас будет возможность их сравнить на самом деле.
Есть задачи, которые вот это решает автомат, нет?
Возможно, есть и наоборот.
А тут можно искать за корень?
Делать динамический слой?
Нет.
Что-то придинамическое?
Dynamic Diction Matching.
Пасем нас.
Ну это, короче, когда там добавляются строки, и приходят запросы, проверить, есть ли в этой строке все эти подстроки?
В текущей строке нет, ну слушайте, если у тебя запросы по pushback строку символы проверить, если такая подстрока...
Нет, если новые слова в словарь, нужно проверить, и приходится запрос какой-то текст, нужно проверить вхождение строк из словаря в...
Ну каждая, сейчас.
Каждый раз так?
Да, вот есть вопрос новый текст, и добавляю, и он еще может удаляться.
А, интересно.
И что, ты думаешь, что этот суп автоматом прям легко делается?
Ну вот, там есть такой человек, его зовут Филипп Грибов, который придумал, как это делать суп автоматом.
Надо подумать так, автоматом и за кой.
Там, типа, каждый раз добавлять новое слово в словарь сразу из корня, и потом сделать обход под автоматом.
Обход под автоматом.
Сейчас и все.
Ну, я не знаю, нет, просто, извините, за корень это делается, извините, хэшами и мапом.
Давайте для каждой длины слов из словаря сгонить мап хэшей, мап хэшей, все.
И когда приходит новый символ, переверяете корень различных длин, берете хэши и влезете в мап, проверяете, есть ли они, все.
Ну, наверное, да.
Особенно если у него в решении есть хэши, то как бы все.
Нет, если без хэшей, то ну окей, окей.
Ладно, будет интеграция.
Но для этого нам придется дожить до автомата.
Зачем нам еще в аэро?
Потому что у нас ферст нот лифт наш несколько раз может меняться.
Потому что когда мы вот это сделали, ферст нот лифт перешел как бы в следующий суффикс.
Оттуда переход здесь, и тут выясняется, что может тоже не быть, поэтому в аэро.
И еще эта валидность, потому что он может пройти по всем, дойти до корня, понять, что из корня тоже надо сделать ребро, сделать это ребро и перейти еще куда-то и стать всем самым невалидным.
Вот.
Поэтому я тут себе эту валидность и пишу.
Так вот.
Надо.
S.lens-1.
Ну, здесь мы пишем.
Inf.
И кто у нас parent?
Да?
А, ну да.
Ой, ой-ой-ой.
А ведь, смотрите, мы же еще кое-что забыли.
Мы же...
Так.
Так, погодите.
Сейчас.
Нет, ноль, погодите, что-то не то.
А, хотя нет, да.
А, ну да.
А ведь, на самом деле, теперь заметим, что еще кое-что повернуло.
А, ну ладно, будем считать, что у Нювы...
Да.
А, ну да, нет, мы будем считать, что у Нювы все корректно.
Поэтому, то есть, когда мы тут распиливали, мы тут эти все, там, вот эти LR parent переписали, естественно.
Угу.
Вот.
Так.
Ну и что теперь?
Ну, и нужно все остальное сливу на следующем суке поменять.
Ну да.
Ну, теперь, значит, будем говорить.
Ну вот.
А теперь, в общем, становится очень интересно.
Потому что дальше начинается магия.
То есть, только не фигуничай головой сколько-нибудь.
Где...
Да?
Ну, даже помочь сейчас.
Безобразие.
Хорошо.
И тогда, значит, теперь эта позиция...
Ну ладно.
Она, на самом деле, ссылаться на нее бесполезно, потому что эта позиция потеряла свой актуальный смысл, на самом деле.
Да?
Потому что в этом месте мы создали знание.
Поэтому, получается, оно равно...
Я такую магическую функцию напишу немножко.
И она может быть тоже...
Значит...
Erase.
First Symbol.
А в сколько я внезапно напишу new V?
Ну понятно, что имеется в виду.
Потому что, да, я, типа, беру путевую метку new V.
Ну понятие путевая метка сохраняется, да?
И хочу взять...
Так, если у меня есть строчка, я хочу взять строчку, отпилить первый символ и сказать так, а какова позиция этой строчки у нас в более.
И я знаю, что она есть.
Так.
Ну и в конце.
Если после этого, значит, эта позиция еще-еще валидна.
Если этот фест внутри валиден.
Так, что мы делаем?
First Not Leave равно...
Ну, здесь привязано.
Go.
Там еще, возможно, добавить новый ребро просто из корни не нужно?
Нет.
Нет, зачем?
Добавлять не надо?
А, я что-то забыл.
Нет, это еще не все.
L, Z.
Потому что, может быть, так, что вот...
Нет, почему?
Может, могло так случиться, что new V оказалась прям корень.
Из него мы добавили новое ребро и из него тоже перескочили.
Удалили первый символ.
Но ровно в этом месте как раз First Not Leave перестал быть валидным.
Поэтому я должен...
Если он перестал быть валидным, то есть мы даже из корня, то получается, что...
Ну, скорее всего, это произошло...
Ну, я утверждаю так.
Невалидным First Not Leave станет тогда и только тогда, когда добавленный символ раньше в строте не встречался.
В этом случае мы просто напишем, что First Not Leave будет тупо смотреть в корень.
Ну, давайте так и напишем.
First Not Leave.
Ну да, ровно.
Соответственно, напишем 0.
0-0.
У нас же эта парочка.
Ах, да.
Значит, тут напишем 0.
И расстояние до него тоже, естественно.
А, по-хорошему, и V тут тогда надо написать.
О!
Красота!
Ну, в общем, по модулю магии, зашитой в ArraySpecSymbol...
На самом деле, полгарита мукамина на этом заканчивается.
В чем-то достаточно легко убедиться, что, да, если магия работает от единицы хотя бы учетно, то, в принципе...
В общем, по алгоритму работает за линию, и что-то пишется даже не так страшно, как вообще могу показать.
Ну, нам еще надо реализовать isValid, canGo, buildNode, init и так далее.
Да, да.
Да, надо написать.
Ну, isValid, наверное, реализовать просто.
Ну, что по большому счету, ArraySpecSymbol, там будет написано следующее, что если эта позиция корень, значит, возвращаем минус один, минус один.
А в противном случае начинаем делать шамань, шамань, черный магию.
Понятно, да?
А что же это за черная магия?
Ну, кажется, нам пришло время...
Так, вот.
Чего нам пришло время?
Так, переливом нам пришло время?
Ну, полтора часа прошло.
Ну, давайте не выступим.
Итак, финалочка.
Что будет заключаться в нашей финалочке?
Вот, финалочка будет заключаться в том...
Вот, финалочка будет заключаться в том...
Финалочка будет заключаться в том, что нам нужно научиться уметь телепортироваться.
В чем?
Обратите внимание, значит, обратите внимание, что телепортироваться нужно только из вершины.
Нам нужно говорить, жила-была вершина, у нее есть какая-то путевая метка.
Ну, запятим, что приятно, кстати, что если мы создали вершину, то путевая метка ее уже не изменится никогда.
То есть конкретный путь до нее в лице последовательности вершин может поменяться.
Потому что там любое ребро может быть распилино, но путевая метка не поменяется никак.
Сросты?
Вот.
Внимание, вопрос.
Я так долго думал.
Вот.
Теперь внимание, вопрос.
Теперь надо вот взять, научиться у этой путевой метки отпиливать первый символ и понимать, куда ходить.
Для этого, так, какой мы еще контрастный маркер не использовали.
Так, ну ладно, пришло время, видимо, зеленого маркера.
Там придется ввести понятие суффиксная ссылка.
Суффиксная ссылка.
Суффиксная ссылка.
Вот.
Ну, хорошему надо было ее «суфф» называть, но ладно же.
Пишем полностью, так пишем полностью.
То есть действительно.
Значит, определение.
Давайте оправим, оправим, оправим.
Формальное определение.
Значит, суффикс линк от V.
От вершины V.
Где V.
Значит, V неравно к ворту.
Это.
Значит, такое вершине U.
Давайте вот в синеньком.
Давайте, да, будем рисовать.
То есть V и U это вершины, да?
В неравно к ворту.
Что?
Путевая метка U в суффикс.
Путевой метки от V.
Причем.
Длина U равно длина V.
Понятен принцип, да?
Понятен принцип, да, понятен принцип, да.
Такая радость получается.
И сразу возникает вопрос.
А всегда ли такая суффиксная ссылка существует?
Возможно, я немножко поторопился.
Поторопился вот в каком-то моменте.
По-хорошему, это определение, наверное, не вызывало бы проблем.
Если бы я сказал, что это не вершина, а...
Вот нет, не торопитесь переписывать определение, зачеркиваю.
Вот если бы я сказал, что это позиция.
Да, мы точно знаем, что если такая строка есть, то строка без первого символа тоже у нас более явной есть где-то, правда?
Но кто сказал, что это именно вершина, а не позиция?
Ну, вроде понятно.
Ну, она в какой-то момент была последней добавленной, значит, был такой суффикс.
Нет.
Ну, просто если у нас учекущая в этой вершине, значит, она либо... ну, понятно.
Либо в ней происходит развилка.
Но тогда, если там развилка, то без первого символа тоже развилка обязательно будет в этом месте.
А вдруг, если вы говорите о листах, а ведь может так...
Ведь на самом деле может так получиться, что на самом деле, во-первых, у листа это не лист, то есть просто у листа это не лист, но развилки, допустим, нет.
Не может так получиться. Вот, например, у строки ААА.
В смысле, что В это лист, а у... как бы...
А его суффиксная ссылка это не лист.
Нет.
Такое может быть.
А такое может быть, да.
Вот, смотрите, рассмотрим строку АААА.
Тогда заметим, у него единственный лист, и суффиксная ссылка у него ведет куда-то там все в это ребро.
Ну, тут в чем идея тогда?
Так В это суффикс, ну, то есть у это тоже суффикс всей строки.
Да.
Вот, и если мы суффиксный дерево достроили до конца, то это будет вершина.
Нет, ну, я кто сказал, что В суффикс?
В это вершина.
Никто не знал, что она прямо сейчас.
Когда-то она, конечно, с суффиксом может...
Кстати, может, она и не обязана.
Есть проблема.
Ну, если как раз В лист, то В суффикс.
Да.
Но самое прикольное... да.
То есть главное, когда мы его создаем...
То есть надо... то есть тут очень интересно.
Ведь когда мы создаем вот этот последний созданный лист, то суффиксная ссылка у него ведет фактически в ферстноутлиф.
Правда?
И получается, что эта суффиксная ссылка у этого листа будет постоянно меняться.
Потому что этот ферстноутлиф будет сдвигаться, сдвигаться, сдвигаться.
Меняться до тех пор, пока этот ферстноутлиф наконец не упадет, соответственно, в следующий лист.
То есть придется, получается, еще как-то под шаманью.
Поэтому мы поступим следующим образом.
Мы будем говорить, что В не только не корень, но и не лист.
Ведь действительно заметим, что нам по большому счету эта черная магия для листов не нужна.
Потому что наши ферстноутлифы по листам не скачут.
Понимаете, да?
В не лист.
А теперь представим себе, что вершина В, то есть итак, вершина В это вершина, но не лист.
Видно ли, что ее суффиксная ссылка это обязательно вершина.
Ну, если это не лист, то да.
Почему?
Ну, потому что раз в этой вершине, значит, на ней происходит развилка.
Да.
А тогда такая же развилка будет происходить и у вершины без первого символа.
Ну да, тоже да.
Что значит развилка?
Это означает, что мало того, что у этой строки как минимум два обсуждения,
значит, у нее два обсуждения, справа от которых находятся два разных символа, правда?
Кстати, если развилка тройная, это значит, что таких символов три.
Это понятно, о чем я говорю?
Так сказал бы Мартира Сяна, это называется.
Замечаете, о чем я пою, да?
Так вот.
А тогда если у этой строки ее можно как под строку продолжить хотя бы двумя способами разными,
то тогда если от нее отпилить один символ, то как минимум этими же двумя способами ее тоже можно продлить,
а то и больше способов, правда?
Может так случиться, что там еще дополнительные способы появятся.
Поэтому да.
Поэтому получается мистическая синяя теорема.
Вот вершивение.
Да, суффикс линк от V всегда вершина.
По крайней мере, в полностью составленном дереве это точно вершина.
Это даже при не полностью составленном это тоже вершина.
Поэтому это у нас именно Инт.
Я более того этот Инт даже вот теперь синеньким помечу в знак того, что это вершина.
На самом деле, да, тут надо.
Мистическая теорема.
Правда, есть одна.
То есть в идеале, по идее, так сказать.
То есть по идее можно на самом деле, вместо этой функции eraseFirstSymbol,
на самом деле можно теперь написать функцию.
Какую?
Ну, ту самую.
Суффикс линк от new.
Но у этой штуки есть одна маленькая подземь.
Дело в том, что этой суффиксной ссылки может в некотором плане не существовать еще.
Пример вот такой, вот, например, из последнего.
Вот, например, когда мы, вот, помните, мы здесь строили вершину, да?
Вот мы построили здесь вершину и скакнули из нее по суффиксной ссылке, да?
Мы скакнули вот сюда.
Да, суффиксная ссылка ведет, должна вести очевидно в эту вершину.
Но маленькая проблема.
В тот момент, когда мы ее строили, ее еще не существовало.
Помните, тут чистое ребро было.
Помните?
Или я не знаю.
Или я могу другой пример нарисовать.
Давайте представим себе, что у нас есть какая-нибудь строка там...
Ну, какая-нибудь вот A-A-A-A-A-A-A-B.
Смотрите.
Вот давайте где-нибудь, вот тут я ее порисую отдельно.
Вот как у нас будет все это выглядеть для A-A-A-A-A-B?
Вот как у нас будет все это выглядеть для A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A?
Ну что у нас будет происходить?
У нас тут будет вот это вот мысль о A-A-A-A-A-A-A-A.
В реальности будет только одно ребро вот это вот, да?
На там 0 плюс бесконечность по букле A из корня.
И, в общем-то, все.
Да, это бесконечность, это не 8.
Вот. И тот неожиданно выясняет, ну вот. И наш этот рыженький указатель, он указывает куда? Правильно, вот сюда.
То есть это первый суффикс, который заканчивается не в листе, он заканчивается где-то здесь, правда?
Кстати, это тот самый случай, когда он отчаянно пытается догнать лист, но никогда его не догоняет.
Ведь обратите внимание, если я добавлю сюда букву А, то это рыженький соответственный листочек.
То есть он как бы вроде переместится сюда, и казалось бы он пришел в лист, но нет, это не лист.
Потому что за секунду до этого тут добавилась еще вот эта буква А, без бесконечности. Удобно, правильно?
Вот. А теперь неожиданно пришла буква Б. Что делать?
Тогда получается следующее. Да, ну как-то ж алгоритм говорит, так, ну поехали, можно отсюда пройти по букве Б? Нельзя.
Так, хорошо, говорим мы. Значит так, это у нас буква Б, это у нас 0, 1, 2, 3, 4, 5, 6, 7, 8, да?
Да, 8. То есть получается пишем тут переход по букве А, то есть создаем новую вершину, переход по букве А от...
А, теперь интересно. 8 плюс бесконечность. Вот. Это 8, это плюс бесконечность.
Не перепутайте. Вот.
И что-то еще. И переход по букве Б, а ну здесь тоже. Нет, так не 8 плюс бесконечность.
8 плюс бесконечность это буква Б у нас. А, тут слишком много, да.
Да, тут 8 плюс бесконечность. А, а тут надо 9 плюс бесконечность. Вот, правильно.
Тут переход по букве Б, 9 плюс бесконечность.
Ну, а теперь высказать вопрос. Теперь надо скакнуть по суффиксной ссылке, да?
Только суффиксная ссылка должна нас отправить вот в эту позицию.
А вершины тут нет. То есть мы это какие-то... То есть мы не должны не просто каким-то образом вычислить,
но еще и сказать, что как бы это может быть позиция, хотя казалось бы, это должна быть вершина.
Конечно, нам разрешить это казалось по противоречию.
Ну, это значит, что текущая наша вершина до добавления этого символа тоже была не вершиной?
Ну, на самом деле, ну вот. Нет, ну да.
Но на самом деле просто идея такая. Если вы попытаетесь скакнуть по суффиксной ссылке,
ну, вы в момент поставления этой вершины, возможно, ее даже вычисляете, правда?
Возможно. Может и нет. То есть, возможно, вы ее вычисляете.
Выясняете, что... И тогда как следующее. Если тут вершины нет, то вы вынуждены видеть, что прямо сейчас она тут появится.
Ну, потому что, во-первых, когда вы закончите построение, там эта вершина должна тут быть,
потому что суффиксная ссылка в идеальном дереве все-таки только из вершины в вершину идет, правда?
Значит, по-видимому, получается, вы при поиске прямо сейчас можете эту вершину хоть там построить.
Да, пока у нее будет только один ребенок, но ничего страшного.
Семь, восемь. Тут будет семь.
Соответственно. Вот. И тогда после этого сюда и перескакивать.
Ну, а потом перескакивает отсюда, когда понадобится, ну и так далее.
Вот. А я тебе принц.
Вообще, у нас стало, что дерево для этой ссылки, когда еще В не было, должно было быть дольше.
Должно было быть, но дело в том, что отсюда-то вы тоже потом, когда построитесь, как йотип,
попытаетесь по суффиксной ссылке, вам придется еще вершину создать потом, еще здесь, потом здесь.
А здесь вершины не были?
Пока еще нет. До буквы В их не было. Тут было одно либро вообще.
Нет, ну реально. Как выглядит суффиксная ссылка?
То есть как выглядит вообще дерево на строку а-а-а-а?
Вот магия. Обратите внимание.
Оно выглядит как вообще один несчастный либро.
А-а-а-а.
А, что там?
Магия.
Вот, а когда появится буква В, тут все эти вершины, как на лифте начнут подыматься.
Да, да, да, да, да, именно. Ура, ура, ура.
Вот, в чем рад.
Так, что у нас в чем?
То есть поэтому тут и начнется вот это, потом вот это, потом вот это, потом вот это.
Еще там суффиксные ссылки придется дощить.
Это мы будем учитывать, когда вот у меня функция суффикс-лиг.
Поэтому я буду для удобства делать так, чтоб тут в излишнюю рекурсию не вдаваться, я буду делать так.
Посмотрите, я тут создаю новые вершины.
Везде, где я их буду создавать, я буду писать минус один.
Знак того, что я эту суффиксную ссылку пока не знаю.
И здесь соответственно еще минус один напишу.
То есть, ну то есть, смотрите, ну здесь ладно.
Причем это лист, поэтому для нее суффиксная ссылка в общем-то никогда существовать и не будет.
Понятно?
Вот.
Поэтому, а теперь остается только написать магию.
Как же этот суффиксный, как бы этот суффиксный ссылк мы тут будем делать?
Так, давайте-ка я сделаю вот так.
Сейчас я вот это вот сотру.
Не пугайтесь.
И напишу суффиксный линк.
Вот здесь.
Я просто это сдвинул.
Потому что мне все-таки очень хочется все еще ход уместить на этой доске.
И мне кажется, мне это сейчас может удастся.
Сейчас вот это я уберу.
Что ж там?
Ссылка поясни.
Ой, а я говорили, да?
От нее.
Да-да-да, мы что-то ее выписали, да-да-да.
То-то я думал, что-то слишком нелинно было, короче, да.
Конечно.
Значит, смотрите, как мы это будем делать.
Вот.
Вот.
Значит, смотрите, как мы это будем делать.
Ну, функцию buildNodeEvNit мы, значит, чуть позже здесь делаем.
А пока суффиксную ссылку я...
То есть они тут будут немножко взаимозависимые.
Значит, поехали.
Итак, поехали.
Int, суффикс, линк.
Вот.
Вершина.
Вот я в какой-то вершине хочу найти суффиксную ссылку.
Ну, и здесь я буду делать немножко в стиле ленивой динамики.
То есть if там, допустим...
Айей, не тем цветом пришел.
Айей, не тем цветом пришел.
Nodes от v.
Суффикс, линк.
Не равно.
Минус один.
То ее же и веркут.
Return.
Nodes от v.
Значит, суффикс, линк.
Вот.
Что мы будем делать дальше?
Ну, дальше теперь тоже давайте простые вещи.
О, кстати, интересный факт.
Когда мы тут делаем суффикс, линк, обратите внимание.
Мы позиции пытаемся присвоить вершину, да?
Значит, до этого раз придется нам сделать следующее.
То есть вершины суффикс, линк, и тут будет ноль.
Ну, потому что...
Ну, теперь, смотрите, как делаем так.
Мы только на первом шаге фестнут-криф реально можем быть не вершиной.
Потому что теперь, когда мы скачем по суффиксной ссылке,
то есть уже процесс суффиксной ссылки будет говорить, что там должна...
То есть если там не вершина, значит мы ее прямо сейчас там заведем.
Это вот у нас где-то в конце будет. Понятно, да?
Угу.
Расстояние до этой вершины.
Более.
Ну, в нежатом, да.
Ага, так вот.
В чем этот момент?
У нас получается build note of need.
Вообще применится не более чем один раз заварик.
Потому что все остальные мы уже в них попадем по суффиксным ссылкам,
и значит они уже будут существовать.
Ну, сейчас.
В смысле, то, что мы будем вызывать, это build note of need и суффиксы?
Да, у нас на самом деле, да.
Ну, можно сказать так.
Во-первых, мы сейчас будем в стиле линейной динамики вызывать.
Но в реальности мы будем говорить так, что...
Ну, по факту, да, в каждый момент времени у нас только в текущей вершине
может быть еще не насчитана суффиксная ссылка,
а у всех остальных она уже посчитана на самом деле.
Ну, у нас будет так получаться.
Как только вы создали новую вершину,
значит из нее по суффиксной ссылке все равно придется скатнуть обязательно.
Потому что вы только что ее создали,
создали из нее ребро, значит придется из нее скатнуть.
Так алгоритм.
Да, здесь нам придется еще кое-что.
Да, мы знаем, что суффикс линк в листы у нас не ходит.
Поэтому мы говорим.
Значит, если выясняется, что это корень...
Давайте оговоримся сразу.
Ну, видите, у нас же бывает chauffeur note of need корень.
Поэтому мы напишем так.
Если v равно равно нулю,
то, соответственно,
притурн...
Ну, тут минус один и выращаем.
Кстати, ровно в этом месте,
кстати, позиция становится неважной.
Вот, понятно, да?
Да теперь, смотрите, какая интересная технология.
Как нам вообще хоть как-нибудь
найти
действительно эту суффиксную ссылку?
Ну, идея здесь оказывается такой.
Вот здесь я сейчас картинку нарисую.
Вот жил-был путь вот там до этой вершины, да?
С какими-то ответвлениями,
ответвлениями, ответвлениями, ответвлениями, ответвлениями.
Вот, и мы хотим вот...
Мы эту вершину только что создали,
и теперь хотим из нее суффиксную ссылку найти.
Как это сделать?
Ну, можно, конечно, в тупую пройти по этому пути, да?
Ну, с другой стороны, заметим...
Ну, первое замечание.
Во-первых, начнем с того, что
по этому пути
можно пытаться идти чуть быстрее.
Ну, во-первых, ладно, допустим,
эту строчку мы знаем, да?
Ну, откуда-нибудь уж, я не знаю, откуда, да?
Вот. Ну, там...
Можете дополнительную информацию тут хранить,
типа, что если взять целую строчку,
откуда она взялась.
Или нет?
Хотя...
Хотя, на самом деле, это даже не обязательно,
потому что, по большому счету, если вы там будете хранить,
скажем, каждую вершину ее глубину,
то конец этой подстроки, в общем-то, он в этой эре будет.
Можно прям по индукции увидеть, что это так.
Ну, потому что в самом начале, допустим,
если вершина так,
то когда вы тут распиливаете ребро,
то вы как бы копируете информацию,
вы копируете информацию из нее, по сути.
Вот. Там так будет получаться.
Ну, в общем-то, детали.
Так вот. Но можно же заметить,
что когда вы проходите по этой строке минус один символ,
то можно заметить, что проходить можно
не за от длины строки, а за от количества вершин,
которые вам на этом пути встретятся.
Правда?
Ну, чисто за счет того,
что вы точно знаете, что пройти 8.
Вам на каждом шаге не надо проверять, можно ли пройти или нет.
Поэтому вы говорите, что так,
если я нахожусь на ребре, мне до финиша осталось
5 символов, а мне надо пройти 11,
то я говорю, так, ладно, давайте я съем эти сразу 5 символов,
там проверять точно не надо.
Я лучше пойду в вершину и пытаюсь из нее пройти
оставшиеся 6. Правда?
Сейчас. Секунду. Мы пытаемся пройти путь
без первого символа, чтобы донести свою ссылку.
Да.
А почему там будут такое же деление?
Я не очень понял.
Нет, а я не говорю, что там будет такое же деление.
А что, что мы пытаемся пройти сразу за 5 символов, если там как-то в вершине...
Нет, смотрите, я имею в виду следующее.
Вот там надо попасть вот в эту какую-то позицию.
Но я утверждаю,
я знаю, что эта позиция существует,
поэтому я предлагаю идти по вот этой стротине
не за от ее длины, а за от
сколько тут развилок реально встретится.
А в плане, что типа...
Ну, окей, да, понял.
Да, между двумя развилками я уже можно пройти
за от единицы. Потому что мы знаем,
по кому именно сильно надо идти каждый раз,
и знаем, что мы дойдем. Да.
Ну да, то есть только идти в Сашамрадо,
это на развилках решать, в какую сторону мы пойдем.
Потому что нам ничего не надо.
Понятие принято, да?
Это оптимизация номер 1.
Оптимизация номер 2 решающая.
Если тут вот... Сатычка какая идет?
А давайте не по всей стротине идти.
А вот допустим, у нас тут был
родитель, да?
А может быть, давайте просто
пойдем по сути,
к ссылке родителя, а?
И будем идти не по всей этой
стротине, а только вот по этому вот
несчастному кусочку.
Ну понятно, если это
родитель-корень, то уже
придется идти из корня только на один с его меньше.
Вот.
И будем спускаться только по вот этой
подстроке.
Понятно, да?
То есть выглядеть это будет примерно следующим образом.
Я напишу
int
cur
равно
nodis от v
точка parent.
Значит, и еще теперь int
l
равно nodis от v
точка edge
l
и там r.
Вот.
То есть я должен прийти
по подстроке l.
Но как бы и теперь я пишу следующее,
что если оказалось, что
cur не равно
root,
то я говорю, что cur
равно, вот если уж совсем
писать ленивую динамику так до конца,
то
пишем, что это
c,
c,
то пишем, что это
suffix link.
То есть просто
стактовать не отсюда, а отсутствует.
В противном случае
мы просто увеличиваем
5.
Да.
Ну root в смысле бы.
Нет.
В общем, теперь
задача
взять вершину cur
и спуститься из нее по подстроке l.
Понятно, да?
Вот.
Значит, сделаем мы это
следующим образом.
Спускаться мы будем, конечно,
по позиции. Значит, position
pos
от этой вершины, которая cur.
И, соответственно,
расстояние до нее
ноль.
Значит, теперь
говорим.
Значит, теперь делаем этот спуск.
Значит, вот мы находимся вот в позиции.
Позиция говорит.
Теперь смотрите.
While
l меньшее.
Дальше
говорим следующее.
Значит, ну тут два варианта.
Если у нас, например, pos
если мы находимся
на время, то есть pos.dist
не равен
нулю
dist2
dist2
dist2
dis2
dis2
dis2
dis2
то мы, значит, думаем
насколько нам идти.
Пишем int
len равно, соответственно
ну тут два варианта у нас.
То есть минимум сколько там в этом дисте осталось
pos, dist
e, соответственно,
tu
и, соответственно, r-l.
Ну и как теперь нам пройти?
Да очень просто.
Ну, очевидно, просто пишем
l
plus равно
len
и, соответственно,
pos.dist
minus
равно
len.
А что делать,
если мы находимся
на время,
а что делать, если мы находимся
в вершине?
Ну да, можно.
Нет. Мы точно
чем преимущество? То есть заметим, что мы
следующий символ, по которому мы должны пройти
он имеет строки s, номер l,
правда? Жестко.
Поэтому
на самом деле просто надо сказать, что pos
равно просто position.
Position от какой вершины?
Notes.
Notes от
pos.v2
s, y, d.
Да, точка children, да.
То есть идем в эту бывшую
нодис
от pos.v2
И говорю, что идти надо в вершину
точка children
Здесь мы
отправляемся в строчку s
и берем ее
И вот
А вот с расстоянием?
А как расстояние выяснить?
Ну тут
опять формулка получается
Да, то есть опять этим
придется пользоваться.
Что же делать?
Ну ничего страшного.
Поэтому придется
чуть-чуть более аккуратно
Значит, напишем
так
аккуратненько
node
ampersand
nd
равно
нодис
от pos.v2
Вот я просто возьму ссылку
Внутри этого nd я все равно
вектор менять не буду, правда?
Поэтому что я сделаю?
Сейчас nd
node
от pos.v2
равно
Можно взять позицию, можно просто
инициалайзеристами присвоить
быть такой конструктор копирования
Значит, пишем
первое мы пишем
nd.childrum
А, нет
Дальше
А может просто
номер вершинки, которая
почил
Ну может, ну короче ладно, давайте так
node
ampersand
новая вершина
nd
нодис
от
nd.childrum
Вот
Это типа куда я иду
Понимаете, да?
Ну и давай теперь
пишем pos
pos теперь
вот теперь все по nd
Значит, пишем
номер
номер надо
да екак не бабай
А что ж ты будешь делать?
Ладно
А nd вообще не очень нужно
потому что мы пользоваться не будем
Не, ну будем, ну ладно
Что ж так
Ну ладно
Ладно, давайте так
nd.nv
вот что это за вершина
nd.sim
ldm
от
и
вот так
Да нам нужна эта вершина
Ну да, здесь уже легче написать
nnv
nnv
и здесь
nd.nv
.
edge
minus
nd.nv
.edge
да
Че, прям все уже?
Могу я начать?
Так
Да, заметим, что
в этой части nd.nv не меняются никак
Так, ой
И у нас доска закончилась
А, хотя
нам в общем-то одна строчка-то и осталась
после этого
Ну да, ну теперь мы нашли как бы место
где мы
Да, нужно закончить и написать
nodis, прям на этот раз аккуратно
nodis от вот этой вот вершины v
.suffix
А, нет, даже не так
Return
Да, правильно
Сейчас давайте вот эти скобки поменьше нарисую
Теперь пишем
return
ну
в полном соответствии с линейной динамикой
nodis от
от чего?
от v
.suffix
link
равно
один раз равно, обратите внимание
Да, не два
И равно это будет
Ну, видимо, было одно удовольствие
Да, совершенно верно
build
node
if
.suffix
Да
Это так
Ну вот
То есть, типа, нет вершины
значит заведем, потому что все равно придется
Вот
Вот, можем потом там
где-нибудь тут найти место и написать
build node if need, если надо
Да
То есть нам осталось
дописать, ну там
build node if need, go и can go
но это мелочи, и доказать, что это все с линей
работает. На самом деле, да
Ну вот, то есть дальше
вот я говорю, можно делать, в принципе
то есть
У нас, в принципе, isVaid
это просто проверка на то, что там вершинка
не минус 1 и все, в принципе
Где?
isVaid функция
Да
Может, когда мы это писали, мы этого еще не понимали
Так, теперь
понимаем
Вот, ну все
build node if need надо писать
Ну, заранее дела, тогда напишем
Значит, смотрите
Теперь давайте int
тянок
где же нам писать
Ну ладно, давайте
поплотнимся немножко
Так, все, давайте
И поехали, значит
s
равно быть
Да, да, просто сдвигаем, мы еще не делали
Вот я говорю, да
Дайте вот, проблема, недостаток доски, потому что
приходится сдвигать, вот так
Преимущество доски, что можно красиво и разными цветами
писать, и там стрелочки куда-то
вставлять
Дайте, при таком раскладе уже жалко
Принцип
это да
А, ну
его тоже жалко, потому что им хотел воспользоваться
Нет, нам на самом деле
не потребуется
И доску вот так
и доску вот так переворачивать
в левую
Да нет
Да нет смысла нас
Нет, на самом деле нет смысла
Это если мне хорошо дается, когда мы на одной доске пишем только кота
на втором карте
Вот
Так, ну и давайте вот
Post
Post и
not me
Это просто не if
Нет, not me
Not me
Вот такая красота
И наконец
И вот где-то здесь нам остается
только
написать
build not if
Ну, поехали
Not if
if
Excellent
Что же у нас получается
Ну, начнем
с простого if
Если оказалось, что
post.v2
post.dist2
равно
нулю, то что мы делаем
Мы тупо возвращаем
post.v2
То есть если мы уже в вершине
ничего делать не надо
В противном случае
да, какую-то картинку придется нарисовать
Значит, теперь
Ну, сделаем так
Итак, мы живем на контр-ребре
Вот наша позиция находится
где-то
здесь
Вот это вот post
И мы что знаем
Это у нас будет вершина
v2
Ну, давайте так, это будет вершина v
Это будет вершина
допустим, p
от слова pairing
Ладно, давайте так
Это будет вершина lv
Ну, мы будем так называть, понятно, да?
А еще нам надо, что
вот эта подстрока соответствовалась
от l
до r
И вот на вот этой позиции
должен появиться
Логично, да?
Логично, да?
Понятно, да?
Ну, то есть самое надежное
Давайте честно эти переменные все пропишем
И после этого будет все красоте
И тогда после этого будет все красоте
Да, то есть давайте вот с этого и начнем
int
v
Вно, короче, v2
Ну, который post
int
p равно чему?
Ну, да, но
без вот v.pairing, конечно
Так
И делим
Значит int nv равно чему?
Ну, я могу то же самое здесь
нарисовать, да?
Уже не надо? Хорошо
Значит int nv равно
ну, нотис.size
Ну, и давайте теперь a вернуть
Успелы
int n
Догадаетесь чему равно?
нотис.size
Ну, да, имеется в виду
что нотис.size
Такого поля
у нотис v действительно нет
нотис от v.
n
да, совершенно верно
int x
равно
нотис.doe.sg
А v как вы думаете чему равно?
Нет
Нет, просто
нам нужен именно mid
знак того, что
вот это ребро
это именно от mid до r
а вот это ребро
от l до mid
Вот теперь мы все переменные
приписали
а теперь давайте
теперь нам нужно создать эту вершину
и поменять что-то в этих двух вершинах
Ну, начнем с того, что
создадим новую вершину
Значит, поехали
Ну, начнем с того, что
создадим новую вершину
Значит, поехали
Ну, начнем с того, что
создадим новую вершину
Ну, начнем с того, что
Значит, внимание
нотис.push.b
нотис.push.b
нотис.push.b
нотис.push.b
нотис.push.b
нотис.push.b
нотис.push.b
а, ну не важно, тем более что
впервые в истории
мапчик нам придется делать
не пустым
ведь обратите внимание
да?
чак
чак
чак
потому что у этой вершины есть единственное
ребро
у него есть
ребро ведет по символу С
мидовому
да? Видите? Первый символ мидовому
И
ведет это ребро куда?
вершину номер В
поэтому ведется его тут
Я надеюсь, что в конструкторе МАПа не надо там прописывать эти все?
Не-не-не, нужно работать.
Пэтчеринг, вот это все, очень надеюсь.
Ну ладно, если нет, дофидать это не проблема.
Вот, что дальше?
Так, ну давайте так, идем по списочкам.
Эдж, Эль...
Не-не-не, это фигурные скобки здесь...
Нет, это фигурные скобки от самой пары, а это фигурные скобки от МАПа.
Так что вот эта фигурная скобка еще не закрыта, мы живем.
Ок, ок, ок, ок.
А, ой, ой.
А, он плейсблэк это с круглой скобкой?
Хорошо, тогда это с круглой скобкой, она открыта, мы живем.
Ну вот, дальше, что дальше?
Дальше, Эджелер, это Эллимит.
Да, но, нет, не угадали.
Мы вот это ребро добавляем.
Поэтому...
Зачем? Что?
Ну, мы создаем вот эту вершину.
Да.
Это вообще единственное ребро.
Так мы вершинку добавляем в ребро в нее.
Да.
А, да, вы правы, вы правы.
Давайте добавим его.
Это будет Эллимит.
Значит так и пишем.
Элли, запятая.
Ой, Эллимит.
Так, поехали, Эллимит.
Что дальше?
Есть что-нибудь дальше?
Дальше, П.
Так, кто у этой вершины родитель?
А, ну, соответственно, П, конечно.
Так, и...
А суффиксной ссылкой мы не заморачиваемся.
То есть, типа, надо будет создать.
То есть, действительно, тут будет очень небезопасно, если вы здесь еще будете суффиксы.
А, ну, здесь вы его не вызовете, потому что вершины еще нет.
Вот.
Тем более, что дерево еще не полностью корректно.
Оно должно быть полностью корректным, чтобы суффиксную ссылку вызывать.
Поэтому.
Так, отлично.
С этой вершины справились.
Теперь в ней все корректно.
Теперь давайте поменяем вершину В.
Что мне надо поменять?
Переход по символу С, Л.
Где здесь...
Где здесь переход по символу?
Ничего не видно.
Нет.
В вершине В...
Нет, так как мы попали...
Так, надо поменять parent.
И edge.
Да.
Давайте поменяем.
Node.js от V.
А у parent r, что это значит?
То есть, parent равно, получается, nv.
И node.js от...
Nj.
....nj.
Равно, соответственно, теперь mi.
Да.
Отлично.
Вроде так.
Ну а что, дети в ней не поменялись.
Nj в ней не поменялся.
Нужно еще...
Суффикс лимб в ней поменялся.
Еще нужно...
Суффикс лимб не поменялся.
И еще нужно у PL, т.е. у джентльмена Чилл путь PSL, он был в V, теперь Nv, Nv
Да, совершенно верно, ну поехали
nodis.pl.children от S-Evital
равно чему
что это будет в сеть
одно Nv
ну
я над говорю тоже желтенький
и конечно же return
оп, упустились
да, почерк конечно пришлось сильно уменьшить
но уже не упустились
опустились
ну а че, походу вот весь код и написали
да, по хренометражу прямо
ну как почти
знаете как говорят
оставшиеся в крайне незначительные слова
служили элочки
помогали элочке контактировать
с ее там предавцами
у меня сейчас только один вопрос
наверное
вот в Go
короче, ну я сейчас понял что я все написал
он не работает, проблема в том что
нужно как-то аккуратно переходить вершину
если она
если у нас там
из ней
сейчас
в общем прибру длины
бесконечности
нужно правильно сразу
проставлять disk2
нельзя его проставлять
edger-edgel в таком случае
сейчас
какое место
изначально мы пишем бесконечности
все диски пишем с бесконечности
то есть начало не будет меняться
ну вот так устроен Go
если сейчас
disk2 не ноль, то мы его уменьшаем на 1
если disk2 ноль
то мы проходимся по children
от нашего символа
находим новую вершинку
а что мы должны написать disk2
нам нужно пройти
всю подстроку на этом ребре
кроме одного символа
по которому мы уже прошли
этот символ будет иметь номер
edger-dis2 в чем проблема
это будет edger-edgel
edger-dis2
в disk2 храним что?
расстояние до ниша
ну вот мы
находимся в вершинке
и мы хотим
пройтись по одному символу из нее
если ты говоришь
про вот этот вот else
нет, я про функцию Go
а, ну про функцию Go
но ты говоришь, что
нет, тут вопрос Go
или canGo
если говоришь Go, то все
а если здесь 0?
тогда ты смотришь
тогда ты просто берешь ребро
и вот просто как здесь
выходишь на новое ребро
и вот пишешь буквально вот эту же строчку
там вроде, кстати
edger-edgel-1
полуинтервал
не случайно
полуинтервалы пишем
edger-edgel
это сколько символов вообще в этой строке?
правильно
а вы по одному символу уже обошли
а, в этом плане
ну, господи
ну в этом плане
это еще ужать
ну просто в этом плане
вообще нормально же
нет, ну смотри
нет, все нормально
нет, ну просто не знаю
ну давайте вот на всякий случай
нет, просто позицион Go
теперь будет выглядеть так
нет, я думаю, что все должно работать
правильно
ну раз возьмите вопрос
давайте пример приведу
обычно просто пишут
я просто писал так
значит пишем
что если оказалось
что pos.dist
tu равно 0
пройти надо еще по символу q
вот
что мы тогда делаем?
вот делаем тогда так
значит если pos.dist
tu равно 0
то мы говорим
то прям
ну да, прям так и прописываем
буквально копипастим
ну вот
ну и в конце пишем
pos.dist
tu минус мимус
return pos
можно даже это
в отдельную функцию хорошую вынести
какую-нибудь
вот
прям вот копипастом
то есть тут на самом деле
можно это вынести в строительную функцию
давайте ее там скажем
start engine
вот и все
да-да-да
ну и тем более надо аккуратно проверять
вот
и по большому счету нам
ну ладно, проверяем
это ли почему этот алгоритм
работает
в смысле
что он действительно на каждом шаге поддерживает
корректную суффиксную идею
остается только маленький финальный вопрос
почему вот это вот допиливание
суффиксных ссылок
оставляет симпатику видео
ну ответ на самом деле кроется в этой картинке
смотрите
давайте я представим
вот мы с вами ходим
вот когда мы ходили только вот этим
рыжим указателем
то как бы да
его скачков было легейное время
но мы можем вообразить
себе более продвинутую вещь
если я представим, что мы еще ходим
вот этим вот типа зеленым указателем
когда он
из каждой вершины не просто
по суффиксной ссылке скачет
подымается
проходит и вот так вот спускается
по большому счету
можем считать, что
зеленый указатель делает тоже шоу рыжий
только еще больше
ключевое наблюдение
здесь заключается в следующем
вот я не случайно говорил
про количество вершин
на вот этом вот пути от корки
ведь если я из них
проведу суффиксные ссылки
то ведь мы же можем заметить, что
они практически все, кроме может быть одной
будут на этот условно
путь и вести
правда?
кроме может быть одной, которая поведет в коинь
вот, понимаете, да?
поэтому идея такая
давайте рассматривать такой, так сказать, потенциал
если хотите
по этому зеленому указателю
он указывает на вершину, мне интересно
глубина вершин
и количество именно вершин на пути
то есть когда мы идем в родители
мы уменьшаем эту глубину на один
когда скачем по суффиксной ссылке
эта глубина
уменьшается не более чем на один
а может остается прежняя
или даже увеличивается
потому что эти вершины точно есть
но может быть тут посредине где-нибудь еще возникли
вполне вероятно
понятно, да?
ну, короче, прибавили
не менее чем минус один
понимаете, да?
а когда мы теперь вот этим вот
сжатым образом спускаемся
и дальше получается, что мы скачем
скачиваем на каждом шаге
глубину увеличиваем
ну, там, доходим докуда и создаем
вершину, да?
тогда получается рассмотрим
зеленый указатель
он изначально вместе с рыжим указателем находится
в коине, то есть глубина 0
он
никогда не может стать глубина
больше чем n, правда?
и при этом оказывается, что
он уменьшается
на каждом шаге
ну, ладно
ну, нельзя сказать, что
на каждом шаге уменьшается не более чем
два раза, но интересно, при каждом
скачке рыжего указателя
по суффиксной ссылке
кое-что всего n, помните, да?
зеленый указатель уменьшается
не более чем
на два
вывод
суммарно спусков
тоже не больше чем 2n
3n, да
ну, от 0 до n и еще там
2n подъема, значит, спусков тоже
не более чем 3n, короче, линии
все
все, это опять же
как в случае
дерева полиэндромов
это будет работать, даже если вы эту суффиксную ссылку
будете каждый раз пересчитывать в тупую
ну, не эту пересчитывать в тупую
а вот эту пересчитывать в тупую
это все равно будет работать за лигию
ну, естественно, вы этим заниматься не будете
но тем не менее
вот и все
вот и весь
в общем-то
алгоритм
даже в общем
не сильно сложно
ну, то есть, нет
вот, конечно, достаточно сложно
это да, но
ну, как бы да
softheap был сложнее, конечно
да
зеленый указатель
да
нет, не только
еще мы есть суффиксная ссылка
зеленый указатель
резкий указатель
и вот эти новые ребра
и зеленый указатель
это, который делает черновую работу
то есть, он скачет вместе с рыжим указателем
когда рыжий указатель хочет скатнуть по суффиксной ссылке
то зеленый указатель murdered
вотiding Yemenique
вот then
то есть, по факту
кому зеленый указатель
не меньше рыжего
Но при этом он ходит за код.
Так что вот такая красота.
В целом у меня, например, получилась...
Весь этот код занял 108 строчек.
Это там включая Include.
А ты еще CanGo нарисовал?
Я все дописал, да. У меня вроде же работает.
Ну, скажем так, да.
Такая проблема есть.
Что алгоритм немножко ровно.
Но для интересующихся...
Тут я уже не расскажу, наверное, дополнительно.
Но скажу так.
В принципе, на Emax есть версия в 30 строчек.
Ну, можно...
Смотрите, тут можно аккуратно думать за счет чего.
Потому что можно там...
Потому что мы тут как бы вот это...
Сранение ребер, вот этот вот Bices, мы вот прописали вот так.
Могли бы писать по-другому.
Получились бы, может быть, другие строчки.
Но тут еще...
Ну, как бы у нас не было цели оптимизировать количество строчек,
у нас была цель, собственно, написать максимально понятный код.
Вот. То есть...
Поэтому...
То есть можете посмотреть там, как написать там...
Действительно, в 30 строчек это вот, может быть, там.
То есть, ну, правда, где-то там просто какие-то две строчки будут там...
Ужиматься, кто-то там...
Еще что-то будет в общем там такое.
Но это больше уже будет походить на черную магию.
Ну да, алгоритм немножко хромост.
И это да.
Суффиксный автомат, конечно, в этом смысле любит больше,
потому что количество строчек у него, конечно, там в два-три раза меньше.
Но тем не менее.
Но тем не менее вот алгоритм, собственно, красивый.
Ну а часто суффиксное дерево это, на самом деле, такое приятное,
приятная, интуитивно-понятная структура.
То есть вот она сама по себе, может быть, интуитивно-понятна,
а суффиксный автомат, на самом деле...
Скажем так, чтобы с ним хорошо работать, нужно стать чуть больше человеком.
Впрочем.
А, ну впрочем, видимо, в следующий раз мы этим, в общем-то, и доедемся.
Ну то есть и так, что у нас будет?
На самом деле, как бы это...
Впервые в истории получилось, что первая суффиксная структура,
которую мы изучили, это суффиксное дерево.
Нет, обычно просто начиналось как-то с суффиксного массива.
Ну вот.
Но как-то вот мы в этот раз пошли так.
Так что вот.
Так, ну на сегодня по-любому все.
