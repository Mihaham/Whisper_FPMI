Так, добрый вечер, давайте начинать.
Мы переходим к потокам, которые в каком-то смысле обобщают
пара сочетаний, которые были в прошлый раз, как вас
мало.
Будем изучать максимальные потоки в сетях.
Идея примерно следующая.
Какую задачу мы будем решать?
Представьте, что у нас есть какой-то ориентированный
граф, в котором две вершины отдельно выделены, s и t.
И нам нужно передавать водичку из s в t, в воду, нефть или
может быть машинки надо, чтобы ехали как-то оптимально
из s в t.
При этом в графе есть какие-то ребра ориентированные.
Какие-то ребра, по которым можно пускать водичку, и
на каждом ребре написана некая пропускная способность,
некое ограничение на то, сколько водички может
течь по данному ребру в единицу времени.
Какие числа написаны на ребрах?
Это значит, что вдоль этого ребра в одну единицу времени
может течь не больше чем семь единичек водички.
Здесь не больше чем восемь, здесь не больше чем одна
и так далее.
Наша задача как-то таким образом распределить воду,
чтобы она текла из s в t так, чтобы ее суммарно перетекало
на максимально возможное количество.
Вот, например, здесь что можно сделать?
Здесь, наверное, какой-то неинтересный пример получился,
потому что у меня есть верхняя часть графа и нижняя часть
gagner eingрафа, верхняя цепочка и нижняя.
Понятно, что, суммарно, по верхней течет максимум
одна единичка воды, потому что вот здесь вот ограничение
один… gigabytes stain, затянутое воду, значит, суммарно здесь
всего протекает максимум идиница, потому что здесь
вот... узкая горлашка… мы не можем больше, чем одну
единицу здесь протолкнуть.
Например, можно взять вот такой вот такой какой-нибудь
путь, давать руку, personalization runner.
И вдоль него протолкнуть единицу потока.
Тут можно взять три единицы потока протолкнуть вот
здесь, вот по этому пути.
Протолкнуть сразу по троечке.
Ну вот, видимо это будет максимальный поток, то есть больше нельзя, и в общем случае
собственно задача так и ставится. Есть какая-то транспортная сеть, то есть
ориентированный граф с ограничениями на ребрах, и нужно пустить поток максимальной
величины, то есть чтобы как можно больше водички текло из С в Т, но при условии,
что поток на каждом ребре не превосходит пропорционную способность этого ребра.
Ну вот, такая идеиная постановка, давайте займемся формализмом. Что такое сеть,
сеть или транспортная сеть? Это граф ориентированный, выделенные в нем вершины С и Т, а также,
ну собственно, вот эта вот весовая функция, которая каждому ребру ставит в соответствие
некое число. Пусть это будет функция С. Значит, здесь G, ну давайте считать, что это ориентированный
граф. Дальше С и Т, две различные вершины из множества V от G, две различные вершины графа,
значит я их буду называть соответственно сток и исток. Вот, а С это функция, которая, как я уже
сказал, каждому ребру ставит в соответствие какую-то пропорционную способность. Формально это просто
функция из Е, ну давайте скажем в целые неотрясательные числа. Ну, капость, наверное,
всегда не отрицательно. Да, и соответственно, это называется пропускные способности ребер,
пропускные способности ребер. Вот, я для краткости буду говорить capacity, собственно,
от английского capacity, вместимость ребра, сколько можно вдоль ребра протолкнуть наши водички.
Ну вот, вроде ничего хитрого пока. Значит, дальше я буду считать, если что, если нужно,
я могу в принципе эту функцию С продлить не только на ребра графа, могу продлить на потенциально
все пары вообще вершин. То есть я могу для каждой пары вершин сказать, что если там есть
ребро, то capacity такое же, собственно, как на ребре написано, а иначе, если нет ребра в графе, то я
могу считать, что на нем нулевая capacity. Например, я могу сказать, что для вот этой вот пары вершин,
ну я всегда могу ввести ребро нулевой capacity. Понятно, это граф никак не меняет, водичка по нему
все равно течь не может. Вот, но формально можно считать, что вот это вот С определено не только
для ребер, но и вообще для всех пар вершин. Потому что если ребра нет, то можно считать,
что capacity нулевая. Хорошо, что такое тогда поток?
Значит, поток вот в этой вот нашей сети, поток в сети, это такая функция, давайте сразу скажу,
из v квадрат в целые числа, такая что? Во-первых, ну самое естественное требование, что поток по
ребру всегда не превосходит capacity, значит, для любой пары вершин, увы, поток, текущий вдоль
ребра, не превосходит, собственно, capacity этого ребра. Вот, но здесь как раз играет то, что я сказал,
что я функцию С могу продлить на v квадрат, и в случае отсутствия ребра здесь написано,
что f от ув не больше нуля. Второе, ну давайте скажу антисимметричность. Значит, я скажу,
что для любой пар вершин, ув, поток, текущий вдоль ребра, ув, равен минус потоку, текущему
вдоль противоположного ребра, что-то называется антисимметричность. Формально просто давайте
скажем, что если вдоль ребра течет f единиц потока, то вдоль обратного течет минус f, ну как это можно
понимать, да, не знаю, вот у вас есть две станции, которые передают друг другу нефть, вот если одна
другой передала f, то это как бы то же самое, что вторая первой должна как бы минус f. Вот, ну это
значит будет играть, пока давайте просто формально так запишем, что всегда если течет, как бы течет поток
в одну сторону, то всегда в обратную течет отрицательность. Так, ну и третье, свойство
сохранения потока, значит, для любой вершины отличной от ста и стока и стока, сумма исходящих
потоков равна нулю. Равна нулю. Ага, это и так открыто, ну вот. Вот, значит свойство сохранения.
Так, ну что хотелось бы этой формулой выразить? Хотелось бы выразить следующее, что если у вас
v, эта вершина отличная от начала и конца, то в ней как бы ничего не скапливается, то есть все,
что в нее поступило, вся водителька, которая в нее поступила, должна вытечь. Вот, ну то есть другими
словами, да, если здесь втекает какая-нибудь альфа-бета-гамма потока, а здесь вытекает а и b,
то мне хотелось бы, чтобы альфа-бета-гамма в сумме равнялись а плюс b. Да, ну то есть как бы,
что вода не застревает вот в промежуточных вершинах, она если в вершину пришла, то она
дальше течет. Ну иными словами, у нас вот здесь вот нету таких резервуаров для накопления. У нас
только здесь есть как бы скважина, которая качает воду, и здесь есть хранилище, куда, как бы, где вода
складывается. Вот, а посередине мы ее накапливать не можем. Вот, ну хочется выразить вот так, но как
раз в частности за счет того, что я ввел антисимметричность потока, я мог бы сказать
просто следующее. Я могу, значит, вот эти вот серебра развернуть, тогда на них написано минус
альфа, минус бета, минус гамма, вот, и вот эта формула, что сумма всех исходящих потоков из вершины
равна нулю, как раз вот этой мы и равносильно, да, потому что сумма всех исходящих сейчас это a плюс b
минус альфа, минус бета, минус гамма. Вот, и оно равно нулю по соссохранению потока. Понятно, что это
эквивалентные формулы, значит, вот эта вот запись как раз и означает, что водичка в вершинках не
скапливается. Вот это эквивалентное равенство, а это есть соссохранение. Понятно это? Ну вот. Так, хорошо.
Ну и давайте, значит, скажем сразу, что в таком случае величиной потока
называем
суммарное количество потока, которое вытекает из s.
Сколько вот суммарно из s выходит, это эта величина потока. Так, хорошо, хорошо. Вот. Мы хотим
разработать какой-то алгоритм поиска максимального потока. Чтобы его сделать, я веду еще одно
определение остаточной сети. Значит, пусть f это поток в сети g, тогда остаточная сеть
g с индексом f, значит, эта сеть, ну, буквально остающаяся после того, как мы пропустили f потока.
Формально я запишу просто следующее. Для любого, для любой пары вершин uv, capacity, давайте
напишу так, остаточная пропускная способность ребра uv просто равна изначальной capacity минус
величина потока f uv. Ну то есть как бы я знаю, что вдоль каждого ребра может течь максимум c,
единиц потока, но при этом f уже течет. Значит, осталось пустить максимум вот столько. Ну вот,
давайте тогда просто для каждого ребра напишем на нем вот такую capacity, остаточную, и это будет
собственно наша остаточная сеть. Просто по сути вычли из capacity потоки. Ну, понятно, что эта
штука не отрицательна по первому свойству потока, что поток всегда не больше, чем capacity. Значит,
у меня все остаточные capacity всегда не отрицательны, и это будет корректное определение сети. Вот,
ну здесь еще давайте добавлю, что в вот этой вот остаточной сети GF я ребра нулевой capacity
удаляю. При этом ребра с нулевой capacity в GF не добавляются. Ну то есть если вот это
вот выражение равно нулю, да, ну как бы я понимаю, что при ребро счет 0 потока, наоборот, по нему
можно пустить 0 потока, то есть ничего вообще опускать нельзя. Давайте его выкинем из нашего
графа, как бы его нет. Понятно опять же, что от этого ничего не изменится, потому что и так это ребро
бесполезно, по нему ничего нельзя пустить. Давайте его удалим. Вот, значит, и оказывается, что,
оказывается, что поток F максимален, то есть его величина максимальна, если и только если в
остаточной сети JSONXMF нет пути из FFT. Вот, то есть чтобы искать максимальный поток, можно делать
следующее, можно просто итеративно многократно строить остаточную сеть JSONXMF, пытаться находить
в ней какой-то путь из FFT. Вот, если мы нашли какой-то путь, вот давайте вот в GF, я нашел какой-то путь
из FFT. Поскольку это какой-то путь в остаточной сети, и все ребра здесь имеют положительную
остаточную capacity, то я могу, ну там единичку потока точно могу вдоль этого пути протолкнуть,
потому что все capacity положительно, значит хотя бы один, поэтому хотя бы единичку потока вот вдоль
этого пути я еще могу протолкнуть. И вот если я здесь сделаю везде F плюс равно один, то есть вдоль
этого пути протолкну единицу потока, то у меня увеличится поток в исходной сети, понятно,
потому что из S что-то дополнительно вытекло, и поток увеличится. Вот, вот оказывается,
что этого достаточно, что достаточно насытить все пути в остаточной сети, и вот если их больше нет
в остаточной сети, то оказывается поток максимален. Ну это отчасти похоже как раз на просочетание,
что просочетание максимально, если нет увеличивающих путей в вдольном графе. То же самое
здесь, поток максимален, если в остаточной сети просто нет никакого пути из FFT. Вот, значит здесь
есть важный трюк, почему, собственно, я ввожу в частности отрицательное значение потока. Это за
следующим, что в такой постановке мне нужно как бы уметь отменять поток текущий вдоль ребра,
потому что вот, например, вот пусть у меня каким-то образом в какой-то момент времени пустился
единица поток вдоль какого-то ребра, но она оказывается неправильная, то есть в оптимальном,
в правильном решении вдоль этого ребра ничего течет не должно. Ну, например, давайте вот такой
пример рассмотрю. Вот пусть такой граф у меня будет. Вот такой граф, все копасти единичные.
Пусть какой-то дурак пришел и пустил единицу потока вдоль вот такого пути. Ну, понятно,
что это не оптимально, надо было пустить единицу здесь, единицу здесь. ну вот пусть внезапно как бы
кто-то пустил единицу потока здесь. Это корректный поток величины 1. Чтобы его добить до правильного,
до максимального потока величины 2, мне хотелось бы как-то отменить поток текущий вдоль вот
этого ребра, потому что в правильном решении мне нужно было бы пустить здесь, и здесь поток,
а вот тут вот отменить. Но для этого как раз у меня вот по такой формуле в
остаточной сети возникает обратное ребро вот к этому вот. У меня возникает на
самом деле вот такое ребро. Ну почему? Потому что у меня было изначально, давайте
перерисую, у меня было изначально ребро с капастью 1 и с потоком 1,
обратное у меня было с капастью 0 и с потоком минус 1,
потому что по обратному течет отрицательный поток. И вот если я теперь
вычту f и c, то у меня остаточная капасти будет как раз 1. На 0 минус минус 1 это 1.
И значит как раз в остаточной сети у меня появляется вот такое обратное ребро,
вдоль которого я смогу как раз найти вот такой вот путь, использовав вот это вот
ребро снизу вверх. И это как раз означает, что я отменяю ту единицу потока, которая
текла сверху вниз, с помощью, наоборот, единицы потока текущего сверху вниз.
Ну, короче, вы поняли, такое отменяю таким. Ну и видно, что как бы сумма двух вот таких
вот потоков вдоль такого пути и вдоль такого пути как раз вот здесь сократится,
1 минус 1 будет 0, и останется поток вдоль верхней дужки и вдоль нижней дужки.
Ну, не совсем, потому что, смотрите, вот тут у вас понятно, что поток не больше единицы сверху вниз.
Значит обратный поток хотя бы минус 1, наоборот. То есть как бы там симметрично будет
неравенство возникать из этого. Так, то есть еще раз мораль. Отрицательные потоки нужны для того,
чтобы они порождали обратные ребра. Как раз, если я пускаю поток вдоль обратного ребра,
это значит, что я отменяю старый поток, который шел по прямому ребру, и тем самым перестраиваю
как-то тот поток, который уже в графе течет. Ну и вот оказывается, что если вводить вот такие
обратные ребра, то можно просто вот пока есть путь в остаточной сети, пока он есть,
пускать по нему поток, так многократно делать, пока все пути не исчерпаются. И когда исчерпаются,
оказывается, что поток максимален. Это мы докажем. Ну если не было обратного ребра,
то, например, кто-нибудь мог прийти и сказать, давайте я пущу поток вот вдоль такого пути.
Тогда что останется? У меня останется вот такое ребро и вот такое ребро, а все остальные уже
насыщенные. И я ничего с ним делать не смогу. То есть мне нужно, мне как бы, мне придется как-то
отменять поток вдоль вот этого ребра, но у меня нет таких ресурсов, я могу только пускать поток.
Именно для этого я ввожу обратное ребро, которое как раз и означает, что можно отменить поток
текущий сверху вниз. Без него провал будет, к сожалению. Так. Ну вот, хорошо. Вот это утверждение мы
сейчас будем доказывать, но для этого мне, там теорема из трех эквивалентных утверждений,
мне для этого нужно еще пару определений ввести. Определение, как обычно, пусть g это сеть,
тогда пара множеств s и t называется разрезом, если, если s маленькое лежит в s большом,
t маленькое лежит в t большом, и при этом они в дизюмкном объединении равны множеству вершин.
Граф ажи. Это буквально какое-то разбиение множества вершин на два куска, такие, что s в одном, а t в другом.
Дизюмкное объединение все же знают, не пересекающие множество в объединении, дающее все v. Так, ну давайте
тоже напишу. В таком случае величиной разреза назовем, назовем сумму capacity всех ребер из s в t.
Просто формально сумма по всем u из s, v из t, capacity ребра у v. Картинка примерно такая. У вас есть
разбиение вашего графа на два множества, s большое, t большое. Здесь где-то s маленькое,
здесь где-то t маленькое. Вот, и мы просто считаем суммарную капасти всех ребер слева направо. То есть
все такие ребра перебираем, складываем их capacity, это называется величиной разреза.
Cst это просто сумма вот этих всех capacity на ребрах между долями. Вот, интуиция у этой величины
следующая, что любой поток заведомо не превосходит величины вот этого разреза. Да, ну потому что,
смотрите, любой поток, он же начинает в s, заканчивается в t. Значит, любой поток он должен рано или
поздно пересекать этот разрез и из s переходить в t, из s перетекать в t. Ну, тогда понятно, что поток
не больше, чем величина разреза, потому что вот как-то поток здесь, здесь что-то течет, потом
переходит и потом дотекает в t отсюда. Ну, значит, вот суммарно весь поток не превосходит того,
сколько здесь потенциально может протечь слева направо. Вот как раз не больше этой суммы. Вот,
мы тоже формально докажем. Идея такая, что это какое-то ограничение на максимальный поток,
что любой поток не больше, чем такой разрез. Так, ну еще давайте, да, определю,
значит, величина потока через разрез. Величина потока через разрез. fst, это то же самое,
только я буду суммировать потоки на ребрах слева направо. Значит, сумма по u из s, vst, fuv.
Так, то же самое, да, только я суммирую не капасти на ребрах, а потоки, f. Вот, значит,
ну, лемма давайте напишем. Если st это разрез, то величина потока через разрез равна просто
MATA-величине потока. Вот вся величина потока, это вот вся эта идея, что весь поток,
вытекающе из s, то есть как бы все, что здесь вот есть, все, что из s выходит, оно должно
tycznie Conveniently перейти через из S и Typing в tt, то есть суммарно, сколько потока протекает
из S и Typing в tt, это есть размер всего потока. То есть все, что вытекло, то есть как бы все,
что исходит отсюда, рано или поздно переходит отсюда сюда. Так, ну доказательства. Давайте займемся
арихметикой. Значит, я утверждаю, что fst можно переписать так. Ну, во-первых, давайте я скажу,
что я для любых просто множеств, для любых множеств a и b, просто определяю f и b как сумму потоков
из a в b. То есть это сумма по всем a из a, b из b и f a b. Ну, короче, то же самое, только я могу
для вообще, для произвольных множеств это определить, не обязательно не пересекающихся. Вот,
тогда утверждаю, что fst это просто fsv минус fss. Вот, это вроде очевидно, потому что здесь написаны
суммы потоков из s в t, здесь написана сумма потоков из s куда угодно, минус из s в s. Ну,
понятно как раз, что v-s это будет t в точности. Понятно это? Вот, хорошо,
значит теперь утверждаю, что эта штука ноль на самом деле. Почему, как вы думаете? Ну да,
по антисим barreijke более-менее, потому что здесь вот каждый ребро будет учтено дважды. Слева�
направо и с права налево, но мы знаем, что по противоположным реб 330 текут противоположные потоки.
Поэтому здесь будет ноль. Формально мне нужно было бы... То есть у меня есть на самом деле рёбра и петли
еще. По ребрам понятно, каждый ребро будет пощ зависма два раза, слева направо, с права налево,
поэтому сумме они дадут нулевой вклад. Есть еще петли, но понятно, что по петлям тоже
течет нулевой поток опять же в силу антисимметричности, что поток по петле
должен быть равен минус потоку по ней же, значит это ноль.
Поэтому вся эта штука тоже нулевая. Остается fsv, хорошо.
Так, ладно. Что дальше? Дальше я хочу расписать это следующим образом.
Я хочу выделить в s большом одну конкретную вершину s маленькая, а все остальное загнать во второе слагаемое.
То есть я вот эту всю большую сумму, из всей этой большой суммы вычленяю те слагаемые,
в которых f течет из s маленького, а все остальное остается во втором слагаемом.
Вот, ну тогда понятно, что вот это по определению это просто у нас величина потока,
потому что f из s маленького в это как раз сумма всех потоков текущих из s маленького,
это есть в точности величина потока просто по определению. Вот, ну и хочется доказать, что это тоже ноль.
Почему вот это ноль? Ну да, да, потому что мне известно, что для каждой вершины,
вершины отличные от s и от t, сумма потоков истекающих из нее в весь граф это ноль.
Да, значит я могу написать, что для любого u неравного s и t, я знаю, что сумма по всем v, f и v это ноль.
Это третье свойство у меня. Ну вот, а я такие штуки еще суммирую по всем u из s большого без s маленького.
И понятно, что здесь как раз вот в этом множестве отсутствует и s маленькая и t маленькая,
потому что s я выкинул, а t маленькая здесь, потому что она в t большом лежит. Ну и все,
и значит для каждой вершинки вот эта сумма нулевая, и дальше суммирую и получаю тоже ноль.
Да, окей. Ну все, получилось, что это просто величина потока. Так, шикарно.
Значит отсюда следует немедленно наблюдение, что величина любого потока не больше величины любого разреза.
Я так словами напишу. Величина любого потока не превосходит величины любого разреза.
Ну просто потому, что поток, как мы знаем, имеет величину fst, такую же, как величина потока через разрез,
ну а это уже понятно, что это не больше, чем cst, потому что каждая f в этой сумме не больше,
чем соответствующая c. Значит и весь поток не больше, и весь разрез.
Вот, ну все, теперь наконец-то можно доказывать теорему. Теорема, теорема Форда Фалкерсона.
Значит она утверждает, что следующие три условия эквивалентны. Во-первых,
поток f максимален. Во-вторых, в остаточной сети f, gf, нет пути из svt. Вот. И третье дополнительное
условие, которое здесь пригождается, это что поток f равен величине какого-то разреза. Существует
разрез st такой, что его величина равна величине потока. Что есть какой-то разрез равный по
величине потоку. Ну доказательства давайте просто по кругу докажем. Из 1 в 2. Вроде уже доказали,
что если, скажем, второй не выполняется и есть какой-то остаточный путь, то можно вот вдоль
этого пути протолкнуть единичку потока. Поток вдоль этого пути увеличен на 1, тогда весь поток
увеличится и останется корректным потоком. Можно просто, ну очевидно, можно просто протолкнуть
поток. Так, из 2 в 3. Если у кого-то интуиция, каким образом можно было бы сконструировать вот такой
вот разрез, величина которого равна величине потока. То есть я знаю, что нет путей из svt и хочу
сконструировать разрез конкретный. Представляет ли кто-нибудь, вот тут будет явная конструкция,
определим s вот так, t вот так. Первое что? s маленькое. Ну нет, к сожалению, не хватит. В
общем случае это не верно. Да, вот ровно так. Чтобы вот это вот было верно, что это значит? Это
значит, что в нашем разрезе вот все вот эти ребра насыщенные, то есть они как раз пропадают, у них
остаточная капасти 0. Чтобы c было равно f, мне нужно, чтобы все вот эти ребра были полностью
заполнены потоком. Чтобы c на каждом было равно потоку на каждом. Чтобы этих ребер не было в
остаточной сети. Вот как можно выбрать svt? Да, только я скажу проще. Я просто скажу, что давайте
s большое – это все достижимые из s маленького. Ну просто по ребрам. Пусть s большое – это все
вершины, достижимые из s маленького в остаточной сети jsindex.mf. Тогда как раз все вот эти ребра
отсутствуют в остаточной сети, потому что как раз это достижимые, а это не достижимые.
Ну значит как раз все эти ребра отсутствуют в остаточной сети, значит на них капасти равно потоку.
Ну давайте это пропишем, что для любого u из s, v из t, c, f, u, v равно нулю, так как
ребра, увы, нет в остаточной сети. Нет уже с nxmf. Ну тогда, тогда победа. Тогда, тогда c, величина
вот этого разреза, равна величине потока через разрез просто потому, что на каждом ребре c равно
f. Ну а это мы знаем, что это просто величина всего потока. Понятно? Хорошо. Ну и наконец,
из 3 в 1, надо доказать, что если есть какой-то разрез, то поток максимален. Ну понятно,
это вот отсюда следует немедленно. Я знаю, что любой поток меньше любого разреза, и оказывается,
где-то равенство достигается. Что какой-то равен какому-то. Давайте я такую картинку
нарисую. Вот пусть у меня есть все возможные величины потока, величины потока. Пусть есть
все возможные величины всех разрезов. Я знаю, что все потоки не больше всех разрезов последствию.
То есть у меня как раз засечка где-то слева, потом засечка где-то справа, это разрезы.
то есть они вот так вот как бы разделены. Но при этом откуда-то существует равенство,
что существует конкретный поток равный конкретному разрезу. Значит, вот эти множества пересекаются,
есть какая-то общая засечка вот здесь. Она соответствует и потоку, и разрезу одновременно.
Значит, это экстремальный поток, максимальный поток и экстремальный разрез, то есть минимальный
разрез. Ну еще раз, смотрите, вот это, не знаю, там, вещественная прямая, я на ней наношу засечки двух
типов, равные величине потока и равной величине разреза. Вот здесь все f и здесь все c, для всех
возможных поток и для всех возможных разрезов. Я знаю, что все потоки не больше всех разрезов по
следствию. Поэтому эти два множества отделены друг от друга, то есть у меня есть вот это вот все множество
всех потоков, это множество всех разрезов. Они вот так вот отделены. Эти все слева, эти все справа.
Но при этом они пересекаются. Вот потому что существует конкретный поток, существует конкретный
разрез с одинаковыми значениями. Ну значит, это максимальный поток и минимальный разрез.
Давайте напишем, что в таком случае f это максимальный поток, а st это минимальный разрез.
Ну вот, вроде доказали. Так, нормально? Хорошо. Вот, ну все, тогда из этого теоремы немедленно
следует простейший алгоритм. То есть алгоритм Форда Фалкерсона.
Он делает следующее. Пока в остаточной сети есть путь из СФТ, найди его, скажем, ДФС,
вот просто возьми первый положившийся путь. Посмотри на ребра на нем, возьми среди всех
capacity минимальную. У меня есть какой-то путь. Я выбираю среди всех этих ребер минимальное
остаточное capacity, то есть сколько потока я могу протолкнуть вдоль этого пути. Ну понятно,
если тут есть какие-то числа, то суммарно я могу протолкнуть минимум из них, чтобы все ограничения
превысить. Вот, возьму минимум и протолкну здесь столько потока. И так буду делать,
пока путь существует. Давайте это кратенько напишу, что пока в ЖФ есть путь из СФТ. Найти
его с помощью ДФС, положить х равным минимальной из остаточной capacity ребер на пути. Я так и
напишу минимум. На минимум по всем ребрам, лежащим на пути, остаточной capacity на ребре. Ну и пустить
по нему х потока. Пустить по этому пути х потока. Ну то есть буквально, просто непосредственно
применение теоремы, пока есть путь, пускай по нему поток. А, вот здесь? Ну, минимум всех СФ от Е
по всем ребрамам. То есть вот Е это ребра на этом пути. Среди них выбираем минимально остаточную
capacity, ЦСН, ХМФ. И проталкиваю здесь х потока. То есть вот здесь вот везде пускаю х, х, х, х, х, х.
Понятно? Ну понятно тогда, корректность следует непосредственно из теоремы, потому что просто
вот я заканчиваю, только когда исчерпали все пути. А асимптотика здесь будет, давайте
напишу вот так вот, F умножить на Е, где F это собственно величина потока, ну ответ, грубо говоря,
максимальный поток, а Е это число ребер в графе. Почему? Ну потому что в худшем случае, вот
итерация вот этого вайла происходит как раз в худшем случае F. Потому что в худшем случае на
каждом пути находится всего лишь единичная минимальная capacity, и я проталкиваю единицу потока
вдоль пути. Ну а внутри е это просто сколько времени трачет. То есть, грубо говоря, здесь ДФС,
потом проход по пути, и здесь прибавление константы на каким-то ребрам. Самое сложное здесь ДФС,
но ДФС работает за В плюс Е. Я, как обычно, считаю, что е больше, чем В, потому что иначе можно
отбросить недостижимое и считать, что е хотя бы В минус 1. Ну отсюда такая асимптотика. F это
величина максимального потока. Собственно, вот это вот. Это максимальный поток. Ну, ответ, грубо говоря.
Так, тогда давайте перерывчик небольшой. Так, давайте дальше.
Смотрите, я утверждаю, что вот ту асимптотику, которую я написал, F на Е, она на самом деле в
каком-то смысле точная. Давайте на примере. Давайте я нарисую такой граф. Вот пусть на этих ребрах поток,
точнее, капасти у меня какой-нибудь очень большое, а на этом ребре капасти всего единичка.
Ну, понятно тогда, что чтобы решить задачу, можно было бы просто пустить вот здесь вот
10-9 потока и здесь 10-9 потока и победить. Было бы максимально понятным делом поток. Но возможно,
я же там никак не специфицировал, как DFS работает. Он может как-нибудь по-другому искать эти пути.
Например, он может сначала, первым делом, найти вот такой вот путь, используя это ребро, и пустить
тут всего единичку потока, потому что это минимальная капасти 1. Ну вот пусть он здесь
пустил единичку. Тогда что? Тогда у меня появляется обратное ребро, вдоль которого можно как бы
отменять вот этот поток. Ну единственный остающийся путь, это вот этот вот, по которому тоже можно
всего единичку протолкнуть. Ну и так далее. Вот мы будем вот такими вот путями с капастью 1 пускать
по единичке потока каждый раз. Понятно, что это долго, но это будет 2 на 10 вятое итерация как раз.
То есть, что вот в этом случае у меня поток был 2 на 10-9, и в принципе, если как-то я DFS
неудачно реализовал, если он какой-то дурацкий путь находит, то вот примерно столько итераций может
быть. Может быть F итераций поиска пути. Поэтому это оценка, ну в каком-то смысле строгая,
что она достигается, что реально может быть столько итераций. Вот, значит, ну оказывается,
что это можно довольно легко починить. Именно вот смотрите, я здесь вот взял путь из трех ребер,
а надо было из двух ребер. Вот оказывается, что если всегда выбирать не абы какой путь,
а самый короткий, в плане как бы самой короткой пищу ребер, то можно избавиться вот от этой
зависимости от величины потока. Это называется алгоритм Эдманса Карпа. Значит, все то же самое,
только DFS меняю на BFS. И нахожу не абы какой путь, а самый короткий, ну как бы в плане почлу ребер,
самый короткий почлу ребер путь. Значит, тогда утверждается, что асимптотика вот-вот такой вот,
переходит вот к такой вот. Ну и, соответственно, пропадает зависимость от величины потока.
Ну тоже, конечно, не очень хорошее. Ве квадрат не очень мало, даже много для нормальных графов.
Вот, но в потоках в среднем получается так, что даже вот эти теоретические оценки,
даже несмотря на то, что они, наверное, достигаются на каких-то конкретных графах,
и при конкретном выборе вот этих вот кратчайших путей, да, потому что даже в случае BFS у меня,
ну как бы их может быть много кратчайших путей, да, и там, какой именно выбирается алгоритмом,
я, опять же, не указываю. Вот если он как-то неудачно выбирает, то, наверное, эта оценка,
опять же, достигается. Вот, но на каких-то специфических графах, если нам постоянно не везет,
если мы берем неправильные пути каждый раз и так далее. На практике вот время работы,
реальное время работы алгоритма сильно меньше, чем вот это вот. Ну, тут уже, как бы, вам предстоит
самим поэкспериментировать, насколько быстры все эти алгоритмы в контесте. Вот, ну, теоретически
можно только вот это доказывать. Но если как бы сеть, да, вот как бы сеть, даваемая вам в инпуте,
она не, грубо говоря, если вы сами ее строите, если это не какой-то граф, который вам специально дают,
который, грубо говоря, специально по-доброму, чтобы заваливать Edmunds Carp, например. А вы сами
строите сеть, то есть вы, грубо говоря, у вас есть какая-то исходная задача, вы берете и сводите эту
задачу к потоковой. То есть вы сами строите сеть и говорите, что решить исходную задачу – это то
же самое, что найти максимальный поток в новой сети, в какой-то вами построенной. Тогда это сеть
специфического вида, совсем необщего, какого-то конкретного, который вы сами построили. Ну, и там
скорее всего вот эту оценку можно усилить и доказать, что алгоритм работает быстрее,
чем теоретически максимум. Вот, ну, как-то так. Вот, давайте доказывать, по крайней мере,
что теоретически достигается вот такая оценка. Ну, поехали. Для этого мне нужно будет две леммы.
Лемма первая. Значит, пусть, ну, давайте напишу так, пусть GF и GF штрих – это два последовательных
состояния остаточной сети в алгоритме Эдмонс-Карпа. Два последовательных состояния остаточной сети
в алгоритме Эдмонс-Карпа. То есть мы делаем несколько итераций Эдмонс-Карпа, каждый раз
пропускаем поток вдоль какой-то пути, и вот пусть у нас после итерации была такая сеть,
после и плюс первой вот такая. Значит, дальше пусть D от V – это, соответственно, расстояние от S до V
в графе GF, а D штрих от V – это то же самое расстояние, но уже в новом графе, в графе GF штрих.
Графя GF штрих. Тогда утверждается, что для всех вершин расстояние выросло только, не строго.
То есть Эдмонс-Карп так работает, что кратчайшие расстояния от S до всех вершин могут только
увеличиваться в процессе его работы. Вот такое утверждение. Но давайте пойдем от противного.
Значит, пусть это неверно, и для какого-то V расстояние уменьшилось, то есть D штрих меньше,
чем D от V. Давайте среди всех таких вершин, для которых это неравенство нарушается,
выберем вершину с минимальным значением D штрих. Среди всех вершин, для которых
неравенство нарушилось, выберем ту, у которой D штрих минимально.
Выберем вершину с минимальным D штрих от V.
Хорошо. Значит, тогда давайте я вот в этой новой остаточной сети GF штрих нарисую кратчайший
путь из S в V. На, это кратчайший путь из S в V вот в новой остаточной сети GF штрих.
Кратчайший. Смотрите, ну понятно, наверное, что V не равно S, потому что если V равно S,
то D штрих и D всегда равно нулю, потому что расстояние от S до S всегда нулевое. Поэтому
для S это неравенство нарушаться не может. Значит, V точно не S. Значит, есть какая-то на пути предпоследние
вершины. Давайте ее зафиксируем. Пусть это U. Пусть предпоследние вершины пути это U. Вот,
тогда, например, я могу написать следующее. Я могу написать, что D штрих от V равно D штрих от U
плюс 1. Ну, потому что все это часть одного большого кратчайшего пути от S до V, если U предпоследнее,
то значит до него расстояние на 1 меньше, чем до V. Вот, поэтому в частности у меня получается,
что D штрих от U меньше, чем D штрих от V. А значит, раз D штрих была минимальная, для которого
нарушается это неравенство, значит получается, что для U оно не нарушается. Значит, D штрих от U
больше либо равно, чем D от U. Потому что, еще раз, вот это вот неравенство нарушалось для каких-то
вершин, и D штрих было минимально, для которого это нарушается. Но D штрих от U меньше, чем D штрих
от V, поэтому для U вот это не нарушается. Значит, выполняется такое. Хорошо, значит, это мы зафиксировали.
Мы знаем вот это, мы знаем вот это. Так, теперь давайте я задам себе такой вопрос. Откуда взялось
вот это ребро в остаточной сети? У V что это за ребро? Ну, может быть, два варианта. Либо оно
как бы просто унаследовалось с прошлого состояния сети, из GSMF, то есть оно было и оно осталось.
Либо же его не было, но оно появилось. Раз оно есть в этом графе, если бы, скажем, не было в
исходном, то оно как бы появилось. Но появиться, понятно, оно могло только за счет того, что оно
ввелось как обратное к чему-то. То есть мы как бы пустили поток по обратному ребру, и у нас появилась
у V как возможность отменять поток вдоль вот этого ребра. Ну, давайте два случая рассмотрим. Значит,
откуда у V в новом графе GF? Ну, случай первый. Это ребро было в GF и осталось. Было в GF и осталось
в GF'. В графе GF было это ребро. Вот, но раз оно было в исходном графе на предыдущей
итерации, то я точно могу записать вот такое неравенство, что dA2 не больше, чем dA2 плюс 1.
Ну, как обычно, неравенство треугольника. Если у меня есть такой ребро, то расстояние
досюда не больше, чем досюда плюс 1. Вот. Ну и все. Теперь утверждаю, что совокупность всех
неравенств, которые написаны на доске, противоречива. Давайте попробуем. Вот отсюда мы знаем,
что dA2, например, оценится сверху через d'A2. Поэтому я могу продолжить это неравенство тем,
что dA2 не больше, чем d'A2, ну и плюс 1 переписывается. На это вот это неравенство задействует.
Дальше я знаю, что d'A2 плюс 1, это в точности d'A2. Ну, у меня получилось, что d не больше,
чем d'. А это противоречит вот этому вот предположению. Здесь написано, что d больше,
чем d', а там, что d не больше, чем d'. Противоречие. Противоречие с выбором v.
Да, видно. Хорошо. Значит, случай второй должен быть. Случай второй. У v не было в gf, но оно
появляется. У v не было в gf. Ну, как я уже сказал, если его не было, но оно появляется, значит,
оно появляется только как обратное ребро к тому, вдоль которого протек поток. Значит,
что вот эти два потока f' и f, отличаются друг от друга тем, что я пустил какой-то поток,
текущий в частности вот по этому обратному ребру. То есть по обратному пустилось, за счет этого
появляется ребро uv. Хорошо. Значит, это значит, что в gf, переход от gf к gf' устроен так. Давайте
вот так его нарисую. Значит, это какой-то такой путь из s в t, в частности, содержащий ребро v u.
Чтобы оно появилось, по нему должен был протечь поток. Ну, это значит, что, смотрите, я же пускаю
поток вдоль кратчайшего пути всегда. Значит, в частности, я могу записать, что d от v плюс 1
было равно d от u, потому что это все составная часть большого кратчайшего пути, значит,
расстояние до u равно d от v плюс 1, потому что это все кратчайший путь. Так, вот. Ну,
опять я утверждаю, что записанное неравенство противоречиво. Давайте в этом убедимся.
Так, давайте вот это продолжать. Значит, я знаю, что d от v плюс 1 это d от u. Я знаю,
что d от u не больше, чем d штрих от v. Продон. d от u не больше, чем d штрих от u, извините.
Так, это вот это. Ну и дальше я могу написать, что d штрих от u это d штрих от v минус 1.
Так, это вот самое левое равенство я использую. Ну и все, получается, что тогда, давайте я пишу так,
d штрих от v равно d от v плюс 2. Да, спасибо, больше всего равно, спасибо. Ну а у меня было
предположение вот такое, что d штрих меньше, чем d от v. С одной стороны, больше равно, чем d от v
плюс 2, с другой стороны, меньше. Такого не бывает. Но опять противоречие. Ну все, не такого,
не такого не бывает. Значит, наше исходное предположение неверно, и таких вы не существует.
Поэтому вот это всегда получается. Окей? Хорошо. Хорошо. Тогда лемма два. Лемма два. Ну, например,
вот здесь, чтобы вот это вот утверждать, я говорил, что поток обязательно вдоль кратчайшего пути
протолкнут был. То есть вот это вот равенство следует только из того, что путь из sft, вдоль которого
я пустил поток, кратчайший. Значит, вот это вот равенство я могу утверждать только для кратчайшего
пути. Вроде больше нигде этого не было. Да, вроде больше не было. Итак, лемма два. Шлема два утверждает,
что каждое ребро, увы, в алгоритме Эдманскарпа насыщается не более, чем от вырос.
А что такое насыщается? Ну, насыщается, это когда мы полностью исчерпываем пропускную способность
ребра. То есть вот там, не знаю, если у него было пять, если к опасти было пять, то насыщение,
это когда вот начинает течь ровно пять потока. То есть когда раньше было меньше пять, а потом
становится пять. Ну и понятно, что каждое ребро может потенциально насыщаться несколько раз,
потому что мы могли его сначала насытить, потом пустить поток по обратному ребру и pair, соответственно,
уменьшить здесь поток вдоль этого ребра и обратно потом его опять насытить. То есть может быть такое,
что оно насытилось, потом какой-то поток отменился за счет обратного ребра, и потом
опять ребро насытилось. Вот я отвераю, что количество раз, когда оно становится насыщенным, оно маленькое.
В пополам примерно будет.
Доказательства.
Давайте эту мысль сформулируем.
Между двумя последовательными насыщениями конкретного ребра
мы должны пустить поток по обратному ребру.
Двумя последовательными насыщениями
мы должны пустить поток по ребру ВУ.
Двумя последовательными насыщениями
Двумя последовательными насыщениями
Ну что тогда?
Давайте это ребро нарисую.
Вот у меня изначально ребро насытилось, в очередной раз оно насытилось.
Что это значит?
Это значит, что если вот здесь было какое-то изначальное ДАТУ,
то поскольку у меня проталкивается поток всегда вдоль кратчайшего пути,
то расстояние до В было в точности ДАТУ плюс один.
Потому что это ребро принадлежит кратчайшему пути, раз вдоль него протекает поток,
значит это ребро лежит на кратчайшем пути из СВТ,
поэтому расстояние до В ровно такое.
После этого у меня происходит проталкивание по обратному ребру.
Но тогда я знаю, что между этими итерациями у меня расстояние до вершины только растет.
Поэтому если я здесь рассмотрю расстояние от С до В в этот момент времени,
оно будет хотя бы ДАТУ плюс один.
Потому что раньше оно было уже ровно ДАТУ плюс один,
здесь прошло сколько-то итераций между ними,
то вот это ребро берется в обратную сторону.
Тогда расстояние только выросло, расстояние до нее хотя бы ДАТУ плюс один в этот момент времени.
Но значит до этой расстояние хотя бы ДАТУ плюс два.
Потому что раз это ребро на кратчайшем пути, значит здесь на один больше, чем здесь.
Получается дальше сколько эта итерация проходит,
и в момент, когда это ребро вновь насыщается,
получается опять-таки хотя бы ДАТУ плюс два.
Получается, что между двумя последовательными насыщениями одного и того же ребра
расстояние до начала увеличивается хотя бы на два.
Понятно, что расстояние всегда не очень большое,
а именно расстояние всегда не больше, чем В минус один.
В невзвешенном графе все расстояния не больше, чем В минус один.
Ну и все, значит у меня этих насыщений может быть не очень много.
Если между двумя насыщениями увеличивается расстояние хотя бы на два,
но при этом ограничено сверху В, то значит насыщение примерно В пополам.
Следовательно, насыщение ребра В может быть не больше, чем примерно В пополам.
Что есть у АТВ, что мы и хотели. Понятно?
Ну вот, все отсюда уже немедленно следует, что алгоритм Эдманскарпа работает за ВЕ квадрат.
То есть всегда находит максимальный поток и работает за ВЕ квадрат.
Корректность очевидна, потому что Эдманскарп это просто модификация Форда Фалкерсона.
Пока есть путь во старшем сети, найди его и пусти поток.
Понятно, что корректность следует немедленно из теоремы, из теоремы Форда Фалкерсона.
Почему ВЕ квадрат?
Ну смотрите, давайте я замечу следующее, что каждая итерация алгоритма,
то есть каждый раз, когда я опускаю поток вдоль какого-то пути, она насыщает хотя бы одно ребро.
Потому что как работает эта итерация? Я нахожу кратчайший путь в ЖФ,
выбираю среди всех остаточных капаситей минимальную, то есть я смотрю на все ребра,
выбираю минимальную остаточную капасити и пускаю вдоль этого пути ровно такой поток,
какая минимальная капасити.
Значит, то самое ребро, которое было с минимальной капасити, оно и насытилось.
Поэтому каждая итерация алгоритма насыщает хотя бы одно ребро.
Но поскольку каждое ребро, коих Е, насыщается всего В пополам раз, то значит итерацией будет ВЕ.
Итерацией от ВЕ.
Потому что каждое ребро насыщается столько раз, значит суммарная итерация ВЕ.
Ну и все, а каждая итерация это просто BFS, которая работает за Е.
Отсюда вот такая симптомка.
Ну вот.
Ого, что-то я прям быстро сегодня.
Ну что, понятно?
Вот, хорошо.
Ну, пройдемаскарпайда доказали.
Еще раз повторюсь, что это какая-то теоретическая оценка.
И на конкретных графах, которые вы сами строите руками, специфического вида,
скорее всего этот маскарп работает быстрее.
То есть конкретно такая асимпточка не достигается.
Но в общем случае на это надеяться нельзя.
И тут как бы зависит от удачи и от чего-нибудь еще возможно.
Может нормально, может ненормально.
Короче, магия обычно происходит.
Так, ну давайте расскажу один способ, как можно это ускорить.
Это называется масштабирование.
Техника масштабирования.
Идея.
Ну давайте я здесь скажу сначала следующее.
То есть какое-нибудь С большое.
Это ограничение сверху на все capacity.
Ограничение сверху на все capacity.
И давайте скажу, что нет кратных ребер.
Здесь это будет важно.
Если есть две вершинки УВ, то между ними может течь максимум С потока.
Capacity максимум С.
Так, хорошо.
Значит тогда давайте будем делать следующее.
Давайте будем пытаться пускать потоки сначала какими-то очень большими пачками.
Представьте, С равно 200.
Давайте возьмем максимальную степень двойки, не происходящую С.
Сейчас 128.
Давайте тогда все те ребра, у которых capacity больше или равно, чем 128.
Будем считать, что на них просто написано 128.
Те, кто больше, останутся просто 128.
А те, кто были меньше, чем 128, получают нулевую capacity.
Сейчас я хочу представить, что я ищу поток, такой неразделимый поток величины 128.
Соответственно все, что меньше, чем 128, все ребра с меньшей capacity я могу просто дропнуть.
У нас, конечно, у них нулевой поток, потому что все равно я вдоль этого ребра не смогу протолкнуть 128 потока.
Хорошо, но давайте я сделаю такое преобразование.
Тогда теперь у меня в графе все ребра имеют по факту либо 0, либо 128 capacity.
Тогда можно все поделить смело на 128, пускать поток величины 1 и в конце ответ умножить на 128.
То есть я здесь еще поделю.
Ну и на таком графе запущу любой алгоритм Эдман Скарпа или Форда Фалкерсона, и вот на таком графе найду поток.
Умножу ответ на 128, соответственно получу какое-то приближение к ответу в исходной сети.
Я пускал потоки такими большими батчами по 128, это какое-то приближение к ответу.
Хорошо, вот что-то построили.
Дальше давайте спустимся на шурчик пониже, будем пускать потоки поменьше, по 64.
Ну опять, у меня есть какие-то ребра, те, которые меньше, чем 64 я их просто игнорирую, те, которые больше.
Ну вот здесь уже может быть такое, что будут ребра, скажем, если на ребре написано 130, то оно превратится в 128, равное 64 умножить на 2.
То есть потенциально у меня остаются такие большие ребра, и соответственно я их превращаю в 64 умножить на 2.
И соответственно потом, после деления на 64, там будет просто 2 написано.
Вот. Ну здесь опять будет некая сеть с небольшими уже capacity, то есть на ребрах будет написано не 64, не 130, а 2 просто.
Ну тогда, например, Форт Фалкерсон будет довольно быстро работать, потому что если capacity маленькие, то и поток маленький, значит и Форт Фалкерсон будет быстро работать.
Ну и так далее. Буду уменьшать размер батча по степеням 2 вплоть до 1.
Соответственно в конце я буду пытаться пустить поток величины 1, ну просто в исходной сети, без всяких сокращений, потому что когда у меня будет единица здесь, у меня никаких вот этих вот сжатий и масштабирований не будет уже.
Значит, в конце я точно получу правильный поток, потому что, ну потерем Форта Фалкерсона опять.
Я там какие-то потоки пустил изначально, потом добиваю это потоком величины 1.
Ну вот и все, такая идея.
Теперь давайте это как-нибудь запишем.
Ну как-нибудь совсем схематично напишу следующим образом.
Значит, давайте в цикле по всем K от 2-ичного логарифма С до нуля.
Значит, ну я что делаю? Я вот делаю такое преобразование.
Я каждую остаточную capacity округляю, то есть считаю сколько раз туда помещается 2 вкатый, и оставляю только то, сколько раз тут поместилось 2 вкатый.
Поэтому я для любого ребра просто говорю, что вот новая capacity в масштабированном графе, это просто остаточная capacity поделить на 2 вкатый.
То есть сколько раз через это ребро можно пропустить batch поток величины 2 вкатый.
Дальше находим в новом графе, в новом графе, поток, ну там, здесь неважно, с помощью Форд Фалтерсона или с помощью Эдмонс Карпа, тут с точки зрения симптотики не влияет.
Ну и дальше увеличиваем этот поток на 2 степеника. Точнее, умножаем его на 2 степеника.
В частности, на последней итерации, когда кара равно нулю, у меня просто C штриха то же самое, что C с инксом F, то есть просто остаточная capacity, потому что делю на 1.
Ну и значит, в частности, на последней итерации я просто добиваю всеми возможными путями.
Поэтому корректность как раз очевидна здесь. Я опускаю потоки сначала большие, 128, 64, 32 и так далее, а заканчиваю, добиваю все потоками величины 1 и так делаю, пока все пути не исчерпаются.
Поэтому ответ будет точно правильный.
Ну и вот утверждается, что это работает за E квадрат на лог C.
Что потенциально может дать выигрыш по сравнению с обычным Эдмонс Карпом, где был E квадрат на лог В, обычно лог C все-таки сильно меньше, чем В.
Так, хорошо. Давайте это попробуем доказать.
Ну, мне понадобится следующий факт. Пусть LEM опять будет.
Лемма 11. Пусть F большое. Это настоящий максимальный поток, величина максимального потока.
Вот, а F с индексом K это величина потока, найденная после ката-итерации.
Величина потока найденная после ката-итерации.
K вот у меня также пронумерована. То есть у меня сначала итерация с номером лог C, потом лог C-1 и так далее вплоть до нуля.
Вот тогда F не больше, чем F ката, плюс 2 в каты, но ж на E.
Ну, хорошо. Доказательства. Давайте рассмотрим остаточную сеть после ката-итерации.
Как она устроена? После ката-итерации в остаточной сети нет пути.
Но вот в остаточной пути вот с этими штрихованными масштабированными ребрами.
То есть на самом деле ребра-то вот здесь как бы есть.
Ну, как обычно, S это все достижимые, T это все остальные. На самом деле ребра-то есть, но у них как бы вес меньше, чем 2 в каты.
То есть они как бы, они может быть и есть, но по ним их недостаточно, чтобы пускать большие батчи потока.
На этих ребер остаточная capacity будет меньше, чем 2 в степаняка.
Ну, потому что было бы больше, тогда это ребро присутствовало бы вот здесь.
А здесь у него было бы тогда положительный C-штрих, значит эта вершинка должна была быть в S.
Ну, значит суммарно величина вот этого разреза, она меньше 2 в каты умножить на E.
Потому что всего у меня E-ребер, и каждый имеет capacity максимум 2 в каты.
Значит, величина вот этого разреза не больше, чем 2 в каты умножить на E.
Максимальный поток. То есть вот мы построили новый граф, вот такой вот, с такими капастями.
Дальше в этом графе масштабируемым, таком сжатым находим максимальный поток.
Ну, не один путь, а максимальный. То есть пока все не исчерпаются.
Именно поэтому как раз я говорю, что после каты итерации не остается вообще путей
по ребрам с capacity больше равно 2 в каты. Значит, все вот эти ребра как раз меньше capacity.
Ну вот, а я знаю, что в этой остаточной сети поток, по сути,
остаточный поток от F-каты до F, он не больше, чем этот разрез,
потому что поток всегда не больше, чем разрез.
Значит, остаточный поток, он не больше, чем конкретный вот этот разрез,
который не больше 2 в каты умножить на E.
Ну а остаточный поток, это в точности F-F-каты.
Потому что F это максимальный, а F-каты тоже пущенный.
Осталось до конца добить как раз F-Fk.
Ну, отсюда получается вот это неравенство.
Так, что-то понятно? Хорошо.
Лемма 2. Для любого к, на каты итерации,
алгоритм находит не больше, чем E путей.
Алгоритм находит не больше E путей.
Пардон, 2E.
Да, ну, то есть еще раз, у меня здесь внутри есть какой-то рекурс,
ну там запуск, форт Фалкерс, неледман Скарпа.
Каждый из них работает так, находит какой-то путь в графе,
пускает по нему поток, находит путь, пускает поток и так далее.
Вот я отмечаю, что в суммарных путей любой из них найдет максимум 2E.
Ну почему? Смотрите, я вижу, что остаточный поток максимум вот такой.
Но при этом, ну окей, давайте, давайте идею сначала.
Смотрите, я понимаю, что с предыдущего шага, вот если у меня катый шаг закончился,
а ката итерация закончилась, то мне осталось пустить максимум вот столько потока.
Дальше, на следующей итерации k-1, у меня k уменьшается,
на k-1 итерации мне нужно пустить максимум вот столько потока,
но если я нахожу какой-то путь в этот момент времени,
то я по нему пускаю хотя бы 2 в k-1 потока,
потому что у меня бачи будут иметь размер как раз 2 в степени k-1.
Но если мне осталось вот столько, а любой путь привносит мне вот столько,
то значит путей максимум как раз 2E. Вот то поделить вот на это будет как раз 2E.
Давайте это запишем быстренько.
Значит, после каты итерации остается найти не больше, чем 2 в k-1,
а, возможно, E-потока.
Далее, любой путь, найденный на k-1 итерации,
увеличивает поток хотя бы на 2 в степени k-1.
Потому что как раз все ребра сжались так, что единичка превратилась в 2 в степени k-1.
Если нашел путь, то значит с точки зрения исходной сети на нем поток вот такой хотя бы.
Ну все, значит путей не больше, чем вот этот дробь 2 в k-1E делит на 2 в степени k-1.
Потому что столько осталось, но каждый путь привносит вот столько хотя бы.
Это просто 2E.
Иначе путей мало.
Ну и все. Отсюда следствие, что алгоритм работает за...
Ну, конечно, это утверждение доказывает, что алгоритм работает за E2лc.
Ну, это уже вроде очевидно. Вот столько всего итераций, k пробегает вот столько значений и логарифмическая.
И дальше, на каждой итерации, что я делаю? Я запускаю от Манскарпа или Форт Фалкерсона,
но каждый из них находит максимум 2E-путей.
Каждый путь находится с помощью DFS или BFS, то есть еще за E примерно.
Получается отсюда как раз E2. У меня вот столько. У меня E итерации, O от E итерации.
И каждая итерация работает за E.
Поэтому вот суммарно, при каждом k, вот этот Форт Фалкерсон или Манскарп, неважно кто, работает за O от E2.
Ну, суммарная симптомика вот такая.
Так, вроде все. Отлично. Вопросы есть?
Ну, тогда все. Спасибо. До следующего раза.
