Сегодня у нас ключевая тема, но видимо она будет и сегодня, и в следующий раз.
Это ключевая тема, это NP-полнота.
NP-полнота, но неформально.
NP-полные задачи.
Это такие задачи, которые самые сложные в классе NP.
Я напомню, что мы в прошлый раз познакомились с этим классом.
Изучили два подхода к определению.
Есть один подход через генетогенерные машины.
Другой подход через сертификатные машины.
То есть машины с двумя аргументами.
NP-полные задачи. Это самые сложные задачи.
Открытие NP-полноты послужило началом исследования вопроса о том, равны ли П и NP.
Оказалось, что не просто эти задачи самые сложные, а еще они все друг другу эквивалентные.
Можно сказать, что все эти задачи являются переформулировками друг друга в других терминах.
Можно сказать, что можно перевести с одного языка на другой и фактически будет та же самая задача.
Сначала мы начнем знакомиться с основами теории.
Формально.
Потом докажем, что NP-полные задачи бывают.
А потом будем доказывать про множество конкретных задач.
Они будут NP-полными и там будут некоторые специальные конструкции.
Хорошо. Начнем с определения того, что такое свадимость.
Определение того, что такое полинамиальная свадимость.
Полинамиальная свадимость.
Определение такое, что есть два языка.
Один полинамиально сводится к другому.
Но если существует полинамиальная вычислимая функция.
Полинамиальная вычислимая функция.
Будем считать, что A и B это языки под множество каких-то слов, скажем, двоичных.
То есть слов из 0 единицы.
Получается, что существует полинамиальная вычислимая функция F.
Которая отображает 0,1 со звездочкой, 0,1 со звездочкой.
Ну и конечно еще нужно сказать, что она всюду определена.
Давайте это явно укажем.
Она всюду определенная.
Ну можно считать, что это следует из полинамиальной вычислимости.
Если считать, что если функция данной точки не определена,
то она вычисляется за бесконечное время.
Тогда из полинамиальной вычислимости следует сюда определенность.
Ну можно и явно указать.
Значит, функция F со следующим свойством.
Такая, что для любого x, x лежит в A тогда и только тогда, когда F от x лежит в B.
Вот, больше ничего не требуется от функции.
Она не должна быть никакой биекцией, инъекцией.
Ничего такого не нужно.
Нужно только вот это вот.
Можно посмотреть вот так вот.
Вот пусть есть два облачка.
Два облачка это соответственно две копии множества всех плов.
И вот эта облачка как-то разделена.
Здесь есть A и есть A с чертой.
То есть дополнение K.
Здесь будет ответ да, здесь будет ответ нет.
А вот эта облачка как-то по-другому разделена на B.
На B и B с чертой.
И тогда, соответственно, обязательно из этой части функция отображается вот в эту часть.
Но не обязательно вовсю.
Может быть и склеивается.
Может быть какие-то значения не принимаются.
В общем, можно тут написать, что вот тут есть как бы такой образ.
Образ A, который целиком лежит внутри B.
Ну а здесь, наоборот, есть образ A с чертой, который лежит целиком внутри B с чертой.
Он выглядит как-то вот так.
Вот.
Да, значит, вот такая вот картина получается.
Значит, для чего это нужно?
Ну, в общем, основное утверждение, которое мы тут используем,
будет вот такое вот, что если A пальномиально сводится к B
и при этом B лежит в P,
то тогда A тоже лежит в P.
Ну что, это разное множество.
Вот, соответственно, как это утверждение доказывается.
Ну, тут основное свойство, которое здесь используется,
это то, что композиция параллельно вычислимых функций параллельно вычислима.
Получается, что мы можем сначала вычислить f за пальномиальное время,
а потом про результат понять, лежит он в B или в B с чертой.
И тогда получается, что в точности этот же ответ про образ f от x
будет ответом и происходный x относительно A.
Потому что у нас получается, что x лежит в A,
тогда это тогда, когда f от x лежит в B,
а на вот этот вопрос мы можем ответить за пальномиальное время,
причем за пальномиальное время не только длины f от x, но и длины исходного x.
И этот же ответ будет годиться и вот здесь.
Вот, ну, значит, есть еще ряд утверждений такого рода.
Еще ряд утверждений.
Можно сказать, что если, например, транзитивность верна,
значит, если A сводится к B, B сводится к C,
то тогда A сводится к C.
Ну и это доказывается тоже примерно так же.
То есть тут получается, что x лежит в A тогда и только тогда,
когда f от x лежит в B,
а это будет тогда и только тогда, когда j от f от x,
значит, j от f от x принадлежит C.
Ну и опять же композиция g на f будет пальномиальной,
поэтому все вместе будет тоже функция, которая A сводится к C.
У нас f от x имеет пальномиальную длину от x?
Конечно, потому что само f пальномиального числима, оно просто ничего длиннее не сможет вывести.
А, соответственно, время работы длины g будет пальномом уже от длины аргумента, то есть от длины f от x.
Но поскольку пальном от пальнома это пальном, то это будет пальном и от x тоже.
Вот. Значит, какие еще есть утверждения тут важные?
Ну, важное утверждение вот такое вот.
A сводится к B тогда и только тогда, когда дополнение K сводится к дополнению B.
Ну, здесь можно просто ту же самую функцию взять,
и тогда как бы вот в этом определении взять отрицание от каждой части,
и эти отрицания будут тоже эквалентны, и они как раз будут означать вот эту сводимость.
Вот.
Так, ну еще можно сказать, похоже на первое утверждение.
Значит, если A сводится к B,
а B сводится к N п, ой, B лежит в N п,
то тогда A тоже лежит в N п.
Ну, доказывается примерно так же,
но только нужно, согласно одному из определений,
либо вот здесь вот взять недetermинированную машину
и сказать, что композиция недetermинированной вот здесь вот
и вот этой функции сводящей тоже будет недetermинированной полиновиальной машиной,
и будет давать правильный ответ.
Ну, либо можно сертификат на определение использовать.
Надо сказать, что для B есть верификатор,
и тогда можно построить верификаторы для A, которые сначала из X делают F от X,
а потом проверяет, годится ли данный сертификат для того, что получилось.
То есть, можно сказать, что мы, если у нас V, а давайте я вот так напишу,
значит, V A, верификатор для A от X Y,
будет равен верификатору для B от F от X A
и того же самого Y.
Тогда получается, что если X лежит в A, то F от X лежит в B,
для которого это даст единицу, значит, это тоже даст единицу.
Ну, а если, значит, если X не лежит в A, то F от X не лежит в B,
тогда для F от X A такого Y нет, ну и тогда здесь для X A такого Y тоже нет.
Вот.
Ну и еще можно сказать,
значит, можно сказать, что если
два, значит, если два языка уже пальномиальные, но не тривиальные,
то есть, если A и B у нас лежат в P,
значит, в P, но без,
значит, в P без пустого множества
и, наоборот, всего, да, множество всех слов.
То есть, если A и B пальномиальные, но не тривиальные,
тогда они просто друг к другу сводятся.
Значит, тогда A сводится к B.
Вот.
Но это делается так, что можно, значит, можно вот так вот определить.
F от X будет равно,
значит, некоторое B1, если X лежит в A,
и B0, если X не лежит в A,
где, соответственно, B1 лежит в B,
а B0 не лежит в B.
Значит, как раз если B, значит, если B не пустое и не все слова,
то тогда найдется как слово, которое лежит в B,
так и слово, которое не лежит в B.
Ну а дальше, если мы и так можем понять, лежит ли X в нем или нет,
то мы, соответственно, вычислим, да, вычислим, лежит или нет,
и выдадим соответствующие ответы.
Значит, тут есть такая тонкость,
потому что можно попытаться оспорить вот это рассуждение
и спросить, откуда мы возьмем эти B0 и B1.
Понятно, что, в принципе, если у нас вообще какое угодно B,
это вообще не очень понятно, откуда их искать.
Может быть, а пусть оно там не пустое, оно какое-нибудь очень редкое,
пока найдем элемент в нем, это будет очень долго,
почему все это полиномиальное, такое сомнение может возникнуть.
Но на самом деле это сомнение не будет опровержением вот этого,
потому что, смотрите,
вот тут вот в определении не сказано, что вот это вот F,
ну, она, грубо говоря, откуда-то легко берется.
Она просто существует, да, она просто существует,
и не факт, что, например, по какому-то описанию A и описанию B можно ее легко найти.
Здесь ничего такого не требуется, она просто существует.
Но здесь она тоже просто существует,
и откуда бы, какие бы B1, B0 ни были, откуда бы они ни взялись,
просто вот такая вот функция будет полиномиально вычислимой.
Сама по себе она будет полиномиально вычислимой.
А вот задача ее поиска из других соображений уже может быть сложной.
Ну, это, знаете,
такой же похожий эффект.
Такой.
Да, например, можно рассмотреть такую функцию.
Пусть F от N равно 1,
если все, все числа от 1 до N,
точнее, ну, скажем, десятичные записи всех числа от 1 до N
встречаются в десятичном возложении числа P.
А, соответственно, если хоть какая-то не встречается, то тогда будет 0.
Вот вопрос, будет ли эта функция полиномиально вычислимой?
Ну, на самом деле, будет.
Есть гипотеза, что в записи числа P вообще все в последовании встречаются,
но эта гипотеза не доказана.
Соответственно, если эта гипотеза верна, то эта функция просто всюду единица, она тривиальная.
А потом моменты будут единицы, а потом нули.
Но такая функция, где бы, где бы этот момент ни был, такая функция все равно будет легко вычислима.
Потому что это мы не знаем, в какой момент она станет нулем,
но в программу этот момент в любом случае может быть занесен,
и тогда вот эта программа уже с занесенным моментом переключения будет работать
быстро, ну и вообще она там будет делать одно сравнение и останавливаться сразу.
Понятная идея, что может быть так,
это как бы такая неконструктивная оценка,
может быть так, что какая-то быстрая программа есть, но мы не знаем какая.
А вообще, знаете, давайте, раз уж я про это говорил,
то я немножко отвлекусь от NP и расскажу довольно красивую историю про класс P.
Значит, это называется неконструктивное
доказательство
принадлежности к P.
Вот опять же, какой-то полимониальный алгоритм есть,
но никто не знает, какой.
Так, слышали ли вы про критерии планарности графа?
Там есть критерии Пантреагина-Куратовского.
Да, значит, давайте, не все, не все, да?
Нет, хорошо, ну сейчас я, да, сейчас я расскажу вкратце.
Значит, вот есть такой граф К-5.
Значит, граф К-5 это 5 вершин, которые все друг с другом соединены.
Знаете, какой-то такой пятиугольник и звездочка.
Вот, и вот его нельзя на плоскости нарисовать так, чтобы ребра не пересекались друг с другом.
Так что можно сделать меньше пересечений, чем я здесь нарисовал.
Но так, чтобы было ноль, нельзя сделать.
Но это можно по-разному доказывать, можно, в принципе, аккуратно перебрать все варианты,
можно сослать на формулу Эйлера для планарных графов.
Да, в общем, так или иначе, это нельзя сделать.
Вот шесть вершин разделок на две группы и, соответственно, соединены все из разных.
Так, все вроде, да?
Вот, его тоже нельзя нарисовать.
Да, это есть такая задачка, что вот есть три домика, три колодца.
И в этих домиках живут какие-то нелюдимые граждане, они не хотят друг друга видеть.
В каждом доме, в каждом колодце шла дорожка так, чтобы они не пересекались.
Вот, но, оказывается, нельзя так сделать, надо хотя бы один мостик построить.
Значит, тогда можно так сделать.
И оказывается, что это два базовых примера не планарных графов.
Значит, есть на самом деле два критерия.
Значит, есть один критерий Пантрягино-Куротовского.
Знаешь что, граф не планарен.
Граф не планарен.
То есть, нельзя его нарисовать на плоскости без самопересечений.
Не без самопересечения ребер.
Значит, граф не планарен, тогда это только тогда, когда у него
есть подграф
гомеоморфный
гомеоморфный К5
или К3,3
Значит, что это вообще значит гомеоморфный?
Ну, подграф означает, что просто какие-то ребра убрали,
а гомеоморфный означает, что на самом деле есть выделенный
К5, что есть выделенный пять вершин, и между каждой парой есть пути,
которые попарно не пересекаются.
Но, соответственно, в них может быть не одна вершина, а несколько.
Ну, в смысле, промежуточных может быть несколько.
То есть, здесь есть пять вершин и попарно не пересекающиеся пути
от каждой к каждой. Ну, а здесь есть, соответственно, шесть вершин
и попарно не пересекающиеся пути от каждой из этих трёх.
А ещё есть другой критерий.
Есть другой критерий, называется критерий Вагнера.
Критерий Вагнера, там тоже К5 и К3,3.
То есть, тоже граф не планарен,
тогда и только тогда, когда у него есть
минор.
Значит, минор К5 или
К3,3. А теперь что такое минор?
Минор это немножко другая штука. Значит, минор это такой граф, который получен
операциями удаления ребер.
Это вот так же, как с подграфом. Но ещё операция стягивания
ребер. На стягивание ребер означает, что мы ребро убираем, а его концы склеиваем.
Вот, и вот это вот не то же самое, что взять и подграфом.
Минор это граф,
стягиванием и удалением ребер.
Вот, и тут есть хороший пример на разницу этих,
на разницу этих критериев. Это вот, смотрите, какой граф.
Вот так вот.
Пятиугольник.
Тут всего будет 10 вершин.
Вот так вот. А здесь будет звёздочка.
Вот, и тут как раз, если все вот эти вот ребра стянуть,
как раз копять и получится. Поэтому не планарный по критерию Вагнера.
Вот, но если будет пытаться искать подграф, копять, то тут это не получится.
Потому что, ну вообще у копять тут степень 4,
а тут всюду степень 3. Поэтому подграф тут будет ка-3-3.
Вот упражнение, значит, найти подграф
ка-3-3 вот в этом графе.
Вершина означает, что тут могут быть ещё вершинки по дороге.
Да, что эти ребра, это не отдельные ребра, а могут быть цепочки.
Не, не, не, сейчас, ещё раз.
Подграф, значит, подграф именно означает, что мы сначала какие-то ребра убираем
и может быть вершина тоже, но вершина сразу со всеми ребрами.
Значит, мы убираем какие-то вершины со всеми ребрами, какие-то ещё ребра убираем.
И в том, что осталось, есть в данном случае 6 выделенных вершин
и пути от каждую в каждую, которые ещё и попарно не пересекаются.
Вот, но вот здесь вот как раз с невидотечением и есть проблема.
Потому что тут-то пути есть с каждой в каждую, но они будут пересекаться.
Чему симметрично?
Гомеоморфизм это отношение к валентности.
Не, ну гомеоморфизм можно себе так представить, что если вы представляете граф
как просто такую геометрическую фигуру, то, соответственно,
можно непрерывным преобразованием одну перевести в другую.
То есть если вы ребро представляете как какую-то кривую в пространстве,
и тогда неважно, если там просто будут вершины на этой кривой,
то с точки зрения типологии это всё неважно.
Нет, не заморхнется подразумевать, что будет столько же ребер и столько же вершин.
А ещё раз, в гомеоморфизме вам неважны дополнительные вершины,
которые стоят на ребрах.
Потому что важна только тополическая структура, как там кривая, ломанная и так далее.
Это симметрично следует?
Нет, а симметрично следует из-за того, что у вас есть
непрерывное преобразование,
и тогда можно в другую сторону провести, как бы обратить время.
Нет, ну вообще это там, вот у вас есть фигура какая-то,
вообще вообще, что гомеоморфизм, да, там в мотонии, в типологии,
что у вас есть какая-то фигура в пространстве,
и у вас есть функция, как бы от времени, действительно, параметра.
Вот, и, соответственно,
получается, что там в момент времени 0 у вас получается одна фигура,
в момент времени 1 получается другая фигура,
и все премежуточные изменяются непрерывно.
А, кстати, сейчас тут
и даже не нужно, да, потому что, как я говорю,
узел нельзя развязать, а тут нам не важно, чтобы что-то заузлено.
Ну, типа того,
типа того, да, в общем,
можно сказать, что просто есть непрерывная биекция,
да, можно сказать, что просто есть непрерывная биекция
между одним графом как-то в логическом пространстве и другим.
Вот, тогда там не важно, есть узел, нет узла, это все не важно.
Вот.
Так.
Ну, хорошо.
Значит, дальше есть
есть некоторое количество алгоритмов, которые умеют проверять планарность
за полимерное время.
Значит, планарность можно проверить
можно проверить
за полимерное время.
Вот, но вот критерий
кратовку тут не очень поможет, да, потому что, конечно,
можете проверять, что есть путь за полимерное время,
но вам нужно не просто путь, а много разных путей, да еще и какая-то общая структура
между ними, да, про каждую отдельную пару можно проверить, что есть путь
за полимерное время, но вам нужно больше, да, значит, вам нужно, чтобы все эти пути были не пресекающиеся,
и вот это вот уже гораздо сложнее.
Не обязательно, потому что мы же под грамм берем.
Да, все лишние ребра мы уберем.
Вот.
Но еще, значит, там есть много разных способов, но один из способов это по критерию Вагнера.
Значит, вот наличие минора, как раз, можно проверять.
Значит, один
один из способов
значит, это по критерию Вагнера.
Значит, это тоже совершенно не элементарно, да, как проверять, что есть минор, это тоже
целая отдельная наука.
Но давайте поверим, что так можно сделать.
Но хорошо, на самом деле, дальше есть еще разные другие свойства.
Значит, есть другие свойства.
Значит, есть другие свойства, которые
сохраняются
сохраняются при тягивании
или удалении ребер.
Ну, например, можно посмотреть
вложение не в плоскость, а в какую-нибудь другую двумерную фигуру, например,
в тор. Значит, давайте, если вы это не видели, давайте я это нарисую.
Да, ну, тор, наверное, все знают, что такое, да.
Вот так его обычно рисуют. Да, как бы такой цилиндр, свернутый с двух концов.
Сам на себя.
Дальше можно здесь вот такой вот пятигонечек
нарисовать.
Так, и, например,
два ребра провести прямо здесь.
Вот, и остаются еще три.
И еще вот такой вот.
На поверхность, конечно.
Ну, давайте, например, смотрите, если я проведу вот так вот,
то тогда отсюда-сюда я уже никак вообще не могу провести, поэтому я так не буду проводить.
Но зато если я проведу вот так вот, то это ничего не помешает.
Ну, давайте я так и сделаю.
И тогда остается только два отрезка, вот это и вот это.
И вот тут можно воспользоваться тем, что это тор.
Например, я могу...
Так, мне вот сюда вот надо, да.
Я могу вот так вот провести.
Так, и еще вот сюда вот надо.
Ну, а тут я могу как бы провести вот так вот, там с другой стороны обойти и вернуться вот сюда вот.
Не, ну что нибудь как угодно.
Не, ну в смысле, не, да, это, конечно, не единственный способ.
Ну, может быть, и К6 тоже можно нарисовать.
Не только 5, но и 6 вершин можно нарисовать.
Вот, а 7 не помню.
Вот, да, вот, например, вложение в тор.
Вообще там есть теорема классификация, что любая двумерная поверхность
ориентируемая, это называется сфера с G-ручками.
Это называется ручка.
Можно их как бы друг к другу так приклеивать, их будет много.
И, соответственно, там G, это называется рот поверхности.
И вот любая двумерная поверхность будет иметь такой вид.
Вот, ну, может быть, и другие более хитрые топологические
свойства, кроме вложимости в поверхность, может быть, вложимость
просто трехмерное пространство, но, например, с какими-то условиями
назаузненность. Да, то есть верны лишь там не один цикл, не завязан узел.
Да, выглядит как обычная окружность.
Ну и так далее.
И дальше самая удивительная вещь.
Значит, вот есть теорема Робертано-Сеймура.
Робертано-Сеймура.
Значит, они вообще вот эти вот миноры в графах очень долго
написали 23 статьи, которые так и назывались.
Graph Minors, номер такой-то, про то-то и то-то.
Вот, так что тут вот эта теорема на самом деле из разных работ.
Вот, значит, в одной работе было доказано следующее,
что для любого такого свойства есть конечное число,
то для любого такого свойства есть конечное число запрещенных миноров.
То есть вот здесь вот в этом критерии два запрещенных минора,
К5 и К3, три. Вот, а для любого такого свойства есть какое-то другое
конечное семейство.
Значит, для любого такого свойства,
такого, в смысле вот такого, который сохраняется
при стягивании или удалении ребер.
Ну вот же, вот.
Не, ну вот два класса примеров, это вложимость поверхности
и вложимость пространства без заузленности или с каким-то условием на заузленность.
Значит, для любого такого свойства есть конечное число,
есть конечное число запрещенных миноров.
Вот, ну а второе, из другой статьи теорема,
что наличие данного минора
можно проверить пальномиальным алгоритмом.
Значит, наличие данного минора
можно проверить
за пальномиальное время.
Вот, ну это прям серьезная большая наука, они лет 20 это все писали.
То есть там реально даже больше,
почти 30, наверное, там первые статьи в конце 80-х выходили, а последние уже там 2013 какой-то год.
Вот.
Да, может быть такой же критерий, вот такой же как у Вагнера,
только вместо К5 и К3-3 будут какие-то другие графы.
И их конечное число.
Вот, соответственно, что из этих двух утверждений следует?
Ну получается, что мы для любого такого свойства
можем написать программу.
А именно, вот список запрещенных миноров и про каждый из них мы проверим, что этого нет, этого нет, этого нет, этого нет и так далее.
Если какой-то есть, то значит, свойство не выполнено.
А если никакого нет, то значит, свойство выполнено.
И это будет полиномиальный алгоритм для, соответственно, вот такого свойства.
Вот.
Но проблема в том, чтобы такую программу написать, нужно знать не просто их конечное число,
а что конкретно это за запрещенная графа.
Вот. И даже для вот этой вот задачи вложимости в тор,
тут решения нету.
То есть, это пытались найти список и реально нашли
довольно много как бы запрещенных миноров.
То есть, это что означает?
Что они сами не вложимые.
Если мы что-то удалим или что-то стянем, то уже получится вложимое.
Вот.
Нет, вот в том дело, что все не нашли, нашли довольно много.
Понятно, смотрите, что любой такой граф должен быть запрещенным.
Любой граф, который сам не вкладывается, а если у него что-то стянуть или что-то удалить, то уже будет вкладываться.
Это означает, что любой его минор строгий уже вкладывается.
Раз он не вкладывается, значит, он должен быть запрещенным.
Ну и наоборот. То есть, вот тут точно так же.
Если мы одну реброулку опять удалим, то это уже будет вложимо.
И здесь тоже, если мы одну удалим, то будет вложимо.
Да, в том-то дело.
Определить, оценить в общем случае не получается.
Даже для вложения в тор.
Для вложения в тор их известны какие-то сотни разных.
Ну да, была бы граница, может, было что-нибудь перебирать, пытаться.
Нет, нет, нет, нет никакой границы.
Ну и получается, что тут полиномиальный алгоритм есть, но мы его не знаем.
И даже не можем оценить какая там степень полинома.
Вообще она может быть большой.
Ну хотя, с другой стороны, смотрите, она будет большой, если там будут какие-то большие эти запрещенные миноры.
Если их будет просто много, то это будет мультипликативная константа.
Если там 200 миноров вместо 100, то нужно 200 раз вместо 100 сделать проверку.
То есть это просто в два раза выросло.
А вот если эти миноры какие-то такие, которые сложно проверять, то тогда это уже будет более серьезное превышение.
Вот такая история.
Ну что, можно прерыв делать?
Давай сейчас на 5 минут.
Так, давайте вернемся к вопросу об NP-полноте.
И начнем с определения.
Ну а здесь есть два похожих понятия.
NP-трудность и NP-полнота.
NP-трудность
или по-английски NP-hardness.
Это немножко разные вещи.
NP-трудность означает, что
просто
значит B NP трудный
B NP трудный
если для любого A
если для любого A из NP, верно, что A сводится к B.
То есть можно сказать, что B NP трудный, если он
не менее трудный, чем NP.
То есть с его помощью можно жить все из NP.
Ну и на самом деле бывает, что это слово толкуется расширительно
и расширительно толкуется в смысле того, что означает вот эта сводимость.
Вообще то, как я определил, это не единственный вариант того, что такое сводимость.
В частности, может быть так, что B это вообще не задача распознавания.
Не задача с ответом да или нет, какая-то другая задача.
Тогда то, как мы определили, точно не подходит.
В широком смысле это то же самое, только вот здесь вместо
Ну, например, есть сводимость по куку
означает, что мы можем много раз про разные коды
спрашивать о принадлежности к B и потом еще как-то использовать результаты.
И это гораздо больше, чем как здесь, когда мы
спрашиваем один раз и прямо этот ответ и берем.
В общем, там есть несколько разных видов сводимости.
NP полната.
NP полната.
NP completeness.
Это означает NP трудность и плюс принадлежит к NP.
То есть язык B NP полон.
Если он NP труден, если B NP труден
и сам при этом лежит в NP.
То есть тут как бы есть сразу на сложности оценка сверху и оценка снизу.
То есть NP трудности это только оценка снизу.
NP полнота значит сразу и сверху, что в NP, и снизу, что
настолько же трудно и насколько
всего из NP.
Ну и отсюда из тех утверждений можно
опять же заключить несколько базовых правил.
Но самое главное для нас, наверное, следующее, что такое утверждение,
что если
если B NP труден,
если B NP труден
и если B лежит в P,
то тогда P равно NP.
Ну в частности, если он NP полон
и лежит в P, то тогда P равно NP.
Ну и из чего это следует?
Если B сам лежит в P и любой из NP к нему сводится,
то любой из NP тоже лежит в P.
И тогда NP вложено в P, а наоборот всегда вверх.
Ну вот это вот ключевое утверждение.
Ну и еще вот из транзитивности.
Мы можем написать, что если
если B NP труден,
если B NP труден и B слудится к C,
то C NP труден.
Вот. Ну или аналогично
можно сказать, что если B NP полон,
а C лежит в NP
и
B слудится к C, то C NP полон.
Вот.
Ну и вот это вот, да, ну вроде должно быть очевидно,
что первое, что любой слудится к B, а B слудится к C.
По транзитивности, значит, любой слудится к C.
А здесь мы еще прям явно добавили, что C при этом тоже в NP, значит, C тоже NP полон.
Соответственно, последняя строчка, это для нас ключевое утверждение будет
на следующей лекции. Да, потому что это способ получать новые NP полные задачи.
Да, если у нас уже есть какая-то NP полная задача, то можно новые вот так вот
из нее получать, вводя ее куда-то, если то, куда мы свели тоже лежит в NP,
то оно тоже будет NP полное.
Вот.
Так, ну дальше вопрос, с чего же надо начинать?
Значит, с чего надо начинать? И здесь ключевой задачей будет
задача о выполнимости булевых формул.
Ну и сначала давайте я приведу
пару примеров.
Потому что вообще-то у нас пока не было примеров нетривиальных свадимости вообще.
Так, значит, у нас будет
базовой, значит, базовой задач, у нас будет задача set
от слова set is viability.
Значит, выполнимость, выполнимость логических формул.
Да, то есть множество таких phi, да, значит, что
выполнимая логическая формула.
Вот, то есть можно, ну можно писать так, что существует x
такое, что phi от x равно единице.
Да, то есть можно сказать, что в таблице истинности для phi есть хотя бы одна единица.
Вот, это же NP, но скорее всего не
NP, потому что если у нас N переменных, то сколько у нас
строк в таблице истинности? Ну, два в степени N.
Соответственно, можно ее, конечно, составлять, но это будет экспедиционная задача.
Ну, если число переменных формулы сравнимо с ее длиной,
да, конечно, есть формулы, которые будут какие-то очень длинные уже сам по себе, да, но с маленьким
переменным. Тогда это еще можно явно в виде построить.
Вот, но если формула длинная и переменных там тоже много, то тогда просто так строить это уже будет экспедиенциальная работа.
Вот, с другой стороны, если нам дали конкретно x, конкретное значение для всех переменных,
то можно все подставить, вычислить значение и понять, будет единица или нет.
Значит, поэтому это действительно лежит в NP.
Вот.
Ну и на самом деле это будет NP-полная задача, но я думаю, мы это будем доказывать в следующий раз.
Сегодня еще посмотрим на несколько примеров.
Ну или, может, на основной идеи посмотрим.
Так, значит, пример.
Ну вот, рассмотрим задачу три раскраски.
Значит, trickle, three colorability,
colorability, три раскраска.
Значит, три раскраска, это, может быть, графов G,
что существует правильная раскраска,
значит, правильная раскраска, вершин G,
три цвета.
Ну а что это значит? Что значит правильная раскраска?
Ну, правильно значит, что там соседние вершины разного цвета.
Ну а математически что это значит?
Нож-то вершин, нож-то ребер.
А раскраска это функция C, которая отображает
нож-то вершин в нож-то 1, 2, 3.
А тогда правильно означает, что если у нас есть ребро,
значит, у в ребро,
значит, то тогда получается, что C от u не равно C от v.
Ну и давайте я покажу, как это вот
прикалывайнг сводится к задаче выполнение.
Ну вообще, когда такие конструкции
делаются, нужно как-то договориться о кодировании.
И вообще три цвета не очень удобно кодировать,
потому что удобно кодировать значения,
которых степень двойки, если было 4 цвета, было очень удобно
двумя битами кодировать любой из четырех цветов.
Но для трех цветов все равно 2 бита нужно,
но еще одну комбинацию нужно запретить.
Ну и самый простой способ это сделать, это считать, что вот это 1, 2, 3, это прямо в двоечной записи,
а два нуля запретить.
Для каждой вершины u нужно
завести две переменных.
Значит, две булевых переменных.
Значит, PuT и CuT.
И наложить условия, что они не два нуля, это вот дизьюнция.
Наложить условия
PuT или CuT.
Ну и как бы взять сам большую конъюнцию.
Но это нам пока задача, что это просто раскраска.
Ну, пока дают, что это вот значение 1, 2 или 3.
Нужно еще вот это вот потребовать.
Ну, если у нас два бита, то что означает, что они различны?
Да, для вершины u мы заводим две булевых переменных.
PuT и CuT. Каждое либо 0, либо 1.
Но за счет условий дизьюнции мы напрещаем комбинацию 0, 0.
А все остальные комбинации 0, 1, 1, 0, 1, 1 соответствуют вот этим триом цветам.
И кроме того, нам нужны условия на правильность.
Тут, соответственно, если u и v
это ребро, то тогда получается,
мы накладываем условия
PuT не равно PuT
или CuT не равно CuVT.
Ну а итоговая формула, это просто конъюнция всех условий.
Значит, это вот phi, это конъюнция
конъюнция тех условий.
Ну, все-таки давайте теперь это формально докажем.
И что нам нужно доказать, что граф раскрашивается,
то есть граф раскрашивается
только тогда, когда вот эта формула, по нему построенная,
выполнима. Значит, важно, что это и в ту, и в другую сторону должно быть.
Ну как мы это будем делать? Ну пусть раскрашивается, пусть есть раскраска.
Ну тогда мы просто
по нашему соглашению
присвоим значение переменных от значения цветов.
То есть 1 это будет 0,1, 2 это 1,0 и 3 это 1,1.
Вот. Утверждается, что это будет
выполняющий набор, то есть все условия будут верны.
То есть отсюда верны как раз 0,1, 1,0 и 1,1.
Ну и поскольку у соседних вершин разные цвета,
то условия на несовпадение тоже будут верны.
Ну а наоборот, ну наоборот тоже довольно легко.
Значит, пусть у нас есть какой-то
выполняющий набор.
А что значит, что выполняющий набор для конъюнции?
Ну это означает, что все элементы конъюнции истины.
Ну вот это вот условие означает, что у нас вариант 0,0
вершины не годится, но тогда можно считать, что если 0,1, то это цвет 1,
если 1,0, то цвет 2, если 1,1, то цвет 3. И это нам задаст раскраску.
Ну а вот эти вот условия зададут, что это правильная раскраска,
что действительно для соседних вершин разные цвета.
Ну потому что они либо в первом битве различаются, либо в втором, ну может даже и в обоих.
Вот, значит, вот такая картина.
Ну чего, понятно? Хорошо, давайте я еще один пример покажу.
Значит, еще один пример тоже для графов.
Значит, для графов это задача оклики.
Задача оклики. То есть это множество, тут уже пара.
Значит, пара G и K, но что пар G и K таких, что в графе G
в графе G существует полный подграф на K вершинах.
Вот, это тоже лежит в NP, потому что если граф задан,
то можно проверить, если подграф, если вот эти K вершины заданы,
то можно проверить, что это действительно клик.
Вот.
Ну а дальше, если, например, пытаться как-то напрямую это сделать,
например, для каждой вершины вести переменную,
будет она в клике или не будет она в клике,
то, в принципе, можно выкрутиться и
в таких переменах что-то написать, но это будет не очень удобно.
Там будет какая-то функция суммирования, ее нужно сравнивать с K.
Вот.
Всегда есть некоторые, как, помню, говорят, trade-off.
Trade-off между числом переменных и удобством записи.
Какая-то альтернатива.
Вот. Поэтому давайте я покажу, как сделать так, чтобы переменах было больше,
зато формула была попроще.
Вот. Значит, удобно делать такие переменные.
Ну тоже, скажем, P, It, Ut.
Если U, значит, если U это
It-я вершина клики.
Значит, It-я вершина клики.
То есть, будем считать, там априорникового порядка нет, но будем считать, что какой-то порядок введен.
И, соответственно, вот P, It, Ut означает, что
у It-я вершина клики.
Ну, можно наложить условия, что под каждым номером
есть только одна вершина, но на самом деле
это нам даже не обязательно. Если будет под It-ом номером
две вершины, то это на самом деле там
любую из них можно оставить.
Вот. Но нам все-таки нужно, чтоб хотя бы одна вершина была.
То есть первое условие,
что под
каждым номером
под каждым номером есть вершина.
А, делаем то же самое, что клика
сводится к САП.
Да, это я забыл сказать. Значит, клика
тоже можно формулу построить,
которая выполнима тогда, только тогда, когда в графе есть клика.
Да, соответственно, вот это вот i, значит, у столько же, сколько вершины в графе,
а i будет от 1 до k. Соответственно, под каждым номером есть вершина,
но это просто означает, что
ну, давайте я так напишу P i t 1 или и так далее, или P i t n.
Традиционно, число вершин обозначают за n.
Соответственно, для каждого i, значит, такая дизъюмция должна выполняться.
Нет, дизъюмция, что
есть вершина, значит, есть вершина
под этим номером.
Нет, еще раз, единица, если это i t вершина.
Нам нужна хотя бы одна i t вершина.
Хотя бы одна i t вершина, тогда какая-то такая дизъюмция.
Нет, тут вроде все правильно.
Вот, ну дальше нам что нужно?
Нам нельзя, чтобы одна вершина была под разными номерами,
а то иначе клика меньше размером получится.
Соответственно, под разными номерами
разные вершины.
Но это означает, что
неверно, что одновременно
P i u t и P i v t,
где, соответственно, u не равно v.
Вот.
Ну и наконец,
третье условие, что это, собственно, клика.
На что если i не равно v,
значит, есть
все ребра.
Значит, есть все ребра.
То есть, если i не равно v
и у нас верно, что
P i u t
и P i v t,
то тогда вот это вот uv
uv это ребро.
Так, ну а что значит uv это ребро?
Ну можно считать, что у нас просто для...
Вот это вот это как бы константа из матрицы смежности.
Ой, g, да. Спасибо.
То есть, вот это вот можно считать, что это логическая константа, взятая напрямую из матрицы смежности.
То, что uv лежит в e.
Ну, точнее не e, а вот это как бы принадлежность
логической константа,
взятая из
матрицы смежности.
Ну и тогда получается, что там не нужно какую-то арифметику разводить
и складывать единицы, проверять, что их будет k.
Ну тоже, если это как бы напрямую делать, там слишком длинные формулы получатся.
Нужно какие-то промежуточные шаги.
А тут все ясно, что у нас...
Вот этих формул k,
этих формул k умножить на n в квадрате, если грубо,
и этих формул порядка k в квадрате.
Нет, я же говорю, это логическая константа.
Это логическая константа, которую мы берем из матрицы смежности.
Либо 0, либо единица.
То есть, вот это вот будет единица, если такое ребро есть, и 0, если такое ребро нет.
В принципе, можно даже это раскрутить, сказать, что если тут единица,
то это точно выполнено, мы это вообще уберем.
Если тут 0, то что означает, что из чего-то следует 0? Это означает, что то, откуда следует, неверно.
И тогда можно сказать, что мы просто отрицаем вот эту штуку.
То есть, можно сказать, что если ребра нет, то тогда не может быть так,
что эта пара встретилась под итым и житым номером.
И тогда получается, что уже нет никаких константов, а просто есть то, как мы пишем формулу от тех переменных, которые есть.
Теперь давайте обсудим, почему это работает.
То есть, нам тут нужно, что...
Давайте я тут явно напишу, что и от 1 до k.
Это как мы используем число k.
Что пара g и k лежит в языке клика.
Тогда и только тогда.
Когда вот это такая построенная формула...
Но опять же, формула это конъюнция всех условий.
Когда форма, которая есть конъюнция всех условий, выполнима.
Ну, во-первых, лево-направо. Пусть у нас есть действительно клика.
Тогда мы любым образом пронумеруем ее вершины.
Вершины, соответственно, соответственно этой нумерации.
Действительно, под каждым номером у нас будет вершина, поэтому это верно.
Под равными номерами разные вершины.
Потому что мы взяли кое-какая вершина, их пронумеровали как-то.
Поэтому это тоже будет верно. Ну и ребра, раз это клика, значит это тоже будет верно.
Поэтому в эту сторону все довольно легко.
В обратную сторону пусть все эти условия выполнены.
Я здесь не накладываю условия, что под каждым номером ровно одна вершина.
В принципе, может так получиться, что под одним номером несколько разных вершин.
Мы выберем по одной вершине от каждого номера. Их будет как раз ка штук.
Значит утверждается, что это будет клика размера к.
Почему? Ну, во-первых, эти все вершины будут разные.
Во-первых, мы можем выбрать из кадея, потому что вот это условие выполнено.
Во-вторых, они все будут разные, потому что вот это выполнено.
Ну и в-третьих, это будет клика, потому что вот это выполнено.
Значит, действительно получается равносильно.
А я не писал, что ровно одна.
Ну, смотрите, может быть, например, такая картина.
Ну, например, вот есть треугольник.
Да, есть одна вершина, вот такая вот.
И еще другая вершина, вот такая вот. А между ними ребра нет.
Тогда можно считать, что и вот это вот под первым номером, и вот это вот под первым номером.
Это под вторым, это по третьим, это по четвертым.
И тогда все эти условия будут выполнены.
Так что так может быть.
Если не требовать, что они все разные.
Если не требовать, что под каждым номером только одна вершина, то может так и не будет.
То есть вот для такой номерации все условия верны.
Ну, мы из этих первых вершин одну возьмем и для нее покажем, что вот есть клика.
Вот.
Так, ну вот, значит, вот такая вот картина.
Так, что будем доказывать в следующий раз?
Ну, в следующий раз будем доказывать, что вот эта задача set, это самая универсальная задача.
Это называется теорема Кука-Левина.
Теорема Кука-Левина.
Что задача set.
Это НП полная задача.
Вот. Более того, будет НП полным ее частный случай.
Значит, и 3 set.
3 set тоже НП полная.
Значит, где буквка 3 означает, что это выполнимость циферка 3.
Значит, выполнимость 3 KNF.
KNF означает конъюнктивная нормальная форма, а 3 означает, что в каждой скобке 3 литерала.
То есть это примерно вот такая вот тука.
В общем, в каждой скобке 3 переменных или отрицания переменных.
А всего скобок может быть сколько угодно.
Ну, полинамиальное число.
Да.
Ну, в общем, в каждой скобке 3 переменных или отрицания переменных.
Да.
Да. В set любая, а в 3 set именно такой формы.
И это, на самом деле, если 2 set взять, то это на самом деле будет лежать в П.
То есть если в каждой скобке будет только 2 литерала, то это можно распознать
за полинальное время, а вот с тремя это уже НП трудная.
Но это вот немножко похоже на то, что раскраска в два цвета полинамиальная,
а в три уже тоже НП трудная будет.
Ну вот, соответственно, на следующей лекции в первых половине мы вот это докажем,
а потом будем доказывать НП полноту разных других задач, в том числе вот этих двух, но не только их.
Но, видимо, это потом еще уйдет на еще следующую лекцию.
Ну что, спасибо за внимание. До встречи.
