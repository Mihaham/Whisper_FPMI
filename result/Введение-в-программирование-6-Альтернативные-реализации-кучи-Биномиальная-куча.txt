Здравствуйте, начинаем.
Сначала нам нужно доделать то, что мы не сделали в
прошлый раз про бинарную кучу.
Во-первых, нам нужно добить hip-сорт, да, у нас там был
кусочек, который я назвал hipify, алгоритм построения
кучи за линейное время, там мы не все сделали.
И плюс еще несколько штучек, которые куча умеет в дополнение
ко всему, что мы уже про нее знаем.
Во-первых, мы давайте вспомним, как мы реализовали процедуру
hip-сорт.
Процедура построения, не так, процедура сортировки
данного массива с помощью кучи, есть у нас какой-то
массив A1 и так далее, An, алгоритм состоит из двух шагов.
Во-первых, мы делаем hipify, то есть строим кучу на данном
массиве, но при этом куча с максимумом в корне.
Строим кучу с максимумом корни.
То есть если обычная куча, это у нас, когда добавляется
требование кучи, что в корне лежит минимум, и соответственно
в каждой вершинке лежит число меньше либо равное
чем во всем по дереве, то здесь наоборот мы строим
такую кучу, где наоборот максимум находится ближе
к корню.
То есть это самое большое число, там в детях какие-то
близкие к самому большому и так далее.
И второе, N раз просто вызываем экстракт Мин, извините,
экстракт Макс, да, N раз вызвать экстракт Макс, и сам этот
результат, то число из корня, которое мы удаляем, мы
его никуда не выводим, просто запускаем ту реализацию
экстракт Макс, которая меняет корневое значение
с самым правым листом и уменьшая размер кучи
на единичку.
Тем самым мы как раз на каждом шаге сначала самое
большое число положим в конец, второе потом по
величине положим вторым с конца и так далее.
Ну и вот в итоге мы на том же месте, где исходный был
массив, посортировали его с привлечением от единицы
допонятных человек памяти.
Это in-place сортировка, то есть используем
от единицы дополнительных ячеек памяти.
Ну и нам осталось добить вот этот Hippie-Fi, что было
в прошлый раз.
Давайте мы будем считать, что мы все равно строим
кучу на минимум в корне.
То есть обычную кучу, когда в корне должно быть минимальное
значение.
Остаюсь, чтобы, например, минимум превратить в максимум,
можно изначально все числа умножить на минус 1, и потом
вот написать Hippie-Fi с минимумом в корне, и тогда у вас как
раз в корне будет лежать минимальное число после
умножения всего на единицу, значит до умножения это
как раз максимальное число.
Ну и потом, когда вы извлекаете, вы как раз извлекаете в
нужном порядке.
Или же нужно просто поменять значок сравнения, если раньше
у вас два числа были, одно меньше другого, то теперь
вам нужно наоборот сравнивать, что второе меньше первого.
Напоминаю процедуру, мы просто N раз, от N до единички делаем
севдаун.
Севдаун, а ты?
В прошлый раз мы доказали, что такая штука работает
за от N, там какой-то ряд, давайте напомним, что время
работы оценивается сверху рядом вот таким вот, M от
единицы до бесконечности, M на 2M, ну и все это умножить
на, на T, T, N, на T, T, N, то есть основной здесь, да, да, сорри,
извините, больше бы равно, конечно, от N до единички.
Вот, а симпатика сверху, это T, T, T, основной множитель,
и здесь какой-то ряд, который мы оценили сверху какой-то
константой, что все это не больше, чем какая-то
константа C, независимо какой у вас верхний предел
суммирования, хоть до бесконечности, хоть до любой константы,
можно оценить сверху одной, одним числом C.
Остается доказать только корректность, почему после
вот этого вот цикла у вас обязательно будет храниться
правильная куча, то есть почему она будет удовлетворять
требования у кучи.
Ну здесь, это просто доказать, значит, докажем индукции
PN в порядке, по E в порядке убывания, индукции E по E в порядке
убывания, что после севдаун от E в поддереве этой вершинки
будет корректная куча, что после выполнения севдаун
от E в поддереве этой вершинки будет лежать корректная
куча.
То есть скажем вот, когда E равно N, мы что делаем?
Мы запускаем севдаун от N, но понятно, что N это обязательно
лист, и поэтому его ниже опускать некуда, а севдаун
у меня берет какое-то число и пытается его просеять
ниже.
Если это число слишком большое, то он пытается его опустить
ниже к листю.
Так вот, севдаун от N, понятно, ничего не делает, потому
что опускать ниже некуда.
Севдаун от N минус 1 тоже, скорее всего, ну то есть для
листьев ничего не поменяется, севдаун для листа ничего
не сделает.
Поэтому здесь потенциально можно было бы вызывать,
можно было бы перебирать E не от N, а скажем от N пополам,
потому что для всех E от N до N пополам, это все равно
вершинка будет листом, и тогда севдаун ничего
не сделает.
Ну это не асимпатическая оптимизация, она всего лишь
уменьшит число запусков вдвое, а у нас в принципе
и так линейное время работы, поэтому не особо важно,
какая здесь константа, поэтому можно от N начинать.
Ну значит там база индукции какая-нибудь проста, если
E соответствует листу, то обязательно после севдауна
ничего не произойдет, ну собственно это корректная
куча в корне с E лежит.
Ну теперь переход, смотрим на какую-нибудь вершинку
E и на двух ее детей, соответственно 2E и 2E плюс 1.
Мы понимаем, что эти вершинки уже были когда-то рассмотрены
раньше, поскольку мы перебираем E в порядке убывания, значит
когда-то у меня вызвался вот такой севдаун от 2E
и вызвался севдаун от 2E плюс 1, и по предположению
индукции здесь лежат две корректные кучи, значит
здесь корректная куча и здесь корректная куча.
Ну тогда, собственно единственное, что может сломаться, это
нарушится может какой-то из вот этих двух неравенств,
что либо вот это число больше чем 2E, либо вот это число
больше чем 2E плюс 1, да, то есть может нарушиться
только вот одно из этих двух неравенств.
И мы хотим показать, что если мы вызовем один только
севдаун от E, севдаун от E, то обязательно все вместе
вот эта вся большая куча станет корректной.
Ну что-то похожее мы уже делали, давайте скажем,
что, вот у нас были 2 корректных кучи, давайте мы сначала
их склеим в одну путем дописывания вот здесь числа минус бесконечности,
тогда это понятно дело будет корректная куча, потому
что вот здесь неравенства не нарушаются, здесь не
нарушается, ну и здесь понятное дело, тоже ничего не нарушается,
потому что минус бесконечность, это самое маленькое число,
оно явно меньше, чем то что написано в детях, а потом
мы возьмем эту минус бесконечность, увеличим до правильного значения аитова. Вместо минус
бесконечности напишем аито. Получается, что мы число увеличили, минус бесконечность увеличили
до аитова. Здесь могли нарушиться какие-то неравенства, но мы знаем, что stiff down как раз
все нам починит. Мы знаем, что если была корректная куча и одно из чисел увеличили, а после этого
вызвали stiff down, то обязательно в результате будет корректная куча. Это вот одна из лемм с прошлого
раза, который мы делали, что если была корректная куча, число увеличили и запустили stiff down, то в
конце будет корректная куча. Было такое? Было, было. Ну все, в конце. Давайте напишем после. Мы, конечно,
явным образом здесь минус бесконечность мы не пишем. Это я просто написал, чтобы показать почему-то
все корректно, что если бы здесь была изначальная минус бесконечность, то была бы корректная куча,
и потом я число бы увеличил. Но наш алгоритм не ставит минус бесконечность, он сразу говорит,
что давайте я туда поставлю аито и сделаю stiff down. Ну тогда это будет просто корректно,
потому что если бы мы заменяли минус бесконечность на аито. После замены минус бесконечности на аито
и вызова stiff down от и получим корректную кучу. Значит, после каждой и-то итерации у меня будет
корректная куча с корнем в и, а значит, после последней итерации, после итерации, где и равно
единичке, у меня будет корректная куча с корнем в единице, то есть просто корректная куча.
Что я требовал доказать? Мы хотели по данному массиву построить корректную кучу, собственно
ровно это вот следует для нашего утверждения. Понятно? Хорошо, значит вот Hippie-5 мы построили
за линейное время, он строит кучу на данном на данном наборе элементов. Хорошо. Отсюда можно
сделать такое следствие из вот этого алгоритма hip sort. Не существует такой реализации кучи,
которая могла бы отвечать на экстракт мин за от единицы. Я напишу, которая могла бы делать экстракт
мин за от единицы. Иначе, если такая куча есть и она умеет делать экстракт мин за единицу. Так,
сейчас, секунду, секунду, секунду. Давайте мы ослабим немножко, потому что это зависит
все-таки от структуры кучи, и при этом могла бы делать тоже insert за единицу, insert за от единицы.
Потому что, если бы такая куча была, которая бы и insert, и экстракт мин делала бы за единицу,
то у меня был бы алгоритм сортировки за от n. Я сначала n раз делаю insert, потом n раз делаю
экстракт мин. И каждое издалеченное число я просто печатаю, тем самым сортирую мой массив за
линейное время. Это мы сегодня еще узнаем, что такое амортизированное, но то же самое. Что такое
амортизированное? Это значит, что если вы сделаете k-итерации, то суммарно все работает максимум за от k.
То же самое. Вы делаете там n insert, n extract, даже если здесь амортизированная вот единица, то
суммарно это значит, что все работает за от n, что противоречит нашей теории парового сортировку за
n log n. Иначе был бы алгоритм сортировки за от n. А мы с вами доказали, что алгоритм, основанный на
сравнениях, обязательно требует n log n, ω от n log n, действий для того, чтобы правильно завершиться.
Но здесь я явно не сказал, давайте я подчеркну где-нибудь, что куча обязательно должна быть
основана на сравнениях. В том же смысле, в каком мы говорили про сортировки, основанные на сравнениях,
что у нас объекты это какие-то камушки разноцветные, которые мы можем сравнивать только
явным образом, положив два камушка на весы. То есть мы не можем просто по виду двух камней сказать,
какой из них больше, какой меньше. Мы должны их прямо положить руками и сравнить, как у нас было
сортировки сравнений. То есть если бы у нас, например, было не так и мы бы знали, например, что числа,
которые мы кладем в кучу, это маленькие целые числа, не знаю там от n log n до 10, то тогда понятно,
что легко делать n extract за единицу, n insert за единицу, просто давайте для каждого числа от n log n до 10
и хранить, сколько раз оно встречается. Тогда insert это просто увеличить какой-то счетчик,
а extract min это пройтись от 1 до 10 и найти первый не нулевой счетчик. Но это как раз тогда получится
куча не основана на сравнениях, потому что она использует доп информацию о наших объектах,
что это не просто камушки, которые можно сравнивать, а вот маленькие целые числа, которые можно как-то
развить по корзинкам. Ну а в общем случае, если можно только сравнивать наши элементы и больше
ничего мы про них не знаем, то вот ничего лучше, чем ну не так, то нельзя одновременно extract
insert делать за единичку. Ну еще можно заметить, что наша бинарная куча, она как раз основана на
сравнениях, потому что в ней там основная операция это shift up и shift down, которые всегда просто берут
и сравнивают число с детьми или там с родителем. То есть наша куча, она как раз основана на
сравнении. Вот это сделали, хорошо.
Так, давайте теперь еще тогда поговорим про то, что умеет куча делать. Это про декоризки,
ну про вообще про особенности декоризки. Значит как у нас работала декоризки в простой
реализации на бинарной куче? Мы брали в качестве одного из аргументов позицию, не помню я там ве
называл ее или давайте пусть будет ве. Позицию ве вершины такую, что на соответствует числу,
которому нужно уменьшить, да, и мы сначала там делали, а в этой минус равно дельта. Мы вот то самое
число, на которое показывает указатель, уменьшаем на дельту. Это такая скорее абстрактная ситуация,
когда внешний сторонний пользователь прям вам тыкает на элемент в куче, то есть он знает,
где он лежит и говорит вам уменьшить его, пожалуйста, на дельту. Скорее всего внешний пользователь не то,
что не может вам показательный элемент, он скорее даже не знает, что у вас вообще какая-то куча
реализована в программе. Это скорее ваша задача понимать, чего хочет пользователь, какой именно
нужно объект уменьшить. Вот, и здесь возникает два возможных способа, как это может быть реализовано.
Способ первый это декрески по... Сейчас, сейчас, извините, нет, я перепутал, тут один есть вариант,
просто декрески. Нам просто как-то указывают идентификаторы элемента, которые нужно уменьшить.
По идентификатору я так скажу. То есть, ну проблема остается, что нам не могут сообщить просто число,
скажем, нам не могут сказать уменьшите, пожалуйста, х на дельту, напишите вместо ха х-дельта, потому что
из этих х-ов нашей кучи может быть много, во-первых, и непонятно, какой из х-ов менять. Во-вторых,
даже если их один или нам не важно, какой именно менять, к сожалению, куча не умеет быстро находить
данный элемент. Вот есть у меня бинарная куча, там много-много чисел, я вас прошу, найдите в ней
число 10 и уменьшите его. Но чтобы найти эту десятку, у нас нет никакого алгоритма, чтобы это
эффективно делать. То есть, лучшее, что мы можем придумать, это как-то спускаться просто по куче
снизу вверх, обрубаясь на числах сажем, которые больше, чем 10, потому что спускаться вниз не имеет
смысла. Вот, но как-то эффективно найти 10, скажем, за гарантированное от алгоритма, к сожалению, нет
способа или, по крайней мере, не придумано. То есть, найти число в куче проблематично, ну потому что мы
не поддерживаем никакую структуру, и это число может быть где угодно в куче. Поэтому лучше, на что
можем надеяться, это на то, что пользователь как-то дает какую-то все равно информацию о том числе,
которую нужно уменьшить. И вот самый простой случай, это когда идентификатор, это, скажем, номер
запроса, на котором соответствующее число было добавлено. Номер запроса, на котором соответствующее
число было добавлено. То есть, дикрийский будет работать теперь так. Есть у меня там insert,
extract min и так далее, вот все эти обычные операции, а дикрийский работает следующим образом. Уменьшите,
пожалуйста, вот тот запрос, который к вам пришел 13-м, на столько-то. То есть, вам не тыкают места в
куче, а говорят, вот тот элемент, который я когда-то 13-м положил вам, вот его уменьшите. Ну и это уже
чуть более реалистично. В той модели, когда мы там какая-нибудь фабрика, которая обрабатывает
заказы, нам приходит клиент и говорит, я вам тут дал заказ номером там 1, 4, 2, 3, вот, пожалуйста,
его нужно поскорее закончить. То есть, какой-то идентификатор, который однозначно позволяет
вам понять, про какой элемент идет речь. Вот. Здесь тогда нам нужно как-то по идентификатору
найти, где находится это число в куче. Но это можно сделать довольно просто. Смотрите, давайте
мы для каждого элемента кучи будем хранить соответствующему как бы коробочку, которая вот с ним
находится во взаимно-однозначном соответствии. То есть, говорим, что вот это идентификатор и он,
а это какая-то вершина кучи, да, это вершина кучи, и что вот они друг на друга ссылаются. То есть,
этот идентификатор хранит информацию, что соответствующий заказ лежит там-то в куче,
и наоборот, эта вершина кучи, зная, какой тут элемент, говорит, что ему соответствует
такой-то идентификатор. То есть, вот такое вот взаимно-однозначное соответствие. И потом,
если ко мне приходит запрос по какому-то данному идентификатору изменить какой-то элемент,
я просто нахожу соответствующую коробочку, смотрю, куда она ссылается, и этот элемент
уменьшаю. Делаю дикрестки уже от этой позиции в кучу. Получается, что вот это такое соответствие
позволит не отвечать на запрос. Но тогда их нужно еще научиться поддерживать и сохранять вот эти
вот стрелочки, когда мы делаем всякие сифтапы и сифтдаун. Вот давайте мы на это посмотрим.
Итак, давайте скажем, что num, нет, сейчас, сейчас, pointer, наоборот, pointer от t, это указатель
на вершину в куче, которое соответствует этому добавленному элементу. Указатель на вершину в куче.
Которое соответствует, соответствует этому добавленному элементу. То есть это вот как раз,
если мы знаем идентификатор, то по нему мы хотим понять, на какой элемент куча это указывает. Вот
такой pointer будем хранить. Ну указатель – это громкое слово, поскольку у меня все равно вся куча
хранится в массиве, то на самом деле это будет просто номер вершинки. Вместо указателя скорее
номер вершины. Ну и обратное соответствие нам тоже нужно. Давайте я его назову num. Num,
наоборот, от v, это обратное соответствие, то есть идентификатор в соответствующей вершине v.
Идентификатор в соответствующей вершине v. И нам нужно эти pointer и num корректно пересчитывать,
когда мы делаем в нашей куче всякие там свопы, когда мы поднимаем, что-то опускаем. Вот это все
нужно аккуратно переделывать. Например, когда мы реализуем coin-sift-up, мне может понадобиться
поменять местами значения, которые написаны вот в вершинке v и вершинке v пополам. Но тогда не
просто я поменяю значения, которые там лежат, но также мне нужно аккуратно вот эти вот стрелочки
все переназначить. Потому что если у меня был идентификатор соответствующий v и идентификатор
соответствующий v пополам, то теперь, поскольку эти числа поменяются местами, то эти стрелки
тоже нужно будет перерисовать. Давайте я нарисую красным старую конфигурацию.
Вот красное было то, что раньше, а синее то, что теперь должно быть. Потому что я их поменял
местами, и теперь v находится вот здесь. Значит, коробочка, которая соответствует,
но она находится там же, но нужно этот указатель как бы перенаправить в эту вершинку. То есть числа
поменяли, значит и вот эти стрелки тоже должны как бы перенаправиться. Давайте напишем тогда
простую процедурку. Я ее назову exchange, которая принимает номера вот этих двух вершин, для
которых нужно сделать вот этот вот swap, ну и меняет все вот эти стрелочки аккуратно. Ну тут int u, int v.
Так, я хочу ввести переменные, скажем k, это pointer от u и какой-нибудь m, это pointer от v.
Если это u, а это v, тогда у меня получается вот это вот, это идентификатор соответствующий v,
sorry, вот это вот m соответствует v, а k соответствует v половину или там u. Так, во-первых,
мне нужно поменять эти pointer, во-вторых, у них нужно num поменять, потому что вот эти стрелки
тоже меняются, то есть была стрелка сюда, станет стрелка сюда. Еще нужно не забыть поменять out
и out, это все я аккуратно сейчас сделаю. Во-первых, нужно поменять эти pointer, pointer out и pointer v.
Во-вторых, нужно поменять,
так. Плохо, да? Здесь я имею в виду num. Да, извините, num давайте напишем здесь.
Виноват. Тут везде num, а не pointer, потому что для вершинки мне нужен номер идентификатора,
а вот здесь наоборот. У меня есть два идентификатора, и мне нужно поменять указатели на элементы в куче,
куда они показывают. То есть мне нужно здесь поменять pointer kt и pointer mt, вот так. Неважно,
как я их назову, можно было бы поменять pointer num, потому что это все равно взаимно противоположные
вот такие вот соответствия, слева направо, справа налево. Так, ну и в конце не забываем сделать swap
аута и авета. Поменять местами значение утово и в этого элемента. Все. Вот такой exchange,
то есть это по сути обычный swap, только еще мы аккуратно с этими стрелочками работаем. Давайте
вот. Понятно? Хорошо. Ну и тогда если у нее есть такой exchange, то все операции shift-tap и shift-down
сейчас автоматически мы перепишем с его помощью, и у нас будет куча, которая поддерживает уже вот
эти вот соответствия между элементами кучи и идентификаторами. Давайте shift-tap только перепишем.
Shift-tap. Напоминаем, как он работает, принимает номер вершинки. Пока у нее есть родитель,
мы пытаемся с ним поменять. Пока v не равно единице, если авета меньше чем a родительская,
av пополам т. Тогда в обычной реализации я пишу здесь swap, а здесь напишу exchange, потому что кроме
значений мне нужно также поменять все эти ссылочки. Поэтому я просто напишу exchange, v и v пополам.
Потом v поделю, вместо v напишу родителя, ну а иначе break.
То есть shift-down остается точно таким же, только вместо swap-a, exchange. Все. А дальше, ну то есть
дальше у меня shift-down точно также переписывается. Всюду, где у меня там был swap, я делаю exchange,
соответственно. Ну а все операции, поскольку они выражаются через shift-tap и shift-down, то там insert,
getmin и так далее, они все останутся таким же, просто используя shift-tap и shift-down. А дальше,
когда мне приходит запрос decrease key, какой-нибудь идентификатор t и дельта, мне нужно вспомнить,
чему соответствует этот идентификатор. То есть посмотреть на pointer от t, просто pointer от t,
и этот pointer от t как раз ведет меня в ту вершинку в куче, которую нужно уменьшить. Я считаю,
что там t-шки, это номер запроса в общем порядке. Пришел первый, второй, третий и так далее запрос.
То есть вот эти t-шки как бы сплошняком номируются, тогда я могу хранить просто массив этих
pointer и для каждого идентификатора я знаю, куда он ссылается в кучу. И тогда, соответственно,
я просто считаю сам этот свой pointer, поддерживаю его всегда в процессе работы программы, посчитал
pointer, знаю, куда он ссылается и уменьшаю вот этого число на дельту. А от pointer от t уменьшу на
дельту. Ну и вызову с фитапом. Вот и все, вся реализация дикриски, если мне не показывать кучу,
а говорят просто там номер элемента в порядке добавления. Вот, вопросы. Хорошо. Так, вот,
ну дикриски как по-другому. Когда пользователь не знает, какой именно элемент где хранится,
мы сами должны как-то про это узнавать. Ну вот никак по-другому, кроме как давать какой-то
идентификатор элемента, ну непонятно, как это по-другому можно реализовать. То есть все равно
пользователь как-то должен знать, какой именно элемент ему нужно уменьшить, поэтому вот это t
он сам откуда-то берет, ну а мы его обрабатываем. Мы его сами уже обрабатываем. Так, с дикризом
разобрались. Вот, и оказывается, что с помощью этого дикриза и с помощью вот этих указателей можно
делать еще и рейс из кучи. Прям вот удалять элементы с кучи. И здесь есть вот, вот здесь как
ростки из два подхода. Первое это удаление по указателю, удаление по указателю, ну или по
идентификатору. И второе это удаление по значению, удаление по значению. Вот, первое удаление по
указателю. В дополнение к нашим четырем запросам insert, getmin, extractmin и дикриски появляются еще
запросы вида erase t. Это значит, что тот элемент, который был добавлен на t этом шаге, нужно теперь
удалить из кучи. Там, не знаю, приходит клиент, говорит, что вот у меня, мой заказ, который я вам
тетин дал, вы его так долго исполняете, что мне его даже не надо уже все оставить, не выполнять его,
удалить его из кучи своей. Вот такой поступает запрос удаления заказа. Но мы его просто должны
удалить из кучи. И в случае, если нам вот дается этот идентификатор t или нам прям показывают,
какой элемент нужно удалить, здесь реализация очень простая. Как удалить можно из кучи? Ваше
предложение. Что сделать? Да-да-да, хорошая идея. Действительно, можно так. Сейчас поступило
такое предложение. Вот если мне известен идентификатор или сразу указатель, мы понимаем,
что по идентификатору можно построить указатель. Вот у меня есть вершинка v,
которую нужно удалить. Тогда давайте мы возьмем последний элемент кучи, аэнный. Поменяем местами
аэнное и авэте, уменьшим размер кучи на единичку и сделаем сифтап от сифтдаун от v. А нам это,
кажется, не нужно. А, возможно, сифтап придется запустить. Да-да, это может быть. Действительно,
вот есть элемент, который нужно удалить. Берем аэнное, ставим его на его место и, соответственно,
уменьшаем кучу на единичку. Тогда у меня что? У меня есть корректная куча на n-1 элементе,
в котором вот этот элемент изменился, было авэто и стало аэнным. Ну и, соответственно,
в зависимости от того, увеличилось это число или уменьшилось, нужно сделать сифтап или сифтдаун.
Тогда вроде все работает. Я просто забываю, что это когда-то было, переношу его в область
недопустимых значений и делаю тут сифтап или сифтдаун. Да, так вроде работает. Можно немножко по
другому. Можно сказать, что давайте мы сюда поместим число минус бесконечность, ну или такое число,
которое меньше, чем все элементы в куче просто. Запустим сифтап, поднимем его в корень и потом
просто удалим. Еще раз, авэто равно минус бесконечность, кладем туда что-то очень
маленькое, потом запускаем сифтап от v, после чего это как раз минус бесконечность всплывает
в корень, ну и потом делаем экстракт мин. Экстракт мин. На этом шаге как раз вот эта
минус бесконечность уйдет в конец, отрежется, ну и куча корректной перестроится опять. Да,
можно так и так, как удобно. Вот, это первый случай, да, простой, когда у меня прям,
нам показывают явно, то есть либо сразу показывают, какую вершинку нужно удалить,
либо мы сами это понимаем по идентификатору. Сейчас, сейчас, секунду.
Да. Отрезаем эту ветку и потом запускаем сифтап отсюда. Ну, мы сначала понимаем,
как число изменилось, уменьшилось или увеличилось. И мы знаем, что в зависимости, ну то есть у нас была
лемма, что если была корректная куча и число увеличилось, то нужно запускать сифтап и все
будет корректно. А если число уменьшилось, нужно вызвать сифтап и все будет тоже корректно.
Что? Ну, по сути, это одно и то же. Декрестки. Вы про это или вот это?
Ну, по сути, это все равно одно и то же, потому что мы меняем значение в элементе и потом,
там чего, сифтап. Ну, то же самое. Просто я как бы это расшифровал без использования декрестки.
Так, это простой случай. Теперь второй случай – удаление по значению. Это когда мне не говорят,
какое именно нужно удалить, а сообщают просто о значении. Нужно из кучи удалить элемент со
значением x. И вот здесь опять та же проблема, которая была в декрестки, что нельзя уменьшать
по значению, потому что я не могу в куче быстро найти этот элемент. Вот мне говорят raise x. И мне в
идеале хотелось бы найти, где это x влит в куче, но, к сожалению, у меня нет такого способа. У меня
нету процедуры, которая бы находила, где x влит в куче. Найти, где x лежит в куче. У меня такого нету.
Мы не умеем это эффективно делать, потому что куча не поддерживает никаких свойств, которые
позволял бы быстро находить данное число. Поэтому придется здесь что-то придумать другое. А именно,
давайте мы поддерживать на риту с нашей исходной обычной кучей кучу удаленных элементов. У меня
теперь в решении будет не одна куча, как было всегда до этого, а две. Обычная куча, а также куча
удаленных. Удаленные элементы. И тогда вместо raise x, вместо удаления ее из исходной кучи,
я просто добавлю x в множество удаленных. Ничего удалять не буду, буду только вставлять,
наоборот, в множество удаленных. А дальше у меня, ну, на самом деле мало что изменится,
потому что когда приходит обычный insert, скажем insert y, тогда нужно просто y сюда
поместить. Там decrease key тоже, если мне как-то ссылаются, да, то есть если мне дают как-то
идентификатор элемента и говорят это уменьшить, ну, я тоже его спокойно уменьшу. Проблема только в
get mini и в extract mini. То есть мне нужно как-то найти минимальный элемент вот в этой куче с учетом
того, что какие-то из нее еще извлечены, какие-то из нее уже удалены. Я утверждаю,
что это сделать довольно просто. Давайте я назову эту кучу a, эту кучу d. Как будет тогда
работать get min? Он работает так. Пока минимальные элементы в наших двух кучах a и d совпадают,
мы их оба удаляем. Пока, но я так вольно напишу a.get min. Равно d.get min. В том смысле,
что если я запущу на каждой отдельной куче get min, то вернется одно и то же число, то я
этот минимум из обеих куч извлекаю. a.extract min и d.extract min. А в конце у меня что? У меня это
условие будет уже не выполняться. Когда я из вайла выйду, у меня это условие уже не выполняется. То
есть здесь в корне лежит какое-то число, которого здесь нет. По крайней мере так хочется, что здесь в
корне будет число, которого нет здесь. И тогда соответственно в качестве ответа нужно просто
его вернуть. return a.get min. Вот как поменяется запрос get min на случай, когда у меня две кучи,
так понятно ли то, что тут произошло? Ну вообще да, это верно. Сейчас, сейчас, одну секунду. Да,
это хорошее замечание, тут нарушается в каком-то смысле следующее требование. Но это такое, мы не
будем об этом задумываться. Да, да, да, я понимаю, но здесь можно по-разному на это претензию ответить,
что, во-первых, представим, что у нас всего будет n операций вот к этой куче, к этой структуре,
всего n операций. Там, не знаю, сначала куча инсертов, потом куча рейзов, опять куча инсертов,
куча рейзов и так далее. И никогда, скажем, get min я не удаляю и корень тогда не удаляю. Но тогда
все равно каждый запрос за логарифм обработается, за log n, где n это общий число запросов, потому что
суммарно здесь будет максимум n элементов, ну и поэтому как бы глубина тоже максимум всегда логарифм.
Поэтому все равно как бы будет логарифмическая оценка. С другой стороны, у нас логарифм не от числа
элементов в куче активных, а как бы числа всего запросов. Ну такой метод, да, это конечно его изъян,
что логарифм не от числа активных элементов, а от общего числа запросов. Ну что есть? Что есть?
Так, нам надо доказать корректность вот этого, но здесь все довольно просто. Сейчас, извините.
Почему это все верно? Можно просто заметить, что если у меня все запросы корректные, то есть у меня
не поступает запрос, а, скажем, удаление несуществующего элемента, тогда у меня всегда
будет выполнено, что d вложено в a. Множество удаленных всегда является под множество,
множество добавленных. И давайте я тогда нарисую следующую картинку. Вот пусть a это какая-то такая,
ну расположим эти числа на вещественной прямой, ну или там наши элементы упорядочим как-то в
порядке возрастания, и у меня какие-то элементы как бы убиты, да, они какие-то были удалены из кучи.
То есть в черточке это те, которые есть в a, а в крестике те, которые есть aggression, которые
нужно удалить. Тогда как найти минимальное добавленное, но еще не удаленное? Давайте
просто идти слева направо и находить первую черточку, которая не зачеркнуто крестиком,
да, найти самое левое добавленное число, которое еще не было удаленным. Ну и собственно ровно
это мы и делаем, мы идем слева направо по палочкам слева направо по крестикам, пока они совпадают,
это значит, что элемент был добавлен и удален. Значит я должен удалить его из обеих кучек и
И вообще считаю, что здесь ничего нет.
Опять то же самое. И впервые, когда я вижу, что здесь элемент есть,
ну то есть минимум здесь левее, чем вот здесь, то есть я нахожу первое минимум вот здесь и первое минимум вот здесь,
они различны. Значит, я какой-то этот элемент добавил, но еще не удалил.
Собственно, его и нужно вернуть.
Вот и все, такое простое объяснение.
Ну и экстракт-мин точно так же. Если я нашел минимум,
то в экстракт-мине нужно его не найти, а удалить.
То есть экстракт-мин пишется точно так же.
Главное, что нам нужно поудалять вот эти вот первые элементы, пока не найдем первый неудаленный.
Ну, проблемы не будет, если, скажем, нам говорят там insertX два раза,
ну давайте не X, а давайте Y.
И потом говорят eraseY один раз.
И будет иметься в виду, что Y нужно как раз один раз удалить.
То есть сколько удаляем, столько его и нужно вычеркнуть.
Ну тогда все будет хорошо, потому что я сначала, ну и допустим там все остальные числа больше.
Тогда как раз я сначала найду минимальное число Y, его удалю из обеих пуч,
а дальше здесь будет Y, а здесь не будет.
Ну как раз все как надо.
На вот этой картинке у меня в одном месте там, не знаю, три палочки и два крестика.
Тогда я удалю две палочки и два крестика, и одна палочка останется как раз то, что мне нужно.
Здесь мы тоже все показали.
Еще одно, я допишу, что это все работает в случае корректности запросов.
Это все работает при корректности запросов.
То есть что несуществующие элементы не должны удаляться.
Несуществующие элементы не должны удаляться.
Ну иначе все может сломаться, потому что, например, если у меня вот здесь стоит палочка,
и где-то левее стоит крестика, которая не соответствует никому добавленному числу.
Скажем, не знаю, мы добавили двойку, а удалили единицу.
Ну тогда мы эту единицу будем всегда находить, и до этой двойки даже не доберемся.
То есть в том случае мы поймем, что первые минимальные элементы различные, поэтому это равен минимум.
Но возможно и не так, потому что двойка тоже удалена, а, скажем, тройка остается.
И это все из-за вот этой фиктивной единицы, которая удаляет несуществующие элементы.
Тогда все эти рассуждения не работают.
Ну а если же работают, и тогда действительно множество удаленных является под множеством множества добавленных,
тогда все корректно.
Но мы считаем тогда, что запросы корректные, и такого не возникает.
Хорошо.
Тогда идем дальше.
Да.
Да.
Да.
Да.
Ну опять, если у нас есть какая-то верхняя оценка, начало запроса, можно завести массив такого размера.
Если нет, то у нас сегодня же будет структура данных вектор, которая как раз умеет это делать.
Она умеет добавлять элементы в конец.
Так, давайте я здесь еще расскажу про вообще другие реализации куч.
То есть мы вот рассмотрели сейчас конкретно только бинарную кучу, двоичную кучу,
которая по сути на все отвечает за логарифом, кроме того, что гитмин может зовут единиц.
Есть куча других еще реализаций куч, которые, возможно, в некоторых местах достигают лучшей асимптотики.
Но все там точно не будет от единицы и в инсерте, и в экстракт-мини,
потому что мы доказали, что не может быть и того, и того одновременно, если это нормальная куча на сравнении.
Есть, например, куча фибоначи,
которая позволяет делать декрески за от единицы амортизировано.
Мы вот сегодня посмотрим, что значит амортизировано.
Но, грубо говоря, можно считать, что каждый декрески выполняется как бы в среднем за от единицы.
То есть, возможно, каждый конкретный декрески работает и долго, может потребовать большого количества операций.
Но если вы их делаете много, скажем, если вы суммарно сделаете n операций,
то суммарно все эти декрески будут работать за от n.
Это вот как раз такая учетная стоимость, что каждая конкретная, возможно, работает долго,
но суммарно они все работают за от n.
Вы там сделали n раз декрески, и тогда суммарно они работают за от n, хоть каждая конкретная может работать долго.
Ну а все остальное, все остальные, за от логен амортизировано.
И тогда с помощью такой кучи фибоначи мы ее, наверное, рассматривать не будем,
но с ее помощью можно некоторые алгоритмы, по крайней мере, в теории улучшить на них эту точку.
Вот, например, я в прошлый раз говорил, что будет у нас когда-то алгоритм Dijkstra.
Алгоритм Dijkstra. Нам не нужно понимать пока что, что это такое.
Можно просто сказать, что это какой-то алгоритм на графе.
У нас дан граф с n вершинами и n ребрами.
С n вершинами и m ребрами.
И в процессе нашего алгоритма, в процессе алгоритма Dijkstra, мне нужно сделать m раз декрески, куча, m раз декрески и n раз экстракт-мин.
Еще раз повторюсь, нам пока что не обязательно понимать, как работает алгоритм Dijkstra, но если вы это знаете, то сейчас будет хорошо.
Там нам важно, что нам нужна какая-то структура данных, которая умеет делать все, что умеет куча.
Вот этот декреский, экстракт-мин, get-мин, insert и так далее.
И в ней нужно m раз делать декрес и n раз делать экстракт-мин.
И тогда, смотрите, обычная бинарная куча справится со всем этим за логарифом.
Потому что что декреский там работал за логарифом, что экстракт-мин работал за логарифом.
Поэтому асимптотика, если мы будем использовать бинарную кучу алгоритма Dijkstra, у меня будет асимптотика n плюс m на лог n.
А если мы используем кучу Fibonacci, то у меня будет асимптотика m плюс n лог n.
Потому что, еще раз, у меня декреский как раз за от единицы работает амортизировано.
В том смысле, что если мы сделаем много операций, то можно считать, что каждый работает за от единицы.
То есть, суммарно, вот эти вот все декрески работают за от m.
Плюс еще log раз, извините, n раз нужно за логарифмическое время сделать экстракт-мин, тоже амортизировано.
В сумме это даст добавку n лог n.
И в случае, когда у нас, например, m сильно больше, чем n, у меня куча Fibonacci позволяет сделать алгоритм Dijkstra быстрее.
То есть, здесь у меня m умножалось на логарифм, а здесь m идет просто линейно и без умножения на логарифм.
То есть, получается, в зависимости от того, как именно вы эту кучу реализуете, у вас разные другие алгоритмы будут, возможно, работать быстрее.
Ну, по крайней мере, с точки зрения теоретической оценки.
Проблема кучи Fibonacci как минимум в том, что там очень большая скрытая константа, там нужно очень много всего хранить.
Она гораздо гораздо объемнее, чем наша бинарная куча, которая на массиве, по сути, хранится.
Там нужно гораздо больше всего хранить.
Поэтому здесь константа в большом, к сожалению, сильно большая.
И не всегда на практике это будет лучше, чем вот это.
Но, тем не менее, с точки зрения теории или для очень больших NM, когда компьютеры ускорятся в тысячи, десятки тысяч раз, вот это будет лучше, чем вот это гарантированно.
А сейчас давайте рассмотрим еще одну кучу, биномиальную.
Биномиальная куча.
Вот, и раз это куча, то она, конечно, умеет делать все, что умеет делать бинарная куча.
Давайте мы восстановим все эти действия.
Insert, get mean, extract mean, decrease key.
Если постараться, то можно также сюда добавить erase, потому что мы можем хранить дополнительную кучу удаленных элементов.
Но здесь еще появляется новое действие, здесь появляется действие merge.
Слить две кучи, объединить две кучи в одну.
То есть представьте, что у вас было какие-то две кучи, и вам пришел запрос, что нужно их объединить в одну.
То есть построить какую-то новую кучу, которая хранит информацию обо всех этих элементах по одному разу и только их.
Каждый элемент отсюда, который вы переместите туда в один большой список.
Продолжая нашу странную метафору с заводом, у вас два завода объединились,
а им нужно все еще сделать те же самые запросы, обработать те же самые заказы,
но вот они их сваливают в одну кучу и опять обрабатывают теперь уже всем новым большим заводом вместе.
Вот, то есть новость только то, что появляется merge.
Это во-первых, это куча более мощная, поскольку позволяет делать merge за эффективно, то есть мы это будем довольно быстро делать.
И во-вторых, у меня будет такое, что она на самом деле нужна, чтобы по ней построить кучу фибоначи.
Она дает способ построить кучу фибоначи.
То есть фибоначи очень сильно базируются на том, что мы сейчас будем делать, но мы туда не пойдем.
Окей.
Чтобы определить, что такое биномиальная куча, мы сначала определим биномиальное дерево.
Биномиальное дерево.
Порядка К.
Порядка К.
Биномиальное дерево порядка ноль, это вот такое дерево, просто одна вершина.
Биномиальное дерево порядка один, это вершина с одним сыном.
Биномиальное дерево порядка два, это вершина с одним сыном,
в которой еще присоединено то же самое дерево, вершина с одним сыном.
Ну и давайте Т3 еще нарисую.
Вот, кажется так.
В общем случае формула такая, если у вас есть дерево ткта
с каким-то корнем, то вы можете внести его в кучу фибоначи.
В общем случае, если у вас есть дерево ткта, то вы можете внести его в кучу фибоначи.
Вот формула такая, если у вас есть дерево ткта
с каким-то корнем, то вы можете к этому же корню подвести еще одного сына и здесь подвести еще одну ткта.
Вот здесь ткта и здесь ткта.
И все это вместе будет тк плюс первое.
То есть если у вас есть дерево катового порядка, вот такое,
вы просто его дублируете и подвешиваете один из корней к другому.
И это будет дерево следующего ка плюс первого порядка.
Ну и все вот эти получается ровно так.
Ну например, у вас есть дерево нулевого порядка, вот это,
и вот дерево нулевого порядка, вот это, вы одно подвесите к другому и получаете дерево первого порядка.
То-что самое здесь. Вот есть дерево первого порядка, вот есть дерево первого порядка,
вы одно подвесите к другому и получаете Т2.
Ну и тут, раз, два, и одно подвесите к другому.
Почему они биномиальные?
потому что, например, на m уровне
дерева tk
находится t из m пока вершин.
Так, я надеюсь, что вот это обозначение всем знакомо.
Если нет, то на семинарах. Вот эта задача про количество вершин на каком-то уровне в
катом дереве, что это какой-то биномиальный коэффициент, она будет на семинарах.
Попросите у семинаристов объяснить, что это такое, если не знаете. Вот, но эти цешки
как раз и называются биномиальными коэффициентами. Они возникают, если вы там
возводите в степень какую-нибудь сумму. А плюс б в степени n, вот известный бином
ньютона, если вдруг не знакомо, что а в степени k, b в степени n-k на c из n по k.
И вот эти вот биномиальные коэффициенты, с помощью которых мы можем раскрыть бином
ньютона, они как раз вот здесь и будут. И это называется биномиальные коэффициенты,
поэтому дерево тоже биномиальное. Так, ну хорошо, вот мы определили, что такое дерево.
Ну и мы в вершинах этого дерева будем хранить наши элементы. В вершинах деревьев, в вершинах
дерева храним элементы. Элементы нашего мульти-множества, которые мы добавляем.
Мульти-множество. Которым мы работаем, там удаляем, добавляем и так далее. Уменьшаем.
Вот. Опять, если у меня есть дерево, то у меня возникает требование кучи,
это что каждое число, записанное в вершине, должно быть меньше либо равно, чем все,
что написано в поддереве. То же самое, что было в бинарной куче. Требование кучи.
Число, записанное в вершине, в вершине В, не превосходит чисел, записанных в поддереве В.
Вот. И картинка будет такая же, как раньше, что число, написанное в родителе, должно быть меньше
либо равно, чем все числа в детях. Только теперь детей может быть больше, чем два. Вот уже на этой
картинке у вершинки есть три ребенка, в Т4 будет четыре ребенка и так далее. Поэтому у меня
возникает больше неравенств. Но смысл такой же. Число, написанное вот здесь, должно быть меньше
либо равно, чем все числа в детях. Вот так. Требование кучи. Ну и, наконец, биномиальная куча.
Это набор биномиальных деревьев, причем все они попарно различных порядков.
Набор биномиальных деревьев
попарно различных порядков.
Ну, например, у вас может быть Т2 и Т3. Это корректная биномиальная куча. То есть у вас есть
отдельно дерево Т2 лежит, отдельно Т2, отдельно Т3. Они вместе образуют корректную биномиальную
кучу. А если, например, у вас есть две одинаковые, там не знаю, Т1, Т3 и Т3, это уже не корректная
биномиальная куча, потому что есть две кучи одинакового порядка, с одинаковым индексом. Извините,
два дерева с одинаковым индексом мы такое запрещаем себе. Какой в этом смысл? На самом
деле, вот это вот разложение по деревьям, разложение биномиальной кучи по биномиальным
деревьям, оно соответствует разложению в двоичную систему исчисления числа n элементов в куче.
Потому что, смотрите, легко заметить, что вот, скажем, катом деревя у меня всего два степенька
вершин. В дереве ТК содержится два вкаты вершин. Ну, это совсем легко понять, потому что, если у
вас здесь два степенька, то чтобы получить ТФ степенька при степеньке, вы сливаете два дерева
одинакого размера, получаете дерево в два раза больше, как раз два в ка плюс первый. Это совсем
простое утверждение. Но тогда как раз у вас вот здесь два во второй элементов, тут два в третьей
и так далее. И если все эти порядки попарно различны, то это как раз разложение в двоичную систему,
то есть по степеням двойки, общего числа элементов. Да, если, например, у вас, то есть вот здесь сколько?
Четыре плюс восемь. Если у вас всего в куче двенадцать элементов, то они раскладываются следующим
образом. У вас есть дерево на четырех элементах, дерево на восьми элементах. И так для любого n.
Да, ну то есть какая-то часть, просто какие-то четыре будут здесь, какие-то восемь будут здесь.
Они произвольны, нам не важно, как они распределяются по деревьям, нам лишь важно,
что они все где-то здесь присутствуют. Ну тогда, например, чтобы найти минимум,
нужно просто посмотреть на минимальное значение в каждой из деревьев, в каждом.
Ну их не может быть очень много, потому что у них размер экспенциально растется номером.
Чем больше k, тем сильно больше.
Ну если у числа в двоечной записи n единиц, то оно хотя бы само по себе уже два в степени n.
И в нем будет n деревьев. Мы сейчас все докажем, это все нормально будет работать. Мы все докажем
обязательно. И так, вот у меня есть несколько деревьев, и суммарно их размеры равны в точности n,
то есть по сути это разложение n по степеням двойки. И мы будем их хранить вот в таком
возрастающем порядке, в порядке возрастания этих индексов, в порядке возрастания номеров,
точнее порядков всех деревьев. Тогда давайте понимать, как обрабатывать, скажем, самый простой
вопрос GetMin. Как обрабатывать GetMin? Ну мы сказали уже, что каждый элемент лежит ровно в одном из
этих деревьев, и если мне нужно найти самый маленький элемент среди всех, то мне достаточно
посмотреть на самый маленький в каждом из деревьев и среди них выбрать минимум. Вот если у меня есть
всего две кучи, то мне нужно посмотреть минимум вот здесь, минимум вот здесь, и взять из них
самое маленькое. Ну потому что если у меня весь список разбит на непредсекающие корзинки,
то минимум во всем массиве это минимум среди минимумов во всех корзинках. Поэтому тут можно
сделать следующее. Ну давайте я не буду писать код, я скажу, что просто словами, да, найти
минимальный,
минимальный
корень среди всех деревьев.
среди всех деревьев. И это опять будет работать, потому что, так сейчас, а это опять будет работать,
потому что в каждом дереве минимум обязательно в корнях из-за требования кучи, да, требования
кучи, в частности, мне говоришь, что минимальное число в дереве всегда находится в его корне,
и тогда если у меня корень каждого дерева это минимальное число, то я просто прохожу по всем
корням и беру самое маленькое. Да? Вот, а сколько это работает? Ну, смотрите, если всего в куче
n элементов, если всего в куче n элементов, то какие порядки деревьев допустимы? Да? Да, да, да. Ну,
каждый элемент ровно один раз присутствует, поэтому суммарный размер всех деревьев, он, конечно,
равен в точности n. Так вот, если всего в куче n элементов, то я утверждаю, что порядки вот этих
вот деревьев, они максимум логарифом, то все деревья в куче имеют порядок не больше, чем, ну,
я напишу так, двоиченалберифмен, округленный вверх, ну, короче, не больше логарифа, потому что мы
знаем, что в катом дереве два вката вершин, даже, даже вниз, даже вниз можно сказать, но неважно,
короче, даже можно вниз, потому что мы знаем, что в дереве порядка k у меня два в степеника вершин,
и это два степеника должно быть меньше броной, чем n, да, потому что, ну, там какие-то элементы же
лежат неповторяющиеся, значит, обязательно это должно быть не больше, чем общее число элементов n,
раз мы еще и по разным деревьям разбросываем, поэтому у них у всех порядок максимум логарифом,
а значит, поскольку у меня все порядки различные, то у меня ноль может встречаться максимум один раз,
единицы максимум один раз, и так далее, вплоть до логарифма, значит, всего деревьев максимум логарифм,
всего деревьев куча, куча, не больше, чем логарифм, не больше, чем двоиченалберифмен, ну, а значит,
вот этот проход по корням, он работает за логарифм, я просто перебираю все, все деревья,
нахожу у них, ну, смотрю на корень, и выбираю средних минимум, это работает за логарифм. Согласны?
Кажется, что да. Хорошо, get mean мы обработали. Дальше decrease key, давайте возьмем decrease key,
ну, здесь опять вот эта вот дилемма насчет того, как именно указатель нам задается,
давайте в простом случае, когда нам прям тыкают на вершинку, которую нужно уменьшить. Вот нам
тыкнули на вершинку, которая находится в позиции ptr, и нужно уменьшить ее значение на дельту. Ну,
тогда все абсолютно точно так же, как было в бинарной куче. Вот есть у вас число какое-то,
вам нужно его уменьшить, было какое-то x, нужно превратить его в x-delta. Тогда, чтобы сохранилось
требование кучи, мне нужно просто это число поднимать до тех пор, пока все не подчинится.
То есть, по сути, мне нужно просто запустить тот же самый сифтап,
тот же самый сифтап, который поднимает вершинку, то есть сравнивает вершинку с родительской и
меняет значение, пока у меня не начнется выполняться эта неравенство, пока все я не подчиню.
Ну, чего? Нужно еще там аккуратно доказать корректность, но мы аналогично делали в
бинарной куче. Если у меня была корректная куча, одно число уменьшилось, я вызывал сифтап,
то в конце будет корректная куча. Тут то же самое, только у меня дерево как бы не бинарное,
а сколько угодно ветвящееся. У вершинки может быть много сыновей, но это неважно,
это не влияет на корректность нашего доказательства. Сифтап все равно даст нам в конце корректную кучу.
За сколько это работает? Ну, это работает за глубину дерева. Работает за глубину дерева,
но легко тоже видеть, что вот эти деревья, как мы строим ткт, у катого дерева глубина ровно к,
потому что мы там взяли катое дерево. Чтобы получить к плюс первым, мы взяли ткт,
мы взяли ткт, подвесили к его корню еще одно ткт. Получается, что если здесь глубина была к,
то здесь глубина как раз на один побольше. Здесь как раз глубина на один побольше.
То есть глубина ровно такая же, как порядок. А значит, если мы возвращаемся сюда, у меня все
порядки максимум логарифм, поэтому глубина тоже вся максимум логарифм. В итоге дикризки тоже
работают за отлогом. Понятно? Ну, просто за глубину, а глубина максимум логарифм.
Так, get mean. Сделали, все сделали. Теперь давайте мерч обсудим. Давайте мерч обсудим.
Как я предполагаю, что реализуется мерч? У меня есть какие-то две кучи, h1, h2, две кучи,
каждый из которых это набор биноминальных деревьев. И мне нужно их слить в один набор
вот этих самых деревьев. Идеальный случай — это когда деревья вот здесь и вот здесь имеют попарно
различные порядки. Ну скажем, не знаю, здесь порядки 1 и 3, здесь порядки, тут 1 и 4, тут 2 и 3. Тогда они
просто, ну, то есть их нужно в правильном порядке расположить, и будет вам корректная куча. Да,
ничего не нужно там, ничего не ломается. У меня все еще все порядки различны. Это хорошо. Но иногда,
конечно, может быть такое, что здесь бывают кучи одинаково, деревья одинакового порядка, скажем,
две двойки лежат. У меня будут бывать деревья одинакового порядка. Но с ними не очень сложно
побороться. Если у меня есть два дерева одного порядка, давайте мы посмотрим, у кого из них число
в корне меньше. Ну скажем, у вот этого. Давайте здесь a, здесь b, и считаем, что a меньше, чем b.
Ну меньше, примерно, чем b. Тогда я могу просто подвесить второе дерево к первому, то есть вот этот
корень подвесить сюда, тем самым получив дерево t3. Я слил два дерева одного порядка, подвесив один из
корней к другому, тем самым получает дерево следующего порядка t3. Это просто по построению,
у меня так строятся деревья. И получаю опять корректную кучу, потому что единственное новое
требование кучи, которое добавляется, это вот это соотношение, что корень должен быть меньше
либравен, чем его вот этот правый сын. Но это выполнено по предположению, я к меньшему как раз числу
и довешиваю второй корень. Поэтому это будет корректное биномиальное дерево, то есть, ну,
во-первых, у него структура правильная, потому что я деревья одинаково порядка слил. Во-вторых,
там будет не нарушаться требование кучи, оно будет выполнено. Итак, мы сделаем со всеми
совпадающими парами. Вот было у меня две двойки, я их слил, получил следующую. Там было две тройки,
я их тоже слил, получил следующую. И так сделаю как бы со всеми конфликтами, в итоге у меня будет
дерево как бы без проблем, все одинаковые, все совпадающие деревья я склею, получу такой
непересекающийся набор деревьев, у них у всех разные будут порядки. Вот, и по сути это то же
самое, как если бы мы складывали вот эти два числа просто в столбик вдовечной записи. Мы понимаем,
что вот это что значит. Это значит, что в этой куче 2 в первый плюс 2 в четвертый вершин, ну и там
элемент. Здесь 2 в квадрате плюс 2 в третий элемент. И если бы мы представили это там
числом вдовечной записи, и вот второе число тоже также представили, и потом сложили, то у меня
возможно где-то будут две единички. Это как раз значит, что у меня вот эта степень двойки входит
и сюда и сюда в разложение n1 и n2 размеров куч. Ну и как раз при сложении у меня вот эти вот две
кучи как бы объединятся, тут станет нолик, а здесь станет единичка. Сюда перенесется единица,
как это, перенос, будет перенос из предыдущего разряд. Здесь то же самое, если скажем, у меня
здесь было 0,1, тогда у меня вот эта единица склеится вот с этой единицей, тут будет нолик,
и еще единица перенесется в следующий разряд. И это вот как раз моделирует ровно то, что мы
будем делать. Мы берем деревья совпадающих порядков, то есть две единички в одном разряде,
сливаем их в дерево следующего порядка, переносим его в следующее, а тут пишем нолик,
то есть два дерева мы как бы убили и получили одно новое. Вот такой алгоритм. Давайте попробуем
его написать. Ну так, не очень подробно, но все же. Будем считать, что у меня есть в h1 какой-то
список деревьев. Не знаю там, первая с индексами от 0 до логи. И во втором дереве тоже есть список
деревьев от 0 до алгоритма. И соответственно, там каждое дерево это либо ну какой-нибудь там
нулевой указатель или фиктивное значение, минус 1 скажем, либо это вот номер вершины корня,
что-нибудь такое. Тогда как будет у меня происходить слияние? Я прохожусь, нет,
давайте я сначала заведу переменную переноса к эри, у меня там будет минус 1.
Ну да, минус 1, то есть как бы нет переноса, и у меня в переносе не хранится никакое дерево.
Вот давайте так сделаем. Потом я иду по и от 0 до чего, ну может быть до алгоритма плюс 1,
нам возможно придется увеличить количество ячеек, потому что если здесь они скажем все
заполнены, здесь все заполнены и мы их сливаем, то мне придется следующий разряд тоже использовать.
Когда я складываю два числа одной длины, мне возможно придется увеличить длину на единицу.
Вот и теперь смотрите, у меня есть три объекта, у меня есть T1 и T, у меня есть T2 и T и у меня есть
кэри, у меня есть перенос из предыдущего разряда. Какие-то из них это настоящие деревья,
а остальные это минусы дницы как знак того, что нет такого дерева, то есть скажем либо перенос
пришел пустой, либо в одной из куч не было такого дерева. И моя цель следующая, вот из этих трех
деревьев, то есть какие-то из них фиктивные пустые деревья, которые не нужно рассматривать,
и из оставшихся мне нужно, если их два, их нужно склеить, склеить, перенести в следующий разряд.
Да, не просто упорядоченные, мы считаем, что нам, ну то есть для каждого вот это вот порядка,
там для каждого K, у меня хранится указатель на кучу порядка K, либо сообщение о том, что нет
кучи порядка K, то есть не просто упорядоченные, но и вот для каждого порядка хранится,
то есть для каждого номера хранится куча с таким номером, или указатель, что ее нет.
Ну вот это минусы дницы. Ну это зависит от реализации того, что мы понимаем под деревом.
Здесь можно говорить, что у меня там T2 от K, это номер вершины дерева TK, номер вершины корня вот
вот. Это будет там TKT. И в случае, если это настоящее дерево, которое присутствует в разложении N по
степням двойки, то это будет просто номер вот этой вершинки. А если этого дерева нету, то есть нету
два вкаты в разложении N по степням двойки, ну там будет минус один. То есть либо нормальное дерево,
ну там, скажем, указатель на корень, либо минус один как знак того, что это дерево не
участвует, его там нет. Ну, соответственно, вот здесь это либо нормальное дерево
текущего там и этого порядка, либо это минус 1 как знак того, что ничего не
пришло. Ну, то есть вот нолик, да, вот здесь. Если здесь был нолик, то у меня там
будет минус 1, а если 1, то указательное дерево. Вот так. Вот, в итоге у меня есть
три дерева, какие-то из них, возможно, не существующие, и мне нужно, если среди них
есть хотя бы две не минус 1, то есть если два настоящих дерева есть, мне нужно их
склеить и перенести в следующий разряд. Ну, и давайте скажем, что t0 и так далее, t
log n плюс 1 это результат. Результат. Так, так, так, так, так.
Ну, тут нужно аккуратно все разобрать. Давайте скажем, что если те три дерева
настоящие, те три дерева есть. То есть это значит, вот здесь была единица здесь,
единица здесь, и еще единица с того разряда пришла. То есть у меня есть сейчас три
дерева одного порядка t0. Есть три вот таких дерева. Тогда я делаю следующее. Я два
из них склеиваю, превращаю в дерево и плюс первого порядка, а одну из них
оставляю как раз t0. Можно написать так, значит t и t это, например, там query пусть будет. То есть
я то, что мне пришло с предыдущего разряда, сохранил здесь, а дальше в query то, что я переношу
в следующий, я напишу объединение t1 и t2 и t. Там merge. Ну, давайте не merge плохо, потому что
так функция называется. Unite давайте. Unite t1 и t, t2 и t. То есть я то, что пришло с предыдущего
разряда, сохранил в этой позиции, а те, которые сейчас у меня вот эти две единички стоят, я их
сложил и переношу в следующий, перезаписываю в query. Дальше, если у меня всего два дерева,
есть два дерева из трех, тогда что это значит? У меня пришло два дерева, то есть среди вот этих
вот трех потенциальных единиц, раз два и три, которые перенос, у меня есть всего два, тогда их
сумма будет ноль, то здесь ничего стоять не будет, у меня точно будет t и t равно нулю, равно минус
единицы, то есть в этом разряде ничего не будет. А дальше вот те два нужно склеить и перенести
в и плюс первый. И просто сказать, что query равно unite, ну вот те самые два дерева, которые настоящие,
два дерева. То есть я понимаю, какие именно деревья настоящие, то есть какие деревья существуют,
их объединяю в одно дерево следующего порядка и приношу это с помощью переноса в следующий
разряд. А в этом разряде ничего не пишу, потому что две единички превращаются в нолик в этом
разряде. Ну и наконец, ну два остается, если есть одно дерево из трех, то я его записываю в
teite, да, что teite это то самое дерево, а query я за минус единичиваю. То есть если из трех
деревьев мне пришло только одно, то я его записываю в этом разряде, а переноса не делаю,
потому что у меня не возникает переноса в больший разряд. Ну и в конце, если ноль деревьев,
если ноль деревьев, то я должен и teite сделать пустым, и query сделать пустым.
teite минус единица, query минус единица, вот и на этом все. Чего-чего? Да-да-да, ну действительно,
можно этого не писать, потому что если все действительно все пустые, то query так пустой,
можно тогда, согласен. Это можно как бы не дописывать. Вот, еще раз повторюсь, если что-то из этого
непонятно, мы по сути просто моделируем сложение двух чисел в столбик справа налево. Берем,
у нас есть максимум три бита, которые нам нужно учитывать, бит из первого числа, бит из второго
числа и бит переноса с предыдущего разряда. Мы их все складываем, записываем сюда то, что нужно,
либо одно из этих деревьев, либо слияние каких-нибудь двух деревьев, и переносим,
если нужно, разряд следующий. Вот такой алгоритм merge. Работает это за log n, потому что, собственно,
здесь просто у меня есть цикл от нуля до логарифма, где логарифм – это как раз ограничение начало
порядка в куче, а дальше у меня все вот эти штуки обрабатываются за вот и днице, потому что какие-то
случаи просто… Ну и самое сложное – это unite, как объединить два дерева. Но мы это уже обсуждали,
что нужно просто добавить одно вот такое ребро, просто сказать, что у этой вершинки появляется
один новый сын. Вот это можно сделать за вот и днице. В итоге merge тоже работает за… Ну я напишу так,
о от логарифма n1 plus n2, где n1 – это размер первой кучи, n2 – размер второй кучи. Вот так,
за логарифмом как бы от общего итогового размера обеих куч. Так, и теперь, когда мы сделали самое
сложное, когда мы сделали merge, нам сделать insert и extract-min уже труда не составит.
Insert теперь сделать очень просто – как добавить x в нашу кучу. То есть была какая-то корректная
куча h, к ней добавляется новый элемент x. Самое простое, что можно сделать – это следующее – оставить
в покое кучу h, которая там была несколько деревьев каких-то, завести новую кучу h1,
в которой будет всего одно дерево порядка 0, и в нем будет тот самый x. Заводим новую кучу,
в которой всего одно дерево нулевого порядка, и в вершине этой написано число x. То есть я
просто создавел кучу на одном элементе. А дальше делаю их merge. У меня же есть способ объединить
в совокупность две кучи. Ну вот ровно это мне и нужно сделать. Мне нужно слить вот это вот множество
элементов, с вот этим множеством элементов и построить одну новую большую кучу. Работает за
логарифм от n. Если n, у меня было элементов здесь, и тут появился 1, то мы работаем как бы за
лог от n-то с 1. Это то же самое, что логарем. Понятно? Экстракт мин теперь. Ну мы знаем,
как находить минимум. Нужно пройтись по всем вот этим вот деревьям куча и среди корней выбрать
самое маленькое. Например, вот это вот значение соответствует самому маленькому значению среди
корней. И нам нужно в идеале вот эту вершинку как бы удалить, а всех ее детей, которых тут в
принципе может быть много, потому что дерево уже не обязательно бинарное, нам нужно все вот эти вот
поддеревья как бы добавить в общий набор. Их вот все как бы сюда перенести и сделать такой
набор деревьев. Вот это, вот это, а также все поддеревья вот этой удаленной вершинки. Вот этого
минимума. Вот. Ну и на самом деле мы ровно так и сделаем. Да, мы скажем, что все, то есть эта
вершинка там печатаем, знаем, что это минимум, ее удаляем, освобождаем память, которую она
занимала, а дальше всех ее детей просто добавляем в этот общий список. Ну или альтернативно,
мы в куче h, вот этой вот исходной, удалим дерево, которое соответствует, у которой минимум был вот
этот вот, у которого корень был минимальным значением. Я эту кучу как бы, это дерево целиком
удаляю, а все ее поддеревья заношу в новую отдельную кучу. Вот этих вот все я заношу в
отдельную кучу. И потом вызываем мерч от того, что осталось, то есть исходной кучи без вот этого
дерева, с новой кучей, которая получается из-под деревьев вот этого вот корня, которую мы удалили.
Здесь тоже делаю мерч, и в результате у меня будет как раз объединение всех нужных элементов,
то есть все исходные элементы, кроме минимально удаленного. Это хороший вопрос, да, но на самом
деле будет все ровно так как нужно. Значит, чтобы понять, что это корректно, нам нужно показать,
что вот это будет корректная биномиальная куча, потому что мерч работает только на двух
корректных определенных биномиальных кучах. То есть, во-первых, что здесь все порядки поварно
различны, во-вторых, что здесь выполняется требование кучи, но вообще, что это биномиальные
деревья. Для этого мы докажем следующий простой факт, который следует из построения деревьев
наших. Факт такой, сыновьями корня дерева тк выступают под деревья, соответственно,
всех меньших порядков, порядков t0, 1, 2 и так далее, вплоть до k-1. То есть,
когда я отрезаю у тк-того дерева корень, у меня все распадается на t0, t1, t2 и т.д. от tk-1. И как раз
тогда это будет корректная биномиальная куча, потому что это набор биномиальных деревьев по
пара различных порядков, и тогда их можно склеить с исходной кучей h. Ну, почему это верно,
можно показать по индукции или порисовав в картинке. Значит, вот есть у меня, пусть это,
к сожалению, верно для какого-нибудь k. Тогда как работает тк-1? Тк-1 получается дорисовыванием
корня, корню вот этого тк-того дерева, еще одного тк-того. Но вот в этом исходном дереве у меня
были сыновья t0, t1 и т.д. тк-1 по предположению индукции. А еще я довесил как раз одно новое
тк-т. Поэтому обязательно, если у меня есть дерево tk-1, то у него есть все нужные сыновья в
порядке от 0 до k. Получается корректная куча и все доказано. Получается тоже работа с алгорифом
extract-min, потому что это слияние двух куч. Ну и на этом мы все операции сделаем с алгорифом. Все,
спасибо, до свидания.
