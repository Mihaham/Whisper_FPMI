значит поехали да ну да у нас теперь все еще будут деревья но другие вот какие у нас
деревья сегодня будут но начнем мы сегодня с б-дива вот потому что да если ну как вы
дадете этого это может быть одна из таких из так полезных на практике структур данных ну мало ли
иногда там редакция там иногда кто-то берет и спрашивает а вот мы тут обсуждаем какие-то
алгоритмы а зачем они вообще нужны ну кроме того чтобы какой-то лажа в каких-то там хозяина
там олимпиадок загонять да вот вот оказывается что но сегодня мы изучим дерево которое на
практике надо просто настолько надо что оно зашито в основе просто все там всех бас данных вот
чем идея но идея в том что зачем нужно вообще деревья поиска они нужны там что какие-то
данные как-то хранить и как-то быстро какие-то данные соответствующие чему-то искать вот
теперь выскажите вопрос а что делать если данных много что такое много но много настолько что они
не влезают в оперативную память вот то есть да дорогие олимпиадники такое бывает соответственно
то есть это действительно данные там приходится как-то там хранить где-то там на какой-то там
ну как минимум жестком диске как максимум еще и там действительно в определенном кластере и
как-то но как-то тем не менее данные надо все-таки добавлять удалять и с ними как-то работать ну к
приводит Kennedy�� к тому что мы понимаем что мы не доступа к всему дерево одновременно вот кто
у нас он т.е. у нас есть возможность хранить там в оперативной памяти только у л matlike вершин
ну но с другой стороны мы помним до что то есть комиссияmä храни в памяти только один в тешин
значит мы должны откуда-то загружать. То есть мы должны откуда-то загружать и наоборот, куда-то
загружать. Вот откуда ты их доставать и куда-то класть. Вот, но мы помним, как минимум по жесткому
диску. Оказывается, что скорее всего, если уж вы озаботились тем, что надо что-то жесткого
диска доставать, то выясняется, что, на самом деле доставать один байт, это не очень выгодно. То
То есть выгодно все-таки памяти побольше, там, за один сеанс, все-таки сразу достать.
Вот.
Ну вот, исходя из этих соображений, возникает B дерево.
Да, сразу скажу, не знаю, почему B, как бы и куда делось дерево, а я не знаю, ну вот.
Нет, где-то оно, скорее всего, было там рядом, да.
Бубен, ну...
А упало.
Ага.
А.
А B продолжает работать, да, ну нормально, да.
Да, да, да. Да, если бы, да, я бы в это еще и поверил, если бы это еще и русские создавали, да.
Но там, насколько я помню, авторы совсем не русские, впрочем, гарантировать не могу.
В общем, когда, знаете, когда выясняется, что основным там создателем, там просто, как всех концепциях стояли, является человек с именем Александр Степанов.
Нет, вот, реально, это чистая правда.
Да, но то, как помню, что да, русские могут быть там везде, на самом деле.
Вот, но тем не менее.
Значит, в чем у нас идея?
Значит, идея в том, что да, B дерево это не двоичное дерево поиска.
Вот, почему не двоичное дерево поиска? В первую очередь, да и в последнюю тоже, потому что оно не двоичное.
Значит, мы тут действительно начинаем думать, что ладно, но, то есть действительно, в чем у нас идея, да, то есть идея двоичного дерева поиска в том, что у нас есть данные и каждая вершина их как бы делит, ну, что-то типа на пополам, ну или как минимум на две части, да.
То есть вот у меня есть, обычно говорили, что у нас есть какая-то вершина, там X в левом, у нее есть левое под деревом, в котором есть все элементы меньше X, в правом под дереве все элементы, которые больше X.
Что же, но?
Вот, но мы говорим, это мало, тоже говорим, а кто сказал, что ветвицу нужно обязательно на две части?
А давайте, а?
Вот, а вот, а мы определим, потому что, смотрите, какая у нас гениальная идея возникает.
Значит, мы неожиданно себе заявляем, что у нас может быть несколько ключей.
Ну, например, ну, конкретно в этой вершине K, и мы заявляем, что, да, у нас есть ключи, они отсортированы, и более того, вот, и тогда у этой, говорим, что у этого дерева будет K плюс один под деревьем, и не просто под деревьем, вот в первом под деревьем будут элементы меньше X1.
Во втором под дереве, вот ссылочка тут типа между X1 и X2, будут элементы, у которых значение между X1 и X2.
Вот так, что у нас тут получается? Тут элементы будут между там X2 и X3, ну и так далее.
Вот, ну и в самом конце тут будут все элементы от XK. Так что вот, пожалуйста.
То есть, в общем-то такая вот оригинальная модификация, это требование того, чтобы дерево было деревом поиска.
То есть вот такая вот красивая идея.
То есть более того, мы даже откажемся от требования, чтобы в каждой вершине было одинаковое количество ключей.
То есть вот это вот K константой являться не будет.
То есть там в каждой вершине у нас будет вполне вероятно, что у нас будут разные, разные количество ключиков,
но более того, то есть более того, у каждой вершины количество ключиков может в процессе меняться, как мы это увидим.
Вот, это вот такие первые идеи, но теперь пришло время написать более точное определение.
Значит, что же у нас такое B дерево?
Итак, значит B дерево, ну это у нас подвешенное дерево вот такого вида, вот такого вида,
где вводится константа T.
Ну тут вот можно сказать шаблонная константа T, интовая.
Про которую известно только, что T больше одного.
И известно, что в дереве, вот так создано дереве, соответственно, соблюдаются следующие инвериенты.
Ну нам нужна какая-то гарантия на балансировку, поэтому соблюдается следующие варианты.
Значит, для любой вершины V оказывается, что количество ключиков вот этих вот в вершине не превосходит внезапно 2T-1.
Вот такая вот константочка.
Ну, казалось бы, пока двоичное дерево поиска удовлетворяет этому требованию для любого T.
Но для того, чтобы у нас все-таки вершины были пожирнее, мы добавляем ограничение снизу.
То есть для любого V неравного руту, верно, что K от V больше либо равно, чем T-1.
Вот.
Да, то есть вы видите, внимание, все-таки в корне у нас, на самом деле, ключиков может быть и меньше, чем T-1.
Нет, почему?
Ну, тут вопрос, как бы считать это детьми, то есть мы считаем количество ключей, а не количество детей.
И с детьми вопрос.
Но на самом деле это действительно, кстати, вопрос, а когда вообще дети существуют, а когда нет.
Вот это всегда балансировка, что там у нас.
Да, забавно, что было в вершине 57 ключей, но существует из них только первый, второй, третий.
Там дети существуют только первый, второй, третий и двадцать седьмой.
Да, почему двадцать седьмой, ну а какой еще?
Действительно.
Соответственно.
Но у нас все будет неожиданно надежно.
Ну, я напишу так, нарисую на уровне D.
То есть, во-первых, у каждой вершины...
У каждой вершины...
А, ну что это писать, у каждой вершины?
Для любой вершины V.
У вершины V либо K от V плюс один детей, либо ноль детей.
То есть, либо все дети существуют, либо не существует ни одного.
Но, конечно, балансировку это вам не обещает.
Потому что даже если все дети существуют, то непонятно.
Вполне вероятно, что у каких-то дети листы, а у каких-то высоких под деревья.
Справиться с этим нам помогает заключительное условие,
которое нам говорит, что все листы находятся на одинаковой глубине.
Да, вот совершенно внезапно оказывается, что конкретно в таких деревьях мы можем такое потребовать.
Хотя в OVL мы уже думали на эту тему и понимали, что это физически невозможно.
Поэтому немножко расшнуровывать штурки приходилось,
в том плане, что у соседних под деревья разность глубин должна быть там.
То есть, может быть один.
Больше не может быть, но вот один допустимая разница.
Здесь предлагается сделать так, что листы пусть находятся на одинаковой глубине,
но зато в каждой вершине может быть ключиков больше, чем один.
И детей, соответственно, больше, чем два.
И вот, оказывается, такая красота возможна.
В общем, более того, да.
Дальше дело вклинивается у нас, соответственно, параметр Т,
от которого также зависит глубина.
А вот давайте подумаем, какая глубина у такого дерева может быть?
Так, лог по основанию Т минус один.
По основанию К как?
По основанию Т.
Так, откуда же такое?
Откуда же такое счастье?
Так, ну, действительно, давайте думать.
Предположим, что у дерева высота, она же глубина H.
Тогда давайте думать, сколько у нее вершин.
Сколько у нее может быть ключей?
Так, ну, в корне у нас, если по минимуму рисовать,
то в корне у нас, как минимум, один ключик добудет.
А, да, ну, давайте я тут добавлю еще какое-нибудь такое
мини-условие, что К от рута все-таки больше либо равно один.
Ну, чтобы не было такого, что корень – это такой один указатель несчастный.
Значит, смотрим, тогда у нас получается количество ключей.
Минимально это один.
Так, и значит, на следующем уровне у нас хотя бы две вершинки.
Эти две вершинки заявляют нам, что ключиков там,
то есть в каждой из них хотя бы Т-1, поэтому их тут уже 2Т-1.
Но тогда получается, если у каждой вершинки по Т-1 ключиков хотя бы,
то у нее хотя бы по Т детей.
И тогда получается, что на следующем уровне у нас
ключиков получается 2Т на Т-1, ну, дальше получается 2Т2 на Т-1
и так далее.
Ну, и в самом конце получается, что на уровне листов у нас
2Т в степени H-1 или сколько?
Видимо, H-2 все-таки.
Видимо, H-2 все-таки.
На Т-1.
Так, ну теперь выясняет вопрос, сколько это?
Да, а точнее?
Ну, давайте так, это получается 2Т-1, на самом деле,
если уж свернуть геометрическую прогрессию,
то получается до Т-1 на Т-1.
Так, ну получается шлеп-шлеп,
и получается 2Т в степени H-1 минус 1,
ну, потому что плюс 1, минус 2.
Так, и это как минимум.
А всего в реальности у нас ключи обычно N.
Ну, тогда отсюда можно вывести,
что H получается не превосходит 1
плюс логарифом двоичный, N плюс 1 пополам.
Да, все еще хуже, да, 3-ичный.
Ну, да, конечно, что Т-константа,
значит, казалось бы, да, с точки зрения 7-точки,
конечно, там эта константа может ни на что не влиять особо.
Вот.
Но тем не менее.
Но тем не менее.
То есть сейчас, на самом деле,
когда мы перемещаемся в места,
где у нас все не влезает в оперативку,
и у нас в константу входит уже и загрузка этих вершин,
то на самом деле эта константа может нам очень здорово,
то есть она может показаться очень здорово принципиально.
Ну, в принципе, действительно.
То есть если вы там пишете код,
который какие-то данные откуда-то из баз данных подгружает,
то вам принципиально, на самом деле,
вы там делаете 5 запросов в базе данных
или 5 умножить на логариф.
Это прям принципиально.
Лучше там лишний лог квадрат у себя,
у себя локально сделать,
чем там делать лишний логариф запросов в базе данных.
Вот на практике может так оказаться,
поэтому там вот просто...
Да, классическая олимпиадная логика уже работать перестает.
Так, но тем не менее, вот получается,
что высота дерева у нас логарифмическая,
ну и соответственно, чем больше Т,
тем высота у нас меньше.
И это, конечно, хорошо.
Но теперь остается только вот вопрос,
как же нам с таким деревом жить?
Вот спрашивается, как нам с ним жить?
Ну, давайте про нот.
Ну, самое простое, что можно делать с деревом,
это, конечно, делать поиск.
Вот спрашивается, как в таком дереве искать элемент?
Ну, искать-то, в общем-то, понятно,
как, что мы просто начинаем с корня,
ну, по вершинам.
Вот в каждое время у нас есть вершина,
и мы просто с помощью...
Можно бинпоиск, а можно, в принципе,
из ООТ пробежаться,
и, собственно, понять, что нам вообще надо,
и в какое дерево нам надо спускаться,
если вообще надо.
Ну, типа того.
То есть там логарифм...
Формально симпатичка будет что-то типа логарифм
по оставанию t умножить на t, возможно.
Нет, ну, как сказать, в олимпиадной логике да.
Но если мы все равно эту вершину
загружаем,
то есть подозрение, что там будете ли вы
бегать за логарифм t или за t,
на практике будет не принципиально.
Нет, тот и прикол, что нет.
Да.
То есть это уже просто не та логика.
Вот.
Но более того, что приятно
в этом серче,
так это то, что мы в реальности можем
хранить только один корень.
Вот давайте сейчас попробуем примерно...
Примерно даже редкий случай написать
код, как это вообще будет работать.
Ну, вот. Ну, во-первых, ну, давайте
допустим, бум.
Exist.
Вот так мы его назовем.
Так.
Ну, и вот какая-то вопрос. В каком виде нам
передается дерево?
Вот.
Так. Ну, давайте так.
Но...
Но даже...
Ну, назовем это, наверное, тоже итератором,
хотя, конечно, так себе...
И слово итератор, конечно, может вызвать
не те ассоциации.
Это я не дописал.
Как бы...
Ну, как-то, как сейчас-то бывает, вы пишете
слово, в том задумаетесь, какое слово вы тут
хотите написать.
Ну, допустим, ладно. Но да, итератор.
Допустим, it.
Там. Допустим, root, it.
Допустим.
Так.
Ну, вот.
А.
Она получает на вход ключик.
Да. Забыл сказать.
И она хочет вернуть true, если ключик есть
и false иначе.
Допустим.
Как такое счастье
может выглядеть, вот, по крайней мере,
в идеальном мире?
Вот.
Значит, на 30.
Значит, смотрите, ну, идея такая.
Ну, допустим, вот. Ну, тут идея такая,
что сама вершина, это, конечно, штука жирная,
а вот итератор на вершину, это нормально.
Потому что это, ну, как бы, просто хранит какие-то
данные, там, собственно, из какого
интернета, там, с какого сервера ее
скачивать надо, условно.
Вот.
Значит, поэтому можно говорить.
Там. Давайте так.
Там nodi итератор.
Там v.
Там way it
равно root it, допустим.
Там while
way it
точка valid.
Значит, мы говорим.
Ну, там условно.
nodi v
равно.
Нет, итератор на вершину.
Ну, в обычной жизни это был бы указатель на вершину.
Потому что, напоминаю, у нас вершина не лежит
в оперативной памяти.
Она лежит где-то там, черти где.
Ну, типа того, да.
Ну, например, в данном случае
это может выглядеть так, что мы можем сказать,
что у этого итератора
ну, вот, то есть, можно говорить v.
download.
Ну, вот, условно.
Мы говорим
download.
Ну, и допустим,
что у нас там в вершине v есть?
Ну, а давайте подумать, что у нас
в этой классе в вершине может есть?
Так, ну, у нас там обычно есть
наверно, какой-нибудь там
vector node. То есть, обычно
есть, наверно, какой-нибудь там
vector какой?
То есть, ну,
vector может быть ключи.
Ну, можно data, наверно.
И, соответственно, дети.
Ну, ключи у нас имеют
тип tiki.
Дети у нас имеют тип, конечно,
тоже node.
Итератор, естественно.
Итератор.
Ну, допустим, children.
Так, ну, да, придется сделать, конечно,
маленькую оговорчику, что
детей мы, наверно, будем
нумеровать все-таки не от одного docker,
а все-таки от 0 до k-1.
Чего?
Нет, ну,
да, детей от 0 до k автоматически
получается.
Вот.
Вот так получается.
Вот.
Так.
Ну, и, соответственно,
тогда тут получается, что
нахитым, там, допустим,
k равно.
Вот здесь мы прям пишем
std leverbound.
Leverbound от чего?
От
v.kis.begin
v.kis.end
и, соответственно,
key.
Вот.
Но, конечно же, не забыть написать
minus v.kis.begin.
Да, потому что, например,
как вы помните, std leverbound
да, он возвращает
оператор.
Чего?
А его не надо
разминовать.
Именно поэтому я вычитаю из него begin.
Ну, то есть, формально, конечно,
я должен писать ttrd
в нижней подчеркивании.
Ну, вот это вот гадость.
Но мы
не будем этого делать.
Это, как говорится, это вот.
Будете сдавать экзамен по C++,
и, возможно, вас начнут
терроризировать эти вопросы.
Нет.
Нет.
А вы стрель уже обсуждали, кстати?
Нет.
Я не обсуждали.
Ну, ничего, пообсуждайте.
Ничего.
В какой-то момент
вы даже шаблончики там пообсуждали.
Базового помнилось.
А, ну, ничего.
Ну, ничего, шаблончики тоже.
Ну, классическое задание, по-моему,
там было это.
Написать sharet.ptr.
Ну, вот это будет ментом.
Какое-то мясо будет то еще.
Нет, ну, не настолько.
Нет, ну, смысл sharet.ptr
и чтобы вы не следили за памятью.
Чтобы вы там не следили.
Кого там надо delete, а кого не надо.
Да, но зато теперь нужно следить
за безопасностью потока.
Потому что потока вам нужно будет следить
на каком-нибудь другом курсе.
Так что, я думаю, не все так сразу.
Вот.
Значит, что это у нас
происходит?
Тут у нас такое кан.
Вот.
Значит, что это такое?
Ну, в принципе, да.
Если оказалось, что...
Значит, если оказалось, что
кейс каты
каты
действительно равно
ки,
то, ну, значит, можно выпуститься
с криком ура.
Ну, как у нас, да.
Как у нас по-английски ура, правильно?
True.
Чего?
Ух ты, какие молодцы.
Я действительно хотел написать код
и сказать, найдите ошибку.
Молодцы, браво, браво, браво.
Да, да, да.
Да, придется здесь...
Вот.
Ой, ой, да, да, да.
А, но это классика, да.
Допускаешь маленькую ошибку,
прочь на тебе ошибку.
Прежде чем нашли твою ошибку,
нашли еще семь.
Причем содержательных.
Да, да, да, да.
Так, значит, хорошо.
Значит, если к,
значит, меньше, чем...
Нет, ладно, на самом деле, знаете,
как это работает?
Тут я понял, что...
Ну ладно, давайте...
Ну, можно писать в кейс, хотя, конечно,
ладно, в будущем.
Так.
Size.
Да.
Не, не надо.
Ну, во-первых,
нам как бы в
будущем...
Ну, сейчас не принципиально, но вообще в
будущем нам эту вершину как бы еще это
грузить обратно.
Поэтому нежелательно.
Поэтому нежелательно
подобными вещами баловаться.
Нет, у меня была идея, чтобы просто мне что-то в кейс не учить.
Там это лениво немножко писать.
Вот, ну ладно, сейчас уже не буду переписывать.
Значит, в кейс size и...
Значит так...
И вот после этого...
Нет, это я k так написал.
Вот так.
Вот, значит...
Да, да, да.
В. кейс от k.
равно
равно кейс, неожиданно выяснилось,
что...
То, значит, тогда выбрасываемся
с криком true.
Значит, в противном случае...
Так, ну да.
Хочется сказать, что выбрасывается с криком false,
но рановато, конечно.
Но нет, вместо этого мы пишем...
Да, я мог бы, конечно, запуститься рекурсивно,
но, как вы уже поняли,
рекурсии мы баловаться не будем,
потому что рекурсия тогда приведет к тому, что у меня будет
логарифом вершин в памяти одновременно
храниться. Это мы хотим избежать.
Поэтому пишем weight
равно...
...
...
...
...
...
Ну, во-первых, мы потеряли не указатель,
а итератор.
Во-вторых, итератор никто
не терял, потому что мы
скачали вершину.
Скачали.
То есть там, где-то
в память, в принципе,
скачали ее, можно сказать, в формате
витонли, в общем-то. То есть, видите...
Память выделена осталась.
Память выделена осталась.
Но, заметим, выделяли
это мы ее не по указателю, мы ее выделяли
статической памяти. Поэтому...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
а теперь а теперь внимательность заведем что ребенок каты существует заведомо
что детей на один больше чем ключей напоминаю а если а за это у нас а за это у нас
что такое лист это у кого дети неволидные нет просто когда мы из листа пытаемся
перейти к детям то просто итератор оказывается неволидным вот так что да вот да вот такая идея
да то есть на самом деле у всех дети есть просто у некоторых дети неволидные да вот все но типа
того вот так ну и в конце самое главное не забыть конечно в конце все-таки выброситься уже с более
подходящим эту случаю криком вот фолс не ну дословный перевод тру это истина фолс ложь
ну можно переведеть как бе но можно так переводить ну как-то во времена популярности
албанского языка фолс переводили как угла в принципе как переводили тру я не помню да а
может так и писали тру с твердым знаком там вот вот ой были вы да ну видимо
видимо это давно было вы еще маленькие были нам так вот так что ты себя так примерно может
выглядеть а давай сейчас чего проверяем ну вы лет проверяя но вы ну вы лет проверяет указывает
ли это является ли таракта корректно то есть указывает ли он на корректную вершину
ну ключи есть а детей нет ну да нет это означает что нет вершину будут записаны все эти дети то
есть их тоже будет как бы каплю с один но просто все они будут неволидными да тут вот тут вот
такое удобство будет вот так что вот такой вот так есть то есть вот такие вот то есть такие
нет нет нет нет нет нет почему нет обратить внимание в иит он показывает на какую-то вершину да то
есть я поэтому так и написал что если вы ведь показывает на какой-то на лист он как бы все
залезет по почитает ключи если поймет шоу как бы исключение ничего не достанет то вот дальше
он пытается пойти дальше вайли вы там в условии вайла поймет что дальше хода
нет и собственно радостно пойдет выбрасываться вот а вот соответственно вот так что это у нас
такой вот такой вот экзиз ну то есть да ну в общем-то и да идея на тут конечно ничего сложного нету
но вот но то технические особенности тут какие-то уже на лицо
что вот значит поехали значит но теперь значит хорошо теперь уровень медиум уровень медиум
говорит нам дорогие друзья достаньте нам пожалуйста вот пожалуйста функцию insert
вот так как это да как себе мой господи в золотые времена когда в аудитории было две доски
хотя над подумать что можно свистнуть вторую доску где-нибудь интересно нету тут-то нет
у основы они типа не пользуются
я тебе больше скажу это она есть
так так но давайте думать как же нам осуществлять вставку
вот потому что да дальше возможно нам так это представление об интерфейсе придется расширить
потому что во вставке нам вершины придется реально как-то менять то есть придется и
но то есть придется их там как-то куда-то запи это куда-то записывать так давайте смотреть
но теперь давайте дубы а как же нам вообще осуществить вставку
так но казалось бы да
так но правда нахер сразу стало что просто тупо вставить ключик мы можем только в лист
потому что да понтишь промежуточную вершину ставим значит у нас откуда должен
взяться еще и лишний ребенок сразу а у нас как видите с детьми такая ситуация что нельзя просто
так и создать еще одного ребенка потому что они все одинаковые то есть это не не то есть не этого
мне это там биномиальная куча где у вас там есть куча детей давайте это но хотя нет да откуда
берется еще один ребенок как говорится да и встретились два одинаковых родителей сказали
а давай ты будешь моим родителем я буду твоим большим ребенком окей вот у нас тут не так у нас
тут все дети одинаковые но в принципе то есть как бы идея вроде понятная то есть а давайте
просто честно идти спускаться спускаться спускаться спускаться и вот мы доходим до листа нет не так
вот доходим до листа но совершенно вот и было у нас тут сколько-то детей точнее ключик
людей не было наоборот ключиков и мы решили добавить еще одного ну казалось бы очень
простая функция если бы не одно но чего да детей может быть слишком много так ключиков может
быть слишком много что же тогда делать но придется так теперь вспоминаем что у этого листа наверное
был родитель этот родитель был наверное где-то между двумя ключиками тогда возникает из неожиданной
идеи а давайте этого ребенка распилим на два да пока он лист его распилить очень просто да ну
правильно да что делать если у вас ребенок сильно растолстел да вот да вот пожалуйста раз ну
в том что ключиков стало слишком много у нас было ограничение что в одной вершине ключиков
бывает не более чем 2 т-1 а этот мог оказаться вот это но ничего страшного мы можем значит
тогда у нас возникает такая интересная операция что допустим у меня т-1 ключиков тут у меня
да вот этот новенький он как бы не обязательно посередине ж будет вот но значит фишка такая а
вот этот ключик он неожиданно получает повышение оп то есть мы теперь говорим что у нас больше нет
этой ссылки вместо этого у нас тут есть целый вот этот вот ключик который мы сюда перенесли и
вместо указателя на одного ребенка здесь указатели на двух детей
все но вот сюда подойдем до этого практически практически ответив на следующий вопрос можем
ли мы сказать что мы победили да потому что здесь тоже могло оказаться что ключика слишком много
чем мы сделали распилили ребенка да я вот центральную часть повысили да отлично да но
говоря что тут что-то тоже слишком много слишком много всего поэтому давайте этого товарища тоже
попилим ну вот ну то есть вот это вот это вот это тоже попилим и как там середину его можем
кстати эту может этой вершины если повезет значит тоже повысим сюда ну допустим выяснилось
что тут у нас все попроще поэтому на 4 мы там отправляем вот сюда и тут соответственно тоже
объявляем двух детей вот но заметим что в принципе так мы можем протидывать прям высоко-высоко то есть
в худшем случае может кончиться тем шумаш до корня дошли и у него оказалось 2 т ключиков ровно
в этот момент мы увеличиваем высоту заявляю что как говорится давайте возьмем какой-нибудь
центральный ключик и объявляем дорогой ключик поздравляю теперь ты король ну смысле корень
да тут мы заодно еще и поисками пользуемся тем что непосредственно в корне у нас может быть мало
ключиков то есть вот ровно в этом месте высота и увеличивается то есть вот по идее такая вот
идея в принципе на олимпиадном уровне в общем-то мы бы этим и удовлетворились потому что в принципе
вот он то есть как бы вставка есть есть работает залогарифом залогарифом все ура не не не даже
дело даже не в этом ну то есть удаление тоже придется написать но следующие задачи на самом
как бы с точки зрения практики нас здесь не очень устраивает что ну да то есть по-хорошему
говоря давайте подумаем сколько раз нам нужно будет сколько раз нам нужно будет скачивать вершины
логарифом два логарифа потому что нам придется мы должны идти не только вниз но и вверх так вот
напоминаю мы имеем мы можем хранить в памяти только у от леденицы вершин они логарифом так
что вы то есть база данных настолько большая что даже логарифом ее это больно да тем более что
значит вот но поэтому нам как-то не очень вот то есть как бы загрузок много но понятно лада но вот
то есть как бы лада то есть как бы но вот но тут еще придется правда какие-то вершинки пить там
пили теперь сохранять но понятно тут уже как повезет то есть то есть как бы тут только до какой-то
высоты вершинки реально придется менять но тем не менее а потому что когда мы дамы сюда вершинку
новую добавили и тут у нас получилось всего ключиков 2 т да просто если если бы тут было
2 т минус один или меньше бы просто так бы все и оставили потому что нас устраивает да это мы
взяли именно середину да то есть как бы когда как можно еще раз подчеркнуть да то есть элемент
середине не обязан быть новым добавленным элемент но он но и не обязан им не быть то есть вот
пожалуйста он может на самом деле оказаться и с краем где-нибудь вполне так что сделать то
есть как бы нам изберут то есть можно ли нам каким-то образом избежать лишних загрузок
что
2
но
кого список
Да, нет, на самом деле все гораздо проще. Нет, идея на самом деле такая. Нет, как добиться того, чтобы скачивание было только логарифом?
Так идея такая. А давайте идти снизу вверх и просто заранее поддерживать вариант, что вы работаете с вершиной, у которой меньше, чем 2t-1 ключей.
То есть идея будет соответственно очень простая. То есть вот вы находите сейчас вершине, у которой меньше, чем 2t-1 ключей. Что это означает?
Это означает что? То есть дальше тогда вы можете работать так. То есть если это лист, то вы просто в нее вставляете ключик и не паритесь.
Вот. Если же надо куда-то идти вниз, то хорошо, вы находите куда идти вниз и идете. Но тогда выясняете, что если там меньше, чем 2t-1 ключей, то вы просто туда идете и не паритесь.
А если там 2t-1 ключей, то вы соответственно быстренько распиливаете эту вершину на две, повышаете средний ключик, тут остается t-1 и t-1. Вот. И после этого там идете куда надо.
Ну, в некотором смысле пуши. Хотя это, конечно, не совсем пуши.
Нет, поменялось в том, что мы, вот раньше мы просто тупо шли вниз, а потом, когда шли снизу вверх, пытались там проталкивать ключики, если у нас тут их слишком много оказалось.
Теперь нам обратно, теперь мы работаем на упреждение. Мы говорим, что когда я работаю с вершиной, я уже знаю, что в ней ключиков немного.
Нет, вставлять-то мы будем все еще в лист.
Сразу разделяем те вершины, которые плохие были.
А что если у нас есть вершина, где 2t-1, где 2t-1, а потом там несколько 1 ключ?
Не 1, а там t-1.
Нет, если где-то t-1, значит мы с ней ничего не делаем.
Значит мы с ней тупо работаем.
А как мы знаем, какая у вас будет вершина по середине, потому что, возможно, мы использовали вот эту вершину, которую мы слили несколько раз подряд.
В смысле несколько раз подряд, не понял?
Смотрите, у нас уже мы добавили вершину в лист, мы ее повышаем.
Потом еще раз мы ее повышаем.
Нет, в смысле, мы никого не поняли, где мы кого повышаем.
Повышаем вершину, когда делаем инсерты.
Что значит повышаем? Количество ключиков в каждой вершине увеличивается только на один максимум.
Да, но мы же делим его в пола.
И что? Делим.
И что? Было 2t-1, стало t-1, t-1, и что?
Так мы не знаем, где у нас так кажется.
Мы можем, конечно, рассчитать, где у нас так кажется вершина, которую мы инсерты.
И что? Так мы сначала посплитим, а потом выясним, куда нам идти влево или вправо.
Мы же вот это дерево не просто так выяснили, а выяснили, что то, что мы хотим вставить, должно лежать между этим ключом и этим ключом.
Это мы уже знаем.
Если у нас в решении 2t-1 ленок, то мы его обязательно распилим.
Так у нас алгоритм такой. Алгоритм не думает о том...
Нет, мы не знаем, будем ли мы его распиливать или нет.
То есть, конечно, исходя из этого соображения, мы не знаем.
Но она бы плевать, мы просто берем и пилим.
Всегда.
Всегда.
То есть теперь он может всегда распиливать вершину.
Ну да.
Ну да.
То есть, может быть, мы, конечно, где-то сделаем какой-то фальстарт.
Ну вот, но ничего страшного.
Суть, в общем-то, та же останется.
Просто, видимо, какие-то распиливания мы сделаем чуть раньше.
Так что такая вот идея.
Хотя, в общем-то, если следить, как там происходит добавление,
то, в общем-то, суть принципиально не поменяется.
Вот.
Так что такая вот получается радость.
Вот, ну и давайте посмотрим, как же это...
Да, ну и, соответственно, отдельно тогда хочется остановиться,
что у нас...
Возможно, нам в самом начале придется решить, поменялся ли у нас корень.
Вот.
Поэтому придется тут, конечно, поработать.
В коде.
То есть, как это будет примерно выглядеть?
Выглядеть это будет примерно следующим образом.
Так.
Так, ладно.
Exist же можно ликвидировать?
Да, я думаю.
Давайте Exist ликвидируем.
Ой.
Ну да.
Как это называется?
Код ликвидируется, память о нем остается.
Ну ничего.
Ну ничего.
Так.
Что?
Ну вот.
Ага.
Я понял.
Да.
Ой.
Ну память о нем остается.
Так.
Так, ну ладно, это мы тоже уберем.
Думаю, понятно, что мы тут вряд ли где-то на сплэй неожиданно перешли.
Так.
Так, ну поехали.
Значит, делаем.
Хм.
Так.
Хм.
Хотя это называется, сейчас будет уже хороший вопрос.
Потому что заметим, что у нас в результате корень мог поменяться.
Правда?
Да.
Но у нас Gentoo Linux.
Генту Linux.
Вы можете, в Gentoo Linux вы можете сделать буквально все своими руками.
Более того, вы будете делать буквально все своими руками.
Ну да.
Что нам мешает?
Ничего не мешает.
Просто мы начинаем писать код, мы должны об этом задуматься.
Да, пришло время об этом задуматься.
Просто обычно в этом месте уже начинаешь задумываться.
А шо вообще insert будет возвращать?
Ну вот, видимо, да.
Наш, ну логично.
Node.it, допустим, insert.
От.
Node.it, я тут сократил, не буду сейчас Node.iterator писать.
Там Node.it, там допустим root.it.
И соответственно вставляем мы этот вот таки key.
Так.
Ой.
Так.
Ну во-первых, сразу придется рассмотреть веселый случай.
Если совершенно внезапно оказалось,
что этот итератор уже не валиден,
а такое бывает.
Ну бывает же, что у нас дерево пустое, правильно?
Ну вот, но получается так.
Ну да, так и написать.
Node.it, там действительно root.
Ну там, видимо, Node.it root от.
Ну вот так и пишем, да, видимо, кучу фигурных скобочек.
от key.
Ну а дальше там.
Так, вот создаем эту вершину.
Node.root, создаем ее локально.
Да, совершенно верно.
Вот я ее нод.
Вот.
Ну вот.
Сейчас мы просто сделаем локальную версию.
Нет, Node.root это мы сделали локальную версию.
У этого Node.
Потому что это дерево.
Вот, я бы вот так сказал.
Потому что смотрите, у нас будут на самом деле две разные вещи.
То есть у нас вот upload new node, это я вот говорю,
это я говорю, что я хочу вот, то есть это я хочу создать новую вершину.
Вот очень хочу, очень хочу создать новую вершину.
Вот.
Вот, а сейчас нод.
Соответственно upload new node.
А так я иногда буду upload по итератору, типа вершины не меняется,
просто запись нод меняется, векторы конкретные в ней.
Вот, это чуть позже будет.
В этом Ифе мы проверяем, что если совершенно внезапно выяснилось, что дерево пустое,
то есть у нас даже корень является уже неволидным итератором,
то мы просто создаем дерево из одной вершинки.
То есть вот так.
Ну да.
Да, то есть как бы я создаю вершину, вот вершина выглядит вот так.
И я вызываю функцию upload new node, которая возьмет эту вершину,
положит ее там куда-то себе на сервер и вернет итератор на нее.
Но я подчеркиваю, что это новая вершина.
Вот.
Вот.
Вот.
И так, значит, наш итератор теперь валиден.
И что мы теперь делаем?
Так, наш итератор валиден.
Но нам придется тоже рассматривать случай, будь здоров.
Потому что, возможно, нам все еще придется создавать новый корень.
Почему?
Потому что может так оказаться, что у нас в корне слишком много ключей, а именно 2t-1.
Понимаете, да?
Вот.
Поэтому в принципе, значит, что тут можно сделать?
Вот, можно сделать примерно следующее.
Так, значит, как же мы это сделаем?
Так, ну давайте начнем с простого.
Значит, nodie root равно rootit.download.
Download от чего?
Не просто.
Да, от широты жизни, да.
Вот.
Вот.
Вот.
И так, значит, root у нас такой.
Значит, если оказалось...
Значит, теперь мы сейчас будем мыслить аккуратно.
Значит, если оказалось, что root.kis.size
равно 2 умножить на t минус 1, то что мы тогда делаем?
Вот.
Вот.
А, ну смотрите, знаете, что мы еще сделаем?
Я еще напишу nodie it.
Это называется wayit равно rootit.
Потому что в конце я должен буду написать rootit.
Это веритурно rootit, то есть просто сохраняем.
Так, значит, если у нас, значит, осталось 2t-1, значит, нам придется создать...
Так, ну во-первых, действительно там...
Ну, во-первых, попилить новую вершину.
Как мы это конкретно сделаем?
Так.
Ну, во-первых, давайте так.
Так, сделаем аккуратно.
Давайте, во-первых, ту вершину из базы удалим.
Ну, во-первых, начнем с того, что там скажем.
Erase from base.
Там, собственно, от этого rootita.
Ну, как бы, видите, мы ее уже скачали, поэтому, в общем, ничего страшного, понимаете, да?
Так.
Почему мы храним iterator на rootit?
Что?
Почему мы храним iterator на rootit?
Ну, эффективнее через wayit, если...
А мы его сейчас перепрессуем.
Какие?
Нет, нет, это мы обязательно учтем.
Значит, что мы теперь делаем?
Теперь эту вершинку надо, получается, распилить.
Так, ну, во-первых, создадим новый root.
А, хотя нет, неправильно.
Для того, чтобы создать root, неплохо было бы создать iterator на его левый и правый ребенок.
Левый и правый ребенка.
Вот.
Значит, поехали.
Ну, поехали.
Там node, там left child.
Так, ну, во-первых, там...
Как создать node?
То есть, на самом деле, vector можно создать так.
Так, vector от tkey.
Значит, от чего?
От нашего вот этого вот.
Значит, root.
Не значит, точка keys.begin.
Вот, root.keys.begin.
Плюс, соответственно, сколько там?
t-1.
Вот.
Ну, есть у vector такой конструктор от двух итераторов.
Вот.
Еще?
Есть туда.
Как говорится, мало кто знает, но он есть.
Вот.
Что еще есть?
Ну и, соответственно, дети теперь.
Значит, там node.it.
Тоже root.
Точка children.
Точка begin.
Рут.
Точка children.
Точка begin.
Плюс.
На этот раз t, потому что, соответственно, у вершины с t...
Если t-1 ключей, то детей, соответственно, t.
Так, ну, вот такого вот left child создали.
Логично, да?
Вот.
Вот.
Сейчас чего-чего еще раз?
2t-1.
А, детей 2t, да.
Да, детей 2t.
Значит, ну, давайте создадим теперь право.
Можем создать право ребеночка теперь.
Right child.
Значит, right child.
Соответственно, от vector.
Значит, от такие...
От чего?
От...
Значит, root.keys на этот раз.
Точка begin.
Плюс на этот раз t.
Ну, вот.
Точка begin.
Плюс на этот раз t.
И здесь уже можно просто n кинуть.
Нет.
Нет.
t-1 ключ, он не отправится в детей, он отправится в корень.
А вот дети...
Точнее, указатели на детей.
Это не сами дети, это еще их так, так сказать, их мобильный телефон.
Да.
Ну или...
Хотя нет.
То есть, нет, это я не знаю, где мой ребенок, но у меня есть там эта магическая шкирка,
которую я могу дернуть, и ребенок появится.
Вот.
Вот так.
Так.
Begin.
Плюс t.
Точка children.
Точка end.
Во.
Ой, скоб.
Ай, скобочка забыл.
Так, классно.
Значит, смотрите.
Так.
Ну, во-первых.
Теперь.
Теперь.
Так, nodie, nodie it.
Теперь пишем left.
Нет, ну давайте нормально напишем.
Nodie it.
Left child it.
Равно.
Значит, upload new nodie.
От left child.
Значит, nodie it.
Right child.
Right child it.
Равно.
Upload new nodie.
От right child.
Вот.
Так.
Ну, что у нас теперь?
Значит, root у нас.
Значит, что у нас теперь?
Значит, root.
А давайте просто в эту вершину напишем.
root равно, допустим, nodie.
От чего?
От.
Единственного вот этого несчастного.
root.keys.
точка.
А, не точка, а просто t-1.
И здесь вот это вот.
Left child it.
И right child it.
Во.
Значит, тут соответственно шлеп.
И шлеп.
Вот.
Значит, пишем теперь.
Ой, хотя этот ключик, видимо, придется сохранить.
Так.
Раз мы его перезаписываем.
Так.
А, впрочем, это.
А, впрочем, нет.
Вот.
Впрочем, не совсем так.
Значит, пишем теперь.
root it.
равно.
Значит.
Upload new nodie.
От root.
А теперь внимание.
Вот вы спрашивали.
Ну, теперь пишем, что v it.
равно.
Ну, и соответственно пишем, что если наш вот этот ключик оказался меньше, чем
там root.keys нулевое.
То он равен соответственно left child it.
Двоеточие.
Right child it.
Во.
Так.
То есть, видите.
То есть, вот получается, что у меня v it будет, значит, равен текущей вершине.
Но если у нас в корне что-то произошло, то как бы, значит, в том ребенке, который
надо.
Вот.
Да.
Так.
Так что вот такой вот код мы написали лишь для того, чтобы рассмотреть случай
с корнем.
Вот.
Нет, ну здесь, да, хотелось на это время потратить, чтобы вот просто посмотри, какие
тут техники.
Вот.
Вот.
Вот.
Нет, ну здесь, да, хотелось на это время потратить, чтобы вот просто посмотри, какие
тут техники.
Какие тут технические детали возникают.
Вот.
Значит, что же нам теперь надо сделать?
Так.
Ну тебе, ну дальше, в общем-то.
Точнее, да.
Возможно немножко копипастить придется.
Но давайте.
Но суть-то теперь понятна.
Теперь давайте.
Давайте попробуем попробуем уложиться куда-то вот куда-то вот сюда в эту часть
доски.
Как это добудем?
Это попробуем упихать код.
Тем более, что в реальных компаниях от вас могут.
Нет, хуже в размер экрана.
Нет, кстати, в реальном коде, кстати, обычно там то есть какой-то яндексе помню там
были требования, что комитет код, то есть у вас там весь код должен умещаться в
экран.
Весь код или весь тиф?
Нет.
Но я имею в виду, каждая строчка кода, естественно.
Нет, понятно, наверное, весь код поисковика Яндекса, естественно, вряд ли уместится
в монитор.
Нет, но сформулировать так нет.
Теоретически можно, наверное, пытаться жестко требовать, чтобы любая функция в коде
помещалась в экран.
То есть просто если у вас не вмещается в экран, значит вы ее плохо разбили на под
функции.
Вот, да, теоретически можно.
Так, что у нас тогда будет дальше?
Да, то есть напоминаю, код у нас не заканчивается в этом месте.
То есть мы еще пока идем, идем, идем.
Так.
Так, значит тут мы начинаем писать, что мы начинаем писать?
Не, никакого Элзе.
То есть у нас есть вершина wayit, на которую мы смотрим, итератор, на который мы смотрим.
Вот, то есть более того, на самом деле, правильно было бы еще написать, вот, более
того, правильно было бы еще написать, знаете, что?
Сейчас я вам скажу.
То есть на самом деле, можно было бы еще написать какую-нибудь, то есть вот wayit
равно rooted, и надо еще тогда написать, знаете, что?
Надо писать ноде v равно root.
Нам просто будет удобно, чтобы эта вершина прям сразу и хранилась, чтобы лишний раз
ее там не доставать.
Вот.
Да, да, да.
И вот поэтому здесь придется тоже это написать.
Там key меньше root точка keys от нуля.
Вопросик left child.
Ну, к сожалению, в языке, в этом языке у нас картриджей нету.
Ну, точнее так, Влада, в продвинутых версиях есть.
Там что-то, что-то отдельно похожее, но легче уже не заморачиваться.
Вот.
А.
В.
А она в будущем окажется.
А она это это пока копия root, потому что как бы сейчас у нас будет то сейчас
начинается с этого момента.
То есть мы тут пишем while true.
Ну, не совсем.
Значит, смотрите, там, нет, там логика такая будет.
То есть сейчас мы находимся в вершине v и в ее поддерево куда-то хотим вставить вершину.
Мы будем поддерживать инвариант, что вершина v уже скачана.
Если душить, кстати, то вот вы сделали v равно key.
Нет, v и я значит скачал это и итератор, а v это прям вершина.
Да.
Ну, райтчайлт и левчайлт это тоже по типу нода.
В чем проблема?
Ждем.
А.
В.
В.
В.
В.
В.
Ждем.
Мы делаем, мы не можем присвоить ноду, нод и итератор.
Нет, наслаждайся.
Нет, ты сейчас.
Да, вот, не путать.
Вот.
Так, что там?
Так, значит while true, теперь говорим, что вершина v у меня есть и итератор на нее тоже есть.
Но самое важное по этому вершину, что мы знаем, это то, что сама по себе вершина уже удалена не будет.
Ну, потому что я имею ввиду, что инвариант заключает в том, что это не просто вершина, а это вершина, у которой ключиков заведомо меньше, чем 2t-1.
Значит, поэтому работать мы теперь будем следующим образом.
Значит, куда же ее вставлять?
Ну, вставлять ее, очевидно, нам нужно будет в позицию лавербаунд, правда?
Пишем, как всегда, std pum pum laverbound.
От чего?
От v.kiss.begin v.kiss.end.
Да, запитая key.
И не забыть, конечно же, вычесть begin.
Так, отлично. Это мы знаем, в какую позицию будем вставлять. Понятно, да?
Кстати, вполне вероятно, что будем вставлять и в конец.
Чем приятен такой лавербаунд, что если ваш элемент больше всех элементов, которые у вас тут в массиве есть, то он вернет это.
Вот.
Так, поз, значит, сделали.
Так, ну теперь пришло время, наверное, создать новую вершину.
Но правда есть самый тупой вариант.
Так, ну давайте так, во-первых, так и допишем.
Not it.
Вот этот вот pos it равно v.children pos.
Вот, по идее, именно в это под дерево нужно вставлять новый ключик.
Но, правда, сразу придется сделать уговорочку. Если совершенно случайно оказалось, что он невалиден.
То, что мы тогда делаем.
Тогда, смотрите, тогда я технически делаем так.
v.kis.
Значит, делаем insert прям в вектор.
v. как делается вставка элемента, да?
Она делала v.begin plus pos и, соответственно, key.
Вот.
Ну, я надеюсь, я надеюсь, вы в этом месте не начинаете там pushback эти элементы, прибегаться фориком там, чтобы скопировать там вот это все.
Так, да, как, как, как добавить v.children лишний nullptr?
Ну, в данном случае вообще можно не заморачиваться.
И просто написать pushback.
Ну, там.
Типа от nullptr.
Ну, я так напишу. Понятно, что там какой-то итератор от nullptr.
Ну да, потому что надо добавить пустой просто.
То есть, в векторе нужно добавить ноль пыта.
Ну, и в векторе.
Ну, и в векторе, и в векторе.
Ну, и в векторе.
Ну, и в векторе.
как бы то есть знаете да знаете как как поет классик зайти там а любви немало песен сложена
я спою тебе спою еще одну вот но не то чтобы конечно любовь и нул птр конечно как-то
связаны но соответственно вот ну то есть иногда конечно случается и такое но да вот значит
поменялась вершина но мы хотим но замена но идея такая мы хотим чтобы как бы сама appelle
эти вещи то есть скажем так в вершине появился новый клюк и кто сама по себе вершину как
сущность не поменялась в том плане что как бы этой вершины был родитель и наверное это
этот родитель указывал на эту вершину и мы не хотим чтобы этот указатель перестал быть валидно
поэтому у нас неожиданно появляется что у нас неожиданно появляется появляется такое
такой метод вид вид точка аплод
ну и турн рутит конечно
нет нет просто идея такая
просто да то есть у нас смотрите просто вот есть разница потому что выит это
означает следующее что где-то но то есть то есть как бы то есть где-то у нас есть
какой-то удаленный сервер да на сервере есть ячейка в ячейке сундук там сундуке
яйцо там яйца и утка утка там утки заяц да вот так вот значит что вот это за
она говорит значит смотреть не то значит не надо ни не там не трогай сервер оставь
там покой утку значит оставь зайца просто вот внутрь этого зайца просто положи лишний
ключик но сам по себе само по себе зайца не трогай ну по модулю конечно это да вот то есть
имеется ввиду что как бы у меня есть не таратор со сведениями то есть как бы хочется чтобы
эти сведения остались прежними то есть я был что тот же самый сервер тот же
самый сундук и так далее но да то есть как бы и таратор это он говорит что
где-то там вот есть сундук вот в этот сундук вот теперь чтоб там лежала вот
это то есть если кто-то ссылался на этот сундук значит вот вот пусть он на
него ссылается тут все коррект вот вот такая вот идея красивая вот так значит
что у нас тут теперь дальше так ну дальше я чувствую крыш код придется все
таки стирать потому что да да да да да совершенно верно а у нас этот вал не
закончился потому что теперь остается маленькая подляночка потому что если
ребенок существует то придется то как бы что мы дальше будем делать нам придется его
скачать посмотреть не сильно ли много там детей но вот такие ключиков и если
слишком много то один придется повысть вот ну уж ладно раз уже селись давайте
доделаем правда правда для этого придется видимо тут чуть-чуть постереть
вот вот эту часть можно уже стирать вот я вот жалко вот это писали бы на
экране бы конечно это копипас ну и сейчас конечно вот значит смотрим что же
у нас происходит тут вот давайте тут
так кого оптимизит
да и чоп и чоп прям оптимизирует интересно но да да задача давайте да давайте в
стд сэп подсунем бы дерево будет ли она работать быстрее и что помогает
мясо ой да да да да да да господи так ладно начали поехали так что нам там
надо значит нам надо полезть в этот вот постит и скачать новую вершину но давайте
скачать значит ноде там вот этот вот пост чайлт равно да ум лод так как мы да
он лод пишем нет мы не так пишем до лод мы пишем пост и точка до лод до лод так
загружаем ребеночек так ладно давайте начито раночь какая у меня тут первая
идея которая возникает но давайте сразу себе отсечем простой случай если оказалось что пост
чайлт точка кис точка сайз оказался совершенно случайно меньше чем 2 умножь на t минус 1
то что мы делаем ну понятно вит равно постит тогда действительно в равно пост чайлт ну и
континю вот вот начать с этого момента мы значит мы поняли вот значит теперь мы понимаем что как
бы пост чайлт слишком жирный его придется распилить как же нам это сделать но наверное
но наверное неси любой ну давай так ну давайте как этого пост чайлта распилить ну как всегда
значит пишем левт значит пишем левт чает у нас пилится от чего так ну давайте так я сейчас не
буду не буду все переписывать поэтому скажу поэтому скажу что он там от пост чайлт точка кис от нуля
до t минус 1 вот и значит пост чайлт точка чилдер от нуля до t так так ладно никого надеюсь вот
это спонтанное обозначение не пугает вот ну так но я тут немножко как ну как-то нас водится я
тут немножко сократить себе там собственно за эту работу решил поэтому так вот да то есть
пост чайлт точка кис от значит от чего тут получается от t до 2 t минус 2 так ну и
соответственно пост чайлт точка чилдер от соответственно чего-то тум-пум 2 t минус 1 тут
да так а ну тогда у нас тут нет сейчас тогда у нас тут t минус 2 вот хотя надо было полу интервал
написать было бы хорошо да ну ладно не важно вот так ну хорошо рай райт чайлд создали так
ладно сама вот пост чайлдом можно наверное удалить так как как у нас то функция называлась
а эйс оф бейса эггейс фромбейс да давайте так рейс фромбейс пост чайлд так
так ну и теперь значит значит ну и соответственно вершину в надо сделать получается так так ну
давайте так ладно чем с того что создадим детей точнее не просто создадим детей а положим их
как-то но положим их в базу вот как-то как известно мало мало создать детей надо еще
найти найти в их правильное место в жизни да так значит так что у нас тут но деит
лэфт чайлд это равно значит а плот уплот нью нодя от но я вот так и пасторша должна
была быть функция крыша попилили попилить ребеночка в авдолите как может радоваться будет
функция значит объединить ребеночка вот значит вот такая значит лэфт чайлд
не прошла фишка такая прикинь это это мы только вставку пишем да то есть дикарь
дикарта дерево уже бы уже бы тут все полностью убестилось надо не в прошлый раз кто-то задавал
в этом месте правильный вопрос как бы и чтобы дикарта деревен уже чтобы делать сплит и мерч
потому что так то если вам нужно было делать только вставку удаления в общем-то статус это
никто не отменял если да он ордер от сет кстати тоже вот так и очень глупо было бы этим не
пользоваться хотя вот честное в наше время нас старались давать задачи
но почему теоретически есть
нет а элементарно потому что для того чтобы это нужно было делать нужно в каждой вершине
хранить размер под дерево а это это лишняя память от не решили но ты не решили избавиться то
есть это опять часть вот тех самых трейдов так-то можно сказать а почему в сети нельзя делать
сплит и мерч почему нельзя там да вот что за безобразие то есть вот то есть как бы да тут
проблема в том что можно это все сделать но как бы если нам нужен только то есть если кому-то
нужен рабочий христианский сет который умеет только вот вставлять удалять и искать то в общем-то
тогда он просто будет работать дольше чем мог бы так дети так ребята тихо так дети созданы
значит поехали так теперь пришло время обновлять вершину в значит то как ее обновлять в тактих
значит в точка кис так но значит получается вот в этот вот в это посовое место нужно вставить
значит вис пишем инсерт от куда от в точка кис точка пост и тут соответственно пост чайлд
точка кис вот этот вот и ты минус первый значит вставили этого товарища теперь а теперь расскажите
мне куда вставлять детей чего нет ну не все почему середину не в середину
да да да беги пум пум плюс пост запятая да так ладно придется это тоже стереть все-таки мы
не уложились в доску так ну ничего страшно уж кошмар покидите что вот нет я только начал
стирать сам инсер вот значит так шли у нас тут две линии и они продолжают идти так значит в
кис значит вставили этот вставили но тут фишка такая в чилдранов значит тот чилдран
посовое на самом деле мы напишем лев чайлдит вот так и в этом чилдран точка инсерт от в точке
чилдран точка беги плюс пост и собственно райт чайлдит вот и вот теперь соответственно можно
вит точка а плот от в и в конце все равно нам остается так ученым теперь надо сделать теперь
вит равно чему ну ки меньше чем пост и точка кис от вот этого t минус 1
спасибо плюс один молодцы так лев чайлдит а тут двое точек райт
чайлдит вот так ну и соответственно в равно ки меньше того же самого и с от ты минус 1
лев чайлдит то это ки райт чайлдит так что тут у нас значит соответственно да на этом вайлик
заканчивается и мы выбрасываемся а уже а тут мы можем даже не заморачиваться потому что
выбрасывание произойдет не здесь вот теперь хорошо нет нет а ой да да да да да да да да да да
да вот так вот так что вот такая вот красота у нас возникает так это мы делали вставку ой ой ой
так что мы делаем именно таким образом что если ки меньше чем пост чайлд кис
а что не так нет потому что как бы у нас бы как бы появился новый ключик то есть в этой
вот середине да то есть как бы тот ребенок который мы хотели спустить он распилился на два нам нужно
пойти там в левую часть пойти или вправо но как бы точка распила стал и стал именно вот этот
ключик который мы тут еще и добавляли вот нет мы его не удалили мы ему повысили вершину в
чай нет ну пост чайлд уже не существует после они существует существует его левая половина
правая половина и то что было посередине то есть сам этот ключик который повысился да нет мы
пользуемся вот то есть у нас тут лежит какая-то старая копия мы им пользуемся то есть да мы его
ликвидировали в базе до базе его не существует но у нас локально он есть нам это удобно так что
вот такая красота остался только остался только выяснить маленькую приятную вещь а как делать
удаление мяса не рано не но не оно в общем-то можно пробить но думаю думаю для того чтобы
успешно сделать пришло время сделать и перерыв конечно так и так как же удалять элемент вот
как же теперь удалить элемент из дерева так причем опять же видимо какая-то такая идея что
мы хотим как-то это делать сверху вниз чем у нас теперь подлость подлость заключается в том что мы
и не то есть мы теперь особо не выбираем откуда удалять потому что где элемент находится оттуда
его удалять каким-то образом и надо логично правда вот делать вот то есть вот действительно
высекает такая маленькая но хотя с другой стороны то есть мы умеем безболезненно удалять только из
листа и то в предположении что там хотя бы те ключи правда вот ну не говоря о том что придется
рассмотреть видимо какие всякие эти там какие-то это мир за парой там мелкие случаи типа что у
вас существует только корень там выпиливать элемент надо из него там вот ну и так далее но
подлянка может быть том что что делать если удаляемый элемент оказался не в листе но потому
что наверно то есть конечно можно каким-то образом там идти сверху вниз и добиваться того что в
вершине в которую вы смотрите хотя бы то ключи или ну просто хотя бы так ключи вот да то есть это
конечно возможно мы это сделаем но с другой стороны высекает вопрос а что делать если удаляемый
ключик находится не в листе вот да ну видимо да придется каким-то образом его опустить но каким
образом мы можем опустить но на соответствии по ситуации но хотя давайте смотреть потому что
конечно первый способ который хочется рассмотреть конечно идеальный способ это вот у вас есть ключик
неожиданно вот у вас есть ключик и неожиданно выяснилось что у вас тут но вот и но вот и
выяснилось что у вас тут два ребенка и у каждого по t минус один ключик тогда это прям идеально
тогда значит мы берем тогда мы просто делаем операцию обратную то что была то есть мы вот
это вот сюда переносим там собственно вставляем ну вот здесь у нас вот так получается вот ну если
предполагать что у нас тут было хотя бы ты вершин то это валидная операция очень удобно но это нам
должно прям супер повести чтоб тут было t минус один и t минус один а что делать если тут где-то
не ты минус один чем чем кого отпилить куда отпилить
года сlio считают
сейчас так пойдем справа возьмем самые левые да так
так хорошо пройдем где ну хорошо нашли мы этот ну допустим мы нашли в принципе мы по этому
левому пути можем прогуляться в принципе за от единицы там за от единицы памяти даже нет
почему нет почему нет почему прогуляться нет есть у меня задача найти самую левую вершину в
подделье вот этой то мы можем это сделать просто вайликом пройтись ну тупо берем вершину берем там
самого левого ребенка записываем на ее место но логарифом будем обращаться а ну по нет по
памяти будет адекватно вот это по времени возможно лог квадрат конечно хотя хотя с другой стороны тут
вещь такая на самом деле если вы просто пойдете вот сюда и скажете что дорогие друзья начинает
этот момент я буду удалять самый левый элемент который вот у вас только есть вот этот вот да то
в принципе идея будет такая что вам то есть на самом деле вас будет только логарифом потому что
то есть идея будет том что вы всегда будете двигаться там вниз вниз вниз то есть добиваться
того чтобы тут вершины были размера хотя бы т и потом когда вы придете в этот лист у вас будет
вершина размера t или более и тогда вы хотя это даже неважно но вот то есть как бы и тогда вы
этот элементом удалите или там просто подмена там замените на это не точнее наоборот точнее
достанете этот элемент удалите его и положите его вот аккуратненько на это место так что вот
такая вот не очень хитрый а как его спускать еще тут не t-1 и t-1
у нас получится какой-то массивчик больше чем 2t-1 мы из него достанем вершину симметричную по
позиции нам же можно спустить вниз сейчас стоп стоп уже да только мою только мою да супер если бы
не одно но а если тут 2t-1 и 2t-1 тогда тогда ты просто этот же элемент назад и вернешь
вот поэтому оказывается так то есть идея такая еще раз и допустим мы тут шли шли шли сверху и
нашли элемент который надо удалять идея такая значит тогда этот элемент мы будем некоторое
время пропихивать вниз то есть если мы видим что у него дети справа и слева от него t-1 то мы его
пропихиваем вниз но как только обнаружилось что один из ребенков оказался больше либо равен
например правой то тогда мы объявляем следующий мы идем в этого правого ребенка удаляем из него
минимальный в нем элемент вполне себе залогарифом обратите внимание до и этот минимальный элемент
просто записываем на место вот этого то есть вот такая вот ну в принципе то есть это технология
делали в обычных двоичных деревьях а потому что надо этим надо еще подумать потому что
надо поддерживать надо спускаться и поддерживать инвариант что в каждой вершине то есть на
bakın есть мы просто идем близко знаю допустим что удаляемая вершина находится в листе и
мы поддерживаем инвариант что в каждой вершине с которой мы работаем хотя бы те ключиков вот эти
База у нас, кстати, есть. Вот тут он же хотя бы Т.
Что смущает? Смущает то, что мы не проговорили,
о каким образом мы будем это делать. Пока я это сказал только на уровне идеи.
Ну а теперь у нас есть какая-то вопрос. Как поддерживать вариант, что туда, куда мы спускаемся?
А ведь давайте сразу, кстати, обобщим. То есть мы тут мы спускаемся только влево,
ну или в симметричном, возможно, симметричном случае, когда спускаемся только вправо.
Но на самом деле нам же еще до этой вершины надо как-то дойти.
И более того, кстати, обратите внимание, в этой вершине нам тоже нужно требовать,
чтоб тут было хотя бы Т. вершин.
А что это требование обеспечивает? Это требование обеспечивает, что мы хотя бы в принципе можем
удалить из этого поддерва вершину и ничего не сломалось.
Т ключиков, да.
А потому что у нас еще дети есть.
Да, если бы это было не 100, да, мы бы просто удалили и не заморачивались бы.
Да, но у нас есть дети. Детей должен быть ровно на один тем ключиков, еще и с вредными вариантами.
Но сейчас давайте смотреть, да. Ну и сейчас это обсудим.
Да, сейчас просто хочется подчеркнуть, что в принципе можно было пытаться сказать,
да, нельзя, а зачем нам это больше либо равно Т, нельзя ли без этого варианта обойтись вообще.
Но тут сразу оговоримся, потому что мы хотим избирать такой ситуации.
Дело в том, что может тогда теоретически возникнуть ситуация, когда вы находитесь под дереве,
где все вершины, у всех вершин ровно по Т-1 ключиков.
Тогда утверждение, вы из нее ничего удалить не можете в принципе.
Потому что дерево должно остаться той же высоты.
И у вас там минимальное количество ключиков, которые там может быть.
В общем-то, обратите внимание, кстати, в инсекте тоже вот этот вариант, что у вас в корне меньше,
чем 2Т-1, гарантирует, что у вас не это переполненное дерево, когда там все по 2Т-1,
и когда добавить одну вершину, у вас там будет бабах.
Поэтому такой вот необходимый вариант.
И так у нас два случая.
То есть у нас в принципе две части, на самом деле, будет нашего эрейса.
До того, как мы нашли вершину, которую хотим удалить.
И после того, как мы ее уже нашли и хотим пропихивать куда-то вниз.
Но суть везде одна.
Но суть там в промежутках везде одна.
Жила была вершина, в ней детей больше либо равно Т.
Вот. Больше либо равно Т.
Я хочу спуститься в какое-то поддерево, ну, допустим, вот это.
Ну, естественно, говорю я так.
Ну, никаких проблем спуститься в это поддерево.
Нет, если там тоже больше, чем Т-1 ключиков.
Я просто туда спускаюсь и не заморачиваюсь.
Но что делать, если там оказалось ровно Т-1 ключиков?
Ну, тогда идея такая.
Давайте рассмотрим соседа.
Да, кстати, сосед может быть вообще один.
Вот такой сосед.
Рассмотрим соседа.
Как мы уже поняли, если тут тоже Т-1 вершина,
то давайте вот эту вершинку между ними торжественно спустим сюда.
Тогда у нас тут получится, тут вершина 2Т-1, мы в нее торжественно переходим.
Вот.
Но что делать, если так не работает?
И тут сосед оказался больше, чем Т-1.
Ну, вот.
Нет, погодите, погодите.
Это мы делаем еще, как бы это еще неудаляемый ключик.
То есть как бы нам просто надо как-то правильно спуститься.
То есть поэтому там рекурсивно пойти и отпилить у него там
самого правого ребенка, это лог квадрат.
Так.
Так.
Да, совершенно верно.
Да, то есть оказывается, да.
То есть сейчас то, что мы сделаем, на самом деле будет очень похоже
на малый левый поворот или малый правый.
Как говорится, неделю назад мы таким баловались, помните?
Так вот неожиданно это вылезает и здесь.
Рассмотрим самый правый ключик и на нем висит под дерево альфа.
Вот балалайка такая.
Вот.
Да, этот элемент мы назовем А, а этот элемент назовем B.
Так вот возникает неожиданная идея.
То есть вот тут была какая-то борода тут.
Вот.
И тогда, оказывается, с этими вершинами можно сделать поворот.
Значит, идея такая.
То есть этот ключик ликвидировать.
Точнее не ликвидировать, а записать вот сюда.
То есть вместо B сюда записать А.
Куда же денется ключик B?
Ключик B мы поместим вот сюда.
Но слева от него тоже должен быть ребеночек?
Ну так давайте этого ребеночка альфа сюда и переподвесь.
Вот, понятная идея, да?
То есть просто поворот.
Такой красивый.
И теперь чего мы добиваемся?
Мы добиваемся того, что туда, куда мы хотели спуститься вот сюда,
здесь уже стало в вершинке Т ключиков, значит с ней можно работать.
Вот, понятна логика, да?
То есть, смотрите, получается вот таким механизмом мы можем дойти до той вершины,
в которой у нас находится удаляемый ключ и добиться того,
чтобы в этой вершине было хотя бы Т ключей.
Ну а дальше мы действуем ровно дальше.
То есть дальше мы, соответственно,
некоторое время там пока тут Т-1, Т-1 этот ключ спускаем,
потом если обнаруживаем в какой-то момент соседа больше либо равно Т,
то просто из него мы удаляем самый левый ключ и помещаем его сюда.
Ну в процессе, когда мы спускаемся к самому левому ключу,
мы как раз и поддержим этот вариант.
То есть мы как раз и делаем эти повороты.
Ну да, делаем повороты или иногда вот эти вершины спускаем,
там как повезет.
То есть мы спускаемся в вершину и там Т-1 ключ.
Как с этой проблемой справиться?
Либо поворотом, либо спуском.
Ну в зависимости от ситуации.
Так что вот такое.
Ну еще, конечно, придется оговориться,
если это реально писать в коде,
то, конечно, еще нам придется оговориться о корне.
Да, иногда должна, но здесь понятна какая идея,
что рассмотрим корень, в котором, допустим,
там остался бедный один ключик.
Ну потому что если там осталось хотя бы два ключика,
то работаем ровно так же.
Что делать, если остался один ключик?
Ну тут, как всегда, по ситуации, на самом деле,
предположим пока, что этот ключик удалять не надо.
Тогда что мы делаем?
Мы должны куда-то спуститься, допустим, влево.
Ну тут, как всегда, значит, если тут оказалось Т-1,
то, значит, надо сделать,
то есть если тут и тут Т-1,
значит, нам остается этот ключик просто опустить.
Да, но с оговоркой, что в корне нам необязательно,
чтобы тут было Т ключиков.
Ясно.
То есть тут надо поддерживать инвариант,
что инвариант более точно звучит так.
В вершине, который вы рассматриваете,
ключиков хотя бы на один больше, чем минимум.
То есть мы хотим поддерживать инвариант,
что в корне...
Ну не совсем, ладно, у нас не удастся поддерживать прям такой инвариант.
Но, значит, тут у нас...
Ну то есть по-разному, на самом деле, можно сделать,
потому что можно такой инвариант объявить и его поддержать,
потому что сказать,
мы хотим решить проблему,
что у нас один ключик в корне.
Так, как это решается?
Ну давайте посмотрим на детей.
Если тут Т-1 и тут Т-1,
то там как бы работаем стандартным образом.
То есть там понятно, спускаем этот ключик
и объявляем просто корень на меньшей высоты.
Что делать в ином случае?
В ином случае, правда, не понятно,
откуда вы выкопаете вторую вершинку.
Но с другой стороны, нам на самом деле и не надо.
Может отбросить лучше этот инвариант.
Потому что если у нас...
Во-первых, если оказалось, что вы хотите спуститься
в левое под дерево,
а там больше либо равно это ключик,
то в общем-то и заморачиваться не надо больше.
Пусть там в корне висит этот ключик,
пусть он там думает о себе что угодно.
А мы тут поработаем.
Вот.
Ну а если оказалось, что нам надо спуститься
т-1, а справа оказалось
в общем-то больше либо равно t,
то значит даже если этот ключик 1,
как бы малый правый поворот никто не отменял.
То есть это отдельный случай с корнем
придется разобрать.
Сейчас мы этот код писать естественно не будем.
А в какой момент
это условие резко нарушается?
Нет, но обратите внимание,
мы с деревом вообще по большому счету что делаем?
Что в инсерте, что в дынете?
Вот эти вот операции туда-сюда, да?
Но это как бы распил ребенка,
но как бы все листы остаются теми же.
Ну максимум что может быть,
эта вершина будет.
Ну максимум что может быть,
эта вершина была лист и она просто распилилась на два листа.
А в любом ином случае,
то есть там просто произошел какой-то
переподвес, то есть там дерево распилилась на два,
но их высоты никуда не делись.
Вот.
Ну или да. То есть вот это, ну типа удобства такое, да.
Ну да, это называется, да,
клад разделился на два подклана, да.
Ну нет, там просто отдельно обрабатывать,
потому что в результате этого действия корень может поменяться.
Во-первых, корень может быть,
там вот просто один ключик,
это поэтому надо отдельно рассматривать всегда, к сожалению.
Вот.
Да, ну и самое приятное,
что,
ну да, то есть единственная проблема,
что скачивать вершин, конечно, придется много.
То есть на каждой высоте
вам придется, возможно,
там скачать аж два ребенка даже.
Ну для поворота.
Ну для поворота, для этого обретенения.
Но,
вот, но тем не менее, но, но тоже
неплохо.
Вот. Но тоже, соответственно,
не так плохо.
Вот. Но мы сейчас, да, не будем сейчас писать код,
а вместо этого задумываемся
над неожиданной вещью.
Значит, это мы сейчас говорили о том, как это, значит,
в идеале реализовывать, там, в реальном мире.
А теперь давайте все-таки
посмотрим на эту структуру данных,
как олимпиагики.
Потому что олимпиагик скажет,
у нас есть дикартовые деревья,
они умеют делать сплит и мерш.
А теперь внимание, вопрос.
Давайте задумаемся.
А умеет ли,
а не умеет ли случайно,
в чем-то, да, в кормании как бы вот это все
подробно описывается.
А потом неожиданно упражнение,
и там упражнение четыре.
Да.
Да. Первое. Напишите мерш.
Напишите мерш.
Напишите, то есть не придумайте, а напишите.
Ну или опишите там,
придумайте. Ну ладно, придумайте.
Хорошо. Придумайте мерш.
И нот.
И придумайте.
И неожиданная нот. А потом после этого
придумайте сплит.
Вот. Но более того,
вам сразу подсказывают.
Какая тут просто основная идея,
которая, как в дикарте, после дикарте,
она может казаться вообще прям контринтуитивной,
но на самом деле...
На самом деле...
Не-не-не.
Значит там подсказка такая.
Значит вам нужно
реализовать функцию...
Значит реализовать функцию мерш.
Да, ну как бы.
Ну то есть как всегда.
Значит мерш от чего?
Вам дано
дерево,
в котором все элементы меньше
икса.
Вам дан сам икс,
прям один элементик.
И дерево, в котором все элементы
больше икса.
Вот.
Да, то есть помните.
Дикартовые деревья тоже рандомные, деревья не мержат.
Ну такие мержат,
но там начинаются там всякие какие-то оценки,
дай бог, чтобы блок куб сошелся.
Вот.
Нет, ну там есть какие-то там такие
развлечения, на самом деле.
Как-то там
правильно...
То есть как-то, как слить сеты,
у которых вот эти вот условия не выполнены.
Да, ну правда там
больше сливаемые дуошки начинают вылезать.
Да, там
и там логарифм вполне себе вылезает.
Вот.
Вот.
Ну да, в какой-то момент мы даже обсудим.
Да, вряд ли успеем
сегодня, но в следующий раз наверно точно.
Вот.
То есть нет, это как бы фишка известная.
Хорошо, понятно.
Так, но самое главное, что там
да, нет, ну все-таки лучше проговорить.
Потому что самое главное,
что
от нас просят, чтобы мерж работал
за симптотику О от 1
плюс разность
высот.
О.
Там
одинаковые тешки.
Не, ну да, да, да, конечно.
Ну как бы это
мы сливаем только там
один тип.
Так что да, да, да.
Так что вот такая вот неожиданная идея.
Что если нам даны два
дерева слить за разность
высот плюс один.
Нет, ну действительно.
Заметим, что если
высоты у этих деревьев совершенно
случайно одинаковые,
то слить оказывается предельно
просто. Надо просто взять корень
тут.
Взять корень тут.
Ну тут борода, борода, борода.
Да, тут борода, тут борода.
И тогда
что мы делаем? Мы просто
объединяем.
То есть объединяем эти списки через
вот этот вот промежуточный х.
И единственное,
что нам надо рассмотреть, а не
получилось ли так, что тут количество ключей
больше чем 2t-1.
Ну могло
получиться меньше, причем насколько угодно,
практически меньше.
Но если оказалось больше, то что делаем?
Ну да.
То делаем очень простую вещь.
То есть просто распиливаем,
выносим, создаем корень
из одной вершины.
Да, распиливаем не обязательно в этом месте,
потому что у каждого
этих старых корней может быть сильно меньше,
чем t-1 ключикам.
А может быть несколько?
Нет.
Нет, смотри, дело в том, что
2t-1, да?
Ну как повезет.
Нет, мы распиливаем, когда у тебя
от 2t до... А сколько тут вообще ключиков
бывает?
Ну в худшем случае тут 2t-1, тут 2t-1.
В худшем случае, да.
4t-1.
Вот.
Но распилить тут достаточно просто.
То есть надо тут...
То есть тут надо просто распилить так,
чтобы каждая часть была как минимум t-1.
Ну в самый тупой случай я бы сказал,
что если у тебя тут, допустим,
получилось там какой-нибудь k,
то я просто распилил,
честно говоря, по k пополам
и k пополам.
Нет, вот так.
k-1 пополам и k-1 пополам.
Вот так.
Нет, не обязательно.
Как повезет.
Да, мы носим какую-то серединку,
чтобы вот было. Но легко вот увидеть,
что каждая из этих штук будет
хотя бы t-1, если тут вот так будет.
А элементарно в корне может быть
сколько угодно. То есть может тут
3, а тут 2.
Нет, если тут 3,
и тут 2...
Ну тогда мы говорим,
что если у нас тут совокупности
осталось не более чем 2t-1 ключиков,
то мы не заморачиваемся.
Больше либо равно, чем 2t,
то мы этот корень распиливаем
на пополам. Только уже не в этом
месте, а посередине.
Не могло.
Нет.
Так что получается,
что если высоты одинаковые,
то вы действительно за 1 деревья
прекрасно объединяете.
Так, что нам остается
сделать? Остается сделать
только маленькую приятную вещь.
Сказать, а что делать,
если высоты
все-таки чуть-чуть различаются?
Найти...
Да, ну да.
Но я бы сказал так. Нарисовать
это можно так. То есть допустим,
у нас тут действительно
без ограничений общности левое дерево
оказалось выше правого.
Тогда мы идем
в левом дереве
по правому пути.
Идем, идем, идем, и вот наконец
доходим до
соответствующей высоты.
Тогда что мы делаем?
Тогда вот на этой вершине
тут висит свое дерево,
и давайте мы эти деревья
в виде их корней
объединяем через вот этот х.
Мы взяли
левое дерево,
пусть у него высота больше.
И мы спускаемся
по правому пути
под дерево той же высоты,
под дерево той же высоты, что и правое.
Вот.
Тогда вот это правое под дерево с этим деревом
просто объединяем через х.
Все, что может произойти,
это то, что в этой объединенной
вершине окажется
больше, чем 2t-1 ключ.
Если оказалось не более, чем
2t-1, то просто мы уже радуемся
жизни.
То есть условно говоря, просто
в этом месте на этот указатель подвешиваем
вот это объединенное дерево и радуемся.
Вот.
Но если оказалось больше, то что делать?
То значит придется опять
что-то попилить и пробросить эту вершину
наверх.
Да?
Вот. Если тут оказалось больше, чем 2t-1,
то пробрасываем, ну и так
наверх.
Могли.
А могли
не поддерживать.
По ситуации.
Ну да.
Ну в принципе да.
Ну по модулю того, насколько вы...
Ну это называется по модулю того,
насколько вы там в базах данных
будете реально там баловаться с плитами и мержами.
Или там вот этими.
А с рандомными ключами нельзя?
Чего?
Нет, если
деревья
произвольны, то есть если ключики друг от друга
произвольны, расположены, то увы.
А два там дерева тоже не может быть?
Чего? Ну совсем с произвольными
нет.
Чего?
Не, никак.
Вот.
Так что
получается вот мерж за разность
высот плюс один вроде заморочен.
Вроде сделали.
Так. Ну что ж.
Ну теперь приходит время
самого сладенького.
Чтобы сделать сплит.
Так. Ну давайте зададим себе.
Да. Ну а первое да. Отметим, что
вот это вот в случае...
Ну для нас конечно можно заметить, что да.
То есть в принципе если вы хотите слить просто
как дикарь, так же просто два дерева,
то в принципе вы за логарифом это вполне можете сделать,
потому что вы просто из одного из этих деревьев
можете там какой-нибудь минимум
и достать.
Ну если очень хочется.
То есть на самом деле этого не надо делать.
Соответственно.
И теперь собственно.
Интерес.
Значит как же делать сплит?
Ну сплит
значит он должен быть
ну сплит какой?
Как у нас устроен сплит? То есть
сплит дано дерево, дано х.
Ну и допустим
для простоты гарантируется, что этот х
где-то в дереве есть.
Нам очень хочется распилить тогда
это дерево на дерево,
в котором есть меньше х,
сам х
и собственно все, что больше х.
Сразу?
Ну погоди.
Ну погоди.
Ну да.
Амортизация, да.
Не, не, не, не, не.
Ой, боже,
ну смотри.
Ну сейчас
посмотрим.
Ну во-первых, допустим так,
где находится х?
Нет.
Если х находится где-то в корне,
то нам прям повезло.
Да, потому что если это
прям вот корень и вот нам х,
то значит мы просто говорим вот,
вот, то есть
как бы, то есть вот так,
вот так, вот так. То есть правда
и получается два дерева одинаковой
высоты, если
конечно этот х не оказался с края.
То есть в точки зрения
реализации сразу
порекомендую обратить внимание на то, что
как бы например, если вот х оказался
справа, то у вас там одно дерево
будет той же высоты, что и старое,
а другое дерево будет на единичку меньше.
А вот на этот раз не факт.
Нет,
как задачи делают
очень просто вот эти, потому что технология
очень простая. Я дам вам контест
как бы классичные задачи на эти картеечки.
Нет, ну не
не, ну не настолько.
Нет, обычно
там можно
спрактиковать так,
но дело в том, что каждую задачу,
то есть у каждой задачи есть какой-то номинал,
х баллов. Так вот,
если вы сдадите эту задачу,
просто сдадите, вы получите
0,4х.
Вот.
Но если вы сдадите
двумя разными деревьями, то вы получите
0,8х. А если
тремя, то 1,2х.
Ну и так далее.
Ну да, нет, там
на самом деле отдельная графа, то есть
если вы ухитритесь дать задачу вообще
там без всяких деревьев,
то есть прям реально
обойдетесь истрелям,
ну ладно, или как ячкой,
то это, то так и быть, на это
закидываю еще.
Нет,
нет, в принципе, конечно,
не, ну конечно, поочеряйте, на самом деле, не используйте
картовые деревья там, где их использовать не надо.
Естественно.
Нет, самое смешное, что, кстати,
осталось только достать пару
задач на сливаемые кучи и забабахать тоже самое, да.
Нет, ну там задача,
там написать там
левацкую косую, там это проще.
Да, вот фибонай, да, вот фибонай
чуть-чуть, ну тоже на самом деле не самое сложное,
учитывая, что как бы код есть в кормане.
Переливайк, ну.
Нет, ну что, переливайка,
да.
Ну тут надо подумать, там всегда можно ввести
какой-нибудь запрет в духе, что там запрещается
пользоваться, там
запрещается пользоваться
СТД.
Только, ох ты.
Да-да-да, пишем на том алголе, на котором
там, называется, обычно пишет
тариан в статьях, да-да-да.
Чего?
На Паскале?
Да ладно.
Так, нет, ну, к сожалению,
не все языки поддерживают.
Нет, Паскаль,
нет, Паскаль-то да, но с другой стороны
заставляет вас еще учить Паскаль,
потому что, я думаю, большинство
из вас Паскаль в глаза не видело.
Нет, это
нет, я не знаю, нет,
мне, конечно, это осторожно, мне это может созреть душу,
потому что я до 11 класса
насяг писал только на топ-кодере.
Так что осторожно.
Так что вы с таким предложениями поосторожнее.
Я же, да, я же могу и согласиться.
Ну да.
Нет, ну я так и быть, я разрешу писать на Дэлфе,
но вот как бы да.
Ну скажем так,
локально, пожалуйста,
но в тысячную систему
в натуре Паскаль ты ничего не сдашь,
потому что это 16-битный компилятор, он даже массив на 100 тысяч не скушает.
Да, на всякий случай
напоминаю, Паскаль это такое сим,
в котором нет даже вектора.
Вперед.
Салонов там тоже нет, кстати.
Сортировки там, кстати, тоже нет.
А в некоторых задачах еще,
как выясняется, в некоторых задачах
сует антикуссор тесты.
Я думаю, пожалуйста, да.
Нет, пожалуйста, пожалуйста.
Ну да.
Ну понятно.
Так вот, ладно.
Так вот,
вернемся к сплиту.
Так вот, господа.
Так, тихо.
Тихо.
Возвращаемся к сплиту.
Как же сделать сплит?
Ну оказывается,
ну то есть идея такая, хорошо,
если нам повезло, то нам повезло.
А что делать, если нам
не повезло?
Ну тогда идея очень простая.
Берем корень,
понимаем, что мы хотим пойти, допустим,
вот в это под дерево,
потому что там находится х.
Тогда у меня идея такая,
я все-таки
распиливаю это дерево
вот таким вот нехитрым способом.
То есть смотрите,
что?
То есть смотрите, у меня,
оказывается, то есть
смотрите, что у меня получается. У
меня получается есть одно дерево,
в котором элементы, вот у меня тут целое
дерево, в котором элементы меньше х.
И также у меня, ну вот,
и есть дерево все элементы которого
больше х., а также у меня есть
промежуточный элемент.
И еще есть какое-то под дерево,
которое я тоже сейчас пойду сплитить условно и рекурсивно. Ну, условно, потому что на самом
деле я, конечно, все буду вайликами делать. Значит, смотрите, что у меня тут? У меня тут дерево,
и в этом дереве тоже есть корень. И тут я неожиданно понял, что я хочу пойти вот в это
дерево. Так давайте возьму тряпочку. Вот, и тут я возьму тряпочку. Выяснится, что у меня тут тоже есть
ключик. Я тут решил пойти вот куда-то сюда, но здесь я сделал примерно то же самое. То есть у меня
тут образовалось еще одно дерево, правда, меньше высоты. Видно, да? Вот. И вот тут еще красота. Вот.
И тут еще какие-то. И так я буду идти, ну и в какой-то момент, оказывается, я найду вершину,
в которой находится х, и ее уже пепелю как корень. Да. То есть к чему это нас приведет? Это нас
приведет. Это нас приведет. Куда это нас приведет? Вот так. Это нас приведет к тому,
что нас в результате тут где-то образуется элемент х. Слева от него обнаружится какие-то
последовательность под деревьев. Причем, в принципе, гарантируется, что каждое следующее
под дерево по высоте не больше предыдущего. Вот. Но, да, важный момент. Именно не больше. Да,
может показаться, что строго меньше, но это не совсем так. А потому что здесь может быть подлянка,
что вы пойдете тут. Потому что когда вы тут, допустим, вы могли захотеть пойти вот сюда,
вот в это под дерево. И вот не самое крайнее слева, а вот второе слева. И тогда у вас влево отправится
только вот это под дерево на единичку меньшей высоты, чем было вот это. Поэтому там вполне вероятно,
то есть оно как бы на единичку меньше вполне вероятно, и следующее у вас вполне может оказаться
той же высоты. Поэтому гарантировать можно только, что каждое следующее дерево высоты не больше,
причем уже в качестве упражнения можно показать, что на самом деле подряд идущих
деревьев одинаковой высоты будет не более чем два. Ну ладно, не то чтобы это принципиально,
но это как бы тоже решаемый вопрос. Но короче говоря, есть вот такая вот условная неубывающая
последовательность, и надо эти деревья как-то слить. Ну давайте так, во-первых, давайте добьемся того,
чтобы деревья были вот такие. Для удобства. Для формального удобства, я так скажу. Нет,
нет, меня просто смущает вот что. Да, хочется сказать, что давайте сольем это с этим, потом
это с этим, потом это с этим, и у вас получится какая-то телескопическая сумма, которая схлопнется,
да? Но это будет работать, только если вы будете гарантировать, что у вас в каждый момент времени
дерево слева по высоте больше чем справа или хотя бы не меньше. Нет, ну нет, ну просто фишка такая,
что если у вас справа начали деревья обгонять, то это как бы желательно, чтобы это было как-то
контролируемое, потому что если сливаешь дерево высоты 57 с деревом высоты 58, может
получиться дерево высоты 59. И если тут идут какие-то равные, то как бы там обгон не пошел на 2,
на 3, на 4, в результате как бы у вас тут лог квадрат не вылез. Да, но идея тут на самом деле такая.
Начнем с того, что давайте избавимся от равных. Как мы избавимся от равных? Да очень просто,
наоборот идем, ну я бы сказал так, наоборот, идем по убыванию, то есть идем по убыванию,
по убыванию, по убыванию. Если в какой-то момент встретили два равных, давайте их объединим. То есть
давайте их объединим. Если при этом оказалось, что очередное дерево, то есть получилось дерево
равное предыдущей высоте, значит их тоже объединяем. Вот, то есть так вот объединяем,
ну то и фактически в стеках по сути добавляем. Ну, которые в сплите возникли слева от икса. Вот,
ну справа понятно, то же самое, но в другую сторону. Вот, в результате тогда получается,
что за суммарный алгорифм действия мы добились того, что у нас в массиве все деревья по высоте
строго убывают. Идем, значит идем слева направо, добавляем деревья в стек, но если на вершине
стека образовались два дерева одинаковой высоты, значит мы их мержим, значит достаем из стека,
мержим, кладем обратно в стек и повторяем вариант. Проверяем. Ну понятно, что это работает за,
очевидно, количество деревьев плюс количество объединений, но объединений не больше, чем количество
деревьев минус один, поэтому хорошо. Да, мы здесь пользуемся тем, что два равных дерева мы мержим
за единицу. Да, совершенно верно. Да, спасибо, очень важное замечание, мы действительно пользуемся тем,
что когда вы объединяете два дерева одинаковой высоты, то получается дерево высоты не меньше,
чем столько же и не более, чем столько же плюс один. Поэтому мы гарантируем, что как бы новое
дерево не станет уж больше предыдущего, но равным ему оно стать может. Да, а в каждый момент времени в
стеке у нас строго убывающий массив. Этот механизм, кстати, работает даже если бы у вас бывало
3, 4, 5 и сколько угодно подряд идущих элементов одинаковой высоты, кстати. Да, ровно поэтому мы
слева направо вообще идем. То есть как бы кто сказал, что давайте справа налево и пропихивать,
но тогда если у вас будет несколько подряд, то там обгоны начинаются. И так что же делать теперь,
зачем мы это сделали? То есть зачем мы добились того, что у нас высоты строго убывают? Ну понятно,
зачем? Потому что этим мы добиваемся того, что теперь мы идем наоборот справа налево,
объединяем сначала вот эти деревья и гарантируем, получаем дерево высоты не больше, чем вот это плюс
один, то есть не больше, чем вот это. То есть поэтому этот результат мы спокойно объединяем
за именно вот высота этого, минус высота вот этого, ну плюс один. То есть для чего мы это все делаем?
Для того, чтобы вычиталась именно высота левого, минус высота правого. И чтобы эта сумма просто
схлопывалась. То есть объединяем эти, получаем высоту не более, чем вот это плюс один, ну и не
менее, чем вот это. И объединяем уже с этим. И тогда суммарно получается лыгарифм.
Ну потому что вот на очередной высоте, ты тут неожиданно понял, что тебе надо пойти на
второго слева ребенка. Тогда, когда ты сплитешь, у тебя вот в левой части окажется вот ребеночек,
то есть только чисто ребеночек, то есть дерево высоты на единичку меньше, чем вот эта вершина.
Вот. Более того, то есть тут целое дерево будет в высоты той же, что и вот эта вершина. А тут
может случиться, что ты решил посплитить ее посередине. И тогда высота, то есть высота
вот этой вершины окажется такой же, как эта. Так что такой технический нюанс возможен.
Сейчас, погоди. Почему?
Ну нет, когда мы составляем список, равные все-таки могут оказаться.
Но сверху мы можем оценить, как просто убывающие типа h, h-1, h-2, h-3 и так далее. Тогда если мы будем их
просто сливать отмечек большим, мы сверху сможем оценить, как будто мы сливаем деревья.
Не сможем. Ну с формулировом так. Прежде всего, предположим, что у нас, мы знаем,
тут допустим, что мы знаем, что тут высота не более чем 179, а тут не более чем 177. Мы очень
хотим заявить, что тогда в принципе их можно за о от двойки, там двойки плюс один слить. Но это
может быть ни черта не так. Почему? Потому что оценка сверху не гарантирует, что у тебя тут,
допустим, не окажется, что тут высота 174, а тут 57. И тогда слияние будет ни черта не за о от двойки.
Вот. Поэтому то есть нам требуется, чтобы оценка была не только сверху, но и снизу все-таки. Вот.
Поэтому просто так на халяву, к сожалению, не получится. Так, ну что ж, поздравляю. У нас есть
сплит. А нет, видимо, еще нету. Так. У нас же есть проблема, что вот мы когда сплитим, мы вот находим позицию,
между которыми находятся, ну между двумя элементами. А причем деревья мы разбили на то, что вот, ну вот,
ну а куда мы эти два элемента делим? А у нас есть не просто деревья, у нас не просто последовались
деревья, а последовались деревья и элементов между ними. Да. То есть у нас тут целая цепочка есть.
А, ну, мы этого не сказали, потому что это подразумевалось. Нет, с этим же успехом,
можно сказать, что формально я должен был сказать, что такое сплит, что сплит имерша, значение этих
операций в мировом программировании и так далее. Но я просто в наглую предположил, что тут все
понимают, что такое сплит имерш, в принципе, да. Потому что, наверное, потому что я проведу
соцпрос в прошлый раз, и помнишь, декартовые деревья видели все. Ну, как бы логично, да. Там сложно
было предполагать иное. Вот. Так что вот. Но самое приятное, что теперь можно сказать,
это то, что все эти операции вместе с сплит имерш делается как бы сверху. Поэтому заметим,
что все операции, которые вы там пропихивали с помощью операции push в декартовом дереве,
можно прекрасно делать и в поддереве. То есть можно там прибавлять на отрезки, там на поддереве,
там присваивать на поддереве, разворачивать можно, пожалуйста. На каэйфе мы пишем.
Вот. Нет. Но с формулирован так. Смотрите. Ну тут аккуратно. Да вроде нет. Скажешь так,
не могу ответить достоверно, но на самом деле, окажешь, что это не вот. Ну, скажешь так,
но есть сильная вероятность, что это просто буквально это, просто при константе t равно 2.
Ну и что? Нет, там ладно. Но там вот смотрите, как при t равно. Нет, ну как понятно,
что при t равно 2 у вас там как бы ключей не меньше одного и не больше, чем сколько там 2. Вот. Нет,
не больше, чем 2. 2t минус. Нет. Да-да-да-да. Ну от одного до трех. Ну вот. От одного до двух
или до двух до трех? Нет, ну как бы в два-три дереве, наверное, ключей должно быть от двух до трех,
или имеется в виду, что детей там от двух до трех. Но скажем так. Нет, скажешь так,
тут я достоверно не скажу. Вот. Ну вот. Ну, скажешь так, ну если он у вас преднаписан,
то в общем-то ни в чем. Хотя я не гарантирую, что константа его не окажет хуже, чем константа
Декартеича. Нет, ну зачем? Нет, ну в данном случае вы. Нет, ну на самом деле, как бы теоретически
смысл этого имеет. Потому что в чем победа по сравнению с декартовым деревом? Да, нету вероятностей.
То есть и даже нет амортизации. То есть мы теперь умеем делать сплит вёрши, там всякие вёрши на
подотреске за логарифм честный. Да, то есть в принципе да. То есть там персистентный реверс
можно в принципе и делать. Да. Так что, ну вот, предельно честный. Но единственное, что мы теперь
можем сказать, это то, что, господи, прям нам нужно было изобрести это вот громадину, это вот
писать вот эту гадость, а мы уже начали убеждаться, что это немножко гадость очень сильно. Да, но
если вы заранее напишите, отладите, еще оптимизируете, конечно, в библиотеке на
Кодфорсе, пожалуйста, но на конте CPC вы, наверное, с этим ноутбука это перебивать будете вряд ли.
Вот. Но как бы что вам может помочь? Ну там я боюсь только декартач, но в целом, на самом деле,
сейчас мы убедимся, что на самом деле, ну то есть на самом деле ради сплитаймержабы дерево можно
было не изобретать, потому что на самом деле я утверждаю, что АВЛ дерево тоже прекрасно
справляется с сплитом и мержом. Вот. Но для баз данных, то есть это просто вот такая большая
структура. Нет, для Олимпиада оно не надо. Ну там, ну как сказать, да, там, ну да, во-первых,
вероятности, а во-вторых, там, да, там, то есть там больше более, ну там более рандомная грубина,
это то есть, нет, нет, а что предлагается иметь в виду, делать тут какие-то рандомные приоритеты
как-то, что ли, с разной высотой или что? Ну то есть, нет, это, ну скажешь так, это отдельная песня,
как бы можно ли действительно сделать какой-нибудь прикол, но здоровь, понимаете, когда речь идет о
таких фундаментальных задачах, когда работа с база данных и так далее, знаете, как бы кодинг,
то есть как бы скорость кодинга в этом смысле уходит на второй план. Нет, ну нет, там разные
причины, потому что, ну, то есть, нет, это, конечно, интересно открыть, на самом деле,
оригинальную статью по дикартьячке, кстати, там, по-моему, кстати, как ни странно, кстати,
дикартьячка датируется сильно более поздним годом, который все можно вообразить, просто слет
едва лиги 94-й какой-то, но можете гуглануть, там, это арагон Зидель, там, вот это все, да, да, как
это называется, да, первая, да, первая девушка, первая у нас, по-моему, это девушка среди авторов
алгоритмов, кстати, да, Сесилия арагон, а у нас не было, нет, маргарит-карачик у нас еще не было,
нет, так у нас еще ожидается Матильда Штор, кстати, алгоритм Штор Варнера, да, да, Штор Варнера,
не Штурм, нет, Штурм, нет, Штурм это, во-первых, он, во-вторых, это про другое вообще, то есть,
нет, нет, есть там штурмовые последовательности, там это все, да, но это, ой, да, да, в чем не путать
метод штурма и метод мозгового штурма, да, да, да, вот, это немножко другое, да, но вот тут есть вот,
да, но, насколько я понял, насколько я так слышал, да, сошлепся на слухи, что, как бы, то есть,
дикартьячка все-таки может это разрабатывалась именно как то, что можно было бы проще написать,
ну, потому что, да, преимущество дикартового дерева, конечно, почему в олимпиадах используется оно,
а не АВЛ, потому что там дикартово дерево кодится сильно проще, чем любое из наших деревьев,
вот, то есть, просто, то есть, ну, действительно объективно его там, то есть, в него там действительно
сложно, может быть, там, может быть, сложно въехать, но, как бы, написать его очень просто.
В чём Википедии написано, что у Б деревьев получается не от К-1 до 2К-1, а от Кадака до 2К-1?
Не знаю.
Ну, скажем так, а в коре, сфорулирую так, я не знаю, в коре мне написано по-другому, кору буду я верю больше, честно.
Ну, я не знаю, видимо. Не, ну, как, нету, вот, сфорулирую так, можно теперь тихо задуматься, что, нету, можно, наверное, как бы, реализовать дерево, чтобы там было от Т до 2Т-1, до самом деле, ключиков.
То есть, скорее всего, в общем-то, мы не сильно пострадаем, просто будет чуть менее удобно, но, в принципе, мы не пострадаем, вот, логарифом.
Прям вот логариф, вот, от высоты, от высоты исходного дерева.
Так вы не говорили, что делаете все вершинками, а типа, а мы сливаем вместе и деревья, и вершины?
Конечно. Нет, когда я говорю, слить два дерева, я говорю, что мы их сливаем вместе с этой вершинкой.
Нет, это да, нет, теоретически умеет, но эту вершину надо было бы выкопать, а мы так не, да. Так что нет, Боже упаси, да.
Вот. Так, ну, теперь пришло время опробировать ту же технологию, собственно, для АВЛ-а.
Так вот, давайте доберемся в нас, в вас добрый, в нашу зону комфорта, в которой все-таки в каждой вершине два ребенка и один ключик.
Хотя, честно говоря, хотя я не знаю, что, слава Богу, потому что тут так хорошо стало, да. Я скачал вершину, у меня тут 57 детей, ну, кайф.
Нет, не кайф, что, не кайф? Не знаю.
Вот. Да. Нет, действительно, да, это удобно.
Эх, да, как удобно, когда все дети одинаковые, да, с ними можно одинаково разговаривать.
А автомат прификс функции, а автомат тот же автомат ахакарасик только когда в более одной строчке. Какая разница?
Ну, понятно. Так, ну, тихо-тихо, ладно. Так, ну, давайте вспоминать. А теперь, как сплитить и бежать теперь нам АВЛ-ки. Так, давайте вспомнить, что такое АВЛ вообще?
Да, ну, понятно, что АВЛ это такое двоичное дерево польское, у которого есть только один вариант. У любой вершина разность высоты ее от двух поддеревьев отличается не более чем на один в ту или иную сторону.
Так, ну, поехали. Теперь задача, как делать мерш. Ну, давайте делаем, как всегда. Есть дерево меньше х, есть х, есть больше х. Спрашивается, как их слить?
Если высота отличается не больше чем на один. Да, но заметим, что если высота отличается не более чем на один, то слить неожиданно тупым образом.
Вот, а что делать, если высота тут дерева оказалась неожиданно?
А можно еще один такой вопрос? Как умея сливать три дерева, элемент дерева, научиться просто сливать два дерева?
А, просто выковырить самый правый элемент из левого дерева.
А, то есть разность высоты два дерева уже сольем?
Да, без этого нет.
Это даже невозможно, можно показать, что это невозможно.
Ну, не знаю, можно ли прям показать, но скорее всего да.
Читать технически.
Хотя, вот. Значит, поехали. Как теперь слить два дерева?
Ну, да, но здесь, конечно, да, идея такая. Давайте идем, идем, идем, идем и находим, вот тут внимание, тут надо аккуратно сделать небольшую аккуратность.
Среднюю вершину, у которой высота больше либо равна h.
Где h это высота, ну, высота соседнего дерева.
Да, ну, допустим, вот у нас сказал, что hl оказалось сильно больше, чем hr.
Это h, и это h, и это h, а это r, а это r, это r.
Ну, давайте я поточнее нарисую, хорошо, вот, да.
Эти желтые буряты, да-да-да, они похожи на якутов, да, мы помним, да.
Вот, так.
Итак, но получается следующее.
Тогда, значит, что делается? Находим вот эту последнюю вершину, и к x подвешиваем вот это дерево, и именно вот эту вершину.
Ну, во-первых, замечем, что разность высот здесь не будет превосходить один. Почему?
Ну, потому что когда мы идут по какому-то пути, то высоты скачут не более чем на два, правда?
Поэтому тут как бы высота либо hr, либо hr плюс один.
Но что приятно, то есть если мы это все взяли и вот сюда подвесили, то заметим, что высота вот этого поддерева увеличилась.
Я бы сказал, ровно на один она увеличилась на самом деле.
Вот.
Но тогда это позволяет нам тогда просто прогуляться от этой вершины вверх и делать абсолютно то же самое, что делали в инсорте.
Ну, то есть вот это тоже самое ребалансирует.
Потому что инвариант вот буквально так же.
То есть такой, что мы там сделали какой-то инсорт, и мы знаем, что вот у нас нашлось тут неожиданно поддерево, в котором высота оказалась там на два больше, чем у соседа.
И мы знаем, что других проблем нет.
То есть мы на самом деле просто заменяем эту вершинку в другом месте hr на x и идем вверх.
Идем вверх и делаем те же повороты.
Ну, то есть формальное доказательство звучало бы так, что просто давайте сделаем так.
Если hr сильно больше, чем r, то рекурсивно сливаем правое поддерево hr с hr через x.
Ну вот, нам в качестве предположения индукции приходит, что высота не уменьшилась и увеличилась не более, чем на один.
Вот.
И тогда это нам гарантирует, что тогда в корне мы тоже сможем сделать какой-то поворот.
Доказательство абсолютно то же, что было.
То есть таким образом мы умеем делать мерч.
И мерч мы умеем делать снова за нашу любимую асимптотику один плюс разность высот.
Вот.
Потому что его тоже надо писать.
Там эти повороты тебе придется переписывать.
Это больно.
Нет, я прям жду, когда ты, видимо, минут через 15, максимум 20.
Даже вопрос, а почему в Олимпиадах не пишут красночерное дерево?
Да сплей для линката не помешает.
Да.
Нет, ну как какие-то линкаты можно реализовать на чем угодно.
Другой вопрос, что на чем угодно это работает залог квадрата на сплее за логарифом.
Но ответ как повезет.
Нет, он может быть, я не знаю, конкретно какие-нибудь продвинутые люди, возможно, сделали задачу, в которой линкат залог квадрат.
Я думаю, что он реально работает залог квадрат.
Ну там просто доказательно.
Может быть, я не знаю.
Я этим не занимался, я не знаю.
Но как бы отдельные вредные умельцы могли и заморочиться, в принципе.
Так вот, хорошо, мерзь сделали.
А теперь как сделать сплит?
Ну сплит делается даже еще тупее.
Потому что мы говорим, так, если надо сплитить по корню, то что мы делаем?
Отпиливаем левое под дерево, делим правое под дерево, говорим вот.
То есть очень удобно.
Вот.
Но что делать, если оказалось, что корень, что надо сплитить не по корню?
Ну ответ, детей все равно отпиливаем.
То есть как бы все, как бы у корня точно детей не будет.
Другой вопрос, что бывший левый ребенок как бы остается целым.
Вот.
А вот правый, ну там допустим, если наш элемент был справа, то вот справа мы пилим дальше.
Так, тут у нас тоже вершинка.
Если тут мы неожиданно решили пойти в левое под дерево.
Ну значит тогда получается у нас тут справа отпилилось дерево.
Вот.
Ну вот.
И тут у нас теперь вот новое под дерево.
Ну и так далее.
То есть вот у нас тут какой-то путь.
От корня, ну право, ну как сказать, там правый ребенка мы естественно отпилили.
Потому что мы его отпилили, более того, вот просто этого правого ребенка мы еще будем деребанить.
А вот когда мы пошли влево, левого ребенка мы отпилили или нет?
Вот этого?
Нет.
Если вправо, потом влево.
А вот этого?
Конечно все отпилили, да.
Ну можно сказать, что...
Ну по сути да, хорошо.
То есть на самом деле да, тут везде тут вот, то есть пилили, то есть все пилим, пилим, пилим.
Вот такая с до икса дошли.
Ну значит тогда тут тоже отпилили там обоих детей.
Или что получилось?
Получился икс, получилось последовательность слева.
И последовательность справа.
Да, пока как СБ дерево.
А что будет отличаться?
Что будет отличаться?
Ну во-первых, давайте подумаем, верно ли, что...
Ну, отличие это будет в том, что да, так.
Ну во-первых, опять последовательность снова не обязательно строго убывает.
Почему?
Ну потому что если в корне вот была аж, и у нас тут первое дерево аж минус два,
то вполне вероятно, что следующее дерево тоже будет аж минус два.
Ну потому что раз тут аж минус один,
то вполне вероятно, что у него тут левый ребенок был аж минус два.
Ну больше он не будет.
Но тем не менее, в общем, скажем так, невозрастаемость гарантируем.
Вот.
Но с другой стороны, тут, конечно, с другой стороны,
избавиться от невозрастаемости мы можем достаточно легко, правда?
То есть ну просто абсолютно то же самое.
Кладем стэк, то есть абсолютно та же технология.
Там что-то там объединяем, и в результате у нас теперь...
Есть.
Вот этот.
Да, мы его никуда не дели.
Он на месте.
Так что промежуточные элементы есть.
Это вот ваша технология, что делайте мержи только через промежуточные элементы.
Вот.
А то эти ваши дикартячки, они что-то это как-то...
Да.
Вот.
Вот.
Они что-то...
Ну вот.
Так что соответственно.
Значит, получается вот так.
Ну вот.
То есть теперь что делать?
То есть теперь у вас есть последовательство строго убывающих высот.
Но здесь слияние такое же, потому что мы тоже умеем сливать заразность высот,
причем гарантируем, что высота будет, наверное, не меньше, чем вот это
и не больше, чем вот это плюс один.
Поэтому после этого тогда получается, что у вас тут, значит, получается телескопическое слияние
вполне себе будет иметь место.
Так что получается, ура, мы победили.
Так что если они станут вот этими промежуточными...
Мы сливаем через промежуточные, я напоминаю.
Поэтому с ними ничего не надо делать.
Жил, добыл, все скачал и пропал.
Как это называется?
Про шо это я вообще...
Так.
Хотя да.
Как бы да.
Несколько лет назад прям всех было бы однозначно ассоциация.
Сейчас вопрос.
Так.
Хотя по этой логике, да.
Так, ладно, чего я стираю.
Так, ну и теперь хит сезона.
Красно-черное дерево.
А теперь да.
А теперь давайте...
А как посплитить его?
Так.
Сейчас.
Так, ну давайте думать, да.
Так, сейчас.
Нет, ну давайте сначала подумаем.
Ну во-первых, так.
Во-первых, тут как бы...
Так, ну давайте сначала подумаем, как красно-черное дерево вообще посплитить.
Да, прям ужасно.
Так, ну давайте начнем с разминочки.
Жили-были два красно-черных дерева.
И промежуточный элемент, куда же без него.
Как провести мерч за желательная разность высот?
Там больше х.
Да-да-да.
Так.
Так, ну ладно, да.
Правильный вопрос.
Давайте вспоминать.
А что такое красно-черное дерево вообще?
Так, одинаковые какие высоты?
Черные.
Да, напоминаю.
Давайте вспомним.
У красно-черного дерева сама общая высота не принципиально.
Принципиально черная высота.
Значит, черная, да, принципиально черная высота.
То есть у нас там по сути варианты следующие.
Что корень черный, черная высота у всех листов одинаковая.
Ну там черная, ну вот.
И что самое главное, никакие две красные вершины там рядом друг с другом не идут.
То есть как бы помним.
Да, у красной вершины дети черные, родители черные, все черное, в общем, соответственно.
То есть если мы делаем за разность черных высот, то это помнение может и не отражать разность реальной высоты?
Нет, это не важно.
Это не важно, потому что реальная разность, то есть реальная разность высот, это как бы разность черных высот умножить максимум на два.
Нет, подождите, а что если у нас с левым?
И что значит у одной вершины, значит высота там в два раза больше.
Это не глобально.
Ну там просто суть такая.
Пусть у тебя там была у одной черная высота 57, а другой 52.
Это означает, что ты тут спустишься до черной высоты 52 не более чем за 5 умножить на два ходов.
Да, потому что ты просто по двум красным вершинам подряд идти не будешь.
Так, да, совершенно верно.
Да, да, да, совершенно верно.
То есть самое тупое, да, то есть слияние пока то же самое.
Если у нас неожиданно черные высоты оказались одинаковые, то давайте красим вершину черный цвет и вешаем из него вот этот слева и справа и радуемся жизни.
Значит, если нам с высотами не повезло, то ну ничего, делаем, то тогда что мы делаем?
Делаем абсолютно то же самое, что и ранее.
То есть спускаемся под дерево с черной высотой такой же, как здесь.
И дальше, и дальше просто вмерживаем.
Здесь я для простоты просто скажу, давайте я скажу, что эта вершина будет красной.
То есть я ее вот вмержу вот сюда.
Единственная проблема может быть, что это будет красная вершина, у которой, соответственно, родитель тоже красный.
Эту проблему мы как в инсекте там умеем решать.
Ну не будем сейчас повторять как, но суть в том, что не более чем за два поворота и какие-то красивые перекраски.
То есть поэтому, то есть это гарантируем, что слияние явно будет там как-то от высоты.
Помните, да?
Сейчас мы находим, получается, одинаковый черный высот.
Да, находим черный, да, и подвешиваем их к красной вершине.
Нет, ну черную, да, не надо.
То есть черной могут быть проблемы.
То есть мы умеем решать проблему, когда в одном подтереве черная высота на один меньше, чем в остальном,
но мы не умеем решать проблемы, когда черная высота на один больше, чем в остальном.
Вот такая вот диспозиция.
Ну хорошо, сливать научились.
Но с другой стороны давайте думать, как же делать сплит?
Ну давайте думать, а что, собственно, поменялось?
Ну поменялось только одно, что нам нужно контролировать черные высоты,
и у нас приближут четыре вершины, могут быть как черными, так и красными.
Впрочем, это не принципиально.
То есть таким образом, ну вот.
То есть в общем-то там ничего особо не поменяется.
То есть единственная проблема, что черные высоты могут тоже не строго убывать,
поэтому это тоже надо будет проблемы решать.
Но суть, в общем-то, абсолютно та же.
Это тоже за разные высоты?
Да, ну как видите, да.
Ну это подъем этой проблемы тоже там, как легко убедиться в красно-черном дереве, делается за разные высоты.
Так что получается логарифом, ура.
То есть на самом деле, да, Б дерево не уникально, то есть на самом деле с точки зрения сплитов и мержей,
на самом деле вам и исходного овэля хватало.
Но правда, единственная маленькая оговорка,
потому что для того, чтобы делать такой,
то есть как бы тут правда маленькая оговорка для того,
чтобы сделать такое слияние там какой-нибудь сплиты,
то есть такой вот мерж там в красно-черном дереве,
вам еще придется эту черную высоту в явном виде найти.
Нет, ну да, то есть нет, ну не совсем так.
На самом деле это не глобальная проблема.
Если вам нужно просто абстрактно слить два дерева,
то во-первых, то в принципе, то как вы это будете делать?
Если вы просто абстрактно слить даже через элемент,
вы можете эти высоты, черные высоты, найти в явном виде, прогулявшись по дереву.
Ну правда, получится логарифом, да,
но как бы если вы просто абстрактно сливаете деревья за логарифом, вас это устраивает.
А так в принципе, когда вы делаете какой-нибудь сплит,
вы можете там эти, то есть там вы эти высоты можете прямо,
то есть там заранее посчитать какие у вас там черные высоты деревьев,
вы их просто аккуратно контролировать.
Поэтому чисто теоретически,
наверное, СТЛ мог бы такое реализовать.
Другой вопрос, что, видимо, решили заморачиваться?
Нет.
Потому что, видимо, глобально не увидели смысла,
то есть зачем нужен сплит и мерж в интерфейсе СТЛ.
Ну, может быть.
Нет, может и нет.
Ну, тут не только так, видите, там же сформулируем так,
для того, чтобы что-то, как бы тут еще такой момент.
Просто стандарт, это что такое?
То есть как бы стандарт, это то, что вот должен,
то есть это минимум, который должен реализовать любой компилятор.
То есть как бы если вы хотите,
чтобы все разработчики компиляторов это реализовывали,
то нужны очень жесткие обоснования, как бы почему это вообще надо.
То есть есть подозрение, что сплит сетов,
это достаточно локальная задача.
Нет, это мы с вами олимпиадники,
но как вы сами понимаете, в комитете по C++ не олимпиадники сидят.
Там сидят больше люди как бы из реального мира разработки.
Ну вот.
То есть можно половину...
То есть там...
Поэтому они там задумываются,
насколько часто вам реально нужно сплитить сет в промышленной разработке.
В принципе, вообразить себе, что вам там нужен сет,
для того, чтобы там реально что-то хранить и искать какие-то элементы,
да, это удобно, это нужно, это будем использовать.
Но нужно ли там делать сплит и мерч?
Ну, скорее всего, не принципиально.
То есть обратите внимание, там база.
То есть как бы в этом смысле,
если вы хотите использовать какие-то адские алгоритмы,
то как бы есть библиотека Boost.
Вы столкнулись с такой?
Вот.
Ну, там конечно...
То есть это когда огроменная библиотека,
в которой на самом деле можно идти едва ли не...
Ну, там просто едва ли не все олимпиадные алгоритмы,
которые только есть в природе.
То есть там есть какой-то адский шаблонный ДФС там на самом деле,
в который вы будете передавать,
что вы будете делать там,
перед проходом по детям,
во время прохода по детям и так далее.
Есть такое.
Но более того, что самое главное,
практически все новинки STL,
типа там Sharit Potterov и так далее,
они на самом деле там, скорее всего,
за 10 лет до этого были в Boost.
Вот.
Так что если вам хочется прям использовать все алгоритмы,
просто как использовать там...
Потому что там всякие DX3 там,
естественно, там тоже есть.
Там есть сплетни нож в Б-дереве.
Не знаю.
В Б-дереве не уверен.
ФФТ... Ой, ну...
По-любому не знаю.
Вот.
Но я не знаю, там очень подробнее я вас отошлю лучше к само...
Нет.
Подробнее я вас лучше там...
Нет.
Ну давайте так.
Что там конкретно, если чего там каких-то мелочей нет,
это я вас как бы отошлю, собственно, к самому Boost.
Но как бы там, понятно, многое там есть.
Вот.
Но в STL-е как бы есть только то,
что вот необходимо просто вот совсем база.
То есть там это нот.
Поэтому тут нот аккуратно.
Ну и много нот.
Ну и тем более, что как бы там же есть еще такой вот этот вот балансик,
что если вот это может быть полузнеофициальное расширение STL
в каких-нибудь глушных компиляторах.
Потому что как бы, если вам, потому что сет не умеет искать
как и по возрастанию элемент,
но вы там в глушном компиляторе можете там достать
какую-то чуть более продвинутую версию сета, которая это умеет.
Ну чисто в теории можно, но практически скорее всего это там
какой-то оверхед по разработке даст.
И по разработке, и по константе.
Ну, компиляторов есть все-таки несколько, да, все-таки поэтому такое.
Ну вот, то есть нет, здесь как бы это все как бы аккуратно,
потому что мы тут следим за тем, чтобы у нас не было там монополизма какого-то.
Чтобы, что типа существует только один там настоящий компилятор C++,
это Gnus C++, все остальное там, это дешевое там,
дешевая подделка китайцев из Microsoft'а, да.
Ну вот, это все как бы аккуратно, потому что мы тут следим за тем,
что есть там дешевая подделка китайцев из Microsoft'а, да, да, да.
Нет, это да, но у нас тут все-таки в этом смысле как бы есть как бы аккуратность.
Нет, ну тут «не».
Ну может быть.
нет я так скажу нет чисто теперь нет да не но да хорошего как бы да смысл в том что как бы да что
как бы как бы стандарте плюс говорит о том что как бы компилятор что как ваш компилятор си плюс
плюс он должен поддерживать си плюс плюс вот в этом виде да то есть понятна будет там другая
архитектура придется там скорее всего сам компилятор писать как-то принципиально по-другому
то есть это надо другой вопрос что у нас сейчас как бы видимо архитектура компьютеров там чуть
менее чем везде там одна этажа в общем-то да хотя хотя там какие-то хотя есть там какие-то
еще что там там советские разработки которые может даже не хуже работают между прочим да но
это ну возможно тут у человека но вот ну тем более да вот и да вот теперь вот да но этим
эпов вот когда вот как минимум эпов том тоже надо объяснять как должен работать си плюс плюс
нет ну как сказать нет формулирован так скорее всего значит придется к значит кому-то придется
просто под значит под это как это под айо с собственно в этом эпловские написать соответственно
компилятор си плюс плюс ну вот и там соответственно так но вот это были но вот так что соответственно это
были честные деревья абсолютно но разница в том что когда мы там берем вот эти вершины мы у них
как бы и цвета стираем но есть там эти цвета мы же учитываем для того чтобы там может быть
понимать какие высоты дирек черные высоты деревьев у нас тут есть чтобы их не пересчитывать
напоминаю в отличие от овл у нас высоты деревьев не хранят ну ничего ну не важно просто
черные красные там в плите когда мы там как бы говорим что как бы отпиливаем коре то есть там
от корня отпиливаем детей идем в какого-то из этих ребенков ну как бы как бы нам сейчас
плевать этот корень красный или черный конечно но это не важно но скажем так там не сильно
принципиально хотя ладно есть одна мелкая говорка на самом деле если в тупую делать может только
оказаться что у вас корень каких-то из под деревья будет красный ну да нет его можно перекрасить но
тогда значит надо просто аккуратно следить что у вас там что чтобы у вас там обгон по высоте не
случился вот так же в этом свой то есть в этом соседа может так что но вот потому что да но
хотя нет но хотя нет тут на самом деле заметим следующее что заметим ли мы что-то нет вот
так вы гарантировали что высоты тут не убывают но с другой стороны если у нас тут есть какие-то
равные деревья только равные по высоте черной высоте деревья только у одного из них черный
корень дрова красный то перекраска красного неожиданно может привести к тому что у вас
произошел обгон по высоте для того потому что у нас три инварианта ну сфорилируем так у
нас есть инвариант инвариант заявлял нам то что корень черный и мы это и кстати в одном
но например мы это использовали вот так но например вот когда мы вот ослеваем два дерева
мы вот это используем потому что мы вершину x изначально заявляем как красненькую если у нас
вот тут еще будет украсть корень красненький у нас будут проблемы но на самом деле это проблема
тоже техническая решается она например так то есть допустим что изначально у вас как бы все
все деревья хорошие высоты их не убывают но только столеша говорочка что отдай один из корней что
корни могут быть красненькие тогда как это делается сначала пробежимся и добьемся того что у
вас высоты строго убывают как мы этого добьемся добьемся мы этого также как и ранее просто
как мы обидеем две вершины с одинаковых два дерева с одинаковой высотой подвешиваем
подвешиваем их к вот этой приезжите на вершине а ее мы там допустим железо бетон на объявляем
черный понятно да поэтому как бы но вот то есть поэтому там как бы становится все в порядке после
этого тогда у нас оказывается что у нас есть последовательность строго убывающая но некоторые
корни оказываются красными. Да, перекрасим красные теперь черные, теперь последовательность
невозрастающая. Ну теперь там сольем еще, если там образовались равные высоты после этого.
Это как бы технический вопрос. Ну можно и так сказать. Но когда мы сливаем через
деревья разные высоты, оказывается выгодно сделать ее красной. Ну просто тупо так удобно.
Так что так. Но это уже ладно. Давайте так, детали я вам оставлю на самостоятельное
додумывание. То есть не сильно сложно в общем-то. Вот, но пока заметим, да, отметим, что мы в принципе
обсудили блок честных деревьев. То есть вот АВЛ, красно-черные Б, это такие приятные ноты.
Это такие приятные деревья, которые делают все честно. Ну вот, правда да, с точки зрения
реализации с минус, что они конечно по реализации громоздки там требуют какой-то константы. Поэтому
там есть конечно альтернатива в лице дикотячки, которая делает все вероятносты по ноте,
поэтому пишется за муа. Но на самом деле дальше логика наука пошла немножко в другом направлении.
Потому что наука заявила, ну вот, потому что наука такая, наука так заметила, что из
практики, что на самом деле не всегда оказывается оптимально использовать именно деревья, у которых
все работает за логарифом. Почему? Ну потому что нет, это конечно, потому что это деревья,
они идеальные и лучше не придумаешь, если у вас запросы абсолютно рандомны. Да, то есть
если вас там тыкнуть, ну это реально. То есть если вы ничего заранее не знаете и у вас там все
запросы могут быть абсолютно произвольны. Но вот возникает вопрос, но иногда возникает вопрос,
вот например, вот у вас там допустим такая самая простая задача. Хочет дано n элементов и вы
хотите из них составить двоичное дерево поиска. Ну для того, что там элементы искать. Вам может
показаться, что самое оптимальное, давайте из них сделаем типа вот эту двоичную кучу и возрадуемся.
Но оказывается, что это не всегда оптимально. Потому что оказывается, что если вы заранее что-то
знаете о запросах, то может оказаться, что дерево выгодно делать по-другому. Вот обычно,
если вы когда-нибудь изучали оптимизацию кнута, ну как кто изучал когда-нибудь оптимизацию кнута?
Ну динамическое программирование такое есть. Ну да, но по-разному там можно это делать,
то смотрите, вот оптимизация кнута, то там возникала действительно такая задача,
что дано n элементов и про каждый из них известно, условно там сколько раз его будут искать. Надо
составить двоичное дерево поиска таким образом, чтобы суммарное время поиска всех элементов было
как можно меньше. И там выяснялось, что это такая не самая, ну вот, то есть выяснялось, что это такая,
в принципе, какая-то задача на ДП. Ну не будем сейчас копать ДП, понятно, не сильно сложно. Вот,
но просто я к чему? То есть это просто оказывается к тому, что действительно такое дерево может
оказаться лучше, чем вместо этого вот обставить какие-то ВЛки, вот эти вот Б и так далее. Вот,
поэтому там вот возникала проблема, что даже там под какие-то конкретные случаи создавались какие-то
отдельные деревья, у которых есть там какие-то, может быть, адские асимптутики. Ну, может быть,
может быть, какой-нибудь там информационный дерево, например, которое там, если в элемент тычут с
вероятностью P1, то есть там или там тыкали исторически, то оно будет там подгоняться так,
что действительно как бы там поиск его будет работать за какое-то хорошее время. Ну,
за какой-нибудь там, за логарифм 1 делить на P на эту вероятность. Вот, то есть там на самом деле
можно открыть прям оригинальную статью Тарьяна, то есть там много деревьев, то есть есть там всякие
там для этих случаев вот такие, для этих вот такие, там какие-то фингер-3 возникают там еще.
Не знаю. Я не знаю, что такое фингер-3. Ну, может быть, но я не помню там какой-то логарифм,
там какие-то оценки модульные и так далее. Но как бы в чем победа? То есть на самом деле,
то есть тут идея радостных это, ну вот, то есть идея действительно в том, но вот идея в данном
случае не просто Тарьяна, тут у нас как бы авторов 2, там Дэниел Слейтер. Ну, возможно,
встречали есть такой человек там синий на Кодфорсе, все такой. Дэниел Слейтер. Ну,
да. Ну, одно дело придумывать крутые алгоритмы для практики, там и быть ученым. Другое дело,
не знаю. Дэниел, да. Уже зеленый. Индус? Нет.
Нет, это уже другой вопрос. Ну, неважно. Нет, ну всякие. Да нет, вряд ли. Нет, ну какие-то
раунды писал. Нет, наверное, весело. Нет, ну быть олимпиаником-то разные вещи. Нет,
он стал крутым. На всякий случай мы сейчас будем изучать структуру данных, которая придумалась
до того, как спортивное программирование начало глобально выходить за пределы США, скажем так.
Потому что речь сейчас идет где-то о 84-м ходе. Ну, плюс-минус. 84-86, там что-то в этом роде. То есть
ACPC, то есть сам себе чемпионат мира ИСМ появился, там считается, что он стартовал в 77-м году. Вот,
но как бы он долгое время был только там, только локально в США. То есть там, скажем, всякие там
российские команды начали участвовать где-то, по-моему, года с плюс-минус 90-го. Нет. Нет,
но почему? Первыми в истории чемпионами мира, по-моему, едва ли не Дуров и Лопатин в 2000-м и Стале.
Да, Лопатин абсолютно тот самый. А Дуров, скажем так, старший брат того самого. Я вам даже больше скажу,
тот самый Лопатин и так далее. Они, собственно, имели прямое отношение к разработке исходной
версии компании ВКонтакте. Да и к телеграмму вроде тоже. Вот. То есть нет, Лопатин к этому
сейчас отношения точно не имеет? Нормально. Ну вот. Так вот. Ну вот. Так что, соответственно. Нет,
так что нет. Нет, это все там первое, это было. То есть если там покопать во всех медалих, там, да,
будут там двукратные чемпионы. Там, собственно, Дуров, Лопатин, у них там два сокомандника разных
были, у них они там дважды чемпионами стали. Потом где-то там в четвертом году золотые медали выиграл
Станкевич. Тоже тот самый. Да. Так что в случае чего у Станкевича как бы есть медалька и, собственно,
как участника тоже. А не просто это там. Называется тренером семи чемпионов мира, там подумаешь.
По мелочи. Вот. Нет, ну. Ну я не знаю, по-моему, является ли Геннадий Коткевич тренером чемпионов.
А, уже является, ну. Не, ну золотых-то почти, наверное, да, но впрочем. Ну, нет, ну,
давайте так. Нет, ну, не совсем. Геннадий Коткевич, по-моему, становился чемпионом мира, когда он
становился чемпионом. По-моему, что-то типа. Ну, я не знаю, скажешь так, это были какие-то
года, разнесенные на два. То ли 13, ну я не помню, это как бы в 14-м точно нет. Вот я участвовал,
его там не было. Вот. Но как бы было это то ли в 13-м и 15-м, то ли в 15-м. Нет, хотя в 15-м,
17-м точно нет, потому что в 17-м году полуфинал выиграл Фистех. Ну, вот. Да, да, да, это было.
Кто это был? А, ну да, Останин Голованов, Уваров, видимо, это и были. А, ну вот так. Хотя,
нет, ну тут сложно, потому что там. А, ну понятно, да, потому что они тогда съездили и тогда в итоге
за три минуты до конца все-таки там МКУшники их отобрали чемпионство. Ну, скорее всего, сейчас.
Да и бог в памяти. Ой, ладно. Нет, это я вам скажу, это при мне просто было. Геннадий,
значит, нет, Гимадеев, Луготь, Шишкин. У них было пятое место соответствующего полуфинала.
А нет, в Ру. Нет, все еще хуже было. Там эпическая история была. Потому что, значит, было так,
потому что это был сезон 10-11 года, когда командователь Роджер в составе Гимадеев,
Луготь, Шишкин заняла пятое место. Так приятно было потом читать комментарии и видеть там
комментарии, что Фистех что-то нереальное вытворяет. Да, для справочки, до этого момента Фистех
выходил на финал только один раз в 2006 году. Правда, на этом финале занял 13 место.
Обидное 13 место, потому что по ходу контеста они там из топ-10 были очень много времени.
Но не важно. Соответственно, в девятом году на финал Фистех не проходил. Это был мой первый
сезон, но я тогда не попал на полуфинал, потому что от Фистех тогда две команды проходила,
а мы по Фистеху третьи были. Но там были опытные люди. В 2010 году, соответственно,
они заняли пятое место, но сам финал слили. Какое-то сорок лохматое какое-то там.
Пошли в следующий сезон, но, правда, безыльтернативно. Честно говоря, не ожидалось,
что от Фистеха им кто-то навяжет борьбу. В результате они вышли на финал, заняв,
по-моему, на полуфинале какое-то восьмое место, обыграв девятое другую команду Фистеха.
Вот, не буду тыкать, кто там был, да. Нет, ну ладно, надо тыкнуть пальцем. Там были,
собственно, мы были в составе, да, Гош Чебанов, Ваня Смирнов. Тогда такой состав был. Вот,
так вот. Мы им тогда проиграли 15 штрафных минут. Просто буквально одну лишнюю посылку
с Compilation Error. Да, на полуфинале, да. Но, правда, они сказали, что у них тоже была посылка с
Compilation Error, так что тут не считается. Вот. Ну, вот, честно скажу, мы тогда, честно, как бы,
мы себе тогда не ставили целью выходить на финал. То есть, наверное, но вот поэтому так. Вот. Ну,
не то, что мы себе ставили целью на финал не выходить, конечно, но мы, как бы, не ожидали,
что мы тут, оказывается, можем навязать борьбу. Ну вот. Ну, вот. Ну, и оказалось, что и слава богу.
В результате они поехали на финал и взяли там, собственно, золотую медаль, абсолютное третье
место. То есть, более того, отдельно там ходит видео на том, как они там решают пятую задачу,
вообще возглавляют таблицу. То есть, это просто отдельное там эпическое видео,
просто этого абсолютного счастья. Да, ну вот. Да, это было шикарно. Вот. Соответственно. Вот,
значит, потом, что, вот. Значит, это получается был, ну вот, это были, значит, это был 10-11 год.
Вот. Значит, да. Ну, так, кто там, осталось только вспомнить, кто там в те годы чемпионом был.
Хотя, нет. Нет, дай бог памяти. То есть, вот про наших я помню, а кто там дрался за чемпионство,
я не помню, скорее всего. Хотя, там, начиная с 10-го года, вроде как, кроме Этмо, Питера,
и потом МГУ, и потом где-то МГУ, в общем-то, никто больше чемпионат не выигрывал. Вот. Нет,
ну, так и так. Потому что последними чемпионами были так. Потому что, я помню точно, в 19-м году,
потому что, значит, чемпионами второй раз стали там МГУ и Рэд Панда. Ну, там и Патов Макеев,
Горбунов, это точно. Вот. Ну, в 2020, а с тех пор у нас произошел сбой, потому что в 2020 году
финал прошел в 2021, его выиграла команда Нижегородского университета. Ну, в составе,
собственно, Данилюка Калинина, собственно, и Лера Рябчикова, да. Вот, соответственно. Ну,
вот. Но с тех пор, после этого, произошел только один финал, где впервые, за, по-моему, несколько
десятилетий, по-моему, чемпионом стал кто-то из Америки. Да, китайские межнары из MIT, да,
там стали чемпионами. Ну, и являются действующими чемпионами. Вот. Ну, было. Нет, ну, как понятно,
что учитывая, что вы CPC, вы на финале можете поучаствовать не более двух раз, понятно,
что тут все относительно. Вот. Так что там. Так что, нет, этого. Так что, нет, это было, там, это,
это все было вот так. Ну, да. Нет, в основном, тогда чемпионами там в основном становились разные
команды ИТМО. Где-то становилась Геннадия. В 2014 году была команда СПБ. Так, стоп. Да. Или,
или зачтем вот эту болталонию за перерыв, потому что, в принципе, да. Ну, вообще, я не знаю. Ну,
где-то там, ну, где-то в 13.45-13.55 нас, как бы, начнут отсюда жестко выбирать. Да. Да. У нас есть час.
Так что, ладно, придется зачесть за перерыв. Да. Вот. Ну, что делать? Ну, ладно, посмотрим. Ладно,
если получится меньше, значит, можно будет вас пораньше отпустить. Хотя, впрочем, не уверен.
Потому что, как бы, смотрите, значит, если, так, да, не знаю, уже не помню, как мы вышли на всю эту
историю CPC. Да, вот. Да, не помню, как это было, но я скажу. Хотя, ну. Нет, там какие-то другие составы
были. Нет, видимо, в 17-м году. Ну, да. Шинетарет Панда, как бы, вы свои полуфиналы вроде брала.
Вот. Да. Ну, ладно, неважно. Да ладно, эти подробности, господи, на сайте Нирка можете
там подробно посмотреть, какие там составы были. Вот. Ладно, значит, зачем нужно сплей? Так вот,
значит, как тут радостно сообщают нам авторы. Всякие синие, ну, Код Форсисе. И некоторые,
возможно, там даже нервировшиеся никогда. Вот. Так вот, они нам гордо теперь сообщают,
что на самом деле сплей, теперь вот эти все большие эти фингер, три прочие разные деревья,
они на самом деле не нужны. Потому что, если вы просто верите в амортизацию. Ну, если вам,
как бы, амортизация нормальная, то у нас есть сплей дерево, которое умеет все. Да. Да. Нет,
почему? Сортировка за линию она, конечно, не умеет. Но сортировка за НЛОГН она вполне умеет.
Потому что добавим все элементы за НЛОГН, потом пробежимся ДФС. Ну, или просто поудаляем
элементы, тоже пойдет. Потому что сплей дерева карантирует следующее. Во-первых, ну, в плане
какой-то учет. То есть, если подгонять правильные потенциалы, то можно показать, что, во-первых,
все операции в сплей дереве будут делаться за логарифом. Если подгонять другой правильный
потенциал, то можно подгонять, что если каждая вершина ищется с вероятностью там П1,
то тогда учетное время ее поиска будет логарифом 1 делить на П1. Вот. А если взять эти ваши фингер
три, то их тоже можно взять и выбросить, потому что сплей дерево тоже из-за их асимптотику,
не помню, какую оно работает. Чего? Не, ну не настолько. Нет, если ты его ищешь с большой
вероятностью, то да. Нет, ну просто нет, скорее всего, это значит, что да, его тоже будешь там
суммарно за 1 искать. Потому что основная идея этого дерева предельно простая. То есть,
оно даже называется не сплей дерево, а вот оригинальная статья, если вы гугланете,
будет называться там что-то типа self-adjusting tree или что-то в этом роде. А, self-adjusting,
data structure. Именно. То есть, оно будет внутри себя само балансироваться. То есть, более того,
нет, более того, смотрите. Основная идея такая, вот мы в Аврельке подгоняли какую-то балансировку
с помощью поворотов. Так вот, у нас теперь будет сейчас принципиально новинка. То есть, раньше
мы страдали там тремя разными способами, чтобы добиться того, чтобы у нас там был какой-то
баланс. Либо высоты прям железно одинаковые, там либо они были там плюс-минус 1, либо там
плюс-минус 1, либо там красно-черное вот это там издевательство. А теперь мы пойдем другим путем.
Мы говорим, чтобы все, больше никаких вариантов нет. Теперь любое из там n-ого числа каталана
двоичных деревьев поиска является корректным сплэй-деревом. Да, спрашивается, за счет чего
логорифм. Ну, а первое, за счет амортизации. Самое главное, самая главная идея просто такая,
что скажем так, каждая по сути операция это спуск по дереву к какой-то там, ну где-то вот
какой-то вершине, правда. Так вот, у нас, так вот, мы будем вводить мистическую операцию сплэй от V.
Вот, она будет, значит, за реальное время, за реальное время тета от глубины вершины V,
делать некие там мистические повороты, относительно мистические, таким образом, чтобы вершина V стала
корнем. То есть вот такой вот неожиданный кэш. То есть условно, если вы искали вершину V, то в
результате операции, то есть вы как бы спуститесь до вершины V и вызовите сплэй. В результате вершина
V окажется тупо корнем. То есть это получается такой кэширующий эффект. То есть, соответственно,
если вы что-то искали, то если вы еще раз через секунду захотите найти эту вершину, то она будет
у вас просто рядом с вами в коре. А если через три секунды, то она из этого корня, скорее всего,
не сильно далеко уйдет. Вот, понятная идея, да? То есть вот такой вот красота. Вот. То есть вот такая
вот мистическая идея. То есть еще раз. То есть окажется, ну, идеально окажется так, что реальное
время. То есть реальное время это от, так сказать, глубины. Нет, не высоты, а глубины вершины V,
то есть расстояние до корня. А учетное время, а вот в зависимости от потенциала. Но нас будет
интересовать, что это будет от логарифа. Ну ладно, в общем случае на самом деле мы докажем,
что это будет от логарифа V делить на V с индексом V. Вот так. А значит это следующее. Откуда берутся
разные потенциалы. Мы на каждую вершину навешиваем, значит потенциальщик W. Там, условно говоря,
навешиваем чиселку W. Про чиселку W мы знаем только одно, что чиселка W с индексом V каждая
больше либо равна единице. А W это просто сумма по всем вершинам, так сказать, весов вершин.
Самый тупой вариант, это когда у каждой вершины W равно 1, тогда это в точности логая. Да,
мы это будем доказывать именно в этом виде. Почему? Ну просто потому, что нам когда-нибудь,
как минимум, когда-нибудь в линкате нам это тоже пригодится. Ну да. Но для любого,
только вот чтобы эти W были больше либо равные там. Хотя здесь-то это не принципиально, конечно.
Но потому что заметим, что такая сим-точка обладает приятным свойством. Если вы все веса
домножите на константу, то ничего не поменяется. То есть условно говоря, вы сантиметров килограмма
переведете, в общем-то. В реальности они, конечно, никакого значения не имеют. То есть как бы да,
в плей-дерево вы не храните никаких весов. То есть максимум, что вы может быть храните,
это указатель на родителя. И то не факт. Ну и то понятно, что для большинства задач на самом деле
это не надо. Потому что скорее всего во всех задачах, которые вы решаете, вы к вершине W
спускаетесь как-то сверху. То есть спускаетесь как-то сверху, поэтому знаете весь ее путь. Поэтому
когда вы вызываете сплей от W, то путь вы уже знаете. Поэтому родителей хранить не обязательно.
То есть как видите, смысл в том, что как бы этот сплей – это такой способ оплаты. То есть вы можете
спускаться к какой угодно вершине. Если вы вызовете от нее сплей, то как бы вот этот спуск до
нее оплатится. Понятно, да? То есть вот такая идея. То есть вот мистический такой сплей. Пока визуально
вы можете считать, что он делает просто едва ли немалые поворотики, вот эти локальные. Ну и в
принципе, но оказывается, что если у вас есть такой сплей, то ну что можно делать? Ну на самом
деле да. Ну ладно, как искать элемент? Думаю, очевидно. То есть ищем, как обычно, в обычном дереве
поиска, а потом от найденной вершины или от последней рассмотренной вершины, если вы ничего
не нашли, запускаем сплей. А про баланс ничего не знаем? Вообще ничего не знаем. То есть нам наплевать.
Нет, ну там сплей просто будет работать за счет того, что там, конечно, поворотики будут чуть-чуть
посложнее, чем просто малые поворотики. Но пока можно себе вообразить и это. Там как бы не сильно
сложнее будет. Вот, ну теперь давайте подумаем, что еще можно сделать? Ну давай, ну на самом деле
тут все операции будут на этот раз сводиться к сплиту и мержу. И вот теперь задача, как отпилить,
как сделать сплит по элементу X? Да, совершенно верно. То есть как бы действительно сплит
действительно будет выглядеть неожиданно тупым образом. Значит, найдем в дереве этот элемент,
значит вызовем от него сплей, вот он теперь в корне. Ну и значит, давайте тогда отпилим от него,
то есть отпилим теперь правого ребенка или левого ребенка. Да, здесь уже сплит без
промежуточного элемента, хотя можно в принципе и с ним. Не понял вопроса. Никаких. То есть мы
работаем со сплей деревом и варианта в нем никаких. Это просто обычное двоичное дерево.
Просто отличие только одно, что мы оплачиваем какие-то спуски до вершины V с помощью мистической
операции сплей, которая с помощью каких-то поворотов поднимает V в корень. Все. Вот это все,
что мы знаем. То есть никаких вариантов там не поддерживается. Да, просто двоичное дерево. То есть
как я сказал, любое двоичное дерево, дерево поиска может оказаться корректным сплей деревом. То есть
никаких проблем. Здесь как бы не любая паста. Ну правда, тут конечно маленькая оговорка, что да,
вам может показаться очевидным, что если вы умеете делать сплей за логарифом, то как бы
и эту операцию вы тут делаете получается за сплей плюс от единицы, поэтому очевидно,
что это тоже работает за логарифом. Но если вы достаточно грамотные люди, то вы понимаете,
что тут надо сказать, видимо, что-то еще. Потому что от единицы реального времени это вовсе не
означает, что это не от плюс бесконечности потенциального. Поэтому тут вам придется,
конечно, то есть придется тут потенциальчиками побаловаться. Не совсем, не совсем. Значит,
там будет ситуация такая. У каждой вершины есть, во-первых, w с индексом v, это мы будем
называть вес вершины. Значит, также мы введем понятие czv, но я условно это буду называть cz,
конечно, не совсем корректно. Это сумма весов в подделье вершины v. Понятно, да?
Ну, возможно, нам еще пригодится. Ну, короче говоря, так. Вот, значит, что у нас тут еще будет?
Ну, короче говоря, может быть, мы введем еще кое-что. На самом деле, так скажу, потенциал,
он сумма по всем вершинам, логарифма этих вот cz. Да, логарифма честного двоичного.
Нет, мы введем ровно такой потенциал. Другой вопрос, как мы будем веса вешать?
Ну, это не важно, мы сразу в общем виде докажем. То есть, если вы этих весов подставите один, то будет победа.
Так, но пока же нам нужно это так. Мы, конечно, это будем отдельно обсуждать, может быть, да.
То есть, не знаю, посмотрим сейчас по времени, может даже не сегодня, но неважно. Значит, к чему это нас приводит?
Значит, потенциал есть? Потенциал есть. Вот. И, значит, теперь давайте подумаем, если мы отпилили от дерева такую вершинку, такую штуку,
какая учетная стоимость у нас в этой операции будет?
Да, ну, естественно, да. С точки зрения, мы подразумеваем, что у нас в системе есть несколько деревьев, и потенциал системы – это сумма потенциала всех деревьев.
Да, но теперь заметим, что когда мы отпиливаем от корня ребеночка, то как бы заметим, что меняется только ССшка вершины, и то уменьшается.
Поэтому получается, что учетная стоимость конкретно этой операции не более чем 1.
У нас же потенциалы, когда мы делали сплей, изменили, а после него, говорю, что все чуть меньше.
Да, ну, нет. Сначала мы сделали сплей. Его учетная стоимость была вот логорифом.
Пока не доказали. Пока в это верим.
Но далее теперь заметим, что от пил заведом работает за единицу.
Но другой вопрос, за что будет работать при пил?
Ну, потому что, как вы думаете, как мы будем делать мерш?
Да, совершенно верно. То есть при пил будет работать так.
Мы найдем в левом дереве самую правую вершину. Вызовем от нее сплей.
То есть получится вот что-то такое. И справа от нее повесим вот это правое дерево.
Ну, то есть еще раз. Как слить два, как теперь померзнуть два дерева?
А два дерева с элементом или без?
Без элемента даже. Хотя, может, в принципе и...
С элементом же нельзя просто?
Хотя, ну, смотрите, с элементом, да, без проблем.
Ну, с элементом вообще просто взяли, к нему повесили.
Нет, а по большому счету вот эта версия недалеко ушла.
По большому счету мы просто самый правый элемент, по сути, достали и ударили.
Чтобы потом его обратно туда же повесить. То есть это одно и то же.
Вот, то есть действительно оказывается, что если вы просто возьмете вершину
с каким-то своим весом и привесите к ней два дерева,
то учетная стоимость этого привешивания окажется, ну, просто потенциал этой вершины, короче.
Точнее, логорифм суммы весов, получается.
Вот.
То есть логорифм суммы весов.
Поэтому вам тут и надо следить, что если W там не сильно большая, то все адекватно.
Получается, легорифм работает за логорифм все-таки?
Конечно.
Если сплит за единицу, то мерч логорифм.
Нет-нет-нет, сплит тоже за логорифм, потому что там сплит.
Ну мы если сплит пока не рассматриваем.
Ну, скажем так, сплит работает за сплей плюс единица, мерч работает за сплей плюс вот все-таки лог СЗ.
Да, тут, увы, тут ничего не поделаешь.
Вот.
Но, тем не менее, вот, оказывается удобно.
Ну, потому что когда ты вот делаешь вот этот отпил, этот отпил работает за от единицы
реального времени и учетного тоже, потому что потенциал это не увеличивает.
Вот.
А тут потенциал увеличивается, как бы, на логорифм веса, поэтому учетная стоимость этого,
конкретно этих подвешиваний такая.
Так что вот такая вот красота.
Вот, значит, что-то у нас еще.
Ну или можно было, знаете, как сказать, чтобы аккуратнее было, логорифм суммарного,
там, суммарного веса поделить на вес вот этой вершинки, на самом деле.
А почему пример же на логорифм у нас увеличивается?
Потому что, ну, потому что учетная стоимость подвешивания будет не единица, а логорифм.
Почему?
Потому что у этой вершины потенциал резко, там, был он, у него логорифм ее веса, да?
А стал логорифм суммарного веса всего дерева.
И что?
Ну, просто я говорю, конкретно, конкретно вес вот этой вот операции, когда ты подвесил,
тогда получается он не единица.
То есть учетная стоимость оказалась больше, чем реальная.
Да, ну, суммарный вес поддельного этой вершины увеличился.
Вот, поэтому получается, что и потенциал увеличился,
значит, получается, учетная стоимость тоже оказалась больше, чем реальная.
Ну, по сути.
Ну.
Ну, и сейчас изменения.
Нет, почему время работает с плея?
А, нет, это если вы вот это доставали.
Ну, кстати, да, если вы мержали с промежутком, то, кстати, с плея здесь не было.
Ну, да, что-то похоже на время работы с плея, потому что, как бы, с плея тут не было.
А так, в принципе, по ходу, да.
Вот.
Ну, там, ну, там идея в том, что, как бы, при сплее,
при мерже через промежуточный элемент с плея как такового не было.
Но, заметим, что, по большому счету, потенциал увеличился,
она в точности логарифма суммарного веса,
минус логарифм, соответственно, того, что там было перед этим.
То есть, ну, это в точности на всякий случай есть логарифм двоичный,
w делить на wx.
То есть, получается, это значит, учетная стоимость получается 1 плюс вот этот логарифм.
И это просто тут было отмечено, что это очень похоже на то, что мы мечтаем увидеть в сплее.
Вот.
То есть, ну, вот.
То есть, это будет такая оценка, хотя, честно скажу, в реальности скорее,
то есть, в реальности мы с вами докажем по факту вот это вот.
Ну да, понятно, что это лучше, чем вот это.
Потому что, да, мы с z можем оценивать, оцениваем снизу, как вес этой вершины,
поэтому окей.
Но это мелкая деталь.
Сумма логарифмов.
Что?
Какие?
Где?
Размеры?
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Тогда непонятно, на что конкретно логарифм.
Да, непонятно, конечно.
Логарифм какого-то произведения.
Ну и что?
Нет.
Нет.
Почему?
У нас дельтер.
Это все еще лог.
Нет.
Тут он не принципиально.
Ну, то есть, это можно сказать, как произведение.
Ну и что?
Можно выписать, как появился.
Поменялся где?
Ну, после.
Ну, смотри, как он поменялся.
Смотри.
Ну, заметим, что, смотри, СЗ.
Ну скажи так, утверждение такое.
Значит, это сумма по всем СЗ, логарифм СЗ.
Заметим, что СЗ поменялась только у одной вершины.
У Икса.
И как она?
Чего?
На каком пути?
Эти деревья вообще не менялись, поэтому...
Нет, какой пути?
У нас здесь сплетая небо.
У нас здесь не спой.
Не-не-не.
Мы сейчас рассматриваем мерш с промежутком сразу.
Когда он нам да.
Вот.
Тогда как здесь поменялся?
Но тогда, соответственно, как поменялся СЗ?
Ну, СЗ был у нас...
Ну, когда мы ничего не подвешивали, СЗ совпадал просто с весом.
А когда мы подвесили, он стал просто W, типа суммарным
вот этим весом.
Вот и все.
Вот.
Так что такая вот неожиданная идея.
Вот.
Ну, а теперь заметим, что всякие вставка, теперь
просто мы больше не заморачиваемся, потому что как делать
вставку?
Ну, вот, естественно, просто посплитим по элементу
и сделаем вот это.
Да.
Как удалить?
Достать, повесить, там, довести элемент до корня
и радостно его казнить.
Вот.
Ну, как-то да.
Просто да.
Просто так казнить нельзя.
Если ты король, то как бы святое дело.
Да.
Ну, вот.
Соответственно.
Вот.
То есть получается очень удобно, то есть всякие,
понятно, всякие прочие там эти проталкивания.
То есть понятно, что там всякие там какие-нибудь
проталкивания, операции сверху.
В общем, здесь тоже прекрасно работают, как вы понимаете,
да?
Да.
Вот.
То есть как бы...
Да, нет.
Ну, как уже...
Нет, если у нас есть сплит и мерч, то как бы понятно,
что все там, все описанные деревья прекрасно работают
по неявному ключу.
Да.
Ну, я думаю, там не надо рассказывать о концепции
неявного ключа.
Да.
Я надеюсь.
Или надо.
Так, ладно.
Есть кто живой вообще?
Или все.
Или все.
Или слова неявных ключи всех вы просто выводят.
Кто-то живой есть.
Нет, живой-то есть, но я просто не пойму этого,
потому что он как бы никто не берет на себя ответственность.
Что сказать?
Не надо.
Не надо.
Не надо.
Не надо.
Не надо.
Не надо.
Не надо.
Никто не берет на себя ответственность.
Что сказать?
Не надо.
Или наоборот?
Что как бы...
Ответ...
Нечем было ответить одному.
Надо было знать...
Ну вот, да.
Хорошо.
Да, но нет.
Можно так сказать.
Ставите это просто тут.
Как всегда.
Тут лучше аккуратно.
Хорошо.
Так.
Ну ладно.
Как мы сделали?
И все.
Потому что сплит делают только по ключу,
который есть в дереве.
Эм...
Мы же сказали, что если в ключе нет деревья,
давай поставим максимально из левого по дереву.
Это мерже.
Так.
Нет.
Ну, смотрите.
Нет.
Нет.
Ну, идея...
Значит, да.
Действительно.
Как правильно заметили, что...
Действительно.
Как там делать с...
Как это...
Ну, на самом деле, инсерт можно сделать так.
Давайте этот инсерт честно искать.
То есть, честно идем, идем, идем, идем.
Ну, кстати, если мы его найдем, то не надо вставлять.
Но, допустим, мы его не нашли.
Тогда это означает, что мы тут шли, шли, шли, шли.
Вот до какой-то вершинки дошли.
Попытались пойти вправо.
А там...
Вот.
Что мы тогда делаем?
Ну, тогда, значит, у меня возникает мистическое подозрение.
У меня возникает мистическое подозрение, что этот элемент
был максимальным элементом в дереве, который больше
этого.
Ну, если мы здесь вправо попытались пойти.
Меньше.
Да.
Это максимально...
Ну, такой, типа да, а пербаунд наоборот.
Ну, да, лавирует, то есть...
Ну, вот.
Значит, тогда идея такая.
Ну, вот.
Значит, смотрите.
Нет.
Просто тогда смотрите.
Тогда идея такая.
Тогда, раз это так, то нам останется просто посплеить
этот элемент в корень и отпилить от него правое
поддерево.
Все.
Все элементы будут больше, а в левом поддере будут
все элементы меньше.
Сплеем от него?
Да.
У нас в левом поддере.
Ну, да.
Ну, вот.
Ну, так, то есть, я говорю, самое сложное здесь, это
поверить, что этот элемент действительно максимальный
и меньший.
Мы делаем, может, подвесить просто копию себя, а потом
просто их сверх корень?
А нет.
Ой, ой, ой, ой, ой, ой.
А вот это небезопасно.
Потому что вы конкретно этим подвешиваем, неконтролируемый
вы повесили, там мы изменили потенциал.
Потому что у кучи вершин ССшки поменялись, логарифы
поменялись.
И как их там адекватно оценить?
В концерте просто вставляем и делаем сплей, да?
Нет.
Нет, нет, нет.
То-то и прикол, что мы его не вставляем.
Потому что, смотрите, просто, да, была бы мечта просто
повесить его в это место и сделать его сплей, но
просто проблема в том, что сама по себе вот эта операция
подвешивания, вот этот потенциал увеличивает.
Причем как-то не особо контролируемо.
Ну, я не знаю, хотя там, конечно, разные потенциалы
есть.
Потому что там бывает потенциал, когда вы, кстати, эти логарифы
округляете вниз.
Вот.
Мы им пользоваться не будем, потому что это не самый
крутой потенциал.
Но если там вот такой логариф, то как бы вам придется
тогда пробежаться по всему этому пути, посмотреть,
что у каждого из них ССшка там увеличилась на вот вес
этой вершины и насколько там все изменилось суммарно,
мы не знаем.
Хорошо.
А, то есть, тогда мы должны вызвать сплей от родителей.
Поэтому мы вот от этой вершины, от родителя вызываем сплей.
Я, скорее, сплит даже, на самом деле.
Мы от него можем сплит вызвать.
Ну, но это уже опять, да, другой причетальон.
Зачем вы нам сами принесли письмо, лучше по почте отправить.
Ну, вот это будет.
Потому что мы уже пришли в эту вершину.
Давайте лучше сплей от нее и вызовем.
Она станет корнем и, собственно, отсплитчиваем правое под
дерево.
Все.
Отсплитчиваем и добавляем вершину между ними.
И, по сути, да.
По сути, да.
Вот.
То есть, вот такая.
То есть, вот так вот инцерк можно сделать.
Мы сделали сплей от нее.
И что там оказалось?
Оказалось, что...
Но оказалось.
Нет, оказалось, что вот она оказалась корня, значит,
тут все элементы больше х, она сама меньше х, и тут
все элементы меньше х.
Следовательно, как сделать сплит по х у этого дерева?
Вот так.
Просто подвешиваем х вот туда.
Нет.
Нет, знаете, пока ничего не подвешиваем.
Нет.
Х, скорее всего, мы, видимо, если мы скажем, что просто
вот нам х и давайте подвесим его вот так и вот так.
Да.
Выглядит будет не совсем кузяво, конечно, но вроде
адекват.
А потенциал как изменится?
Ну так...
Не, от того, что отпилили под дерево, потенциал только
уменьшился.
А вот этот...
А это идентично вот этой ситуации.
Так что ничего страшного не произойдет.
Ну, то есть, это будет гореть?
Да.
А потенциал...
Да, то есть, потенциал и опять логарифм вас приветствует.
То есть, тут, конечно, эти непрерывные какие-то
монеточки, конечно, возникают.
Вот.
Но...
Ну, ничего страшного.
Такое может оказаться.
Поэтому вам придется рассмотреть симметричный случай.
Тогда в этом случае я утверждаю, что это будет как раз Супербаунд.
Ну, придется, да.
Ну да, да, да.
Ну, это не то, чтобы сильно глобально.
Вот.
Так что-то получается, что да.
То есть, если мы верим в эту мистическую операцию...
Так, сколько?
Ой.
Ага.
Ага.
Так.
Ну вот.
Так, ну ладно.
Выяснилось, что пара у нас еще не закончилась,
поэтому мы все-таки еще можем обсуждать дальше.
Но я надеюсь, что мы...
Ну ладно.
Но правда, по большому счету мы заметили, что, в общем-то,
мы уже полностью свели задачу к чисто тому,
чтобы адекватно реализовать сплей.
Правда?
Так что смотрите.
Сейчас будет немножко мистики.
Хотя ладно, с вами, конечно, по-моему, любая мистика
оказывается хорявной, на самом деле.
Ну вот.
Вот.
Да.
Хотя, честно скажу, там чисто в среду, что-то, по-моему,
ваши великие предшественники сильно удивились,
в каком темпе мы идем.
Да, будут.
Типа шо, быстро.
Шо, чо?
Уже середина октября?
Уже красно-черное дерево?
Чего?
Чего?
Нет, старокурсники, да.
Ну я говорю, ваши предшественники.
По ходу, да.
Так, безобразие.
Ну так.
Ладно.
Не, как раз-таки, по-моему, он кому-то, он, типа, не
проверял.
Но он, как правило, 003, по-моему, больше, и он, типа, игнорк
сразу же.
Я думаю, что он, как правило, 003, по-моему, больше, и он
игнорк сразу же.
Я думаю, что он, как правило, 003, по-моему, больше, и он
игнорк сразу же.
Я думаю, что он, как правило, 003, по-моему, больше, и он
игнорк сразу же.
Я думаю, что он, как правило, 003, по-моему, больше, и он
игнорк сразу же.
Нет, игнори там быстро можно проверять.
Так.
Итак.
Значит, внимание.
Эк, внимание.
Внимание.
Значит, потенциал, значит, навесили.
Так.
Значит, цель.
Значит, цель асимптотика от логарифма двоичного
w минус логарифма двоичного ср.
Так.
Ну ладно.
Я наврал.
Да.
К сожалению.
Да.
Тут как бы такая маленькая странность.
Статья утверждает, что асимптотика такая.
Но я все-таки вынужден констатировать, что там плюс один.
Нет, ну минус один бы я поверил.
Да, ну.
Нет, вы знаете, там просто…
Но дело в том…
Да, можно и так.
Да.
Давай.
Хорошо.
Хорошо.
Да.
Плюс один.
Нет, это как бы нам…
Нет, кстати, в линкаче на самом деле этот лишний
плюс один даст нам там небольшую техническую работу.
Ну вот.
Потому что как бы в телескопической суббите, да, там в одном месте
логарифмы эти пошлеп-шлепаются, это да, но там плюс один.
Все-таки плюс один.
Сейчас кончится тем, что линкат у нас просто в следующий
раз будет.
Так.
Ну хотя это из цикла, а почему бы и нет?
Да, ну и что, нет, понятно, что для того, чтобы рассказать
линкат, да, придется рассказать ХЛД, рассказать, как ХЛД
делает залог, а не залог квадрат, там и так.
Да.
Да.
Да.
Чего это не имеет?
Оно умеет все, что умеет делать ДО, умеет делать ХЛД-залог.
А потому что его больно писать и типа не осмысленно.
Чего?
Тебе не рассказывали?
Да ладно.
Сейчас, погоди.
Нет, это какой-то бред, потому что о том, как это делать,
я от Филиппа Грибова лично и узнал.
Ну я не знаю.
Нет, я говорю, что такое ХЛД-залог, а как делать
ХЛД-залог, я узнал от Филиппа Грибова.
Нет, там просто, вместо двоичного дерева поиска,
ну просто обычно, просто на каждом пути вы делаете
не ДО-шку, а ну что-то типа ДО-шки, только делите
как бы вершины не пополам, а там более как-то аккуратно,
чтобы, чтобы там, ну увидите, короче.
Ну так, чтобы балансировать, балансировать не количество
обесящий на них под деревья, вот эти.
Вот.
То есть, оказывается, что это тоже как бы, на каждом
конкретном пути это все равно логарифм, правда не
логарифм этого пути, а логарифм глобального N.
Но вот, но в сумме, оказывается, там логарифм, там красиво
слопывается, это мы увидим.
Вот.
Пока же давайте вот с этим покончим, чтобы в следующий
раз не возвращаться к этому.
Итак, для этого я должен все-таки описать, какие
конкретно повороты мы делаем в сплее.
Значит, смотрите.
Ну, на самом деле, да.
В случае номер ноль.
Ну, опять-таки каждый раз мы говорим, у нас есть
вершина, мы хотим загнать ее в корень.
В случае номер ноль, вершина уже корень.
Делать ничего не надо.
Нет, еще три случая есть.
Уже?
Ага, да-да-да.
Да-да-да, как надо.
На бизнес тренингах, так говорят.
Итак, какая у нас цель?
Цель первая, собрать с каждого из вас по 1000 рублей.
И мы уже это сделали.
Давайте поаплодируем.
Вот именно.
Вторая цель, это почесать мое ЧСВ.
Третья цель, и так далее.
Да, третья, провести время в хорошей компании.
Ладно.
Так вот.
Значит, далее.
Случай номер первый.
Не сильно далеко ушедший.
Вершина оказалась ребенком корня.
Да.
То есть, когда вершина В оказалась
просто ребенком рута.
Этот случай мы будем называть
ЗИК.
Нет, это официальная
терминология, ничего не знаю.
Вот. В этом случае
мы тогда загоняем В в корень
просто
с помощью
уже полюбившегося нам малого поворота.
Ага.
Ну, как видите, не убой.
Это первый случай.
Это называется ЗИК-ШАК.
ЗИК-ШАК.
Или там ЗИК-СТЕП.
ЗИК-ФЕЙС.
Ну, в общем, откройте статью.
Я не знаю, почему
тарьяны слей так называют это ЗИК.
Хотя догадываюсь, почему.
Потому что, смотрите,
случай второй.
Не, первый, тот был нулевой.
Вот.
Теперь случай второй.
Значит,
вершина В является не менее,
чем внуком корня.
Это означает, что у нее есть
дедушка.
Но не гарантируется,
что дедушка является корнем.
Но важный,
но здесь вариант такой. Сейчас вот, слушайте внимательно.
Вершина В
висит относительно своего
родителя с той
же стороны, как этот родитель
висит относительно
дедушки.
Да. То есть, как бы, либо
В,
левый ребенок А и А, левый ребенок
В, либо В, правый ребенок А и
А, правый ребенок В.
Это называется
ЗИК-ЗИК-ШАК.
Это называется ЗИК-ЗИК.
Вот здесь вот очень, как бы,
вот единственная ситуация,
когда мы не просто берем
QV и применяем малый поворот.
Мы здесь
делаем вот такую операцию.
Мы здесь просто...
То есть, мы здесь просто жестко
опускаем дедушку до внука.
Ну да.
Нет. Ну...
Нет. Теоретически, в принципе,
это иногда происходит, потому что, знаете, там
когда там есть же
эти стандарты, там шутки типа
как в зависимости
от возраста, там
человек реагирует на Петросяна.
Утверждается, что он почти...
Он, как бы, жутко смеется до 5 лет
и после, там, 90.
А все остальное время он сидит с покерфейсом.
И вот.
А знаете ли вообще, кто такой Петросян?
Ну да, да, да.
Тигран Петросян. Чемпион мира по шахматам.
Да, да, да.
Ну как бы. А что, какой-то Петросян есть?
А, кто там?
А, вот это, Аделия Петросян.
Вот эта фигуристка есть там, это да.
Вот.
Ладно.
Ну ладно, с помощью Петросяна
мы тут, оказывается, дорисовали эту штуку.
Вот.
Ну Петросян, как ему положено, позволит
сделать так, чтобы это было не скучно.
Вот. То есть вот такой поворот мы делаем.
А почему мы нарисовали В в небе?
Не совсем.
Не знаю.
Согласен, нет, согласен, согласен.
Да, спасибо за замечание. Да, это правильно.
Так. И наконец.
Как вы уже догадываетесь,
сейчас будет...
А, ну это знающие люди.
Так по локе, наверное, предполагают, сейчас будет зиг-зиг-зиг.
Но нет.
Будет действительно зиг-заг.
Да.
Если выяснилось, что Вершина В
не такой ребенок,
как ее родитель.
А?
Не, ну как сказать,
не, ну как сказать, если у нее, ну типа, знаете,
если родитель зига, она не зиг,
то тут еще вопрос, что там хорошее.
Да.
Так появилась операция спит в дикартовом дереве.
Вот.
Так. Ну вот.
Что мы делаем здесь?
А вот здесь мы как раз не заморачиваемся.
Просто делаем два малых поворота с Вершиной В
и приводит нас это в итоге
к вот такой простой ситуации.
Опа.
Красота.
Благодарь.
Давай.
Нет, ну не совсем так.
Ну, скажем так,
возможно вам тогда
после этого поворота есть, там вам придется делать
зиг-зиг.
Вот.
Нет, там
нет,
теоретически
не совсем.
Теоретически может быть подлянка.
Подлянка может быть в том, что ты сделал здесь
зиг, а потом выяснилось, что в этом месте
надо зиг-зиг делать.
Если мы знаем, что в случае
зиг-заг, конечно, мы можем сделать просто так.
Верное утверждение такое,
зиг-заг можно реализовать как два зига.
Зиг-зиг тоже можно там реализовать.
Почему это называется зиг-зиг?
Потому что
просто, смотрите, гарантируется,
что просто требуется, чтобы было
именно вот так.
Чтобы не было, чтобы мы тут сделали зиг, а потом неожиданно
побежали зиг-зиг делать, потому что тут дедушек,
прадедушек куда-то в ту же сторону пошел.
Нет.
Но как бы зиг-заг,
произошел зиг-заг. То есть вот поворот,
вот этот вот зиг-заг.
Да, тот отсылка к реально существующему слову зиг-заг.
В русском языке даже такое есть.
Есть даже там,
есть даже фильм зиг-заг удачи.
Сейчас.
Чего?
Никакой.
Так, какой вопрос?
Как кого?
Как это большой поворот?
Ну, да.
Да.
Ну, по большому, да.
Ну, просто сейчас они называются вот так.
Хотя в терминах Вэля, да, это большой поворот
в чистом виде.
Ну, зиг-заг,
ну, конечно, прикольно, да.
Да, господи, есть
этого?
Есть советский фильм зиг-заг удачи,
но есть, есть
фильм, но да, даже дети
называют это. Итак, фильм зиг-заг удачи
называется зиг-заг удачи.
Спасибо, мистер Магди, там еще вот такое есть.
А, то есть ваше поколение уже диснеевские мультики
не застало, да?
Или застали, но это не смешно.
Так, ребят, ладно, юмор
не юмор, но пришло время,
значит, пришло время
достаточно включать мозг.
Да, ну, просто,
то есть, логика, то есть, пока
вершина В не стала корнем, говорим, так,
если вершина В, ребенок, корня,
делаем вот это.
Если она не ребенок,
ну, значит, тогда смотрим на дедушку,
то есть, родителей и дедушку, и в зависимости
от этого конфигурации делаем либо зиг-зиг,
либо зиг-заг. Все.
Что нам нужно показать?
Я хочу показать,
что учетная
нот, что
учетная стоимость вот этой
нот, здесь вот этой вот операции,
потому что, смотрите, давайте,
значит, у нас будут
соответственно всякие такие вот эти веса,
ну, веса у нас не
меняются, но у нас есть
СЗ до
и СЗ
после.
Вот будем говорить, что
у каждого шага
и у каждой вершины есть
как бы СЗ до и СЗ
после, правда?
Понятно, да?
Вот.
Так вот.
Я хочу показать, что
учетная стоимость зига,
учетная, она
от, то есть,
она не превосходит в некотором смысле
три.
Эх, мечта, мечта, мечта, но нет.
Значит,
лог двоичный СЗ
после,
СЗВ после,
минус лог двоичный
СЗВ до
плюс один.
Это я хочу показать
для зига.
Для зигзига
я хочу доказать,
для зигзига
я хочу доказать, что
будет не более чем три
логарифма, тоже опять
СЗ после
минус логарифм двоичный
СЗ до,
но на этот раз
без плюс единички.
И более того,
логарифм двоичный
СЗВ.
То есть, в зигзаге, короче говоря,
я перерисовываю то же самое.
Вот такая у нас будет ставка.
Потому что если мы в это
поверим, то я думаю, отсюда очевидно,
что суммарное,
тогда суммарное учетное время работы
для всех подъемов будет,
но там просто эти логарифмы все похлоп-хлопаются
и останется только,
а, кстати, набрал единичка даже не в скобочке,
а здесь. Ну, не принципиально,
реально очевидно.
И тогда получается, если я это все просуммирую,
то учитывая, что у меня,
понятно, СЗ
после предыдущего шага
то же самое, что до следующего,
поэтому суммарно
получится три лог
СЗВ итог
минус три логарифма
двоичных СЗВ
начала. Ну и плюс один.
Но это практически ровно то,
что нам требуется.
Потому что заметим,
что лог, потому что СЗВ итог,
это как раз суммара, практически,
то есть СЗВ итоговая, это суммарный
вес как раз всех вершин, потому что В
стало коркин.
Вот.
Ну а здесь СЗВ то, что было в начале,
но, на самом деле, да, можно это оценить снизу,
как, собственно, тупо ее вес.
Вот. Вводили, водили.
СЗВ это что? Это сумма весов.
Так что вот такая штука.
Понятно?
То есть таким образом,
если мы докажем
вот эти вот три оценочки,
то мы победили.
Отлично.
Все. Значит, больше ни о чем
не думаем, залазим в процедуру
и начинаем. Так, ну начнем. Давайте
выкинем из головы зиг шаг.
Это означает, давайте
докажем вот эту штуку.
Итак, давайте подумаем,
как поменялся,
ну понятно, все шаги делаются
за хорошее время, да?
За единицу реальную, да?
Значит, да.
Значит, тут учетное время,
то есть, так сказать,
Т учетное зиг, напишу я, да,
равно
один плюс потенциал
после
фи после
минус потенциал
до.
Это я написал просто определение
учетной стоимости, правда?
Это равно.
Но я тут должен был
суммировать по всем вершинам,
но деревья, альфа, бета, гамма,
вот эти все вершины я могу выкинуть.
Почему я могу их выкинуть?
Да, просто потому что там
ничего не меняется.
Поэтому по факту остается
только логарифом
двоичный
значит
СЗ В
до
плюс логарифом
двоичный
СЗ Рут
до
да, потому что я
наврал, так,
потому что я наврал, так,
минус логарифом
двоичный СЗ В
СЗ В
до, минус логарифом
двоичный
СЗ Рут
до
до
да, скажи до, до
скажи после, после
вот это все, да, вот.
Так, ну начнем
с самого приятного
для нас,
что тут для нас самое приятное?
Это, конечно, его величество
но мало кто
знает,
но сумма весов
в поддереве этой вершины
и сумма весов в этой вершине
в этом поддереве одна и та же.
Это поразительно.
Вот.
Это равно.
Значит давайте тут разминаемся
логарифом двоичный СЗ
Рут
после
минус логарифом
двоичный СЗ
В
до.
Время-то еще есть вообще?
За 15 минут уложимся.
Я надеюсь.
Вот.
Так, ну теперь можно оценить сверху,
потому что СЗ Рут
после можно оценить сверху как СЗ
В после.
Что не так?
Ну вот.
СЗ
после
значит В
минус логарифом двоичный
СЗ В до.
Но это
так как эта разность больше
либо равна нуля, то она меньше либо
равно 1 плюс 3 на
лог 2
минус лог 2
честно скажу,
потому что у меня
где-то вот тут возникнет
тройка.
Чисто чтобы
удобно было.
Вот.
Так что
так что
как видим в общем-то
между Рутом
и В хотя бы 1.
Между Рутом и В?
Нет.
Потому что нет
почему?
Тут вес очень маленький, у самого Рута
вес очень маленький.
А тут все большие веса, поэтому не факт.
Да, то есть от весов зависит.
Что?
В данном случае нет.
Вот я честно скажу
одна из самых крутых идей здесь
это как эта единичка убьется в других
шагах.
Но здесь она не бьется.
Поэтому
я тут вынужден писать единиц.
Вот.
Более того, собственно, изучение авторского
доказательства в общем-то не дало мне
возможности сказать, что тут этой единицы нет.
Понятно, что интуитивно хочется сказать,
что наверно единица бьется этими
логарифами, но
тот и прикол, что логарифы могут быть
сильно меньше. Единицы это принципиально.
Вот.
Зигом понятно?
Так.
Ну что ж, тогда я думаю мы просто пойдем
обратно.
Нет.
Но разность логарифом миллион один
и логарифом миллиона
у них там
чем больше вес
эта разность может быть сколь угодно малой.
Так что давайте так все. Зиг убираем.
Я его даже полностью убираю.
Потому что
может понадобится чуть-чуть больше доски.
Вот.
И пришло время попробовать доказать
зиг-зиг.
Нет.
Ну то есть да,
но нет.
Надо будет заметить,
то есть сделать аналогичное,
заметим что.
А знаете что?
А давайте зигзагой
начнем.
Потому что на зигзаге
может быть чуть лучше
более лучше
лучше.
Короче будет хорошо видно.
Нет.
В этой гамма
не, в этой гамма по глубине
как распределились, кстати. Это альфа и дельта остались
на одинаковой глубине.
Но на самом деле
это сейчас не принципиально, потому что глубина сейчас не интересует
от слова никак.
А в этом смысле да.
Но это они как бы глубины тут ни при чем.
Тут важно, что их консервуют.
Так, ну поехали.
Итак,
поехали. Т с крышечкой
зиг-заг.
Да, что такое крышечка?
Ну да, крышечка да.
Знаменитый польский режиссер.
Да, в скобках нет.
Так.
У тебя есть одно видео с неописанной крышечкой.
Ага.
Да, да, да, да.
И так.
Значит оно равно.
Значит один плюс.
Ну как всегда.
Ну давайте уж так начнем. Фи после
минус Фидо.
Не Фиде, а Фидо. Да.
Вот.
Один плюс.
Так.
Лог СЗ.
Значит после А.
Так, вот какие у нас тут вершины. Да.
А, Б и В.
Логично.
Так.
Лог два СЗ.
После
В. Минус.
Лог два СЗ.
В. После.
Минус.
Минус.
Логарифом двоичной СЗ.
А. До.
Минус логарифом двоичной СЗ.
В.
Минус логарифом двоичной СЗ.
В.
До.
Так. Ну что?
Есть подозрение, что-то можно шлеп-шлепнуть.
Как минимум да.
Б и В можно.
После В. До.
Отлично.
Как говорится? Отлично. Мы молодцы.
Мы шлеп-шлепнулись.
Значит шлеп-шлепнулись.
Так.
Ну давайте.
А это следующим заходом.
Плюс логарифом двоичной СЗ.
В.
После.
Значит минус логарифом
двоичной СЗ.
А. До.
Минус логарифом. Это я пока просто переписываю.
Ничего.
Так.
Куда? Спрашивается.
Куда девать единичку?
Вот.
Ну.
На самом деле сейчас я поведаю.
Сейчас я попробую поведать
мистический факт.
Я утверждаю.
Смотрите.
Мало кто знает.
Вот вы возможно еще не знаете.
Что логарифом
это функция выпуклая вверх.
Да.
Формально вы этого еще не знаете.
Вот.
Нет. Дело вот чем.
Ну я скажу так.
Просто это мне дает подозрение такое.
Если я хочу сложить логарифом Икса
логарифом Икса
и взять их среднее арифметическое.
То оно окажется меньше, чем логарифом
среднего арифметического Икса Икса.
То есть логарифом
значит Икс плюс логарифом Икс
пополам.
Он окажется просто меньше
либо равен, чем логарифом двоичной
Икс плюс Икс пополам.
А вот вы спрашивали откуда берется
как схлопнуть единичку.
А вот и возникает такая идея.
Вот.
То есть как хлопнуть единичку.
Вот.
Смотрите.
Теперь я просто
хлопну.
Хлопну ее вот каким
вот. То есть я теперь могу просто
заметить, что это теперь
меньше либо равно. Получается один
плюс. Так. Ну тут правда видите
тут как двоечка.
Поэтому тут надо...
То есть поэтому я могу написать так.
Два логарифма
двоичных.
Значит СЗА
после.
Плюс СЗБ
после.
И минус
два. Ой, далее.
Вот.
Могу я такое заявить.
И минус
логарифма
двоичных СЗА
до.
Минус логарифм двоичный
СЗВ
до.
А теперь самое... А теперь почему
я взял... Ну вот почему это вот хорошо взять.
Потому что, смотрите.
Просмотрим на А и В после.
Заметим, что не просто...
То есть заметим теперь следующее.
Что их СЗшка даже в объединении
она меньше
чем СЗшка от В.
Поэтому я могу
здесь просто объявить,
что это меньше либо равно.
Чем минус один. Ну давайте
сразу скажем, да.
Плюс
два
логарифма двоичных СЗ
до СЗ
после В.
Минус
минус. А теперь заметим, что...
Ну
а теперь что мы вычитаем?
Мы вычитаем одно СЗВ до
и вычитаем еще что-то, что
заведомо больше, чем СЗВ
до. Потому что А это родитель В.
Видите, да?
Поэтому я
здесь могу с абсолютно
чистой совестью написать
два логарифма СЗВ
до.
То есть это равно...
Ну, короче говоря,
меньше либо равно, чем два
логарифма двоичных
СЗВ
после
минус
логарифм двоичный
СЗВ до.
А я
его меньше либо равно.
И в принципе могу сразу сказать
меньше либо ров три от того же самого.
Да, потому что
этот логарифм заведомо больше, чем вот этот
логарифм.
Потому что тут в поддереве все, а тут не все.
А тут почти все.
Так штурм!
Таким образом
оказывается, что, видите, то есть
оказывается, лишнюю минус единичку
можно убить, если
найти сумму каких-то двух, желательно
не пересекающихся
поддеревьев.
Вот.
Так что, так, ну давайте
так, прежде чем я сотру зигзаг,
есть ли тут какие-то вопросы?
Так.
Надо еще все, все кто хотел
переписали, да?
И теперь, ну и теперь
собственно финалочка. Теперь вот, в общем-то,
самое интересное, потому что вот теперь
да, теперь как бы должен наконец ответиться, откуда мы
тройку взяли, а не двойку.
Вот.
Давайте, значит, зигзагом мы разобрались.
Вот.
Вот, что так наконец-то.
Мы зигзагнились.
Вот.
Итак, поехали.
Итак, финалочка.
Вас приветствует ZIGZIG.
Да, хорошо звучит, конечно.
Да, ну.
Так.
Ну, как говорится.
Ну, в конце концов, да.
Так. Итак, поехали.
Значит, поехали.
Значит, ну, как всегда, давайте.
Ну, я тут не буду фиксировать.
Ну, я тут не буду фиксировать.
Значит, ну, как всегда, давайте.
Ну, я тут не буду финито писать, я просто сразу
напишу. Ложарифом двоичный
значит СЗВ
после.
Плюс ложарифом двоичный
СЗА
после.
Плюс ложарифом двоичный
СЗБ
после.
Минус опять
логарифом двоичный
СЗВ до
минус
логарифом двоичный СЗА
до
минус
СЗБ до.
Так.
Так. Ну, начнем с уже
полюбившегося нам шлеп-шлепа.
Да. В после,
В до. В общем, зачем я стер первую
строчку?
Вот. Можно было не стирать.
Ты можешь еще раз написать, как бы тогда
как бы
увеличить понимаемость.
Так. Ну, что тут у нас?
СЗА
после СЗБ после снова
так посумировать.
Нет, ну просто
проблема в том, что СЗА после плюс СЗБ
после равны непонятно
к чему.
Нет, то давайте так, давайте я пока перепишу.
Значит там просто, да.
Как бы там не самая тривиальная идея, знаете, еще
года, еще года два назад я тупил, если
честно. Так.
Вот.
Ну, на самом деле сейчас
СЗБ после плюс СЗА до
да, и это ровно то, что нам нужно.
Ну, у нас не плюс.
СЗА до и СЗБ после
Да. Совершенно верно.
Да. То есть у нас
идея в том, что оказывается вот это
плюс вот это ее можно оценивать сверху
как СЗВ после.
Но у нас нету
СЗВ до и СЗБ
после. Точнее у нас есть СЗБ
после, но нет СЗВ
до.
Нет, есть у нас минус.
Да.
Но есть действительно такой популярный
в математике метод прибавим и вычтем
называется.
Да. Значит он
мы его сделаем так, я его даже отдельно
лог 2 СЗВ
до.
Плюс лог 2
СЗБ
после.
Плюс
логарифом
2 СЗА
после.
Ну, это я просто вот это переписал, да.
И минус
логарифом, минус 2 на этот раз
логарифом СЗВ
до, минус
логарифом 2 СЗА
до.
Ой, у меня место заканчивается, так.
А, впрочем
ну впрочем ладно, я думаю если мы
летающий маркер.
Так.
Так.
Значит, ну поехали.
Так, ну к чему это
нас приводит? Так, ну
пишем. Это
у нас оказывает нот. То есть это
мы теперь можем поскладывать. Это оказывается
теперь меньше
либо равно. Давайте аккуратненько скажем
один плюс
два
значит
логарифма двоичного
значит
от СЗВ
до, плюс СЗВ
СЗБ
после.
Минус
два.
Вот. Ну и дальше
все это безобразие переписываем.
Чего?
Вот это? Ну да.
Ну да, то есть значит минус
СЗВ
до, минус лог
два СЗА
до. Так.
Ну да, я пишу как идея, хотя как бы могли бы тут
уже это свести к трем СЗВ
до.
Так, ну теперь оцениваем сверху.
Значит, это меньше либо равно,
чем, во-первых, минус один, плюс
два логарифма
двоичных СЗВ
после. В этом
ради этого мы, в общем-то, это слагаемые вводили.
Да.
Плюс
лог два СЗА
после. Ну у нас тут все
это тоже. Значит, пишем
лог два СЗВ
после.
Ну потому что СЗВ
после он по-любому чемпион.
Минус
ну и здесь, в общем-то, все
красиво схлопывается, потому что
тут СЗВ до
и минус тут лог два СЗА
до, но СЗА до оно больше
чем СЗВ до, потому что опять А родитель.
Поэтому тут пишем
с чистой совестью СЗВ
до, и это
пришли бы равно, чем три
логарифма СЗВ
после
минус
логарифм двоичный СЗВ
до.
Все.
В общем, да.
В общем, опять оказалось, что-то не сильно убойно.
Да.
Вот.
Ну я не знаю, может, конечно, на экзамене будет сложности, я не знаю.
Ну-ка,
ну-ка,
у кого-то буду, я не знаю,
потому что, честно скажу, это
вопросом до отел будет вряд ли.
Ну,
ну да.
Нет, но это хор на отел.
Ну, как минимум,
софт хип.
Чего?
Как максимум.
Ну я не знаю, честно скажу, в прошлом году
вопросом на пять был линкат.
Линкат?
Да, но я не знаю, может, мы, конечно, все
можем.
Нет, на отел,
на отел.
Да, вот нет, отел 5 это да.
Нет, ну почему, как сказать.
Нет, отел 5 это нормально, если вы получите
хор 5 и 3 СПС-бонусы.
Нет, ну да.
Ну или я за четверть финал
расщедрюсь там, я не знаю.
Ну, может, вы там решите 15 задач из 12
возможных, там я не знаю.
Не, как бы, если что, я не полил
количество задач, потому что я их не знаю.
Так это да.
Ну,
вот.
Нет,
ну сфоролирую так, ладно.
На всякий случай лучше, как бы так.
Тут надо аккуратно, без комментариев.
Потому что
утверждать, что я
на этот раз не имею никакого отношения к подготовке,
я не могу.
Ну вот, поэтому без комментариев.
Поэтому никаких
подробностей я вам, естественно, не расскажу.
Да, да, ой.
Ну, как вам сказать.
Нет, ну тут
вы знаете, ну как сказать.
Нет, ну как сказать, я не знаю там,
конечно.
Ну, я не могу никак
комментировать, собираются ли тут добавить линкат или нет.
Естественно.
Нет, в принципе, конечно, да.
Я помню на самом деле как-то раз, потому что
каждый раз, обычно мы там с тренерами сидим
где-нибудь и что-нибудь обсуждаем.
И в принципе, да, на самом деле у какой-то тренера
из какой-то неизвестного вуза на самом деле
возник вопрос, так, погодите, стоп, чего?
То есть вы тренера
в своих вузах, да.
И вы, значит, в жюри Олимпиады.
Чего? Ну вот.
Ну, можно им подсказать, а как? Ну мы же им не рассказываем задачи.
А, ну вы же можете как будто случайно пройти
нужную тему.
Ну вот, думаю, ну да.
Но правда, гарантировать
можно только одной, в принципе, на видео это будет
подтверждено. На самом деле, что
обычно там порядок тем обычно принципиально
не меняется, во-первых, это раз.
В-третьих, пока еще, по крайней мере, ни разу не было,
что я тут неожиданно переставил тему, и тут
бабах, это кому-то помогло.
Ну вот.
Да, я рассказал софт.
Да, я рассказал.
Не, а как-то вам могло, потому что на софт-хип я знаю
только одну задачу на софт-хип.
Нет, я давал как-то на руку
от задачи на софт-хип.
Нет, там
сейчас.
Нет, там просто
задача на самом деле не на софт-хип, а на
там...
Сейчас.
Нет.
Там была, знаете, какая задача?
Значит, взяли числа от 1 до n
в кучу там с параметром
каким-то епсилон, по-моему.
Значит, пихнули нот.
И попытались им устроить софт-хип-сорт.
Внимание, вопрос.
По-моему, сколько
согласно оглашенному инварианту
различных массивов мог выдать
софт-хип?
И то инвариант задачи отлично.
Естественно, сам софт-хип писать не надо было.
Хотя это хорошая версия.
Много-много раз генерим, сколько различных
массивов сгенерилось, столько и выводим.
Ну вот.
Так что вот такая разница.
Вот.
Так что в этом смысле так.
Ладно.
Так, ну ладно, если тут нет вопросов,
то, видимо, по хронометражу явно на сегодня
все.
Так что ответственно.
