Тема сегодняшнего занятия это межпроцессное взаимодействие, а именно удаленный вызов процедур.
Вы уже изучили много всего хорошего и интересного, то как все устроено, уровни.
И в частности была такая замечательная штука под названием сокеты.
Итак, сокеты. Напомню, что это такое. Это некоторые файловые дискрипторы, которые вы можете одновременно и читать, и писать.
То есть они двусторонние. И в отличие от всяких других примитивов, таких как каналы, еще что-нибудь.
Особенность сокетов в том, что это механизм межпроцессного взаимодействия, где явным образом выделяется некоторый сервер.
То есть процесс, который анонсирует себя по какому-то имени, и отдельно выделяется клиент.
Соответственно, возможность взаимодействия либо через некоторые локальные файлы, которые имеют специальный тип, либо по сети.
То есть именем является пара значений имя хаста, либо IP-адрес, плюс номер порта.
И такой механизм очень удобно использовать в качестве механизма межпроцессного взаимодействия, хотя здесь не решаются некоторые проблемы.
Например, как можно найти какой-то другой процесс. То есть нужно иметь очень строгую договоренность о том, как называются какие-то локальные файлы в UNIX-системе.
Либо иметь строго определенное назначение каких-то портов на определенном хасте.
И для межпроцессного взаимодействия удобно иметь некоторую общую шину, куда сваливаются все имена подключенных сервисов, и точно также к этим сервисам подключаться.
Одним из таких механизмов является сервис под названием DBAS, который является стандартом для open-source UNIX-систем.
Но на самом деле не только open-source. В Mac тоже есть система DBAS, которая ставится через бью.
Что это такое? Это механизм межпроцессного взаимодействия, который ориентирован на обмен сообщений.
И может быть использован для того, чтобы организовать межпроцессные взаимодействия и удаленный вызов в процеду.
Что под называется высокоуровневое взаимодействие? Это означает, что вы регистрируете какие-то сервисы.
У этих сервисов есть какие-то осмысленные имена, и эти сервисы реализуют определенные интерфейсы.
Что означает определенные интерфейсы? Это значит, что строго гарантируется какая-то сигнатура методов и возвращаемое значение.
Причем сервисы работают осинхронным образом. С сервисами могут быть произвольные приложения, которые делают еще что-нибудь,
помимо своей основной деятельности, того что они являются DBAS-сервисами.
И просто они периодически получают какие-то события, и можно программным образом управлять.
Существует два двумя шины для DBAS. Посмотрим, как это делается под Linux. Как посмотреть список всех процессов?
Кто помнит название команды? Посмотреть список всех процессов.
PS3 – это один из вариантов. Вариант PS.
И есть еще, если у вас есть какие-то системные сервисы. Другая удобная команда – это SystemD. Что-нибудь видно на экране, шифт не мелкий.
SystemD через Defiz CG-LS. Что-то очень похожее на PS3, но дополнительно еще отображается, какие процессы относятся к каким системным сервисам,
которые в свою очередь объединяются в некоторые группы, скопы. Все это делится на слайсы.
Что такое контрольные группы? Помните Cgroups? Конец прошлого семестра. Управление ресурсами. Если не помните, посмотрите лекции прошлого семестра.
Дополнительная группировка по группам. Можно найти в запущенной системе с графическим интерфейсом. Я не зря сегодня запустил, хотя обычно это не делаю, полноценное десктопное окружение.
Можно найти минимум два экземпляра сервиса D-Bus. Один находится в User Service, запущен из-под обычного пользователя. Называется D-Bus Demon. Это так называемая сессионная шина.
И еще один экземпляр, который запущен через SystemD с правами Root. Где-то тут можно найти еще один D-Bus Service, который является системной шиной.
Для чего это все нужно и как это можно использовать на практике? В чем заключается общая идея межпроцессного взаимодействия через D-Bus? У вас есть одна или несколько шин. У вас есть определенное количество сервисов, которые могут реализовать определенные интерфейсы и какое-то количество клиентов.
Когда вы запускаете процесс, который является сервисом? Он подключается к одной из шин, регистрирует свое название, свои интерфейсы, свою инвентарию методов поддерживаемых.
И в качестве побочного эффекта может выполнять определенные действия, свои основные значения, и при этом дополнительно прослушивает все входящие события, которые возникают на этой шине, адресованные определенному сервису.
При этом сами сервисы не являются серверами. Они не прослушивают никакие порты, никакие сокеты. Они сами являются клиентами с точки зрения UNIX-системы. Как это реализуется на высоком уровне?
Название D-Bas это сокращение от Desktop-Bas. Основное назначение это все-таки десктопные системы. Если вы запускаете какое-то графическое приложение, то оно подключается как минимум еще к одному сокету.
Это сокет X-сервера, откуда приложение читает события вот с клавиатуры, события окон системы, то есть там resize окон и так далее. И сами по себе отправляют в эти сокеты запросы на адресовку чего-либо.
И организуется некоторая единая очередь обработки событий, которая в том числе прослушивает сокет, связанный с D-Bas, и может выполнять какие-то определенные действия. На низком уровне это может быть реализовано с помощью библиотеки X, но на практике ни того не делает. Обычно используют более высокого уровня библиотеки, либо QT, либо GTK, совместно с библиотекой Gallip.
Итак, пример межпроцессного взаимодействия, который взят из библиотеки QT.
Некоторый пример, который написан не мной, а найден совместно в библиотеке, это вот такая машинка. Машинка – это отдельное приложение, отдельный процесс, что оно умеет делать.
Оно умеет ускоряться, затормаживать, ехать в обратную сторону, поворачивать налево, поворачивать направо. Это один процесс.
Отдельно можно запустить еще один процесс, который реализует контрольную панель с кнопочками. Это отдельное приложение. Обратите внимание, что я запустил два этих программы, не указывая никаких параметров подключения.
Поехала. Никакого практического смысла в этой программе нет. Это просто стандартный экзампл из поставки библиотеки QT.
Более интересно посмотреть на реализацию всего этого безобразия.
Реализация. На самом деле тут не обязательно знать все подробности, как это устроено на низком уровне.
Самое интересное здесь в том, что реализация заключается в вызове всего лишь трех вещей.
После того, как создана машинка, нужно открыть системную шину, зарегистрировать некоторый объект и зарегистрировать сервис. Все остальное делается в графической библиотеке.
Что здесь регистрируется? Нас регистрируется некоторый сервис, в котором может быть несколько объектов.
В данном случае он называется объект slashcar, хотя любое приложение может создавать много разных экзампляров с разными именами.
Как теперь можно управлять этой машинкой, не пользуясь кнопочками? Машинка у меня есть, она осталась в каком-то состоянии.
Машинка это просто модель какой-то реальной программы, с которой вы можете взаимодействовать.
У каждой машинки может быть свое имя, если вы запускаете с одним фиксированным именем, но просто у вас не получится этот объект зарегистрировать.
Теперь я запущу вот такую штуку и сделаю управлять этой машинкой каким-то программным образом, как будто мы управляем реальным приложением.
Для этого можно использовать модуль D-Bus.
Импортируем сессионную шину, подключаемся к шине. Что такое шина? Это как раз один экземпляр, который запущен вместе с сеансом рабочего стола.
Затем, зная название сервиса и конкретного экземпляра, мы можем найти какой-то объект по его имени.
Вот название сервиса и конкретный экземпляр. В данном случае он всего один, хотя может быть несколько.
Это некоторая машинка, какой-то объект, который в свою очередь реализует некоторые методы.
Можно получить полный список любого D-Bus интерфейса в виде XML строки. Как же ужасно все-таки пользоваться нестандартными экранами.
Это обычная XML. У машинки есть некоторые экспортированные методы. Могут быть разные интерфейсы. В частности, Accelerate, Dexlerate, Left, Turn Right.
Давайте теперь вызовем.
Для этого у каждой машинки должно быть свое уникальное имя. Есть некоторый сервис, который называется OrgExampleCarExample.
Этот сервис может регистрировать несколько разных имен. Точно так же, как разные объекты в URL кодируются в браузере.
Разные имена соответствуют разным экземплярам. В ней могут иметь какие-то числовые параметры и так далее.
В частности, это используется, например, порядковыми номерами сетевых интерфейсов Network Manager.
Возвращаясь к машинке, мы заставили машинку двигаться в обратную сторону. При этом никто не мешает запустить контроллер, который тоже будет отправлять какие-то команды.
В данном случае у нас есть один процесс, к нему могут подключаться другие процессы и как-то им управлять.
Какой в этом практически смысл? Машинка это всего лишь модель. В реальной жизни, естественно, вы будете пользоваться чем-то другим взаимодействием не с какими-то машинками.
Здесь выделяются разные уровни. Во-первых, это то, чем может управлять обычный пользователь, не обладая правами администратора.
Любовь взаимодействия с рабочим столом. Какое может вам потребоваться взаимодействие? Например, вывести какой-нибудь notification в иконке.
Может быть взаимодействие с иконной системой, если у вас окружение рабочего стола это позволяет заставить какое-то окошко показаться на самом верху, либо наоборот, скрыться.
Какие-то общие парольные менеджеры или, возможно, доступ к контактным данным. В линуксе это, конечно, не очень распространено.
Есть две независимые системы. Одна называется Evolution Server, другая Канадия. Одна из них это в составе GNOME, другая в составе KDE, которые позволяют обращаться к вашим почтовым ящикам, контактам, календарям.
Почему в линукс дектопных это не очень распространено? Потому что изначально технологии они были в первую очередь не оритированы на мобильные устройства еще до Android.
Ну и кроме того, с чем может взаимодействовать пользователь с сессионной шиной, есть еще и системная шина.
И можно дергать разные события и обращаться к сервисам, например, для того, чтобы узнать состояние батареи, насколько она у вас заряжена, для чего это может понадобиться на практике.
Например, приложение Adject Brains. У них есть Power Safe Mode, когда отключаются всякоиндексации. Как может приложение понять, что нужно принудительно переключиться в Power Safe Mode?
Кстати, у Яндекс браузера тоже есть. Можно просто обратиться через dbus к системной службе мониторинга батареи и запросить, сколько у нас осталось времени на работу, либо оценить самостоятельно и принять какое-то решение.
Ну и кроме того, управление сетью. Что делает вот эта кнопочка сетью? У меня вай-фай настоящих нет, поскольку это виртуальная машина.
На самом деле, вот этот апплет – это просто маленькое графическое приложение, которое взаимодействует через интерфейс dbus с системным менеджером управления сетью.
То же самое управление звуком, подключение новых устройств. Некоторые такие действия могут потребовать уже права администратора.
Так, ну практически пример, когда это может быть полезно. Шина у меня уже подключена. Есть разные сторонние приложения, которые позволяют... Так, все, машинка мне не интересна, я ее закрываю, потому что мы сейчас другим развлекаться будем.
Так, есть разные инструменты, которые позволяют исследовать, что у вас вообще есть в шине dbus. Это либо qdbus-viewer для среды KDE, либо в гноме есть еще инструмент по названиям dfeed.
Вот так пишется d-feed. Делает примерно то же самое.
В плане поразвлекаться, самый наглядный пример – это Notification Area, которая доступна по сервису org-free-desktop-notifications.
Так, сервис называется org-free-desktop-notifications. Вот у меня уже открыт спитон. Шина у меня уже есть, пересоздавать ее нет никакого смысла.
Давайте подключимся к desktop.notifications.
И там есть объект, который существует ровно в одном экземпляре. Как правило, в опенсорсных средах для объектов, которые существуют ровно в одном экземпляре, название экземпляра примерно совпадает с названием самого сервиса.
Так, есть какой-то сервис. Давайте посмотрим, какие есть у сервиса возможности.
И кто этот сервис вообще реализует. У нас есть некоторые стандартные интерфейсы. В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализации
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Первый параметр называется Notify.
Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
Иконка, которая будет отображена.
ЦСД Color. Красивая иконка.
ЦСД Color.
ЦСД Color.
ЦСД Color.
Самый короткий текст.
Самый короткий текст.
Что там еще по интерфейсу нужно?
Что там еще по интерфейсу нужно?
Массив строк. Какие-то действия.
медка.
медка.
медка.
Медка.
Медка.
Медка, over pretty software,
Медка, over pretty software,
Медка.
Медка, over pretty software,
Медка, over pretty software,
Медка, over pretty software,
Медка, over pretty software,
Теперь про системные шины. Что можно вытворять?
Яркость экрана, кстати, да, можно, если у вас система поддерживает настройку яркости экрана.
Они плохо портируются, поэтому в основном это сделано под...
На самом деле, в чем смысл этой штуки?
Если, например, у вас есть система не Linux, а FreeBSD или OpenBSD, то есть не на базе ядра Linux,
у вас может быть реализовано какое-то другое взаимодействие с железом.
Но при этом вы хотите использовать возможности тех же рабочих столов, что и Linux, те же KDE, те же GNOME.
То есть вам нужно написать под FreeBSD сервис, который будет реализовывать тот же самый интерфейс.
Этот сервис, соответственно, запускается и точно так же прослушивает события.
И с точки зрения рабочего стола нет никакого различия, на какой системе вы работаете.
XOR и Wayland да, но они отвечают только за взаимодействие с клавиатурой, мышью и экраном. Все.
Все остальное это уже за пределами возможности XOR и Wayland.
Так, ну вот, например, системный сервис, org-free-desktop-accounts.
Для того, чтобы к нему подключиться мне уже нужна другая шина.
Так, я, наверное, даже не импортировал.
Пайди-бас, импорт, который называется System-Bas.
Пересоздам эту шину.
И найду объект.
Который отвечает, например, за управление аккаунтами пользователей.
Так, org-free-desktop-accounts.
И можно застучаться до определенного аккаунта определенного пользователя,
либо сделать какие-то общесистемные действия.
Например, может попытаться сделать нового пользователя.
Обратите внимание, что я все это запускаю из-под обычного пользователя, не из-под рута.
Так, org-free-desktop-accounts.
Так, вот у нас какой-то есть сервис.
Потому что я просто подключаюсь к какой-то шине, просто нахожу какой-то объект.
Пока нам никто не мешает.
И что я теперь, например, хочу сделать?
Например, я хочу сделать нового пользователя.
Так, что нам нужно для создания нового пользователя?
Для создания нового пользователя мне нужно указать его имя, полное имя и тип аккаунта,
просто болевый флаг, один либо ноль, админ либо не админ.
Так, ну ладно, пусть будет пользователь Вован, которого зовут Вова Пу, например, китаец.
Может быть.
Так, обратите внимание, что пользователя у меня только один сейчас в системе, все честно.
Ну и пусть он не будет с админом.
Понятно, что создание нового пользователя это какая-то операция, которая требует администраторских прав.
Я это запускаю из-под обычного пользователя.
Бабах. Ну теперь у нас откуда-то выскакивает окошко, которое требует вести пароль администратора.
Кто создает это окошко?
Тот сервис, который запущен с правами рута и отвечает за управление аккаунтом.
То есть это на самом деле не тот самый процесс, в котором запущен питом из-под обычного пользователя.
Ну теперь я могу вести пароль, если он честный, то, видимо, будет создан какой-то аккаунт,
действительно появился новый каталог пользователя.
У него есть некоторый новый user ID, то есть прямо честная операция в создании нового пользователя.
То же самое можно сделать и с удалением поиска.
Так, ну это все, что относится к сервису под названием debas, который ориентирует в первую очередь на десктопное применение.
На самом деле все, что здесь я вам показал, это может быть исполнено не только на десктопах, но и на серверах,
которые без графического интерфейса. Все, что здесь нужно сделать, это просто реализовать подключение к шине
и прослушивать периодически какие-то события, на них реагируют.
При этом все сервисы debas, поскольку они исходно ориентированы на локальное применение,
работают поверх локальных Unix Sockets. Штуковые локальные Unix Sockets, помните?
Это файлы специального типа, которые адрес вами Unix.
Кстати, что еще отличает их от обычных файлов? Максимальная длина пути.
То есть для обычных файлов это 4096 байт, для Unix Sockets это всего лишь 108 байт.
Так, ну и главный недостаток локальных Unix Sockets, то, что недоступлено вам только локально.
При этом на самом деле вы можете файловые системы монтировать дистанционно,
используя SSHFS, Network File System и так далее.
Но локальные Unix Sockets, даже будучи подмонтированными удаленно,
удаленные файловые системы все равно не доступны для взаимодействия.
Поэтому здесь, если вы хотите использовать удаленный вызов-процедур,
с какими-то параметрами получать результаты от соседнего компьютера,
либо какой-то произвольного компьютера, локальные Sockets вам не подойдут.
Нужно использовать Address Family Internet, либо Address Family Internet 6.
Так, ну и на самом деле идея не новая. Существовала еще в 90-е годы, существует до сих пор.
Общая идея. У нас есть какой-то интерфейс, есть класс, который реализует этот интерфейс,
класс-клиент и класс, который реализует тот же самый интерфейс, класс-сервер.
Как это выглядит в реальной жизни? Сейчас будет много всякого кода.
На самом деле, вникать во все подробности кода, запоминать что-то не особо обязательно,
потому что я это все выложу на GitHub. Весь код, конечно, на экране показать невозможно.
Итак, есть некоторый интерфейс. Не пугайтесь, что я вам показываю
какой-то мало знакомый язык программирования Java, он похож на C++.
На самом деле, сегодня я буду показывать на разных языках программирование код,
который вполне себе читабельный. Что означает слово Public Interface?
Это означает, переводя на язык C++, просто полностью абстрактный класс,
который подразумевает, что должен быть реализован
некоторый метод, под названием GetMessage, который возвращает строку.
Этот интерфейс реализован каким-то конкретным классом,
который можно запустить в отдельном процессе.
И есть еще один процесс, который хочет использовать данный интерфейс,
но при этом подключиться к какому-то сервису.
Сервис, в свою очередь, работает на обычном IP-порту,
по умолчанию порт 1.0.99 можно задать какое-то имя сервиса,
потом в клиенте это имя сервиса найти, для того чтобы потом
вызвать какой-то произвольный метод, получить его результат.
Запустили отдельно сервер, отдельно запускаем клиент,
который запускается, получается строчку Hello.
Что у нас при этом происходит в сети?
Для этого у нас есть Wireshark, ознакомим вам уже.
Давайте посмотрим, что у нас тут будет происходить.
Подключаемся к Localhost.
Стандартный порт данном случае это 1.0.99.
Запускаем клиента еще раз.
Смотрим, что у нас тут поймалось.
Поймалось много всего интересного.
В частности, где-то у нас тут есть, среди TCP безобразия,
запрос на Java RMI, вот у нас ReturnData,
и здесь что-то связанное с сервизацией Java,
определенной версии в незашифрованном виде.
Можно перехватить трафик и узнать, кто у кого что вызывает.
И это является одним из главных недостатков
Java Remote Invocation.
Поэтому в реальной жизни сейчас им никто не пользуется.
Но сама идея достаточно красивая.
Когда вы один и тот же интерфейс реализуете и на сервере,
и подразумеваете, используя на клиенте,
и объект у вас создается, просто подключившись к какой-то шине.
Главный недостаток все-таки помимо того, что отсутствует шифрование.
Шифрование – это ладно. Вы можете сделать отдельную подсеть
только для доверенных серверов,
разбить огромный сервис на микросервисы в локальной защищенной сети.
Это еще полбеды. Другое важное ограничение – это Java.
Чем плоха Java?
На самом деле хороший язык программирования.
Но, кроме Java, существует много других языков программирования.
Да, имею в виду семейства языков Java.
Это Kotlin, Java, Scala.
Но все, это то, чем ограничено использование этого способа.
Поэтому не очень хорошо и распространение не получил.
Чуть более универсальным, но уже историческим способом
является использование формата XML и обычного HTTP-сервера.
В чем заключается этот подход?
Вы понимаете обычный Web-сервер.
В чем преимущество Web-сервера?
Вы можете его запустить на любом произвольном порту.
Он легко проксируется чем угодно.
Есть средства для безопасности в виде отдельного слоя Secure Second Player.
И отправлять туда запросы в формате XML.
Что такое язык XML? Я думаю, пояснять не нужно.
HTML вы все знаете.
XML – это более строгая форма того, что вы привыкли назвать HTML.
Отправляете какие-то структурированные запросы,
которые содержат аргументы вызываемых методов и получаете ответ.
Этот способ был популярен в конце 90-х, начале нулевых.
Сейчас не используется по одной простой причине.
Формат XML очень многословный.
Получается очень дикий безумный оверхед.
Сейчас в основном используется другой подход под названием REST.
Тоже поверх протокола HTTP.
Но используя различные команды этого протокола.
Команды GET и POST вы уже смотрели на семинарах.
Даже задачки делали. Как, кстати, успешно?
Даже успешно.
Да, там все сейчас работает.
Кроме команд GET и POST,
команды могут быть совершенно произвольные текстовыми.
Этому будут любые литералы.
Есть часть команд, определенные разными стандартами.
Например, команды PUT, DELETE, HEAD.
Но в общем случае, поскольку протокол является текстовым,
вы можете задавать произвольные команды вплоть до названия методов.
Хотя на самом деле название методов в REST обычно кодируется как часть пути.
В том числе не только методы, но и какие-то конкретные объекты.
В заголовках можно указывать в запросе в заголовках accept,
что вы готовы данные какого формата получать.
Сервер в свою очередь может по своему усмотрению
либо реализовывать достаточно широкий спектр форматов.
Это может быть либо JSON, либо XML, либо plain text, либо бинарные данные.
Как правило используется только JSON, хотя некоторые веб-фреймворки,
например, есть такой N2O, который на Ирланге сделан,
позволяет легко делать поддержку произвольных типов данных.
И где это используется на практике?
Возьмите хотя бы Яндекс.Погоду.
Слово Яндекс.Погода вам, наверное, известно.
Кроме Яндекс.Погоды есть еще другие сервисы,
и с погодой связанные, и с финансами,
которые предоставляют открытые программные интерфейсы.
Открытые в том плане, что пользуется им может практически кто угодно,
но для этого нужно получить некоторый ключ.
Поэтому сейчас я вам показывать не буду,
как это на практике делается.
Просто пример из документации.
Отправляйте некоторые запросы.
Параметры запроса могут быть сформированы
либо как аргументы GAT-запроса,
либо являются частью заголовков.
И получаете ответ в формате JSON,
который дальше можете использовать.
Вот такой простой удаленный вызов
какого-то API на стороннем сервере.
Преимущество такого подхода в том,
что сам по себе протокол HTTP он очень простой.
Он понимается любыми браузерами,
поэтому можно сделать это не только в приложении,
но и в стране JavaScript.
Из недостатков здесь JSON по сравнению с XML
все-таки более компактный формат.
В то же время JSON это человекочитабельный формат.
Он хорош для человека.
Вы смотрите на вывод, вам все понятно как-то распарсить,
но на парсинг все-таки требуется время, требуются ресурсы.
Если у вас сервис не очень сильно нагружен,
то ничего страшного в этом нет.
Если у вас сервис имеет большое количество одновременных подключений,
большое количество пользователей,
то парсинг JSON уже может занимать значительное время.
Не только парсинг, но еще и генерация.
Вообще говоря, многие программисты и бэкэнд-разработчики,
знаете чем занимаются в реальной жизни?
Они не решают прикладные задачи.
Очень значительную часть времени они занимаются тем, что перекладывают JSON.
Аналитики частят данные от мусора,
программисты и бэкэнд-разработчики перекладывают JSON.
Программа JSON в том, что он не совсем однозначный.
Как можно договориться о том, что данные у вас имеют определенный формат?
Только прописать это в документации.
Эту документацию нужно строго следовать.
И это не только к формату данных,
но и к тому, какие из команд запросов за что отвечают.
Нет строгого определения, что является пост-запросом, что является пут-запросом.
Как договоритесь, так и будет.
Никакой четкой договоренности, никаких четких интерфейсов.
Это по сути не обозначенная грамотика.
Это является главным недостатком рест-интерфейса,
то, что вам приходится курить документацию на каждый сервис.
Более современным решением, хотя тоже не самым идеальным,
является использование штуки Google Remote Processor Calls.
Это специальный механизм для того, чтобы обеспечить межпроцессное взаимодействие,
в том числе между разными узлами сети,
в том числе с использованием самых разных языков программирования.
И при этом, во-первых, гарантировать строгое соблюдение интерфейсов, которые четко описаны,
соблюдение которых контролируется компилятором.
Ну и основан этот протокол на базе протокола HTTP-2 версии.
Про HTTP-2 версии я чуть позже скажу, что он из себя представляет.
Он представляет из себя описание каких-то структур в определенном формате,
универсальном по отношению ко всем остальным языкам программирования,
и описанию каких-то методов определенных сервисов.
Что могут из себя представлять методы?
Методы могут быть какие-то обычные функции, которые вы передаете аргументу и получаете результат.
Это будут методы, которым вы передаете какие-то аргументы и получаете непрерывный поток данных,
который может обрабатываться последовательно, в том числе по мере генерации.
Совершенно не обязательно они сразу завершаться, они могут работать по несколько минут.
И клиенты могут получать данные частями, ну и плюс то же самое возможно еще и в обе стороны,
когда клиенты постепенно отправляют какие-то данные, ну и получают данные тоже по мере готовности.
Что представляет собой протокол JRPC?
Ключевой момент здесь это файл описания, который называется протокол буфер,
в котором описываются различные структуры под названием сообщения.
Сообщение это как раз тот кусок данных, который является атомарным с точки зрения какого-то вызова.
То есть у вас любой аргумент должен быть объявлен как какое-то сообщение,
вы можете дальше возвращать либо сообщение, либо поток этих сообщений.
В сообщениях могут быть самые обычные скалярные типы, которые есть во всех языках программирования.
Это разные инты, знаковые, безнаковые с разрядностью, фолтингпоинт, фиксированные точки, строки, булевые объекты и так далее.
Как можно организовать структуры?
Точно так же как и в обычных все подобных языках программирования,
у вас одни сообщения могут включать в качестве типов данных, а другие сообщения, то есть запускается вложенность.
Такую штуку на самом деле можно преобразовать по стандартным алгоритмам формат JSON, если вдруг это вам понадобится.
А теперь достаточно большой кусок демонстрашек всяких разных кодов.
На самом деле это было бы очень долго, нам бы пары не хватило.
Разберем на примере какой-нибудь практической задачи.
Например, вы хотите сделать свою соцсеть.
Фейсбук, она же морда книга, это запрещенная организация экстремистская.
Надо сдерживать свое православное.
Что такое социальная сеть?
На самом деле это совокупность каких-то отдельных сервисов, их еще называют микросервисы.
Разные части могут располагаться на разных серверах, могут быть реализованы на разных языках программирования.
Итак, давайте рассмотрим создание с нуля социальной сети, которая что умеет делать.
Во-первых, она умеет выдавать по пользователю какой-то профиль, фамилия, имя, возраст, рост, пол, телефоны и так далее.
Что означает описание?
Синтакс равняется Proto 3, некоторая магическая строчка, по аналогии как в CMake листе, CMake minimum required.
Proto 3 означает третью версию протокола протобуфер, которая уже много лет как-то не менялась.
Фактически это уже стабильный интерфейс для описания.
Каждая структура называется message.
Как и в обычных структурах у нас есть поля определенного типа данных.
Название очень похоже на то, что вы встречали в языке C, либо в языке C++, либо еще где-нибудь в стримке Win64.
Понятно, что такое? Если написать подчеркивание T, получаете название стандартного типа в языках C и C++.
Есть янамы.
Важным отличием от структур и классов в обычных языках программирования является то, что обязательно после имени поля является еще какое-то число.
Для чего это нужно?
Представьте себе, что вы реализовали какой-то сервер, реализовали каких-то клиентов,
и потом вам нужно внести какие-то изменения в структуру взаимодействия.
Например, вы хотите добавить новые поля, убрать какие-то уже ненужные вам.
Для того, чтобы не поломать совместимость уже с существующими клиентами, вы можете договориться, что когда вы добавляете новую функциональность в определенной версии,
вы используете номера с определенного диапазона, они не обязательно должны идти последовательно.
Просто они фиксируют, что данное поле имеет такое-то имя, такое-то тип.
Некоторые поля могут быть опциональными, то есть их указание не обязательно должно иметь дефолтное значение.
На что еще обратить внимание?
Поля могут повторяться, то есть быть реализованными либо как списки для тех языков, где у вас есть тип-лист,
либо если это язык C++, они могут транслироваться в обычный вектор,
когда вы получаете сообщение, количество элементов в нем уже известно и фиксировано.
Кроме типов структур, а не же месседж, вы можете объявить какой-то сервис.
Да, сервисов может быть тоже несколько, не обязательно одни.
По сути, сервис – это некоторый интерфейс, который потом превращается в класс.
В каждом классе могут быть свои методы, которые принимают аргументы и возвращают какие-то значения.
Что с этим файлом потом можем сделать?
Затем этот файл нужно превратить во что-то осмысленное и желательно сделать это автоматическим образом.
Симейк-листs, add custom command, add custom target, помните такой из технологий программирования?
Кодогенерацию.
Что дальше можно сделать с этим портофайлом?
Портофайл – это некоторый прототип для вашего кода.
Из него дальше можно сгенерировать обычный исходный код на каких-то языках программирования,
причем этих языков программирования может быть много.
Команда входит в поставку многих Linux-дистрибутивов, называется protoseed,
которая обрабатывает эти самые портофайлы и генерирует по ним исходные тексты.
Проблема в том, что protoseed является компилятором только фронтендом этого самого языка протоописания.
И не в каждом дистрибутиве, тем более не в каждом макии в Homebrew, есть кодогенераторы.
Кодогенераторы, как правило, ставятся отдельно.
Они могут входить в поставку дистрибутивов, либо могут не входить.
Под каждый язык программирования может быть свой кодогенератор, который называется plugin.
Вот их надо отдельно прописывать, если вы используете что-то нестандартное.
Здесь у меня реализована поддержка четырех языков программирования.
Это C++, Python, Dart и GoLang.
Последним аргументом является сам протофайл.
Собираем, что мы получаем.
У нас генерируется куча всяких файлов.
В частности, вот такие страшные файлы.
Огромные.
Которые являются временными, их лучше не редактировать, они все равно будут перегенированы.
Я надеюсь, вам в технологиях программирования рассказывали, что в системе контроля версий
такие файлы нужно прописывать gitignore, чтобы они ни в коем случае не попадали.
Они являются выводимыми из какого-то другого файла.
Возвращаемся к нашим баранам. Зачем все это нужно?
У нас есть некоторый класс, сервис, интерфейс, под названием ProfileManager.
Который нужно реализовать.
Реализуется следующим образом, что у нас есть некоторый сгенерированный
интерфейс, абстрактный класс, который можно унаследовать
и написать уже точную реализацию метода, например, по названию GetUserProfi.
То есть, как реализуется что-то на gRPC. Вы сделали какой-то протофайл,
сгенерировали дальше абстрактные классы, их наследуете и выполняете их реализация.
Тем самым вы реализуете функциональность ваших серверов.
Переопределяем нужный вам метод. Метод достаточно простой.
Это не реальный код, это просто демонстрация.
Поэтому за хардкоженые два имени, по которым нужно выдать какую-то информацию.
Типа данных самые простые, соответствующие определенному языку программирования.
То есть, если у нас язык C++ и поле указано как строковое,
то используется обычный класс std string.
В питоне, соответственно, обычная питонская строка.
То есть, код генерировался так, чтобы быть максимально родным для текущего языка программирования.
Вот реализовали какой-то сервис. Что мы с ним можем сделать?
Мы можем объявить некоторый сервер, который привязан либо ко всем интерфейсам, либо только к Localhost.
К этому серверу на один порт подключить один либо несколько сервисов,
которые реализуют конкретные классы, и запустить очередь на обработку.
Вот вся реализация.
Ладно, это то, что касается реализации сервера.
Теперь насчет клиента.
Клиент давайте для разнообразия пусть будет не на плюсах, а на питоне.
Для этого мы генерируем какой-то код, складываем его в какой-то каталог для питона.
Дальше этот код, который выглядит опять же страшным образом, но нам совершенно не обязательно его смотреть.
Зачем нам это все узнать?
Это все генерируется автоматически. Мы это просто импортируем и используем.
Итак, у нас есть некоторый сервер. Мы знаем имя хоста, мы знаем порт для этого сервера.
Хорошо подключаемся.
Дальше загружаем какой-то интерфейс.
Получение профиля означает, что нам нужно сформировать какое-то сообщение,
передать его в качестве аргумента, получить результат и радоваться жизни.
В этом файле у меня реализованы только функции, поэтому я открою отдельный терминал.
Запущу питон в интерактивном режиме.
Опция "-i", это означает, что нужно выполнить какой-то файл.
После этого не завершать работу, а использовать обычный концов.
Итак, метод получения профиля подразумевает, что нужно указать имя,
который потом сконвертирует нужное сообщение и вызовет то, что нам нужно.
У меня реализованы два товарища. Один называется Ваван, который...
Вот мы получаем строку.
First name, last name. Соответственно, здесь просто Shell нам экранирует русские буквы,
но можно получить... Все хорошо, все замечательно.
Что при этом происходит опять же с точки зрения того, что у нас происходит по сети.
Так, порт был... Порт, порт...
Порт 1.9.0.1. Давайте посмотрим, что там теперь у нас происходит.
9.0.1.
Я отправляю какой-то запрос. Что мы видим в R-шарке?
В R-шарке мы видим какие-то TCP-соединения. В общем, какой-то мусор.
Это про то, что я явно образом отключил шифрование.
Во-первых, чтобы можно было как-то продемонстрировать то, что у нас гоняется по сети.
Во-вторых, чтобы не заморачиваться с подключением сертификатов.
Так, какие-то бинарные данные.
Но на самом деле это протокол TCP-2, который при этом является тоже бинарным.
Так, в R-шарке для этого мы можем сделать некоторую подсказку.
Меню Analyze. Дальше Decode S.
И можно сказать, что все, что у нас попадает на порт 1.9.0.1, нужно трактовать как протокол.
Выбираем из списка того, что поддерживает R-шарк, что он умеет распознавать TCP-2.
Так, окей.
Вывод стал чуть более осмысленным.
Итак, что такое протокол HTTP-2, который у нас тут используется под капотом?
А, ну, сначала gRPC.
Вот полный степ протоколов.
Протокол IPv6 вместо IPv4. Интересно, ну ладно.
По верхнему дальше идет TCP, как транспортный.
Дальше идет следующий уровень HTTP-2,
в котором закодировано какое-то gRPC-сообщение, доступ к профиль-менеджер slash getUserProfile,
получить реквест, который в свою очередь содержит запрос под названием messageUser,
логин Ваван и где-то у нас есть в обратную сторону gRPC.
Ответ.
Откуда вообще R-шарк знает, как нужно парсить вот эти все структуры?
Опять же, R-шарк по молчанию ничего не знает.
Для этого нужно залезть в настройки, дальше выбрать протокол с,
найти здесь protobuf где-то в списке огромном
и в настройках уже этого протобуфа указать каталог, где валяются ваши протофайлы,
чтобы R-шарк искал нужные вам описания.
Вот я это один раз прописал, теперь R-шарк может мне подробно все отображать.
Ну ладно, это не самое на самом деле интересное.
Чуть более интересное это, что именно у нас передается в рамках протокола HTTP-2 на каждый запрос.
В протоколе HTTP-2 у нас перейдются бинарные данные, которые вполне себе осмыслены
и они содержат...
Ладно, покажу отдельную картинку лучше.
В общем, у нас есть jfpc, который кодирует HTTP-2.
Эти данные перейдут через обычный TCP.
Кроме того, что мы можем делать обычные запросы, связанные с передачей аргументов
и получением результатов, мы можем еще делать запросы,
которые отправляют некоторый поток данных.
Опять же, я подробно не буду вдаваться в этот код.
Потом посмотрите на GitHub.
То же самое можно сделать на языке Go, запустить еще один сервис.
Используя тот же самый Python, помимо получения профилей, еще и так.
Открыть одну вкладку, например, и начать получать сообщение.
Часть соцсети это все-таки messenger.
Откроем еще одну вкладку и отправим сообщение
от юзера Ion-пользователю WoWan.
Вот сообщение доставлено.
Более интересное, что такое себя представляет протокол HTTP-2, который мы наблюдали в Airshark.
Это более современная реализация протокола HTTP.
Если первая версия была текстовая, зачем нужна бинарная версия протокола?
Наверное, для того чтобы экономить байтики.
Все-таки плейнтекст не очень оптимален с точки зрения передачи данных.
При этом протокол HTTP-2 может использовать те же самые порты, что и обычный протокол,
то есть 80-ый для незашифрона и 443-ий с использованием SSL.
Как можно переключиться с первого на второй?
Вы делаете запрос в какой-то странице, используя протокол HTTP 1.1, все стандартно,
и прописать заголовок Connection Upgrade и плюс заголовок Upgrade до какого протокола.
Если сервер поддерживает вторую версию HTTP, то он выполнит статус 101 Connection Upgrade
и после этого уже возможно взаимодействие протокола HTTP-2.
Если сервер не поддерживает, он этот заголовок просто проигнорирует, ничего плохого при этом не произойдет.
В чем особенность этого протокола?
Помимо того, что он является бинарным.
Шифрование также как и для первого протокола является опциональным,
хотя во многих серверах EngineX требуется обязательно сертификатики указывать.
Самое главное, что он позволяет двунаправленное взаимодействие,
то есть не просто запрос-ответ, но и взаимодействие в реальном времени,
и при этом позволяет на один запрос отправлять сразу несколько файлов,
используя при этом всего лишь один socket.
Как это работает?
У нас весь поток данных, либо несколько потоков данных,
бьется на некоторые части, которые называются фреймы.
Фрейм – это небольшой кусок данных размером от 16 кб до 16 мб.
В общем случае его размер может варьироваться,
для этого нужно отправлять специальные фреймы на их перенастройку.
Фреймы могут иметь разные типы.
Это могут быть либо фреймы с заголовками, либо фреймы с данными,
либо специальные фреймы типа PING,
для того чтобы проверять, действительно ли соединение у нас есть.
И каждый независимый файл, либо каждый независимый запрос
оформляется в виде последовательности фреймов,
которые имеют некоторые общие уникальные ID этого потока.
В чем главное преимущество с использованием протокола HTTP2?
Если вы не заморачиваетесь со всяким межпроцессным взаимодействием,
просто хотите использовать этот протокол для выдачи веб-страниц.
В среднем получается все быстрее,
потому что вам не нужно последовательно ждать,
когда у вас закончится что-то предыдущее.
У вас все фрагменты разбиваются на какие-то маленькие части
и отправляются по очередной.
При этом возможна приоритизация каких-то отдельных потоков,
каких-то отдельных файлов.
И важной особенностью протокола HTTP2 является то,
что вы можете отправить один запрос, например, получить главную страницу.
Что помимо главной страницы, а что эмолки, у вас может еще загружаться.
Картинки, CSS-файлы, Джаваскрипты.
Как для этого нужно делать в обычном HTTP 1.1?
Вам нужно последовательно отправлять запросы и загружать какие-то файлы.
В случае с HTTP2, если веб-сервер знает,
что с какой-то страницей связано несколько ресурсов,
то сервер может сделать упреждающую отправку сразу всех данных.
И это получается без дополнительных запросов, намного быстрее.
Какое отношение это все-таки имеет к gRPC?
Если у нас есть что-то, что работает поверх чего-то с названием HTTP,
то, наверное, эта штука должна работать из обычных браузеров.
Обычный ремонт процедур calls можно использовать из обычного Джаваскрипта,
либо из чего-то, что транслируется в Джаваскрипт.
То есть мы можем теперь те же самые методы получения профиля, чата,
вызвать из обычного браузера.
Давайте попробуем, получится у нас это или не получится.
Так, отдельный проект.
Небольшое приложение, которое загружает профили,
выглядит следующим образом.
Так, port 1.9.0.1, здесь было для профилей.
Так, запускаем в Google Chrome.
Да, Google Chrome запускается долго.
Еще чуть-чуть там качается.
Так, сразу немножко про веб-разработку.
Совершенно не обязательно писать все на Джаваскрипте.
Я имею в виду клиентскую часть.
Когда-то давно можно было писать на Джаве.
Еще можно писать на TypeScript.
Еще можно писать на языке Dart.
Кто еще какие языки для веб-разработки знает?
В TypeScript я его перечисливаю.
Что еще?
Раст, кстати, да, тоже возможно.
Но такое извращение.
В общем, некоторые коды, которые позволяют что-то загрузить.
Браузер меня запустился.
Оно вроде даже работает.
Так, ладно, отправим.
Запрос. Мы знаем, что у нас есть пользователь по названию Vovan.
Отправка идет следующим образом.
У нас есть какой-то канал,
который реализовал, есть интерфейс,
который опять же сгенерирован из ProtoFile.
И если вы что-то в ProtoFile поменяете,
вам придется перекомпилировать то и другое.
Так, загрузка профиля.
Следующим образом,
создаете сообщение,
типа user, объект класса.
Вызываете метод getUserProfile
и получаете из него все, что вам нужно.
Ничего особенного.
Так, ну и теперь из браузера
отправляем на сервер.
И получаем в бабах какую-то ошибку.
Так, о том, что...
Внимательно не читаем текст ошибки.
На самом деле, ProPotentialCourseIssue можно проигнорировать.
Он отключен.
Запрос завершен без статуса.
И вообще какая-то ошибка,
связанная с тем, что у нас
браузер не получил какой-то осмысленный HTTP ответ.
С чем это связано?
Как вообще браузеры отправляют какие-то запросы?
Например, к внешним API.
Штука, которая называется
абраторией hxhr,
исходно называлась XMLHTPRequest,
которая позволяла создавать новые подключения
к JavaScript.
На самом деле, никакому языку XML это уже давно
отношение не имеет, но так исторически сложилось
именно такое название hxhr.
То есть создается новое подключение,
HTTP, которое дергает какие-то данные,
и дальше эти данные можно распарсить уже средством языка JavaScript
с той страницы,
которой этот запрос инициировал.
Во-первых, можно использовать только тот же самый протокол,
который использовался для загрузки исходной страницы.
Если браузер загрузил страницу
через протокол HTTP1,
то он отправлять может только HTTP1.1,
но не HTTP2.
А он является обязательным для gRPC.
Второе ограничение связано с тем,
что браузер подразумевает, что сначала должны быть все заголовки,
а потом идут данные.
В то же время, поскольку протокол HTTP2
очень гибко бьется на фреймы,
и в gRPC последний фрейм
обычно используется для того, чтобы вернуть
код возврата, который у вас получился
статус возврата из gRPC функции.
И это тоже не очень совместимо с тем,
что ожидает увидеть браузер.
Используйте gRPC даже в том случае,
если вы полностью перешли на протокол HTTP2.
У кого-то есть свой сервер,
у которого болтает свой сайт.
Можно на хостинге.
Попробуйте в качестве эксперимента
просто в настройках nginx переключить с HTTP1 на HTTP2,
и вы приятно будете удивлены,
потому что протокол HTTP2
все более распространен как средство
для выдачи контента.
Но тем не менее, эта маленькая особенность
то, что gRPC самым последним фреймом
выдает код возврата, который сам по себе
является заголовком. Он уже не совместим с браузером.
А как же все-таки можно использовать gRPC,
чтобы не создавать прослойки
в виде перекладывания JSON,
в виде дополнительных действий.
Можно использовать
некоторое подмножество gRPC.
Еще один протокол,
который называется gRPC Web,
это два разных протокола.
Если вы будете где-то в сети встречать протокол gRPC Web,
то это вовсе не gRPC, а протокол,
который назначен как раз для использования
браузерами, то есть его использование
помимо браузеров не очень осмысленно.
Когда-то для него существовал плагин для Nginx,
который потом уже перестал развиваться,
поддерживаться, его выкинули.
Но есть другие прокси-серверы, либо
юнвой-сервер, либо есть пакет еще для Гоуланга.
В чем заключается проксирование?
Для того, чтобы транслировать запросы,
которые может сформировать браузер,
в обычный полноценный gRPC, чтобы вам не приходилось
переписывать код. В обратную сторону ответы,
транслировать во что-то, что браузер
сможет понимать.
Небольшая правка в коде.
И плюс запускаем еще внешний прокси-сервер.
Так, сервис у меня работает.
Осталось запустить
что-то, что работает.
Что такое прокси-сервер? Это штука, которая
цепляется в качестве клиента к серверу,
при этом создает еще свой сервер,
который работает на другом порту,
и к нему уже клиенты могут подключаться.
В исходном тексте мне нужно поменять
номер порта.
8081.
Запускаю заново.
При этом нужно, естественно,
в аэршарке поменять
номер порта, если мы хотим за этим
наблюдать.
Пока запускается Chrome, есть у вас вопросы.
Тогда ждем, пока запустится Chrome.
Запустился.
Так.
Запускаем.
Ищем профиль Вавана.
Все работает. Это обычный браузер,
обычный джаваскрипт.
Точнее, код, который был транслирован джаваскриптом,
все равно выполняется обычным джаваскриптом.
При этом я не вносил никаких изменений
в тот сервер на C++,
который нам это все выдал.
Ну и что у нас реально передавалось по сети?
Вот у нас есть обычный HTTP пост-запрос,
который содержит URL
примерно такой же, как в HTTP2,
Content Type Application,
gRPC, web с proto-файлом.
И в этом запросе у нас
есть контент, который
уже является бинарным, тот самый
протобуфер. То есть протобуфер описывает только формат
сообщений, а не запрос.
И мы получаем ответ, который сформирован
уже проксисервером,
на основании тех данных, которые он получил от настоящего сервера.
Он просто поделил
все фреймы, запихал их
в некоторые отдельные части
последовательные.
Текстовый протокол в HTTP тоже позволяет.
Ну и несколько кусков,
которые потом склеиваются
и соединяются
в одно большое протобуфер сообщений.
Помимо протокола HTTP2,
сейчас уже 22-й год
существует в формате драфта
следующий стандарт.
Второй HTTP был не настолько популярным,
даже сейчас, сколько лет прошло,
2016-2015 год появился.
До сих пор это еще не мейнстрим,
поскольку не обладал
существенными преимуществами
в ущерб читабельности.
Сейчас разрабатывается новый протокол HTTP
на базе протокола Google Quick.
Тут уже будут более существенные улучшения.
Во-первых, будет использоваться UDP
Удп не дает никаких гарантий,
поэтому как раз используется
чуть более высокоуровневый механизм,
который будет отдельно
в польском пространстве,
а не в ядре,
считать,
какие пакеты у вас дошли
и в каком порядке составлять
UDP сообщения в правильном порядке
и дальше их интерпретировать.
Здесь дальнейшее развитие идеи
с фреймами, что у нас данные передаются
небольшими кусочками.
В отличие от второго HTTP
шифрование будет обязательным.
Главная пользовательская фича
в том, что можно будет делать
из одной сети в другую.
Это имеет смысл, если вы пользоваетесь
смартфонами, ноутбуками,
переключаетесь между Wi-Fi сетями
либо с Wi-Fi в мобильную сеть,
разрыва связи у вас происходить не будет.
Потому что у вас нету такого
постоянного TCP-соединения,
которое нужно переустанавливать.
Содержательных вопросов нет.
