У нас с вами задача с кратчайшими плечами продолжается.
На чем мы закончили прошлый раз?
На Форде Бэлмене.
Почему Форд Бэлмен был хороший?
Можно было найти отрицательный цикл и можно было работать
просто с отрицательными реблями.
Но это да и экстра выглядит все равно тоже прикольно.
Правда?
Вот.
Фактически на прошлом занятии мы с вами говорили о задаче,
чуть-чуть подсохнет, но существует несколько видов
задач на нахождение кратчайших путей.
Существует задача, когда вам нужно от вершины до
вершины найти, существует задача, когда вам нужно
от вершины до всех вершин найти, и от всех вершин существует
до всех вершин.
Задача от вершины до вершины — это, по сути, своя д-экстра
почти что.
Некоторые мои улучшения — это так называемые алгоритмы
со звездой.
Если у нас будет время, мы его разберем.
А от вершины до всех остальных вершин — это д-экстра, это
Форд Бэлмен, ну и пока все.
Ну, БФС еще можно сюда отнести, если очень хочется.
Согласны?
Вот.
Существует задача некоторая от всех вершин до всех
вершин.
В принципе, можно от каждой вершинки запустить д-экстру
и получить какой-нибудь алгоритм, который будет
показываться от всех вершин до всех вершин, но это будет
занимать чуть дольше времени.
Хочется придумать что-то другое.
И вот что-то другое — это будет называться алгоритмом
Флойда или алгоритмом Флойда Воршелла — одно из двух
названий.
В общем-то, какая задача?
Предположим, что у нас все также на графе есть веса
у каждого из ребер.
Мы с этим работаем, мы с этим живем, как бы все как
обычно.
И нам нужно найти эти кратчайшие пути от каждой вершины до
вершины.
В принципе, что мы ожидаем?
Мы ожидаем в качестве ответа некоторую матрицу, где у
нас будет в строке указываться, от какой вершины в столбце
до какой вершины, и мы будем смотреть, какие у нас есть
расстояния.
Все достаточно просто.
Согласны ли вы с тем, что эта матрица ничего особенного
не имеет?
Или нет?
Диагональ нули.
Если у нас будет неориентированный граф, то какая матрица будет?
Симметричная.
Отлично.
А диагональ нули?
Всегда ли будет диагональ нули?
Вот.
Если будет отрицательный цикл, то логично, что там
будет какие-то не те значения, которые мы хотим.
Ну, как бы, наивный подход какой?
Мы берем просто нашего Форда Белмана и запускаем
его в RAS.
Мы берем нашу DX3 и запускаем ее в RAS и смотрим, что у нас
получается.
Ну, для Форда Белмана у нас всегда получается
VF4.
Для DX3 это будет у нас либо A, но все достаточно просто.
У нас же там EV, ну, в некоторых случаях, да, действительно
будет V квадрат, ой, V куб, потому что я в RAS буду делать
V на V.
Вот.
Ну, в общем, в своей сути у нас будут почти плотные
графы почти всегда, вот.
Поэтому будет там VF4.
Но, да, в детпитительности, как бы, если у нас алгоритм
будет всего лишь, алгоритм у нас будет на разрешенный
граф, то у нас будет V куб.
Если же мы с вами говорим про то, что у нас еще ребра
будут не отрицательные, то тут включается DX3, и
тогда это будет с одной стороны работать за V квадрат
лог V на разрешенных графах, на плотных графах будет
все работать за V куб.
Но здесь важное утверждение, что у нас веса не отрицательные.
Это очень-очень важно и нужно.
Это все достаточно просто.
Теперь поговорим про сам алгоритм Флойда.
Что это такое?
Смотрите.
Хочется воспользоваться чем-то из первого семестра,
какого-то знания.
Мы же не просто так учились, правда?
Во-вторых, какой-то такой очень простой и какой-то
логичный момент использовать.
Какой момент использовать?
Смотрите, предположим, что у нас есть некоторая
вершина V, есть некоторая вершина U.
И вот давайте мы скажем следующее.
У нас есть какое-то посчитанное расстояние здесь, и я зафиксирую
какую-то вершину, не знаю там, а K.
Я буду смотреть для любой пары VU, что у меня лучшее,
расстояние, которое у меня есть сейчас тут, либо же
расстояние, проложенное через эту вершину K, и буду
обновлять все наши пути.
Вот я буду вот через нее только ходить.
Тут у меня какая-нибудь омега-1, тут омега-2, а тут
просто омега.
Вот я буду смотреть, что вот эта омега, она больше
чем омега-1 плюс омега-2.
Если она больше, тогда мне легче пройти через эту
вершину K.
Ага, пока понятно, что я говорю, или не очень.
Теперь представьте следующее, я вот этот вот принцип разобью
дальше.
Что вот здесь подразумевается, смотрите, подразумевается
следующее.
Представляете, что у меня открываются вершины поочередно,
и вот я смотрю на них, и вот их пытаюсь добавлять
вот с учетом того, как у нас граф выглядит, то есть
с учетом всех тех вещей, которые вот ребра там то
в него смотрят, то из него исходят и так далее.
И в зависимости от этого я пытаюсь вот именно вот
так вот проходиться.
Что это само по себе напоминает, что я использую какие-то
условия под задачи, которые были до этого, вот это,
то есть какой-то путь из уже открытых вершин, и смотрю
на новую вершину.
Фактически это динамическое программирование, которое
у нас с вами будет, и вот таким вот образом мы все
это перестраиваем.
В начале у нас будет пустота, у нас будет все грустно,
у нас одна вершина, а дальше мы добавляем эту вершину
и смотрим какие пути проходят через нее и так далее.
То есть грубо говоря, у нас есть некоторый граф,
и вот мы знаем, что какое-то количество вершин хотя
бы есть, но вот эти ребра, которые связаны с какой-то
вершиной, мы вводим поочередно.
Смотрим, что у нас происходит.
И в зависимости от этого мы ввез
свое улучшение.
Я утверждаю, что этого будет достаточно, то есть если
мы вот так вот будем добавлять по одной вершинке, и мы пройдемся
по всем вершинам, то этого будет достаточно, чтобы
понять, что вот эта омега – это действительно кратчайший
путь.
Фактически ребра связанные с вершиной.
Почему так?
Ну в действительности представьте, что у вас есть граф несвязанный,
у вас будет везде расстояние какое-то бесконечное, вот,
а потом мы добавляем ребра, связанные с конкретной вершинкой,
мы начинаем прокладывать.
Ну вот в него входит, из него исходит такого характера.
Фактически, если говорить фактически, как это будет
выглядеть с точки зрения реализации, достаточно будет следующего.
Вы просто фиксируете какую-то вершину и пытаетесь прокладывать
все пути через нее.
И смотрите, если я проложу этот путь через эту вершину,
то будет хорошо или плохо?
Вот, ну и буду обновлять.
Подходит, не подходит.
Вот, в этом заключается алгоритм Флойда.
Что здесь происходит?
Смотрите, имеется в виду следующее, вот у нас есть
Некоторая табличка, и я говорю, что этих табличек
будет В.
И вот dkt x, y это будет расстояние от x до y, в котором в качестве
вот промежуточных вершин, то есть по которому я мог
пройти по этому пути, используется только первый k вершинок.
Ну, у нас типа k табличек, я называю так, В табличек,
а?
В табличек?
Да, В табличек размером В на В, все правильно.
Вот, я открываю эти вершины поочередно.
Я говорю, вот я добавил одну вершину, вот добавил
вторую вершину, вот третью вершину, вот четвертую и
так далее.
И я говорю, что каждая последующая табличка будет зависеть
от результатов предыдущей.
Вот, логично ли звучит?
Примеры хочется?
Ну, давайте возьмем тот пример, который здесь,
например, нарисован, хорошо.
Давайте сейчас нарисуем, а после этого будем разбираться
дальше.
Вот, но если это табличка, в начале как она должна
быть заполнена?
Это D0, везде L, кроме диагонали.
Мы считаем, что все-таки сами элементы в себе будут,
правильно?
Согласно?
А?
Сейчас, петли могут быть, вот, если вопрос с петлями
правильный, а какой он будет в отрицательных циклах
и вот будут ли отрицательные петли, что они будут делать
здесь?
Действительно, если мы зафиксируем эту вершину, мы посмотрим
путь через нее и увидим, что у нас все соходится.
У меня же повторяющиеся вершины тоже будут от себя
до себя.
Вот, нолики, все остальное это бесконечности.
Дальше я начинаю это обновлять, я фиксирую нулевую вершинку
и говорю, ага, теперь смотрим все пути через эту вершину.
Что у меня происходит?
Какие обновятся, во-первых, эти вершины?
Один, три, ну, смотрите, четыре, два, обновится, обновится.
Вот у меня четыре, два, обновится здесь и станет четыре.
Четыре, нет, почему.
Ну, ты просто смотришь, у тебя есть вот это?
Ребра эти есть или нет?
Боже, нет, нет, нет, мы фиксируем конкретную вершину и идем
через нее.
Да, именно эту вершину фиксируем только и только
к ней ходим, типа вот из четыре я должен в ноль прийти
и из нуля в два, в этом случае пара четыре, два работает.
Вот, и в действительности как бы в дальнейшем мы будем
работать именно с этим и смотреть, что там дальше
происходит.
Если рассматривать эту табличку еще дальше, то
в этом случае, когда у нас пара будет четыре, два,
мы зафиксируем какую-нибудь новую вершину и попробуем
походить еще через что-нибудь и так далее.
И когда мы дойдем до третьей, до третьей вершинки, у
нас будет, смотрите, до четыре, два я могу дойти
до четыре, а в то же время до четыре, два я могу пройти
через три и будет стоимость два и обновим.
Как я это сделаю?
Смотрите, я буду смотреть, а какое у меня вообще расстояние
есть до четырех, какое у меня есть расстояние до
двух и от этого входим.
Вот, давайте чуть более подробно.
Смотрите.
Да.
Четыре, пять, четыре, два, да.
Вот, смотрите, ну что такое D0XY?
Мы с вами уже говорили, что D0XY вообще в самом начале,
в действительности, мы, чтобы вот не ходить вот таким
вот путем, как мы сейчас делали, и вот не обновлять
вот по одной ячейке очень долго, давайте с самого
начала зафиксируем, что нулевая его часть, то есть то, когда
у нас только появляется эта табличка, у нас будет
равна весам все, которые есть.
То есть вот все, что у нас с вами здесь было в действительности,
мы возьмем и сразу скажем, что, ага, ну у нас же есть
прямые пути, правильно?
Вот, эти все прямые пути мы добавим, то есть фактически
с самого начала, вот эту четверку пока сотру, у меня
будет здесь 4, 0, это 1, у меня будет 4, 3, это 1, что там,
0, 2, это 3, 0, 5, это 1, тут, тут, тут, давайте с единички
начнем, а в единичке ничего, в двойке 2, 1, правильно?
3, 2, 1, это 1, вот, тройки, тройки, это 3, 2, это 1, и это все,
и в пятерке это 5, 1, да, правильно, правильно, вот,
мы начнем вот с этого момента, ну потому что это прям
ровный путь между вершинками, согласны?
Вот, это отлично, что мы дальше, а, знаем, смотрите,
если, вот как вы думаете, чему равен вот обновление
вот этой таблицы, в случае, если вот у нас есть к плюс
первая какая-то вершина, ну фактически катая, номер
ее катый, таблица будет к плюс первая.
Мы говорим, что, знаете, мы говорим, что дкт это пути,
которые меньше, чем к, используют вершины, с номерами меньше,
чем к, с нулевая это вот просто вот эту, без обновления
одной вот этой штучки, на один побольше, нет, смотрите,
давайте еще раз, хорошо, я возможно вас допутал,
простите, пожалуйста, смотрите, дкт, само по себе, это минимальное
расстояние, минимальное расстояние, проходящее
через вершины, с номером, меньше к, меньше к, ага, вот
здесь, так нет, прямые пути, у них ничего не проходит
путь, д нулевое, не через одну вершину не проходит
прямой, вот, смотрите, теперь вопрос, дк плюс первый,
чмо он равен, если мы знаем, что кратчайший путь у нас
не будет идти через вершину к, нет, пока мы не обновили,
вот, д1 мы бы обновили, смотрите, да, д1, вот, если бы я добавил
нулевой вершины, посмотрел пути через нее, ну, давайте
хорошо, давайте д1 отмечу еще раз, вернемся к этому
примеру, д1, да, тут соря, вот, тут ошибся, раз, два,
три, четыре, пять, перебрал, раз, два, три, четыре, пять,
а чо у нас тут нули, здесь у меня единичка, единичка,
единичка, единичка, единичка, единичка, тройка единичка,
да, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, ну, теперь смотрите,
чо с этим делаем, я говорю, ага, теперь, д1, оно что делает,
оно должно пройти через нулевую вершинку, ну, теперь вот
я могу использовать эту нулевую вершину, что я смотрю, вот,
заполнено бесконечности, через нулевую вершину у меня
один путь, два, это 4, 2 и 4, 5, ну, вот я и ставлю, 4, 2, у
меня будет 4, 4, 5, это будет 2, вот, все мое обновление
пока, ага, вот, а теперь смотрите, давайте вернусь к вопросу,
если у меня кратчайший путь не проходит через вершину
k, то dk плюс 1, чему будет равен?
dk тому, да, ну, то есть, смотрите, если кратчайший путь никак
не проходит через нашу вершину, то, хоть добавляя, хоть не
добавляя, у нас все равно кратчайший путь будет вести
через другие вершинки, правильно, поэтому, как бы, ничего
не изменится для нашей, для нашей вещи, вот, а если
известно, что кратчайший путь идет через нашу вершину,
значит, будет dk xk плюс dk ky, да, вот, ну и тогда в общем
случае, чему будет dk плюс первое равно?
Минимум из этих двух, все правильно, вот, то есть, мы
возвращаемся вот к этой вот картинке, понятно, мы фиксируем
конкретную вершину, смотрим, идем через нее или не через нее,
все, это и есть алгоритм Floyd, в действительности, с точки
зрения реализации это выглядит вот так, что вы делаете?
Естественно, хранить типа k таблиц в таблиц не прикольно,
храните одну, почему, потому что у нас каждая следующая
итерация зависит от предыдущей, ни от чего дальше не зависит,
согласны, вот, и пока что здесь трехмерная, хорошо,
но подумайте на тему того, что они будут не зависеть,
мы до этого сейчас дойдем, да, sorry, я говорю, что-то сегодня это,
то есть, в общем-то, в действительности, что у нас происходит, у нас есть вот эта
катная таблица, она зависит от каты, а k плюс первая таблица, она зависит от каты,
вот, пока что в этой реализации, что мы должны сделать, мы должны пройтись по таблице от нуля
до там, в этой табличке, вот, дальше пройтись по всем вершинам, по всем парам вершин и посмотреть,
можем мы обновить, не можем мы обновить эту таблицу, согласны, ну вот, все, пока сложно
выглядит или нет, понятно, как это написать, вот, единственное, что здесь у меня чуть-чуть косяк,
хотя нет, нормально, в нулевом случае, в плане, или в каком, да,
да, только путь, когда лежит через k, но в действительности надо, это нам будет помощь,
почему надо, потому что мы не знаем, можем мы обновиться так или нет, ну, то есть, есть ли путь
вообще какой-то из одной вершины в другой, это же проверить еще надо, что будет означать,
что пути нету, вот, из v в k и с k в u, значит, хотя бы где-то здесь у нас как минимум там
бесконечность возникнет, согласна, вот, в этом случае мы минимум пройдемся по вот этому,
если ты хочешь, ты хочешь сократить количество действий, я так понимаю,
все зависит от того, как будет выглядеть граф, то есть там он достаточно неплотный,
который был на примере, если он будет плотный, там будут обновления больше, сильно больше,
вот, а важный момент здесь следующий, заметьте, я сначала фиксирую таблицу k, а только потом
рассматриваю все пары, то есть вот это fo k идет первым всегда, окей, фактически это просто три
цикла в цикле, вот, ничего страшного, теперь следующий момент, следующий момент, это то,
что чуть-чуть проговорился, в действительности вам не нужно хранить k таблику, у вас каждое
последующее зависит от предыдущей, согласны, значит, можем хранить хотя бы две и уже неплохо,
тогда в этом случае вы будете использовать просто предыдущие результаты и вот между собой их
перекидывать, то есть сначала в одну записку, потом в другую, потом еще что-то и так далее,
окей, нравится это, сколько памяти, давайте так, вопрос такой, сколько бы памяти задействовали,
если бы мы так не сделали, в куб, а здесь в квадрат, уже неплохо, правда, вот, но я хочу
сделать еще лучше, я хочу убрать эти две матрицы, я хочу оставить одну и в действительности не будет
никакого аффекта в том, что вы возьмете и оставите эту одну матрицу, почему, все то же самое, только без матрицы,
по сути своей это правда, то, что ты сейчас говоришь, кроме того, мы заполняем их вот таким вот образом,
мы смотрим нулевую вершину в самом начале, когда ее добавляем, например, потом первую вершину,
как только мы ее добавили, то есть мы смотрим вот в этом плане здесь именно таким образом,
в действительности можно реализовывать это in place, здесь написано, что о памяти этот единичке,
но это чуть-чуть может быть не так, почему, а все зависит от того, как вам даны все веса,
если вам даны с помощью матрицы смежности, то все логично, у вас тисилки стоят, ну зачем вам
создавать новую табличку, тогда у вас действительно будет этот единичке, а если вам дам список ребер,
то в этом случае она будет в квадрат, но представьте, что ее так и далее, но у вас другого варианта нет,
фактически сам алгоритм не будет использовать дополнительной памяти, вот вы использовали
только то, что у вас есть матрица смежности, ага, вот в этом суть, вот, ну и все, вот это весь алгоритм,
а дальше внутри этого всего мы увидим расстояние от x до y, можем ли мы вообще дойти, понятно,
сложно, нет, это чудесно, вот, а в действительности, в действительности,
а почему это можно, ну как бы здесь опять же нужно рассмотреть вот эти зависимости друг от дружки,
а что вот если мы будем таким вот использовать типа и вот заглядывать на какие-то результаты,
которые были в предыдущем шаге и возьмем не старые, а новые, изменится ли что-то,
в действительности хуже ничего этого не сделает, поэтому это все будет ровно то же, что мне надо,
вот, а как бы если у нас нету каких-то отрицательных циклов, то ничего не произойдет здесь,
согласны, ну то есть не будет никаких вот этих вот круговорот, чудесно, а что с
отрицательными циклами делать, как понять, что они есть, да, на диагонали окажется,
что у нас какие-то отрицательные числа будут и в этом случае мы говорим, что у нас есть
отрицательный цикл, все, есть ли тут вопросы, нет, все понятно, и все хорошо, окей, тогда мы с вами
получаем, что у нас есть алгоритм Floyd, который всегда работает за V-куб и неважно у вас алгоритм,
ой, у вас граф плотный или разреженный, без разницы, он всегда будет работать за V-куб, поэтому в
моменте, когда у вас будет плотный граф и у вас будут веса отрицательного, ой,
ребра отрицательного веса, в этом случае алгоритм Floyd полезен, а так как бы в других случаях он
может занимать столько же времени, сколько там Форд Белман или Дейкстра, вот, это первый такой
нюансик, теперь смотрите, начинается вот самое самое интересное, представим, представим такую
картину, что я хочу все-таки, чтобы Дейкстра работала на отрицательных ребрах, что мне нужно
сделать, мы чуть-чуть обсуждали этот прошлый раз, я сказал, подумайте, что для этого точно
нужно сделать, нужно вести потенциал, кто помнит, что такое потенциал, какого флешбеки с амортизационного
анализа, а, пункт С состояние, хорошо, почему потенциал, почему правильно вести какой-то потенциал,
смотрите, здесь большинство с ПМФ или ПМИ, а, ну все, отлично, с ПМФ, смотрите,
что означает потенциал физики, что она позволяет делать, хорошо, давайте другой вопрос задам,
типа, с потенциалом, вот у вас есть земля и вот у вас есть здесь элемент, я могу вот так вот пройтись
к какой-то другой части, не знаю, точки А до точки В, а могу вот так пройтись, будет ли у меня разница
потенциала хоть как-то это зависеть, вот, здесь будет ровно так же, если мы с вами введем какую-то
функцию потенциала, которая будет показываться в каждой вершине графа, то в этом случае, когда
мы будем их вычитать, грубо говоря, вот у нас же что происходит, мы хотим с потенциалом попробовать
сделать так, чтобы у нас он увеличивал расстояние и там что-то происходило, и вот это увеличение
должно быть таким, чтобы оно зависело только от начальной и конечной точки, не зависело от пути,
которые мы с вами проходим, а Dextra работает на графах, где у нас нет отрицательных ребер,
я хочу, значит, избавиться от отрицательности ребер, просто прибавить всем не вариант, в прошлый
раз мы с вами это посмотрели, правда, или есть вопросы, почему это не подходит,
просто прибавить все, ребра, не знаю, плюс 100, репутация и мисс карисы, не знаю, вот так,
все ли понимают, почему это не подходит, не только, даже если бы циклов не было,
ну, почти что, смотрите, ладно, хорошо, давайте, я лучше подчерчу, у нас есть вот такой,
вот такой вот путь, и смотрите, с одной стороны, я скажу, что, ага, ну вот у меня, не знаю, тут путь 100,
вот, а здесь путь будет, не знаю, а 5, 7, 1, 3, ну вот где-то в графе там, где-то еще есть отрицательные
ребра, ну, предположим, что они максимум 100, ну, отрицательные по модулю 100, давайте я попробую
прибавить ко всему 100, что у меня будет проблема, у меня будет проблема в следующем, у меня здесь
105, здесь 107, здесь 101, тут 103, а вот здесь 200, теперь смотрите, какой путь более выгодный, вначале путь
был вот такой более выгодный, согласны, а теперь у меня более выгодный нижний, потому что сверху
я прибавил по 100, и вот из-за того, что у меня количество ребер в этом пути другое, у меня увеличилась
стоимость пути, что неправильно, я хочу избавиться от такого, мне, наоборот, такое нельзя, мне нужно
вести некоторую функцию, то есть я хочу прибавить каждому ребру свой потенциал, разницу потенциалов
от начала до конца, то есть в конечной точке до начальни, и тогда я буду понимать, как это работает,
и тогда она будет не зависеть от пути, и тогда у нас все чудесно и прекрасно, ага, вот, это то, что я
хочу здесь сделать, это называется алгоритм Джонсона, вот, а все окей, все хорошо, мы определяем новую
какую-то весовую функцию на каждом из ребер, мы говорим, что пусть у нас новый вес ребра равен
предыдущему весу ребра, плюс потенциал вершины, куда мы придем, ой, откуда мы придем, минус потенциал
из вершины, где мы были, куда придем, ну вот, это разница потенциала, это все, что я хочу здесь
добавить, могу так сделать, могу, то есть я должен вести потенциал для каждого из вершин, нужно
понять, что у нас происходит, ну как изменится длина произвольной пути, да никак, у нас изменится на
разницу потенциала, поэтому, если я захочу вернуться обратно к моменту, когда я был на нормальных
ребрах и не изменял их никак, то я просто должен буду вычесть потенциалы начала и конца, вот эту
разницу, согласны, потому что я буду ее понимать, то есть я хочу найти там, не знаю, расстояние от В до У,
вот я вычил расстояние до У, ой, потенциал до У, прибавил потенциал до В, получил действительно
свою весовую функцию. Окей, есть ли тут вопроса? Осталось понять. А следующий, а? А следующий вопрос, изменится ли
кратчайший путь вообще, сам по себе? Нет, почему? Потому что вот из-за того, что мы будем прибавлять,
убавлять потенциалы, у нас всегда останется вот эта разница потенциалов одна и та же, мы это с вами
тоже сейчас сделаем. А изменится ли вес любого цикла? Не изменится, почему? Потому что мы в начало
пришли, в начало, в начало пришли, в начало пришли, значит мы просто прибавили потенциал в этой точке,
убавили потенциал в этой точке, получили ноль. Отлично. И теперь следующее, ну как бы мы с вами
понимаем, что нам осталось придумать этот потенциал. Как бы в теории звучит все хорошо,
осталось придумать это на практике. У кого какие идеи? Это не совсем хорошо, потому что представь,
что у тебя есть продолжение пути в виде того, где не отрицательное ребро, и тебе нужно дойти еще.
У тебя путь изменится тогда, у тебя может измениться путь. Вот. А сильно вас этим мучать не буду,
объясню почему. Я б тоже не догадался, поэтому все хорошо. Книжки просто почитал умные и все,
и я здесь. Но в действительности, смотрите, как это выглядит. У вас есть некоторый граф G. Что вы
делаете? Формально, когда описывали алгоритм Джонсона, говорилось следующее. Давайте добавим
фиктивную вершину. От этой фиктивной вершины проведем ребра во все остальные вершины и скажем,
что все эти ребра весит 0. Следующий шаг. Давайте отрелаксируем все ребра. Фактически запустим
алгоритм Форд Белмана. И тогда я в этом случае что сделаю? Найду кратчайшие пути от каждой вершины
до вершины через вот эту вершинку. Почти всегда. Правильно? Тут 0, тут 0. Вот она проходит через нее. Вот.
Если у нас был бы отрицательное число здесь какое-нибудь, то есть у нас бы появились бы новые отрицательные
какие-нибудь штуки. Вот. Чудесно. Вот это оно в действительности и будет. Фактически мы говорим следующее.
Вот здесь есть теорема Джонсона, который он и брал, что мы добавляем вот эту фиктивную вершину. Из нее
исходят все ребра веса 0. Запускаем алгоритм Форда Белмана и находим кратчайшие расстояния от этой
фиктивной вершины до остальных вершин. Все оно не нулевое, оно может быть отрицательное еще как-то.
Почему? Ну потому что я могу вот либо по нулевой вершине пройтись, либо вот здесь вот у меня есть
там минус 5. Я в этом случае дойду сюда через минус 5. Вот запускаю алгоритм Форда Белмана,
нахожу и тогда в этом случае получаю некоторое число. Вот это число, которое является кратчайшим
расстоянием будет потенциалом. Вот. Потенциал вершины, то есть это будет то кратчайшее расстояние
от нашей вершины, фиктивной, которая есть, до всего остального. Ну какое здесь доказательство?
Смотрите, я говорю следующее, что пусть у меня есть некоторый вес ребра с потенциалами. Он равен
весу самого ребра плюс потенциал вершины В минус потенциал вершины У. Это хорошо. В этом случае
тогда я возьму и скажу, что у меня является потенциалом. Я говорю, что потенциалом в этом
случае является вот это кратчайшее расстояние от вершины фиктивной. Там у меня названа эта звезда.
От вершины С-звездочка до вершины В минус расстояние от С до У. Почему оно больше либо равно нуля?
С-в-в-у. Он не короче, давай так скажу. Ну то есть да, подразумевается следующее. Вот у меня есть
эта звездочка, у меня она указывает в какую-то вершину В и у меня есть какая-нибудь вершина У. Вот,
я подразумеваю следующее, что кратчайший путь от вершины С до вершины У, он может пролегать через
какие-то другие вершины. Он явно не должен быть больше, чем просто путь из вершины С-звездочка в
В. Согласны? Потому что это не факт, что кратчайший путь. Вот, значит последний у нас больше либо равно нуля.
А тогда, если оно больше либо равно нуля, то мы получаем что? Что веса всех ребер не отрицательны.
Согласны? А если у нас веса всех ребер не отрицательны, то что мы можем сделать?
То запустите алгоритм Д-экстры. Да, именно так это и выглядит. То есть, фактически, алгоритм
Джонсона звучит таким образом. Добавляем фиктивную вершину с нулевыми ребрами во все остальные вершины.
Ищем кратчайшие пути для всех вершин, которые у нас есть с помощью алгоритма Форда Белмана.
Смотрите, смотрите.
Не совсем так. А вопрос примерно в следующем. За сколько? Ну, у нас как бы, да, это может
все работать за ВЕ. Это прикольно, еще что-то. Но в действительности все будет завязано как раз
таки на этих отрицательных ребрах и так далее. Алгоритм Д-экстры очень понятно, как формулируется,
он не очень долго работает сам по себе. Но что здесь важно понимать? Важно понимать здесь
следующее. А вот с помощью вот этого алгоритма Джонсона мы найдем расстояние от одной вершины
до всех остальных. Или от всех до всех? От всех до всех. Да? Или нет? Ага. С со звездой вести
ее изначально. На самом деле, вам ее вводить даже не нужно будет с точки зрения реализации. Ну,
это следующий момент, когда я того же скажу. Вопрос следующий. Смотрите, а за сколько у нас
работает Д-экстра? За ЕЛУКВ, предположим. За сколько работает Форд Белман? За ВЕ. Вот если я в раз буду
запускать Форд Белмена, то у меня будет работать за В квадрат Е. А если я в раз буду запускать Д-экстра,
то оно будет работать и один раз Форд Белман, то это будет ВЕ плюс ВЕЛУКВ. Что из этого лучше?
Ну, то есть давайте еще раз. Сравнение следующее.
