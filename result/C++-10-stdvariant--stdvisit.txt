Наш цель – обсудить, как устроен STD-вариант изнутри и еще, как устроено функциональный visit.
То, что вам Федя показывал в прошлый раз в конце.
И после этого можно будет выдать вторую задачу, которая…
Ой, не вторую, а пятую задачу.
И предпоследнюю задачу в этом семестре, которая называется вариант.
То есть STD-вариант у вас будет задание реализовать.
Но перед этим нам надо закончить, что мы недообсудили в прошлый раз.
И в прошлый раз мы недообсудили STD-фанкшн.
Вот такой файл был.
Я думаю, что можно помельче сделать даже.
В прошлый раз мы остановились на том, как реализовать STD-фанкшн.
И обсудили почти все, что нужно.
Решили почти все проблемы.
Но самое последнее я не сказал.
Давайте вспомним, что у нас там было.
Во-первых, делали small object optimization.
Это, если функция, а это часто бывает,
если функциональный объект, его size of меньше или равен,
чем некоторое число, например, 16,
то нет смысла выделять под него динамическую память.
Мы его храним в локальном буфере.
Дальше, что мы еще делаем?
Если у нас функтор, вот этот вызываемый callable объект,
является pointer to member, указателем на член,
то обычный синтаксис вызова не сработает,
и нам надо будет делать вот такой синтаксис вызова
через точку со звездочкой, ну или через стрелочку со звездочки.
Поэтому, чтобы нам корректно вызывать,
и в таком тоже случае мы используем STD-invoke.
Я напоминаю, вот этот STD-invoke,
она нужна для того, чтобы корректно обрабатывать ситуации,
когда у нас callable не обычный,
а, например, указатель на член или указатель на метод.
Вообще объект, в котором мы вызываемся, является указательным.
Он корректно обрабатывает стрелочку у нас со звездочкой и так далее.
Вот, и какая еще была проблема последняя,
которую мы обсуждали, это...
Да вроде все, вроде у нас там...
Ну, еще здесь корректно move-ать надо.
Напоминаю, что вот здесь мы все forward-им.
Вот.
Здесь возвращаемый тип, мы написали declType от авто.
Я, кстати, не уверен, что declType от авто будет всегда корректно подходить здесь,
но может быть...
Ну, кажется, что в базовых случаях будет.
Но на самом деле здесь не declType от авто написано,
а invokeResultT.
Вот, и вычисляется он более сложно.
Ну, по сути, он вычисляется отдельно для того, чтобы корректно вернуть.
Ну, там есть какие-то тонкости,
из-за которых, кажется, declType от авто не будет работать, но...
Ну, в смысле, в каких-то краевых случаях, кажется, declType от авто не подойдет.
То есть там, если у нас массивы, поинтеры, что-нибудь такое,
то там declType от авто не подходит,
поэтому в стандартной библиотеке используется специальная метафункция invokeResultT,
которая, по сути, просто вот это все повторяет,
и вот возвращаемый тип этого и называется invokeResult.
Вот.
У нас есть две проблемы еще.
Ну, как две? Даже, наверное, три.
Вот про function еще надо сказать три вещи.
Во-первых...
Ну, давайте начнем вот с чего.
Сейчас я открою некоторый заготовленный код.
Так.
Значит, смотрите.
Я назову файл function.impl2.cpp.
Он у меня просто в другой папочке лежит.
На самом деле стандартная функция реализована не так, как я написал.
Она реализована чуть хитрее.
И вот что там на самом деле написано.
Вот это будет function.impl, а я сейчас открою function.impl2.
Я просто этот код заранее подготовил.
Я не хочу писать его руками, потому что это долго,
но вот вкратце давайте обсудим, что здесь написано
и чем это может быть лучше или хуже, чем то, что мы написали раньше.
На самом деле мы, когда реализовались на function,
использовали виртуальные функции.
И вот стандартная библиотека...
Ну, виртуальные функции, в которых еще...
Там еще есть штука typeID, то есть хранится typeInfo.
Можно у function, кажется, спросить название typeInfo того функтора,
который там сейчас лежит.
Вот в стандартной библиотеке function реализован не так, не через виртуальные функции.
Есть другой подход.
То есть можно сделать все то же самое, но без виртуальных функций.
Понимаете ли вы идеи, как это можно сделать без виртуальных функций?
На самом деле мы с вами вот эти вот виртуальные функции здесь использовали
Зачем нам нужны виртуальные функции здесь были?
Потому что без них мы как бы не умеем динамически подменять тип того, что у нас лежит.
Почему не умеем?
Потому что, ну, как минимум нам надо уметь вызывать деструктор старого,
прежде чем класть новый.
Если мы уничтожаем старый функтор и кладем на него новый,
то нам нужно уметь вызывать деструктор.
Но мы не можем узнать, какой именно код нужно вызвать для деструктора,
если мы не помним, какой реально тип лежит под function.
То есть нам нужно где-то что-то хранить, какой-то указатель на функцию,
которая должна отрабатывать, когда деструктор вызывается.
И по сути виртуальные функции именно этот механизм реализуют.
Виртуальная таблица это и есть набор указателей на функции,
которые вызываются в соответствующих случаях.
Значит, что делать, если позвали деструктор,
что делать, если позвали копирование,
что делать, если позвали там, не знаю, оператор круглые скобочки и так далее.
Ну, то есть вот здесь вот.
Вот здесь вот еще должен быть метод getCopy тоже виртуальный,
который будет зваться в случае, если позвали копирование.
Там метод getMove, наверное, если позвали мувающий конструктор, ну и так далее.
Вот, ну, мы его не реализовали, но понятно, что он должен быть.
Вот можно все это делать не через виртуальные функции, а вручную.
И у такого подхода, кажется, могут быть преимущества по эффективности.
А мы хотим, типа, просто вручную реализовать то же самое?
Ну, вот подход, который в STL выбран.
Вот если вы откроете STL-ный код Function, вы там не найдете слово virtual нигде.
Вот если вы откроете прям класс Function, вот я сейчас попробую.
Я не знаю, здесь у меня есть вот Function.
Давайте я попробую открыть.
Нет, к сожалению, он так не может, что у меня сломалась переход к типу.
Может быть, здесь он сможет.
Да, ну вот, значит, вот я открыл STD Function, вот файл просто открыл.
И здесь можно попробовать найти слово virtual.
И я просто по коду STD Function ищу слово virtual.
И вот я нашел bad function call, это исключение.
Больше слова virtual не встречается нигде.
То есть Function реализована как-то без виртуальных функций.
Как же оно так сделано?
А здесь просто, видите, есть статические методы, которые, по сути,
ну, в каком-то смысле аналогичны по поведению таблиц виртуальных функций.
Что такое таблица виртуальных функций?
Это для данного типа набор статических методов.
Что делать, если позвали destructor?
Что делать, если позвали copy constructor?
Что делать, если позвали оператора круглые скобочки?
Мы можем, по сути, сделать то же самое.
Мы можем сделать вот так.
Я вам сейчас еще раз покажу этот код.
Значит, это очень упрощенный код, но, значит, идейно он отражает суть.
У нас будет для данного функтора, для данного typeName функтор
шаблонный метод, который будет называться invoke,
и он будет, значит, делать вызов этой функции.
Ну, тут должен быть std invoke, но для простоты я делаю просто вызов,
обычно через круглые скобочки.
У нас будет шаблонный метод create, который для данного функтора
создает по адресу destination объект функтор от другого.
По сути, метод copy.
У нас будет шаблонный метод статический, destroy,
который для данного функтора, опять-таки,
указатель на объект типа функтор вызывает его destructor.
По сути, это и есть аналог таблицы виртуальных функций.
Давайте назовем теперь вот такими типами.
Значит, invoke.ptrt – это что такое?
Это указатель на функцию, которая принимает void-звездочку
и аргументы, и возвращает рез.
Значит, create.ptrt – это просто штука, которая принимает две void-звездочки
и возвращает ничего, а является указательной такой функцией.
А destroy.ptrt – это указательная функция, которая просто
принимает void-звездочку и ничего не возвращает.
И по сути, мы в классе храним вот эти указатели,
мы в объекте нашего класса, function, храним указатели
на эти pointer, ой, господи, на эти методы статические.
Когда мы создаем функцию, когда мы создаем function
от функтора, мы инициализируем эти указатели.
Указатели чем? Invoke.ptr – мы берем вот этот вот invoke от функтора,
invoke с шаблонным параметром функтора, статический метод,
и указатель на него, ну и кастим invoke к типу invoke.ptrt.
То есть invoke.ptrt – reinterpret.cast.
То есть мы просто, ну вот по сути делаем стирание типа.
То есть мы делаем вот эти вот методы от void-звездочки, хотя на самом деле
они от функтора звездочки. Всякий раз, когда мы создаем
от нашего нового типа функтор, мы тем самым заставляем компилятор
сгенерировать новую, ну синстанцировать новый статический метод
с данным шаблонным параметром функтора, куда запихать код,
что делать для такого функтора. И сохраняем у себя вот этот вот pointer
на этот статический метод. Соответственно, когда нас просят
что-то сделать, ну да, вот здесь надо еще сделать create, собственно.
Или здесь надо просто new сделать сейчас. Давайте подумаем.
Значит, я проинциализировал вот эти указатели, а теперь я могу просто сделать…
Ну да, никто не отменял, что мне надо сделать align-ness, std,
max-align-t, char, buffer, размером, господи, max-buffer-size.
Ну то есть, короче, всю эту штуку мне надо сделать по-прежнему.
И здесь мне нужно просто создать new от…
Ну или мне, собственно, надо вызвать вот этот create.
Да, по сути, create мне и надо вызвать. Значит, create-ptr.
От чего? Значит, из чего на что? Мне нужно передать ему
functor звездочка dest и functor звездочка crc. functor звездочка dest
это будет мой буфер, а crc это будет вот эта штука.
Ну, тут, возможно, надо сделать какие-то интерпрет-касты явные,
чтобы оно скомпилировалось, но идея на именно это происходит.
Значит, когда мне будет вызывать деструктор? Или когда мне будет вызывать
оператор присваивания? Что я должен сделать?
Ну, допустим, я хочу вот этому functor, ага, значит, function…
Ну это опять будет template, typeName, functor, function&,
оператор равно от const functor&f.
И что я здесь должен сделать? Я должен сделать сначала dest ptr
вызвать от своего буфера, а затем сделать…
Ну, проинициализировать мои новые pointer вот этим вот типом,
который мне передали. То есть invoke-ptr проинициализировать,
reinterpret-cast-нуть к invoke-ptrt от того, значит, этот reinterpret-cast-нуть
сделать вот так, dest ptr reinterpret-cast-нуть сделать вот так.
И, значит, после этого сделать create ptr вот опять-таки от буфер
и от того, что мне дали.
А что такое еще раз буфер?
Ну, буфер – это то самое место, где мы храним function наш.
Вот. Ну, тут надо опять-таки…
Ну, здесь должно быть как в нашем function smallObjectsOptimization,
потому что у нас буфер может быть…
Ну, у нас должен быть, короче, pointer на случай, если объект функции
не помещается в динамическую, в локальный буфер.
Или если помещается, мы просто на него кладем.
Ну, то есть здесь должно быть еще написано if constexpr…
Ну, короче, буфер – это просто то место, куда мы объект кладем,
объект самого functor.
Но на случай, если он помещается в smallObjectsOptimization,
то есть maxBufferSize, ну, допустим, 16 или 32.
Мы считаем, что если объект size объекта меньше или равен чем это,
то мы просто кладем по этому адресу наш объект.
А если нет, то здесь нужно еще сделать pointer на динамическую память,
куда мы будем класть объект в случае, если его размер не влезает.
Ну, соответственно, надо подредактировать весь код,
чтобы различать, мы сейчас должны в динамическую память идти
или не в динамическую память.
Ну, то есть нам надо еще где-то помнить опять-таки, видимо, bool.
Ну, как мы там это делали? Я уже забыл. У нас был…
Ну да.
У нас был FPTR, который либо NullPtr, да, либо не NullPtr.
Если он NullPtr, то мы, значит, понимаем, что у нас локальный storage
и идем вот от этого вызываться.
Если он не NullPtr, то мы идем вызываться от того адреса,
где лежит наш объект.
Вот. Вот. По сути, мы написали таблицу виртуальных функций своими руками.
Вот. Именно так сделано VSTL, именно так реализована Function.
А зачем так сделано? Какой-нибудь есть идеи?
То есть вот на самом деле то, что мы делали раньше, оно…
Ну, проще пишется, казалось бы.
Мы просто использовали готовый механизм виртуальных функций.
Но можно было бы предположить, что мы не знаем виртуальных функций.
Тогда мы могли бы, по сути, написать его сами.
То, что здесь сделано, это, по сути, самописное виртуальное…
самописное retable.
Вот. А настоящий retable, ее отличает одно.
Мы прямо в объекте класса храним эти поинтеры.
И мы это тут побыстрее.
Мы увидим, у нас просто меньше на один прыжок по указателю.
Да. Значит, преимущество…
В смысле избежать runtime приколов.
В чате пишет человек.
Избежать runtime приколов мы, кажется, никак не можем,
потому что все равно уже в runtime идти подменяем.
Вот.
Преимущество этого в том…
Ну, одно из преимуществ этого в том, что мы не прыгаем в…
Ну да, можно сказать, что вот в такой реализации у нас
на один прыжок по указателю меньше,
когда мы с функцией что-то делаем.
Когда мы, например, делаем call, вызываем функцию,
делаем invoke, то поинтер, по которому делать invoke,
он сразу вот этот вот адрес, указатель на функцию,
которая является вызовом нашего функтора,
она вот тут у нас прямо лежит.
Нам не нужно идти в таблицу виртуальных функций
и там искать адрес этой функции.
То есть как будто бы мы делаем на один прыжок меньше.
Правда, при такой реализации у нас размер самого объекта function
сильно возрастает.
У нас здесь, смотрите, сколько указателей.
Invoke, putter, create, putter, destroy, putter.
Так еще и нужен move, move-ующий оператор.
Значит, ну, нужен еще оператор…
Нужна еще функция, которая делает functor
от std move от CRC.
Это по идее еще одна.
И у нас тогда размер самого объекта function раздувается просто неимоверно.
Это минус.
Но если мы посмотрим sizeof от std function,
мы скорее всего увидим, что он небольшой.
Там не лежит так много объектов.
Ну вот, я не знаю, здесь где-нибудь закомментировать бы все
и посмотреть просто std…
Не аккомпилируется такой вот интересный или нет?
Давайте я просто спрошу, какой размер sizeof std function, например,
от… да хоть от того же, bool от int int.
По коду std довольно трудно понять, какой он там.
Там трудно.
Господи, что я сделал.
Вот, ну вот если я попрошу function.impl скомпилировать,
конечно же будет куча ошибок компиляции.
Ой, господи, боже мой.
Ладно.
А к чему 11?
G++11, не C++11, а G.
У меня версия компилятора G++11.
Не версия языка, а версия компилятора.
Не путайте.
Но у меня не за inclusion function.
Давайте за inclusion functional, да?
32.
Вот, размер объекта function 32.
Я не помню, ну как?
Я не знаю, какие именно там хранятся поинтеры.
Ну, то есть вот какой был размер вот этого объекта,
если бы мы реализовали его вот так?
Кажется, что 24, да?
А какой бы размер был, если бы мы реализовали вот так?
Function.impl2.
Как будто бы он равен...
как раз...
Ну, он равен 24.
Это вот эти три поинтера.
И еще buffer size char.
Значит, это еще, видимо, 16.
Еще у нас не хватает поинтера на move конструктор.
Это еще 8.
Ну, короче, много.
48 где-то у нас было, да?
4 еще.
Ну, где-то 48 байт у нас при таком.
Вот.
Что можно сделать?
На самом деле, скорее всего, я предполагаю,
я сейчас не буду проверять,
я предполагаю, что можно сделать так.
Какая операция у нас самая...
вот та, которая быстрой должна быть?
На invoke.
Самое главное, это чтобы invoke быстро делалось.
Вот если мы invoke запрятали в таблицу виртуальных функций,
то это очень неэффективно.
Это каждый раз, когда мы вызываем функцию,
а вдруг это компаратор,
получается, каждый раз, чтобы мы ее вызвали,
мы два прыжка по указателям делаем.
Очень плохо.
Давайте просто invoke будем хранить как поле.
Прямо здесь непосредственно поинтер на него хранить.
А остальные запрячем в структуру,
которая будет как раз называться статической,
вот эта вот function table для данного t,
шаблонная для данного функтора.
То есть у нас будет храниться просто здесь указатель
на function table для данного функтора.
По сути, мы делаем нечто среднее
между этим решением и предыдущим решением.
То есть часть функции мы прячем в table
и там вызываем через механизм виртуальных функций.
Ну, что значит по сути виртуальных функций?
Мы просто храним здесь pointer
объект той структуры,
а в той структуре уже хранится несколько поинтеров
на нужные нам методы.
Но вот указатель на вызов круглых скобочек
мы храним прямо тут, чтобы до него быстрее идти было,
чтобы мы не прыгали два раза.
Я думаю, что с defunction примерно так как-то и реализовано.
Разумеется, это зависит все от компилятора
и зависит все от версии компилятора.
То есть вы можете самостоятельно проверить,
как у вас реализована function в вашей версии,
либо, конечно же, стандарт не регламентирует ничего подобного,
он не говорит, как надо реализовать function.
Вот.
Но реализована она, вот, скорее всего, я думаю, так.
Правда, был один доклад на CppCon,
на конференции, про то, как можно...
Ну, вот на самом деле то, что я вам рассказываю,
это было рассказано в одной из лекций на конференции по C++
несколько лет назад,
а там чувак рассказывал про то,
какие есть подходы к реализации function,
показывал этот подход, тот подход,
замерял время и выяснялось, что одинаково.
Вот.
Не помню, правда, какие он тесты делал.
То есть как будто бы подход с виртуальными функциями
не дает проигрыша.
Ну, потому что, по сути, мы ровно это и сделали.
Только переложили...
Можно было, короче, virtual оставить,
просто отдельно сохранить метод вызов круглых скобочек
и его не через виртуальную таблицу вызывать,
а напрямую.
Можно было и через виртуальную функцию реализовать.
Ну, в общем, почему именно в STL
решили не использовать virtual?
Я не знаю, почему именно этот подход,
а не тот там выбран.
То есть казалось бы он быстрее.
Возможно, действительно, ну, виртуальные таблицы,
они несут какие-то накладные расходы
известные разработчикам компилятора,
которые нам не очевидны.
И в данном случае нам нужна миниатюрная версия
виртуальной таблицы, чтобы всю виртуальную таблицу
не создавать, с этим TypeID и прочим.
Они написали мини свою версию конкретно для данного,
чтобы там не было всяких дополнительных еще штуковин,
которые, возможно, могут что-то замедлить
в каких-то сценариях.
Вот. Ну, короче, то, что мы обсудили, это, так сказать,
TypeRager без виртуальных таблиц.
Вот. По сути, сделали свою виртуальную таблицу
своими руками.
Вот.
Вопросы?
Вот. Есть еще одна проблема.
Вот какая.
Я вернусь вот к этой реализации,
потому что она более полной получилась.
Значит, вот мы здесь реализовали
класс Function в каком-то виде.
И у этого Function
ну, да, не очень хорошо я реализовал,
а тут нет конструктора копирования.
Ну, понятно, что Function должна обладать
всеми стандартными методами,
которыми обладают всякие там интервью.
То есть у Function есть конструктор копирования.
Да, ну, давайте я его напишу, значит, Function.
Я не буду прям реализовывать, я просто объявлю.
Значит, есть конструктор копирования Function.
Есть конструктор перемещения Function.
Есть оператор присваивания Function
от lvalue.
Видимо, даже два.
В смысле два?
Ну, есть могущий оператор присваивания?
Ну, да, да, да.
Естественно.
Вот. Понятно, что все эти штуки есть.
И есть деструктор, само собой.
Ну, правила пяти никто не отменял.
Идеальный все, значит, все четыре эти штуковины надо сделать.
Вот.
Ну, и C++11.
Собственно, вот тип Function так и выглядел.
Значит, понятно, что здесь...
Ну, короче, вам должно быть идейно понятно,
как они реализованы.
Я не буду их реализовывать.
Это можно как упражнение сделать.
Идейно понятно, что здесь происходит.
Здесь мы просто создаем
такую же штуку, как там хранится,
со всей виртуальной таблицы копируем.
Здесь мы, значит, move'ем, там
оставляем на lptr, себе все забираем.
Здесь то же самое, только первоначально
мы уничтожаем то, что у нас лежит.
Вот может быть кто-нибудь из вас...
Значит, давайте сделаем тест.
Диспозиция такая.
Исходные данные такие.
Вот у нас с C++11 мы реализовали
вот так класс Function.
То есть понятно, что здесь написано.
Понятно, какие операции там делаются.
Неважно у нас, через таблицу
виртуальных функций мы реализовали
или сами написали аналог таблиц виртуальных функций.
Это как раз сейчас неважно.
Мы реализовали вот такой класс
с такими методами.
Вот попробуйте быть умнее комитета по стандартизации.
Что здесь...
Я не ожидаюсь, что кто-нибудь догадается до ответа.
Может кто-нибудь знает ответ.
Но если кто-нибудь догадается до ответа,
то круто, хотя вряд ли.
Это трудно предвидеть такое.
В общем, тут есть одна проблема,
из-за которой этот класс Function
оказался в некоторых сценариях очень
ну скажем так, непригодным.
Не для всех Functions,
не для всех Callable объектов
он годится.
Просто для некоторых
получается CE
и ничего с этим сделать нельзя.
И просто SD Function
не подходит для них,
если ее так реализовать.
До этого вроде было много проблем
с указателями на члены всякие.
Не-не, это не связано с указателями на члены.
Это не связано с указателями на члены.
Не-не, это не связано с указателями на члены.
С указателями на члены мы как раз решили проблему,
мы написали специальный CD Invoke
и все нормально.
Нет, для самых нормальных, для вот обычных
полноценных объектов.
Статический метод у класса?
Статический метод у класса?
А что, в чем проблема с ним?
Не понимаю.
А что с исключением будет?
Все нормально?
Сейчас, что у нас с исключением будет?
Все нормально?
Хороший вопрос.
И у нас понятно,
что с ExceptionSafety умирает,
но вот как бы, если...
У нас нет ExceptionSafety, да,
А что у нас может быть не так
с ExceptionSafety?
Когда мы копируем...
Ну, это сейчас был разговор
Это сейчас был разговор не про ExceptionSafety.
Наверное, здесь надо добавить try-catch в каких-то местах, чтобы была ExceptionSafety.
То есть, если у нас Exception происходит во время колла, во время вызова,
то все нормально, оно просто так и летит наверх.
При уничтожении, в смысле, при момент, когда мы делаем дестрой.
Вот. Если у нас произошло Exception во время создания,
во время того, как мы делаем присваивание,
то...
Тут как-то это тривиально поддерживается все.
Ну да, кажется, что это несложно.
То есть, типа, ну...
Кстати, хороший вопрос про исключение во время присваивания function.
Я, если честно, даже не помню, как там, что там написано в стандарте.
Давайте почитаем.
Std function.
Оператор присваивания, допустим.
На себе периференс даже не написано.
ExceptionSafety.
Ну, то есть, вопрос в том, что будет, если мы уже уничтожили старый объект
и положили новый.
М-м-м...
Слушайте, не знаю.
Ну, короче, вопрос хороший, но не хочу сейчас на него тратить время.
В общем, я не знаю.
В общем, я не знаю.
В общем, я не знаю.
В общем, я не знаю.
Не хочу сейчас на него тратить время.
В общем, понятно, что это можно поддержать.
Поддерживать ли это function, я не знаю, если честно.
Я не вижу на, типа, периференс слов, что оно exceptionSafe.
Возможно, они забили на поддержку exceptionSafety
в присваивании function одного другому.
Типа...
Кстати, не очень понятно, как это поддержать, на самом-то деле.
Потому что буфер-то один.
Если мы положили на этот же буфер...
Ну, у нас же исключения во время копирования происходят.
Может произойти, да.
Если мы используем один и тот же буфер,
то кажется, что мы не можем...
Ну, если мы уничтожили старую функцию
и начали класть новую, и произошел exception,
то, кажется, мы никак уже старую не вернем.
Потому что нам нужно на тот же буфер положить новую.
И что мы тогда будем делать?
Мы же не можем старую заново создать.
И мы не можем создать второй буфер, в который положить новую,
потому что потом все равно копировать в другой буфер ее придется.
То есть, как минимум, кажется, строгую гарантию исключения
мы не можем поддержать.
Наверное, можно поддержать базовую.
То есть, мы уничтожили старую штуку,
попробовали создать новую.
Если не вышло, то мы просто делаем...
Считаем, что у нас nullPTR,
и как бы, ну, остаемся в корректном состоянии,
что в нас ничего не лежит.
Мы не смогли создать функцию по...
Из истой и, значит, просто null...
Ну, остаемся в пустом состоянии.
И протидываем exception дальше.
Кажется, что так оно и должно работать,
потому что, ну, по крайней мере,
в SD-варианте так, кстати, работает.
То есть, там базовая гарантия безопасности исключения,
а не строгая.
Потому что строгую вообще непонятно так соблюсти.
Вот базовую можно.
И, наверное, базовая так и есть.
Правда, тут не написано почему-то.
Но, окей, это...
Это еще один интересный вопрос,
но все-таки я...
Есть еще одна...
Еще проблема, даже, возможно, более серьезная.
Для некоторых...
Для некоторых объектов callable
этот класс просто не применим вообще.
Не то что там иногда,
а просто не скомпилируется.
А лямбда функция?
Да нет, для лямбда функции тоже применим,
но не для всех.
Для некоторого подмножества лямбда функции
он не применим.
И для некоторого подмножества других объектов.
Это не связано с тем,
лямбда это функция или не лямбда функция.
Короче...
А если мы...
А если мы хотим, чтобы объект
можно было вызывать только на определенное количество раз?
В смысле, в нем какой-нибудь счетчик,
но там придется мутить с mutable,
чтобы это адекватно работало?
Вроде бы.
Ну, кажется, что...
Кажется, что это, опять же,
не проблема, потому что...
Может быть, качинивать...
Конструктор считается функцией?
Конструктор...
функции... чего?
Конструктора класса, не знаю...
Нет, у тебя должен быть тип
какой-то, callable.
Что такое callable? Я не понимаю.
Callable либо указатель на функцию,
либо...
С указателями на функцию нет никаких проблем.
Если ты хочешь конструктора класса
интерпретировать как callable объект,
кажется, ты можешь указатель
на конструктор. Можешь ли ты
сделать?
Я даже не знаю, что мне кажется...
Нет.
А может, ты можешь?
Блин, это хороший вопрос. Можно ли взять указатель
на конструктор как на функцию?
Но в любом случае, это будет указатель на функцию, обычно сишный,
и это не проблема. Ладно, в общем...
Ну, никто не догадался, в общем, до этого трудно догадаться.
Ну, да.
Если у нас
шаблонная функция
от пакета,
то она же будет
в итоге компилятором
как несколько функций просто рассматривать, да?
Почему? Нет?
Шаблонная функция от пакета?
Ну, вот...
Ну, если ты ее вызываешь, подожди,
если ты ее вызываешь с разными типами аргументов,
то да,
она рассматривается, ну, под каждый
вызов генерируется своя версия
шаблона. Ну, да.
Ну, и по итогу, ну, собственно,
то есть никакой проблемы с такими функциями
тоже не будет, да?
Ну, ты, чтобы взять указатель на нее,
ты должен конкретизировать типы.
Ты же не можешь взять указатель на...
Ну, да. Ну, поэтому ты просто берешь указатель на функцию,
уже конкретизируя типы,
и поэтому просто хранишь ее как панцирный планет.
Короче, ответ вот какой.
Это не будет компилироваться для объектов,
которые только movable.
В частности, например,
если у нас в функцию захвачен какой-нибудь унит по tr,
то std function в такую
лямду
в std function вы уже не положите.
Давайте я...
Примонстрирую. Ну, смотрите сейчас.
Значит, я это закомментирую.
Вот, смотрите, давайте у меня будет какая-нибудь лямба.
Ну, значит, да.
Значит,
f равно
after move only
равно...
Ну, вот у меня будет std unique ptr,
точнее, after
ptr равно
std make
unique
от int
от
pt.
И я скажу, значит,
ptr равно std move
от ptr.
А что она
будет принимать? Ну, не знаю.
Ничего.
Возвращать int и, значит,
return звездочка
ptr. Ну, какая-то дурацкая функция,
просто которая заменовывает
pointer. Теперь я хочу сказать
std function
от decal type
от...
Нет, std function
с параметрами, значит,
int круглые скобочки.
Функция, которая принимает...
Ничего не принимает, возвращает int.
f2 равно
std move
от move only.
Почему std move? Потому что копированием
я, конечно же, не могу сделать.
Ну, вот давайте попробуем так сделать.
Я не заincluded memory, кажется.
Так, попробуем.
Что ж такое? Что на этот раз?
А, потому что здесь я не поставил
точку запятой.
Вот.
Вот случилось то, что я
и говорил.
Я попробовал в std function положить
move'ом положить.
Это ведь я все правильно сделал.
Если бы я копированием клал, я бы вообще...
Но я move'ом положил в...
Хотел положить в f2
сохранить вот этот объект.
И не смог. Почему?
А потому что
класс инстанцируется
с шаблонным параметром,
как у меня, а в нем есть конструктор копирования.
В конструкторе копирования
function
у меня инстанцируется function
с нужными шаблонными параметрами.
И в частности, там есть конструктор
копирования.
Конструктор копирования, он уже не шаблонный.
У него уже подставлены шаблонные параметры,
как у меня, как у класса function.
И, значит, инстанцируется
тело сразу, потому что там
еще пока нету переменных шаблонных параметров.
И в этом конструкторе копирования
есть вот такая строчка.
Потому что
конструктор копирования, когда компилируется,
он должен уметь пытаться создавать
из
объекта функтора другой объект функтора.
Я не пытаюсь вызывать
конструктор копирования.
Но он таки инстанцируется,
а значит, он пытается
компилироваться.
И это не работает.
Сейчас у нас лямбда
move only,
потому что у нее есть глобальная
захваченная переменная
move only.
У нее есть поле,
которое не обладает
конструктором копирования.
Значит, и вся лямбда,
только мобильная,
некопируемая.
Если мы пытаемся ее положить в...
Я могу и функциональный класс свой создать
без лямбды такой.
Но если положить ее в std function,
у меня ничего не получается.
Даже move я ее пытаюсь положить.
Потому что функцион с такими параметрами
старается инстанцировать, пытается создать
конструктор копирования себе,
а его не может создать.
Поэтому вся функцион отваливается.
Это недостаток класса function.
И как его исправить,
не очень понятно.
Да.
Где он конкретно пытается создать
конструктор копирования?
Он пытается создать конструктор копирования
от соответствующих перемен.
Он пытается компилировать код класса function
с подставленными типами int
круглой скобочки.
В этом классе function
есть вот такой вот function
от const function персан,
в котором написано
скомпируй функцию.
Там есть конструктор копирования.
Он не копирует переменные,
а функция сама становится понятна.
Конечно, он создает новый объект function
а для этого он копирует объект
функтора.
А нельзя просто
как-нибудь сказать, что это
лямбда будет просто сказать,
что все функции такого вида просто теперь не могут
а еще и копируются.
Говорить, что если вы делаете что-то не так,
будет не так.
Чего сказать надо?
Заглушку поставить.
Да, заглушку. Именно конкретно такой случай,
что значит заглушку?
Что написать надо и где?
Ну как с привылзами виртуальных функций,
чисто абстрактных pure virtual,
там их можем вырывать, но потом заглушка.
А или сейчас?
Не можем, да.
Не понимаю.
Можем ли мы каким-то образом
изменить категорию функции
как не only move?
Безыри интерплеть кастик,
к чему-то там вообще волшебно, хоть и к самой себе.
Я все еще не понимаю,
где именно и что вы предлагаете написать.
Что должно быть написано в конструкторе
копирования вот этой вот function?
Он же должен быть.
Что в нем должно быть написано?
Если его не будет вообще,
то это значит, что любой объект
function будет некопируемым.
Не очень понятно, что у функции
конкретно копируются
и почему нельзя.
У нас функция просто в какой-то момент
из-за того, что мы...
Ну, например, если лямбами что-то захватили,
а становится внезапно
некопирующейся просто
из-за того, что мы захватили что-то плохое.
Вы про лямбду забудьте. У нас объект
функтора есть. Он может быть чем угодно,
не обязательно лямбой. Это может быть bind expression
или это может быть просто обычный класс.
У нас объект функтора.
И он некопируемый.
Function — это класс, который хранит в себе объект функтора
и динамически умеет
подменять его на объект другого
типа с сохранением сигнатуры
оператора вызова.
Вот мы решили положить в Function объект функтора,
который некопируемым оказался.
Тогда у нас некопилируется конструктор копирования Function.
Что делать?
Можно вопрос?
Вот мы когда-то обсуждали, но не очень подробно,
что шаблон может не полностью
создаваться.
И почему
это здесь не происходит?
То есть мы же не воспользовались нигде
копированием Function.
А если мы пользовались до того,
как мы его присвоили?
У нас, видимо, не шаблон.
У нас подставился шаблон.
Вот этот метод не шаблонный.
У нас класс шаблонный.
Если у меня есть вот такой метод,
он шаблонный сам по себе.
И вот этот код
он не будет...
Тут и в constexpr
это скорее всего все равно будет.
Когда я инстанцировал Function
с каким-то шаблонным параметром,
вот тело этого метода еще не инстанцировалось.
Потому что шаблонный параметр класса я зафиксировал,
а шаблонный параметр этого я не зафиксировал.
И он пока не подставляет
сюда никакой фактор.
Когда я начну Function
от данного шаблонного фактора инстанцировать,
он уже сюда подставит фактор
и будет говорить, что можно или нельзя.
Но здесь шаблонные параметры
этой штуки они такие же,
как шаблонные параметры самого класса Function.
Когда я инстанцировал Function
с какими-то типами,
компилятор уже подставил эти типы
в том числе в тело вот этого конструктора.
Сейчас, тело он не генерируется.
Он генерируется как бы объявления, да?
Но само тело не генерируется.
Генерирует уже,
потому что я подставил...
Темплейтный же параметр.
Это параметр класса,
а не метода.
Если я подставил
шаблонные параметры в класс,
то весь код,
где написаны эти шаблонные параметры,
он их уже зафиксировал.
Конструктор не шаблонный сам по себе.
У меня не генерировались
некоторые методы, которые я не вызывал
в шаблонном классе,
но сами они шаблонные.
Хотя в них было SE, но ничего страшного.
Чего еще раз?
Какие методы?
Почему ты говоришь SE все еще?
Говори, пожалуйста, CE, я не могу это слышать.
Но это не буква C,
а не S.
Я описал шаблонный класс.
Внутри у меня был метод,
у которого в теле было CE.
Но при этом я его не вызывал,
поэтому CE не происходило
и все работало.
А метод был шаблонный или нет?
Сам метод не шаблонный,
класс шаблонный.
Вот это странно,
потому что кажется, что должно все равно.
Не знаю.
Если у тебя есть пример такого кода,
то пришли его, пожалуйста.
Так или иначе,
по какой-то причине компилятор...
В случае с конструктором копирования
вот это так работает.
Может быть, компилятор умеет иногда
избегать такой подстановки,
а он ее не умеет избегать.
Короче, если метод не шаблонный,
когда вы подставите в нее
в класс шаблонные типы,
вы, вообще говоря, нарветесь на CE
во всех местах, где вы пытаетесь
от этих типов уже вызывать методы.
А мы можем сделать конструктор
копирования шаблонным,
чтобы его просто закостряли?
Нет, если сделаешь что-то шаблонным,
в случае с конструктором копирования по определению.
Мы не могли теоретически сделать
какую-нибудь специализацию
function в плане
дополнительных темплетных параметров
туда прикрутить,
и сделать там такое же взаимоотношение,
как мы с стераторами делали
для константного и неконстантного.
То есть сделать специализацию
для...
сделать какой-нибудь
inner function?
Я вам просто скажу,
что сделано в стандартной библиотеке для этого.
Проблему осознали
не сразу.
Все преступники 11 написали вот так
и не сразу осознали проблему.
Потом ее осознали, но было уже поздно.
Короче,
есть вот такой замечательный класс.
Правда, он
C++23 только будет
добавлен, потому что
до сих пор еще не успели.
Типа function without copy?
Значит, move only function
это все как function,
только без конструктора копирования.
Если вы хотите
в function класть
объекты, которые не копируются,
то используйте move only function.
На самом деле
это очень редкий случай,
когда вам нужно копировать function.
Если вдуматься,
то становится понятно, что это очень редкая операция.
Зачем вам копировать функциональный объект?
Наиболее часто вам нужно move
функциональный объект.
Если у вас есть функциональный объект
реально, не тривиальный, с какими-то данными,
то, как правило, вам эти данные нужны
для вызова функции.
Один раз вам не нужно
создавать много копий этих данных,
чтобы вызывать функцию.
Где вы вызываете, там вам эти данные нужны.
Вам вряд ли понадобится
дублировать данные для вызова функции.
Может быть и понадобится, но редко.
Короче,
на самом деле
наиболее часто
функциональные объекты именно move
туда, где они нужны, вместе с данными.
Например, есть стандартный пример,
когда у вас будет многопоточка,
вам, может быть, нужно взять
функциональный объект и положить его в какой-нибудь
thread pool на выполнение,
чтобы он в какой-нибудь очереди
пока его выполнен.
Вы вряд ли будете его копировать туда.
Вы его туда move'ните.
И если у вас объект такой,
что его копировать нельзя,
с the function вам не поможет.
Но вот есть на такой случай
типа move only function.
Все то же самое, только он
умеет лишь
move'аться.
Копирующий конструктор удален.
Только пока нет.
Ну, пока нет.
23-й год, поэтому, как бы, формально есть.
Правда, компиляторы еще не поддержат, скорее всего.
Но надо посмотреть, какие поддерживают.
Было бы еще забавно, если бы
можно было function в него
конвертировать.
Ну, вряд ли.
А это разве не просто
удалить два конструктора и
вставить, копипаснуть в свой код
function'а? По сути, да.
То же самое все. То есть, по идее, поддержать
не сложно. Да.
Не, но если ты скопипасишь код
остального function, я боюсь, что
там простым удалением чего-либо
ты не обойдешь. У тебя все сломается
и будешь долго разбираться.
Но я уверен, что в интернете
много аналогов уже реализовано
за вас. Вот, короче.
Что еще надо сказать по поводу
этого дела?
Move only function.
Ладно, вроде
я забыл, что я хотел сказать
про move only function. Будем считать, что я все
сказал.
Так.
Хорошо.
Дальше.
Есть, на самом деле, еще одна проблема.
Наша реализация function сейчас
все еще не до конца корректная.
Вот, в том виде, в котором
это написано здесь.
Но
пока что
мы эту проблему отложим,
потому что она очень
трудная для понимания.
И я
про нее проявляю.
Ну, и
я про нее
расскажу, вероятно, в конце
второй из сегодняшних
двух пар.
Потому что ровно такая же проблема будет
и в реализации с the variant.
Но поймем
мы ее позже.
А пока что
давайте закончим.
У нас сейчас параграф
нет.
Function implementation
это 14.4.
Федя вам рассказал
14.5 и 14.6.
14.5 это полиморфик-аллокатор,
а 14.6 это варианты визитных использований.
Нам сейчас предстоит как раз
параграф 14.7,
где мы будем реализовывать variant.
Но прежде чем
мы начнем реализовывать variant,
ну, точнее, я не буду реализовывать
его прям полностью, я объясню
несколько идей, которые нужны для того,
чтобы реализовать.
А реализовывать вы его сами будете,
там еще много приколов предстоит
увидеть по ходу его реализации.
Но
прежде чем его реализовать,
давайте я еще раз
покажу то, что показывал
Федя в конце последней пары,
потому что это важно, и мне кажется
тогда не очень все успели
понять, что происходило,
а это очень важно, потому что оно нам
прямо сейчас потребуется для
так, вот это я уже лишнего написал,
вот я пока удалю, оно нам потребуется
для того, чтобы
ну, короче, в варианте нам
пригодится эта идея.
Смотрите,
этот код демонстрирует
использование варианта и визит.
Напоминаю,
что такое variant?
Variant это штука, которая умеет
хранить в себе один из
облюстителей порядка,
это параграф 14.6, в котором
был разговор про
вариант и визит,
пока без реализации. Так вот, вариант умеет
хранить один из перечисленных типов
и динамически подменять один на другой,
то есть это такой type-safe-union.
Напоминаю, в union
когда мы, если мы
хранили что-то, например int, и решили туда
положить string, присваиванием,
то у нас будет seg-fold,
потому что мы
вызовем деструктор, ну там
delete квадратной скобочки на памяти,
которая не являлась string, в общем, всё плохо.
Помните, я надеюсь, это пример,
мы его разбирали в прошлый раз.
Variant такой проблемой
не страдает, вариант позволяет динамически
подменять то, что в нём лежит, просто присваиванием.
При этом,
вариант,
я напомню, это тоже очень
важно, значит, у нас
вариант умеет
выбирать
наиболее подходящий тип
из тех, которые мы дали,
то есть вот если у меня есть вариант int double
и я его
проинциализирую флуатом,
то
активируется тип double.
Помните этот пример?
Значит,
вариант умеет
выбирать наиболее подходящий тип
из тех, что в нём есть, для того, чтобы
ну, когда мы его инициализируем
каким-то значением.
По какому принципу, по какому правилу он понимает
какой тип наиболее подходящий, по какому правилу он
понимает, если в варианте нет
Ну, как перегрузка функций.
Да, причём в точности так же,
то есть никаких новых правил
нет, эти правила абсолютно аналогичны.
Вариант выбирает подходящий
тип в точности по правилам
перегрузки функций.
Это удивительно вообще, это
совершенно не тривиально, это очень
это
вообще не очевидно, как это написать.
Тем не менее, мы сегодня как раз это
напишем, то есть мы
именно напишем,
как нужно реализовать, что нужно
написать в классе вариант, чтобы
именно так это работало.
Это совсем
не очевидная идея, вот догадаться
самостоятельно до неё, я не знаю, очень
трудно.
Так вот,
почему здесь
double активируется? Потому что привести
float к double это, я напоминаю,
promotion. Это самый лёгкий вид
приведения типов. Привести float к int
это conversion,
которая менее предпочтительна, чем promotion,
поэтому будет выбран double.
Если вы пытаетесь
инициализировать вариант
чем-то, что
не
конвертируется,
ну, конверсия, где неоднозначно
или вообще
ни один тип не конвертируется,
то вы получите CE,
на этапе компиляции проверяем,
а вы пытаетесь варианту
с таким набором типов присвоить
объект какого-то типа, у которого
неоднозначна конверсия
во что
предпочтительно непонятно,
вы получите CE, как и при перегрузке функций,
ambiguous. То же самое вы получите,
и ни один из типов вообще не конвертируется
в ваш, наоборот.
Вот, теперь
что такое visit я напоминаю. Вот у меня есть
вариант,
точнее у меня есть вектор вариантов.
Вариант
из вот таких вещей,
char long long and double long long.
Код взят из интернета,
я вам пришлю ссылку на страничку,
откуда я взял этот код потом.
Значит,
вектор хранит в себе
вот такие варианты,
и в этих вариантах в первом из них лежит
char, во втором в первом из них
лежит int, потом char,
потом double, потом long long,
потом long,
потом float и потом int
опять.
То есть,
каждый объект
варианта инициализировался соответствующим
типом, и я вектор из
них сделал.
Вектор в каждом вариант и
каждый вариант догадался, какой тип
в нем лежит. А теперь я
делаю вот
такую штуку, и вот я напомню, значит,
это вам показывал Федя
в прошлый раз, но, возможно,
вы, значит, не...
тогда еще не поняли, но давайте
наверное вот как сделаю, наверное
вот это пока закомментирую,
а здесь просто...
Нет, даже не так я сделаю,
я не буду это комментировать, я просто return,
сделаю раньше времени. Сначала простой
пример, более простой пример.
У меня есть, значит,
автовизитор
равно
лямбда функция, которая принимает
авто
и возвращает
что?
Не возвращает, а выводит
typeId от
x.name
Вот.
Тут я сделаю return 0,
и теперь я сделаю
for const
auto percent
where
var
veqVariant
visit
stdVisit
Первым параметром я передаю
Visitor,
а вторым параметром я передаю
V
Что сейчас произойдет?
Сейчас выведутся названия
типов по очереди, которые в нем лежат.
Overload,
видит.
Действительно вывелись.
Char double
x это, я не знаю, что такое,
long,
float,
наверное это long-long так обозначается.
Ну я напоминаю, что typeId он
не настоящее название, типа
name хранит, а
для примитивных типов там однобуквенные
каторы лежат.
Понятно ли, как это работает на данный момент?
Вот это должно быть понятно.
Это обсуждали в прошлый раз.
Значит, что
произошло? Сгенерировался
шаблонный класс,
точнее нет, сгенерировался
обычный класс, не шаблонный,
в котором шаблонный оператор куглы скобочки,
ведь Visitor это что такое? Это функциональный
объект, а в нем есть template
оператор куглы скобочки от t,
и вот это auto оно как раз
соответствует тому t, который в операторе
куглы скобочки.
И просто для каждого типа t сгенерировалась
своя версия оператора куглы скобочки,
когда мы вызвались, выбралась нужная
просто для каждого t
соответствующая версия оператора куглы скобочки
сгенерировалась.
То есть на самом деле сгенерировалась по факту
сколько надо разных методов,
не шаблонных уже.
Хорошо.
Вот теперь прикол
с warlord, что здесь написано?
Тут написано следующее.
У меня есть тип
overload, который является
шаблонным, причем он
у нас пока стояло многоточие,
вот так ставится без пробела.
У нас он
шаблонный от перемен
количества аргументов, и он
вот это вот самое внезапное,
вот это вот новое
для вас, такого у нас
раньше не было. Ну, Федя вам в прошлый раз
показывал, но до этого у нас такого не было.
И это нам сегодня еще пригодится.
У нас наследование от переменного количества
шаблонных аргументов.
То есть я распаковал пакет
типов вот прям здесь.
Я сделал структуру
наследницей всех шаблонных параметров,
от которых она,
которые у нее есть.
А дальше я
сделал следующее.
А я написал
using
это еще один новый синтакс, из которого
тоже у нас раньше не было.
Вот этот синтакс
разрешен только начиная с C++17.
До этого
это вообще нельзя было писать.
До этого можно было
написать. Вот
using с многоточием
стал разрешен начиная с C++17.
На самом деле
это можно было сымитировать
средствами
C++11.
Но я забыл как.
Надо вспомнить, надо подумать.
Ну
например
можно было
написать так.
Ну чисто вот что
можно было бы сказать.
Можно было бы сказать, что
у меня есть
шаблонный метод
в котором
у меня есть шаблонные
параметры.
То есть у меня есть шаблонные
параметры.
Шаблонный метод
оператор круглые скобочки
void.
Ну правда вот здесь
типом будет
некоторая проблема.
Типы получаются у меня должны быть
разными. Но с другой стороны
перегрузки типы должны быть одинаковыми.
Вот на самом деле тип здесь у меня
должен быть какой-то один.
Визи тоже должен быть одинаковый тип
возвращаемый.
Тип нужно явно указать, либо
он должен выводиться какой-то одинаковый.
Я здесь что напишу?
void.оператор круглые скобочки
от
какого-то параметра.
Ну скажем от
чего?
Сейчас.
Принимаемый тип у меня
здесь тоже является проблемой.
А ну вариант
видимо мне нужно принять.
const
вариант
персант.
Короче я что хочу сделать?
Я могу сказать, что статик каст
токсик
токсик
токсик
токсик
Я могу сказать, что статик каст
т звездочки себя
и вызвать у него круглые скобочки от этой штуки.
Я кстати не уверен, что это
прям
что нет лучшего способа.
То есть здесь надо написать статик ассерт
что я вызываю этот
оператор
вариант
стд вариант
Ну да.
Визит вызывается от варианта, потому что
сейчас нет
я что-то затупился
я начал какую-то фигню писать
по-моему.
Слушайте
нет, давайте я лучше не буду этим заниматься.
Я не помню как это санитировать
через средство C++11.
Это можно, но
видимо я не могу это сделать в ходу, поэтому я сейчас
лучше не буду в этом делать.
Следующую строчку объясните, пожалуйста.
Вот
короче, вот такой синтакс из работы
начинается C++17. Может быть сейчас мы
сделаем перерыв, когда у нас
через полчаса
и в перерыве я быстренько найду
и покажу как это имитировалось раньше.
Тем не менее, что вот это значит?
Это значит, что я
из всех наследников
вношу в эту область видимости оператор
круглые скобочки. Таким образом у меня
получается много операторов
круглые скобочки
от
нужных типов.
Один
оператор круглые скобочки от
Char, другой от int,
третий от unsigned int,
потому что у всех моих наследников
у каждого был по одному оператор круглые скобочки.
И я
тем самым их
все унаследовал.
Что вот это такое?
А это, господа, type
deduction guide, который у вас
был в пункте
дай бог памяти 11.3,
когда вы говорили про
сети ID, class template,
аргумент deduction. Если я
создаю
оверлот от каких-то
шаблонных параметров,
то шаблонные параметры должны вывестись
вот так.
Это user defined deduction guide.
Вот.
И что здесь написано?
Здесь написано, что если я в конструктор
overload передаю какой-то набор
типов, то считай, что
твои шаблонные параметры это и есть
эти типы. Вообще говоря,
если бы я этого не написал, компилятору
было бы совершенно непонятно,
от каких шаблонных
параметров я имею в виду overload,
если я вызвал конструктор overload
от таких типов.
Но я написал deduction guide, что
от этих типов тебя конструктор не вызывали,
считай, что твои
шаблонные параметры это и есть эти типы.
Таким образом, если я вызываю
конструктор от вот
такого набора шаблонных параметров,
то компилятор понимает, что именно эти
типы и будут моими шаблонными параметрами,
а значит,
от них от всех мне надо унаследоваться.
А значит,
от каждого из них мне нужно внести
вот этот вот using,
из каждого из них в область видимости свою
внесется оператор куглы-скобочки.
Каким образом у меня в классе overload,
в объекте вот этот вот,
будет вот 6 разных операторов куглы-скобочки,
которые для каждого типа
делают то, что нужно.
И теперь, если я так сделаю,
то у меня просто выведутся
названия этих типов по правилам перегрузки.
Потому что у меня
будет ровно столько операторов куглы-скобочки
по одному на каждый тип.
И для каждого из них выведется название.
Понятно, что произошло вот здесь,
вот в этом коде?
Ну, самое сложное здесь, кажется,
для понимания вот эта строчка.
Но это просто надо принять,
потому что это такой синтаксис специальный.
То есть, начиная с 17,
можно делать вот так.
Можно делать using с многоточиями.
Это значит, я у всех наследников
унаследовал оператор куглы-скобочки.
Вот.
Ну а теперь, значит,
самое интересное,
когда у меня есть...
Ой, что я сделал?
Это мне не надо было удалять.
Вот эту удаляю.
Теперь у меня есть другой вектор вариантов.
Смотрите, у меня вариант из вектора,
дабла и стринг.
И смотрите, что написано.
Первый вариант я инициализирую даблом,
второй вариант я инициализирую вектором,
третий вариант я инициализирую стрингом.
То есть у меня такой вектор,
в котором первый элемент хранит дабл,
второй элемент хранит вектор,
третий элемент хранит стринг.
И теперь я делаю вот такую вещь.
У меня есть оверлот от двух лямб.
Первая лямбда принимает вектор,
а вторая лямбда принимает авто.
К чему это приводит?
А это приводит к тому,
что в моем оверлот
получается два оператора куглы-скобочки.
Один оператор куглы-скобочки
от конкретного типа вектор,
а другой оператор куглы-скобочки
шаблонный.
Вот эта чудо-конструкция
унаследовала мне от всех
наследников оператор куглы-скобочки,
один из которых конкретный
от вектора, а второй из которых
шаблонный от t.
Таким образом у меня в этом классе
оверлот есть два оператора куглы-скобочки,
один конкретный от вектора,
другой шаблонный от t.
И дальше выбирается перегрузка,
как происходит перегрузка между ними.
Если я вызываюсь от вектора,
ну вот здесь я делаю visit,
вот этот вот функтор
от вот этого варианта.
И этот visit
понимает, что раз в варианте
лежит вектор,
то ему надо вызвать
версию от вектора.
И он вызывает
от него.
Почему от него?
Потому что у меня, частно-предпочтительно
общего, у меня есть конкретная версия
от вектора и шаблонная версия еще
от нее.
Но если у меня вектор,
то предпочтительно, конечно, версия конкретная
от вектора.
А что дальше происходит?
Дальше, когда у меня лежит double,
версии от double нет,
поэтому мы инстанцируем шаблонную версию.
И попадаем вот в этот код.
Вот этот шаблонный код, который здесь еще
проверяет, правда ли тип...
Ну, здесь я уже написал
и в constexpr чисто, чтобы еще
добавить веселухи.
Здесь я проверяю, правда ли тип string,
и тогда пишу string. А если тип int,
то пишу int. Часто, правда, кстати,
не сработает. Помните ли вы почему?
Потому что у меня тип arg. На самом деле ссылка.
Мне нужно std decay
добавить.
Ой, std decay перед декл-тайпом надо добавить.
std decay t
от декл-тайпа arg и
std string. И здесь тоже std decay t.
decay – это штука,
которая снимает все...
снимает звездочки, амперсанды,
в общем, оставляет
чистый тип, как он
есть. Там без амперсандов,
в частности. Массив разрушает
допойнтера.
В общем, снимает украшения с типа, можно так
сказать, по-простому говоря.
Вот. И сейчас
у меня
ничего не вывел. Раскулачивает.
Потому что я написал...
Почему?
Сейчас что произошло? Я не понимаю.
Сейчас можно мне вопрос задать?
Да-да, сейчас. Вот. Все правильно.
У меня случилось
1.3.4.5, потом string hello.
А, потому что там был не int.
Здесь мне надо написать double.
И тогда, кажется,
все будет правильно. То есть он сначала выведет
int.1.5.
Ну, double написать было.
Потом
vector вывел, попав вот в эту версию.
А потом вывел string,
попав вот сюда.
Да. Вопрос?
Да, вопрос.
У нас почему, когда мы конструируем
оверлот от лямда...
У нас же лямда авто — это тип
без шаблона. То есть это как бы шаблон, но он такой
необычный шаблон.
Он не считается обычным.
Почему мы конструируем класс от оверлот
от лямда с этим авто?
Тип этой лямды сам по себе тип
не шаблонный.
В нем оператор круглые скобочки шаблонный.
О, ок.
Вот.
И мы его внесли в эту область видимости.
И теперь в этой области видимости у нас есть один оператор
круглые скобочки обычный от вектора.
А другой оператор круглые скобочки шаблонный
от tempersanda. Соответственно, когда мы вызываемся от
вектора, мы попадаем в частную версию, потому что есть
версия конкретно для такого типа. А если мы вызываемся
от чего угодно другого, не от вектора, мы попадаем
в эту версию, потому что предпочтительнее сделать
подстановку t, чем конверсию типа. И дальше мы попадаем
вот в этот код, где уже в зависимости от того, чему
равно t, делаем либо одно, либо другое.
А можете еще раз наверх промотать?
Пожалуйста.
Так, спасибо.
Начиная с C++20, вот это можно не писать. Это вам тоже
Федер говорил в прошлый раз. Надеюсь, мне нужно
писать –std равно C++20. И это работает без кастомного
вывода типов. Почему это работает без кастомного
вывода типов? Потому что помните, мы с вами когда
обсуждали classTemplate.argument.deduction, там был разговор о том, что
начиная с C++20, добавили argument.deduction, в том числе
для вот такого инициализации, когда вы инициализируете
через когрегатную инициализацию.
Здесь, правда, какой-то совсем интересный пример,
потому что здесь конструктор как бы от всех наследников.
Но меня не дает вывести на самом деле, то есть у
меня ЦСЕ, если не прописать явно.
А у тебя какой компилятор?
Ну, C++20. Компилятор.
Компилятор какой? Они могут не целиком поддерживать.
Ну, в общем, не знаю, по идее должно работать.
Что, в крайнем случае, если не работает, можно так
писать. А так работает?
По сути, наверное, все на этом. Ну, это была подводочка
к тому, что мы сейчас начнем реализовывать, собственно,
то есть наша задача сейчас будет состоять в том, чтобы
понять, как это все работает внутри.
Во-первых, как работает вариант, во-вторых, как работает
визит, потому что это пока осталось загадкой.
Ну, а у вас это будет, соответственно, предпоследней задачей в
этом семестре написать это все как следует.
И мы сейчас переходим к обсуждению того, как реализован
вариант. Ну, начнем понятно как.
У меня есть typeName многоточие types, а класс вариант.
Давайте вместе думать. Ну, мы начнем с самого простого.
Что нам надо очевидно хранить?
Для начала обсудим поля. Вот, что надо должно храниться?
Конечно, мы все потом переделаем. Сейчас мы будем итеративно,
то есть мы будем делать какую-то банальную, реализовывать
банальную идею, потом находить проблемы и преобразовывать
более сложную идею. Ну, на первоначальном этапе, как
кажется, что должно храниться у нас?
Что, никто не может ничего сказать? Или еще не пришли
с перерыва все? Так, сейчас.
Должен быть Юниор. А есть кто смотрел лекцию прошлого
года про реализацию варианта? Если вы смотрели, то у вас
все заспойлерено, вам будет неинтересно. Тогда вы молчите.
Надо, чтобы те, кто не смотрели, фантазировали.
Я не смотрел даже нашу лекцию два-две лекции назад, потому
что ее не выложили.
А, ладно. Ну, кто-то сказал, Юнион надо хранить.
Можно хранить Юнион, но как в этот Юнион положить все
типы, какие надо? У меня же их переменное количество.
Да, в стрейт-оче есть синтезис?
Ну, я не могу сказать, я не могу поле объявить вот так,
очевидно. Это бред полный. Ну, типа как?
Может, через оператор запятую, что-нибудь такое веселое
дело?
Нет, опять через оператор совершенно непонятно как,
потому что Types это пакет. Мне надо распаковать пакет,
если я...
Types, а, через оператор, нет, значит, это не оператор.
Мне оператор никакой, кажется, не поможет по той простой
причине, что мне нужно declaration сделать, мне нужно объявить
несколько штук разных типов. Оператор тут никак не справится,
потому что оператор это когда уже есть, а не можно
expression писать.
Но есть какую-нибудь функцию, которую они еще и делают,
какой-нибудь define сделать?
Нет, define вообще не вариант. На самом деле, вот мы с вами
внимательно читали...
Может, в сырую память их положить?
Так тоже можно.
Можно хоть звездочки все скастовать и положить
указательные на них.
Мы с вами, хоть звездочки, ты уже что-то перегнул.
Мы с вами внимательно читали статью
Seed Preference про юнионы, в которой было написано, что нельзя
в юнионах. Там было написано в юнионах, там нельзя то,
все, нельзя наследование, нельзя виртуальные функции,
но там не было сказано, что нельзя делать шаблонные
юнионы. На самом деле, можно сделать шаблонный юнион.
Я богое имя типов сделаю, чтобы не конфликтовать с
внешним.
И сделаю следующее.
Правда, мне придется сделать здесь head и tail.
Да, здесь будет head и tail.
Я сделаю head.
Head.
А дальше я сделаю union.
Вот tail.
Ой, какой union?
Господи, что?
А, tail.
Так лучше.
Вот.
Понятно, как это работать будет.
У них нужна специализация для одного head?
Разумеется.
Безусловно. Нужна специализация.
Скорее для пустого.
Ну, не знаю.
Может быть лучше.
Пустого union не очень понятно, что такое пустой union.
Типа, там будет один byte, что это такое?
Нет, я для одного лучше сделаю.
Так что size of пустого union тогда не понятно,
какой будет.
Я лучше сделаю для такого.
И что я здесь напишу?
Ну, я напишу вот так.
Только T.
Да, T value.
Ну, может я все-таки сделаю head.
Да, я неправильно описал специализацию,
потому что нужно вот так же делать.
И сделаю просто head.
Head, а tail никакого нет.
Понятно, как это работать будет?
Шаблонный union.
Понятно ли,
что size of такого union
будет максимум
из size of типов?
Ну, максимум
с точки корректировки на выравнивание.
Сейчас вопрос.
Он положит в память сначала head?
Ой, сейчас, нет.
Не совсем понятно,
что значит union от tail
в плане как это работает.
Ну, как это? U с шаблонным параметром tail
наготовишь. U вот с таким пакетом параметров.
Если я сделаю U от int
double string, например,
то в нем будет лежать int,
а еще union от double string.
Это как бы рекурсивная штука,
мы рекурсивно определяем их в список.
Это немножко странно.
Почему странно?
Последним элементом надо N раз
прошагать внутрь.
Да, это правда. Это минус.
Это недостаток такой реализации.
Но это все будет в compile time
делаться с другой стороны. То есть это
линейное время, но и так компиляция.
Понимаете? Ну, то есть если вы хотите
считать из union последний его тип,
то вам нужно как бы пройти
по всему пакету типов,
проверяя, это тот тип, какой надо или нет,
и наконец вы достанете его.
Но это будет линейное время
в compile time, а не в run time.
Вообще непонятно.
Я же не могу обратиться
от первого к union
к третьему элементу,
потому что это будет второй элемент второго union,
который у меня лежит внутри.
То есть я не могу писать union от 3,
мне нужно написать union от 2 от 2.
Что значит union от 3?
Что такое union от 3?
Я ничего не понимаю.
У union нет никаких методов,
union это зарезервировано
в языке, это вид типов.
Никаких методов у union нет,
пока мы их не определим.
Мы сейчас сами их будем определять.
Вот у варианта есть метод,
точнее не метод, а внешняя функция.
Есть гент, который принимает вариант
и индекс. И вот она-то как раз
будет шагать по этому union,
пока не дает методов.
Вот у варианта есть метод,
точнее не метод, а внешняя функция.
У меня сейчас будет шагать по этому union,
пока не дойдет до того,
что тип, что его спросили, совпадает
с типом, какой она видит.
И пока не досчитает счетчик.
При этом она будет именно
на этапе компиляции это делать.
Можно это написать так,
чтобы на этапе компиляции работала.
Я предлагаю, если вы будете смотреть
лекции прошлого года,
хотя зачем, казалось.
В общем, тут опять есть два подхода.
Как и в реализации Function,
есть два подхода в реализации Variant.
Один из подходов сделан такой шаблонный union.
Другой подход – это просто сделать
массив char, локальный буфер.
И вот в него напрямую писать.
Без вознес union.
Я, пожалуй, в этот раз предпочту
второй подход, хотя можно
и через union делать.
Хотя в STL кажется сделано
через шаблонный union.
Я, если честно, не очень разбирался
в STL, как это прямо там написано,
ну, типа, идейно.
Понятно, как, почему они
предпочли делать через шаблонный union.
Я, честно говоря, не знаю.
Но как будто бы...
Ну, есть преимущественные
недостатки у такого и у другого подхода.
Вы можете сами когда-нибудь реализовывать,
если будете реализовывать, писать и так, и так.
В прошлом году я показывал
подход через шаблонный union.
В этом году давайте я все-таки
сделаю без union, а просто сделаю
буфер
ну, просто обычной чары,
короче, буду хранить. Массив чаров просто буду хранить.
Вот.
Это...
Ну, дальше мы увидим.
Это наложит определенные там...
Возможно, местами это
сделает ход чуть
короче, но зато там чуть менее
безопасным. Ну...
Можете чуть-чуть вернуть назад на секунду?
Ну, вернул.
Ага.
А, ну да.
Короче, давайте
просто хранить массив чаров.
Буфер.
Какого размера?
Ну, max...
Как это сделать? Как это написать?
Вот тут начинается проблема. Пока у нас был union,
это само считалось.
Но зато нужно было шагать
по union-у линейно в компиляции.
Как нам размер буфера понять?
Какой?
Мы, кажется, можем... Типа, вот как мы делали
с compile time вычислениями,
мы можем как-то...
Да, нам нужна
метафункция, которая вычисляет...
Нет какой-нибудь size of
3.
Size of 3. делает не то. Size of 3.
вычитает количество типов в пакете.
Нам нужен максимальный размер
типа из пакета.
Нам нужна метафункция,
которая будет
вычислять
максимальный размер для данного множества типов.
Ну,
я не буду ее писать.
Вы ее сами реализуете.
Get max size of
Давайте я здесь просто напишу static const
size t
value
равно, не знаю, 128
нам для всех нужд этого хватит.
Вот.
Можно даже 64
написать. Я не думаю,
что-то буду хранить большего размера.
Короче,
а буфер вот такого размера,
но вы напишите свою функцию, которая
значит
вычисляет правильный размер.
Еще чего не хватает,
если мы так пишем.
Вот мы такой буфер
завели. Что еще не хватает ему?
Если в такой буфер прямо сейчас
писать начать, то это вообще говоря
есть
alignment
Конечно, нужно align
align s
Он, кстати, можно вроде после
типа писать.
Опять, здесь нужно правильно вычислить,
какой alignment. Но я не буду париться,
напишу max align t.
Вы, если будете писать,
вам лучше запариться.
Давайте я проверю, что все у меня
на данный момент работает.
Alignment t у меня не
определено ожидаемо.
Я уже теперь помню
C, S, T, D, D, F.
Видимо, надо все-таки
слева писать что-ли.
Да, интересно.
Все-таки слева надо писать было типа.
Окей, буфер.
Что еще надо?
Надо хранить индекс типа.
Мы никак
не можем этого избежать,
потому что в рантайме нам где-то надо
помнить, какой тип сейчас хранится.
Иначе никак. Нам нужен какой-то
индекс.
Давайте я скажу, что это unsigned int.
Ну или sizeT.
Все равно выравнивать
придется по 16,
поэтому не сильно я потеряю.
SizeT current
index
равно 0, допустим.
На самом деле, хороший вопрос,
почему он равен по умолчанию.
Кстати, по умолчанию он как раз и должен быть равен 0, правда?
Ведь мы, если создаем вариант
по умолчанию, то он инициализируется первым
из своих типов.
Вот.
Окей.
Давайте что-нибудь
какие-нибудь реализуем методы.
Сначала простые какие-нибудь методы.
Например,
что у нас
простое? Например, get.
Вот как сделать get из варианта?
Это легко
должно быть.
Только опять-таки нам понадобятся
разные метафункции.
Get – это
внешняя функция, шаблонная.
Template
typeName
Get бывает
по индексу, а бывает по типу.
Вот.
Ну давайте сделаем get по индексу.
Template
sizeTn
typeName
многоточие types.
А
какой тип
должен быть возвращаемый
у функции get?
Ну я напишу авто get
без параметров
стрелочка.
Какой возвращаемый тип должен быть?
Я из варианта
по индексу n, а
какой же, что же я делаю,
вариант амперсам
v.
Get передаю в вариант.
stget
с шаблонным параметром int,
ну шаблонным параметром число.
Вот объекта варианта.
Какой у него возвращаемый тип?
Первый вопрос.
Какой?
Очевидная какая-то метафункция,
которая…
Это элемент пакета как бы.
Вообще кажется, что подойдет
амперсам или
деплтайп от авто.
Ну можно и прогресс.
Кажется, что подойдет
авто амперсам.
Но я не уверен. Сейчас мы напишем
и потом подумаем.
Или вы подумаете. Я напишу пока так,
но вы когда будете тесты проходить,
возможно вы поймете, что
это не всегда подходит, а надо что-то более умное.
А что по существу надо сделать здесь?
У варианта, наверное, надо аргумент
указать в шаблоне.
Это правда, кстати.
Вариант от параметров types как раз.
Нам нужна функция,
которая… Нам нужно это элемент
пакета достать.
Нам нужно достать это и по счету элемент
пакета.
И скастовать к нему…
Гуфер.
Вот. Но этого мало.
Нам надо бросить исключение.
А что мы будем делать?
Но этого мало. Нам надо бросить исключение,
если тип вариант на самом деле не такой был.
Нам нужно проверить, правда ли
текущий тип в…
Еще надо проверить, видимо, что n лежит
в количестве аргументов.
Ну, адекватное, короче.
Ну, вот если
n больше, чем sizeOfTypes,
то это можно
compileTimeError сделать.
Как мы n,
если оно не шаблонное,
передадим в эту функцию?
Кстати, на счет n меньше
или равно, чем sizeOf
многоточие Types.
Это просто compileTime
проверка. Чего-чего?
Илья, каким образом у нас функция get
будет работать только с числами вычислимыми
в compileTime?
Даже строго меньше.
Каким образом что функция… Что еще раз?
Get… Это шаблонный параметр
get. Мы пишем std get
от какого-то
шаблонного параметра
от варианта.
n вычислимых в compileTime.
Ну, так разве у
варианта нету какой-то функции,
которая позволяет получить его n
и параметр,
где n вычисляется в runTime?
Нет.
А каким образом это вообще можно сделать,
по-твоему?
Мне нужно…
Ну, это довольно бессмысленно.
Во-первых, кажется,
это довольно бессмысленное желание,
потому что
n и параметров…
Потому что пакет типов
он же в compileTime известен.
А вы хотите в runTime
из пакета типов вытащить
какой-то тип? Это, кажется,
какая-то глупость. Ну как?
У вас пакет типов-то зафиксирован
в compileTime,
и вы хотите в runTime
выбирать какой-то из него.
Но вам же нужно, чтобы возвращаемое значение
имело какой-то конкретный тип.
У вас же должно быть возвращаемый тип каким-то конкретным.
О, get.
Вы ушли бы тогда просто
и вам тогда вариант никакой пользы не приносит.
Либо, если вы пользуетесь get,
то у get должен быть
конкретный возвращаемый тип.
Но конкретный возвращаемый тип нельзя в runTime
определять.
На прошлом занятии я показывал,
что, на самом деле, когда он генерировал разные лямбды,
то там просто лямбда генерируется на каждый из возможных
вариантов и просто вызывает нужную функцию.
Почему здесь нельзя сделать
то же самое? Просто загенерировать функции для всех n,
потому что, понятно, все они известны.
После этого вызывать в runTime нужную функцию, которая нам нужна.
Нет, мы будем писать visit.
Visit – это другое.
Visit работает так,
что у него
на каждый тип
того, что может лежать в варианте,
теоретически есть своя операция,
и вы, просто вызывая visit,
решаете, какая операция вызывается.
Но по факту...
Вот visit.get сделать, просто.
Что значит visit.get?
Ну, это значит сделать get, который будет
вгенерировать код для получения
типа каждого из
вариантов, которые можно будет получать в runTime.
Нет, я не понимаю. Давай ты скажешь
сначала, какую ты хочешь сигнатуру функций
иметь. Что ты хочешь, чтобы можно было
делать? Есть вариант.
Просто мы...
Я не понимаю, в чем запрос
состоит. Вот у меня есть вариант int double
и std string, допустим.
И я положил в него, я не знаю,
там, 5.0.
И дальше, что я должен...
Ты хочешь функцию, которая что позволяет сделать?
И что она возвращать
должна? Отличный вопрос.
Самый главный. Просто функция get,
у нее возвращаемый тип, это tmperson,
где t – это тип того, что ты попросил
достать. Я хочу сделать
n перегрузок на каждый тип
варианта.
Хочу сделать n перегрузок на каждый...
на каждый вариант того, что будет представляться
в n, чтобы возвращался
соответствующий тип, который соответствует
n-кому параметру варианта.
Причем так, чтобы...
Короче, я хочу просто сделать get, который работает
в runtime.
Какой у него будет возвращаемый тип?
У него будут разные
возвращаемые типы в зависимости от перегрузки от того,
что... Как может быть разный возвращаемый тип?
Get – это будет внешняя
функция или метод варианта?
Метод варианта.
Какой у него
будет возвращаемый тип? Вот здесь будет
написано template или что?
Это будет шаблонный метод или нет?
Так он будет...
Проблема, что я не понимаю, как это реализовано.
Ну никак.
Ну никак.
Ну с visit-ом эта проблема обходится...
В смысле, ты не понимаешь, как visit работает.
Да, именно.
Давай мы отложим это наконец,
потому что сейчас мы, кажется, очень сложные проблемы
начали обсуждать. Мы...
Как visit работает, мы обсудим в конце.
Вот, я надеюсь, успеем.
Так не сможет работать.
Хорошо, вопрос такой сразу.
Если мы знаем, как работает visit, можно ли через visit
реализовать get, который будет работать как visit?
Ну, кажется, да.
Ну, ты как минимум можешь из visit-а
возвращать просто...
Ну как, ссылку на
то, что ты...
Ну, ты делаешь visit,
варианта...
Значит, ты делаешь visit,
и в visit в перегрузке принимаешь
авто&x.
Ты можешь просто вернуть этот x
наружу из visit-а.
И вот тебе будет visit, который возвращает тебе ссылку
на то, что он получил
в качестве параметра.
Ну, а как бы тип...
В смысле, что такое x?
Ну, это не будет работать для всех наборов типов,
потому что возвращаемый тип visit-а
либо придется явно указывать, либо он
не сможет вычислиться, если типы несовместимые.
Короче, это всё равно
не сможет работать, если типы несовместимые.
Если нельзя, общий тип
найти для всех данных.
Стоп, всё, нет.
Закрыли вопрос слишком долго.
Мы сейчас уже начнём услышать, как visit работает.
Визит мы в конце обсудим.
Get конкретный тип возвращает.
Вот get должен вернуть тип, который
реально мы запросили, и это в compile-time вычисляется.
Так?
Как работает get с одним шаблонным
аргументом, когда мы пишем get int
от варианта?
Давай сначала напишем get от числа.
Вот сейчас я реализую get от числа.
Ну хорошо, но get2
от варианта.
В любом случае, вот мы сейчас пишем get, который
ещё, помимо этого,
принимает ещё пакет типов.
Замечательно. get
берёт
первым шаблонным аргументом число,
а принимает в качестве параметра
он вариант.
И у этого варианта
шаблонными параметрами являются типы.
Но поскольку это шаблонная функция,
то здесь однозначно
сопоставляется от каких шаблонных параметров
вызывается get.
Потому что мы передали в get вариант от конкретного
набора типов,
и компилятор
может вывести эти types.
Но мы же обсуждали, что
частичный аргумент reduction
не бывает.
Для функций вообще-то бывает. Это для классов не бывает.
А, хорошо.
Для функций ты можешь указать
часть, начальный
префикс шаблонного параметра явно,
остальные он выведет сам.
У нас был даже пример
связанный, кажется.
Короче, для функций это работает.
Так вот, что мы дальше пишем?
Мы должны...
Ну, мы сделали static assert,
что n меньше, чем size of многоточие types.
А дальше мы что делаем?
Ну, мы просто по сути делаем
static cast к ссылке
на
Ну, нам нужен
using
t
равно
get
type
by index
от n
запятая types.
Нам опять нужна метафункция,
которая по данному пакету типов
возвращает n-й тип.
Так.
Как?
get type by index
знак подчеркивания t.
Ну, или
вот здесь type.
И можно было и на месте писать.
На месте? Не очень понятно. Как?
Ну, просто взять head и закуститься
от варианта, который без первого
типа. Это мне не очень нравится,
потому что это была бы
рекурсия с функций,
а я хочу, чтобы у меня
не было вызова функций с функций.
Я только метафункции хочу вызывать.
Но это вроде понятно, как писать.
Да, я сейчас тоже напишу заглушку
template type name
size tn
type name многоточие types
значит struct
get type
by index
Ну, и здесь я напишу, не знаю, using type
равно
int
Ну, я просто написал заглушку,
но понятно, что вы реализуете сами.
Хорошо.
И что мы делаем?
Просто мы делаем reinterpret cast
к этому типу
от нашего
v.buffer
Откуда мы берем буфер?
Ну, нам надо, чтобы эта функция была другом
варианта.
Разумеется.
То есть эта функция, она
будет
иметь доступ
к приватным полям.
Вопрос
Ответ, на который
опять-таки до него сложно догадаться.
Вопрос на
либо вы очень умные, либо вы
знаете наперед.
У вас наверняка мучил этот вопрос
еще в прошлый раз. Почему get это внешняя
функция, а не метод варианта?
Кто догадается, тот супер молодец.
Ну, комитет
эту проблему понял сразу, и они
сразу сделали get внешней функции.
Почему плохо делать get методом
варианта?
Это ответ очень тупой
и очень, даже не знаю, смешной, но
вот тем
не менее он не очевидный совершенно.
Может быть, типа они
один get вообще на все возможные
типы написали.
Что значит один get на все возможные?
Есть get для тапла, есть
get для варианта. Может быть, это
одна и та же функция.
Они же по-разному работать должны.
Как это может быть?
Это как-нибудь связано с абстрактными
методами?
Абстрактные методы?
Может там будет какой-нибудь метод, который будет
годным? Нет, у нас никакого
верчевого
варианта
в варианте у нас не будет.
У нас нет
здесь никакого runtime полиморфизма
с ранее типов. Есть тупая версия?
Да, я знаю. Ответ
и есть тупой. Ответ очень смешной и
тупой.
Предположение, что мы не хотим
на получение
видимо одного и того же типа
кучу
getов генерировать для разных
вариантов.
Там что-нибудь такое?
Короче, нет. Я вам могу так
сказать. Давайте представим, что я этот get
сделал методом.
Это будет подсказка сейчас.
У нас много разных вариантов
с одним и тем же типом. Вот, смотрите.
Вот, допустим, я сделал вот эту функцию
get методом варианта.
Шаблоны? Что с шаблонами?
У нас два разных шаблона для...
Ну, хорошо.
Сделал вот так.
Types здесь убрал.
Оставил только вот так.
Там с порядком шаблона
сюда все плохо.
Может быть, какие-нибудь универсальные
ссылки не сработают?
Так, смотрите. Все сейчас вроде нормально.
N это параметр число.
Сам вариант имеет шаблонные
параметры Types.
Ну, все нормально.
Так у нас порядок.
Чего? У меня есть вариант.
Я говорю .get с одним шаблонным параметром.
С одним шаблонным параметром.
В чем проблема?
Это метод теперь.
Теперь я пишу
v.get double
и точка запятой.
По идее, должно вернуться double
imperson.
Да?
Ну, хотелось бы.
Вот. Это не скомпилируется, к сожалению.
Ну, то есть, казалось бы,
можно сделать get методом.
Но тогда вот это не будет
скомпилироваться.
Знаете, почему?
А догадайтесь, почему?
Это из первого семестра вы должны знать,
почему это скомпилируется.
Ой, что double-то?
Get от пяти.
А, блин, нет.
Сейчас, подождите, может это скомпилируется?
Так, наверное, это скомпилируется.
Ну, у нас статикасер сработает,
потому что 5...
Статикасер сработает. Почему 5-то я написал?
Get один. Вот так вот.
Сейчас, может, я вам наврал, и на самом деле это скомпилируется.
А когда ты копировал,
фигурная скобочка осталась.
Чего?
Вот фигурная скобочка лишнего
в Friend.
А, да.
Хорошо.
И с буфером еще что-то странное
происходит.
В общем, cast,
ampersand от просто буфера кажется...
Господи, почему не private, public?
Почему?
Нет, Sereniter. Перед кастом это все должно быть нормально.
Вот здесь мне
надо написать другое название
шаблонного параметра template
многоточие ts.
Господи.
Началось просто.
Обожаю это.
Да, у меня только одна проблема.
У меня нет конструктора.
Сейчас.
Да, к сожалению, пример
не сработал. Почему это не скомпилировалось?
Очень жаль.
Очень жаль.
Ладно.
Давайте я вам отвечу, почему get плохо.
В данном случае это работает.
Я еще много раз промотаю.
Ты за мной
записываешь, что ли?
Да.
Да, кстати, этот код я вам не скину.
А то будет слишком...
Запись ты скинешь. Запись скину, да.
Я твой файл не скину.
Ну ладно, руками перебьем.
Сами будете писать.
Вот ты молодец.
Короче, это не будет
работать. На самом деле этот вопрос
не очевиден совершенно. В прошлом году его тоже
задавали.
Мы не сразу поняли. Я тоже не сразу понял
почему. На самом деле ответ вот какой.
Потому что если вы
будете это делать
из шаблонного кода,
то я сейчас не в шаблонном коде.
Но если бы я делал это в шаблонном коде,
то вот такой метод обращения
к нему было бы некорректным
по причине это зависимое имя
и нужно было бы писать template get.
То есть мы просто не хотим писать
template каждый раз, поэтому делаем...
Представьте, что мы находимся в функции
template,
typeName
многоточие types,
которая
f
и она объявляет здесь вариант
от types.
многоточие v.
Вот. И если я эту штуку
инстанцирую с каким-нибудь там
int main
Господи.
int main и я сделаю f
с шаблонным параметром int double
std string,
то вот здесь я окажусь
в шаблонном коде
и...
Видите, что начало происходить?
invalid operands of types
unresolved overloaded function type
и int
к бинарному оператору меньше.
Никогда такого не было и вот опять.
Если у вас types это шаблонный параметр
а это часто вообще
это нормальная ситуация, что types это у вас
короче это у вас зависимое
имя и get парсится как
поле, а не как шаблон
и это воспринимается как оператор
меньше. И чтобы это парсилось
правильно, нужно писать v.template
get.
Если бы мы с вами
реализовали через union, то у нас бы
мы бы столкнулись с этой проблемой раньше.
Но в общем
это просто вопрос
на Stack Overflow есть. Почему get не метод?
Да вот почему, потому что иначе
всегда бы вам пришлось template get писать,
а не просто get. Это очень неудобно.
Поэтому мы так не делаем, а get
считаем, что это у нас
внешняя функция.
Не std get, а просто get
от одного, например
от нашего варианта.
Сейчас еще раз глупой вопрос. Почему
get парсится? Почему в конкретном случае
она парсится? Потому что
type v это зависимое
имя.
v зависит от того, что такое type.
В зависимости от того, что такое type, get могло быть
как полем, так и типом,
так и шаблоном.
Получание парсится как поле.
А можете еще раз наверх?
Ты можешь скрин сделать
и переписывать там сколько тебе надо.
А
так, еще
должно быть get по типу.
Ну давайте get по типу я не буду писать,
его сами тоже напишете.
Ну то есть, что должен проверять get по типу?
Get по типу, во-первых, должен проверять, что
тип единственный в пакете,
ну еще он ровно один вообще.
Статика все на этом. А дальше он просто
должен делать reinterpret cast к этому типу опять.
Самая интересная
часть.
Одна из самых интересных частей,
их сейчас будет несколько.
Конструкторы.
Давайте напишем конструктор варианта.
Конструктор от
t,
где t это то, что мы вариант
положить хотим.
Template,
type name t,
variant
от
ну опять-таки понятно, что
должен быть конструктор как от rvalue
так и от lvalue.
И на самом деле
можно написать, что мы здесь делаем
универсальную ссылку, но это все я
короче опущу, вы сами это все сделаете,
как полагается, там у вас будет
значит,
вы стоили посмотрите, увидите от чего там
должен быть конструктор. Значит, эту всю
историю я опущу.
Будем считать, что просто стандартно от конста
конструктора.
Что надо сделать здесь?
У кого-нибудь есть идеи вообще?
Что написать?
И вообще так ли надо написать?
То есть как
осознайте проблемы.
Ну понятно, да, что я могу сказать
new от буфера,
но это совсем не то, что нам нужно.
Это конструктор варианта, какой
предыдущий?
Но это работает совсем не так,
как нужно. Это слишком
примитивно.
Это не то, чем мы хотим от варианта.
Это наивная очень реализация конструктора,
не так все должно работать. Почему?
Что здесь не так будет работать?
Главная особенность варианта,
которая непонятная,
которая в самом начале,
я в прошлом акцентировал внимание,
как должен себя вести вариант,
если мы вызываем конструктор какого-то
Т.
Но карантиндекс нужно подвинуть.
Да и это не в суть.
Тут принципиально все неправильно
работает. Никакой
плейсмент юзди не получится так
реализовать конструктор. Ну то есть получится,
но будет работать неправильно.
Ну еще раз,
если я...
Так у нас могут быть какие-то ссылки в полях,
указатели, которые
нельзя вот так сделать.
Все мимо.
У меня есть вариант от int и double,
и я его конструирую от float.
Должен создаться double, а не float.
Конструктор должен
работать по правилам перегрузки, мы же
про это говорили час назад.
Я должен
выбрать тип из своего
types, который наиболее предпочтителен
для конверсии t в него,
и его создать из этого t.
А как вообще это писать тогда?
В этом и вопрос главный.
А мы не можем... А можно создать
конструктора от всех типов, которые у нас
есть, и потом
просто вызвать отдельные фронты.
Как их всех объявить-то
эти конструкторы? У тебя ж не будет
выбираться вроде из шамлонов.
У меня есть вариант от 3 точья, как
оператор.
С многоточем
только using можно писать.
Метод объявить новый
через многоточие нельзя.
Вроде
может быть можно создать какой-то вспоминательный
класс, шаблонный, который
будет как раз
отвечать каким-то образом
за конструирование,
и для него написать using, что-то там.
На самом деле
нам потребуется...
Единственный способ,
известный мне,
и кажется, что в ASTL
также сделано.
Единственный способ, известный мне,
это через наследование
и using
многоточие.
Мы сейчас
сделаем переменное количество
наследников
в каждом из которых
определим конструктор
от соответствующего t
и внесем их все
в нашу область видимости
через using с многоточием.
Смотрите, что будет написано.
Я заведу такой шаблонный
класс.
Назову его...
Давайте я заведу это вообще структурой.
Variant choice.
И в нем
будет...
Я свой вариант сделаю
приватным наследником, приватным,
потому что никому не надо об этом знать.
Variant choice от types многоточия.
Мой вариант, это будет
наследник от переменного количества таких
choice.
И в variant choice я напишу следующее.
Так, нет.
Это я что-то забежал вперед.
Мне надо в
variant choice
сделать конструктор
от данного t.
И этот конструктор должен взять
и прямо
у нас есть буфер
нужный объект t.
Откуда он буфер возьмет?
А для этого ему нужно
посчитать, что он и есть вариант.
Но это так на самом деле и есть.
То есть ему нужно
сделать static cast себя
как будто он вариант.
Но он и есть вариант. Мы как бы и приватно
наследуемся. Это такой
CRTP в каком-то смысле.
Вот, например, мы
берем вариант
и делаем его
наследником
variant choice
от него самого.
На самом деле я могу вот так сделать.
Здесь сказать variant
с шаблонным параметром types.
Но можно и лучше.
То есть смотрите, что я делаю.
Я говорю,
вот здесь вот я хочу
соответствующего варианта,
из которого я сейчас
создал, как бы создаюсь.
Понимаете, что я пытаюсь сказать?
Короче, я говорю
using
derived
равно, и вот здесь говорю,
какой тип. Это будет
вариант с
шаблонным параметром types.
А откуда я узнаю types?
А
а я их
передам сюда.
Вы что-то говорите?
Нет, я просто
печатаю.
По сути, вот что здесь должно быть
написано.
Осознайте это.
А у нас не должно быть случайно
варианта
с шаблонным параметром
types?
Это правда.
Должно быть, конечно.
Потому что мы его используем
не объявив.
Тут еще одна есть проблема,
но это все технические
проблемы, вы суть осознайте.
Значит,
много проблем на самом деле.
Понятно суть
фокуса.
Что я сделал благодаря наследованию
такого количества родителей.
Ну, у нас теперь есть конструкторы, которые будут
вводиться в этом по правилам выда функций.
Да.
Вот здесь я напишу
using
variant
choice от
types
variant choice
многоточие.
То есть, я взял и унаследовал,
как бы, внес в свою областительность
все конструкторы variant choice.
Напоминаю, что using
variant choice можно применять к родительским конструкторам в наследнике.
Я взял
и как бы сказал, что меня можно создавать
от любого из того,
из чего можно создавать было своих родителей.
Я сказал, что пусть у меня
будут конструкторы от всех
тех типов,
от которых можно было создавать
моих родителей. А моих родителей
можно было создавать от всех
те, я как бы сделал
наследование вот от такой штуки.
Смотрите, допустим, если у меня есть
понимаете, как это работает? У меня хитрая конструкция,
у меня здесь многоточие,
угловая скобка закрылась и снова многоточие.
Как это работает?
Если у меня есть,
допустим, вариант
а
если у меня есть вариант какой-нибудь
от int
double
string,
то он получается наследник
следующих вещей. Variant
choice
от int
а потом int double
string
еще он наследует
вариант choice
от double
а потом int double string
а потом он еще
наследует вариант choice
от string
int double string
То есть у variant
choice шаблонный параметр является
некоторый тип, а дальше весь пакет.
И у меня таких типов
создается столько штук, сколько типов в пакете types.
Вот что здесь на самом деле написано.
Унаследуйся, пожалуйста,
от variant choice вот со всеми
такими возможными шаблонными
аргументами. Вот этот пакет
распаковывается вот здесь
и превращается в перечтение int double string
а вот это распаковывается внешним
многоточием и получается, что у меня
переменное количество родителей.
Двойная распаковка пакета здесь происходит.
Вопросы?
Можете, пожалуйста, сказать, как мы
вот в этот variant приписали?
Мне очень на самом деле
грустно, что у нас онлайн сегодня.
Мы все еще сделали
конструктор только от T, который
мы передавали в variant.
Я тут все еще ору просто
с выключенным микрофоном.
Да-да-да, вот я говорю, я очень жалею, я очень бы хотел,
чтобы именно эта пара была онлайн,
потому что, оффлайн, потому что мне не хватает
эмоциональных комментариев от господина Васюка.
Я просто как бы вот уже
представляю себе,
как он бы это прокомментировал,
просто пока здесь сидишь
и нифига не понимаешь,
ты молчишь на камеру,
а если в классе, то ты
не молчишь, ты кричишь.
Да, мне сейчас не достает вот это.
Зато вот материться можно, все нормально.
Эмоциональная реакция зала, да, что за черт происходит?
Ну вот, ну ничего, не волнуйтесь,
у нас еще с вами будет...
Я все равно не особо понял.
Каждой оставшейся паре у нас будет что-то подобное,
поэтому мы еще насладимся, так сказать,
всеми возможными возгласами.
Можете, пожалуйста, юзинг показать?
Да, вопрос, подождите, был задан вопрос.
Мы же все равно сделали конструктор
только от тех t, от которых
которые были в пакете.
Это правда, но
теперь у нас
эти все конструкторы внесены как обычные функции
сюда, это уже не шаблонные
функции, они
сюда внесены, таким образом у нас,
у меня как бы в варианте есть
конструктор от int, конструктор от double,
конструктор от string, они внесены
как самостоятельные функции в этом
области видимости, таким образом,
кстати, вот это мне надо удалить, оно же не работает,
таким образом
у меня
когда я создаю вариант от чего-то,
выбирается версия из этих
трех по правилам перегрузки, потому что
у меня как раз таки вот эти три версии
здесь и внесены в область видимости.
У меня ровно столько версий, сколько типов
для каждого своя, и они не шаблонные,
поэтому подстав в шаблон там не делается,
выбирается подходящая по правилам
перегрузки.
А вы можете скопилировать код?
Не знаю, давайте попробуем.
Там еще кажется в юзинге
нужно пакет
дописать. Вот у меня такая же ошибка
просто кажется.
Вот здесь кажется нужно пакет
дописать. Да, не хватило,
здесь нужен пакет.
Type, во-первых, вот
так.
А сейчас будет еще одна ошибка,
скорее всего.
Не хватает конструктора
по умолчанию ему еще?
Он жалуется, что не хватает конструктора
по умолчанию.
Значит, в variant-choice
нужен конструктор по умолчанию, кажется.
Не знаю, чем
вызвано это требование.
Вот.
И...
Давайте, наверное,
можно догадаться, чем это требование
вызвано.
Тут написано, что
не хватает конструктора
по умолчанию.
И...
И...
Написано, что
конструктор
от const double and percent is implicitly deleted
because the default definition would be ill-formed.
variant-choice
variant-choice без параметров
отсутствует.
Почему-то...
Почему-то он хочет,
что был конструктор без параметров.
Не знаю, почему, если честно.
Не помню.
Надо почитать правила.
Но ладно.
Еще у нас одна ошибка в компиляции.
Какая? Видите, какая?
Понимаете, почему?
variant-choice blah-blah-blah is inaccessible based
off variant blah-blah-blah.
Почему такая ошибка?
Потому что наследование приватное.
Потому что приватное, конечно, наследование.
Наследование приватное — это значит,
что variant скрывает от всех тот факт,
что он наследник variant-choice,
вообще от всех, в том числе
от самого variant-choice.
Variant-choice тоже не знает, что variant
его наследник.
Поэтому нам нужно сделать variant-choice
другом варианта.
Variant-choice с любыми шаблонными параметрами
должен быть другом variant.
Этот наследование нам не поможет?
Так.
Значит, я просто говорю, что...
Наверное, я должен повторить сигнатуру точно.
Ну, в общем, я должен сказать
friend struct
variant-choice.
Сейчас, наверное, так можно.
Если нет, то я дословно повторю
сигнатуру.
А, redeployer to use one template параметр.
Да, так нельзя.
Значит, мне все-таки придется явно
повторить TypeName.ts, запитать TypeName.ts.
У меня там два шаблонных параметра
было.
Ну, вот теперь это работает. Это даже запускается.
Правда, ничего не выводит. Ну, понятно, почему
ничего не выводит.
А где вы добавили конструктор
в умолчанию?
Вот здесь.
Вот.
Хороший вопрос, правда.
Как будет тогда вести себя конструктор
в умолчанию самого варианта?
Ну, давайте этот вопрос я оставлю
вам на самостоятельное изучение,
потому что это уже не так интересно.
Тут, возможно, надо написать варианту
отдельно конструктор в умолчании, который будет
конструировать первый аргумент.
Ну, это не интересная часть.
То есть главное, что мы поняли,
как победить вот эту проблему с перегрузкой.
То есть мы поняли,
как победить вот эту проблему с перегрузкой.
То есть благодаря вот этому вот
трюку, магическому фокусу
с наследованием к переменам количества
классов и юзингом с многоточием,
мы умудрились
в вариант
добавить
конструкторы,
которые по правилам перегрузки
выводятся.
Кстати,
кстати,
кажется, что
это все-таки можно было сымитировать без
юзинг многоточия.
То есть
вот это вот самая
самая удивительная конструкция здесь.
Да, вот это вот вообще.
Это C++17 тока.
Но все-таки, если у нас
нет юзинг многоточия, если вот без
этой конструкции, как ее можно сымитировать?
Но на самом деле у нас же есть
user-defined-deduction-guides.
Мы же можем варианту написать,
вот представьте, что я без юзинг многоточий
могу сказать.
Deduction plate,
type name,
variant
от const
Я же могу сделать
deduction-guide. Variant
от
Deduction plate
Нет,
не deduction-guide мне нужен. То есть
смотрите, я могу что сделать? Я могу написать
Что я могу написать? Я мог бы написать шаблонный конструктор, ну давайте я идею скажу, что можно было бы, как бы можно было это обойти, кажется. Смотрите идея.
Я могу написать шаблонный конструктор от const.mpercent.
Variant от const.mpercent.
Вот. А здесь сделать такую вещь.
Using type равно decal type от некоторая функция helper с шаблонным параметром types.
Вот наш пакет.
От value.
Вот.
Значит.
Да, вот так.
И...
Блин, черт, все-таки не получается у меня, жалко да, ой, печально как.
То есть я хочу что сделать, я хочу как бы сымитировать, я хочу сделать как бы перегрузку helper, которая бы была...
Которая бы принимала вот этот вот value и при этом возвращала бы какой-то тип, как если бы...
Вот от того types, от которого она вернулась.
Блин, нет, все-таки не получается.
Не будет это так работать.
Блин, давайте я потом вам пришлю как это сделать, потому что не могу что-то я сходу написать, как это будет надо написать.
Чтобы у меня была перегрузка функций реальных, чтобы я по decal type от выражения понимал какой выбрался тип из типов.
То есть у меня пакет типов и я хочу написать по функции для каждого типа и вот каждая функция будет возвращать тот тип, от которого она реально вызвалась.
И после этого я через decal type пойму какой тип.
Не могу, забыл как это пишется, короче, сорян, но вот так мы...
Вот так это стало писаться и начинать степель способствоваться.
Может быть тот способ вам никогда не понадобится.
Ну я пришлю в чат или в следующий раз вспомню и расскажу как это писать.
Короче, это можно сымитировать было и без вот этого заклинания, но с этим заклинанием стало гораздо проще.
Короче, так, есть ли вопросы?
А, еще, я здесь забыл важную вещь, мне здесь надо сделать choice.
Ну, мне здесь надо еще соответствующий этот currentIndex поменять на нужный.
Ну, давайте я туду оставлю, тоже не буду это писать, потому что это тоже понятно так сделать.
Ну как-как? Опять мне нужно...
Ну, мне нужно скастить опять дирайвом персанду себя и у него сделать currentIndex каким?
Таким каков индекс этого, значит, t, вот этого t в списке...
Я не то сделал-то, господи.
А, нет, все то сделал.
Да, но у нас уже была похожая функция, которая по индексу возвращается.
Да, у нас была функция getTypeByIndex, а здесь мне нужна функция getIndexByType.
То есть мне здесь нужна еще метафункция getIndexByType, которая по типу возвращает его индекс в пакете.
Ну, понятно, и вы ее тоже можете реализовать легко.
А правда ли, что эта задача легче, чем какой-нибудь Android Map, например?
Не думаю, не знаю.
Тут еще далеко не все проблемы решены, сейчас вы увидите новые проблемы.
Божить точно меньше.
А...
Окей, мы написали конструктор.
Давайте напишем деструктор варианта.
Как написать деструктор варианта?
Ну, вызвать по индексу деструктор.
А как узнать, какой вызвать?
Так у нас же индекс есть, мы же имеем getTypeByIndex, у нас же есть индекс, который хранится в памяти у нас.
Так он же...
Да, но он runtime.
Да, он runtime-ский.
А что мешает деструктору в runtime понимать, что ему есть?
Ну, продиктуй просто, что напечатать мне.
А что мешает деструктору в runtime понимать, что ему есть?
Ну, продиктуй просто, что напечатать мне.
Ну, reinterpreter предкаст к там getIndex, точнее getTypeByIndex от types.
Точнее от... А там первым идет индекс?
Ну да.
А, мы не можем currentIndex туда поставить?
Да, мы не можем currentIndex, потому что это не compileTime константа.
Че делать?
Можно каким-нибудь ifConstext проифать все возможные варианты?
Как?
Их перемен...
Если бы их было конечное, ну, фиксированное...
Нет, у нас же фиксированное количество, у нас размер...
Диктуй, че печатать.
А мы можем рекурсивно, например, если один, то окей, а иначе запустится от...
Ну, диктуй. Пожалуйста.
Диктуйте, че писать. И ifConstexpr, что?
Только мы current не можем проверить, да.
Опять, мы не можем в constexpr че-то с currentIndex делать, потому что это не можно.
Мы не можем, когда мы заменяем наш тип, который там хранится...
Ну, типа хранить указательный деструктор.
То есть вы предлагаете опять создать некое подобие таблицы виртуальных футов, то есть хранить pointer.
Че делать, когда деструктор вызывается?
Ну, как вариант.
В целом, что угодно можно сделать. То, что мы до этого делали.
Да, можно запилить опять TypeIrager.
Но мы бы не хотели все-таки виртуальные функции сюда приделывать, потому что это уж как-то совсем грустно.
Мы как-то хотели без них все-таки.
Но действительно, кажется, можно сделать указательный деструктор.
Нет, ну ладно, а тогда оператор присваивания как писать.
Также.
Ура, ура!
Кстати, с оператором присваивании есть еще вот какой момент.
Оператор присваивания должен работать так.
Он должен вызвать деструктор и снова конструктор, если мы присваиваем не тот тип, который лежал.
А если мы присваиваем тот же тип, который и так лежал, то мы просто типу присваиваем его.
Не делаем деструктор и заново конструктор.
допустим у нас в варианте лежал string и мы присваиваем в варианте новый string, тогда мы не делаем
destructor string, а потом constructor string, вы просто должны вызвать оператор присваивания стринга,
то есть если у нас в варианте мы присваиваем ipp который в нём и лежал, мы не делаем destructor,
мы делаем непосредственно оператор присваивания. Это по стандарту? Да. То есть нам получится
надо будет хранить еще указательный оператор присваивания. А если это мувающие присваивания,
то нам надо будет еще хранить указательно мувающий оператор присваивания. И вот уже
три указательных надо хранить. Попахивает опять какой-то таблицей виртуальных функций. Что-то
вообще неприятно. Я вам сейчас покажу козырное решение. Оно тоже может вызвать... Вот короче,
Денис, Васюк, включи микрофон. Сейчас я просто... Мне нужна реакция зрителей. Мы сделаем деструкторы
и отнаследуем все деструкторы. Смотри, деструкторы мы отнаследовать не сможем,
потому что деструктор должен быть только один в классе. Но мы сделаем вот... Смотрите, мы вот что
сделаем. Давайте я так напишу. ThisVariant равно... Короче, вот эту штуку я просто скопирую,
потому что мне опять надо будет себя кастить к варианту. Значит, ThisVariant это статик каст,
вот эта штука. Только не буфер, а просто статик каст дирайвт от себя. Вот. И теперь смотрите,
я напишу, если ThisVariant.currentIndex равно getIndexByType от at.types, if не constexpr,
потому что... Ну, потому что currentIndex это runtime штука. Давайте я сделаю тоже заглушку какую-нибудь.
getIndexByType будет всегда 0 возвращать. getIndexByType. И здесь будет typeNameT. И здесь будет value static
const sizeT value равно 0. Так вот, я что говорю, если ThisVariant.currentIndex равно... Если,
короче, в варианте index сейчас такой, каков index типа t в пакете types, то мы вот по
этому буферу и вызываем index. Деструктор t. А, то есть мы вызываем все деструкторы,
но только один из них сработает? Ну, типа да. Ну, кажется, что ничего такого неадекватного нет.
Ну да. Ну и смотрите, что происходит. Когда уничтожается Varian, должны уничтожиться все
его родители. А как они работают? А уничтожаясь, соответствующий родитель Varian проверяет,
правда ли, index был таким, каким надо, и если да, то вызывает по нужному адресу деструктор
нужного типа. Таким образом, ровно один раз уничтожается нужный тип. Поняли вы идею?
А можете, пожалуйста, уточнить, что такое буфер? Тут написано куда как точнее. Char, буфер вот такого
размера. Это массив Char. Так, понятна ли идея с деструктором? Сейчас, только видимо не буфер,
а здесь Varian буфер. Да. Это сейчас компилируется. То есть здесь мы явно использовали MTBaseOptimization в том,
что у нас в Varian.choice ничего нет, и у них все будут такой же адрес, как у установок варианта.
Нам еще надо буфер в интерплет кастнуть. Сейчас. Там, кажется, 2.2.2 value в верхней 38 строке.
Где-где? Где-где indexByType 2.2.2 value? Вот здесь. Это не компилируется, впрочем. Почему не компилируется это?
Ну да, потому что мы буфер, как бы, у него нет деструктора T. Да, потому что мы вызываем
диструктор T у штуки, которая не является штукой соответствующего типа. Это бред. Но даже если бы
это компилировалось, было бы тоже плохо, потому что это UB. Знаете, почему это UB? Мы же уже уничтожаем
сначала объект Varian, а потом его родителей. Сначала делается диструктор наследника,
потом диструктор родителей. В момент, когда делается диструктор родителей, наследника уже
не существует. Обращение к полям наследника в этом случае UB. Блин. Блин, я вам рано про это сказал,
потому что вы сейчас заметите еще одну проблему, которую я хотел на попозже отложить. Ну короче,
ладно, давайте пока решим проблему, что это не компилируется. Что же делать-то? Принтер при этом
из каст все равно нужно. Нет. Так, сейчас. Давайте ко мне минутку подумать. Я тут кое над чем сам задумался.
А мы можем сделать функцию destroy, которая, допустим, возвращала бы int равный нулю и, короче,
через FoldExpression заставить его вызывать destroy по всем типам. Да, мы так и хотим сделать,
но все равно непонятно как решить обойти вот эту проблему пока что. Так нет, у нас будет функция
destroy и у нас диструктор сам по себе. Сначала явно destroy всех VarianChoices, а диструктор VarianChoices
получается не нужен будет, потому что он всегда будет корректно удален заранее. Да, действительно,
и нам даже даже на самом деле никакой тип нам не нужен, у нас есть прекрасный первый разопитая.
Значит, смотрите, вот у нас destroy, вот здесь, да. Можно еще раз, что вы предлагаете? Ну, короче,
сделать все то, что у нас было в диструкторе в destroy. Вы хотите сделать вот эту функцию,
назвать ее destroy. Да, и затем явно вызвать VarianChoices в диструкторе нашего класса через FoldExpression.
Да, но как решить проблему, что это не компилируется-то? Так а в чем проблема еще
раз? Ну да, видимо, ни в чем. Видимо, надо просто здесь ринтерпрет кастом писать. Да, почему,
ну то есть все, понятно, разобрались. Почему нельзя это было делать в диструкторе VarianChoices? Потому
что тогда бы мы вызвали УБ себе, мы бы обращались к полю буфер, после того, как уже Varian
Choice уничтожен. То есть давайте еще раз, что-то я запутался сам, давайте я распутаю. Почему мы не
могли сделать вот так? То есть мы могли бы просто сказать ринтерпрет каст Tampersandu, точнее к
T звездочки, господи, к T звездочки от вот этого стрелочка tilde T. Мы могли бы так написать,
и это бы компилировалось, но это бы было УБ, потому что диструктор VarianChoices вызывается
после того, как уничтожился сам наследник. А когда сам наследник уничтожился, вот эти поля,
обращение к его полям, это уже УБ. И компилятор имел бы право это вообще соптимизировать,
и ничего бы не происходило на самом деле. И так бы и было, скорее всего, если бы мы так не
писали. Поэтому на самом деле так не работает. Но мы можем это сделать функцией Destroy. Сделаем
функцию Destroy, в которой напишем вот это. И когда мы будем вызывать диструктор Varian,
мы с помощью FoldExpression вызовем Destroy от всех предков. То есть мы пишем VarianChoice от types,
запитая types, многоточие, двоеточие, двоеточие, Destroy, запитая многоточие, и все это в скобочках.
Понятно ли, что я здесь написал? Но это именно то, что предлагал, не помню кто.
Давайте проверим, что это компилируется. Компилируется. Кстати, опыт прошлых лет показывает,
что на G++ версии ниже 11 это не компилируется. G++, я надеюсь не путаю, то есть C-Lang, по-моему,
это может компилировать, это G++ нет. В общем, G++ до 11 версии почему-то не мог это распарсить и
ломался. Давайте, кстати, я попробую. У меня G++ 9, кажется, по умолчанию стоит. Если я ему
напишу C++ 17, то он скорее всего не справится. Да. Значит, G++ 9 версии не может это скопилировать,
хотя я не использую никаких фичей C++ 20, я использую только C++ 17. Это был баг G++,
он не мог это скомпилировать. G++ 11 уже может. Ну и он по умолчанию в C++ 17 компилирует.
C-Lang, по-моему, мог довольно давно. Так, ну что, есть вопросы? Но у меня оно 6 секв ловит. Ну,
в смысле, это значит, что ты что-то неправильно, в смысле оно ловит. Кто именно? Этот код, который ты
запустил, вот ты его сейчас запустил прям. Да. Так у нас есть еще одна проблема. У нас куча заглушек,
во-первых, поэтому я не удивлен. Если бы мы правильно реализовали все getIndexByType и getType
byIndex, то, может, у нас бы и работало. А у нас в конструкторе разве нет проблемы? Да, это совершенно
верно, это следующая вещь, которую надо обсудить. У нас, я вам сказал, что я забежал вперед, у нас та
проблема, которую я только что озвучил в Destructor, с обращением к полям, на самом деле ровно это же
проблема, если в конструкторе, просто мы ее не сразу заметили. И поэтому, если так написать, то это
тоже UB, потому что конструкторы родителей вызываются до конструктора наследника и до создания вообще
полей наследника. Обращаясь из конструктора родителей к полю буфер, мы ловим UB, потому что буфер,
еще его время жизни началось, и компилятор имеет право вот этот вот код просто соптимизировать и
выкинуть. Он может просто не делать эту строчку, потому что буфера еще не существует. Мы находимся
в конструкторе родителя, буфер появится как поле только тогда, когда начнет работать конструктор
наследника, то есть перед тем, как закончится конструктор родителя и после того, как закончится
конструктор родителя, перед тем, как начнет работать конструктор наследника, появится поле буфер,
до этого его нет. Как решать эту проблему? Ровно так же, как с деструктором создать
какой-нибудь констракт, который точно так же вызвать в конструкторе? Да, можно так решить эту
проблему, то есть, нет, стоп, в каком конструкторе? В конструкторе самого варианта. А он будет от чего
этот конструктор? От шаблонного параметра любого не пойдет? Да, от шаблонного параметра,
а дальше выберется оптимальная перегрузка. Как это она выберется? А нет, сейчас при
постановке. Будет ровно эта проблема, то есть, если мы опять заведем здесь шаблон, то есть,
мы эту всю байду с наследованием затеяли как раз для того, чтобы у нас перегрузка в конструкторах
правильно работала. Если мы сейчас опять напишем вот так и здесь будем делать констракт, то как он
поймет, какой ты активировать? Нет, очень плохо, что эта пара не очень. Я сам очень жалею, на самом
деле. Ну вот давайте тогда сделаем, что у нас у специализации вариант чойса. Чего еще у тебя?
Мы можем сделать у варианта чойса специализацию, что если это, конечно, самый последний вариант
чойс, то тогда у него будет как раз-таки этот массивчик, а не у самого. Какой массивчик? Что? Так,
подожди. Сейчас, а что значит специализацию вариант чойса? Специализацию для каких типов? То есть,
ты хочешь сделать специализацию вариант чойса на случай, если ты это последний в пакете types.
Давайте создадим статистическую версию бушера. Подожди, подожди, подожди, подожди. Как это вообще
синтоксически напишешь? Специализация может быть только для как? Ты хочешь написать вот здесь
что? Допустим, я специализацию пишу. Как это написать? Вариант чойс от каких-то конкретных… Ну,
то есть, что здесь написать специализацию? Давайте еще третий параметр номер. Несколько осталось.
Так, и что? И я не понимаю, все равно как это написать? Как частичная специализация, она может
быть если ты фиксируешь какие-то параметры или если ты там у тебя… Я совершенно не понимаю,
как это сделать. Мы зафиксируем, что если у нас… Ну, самый первый вариант чойса будем создавать…
Первый параметр делать size of многоточие types. Так что ли? Типа специализация на случай,
если первое число это size of многоточие types, а дальше эти сами types пошли, да? Так что ли?
Ну да. Я не уверен, что это скомпилируется. Я не уверен, что можно expression делать там.
Нет, нельзя, но можно типа сделать ровно обратную штуку, что не с какой индекс,
а сколько до конца осталось, чтобы оно скомпилировалось со специализацией для нуля,
видимо. И в такой специализации уже делать буфер? Типа того. Кажется, буфер надо делать
чтобы он сконструировался раньше всех. Я предложу вам идею попроще. Как вы хотите
конструировать буфер до того, как мы начали вариант? Я предложу вам идею попроще. На
самом деле я просто сделаю еще одного наследника. Жесть, что? Да нет, все нормально как раз.
У меня будет вот такое наследование. У меня будет отдельный класс VariantStorage,
который будет хранить буфер и заодно предоставлять разные удобные методы для доступа к этому буферу.
И он все равно уничтожится раньше, чем наши типы? Нет, он не уничтожится раньше, чем наши типы.
Дестрои? Нет, он уничтожится позже. И вот сюда перенесу вот это.
Да и CurrentIndex тоже мне перенести надо будет сюда,
потому что к нему я тоже хочу обращаться из VariantChoice.
Вот и на самом деле, теперь, когда я создаю Variant, в первую очередь создается VariantStorage,
потом начинаются создаваться VariantChoice, потом только сам Variant. Если я теперь из VariantChoice
обращаюсь к буферу или CurrentIndex, то это корректно, потому что к моменту,
когда создаются VariantChoice, VariantStorage уже создан. Если я из Дестроя обращаюсь к вот этим штукам,
но это тем более корректно, потому что у меня еще Variant существует, а значит и Buffer и CurrentIndex существуют.
То есть вот теперь я, сейчас я правда не уверен, что это скомпилируется, как обычно. Нет, компилируется нормально,
но потому что эти поля Buffer и CurrentIndex, они есть у Variant, потому что есть у VariantStorage, там все публичное.
А, минуточку, нет, подождите, мне надо вот это удалить. Ну да, компилируется. Даже C++17 компилируется.
А, вопросы. Ну раз теперь есть storage, то можно и без дестроя. Да, дестрои можно. Сейчас,
он будет уничтожаться от последнего родителя к первому. А как без дестроя это сделать? Подождите,
я не понимаю как это без дестроя сделать? В плане, у нас же storage будет уничтожаться.
Будет уничтожаться от последнего родителя к первому или как? Да, он уже после первого
уничтожает родителей, поэтому storage уже последний, поэтому он всегда будет.
Ну тогда variant storage нужно тоже... Нет, подождите, не понимаю, как вы предлагаете сделать без
destroy? Я не понимаю, вы предлагаете в variant storage написать destroy или что?
Вернуть обратно destroy в destructora, потому что они будут вызываться до того,
как будет уничтожен variant storage. В смысле, вот здесь сделать просто destructor, что ли?
Ну да, как мы изначально это в destructora делали, потому что теперь там убэ не будет,
потому что buffer еще не будет уничтожен. Сейчас, давайте подумаем, правда ли это?
Вообще кажется, правда. В смысле, мы же здесь quarantine index обращаемся, а не к buffer. У нас убэ из-за этого.
Не, ну quarantine index тоже в storage лежит теперь. Ну так это не with variant, а сейчас.
Да, ну вообще кажется, что... И вам нужно будет делать эту штуку не от варианта, а от variant storage,
тогда, видимо, deriving. Ну или сделать просто using другой.
Мне все равно не очень нравится это, потому что мы как бы обращаемся к this variant, как будто это variant,
хотя на самом деле destructor variant уже вызвался. И так нельзя, я думаю.
Сейчас еще как мы адрес получим в этой штуке? Ведь тут-то мы его пользовали.
Смотрите, почему мне кажется, почему мне не нравится то, что вы предлагаете.
Как я могу кастовать к storage, если я не наследник storage?
Не, ну может, конечно, reinterpret custom кастовать к storage.
Мы же точно животной памяти, поэтому давайте reinterpret custom.
Мы не знаем, что с адресом. Там же, может быть, все что угодно, еще size of и так далее.
Сейчас, вы говорите, что можно сделать reinterpret custom к variant storage, потому что мы это точно variant storage,
и мы начинаемся на той же памяти. Ну потому что, кроме как variant storage, ни у чего болей нет.
Ну, наверное, да. Наверное, так можно. Наверное, так должно сработать.
Ну, так или иначе, в общем, есть разные способы это сделать. Наверное, способ
через reinterpret custom variant storage работает. Но работает и то, что здесь написано. Вот.
Из деструктора обращаться к thisVariant как к derived, мне кажется, это все равно уб,
потому что формально thisVariant уже не является variant, поскольку его деструктор
как variant уже был вызван, и обращаться к нему через точку, как будто он объект variant,
кажется неправильно. Кажется, формально это может быть уб. Хотя я не до конца уверен,
но на всякий случай я бы лучше так не писал. Сейчас, у нас приватное наследование от variant storage, так?
У нас вот написано, и что? Поэтому variant choice не видит, что у нас есть поля из variant storage.
Естественно. Но мы при этом не обращаемся внутри. Потому что thisVariant это derived,
derived это variant. Мы скастовали себя к варианту, а у варианта уже есть поля variant storage.
Так, ну ладно, господа. На самом деле, мы почти все обсудили, что касалось варианта.
Мы, правда, не обсудили, как visit реализовать. Мы не обсудили еще одну важную проблему,
которая присуща не только нашей реализации в variant, но и нашей реализации в function.
Я не буду, ну сейчас, на сегодня все, давайте, то есть до конца мы все-таки не успели,
но ничего страшного. Давайте вам анонсирую проблему, которую нам предстоит решить следующей.
На самом деле, последнее время мы с вами занимаемся такой интересной вещью. Мы берем и
заводим массив чаров, вызываем там конструктор некоторого типа, потом вызываем деструктор этого
типа и конструктор другого типа. По сути, мы это делаем, правда? На самом деле, так делать это UB.
Вообще говоря, по стандарту нельзя брать на какие-то байты класть некоторый тип,
уничтожать его, а потом класть другой тип на эти же байты. Компилятор имеет право, если вы положили
какой-то тип туда, то без некоторых дополнительных оговорок, предположений, компилятор имеет право
считать, что этот тип там дальше и лежит. И нельзя по этой же памяти динамической убрать,
даже не обязательно динамической, нельзя. Если вы сделали плейсинг-дю на какой-то адрес какого-то
типа, то в дальнейшем коде компилятор имеет право предполагать, что там он и лежит, этот тип,
и оптимизировать обращение к нему, как если бы он там продолжал. Компилятор предполагает,
так давно это изначально было так сделано, была такая оптимизация, компилятор предполагает,
вообще говоря, что тип по данному адресу, по которому вы плейсинг-дю сделали, до тех пор,
пока переменная живет, не меняется. Если вы завели переменную какую-то, под ней что-то лежит,
компилятор предполагает, что тип не меняется. Ну потому что смотрите, иначе что можно было
бы делать. Представьте, что я такое сделал и сказал, ну я не знаю, типа, вот я сказал там,
char, буфер размера 16, потом сказал new, буфер, не знаю, int от 5, потом я вызвал какую-нибудь
функцию g, а потом решил вывести, я вот так сказал, int звездочка pr равно new, буфер int 5,
а потом я решил, что сделать. Сейчас я подумаю, как мне бы пример написать, чтобы это было
не так. Пример другой должен быть. Вот представим, что у меня был класс b и класс derived. Вот я сделал
derived d, допустим, на какой-то памяти, derived d равно new derived от чего-то, потом вызвал какую-то
функцию, а потом сделал d, стрелочка метод. Вот. Вот если бы вы были компилятором, вы бы предполагали,
что по d лежит derived или нет, или возможно там что-то другое сейчас лежит, например, base.
Смысл в чем? Если derived это полиморфный класс, то вызов его методов требует
прыжка в проходах в таблицу виртуальных функций. Но если у вас вот такой код написан,
компилятор делает так называемую девиртуализацию, ну точнее имеет право делать. Он увидел, что вы
изначально создали это d как derived, дальше вы что-то поделали, а потом к этому d обращаетесь
как к методу. Если при этом у вас derived — это наследник base и больше никого в иерархии наследования
нет, компилятор здесь имеет право сразу вызывать нужный метод, а не идти в таблицу виртуальных
методов смотреть, какой именно вызвать. Потому что вы создали d как derived и вызываете сразу
же у него, спустя некоторое время в той же области видимости вызываете у него какой-то метод. Зачем
компилятору идти в таблицу виртуальных функций? Если компилятор так знает, что вы уже создали
derived на этой памяти, от derived никто больше не наследуется, и вы d вызываете, как полагается,
через стрелочку. Но это логичное предположение, не так ли? А если бы от derived кто-то наследовался?
Даже если никто не наследовался, тем более. Это логичное предположение, не правда ли?
Казалось бы, если вы сделали так и вот потом так, то не нужно идти в таблицу виртуальных функций,
чтобы узнать, кто там лежит на самом деле. Вы там derived создали, зачем идти в таблицу виртуальных
функций проверять? Это оптимизация, которая называется девиртуализация, которую компиляторы из поколен веков
умеют делать. Так? Давайте кто-нибудь скажите, да, типа вот мне нужны возгласы одобрительные.
Они, возможно, так умеют делать. Вот, умеют. Но если бы мы с вами разрешили динамически менять тип того,
что лежит по данному адресу через пару вызов диструктора, вызов конструктора, компилятор от
функции g, представьте, что функция g выглядит так теперь. Вот смотрите, у меня функция g допустим
выглядит так. Ну туда можно передать, видимо, указатель на d. Да, функция g, которая берет,
ну да, функция g, допустим, от этого d, ну или от самого d. Функция g от d, которая говорит,
не знаю, она принимает ссылку на base и делает следующее. Она говорит,
или даже ссылку на derived, и говорит d, стрелочка tilde derived, а потом new по адресу d,
base и все. Как вам такое? Ну, компилятор подразумевает, что такого не происходит,
что если вы создали derived, то вы внезапно не вызовете диструктор и не подложите новый тип
ему, потому что компилятор хочет уметь оптимизировать вызовы виртуальной функции,
например, вот в такой ситуации. Отсюда следующее правило, если вы по данному адресу имели
какой-то тип, а потом уничтожили его диструктором и плейсментом u, положили другой тип, то вообще
говоря, обращение потом к методам этого типа, это уб, потому что компилятор имеет право предполагать,
что вы не подменяете тип вот так вот незаметно для него, пока он в одной и той же области
видимости к нему обращается. Сейчас, но если в другую область видимости? И если в другой области
видимости тоже. Если вы создали как derived, компилятор имеет право, с некоторыми оговорками,
это сложный разговор, но он имеет право запомнить некоторыми оговорками, что там лежал именно такой
тип. И если вдруг в какой-то момент тип поменялся, компилятор офигеет. Короче, нельзя так просто
брать и подменять тип того, что лежит по данному адресу. То есть, короче, если я сазал char вот этот
массив из чаров, то все, я тогда не могу класть ничего. Нет, если ты по адресу массива из чаров
в частности наш лист это сплошное b. Нет. Чего? Какой лист? А где у вас там массив из чаров?
Где у вас лист? Там аллокатор. Что? Какой аллокатор? Аллокатор и внутри массив из чаров. И что? Как он не
переиспользует память с другими типами? Ну, если вы вызвали конструктор некоторого
типа на какой-то памяти, а потом сделали деструктор конструктор другого типа, вот это убе. Нет,
на массив чаров можно класть. Но чар это же тоже тип, и он вызвал свой конструктор,
когда я его... Нет, на массив чаров можно класть. Короче. Как это работает, я не понимаю.
Формально и правильно очень сложно. Так, давайте на сегодня все. У нас время ушло. Если на массив
стрингов, то уже будет убе. Ну, типа, блин. На массив чаров класть другой тип можно. Если вы на
массив чаров вызвали конструктор какого-то типа, конструктор именно, не просто int положили,
а конструктор чего-то вызвали, а потом вызвали деструктор и конструктор чего-то другого,
и стали обращаться к нему как к чему-то другому. Вот это убе. И на массив int-ов аналогично. На
массив int-ов я не уверен. С массивом чаров там особое правило, по-моему. Но, по-моему, на массив
int-ов нормально тоже. В общем, это проблема. Ну, я ее сейчас озвучил, а решать ее будем мы в
следующий раз. Вот. Но пока на сегодня все. А Валатай, он не поможет? Оно же заставляет бегать в память каждый раз.
Не знаю, кстати. Думаю, что нет, но не уверен. Ну, короче, давайте все на сегодня. Я не уверен,
что Валатайл это исправит. Хотя, может быть. Ну да, я согласен, что Валатайл решает похожую
проблему, но все-таки там немного другая проблема. Вот. Могу ли я прислать код, который могу прислать?
Честно говоря, мне не хочется прислать вам этот код, потому что мне кажется, что полезно написать код самому.
Главное, запись выложу. Запись-то, понятно, я выложу. Мне просто кажется, что когда вы пишете код сами,
вы его лучше понимаете. Просто когда вы, если вы просто скопипастите все то, что я написал,
вы не очень можете осознать, как оно работает. Я переписывал с доски, но у меня не компилируется.
А вот когда вы сами начнете писать, повторять все это своими руками, это гораздо лучше. Вы задумываетесь
невольно над каждой строчкой, и таким образом вы понимаете. Я не хочу прислать код именно поэтому,
потому что мне кажется, полезно напечатать это самому хотя бы раз, чтобы понять, что происходит.
Иначе вы просто такие, а я скопипастил, ничего не понял, но вроде работает. Потому что вам нужно,
конечно, будет добавлять туда свои функции, свои методы и так далее. И лучше для этой цели,
мне кажется, чтобы вы сами это напечатали. Код по лямбдо-функциям. Код по лямбдо-функциям,
да, это я могу прислать. Ну вот, такие дела. На сегодня все.
