Так, поехали. Лекция хронологически седьмая, идея на шестая. Так, мы сегодня закончим с
мы говорить про ЛЦА. Это первое. Второе мы начнем, видимо, о потоке говорить. Так,
окей. Первый раздел это вообще сведение. Потом подумаем, кого-кому сводить будем.
Еще у нас будет сведение в обе стороны. Будем учиться зная, как решать РМК и ЛЦА и наоборот.
Вот, окей. Так, ну давайте научимся решать ЛЦА зная РМК. Так, давайте тогда зная РМК решать
ЛЦА. Вот, что мы хотим. Давайте рассмотрим дерево какое-нибудь произвольное. Да,
какое-нибудь такое дерево. Вот, я пронумеровал его вершины в ходе обхода ДФС. Вот первое,
второе, третье. Это уже посещено. Четвертое, пятое. Зачем все вверх? Шестое. Зачем все вверх? Вверх
семь. Вверх. Понятно логика. Вот так, нам потребуется несколько массивов. Давайте взаим их как-нибудь,
наверное. Так, окей. Вообще вот такой вот обход. Вот такой вот ДФС. Сейчас мы будем
выписывать массив именно вершинок, которые мы прямо встречаем. Явно каждый шаг. Это
будет называться Эллеров обход дерева или по-английски Эллер Тур 3. Эллеров обход дерева.
Давайте выпишем массив этого обхода. Так, на первом месте единичка, потому что мы сначала
единиц находимся. Затем двойка, тройка, двойка, четверка, пятерка, четверка,
шестерка, снова прыгаем вверх, снова вверх, четыре, два, семь, два, один, восемь, девять, восемь, один.
Чем этот обход хорош? Тем, что в нем под дерево и под отрезок. Доказывается непосредственно по
лемме белых путях внезапно. То есть вы выделяете какую-то вершинку, смотрите какой-то под отрезок,
выделяем вершинку четыре. Вот берем самое левое и самое правое вхождение четверки в этот массив.
Вот он раз, два. Утверждается, что вот здесь вот выписан Эллеров обход под дерево четверки.
Ну просто по лемме белых путях, когда вы входите в четверку, вас достижим по белым путям, из нее
только вот пять и шесть, все, больше никто. Вот, к моменту, когда вы покрасили четверку в черный,
то есть к моменту последнего вхождения, у вас уже эти должны быть покрашены, поэтому они все находятся
внутри под отрезки. Так, дальше нам понадобится массив H. H это массив высот.
Так, изначально у нас давайте это будет уровень 0, уровень 1, уровень 2, это уровень 3, соответственно.
Так, 1, 2, 3, 2, 3, 2, 1, 2, 1, 0, 1, 2, 1, 0, это массив высот. Так, давайте сразу вопросом на засыпку пока,
сколько, какой длины будет вообще массив этого Эллерового обхода, если вам дону дерево? 2e плюс 1
или 2v минус 1? Так, окей, теперь последнее, что я хочу, это, назовем массив first, first it и давайте
подпишем здесь. Ну, по сути, это будет равно то ину этой вершинки, то есть это будет индекс,
когда мы впервые ее встретили в массиве Эллерового обхода. Ну, единичку мы встретили на нуле,
понятное дело, потому что мы в ней сразу находимся. Дальше в двойку и в тройку мы прыгаем
последовательно. А теперь в четверку, 0, 1, 2, 3, 4, 5, 5 получится, 0 это 1, это 2, это 3, 4,
вершинки же с единички номируются. Так, шестая вершинка 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14.
Вот такие вот у нас индексы получились. А что теперь? Ну, не знаю, я привык его first обозначать
в этом контексте, что это как бы первое вхождение в наш массив. Ну, таин это как бы время входа,
а здесь у вас именно в массив первое вхождение. Вот это такое. Филистическое просто. Ну,
теперь давайте пробулируем утверждение, что ли, которое вроде очевидно плюс-минус.
Чему равно са-ту-ве? Это будет... ух, сейчас. Не совсем. Это будет... ну, давайте будем писать,
да. РМК на отрезке по И лежащем. First от У, first от В. От чего? От аш-итых. Это получу минимум
высоты. Теперь я хочу взять ее индекс. Давайте Арк РМК напишем. То есть он возвращает там индекс,
где достигалось значение минимума. И возьму от этого еще всего вот эту штуку. Получу ответ.
По такой формуле можно ЛЦА посчитать. Давайте разбирать эту формулу по частям. Так, УВ берется
first от У и first от В. Почему это так? Потому что ЛЦА предположим, что мы У посетили первее,
чем В. Просто для определенности, что у нас этот отрезок существовал,
значит он просто у ИВ свапник. Вот так. Если мы сначала постили У, потом постили В, то очевидно,
что мы должны были... когда мы вышли из У, мы сначала прошли через ЛЦА, потом через В. Иначе
просто быть не могло. То есть DFS, который айлеров, посещает первым действием вершина У,
вторым действием ЛЦА от УВ, и третья вершина В. Поэтому ЛЦА находится где-то на подотреске,
с одной стороны. С другой стороны, ЛЦА должна обладать минимум глубины на этом подотреске.
Почему это так? Потому что выше вы не будете выпрыгивать просто в ходе DFS. А ниже не будет
ЛЦА, потому что вершина есть под деревьях. Здесь надо просто аккуратно посмотреть глазами,
понять, что это очевидно. Но раз мы знаем тогда индекс, где достигается минимум по высоте,
мы можем взять краски-вершинку, которая в нужном нам месте находится. Ну все, что тогда мы можем
делать? Как решать задачу ЛЦА? Давайте выпишем вот эти вот массивы, три штуки. Построим по
массиве H разреженную таблицу. Зен Луген. Предподсчет. Ответ на запрос, за сколько разреженная таблица
он даст? За единицу, да. Индекс минимума тоже он может дать, если вы будете его явно сохранять в
ответе. Вот, поэтому это за единицу, это за единицу. То есть ответ. Вот единица. Окей.
Плюс-минус то, что требовалось сделать задачи G в контесте. Ну есть те, кто читерски загнал,
поэтому ее надо будет отправить на ревью и забанить всем. Вот. РМК это минимум, а ARC это где
у тебя достигается минимум? В нашем случае это индекс минимума. Так, окей. Что теперь хотим? Долго.
Давайте ускорять. Сейчас мы будем 30 минут ускорять вот эту штуку до линии. Может больше. А давайте
в обратную сторону сводить. Знаю LCA, решать RMQ. Здесь нам придется вспомнить нашу прекрасную
конструкцию. Помните, что такое декартовый дерево? Давайте строить его. Построим декартовое дерево.
Построим DDNK, декартовое дерево по явному ключу, где приоритеты аиты. Так, еще раз. Мы хотим
уметь решать RMQ, уметь решать LCA. Наша задача. Если мы хотим решать RMQ, значит что у нас дано? Нам
дано массив. И там какие-то запросы к нему. Аита это массив. Например, вот наш массив прекрасный.
Как строилось декартовое дерево по явному ключу? Тут, понятно, какие-то элементы еще есть. Но нам
есть приоритеты. Брался максимальный из них, тут минимальный из них и объявлялся, что он в корне
находится. У него должен быть самый минимальный приоритет, потому что декартовое дерево по
приоритетам это все еще куча. Давайте я еще индексами добавлю. Это будет аиты, это и. Чтобы я мог пары
писать. То есть первая пара у меня будет это 6, 0. Тогда в ее правом по дереву все, что правее,
а в левом все, что левее. В правом по дереву остается только пара 7, 3. А в левом по дереву
выбирается снова минимальный чувак. Но из них там кто-то один будет корнем. Давайте этот для
разнообразия. Мы с вами разделили массивно вот такие вот кусочки. Причем этот забрали,
этот забрали и этот забрали. Тогда в правом по дереве этого узла находятся вот эти вот две
штуки. Минимальный двойка здесь 2, 5. И у него левый 4, 5. Нет, я пишу слева индекс.
Да. Спасибо. У меня слева у меня пары и аиты.
Нет, 6, 0 нормально написано. И 7, 3 нормально написано.
Так еще раз. Здесь будет у нас 3, 1. Здесь правее будет. Нет, будет в корне тот, у кого минимум по
приоритету. 4, 5. А нет, мы же смотрим приоритет по значению. 5, 2. И здесь будет тогда 4, 5. Все,
разбрались. Так, а слева остается вот эта вот штука. Здесь будет 0, 1. И у него в правом по дереве вот
это вот. Это будет то, у нас будет стройка в корне 1, 3. И у него правый сын 2, 7. Получили вот такое
вот дерево. Я утверждаю, что если вы возьмете две вершины И, Ж какие-то, два индекса, найдете эти
узлы в дереве, то есть вот он 2, 7. Это И, 5, 2 это Ж. То я утверждаю, что минимум это ЛЦА. Вот ЛЦА в
каком дереве это 3, 1. И это будет минимум на этом подотреске И, Ж. Минимум их темпоаитам, то есть вот он.
Ну это он и есть. 3, 1. Это и ХЛЦА. То есть я утверждаю, что РМКУ от И до Ж. Ну МИН точнее можно описать.
МИН по наотреске И, Ж и закатах. Это будет ЛЦА
В ИТ и В Ж. То есть В ИТ и В Ж это вершинки дерева. Вершины соответствующие элементам.
Вот мы ввели в обратную сторону. То есть умеем решать РМКУ, умеем решать ЛЦА.
Но остался последний штрих. Это ускорить РМКУ. Так, второй шаг. РМКУ плюс-минус 1.
Поставка такая. Пусть массивя А1, АН для любого И от 1 до N минус 1, АИ плюс 1.
Вот такого утверждения верно. Средние элементы отличаются ровно на единицу по модулю.
То есть не могут быть как больше единиц, так меньше на единицу. То есть, например, вот такой массив нас устраивает.
Если бы здесь что-то поменять, то уже не будет устраивать. Вот.
Вот я утверждаю, что на таком массиве умею решать РМКУ за линейный предпочет и за константный ответ.
Просто это модуль заканчивается. Просто И.
Вот. Мы сейчас покажем, как эту штуку за линию строить. Из-за единицы отвечать на запрос.
Потом скажем, что вот у нас есть массив Высот, потом мы применим кучу сведений, все это вместе скомпонуем и получим РМКУ за ОТН на предпочет и от единицы на ответ.
Да, план у нас страшный. Ну давайте поймем, как устроен вообще запрос РМКУ.
Разобьем на блоке давайте длины К.
То есть вот наш был массив.
Ну быть может не на целом там последний блок не хватит там такая, это не очень важно.
Вот. Давайте посмотрим, как могут быть устроены запросы.
В первом случае запросы могут быть устроены как-то вот так вот.
То есть они затрагивают какое-то количество блоков целиком, плюс суффикс блока, плюс префикс блока.
Это какое-то количество целых блоков.
Второе это суффикс блока.
Третье это префикс блока.
Знаете, что сейчас сделаем? Давайте научимся сначала с первой категории работать.
Ну давайте найдем на каждом блоке минимум его позицию.
Это в отдельном случае мы его разберем еще.
Так.
Да, мы ищем в самом блоке ответ.
Посчитаем для каждого блока.
Минимум на нем.
Вроде нам позиция не понадобится, если понадобится, то допишем, что и позицию надо посчитать.
Так.
Но у нас же этих блоков может быть много подряд.
То есть у нас может быть целый подотрезок взят.
Значит нам нужно отвечать на подотрезки минимум.
Раз нам нужно отвечать минимум на подотрезки, то что мы хотим?
На них построим обычную разреженную таблицу.
Обычную.
Будьте здоровы.
Так, разреженную таблицу.
Пока что будем писать в терминах k симптотики, потом подберем оптимальное k, чтобы все сошлось.
Сколько у нас блоков?
n делить на k.
По строению у нас отнимается вот столько вот тогда.
Окей.
Нет, вы нашли в каждом блоке минимум.
То есть вы знаете, что минимум где-то тут здесь, например.
Здесь тут здесь где-нибудь.
Здесь вот здесь.
Потом вы взяли эти минимумы и на них построили разреженную таблицу.
Потому что нам нужно отвечать на подотрезок блоков.
Так, что второе, как со вторым и третьим?
Давайте напишем, что 4 здесь еще будет.
Это подотрезок блока.
Подотрезок блока у вас затрагивается, когда у вас запрос целиком внутри одного блока.
Понятно, да?
Определение.
Блок.
АИТ и АИ плюс карты.
Это нормализованный?
Если
АИТ равен нулю.
Если
АИТ равен нулю.
В чем прикол?
Нормализованных блоков.
Прикол у них очень простой.
Их не очень много.
Нормализованных блоков.
2 степени К-1.
Это очевидно или надо пояснить почему?
Ну, смотрите.
У вас каждый блок, раз все начинается с нуля,
он имеет вот такой вот вид.
Тогда можно выписать плюс один, плюс один,
минус один, минус один,
минус один.
Массив последовательных разностей.
При этом они принимают лишь одно из двух значений.
Либо один, либо плюс один, либо минус один.
Давайте закодируем просто двичную записью,
а разность у вас на минус один.
Нет, вообще вот посчитать многообразие.
Я покажу, что мне даже с такой лихвой хватит.
Я уложусь в линию.
Вот как бы плюс-минус один это вообще не считает.
Давайте я посчитаю просто.
Посчитаем на каждом
каждом подотрезке
каждом подотрезке
каждом подотрезке
каждом подотрезке
каждом подотрезке
каждого блока
минимум
за от К квадрат
на два степняка минус один.
Ну красота, да?
Не, нормально, мы сейчас подгоним К, чтобы сошлось все.
Вы согласны, что если я знаю
минимум и его позицию?
Вот как раз-таки знаю
для каждого блока
вот там вот нарисованных
к какому классу он относится
то есть вот эту кодировку
плюс-минус один, я могу четко
получить позицию его минимума.
А вот позиция минимума не зависит
от того, нормализовали ли мы блок,
то есть приводили ли мы аи-т
или нет.
Вроде очевидная идея.
Что мы делаем?
Вот мы взяли блоки, мы для каждого из них
посчитали плюс-минус один, соседняя разность.
Мы для всех возможных блоков
посчитали позицию минимума,
потом взяли какой-то блок,
вычисли из него аи-ты,
чтобы нормализовать его,
чтобы аи-ты оказался равной нулю, то есть блок из массива.
Потом такие ага,
мы знаем для него ответ
на подотрезке, на префиксе
или на суффиксе, где именно лежит минимум.
Мы знаем позицию.
Ну все, тогда я знаю ответ
для конкретной этой части.
То есть если я опять же разбиваю
этот массив на подзапросы,
то я умел вот это
вот делать, это наша первая
часть была.
Теперь мы научились
вот так вот отвечать на вот этих
вот двух частях.
Опять же,
это мы научились делать за О от единицы,
потому что мы просто все предпочитали.
А вот на подотрезках у нас
разрезанная таблица за О от единицы
отвечает, да?
Кого?
Да.
Потом я еще заранее
за линию посчитал, для каждого блока
к кому класса он относится.
Ну вот мы посчитали
для того блока,
что у него минимум за краем ответа.
Нет, я для каждого подотрезка блока
знаю ответ.
У меня же там как квадрат умножается еще.
Ну что, коллеги, осталось совсем немножко.
Согласно тогда, что имея всю эту информацию
из О от единицы, у меня получает ответ
на произвольный запрос.
Но осталось это в линию превратить.
А давайте
Итого.
Я получаю
от
n делить на k
log n делить на k
плюс k квадрат
на 2 в кат и минус 1.
Теперь самая тонкая
хитрость, так сказать.
Возьмем вот такое k.
Вот здесь очень важна одна вторая сейчас будет.
Поймете, где она вылезет.
Так, считаем.
От n делить на
1 вторую log
двоичный n
logarithm n делить на
1 вторую
log двоичный m
плюс
1 четвертая
log двоичный n
квадрат
на 2 в степени
1 вторая log двоичный n
минус
минус 1.
Давайте упрощать.
Так, здесь я
позволю на одну вторую забить.
Потому что это просто будет
двойка вылезет в числителе.
Так, дальше
что я могу себе позволить сказать?
Здесь я могу себе позволить сказать, что
вот это вот все
оно
не превосходит n.
Согласны?
Ну, n делить на log n он как бы меньше n.
Поэтому я здесь могу просто написать
на log n.
Плюс
так, константа нас не интересует.
Здесь константа тоже не интересует.
Поэтому остается
1 четвертая log квадрат m
на 2 в степени
1 вторая log двоичный n.
Ну,
здесь я должен перейти к логарифму
по другому основанию, но это константа,
поэтому на нее тоже забиваю.
Теперь смотрим, что происходит здесь.
Квадрат логарифма
умножить на корень из m.
Как мы с вами знаем, корень из m
к логарифму это o от n.
Конец.
Все, победа.
То есть мы просто хитро подобрали k.
Вот здесь вот эта вот тоненькая 1 вторая,
которая сделала вам здесь не n,
а здесь корень она оставила.
Так, окей.
То есть это вот, что мы с вами научились делать.
Мы с вами научились
сводить lc к rmq,
rmq к lc,
rmq плюс минус 1.
Но осталось последнее,
это суметь вытереть
третью доску,
чтобы дописать
окончательно то, что мы хотели,
в чем мы добивались все это время.
rmq
за
пару
o от n, o от единицы.
То есть
временный предподсчет, временный запрос.
Ну что мы с вами делаем
первым шагом?
Хочется свести,
знаете,
rmq к чему-нибудь.
Рмq к lc сводить,
да?
То есть умею решать lc,
умеем решать rmq, да?
Помните, это вот декартовые деревья.
То есть первый шаг.
Сводим
rmq
к lc.
Строим
ddnk.
Шаг второй.
Давайте
сведем lc к rmq
уже этим способом.
Потому что здесь мы ищем rmq
на массиве h.
То есть сводим
lc к
rmq
плюс-минус один.
Эллеров обхода
примерно.
Шаг третий.
Решаем rmq
плюс-минус один.
А, я забыл сказать,
этот прекрасный алгоритм
с оценочкой по времени
называется
вот так вот.
По a, по фамилиям.
Farah Colton и Bender.
Это два чувакатки.
Один Farah Colton, другой Bender.
То есть этот алгоритм, который считает блоки
ddnk,
на них парсы, потом
на каждом из блоков суффиксы,
это вот эти два чувака придумали.
Вот. То есть как бы здесь
теперь что мы научились с вами делать? Как отвечать на запрос?
Вы такие, окей, ответ на запрос, тогда это просто делаем
все то же самое.
Нам говорят под отрезок, мы ищем нужные нам
вершинки в lc.
Нужные вершинки в lc мы ищем
вот это вот схеме.
Отвечаем с помощью
Farah Colton и Bender на запрос.
Дальше обратно возвращаем ответ.
Получили ответ какой-то
индекс.
Индекс нам говорит вершинку, вершинка нам говорит
собственно номер
ответа.
Там ничего сложного.
Кое-то это не надо, будет сразу я вас предупреждаю.
Это первое
такое радостное для вас замечание. Второе радостное
замечание то, что
по сути дела мы все это изучали
ради того, что можно сводить
вот это вот сведение.
Почему? Ну потому что
если вы построите декартовое дерево
по неявному ключу на массиве,
на вот этих вот массивах,
то в целом можно брать и что делать?
Ну переподвешивать под деревья.
Ну просто взять вот отрезок
соответствующего по дереву, подвесить его к вершине
в 8.
И все, ничего не изменится.
Вам все также надо будет искать минимум на отрезке,
а декартовое дерево по неявному ключу
позволит вам просто переставлять под отрезки, например.
Та же задача у вас, которая последняя в контесте
про удаление и добавление вершин,
изначально предполагаю, что вы напишете через это.
Но хитрые гении
написали хитро-гениально.
Что меня конечно разочаровало.
В следующем году
будет задача типа
переподвешивать под деревья и копировать ветки.
Зачем это вообще нужно?
Задумайтесь.
Есть такая классная команда Git Rebase.
Она берет и
переподвешивает какой-то комит к другому комиту.
Она берет под дерево
и переподвешивает его к другому под дереву.
Вот если нужно это делать очень быстро,
Git Rebase
вообще медленная операция,
то это можно вот так вот делать.
Но там это
конечно так не делается в силу других причин.
Но
как сам факт, это можно делать вот так вот.
Также можно копировать ветки
или черепикать их.
Тоже самое будет.
Ладно.
В общем-то
мы закончили
менясто, ВЛЦА и вот эту всю лобуду.
Наконец-то начались
серьезные темы.
Потому что сейчас пока что это был такой
семестер, мы только вкатывались в темы нормальные.
Теперь мы дошли до содержательных тем.
Это потоки.
Был план рассказывать
про сочетание потоки.
Но я посмотрел на лекции и понял, что там еще
10 мая выпадает.
Мне крайне не хочется 10 мая искать
доп-лекцию.
Потому что это будет конец семестра,
у вас зачетная неделя, вы все будете
заняты чем-то там.
И устраивать вам еще время на доп-лекцию вообще не хочется.
Поэтому было решено, что
мы не будем рассказывать
про сочетание на лекции,
а они будут семинарским материалом.
Попадет, потому что мы научимся их
решать через потоки просто.
Конечно.
Нет. Не, на экзамен
не попадет, потому что это на лекции нет.
Это попадет
в контесты и в семинары,
потому что вам на семинарах расскажут
один способ как решать, а потом расскажут,
как через потоки это делать.
План такой.
В чем мотивация потоков?
Мотивация возникла
из того, что у вас
графы это, конечно, круто искать в кратчайшей пути,
но давайте нарисуем что-нибудь такое.
Вот это сеть городов,
карта.
И мы знаем, что здесь
могут проезжать 6 машин,
в единицу времени здесь 10,
здесь там 3,
здесь 7, здесь 5.
Как вопрос в том,
сколько можно от старта до финиша
максимально опустить машин?
Откуда возникла эта идея?
Идея возникает в том,
разный грузоперевозок.
У вас есть карта грузоперевозок
между городами,
вы знаете, что на каких-то маршрутах
можете пустить не больше, чем
определенные числа автомобилей.
Вы хотите понять,
какая у вас максимальная пропускная способность
от склада до магазина?
Не очевидно, как
пускать поток машин.
Да, мы считаем,
что поток дискретный.
Нет, не так, будем считать, что поток непрерывный
в общем случае, однако здесь все-таки машинки
дискретные, пускать
одну треть машинки не очень
интеллектуальное занятие.
Нет, нельзя.
А, ну можно, да, окей.
Отлично.
Типа вот такого вот.
Ну не очевидно.
Не, ну понятно, что больше 9
не получится.
Ну, понятно.
Ну да, окей, хорошо.
Ну это потому, что сети маленькие.
Но сети там будут внезапно чуть-чуть побольше
все-таки.
Я не про пропускную способность.
Нет, там будет до 100 обычно
по вершинам ребер.
Потому что у нас сейчас будут алгоритмы за М в четвертый.
Там ВЕ квадрат
алгоритмы сейчас пойдут.
Да, действительно, тут люди борются уже 50
лет и не эффективно.
Так, определение.
Транспортная сеть
или просто
сеть.
Назовем.
Да, здесь я буду очень
формален во всех
формулировках и так далее.
Потому что это все-таки нам придется понимать.
Назовем N.
Такая классная буква N.
Красивая. От слова network.
Сеть.
Ух, так сейчас она будет
иметь вот такой вот вид.
G равный VE
C, S, T.
Четверка будет такая.
Где
S и T
лежат V
это
и сток
и сток
соответственно.
То есть это две вершинки.
G
это ориентированный граф.
Такой, что
давайте, ориентированный граф
без антипараллельных
ребер. Что это такое? Поясню чуть дальше.
Без антипараллельных
ребер.
Так, G определение,
с T определение осталось
C определить. C
это функция,
которая действует
из
V на V.
В общем, в случае R
плюс.
При этом
для любой пары
U, V
не из E.
C от U, V
равна 0.
То есть мы полагаем, что у нас нельзя пропускать
поток через ребер, которых нет.
Так, вроде бы
все написали. Не понятно только,
что такое антипараллельные ребра.
Определение
пара
ребер
U, V и
VU
называется антипараллельный.
Антипараллельный.
Да.
Потому что у нас G это
Orgraph. И нам
будет очень неприятно, если у нас будут
вот такие вот ситуации.
Алгоритмически оно будет разрешимо
на раз-два.
Но с точки зрения теории, лучше от этого избавиться.
Просто нам будет проще
некоторые там вещи доказывать.
И в целом понимать, как жизнь устроена.
Давайте определим поток.
Так, определение.
Поток
5n
это
такая
функция
F
из V на V
в R плюс.
Что?
Сохранены два свойства.
Точнее, она будет называть двум свойствам.
Первое
сейчас, сейчас,
так. Первое свойство
то для любой
U, V
ну, давайте даже не так.
Для любых
U, V из V
F от U, V
не превосходит C от
V.
То есть нельзя пропустить
больше, чем вмещается в ребро.
Потому что мы C определили
на V, F.
Можно писать на E.
Непринципиально. То есть тогда
вы должны определить, что у вас поток
не через ребра, не может проходить.
И там, что профессиональной способности это ноль.
Нам это будет важно
потом, потому что у нас возникнут
новые ребра.
Которые уже не из E, они будут
краски обратно ребрам из E.
Поэтому проще писать из V квадрат.
И второе свойство
сейчас, так. Здесь будет
интеллектуальнее.
Для любой вершинки V, которая
не сток и не исток
сумма по
U, V
лежащим
давайте даже не так. Зачем?
Можно написать круче.
Для любой U из V
сумма
F от U, V
равна
сумме
снова для любой U из V
равна
сумме F от U.
Вот так вот.
То есть, как это понимать?
Рассматриваются
все вершинки U и ребра U, V.
То есть вот эта вот часть
это у вас есть вершинка V
и рассматриваются все ребра
в нее.
Это вершинки U.
Тогда как эта часть
этой краски рассматривается
V
и из нее все возможные
ребра U.
То есть это значит
сколько потока в вершину втекло,
а это сколько потока из вершины
вытекло.
Фичку знаете?
Первый закон Киргофа.
То есть вот что такое поток.
Это такая функция, которая
краски удовлетворяет нашим вот этим аксемам.
В частности, когда мы тут писали какие-то машинки
это мы пускаем поток.
Что будет если пустить целую одну машинку?
Ну вот, мы будем писать,
что мы пустили, справа у нас будет
вместимость ребра, слева у нас будет
сколько поток пустили.
Это значит, что одна машинка, раз она сюда
приехала, она должна куда-то вытечь.
Допустим, сюда.
Она должна снова куда-то вытечь.
Вот, один из пяти.
Один из пяти.
Вот так вот.
Так.
Теперь нужно определить еще
одну штуку.
Что такое величина потока?
Величина потока.
Моду Лев.
Я не буду томить вас
с ожиданием.
Вот такая вот конструкция.
То есть, это сколько у вас из вершины
С вытекает из стартовой?
Это сколько в нее втекает?
Странно, зачем втекать в стартовую вершину, да?
Ну, пример такой.
Ну, пример такой.
Вот у меня такая классная сеть.
Это мне никто не запрещает
делать.
Ну, могу добавить промежуточную
вершину, не особо важно.
Нет, почему?
Ну, это вот такая вот ситуация,
когда у вас есть ребра из УВ и ВВ.
Вот, и здесь я везде построил
capacity3.
Да, пробушная способность называется capacity
по-английски, по этому букву АС.
Ну, это запрещено?
Да.
Ну, поэтому я вынужден
вводить эту штуку.
Я ограничен, так сказать,
средствами своего времени.
И своих же рассуждений.
То есть, мне никто не мешает пустить
поток величины 3 по этому циклу.
Тогда суммарно величина потока 0
все еще будет, потому что до T никто
не добирается. Абсолютно аналогично.
Не, ладно, по T
и по T по циклу пускать это что-то очень
странное.
Это слишком странно.
Конечно, можно определить, но
там вроде как все согласовано будет.
Ну, не знаю, короче, так совсем не делается.
Вот из старта можно пускать по циклу спокойно.
Так, давайте теперь разберемся.
А, ну вот, собственно, в чем
наша задача теперь будет состоять?
Мы будем учиться эту лекцию, следующую
и после следующую.
После, после следующую уже скорее всего
нет.
По заданной сети искать максимальный
поток. То есть, поток максимальной
величины.
А, давайте сформулируем, как избавляться
от антипараллельных ребер
и как работать с
множественными источниками.
Так, как избавиться от антипараллельных
ребер?
Допустим, у вас сети, где действительно есть такая
и такая штука.
Так, давайте это будет
3, а это 5.
Такую конструкцию просто
превращаем
розчерком пера.
Вот такую вот.
Почему это корректно?
Потому что, если мне
уже раздваивать вершину, надо ставить бесконечность,
потому что я хочу сквозь нее сколько угодно
поток пускать.
Ну, или можно это скопировать,
да.
Прям в том, что у вас на одной вершине может быть много
завязанных таких.
То есть, у вас может быть еще здесь.
Такая
конструкция.
Потому что это будет неправильно.
Потом будет понятно, почему.
Может быть.
Может быть.
Мне выгоднее для корректности написать бесконечность просто.
Это, смотрите,
можно оптимизировать, но здесь
оптимизация на уровне нуля.
Теоретического
выгоды гораздо больше, потому что
с этим проще жить, чем доказывать,
что это корректно и писать какое-то число.
Бесконечность гораздо корректнее, гораздо проще
читать корректность.
Так, окей, допустим, мой смысл задачи
в том, что у меня есть несколько из токов.
Есть несколько
токов.
Ну, блин, ладно, не, плохая
картинка получилась, слишком большая.
Широкая. Давайте
ее нарисую поуже чуть-чуть.
Вот здесь моя сеть находится какая-то.
Вот такая вот у нас ситуация.
Вот как мне действовать?
Ну, допустим, я не знаю, у меня есть несколько
автопарков, откуда я могу машинки пускать,
несколько складов, несколько
приемных пунктов.
Мне в целом не очень важно, сколько
попадет, мне главное знать, сколько я могу
максимально увести со складов.
Ну да, это все превращается
опять же в розчерк ампера,
делается супер исток,
в который проводятся ребра бесконечной пропускной
способности.
Теперь это входит в сеть.
Здесь будет t1,
здесь будет tm.
Здесь опять же ребра бесконечной
пропускной способности
к суперстоку
t.
Ну, легко показать, что любой поток, который
вы провели здесь, может проведен бы здесь
и наоборот.
Здесь как бы легко построить биекцию,
поэтому это корректные сведения.
А сколько вы хотите?
Нет, ноль не хочу,
потому что если у меня здесь ноль, то я ничего
из t1 не выпущу.
Я хочу уметь выпускать все, что дошло до
сюда, а дойти
могло у меня очень-очень много, я не знаю
сколько, но бесконечность точно
хватит.
Сейчас.
Да, давайте даже это в определении
наверное запишу, что я с неравнотою.
Ну, тогда вы можете пускать
сколько угодно из себя в себя потока.
Ну, тогда ничего вам не мешает
пускать по циклу длины ноль потока, я не знаю.
Ну, да.
Ну, окей, да.
Вы можете разбить его фиктивно,
просто на две вершины явно разбить,
если очень хочется.
Если у вас ССТ равны, то
наверное вы делаете что-то не так,
потому что можно и ничего не делать.
Но если вам зачем-то хотелось погонять машины
из гаража в гараж,
то ну,
представьте, что это два разных гаража.
Вот, ну не знаю.
Таким приколам я еще не сталкивался.
Так, ну вроде бы мы это
осветили.
У нас остается
7 минут.
Ладно, давайте следующую часть
наверное в следующий раз начнем.
Потому что здесь
если формулы,
потому что там следующая часть,
это если говоришь А, говори B, C и D.
А если говоришь А, говори B, C и D.
Примерно такая.
Вот, окей, на следующей лекции
тогда мы научимся
скорее всего уже искать максимальный поток
и быть может
научимся это делать
плюс-минус быстро.
Где VE квадрат
это будет очень быстро
для нас на этот момент.
Ну тогда все на этом
в принципе на сегодня.
