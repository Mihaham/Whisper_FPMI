Так, мы продолжим говорить про потоки, давайте сначала
доведем до конца Эдмонскарпа, давайте напомню, что мы
успели сделать.
Мы доказали вторую лему, которая самосодержательная,
что в алгоритме Эдмонскарпа каждое ребро насыщается
не больше, чем от ВРАС, но отсюда следует, что алгоритм
работает за ВЕ квадрат.
Почему, ну, смотрите, понятное дело, напомню, что итерация
в алгоритме Эдмонскарпа, я называю запуск БФСа плюс
пропускание потока по кратчайшему найденному пути.
Эдмонскарп работает так, мы многократно делаем
итерации, на каждой итерации пускаем поток в той же
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем,
кратчайшем, кратчайшем, кратчайшем, кратчайшем,
кратчайшем, кратчайшем,
кратчайшем.
Иитает от weniger чем нулёгberg.
А сейчас я這裡 소리 звонит,
Значит, суммарная итерация от ве, потому что всего
е-рёбер, ну два е-рёбер, если мы считаем прямое и обратное,
по два раза их надо считать, значит, два е-рёбер, каждое
ребро вот столько раз насыщается, значит максимум от ве итерации.
Но раз итерации столько, а каждый работает, это просто
по сути бфс, ну значит нам нужно число итерации перемножить
на время работы бфс, и как раз получается ве квадрат.
Напоминаю, мы считаем, что е у нас больше, чем ве,
потому что иначе мы можем много ребер удалить, оставить
граф связанным, то есть все достижимое из с, тогда
е будет хотя бы ве-1 и можно считать, что оно асимпатически
больше.
Значит, суммарная симптотика это от ве на от бфс, есть
точность его от ве квадрат, доказали, просто будут.
Хорошо, тогда едем дальше, следующая идея, так называемая
техника масштабирования потока.
Вот, это скорее не алгоритм, а надстройка над любым алгоритмом
поиска максимального потока, то есть ее можно применять
и к Форт Фалкерсону, и к Эдман Скарпу, и к Деницу,
который мы сегодня тоже пройдем, ну и на самом деле
к другим алгоритмам поиска потока, которая в принципе
существует, вот, поэтому она может быть полезна как
надстройка над каким-нибудь алгоритмом.
Так вот, идея в следующем, смотрите, давайте мы скажем,
что пусть С большое это ограничение сверху на все
капасити, ограничение сверху на все пропускные способности.
Вот, ну еще я буду считать, что кратных ребер нет.
Раньше это было неважно, а здесь я подчеркну, потому
что это может быть существенно, кратных ребер нету.
Вот, тогда давайте делать следующее, ну давайте, например,
я скажу, что С равно 100, давайте мы будем идти по степеням
двойки в порядке убывания, то есть там 64, 32, 16 и так
далее, и будем пускать поток непрозвольной величины,
а вот в точности такой степени двойки, то есть если изначально
скажем С равно 100, мы будем пытаться пустить поток
величины 64, пустим все такие возможные потоки, то есть
найдем все пути, на которых есть поток величины 64, пропустим
их, дальше поток 64 мы уже пустить не можем, возможно
можем пустить поток величины 32, тогда соответственно какие-то
ребра у нас станут, можно будет опять использовать,
то есть если там капасти было 50, то 64 пустить нельзя,
а 32 уже можно, вот, и давайте допустим все потоки величины
32, потом 16 и так далее, и рано или поздно мы дойдем
до состояния, когда мы пытаемся пускать единичные потоки
величины 1, как очередная степень двойки, и тогда
понятно, что в конце мы все равно найдем максимальный
поток, то есть мы вот так вот идем и пытаемся сначала
какими-то большими батчами пускать по степени двойки
потока, сначала большие куски пытаемся переправить,
в самом конце дойдем до к равной единице, когда
будем пытаться пускать единицу потока, но это вот
более-менее то, что мы делали в Эдманскарпе, но тут на
самом деле не единичка пускается, а минимум из
капасити, но в худшем случае это единица, вот, а здесь
мы идем как бы начиная с больших величин потока
до самой маленькой, до единички, значит, сейчас я это напишу,
в цикле К от двоичного алгорифма С до нуля мы делаем следующее,
мы хотим пускать поток величин два степени К, для этого
я сделаю следующее, я все остаточные пропускные
способности округлю вниз до ближайшего числа кратного
вот этому 2 вкатый, то есть понятно, что число 100 превращается
в 64, потому что как бы, ну, больше чем 64 пустить нельзя,
ну а все, весь остальной остаток мне не важно, поэтому
я сделаю следующее, для всех ребер найдем, вот как раз
максимальное число снизу, которое делится на очередную
степень двойки, я напишу так, значит, С штрих от Е, это
остаточное капасити этого ребра делить на 2 вкатый умножить
на 2 вкатый, только после деления беру целую часть,
ЦФ делить на 2 втепняка, это как раз максимальное
степень двойки кратное, смотри, максимальное число
меньше либо равное остаточной капасити кратное 2 вкатый,
вот, и на такой сети я пускаю поток каким-нибудь алгоритмом,
там Форт Фалкерс, на самом деле не важно, вот в этой
сети, в сети с новыми капасити запускаем алгоритм поиска
максимального потока, вот, и поскольку теперь вот
в этой сети у меня все капасити кратные 2 вкатый, то понятно,
что любой путь, который я найду будет повельшине
ну хотя бы 2 вкатый, то есть я по нему смогу протолкнуть
хотя бы 2 вкатый единиц потока, точнее кратные 2 вкатые,
либо 2 вкатые, либо 2 на 2 вкатые, либо 3 на 2 вкатые и так далее,
ну и все, и так в цикле до нуля, когда кара равно нулю,
у меня будет просто здесь написано остаточное капасити,
да, потому что если кара равно нулю, то здесь я делю на
единицу, умножаю на единицу, значит корректность на самом
деле автоматически следует из того, что у меня рано
или поздно я дойду до последней стадии, когда кара равно нулю,
значит я ну по сути с осашенной капаситой ничего не делаю,
корректность на последней итерации, то есть когда кара
равно нулю, у меня вот эта вот моя сеть с штрихами совпадает
с сущностью с осашенной сетью, ну и поскольку я
в ней нахожу пути пока можно, то соответственно
у меня на последней итерации я как раз найду максимальный
поток, потому что по теориям Форт Фалкерсона поток
максимален, если только если в осашенности нет
пути, а на последней итерации я как раз просто, у меня
вот эта вот сеть с штрихами, это в точности осаточная
сеть, и я в ней нахожу все пути и соответственно
исчерпываю весь поток, который мог быть, значит на последней
итерации, остаточная сеть совпадает ну с вот этой вот
рассматриваемой, вот, значит алгоритм заканчивается
ровно тогда, когда нет путей в осаточной сети, поэтому
он корректен.
А что здесь с асимптотикой, то есть как бы корректно
здесь будьте здоровы, как обычно следует из Форт
Фалкерсона, что со временем работы, но вот на самом деле
независимо от того, какой вы алгоритм здесь пускаете,
Форт Фалкерсон и Ледман Скарп, асимптотика будет
на лог ц, асимптотика при использовании алгоритма
Форда Фалкерсона и Ледман Скарпа будет е квадрат на лог
ц.
Сейчас мы это докажем, ну лог ц понятно откуда берется,
потому что у нас лог ц итераций, лог ц значений принимает
переменная k, и вот хотелось бы доказать, что каждое
значение k работает примерно за е квадрат.
Давайте докажем, давайте это утверждение, доказательство.
Ну пусть, скажу следующее, пусть f это настоящий максимальный
поток, максимальный поток, а fкт это суммарный поток,
который я успел пустить за первые k итерации, то
есть вот у меня k убывает от лог ц до какого-то k,
и пусть fкт это сколько суммарного потока мы успели пустить.
Значит, общий пущенный поток.
На итерациях, собственно, от лог 20 до kт, если мы выполнили
первые вот столько-то итерации, сколько потока мы уже суммарно
пустили.
То есть тогда я утверждаю, что f не больше чем fкт, плюс
2хкт умножить на е.
Почему?
Ну смотрите, давайте рассмотрим, что происходит с нашей сетью
в конце ката-итерации.
Значит, с нашей сетью в конце ката-итерации происходит
следующее.
В ней, вот в этой сети, когда я вот так вот определяю
ее капасити, больше нет никакого пути из s в t.
Значит, вот если я рассмотрю вот эту вот сеть, где все
капасити кратны 2хкт, у меня есть s, у меня есть t, все
капасити кратны 2хкт, но пути из s в t нет.
Что это значит?
Это значит, что все вот эти вот ребра, которые были
в исходном графе между этими двумя долями, то есть по
факту я здесь опять пользуюсь Форт Фалкерсом тем, что
у меня есть разрез.
Что если у меня нет пути из s в t, значит есть...
Так, сейчас, одну секунду.
Ну да, значит есть...
Да-да-да, все правильно.
Значит, раз нет пути из s в t, значит по терям Форда
Фалкерсона есть разрез, величина которого равна
остаточному потоку, сколько осталось потока до конца
довести.
Вот я этот разрез нарисовал, здесь все ребра на самом
деле, они имеют капасити...
Сейчас, момент.
Туплю.
Туплю.
Два вкатые.
А, меньше два вкатые, меньше два вкатые, да.
Вот у них у всех остаточное капасити меньше, чем два
вкатые, потому что если было бы больше, соответственно
здесь было бы ребро графа, и тогда отсюда можно было
бы достичь вот эту вот вершинку.
Да, то есть еще раз, у меня нет пути из s в t, значит
есть разрез их разделяющий, поэтому все ребра исходного
графа, которые пересекают этот разрез, на самом деле
в этом графе не участвуют.
А раз они не участвуют, значит их остаточное капасити
меньше, чем два вкатые.
Было бы больше, оно бы вот здесь вот было бы.
Вот.
Значит здесь все ребра имеют капасити меньше два вкатые,
и их не больше, чем е, потому что всего е ребер.
Значит, суммарно величина вот этого вот разреза
не превосходит даже строго меньше два вкатые умножить
на е.
Это настоящий максимальный поток во всей сети.
Вот.
Значит мы показали, что после кат-итерации величина
разреза в исходной сети между s и t не больше, чем
вот это.
Ну а это в точности то, сколько потока осталось
пустить.
Вот я формулировал, что отсутствие пути из s в t в
нашей сети, новой, равносильно тому, что в исходной сети
величина этого разреза равна величине потока,
который осталось пустить.
Вот.
Ну значит как раз f – fk не больше, чем два вкаты
на е.
Да, потому что это сколько потока осталось пустить
до самого конца.
А это это величина разреза, которая вот равна всегда
величины потока.
Но это сколько потока осталось пустить до конца.
Сколько потока будет найдено на следующих террациях.
Вот, поэтому это утверждение мы доказали.
Вот, хорошо, а что дальше, зачем это нам нужно было?
Смотрите, когда это сделали, я хочу сказать следующее,
что на самом деле на каждой итерации, для каждого k,
количество ребер, точнее, количество путей, которые я нахожу в нашей новой сети
вот с этими странными копастями, это от E.
Сейчас мы это покажем.
Отсюда следует, что число путей, найденных на следующей итерации, есть от E.
Потому что, смотрите, я доказал, что то неравенство означает, что осталось, после k от итерации,
осталось пустить не больше, чем 2 вкаты на E потока.
Но, смотрите, на следующей итерации, что такое следующая итерация?
Это когда k равно k-1. На следующей итерации у меня все ребра будут иметь
капасти кратной 2 в степени k-1. Значит, каждый путь, который я найду на следующем шаге,
он вносит в ответ хотя бы вот столько. Но при этом внести нам осталось максимум 2 вката на E.
А если каждый путь, который я нахожу, вносит хотя бы столько, то суммарно пути не больше,
чем вот это поделить на вот это, то есть 2E.
Значит, каждый путь вносит хотя бы 2 в степени k-1, значит,
путей не больше, чем то, сколько осталось найти, поделить на то, сколько вносит каждый конкретный путь.
Окей? Ну, собственно, все. Это мы доказали, что на каждой конкретной итерации находятся
пути максимум от E. Ну, а нахождение любого пути это еще один от E. То есть, не важно,
Форд Фалкерсон у вас или Эдман Карп, находите путь вы за линейное время. Тут DFS, тут BFS.
Поэтому суммарно для каждого конкретного k у вас итерация работает за E квадрат,
ну и итерация локция. Поэтому такая символика получается. Окей? Ну, значит, тут самое главное,
что на каждой итерации мы находим максимум от E путей. Ну, а дальше уже просто надо посчитать,
за сколько находится каждый путь и сколько раз мы это делаем. Так. Вот такой прикол.
Ну и значит, на семинаре будет упражнение сделать то же самое для алгоритма Диница,
который мы сейчас начнем осматривать. Значит, сделать то же самое для алгоритма Диница.
То есть, для Форд Фалкерсон и Эдман Карп мы доказали, и для Диница тоже надо то же самое
сделать. Значит, давайте, собственно, тогда к нему и перейдем.
Для этого мне нужно будет два вспомогательных определения, оба не сложные. Значит, первое такое.
Первая – слоистая сеть. Слоистая сеть. Значит, слоистая сеть определяется так.
Смотрите, в алгоритме Эдманца Карпа мы находили кратчайшие пути из S до T.
Давайте мы вот, то есть с помощью BFS, давайте мы этот BFS оставим и для каждой вершинки
сохраним какое расстояние до нее нашлось. Дальше, давайте все вершины разобьем на кластеры
по, собственно, этому самому расстоянию. Соответственно, S будет сама по себе до нее расстояние 0.
Дальше будет некий набор вершин, до которых расстояние равно единице.
Дальше расстояние – 2, ну и так далее, вот вплоть до T, DST.
И оставим все ребра, которые идут только слева направо.
Вот это будет слоистая сеть. То есть слоистая сеть строится так. Я запускаю BFS,
разделяю, разбиваю все вершинки по классам по значению расстояния и оставляю только ребра слева направо.
Формально можно сказать следующее. VIT – это множество вершин таких, что DST S V равно I.
Я как раз классифицировал все вершины по DST. А дальше провожу ребра только слева направо,
только из I этого слоя V плюс первый. Давайте словами напишу. Оставляем только ребра слева направо.
То есть из VIT V и плюс первая для любого I.
Понятно, что ребро слева направо не может перескакивать через слой. Из V1 в V3 ребра быть не может,
потому что до этой вершинки путь длины 1, а для этой путь длины 3 кратчайше.
Но при этом есть вот такое ребро, до него был бы путь длины 2. Такого не бывает.
Поэтому ребра, идущие слева направо, они только в следующий слой идут. Из I V плюс первый.
Но через слой им прыгать нельзя.
Соответственно, слоистые сети я оставляю только такие ребра. Все остальные, которые ведут справа налево,
или которые зачем-то внутри слоя находятся, я их удаляю, я их просто игнорирую.
Второе определение.
Это блокирующий поток.
Тут вот так его проще всего задать. Это такой поток, который нельзя увеличить, не водя обратных ребер.
Пример.
Наш любимый вот такой вот граф.
Вот если я такую картинку нарисую, мы знаем, что здесь правильный поток имеет величину 2.
Капасти единичка сейчас все.
Но смотрите, если я пущу вот такой вот поток, глупенький вот такой вот, величины 1,
то он будет блокирующим.
Потому что не вводя вот это вот обратное ребро, которое на самом деле появляется в осадочной сети,
не вводя это ребро, я этот поток никак увеличить не смогу.
То есть да, конечно, правильный алгоритм вводит это обратное ребро и пускает такой поток,
отменяя какой-то плохой поток вот здесь, находя правильный поток 2.
Но вот если не вводить обратное ребро, то мы нашли блокирующий поток.
Один из блокирующих потоков.
Окей?
Хорошо.
Ну и тогда алгоритм Диница очень простой.
Мы просто строим каждый раз слоистую сеть, и в слоистой сети находим блокирующий поток.
Пока есть путь из СВТ в осадочной сети, мы строим слоистую сеть, и в ней находим блокирующий поток произвольный.
Пускаем блокирующий поток в слоистой сети.
ЖФ, ну в осадочной сети.
Так, в слоистой сети графа ЖФ.
Ну, как бы вот это условие можно было бы заменить на вайл-тру, грубо говоря.
То есть пока можно, мы делаем вот это вот действие, пока оно осмысленно.
Вот.
То есть смотрите, мы что делаем.
Вот у нас есть исходный граф, мы по нему построили слоистую сеть по этому правилу.
В ней нашли блокирующий поток, пустили его, и только после пропускания всего блокирующего потока начнем перестраивать сеть.
Мы ведем обратные ребра, у меня изменится осадочная сеть, потому что там какие-то ребра пропадают, какие-то появляются.
В частности, какие-то обратные появляются.
Дальше, по этой осадочной сети строим слоистую, в ней находим блокирующий поток, ну и так далее.
Опять перестроили осаточную, по ней слоистую, в ней блокирующий поток, и так по кругу.
Вот.
Ну и оказывается, что асимптотика вот такой штуки В квадрат Е будет.
Асимптотика.
В квадрат Е.
Что обычно лучше, чем Эдманскарп, потому что Эдманскарп это ВЕ квадрат, а здесь я квадрат перенес с Ешки на Вешку.
Это обычно лучше, потому что ребра обычно больше, чем верши.
Так.
Окей.
Значит, чтобы это доказать, что у нас засток работает, надо сначала разобраться, как мы будем искать блокирующий поток.
За сколько мы в слоистой сети можем найти блокирующий поток.
Ну, давайте опишем алгоритм, который находит блокирующий поток в осаточной сети.
Поиск блокирующего потока, извините, в слоистой сети, в слоистой сети, в слоистой сети, за ВЕ.
Если мы это научимся делать, то после этого надо будет показать, что число итераций, то есть перестраивания слоистой сети будет от В.
Тогда мы, соответственно, от В раз ищем блок поток в слоистой сети, а асимптотика будет как раз в квадрат Е.
Ну, пока давайте на этом сфокусируемся.
Значит, вопрос.
Представьте себе, что у вас есть такая слоистая сеть.
Вот она.
Вы хотите в ней найти какой-нибудь блокирующий поток?
Так, я, кстати, забыл сказать про корректность, но она здесь очевидна опять из Форт Фалкерсона,
потому что заканчивается наш алгоритм только в случае отсутствия пути из СПТ в осаточной сети,
а это в точности по Форт Фалкерсону критерии максимальности.
Поэтому я тут даже это забыл сказать, потому что это очевидно.
Вот эта первая строчка автоматически знает, что алгоритм корректный.
Итак, вернемся.
Значит, есть слоистая сеть, я хочу найти какой-нибудь блокирующий поток.
Давайте сделаем следующее.
Давайте будем в каком-то смысле просто жадно идти и пускать максимально возможный поток по каждому ребру.
Значит, что я имею в виду?
Смотрите.
Пусть мы начинаем в С, как-нибудь прошли,
и, ну понятно, нам нужно хранить минимально из вот этих capacity,
то есть какой поток мы можем пустить по вот этим ребрам.
Пусть мы находимся в очередной вершинке В,
и хотим дальше пустить как можно больше потока.
Но давайте просто перебирать все исходящие ребра.
И смотреть, что с ними происходит.
Значит, во-первых, вот если я рассматриваю очередное ребро,
надо не забыть, что оно находится на самом деле в слоистой сети.
Что оно ведет реально из предыдущего слоя в следующий.
Вот если это хорошее ребро, давайте попытаемся по нему протолкнуть этот поток,
ну и дальше с помощью какого-то DFS'а попытаемся найти путь отсюда до T.
Если получилось, то хорошо, вот мы нашли какой-то поток.
Ну, пока не блокирующий, но это какой-то поток, по этому пути можно что-то протолкнуть.
Но, более важное,
если мы не смогли отсюда дойти до T,
мы можем сразу сказать, что это ребро бесполезно, но мусорное,
его можно больше никогда не рассматривать.
То есть, если я использую это ребро,
отсюда не смог дойти до T, вот здесь нет пути до T.
Значит, это ребро больше никогда рассматривать не нужно.
По нему больше поток в принципе нельзя пустить.
Потому, что отсюда нет пути до T, значит, это ребро не участвует ни в каком потоке.
Вот, если мы это сделали, если мы нашли, что ребро бесполезно, давайте его таким пометим и больше его не использовать.
Собственно, это все, что будет нужно.
Значит, у меня в каждой вершинке будет, ну, давайте, у меня есть какая-то вершина, v, из нее выходят ребра,
и я постепенно буду их помечать бесполезными.
То есть, я, скажем, взял это ребро, не смог дойти до t, это ребро, ну, как бы удалил.
Я не буду удалять, просто буду помечать его бесполезно.
Дальше буду пытаться через это ребро пустить поток.
Если смог, ну, хорошо, потом я могу, если что, его переиспользовать.
Рано или поздно оно тоже станет бесполезным, потому что либо оно само насытится,
либо я отсюда просто не смогу дойти до t, потому что там какие-то другие ребра стали уже насыщенными.
Значит, это ребро станет насыщенным, ну и так далее.
И, ну, собственно, вот очень простой алгоритм, просто пока ребро, пока по ребру что-то можно пустить, пускаем,
а если нельзя, то, значит, это ребро можно игнорировать.
Значит, немножко деталей реализации.
Мне будет нужен вектор ptr, который для каждой вершины говорит номер первого интересного ребра.
ptr от v – это номер первого интересного исходящего ребра.
Интересно, это то, про которое мы еще не знаем, что оно бесполезно.
То есть, если оно бесполезно, то мы его должны игнорировать, а иначе, если мы про него еще не знаем, что оно бесполезно,
вот давайте с него пытаться начинать наш путь.
Вот. И тогда, значит, давайте напишем такой dfs.
Значит, пусть мы дошли до вершины v и смогли до нее довести f потока.
То есть, грубо говоря, f – это минимум из вот этих вот всех остаточных capacity.
То есть, я же как-то до сюда дошел.
Соответственно, f – это то, сколько поток я могу по этому началу пути протолкнуть.
Значит, условия выхода, если мы внезапно закончились, то надо просто вернуть f.
Да, у меня dfs будет возвращать, сколько потока мы нашли.
А иначе, мне нужно просматривать вот эти ребра в порядке вот, в том, в котором они занумерованы исходящие ребра,
и каждое еще интересное ребро, вдоль каждого такого ребра, попытаться протолкнуть какой-то поток.
Значит, это я сделаю следующим образом.
Давайте там уже.
Пока ptr от V меньше, чем количество ребер, то есть, меньше, чем в этой точке size tv,
Пока ptr от v меньше, чем количество ребер, то есть
меньше, чем wt.size, пока есть хотя бы одно интересное
ребро, про которое мы еще не знаем, что оно бесполезное.
Да, вот берем, берем его номер, пусть e это то
самое ребро.
Значит пусть e это ребро, исходящее из v, вот с этим
номером.
То есть это первое ребро, про которое мы еще не знаем,
что бесполезное, по которому мы сейчас будем пытаться
прогнуть поток.
Значит сначала давайте проверим, что оно реально
слой сети.
То есть это ребро слева направо, и оно, на нем не
нулевая capacity.
Я напишу так, если dist от v плюс 1 не равно dist от tu,
ну где tu это конец этого ребра, то есть e это ребро
из v2, да, e это ребро из v2, или это ребро насыщенное,
e capacity равно e flow, тогда я просто делаю continue.
Вот эта проверка отсекает все нележащие в слоистой
сети ребра.
Потому что в слоистой сети у меня только ребра слева
направо, то есть dist от конца должно быть на ничку
больше, чем от начала, и при этом capacity должна быть
положительная, а station capacity должна быть положительная.
Ну потому что иначе по нему ничего пустить нельзя,
оно нам точно ничего не даст.
Мы такие ребра игнорируем, на самом деле, sorry, тут не
continue, глупость написал, надо plus plus ptr at first сделать сначала,
после этого continue.
Ну потому что вот это конкретное ptr в это ребро бесполезно,
мы его помечаем бесполезным, сдвигаем указатель на
единичку, вот этот вот, и переходим к следующему
ребру, которым мы еще не знаем, что бесполезно.
Ну а иначе давайте сделаем следующее.
Мы считаем, что ребро e хорошее, пытаемся по нему что-то
пропустить.
Вопрос, сколько мы можем суммарно перенести потока,
если мы вот это вот ребро в конец нашего пути приклеиваем.
То есть мы сначала дошли от s до v, смогли здесь f потока
протолкнуть, и теперь еще вот вдоль этого ребра пускаем
поток.
Ну понятно тогда, что поток ограничен сверху f и остаточной
капастью этого ребра, а остаточная капасть этого
ребра это e cap – e flow, e cap – e flow.
Соответственно тогда я с помощью того же самого
DFS пытаюсь найти, сколько я могу до конца, то есть
до t, пустить потока из вершинки 2.
Вот я в вершинке 2 начинаю, потока не больше, чем вот
это вот количество, ну и сколько я могу до t довести.
Если вдруг так получилось, что x равно нулю, это как раз
значит, что ребро вот это вот e бесполезно, то есть
я до сюда дошел, пытаюсь что-то пустить, но не могу,
то есть я отсюда до t никак не могу добраться, то есть
передав положительное количество потока, я до t добраться не
могу.
Значит это ребро бесполезно, его больше никогда рассматривать
нет смысла, потому что если я до него вдруг дойду как-нибудь
по-другому, то все равно с его помощью я до t никак
не доберусь, поэтому больше его рассматривать нет смысла.
В этом случае я просто делаю, ну вот то же самое по факту,
помечаю его бесполезным и перехожу к следующему
ребру в цикле.
А иначе, если x положительное, значит я смог по вот этому
пути от s до v через ребро e до t пропустить поток x, вот
здесь вот везде я должен пропустить x.
Ну давайте тогда, чтобы этот x учесть, я сделаю, я его
учту для ребра e, а на всех остальных ребрах его учтет
dfs, который те ребра рассматривал.
Значит я сделаю так, e flow плюс равно x, потому что я
на этом ребре пустил поток x.
Вот и здесь же мне нужно не забыть, что у меня на самом
деле же обратные ребра на самом деле присутствуют
во всем графе.
Мне нужно не забыть, что на обратном ребре я пускаю
получается минус x, всегда если я по одному ребру, по
прямому ребру пускаю x, то по обратному надо не забыть
вычесть x, ну потому что у меня антисимметричность
потока есть.
Значит здесь мне нужно написать что-то типа для обратного
ребра, да, reverse вот e, точка flow, мне нужно сделать минус
равно x.
Вот.
Ну и все, после этого можно сделать return x, как знак
того, что какой-то поток я протолкнул, а если у меня
весь этот файл закончился и я ничего не вернул, то
мне нужно сделать return 0, все, и на этом dfs закончился.
Вот.
То есть что делать dfs, он в самом начале, да, как я
его буду вообще вызывать?
Я его из main буду вызывать так, dfs, s бесконечности.
То есть я стою в s, говорю, что я могу сюда привести
сколько-года много потока, и дальше ты, пожалуйста,
найди мне какой-нибудь путь, протолкни хоть какой-нибудь
по точек, по какому-нибудь пути, да, вот с помощью этой
процедуры.
То есть мы по факту просто идем как-нибудь, что можем
проталкиваем, если какие-то ребра помещаются бесполезными,
то мы их больше никогда рассматривать не будем.
Вот.
И, соответственно, блокирующий поток, поиск блокирующего
потока работает так, пока эта штука возвращает положительную
величину, мы ее запускаем многократно.
То есть пока эта штука возвращает что-то положительное,
то есть пока в осадь bucket есть путь, я просто ее запускаю,
запускаю, запускаю много раз, пока хоть что-то пропускается.
Как только ничего не пропускается, значит у меня все
рёбра стали бесполезными, я ничего пустить больше не могу.
Так, давайте это запишем тоже. Блок поток. Ну и так очень некрасиво
напишу, пока dfs, s бесконечность больше нуля. То есть пока
у меня получается пустить положительный поток,
я его запускаю, запускаю, запускаю. Как только эта штука вернула ноль, значит больше
потока я пустить не могу без введения обратных рёбер. Ну и у меня этот вайл
соответственно заканчивается. Пережив. Так, давайте продолжать.
Чего? Мы хотим понять, за сколько это работает. То есть я научился
находить какой-то блокирующий поток, вопрос это за сколько было. Я утверждаю
следующее, что если, давайте рассмотрим какой-то запуск, вот конкретно dfs, s
бесконечность. Вот я, вот я из моего мейна запускаю dfs, s бесконечность. Вопрос
за сколько он отработал. Давайте скажем, что суммарно все ptr вот эти вот
увеличились на k. Пусть суммарно все ptr увеличились на k. То есть вот если я
посчитаю, сколько раз у меня вот этот вот ptr увеличился или вот этот, вам там
удобно? Отлично. Вот сколько суммарно было вот этих плюс-плюсов, пусть их было
ровно k. Тогда я утверждаю, что время работы вот этого dfs, вот этой вот штуки,
есть v плюс k. Почему? Потому что, смотрите, давайте рассмотрим вот окончание, когда
это dfs закончил работу. Что это значит? Это по факту значит, что он нашел какой-то
путь из s в t и пустил по нему какой-то поток. Ну либо он вообще рассмотрел все возможные
пути и сказал, что пути нет. Давайте общий случай, когда он нашел путь. Вот он нашел
какой-то путь. И что он еще сделал? Для того, чтобы его найти, он несколько раз увеличил ptr.
То есть он какие-то ребра помечал бесполезными. Вот тут или вот тут. То есть он еще какие-то
ребра рассмотрел и пометил их бесполезными. Снял с них ptr, то есть мы их больше рассматривать
не будем. Поэтому на самом деле суммарно время работы вот этого dfs, это сколько ребер он
просмотрел и пометил бесполезными, плюс вот это количество ребер на этом пути. Ну потому что
что делает dfs? Он рассматривает ребра в каком-то порядке и либо он ребра помечает бесполезным,
либо это ребро участвует в нашем пути от s до t. Время работы dfs вот этого вот,
это просто число просмотренных ребер. Вот таких вот ребер мы просмотрели k, вот таких
мы просмотрели v, потому что в слейстой сети расстояние от s до t максимум v. Ну значит вот
время работы v плюс k. Чудесно. Значит время работы одного dfs v плюс k. За сколько работают вот эти
многократные запуски dfs тогда? Но мне нужно его пускать, пускать, пускать, пока пускается, да,
то есть пока он что-то находит. Вопрос сколько раз это может происходить? Да, вопрос к вам,
сколько максимум раз может dfs запуститься? Да, вот этот while сколько сколько раз он может
запустить dfs с бесконечности? Вот как говорит vector, это говорит e, а почему v? Вроде e я могу только
сказать. Да, значит давайте напишем, что число запусков, да, да, да, число таких запусков есть
от e, потому что каждый запуск насыщает хотя бы одно ребро, а значит оно помещается бесполезным и
значит его больше мы не рассматриваем. Но суммарно по меток бесполезности максимум e потому что
всего e ребер. Так как хотя бы одно ребро насытится, значит помещается бесполезным. Ну вот,
значит у меня e раз опускается такой dfs, каждый dfs работает за столько и вот пусть, соответственно,
k1 и так далее k e это то насколько сдвинули суммарно все ptr на очередной итерации. Тогда время работы
будет, ну давайте суммарно, у меня будет сумма по e итерациям o от v плюс k i t. Вот, ну здесь будет
v e, а здесь будет сумма всех k i t, сумма всех k i t это o от e, потому что k на сколько сдвинутся
указатели, ребер всего e, значит указатели суммарно сдвинутся максимум на e. Значит у меня
получился алгоритм за v e. Так, все, значит мы сделали то, что я обещал, мы нашли блок поток за v e.
Прекрасно. Теперь я хочу доказать, что, я хочу доказать, что суммарное количество раз,
которые мне потребуется искать блок поток, это будет o от v, тогда будет как раз такая симптомика.
Для этого я покажу следующее. После каждой итерации, после каждой итерации, ну то есть когда я нахожу
слоистую сеть, в ней блокирующий поток, вот после этого, после того как я пустил блок поток в новой
сети, у меня увеличивается расстояние от s до t. Расстояние от s до t увеличивается. То есть после
пропускания блокирующего потока в слоистой сети, у меня новый дист в остаточной сети будет больше,
чем старый. Дист-штрих больше, чем дист-ст. То есть скажем, если у меня раньше была слоистая сеть вот
такая вот, расстояние было тройка от s до t, то после пускания весь блок потока у меня расстояние будет
хотя бы 4, строго больше, чем раньше. Почему так? Потому что мы нашли блокирующий поток, значит в
каком-то смысле мы исчерпали все пути текущей длины, вот этой вот старой длины st. Значит блокирующий
поток исчерпал все пути вот такой длины, все пути длины st, длины диста st. Давайте картинка,
вот была наша слоистая сеть, все ребра шли слева направо, я нашел в ней какой-то блокирующий
поток, его пустил. Я утверждаю, что после того, как я пустил блокирующий поток, у меня в новой
остаточной сети, если я ввожу обратные ребра, как и надо делать в обычном алгоритме, у меня не будет
ни одного пути той же самой длины от s до t, какой был раньше. То есть если какой-то пути будет,
то только больше. А давайте вообще поймем, что происходит с сетью остаточной после пускания
здесь блокирующего потока. Значит как выглядела сеть изначально? Мы знаем, что есть ребра слева
направо, мы знаем, что есть ребра внутри слоя, и есть, возможно, ребра справа налево. Других ребр
не бывает. Либо внутри, либо справа налево, либо слева направо, из одного слоя в следующий.
Значит после того, как я пустил здесь блокирующий поток, у меня не осталось ни одного пути от s
до t по ребрам слева направо, на котором был бы положительной остаточной капасити. То есть любой
путь из s в t, вот такой вот прямой, давайте опять возьму цветной мелок, значит любой путь слева
направо, он уже исчерпан. Потому что, ну, иначе можно было бы его добавить и увеличить блокирующий
поток. Значит на любом таком пути, на самом деле, хотя бы одно ребро насыщенное, значит этого пути
в остаточной сети уже нету, его как бы не существует, нельзя вот s до t по нему добраться. Давайте посмотрим,
какие могут быть другие пути. Можно ли после проведения блокирующего потока найти поток
меньше длины, путь меньше длины или такой же? Ну вот нельзя, потому что как вообще может
выглядеть любой путь отсюда до сюда в новой сети? Что у нас вообще происходит после того,
как я блокирующий поток провел? У меня какие-то ребра исчезли, потому что насытились, скажем,
вот это ребро могло исчезнуть. И какие-то ребра могли появиться, но ребра только справа налево
появляются, потому что появляются только обратные ребра, обратные к прямым, то есть из и плюс первого
слоя вытой. Поэтому изменения только в том, что какие-то ребра слева направо пропадают, а справа
налево появляются. Ну тогда понятно, что кратчайший путь от s до t мог только увеличиться по длине,
да, ну потому что за один шаг я могу прыгнуть только в следующий слой, и если, скажем, ну путь был бы
той же длины, то у меня получается мне нужно отсюда до сюда прыгнуть, отсюда до сюда, сюда-сюда-сюда,
но все такие пути исчерпаны. Значит единственная возможность это, ну что-то вот такое, сюда-сюда,
потом вернулись, потом опять сюда, потом как-нибудь вернулись, ну короче вот как-то так, он мог
быть только длиннее. Ну значит дист увеличился. Давайте это я что-нибудь здесь напишу. Так, момент.
Давайте напишу так, чтобы путь имел меньшую длину, меньше либо равную длину, значит он должен идти
только по ребрам слева направо, потому что если он использует хотя бы одно ребро справа налево,
то значит его длина уже точно больше, ну потому что вот быстрее, чем за количество слоев плюс
один, мы добраться точно никак не можем, потому что каждое ребро только на один слой вперед нас
проталкивает. Значит чтобы путь имел длину не больше, чем раньше, он должен проходить по всем
слоям в порядке слева направо. Походить по всем слоям в порядке слева направо. Но поскольку мы
пустили блокирующий поток, то все такие пути исчерпаны, по ним ничего больше пустить нельзя. Ну все,
значит меньше либо равно иметь нельзя, значит будет только больше. Но все такие пути исчерпаны.
Все, значит дист штрих строго больше мдист эста.
Ну и отсюда не следует, что время работы это v квадрат на e. Алгоритм работает за v квадрат на
e. Потому что каждая итерация работает за v, а каждая итерация это поиск блока потока за
ve. И итерация максимум от v, потому что дист не может возрастать больше, чем до v. Значит итерация
за ve, а всего итераций от v, потому что каждая итерация увеличивает дист хотя бы на единичку. Дист не
может быть больше, чем v, потому что если в графе v вершин, то украшение не больше, чем v, не больше,
значит их от v. Ну все, получили v квадрат e. Так, хорошо. Значит, секунда рассуждений. Смотрите,
все эти симптотики, которые я пишу, v квадрат e в Диннице, ve квадрат в Эдманскарпе или там f на
e в Форт Фалкерсоне, они все теоретически, я скажу так. На самом деле на практике они работают гораздо
быстрее, чем если вы просто посчитаете вот эту величину и поделите на количество операций в
секунду. На самом деле поток найдется, скорее всего, гораздо быстрее. Почему? Ну потому что вот
эти вот условия, которые вот такую асимптотику дают, они тяжело достижимы. Давайте проанализируем,
когда здесь достигается v квадрат e. Во-первых, мне нужно, чтобы на каждой итерации дист увеличился
ровно на единицу, чтобы итерация была e. Во-вторых, мне нужно, чтобы при поиске блокирующего потока
каждый поток насыщал только одно ребро. Вот из всего длинного пути только одно ребро насыщалось,
тогда будет как раз ve вот здесь время работы. Ну понятно, что это не очень правдоподобно. Наверняка
там каждый путь, ну несколько ребер насытит. Особенно если у вас там все capacity довольно
маленькие, capacity числа от 1 до 10, например, тогда понятно, что вместе с одним ребром насытится
еще все такой же capacity, ну то есть там несколько, грубо говоря. Поэтому вот такая асимптотика,
она, наверное, не очень достижима. Это очень неформальное рассуждение. Ну на пальцах почему
здесь, почему может быть сильно лучше, чем вот это. И то же самое с Edmunds Carp, и то же самое с
Fort Falkers, потому что они только в худшем случае работают за вот это время какое-то, но на практике
часто лучше. Есть еще теоретические оценки, вот мы сейчас еще на них посмотрим, как можно
еще жестче, еще строже оценить теоретически время работы алгоритма Деница. Вот мы сейчас их
подоказываем, что в некоторых специфических графах можно теоретически доказать, что время
работы будет еще лучше. Так, для этого нужны будут определения. Пусть, ну там, как обычно, G, S, T, C это
сеть. Значит, для любой вершины я могу определить C in от V. Это сумма всех входящих capacity. И C out от V.
Это сумма всех исходящих capacity. Так, sorry, здесь U, здесь U, здесь capacity U V. То есть это вот вершину
я складываю сколько входит суммарно и сколько выходит. Не потока, а capacity. Вот, и потенциалом
вершинки P от V я назову минимум из этих двух величин. Минимум из C in от V и C out от V. Потенциал
вершины V. Общий потенциал сети это сумма по всем вершинам, сумма потенциалов по всем вершинам.
Теорема. Число итерации алгоритма 1 не превосходит корни SP. Число итерации алгоритма 1 есть от корни
SP. Поэтому если вдруг вот это вот сильно лучше, чем V, да, у нас пока что мы пока что знаем только,
что число итерации есть от V. Если вдруг P, точнее корень SP сильно меньше, чем V, то это дает более
содержательную оценку на время работы денницы. Особенно это здорово работает, если у вас,
например, ну до этого дойдем, да, но если, например, сети деничные, у вас все capacity равны деничке,
тогда у вас вот эта вот штука, сумма, она на самом деле будет от E. Ну потому что вы как бы здесь,
это у вас что-то типа степени вершины, и вы складываете в степени всех вершин. И тогда у
вас P это от E, и здесь будет корень из E вместо V. Ну понятно, что корень из E очень часто лучше,
чем V. Поэтому это полезная оценка будет. Ну чтобы доказать, опять надо будет повозиться с графами.
Так, ну да, шлема первая. Пусть L это distance t, пусть F это величина максимального потока,
а P это потенциал сети. Вот это вот P. Тогда L, не помню, надо списать,
меньше это равно, чем 1 плюс P делить на F. Доказательства. Давайте нарисуем слоистую сеть.
Вот наша слоистая сеть, выделим в ней все слои. Это будет в L минус 1, t будет в L там
слои, соответственно. И давайте в ней нарисуем наш вот этот поток F максимальный. Я утверждаю,
что, ну давайте я введу обозначение, пусть P i t это сумма по всем V из V i, потенциал в вершинке V.
Так вот, я утверждаю, что поток не больше, чем потенциал каждой конкретной доли для всех i от
1 до L минус 1. На пальцах объяснений смотрите. Вот я рассматриваю какую-нибудь конкретную долю,
вот V2, например. Что такое P i? Это для каждой вершины минимум из того, сколько сюда втекает,
точнее сколько может втечь и сколько может вытечь. То есть по факту P от V это какое-то
ограничение сверху на то сколько сквозь вершину протекает. Потому что втекает не больше, чем столько,
вытекает не больше, чем столько, значит поток, идущий сквозь вершину не больше, чем минимум
из них. P от нее дальше. Дальше. И так я для каждой вершины считаю Ограничение сверху на то сколько
потока через нее протекает. Но тогда понятно, что поток от S до T он рано или поздно вот эту
как бы проходит да то есть вот рано или поздно поток протекает сквозь очередную долю ну и
понятно тогда что он не больше чем суммарный потенциал всех этих вершин f не больше чем чем
pi значит да 1 плюс п делить на f еще раз нет это извините ага не это у меня осталось просто
прошлого раза вот значит поток текущий сквозь долю не больше потенциал этой доли значит если
это давайте вот такого рассуждения будет достаточно если мы хотим это чуть более формально
доказать нам нужно будет на самом деле такое утверждение было бы нужно такое утверждение
значит лемма о декомпозиции потока которая должна была быть на семинарах лемма декомпозиции
потока что любой поток можно представить как сумму путей плюс циклов любой поток это сумма
путей плюс сумма циклов вот ну циклы понятное дело вносят нулевой поток но как бы они фиктивно
могут какие-то эвки добавлять на ком-то цикле и не не вносить содержательного вклада в настоящий
поток вот а пути это ну пути там с единичным потоком как могут у нас здесь эти пути выглядеть
если он вот такой вот просто слева направо то это прям идеальный поток он как раз проходит
через каждую через каждую долю ровно один раз и смотрите он задействует единичку входного
единичку входного капасти вершину и выходного капасти из вершины поэтому как раз ну вот там
единичка потока равна единичке вот которая может сюда втечь и вычесть вытечь бывают еще правда
плохие пути какие-то вот такие вот например которые многократно через нашу долю через
нашу долю протекают но тогда смотрите единица потока обеспечивал нам сразу много капасти вот
здесь вот единичка втекла вытекла здесь единичку вышли и здесь еще единичку ушли то есть чтобы
пустить единицу потока я потратил аж три capacity вот здесь одна здесь другая здесь третья поэтому
f не больше чем чем суммарно p и ну и там если вот формально все эти пути расписать то будет как
раз такая оценка что поток не больше чем чем чем потенциал вот она пальцах это просто сколько
потока протекает через вот вот этот разрез ну все теперь это просуммирую получу получу то что
нужно значит суммируем по всем и суммируем по всем и получаем l минус 1 f не больше чем сумма
п это не больше чем п потому что п это общий потенциал п это потенциал в доле в этой доле ну
если я здесь поделю на f получится поделить на f и прибавлю единичку как раз или не больше чем 1
плюс п на f лемма вторая потенциал сети величина постоянная и не зависит от того какой какой
п не изменяется при переходе от g gf то есть если у меня был какой-то потенциал для старой сети g
я пустил какой-то поток и перестроил нашу сеть то есть пришел к оставшему сети так вот я тоже
что потенциал не изменяется но здесь нужно на самом деле добавить ремарку что в отсутствии
рёбер ведущих в s или исходящих из t ведущих в s или исходящих из t ну понятно что эти рёбра
бесполезные да есть у меня есть с и в него входят какие-то рёбра то я могу их смело удалить
потому что нет смысла какой-то водичке в текать в с она отсюда вытекла как-то она сюда обратно
попала и то и дальше потом пошла ну понятно что такие рёбра они как бы нам ничего не дают их можно
смело удалить вот поэтому если их нет я могу то есть если они есть я могу их удалить или ему будет
будет верна полностью доказательства ну тут все очень просто надо проследить за каждой вершиной
что с ней происходит когда я пускаю какой-то поток вот если у меня был какой-то путь я по
этому пути пустил f потока надо просто понять как у меня меняется c in c out значит вспоминаем
что если я пустил v потока по sorry f потока по ребру у меня на самом деле по обратному
ребру появляется минус f потока минус f потока соответственно здесь копасть уменьшилась на f
здесь уменьшилась на f а на обратных ребрах наоборот увеличилась на f ну и отсюда все следует
потому что давайте посмотрим на цин как поменялся цин как поменялась цин рассматриваем входящие
ребра вот это вот и вот это вот здесь capacity упала на ц и а здесь увеличилась ссори здесь
capacity упала на f а здесь увеличилась на f значит у нас сумма не изменилась плюс f минус
поэтому при проталкивании f потока вдоль какого-то пути цин для вершины на этом пути не изменилась
потому что здесь уменьшилась здесь увеличилась на f то же самое с ци аут как поменялась ци аут
ну то же самое рассматриваем все исходящие ребра вот они два здесь упала на f здесь увеличилась
на f осаточная capacity но поэтому ци аут тоже не изменилась то же самое плюс f минус f и так для
всех вершин и какой бы поток я не пустил то есть если опускаю поток там да вот очередную порцию f
потока пустил для любой промежуточной вершины у меня ци аут остались такими как были значит
праут значит прадвэ тоже не изменилась но раз прадвэ не изменилась то и весь потенциал не
изменился окей так ну все тогда мы готовы доказать эту теоремку
тоже именная теорема корзанова
теорема корзанова число итерации в алгоритме 1 не происходит корни из я
число итерации в алгоритме 1 есть футы корень исп от корни сп от корни сп
доказательства давайте мы запустим алгоритм 1 на корень исп итерации вот нам нам разрешили
от корни сп давайте корни сп запустим запустим первые корни сп итерации алгоритма 1 если он
успеет завершиться за эти корни сп итерации то мы же победили если он закончился то ну число
итерации есть вот корни сп значит если он не закончился если он не закончился мы можем написать
что дист ст больше либо равно корни сп потому что по одной из лям которые мы когда-то доказали мы
знаем что после каждой алгоритма 1 расстояние восстанчивой сети между стт увеличивается хотя
бы на 1 каждый раз увеличивается если я сделаю столько итераций то после этого количества
расстояние будет хотя бы число итерации хотя бы корень сп то есть смотрите я я пустил сколько
это раций пустил какой-то поток дальше восстанчивой сети у меня расстояние хотя бы корень исп давайте
тогда посмотрим на лему 1 пусть давайте применим лему 1 к остаточной сети в ней л это дист ст хотя
бы корни сп f это сколько потока осталось пустить до самого конца до победы сколько осталось пустить
сколько осталось пустить потока на дополнение до максимально вот я уже сколько допустил
рассматривать столько осталось до конца вот это вот f максимальный поток восстанчивой
сети это сколько осталось потока вот ну а потенциал п это потенциал исходной сети
Давайте я напишу так. p от g f равно p от g. Это по второй лемме. Потому что потенциал не
меняется при переходе касашной сети. По второй лемме. Ну все, теперь применяем первую лему вот
к этим числам, что-то получаем. l не больше чем 1 плюс p на f. Дальше оцениваю l снизу корнем из p,
и решаю это как неравенство относительно f. Получится p делить на f больше или равно корень
из p минус 1. Ну наверное там все числа положительные, поэтому f меньше либо равно p делить на корень из p
и singing f-1. Cколько осталось пустить потока f не больше, чем p делить на корень из p минус 1,
ну это примерно корень из p. Если бы не былоUM-1, бы просто был корень из p. Ну подумайте,
асимптати joue не влияет ни на что. Осталось пустить потока от корня из p. Ну значит понятно,
не больше, чем от корни СП, потому что каждый террация хотя бы единичку потока-то находит.
Каждая террация строит слоистую сеть, в ней находит поток блокирующий,
и понятно, что он положительный, потому что есть путь из С в Т.
Значит, суммарно осталось до конца террации не больше, чем f, то есть не больше, чем от корни СП.
Значит, давайте здесь напишу.
Значит, осталось от корни СП террации.
Конец. Мы сделали корень СП террации, потом еще осталось сделать от корни СП.
Суммарно это от корни СП.
Так, вопросики есть?
Ну вот, хорошо.
Значит, давайте тогда пример один я напишу.
Идиничные сети.
Значит, сеть называется единичной, если в ней все капасти от 0 или единицы.
В ней, во-первых, П это от Е.
Ну, потому что давайте напишем, что давайте я напишу вот так.
Я здесь только так умею это нормально объяснять.
Ну, то есть В это минимум из C in и C out.
Минимум не больше суммы.
А это просто степень вершины В.
Сколько ребер входит, плюс сколько выходит.
Ну, значит, П.
Не больше суммы степней, то есть 2E.
Поэтому П это от Е.
Значит, число итерации будет от корни СЕ.
Уже хорошо.
От корни СП, но от корни СЕ итерации.
Более того, мы можем оценить не только число итерации,
но можем еще оценить, за сколько работает каждая итерация.
Значит, за сколько работает каждая итерация.
То есть за сколько работает пояс блокирующего потока.
Вот я вот и жажду за О от Е.
Значит, раньше блокирующий поток я умел искать за ВЕ.
В произвольной сети, ну, в слоистой сети я ищу поток, блокирующий за ВЕ.
А вот если она единичная, то на самом деле это работает,
вот тот же самый алгоритм работает за просто О от Е.
Потому что, давайте вспомним, да, как у нас работает каждый запуск ДФСа.
Каждый запуск ДФСа находит какой-то путь из С в Т
и еще какие-то ребра помечает помеченными, бесполезными,
которые больше не обращаются.
Ну, понятно, что суммарное количество ребер, которое я здесь посмотрел...
Да, то есть самое важное следующее, что когда я нахожу какой-то путь,
у меня все эти ребра сразу автоматически становятся насыщенными.
Потому что все копасти единичные, вот в этой остаточности все копасти единичные,
и когда я пускаю поток по какому-то пути,
я могу сразу сказать, что эти ребра бесполезные.
Поэтому у меня каждый ДФС работает за количество ребер,
которые он помечает бесполезными, то есть он эти помечает бесполезными
и эти сразу помечает бесполезными.
Но значит суммарно все ДФС работают за число ребер.
Просто потому, что каждый просмотр каждого ребра,
либо он говорит, что он бесполезный, потому что из него нельзя добраться до Т,
либо оно полезное, выпускаю вдоль него поток,
он сразу насыщается и больше его брать нельзя.
Оно сразу становится бесполезным.
То есть причем любой просмотр ребра finestive,
потому что любой просмотр ребра,
давайте я напишу так, любое ребро просмотрено не более одного раза.
Любое ребро просмотрено не больше одного раза.
Ну а значит, суммарно это будет вот E.
Вот, получается, если сеть единичная,
то у меня столько итераций, и каждый работает за вот столько.
Поэтому суммарно единица работает за E корней из E.
Значит, алгоритм единица в единичных сетях
будет работать за E корней из E.
Ну и второй пример еще более стильный.
Хотя мы, наверное, его не успеем.
Давайте тогда, возможно, в следующий раз забудем про него.
Все, спасибо, на сегодня закончили.
